00:01:45 <jrockway> "f" (in the paste)
00:01:54 <jrockway> but actually, when i copy the file over, it works there too
00:01:58 <jrockway> so my test case at work was wrong
00:02:04 <jrockway> but ... it's essentially the same
00:02:08 <jrockway> using if/then instead of guards
00:16:26 <nus> jrockway, perhaps comparing desugared versions would help understanding what's going on.
00:19:23 <jrockway> where do i have too much sugar?
00:19:45 <jrockway> (if/then/else instead of guards?)
00:20:15 <jrockway> or doing it without a monad?
00:20:20 <jrockway> that is not a bad idea
00:33:57 --- topic: '["msg an op if you can't talk", "find ops: /msg ChanServ access list #haskell", "Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]'
00:33:57 --- topic: set by mauke on [Mon Jan 18 11:11:51 2010]
00:33:57 --- names: list (clog BONUS jlouis electrogeek alexsuraci davidL Laney otto_s Paradox924X niksnut qebab wisemanby koala_man dibblego dfeuer kynky trofi Argue dobblego syntaxglitch Niccus ablokzijl naten s76_ mikezackles wolverian ts33kr proq nick8325 jmcarthur gds Heffalump deavid mokus kmc ivanm a11235 mblondin jonafan stoop dnolen EvanCarroll jfredett jql Huggles_sipna newsham bwr Valodim ortmage AtnNn calvins eldragon DekuNut Cthulhon Muad_Dibber Draconx pflanze)
00:33:57 --- names: list (Draconx|Laptop pantsman yrlnry nainaide alip Nereid_ cheater nainaide_ Raynes Daminvar Bassetts Cale skeptomai|away tab Zeiris_ aluink gnuvince domor pikhq Dashkal dmwit baaba And[y] ski_ mereale bob0 cods tltstc petekaz Aisling koninkje_away FauxFaux Wooga nus bind_return jystic ville sjanssen beza1e1 JaffaCake nothingmuch StarFire Baughn IceDane mfoemmel BurgessShale McManiaC tomoj Deewiant suiside andrewsw G0SUB aiko tamiko Jaak saccade blackdog PepeSilvia)
00:33:57 --- names: list (jix epmf Bleadof lpsmith netcat ziman Sagi SubStack Raevel sshc glith MadX` djinni orbitz amiri duairc dufflebunk Vq shawn Milo- MrDomino [S] elspru shrimpx _br_ DrSyzygy kw317 blazzy canvon qm13 guerrilla rntz drhodes sothim mjrosenb int_e NEEDMOAR dang`r`us anee mattam Lemmih wto jrockway medfly chaoyi cheater2 Taejo pcc1 @ChanServ jayne)
00:34:14 <medfly> sweet.
00:34:26 <jrockway> -> 218
00:34:27 <jrockway> :)
00:34:32 <medfly> it's like watching a flood or a tornado
00:34:37 <yrlnry> what just happened exactly?
00:34:41 <medfly> yrlnry, new ircd
00:35:01 <medfly> yrlnry, they re-started all the servers
00:38:14 <pretsas> What just happened?
00:38:31 <medfly> pretsas, they switched to a new ircd. they restarted all the servers.
00:38:35 <pretsas> Ah
00:41:26 <Gracenotes> there are tildes in hostmasks now
00:41:33 <copumpkin> zomg
00:41:40 <yrlnry> copumpkin++
00:41:42 <copumpkin> such technology!
00:41:51 <copumpkin> yrlnry :)
00:41:59 <jinjing> is it possible to give an instance to () ?
00:42:10 <ivanm> yrlnry: so you gave him karma for something he says quite regularly?
00:42:17 <copumpkin> jinjing: sure, why not? it's already an instance of many things
00:42:18 <ivanm> jinjing: yes, as long as there isn't an instance for it already
00:42:22 <yrlnry> ivanm:  So it would seem.
00:42:23 <Gracenotes> yes, the type name is just ()
00:42:55 <copumpkin> zomg
00:42:58 <tomoj> what's () for anyway?
00:43:03 <ivanm> see? case in point!
00:43:03 <jinjing> thanks copumpkin, ivanm, is there an example?
00:43:10 <ivanm> tomoj: the same as "void" in C, etc.
00:43:23 <ivanm> tomoj: i.e. "I don't want to return a value but I have to"
00:43:26 <copumpkin> instance Enum () where toEnum 0 = (); fromEnum () = 0
00:43:29 <tomoj> oh, yes, I knew that, but didn't realize it
00:43:32 <jinjing> oh got it
00:43:32 <medfly> oh
00:43:34 <tomoj> seen IO () all over the place
00:43:38 <ivanm> or instance Show () where show _ = "()"
00:43:41 <Gracenotes> it's a unit type: a type for which only one value exists (boolean, by contrast, is a type where only two values exist). more useful than you'd think.
00:43:53 <Gracenotes> (this is all not including bottom)
00:43:54 <ivanm> tomoj: exactly; it has to have a return type but in most cases we don't actually want one
00:44:00 <ivanm> Gracenotes: yeah
00:44:50 <jinjing> thanks everyone
00:46:40 <Gracenotes> tomoj: C, Java, etc. are about executing procedures, nested, one after another. Haskell is more about combining expressions. So to execute two IO things, for instance, we combine one IO () with another IO (), using monad functions. () is like a token you get that the action's run.
00:54:13 <Gracenotes> also, finally, SSL!
00:55:56 <ski_> (ivanm : it should be `show () = "()"' rather than `show _ = "()"')
00:56:06 <ivanm> ski_: well, yes
00:56:21 <ivanm> but since we know what the value we're getting is going to be, why make it explicit?
00:56:43 <ski_> (i'd show `show (undefined :: ())' if lambdabot or lunabot had migrated yet)
00:56:56 <ski_> ivanm : it could be looping
00:57:10 <ski_> so we don't "know what the value we're getting is going to be"
00:57:21 <ivanm> ski_: hmmm?
00:57:29 <ivanm> in which case, isn't my version better?
00:58:03 <ski_> see e.g. the `rnf' (iirc) combinator which takes a value and forces it, returning `()'
00:58:24 <ski_> if you don't force the result `()', then the input won't get forced, either
00:58:52 * ivanm is confused
00:59:04 <ski_> (and yes, you could explicitly `case ... of () -> ...', but it seems more uniform to force for `()', just as for `Bool', &c.)
00:59:08 <copumpkin> it's called deepseq these days
00:59:25 * ski_ hasn't used it much
00:59:35 <Gracenotes> down in the deep blue seq
00:59:58 * ski_ idly wonders whether there is a `Show Void' instance
01:00:02 <ivanm> Gracenotes: heh
01:00:08 <ivanm> @hoogle Void
01:00:16 <ivanm> oh, that's right, no bot
01:01:01 <Gracenotes> http://haskell.org/hoogle/?hoogle=Void
01:01:06 <Gracenotes> always wanted to be a bot one day
01:01:11 <ski_> (it ought to be basically `instance Show Void where show v = seq v (error "impossable : `Void' value was forced !")')
01:01:13 <ivanm> lambdabot, o lambdabot, where art though lambdabot?
01:01:22 <ivanm> *thou
01:02:35 <ski_> lambdabot, come hither !
01:14:45 <Vq> @botsnack
01:14:46 <lambdabot> :)
01:18:07 <sfuentes> is there a difference between putStrLn "foo" and putStrLn $ "foo" ?
01:18:27 <Saizan> if that's the whole expression, no
01:18:40 <ski_> > show (undefined :: ())
01:18:40 <lambdabot>   "* Exception: Prelude.undefined
01:18:50 * ski_ nods slowly
01:19:11 <sfuentes> so what is the $ symbol for?
01:19:59 <ski_> `foo x $ \a -> bar y z $ baz a b' is the same as `foo x (\a -> bar y z (baz a b))'
01:20:26 <Saizan> sfuentes: it's used to avoid typing parentheses in more complex expressions
01:20:31 <Saizan> ?src ($)
01:20:31 <lambdabot> f $ x = f x
01:20:32 <Vq> f $ x = f x
01:20:50 <Saizan> it's just function application, but it's right-associative and has the lowest precedence
01:21:17 <Saizan> so, instead of writing f a (g b) you can write f a $ g b
01:21:35 <sfuentes> awww. i see.
01:21:43 <sfuentes> thank you
01:26:15 <ivanm> > let (s _ = "()") in s (undefined :: ())
01:26:16 <lambdabot>   <no location info>: parse error on input `='
01:26:26 <ivanm> > let s _ = "()" in s (undefined :: ())
01:26:27 <lambdabot>   "()"
01:28:28 <benmachine> $ is also useful with e.g. zipWith or operator sections
01:29:11 <Vq> > map ($ 5) [(+2),(+3),(*10)]
01:29:12 <lambdabot>   [7,8,50]
01:30:31 <jrockway> interesting; i've never used $ in a section, but it makes sense
01:30:31 <benmachine> so if I have let x = 4; y = x + x in y
01:30:40 <jrockway> (<$> comes up quite often in sections, for me anyway)
01:30:53 <benmachine> would the next step of evaluation be, let y = 4 + 4 in y
01:31:00 <benmachine> or, let x = 4 in x + x
01:31:18 <benmachine> this is not really a haskell-implementation question
01:31:21 <benmachine> what seems more logical?
01:31:24 <jrockway> the bindings are not evaluated in order; x can refer to y, and y can refer to x
01:31:56 <benmachine> jrockway: I am writing a tool that tries to evaluate haskell expressions in a step-by-step fashion so that you can see how it's done
01:32:06 <benmachine> jrockway: so my question is really stylistic rather than
01:32:09 <benmachine> <other>
01:32:31 <jrockway> you can always debug.trace and see what ghc does
01:32:43 <benmachine> I don't really care what ghc does :P it's probably magic
01:33:20 <benmachine> but in general the question of when to substitute a bind and when to just evaluate it is not a simple one
01:33:56 <jrockway> there may be multiple steps for each bind
01:34:09 <jrockway> let f x top = if x > top then 42 else f (x + 1) top
01:34:26 <jrockway> the joys of static analysis :)
01:34:39 <Gracenotes> @where stg
01:34:39 <lambdabot> http://citeseer.ist.psu.edu/peytonjones92implementing.html
01:34:44 <benmachine> I think what I have for that currently is
01:34:50 <benmachine> let f = \x top ->
01:34:55 <benmachine> hmm
01:35:04 <benmachine> well, in that case you have to substitute f anyway
01:35:08 <benmachine> oh, never mind
01:35:14 <benmachine> I will think about this properly later
01:35:28 <Gracenotes> STG is reasonably simple to understand
01:36:14 * benmachine adds it to his stock of firefox tabs
01:36:36 <benmachine> thanks, I think I'm going to have to look at it later though
01:36:50 * benmachine disappears
01:37:03 <Gracenotes> either way, graph reduction would be involved.
01:50:47 <ski_> benmachine : i'd say after `let x = 4; y = x + x in y' you get `let x = 4; y = 8 in y'
01:52:30 <ski_> (barring any "optimizations" such as discovering that `y' is only used in one place, so could be substituted)
02:33:12 <tARrAScH> Hello, is this the appropriate place to ask for more technical issues, like problems with wxHaskell?
02:35:06 <lpsmith> tARrAScH, sure
02:35:24 <lpsmith> I've never used wxHaskell though, so I can't help you
02:37:18 <tARrAScH> Ok. I've recently installed wxHaskell, and I can now load this normal hello world program; which I couldn't before isntallation, but now when I try to run my program with ghci I get this error during linking:
02:37:22 <tARrAScH> Error: Loading package wxcore-0.12.1.2 ... <command line>: can't load .so/.DLL for: stdc++ (libstdc++.so: cannot open shared object file: No such file or directory)
02:38:13 <tARrAScH> Simple hello world Program: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16800#a16800
02:38:39 <tARrAScH> by "run" I mean typing in 'main'
02:40:17 <tARrAScH> Executing: 'ghci -package wx' also gives the same error.
02:42:39 <nus> tARrAScH, your wxcore package linkage is broken. distro/package mismatch?
02:48:28 <tARrAScH> nus, hmm; Any idea how to fix it? I use ubuntu 9.10 if that matters. I'm quite inexperienced with both Linux and cabal
02:49:47 <nus> tARrAScH, use gtk2hs ;-)
02:50:21 <Berengal> I think it's enough to just specify libstdc++ on the command line
02:50:50 <tARrAScH> Berengal: Can you clarify that :)?
02:51:16 <Berengal> tARrAScH: ghci Foo.hs path/to/stdlibc++.so
02:51:31 <tARrAScH> nus, I think I've to use wxHaskell, say my course leaders
02:51:41 <tARrAScH> Berengal: aha, ok thanks
02:53:40 <Berengal> If that works, you might want to write a script that does it for you and use that for that project
02:54:53 <tARrAScH> Berengal: Is there any obvious paths to find stdlibc++, I tried searching for it but no results ..
02:55:06 <Berengal> tARrAScH: /usr/lib, probably
02:56:11 <Berengal> Make sure you have it installed. apt-file is a nice program for searching for files in packages too
02:57:10 <Berengal> /usr/lib/libstdc++.so.6 on my machine (also, ubuntu 9.10)
03:00:09 <Wooga> can i somehow read directly from getLine to non-IO variable?
03:00:39 <Wooga> i am trying to do something like
03:00:40 <Wooga> main = do let z = (read getLine :: Int)
03:00:40 <Wooga>           putStrLn $ show $ factorial z
03:01:01 <Wooga> but where i am wrong?
03:01:36 <ben0x539> read is, for example, String -> Int
03:01:39 <ben0x539> but getLine is not String
03:01:53 <ben0x539> you cannot pass getLine to read, you have to squeeze read into getLine.
03:02:05 <ben0x539> And then you still need <- instead of let =
03:02:34 <Wooga> but how i make getLine string?
03:02:41 <ben0x539> You do not
03:02:47 <ben0x539> It is an IO action, not a string
03:03:07 <Wooga> or there is only way to do something like x <- getLine; let z = (read x :: Int) ?
03:03:24 <ivanm> @hoogle (Read a) => IO a
03:03:24 <lambdabot> Prelude readLn :: Read a => IO a
03:03:24 <lambdabot> System.IO readLn :: Read a => IO a
03:03:24 <lambdabot> Prelude readIO :: Read a => String -> IO a
03:03:27 <ivanm> ;-)
03:03:33 <ben0x539> you can say x <- fmap read getLine
03:03:37 <ben0x539> Well, or do that
03:03:41 <ben0x539> @src readLn
03:03:42 <lambdabot> readLn =  do l <- getLine; r <- readIO l; return r
03:04:08 <Wooga> thanks!
03:04:16 * Twey never knew about that one, either
03:04:34 <Twey> What does readIO do if it fails?
03:04:42 <Twey> Which exception does it throw?
03:04:48 <ivanm> Twey: fails horribly is my guess
03:06:37 <voker57> Twey: UserError
03:06:55 <Twey> Aha
03:07:08 <voker57> i suggest using readSafe from "safe" package instead
03:07:17 <voker57> readMay *
03:07:35 <Twey> Yeah, but sometimes you want to catch any sort of input error
03:07:50 <Twey> Since the rest of them are all exceptions, it's more convenient
03:10:37 <Wooga> why in ghci 6.10.4 Enum a is required by function like
03:10:38 <Wooga> factorial :: (Num a, Enum a) => a -> a
03:10:38 <Wooga> factorial n = product [1..n]
03:10:59 <Wooga> while in http://haskell.org/haskellwiki/Learn_Haskell_in_10_minutes such function goes only with Num a ?
03:11:21 <Twey> Num requires Enum
03:11:37 <Wooga> like Ord - Eq ?
03:11:47 <Twey> Yes
03:11:48 <Twey> :t (1 +) . succ
03:11:49 <lambdabot> forall t. (Num t, Enum t) => t -> t
03:11:56 <Twey> :t (1 +) . succ :: Num t => t -> t
03:11:57 <lambdabot>     Could not deduce (Enum t) from the context (Num t)
03:11:57 <lambdabot>       arising from a use of `succ' at <interactive>:1:8-11
03:11:57 <lambdabot>     Possible fix:
03:12:09 <Twey> It's just a hack around class aliases
03:12:17 <Twey> Er, or rather the lack thereof
03:12:38 <Twey> Really, (+ 1) == succ for Nums, but which type ends up in the signature just depends which one gets used
03:13:05 <Twey> If the function uses both an Enum operation and a Num operation, both constraints end up in the type
03:21:05 <abccc> hi, does anyone have a hint for me: I have a simple gtk GUI with a Textentry and a Button.. When clicking on the Button I load some data from the internet (based on the text in the TextEntry) . Now, my problem is that I just want do download if the text in TextEntry differs from the Text when clicked before.. How can i achieve this with Haskell? :(
03:22:00 <tARrAScH> Berengal, ghci -package wx '/usr/lib/libstdc++.so.6' gives the sane error, any ideas?
03:22:56 <Berengal> tARrAScH: Eh... set up a symbolic link that calls it libstdc++.so without the .6
03:23:08 <Berengal> If that doesn't work I don't know...
03:23:39 <Berengal> Perhaps sepcifying it with -L...
03:23:42 <tARrAScH> Berengal: Is it possible to just copy libstdc++.so.6 and put it in the same folder as where you compile from?
03:24:26 <Berengal> Possibly, but I'd just ln /usr/lib/stdc++.so.6 libstdc++.so instead of copy
03:24:40 <Berengal> ln -s that is
03:31:21 <tARrAScH> Ok, now I'm getting another error. I doubt I should continue to fix them 1 by 1, I've better chances getting the issue solved writing an angry letter to the labb authors over why they picked wxHaskell when gtk is just click-n-play
03:31:25 <tARrAScH> Anyway huge Berengal
03:31:33 <tARrAScH> huge thanks*
04:13:05 <chrisdone> > let f = uncurry zip . (map snd . filter (odd . fst) &&& map snd . filter (even . fst)) . zip [1..] in f [1,2,3,4,5]
04:13:06 <lambdabot>   [(1,2),(3,4)]
04:13:22 <chrisdone> @hoogle [a] -> [(a, a)]
04:13:23 <lambdabot> Test.QuickCheck two :: Monad m => m a -> m (a, a)
04:13:23 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
04:13:23 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
04:13:37 <chrisdone> > two [1,2,3]
04:13:37 <lambdabot>   Not in scope: `two'
04:13:42 <chrisdone> > Test.QuickCheck.two [1,2,3]
04:13:43 <lambdabot>   Not in scope: `Test.QuickCheck.two'
04:13:59 <chrisdone> @src Test.QuickCheck.two
04:13:59 <lambdabot> Source not found. Take a stress pill and think things over.
04:14:12 <chrisdone> @source Test.QuickCheck.two
04:14:12 <lambdabot> Test.QuickCheck.two not available
04:15:11 <chrisdone> ah, that is out of date
04:16:11 <chrisdone> unless storing old versions of libraries is intentional
04:16:27 <burp> test
04:16:36 <chrisdone> OK. 1 test completed.
04:18:00 <tARrAScH> @hoogle (a, b) -> (b, a)
04:18:00 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
04:18:01 <lambdabot> Data.Graph.Inductive.Query.Monad mapSnd :: (a -> b) -> (c, a) -> (c, b)
04:18:01 <lambdabot> Data.Graph.Inductive.Query.Monad mapFst :: (a -> b) -> (a, c) -> (b, c)
04:18:19 <burp> has anyone built HPlot with ghc 6.12? (anyone who is able to write :P)
04:22:16 <chrisdone> :t (snd && fst)
04:22:17 <lambdabot>     Couldn't match expected type `Bool'
04:22:17 <lambdabot>            against inferred type `(a, b) -> b'
04:22:17 <lambdabot>     In the first argument of `(&&)', namely `snd'
04:22:19 <chrisdone> :t (snd &&& fst)
04:22:20 <lambdabot> forall a c. (a, c) -> (c, a)
04:23:55 <Berengal> The swap function should really be in the prelude...
04:25:06 <tensorpudding> is it that useful?
04:31:38 <Botje> i've used it a couple of times
04:33:52 <tensorpudding> > swap (2,5)
04:33:53 <lambdabot>   Not in scope: `swap'
04:34:05 <tensorpudding> hmm, so it's not a real function
04:34:32 <Botje> :t (uncurry (flip (,))
04:34:33 <lambdabot> parse error (possibly incorrect indentation)
04:34:38 <Botje> :t uncurry (flip (,))
04:34:39 <lambdabot> forall b a. (a, b) -> (b, a)
04:35:27 <tensorpudding> or just f (a,b) = (b,a)
04:35:44 <tensorpudding> looks almost exactly like the type
04:37:43 <chrisdone> (snd &&& fst) is awesome
04:37:54 <tensorpudding> it requires an import
04:38:07 <chrisdone> so?
04:38:34 <chrisdone> most my haskell programs need Control.Arrow as a start
04:39:04 <tensorpudding> it's also more complicated
04:39:46 <chrisdone> right..
04:40:16 <chrisdone> if you're working with &&& and *** and first/second all day, it goes with the floy
04:40:32 <tensorpudding> maybe so
04:41:09 <tensorpudding> between that and the one with uncurry flip, i'd go with yours
04:48:11 <Heffalump> @type uncurry (flip (,))
04:48:13 <lambdabot> forall b a. (a, b) -> (b, a)
04:48:31 <Heffalump> oh, sorry, that was already in scrollback
04:49:45 <chrisdone> what's the ettiquette (did I murder that spelling?) with respect to putting your quickcheck properties?
04:50:02 <chrisdone> do you put them in a Tests module in your project, like your Types module, or do you put them along side each function?
04:50:18 <chrisdone> I can see advantages with both ways
04:50:29 <Badger> (etiquette)
04:50:56 <Heffalump> I guess putting them alongside is better in terms of not having to expose internals.
04:51:12 <Heffalump> I don't think there's a standard way though
04:51:46 <chrisdone> oh good point, I didn't consider having to export them
04:52:14 <chrisdone> Haskell> quickCheck (\x -> keysToUrl (urlToKeys x) == x)
04:52:14 <chrisdone> Loading package QuickCheck-2.1.0.2 ... linking ... done.
04:52:15 <chrisdone> *** Failed! Falsifiable (after 2 tests and 1 shrink):
04:52:15 <chrisdone> "a"
04:52:16 <abccc> hello, maybe someone can help me: I'm using Gtk and draw on a drawingArea in the onExpose Event. A redraw is triggered throug a button's event and widgetQueueDraw ...    In the draw event I want to draw some String which I get from a function which loads them from the internet (parameterized by some  from TextEntries). Now my problem is, how can i "cache" the result (or in the function?!) that only a new download occurs when the param
04:52:16 <abccc> eters changed?
04:52:18 <chrisdone> god damnit quickechk, I love you!
04:53:14 <chrisdone> in that vain, then, anyone got emacs macros for automagically running quickcheck tests for function definitions?
04:54:31 <ivanm> chrisdone: I think that would depend too much on how you define them, etc.
04:54:41 <ivanm> but IIRC there's a package on hackage that lets you embed tests in the documentation
04:56:03 <kmc> abccc, sounds like you want a mutable cell
04:56:04 <kmc> like an IORef
04:56:31 <kmc> both drawing and fetching stuff from the internet are probably IO monad actions
04:56:47 <chrisdone> ivanm: yeah lots of quickcheck projects knocking about, sweet
04:56:55 <abccc> yes, the fetching is an IO monad... I'm new to Haskell/functional programming.. maybe I also have a design issue?
04:57:22 <kmc> your design doesn't sound too crazy
04:57:25 <abccc> I will search for mutable cell and IORef.. thx for the kywords
04:57:40 <kmc> abccc, http://www.haskell.org/ghc/docs/6.10-latest/html/libraries/base/Data-IORef.html
04:58:07 <pokoko222> what is the use of groups, fields and rings in haskell?
04:58:54 <Botje> they have properties which correspond to the mathematical definition of those things
04:58:56 <chrisdone> pokoko222: scaring away ruby programmers
04:59:25 <pokoko222> Botje in what cases have you used them?
04:59:42 <kmc> abccc, if you're new to Haskell, starting with gui and network stuff is sort of jumping in the deep end :)
04:59:50 <kmc> but it sounds like you're doing all right
04:59:54 <kmc> have you read Real World Haskell?
04:59:55 <Botje> i haven't used them myself
04:59:59 <Botje> i've seen them used in some articles
05:00:40 <Botje> kmc: the deep end is infested with sharks, yes?
05:00:59 <abccc> hehe, maybe right ;). The network stuff is running.. and I need this for a small project at the university I have to do for a course
05:24:48 <smorg> Oh no, theres no http://foldl.com/
05:24:56 <medfly> foldr then?
05:25:17 <medfly> oh... I recall seeing someone say that all 5-lette rthings which end in .com are used, but I am not sure
05:25:37 <ehamberg> smorg: yeah, it disappeared ~4 months ago or something :(
05:25:39 <smorg> I found http://foldr.com/ in wikipedia and guessed someone here must be responsible :P
05:26:06 <medfly> hahaha
05:26:19 <smorg> after guessing that church encoding proabably had something to do with cons
05:40:51 <Wooga> what is better: fold?? or recursion?
05:41:21 <Axman6> Wooga: they're the same thing
05:41:31 <Wooga> but which one is better to use?
05:41:41 <kamatsu> generally fold, but it depends on what you're doing
05:42:03 <Wooga> thanks
05:43:05 <Wooga> just at least for me it is easier to think in fold terms rather recrusion ones
05:45:26 <damd> u must use foldr not foldl to recurse
05:45:31 <damd> foldl is imperativ style
05:46:36 <kamatsu> damd: imperative?
05:46:39 <kamatsu> dmwit: whoa whoa whoa
05:46:41 <kamatsu> oops
05:46:44 <kamatsu> damd not dmwit
05:46:51 <kamatsu> foldl is in no way imperative
05:47:02 <damd> yes look at type of it
05:47:03 <damd> :t foldl
05:47:04 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
05:47:05 <damd> :t foldr
05:47:06 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
05:47:08 <damd> see?
05:47:14 <Wooga> ...
05:47:15 <kamatsu> that is not "imperative" ;)
05:47:26 <jlouis> http://www.haskell.org/haskellwiki/Foldr_Foldl_Foldl' is worth a read
05:47:30 <kamatsu> i don't think "imperative" means what you think it means
05:47:43 <kamatsu> foldl doesn't behave well with laziness
05:47:44 <damd> TROLLD
05:47:48 <kamatsu> but strict semantics are not imperative
05:48:25 <kamatsu> when beginners are in the channel, that sort of behavior is unhelpful, damd.
05:48:28 <Wooga> in lyah said that strict foldl' is worth using
05:48:47 <kamatsu> Wooga: it is fine, feel free to use foldl' and foldr liberally
05:49:07 <kamatsu> Wooga: just careful with lazy foldl, it's still occasionally useful
05:49:18 <kamatsu> Wooga: but not as safe a bet as the others
05:50:40 <kamatsu> Wooga: LYAH is a good tutorial too, but feel free to ask here if you have more questions
05:51:38 <Wooga> i never holded myself from asking questions here :3
05:51:58 <damd> just try to remember to ask if you may ask first
05:52:15 <kamatsu> damd: beginners can always ask
05:55:26 <chrisdone> are monads electric?
05:56:33 <kamatsu> hm?
05:57:53 <chrisdone> only mine's broke down, and now I've no one to perform computations
05:58:17 <kamatsu> can't make do with an applicative functor?
05:58:20 <kmc> turn the crank on the side
06:00:29 <chrisdone> :p
06:01:28 <Raynes> The general rule is to never ask to ask because asking to ask takes longer than just asking and asking to ask requires more typing and a less direct route to the answer of your question.
06:01:46 <medfly> almost as much as typing that sentence
06:01:51 <Raynes> Indeed.
06:02:39 <kmc> i always ask whether i should ask to ask or just ask
06:03:01 <Raynes> Just ask if's okay to ask to ask, and everything will be fine.
06:03:40 <kmc> @quote ask
06:03:41 <lambdabot> quicksilver says: [on @yhjulwwiefzojcbxybbruweejw] it's the noise a haskell developer makes if you kick him in the de bruijn index.
06:03:50 <kmc> hehe
06:03:56 <kmc> @yhjulwwiefzojcbxybbruweejw
06:03:56 <lambdabot> "\""
06:07:08 <medfly> o.O
06:08:34 <burp> arg, /query lambdabot
06:10:07 <int-e> @quote state
06:10:08 <lambdabot> state says: ?. ++ . read . show . state ?. ++ . read . show . state
06:13:35 <soupdragon> > iterate ((+1).(*2)) 1
06:13:36 <lambdabot>   [1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535,131071,26...
06:14:25 <soupdragon> > iterate ((+1).(*10)) 1
06:14:26 <lambdabot>   [1,11,111,1111,11111,111111,1111111,11111111,111111111,1111111111,111111111...
06:14:37 <soupdragon> > map square . iterate ((+1).(*10)) $ 1
06:14:37 <lambdabot>   Not in scope: `square'
06:15:14 <m0nkfish> > map (\x -> x*x) . iterate ((+1).(*10)) $ 1
06:15:15 <lambdabot>   [1,121,12321,1234321,123454321,12345654321,1234567654321,123456787654321,12...
06:16:55 <kmc> nice
06:18:03 <facsimile> Excuse my ignorance, but what are the differences between "function-level" and "functional" programming?
06:18:11 <facsimile> "Function-level" is also known as "point-free style", for those of us with Haskell experience.
06:18:25 <facsimile> http://www.reddit.com/r/coding/comments/aues1/fp_programming_language_the_origin_of/
06:19:24 <dolio> Is that what function-level means? FP-like?
06:20:02 <kmc> facsimile, do you mean to quote those comments, or repeat them?
06:20:04 <dolio> One main idea is (I think) that composition is more important than application, so the former gets denoted as juxtaposition.
06:20:52 <dolio> Which in practice gets you fairly different code.
06:21:01 <dolio> Maybe you can't do application at all.
06:23:10 <dolio> Languages like that would probably fall into the "concatenative" category.
06:23:23 <facsimile> yeah so basically it's forth
06:23:31 <facsimile> ?
06:23:50 <dolio> I don't really know FP, but I think it's similar.
06:23:52 <kmc> @quote abstraction.oriented
06:23:52 <lambdabot> JonFairbarn says: I think we should call it "Abstraction Oriented Programming". It's got the "oriented" buzzword in it, and we don't need to tell folk that "abstraction" means more than one thing to
06:23:52 <lambdabot> us until we're sure they're OK.
06:24:57 <dolio> But, perhaps Joy is another example?
06:28:59 <dolio> From point-free code in Haskell, I can't say it intrigues me much.
06:30:03 <dolio> But I suppose it's possible that the fact that we can fall back on application has kept us from having deriving all sorts of wonderful combinators that make point-free code actually readable in general.
06:30:13 <dolio> While the concatenative people have made such breakthroughs.
06:30:20 <facsimile> dolio I don't believe that :P
06:30:39 <facsimile> hm
06:30:48 <facsimile> what sort of concatenative breakthroughs
06:30:52 <dolio> I don't either. But it's conceivable. :)
06:31:07 <facsimile> I was wondering if that's what conal was gettnig at
06:32:46 <dolio> Part of the reason people don't use arrows is probably that it's all point-free without arrow syntax.
06:33:06 * facsimile doesn't use arrows because wtf is an arror..
06:33:21 <facsimile> :(
06:34:07 <dolio> Category theory is, at its core, all point-free as well, but they invent lots of notation for making things look applicative like normal mathematics when possible.
06:34:55 <facsimile> what about functors they aren't point free ?
06:35:06 <facsimile> like you write F(something)
06:35:09 <dolio> And there's even the business of internal languages, where lambda calculus-type language with application can make sense in more general classes of categories.
06:35:30 <mreh> http://okmij.org/ftp/Haskell/perfect-shuffle.txt -- does anyone know why Furthermore, if we have a sequence of N elements and associate with each element a key -- a random number uniformly distributed within [0, M-1] (where **N!>M>=N***)
06:36:10 <dolio> More general than just "sets" or something similar, that is.
06:36:23 <mreh> obviously M needs to be larger than N otherwise we would never access some permutations in our sorting
06:37:40 <dolio> Functors aren't point free, but all the diagrams are.
06:37:55 <facsimile> ohh yeaha
06:38:06 <dolio> Diagrams denote equations like 'f . g = h . k'
06:39:26 <dolio> But it's not uncommon to see things couched as generalized elements, where instead of 'f . x = ...' you see 'f(x) = ...'.
06:40:13 <int-e> mreh: N! has more distinct prime divisors than M^N (which has the same distinct prime divisors as M. The statement is false though, for example 4! divides 6^4)
06:41:36 <dolio> That sort of notation is more directly meaningful if x : 1 -> A, but sometimes you'll even see it for x : B -> A.
06:41:54 <facsimile> generalized elements
06:42:17 <int-e> mreh: more precisely, in N! > M >= N, N! should be replaced by the product of distinct primes up to N.
06:43:51 <mreh> int-e: I didn't understand that
06:44:00 <dolio> Functor composition tends to be written as juxtaposition, as well.
06:44:09 <mreh> but don't worry, I'm just interested in getting a random shuffle working
06:44:27 <dolio> Like, mu : TT => T, in the definition of a monad.
06:45:06 <lpsmith> mmm,  factoradic numbers
06:45:50 <dolio> But that's because mathematicians get to overload things a lot more freely than we get to in programming languages.
06:46:54 <int-e> mreh: oh, perhaps this helps: if a configuration assigns the same key to two elements, then the order of those elements in the result will be determined by the sorting algorithm rather than being random.
06:48:18 <int-e> mreh: (that
06:48:32 <int-e> 's a different argument than the counting one, but perhaps more intuitive)
06:56:42 <mreh> int-e: oh yes, I understand that
06:57:16 <mreh> [lo, hi] is an inclusive range is it not?
06:57:48 <mreh> it's not called a range though...
06:57:52 <mreh> I can't remember the name
06:58:01 <mreh> (lo, hi] is another example
06:58:05 <Saizan> interval
07:05:43 <pokoko222> Can someone please explain me limits in category theory as generalizations of limits in analysis?
07:06:48 <facsimile> and me
07:06:49 <facsimile> ;D
07:07:03 <facsimile> that sounds interesting, is there some kind of epsilon-delta category?
07:18:49 <dolio> I've never seen such a connection pointed out. But there may be one.
07:22:54 <pokoko222> wikipedia says so
07:25:25 <dolio> Where?
07:26:19 <pokoko222> http://en.wikipedia.org/wiki/Limit_(mathematics)
07:27:01 <dolio> Oh, okay.
07:27:09 <dolio> If it's the limit of a sequence...
07:28:48 <dolio> Then it probably has to do with arranging to have a partial order looked at as a category.
07:29:22 <dolio> Where you'd have a_0 -> a_1 -> a_2 -> ...
07:29:24 <pokoko222> the limit of sequence yes, what else you thought of?
07:30:26 <dolio> The colimit of such a diagram would be the 'least' value such that every value in the sequence is 'less' than the colimit.
07:31:05 <dolio> You said analysis, so I was thinking of limits of functions approaching arbitrary points.
07:41:55 <pokoko222> anyone can share practical use of universal cones i kinda dont get them?
07:43:42 <mreh> mmm, cones
07:44:15 <dolio> Universal cones are limits.
07:44:53 <dolio> A cone is an object together with arrows from that object to the objects in your diagram that commute with the arrows in the diagram.
07:45:50 <dolio> A universal cone is a cone such that for every other cone, there's an arrow from the object in the other cone to the object in the universal cone that commutes with the relevant arrows.
07:45:54 <dolio> Which is the definition of a limit.
07:46:43 <dolio> So, If you have a diagram with just two objects, A and B...
07:47:05 <dolio> Then a cone is an object X, with arrows that look like: A <- X -> B
07:47:50 <dolio> Then a universal cone is such that for every other cone A <- Y -> B, there's an appropriate Y -> X.
07:47:56 <dolio> Which is the definition of a product.
07:48:07 <dmwit> (and a sum is a universal co-cone of the same diagram)
07:48:23 <dolio> Couniversal. :)
07:48:32 <dmwit> yes, right =)
07:49:20 <dmwit> Some other constructs can be defined in terms of universal cones, as well.
07:51:39 <b0fh_ua> Hi there! Can somebody please explain me how should I understand this expression: runState (get >>= \s -> put (s+1) >> return (s^2)) 3
07:52:19 <kmc> b0fh_ua, understand on what level?
07:52:21 <b0fh_ua> I am not sure with the order of evaluation of state within brackets
07:52:23 <kmc> can you parse it?
07:52:44 <kmc> do you care about the order of evaluation, or do you care about the order of execution of state-manipulations?
07:53:03 <b0fh_ua> I think "get the current state, then bind it to s of lambda"
07:53:11 <kmc> yes
07:53:18 <b0fh_ua> but with that >> return (s^2) I'm a bit lost
07:53:19 <kmc> a lambda body extends as far to the right as it can
07:53:30 <kmc> so the body of the lambda is ´put (s+1) >> return (s^2)ª
07:53:51 <b0fh_ua> ah, now that's clear
07:53:52 <kmc> ´ a >> b ª  is simply  ´ a >>= \_ -> b ª
07:54:14 <kmc> an equivalent expression is:  do { s <- get; put (s+1); return (s^2) }
07:54:23 <kmc> @undo do { s <- get; put (s+1); return (s^2) }
07:54:24 <lambdabot> get >>= \ s -> put (s + 1) >> return (s ^ 2)
07:54:34 <b0fh_ua> nice
07:54:46 <b0fh_ua> looks I'm close to understand the state monad :)
07:54:48 <kmc> cool
07:55:04 <dmwit> > (runState (get >>= \s -> put (s + 1) >> return (s^2)) 3, (succ &&& (^2)) 3)
07:55:04 <kmc> well, that stuff was not specific to the state monad
07:55:05 <lambdabot>   ((9,4),(4,9))
07:55:08 <dmwit> whoops
07:55:12 <dmwit> got it backwards =)
07:56:01 <kmc> @check \n -> runState (get >>= \s -> put (s + 1) >> return (s^2)) n == ((^2) &&& succ) n
07:56:03 <lambdabot>   "OK, passed 500 tests."
07:56:03 <b0fh_ua> kmc: http://ertes.de/articles/monads.html - I'm learning yet another monad tutorial :)
07:56:09 <b0fh_ua> one more, thus
07:56:18 <dang`r`us> tmonads and strife
08:01:19 <b0fh_ua> one more question about lambdas: getRandom >>= \a -> getRandom >>= \b -> getRandom >>= \c -> return (a+b+c) - how should I parse it?
08:01:29 <kmc> each one goes all the way to the right
08:01:54 <b0fh_ua> the order of evaluation isn't clear for me
08:02:06 <kmc> again, i don't think it's order of evaluation that matters
08:02:13 <kmc> maybe it does matter for what you're doing
08:02:35 <kmc> but you probably care more about the order of *execution* of state modifiers
08:02:38 <b0fh_ua> I just trying to understand :(
08:02:53 <kmc> which is defined by how the State monad defines (>>=)
08:03:23 <kmc> getRandom >>= (\a -> getRandom >>= (\b -> getRandom >>= (\c -> return (a+b+c))))
08:03:36 <b0fh_ua> well, my goal is to understand how this works, and how to create such expressions when needed
08:04:32 <kmc> the State monad defines (>>=) in such a way that the computation on the left modifies the state first
08:04:45 <kmc> then the computation on the right (or rather, the computation returned by the function on the right)
08:04:52 <b0fh_ua> with this expression c is bound to getRandom and passed to (a+b+c), which in order is returned and b is bound and so on?
08:06:28 <kmc> the first State computation to run is getRandom
08:06:44 <b0fh_ua> kmc: which one? :)
08:06:47 <kmc> the first one
08:06:51 <kmc> its result is passed to the ´\a -> ...ª function, which returns another State computation
08:07:34 <kmc> that computation runs getRandom and passes its result to the ´\b -> ...ª function, which returns another computation, etc.
08:08:22 <b0fh_ua> and as soon as return (a+b+c) found, the values a,b and c are already known?
08:08:57 <kmc> yes, they're in scope from enclosing lambdas
08:09:57 <b0fh_ua> okay, so in general if there is lambda which in order has another lambdas in it's definition - so those internal labmdas do have access to the parameters of any "parent" lambda?
08:10:08 <kmc> yes
08:10:20 <b0fh_ua> okay, that's fair enough
08:10:22 <b0fh_ua> thank you
08:10:23 <kmc> > (\a -> \b -> (a+b)) 2 3
08:10:24 <lambdabot>   5
08:10:29 <kmc> > (\a b -> (a+b)) 2 3
08:10:30 <lambdabot>   5
08:10:49 <kmc> > (\a -> let f = (a+) in \b -> f b) 2 3
08:10:50 <lambdabot>   5
08:11:39 <b0fh_ua> excellent, I didn't find anything like this in tutorials. May be I just missed it.
08:11:52 <b0fh_ua> thanks again :)
08:11:55 <kmc> it's the same in any functional programming language
08:12:26 <kmc> b0fh_ua, variables occurring in a lambda body that aren't bound by the lambda are called "free variables"
08:12:29 <b0fh_ua> kmc: haskell is the first one I am trying to learn
08:12:57 <temoto> You're lucky.
08:13:45 <b0fh_ua> may be. It's hard to learn for me, with all those 10 years background in imperative programming
08:14:00 <kmc> well, Haskell is an imperative language too
08:14:05 <b0fh_ua> I bet things would be much easier if I start to learn it earlier
08:14:13 <kmc> yeah
08:14:32 <b0fh_ua> kmc: the most difficult concept for me is the computations, which may evaluate or may not
08:14:43 <kmc> most imperative languages have first class functions too
08:14:49 <temoto> Called lazy evaluation.
08:14:54 <temoto> –ª–µ–Ω–∏–≤–æ—Å—Ç—å
08:14:59 <Raynes> b0fh_ua: Those are called closures.
08:15:01 <b0fh_ua> ’«’
08:15:07 <kmc> Raynes, uh, not really
08:15:40 <Raynes> Unless I read something wrong, I'm pretty sure it is.
08:15:43 <temoto> He just a bit late, you were talking about closures.
08:16:31 <kmc> "closure" is what you call the in-memory datastructure that represents a function, in some implementations
08:16:32 <Raynes> temoto: Didn't realized I hadn't scrolled down in time. :p
08:17:00 <Raynes> I'm so very sorry I wasn't specific enough for you. ;)
08:17:41 <kmc> well, an implementation needn't have closures, and a language spec probably won't mention them at all
08:18:07 <temoto> But people will still say that word.
08:18:22 <kmc> just like the language spec does not require that a list is represented by two consecutive pointers
08:18:26 <kmc> people say lots of words
08:19:06 <temoto> And it's not that bad, nor is it misleading. Lambda is closed over some variables.
08:19:15 <b0fh_ua> can somebody please explain : http://pastebin.com/d367d81c2 - where the initial state is obtained from by "get" ?
08:19:29 <kmc> yeah, it's a fine point -- i myself have been on the other side of this argument ;)
08:19:34 --- mode: jordan.freenode.net set +o ChanServ
08:20:02 <temoto> b0fh_ua, you wouldn't believe :)
08:20:04 <kmc> i just want to avoid calling functions themselves "closures", because that's like C# calling them "delegates" or C++ calling them "functors"
08:20:17 <kmc> inventing a fancy new name for the oldest feature in programming languages
08:20:29 <b0fh_ua> temoto: shoot :)
08:20:43 <kmc> b0fh_ua, eventually you will use runState on this computation
08:20:46 <kmc> :t runState
08:20:47 <lambdabot> forall s a. State s a -> s -> (a, s)
08:20:48 <Raynes> b0fh_ua: I remember asking that same question a while back. You have to really look really really hard the first time to figure it out.
08:20:57 <kmc> here you pass in the initial state
08:21:07 <temoto> b0fh_ua, it comes from outside of that function :)
08:21:15 <kmc> that's not a function
08:21:28 <temoto> getRandom is not?
08:21:31 <kmc> nope
08:21:37 <Raynes> kmc: Wow, you're pretty anal aren't you. :p
08:21:39 <kmc> it doesn't have a (->) in its type
08:21:50 <temoto> So what?
08:21:57 <kmc> means it's not a function.  you can't apply it
08:22:14 <temoto> kmc, did you have a bad day? :)
08:22:23 <b0fh_ua> that's computation, I guess
08:22:53 <kmc> Raynes, temoto, the fact that stateful computations are a first-class type distinct from functions is one of the most distinctive and misunderstood features of Haskell
08:22:57 <kmc> so i like to be precise about it
08:23:36 <Raynes> It's expected, anyways. No matter how smart you get, and how smart you think you are, somebody in #Haskell will always make you look like an idiot. ;)
08:23:40 <b0fh_ua> Raynes: that's very hard to manage out those concepts
08:23:57 <kmc> it wasn't my intention to make anyone look like an idiot
08:24:15 <Raynes> kmc: I know that. Trust me, I know.
08:24:17 <nh2> can I use pattern matching in filter? I want to get all Bar elems from a list of Foo if data Foo = Bar | Baz
08:24:27 <edwardk> raynes: sadly it is true
08:24:28 <kmc> it also happens that the mtl implementation of State *is* a newtype-wrapped function
08:24:59 <temoto> b0fh_ua, in this case getRandom is a constant because it's a name bound to some expression and it doesn't take any arguments. Just like f = 15 + 10
08:25:00 <kmc> nh2, you can use a ´caseª expression in any expression context
08:25:36 <kmc> including within a lambda expression you pass to filter
08:25:41 <b0fh_ua> temoto: I feel like this is something closer to "macros" to be substituted in any expression ot appears
08:25:58 <kmc> filter (\x -> case x of Bar -> True; _ -> False)
08:26:03 <kmc> that's clunky though
08:26:05 <b0fh_ua> just not to bloat the code
08:26:08 <nh2> kmc: ok, but filter (\(Bar)->True) mylist will not work, right? The problem is case has not been introduced yet in our course but I still want the code to look good
08:26:18 <kmc> in a list comprehension, pattern match failure skips the element
08:26:24 <kmc> [ x | x@(Bar _) <- xs ]
08:26:49 <temoto> b0fh_ua, but distinguishing functions and constants doesn't give you anything, so you can call it a function when km—Å is not here :)
08:27:10 <nh2> kmc: unfortenately we cannot use those, too. Seems as if I had to use isBar and isBaz functions
08:27:17 <kmc> nh2, seems like :/
08:27:32 <kmc> temoto, whether f is a function tells you whether (f x) could possibly typecheck
08:27:53 <b0fh_ua> I need some coffee-break :)
08:28:01 <nh2> can I at least get rid of one of them? like "filter (not isBar) mylist", but it does not work
08:28:08 <kmc> not . isBar
08:28:18 <kmc> you want to compose the functions, not apply tem
08:28:41 <nh2> kmc: works fine!
08:29:34 <kmc> anyway, in most languages, functions are used to express argument dependence, to describe effects, and to defer evaluation
08:29:37 <temoto> b0fh_ua, it is related to haskell evaluation model. You can think of every expression as a macros and then they substituted into each other until you reach main = <expr>. Just defining f = 14 + 15 doesn't initiate the sum evaluation. And you can pass 'f' around pretty much time, it won't be evaluated until it's value is needed in some expression.
08:30:07 <kmc> these are three mostly unrelated roles that ended up as part of one feature for reasons that have no theoretical basis
08:30:26 <kmc> Haskell, as part of the general policy of "fuck everyone else, we'll make it nice", separates these three features
08:30:34 <kmc> therefore, no argument dependence => not a function
08:31:17 <kmc> temoto, yeah, the ability to substitute one side of an equation for another is very powerful
08:31:55 <kmc> call-by-name evaluation is conceptually like macro substitution
08:32:08 <kmc> lazy evaluation is a more efficient refinement that gives the same results
08:32:53 <temoto> Something related is called beta-reduction.
08:33:44 <temoto> AFAIK, exactly macro substitution is a beta reduction.
08:34:25 <kmc> > text "\9749 coffee break \9749"
08:34:26 <lambdabot>   ‚òï coffee break ‚òï
08:34:52 <temoto> @do get >>= \s0 -> let (x,s1) = lcg s0 in put s1 >> return x
08:34:53 <lambdabot> do { s0 <- get; let { (x, s1) = lcg s0}; put s1; return x}
08:34:55 <kmc> temoto, perhaps with hygenic macros
08:36:49 <temoto> kmc, wow i had unhygienic macro troubles in C. Didn't realize it has a special name and wiki page.
08:37:09 <edwardk> temoto: hygienic macros are very cool things =)
08:37:17 <kmc> C macros are filthy
08:37:52 <kmc> you can't even introduce bindings in an expression context
08:38:47 <kmc> so i've seen libraries that resort to something like:  static int __foo_val; #define FOO(x) (__foo_val = ((x)),  /* use __foo_val */)
08:39:13 <kmc> because they want to avoid reevaluating x (and reexecuting its possible side effects)
08:41:34 <cebewee> kmc: Actually, you can do this in gcc
08:42:16 <cebewee> #define FOO(x) { int __foo_val = (x); /* use __foo_val */ }
08:42:29 <kmc> ah, is that the statement expressions extension?
08:42:36 <cebewee> yep
08:42:41 <kmc> (the example i gave is from Numerical Recipes which is written in Ye Olde C)
08:43:13 <kmc> cebewee, cool.  do you "return" from such a statement or does it just take the value of the last expression-statement?
08:43:17 <cebewee> hm, forgot the () around the {}
08:43:28 <cebewee> kmc, the last expression
08:43:35 <kmc> like perl ;)
08:44:15 <kmc> ultimate perl philosophy.  to avoid writing 7 characters, let's make every void function return some garbage its caller is free to use anyway
08:44:50 <soupdragon> O(7) :)
08:50:09 <edwardk> kmc/cebweebe: you usually wrap that in a do { ... } while (0) so that semicolons work right on your macro
08:50:23 <kmc> yeah
08:53:41 <cebewee> edwardk: thats for statements
08:54:15 <cebewee> you don't do that for statement expressions (but i forgot the parentheses above):
08:54:55 <cebewee> #define FOO(x) ({ /* stuff */ })
08:55:34 <soupdragon> basically the macro system sucks
08:55:37 <soupdragon> ?
08:56:01 <kmc> yes
08:56:17 <kmc> good metaprogramming has to be done at the AST level not the character level
08:56:48 <kmc> C macros are very useful in practice, though
08:57:20 <aavogt> [01:07:56]      kamatsu | aavogt: your th doesn't work as you say it does
08:57:23 <soupdragon> does anyone know about that new quantum algorithm for approximating functions of solutions of linear systems
08:57:33 <edwardk> cebewee: oh yeah sorry misread. of course. i use those in a jit of mine to declare a static variable locally even if you use it in an expression
08:57:35 <aavogt> oh, isn't that great :)
08:57:38 <soupdragon> what do you need to know to understand this stuff?
08:57:39 <ray> too bad lispers think that macros are a silver machine gun
08:57:55 <kmc> lisp macros work on AST, though
08:57:58 <soupdragon> ray, kind of hard to make a statement about all lispers?
08:58:00 <kmc> but they're not hygenic
08:58:32 <Gracenotes> C macros can also be useful declaratively
08:58:37 <ray> well that's one of the billion reasons scheme is preferable there
08:58:40 <edwardk> ray: they have trouble making interdental fricatives?
08:59:01 <kmc> soupdragon, you mean quantum computation in general?
08:59:01 <Gracenotes> although, more commonly, used with expressions
08:59:59 <soupdragon> this one paper
09:00:00 <ray> edwardk: i mean they have trouble loading their machine guns with silver bullets
09:00:17 <soupdragon> Do you think it's possible to understand EVERY known quantum algorithm?
09:00:27 <soupdragon> since there's only like 3? or something
09:00:37 <kmc> hehe
09:01:01 <edwardk> soupdragon: there aren't all that many
09:01:18 <edwardk> i think closer to 5-6
09:01:39 <interferon> what gui library is the easiest to install on os x?
09:01:42 <soupdragon> what are they
09:01:48 <soupdragon> I know about that one ummm
09:01:56 <soupdragon> what's it called, about the not gate
09:01:59 <kmc> phase estimation
09:02:00 <soupdragon> Deutchs algorithm
09:02:03 <soupdragon> and Shors algorithm
09:02:05 <kmc> is used by shor's
09:02:09 <kmc> but is more general
09:02:31 <soupdragon> The DeutschñJozsa algorithm is a quantum algorithm, proposed by David Deutsch and Richard Jozsa in 1992[1] with improvements by Richard Cleve, Artur Ekert, Chiara Macchiavello, and Michele Mosca in 1998.[2] Although it is of little practical use, it is one of the first examples of a quantum algorithm that is exponentially faster than any possible deterministic classical algorithm.
09:02:33 <kmc> Nielsen and Chuang is a great book
09:02:35 <soupdragon> that's fro wikipedia
09:02:46 <kmc> i should finish it sometime
09:02:55 <Gracenotes> well, if you understand quantum registers, and the properties they have, the most difficult of which would probably be the effect of QFTs
09:03:11 <soupdragon> so that's 3 algorithms now
09:03:24 <Gracenotes> heck, I don't even fully understand FFTs.
09:03:27 <soupdragon> including this linear system one
09:03:49 <soupdragon> Quantum Computation and Quantum Information -- yeah that sounds good
09:04:28 <soupdragon> All problems which can be solved on a quantum computer can be solved on a classical computer
09:04:32 <soupdragon> ??
09:04:52 <kmc> yes, so it is thought
09:04:56 <jkarlson> that's the idea so far
09:04:56 <Gracenotes> quantum register is just a normal register if you don't superposition stuff
09:04:58 <soupdragon> What makes quantum algorithms interesting is that they might be able to solve some problems faster than classical algorithms. -- I thought I was on simple.wikipedia or something
09:05:25 <soupdragon> The most well known algorithms are Shor's algorithm for factoring, and Grover's algorithm for searching an unstructured database or an unordered list -- aha there's one that does lookup in O(sqrt(n))
09:05:37 <soupdragon> "fastest possible for searching an unsorted database in the quantum model"
09:05:45 <jkarlson> and bogosort!
09:05:56 <soupdragon> lol
09:06:01 <edwardk> soupdragon: deutch-jozsa, shor's simon's, hidden subgroup, estimating gauss sums, grover's algorithm, quantum counting, element distinctness, triangle finding, evaluating nand trees, estimating molecular weights, etc.
09:06:14 <edwardk> soupdragon: so closer to 9-10
09:06:15 <soupdragon> wwow there's a quite a lot
09:06:24 <soupdragon> edwardk I'm never going to learn all these!
09:06:36 <medfly> o.O??
09:06:40 <edwardk> soupdragon: meh, they all use the same tricks
09:06:47 <medfly> isn't it just, "implement this, try to understand it" ?
09:07:46 <kmc> @hackage quantum-arrow
09:07:46 <lambdabot> http://hackage.haskell.org/package/quantum-arrow
09:08:55 <Gracenotes> also, see the kind of operations provided by libquantum
09:09:14 <nh2> how to do something like "isPerson searchname (Person searchname) == True" instead of "isPerson searchname (Person name) = searchname==name"
09:09:26 <_Shadow> hi all
09:09:32 <soupdragon> hn2, impossible :(
09:09:34 <edwardk> soupdragon: trying to find my favorite quantum algorithms book on amazon right now, but having no luck =-/
09:09:43 <_Shadow> can someone guide me how to install house??
09:09:51 <soupdragon> edwardk happens to me all the time :P
09:09:55 <nh2> soupdragon: ok
09:10:02 <kmc> nh2, i don't understand what you are asking
09:10:22 <_Shadow> http://programatica.cs.pdx.edu/House/
09:10:51 <_Shadow> here it is written that it can be loaded from a floppy disk
09:10:56 <edwardk> soupdragon: heh, mine is a big thick black tome that i accidentally neglected to return to my university library
09:11:06 <edwardk> funny, i paid a small fortune in library fees in college
09:11:10 <soupdragon> they will fine you a lot!!!!!
09:11:17 <_Shadow> but I don't have floppy disk drive
09:11:17 <kmc> they'll prevent you graduating
09:11:21 <_Shadow> what to do then??
09:11:27 <edwardk> they did - i think it was like $200
09:11:38 <edwardk> kmc: i have graduated long since
09:11:53 <kmc> _Shadow, you can probably boot them from a CD, hard drive, USB stick or the like
09:12:07 <Gracenotes> oh, ick. the new ircd is causing messages come in all at once
09:12:14 <kmc> iirc Grub can boot a floppy image
09:12:18 <kmc> or you might try SYSLINUX or ISOLINUX
09:12:31 <soupdragon> edwardk did you just love it too much to return it? :P
09:12:47 <_Shadow> okay
09:12:48 <edwardk> soupdragon: yeah. sadly many of my books were obtained in this fashion ;)
09:12:50 <kmc> in fact it's designed to be booted by grub
09:12:51 <jkarlson> grub can boot almost anything on x86
09:13:03 <kmc> but you might have to build from source to get it in non-floppy image form
09:13:10 <edwardk> soupdragon: to be fair, i was getting ready to teach a quantum computing class the following semester based on the contents of the book
09:13:19 <jkarlson> if there is a functional kernel on the orbit on some satellite, grub can boot it
09:13:24 <jkarlson> at least grub2
09:13:31 <edwardk> soupdragon: so there are exigent circumstances
09:13:41 <soupdragon> okay
09:14:07 <soupdragon> how much physics should you know for quantum computation?
09:14:18 <byorgey> exigent?
09:14:21 <Gracenotes> incidentally, anyone worked out booting grub from a hard drive partition?
09:14:31 <kmc> soupdragon, not too much is necessary
09:14:37 <kmc> unless you want to implement quantum computation
09:14:46 <kmc> you do need to know CS and linear algebra
09:14:47 <jkarlson> btw are there any algorithms to kryptographic signing of data that survive quantum computing?
09:14:54 <jkarlson> for
09:15:03 <Gracenotes> it's more math than physics. The exact physical model (what is a qubit precisely) can vary, I believe.
09:15:20 <edwardk> byorgey: well, i had to loan my own copy to the dept head to get approval to teach the course, and things got complicated.
09:15:21 <soupdragon> implement quantum computation?
09:15:21 <_Shadow> kmc, I think grub runs only on linux distributions
09:15:37 <_Shadow> kmc, I am on windows now
09:15:37 <soupdragon> jkarlson, I think so like what about elliptic curve cryptography?
09:15:43 <kmc> _Shadow, grub the bootloader doesn't run on anything
09:15:52 <soupdragon> oh hm nevermind me
09:15:54 <kmc> but you might need the grub shell to install the bootloader
09:16:00 <kmc> _Shadow, it'd be easier to try House in QEMU
09:16:04 <byorgey> edwardk: no, I mean, I had never heard the word 'exigent'
09:16:11 <edwardk> byorgey: ah
09:16:17 <_Shadow> what is QEMU?
09:16:28 <kmc> an emulator (or virtualizer, sometimes)
09:16:32 <kmc> the page mentions it
09:16:37 <byorgey> edwardk: I just looked it up =)
09:18:31 <soupdragon> http://www.its.caltech.edu/~sjordan/zoo.html  oh it gets worse!!!
09:18:36 <chrisdone> awesome. whipped up some elisp functions to get this working. I hit C-c q while in a function, finds the function, finds the function's property, sends it to ghci, returns the QuickCheck result: http://chrisdone.com/pics/emacsquickcheck.png
09:18:58 <sshc> if I have a multiparameter type class "Foo" with a function "Bar" (class (Aoeu c, AoeuSnth d) => Foo a b c where Bar :: etc.), how do I specify which instance of "Foo" in which to call "Bar"?
09:19:29 <byorgey> chrisdone: awesome!  Please publish the code somewhere =)
09:19:30 <edwardk> re quantum algorithms, you don't need much physics background, a ton of linear algebra, and maybe a bit of physics knowledge to know what bra-ket notation means
09:19:40 <chrisdone> byorgey: will do! =)
09:19:47 <soupdragon> linear algebra I don't know about tensors
09:19:55 <edwardk> know as for implementing any sort of quantum system, that takes a ton of physics knowledge =)
09:19:59 <soupdragon> so I should do that I guess because I keep seeing that cross in a circle thing
09:20:07 <byorgey> sshc: the instance of 'Foo' is inferred from the type at which 'bar' is used.
09:20:23 <byorgey> sshc: if there's not enough information for it to be inferred you may have to give a type annotation.
09:20:33 <sshc> byorgey: yes, there is not enough information
09:20:40 <hatds> is there a reason Data.Vector doesn't have the usual instances? (Functor, Foldable, Traversable)
09:20:47 <sshc> byorgey: since the type of a and c are not inferred, but b is
09:20:48 <hatds> *Data.Array.Vector
09:20:49 <byorgey> sshc: also, if the type of 'bar' does not actually involve all of a, b, and c, you may need some functional dependencies
09:20:57 <byorgey> sshc: because otherwise there will never be enough information.
09:21:16 <byorgey> sshc: what is the type of 'bar' ?
09:23:21 <chrisdone> byorgey: http://gist.github.com/290636 -- gonna add more to it i.e. to auto-start a haskell process if one isn't there, make sure QuickCheck is loaded in GHCi, etc. maybe some interaction with one of the hackage libraries to test all properties in a given file, interaction with C-c C-l, etc. feel free to patch that gist
09:24:10 <sshc> byorgey: This is the real definition with different names: class (Quux v, Bar a v, Bar b v, Bar c v, Bar d v) => Foo v a b c d where aoeu :: a -> b -> ADataConstructor c d
09:24:28 <burp> can't I use Text.Parsec.Tokens with bytestrings? (Text.Parsec.ByteString)
09:24:35 <sshc> byorgey: I have many instances of the Foo class
09:24:54 <sshc> byorgey: how do  Ispecify which instance of Foo to use?
09:25:51 <burp> > :t float (makeTokenParser haskellDef) ,... Text.Parsec.Prim.ParsecT String u mtl-1.1.0.2:Control.Monad.Identity.Identity Double
09:25:52 <lambdabot>   <no location info>: parse error on input `:'
09:27:05 <burp> where does that String come from?
09:29:57 <byorgey> sshc: yeah, you can't really, unless you add some functional dependencies
09:30:10 <byorgey> sshc: since v does not show up in the type of aoeu
09:30:37 <byorgey> sshc: you need to add something like  ... => Foo v a b c d | a -> v  (for example, if the type a determines v uniquely)
09:31:07 <sshc> byorgey: when I call aoeu, GHC errors out with: No instance for (Foo v3 ConcreteType ConcreteType AnotherConcreteType d)
09:31:11 <byorgey> otherwise there could be multiple instances with different types for v and there is no way to know which one you want just by looking at the type of aoeu
09:31:28 <sshc> byorgey: wouldn't it be | v -> a?
09:31:41 <byorgey> sshc: no,  a -> v  means that a determines v
09:31:52 <sshc> I see
09:32:01 <byorgey> i.e. given a concrete type for a, there can only be one possible instance for v
09:32:17 <byorgey> so if it can find one, it knows that must be the right one to use
09:32:23 <sshc> yes, that is true
09:32:26 <jlouis> I tend to read it exactly as "a determines v"
09:32:50 <byorgey> otherwise there could be multiple ones, and since type classes are open even if there is only one instance currently in scope, it could be linked with another module with a different instance, etc...
09:33:31 <_Shadow> can someone guide me use QEMU?
09:33:35 <_Shadow> I am on windows
09:33:48 <_Shadow> I have downloaded the files
09:33:53 <Zao> _Shadow: I do not particularly see the relevance to Haskell.
09:34:06 <Zao> Consider asking a relevant channel instead?
09:34:11 <sshc> QEMU?
09:34:12 <_Shadow> I want to use House
09:34:22 <_Shadow> that is why
09:34:36 <Zao> sshc: VM emulator, basically.
09:34:48 <_Shadow> kmc recommended to use QEMU
09:34:55 <_Shadow> but I can't make out how
09:35:17 <Zao> http://programatica.cs.pdx.edu/House/ <- that, I guess.
09:35:29 <_Shadow> yeah
09:35:34 <Zao> In any way, read the qemu docs or ask in a qemu channel, I'd say.
09:35:50 <_Shadow> oh is there a channel for qemu too??
09:35:50 <joga> _Shadow: maybe consider using Virtualbox instead (it's GUI)
09:35:53 <_Shadow> okay fine then
09:36:01 <_Shadow> okay
09:36:17 <joga> (unless it was designed to be run in qemu or something)
09:36:48 <burp> :t makeTokenParser emptyDef
09:36:49 <lambdabot> Not in scope: `makeTokenParser'
09:36:49 <lambdabot> Not in scope: `emptyDef'
09:38:07 <jlouis> If an ADT derives Ord, what is the default ordering? Occurence? That is data Foo = A | B | C means A < B < C ?
09:38:37 <burp> makeTokenParser emptyDef   :: GenTokenParser String u mtl-1.1.0.2:Control.Monad.Identity.Identity ‚Üê why does it use String?
09:38:50 <jlouis> Or is it lexicographic on the name, or up to the compiler_
09:39:08 <doserj> jlouis: order in definition
09:39:27 <nainaide> :t tail
09:39:28 <lambdabot> forall a. [a] -> [a]
09:40:35 <jlouis> doserj: mmm, The H98 Report says so too :)
09:40:55 <doserj> clever report
10:15:14 <rhox> Hello everybody. I am trying to install lambdabot on Ubuntu 9.10, but cabal-install doesn't like it:
10:15:27 <rhox> cabal: cannot configure show-0.3.4. It requires QuickCheck <2
10:15:44 <rhox> and: QuickCheck-1.0 was excluded because tagsoup-0.8 requires QuickCheck ==2.1.*
10:16:03 <rhox> what can i do?
10:18:17 <doserj> rhox: constrain tagsoup to 0.6?
10:22:31 <rhox> with: --constraint tagsoup=0.6?
10:23:39 <doserj> --constraint=tagsoup-0.6, I think. But I don't remember the exact syntax
10:24:03 <Saizan> --constraint="tagsoup == 0.6"
10:28:48 <rhox> now i a get another message: cabal: Error: some packages failed to install: ...
10:29:15 <rhox> haskell-src-1.0.1.3 failed during the building phase. The exception was: exit: ExitFailure 1 ...
10:30:01 <rhox> lambdabot-4.2.2.1 depends on readline-1.0.1.0 which failed to install. ...
10:30:17 <mreh> can I represent a Permutation using Set? I don't suppose Set keeps any ordering information?
10:30:31 <mreh> I'd like to borrow the implementation of set minus
10:30:45 <rhox> readline-1.0.1.0 failed during the configure step. The exception was: exit: ExitFailure 1
10:31:54 <Saizan> rhox: you should look in the log for the actual errors about haskell-src and readline
10:33:44 <rhox> trying to install haskell-src alone, i get:  cabal: The program happy is required but it could not be found
10:34:07 <Saizan> cabal install happy, and make sure it's in your $PATH
10:35:35 <rhox> yes i have just tried that, many warnings, but it completed
10:39:19 <rhox> still hanging with readline ...
10:40:25 <rhox> trying to install readline allone gives me:  configure: error: readline not found, so this package cannot be built
10:40:44 <mreh> :t Tip
10:40:45 <lambdabot> Not in scope: data constructor `Tip'
10:42:55 <doserj> rhox: install libreadline-dev or whatever it is called in ubuntu
10:44:10 <rhox> i have libreadline5-dev and libreadline6-dev; take the 6?
10:46:05 <doserj> I have no idea if there are incompatibilities...
10:46:12 <aavogt> you could very well install both?
10:46:26 <monochrom> which ghc version?
10:46:56 <rhox> ghc 6.10.4
10:47:22 --- mode: ChanServ set +o Lemmih
10:47:24 <monochrom> it doesn't need readline. it needs editline.
10:47:30 <mreh> data Set a    = Tip
10:47:31 <mreh>               | Bin {-# UNPACK #-} !Size a !(Set a) !(Set a)
10:47:35 --- mode: Lemmih set +v MoeKhoe
10:47:38 <mreh> what does this mean?
10:47:52 <rhox> lambdabot completed with libreadline6-dev
10:48:12 <MoeKhoe> hi
10:48:16 <rhox> but it asked for readline
10:48:19 <MoeKhoe> @pf \x -> x
10:48:19 <lambdabot> Maybe you meant: bf pl
10:48:25 <mreh> !Size?
10:48:25 <MoeKhoe> @pl \x -> x
10:48:25 <lambdabot> id
10:48:34 <aavogt> mreh: the ! means that the field is strict
10:48:39 <MoeKhoe> @pl \(d1,r1) (d2,r2) -> (d1+d2,r1+r2)
10:48:40 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (+)) . flip . (((.) . (,)) .) . (+))
10:48:54 <MoeKhoe> is there a way to use lambdabot without bothering everybody here?
10:49:01 <burp> MoeKhoe: query it
10:49:03 <burp> erm her
10:49:07 <rhox> i will check it out tomorrow, thank you for the help
10:49:26 <mreh> aavogt: it's not an expression, or does that mean anything in that field will be evaluated immediately
10:49:27 <monochrom> /msg lambdabot @pl \x->x
10:49:37 <MoeKhoe> thanks
10:50:19 <aavogt> mreh: it means that   Bin s x y z = undefined  whenever any of  s, y, z are undefined
10:52:17 <MoeKhoe> is there a more concise way of writing  \(d1,r1) (d2,r2) -> (d1+d2,r1+r2)  ?
10:52:18 <mreh> aavogt is that likely seeing as the implementation is hidden?
10:52:32 <aavogt> I'm not sure why the fields for individual elements aren't strict, though I suppose that adding elements to the set requires you to compare values... which usually results in the element being evaluated
10:53:33 <aavogt> > Set.fromList [1,2,3,(succ.succ.succ.succ.succ) undefined ] :: Set.Set Natural
10:53:34 <lambdabot>   Not in scope: type constructor or class `Set.Set'Not in scope: type constru...
10:53:43 <aavogt> > Set.fromList [1,2,3,(succ.succ.succ.succ.succ) undefined ] :: Set Natural
10:53:44 <lambdabot>   Not in scope: type constructor or class `Set'Not in scope: type constructor...
10:53:55 <aavogt> > Set.fromList [1,2,3,(succ.succ.succ.succ.succ) undefined ::Natural ]
10:53:56 <lambdabot>   Not in scope: `Set.fromList'Not in scope: type constructor or class `Natural'
10:54:15 <aavogt> > Data.Set.fromList [1,2,3,(succ.succ.succ.succ.succ) undefined ::Nat ]
10:54:16 <lambdabot>   Not in scope: `Data.Set.fromList'
10:54:33 <aavogt> hmm, doesn't seem to exist
10:55:37 <aavogt> mreh: well in any case, if the implementation was different, then maybe you could construct and destruct sets containing partially defined elements
10:56:08 <aavogt> at least it should be lazy enough to accept that one (though it seems that \bot is missing some imports)
10:56:25 <aavogt> and only fail on printing the highest number in the set
10:58:50 <aavogt> @type ((+) *** (+))
10:58:52 <lambdabot> forall b b'. (Num b, Num b') => (b, b') -> (b -> b, b' -> b')
10:59:58 <aavogt> @pl \(x,y) -> ((x+) *** (y+))
10:59:58 <lambdabot> uncurry ((. (+)) . (***) . (+))
11:00:24 <aavogt> MoeKhoe: ^^ that's shorter
11:01:12 <temoto> A friend of mine just invented the greatest monad analogy ever.
11:02:32 <temoto> It's like a public toilet: you go there, close the door and do all kinds of dirty things. Then you put your pants back on, exit it and you're back clean and safe.
11:03:25 <temoto> Yeah it doesn't go well with List but sure awesome for IO and State.
11:04:03 <aavogt> depends whether public toilet activities are non-deterministic
11:15:45 <Saizan> with that analogy the final runState is like going naked out of the toilet?
11:16:00 <Chaze> what kind of signature is this?  f :: [()] -> ()
11:16:07 <Saizan> however the greatest one is copumpkin's one about unicorns
11:16:08 <Chaze> is () a 0-tuple?
11:16:11 <Saizan> yes
11:16:14 <Saizan> > ()
11:16:15 <lambdabot>   ()
11:16:16 <copumpkin> lol
11:16:19 <Saizan> ?type ()
11:16:20 <lambdabot> ()
11:16:35 <copumpkin> not sure I'd go so far as to say it's the greatest one
11:16:42 <Chaze> why does this procuce it?   let f = foldl1 max
11:16:52 <monochrom> Saizan: What analogy?
11:17:14 <pikhq> :t foldl1 max
11:17:15 <lambdabot> forall a. (Ord a) => [a] -> a
11:17:37 <pikhq> @instance Ord
11:17:38 <lambdabot> Maybe you meant: instances instances-importing
11:17:40 <Saizan> Chaze: it does only because of the monomorphism restriction and ghci's extented defaulting
11:17:42 <pikhq> @instances Ord
11:17:43 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), (a, b, c, d, e), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
11:17:49 <Saizan> ?type let f = foldl1 max in f
11:17:50 <lambdabot> forall a. (Ord a) => [a] -> a
11:18:13 <pikhq> Clearly, it does that because () is an instance of Ord.
11:18:28 <Chaze> well, I get the type posted earlier in ghci
11:19:32 <Chaze> and i still don't get it. can somebody rephrase that?
11:20:57 <Saizan> monochrom: unicorns are like monadic actions, they all chain together, i'll let you imagine how
11:21:25 <Saizan> Chaze: ok, foldl1 max by itself would have type (Ord a) => [a] -> a
11:21:26 <monochrom> Oh wait, I now remember!
11:21:50 <monochrom> I now remember I have programmed my irc software to flush all stupid analogies down the toilet.
11:21:54 <Chaze> yes..
11:22:16 <monochrom> So I didn't see any analogy, and if you try to tell me the analogy again, I will still not see it.
11:22:23 <Saizan> Chaze: but definitions like  let f = foldl1 max which have no formal parameters can't be typelcass polymorphic
11:22:39 <Saizan> Chaze: i.e. the Ord a context must be resolved to a concrete type
11:23:13 <copumpkin> monochrom: I'm offended
11:23:15 <Saizan> Chaze: ghci has extended default rules, so it picks () as the type to default to
11:24:09 <Saizan> monochrom: hah, well, you'll miss this great piece of humor then
11:24:24 <monochrom> haha
11:24:31 <Chaze> I see. How would I define it for a specific type?
11:24:47 <Saizan> Chaze: you can give it a type signature
11:25:00 <Chaze> but i can't do that in interactive mode
11:25:02 <Saizan> Chaze: you can actually get the polymorphic type if you give it explicitly
11:25:06 <Saizan> sure
11:25:08 <Chaze> can't i do a :: Int somewhere ?
11:25:12 <Chaze> i can? wow
11:25:24 <Saizan> let f :: Ord a => [a] -> a; f = foldl1 max
11:25:31 <Saizan> or you can add an argument
11:25:37 <Saizan> let f xs = foldl1 max xs
11:25:39 <Chaze> I figured so much
11:25:43 <Chaze> thanks!
11:26:11 <Saizan> np :)
11:28:38 <burp> http://paste.railsbox.eu/show/226/ ‚Üê why is parsing doubles with format "double double double" so slow? it takes 17 seconds for 100k lines
11:29:23 <burp> and I already used the ByteString parser
11:29:55 <Chaze> it also seems to work when running with -XNoMonomorphismRestriction, although I have no idea what that means. Bad idea?
11:30:16 <Baughn> Chaze: Possibly confusing idea. You need to know what it means.
11:30:47 <Saizan> Chaze: that removes the restriction about typeclass contexts for parameterless bindings i was talking before
11:31:25 <Saizan> Chaze: the only downside is that you've to look at the type of the binding to tell if its evaluation will be shared or not
11:31:38 <Saizan> Chaze: typeclass polymorphic ones won't be shared
11:32:22 <Chaze> well, I was thinking if the only downside is some restriction on formal proves or whatever, I might as well ignore that. What consequences are there?
11:34:04 <Lemmih> burp: parsec isn't known to be fast.
11:34:18 <luqui> i'm trying to load a list into a Ptr GLdouble
11:34:24 <luqui> where should I look?
11:34:29 <Chaze> nevermind, I found http://www.haskell.org/haskellwiki/Monomorphism_restriction and will read through that
11:34:32 <Saizan> it's not known to be slow either
11:34:53 <Saizan> though maybe the lexer things are not really optimized
11:35:04 <soupdragon> hey luqui I just saw  your quantum code
11:35:32 <Philonous> Chaze: Performance might degrade a bit. Shouldn't be dramatic, though. I'd recommend putting it on top of every haskell file. It prevents some really counterintuitive error messages.
11:35:42 <dons> burp: using the bytestring-lexing package?
11:35:53 <mreh> "instead of pairing we use CPS"?!
11:35:55 <mreh> what is CPS?
11:35:56 <dons> burp: there are special purpose parsers for numeric data on hackage (e.g. bytestring-lexing)
11:36:05 <dons> burp: that dont' use String for input, but instead, bytestrings.
11:36:09 <Philonous> mreh: Continuation passing style
11:36:13 <dons> you can also use Data.Binary for very fast parsing.
11:36:21 <mreh> Philonous: oh, never done that before
11:36:34 <burp> dons: oh, thanks
11:39:59 <luqui> found it.  Foreign.Marshal.withArray
11:40:04 <luqui> soupdragon, aa soo?
11:40:24 <soupdragon> it's funny how I keep coming across stuff you wrote!
11:40:45 <luqui> similar interests?
11:42:02 <soupdragon> no I don't think so
11:42:37 <soupdragon> I think you are just prolific
11:42:48 <soupdragon> for example I have NFI about FR
11:42:51 <soupdragon> FRP
11:43:19 <luqui> you will :P
11:46:25 <edwardk> heya luqui
11:47:05 <luqui> hola
11:48:22 <copumpkin> holla
11:48:45 <edwardk> challah
11:49:48 <edwardk> luqui: anything specific prompt your foray into free monads?
11:50:11 <copumpkin> are there free comonads or cofree monads?
11:50:16 <monochrom> free thinks long for free monads
11:50:20 <monochrom> err
11:50:23 <monochrom> free thinkers long for free monads
11:50:32 <edwardk> copumpkin: there is a monad for the prod-type construction that is used in the cofree comonad
11:50:38 <luqui> edwardk, yeah, my console UI programming
11:50:43 <edwardk> the converse would require costrength or coexponentials
11:50:45 <edwardk> iirc
11:50:48 <ray> http://www.fileformat.info/info/unicode/char/2041/index.htm
11:50:49 <copumpkin> ah
11:50:56 <ray> it's the punctuation-mark lambda we've wanted!
11:51:03 <ray> just one little flaw
11:51:05 <copumpkin> dammit
11:51:13 <copumpkin> now we'll have to start writing all our haskell backwards
11:51:20 <luqui> data Command i o a = Return a | More o (i -> Command i o a)
11:51:43 <soupdragon> is that like apfelmus monad reader thing?
11:51:55 <edwardk> luqui: ah, hence the inquiry to see if the codensity version would be better
11:52:02 <luqui> yeah
11:53:08 <luqui> which I have still not tried.  SInce I need to gradually pull it apart -- i.e. i am not immediately reducing to a summary value -- I am not sure if the transform works..
11:54:06 <edwardk> luqui: well, there is always the monad-ran version of IO if you're looking for intuition
11:54:20 <luqui> edwardk, oh?
11:54:22 <edwardk> but maybe thats going a bit far afield
11:54:43 <luqui> you and your kan extensions
11:54:49 <luqui> i have no idea what you are talking about :-)
11:56:02 <edwardk> in monad-ran i encode Ran IO a ~ forall r. (a -> World RealWorld -> r) -> World RealWorld -> r
11:56:29 <edwardk> which is the realization that IO looks like StateT (World RealWorld)
11:56:48 <edwardk> converted to cps'd state
11:57:04 <luqui> what is the advantage?
11:57:07 <luqui> if any?
11:57:25 <temoto> soupdragon, what is NFI?
11:57:54 <edwardk> lift/liftIO/fmap/return and bind can be cheaper if using a codensity transformer on a monad in codensity form
11:58:02 <soupdragon> no freaking idea
11:58:15 <soupdragon> as in I understand quantum physics better than this
11:58:22 <temoto> :)
11:58:22 <edwardk> monad-ran tried to do the same thing for all right kan extensions, but it turned out to only be a win if everything was in codensity form
11:58:35 <temoto> soupdragon, you do?
11:58:50 <soupdragon> i.e. not at all
11:59:08 <Saizan> edwardk: so only if the two functors were equal?
11:59:19 <edwardk> Saizan: yeah
11:59:37 <edwardk> Saizan: thats what i found when i started trying to code the kata mt; ;)
11:59:38 <edwardk> er mtl
11:59:58 <luqui> interesting...
12:00:04 <soupdragon> luqui what do you think about bootstrap.org
12:00:13 <soupdragon> um
12:00:15 <soupdragon> sorry
12:00:32 <edwardk> there are a bunch of useful codensity based monads though, state, io, stm, ST s, state-based-writer, etc.
12:01:16 <soupdragon> what is the right url...
12:01:18 <edwardk> it seems the similar density based comonads don't add any value because density looks a lot like the result of closure conversion,
12:01:42 <soupdragon> http://www.bootstrapworld.org/
12:01:51 <soupdragon> it is basically FRP?
12:02:18 <Saizan> so forall r. (a -> Maybe r) -> Maybe r is better than forall r. (a -> r) -> r -> r ? and is it better than Maybe a?
12:02:34 <luqui> soupdragon, not sure, never heard of it
12:02:49 <soupdragon> you can write mario and stuff
12:02:59 <soupdragon> (using pure functions)
12:03:16 <luqui> well FRP in the way I view it is about semantics
12:03:21 <soupdragon> the overall idea is object oriented though, but you don't program at that level
12:03:24 <luqui> but roughly it's about pure functional interactivity
12:03:39 <luqui> but there is more to it than that -- or rather there is more to a *good* FRP interface than just purity
12:04:00 <luqui> but i don't really have time to look into it right now
12:04:25 <edwardk> Saizan: different functionality. substitute (->) e for Maybe, and you'll see
12:07:15 <Saizan> edwardk: mh, i guess it's extended
12:07:17 <edwardk> the advantage of forall r. (a -> f r) -> f r is that you don't need to know how to do anything to f to be able to fmap, bind, and return Codensity f. You don't even need f to be a functor, just to have kind * -> *
12:07:32 <edwardk> but that isn't isomorphic to f.
12:07:35 <edwardk> yeah
12:10:06 <edwardk> in the case of Codensity ((->)e) you can appeal to some stuff i built up in http://comonad.com/reader/2008/kan-extensions-ii/ to show that it is isomorphic to State e, not Reader e =)
12:13:01 <edwardk> (,) e -| (->) e, so using the ranToComposedAdjoint/composedAdjointToRan Ran ((->)e) h a ~ (h `O` (,)e) a, when h = (->)e, that says Codensity ((->)e) ~ ((->)e `O` (,)e) -- the latter is State.
12:13:13 <copumpkin> how did density and strength get their names?
12:13:19 <copumpkin> I mean, in CT
12:14:05 <edwardk> density comes from topology
12:14:43 <edwardk> strength comes from http://home.imf.au.dk/kock/SFMM.pdf
12:15:27 <edwardk> but probably dates back to its use with tensors even farther
12:16:15 <orgullocachanill> It is time to put those Haitian jigaboos in their place!  No matter how many times the civilized world donates money, opens schools, rebuilds their nation, and holds their little monkey paws, the damn niggers can never get it right.  They never will!  The same goes for New Orleans!  Cancun in Mexico suffered few fatalities after their major hurricane, and the rebuilding is already completed.  What have the niggers in New Or
12:16:16 <orgullocachanill> lean
12:16:17 <orgullocachanill>  s done?  If you are sick of this, join Chimpout forum!  http://www.chimpout.com/forum
12:16:24 <copumpkin> @where ops
12:16:25 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver monochrom
12:16:43 <Spockz> long live the highlights :)
12:17:22 <copumpkin> ah well, I tried
12:17:29 --- mode: ChanServ set +o Saizan
12:17:34 --- mode: Saizan set +b *!*ChorizoGr@*.170.169.40.dsl.dyn.telnor.net
12:17:34 --- kick: orgullocachanill was kicked by Saizan (orgullocachanill)
12:17:48 --- mode: Saizan set -o Saizan
12:18:08 <Spockz> ha wow my teacher is an op here... :P
12:18:17 <edwardk> Spockz: who?
12:18:22 <Twey> Saizan is your teacher?
12:18:27 <Spockz> k.osmikus
12:18:50 <burp> you mean kosmikus?
12:19:01 <Spockz> burp: yes, or is he only a lambdabot op?
12:19:15 <dolio> Those are channel ops.
12:19:32 <Spockz> he doesn't show as one
12:20:35 <Spockz> right ^^ :p
12:20:56 <Saizan> edwardk: actually, i've used the extra power of Codensity multiple times, just didn't realize it mattered here :)
12:21:46 <edwardk> Saizan: yeah like when you pointed out i was overcomplicating things with the type for that 'is this ref still alive' monad
12:22:30 <edwardk> which, alas, proved to be an interesting diversion buys useless
12:22:32 <edwardk> er but
12:22:53 <burp> http://paste.railsbox.eu/show/HtlHUUx6Wu2o6nK9DZJN/ this still takes ~6-8s for parsing 100k lines of doubles with bytestring-lexing, can this be further improved?
12:23:01 <Saizan> i guess this is a lot like those slides were filinski packages up continuations behind a monadic interface so that you get only controlled effects
12:23:36 <temoto> @src length
12:23:36 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
12:24:01 <temoto> > length [2]
12:24:02 <lambdabot>   1
12:24:07 <temoto> Why no source?
12:24:26 <Saizan> burp: are you compiling with -O2 ?
12:24:47 <burp> yes
12:24:53 <dolio> ski: ping
12:28:39 <soupdragon> does anyone have something that works like Show except turns haskell values into a nice HTML form?
12:28:57 <burp> http://paste.railsbox.eu/show/B2XnwWIMh7zTzWnraxdR/ sample data: http://tobias-neumann.eu/tmp/100k.txt.gz in case someone wants to try
12:29:17 <syntaxglitch> what do you mean by "nice HTML form"? character escaping?
12:29:45 <soupdragon> that would be one part
12:30:02 <syntaxglitch> or actually building markup based on the structure of the type somehow
12:30:06 <Saizan> edwardk: though i thought Ran M would win over M simply by the induced deforestation
12:31:13 <syntaxglitch> soupdragon, if you just want escaping I'd be shocked if there wasn't already code for that--it'd then be trivial to turn any Show instance into an html escaped version
12:31:23 <soupdragon> more than escaping
12:31:33 <soupdragon> I need to implement it for practically everything Show implements
12:31:47 <soupdragon> hm
12:31:55 <soupdragon> can you do a typeclass like
12:31:59 <syntaxglitch> soupdragon, what else do you want it to do?
12:32:05 <soupdragon> htmlize (Specific x) = <something special>
12:32:14 <soupdragon> htmlize everythingElse = show everythingElse
12:32:15 <soupdragon> ?
12:32:37 <luqui> soupdragon, no
12:32:43 <luqui> soupdragon, I would suggest html combinators
12:32:47 <Saizan> yes with OverlappingInstances
12:32:55 <soupdragon> does html combinators exist already?
12:33:00 <shapr> Does anyone have income tax code in Haskell? :-)
12:33:02 <syntaxglitch> soupdragon, if I understand what you mean then no, at least not without weird metaprogramming hackery
12:33:02 <luqui> probably somewhere
12:33:17 <luqui> soupdragon, but it's not that important, they would be easy to implement
12:33:32 <luqui> and have one combinator showable :: (Show a) => a -> HTML
12:33:41 <syntaxglitch> soupdragon, what kind of markup do you want this to emit, anyway?
12:33:50 <luqui> and then for the datatypes that have more structure, use more specific functions that generate HTML
12:34:27 <soupdragon> most things should have the normal presentation, but I want some special guys that don't
12:35:23 <Saizan> instance Show a => Htmlize a where htmlize a = show a; instance Htmlize Special where htmlize s = ...
12:36:07 <Saizan> then ghc will complain about a missing Show instance, if your type lacks both
12:36:25 <soupdragon> cool
12:36:40 <soupdragon> I would have thought Special needs to go before a
12:36:47 <Saizan> {-# LANGUAGE OverlappingInstances, UndecidableInstances #-}
12:36:57 <Saizan> no, the order doesn't matter
12:37:03 <Saizan> it picks the most specific match
12:38:43 <syntaxglitch> I also assume that overlapping instances could be avoided if Special isn't an instance of Show
12:38:53 <syntaxglitch> which may or may not be possible
12:39:19 <Saizan> syntaxglitch: no, you can't avoid that extension here
12:39:29 <syntaxglitch> Oh, right
12:39:41 <syntaxglitch> It doesn't look at the context until after finding a match
12:39:46 <Saizan> typeclass resolution assumes an open world, so no negation
12:39:46 <syntaxglitch> I always forget about that :(
12:39:46 <Polarina> How could I easily establish a TCP connection somewhere and get a lazy bytestring to read from the stream? :)
12:40:14 <syntaxglitch> Saizan, sorry, that still seems unintuitive to me, even if it's clear why it's done that way
12:40:20 <Saizan> use the Network to get an Handle, and the hGetContents
12:40:31 <Saizan> *then
12:40:33 <Polarina> Saizan, is that a bytestring?
12:40:44 <burp> there is hGetContents in lazy bytestring
12:40:50 <Polarina> :)
12:41:05 <Polarina> I'll go learn haskell networking now. Thanks.
12:41:35 <soupdragon> http://hackage.haskell.org/packages/archive/xml/1.3.5/doc/html/Text-XML-Light.html
12:41:45 <Saizan> it'd be a bit nervous if i were using lazy IO with network handles
12:42:07 <Polarina> Saizan, but lazy IO is great for an IRC bot.
12:42:08 <soupdragon> :s how do you install cabal
12:42:28 <Zao> soupdragon: Cabal or cabal-install?
12:42:33 <soupdragon> I don't know
12:42:41 <Saizan> Cabal comes with ghc
12:42:50 <Zao> Saizan: You can upgrade it.
12:42:53 <Saizan> soupdragon: which version of ghc are you using?
12:43:09 <Twey> Needs more Iteratee
12:43:17 <Zao> Cabal is the usual ghc --make Setup && ./Setup configure && ./Setup build && ./Setup install
12:43:20 <soupdragon> 6.12.1
12:43:34 <Zao> cabal-install is similiar, or run the bootstrap.{sh,bat} scripts.
12:44:02 <Zao> cabal-install provides the cabal[.exe] binary
12:44:26 <Saizan> http://hackage.haskell.org/packages/archive/cabal-install/0.8.0/cabal-install-0.8.0.tar.gz <- the tarball
12:45:18 <soupdragon> okay thanks I am trying bootstrap
12:45:40 <Saizan> (there's no .bat though!)
12:45:49 <Zao> Saizan: Mixing it up with Boost, I guess.
12:46:13 <Zao> Use the .sh under msys then, or just grab the dependencies manually.
12:46:33 <mreh> I've got to swap elements in a list to make a random permutation, I was thinking of turning the list to a complete binary tree with the elements on the leaves and swapping them
12:47:53 <Saizan> the swapping algorithm works well only with arrays
12:48:31 <Saizan> with trees you just pick a random element each time and delete it from the tree
12:48:45 <mreh> Saizan: then it looses it's completeness
12:49:14 <Saizan> yeah, but you've built your permutation
12:49:23 <soupdragon> wow
12:49:30 <soupdragon> trying to link cabal almost crashed my computer
12:49:52 <mreh> Saizan: what about the intermediate steps?
12:50:27 <mreh> I have to choose other elements from an incomplete tree
12:50:43 <soupdragon> it says Building the cabal-install package failed so I guess I am out of luck
12:51:06 <Zao> soupdragon: Due to?
12:51:17 <soupdragon> I don't know, it doesn't say
12:51:19 <Zao> soupdragon: I have successfully built that one on 6.12.1 on Windows.
12:51:55 <Zao> Might have had to mutate some .cabal files slightly.
12:52:51 <Saizan> well, if you killed it while linking i guess that's the problem
12:53:51 <soupdragon> I didn't kill it
12:54:02 <soupdragon> I don't get this
12:54:14 <soupdragon> I thought boostrap would at least install the deps
12:54:22 <soupdragon> it's made .cabal/lib/HTTP-4000.0.8/ghc-6.12.1 ?
12:54:28 <soupdragon> but cabal doesn't realize it's there
12:54:33 <soupdragon> ugh I give up
12:54:44 <Saizan> soupdragon: you've to use --user, i think
12:54:47 <Saizan> mreh: true, i wasn't thinking that the completeness helps for indexing
12:54:48 <mreh_> don't give up!
12:55:46 <mreh_> does anyone know how to shuffle a list with complete trees?
12:55:54 <soupdragon> Saizan wow that did it!
12:55:57 <mreh_> the indexing bit is easy, removing the element is hard
12:57:18 <Saizan> so you don't understand how oleg's extract_tree works?
12:58:47 <mreh_> Saizan: nup
12:59:20 <mreh_> I don't understand the continuation passing either
12:59:21 <Saizan> well, it actually stores the number of leaves in the Node, so it's not so important to keep it complete
12:59:39 <mreh_> Saizan: that's very true
12:59:42 <Saizan> it'll still work in O(n log n)
13:00:22 <Saizan> actually, you can just use a Data.Sequence.Seq
13:00:42 <mreh_> so you can go along the nodes you visit subtracting one to keep the invariant
13:00:52 <Saizan> yeah
13:01:40 <mreh_> I'm going the TSDp with a GA
13:04:13 <soupdragon> even 'xml: A simple XML library.' is too complicated for me
13:04:32 <soupdragon> what's the easiest way to generate html from haskell?
13:04:49 <Twey> The HTML library, I guess
13:05:04 <Twey> Although StringTemplate might be easier, for some definition of ‚Äògenerate‚Äô
13:05:10 <soupdragon> http://hackage.haskell.org/package/html-1.0.1.2 this?
13:05:13 <Twey> Yes
13:09:51 <soupdragon> toHtml "foo&bar"
13:09:51 <soupdragon> foo&amp;bar
13:09:53 <soupdragon> sweet!
13:10:36 <sshc> how do I override + for vectors in a manner similar to C++'s override?
13:10:46 <Twey> sshc: You make them an instance of Num
13:11:24 * copumpkin shudders
13:11:29 <sshc> copumpkin: why?
13:11:32 <Twey> But you probably shouldn't
13:11:36 <copumpkin> because Num comes with other baggage
13:11:44 <Twey> Because they're not really numbers, I'd say
13:11:50 <sshc> copumpkin: if I have vectors, it's pretty obvious that I'm not referring to the default +
13:12:01 <copumpkin> sshc: how about (*) ?
13:12:30 <sshc> I'm looking at  http://www.haskell.org/haskellwiki/Functional_dependencies
13:12:32 <copumpkin> if you have a vector of 3 components
13:12:40 <copumpkin> you could do cross product
13:12:49 <sshc> copumpkin: I could, but I prefer √ó, so I'd leave it undefined
13:12:57 * Twey winces.
13:13:03 <copumpkin> how about abs?
13:13:15 <sshc> what about mine?
13:13:24 <copumpkin> :P
13:13:25 <copumpkin> :t abs
13:13:26 <lambdabot> forall a. (Num a) => a -> a
13:13:27 <Twey> Hehe
13:13:36 <copumpkin> can you write an abs that takes your vector to your vector?
13:13:41 <copumpkin> it's a really silly type for abs
13:13:48 <copumpkin> but the nice one would require associated types
13:14:06 <copumpkin> it's also a silly thing to combine with the other ones
13:15:21 <sshc> if (*) is already part of the Num class, could I still write my own class such as FooMult a b c | a b -> c where (*) :: a -> b -> c, and then make instnances of (*)?
13:15:37 <sshc> instances of FooMult
13:15:42 <aavogt> you'll have to hide (Prelude.*)
13:15:50 <aavogt> or otherwise disambiguate them
13:15:57 <copumpkin> I'd use an associated type anyway
13:16:09 <Twey> You could use the Numeric Prelude instead
13:16:20 <Twey> That allows more control over your numbers
13:16:22 <sshc> I still need Prelude.*
13:16:28 <sshc> Numeric Prelude?
13:16:38 <copumpkin> don't do that
13:16:42 <Twey> http://www.haskell.org/haskellwiki/Numeric_Prelude
13:17:03 <aavogt> import qualified Prelude -- well you have to do this when you start replacing Prelude functions
13:17:19 <aavogt> whether or not those functions come from another library
13:17:35 <aavogt> what's wrong with Numeric Prelude, copumpkin?
13:17:42 <copumpkin> HT's naming scheme :P
13:17:48 <sshc> why should I stick with a separate function such as vectorAdd rather than make vectors an instance of the Num class for (+) and (-)?
13:18:06 <copumpkin> sshc: because Num is a silly class and we should boycott it
13:18:11 <aavogt> hmm, it's also GPL
13:18:19 <copumpkin> aavogt: I could live with that
13:18:23 <copumpkin> but T and C, never!
13:18:23 <Twey> Heh, Algebra.Ring.C
13:18:26 <monochrom> and what do you do with vector (*) ?
13:18:27 <Twey> Meh
13:18:36 <copumpkin> monochrom: for vector of 3 or 7 components, you're fine
13:18:39 <Twey> It's annoying, but it's better than Num :√æ
13:18:48 <monochrom> I mean sshc
13:19:06 <sshc> monochrom: I wouldn't define it
13:19:33 <sshc> monochrom: although I'm not sure what would happen if somebody accidentally called it somewher in the code not realizing there's a separate function for that
13:19:40 <monochrom> Think through the consequences, then do what you like.
13:21:03 <sshc> monochrom: while I don't need to worry about that, anytime soon anyway, I'd still like to error out with sufficient information instead of only outputting "Exception: undefined" and nothing else and crashing.
13:21:33 <aavogt>   (*) = error "Not implemented"
13:21:39 <Saizan> (*) = error "You shouldn't call Vector's (*)!!"
13:21:50 <monochrom> > error "multiplication for vector is not available"
13:21:51 <lambdabot>   * Exception: multiplication for vector is not available
13:22:17 <copumpkin> (*) = error "FUCKING NUM IS THE WORST CLASS EVAR. WHO THE FUCK CAME UP WITH THIS SHIT?"
13:22:18 <monochrom> Supposed there is also some lib providing some way to report line numbers.
13:22:25 <xerox> But sometimes it is :(
13:22:36 <copumpkin> that's what I was saying
13:22:51 <idnar> copumpkin: nice
13:22:54 <aavogt> @type assert
13:22:56 <lambdabot> Not in scope: `assert'
13:23:01 <xerox> How was that called... dons' stuff.
13:23:08 <monochrom> > error "the number you called is unavailable for now. please try again later"
13:23:09 <lambdabot>   * Exception: the number you called is unavailable for now. please try again...
13:23:16 <sshc> monochrom: which?
13:23:16 <xerox> haha
13:23:21 <aavogt> @hoogle assert
13:23:22 <lambdabot> Control.Exception assert :: Bool -> a -> a
13:23:22 <lambdabot> Control.OldException assert :: Bool -> a -> a
13:23:22 <lambdabot> Control.Exception.Base assert :: Bool -> a -> a
13:23:29 <luqui> @seen sinelaw
13:23:29 <lambdabot> Unknown command, try @list
13:23:30 <sshc> > assert False
13:23:31 <lambdabot>   Not in scope: `assert'
13:23:36 <xerox> ?where loch
13:23:36 <lambdabot> http://www.cse.unsw.edu.au/~dons/loch.html
13:23:36 <luqui> ... what happened to @seen?
13:23:38 <monochrom> Hell, I should s/number/Num/
13:23:42 <aavogt> > Control.Exception.assert False ()
13:23:43 <lambdabot>   Not in scope: `Control.Exception.assert'
13:23:46 <sinelaw> luqui, hi
13:23:46 <lambdabot> sinelaw: You have 1 new message. '/msg lambdabot @messages' to read it.
13:23:48 <xerox> sshc that one ---^
13:23:48 <aavogt> , Control.Exception.assert False ()
13:23:56 <luqui> sinelaw, hi.  just saw your contribs to g-dc
13:24:19 <idnar> The typeclass method you have called is outside of the coverage area. Please try again later.
13:24:21 <luqui> sinelaw, thanks for adding the font thing to the example.  i didn't realize i hadn't included the font.ttf i was using locally
13:24:49 <luqui> sinelaw, i am in the process of removing dependence on sdl from the lib since it doesn't build anywhere but linux easily.
13:25:02 <aavogt> at least in ghc, assert gives line numbers
13:25:23 <sinelaw> hmm. about sdl, will that mean i'll have to do extra work to get it to work again *with* sdl?
13:25:41 <luqui> sinelaw, I hope not.  it should be windowing lib independent
13:25:49 <luqui> substituting image and font support for other libraries on hackage
13:26:08 <sinelaw> luqui, i hope it doesn't become too hard
13:26:45 <luqui> yeah well, the point is to make it easily cross-platform -- so if it becomes too hard then i have failed at my current goal
13:27:15 <sinelaw> luqui, well it could become easier for other platforms, but harder for linux
13:27:25 <luqui> i dev on linux, so i don't see that happening :-)
13:27:36 <copumpkin> failinux
13:27:53 <sinelaw> luqui, good :)
13:28:05 <sinelaw> luqui, did you see the other changes?
13:28:09 <Lajla> Query: is there any difference in Haskell between let's say a function passed an argument and the evaluation thereof for the language?
13:28:19 <luqui> sinelaw, yeah.  bezier will be nice.
13:28:43 <luqui> sinelaw, i moved the init stuff back out of init -- the library isn't meant to seize control of your opengl context.  it should work nicely with other opengl stuff if it is there.
13:28:52 <luqui> which means we have to reinit every frame.  no biggie, it's not expensive.
13:29:25 <sinelaw> luqui, but doesn't that seize control too? only again at every frame? (dunno too much about opengl, so excuse me)
13:29:55 <luqui> yeah but the frame draws in a GL.preservingAttrib
13:29:59 <sinelaw> ah
13:30:46 <luqui> the font lib i switched to was FTGL.  it does sieze control of that... unfortunately, becuase FTGL doesn't have anything that can be used like preservingAttrib
13:30:49 <luqui> fully destructive!
13:31:12 <sinelaw> maybe we can patch that lib? or is it an inherent problem
13:31:29 <luqui> anyway, do you know what happens if you specify fewer than 4 points to bezier?
13:31:36 <luqui> sinelaw, hmm maybe.  haven't looked into it.
13:32:39 <sinelaw> luqui, haven't tried that, but in my own implementation that was a problem :) did you try?
13:32:47 <sinelaw> (my non-opengl implementation)
13:33:04 <luqui> sinelaw, no just saw it in the comments.  maybe i'll just try :-P
13:33:15 <luqui> i like my functions at least to be total :-)
13:33:22 <mm_freak> hey, people‚Ä¶  if i would offer to write a List class, would that become part of the standard library sometime?
13:33:35 <luqui> mm_freak, very unlikely
13:33:36 <sinelaw> mm_freak, what?
13:33:37 <soupdragon> now I am looking at Hint and thinking if I had a simple webserver in haskell I could get rid of the lisp side of this program
13:33:44 <mm_freak> that class would generalize (head :: [a] -> a) to (head :: List l => l a -> a)
13:33:44 <luqui> mm_freak, we already have lists :-)
13:33:45 <aavogt> @where edison
13:33:46 <lambdabot> http://www.cs.princeton.edu/~rdockins/edison/home/
13:34:03 <mm_freak> the point:  saving a lot of qualified imports
13:34:04 <sinelaw> oh you mean type class
13:34:06 <sshc> mm_freak: that would be very useful
13:34:07 <soupdragon> mm_freak sounds pretty weird, like what's a  list but not []?
13:34:17 <mm_freak> soupdragon: a ByteString
13:34:19 <sinelaw> soupdragon, [] is a type, he means typeclass
13:34:20 <sshc> yes
13:34:23 <sshc> a ByteString, etc.
13:34:35 <mm_freak> it sucks to import everything qualified
13:34:35 <sshc> a vector perhaps?
13:34:37 <soupdragon> how is that a list?
13:34:41 <mm_freak> because of conflicting names
13:34:49 <soupdragon> @instances Traversible
13:34:49 <Saizan> it won't work with that type, for bytestrings :)
13:34:49 <lambdabot> Couldn't find class `Traversible'. Try @instances-importing
13:34:52 <sshc> yes, it does
13:34:56 <sshc> I would love a List class!
13:35:04 <mm_freak> oh well
13:35:07 <luqui> sinelaw, anyhow, i am wishywashing on the Image Any decision.  was that confusing to you?  do you like/disklike?
13:35:10 <mm_freak> class List l a
13:35:16 <sshc> in a cabal package, there is if flag(debug); how do I set that flag when I build?
13:35:18 <luqui> sinelaw, do you not use it? :-)
13:35:24 <sinelaw> luqui, truth is I don't understand it
13:35:27 <mm_freak> head :: List l a => l a -> a
13:35:27 <aavogt> bytestrings don't implement all list operations...
13:35:30 <Saizan> sshc: -fdebug
13:35:34 <mm_freak> instance List ByteString Char where
13:35:34 <sinelaw> luite, so no opinion
13:35:48 <Saizan> mm_freak: still wrong :)
13:35:54 <Saizan> mm_freak: head :: l -> a
13:36:01 <mm_freak> oh, sure =)
13:36:03 <luqui> sinelaw, ah that's good to know, i was afraid of that.
13:36:08 <aavogt> is that an intentional decision (as in inefficient ops aren't implemented)?
13:36:22 <mm_freak> aavogt: what's missing in ByteString?
13:36:57 <dixie> Hi ! I have problem with UTF8(?) HTTP downloaded ... and my try with Data.String.UTF8 doesn't work :( http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16813#a16813
13:37:10 <luqui> sinelaw, Any is equivalent to Bool, where its monoid operation is (||).   So when you mappend two Image Anys, their non-graphical values get or'ed together.  but i think i'll lose it and replace with plain Bools, at the expense of using mappend out of the box.
13:37:23 <aavogt> mm_freak: weird stuff like permutations
13:37:37 <mm_freak> aavogt: it's not implemented, but it's certainly possible =)
13:37:45 <mm_freak> and btw
13:37:54 <sinelaw> @tell ivanm thanks! that looks cool, but not as cool as i intend my program to eventually be...hopefully i will sometime actually implement all my wish-list features. and it will be in haskell, too!
13:37:57 <lambdabot> Consider it noted.
13:38:09 <sshc> I've always wanted a List class
13:38:16 <Saizan> dixie: ghc-6.12.1 ?
13:38:19 <mm_freak> with such a generalized interface you could get a lot of functions for free
13:38:25 <sshc> I've always wondered why it has'nt existed yet
13:38:25 <dixie> Saizan: yes
13:38:45 <mm_freak> permutations :: List l a => l -> [l]
13:38:46 <aavogt> you have to be careful not to end up with Num though :)
13:38:52 <sinelaw> luqui, what's bool's monoid op?
13:38:53 <dixie> Saizan: But I didn't removed ~/.cabal/ since 10.x .. maybe I have broken installation
13:39:01 <Saizan> dixie: no
13:39:13 <luqui> sinelaw, doesn't have one, because there are a few different "reasonable" ones
13:39:22 <sinelaw> fair enough
13:39:26 <Saizan> dixie: i think it's just that HTTP has not been updated yet to work with the new Unicode IO
13:39:31 <mm_freak> anyway‚Ä¶  i'd write that class, if there is hope for it to end up in the base
13:39:42 <mm_freak> really i'm annoyed by the current list interface
13:40:03 <sshc> I am too
13:40:04 <dixie> Saizan: Do you have some reference / article to which I should look for about this new Unicode GHC 6.12 stuff?
13:40:49 <Saizan> dixie: http://ghcmutterings.wordpress.com/2009/09/30/heads-up-what-you-need-to-know-about-unicode-io-in-ghc-6-12-1/
13:40:54 <dixie> Haskell is fine, but this String/ByteString.*/... things are quite complicated for me
13:41:09 <dixie> thanks.
13:41:21 <Twey> Strings slow.  Bytestrings fast.
13:41:46 <sinelaw> luqui, btw, good opportunity to thank you for your blog. i learn a lot from it.
13:42:00 <luqui> sinelaw, oh, thanks :-)
13:42:00 <dixie> Twey: That is nice. But Why I need that "Slow" ? :)
13:42:01 <sinelaw> (the semantic design one really was a breakthrough for me :)
13:42:35 <luqui> sinelaw, for me too!  conal++
13:42:37 <Saizan> String's are easier to work with, and lazier
13:43:25 <Twey> dixie: They're convenient sometimes
13:43:26 <Polarina> How would lazy hGetContents on a network stream behave with I/O errors -- and if any occurs, how would I detect such an error?
13:43:29 <luqui> sinelaw, i am still internalizing that idea.  its consequences are far-reaching.
13:44:14 <sinelaw> luqui, that's right. i'm doing my senior year project on it, btw :) http://www.ee.bgu.ac.il/~noamle/ I only recommend the "motivation" section, though. rest needs re-write.
13:44:37 <luqui> sinelaw, sweet :-)
13:45:04 <Saizan> Polarina: it'd just truncate the output there and you won't be able to see the difference with a normal EOF
13:45:36 <conal> :)
13:47:19 <sinelaw> luqui, i still don't understand how the non-graphical data is supposed to work (or what it means, in light of semantic design :)
13:47:25 <soupdragon> conal do you know about bootstrap teaching scheme project?
13:47:41 <Polarina> Saizan, can a error not be detected?
13:47:49 <luqui> sinelaw, Image a = R2 -> (Color, a)
13:47:51 <conal> soupdragon: nope
13:48:22 <sinelaw> luqui, what about the picking/Any part? what does that mean
13:48:23 <luqui> sinelaw, the sample function maps from R2's to the associated a's.  it's a wrapper around GL's selection interface.
13:48:41 <Saizan> Polarina: what do you mean?
13:49:01 <luqui> sinelaw, if you look at example.hs, you'll see how i use it to determine whether the user clicked on the left or the right side of the screen.
13:49:21 <luqui> the left side's semantics is (Red, "A") and the right's is (Blue, "B")
13:49:43 <Polarina> Saizan, can I detect somehow it it was just a connection being closed or some other error?
13:50:01 <luqui> i can't programmatically observe the colors because of OpenGL's limitations, so I use the second component to represent data that I can observe.
13:50:04 <sinelaw> luqui, that much i got. this is what confused me:
13:50:07 <sinelaw> > fmap (\(Any b) -> if b then Just text else Nothing)
13:50:08 <lambdabot>   No instances for (Test.SmallCheck.Serial (f Data.Monoid.Any),
13:50:08 <lambdabot>              ...
13:50:15 <Saizan> Polarina: no, you'll only see the bytestring end
13:50:17 <sinelaw> oops, didn't mean that for lambdabot to parse :)
13:50:24 <Polarina> Saizan, :(
13:50:31 <luqui> sinelaw, which part of that confuses you?
13:50:55 <sinelaw> what's the meaning of the fmap here? (could be obvious, but i can't see it)
13:51:12 <sinelaw> you're running that function on the values (the 'a') of the images?
13:51:18 <luqui> sinelaw, ah, maps over the second component of the tuple.
13:51:19 <luqui> yeah
13:51:45 <luqui> which is Any True where the shape exists, and Any False where it does not.
13:52:28 <sinelaw> where's Any in your meaning?
13:52:43 <luqui> sinelaw, what do you mean?
13:53:20 <sinelaw> the snd of that tuple is of type 'a', no?
13:53:22 <dixie> Saizan: thanks! now it works
13:53:44 <mm_freak> <Saizan> String's are easier to work with, and lazier
13:53:47 <mm_freak> i think that's wrong
13:53:55 <luqui> circle :: Image Any
13:53:56 <aavogt> > fmap (+1) (1,1)
13:53:57 <lambdabot>   (1,2)
13:53:59 <mm_freak> they are easier to work with, yes, and the reason is this:
13:54:08 <mm_freak> import qualified Data.ByteString.Char8 as B
13:54:21 <luqui> semantics is circle (x,y) = if x^2+x^2 <= 1 then (White, Any True) else (Transparent, Any False)
13:54:26 <mm_freak> B.split ' ' <$> B.readFile "blah.txt"
13:54:38 <mm_freak> B.this, B.that, ‚Ä¶
13:54:43 <luqui> so the Any comes from the geometric primitives' definitions
13:54:58 <mm_freak> that's exactly the reason why i want to write the List class
13:55:38 <aavogt> mm_freak: make your modules small enough that is sensible to import qualified Prelude; import Data.ByteString
13:56:15 <aavogt> or import qualified Prelude as P
13:56:19 <mm_freak> that doesn't solve the problem
13:56:26 <mm_freak> it just moves it elsewhere
13:56:32 <sinelaw> luqui, oh i see
13:56:35 <luqui> mm_freak, what is the engineering problem?
13:56:43 <luqui> mm_freak, or is it purely aesthetic?
13:56:56 <mm_freak> luqui: both
13:56:56 <Saizan> mm_freak: i was referring to pattern matching and the ability to represent all of unicode
13:57:02 <luqui> mm_freak, then what's the engineering problem?
13:57:12 <mm_freak> Saizan: indeed, pattern matching is a point
13:57:33 <mm_freak> luqui: if you have some new list-like structure, you have to implement everything from scratch
13:57:44 <mm_freak> a List class could generalize a lot of functionality
13:57:44 <Saizan> (though you can use uncons and ViewPatterns)
13:57:57 <sinelaw> luqui, so for all the geometrical primitives, (*all* your drawing primitives actually) it's R2 -> (Color, Any Bool)?
13:58:04 <mm_freak> you would get 90% of all list functions for free for your structure
13:58:28 <aavogt> hmm, does -XOverloadedStrings work for pattern litterals?
13:58:30 <luqui> sinelaw, yeah.  er, R2 -> (Color, Any).  I knew what you meant.
13:58:33 <Saizan> mm_freak: with random, probably suboptimal complexities :)
13:58:41 <dons> aavogt: mmm. i think yes.
13:58:59 <sinelaw> luqui, aha right.
13:59:01 <mm_freak> Saizan: not if you provide a reasonable interface to your list structure
13:59:24 <aavogt> let f "ab" = 1 in f :: (Num t1, Eq t, IsString t) => t -> t1
13:59:32 <aavogt> dons: yes it does
13:59:38 <Saizan> the problem has always been finding that one
13:59:38 <luqui> sinelaw, but the naming of that type is unclear, and it's awkward to work with.  Maybe I'll just add union = liftA2 (||)
13:59:42 <sinelaw> luqui, why "Any", btw?
13:59:43 <luqui> to be used instead of mappend
13:59:55 <mm_freak> Saizan: it doesn't look like anyone has searched for it at all
13:59:56 <luqui> sinelaw, defined in Data.Monoid, had the semantics I wanted.
14:00:16 <sinelaw> luqui, oh, didn't know that. why is it "Any" originally then?
14:00:25 <luqui> the idea is that mconcat (map Any xs) will be Any True if any of the xs are true.
14:00:38 <mm_freak> i think most people will agree that using ByteStrings in haskell is unnecessarily complicated
14:00:40 <sinelaw> ah....because of the or
14:00:41 <sinelaw> ok
14:00:42 <Saizan> mm_freak: i've seen attempts in the past, no proofs that you couldn't though, so it's an open problem :)
14:00:53 <mm_freak> they _should_ be as easy to use as lists
14:01:11 <sinelaw> luqui, in light of that being something standard, it's not bad
14:01:11 <mm_freak> including using head, tail, (++), etc.
14:01:27 <sinelaw> luqui, so my confusion was from ignorance, sort of
14:01:28 <luqui> sinelaw, yeah but it's obscure, little known.  and i think it is not that pleasant to work with.
14:01:50 <luqui> not sure if Bools would be that much more pleasant.
14:02:17 <Saizan> i don't think many people munge bytestrings directly
14:02:34 * sinelaw chews on a crispy bytestring
14:02:39 <luqui> mm_freak, that is a good point.
14:02:53 <luqui> mm_freak, re: reimplementing all the list combinators.
14:03:29 <mm_freak> yeah
14:03:38 <sinelaw> haskell should have typeclasses for every container type that has at least one instance implemented in haskell
14:03:48 <mm_freak> and either renaming them or forcing you to use qualified names everywhere
14:04:21 <Polarina> Saizan, can I do a sClose on the handle once the string from hGetContents ends (evaluated)?
14:04:22 <luqui> i don't know about that
14:04:23 <mm_freak> an alternative would be some OOP-like scoping of names
14:04:27 <luqui> i like concrete types
14:04:37 <sinelaw> btw, doesn't collections already have something like what we're discussing?
14:04:39 <mm_freak> that would be great for record types
14:04:50 <Saizan> Polarina: i think so, not sure if you really need to though
14:05:10 <luqui> after working with them, i am disliking typeclasses more.  Functor, Applicative, Monad are nice.  So is Num (er, the idea).  But I think I prefer ML functors for general abstractions.
14:05:28 <sinelaw> collections package has Sequence
14:05:44 <sinelaw> and Indexed
14:05:53 <Twey> sinelaw, luqui: There are many obscure things in Data.Monoid
14:05:59 <Twey> It's an oft-overlooked library
14:06:00 <jmcarthur> i like type classes, but don't have much experience with ML functors
14:06:02 <sinelaw> Sequence has head, tail, concat, concatMap
14:06:33 <sinelaw> mm_freak, did you check that?
14:07:03 <sinelaw> luqui, what's the deal with ML functors? (i know nothing about that)
14:07:17 <sinelaw>  why do you like them more
14:07:18 <Veinor> where would a library for generating ascii art go?
14:07:25 <sinelaw> graphics?
14:07:52 <luqui> sinelaw, they essentially represent higher-order modules.
14:08:40 <Saizan> typeclasses and ML functors have actually quite different use cases, even if you can make them overlap
14:08:50 <luqui> sinelaw, it is direct obvious how to abstract something in terms of them, just like with functions:  make the thing you want to abstract over a parameter
14:08:54 <Saizan> for abstraction functors are indeed more appropriate
14:09:09 <mm_freak> sinelaw: it needs to be something in Data.List or Prelude
14:09:16 <luqui> Saizan, i think that's about right.  maybe I just miss them more because I have typeclasses :-)
14:09:22 <mm_freak> otherwise it solves only half of the problem
14:09:30 <Veinor> well, specifically one that generates art based on functions; so, like, drawASCII :: (Float -> Float) -> Range -> ASCII
14:09:38 <Veinor> where type ASCII = String
14:09:45 <luqui> Saizan, but then how would you describe the "purpose" of typeclasses
14:09:55 <Saizan> luqui: overloading
14:10:12 <Saizan> luqui: controlled/sane overloading, actually :)
14:10:22 <luqui> Saizan, hmm... yeah i buy it :-)
14:10:33 <jmcarthur> polymorphic constraints
14:10:38 <luqui> we seem to have a culture where overloading as in C++ is discouraged
14:10:44 <luqui> we like our overloads to mean something
14:10:59 <luqui> so it's hard to draw a parallel
14:11:49 <sinelaw> luqui, thinking more about that Any thing, wouldn't a Maybe with the opposite monoid meaning be more appropriate? (Nothing <> Just x = Just x, commutatively?)
14:12:16 <Twey> Like Last?
14:12:35 <luqui> sinelaw, what do you propose as the type for circle?
14:13:10 <luqui> btw images are left-biased.  over `mappend` under
14:13:25 <sinelaw> oh sure. i meant the nothing vs. just case
14:13:38 <luqui> sinelaw, i don't follow
14:13:51 <Zao> Is Perl part of the msys environment recommended for GHC builds or is it something I've added myself?
14:14:49 <pikhq> Perl's needed if you want to compile via C.
14:14:55 <Zao> I've got to run some code at cabal configure/build time to generate some files, will Perl suffice or should I aim to do it in Haskell to not have to depend on msys?
14:14:56 <pikhq> (the munger is in Perl)
14:15:34 <dons> Zao: you can use any ./configure script you like.
14:15:48 <dons> Zao: and cabal configure with Build-type: Configure will run that script
14:15:49 <Zao> I'm not particularly interested in GHC itself, it's more about what I can assume people building my package through cabal has.
14:16:09 <luqui> Zao, but everybody's got perl :-P.  except windows.  screw 'em.
14:16:18 <Zao> Depending on Perl is probably out then, as that would exclude anyone that doesn't have the msys setup.
14:17:01 <Zao> dons: I can't see how that would work much at all outside a msys world.
14:17:18 <Saizan> Zao: it doesn't
14:17:19 <Zao> Could I run stuff from my Setup.hs perhaps?
14:17:21 <sinelaw> luqui, like the type 'First a'
14:17:27 <Saizan> in fact, configure scripts are discouraged
14:17:29 <sinelaw> [[ circle :: Image a ]]  = R2 -> First a
14:17:37 <Saizan> and yes, you can put hooks into Setup.hs
14:17:48 <sinelaw> ...oops, wait
14:17:51 <sinelaw> [[ Image a ]]  = R2 -> First a
14:17:56 <Zao> In an optimal world, an user should be able to cabal install things.
14:18:09 <Zao> Time to dig into Cabal docs then.
14:18:21 <sinelaw> and....circle :: Image () ?
14:18:28 <Saizan> Zao: "cabal install" runs the Setup.hs script if you use build-type: Custom
14:18:40 <Polarina> if I pattern match ("HELLO":xs) and ("WORLD":xs) -- would Haskell ever evaluate the rest of the matching string further than the first 5 characters?
14:19:25 <Saizan> Polarina: is xs :: [String] ?
14:19:57 <Polarina> Saizan, ('H':'E':'L':'L':'O':xs) then.
14:20:10 <voker57> no
14:20:18 <Polarina> Cool. :D
14:20:46 <Saizan> well, it depends
14:21:24 <Saizan> an implementation is free to evaluate things as it likes if it can determine that doesn't change the termination
14:21:48 <voker57> > case ['h':undefined] of ['h':xs] -> print 1
14:21:49 <Polarina> Saizan, but it's I/O... :(
14:21:49 <lambdabot>   <IO ()>
14:21:59 <voker57> > case ['h':undefined] of ['h':xs] -> 1
14:22:00 <lambdabot>   1
14:22:10 <Polarina> voker57, :D
14:22:16 <Gracenotes> @type ['h':undefined]
14:22:17 <lambdabot> [[Char]]
14:22:26 <Gracenotes> @type ('h':undefined)
14:22:27 <lambdabot> [Char]
14:22:40 <Polarina> > case ['h':undefined] of ['h':'e':xs] -> 1
14:22:41 <Saizan> Polarina: it's a String :P
14:22:41 <lambdabot>   * Exception: Prelude.undefined
14:22:43 <Polarina> :P
14:22:50 <voker57> eh
14:22:54 <Polarina> Saizan, IO String.
14:23:01 <voker57> > case ('h':undefined) of ('h':xs) -> 1
14:23:02 <lambdabot>   1
14:23:11 <Polarina> voker57, I know, I was just testing.
14:23:15 <Saizan> Polarina: by the time you pattern match on it, it's just String
14:23:33 <Polarina> Saizan, but it has to do a I/O read when it pattern matches.
14:23:34 <Zao> > let (a:b:c:d:e:xs) = "HELLO" ++ undefined in (a,b,c,d,e)
14:23:35 <lambdabot>   ('H','E','L','L','O')
14:23:36 <Zao> > let (a:b:c:d:e:f:xs) = "HELLO" ++ undefined in (a,b,c,d,e)
14:23:36 <voker57> that was related to Gracenote's correction
14:23:38 <lambdabot>   (* Exception: Prelude.undefined
14:23:38 <sinelaw> luqui, that way we can rid the boilerplate: fmap (\(Any b) -> if b then Just text else Nothing)
14:23:44 <Gracenotes> I like saying, there's no such thing as a free type variable
14:23:46 <Polarina> Saizan, if it evaluates more, more I/O.
14:23:57 * gwern is astonied by http://en.wikipedia.org/wiki/Black_Perl
14:24:07 <Gracenotes> everything gets filled in eventually
14:24:12 <Saizan> Polarina: yeah, i hope it doesn't ignore that :)
14:24:27 <gwern> @quote not.*free
14:24:27 <lambdabot> OlinShivers says: "I am not a Church numeral; I am a free variable!"
14:24:50 <Saizan> e.g. it's not like GHC tries too much to make uses of unsafePerformIO safe
14:25:13 <Saizan> it still optimizes them as if they were pure code
14:25:32 <Saizan> Polarina: however it'll probably won't use eager evaluation for String's
14:25:36 <Polarina> What's unsafePerformIO?
14:25:46 <Polarina> Saizan, what do you mean with "eager"?
14:25:48 <Gracenotes> unsafe. it performs IO.
14:25:49 <c_wraith> Polarina: IO a -> a
14:25:53 <Saizan> unsafePerformIO :: IO a -> a
14:25:56 <c_wraith> What else do you need to know about it?
14:26:05 <Polarina> Saizan, o.O
14:26:22 <Polarina> That's very, very unsafe...
14:26:24 <c_wraith> If you use it, you'd better be damn sure you know what you're doing. :)
14:26:26 <Saizan> yeah
14:26:44 * Zao coerces Polarina to a CLDouble.
14:26:51 <Zao> unsafePerformIO told me to!
14:26:56 <Polarina> CLDouble?
14:26:59 <Saizan> and hGetContents is using unsafeInterleaveIO, which is basically "return . unsafePerformIO"
14:27:30 <Gracenotes> lazy IO is very suspect.
14:27:32 <c_wraith> unsafePerformIO was originally added to support FFI functions that are pure, while the FFI gives only an IO interface otherwise.
14:27:41 <Zao> Polarina: A datatype removed recently, which I believe was supposed to map to `long double' but in fact mapped to CDouble.
14:27:48 <Gracenotes> however, unsafePerformIO can be useful for pure things. FFI, like c_wraith is sayin
14:27:53 <Polarina> Zao, I see.
14:27:58 <Saizan> Polarina: eager evaluation is the one where you evaluate the arguments before passing them to functions
14:28:09 <Polarina> Saizan, how does one do that?
14:28:26 <Zao> Polarina: One programs in C++.
14:28:44 <Saizan> Polarina: well, the compiler sometimes uses it as an optimization
14:29:02 <Polarina> Saizan, but how would one force an eager evaluation?
14:29:33 <c_wraith> in haskell?  Using seq, or anything defined in terms of it
14:29:45 <mm_freak> i noticed that i don't need to use bang patterns/seq anymore
14:29:47 <Polarina> What's seq?
14:29:53 <mm_freak> GHC must have become much smarter over time
14:29:54 <c_wraith> :t seq
14:29:55 <lambdabot> forall a t. a -> t -> t
14:29:56 <pikhq> :t seq
14:29:58 <lambdabot> forall a t. a -> t -> t
14:29:58 <Zao> @src seq
14:29:59 <lambdabot> Source not found. It can only be attributed to human error.
14:30:02 <Gracenotes> seq does not necessarily force evaluation all the way. Just enough to put it in what we call weak-head normal form (WHNF)
14:30:06 * Zao has human error
14:30:16 <Polarina> Gracenotes, WHNF?
14:30:17 <mm_freak> (`using` rdeepseq)
14:30:24 <gwern> mm_freak: really, you don't? havey ou checked that with the seq genetic algorithm checker?
14:30:40 <gwern> maybe baseline ghc has just gotten good enough you no longer feel motivated to add seqs
14:30:42 <Polarina> Does anyone have an example usage of seq?
14:30:52 <sshc> mm_freak: perhaps you could ticket it and hope for inclusion in the next standard, 2011?
14:31:01 <Saizan> ?src foldl'
14:31:02 <lambdabot> foldl' f a []     = a
14:31:02 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
14:31:07 <Gracenotes> Polarina: if it has a data type, what seq does to the first argument is evaluate it until it can be pattern-matched - i.e., determine exactly what form it has
14:31:32 <mm_freak> Polarina: WHNF means:  evaluating one layer of data constructors
14:31:36 <sshc> :t rnf
14:31:37 <lambdabot> forall a. (NFData a) => a -> Done
14:31:58 <mm_freak> Polarina: the head element of lists, for example
14:31:59 <Polarina> Saizan, thanks.
14:32:13 <Polarina> mm_freak, what do you mean with only "one layer"?
14:32:13 <Philonous> WHat is the preferred method to generate C bindings? c2hs? bindings-DSL? hsc2hs?
14:32:52 <mm_freak> Polarina: data [a] = [] | a:[a]
14:33:01 <Polarina> mm_freak, o.O
14:33:07 <mm_freak> so WHNF evaluates xs0 to x1:xs1
14:33:07 <Gracenotes> there is more important stuff in Haskell than how exactly laziness works
14:33:13 <Polarina> mm_freak, but if one would like to evaluate everything?
14:33:17 <mm_freak> the next step would be x1:(x2:xs2)
14:33:29 <Polarina> mm_freak, is that a valid pattern?
14:33:33 <mm_freak> normal form would be the entire structure (as opposed to WHNF)
14:33:41 <Gracenotes> Polarina: one way to evaluate everything in a list would be to print it, for instance
14:33:53 <copumpkin> not necessarily
14:33:58 <copumpkin> depends on the show instance of the elements of the list
14:34:01 <copumpkin> best go with rnf :P
14:34:06 * Polarina wonders if  return (x)  would evaluate x.
14:34:08 <Polarina> Would it?
14:34:13 <Saizan> no
14:34:16 <Polarina> :(
14:34:19 <Philonous> Depends on the monad
14:34:35 <Saizan> return is required to be lazy by the monad laws
14:34:43 <mm_freak> Polarina: to evaluate everything, either use the entire structure
14:34:44 <Philonous> Oh
14:34:47 <Gracenotes> Polarina: the main thing you need to know is that you can program Haskell like most other functional languages, and it just evaluates the things it needs to
14:34:55 <copumpkin> yeah, there was a bug in parsec until recently that violated that
14:35:01 <mm_freak> or import Control.Parallel.Strategies and use:  myStructure `using` rdeepseq
14:35:02 <Polarina> Gracenotes, I know. :-)
14:35:06 <Saizan> well, if you take "return x >>= f = f x" literally at least
14:35:07 <Gracenotes> >_>
14:35:13 <mm_freak> of course you need to combine that with seq =)
14:35:28 <mm_freak> something `using` rdeepseq `seq` print somethingElse
14:35:29 <Polarina> What's a >>=? What does it do?
14:35:29 <Gracenotes> copumpkin: afaik, the Show instances for mostly everything in Prelude evaluates it
14:35:42 <mm_freak> evaluates 'something' to normal form before printing somethingElse
14:35:45 <copumpkin> Gracenotes: sure, but it isn't guaranteed to
14:35:55 <gwern> ?src (>>=)
14:35:55 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
14:35:59 <Saizan> Polarina: it's the other combinator from Monad
14:36:00 <gwern> @hoogle (>>=)
14:36:00 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
14:36:00 <lambdabot> Control.Monad (>>=) :: Monad m => m a -> (a -> m b) -> m b
14:36:00 <lambdabot> Control.Monad.Instances (>>=) :: Monad m => m a -> (a -> m b) -> m b
14:36:04 <Saizan> ?type (>>=)
14:36:06 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
14:36:10 <gwern> hm. I wonder whher djinn can write that
14:36:14 <Gracenotes> copumpkin: hence the "for instance"
14:36:15 <Polarina> And how would one use >>=?
14:36:23 <mm_freak> Polarina: use probably use >>= all the time
14:36:24 <c_wraith> gwern: given a specific enough type signature, it can
14:36:30 <Saizan> Polarina: do you know how to use do-notation?
14:36:30 <gwern> @djinn m a -> (a -> m b) -> m b
14:36:30 <lambdabot> -- f cannot be realized.
14:36:33 <mm_freak> do x <- c; f x = c >>= f
14:36:35 <Polarina> Saizan, yes.
14:36:40 <c_wraith> gwern: djinn can do >>= for State, for instance
14:36:40 <gwern> c_wraith: no, djinn is broken beyond specificity
14:36:46 <gwern> or so I hear
14:36:50 <gwern> can't do lists or something
14:36:56 <Saizan> gwern: it's a typeclass method, what's the point of asking an implementation for it?
14:37:02 <copumpkin> Gracenotes: not sure for instance means "this is an example, but it might fail" :P
14:37:14 <Chaze> Polarina: in the most simple case: return "Hello World" >>= putStrLn
14:37:28 <gwern> Saizan: mm. couldn't it be written in terms of the others?
14:37:35 <Gracenotes> copumpkin: "in some cases". let's all turn down the pointless pedantry now >_>
14:37:36 <Saizan> Polarina: well, "do x <- m: ..." is transalted to "m >>= \x -> ..."
14:37:37 <mm_freak> getLine >>= \name -> putStrLn ("Hello " ++ name)
14:37:52 <mm_freak> do name <- getLine; putStrLn ("Hello " ++ name)
14:37:53 * copumpkin turns up the pedantry knob
14:37:54 <Polarina> Ah, I see. :)
14:37:55 <c_wraith> @djinn (a -> (s, a)) -> (a -> (b -> (s, b))) -> (b -> (s, b))
14:37:55 <mm_freak> same thing
14:37:56 <lambdabot> -- f cannot be realized.
14:38:02 <Gracenotes> copumpkin: up to 11??
14:38:07 <gwern> c_wraith: see? djinn is not particularly powerful
14:38:09 <copumpkin> Gracenotes: OVER 9000!!!
14:38:16 <c_wraith> gwern, it can.  I just got the signature wrong
14:38:26 <Saizan> @djinn (s -> (s, a)) -> (a -> (s -> (s, b))) -> (s -> (s, b))
14:38:27 <lambdabot> f a b c =
14:38:27 <lambdabot>     case a c of
14:38:27 <lambdabot>     (d, e) -> b e d
14:38:37 <c_wraith> right, I totally screwed up what state is. :)
14:38:40 <mm_freak> Chaze: don't you EVER even consider using 'return something >>= f' as an example for >>= ;)
14:38:58 <Chaze> mm_freak: it helped me understand it
14:39:03 <sshc> Constraint is no smaller than the instance head in the constraint
14:39:09 <sshc> what does that mean?
14:39:28 <copumpkin> sshc: you're trying to do something evil
14:39:31 <mm_freak> Chaze: it was just a joke, but it could be misleading sometimes
14:39:38 <sshc> copumpkin: I intend to do good
14:39:42 <sshc> copumpkin: what does that mean?
14:39:57 <copumpkin> sshc: it means you're entering the realm of undecidable instances
14:40:06 <mm_freak> it's about the same problem as this:  do x <- something; return x
14:40:17 <soupdragon> gwern???
14:40:19 <sshc> copumpkin: how can that happen?
14:40:23 <mm_freak> and yes, a lot of people write it that way =)
14:40:28 <soupdragon> djinn is best
14:40:29 <gwern> soupdragon: !!!
14:40:41 <temoto> [imaginable language] What can you say about this?  f = x + 1; g x = f; > g 1 = 2
14:40:42 <sshc> copumpkin: instance (Vec v) => Num v where etc.
14:40:50 <copumpkin> sshc: that's it
14:40:51 <mm_freak> @djinn Either e a -> Maybe a
14:40:51 <lambdabot> f a =
14:40:52 <lambdabot>     case a of
14:40:52 <lambdabot>     Left _ -> Nothing
14:40:52 <lambdabot>     Right b -> Just b
14:40:55 <Saizan> sshc: the size there is basically the height of the tree of type constructors
14:41:09 <copumpkin> sshc: don't do that, basically :P
14:41:09 <Saizan> sshc: size (Vec v) = 1 + size v
14:41:24 <sshc> copumpkin: why not?
14:41:34 <Saizan> sshc: when you have instances like this, typeclass resolution might not terminate
14:41:37 <sshc> can't GHC determine whcih types are instances are Vec and only apply those?
14:41:38 <copumpkin> sshc: you're not reducing the complexity of the constraint in any way with that
14:41:39 <Philonous> sshc: Consider instance Foo x => Bar x, instance Bar x => Foo x. An inifnite loop.
14:42:04 <Philonous> sshc: To make sure this doesn't happen ghc asks you to make the type on the left "smaller" than on the right hand side, so termination is ensured
14:42:16 <sshc> GHC can still handle this
14:42:27 <sshc> -XUndecidableInstances
14:42:36 <copumpkin> sshc: yeah, note the word Undecidable in there
14:42:39 <copumpkin> it should make you tremble
14:42:40 <Saizan> Undecidable means exactly that
14:42:42 <Philonous> Of course, you can tell it to go **** itself and just comply to your orders, yes
14:42:43 <pokoko222> can someone give me a concrete example of topological space please? anything related you have done in haskell?
14:42:44 <Saizan> "it might loop"
14:43:01 <copumpkin> sshc: if you don't care about your compiler terminating, go ahead
14:43:25 <copumpkin> of course, in this case you're probably safe, but who knows what may happen in future :P GHC makes no guarantees once you turn that on
14:43:31 <kmc> pokoko222, http://en.wikipedia.org/wiki/Topological_space#Examples_of_topological_spaces
14:44:05 <sshc> copumpkin: is my only alternative to make the exactly same instance declaration for every type that's an instance of Vec?
14:44:09 <temoto> sshc, i'll tell you a secret. In the future we are all dead.
14:44:10 <copumpkin> sshc: yeah
14:44:27 <temoto> boy, what a spoil
14:44:29 <copumpkin> or you could avoid using a Vec typecalss
14:44:42 <sshc> temoto: that's irrelevent
14:45:11 * Saizan is not really scared of UndecidableInstances
14:45:21 <copumpkin> BE SCARED DAMMIT
14:45:22 <sshc> what's wrong with it
14:45:25 <sshc> ?
14:45:40 <Saizan> the worst thing is that the instance above overlaps with everything.
14:45:57 <temoto> sshc: i was kinda joking about possible-unsafety-in-the-future.
14:46:31 <kmc> is it such a big deal if your compiler diverges
14:47:06 <pokoko222> kmc went through the wiki first, i did not understand anything that is why i asked here
14:47:14 <Saizan> kmc: only if it starts diverging even if your code is perfectly valid :)
14:47:55 <kmc> pokoko222, perhaps you should read some more elementary wiki articles then
14:48:00 <kmc> we would explain the same concepts in the same terms
14:48:21 <Saizan> does the wiki article mention scott domains?
14:49:56 <galdor>  hi, is that normal that cabal-install HEAD requires cabal 1.9.* ?
14:49:57 <trzkril> is there some elegant or maybe standard way to pretty-print file sizes using binary units?
14:50:07 <Saizan> pokoko222: this is a bit tangential but it might help http://blog.sigfpe.com/2008/02/how-many-functions-are-there-from-to.html
14:50:08 <galdor> ghc 6.12.1 ships with cabal 1.8
14:50:10 <trzkril> so far i have come up with that: http://paste.pocoo.org/show/172018/
14:50:25 <Saizan> galdor: yeah, you need Cabal HEAD too
14:51:02 <temoto> Do you need legs?
14:51:10 <galdor> Saizan: installing it from HEAD isn't gonna break the cabal 1.8 shipped with ghc ?
14:51:26 <Saizan> galdor: no, you'll have both versions installed
14:51:32 <galdor> oh excellent
14:51:34 <galdor> thank you
14:52:03 <galdor> I at last get a working ghc 6.12.1 on OpenBSD, so if I get cabal-install too, it's gonna be fun
14:52:09 <EvanCarroll> win 2
14:52:17 <Saizan> lose 3
14:57:40 <jmcarthur> freenooooooooooooode!
14:58:41 <Saizan> damn, no lambdabot, we lost this netsplit
14:59:23 <jmcarthur> obviously this is the time to say rude things that won't be logged
15:00:01 <Saizan> well, the logger is here, actually
15:00:06 <Saizan> clog
15:00:39 --- mode: jordan.freenode.net set +o Lemmih
15:05:07 --- mode: jordan.freenode.net set +o ChanServ
15:09:21 <Polarina> How do I create a PortNumber for connectTo?
15:09:48 <Twey> Polarina: There's a fromIntegral involved
15:10:03 <Polarina> Twey, can you give an example?
15:10:12 <aavogt> if it needs fromIntegral, then you can write a litteral portNumber
15:10:24 <Polarina> ...
15:10:25 <aavogt> 123 :: PortNumber -- if it has a Num instance
15:10:34 <Polarina> Oh.
15:10:37 <aavogt> fromIntegral is implicit here
15:10:50 <Polarina> But I also need it to declare the connection AF_INET6.
15:10:54 <aavogt> but I dunno which network library you are using here
15:11:10 <tommd> @hackage network -- I assume
15:11:29 <Polarina> aavogt, Network.
15:11:40 <Twey> Polarina: ‚ÄòPortNumber 55‚Äô for example
15:11:53 <Polarina> But for AF_INET6?
15:12:08 <Alpounet> lambdabot didn't come back.
15:12:57 <Twey> Polarina: I don't believe there's a difference
15:13:02 <Twey> IP doesn't handle port numbers
15:13:03 <Polarina> Really?
15:13:16 <Polarina> But I need to connect via IPv6.
15:13:32 <Twey> But it doesn't change how you deal with ports.
15:13:42 <p_l> Polarina: both v4 and v6 use 16bit port number
15:13:46 <kmc> Polarina, you're using Network, not Network.Socket ?
15:13:52 <Polarina> kmc, yes.
15:13:59 <kmc> port numbers are a concept in TCP or UDP, not IP
15:14:34 <Polarina> ...
15:14:35 <Polarina> Ok.
15:14:37 <Polarina> I know that.
15:14:46 <Polarina> But how do I connect via IPv6 then?
15:14:51 <Polarina> Or an UNIX socket?
15:14:52 <kmc> Polarina, then it's part of the PortID data
15:15:04 <kmc> data PortID = Service String | PortNumber PortNumber | UnixSocket String
15:15:05 <Polarina> connectTo doesn't take a PortID.
15:15:18 <kmc> yes it does, in http://www.haskell.org/ghc/docs/6.10-latest/html/libraries/network/Network.html
15:15:24 <Polarina> Oh.
15:15:27 <Polarina> I'm blind. :(
15:16:18 <kmc> the src to that module is full of references to IPv6
15:16:36 <kmc> i would guess you just use an IPv6 address as the HostName to connectTo
15:16:46 <kmc> or a DNS name that has an AAAA record
15:17:08 <SamB_XP> @hoogle HostName
15:17:40 <mm_freak> yes, using an IPv6 :: HostName address works well
15:17:44 <mm_freak> i've used it a number of times
15:17:51 <mreh_> it seems working with trees that hold values on the leaves is rather difficult, there is no way of representing a null leaf
15:18:03 <kmc> mreh_, in the context of some library, or in general?
15:18:08 <SamB_XP> mreh_: a what now ?
15:18:13 <Polarina> mm_freak, IPv6 :: HostName?
15:18:14 <SamB_XP> it's either there or it isn't!
15:18:17 <SamB_XP> make up your mind!
15:18:20 <mm_freak> unfortunately connectTo doesn't separate the DNS and connection steps, so you can't control whether to prefer IPv6 or IPv4
15:18:26 <kmc> mreh_, why not use a Maybe type for the leaf type
15:18:38 <mreh_> kmc, well what I'm doing is removing elements from a complete tree, the elements exist on a leaf
15:18:39 <SamB_XP> @hoogle connectTo
15:18:49 <mreh_> kmc: it's a polymorphic type, I dont see how that would work
15:18:59 <mm_freak> Polarina: connectTo :: HostName -> PortID -> IO Handle
15:19:02 <kmc> mreh_, can you hpaste the defn of the tree type you're using?
15:19:08 <mm_freak> but type HostName = String
15:20:04 <mreh_> Tree a = Tree Integer (Maybe (Tree a)) (Maybe (Tree a)) -- like so?
15:20:15 <mreh_> the integer is for element retrieval
15:20:15 <Veinor> I don't think I like haskell-mode indenting the entirety of a module :/
15:20:21 <kmc> that's sort of ugly
15:20:37 <mreh_> kmc: that's what you proposed though
15:20:39 <jmcarthur> mine doesn't do that...
15:20:47 <sshc> In my experience: C is a matter of hunting bugs at run-time.  Haskell is a matter of fixing bugs at compile time.
15:20:54 <Veinor> mine does.
15:21:02 <kmc> mreh_, where are the values of type 'a'?
15:21:06 <kmc> in that type, there are none
15:21:10 <Veinor> at least for some stuff.
15:21:24 <mreh_> sshc: as I've become more experience I found that I'm hunting more programmer error type bugs
15:21:31 <kmc> mreh_, i was thinking your tree was something like:  data Tree a = Leaf a | Node (Tree a) (Tree a)
15:21:43 <kmc> then, you can choose a Maybe type for ´aª
15:21:44 <mreh_> kmc: that's what my tree *is* like
15:21:45 <theorbtwo> sshc: I agree with your substance, but I think your wording is rather unfair.
15:21:51 <kmc> i.e., Tree (Maybe Char)
15:21:51 <mreh_> ooh
15:21:58 <kmc> each leaf will have Nothing or Just x, for x a char
15:22:25 <Veinor> where's a table of all the typeclasses for Haskell's numeric types?
15:22:41 <mreh_> kmc: okay, I see what you mean, I posed my question incorrectly though
15:23:19 <mreh_> If you want to define a function to remove an element from a tree say, you have to return the modified sub-tree at every node traversal
15:23:33 <mreh_> when you get to the leaf and you want to remove *that* element, what can you return?!
15:23:53 <mreh_> it makes defining the function a lengthy affair, possible, just loooong
15:24:37 <galdor> please, is that normal that ghc 6.12.1 can't recompile itself ?
15:24:55 <galdor> I get a ghc-cabal: ghc-pkg: error while parsing
15:24:58 <Veinor> blah. I'm brainfarting right now, I want to declare a type using record syntax like data Range a = (Enum a) => Range { xrange :: (a,a); yrange :: (a,a) }
15:25:01 <Veinor> what am I doing wrong?
15:26:08 <Polarina> What's FlowID and ScopeID in Network.Socket.SockAddrInet6?
15:26:45 <tommd> Some as the flowID field IPv6 I would assume.
15:27:21 <Polarina> What's that?
15:27:36 <kmc> Polarina, IPv6 allows you to label packets as belonging to certain "flows"
15:27:46 <Polarina> What's a "flow"?
15:27:50 <kmc> an IPv6 concept
15:27:57 <Polarina> Could you explain it?
15:27:59 <tommd> http://www.ietf.org/rfc/rfc1981.txt?number=1981
15:28:05 <kmc> no, because i have no idea how it works
15:28:14 <Polarina> :(
15:28:15 <kmc> perhaps wikipedia or the relevant RFC knows more
15:28:21 <kmc> it's not a Haskell concept
15:28:32 <tommd> Polarina: See the rfc, Google, or Wikipedia.
15:29:21 <kmc> Veinor, typeclass constraints on data ctors in H98 types are not too useful
15:29:41 <kmc> however anyway the error is that you use ´;ª instead of ´,ª
15:29:56 <kmc> ah sorry
15:30:05 <kmc> didn't notice it's an existential type
15:30:18 <kmc> the constraint makes sense then
15:31:59 <Polarina> But what about ScopeID?
15:32:55 <kmc> i think the same strategy will work there too
15:34:06 <Veinor> kmc: hmmmm. I'm not actually sure what I want.
15:34:50 <kmc> IPv6 is hard
15:35:12 <Veinor> basically, I'm doing an ASCII function plotter. the plotter is going to have signature Plottable a -> Range a -> String
15:36:08 <Veinor> where Plottable a = a -> a -> Float, Range a = Range (a,a) (a,a) or something.
15:36:09 <kmc> Veinor, perhaps you want ´data (Enum a) => Range a = Range { xrange :: (a,a), yrange :: (a,a) }ª
15:36:15 <Veinor> ahhhhhhh.
15:36:21 <Veinor> yes, that's what I want.
15:37:01 <HaskellLove> any category guy here that knows topology too and wants to talk about it in pm?
15:37:18 <Veinor> also, Graphics.Ascii.Asciigraphs.Bitmap is kind of a long name
15:37:19 <Veinor> :/
15:38:10 <Twey> Thankfully, you only have to type it once
15:38:26 <HaskellLove> why do people cry about long names. Hello, the world is complex... you would rather have names like R23g.s.23.sd ?
15:38:48 <kmc> Veinor, maybe not, it seems it does not make the (Enum a) constraint available when you pattern match a value of type (Range a)
15:38:54 <Twey> It might be wise to aggregate an API in Graphics.Ascii.Asciigraphs so people only have to import that
15:38:55 <kmc> maybe you want the GADT
15:39:04 <kmc> data Range a where { Range :: (Enum a) => (a,a) -> (a,a) -> Range a }
15:39:09 <Veinor> Twey: yeah, that's what I'm going to do.
15:39:10 <Twey> HaskellLove: I get annoyed with long names if I have to type them over and over again.
15:39:17 <kmc> (you can get the field labels on that too, but it's uglier)
15:39:27 <Twey> Once in an import declaration, though, is fine.
15:39:32 <HaskellLove> Twey there is this cool thing, it is called Copy and Paste
15:39:50 <Twey> There is this cool thing: it's called readability
15:40:06 <Twey> When identifiers take up whole lines, that goes right out of the window :√æ
15:40:14 <Zao> Overly long identifiers, much like overly short ones, are suboptimal.
15:40:18 <Twey> *nod*
15:40:29 <luqui> I have an example that comes with graphics-drawingcombinators that relies on SDL.  I would like to build this example if SDL is available, but not prevent building the library if it is not.  is there a way to do that with cabal?
15:40:31 <Zao> I would say AsciiGraphs, by the way.
15:40:58 <tensorpudding> long names are more readable with camel case, though some people disagree
15:41:01 <Polarina>     Could not find module `Network':
15:41:04 <Saizan> luqui: you can have a Flag in your .cabal
15:41:05 <Polarina> Am I missing something?
15:41:28 <Veinor> kmc: I was able to use the Enum constraint.
15:41:34 <Saizan> Polarina: the network package i'd think
15:41:37 <Veinor> f (Range (x,_) _) = succ x
15:41:39 <Veinor> worked fine for me.
15:41:44 <kmc> Veinor, okay.  maybe my example was broken
15:41:51 <Polarina> Saizan, the documentation says it's a core library.
15:42:06 <Saizan> Polarina: did you get your ghc from apt-get?
15:42:23 <Polarina> Saizan, yes.
15:42:37 <Saizan> Polarina: you need libghc6-network-dev then
15:42:39 <luqui> Saizan, where can I read about that?
15:42:42 <Polarina> o.O
15:43:07 <Veinor> gah. why can't I use the home and delete keys in ghci :/
15:43:25 <Polarina> Saizan, that library is defined in the haskell standard, isn't it?
15:43:25 <kmc> is debian ghc on 6.12 already?
15:43:33 <Twey> I don't know.  I can.
15:43:40 <Twey> kmc: You're kidding, right?
15:43:41 <Polarina> kmc, Debian Squeeze is still 6.8.
15:43:41 <Saizan> luqui: http://www.haskell.org/cabal/release/cabal-latest/doc/users-guide/authors.html#configurations
15:43:43 <kmc> haha
15:43:45 <Veinor> I'm using 6.10.4
15:43:50 <kmc> then why doesn't a package like 'network' come with ghc?
15:44:03 <luqui> Saizan, thans
15:44:04 <luqui> thanks
15:44:10 <chrisdone> Veinor: do you have one of the readline or editline versions?
15:44:23 <Saizan> on debian the ghc install has always been fragmented like that
15:44:26 <chrisdone> Veinor: alternatively, try rlwrap gchi
15:44:29 <Veinor> I'm just using the one in the Ubuntu repositories, so...
15:44:31 <SamB_XP> kmc: I guess they split up the package at build time ?
15:45:08 <Saizan> Polarina: actually no, network is not in any standard, but it's in the Haskell Platform
15:45:16 <Polarina> :'(
15:45:24 <sshc> theorbtwo: my substance?
15:45:25 <Saizan> i.e. it's fine to use
15:45:29 <sshc> theorbtwo: which?
15:45:30 <Veinor> also, rlwrap ghci doesn't work
15:45:35 <Saizan> it used to be shipped with ghc
15:45:38 <sshc> theorbtwo: and how is my wording unfair?
15:45:42 <Veinor> chrisdone: how do I get one of these readline/editline versions?
15:45:44 <sshc> theorbtwo: I would like to know my mistake
15:46:18 <chrisdone> Veinor: not sure. here are some tips, fwiw: http://www.haskell.org/haskellwiki/GHC/GHCi#Readline.2Feditline
15:47:09 <theorbtwo> Why are you "hunting" C bugs, but "fixing" haskell bugs?
15:47:19 <Veinor> hm.
15:47:27 <Veinor> it doesn't have to do with that, since I can use the up arrow just fine
15:47:37 <Veinor> I just can't use Home or delete. odd.
15:48:08 <HaskellLove> a concrete example of initial and terminal object from CT applied in Haskell please?
15:48:20 <Polarina> Why am I getting this error? http://codepad.org/ia1SRN8A
15:48:27 <sshc> theorbtwo: there are a LOT of really hard to find bugs in C applications
15:48:36 <sshc> theorbtwo: memory corruption is aweful
15:48:49 <sshc> minus the e
15:49:11 <sshc> theorbtwo: not all of them are hard to find, of course
15:49:41 <chrisdone> Veinor: what about C-d and C-a?
15:50:39 <thaostra> so sshc, which language do you like better, c or haskell?
15:50:46 <theorbtwo> Hm.  I can buy that.
15:50:56 <kmc> C is better for some things
15:50:56 <Veinor> C-d works; presumably, C-a would work if I wasn't running in screen.
15:51:01 <kmc> it's more domain-specific
15:51:08 <sshc> thaostra: which do I *like* better*  Haskell, by FAR
15:51:09 <Veinor> but still. :P
15:51:24 <kmc> run of the mill application code should *not* be written in C
15:51:26 <sshc> s/better\*/better?/
15:51:50 <thaostra> may I ask why haskell fits your preference?
15:52:43 <DigitalKiwi> sshc uses real regex on irc, lmao
15:53:16 <sshc> DigitalKiwi: the same can be said for real English!
15:53:29 <sshc> thaostra: yes, but I can't answer that now, as I'm going to be away from my IRC client for a while
15:53:47 <sshc> thaostra: you can ask kmc why he prefers Haskell, or just ask anybody else
15:54:17 <thaostra> ok, why is haskell good?
15:54:32 <kmc> thaostra, how much do you know about Haskell
15:54:40 <thaostra> i mean, there are some appealing features like being purely functional
15:54:56 <thaostra> a bit, i am more familiar with C
15:55:46 <kmc> thaostra, Haskell's strong static type system pushes a lot of errors to compile time
15:55:52 <sshc> thaostra: shorter, more reliable, more stable, more maintanable code
15:55:53 <theorbtwo> Purely functional isn't really a feature.  It's a means to an end.
15:56:27 <thaostra> uh huh
15:56:39 <mm_freak> thaostra: i think one of the most important features is expressiveness
15:56:40 <kmc> Haskell code quite often works correctly the first time you get it to compile
15:56:50 <sshc> thaostra: The beginning of Real World Haskell explains a good bit of Haskell's goodness, but I would whole-heartedly recommend reading http://learnyouahaskell.com/chapters/ first
15:56:56 <glguy> Haskell's parametric polymorphism knocks out a lot of the cases where code duplication or void* and casting is necessary in C
15:57:01 <DigitalKiwi> sshc: Ich spreche zwei Sprachen: Englisch und ein bisschen Deutsch ;D
15:57:07 <mm_freak> thaostra: most haskell programms will take a very small amount of development time compared to C
15:57:28 <sshc> correct
15:57:32 <mm_freak> note that you can write C in haskell just as well‚Ä¶  you just, uhm, don't =)
15:57:41 <sshc> mm_freak: sure you do
15:57:43 <kmc> and features like type inference reduce the programmer burden of static types
15:57:48 <thaostra> ok, but how fast small are compiled haskell programs compared to c programs
15:57:51 <mm_freak> DigitalKiwi: Ein Bisschen ;)
15:57:56 <DigitalKiwi> doesn't ghc have a way to turn haskell into c and then compile it?
15:57:57 <kmc> thaostra, you mean when compiled with GHC?
15:58:02 <thaostra> yes
15:58:08 <kmc> DigitalKiwi, sure.  the code is worse
15:58:15 <mm_freak> sshc: let's say that's not the usual way to do things
15:58:17 <mm_freak> not even in IO
15:58:20 <kmc> it's not like the GHC-output C code is anything like regular C code
15:58:31 <augur> does anyone know both Model Theory and some amount of formal semantics of natural language?
15:58:34 <sshc> thaostra: I know this doesn't answer your question, but it's fast enough for me
15:58:39 <kmc> thaostra, http://shootout.alioth.debian.org/
15:58:51 <mm_freak> thaostra: compared to C programs a haskell binary is much larger
15:58:54 <kmc> as for size, GHC binaries tend to be very big if they're statically linked to the Haskell runtime
15:59:06 <kmc> however starting in GHC 6.12.1 you can dynamically link Haskell libraries
15:59:07 <mm_freak> and you'll get about 50% of the raw performance most of the time, although that will fit most purposes
15:59:10 <sshc> thaostra: yes, one downside is that they are a bit larger
15:59:14 <DigitalKiwi> there was an article of this haskell->c->machine code that was about as fast as a C version
15:59:28 <kmc> thaostra, i find it's a lot of work to write fast Haskell code.  but i'd rather spend time making the code fast, than making it work at all
15:59:35 <Veinor> IT'S MACHINE CODE
16:00:00 <DigitalKiwi> http://donsbot.wordpress.com/2008/06/04/haskell-as-fast-as-c-working-at-a-high-altitude-for-low-level-performance/
16:00:01 <kmc> especially because most parts of most programs don't have to be fast
16:00:18 <syntaxglitch> Polarina, you can't compose those functions like that, the types aren't compatible
16:00:38 <Polarina> syntaxglitch, unsafePerformIO fixed things. :)
16:00:52 <syntaxglitch> I don't think that's really an ideal solution
16:01:11 <Polarina> It is not.
16:01:30 <mm_freak> unsafePerformIO to fix type problems?
16:01:53 <kmc> you can write unsafeCast with unsafePerformIO
16:01:57 <kmc> with some trickery
16:02:03 <glguy> unsafePerformIO is a great way to use global, polymorphic references to get yoru cast function
16:02:23 <soupdragon> lol
16:02:40 <augur> noone huh? :(
16:02:56 <mm_freak> kmc: that was not a question of whether it can be done, but whether Polarina actually does do it
16:02:58 <copumpkin> John Noone?
16:03:12 <thaostra> well kmc, thank you for your input
16:03:13 <kmc> anyway, the distaste for uPIO is not just empty moralizing.  it breaks basic assumptions that the compiler needs for its optimizations to be correct
16:03:18 <augur> copumpkin: noone knows both model theory and something about natural language semantics
16:03:28 <copumpkin> you should speak to him then :)
16:03:30 <kmc> thaostra, i think there are also good subjective reasons to learn Haskell
16:03:41 <augur> copumpkin: :P
16:03:42 <thaostra> i have been looking to learn languages like ruby, go and of course haskell
16:03:51 <glguy> :-X
16:03:51 <thaostra> perhaps
16:03:53 <kmc> it's fun, and it's very different from other languages
16:03:55 <augur> where noone is a negated existential quantifier ;P
16:04:14 <copumpkin> mmm, the armani, D&G, and herm√©s of programming
16:04:14 <Twey> thaostra: http://www.cowlark.com/2009-11-15-go/
16:04:20 --- mode: ChanServ set +o monochrom
16:04:27 <DigitalKiwi> dons: I like that artile btw, I think it was you who wrote it
16:04:42 --- mode: ChanServ set +o glguy
16:04:53 <mm_freak> thaostra: the experience of learning haskell is about the same as solving rubik's cube using the human thistlethwaite method =)
16:04:56 <DigitalKiwi> op war!
16:04:56 <dons> DigitalKiwi: which article?
16:05:04 <DigitalKiwi> 17:59
16:05:14 <dons> ah yes
16:05:15 --- mode: monochrom set -o monochrom
16:05:15 <DigitalKiwi> haskell as fast as c...
16:05:16 <dons> cheers.
16:05:16 <thaostra> haha
16:05:16 <kmc> rubik's cube is boring
16:05:31 <Axman6> urgh, not happy. connecting to freenode now gives me the IPv6 address by default, and i can't connect
16:05:34 <copumpkin> lots of ops
16:05:42 <DigitalKiwi> did you get ghc on arch working all smoothly again?
16:05:51 <mm_freak> kmc: it is, if you just apply some rules
16:06:00 <DigitalKiwi> glguy: hi
16:06:02 <xerox> 13WAAAN98 77CAAAPYY 94SAAANLT don't they look suspicious.
16:06:05 <glguy> Hello
16:06:07 <mm_freak> but it's exciting, if you _really_ solve it as in understanding it =)
16:06:09 <kmc> even if you figure out the rules yourself
16:06:10 <dons> DigitalKiwi: yeah, just finishing updating 1500 packages.
16:06:15 <syntaxglitch> Polarina, wouldn't "putStr =<< getGetContents $ PortNumber 6667" work?
16:06:17 <DigitalKiwi> 1500 D:
16:06:22 <syntaxglitch> er, hGetContents
16:06:23 <kmc> you are just factoring in one particular group
16:06:28 <Polarina> syntaxglitch, probably.
16:06:31 <xerox> haha one is a freenode staff memger.
16:06:32 <glguy> xerox: 13WAAAN98 is tomw, freenode op
16:06:33 <xerox> *member
16:06:37 <Polarina> @type (=<<)
16:06:58 <syntaxglitch> It's just >>= with the arguments flipped
16:06:59 <mm_freak> kmc: well, there is magiccube4d, which is going to be my next challenge =)
16:07:11 <Polarina> syntaxglitch, :)
16:07:11 <DigitalKiwi> glguy: surprised they didn't kline him
16:07:12 <syntaxglitch> nicely self-documenting (assuming you know what >>= does)
16:07:29 <kmc> @src (=<<)
16:07:46 <Veinor> blah. I think I'm going to wind up handwriting enumFromThenTo.
16:07:55 <tensorpudding> @botsnack
16:07:56 <DigitalKiwi> glguy: did you see the encylopedia dramatic article about the recent freenode+javascript exploit? it's hilarious (tigrmesh showed me it)
16:08:02 <mm_freak> since i use Control.Applicative a lot, i haven't found many uses for (=<<) anymore
16:08:24 <tensorpudding> hmm
16:08:36 <mm_freak> , ()
16:08:46 <mm_freak> bots are gone‚Ä¶
16:08:48 <tensorpudding> lambdabot is here, why isn't she responding
16:08:52 <kmc> @bot
16:09:53 <dons> glguy: is it possible to create a file like this for Fedora .hs packages, http://www.galois.com/~dons/cabalArchMap.txt  ...
16:09:58 <mm_freak> why don't we call her jennifer?
16:10:01 <dons> if so, hackage would then display the fedora name
16:10:11 <Veinor> whee, manually compiling ghci
16:10:14 <syntaxglitch> Polarina, you could also just bind the result of the hGetContents call instead of writing it on one line, using unsafePerformIO is really not what you want to do
16:10:32 <Polarina> Hmm.. probably a good idea.
16:10:42 <kmc> yes, don't use uPIO
16:11:09 <kmc> it's not idle moralizing, you really can break things badly
16:12:33 <Zao> If I want to generate some headers and abort the build if it failed, would the preBuild Cabal hook be the right place?
16:19:34 <Polarina> If I do a lot of similar pattern matches ('A':xs), ('B':xs), ('C':'D':xs), etc. -- will ghc optimize them to something quick, like a lookup table or something?
16:20:22 <dons> in some cases.
16:20:25 <Polarina> Some?
16:20:38 <dons> depends on the pattern type and complexity.
16:21:07 <dons> generally, you can assume pattern matching is as efficient as it can be.
16:21:15 <Polarina> dons, oh, cool.
16:21:22 <dons> maybe once every several years i have to hack around pattern matching.
16:21:30 <Polarina> Was afraid I would've had to use Map on a very long list of patterns.
16:21:37 <dons> so if you have to ask, then you shouldn't worry :) it'll be fine.
16:21:41 <dons> no no.
16:21:51 <Polarina> Implementing an IRC bot.
16:21:57 <Polarina> Handling all the IRC commands from the server.
16:22:09 <tibbe> #haskell is such a different place when you're on pacific time :)
16:22:13 <dons> hehe
16:22:19 <syntaxglitch> Polarina, I recommend that as a first order approximation, always assume GHC is smarter than you think it is
16:22:20 <dons> no euro trash :)
16:22:27 <tibbe> exactly ;) (just me)
16:23:08 <idnar> haha
16:23:16 <idnar> I'm in UTC+2
16:23:20 <idnar> other hemisphere, though
16:23:31 <tibbe> I'm normally in GMT+1
16:23:51 <Polarina> I am always in UTC.
16:23:57 <Polarina> :D
16:24:39 * Axman6 plays his UTC+10 and deals 8-9 damage
16:24:57 <tibbe> hah
16:25:13 * tibbe is procrastinating 
16:26:12 <kmc> syntaxglitch, i dunno, a lot of people assume auto memoizing of functions
16:26:33 <kmc> Polarina, did you see the irc parser on hackage?
16:26:43 <Polarina> kmc, there's an irc parser?
16:26:45 <syntaxglitch> kmc: Which illustrates my point, since most of the time that would probably be a bad idea
16:27:10 <Alpounet> @hackage irc
16:27:15 <Alpounet> damn
16:27:22 <Alpounet> well, check the "irc" package
16:29:02 <Polarina> But implementing an IRC parser is so easy that I'd prefer to do it myself. :D
16:32:15 <Cadynum> hello, im experimenting a bit with hstringtemplate but have run into an obstacle. im trying to include a template in a template which name is set dynamically
16:32:15 <Cadynum> im trying to do it with $(content)()$ , using setAttribute "content" "test", test.st being in my template dir
16:32:15 <Cadynum> however it doesnt seem to work, instead im getting the following error message:
16:32:15 <Cadynum> (line 11, column 2): unexpected "(" expecting white space or "$"
16:32:16 <Cadynum> What am i missing?
16:33:09 <dons> Polarina: an example. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16817#a16818
16:33:25 <Veinor> hm.
16:33:35 <Polarina> dons, oh, cool.
16:33:42 <Polarina> dons, where do you get that assembly output? :P
16:33:47 <Veinor> so if I'm going to make a plotter, what typeclass should the plot function's arguments be in?
16:33:50 <dons> from the ghc-core tool
16:34:00 <Veinor> Enum, Num, or both?
16:34:02 <dons> http://hackage.haskell.org/package/ghc-core
16:34:13 <Polarina> dons, cool!
16:34:43 <Veinor> I think... it'll have to be both. :/
16:34:44 <Polarina> dons, thank you.
16:35:38 <Veinor> that or handwrite a function that takes a start, a stop, and a step, and produces the appropriate list.
16:37:06 <Polarina> I downloaded that package, how do I install it? :)
16:37:31 <dons> cabal install ghc-core
16:37:57 <Polarina> Nice.
16:38:17 <Veinor> also, I need to recompile ghci, this sucks :(
16:38:28 <Veinor> because I don't know if there's a way to just compile ghci
16:38:36 <dons> recompile ghci?
16:38:50 <Veinor> yeah, for libedit-dev support
16:38:55 <Veinor> so I can have a working home key.
16:39:03 <dons> ah
16:40:49 <Polarina> dons, I get this error: http://codepad.org/GvJRy8OW
16:41:48 <luqui> Saizan, hm, I can't seem to specify that I don't want to build the executable if SDL isn't available.
16:41:58 <luqui> construct is not supported at the top level
16:42:30 <dons> Polarina: what ghc are you using?
16:42:35 <Polarina> dons, 6.8
16:43:13 <dons> oh, that's too old. try updating to ghc 6.10.4 (via the haskell platform).
16:43:24 <dons> or use an older version of ghc-core
16:43:29 <Polarina> How?
16:43:44 <dons> you can download 6.10.4 here,
16:43:52 <dons>  http://hackage.haskell.org/platform/
16:43:52 <Polarina> Can I compile 6.12 somehow?
16:43:55 <dons> sure.
16:43:57 <syntaxglitch> Veinor, hey, do you have a link to any information about that, that's been annoying me with ghci as well
16:44:08 <dons> Polarina: it depends on your distro.
16:44:15 <Polarina> dons, Debian Squeeze.
16:44:20 <Polarina> dons, can't I use cabal?
16:44:24 <Veinor> supposedly compiling from source with libedit-dev will work
16:44:28 <dons> using the ghc that comes with your distro is probably best.
16:44:54 <dons> ah, but squeeze ships with 6.8 http://packages.debian.org/squeeze/ghc6
16:44:54 <Polarina> dons, 6.8 is what came with my distro.
16:45:09 <dons> 6.12 is in experimental, http://packages.debian.org/experimental/ghc6
16:45:15 <tibbe> is there a call graph tool for haskell? Given a function could it show me (all) call graphs by just following function calls?
16:45:23 <dons> 6.10 is in unstable, http://packages.debian.org/sid/ghc6
16:45:32 <dons> tibbe: yeah, i think so. graphalyze ?
16:45:35 <tibbe> I realize that might be tricky for the same reason stack dumps are tricky
16:45:37 <Veinor> syntaxglitch: I'm compiling it right now on my stock Ubuntu 9.10 install, will let you know if it works.
16:45:38 <dons> pretty sure on hackage  there is such a tool
16:45:40 <tibbe> dons: oh?
16:45:46 <dons> or at least some fake version
16:45:54 <tibbe> dons: I'll have a look.
16:46:17 <tibbe> I really miss such a tool at work for digging trough the spaghetti (C++) code that I sometimes run into
16:46:36 <dons> there's a tool on hackage for internal/external call graphs of JS
16:46:41 <dons> (the webbits package)
16:46:50 <Veinor> that is, if this compilation will ever finish.
16:46:51 <mreh_> has anyone got any suggestion for a better implementation for this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16819#a16819
16:46:51 <syntaxglitch> Veinor, thanks, I'm on Ubuntu 9.10 as well
16:46:54 <kmc> Doxygen does C++
16:47:01 <mreh_> there's bugs I just can't track down
16:47:09 <kmc> doxygen call graphs are usually pretty useless though
16:47:13 <dons> mreh_: write QuickCheck properties for each function?
16:49:02 <Veinor> syntaxglitch: just be aware, compiling ghc takes a long time :P
16:49:25 <syntaxglitch> Veinor, I've done it before, I know
16:49:57 <syntaxglitch> At least this machine is faster than the one I was compiling it on the other time, so hopefully I'll be pleasantly surprised
16:50:21 <mreh_> dons: do you just give it some invariants?
16:50:29 <mm_freak> there was this xkcd-like comic showing programming languages as seen by programmers of other languages
16:50:38 <mm_freak> does anyone know where to find it?
16:51:27 <djahandarie> mm_freak, http://axgle.github.com/images/haskell.jpg
16:52:33 <Botje> http://www.spy.org/tmp/lang-by-sdy.jpg
16:52:37 <Botje> rather :)
16:52:38 <mm_freak> djahandarie: no
16:52:43 <mm_freak> xkcd-like
16:53:13 <djahandarie> lol
16:53:19 <kmc> mm_freak, programming languages as seen by programmers of other languages as explained using internet memes and awkward sexual references?
16:53:28 <soupdragon> lol
16:53:35 <jfoutz> lambdabot is gone?
16:53:42 <retroj> hi, on my debian system, i have installed libghc6-parsec-dev but when I compile a program with "import Parsec", ghc (through cabal) complains "Could not find module Parsec".  could this be related to something I'm doing, or does it suggest a problem with the debian package?
16:53:48 <dons> mreh_: yeah
16:53:52 <dons> see RWH.
16:53:59 <mreh_> do you think a haskeller made that image?
16:53:59 <dons> jfoutz: mmm
16:54:09 <kmc> retroj, Text.ParserCombinators.Parsec
16:54:18 <Alpounet> jfoutz, she didn't reconnect after the freenode server migration indeed
16:54:53 <retroj> kmc: thank you
16:54:53 <mreh_> dons: okay
16:55:34 <mreh_> dons: if it comes back with exactly what I already knew I'll come speak to you :)
16:55:55 <Veinor> yay, I think it's almost done!
16:56:13 <mreh_> Veinor: unlikely
16:56:14 <dons> hehe
16:56:15 <Veinor> the one I saw had everybody seeing Haskell programmers as Einstein, heh
16:56:35 <syntaxglitch> I think the original version didn't have Haskell or Lisp
16:56:36 <dons> mreh_: it might show you the difference between properties you think hold, and what your iimplementation actually does.
16:57:04 <Veinor> ooh, it's done building ghc. I think it's onto modules now.
16:57:07 <jfoutz> so... i have this idea about mif :: Bool -> a -> Maybe a, and eif Bool -> a -> b -> Either a b, they're pretty handy. who would i talk to about adding them to Data.Maybe and Data.Either? just submit justification/patches to libraries@haskell.org ? or is there another way?
16:57:08 <syntaxglitch> and the one with a column full of Einstein had been "improved" by a haskell fan
16:57:10 <kmc> Veinor, yeah, that one pissed me off
16:57:24 <mreh_> dons: does it work on Monadic code?
16:57:47 <syntaxglitch> on the other hand, I have to say the "X as seen by Haskell fans" row seemed pretty dead-on accurate
16:58:06 <Veinor> syntaxglitch: pretty much.
16:58:19 <djahandarie> I don't get the ruby as seen by Haskell
16:59:00 <pikhq> djahandarie: ... You haven't read Calvin and Hobbes?
16:59:12 <djahandarie> Nope >_>
16:59:23 <pikhq> djahandarie: Fix that.
16:59:24 <pikhq> It is imperative.
16:59:26 <Axman6> i've seen a bit, but i don't get it either
16:59:38 <tommd> Wow - so many people who shouldn't be on IRC
16:59:49 <dons> hey
16:59:50 <dons> what?
17:00:09 <tommd> People who haven't seen Calvin and Hobbes - its OT but very important.
17:00:33 * BMeph appreciates the symmetry between the Haskell->C fans vs. C->Haskell fans... :)
17:01:36 <mreh_> what symmetry?
17:02:28 <syntaxglitch> Veinor, I say compiling GHC shouldn't be required, it should just lazily compile itself on demand as needed, don't you think?
17:03:24 <mreh_> only the haskell line makes much sense :)
17:03:32 <jrockway> the java also makes sense
17:03:59 <jrockway> someone who i work with who is a big java fan said something like "i need management to approve these UML diagrams before i being work"
17:04:31 <jrockway> gotta love the corporate mentality
17:04:45 <mreh_> heh
17:04:49 <mreh_> that's funny, to me
17:05:11 <Axman6> jrockway: that's when you say: "i've gotta go on break because i've been too productive they're thinking of reducing our staff"
17:05:17 <mreh_> the home brewed theme of the C column is accurate
17:05:39 <jrockway> that's basically how I see UML diagrams
17:05:56 <jrockway> "i don't really want to do anything today, and this seems more like work than watching TV"
17:08:06 <kmc> if you're going to scribble diagrams on a whiteboard, you might as well use a common notation
17:08:09 <flippo> My software is so complicated that I can only explain it with diagrams.  That's the message I like to send with UML.
17:08:30 <tibbe> dons: I'm trying to write that blog post about reading code but it's difficult. It feels like I'm saying trivial things
17:08:31 <kmc> problem more being when these diagrams are required for stuff you wouldn't whiteboard
17:09:05 <andrewsw> those diagrams would be a lot more useful if people could read my handwriting
17:10:04 <Veinor> syntaxglitch: haha
17:10:08 <Veinor> also, it worked!
17:10:18 <jrockway> i've never seen a finished product that looked anything like the UML diagram
17:10:36 <syntaxglitch> Veinor, awesome
17:10:38 <jrockway> so personally, i just start hacking, and if the design sucks, i just fix it
17:10:44 <jrockway> no need for meetings or diagrams :)
17:11:18 <syntaxglitch> Veinor, are there any particular instructions you were following or is it just "build ghc from source"
17:11:26 <Veinor> the ones here: https://bugs.launchpad.net/ubuntu/+source/ghc6/+bug/483455
17:11:42 * syntaxglitch has gotten soft from using package managers, not used to compiling and installing stuff manually
17:13:19 <syntaxglitch> Veinor, anyway, thanks, that'll make using ghci much more pleasant
17:13:51 <Veinor> no problem.
17:14:28 <monochrom> http://www.haskell.org/ghc/dist/6.10.4/ghc-6.10.4-i386-unknown-linux-n.tar.bz2
17:14:49 <tensorpudding> you don't have to compile, you can install the pre-compiled binary
17:14:59 <monochrom> which is the url I just gave
17:15:15 <monochrom> http://www.haskell.org/ghc/dist/6.10.4/ghc-6.10.4-x86_64-unknown-linux-n.tar.bz2 if you want 64-bit
17:15:34 <syntaxglitch> ooh, that sounds much nicer than recompiling
17:15:48 <Veinor> true. :o
17:15:59 <tensorpudding> there is no reason to compile if the binary is available
17:16:08 <tensorpudding> and generic
17:16:09 <Veinor> does it contain ghci with libedit hooks?
17:16:39 <Wooga> how i can use IO int as usual int? 'readLn (randomRIO (0,6))' seems like not working
17:16:41 --- mode: ChanServ set +o monochrom
17:16:47 --- mode: monochrom set +v acowley
17:17:04 <Twey> Who's acowley and why do they need voice?
17:17:12 <Twey> Wooga: You don't
17:17:21 <Veinor> ugh, what; cabal is failing to build.
17:17:34 <Twey> Wooga: You don't take values out of IO, you push transformations into IO.
17:17:36 <tensorpudding> you can lift a pure function into the IO monad if you really want to
17:17:45 <Axman6> Wooga: do the types match? if not, then no
17:17:56 <Twey> :t readLn
17:18:04 <Axman6> :t readLn
17:18:07 <Axman6> argh
17:18:10 <Alpounet> lambdabot isn't there
17:18:13 <tensorpudding> > liftM succ (Just 5)
17:18:14 <Twey> Argh!
17:18:15 <Gracenotes> Read a => IO a
17:18:17 <tensorpudding> boo
17:18:18 <Twey> The world, it is coming to an end!
17:18:20 <Gracenotes> iirc
17:18:23 <Twey> Anyway
17:18:24 <Twey> Yeah
17:18:25 <kmc> Wooga, http://www.haskell.org/haskellwiki/Introduction_to_IO
17:18:33 <Twey> readLn doesn't take an argument
17:18:43 <Twey> So of course attempting to call it with one won't work
17:18:43 <Alpounet> it's an IO action
17:18:45 <kmc> Wooga, do { n <- randomRIO (0,6); otherThing n }
17:18:53 <kmc> yeah, readLn is not a function
17:19:11 <Axman6> Wooga: you may find this helpful too: http://random.axman6.com/blog/?page_id=70
17:19:15 <Wooga> thanks!
17:19:31 <acowley> Can anyone give me a nudge with a CT proof? I'm unsure how to prove the uniqueness of the mediating arrow of the composite pullback from the pullback lemma.
17:19:48 * acowley is working through Pierce's book
17:19:55 <Philonous> Is it bad when c2hs crashes with "c2hs: src/C2HS/Gen/Bind.hs:(662,0)-(691,75): Non-exhaustive patterns in function enumDef" or is this my fault?
17:20:01 <Gracenotes> liftM read getLine
17:20:08 <tensorpudding> this channel seems to get more CT questions than #math does
17:20:17 <kmc> yeah, we have a reputation
17:20:18 <Twey> Philonous: I suspect it's your fault
17:20:27 <Twey> Though they probably should have given you a more useful error
17:20:43 <Axman6> Philonous: compile with -Wall if you can
17:20:48 <acowley> I think the perspective here can sometimes be more useful for a CS person
17:20:51 <Axman6> it should tell you what's not matched
17:20:56 <tensorpudding> though HaskellLove visits a lot with CT questions
17:21:08 <Axman6> >_<
17:21:31 <mreh_> are there compiler warnings for when you override a var in scope?
17:21:44 <Twey> mreh_: Yes
17:21:45 <mreh_> I keep doing that
17:21:47 <kmc> mreh_, -fwarn-name-shadowing
17:21:50 <Axman6> i believe they're shadowing warnings
17:21:52 <kmc> or just use -Wall
17:21:56 <Twey> Just -Wall, yeah
17:22:01 <mreh_> does that relate to Larry Wall?
17:22:07 <kmc> heh
17:22:07 <Gracenotes> :o
17:22:20 <tensorpudding> -W is for warning
17:22:21 <Zao> Does Text.Regex expose some kind of interface to do s/foo/bar/-like substitutions, or do I have to capture everything and glue something together myself?
17:22:24 <mreh_> Perl gives lots of warnings
17:22:28 <tensorpudding> -Wall is all warnings
17:22:34 <Gracenotes> -Welsh
17:22:42 <mreh_> heh, -Wall
17:22:51 <tensorpudding> though in gcc i don't think it's all warnings
17:22:57 <Gracenotes> @quote wall
17:23:05 <Axman6> lambdabot!
17:23:06 <mreh_> @botsnack
17:23:08 <Axman6> :'(
17:23:11 <tensorpudding> you need gcc -pedantic -Wall -Wextra
17:23:15 <Axman6> where for art thou? :(
17:23:22 <Twey> Argh
17:23:36 <syntaxglitch> :( I miss Œªbot
17:23:47 <monochrom> :)
17:23:51 <mreh_> some doesn't want their botsnacks!
17:23:57 <Twey> Is she broken for seven?
17:23:59 <monochrom> gcc -pedentic -Wall -Wextra -ansi
17:24:08 <tensorpudding> ah, forgot the -ansi
17:24:10 <Alpounet> , 1+1
17:24:19 <Alpounet> hmm
17:24:24 <Alpounet> preflex, 1+1
17:24:24 <Philonous> Twey: It was indeed my fault. Tried to convert an enumeration that wasn't an enumeration in the first place.
17:24:29 <Philonous> Twey: Thanks
17:24:32 <kmc> the regex interface is weird
17:24:38 <tensorpudding> because the default gcc accepts some reaaaally stupid code
17:24:41 <Alpounet> what are preflex's commands already ?
17:24:44 <Veinor> gah, cabal-install keeps on failing to build :(
17:24:49 <tensorpudding> without complaining
17:24:51 <kmc> preflex, be lambdabot
17:24:56 <jrockway> Zao: subRegex or something?
17:25:10 <Twey> Philonous: You're welcome
17:25:15 <mreh_> how much better is n log n than n^2
17:25:29 <tensorpudding> mreh_: asymptotically better
17:25:31 --- mode: monochrom set +v preflex
17:25:34 <Veinor> n / log n better.
17:25:34 <monochrom> , 0
17:25:43 <monochrom> @botsnack
17:25:46 <monochrom> @bots
17:25:48 <Veinor> oh huh, I was running out of memory.
17:26:22 <monochrom> preflex: @seen monochrom
17:26:22 -preflex(~preflex@95-88-118-220-dynip.superkabel.de)- monochrom was last seen on #haskell 36 seconds ago, saying: @bots
17:26:37 <monochrom> preflex: > 1+1
17:26:53 <monochrom> preflex: , 1+1
17:26:59 <tensorpudding> preflex: @nixon
17:27:15 <tensorpudding> preflex doesn't know many tricks
17:27:18 <Zao> jrockway: That seems to be restricted to the posix backend.
17:27:23 <Zao> Which is not available here.
17:27:41 <jrockway> i agree that the posix backend is bad, but i doubt it's not available here
17:27:46 <jrockway> i got it working on plain win32 the other day :)
17:28:07 <jrockway> googling a bit indicates that you will have to do it yourself
17:29:32 <jrockway> (googling also turns up some things that say "it's impossible to do this generally", which i disagree with, having used Perl for many years)
17:29:36 <jrockway> a library is needed. :)
17:30:30 <sshc> @seen me
17:30:38 <sshc> @seen sshc
17:30:42 <mreh_> is there a more efficient way of doing a list minus than sticking the subtracthand in a hashmap?
17:30:59 <kmc> we don't have a standard hashmap
17:31:03 <sshc> preflex: @seen sshc
17:31:03 -preflex(~preflex@95-88-118-220-dynip.superkabel.de)- sshc was last seen 12 seconds ago, saying: <private message>
17:31:04 <kmc> use Data.Set or Data.Map
17:31:09 <sshc> preflex: @seen sshc
17:31:10 -preflex(~preflex@95-88-118-220-dynip.superkabel.de)- sshc was last seen on #haskell 7 seconds ago, saying: preflex: @seen sshc
17:31:27 <danderson> with cabal, how do you install profiling libraries for packages? Specifically, I'm following the RWH guide on profiling, and ghc is complaining that it can't find a bunch of packages when -prof is passed.
17:31:27 <mreh_> i suppose it's a tree based thing
17:32:03 <jrockway> danderson: "cabal install -p foo-library"
17:32:03 <kmc> mreh_, it's an abstract interface with suspiciously tree-like time complexity ;)
17:32:14 <jrockway> sometimes needs a --reinstall if you have already installed the libraries
17:32:15 <mreh_> is Data.Map a heap?
17:32:26 <danderson> wow, that was easy :)
17:32:36 <mreh_> kmc okay :)
17:32:38 <jrockway> danderson: and then in the future, you can turn that flag on in your .cabal config
17:32:39 <Axman6> mreh_: it's a tree
17:32:40 <danderson> jrockway: any disadvantage to always installing with -p?
17:32:44 <sjanssen> mreh_: it isn't a heap, but I've used it as one in a pinch
17:32:46 <jrockway> twice as slow
17:32:49 <Twey> Slows stuff down, makes stuff bigger
17:32:58 <mreh_> a heap is a tree
17:33:12 <syntaxglitch> Data.Map is a balanced binary tree, I think
17:33:13 <danderson> twice as slow to install, but not to run, right? afaict it's using a different set of libs when profiling is on
17:33:17 <jrockway> a tradeoff that is worth it, imho, because cabal-install --reinstall is 3x slower in the long run :)
17:33:22 <jrockway> yeah
17:33:25 <jrockway> no runtime hit
17:33:30 <jrockway> (when you are not profiling)
17:33:35 <jrockway> it just has to compile everything twice
17:33:38 <jrockway> once normal, once profiling
17:33:52 <danderson> okay, well, if a ghc -O doesn't slow down once I'm done profiling, awesome. I'll go hunt down the switch.
17:34:06 <Veinor> stylistic question: if I have a type constructor, Axis, whose type argument has to be both Num and Enum, should I make an AxisValue typeclass?
17:34:13 <syntaxglitch> whereas I think Data.IntMap is a radix tree sort of thingie, and should have much better time complexity than Data.Map
17:34:21 <jrockway> danderson: yeah, no slowdown when not profiling
17:34:30 <danderson> great
17:34:39 <danderson> any cabal shorthand to --reinstall all installed packages?
17:34:52 <acowley> Veinor: I'd vote for no on that one
17:34:54 <jrockway> not that i know of
17:34:58 <mreh_> syntaxglitch, why didn't they make Data.Map the fastest?
17:35:04 <jrockway> i had to do this recently, and just manually followed the tree backwards
17:35:05 <Twey> ls ~/.cabal/packages | xargs cabal -p --reinstall
17:35:22 <jrockway> i should have done that though :)
17:35:27 <Twey> ‚ò∫
17:35:31 <Axman6> mreh_: because IntMap relies on the fact its keys are ints
17:35:32 <syntaxglitch> mreh_, it's more general purpose
17:35:33 <acowley> Veinor: there are proposals for aliases for type constraints, but I'm not aware of anything you can use today
17:35:46 <Axman6> Map workks on anything with an Ord instance
17:36:03 <mreh_> > maxBound :: Int
17:36:09 <mreh_> nooo!
17:36:32 <syntaxglitch> the data structure underlying IntMap only works for types with unambiguous serialization/deserialization
17:36:47 <Veinor> acowley: well, basically here's what I've got: I'm doing an ascii 2D function grapher, and I'm thinking it has type signature Grid a b -> (a -> b -> Plottable c) -> String
17:37:06 <Veinor> where I might say PlotFunction a b c = a -> b -> Plottable C
17:37:11 <Veinor> am I thinking about this the wrong way?
17:37:33 <mreh_> syntaxglitch, I don't know what that means
17:37:33 <danderson> so, another performance related question, while cabal rebuilds the universe
17:37:43 <Veinor> also, the lambdabot package has paradoxical dependencies :(
17:38:29 <danderson> I have a QC Arbitrary instance to generate random valid(-ish) IP datagrams, and running tests that need datagrams is very slow (6s to generate 100 packets)
17:38:35 <syntaxglitch> mreh_, roughly speaking you have to be able to convert the key type to and from [Int] in a reliable, unambiguous way
17:38:57 <Veinor> actually... I think that I'm going to do toBitmap :: Grid a b -> (a -> b -> Plottable c) -> [[Int]] and then toASCII :: [[Int]] -> String
17:39:01 <Veinor> but anyway.
17:39:06 <danderson> I suspect that the main problem is that I'm generating the payload as a list of random Word8, then packing it into a ByteString. Is there a way to get at the UArray in the ByteString directly to twiddle it in-place?
17:39:33 <sjanssen> danderson: ByteString is not a UArray, it's a ForeignPtr
17:39:41 <jrockway> have you profilied and found that that's the bottleneck?
17:39:50 <jrockway> i find arbitrary to be generally slow
17:39:55 <jrockway> slower than i'd expect, anyway
17:39:58 <jrockway> but i haven't profiled either
17:40:02 <mreh_> has anyone implemented the ol' list as a complete binary tree?
17:40:02 <danderson> jrockway: no, I'm currently rebuilding all my libs to have profiling info :)
17:40:07 <jrockway> right. :)
17:40:12 <danderson> so while that's happening, I'm guessing randomly for a bit
17:40:22 <jrockway> fair enough
17:40:29 <syntaxglitch> why the standard library doesn't include a more generalized version of IntMap I don't know, though, there's a lot of key types where that would be easy and much better than Data.Map
17:40:41 <danderson> sjanssen: oh. I thought I'd read in the docs that it used an UArray under the hood.
17:40:49 <jrockway> danderson: if you find anything groundbreaking, let me know
17:40:51 <jrockway> i have something liek:
17:40:54 <danderson> oh yeah, never mind
17:40:56 <sjanssen> danderson: you're right in suspecting that converting lists to ByteString is rather slow
17:41:04 <danderson> it used to be UArray, now it's ForeignPtr
17:41:08 <jrockway> arbitrary = do { foo <- arbitrary; bar <- arbitrary; Thing foo bar }
17:41:13 <jrockway> and that is ... not too fast
17:41:20 <jrockway> making 100 of them takes a second or so
17:41:38 <danderson> jrockway: probably a nice slice of GC overhead there
17:41:41 <sjanssen> danderson: unfoldrN sounds like what you want http://www.haskell.org/ghc/docs/latest/html/libraries/bytestring-0.9.1.5/Data-ByteString.html#v%3AunfoldrN
17:42:06 <syntaxglitch> mreh_, do you mean treating a basic list as a tree? That's not a good idea
17:42:08 * mreh_ like noticable differences in running time
17:42:29 <mreh_> syntaxglitch, well, an array then
17:43:00 <syntaxglitch> I doubt it'd be worthwhile for the most part
17:43:10 <syntaxglitch> If you want a tree, use a tree-like data structure
17:43:14 <danderson> sjanssen: good idea. I'll give that a go once cabal has finished churning.
17:43:39 <danderson> note that I don't specifically mind if the quickcheck tests are slow, I'm just jumping on the occasion to learn more about profiling in haskell
17:43:56 <danderson> since I'm trying to write an I/O heavy server, I suspect I'll need all the help I can get :P
17:44:30 <mreh_> is Array a genuine O(1) access data structure?
17:44:41 <Axman6> yes
17:44:51 <chrisdone> http://www.emacswiki.org/emacs/QuickCheckHaskell
17:44:53 <Axman6> but it's an O(n) update, unless you do it in IO or ST
17:45:00 <dufflebunk> where did lambdabot go?
17:45:01 <syntaxglitch> mreh_, IntMap is an O(1) access structure as well, you know
17:45:05 <chrisdone> like what ya see? there's more where that came from
17:45:08 <syntaxglitch> for certain definitions of O(1)
17:45:59 <mreh_> Axman6, I need fast removal and update, I think a tree is my best bet
17:46:06 <Axman6> yup
17:46:19 <sshc> what happened to lambdabot?
17:46:33 <mreh_> she drinks heavily
17:46:38 <syntaxglitch> mreh_, then use IntMap if you can
17:46:45 <mm_freak> @botsnack
17:46:46 <Twey> Her balance fails and she falls off the wire
17:47:13 <luqui> syntaxglitch, what is that definition.  is it because of the 32 bit bound.
17:47:34 <jmcarthur> luqui: that's right
17:48:01 <luqui> i don't think that's fair.  you wouldn't call a Map of [Int] where all the lists are constrained to be less than 500 elements O(1)
17:48:08 <luqui> even though... technically... it is
17:48:19 <luqui> it definitely depends on how many things are in the map, as it does with IntMap
17:48:20 <jmcarthur> luqui: and a common argument is that a memory access is O(log n) anyway on most architectures
17:48:32 <jmcarthur> but it's pushing it i think
17:48:47 <luqui> log n where n is what?
17:48:49 <mreh_> jmcarthur, are we talking after it goes through the hierachy?
17:49:16 <Polarina> Is 'length' on a 'Data.ByteString' (the strict one) optimized to be O(n) in ghc?
17:49:19 <jmcarthur> luqui: i guess n would the theoretical maximum of memory supported by the architecture
17:49:35 <tibbe> Polarina: length should be O(1) as it's kept separate in the data structure
17:49:36 <jmcarthur> which is pretty much the same as for IntMap
17:49:42 <luqui> see that's different.  Map depends on the number of elements stored by the map.
17:49:42 <Polarina> tibbe, cool.
17:49:49 <luqui> I could buy a *trie* of Ints being O(1)
17:49:55 <jmcarthur> luqui: which is still bounded by the same n, though
17:49:55 <syntaxglitch> IntMap is a trie.
17:50:02 <jmcarthur> yeah, it's a trie ;)
17:50:08 <luqui> oh IntMap is a trie?
17:50:11 <tibbe> intmap is O(W) where W is the number of bits in Int
17:50:11 <jmcarthur> radix tree
17:50:13 <syntaxglitch> actually I think it's a patricia tree
17:50:19 <kmc> urgh, asymptotic complexity
17:50:20 <luqui> well... ok then... nevermind :-)
17:50:21 <jmcarthur> all three are the same thing
17:50:23 <syntaxglitch> Which is a trie with merged prefixes
17:50:26 <syntaxglitch> or something
17:50:42 <tibbe> IntMap stores a bitmask and the number of "useful" bits in that bitmask
17:50:50 <luqui> I think I could have made my argument precise by saying Theta instead of O.
17:50:50 <tibbe> i.e. the discriminating bits
17:51:23 <syntaxglitch> anyway, yeah, IntMap is based on a variation on tries, so in an idealized sense it's O(1) in number of elements and O(n) in "size of key in bits"
17:51:43 <tibbe> right
17:52:21 * syntaxglitch notes that all the people who moan about Haskell not having a viable hash table tend to forget that hash functions are non-constant complexity in key size
17:53:10 <mreh_> should I got O(n) when I could get (n log n)?
17:53:38 <mreh_> yes of course
17:53:38 <luqui> tries ftw
17:54:15 <luqui> tries are laziness-friendly.  :-)
17:54:28 <jmcarthur> tries are love
17:54:38 <Zao> I'm looking for a function with the signature [(a -> a)] -> a -> a    (or the flipped one), which would apply each function in the list in turn on the seed value, and yield a value in the end.
17:54:39 <syntaxglitch> I do wish the standard libraries had a trie-like structure indexed by something other than Int, though
17:54:42 * tibbe notes that laziness in data structures is often worth it if you need it semantically
17:54:42 <Zao> Like an unary fold.
17:55:00 <Zao> Or hrm, not quite like that at all.
17:55:08 <dibblego> Zao, sequence
17:55:09 <jmcarthur> Zao: Endo?
17:55:09 <soupdragon> sequence :: [(a -> a)] -> a -> a
17:55:16 <soupdragon> damn!! dibblego is better than me ;P
17:55:18 <tibbe> syntaxglitch: we can get it with associated data types
17:55:19 <jmcarthur> heh, sequence, nice
17:55:32 <tibbe> syntaxglitch: that would be right way to do it without (too much) code duplication
17:55:35 <Philonous> Is there a feasible way to interface to variadic c functions?
17:55:37 <Zao> Doesn't sequence involve monads?
17:55:42 <soupdragon> Zao yes
17:55:49 <dibblego> Zao, you're using a monad (the ((->) a) monad)
17:56:00 <mreh_> adding to n digit numbers is O(n) complexity according to wikipedia...
17:56:02 <jmcarthur> :t sequence :: [(a -> a)] -> (a -> a)
17:56:02 <Zao> Ah. Stealthy little bugger.
17:56:06 <dibblego> > sequence [(+1), (*2)] 7
17:56:09 <mreh_> s/to/two/
17:56:13 <jmcarthur> dang, LB is down
17:56:33 <tibbe> preflex: :t sequence :: [(a -> a)] -> (a -> a)
17:56:34 <jmcarthur> just like the fire in my fireplace :(
17:56:44 <kmc> foldr (.) id
17:57:02 <syntaxglitch> mreh_, arithmetic has nasty time complexity if you exceed what the hardware can handle
17:57:03 <Zao> Amusingly enough, I used sequence with IO earlier in the statement.
17:57:21 <kmc> sequence would have type [a -> b] -> a -> [b]
17:57:46 <kmc> and is equivalent to \fs x -> map ($ x) fs
17:57:47 <kmc> i think
17:57:47 <syntaxglitch> tibbe, just a map keyed by [Int] would be reusable enough
17:57:59 <tibbe> syntaxglitch: but not as fast
17:58:17 <syntaxglitch> same time complexity, at least
17:58:46 <dibblego> woops yes sorry
17:59:33 <syntaxglitch> anything you'd want to put into a trie ought to be convertible to and from [Int] with complexity linear in list length anyway
17:59:43 <syntaxglitch> which is the same time complexity as trie access
18:03:24 <syntaxglitch> although, since I'm complaining about the standard libraries, am I the only one who gets annoyed by a bunch of functions with almost identical semantics existing for sets, maps, and even association lists?
18:03:31 <syntaxglitch> shouldn't those be a type class or something :(
18:04:48 <syntaxglitch> actually I'd rather see the functions for association lists gone entirely, they seem like a terrible idea
18:05:40 <Twey> I'd rather see a Map typeclass that included Eq a => [(a, b)]
18:05:40 <Zao> kmc: Hrm, not quite what I want then.
18:05:57 <Zao> All I want to do is thread my original value through the list of functions.
18:06:06 * syntaxglitch would like to junk (!!) as well
18:06:10 <Twey> Association lists are often quite useful
18:06:15 <Twey> (!!) is less useful
18:06:21 <Twey> But it has its moments
18:06:21 <dibblego> @type mconcat
18:06:21 <temoto> syntaxglitch, association list?
18:06:26 <tensorpudding> why would you junk (!!)?
18:06:30 <mreh_> can I make a list infinite by referring back to it's own head?
18:06:35 <dibblego> @type mconcat
18:06:38 <Twey> showIntAtBase 2 ("01" !!)
18:06:44 <medfly> damn functions which I'm not even forced to use!
18:06:47 <Zao> mreh_: cycle
18:06:48 <syntaxglitch> temoto, treating a list of tuples as an associative collection
18:07:11 <syntaxglitch> tensorpudding, because indexing a cons list is a bad idea and we shouldn't encourage people to do it
18:07:39 <medfly> BUT I WANT TO KNOW WHERE I'M AT!
18:07:42 <temoto> I guess terrible operator is already non-encouraging.
18:07:52 <syntaxglitch> mreh_, google for "tying the knot"
18:07:53 * drdr now loves that he learned functonal programing
18:08:17 <tensorpudding> it is true that indexing a cons list is bad but will removing the (!!) operator really encourage people to write in a style where it's not needed?
18:08:39 <medfly> why is using (!!) bad?
18:08:41 <tensorpudding> i use (!!) as a convenience function sometimes
18:08:47 <medfly> other than the fact it doesn't seem to use Maybe
18:09:04 <syntaxglitch> tensorpudding, at least removing it from the implicit Prelude import
18:09:10 <syntaxglitch> medfly, because it's inefficient
18:09:15 <tensorpudding> that's fair i guess
18:09:18 <tensorpudding> leave it in Data.List
18:09:23 <dibblego> it's only bad to the extent that you should be using something else besides [], such as Data.Sequence
18:09:24 <syntaxglitch> It's indexing into a intrinsically sequential data structure
18:09:26 <medfly> isn't that a property of lists?
18:10:13 <syntaxglitch> (xs!!n) has time complexity O(n)
18:10:27 <medfly> isn't that mostly because it uses lists? :o
18:10:37 <tensorpudding> indexing is good on an array
18:10:38 <syntaxglitch> people coming from a background in most languages are likely to assume that indexing is cheap
18:10:46 <syntaxglitch> e.g., like O(1) indexing into an array
18:10:59 <medfly> it's not really (!!) is it, it's lists
18:11:12 <tensorpudding> though whenever you index you run risks of being out of bounds if you're doing it stupidly
18:11:21 <syntaxglitch> no, lists are fine if you use them for what they're meant for
18:11:35 * medfly shrugs.
18:11:56 <tensorpudding> (!!) has to traverse the whole list to give an out-of-bounds exception
18:11:56 <temoto> I came from that background and i can tell you, the problem is with lists.
18:11:59 <medfly> when I learnt Haskell I wrote all those functions myself, so I don't need to be hinted that using them might be a bad idea in some cases.
18:12:58 <tensorpudding> i like how the visual impact of (!!) indicates surprise
18:13:02 <temoto> The problem is that somewhy haskell people assume "linked list" = list is so natural. It's not to anyone with non-functional background.
18:13:04 <medfly> hehe
18:13:07 <dibblego> if you are using (!!) you probably shouldn't be using lists (and therefore (!!))
18:13:08 <Twey> > [] !! 1
18:13:11 <Twey> Oh!
18:13:22 <Twey> 02:10:27 < Twey> showIntAtBase 2 ("01" !!)
18:13:31 <tensorpudding> it's like with destructive methods in ruby ending in !
18:13:49 <idnar> temoto: uhm, I dunno, isn't a list a linked list in every language except Python? :P
18:14:10 <idnar> I guess it's not in Perl either
18:14:13 <theorbtwo> idnar: Perl.
18:14:28 <idnar> I still don't understand Perl lists at all, though ;)
18:14:28 <dibblego> what is python's list exactly anyway?
18:14:35 <theorbtwo> Is a list really a linked list in other languages, except lisp and haskell?
18:14:39 <syntaxglitch> temoto, I don't know, I think it might be more obvious that a list is like a linked list if we didn't give people operators that look like array indexing by default :(
18:14:39 <temoto> idnar, in Flow list is a type class with many implementations, like array, linked list, double linked list.
18:14:43 <idnar> dibblego: it's a dynamic array
18:14:47 <theorbtwo> Linked lists aren't really very good at it.
18:15:11 <dibblego> idnar, you mean an array which has O(n) append?
18:15:22 <tibbe> dibblego: it's ammortized O(1)
18:15:30 <syntaxglitch> python lists have O(1) append
18:15:32 <temoto> syntaxglitch, you have a point. But then the problem is that everything is built around *lists*. You can't map on Array, etc.
18:15:35 <tibbe> dibblego: if you append and the backing array is full it's grown
18:15:50 <dibblego> tibbe, ok thanks
18:15:51 <tibbe> dibblego: with something like 2x
18:15:56 <syntaxglitch> but prepending to a python list is O(n) because it has to shift everything
18:16:08 <medfly> >.<
18:16:14 <tibbe> dibblego: which costs O(n) but since you only grow every n inserts it's ammortized O(1)
18:16:21 <Twey> So it's basically a backwards linked-list.
18:16:22 <idnar> syntaxglitch: amortized O(n)
18:16:32 <idnar> it's not a linked-list at all
18:16:47 <theorbtwo> syntaxglitch: That, too, is avoidable.  Also, you often get a choice of prepending or appending.
18:16:54 <tibbe> Python arrays are like C++ vectors
18:16:57 <sjanssen> temoto: in a lazy purely functional language, singly linked lists  are a great fit for many problems
18:17:05 <dibblego> it's more like Java and C# ArrayList by the sound of it
18:17:35 <sjanssen> temoto: but it is true that certain parts of Haskell's libraries rely on lists a bit too much rather than a more general interface
18:17:37 <tibbe> lazy lists are useful for the case you would have used a stream/generator type in other languages
18:17:44 <medfly> yeah, it's kind of annoying that you'd run into some difficulty if you tried to use anything that isn't a list
18:17:53 <idnar> if you want fast prepend, there's a deque type
18:17:58 <temoto> sjanssen, of course. But many problems fit Integers. And we still have everything compatible with Num, not Integer.
18:18:11 <tibbe> my biggest beef with haskell arrays is the annoying generalization of indexing
18:18:21 <tibbe> I yet haven't find a use case for non-zero based arrays
18:18:45 <sjanssen> tibbe: the best use case is non-Int indices
18:18:48 <Zao> tibbe: Mathematicians.
18:18:54 <theorbtwo> How difficult would it be to make a GHC extension that made arrays into a typeclass instead of a type?
18:19:15 <temoto> haha
18:19:16 <sjanssen> tibbe: it doesn't really have much to do with 0 vs. 1
18:19:21 <idnar> theorbtwo: do you mean lists?
18:19:31 * theorbtwo smacks forehead.
18:19:33 <theorbtwo> Yes.
18:19:37 <tibbe> sjanssen: whatever the reason, it gets in the way
18:19:53 <syntaxglitch> I think the list typeclass you want is "Foldable"
18:19:56 <idnar> theorbtwo: why do you need a compiler extension?
18:19:56 <syntaxglitch> in most cases
18:20:03 <kmc> theorbtwo, do you refer to list literal syntax?
18:20:05 <temoto> @src Foldable
18:20:06 <kmc> or the list itself?
18:20:09 <idnar> theorbtwo: do you want (:) and [] to be polymorphic or something?
18:20:20 <temoto> Is lambdabot dead?
18:20:22 <monochrom> It does not get in my way. I have algorithms heavily relying on it.
18:20:25 <medfly> @botsnack
18:20:26 <kmc> tibbe, i've used negative and positive indices in an array representing an image
18:20:28 <sjanssen> tibbe: I do think we need another layer between the fancy "Data.Array" and GHC internals
18:20:34 <Twey> Hmm‚Ä¶ type families‚Ä¶
18:20:35 <medfly> guess so?
18:20:38 <tibbe> sjanssen: agreed
18:20:38 <syntaxglitch> yeah, lambdabot is taking a nap
18:20:50 <tibbe> sjanssen: I've written that layer more than once for libraries
18:20:52 <medfly> bots need to get some rest ;)
18:21:01 <tibbe> sjanssen: every vector based data type seems to have one
18:21:02 <theorbtwo> kmc: I mean that foo :: [a] -> Int should work with Data.Array and List.
18:21:16 <tibbe> kmc: there are applications, you're right
18:21:37 <dibblego> theorbtwo, class Foo f where foo :: f a -> Int
18:21:43 <theorbtwo> Somebody said earlier that the problem is that you can't use map on a Data.Array.  Why not change the language so that you can?
18:22:04 <dibblego> theorbtwo, see fmap
18:22:09 <theorbtwo> dibblego: Now you need to use map', and length', and ...
18:22:13 <kmc> theorbtwo, that's what "fmap" is for
18:22:13 <theorbtwo> @src fmap
18:22:17 <monochrom> I used "map index".
18:22:18 <dibblego> theorbtwo, no you don't
18:22:24 <kmc> we should get rid of the list map and rename fmap to map
18:22:24 <syntaxglitch> yeah, just make array a functor, if it isn't already
18:22:26 * sjanssen points at instance Ix i => Functor (Array i)
18:22:37 <tibbe> the containers needs an overhaul
18:22:47 <tibbe> just like Scala did
18:22:48 <tensorpudding> though length doesn't work since it's not a list
18:22:50 <kmc> fmap maps over any Functor.  a Functor is anything you can map over
18:22:51 <syntaxglitch> kmc, yeah
18:22:55 <dibblego> fmap :: (Functor f) => f a -> (a -> b) -> f b
18:23:01 <syntaxglitch> fmap annoys me
18:23:07 <tensorpudding> wrong order there
18:23:12 <tensorpudding> the (a -> b) goes first
18:23:13 <sjanssen> kmc: Functors aren't really anything you can map over -- eg. UArray or ByteString
18:23:15 <dibblego> yeah flip that
18:23:28 <monochrom> Is this Saturday beer whining night?
18:23:28 <kmc> sjanssen, you're right
18:23:30 <temoto> @src fmap
18:23:33 <tensorpudding> but fmap is nice and polymorphic
18:23:34 <temoto> fmap = flip map
18:23:35 <syntaxglitch> I actually wrote myself a customized Prelude that replaces fmap with map, heh
18:23:35 <medfly> :)
18:23:37 <kmc> anything polymorphic you can map over, maybe
18:23:44 <temoto> That's how it called fmap after all!
18:23:45 <kmc> but it'd be nice to generalize further with instances in some way
18:23:46 <tensorpudding> length is not though
18:23:52 <Twey> Hm
18:23:54 <medfly> Caleskell
18:24:02 <tensorpudding> there is a length function for arrays though
18:24:03 <dibblego> tensorpudding, Data.Foldable
18:24:15 <Twey> (map, fmap) = (Prelude.fmap, flip Prelude.map)
18:24:18 <tensorpudding> the Prelude length, i should say
18:24:30 <sjanssen> I think the tension between parametric polymorphism and specialized containers is what's currently keeping us from a general purpose container interface
18:24:49 <tensorpudding> Foldable and Traversable and the like have tons of nice conflicting more-polymorphic versions of everything
18:25:05 <medfly> yay
18:25:20 * syntaxglitch wants to burn all the redundant conflicting functions with similar/identical names and nearly-identical semantics
18:25:25 <dibblego> just like Scala :)
18:25:33 <dibblego> (only it is much worse)
18:25:40 <syntaxglitch> sjanssen, how so?
18:26:03 <temoto> We discussed it with other guy. map is also a friendlier name to newcomers. They are already scared with monads, now something simple as iterating over list needs a Functor would be heavier to study.
18:26:09 * syntaxglitch doesn't see why wanting to use a specialized container would preclude having general container type class(es)
18:26:15 <sjanssen> syntaxglitch: how would you write the type class that supports the function 'map'?
18:26:33 <syntaxglitch> sjanssen, ...isn't that "Functor"?
18:26:51 <dibblego> class Functor f where (.) :: (a -> b) -> f a -> f b
18:26:54 <Twey> temoto: Don't care
18:26:55 <syntaxglitch> temoto, that's part of a wider issue of Haskell using scary-sounding names in general
18:26:56 <monochrom> How does using the name "map" get rid of Functor or typeclass?
18:26:58 <temoto> i'm not exactly there, personally i'd like to have only one 'map' as generic as possible, but his words make a point too
18:27:14 <sjanssen> syntaxglitch: yes, exactly.  You can't write an instance of Functor for ByteString, can you?
18:27:15 <tensorpudding> fmap
18:27:23 <Twey> You don't write a language for newbies, you write a language for people who know what they're doing
18:27:27 <Twey> Or you get COBOL
18:27:36 <syntaxglitch> just rename Functor to "Mappable" if you want to calm the newbies :P
18:27:40 <tensorpudding> depends on your definition of newbies
18:27:43 <medfly> "either that or COBOL!!!!!! PICK WHAT YOU PREFER!"
18:27:43 <Twey> Heh
18:27:48 <Twey> medfly: RIGHT!
18:27:50 <Twey> :√æ
18:27:58 <tensorpudding> why should it be called map?
18:28:04 <theorbtwo> Twey: At the same time, there's little reason not to make a language friendly, if it doesn't hurt to do so.
18:28:15 <tensorpudding> is map less unfamiliar for a newbie?
18:28:20 <monochrom> oh bother, no one is taking @remember commands
18:28:25 <sjanssen> syntaxglitch: basically, lots of useful containers are not parametric and classes like Functor discriminate against them
18:28:32 * temoto never seen a cobol program.
18:28:36 <Twey> theorbtwo: But it does hurt to do so.  It results in a bunch of redundant aliases.  We're turning into PHP.
18:28:40 <syntaxglitch> sjanssen, oh, I see what you're getting at
18:28:45 <tensorpudding> it'd only be more familiar if they've seen a function called map in another language
18:28:51 <tensorpudding> which means that they're not really a newbie
18:29:02 <medfly> they're a newbie when it comes to Haskell
18:29:09 <Twey> ‚ÄòOoh, newbies might screw up and type $concept_from_another_language by mistake‚Ä¶ better add another alias!
18:29:13 <Twey> ‚Äô
18:29:18 <temoto> tensorpudding, it's easier to explain. map doesn't involve functors, type classes.
18:29:35 * soupdragon thinks it's very simple
18:29:45 <pikhq> temoto: But fmap is pretty easy to explain.
18:29:47 <soupdragon> (1) Prelude.hs (2) BeginnersPrelude.hs
18:29:50 <Twey> temoto: So gloss over the other Functor instances when explaining it
18:29:51 <pikhq> "Look at what it does with lists!"
18:29:51 <theorbtwo> Twey: I'd much rather have a function called fmap and one called gmap that do the same thing then one called fmap and one called gmap that vary in some subtle, and useless, way.
18:29:54 <medfly> I liked having a simpler version of map because I mostly learnt Haskell by writing all those functions, and I imagine writing fmap would have been a lot more complicated.
18:29:59 <Twey> You don't have to explain everything in one place.
18:30:12 <pikhq> "(later...) fmap works on other Functors!"
18:30:21 <Twey> theorbtwo: Like, for example, that one can only be used on one specific type?
18:30:30 <Twey> pikhq: *nod*
18:30:33 <medfly> although I suppose I could have still done it
18:30:42 <medfly> and just later realised that the same thing can be generalised to functors. :p
18:31:01 <Twey> medfly: Right
18:31:06 <temoto> Hey common, i already said that i'd vote and be glad for single most generic map. Given this universe it would be fmap. But *also* i understand how current map is simpler to explain.
18:32:03 <Twey> temoto: But you don't have to explain it.
18:32:18 <temoto> Twey, that's true too.
18:32:27 <Twey> In fact, you can just say ‚Äòthis is a function that applies a function to every element of a list‚Äô
18:32:46 <temoto> and that would be honest, i understand
18:32:46 <Twey> And then they'll be able to use ‚Äòmap‚Äô
18:32:48 <idnar> syntaxglitch: I don't understand how something that isn't parametric can be a container
18:32:56 <Twey> You can explain it later
18:33:02 <tensorpudding> fmap takes a container and applies the function to every element of the container
18:33:06 <kmc> medfly, writing fmap is not more complicated (once you understand typeclasses).  it's just that you write it once for each Functor type
18:33:17 <theorbtwo> tensorpudding: Indeed, and lists are containers.
18:33:21 <tensorpudding> yes
18:33:26 <idnar> syntaxglitch: do you mean something like IntMap?
18:33:28 <theorbtwo> Why have both map and fmap?
18:33:30 <tensorpudding> although some functors are not really thought of as containers
18:33:47 <theorbtwo> Why does having the less useful version available at all help anything?
18:33:54 <sshc> if a, b, c, and d each uniquely determine v, why can't I write "a -> v, b -> v, c -> v, d -> v"?
18:33:56 <theorbtwo> ...much less giving it the friendlier name?
18:33:58 <idnar> (except that's still parametric)
18:34:00 <kmc> i don't think (Cont r) is usefully thought of as a container
18:34:08 <syntaxglitch> idnar, hm? Being parametric doesn't really have anything to do with conceptually being a "container"
18:34:10 <Twey> theorbtwo: That's the idea
18:34:22 <tensorpudding> IO is not a container either
18:34:33 <idnar> syntaxglitch: a container is a structure that holds values
18:34:36 <Twey> It provides a container-like interface
18:34:40 <medfly> :k IO
18:34:46 <kmc> (IO a) does not hold values of type a
18:34:46 <medfly> ugh
18:34:48 <Twey> It doesn't matter whether there's actually a value inside there
18:34:49 <temoto> * -> *
18:34:50 <jrockway> theorbtwo: why do we have both mappend and ++?
18:35:00 <idnar> syntaxglitch: if it's not parametric, then what does it hold?
18:35:02 <Twey> It doesn't, but you can pretend it does
18:35:03 <medfly> thanks temoto
18:35:13 <syntaxglitch> idnar, values of a predetermined type
18:35:16 <kmc> ByteString is a container of Word8
18:35:16 <monochrom> do { x ‚àà callCC (\k -> ...) ; liftIO (print x); ... }
18:35:27 <theorbtwo> jrockway: I have *no* idea.
18:35:35 <sshc> idnar: if you're dealing with only lists, why wouldn't you use just ++?
18:35:42 <tensorpudding> fmap applies a function on values that are in a structure, while keeping the structure in place
18:35:52 <kmc> i think these name issues are mostly historical
18:35:55 <Twey> jrockway: I figure they wrote ++ and map first, and only later realised that it's actually more general than that.
18:36:04 <syntaxglitch> kmc, most likely
18:36:04 <Twey> And didn't want to change the types.
18:36:09 <idnar> syntaxglitch: okay, but either you can just replace the predetermined type with a parameter, or the "container" is actually compositing the values in some fashion
18:36:11 <temoto> medfly, don't expect @undo, @pl kind of stuff, though. :)
18:36:11 <jrockway> exactly
18:36:14 <jrockway> historical reasons
18:36:18 <medfly> ;)_
18:36:19 <kmc> Twey, yeah, first thing you do when you implement a FPL is to write "map"
18:36:25 <jrockway> read the haskell prime RFCs, and you'll see that this will go away
18:36:26 <idnar> syntaxglitch: I mean, I wouldn't consider a bitfield a "container" for flags
18:36:30 <kmc> then later if your FPL has typeclasses (which most don't) you might generalize it
18:36:38 <Twey> Yeah
18:36:39 <theorbtwo> The problem with "historical reasons" is that you will never get a better language so long as you keep using that as an excuse.
18:36:41 <jrockway> but sometimes, not breaking every program ever written is better than calling fmap map
18:36:44 <tensorpudding> cons lists are the most ubiquitous FP data structure it seems
18:36:45 <Twey> theorbtwo: *nod*
18:36:45 <jrockway> IMHO anyway
18:36:56 <jrockway> theorbtwo: not every language redesign is like perl 6 :)
18:36:59 <idnar> sshc: was that meant for someone else?
18:37:00 <Twey> jrockway: But it wouldn't break anything
18:37:03 <jrockway> some have actually been released :)
18:37:05 <medfly> does map = fmap break anything, if you leave fmap in lplace
18:37:09 <Twey> No
18:37:11 <syntaxglitch> idnar, conceptually it makes perfect sense to think of it that way, though
18:37:11 <Twey> Nothing at all
18:37:12 <theorbtwo> Ah, but what Twey said.
18:37:18 <Twey> Oh
18:37:33 <Twey> You might invoke some MMRs in weird situations where someone's been relying on map to provide a concrete type
18:37:37 <idnar> syntaxglitch: only if you're using an abstract interface
18:37:45 <Twey> But it's certainly not going to ‚Äòbreak everything‚Äô
18:37:49 <theorbtwo> jrockway: Not every language is perl 5; haskell makes many things illegal, so that making them legal doesn't need to hurt.
18:38:06 <idnar> syntaxglitch: but okay, arguing semantics like this is a bit silly
18:38:15 <idnar> syntaxglitch: maybe I should just have said that my idea of a container is a functor :P
18:38:17 <sshc> jrockway: if you're dealing with only lists, why wouldn't you use just ++?
18:38:30 <medfly> MOOOAAAAR ALIASES
18:38:41 <jrockway> if you're dealing with arbitrary monoids, why call it `mappend`?
18:38:44 <jrockway> anyway, i personally don't care
18:38:46 <medfly> we should write mmap for Maybe too!
18:38:50 <jrockway> i was just throwing in another example
18:38:52 <tensorpudding> haskell is a dictatorship of the academics, in transition to a typeclassless society
18:38:58 <jrockway> i call it <$> when i do it to a list
18:39:15 <Twey> medfly: Don't forget iomap ;)
18:39:17 <jrockway> remove map and fmap and i doubt i would even notice ;)
18:39:22 <kmc> tensorpudding, haha
18:39:30 <syntaxglitch> Sometimes I get tempted to just go rewrite large sections of the standard libraries, rename things and rearrange type classes, until I'm happy with it
18:39:40 <idnar> jrockway: assuming someone fixes the definition of <$> :P
18:39:53 <Twey> syntaxglitch: When I feel like that, I lurk in #alt-stdlib until I feel better
18:39:54 <jrockway> what's wrong with the definition
18:39:57 <idnar> syntaxglitch: you can call the result Haskell 3000
18:40:06 <medfly> heh
18:40:07 <idnar> jrockway: <$> = fmap isn't going to work very well without fmap
18:40:15 <jrockway> LOL
18:40:18 <Twey> Heh
18:40:22 <jrockway> wow, you mean it's not magical?
18:40:28 <jrockway> :)
18:40:29 <syntaxglitch> just define fmap = <$>
18:40:32 <syntaxglitch> that should fix it, right?
18:40:33 <medfly> jrockway, who would have thought
18:40:33 <idnar> haha
18:40:38 * Twey chuckles.
18:40:38 <medfly> heh
18:40:54 <idnar> syntaxglitch: then write a tool called 98to3 that pretends to convert Haskell '98 programs to Haskell 3000 but doesn't really work very well
18:41:07 <jrockway> haha
18:41:10 <temoto> 10to3
18:41:15 <idnar> syntaxglitch: and then tell everyone they're being stubborn and silly when they refuse to stop using Haskell 98
18:41:22 <syntaxglitch> idnar, that sounds like too much effort
18:41:31 <jrockway> i don't use haskell 98
18:41:34 <temoto> The name would even make sense for binary first number.
18:41:41 <syntaxglitch> idnar, also I suspect you're referring to something that I'm not familiar with
18:41:41 <idnar> syntaxglitch: it does, doesn't it?!
18:41:43 <jrockway> at least, i assume that when i load 5 GHC extensions, i'm not using haskell 98 anymore :)
18:41:55 <idnar> syntaxglitch: heh
18:42:01 <sshc> if both a and b together uniquely determine c and d, how do I Write this?
18:42:07 <monochrom> module Haskell98to3000(main) where main = putStrLn "why don't you just give up"
18:42:08 <idnar> syntaxglitch: sorry, I'm just being bitter and twisted
18:42:19 <Twey> temoto: More sense for a trinary
18:42:22 <idnar> syntaxglitch: in Python-land, there used to be this sort of running joke
18:42:28 <syntaxglitch> ah
18:42:44 <syntaxglitch> I haven't really kept up with Python stuff much
18:42:44 <idnar> syntaxglitch: someone would propose some change that was too drasticly backwards-incompatible, and people would say "oh, we'll do that in Python 3000"
18:43:04 <idnar> syntaxglitch: then one day, GvR let everyone know that Python 3000 was actually going to be a real thing
18:43:24 <Twey> Haha
18:43:43 <Twey> I just figured everyone else was in on it from the start
18:43:53 <idnar> syntaxglitch: so now you have Python 3.x which is backwards incompatible in all sorts of stupid trivial ways, a tool called 2to3 which might be able to convert your code correctly if you're really lucky and have some virgin sacrifices on hand
18:43:56 <theorbtwo> You've got to love a numbering scheme that goes 1, 2, 3000.
18:44:00 <tensorpudding> they're merging unladen swallow into python aren't they?
18:44:02 <sshc> if both a and b together uniquely determine c and d, how do I Write this?
18:44:13 <sshc> "a b -> c d" or "a b -> c, a b -> d"?
18:44:23 <syntaxglitch> Twey, when a language is named for a comedy troupe it can be hard to tell what's a running joke and what's real
18:44:31 <Twey> Haha, yes
18:44:35 <idnar> syntaxglitch: and people like me who don't want to rewrite their Python code in a different language (Python 3), even (especially?) if it's really similar to Python, and has "Python" in the name
18:44:38 <monochrom> sshc: Both mean the same.
18:45:01 <tibbe> tensorpudding: there's a PEP for it, my guess you be "yes"
18:45:12 <soupdragon> sshc, is that a rewrite system?
18:45:16 <temoto> tensorpudding, they will merge US into python3.
18:45:29 <soupdragon> sshc, doh, it's fundeps I guess
18:45:39 <soupdragon> the second in that case
18:45:49 * syntaxglitch has kind of soured on dynamic typing, so is pretty ambivalent about Python these days
18:46:00 <eldragon> HiPE is faster than CPython, CPython is not a good idea
18:46:09 <idnar> I figure if I'm going to rewrite all of my code, and all of its dependencies, I might as well do it in a language that actually offers me some significant improvements (say, Haskell)
18:46:31 <syntaxglitch> idnar, I endorse that plan
18:46:40 <idnar> I don't think I've really soured on dynamic typing, I've just unsoured on static typing
18:46:45 <Twey> I second that endorsement
18:47:12 <idnar> 10 years of C++ really damaged my idea of static typing
18:47:14 <temoto> I 3000 that endorsement.
18:47:18 <jrockway> what is the advantage of dynamic typing?
18:47:20 <idnar> s/idea/opinion/
18:47:21 <sshc> can UndecidableInstances be used when th instance is never used?
18:47:23 * syntaxglitch remains very sour indeed on defective implementations of static typing 
18:47:23 <jrockway> i have not noticed any
18:47:24 <idnar> Haskell resuscitated it for me
18:47:32 <sshc> I need to use it to disambiguate () for a class
18:47:36 <jrockway> i program in dynamic langauges a lot, and i make every effort to pretend there is static typing
18:47:40 <idnar> jrockway: I think the main "advantage" is that it lets you write partially correct code
18:47:43 <jrockway> because data of the wrong type is just going to break my program
18:47:57 <jrockway> ah, it dies at 3am instead of when you are awake and coding it
18:47:59 <jrockway> i see :)
18:48:05 <theorbtwo> I think interred static typing and dynamic typing really attempt to solve the same problem in different ways.
18:48:10 <idnar> jrockway: pretty much ;)
18:48:17 * jrockway would *love* a perl with static typing
18:48:18 <idnar> jrockway: you can hack up something that's halfway correct, and it'll halfway run
18:48:19 <theorbtwo> Traditional static typing is just too much work.
18:48:25 <idnar> jrockway: as opposed to failing to type check, and not running at all
18:48:27 <syntaxglitch> jrockway, the advantage is that it lets you write wrong code easily, instead of having to add a lot of type annotations and go through contortions to write wrong code slowly like in Java
18:48:34 <temoto> jrockway, i use @check_type decorator in python.
18:48:34 <idnar> jrockway: PHP is kind of the ultimate progression in that direction
18:48:48 <idnar> jrockway: it's not just the type system that does that, it's absolutely everything
18:48:48 <jrockway> i just wonder what the motivation was when lwall and GvR were designing the language
18:49:02 <jrockway> surely, "it crashes unpredictably" was not the bullet point on their mental feature list :)
18:49:16 <idnar> for me, the great thing about dynamic typing in Python was that I didn't have to repeat the type of every value 50 times for the compiler's benefit
18:49:19 <tensorpudding> no language makes it hard for you to write bad code
18:49:26 <monochrom> dynamic typing is dependent typing minus proofs.
18:49:35 <syntaxglitch> jrockway, would you describe mainstream static typed languages as not "crashing unpredictably"?
18:49:45 <idnar> when someone introduced me to Haskell's type inference, my head exploded with awesomeness
18:49:50 <jrockway> i wouldn't call the mainstream statically typed languages statically typed
18:49:53 <theorbtwo> Also, in statically typed languages like C, it's simply too hard to get the type system to work for you.
18:49:56 <jrockway> "NullPointerException"
18:50:07 <jrockway> i guess haskell can be as bad though
18:50:09 <jrockway> error "foo"
18:50:10 <jrockway> undefined
18:50:14 <jrockway> pattern match failures
18:50:19 <idnar> yeah, in C/C++/Java, you spend all your time telling the compiler stuff it ought to already know, and then having it completely avoid to notice all the type errors you made anyway
18:50:21 <theorbtwo> Haskell has null pointer exceptions too, they just happen slightly less often.
18:50:23 <theorbtwo> _|_
18:50:40 <theorbtwo> (OK, lots less often.)
18:50:58 <jrockway> i'm surprised i don't see them more often, actually
18:51:05 <idnar> theorbtwo: the difference is that you can't easily test for _|_, so it's only used as an "exceptional" case
18:51:05 <syntaxglitch> see, that's another thing I'd change about Haskell, there's no excuse for pattern match failures being acceptable at compile-time
18:51:08 <jrockway> i would like a langauge without error or undefined
18:51:12 <idnar> theorbtwo: also, people know partial functions are bad, and try to avoid them
18:51:13 <medfly> tensorpudding, if you can't write good code, Haskell makes it hard for you to write ANY code.
18:51:13 <jrockway> pattern-match failures, i'm not so sure about
18:51:27 <idnar> in Java, people return null at the drop of a hat, so you just have to live with it everywhere
18:51:28 <jrockway> i have seen the haskell section on stackoverflow
18:51:37 <jrockway> haskell does not seem to deter people from writing bad code that compiles and runs :)
18:51:51 <idnar> whoa, there's a haskell section on stackoverflow?
18:51:52 <medfly> yeah, but someone too incompetent wouldn't be able to write Haskell.
18:51:55 <syntaxglitch> jrockway, I got a huge pile of rep on SO from telling someone not to use error for control flow logic :P
18:51:56 <EvanCarroll> whoppix: yea there is.
18:51:57 <MononcQc> medfly, I'd argue it's hard if you only knows ways to write bad codes in traditional languages
18:51:58 <idnar> maybe I should hang out there
18:52:04 <EvanCarroll> http://stackoverflow.com/questions/tagged/haskell
18:52:06 <jrockway> idnar: yeah
18:52:06 <MononcQc> give someone a shitty haskell education and they'll write shitty haskell
18:52:08 <medfly> MononcQc, I suppose.
18:52:09 <EvanCarroll> I just asked a question 5 minutes ago
18:52:14 <temoto> syntaxglitch, isn't there an extension like -XDemandFullPatterns?
18:52:16 <idnar> nobody ever answers my questions on stackoverflow, and I can't answer everyone's Java and C# and whatever questions
18:52:23 <theorbtwo> medfly: Oh, I remember writing some *really* bad code back in the early days of Pugs.
18:52:27 <medfly> but it's like a filter that protects us.
18:52:37 <idnar> although I probably can't answer anyone's Haskell questions either, but anyway
18:52:39 <Philonous> Real programmers write FORTRAN in any language
18:52:42 <theorbtwo> Actually, it goes back a bit to what we were talking about earlier.
18:52:44 <MononcQc> medfly, obscurity is a filter in itself. I see it a bit in Erlang too :)
18:52:45 <EvanCarroll> I get pretty good answers on SO
18:52:51 <medfly> yes it is
18:52:54 <EvanCarroll> http://stackoverflow.com/questions/2170341/why-does-haskell-stop-short-of-inferring-the-datatypes-typeclasses-in-the-functi
18:52:56 <jrockway> EvanCarroll: the ones you give, OTOH
18:53:00 <theorbtwo> The compiler kept being sure I wanted to use the [] monad.
18:53:15 <idnar> EvanCarroll: well, I'm exaggerating horribly
18:53:36 <idnar> EvanCarroll: I've only ever asked one question, but nobody else responded to it at all, until I posted an answer myself about a day later
18:53:40 * syntaxglitch is currenetly happy to be a ways up the "top haskell answerers in the last 30 days" list
18:53:46 <idnar> EvanCarroll: http://stackoverflow.com/questions/705463/workaround-for-ssl-bug
18:53:47 <EvanCarroll> jrockway: ?
18:53:49 <syntaxglitch> hooray for ego gratification :P
18:54:09 <EvanCarroll> jrockway: want to give an example?
18:54:14 <jrockway> nope
18:54:46 <syntaxglitch> temoto, there's a compiler flag for inexhaustive patterns, which ought to be enabled by default
18:54:54 <EvanCarroll> k, I take criticism, just pvmsg if you want to discus one of them
18:55:41 <idnar> syntaxglitch: that would be http://stackoverflow.com/questions/2156569/skipping-exceptions-when-using-map-in-haskell I guess?
18:55:56 <syntaxglitch> idnar, yes
18:56:24 <temoto> syntaxglitch, agreed.
18:57:57 <syntaxglitch> idnar, that question was particularly egregious, I mean, using error due to being too lazy to handle unexpected input is bad enough, but using it for something that's actually expected to occur?
18:58:28 <Philonous> syntaxglitch: Expection handling is a common anti pattern
18:58:40 <jrockway> i don't think that would be idiomatic in any language
18:58:59 <theorbtwo> Exception handling is the first big thing that put me off of real world haskell.
18:58:59 <jrockway> people do misuse exceptions, but that is not a common misuse :)
18:59:14 <EvanCarroll> there was a really good community wiki on exceptions vs assertions
18:59:15 <jrockway> in what way?
18:59:19 <EvanCarroll> on SO
18:59:19 <idnar> jrockway: in Python or Java, I suppose you might use None or null or whatever
18:59:33 <idnar> jrockway: I think he just mistakenly translated that to bottom in Haskell, instead of Nothing
18:59:34 <jrockway> yup, which is what you'd do in haskell too
18:59:44 <jrockway> yeah
19:00:22 <syntaxglitch> the Haskell in that question isn't like exceptions in Java or whatever, it'd be more like forking a new process to run a loop and signaling that the loop was done by dividing by zero
19:00:46 <jrockway> don't give anyone any ideas by saying something like that :)
19:01:08 <idnar> hahaha
19:01:08 <theorbtwo> The problem with using Nothing as your error value is that you have to keep handling it.
19:01:14 <MononcQc> that is the whole concept behind Erlang ;)
19:01:16 <idnar> syntaxglitch: that puts me in mind of quantum bogosort
19:01:25 <jrockway> theorbtwo: where "you" is a combinator
19:01:28 <theorbtwo> Unlike exceptions in other languages, it doesn't automatically bubble outward until handled.
19:01:42 <syntaxglitch> theorbtwo, that's where Maybe being a monad comes in handy
19:01:51 <jrockway> exactly
19:01:55 <idnar> theorbtwo: lifting is a lot easier in Haskell, though
19:02:00 <jrockway> i often use a pattern like the Error monad in other languages
19:02:03 <theorbtwo> jrockway: Yeah.  You, the teacher, have to introduce monads before they realize how much error handling sucks without them.
19:02:09 <jrockway> if (Left){ stop doing stuff }
19:02:11 <glguy> theorbtwo: well, once you have decide what your error behavior should be, you can wrap that Maybe a producing function, lifting the error into your program as needed
19:02:22 <glguy> You don't have to manually handle it every time
19:02:28 <EvanCarroll> why is Left always the error?
19:02:30 <jrockway> (exceptions work poorly for asynchronous actions, IMHO)
19:02:31 <idnar> theorbtwo: if you take a look at Java's checked exceptions, you have a similar sort of phenomenon; except in Java, it's so incredibly painful to deal with them, that people often just hack around it instead of dealing with them properly
19:02:38 <syntaxglitch> Because leftness is sinister and, thus, evil
19:02:46 <jrockway> i just write "throws Exception" after every method declaration in Java
19:02:48 <syntaxglitch> Right is the right way to go.
19:02:51 <jrockway> "checked exceptions" indeed
19:02:55 <theorbtwo> Strange.  I normally see left as the usual and right as the error.
19:03:08 <jrockway> well, that's wrong :)
19:03:08 <theorbtwo> I want to list what I want to get back first in the declaration.
19:03:18 <idnar> jrockway: when I wrote Java code, I generally caught "checked" exceptions right away, and threw an unchecked exception instead
19:03:24 <syntaxglitch> theorbtwo, you can do that, but it's unidiomatic
19:03:30 <BMeph> EvanCarroll: For punning reasons - the "Right" answer is always the "right" answer. ;)
19:03:35 <glguy> Left ends up being the error because once you've applied 'a' to "Either a", you have something of kind *->* which makes sense for implementing things like Functor and Monad
19:03:37 <jrockway> and you will have to write your own Error monad implementation
19:03:39 <idnar> jrockway: I think basically ever checked exception in Java either wants to be a return value, or an unchecked exception
19:03:44 <idnar> *every
19:03:46 <jrockway> and MonadError doesn't work, etc.
19:03:50 <Twey> Because the alternative is a bit sinister
19:03:50 <theorbtwo> Hm.  I should double check Real World, and get one of you to complain in the comments, then.
19:04:09 <EvanCarroll> BMeph: ahha, I've never seen that before
19:04:23 <theorbtwo> That's *exactly* what got me in Real World Haskell.
19:04:33 <temoto> EvanCarroll, because errors are just not Right :)
19:05:04 <theorbtwo> I was sailing along well, and then a question asked me to implement conversion of "123" to 123.  Then it asked me to do that again, but returning Choice Int ErrorMessage.
19:05:21 <theorbtwo> There's no good way to do that without a monad to do your error handling.
19:05:26 * syntaxglitch likes Maybe, MonadError, etc. for propagating errors automatically--having "this can error" be part of the type signature is good when it's done right
19:05:32 <theorbtwo> ...and monads haven't been introduced yet.
19:05:41 <Twey> Yes there is
19:05:42 --- mode: ChanServ set +o glguy
19:05:50 --- mode: glguy set -q $~a
19:05:51 <jrockway> i think haskell could do without traditional exceptions, actually
19:05:57 <medfly> eheheh, "123" -> 123 sounds like PHP.
19:06:03 --- mode: monochrom set -o monochrom
19:06:29 <jrockway> i think RWH brings in monads too late
19:06:30 --- topic: set to '["Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]' by glguy
19:06:32 <theorbtwo> medfly: Er, it's a terribly common, and useful, thing to do in anything that takes input.
19:06:37 <jrockway> i blame the internet for the "monads are hard" meme
19:06:46 <medfly> meme
19:06:50 <Twey> maybe (ErrorMessage "ARGH!") (Right . fst) . listToMaybe
19:06:52 <syntaxglitch> jrockway, exceptions are fine for catastrophic errors
19:06:54 <Twey> Er
19:07:00 <Twey> maybe (Left $ ErrorMessage "ARGH!") (Right . fst) . listToMaybe
19:07:13 <jrockway> syntaxglitch: right, maybe 'error "This can't happen."'
19:07:20 <syntaxglitch> by which I mean errors where the only thing that makes sense is to log what happened, clean up if you can, and then die with dignity
19:07:22 --- mode: ChanServ set -o glguy
19:07:27 <jrockway> but openFile should return a Right Handle or a Left IOError
19:07:34 <jrockway> imho
19:07:39 <syntaxglitch> jrockway, agreed
19:07:49 <jrockway> i think there is a hackage module for that though
19:07:55 <jrockway> that makes error's liftIO do the conversion
19:07:56 <medfly> I like Maybe
19:07:59 <BMeph> Ah, PHP. The language made to, bacause Perl was "too wordy"... :D
19:08:04 <jrockway> i impelmented that myself and like it a lot :)
19:08:05 <syntaxglitch> exceptions should be reserved for things like "out of memory", "fatal runtime error", "computer on fire", &c.
19:08:07 <hzap> Control.Exception.try (openFile ...)?
19:08:18 <medfly> computer on fire
19:08:18 <MononcQc> PHP's a chainsaw
19:08:19 <medfly> printer
19:08:20 <medfly> :)
19:08:30 <jrockway> hzap: sure, a combinator is nice
19:08:40 <jrockway> but the language would be simplified without the concept, IMHO
19:08:57 <EvanCarroll> jrockway: how long have you been using haskell?
19:09:03 <monochrom> http://hackage.haskell.org/package/MonadCatchIO-mtl
19:09:04 <lambdac> Title: HackageDB: MonadCatchIO-mtl-0.2.0.0
19:09:04 <hzap> jrockway: it's hard to not have exceptions at all imo
19:09:09 <theorbtwo> BMeph: Funny, I see the php problem a lot in haskell: There's a lot of functions with slight variations in both names and meaning, without terribly much effort put into keeping the namespace clean by.
19:09:10 <temoto> All Go language IO is returning tuples (Error, a)
19:09:12 <Twey> I meant maybe (Left $ ErrorMessage "ARGH!") (Right . fst) . listToMaybe . reads
19:09:21 <Twey> Sorry
19:09:26 <syntaxglitch> theorbtwo, didn't we just have that conversation?
19:09:28 <Twey> Missed the most important part of that function‚Ä¶ :√æ
19:09:33 <theorbtwo> syntaxglitch: Yes.  Sorry.
19:09:35 <jrockway> EvanCarroll: a few years
19:09:43 <jrockway> i use it at work every day
19:10:06 <temoto> jrockway, have vacancies?
19:10:14 * syntaxglitch has only been tinkering with Haskell for about three months and is already cranky about a lot of stuff
19:10:20 <jrockway> sort of, but we are actually 99.8% perl and .2% haskell
19:10:28 <kmc> you can do ´String -> Either ErrorMessage Intª with reads and straight pattern matching
19:10:33 <kmc> you don't have to notice that Either is a monad
19:10:38 <Twey> jrockway: I'm terribly sorry
19:10:45 <jrockway> no, perl is an excellent language
19:10:50 <jrockway> i like it a lot
19:10:53 <kmc> the point of noticing that is to use ´doª and generalized monad functions in order to make your code cleaner
19:13:18 <temoto> jrockway, do you use haskell to generate perl?
19:13:35 <jrockway> no
19:13:49 <syntaxglitch> perl 6 is going to be the language of the future, it has support for quantum computation already
19:13:52 <jrockway> i use it for stuff that needs to run on windows, or that needs to use foreign libraries
19:13:56 <theorbtwo> Generating perl is generally a bad idea.
19:14:02 <jrockway> because i'm sure not going to use C or C++ :)
19:14:13 <jrockway> my goal is to move more in the haskell direction, though
19:14:20 <jrockway> we do a lot of ETL stuff, and it runs too slowly
19:14:25 <jrockway> because perl is a terrible language for ETL stuff
19:14:32 <theorbtwo> ETL?
19:14:39 <jrockway> (it's great for large apps, though, contrary to popular belief)
19:14:44 <jrockway> extract/transform/load
19:14:47 <jrockway> data munging, basically
19:14:52 <theorbtwo> Oh.
19:15:09 <temoto> mining?
19:15:17 <syntaxglitch> I thought data munging was one of perl's strengths? Or at least string munging
19:15:31 <jrockway> libraries is perl's strength
19:15:37 * syntaxglitch hasn't touched perl in ages
19:15:48 <jrockway> if you just need to take the second field of a CSV and multiply by 42, then you don't get much in perl that you wouldn't have in haskell
19:15:55 <jrockway> except that it runs slowly
19:16:02 <jrockway> and that type errors are silent
19:16:04 <syntaxglitch> heh
19:16:10 <jrockway> (that is my biggest concern; speed does not really bother me)
19:16:35 <syntaxglitch> I bet hackage seems pretty pitiful to you, huh :P
19:16:55 <jrockway> a little
19:16:57 <tensorpudding> hackage is pretty small compared to cpan
19:16:58 <jrockway> but it's served me pretty well
19:17:00 <temoto> A friend of mine tried to parse JSON in haskell when json library didn't have ByteString support yet. He was concerned about speed pretty much.
19:17:11 <syntaxglitch> I don't think anything really compares to cpan
19:17:21 <ido> jrockway: interesting to see you around these parts, and hello again from #catalyst :)
19:17:28 <jrockway> yeah :)
19:17:34 <jrockway> some apps need cpan, some don't
19:17:37 <jrockway> for apps that need cpan, i use perl
19:17:38 <tensorpudding> i wonder why perl seems to be dying
19:17:46 <tensorpudding> or at least, declining a lot
19:17:47 <jrockway> for apps that don't, i use haskell
19:18:02 <jrockway> it's not cool
19:18:05 <jrockway> it's been around forever
19:18:14 <monochrom> python and php stole some perl users. conservation of programmer mass.
19:18:17 <jrockway> someone wrote bad perl 10 years ago and blame perl rather than their inexperience with programming
19:18:24 <jrockway> etc.
19:18:33 <jrockway> in 10 years, we will all hear how sucky ruby and python are
19:18:34 <syntaxglitch> and Perl Forever or whatever the next version is has been taking a while
19:18:42 <jrockway> yeah
19:18:46 <jrockway> shouldn't have called that perl
19:18:48 <syntaxglitch> so there's not even "oh look new version!" to get attention
19:18:53 <ido> jrockway: perl makes it easier to write bad perl than, say, smlnj or ocaml...
19:18:56 <medfly> I think I heard about ruby being sucky already
19:18:57 <jrockway> because perl5 has made amazing strides in the last few years
19:19:00 <ido> well, smlnj anyhow
19:19:10 <jrockway> but everyone outside of the community thinks that perl6 is the only new perl-related thing
19:19:15 <jrockway> and dismiss perl5 as dead
19:19:15 <ido> though it's really hard to write bad perl in smlnj :P
19:19:32 <ido> also you have a PM jrockway
19:19:37 <theorbtwo> There's been plenty of new versions, but so much of the innovation is in cpan that looking at the changelogs of perl 5 isn't terribly awe inspiring.
19:19:38 <jrockway> PM?
19:19:41 <ido> privmsg
19:19:44 <jrockway> ah
19:19:52 <tensorpudding> perl has a bad rap for being hackish
19:20:08 <sshc> tensorpudding: rap?
19:20:18 <tensorpudding> rep, sorry
19:20:33 <BMeph> I thought most folks only thought of Moose as the only new perl-related thing? :)
19:20:48 <theorbtwo> Every language has bad elements, but perl's seem to get entirely too much press.
19:21:02 <tensorpudding> maybe it's just beecause people saw way too many hacked up perl scripts
19:21:15 <theorbtwo> Haskell's reputation is that it is hard, and people who understand it must be super-intelegent.
19:21:22 <jrockway> Moose is a pretty important thing, though
19:21:24 <syntaxglitch> perl's bad elements tend to be obvious relative to other languages, I think
19:21:27 <tensorpudding> its massive popularity as the duct-tape language collapsed
19:21:33 <jrockway> i had a CL kick for a while and gave up because CLOS is so limiting compared to Moose
19:21:34 <MononcQc> I think Haskell looks a lot like perl with all the operators :B
19:21:38 * MononcQc is trollish
19:21:43 <theorbtwo> tensorpudding: That's mostly becuase you aren't a perl programmer.
19:21:44 <jrockway> it feels like writing OO-programs in assmebler
19:21:51 <jrockway> (then there's java and .net, which i won't even talk about :)
19:21:58 <theorbtwo> It's a lot easier to see other people's flaws then your own.
19:22:13 * syntaxglitch always figured that Haskell's overuse of gratuitous operators was due to APL envy
19:22:19 <theorbtwo> (Partly because what other people consider flaws, you know the good side of.)
19:22:42 <syntaxglitch> since APL is one of the few languages that can claim to be more intimidating than Haskell, monads or no
19:22:57 <theorbtwo> Brainfuck!
19:23:22 <tensorpudding> esolang's don't count
19:24:03 <dolio> APL isn't that hard, is it? Just hard to type.
19:24:04 <lambdac> dolio: You have 1 new message. '/msg lambdac @messages' to read it.
19:24:11 <dolio> Oh good.
19:24:15 <dolio> @messages
19:24:15 <lambdac> vixey said 1y 4m 21d 15h 1m 36s ago: \neg actually also works I just noticed
19:24:29 <tensorpudding> ...
19:24:29 <jrockway> 1y!?
19:24:35 <tensorpudding> hahaha
19:24:46 <syntaxglitch> dolio, I think APL's opacity goes a little beyond just the symbols, though those don't help
19:24:50 <dolio> Who's running lambdac?
19:25:12 <monochrom> dibblego runs lambdac because lambdabot is away
19:25:18 <Gracenotes> eek
19:25:22 <jrockway> i'm actually kind of curious what people outside of the perl community think about perl
19:25:24 <dolio> Well, it's also a concatenative language for array programming, so I guess that's a bit weird, too.
19:25:31 <jrockway> all i can usually get out of people is "it's slow" and "it's line noise"
19:25:35 <Gracenotes> I must stop this flaw in ChatZilla of listing every nickname in scope
19:25:36 <jrockway> both of which are totally meaningless :)
19:25:55 <monochrom> I think perl is too much @#$%
19:26:11 <tensorpudding> perl and ruby are kinda similar looking sometimes
19:26:27 <hzap> i try to learn perl but couldn't find a good website for it for some reason
19:26:35 <monochrom> And hash tables pretending to be data structures.
19:26:41 <tensorpudding> most people don't think that ruby syntax is line noise though
19:27:00 <MononcQc> hzap, /msg mst, he's likely to be able to help you. He's behind the perl iron man
19:27:16 <syntaxglitch> tensorpudding, that's because ruby is an unholy amalgamation of perl and smalltalk at heart
19:27:21 <jrockway> yeah, coherent documentation for "modern perl" is somewhat difficult to find
19:27:28 <theorbtwo> hzap: Try perlmonks.org
19:27:31 <jrockway> we keep adding new stuff faster than anyone can write about it all
19:27:39 <Zao> Ooh nice. -XOverloadedStrings.
19:27:40 <syntaxglitch> there's a lot of perlisms in ruby but they don't tend to be as popular
19:27:45 <Zao> Makes ByteString fappage much nicer.
19:27:55 <theorbtwo> It's a forum / community site, not a single tutorial, but it's good people.
19:28:10 <hzap> oh thanks, i'll probably look at it when i start to want to look at perl again :)
19:29:13 <jrockway> btw, random cabal question
19:29:25 <jrockway> can i make an executable depend on a library "defined" in the same file?
19:31:19 <syntaxglitch> on the earlier subject of hackage being weaksauce compared to cpan, I wonder what kind of stuff hackage is most in need of
19:31:46 <jrockway> someone was asking earlier "how can i do a s/foo/bar/-style regex"
19:31:53 <jrockway> apparently there is no code for that anywhere
19:32:15 <jrockway> that is probably offputting to people just starting with haskell
19:32:23 <jrockway> (although i have not actually ever needed that, oddly enough)
19:32:41 <syntaxglitch> this is haskell, syntactic validity of regexes should be statically checked
19:32:49 <jrockway> people just need to pull generic parts out of their apps and put them on hackagedb basically
19:33:09 <jrockway> that's how the cpan got to be big
19:33:18 <jrockway> another person finds something interesting, sends patches, etc.
19:33:26 <jrockway> eventually there is a generic solution that pleases everyone
19:33:37 <jrockway> i think haskell people might be too worried about getting it perfect on the first try
19:33:42 <jrockway> which just doesn't happen in the real world
19:33:45 <syntaxglitch> or multiple generic solutions that each please some overlapping subset of everyone
19:33:53 <wnoise> I thought John Meacham had some code to do regexes, overloading on return type.
19:33:57 <wnoise> http://markmail.org/message/edtyo5v3xat2ipz7
19:33:57 <lambdac> Title: [Haskell] regular expression syntax - perl ain't got nothin on haskell - John Me ...
19:34:10 <jrockway> yeah
19:34:15 <jrockway> i was just thinking about the Text.CSV module
19:34:21 <jrockway> it is really inadequate for real use
19:34:33 <jrockway> but people just wrote their own and uploaded them, instead of patching the existing implementation
19:35:02 <wnoise> > [Either String String] - list of matching and nonmatching strings, if concated, the original string results. Left = notmatching, Right = matching.
19:35:04 <lambdac>   <no location info>: parse error on input `of'
19:35:44 <wnoise> So, anyways, swapping out matches is pretty easy with that interface.
19:35:47 <Zao> jrockway: T'was I who asked, and I ended up using matches to verify the format of the line, split on suitable things and glue stuff back.
19:36:23 <jrockway> wnoise: yeah
19:36:27 <Zao> Or at least that's the plan.
19:36:29 <jrockway> but cutting-and-pasting code from blogs is a pain
19:36:35 <wnoise> (what is the convention for quoting from elsewhere, if lambdabot eats >)
19:36:45 <jrockway> where do you put the file? how do you track updates? where do you send patches? etc.
19:37:01 <jrockway> wnoise: quotes?
19:37:06 * syntaxglitch also notes that a fair amount of stuff on hackage is lacking in the documentation department
19:37:07 <jrockway> "here is the text"
19:37:08 <wnoise> http://repetae.net/computer/haskell/JRegex/
19:37:10 <lambdac> Title: JRegex
19:37:16 <jrockway> syntaxglitch: glad you mentioned that
19:37:30 <jrockway> it would be nice if the haddock auto-generated docs were shown even if there were no "docstrings" in the file
19:37:40 <jrockway> a list of functions and their types is better than nothing
19:37:42 <syntaxglitch> type signatures go a fair way, but a few examples of use or something would be nice
19:37:49 <jrockway> yes
19:37:57 <syntaxglitch> if I already know what a library does the signatures are 99% of what I need
19:37:57 <jrockway> examples of use are essential and very lacking
19:38:01 <jrockway> (text.regex.base, for example)
19:38:16 <jrockway> how do i match "ar" against "foobar"?
19:38:19 <syntaxglitch> but sometimes I'll see something that I suspect would be useful, but I have no idea how it works
19:38:20 <jrockway> i don't think the docs tell you
19:38:35 <jrockway> there are like 3487 type classes that you need to understand to realize you can just say "foobar" =~ "ar" :)
19:39:06 <kmc> yes, i think the regex library has a very strange interface
19:39:08 <kmc> it's not typical
19:39:54 <idnar> do you need -XGADTs to use GADT syntax?
19:40:16 <kmc> think so
19:40:26 <syntaxglitch> idnar, just write what you want and give it to GHC
19:40:41 <syntaxglitch> it's pretty good about telling you what extension you wanted
19:40:48 <idnar> syntaxglitch: I was trying to figure out whether I screwed up what I wanted or not
19:40:50 <syntaxglitch> vs. just falling over with an error
19:41:03 <idnar> because I was defining a "normal" data type
19:43:07 <Zao> I was rather confused by the regex errors until I realized that :: (a, b, c, [B.ByteString]) is not an instance of whatever is used.
19:43:38 <orgullocachanill> It is time to put those Haitian jigaboos in their place!  No matter how many times the civilized world donates money, opens schools, rebuilds their nation, and holds their little monkey paws, the damn niggers can never get it right.  They never will!  The same goes for New Orleans!  Cancun in Mexico suffered few fatalities after their major hurricane, and the rebuilding is already completed.  What have the niggers in New Orleans done? If you
19:43:40 <orgullocachanill> are sick of this, join Chimpout Forum! http://www.chimpout.com/forum
19:43:52 <jrockway> ugh
19:43:53 * medfly shrugs
19:43:54 <jrockway> kill.
19:43:57 <kmc> @where ops
19:43:57 <lambdac> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
19:43:58 <medfly> now I can't @where ops :(
19:44:02 <medfly> oh, it's possible...
19:44:06 <CcSsNET> doesnt this spam crap ever end ^
19:44:08 --- mode: ChanServ set +o xerox
19:44:14 <kmc> @run fix ((0:) . scanl (+) 1)
19:44:15 <lambdac>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
19:44:16 <jrockway> the new ircd was supposed to solve the problem :)
19:44:24 --- mode: xerox set +b *!*@64.134.233.103
19:44:24 <jrockway> apparently not
19:44:25 <medfly> well, it's just a normal user that advertises something
19:44:27 <kmc> not sure it was supposed to solve this problem
19:44:35 <kmc> this problem is that people go into channels and say dumb shit
19:44:36 --- kick: orgullocachanill was kicked by xerox (orgullocachanill)
19:44:42 <kmc> that's a basic feature of IRC
19:44:44 <jrockway> yeah
19:44:54 <Zao> medfly: I've seen it on gimpnet too.
19:44:56 <jrockway> but the spam from last week was actually web browsers making HTTP requests to the IRC port
19:45:01 <jrockway> apparently that is possible...
19:45:09 <jrockway> (no acking of messages was required)
19:45:15 <medfly> :)
19:45:24 <syntaxglitch> kmc, if you generalize "channels" slightly it's more a basic feature of the internet
19:45:34 <kmc> yeah
19:45:48 <kmc> charging a nominal fee to register an account does cut down spam dramatically
19:45:48 <Zao> jrockway: You can always send the ack before the server messages arrive to you.
19:46:00 <Zao> jrockway: It's just queued on the server until it expects a response.
19:46:03 <jrockway> but the ack should be something like, give me the md5sum of this random number
19:46:08 <jrockway> an http client is not going to be able to do that
19:46:13 <jrockway> or maybe... who knows
19:46:19 <Zao> The weird bit was that hyperion accepted garbage commands.
19:46:26 <jrockway> i think the http headers should confuse the irc server
19:46:26 <jrockway> yeah
19:46:35 <jrockway> too tolerant :)
19:46:40 <Zao> I guess it's probably to handle poor clients.
19:46:44 <jrockway> yeah
19:46:48 <kmc> the new ircd rejects any client that starts off by saying "POST"
19:46:52 <Zao> "be strict in what you produce, lenient in what you accept"
19:46:57 <jrockway> yeah
19:47:10 <jrockway> PUT / HTTP/1.1
19:47:14 <jrockway> MADEUPMETHOD / HTTP/1.1
19:47:18 <jrockway> that requires javascript though
19:48:21 <syntaxglitch> Zao, that principle made more sense before the net became popular enough to attract a lot of irresponsible or malicious people, unfortunately
19:49:14 <medfly> IRC is popular?
19:49:15 <medfly> ;)
19:49:53 <djahandarie> Haskell ircd?
19:50:15 <Zao> djahandarie: "we're sorry for the last split. the impossible just happened"
19:50:26 <monochrom> ha
19:50:29 <ido> I hear "IRC: It's where hackers go when they don't want to be seen." - NUMB3RS (http://www.youtube.com/watch?v=O2rGTXHvPCQ )
19:50:30 <lambdac> Title: YouTube - Numb3rs' description of IRC
19:51:26 * syntaxglitch uses Haskell to implement a lazy ircd, it only relays messages when someone actually wants to know what you said
19:51:37 <monochrom> that is indeed really old code. to include the url unmangler.
19:51:55 <monochrom> your only hope is this:
19:52:03 <monochrom> http://www.vex.net/~trebla/fix.xhtml
19:52:12 <Twey> syntaxglitch: ‚ÄòEmail‚Äô?  ;)
19:52:28 <monochrom> The old code does not understand mere xhtml
19:54:28 <Veinor> what exactly does libtinfo do?
19:54:33 * syntaxglitch wonders what the current state of haskell-oriented editors is
19:54:52 <Zao> Veinor: Smells like some kind of terminal info thingie.
20:01:09 <nus> @where yi
20:01:13 <lambdac> http://www.cse.unsw.edu.au/~dons/yi.html
20:01:51 <syntaxglitch> hm, sounds interesting
20:05:02 <djahandarie> Probably would make more sense to link to http://haskell.org/haskellwiki/Yi
20:05:04 <lambdac> Title: Yi - HaskellWiki
20:05:10 * djahandarie doesn't know how to work lambdac 
20:06:02 <aavogt> @where+ yi http://haskell.org/haskellwiki/Yi
20:06:02 <lambdac> Done.
20:06:24 <aavogt> @help
20:06:25 <lambdac> help <command>. Ask for help for <command>. Try 'list' for all commands
20:06:32 <aavogt> @list
20:06:32 <lambdac> http://code.haskell.org/lambdabot/COMMANDS
20:06:48 <djahandarie> I see.
20:07:49 <smorg> Why is it lambdac?
20:08:47 <djahandarie> Why do I typically get a ton of warnings whenever I use Cabal to install stuff by the way? Usually relating to "Defined but not used" or "pattern matching not exhaustive"
20:09:26 <monochrom> lambdac is a temporary measure
20:09:34 <smorg> seven broke it or something
20:09:46 <kmc> @quote
20:09:49 <lambdac> numerodix says: tbh: people who do haskell on their own initiative kinda creep me out :)
20:09:58 <nus> @help fact
20:10:01 <lambdac> fact <fact>, Retrieve a fact from the database
20:10:02 <monochrom> @quote monochrom
20:10:10 <lambdac> monochrom says: The problem is that bad programmers will assess tutorials for good programmers as "ivory tower", and moreover bad programmers are the vocal majority.  It gets you bad press.
20:10:28 <kmc> @join #haskell-blah
20:10:37 <lambdac> Not enough privileges
20:11:06 <smorg> @join #gentoo-haskell
20:11:06 <lambdac> Not enough privileges
20:12:03 <soupdragon> @join Not enough privileges
20:12:10 <lambdac> Not enough privileges
20:12:53 <Zao> djahandarie: Library authors not caring much or being able to quench all warnings.
20:13:05 <Zao> djahandarie: Or changes in warning behaviour in newer/older compilers.
20:13:47 <nus> fact vs where: TMTOWTDI?
20:29:05 <retroj> hi.  is there any "do nothing" IO action apart from say, (putStr "") that I can use when I need to return from an IO function without performing any action?
20:29:37 <aavogt> retroj: return ()
20:29:39 <BMeph> retroj: return ()
20:29:43 <retroj> thanks!
20:29:47 <BMeph> Jinx!
20:29:53 <Philonous> Return Nothing
20:29:57 <Philonous> return*
20:29:58 * BMeph wins!
20:30:09 <medfly> BMeph, I see aavogt as having beaten you
20:30:13 <medfly> :-)
20:30:42 <Zao> pure () ! :P
20:30:54 <BMeph> :˛
20:31:11 <Philonous> point ()
20:31:37 <Zao> choose p a b = if p then a else b -- anything more built-in?
20:31:58 <Axman6> if', notn sure if it's in data.bool
20:32:07 <aavogt> pure unit -- haskell gangsta?
20:33:23 * soupdragon whishes if didn't exist... then I could define it myself
20:34:02 <soupdragon> although I would call it bool, to line up with maybe and either and foldr.. ahem
20:34:26 <idnar> bool has a different argument order
20:34:59 <idnar> if' :: Bool -> a -> a vs. bool :: a -> a -> Bool
20:36:07 <BMeph> Yeah, bool would be a -> a -> Bool -> a
20:36:07 * Cale hates that @where ops thing :)
20:36:46 <medfly> why?
20:38:26 <idnar> er, whoops, missed a -> a
20:38:37 <idnar> but you get the idea
20:40:31 <idnar> Zao, kmc, jrockway: by the way, a common mechanism to block HTTP POST faking IRC and such is to send a PING from a randomly-generated origin during connect, and not proceed until you get a PONG
20:41:04 <idnar> as in PING :5da57ff3 or whatever
20:41:16 <idnar> so you can't connect without being interactive
20:41:39 <medfly> hearing freenode may have done that may explain my connection problems :-D
20:42:39 <mreh_> I've been programming for 10 hours straight!
20:42:46 <mreh_> i'm doing to die
20:42:53 <medfly> why?
20:42:58 <absentia> after only 10 hrs?
20:42:59 * medfly gives mreh_ water
20:43:00 <absentia> wuss.
20:43:27 <absentia> can you even pass a cs101 with only a 10hr run?  bah.  kids these days.
20:43:38 <mreh_> I have abstracted myself from reality
20:43:58 <absentia> back in my day, it took 10 hrs just for the lisp garbage collector to run!
20:44:01 <monochrom> I can. I did.
20:45:32 <mreh_> I just programmed things like swapping values and generating permutations with trees, why did I bother?
20:45:59 <monochrom> Some group project of some 1st-year course made me work for 10 hours. But cs101 per se? Maybe just 3 hours per assignment, the beginning ones 2 hours. And yes, I did wonder why it was so hard to everyone else.
20:46:09 <mreh_> oleg did it with trees, good for an exercise, but in all fairness arrays seem to be a better idea for practicality
20:46:19 <mreh_> monochrom: heh
20:46:43 <monochrom> Most other people, 10 hours and still obviously buggy. Me, 3 hours and perfect, absolutely no bugs.
20:46:47 <Cale> We should find a way to use the tags on people's garbage bags as a program heap. Then the garbage collectors can do our garbage collection.
20:46:48 <mreh_> I worked about 30hrs on a group project once, the group consisted of me and 5 other non-programmers
20:46:52 <medfly> I love consecutive productivity.
20:47:00 <pikhq> monochrom: I started college after being decently competent at C...
20:47:15 <syntaxglitch> Cale: Garbage collection-level metaprogramming, I like it
20:47:21 <pikhq> I seem to recall making a couple of the assignments harder than they had to be due to boredom.
20:47:28 <monochrom> I had BASIC only before cs101.
20:47:30 <medfly> I spent a while on an intro programming course, and I didn't even take it.
20:47:51 <monochrom> And I embraced recursion the first time cs101 showed it.
20:47:58 <Axman6> monochrom: i've been the same :)
20:48:03 <absentia> I make everything more difficult than it should be...  character flaw, I think.
20:48:47 <soupdragon> monochrom :)))
20:49:03 <pikhq> monochrom: Mmm, tail recursive C.
20:49:04 <pikhq> :P
20:49:43 <monochrom> I planned before I went to the computer. You could say, I divided my program-to-be into sensible parts, part-to-part boundaries and interfaces well-defined.
20:50:52 <mreh_> absentia: you probably like to hold off for a better solution like me, rather than just GET THINGS DONE!
20:50:54 <absentia> tair recursive C = iteratio w/ accumulation?
20:51:05 <soupdragon> I (think I) helped someone understand structural induction for proving recursive programs satisfy some property today
20:51:09 <pikhq> absentia: ... Tail recursion. In C.
20:51:14 <pikhq> That's about it.
20:51:33 <medfly> somehow what I have seen in that intro course doesn't sound like what you say it is. it was just "learn how to use C", mostly, with a bit of introducing some programmign concepts in the assignments
20:51:34 <pikhq> Only sane in GNU C (which does TCO).
20:51:40 <medfly> TCO?
20:51:49 <pikhq> Tail-call optimisation.
20:51:57 <absentia> mreh:  I don't know what my problem is.  I can't just make things simple.  I see it trivially.. but I implement it insanely.
20:53:25 <Twey> ‚ÄòHi, my name is Twey, and I'm an abstraction addict‚Äô
20:53:36 <kamatsu> 'Hi Twey.'
20:53:48 <Philonous1> absentia: Yeah, there is always yet another abstraction to find
20:53:54 <medfly> 'Hi, my name is nick, and I'm an abstraction addict'
20:53:55 <absentia> ya
20:54:09 <mreh_> what kind of name is "Twey"?
20:54:09 <absentia> architecture astronaut
20:54:23 <dibblego> @kind Twey
20:54:25 <lambdac> Not in scope: type constructor or class `Twey'
20:54:25 <Alpounet> mreh_, an abstract one ?
20:54:42 <pikhq> @pl \x->"Hi, my name is "++x++", and I'm an abstraction addict."
20:54:43 <lambdac> ("Hi, my name is " ++) . (++ ", and I'm an abstraction addict.")
20:54:50 <medfly> hehehe
20:54:52 <pikhq> Oh, sure. Obvious.
20:54:56 <medfly> good :-)
20:55:59 <Twey> Hehe
20:56:00 <absentia> ha.  my daughter, Emma, just woke up a little...
20:56:05 <Philonous1> absentia: I tend to replace every concrete data stucture with a set of class constraints. If there are no classes, I make my own. But honestly I think We need some sort of meta-language to write algorithms in.
20:57:03 <monochrom> use squiggol
20:57:21 <soupdragon> I wonder if it would be optimal to teach programming and formal proof simultaneously
20:57:33 <medfly> no
20:58:28 <medfly> not everyone that studies programming does it as part of a degree in CS.
20:58:34 <monochrom> make sure you have an IDE for formal proofs if you do that.
20:58:36 <soupdragon> there is a very tight relation between data definitions, simple recursive functions on them and simple inductive proofs about them and having these 3 ways to look at it might help
20:58:44 <absentia> I studied programming and I do not have a degree in CS.
20:59:12 <absentia> where I studied, though, CS was trying to make you a mathematician who could program.  I found that very lame.
20:59:25 <medfly> hehe
20:59:36 <medfly> isn't that the usual case?
20:59:37 <absentia> Fine.. gimme Big-O theory.. but end it there.
20:59:41 <soupdragon> what is lame about that?
20:59:53 <monochrom> Big-O is lame.
20:59:57 * syntaxglitch really thinks "computer science" and "software engineering" need to separated
21:00:01 <kamatsu> lambda calculus is certainly also useful
21:00:03 <Veinor> @pl (\y -> x `mod` y == 0)
21:00:06 <lambdac> flip ((==) . (x `mod`)) 0
21:00:07 <lambdac> optimization suspended, use @pl-resume to continue.
21:00:10 <QtPlatypus> monochrom: Why do you feel that?
21:00:18 <emma> absentia: hehe :)
21:00:20 <absentia> well, one size doesn't fit all.  I have never needed any of the math that I took. really... for programming.  the one time I was writing my 3d widgets, I looked up some algorithms.  bfd.
21:00:26 <medfly> @pl-resume
21:00:33 <lambdac> flip ((==) . (x `mod`)) 0
21:00:33 <lambdac> optimization suspended, use @pl-resume to continue.
21:00:41 <medfly> ??
21:00:54 <absentia> mono:  it's he principle ...
21:00:55 <kamatsu> absentia: discrete maths has been helpful to me
21:00:57 <soupdragon> absentia, ah well teaching irrelevant usesless stuff is quite pointless, I could not disagree with that
21:01:00 <monochrom> From Big-O all you can get is how long the program runs. You know nothing about what answer it gives.
21:01:13 <absentia> answers are irrelevant.
21:01:37 <absentia> ha! mr_daniel just appeared.. that covers both my children's names.  nice.
21:01:39 <kamatsu> monochrom: Big-O is useful when it's the difference between waiting a short time to get an answer and never getting the answer at all
21:01:46 <kmc> "From now on, there are three ways to do things: the right way, the wrong way, and the Max Power way."
21:01:51 <kmc> "Isn't that just the wrong way?"
21:01:55 <kmc> "Yeah, but faster!"
21:01:56 <kamatsu> "yeah, but faster"!
21:02:01 <medfly> lol
21:02:22 <absentia> hard coding constants...  is the fastest way.
21:02:48 <monochrom> The complete picture should be you prove both how long the program takes and what answer it gives.
21:02:53 <medfly> I don't really think that programming == CS, so for CS mathematics is cool, for real world programming, no.
21:03:02 <kamatsu> absentia: not if there are infinite constants you need
21:03:06 <absentia> med: exactly.
21:03:13 <absentia> I wanted real world programming... not so much theory.
21:03:24 <pikhq> medfly: Yeah, computer science is, really, a branch of math.
21:03:28 <kamatsu> medfly: When I work at Google, I use Big-O notation and formal reasoning
21:03:33 <dibblego> you can have both or neither, but not one
21:03:34 <kamatsu> medfly: I don't think they're completely exclusive
21:03:35 <absentia> kama: was a joke aimed at the comments above about not getting answers.
21:03:40 <pikhq> And has about as much to do with computers as astronomy does with telescopes.
21:03:45 <medfly> I am aware that CS can be useful
21:03:50 <syntaxglitch> maybe if "real world" programming used more theory, "real world" software wouldn't be so terrible :P
21:03:57 <kamatsu> syntaxglitch: true
21:04:15 <absentia> syn:  prove it.
21:04:22 <kamatsu> absentia: haskell?
21:04:24 * absentia rofls at his own joke... h0h0h0
21:04:30 <kmc> that's true but unattainable, because most programmers are not very smart
21:04:36 <absentia> kamatsu:  not much yet, you ?
21:04:42 <syntaxglitch> "haha, silly computer scientists with their formal methods, distracting me from writing my buffer overflows and SQL injection vulnerabilities"
21:04:43 <pikhq> syntaxglitch: Well, it certainly couldn't be *worse*.
21:04:52 <kmc> this is why languages and tools matter so much
21:05:01 <kmc> a little theory there goes a long way
21:05:01 <kamatsu> absentia: I was saying that haskell is proof that more theoretical based software ends up better
21:05:18 <absentia> kama:  really?  how so -- that's news to me.
21:05:19 <soupdragon> I do not beleive so
21:05:20 <pikhq> "Silly computer scientists with their garbage collector, distracting me from writing memory leaks."
21:05:22 <medfly> if a programmer wants to do CS, he can learn it, but this formal stuff is a bit different from what most people call programming.
21:05:31 <monochrom> So perhaps Big-O is not lame, but some people using Big-O are lame. Look at this phrase: "algorithm analysis". This phrase refers to the big-O part, the how-long part, exclusively. What happened to analyzing what the algorithm does?
21:05:31 <soupdragon> I have not found programs written in haskell to be of a much higher standard
21:05:35 <soupdragon> mabye I am just using the wrong ones though
21:05:47 <absentia> soup: agreed.
21:05:56 <kamatsu> I am referring to the language
21:06:00 <soupdragon> also not sure why haskell is more theoretical
21:06:02 <kamatsu> not the programs writtenm in it
21:06:10 <soupdragon> it's equally theoretical (not at all)
21:06:22 <kmc> what bugs me about big-O analysis is all the noise made over O(1) vs. O(log n) in cases where log n is, like, five
21:06:24 <kamatsu> ah, unfortunately we don't have a formal semantics for haskell
21:06:24 <medfly> Haskell forces you to learn all these theory things.
21:06:27 <pikhq> soupdragon: Haskell makes theory more useful is all.
21:06:30 <pikhq> Because abstraction is cheap.
21:06:31 <medfly> because of the community, really
21:06:35 <soupdragon> I'm not being anal about formal semantics though
21:06:52 <soupdragon> I just mean that it's used in practice
21:06:54 <absentia> kmc:  yes, but it's critical for very large values of 5.
21:07:01 <kmc> yeah
21:07:11 <kmc> well, sort of
21:07:18 <kmc> if your data set fits in memory, log n <= 64
21:07:20 <monochrom> Note that some O(1) claims are lies too.
21:07:21 <kamatsu> I still think that being aware of the complexity of your algorithm is important so that you don't write stupid programs
21:07:38 <absentia> amortization rocks!
21:07:38 <pikhq> kamatsu: Well, yeah.
21:07:42 <kmc> i think most truly stupid programs turn out to be exponential time
21:07:46 <soupdragon> <pikhq> "Silly computer scientists with their garbage collector, distracting me from writing memory leaks."
21:07:49 <kamatsu> kmc: yeah
21:07:49 <kmc> rather than log n when they should be constant
21:08:01 <pikhq> It's essential to any actual attempts to optimise code.
21:08:05 <soupdragon> pikhq, people actually say (and mean it when they do!!) "garbage collection is for lazy programmers"
21:08:09 <absentia> this is o(1) over infinite run... but there are times when.. well, you better just not wait.
21:08:13 <kamatsu> The main probablem is that we're saying big-O isn't useful after we've all learnt it and made use of the advantages of learning it
21:08:18 <pikhq> soupdragon: Dear God. That's awful.
21:08:20 <soupdragon> and using libraries is for noobs that can't implement everything from scratch...
21:08:33 <soupdragon> it's not REAL programming if it's not Turing Complete!
21:08:38 <kmc> yeah, some people have a macho complex
21:08:41 <kmc> in every field
21:08:53 <pikhq> soupdragon: So, wouldn't that make C not "real programming"?
21:08:54 <pikhq> :P
21:08:54 <kamatsu> real programmers use a needle and a steady hand
21:08:54 <kmc> usually the successful professionals are not those people
21:08:55 <absentia> C++ template programming is turing complete.
21:09:02 <erikc> not c++ again
21:09:15 <kmc> i'm not saying big-O analysis is useless
21:09:18 <Twey> It's not Turing-complete.  There's a bound on recursion.
21:09:21 <pikhq> absentia: Yes, it has an isomorphism with the lambda calculus.
21:09:26 <soupdragon> I would say that C is TC -- since TC is a theoretical thing about the abstract model, not a real world thing you can measure with a ruler
21:09:32 <pikhq> Twey: No, implementations are allowed to bound recursion.
21:09:36 <kamatsu> Twey: it is still turing complete, you can transform it into goto
21:09:38 <syntaxglitch> Twey, by that standard nothing is turing complete, because computers have finite memory
21:09:53 <pikhq> And there is a minimum recursion depth required for compliant implementations.
21:09:53 <Twey> Oh, really?  I thought it was part of the specification
21:09:54 <kmc> i think it's over-used as a lazy way to get an irrelevant answer, and avoid thinking about very hard real-world problems of constant factors, caches, etc
21:10:00 <pikhq> So, C++ *may* be Turing-complete.
21:10:05 <kmc> which to be honest, the only way to know is to profile
21:10:31 <pikhq> kmc: Well. Yeah.
21:10:34 <kamatsu> kmc: that's true, but whenever you're dealing with large data sets, you forget about constant factors and go after optimizing complexity
21:10:54 <pikhq> Complexity is just one tool used for optimisation.
21:11:20 * absentia shivers.
21:11:29 <kamatsu> for huge n, complexity is far more important than cutting out the coefficient of 2
21:11:49 <absentia> are we chatting at the edge of chaos?
21:12:00 <kamatsu> absentia: what?
21:12:04 <monochrom> at the edge of Truth.
21:12:18 <absentia> sorry.. nightmarish phrase from a past life of mine.
21:14:23 <idnar> we are dancing at the edge
21:14:31 * absentia bails.
21:14:34 <monochrom> @quote monochrom
21:14:39 <lambdac> monochrom says: 16 is the ripe age for writing your own compiler, you know.
21:14:46 <monochrom> ha
21:15:02 <pikhq> Yeah, that's about the right age.
21:15:05 <kamatsu> I wrote an interpreter when I was 16
21:15:08 <soupdragon> I am thinking that making the link closer between proving and programming could really make it a lot easier to program?
21:15:14 <kamatsu> I was so excited about all these cool ideas I was putting into my language
21:15:22 <kamatsu> I then realised it had all been done before :(
21:15:25 <medfly> yes, and I programmed when I was 2, and how I invented a language before I got into elementary school
21:15:25 <pikhq> I was targetting Brainfuck.
21:15:26 <soupdragon> sort of like a missing peice, that once you have everything is just simpler
21:15:35 <kamatsu> soupdragon: I agree
21:15:36 * medfly punches everyone
21:15:45 <monochrom> To be fair I couldn't write a compiler at 16.
21:16:13 <kamatsu> nor could I
21:16:15 <syntaxglitch> kamatsu, don't feel too bad, the cool new ideas in mainstream languages had all been done before too
21:16:20 <kamatsu> yeah
21:16:22 <soupdragon> I should like to put this into practice and see if I am right
21:16:31 <soupdragon> but it not possible to for me to test this
21:16:51 <Twey> medfly: Really?  Hey, cool!  Join the club!
21:16:52 <kamatsu> syntaxglitch: I am happy though, I figured out a way to implement OO using closures (this language was dynamically typed)
21:16:57 <medfly> err...
21:16:58 <kamatsu> syntaxglitch: so the OO stuff was all in libraries
21:17:07 <medfly> no, I only got remotely capable of programming at the ripe age of 17.
21:17:14 <Twey> Oh, okay
21:17:19 <medfly> jeez...
21:17:26 <Twey> :√æ
21:17:35 <syntaxglitch> kamatsu, heh, nice
21:17:38 <kamatsu> soupdragon: I work with high school students, we teach them Haskell, C and Python over 2 years
21:17:47 <kamatsu> soupdragon: maybe I could introduce them to a formal proof environment
21:18:04 <medfly> kamatsu, OMG ARE YOU SAYING AGE ISN'T STRONGLY CORRELATED WITH INTELLIGENCE?
21:18:10 <kamatsu> medfly: yes
21:18:15 <medfly> kamatsu, HOLY SHIT MAN
21:18:21 <kamatsu> knowledge, but not intelligence
21:18:24 <pikhq> kamatsu: OO using closures isn't even hard in C, man. :P
21:18:32 <monochrom> of course strongly correlated. some inverse square law.
21:18:32 <kmc> blurrfghrglhrfghrl
21:18:34 <kamatsu> pikhq: yeah, but, i was 16
21:18:45 <pikhq> ... Even then.
21:18:54 * syntaxglitch also votes for "inverse correlation"
21:18:58 <djahandarie> I'm 18 currently.
21:19:03 * pikhq is 19
21:19:11 * kamatsu is 21
21:19:14 <soupdragon> kamatsu, I think that would be a very interesting project but I have a bad feeling about high school people, like in general they don't care -- not very sure
21:19:16 * Twey is in between
21:19:17 <medfly> I know some people who have said to be programmers for ages, does that make them more competent than people who have been programmers for a short time? no
21:19:23 * syntaxglitch is 26 :(
21:19:29 <monochrom> The good news from the inverse square law is between age 30 and age 40 there is no much difference. :)
21:19:30 <soupdragon> syntaxglitch omg your old!!!!!!!
21:19:33 <djahandarie> People in here are quite young though...
21:19:33 <kamatsu> soupdragon: this is for people that voluntarily come to the university to learn this stuff
21:19:41 <pikhq> medfly: "Time programming" is only loosely correlated to ability.
21:19:44 <syntaxglitch> soupdragon, yeaahhh high score! go me!
21:19:49 <soupdragon> kamatsu, oh that's something!
21:19:56 <medfly> yeah, but it really depends on what the fuck you've been doing.
21:20:12 <pikhq> Yeah...
21:20:12 <medfly> if you've written increasingly difficult things and very often, great, moar time = awesome.
21:20:23 <kamatsu> like, for a long time i could only write this cute sort of LISP that was on my ancient mac
21:20:38 <syntaxglitch> but don't underestimate people's ability to do the same thing the wrong way over and over again
21:20:38 <Axman6> how ancient?
21:20:39 <Zao> My Setup.hs is 93 lines and growing. This is turning out well.
21:20:50 <kamatsu> Axman6: one of those early ones with a tiny black and white screen
21:20:51 <pikhq> I try to write something that's difficult to make myself a better programmer rather often...
21:21:14 <Axman6> kamatsu: heh, those are my speaker stands, i have two right next to me :P
21:21:14 * syntaxglitch is currently trying to make himself a better programmer by "learning Haskell"
21:21:29 <djahandarie> My definition of programming is "writing something I can't currently write." ;)
21:21:32 <kamatsu> pikhq: I only starting seriously improving my programming skills when I was 15 or so, before then I was just playing around
21:21:38 <absentia> you guys are 21?  my first irc bot was written in the fall of '88  ...
21:21:57 <djahandarie> kamatsu, that's about the same for me.
21:21:59 <kamatsu> not everyone here is as young as us
21:22:03 <soupdragon> pikhq, how do you find something difficult to do?
21:22:05 <soupdragon> I have run out!
21:22:07 <drhodes> naval gazers
21:22:13 <Axman6> kamatsu: http://www.flickr.com/photos/57127535@N00/2287439889/
21:22:14 <lambdac> Title: Comp pics-2 on Flickr - Photo Sharing!
21:22:17 <soupdragon> everything is just tedium or impossible
21:22:34 <pikhq> Currently, I'm working on a Lazy K interpreter in lazy functional C.
21:22:35 <djahandarie> soupdragon, trying to do impossible things is certainly difficult.
21:22:36 <kamatsu> Axman6: awesome!!
21:22:44 <kamatsu> Axman6: why 2?
21:22:47 <Axman6> i grew up using the one on the right
21:22:51 <pikhq> soupdragon: Often, I abuse programming languages. :P
21:22:52 <drhodes> Axman6: on the right is a fatmac512K?
21:22:59 <drhodes> Axman6: on the left a color classic?
21:23:12 <syntaxglitch> heh, Lazy K
21:23:16 <djahandarie> pikhq, lazy functional C...? That doesn't sound like it'd be fun.
21:23:21 <Axman6> right is a Macintosh Plus, left is a Macintosh Classix II
21:23:24 <Axman6> c*
21:23:29 <pikhq> djahandarie: It's not hard with a lambda macro.
21:23:36 <kamatsu> my one actually had a card in it that hardware accellerated Lisp
21:23:41 <pikhq> Though it's a royal pain in the ass to debug.
21:23:45 <Axman6> kamatsu: awesome
21:23:55 <kamatsu> It also had a c compiler and the expensive mac development tools
21:23:56 <monochrom> sexy!
21:23:57 <pikhq> I get, like, no typechecking.
21:23:59 <kamatsu> we found it on the street one day
21:24:12 <Axman6> :o
21:24:20 <pikhq> And GCC gives extremely *useless* error messages for macro invocations over multiple lines.
21:24:30 <syntaxglitch> pikhq, it's C, it's not like you have a helpful type system anyway
21:24:40 <monochrom> some developer threw it out as junk of the form "let's hope someone else wants it"
21:24:41 <pikhq> syntaxglitch: Everything's a void*.
21:24:47 <pikhq> Even C is helpful in comparison.
21:25:04 <kamatsu> you can shove sort of meaningful type checking into C
21:25:19 <kamatsu> for example, you can implement newtype by adding another layer of dereferencing
21:25:20 <Zao> pikhq: Everthing in my Haskell library is Ptr () :)
21:25:27 <kamatsu> typedef *type Type
21:25:32 <kamatsu> typedef **type Newtype
21:25:33 <kamatsu> hah
21:25:36 <pikhq> I've got half a mind to start using tagged pointers just to have a hope of getting *runtime* type checking.
21:26:21 <pikhq> Trying to figure out why the only programs that function correctly on your interpreter are equivalent to I is annoying.
21:26:28 <syntaxglitch> hahaha
21:26:31 <kamatsu> hahahaha
21:26:43 <monochrom> hehehe
21:26:47 <Twey> Not nearly as confusing as figuring out why every program functions as S, though
21:27:01 <syntaxglitch> or if every program functioned as Y
21:27:02 <pikhq> Twey: Never had *that* problem, thankfully.
21:27:18 <pikhq> It's even more irritating considering how I've defined I.
21:27:30 <syntaxglitch> in terms of S and K?
21:27:38 * Twey chuckles.
21:27:45 <pikhq> global_thunk(static, I, NULL, {return dethunk(eval(genList("SKK")));});
21:27:50 <syntaxglitch> hahahaha
21:27:55 <Twey> Yes :-D
21:28:09 <pikhq> syntaxglitch: In terms of the interpreter, even.
21:28:19 <Twey> Haha
21:28:32 <monochrom> So, that's how you become more intelligent.
21:29:51 <pikhq> Or just amuse myself.
21:31:31 <pikhq> Maybe after this I'll write a Scheme or something.
21:33:05 <monochrom> @quote monochrom
21:33:05 <lambdac> monochrom says: krad!  I'm reading Bird's haskell book now.  It has fusion, parser monad, and monad transformers!  If I read this book instead of Paulson's ML book ten years ago, the history of the
21:33:05 <lambdac> entire human race would have to be rewritten!
21:34:16 <syntaxglitch> pikhq, write a Scheme... in Lazy K, running on your interpreter
21:34:40 <monochrom> ha nice
21:37:14 * syntaxglitch notes that, augmented with a simpleminded string-substitution macro system, Lazy K would actually be quite tolerable to program in
21:37:25 <pikhq> syntaxglitch: Very tempting.
21:37:35 <syntaxglitch> arguably less painful than programming in Java, though perhaps a bit slower
21:37:35 <pikhq> And yeah, it would.
21:37:59 <pikhq> I'll note that the Lazy K implementation comes with a slightly more complex macro system.
21:38:31 <pikhq> (it compiles lambda, too!)
21:38:36 <syntaxglitch> as long as the macro system isn't turing complete it's fair enough I guess
21:39:02 * soupdragon just reads cool stuff and thinks I know things.. but when I try and put it into practice nothing happens
21:39:10 <monochrom> build Lazy K. then build Lazy K++ providing better macro. :)
21:39:24 <pikhq> Technically the macro system is "a couple of Scheme functions", though. So if you really wanted it to be TC, you could make it be that way. :P
21:40:06 <syntaxglitch> pure untyped lambda calculus is almost too usable to count, even without any macros
21:41:15 <pikhq> It's fairly trivial to do, though.
21:41:49 <syntaxglitch> I have a half-finished Œª-calculus interpreter I was tinkering with that had a couple very minor syntactic extensions, it actually made a charming little minimalist language
21:42:13 <pikhq> def and lambda make for a surprisingly useful language.
21:42:23 <syntaxglitch> pf, "def"
21:42:35 <pikhq> Though it does take you a little bit of time to get the primitives in place.
21:42:35 <soupdragon> you don't need def :P
21:42:47 <soupdragon> (\car cdr eval apply -> ....) <definnitions go here>
21:42:51 <pikhq> No, but it makes programming a bit easier. :P
21:43:00 <syntaxglitch> yeah, I was doing what soupdragon said
21:43:07 <soupdragon> also you don't need comments
21:43:09 <pikhq> soupdragon: True, true.
21:43:15 <syntaxglitch> with the addition of allowing multiple files in a "project"
21:43:19 <soupdragon> (\this is a comment -> comment)
21:43:24 <medfly> all that sugar is bad for you!
21:43:27 <syntaxglitch> so I could pull the "library" functions out into a different file
21:43:50 <pikhq> soupdragon: BTW, (\car.\cdr.\eval.\apply. ...)
21:43:51 <pikhq> :P
21:43:51 <syntaxglitch> a valid source file was a combinator
21:44:55 <syntaxglitch> so I had "import" bindings at the top of the "main" file, then to run the program it would first apply the main file to the library files, then apply the result to the input stream
21:45:25 <syntaxglitch> it was kinda fun, actually
21:45:55 <pikhq> I'm still somewhat amused that I managed to get an infinite list in C.
21:46:04 <syntaxglitch> the only unusual thing I added was syntactic indentation
21:46:19 <syntaxglitch> because obviously, too many parenthesis is the main usability problem with pure untyped lambda calculus
21:46:43 <mreh_> pikhq: linked list?
21:46:58 <medfly> I am thinking how it would be cool to have a simple language like Scheme and a kind of sugar layer on top, you'd essentially translate everything written into de-sugared versions.
21:46:59 <mreh_> syntaxglitch, which is also a problem with Lisp/Scheme
21:47:04 <soupdragon> well you can always implement a sub-language inside it that doesn't suffer from this problem
21:47:10 <pikhq> mreh_: Yes.
21:47:42 <syntaxglitch> nah, parentheses aren't that bad in the lisp-like languages, because of the expressive power
21:47:43 <pikhq> mreh_: Corecursion is fun.
21:47:58 <syntaxglitch> but lambda calculus tends to have a bit more cruft attached
21:47:58 <soupdragon> bind various symbols to functions that CONS a lexical atom onto a list
21:48:01 <mreh_> syntaxglitch, the tree notation is impossible to read
21:48:06 <soupdragon> then you can implement lisp syntax :)
21:48:50 <syntaxglitch> "lisp syntax" is a phrase that doesn't really make sense
21:49:10 <syntaxglitch> it's like saying "his hair color is baldness"
21:49:12 <soupdragon> \open close lambda car cdr ... ->   open car open cons .... close close close
21:49:14 <soupdragon> like that sort stuff
21:49:17 <medfly> heh
21:50:15 <syntaxglitch> when you're essentially writing an AST directly you've left the land of syntax far behind
21:50:35 <mreh_> it's not an AST is it? It's an executable program
21:50:56 <monochrom> executable AST in funny notation
21:51:16 <syntaxglitch> it's not unheard of for interpreters to work directly on an AST
21:51:16 <mreh_> lisp machines, my god father told me about those
21:51:39 <syntaxglitch> I think Ruby used to run ASTs directly, actually
21:52:44 <mreh_> "used to" - does anyone else find that expression not sitting right, even though english my native languag
21:52:46 <mreh_> anyway
21:53:01 <mreh_> I'VE BEEN PROGRAMMING 12 HOURS
21:53:13 <syntaxglitch> mreh_, TWELVE MORE TO GO
21:53:26 <syntaxglitch> PLEASE DON'T GIVE UP
21:53:28 <mreh_> CAN'T PROGRAM IN SLEEP
21:53:45 <monochrom> I use "used to" all the time.
21:53:52 <mreh_> i'm writing a TODO file... ffs
21:54:31 <monochrom> Ha, I am used to writing "used to". :)
21:55:10 <allbery_b> isn't linguistic shift fun?
21:55:13 <mreh_> that must mess with learners
21:55:32 <syntaxglitch> monochrom, I used to be used to that, it's a phrase I used to express many concepts
21:55:45 <ivanm> ummm.... where's lambdabot?
21:55:52 <monochrom> heh
21:56:07 <monochrom> It only depends on how generalizable your mind is.
21:56:11 <mreh_> "I am to be used to unblock toilets"
21:56:38 <mreh_> that doesn't work
21:56:51 <mreh_> can't... take... things... out of context correctly
21:57:08 <monochrom> First revelation from learning English: individual letters mean nothing. combinations of letters are words, they begin to mean something.
21:57:21 <allbery_b> used to = accustomed to; the past-tense use reflects a grammatical mode which I'm misremembering at the moment (and which is otherwise largely forgotten)
21:57:37 <monochrom> Second revelation: generalizing from the first, individual words mean nothing either, you have to look at combinations of words.
21:57:38 <allbery_b> much like the subjunctive mood is all but gone
21:57:55 <mreh_> allbery_b there is no subjunctive in english
21:58:16 <aavogt> a is a word
21:58:19 <mreh_> "used to" can mean, "it's not like that any more"
21:58:23 <mreh_> aavogt++
21:58:31 <soupdragon> monochrom I don't like where this is going
21:58:32 <soupdragon> !
21:58:46 <allbery_b> false.  ever wonder why sometimes "were" is used in place of "was"?  that's the sole remaining vestige f the subjunctive
21:58:47 <monochrom> Not many people made it to the second revelation due to inability to generalize. Of course they will have problems with "I am used to write", "I am used to writing", "I used to write".
21:59:07 <syntaxglitch> monochrom, I think natural languages need a static type system
21:59:27 <syntaxglitch> to resolve this ambiguities
21:59:31 <monochrom> They are also the kind of people who ask, "what does , mean in haskell?"
21:59:45 <monochrom> Dude, individual tokens like , mean nothing.
21:59:50 <allbery_b> they tried that once.  unfortunately, the "type system" they chose was formal Latin :)
21:59:55 <soupdragon> monochrom I understand the paradox of a dictionary that defines words in terms of words
22:00:07 <mreh_> allbery_b, were is used to agree with the subject of the sentence
22:00:28 <mreh_> I was, you were, he was, we were...
22:00:34 <monochrom> (2,3) means one thing. [2,3] means another thing. import XXX(aa,bb) means yet another thing. The whole construct means something. The comma alone is just delimiter, pure syntax, no meaning.
22:00:35 <allbery_b> mreh_: "if I were ..." is not agreeing in number, it is subjunctive
22:00:39 <medfly> it's like that open loop stuff you guys discussed before
22:00:41 <mreh_> ooh
22:00:56 <mreh_> were I to do so and so
22:00:58 <medfly> dictionaries
22:01:31 <monochrom> I understand the reductionist way and in fact I am a reductionist too, but you can't practically reduce to the level of commas and expect to ask what they mean.
22:01:35 <allbery_b> (that silly attempt to force languages to match Latin got us the false :no split infinitives" nonsense, among others.  you *can't* split an infinitive in Latin, therefore it's "obviously" wong to do so in languages which can?)
22:02:18 <mreh_> ab ere <- split infinitive
22:02:26 <syntaxglitch> monochrom, what does the twenty-sixth bit in my program mean in Haskell?
22:02:30 <syntaxglitch> I think it's a 1, if that helps
22:02:38 <allbery_b> heh
22:02:41 <aavogt> you could split latin infinitives if you had the chance to really try hard :)
22:02:42 <monochrom> ha
22:02:51 <allbery_b> *snrk*
22:03:04 <mreh_> > splitAt 2 "abere"
22:03:06 <lambdac>   ("ab","ere")
22:03:10 <mreh_> woo
22:03:51 <mreh_> what should I do to stay awake?
22:04:05 <mreh_> #haskell is counter productive, sorry guys
22:04:06 <syntaxglitch> drink coffee, write Haskell
22:04:18 <soupdragon> mreh_, you should program for 12 hours straight!
22:04:20 <mreh_> syntaxglitch, I want to write good Haskell
22:05:13 <uorygl> Then use type signatures.
22:05:21 <soupdragon> bleh :P
22:05:22 <syntaxglitch> hm, by the C-H correspondence, does drinking coffee and writing a Haskell program that compiles successfully meet the criteria for being a mathematician?
22:05:34 <soupdragon> coffee-haskell correspondence?
22:05:40 <pikhq> syntaxglitch: Possibly.
22:05:40 <mreh_> haha
22:06:00 <pikhq> Mathematicians do convert coffee to theorems, and a program can be considered a theorem.
22:06:00 <mreh_> GHC called my functions "equations" today
22:06:23 <uorygl> No, you've merely proved that if you have coffee, you can be a mathematician.
22:06:51 <mreh_> if I just close my eyes for ten minutes
22:07:39 <monochrom> he goes asleep. :)
22:08:12 <uorygl> Lie down. Close your eyes. Count to 120. Open your eyes. Get up.
22:08:34 <uorygl> And by "count to 120", I mean "count your breaths until you've counted 120 of them".
22:08:36 <syntaxglitch> hm, apparently the "a mathematician is a machine for turning coffee into theorems" quote wasn't originally said by Erdos, I thought it was
22:08:54 <uorygl> A mathematician is a proof that if coffee exists, theorems exist.
22:09:00 <syntaxglitch> heh
22:09:25 <wnoise> A comathematician is a machine for turning cotheorems into ffee.
22:09:40 <monochrom> callCC (\k -> do { lie down; close eyes; count to 120; k (); open eyes; get up } )
22:09:42 <djahandarie> I don't drink any coffee.
22:09:48 <dmwit> ?quote Cale inconsistent
22:09:49 <lambdac> No quotes match. Sorry.
22:09:54 <pikhq> djahandarie: Clearly you are not a mathematician.
22:10:00 <soupdragon> nice use of continuation :o
22:10:15 <uorygl> pikhq: on the contrary, that means that djahandarie is trivially a mathematician.
22:10:26 <uorygl> Because of A -> B -> A.
22:10:26 <pikhq> uorygl: Oh?
22:10:33 <pikhq> Alas.
22:10:40 <monochrom> hahaha
22:10:42 <dmwit> <Cale> But in another sense, functional programmers are applied logicians who spend all their time proving trivial theorems in interesting ways in an inconsistent intuitionist logic.
22:10:43 <pikhq> He turns a lack of coffee into a lack of coffee.
22:10:48 <pikhq> I have been enlightened.
22:11:29 <uorygl> If djahandarie doesn't drink coffee, that means djahandarie :: Theorems, meaning const djahandarie :: Coffee -> Theorems.
22:11:56 * djahandarie notes to make passing comments in #haskell more often
22:12:36 <mreh_> are there mugs shots of the community anywhere?
22:12:48 <dmwit> hah
22:13:46 <soupdragon> there's south-parkifications..
22:15:05 <uorygl> Darn. I'm probably not active enough in the community to qualify for a mug shot.
22:17:10 * mreh_ .o0(http://farm4.static.flickr.com/3340/3473892473_4600be9687.jpg)
22:18:00 <djahandarie> How fitting in light of the conversation we were just having.
22:18:06 <syntaxglitch> indeed
22:18:12 <monochrom> "machines develop altruism to provide coffee to each other"
22:18:49 <uorygl> It's actually a response to a threatening display.
22:19:14 <mreh_> it's the brutality and selfishness of a slave mentality
22:39:32 <Jonno_FTW> is anyone here good with data.xhtml?
22:42:47 <jinjing> where did data.array.diff go in ghc 6.12?
22:44:24 <Jonno_FTW> well?
22:46:34 <nainaide> Just want  to QuickCheck from 1.2.0.0 to Latest version available: 2.1.0.3, but cabal upgrade QuickCheck just reinstall, how to do that, please?
22:46:46 <kamatsu> @pl \a b -> (max a b) - (min a b)
22:46:46 <lambdac> ap (ap . ((-) .) . max) min
22:46:57 <kamatsu> ah, i'll just use abs
22:52:28 <aavogt> nainaide: cabal install QuickCheck-2.1.0.3
22:52:39 <nainaide> aavogt, thanks, I see
22:53:01 <Zao> Isn't there some unspoken rule that if the major version changes, it should be considered a completely different package?
22:53:21 <ivanm> Zao: completely different? no
22:53:25 <ivanm> backwards incompatible? yes
22:54:48 <soupdragon> so what's the best shortest webserver in haskell
22:54:50 <soupdragon> ?
22:55:03 <ivanm> uhhh..... what?
22:55:04 <Jonno_FTW> i saw one in less than 4096 characters
22:55:17 * ivanm isn't even sure if we even had a full blown web server written in haskell
22:55:20 <Zao> soupdragon: Allowing what libraries? network?
22:55:24 <ivanm> but saying "best shortest" doesn't make sense?
22:55:25 <soupdragon> I dunno
22:55:26 <soupdragon> I have cabal
22:55:32 <soupdragon> well let me explain
22:55:37 <ivanm> soupdragon: http://hackage.haskell.org/package/
22:55:38 <lambdac> Title: HackageDB: packages by category
22:55:48 <soupdragon> I want to serve web page but also have a dynamic page
22:55:48 <ivanm> maid looks small
22:55:58 <Jonno_FTW> i have a copy of the short webserver in haskell
22:56:07 <soupdragon> basically that's it... I already coded this in lisp and it works
22:56:07 <Jonno_FTW> 4196 bytes
22:56:15 <soupdragon> but I'm wondering, I should replace it with haskell
22:56:23 <soupdragon> (since the actual program is written in haskell)
22:59:58 <uorygl> Darn. A while ago, in some channel, someone mentioned that English has only one vestige of the subjunctive mood remaining, that being the "were" in phrases like "if I were you".
23:00:36 <uorygl> I wanted to respond and say that I still use the subjunctive occasionally, in things like "I propose that this feature be added" and "I insist that you not run away".
23:15:33 <ezyang> I'm trying to simulate loops as seen in traditional imperative languages, and am kind of wondering what transformer I want to put on the IO monad
23:15:52 <soupdragon> ezyang, you can do loops without anything special
23:16:09 <ezyang> right, with pure recursion
23:16:13 <ezyang> I want to use the list monad
23:16:23 <soupdragon> oh that's not really a loop though
23:16:36 <medfly> how is something like (,) implemented?
23:16:40 <soupdragon> there's ListT you can use
23:16:51 <medfly> @src (,)
23:16:51 <lambdac> Source not found. My mind is going. I can feel it.
23:17:28 <ezyang> soupdragon: Right, but then I need ListT IO a in order to extract, when I often have [a] I want to extract
23:17:44 <ezyang> I guess if I can get [a] -> ListT IO a I win
23:17:47 --- mode: xerox set -o xerox
23:17:58 <soupdragon> extract??
23:18:03 <medfly> if I use :t (,,,,,,) for a ridiculous number of ,s it still works.
23:18:06 <ezyang> <-
23:18:17 <ezyang> medfly: I think they're built into GHC?
23:20:36 <medfly> so... it's not Haskell? :o
23:20:38 <medfly> or what
23:20:53 <Niccus> I think they're coded in up to like (,,,,,,,)
23:21:09 <medfly> :t (,,,,,,,,,)
23:21:10 <lambdac> forall a b c d e f g h i j. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> (a, b, c, d, e, f, g, h, i, j)
23:21:13 <medfly> works :)
23:21:17 <ezyang> :t (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
23:21:18 <lambdac> forall a b c d e f g h i j k l m n o p q r s t u v w x y z t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o ->
23:21:18 <lambdac> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 -> t35 -> t36 -> t37 -> t38 -> t39 -> t40 -> t41 -> t42 -> t43 -> (a, b, c, d, e, f, g, h, i, j,
23:21:18 <lambdac> k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t28, t29, t30, t31, t32, t33, t34, t35, t36, t37, t38, t39, t40, t41, t42, t43)
23:21:20 <ezyang> lol
23:21:33 <ezyang> maybe later GHCs make it more generalized
23:21:43 <aavogt> > length ['a' .. 'z']
23:21:44 <lambdac>   26
23:21:58 <medfly> ehehe
23:22:04 * aavogt wonders what happened to t27
23:22:13 <medfly> indeed
23:22:21 <soupdragon> :t let a x = (x,x) ; b = (a,a) ; c = (b,b) ; d = (c,c) in d
23:22:23 <lambdac> forall t t1 t2 t3 t4 t5 t6 t7. (((t -> (t, t), t1 -> (t1, t1)), (t2 -> (t2, t2), t3 -> (t3, t3))), ((t4 -> (t4, t4), t5 -> (t5, t5)), (t6 -> (t6, t6), t7 -> (t7, t7))))
23:22:33 <Niccus> http://haskell.org/ghc/docs/latest/html/libraries/ghc-prim-0.2.0.0/GHC-Tuple.html
23:22:35 <lambdac> Title: GHC.Tuple, http://tinyurl.com/yafcl6g
23:23:06 <Niccus> whoa why is there a tinyurl tacked on
23:23:20 <medfly> an old version of lambdabot, I think
23:23:45 <Niccus> :t (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
23:23:47 <lambdac> forall a b c d e f g h i j k l m n o p q r s t u v w x y z t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52 t53 t54 t55 t56 t57 t58 t59 t60 t61 t62
23:23:47 <lambdac> t63 t64. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 -> t35 -> t36
23:23:47 <lambdac> -> t37 -> t38 -> t39 -> t40 -> t41 -> t42 -> t43 -> t44 -> t45 -> t46 -> t47 -> t48 -> t49 -> t50 -> t51 -> t52 -> t53 -> t54 -> t55 -> t56 -> t57 -> t58 -> t59 -> t60 -> t61 -> t62 -> t63 -> t64 ->
23:23:47 <lambdac> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t28, t29, t30, t31, t32, t33, t34, t35, t36, t37, t38, t39, t40, t41, t42, t43, t44, t45, t46, t47, t48, t49, t50, t51,
23:23:47 <lambdac> t52, t53, t54, t55, t56, t57, t58, t59, t60, t61, t62, t63, t64)
23:24:02 <medfly> yeah, it just keeps on going like that.
23:24:06 <Niccus> well that's further than the one listed on the page
23:25:31 <medfly> I'm trying to see if it ever stops
23:26:06 <Niccus> :t (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
23:26:07 <lambdac> forall a b c d e f g h i j k l m n o p q r s t u v w x y z t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52 t53 t54 t55 t56 t57 t58 t59 t60 t61 t62
23:26:07 <lambdac> t63 t64 t65 t66 t67 t68 t69 t70 t71 t72 t73 t74 t75 t76 t77 t78 t79 t80 t81 t82 t83 t84 t85 t86 t87 t88 t89 t90 t91 t92 t93 t94 t95 t96 t97 t98 t99 t100 t101 t102. a -> b -> c -> d -> e -> f -> g ->
23:26:07 <lambdac> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 -> t35 -> t36 -> t37 -> t38 -> t39 -> t40 -> t41 -> t42 ->
23:26:07 <lambdac>  t43 -> t44 -> t45 -> t46 -> t47 -> t48 -> t49 -> t50 -> t51 -> t52 -> t53 -> t54 -> t55 -> t56 -> t57 -> t58 -> t59 -> t60 -> t61 -> t62 -> t63 -> t64 -> t65 -> t66 -> t67 -> t68 -> t69 -> t70 ->
23:26:07 <lambdac> t71 -> t72 -> t73 -> t74 -> t75 -> t76 -> t77 -> t78 -> t79 -> t80 -> t81 -> t82 -> t83 -> t84 -> t85 -> t86 -> t87 -> t88 -> t89 -> t90 -> t91 -> t92 -> t93 -> t94 -> t95 -> t96 -> t97 -> t98 ->
23:26:09 <lambdac> [3 @more lines]
23:26:11 <Niccus> oh god it doesn't
23:26:12 <Niccus> aaaa
23:27:26 <aavogt> #ty $(ConE (TupleT maxBound))
23:27:40 <aavogt> @botsnack
23:27:40 <lambdac> :)
23:27:49 <aavogt> oh, lunabot is gone :(
23:28:46 <medfly> what is that?
23:29:09 <tensorpudding> > "ping"
23:29:10 <lambdac>   "ping"
23:29:13 <tensorpudding> hmm
23:29:22 <tensorpudding> lambdac is the replacement lambdabot?
23:30:03 <aavogt> medfly: in ghci, :set -fth; :m +Language.Haskell.TH; $(return $ ConE $ tupleDataName maxBound)
23:30:14 <medfly> thanks
23:31:03 <aavogt> though you probably want a lower number
23:31:06 <augur> wtf is lambdac :|
23:31:26 <ivanm> augur: dibblego's lambdabot
23:31:29 <augur> o ok
23:31:32 <ivanm> since the real lambdabot isn't here
23:31:37 <ivanm> preflex: seen lambdabot
23:31:37 -preflex(~preflex@95-88-118-220-dynip.superkabel.de)- lambdabot was last seen on #haskell 1 day, 6 minutes and 32 seconds ago, saying:   [(2,1),(3,2),(4,3),(5,4),(6,5),(7,6),(8,7),(9,8),(10,9),(11,10),(12,11),(13...
23:31:48 <DigitalKiwi> GRR
23:31:49 <augur> aww, lambdabot, where ARE you? D:
23:32:00 <DigitalKiwi> preflex sending notices pings me
23:32:02 <djahandarie> Who runs lambdabot anyways?
23:32:15 <medfly> well, it's doing stuff. no doubt :o
23:32:24 <ezyang> Any cuter ways of doing this? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16828#a16828
23:32:36 <DigitalKiwi> I've been wondering for days why I keep getting pinged but see nobody mention my name or a ctcp
23:32:36 <Niccus> cute or good
23:32:46 <ezyang> cute.
23:33:00 <ezyang> If it was good, I wouldn't be trying to simulate traditional imperative loops :-)
23:33:04 <aavogt> medfly: so while a tuple containing (maxBound::Int) probably consumes all your memory... 20000 works :)
23:33:06 <sinelaw> yo.
23:33:08 <djahandarie> lambdabot! =D
23:33:17 <djahandarie> > "test"
23:33:19 <lambdac>   "test"
23:33:22 <medfly> 20000 works?
23:33:23 <lambdabot>   "test"
23:33:34 <augur> lambdabot is a fraud! D:
23:34:02 <medfly> also, lol, yeah, it's eating my memory...
23:34:02 <xerox> does preflex eval haskell?
23:34:06 <augur> > foldr (+) 0 [0,1..]
23:34:08 <lambdac>   * Exception: stack overflow
23:34:13 <lambdabot>   * Exception: stack overflow
23:34:16 <augur> LIAR
23:34:22 <aavogt> medfly: well that template haskell I suggested to you is a type error, it is sort of proof that ghc can represent such tuples
23:34:26 <augur> look at that delay
23:34:27 <djahandarie> aavogt, could be on a different computer
23:34:31 <djahandarie> Err
23:34:31 <augur> LIE, ER.
23:34:36 <djahandarie> augur, ^
23:34:46 <djahandarie> We could try some other stuff
23:34:51 <aavogt> @bot
23:34:52 <lambdac> :)
23:34:57 <lambdabot> :)
23:35:21 <djahandarie> > last (scanl (+) 0 [1..1000000]))
23:35:23 <lambdac>   <no location info>: parse error on input `)'
23:35:27 <djahandarie> lol
23:35:27 <lambdabot>   <no location info>: parse error on input `)'
23:35:28 <djahandarie> > last (scanl (+) 0 [1..1000000])
23:35:30 <lambdac>   * Exception: stack overflow
23:35:37 <lambdabot>   * Exception: stack overflow
23:35:40 <Niccus> > fix error
23:35:41 <lambdac>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
23:35:47 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
23:35:52 <djahandarie> THERE IS NO WAY TO TELL
23:36:06 <aavogt> @vixen do you always give the same answer?
23:36:06 <lambdac> i dunno, what was the question?
23:36:07 <lambdabot> i dunno, what was the question?
23:36:09 <xerox> ?quote meep
23:36:10 <lambdabot> No quotes match.
23:36:10 <lambdac> No quotes match. There are some things that I just don't know.
23:36:16 <Niccus> egad
23:36:18 <djahandarie> Oh
23:36:23 <xerox> ?quote monad
23:36:23 <lambdabot> spb says: [in ##freenode-social] because monads are a nasty hack to get around a language deficiency
23:36:23 <lambdac> monochrom says: If you're having trouble learning monads, try to learn something harder, like algebraic geometry.
23:36:24 <djahandarie> Definitely a different bot. :P
23:36:39 <Niccus> ?quote monad
23:36:39 <lambdabot> mtnviewmark says: [on the State monad] "If I had a sta-ate, I'd compute it in the morning.... I'd compute it in the evening.... All over this la-and!"
23:36:40 <lambdac> dons says: Binkley: yes, I'd love to see 'monads as nuclear waste' illustrated through dance, to something by Kate Bush
23:36:46 <tensorpudding> stop botflooding!
23:36:47 <augur> lambdabot seems to be ignoring my direct messages
23:36:54 <Niccus> but we love to swim in bot
23:37:08 <augur> i'd swim in /your/ bot
23:37:10 <augur> ;o ;o ;o
23:37:17 <Cale> Who owns lambdac?
23:37:23 <medfly> dibblego
23:37:26 * syntaxglitch wonders if there's anything that would trick the bots into triggering each other
23:37:47 <medfly> hehe
23:37:58 <Niccus> a triggering quine
23:37:58 * hackagebot upload: web-encodings 0.2.2 - Encapsulate multiple web encoding in a single package. (MichaelSnoyman)
23:38:07 <augur> its real!
23:38:13 <augur> lambdabot is real. :D
23:39:47 <augur> > let f xs = xs in f [0..]
23:39:48 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
23:39:48 <lambdac>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
23:39:53 <augur> look at that. beautiful!
23:40:15 <augur> but now we have two bots. someone kick the one that belongs to the least cool person
23:40:27 <augur> where least cool means less nerdy, obviously.
23:40:28 <medfly> that would definitely be lambdac :-p
23:40:38 <syntaxglitch> no!
23:40:41 <syntaxglitch> make the bots duel
23:40:43 <syntaxglitch> to the death
23:40:46 <augur> hm!
23:40:50 <xerox> > "the fastest stays"
23:40:51 <lambdac>   "the fastest stays"
23:40:51 <lambdabot>   "the fastest stays"
23:40:56 <medfly> hehe
23:40:57 <xerox> they agree
23:41:00 <medfly> they're sort of the same
23:41:09 <Niccus> but which one is the evil twin
23:41:19 <augur> > putStr ">"
23:41:20 <lambdabot>   <IO ()>
23:41:20 <lambdac>   * Exception: "<IO ()>"
23:41:27 <sinelaw> hah.
23:41:28 <augur> oh thats interesting
23:41:28 <Niccus> whoa
23:41:32 <xerox> haha
23:41:33 <sinelaw> > fix fix
23:41:34 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
23:41:34 <lambdac>   Occurs check: cannot construct the infinite type: a = a -> a
23:41:44 <aavogt> http://aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.tld
23:41:51 <augur> how can we get lambdabot to echo > ...
23:41:53 <sinelaw> @hoogle putStr
23:41:53 <lambdabot> Prelude putStr :: String -> IO ()
23:41:53 <lambdabot> Data.ByteString putStr :: ByteString -> IO ()
23:41:53 <lambdabot> System.IO putStr :: String -> IO ()
23:41:53 <lambdac> A Hoogle error occurred.
23:41:55 <augur> such that its a quine
23:42:01 <sinelaw> lambdac is misconfigured.
23:42:05 <sinelaw> kill it.
23:42:08 <augur> and forces the bots to eval one anothers outputs
23:42:11 <augur> forever
23:42:20 <augur> someone figure this out
23:42:22 <augur> go go go!
23:42:53 <augur> > ">"
23:42:54 <lambdabot>   ">"
23:42:54 <lambdac>   ">"
23:43:02 <voidprayer> I notice that the manual says GHC currently cannot compile Haskell module into shared Windows DLL. And some blogs suggest using GHC-6.8. Are these true?
23:43:02 <soupdragon> > quine
23:43:03 <lambdabot>   Not in scope: `quine'
23:43:03 <lambdac>   Not in scope: `quine'
23:43:19 <augur> its gotta be some sort of co-quine
23:43:22 <augur> since there's two of them
23:43:29 <augur> and because its haskell, so everything is co-.
23:43:34 <Niccus> it just needs to print itself prepended with "> "
23:43:39 <Niccus> in one line
23:43:45 <augur> yeah, but without the quotation marks,
23:43:49 <augur> > show ">"
23:43:49 <lambdabot>   "\">\""
23:43:50 <lambdac>   "\">\""
23:43:59 <sinelaw> > show "\n>"
23:44:00 <lambdabot>   "\"\\n>\""
23:44:07 <soupdragon> :t :t
23:44:08 <lambdabot> parse error on input `:'
23:44:16 <sinelaw> smartass. and labdac seems stuck
23:44:29 <Niccus> putStr "> putStr \"Hello, World!\""
23:44:32 <Niccus> > putStr "> putStr \"Hello, World!\""
23:44:33 <lambdabot>   <IO ()>
23:44:35 <lambdac> parse error on input `:'
23:44:35 <lambdac>   "\"\\n>\""
23:44:35 <lambdac>   * Exception: "<IO ()>"
23:44:42 <sinelaw> > "\n>"
23:44:42 <lambdabot>   "\n>"
23:44:43 <lambdac>   "\n>"
23:44:57 <sinelaw> > 3
23:44:58 <lambdabot>   3
23:44:58 <lambdac>   3
23:45:00 <soupdragon> @pl join atpl
23:45:00 <lambdabot> join atpl
23:45:00 <lambdac> join atpl
23:45:09 <sinelaw> they put two spaces anyway in front, so there's no use trying.
23:45:29 <sinelaw> @vixen are you  unique?
23:45:29 <lambdabot> yes, i am
23:45:29 <lambdac> yes, i am
23:45:33 <ray> > let str = "> let str = \"%s\" in printf str str" in printf str str
23:45:34 <lambdac>   Add a type signature
23:45:34 <lambdabot>   Ambiguous type variable `a' in the constraints:
23:45:34 <lambdabot>    `GHC.Show.Show a'
23:45:34 <lambdabot>      a...
23:45:34 <soupdragon> @pl (\x y -> y (x x y)) (\x y -> y (x x y)) atpl
23:45:38 <lambdabot> (ap id . ap id id) (ap id . ap id id) atpl
23:45:38 <lambdac> (ap id . ap id id) (ap id . ap id id) atpl
23:45:38 <lambdabot> optimization suspended, use @pl-resume to continue.
23:45:38 <lambdac> optimization suspended, use @pl-resume to continue.
23:45:45 <sinelaw> @pl-resume
23:45:51 <lambdac> (ap id . ap id id) (ap id . ap id id) atpl
23:45:51 <lambdabot> (ap id . ap id id) (ap id . ap id id) atpl
23:45:51 <lambdabot> optimization suspended, use @pl-resume to continue.
23:45:52 <lambdac> optimization suspended, use @pl-resume to continue.
23:46:10 <Niccus> what happened
23:46:12 <sinelaw> @pl (>3)
23:46:12 <lambdac> (> 3)
23:46:13 <lambdabot> (> 3)
23:46:13 <soupdragon> @@ @
23:46:14 <lambdac> Plugin `compose' failed with: Unknown command: ""
23:46:14 <lambdabot> Plugin `compose' failed with: Unknown command: ""
23:46:20 <augur> oh well. enough of this.
23:46:24 <soupdragon> @@ @echo @@
23:46:24 <lambdabot>  echo; msg:IrcMessage {msgServer = "freenode", msgLBName = "lambdabot", msgPrefix = "soupdragon!~quantum@unaffiliated/fax", msgCommand = "PRIVMSG", msgParams = ["#haskell",":@@ @echo @@"]} rest:""
23:46:24 <lambdac>  echo; msg:IrcMessage {msgServer = "freenode", msgLBName = "lambdac", msgPrefix = "soupdragon!~quantum@unaffiliated/fax", msgCommand = "PRIVMSG", msgParams = ["#haskell",":@@ @echo @@"]} rest:""
23:47:02 <ezyang> with the help of price, here's a better version: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16828#a16829 ^^
23:47:08 <augur> hm
23:47:16 <augur> lambdabot has some interesting outputs
23:47:17 <voidprayer> I notice that the manual says GHC currently cannot compile Haskell module into shared Windows DLL. And some blogs suggest using GHC-6.8. Are these true?
23:47:20 <augur> > (> 3)
23:47:21 <lambdabot>   {-3->False;-2->False;-1->False;0->False;1->False;2->False;3->False}
23:47:23 <voidprayer> Sorry I was splitted
23:47:33 <sinelaw> splut
23:47:38 <lambdac>   mueval-core: Prelude.read: no parse
23:47:38 <lambdac>  mueval: ExitFailure 1
23:47:41 <voidprayer> sinelaw: thanks...
23:47:49 <sinelaw> j/k :)
23:48:20 <sinelaw> voidprayer, but seriously, i have no idea. maybe ghc-6.12 does
23:48:41 <sinelaw> it supports dynamic linking, so that might help (or not)
23:48:49 <voidprayer> sinelaw: i see. i have no windows here, and cannot make a test.
23:48:56 <voidprayer> sinelaw: thank you.
23:49:02 <soupdragon> @quote stereo
23:49:02 <lambdabot> monochrom says: Welcome to #haskell, where @remember's are in majestic stereo!
23:49:13 <sinelaw> @quote hifi
23:49:14 <lambdabot> No quotes match. Sorry.
23:49:19 <soupdragon> @quote fugue
23:49:20 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
23:49:32 <sinelaw> puntal?
23:49:37 * ezyang is reminded of GEB 
23:49:43 <aavogt> @quote counterpoint
23:49:43 <lambdabot> No quotes match. My brain just exploded
23:50:27 <syntaxglitch> but what about ntrapuntal cofugues?
23:51:44 <medfly> @remember @remember @remember @remember woo
23:51:44 <lambdabot> I will never forget.
23:51:48 <medfly> @quote @remember
23:51:49 <lambdabot>  @remember says: @remember @remember woo
23:51:51 <medfly> :(
23:52:10 <medfly> @forget @remember @remember @remember woo
23:52:10 <lambdabot> Done.
23:52:46 <syntaxglitch> "will never forget", huh
23:52:51 <syntaxglitch> lambdabot, you liar
23:53:11 <medfly> @quote @remember
23:53:11 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
23:53:15 <medfly> just checking
23:53:38 <medfly> @quote
23:53:38 <lambdabot> jamesbritt says: Writing Haskell, for example, involves an hour of meditation followed by the emission of a fold expression.
23:53:42 <medfly> okay, good...
23:54:22 <ezyang> +1
23:55:01 <voidprayer> Seems it is not about the netsplit, it is the bad net here...
23:57:56 <Cale> @let says = 1
23:58:02 <lambdabot>  Defined.
23:58:10 <Cale> oh, lambdac quite
23:58:12 <Cale> quit*
23:58:26 <Cale> @undefine
23:58:57 <Cale> in any case, I located a place where lambdabot can produce a line beginning with > :)
23:59:01 <Cale> @quote >
23:59:01 <lambdabot> > says: foo
23:59:17 <Cale> @forget > foo
23:59:17 <lambdabot> Done.
