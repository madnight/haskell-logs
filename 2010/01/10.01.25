00:00:08 <kmc> ah, like IO, ST, etc.?
00:00:13 <Saizan> yeah
00:00:28 <kmc> so you can stuff a continuation into a ref and use it recursively?
00:01:05 <Saizan> i think it's more about using them as forwarding pointers, but i don't remember much
00:05:55 <Saizan> it was by Magnus Carlsson, if that helps :)
00:09:23 <Saizan> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.4.86 <- looks relevant
00:11:07 <dolio> The thing is, I'm pretty sure I read someone describing a paper they wrote recently, including a remark like, "I also found a new fixpoint operation for the continuation monad."
00:15:07 <dolio> Oh yeah, that paper also talks about how it doesn't have the left-shrinking property (section 5.2), which I think other instances do.
00:16:48 <Saizan> other instances for Cont?
00:17:05 <dolio> No. Instances for other monads.
00:19:51 <dolio> Oh, right it was lpsmith, talking about his article in TMR.
00:24:26 <dolio> Oh, it doesn't have the right type to be mfix.
00:25:38 <Saizan> lpsmith_'s one?
00:25:52 <dolio> Right. It's (r -> Cont r a) -> Cont r a.
00:26:00 <dolio> Instead of (a -> ...
00:26:03 <Saizan> ah
00:27:17 <Saizan> (r -> (a -> r) -> r) -> (a -> r) -> r <- quite easy with fix
00:28:26 <Saizan> ?type \f -> fix . flip f
00:28:27 <lambdabot> forall a a1. (a -> a1 -> a) -> a1 -> a
00:35:50 <lpsmith_> is that equivalent to my mfixish?
00:35:53 <lpsmith_> hmm
00:49:59 <vegai> ghc on sparc is still alpha, right? Or is it even that?
00:56:59 <tomoj> hmm, god surely wrote the universe in haskell, not lisp, no?
00:59:50 <jrockway> nope, perl
01:00:01 <jrockway> that's why there are earthquakes, tornados, etc.
01:00:09 <Dashkal> It's just a fractal
01:00:34 <EnglishGent> <deadpan>what is? god punishing people for writing code with side effects?</deadpan>
01:00:35 <EnglishGent> :)
01:01:19 <jrockway> a black hole is what happens when you try to invoke a method on "undef", for example
01:01:31 <jrockway> and let's just say that the universe was created before there were unit tests
01:01:50 <jrockway> he tried writing it in haskell, but he never got it to compile
01:01:59 <jrockway> occurs check: universe -> [universe]
01:03:02 <jrockway> the natural world makes so much sense when you think about it from a programmer's perspective!
01:03:15 <jrockway> continental drift is "refactoring"
01:07:12 <EnglishGent> jrockway - so when does continent 2.0 get released? :)
01:11:23 <jrockway> after the "genetic algorithms" are perfected, i guess ;)
01:35:17 <vy> In "newtype Simple x y = SimpleCons { verySimple :: x -> y }" expression, "verySimple" actually has nothing to do except being a temporary alias for the function argument SimpleCons takes, right?
01:42:03 <vy> Nevermind.
01:46:11 <Saizan> verySimple is just an accessor, yeah
01:46:21 <Saizan> verySimple (SimpleCons f) = f
01:46:22 <quicksilver> well there is also the record update syntax
01:46:39 <quicksilver> and the (very simple) construction syntax
01:46:42 <quicksilver> eh
01:46:47 <quicksilver> (very similar) I meant
01:47:09 <quicksilver> stupid fingers typing what the eye can see instead of what the brain tells them to
01:50:01 <Saizan> no one told me PADL were so interesting and close to me. damn.
01:51:44 <qebab> anyone have any interesting reading about programming a compiler in haskell? :p
01:52:16 <kamatsu> there is a tutorial being posted on reddit
02:04:47 <jrockway> "being"?
02:06:39 <arw> my favourite spelling error is writing "beeing"...
02:07:39 <opqdonut> boeing
02:11:36 <sinelaw> preflex, seen Peaker
02:11:36 -preflex(n=preflex@95-88-118-220-dynip.superkabel.de)- Peaker was last seen on #haskell 7 hours, 29 minutes and 44 seconds ago, saying: s/give it/bind it
02:11:37 <sinelaw> preflex, seen PeakerWork
02:11:37 -preflex(n=preflex@95-88-118-220-dynip.superkabel.de)- PeakerWork was last seen on #haskell 10 hours, 11 minutes and 4 seconds ago, saying: pikhq: you can use a partiality monad for turing completeness
02:12:41 --- mode: ChanServ set +o Saizan
02:12:48 --- mode: Saizan set +v preflex
02:13:03 <Saizan> preflex: seen Peaker
02:13:04 -preflex(n=preflex@95-88-118-220-dynip.superkabel.de)- Peaker was last seen on #haskell 7 hours, 31 minutes and 13 seconds ago, saying: s/give it/bind it
02:13:18 --- mode: Saizan set -o Saizan
02:14:10 <Saizan> oh, duh, i ignore notices
02:18:50 <solrize> do gadt's no longer support the "data Foo :: * -> * -> *" syntax?
02:19:24 <dolio> You need KindSignatures, I think.
02:19:37 <solrize> oh, thanks.  the wikibook isn't clear on that.
02:22:01 <vy> quicksilver: What's "record update syntax"?
02:22:52 <kamatsu> vy: record_val { field = val }
02:23:15 <vy> kamatsu: Oh, I see.
02:24:49 <blackh> Does GHC have any sort of closed type functions so that you can define, for example, a function f :: a -> b -> c where a b and c can be related to each other so that type inference works?
02:25:37 <blackh> (I'm finding it difficult to believe I've found something GHC won't do!)
02:26:23 <kamatsu> blackh: uh, say again? perhaps a more concrete example
02:28:33 <blackh> kamatsu: e.g. data Pure ; data Impure ; f :: a -> b -> c  constrained so that a, b and c can be only Pure or Impure.  Cases are: f :: Pure -> Pure -> Pure ; f :: Impure -> Pure -> Impure ; f :: Pure -> Impure -> Impure; f :: Impure -> Impure -> Impure
02:28:52 <blackh> the function would have only one name (defined via a typeclass, presumably), but type inference would work.
02:29:05 <blackh> I think GHC doesn't implement this yet but I would dearly love to find some way of doing it.
02:29:32 <kamatsu> hmm
02:29:33 * ski thinks of intersection types
02:29:36 <blackh> You can almost do it with type families, but type functions are open, so the type inference doesn't work
02:30:35 <blackh> ski: Cool! What are intersection types?
02:31:31 <ski> `e :: tau0 /\ tau1' iff `e :: tau0' and `e :: tau1'
02:31:43 <solrize> i like that scala for haskellers presentation.  scalas type system actually looks more organized than haskell's in some way
02:31:45 <solrize> ways
02:32:10 <ski> cf. : `(e0,e1) :: (tau0,tau1)' iff `e0 :: tau0' and `e1 :: tau1'
02:32:37 <ski> blackh : so that `e' simultaneously has types `tau0' and `tau1'
02:32:41 <mlesniak> I'm pretty sure I'm blind, but until now I thought most of the trivial functions are already predefined. I have not found the definition of swap (a,b) = (b,a). Is it defined somewhere? (playing a kind of Code Golf and do not want to define it by myself ;-))
02:33:03 <blackh> ski: That sounds good - is that something that's implemented now, or proposed somewhere I can read about it?
02:33:16 <ski> in your case, you might have `f :: (Pure -> Pure -> Pure) /\ (Impure -> Pure -> Impure) /\ (Pure -> Impure -> Impure) /\ (Impure -> Impure -> Impure)'
02:33:18 <Saizan> blackh: typeclasses with functional dependencies, maybe?
02:33:48 <ski> blackh : there are papers about the concept .. i'm not aware of any haskell-implementation
02:34:05 <Saizan> mlesniak: snd&&&fst
02:34:16 <mlesniak> Saizan, *g*
02:34:54 <ski> @type uncurry (flip (,))
02:34:55 <lambdabot> forall b a. (a, b) -> (b, a)
02:36:55 <blackh> Saizan, ski: Thanks kindly.
02:36:58 <sinelaw> any FRP-aficionados around?
02:37:30 <blackh> sinelaw: Not as such, but I am a Yampa user who knows how to make it do stuff.
02:37:38 <blackh> Not quite the same thing. :)
02:37:42 <sinelaw> heh
02:47:40 <dolio> ski: Seems like 'Pure -> Pure -> Pure /\ Impure -> Impure -> Impure' would be empty, working from a Haskell-like base.
02:47:54 <Veinor> mlesniak: that's not predefined because it's not generally terribly useful
02:48:10 <mlesniak> Veinor, hmmm, good point
02:48:57 <dolio> Oh, except for things in (a -> a -> a), which would be knocked out by (Impure -> Pure -> Impure).
02:49:02 <sinelaw> blackh, what did/do you do with Yampa, btw?
02:49:20 <blackh> sinelaw: Working on a video game for the iPhone
02:49:33 <sinelaw> coolness!
02:49:44 <sinelaw> blackh, which game?
02:50:02 <blackh> sinelaw: It's called BloodKnight and it isn't finished yet.
02:50:21 <blackh> sinelaw: It's an action RPG
02:50:55 <ski> dolio : what if `Pure' is the subtype of `Impure' that represents expressions with no impurities, and `f' is some kind of combiner (e.g. just make an application node) ?
02:50:57 <dolio> I guess a -> b -> c could fit in, but that's empty too.
02:51:49 <sinelaw> blackh, sounds nice. i got stuck trying to implement something that takes an SF A (Event B), and outputs (for every new event) an SF T C, using an interpolation between each two last pairs of Event A's, A -> A -> SF T B
02:52:00 <dolio> Well, Haskell doesn't have any of that.
02:52:12 <sinelaw> blackh, oops, mistake there.
02:52:14 <ski> indeed
02:52:20 <sinelaw> blackh, sounds nice. i got stuck trying to implement something that takes an SF A (Event B), and outputs (for every new event) an SF T C, using an interpolation between each two last pairs of Event B's, B -> B -> SF T C
02:52:22 <sinelaw> there.
02:52:23 <ski> it doesn't have intersection types, either
02:52:49 <ski> (and the expressions there would be in some object language)
02:52:55 <sinelaw> i got pretty close, but i can't get it to work
02:53:59 <ski> (dolio : btw, i have no idea what you meant by your comments re `a -> a -> a' and `a -> b -> c')
02:54:02 <blackh> sinelaw: So the type of that would be ... err
02:54:29 <vy> Can anybody help me to understand what's wrong with http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16501 GHC complains that "No instance for (Monad (State StdGen)) arising from a use of `return'".
02:54:36 <blackh> sinelaw: SF A (Event B) -> SF T C ?
02:54:39 <sinelaw> (b -> b -> (t -> c)) -> SF a (Event b) -> SF t c
02:54:59 <dolio> ski: I mean that a function that had the type a -> b -> c could legitimately be instantiated to all those types, so it's sort of in their intersection.
02:55:43 <ski> (with `forall a b c. ', itym)
02:56:15 <blackh> sinelaw: Cogs in brain turning... (slowly because it's near midnight)....
02:56:47 <sinelaw> blackh that's when i was trying to do this, may explain my failure :)
02:57:16 <blackh> vy: You haven't made State into a Monad, so you can't use >>= and return and friends. Why not use the standard library State monad?
02:57:33 <vy> blackh: Is there any? Where?
02:57:36 <ski> vy : you haven't defined `(>>=)' nor `(>>)' nor `return'
02:57:37 <sinelaw> blackh i had first something that paired the last two events, SF a (Event b) -> SF a (Event (b,b))
02:57:41 <blackh> vy: Control.Monad.State
02:58:09 <ski> vy : also, you could say `getRandom = State random'
02:59:22 <blackh> sinelaw: Still thinking....
02:59:23 <vy> blackh: This is GHC 6.12.1 and Control.Monad.State is not in scope.
03:00:05 <blackh> vy: The package you want is mtl
03:01:13 <vy> blackh: Actually, excerpt is from ch14 of RWH, shouldn't it be working without mtl or some other library? Am I missing something?
03:01:20 <blackh> sinelaw: Shouldn't it be (b -> b -> t -> c) -> SF a (Event b) -> SF (a, t) c ?
03:01:30 <blackh> sinelaw: Otherwise where does the a come from?
03:01:55 <Saizan> vy: mtl used to be shipped with ghc
03:01:57 <blackh> vy: mtl is part of the standard libraries but ghc 6.12.1 is stripped right down.
03:02:30 <sinelaw> blackh, yeah, probably
03:03:23 <blackh> sinelaw: Well, that should work fine in Yampa.  You got the last two events paired... that's not too hard using accumHold
03:03:47 <c_wraith> As I understand it, 6.12 is no longer considering anything beyond what it needs to run and haskell 98 compatibility as a standard package.  Platform is being expanded to include the things that used to be part of 6.10 but were dropped from 6.12
03:04:46 <anee> is there a list of what libraries are part of the standard libraries, but not shipped with the default ghc installation somewhere?
03:04:53 <sinelaw> blackh, i'll re-try it sometime
03:04:58 <sinelaw> not urgent
03:05:00 <blackh> sinelaw: There's another problem ... the type probably needs to be...
03:05:21 <Saizan> anee: see the list of libs in the haskell-platform
03:05:30 <blackh> sinelaw: (b -> b -> t -> c) -> SF a (Event b) -> SF (a, t) (Event c)  ... the reason being that you don't always have something to output.
03:05:42 <blackh> sinelaw: Well, track me down if you get stuck
03:06:21 <sinelaw> blackh, that's exactly what i'm trying to avoid. i want t to be time and to always output the interpolation between the two last events. i want discrete -> continuous
03:08:04 <blackh> sinelaw: Oh right. I'm with ya.  That would be fine.  You will also need a default b value, but that becomes obvious pretty quickly, so then it needs to be .... b -> (b -> b -> t -> c) -> SF a (Event b) -> SF (a,t) c
03:08:15 <anee> Saizan: thanks!
03:09:55 <sinelaw> blackh, right, that clears it up a bit
03:10:17 <ivanm> greetings, sinelaw
03:10:37 <sinelaw> hey ivanm
03:11:04 * ivanm just got home today, so will be investigating the profiling results of grpahviz over the next few days
03:11:47 <sinelaw> cool
03:12:02 <sinelaw> i can't imagine how much work i've been dealing out to people here
03:12:12 <sinelaw> :) hopefully some of mine will get done eventually as well
03:16:40 <ivanm> heh
03:16:49 <ivanm> sinelaw: why, which other suckers have you conned into helping you?
03:17:05 <sinelaw> luqui, but only a tiny bit
03:17:48 <vy> In ghci, is it possible to list all exported symbols by a particular module?
03:18:17 <ivanm> vy: :browse
03:18:31 <vy> ivanm: Thanks.
03:18:44 <ivanm> no worries
03:34:46 <mreh> how does one concat map inside IO monad in a haskelly way
03:35:23 <Beelsebob> using the concatMap function?
03:35:38 <Beelsebob> do you mean, how does one concatMap over a list that's in the IO Functor?
03:36:34 <mreh> rather, map a function :: a -> [b] to a list [a] and concat the results
03:36:50 <mreh> rather, map a function :: a -> IO [b] to a list [a] and concat the results
03:37:24 <mreh> so i get (a -> IO [b]) -> [a] -> IO [b]
03:37:27 <Beelsebob> @type concat . sequence . map
03:37:28 <lambdabot>     Couldn't match expected type `[[a]]'
03:37:29 <lambdabot>            against inferred type `[a1] -> [b]'
03:37:29 <lambdabot>     Probable cause: `map' is applied to too few arguments
03:37:34 <Beelsebob> @type sequence . map
03:37:35 <lambdabot>     Couldn't match expected type `[m a]'
03:37:35 <lambdabot>            against inferred type `[a1] -> [b]'
03:37:35 <lambdabot>     Probable cause: `map' is applied to too few arguments
03:37:42 <Beelsebob> @type sequence
03:37:43 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
03:37:57 <Beelsebob> oh, I'm missing a .
03:37:58 <mreh> thats for [IO b] -> IO [b]
03:38:05 <Beelsebob> right... but
03:38:05 <dolio> @type mapM
03:38:06 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
03:38:13 <Beelsebob> indeed
03:38:25 <mreh> oh, sequence list monad
03:38:43 <Beelsebob> @type \f a -> concat <$> mapM f a
03:38:45 <lambdabot> forall a a1 (f :: * -> *). (Monad f, Functor f) => (a1 -> f [a]) -> [a1] -> f [a]
03:39:03 <mreh> <$> = fmap?
03:39:06 <Beelsebob> yep
03:39:14 <mreh> `fmap`
03:39:25 <Beelsebob> @src (<$>)
03:39:26 <lambdabot> f <$> a = fmap f a
03:39:27 <mreh> = liftM
03:39:51 <Beelsebob> yeh, but why call it liftM/liftA when it's already got a nice name
03:40:41 <mreh> all this monads are functors isn't intuitive to me
03:40:50 <Beelsebob> why not?
03:40:50 <Veinor> @src map
03:40:50 <lambdabot> map _ []     = []
03:40:51 <lambdabot> map f (x:xs) = f x : map f xs
03:40:53 <Beelsebob> @src liftM
03:40:54 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
03:41:00 <dobblego> mreh, write fmap using (>>=) and return
03:41:00 <Beelsebob> ^ look, you can define fmap
03:41:12 <Beelsebob> it's that simple
03:42:08 <mreh> aha
03:42:31 <Beelsebob> all monads are functors, because you can define fmap in terms of monad operations
03:43:04 <dolio> All monads are functors because the definition of a monad is "a functor together with two natural transformations ...".
03:43:11 <Beelsebob> hehe
03:43:13 <mreh> heh
03:43:24 <Beelsebob> that too
03:43:30 <Beelsebob> in haskell terms, it's my explanation
03:43:35 <Beelsebob> in mathematical terms it's dolio's
03:43:57 <Beelsebob> mreh: note, (>>=) *theoreticall* should be defined in terms of fmap
03:43:57 <idnar> Beelsebob: you should probably say Monads and Functors then, to make it a little more clear that you mean the typeclasses
03:44:00 <mreh> those being unit and bind
03:44:13 <Beelsebob> idnar: point
03:44:20 <Beelsebob> mreh: nope, pure and join
03:44:24 <idnar> Beelsebob: I don't think you can define (>>=) in terms of fmap without join, can you?
03:44:30 <Beelsebob> bind is defined in terms of fmap and join mreh
03:44:47 <Beelsebob> idnar: nope, you need join indeed
03:44:48 <mreh> join . fmap
03:44:57 <idnar> and then if you throw in Applicative it's just a mess anyway
03:44:58 <Beelsebob> fmap fmap fmap join fmap
03:45:06 <idnar> fmap join badgers
03:45:09 <kamatsu> Beelsebob: That is assuming that Monad requires Functor, which it actually doesn't in Haskell for some reason
03:45:23 <Beelsebob> kamatsu: right – as I said – theoretically
03:45:23 <mreh> did I get it right?
03:45:32 <idnar> @type join . fmap
03:45:33 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a)
03:45:33 <lambdabot>     Probable cause: `fmap' is applied to too few arguments
03:45:33 <lambdabot>     In the second argument of `(.)', namely `fmap'
03:45:35 <Beelsebob> mreh: nope, because fmap takes two arguments
03:45:40 <idnar> the type checker doesn't think so
03:45:42 <Beelsebob> @type fmap fmap fmap join fmap
03:45:43 <lambdabot> forall a a1 (f :: * -> *). (Monad f, Functor f) => (a1 -> f a) -> f a1 -> f a
03:46:04 <idnar> fmap fmap fmap is just silliness ;)
03:46:05 <idnar> @type (>>=)
03:46:06 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
03:46:07 <Beelsebob> yes it is
03:46:08 <Beelsebob> >.>
03:46:11 <mreh> fmap fmap fmap
03:46:12 <lvh> my brain just exploded
03:46:15 <idnar> and you need a flip in there anyway
03:46:20 <mreh> lvh: get used to it
03:46:23 <Beelsebob> you do, but (=<<) is nicer anyway
03:46:26 <idnar> @type fmap fmap fmap
03:46:27 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
03:46:29 <ski> @type (join .) . fmap
03:46:29 <Beelsebob> so I prefer to define it
03:46:30 <lambdabot> forall (m :: * -> *) a a1. (Monad m, Functor m) => (a1 -> m a) -> m a1 -> m a
03:46:31 <lvh> mreh: I don't actually know any haskell, that probably doesn't help
03:46:42 <lvh> mreh: I understand those signatures though! woo
03:46:42 <dang`r`us> don't worry, those are all smileys
03:46:43 <idnar> lvh: fmap fmap fmap is just fmap . fmap, if that helps
03:46:47 <dang`r`us> Haskell looks vastly different
03:46:53 <mux> lvh: that happens a lot around here; just make sure to clean the mess afterwards, we don't rotting pieces of brain to stick to the topic.
03:46:59 <mreh> lvh: you don't need to understand the mathematics, just get used to it
03:47:00 <lvh> idnar: my brain exploded *because* I understand what it says
03:47:09 <Beelsebob> lvh: which importantly in this case is *also* ((.) . (.))
03:47:12 <idnar> lvh: oh, it usually goes the other way around for me
03:47:22 <Veinor> the boobies combinator
03:47:33 <lvh> Beelsebob: clearly third-nipple-boobies are the essence of haskell
03:47:39 <mreh> (.) = fmap
03:47:43 <Beelsebob> lvh: absolutely they are
03:48:01 <mreh> :t (.) (.) (.)
03:48:02 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
03:48:05 <idnar> anyway, I would usually just write x >>= f = join (fmap f x)
03:48:07 <mreh> total recall operator
03:48:14 <Veinor> haha
03:48:15 <Beelsebob> idnar: right, that would be what a sane person does
03:48:38 <idnar> Beelsebob: haha
03:48:58 <idnar> Beelsebob: (that's funny because nobody would ever confuse me with a sane person)
03:49:03 <Beelsebob> haha
03:49:35 <mreh> why have we designated fmap an operator?
03:49:42 <mreh> is it because <$> is also applicative
03:49:53 <Beelsebob> no, <$> is always for functors
03:49:57 <Beelsebob> it's <*> that's applicative
03:49:57 <idnar> mreh: designated?
03:50:10 <Beelsebob> and you can combine the two to make liftAn prettily
03:50:12 <idnar> mreh: oh, you mean (.) as fmap?
03:50:28 <mreh> idnar: (<$>) = (.) = fmap
03:50:43 <mreh> :t (.)
03:50:44 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
03:50:45 <Beelsebob> mreh: (.) actually doesn't = fmap, unless you're writing caleskel
03:50:55 <idnar> mreh: there are a number of reasons why (.) as fmap makes sense, most of which I can't remember ;)
03:51:12 <idnar> mreh: but I suppose the most obvious one is that fmap = (.) for Functor (r ->)
03:51:13 <Beelsebob> (.) is fmap restricted to functions
03:51:19 <ski> idnar : "it works in the `(r ->)' functor"
03:51:29 <ski> same, re
03:51:32 <ski> @type flip
03:51:33 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
03:51:46 <lvh> I wish I could do something in Haskell. Unfortunately none of the stuff I'm doing right now is very fitting.
03:51:47 <mreh> @pl f (a . b)
03:51:47 <lambdabot> f (a . b)
03:51:48 <idnar> oh, I hadn't seen that one
03:51:58 <mreh> @pl f (a . b) c
03:51:59 <lambdabot> f (a . b) c
03:52:08 <idnar> @src flip
03:52:09 <lambdabot> flip f x y = f y x
03:52:16 <idnar> how do you define that one?
03:52:18 <ski> @pl foo f a b c = f (a . b) c
03:52:19 <lambdabot> foo = (. (.)) . (.)
03:52:26 <ski> @pl foo f a b = f (a . b)
03:52:26 <lambdabot> foo = (. (.)) . (.)
03:52:28 <mreh> good god
03:52:37 <mreh> which is easier to read?
03:52:39 <ski> (or maybe `f' shouldn't be a parameter ?)
03:52:48 <mreh> ski, no
03:53:09 <ski> idnar : define what ?
03:53:13 <idnar> @type flip f a = fmap ($ a) f
03:53:14 <lambdabot> parse error on input `='
03:53:18 <idnar> @type let flip f a = fmap ($ a) f in flip
03:53:19 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
03:53:35 <mreh> @pl foo a b = f (a . b)
03:53:36 <lambdabot> foo = (f .) . (.)
03:53:47 <idnar> is there a better definition than that?
03:54:02 <ski> @type let flip' = flip fmap f . flip ($) in flip'
03:54:03 <lambdabot> forall a (f :: * -> *) b. (SimpleReflect.FromExpr (f (a -> b)), Functor f) => a -> f b
03:54:08 <ski> er
03:54:12 <ski> @type let flip' = flip fmap . flip ($) in flip'
03:54:13 <lambdabot> forall a a1 b. a -> (a1 -> b) -> (a -> a1) -> b
03:54:17 <idnar> @pl flip f a = fmap ($ a) f
03:54:17 <lambdabot> flip = fix (flip . (fmap .) . ($ id))
03:54:36 <idnar> fix? seriously, pl?
03:54:59 <sinelaw> wow
03:55:43 <idnar> @pl flip' f a = fmap ($ a) f
03:55:44 <lambdabot> flip' = flip (fmap . flip id)
03:55:47 <idnar> right
03:56:06 <idnar> so that doesn't really help
03:56:12 <dolio> @pl ap f = (\f g x -> f x (g x)) f
03:56:13 <lambdabot> ap = const (join ap)
03:56:38 <dolio> @pl ap f = f (\f g x -> f x (g x))
03:56:39 <lambdabot> ap = ($ const (join ap))
03:56:53 <idnar> @pl ap' f = (\f g x -> f x (g x)) f
03:56:53 <lambdabot> ap' = const (join ap)
03:57:39 <ski> that looks nice, somehow
03:57:54 <idnar> @type const (join ap)
03:57:54 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b
03:57:55 <lambdabot>       Expected type: m (a -> b) -> m (a -> b) -> a1
03:57:55 <lambdabot>       Inferred type: m (a -> b) -> m a -> m b
03:57:56 <sinelaw> we should hold an annual pl contest
03:58:09 <idnar> naughty pl
03:58:10 <sinelaw> nicest pl gets first prize, date with vixen
03:58:16 <sinelaw> @vixen what do you think
03:58:16 <lambdabot> let's don't talk about that
03:58:24 <idnar> a date with vixen sounds interesting
03:58:37 <sinelaw> @vixen, pl ap' f = (\f g x -> f x (g x)) f
03:58:37 <lambdabot> You think this is a botiecall??
03:58:56 <lvh> I left perl because of things that look eerily similar to this
03:59:00 <idnar> I'll pay the winner of the contest if they'll let me observe the date
03:59:16 <dolio> @pl ap = ($ const (join ap))
03:59:16 <lambdabot> ap = fix (flip id . const . join)
03:59:18 <idnar> lvh: the difference is that Haskell programmers aren't serious about it ;)
03:59:28 <lvh> idnar: oh. hard to tell sometimes ;-)
03:59:50 <ToRA> @pl (\(x,y) -> (y,x))
03:59:50 <lambdabot> uncurry (flip (,))
03:59:51 <lvh> anyone know if there's been any serious progress regarding libevent/epoll/kqueue/gcd/... support in ghc?
04:00:18 <mux> there have been a few blogs posts about it, showing nice performance improvements for some benchmarks
04:00:19 <lvh> as soon as that happens I might consider quitting Erlang/OTP
04:00:31 * ski . o O ( `gcd' ?)
04:00:32 <mux> it seems to be in a good shape for getting into the tree soon
04:00:35 <lvh> mux: yeah, I predicted thread-per-conn being terrible
04:00:39 <lvh> ski: grand central dispatch
04:00:48 <mux> lvh: no offense, but that wasn't hard to predict :D
04:00:57 <idnar> I don't understand what gcd has to do with kqueue, epoll, and libevent
04:01:10 <lvh> mux: I'll leave it up to you if I'm psychic or just exprienced (longer than 2 minutes)
04:01:17 <idnar> lvh: http://www.serpentine.com/blog/2010/01/11/progress-on-ghcs-io-manager/
04:01:27 <mux> lvh: maybe both, actually!
04:01:34 <idnar> lvh: what do you mean by thread-per-conn?
04:01:48 <alex404> Does anyone have any idea why ghc doesn't seem to think Graphics.UI.Gtk doesn't exist even though I've installed gtk2hs?
04:01:49 <mux> yeah, btw, the problem is not a "thread per connection" problem
04:01:58 <mux> it's the usual poll()/select() scaling problem
04:02:00 <lvh> idnar: Doing a blocking read in a new thread for every new connection
04:02:09 <alex404> (unintended double negative alert)
04:02:10 <idnar> lvh: are we talking about Haskell now, or what?
04:02:16 <kamatsu> alex404: how did you compile it?
04:02:34 <alex404> kamatsu: Archlinux pacman
04:02:38 <kamatsu> alex404: as in, how did you compile your program
04:02:50 <lvh> idnar: Yes. I tried to figure out how to do async IO a few months back, and people told me to use something that basically amounted to blocking connections in threads.
04:02:55 <alex404> kamatsu: I'm just trying to load it into ghci
04:03:02 <idnar> lvh: "blocking read in a new thread" means something very different in Haskell to what it might mean in other languages
04:03:08 <alex404> kamatsu: Running through a little hello world tutorial
04:03:14 <kamatsu> that's odd
04:03:20 <kamatsu> have you tried ghc --make?
04:03:22 <lvh> mux: Right. Either way, getting rid of treads is usually nice.
04:03:37 <idnar> lvh: forkIO gives you a lightweight Haskell thread (somewhat similar to Erlang processes), and the "blocking read()" just yields back to the I/O manager
04:03:38 <lvh> idnar: Probably, but it suffers from identical performance issues.
04:03:44 <lvh> idnar: Right.
04:03:49 <alex404> kamatsu: What would that do? My 'program'  is 9 lines.
04:03:52 <idnar> lvh: the only performance issues it suffers from are select vs. epoll
04:04:01 <lvh> idnar: And it also dies at around 1000-2000 connections, like every select()-based thing out there
04:04:06 <kamatsu> alex404: compile the program with ghc --make blah.hs
04:04:18 <kamatsu> alex404: --make makes ghc figure out your dependencies for you
04:04:29 <lvh> idnar: Yes, I understand that the actual problem is select() ;-)
04:04:31 <kamatsu> alex404: ghci should do that, but you might get a more informative error message this way
04:05:06 <alex404> kamatsu: Same deal: Could not find module `Graphics.UI.Gtk'
04:05:13 <kamatsu> hm
04:05:14 <idnar> lvh: "suffers from identical performance" issues is rather inaccurate, then
04:05:27 <idnar> lvh: select() on 1024 sockets is way more efficient than 1024 OS threads blocking on read()
04:05:35 <alex404> kamatsu: ghc-pkg doesn't seem to acknowledge the existence of this stuff either
04:06:14 <kamatsu> alex404: was just about to ask
04:06:14 <idnar> lvh: (sorry if it seems like I'm being unreasonably pedantic about this stuff, there's just a lot of misinformation out there about network / async IO programming)
04:06:18 <mux> lvh: also, haskell wouldn't have a problem with tens of thousands of threads if they're all waiting on the same file descriptor :-)
04:06:22 <kamatsu> alex404: tried reinstalling from cabal?
04:06:27 <lvh> idnar: it's okay, I'm usually worse than you
04:06:33 <mux> fwiw
04:06:36 <alex404> kamatsu: I'll try once more for good measure
04:06:49 <kamatsu> alex404: pay attention to the output from cabal when you install it
04:07:09 <lvh> idnar: but my day job is hacking on an async library, so I might be biased
04:07:23 <idnar> lvh: heh, fun
04:07:43 <lvh> idnar: but yeah, I don't think anyone actually does 1024 OS threads blocking on read()
04:07:53 <lvh> idnar: excpet a few idiots that think Python's stdlib is full of nice things
04:08:01 <alex404> kamatsu: Errm. You mean use 'cabal install gtk2hs' right? Because it doesn't think that package exists.
04:08:05 <idnar> lvh: people using APache do 1024 OS processes blocking on read() :(
04:08:13 <lvh> idnar: tee hee
04:08:20 <lvh> idnar: apache
04:08:22 <idnar> lvh: and then they wonder why their server grinds to a halt when someone sneezes in their direction
04:08:27 <kamatsu> alex404: cabal update
04:09:01 <theclaw> the only way to modify the environment in the reader monad is using "local"?
04:09:11 <idnar> lvh: apparently Java programmers also do 1024 OS threads blocking on read()
04:09:15 <lvh> idnar: at least in Haskell it's marginally less bad than in Java, where a thread may or may not mean OS thread (the vm usually picks the worst option)
04:09:16 <ski> theclaw : yes
04:09:18 <idnar> lvh: my day job involves hacking on a Mantissa app (so using Twisted etc. under the hood)
04:09:20 <lvh> idnar: sometimes
04:09:43 <lvh> idnar: my day job involves twisted, unfortunately not as much as I want to due to medical issues
04:09:44 <alex404> kamatsu: Still no dice. cabal list gives me a bunch of extensions to the gtk2hs library, but doesn't list gtk2hs itself
04:09:52 <idnar> lvh: we had a network outage, so after connectivity was restored, our system tried to send about 200 queued messages to this other system
04:10:00 <kamatsu> alex404: what ghc are you using?
04:10:04 <lvh> idnar: twisted is said library :-)
04:10:06 <alex404> alex404: 6.12
04:10:13 <alex404> kamatsu: 6.12 even
04:10:16 <idnar> lvh: I think we limit parallelism to about 10 requests in parallel, but that was still enough to trigger frantic phone calls asking us to please stop clobbering their system
04:10:28 <lvh> idnar: didn't you use to work for TwistedMatrix?
04:10:35 <lvh> idnar: ha ha
04:10:40 <idnar> lvh: no, I'm just a community contributor
04:10:56 <kamatsu> alex404: hm, gtk2hs does not yet support ghc 6.12 afaik
04:11:08 <idnar> lvh: actually, I think I've contributed about a total of one patch to Twisted; I've contributed a lot more to Mantissa/Nevow/Axiom/etc. though
04:11:12 <alex404> kamatsu: Ahhh.
04:11:15 <kamatsu> alex404: your safest bet is to downgrade ghc and cabal install to their previous versions
04:11:22 <kamatsu> alex404: the Haskell platform has not caught up to GHC
04:11:27 <theclaw> ski: thanks
04:11:27 <idnar> lvh: I mostly just hang around in #twisted and on the mailing list and try to sound cool and intelligent
04:11:39 <lvh> idnar: Ah. I'm using Nevow, but only because my app is very naturally described as serverside push
04:11:41 <kamatsu> alex404: I am holding them back in my pacman.conf file until the platform moves onto 6.12
04:11:51 <alex404> kamatsu: I see. Is it not always such a good idea to stay up to date with ghc?
04:11:51 <lvh> idnar: and it turns out nevow is really good at that
04:11:57 <idnar> lvh: using Athena?
04:12:09 <kamatsu> alex404: no, best to stay up to date with the Haskell Platform, which is still at 6.10 atm
04:12:23 <alex404> alex404: Is there some official 'haskell platform' or something?
04:12:25 <lvh> idnar: Yep.
04:12:59 <lvh> idnar: Someone I know is writing a pretty cool AQMP-to-Twisted-to-Comety thing which hopefully is what I eventually use
04:13:02 <alex404> kamatsu: (answered my own question there)
04:13:23 <alex404> kamatsu: (googling isn't too hard)
04:13:25 <kamatsu> alex404: ah, yes, there is an official haskell platform
04:13:38 <kamatsu> alex404: don't use the linux installer for it tho
04:13:39 <lvh> idnar: if you know AMQP: browsers end up registering as consumers
04:13:44 <yaxu> Mind you I'm having problems getting stuff running under the haskell platform that's written to ghc 6.12
04:13:47 <kamatsu> alex404: I recommend just using the ghc and cabal versions i have
04:13:52 <kamatsu> alex404: i'll let you know in a minute
04:13:57 <kamatsu> alex404: then just hold them back in pacman.conf
04:14:04 <kamatsu> alex404: until the platform moves on, then you know it's safe to upgrade
04:14:07 <int-e> gtk2hs has not been cabalized. you have to do the configure-make-install dance, and for ghc 6.12.1 you need some patch that appeared on the gtk2hs-devel list.
04:14:18 <kamatsu> int-e: wait, they did a patch?
04:14:21 <alex404> kamatsu: Cool. What do I need to do to pacman.conf, exactly?
04:14:28 <alex404> kamatsu: I've never rolled anything back before.
04:14:50 <kamatsu> alex404: now, rolling back is separate from keeping back
04:14:53 <int-e> kamatsu: http://sourceforge.net/mailarchive/message.php?msg_name=1260471581.13548.13986.camel%40localhost
04:14:58 <idnar> lvh: yeah, I've dabbled with AMQP a bit, haven't started actually using it for anything yet
04:15:08 <kamatsu> alex404: first you should probably remove all haskell packages
04:15:21 <kamatsu> alex404: if this is infeasible, then, erm, problematic
04:15:27 <idnar> lvh: we probably won't use it on the frontend / in the browser, but I have some idea for using it on our backend
04:15:32 <int-e> kamatsu: with some caveats: haddock doesn't work, and split-objs doesn't work, so you'll have to use configure --disable-split-objs
04:15:37 <alex404> kamatsu: I can rip em all out
04:15:44 <kamatsu> alex404: okay, do so
04:15:46 <lvh> idnar: same, mostly due to previously said medical issues
04:15:55 <alex404> kamatsu: Might take a second...
04:16:02 <lvh> idnar: my app naturally divides in a live-following-of-messages part and a not-so-live looking at processed data bit
04:16:03 <kamatsu> yep
04:16:32 <lvh> idnar: basically the browser is a consumer to facilitate the former, and the database is a consumer to facilitate the latter
04:17:25 <Peaker> idnar: why would 1000 threads in read() be worse than select with 1000 sockets? The former has at least a chance to be optimized by the kernel (only waking up the relevant threads) whereas the latter constantly has to copy tables of 1000 FD's every time select return
04:18:09 <idnar> Peaker: unless you have a seriously magic kernel, 1000 threads will just choke the system
04:18:27 <Peaker> idnar: why would sleeping threads be a problem? They just sit there :)
04:18:41 <lvh> Peaker: except when they don't
04:18:50 <idnar> Peaker: there's quite a bit of overhead for each of those threads
04:18:56 <idnar> Peaker: not to mention what happens when they all wake up at once
04:19:09 <idnar> and your load average goes to 1000 with context switches using 90% of your CPU time
04:19:19 <JohnDoe365> I searched hackage for "packrat" or "peg" but ton no avail. Are there any maintained pure haskell PEG parsers?
04:19:24 <Peaker> if they are woken up by fd activity - then they all work, and it will be just the same amount of CPU work as select-1024, though with a little more contention
04:19:52 <Peaker> idnar: I don't think context switches are that expensive -- have you seen that happen? How do you know 90% was context switches?
04:20:00 <lvh> Peaker: empirical evidence suggests "a little more contention" is an understatement
04:20:27 <dolio> JohnDoe365: I don't know how maintained it is, but frisby is one. You won't find it on hackage, though, because its author doesn't like cabal.
04:20:42 <solrize> JohnDoe365, there's a packrat parser on hackage that works... i don't know if it's "maintained" but i've used it
04:20:50 <alex404> kamatsu: Alright, think I'm all good to go
04:20:55 <idnar> Peaker: it was a guesstimate based on how much CPU time was being used by the processes/threads
04:20:56 <Peaker> I dislike the thread-per-connection model as much as the next guy, but I don't think 1000 threads hits a significant performance problem with I/O (but it does hit plenty of other problems, including locks-related performance issues)
04:20:57 <dolio> Frisby is a combinator library. There's also a parser generator... pappy maybe?
04:21:20 <idnar> Peaker: context switches aren't that expensive, but when you have 1000:1 contention...
04:21:40 <Peaker> idnar: well, if they're all waiting on the same lock, that can be a problem in some kernels, yeah
04:22:05 <lvh> Peaker: every practical example of tpc-like systems ends up failing catastrophically around the same number of connections
04:22:16 <kamatsu> alex404: see pm
04:22:21 <Peaker> lvh: well, that number is probably not 1000 :)
04:22:29 <lvh> Peaker: what do you base that on
04:22:38 <JohnDoe365> dolio:i discovered firsby by go oogle but was timid as i couldn't find it on hackage .. will give it a try
04:22:42 <idnar> Peaker: on a uniprocessor system, any load average over about 20 already puts your system in a fairly bad state of health
04:22:42 <alex404> kamatsu: ?
04:22:50 <Peaker> lvh: the system I work with at work uses a thread pool of 1000 active threads (I hate it! but it doesn't have significant performance penalties)
04:22:54 <idnar> Peaker: by the time you reach 1000, it's practically unusable
04:23:06 <kamatsu> alex404: I've sent you private messages with the links in them
04:23:13 <JohnDoe365> solrize: Do you have a package name? I search hackage and hoogle for peg and packrat but no results ...
04:23:14 <kamatsu> alex404: just cos it would be spammy to post them here
04:23:16 <alex404> kamatsu: Ahh ;)
04:23:32 <lvh> Peaker: I don't know enough about your system to make an intelligent comment about it
04:23:32 <solrize> JohnDoe365, i was just looking for it and don't see it, maybe it wasn't on hackage, let me look some more
04:23:33 <idnar> Peaker: it might take hours just to deliver a SIGKILL to one of the processes
04:23:39 <Peaker> idnar: Our 1000-thread system is very usable and it has performance issues regarding latency/locks (passing around shared data) but not really a problem w.r.t I/O calls
04:24:07 <idnar> Peaker: presumably you don't have 1000 threads all waking up at once
04:24:08 <Peaker> lvh: well, you asked how I know that 1000 isn't that number :)
04:24:17 <Peaker> idnar: We do have 1000 threads all active at once
04:24:32 <lvh> Peaker: I find that extremely hard to believe.
04:24:41 <idnar> Peaker: I don't really understand how you keep the system up under those conditions
04:24:41 <Peaker> lvh: why?
04:24:47 <Peaker> idnar: 1000 threads is not that much
04:24:58 <lvh> Peaker: I've seen hundreds of systems fail horribly under similar conditions, and apparently so has idnar
04:25:15 <idnar> Peaker: if I push my desktop system to a load average of 200, it takes me 15 minutes just to get a new shell prompt
04:25:22 <lvh> Peaker: anecdotal evidence regarding one system that I've never seen let alone understand does not change my mind
04:25:29 <idnar> Peaker: granted, it's only a uniprocessor system, but still...
04:25:45 <Saizan> different kinds of threads?
04:25:57 <lvh> Saizan: I think he specifically mentioned OS threads earlier
04:26:11 <Saizan> well, the OS might provide different kinds of threads
04:26:27 <Peaker> its 1000 os threads and they either all sleep on a mutex, or they all do some I/O
04:26:37 <Peaker> and a bit of CPU work
04:26:41 <idnar> 1000 threads isn't that much if only 2 or 3 are actually running at the same time
04:26:46 <idnar> if they're all scheduled to run at the same time, though...
04:26:59 <McManiaC> anyone here working with hscurses? I get the error message "Loading package hscurses-1.3.0.2 ... can't load .so/.DLL for: ncurses (/usr/lib/libncurses.so: file too short)" when trying to do anything with it
04:27:08 <McManiaC> I'm running arch linux x86_64
04:27:20 <vegai> McManiaC: oh, that silly error
04:27:20 <Saizan> McManiaC: make sure your /usr/lib/libncurses.so is not a linker script
04:27:34 <vegai> yeah, it is.
04:27:36 <solrize> JohnDoe365, the thing i was thinking of doesn't seem to be around any more.  it was used by a weird slow json package written in japan, that json.org used to point to under "haskell"
04:27:53 <McManiaC> Saizan: how do I avoid this?
04:28:10 <McManiaC> INPUT(-lncursesw)
04:28:11 <Saizan> McManiaC: make it a symlink to the binary
04:28:12 <Peaker> idnar: anyhow, for latency issues we're going to switch to a 1000-coroutine solution later
04:29:05 <McManiaC> Saizan: okay, works
04:29:05 <McManiaC> thx
04:38:12 <luite_> does anyone know when gtk2hs is supposed to officially support ghc 6.12?
04:39:29 <burp> unofficially it does for me :>
04:39:46 <burp> luite_: did you remember to use --disable-split-objs?
04:41:27 <luite_> burp: yes, it does seem to work on linux with the patch, but I haven't been able to build it for windows yet (haven't tried too hard though, maybe I just made some mistake)
04:41:39 <burp> oh windows, ok
04:42:59 <luite_> gtk2hs does seem rather undermaintained currently...
04:43:39 <kowey> what does this cabal-install output mean? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16513#a16513
04:44:04 <kowey> cabal-install insists on reinstalling regex-posix and test-framework repeatedly
04:44:58 <Saizan> you're using only packages as they are on hackage, right? no customization?
04:45:27 <kowey> as far as I know -- I do have a customised pandoc, but that's under a separate name (pandoc-kowey)
04:45:30 <Heffalump> I think that situation arises when you're building Z that depends on X and Y, and X and Y have managed to get built against different versions of W.
04:45:53 <Heffalump> but I could be wrong. I've certainly seen similar behaviour myself without fully understanding it.
04:46:35 <Saizan> if it doesn't reach a fixed point something is indeed fishy
04:46:44 <Saizan> kowey: can you paste ghc-pkg list too?
04:46:55 <burp> luite_: maybe you can give me an idea how to do this with gtk2hs: I want to modularize some part of the application (popup for some login process) so I create an onClicked handler for the login button
04:47:21 <burp> the handler itself uses a new function to open the popup
04:47:31 <burp> and declare some onClicked handler on that popup window
04:47:31 <kowey> heh, I figured somebody would ask :-), pasted
04:47:39 <luite_> burp: sorry I don't know much about creating gui's with gtk2hs, I mostly use the package for Cairo
04:47:56 <burp> but if you now use that popup more than once, the onClicked handlers get declared more than once
04:48:10 <Saizan> kowey: currently it has decided to reinstall regex-posix under the new regex-base, and so to reinstall test-framework against this new regex-posix
04:48:12 <burp> and are so called more than once after you opened the login-popup often
04:48:15 <burp> luite_: ok
04:48:19 <kowey> one thing is that I've recently upgraded from cabal-install 0.6.x to 0.8.x
04:48:42 <kowey> but then when I run that cabal install test-framework a second time, it still goes through this?
04:49:13 <Saizan> kowey: ah, you've regex-posix installed both in the global and user dbs
04:49:17 <Saizan> kowey: that's bad :)
04:49:34 <Saizan> kowey: ehm, the same exact version of regex-posix i mean
04:49:48 <kowey> oh... I think that may be because I have library-profiling: True  in my ~/.cabal/config
04:50:02 <Saizan> no, that shouldn't be
04:50:08 <kowey> oh, hmm!
04:50:33 <Saizan> however, i think this time it might actually succeed
04:50:45 <JohnDoe365> solrize:Thank you, I will give fisby a try
04:50:53 <Saizan> in the sense that if you now use the new regex-base it'll stop recompiling
04:51:00 <solrize> – We use dependently kinded witness types to encode information about pu-
04:51:00 <solrize>   rity, constancy and mutability in the intermediate language.
04:51:17 <Saizan> assuming the build gets through
04:51:22 <kowey> well, my symptom is still repeated re-installing ... do I need to do something special?
04:51:31 <kowey> like nuking a package somewhere?
04:51:33 <solrize> dependent kinds?  is that even hairier than dependent types?
04:51:56 <dmwit> Not really.
04:51:58 <Saizan> kowey: try nuking all the packages you've with the same version in both dbs
04:52:03 <kowey> nuking away!
04:52:33 * kowey defines nuke and ghc-pkg unrgesister here...
04:52:36 <dmwit> In fact, most languages with dependent types just have dependency all the way up the chain.
04:52:41 <kowey> *as*
04:52:46 <solrize> hmm
04:53:27 <Saizan> kowey: you'd need --global to nuke from the global db
04:59:38 <mreh> how can I get at the text a Parsec Parser has matched?
05:01:28 <kowey> Saizan: whoops, work distracting me from Haskell... thanks for the help! I'll pick this up later (sigh)
05:03:37 <interferon> what's a good tutorial for learning arrows?
05:04:48 <kamatsu> +1 to interferon's question
05:05:33 <ToRA> generalising monads to arrows I remember being a good paper, but maybe because that's what forced me to crystallise monads in my mind
05:05:46 <interferon> i liked that paper too
05:05:56 <interferon> but it's not quite getting me across teh gap
05:06:27 <solrize> typeclassopedia is ok to start but is just a start
05:07:20 <Saizan> http://www.haskell.org/arrows/biblio.html#Hug05 ? quite similar to Hug00 i guess..
05:07:44 <ToRA> my problem with arrows is I think I understand the 'how' (the machinary), and I can rote-recall the 'why' (what other people think they're good for), but I don't really believe it.
05:07:52 <interferon> exactly
05:08:11 <Saizan> "believe"?
05:08:34 <interferon> well, not exactly to the believe
05:08:43 <interferon> but exactly to the how as opposed to the why
05:08:50 <ToRA> possibly too strong a word
05:09:52 <Saizan> the stronger why is when you've something you can't make a monad, usually because you don't want to lose some introspection abilities
05:10:16 <Saizan> how common that situation is in practice is another problem
05:10:24 <ski> Swierstra's and Duponcheel's parsers ..
05:10:30 <mgsloan> what's the best way to search haskell docs? so far it seems like Graphics.Rendering.OpenGL.GL is unindexed by google >.< ARGH
05:10:31 <ToRA> I guess the problem is I've never seen a case when  need it as an arrow as opposed to just an instance of itself
05:10:50 <mgsloan> is there a way to perhaps download a local version of hoogle and index it on a  wider selection of libraries?
05:11:07 <quicksilver> ToRA: you never need it to be an arrow.
05:11:27 <Saizan> ah, though that's a fair question "what do i gain by recognizing this as an arrow?"
05:11:36 <quicksilver> ToRA: arrow methods aren't that exciting, you've probably already written them, and there are precious few interesting general combinators / algorithsm written over Arrow a =>
05:11:39 <dolio> Making it an Arrow just gives you a bunch of pre-defined combinators, and syntax, same as with monads.
05:11:52 <ToRA> yeah, but my point is quicksilver's point
05:11:54 <quicksilver> ToRA: the arrow syntax is useful sometimes, but not always.
05:11:59 <ToRA> making something an arrow doesn't seem to give you much
05:12:02 <xerox> there's also proc notation which is nice
05:12:21 <mgsloan> *aside: I generally only use arrow combinators as convenient ways to operate on tuples
05:12:29 <ToRA> mgsloan: +1
05:12:33 <ToRA> awww
05:12:35 <ToRA> http://hackage.haskell.org/packages/archive/OpenGL/2.4.0.1/doc/html/frames.html
05:12:38 <ToRA> promises so much
05:12:47 <xerox> http://haskell.org/arrows/syntax.html
05:13:05 <ski> kamatsu,ToRA : maybe see the `karma+' lambdabot command ?
05:13:47 <Saizan> maybe we should put more combinators in Control.Arrow as we find them :)
05:13:56 <ToRA> ski: it was more a I agree with the sentiment, not wanting to give out karma
05:14:00 <Saizan> (or Category and Applicative, as we found)
05:14:16 <mgsloan> But seriously, I have examples of some opengl code, but I have no idea where some of the function names came from in the huge huge namespace
05:15:19 <ski> Saizan : i'd rather we take out combinators from `Arrow' (i.e. replace it with `Category' :)
05:19:18 <ClaudiusMaximus> mgsloan: you can use +packagename on the hoogle web interface, eg: "+opengl vertex" (not sure which packages are available)
05:21:04 <DekuNut> Is there a specific GUI package anyone would recommend, at the moment I'm just going to go with gtk2hs, but I thought maybe there was something else that's nice
05:22:11 <mgsloan> ClaudiusMaximus: ooh awesome, thanks
05:22:35 <Saizan> ski: not in the class, i meant derived ones like mapM for Monad
05:22:46 <McManiaC> can someone help me getting started with hscurses? I did "do start; w <- newWin 10 10 10 10; wAddStr w "foo"; refresh; getCh; end", but "foo" doesnt get displayed… what am I doing wrong?
05:23:44 <ski> Saizan : ah, right (realized that after the fact)
05:24:14 <benmachine> McManiaC: I don't think you need to use newWin, just write your strings to stdScr
05:24:29 <galdor> McManiaC: not sure, but you should use wrefresh, not refresh
05:24:38 <galdor> refresh update the main window
05:25:00 <galdor> since your use another window, use ‘wRefresh w’
05:25:08 <McManiaC> there is no wRefresh
05:25:13 <mgsloan> I think I'm just finding old code that doesn't work with modern libs
05:25:24 <galdor> well wrefresh exists in ncurses
05:25:30 <McManiaC> yeh
05:31:08 <galdor> McManiaC: seems wRefresh isn't binded
05:31:29 <galdor> want to bind it and send a patch ? :)
05:35:39 <McManiaC> galdor: hmmm
05:35:46 <McManiaC> let see if I can do that
05:35:46 <McManiaC> :>
05:36:03 <mreh> did someone answer my question?
05:38:44 <kamatsu> mreh: sorry, what was it?
05:39:02 <mreh> how might I get at the text a Parsec Parser has matched?
05:40:42 <xerox> you return it from the parsec parser
05:40:56 <xerox> wait, 'at' the text?
05:42:02 <mreh> xerox, not really, if a Parser succeeds, surely it remembers what It's matched
05:43:47 <burp> what apps that make advanced use of gtk2hs are there?
05:43:47 <mreh> I'd like to parse the text into a data structure and store the text, that's not difficult to do, I just wondered if there was a shortcut
05:44:09 <burp> I need some ideas that the demos do not supply
05:50:38 <ski> mreh : why would it need to keep the tokens ?
05:51:28 <mreh> ski: shits and giggles
05:51:43 * ski looks confused
05:56:47 <ddarius> mreh: It distinctly does NOT remember what it matched.
05:56:57 <ddarius> Unless it may need to backtrack.
05:57:14 <ddarius> To avoid remembering what it has matched is why Parsec has a try combinator.
05:57:46 <shrughes> mreh: if you want the text, can you just return it in a tuple with whatever else the parser is returning?  or take the SourcePos before and after the parsing and use that to reconstruct the interval later.  (SourcePos is a bit ugly for this though.)
05:58:10 <mreh> shrugles, that's what I was reckoning with
06:47:02 <execve> How to pass a very large memory buffer from C program to Haskell/GHC function as ByteString without copying the original buffer?
06:48:12 <mux> execve: if the buffer comes from a file you could use the mmap package; otherwise I suppose you could use the unsafe creation functions of the internal ByteString module
06:48:29 <mauke> http://hackage.haskell.org/packages/archive/bytestring/0.9.1.5/doc/html/Data-ByteString-Unsafe.html#v%3AunsafePackCStringLen
06:48:44 <mux> yep, this one :-)
06:49:26 <Loriel> What is the diffrence between a Ptr and a Addr#?
06:49:49 <execve> thanks, missed this function... (
06:52:56 <burp> hm, I want some kind of hGetLines, how can I do this? let lines = lines ++ [hGetLine handle]
06:53:30 <mauke> what?
06:53:32 <copumpkin> wat
06:53:35 <Saizan> fmap lines (hGetContents handle) -- maybe
06:53:44 <Saizan> ?type lines
06:53:45 <lambdabot> String -> [String]
06:53:52 <burp> Saizan: the problem there is that when I stop reading the list the connection is closed
06:54:05 <burp> I want to use some takeWhile on it
06:54:52 <Saizan> you've to write your own loop then
06:54:53 <burp> forever $ do  lines <- hGetLines handle;   takeWhile (... ) lines .. do something with it
06:55:02 <Loriel> hGetLines handle = do line <- hGetLine handle; rest <- hGetLines handle; return (line:rest)
06:55:05 <Loriel> modulo eof handling
06:55:50 <Saizan> burp: that can sort of work only with lazy I/O, but i wouldn't get into that
06:56:17 <xerox> do you know what does tunes.org/~nef/ use exacly to log?
06:57:17 <Saizan> so, something like getLinesWhile pred handle = do line <- hGetLine handle; if pred line then (line:) `fmap` getLinesWhile pred handle else return [line]
06:58:16 <Loriel> I think the proper way to do this is just to catch the eof exception
06:58:38 <Saizan> he doesn't want all the lines, afaiu
06:58:55 <Saizan> and wants to continue consuming the rest from the handle in some other way
06:59:10 <Loriel> I see. Well, I still think catching an eof exception ought to be part of that :>
06:59:29 <burp> I get some input from a socket and then a blank line, and then more input, so I want to split by the blank lines
07:00:59 <Saizan> then you can write your own function of type [String] -> [[String]] which splits on blank lines
07:01:15 <Saizan> and then apply it to fmap lines (hGetContents handle)
07:02:09 <Saizan> not the most robust code, since we're using lazy IO, but simple
07:02:11 * ski ponders `getContentsUntil'
07:02:39 <burp> what is the problem with lazy IO?
07:03:40 <BenceF> hey guys!
07:03:45 <ToRA> have to be careful about when file-handles get closed with respect to forcing of lists of strings/chars
07:04:53 <ski> xerox : it's `clog' that logs .. i'm not sure what it logs with, though
07:04:56 <BenceF> what are the !-s at data declarations? like :  data Mydata a = !a !a
07:04:58 <ski> (hm, `nef' appears to never have identified)
07:05:07 <mauke> BenceF: strictness annotations
07:05:25 <xerox> ski yeah, I wonder how to talk with him
07:05:53 <ski> you might find a mail somewhere on the site .. also, Fare might know, if you care to bother him
07:06:10 <BenceF> mauke: thx im google-ing it. its hard to search "!"
07:06:16 <BenceF> :)
07:06:46 <ski> BenceF : it makes the corresponding argument of the constructor strict
07:07:31 <ski> in `data MyData a = Foo !Int a', forcing `Foo n x' would force `n'
07:10:07 <BenceF> ski: so data Mydata a = !a !a forces a to be the exact same type?
07:10:13 <McManiaC> how do you know where/when you need strictness?
07:10:53 <BenceF> wiki wrote monadic return as an example
07:11:06 <xerox> (ski he's online on freenode sometimes?)
07:11:28 <pastorn> BenceF: you need a constructor there...
07:12:50 <BenceF> pastorn: youre right data Mydata a = Mydata !a !a
07:13:28 <pastorn> and both a's on the RHS will be of the same type
07:13:39 <pastorn> why are you using -XBangPatterns?
07:14:16 <BenceF> pastorn: me? not purposley
07:14:44 <pastorn> hehe
07:15:30 <blobl> ispalindrome list = list == reverse list. can i write that using id? no. can anybody else?
07:15:59 <McManiaC> pastorn: some type or exactly the same object?
07:16:00 <opqdonut> ispalindrome = ap id (==)
07:16:10 <pastorn> McManiaC: same type
07:16:14 <opqdonut> err, nevermind
07:16:16 <opqdonut> @pl (\list -> list == reverse list)
07:16:16 <lambdabot> ap (==) reverse
07:16:27 <opqdonut> i'm still waking up here :D
07:16:36 <pastorn> (Mydata "hello" "in here") <-- valid
07:16:59 <opqdonut> also: ispalindrome = liftM2 (==) id reverse
07:17:03 <pastorn> (Mydata "no ok" 5)
07:17:12 <opqdonut> > liftM2 (==) id reverse $ "hih"
07:17:13 <lambdabot>   True
07:17:14 <ski> xerox : yes .. apparently not atm, though
07:17:14 <opqdonut> > liftM2 (==) id reverse $ "hii"
07:17:15 <lambdabot>   False
07:17:20 <opqdonut> blobl: got those?
07:17:31 <blobl> what on earth.. you blow my mind :D
07:17:38 <xerox> ski do you know anything about clog policy? do they add channels?
07:17:44 <opqdonut> blobl: the (->) monad :)
07:18:04 <pastorn> opqdonut: that should be renamed to the brainfuck monad...
07:18:13 <ski> BenceF : (a), `data Mydata a = !a !a' is invalid syntax (missing data constructor name); (b), forces `a' to be the exact same type as what ?
07:18:15 <opqdonut> nah, it's really straightforward
07:20:04 <BenceF> ski: the former a
07:20:16 <BenceF> so not derived type
07:20:18 <opqdonut> BenceF: yeah, both a's are the same
07:20:40 <opqdonut> so if "data Mydata a = Mydata a a", "Mydata Int" contains two ints
07:21:24 <BenceF> ok
07:21:42 <BenceF> im starting to get it
07:21:46 <Philonous> Not necessarily the same ints, though
07:21:55 <BenceF> its like templates at C++ isnt it?
07:22:04 <mauke> BenceF: not really
07:22:12 <opqdonut> in a very slight way :)
07:22:27 <mauke> ok, templates are the closest thing to parametrized types C++ has
07:23:37 <BenceF> yeah i guess evaluation-wise they differ quite a bit
07:23:59 <gwern> hm. cracking this pdf's password may take a while. I've had 3 bruteforcers running for an hour now
07:24:33 <BenceF> :) gwern , what is it about?
07:25:08 <dang`r`us> about brute force password cracking
07:25:24 <pastorn> gwern: you're not doing dictionary first?
07:25:37 <gwern> BenceF: arggh, it be about anime!
07:25:48 <pastorn> gwern: that's sorta embarrasing :p
07:25:53 <jmcarthur> so find an anime word list
07:26:01 <gwern> pastorn: don't have a dictionary
07:26:12 <pastorn> gwern: tried "^_^ kawaii!!!" yet?
07:26:14 <gwern> and I suspect the password is random anyway, it being a commercial ebook seller pdf
07:26:39 <blobl> opqdonut: why do i get a Occurs check: cannot construct the infinite type: ? with ap id (==)
07:26:53 <BenceF> dang`r`us: :D
07:27:12 <gwern> pastorn: and it's for a good cause, referencing WP articles
07:27:26 <opqdonut> blobl: because that was wrong
07:27:26 <gwern> (as I expected, nothing in /usr/share/dict/american-english worked)
07:27:28 <BenceF> gwern: maybe the password is utf-8 kanji
07:27:41 <opqdonut> "ap (==) reverse" and "liftM2 (==) id reverse" were right
07:27:50 <gwern> BenceF: I doubt it. this ebook seller specialized in US game material
07:28:02 <gwern> (/usr/share/dict/british-english works neither)
07:28:05 <jmcarthur> i once was given a thumb drive that had an encrypted pdf on it. after a little sleuthing i determined that it had information about his scholarship funds and was encrypted with his SSN. that was not good because within a matter of 20 minutes i had his SSN and access to his scholarship funds...
07:28:06 <pastorn> gwern: WP articles?
07:28:10 <gwern> pastorn: yep
07:28:24 <gwern> jmcarthur: ssn? how easily bruteforceable
07:28:38 <pastorn> gwern: wtf?
07:28:39 <jmcarthur> i meant to contact the people responsible for that kind of security, but i never got around to it and i have no forgotten the details
07:28:46 <jmcarthur> gwern: yeah i know. it was so stupid
07:28:46 <gwern> jmcarthur: why, you could narrow it down to a few dozen/hundred/thousand just knowing his rough birthdate and location
07:29:03 <gwern> I once found my SSN online when looking in my state & date of birth :(
07:29:11 <jmcarthur> gwern: no need. too easy to just brute force for the digits
07:29:16 <jmcarthur> oh gross
07:29:38 <gwern> fortunately, the list was jut by state & date, no link to names, but still disconcerting
07:30:07 <pastorn> gwern: i asked what WP was and you answered "yep". That's encouraging...
07:30:22 <pastorn> <-- puts the "rage" in "encourage"
07:30:39 <pastorn> or maybe it's you who do...
07:30:45 <gwern> (hm. looks like my bruteforcers have checked most 5-digit passwords, and roughly half of the 8 and 10 digit passwords)
07:31:09 <gwern> pastorn: glad to I could help
07:31:43 <BenceF> wordpress i guess
07:32:07 <pastorn> BenceF: thank you
07:32:20 * pastorn gives BenceF a cookie
07:33:27 <gwern> you shuold withdraw that cookiee
07:33:36 <gwern> or as the lawyers would say, force BenceF to disgorge his gains
07:33:51 * gwern meant Wikipedia. why would I be referencing any blog posts?
07:35:25 * BenceF already ate it, and didnt know the context, just guessed
07:38:53 <BenceF> gwern: try /usr/share/dict/lojban   short words. gotta be fastg
07:38:55 <BenceF> -g
07:38:57 <gwern> ---
07:39:44 <jmcarthur> huh i never thought to put lojban words in /u/s/d
07:40:22 <jmcarthur> i don't know enough lojban to justify such fanaticism though :P
07:41:28 <BenceF> jmcarthur: me neither, dont worry
07:42:29 * lispy makes a mental note, Gwern only cites wikipedia :)
07:42:36 <lispy> gwern: hi!
07:42:40 <lispy> gwern: how's it going?
07:42:44 <gwern> GREETINGS FELLOW HUMAN
07:43:00 <gwern> lispy: it goes indifferently
07:43:11 <gwern> no news, but the world's grown honest
07:43:13 <lispy> gwern: darcs is almost ready to release 2.4.
07:44:18 <gwern> lispy: yes, I've seen the noise
07:44:24 <gwern> hunk editing is cool, but needs UI work
07:46:02 <lispy> gwern: indeed.  I'm not sure what the benefit is over just editing the file.  But I've also not really paid attention :)
07:46:07 <burp> phew, I need some help with that [String] -> [[String]] function that breaks by empty strings
07:46:26 <lispy> burp: breaks by empty strings?
07:46:55 <burp> ["abc","def","","bla","blub"] -> [["abc","def"],["bla","blub"]]
07:47:17 <lispy> burp: oh
07:47:17 <Saizan> > groupBy (\_ y -> null y) ["aa","bb","","cc","dd","","ee"]
07:47:18 <lambdabot>   [["aa"],["bb",""],["cc"],["dd",""],["ee"]]
07:47:29 <Saizan> > groupBy (\x y -> null x) ["aa","bb","","cc","dd","","ee"]
07:47:31 <lambdabot>   [["aa"],["bb"],["","cc","dd","","ee"]]
07:47:33 <burp> tried various things with takeWhile/dropWhile/break but it doesn't end well
07:47:37 <Cale> > let diagonals = map (concat . takeWhile (not . null)) . transpose . zipWith (++) (iterate ([]:) []) . map (map (:[])) in diagonals . iterate (scanl1 (+)) $ repeat 1
07:47:39 <lambdabot>   [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1]...
07:47:43 <lispy> :t splitAt
07:47:44 <lambdabot> forall a. Int -> [a] -> ([a], [a])
07:47:51 <gwern> lispy: well, for me the usecase is when you add or insert several definition consecutively to a file and later go to record; you couldn't cherrypick before because darcs saw it as a single insertion/addition to be recorded
07:47:51 <gwern> burp: use the split package?
07:47:54 <Saizan> > groupBy (\x y -> null x && not (null y)) ["aa","bb","","cc","dd","","ee"]
07:47:55 <lambdabot>   [["aa"],["bb"],["","cc","dd"],["","ee"]]
07:48:01 <burp> that looks good
07:48:40 <Saizan> > groupBy (\x y -> not (null y)) ["aa","bb","","cc","dd","","ee"]
07:48:41 <lambdabot>   [["aa","bb"],["","cc","dd"],["","ee"]]
07:48:43 <Cale> Can anyone think of a better way to collect the (anti-) diagonals of a list of lists? There's obviously a way which uses indices...
07:48:45 <Saizan> better.
07:48:52 <lispy> burp: I would recommend writing it in a naive recursive manner and then trying to refactor it to use things like map/foldl as appropriate
07:49:04 <gwern> @hoogle (a -> Bool) -> [a] -> ([a], a, [a])
07:49:04 <lambdabot> No results found
07:49:10 <gwern> @hoogle [a] -> ([a], a, [a])
07:49:11 <lambdabot> No results found
07:49:15 <gwern> @hoogle [a] -> ([a], [a])
07:49:15 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
07:49:15 <lambdabot> Prelude span :: (a -> Bool) -> [a] -> ([a], [a])
07:49:15 <lambdabot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
07:49:19 <Cale> > let diagonals = map (concat . takeWhile (not . null)) . transpose . zipWith (++) (iterate ([]:) []) . map (map (:[])) in map sum . diagonals . diagonals . iterate (scanl1 (+)) $ repeat 1
07:49:20 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
07:49:29 <gwern> always thought the break and span types were a litle screwy
07:49:51 <burp> > sepBy [""] ["aa","bb","","cc","dd","","ee"]
07:49:52 <lambdabot>   Not in scope: `sepBy'
07:50:00 <burp> ok, sepBy is indeed from the split package
07:50:08 <lispy> ?hoogle sepBy
07:50:09 <lambdabot> Text.Parsec.Combinator sepBy :: Stream s m t => ParsecT s u m a -> ParsecT s u m sep -> ParsecT s u m [a]
07:50:09 <lambdabot> Text.ParserCombinators.ReadP sepBy :: ReadP a -> ReadP sep -> ReadP [a]
07:50:09 <lambdabot> Text.ParserCombinators.Parsec.Combinator sepBy :: Stream s m t => ParsecT s u m a -> ParsecT s u m sep -> ParsecT s u m [a]
07:50:19 <BenceF> Cale: the first one is a pascal triangle
07:50:20 <lispy> That's the sepBy I know
07:50:26 <Cale> BenceF: Indeed it is.
07:50:28 <BenceF> thats always handy
07:51:47 <Cale> BenceF: There's something really neat going on here...
07:52:30 <Cale> If we take the rows of Pascal's triangle and sum them, we get powers of two:
07:52:40 <Cale> > let diagonals = map (concat . takeWhile (not . null)) . transpose . zipWith (++) (iterate ([]:) []) . map (map (:[])) in map sum . diagonals . iterate (scanl1 (+)) $ repeat 1
07:52:41 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
07:52:58 <Cale> and if we take the diagonals again, we get Fibonacci
07:53:04 <Cale> > let diagonals = map (concat . takeWhile (not . null)) . transpose . zipWith (++) (iterate ([]:) []) . map (map (:[])) in map sum . diagonals . diagonals . iterate (scanl1 (+)) $ repeat 1
07:53:05 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
07:53:25 <lispy> whoa
07:53:30 <Cale> and if we take them yet again, we get something less recognisable, but still meaningful
07:53:36 <Cale> > let diagonals = map (concat . takeWhile (not . null)) . transpose . zipWith (++) (iterate ([]:) []) . map (map (:[])) in map sum . diagonals . diagonals . diagonals . iterate (scanl1 (+)) $ repeat 1
07:53:37 <BenceF> pascal triangle is cool
07:53:37 <lambdabot>   [1,1,1,3,2,6,6,11,16,22,37,49,80,113,172,257,377,573,839,1266,1874,2798,417...
07:53:46 <Cale> @oeis 1,1,1,3,2,6,6,11,16,22,37,49,80,113,172,257,377,573
07:53:46 <Heffalump> > let twos = 1:zipWith (+) twos twos in twos
07:53:47 <lambdabot>  Number of compositions of n such that two adjacent parts are not equal modul...
07:53:47 <lambdabot>  [1,1,1,3,2,6,6,11,16,22,37,49,80,113,172,257,377,573,839,1266,1874,2798,4175...
07:53:47 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
07:53:57 <Heffalump> > let twos = 1:zipWith (+) twos (tail twos) in twos
07:53:57 <Cale> 'equal modulo 2'
07:54:01 <lambdabot>   mueval-core: Time limit exceeded
07:54:06 <Heffalump> > let twos = 1:1:zipWith (+) twos (tail twos) in twos
07:54:07 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
07:54:16 <Heffalump> > let twos = 1:1:1:zipWith (+) twos (tail (tail twos)) in twos
07:54:17 <lambdabot>   [1,1,1,2,3,4,6,9,13,19,28,41,60,88,129,189,277,406,595,872,1278,1873,2745,4...
07:54:34 <lispy> Cale: does it stop there?
07:54:40 <Heffalump> hmm, I was hoping the third one would be the same as Cale's third one.
07:54:43 <Cale> That is, the nth entry is the number of ways to write n as a sum which alternates between even and odd terms
07:54:44 <lispy> Cale: or will the next application be meaningful too?
07:55:02 <Cale> lispy: OEIS doesn't know what the next one is
07:55:05 <BenceF> its got something with combinatory as well i recall
07:55:09 <Cale> But I think it will be something meaningful.
07:55:21 <Cale> Powers of 2 are the number of compositions of n
07:55:41 <Cale> and Fibonacci numbers are the number of compositions of n using only odd parts
07:55:57 <BenceF> cool
07:56:45 <BenceF> and i think its related to factorial as well
07:57:35 <lispy> Cale: so how did you stumble on this?
07:57:58 <Cale> lispy: Trying to come up with cute ways to compute Pascal's triangle.
07:58:37 <Cale> iterate (scanl1 (+)) $ repeat 1  is just so pretty that it's tempting to use it, but you need to extract the diagonals.
07:58:58 <BenceF> :t scanl1
07:58:59 <lambdabot> forall a. (a -> a -> a) -> [a] -> [a]
07:59:19 <Cale> scanl1 (+)  will compute the list of partial sums of a list
07:59:25 <Botje> iterate ((1:) . (the zip`ap`tail trick)) ?
07:59:26 <mux> http://pastebin.com/d3910613 <- my version for project euler
07:59:32 <mux> not so sexy I guess, explicit recursion, etc
07:59:32 <Cale> > scanl1 (+) [1,10,100,1000]
07:59:33 <lambdabot>   [1,11,111,1111]
07:59:45 <lispy> I rarely think to use scanl but it's nice when you need it
07:59:45 <mux> but fast
07:59:52 <Cale> Well, there's also...
08:00:06 <BenceF> ah its like a fold leaving its trail
08:00:14 <mux> yeah
08:00:15 <opqdonut> that's the idea
08:00:17 <lispy> BenceF: right
08:00:21 <Cale> > iterate (liftM2 (zipWith (+)) ([0]++) (++[0])) [1]
08:00:23 <lambdabot>   [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1]...
08:00:23 <mux> > scanl f x0 [x,y,z]
08:00:25 <lambdabot>   Not in scope: `x0'
08:00:29 <mux> > scanl f a [x,y,z]
08:00:30 <lambdabot>   [a,f a x,f (f a x) y,f (f (f a x) y) z]
08:00:42 <lispy> > scanl1 (+) [f] :: Expr
08:00:43 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
08:00:43 <lambdabot>         against inferred ...
08:01:07 <jmcarthur> pascal's triangle or whatever it's called?
08:01:11 <Cale> jmcarthur: yeah
08:01:15 <jmcarthur> nice
08:01:28 <Cale> jmcarthur: My other version is:
08:01:40 <Cale> > let diagonals = map (concat . takeWhile (not . null)) . transpose . zipWith (++) (iterate ([]:) []) . map (map (:[])) in diagonals . iterate (scanl1 (+)) $ repeat 1
08:01:42 <lambdabot>   [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1]...
08:01:56 <Cale> I need a better way to extract diagonals though.
08:02:53 <jmcarthur> i haven't seen pascal's triangle in a long time
08:03:01 <sinelaw> preflex, seen pascal
08:03:01 -preflex(n=preflex@95-88-118-220-dynip.superkabel.de)- Sorry, I haven't seen pascal
08:03:02 <mux> > map row [1..] where row i = 1 : go 1 1 where go c v | c > i = []; | otherwise = v' = (v * (i + 1 - c)) `div` c in v' : go (c + 1) v'
08:03:03 <lambdabot>   <no location info>: parse error on input `where'
08:03:08 <mux> bah.
08:03:24 <jmcarthur> not since i had a bit of an obsession with math puzzle books from the public library as a kid
08:03:47 <mux> > let go c v | c > i = []; | otherwise = v' = (v * (i + 1 - c)) `div` c in v' : go (c + 1) v' in let row i = 1 : go 1 1 in map row [1..]
08:03:48 <lambdabot>   <no location info>: parse error on input `|'
08:04:01 <mux> > let go c v | c > i = [] | otherwise = v' = (v * (i + 1 - c)) `div` c in v' : go (c + 1) v' in let row i = 1 : go 1 1 in map row [1..]
08:04:02 <lambdabot>   <no location info>: parse error on input `='
08:04:13 <mux> damnit. I guess I cannot use pattern guards with lambdabot
08:04:20 <benmachine> eh?
08:04:22 <Cale> jmcarthur: The one with diagonals gives us a rather cute way to compute fibs too. :)
08:04:35 <Cale> jmcarthur: Take the diagonals again, and then sum the rows :)
08:04:40 <benmachine> mux: what's otherwise = v' = (v ... supposed to do?
08:04:48 <Cale> > let diagonals = map (concat . takeWhile (not . null)) . transpose . zipWith (++) (iterate ([]:) []) . map (map (:[])) in map sum . diagonals . diagonals . iterate (scanl1 (+)) $ repeat 1
08:04:49 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
08:04:53 <mux> benmachine: d'oh, that was a typo
08:05:06 <mux> > let go c v | c > i = [] | otherwise = let v' = (v * (i + 1 - c)) `div` c in v' : go (c + 1) v' in let row i = 1 : go 1 1 in map row [1..]
08:05:08 <lambdabot>   [[1,1 * (i + 1 - 1) `div` 1,1 * (i + 1 - 1) `div` 1 * (i + 1 - (1 + 1)) `di...
08:05:28 * mux facepalms
08:05:32 <benmachine> :P
08:05:39 <benmachine> good ol' simplereflect
08:05:46 * mux kicks SimpleReflect in the monads
08:05:49 <Cale> Perhaps surprisingly, this method of computing fibs is not astoundingly slow.
08:06:36 <sinelaw> the monads, that's how they're called nowadays
08:06:43 <Cale> (it's also not terribly fast, but there's enough memoisation going on in the intermediate datastructures to make it a lot faster than the direct recursive version)
08:07:01 <BenceF> however computing them the oldfashioned way is not that bad either ;)
08:07:24 <Cale> mux: Well, it would have just been a "not in scope" error otherwise
08:07:43 <mux> I suppose so, but I gave up already :-)
08:08:08 <Cale> > let row i = 1 : go 1 1 where go c v | c > i = [] | otherwise = let v' = (v * (i + 1 - c)) `div` c in v' : go (c + 1) v' in map row [1..]
08:08:09 <lambdabot>   [[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1],[1,...
08:08:14 <Cale> > let row i = 1 : go 1 1 where go c v | c > i = [] | otherwise = let v' = (v * (i + 1 - c)) `div` c in v' : go (c + 1) v' in map row [0..]
08:08:15 <lambdabot>   [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1]...
08:08:32 <mux> cheers ;-)
08:08:43 <mux> note that this version can generate the nth row directly
08:08:47 <benmachine> who needs newlines
08:09:32 <BenceF> whats go, and where is it?
08:09:35 <BenceF> :t go
08:09:36 <lambdabot> Not in scope: `go'
08:09:51 <benmachine> BenceF: it's defined in the where statement
08:10:04 <BenceF> ohh ive got lost
08:10:39 <BenceF> ohh now i get it
08:12:19 <int-e> > let row n = scanl (\x k -> x * (n+1-k) `div` k) 1 [1..n] in row 10
08:12:21 <lambdabot>   [1,10,45,120,210,252,210,120,45,10,1]
08:13:13 <BenceF> ok thats dense.
08:13:47 <jmcarthur> @oeis [1,10,45,120,210,252,210,120,45,10,1]
08:13:47 <lambdabot>  Sequence not found.
08:13:59 <mux> @oeis 1,10,45,120,210,252,210,120,45,10,1
08:14:00 <lambdabot>  Pascal's triangle read by rows: C(n,k) = binomial(n,k) = n!/(k!*(n-k)!), 0<=...
08:14:00 <lambdabot>  [1,1,1,1,2,1,1,3,3,1,1,4,6,4,1,1,5,10,10,5,1,1,6,15,20,15,6,1,1,7,21,35,35,2...
08:14:45 <BenceF> hoppps there it is n!/(k!*(n-k)!) this is what i remembered
08:15:05 <mux> that's the formula to get one specific binomal coefficient
08:15:18 <mux> as opposed to the code we're writing which generates the whole rows
08:15:33 <mux> generating the rows using  the binomial formula would be terribly slow
08:16:53 <BenceF> yeah but generating your way you can read out any binomials value
08:17:50 <BenceF> which is the combination of k things out of n things
08:18:02 <int-e> > foldr ((([]:) .) . zipWith (:)) (repeat []) (iterate (scanl1 (+)) (repeat 1))
08:18:03 <lambdabot>   [[],[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6...
08:18:08 <BenceF> thats where its connected to combinatory
08:18:15 <BenceF> and n^2 obviously
08:19:31 <BenceF> > tail $ foldr ((([]:) .) . zipWith (:)) (repeat []) (iterate (scanl1 (+)) (repeat 1))
08:19:32 <lambdabot>   [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1]...
08:20:15 <BenceF> im glad i could make my contribution with one function :D
08:20:28 <int-e> > foldr ((. ([]:)) . zipWith (:)) [] (iterate (scanl1 (+)) (repeat 1))
08:20:29 <lambdabot>   [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1]...
08:20:42 <Cale> int-e: aha!
08:21:33 <Cale> lovely
08:22:05 <Cale> > let diagonals = foldr ((. ([]:)) . zipWith (:)) [] in map sum . diagonals . diagonals . iterate (scanl1 (+)) $ repeat 1
08:22:07 <lambdabot>   [1]
08:22:09 <Cale> er...
08:23:00 <int-e> it needs a different zipWith to work for truncated diagonals.
08:23:00 <Cale> > let diagonals = foldr ((. ([]:)) . zipWith (:)) [] in diagonals . iterate (scanl1 (+)) $ repeat 1
08:23:02 <lambdabot>   [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1]...
08:23:08 <Cale> ah, right
08:30:59 <MissPiggy> say I want to define two monoid instances on the same set, then make a new typeclass that interprets one as an additive monoid and the other as multiplicative (i.e. the syntax for it would be (+,zero) and (*,one)) how would you do that?
08:31:13 <Cale> MissPiggy: You'll find that in Data.Monoid
08:31:25 <Cale> MissPiggy: There are newtype wrappers called Sum and Product
08:31:39 <Cale> which give the additive and multiplicative instances for various sorts of numbers
08:32:10 <MissPiggy> so something like  instance Monoid a => Monoid (Sum a), and Product a?
08:32:11 <int-e> mmmm. (+) :: Monoid (Sum a) => a -> a -> a
08:32:24 <copumpkin> ooh, MissPiggy is back
08:32:27 <opqdonut> int-e: wow
08:32:31 <opqdonut> clever :)
08:32:44 <copumpkin> > Sum 5 ++ Sum 6
08:32:45 <lambdabot>   Sum {getSum = 11}
08:32:58 <Cale> MissPiggy: instance Num a => Monoid (Sum a)
08:33:27 <MissPiggy> am I wrong to get rid of Num?
08:34:15 <int-e> @type \a b -> getSum (Sum a `mappend` Sum b)
08:34:16 <lambdabot> forall a. (Num a) => a -> a -> a
08:34:28 <int-e> hah. of course.
08:34:35 <Cale> MissPiggy: Num is annoying in that it has abs and signum which you sometimes have to 'implement' with errors
08:35:08 <Cale> MissPiggy: But replacing it with something else is too annoying unless you take it on as a huge project of redefining the base package.
08:35:19 <int-e> I tend to use abs = 1; signum = id
08:35:44 <int-e> (err, except that abs 0 = 0)
08:35:59 <Cale> int-e: not  abs = id, signum x = 1?
08:36:15 <int-e> Cale: that violates  signum (-x) = - signum x
08:37:14 <int-e> But I'll not claim that this is any better than using errors ...
08:37:17 <copumpkin> failnum
08:37:45 <MissPiggy> I will redefine base
08:38:00 <Cale> MissPiggy: Join the folks in #alt-stdlib
08:38:41 <Cale> MissPiggy: There are lots of things which we'd like to change about the Prelude and base modules... just need to figure out what colour to paint all the bikesheds.
08:39:29 <int-e> octarine ;)
08:39:31 <Cale> (that channel has been quite quiet for the last couple weeks...)
08:39:48 <copumpkin> hey, we said lots of deep stuff just now
08:39:58 <absentia> quiet, howso?  I always apreciate the level of conversation and feedback in here.
08:40:12 <int-e> (picking a mythical colour will avoid all problems in practice if the bikeshed should ever materialise.)
08:40:18 <MissPiggy> module Prelude where
08:40:22 <MissPiggy> end of listing Prelude.hs
08:40:25 <absentia> I ask honest questions... not trolling (but could be taken that way) and I get real quality answers back.. no flame war, etc.  very nice.
08:40:32 <copumpkin> int-e: what's a good mythical color?
08:40:38 <Loriel> absentia: Not here, there
08:40:39 <copumpkin> absentia: he was talking about #alt-stdlib :)
08:40:48 <absentia> h.  ok.  :-)
08:40:51 * absentia goes back to lurking
08:41:00 <int-e> copumpkin: octarine would be my pick. but I said that already ;)
08:41:08 <copumpkin> it would've been amusing if we'd just stayed quiet and absentia's guilt had poured out into an admission of epic trolling and more
08:41:16 * int-e goes to haskell-overflow
08:41:28 <absentia> :-)
08:41:40 <int-e> or actually -blah.
08:44:54 <BenceF> can someone explain briefly $= ?
08:45:10 <BenceF> cause im using it happily, but not sure what it is
08:45:12 <ToRA> BenceF: in which package?
08:45:14 <ToRA> gl?
08:45:19 <ToRA> or gtk?
08:45:21 <ToRA> or..?
08:45:33 <BenceF> gl
08:45:43 <ToRA> http://hackage.haskell.org/packages/archive/StateVar/1.0.0.0/doc/html/Data-StateVar.html
08:45:51 <BenceF> thx
08:46:23 <ToRA> in short   $= :: (HasSetter s) => s a -> a -> IO ()
08:46:44 <quicksilver> BenceF: the idea is that it looks nicer than having two actions called 'getFoo' and 'setFoo' for all sorts of things
08:46:54 <ToRA> so if you imagine that IORef x is an instance of HasSetter, IORef x $= x  kinda makes sense
08:47:14 <quicksilver> BenceF: you just have 'foo', and for the getting half you do "x <- get foo" and for the setting half you do "foo $= x"
08:47:36 <quicksilver> (actually $= doesn't require there to be a getting half, but there generally is)
08:48:00 <ToRA> gah, reading documentation is so annoying sometimes
08:48:14 * ToRA winces at how much he should refactor to use $~
08:48:14 <quicksilver> int-e: +1 on painting bikesheds octarine
08:48:24 <BenceF> so it is poke Monad pikachu
08:48:36 <quicksilver> ToRA: don't do that. Instead refactor to use a lenses package.
08:48:53 <quicksilver> ToRA: but first, realise that you don't like any of the lenses packages on hackage, so write your own
08:49:03 <quicksilver> ToRA: in this way you will learn the true art of yak shaving.
08:49:12 <BenceF> :D
08:49:52 <ToRA> quicksilver: half done that before...fclabels is a beautiful package, apart from the getM,setM, modM obsenities
08:50:52 <Cale> I like how ($=) in the implementation for SettableStateVar practically is the same thing as ($)
08:51:00 <quicksilver> ToRA: not looked at fclabels yet, the name annoys me too much.
08:51:17 <quicksilver> ToRA: labels is a poor intuition, lenses are not just useful for records.
08:51:22 <quicksilver> ToRA: I shuld probably get over that ;)
08:51:28 <Cale> SettableStateVar a values are internally just functions a -> IO ()
08:51:40 <Cale> and ($=) just applies that function to the given value
08:51:45 <burp> when I kill a thread with a running network connection, will that be "ok"? is it different to hClose?
08:52:15 <Cale> burp: You might want the thread to catch the exception and hClose the handle...
08:52:20 <Cale> I'm not sure actually
08:52:33 <Cale> Do handles get auto-closed when they're GCed?
08:52:56 <Cale> I think perhaps they do.
08:53:17 <burp> let's assume they do ;)
08:53:28 <ToRA> quicksilver: it's a nice package and worth looking at (it made me think anyways), though it has a load of irritating helpers for MonadState, and a dependency on monads-fd which really confuses my general mtl usage
08:53:48 <BenceF> ok im off now. gonna look up IORefs first thing in the moning
09:00:12 <sshc> besides mutually recursive modules, how else does GHC not conform to the '98 standard?
09:01:22 <copumpkin> dots in module names
09:15:05 <ddarius> sshc: The User's Guide lists such things.
09:17:57 <theclaw> is it possible to write if-then-else constructs without layout?
09:18:10 <theclaw> without putting everything in one line
09:18:32 <aavogt> > if True then "yes" else "not"
09:18:33 <lambdabot>   "yes"
09:19:47 <theclaw> aavogt: http://pastie.org/793746 for example - I don't want to put everything in one line
09:20:33 <theclaw> aavogt: isn't it possible with curly braces?
09:21:03 <Beelsebob> theclaw: no, Haskell's syntax is defined in terms of whitespace
09:21:06 <Beelsebob> this is the way of things
09:21:16 <Beelsebob> but ... why the do and the returns?
09:22:09 <theclaw> Beelsebob: I'm not sure - it seemed to be as if the indentation rules are different when using "if" inside of "do"
09:22:21 <Beelsebob> they are, slightly
09:22:31 <sshc> Certain lexical rules regarding qualified identifiers are slightly different in GHC compared to the Haskell report. When you have module.reservedop, such as M.\, GHC will interpret it as a single qualified operator rather than the two lexemes M and .\.
09:22:59 <sshc> If GHC did conform to the '98 standard here, how would I refer to (+++) exported by Foo?
09:23:09 <theclaw> Beelsebob: that's a real PITA, I'm trying to generate haskell code and it those layout rules are really hard to work around :[
09:23:41 <Beelsebob> theclaw: I found when generating haskell code that I needed to do two things to keep it simple
09:24:16 <Beelsebob> 1) keep my bindings small – if I want a larger binding than a single application/if then else then add lets for the sub-expressions
09:24:24 <Beelsebob> 2) write expressions on one line
09:24:28 <Cale> Whaat? Haskell isn't whitespace sensitive if you use curly braces and semicolons
09:24:30 <Beelsebob> then you totally avoid any layout issues
09:25:01 <Cale> theclaw: You're indenting if/then/else incorrectly though
09:25:05 <Cale> It should be:
09:25:08 <Cale> if a == 3
09:25:12 <Cale>    then return 1
09:25:18 <Cale>    else return 2
09:25:24 <Cale> Or:
09:25:31 <Cale> return $ if a == 3
09:25:36 <Cale>             then 1
09:25:40 <Cale>             else 2
09:25:46 <quicksilver> theclaw: Aside: if/then/else is not a layout construct. No layout rules apply to if/then/else specifically.
09:26:20 <Cale> Right, there are no actual rules used by the compiler for if/then/else, but generally you want to use the style that I've shown.
09:26:53 <quicksilver> "do 1 +\n   2 +\n   3" is just as bad
09:27:04 <quicksilver> (and the operator + isn't a layout construct!)
09:27:06 <Cale> It's really the do-block which is giving you trouble here. If you put a second line in the do-block which starts in the same column as your first line (as the else does here), it starts a new statement.
09:27:21 <quicksilver> its just if you are continuing an expression onto a subsequent line, inside a do block, you need to indent further.
09:27:36 <manjunaths> hello
09:27:45 <Cale> But don't use the C-style layout for if/then/else, and you'll have no problems.
09:27:55 <manjunaths> finally I wrote a haskell function to read 2 bytes from a file :-)
09:28:03 * manjunaths feels happy
09:28:32 <Cale> The golden rule of indentation: things which are siblings should line up (start in the same column), and when something is a child of something else, it starts in a deeper column.
09:28:49 <manjunaths> hey Cale the other day you were trying to help me and I logged out in the middle, I am sorry.
09:28:58 <Cale> The 'then' and 'else' are siblings, so they should line up. They are both children of the 'if', so they should be indented more than it.
09:29:06 <theclaw> hmm. I'm not able to achieve this, unfortunately
09:29:19 <zygoloid> Cale: deeper column than the start of the line or the keyword?
09:29:26 <Cale> zygoloid: The keyword.
09:29:58 <zygoloid> Cale: that rule doesn't work for my preferred style: "foo x y z = do\n  a\n  b\n  c"
09:30:07 <Cale> Well, this isn't the *actual* rule used for layout, but it results in pretty code.
09:30:17 <Cale> I always put do
09:30:24 <Cale> on the same line as the first line of the do-block
09:30:30 <theclaw> Cale: I didn't write the code generator. (I'm trying to write Haskell target for ANTLR for my bachelor's thesis, so I'm limited to what antlr provides in terms of code generation)
09:30:37 <Cale> foo x y z =
09:30:40 <Cale>   do a
09:30:41 <zygoloid> I don't; I like to use the same indent width everywhere :)
09:30:43 <Cale>      b
09:30:44 <Cale>      c
09:31:03 <aavogt> you can use explicit semicolons and braces for the generated code, theclaw?
09:31:05 <Cale> theclaw: You could always use braces and semicolons
09:31:14 <Cale> theclaw: But... why ANTLR?
09:31:35 <Cale> err...
09:31:43 <Cale> Isn't ANTLR a parser generator?
09:31:55 <Cale> ah, I see
09:31:57 <Cale> okay
09:32:02 <theclaw> Cale: yes, why?
09:32:10 <theclaw> Cale: (any feedback welcome :).)
09:32:19 <Cale> Sorry, I was just confused for a moment about what you were trying to do
09:32:23 <CalJohn> theclaw: oh man, you stole me idea for a thesis
09:32:25 <CalJohn> *my
09:32:28 <theclaw> CalJohn: really?
09:32:39 <theclaw> CalJohn: what exactly where you trying to do?
09:32:51 <theclaw> CalJohn: *were
09:32:51 <CalJohn> create a haskell target for antlr :)
09:32:59 <theclaw> CalJohn: it's quite a PITA ;)
09:33:03 <CalJohn> it's cool, I haven't started yet
09:33:10 <CalJohn> I'm not in my final year yet
09:33:17 <CalJohn> good luck, i think it's a cool idea
09:33:21 <theclaw> thanks :)
09:33:34 <Cale> What is ANTLR written in?
09:33:35 <CalJohn> :)
09:33:38 <theclaw> CalJohn: java
09:33:43 <Cale> okay
09:34:02 <theclaw> CalJohn: it seems to be a big problem that antlr mainly generates code for imperative languages
09:34:14 <Cale> I would recommend emitting the most poorly formatted Haskell code ever, using braces and semicolons, and then use one of the existing Haskell prettyprinters to prettify it.
09:34:39 <Cale> You could just generate no newlines at all.
09:34:48 <CalJohn> i had a hunch that would be the case, I was considering out putting state monad stuff to get around this
09:34:52 <theclaw> CalJohn: and stringtemplate (the template engine used for generating code) doesn't work that well for generating haskell code, sometimes :(
09:35:16 <zygoloid> Cale: my preferred style is: "where" and "do" go on the current line, indent 2 spaces after them, and don't use "let ... in" or "if" if they don't fit nicely on a single line. :)
09:35:26 <Cale> http://hackage.haskell.org/package/haskell-src-exts
09:35:34 <theclaw> Cale: that's a great idea, thanks. any pretty-printers you would recommend?
09:35:42 <CalJohn> to be honest, I hadn't looked at it properly, it was just my plan to pretty much that project :p
09:35:50 <Cale> ^^ this Haskell library includes a complete parser and prettyprinter for all GHC syntax
09:36:32 <Cale> You can trivially use it to write a program to prettify Haskell source files.
09:36:40 <theclaw> CalJohn: yes, I'm using a state monad for variable bindings, but my current problem is really the DFA that gets generated to decide which alternative to take from a grammar rule
09:36:55 <theclaw> CalJohn: thanks :)
09:38:04 <theclaw> CalJohn: this DFA can be an arbitrarily nested if-construct, and that's where I'm stuck now :(
09:38:26 <theclaw> Cale: thanks
09:38:30 <Cale> There are so many parser combinator libraries and parser generators for Haskell already, that adding Haskell as a target language to an existing parser generator isn't something I would have thought of. ANTLR looks like it has lots of neat features though.
09:39:33 <theclaw> Cale: yes, I'm still a beginner in haskell, and I knew next to anything about haskell when I accepted the topic
09:40:20 <theclaw> Cale: in retrospect it wasn't the best choice for me, I guess
09:40:42 <CalJohn> oh, it was a suggested topic?  who's the supervisor?
09:43:54 <manjunaths> hello
09:44:14 <Wooga> how do i apply read function to IO String?
09:44:24 <Cale> fmap read
09:44:32 <Cale> Or run the action and apply read to the result.
09:44:40 <Cale> manjunaths: hello
09:47:10 <Wooga> where i am wrong: http://paste2.org/p/631777 ?
09:47:37 <copumpkin> you tell us
09:47:54 <MissPiggy> base = fmap read base_c -- syntax error
09:48:14 <MissPiggy> let base = fmap read base_c -- type error (?)
09:48:29 <copumpkin> base <- fmap read base_c
09:48:36 <MissPiggy> base_c :: String
09:48:40 <copumpkin> depends what you want, really :)
09:48:41 <copumpkin> oh
09:48:53 <Wooga> i am trying to do homework from http://en.wikibooks.org/wiki/Haskell/Simple_input_and_output
09:49:02 <Wooga> "Write a program which asks the user for the base and height of a right angled triangle, calculates its area and prints it to the screen. The interaction should look something like:" part
09:50:14 <manjunaths> when I try to compile a file which has import Data.ByteString I get these (http://moonpatio.net/fastcgi/hpaste.fcgi/view?id=6487#a6487) errors, anyone know how to fix them ?
09:51:55 <temoto> Hello.
09:52:08 <temoto> I'm looking for SSL/TLS library.
09:52:49 <temoto> The task is to establish connection, get certificate and disconnect.
09:54:02 <sproingie> there's OpenSSL bindings
09:54:38 <sproingie> @hackage hsopenssl
09:54:38 <lambdabot> http://hackage.haskell.org/package/hsopenssl
09:54:50 <sproingie> hm
09:55:02 <temoto> Thanks.
09:55:04 <sproingie> @hackage hopenssl
09:55:04 <lambdabot> http://hackage.haskell.org/package/hopenssl
09:55:20 <temoto> @hackage foobarnonexistent
09:55:20 <lambdabot> http://hackage.haskell.org/package/foobarnonexistent
09:55:23 <sproingie> ah there is HsOpenSSL.  hackage be case-sensitive
09:55:24 <temoto> haha
09:55:39 <sproingie> yeah i wish \bot would consume the hackage index
09:55:43 <sproingie> patches welcome i'm sure
09:56:03 <temoto> Is that on @hackage lambdabot ?
09:56:05 <temoto> :)
09:59:31 <pretsas1> What say ye on HappStack?
09:59:32 <gwern> dang, I hate email obfuscation. it took me 4 tries before I got the first email on http://www.ocf.berkeley.edu/~animage/konshuu.php right
10:00:29 <sproingie> i never obfuscate my email.  my gmail hardly ever gets spam
10:00:35 <temoto> me too
10:00:46 <Saizan> how do you define composition with SKI combinators?
10:00:54 <sproingie> frankly for the end-user spam is nearly a solved problem
10:01:08 <temoto> and this is ridiculous because they easily tranform back all your obfuscation
10:01:13 <sproingie> for the sysadmin it's still a hassle
10:01:25 <temoto> ... with software.
10:01:34 <temoto> But "good" guys have to solve puzzles by hand.
10:01:41 <gwern> temoto: decent software if it could translate that exactly on first try
10:01:43 <chrisdone> sproingie: me too, I publish my email everywhere
10:02:03 <chrisdone> sproingie: in the hopes that I get spam because I'm so lonely from seeing "No new mail! There's always Google News if you're looking for something to read."
10:02:03 <chrisdone> sproingie: but I never do ;_;
10:02:23 <sproingie> they should change that to "there's always your spam folder if you're looking for somethign to read"
10:02:29 <chrisdone> aye
10:02:48 <chrisdone> if you're looking for copious advertisements for penis enlargement
10:03:01 <chrisdone> which, frankly, I am
10:03:07 <temoto> gwern: that's a simple image. The dumbest OCR can read that.
10:03:13 <gwern> ;_;
10:03:27 <temoto> gwern: they didn't even twist letters or something.
10:03:38 <emias> sproingie, temoto: HsOpenSSL doesn't do SSL connections anyway.  Nor does http://cryp.to/hopenssl/ ...
10:03:53 <temoto> lol
10:04:02 <sproingie> gack
10:04:05 <emias> hsgnutls might do, but I seem to remember someone ranting on that one, too (never tried it myself).
10:04:11 <sproingie> not the most useful bindings then
10:04:35 <emias> Well it provides bindings to other crypto stuff from OpenSSL.
10:04:36 <sproingie> so i can assume none of the web stacks do SSL?
10:04:43 <pretsas> What is there in the way of Haskell powered web-stuff?
10:04:45 <chrisdone> gwern: actually that is distorted
10:05:09 <gwern> chrisdone: my 4th email, I realized that there was an e and not a c in the first half
10:05:09 <chrisdone> width=167 height=13, but the actual image is 136x14
10:05:18 <chrisdone> yeah, that's due to the distortion
10:05:44 <Saizan> ?type ap (return ap) return
10:05:45 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> b) -> m a -> m b
10:05:49 <pretsas> Er.. Hello?
10:05:55 <chrisdone> pretsas: hai
10:05:59 <Raevel> oh hai
10:06:11 <pretsas> Alright, just making sure there wasn't some strange NickServ stuff going on
10:06:17 <pretsas> Because that's happened to me :P
10:06:21 <temoto> sproingie: web stacks don't need to do SSL.
10:06:22 <tromp> > 0==0
10:06:23 <lambdabot>   True
10:06:38 <chrisdone> `,____,`
10:06:59 <temoto> But not having any SSL library is bad. :)
10:07:01 <tromp> :t ap (const ap) const
10:07:03 <lambdabot> forall a b b1. (a -> b) -> (b1 -> a) -> b1 -> b
10:07:08 <pretsas> But anyways, what is there in the way of Haskell powered web-stuff?
10:07:12 <chrisdone> pretsas: ah, I don't think #haskell requires registered nicks to be voiced
10:07:40 <chrisdone> pretsas: happstack or fastcgi or plain cgi
10:07:54 <temoto> Which means you really have only one option.
10:08:05 <chrisdone> rightf
10:08:08 <chrisdone> fastcgi
10:08:18 <temoto> No, Happstack.
10:08:24 <chrisdone> no, fastcgi
10:08:27 <chrisdone> >_<
10:09:03 <temoto> FastCGI is meaningless, CGI is unappropriate for anything >2 request per second.
10:09:26 <chrisdone> what's meaningless about fastcgi?
10:09:37 <temoto> You can't talk to external clients via FastCGI.
10:09:42 <rittyan> <s>there is no way to make cgi right</s>
10:09:58 <chrisdone> external clients?
10:10:04 <temoto> Which renders yet another intermediate protocol useless.
10:10:17 <temoto> Yes, the actual browsers.
10:10:26 <temoto> They don't support FastCGI, you know?
10:10:34 <temoto> libcurl, no one
10:10:40 <chrisdone> what are you talking about??
10:10:58 <temoto> Web applications are written with clients in mind.
10:11:07 <temoto> Someone will connect and issue requests.
10:11:19 <chrisdone> so what?
10:11:21 <temoto> Those are browsers, mainly.
10:11:33 <temoto> And they don't speak FastCGI.
10:11:52 <chrisdone> why would they?
10:12:03 <pretsas> Alright, I'm attempting to install HappStack
10:12:07 <rittyan> why fastcgi exists at all? apps should speak http
10:12:19 <pretsas> And HSP doesn't seem to want to compile
10:12:32 <temoto> Which means you are forced to put some HTTP proxy between clients and your FastCGI app.
10:12:35 <pretsas> As indicated here
10:12:37 <pretsas> Building hsp-0.4.5...
10:12:37 <pretsas> ghc: could not execute: trhsx
10:12:47 <chrisdone> rittyan: probably because you have to share one port
10:13:16 <chrisdone> if you're going to proxy anyway, you might as well have a protocol that supports scaling etc
10:13:22 <aavogt> pretsas: you're using cabal to install it?
10:13:32 <pretsas> Yeah
10:13:35 <aavogt> add ~/.cabal/bin to your $PATH
10:13:35 <temoto> That protocol is called HTTP.
10:13:46 <chrisdone> not really
10:14:11 <temoto> Why not?
10:14:23 <c_wraith> http is an awful protocol, in practice.  Best to leave it to dedicated http servers, and use something less awful for custom software
10:14:52 <pretsas> Thanks aavogt
10:14:58 <pretsas> It seems to be working now
10:14:58 <temoto> What is less awful in FastCGI than HTTP?
10:15:00 <aavogt> no problem
10:15:15 <c_wraith> of course, fastcgi is not less awful than http, so I don't recommend it, either :)
10:15:30 <sproingie> fastcgi is a gateway interface, not an application interface
10:15:32 <temoto> That's my point. We have two awful protocols instead of one.
10:15:39 <sproingie> er network protocol
10:16:02 <c_wraith> cgi is a gateway interface.  fastcgi *is* a network protocol.
10:16:13 <sproingie> yes the fastcgi protocol sucks and it's kind of baroque since i don't know anyone who actually uses authorizers and authenticaters
10:16:41 <temoto> ... because fastcgi is never external.
10:16:42 <sproingie> it's also totally irrelevant to clients.  it's just a way to glue a persistent process to the webserver
10:18:14 <temoto> Yeah but we're speaking about server software here, so glue kinda relevant. Despite the fact that both HTTP and FastCGI are almost equal. which makes it harder to evangelise one of them
10:18:58 <sproingie> implementing a fastcgi responder is simpler than writing an http stack
10:20:34 <chrisdone> fastcgi is just one of many implementations aimed to speed up and simplify ipc and happened to become popular. it's easy to evangelise
10:21:16 <chrisdone> and re CGI, I would be interested to see anyone here who writes a haskell web site that gets <= 2 requests per second
10:21:35 <sproingie> these days i use standalone http servers and proxy them with pound
10:21:56 <sproingie> i'm finding pound sucks in many ways but it's simple and works well enough for my needs
10:22:33 <chrisdone> er, >= 2 requests per second
10:24:15 <c_wraith> lemme check our stats, chrisdone
10:25:16 <c_wraith> We're closer to 1 request/sec, it looks like
10:25:27 <c_wraith> at least hitting the haskell portion of the stack
10:25:55 <chrisdone> well done anyway
10:25:57 <chrisdone> what site's that?
10:26:06 <c_wraith> rpxnow.com
10:26:17 <c_wraith> A few more big customers, and we'll double that
10:26:18 <c_wraith> :)
10:26:24 <gwern> bruteofrcing pdfs is slow! it's been running for hours and it's only up to '____x'!
10:27:33 <c_wraith> (our architecture is nginx reverse-proxying to several different services, via http)
10:27:42 <chrisdone> c_wraith: is uservoice worth the money then?
10:28:24 <c_wraith> I'm not on the user-support end of stuff, so much.  I'm not the one to ask.
10:39:16 <HaskellLove> What is the largest haskell program you have written and are you willing to share so i study it?
10:39:51 <FauxFaux> There's plenty of large Haskell applicaitons, why do you need someone here's?
10:40:12 <sinelaw> HaskellLove, hackage has tons
10:40:22 <sinelaw> more than you'll ever be able to go through
10:40:23 <Berengal> HaskellLove: Take a look at Yi or Darcs, for example.
10:40:35 <sinelaw> or perhaps...ghc!
10:40:51 <Berengal> Yeah, ghc is also pretty large
10:40:59 <HaskellLove> yeah you are right, i will just go to hackage
10:41:45 <HaskellLove> but that is stuff for use in haskell, i meant, programs like i dunno, games, messengers or whatever crazy stuff
10:42:12 <Berengal> There are executable programs on hackage as well, not just libraries
10:42:18 <Berengal> Like, oh, Agda-executable :)
10:42:21 <BONUS> perhaps start small and build up? maybe start with twidge
10:42:22 <MissPiggy> GHC is horrible to read :P
10:42:26 <MissPiggy> so is Agda
10:45:13 <temoto> HaskellLove: you may want to look at Kaya language compiler.
10:45:41 <temoto> HaskellLove: Hedgewars server is written in haskell too.
10:46:35 <lament> is it about warring hedgehogs?
10:46:35 <lambdabot> lament: You have 1 new message. '/msg lambdabot @messages' to read it.
10:46:55 <temoto> yes.
10:47:06 <temoto> It's a Worms clone.
10:47:14 <MissPiggy> how come the group ring isn't a group
10:47:16 <temoto> Very nice and all. And it's free.
10:47:58 <temoto> BTW, hsgnutls seems to support network.
10:48:27 <basvandijk> Hello, does anybody have an idea why my 'regions' package won't build on hackage: http://hackage.haskell.org/package/regions ?
10:48:40 <Cale> MissPiggy: what?
10:48:43 <basvandijk> I get an: haddock: internal Haddock or GHC error: dist/doc/html/regions/regions.txt: commitAndReleaseBuffer: invalid argument (Invalid or incomplete multibyte or wide character)
10:48:44 <basvandijk>  
10:48:59 <temoto> And it uses a lot of KxUnknown, MacUnknown, CompUnkown kind of data constructors. I wonder if those ought to be Nothing.
10:48:59 <Cale> MissPiggy: You mean, under multiplication?
10:49:07 <Cale> MissPiggy: It's because there's a zero.
10:49:09 <MissPiggy> ohh
10:49:14 <MissPiggy> thank you Cale
10:49:20 <MissPiggy> so can it make a field?
10:49:56 <zygoloid> if it's a ring it should be an additive grou :)
10:50:20 <Cale> Some group rings might be fields
10:51:06 --- mode: ChanServ set +o Cale
10:51:09 --- mode: Cale set +b *!*@201.170.83.247.dsl.dyn.telnor.net
10:51:09 --- kick: Tijuanense was kicked by Cale (Cale)
10:51:44 --- mode: Cale set -o Cale
10:51:47 <HaskellLove> wow quake III game in haskell ... awesome i will study that one
10:52:26 <Cale> HaskellLove: It was mostly written by a beginner in a few weeks, so it's not all as nice as perhaps it could be.
10:53:00 <Cale> But it's an interesting proof of concept :)
10:53:35 <HaskellLove> a game written by beginner? wow, i am ashamed i am beginner and i just solved couple of eulers
10:53:51 <lament> a game written by a beginner,
10:53:54 <lament> full of sound and fury,
10:53:57 <lament> signifying nothing
10:54:02 <zygoloid> wow, what did Tijuanense do to earn an immediate kickban? :)
10:54:27 <Cale> zygoloid: spammed me with racist bullshit
10:54:57 <Cale> (in privmsg)
10:55:00 <zygoloid> fair enough :)
10:55:27 * zygoloid has end-of-the-alphabet immunity from such things :)
10:56:29 <lament> lambdabot: help message
10:57:47 <lament> @tell mreh Can you credit me somewhere? Also why do you have Modes as well as scales?
10:57:48 <lambdabot> Consider it noted.
10:59:30 <mm_freak> dons: i'm getting an oddity with mersenne-random
10:59:34 <Cale> MissPiggy: Actually, I think the group ring, even over a field, is almost never a field itself.
10:59:37 <dons> mm_freak: oh?
11:00:01 <MissPiggy> Cale oh that's a shame
11:00:50 <dons> mm_freak: send mail with case to reproduce it.
11:02:01 <mm_freak> dons: i don't know whether it's a bug or my own misunderstanding, so i'll show it here first
11:02:08 <mm_freak> newMTGen Nothing >>= replicateM 3 . random
11:02:13 <mm_freak> [212779279,-1674701810,-1603567879]
11:02:27 <mm_freak> shouldn't that give the same number every time?
11:02:43 <mm_freak> oh, ok, forget it
11:02:56 <zygoloid> Cale: probably depends how often you use the single-element group :)
11:02:56 <mm_freak> i guess there is a good reason why 'random' is an IO action =)
11:03:00 <dons> not a bug :)
11:03:12 <dons> if you used the same seed every time, then a different story
11:03:22 <dons> if you use Nothing, it uses its own seed
11:03:28 <theorbtwo> mm_freak: If it wasn't, it'd have to return the same random value every time.
11:03:55 <mm_freak> theorbtwo: i interpreted newMTGen's return value as a _state_ rather than a _generator_
11:11:32 <sshc> is there a library that I can use to write "shell" scripts in Haskell?
11:11:50 <Raevel> there are several useful ones
11:12:53 <sshc> Raevel: which are they?
11:12:56 <Raevel> humhum
11:13:23 <jaspervdj> sshc: have you seen the chapter from RWH on that subject?
11:13:34 <Cale> For example, in the group ring R[Z_2], say, you have things like (1 - a) (1 + a) = 1 - a^2 = 1 - 1 = 0
11:13:34 <Raevel> i haven't used any "shellscripting packages"
11:13:37 <sshc> jaspervdj: I haven't yet
11:13:43 <Cale> So it certainly can't be a field.
11:14:04 <Raevel> but i have used for instance, filemanip, filepath, directory...
11:14:14 <Raevel> there is HSH, haven't tried it though
11:14:16 <jaspervdj> sshc: I think it would be a good starting point
11:14:32 <jaspervdj> sshc: http://book.realworldhaskell.org/read/systems-programming-in-haskell.html
11:14:59 <sshc> on a slightly related note, are there any *interactive* Haskell shells in which I can write Haskell code to do various shell tasks?
11:15:11 <lament> Monad :)
11:15:29 <sshc> lament: are you responding to me?
11:15:41 <shambler> sshc, ghci?
11:15:57 <sshc> shambler: yes, similar to ghci
11:16:17 <Raevel> sshc: http://hackage.haskell.org/packages/archive/pkg-list.html#cat:system
11:16:22 <sshc> shambler: if there are none that has vi mode (like zsh's) I won't use any
11:16:23 <shambler> oh you want like bash but bashkell?
11:16:31 <sshc> yeah, pretty much
11:16:39 <Raevel> there is hashell, dunno how far they've come
11:16:53 <sshc> can I use Haskell in hashell?
11:17:01 <Raevel> that's the point afaik
11:17:07 <sshc> ok, that's good
11:17:19 <sshc> bash has vi mode too I think but it's really hard to configure, so I don't use bash
11:17:24 <sshc> does hashell have vi mode?
11:17:30 <Raevel> no clue
11:18:52 <sshc> Hashell is no longer maintained and only works with old versions of GHC
11:18:59 <Raevel> bah
11:19:05 <Veinor> I read that as 'haskell is no longer maintained'
11:19:29 <Raevel> ... and only works with old versions of GHC
11:19:34 <sshc> now, that would be terrible!
11:20:09 <Cale> Haskell doesn't seem to me like something which would make a convenient user shell, but it's good for shell scripting tasks along with libraries such as HSH.
11:21:11 <Raevel> i would just love to be able to write flip mv sometimes :-)
11:21:21 <Cale> Things that I would consider convenient user shells all have the property that you can use an arbitrary executable file on the system directly as a command with no extra keystrokes.
11:21:30 <Veinor> Raevel: mv -t?
11:21:40 <Cale> But if you try to mix that property with Haskell, you have a problem assigning types to things.
11:21:53 <sshc> I see
11:22:01 <Raevel> Veinor: ooooooooooooooooh, but not on os x unfortunately :-(
11:22:07 <Veinor> :(
11:22:24 <Veinor> you can only do mv -t dir/ file, not mv -t file2 file1, but still
11:22:53 <Raevel> sounds fair
11:23:23 <Cale> Has anyone else here ever used sed to generate commandlines and piped the result back to bash?
11:23:51 * Cale goes to great lengths to avoid for loops in bash :)
11:24:57 <Raevel> nope!
11:25:12 <sproingie> i like to pipe into while loops
11:25:28 <sproingie> blahblah | while read foo bar; do ...
11:25:35 <BONUS> hmm, what are the advantages to writing sum types as CPS-style functions? i.e. Either a b = ((a -> c) -> (b -> c) -> c)
11:25:40 <BONUS> aside from that just being plain cool
11:25:48 <Cale> BONUS: memory
11:25:55 <BONUS> memory?
11:26:07 <Cale> well, hmm...
11:26:14 <sproingie> i totally don't understand that definition of Either
11:26:53 <Cale> The GHC optimiser does a much better job of inlining and removing such functions altogether than it does at fusing out the construction of Either values
11:26:57 <Heffalump> Cale: I do it quite a bit
11:27:07 <Heffalump> (re sed/bash)
11:27:11 <Cale> :)
11:27:17 <Heffalump> it's often the only way I can figure out quoting issues sanely
11:27:23 <Cale> Yeah.
11:27:24 <BONUS> sproingie: well it's isomorphi to Left a | Right b. Right "blah" is like doing (\l r -> r "blah")
11:27:31 <BONUS> Cale: ah
11:27:37 <BONUS> i also imagine there are some gains regarding laziness
11:27:46 <BONUS> since you don't have to pattern match on constructors
11:28:12 <MissPiggy> is this right ((a -> c) -> (b -> c) -> c)?
11:28:22 <Cale> Well the function application is essentially the same thing as case.
11:28:23 <maltem> :t either -- sproingie
11:28:24 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
11:28:55 <BONUS> either should have a type of Either a b -> (a -> c) -> (b -> c) -> c imo :)
11:29:07 <opqdonut> BONUS: ah, continuation style. I would've termed that church style or something :)
11:29:11 <Cale> It's more often useful the other way.
11:29:14 <opqdonut> but continuations they are
11:29:15 <maltem> to demonstrate the isomorphism yea :)
11:29:31 <Cale> either is to Either what foldr is to []
11:30:06 <BONUS> hmm
11:30:13 <sproingie> i get it.  at least for something that simple
11:30:26 <sproingie> i think i'd have a brain asplosion trying to do it for anything actually complex
11:30:28 <opqdonut> either is to Either what (\a b -> if nil xs then a else b (tail xs)) is to []
11:30:44 <opqdonut> or something to that effect
11:31:08 <kmc_> that's an eliminator right?
11:31:24 <BONUS> sproingie: you can also make trees like (\t b -> b (\t b -> t 2) 3 (\t b -> t 4))
11:31:53 <leimy> I basically love parsec
11:32:09 <leimy> but I have a heck of a time figuring out, without GHC's help, what the type of a parser function is :-)
11:32:35 <BONUS> opqdonut: why b (tail xs)?
11:32:36 <leimy> Just in case I wanted to perhaps specify it.  It's like you're better off just letting the inference engine get it.
11:32:43 <BONUS> wouldn't it just b b xs?
11:33:27 <BONUS> be*
11:36:30 <opqdonut> BONUS: eliminator, not catamorphism
11:36:39 <MissPiggy> difference?
11:37:49 <sshc> would making a vector type an instance of Num so that -, +, and negate can be used on them a good idea?
11:38:20 <opqdonut> it's the difference between "cons = (\h t -> \n c -> c h t)" and "cons = (\h t -> \n c -> c h (t n c)"
11:39:33 <opqdonut> so either a list is represented as it's own case, or it's own catamorphism
11:39:34 <Gracenotes> that looks like a difference
11:39:54 <opqdonut> the first makes head & tail easy, the second makes recursion easy
11:40:03 <MissPiggy> aha
11:40:34 <sshc> where can I use guards?
11:40:47 <copumpkin> knees
11:40:51 <BONUS> lol
11:40:58 <Gracenotes> declarations
11:41:03 <kmc_> case arms
11:41:07 <copumpkin> case expressions
11:41:26 <copumpkin> > let Just x | even x = Just 6 in x -- will this work?
11:41:29 <sshc> why can't I use them after a let expression like "let foo = x in | foo == bar = ..."?
11:41:30 <lambdabot>   mueval-core: Time limit exceeded
11:41:39 <copumpkin> o.O
11:41:43 <Gracenotes> hum
11:41:45 <kmc_> you can't use them there because it's not part of the language
11:41:48 <kmc_> not sure what it would even mean
11:42:04 <copumpkin> > let Just x | odd x = Just 6 in x -- will this work?
11:42:08 <lambdabot>   mueval-core: Time limit exceeded
11:42:10 <Gracenotes> nooooo
11:42:12 <kmc_> maybe you want:  let foo = x in case x of { ... | foo == bar -> ....    | otherwise -> ... }
11:42:17 <BONUS> basically when defining functions or in case statements
11:42:28 <sshc> kmc_: yes
11:43:08 <kmc_> there's also this idiom for multi-way conditionals:   case () of { _ | cond1 -> .... | cond2 -> .... | cond3 -> ... }
11:43:09 <BONUS> i wish we had some syntactic sugar for case () of _ | a -> x | b -> y | c -> z ...
11:43:11 <Gracenotes> this is all one big mixup, I say
11:43:13 <kmc_> yeah
11:44:24 <Gracenotes> not sure why there are guards in case statements in the first place. but, they do exist in functions, which can be glorified case statements, so...
11:44:54 <kmc_> why shouldn't there be guards in case statements?
11:45:15 <sshc> so there is no syntactic sugar for case () of _ | ...?
11:45:19 <kmc_> no
11:45:20 <BONUS> well f pattern1 = ...; f pattern2 = ... desugars to f x = case x of pattern1 -> ...; pattern2 -> ...
11:45:51 <sshc> kmc_: is that even valid Haskell?
11:45:57 <kmc_> which?
11:46:07 <kmc_> the idiom i used?
11:46:13 <kmc_> i think it's valid, unless i made an error
11:46:17 <sshc> > let foo = 3 in case () of _ | even foo = True | otherwise = False
11:46:17 <lambdabot>   <no location info>: parse error on input `='
11:46:36 <opqdonut> it's "->"
11:46:39 <kmc_> it's a case expression whose scrutinee is (), with only a single pattern (the wildcard _) and multiple guards on that pattern
11:46:58 <kmc_> > case () of _ | even 3 -> "foo" | otherwise -> "bar"
11:47:00 <lambdabot>   "bar"
11:47:05 <sshc> > let foo = 3 in case () of _ even foo = True | otherwise = False
11:47:06 <lambdabot>   <no location info>: Parse error in pattern
11:47:10 <sshc> > let foo = 3 in case () of _ | even foo = True | otherwise = False
11:47:11 <lambdabot>   <no location info>: parse error on input `='
11:47:13 <kmc_> it's -> not =
11:47:15 <kmc_> in case
11:47:29 <sshc> oh
11:47:31 <Zao> Is there any functionality to find the byte offset of a member of a C struct in a .hsc file?
11:47:48 <sshc> > let foo = 3 in case () of _ | even foo -> True | otherwise -> False
11:47:49 <lambdabot>   False
11:48:15 <temoto> sshc: that's 'if'
11:48:33 <sshc> temoto: what is?
11:49:00 <kmc_> the idiom is mostly useful with more than two conditional cases
11:49:01 <temoto> > let foo = 3 in if even foo then True else False
11:49:01 <lambdabot>   False
11:49:12 <kmc_> but you might prefer it to "if" for stylistic reasons as well
11:49:18 <kmc_> i don't really like "if"
11:49:26 <temoto> Why?
11:49:31 <c_wraith> if is syntax.  That's annoying
11:49:39 <kmc_> it's special syntax and not for a good reason
11:49:43 <kmc_> it interacts poorly with layout
11:49:53 <temoto> yeah :)
11:49:59 <sshc> that's why I want to use guards in case
11:50:06 <kmc_> if "if_then_else_" were a mixfix operator from the std lib, i'd be more fine with it
11:50:33 <kmc_> also, i dislike it because beginners overuse it :)
11:50:42 <temoto> case is a syntax too, why do you case whether it's a syntax or operator?
11:50:46 <temoto> care*
11:50:47 * copumpkin gesticulates in agreement with kmc_
11:50:58 <kmc_> "if" is syntax which could be replaced by a library function
11:51:01 <kmc_> with only cosmetic changes
11:51:04 <kmc_> "case" is not so
11:51:16 <temoto> I understand layout rant.
11:51:23 <kmc_> > let if' True a b = a; if' False a b = b in if' (even 3) "foo" "bar"
11:51:24 <lambdabot>   "bar"
11:51:29 <sproingie> i bet patches to add mixfix would be welcome
11:51:33 <kmc_> hehe
11:51:37 <kmc_> backport it from Agda
11:51:49 <kmc_> seriously, i have no idea how to even begin writing an parser which supports
11:51:52 <BONUS> > let guards xs otherwise = case find fst xs of Just (True, x) -> x; Nothing -> otherwise in guards [(even 3, 'a'), (odd 3, 'b')] 'c'
11:51:53 <lambdabot>   'b'
11:51:57 <copumpkin> it's hard
11:51:59 <kmc_> user-extensible mixfix parsing rules
11:52:02 <copumpkin> and forces whitespace around all identifiers
11:52:12 <copumpkin> which greatly hinders golfing ability
11:52:14 <copumpkin> :(
11:52:41 <sproingie> i always say i want that but i don't want to have to put spaces around :
11:52:57 <sproingie> so i want forced whitespace except when i don't
11:53:28 <copumpkin> _ _ = _$_
11:53:54 <lament> money from nothing
11:54:04 <temoto> That's ambigous btw.
11:54:04 <BONUS> chicks from free
11:54:11 <sproingie> theorems
11:54:13 <lament> money for nothing and chicks for free
11:54:17 <temoto> _1 _2 = _1$_2
11:54:20 <copumpkin> monads for free
11:54:31 <copumpkin> comonads for cofree?
11:54:35 <sproingie> monads for nothing and your theorems for free
11:54:42 <kmc_> theorems for free, lemmas $1.50
11:54:48 <lament> no monads, no service
11:54:48 <copumpkin> lemmata
11:55:07 <kmc_> excuse me sir, your monads are showing
11:55:22 <temoto> Show must go on.
11:55:25 <kmc_> is there a paper on how Agda's parser works?
11:55:34 <copumpkin> oh wow, I can't believe the man page for iostat writes out central processing unit
11:55:38 <copumpkin> kmc_: yeah, I saw one somewhere
11:55:39 <ziman> excuse me sir, your comonads are looking
11:55:40 <copumpkin> let me see
11:56:06 <copumpkin> kmc_: http://www.cs.nott.ac.uk/~nad/publications/danielsson-norell-mixfix.pdf
11:56:10 <sshc> > let 1 = 3 in abs(1 * 3 - 6) - 3
11:56:10 <lambdabot>   0
11:56:12 <temoto> kmc_: do you have sources of that layout parser now, btw?
11:56:35 <copumpkin> kmc_: he's got another couple of papers on related topics
11:57:24 <kmc_> temoto: no
11:57:37 <kmc_> copumpkin: thanks
11:58:18 <temoto> kmc_: do you want me to stop asking about it? :)
11:58:33 <kmc_> temoto: it's not easily accessible, sorry :/
11:58:46 <temoto> i take it as not yet :)
12:00:11 <McManiaC> how do I get hscurses to display utf8 characters?
12:02:41 <HaskellLove> Anyone has installed frag, a game written in haskell? I get error on build Could not find module `Render'
12:04:01 <copumpkin> HaskellLove: an endomap appears to be an arrow whose domain and codomain are the same object
12:04:18 <copumpkin> at least from about 2 seconds of googling ;)
12:04:41 <Veinor> I should really learn CT sometime, but I don't know of any good introductory books to it that aren't crazy expensive.
12:05:04 <HaskellLove> yeah they are expensive
12:05:13 <copumpkin> the awodey pdf is "free"
12:05:25 <copumpkin> the barr-wells notes are pretty decent from what I've read so far
12:05:29 <Veinor> 'free'?
12:05:37 <BONUS> just google: awodey pdf
12:05:44 <opqdonut> books for nothing and pdfs for free
12:05:50 <copumpkin> free as in there's a pdf floating around, "" as in it probably shouldn't be
12:05:57 <Veinor> ahh.
12:05:58 <pastorn> Veinor: http://www.amazon.com/Category-Computer-Scientists-Foundations-Computing/dp/0262660717/ref=sr_1_1?ie=UTF8&s=books&qid=1264449921&sr=8-1
12:06:00 <shambler> @snack
12:06:01 * lambdabot pulls  through the Evil Mangler
12:06:05 <pastorn> 17 USD
12:06:11 <copumpkin> @bumsmack
12:06:11 <lambdabot> Unknown command, try @list
12:06:23 <copumpkin> @bumsnack
12:06:23 <lambdabot> :)
12:06:42 <copumpkin> lambdabot: you like that don't you
12:06:48 <Veinor> yeah, that doesn't look like it should be free.
12:07:10 <BONUS> looks like it should be free to me
12:07:17 <Veinor> although it is on the UC website...
12:07:17 <BONUS> (imo everything should be free)
12:07:22 <lambdabot> yeah, I like that babe
12:07:35 <MissPiggy> everything should be free THEREFORE it is
12:07:49 <BONUS> solid enough reasoning
12:09:12 <HaskellLove> seems Veinor connected to the internet yesterday
12:09:18 <Veinor> ?
12:09:39 <copumpkin> HaskellLove is a pirated book expert
12:09:40 <copumpkin> ARR
12:09:53 <Zao> HaskellLove: No GLUT here, so no frag for me.
12:10:06 <Zao> I do see no GLUT as a positive thing though :)
12:10:13 <copumpkin> class ARRow (~>) where ARR :: (a -> b) -> (a ~> b)
12:11:06 <HaskellLove> Zao I guess i will just read the source, i cant install it
12:26:53 <Vitka> :t me
12:26:54 <lambdabot> Not in scope: `me'
12:27:00 <Vitka> Hmm.
12:39:29 <McManiaC> is there a "correct" way to break out of a "forever" loop?
12:40:01 <Loriel> What part of "forever" do you not understand? :)
12:40:07 <McManiaC> hehe
12:40:19 <c_wraith> Many correct ways, depending on what monad you're in
12:40:26 <McManiaC> IO
12:40:27 <lispy> McManiaC: I think exceptions can get you out it
12:40:36 <McManiaC> yeh, "fail "foo""
12:40:39 <Twey> So what is one supposed to do for Happstack.State to stop the application producing ‘an application may still be using this state…’ when next you launch it?
12:40:55 <c_wraith> anything that implements MonadPlus, mzero will get you out of forever.
12:41:06 <McManiaC> oh right
12:41:13 <PeakerWork> forever is a lie :)
12:41:23 <lispy> forever == the cake
12:41:38 <Twey> The cake is forever
12:41:48 <lispy> No no, the cake is a lie
12:41:57 <Twey> Forever :þ
12:48:33 <jaspervdj> @src forever
12:48:33 <lambdabot> Source not found. My mind is going. I can feel it.
12:49:08 <jmcarthur> if you want to break out of a forever loop you should not be using forever
12:49:17 <benmachine> that's not true necessarily
12:49:19 <BONUS> that's a bingo!
12:49:41 <benmachine> you can easily break out of forever in Maybe but not in a very interesting way :P
12:50:01 <kmc_> you can use the Either monad instance this way
12:50:01 <benmachine> a common Either monad would provide something more interesting
12:50:09 <kmc_> or define a custom "break-out" monad
12:50:11 <kmc_> or use continuations
12:50:15 <BONUS> > forever Nothing
12:50:16 <lambdabot>   Nothing
12:50:21 <BONUS> sounds very pessimistic
12:50:29 <jmcarthur> yeah but i don't consider those to be "breaking out"
12:50:50 <jmcarthur> it just happens to converge
12:51:02 <BONUS> can you break out with callCC?
12:51:07 <MissPiggy> implementing C style break control operator with continuations is sensible
12:51:09 * BONUS attempts
12:51:14 <MissPiggy> this is how you'd do it in semantics anyway
12:51:19 <jmcarthur> you should be able to with callCC i think
12:51:24 <kmc_> yeah
12:51:31 <MissPiggy> well I would use RESET/SHIFT rather than CWCC but that's just me
12:51:37 <jmcarthur> you can do pretty much anything with callCC
12:52:19 <pikhq> BONUS: callCC is much like a functional goto.
12:52:24 <pikhq> Except more flexible.
12:52:28 <BONUS> yase
12:52:32 <MissPiggy> I don't see any relation with goto
12:52:38 <kmc_> > flip runCont id $ callCC (\k -> forever (k ()))
12:52:39 <lambdabot>   ()
12:52:52 <pikhq> MissPiggy: "Closest analogue", more like.
12:52:53 <MissPiggy> but a lot of people say that about callCC so it must be true
12:53:05 <kmc_> callCC is much like an axiom of classical logic ;)
12:53:19 <jmcarthur> it happens to you can implement something like goto with callCC
12:53:40 <jmcarthur> which i guess "makes" callCC a "more flexible goto"
12:53:51 <BONUS> it can't jump forward though
12:54:08 <harlekin> Is there a class which has (>>) from monads, but doesn't have a return type? I just want to thread a state through a sequence of action which are only modifying the state.
12:54:19 <pikhq> No, but it can jump back with a reference to a forward jump.
12:54:23 <benmachine> harlekin: just compose your state functions?
12:54:23 <BONUS> true
12:54:25 <benmachine> with .
12:54:34 <benmachine> or you can use >>> if that would make you happy :P
12:54:47 <kmc_> :t foldr (.) id
12:54:47 <BONUS> applicative is the minimum you need for >>
12:54:48 <lambdabot> forall b. [b -> b] -> b -> b
12:54:56 <BONUS> i always forget if it's <* or *> though
12:54:58 <kmc_> :t (<*)
12:55:00 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
12:55:04 <benmachine> *> = >>
12:55:09 <BONUS> *> then, yeah
12:55:21 <Twey> But Applicative has pure
12:55:31 <benmachine> mmhm
12:55:38 <BONUS> so?
12:55:48 <Twey> So that's a return
12:55:55 <BONUS> oh he meant return type in that way
12:56:10 <Twey> Well, that's what I assumed
12:56:16 <Twey> harlekin: Perhaps you want the function monad?
12:56:32 <BONUS> harlekin: what do you mean exactly by "doesn't have a return type"?
12:57:02 <Twey> > do { x <- id; y <- (* 2); z <- (+ 9); return (x, y, z) } $ 3
12:57:03 <lambdabot>   (3,6,12)
12:57:07 <harlekin> BONUS, assuming I implement a monad interface, all my actions would return (). They only modify the state.
12:57:27 <BONUS> so your functions are just state -> state?
12:57:51 <harlekin> BONUS, yes. But I want to hide the state. Is this even useful?
12:58:11 <BONUS> you can just make it a monad and use >>, this will automatically discard their results, they don't have to return ()
12:58:22 <benmachine> harlekin: you could newtype-wrap a function from state to state and define monoid, but there's not much point?
12:58:34 <benmachine> I'm not sure what hiding the state gains you
12:58:43 <benmachine> if your functions are only on state you must use it in every function anyway
12:59:03 <MissPiggy> 'hiding' is an idiom from object oriented programming, probably
12:59:15 <benmachine> doesn't really make sense in this context
12:59:27 <benmachine> you could define a type synonym for StateType -> StateType
12:59:30 <harlekin> I guess you're right. I shouldn't hide the state if the state is all I have.
12:59:33 <benmachine> that's about all the hiding you're going to get
12:59:56 <benmachine> you can make it a monad with useless return if you like
13:00:01 <benmachine> then you can use do, which you might like
13:00:03 <jmcarthur> do whatever is most composable
13:00:09 <aavogt> @src Endo
13:00:09 <lambdabot> Source not found.
13:00:23 <BONUS> harlekin: what's the type of your stateful functions?
13:00:27 <benmachine> newtype Endo a = Endo { appEndo :: a -> a }
13:00:35 * benmachine always thinks appEndo is an unhelpful name
13:00:36 <jmcarthur> harlekin: if you want something monad-like that isn't a monad, maybe you just want Monoid instead?
13:00:58 <kmc_> monads and monoids don't have much in common
13:01:08 <benmachine> you can make a monoid out of monads
13:01:09 <jmcarthur> well, i guess it would be a monad, but only giving anything of type m () looks like a monoid to me
13:01:12 <benmachine> with >> and return ()
13:01:13 <harlekin> BONUS, ([IO ()], (Int, Int)) essentially.
13:01:15 <jmcarthur> kmc_: sure they do
13:01:20 <kmc_> an abstract description
13:01:21 <benmachine> (and out of applicatives)
13:01:23 <aavogt> benmachine:    (f :: Endo) `appEndo` x -- this makes sense, but I also doubt that it's very helpful
13:01:24 <kmc_> but the code you write is not very similar
13:01:26 <jmcarthur> they have similar types and the same laws
13:01:34 <aavogt> err  f :: Endo a
13:01:38 <jmcarthur> kmc_: only with do notation are they different...
13:01:41 <benmachine> aavogt: every other newtype has runFoo, *that* makes sense
13:01:44 <kmc_> i don't see how the types are similar
13:01:50 <benmachine> (not every, but you know what I mean)
13:01:59 <aavogt> or unFoo
13:02:02 <BONUS> monads are monoids in the category of endofunctors :)
13:02:08 <kmc_> yes yes
13:02:11 <jmcarthur> kmc_: do you see the similarity of Monad and Category?
13:02:14 <harlekin> BONUS, I want each function to put a IO function on top of the [IO ()] list and modify the second entry in the tupel.
13:02:33 <kmc_> jmcarthur: you mean that the Kleisli category is a category?
13:02:48 <aavogt> is () the 0-tuple you modify harlekin?
13:02:48 <BONUS> hmm, seems convulted
13:03:19 <jmcarthur> kmc_: i mean the relationship between return and id and between <=< and .
13:03:27 <harlekin> aavogt, I modify the while 2-tupel ([IO ()], (Int, Int)). I want to add an item to [IO ()] and change (Int, Int) with every function call.
13:03:31 <jmcarthur> kmc_: and that they obey the same laws (the monad laws, essentially)
13:03:52 <harlekin> s/while/whole/
13:03:58 <jmcarthur> return <=< a = a ; a <=< return = a ; (a <=< b) <=< c = a <=< (b <=< c)
13:04:08 <jmcarthur> those are the monad laws in terms of <=<
13:04:30 <kmc_> jmcarthur: i think that's what i said
13:04:33 <jmcarthur> mempty ++ a = a ; a ++ mempty = a ; (a ++ b) ++ c = a ++ (b ++ c)
13:04:40 <jmcarthur> and those are the monoid laws
13:04:43 <aavogt> harlekin: is there much benefit in keeping the IO (), separate? There's not much information about which one(s) to run later...
13:04:53 <harlekin> I think I could use the monad interface and have function which return (Int, Int) and thread the [IO ()] list through the actions as a hidden state.
13:05:01 <kmc_> jmcarthur: you're saying that a monad forms a Kleisli category, and also that a monoid is a category with one object
13:05:05 <harlekin> aavogt, I want to run all of them later in the order they're in the list.
13:05:29 <jmcarthur> kmc_: more than that. a monad is a monoid
13:05:51 <jmcarthur> with some extra type information
13:06:10 <aavogt> then instead of consing on the list, you can just   new >> old -- or other order (which is bad if you still use a list)
13:06:37 <kmc_> yes, a monad forms a "typed monoid" with return and (<=<)
13:06:37 <aavogt> in which case your type is like    StateT (Int, Int) IO () ...
13:06:57 <kmc_> "typed monoid" is a concise description of what a category is
13:07:00 <jmcarthur> kmc_: and if your monad only ever gives you thing of the for m () then you might as well just use a monoid, no?
13:07:00 <aavogt> which is probably not better
13:07:12 <harlekin> aavogt, what's bad about that?
13:07:14 <jmcarthur> *things of the form m ()
13:07:37 <MissPiggy> indexed monoid ??
13:07:40 <kmc_> yeah.  if you restrict the kleisli arrows to be of type (() -> m ()) then your Kleisli category is a monoid
13:07:53 <kmc_> (and you might as well then drop the argument, because it's useless)
13:07:58 <jmcarthur> exactly
13:08:02 <kmc_> (since there's only one value of that type)
13:08:04 <benmachine> aavogt: how about StateT (Int, Int) (Writer MonadMonoid) ()? that prevents you using the IO inside the state calculation
13:08:14 <jmcarthur> hence my suggestion for harlekin to use Monoid instead of Monad
13:08:27 <kmc_> yeah, i wasn't arguing against that
13:08:36 <BONUS> harlekin: what are you trying to do here, i mean like big picture stuff
13:08:44 <BONUS> maybe there's a much simpler way to model your problem
13:09:00 <aavogt> oh, the state calculations are independent of any IO results?
13:09:17 <aavogt> @hoogle MonadMonoid
13:09:17 <lambdabot> No results found
13:09:20 <jmcarthur> "<kmc_> monads and monoids don't have much in common" ... i was just trying to point out that they do
13:09:50 <harlekin> BONUS, I want to sequence X11 drawing commands for later execution (that's the [IO ()] part). All drawing commands work on a canvas of (Int, Int) width and height and each drawing command reduces the canvas size for the next.
13:10:04 <jmcarthur> and let's not also forget that in category theoretic terms monads are monoids anyway. it's just less applicable to us directly in this context
13:10:07 <BONUS> ahh, interesting
13:10:19 <MissPiggy> every function that just uses m a, i.e. not m b, m c or m (m a) or anything like that (e.g. m a -> (m a -> ...) -> ) you could use on monoid?
13:10:21 <aledge> :t ((.) .)
13:10:22 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
13:10:44 <MissPiggy> but then there are functions on monoid, which might get generalized to have more elaborate types
13:11:07 <MissPiggy> so what is the relation?
13:11:31 <BONUS> harlekin: maybe model one such drawing command as (Int, Int) -> IO (Int, Int)
13:11:34 <BONUS> seems more natural to me
13:11:45 <MissPiggy> it's like they are both associative, but it's a different notion of associative - sort of ..
13:11:49 <BONUS> or are you stuck with the commands as IO ()
13:11:57 <jmcarthur> MissPiggy: instance Monad M => Monoid (M ())
13:12:08 <benmachine> BONUS: but implies that your (Int, Int) result requires IO
13:12:10 <sproingie> :t (Prelude..)
13:12:11 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
13:12:33 <jmcarthur> err, lowercase m, not uppercase
13:12:44 <harlekin> BONUS, as benmachine says, the canvas size after a drawing command should be computed purely functional.
13:12:46 <sproingie> :t ((Prelude..) (Prelude..))
13:12:47 <lambdabot> forall b c a a1. (a1 -> b -> c) -> a1 -> (a -> b) -> a -> c
13:12:49 <benmachine> jmcarthur: itym instance Applicative f => Monoid (f ()) :P
13:12:57 <jmcarthur> benmachine: yes, you are right
13:13:00 <BONUS> aha
13:13:01 <sproingie> \bot has funny ideas about .
13:13:26 <jmcarthur> Applicative essentially forms a right seminearring if i recall correctly
13:13:34 <jmcarthur> just with extra type information
13:13:35 <BONUS> how about (IO (), (Int,Int) -> (Int,Int))?
13:13:48 <benmachine> semin earring?
13:13:57 <sproingie> is that hair gel?
13:14:05 <BONUS> lol
13:14:45 <harlekin> @src (>>=) State
13:14:45 <lambdabot> Source not found. I feel much better now.
13:14:51 <harlekin> @src State (>>=)
13:14:52 <lambdabot> Source not found. There are some things that I just don't know.
13:15:05 <jmcarthur> no i'm wrong
13:15:24 <jmcarthur> Applicative is a monoid, Alternative is a right seminearring
13:16:03 <MissPiggy> what's the point in stuff like matroids and nearring
13:16:34 <Cale> MissPiggy: Matroids are an abstraction of linear independence.
13:16:52 <jmcarthur> same as for Monoids, really. nice abstractions sometimes
13:17:20 <Cale> they also sort of capture the general setting in which "greedy algorithms" work
13:17:36 <Cale> Well nearly so.
13:18:06 <Cale> (there is a generalisation called a greedoid which gives a slightly better fit)
13:18:31 <BONUS> hehe, sounds like a B-movie villain
13:18:43 <benmachine> I thought that
13:19:04 <BONUS> ugh, plz ban Tijuanense
13:19:18 <benmachine> seconded
13:19:25 <benmachine> oh there we go
13:19:32 <Cale> I banned him before
13:19:37 <lispy> Is there a tutorial for regex?
13:19:46 <Cale> looks like his IP changed
13:19:51 <lispy> I'd like to do some string replaces but the haddock is a bit obtuse
13:19:54 <Heffalump> what was Tijuanense doing?
13:20:00 <Cale> Well, he's k-lined now
13:20:07 <MissPiggy> spamming links in PM
13:20:09 <BONUS> Heffalump: spamming in private
13:20:14 <BONUS> ya
13:20:15 <medfly> how does banning him help?
13:20:17 <Cale> He was spamming people with racist stuff.
13:20:30 <Cale> medfly: Prevents him from getting the user list.
13:20:39 <HugoDaniel> is there an Int32 type in haskell ?
13:20:45 <BONUS> Word32
13:20:46 <Cale> But you generally don't want someone like that in the channel anyway
13:20:47 <HugoDaniel> hmm nice
13:20:54 <Cale> There's also an Int32
13:20:58 <Cale> in Data.Int
13:21:06 <BONUS> really? what's the difference between Int32 and Word32
13:21:10 <Cale> Signedness
13:21:11 <HugoDaniel> is it possible to do bit operations in a Word32/Int32 ?
13:21:17 <Cale> Yes, see Data.Bits
13:21:17 <benmachine> > maxBound :: Word32
13:21:19 <lambdabot>   4294967295
13:21:21 <benmachine> > maxBound :: Int32
13:21:23 <lambdabot>   2147483647
13:21:25 <HugoDaniel> ah nice
13:21:44 <HugoDaniel> and is it possible to convert from Int to Word32/Int32 ?
13:21:44 <BONUS> HugoDaniel: Data.Bits
13:21:50 <Cale> fromIntegral
13:21:54 <HugoDaniel> sweet
13:21:56 <HugoDaniel> thanks :D
13:21:59 <Adamant> I read semi-near-ring as semi-earring and was starting to wonder if there was another bit in abstract algebra I hadn't heard about before
13:21:59 <BONUS> > fromIntegral (3 :: Int32) :: Word32
13:22:00 <lambdabot>   3
13:22:08 <HugoDaniel> now i have all that i need
13:22:10 <HugoDaniel> :D
13:23:07 <Cale> One thing I don't understand is the general lack of appearance of homomorphisms in most of the material I've ever seen on matroids.
13:23:20 <Cale> It would seem to me like the first thing you'd want to define.
13:23:30 * ivanm has never understood what a matroid was
13:23:54 <MissPiggy> can't you get homomorphisms come from universal algebra
13:24:00 <Cale> ivanm: Do you know what linearly independent sets in a vector space are?
13:24:13 <sproingie> it's like a metroid but not
13:24:14 <ivanm> well, I'm supposed to since I did exams on it and passed... >_>
13:24:15 <ivanm> ;-)
13:24:43 <Cale> ivanm: Okay, so a matroid is a set together with a collection of subsets of it which are simply specified to be the "independent" sets.
13:24:53 <Cale> They must satisfy the properties that:
13:24:56 <ivanm> independent in what sense?
13:25:00 <Cale> 1) The empty set is independent
13:25:09 <Cale> In any sense which satisfies some axioms :)
13:25:12 <ivanm> aha
13:25:23 <ystael> sproingie: that might explain why occasionally in my last combinatorics class somebody would fall out of their seat, roll up in a ball, and start shouting "arf arf arf get it off me!!" ... then you'd hear a loud BOOM and everything would be OK.
13:25:24 <ivanm> right, empty set makes sense
13:25:26 <Cale> 2) Every subset of an independent set is independent.
13:25:41 <ivanm> yup, makes sense
13:26:10 <Cale> 3) If A and B are two independent sets, and A has more elements than B, then there exists an element in A which is not in B that when added to B still gives an independent set.
13:26:30 <ivanm> hmmmmm....
13:26:41 <Cale> #3 is somewhat subtle, but you might (vaguely?) remember it from linear algebra class.
13:26:43 <lunabot>  luna: parse error on input `class'
13:26:50 <sproingie> ystael: naw that was just them coming down off of speed :)
13:26:53 <ivanm> Cale: what's the linear equivalent?
13:27:01 <ivanm> by replacing a 0 with a value?
13:27:07 <Cale> The very same thing, but with sets of vectors
13:27:16 <Cale> and independence is linear independence
13:27:17 <ivanm> oh, a set of vectors...
13:27:44 * ivanm isn't sure how you can guarantee that
13:27:46 <aledge> is that replacing a column by some combination of it and another column?
13:27:51 <aledge> in a matrix i mean
13:28:03 <ystael> sproingie: meth is that bad?
13:28:12 <medfly> ?
13:28:16 <Cale> It's usually called the extension theorem, I believe, and it's a critical part of showing that any two bases have the same number of elements.
13:28:32 <Cale> (which leads to the definition of the dimension of a vector space)
13:28:49 * ivanm quickly looks up what bases are again
13:29:05 <ivanm> is the base for R^3 just {i,j,k} ?
13:29:13 <Cale> That is *a* basis
13:29:20 <MissPiggy> so for any Ring R and Monoid M, R[M] is Ring?
13:29:20 <ivanm> right
13:29:27 <Cale> A basis is a linearly independent set whose span (the set of linear combinations of vectors in the set) is the whole vector space.
13:29:39 <ivanm> OK, a basis is just a set of vectors which are linearly independent but can be used to create any other vector?
13:29:42 <ivanm> right
13:29:48 <MissPiggy> The best thing to do is put + and * in Ring then!
13:30:10 <Cale> In our more general setting of matroids, we can define a basis to be an independent set such that adding any extra element to that set will make it dependent.
13:30:21 <MissPiggy> Cale is that different to rank-nullity or just a different name?
13:30:25 <ivanm> OK, so a maximal independent set?
13:30:25 <Cale> ivanm: right
13:30:28 <Cale> yes
13:30:56 <Cale> MissPiggy: I guess it's somewhat related to rank-nullity, but not quite the same
13:31:26 <Cale> (rank-nullity is a theorem about linear transformations -- this is just considering sets of vectors)
13:31:34 <Cale> hang on, I have a chore to do :)
13:31:38 <ivanm> heh
13:34:58 <tolkad> My scrotum will not allow that action. Discontinue it immediately.
13:35:23 * sproingie discontinues tolkad's scrotum
13:35:39 <ivanm> we can haz ops standing by? kthnx
13:35:45 <sproingie> dangling antecedents are a bitch
13:36:11 <xemdetia> *Does anyone know if there is a convenient way to OR together stuff like you can in C to pass to foreign functions?
13:36:41 <dobblego> @type any -- xemdetia ?
13:36:42 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
13:36:47 <MissPiggy> :t(.|.)
13:37:55 <xemdetia> dobblego: I am new as can be and unfortunately don't know what you mean by type any
13:38:19 <benmachine> xemdetia: what kind of or are you looking for?
13:38:26 <dobblego> xemdetia, I don't understand what you mean by your question, so I am taking a guess, with the any function, which works like this:
13:38:31 <dobblego> > any (==5) [1..10]
13:38:32 <lambdabot>   True
13:39:06 <MissPiggy> > 5 .|. 7 :: Word8
13:39:07 <lambdabot>   7
13:39:13 <MissPiggy> > 8 .|. 7 :: Word8
13:39:14 <lambdabot>   15
13:39:28 <xemdetia> I am rather new to haskell so I posed it poorly. I mean something along the lines of.. SDL_SWSURFACE | SDL_AUDIO | SDL_INPUT
13:39:35 <xemdetia> (In C that is)
13:39:37 <pikhq> :t (.|.)
13:39:39 <lambdabot> forall a. (Bits a) => a -> a -> a
13:39:48 <pikhq> Ah.
13:40:14 <benmachine> xemdetia: .|. combines bitflags, but usually if you want to specify flags in Haskell you might use a list
13:40:43 <xemdetia> Alright, cool. Thanks everyone. Trying to search for some of the special operators is the one thing that's killing me in trying to learn haskell
13:41:07 <Cale> xemdetia: They're just normal functions with different names :)
13:41:10 <dobblego> xemdetia, they aren't operators in Haskell, just library functions
13:41:16 <Cale> okay
13:41:54 <MissPiggy> suppose I had defined Abelian Group and Monoid on the same set -- how would you define Ring from these?
13:41:58 <xemdetia> Right, sorry.
13:42:25 <Cale> ivanm: So does that definition make some amount of sense?
13:42:27 <benmachine> MissPiggy: if you want a ring you need the monoid to distribute over the group
13:42:35 <MissPiggy> benmachine but that's not haskell
13:42:48 <benmachine> well, you could just do
13:43:01 <benmachine> class (AbelianGroup a, Monoid a) => Ring a where
13:43:05 <benmachine> and then specify no methods
13:43:15 * benmachine isn't sure if you need the where or not
13:43:27 <MissPiggy> then how can I use + and * to denote the group and moniod operations, respectively?
13:43:43 <lispy> :t subRegex
13:43:44 <lambdabot> Not in scope: `subRegex'
13:43:45 <benmachine> erm
13:44:05 <lispy> I'm totally mystified by the way matching works with Text.Regex
13:44:07 <Cale> ivanm: I just remembered another way that the extension theorem is often stated is that if V is any vector space, and W is a subspace of V, and B is a basis of W, then there exists a set C of vectors of V such that B union C is a basis of V.
13:44:14 <benmachine> pass
13:44:15 <lispy> subRegex (mkRegex "foo") "bar" "I am foo!"  ==> "bar"
13:44:34 <Cale> (any basis for a subspace extends to a basis for the whole space)
13:44:34 <lispy> I really wanted "I am bar!"
13:44:43 <lispy> Any ideas what I'm doing wrong?
13:46:23 <Cale> Parameters are in the wrong order
13:46:34 <Cale> subRegex has a weird parameter order
13:47:05 <Cale> (just flip the last two there)
13:49:11 <Twey> Seems reasonable to me.  It allows you to define a ‘pattern’ function.
13:49:43 <Twey> > let sr = subRegex (mkRegex "foo") "I am foo!" in (sr "bar", sr "baz")
13:49:44 <lambdabot>   Not in scope: `subRegex'Not in scope: `mkRegex'
13:49:53 <Twey> Oh, well, you get the idea
13:51:14 <lispy> Oh, I swear I checked I that :)
13:51:17 <lispy> Thanks guys
13:51:23 <lispy> That is a weird parameter order
13:51:33 <HugoDaniel> if my code is all made of pure functions and i use lots of indexing in a const list of values, does ghc reason enough to automagically replace these values during compile time ?
13:51:58 <benmachine> Twey: but it doesn't allow you to define a substitution function
13:54:37 <lispy> HugoDaniel: you could check the core
13:54:41 <MissPiggy> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16535#a16535
13:54:48 <MissPiggy> this is the idea
13:55:00 <HugoDaniel> lispy: the core ?
13:55:00 <MissPiggy> the question is, Is it possible to actually implement it?
13:55:25 <Eduard_Munteanu> Hi.
13:55:27 <lispy> HugoDaniel: yeah.  It's optimized haskell without the syntax sugar
13:55:39 <MissPiggy> it seems like it would be easy if you could do   class (g::Group r, m::Monoid r) => Ring r where zero = g.e ; (+) = g.(&)
13:55:49 <MissPiggy> but you can't do that so I am not sure what is the sort of, alternative way
13:56:03 <lispy> HugoDaniel: basically, you inspect the input program after optimization: http://hackage.haskell.org/package/ghc-core
13:56:17 <MissPiggy> I was thinking maybe, r r', and then something about an equality coercion but that's not really going to work
13:56:24 <MissPiggy> (since it's brought into the context)
13:56:27 <lispy> HugoDaniel: you can either use that tool (ghc-core) or read GHCs manual to find the commandline flags
13:56:40 <Cale> HugoDaniel: regarding your question about lists and indexing, almost certainly not.
13:56:47 <Cale> (I would be quite surprised)
13:57:20 <MissPiggy> I'm looking at http://haskell.org/haskellwiki/GHC/Indexed_types for inspiration but not getting any
13:57:28 <Cale> Using indexing on lists is generally a bad sign.
14:01:23 <MissPiggy> class (Group r, Monoid r') => RingHORRIBLEHACK r r' where
14:01:26 <MissPiggy> class RingHORRIBLEHACK r r => Ring r where
14:01:29 <MissPiggy> that works..
14:02:03 <MissPiggy> except when you try to actually use it
14:02:16 <HugoDaniel> Cale: what about an immutable array ?
14:02:57 <Cale> HugoDaniel: Well, that will be faster anyway
14:03:25 <Cale> Generally if you really *need* indexing making an array is probably worthwhile.
14:03:40 <jmcarthur> MissPiggy: you are wanting constraint synonyms :)
14:03:58 <MissPiggy> I am not sure how to use them to solve this
14:04:00 <jmcarthur> MissPiggy: i believe it's one of the tickets on alt-stdlib
14:04:06 <Cale> But often there are ways to avoid needing to index into lists by manipulating things collectively in the right way
14:04:31 <jmcarthur> MissPiggy: for your example, you would say:  constraint Ring r = (Group r, Monoid r)
14:04:53 <MissPiggy> does that let me use + and *
14:05:12 <jmcarthur> MissPiggy: i have a big file at home that allows it, in a different way than you attempted there
14:05:26 <MissPiggy> well? :)
14:05:35 <jmcarthur> MissPiggy: i will show it to you when i get home later, if you want
14:05:42 <MissPiggy> yeah that would be grand thans
14:05:44 <MissPiggy> thanks
14:05:55 <jmcarthur> MissPiggy: it relies on a preprocessor implementing constraint synonyms
14:06:20 <jmcarthur> but essentially it does what you did, but simpler... why did you do the RingHORRIBLEHACK part?
14:06:41 <MissPiggy> I was trying to get + and * to work, infact RingHORRIBLEHACK doesn't even do that
14:06:41 <jmcarthur> why not just class (Group r, Monoid r) => Ring r?
14:06:46 <jmcarthur> oh
14:07:11 <Cale> Uh, a ring is an Abelian group which is also a monoid...
14:07:11 <jmcarthur> i manage it with newtype wrappers and flexible contexts
14:07:23 <Cale> (not just any group...)
14:07:31 <jmcarthur> err, yeah, that too
14:07:50 <Cale> But I don't think that classification is really useful for a numeric hierarchy.
14:08:32 <Cale> I would prefer the classes be named after the notations rather than the properties.
14:08:34 <jmcarthur> MissPiggy: basically i have, outside of type classes, (+) :: Magma (Sum a) => a -> a -> a ; (*) :: Magma (Product a) => a -> a -> a ; etc.
14:08:41 <jmcarthur> Cale: what do you mean?
14:09:03 <Cale> class Additive a where zero :: a; (+) :: a -> a -> a
14:09:12 <Cale> class Multiplicative a where one :: a; (*) :: a -> a -> a
14:09:17 <jmcarthur> ah, yeah that's another way
14:10:01 <jmcarthur> i mainly don't like that because you have to denote one of those as a more canonical monoid than the other
14:10:15 <benmachine> it's additive, sorted
14:10:16 <jmcarthur> if all you want is monoid
14:10:31 <benmachine> personally I prefer ++ to + though for no well-explored reason
14:10:53 <benmachine> well, I prefer "foo" ++ "bar" to "foo" + "bar"
14:10:56 <Cale> jmcarthur: Actually, I'd have a separate monoid class altogether.
14:11:18 <jmcarthur> Cale: then my issue with it becomes a lot of duplication
14:11:21 <Cale> Maybe with ++ and unit or some such.
14:11:40 <benmachine> maybe Additive should include - and negate
14:11:47 <benmachine> because they are sort of related
14:11:52 <Cale> Yeah, quite possibly
14:12:17 <jmcarthur> i prefer the properties classification
14:12:22 <MissPiggy> class (Group g r, Monoid m r) => Ring r where
14:12:33 <Cale> Well, Float technically satisfies none of those.
14:12:38 <benmachine> why are Group and Monoid multiparameter :o
14:12:41 <MissPiggy> g and m are just labels
14:12:45 <jmcarthur> i don't usually care if it's additive or multiplicative. i care that it's associative and/or unital
14:12:49 <Cale> Addition and multiplication of floats isn't associative.
14:13:18 <benmachine> Cale: I propose that we consider all properties of Floats to hold iff one appends "ish" to them
14:13:19 <Cale> Nor does it satisfy a distributive law.
14:13:33 <Cale> I don't like that.
14:13:41 <jmcarthur> Cale: i personally think floats should either be accepted as a close enough approximation or not included in those type classes. i'd prefer the former as long as it's treated consistently, i think
14:13:46 <Cale> I think they're usable as numbers, but calling them a ring is nonsense.
14:13:49 <MissPiggy> different equivalence relation than congruence
14:14:10 <Cale> This is my main opposition to using the names from mathematics.
14:14:12 <MissPiggy> non-transitive equality
14:14:30 <MissPiggy> a == b and b == c (both close) but not (a == c) (far apat)
14:14:31 <jmcarthur> Cale: i'm all for having some sort of less hackish Num heirarchy, but not necessarily in place of a good algebra
14:14:34 <Cale> I think that Float and Double deserve to be treated uniformly with other numbers for convenience.
14:14:57 <Cale> But I don't think they deserve the name Ring (or group / monoid etc.)
14:14:58 <jmcarthur> Cale: conversely, i'm not sure i want an algebra to completely replace the Num heirarchy. perhaps that would settle your dispute with me?
14:15:12 <Cale> I think we should keep Num
14:15:17 <jmcarthur> then Float and Double would be in the Num heirarchy but not in the algebra
14:15:20 <Cale> But split signum and abs out
14:15:28 <jmcarthur> Cale: yes, something like that
14:15:30 <Cale> and drop the Eq and Show constraints
14:15:48 <Cale> the rest of the numeric hierarchy I'm mostly okay with
14:15:48 <benmachine> my understanding for Eq was that it was for numeric patterns
14:16:04 <jmcarthur> but i would still prefer that the algebra be able to get the (+) and (*) operators, etc., which i think complicates things with Num or something
14:16:16 <Cale> Though "Real" was a stupid choice of name, I'm not sure it really matters
14:16:47 <Cale> *maybe* we should have a numeric class which separates out negate and (-)
14:16:57 <Cale> Because I think natural numbers are important
14:17:20 <Cale> Well...
14:18:01 <Cale> There is a natural (-) on natural numbers which is total, though it doesn't satisfy the normal properties you'd expect of subtraction in a ring, of course.
14:18:27 <Loriel> Well, it is a ring so I expect it to wrap around
14:18:29 <Cale> The idea being that natural numbers are something like lists of ()
14:18:37 <Cale> and subtraction is something like \\
14:18:43 <ddarius> Cale: Saturating subtraction or what?  And what makes it natural?
14:18:49 <ddarius> Okay.
14:19:08 <Cale> It turns out to be the thing you want most often
14:19:13 <Cale> There was a good paper about it
14:19:15 <ddarius> Maybe we should accept that naturals are a Z-torsor.
14:19:22 <Cale> (in the context of Haskell)
14:19:38 <ddarius> (-) :: AdditiveTorsor g s => s -> g
14:19:38 <Cale> Or... at least functional programming.
14:19:44 <ddarius> (-) :: AdditiveTorsor g s => s -> s -> g
14:20:39 <MissPiggy> I updated my paste
14:20:40 <MissPiggy> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16535#a16537
14:21:09 <ddarius> Then we can have: instance AdditiveTorsor Vector Point
14:21:10 <MissPiggy> this still doesn't work, it's just explaining that the problem doesn't go away if you point the constaints in the other direction
14:21:13 <jmcarthur> my beef is only that i like having concrete properties with which to reason about my code. i get that Float and Double complicate that, but if they are the only things interfering with having such properties as requirements for an algebra replacing num, i'm fine with considering them a close enough approximation.
14:21:32 <ddarius> I always define distinct Point and Vector types.
14:21:38 <MissPiggy> just define   _ == _ = True  for floats
14:21:42 <MissPiggy> then the laws hold
14:21:51 <Cale> haha
14:21:57 <jmcarthur> heh
14:22:02 <ddarius> MissPiggy: And the Ord instance?
14:22:16 <jmcarthur> ddarius: if they are all equal it doesn't matter what Ord does
14:22:17 <ddarius> 3 < 4 && 4 < 3
14:22:38 <ddarius> jmcarthur: It forces the Ord definition.
14:22:43 <jmcarthur> yeah
14:22:46 <ddarius> compare _ _ = EQ
14:22:51 <jmcarthur> it was a joke :P
14:23:34 <jmcarthur> constraint Num a = (Magma (Sum a), Magma (Product a), some other stuff)
14:23:37 <Cale> I don't mind using different syntax for anything which only has one operation, somehow.
14:23:44 <jmcarthur> no properties on Magma, really :)
14:24:49 <jmcarthur> as long as we keep the type classes providing the notation separate from the ones providing the properties, we can make constraint synonyms out of them however we want without forcing properties on them
14:24:56 <jmcarthur> so Float and Double would work fine
14:25:03 <Cale> You can split up Num into tiny tiny pieces, but I kind of think it'll mostly be annoying.
14:25:09 <Eduard_Munteanu> When doing cabal install ghc-core, I get this: Not in scope: data constructor `C.ExitException'
14:25:13 <Eduard_Munteanu> Am I missing anything?
14:25:21 <idnar> ring wrong
14:25:31 <gwern> so I just registered an account on hawiki for a stacey walters
14:25:31 <Eduard_Munteanu> I have ghc-6.10.4
14:25:36 <jmcarthur> Cale: annoying how? with constraint synonyms i could even still say Num a => a instead of having to mess with all the tiny pieces
14:25:39 <Cale> At least, unless we can find a way to let people ignore all the classes they don't care about and write instances for the "large" ones.
14:25:42 <gwern> out of curiosity, I tried http://staceywalters.com/ . o.0
14:25:59 <Cale> jmcarthur: Can you even do that when defining an instance?
14:26:04 <jmcarthur> ah, class aliases is what you would rather have it looks like?
14:26:11 <Cale> Perhaps, yes.
14:26:21 <jmcarthur> Cale: you want to be able to define Num and have the pieces defined automagically?
14:26:51 <Cale> jmcarthur: yeah, given that we're splitting up Num into tiny parts. I wouldn't mind defining signum and abs in a separate class, say.
14:27:07 <jmcarthur> i think that is a reasonable thing to want
14:27:23 <Cale> But once it gets to the point of (+) and (*) being in separate instances, it's starting to be a bit annoying.
14:27:32 <jmcarthur> would be nice if it could play nice with the constraint families stuff
14:28:15 <jmcarthur> i suspect this is doable
14:28:15 <opqdonut> Cale: there should be something like "instance Plus, Times, Signum: MyType where (+) = ...; (*) = ...; "
14:28:23 <MissPiggy> I think I got it to work
14:28:23 <opqdonut> give or take syntax
14:28:26 <MissPiggy> anyone want to see
14:28:34 <jmcarthur> opqdonut: that's kind of nice, but i like Cale's suggestion better i think
14:28:39 <MissPiggy> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16535#a16538
14:29:04 <jmcarthur> opqdonut: to just have Num which is a synonym for those other classes but you can treat it as just one class
14:29:15 <opqdonut> yeah
14:29:29 <MissPiggy> the general idea is that you define the biggest possible structure you have on a set, in whole -- and that produces instances for all the substructures
14:29:44 <MissPiggy> so Ring gives you two Monoid instances and an (Abellyan) Group instance
14:30:16 <jmcarthur> MissPiggy: that's kind of the opposite direction i've taken so far
14:30:25 <MissPiggy> yeah I flipped the arrow
14:30:33 <MissPiggy> the other way wasn't working
14:30:38 <jmcarthur> MissPiggy: but i think it kind of does what Cale wants, too. a way to do both would be nice
14:32:09 <Cale> Mostly, I don't mind the coarse hierarchy though.
14:32:16 <jmcarthur> where you aren't locked into having a Ring just to have a Monoid, but you get a Monoid for free by defining a Ring
14:32:41 <Cale> I would just be happy to have instances of Num for functions.
14:32:53 <jmcarthur> Cale: i really really want a fine grained hierarchy, but i don't mind working to be able to please both camps
14:33:06 <MissPiggy> what does coarse hierarchy?
14:33:07 <MissPiggy> mean
14:33:24 <MissPiggy> What does everyone think of my approach
14:33:26 <MissPiggy> im a newbie
14:33:28 <jmcarthur> MissPiggy: closer to what we have already. you can't decompose Num into its parts
14:33:37 <PeakerWork> Cale: then need to generalize Eq to (a -> Bool) and such as well
14:33:52 <MissPiggy> how can you Eq on  (a -> Bool)?
14:33:52 <MissPiggy> that doesn't seem possible
14:33:56 <MissPiggy> computable
14:33:58 <Cale> PeakerWork: what?
14:34:07 <jmcarthur> MissPiggy: i think your approach has the appearance of being fine grained but is actually a bit coarse
14:34:09 <PeakerWork> Cale: if you pattern-match a Num against 1, and it happens to be a function..
14:34:13 <MissPiggy> coarse in what sense?
14:34:23 <Cale> PeakerWork: If you pattern match against 1, then your function needs an Eq instance.
14:34:23 <PeakerWork> MissPiggy: You can have the entire resulting function be in the (a->) reader
14:34:30 <jmcarthur> MissPiggy: the idea is the Eq constraint would be removed from Num, so Eq (a -> Bool) is unnecessary
14:34:35 <Cale> PeakerWork: which wouldn't exist for functions, obviously
14:34:37 <PeakerWork> Cale: ah, just taking that out of Num sounds simpler, yeah
14:34:44 <MissPiggy> ah so (==) :: (a -> Bool)^3
14:34:48 <PeakerWork> Cale: Currently Eq is a super-class of Num because of pattern matching, iiuc
14:34:54 <MissPiggy> err that notation is ridiculous, why did I write that
14:35:01 <opqdonut> :D
14:35:18 <jmcarthur> MissPiggy: coarse in the sense that you can't have an Additive or Multiplicative Monoid without a Ring in your version
14:35:27 <jmcarthur> but i guess it's a lot more fine grained that what we have now at least
14:36:00 <opqdonut> IMO the correspondences between algebraic structures are too hard to be captured in a/the class system
14:36:04 <MissPiggy> oh??
14:36:13 <opqdonut> but certainly, we could have something better than the current state
14:36:14 <MissPiggy> jmcarthur you are right in terms of confluence or something
14:36:18 <jmcarthur> MissPiggy: yours isn't so bad. i'm not sure i'd want to use it though
14:36:21 <MissPiggy> it is not allowed to define a Additive or Multiplicative
14:36:24 <Cale> When I first started programming in Haskell, I thought that the numeric hierarchy should be more like the mathematical one, but I've come to the opinion that there are a lot of matters involved in programming with numbers that mathematics doesn't really concern itself with.
14:36:43 <MissPiggy> but you can define a Monoid on anything you wan't
14:36:47 <Cale> (or traditional algebra, anyway)
14:36:57 <jmcarthur> MissPiggy: yes, that causes me to forgive it a bit :)
14:37:07 <ddarius> Cale: Namely finite, computable representations...
14:37:12 <opqdonut> :D
14:37:15 <MissPiggy> I wish a better solution but I think I've been a week on this and still not sure
14:37:28 <Cale> Using the names from traditional algebra, but writing instances which aren't really instances of those concepts seems really disingenuous to me.
14:37:33 <jmcarthur> MissPiggy: i promise to show you my solution when i can
14:37:38 <jmcarthur> hmm...
14:37:45 <MissPiggy> I do not beleive that static analysis GHC does on the typeclass constaints is enough to make large scale programming with what I got now reasonable
14:37:48 <ddarius> Cale: So pull an O'Caml.  Floats are the only big problem I can see.
14:37:58 <MissPiggy> I agree with ocaml
14:37:58 <Cale> Better to use vague names that people will recognise the rough meaning of, and use the laws when we can get them.
14:38:32 <MissPiggy> Cale (just by the way, I am not doing any numerics -- just symbolic stuff,)
14:38:47 <Cale> I prefer the way we have things now to O'Caml's idea.
14:38:49 <dons> "enough to make large scale programming with what I got now reasonable" -- sound unusual
14:38:56 <dons> what do your type class constraints look like?
14:39:07 <jmcarthur> again, if we define Num in terms of Magma and other very loose type classes which don't have many/any laws with them then we avoid the need to prove things about weird data representations
14:39:29 <jmcarthur> yet we still get the chance to instantiate the type classes denoting properties if we want
14:39:36 <Cale> jmcarthur: Yeah, but why bother with the name "Magma"
14:39:44 <jmcarthur> including benefits like rewrite rules
14:39:51 <Cale> That's no different than naming the classes after their notations :)
14:39:55 <MissPiggy> dons, I am doing an unusual thing with them <http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16535> the issue I see is (that jmcarthur pointed out), You are not allowed to define Additive or Multiplicative monoids yourself -- but the compiler doesn't check things like that. So if you build a much larger heireachy keeping track of all this stuff in ones head is going to become impossible
14:39:58 <ivanm> Cale: ahhh, yeah, I vaguely recall something like that (union forms another basis)
14:40:05 <ivanm> though I don't recall why that is...
14:40:07 <jmcarthur> Cale: that's essentially what Num is. a class for the notation, not the laws
14:40:08 <Cale> and more people will understand what Additive and Multiplicative refer to than Magma :)
14:40:31 <jmcarthur> Cale: that's what the newtypes are for, in my version
14:41:01 <dons> interesting.
14:41:04 <jmcarthur> Cale: regardless, if you can just define Num you're good anyway
14:42:04 <MissPiggy> so I feel like I should think harder about this stuff before just going with what I have got now
14:42:17 <Cale> jmcarthur: Perhaps we can have empty classes which are subclasses(?) of the general ones to denote when various laws are satisfied.
14:42:21 <jmcarthur> MissPiggy: well, i am going home soon. if my wife and i don't immediately eat out, i will get my algebra on hpaste for you
14:42:30 <jmcarthur> Cale: that's exactly my idea
14:42:45 <MissPiggy> jmcarthur, thanks, but don't go out of your way for me! if I don't get to see it for a week I'm still happy
14:43:02 <jmcarthur> Cale: this algebra i'm going to show MissPiggy later is an example of it. i'll ping you when i paste it
14:43:57 <Cale> jmcarthur: If we can take care of all the issues regarding instance creation (class aliases seem like a solution), then this wouldn't be too unreasonable. At that point, a lattice hierarchy would also be nice.
14:44:08 <jmcarthur> Cale: indeed :)
14:44:29 <jmcarthur> although i don't know enough about lattices to claim to be up to the task
14:45:00 <MissPiggy> I don't understand how class aliases come into it
14:45:07 <MissPiggy> presumably that will become clear in the future
14:45:43 <jmcarthur> i'll annotate the code with what a Num instance might look like with the class aliases proposal
14:45:52 <jmcarthur> and what its effects would be
14:46:13 <MissPiggy> is there a name for this structure?
14:46:20 <jmcarthur> for what structure?
14:46:25 <Cale> MissPiggy: They come into it because with fine hierarchies and without some additional mechanism to automate the construction of intermediate instances, you end up pissing off everyone who wants to write instances of the classes near the top.
14:46:59 <MissPiggy> well it's an isomorphism, but let me explain anyaywa,
14:47:07 <jmcarthur> MissPiggy: in our current library, class aliases might allow us to define Eq and Show inline in a Num instance, for example
14:47:11 <Cale> I shouldn't have to write half a dozen instances in order to write an instance of Num, for example.
14:47:15 <MissPiggy> you have some   newtype Foo a = Foo { unFoo :: Foo a -> a }
14:47:19 <MissPiggy> woops
14:47:23 <MissPiggy> you have some   newtype Foo a = Foo { unFoo :: a }
14:47:36 <MissPiggy> now there is an isomorphism between Foo a <-> a
14:48:05 <MissPiggy> so what about operators to left   (&) :: a -> a -> a  to  <|&|> :: Foo a -> Foo a -> Foo a
14:48:15 <MissPiggy> lift*
14:48:26 <MissPiggy> and similar for any n-ary function
14:49:01 <MissPiggy> Cale, doesn't my approach solve that then
14:49:01 <MissPiggy> ?
14:49:08 <ivanm> Cale: so how does that third property of matroids work?  I'm finding it rather strange that two you can copy values from one independent set to the other and still have it remain independent
14:49:36 <ivanm> (especially since wikipedia doesn't say what it means by independence)
14:49:50 <McManiaC> myThreadId >>= killThread ← valid or not so valid way to quit a "forkIO . forever $ ..." function?
14:49:53 <McManiaC> :D
14:49:55 <ivanm> or is that how you just generate the independent sets? (i.e. get a basis, and then generate)?
14:52:39 <MissPiggy> okay I guess I'll just define an Isomorphism class then
14:53:18 <MissPiggy> sorry Bijection*
14:55:04 <chrisdone> @hoogle sleep
14:55:05 <lambdabot> No results found
14:55:26 <MissPiggy> @hoogle threadDelay
14:55:26 <lambdabot> Control.Concurrent threadDelay :: Int -> IO ()
14:55:33 <chrisdone> cheers
14:55:40 <HaskellLove> any book recommendation on abstract algebra for noobs?
14:56:43 <sproingie> i have one but i forgot its name :p
14:56:58 <Adamant> I think people like the Dover book
14:57:06 <Adamant> on Abstract Algebra
14:57:13 <Adamant> but ask a math major :P
14:57:51 <nomadmonad> I have 370 MB xml file, which xml lib would be best to parse it into memory?
14:58:10 <nomadmonad> my guess is that SAX like processors would consume the file without reading it into memory first
14:58:11 <sproingie> you need it all in memory?
14:58:17 <sproingie> that's what SAX is about, yes
14:58:45 <Twey> Hm, do we not have a working implementation of class aliases yet?
14:58:47 <nomadmonad> sproingie: I need all the info (and a lot more) in  a memory to process it, but reading should be fast and easy
14:59:43 <sproingie> HXML has some dom-ish thing i believe
15:00:01 <sproingie> not the API, but document-at-once anyway
15:00:32 <sproingie> sorry that's HXT
15:00:45 <MissPiggy> I need CHR in the type level :(
15:01:13 <MissPiggy> could not deduce Bijection b a from Bijection a b, is there any way to deal with this that isn't infinnite loops?
15:01:19 <benmachine> is it weird that having decided that dc needs two minor additions the first strategy that comes to mind is to rewrite it in haskell
15:01:38 <sproingie> actually i do see DOM, i just don't see docs offhand
15:02:09 <sproingie> benmachine: "rewrite it in haskell" is often my first instinct too :)
15:02:26 <sproingie> not that i've gotten around to rewriting much at all in haskell
15:02:29 <benmachine> heh
15:02:44 <nomadmonad> sproingie: hmm. haxml seems to have Text.XML.HaXml.SAX
15:03:27 <sproingie> right, you said you needed the whole document at once.  a SAX api is not going to be fun for that
15:03:50 <sproingie> you can reinvent your own document model, i can think of more fun things to do
15:04:50 <nomadmonad> sproingie: which seems to be lot of trouble anyway: saxParse file content takes a filename and the string content of that file and generates a stream of SaxElements.
15:05:22 <dobblego> nomadmonad, I parsed a 360GB file with HXT just fine
15:06:00 <nomadmonad> sproingie: yes, efficient in memory representation of DOM to convert that to into real data structure is needed. I'd like to avoid SAX but building DOM should be done from SAX like events instead of parsing in-memory string of file contents.
15:06:31 <dobblego> the two are not unifiable; just use laziness and win
15:07:29 <sproingie> there's plenty of lazy DOM parsers.  i'd be pretty surprised if haskell's werent
15:07:47 <MissPiggy> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16539
15:07:57 <sproingie> dobblego: 360 *gigs*
15:07:57 <MissPiggy> I am sort of confused about this thing
15:08:05 <sproingie> dobblego: what API did you use to parse that?
15:08:15 <MissPiggy> so hopefully anyone that knows a bit about the types could tell me how to get rid of IncoherentInstances ?
15:08:19 <dobblego> sproingie, http://code.google.com/p/geo-osm
15:08:21 <nomadmonad> dobblego: were you using Text.XML.HXT.IO.GetFILE or what was the way?
15:08:28 <MissPiggy> or maybe there is just a much better way all-together
15:08:39 <dobblego> HXT picklers
15:08:58 <MissPiggy> the code actually works I just want rid of that scary extention
15:09:37 <MissPiggy> and also wonder if there's a better way to define it so that I don't have to define two (of the same) instances every time
15:09:48 <sproingie> instance Bijection Rejection where forward = error
15:11:08 <MissPiggy> im rubbish at typeclasses
15:11:25 <nomadmonad> dobblego: thanks for pointing this out. I gotta check out the code and see if I'm able to understand it, perhaps even follow the route.
15:12:27 <MissPiggy> maybe this was just a stupid idea all-together and I should just type it out by hand instead of making a function do it?
15:15:39 <MissPiggy> :[
15:15:50 <MissPiggy> or what could I read that explains how to use them properly/
15:17:33 * benmachine is reading through code that prefixes a series of import statements with the helpful reminder, -- imports
15:17:41 <MissPiggy> heh
15:17:58 <Botje> -- WARNING: the following lines are imports!
15:18:04 <Botje> -- DO NOT TOUCH ON PAIN OF DEATH!
15:18:35 <MissPiggy> anyone want to help me with typeclasses because I'm sort of losp
15:18:37 <MissPiggy> lost*
15:19:00 <MissPiggy> I don't really even understand how they compute
15:21:25 <lispy> Is it just me or does when have a silly/broken type?
15:21:37 <lispy> Hmm
15:21:44 <ddarius> :t when
15:21:45 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
15:21:55 <idnar> what's wrong with it?
15:21:57 <lispy> Couldn't it be changed so that the null branch is still m a
15:22:03 <lispy> :t Just
15:22:04 <ddarius> lispy: Yes, but to what end?
15:22:05 <lambdabot> forall a. a -> Maybe a
15:22:13 <lispy> :t Nothing
15:22:14 <lambdabot> forall a. Maybe a
15:22:25 <idnar> @src when
15:22:25 <lambdabot> when p s = if p then s else return ()
15:22:38 <benmachine> you could have return undefined but what would be the point
15:22:47 <benmachine> if there is no return value the type should be m ()
15:22:49 <lispy> Maybe what I want here doesn't make sense...
15:22:59 <ddarius> You could change it to: if p then Just <$> s else return Nothing :: Monad m => Bool -> m a -> m (Maybe a)
15:23:14 <idnar> @type maybe
15:23:15 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
15:23:21 <benmachine> that sounds pretty sensible actually
15:23:31 <benmachine> well, sort of
15:23:32 <idnar> @type bool
15:23:33 <lambdabot> Not in scope: `bool'
15:23:34 <lispy> ddarius: yeah, maybe that is what I need to do
15:23:44 <benmachine> I'm not sure that you often want to extract the value from a when
15:23:59 <lispy> ddarius:  but, I think I don't need the ExitCode that is generated inside my IO (), so I'll just ignore it?
15:24:34 <ddarius> Just tack on a (>> return ()) and that'll be fine.
15:25:08 <lispy> Yeah, Except, I've just decide I want to log something when the exit code is a failure :)
15:25:14 <lispy> So, it's probably best that it is m ()
15:25:17 <Eduard_Munteanu> Has Control.Exception.ExitException been removed somewhere in GHC 6.10?
15:25:24 <Eduard_Munteanu> ghc-core needs it and can't find it.
15:25:53 <ddarius> @hoogle ExitException
15:25:53 <lambdabot> Control.OldException ExitException :: ExitCode -> Exception
15:26:16 <Eduard_Munteanu> ddarius, thanks, I'll patch the code to use Control.OldException
15:27:17 <benmachine> Eduard_Munteanu: better would be to patch the code to not use ExitException :P
15:27:33 <Eduard_Munteanu> benmachine, yeah. Will make a proper patch and send it to the maintainer.
15:27:45 <Eduard_Munteanu> But I need a quick fix.
15:38:07 <Dashkal> Monad transformers are intimidating.  I need a little help to be sure I'm building my stack correctly.  I want a state monad that can fail with a reason.  I was thinking of stacking StateT over Either (I made an either monad instance so it can sit under it).  Does this sound sane?
15:38:24 <Dashkal> If the computation fails, I don't care about the final state
15:38:32 <kmc_> @unmtl StateT s (Either e) a
15:38:32 <lambdabot> s -> Either e (a, s)
15:38:49 <kmc_> A function which takes an old state and returns either an error, or a value plus a new state
15:38:53 <kmc_> That sounds like what you want
15:39:07 <Dashkal> Perfect.  Thank you.
15:39:13 <kmc_> Thank lambdabot :)
15:39:25 * Dashkal bows before lambdabot
15:39:34 <kmc_> @botsnack
15:39:34 <lambdabot> :)
15:39:34 <lunabot>  :o
15:39:37 <Dashkal> I hadn't heard of @unmtl before.  That looks handy for this kind of question
15:39:53 <BONUS> although interestingly, ErrorT e (State s) a works similarly
15:40:02 <BONUS> @unmtl ErrorT e (State s) a
15:40:03 <lambdabot> s -> (Either e a, s)
15:40:15 <benmachine> the difference being whether you get the final state or not
15:40:23 <Dashkal> *nods* I was suspecting that the error monad would work as well.  I'm going to investigate that as well before I actually build this beast.
15:40:24 <BONUS> yup
15:40:33 <BONUS> but it still has the short-circuiting behavior
15:41:01 <Dashkal> The greater concept is I have a large data structure that I want to mutate, but it's possible for that mutation to fail (trying to create a cycle in the tree, and other such oddities).
15:41:45 <Dashkal> If there's an ErrorT, I suspect there's an Error plain monad?
15:42:00 <kmc_> nah, they use Either for that
15:42:02 <kmc_> bad move, imo
15:42:06 <Dashkal> mmm
15:42:16 <Dashkal> Oh yeah, doesn't it restrict to Either String a?
15:42:16 <kmc_> Either should be symmetric in every way; Error would be isomorphic but would have the non-symmetric Monad instance, etc.
15:42:18 <BONUS> well kind of yeah
15:42:21 <kmc_> not really
15:42:31 <Dashkal> hmm, must be thinking of something else.
15:42:51 <Dashkal> I'm using a custom type for my errors (just a simple data declaration to simulate exceptions)
15:42:53 <BONUS> it's: instance (Error e) => Monad (Either e) where ...
15:42:55 <MissPiggy> it's so confusing
15:43:04 <BONUS> and everyone hates the Error e constraint
15:43:14 <MissPiggy> is there any tutorial to learn typeclasses inside out?
15:43:32 <ivanm> BONUS: isn't that required for fail ?
15:43:39 <ivanm> @src (Either e) Monad
15:43:39 <lambdabot> Source not found. You untyped fool!
15:43:43 <ivanm> @src (Either e) fail
15:43:44 <lambdabot> Source not found. My pet ferret can type better than you!
15:43:50 <ivanm> @src Either fail
15:43:51 <lambdabot> fail msg      = Left (strMsg msg)
15:43:58 <ivanm> yeah
15:43:59 <BONUS> yeah that's for fail, but fail is fail itself
15:44:03 <benmachine> kmc_: the ways in which you can partially apply Either are surely going to make Left and Right distinct
15:44:04 <ivanm> BONUS: true
15:44:22 <ivanm> stupid people using error for fail...
15:44:25 <benmachine> cf. functor
15:44:51 <kmc_> yeah, but if you expect those partial applications to do something more specifically useful, you should use a more specific type
15:45:08 <Dashkal> fail requiring a string is pretty much the reason I can't use it sensibly (if there is such a thing)
15:45:31 <Dashkal> But I'm content with Either WorldException a
15:46:35 <ivanm> Dashkal: well, fail needs a String because it's meant to be a fail _message_ ...
15:47:23 <gwern> ivanm: what, can we no longer read ASCII binary?
15:50:00 <MissPiggy> fundeps like class    Eval a b | a -> b    have been subsumed?
15:50:19 <kmc_> by type families?
15:50:23 <ddarius> @src fail
15:50:23 <lambdabot> fail s      = error s
15:50:29 <BONUS> i don't know if they have been deprecated or not
15:50:29 <BONUS> hm
15:50:30 <kmc_> sort of
15:50:33 <kmc_> they're not deprecated
15:50:35 <kushou_> (a,b) -> a
15:51:04 <kushou_> I want to see the bot whiche deduce the function from the type
15:51:19 <kushou_> -e
15:51:20 <BONUS> @djinn a -> a
15:51:20 <lambdabot> f a = a
15:51:22 <idnar> @djinn (a,b) -> a
15:51:22 <lambdabot> f (a, _) = a
15:51:33 <kushou_> thank you !
15:51:55 <BONUS> @djinn ((a -> r) -> r) -> (a -> (b -> r) -> r) -> (b -> r) -> r
15:51:55 <lambdabot> f a b c = a (\ d -> b d c)
15:52:11 <medfly> @hoogle (a,b) -> a
15:52:11 <lambdabot> Prelude fst :: (a, b) -> a
15:52:11 <lambdabot> Data.Tuple fst :: (a, b) -> a
15:52:11 <lambdabot> Prelude uncurry :: (a -> b -> c) -> (a, b) -> c
15:53:34 <benmachine> :t uncurry const
15:53:36 <lambdabot> forall a b. (a, b) -> a
15:57:34 <ivanm> gwern: there's an ASCII binary type to use?
15:58:45 <MissPiggy> http://www.haskell.org/haskellwiki/Research_papers/Type_systems#Type_classes
15:58:52 <MissPiggy> what should I read?
16:00:07 <BONUS> MissPiggy: what kind of detail are you looking for regarding type classes
16:00:13 <BONUS> just generally how they work or more advanced stuff
16:00:26 <MissPiggy> the thing is I can't figure out how to get my code right
16:00:30 <BONUS> like multiparams, associated types, etc.
16:00:39 <BONUS> MissPiggy: which code
16:00:40 <MissPiggy> but I think I have to know typeclasses better to do it
16:01:09 <MissPiggy> well it's 80 lines so maybe I should make a shorter example (that still compiles) to show
16:01:11 <MissPiggy> ?
16:01:15 <ivanm> BONUS: MissPiggy's code! ;-)
16:01:18 <MissPiggy> the only important bit is one typeclass though
16:01:22 <ivanm> MissPiggy: what kind of problems have you been having?
16:01:24 <BONUS> ah
16:01:27 <lament> i miss piggy :(
16:01:33 <MissPiggy> the first one is having to use IncoherentInstances
16:01:39 <ivanm> lament: heh
16:01:43 <ivanm> MissPiggy: there's your problem
16:01:44 <MissPiggy> and the second is having to define two instances when I should just write one
16:02:45 <MissPiggy> at any rate I'm completely stumped in terms of what to do
16:03:10 <MissPiggy> I don't want my whole architecture to fall down once it just about starts working
16:03:25 <ivanm> MissPiggy: paste some code so we can have a look?
16:03:33 <ivanm> but generally, you don't use extensions unless you have to
16:03:44 <ivanm> and even then only pick safe extensions unless you know what you're doing
16:03:51 <MissPiggy> the whole thing?
16:03:51 <ivanm> and IncoherentInstances is _not_ safe
16:03:56 <MissPiggy> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16549#a16549
16:03:59 <ivanm> MissPiggy: how long is it?
16:04:23 <MissPiggy> just look at line 58 and 60
16:04:30 <MissPiggy> 62*
16:04:32 <ivanm> MissPiggy: what are you trying to do here?
16:04:48 <kmc_> why is this better than "instance Bijection a (Additive a)" ?
16:04:56 <kmc_> your constraint forces the types to be equal anyway
16:04:57 <MissPiggy> I neede IncoherentInstances for this typeclass
16:05:26 <ivanm> why?
16:05:32 <MissPiggy> kmc_, the only reason why I don't do it that way is because it doesn't work
16:05:42 <MissPiggy> I have no idea
16:05:52 <kmc_> in which way does it not work?
16:05:57 <MissPiggy> um
16:05:58 <MissPiggy> type error
16:06:24 <MissPiggy> I made sure the file is self contained incase you want to experiment
16:06:27 <ivanm> kmc_: he's trying to say there's a bijection between Int and (Additive Int) I think...
16:06:35 <MissPiggy> newtype Additive a = Additive { unAdditive :: a } deriving (Eq, Show)
16:06:41 <MissPiggy> any newtype of that form is a bijection
16:06:43 <kmc_> right
16:06:43 <ivanm> *she
16:06:49 <MissPiggy> so the idea is that you can cast programs back and fort
16:06:56 <Twey> So what is one supposed to do for Happstack.State to stop the application producing ‘an application may still be using this state…’ when next you launch it?
16:07:02 <ivanm> MissPiggy: I would just have instance Bijection a (Additive a) though ...
16:07:05 <ivanm> AFAIK that'll work
16:07:14 * ivanm goes off to try it
16:07:24 <MissPiggy> yeah I'll do anything if it works
16:07:50 <kmc_> MissPiggy: when i make that change it gives me an error later on the Monoid instance
16:08:29 <kmc_> not sure i understand this BI type
16:08:43 <kmc_> what does a value of type (BI a b t t') mean?
16:08:54 <ivanm> MissPiggy: I'm thinking it might be your cast function that's the problem
16:09:12 <ivanm> nope, it isn't
16:09:27 <ivanm> MissPiggy: just have: instance Bijective a (Additive a) where
16:09:28 <ivanm> etc.
16:09:35 <ivanm> no need for incoherence!
16:09:44 <MissPiggy> kmc, remember that when you have a bijecton from A to B, then you can take any function or statement or whatever  (A -> (A -> A) -> A) .. and rewrite it into (B -> (B -> B) -> B)
16:09:48 <MissPiggy> it's just expressing that rule
16:09:56 <jmcarthur> ghc 6.10 allowed me to use (.) at the type level with TypeOperators, but ghc 6.12 doesn't...
16:10:11 <MissPiggy> you have to do a bit of contrafuncitonal twiddling but that's standard
16:10:19 <kmc_> MissPiggy: which part here is the desired end goal
16:10:34 <kmc_> i.e., if you make these instances without BI, does that help you?
16:11:00 <ivanm> MissPiggy: what's the point of your a ~ a' constraints?
16:11:07 <MissPiggy> How to define a typeclass that expresses bijections between a and b
16:11:11 <MissPiggy> but it should also work for b and a, symmetrical
16:11:19 <MissPiggy> (I suposse I really want the refl/sym/trans closure...)
16:11:28 <kmc_> don't you already have it, "class Bijection a b"
16:11:39 <MissPiggy> ivanm, I can't really say any reason except for 'they work', I wish I did know!
16:11:53 <ivanm> MissPiggy: what's wrong with just "Bijection a (Additive a)" ?
16:12:02 <ivanm> MissPiggy: type-checks =/= works
16:12:07 <ivanm> especially with some extensions
16:12:08 <kmc_> MissPiggy: i'm not sure they really work, might they work because they are vacuous implications?
16:12:19 * Dashkal suddenly falls in love with monad stacks
16:12:20 <MissPiggy> the neeeding IncoherentInstances and having to define every instance twice is the reason I think it's maybe a bad idea
16:12:32 <MissPiggy> kmc_, what is?
16:12:40 <kmc_> (a ~ a') =>
16:12:44 <MissPiggy> what about  that?
16:12:53 <kmc_> suppose it were never satisfiable
16:12:58 <ivanm> yup
16:13:06 <kmc_> admittedly, i can't see why that'd be the case here
16:13:14 <ivanm> MissPiggy: you will need to define every "instance" twice: one to and one from
16:13:20 <kmc_> MissPiggy: is this "BI" type integral to what you're doing, or only a means for writing the Monoid instances?
16:13:28 <ivanm> there's no real automatic way of having both done at once AFAIK
16:13:57 <MissPiggy> kmc_, BI only exists so I can write cast, and cast just shows a use-case of the Bijection class
16:14:23 <ivanm> MissPiggy: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16550#a16550
16:14:53 <kmc_> what'd you change?
16:15:06 <ivanm> kmc_: removed the ~ garbage
16:15:54 <jmcarthur> MissPiggy: i haven't had a chance to annotate this or add anything to demonstrate what Num should look like, but here is the algebra i wrote up a couple/few months ago http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16551#a16551
16:16:35 <interferon> how can i write the following points-free:
16:16:40 <jmcarthur> i have to go now to eat, but everybody feel free to destroy it while i'm gone
16:16:41 <medfly> use @pl
16:16:41 <interferon> entriesForDay day = filter matches
16:16:41 <interferon>     where matches x = date x == day
16:17:27 <medfly> filter (\x-> date x == day)
16:17:38 <ivanm> @pl \ day -> filter ( \x -> date x == day)
16:17:38 <lambdabot> filter . (. date) . (==)
16:17:42 <ivanm> interferon: ^^
16:17:48 <ivanm> but I would keep day as an argument methinks
16:17:50 <jmcarthur> MissPiggy: it relies on some other parts of alt-stdlib for some of the instances, but if you remove those and manage to get http://github.com/dorchard/constraintTermExtensions to compile (the preprocessor for constraint synonyms/families), you should be able to use it
16:17:53 <ivanm> @pl filter ( \x -> date x == day)
16:17:53 <lambdabot> filter ((day ==) . date)
16:18:00 <ivanm> yeah, that's much nicer
16:18:07 <kmc_> MissPiggy: i think you might want to convert more of this class structure to data
16:18:12 <ivanm> interferon: point-free isn't the be all and end all of haskell programming
16:18:21 <jmcarthur> MissPiggy: i forget why i needed undecidable instances, btw. might be able to remove that for all i know.
16:18:29 <jmcarthur> MissPiggy: anyway, have fun. be back later
16:18:41 <MissPiggy> I can't understand how ivanms version checks and mine doesn't (with the same edit)
16:19:06 <interferon> ivanm: thanks
16:19:11 <ivanm> interferon: no worries
16:19:20 <aavogt> ivanm: I wouldn't have guessed from #haskell :)
16:19:34 <ivanm> MissPiggy: because you might be needing incoherent instances elsewhere as well...
16:19:36 <ivanm> aavogt: heh
16:19:42 <KSkrzet> i'm building a library + executable with cabal. I want the executable to be build with -shared instead of standard static building. how can I achieve that?
16:19:54 <ivanm> aavogt: it can make some code cleaner, but not always
16:20:02 <MissPiggy> yeah so like
16:20:07 <MissPiggy> I need the a ~ a' stuff
16:20:08 <ivanm> KSkrzet: you are using GHC 6.12?
16:20:11 <aavogt> for varying definitions of clean
16:20:11 <ivanm> MissPiggy: why?
16:20:15 <MissPiggy> since it doesn't work otherwise like I said
16:20:21 <ivanm> MissPiggy: I meant something else needs incorent instances
16:20:32 <ivanm> MissPiggy: to test, remove the Bijection stuff and then see if it type checks
16:20:43 <kmc_> MissPiggy: i'm still confused as to whether you have an explicit desire to write the bijections explicitly, or whether the goal is simply to write the instances for Monoid and Group
16:21:19 <MissPiggy> ivanm it uses bijection so it wornt typecheck without it
16:21:23 <ivanm> oh, you're using cast in your Monoid definition
16:21:28 <KSkrzet> ivanm: yes
16:21:32 <MissPiggy> kmc_, what do you mean about class structure to data?
16:21:36 <MissPiggy> which classes
16:21:43 <MissPiggy> oh!!! I see!
16:21:45 <ivanm> KSkrzet: which OS?
16:21:51 <MissPiggy> I can just not make bijection a class
16:22:05 <KSkrzet> ivanm: Arch Linux 32 bit
16:22:07 <ivanm> MissPiggy: and I would query why you're doing such crazy stuff anyway
16:22:15 <ivanm> KSkrzet: so it should be possible...
16:22:18 <KSkrzet> ivanm: generally ghc --make -shared works
16:22:18 <MissPiggy> ivanm this is my trying to be good :(
16:22:19 <ivanm> I just don't know how ;-)
16:22:22 <sshc> is it possible to implement a function for a specific type?
16:22:36 <ivanm> (figured I'd just get the obvious possible problems out of the way)
16:22:46 <kmc_> sshc: what do you mean?
16:22:50 <ivanm> KSkrzet: look at the haskell reddit; there's been a discussion sometime this month there about how to do this IIRC
16:22:55 <KSkrzet> ivanm: the problem is that cabal install builds different versions of packages: normal, shared and profiling
16:23:02 <ivanm> KSkrzet: right
16:23:11 <DigitalKiwi> 37
16:23:14 <DigitalKiwi> hurr
16:23:15 <DigitalKiwi> sorry
16:23:17 <KSkrzet> ivanm: I want to force shared for executable
16:23:17 <ivanm> heh
16:23:25 <sshc> kmc_: for example, could I write an optimised version of fromJust when the value passed is (Maybe Int32)?
16:23:27 <sproingie> most functions are implemented for a specific type.  if you mean a different function, you have to use a typeclass.
16:23:28 <ivanm> KSkrzet: you set it in the cabal file AFAIK...
16:23:33 <ivanm> KSkrzet: though why do you want to?
16:23:33 <kmc_> oh
16:23:37 <sproingie> sshc: oh for that you can use the SPECIALIZE pragma
16:23:40 <ivanm> sshc: yes
16:23:45 <ivanm> as sproingie said
16:23:53 <ivanm> they already do this in Data.List, etc.
16:24:01 <sshc> ok
16:24:02 <KSkrzet> ivanm: you mean this post: http://mostlycode.wordpress.com/2010/01/03/shared-haskell-so-library-with-ghc-6-10-4-and-cabal/
16:24:03 <KSkrzet> ivanm: ?
16:24:16 <sshc> is this standard '98 Haskell?
16:24:19 <sproingie> nope
16:24:22 <MissPiggy> great!
16:24:24 <ivanm> no...
16:24:28 <sproingie> none of the pragmas are
16:24:35 <ivanm> yay, netsplit :s
16:24:52 <sproingie> sshc: it's also just a hint, you're not guaranteed to get it
16:25:03 <sproingie> in ghci you almost certainly won't
16:25:36 <sshc> is there a way to fail if I don't get it?
16:25:45 <sproingie> good question
16:26:45 <sproingie> it might emit a warning, for which you can use -Werror
16:26:47 <kmc_> MissPiggy: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16552#a16552
16:27:19 <sshc> I'm actually modifying the behaviour of a special type of "data Foo = Foo a", not optimizing it
16:27:26 <kmc_> that's definitely not allowed
16:27:28 <kmc_> with SPECIALIZE
16:27:32 <KSkrzet> ivanm: because i want it to be smaller. specifying -shared in ghc-options for executable doesn't really work :(
16:27:37 <sshc> kmc_: so I can't do that?
16:27:41 <ivanm> KSkrzet: see http://hackage.haskell.org/trac/hackage/ticket/600
16:27:44 <sproingie> there's SPECIALIZE instance
16:27:45 <ivanm> looks like it doesn't yet...
16:27:54 <kmc_> sshc: you will break everything
16:28:05 <ivanm> KSkrzet: so you can do so by hand, but not via cabal AFAICT
16:28:12 <sshc> is there a way I can require SPECIALIZE to be recognized if I'm using cabal?
16:28:17 <sshc> cabal can enforce extenstions
16:28:32 <sshc> kmc_: what do you mean?
16:28:38 <benmachine> sshc: if you want per-type behaviour, you'll need to use a type class
16:28:52 <MissPiggy> thanks a lot everyone!
16:28:54 <kmc_> you're using parametric polymorphism exactly counter to its definition
16:29:03 <kmc_> which may result in the compiler making incorrect optimizations
16:29:06 <sproingie> cabal can enforce LANGUAGE extensions anyway.  not sure how to make it recognize other pragmas
16:29:36 <kmc_> when you write your own specializations for GHC, you take on the proof burden of ensuring that they do the same thing (hopefully, faster)
16:29:50 <sshc> benmachine: what should I name a type class that covers Vectors, Lines, Planes, Polygons, and Polyhedrals?
16:30:10 <KSkrzet> ivanm: ah, thanks for the link
16:30:17 <kmc_> there are other ways to get polymorphic functions that care about the concrete input type (aka "ad-hoc polymorphism")
16:30:31 <sproingie> sshc: tensor?
16:30:45 * sproingie notes there's already a tensor package on hackage, tho it's pretty trivial
16:30:47 <ivanm> KSkrzet: no worries
16:30:54 <KSkrzet> ivanm: unfortunately the workaround there (pass -dynamic) doesn't really work since i use TH and -dunamic is non-standard build
16:31:09 <idnar> Polytope?
16:31:11 <sshc> sproingie: that's a good name
16:31:14 <kmc_> sshc: quite often, if you want different behavior for two different types, what you really want to do is pass in a variant type which has two constructors
16:31:21 <kmc_> and pattern match on the two
16:31:25 <KSkrzet> ivanm: anyway i'm going to check what's really the difference between -shared and -dynamic
16:31:29 <idnar> polyhedra aren't tensors, are they?
16:31:48 <sproingie> well tensors are mostly about vectors.  i think the OpenGL bindings might even use it for points tho
16:32:29 <sshc> could the term be used to describe rectangles or cubes?
16:32:45 <sproingie> KSkrzet: -shared compiles a shared library, -dynamic means to compile an executable that uses shared libraries
16:32:48 <MissPiggy> constraint Ring r = (Abelian (Sum r), Monoid (Product r), Distributive r)
16:32:48 <MissPiggy> nice
16:32:54 <MissPiggy> constraint Field r = (CommutativeRing r, Inverse (Product r))
16:32:57 <MissPiggy> this is pretty cool?
16:33:10 <MissPiggy> although, what's the point
16:33:25 <idnar> polytopes are n-dimensional polygons; so that includes polygons, polyhedra, polychorons, and so on for higher dimensions
16:33:33 <KSkrzet> sproingie: but you can't make both executables and libraries in one run right? if so one flag should suffice for both
16:33:42 <idnar> vectors are sort of the odd man out, but I think you can cheat them in
16:35:05 <sproingie> KSkrzet: blame C
16:35:23 <Twey> MissPiggy: Well, it allows you to write Field r => r instead of (Abelian (Sum r), Monoid (Product r), Distributive r, Commutative r, Inverse (Product r)) => r
16:35:29 <Twey> Quite a big advantage, I think…
16:35:31 <sproingie> KSkrzet: those flags just turn on a raft of other flags without having to be sensitive to what the output is
16:35:34 <MissPiggy> just search an replace
16:35:44 <sproingie> well at least in gcc they do
16:36:00 <Twey> MissPiggy: And then we have Java.  :þ
16:36:11 * MissPiggy doesn't program like that in java
16:37:48 <sshc> idnar: would tensor be a better term for points, vectors, lines, rectangles, polygons, polyhedrals, etc.?
16:38:18 <sproingie> naw forget i mentioned tensor.  it works for points and vectors and maybe lines, but n-gons forget it
16:40:41 <MissPiggy> jmcarthur want to talk about it?
16:40:58 <sshc> how would I define instances of and use specialCase after I do "class Foo a where specialCase :: Bool"?
16:41:19 <sshc> or is it not possible to define single-value non-functions in type classes?
16:42:02 <MissPiggy> sshc since it doesn't depend on 'a' there is a trouble
16:42:20 <MissPiggy> for example if I write specialCase somewhere, which instance of Foo is meant
16:42:21 <MissPiggy> ?
16:42:28 <sjanssen> so GHC 6.14 may have a concurrent GC?  Neat
16:44:09 <ivanm> preflex: seen bos
16:44:09 -preflex(n=preflex@95-88-118-220-dynip.superkabel.de)- bos was last seen on #haskell 1 day, 3 hours, 3 minutes and 44 seconds ago, saying: copumpkin: i renewed it, but it might take a little while for the DNS update to propagate
16:44:51 <ivanm> @ask bos if I wanted to use the Text library with it always using utf8, would I have to manually do the I/O and conversions to/from Bytestring?
16:44:51 <lambdabot> Consider it noted.
16:55:37 <interferon> what is the operator that forces strict evaluation?
16:55:54 <nettok> seq?
16:56:09 <damd> @src seq
16:56:09 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
16:56:13 <damd> :(
16:56:32 <interferon> isn't it an exclamation point or some variant on  that?
16:57:26 <nettok> i don't know, i am a haskell noob
16:57:36 <damd> $! comes to mind
16:57:39 <dobblego> interferon, seq
16:57:45 <damd> but i don't know if that's a real operator
16:57:49 <dobblego> interferon, ($!) is implemented in terms of seq
16:57:52 <interferon> ahh
16:57:59 <dobblego> @src ($!)
16:57:59 <lambdabot> f $! x = x `seq` f x
16:58:06 <interferon> also, how do i handle the possibility that read will fail to parse?
16:58:07 <dobblego> @type seq
16:58:08 <lambdabot> forall a t. a -> t -> t
16:58:15 <dobblego> > seq undefined 7
16:58:16 <lambdabot>   * Exception: Prelude.undefined
16:58:21 <dobblego> > flip const undefined 7
16:58:22 <lambdabot>   7
16:58:30 <dobblego> @type reads
16:58:31 <lambdabot> forall a. (Read a) => String -> [(a, String)]
16:58:32 <blackh> interferon: Well, ... seq doesn't _quite_ force strict evaluation.
16:58:34 <pikhq> dobblego: seq is strict.
16:58:35 <interferon> i'd like "read "f" :: Double" to return a maybe instead of failing with a parse error
16:58:35 <dobblego> using reads
16:58:40 <dobblego> pikhq, right
17:00:04 <blackh> interferon: You need to use reads, but the interface is a bit fugly.  See http://www.syntaxpolice.org/index.php/?q=node/419  <-- look at maybeRead defined on that page
17:00:05 <nettok> should i upgrade to GHC 6.12.1 if i am learning haskell?
17:00:15 <blackh> nettok: Not yet. ghc 6.10 is still bestr.
17:02:55 <MissPiggy> thhe problem is that if I use + and * for Ring.... then I can't use that for Field
17:03:52 <theorbtwo> Do you have fields that are also rings?
17:04:15 * theorbtwo isn't much of a mathematician.
17:04:22 <MissPiggy> let me think about this
17:04:27 <MissPiggy> I will try and answer
17:06:03 <MissPiggy> I don't know about that
17:08:28 <Cale> theorbtwo: All fields are rings.
17:08:41 <theorbtwo> Oh.
17:09:03 <MissPiggy> in terms of haskell typeclasses that doesn't mean I should do something in particular
17:11:26 <MissPiggy> so annoying I thought I had solved it! :)
17:12:57 <aavogt> but the field + * are not the same operations as the Ring  + *, MissPiggy?
17:12:59 <MissPiggy> maybe I will try with Chameleon
17:13:10 <MissPiggy> aavogt, I have no idea
17:13:12 <theorbtwo> MissPiggy: Sounds like you're OK; a Field has the (-) and (/) operators, and is also a Ring.  A Ring has the (*) and (+) operators.
17:13:21 <MissPiggy> all this stuff with typeclasses is just not working
17:13:52 <MissPiggy> I have a feeling that with Chameleon I will have more success
17:13:53 <Twey> readMaybe = fmap fst . listToMaybe . reads
17:14:28 <MissPiggy> Twey you know how constraint is implemetnd?
17:14:31 <aavogt> > read "123abc" :: Int
17:14:32 <lambdabot>   * Exception: Prelude.read: no parse
17:15:02 <theorbtwo> What's Chameleon?
17:15:18 <MissPiggy> theorbtwo, it changes typeclasses into a different language
17:15:25 <MissPiggy> so that maybe I can express this better
17:15:32 <MissPiggy> here is the website http://taichi.ddns.comp.nus.edu.sg/taichiwiki/ChameleonHomePage
17:15:52 <Twey> MissPiggy: Nope.  I was replying to blackh/interferon.  The ‘maybeRead’ described in that article is rather clumsy.
17:16:05 <MissPiggy> Twey, it is a search and replace preprocessor
17:16:31 <Twey> Ah, right, okay
17:16:35 <Twey> … and?
17:16:52 <Twey> Hm
17:16:54 <Twey> I'm sure it isn't
17:17:04 <Twey> It can only work on constraints
17:17:21 <Twey> If it were a textual search/replace, all sorts of crazy things would happen.
17:19:12 <aavogt> even without that, you can still do crazy things...
17:19:23 <MissPiggy> what does package lang mean?
17:20:43 <Twey> aavogt: Crazy things like putStrLn "Ring r" outputting "(Abelian (Sum r), Monoid (Product r), Distributive r)" :þ
17:21:10 <Twey> MissPiggy: http://www.haskell.org/pipermail/haskell-cafe/2006-December/020576.html
17:21:43 <MissPiggy> but I tried just removing it and I get compile errors because of this http://www.haskell.org/ghc/docs/4.06/hslibs/sec-ioexts.html
17:21:52 <MissPiggy> that says it is in The lang category
17:22:00 <MissPiggy> so maybe I do need it?
17:23:12 <Twey> Those docs are for GHC 4.06…
17:23:37 <Twey> All these things are in other modules, now
17:23:43 <Twey> @index writeIORef
17:23:43 <lambdabot> Data.IORef
17:23:48 <Twey> @index fixIO
17:23:48 <lambdabot> System.IO
17:23:56 <Twey> @index unsafeInterleaveIO
17:23:56 <lambdabot> System.IO.Unsafe
17:24:03 <aavogt> you could still be using ghc-4.06 though...
17:24:20 <ivanm> heh
17:24:48 <MissPiggy> everything you want to use is like a week old, so GHC has deprecated whatever libs it uses 10 times already
17:25:01 <KSkrzet> slightly offtopic: does anyone know how to see what symbols are defined in .so shared linux library?
17:25:05 <MissPiggy> I am fixing syntax errors on this thing now
17:25:14 <kmc_> KSkrzet: objdump
17:25:30 <kmc_> super useful tool
17:26:06 <KSkrzet> kmc_: thanks, i'll check it out
17:27:11 <Twey> MissPiggy: Err, that's at least six years old
17:27:24 <aavogt> closer to 10?
17:27:31 <Twey> Could well be
17:27:32 <MissPiggy> yeah well it doesn't work
17:27:38 <Twey> What a surprise!
17:27:46 <Twey> I am aghast and dismayed!
17:27:52 <Twey> We must keel-haul SPJ at once!
17:27:57 <MissPiggy> ok
17:27:59 <ivanm> why?
17:28:14 <aavogt> because there's no ghc-LTS
17:28:14 <Twey> ivanm: Because code written ten years ago no longer works on a modern compiler
17:28:35 <ivanm> oh noes!
17:28:44 <Twey> I know!  Think of the children!
17:28:48 <ivanm> Twey: you mean people actually wrote code 10 years ago? :o
17:28:49 <ivanm> ;-)
17:28:54 <Twey> Yes
17:28:56 <Twey> On slates
17:29:00 <ivanm> heh
17:29:07 <Twey> Using burnt sticks
17:29:13 <MissPiggy> yeah I have different ideas about programming than you
17:29:13 <ivanm> nowadays, large-scale backwards incompatability would be a problem due to hackage, etc.
17:29:26 <Twey> MissPiggy: Clearly.  ;)
17:29:31 <ivanm> MissPiggy: how do you know? ... >_>
17:29:33 <ivanm> <_<
17:29:35 <Twey> Whole programming languages have risen and died in that time-span.
17:29:53 <benmachine> which ones
17:30:09 <ivanm> well, it's difficult to say if a language has died or not
17:30:11 <Twey> Good question
17:30:13 <benmachine> heh
17:30:23 <Twey> I'm sure that many have, though
17:30:30 <ivanm> because unless its a joke language, then there's probably someone still using it for some app that they can't/don't want to re-write
17:30:34 <Twey> Some maybe even sticking around long enough to be significant
17:30:45 <Twey> ivanm: Even if it's a joke language
17:30:49 <ivanm> and even for joke languages, some people still try using them "for teh lulz"
17:30:51 <Twey> C++ is still used in many places ;)
17:30:54 <ivanm> heh
17:30:56 <benmachine> heheheh
17:30:58 <kmc_> haha
17:31:04 <ivanm> Twey: you've read the fake interview by strousup about C++?
17:31:09 <Twey> Yeah :þ
17:32:18 <ivanm> it made sense to me...
17:32:19 <ivanm> ;-)
17:32:40 <Twey> It does.  It wasn't 'til I got to the end that I was convinced it wasn't real.  :þ
17:32:56 <ivanm> heh
17:33:15 <pastorn> ivanm: linky?
17:33:30 <Twey> http://www-users.cs.york.ac.uk/susan/joke/cpp.htm
17:33:42 <pastorn> Twey: thanky
17:33:47 <ivanm> yeah, that's the one
17:34:39 <DigitalKiwi> i saw it here http://harmful.cat-v.org/software/c++/I_did_it_for_you_all this site is hilarious
17:34:51 <ivanm> Twey: but what's this fandangled "tape" thingy they talk about at the end?
17:34:52 <ivanm> :p
17:36:10 <DigitalKiwi> the "Linus" one is lulzy, and is actually real (I looked up the mailing list >.>)
17:37:40 <McManiaC> how does Text.Printf work? I dont see from the sourcecode why you can pass any number of arguments to it
17:37:51 <ivanm> McManiaC: using magic!
17:38:04 <ivanm> there was a blog post linked from haskell reddit recently about it that explained it rather well
17:38:39 <Twey> ivanm: Hehe.
17:38:41 <ivanm> basically, it uses a type class, and printf has a type something like :: (PrintType t, PrintClass c) => String -> t -> c
17:38:47 <ivanm> and (t -> c) is an instance of PrintClass
17:39:06 <Twey> PrintfType r => String -> r
17:39:38 <ivanm> that's the one
17:39:50 <Twey> Where r includes PrintfType r => Int -> r, PrintfType r => String -> r, String, and IO ()
17:40:25 <McManiaC> so thats some kinda of recursive function-data type?
17:40:28 <ivanm> and all other printf types -> r
17:40:32 <ivanm> McManiaC: something like that
17:40:36 <Twey> McManiaC: Yeah, basically
17:40:40 <McManiaC> kaaay
17:40:41 <ivanm> it means, however, that you can't really type it tha well
17:40:46 <ivanm> and you get a lot of runtime errors...
17:40:59 <Twey> There's a TH version on Hackage that does proper type-checking at compile-time.
17:41:03 <ivanm> :o
17:41:09 <ivanm> but TH itself is semi evil...
17:41:15 <McManiaC> TH?
17:41:18 <Twey> Sure, but at least it type-checks.
17:41:20 <ivanm> Template Haskell
17:41:22 <ivanm> Twey: true
17:41:27 <ivanm> McManiaC: meta-level programming for Haskell
17:41:30 <McManiaC> ah yeh
17:41:35 * ivanm wonders what xformat is like
17:41:38 <McManiaC> read about it, never really got into it
17:41:39 * Twey sleep now
17:42:05 <pastorn> Twey: GOOD NIGHT!
17:42:29 <ivanm> well, xformat dosn't actually say how to use it AFAICT...
17:42:33 <ivanm> g'night Twey
17:46:23 <pretsas> I've just read "All About Monads" and I'm doing the exercises. Is maybe a member of MonadPlus by default? Or do I have to import the MonadPlus stuff or something?
17:47:09 <McManiaC> not by default, no
17:47:21 <McManiaC> only Monad and Functor
17:47:33 <McManiaC> ghci → :i Maybe will tell you the instances
17:47:56 <aavogt> seems to me that class MonadPlus, and instance MonadPlus Maybe are both in Control.Monad
17:48:05 <pretsas> Thanks
17:48:06 <pastorn> McManiaC: how'd you do that?
17:48:15 <Cale> So the instance of Maybe is available whenever MonadPlus is.
17:48:16 <pastorn> i wanna do UTF arrows in IRC as well!!
17:48:23 <Cale> instance for*
17:50:35 <kmc_> > id :: () → ()
17:50:36 <lambdabot>   {()->()}
17:51:23 <McManiaC> pastorn: on the german nodead keys layout it's altgr+zuiU
17:51:58 <pastorn> ŋª
17:52:01 <pastorn> hehe
17:54:41 <MissPiggy> > not
17:54:42 <lambdabot>   {True->False;False->True}
17:55:12 <MissPiggy> > \(f :: Bool -> Bool -> Bool) -> f . f . f
17:55:13 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
17:55:14 <lambdabot>         against inferred type ...
17:55:21 <MissPiggy> > \(f :: Bool -> Booll) -> f . f . f
17:55:23 <lambdabot>   Not in scope: type constructor or class `Booll'
17:55:35 <ivanm> @instances MonadPlus
17:55:36 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
17:55:50 <ivanm> McManiaC: looks like Maybe _is_ an instance of MonadPlus...
17:56:08 <McManiaC> not in prelude
17:56:14 <ivanm> no
17:56:14 <McManiaC> O.o
17:56:19 <ivanm> but Maybe isn't defined in the Prelude
17:56:28 <ivanm> it's defined in Data.Maybe and re-exported in the Prelude
17:56:38 <ivanm> realistically, the Prelude is only useful for hacking in ghci
17:56:52 <ivanm> for proper coding, I'd almost prefer for the Prelude not to exist
17:56:54 <McManiaC> http://npaste.de/EF/
17:56:57 <McManiaC> thats all I get…
17:57:00 <kmc_> it's easy enough to not import it
17:57:00 <ivanm> well, maybe just contain Show and Read ...
17:57:16 <ivanm> kmc_: well, you have to use either an extension or import Prelude()
17:57:24 <kmc_> or import qualified Prelude as P
17:57:25 <Cale> ivanm: Really? I hate having to import Data.List and Control.Monad in every program I ever write.
17:57:25 <ivanm> McManiaC: right
17:57:39 <ivanm> McManiaC: the instance is defined with MonadPlus IIRC
17:57:44 <McManiaC> yup
17:57:50 <McManiaC> I didnt say there is none
17:58:06 <McManiaC> but he asked whether he has to import something first, and he obviously has to :)
17:58:06 <ivanm> Cale: well, it doesn't make sense to have foldl defined in the Prelude but having to import Data.List for foldl' for example
17:58:16 <ivanm> ahhh, right
17:58:21 <ivanm> McManiaC: ^^
17:58:23 <McManiaC> ^^
17:58:26 <ivanm> missed that bit
18:05:17 <mm_freak> @hoogle Either e a -> Maybe a
18:05:17 <lambdabot> Data.Typeable typeOf2 :: Typeable2 t => t a b -> TypeRep
18:05:18 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
18:05:18 <lambdabot> Data.Either either :: (a -> c) -> (b -> c) -> Either a b -> c
18:05:45 <mm_freak> @djinn Either e a -> Maybe a
18:05:45 <lambdabot> f a =
18:05:46 <lambdabot>     case a of
18:05:46 <lambdabot>     Left _ -> Nothing
18:05:46 <lambdabot>     Right b -> Just b
18:06:14 <mm_freak> wow, i didn't expect djinn to come up with that
18:06:31 <tolkad> @djinn Either e a -> Maybe a -> Or b, if I feel like it
18:06:32 <lambdabot> Cannot parse command
18:06:41 <tolkad> 0_o what did I do wrong?
18:07:35 <pastorn> ivanm: "Not really. Everyone has a choice. I didn't expect the thing to get so much out of hand. Anyway, I basically succeeded. C++ is dying off now, but programmers still get high salaries - especially those poor devils who have to maintain all this crap. You do realise, it's impossible to maintain a large C++ software module if you didn't actually write it?"
18:07:49 <pastorn> XD
18:08:26 <Adamant> not strictly true, it's like Perl. you have to find a subset of the language and enforce it viciously
18:08:40 <Adamant> then you can at least do it within organizations.
18:08:45 <MissPiggy> subset of correct programs
18:09:12 <Adamant> lol, you're usually not that lucky :P
18:09:39 <tolkad> @djinn Either e a -> Maybe a -> Maybe e
18:09:39 <lambdabot> f a b =
18:09:39 <lambdabot>     case a of
18:09:39 <lambdabot>     Left c -> case b of
18:09:39 <lambdabot>               Nothing -> Nothing
18:09:39 <lambdabot>               Just _ -> Just c
18:09:41 <lambdabot>     Right _ -> Nothing
18:09:46 <tolkad> 0_o
18:09:50 <tolkad> @djinn Either e a -> Maybe a -> Maybe e -> Maybe a
18:09:51 <lambdabot> f a b c =
18:09:51 <lambdabot>     case a of
18:09:51 <lambdabot>     Left _ -> Nothing
18:09:51 <lambdabot>     Right d -> case b of
18:09:51 <lambdabot>                Nothing -> Nothing
18:09:53 <lambdabot>                Just e -> case c of
18:09:55 <lambdabot>                          Nothing -> Just e
18:09:57 <lambdabot>                          Just _ -> Just d
18:10:05 <medfly> oh, we can make lambdabot flood this channel!
18:10:07 <DigitalKiwi> spam, mm so tastey
18:10:08 <mm_freak> does anyone know something like a ByteString-builder?
18:10:14 <tolkad> @djinn Either e a -> Maybe a -> Maybe e -> Maybe a -> Maybe a -> Maybe e -> Maybe a -> Maybe a -> Maybe e -> Maybe a -> Maybe a -> Maybe e -> Maybe a
18:10:18 <mm_freak> those cons, snocs and appends tend to get ugly
18:10:47 <mm_freak> ah, wait…  i can use Writer, i guess
18:10:47 <medfly> o.O?
18:10:49 <lambdabot> No output from Djinn; installed?
18:10:53 <pastorn> mm_freak: isn't there pack/unpack?
18:10:56 <medfly> @djinn Either e a -> Maybe a -> Maybe e -> Maybe a -> Maybe a -> Maybe e -> Maybe a -> Maybe a
18:10:57 <lambdabot> f a b c d e f g =
18:10:57 <lambdabot>     case a of
18:10:57 <lambdabot>     Left _ -> g
18:10:57 <lambdabot>     Right _ -> case b of
18:10:57 <lambdabot>                Nothing -> g
18:10:59 <lambdabot>                Just _ -> case c of
18:11:00 <pastorn> or what are you talking about?
18:11:01 <lambdabot>                          Nothing -> g
18:11:03 <lambdabot>                          Just _ -> case d of
18:11:05 <tolkad> @djinn Either e a -> Maybe a -> Maybe e -> Maybe a -> Maybe a -> Maybe e -> Maybe a -> Maybe a
18:11:05 <lambdabot>                                    Nothing -> g
18:11:07 <lambdabot>                                    Just _ -> case e of
18:11:09 <lambdabot>                                              Nothing -> g
18:11:11 <lambdabot>                                              Just h -> case f of
18:11:13 <lambdabot> Plugin `djinn' failed with: thread killed
18:11:15 <lambdabot> f a b c d e f g =
18:11:17 <lambdabot>     case a of
18:11:19 <lambdabot>     Left _ -> g
18:11:19 <mm_freak> pastorn: i'm not talking about String <-> ByteString conversion
18:11:20 <pastorn> medfly: stop this
18:11:21 <lambdabot> Plugin `djinn' failed with: thread killed
18:11:32 <mm_freak> pastorn: say i have a nickname, username and hostname
18:11:38 <mm_freak> and i want to construct nick!user@host
18:11:42 <mm_freak> as a single string
18:11:50 <tolkad> @djinn Either a b c d e f g
18:11:51 <lambdabot> Error: kind error: (KArrow (KVar 2) (KVar 9),KVar 8)
18:11:56 <tolkad> @djinn Either a b c d e f g -> Maybe a
18:11:57 <lambdabot> Error: kind error: (KArrow (KVar 2) (KVar 9),KVar 8)
18:11:59 <mm_freak> currently i'm using a combination of cons, snoc and append
18:12:03 <tolkad> @djinn Either a b-> Maybe a
18:12:04 <lambdabot> f a =
18:12:04 <lambdabot>     case a of
18:12:04 <lambdabot>     Left b -> Just b
18:12:04 <lambdabot>     Right _ -> Nothing
18:12:04 <pastorn> mm_freak: nick ++ "!" ++ host
18:12:06 <pastorn> ?
18:12:09 <mm_freak> which is ugly and probably also slow
18:12:13 <pastorn> oh
18:12:15 <mm_freak> :t (++)
18:12:19 <lambdabot> forall m. (Monoid m) => m -> m -> m
18:12:28 <mm_freak> hmm
18:12:28 <tolkad> @djinn Either a b->Maybe a->Maybe b->Maybe a->Maybe b->Maybe a->Maybe b
18:12:28 <lambdabot> f a b c d e f =
18:12:29 <lambdabot>     case a of
18:12:29 <lambdabot>     Left _ -> Nothing
18:12:29 <lambdabot>     Right g -> case b of
18:12:29 <lambdabot>                Nothing -> Nothing
18:12:30 <medfly> :t Prelude.(++)
18:12:30 <lambdabot>                Just _ -> case c of
18:12:32 <lambdabot>                          Nothing -> Nothing
18:12:34 <lambdabot> Not in scope: data constructor `Prelude'
18:12:36 <lambdabot>                          Just h -> case d of
18:12:38 <lambdabot>                                    Nothing -> Nothing
18:12:39 <medfly> :t Prelude.++
18:12:40 <lambdabot>                                    Just _ -> case e of
18:12:43 <lambdabot> parse error on input `Prelude.++'
18:12:43 <mm_freak> in ghci it's [a] -> [a] -> [a]
18:12:44 <lambdabot> Plugin `djinn' failed with: thread killed
18:12:45 <pastorn> mm_freak: (++) :: [a] -> [a] -> [a]
18:12:48 <medfly> :t (Prelude.++)
18:12:49 <lambdabot> forall a. [a] -> [a] -> [a]
18:12:50 <pastorn> medfly: STOP!!!
18:12:54 <aavogt> mm_freak: how can you do it any faster than that? (++) is right associative anyways
18:12:56 <medfly> pastorn: WHAT!
18:13:03 <pastorn> with the djinyness
18:13:07 <medfly> it's not me!
18:13:16 <pastorn> tolkad: ass
18:13:17 <mm_freak> aavogt: i guess it's going to look nicer using a Writer
18:13:33 <tolkad> pastorn: I'm trying to figure out what djinn is
18:13:36 <medfly> I totally support abusing defenseless bots
18:13:36 <pikhq> @djin a->b
18:13:37 <lambdabot> Maybe you meant: djinn djinn-add djinn-clr djinn-del djinn-env djinn-names djinn-ver
18:13:41 <aavogt> it's still going to do the same operations, unless you use a different monoid
18:13:42 <pikhq> @djinn a->b
18:13:43 <lambdabot> -- f cannot be realized.
18:13:47 <mm_freak> > runWriter (tell "blah" *> tell "blubb" *> tell "blor!") ""
18:13:47 <pastorn> > "hello " ++ "there " ++ "you " ++ "nice " ++ "person!"
18:13:50 <lambdabot>   Couldn't match expected type `[GHC.Types.Char] -> t'
18:13:50 <lambdabot>         against inferr...
18:13:51 <lambdabot>   "hello there you nice person!"
18:14:08 <aavogt> actually it's going to be worse if you use  Writer String, since that ends up associating to the left
18:14:23 <aavogt> tolkad: you can /msg lambdabot @spammy
18:14:27 <pastorn> mm_freak: how the HELL do you use the writer monad and don't know about (++)?
18:14:38 <medfly> is unwords better?
18:14:44 <pastorn> this seem pretty insane to anyone else?7
18:14:47 <mm_freak> pastorn: i do know about (++), but it's restricted to lists in the prelude
18:14:51 <mm_freak> :t runWriter
18:14:52 <lambdabot> forall w a. Writer w a -> (a, w)
18:14:57 <mm_freak> > runWriter (tell "blah" *> tell "blubb" *> tell "blor!")
18:14:57 <pikhq> pastorn: Yes.
18:14:58 <lambdabot>   No instance for (Control.Applicative.Applicative
18:14:58 <lambdabot>                     (Contr...
18:15:00 <pastorn> mm_freak: `mplus`
18:15:09 <pastorn> @type mplus
18:15:09 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
18:15:14 <mm_freak> pastorn: then i could just as well use `append` =)
18:15:17 <tolkad> @type int
18:15:18 <lambdabot> Int -> Doc
18:15:21 <mm_freak> i just want to write it nicer
18:15:25 <tolkad> @type Doc
18:15:26 <lambdabot> Not in scope: data constructor `Doc'
18:15:27 <medfly> @hoogle.type (++)
18:15:27 <lambdabot> Unknown command, try @list
18:15:28 <mm_freak> less operators, more sequencing-like
18:15:31 <mm_freak> so i'll use Writer
18:15:39 <pikhq> mm_freak: (++) is on the monoids in Caleskell, you know.
18:15:40 <pastorn> tolkad: start a query with lambdabot
18:15:43 <pastorn> this is getting out of hand
18:15:51 <mm_freak> > runWriter (tell "blah" >> tell "blubb" >> tell "blor!")
18:15:52 <lambdabot>   ((),"blahblubbblor!")
18:15:58 <medfly> pastorn: I think he is trying to flood this channel.
18:15:58 <pastorn> tolkad: /query lambdabot shit
18:16:02 <mm_freak> why the hell is Writer non-Applicative?!
18:16:16 <pastorn> quicksilver: kick tolkad o
18:16:22 <tolkad> medfly: no I'm not. Those were one line responses
18:16:26 <pastorn> quicksilver: for a while? he needs it
18:16:30 <pastorn> tolkad: nevertheless
18:16:33 <pastorn> tolkad: query
18:16:34 <tolkad> medfly: If I was trying to flood I would keep using djinn
18:17:07 <mm_freak> tolkad: you know, djinn is powered by a dedicated nuclear power plant
18:17:13 <mm_freak> you're wasting a lot of power!
18:17:14 <pikhq> mm_freak: Because there's not an easy way to make all monads applicatives.
18:17:33 <pastorn> tolkad: now half my screen is shit filled with shit you've caused and the other half is me bitching to you about it... get the hint?
18:17:33 <aavogt> > execWriter (tell [x] >> tell [y] >> tell [z]) :: Expr
18:17:34 <lambdabot>   Couldn't match expected type `[SimpleReflect.Expr]'
18:17:34 <lambdabot>         against inferre...
18:17:37 <mm_freak> pikhq: what's difficult about it?  monadLib's monads are all Applicatives
18:17:57 <pikhq> mm_freak: Make *all of them* applicatives. In Control.Applicative. :P
18:18:09 <pikhq> Obviously, it's fairly easy to make any arbitrary one an applicative.
18:18:22 <pikhq> (let pure = return; <*> = ap)
18:18:46 <mm_freak> pikhq: well, that's largely due to the unfortunate design decisions in the base
18:19:09 <mm_freak> Monad should depend on Applicative, but we've had that a number of times =)
18:19:16 <tolkad> mm_freak: If you had read foundation novels by Isaac Asimov you would know that nuclear power plants are not that big of a deal
18:19:48 <pikhq> mm_freak: Yes, yes...
18:20:09 <medfly> my screen idn't filled by a lot of lambdabot
18:20:47 <aavogt> , time (execWriter $ replicateM_ 10000 (tell "hi"))
18:20:48 <lunabot>  luna: Not in scope: `execWriter'
18:20:49 <mm_freak> but to be honest, i only recently discovered the virtues of Control.Applicative
18:20:52 <DigitalKiwi> pastorn: how big is your screeen? D:
18:21:16 <DigitalKiwi> I have to hit page up twice to see any of his spam
18:21:21 <aavogt> , time (Control.Monad.Writer.execWriter $ replicateM_ 10000 (tell "hi"))
18:21:22 <lunabot>  luna: Not in scope: `Control.Monad.Writer.execWriter'
18:21:41 <aavogt> , time (runWriter $ replicateM_ 10000 (tell "hi"))
18:21:42 <lunabot>  luna: Not in scope: `tell'
18:22:14 <medfly> :]
18:22:28 <aavogt> @msg mmorrow can lunabot import Control.Monad.Writer please?
18:22:28 <lambdabot> Not enough privileges
18:22:35 <aavogt> @ask mmorrow can lunabot import Control.Monad.Writer please?
18:22:35 <lambdabot> Consider it noted.
18:23:10 <Cale> aavogt: lambdabot has Control.Monad.Writer
18:23:21 <aavogt> , time (foldl (++) [] $ replicate 1000 "hi")
18:23:25 <lunabot>  (1.0e-3,"hihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihi...
18:23:36 <aavogt> , time (foldr (++) [] $ replicate 1000 "hi")
18:23:38 <lunabot>  (0.0,"hihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihih...
18:23:48 <aavogt> , time (foldr (++) [] $ replicate 100000 "hi")
18:23:50 <lunabot>  (0.0,"hihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihih...
18:23:57 <mm_freak> > runWriter $ replicateM_ 100 (tell "hi")
18:23:58 <lambdabot>   ((),"hihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihi...
18:24:02 <aavogt> , time (foldl (++) [] $ replicate 100000 "hi")
18:24:04 <Cale> , time (foldr (++) [] $ repeat "hi")
18:24:07 <lunabot>  (0.0,"hihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihih...
18:24:07 <lunabot>  Killed.
18:24:18 <Cale> hmm
18:24:21 <mm_freak> > runWriter . forever $ tell "hi"
18:24:24 <Cale> , time (foldr (++) [] $ repeat "hi")
18:24:26 <lambdabot>   mueval: ExitFailure 1
18:24:27 <lunabot>  (0.0,"hihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihih...
18:24:32 <aavogt> anyways, my point is that the foldl version is slower
18:24:43 <mm_freak> hmm, why doesn't that work?
18:24:47 <Cale> Of course it is :)
18:24:59 <mm_freak> > let c = c >> tell "hi" in runWriter c
18:25:03 <lambdabot>   mueval-core: Time limit exceeded
18:25:11 <mm_freak> > let c = tell "hi" >> c in runWriter c
18:25:14 <Cale> mm_freak: Needs a result :)
18:25:15 <lambdabot>   mueval-core: Time limit exceeded
18:25:18 <theorbtwo> :t runWriter
18:25:19 <KSkrzet> > fix id
18:25:20 <lambdabot> forall w a. Writer w a -> (a, w)
18:25:24 <lambdabot>   mueval-core: Time limit exceeded
18:25:25 <KSkrzet> > print $ fix id
18:25:27 <lambdabot>   <IO ()>
18:25:28 <aavogt> Cale: or, lambdabot could have a time function / command
18:25:36 <mm_freak> Cale: ah, indeed
18:25:39 <Cale> aavogt: Where does time come from?
18:25:39 <KSkrzet> > print $ (fix id :: Int)
18:25:41 <lambdabot>   <IO ()>
18:25:47 <mm_freak> > let c = c >> tell "hi" >> return () in runWriter c
18:25:49 <KSkrzet> > (fix id :: Int)
18:25:49 <aavogt> #ty time
18:25:51 <lambdabot>   mueval-core: Time limit exceeded
18:25:51 <lunabot>  forall a . a -> (Double, a)
18:25:53 <lambdabot>   mueval-core: Time limit exceeded
18:25:59 <mm_freak> Cale: but it never gets to evaluate it, i guess
18:26:30 <Cale> > execWriter (fix (tell "hi" >>))
18:26:31 <KSkrzet> @hoogle time
18:26:31 <lambdabot>   "hihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihi...
18:26:32 <lambdabot> package time
18:26:32 <lambdabot> module Data.Time
18:26:32 <lambdabot> module System.Time
18:26:39 <mm_freak> > let c = c >> modify (++ "hi") in execState c ""
18:26:41 <lambdabot>   "* Exception: stack overflow
18:26:51 <mm_freak> > let c = c >> modify ("hi" ++) in execState c ""
18:26:52 <lambdabot>   "hihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihi...
18:26:56 <mm_freak> ah, there you go
18:26:59 <aavogt> Cale: it's defined using unsafePerformIO
18:27:17 <Cale> aavogt: In what package?
18:27:53 <mm_freak> execWriter, of course…
18:27:55 <aavogt> > reify 'time
18:27:56 <lambdabot>   <no location info>:
18:27:56 <lambdabot>      lexical error in string/character literal at chara...
18:28:02 <aavogt> , reify 'time
18:28:04 <lunabot>  luna: No instance for (GHC.Show.Show
18:28:16 <mm_freak> > execWriter . forever $ tell "hi"
18:28:18 <lambdabot>   "hihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihi...
18:28:20 <xerox> #ty reify
18:28:23 <lunabot>  Name -> Q Info
18:28:40 <aavogt> #src 'time
18:28:41 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Quote.QuasiQuoter'
18:28:45 <aavogt> #src time
18:28:46 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Quote.QuasiQuoter'
18:29:29 <aavogt> Cale: I'm not aware of it being from any package
18:34:41 <aavogt> it is simple enough to define:   time f = unsafePerformIO $ do ini <- getCurrentTime; f `seq` return (); done <- getCurrentTime; return (diffUTCTime done ini,f) -- maybe this works... I dunno
18:34:58 <tomberek> hi
18:35:42 <Cale> Probably better form to use Control.Exception.evaluate
18:35:43 <pikhq> aavogt: Doesn't look like it needs to be unsafePerformIO'd, though.
18:36:01 <Cale> pikhq: It would need to be if it's to be usable from lambdabot
18:36:09 <pikhq> Cale: Mmm. True.
18:41:26 <aavogt> Cale: the definition as-is works fine
18:41:48 <aavogt> evaluate x = (return $! x) >>= return
18:42:42 <aavogt> evaluate x = do x `seq` return (); return x -- this is the same, due to laziness (as in sharing the results of whnf'ing x)
18:44:16 <aavogt> though maybe this does fail that first requirement of evaluate, which doesn't matter for us:
18:44:17 <aavogt> evaluate x `seq` y    ==>  y
18:44:25 <dolio> (return $! x) >>= return shouldn't really be a correct definition of evaluate.
18:44:50 <aavogt> please explain :)
18:44:51 <tomberek> Cale: What happened to the directed graph project?
18:46:04 <ivanm> tomberek: directed graph project?
18:46:40 <tomberek> ivanm: ah,, well, the graph project... i came across this,,, http://www.haskell.org/pipermail/haskell-cafe/2009-June/063402.html
18:46:55 <ivanm> yup, that's me all right
18:47:03 <tomberek> yeah, didn't know you were here
18:47:09 <ivanm> I've done a draft version based on something Cale and I hashed together
18:47:10 <dolio> Me explain?
18:47:15 <aavogt> yes dolio
18:47:18 <ivanm> I can send you a copy if you'd like
18:47:34 <ivanm> by the looks of things, however, the way we've done it means you'll need at least 6.12 :s
18:47:44 <dolio> The monad laws say that m >>= return = m, so (return $! x) >>= return = return $! x, which is supposed to explicitly not be the case for evaluate x.
18:47:52 <ivanm> (so it won't really be usable for a year or so yet)
18:47:52 <tomberek> ivanm: sure... i'm working on implementing a neural network... ie, a directed graph with computation
18:48:01 <tomberek> ivanm: dang
18:48:02 <ivanm> tomberek: atm, don't worry about this
18:48:24 <ivanm> it's definitely more of an idea than a realistic implementation atm
18:50:16 <tomberek> ivanm: so a homebrew solution is in order?  do you have any suggestions on how to structure a neural network, do the computations? update neuron states?  (I'm pretty new to haskell)  I'm just tossing around ideas here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16553#a16553
18:50:32 <ivanm> tomberek: there are at least 2 neural network libraries on hackage IIRC
18:50:36 <mm_freak> how do i format numbers without having to use printf?
18:50:42 <mm_freak> something more lightweight would be great
18:50:46 <EvanCarroll> Cale: sup sup
18:50:50 <ivanm> mm_freak: what kind of formatting?
18:50:54 <EvanCarroll> Cale: you're the RWH author right?
18:50:59 <Cale> no
18:51:00 <EvanCarroll> I found a pretty major error
18:51:02 <EvanCarroll> =(
18:51:03 <mm_freak> ivanm: make "012" out of (12 :: Integer)
18:51:08 <ivanm> EvanCarroll: it's dons, CosmicRay and bos
18:51:13 <Cale> dons, bos, and CosmicRay are
18:51:15 <Cale> yeah
18:51:25 <tomberek> ivanm: yeah, the hfann and hnn.... i'm workikng with Alp M. to remake hnn
18:51:26 <ivanm> mm_freak: hackily using ShowS ?
18:51:31 <ivanm> tomberek: *nod*
18:51:46 <mm_freak> uh
18:51:51 <ivanm> tomberek: I really haven't done much with neural networks to be able to tell how to implement them
18:51:58 <Cale> tomberek: Implementing graphs is easy enough though. I usually use some variation on Map Vertex (Set Vertex)
18:51:59 <ivanm> mm_freak: or else using a pretty printer maybe
18:52:04 <mm_freak> i'll use printf =)
18:52:21 <ivanm> (IIRC, most of them let you overwrite stuff so you can do 3 0s, then overwrite it with the 12)
18:52:26 <ivanm> mm_freak: probably easiest ;-)
18:52:34 <Cale> tomberek: You'll have weighted edges, so probably Map Vertex (Set (Weight, Vertex))
18:52:47 <tomberek> Cale: with my haskell knowledge, i'm acting more as an idea guy, than implementer.. hehe
18:53:23 <ivanm> and if Vertex = Int, then you can use IntMap
18:53:41 <tomberek> Cale: what package is that?
18:53:44 <ivanm> Cale: is IntMap and IntSet better than Map and Set because of unboxing, specialisation, etc. that's possible because the key/set type is known?
18:53:48 <ivanm> tomberek: containers
18:53:50 <ivanm> comes with GHC
18:53:54 <Cale> It would be nice to have a standard sort of interface for algorithms that work on various sorts of arbitrary graphs, but in the interim, what I usually do is to make the algorithm take functions as parameters for any operations on the graph that it'll need.
18:54:11 <Cale> (like, the implementation of 'neighbours' or getting an edge weight)
18:54:56 <tomberek> ok... I'll poke around.. thanks
18:55:01 <Cale> http://hackage.haskell.org/packages/archive/astar/0.2.1/doc/html/Data-Graph-AStar.html
18:55:04 <ni|> anyone familiar with inverse quadratic interpolation?
18:55:44 <Cale> ^^ here's an implementation of A* which I did for fun (no guarantees about suitability for a particular purpose -- I wrote it in 10 minutes or so from the Wikipedia page)
18:55:59 <Cale> It's a good example of that style of just taking lots of function parameters
18:56:02 <tomberek> wow.... yeah, i saw that earlier
18:56:05 <ivanm> Cale: so it's basically a specialised unfolding?
18:56:21 <Cale> ivanm: heh, in a funny way, I suppose it is
18:57:12 <Cale> I wish haddock didn't butcher the types.
18:57:20 <ivanm> yeah
18:57:25 <Cale> It seems to leave required parens out
18:57:34 <ivanm> I find it a PITA that you put brackets around a function type, and then haddock ignores them
18:57:46 <ivanm> yes, it puts the two on the one line to indicate a function, but it isn't as obvious
18:57:52 * ivanm hates idiots like this: http://www.reddit.com/r/programming/comments/au31u/how_factor_replaced_gnu_assembler_with_factor_code/c0jep2v
18:59:39 <aluink> context: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16554#a16554
18:59:48 <aluink> what's the type of x'squared?
19:00:08 <ivanm> Int
19:00:20 <ivanm> but that's a weird naming convention...
19:00:21 <_nickel> does anyone know of folks doing work/research on haskell in the US?
19:00:22 <aluink> it should be Int for add'cont to work, but square'cont returns Cont r Int
19:00:31 <aluink> ...that has to do with how do's work right?
19:00:37 <ivanm> _nickel: see research and industry links on haskell.org
19:00:45 <_nickel> ivanm: thanks very much sir!
19:00:49 <ivanm> aluink: right, but you "extract" the values using <-
19:00:58 <ivanm> yup, that's how do statements work
19:01:16 * ivanm can't quite tell if _nickel is being sarcastic or not...
19:01:25 <aluink> hmmm, how would it be written using >>='s?
19:01:34 <_nickel> ivanm: not at all
19:01:45 <_nickel> ivanm: I appreciate the quick and useful response
19:01:50 <ivanm> aluink: so the do notation is desugared into something like this:
19:02:04 <McManiaC>  fac n = if n <= 1 then 1 else n * fac (n-1)
19:02:08 <McManiaC> why is that strict?
19:02:08 <ivanm> do a <- ma; b a ---> ma >>= (\ a -> b a)
19:02:15 <McManiaC> because n gets compared to 1?
19:02:18 <ivanm> McManiaC: is it? looks lazy to me
19:02:30 <McManiaC> http://haskell.org/haskellwiki/Performance/Strictness says its strict
19:02:30 <aluink> whoa! let me brain catch up ;)
19:02:48 <ivanm> @google monad do blocks
19:02:50 <lambdabot> http://en.wikipedia.org/wiki/Monad_(functional_programming)
19:02:50 <lambdabot> Title: Monad (functional programming) - Wikipedia, the free encyclopedia
19:03:01 <aavogt> McManiaC: because <= and * are both strict functions (or at least for most instances of Num)
19:03:14 <aluink> oh...right, i wasn't getting your notation..yeah, i think i understood that
19:03:29 <ivanm> aluink: http://en.wikipedia.org/wiki/Monad_%28functional_programming%29#do-notation
19:03:38 <aluink> i guess what's throwing me off is how squared'cont takes one Int and add'cont takes two...and how that all works
19:03:50 <aavogt> > let fac n = if n <= 1 then 1 else n * fac (n-1) in fac 100 > (fac 2 :: Natural)
19:03:51 <lambdabot>   Not in scope: type constructor or class `Natural'
19:03:55 <aavogt> > let fac n = if n <= 1 then 1 else n * fac (n-1) in fac 100 > (fac 2 :: Nat)
19:03:56 <lambdabot>   No instance for (GHC.Num.Num L.Nat)
19:03:56 <lambdabot>    arising from a use of `fac' at <inte...
19:04:00 <manjunaths> hello
19:04:03 * ivanm points out the "making stricterness more relevant" paper from PEPM in case anyone actually cares about semantics, etc. of strictness in haskell
19:04:08 <McManiaC> aluink: thats some weird use of 's there btw
19:04:22 <ivanm> aluink: you can consider <- as removing the value from the monadic container
19:04:32 <McManiaC> ivanm: link?
19:04:36 <o-_-o> @hoogle (<$>)
19:04:36 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
19:04:45 * ivanm idly waves in o-_-o's general direction
19:05:18 <ivanm> McManiaC: http://people.cs.uu.nl/stefan/pubs/holdermans10making.html
19:06:36 <aluink> McManiaC: yeah, i got it from the Haskell book on wikibooks on the page on Continuation Passing Style
19:06:50 <aluink> ish...that was just bad english
19:07:27 * aluink is nautious
19:07:29 <McManiaC> ivanm: thx
19:07:56 <aavogt> @wn nautical
19:07:57 <lambdabot> *** "nautical" wn "WordNet (r) 2.0"
19:07:57 <lambdabot> nautical
19:07:57 <lambdabot>      adj : relating to or involving ships or shipping or navigation or
19:07:57 <lambdabot>            seamen; "nautical charts"; "maritime law"; "marine
19:07:57 <lambdabot>            insurance" [syn: {maritime}, {marine}]
19:08:16 <o-_-o> > :t runGet
19:08:18 <lambdabot>   <no location info>: parse error on input `:'
19:08:26 <o-_-o> @type runGet
19:08:27 <lambdabot> Not in scope: `runGet'
19:08:31 <ivanm> McManiaC: no worries
19:08:34 <o-_-o> @type Data.Binary.runGet
19:08:36 <lambdabot> Not in scope: `Data.Binary.runGet'
19:08:45 <ivanm> @hoogle runGet
19:08:46 <lambdabot> No results found
19:09:14 <ivanm> hayoo says: Get a -> ByteString -> a
19:09:39 <ivanm> o-_-o: hoogle only knows about the libraries that come with GHC (what is nowadays the platform)
19:09:55 <o-_-o> ivanm, ok
19:10:29 <quuxman> is there a hugs interface with tab completion of names in scope?
19:10:34 <quuxman> I have very little patience for CLIs without tab completion
19:10:37 <xerox> maybe winhugs?
19:10:47 <quuxman> xerox: I'm using ubuntu
19:10:53 <ivanm> quuxman: why not use ghci?
19:10:55 <xerox> oops
19:11:01 <ivanm> note that hugs is pretty much dead
19:11:12 <quuxman> ivanm: I want to check out this Haven library... (oh, I didn't know that)
19:11:33 <ivanm> what library is this?
19:11:33 <quuxman> ivanm: Haven requires Hugs or GHC 5, so I assumed it would be easier to use Hugs
19:11:48 <ivanm> if so, it must be old enough to be useless
19:11:53 <quuxman> http://haskell.org/haven/
19:12:13 <xerox> quuxman also there is cairo bindings in gtk2hs
19:12:21 <ivanm> it uses Java? :s
19:12:30 <quuxman> xerox: I've used the cairo bindings with gtk2hs
19:13:07 <ivanm> quuxman: see byorgey's shape drawing library
19:13:15 <ivanm> (which I'm trying to remember the name of)
19:13:30 <ivanm> there's also graphvics-drawingcombinators which uses opengl...
19:13:39 <pretsas> What is the general opinion of Leksah?
19:13:48 <ivanm> pretsas: a Haskell IDE
19:13:52 <pretsas> I know that
19:13:56 <quuxman> ivanm: is byorgey's library in hackage?
19:14:05 <ivanm> quuxman: yup; diagrams is it
19:14:10 <pretsas> I mean, is it useful?
19:14:17 <pretsas> Or is there some good reason not to use it?
19:14:28 <pretsas> Something to that effect :P
19:14:34 <ivanm> oh, _opinion_
19:14:41 <ivanm> for some reason I misread that :s
19:14:45 <ivanm> pretsas: some people use it; I for one don't
19:15:06 <quuxman> ivanm: I want to draw things to the screen, as opposed to a file
19:15:21 <djahandarie> ivanm, normally people read "opinion" where there isn't on the internet
19:15:27 <quuxman> so it sounds like I should use cairo + gtk2hs or drawingcombinators
19:15:30 <ivanm> *shrug* see the verious SDL, OpenGL, etc. bindings then
19:15:30 <djahandarie> I guess you are just special. :P
19:15:54 <ivanm> I think I read pretsas' question as "What is the general purpose of Leksah?" :s
19:16:03 * ivanm is still jet lagged
19:16:28 <aluink> ivanm: w00t, i believe i've converted the pythagoras'cont do block to using only >>= and lambdas...http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16554#a16555
19:16:41 <tomberek> prestas: i spent a while getting leksah to work and eventually just started using editor and ghci
19:17:04 <tomberek> though a good ide for haskell would be great
19:17:19 <ivanm> aluink: looks about right
19:17:28 <ivanm> tomberek: emacs with haskell-mode! \o/
19:17:40 <tomberek> hehe
19:18:07 <aluink> ivanm: my playing with it has so far yield equal outputs for each version
19:18:30 <aavogt> aluink: you've seen quickcheck?
19:19:00 <tomberek> ivanm: I'm not understanding how Map Vertex (Set (Weight, Vertex)) is applicable to neural networks.. The Set part is throwing me for a loop
19:19:20 <ivanm> tomberek: well Cale proposed it, nto me ;-)
19:19:20 <tomberek> Map Vertex Weight seems good enough to store everything?
19:19:24 <ivanm> *not
19:19:32 <aluink> aavogt: briefly
19:19:34 <ivanm> tomberek: but I'm guessing the point was that each edge has a Weight
19:19:40 <tomberek> Cale: opinion on 5 lines above ^^^^^^
19:19:58 <aavogt> tomberek: Map Vertex Weight -- how do you lookup all the destination links from a given vertex then?
19:20:08 <ivanm> so from each Vertex, you have a Set of edges (assuming no multiple edges) to other vertices each with a weighting
19:20:16 <quuxman> why are there so many awesome Haskell libraries that have been abandoned to bitrot?
19:20:20 <aavogt> in a Map, all the keys must be unique
19:20:36 <ivanm> tomberek: if you have weighted vertices with unweighted edges, maybe soemthing like: Map Vertex (Weight, Set Vertex) would be appropriate
19:20:46 <ivanm> quuxman: because the developers no longer care
19:20:48 <tomberek> ah, i get it, i was thinking something like Map Connection Weight where Connection =(Vertex,Vertex)
19:21:15 <ivanm> quuxman: in particular, until Hackage came around most libraries were done by PhD students, etc. as research; as soon as theiri project/thesis/grant was over they stopped caring
19:21:23 <ivanm> tomberek: right, you can do that as well
19:21:47 <ivanm> but with your way it's harder to find which other vertices a specific vertex is connected to
19:22:06 <tolkad> Is it possible to load PHP classes into haskell?
19:22:15 <tolkad> to do OOP in haskell
19:22:16 <kamatsu> tolkad: no
19:22:21 <quuxman> ivanm: yeah I know. It's frustrating though. There are several such libraries that would be really useful
19:22:30 <kamatsu> tolkad: OOP in haskell is achievable
19:22:35 <kamatsu> tolkad: PHP classes in haskell are not
19:22:35 <tomberek> i see,, ok..... when Cale said he implemented that A* in 10 minutes, i hate him... i've been trying to learn haskell for weeks
19:22:48 <pretsas> Isn't OOP in haskell against the whole haskell way?
19:22:53 <ivanm> tolkad: can I load Haskell modules into PHP to do pure functional programming?
19:22:57 <ivanm> pretsas: not at all
19:22:59 <kamatsu> pretsas: not exactly
19:23:02 <ivanm> see Timber, OOHaskell, etc.
19:23:04 <quuxman> lol, a Haskell to PHP bridge... combining the most beautiful and ugly programming languages in existence
19:23:25 <tolkad> quuxman: idk, are you sure perl isn't worse?
19:23:27 <kamatsu> quuxman: that'd be inline x86 assembly
19:23:36 <kamatsu> tolkad: perl is substantially better ;)
19:23:58 <quuxman> tolkad: yes, I've written lots of code in both, and Perl is far better
19:23:58 <aavogt> @where harpy
19:23:59 <lambdabot> http://uebb.cs.tu-berlin.de/harpy/
19:24:00 <ddarius> I hate perl and I would say it is significantly better than PHP.
19:24:01 <medfly> tomberek, someone who knows Haskell had an easier time doing something than someone that doesn't even know the language?
19:24:21 <quuxman> and yes, ddarius is right. They're both terrible
19:24:39 <tomberek> medfly: i just envy it... i'll get there eventually
19:25:10 <kamatsu> tolkad: anyway, most of the time OOP isn't the way to go
19:25:23 <kamatsu> tolkad: most OOP like constructs can be modelled more simply in Haskell
19:25:34 <Cale> tomberek: If it helps, it took me about two months before I actually felt like I could do useful things with Haskell, and about a year to be "comfortable".
19:25:39 <dino-> I know Perl isn't on it, but this all made me think of: http://imgur.com/P9RnL
19:25:53 <kamatsu> Cale: took me a similar time
19:25:53 <tolkad> Anyway, functional programming languages have problems. For example say I want a function to split a string into two parts. In a normal language I could do this with one function call. In a functional language it requires two function calls because each function call can only return one value
19:25:56 <ivanm> Cale: so about 3 times as fast as everyone else? :p
19:26:03 <tomberek> Cale: actually, that does help... now I don't feel so stupid
19:26:06 <kamatsu> tolkad: horseshit
19:26:08 <kamatsu> tolkad: sorry
19:26:15 <kamatsu> tolkad: but, i can easily do that in haskell
19:26:19 <tolkad> kamatsu: By definition a function only returns 1 value
19:26:31 <c_wraith> tolkad: tuples are single values
19:26:31 <kamatsu> tolkad: you can put multiple values in 1 return value
19:26:33 <quuxman> tolkad: ever heard of a tuple?
19:26:42 <kamatsu> tolkad: split :: String -> (String, String)
19:26:44 <quuxman> tolkad: or a struct?
19:26:45 <Cale> > splitAt 5 "Hello, World!"
19:26:46 <lambdabot>   ("Hello",", World!")
19:26:48 <quuxman> tolkad: or a list?
19:26:54 <tolkad> Is that like multipe return values in lua?
19:26:59 <kamatsu> no
19:27:01 <kamatsu> it's tuple values
19:27:10 <tomberek> tolkad: um.... tuple can hold (2,'c')
19:27:17 <tomberek> or ('cdcd','gfds')
19:27:26 <kamatsu> tomberek: double quotes ;)
19:27:38 <tomberek> kamatsu: aye
19:27:51 <c_wraith> :t (,)
19:27:52 <lambdabot> forall a b. a -> b -> (a, b)
19:27:57 <tolkad> Well then you are stuck with a tuple. In a functional language it is impossible for 1 value to become two values
19:27:58 <ivanm> the first bit of Haskell code that I released that I considered to be "good" was graphviz last year; I've been using Haskell for about 3 years now IIRC
19:28:06 <ivanm> tolkad: "stuck with"?
19:28:09 <kamatsu> tolkad: also not true
19:28:09 <quuxman> dino-: that picture is awesmo
19:28:11 <ivanm> do you even know wtf you're talking about?
19:28:17 <ivanm> or are you just a mega troll?
19:28:22 <kamatsu> tolkad: (a,b) = splitAt 5 "abcdefghijkl"
19:28:39 <dino-> quuxman: awesmo indeed. It made me luagh
19:28:52 <kamatsu> i think tolkad is either badly misinformed or a troll
19:28:52 <ivanm> or else you can always use uncurry on that
19:28:54 <tolkad> I think tuples are cheating sort of : /
19:28:59 <tomberek> stop feeding?
19:29:05 <ivanm> tolkad: tuples are something missing from other mainstream languages
19:29:13 <tolkad> ivanm: python has them
19:29:16 <pretsas> You tolkad, are most definitely approaching your problem the wrong way
19:29:23 <ivanm> tolkad: let's consider how to swap two variables around in other languages
19:29:38 <kamatsu> tolkad: python's tuples are mutable and wrong
19:29:42 <pretsas> Yay for useless temporary variables!
19:29:43 <ivanm> in Java, etc. you have to use references because they don't have tuples and thus you can only return one value
19:29:45 <tolkad> ivanm: $temp = $a; $b = $a; $b = $temp;
19:30:00 <kamatsu> tolkad: in  haskell (b,a) = (a,b)
19:30:02 <ivanm> tolkad: right, but can you write a function to do that for you?
19:30:20 <tolkad> kamatsu: in php, list($a, $b) = array($b, $a);
19:30:22 <copumpkin> kamatsu: that doesn't terminate
19:30:26 <tolkad> wait I don't know if that works
19:30:29 <tolkad> let me tes
19:30:31 <tolkad> test*
19:30:38 <ivanm> in C, Java, etc. the only way to return multiple values is to define some weird custom data structure just for it or to use pointers, etc.
19:30:51 <kamatsu> copumpkin: are you sure?
19:31:01 <copumpkin> > let (b, a) = (a, b) in a
19:31:02 <ivanm> tolkad: how do you write a swapValues function?
19:31:05 <lambdabot>   mueval-core: Time limit exceeded
19:31:11 <copumpkin> :P
19:31:20 <Cale> > let swap (a,b) = (b,a) in swap (1,2)
19:31:21 <lambdabot>   (2,1)
19:31:26 <copumpkin> :P
19:31:30 <ivanm> copumpkin: yeah, kamatsu forgot the \
19:31:31 <tolkad> ivanm: http://codepad.org/TlZIv1KS
19:31:31 <kamatsu> What cale said ;)
19:31:34 <ivanm> Cale: exactly
19:31:36 <copumpkin> aha :)
19:31:56 <aavogt> > let swap = uncurry (flip (,)) in swap (1,2)
19:31:56 <tolkad> ivanm: function swapValues(&$a, &$b) {list($a, $b) = array($b, $a);}
19:31:57 <lambdabot>   (2,1)
19:32:04 <ivanm> Cale: whereas when I was learning Java at uni, I was told that the "only" way that kind of thing was possible was to use pointers (or whatever Java calls them)
19:32:21 <ivanm> tolkad: I can't read perl, but to me it appears you don't actually return the values
19:32:29 <ivanm> instead you're using references
19:32:35 <pretsas> Also, it looks nasty :D
19:32:37 <tolkad> ivanm: Oh, I thought you wanted references, I can return too
19:32:43 <ivanm> tolkad: no
19:32:58 <ivanm> my point was, you use tuples to avoid having to do ugly hacks like that
19:33:09 <tolkad> function swapValues($a, $b) {return array($b, $a);}
19:33:12 <dolio> Functions should return error codes, anyway.
19:33:17 <ivanm> tolkad: so you're using an array
19:33:20 <tolkad> ivanm: PHP calls it's tuples arrays
19:33:23 <ivanm> tolkad: ahh
19:33:28 <ivanm> so you _are_ using tuples!
19:33:32 <ivanm> and that was my point
19:33:46 <kamatsu> PHP's arrays are actually hashmaps/arrays/tuples/lists/whatever
19:33:55 <kamatsu> a general "stuff" container
19:33:55 <tomberek> stop furnishing sustenance!
19:33:56 <tolkad> ivanm: yeah but php isn't a functional language. I'm saying if haskell uses tuples it isn't really functional
19:34:07 <ivanm> how is it not functional?
19:34:08 <quuxman> lol
19:34:08 <kamatsu> ah, tolkad is just a trol
19:34:09 <Cale> tomberek: Here, we feed trolls until they explode.
19:34:10 <ivanm> @src (,)
19:34:10 <lambdabot> Source not found. You speak an infinite deal of nothing
19:34:13 <tolkad> I'm not trolling
19:34:16 <medfly> hehe
19:34:23 <kamatsu> tolkad: what in your mind defines a functional language?
19:34:31 <c_wraith> :t (,,,,,,,,,,,)
19:34:32 <Cale> tomberek: As long as there's actual information being furnished, it's okay :)
19:34:33 <lambdabot> forall a b c d e f g h i j k l. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> (a, b, c, d, e, f, g, h, i, j, k, l)
19:34:37 <ivanm> tolkad: this isn't quite accurate because it's a built in, but: data (a,b) = (a,b)
19:34:42 <aavogt> @@ @pl @undo \x y ->  do x' <- readIORef x; y' <- readIOref y; writeIOref x y'; writeIORef y x'
19:34:42 <lambdabot>  ap ((.) . (>>=) . readIORef) (ap ((.) . (>>=) . readIOref) . (. writeIORef) . (.) . flip . ((>>) .) . writeIOref)
19:34:45 <tomberek> Cale: i guess it could be useful.
19:34:47 <ivanm> so you can pattern match, use currying, etc. on them
19:34:54 <copumpkin> tolkad: what about tuples makes them inherently unfunctional?
19:35:00 <tomberek> Cale: keeps the channel from dying
19:35:02 <aavogt> that is how you swap two variables in haskell
19:35:05 <ivanm> @remember Cale Here [#haskell], we feed trolls until they explode.
19:35:05 <lambdabot> Okay.
19:35:06 <tolkad> kamatsu: It has like real math functions. Each function returns only 1 value. Functions don't have side effects
19:35:19 <kamatsu> tolkad: right, and tuples are not side effects, and tuples are one value
19:35:20 <ivanm> aavogt: heh
19:35:21 <kamatsu> no problem
19:35:24 <Cale> tomberek: There are also lurkers who doubtless benefit.
19:35:32 <ivanm> @type ap ((.) . (>>=) . readIORef) (ap ((.) . (>>=) . readIOref) . (. writeIORef) . (.) . flip . ((>>) .) . writeIOref)
19:35:33 <lambdabot> Not in scope: `readIORef'
19:35:33 <lambdabot> Not in scope: `readIOref'
19:35:33 <lambdabot> Not in scope: `writeIORef'
19:35:37 <ivanm> bah
19:35:39 <tolkad> kamatsu: I learned in algebra in high school that you do the verticle line test, if you have like two values because it was a tuple it fails the vertical line test
19:35:53 <Cale> tolkad: Not only that, but each function takes only one parameter
19:35:55 <ivanm> tolkad: that's to do with functions in maths
19:35:57 <aavogt> should be   IORef a -> IORef a -> IO ()
19:36:01 <kamatsu> the vertical line test is not a solid definition of a function, actually
19:36:06 <ivanm> tolkad: here, we are returning a single value
19:36:08 <BMeph> I lol'd. ;)
19:36:22 <ivanm> tolkad: e.g. you can have functions of type R -> R*R
19:36:25 <tolkad> Cale: I didn't know that
19:36:33 <ivanm> i.e. you're mapping a value into a point on the 2D plane
19:36:33 <medfly> o.O
19:36:44 <tolkad> @type a
19:36:45 <lambdabot> Expr
19:36:49 <Cale> tolkad: If you have a function R -> RxR, then it's more of a 'vertical plane test'
19:36:56 <kamatsu> tolkad: In Haskell, returning a tuple is like drawing a line on a 3 dimensional plane
19:37:09 <ivanm> kamatsu: yeah, it's a very simplistic definition if the domain and range are the same (or the same "type" at least); that's about it
19:37:11 <kamatsu> tolkad: vertical line test still passes
19:37:36 <Gracenotes> @type Data.IORef.readIORef
19:37:37 <lambdabot> forall a. GHC.IOBase.IORef a -> IO a
19:37:37 <Cale> tolkad: To each real number in R, the function associates exactly one pair of real numbers in RxR
19:37:45 <Cale> (one point in that plane)
19:37:50 <tolkad> kamatsu: that... actually makes sense
19:37:50 <quuxman> tolkad: the vertical line test is a special case of testing the condition of one input always producing one and the same output
19:38:06 <EvanCarroll> I really would not believe a single person new to functional programming learned on RWH prior to the printing.
19:38:13 <EvanCarroll> I wouldn't even believe someone new to haskell learned with RWH prior to the printing
19:38:29 <ivanm> what's the technical definition of a function again? there's an injection between the domain and the range?
19:38:30 <Cale> EvanCarroll: why is that?
19:38:30 <tolkad> EvanCarroll: what's RWH?
19:38:35 <kamatsu> a book
19:38:37 <kamatsu> Real World Haskell
19:38:41 <EvanCarroll> I've pulled my hair out on poor code representations at least 5 times in chapter 6 alone.
19:38:49 <medfly> @where rwh
19:38:50 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
19:38:55 <ivanm> EvanCarroll: sure, you can learn how to use Haskell
19:39:01 <medfly> I can see the future!
19:39:02 <ivanm> RWH isn't aimed as a tutorial to new programmers
19:39:07 <o-_-o> a :: IO (Word16, Word8, Word8, Word16, Word16, Word16, Word16) <- If I have a type of this, how do I access the individual things inside
19:39:10 <kamatsu> learn you a haskell is good for that
19:39:12 <kamatsu> @where lyah
19:39:13 <lambdabot> http://www.learnyouahaskell.com/
19:39:23 <ivanm> it is aimed as an advanced Haskell tutorial with introductory material for people who have programmed in other languages before
19:39:30 <aavogt> o-_-o: pattern match... but maybe you should use some more sane datatype here?
19:39:33 <BMeph> Evan: Comments Welcome! ;)
19:39:43 <Cale> EvanCarroll: poor code representations?
19:39:45 <ivanm> o-_-o: you have to use <- in a do block to "extract" the value out of the IO first
19:39:48 <o-_-o> http://moonpatio.net/fastcgi/hpaste.fcgi/view?id=6493#a6493
19:39:51 <ivanm> and then you can pattern match when doing so
19:39:58 <ivanm> aavogt: it's in IO
19:40:05 <o-_-o> ivanm, can you give a small example
19:40:11 <quuxman> ok, so here's what I've been wanting for a long time: A level graphics API (Cairo is fine) that I can make calls to in ghci and see the results immediately
19:40:21 <quuxman> s/A level/A high level/
19:40:24 <EvanCarroll> yea, like http://book.realworldhaskell.org/read/using-typeclasses.html JSONClass.hs
19:40:32 <aavogt> ivanm: minor details :)
19:40:35 <o-_-o> ivanm, the entire code is in the paste above
19:40:47 <ivanm> o-_-o: do I dare ask wtf you're doing there?
19:40:49 <pastorn> quuxman: like hackety-hack?
19:40:50 <ivanm> aavogt: heh
19:40:58 <o-_-o> ivanm, reading an SGI RGB file
19:40:59 <pastorn> or maybe hackety-hack is not immideate?
19:41:08 <EvanCarroll> that is the first time we've ever seen id in code, , and it is the first time we've treated a value constructor like a function, and it is the first time we've curried a value constructor
19:41:10 <ivanm> o-_-o: why is the type sig commented out?
19:41:12 <o-_-o> ivanm, learning how to do binary IO in haskell :-)
19:41:21 <o-_-o> ivanm, it doesn't compile with it
19:41:47 <quuxman> pastorn: Possibly... let me check out hackety-hack
19:41:58 <Cale> EvanCarroll: Er, really?
19:42:09 <EvanCarroll> yes.
19:42:11 <Cale> EvanCarroll: Well, maybe I'll believe the point about id
19:42:21 <dolio> @type liftM7
19:42:22 <ivanm> o-_-o: what does :type sgiRGBHeader in ghci say?
19:42:22 <lambdabot> Not in scope: `liftM7'
19:42:26 <ivanm> o-_-o: http://moonpatio.net/fastcgi/hpaste.fcgi/view?id=6493#a6494
19:42:33 <pastorn> quuxman: installing it in *nix is hard, but i reckon windows is easier
19:42:38 <ivanm> OK, so the initial type might be wrong then if the type for sgiRGBheader is wrong
19:42:41 <EvanCarroll> show me a single curried value constructor prior to that point.
19:42:42 <Cale> There are lots of places where data constructors are being applied like functions earlier on that page even...
19:42:47 <quuxman> pastorn: but I want Haskell, not Ruby
19:43:09 <o-_-o> ivanm: sgiRGBHeader  :: Get (Word16, Word8, Word8, Word16, Word16, Word16, Word16)
19:43:32 <ivanm> o-_-o: which is exactly what you have there...
19:43:40 <ivanm> so why doesnt' it work with it uncommented?
19:43:40 <o-_-o> I took it from an example in http://www.haskell.org/haskellwiki/DealingWithBinaryData
19:43:44 <EvanCarroll> i have the book, it is in a slightly different format got an example, I must have missed it then
19:44:01 <pastorn> quuxman: but is it the design you're looking for?
19:44:01 <o-_-o> ivanm, I don't know I took it from haskell wiki above
19:44:31 <lunabot>  test
19:44:31 <Cale> EvanCarroll: But maybe not partially applied...
19:44:32 <ivanm> o-_-o: first of all, I highly suggest that you become more familiar with the basics before doing that kind of stuff then
19:44:39 <pastorn> quuxman: to do stuff that interacts with running programs one example i've seen is done by alex mclean... lemme find a ling
19:44:40 <o-_-o> ivanm, ok
19:44:48 <ivanm> but anyway, I gave you a link which demonstrates how to actually use values like that
19:44:55 <ivanm> note that it works for all monads, not just Get
19:44:55 <EvanCarroll> I'm just saying, as a novice I can not recommend this book to novices without a serious discussion on version 2.
19:45:05 <Cale> EvanCarroll: I suppose someone might get the idea that data constructors are special syntax or something (as they are special in patterns)
19:45:15 <o-_-o> ivanm, thanks :-)
19:45:16 <EvanCarroll> It in its current form is very unrefined for the purpose i'm using it for, I this isn't the first case.
19:45:22 <ivanm> o-_-o: no worries ;-)
19:45:26 <tomberek> how can I make this type an instance of Show: type Activation a = Pulse a -> Pulse a    I'm getting illegal instance declarations
19:45:49 <c_wraith> since it's a function, you probably can't use deriving
19:45:49 <ivanm> tomberek: you can't create isntances for type aliases
19:45:51 <tolkad> # let a = "x"
19:45:53 <quuxman> pastorn: let's see... I'm downloading it now
19:45:53 <lunabot>  luna: parse error on input `|]'
19:45:58 <tomberek> ivanm:  ah,, that would be why!
19:45:59 <tolkad> what am I doing wrong?
19:46:02 <Gracenotes> ivanm: you can't?
19:46:05 <ivanm> (well, you can with an extension, but you shouldn't int hat case)
19:46:06 <EvanCarroll> http://stackoverflow.com/questions/2125674/what-is-the-effect-of-type-synonyms-on-instances-of-type-classes-what-does-the-t
19:46:11 <EvanCarroll> for another example in the same chapter.
19:46:15 <ivanm> Gracenotes: there's an extension, but still...
19:46:23 <EvanCarroll> go to the comments on the website for other people struggeling with the /same/ thing.
19:46:28 <ivanm> tolkad: with what?
19:46:33 <Gracenotes> I didn't think type synonyms were limited in that way
19:46:43 <pastorn> quuxman: http://yaxu.org/patterns-in-haskell/
19:46:44 <tolkad> ivanm: nvm
19:46:54 * Cale wonders how the Haskell community on StackOverflow is.
19:46:58 <Gracenotes> well, good way to prevent someone from making instances for a type you export
19:47:06 <ivanm> Gracenotes: if I say "type MyInt = Int" and create an instance for it, how does GHC know which instance to use?
19:47:14 <ivanm> since type aliases are there for the _programmer_
19:47:25 <Gracenotes> ivanm: same way if you were to make two instances for Int
19:47:29 <tomberek> that's ok, i'll just change the Show instance for my data Neuron a
19:47:30 <ivanm> Cale: as in how knowledgeable/good they are?
19:47:32 <EvanCarroll> because of the poorly chosen examples, i feel the language is getting exponentially more complex with each chapter, with LYAH, I feel it is fairly linear because it is so much better written.
19:47:34 <Gracenotes> it would complain and forbid it
19:47:34 <ivanm> Gracenotes: exactly; you can't
19:47:47 <ivanm> EvanCarroll: compared to what?
19:47:51 <EvanCarroll> I just don't feel like I'm getting the foundation i want with LYAH.
19:47:51 <pastorn> quuxman: or now i'm not really sure... i thought he interactively changed stuff in a sound thread or something, but watching his videos again makes me a bit uncertain
19:48:03 <aavogt> EvanCarroll: then read it exponentially more slowly :)
19:48:06 <EvanCarroll> ivanm: (learn you a haskell)
19:48:14 <Gracenotes> so given that, it should be perfectly permissible to make an instance for the synonym but not the synonymed type
19:48:14 <EvanCarroll> aavogt++ hahahah
19:48:20 <tolkad> @faq can haskell randomly delete all the file on your computer when given simple, benign code?
19:48:21 <lambdabot> The answer is: Yes! Haskell can do that.
19:48:30 <tolkad> 0_o
19:48:30 <ivanm> EvanCarroll: I quite like Craft of Functional Programming
19:48:35 <ivanm> which is a paper book
19:48:36 <Cale> ivanm: as in how popular that site is for getting help with Haskell
19:48:42 <ivanm> @slap tolkad
19:48:42 * lambdabot smacks tolkad about with a large trout
19:48:50 <ivanm> Cale: *nod*
19:48:54 <Gracenotes> tolkad: gotta watch out for behavior that's specified to be undefined
19:49:07 <Gracenotes> though better a deleted file than a missile launching
19:49:47 * ivanm has been tempted for many years now to buy a USB missile launcher gadget, write haskell bindings to it and then put them up on Hackage with an unsafeLaunchMissiles function...
19:49:50 <tolkad> @faq can haskell randomly initiate nuclear warfare when given simple, benign code?
19:49:51 <lambdabot> The answer is: Yes! Haskell can do that.
19:49:59 <ivanm> @slap tolkad
19:50:00 * lambdabot beats up tolkad
19:50:10 <quuxman> pastorn: there is a library that does that... I saw a demo video of it in use
19:50:17 <Cale> Hmm, 670 / 477974 questions :)
19:50:18 <quuxman> pastorn: I think reactive might be a helpful library to write something like this
19:50:34 <pastorn> quuxman: cool... i'll have to check it out
19:50:52 <Cale> uhhh...
19:50:52 <quuxman> pastorn: there's already reactive-fieldtrip, but it focuses mostly on 3D
19:51:00 <Cale> reactive is cool except that it's broken
19:51:10 <quuxman> Cale: oh? :)
19:51:15 <ivanm> run everyone! it's zombie Cale! :p
19:51:41 <Cale> There are implementation problems.
19:52:26 <Cale> Well, maybe when Conal gets GHC 6.12, he can get things running and tell us if unamb works better and magically makes all the problems go away :)
19:52:45 <o-_-o> ivanm, I fixed the issue, it was a typo
19:52:53 <Cale> But there are showstopping performance issues currently.
19:53:02 <ivanm> o-_-o: heh
19:53:15 <pastorn> what in 6.12 is it that makes everything break?
19:53:28 <dino-> Speaking of, I was fairly put-off by the having to pay to get your cv viewed by potential jobs on StackOverflow's job thingamajig
19:53:29 <Cale> No, 6.12 might fix something
19:53:30 <quuxman> Cale: oh, good to know I guess
19:53:35 <Cale> (but we don't know yet)
19:53:54 <ivanm> pastorn: some libraries have changed, etc.
19:53:56 <pastorn> well, nothing builds in 6.12
19:54:01 <ivanm> pastorn: not much really
19:54:17 <pastorn> i know the Vector library breaks, so GPipe can't compile
19:54:18 <ivanm> the biggest change was locale-dependent IO; there have been a few bugs, etc. wrt that
19:54:21 <tomberek> how do I :::    add (Show a) to the context of the instance declaration ?
19:54:21 <aavogt> pastorn: previous ghc releases were worse with respect to compatibility
19:54:41 * EvanCarroll <3's SO, the RWH commendium with the Oreilly errate a and comments from the book website.
19:54:49 <ivanm> (in terms of documentation, etc. containing non-ASCII characters)
19:55:00 <aavogt> tomberek: your question looks broken... your type should already have a Show instance.
19:55:00 <EvanCarroll> If I learn haskell, it is so going on the list of lifes top 10 accomplishments.
19:55:02 <pastorn> tomberek: instance (Show a) => Mydata a where ?
19:55:36 <aavogt> missing the class there...
19:55:56 <tomberek> i'm trying to define Neron a as an instance of Show, but then the recursive call to show gives me this error:     Could not deduce (Show a) from the context (Show (Neuron a))
19:56:03 <tolkad> , ,
19:56:05 <lunabot>  luna: No instance for (GHC.Show.Show (a -> b -> (a, b)))
19:56:16 <tolkad> , ","
19:56:16 <ivanm> tomberek: paste the code up somewhere?
19:56:18 <lunabot>  ","
19:56:38 <ivanm> tomberek: note: IMHO you should only ever have "deriving (Show)" (with the exception fo types such as Map and Set)
19:56:44 <ivanm> you should never use Show for pretty-printing
19:57:03 <Cale> EvanCarroll: feel free to ask questions here
19:57:05 <ivanm> but what you probably want is: instance (Show a) => Show (Neuron a) where ... "
19:57:31 <Cale> EvanCarroll: asking is often a lot faster and easier than finding information in some manual somewhere
19:57:59 <ivanm> Cale: so you're saying _not_ to rtfm?
19:58:08 <pretsas> *GASP*
19:58:09 <Cale> Right.
19:58:20 <medfly> "hey, it keeps me entertained!"
19:58:25 <medfly> Cale loves this channel.
19:58:25 <copumpkin> lol
19:58:25 <tomberek> ivanm: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16557#a16557
19:58:43 <copumpkin> Cale needs to become a teacher quickly
19:58:46 <copumpkin> too enthusiastic
19:58:48 <Cale> You have a channel full of people you'll be helping to procrastinate.
19:58:50 <EvanCarroll> Cale: yea, I like So though I usually need wordy long ass explainations to get the concepts through my thick-as-steel head. So the medium seems to work a lot better.
19:59:00 <EvanCarroll> SO*
19:59:01 <Cale> copumpkin: Who says I don't teach? :)
19:59:11 <tolkad> What is # for with lunabot?
19:59:11 <medfly> Cale might end up actually writing code if no one asks questions here
19:59:12 <ivanm> tomberek: no, you couldn't derive Show because Activation is a function
19:59:16 <tolkad> it always give a syntax error
19:59:19 <Gracenotes> # 3
19:59:21 <lunabot>  luna: parse error on input `|]'
19:59:22 <copumpkin> Cale: I guess nobody :)
19:59:26 <Gracenotes> ooh..
19:59:29 <pastorn> tomberek: instance (Show a) => (Show (Neuron a)) where
19:59:36 <dolio> , 3
19:59:37 <pastorn> that'll probably work
19:59:37 <lunabot>  3
19:59:39 <tomberek> ivanm: adding (Show a) => worked.... well, I just made it so Activation is not "showed"
19:59:41 <ivanm> tomberek: what's the actual error message?
19:59:43 <Gracenotes> some template-haskell thing
19:59:50 <Cale> copumpkin: OTOH, it would be nice to be *paid* to teach.
19:59:55 <ivanm> I'm guessing the problem is with either Activity or Connection
20:00:02 <ivanm> tomberek: right, that's the problem
20:00:03 <dolio>  #foo ... = , [$foo| ... |]
20:00:05 <dolio> As I recall.
20:00:19 <tomberek> ivanm: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16557#a16558
20:00:22 <ivanm> pastorn: geez, I thought I'd said that already... ;-)
20:00:34 <ivanm> tolkad: ask mmorrow when he's here
20:00:43 <ivanm> but it does some weird Template Haskell stuff or something IIRC
20:00:56 <pastorn> ivanm: you did'n provide the correct code :p
20:00:56 <aavogt> #ty 1
20:00:59 <lunabot>  forall t . Num t => t
20:01:03 <ivanm> pastorn: sure I did
20:01:03 <tolkad> @botsnack
20:01:04 <lambdabot> :)
20:01:04 <lunabot>  :o
20:01:09 <aavogt> , [$ty| 1 |]
20:01:12 <lunabot>  forall t . Num t => t
20:01:14 <ivanm> <ivanm> but what you probably want is: instance (Show a) => Show (Neuron a) where ... "
20:01:20 <aavogt> #ty ty
20:01:23 <lunabot>  QuasiQuoter
20:01:41 <aavogt> #src 'QuasiQuoter
20:01:42 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Quote.QuasiQuoter'
20:01:48 <aavogt> #src ''QuasiQuoter
20:01:49 <Cale> tomberek: The type synonym part isn't the only reason you can't derive Show for Activation.
20:01:50 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Quote.QuasiQuoter'
20:01:52 <ivanm> aavogt: QuasiQuoter is the type
20:01:56 <tomberek> pastorn: ivanm's idea compiled fine
20:01:57 <aavogt> #info 'QuasiQuoter
20:01:58 <lunabot>  luna: Not in scope: `info'
20:02:20 <Cale> tomberek: It's also because Activation a is a type of function.
20:02:26 <aavogt> ivanm: well there's some way to look up definitions based on the type
20:02:27 <tomberek> Cale: is there a quick way to have a show that just returns the type of a function as a string?
20:02:36 <aavogt> I just have not found it yet
20:02:41 <ivanm> heh
20:02:45 <tomberek> so show id = "a->a"
20:02:57 * EvanCarroll powers down, night all
20:02:57 <tomberek> something like that?
20:03:07 <Cale> tomberek: Maybe not one which works with polymorphic functions
20:03:12 <c_wraith>  > id
20:03:15 <Cale> tomberek: But you can use Typeable to write an instance...
20:03:19 <c_wraith> > id
20:03:20 <lambdabot>   {()->()}
20:03:30 <tolkad> @fact ,"
20:03:31 <lambdabot> ,": lol"
20:03:32 <lunabot>  ": lol"
20:03:40 <tomberek> Cale: I don't know much about Typeable, give me a sec
20:04:12 <tolkad> Is there anything lambdabot will respond to that starts with a space?
20:04:22 <ivanm> tolkad: no
20:04:26 <ivanm> tolkad: and stop being stupid
20:04:50 <ivanm> it took us long enough to convince mmorrow to not have lunabot use /NOTICE
20:04:58 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16559#a16559
20:05:01 <ivanm> and if you keep doing this kind of garbage maybe he'll put it back
20:05:02 <Cale> tomberek: ^^
20:05:21 <ivanm> > typeOf id
20:05:23 <lambdabot>   Ambiguous type variable `a' in the constraint:
20:05:23 <lambdabot>    `Data.Typeable.Typeable a...
20:05:27 <tolkad> ivanm: lol I once got an infinite loop between lambdabot and the scala bot
20:05:28 <ivanm> grrr....
20:05:31 <ivanm> @hoogle typeOf
20:05:31 <lambdabot> Data.Typeable typeOf :: Typeable a => a -> TypeRep
20:05:31 <lambdabot> Data.Typeable typeOf1 :: Typeable1 t => t a -> TypeRep
20:05:31 <lambdabot> Data.Typeable typeOf1Default :: (Typeable2 t, Typeable a) => t a b -> TypeRep
20:05:34 <ivanm> @slap tolkad
20:05:35 * lambdabot loves tolkad, so no slapping
20:05:41 <tomberek> Cale: I like it!
20:05:42 <Gracenotes> bad lambdabot
20:05:49 <ivanm> > show $ typeOf id
20:05:50 <lambdabot>   Ambiguous type variable `a' in the constraint:
20:05:50 <lambdabot>    `Data.Typeable.Typeable a...
20:05:55 <ivanm> grrr....
20:06:03 <Cale> Er, I don't think it actually needs FlexibleContexts
20:06:05 <ivanm> why isn't this working?
20:06:05 <Cale> let me check
20:06:10 <ivanm> > show $ typeOf 2
20:06:12 <lambdabot>   "Integer"
20:06:14 <Cale> right, it doesn't
20:06:16 <ivanm> > show $ typeOf succ
20:06:17 <lambdabot>   Ambiguous type variable `a' in the constraints:
20:06:17 <lambdabot>    `GHC.Enum.Enum a'
20:06:17 <lambdabot>      a...
20:06:22 <Gracenotes> > typeOf (id :: Integer -> Integer)
20:06:23 <lambdabot>   Integer -> Integer
20:06:28 <ivanm> Cale: any idea why lambdabot doesn't like it?
20:06:30 <Cale> ivanm: Polytypes aren't instances of Typeable
20:06:38 <ivanm> Cale: hmmm?
20:06:45 <Cale> You need to pick a monomorphic type first
20:06:48 <ivanm> ahhh
20:06:56 <ivanm> so you can't just have "a -> a" for example?
20:06:59 <Cale> right
20:07:03 <tibbe> dons: I have now descended on SF :)
20:07:03 <ivanm> :(
20:07:19 <Cale> > show (typeOf (id :: Integer -> Integer))
20:07:20 <lambdabot>   "Integer -> Integer"
20:07:20 <ivanm> Cale: I'm guessing because it's difficult to ensure that a new type variable is chosen each time?
20:07:34 <ivanm> tibbe: SourceForge? :p
20:07:44 <Cale> Because think about how you'd write the instance of Typeable
20:07:54 <Cale> You'd have to write an instance Typeable a where ...
20:08:01 <ivanm> anyone here an ops in #xmonad to kick tolkad from there?
20:08:02 <Cale> and that'd overlap with everything
20:08:05 <tibbe> ivanm: or San Francisco ;)
20:08:07 <Cale> ivanm: why?
20:08:12 <Cale> (Not that I do)
20:08:21 <tolkad> Cale: He has a personal vendetta against me
20:08:25 <ivanm> Cale: he's now spamming #xmonad with lambdabot commands
20:08:30 <ivanm> tolkad: use /msg lambdabot
20:08:32 <tolkad> ivanm: I only used one
20:08:39 <ivanm> right
20:08:51 <ivanm> you did "@djinn Either a b->Maybe a->Maybe b->Maybe a->Maybe b->Maybe a->Maybe b"
20:08:53 <ivanm> which was rather long
20:08:54 <Cale> ivanm: Probably better to use a non-technical solution ;)
20:09:09 <ivanm> #xmonad isn't for haskell discussion, etc. per-se
20:09:11 <lunabot>  luna: Not in scope: `xmonad'
20:09:18 <ivanm> strangely enough, it's to discuss _xmonad_
20:09:19 <tolkad> lawl
20:09:23 <ivanm> Cale: hmmm?
20:09:25 <Cale> tolkad: If you want to test lambdabot, note that it does respond to private messages.
20:09:31 <tolkad> ok
20:09:36 <Cale> tolkad: and will give longer responses in private
20:09:58 <keseldude> and you can enjoy @vixen in privacy
20:10:02 <tomberek> Cale: yeah, it doesn't work for polymorphic types
20:10:02 <Cale> heh
20:10:08 <Cale> tomberek: right.
20:10:47 <Cale> tomberek: But it should be enough that you can derive Show for Neuron
20:11:29 <Cale> (There's no way you could show a polymorphic Neuron anyway)
20:11:39 <tomberek> Cale: My Weight and Pulse (newtypes) are polymorphic:  newtype Weight a = Weight a deriving (a bunch of stuff)
20:11:57 <Cale> tomberek: Right, but in the end it'll be monomorphic, and things will be okay
20:12:07 <tomberek> hm.....
20:12:18 <Cale> For any particular value you'd want to show, you'll have chosen an 'a'
20:13:07 <Cale> What does the type a represent?
20:14:09 <tomberek> Cale: the type of the signal going around the network.. Int,Double, usually a numeric of some sort, sometimes a Float
20:14:34 <Cale> tomberek: When you derive an instance of Show, the derived instance will look something like:  instance Show a => Show (Neuron a) where ...
20:14:51 <Cale> hmm
20:15:29 <tomberek> Cale: i can do without it, but it does teach me a bit to get these little things right
20:15:34 <aavogt> Cale: how about if the 'a' isn't mentioned in any of the constructors?
20:15:56 <tolkad> Would it be possible to bring buttbot2 into here? it's a very useful bot we use in ##proggit. You can bring it in here by inviting it
20:16:06 * ivanm passes
20:16:13 <ivanm> with a name like that, it's probably not wanted
20:16:19 <ivanm> we already have 3 bots in here anyway
20:16:29 <tolkad> oh? I only see lambdabot and lunabot
20:16:30 <ivanm> (at least)
20:16:31 <Cale> tomberek: You'll probably need a Typeable instance (which you can derive) for Pulse
20:16:36 <ivanm> tolkad: there's also preflex
20:16:45 <ivanm> oh, and there's hackagebot
20:16:51 <ivanm> there used to be hpastebot as well...
20:16:54 <aavogt> there's also cale
20:16:58 <ivanm> aavogt: heh
20:17:31 <medfly> tolkad, what does it do?
20:17:51 <tolkad> medfly: It randomly responds to people replacing random words in what they said with "butt"
20:18:01 <tomberek> Cale: ok, that all worked now....
20:18:10 <medfly> heh
20:18:14 <medfly> okay...
20:18:21 <Cale> tolkad: no.
20:18:49 <Cale> tolkad: It's simply irritating.
20:19:02 <tomberek> Cale: why would Pulse need to derive Typeable when Weight is almost the same thing?
20:19:07 <kmc> tolkad, but is it written in Haskell?!?!?!?!?!?
20:19:16 <tomberek> Cale: nvm,,, it's because it is in the function type!!!
20:19:21 <ivanm> tolkad: so how is that a "very useful" bot?
20:19:23 <Cale> tomberek: right.
20:19:34 <tolkad> ivanm: I consider that a useful feature. It is written in perl
20:19:39 <Cale> tomberek: and so it needs a Typeable instance so that the Show instance for the function type will exist.
20:19:44 <ivanm> ... right ...
20:19:54 <tolkad> but perl is a similar enough language I guess
20:19:54 <ivanm> since when did juvenile == useful?
20:20:13 <ivanm> @type on
20:20:14 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
20:20:19 <tomberek> Cale: i'm getting the hang of it,, but the PRAGMA's are getting annoying. It seems like i should first learn Haskell proper without the extensions, or not?
20:20:26 <ivanm> tolkad: please tell me that wasn't a serious observation...
20:20:53 <Cale> ##proggit's SNR fell a good deal faster than the actual programming reddit's.
20:20:54 <lunabot>  luna: parse error on input `]'
20:21:01 <ivanm> Cale: SNR?
20:21:06 <Cale> tomberek: It's pretty hard to avoid extensions
20:21:12 <ivanm> Signal to Noise Ratio?
20:21:16 <Cale> ivanm: yeah
20:21:19 <absentia> programming reddits?
20:21:26 <ivanm> absentia: programming.reddit.com
20:21:35 <ivanm> Cale: with a bot like that, is it any wonder why?
20:21:42 <Cale> ivanm: heh
20:21:50 <absentia> 00h
20:21:52 <tomberek> Cale: That's what I'm noticing.  Is that good/bad?  What is standard Haskell practice regarding extensions?
20:22:11 <absentia> pr0n.reddit.com
20:22:12 <absentia> dern.
20:22:17 <Cale> tomberek: It's how the language evolves.
20:22:19 * absentia never has good ideas.
20:22:46 <Cale> tomberek: Implement first, ask questions later
20:23:07 <Cale> A lot of extensions are good candidates for standardisation of some sort.
20:23:12 <tomberek> Cale: thanks for the help... gotta go feed baby... be back
20:23:20 <Cale> no problem
20:23:24 <ivanm> tomberek: use as little as possible; if you have to use some of the "better" ones such as MPTCs, etc.; try to avoid ones like IncoherentInstances unless you really know hwat you're doing
20:23:28 <medfly> BABY! someone in #haskell managed to reproduce!
20:23:29 <ivanm> IMHO anyway
20:23:33 <ivanm> medfly: heh
20:23:40 <blackh> tomberek: The extensions are so useful that they're well accepted, but they all add complexity, so you really need to learn plain old Haskell 98 first.
20:23:46 <ivanm> medfly: CosmicRay started a trend...
20:23:52 <ivanm> ;-)
20:23:57 <ivanm> blackh: some of them are
20:24:02 <ivanm> not all AFAIK
20:24:03 <kmc> > text $ reverse ['a'..'z']
20:24:04 <lambdabot>   zyxwvutsrqponmlkjihgfedcba
20:24:24 <aavogt> some of the extensions lift rather random restrictions... like say -XFlexibleContexts
20:24:31 <blackh> ivanm, tomberek: You're right - some shouldn't be used, but most are good
20:24:46 <tolkad> preflex: tell #haskell test
20:24:46 -preflex(n=preflex@95-88-118-220-dynip.superkabel.de)- Consider it noted.
20:24:51 <kmc> ttttt
20:24:54 <aavogt> also multiparameter typeclasses
20:25:02 <medfly> uh-huh
20:25:40 <tolkad> > reverse ['a'..'u']
20:25:42 <lambdabot>   "utsrqponmlkjihgfedcba"
20:25:42 -preflex(n=preflex@95-88-118-220-dynip.superkabel.de)- lambdabot: you have 1 new message. '/msg preflex messages' to read it.
20:25:43 <ivanm> tolkad: please stop it
20:26:13 <kmc> why do so many people lurk here
20:26:13 <hgolden> hi. i am looking for a repository for HList, especially some examples of its use. it is no longer at http://darcs.haskell.org/HList . is it available somewhere else? thanks.
20:26:30 <ivanm> hgolden: there was a reply on cafe about it being on old-darcs.well-typed.com IIRC
20:26:35 <dobblego> hgolden, http://hackage.haskell.org/package/HList
20:26:48 <ivanm> http://old-darcs.well-typed.com/HList/
20:27:02 <ivanm> dobblego: he wanted a _repository_ ;-)
20:27:04 <copumpkin> kmc: hundreds of professional programmers who feel they should learn haskell eventually and hope that lurking in here they'll eventually absorb something, despite not making an active effort (for lack of time or discipline?) to do so
20:27:07 <copumpkin> kmc: just a hunch though
20:27:12 <kmc> heh copumpkin
20:27:23 <ivanm> copumpkin: what, haskellisation via osmosis?
20:27:26 <dobblego> ivanm, I expected appropriate link from there
20:27:33 <tolkad> can you reverse number lists?
20:27:35 <copumpkin> ivanm: hell yeah
20:27:38 <tolkad> > reverse 1 2
20:27:39 <lambdabot>   Couldn't match expected type `t1 -> t' against inferred type `[a]'
20:27:40 <copumpkin> tolkad: you can reverse any list
20:27:40 * kmc learned haskell thorough second level meditation
20:27:40 <medfly> :t reverse
20:27:42 <lambdabot> forall a. [a] -> [a]
20:27:46 <medfly> > reverse [1..10]
20:27:47 <ivanm> dobblego: the servers just got changed; some of the stuff didn't get migrated properly
20:27:47 <copumpkin> > reverse [1..5]
20:27:47 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
20:27:48 <aavogt> you can reverse lists of anything
20:27:48 <lambdabot>   [5,4,3,2,1]
20:27:58 <ivanm> @hoogle [a] -> [a]
20:27:59 <lambdabot> Prelude cycle :: [a] -> [a]
20:27:59 <lambdabot> Prelude init :: [a] -> [a]
20:27:59 <lambdabot> Prelude reverse :: [a] -> [a]
20:28:12 <copumpkin> in fact, by its type, reverse is simply unable to care about what's inside the list
20:28:13 <hgolden> ivanm, dobblego: thanks for replies. the old-darcs has the examples.
20:28:17 <medfly> :t flip
20:28:18 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
20:28:18 <aavogt> > reverse [error "tolkad",error "otherError"]
20:28:19 <lambdabot>   [* Exception: otherError
20:28:30 <ivanm> aavogt: heh
20:28:30 -preflex(n=preflex@95-88-118-220-dynip.superkabel.de)- ivanm: you have 1 new message. '/msg preflex messages' to read it.
20:28:37 <ivanm> tolkad: kindly fuck off
20:28:57 <kmc> whait
20:28:57 -preflex(n=preflex@95-88-118-220-dynip.superkabel.de)- kmc: you have 1 new message. '/msg preflex messages' to read it.
20:29:16 <copumpkin> @where ops
20:29:17 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver monochrom
20:29:27 <kmc> wait what's this gimmick
20:29:27 <absentia> what is preflex?
20:29:30 <kmc> a bot
20:29:37 <absentia>  /ignore preflex all
20:29:41 <absentia> bye bye bot.
20:29:42 <copumpkin> it's a useful bot
20:29:45 <medfly> preflex, seen lambdabot
20:29:45 -preflex(n=preflex@95-88-118-220-dynip.superkabel.de)- lambdabot was last seen on #haskell 29 seconds ago, saying: shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver monochrom
20:29:48 <copumpkin> it's just being abused
20:29:53 <medfly> oh, it's using notices for everything
20:29:58 <medfly> why is it doing that?
20:30:00 <ivanm> copumpkin: _all_ the bots are being abused
20:30:14 <ivanm> medfly: because tolkad is being an absolute dickhead
20:30:22 <ivanm> dobblego: oh, btw, happy Australia Day ;-)
20:30:27 <dobblego> tolkad, please stop being silly, thanks
20:30:28 <tolkad> sorry : ( I just like playing with bots
20:30:29 <dobblego> ivanm, cheers
20:30:39 <copumpkin> tolkad: play with them in private
20:30:42 <Cale> What?
20:30:42 -preflex(n=preflex@95-88-118-220-dynip.superkabel.de)- Cale: you have 1 new message. '/msg preflex messages' to read it.
20:31:01 <medfly> hehe, I imagine what the messages must be like
20:31:04 <Cale> It's using notices for messages because that's what bots are supposed to use
20:31:10 <medfly> kmc, omg!!!! you are so cool!
20:31:10 <medfly> Cale, I love you!
20:31:16 <ivanm> Cale: the individual who people accused of being a troll but we talked to anyway is abusing the bots
20:31:32 <aavogt> ivanm: how do you know?
20:31:37 <Cale> tolkad: Don't do that.
20:31:48 <ivanm> aavogt: because I got a message from preflex before from him saying "test"
20:32:02 <medfly> aavogt, he's a likely suspect because he was definitely doing that before.
20:32:03 <ivanm> and preflex suddenly had a message for lambdabot from someone before...
20:32:06 <kmc>     Australians all let us rejoice,
20:32:07 <tolkad> ivanm: I didn't do it in this channel but I'll stop now that I've been asked
20:32:11 <kmc>     For we are young and free;
20:32:16 <kmc>     We've golden soil and wealth for toil;
20:32:20 <kmc>     Our home is girt by sea;
20:32:26 <tolkad> I was wondering what would happen if I left a message for everyone in the channel
20:32:26 <copumpkin> kmc: you're australian?
20:32:31 <kmc> copumpkin, no
20:32:34 <medfly> lol
20:33:30 <Cale> tolkad: Everyone would be annoyed with you?
20:33:38 <Cale> tolkad: It's not hard to figure that one out.
20:33:40 <copumpkin> it seems pretty obvious
20:33:40 <copumpkin> yeah
20:33:51 <tolkad> Cale: well, I only did a few people
20:34:04 <tolkad> Cale: anyway, I'll find something more intersting to do
20:34:06 <aavogt> I guess you'll never know
20:34:16 <kmc> let's all get high
20:34:22 <copumpkin> it seems like preflex could /notice only the intended recipient of a message, at least
20:34:28 <absentia> I /msg'd the thing and it told me that I had no message.. so I ignored it.
20:34:29 <shapr> Wait, what?
20:34:43 <shapr> What's going on?
20:34:43 <copumpkin> @yow
20:34:44 <lambdabot> Couldn't find fortune file
20:34:47 <copumpkin> :(
20:34:54 <kmc> @protontorpedo
20:34:54 <lambdabot> how does haskell do with large systems?
20:35:02 <copumpkin> @keal
20:35:02 <lambdabot> you need a Zh function in Haskell
20:35:07 <medfly> hehe
20:35:09 <kmc> @keal
20:35:10 <copumpkin> #?
20:35:10 <medfly> @vixen
20:35:10 <lambdabot> they dumbified you
20:35:10 <lambdabot> so, what made you want to message me?
20:35:11 <lunabot>  luna: parse error on input `]'
20:35:14 <dolio> We were all having a big party, but we stopped when we heard you coming.
20:35:18 <ivanm> preflex: seen malcolmw
20:35:19 -preflex(n=preflex@95-88-118-220-dynip.superkabel.de)- malcolmw was last seen on #haskell 6 days, 12 hours, 56 minutes and 29 seconds ago, saying: quicksilver: no, no, surely I must understand less than you... :-)
20:35:27 <kmc> preflex, seen preflex
20:35:28 -preflex(n=preflex@95-88-118-220-dynip.superkabel.de)- what
20:35:29 <medfly> @nixon
20:35:30 <lambdabot> I brought myself down. I impeached myself by resigning.
20:35:35 <kmc> @. elite nixon
20:35:36 <lambdabot> a Man w|-|0 |-|A$ N3\/Er Loz+ hi/\/\s3lf In 4 C4uzE 8IGg3R 7h4n hIm5eLF HA$ /\/\i$$ed oNe 0f LIphe'5 M0UNtainTop exPERIEn(Ez. 0n1y IN 1OsINg |-|iM53|F doEz he fIND hIMSe1f. ONLy TH3n DoEz |-|3
20:35:36 <lambdabot> dizcoVeR a|L thE |a+3NT StrEN9thz h3 nev3r kn3\/\/ he HAD 4nD wHICH OTHer\/\/ISe W0ULD |-|av3 r3M4INed dOR/\/\4n+.
20:35:42 <medfly> @. vixen nixon
20:35:42 <lambdabot> yup
20:35:47 <kmc> @. vixen nixon
20:35:47 <lambdabot> Bollox!
20:35:51 <kmc> @. vixen nixon
20:35:51 <lambdabot> so, what made you want to message me?
20:35:56 <copumpkin> ahem, spam
20:35:57 <copumpkin> :P
20:36:02 <shapr> Hey, bot traffic to #haskell-blah !
20:36:06 <medfly> lambdabot is in #haskell-blah too
20:36:56 <kmc> spam spam spam spam
20:42:45 <tolkad> How does hpaste work?
20:43:05 <ivanm> pretty much the same as every other pasting site
20:43:15 <ivanm> except that it's written with happstack IIRC and it's aimed at haskell code
20:43:20 <tolkad> but it's suppost to do something with the bot, how does it work with the bot?
20:43:26 <kmc> it doesn't
20:43:28 <aavogt> there's a link to a repo at the bottom of the page
20:43:30 <ivanm> there used to be an hpaste bot
20:43:42 <ivanm> which would announce new pastes
20:43:43 <ivanm> but it no longer seems to exist
20:44:03 <mm_freak> is there a monadic version of Data.Map.alter?
20:44:19 <mm_freak> i need to modify state from it
20:44:20 <aavogt> @type M.alter
20:44:20 <ivanm> @hoogle alter
20:44:21 <lambdabot> forall a k. (Ord k) => (Maybe a -> Maybe a) -> k -> M.Map k a -> M.Map k a
20:44:21 <lambdabot> Data.IntMap alter :: (Maybe a -> Maybe a) -> Int -> IntMap a -> IntMap a
20:44:21 <lambdabot> Data.Map alter :: Ord k => (Maybe a -> Maybe a) -> k -> Map k a -> Map k a
20:44:21 <lambdabot> Control.Applicative class Applicative f => Alternative f
20:44:30 <ivanm> mm_freak: what do you mean by "monadic version"?
20:44:31 <mtnviewmark> hiho tibbe - things are going slower with the haddock project than I had hoped...
20:45:04 <mm_freak> ivanm: i have a computation in State (Map X Y)
20:45:18 <ivanm> mm_freak: use modify?
20:45:20 <aavogt> @type modify
20:45:21 <ivanm> @hoogle modify
20:45:21 <lambdabot> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
20:45:21 <lambdabot> Control.Monad.State.Class modify :: MonadState s m => (s -> s) -> m ()
20:45:21 <lambdabot> System.IO.Error modifyIOError :: (IOError -> IOError) -> IO a -> IO a
20:45:21 <lambdabot> Data.IORef modifyIORef :: IORef a -> (a -> a) -> IO ()
20:45:25 <ivanm> aavogt: heh
20:45:45 <mm_freak> i use M.alter on the state, but that function may or may not change more than the addressed element of the map
20:46:08 <mm_freak> or better:  i'd like it to be that way
20:46:25 <aavogt> the alternative is if you have a function   (a -> IO a), is to see if you can re-write it as   (IO (a -> a)), which can indirectly be passed to M.alter
20:47:13 <mm_freak> aavogt: the state to be modified is not contained in the alter function's parameters
20:47:21 <mm_freak> it only gets Maybe a -> Maybe a
20:47:46 <mm_freak> but i'd need something like:  Monad m => Maybe a -> m (Maybe a)
20:47:52 <mm_freak> seems like i need to write one myself
20:48:30 <aavogt> I don't believe that M.Map exposes enough implementation for that to be any more efficient than a lookup + insert
20:48:51 <mm_freak> aavogt: you're probably right
20:48:53 <Gracenotes> mm_freak: ...return?
20:48:55 <aavogt> err, you could also have a delete
20:49:06 <mm_freak> Gracenotes: ?
20:50:30 <tolkad_> ? test
20:50:30 -preflex(n=preflex@95-88-118-220-dynip.superkabel.de)- tolkad_: you have 1 new message. '/msg preflex messages' to read it.
20:50:38 <tolkad> hmm
20:52:49 <nettok> ?nixon
20:52:50 <lambdabot> It is necessary for me to establish a winner image. Therefore, I have to beat somebody.
21:01:33 <interferon> how can i print a double to two decimals of precision?
21:02:02 <blackh> interferon: showFloat (Just 2) n "" from Numeric module
21:02:19 <mm_freak> interferon: honestly i'd use printf
21:02:30 <mm_freak> > printf "%0.2f" 3.5
21:02:31 <lambdabot>   Ambiguous type variable `a' in the constraints:
21:02:31 <lambdabot>    `Text.Printf.PrintfType ...
21:02:36 <mm_freak> > printf "%0.2f" (3.5 :: Double)
21:02:37 <lambdabot>   Ambiguous type variable `a' in the constraints:
21:02:37 <lambdabot>    `GHC.Show.Show a'
21:02:37 <lambdabot>      a...
21:02:41 <mm_freak> > printf "%0.2f" (3.5 :: Double) :: String
21:02:42 <lambdabot>   "3.50"
21:02:48 <mm_freak> > printf "%0.2f" (3.759 :: Double) :: String
21:02:48 <aavogt> > printf "%0.2f" (3::Int) :: String
21:02:49 <lambdabot>   "3.76"
21:02:49 <lambdabot>   "* Exception: Printf.printf: bad argument
21:02:57 <aavogt> that's a runtime error
21:03:23 <mm_freak> yes
21:03:42 <interferon> would prefer typed things to runtime errors
21:03:42 <mm_freak> showFloat is safer
21:03:51 <interferon> looking up showFloat now
21:03:53 <interferon> thanks for the help!
21:04:14 <mm_freak> :t showInt
21:04:15 <lambdabot> forall a. (Integral a) => a -> String -> String
21:04:18 <aavogt> there are alternatives to Text.Printf in a similar style that do typechecking
21:04:34 <domiel> Hi! I'm trying to do a global install of the bluetile wm on my ubuntu box, I've gone through most of the steps listed on http://www.webupd8.org/2009/12/how-to-install-bluetile-in-ubuntu.html but I've had to modify them a bit to do a system wide install as the website's instructions are for a local user install.
21:04:35 <aavogt> (at compile time)
21:05:07 <domiel> I need some help in getting cabal-install working with a system wide setup
21:05:24 <domiel> is anyone here an expert with cabal?
21:05:47 <aavogt> cabal install --global blah
21:06:05 <aavogt> but that doesn't make it easy to uninstall
21:06:19 <domiel> yes... tried that... but if I do a cabal update it insists on putting everything in my home directory
21:06:24 <domiel> which is not what I want
21:06:48 <aavogt> you can remove those files afterwards
21:07:02 <aavogt> if you correctly do a --global install afterwards
21:07:07 <domiel> (uninstall is taken care of by using checkinstall)
21:07:32 <domiel> ok... I shall try that... brb
21:08:18 <interferon> :t Numeric.showFloat
21:08:19 <lambdabot> forall a. (RealFloat a) => a -> String -> String
21:08:25 <interferon> what is that string argument?
21:08:52 <aavogt> > showFloat 1.2
21:08:53 <lambdabot>   ""->
21:08:53 <lambdabot>    "1.2"
21:08:53 <lambdabot>  "a"->
21:08:53 <lambdabot>    "1.2a"
21:08:53 <lambdabot>  "aa"->
21:08:55 <lambdabot> [4 @more lines]
21:09:29 <interferon> ?
21:10:18 <aavogt> interferon: if you take the String to append as a function argument, that means you can append a string to the result without having to walk through the String again
21:10:58 <domiel> aavogt: thankyou so very much... I had assumed that once cabal-install was installed globally it would do everything globally from then onwads... but you know what they same about assume :)
21:11:01 <aavogt> so the append is O(1), rather than O(n) where n is the length of the string you generate
21:12:05 <aavogt> domiel: no problem. Good to see it worked. But what do you mean by "but you know what they same about assume"
21:12:12 <interferon> so showFloat doesn't let you choose precision?
21:12:21 <interferon> i just want to output a currency value without resorting to printf
21:12:22 <aavogt> @type showFFloat
21:12:23 <lambdabot> forall a. (RealFloat a) => Maybe Int -> a -> String -> String
21:13:11 <interferon> there we go
21:13:11 <interferon> thanks!
21:13:28 <domiel> aavogt: it's a saying we have (in Australia at the very least, though I suspect it's British in origin): Assume makes an ass out of u and me
21:14:21 <pikhq> domiel: I'm pretty sure that's a ubiquitous English expression.
21:14:30 <domiel> that's what I'd suspected
21:14:38 <aavogt> oh, I know that one. It makes more sense without the apparent typo same vs. say
21:14:39 <pikhq> Certainly heard it often in the US.
21:15:21 <domiel> ahh... yes, sorry I only just noticed that one
21:15:32 <domiel> I need a new keyboard :-P
21:16:23 <domiel> pebkac indeed!
21:16:43 <absentia> PEBKAC!
21:17:04 <domiel> or, if you prefer: it's a Layer 8 issue!
21:18:05 <ddarius> domiel: OSI?
21:19:30 <ddarius> So Agda people, how do you guys decide between using (x:A)(y:B) -> C and (x:A) -> (y:B) -> C in general?
21:19:44 <domiel> yes: layer 8 = (l)user
21:20:13 <domiel> sorry... spent too many years in support/admin roles
21:20:13 <copumpkin> ddarius: I typically start adding arrows after the first non-implicit parameter and keep going
21:20:42 <c_wraith> copumpkin curry, if you will
21:22:35 <ddarius> copumpkin: In Ulf's thesis he has: (A B : Set)(C : B -> Set) -> ((x : B) -> C x) -> (g : A -> B)(x : A) -> C (g x) which seems like a fairly ad-hoc mixture of the conventions.
21:23:07 <copumpkin> maybe if he considers things to be related he'll omit the arrow? not really sure
21:29:28 <dolio> ddarius: That type names all and only the things that need to be used later in the type.
21:29:39 <dolio> And never uses (x : A) -> (y : B) -> ...
21:35:50 <dolio> If you wanted to eliminate more arrows, it'd have to be...
21:36:24 <dolio> (A B : Set) (C : B -> Set) (f : (x : B) -> C x) (g : A -> B) (x : A) -> C (g x)
21:36:38 <dolio> Which names that one parameter, but never uses it.
21:37:50 <pastorn> is dat sum agda?
21:38:00 <kmc> ja
21:38:13 <pastorn> agda => page 15, and it will be free
21:38:45 <Cale> How do you distinguish between type-level application and multiple parameters like that?
21:39:09 <Cale> Or am I missing something?
21:39:41 <dolio> Multiple parameters like that always have the form (x : T).
21:40:20 <dolio> Unless there's a forall. You can do "forall A B C D -> ...", in which case the name list is delimited by the forall and the arrow.
21:41:07 <Cale> Is there a point to it?
21:41:12 <dolio> To which?
21:41:25 <Cale> To not just consistently always using ->
21:41:47 <dolio> The forall syntax is nicer than (A : _) (B : _) (C : _) (D : _) ->
21:43:07 <Cale> I mean, why not always curry as much as possible?
21:43:16 <kmc> it's curried either way
21:43:29 <dolio> It's just an abbreviation of syntax.
21:43:51 <dolio> (x : A) (y : B) -> C means the same thing as (x : A) -> (y : B) -> C
21:44:04 <Cale> okay
21:44:34 <pastorn> dolio, Cale: there actually is a #agda here on freenode...
21:44:46 <Cale> But I'd be tempted to read the first as the type-level application of (x : A) to (y : B), even though that's not what it means.
21:45:04 <dolio> And it's arguably closer to something like 'Pi x : A. Pi y : B. C'.
21:46:26 <dolio> (x : A) isn't an expression, though.
21:46:30 <dobblego> edwardk, your solution on the interview question contains a mistake; include is not a haskell keyword :)
21:46:34 <dolio> Somewhat unfortunately.
21:48:25 --- mode: ChanServ set +o mauke
21:48:25 --- mode: mauke set +b *!*@unaffiliated/tolkad
21:50:25 --- mode: mauke set -o mauke
21:55:27 <SubStack> This seems quite odd. I can do typeOf sin in ghci with no problems, but when I load a file with the same code from ghci, it complains about ambiguous type variables.
21:55:38 <SubStack> with typeOf from Data.Typeable
21:55:49 <aavogt> > typeOf sin
21:55:50 <lambdabot>   Double -> Double
21:55:58 <Cale> SubStack: yeah, ghci has extended default rules turned on
21:56:25 <aavogt> > typeOf (sin :: Floating a => a -> a)
21:56:26 <lambdabot>   Double -> Double
21:56:27 <Cale> It tries more aggressively to resolve things to monomorphic types
21:56:32 <SubStack> nifty
21:56:49 <SubStack> aha, I see the -X for it
21:57:18 <SubStack> yay, it works :D
21:57:20 <SubStack> Cale++
21:58:22 <BMeph> "Ambiguous Type Variable is Ambiguous." ;p
21:59:14 <medfly> > typeOf typeOf
21:59:15 <lambdabot>   Ambiguous type variable `a' in the constraint:
21:59:15 <lambdabot>    `Data.Typeable.Typeable a...
21:59:30 <SubStack> o_O
21:59:43 <kmc> :t typeOf
21:59:44 <lambdabot> forall a. (Typeable a) => a -> TypeRep
21:59:46 <medfly> :)
21:59:56 <kmc> > typeOf (typeOf :: () -> TypeRef)
21:59:57 <kmc> > typeOf (typeOf :: () -> TypeRep)
21:59:57 <lambdabot>   Not in scope: type constructor or class `TypeRef'
21:59:58 <lambdabot>   () -> TypeRep
22:00:12 <kmc> Data.Typeable only works for monomorphic types
22:00:34 <pikhq> The runtime typing stuff tends to...
22:00:46 <kmc> madness?
22:00:50 <aavogt> it would be neat if it could handle polymorphic types
22:01:00 <pikhq> aavogt: Harder to do, though.
22:01:09 <pikhq> Particularly with Dynamic.
22:01:17 <kmc> let's just get some dependent types and be done with it
22:01:31 * copumpkin coughs
22:01:33 <pikhq> That'd do it.
22:01:39 <kmc> hi copumpkin
22:02:17 <copumpkin> HELLO THAR
22:02:42 <dolio> How do dependent types help you with that?
22:03:04 <aavogt> @quote panacea
22:03:04 <lambdabot> No quotes match. Have you considered trying to match wits with a rutabaga?
22:03:05 <copumpkin> you need independent types
22:03:13 <pikhq> dolio: Dependent types are MAGIC!
22:03:14 <kmc> codependent types
22:03:16 <aavogt> we have independent types
22:03:22 <copumpkin> not independent enough
22:06:23 <SubStack> http://okmij.org/ftp/Haskell/types.html#de-typechecker <-- batshit insane
22:06:49 <kmc> 1.21 gigaolegs
22:06:58 <aavogt> SubStack: basically djinn at the type level or something
22:07:08 <hydo> Ugh... hdbc-postgresql is broken for 6.12... that'll teach me to not back up every last package my app depends on before upgrading ghc.
22:07:38 <pikhq> SubStack: It's Oleg Haskell code.
22:07:43 <pikhq> It's almost guaranteed to be insane.
22:08:16 <aavogt> @djinn undefined::(b -> c) -> (a -> b) -> a -> c
22:08:17 <lambdabot> Cannot parse command
22:08:24 <aavogt> @djinn undefined :: (b -> c) -> (a -> b) -> a -> c
22:08:24 <lambdabot> Cannot parse command
22:08:25 <SubStack> as soon as my mind gets out of a blender hopefully I can put a sliver of this to use
22:08:32 <aavogt> @djinn f :: (b -> c) -> (a -> b) -> a -> c
22:08:32 <lambdabot> Cannot parse command
22:08:39 <medfly> @djinn (b -> c) -> (a -> b) -> a -> c
22:08:40 <lambdabot> f a b c = a (b c)
22:08:41 <kmc> ah you're on the blender trip
22:09:08 <SubStack> I only just learned about TypeReps this week
22:09:12 <kmc> "i dreamt i was a liquid dripping down an infinitely tall refrigerator"
22:09:54 <aavogt> weee
22:11:51 <SubStack> I'm researching the feasability of writing a function that composes functions of some given type signature out of a pool of other functions
22:12:00 <SubStack> amazingly this seems possible
22:12:16 <kmc> :O
22:12:31 <mauke> @djinn (a -> b) -> a -> (b -> c) -> c
22:12:31 <lambdabot> f a b c = c (a b)
22:13:25 <SubStack> like djinn, but useful-er
22:13:37 <aavogt> well how do you know which ones?
22:14:36 <medfly> like hoogle?
22:14:39 <SubStack> the ones that get me to the desired type signature, of course!
22:14:46 <SubStack> without cycles
22:15:51 <aavogt> class Composes a b where o :: a -> b; instance (Composes a b, Composes b c) => Composes a c where o = o . o
22:16:32 <copumpkin> SubStack: I've toyed with that idea before
22:16:33 <aavogt> I don't think that works nicely with type inference though
22:16:44 <aavogt> sort of like Data.Convertible
22:16:50 <aavogt> @hackage convertible
22:16:50 <lambdabot> http://hackage.haskell.org/package/convertible
22:17:00 <medfly> in the end we'd write programs just using type signatures!
22:17:11 <medfly> (or not)
22:18:59 <aavogt> that's not very convenient, hence all the omonomorphism in H98
22:19:34 <aavogt> monomorphism*
22:19:58 <SubStack> omnomnomorphism
22:20:40 <aavogt> arrow from cookie to mouth
22:20:46 <jrockway> wow, i just realized i can use ghci to work on my xmonad config :)
22:26:55 <kmc> yeah it's wonderful
22:26:55 <kmc> XMonad is a library for writing window managers :)
22:27:38 <SubStack> with good defaults
22:27:44 <jrockway> dunno about that :)
22:27:52 <jrockway> i need my M-x :)
22:29:39 <SubStack> even if I can only do monomorphic types with the extended default rules it should be plenty good enough
22:29:46 <SubStack> for this particular purpose
22:29:51 <solrize> ben lippmeier's dissertation turns out to be one of the better anti-haskell rants out there ;-)
22:31:48 <kmc> don't worry
22:31:50 <kmc> we have soul power
22:33:14 <ivanm> solrize: which dissertation is this?
22:34:29 <solrize> http://cs.anu.edu.au/people/Ben.Lippmeier/project/thesis/thesis-lippmeier-sub.pdf
22:35:31 <aavogt> @quote disciple
22:35:31 <lambdabot> No quotes match. You speak an infinite deal of nothing
22:36:28 <ivanm> how is it an anti-haskell rant?
22:37:12 <aavogt> it says that haskell may not be the answer
22:37:13 <solrize> semi j/k.  a lot of it is about the contortions in haskell code to get around the lack of a mutable store
22:37:30 <ivanm> :o
22:37:37 <ivanm> what is a "store"?
22:37:43 <medfly> it's where you buy things
22:37:44 <solrize> lol
22:37:50 <kmc> came here to post this
22:38:09 <ivanm> yeah, wikipedia just has those and ammo dumps
22:38:31 <solrize> see the first page of the thesis (p. 17 of the pdf)
22:38:54 <medfly> man, you can write a thesis about that?
22:38:59 <ivanm> I did
22:39:02 <solrize> it's a good thesis
22:39:03 <ivanm> it doesn't actually say what it is
22:39:37 <Hugglesworth> is it possible to send key presses to a subprocess (eg: C-c)?
22:39:40 <ivanm> it doesn't seem to have a wikipedia entry; ergo it musn't be an interesting/useful data structure! :p
22:39:44 <Lycurgus> (gasp) aavogt, bite your tongue!
22:39:46 <ivanm> Hugglesworth: you mean #xmonad?
22:39:51 <Hugglesworth> I might
22:39:56 <ivanm> then ask there!
22:40:33 <Hugglesworth> no, I don't
22:40:45 <ivanm> oh, wait, sorry, I get what you're asking now
22:40:54 <kmc> on UNIX, control-C sends SIGINT
22:41:11 <ivanm> kmc: there was someone asking about that before on #xmonad, and no-one answered
22:41:16 <ivanm> so I got confused :s
22:41:23 <Lycurgus> it is if the process owning the keyboard input passes it
22:41:25 <ivanm> Hugglesworth: you mean you're fork'ing a console command?
22:41:29 <ivanm> and want to be able to kill it?
22:41:31 <Hugglesworth> indeed
22:41:37 <Hugglesworth> mplayer to be exact
22:41:37 <ivanm> then no, I don't think so sorry
22:42:12 <kmc> if you do a low level UNIX process spawn (fork() then exec()) you can control what fd is open for the spawned process's stdin
22:42:20 <kmc> and make it a pipe you can send shit down
22:42:23 <Lycurgus> *process chain
22:42:33 <kmc> mplayer supports various methods of remote ctrl anyway
22:47:10 <Hugglesworth> so, no way to send keypresses to a subcommand at all then?
22:47:26 <ivanm> Hugglesworth: probably not
22:47:30 <ivanm> since you've forked it
22:47:39 <ivanm> it's being run in a separate thread, etc.
22:47:51 <kmc> do what i said
22:48:02 <solrize> can't you run arbitrary ioctls and get the characters out of the raw tty port?
22:48:17 <copumpkin> you can write to their stdin
22:48:26 <dons> Hugglesworth: you can pass commands to subprocess
22:48:40 <dons> via pipes or shared memory or other mechanisms
22:48:48 <pastorn> Hugglesworth: a friend of mine did that for mplayer... he made small next-track, pause/play-buttons etc
22:48:57 <dons> hmp3 works like tihs
22:48:58 <solrize> http://haskell.org/ghc/docs/latest/html/libraries/unix-2.4.0.0/System-Posix-Terminal.html
22:48:59 <pastorn> all displayed as a task-bar-thingy in wmii
22:49:12 <dons> reinterpreting commands to the haskell program, and passing them on to sub processes as needed
22:49:36 <Hugglesworth> it is
22:51:42 <Hugglesworth> I've tried sending stuff down stdin but it's not doing anything.
22:52:52 <ivanm> preflex: seen dcoutts
22:52:53 -preflex(n=preflex@95-88-118-220-dynip.superkabel.de)- dcoutts was last seen on #ghc 18 hours, 13 minutes and 45 seconds ago, saying: * dcoutts disappears
22:53:39 <Hugglesworth> and I'm not seeing how to use Posix-Terminal
22:54:45 <ivanm> preflex: seen sinelaw
22:54:46 -preflex(n=preflex@95-88-118-220-dynip.superkabel.de)- sinelaw was last seen on ##java 9 hours, 25 minutes and 54 seconds ago, saying: does java allow passing functions as arguments to other functions, with un-circumventable guarantees on the type of the function being passed?
22:55:18 <ivanm> @tell sinelaw I think I know the problem with multiple calls to Dot: atm it's waiting for the process to finish and then getting the _entire_ String out
22:55:19 <lambdabot> Consider it noted.
22:55:42 <ivanm> @tell sinelaw as such, it has to wait for dot to finish, then parse the big huge String :s
22:55:43 <lambdabot> Consider it noted.
23:02:14 <SubStack> oh excellent, there is a Data.PolyTypeable
23:02:36 <SubStack> yoink
23:05:33 <SubStack> oleg++ for being amazing
23:08:51 <Wooga> how do i make match-all pattern in case expresion ?
23:08:57 <SubStack> _
23:08:58 <kmc> _
23:09:03 <lispy|web> case f of _ -> "Everything"
23:09:20 <kmc> _ is the wildcard pattern; it matches anything and binds no new names
23:09:44 <Wooga> ah, thanks, just realized why _ wasn't worked for me: it was incorrect identation
23:09:46 <lispy|web> > case 1 of x -> "Everything"; _ -> "Anything"
23:09:47 <lambdabot>   "Everything"
23:10:26 <lispy|web> > case 1 of undefined -> "Everything"; _ -> "Anything"
23:10:27 <lambdabot>   "Everything"
23:10:40 <lispy|web> Why does that even work?
23:10:54 <kmc> because undefined is just another local variable
23:10:55 <lispy|web> oh
23:10:58 <lispy|web> Heh, yeah
23:11:10 <kmc> > case 1 of x | x == undefined -> "Everything"; _ -> "Anything"
23:11:11 <lambdabot>   "* Exception: Prelude.undefined
23:11:15 <lispy|web> > case 1 of undefined -> show undefined
23:11:16 <lambdabot>   "1"
23:11:48 <lispy|web> :t \x -> case 1 of undefined -> show x
23:11:49 <lambdabot> forall a. (Show a) => a -> String
23:12:12 <lispy|web> :t \x -> case 1 of undefined -> show undefined
23:12:13 <lambdabot> forall t. t -> String
23:12:14 <Wooga> also, can i somehow use multiple pattern to single match? something that might look like: case name of "Simon" || "Phil" -> putStrLn "Haskel is great!"
23:12:49 <kmc> Wooga, you can name the body with let or where and refer to it in multiple case arms
23:13:06 <lispy|web> Yeah, that's probably the cleanest way
23:13:10 <Wooga> thanks
23:13:21 <kmc> or you can use a guard with (||) ... but that's not pattern matching at all
23:13:23 <aavogt> case name of _ | name `elem` ["Simon","Phil"] -> ...
23:13:41 <lispy|web> You could also define isFoo, where isFoo "Simon" = True; isFoo "Phil" = True; isFoo _ = False
23:14:00 <kmc> @src elem
23:14:00 <lambdabot> elem x    =  any (== x)
23:15:20 <lispy|web> We should use java-esqe names like java.lang.util.atLeastOneElementHasProperty ;)
23:16:14 <kmc> you can call it Data.List.any if you like ;P
23:17:17 <lispy|web> I like that any is concise :)
23:17:48 <kmc> man, i'm loving these guillemets
23:17:53 <indil> Can someone here answer a Parsec question? My Parsec parser isn't consuming all the chars in the input String, and succeeds anyway.
23:18:07 <kmc> indil, because Parsec parsers needn't parse the whole input
23:18:21 <kmc> the parser eof will match the end of stream
23:18:24 <aavogt> eatItAll blah = blah <* eof
23:18:41 <kmc> :t (<* Text.ParserCombinators.Parsec.eof)
23:18:42 <lambdabot> forall a t s u (m :: * -> *). (Text.Parsec.Prim.Stream s m t, Show t) => Text.Parsec.Prim.ParsecT s u m a -> Text.Parsec.Prim.ParsecT s u m a
23:18:55 <Wooga> sorry, where and how should i place let expression to use it in case expression: http://paste2.org/p/632748 ?
23:19:00 <indil> Ah, I'll try that. Thanks!
23:19:20 <Wooga> using it like this, i am getting func.hs:7:9: parse error (possibly incorrect indentation)
23:19:24 <indil> kmc++, aavogt++
23:19:28 <aavogt> Wooga: that's not allowed
23:19:51 <aavogt> let x = y in case ... of ... -> x
23:20:21 <aavogt> alternatively:     case ... of  _ -> let x = y in x
23:20:24 <Wooga> aavogt: thanks!
23:24:04 <lispy|web> Wooga: you might like the interact function
23:24:07 <lispy|web> :t interact
23:24:08 <lambdabot> (String -> String) -> IO ()
23:25:53 <SubStack> > typeRepArgs $ typeOf sin
23:25:54 <lambdabot>   [Double,Double]
23:26:45 <SubStack> :t polyTypeOf
23:26:46 <lambdabot> Not in scope: `polyTypeOf'
23:28:24 <lispy|web> > typeRepArgs $ typeOf show
23:28:25 <lambdabot>   [(),[Char]]
23:28:54 <lispy|web> ?botsnack
23:28:54 <lambdabot> :)
23:28:58 <lispy|web> hmm
23:29:01 <medfly> @botsnack
23:29:01 <lambdabot> :)
23:29:01 <lunabot>  :o
23:30:41 <SubStack> now if only there were a way to get a list of all the classes that a type has instances for
23:31:46 <aavogt> SubStack: probably can be done through the ghc-api
23:32:53 * SubStack checks it out
23:32:55 <lispy|web> oh no, the logs are gone?
23:34:34 <al-maisan> Good morning!
23:36:20 <merehap> Good midnight!
23:36:53 <lispy|web> So, the URL in the subject lies about the log files!
23:37:04 <lispy|web> do we have a backup log?
23:38:55 <theorbtwo> @src concat
23:38:56 <lambdabot> concat = foldr (++) []
23:39:34 <theorbtwo> Gah, almost had it.
23:40:22 <lispy|web> :t foldr (++) []
23:40:23 <lambdabot> forall a. [[a]] -> [a]
23:40:27 <aavogt> > foldl (++) [] ["abc","def","ghi"]
23:40:27 <lispy|web> :t foldl (++) []
23:40:28 <lambdabot>   "abcdefghi"
23:40:28 <lambdabot> forall a. [[a]] -> [a]
23:41:02 * lispy|web tries to understand why foldr should be the default implementation
23:41:11 <lispy|web> I guess because it's lazier?
23:41:46 <aavogt> lispy|web: step through the evaluation
23:42:05 <aavogt> > foldl (++) [] [x,y,z]
23:42:06 <lambdabot>   Couldn't match expected type `[a]'
23:42:06 <lambdabot>         against inferred type `SimpleRef...
23:42:14 <aavogt> > foldl (f) [] [x,y,z] :: Expr
23:42:15 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
23:42:15 <lambdabot>         against inferred ...
23:42:27 <joevandyk> HAY!!!!!
23:42:29 <aavogt> > foldl (f) w [x,y,z] :: Expr
23:42:30 <lambdabot>   f (f (f w x) y) z
23:42:32 <joevandyk> I have this type:
23:42:34 <joevandyk> data Person = Person { name :: String, age :: Int }
23:42:50 <joevandyk> is this the best way to write this method?
23:42:51 <joevandyk> display_person :: Person -> String
23:42:51 <joevandyk> display_person p@Person {} = name p ++ " is " ++ show (age p) ++ " years old!"
23:43:29 <lispy|web> joevandyk: hi
23:43:33 <mauke> the @Person{} part is completely redundant
23:43:44 <joevandyk> i couldn't figure out a better way :/
23:44:09 <joevandyk> oh, i guess i can just do display_person p = ...
23:44:11 <lispy|web> It's 100% completely and totally redundant in its entirety (and fully)
23:44:11 <joevandyk> huh
23:44:18 <theorbtwo> Just display_person p = ... should ... exactly.
23:44:35 <joevandyk> well that makes a whole lot more sense
23:45:24 <mauke> display_person p = printf "%s is %d years old!" (name p) (age p)
23:45:41 <mauke> (needs more liftM2)
23:46:15 <aavogt> or,   display_person Person { name = n, age = a } = unwords [n,"is",show a,"years old!"]
23:46:48 <theorbtwo> :t printf
23:46:50 <lambdabot> forall r. (PrintfType r) => String -> r
23:47:08 <lispy|web> or, display_person _ = "Steve is 17 years old!" -- warning, this version may contain bugs
23:47:23 <theorbtwo> That's... er... opaque.
23:47:49 <aavogt> yay polymorphism
23:48:07 <theorbtwo> I was wondering if printf was in the IO monad, and actually printed, or a pure function that just formatted... and that really doesn't tell me.  WTF is a PrintfType?
23:48:15 <mauke> theorbtwo: it's both
23:49:15 <theorbtwo> mauke: That seems like a bad thing.
23:53:22 <ivanm> theorbtwo: printf is _magic_!
23:53:49 <joevandyk> is printf useful?  the docs say that it can throw an exception at runtime.
23:53:58 <joevandyk> does that mean i should stay away from it if possible?
23:54:15 <ivanm> it can be more useful than manually trying to do it
23:54:23 <ivanm> as long as you're careful
23:54:47 <ivanm> there's a version on hacakge that uses TH and thus does checking at build time to avoid those kinds of problems
23:55:01 <ivanm> and IIRC mauke has his own custom variant, though I have no idea what it does
23:55:15 <aavogt> @hackage xformat
23:55:15 <lambdabot> http://hackage.haskell.org/package/xformat
23:55:30 <ivanm> aavogt: yeah, I couldn't work out how to use that
23:55:34 <theorbtwo> What are you supposed to do if you want to format to a string, while inside the IO monad?
23:55:36 <mauke> right now it fails to build on windows :-/
23:55:49 <joevandyk> what does "the format descriptor is well-typed" mean?
23:56:22 <mauke> ivanm: my version fixes several bugs in the standard version and adds perl's v flag
23:56:25 <mauke> and %b
23:56:30 <ivanm> what's this v flag?
23:56:45 <ivanm> and why aren't those bug fixes in the standard version then?
23:56:47 <mauke> lets you treat a string as a vector of integers
23:56:48 <aavogt> joevandyk: it means if you have too many or too few arguments or some of the wrong type, then you will get a compile error
23:56:59 <augur> D:
23:57:01 <augur> D: D: D:
23:57:06 <augur> who's presented at conferences befor?
23:57:06 <ivanm> mauke: uhhhh, what?
23:57:07 <augur> anyone?
23:57:10 <mauke> ivanm: maybe they are by now
23:57:16 <ivanm> augur: I have
23:57:23 <ivanm> about a week ago! ;-)
23:57:25 <mauke> I sent patches to the maintainer and nothing happened for several months
23:57:27 <augur> were you nervous? D:
23:57:31 <theorbtwo> Hm.  %v was a mistake in perl.  I'm not sure why you'd want to import it into haskell.
23:57:32 <ivanm> reasonably
23:57:39 <ivanm> but I've got to go to dinner now; I'll be around later
23:57:39 <mauke> theorbtwo: what's wrong with it?
23:57:40 <augur> im considering submitting a paper to ESSLLI's student session
23:57:44 <augur> a second one, rather
23:58:01 <theorbtwo> mauke: It tends to be far more confusing then it is useful.
23:58:10 <mauke> how is it confusing?
23:58:41 <augur> ok night guys
23:58:45 <theorbtwo> mauke: It conflates a string with a list of integers.
23:59:04 <mauke> well, that's what it is
23:59:08 <theorbtwo> Most of the time, if you want to have a list of integers, you should really just go ahead and do that.
