00:00:23 <DekuNut> On windows, I want to change the directory the getAppUserDataDirectory produces, I've tried changing several environment variables to see if it'll effect it, but no cigar
00:00:31 <DekuNut> Any help on how this function works on windows?
00:02:38 <imperialenforcer> My guess is going into that file that getAppUserDataDirectory lives in and changing it manually
00:03:13 <DekuNut> Well that's not exactly... a great sounding solution
00:03:31 <DekuNut> I'll go look at it anyway
00:03:48 <imperialenforcer> Yeah... I can't really think of another way
00:03:51 <imperialenforcer> sorry
00:03:57 <DekuNut> No worries, thanks
00:05:01 <merehap> say I have a function of type [String] -> [String], is there any way to feed IO input into the function lazily, line-by-line (and then output lazily)?
00:05:29 <ski> @type interact
00:05:30 <lambdabot> (String -> String) -> IO ()
00:05:31 <merehap> or would this inevitably break referential transparency or determinism?
00:05:35 <ski> merehap : ^
00:05:43 <ski> combine with
00:05:45 <ski> @type lines
00:05:47 <lambdabot> String -> [String]
00:05:48 <merehap> oops, guess I should have remembered that...
00:05:48 <ski> @type unlines
00:05:49 <lambdabot> [String] -> String
00:05:58 <merehap> @src interact
00:05:59 <lambdabot> interact f = do s <- getContents; putStr (f s)
00:06:20 <merehap> thanks
00:07:57 <ski> @let onLines :: ([String] -> [String]) -> (String -> String); onLines f = unlines . f . lines
00:07:59 <lambdabot>  Defined.
00:08:21 <merehap> simple enough
00:08:23 <ski> @let perLine :: (String -> String) -> (String -> String); perLine f = onLines (map f)
00:08:25 <lambdabot>  Defined.
00:08:39 <ski> @type interact . perLine
00:08:40 <lambdabot> (String -> String) -> IO ()
00:08:43 <ski> @type interact . onLines
00:08:44 <lambdabot> ([String] -> [String]) -> IO ()
00:09:46 <ski> @wiki TV#IO
00:09:47 <lambdabot> http://www.haskell.org/haskellwiki/TV#IO
00:10:23 <merehap> I'll be using it to alternately read from a file or from the console, I do love the flexibility that lazy evaluation gives in this regard, something which would require more complex architecture in almost all other languages...
00:11:23 <ski> @type hInteract
00:11:25 <lambdabot> Not in scope: `hInteract'
00:13:44 <merehap> found that in System.IO.Utils, exactly what I need
00:17:31 <tomoj> why am I getting "no instance for (Random UUID)" when there is supposed to be one?
00:17:45 <tomoj> I have the latest Data.UUID it seems
00:31:30 <tomoj> I can see the instance for (Random UUID) in the source cabal downloaded for uuid, but ghci's :i doesn't reveal it and I get an error trying to generate a UUID with System.Random.random. what could be wrong?
00:32:25 <dcoutts> tomoj: is the package built and registered? Are you looking in the right module?
00:33:01 <tomoj> dcoutts: I'm not sure how to check
00:33:13 <tomoj> maybe there is something I should have read about cabal
00:33:19 <tomoj> I just did 'cabal install uuid'
00:33:42 <tomoj> that lets me do :m + Data.UUID alright, and I can see some of UUID's instances, but not Random
00:34:10 <dcoutts> tomoj: ah, do you have the Random module in scope too?
00:34:22 <dcoutts> :info will only list instances that are visible
00:34:25 <tomoj> I have it import qualified
00:35:01 <tomoj> I just changed both to unqualified imports, same problem
00:35:09 <dcoutts> tomoj: I mean in ghci
00:35:21 <dcoutts> is the Random class in scope in ghci
00:36:04 <tomoj> oh, hmm
00:36:28 <tomoj> I can do :i Random and see that there are instances for Random Int, etc, but not Random UUID
00:36:32 <tomoj> does that mean it's "in scope"?
00:38:01 <dcoutts> tomoj: hmm, dunno then. It works for me.
00:38:17 <tomoj> just from 'cabal install uuid' ?
00:38:34 <dcoutts> tomoj: yes, then :m + Data.UUID Random and :info Random
00:38:40 <dcoutts> shows instance Random UUID -- Defined in uuid-1.1.1:Data.UUID.Internal
00:39:03 <dcoutts> similarly if I do :info UUID
00:40:13 <tomoj> oh, that works
00:40:26 <tomoj> I was doing :m + System.Random
00:40:44 <tomoj> well, :m + Data.UUID System.Random
00:40:51 <tomoj> thanks
00:41:08 <c_wraith> bah.  Why does TH give no error messages when it breaks compilation of the rest of the file?
00:41:39 <dcoutts> tomoj: so what was wrong before? you only had one of those two modules in scope in ghci?
00:42:07 <merehap> c_wraith: TH was made with the PHP philosophy in mind
00:42:31 <merehap> clearly
00:43:17 <tomoj> dcoutts: no, I had both
00:43:31 <tomoj> but they were Data.UUID and System.Random, not Data.UUID and Random
00:43:44 <tomoj> which let me see a crippled version of Random I guess
00:43:54 <tomoj> or a crippled version of UUID, I dunno
00:44:40 <dcoutts> tomoj: oh it shouldn't matter if it's Random or System.Random, Random is just an old H98 alias
00:44:57 <Baughn> Wait, wait, the PRNG discussion is /still/ going?
00:45:11 <tomoj> dcoutts: well, seems to matter for me :(
00:45:15 <tomoj> guess I have something set up wrong
00:45:25 <dcoutts> hmm, it's exactly the same here
00:46:31 <dcoutts> tomoj: do you have more than one version of the package random installed? ghc-pkg list random
00:47:50 <tomoj> dcoutts: yes, that's it
00:48:31 <mmaruseacph2> speaking of PRNGs , which one is the fastest and most reliable in haskell?
00:49:27 <Botje> "most reliable" ?
00:49:31 <c_wraith> I don't know why, but these TH splices only work at the end of the file.  That doesn't sound right.
00:50:08 <Baughn> mmaruseacph2: How secure do you need it?
00:50:09 <mmaruseacph2> i need to get somewhere near 10k numbers
00:50:13 <dcoutts> tomoj: ok, that explains things. module Random using the original instance of the random package. When you built uuid, it built against the other random package so only provides instances for that one. Hence you do observe a difference between Random and System.Random because they're being provided by different versions of the package random.
00:50:14 <mmaruseacph2> only for monte carlo
00:50:36 <mmaruseacph2> not cryptography
00:50:42 <Baughn> mmaruseacph2: Eh. Use the Twister then, I guess
00:50:54 <Baughn> http://hackage.haskell.org/package/mersenne-random
00:51:33 <mmaruseacph2> and if i wanted cryptography?
00:51:45 <tomoj> ok, so what's wrong with this? https://gist.github.com/c456377f660507a46078
00:51:50 <Baughn> mmaruseacph2: http://hackage.haskell.org/packages/archive/AES/0.2.5/doc/html/Codec-Crypto-AES-Random.html
00:52:01 <mmaruseacph2> thanks
00:52:16 <Baughn> mmaruseacph2: With the aber that I haven't had a real cryptographer look at it, and there may be errors in my reasoning
00:52:17 <tomoj> I get this error https://gist.github.com/afeb025ab31cf34fb3d7
00:53:09 <mmaruseacph2> and if i am on a machine with no access to /dev/random?
00:53:27 <Botje> tomoj: try putting the :: inside the ()
00:53:36 <Baughn> mmaruseacph2: Then submit a patch to make it work on that kind of OS.
00:53:50 <mmaruseacph2> ok, will try working on it:)
00:53:51 <mmaruseacph2> thanks
00:54:25 <tomoj> Botje: ah, thanks
00:54:32 <tomoj> syntax still confuses me
00:54:42 <Botje> yeah, :: in do context always trips me up
00:54:43 <Baughn> mmaruseacph2: The generator is, frankly, somewhat half-assed. It /could/ be much better, and avoid all those caveats.
00:54:52 <Baughn> But it'll do for making random numbers.
00:55:08 <mmaruseacph2> i see
00:55:30 <mmaruseacph2> well, i finished reading wolfram's book and i intented to use a cellular automata for a rng
00:55:47 <Baughn> ..eek
00:55:51 <mmaruseacph2> in the past i've tried to get some random numbers in haskell but it was very slow (maybe one of my mistakes)
00:55:53 <Baughn> Might as well use Pi
00:56:03 <mmaruseacph2> now i want to test something
00:56:04 <Baughn> mmaruseacph2: System.Random /is/ very slow, yes
00:56:24 <mmaruseacph2> so, no System.Random if in need for speed
00:56:28 <mmaruseacph2> a lesson learned:)
00:56:29 <Baughn> Right.
00:56:51 <Baughn> No CSPRNG if in need of speed either. Mersenne Twister is probably best.
00:57:57 <mmaruseacph2> then this is what i will use
00:58:00 <mmaruseacph2> thanks
01:06:22 <tensorpudding> what is denotational semantics?
01:07:42 <Beelsebob> tensorpudding: it's a method of writing semantics that relies on you writing down mathematical functions which describe the behavior
01:07:47 <Feuerbach> tensorpudding: it's when the semantics of some expression is defined by mapping it to some set of values
01:08:11 <tensorpudding> that sounds a bit abstract
01:08:13 <Feuerbach> I mean, set of expressions is mapped to set of values
01:08:14 <Beelsebob> i.e. unlike operational semantics, it doesn't rely on laying down what all the steps should look like
01:08:31 <amigoo> is Haskell user friendly?  Can a person without any background in programming learn haskell?
01:08:44 <Milo-> yes
01:08:45 <Beelsebob> amigoo: I know several people who learned haskell as their first language
01:08:47 <Beelsebob> it's 100% possible
01:09:06 <amigoo> is it user friendly?
01:09:08 <Beelsebob> tensorpudding: it is – that's in fact the idea – to abstract semantics away from anything machine related at all
01:09:11 <Milo-> no
01:09:12 <amigoo> like for debugging and stuff
01:09:13 <Beelsebob> amigoo: define "user friendly"
01:09:16 <tomoj> why can't I make an instance for Random (UUID, UUID) ?
01:09:44 <Beelsebob> tomoj: because there's already an instance for Random a, Radom b => Random (a,b)?
01:10:11 <Beelsebob> and also, becasue (UUID,UUID) is not a new type or a data declaration
01:10:49 <Beelsebob> amigoo: no computer programming language is "user friendly" – they all, at the end of the day are you, describing how a computer should act
01:10:57 <Beelsebob> Haskell has more safety nets than most
01:11:05 <Beelsebob> so it's less common to get weird bugs
01:11:22 <Beelsebob> it's more common however to get the compiler saying "hey, that's wrong"
01:11:34 <Beelsebob> and it's relatively common for it's version of "hey, that's wrong" to be fairly cryptic
01:11:57 <tomoj> hmm, why do I get "No instance for (Random (UUID, UUID))" if there is an instance for Random a, Random b => Random (a,b)
01:12:12 <Beelsebob> having said that... this community is known for helping people who ask questions like "what does this cryptic error message mean"
01:12:33 <Beelsebob> tomoj: I was guessing that said instance existed – if you get that error, it probably doesn't – define that
01:12:50 <tomoj> oh, ok
01:13:10 <tomoj> oh, I see what I was doing wrong
01:13:10 <Beelsebob> (or search hackage for the micropackage that defines it)
01:13:12 <tomoj> thanks
01:13:15 <glguy> You need an extension to define: instance Random (UUID,UUID)
01:13:28 <Beelsebob> but if you are definining it, you're probably doin it rong anyway
01:13:50 <tomoj> I was looking for Random a, Random b => Random (a,b) as you thought
01:13:55 * hackagebot upload: hxt 8.4.1 - A collection of tools for processing XML with Haskell. (UweSchmidt)
01:14:26 <tomoj> except, that doesn't work either :(
01:14:38 <Beelsebob> it may be getting towards pastebin time
01:14:43 <Beelsebob> because I'm out of guesses
01:15:42 <tomoj> Beelsebob: https://gist.github.com/a0fcba79493899002b44
01:15:43 <glguy> UUIDs don't really make sense in the Random typeclass
01:15:51 <Beelsebob> they don't?
01:16:10 <tomoj> parse error on the ',' in "Random (a, b)"
01:16:23 <glguy> When do you specify bounds for a random UUID?
01:16:31 <Beelsebob> tomoj: well, first off, you're declaring Random for (a,b)
01:16:37 <Beelsebob> so you shouldn't be mentioning :: UUID in there
01:16:44 <Beelsebob> because it's of type a, and type b
01:16:52 <tomoj> oh, of course
01:16:56 <ski> tomoj : do you have an `instance Random UUID' ?
01:17:07 <tomoj> ski: yep
01:17:19 <ski> then it sounds strange
01:17:33 <tomoj> glguy: UUID does this
01:18:54 <Beelsebob> tomoj: http://paste.lisp.org/display/93273
01:19:34 <glguy> Beelsebob: you don't discard the final generator when implementing random
01:19:38 <ski> tomoj : though that code at github looks strange, too
01:19:43 <glguy> random :: (RandomGen g) => g -> (a, g)
01:19:47 <Beelsebob> oh is it?
01:19:55 <Beelsebob> duh, ofc it is
01:19:57 <Beelsebob> >.<
01:20:20 <Beelsebob> http://paste.lisp.org/display/93273#1 <-- sane version then
01:20:21 <Beelsebob> >.<
01:20:50 <glguy> The minimum definition of Random is random and randomR
01:21:00 <Beelsebob> orly?
01:21:22 <ski> @type randomR
01:21:23 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> (a, g)
01:22:53 <Beelsebob> http://paste.lisp.org/display/93273#2 <-- there you go then
01:23:47 * ski wonders whether it is sensible to have `randomR' in the `Random' class
01:24:23 <Twey> ski: Probably we should have another class…
01:24:31 <Twey> Who was it who said that each typeclass should have only one method?
01:24:54 <Beelsebob> I dunno, but I can very much buy that
01:25:15 <ski> @quote method
01:25:16 <lambdabot> ghc says: No explicit method nor default method
01:25:17 <dibblego> I can't
01:25:18 <lambdabot> dibblego: You have 1 new message. '/msg lambdabot @messages' to read it.
01:25:31 <ski> @quote method
01:25:32 <lambdabot> augustss says: Haskell already has enterprise monads; there is a fail method.
01:25:52 <ray> @quote enterprise
01:25:53 <lambdabot> DRMacIver says: I dread to think what category theory would look like after the software engineering world had got their grubby paws on it. Enterprisevariant functors. Commutative UML diagrams.
01:27:12 <tomoj> Beelsebob: thanks
01:31:48 <tensorpudding> ugh
01:32:36 <Twey> (one required method, that is)
01:32:48 <tensorpudding> was looking for a book on constructive analysis, found a book titled Constructive Analysis, it turned out it was about epistemological methodology
01:34:25 <tensorpudding> which i'm still not convinced has any meaning at all
01:40:18 <ski> tensorpudding : Bishop and Bridges ?
01:51:26 <kamatsu> hm, so, i'm wondering
01:51:36 <kamatsu> @pl ellipseM m a b c d e = m >>= \m' -> ellipse m' a b c d e
01:51:36 <lambdabot> ellipseM = (. ((((((flip .) . flip) .) . flip) .) . flip . flip ellipse)) . (.) . (.) . (.) . (.) . (>>=)
01:51:40 <kamatsu> aw
01:51:49 <kamatsu> is there a more sensible way to do what i'm trying to?
01:52:01 <kamatsu> ah, got it
01:52:05 <kamatsu> oh wait, no i don't
01:55:04 <kamatsu> surely there is a cleaner way to do this?
01:59:10 <merehap> @let ellipseM m = (m >>= \m' -> ellipse m')
01:59:11 <lambdabot>  <local>:10:27: Not in scope: `ellipse'
01:59:24 <kamatsu> i tried that
01:59:31 <kamatsu> i'll let you know what it says
01:59:33 <merehap> why doesn't currying work?
02:00:29 <kamatsu> huh
02:00:30 <kamatsu> it works
02:00:37 <kamatsu> wonder what I was doing wrong before
02:00:39 <kamatsu> oh well, thanks all
02:01:03 <merehap> ah, the ghosts in the type checker
02:01:06 <merehap> :)
02:01:12 <kamatsu> haha
02:01:50 <quicksilver> merehap: partial application, not currying ;)
02:02:19 <merehap> one day I'll get them straight :)
02:02:44 <Phyx-> quicksilver: yeah, I think that's one of the biggest misunderstood terms
02:03:03 * quicksilver ceasily striving to correct misapprehensions and abuse of language.
02:03:14 <quicksilver> hmm
02:03:20 <quicksilver> s/ceasily/ceaselessly/
02:03:27 <quicksilver> EINSUFFICIENTCAFFEINE
02:04:13 <Phyx-> i slept straight through my alarm clock...
02:04:39 <merehap> come to think of it, I can't think of a good reason why I would mix them up other than seeing many people before me mix them up
02:04:49 <merehap> I wonder how the mix up chain started...
02:06:18 <yaxu2> I wonder if someone could clear up a confusion...  "sequence" evaluates a list of monads into a monad of lists
02:06:26 <yaxu2> but a list is a monad, right?
02:06:43 <merehap> yeah
02:07:05 <merehap> you could, for example, sequence a list of lists
02:07:24 <yaxu2> so is there a more general sequence that can operate on any monad of one type containing any monad of another type?
02:07:48 * EnglishGent hands quicksilver an emergency cup of coffee
02:07:54 <kamatsu> hm, not sure, why don't you hoogle?
02:08:06 <merehap> that's beyond me, coffee or not
02:08:06 <yaxu2> kamatsu: ha, good idea one sec
02:09:53 <idnar> an emergency cup of monads?
02:10:09 <Jafet> @hoogle (Monad m) => (a -> a -> a) -> m a -> a
02:10:10 <lambdabot> Data.Foldable foldl1 :: Foldable t => (a -> a -> a) -> t a -> a
02:10:10 <lambdabot> Data.Foldable foldr1 :: Foldable t => (a -> a -> a) -> t a -> a
02:10:10 <lambdabot> Prelude foldl1 :: (a -> a -> a) -> [a] -> a
02:10:24 <yaxu2> hoogle seems to be pointing me at Data.Traversable, I'll look into that, thanks for the helpful stock response kamatsu :)
02:10:38 <idnar> @pl ellipseM m = (m >>= \m' -> ellipse m')
02:10:39 <lambdabot> ellipseM = (ellipse =<<)
02:11:06 <yaxu2> @hoogle (Monad ma, Monad mb) => ma (mb a) -> mb (ma a)
02:11:07 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
02:11:07 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
02:11:07 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
02:11:26 <merehap> it seems that's almost there...
02:11:48 <idnar> (m >>= \m' -> ellipse m') is just m >>= ellipse
02:12:10 <quicksilver> yaxu2: yes, it's called traverse
02:12:13 <merehap> by the monad identity laws, i think
02:12:23 <quicksilver> yaxu2: and it's not exactly what you asked for but it's the best answer there is.
02:12:31 <quicksilver> :t traverse
02:12:32 <lambdabot> Not in scope: `traverse'
02:12:35 <idnar> merehap: well, it's more fundamental than that \x -> f x is just f
02:12:41 <quicksilver> :t Data.Traversable.traverse
02:12:42 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
02:12:53 <Jafet> Very kind.
02:13:00 <idnar> @pl \x -> f x
02:13:00 <quicksilver> hmm. that's not the one I wanted actually.
02:13:01 <lambdabot> f
02:13:01 <EnglishGent> has anyone here got any experience with type-level programming? I'm trying to get something from the MonadReader to work - and it doesnt for reasons I dont understand
02:13:16 <merehap> idnar: true
02:13:33 <kamatsu> idnar: thanks!
02:13:56 <yaxu2> :t Data.Traversable.sequenceA
02:13:57 <kamatsu> idnar: how did i miss that >_>
02:13:57 <lambdabot> forall (t :: * -> *) (f :: * -> *) a. (Data.Traversable.Traversable t, Applicative f) => t (f a) -> f (t a)
02:14:00 <quicksilver> yaxu2: yes, that's the one
02:14:07 <kamatsu> yaxu2: yup
02:14:10 <quicksilver> (that's the most general one that is like what you asked for)
02:14:21 <quicksilver> All monads are applicative, so that half is exactly what you wanted.
02:14:27 <quicksilver> not all monads are traversable, but lists are.
02:14:54 <yaxu2> ok, I think my monad should be traversable
02:14:54 <kamatsu> why do you need traversable? couldn't you do a version for Functor t?
02:14:58 <merehap> does that mean that you can't have something as general as what was originally requested?
02:15:01 <quicksilver> kamatsu: no.
02:15:13 <quicksilver> kamatsu: Traversable turns out to be exactly what you need, to do this.
02:15:43 <kamatsu> quicksilver: hm, let me take a look at it, but i don't doubt you're right
02:15:46 <quicksilver> merehap: it does mean that, yes.
02:15:59 <quicksilver> merehap: there is no general "m (n a) -> n (m a)" for two arbitrary monads m and  n
02:16:05 <yaxu2> thanks a lot quicksilver
02:16:12 <quicksilver> merehap: you might call it a commutation law, if there was ;)
02:16:18 <merehap> *reads up on traversables*
02:16:23 <quicksilver> but there always is, if m is Traversable.
02:17:44 <Phyx-> test
02:17:49 <Phyx-> > "test"
02:17:50 <lambdabot>   "test"
02:18:00 <Phyx-> ok, still connected
02:18:12 <shambler_> hehe
02:18:25 <idnar> Phyx-: nope, you're disconnected, we can't read anything you're typing
02:18:39 <shambler_> > (\"ping" -> "pong") ping
02:18:40 <lambdabot>   Not in scope: `ping'
02:18:41 <Phyx-> idnar: oh noes!
02:18:45 <shambler_> > (\"ping" -> "pong") "ping"
02:18:46 <lambdabot>   "pong"
02:19:09 <idnar> > let ping = pong; pong = ping in ping
02:19:13 <lambdabot>   mueval-core: Time limit exceeded
02:19:21 <idnar> oh noes, ping timeout!
02:19:23 <ski> > (\(\"ping" -> "pong") -> \"pong" -> "ping") (\"ping" -> "pong") "pong"
02:19:23 * idnar runs away
02:19:24 <lambdabot>   <no location info>: Parse error in pattern
02:19:26 <merehap> :)
02:19:48 <yaxu2> So I need to make my monad Foldable in order to make it Traversable?
02:19:53 <idnar> ski: you can't pattern match on a function :P
02:20:08 <ski> idnar : i know .. but one should be able to
02:20:11 <merehap> apparently traversables are the foldable functors
02:20:11 <idnar> haha
02:20:20 <merehap> yaxu2: so yes
02:20:38 <yaxu2> righto
02:20:48 <Phyx-> oh oh
02:20:51 <Phyx-> my lag meter is going up
02:20:57 <ski> (specifically the pattern `(\"ping" -> "pong")' would apply the input to `"ping"' and match the result on `"pong"')
02:21:02 <Phyx-> [Lag: 12.71]
02:21:07 <kamatsu> Phyx-: seems hi
02:21:10 <merehap> > canPalin "fold a functor"
02:21:11 <kamatsu> *high
02:21:11 <lambdabot>   "You betcha!"
02:21:24 <Phyx-> kamatsu: torrents
02:21:30 <ski> (i.e. what can be written as `($ "ping") -> "pong"'
02:21:33 <kamatsu> > canPalin "coerce types"
02:21:34 <lambdabot>   "You betcha!"
02:21:44 * yaxu2 feels his brain stretch
02:21:45 <kamatsu> aw, it's not magic
02:21:51 <Phyx-> my connection seems to always be slow the first couple of days after i'm back from vacation
02:21:51 <ski> , (\(($ "ping") -> "pong") -> \"pong" -> "ping") (\"ping" -> "pong") "pong"
02:21:53 <lunabot>  "ping"
02:22:22 <merehap> kamatsu: what, you expect Palin to have good type integrity?
02:22:24 <idnar> is that a view pattern?
02:22:27 <ski> yes
02:22:27 <idnar> or whatever it's called
02:22:30 <Veinor> 05:20:34 < ski> (specifically the pattern `(\"ping" -> "pong")' would apply the input to `"ping"' and match the result on `"pong"')
02:22:32 <idnar> ah
02:22:36 <Veinor> There's a way to do this, but I forget what it is.
02:22:40 <ski> (also called "transformational pattern")
02:22:47 <idnar> Veinor: I think ski just gave it
02:22:53 <Veinor> but in a nicer way.
02:23:01 <Veinor> it's one of the new things in 6.12
02:23:03 <kamatsu> merehap: well, i guess not
02:23:19 <ski> Veinor : with what syntax ?
02:23:37 <kamatsu> > canPalin "solve p=np"
02:23:38 <lambdabot>   "You betcha!"
02:23:38 <quicksilver> merehap: no, traversable is more than a foldable functor
02:23:39 <Veinor> pattern guards?
02:23:51 <Veinor> http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html
02:24:00 <ski> using pattern guards would be uglier, not nicer
02:24:16 <Veinor> bah
02:24:38 <merehap> quicksilver: you mean I will need to put in more than a cursory skim over that article on haskellwiki in order to fully understand traversables?
02:25:02 <quicksilver> merehap: A foldable lets you collect all the 'contents' out of a structure and combine them together
02:25:16 <quicksilver> merehap: or, in more concrete term, a foldable is a structure which has a "list of elements"
02:25:16 <merehap> quicksilver: I'm on a roll for propagating misformation tonight, and I'm not sure if you can keep up :)
02:25:30 <quicksilver> (defining "toList" is a very concrete, but sufficent, way to instance Foldable)
02:25:57 <quicksilver> merehap: a Traversable not only lets you collect elements, but it lets you "traverse" the structure, "doing something" (i.e. runnign an action) at each point and stuffing the result back in
02:26:09 <quicksilver> so it has a way to "rebuild" a new structure with the same shape as the one you started.
02:26:11 <merehap> ah, that makes for a convenient explanation
02:26:35 <quicksilver> Functors, of course, let you rebuild a new structure with the same shape but don't let you run an action at each place
02:26:39 <quicksilver> only a pure function
02:26:48 <quicksilver> at first glance, it's not really clear why Functor isn't enough.
02:27:00 <quicksilver> your first guess would be that it is, but it turns out not to be.
02:27:10 <quicksilver> that's why this class used to be called FunctorM
02:27:19 <ski> @type fmap
02:27:19 <quicksilver> (it's a version of Functor which lets you run an action at each point).
02:27:20 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
02:27:21 <ski> @type Data.Traversable.traverse
02:27:22 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
02:27:46 <quicksilver> an in fact, all the Functors which you expect this to work for, it does.
02:27:58 <quicksilver> bascially for all Functors which a "just a structure" - like a list, or a tree, etc.
02:28:00 <ski> @type Data.Traversable.sequenceA
02:28:01 <lambdabot> forall (t :: * -> *) (f :: * -> *) a. (Data.Traversable.Traversable t, Applicative f) => t (f a) -> f (t a)
02:28:09 <idnar> hmm
02:28:10 <ski> @type \f -> Data.Traversable.sequenceA . fmap f
02:28:12 <lambdabot> forall (t :: * -> *) (f :: * -> *) a a1. (Data.Traversable.Traversable t, Applicative f) => (a1 -> f a) -> t a1 -> f (t a)
02:28:38 <merehap> see, that's why I love this channel, it is impossible to not learn something on any given day
02:29:18 <ski> (cf. the latter type with that of `traverse')
02:29:22 <Phyx-> though not always relevant what you learn...
02:29:42 <Phyx-> for instance, wasn't really relevant learning yesterday that oblivion has a 1 minute speedrun was it?
02:30:09 <merehap> what goes beyond being "just a structure", then?
02:30:24 <merehap> Phyx-: thanks, that's now 2 things for today
02:30:28 <Botje> a one minute speedrun? O_o
02:30:44 <merehap> Phyx-: one of them more useful than the other, I'll let you guess which is which :)
02:30:52 <Botje> i know the trick with the brushes to get into the final area quickly
02:31:05 <quicksilver> merehap: well "IO a" is a functor which isn't traversable.
02:31:25 <merehap> oh, I see what you were saying
02:31:37 <merehap> yes, there are clearly functors that aren't traversable
02:32:01 <quicksilver> of course, (IO a) isn't foldable either.
02:32:31 <merehap> yes, that is what I was wondering about, non-traversable foldables
02:32:31 <quicksilver> I don't have any good examples of a Foldable Functor which isn't Traversable.
02:32:35 <quicksilver> I have some bad examples
02:32:37 <merehap> ah :)
02:32:39 <quicksilver> like Data.Set
02:32:55 <quicksilver> but arguably that's because of stupid reasons about Ord contexts
02:32:59 <merehap> why is that a bad example? that makes sense
02:33:02 <ski> (to be a pedant, `IO' is functor, not `IO a')
02:33:02 <quicksilver> you can make a guess for it being morally traversable.
02:33:31 <quicksilver> ski: (IO a is a functor in the same sense that f(x) is a function; this is a standard abuse which only annoys type theorists :P)
02:33:33 <merehap> I'm guessing that goes back to ZFC
02:33:55 <ski> quicksilver : `f(x)' is not a function (unless `f' is higher-order) ;)
02:33:57 <quicksilver> well the "good reason" that Data.Set isn't a Functor is that fmap might collapse two points into one point
02:34:22 <quicksilver> ski: it is, though, if "x" is indefinite, rather than any particular value or variable.
02:34:37 <ski> `x' is always a particular value
02:34:53 <quicksilver> you may say that, but accepted mathematical (abuse of) notation disagrees with you.
02:35:06 <Phyx-> ski: isn't f(x) always a function when f has an arity > 1
02:35:10 <ski> *nod*, i disagree with it too, :)
02:35:39 * Phyx- is missing some context
02:35:47 * Phyx- sits in a corner with his lollypop
02:36:16 <merehap> yes, but does your lollypop compose?
02:36:22 <ski> (Phyx- : take `f : |R^2 -> |R', then `f(x)' is not a function (unless you represent real numbers by functions))
02:36:29 <Phyx-> merehap: no it decomposes
02:36:54 * ski . o O ( into a "lolly" and a "pop" ? )
02:36:56 <merehap> as long as you can bring it back to math, that's A OK
02:37:39 * ski . o O ( .. or possibly into a "negation" and a "parallel or" )
02:37:41 <Phyx-> ski: yeah
02:38:00 <Phyx-> ski: yes, the lolly is reusable, the pop not to much
02:38:02 <Phyx-> abstraction
02:38:31 <merehap> hm, is there a standard higher order function called blend?
02:38:55 <quicksilver> no, although there is a 3D modeller called blender
02:39:03 <merehap> I'm just hoping I get to say, "Yes, but does it blend" in a fully mathematical context...
02:39:27 <merehap> hm, well I'll have to make one then
02:40:06 <merehap> @let blend = flip (.)
02:40:07 <lambdabot>  Defined.
02:40:51 <Phyx-> oh i just figured out it's my bday today
02:41:03 <merehap> I think that matches the definition of decompose too
02:41:23 <merehap> merry birthday!
02:42:02 <Phyx-> haha, thanks :)
02:42:20 <Phyx-> ski: 23
02:42:51 <Botje> you old fart!
02:42:55 <Phyx-> :O
02:43:01 <Botje> then again, i turned 23 two months ago :)
02:43:12 <Phyx-> lol
02:43:16 <merehap> you're already past your prime haskelling period, too sad :(
02:43:25 <Phyx-> guess we old farts have to stick together :P
02:43:29 <ski> why ? `23' is prime !
02:43:48 <Botje> if you haven't written a monad tutorial before 25, your chance at fame and fortune is gone :)
02:43:52 <Phyx-> which means, i'm still in it, last year :P
02:43:52 <merehap> oops :)
02:43:59 <Vq> merehap: whats the primary haskelling period? 7?
02:44:38 <merehap> I was just going off of mathematicians and when they are most likely to write their most impactful papers
02:44:49 <merehap> I happened to use poor word choice
02:45:48 <Phyx-> oh noes, my mp3 player died
02:46:10 <Phyx-> well, I have proof your invariant doesn't always hold
02:46:14 <Phyx-> both Simons are > 23
02:46:16 <Phyx-> :P
02:46:17 * ski wants a sid player ..
02:46:36 <merehap> @let lollipop = flip (map "yummy")
02:46:37 <lambdabot>  <local>:11:21:
02:46:37 <lambdabot>      Couldn't match expected type `a -> b'
02:46:37 <lambdabot>             agains...
02:46:49 <merehap> @let lollipop = flip map "yummy"
02:46:50 <lambdabot>  Defined.
02:47:10 <merehap> > canPalin (blend lollipop)
02:47:11 <lambdabot>   "You betcha!"
02:47:23 <merehap> it blends!
02:47:55 <Phyx-> > canPalin (win us presidancy?)
02:47:56 <lambdabot>   Not in scope: `win'Not in scope: `us'Not in scope: `presidancy'Not in scope...
02:47:57 <merehap> Phyx-: perhaps you are in luck
02:48:16 <Phyx-> > canPalin ("win us presidancy?")
02:48:17 <lambdabot>   "You betcha!"
02:48:20 <quicksilver> merehap: but can you turn a lollipop into a fish?
02:48:21 <Phyx-> :O
02:48:22 <merehap> ugh
02:48:31 <quicksilver> > lollipop (chr.(`div`2).ord)
02:48:32 <lambdabot>   "<:66<"
02:48:36 <Phyx-> quicksilver: yes, unsafeCoerce :P
02:48:38 * quicksilver wins.
02:48:40 <merehap> ha!
02:48:48 <merehap> most impressive
02:49:00 <yaxu2> hm, I don't understand how Traversable can be based upon Foldable, if Foldable throws away shape
02:50:05 <quicksilver> it's not really based on it
02:50:12 <quicksilver> in fact, it doesn't use any of the methods of it
02:50:22 <quicksilver> but it's true that all Traversables are definitely foldable
02:50:32 <quicksilver> that's the point of the relationship
02:50:37 <yaxu2> Ah, so I'm defining this foldr to make my monad traversable, but it's not actually going to be used?
02:50:45 <yaxu2> when I call sequenceA?
02:51:21 <Phyx-> i just looked through my window, and saw two BMWs and a Aston Martin parked outside my window, and first thing through my mind "I can be gone in 60secons"
02:51:24 <Phyx-> heh
02:51:55 <quicksilver> yaxu2: right, it's not going to be used.
02:52:32 <Phyx-> why does foldable through away structure? It doesn't match my intuition of what a fold does then
02:52:35 <yaxu2> ok, that makes sense then.  of course I'll probably use foldr down the line
02:52:54 <ski> @type foldr
02:52:56 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
02:52:58 <merehap> Phyx-: they came for your birthday, relax
02:53:03 <yaxu2> Phyx-: I guess by turning a list into a single value, you're changing its shape
02:53:07 <ski> no list structure in the result type
02:53:34 <Phyx-> ooohhh that kind of fold
02:53:54 <Phyx-> wtf am i thinking
02:53:56 <Phyx-> all folds do that
02:54:01 <Phyx-> omg.... I need coffee
02:54:03 <Phyx-> merehap: :)
02:55:05 <Phyx-> well, you can have shape preserving folds though, like when using a Fold algebra you could clone the shape for instance
02:55:49 <ski> how do you mean ?
02:56:03 <master_o1_master> hi, how can I compute the gcd of a list of integers? My solution (http://ideone.com/9tM8MDRO) takes to long for huge input
02:56:05 <merehap> > foldr (:) [] [1..10]
02:56:05 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
02:56:14 <Phyx-> like that yeah
02:57:37 <yaxu2> oh, lots of trouble importing both Data.List and Data.Foldable
02:57:41 <Phyx-> > foldr (\a b->a*a:b) [] [1..10]
02:57:43 <lambdabot>   [1,4,9,16,25,36,49,64,81,100]
02:58:06 <Phyx-> also a fold, modifying the elements and preserving shape, more like a map in this case
02:58:06 * yaxu2 qualifies them
02:58:12 <ski>   map f = foldr ((:) . f)
02:58:17 * yaxu2 tries not to type as I think..
02:58:30 <merehap> @let gcdX xs = foldl1' gcd xs
02:58:31 <lambdabot>  Defined.
02:58:46 <merehap> gcdX [3,9,24,30]
02:58:51 <merehap> > gcdX [3,9,24,30]
02:58:52 <lambdabot>   3
02:59:05 <Phyx-> > gcdX []
02:59:06 <lambdabot>   * Exception: Prelude.foldl1': empty list
02:59:11 <Phyx-> > gcdX [0]
02:59:12 <lambdabot>   0
02:59:33 <merehap> master_o1_master: that should be decently efficient
02:59:34 <ski> > 0 `gcd` 0
02:59:35 <lambdabot>   * Exception: Prelude.gcd: gcd 0 0 is undefined
02:59:42 * ski thinks that should be `0'
03:00:02 <pozic> master_o1_master: you get linear space behaviour with the way you programmed it.
03:00:13 <merehap> @let gcdN xs = foldl' 0 gcd xs
03:00:14 <lambdabot>  Defined.
03:00:22 <merehap> gcdN []
03:00:27 <merehap> > gcdN []
03:00:28 <lambdabot>   No instance for (GHC.Num.Num ((a -> a -> a) -> b -> a -> a -> a))
03:00:28 <lambdabot>    arisin...
03:00:42 <ski> @undefine
03:00:51 <ski> @let gcdN = foldl' gcd 0
03:00:52 <lambdabot>  Defined.
03:00:52 <pozic> master_o1_master: what you want to do is compute the gcd of two elements to get a gcd. Then use that gcd with the third element and so on.
03:01:03 <ski> > gcdN []
03:01:04 <lambdabot>   0
03:01:10 <master_o1_master> pozic: well I know that :) but I didn't know how to make it in haskell
03:01:19 <pozic> master_o1_master: the code you have written is correct, but the process it generates is a slow process.
03:01:29 <pozic> master_o1_master: although for small lists it should not matter.
03:01:34 <ski> master_o1_master : you can code an explicit accumulator, too, if you prefer
03:01:46 <pozic> master_o1_master: it might also be possible that you can write a faster gcdN by not using gcd.
03:01:56 <pozic> master_o1_master: there might be some mathematical trick to do that.
03:02:21 <master_o1_master> pozic: I don't think that I have to optimize gcd
03:02:24 <pozic> There almost surely is, in fact.
03:02:32 <merehap> master_o1_master: try a divide and conquer strategy
03:02:33 <Phyx-> @src gcd
03:02:34 <lambdabot> gcd 0 0 = error "Prelude.gcd: gcd 0 0 is undefined"
03:02:34 <lambdabot> gcd x y = gcd' (abs x) (abs y)
03:02:34 <lambdabot>    where gcd' a 0  =  a
03:02:34 <lambdabot>          gcd' a b  =  gcd' b (a `rem` b)
03:02:34 <pozic> master_o1_master: this is not some project euler thing?
03:02:44 <merehap> log n rather than n
03:02:56 <ski> btw, `(foo $ b)' is simpler written as `(foo b)'
03:03:02 <merehap> well log (a*b) or something
03:03:34 <master_o1_master> pozic: no, it's for a class. I've allready solved it in c++ :) But I thought that haskell is nicer
03:03:56 <merehap> the fold solution should probably be fine for your purposes
03:06:06 <pozic> master_o1_master: well, the solution which creates the same kind of process as the C++ version will probably work acceptably fast.
03:10:44 <pozic> Is there a library which can draw a planar graph to the screen already? E.g. using GTK or whatever.
03:11:26 <jaspervdj> suppose I have two related modules Foo, one of which uses the other internally - the other is hidden/not-exposed
03:11:41 <jaspervdj> what would be the naming convention? Foo and FooInternal?
03:12:03 <Veinor> I would argue Data.Foo and Data.Foo.Internal
03:12:05 <merehap> I've seen that a lot on hackage
03:12:14 <merehap> oh yeah, what Veinor wrote
03:12:19 <jaspervdj> Okay, thanks :-)
03:12:28 <Veinor> or Foo.SomeOtherSuitableName
03:12:34 <pozic> jaspervdj: what Veinor wrote indeed, but FooInternal is fine by me too.
03:13:22 <pozic> jaspervdj: darcs still has only one source directory.
03:13:36 <pozic> jaspervdj: navigating directories only takes up time.
03:15:14 <jaspervdj> Hmm, but I always try to stick to the conventions as much as possible, so I'll go with Foo.Internal here
03:21:06 <yaxu1> well my Traversable instance compiles but sequenceA doesn't terminate, there must be some infinity creeping into my Applicative instance somewhere
03:21:20 <yaxu1> bother infinity
03:21:22 <Alpounet> @instances Traversable
03:21:23 <lambdabot> Couldn't find class `Traversable'. Try @instances-importing
03:21:39 <yaxu1> @instances Data.Traversable
03:21:40 <lambdabot> Couldn't find class `Data.Traversable'. Try @instances-importing
03:21:53 <yaxu1> @instances Data.Traversable.Traversable
03:21:54 <lambdabot> Maybe, []
03:29:17 <ivanm> OT, but this channel is rather dead atm anyway: anyone know of any good programs that can be used for inventory purposes (i.e. keeping track of what someone owns, etc.) ?
03:30:51 <kamatsu> ivanm: google docs?
03:30:56 <kamatsu> a spreadsheet?
03:31:12 <ivanm> yeah, I was hoping for something a little more organised than that ;-)
03:31:21 <ivanm> and easy to use for others once I've set it up
03:31:23 <kamatsu> a better spreadsheet?
03:31:26 <ivanm> (since it isn't for me)
03:31:40 <kamatsu> haskell combinator library?
03:31:44 <ivanm> :o
03:32:10 <kamatsu> hm, some form of combinatorial inventory tracker should be easy to understand, after all, it has logical consistency.
03:32:19 <ivanm> I was looking at tellico, but it can't run on windows (and the end users run windows); gcstar runs on windows is fugly :s
03:32:26 <ivanm> kamatsu: I don't have time to write one ;-)
03:32:34 <kamatsu> lol, damn
03:32:54 <ivanm> (this is something I'd promised to do for ages and now kinda have to do it tonight :s )
03:32:59 <kamatsu> haha
03:33:07 <merehap> wow, I was just trying to visit darcs.net
03:33:22 <merehap> but I didn't know my left hand was shifted one key to the left
03:33:28 <merehap> and ended up typing
03:33:39 <merehap> sEX instead
03:33:56 <merehap> I think my hands are trying to tell me something 0_0
03:34:19 <merehap> sorry, random drivel of the day
03:34:29 <yaxu1> merehap: I recommend remapping capslock to ctrl, possibly more ergonomic if you hit control a lot
03:34:34 <fabry1970> ciao
03:34:36 <fabry1970> !list
03:34:55 <Phyx-> this isn't a warez channel
03:35:04 <ski> perhaps you meant
03:35:05 <ski> @src []
03:35:06 <lambdabot> data [] a = [] | a : [a]
03:35:15 <ivanm> Phyx-: I never asked about illegal stuff...
03:35:26 <merehap> yaxu1: you may be right, I don't think I use capslock
03:35:49 <Phyx-> ivanm: lol, i didn't mean you, i meant fabry1970
03:36:02 <Phyx-> unless there actually is a !list command here
03:36:05 <ivanm> Phyx-: how does "!list" imply warez?
03:36:10 <ivanm> Phyx-: there's @list ...
03:36:12 <ski> @help list
03:36:12 <lambdabot> list [module|command]
03:36:13 <lambdabot> show all commands or command for [module]. http://code.haskell.org/lambdabot/COMMANDS
03:37:11 <Phyx-> ivanm: if someone joins and his first few words contain "!list" i would say it's a pretty safe bet he was looking for downloads, and most commonly warez
03:37:25 <Phyx-> atleast, that's my hypothesis
03:39:02 <Jafet> merehap, after you move capslock, bind it to your favorite macro
03:39:12 <Veinor> I'm agreeing with phyx-
03:39:24 <Veinor> I vaguely recall something similar happening in #nethack once.
03:40:05 <zygoloid> yeah !list is a fairly standard command which DCC warez bots respond to
03:40:35 <merehap> Jafet: it might serve as a better mod button for XMonad than the Windows/Super button
03:53:00 <HugoDaniel> http://ezyang.scripts.mit.edu/blog/2010/01/why-haskell/
03:53:00 <HugoDaniel> have you read it ? i sometimes feel that i should use python instead of haskell, because of future maintenance of the code im producing
03:53:53 <Jafet> Haskell is the language of the future
03:54:27 <Jafet> @faq Can Haskell produce zero-maintenance code?
03:54:27 <lambdabot> The answer is: Yes! Haskell can do that.
03:55:09 <merehap> I read it, and have to agree, but still hope for better times...
03:56:11 <shambler_> i don't think python can produce such code
03:56:21 <Jafet> "Why Haskell rocks: the static analysis is complete enough that if it compiles, it runs correctly."
03:56:36 <Jafet> ...er, yeah.
03:56:50 <QtPlaty[HireMe]> Jafet: That is not realy true
03:56:52 <merehap> I wish that were true, it is more true of Haskell than other languages
03:56:54 <flux> for some values of 'correctly'?-)
03:57:06 <medfly> it won't produce a lot of nasty errors :-)
03:57:07 <Jafet> If it typechecks, it will not produce type errors!
03:57:14 <Jafet> medfly, it does until it compiles
03:57:20 <HugoDaniel> :(
03:58:10 <HugoDaniel> i just keep using haskell code for everything i do professionally...
03:58:27 <HugoDaniel> but thats because i mostly work alone
03:58:40 <HugoDaniel> otherwise python or java would have to do...
03:58:47 <HugoDaniel> or C#
03:59:11 <medfly> Haskell is zero maintenance because you can't get anyone to maintain it. (:
03:59:13 <merehap> HugoDaniel: damn you're lucky
03:59:15 <QtPlaty[HireMe]> There are 16 funtions of type Boolean -> Boolean -> Boolean but using thr wrong one will cause an error, which will never be picked up by type checking
03:59:39 <HugoDaniel> merehap: for working alone ? :/
03:59:50 <merehap> for being able to use haskell
03:59:57 <merehap> though working alone can be fun too
04:00:01 <medfly> HugoDaniel: I work alone and I don't get to choose my language
04:00:08 <merehap> I'm stuck with C# day in and day out
04:00:21 <Jafet> @remember medfly Haskell is zero maintenance because you can't get anyone to maintain it. (:
04:00:21 <merehap> at work at least
04:00:21 <lambdabot> I will never forget.
04:00:44 <Jafet> QtPlaty, depends on how good your type system is.
04:01:06 <merehap> what is an example of a type system that could catch that error?
04:01:31 <Jafet> Agda's!
04:01:42 <HugoDaniel> well, there is quite a strong opposition to haskell, specially among the people that manage and dont know how to code
04:01:45 <Jafet> You can probably do a similar thing in C++, to some degree
04:01:54 <merehap> hm, I was thinking nothing short of Coq, but I haven't looked too closely
04:02:12 <Jafet> Great, now we're going to spend another five minutes obsessing over Coq.
04:02:20 <zygoloid> lol
04:02:21 <shambler_> Why Haskell rocks: Insane people writing insane compilers like GHC
04:02:25 <shambler_> hehe
04:02:38 <merehap> no, I haven't used or obsessed over Coq before :)
04:03:18 <zygoloid> has anyone managed to get Python and Haskell to play nicely together? is it possible? (in particular I assume that you'd need to get the GCs to interoperate)
04:03:19 <merehap> well, I guess that depends on how you define "used"
04:03:38 <Jafet> zygoloid, you could run them over IPC
04:03:38 <zygoloid> would it be better to just write a haskell python vm? :)
04:03:54 <Jafet> Guido would die so that he can roll in his grave
04:03:56 <zygoloid> Jafet: i would want the haskell code to be able to hold python objects and vice versa
04:03:58 <Jafet> I suppose that's not too bad
04:04:02 <merehap> zygoloid: that's always the right solution
04:04:06 <merehap> :)
04:04:29 <zygoloid> maybe i should just go back to writing my python compiler :)
04:04:46 <Jafet> How do you compile python? Same way you compile perl?
04:05:17 <kamatsu> Jafet: as in, don't?
04:05:23 <zygoloid> crazy type inference tricks, and resorting to dynamism where you have to, is my approach
04:05:25 <Jafet> As in, do it the obvious way
04:05:33 <QtPlaty[HireMe]> Jafet: Perl is compiled to an intermediate form as is pyton
04:05:52 <Jafet> I assume we're talking about compilation to something resembling assembly language
04:05:54 <zygoloid> i'm not writing a parser though; i'm just invoking cpython and reading the bytecode to get started
04:06:00 <kamatsu> zygoloid: could you use structural typing?
04:06:14 <Jafet> python isn't structurally typed.
04:06:22 <zygoloid> kamatsu: yep, that's part of it, but even that is hard since objects' dicts can be keyed off arbitrary strings
04:06:30 <Jafet> It's a weird mix that people didn't know what to call, so they named it after an animal
04:06:47 <zygoloid> you can use structural typing in the cases where you can prove that it works :)
04:07:16 <Jafet> Kind of hard, since the structure isn't declared anywhere
04:07:52 <Veinor> if I enable existential quantifiers, and I have data Box = forall s. (Show s) => Box s
04:07:52 <zygoloid> Jafet: that's somewhat of an understatement :)
04:07:59 <kamatsu> couldn't you implement a python compiler by bundling a python interpreter and python bytecode into one executable?
04:08:01 <Veinor> can I write f (Box x) = x?
04:08:07 <Jafet> kamatsu, that's how perl is compiled.
04:08:12 <shambler_> they called it after the Monty Python, but thats not very encouraging either
04:08:13 <zygoloid> kamatsu: not only can you, but such compilers are already available
04:08:34 <Jafet> zygoloid, they never work when you need them to, though
04:08:38 <kamatsu> zygoloid: right, so, problem solved.
04:08:51 <kamatsu> zygoloid: any language which has "eval" is at least difficult to compile fully
04:08:55 <zygoloid> kamatsu: that's not the problem i'm trying to solve :)
04:09:03 <Veinor> ah, nevermind
04:09:05 <Jafet> Compiling lisp is pretty solved
04:09:09 <Veinor> you can't because of types
04:09:15 <kamatsu> Veinor: right
04:09:29 <zygoloid> kamatsu: in my experience almost no real python program uses 'eval'
04:09:34 <Veinor> but I could do f (Box x) = show x
04:09:46 <kamatsu> zygoloid: right, but are you aiming to support common python programs or all python programs?
04:09:48 <zygoloid> kamatsu: but i agree that there are /loads/ of things which make it hard
04:09:52 <Veinor> cause that's just Box -> String
04:10:22 <Jafet> @hoogle * -> a
04:10:22 <lambdabot> Parse error:
04:10:23 <lambdabot>   --count=20 "* -> a"
04:10:23 <lambdabot>              ^
04:10:39 <kamatsu> @hoogle b -> a
04:10:39 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
04:10:39 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
04:10:39 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
04:10:49 <zygoloid> kamatsu: i intend, long term, to get the best result i can for the given program. if it uses eval, that won't be very good, i think.
04:11:07 <ski> Veinor : the type of `f' should be `f :: Box -> exists s. Show s *> s' .. which can't be expressed (except via exactly that datatype workaround)
04:11:10 <Jafet> You could define your subset of python that happens to not have eval
04:11:20 <Jafet> Or perhaps a dummy one that dumps core.
04:11:25 <Jafet> Serves them right for using it.
04:12:10 <zygoloid> Jafet: there's still the problem of people writing to __dict__ on an object (possibly a class even), maybe using keys read from the user...
04:12:19 <Jafet> > let out (Just x) = x in (out (Just 1), out (Just "2"))
04:12:20 <lambdabot>   (1,"2")
04:12:39 <Jafet> zygoloid, it's actually similar to things that you can do in lisp
04:12:50 <Jafet> Except Guido loves to overcomplicate things for no reason
04:13:12 <zygoloid> essentially you need buckets of whole-program analysis to prove that people aren't doing horrible things, before you can apply many of the nicer optimizations
04:13:23 <Jafet> Horrible semantics, indeed.
04:13:33 <Veinor> Jafet: yeah, but Just isn't an existential type.
04:14:09 <Jafet> Right.
04:17:04 <kamatsu> zygoloid: not easier to rewrite in haskell?
04:18:20 <kamatsu> Jafet: idiomatic ruby programs use eval constantly
04:18:24 <kamatsu> ruby is big on metaprogramming
04:18:31 <Jafet> eval is not metaprogramming.
04:18:39 <Jafet> eval is admitting that your language sucks
04:18:40 <ski> they use `eval' for what ?
04:18:40 <kamatsu> right, but it has instance_eval and other evals
04:18:56 <sepp2k> kamatsu: Those evals accept anonymous functions, not strings.
04:18:59 <kamatsu> true
04:19:24 <medfly> hehe
04:19:38 <Veinor> if you export an existential data constructor, do things that use it have to have the appropriate extension enabled?
04:19:40 <sepp2k> Well, actually they do accept strings. But they're not usually used with them.
04:19:45 <kamatsu> right
04:20:16 <kamatsu> Veinor: no
04:20:21 <Veinor> ok.
04:21:01 <Veinor> I'm writing a post about variadic functions in haskell, using printf as my motivating example
04:21:12 <kamatsu> Veinor: you don't need existential types for variadic functions
04:21:17 <Veinor> well, yeah
04:21:30 <Veinor> but I'm looking at another way to write printf without the variadic hack it uses
04:21:41 <kamatsu> hack?
04:22:19 <Veinor> well, I dunno if it's a hack exactly. it uses the type system in a very interesting way.
04:22:47 <Veinor> the existential way would be say data Printf = forall t. (PrintfAble t) => Printf t
04:22:59 <kamatsu> right but that doesn't in any way remove any "hack" that printf uses
04:23:18 <kamatsu> it just allows you to add printf-able types in your own programs by adding to a typeclass
04:23:23 <Veinor> and then printf :: (PrintfType t) => String -> [Printf] -> t
04:23:56 <kamatsu> wait, [Printf]?
04:24:11 <Veinor> yeah, an existential type
04:24:16 <kamatsu> why a list?
04:24:21 <ski> it's a list of "options"
04:24:40 <ski> er, s/options/arguments/
04:24:42 <Veinor> current printf "%s %d" "foo" 2 would become printf "%s %d" [Printf "foo", Printf 2]
04:24:46 <Veinor> yeah.
04:25:17 <kamatsu> but then that's not really a variadic function
04:25:20 <zygoloid> but printf only uses the typeclass hack to get the "nicer" syntax
04:25:21 <kamatsu> just a function that takes a list
04:25:25 <Veinor> right.
04:25:35 <Veinor> I'm saying that's an alternative to variadic functions altogether.
04:25:37 <ski> but why not use `printf [Printf . String $ "foo",Printf . Int $ 2]', then ?
04:25:44 <yaxu1> is there a way of writing a function that does this: (Int -> IO Int) -> IO (Int -> Int)
04:26:15 <kamatsu> yaxu1: let me hoogle that for you
04:26:17 <Veinor> ski: I'm not sure what you're trying to say?
04:26:35 <ski> yaxu1 : i don't think so
04:26:36 <kamatsu> @hoogle (a -> m b) -> m (a -> b)
04:26:36 <lambdabot> Test.QuickCheck promote :: (a -> Gen b) -> Gen (a -> b)
04:26:38 <yaxu1> kamatsu: I did start with a hoogle this time, honest
04:26:47 <kamatsu> aww
04:26:51 <ski> Veinor : why separate the formatting options from the things to display ?
04:26:52 <kamatsu> that sounds like a function that should exist
04:27:03 <kamatsu> ski: localization!
04:27:17 <ski> kamatsu : it can't work for an arbitrary monad, at least
04:27:17 <koeien37> no it shouldn't exist
04:27:31 <zygoloid> yaxu1: no, that's not possible. consider: f 0 = putStrLn "zero"; f _ = putStrLn "nonzero"
04:27:41 <koeien37> take a function that maps Ints to IO actions; you can't get a pure function out of that after doing some IO
04:27:54 <zygoloid> yaxu1: if your function existed, i should be able to extract the side-effects of that without providing it with an int
04:27:57 <Veinor> because printf does some other munging as well
04:28:15 <koeien37> that is a good way of putting it
04:28:15 <Veinor> like, right-align, pad with 0s, and trim after the 5th decimal point
04:28:18 <yaxu1> Right, I thought I was missing something
04:28:31 <zygoloid> yaxu1: you can go in the other direction, though.
04:28:43 <koeien37> you can do the other way around
04:29:02 <ski> @type \mf a -> fmap ($ a) mf
04:29:04 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a -> b) -> a -> f b
04:29:13 <koeien37> IO (Int -> Int) -> Int -> IO Int
04:29:18 <koeien37> :t flip fmap
04:29:20 <lambdabot> forall a b (f :: * -> *). (Functor f) => f a -> (a -> b) -> f b
04:29:25 <koeien37> ragh
04:29:45 <ski> @type flip
04:29:46 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
04:29:52 <zygoloid> @type (. return) . ap
04:29:53 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> a -> m b
04:30:44 <Veinor> I also thought it was funny how printf can return a String or an IO ()
04:30:46 <Veinor> so you can use it both as sprintf and printf
04:31:00 <Veinor> that always seemed like a poor idea to me.
04:31:46 <koeien37> yeah, I don't like that either
04:31:51 <koeien37> makes the return type even more complicated
04:32:06 <quicksilver> I've always viewed it as a proof-of-concept not code you'd actually use
04:32:15 <quicksilver> I'm always surprised when people use it.
04:32:32 <koeien37> it is sometimes convenient, although I never use it myself -- I always find out afterwards
04:32:37 <quicksilver> if you want a proper template/formatting language, then you want a proper template/formatting language
04:32:48 * Veinor shrugs
04:32:50 <koeien37> sure, but for quick-and-dirty printing of floats and so on
04:32:53 <quicksilver> if you don't, then (blah ++ blah bar ++ "foo" ++ formatLikeThis bah)
04:32:55 <Veinor> it does make me want to write zipListN, though...
04:32:58 <quicksilver> is normally fine.
04:33:03 <Jafet> format is Turing-complete!
04:33:15 <Veinor> oh wait, that's not possible
04:33:21 <Veinor> hm
04:33:36 <Jafet> Veinor, templates
04:33:39 <Veinor> :P
04:33:50 <Veinor> anyway, back in a while
04:43:11 <Phyx-> @type printf
04:43:13 <lambdabot> forall r. (PrintfType r) => String -> r
04:43:32 <Phyx-> @src PrintfType
04:43:32 <lambdabot> Source not found. stty: unknown mode: doofus
04:43:41 <Phyx-> eh?
04:43:50 <Cale> It means it just doesn't have the source for that
04:44:09 <Phyx-> i got that part, it's the "mode: doofus" that generated the eh out of me
04:44:10 <Phyx-> :P
04:44:29 <Cale> It has various mildly insulting remarks that it picks from for some reason
04:44:48 <Phyx-> lol
04:45:02 <Jafet> Which Cale, as a matter of course, knows nothing about
04:45:47 <zygoloid> it's quite annoying when she insults the user for asking a reasonable question which she doesn't know the answer to...
04:46:41 <Cale> Jafet: Well, I didn't write it :)
04:46:47 <Cale> Jafet: I just keep the bot running.
04:46:50 <Jafet> @vixen call me names, baby
04:46:52 <lambdabot> okay, i'm dialing
04:53:07 <medfly> hehe
04:59:28 <taruti> Is there a nice way of creating a huge TVar-array that is initialized in a lazy fashion?
05:18:13 <Phyx-_> *sigh* time to ghost again
05:29:13 <MarcWeber> kolmodin: Do you already have an implementation watching directories recursively using inotify?
05:31:17 <ivanm> preflex: seen kolmodin
05:31:17 <preflex>  kolmodin was last seen on #haskell 16 days, 19 hours, 50 minutes and 30 seconds ago, saying: OSError: [Errno 13] Permission denied: '/srv/trac/network/attachments/ticket'
05:31:26 <ivanm> MarcWeber: not much chance of catching him atm
05:31:30 <ivanm> he's on holidays IIRC
05:34:57 <Berengal> Has there been any work on leksah lately?
05:37:06 <MarcWeber> Berengal: Go scion. :) (My preference. cause Scion works with both Emacs and Vim)
05:37:57 <Berengal> MarcWeber: I use Emacs myself, but was just wondering about leksah for a moment...
05:38:38 <MarcWeber> I don't know much about that project other than that it exists.
05:44:03 <ivanm> MarcWeber: has there been an actual release of scion yet?
05:44:18 <MarcWeber> ivanm: multiple
05:44:37 <ivanm> hmmm...
05:44:37 <MarcWeber> nominolo and me we both are using it for > 6month..
05:44:47 <MarcWeber> github.com/nominolo/scion
05:46:27 <ivanm> I thought it was using pre-release libraries and thus hadn't had a release yet...
05:47:53 <MarcWeber> ivanm: I'm not sure. It's worth giving it a try whether it has been released or not
05:59:53 <jbourne> ,jh
05:59:54 <lunabot>  luna: Not in scope: `jh'
06:04:38 <Phyx-> try try try
06:04:41 <Phyx-> @type try
06:04:42 <lambdabot> Not in scope: `try'
06:04:51 <Phyx-> @hoogle try --info
06:04:52 <lambdabot> Control.Exception try :: Exception e => IO a -> IO (Either e a)
06:04:52 <lambdabot>  
06:04:52 <lambdabot> Similar to catch, but returns an Either result which is (Right a) if no exception was raised, or (Left e) if an exception was raised and its value is e.
06:06:59 * hackagebot upload: uniplate 1.4 - Help writing simple, consise and fast generic operations. (NeilMitchell)
06:07:01 * hackagebot upload: hlint 1.6.15 - Source code suggestions (NeilMitchell)
06:12:01 * hackagebot upload: convertible 1.0.8 - Typeclasses and instances for converting between types (JohnGoerzen)
06:13:03 <Cale> > sortBy (flip (comparing snd)) . M.toList . M.fromListWith (+) $ zip (concat cake) (repeat 1)
06:13:04 <lambdabot>   [(' ',162),('e',156),('a',91),('r',89),('s',85),('n',79),('o',70),('i',62),...
06:13:29 <Cale> > map fst . sortBy (flip (comparing snd)) . M.toList . M.fromListWith (+) $ zip (concat cake) (repeat 1)
06:13:30 <lambdabot>   " earsnoitlcduhp.gbmwOTFfvjkyA,-'CISz1258:DNPUx"
06:13:32 <quicksilver> that description for 'try' is pretty misleading now.
06:14:15 <ivanm> Cale, quicksilver: either of you familiar much with beamer?
06:14:24 <Cale> ivanm: vaguely
06:14:34 <ivanm> how about it's notes functionality?
06:15:53 <ivanm> nvm, managed to hack something together
06:16:37 <Cale> I haven't really used it myself.
06:17:05 <Cale> I looked at its examples and documentation a bit in the past and figured that if I ever had to make a presentation I'd probably use it.
06:17:20 <Cale> But I've never had the occasion :P
06:17:23 <kamatsu> hey, is there a way in TH to get all the names that a module exports?
06:19:19 <ivanm> Cale: I was trying to make a printout for myself with all the slides and all the notes (even if a slide didn't have any notes to print an empty note slide) 8-up using \pgfpageuselayout like the user guide suggests
06:19:42 <ivanm> I had to insert dummy notes (\note { }) in all the slides to force them to _have_ note slides :s
06:20:49 <kamatsu> hm, i think i might have to write a program that generates haskell then
06:22:05 <ivanm> I've done that
06:22:10 <ivanm> use a pretty-printing library
06:22:22 <ivanm> kamatsu: what are you trying to generate?
06:24:29 <Phyx-> @hoogle directory
06:24:30 <lambdabot> package directory
06:24:30 <lambdabot> module System.Directory
06:24:30 <lambdabot> System.Directory createDirectory :: FilePath -> IO ()
06:24:43 <Phyx-> @hoogle exist
06:24:44 <lambdabot> System.IO.Error alreadyExistsErrorType :: IOErrorType
06:24:44 <lambdabot> System.Directory doesDirectoryExist :: FilePath -> IO Bool
06:24:44 <lambdabot> System.Directory doesFileExist :: FilePath -> IO Bool
06:24:54 <ivanm> yay, I'm leaving for Europe in about 36 hours, and I still have to pack (well, put stuff in the suitcase mainly), check my talk isn't too long and do a few other things :s
06:25:02 <ivanm> oh well, sleep beckons...
06:25:51 <Phyx-> night ivanm
06:26:42 <pozic> ivanm: where are you going?
06:27:02 <ivanm> pozic: ultimately to PEPM in Madrid to present a talk there
06:27:10 <ivanm> first of all I'm going to visit a friend in Rotterdam though
06:29:17 <pozic> ivanm: I wonder whether it is healthy that I know both of them? http://strategoxt.org/PEPM10/InvitedTalks
06:29:35 <ivanm> both of what?
06:29:41 <ivanm> oh, the invited people?
06:29:45 <pozic> ivanm: both presenters.
06:29:53 <ivanm> pozic: I don't know _anyone_ who's going to be there!
06:30:12 <ivanm> I know voigt by email since he asked me to submit a paper (since he's one of the people organising it); that's about it
06:31:12 <pozic> ivanm: I am not even sure whether I would take the effort to go and present something at the other side of the planet :)
06:31:29 <pozic> ivanm: kudos to you for that.
06:31:48 <ivanm> thanks
06:31:58 <ivanm> pozic: I don't really have many choices wrt presenting stuff here...
06:32:23 <ivanm> and besides, it sounds cool that I've been asked to present something when I'm not even a PnD student yet, let alone a professor or something!
06:34:05 <mornfall> PEPM = ?
06:34:23 <ivanm> Partial Evaluation and Program Manipulation
06:34:28 <mornfall> Hmm.
06:34:29 <ivanm> it's a conference co-located with POPL
06:35:55 <pozic> ivanm: is this about source graph?
06:36:01 <ivanm> yup
06:36:11 <pozic> ivanm: what exactly is the research aspect of that?
06:36:45 <ivanm> pozic: wtf to do with it :p
06:37:00 <ivanm> pozic: it does some (admittedly very simple and boring analyses) with the call graph
06:38:51 <pozic> ivanm: I am well aware of those analyses; I just wouldn't call it research, but since you are not doing your PhD yet, that's OK. At least you have shown that you can build something which does something useful.
06:39:42 <ivanm> pozic: voigt _asked_ me to submit!
06:42:44 <ivanm> pozic: I agree with you, but my paper was accepted (with a 40% acceptance rate), I'm getting US$2000 towards flights and AUD$500 towards hotel+registration
06:42:49 <ivanm> so who am I to complain? ;-)
06:44:03 <ivanm> anyway, time I hit the sack
06:44:04 <ivanm> g'night all
06:44:08 <pozic> ivanm: yes, it is very good for you. I am not accusing you of anything. Have fun.
06:44:12 <ivanm> thanks!
06:53:07 <Phyx-> @type isNum
06:53:08 <lambdabot> Not in scope: `isNum'
06:53:13 <Phyx-> @hoogle isNum
06:53:14 <lambdabot> Data.Char isNumber :: Char -> Bool
06:55:01 <aavogt> > isNumber 'a'
06:55:02 <lambdabot>   False
06:55:04 <taruti> How is performance of binary vs cereal vs binary-strict?
07:00:20 <Cale> I think cereal is supposed to perform better than binary, but I haven't actually seen the benchmarks.
07:00:21 * hackagebot upload: hashed-storage 0.4.4 - Hashed file storage support code. (PetrRockai)
07:08:59 <Berengal> Where does cabal do its building when installing from hackage?
07:09:17 <dcoutts_> Berengal: a random dir in $TMP
07:09:39 <dcoutts_> which gets cleaned afterwards
07:09:48 <Berengal> Is there a way for it to not clean it?
07:10:07 <dcoutts_> if you want to poke about then just cabal unpack $foo; cd $foo; cabal install
07:10:20 <Berengal> True enough, thanks.
07:10:52 <dcoutts_> Berengal: since it's easier and more convenient to just do the above I decided that it was not worth adding a --don't-clean flag
07:11:12 <dcoutts_> since it'd have cleaned the first time, you'd have to rebuild with that non-default flag anyway
07:11:18 <Berengal> dcoutts_: Indeed, I just forgot about unpack for a moment
07:11:58 <Berengal> I'm trying to build happstack-data on 6.12, but getting some linker error
07:17:14 <pozic> Is there an extension such that I can use types that start with a number?
07:17:41 <zygoloid> there's an extension which allows you to use 1 as a type, but it's a specific predefined type
07:19:14 <pozic> zygoloid: what is the purpose of that?
07:19:43 <pozic> zygoloid: I have never heard of an extension that specific.
07:30:21 <DekuNut> Is it fair to say that data X = forall a . BuildX a == data X a = BuildX a
07:31:18 <aavogt> DekuNut: [X] is different from  [BuildX a]
07:31:45 <aavogt> since in the first case all the 'a's can be different, but in the second they are all the same
07:32:05 <DekuNut> Wouldn't that be [X] and [X a]?
07:32:31 <benmachine> as I understand it, data X a = BuildX a == forall a. data X a = BuildX a
07:32:51 <DekuNut> Ahhh
07:32:57 <benmachine> but I've never understood it that well, so maybe not
07:33:45 <DekuNut> That would make more sense, also makes forall a little more clear than the (forall a . a -> a) -> (b -> c) / forall a. ( a -> a ) -> ( b -> c ) exampel
07:33:53 <DekuNut> example* even
07:33:54 <aavogt> the existential:   `data X = forall a. X a'  is very useless
07:34:41 <Veinor> yeah.
07:34:43 <aavogt> because it lets you build:    [X 'a',X "hai", X 3, ...]
07:34:43 <DekuNut> aavogt, I haven't actually written any haskell to date, so I haven't got any experience in why it would or wouldn't be
07:34:48 <DekuNut> I'll just take your word for it
07:35:01 <Veinor> DekuNut: because you know nothing about the contents, so you can't do anything useful with it
07:35:18 <aavogt> more useful is, say:   `data X b = forall a. X a (a -> b)'
07:35:42 <Veinor> which would do?
07:36:05 <aavogt> so you are allowed to get a `b' out with the lambda:   (\(X x f) -> f x) :: X b -> b
07:36:14 <DekuNut> Veinor, unless you use typeclasses, i.e, data X = forall a . Show a => X a
07:36:20 <Veinor> DekuNut: yeah.
07:36:27 <aavogt> in spite of all the `a' being different
07:37:14 <aavogt> I think having an actual function(s) included in the existential is easier to see than the typeclass constraint
07:37:16 <DekuNut> Interesting, I really like that aavogt
07:37:21 <aavogt> but they are the same
07:38:06 <zygoloid> pozic: it's to do with the generic classes extension (i think?), wherein automatic class instances can be provided if you say what to do on unit, sum and product types
07:38:47 <aavogt> zygoloid: I have not heard of that either
07:38:52 <HugoDaniel> should i go to the hackaton in zurich ?
07:38:52 <zygoloid> http://www.haskell.org/ghc/docs/latest/html/users_guide/generic-classes.html
07:38:59 <augur> anyone know of any (efficient) algorithms for taking a collection of, lets say, lists, and finding the smallest number of sublists required to construct all of them?
07:39:09 <HugoDaniel> will it be worth the 250€ of the plane ticket ? :/
07:39:41 <benmachine> aavogt: is forall a. X a (a -> b) any more useful than just X b?
07:39:49 <Jafet> augur, sounds like an exact covering problem
07:40:25 <augur> jafet: hmm!
07:40:51 <int-e> what does "construct" mean here?
07:40:54 <augur> not quite i dont think
07:41:55 <augur> int-e: such that lets say l is a list in this set, a ++ b ++ ... == l
07:41:57 <ski> (benmachine : i don't think so)
07:42:07 <Veinor> benmachine: let b = string
07:42:10 <Veinor> er, String
07:42:18 <zygoloid> augur: sounds like an interesting problem. my gut says np-complete :)
07:42:24 <augur> it probably is
07:42:25 <augur> :\
07:42:43 <zygoloid> i wonder if it reduces to set-cover
07:42:45 <ski> (benmachine,aavogt : `data Foo a b = forall x. MkFoo x ((x,a) -> (x,b))', though ..)
07:43:12 <zygoloid> almost certainly the sort of thing which those crazy computational geneticists will have pondered over :)
07:43:42 <augur> really what im looking to do is find the smallest function that will construct maps from phonological to orthographic representations
07:43:43 <augur> :p
07:51:46 <joe1> i am doing something similar to: foreach file in directory, read & process contents, and write to a file(with the suffix from the source file) in a directory.
07:54:42 <pozic> How can I write an instance for Eq when all I have is data P = forall a. Floating a => P a?
07:55:48 <aavogt> @src Floating
07:55:49 <lambdabot> class  (Fractional a) => Floating a  where
07:55:49 <lambdabot>     pi                                                      :: a
07:55:49 <lambdabot>     exp, log, sqrt, sin, cos, tan                           :: a -> a
07:55:49 <lambdabot>     asin, acos, atan, sinh, cosh, tanh, asinh, acosh, atanh :: a -> a
07:55:49 <lambdabot>     (**), logBase                                           :: a -> a -> a
07:56:04 <benmachine> looks like there's not much that can be done thre
07:56:06 <pozic> The problem is that the two as in the argument of (==) don't have to be the same according to the compiler. The compiler is right in this point.
07:56:06 <benmachine> *there
07:56:07 <aavogt> pozic: the type of (==) won't allow it
07:56:22 <aavogt> you could unsafeCoerce...
07:56:50 * hackagebot upload: QuickCheck 2.1.0.3 - Automatic testing of Haskell programs (NickSmallbone)
07:56:53 <benmachine> you need more than Floating
07:56:58 <benmachine> if you had Real you could do it
07:57:00 <aavogt> @type RealFloat
07:57:01 <lambdabot> Not in scope: data constructor `RealFloat'
07:57:12 <aavogt> @type decodeFloat
07:57:13 <lambdabot> forall a. (RealFloat a) => a -> (Integer, Int)
08:00:34 <pozic> benmachine: thank you.
08:00:47 <benmachine> :t toRational
08:00:48 <lambdabot> forall a. (Real a) => a -> Rational
08:01:03 <benmachine> :t (==) `on` toRational
08:01:04 <lambdabot> forall a. (Real a) => a -> a -> Bool
08:01:12 <benmachine> er, you wouldn't quite be able to do that
08:01:16 <benmachine> but, close enough
08:01:36 <benmachine> :t \x y -> toRational x == toRational y
08:01:38 <lambdabot> forall a a1. (Real a, Real a1) => a -> a1 -> Bool
08:01:41 <benmachine> that's better
08:02:06 <pozic> benmachine: yes, I already had that.
08:02:34 <ski> i think that would be the type of   (==) `on` toRational  if the type of  toRational  was  (exists a. Real a *> a) -> Rational
08:02:38 <benmachine> well good!
08:03:01 <joe1> sorry, was disconnected.
08:03:07 <benmachine> what on earth is *> there
08:03:11 <HugoDaniel> anyone going to the zurihac ?
08:03:46 * leimy just made the leap to 6.12
08:03:47 <ski> benmachine :  `*>' : `=>' :: `(,)' : `->'
08:04:23 <ski> benmachine : a value of type `Real a *> a' is a pair of an instance `Real a' and a value of type `a'
08:04:34 <joe1> foreach file in a directory, read and process data in the file and then write to a file in a directory.
08:04:41 <benmachine> ski: weeeeird.
08:04:51 <ski> benmachine : a value of type `Real a -> a' is (implicitly) a function that given any instance `Real a' returns a value of type `a'
08:04:53 <joe1> i am looking for a function such as foreach. wondering if there is one..
08:05:04 <ski> er, s/->/=>/, there
08:05:19 <ski> @type forM_  -- joe1
08:05:20 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
08:05:32 <joe1> ski: thanks.
08:05:53 <ski> you need to first get the files in a directory into a list
08:06:06 <ski> @hoogle directoryContents
08:06:07 <lambdabot> System.Directory getDirectoryContents :: FilePath -> IO [FilePath]
08:07:00 <joe1> ski:          dplusfiles <- globDir1 (compile "dplus*") "/tmp/data/"
08:07:15 <joe1> ski: i am using globDir1 to read certain files into the list.
08:07:50 <joe1> and am planning on using zipWith writeFile to write out the file.
08:11:05 <joe1> zipWith writeFile dplus_destination_files (function_that_processes_data dplusfiles)
08:11:18 <ski> @type zipWithM
08:11:19 <lambdabot> forall a b (m :: * -> *) c. (Monad m) => (a -> b -> m c) -> [a] -> [b] -> m [c]
08:11:25 <joe1> something that makes sense in the above function.
08:11:36 <ski> you'll need that instead (or `sequence', if you prefer)
08:12:26 <joe1> ski: thanks. will give zipWithM
08:12:50 <joe1> s/give/try/
08:15:05 <aavogt> @type zipWithM_
08:15:06 <lambdabot> forall a b (m :: * -> *) c. (Monad m) => (a -> b -> m c) -> [a] -> [b] -> m ()
08:15:13 <ski> hm, right
08:18:09 <McManiaC> hey! is there a 'goto' for haskell?
08:18:22 <zygoloid> ski: isn't "(exists a. Real a *> a) -> Rational" isomorphic to "forall a. (Real a *> a) -> Rational", which is isomorphic to "forall a. Real a => a -> Rational" anyway?
08:18:46 <zygoloid> McManiaC: several, for some value of goto :)
08:18:58 <temoto> in class Eq, is (==) called a 'method'?
08:19:37 <aavogt> temoto: yes
08:19:54 <gio123> ski: hi
08:20:57 <McManiaC> http://schlueters.de/blog/archives/94-Goto-your-Christmas-presents-with-PHP-5.3.html ← like this zygoloid
08:21:01 <McManiaC> :D
08:23:11 <temoto> aavogt: thanks
08:24:19 <kamatsu> seeya all
08:24:59 <aavogt> @unmtl Cont r
08:25:00 <lambdabot> err: `Cont r' is not applied to enough arguments, giving `/\A. (A -> r) -> r'
08:25:04 <aavogt> @unmtl Cont r a
08:25:04 <lambdabot> (a -> r) -> r
08:25:25 <augur> anyone familiar with the SAT problem?
08:25:52 <pozic> augur: I'd hope most people in this channel are.
08:25:58 <augur> ;p
08:26:06 <augur> that is, satisfiability
08:26:24 <pozic> augur: anyway, yes... and normally you just ask a question.
08:26:37 <augur> psh, hush. ill ask my questions how i want
08:26:37 <pozic> augur: although, it might be better for #math.
08:26:51 <augur> math is full of math people not programming people
08:27:17 <pozic> augur: the best programmers are mathematicians.
08:27:20 <augur> :P
08:27:25 <augur> hardly
08:27:29 <pozic> augur: just not full time mathematicians ;)
08:27:29 <augur> i know some mathematicians
08:27:32 <augur> they're HORRIBLE
08:27:34 <augur> oh, well
08:27:37 <augur> in THAT case
08:27:45 <pozic> augur: they do it more like a hobby.
08:28:10 <augur> mathematicians do it over continuous domains
08:28:16 <augur> ;o ;o ;o
08:28:23 <Jonno_FTW> what SAT problem?
08:28:28 <augur> k-SAT
08:28:30 <pozic> augur: programming = discrete mathematics.
08:28:37 <Jonno_FTW> what is it?
08:28:38 <augur> i suppose!
08:28:50 <pozic> augur: anyway, so, what do you want to know?
08:28:58 <Saizan> pozic: not if you ask conal
08:29:02 <augur> Jonno_FTW: given some boolean expression, what assignment of variables will make it true
08:29:11 <pozic> Saizan: conal lives in the wrong universe.
08:29:14 <Jonno_FTW> sounds easy
08:29:34 <Saizan> Jonno_FTW: it's NP
08:29:41 <augur> Jonno_FTW: programming the solution is. but so's programming a definition of fib
08:29:47 <pozic> Jonno_FTW: too bad none of the greatest mathematicians has solved it sofar.
08:29:51 <augur> that doesnt make it _computationally_ easy :)
08:30:09 <augur> pozic: actually i was going to ask if disjunctive normal form wouldnt make solving it easier, but wiki says yes so :p
08:30:32 <pozic> augur: uh, wiki is wrong then.
08:30:37 <augur> no, its not
08:30:42 <augur> it doesnt make it not NP
08:30:48 <pozic> augur: I know what I am talking about.
08:31:05 <pozic> augur: DNF does not reduce the problem in an interesting way.
08:31:09 <augur> uh
08:31:28 <augur> well let me rephrase what i mean by that
08:31:44 <augur> it makes the algorithm easier, but not necessarily the computational complexity
08:32:24 <augur> easier than conjunctive normal form. which is to say that while its NP, solving it over a CNJ expression is still harder than solving it over a DNJ expression
08:32:48 <pozic> For people solving SAT nobody cares about a simple algorithm. They only care about the fastest way to results :)
08:32:53 <augur> :P
08:33:23 <augur> why am i typing J instead of F
08:33:24 <augur> :|
08:33:31 <augur> "conj" thats why
08:33:34 <augur> fucking linguistics :|
08:33:35 <pozic> augur: and to any computational complexity theorist, you have just converted the problem from being NP to EXP.
08:33:37 <augur> and i think doing it in DNF is probably faster than doing it in CNF
08:33:51 <pozic> augur: well, I am sure it is not.
08:33:55 <augur> uh really now
08:34:02 <augur> because doing it in DNF is pretty fast i think
08:34:36 <augur> if all your expressions look like (x and !y and z ...) or ...
08:34:38 <pozic> augur: anyway, unless you have an original idea (which you do now not have) stop wasting your time.
08:35:05 <augur> then solving the first is just taking the negatedyness of each variable. { x => true, y => false, z => true, ... }
08:35:19 <augur> im not wasting my time :|
08:35:41 <pozic> augur: yes, you are. You are trying to do something which was known since the beginning of time to be a bad idea.
08:35:48 <augur> im not trying to do anything!
08:36:04 * hackagebot upload: HSHHelpers 0.23 - Convenience functions that use HSH, instances for HSH. (ThomasHartman)
08:36:12 <pozic> augur: well, you are talking about a silly idea and so am I. I will stop doing that now.
08:36:31 <augur> i think wikipedia is correct about DNF being faster than CNF.
08:36:51 <pozic> augur: actually, I doubt wikipedia says that. URL/
08:36:52 <pozic> ?
08:37:03 <augur> http://en.wikipedia.org/wiki/Boolean_satisfiability_problem "SAT is easier if the formulas are restricted to those in disjunctive normal form"
08:37:51 <pozic> augur: yep, that just shows that you failed to understand what is meant.
08:37:58 <augur> OH DO TELL
08:38:06 <pozic> augur: read Introduction to Algorithms and learn something new.
08:38:16 <augur> cmon pozic
08:38:21 <augur> tell me what it means that i dont understand
08:38:28 <pozic> augur: wikipedia sometimes contains information written by people who are confused.
08:38:53 <augur> im waiting pozic
08:39:26 <pozic> augur: you cannot convert between k-SAT and DNF in polynomial time.
08:39:35 <augur> what
08:39:40 <pozic> augur: as I pointed out in my first response already.
08:40:02 <augur> you mean converting from arbitrary expressions into DNF in polynomial time?
08:40:18 <pozic> augur: arbitrary k-SAT expressions, yes.
08:40:30 <augur> ok and? that wasnt what i was asking
08:40:55 <augur> "asking" -- curious about, rather.
08:40:56 <roconnor> is there some ultra clever way to do a topological sort of a DAG without using state-like things?
08:41:12 <opqdonut> roconnor: writer?
08:41:24 <opqdonut> oh, hmm, state for what's visited
08:41:27 <roconnor> ya
08:41:43 <roconnor> solution preferably uses data recursions :D
08:42:08 <pozic> augur: what is your question then?
08:42:33 <augur> pozic: i was curious only about the relative difficult of solving SAT in DNF vs other forms
08:42:55 <augur> especially CNF
08:43:05 <aksel2> hlint can't seem to digest SPECIALISE pragmas... is that a bug?
08:43:09 <taruti> Is there any support for ByteString regions (i.e. like normal strict ByteString but limited to a given monadic region) ?
08:44:19 <pozic> augur: what do you mean by solving SAT in DNF?
08:44:27 <pozic> augur: SAT and DNF are different languages.
08:44:31 <augur> ok let me rephrase that
08:44:33 <Saizan> aksel2: they are SPECIALIZE i think
08:44:37 <aledge> reducing a SAT problem to a boolean expression in DNF?
08:44:42 <gwern> Saizan: thought ghc took both
08:44:44 <augur> finding the satisfiability of an arbitrary expression that's in DNF
08:45:02 <pozic> augur: well, wikipedia already said that's already in P.
08:45:05 <gwern> aksel2: hlint has developed relatively rapidly along with haskell-src-exts in being able to parse haskell. is this with darcs hlint & -exts?
08:45:24 <augur> pozic: well thanks, i didnt know that wiki said it was in P and thats what i was curious about
08:45:27 <pozic> augur: the interesting issue is only that all real world problems are SAT problems and not DNF problems.
08:45:41 <augur> THANK YOU POZIC BUT THAT WASNT WHAT I WAS CURIOUS ABOUT
08:45:48 <aledge> hey guys
08:46:01 <pozic> augur: anything else?
08:46:04 <augur> you start bitching at me that LOL YOU DONT KNOW WHAT YOU'RE TALKING ABOUT
08:46:05 <int-e> augur: calm down, please.
08:46:22 <aledge> yeah calm down, this isn't #solaris
08:46:34 <gwern> augur is still here? did anyone figure out what he was expounding?
08:46:40 <pozic> augur: sure, I am the one not knowing what to talk about. If only you had any idea.
08:46:43 <augur> sorry int-e, i just dont like getting treated like a moron just because the person im talking to doesnt know what i was asking.
08:47:03 <koeien37> it's easy to get misunderstandings. shouting at people trying to explain is not going to help
08:47:07 <papermachine> augur, does that happen a lot?
08:47:16 <int-e> augur: it's an easy mistake to make - assuming that if you quote something from wikipedia, you've also read the rest of the line, which states clearly "This can be checked in polynomial time."
08:47:16 <augur> depends on who i talk to :(
08:47:16 <pozic> papermachine++
08:47:36 <augur> int-e i know. i wasnt even ASKING pozic a question
08:47:48 <augur> i was about to ask a question to the channel, but then i said nevermind i found the answer on wikipedia
08:48:03 <augur> then pozic asked me what i was going to ask and what wiki said, and i explained
08:48:04 <Saizan> augur: we've all seen the log
08:48:14 <medfly> I haven't
08:48:17 <Saizan> augur: and your reaction can't be tolerated anyway
08:48:38 <pozic> augur: something which ends with a question mark is a question in the English language.
08:48:45 <aledge> pozic you're not helping
08:48:50 <benmachine> oh you are all silly sometimes
08:49:01 <pozic> aledge: I was not trying to help.
08:49:09 <aledge> pozic, everybody can tell
08:49:23 <augur> pozic:
08:49:25 <zygoloid> can we set the channel +m for a couple of minutes until everyone forgets about it and moves on? :)
08:49:26 --- mode: ChanServ set +o Saizan
08:49:34 <augur> <augur> pozic: actually i was going to ask if disjunctive normal form wouldnt make solving it easier, but wiki says yes so :p
08:49:34 <augur> <pozic> augur: uh, wiki is wrong then.
08:49:44 <Saizan> stop this discussion or i'll follow zygoloid advice.
08:50:33 <benmachine> @vixen does P = NP?
08:50:34 <lambdabot> isn't it obvious?
08:50:40 <benmachine> :(
08:50:41 <aledge> hahaha wat
08:51:13 <Liskni_si> maybe it is
08:51:16 <int-e> augur: No, it won't make it easier, because the DNF formula will typically be exponentially larger than the original SAT problem. (Maybe somebody said that already.)
08:51:32 <benmachine> lambdabot knows the answers to most of the major problems facing mathematics
08:51:37 <benmachine> but she just doesn't tell us what they are
08:51:46 <aledge> what a c***
08:52:39 <pozic> int-e: (yes, I did. )
08:52:46 <augur> int-e, maybe, i dont know how the two problems compare, and just going by wiki it seems like doing it in DNF is much easier. pozic says tho that getting an arbitrary expression into DNF is exponential time (which i could belief) and hence in general, its not better
08:53:00 <rovar> how do I achieve this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15800#a15800
08:53:09 <rovar> specifically line 8
08:55:13 <benmachine> my guess would be Ctx <$> (newTMVar . MContext <$> newTChan <*> newTChan <*> pure sock <*> pure M.empty <*> pure 0)
08:55:24 <benmachine> hmm
08:55:34 <benmachine> (from Control.Applicative)
08:55:48 <benmachine> you could avoid using so many pures by using let/where to partially apply MContext
08:56:49 <Saizan> composition doesn't work like that
08:57:14 <rovar> oh
08:57:20 <rovar> I could use newTChanIO
08:57:28 <benmachine> oh yeah, types are different
08:57:30 <rovar> keep everything in zie IO monad
08:57:36 <int-e> what's wrong with do context <- MContext <$> ... <*> ... ; Ctx <$> newTMVar context ?
08:58:05 <Saizan> that's how i'd write it too
08:58:13 <benmachine> wait, why does anything need to be in IO?
08:58:32 <Saizan> it actually doesn't afaict
08:58:38 <int-e> (it's not completely applicative because you're applying the result of a computation to another computation, so it's inherently monadic)
08:58:40 <benmachine> doesn't look like it to me
08:59:05 <rovar> the rest of it is in the IO monad, so it is fine if it is, but doesn't have to be
08:59:34 <benmachine> int-e: where do you use the result of any of the computations?
09:00:15 <Saizan> my initial objection was that "newTMVar . MContext <$> .. <*> .. <*> .." is the same as "(newTMVar . MContext) <$> .. <*> .." so it won't work, because MContext takes more than one argument before producing the input to newTMVar
09:00:43 <Saizan> also newTMVar is monadic
09:00:46 <aledge> int-e I think that description of 'monadic' is the best i have seen ever
09:00:48 <Saizan> so you'd need a join
09:00:56 <aledge> something beginners should see
09:01:49 <Saizan> ?type \x -> (newTMVar <$> x)
09:01:50 <aledge> anyway, lunch time
09:01:51 <lambdabot> Not in scope: `newTMVar'
09:02:09 <Saizan> ?type \x -> (Control.Concurrent.STM.newTMVar <$> x)
09:02:10 <lambdabot> Couldn't find qualified module.
09:03:09 <int-e> benmachine: the desired argument of  newTMVar  is a result of a computation involving several  newTChans.
09:03:54 <rovar> grr.. no instance for Applicative STM
09:04:42 <Saizan> use `liftM` and `ap` :)
09:04:51 <rovar> makes sense :)
09:05:15 --- mode: Saizan set -o Saizan
09:05:25 <benmachine> int-e: oh, yeah I suppose so
09:05:32 <int-e> @type (newTMVar <$> (Just <$> newTMVar ()))
09:05:34 <lambdabot> Not in scope: `newTMVar'
09:05:34 <lambdabot> Not in scope: `newTMVar'
09:05:49 <int-e> oh well, it's STM (STM (TMVar (Maybe (TMVar ())))) (note the double STM)
09:07:15 <Berengal> The longer my coding sessions, the more pointfree my code...
09:07:33 <jmcarthur> that's begging for join, and since you have fmap and join in the same expression it looks a lot like bind in there
09:07:57 <int-e> right.
09:07:57 <yaxu1> Ok earlier I asked whether something like this was possible: (Int -> IO a) -> IO (Int -> a) , and the answer is no
09:08:18 <Berengal> yaxu1: Yep, that's impossible
09:08:37 <yaxu1> and now I'm wondering how come [IO a] -> IO [a] is possible, with sequence
09:09:09 <benmachine> let yaxu f = return (const (f 0)) -- :P
09:09:11 <yaxu1> i.e., what's the conceptual different between Int -> a , and [a]?
09:09:28 <jmcarthur> yaxu1: sequence knows what arguments to apply to the "function" by itself
09:09:33 <yaxu1> s/different/difference/
09:09:36 <jmcarthur> yaxu1: (all of them)
09:09:42 <int-e> yaxu1: oh, (Int -> IO a) -> IO (Int -> a) is possible: just evaluate the function at all 2^32 (or whatever) points, and return a function lookup.
09:09:50 <zygoloid> yaxu1: in Int -> IO a, you need extra information to find what IO value you get, but in the case of [IO a] you already know the IO values you're using
09:10:04 <int-e> yaxu1: But nobody in their right mind would do that, while for a finite list this seems entirely reasonable.
09:10:23 <zygoloid> int-e: that would also perform all the actions for all possible Ints up-front :)
09:10:28 <benmachine> sequence in IO is only possible for finite input lists, I suppose
09:10:37 <int-e> zygoloid: so does sequence, in the case of a list
09:10:48 <Berengal> benmachine: Oh, it's quite possible for infinite lists as well, but it won't return
09:10:52 <benmachine> unless you did something weird and unsafe
09:10:57 <zygoloid> benmachine: it works for infinite ones too, but will give an action which can only terminate through exceptions
09:10:59 <int-e> zygoloid: I really believe my analogy was sound.
09:11:12 <Berengal> benmachine: Still, works nicely if you need actions with indexes, sort of thing
09:11:28 <benmachine> Berengal: oh, I suppose so
09:11:41 <Berengal> There's a reason we have 'forever'
09:11:45 <benmachine> but then sequence_ would be just as good
09:11:47 <yaxu1> int-e: ok that makes sense.  in this case the maximum int is actually much smaller than 2^32, more like 16
09:11:50 <zygoloid> int-e: yes, you're right. i'd missed the obvious isomorphism between Nat -> IO a and Stream (IO a) :)
09:12:42 <Berengal> yaxu1: There is a class for things which have sequence: Foldable. It lives in Data.Foldable
09:13:09 <zygoloid> @type let f :: (Int -> IO a) -> IO (Int -> a); f g = fmap const (g 0) in f
09:13:10 <lambdabot> forall a. (Int -> IO a) -> IO (Int -> a)
09:13:12 <Berengal> yaxu1: The typeclassopedia has an introduction to it, which should probably tell you why functions aren't
09:13:27 <Berengal> yaxu1: In the theoretical sense, that is
09:13:29 <dolio> You only gets sequence_ from Foldable. sequence needs Traversable.
09:13:29 <yaxu1> Berengal: yes I've made my type a member of that, and am now trying to make it a member of Data.Traversable
09:14:05 <rovar> here is the result: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15800#a15802   looks pretty nice.
09:14:21 <yaxu1> my type is actually this: data Pattern a = Pattern {at :: Integer -> [a], period :: Integer}
09:14:48 <yaxu1> where 'period' is the maximum input to 'at'
09:15:21 <yaxu1> my problem is I want to be able to turn types like "Pattern (IO String)" into "IO (Pattern String)"
09:16:34 <jmcarthur> eek
09:16:38 <Berengal> yaxu1: Not possible without running all IO actions up front
09:16:58 <benmachine> would it be easier if at was a Map rather than a function?
09:16:59 <Phyx-> 18:12:44 < jmcarthur> eek
09:17:05 <jmcarthur> and in this case that would be too many to be practical, since the function takes an Integer
09:17:07 <Phyx-> that made me laugh, jmcarthur
09:17:08 <Phyx-> :P
09:17:26 <Berengal> jmcarthur: Not if it's constrained. It just means you have to fudge a bit
09:17:53 <jmcarthur> yaxu1: is there no way to avoid needing this?
09:17:53 <yaxu1> yes it's constrained by the period, Integer is wild overkill there...
09:18:03 <jmcarthur> ah!
09:18:21 <Berengal> A Map is a very decent suggestion, I think
09:18:24 <Berengal> Or even an array
09:18:34 <Berengal> The array also carry the bounds implicitly
09:18:36 <yaxu1> some background here: http://yaxu.org/patterns-in-haskell/
09:19:22 <Berengal> rovar: The withSocketsDo should be wrapping your main, unless I remember the documentation for that wrong
09:20:45 <dolio> The datatype is really 'data Pattern a = Pattern { period :: Natural, at :: Finite period -> [a] }'.
09:22:35 <rovar> Berengal, I thought it just had to be run to initialize the sockets before use.
09:23:05 <benmachine> I think the idea is that it will shut them down after use as well
09:23:17 <benmachine> so all your stuff has to be in the middle
09:24:20 <mtnviewmark> I have a question about profiling: I have some code that uses hexpat and text packages --- When I profile it, functions in text are broken out with their own entries in the .profile, but call code in hexpat is simply attributed whatever function of mine calls it
09:24:26 <Berengal> On Windows operating systems, the networking subsystem has to be initialised using withSocketsDo before any networking operations can be used. eg.
09:24:26 <Berengal>  main = withSocketsDo $ do {...}
09:24:34 <mtnviewmark> this is true even if   my code calls hexpat and hexpat calls text
09:24:50 <Berengal> Is what the docs say... I'm using Linux, so I don't what happens if you misuse it
09:24:54 <mtnviewmark> is there a way to either force or supress a given libraries functions in a profile?
09:25:05 <yaxu1> dolio: yes, interesting
09:25:28 <benmachine> heh, the source generated on hackage has withSocketsDo x = x
09:25:45 <koeien37> for Unix-like systems, withSocketsDo = id
09:26:11 <yaxu1> it'd be a bit annoying to have to run all the IO actions though, I'll have to rethink
09:27:16 <yaxu1> that's a lot clearer now though, thanks all
09:31:23 <HugoDaniel> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15803#a15803
09:31:28 <sshc> how does haskell derive instances of functors by default?
09:31:32 <HugoDaniel> is there anyway to do it all in a single pass through the list ?
09:31:38 <HugoDaniel> and improve readability ?=
09:31:45 <HugoDaniel> im using a concatMap of a Map
09:31:46 <jmcarthur> sshc: it doesn't, does it?
09:31:55 <aavogt> ghc-6.12 does
09:31:56 <benmachine> jmcarthur: I think 6.12 does with -XDeriveFunctor
09:31:58 <HugoDaniel> does ghc optimize these kind of stuff ?
09:32:02 <jmcarthur> oh! nice
09:32:20 <benmachine> sshc: there aren't really that many ways of fmapping
09:32:38 <benmachine> instances of Functor tend to be either easy or impossible
09:33:02 <Phyx-> HugoDaniel: well, a couple of things
09:33:11 <joe1> when I do the below in ghci, I do not see the file created. Any thoughts, please? do I have to flush the buffer or something?
09:33:14 <Phyx-> you're doing two maps
09:33:21 <joe1>  writeFile (head dplus_destination_files) (show $head $head dplus)
09:33:22 <Phyx-> and you could just compose the operations
09:33:27 <HugoDaniel> oh, how ?
09:33:30 <Phyx-> and secondy, the if is not needed
09:33:33 <benmachine> I don't know how it does it, but you can imagine just finding the relevant type variables in the RHS of the expression, and transforming them in the obvious way
09:33:34 <joe1> dplus :: [[[Int]]]
09:33:47 <joe1> head dplus_destination_files :: [Char]
09:33:54 <sshc> benmachine: if the data type consists of only integers, wouldn't deriving it cause fmap to map over all of the integers?
09:34:06 <Phyx-> you could replace it by ((++"\n").genOneYear y (y==selectie++d))
09:34:20 <HugoDaniel> here is the paste without the line errors: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15804#a15804
09:34:42 <benmachine> sshc: remember that Functors are kind * -> *
09:34:46 <HugoDaniel> oh, yes
09:34:53 <aavogt> HugoDaniel: you do have performance problems with that code, or you want to know how to improve it regardless?
09:34:57 <benmachine> so it has to have a type parameter, and that's the only thing fmap can touch
09:35:02 <Phyx-> HugoDaniel: Right, the whole first line is just concatMap ((++"\n").genOneYear y (y==selectie++d))
09:35:07 <Phyx-> HugoDaniel: Right, the whole first line is just concatMap ((++"\n").genOneYear y (y==selectie++d)) list
09:35:07 <HugoDaniel> aavogt: i want to learn how to be a better programmer :)
09:35:23 <mtnviewmark> I just added a revision to your original post
09:35:27 <mtnviewmark> one pass w/concat map
09:35:28 <benmachine> Phyx-: not a fan of whitespace? :P
09:35:31 <mtnviewmark> concatMap
09:35:45 <Phyx-> benmachine: not generally no :P
09:35:55 <mtnviewmark> the trick is that the arguments to the outer function are available in the where clause functions
09:36:00 <mtnviewmark> no need to keep passing htem
09:36:27 <jbourne> can ne one tell where to getr the adobe 0 day hack?
09:36:30 <aavogt> HugoDaniel: then writing the code to make a single list traversal (I mean re-associating the ++, not merging the map and concatMap), it will probably be less clear
09:37:03 <HugoDaniel> yes, better programmer = writing code in a more readable fashion
09:37:16 <HugoDaniel> i dont care much for optimization :/ i guess i should...
09:37:23 <benmachine> depends on your use case
09:37:29 <joe1> when I do the below in ghci, I do not see the file created. Any thoughts, please? do I have to flush the buffer or something?
09:37:31 <mtnviewmark> I added a revision to your new paste
09:37:33 <joe1>  writeFile (head dplus_destination_files) (show $head $head dplus)
09:37:34 <joe1> head dplus_destination_files :: [Char]
09:37:38 <joe1> dplus :: [[[Int]]]
09:37:38 <aavogt> if you're interested, look at   ShowS  instead of ++
09:37:45 <aavogt> @type ShowS
09:37:46 <lambdabot> Not in scope: data constructor `ShowS'
09:37:50 <aavogt> @type shows
09:37:51 <lambdabot> forall a. (Show a) => a -> String -> String
09:37:52 <mtnviewmark> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15804#a15806
09:37:59 <HugoDaniel> thanks mtnviewmark
09:38:01 <HugoDaniel> :)
09:38:04 <Phyx-> mtnviewmark: i beleive your code doesn't preserve the newlines though, it should be unlines $ map genOneYear list
09:38:11 <benmachine> HugoDaniel: for example, if ls took twice as long, how many people would notice?
09:38:12 <aavogt> so to do the concatenation as function composition, and not as (++)
09:38:20 <mtnviewmark> I added the \n to the second vesion I posted
09:38:33 <mtnviewmark> I just put it in genOneyear
09:38:36 <Phyx-> i only see one
09:38:47 <joe1> @info FilePath
09:38:47 <lambdabot> FilePath
09:38:51 <joe1> > @info FilePath
09:38:52 <lambdabot>   <no location info>: parse error on input `@'
09:38:54 <joe1> > :info FilePath
09:38:55 <lambdabot>   <no location info>: parse error on input `:'
09:38:58 <joe1> :info FilePath
09:39:08 <HugoDaniel> thanks a lot :)
09:39:10 <joe1> > :t writeFile
09:39:11 <lambdabot>   <no location info>: parse error on input `:'
09:39:14 <mtnviewmark> Phyx - are you looking at Hugo's original hPaste, or his second?  :-)
09:39:15 <joe1> :t writeFile
09:39:16 <lambdabot> FilePath -> String -> IO ()
09:39:57 <benmachine> all this ++ show year ++ stuff makes me think of printf
09:40:15 <benmachine> (which can do the job of sprintf)
09:40:16 <joe1> can someone help me, please?
09:40:20 <mtnviewmark> actually, it makes me think of using hexpat's Format module
09:40:43 <benmachine> joe1: try :info FilePath in ghci
09:41:04 <benmachine> (or :i FilePath)
09:41:07 <joe1> benmachine: I know that FilePath is just another name for string.
09:41:22 <joe1> I am trying to understand why writeFile in ghci is not writing a file.
09:41:32 <joe1> just want to know if I am missing something.
09:41:38 <joe1>  writeFile (head dplus_destination_files) (show $head $head dplus)
09:41:43 <joe1> dplus :: [[[Int]]]
09:41:45 <benmachine> oh, right
09:41:48 <joe1> head dplus_destination_files :: [Char]
09:41:58 <benmachine> it should be, I suppose you should check if ghci is in a strange directory
09:42:24 <Phyx-> HugoDaniel: and someone also told you to do this http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15804#a15807
09:42:27 <Phyx-> :)
09:42:35 <joe1> ok, thanks. will check it out.
09:42:39 * Phyx- goes back to readin his paper
09:42:51 <benmachine> joe1: writeFile should create the file immediately without any further action
09:43:32 <ReiMoN> 'Listen http://www.youtube.com/watch?v=vQArG8njGFo Dj Alkalino vs Don Reimon guitars'
09:55:51 <joe1> benmachine: just checked the dir and you are correct. I had the directories messed up..
10:00:20 <joe1> I have the code at http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15809#a15809 working. I think I can get rid of the getdata function by putting the actions in a list. Any hints that can help me, please?
10:04:42 <aavogt> joe1: so what is the problem exactly?
10:05:36 <joe1> aavogt: there is no problem. I am just thinking that I can refactor out the getdata function. wondering if you think that it is possible?
10:06:05 <aavogt> I see no redundancy in the  getdata function
10:06:12 <joe1>  think I can put it into a list of actions
10:06:18 <aavogt> there is redundancy in where you've used it
10:06:25 <Cale> Why GHC.Word.Word8 and not just Word8?
10:06:42 <aavogt> where the only difference is dplus vs dminus
10:06:46 <Cale> Is there some reason not to use Data.Word?
10:07:14 <joe1> the file name pattern is different between dplus and dminuse
10:07:16 <joe1> the file name pattern is different between dplus and dminus
10:07:19 <aavogt> Cale: they are the same thing after all?
10:07:27 <joe1> aavogt: yes.
10:07:43 <aavogt> joe1: so make a function that takes that difference as a parameter
10:08:02 <joe1> yes, I can do that.
10:08:18 <benmachine> you could move the mapM into getdata
10:08:34 <benmachine> (even the sort, if you wanted)
10:08:43 <aavogt> move everything into getdata ;)
10:09:12 <Saizan> nah, moving in is never useful :P
10:09:21 <Saizan> just write another function, they are free!
10:09:33 <Cale> next8bytes is factored rather strangely...
10:10:55 <Cale> I would separate it as   map (concatMap splitToBits) . chunk 8
10:12:18 <leimy> Would an implementation of monads in Go be Gonads?
10:12:55 <Cale> Go doesn't have an expressive enough type system to make that anything but painful.
10:13:27 <Cale> You wouldn't gain any benefit, because Go doesn't have any support for parametric polymorphism.
10:13:47 <aavogt> the board game
10:14:46 <Ke> so has anyone investigated seccomp with haskell?
10:14:49 <zygoloid> newtype Gonad a = Gonad { runGonad :: State GoBoard a } deriving (Monad, MonadState)
10:15:30 <Cale> joe1: The filename pattern is different, but that's all that changes, so you could just make that a function parameter
10:15:53 <joe1> Cale: i am doing that as we speak.. thanks.
10:16:25 <aavogt> I was thinking more about encoding the algebraic structure in the actual pebbles zygoloid
10:17:35 <Ke> apparently it was discussed here
10:18:12 <zygoloid> aavogt: on a finite go board? or an infinite idealized one? :)
10:18:28 <p_l> infinite idealized go board? o_O
10:18:47 <gwern> it would work. you can still score territory
10:19:54 <DekuNut> Probably really simple but, in this code: http://codepad.org/EiFYsUMs   <- I realise solving this just requires Show a => in the instance, but why does it NEED it? Why can't it throw an error later if I supply a list that contains types that aren't instances of Show?
10:20:49 <kmc_> DekuNut, "later"
10:20:51 <kmc_> meaning runtime?
10:20:55 <Stinger_> cause Haskell has a static type system, rather than a dynamic one?
10:21:04 <kmc_> or, you mean when you try to use that instance statically?
10:21:05 <benmachine> DekuNut: because half of the point of strict type checking is you catch that kind of problem now
10:21:37 <jmcarthur> why would you knowingly want to attempt to show a value which is not showable?
10:21:38 <aavogt> you could use Data.Dynamic....
10:21:45 <DekuNut> Yes but, when I use it later, for example: display [mynonshowabletypes,moreofthesametype]
10:21:53 <kmc_> i think the question here is not about dynamic types but about throwing out unsuitable instances at compile time
10:21:55 <Cale> Getting an error at runtime and trying to debug it is about a million times more irritating than getting one at compile time and being told exactly why by the compiler.
10:21:56 <jmcarthur> DekuNut: that wouldn't type check anyway
10:22:02 <jmcarthur> DekuNut: lists are homogeneous
10:22:27 <DekuNut> homogeneous?
10:22:29 <jmcarthur> DekuNut: oh i misinterpreted that code
10:22:45 <jmcarthur> DekuNut: i thought you were saying it has elements of varying types
10:22:58 <aavogt> HLists could be filtered based on the instances supported?
10:23:01 <DekuNut> Nah sorry
10:23:07 <Cale> DekuNut: What's wrong with writing  instance Show a => IMustBreak [a] Char where ...  anyway?
10:23:17 <jmcarthur> DekuNut: why would you attempt to display a list of elements that don't have a show instance?
10:23:28 <kmc_> DekuNut, are you asking why, when the compiler sees dispay [x] for non-Show x, why it can't just throw out your [a] Char instance and continue?
10:23:43 <DekuNut> Cale, nothing is wrong with it, I'm just a little confused as to why it NEEDS it, seeing as later when I supply an argument
10:23:52 <DekuNut> It could find out then just as well right?
10:23:55 <zygoloid> DekuNut: you mean, why it doesn't deduce it?
10:23:56 <aavogt> I see an equivalent result by overlapping instance, but somebody here must have the genious to see around such restrictions
10:24:26 <DekuNut> zygoloid, more of, why does it have to deduce it there, I mean it as in
10:24:30 <kmc_> DekuNut, think of it this way: type inference does not apply when you provide an explicit type, and the head of an instance provides explicit types for its members
10:24:33 <Cale> DekuNut: Well, it needs to know what it will need in order to build the instance for the specific type a
10:24:54 <int-e> dcoutts_: is there a way to tell cabal-install to ignore the preferred-versions file?
10:25:01 <DekuNut> Oh right, thanks Cale, that makes sense
10:25:05 <zygoloid> DekuNut: well, i think it would be a reasonable question to ask why contexts aren't deduced for instances, and i have no idea what the answer is, or even whether there's a good one
10:25:18 <dcoutts_> int-e: no, but explicit constraints always take precedence
10:25:47 <kmc_> imo it's nice to be able to look at an instance declaration and see exactly when it will apply
10:25:54 <Cale> It would be possible to deduce the constraints, but magically adding those constraints without telling the programmer seems a bit sneaky.
10:25:56 <kmc_> but in principle they could be inferred
10:26:10 <aavogt> zygoloid: sorry about ignoring your question... I think infinite boards are probably necessary, since finite boards have finite numbers of states (and there are more than a finite number of Monads?)
10:26:16 <dcoutts_> int-e: what's the issue?
10:26:17 <sshc> >
10:26:20 <DekuNut> Well it wasn't even inferred that I was wondering
10:26:35 <DekuNut> Oh actually, bare with me
10:26:59 <zygoloid> DekuNut: well, type inferrence works best when it can split your program up into little pieces where the types can be inferred seperately and independently.
10:27:11 <int-e> dcoutts_: I was looking for a way to say "give me the latest version of HaXml, no matter what preferred-versions says". Using '--preference=HaXml>=0.1' actually works.
10:27:13 <Stinger_> not on the first date
10:27:58 <dcoutts_> int-e: oh, yes and --preference should set the new preference, rather than merge with the old one as one would do with constraints
10:27:58 <int-e> dcoutts_: while cabal install 'HaXml>1.3' didn't do what I wanted, which was upgrade 1.19.7 to 1.20
10:28:31 <DekuNut> Right ok, I see now, thanks again, I have to say, this is by for the MOST helpful channel I've been in on freenode
10:28:35 <DekuNut> Thanks again
10:28:36 <dcoutts_> int-e: ah, mm, interesting example.
10:29:36 <dcoutts_> int-e: could you file a ticket with that example, I'm not actually sure I understand why it's doing that.
10:29:55 <int-e> sure
10:30:02 <dcoutts_> ta
10:31:23 <dcoutts_> I would have hoped that with the constraint >= 1.3, that then since the preference does not distinguish between the versions 1.19.7 and 1.20 that it'll go to the next fallback preference which is to use the latest.
10:31:23 <int-e> dcoutts_: errrr. user error. 1.3 is not larger than 1.13 ...
10:31:34 <dcoutts_> int-e: ahhh
10:31:35 <joe1> > :t chunk
10:31:36 <lambdabot>   <no location info>: parse error on input `:'
10:31:40 <int-e> dcoutts_: specifying HaXml>=1.14 works.
10:31:41 <joe1>  :t chunk
10:31:58 <joe1> > t chunk
10:31:59 <lambdabot>   Not in scope: `chunk'
10:32:00 <dcoutts_> int-e: ok, excellent
10:32:06 <joe1> > chunk
10:32:07 <lambdabot>   Not in scope: `chunk'
10:32:09 <int-e> dcoutts_: I'll not file a report then :)
10:32:16 <dcoutts_> int-e: :-)
10:32:20 <joe1> @hoogle chunk
10:32:21 <lambdabot> Data.ByteString.Lazy.Internal chunk :: ByteString -> ByteString -> ByteString
10:32:21 <lambdabot> Data.ByteString.Lazy.Internal Chunk :: ByteString -> ByteString -> ByteString
10:32:21 <lambdabot> Network.HTTP.Base chunkedTransfer :: BufferOp a -> IO (Result a) -> (Int -> IO (Result a)) -> IO (Result ([Header], a))
10:33:15 <dcoutts_> int-e: at some point I really need to split those preferred versions into actually recommended and backwards compat hacks.
10:33:55 <int-e> dcoutts_: or perhaps I will, as a minor improvement: when cabal-install says a package is already installed, it doesn't tell me which version of the package it means.
10:34:27 <dcoutts_> int-e: yes, "foo-1.0 is already installed" would be good
10:35:53 <zygoloid> http://hackage.haskell.org/trac/ghc/ticket/3766 <-- do people think this is a ghc bug or a bug in the haskell report? (or is the bug report mistaken?)
10:36:06 <dcoutts_> int-e: it's not totally trivial but what you'd do is to compare the install plan against the list of packages that the user requested be installed, if the plan says we're using an installed version then we emit the message. Or perhaps we only emit the message for all packages if we end up installing none.
10:36:34 <dcoutts_> not sure whether or not you want the message when you do cabal install foo bar, and it only ends up (re)installing one of them
10:37:09 <mornfall> dcoutts_: Hm, while you are around, since cabal does not notice changes in -D flags, does it notice a change in .h file?
10:37:12 <sshc> how do I enable usage of recursive modules?
10:37:25 <mornfall> That's #included somewhere...
10:37:27 <sshc> module A where data Foo = Foo Bar
10:37:34 <dcoutts_> mornfall: not if ghc --make doesn't
10:37:51 <aavogt> sshc: if you can avoid it by refactoring your code, that would probably be easier
10:38:37 <sshc> module B where import A data Bar = Int Int (PerhapsSomethingFromA); etc
10:38:44 <sshc> aavogt: I can't avoid it by refactoring my code
10:39:04 <aavogt> otherwise you have to write some .hs-boot files that contain type signatures that will break the cycles
10:39:07 <sshc> aavogt: the only workaround is putting things that belong in module B in A
10:39:31 <sshc> aavogt: .hs-boot files?
10:39:47 * sshc googles
10:39:58 <aavogt> sshc: http://www.haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html#mutual-recursion
10:40:16 <mornfall> dcoutts_: It seems ghc --make doesn't...
10:40:28 <mornfall> *sigh*
10:40:51 <dcoutts_> mornfall: one day we'll have a perfect dependency tracking build system :-)
10:40:54 <mornfall> So basically there's no way to use CPP-based conditional compilation based on configuration flags, I reckon?
10:41:54 <dcoutts_> mornfall: mm, that may well be true, for the case of reconfiguring. So it affects devs, not users.
10:42:00 <mornfall> As in, if -ffeaturex needs to conditionally compile something, then -f-featurex without an intermediate clean wil lstill have that problem.
10:42:15 <mornfall> s/problem/macro defined/. Whatever.
10:42:56 <joe1> contents :: ByteString ; chunk :: Data.ByteString.Internal.ByteString -> ByteString -> ByteString
10:42:57 <mornfall> It could as well affect users that build from version control.
10:43:06 <joe1> how can I used chunk
10:43:31 <joe1> I am thinking : "chunk contents 8", but there are no errors.
10:43:34 <joe1> I am thinking : "chunk contents 8", but there are errors.
10:45:13 <Saizan> joe1: chunk wants two bytestrings as inputs
10:45:34 <Saizan> joe1: so 8 won't work
10:45:57 <joe1> I am trying this:  map (concatMap splitToBits) . chunk 8
10:46:20 <Saizan> then that chunk above is not the function you want.
10:47:27 <joe1> just curious, is there another chunk?
10:50:31 <joe1> or should not bother with this code?
10:51:47 <joe1> Cale: any thoughts, please?
10:51:59 <Stinger> it might be useful, if you tell people what you are actually trying to do
10:52:06 <joe1> I cannot seem to use "chunk 8" here. did you have something else in mind?
10:52:59 <joe1> Stinger: sorry, i had posted a file earlier and was trying out some feedback that I received. do not bother... I will just leave the code as-is..
10:53:55 <int-e> dcoutts_: personally I think it should be tied to the warning, i.e. the case where cabal-install did nothing at all.
10:54:54 <dcoutts_> int-e: so when you cabal install foo bar and it finds the latest foo is already installed then we just install bar and don't warn at all, yes?
10:55:04 <int-e> dcoutts_: yes.
10:55:10 <dcoutts_> seems reasonable
10:56:47 <dcoutts_> int-e: feel free to file a ticket so we remember what we thought best
10:57:49 <int-e> dcoutts_: see #623
10:58:06 <DekuNut> I'm curious, how many people in here are math majors? Or have taken some sort of math side course?
10:58:49 <dcoutts_> int-e: ta
10:59:02 <jmcarthur> DekuNut: my CS major required a math minor
10:59:18 <jmcarthur> i wouldn't say the requirements for the minor were very steep at all though
10:59:18 <dcoutts_> DekuNut: tricky question, there's over 600 people here :-)
10:59:42 <DekuNut> Rofl, yeah dcoutts_, but hardly over 600 active people :o
10:59:49 * benmachine is an undegraduate mathematician
10:59:50 <nbathum> anyone with a cs degree had to take some math. what kind of math courses are you referring to?
10:59:51 <aledge> I took math
11:00:22 <DekuNut> nbathum, well, any I guess. I was just curious as to how much math experience the average haskell-goer took
11:00:25 <mental> I have a math degree
11:00:35 <mental> CS is for losers :)
11:00:43 <jmcarthur> DekuNut: i bet most of us don't have a whole lot of maths, actually
11:00:54 <aledge> i have a school related question, actually
11:01:09 <aledge> how many of you are in some sort of phd program involving programming languages
11:01:23 <kmc_> PL research is depressing :/
11:01:28 <aledge> haha
11:01:33 <aledge> why do you say that
11:01:35 <Stinger> so that's one so far :)
11:01:37 <int-e> nbathum: linear algebra, logic, elementary calculus, abstract algebra, a bit of combinatorics and not enough statistics ... ymmv.
11:01:53 <aledge> because you do research and then everyone still uses java?
11:01:54 <sshc> aavogt: how do I hs-boot when two data types refer to each other?
11:01:58 <nbathum> int-e: yea that sounds about like what ive got
11:02:06 <sshc> aavogt: data Foo = Bar and data Bar = Foo
11:02:15 <benmachine> they don't refer to each other :P
11:02:23 <sshc> aavogt:  data Foo = Foo Bar and data Bar = Bar Foo
11:02:28 <aavogt> yeah those don't
11:02:30 <xle> is it possible to define a typeclass that expects a parse :: a -> IO [b] and then instantiate an ADT with the class and define that function as a specific type like Page -> IO [ListItem]?
11:02:31 <kmc_> because it takes many years for established obviously-good ideas from PL research to make their way into any kind of practical code
11:02:32 <benmachine> please excuse my pedantry
11:02:43 <int-e> data Foo = Bar Foo Bar; data Bar = Foo Bar Foo -- confusion!
11:02:44 <sshc> it's not exactly like that, but they don't work in separate modules
11:02:50 <xle> I keep getting Couldn't match expected type `m' against inferred type `ListItem' errors
11:02:59 <sshc> how do I enable them to work when each module depends on each other?
11:03:01 <aavogt> sshc: any reason you wouldn't want to define:   data Foo = Foo Foo | Bar Foo ?
11:03:14 <aavogt> sshc: any reason you wouldn't want to define:   data Bunny = Foo Foo | Bar Foo ?
11:03:20 <int-e> xle: show code, but perhaps it's just a missing return ...
11:03:21 <kmc_> and because people are constantly designing new languages without paying any attention to either the theory or the history of what has worked and what hasn't
11:03:37 <aledge> kmc_, I see
11:03:46 <aledge> kmc_, but actually doing the research?
11:04:03 <sshc> aavogt: I'm not sure what you're trying to say, honestly
11:04:09 <sshc> aavogt: but I have two data types
11:04:18 <sshc> aavogt: and each one should be in a separate module
11:04:20 <benmachine> kmc_: is there any field of science where the gap between discovery and benefit *isn't* measured in years?
11:04:26 <sshc> aavogt: each one refers to the other data type
11:04:38 <aledge> benmachine, probably a smaller gap in mech e
11:04:39 <ufopp> how can define a new type that's an int and takes only certain values?
11:04:42 <xle> OK, so I have a Parseable typeclass for all record types that contain html page information and can be parsed into some other data type. I have two functions that I want to implement for that class, a parse and a parseCommit that also commits the result into a DB.
11:04:43 <aledge> benmachine, or EE
11:04:44 <aavogt> sshc: the data Foo I wrote is the same as your    data Foo = Foo Bar; data Bar = Bar Foo
11:05:06 <benmachine> ufopp: why should it be an int?
11:05:12 <medfly> benmachine: mathematics
11:05:20 <medfly> benmachine: it's actually measured at least in decades
11:05:26 <medfly> benmachine: :)
11:05:40 <aavogt> sshc: in the link I gave you earlier to the ghc manual, you have to   import {-# SOURCE #-} ModuleName(Foo(..)), and add the appropriate  ModuleName.hs-boot
11:05:41 <benmachine> heh
11:05:51 <xle> Problem is all parses populate different ADTs... I guess I coudl solve it by defining a single algebraic type with alternate records
11:06:01 <ufopp> benmachine, because I want to keep the values that type can take fixed to certain integers
11:06:05 <kmc_> aledge, i wouldn't know... i'm not a PL researcher
11:06:24 <xle> so then I would not have to have parse: a -> IO [b], but I would have it as Page -> IO [ParseResult]
11:06:25 <int-e> ufopp: One idea is to define a module that defines newtype MyInt = MyInt Int, but only exports the type and a smart constructor: myInt 42 = MyInt 42; myInt _ = error "invalid value for MyInt"; fromMyInt (MyInt i) = i;
11:06:26 <aledge> kmc_, oho
11:06:57 <benmachine> ufopp: if the number of possible values are sufficiently small, you could have them each as separate constructors and derive Enum
11:07:37 <ufopp> benmachine, I want 0 to 360 as the range for one type
11:07:43 <int-e> ufopp: There are no subtypes in Haskell - but at least we can simulate them.
11:07:54 <benmachine> then you probably want int-e's solution
11:08:09 <sshc> aavogt: I might have something like "data A = A Int Int Bar", and in the other module I might have "data B = B Int Int A".  In A.hs-boot, I wrote "module A where data A = A Int Int Bar" (without anything else that is defined in the real A.hs), but GHC complains that it can't find B when it compiles A.hs-boot.
11:08:27 <sshc> aavogt: sorry, replace the first "Bar" with "B"
11:08:54 <benmachine> and the second, presumably
11:08:55 <sshc> err, all of the "Bar"s
11:08:57 * benmachine pedant again
11:09:02 <ufopp> int-e -- I'm afraid I don't undertand your solution completely. How do I define the type and be able to math, such as div, plus, etc.
11:09:07 <sshc> no, I'm just having issues typing today
11:09:25 <sshc> so I'll say what I said again but without any mistakes (hopefully)
11:09:37 <benmachine> ufopp: well, it depends what behaviour you want for 180 + 181
11:09:45 <sshc> aavogt: I might have something like "data A = A Int Int B", and in the other module I might have "data B = B Int Int A".  In A.hs-boot, I wrote "module A where data A = A Int Int B" (without anything else that is defined in the real A.hs), but GHC complains that it can't find B when it compiles A.hs-boot.
11:10:04 <ufopp> benmachine: mod behavior
11:10:14 <benmachine> well you have several choices there
11:10:31 <b_jonas> sshc: did you import B in A.hs-boot?
11:10:51 <benmachine> you can use GeneralizedNewtypeDeriving which is a ghc extension
11:11:07 <b_jonas> sshc: also, alternately, put them into one file or define one using a nullary typeclass (I know those don't exist, but emulate using a dummy type parameter)
11:11:28 <benmachine> then you can do newtype MyInt = MyInt Int deriving (Show, Eq, Integral, Num) and then you'll have + and - and the Integral functions on your new type
11:11:48 <benmachine> then you do the mod behaviour in fromMyInt
11:12:01 <benmachine> or you could define your own instances for Num and Integral
11:12:25 <ufopp> benmachine, thanks for the ideas...let me explore them first.
11:12:27 <benmachine> newtype MyInt = MyInt Integer would probably be better
11:13:01 <sshc> b_jonas: if I import B in A.hs-boot, a module cycle is formed
11:14:46 <sshc> I think this is a GHC limitation because I think the 98 standard permits mutually recursive modules
11:15:38 <int-e> ufopp: you have to provide instances for the type classes in question - Num for addition and so on. Something like this will work: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15810#a15810 (untested)
11:17:30 <b_jonas> sshc: did you try adding just 'data B;' in A.hs-boot?
11:17:42 <b_jonas> sshc: I'm not really sure how hs-boot workd
11:19:03 <int-e> ufopp: and apparently it does work, except for the inconsistency between fromDeg (in the Show instance) and deg, and the lone 'instance' in the middle of the code (which was meant to become a Bounded instance ... but that didn't materialise).
11:19:38 <aavogt> b_jonas, sshc: that does work
11:20:36 <aavogt> quite funny how you have support for recursive modules as:    A.hs-boot:   data A = A Int Int B; data B
11:21:01 <aavogt> when you could have just written:   data A = A Int Int B; data B = B Int Int A
11:21:49 <b_jonas> or classes.
11:22:02 <aavogt> or    type AB = (Bool,[(Int,Int)])
11:22:13 <aavogt> or some Stream type
11:22:30 <aavogt> since that list could be finite, while A and B never stop
11:26:28 <ufopp> int-e: thanks much, that's exactly what I was hunting for.
11:26:57 <nbathum> can anyone help with my type error?     Couldn't match expected type `[Char]'            against inferred type `Map.Map k ([Char], ExpType) -> [Char]'
11:27:37 <opqdonut> seems like you forgot an argument
11:27:43 <opqdonut> of type Map k ([Char], ExpType)
11:31:22 <sshc> aavogt: no it doesn't
11:31:52 <sshc> aavogt: Foo is exported by the hs-boot file, but not exported by the modul
11:32:33 <sshc> aavogt: ^ is the error message
11:33:29 <aavogt> sshc: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15811#a15811
11:33:45 <int-e> aavogt: or you could simply have written this, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15812#a15812 ;-)
11:33:50 <aavogt> of course you can leave C out
11:35:00 <aavogt> int-e: or just put the two definitions in one module ;)
11:35:10 <burp> @oeis 2,4,6,8,10,12,14,16,18,20,22,24,26,30,32,34,36
11:35:11 <lambdabot>  Sequence not found.
11:35:35 <aavogt> and import whatever is necessary into the two other modules that apparently define functions on those datas
11:36:40 <int-e> aavogt: (this was yet another alternative to "or some Stream type". it was not a serious suggestion.)
11:37:30 <aavogt> int-e: so the Fix2L and Fix2R are just there to get infinite types, right?
11:38:40 <int-e> right. Together they encode a fixed point of  (x, y) |-> (a x, b y) - Fix2L finds the left component, while Fix2R finds the right component.
11:39:36 * int-e is amazed that the Show instance works ... but it does :-)
11:46:29 <mornfall> dcoutts_: How bad idea it is to include an autogenerated module in a library? As in, have imports of it in the library? I guess I shouldn't list it in other-modules? Or should? (That seems to be the reason why we opted for -DFOO instead of autogenerated module in the first place...)
11:47:03 <dcoutts_> mornfall: all modules must be listed, however they are generated
11:47:19 <mornfall> So other-modules it goes?
11:47:38 <dcoutts_> mornfall: yep, since you don't want it exported in the public interface
11:48:04 <mornfall> And it is OK if the module does not exist prior to configure, I suppose?
11:48:25 <mornfall> (It seems to work, but I haven't tried too hard to break it...)
11:48:36 <dcoutts_> mornfall: the one gotcha I can think of is sdist
11:49:01 <dcoutts_> mornfall: I think there's a special hack to make that work for the module that Cabal auto-generates
11:49:34 <mornfall> Exactly...  Setup: Error: Could not find module: Version with any suffix:
11:49:49 <mornfall> So what now?
11:49:53 * Francine Takako's Jukebox: Thrice - Hoods On Peregrine [03:31m/256Kbps/44KHz]
11:50:03 <mornfall> We need working sdist, as we need working version information. :|
11:50:45 <dcoutts_> mornfall: I thought you'd been autogenerating a version module in darcs for ages
11:51:26 <mornfall> dcoutts_: Yes, but that was only used by the *program* not by library.
11:51:30 <Vitka> @oeis 1,3,6,10,15
11:51:31 <lambdabot>  Triangular numbers: a(n) = C(n+1,2) = n(n+1)/2 = 0+1+2+...+n.
11:51:31 <lambdabot>  [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,2...
11:51:31 <nbathum> opqdonut: thanks for pointing me in right direction... i had indeed forgotten to supply an argument
11:51:42 <Vitka> Hmm.
11:51:46 <dcoutts_> mornfall: ahh, yes that lets you get away with not listing all the other-modules.
11:51:50 <mornfall> dcoutts_: And we relied on -DPACKAGE_VERSION for the lib, which of course breaks due to --make/cabal not noticing rebuilds.
11:52:05 <mornfall> But.
11:53:51 <mornfall> The problem here is that even if Version.hs exists in dist/, it's not enough to satisfy sdist.
11:54:43 <dcoutts_> mornfall: I would suggest adding an hook to generate it, however cabal sdist ignores that, though it'd work with runghc Setup sdist
11:55:18 <dcoutts_> since sadly the current interface for runghc Setup sdist is useless for cabal
11:55:37 <mornfall> dcoutts_: We already have a hook, but generate what?
11:56:03 <mornfall> The only thing I can think of is to fiddle with the package description to filter out the Version before calling the stock sdist hook.
11:56:13 <mornfall> Which is, like, super-ugly.
11:56:23 <mornfall> But will do if that's the only way to make it work.
11:56:31 <dcoutts_> mornfall: presumably you want to distribute the Version.hs in tarballs
11:56:50 <dcoutts_> or do you want to regenerate it at build time?
11:57:19 <dcoutts_> mornfall: nothing you do in the sdist hook will make any difference to people using "cabal sdist"
11:57:26 <mornfall> Well, we have to generate it at build time when building from non-tarballs.
11:57:33 <mornfall> cabal sdist does not work at all in darcs
11:58:40 <mornfall> I can't generate src/Version.hs in sdist anyway, since once its generated, cabal will ignore the one under dist/ ... so if you run sdist once, building from the same directory (presumably a darcs checkout) will afterwards produce wrong version info
11:58:47 <mornfall> And sdist packs the current directory, not a copy thereof.
11:58:59 <mornfall> Well, I could remove it again, but that's quite fragile, too.
11:59:35 <dcoutts_> mornfall: no, for shipped pre-generated modules (like alex, happy) they get put into the tarball in dist, not in the src dir
12:00:13 <mornfall> dcoutts_: Maybe, but things listed in other-modules are not sought under dist/.
12:00:22 <mornfall> dcoutts_: I have Version.hs there and it still fails.
12:00:49 <dcoutts_> mornfall: um, they are looked for under dist, that's where pre-processed .hs files end up
12:01:00 <dcoutts_> maybe you're not putting it in the right place
12:01:02 <mornfall> Maybe elsewhere than dist/build/autogen then.
12:02:44 <mornfall> There doesn't seem to be any other suitable path under Distribution.Simple.BuildPaths... anywhere else I should look?
12:03:00 <mornfall> (I am using autogenModulesDir now.)
12:03:24 <dcoutts_> mornfall: the problem is not that it's not found, but the pre-process modules bit is looking for a source module
12:03:32 <dcoutts_> and it does not find any
12:03:37 <dcoutts_> because there is none
12:04:36 <dcoutts_> hmm, maybe that's not correct
12:06:01 <dcoutts_> mornfall: afaics, putting Version.hs in dist/build/autogen should work for the configure and build stages.
12:06:49 <mornfall> Yes, that works, but not for sdist.
12:08:04 <dcoutts_> mornfall: ah ok, so what Cabal does for the module it generates itself, is that it just filters it out at the sdist step when it does the pre-processing / copying stage
12:08:33 <dcoutts_> which clearly isn't nice, since it's not something users can easily replicate for their own generated modules.
12:08:41 <dcoutts_> the other option is to treat it like a pre-processor
12:08:50 <dcoutts_> which there is more uniform support for
12:09:05 <dcoutts_> ie "generate" Version.hs from Version.blah
12:10:02 <dcoutts_> mornfall: can you please make sure that the individual problems here are filed in the cabal trac, or for existing ones that are a PITA for darcs, please comment on them to that effect. It helps us prioritise.
12:10:56 <dcoutts_> mornfall: for example there's a ticket about cabal sdist not doing the same thing as runghc Setup sdist, but I don't think there's a comment saying "this is a major confusion for darcs users/hackers"
12:12:14 <mornfall> I'll try. Not today, since I am almost out of time and I want to fix up the issues with 1.6 for now anyway.
12:12:27 <mornfall> Anyway, thanks for the info, I have it almost working now.
12:18:12 <kmc_> is there an updated ETA on Haskell Platform for GHC 6.12?
12:21:02 * benmachine appears to have 11 installations of haskell-src-exts not counting a local darcs copy
12:21:27 <benmachine> I suppose it's a good idea not to throw things away
12:21:45 <monochrom> You need GC for packages.
12:22:29 <Raevel>  perhaps youll miss the glory days of 0.5.7 someday
12:22:50 <aavogt> still on hackage... if it's still up
12:23:22 <int-e> monochrom: is there an obvious choice for the roots for that GC?
12:24:20 <monochrom> Yes. The user's own projects.
12:24:28 <FreeNslaved> Hals Audio show just began if anyone wants to listen in.......    Http://www.BoldVoices.TV    channel 12
12:24:35 <dcoutts_> kmc_: the plan is roughly for this month, we'll certainly get a beta out, a final depends on the timing of 6.12.2
12:24:45 <kmc_> cool
12:25:02 <Raevel> oh that's earlier than i expected <3
12:25:09 <monochrom> "19 days before new Haskell Platform"? :)
12:26:37 <burp> there is also gtk2hs and c2hs for 6.12 still missing right?
12:26:57 <dcoutts_> burp: right
12:32:12 <HugoDaniel> ok, im going to ask something completly stupid
12:32:31 <joe1> I need some design advice. I have a file with a list of 0's and 1's. I want to parse the file and print out some specific messages. I had tried parsec before, but could not really get the hang of it. Any suggestions, please?
12:32:35 <HugoDaniel> ...is there any "pure" random function ? :P
12:33:04 <CosmicRay> HugoDaniel: I thought that time was just a function from one pure state of the universe to the next? ;-)
12:33:10 <camio> joe1: did you try working through the parsec tutorial?
12:33:20 <monochrom> I think it is not stupid, it is controversial. Whole fleets of soldiers and ships die for it.
12:33:26 <HugoDaniel> :D
12:34:22 <monochrom> What does random mean to you?
12:34:28 <CosmicRay> HugoDaniel: to be sure, there are those in philosophy that argue essentially that.  whether or not true randomness exists may not be a settled question.
12:35:00 <CosmicRay> (though there are some reasons to believe it does exist, but as far as I know, hasn't been proven.)
12:35:26 <noteventime> Is mapping a a newtype constructor over a list totally optimised away?
12:35:40 <benmachine> what you want is a function where the origin of the data is sufficiently obfuscated that the output is unpredictable
12:35:45 <Cale> HugoDaniel: There are invertible functions such that, only knowing the output, it is arbitrarily difficult to determine what the input must have been.
12:35:58 <HugoDaniel> Cale: like the hashing functions ?
12:36:17 <Cale> Well, hashing functions aren't invertible, but yes, like that.
12:36:32 <thoughtpolice> noteventime: yes. GHC completely eliminates newtype constructors when generating code; they are only there to make the type different, essentially (so you can enforce better constraints, etc)
12:36:44 <thoughtpolice> at least AFAIK - someone may be more up to date here
12:36:53 <noteventime> thoughtpolice: I know newtype constructors are optimised away
12:37:21 <noteventime> The question was about (for example) mapping a newtype constructor over a list
12:37:28 <Cale> There are also things like Blum Blum Shub, which is a pseudorandom number generator that, from looking at the sequence of outputs, determining the generator state is as hard as integer factorisation.
12:37:35 <HugoDaniel> hmm
12:37:52 <thoughtpolice> noteventime: you mean i.e. map Constr list ?
12:38:10 <HugoDaniel> i just want to generate a table of random normalized vectors (where a vector is (Double, Double, Double))... and that got me thinking...
12:38:14 <thoughtpolice> (where Constr is the newtype constructor obviously)
12:38:40 <noteventime> thoughtpolice: Yea, anything which involves some computation; deconstructing e.t.c.
12:38:42 <Cale> ah
12:38:57 <benmachine> HugoDaniel: well, you probably don't really want random vectors, just arbitrary ones
12:39:21 <monochrom> In math channels, some people ask "how do you solve equations?" Eventually, they confess they just mean "x-4=5".
12:39:25 <HugoDaniel> hmm, well... random with an even statistical distribution would be nice :)
12:39:33 <HugoDaniel> :D
12:39:35 <Cale> HugoDaniel: Well, the traditional way to handle this from a practical perspective is to have the PRNG state be a value that you pass along, and whenever you construct a random value, you also get a new PRNG
12:39:41 <HugoDaniel> sorry about that monochrom :)
12:39:54 <Cale> (this is how System.Random works)
12:39:54 <benmachine> monochrom: well the former question is much more interesting
12:40:06 <HugoDaniel> hmm, i just want to generate the table once, and then its static for life... read-only
12:40:19 <Cale> Sure.
12:40:57 <monochrom> "how do you solve equations?" actually is a sensible question. But we know the answer: incomputable. The broad question has a broad answer.
12:41:03 <Cale> as long as you don't lose a reference to it, it shouldn't be garbage collected.
12:41:40 <HugoDaniel> okey, ill jump to it then, ill pass the state along...
12:41:43 <monochrom> So "how do you make random numbers?" should also have a broad negative answer. You can't.
12:41:49 <benmachine> monochrom: the answer I'd give would be something like, you try to find ways to reverse operations applied to your whatsit
12:41:55 <Cale> HugoDaniel: There are fancier things you can do as well though
12:42:06 <benmachine> and if you can't you can't, but quite often you can
12:42:08 <HugoDaniel> like using IO ?
12:42:19 <Cale> HugoDaniel: Like using a random monad.
12:42:36 <Cale> http://hackage.haskell.org/package/MonadRandom
12:42:42 <HugoDaniel> hmmm
12:42:47 <HugoDaniel> that seems interesting...
12:43:02 <Cale> That helps cut down the noise of threading the generator state along.
12:43:11 <noteventime> I'm not sure on how to test
12:43:21 <HugoDaniel> yes, thats very nice
12:43:30 <Cale> But doesn't do any magic beyond that. You still need a StdGen (or other generator) to kick things off.
12:43:36 <thoughtpolice> noteventime: looking at GHC core output, it doesn't seem like 'map Constr list' would be optimized to, for example just 'list'
12:44:27 <thoughtpolice> the results still keep around the C type; but that might just be due to the triviality of my test
12:44:30 <thoughtpolice> hold on...
12:44:48 <HugoDaniel> btw, talking about monads, maybe i can "mask" this MonadRandom inside my own monad
12:45:03 <c_wraith> I was surprised by the interface to MonadRandom.  I thought it would give an interface to calling functions g -> (a, g) in a manner similar to acessing state in MonadState, but it doesn't really appear to.
12:45:16 <HugoDaniel> MyMonad just threads the random state along side some other stuff i need
12:46:46 <pchiusano> hey i have a question about haskell type families
12:46:47 <aavogt> RandomMonadT
12:46:59 <kmc_> pchiusano, cool
12:47:02 <aavogt> Cale: I can has ^^ for all monad libs?
12:47:54 <pchiusano> if I have class Foo c where { type Elem c :: * }, cann I say instance Foo [a] { type Elem String = Int } ?
12:48:24 <seanmcl> How do you use unicode IO with ghc 6.12.1?  I was using utf8-string in 6.10, but now my code is broken.  Even basic stuff doesn't seem to work:  Prelude> print "φ"
12:48:24 <seanmcl> "?"
12:48:39 <pchiusano> in other words, does the fact that I use the same name for the index type in the class declaration mean that i have to have that type in the implementations?
12:48:45 <thoughtpolice> noteventime: from more tests, it seems that GHC does not optimize away the traversals
12:48:52 <thoughtpolice> noteventime: but it will unbox everything given the chance, at least
12:48:58 <pchiusano> i don't know if this question makes any sense, I am reading some haskell code that uses this and trying to understand it
12:49:03 <noteventime> thoughtpolice: Ok, thanks
12:49:22 <b_jonas> pchiusano: how is that about type families?
12:49:30 <noteventime> Hmm
12:49:35 <pchiusano> b_jonas: oh, maybe it isn't
12:49:43 <b_jonas> oh, it is
12:49:44 <b_jonas> I see
12:49:49 <b_jonas> it has type inside the class
12:49:57 <pchiusano> b_jonas: yes
12:50:22 <copumpkin> associated types = type families
12:50:29 <copumpkin> it's very thin syntactic sugar
12:51:14 <kmc_> pchiusano, yes, when you say "class Foo c where { type Bar c }", the two c must be the same
12:51:16 <kmc_> in any instance as well
12:53:04 <pchiusano> kmc_: so really, that syntax is kind of just a way of expressing a functional dependency, without exposing the dependent parameter as a type parameter of the class?
12:53:10 <pchiusano> or is there more to it
12:53:18 <kmc_> it's much like a fundep, yes
12:53:26 <noteventime> thoughtpolice: So one should use unsafeCoerce?
12:53:26 <kmc_> i won't say they're interchangeable in all ways
12:53:45 <pchiusano> kmc_: in what ways are they not interchangeable? :)
12:54:37 <kmc_> well, the syntax for one
12:54:46 <kmc_> is different in a nonlocal way
12:55:06 <kmc_> rather than saying (Foo a b) => X a -> Y b, you say (Foo a) => X a -> Y (T a)
12:55:51 <monochrom> seanmcl: It is invalid on the count that «String» is not «[c]». If you modify to «instance Foo String» you need some extension. If you modify to «instance Foo [Char]» you need some other extension.
12:56:26 <jvoorhis> conal: hello
12:56:30 <jvoorhis> conal: i've looked around for a good explanation of "non-flat" types but i haven't found a satisfactory definition
12:57:06 <seanmcl> monochrom: sorry, I don't understand.  String is no longer [Char]?
12:57:08 <jvoorhis> conal: when you talk about improving values, the term has a sort of intuitive ring to it, but i wondered if you could make it more precise :)
12:57:23 <kmc_> it's [Char], not forall c. [c]
12:58:13 <kmc_> pchiusano, however you can have some parameters to your associated synonym that aren't typeclass parameters, in some sense.  because you can declare it to have a kind not *.  e.g. class Foo c where { type Bar c :: * -> * }; instance Foo () where { type Bar () = Maybe }
12:58:25 <seanmcl> kmc_: still not sure how this is related to being able to print unicode characters.
12:58:41 <seanmcl> that worked with utf8-string before.
12:58:45 <kmc_> um hm
12:58:49 <kmc_> i think convos are getting crossed
12:58:54 <seanmcl> ha
12:58:58 <kmc_> i thought monochrom was responding to pchiusano
12:59:11 <seanmcl> oh, he wrote my name.  probably i should have read directly above
12:59:14 <kmc_> pchiusano, but you cannot say ... where { type Bar () a = Maybe a }
12:59:31 <kmc_> maybe i am confused
12:59:58 <kmc_> pchiusano, if you need the indices of your type to correspond not exactly to the indices of the typeclass, you can break it out to an independent asstype
13:00:15 <copumpkin> asstype!
13:00:18 <monochrom> seanmcl: String=[Char] but not the point.
13:00:20 <pchiusano> kmc_: i see, interesting
13:01:41 <seanmcl> monochrom: would you please elaborate a bit on your answer.  I just want System.IO.UTF8 to work the same as it did in 6.10 :)  That is System.IO.print "φ" should print the unicode phi
13:02:21 <monochrom> Oops.
13:02:59 <lpsmith> jvoorhis, flat types aren't too tricky:   a type is flat iff the the complete partial order that the type represents only contains two kinds of values:  _
13:02:59 <monochrom> pchiusano: It is invalid on the count that «String» is not «[c]». If you modify to «instance Foo String» you need some extension. If you modify to «instance Foo [Char]» you need some other extension.
13:03:13 <lpsmith> jvoorhis, flat types aren't too tricky:   a type is flat iff the the complete partial order that the type represents only contains two kinds of values:  _|_ and fully-formed values without _|_
13:03:47 <lpsmith> jvoorhis, for example,  Int is a flat type,  there is no such thing as a "partial integer"
13:03:53 <monochrom> seanmcl: ghc 6.12 looks at some environment variables to decide which encoding to use for System.IO
13:04:30 <monochrom> And to add more fun, ghci can very well use a different encoding than what System.IO decides.
13:04:57 <kmc_> yes, asstype
13:05:00 <kmc_> that is the preferred nomenclature
13:05:03 <kmc_> didn't you get the memo?
13:05:11 <lpsmith> jvoorhis, [()] is a non flat type,   it has the values ⊥,  [],  ⊥:⊥,  ():⊥, ():[],  ⊥:[],  ⊥:⊥:⊥,  etc.
13:05:26 <jvoorhis> lpsmith: in other words, flat types are atomic?
13:05:53 <lpsmith> jvoorhis, for a suitable definition of atomic,  yes
13:06:11 <jvoorhis> hm, right :)
13:06:14 <Taejo> where atomic == flat :)
13:06:27 <Taejo> I wouldn't call that a usual definition of atomic, though
13:06:46 <jvoorhis> it's Russell's precision thing at work again :)
13:07:13 <Taejo> data T = C !Int !Int -- T here is a flat type, but I wouldn't call it atomic
13:07:35 <camio> type X = Int; newtype Y = Y Int; data Z = Z Int. X and Y are flat, Z is not.
13:07:46 <jvoorhis> Taejo: good point – in other words, strictness can determine flatness?
13:07:57 <Taejo> jvoorhis: absolutely
13:08:09 * jvoorhis is catching on
13:08:56 <Taejo> flatness is all about where _|_ can appear, and strictness stops _|_ from appearing higher up in the definedness order
13:09:03 <lpsmith> newtype MyInt = Int Int   is a flat type
13:09:12 <lpsmith> data MyInt = Int Int   is not
13:09:32 <jvoorhis> camio: and X is flat because it *is* Int, and Y is flat because newtype constructors must be strict
13:09:40 <lpsmith> data MyInt = Int Int   contains  ⊥,   Int ⊥,  and Int 0,  Int 1,  etc.
13:09:41 <jvoorhis> thanks :)
13:10:03 <lpsmith> hehe,  sorry for repeating you, camio
13:10:24 <Taejo> jvoorhis: do you see what makes flat types "flat" (in a diagrammatic sense)?
13:10:40 <jvoorhis> Taejo: i think so – it means _|_ appears once and only once in the information ordering
13:10:57 <Taejo> jvoorhis: I mean, can you see why the word "flat" is appropriate?
13:10:59 <camio> jvoorhis: yes
13:11:30 <jvoorhis> i'm new to information ordering and denotational semantics in general, so i might use a wrong term here and there
13:11:53 <jvoorhis> but in the diagrammatic sense, it's "flat" because the structure of the ordering contains no "diamond patterns"
13:12:16 <sproingie> acyclic
13:12:28 <sproingie> meh not the right term for directed
13:12:30 <Taejo> jvoorhis: no types contain diamond patterns -- their orders always form trees
13:12:32 <camio> Taejo: I think it'd be better called "as flat as Haskell gets", since we can take away the _|_ value in some languages.
13:12:52 <jvoorhis> Taejo: then how do you describe this? http://conal.net/blog/pictures/semantic-lattice.png
13:13:10 <lpsmith> Taejo,  what about ():⊥,  ⊥:[],  and ():[]   :-)
13:13:21 <Taejo> jvoorhis: of course, you are right
13:13:29 <Taejo> thanks
13:13:47 <jvoorhis> it's easy to visualize it as a tree, though
13:14:08 <jvoorhis> but maybe that's not very useful
13:14:16 <Taejo> but not only are there no diamonds in a flat type, there are no elements with depth 3
13:14:37 <Taejo> everything is either _|_, or an atom (ah, so atomic does make sense)
13:16:35 <lpsmith> Taejo,  yeah, I thought the word "atomic" seemed to fit,  though I'm sure there are many definitions of "atomic" floating around in CS :-D
13:17:35 <lpsmith> Hopefully CS will start killing off some of the more idiosyncratic vocabularies and move to a more standardized vocab like math
13:17:51 <lpsmith> Although math isn't perfect in that regard either
13:17:56 <lpsmith> It takes time
13:20:51 <lpsmith> Taejo:  if data T = C !Int !Int is not atomic,   is Int atomic?   After all, it's made up of bits.
13:21:39 <monochrom> quarkic
13:21:50 <jvoorhis> lpsmith: that's why my usage of "atomic" wasn't very precise :) i was relying on a lot of assumptions
13:22:27 <dolio> Nah. The definition is clearly 'data Int = -9223372036854775808 | ... | 9223372036854775807.
13:22:39 <monochrom> har
13:25:28 <jvoorhis> so, if two values have differing information content and a common upper bound, can they be considered equal?
13:25:35 <kmc_> (+) :: Int -> Int; 0 + 0 = 0; 0 + 1 = 1; 1 + 0 = 1; 1 + 1 = 2; ...
13:25:42 <kmc_> err Int -> Int -> Int even
13:25:48 <kmc_> > let 2 + 2 = 5 in 2 + 2
13:25:49 <lambdabot>   5
13:26:17 <lpsmith> jvoorhis, they would be unifiable, but Haskell doesn't have unification
13:26:25 <lpsmith> logic programming languages have unification
13:26:45 <kmc_> :t unamb
13:26:46 <lambdabot> Not in scope: `unamb'
13:26:48 <lpsmith> and,  oddly enough,  unification is often writen =
13:27:19 <monochrom> I am not sure what is «two values have differing information content and a common upper bound». Examples?
13:27:27 <jvoorhis> lpsmith: so one could consider conal's lub operator diy unification?
13:27:38 <lpsmith> probably,  I haven't really looked at lub
13:27:42 <Gracenotes> > let f :: Complex Double -> (); f 1 = () in f (1 :+ 0)
13:27:43 <lambdabot>   ()
13:27:52 <jvoorhis> monochrom: i'm thinking again of the graph at http://conal.net/blog/pictures/semantic-lattice.png
13:28:13 <lpsmith> monochrom:   I interpreted that sentence as something like (1,⊥)  (⊥, True),  they both have an upper bound (1,True)
13:28:26 <lpsmith> Yeah, basically the same thing
13:28:53 <monochrom> But they are better off not equal.
13:28:59 <Vitka> Sorry for interrupting type discussion, but if I want to make a function that boils to primitive table lookup like f a = b; f c = d, what would be efficient way of implementing it? Guards, pattern matching, etc, or will it be optimized by compiler all the same?
13:29:04 <OltreIrc`50589> !LIST
13:29:13 <copumpkin> Gracenotes: that's a deep function
13:29:58 <lpsmith> monochrom:  but the difference is weakly observable in Haskell
13:30:08 <Gracenotes> copumpkin: I'm just wondering, if pattern matching a Num is controlled by fromInteger, which can contain arbitrary code...
13:30:18 * Gracenotes needs to look at the stg dumpage
13:30:20 <lpsmith> I mean,  if you use ==,  ghc will attempt to ground both terms and then perform a comparison without ⊥
13:30:49 <Saizan> Gracenotes: f 1 = () ~> f x | x == fromInteger 1 = ()
13:31:00 <HugoDaniel> what is the haskell remainder operator ?
13:31:02 <lpsmith> >  (1, fix id) == (fix id, True)
13:31:06 <lambdabot>   mueval-core: Time limit exceeded
13:31:11 <lpsmith> >  (1, fix id) `lub` (fix id, True)
13:31:12 <lambdabot>   Not in scope: `lub'
13:31:15 <lpsmith> aww
13:31:16 <Gracenotes> Saizan: hm. it requires Eq? Well, Num does.
13:31:16 <Saizan> HugoDaniel: either mod or rem
13:31:17 <Zao> HugoDaniel: rem or mod if on integers.
13:31:24 <HugoDaniel> thanks
13:31:30 <Saizan> Gracenotes: yeah, it goes via Eq
13:31:34 <Zao> HugoDaniel: Different behaviours for negative numbers.
13:31:53 <Zao> Corresponding division operators are quot and div.
13:31:58 <taruti> Is there a way to simulate linear types with GHC 6.12?
13:32:02 <lpsmith> Vitka:  Pattern matching will probably be better than guardds
13:32:05 <Gracenotes> at least it pattern matches more specifically (much much much more efficiently) when it's a concrete known type, Int-like
13:32:36 <copumpkin> Zao: contrarespectively?
13:32:46 <lpsmith> Vitka: optimizing guards is a harder problem than patterns,  and I don't think ghc is particularly sophisticated in that manner
13:32:48 <HugoDaniel> is there a function to change from [a] to [(a,a,a,a)] ?
13:32:56 <copumpkin> HugoDaniel: no
13:32:59 <HugoDaniel> zip4 :P
13:33:02 <copumpkin> no such function could ever exist
13:33:03 <Gracenotes> pattern matching does compile down nicely
13:33:05 <HugoDaniel> oops zip requires two lsts
13:33:12 <copumpkin> EVER
13:33:15 <copumpkin> NEVER
13:33:17 <Gracenotes> copumpkin: D:
13:33:29 <lpsmith> @djinn [a] -> [(a,a,a,a)]
13:33:29 <lambdabot> Error: Undefined type []
13:33:30 <HugoDaniel> never forever ?
13:33:40 <HugoDaniel> hmm okey
13:33:49 <Zao> copumpkin: Depends on if you adhere to my or Sai`zan's ordering.
13:33:57 <lpsmith> :t map (\a -> (a,a,a,a))
13:33:58 <lambdabot> forall a. [a] -> [(a, a, a, a)]
13:34:03 <copumpkin> lpsmith: omg
13:34:09 <lpsmith> hahaha
13:34:13 <HugoDaniel> :)
13:34:16 <tensorpudding> hmm, @djinn doesn't know about [a]?
13:34:17 <copumpkin> you disproved my thesis!
13:34:18 <HugoDaniel> thats not what i meant
13:34:21 <jvoorhis> lpsmith et al: thanks for walking me through that
13:34:25 <monochrom> There are a million function to change from [a] to [(a,a,a,a)]. Here is one: \_ -> []. Do you like it?
13:34:26 <HugoDaniel> :D
13:34:34 <lpsmith> jvoorhis, you are welcome
13:34:35 <monochrom> s/function/functions/
13:34:38 <jvoorhis> lub makes more sense now, and so does seq
13:34:46 <Gracenotes> copumpkin: to the halls of academic shame with you
13:34:52 <copumpkin> I am in a hall
13:34:56 <copumpkin> in an academic building
13:35:00 <HugoDaniel> okey, from [1..12] to [(1,2,3,4), (5,6,7,8) ...
13:35:01 <copumpkin> and have lots of shame
13:35:08 <Gracenotes> they're metaphorical
13:35:08 <copumpkin> HugoDaniel: nope, no such function exists
13:35:22 <copumpkin> HugoDaniel: what would [1..11] map to?
13:35:36 <jvoorhis> but could definedP on http://conal.net/blog/posts/merging-partial-values/ be written more simply like this? defined a = a `seq` True
13:35:50 <HugoDaniel> Nothing :)
13:35:54 <Zao> copumpkin: Sneak in bottoms where they will cause most pain?
13:35:58 <jvoorhis> afaict it's the same thing, but polymorphic and more concise
13:37:41 <monochrom> HugoDaniel: I recommend writing it yourself.
13:37:50 <lpsmith> @let foo (a:b:c:d:es) = (a,b,c,d) : foo es ;  foo _ = []
13:37:51 <lambdabot>  Defined.
13:37:57 <lpsmith> foo [1..12]
13:38:00 <Saizan> jvoorhis: yes
13:38:05 <lpsmith> > foo [1..12]
13:38:06 <lambdabot>   [(1,2,3,4),(5,6,7,8),(9,10,11,12)]
13:38:08 <lpsmith> > foo [1..11]
13:38:10 <copumpkin> zomg
13:38:10 <lambdabot>   [(1,2,3,4),(5,6,7,8)]
13:38:12 <Gracenotes> don't make it fail
13:38:20 <copumpkin> omgz
13:38:22 * copumpkin faintz
13:38:30 <HugoDaniel> :)
13:38:32 <HugoDaniel> very nicee
13:38:33 <HugoDaniel> ahah
13:38:56 <medfly> @let bar (a:b:c:d:es) = (a,b,c,d) : bar es ; foo xs = xs
13:38:57 <lambdabot>  <local>:3:40:
13:38:58 <lambdabot>      Multiple declarations of `L.foo'
13:38:58 <lambdabot>      Declared at: <local...
13:39:05 <lpsmith> @google Theorems for Free!
13:39:05 <medfly> @let bar (a:b:c:d:es) = (a,b,c,d) : bar es ; bar xs = xs
13:39:08 <lambdabot> http://citeseer.ist.psu.edu/wadler89theorems.html
13:39:09 <lambdabot>  <local>:3:49:
13:39:09 <lambdabot>      Occurs check: cannot construct the infinite type: t = (t,...
13:39:15 <medfly> er
13:39:20 <joe1> > :t concatMapM
13:39:21 <medfly> @let bar (a:b:c:d:es) = (a,b,c,d) : bar es ; bar xs = (xs):[]
13:39:21 <lambdabot>   <no location info>: parse error on input `:'
13:39:22 <lambdabot>  <local>:3:49:
13:39:23 <lambdabot>      Couldn't match expected type `(t, t, t, t)'
13:39:23 <lambdabot>             a...
13:39:27 <medfly> fuck this.
13:39:28 <lpsmith> preflex,  google Theorems for Free!
13:39:33 <joe1> @src concatMapM
13:39:34 <lambdabot> Source not found. I've seen penguins that can type better than that.
13:39:37 <lpsmith> hmm
13:39:38 <medfly> @google theorems for free!
13:39:41 <joe1> @hoogle concatMapM
13:39:41 <lambdabot> http://citeseer.ist.psu.edu/wadler89theorems.html
13:39:41 <lambdabot> No results found
13:39:44 <copumpkin> joe1: doesn't sound particularly interesting
13:39:48 <medfly> :(
13:39:58 <copumpkin> :t concatMap
13:40:00 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
13:40:04 <joe1> copumpkin: isn't there a concatMapM?
13:40:14 <copumpkin> no, but what type would you like it to have?
13:40:50 <joe1> that's ok.. I can work around it..
13:41:13 <copumpkin> :t sequence . concatMap
13:41:14 <lambdabot>     Couldn't match expected type `[m a]'
13:41:14 <lambdabot>            against inferred type `[a1] -> [b]'
13:41:14 <lambdabot>     Probable cause: `concatMap' is applied to too few arguments
13:41:23 <copumpkin> :t (sequence .) . concatMap
13:41:24 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => (a1 -> [m a]) -> [a1] -> m [a]
13:41:30 <copumpkin> is that what you want?
13:43:29 <glguy> :t \ f xs -> concat <$> traverse f
13:43:30 <lambdabot> Not in scope: `traverse'
13:43:30 <glguy> :t \ f xs -> concat <$> traverse f xs
13:43:31 <lambdabot> Not in scope: `traverse'
13:43:44 <lpsmith> Anyway,  HugoDaniel,  you should consider checking out Theorems for Free!
13:43:47 <copumpkin> :t \ f xs -> concat <$> Data.Traversable.traverse f xs
13:43:49 <lambdabot> forall a a1 (f :: * -> *). (Applicative f) => (a1 -> f [a]) -> [a1] -> f [a]
13:43:58 <glguy> sequenceA <$> traverse f xs
13:44:14 <joe1> copumpkin: thanks
13:44:33 <glguy> no sense in tying yourself to a Monad if you aren't using any of the power ;)
13:44:40 <copumpkin> yeah
13:44:49 <copumpkin> I wish the default sequence were the applicative one
13:47:19 <glguy> perhaps:    fold <$> traverse f xs
13:47:26 <glguy> is "fold" the most "generic" concat?
13:48:09 <lpsmith> @let bar (a:b:c:d:es) = (a,b,c,d): bar es ;  bar (a:b:cs) = (a,b,a,b) : bar cs ; bar (a:[]) = (a,a,a,a) ; bar [] = []
13:48:11 <lambdabot>  <local>:1:89:
13:48:11 <lambdabot>      Couldn't match expected type `[(t, t, t, t)]'
13:48:11 <lambdabot>            ...
13:48:56 <lpsmith> @let bar (a:b:c:d:es) = (a,b,c,d) : bar es ;  bar (a:b:cs) = (a,b,a,b) : bar cs ; bar (a:[]) = (a,a,a,a) : [] ; bar [] = []
13:48:57 <lambdabot>  Defined.
13:49:03 <lpsmith> > bar [1..11]
13:49:05 <lambdabot>   [(1,2,3,4),(5,6,7,8),(9,10,9,10),(11,11,11,11)]
13:49:16 <lpsmith> There would be lots of ways to handle the end cases
13:51:24 <joe1> :t group
13:51:26 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
13:51:52 <joe1> @hoogle group
13:51:53 <lambdabot> Data.ByteString group :: ByteString -> [ByteString]
13:51:53 <lambdabot> Data.List group :: Eq a => [a] -> [[a]]
13:51:53 <lambdabot> Data.ByteString.Char8 group :: ByteString -> [ByteString]
13:52:02 <Stinger> > bar [1..12]
13:52:03 <lambdabot>   [(1,2,3,4),(5,6,7,8),(9,10,11,12)]
13:53:56 <HugoDaniel> anyone going to zurich for the hackaton ? will it be worthwhile for a noob ?
13:54:16 <Baughn> @pl \a b c d e f g h i j k l m n o -> h e l l o
13:54:16 <lambdabot> const (const (const (const (const . const . ((const . const . const . ((const . const) .)) .) . flip flip id . (ap .) . flip id))))
13:54:30 <lpsmith> HugoDaniel, I'm not,  but you should consider going if you want,  I don't see what it could hurt
13:55:03 <monochrom> it could hurt the purse
13:55:08 <HugoDaniel> lpsmith: well... i dont want to go there and feel like im stalling things up...
13:55:09 <lpsmith> true
13:55:24 <HugoDaniel> yes, and it has to be economicaly viable
13:55:54 <lpsmith> HugoDaniel, I'm kinda assuming you are in Europe somewhere
13:56:06 <lpsmith> So...
13:56:16 <HugoDaniel> yes
13:56:47 <joe1> I have a list of Int. I want to find the least of them. Is there a function that can do it?
13:56:52 <kmc_> :t minimum
13:56:53 <lambdabot> forall a. (Ord a) => [a] -> a
13:56:53 <benmachine> europe is quite big :P
13:56:54 <koeien37> :t minimum
13:56:55 <lambdabot> forall a. (Ord a) => [a] -> a
13:57:02 <benmachine> :t minimum
13:57:04 <lambdabot> forall a. (Ord a) => [a] -> a
13:57:11 <joe1> thanks, guys.
13:57:13 <HugoDaniel> im turkish
13:57:15 <HugoDaniel> eheh nahh
13:57:18 <benmachine> > minimum []
13:57:19 <lambdabot>   * Exception: Prelude.minimum: empty list
13:57:22 <ehird> So what's the most Haskellish way to parse options? http://www.haskell.org/haskellwiki/GetOpt is rather undecided.
13:57:23 <benmachine> eek
13:57:28 <lpsmith> I've not been to a hackathon, but I seriously doubt you'll stall things up.   Worst case most of the material will go over your head,  and you are out of your money
13:57:41 <benmachine> that's not a great case
13:57:44 * gwern is frustrated ticket 3239 is still open
13:57:51 <gwern> who do I have to fellate around here??
13:57:52 <copumpkin> ehird: ndm has something nice
13:57:55 <copumpkin> gwern: me
13:57:58 <HugoDaniel> ok, tomorrow ill decide if i buy the ticket for the hackaton or not, thanks
13:58:06 <kmc_> when is this hackathon?
13:58:08 <gwern> ehird: getopt works pretty well, once you understand how it works. see mueval's code for a hoepfully clear example
13:58:12 <ehird> copumpkin: helpful :)
13:58:14 <gwern> copumpkin: O RLY
13:58:17 <ehird> gwern: I understand how geopt works
13:58:23 <copumpkin> ehird: http://community.haskell.org/~ndm/cmdargs/
13:58:28 <copumpkin> ehird: much nicer :)
13:58:29 <gwern> ehird: well then. what's the issue?
13:58:31 * copumpkin unzips
13:58:32 <ehird> oh I just read about that thing like... yesterday
13:58:39 <ehird> and thought sweet that's totally cool
13:58:44 <ehird> and then… forgot
13:59:02 <copumpkin> :)
13:59:06 <ehird> i'm kind of dumb :)
13:59:56 <copumpkin> gwern: http://hackage.haskell.org/trac/ghc/ticket/3239 ?
14:00:11 <gwern> copumpkin: no, this is Control.Monad.Void
14:00:13 <gwern> *void
14:00:28 <gwern> 3292
14:00:31 <gwern> oops
14:00:41 <lpsmith> heh
14:00:55 <copumpkin> ah
14:01:13 <lpsmith> gwern, I was going to ask if you were still using PPC or if you were developing for e.g. the X Box
14:01:39 <lpsmith> GHC's deteriorating support for PPC finally pushed me off of it
14:01:45 <copumpkin> gwern: I think you need to fellate at least one of the simons, maybe both
14:01:53 <copumpkin> gwern: and augustss
14:01:55 <copumpkin> maybe hudak
14:02:43 <gwern> despair! despair! this world of laggardly commitals has driven me to despair!
14:02:52 * gwern hangs self from nearest repo
14:09:30 <Saizan> and yet, he's still here
14:09:30 <ehird> ghost! ghost!
14:09:30 <jkramer> Ahoy
14:09:30 * gwern moans. COMMMMIIITTTSSSSS
14:09:30 <jkramer> Is there a version of Data.Char.toUpper that works with umlauts like ä/Ä?
14:09:30 <trofi> > map toUpper "äöå"
14:09:30 <lambdabot>   "\196\214\197"
14:09:30 <trofi> > text $ map toUpper "äöå"
14:09:30 <lambdabot>   ÄÖÅ
14:09:30 <jkramer> Hmm
14:09:30 <Stinger> @ty text
14:09:30 <lambdabot> String -> Doc
14:09:30 <jkramer> Why doesn't that work for me?
14:09:30 <Saizan> wrong encoding?
14:09:30 <trofi> maybe, it's ghc version dependant
14:09:30 <Saizan> which version of ghc are you using?
14:09:30 <gwern> that'd be my bet
14:09:30 <ehird> Do you need mtl to install the Haskell Platform?
14:09:30 <gwern> jkramer: you get gibberish when doing it?
14:09:30 <jkramer> No, it's just returned as the lower case character
14:09:30 <jkramer> The Glorious Glasgow Haskell Compilation System, version 6.10.3
14:09:30 <jkramer> Hmm, wait a second
14:09:30 <lpsmith> > System.Info.compilerVersion
14:09:30 <lambdabot>   Not in scope: `System.Info.compilerVersion'
14:09:30 <jkramer> Where is that "text" function located?
14:09:31 <lpsmith> > compilerVersion
14:09:31 <lambdabot>   Not in scope: `compilerVersion'
14:09:31 <lpsmith> heh
14:09:31 <koeien37> Data.Text
14:09:31 <gwern> ghc uses 'towupper' ffi call, whatever that is
14:09:31 <koeien37> @where text
14:09:31 <lambdabot> I know nothing about text.
14:09:31 <koeien37> I use Data.Text.pack
14:09:31 <Zao> gwern: Standard library wchar.h.
14:09:31 <koeien37> to widechar upper
14:09:31 <gwern> Zao: 'way with you! I speak not your Morgul-tongue
14:09:32 <koeien37> that should work[tm]
14:09:59 <Zao> Eew, C99.
14:10:09 <limpac> hela
14:10:13 <Zao> The behavior of towupper() depends on the LC_CTYPE category of the current locale. This function is not very appropriate for dealing with Unicode characters, because Unicode knows about three cases: upper, lower and title case.
14:10:17 <Zao> Sounds ... suboptimal :)
14:11:03 <jkramer> There's no text in Data.Text, only Text :)
14:11:03 <c_wraith> grrr.  I'd *really* like to load this module in ghci
14:11:04 <lpsmith> Zao:  there is the turkish mail bug ;-)
14:11:30 <c_wraith> but if I try, I get a ghci panic, (the 'impossible' happened)
14:11:51 <c_wraith> linkBCO: >= 64k insns in BCO
14:12:03 <limpac> zedicus the wiz of the first oder
14:12:18 <lpsmith> Zao, http://msmvps.com/blogs/jon_skeet/archive/2009/11/02/omg-ponies-aka-humanity-epic-fail.aspx
14:17:12 <c_wraith> http://hackage.haskell.org/trac/ghc/ticket/789 would seem to be relevant, but it's 5 months old
14:17:56 <c_wraith> err, was reported fixed 5 months ago
14:17:56 <ehird> "omg ponies aka humanity epic fail". yeah, that's pretty much the optimal set of words to include in your url if you don't want me to click it, ever
14:17:56 <amigoo> how do I say, "if this is true, then this and this is true"?
14:18:11 <c_wraith> preflex: seen igloo
14:18:12 <preflex>  igloo was last seen on #ghc 43 minutes and 9 seconds ago, saying: Exactly
14:19:27 <amigoo> how do I say, "if this is true, then this AND this is true"?  I am having problem with the AND statement
14:19:51 <c_wraith> amigoo: I don't really understand what you're trying to do.  conditional assignment?
14:19:55 <jmcarthur> amigoo: what kind of syntax are you expecting?
14:20:19 <amigoo> c_wraith: yes, conditional statement
14:20:37 <amigoo> I want to say, if this statement is true, then these two must be true also
14:20:52 <turiya> hi
14:20:54 <jmcarthur> A -> B/\C ?
14:21:24 <turiya> i am a little confused about expressions, values, types and type expressions
14:21:27 <amigoo> hi turiya, jmcarthur, i don't know what that symbol is
14:21:35 <c_wraith> amigoo: I'm still not clear on what you're doing.  Are you trying to assign to names, or are you doing logic pogramming, as jmcarthur suggests?
14:21:46 <turiya> can somebody explain
14:21:49 <jmcarthur> apparently not as i suggest
14:21:57 <kpreid> amigoo: what do you want to happen in your program that corresponds to "then ___ is true"?
14:22:25 <benmachine> turiya: can you be more specific?
14:22:34 <jmcarthur> > join (,) True
14:22:35 <lambdabot>   (True,True)
14:22:46 <tener> does anyone actually uses GADTs in real code?
14:22:50 <jmcarthur> tener: yes
14:22:52 <tener> i'm looking for working examples
14:22:57 <c_wraith> tener:  uu-parsinglib
14:23:01 <turiya> am reading the second page of the gentle introduction..
14:23:07 <sproingie> :t join
14:23:08 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
14:23:15 <jmcarthur> tener: i think i saw some slides about how darcs uses them before
14:23:21 <jmcarthur> should be a decent example
14:23:26 <turiya> i cant seem understand whether expressions have types or values have types
14:23:36 <benmachine> :t \f -> join f `const` f undefined
14:23:38 <lambdabot> forall a a1. (a1 -> a1 -> a) -> a1 -> a
14:23:50 <c_wraith> turiy: values exist only at runtime, and the runtime has discarded type information.
14:23:51 <sproingie> turiya: yes
14:23:55 <amigoo> I want to make it like, "if apple==red then taste== sweet and apple==nice"
14:23:57 <Berengal> turiya: In a way, all expressions are values
14:24:25 <jmcarthur> amigoo: but what does that buy you? are you wanting to *assign* taste and sweet or something?
14:24:29 <turiya> Berengal: any expression is a sequence of characters which the parser reads right?
14:24:41 <amigoo> yes
14:24:50 <sproingie> amigoo: logical entailment is something you'll need a logic library for
14:24:53 <Berengal> turiya: Well, not everything parsed is an expression
14:24:59 <sproingie> presumably there's something on hackage
14:25:18 <amigoo> ok, thanks I guess
14:25:22 <benmachine> if it is assignment you want then you are going to have difficulty
14:25:31 <jmcarthur> amigoo: what should be the result if the condition is *not* true?
14:25:37 <Berengal> turiya: Parsing usually happens before we get expressions... Rather, the parser creates the expressions
14:25:50 <amigoo> else it's not an apple
14:25:52 <c_wraith> amigoo: I get the feeling you're thinking very imperatively, and possibly should reverse the way you're approaching your problem
14:25:55 <tener> uu-parsinglib is what i needed, thank you
14:26:05 <nbathum> haskell is so amazing
14:26:11 <turiya> Berengal: say i type in inc x = x + 1 in a file and load it
14:26:11 <kpreid> amigoo: do you have some program code existing that you could show us? context might help explanations
14:26:14 <jmcarthur> c_wraith: either that or amigoo should look into logic programming
14:26:15 <amigoo> I am very new to haskell
14:26:29 <Berengal> turiya: Then "x + 1" would be an expression
14:26:29 <turiya> Berengal: what is the expression there?
14:26:32 <amigoo> yes, I will paste the link in a second
14:26:39 <jmcarthur> amigoo: is there a more concrete use case for this question?
14:26:59 <jmcarthur> ah, there is some code
14:27:12 <turiya> Berengal: what happens to the rest of it (inc x = )?
14:27:37 <benmachine> "inc x = x + 1" is not an expression
14:27:49 <benmachine> you could call it a statement
14:27:54 <amigoo> i am doing http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=6023#a6037
14:27:56 <Baughn> It's a definition
14:28:00 <Berengal> turiya: Well, the entire thing is a definition.
14:28:08 <Baughn> You're defining "inc x = x + 1", x being a variable/parameter..
14:28:13 <Berengal> The left-hand-side consists of a name, and one pattern
14:28:17 <sproingie> "let inc x = x + 1 in inc 123" is an expression
14:28:28 <Berengal> The pattern itself consists of just a variable
14:28:46 <Baughn> I don't think it's very useful to consider patterns when it's just x
14:29:05 <Baughn> ..well, it's a trivial pattern, but in the same way you can learn newton's laws without considering relativity. ;)
14:29:19 <jmcarthur> amigoo: you are trying to return True if the card is an Ace and False otherwise?
14:29:32 <turiya> what are definitions?
14:29:49 <Berengal> turiya: meanings given to names... ish
14:29:59 <amigoo> jmcarthur, yes, I also want to return that Ace can either be 2 or 11, depends on the other cards
14:30:28 <turiya> x + 1 is the meaning and the name is inc x?
14:30:51 <Baughn> Pretty much
14:30:59 <Baughn> @let inc x = x + 1
14:30:59 <jmcarthur> amigoo: isAce (Card _ r) = r == Ace  -- solves the first part of the problem, but i don't know what you intend to return to solve that other criteria
14:31:00 <lambdabot>  Defined.
14:31:02 <Baughn> > inc 42
14:31:03 <lambdabot>   43
14:31:04 <jmcarthur> amigoo: how is the result to be used?
14:31:19 <Berengal> turiya: You could look at it like that. I'd rather say inc is the name and x is a parameter, and that the parameter and right-hand-side expression together are the meaning
14:31:41 <amigoo> c is an arbitrary card
14:31:46 <Baughn> turiya: Don't worry too much about the abstract meaning of things yet. Just look at how it works, use it, and you'll see the patterns (eheh..) eventually.
14:32:04 <jmcarthur> amigoo: yes?
14:32:15 <turiya> Berengal, Baughn: Suppose I type in 5 in ghci, what is the expression, value and type?
14:32:18 <amigoo> I used "isAce c= Ace==rank c" to see if this arbitrary card is ace or not
14:32:21 <jmcarthur> ah, isAce c = rank c == Ace -- you had that right
14:32:25 <jmcarthur> yes
14:32:33 <Baughn> turiya: "5", 5, and forall a. Num a => a
14:32:34 <jmcarthur> that's an entire function right there
14:32:35 <Berengal> turiya: The expression is "5", the value is also "5", and it has a type of Integer
14:32:40 <mtnviewmark> turiya - alas, numeric constants are a bit of a puzzle in haskell
14:32:44 <mtnviewmark> ask that about "foo"
14:32:47 <mtnviewmark> :t "foo"
14:32:48 <lambdabot> [Char]
14:32:49 <Berengal> turiya: (Integer in ghci that is, because it defaults)
14:32:56 <Baughn> turiya: Incidentally, there is already a function like inc in the prelude; it's called succ
14:33:09 <amigoo> pastah rhymes helped me with it last night, but I want to make the ace as either a 2 or an 11
14:33:39 <amigoo> so i was wondering if I can use if statement
14:33:51 <turiya> Now.. the value 5 is an abstract thing..
14:33:53 <amigoo> since we already know that if c is ace, then ace must be 2 or 11
14:33:58 <jmcarthur> amigoo: so you actually want to return something like either Card something (Num 2) or Card something (Num 11)?
14:34:02 <Berengal> turiya: As I said, all expressions denote values, and all values are expressible. Values have types, and since expressions denote values, we sometimes say expressions have types too
14:34:12 <amigoo> yes
14:34:30 <benmachine> amigoo: what determines whether it is a two or an eleven?
14:34:39 <turiya> haskell converts this abstract entity to a character representation b4 printing it on screen, right?
14:34:41 <Baughn> turiya: The difference between a value and an expression is that an expression can be more complicated
14:34:42 <jmcarthur> amigoo: well, that function can't return both at once, so it will need to know what the other cards are
14:34:51 <jmcarthur> so it can determine it unambiguously
14:34:52 <amigoo> benchmachine: the other cards determine if it's 11 or 2
14:34:56 <Baughn> turiya: 5 is a value, and an expression. 2+3 is an expression, with the value 5.
14:34:58 <mtnviewmark> turiya - yes, by applying the function show to it
14:35:20 <mtnviewmark> so, it only works for values who's types are intances of Show
14:35:49 <amigoo> late, I want to use lowAce is another statement, and highAce in another statement
14:35:54 <Berengal> Values and expressions sort of live on difference abstraction levels...
14:35:56 <turiya> ok.. an expression evaluates to a value, this value can be printed on screen using show
14:36:01 <amigoo> which will coincide with the value of the other cards
14:36:31 <mtnviewmark> turiya - *may* be printed on screen ... though it is true for all "common" values you encounter
14:36:34 <Baughn> turiya: ..mostly. Not all expressions can be printed using show; functions can't, for example.
14:36:37 <jmcarthur> amigoo: what type should your function have?
14:36:51 <Baughn> turiya: Er, though lambdabot /can/ print functions, kind of. It cheats horribly.
14:37:04 <Berengal> lambdabot has godmode
14:37:07 <amigoo> well, I guess it should have the value of the other cards
14:37:27 <turiya> Baughn: I did not think functions are expression, i thought they were definitions
14:37:29 <koeien37> x
14:37:37 <turiya> expressions*
14:37:42 <benmachine> turiya: you define a function in a definition
14:37:43 <Baughn> turiya: No, "inc x = x + 1" is a definition
14:37:45 <amigoo> later, I will random this arbitrary c
14:37:48 <benmachine> but you use it in an expression
14:37:56 <Baughn> turiya: "inc 2" is then an expression, and so is "inc"
14:38:10 <mtnviewmark> amigoo -- are you trying to handle values of cards in such a way that you can deal with ambiguity --- like you want to return a result for the value of a card, but there may be more than oe answer?
14:38:27 <jmcarthur> amigoo: but what is the *type* of this function? currently it is not very well specified
14:38:27 <Baughn> turiya: Indeed, inc 2 works as an expression specifically because inc does, and you could use any other expression that evaluates to a function instead of inc
14:38:35 <amigoo> mtn: yes
14:38:39 <Baughn> turiya: Like, "(\x -> x + 1) 2"
14:38:39 <mtnviewmark> turiya
14:38:45 <mtnviewmark> what B. said
14:38:58 <mtnviewmark> :t  \x -> x + 7
14:39:00 <lambdabot> forall a. (Num a) => a -> a
14:39:04 <conal> jvoorhis: hi.  i see you were asking about unamb, lub, definedP etc.
14:39:04 <jmcarthur> i have a solution in mind, but i'm afraid of blowing your mind too quickly
14:39:06 <mtnviewmark> or
14:39:13 <mtnviewmark> :t \x -> x ++ ", eh?"
14:39:14 <lambdabot> [Char] -> [Char]
14:39:38 <mtnviewmark> those expressions have the type   [Char] -> [Char]     -- which is a fuction
14:39:38 <amigoo> jmc: I have been having problem with understanding "type", even after reading through the tutorial
14:39:39 <Baughn> conal: I always get the impression that lub is a solution desperately searching for a sufficiently big problem. It's elegant in theory, but..
14:39:52 <mtnviewmark> amigoo: the List monad!
14:39:58 <conal> Baughn: but ... ?
14:40:09 <jmcarthur> amigoo: mtnviewmark has revealed what i was afraid of blowing your mind with ;)
14:40:16 <conal> Baughn: but you don't know what to do with it?
14:40:22 <Baughn> conal: But it's way slow, even with greenthreads. Ah, but you know that. :P
14:40:41 <Baughn> conal: That's probably fixable, so I don't mind much.
14:40:46 <mtnviewmark> value Ace = [1, 11];   value (Pips n) = [n];  value (Face x) = [10]
14:40:48 <turiya> How can Haskell differentiate between definitions and expressions
14:40:54 <conal> Baughn: yes. fixable.
14:41:04 <Baughn> turiya: "inc x = x + 1" <- Definition
14:41:09 <Baughn> turiya: "inc x" <- expression
14:41:15 <Baughn> turiya: The difference would seem to be obvious.
14:41:15 <mtnviewmark> then you can do things like:      sumCards a b = value a >>= map (+) (value b)
14:41:17 <conal> the current unamb impl is there so people can experiment with applications.
14:41:28 <benmachine> turiya: definitions have an = in the middle
14:41:32 <Stinger> anything with an = is a definition (is that right?)
14:41:40 <conal> laziness was very inefficient originally as well.  applications motivated better implementation technology.
14:41:46 <Baughn> conal: Admittedly, I haven't figured out a better way to implement it. Have you thought much about it?
14:41:53 <turiya> Baugh: I can see the difference but just thinking how it is implemented
14:42:01 <mtnviewmark> well, jmcarthur, amigoo --- -for get I said "List monad"  --- and instead told you that the value of a card should be a list of  possible values
14:42:03 <conal> Baughn: some.  not a lot.
14:42:04 <Baughn> turiya: A back-tracking parser
14:42:10 <mtnviewmark> from that you should be able to write your code
14:42:21 <Baughn> turiya: Well, that, and generally expressions can't be used where definitions could be or vice versa
14:42:23 <amigoo> mth: oh, I am already reading through it
14:42:25 <mtnviewmark> and once you learn about the List Monad, you'll discover your code will get smaller and cleaner
14:42:35 <amigoo> mth: though I don't understand much of it
14:42:52 <Berengal> turiya: The top-level consists of a list of definitions. There are also some other places in code where definitions can be put, indicated by keywords. This is handled by the parser.
14:43:08 <Stinger> there is enough basic (well basic-er) haskell to learn before bringing monads into it
14:43:12 <turiya> Baughn: I was thinking that definitions are also type of expression which evaluate to something different
14:43:20 <turiya> expressions*
14:43:28 <Baughn> turiya: Nope. In lisp they are, in haskell they're very different things.
14:43:36 <Baughn> turiya: For the time being, just assume the compiler is magic. ;)
14:43:53 <mtnviewmark> :  (\c1 c2 -> do { a <- c1; b <- c2; return a + b; })  [1, 11] [5]
14:44:01 <turiya> Baughn: I dont want to learn magic :)
14:44:18 <Baughn> turiya: But you do it so well!
14:44:23 <amigoo> mtn: yea see, i don't understand that
14:44:27 <mtnviewmark> :> (\c1 c2 -> do { a <- c1; b <- c2; return a + b; })  [1, 11] [5]
14:44:36 <benmachine> turiya: when you're learning about haskell, you don't need to know how the compiler does things, just what it does
14:44:37 <mtnviewmark> > (\c1 c2 -> do { a <- c1; b <- c2; return a + b; })  [1, 11] [5]
14:44:38 <lambdabot>   <no location info>: lexical error at character '\FS'
14:44:42 <Baughn> turiya: Seriously, though, it's the only way. You have to walk before you can run; you can't understand /how/ haskell works until you understand /what/ it does
14:44:47 <mtnviewmark> well, forget that
14:44:51 <mtnviewmark> consider this:
14:44:53 <amigoo> what doese :> means
14:44:58 <jmcarthur> nothing
14:45:00 <conal> Baughn: s/does/means/
14:45:06 <Stinger> it means he doesnt know how to use lambdabot
14:45:09 <monochrom> > (\c1 c2 -> do { a <- c1; b <- c2; return a + b; })  [1, 11] [5]
14:45:11 <lambdabot>   No instance for (GHC.Num.Num [b])
14:45:11 <Berengal> turiya: It's a bit like learning physics. Each year they tell you that what you learned last year was a convenient white lie, but this year you'll learn how things really work...
14:45:11 <lambdabot>    arising from a use of `GHC.Num.+' at <...
14:45:17 <Baughn> conal: No, I'm including IO in the does
14:45:24 <mtnviewmark> > (\a b -> map (map (+) a) b) [1, 11]  [5]
14:45:25 <lambdabot>   <no location info>: lexical error at character '\FS'
14:45:35 <conal> Baughn: oh, okay.
14:45:35 <mtnviewmark> fie
14:45:36 <turiya> Berengal: I dont remeber any physics I have learnt that way..
14:45:43 <monochrom> mtnviewmark had spurrious characters of the Unicode codepoint U+001C
14:45:51 <conal> Baughn: i don't think *anyone* understands what IO means.
14:46:01 <mtnviewmark> > let cardSum a b = map (map (+) a) b in cardSum [1, 11]  [5]
14:46:02 <lambdabot>   Couldn't match expected type `a -> b'
14:46:02 <lambdabot>         against inferred type `[a1 ->...
14:46:02 <conal> Baughn: only smallish fragments
14:46:03 <monochrom> > (\a b -> map (map (+) a) b) [1, 11]  [5]
14:46:04 <lambdabot>   Couldn't match expected type `a -> b'
14:46:05 <lambdabot>         against inferred type `[a1 ->...
14:46:18 <jmcarthur> > let (+.) = liftA2 (+) in [1] +. [2,11] +. [5] +. [2,11]
14:46:19 <mtnviewmark> I'm failing here --- ned more coffeee
14:46:19 <Baughn> conal: I've got an idea, but it gets into the dovetailer algorithm and statistical distributions of laws of physics
14:46:19 <lambdabot>   [10,19,19,28]
14:46:23 <turiya> thaks guys for all the help
14:46:27 <Baughn> conal: Er, rather, superpositions
14:46:37 <Berengal> turiya: No? You didn't learn about electrons circling in orbits before you learned they actually circle in clouds, not really orbits?
14:46:44 <jmcarthur> > let (+.) = liftA2 (+) in maximum . filter (<=21) $ [1] +. [2,11] +. [5] +. [2,11]
14:46:45 <lambdabot>   19
14:46:52 <Baughn> Berengal: *wince*
14:47:06 <conal> Baughn: sounds like a thesis topic!
14:47:09 <amigoo> too advance for me, I think I probably should try learning other easier language
14:47:17 <amigoo> thanks anyways
14:47:22 <benmachine> amigoo: maybe you just need a better tutorial
14:47:28 <Baughn> conal: For advanced philosophy, maybe.
14:47:31 <conal> amigoo: what scared you off?
14:47:33 <jmcarthur> amigoo: haskell's not that hard. you just have to keep your eyes from going blurry
14:47:39 <jmcarthur> amigoo: everything makes sense in the end
14:47:49 <turiya> Berengal: I feel that the main concept there was that of uncertainty
14:47:51 * Baughn hands amigoo a tasty cookie
14:48:00 <amigoo> someone was explaining me what "type" was for about 5 hours yesterday
14:48:05 <amigoo> and I still didn't get it
14:48:05 <jmcarthur> amigoo: check this out...
14:48:13 <conal> amigoo: oh, urg :(
14:48:15 <jmcarthur> @let (+.) = liftA2 (+)
14:48:16 <lambdabot>  Defined.
14:48:22 <turiya> Berengal: and not how the electron moves, for me..
14:48:24 <Baughn> amigoo: A type is a set of possible values. There. One sentence.
14:48:28 <jmcarthur> amigoo: consider +. to be "magic" for now
14:48:41 <Stinger> type just says, you can use this function with thing a (which has the right type), but not thing b
14:48:50 <Baughn> turiya: Goood, especially since electrons around atoms don't actually /move/, as such, at all
14:48:53 <jmcarthur> amigoo: now say you have a bunch of cards, some of which can have one of two different values. i will express these as lists of values
14:48:53 <amigoo> so type is a set? is it like a list?
14:49:06 <copumpkin> it's a set
14:49:09 <jmcarthur> amigoo: for example, [1], [2], [3], [4], ... for normal cards
14:49:13 <Baughn> amigoo: Set-theoretic set
14:49:16 <jmcarthur> amigoo: and [2,11] for aces
14:49:25 <amigoo> ok
14:49:29 <Baughn> amigoo: The type Int is, semantically, the set of every possible value of Int
14:49:34 <jmcarthur> amigoo: now i can sum up the values of several cards using my magic +. operator
14:49:35 <turiya> Baughn: that is enlightening..
14:49:44 <jmcarthur> > [1] +. [2,11] +. [5] +. [2,11]
14:49:46 <lambdabot>   [10,19,19,28]
14:49:57 <jmcarthur> amigoo: and lo and behold i got four possible values!
14:50:06 <amigoo> ok
14:50:15 <Berengal> Baughn: See what I mean about white lies and physics? Every year it's like being told Santa Claus doesn't exist all over again
14:50:15 <jmcarthur> amigoo: now the job is just to pick the highest valid card from that list
14:50:17 <monochrom> Why is [2,11] ace?
14:50:29 <jmcarthur> monochrom: it's black jack
14:50:48 <nbathum> isnt the ace 1 or 11 in black jack?
14:51:00 <jmcarthur> nbathum: i was just going by amigoo's rules
14:51:00 <leimy> yes
14:51:05 <jmcarthur> nbathum: you're right though
14:51:24 <Baughn> Berengal: Yess. My wince was at your statement that "electrons don't move like <wrong concept>, they actually move like <equally wrong concept>". :P
14:51:24 <nbathum> jmcarthur: ooh, i missed that part
14:51:31 <amigoo> the rules are not important for now, I am just trying to understand the logic
14:51:38 <jmcarthur> amigoo: anyway, you can then use filter (<= 21) to get rid of the values in that list that are above 21
14:51:46 <Baughn> Berengal: Of course, the truth involves observation effects and whatnot, so yeah.
14:51:48 <jmcarthur> > filter (<= 21) [10,19,19,28]
14:51:49 <lambdabot>   [10,19,19]
14:51:58 <amigoo> ok
14:52:00 <jmcarthur> amigoo: so that got rid of the bad values
14:52:06 <leimy> and you can nub
14:52:17 <jmcarthur> amigoo: now we get the maximum value that we can from that using the maximum function!
14:52:25 <jmcarthur> > maximum [10,19,19]
14:52:26 <lambdabot>   19
14:52:26 <Baughn> amigoo: The logic is that a type is a set of values, and a context (Num, Ord, etc.) is an expandable set of types
14:52:31 <jmcarthur> amigoo: and we're done!
14:52:32 <benmachine> Baughn: you mean the latest approximation to the truth
14:52:38 <tibbe> bos: hey!
14:52:41 <Baughn> benmachine: The least wrong one.
14:52:45 <Baughn> benmachine: But at least it's /closer/
14:52:50 <amigoo> ok, is string a type of value?
14:52:52 <benmachine> :P
14:53:06 <jmcarthur> amigoo: we can string that whole thing together the way i did in the earlier version that i think kind of scared you
14:53:14 <bos> tibbe: hey, pushed a piddle puddle of small patches to my event repo today
14:53:15 <preflex>  bos: you have 1 new message. '/msg preflex messages' to read it.
14:53:15 <lambdabot> bos: You have 2 new messages. '/msg lambdabot @messages' to read them.
14:53:21 <benmachine> heh
14:53:25 <jmcarthur> amigoo: but i just explained all the parts, so the only remaining things to learn to understand that are (.) and ($)
14:53:27 <benmachine> bos is popular
14:53:36 <jmcarthur> amigoo: and of course the magic (+.) operator i created
14:53:36 <amigoo> ok
14:53:44 <Baughn> amigoo: Well, String is just an alias for [Char]..
14:53:44 <tibbe> bos: would you prefer selecting the backend using an environment variable to passing an extra to the 'new' function of the EventManager?
14:53:50 <Berengal> Baughn: I didn't mean to be precice about physics, rather the concept of educational lies... Eventually they tell you "what you learned last year wasn't entirely true, but we don't know what the hell is... Have a particle accelerator."
14:53:59 <Baughn> amigoo: Where Char is the type of every possible (unicode) character
14:54:00 <amigoo> and [char] is a type?
14:54:02 <benmachine> wooo
14:54:04 <jmcarthur> amigoo: i suspect now that you are focusing more on the types stuff and not me, so i don't know if i should go on
14:54:05 <amigoo> ok
14:54:05 <tibbe> bos: I'll check if I can merge them
14:54:08 <bos> tibbe: well it needs to get chosen somewhere.
14:54:21 <bos> tibbe: i merged with your changes, so it should be ok.
14:54:24 <amigoo> jmc: please keep going, i am still reading
14:54:25 <Baughn> amigoo: And [a] is the type (set, remember) of every possible list of as
14:54:30 <jmcarthur> amigoo: okay
14:54:37 <bos> and tibbe, yes, i'd prefer an environment variable.
14:54:37 <monochrom> . o O ( a type ought not be a set of anything until I can haz axiom of choice )
14:54:41 <tibbe> bos: as long as it doesn't stick around once we productionize things and I don't have to remember to set an environment variable all the time I'm fine with it.
14:54:54 <amigoo> ok
14:54:56 <benmachine> monochrom: you can have it right now?
14:54:58 <Baughn> amigoo: ..so a [Char], and hence a String, is the set of /every possible/ list of unicode characters
14:55:01 <benmachine> axioms are free
14:55:01 <bos> tibbe: i'd expect the default to be the fastest for the platform.
14:55:05 <tibbe> bos: I want to be able to: cabal configure && cabal build easily
14:55:10 <tibbe> bos: ok
14:55:19 <bos> tibbe: i just need a non-painful way to select a slow back end like select or poll
14:55:30 <tibbe> bos: also, at some point, once we have a really good overall benchmark, we should benchmark the differene
14:55:34 <Baughn> amigoo: Naturally, it is not possible to represent types like that in real life (it's infinite!), so haskell does some approximations, but it's pretty close
14:55:43 <tibbe> bos: reconfiguring is too painful?
14:55:46 <jmcarthur> > maximum (filter (<=21) ([1] +. [2,11] +. [5] +. [2,11])) -- amigoo: i actually can just use parenthese instead of (.) and ($), so this should be easier if you don't know those
14:55:47 <lambdabot>   19
14:55:52 <jmcarthur> *parentheses
14:56:26 <amigoo> :t (.)
14:56:27 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:56:31 <amigoo> >:t (.)
14:56:34 <Baughn> Oh gods
14:56:35 <sproingie> caleskell
14:56:38 <bos> tibbe: yes, it's a pain to rebuild every time i want to test something.
14:56:41 <Baughn> amigoo: That is not .!
14:56:42 <leimy> there is no spoon
14:56:46 <Baughn> :t Prelude.(.)
14:56:46 <jmcarthur> amigoo: i think for now we are best leaving the definition of (+.) alone, honestly. we can get to that some other time. the important part is that you at least understand that it does every possible combination of addition and makes a new list
14:56:47 <lambdabot> Not in scope: data constructor `Prelude'
14:56:50 <leimy> it is you that bends
14:56:52 <Baughn> :t P.(.)
14:56:53 <lambdabot> Not in scope: data constructor `P'
14:56:57 <amigoo> ok
14:56:57 <bos> tibbe: i didn't understand your question about Unique
14:56:59 <tibbe> bos: I'm thinking about what to work on next. I have a few more optimization patches for PSQ in me but then it's time to switch to the next thing
14:56:59 <Baughn> :t (Prelude..)
14:57:00 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
14:57:04 <Baughn> amigoo: That's the one.
14:57:05 <Berengal> As I said earlier, lambdabot runs in godmode...
14:57:06 <bos> tibbe: yeah.
14:57:26 <Baughn> amigoo: ..does this make sense now? Questions?
14:57:29 <tibbe> bos: hmm, I think I simply said that I added a copy of your file to my repo instead of merging yours
14:57:29 <sproingie> i love that particular (.) but it's definitely a whole other can of worms to explain
14:57:32 <bos> tibbe: if i were you, i'd add code to benchmark the timeout code and ensure that it actually works.
14:57:37 <amigoo> yeah sort of
14:57:38 <Baughn> sproingie: Me hatess it.
14:57:39 <ehird> what were we explaining?
14:57:46 <bos> tibbe: that shouldn't matter, right?
14:57:48 <Baughn> sproingie: Useful for silly \bot tricks, but hatess it.
14:57:50 <ehird> Baughn: Bah! (.) is fmap.
14:58:01 <tibbe> bos: no, it was a very technical VCS point :)
14:58:05 <ehird> I'm a certified Caleskell engineer and I can assure you that lambdabot is lying about types.
14:58:16 <tibbe> bos: i.e. "here's why I'm doing what I'm doing"
14:58:38 <bos> tibbe: we already saw that none of the poll code was anywhere near working until i wrote a benchmark to test it :-)
14:58:48 <Baughn> amigoo: We also have something called algebraic data types, e.g. "data Either a b = Left a | Right b"
14:58:53 <bos> tibbe: and i'm pretty sure the timeout code is in the same boat. try using it, and it won't work.
14:59:14 <tibbe> bos: I think the System.Event code needs to be refactored a bit for easier testing. In particular it would be nice to not loop but quite immediately
14:59:14 <Baughn> amigoo: They're "algebraic" because the operations you can do there correspond exactly to set addition and multiplication in the set interpretation of types
14:59:28 <bos> tibbe: why'd you think?
14:59:31 <tibbe> bos: most likely
14:59:38 <amigoo> Baughn: it's fine. I think trying to do blackjack is too advance for me, I think I want to do fibonacci for now
14:59:41 <Baughn> amigoo: So, "Left a | Right b" /adds/ the sets of a and b; an Either can take on any of the values of a /or/ b
14:59:45 <tibbe> bos: the current code is tricky to test because of threading
14:59:54 <sproingie> i never liked the name for Either.  it makes it look like Left and Right are equal citizens, when Left dominates
14:59:59 <Berengal> @quote fibonacci
14:59:59 <lambdabot> ghc says: try_stub.o: unknown symbol `Safe_zdffibonaccizuhszuaM1_closure'
15:00:09 <kmc_> sproingie, i dislike the standard Monad instance for the same reason
15:00:13 <Baughn> amigoo: While (,), eg. "data (,) a b = (,) a b" /multiplies/ them
15:00:18 <kmc_> there should be a symmetric Either type
15:00:18 <benmachine> sproingie: dominates how?
15:00:18 <tibbe> bos: I'd like to 1) register a fd, 2) run through the loop once 3) check that I got an event
15:00:21 <kmc_> and a separate one for errors
15:00:28 <sproingie> benmachine: in the monad instance.  i guess it's just the monad instance
15:00:34 <Baughn> amigoo: So an (a,b) can take as many possible values as the number of values in a *times* the number of values in b
15:00:37 <kmc_> this is Haskell, we do not shy away from distinguished but isomorphic types
15:00:48 <benmachine> I'm not sure what a symmetric one would look like
15:00:59 <kmc_> it would look like our Either
15:00:59 <sproingie> amb perhaps
15:01:00 <monochrom> "help, my program has either types left right and centre"
15:01:02 <tibbe> bos: anyway, I'll write a benchmark for sleeping
15:01:02 <Baughn> amigoo: Sadly, we don't have the equivalent of subtraction. Oh well. :P
15:01:11 <tibbe> bos: but I want some unit tests
15:01:19 <amigoo> ok
15:01:39 <Baughn> (And I'm not entirely sure what division would mean, if anything)
15:01:40 <Berengal> data Neither a b = Left | Right
15:01:44 <kmc_> hehe
15:01:50 <monochrom> . o O ( you would get real sets if you had subtraction )
15:02:14 <Baughn> monochrom: Add dependent typing, and...
15:02:18 <sproingie> @quote Berengal data Neither a b = Left | Right
15:02:18 <lambdabot> No quotes match. :(
15:02:19 <kmc_> the algebraic operations on types are more like (distinguished) union and cartesian product
15:02:24 <sproingie> @remember Berengal data Neither a b = Left | Right
15:02:25 <lambdabot> It is stored.
15:02:34 <jmcarthur> monochrom: would Foo - Void still have _|_?
15:02:36 <sproingie> i am always using @quote when i mean @remember
15:02:41 <kmc_> @quote remember
15:02:42 <lambdabot> fasta says: I think the @remember command is way overused.
15:02:56 <Baughn> @remember lambdabot fasta says: I think the @remember command is way overused.
15:02:56 <lambdabot> Okay.
15:03:16 <jmcarthur> wut
15:03:22 * Baughn whistles innocently
15:03:31 <edwardk> @remember Baugn @remember lambdabot fasta says: I think the @remember command is way overused.
15:03:32 <lambdabot> Okay.
15:03:36 <joe1> filesdata :: [[Int]] ;  GOA.minimum $ GOA.map ( GOA.length ) ( Data.List.group $ GOA.concat filesdata ) ; this code is really really slow. any thoughts on how this can be made faster
15:03:41 <monochrom> ...
15:03:41 <sproingie> fix @remember
15:03:42 * Berengal surpresses an urge to @remember edwardk
15:03:56 <joe1> filesdata is just a bunch of 0's and 1's
15:03:57 * benmachine pokes edwardk in the Baugn
15:04:02 <kmc_> > fix error
15:04:02 * jmcarthur doesn't
15:04:03 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
15:04:23 <damd> > fix (fix error)
15:04:25 <lambdabot>   Couldn't match expected type `a -> a'
15:04:25 <lambdabot>         against inferred type `[GHC.T...
15:04:28 <jmcarthur> @remember edwardk @remember Baugn @remember lambdabot fasta says: I think the @remember command is way overused.
15:04:28 <lambdabot> Done.
15:04:30 <damd> dang
15:04:39 <benmachine> @quote remember
15:04:45 <lambdabot> Baughn says: fix (@remember Baughn . (:))
15:04:45 <leimy> @remember remember
15:04:47 <lambdabot> Incorrect arguments to quote
15:04:52 <benmachine> hah
15:04:54 <jmcarthur> the 5th of november?
15:05:02 <edwardk> jmcarthur: hah
15:05:07 <ralph> Is there another channel for "deep haskell" or "advanced haskell"?  Something like that.
15:05:08 <benmachine> @flush
15:05:09 <leimy> @remember remember the 5th of november
15:05:09 <lambdabot> Not enough privileges
15:05:09 <lambdabot> I will remember.
15:05:13 <leimy> lol
15:05:14 <kmc_> ralph, #haskell-in-depth
15:05:14 <jmcarthur> ralph: #haskell-in-depth
15:05:20 <ralph> ah.  That's it.
15:05:20 <jmcarthur> i win!
15:05:20 <kmc_> it's very light traffic
15:05:24 <ralph> Thanks jmcarthur and kmc_
15:05:25 <damd> @quote remember
15:05:26 <lambdabot> remember says: the 5th of november
15:05:29 <kmc_> feel free to start an exciting convo there
15:05:53 <ralph> Does anyone know of a good piece of software for drawing commutative diagrams?
15:05:58 <kmc_> there is also #haskell-overflow which is just a place to take convos from here when there are too many
15:06:01 <kmc_> not higher or lower level
15:06:04 <ralph> I want to be able to move around boxes, label them and connect them with arrows.
15:06:09 <tibbe> bos: you have a bad habit of putting $! before constructors ;)
15:06:24 <edwardk> heh
15:06:58 <jmcarthur> and #haskell-blah for when you can't keep your mouth shut about how your wife divorced you as you were fired on tax day and then somebody was wrong on reddit
15:07:20 <c_wraith> someone is wrong ON THE INTERNET?!!
15:07:30 <Berengal> It's more likely than you think
15:07:43 <c_wraith> way to confuse me with mixed memes
15:07:56 <Stinger> it's practically the default state
15:09:08 <jmcarthur> AHH
15:09:12 <benmachine> oh dang only 500 left
15:09:17 <benmachine> what will we do :(
15:09:22 <ivanm> 500 what left? people?
15:09:26 <benmachine> yes
15:09:39 * Berengal loves how netsplits are all bundled up in one line
15:09:42 <Stinger> oh god, its 500, noone leave
15:09:47 * benmachine has that disabled
15:10:00 <Stinger> Berengal, what client
15:10:02 <benmachine> it kept telling me people had rejoined from netsplits when actually they were just turning up
15:10:15 <jmcarthur> irssi does that
15:10:16 <Berengal> Stinger: Quassel
15:10:22 <jmcarthur> unfortunately, i am on weechat instead :(
15:10:36 <benmachine> jmcarthur: Berengal's thing or my thing?
15:10:43 <benmachine> (irssi does both)
15:10:50 <leimy> Is there a good haskell irc client?
15:10:59 <jmcarthur> HELLO EVERYBODY
15:11:08 <benmachine> I think I remember reading about one leimy
15:11:11 <joe1> filesdata :: [[Int]] ;  GOA.minimum $ GOA.map ( GOA.length ) ( Data.List.group $ GOA.concat filesdata ) ; this code is really really slow. any thoughts on how this can be made faster?
15:11:18 <ehird> HELLO
15:11:18 <ehird> whoa
15:11:18 <ehird> trippy
15:11:18 <ivanm> leimy: there was an IRC client in Haskell; IMHO it wasn't good
15:11:30 <jmcarthur> benmachine: i'm confused
15:11:31 <ben0x539> hircules
15:11:31 <benmachine> heh
15:12:01 <benmachine> oh it's ben who used to highlight me hi
15:12:13 <ben0x539> hello benmachine
15:12:28 <benmachine> I still feel guilty about making you change :P
15:12:34 <benmachine> you shoudl go back it's a good name
15:12:42 <ben0x539> eh, I go back and forth
15:12:45 <benmachine> jmcarthur: what are you confused about?
15:12:50 <jmcarthur> > unwords $ (:" has joined #haskell") <$> ['a'..'z']
15:12:51 <lambdabot>   "a has joined #haskell b has joined #haskell c has joined #haskell d has jo...
15:12:56 <ben0x539> the stupid numbers make me more memorable anyway
15:13:01 <benmachine> heh
15:13:04 <kmc_> > 0x539
15:13:06 <lambdabot>   1337
15:13:09 <jmcarthur> ben0x539: your question. i completely lost the context of it
15:13:10 <kmc_> heh
15:13:12 <benmachine> clever.
15:13:29 <jmcarthur> *benmachine, sorry
15:13:42 <benmachine> oh, I was asking if you meant irssi does the netsplit-hiding thing or the broken-netsplit-hiding thing
15:14:02 <benmachine> it's not important
15:14:05 <jmcarthur> benmachine: by default it shows a few and then just says "and XX more" or something
15:14:09 <benmachine> yeah
15:14:16 <ben0x539> (benmachine: also, when this whole "get free stuff from that one website for a day" thing was going on, apparently one of the guys handling it was named ben___ or something like that and a few people messaged me instead even though I was not anywhere near them)
15:14:17 * ivanm wishes xchat did that :s
15:14:26 <Stinger> same
15:14:30 <benmachine> heh
15:14:52 <benmachine> ben0x539: did you get any free stuff out of it?
15:15:19 <ben0x539> No, I just changed my nick and hid
15:15:22 <benmachine> aw
15:15:42 <HugoDaniel> if i have a bunch of very complex pure functions composed together, and in the main function i call them with a static value, like "veryComplexPureThing 404", will ghc optimize and replace for the result value in compile time ?
15:15:48 <rovar> how does one convert a ByteString to a LazyByteString?
15:16:03 <benmachine> HugoDaniel: if they're very complex, possibly not
15:16:04 <ben0x539> rovar: fromChunks . (:[]), I believe
15:16:12 <ben0x539> @type fromChunks . (:[])
15:16:12 <lambdabot> Not in scope: `fromChunks'
15:16:13 <copumpkin> fromChunks . pure
15:16:17 <benmachine> HugoDaniel: ghc does a lot of inlining, but imagine if it inlined (repeat 1)
15:16:34 <rovar> thanks
15:16:35 <Baughn> HugoDaniel: There might be a pragma to force it. Or there might not.
15:16:42 <Berengal> benmachine: It should still be able to allocate that at compile-time
15:16:43 <Stinger> surely ghc can solve the halting problem
15:16:43 <heatsink> Is there a way to apply a polymorphic function to the value in a Dynamic?
15:17:05 <copumpkin> heatsink: nope
15:17:05 <tibbe> WHNF (using seq) doesn't evaluate inside constructors and lambdas, right?
15:17:12 <benmachine> Berengal: allocate it?
15:17:18 <copumpkin> heatsink: how would it what's inside?
15:17:29 <Baughn> heatsink: You could store the applied function along with the value when you make it, and trust in laziness
15:17:38 <heatsink> copumpkin, it wouldn't need to because of uniform representation
15:17:43 <Berengal> benmachine: Yes, as in put it in the binary. I'm not saying it does, just that it should be able to.
15:17:53 <copumpkin> heatsink: so you really have an a -> b function?
15:17:54 <benmachine> Berengal: an infinite list?
15:17:59 <benmachine> oh I guess it could
15:18:04 <heatsink> copumpkin, it's an a -> t a
15:18:04 <benmachine> with a circular thingy
15:18:21 <heatsink> a -> T a
15:18:21 <Berengal> benmachine: This way, if you wanted, you could embed static data like prime-tables or whatnot into the executable
15:18:22 <copumpkin> heatsink: ah, I still don't think you can, but you should be able to
15:18:59 <benmachine> Berengal: okay, but the point is that sometimes it uses more memory to do that than you save
15:19:00 * hackagebot upload: afv 0.0.0 - Model checking Atom generated C. (TomHawkins)
15:19:23 <Berengal> benmachine: It still needs to solve the halting problem, I think... And I just had my fifth deja vu about just this thing
15:19:33 <heatsink> It would be a useful feature for interfacing between statically and dynamically typed code...
15:20:01 <benmachine> Berengal: heh, I suppose so
15:20:23 <tibbe> bos: merged and pushed to my github repo
15:20:38 <jmcarthur> wait, people use dynamically typed code?
15:20:40 <heatsink> Well, there aren't that many differnet types, I can just enumerate them.
15:20:58 <glguy> jmcarthur, only when they want to get things done
15:21:02 <Berengal> benmachine: Perhaps a restricted subset of the language could be employed, together with the understanding that TH is already turing-complete and may eat your memory
15:21:05 <jmcarthur> wat
15:21:08 <copumpkin> wat
15:21:17 <benmachine> wat
15:21:18 <Berengal> wat
15:21:24 <monochrom> :)
15:21:25 <copumpkin> angkor
15:21:30 <heatsink> joul
15:21:39 <Baughn>  s/memory/brains/
15:21:42 <copumpkin> wat
15:21:51 <monochrom> @humans
15:21:52 <lambdabot> Unknown command, try @list
15:22:01 <Berengal> Baughn: Haskell is always eating your brains
15:22:32 * benmachine did that thing where everyone whose name begins with a capital B and then something with a g in it is the same person
15:23:12 <Baughn> benmachine: That's because I ate Berengal's brains.
15:23:14 <heatsink> benmachine, I know exactly what you're talking about.
15:23:18 <heatsink> wait, I don't.
15:23:24 <benmachine> heh
15:23:46 <ivanm> benmachine: nah, ksf vs kmc is the best one, especially when xchat gives both of their nicks the same colour!
15:23:57 <benmachine> woo.
15:24:15 <Berengal> My chat client needs more colours... :(
15:24:16 <c_wraith> yes, xchat does.  I can never keep it straight which of them is which
15:24:29 <benmachine> preflex: seen lilac
15:24:29 <preflex>  lilac was last seen on #haskell 60 days, 4 hours, 41 minutes and 48 seconds ago, saying: ksf: well, the C version uses evil such as: "Integer to float conversions are faster if the integer is signed"
15:24:36 <benmachine> 60 days :o
15:24:50 <jmcarthur> o_O
15:26:51 <tibbe> bos: how do you run the Simple benchmark?
15:27:26 <heatsink> I guess that's because x86 has a singed-to-float conversion instruction, but no unsigned-to-float conversion instruction
15:27:31 <tibbe> bos: perhaps a makefile would be in order to make sure that everyone can easily run all tests/benchmarks to make sure they didn't break anything
15:51:20 <noteventime> I don't quite get the difference between event and behaviour apart from one being indexed by a continuous time and the other by a discrete onr
15:51:56 <sinelaw> noteventime, it's the difference between a sequence and a continuous function
15:52:23 <noteventime> Ok
15:52:52 <sinelaw> Event a is a sequence of (Time, a) pairs. Behavior a is a continuous function from Time to a
15:53:19 <noteventime> So the reason for separating them in the context of frp is one of performance?
15:53:42 <sinelaw> noteventime, no. what i described is a semantic difference.
15:53:56 <sinelaw> it's a question of what they should mean
15:54:04 <sinelaw> (what should they denote)
15:54:17 <noteventime> In what sense?
15:55:07 <sinelaw> the idea is that when you design your program, you start by defining precisely what the program is, what the data types correspond to an in ideal mathematical world. then you go forward and implement that efficiently, somehow.
15:55:46 <sinelaw> noteventime, so in this case, we first decide what Behaviors and Events are, what we want them to be
15:56:03 <sinelaw> and the questions of performance and how exactly to implement them comes only later
15:56:28 <noteventime> Sure, I can't see how the two are different though
15:57:05 <noteventime> I mean, apart from what I've already mentioned
15:57:31 <noteventime> Also, I can see the difference in application
15:57:39 <sinelaw> noteventime, you see the difference between sequence of values that are defined at specific points in time, vs. a value that changes with respect to continuous time?
15:57:50 <noteventime> But the reason for separating them in application seems to be performance
15:58:02 <Veinor> I'm going to write a post about stuff that you can't do in Haskell, and why you shouldn't do it anyway.
15:58:04 <noteventime> sinelaw: They seem equivalent to me
15:58:06 <aavogt> the point is that you could get by with only Behavior?
15:58:10 <sinelaw> noteventime, not at all. the reason for separating them in the application is for the implementation to follow the design.
15:58:25 <gwern> good news everyone! you're going to deliver a cargo of kisses to the planet Cosa Nostra IV!
15:58:26 <Veinor> I'm thinking of calling it "Dr. Haskelllove or: how I Learned to Stop Worrying and Love the Type System"
15:58:29 <gwern> and Control.Monad.void was pushed tonight
15:58:29 <Veinor> :D
15:58:57 <sinelaw> noteventime, why do they seem equivalent?
15:59:04 <monochrom> What is planet Cosa Nostra IV?
15:59:07 <noteventime> sinelaw: A sequence of values can be seen as a piecewise constant function with a countable number of jumps
15:59:12 <ehird> Does the Haskell Platform really depend on happy and alex?
15:59:16 <ehird> Or does it install them itself?
15:59:27 <gwern> monochrom: a planet due for a lot of kisses, apparently
15:59:27 <monochrom> does not depend
15:59:32 <sinelaw> noteventime, no, that's not equivalent. the best equivalent notion is a sum of dirac delta functions
15:59:53 * blackdog__ has a Hubris user apart from himself. apparently it almost compiles.
15:59:53 <sinelaw> noteventime, because the values of the event are only _defined_ at the specific time point in which they occur
16:00:16 <noteventime> sinelaw: Well, a sum of dirac delta functions then :)
16:00:24 <sinelaw> noteventime, what you describe is what's called a "zero order hold" (or "stepper" in frp) of an event
16:00:25 <monochrom> what is cosa nostra translated to english?
16:01:11 <monochrom> where may I read more about Control.Monad.void?
16:01:14 <sinelaw> noteventime, in the sense of a sum of dirac delta functions, you can say that events are equivalent to behaviors
16:01:18 <noteventime> sinelaw: Sure, as I said, I can see why you'd want to have both. What I can't see is how they'd be fundamentally different
16:01:26 <gwern> monochrom: libraries@
16:01:37 <gwern> or your friendly local base repo
16:02:10 <noteventime> Why they aren't just sequences of time-tagged values
16:02:18 <sinelaw> noteventime, what do you mean by "fundamentally"? They are different in that events are not defined except for a finite number of time points, unlike behaviors which are defined for all time
16:02:21 <noteventime> With increasing time
16:02:28 <monochrom> Is it on hackage yet? I'll look.
16:02:32 <ehird> Preprocessing executables for happy-1.18.4...
16:02:33 <ehird> Setup: The program happy is required but it could not be found
16:02:36 <sinelaw> noteventime, you mean why behaviors aren't a sequence?
16:02:39 <ehird> monochrom: i accuse you of incorrectness
16:02:48 <gwern> j'accuse tu, pikachu!
16:03:14 <ehird> incorrectosity
16:03:15 <noteventime> sinelaw: Yes, that too
16:03:23 <gwern> ehird: philistine
16:03:26 <noteventime> That direction may be more clear
16:03:28 <sinelaw> because you can't model a continuous function as a sequence
16:03:44 <sinelaw> noteventime, how is f x = 2*x a sequence?
16:03:45 <ehird> incorrectnessosity
16:03:47 <monochrom> ehird: when I built haskell-platform from source a week ago, I did not have happy.
16:03:53 <HugoDaniel> how do i add instances of IArray UArray ? it seems to me that the data constructor UArray is not being exported in Data.Array.Unboxed
16:03:59 <noteventime> sinelaw: It's a sequence indexed by an uncountable set
16:04:14 <noteventime> Well
16:04:14 <ehird> monochrom: s/a week ago/just now/; s/\.$/, and the compile failed because of this/
16:04:16 <sinelaw> noteventime, never heard of such a thing...
16:04:30 <ehird> noteventime: that sounds fun
16:04:33 <sinelaw> noteventime, how precisely do you define that?
16:04:49 <noteventime> A function defined on the real numbers
16:04:51 <sinelaw> and why is that any simpler than a continuous function? (our aim is simplicity also)
16:05:03 <noteventime> Just as you normally define a sequence as a function on the natural numbers
16:05:09 <sinelaw> noteventime, so a behavior is a sequence that is really a continuous function
16:05:13 <noteventime> I'm not saying it's simpler
16:05:15 <HugoDaniel> can someone help me please ?
16:05:41 <tener> I'm doing bits of type-level programming and just got the following error: <interactive>:1:24: Only unit numeric type pattern is valid
16:05:43 <noteventime> My problem is just that I can't see the difference between behaviour and event apart from the cardinality of the set they're defined on
16:05:43 <sinelaw> noteventime, if you come up with a simple way (dirac delta's are a possible direction) for unifying events and behaviors, i'll be glad to hear
16:05:57 <tener> I typed something like (1 <: 2 <: empty :: List 2 Int)
16:06:04 <ivanm> HugoDaniel: ummm.... last I checked UArray _was_ an instance of IArray
16:06:05 <sinelaw> noteventime, why is that a problem? that may be precisely the difference
16:06:13 <copumpkin> tener: 2 isn't a type
16:06:18 <tener> I know
16:06:18 <ivanm> @instances-importing Data.Array.Unboxed IArray
16:06:19 <HugoDaniel> ivanm: but i want it to support my datatype
16:06:19 <lambdabot> Array e, UArray Bool, UArray Char, UArray Double, UArray Float, UArray Int
16:06:19 <copumpkin> tener: it's a really annoying error
16:06:28 <HugoDaniel> which is (Double, Double, Double) btw
16:06:29 <noteventime> sinelaw: Then I find it strange they they are treated so very differently
16:06:29 <tener> I should have used (List Two Int)
16:06:50 <Ke> so ipc in hackage has no api description
16:06:52 <tener> but perhaps there is a way to instruct GHC to so that 2 is Two ?
16:07:03 <ivanm> HugoDaniel: I think the index is in Data.Array.IArray
16:07:04 <copumpkin> tener: one day, maybe :) a kindclass!
16:07:10 <HugoDaniel> i just keep getting No instance for (IArray UArray (Double, Double, Double))
16:07:13 <Ke> what would you guys use for ipc?
16:07:23 <ivanm> actually, it's in Data.Array.Base
16:07:28 <sinelaw> noteventime, that difference you pointed out is exactly why they are treated differently. there different things you might want (or be able) to do with each of them
16:07:35 <ivanm> HugoDaniel: make (Double, Double, Double) an instance of Ix
16:07:45 <ivanm> @instances-importing Data.Ix Ix
16:07:46 <lambdabot> (), (a, b), (a1, a2, a3), (a1, a2, a3, a4), Bool, Char, Int, Integer, Ordering
16:07:51 <ivanm> well, it should be...
16:07:58 <sinelaw> noteventime, and like I said, that model is not "ultimate". if you find a better one that unifies them, it would be great.
16:08:07 <ivanm> HugoDaniel: oh, it can't... because (a,b,c) isn't unboxed IIRC
16:08:16 <HugoDaniel> oh
16:08:17 <noteventime> sinelaw: But there's no difference between finite and countable sets, for example. It just seems a little ad-hoc
16:08:19 <ivanm> or am I getting the boxing stuff the wrong way round?
16:08:20 <HugoDaniel> so... how do i solve it ?
16:08:26 <ivanm> yup, I am...
16:08:36 <ivanm> no, I'm not...
16:08:45 <ivanm> HugoDaniel: just use IArray rather than UArray
16:08:52 <noteventime> sinelaw: I'd have to not suck at this first
16:09:13 <sinelaw> noteventime, you're arguing that there's "no difference", but agree that there is a difference. i don't understand what you're trying to say.
16:09:14 <noteventime> Going to try reading Conals paper again
16:09:46 <sinelaw> noteventime, that difference is what makes you use them differently, and that's why they have a different interface
16:09:47 <HugoDaniel> ivanm: !?
16:10:19 <HugoDaniel> isn't IArray a type class ?
16:10:53 <sinelaw> noteventime, at some hyper-generalized level, they are the same, if that's what you're trying to say
16:11:04 <sinelaw> maybe not even so hyper. that's why we're trying to find out
16:11:06 <noteventime> sinelaw: I guess my problem is why they're not just something like "Behaviour a = Reactive Real a" and "Event a = Reactive Nat a", or is that how they're supposed to be interpreted?
16:11:11 <sinelaw> s/why/what/
16:11:54 <aavogt> Dave Ng
16:12:01 <sinelaw> noteventime, i'm not too up to date w.r.t the push-pull paper myself, but i don't think he unified them at that level
16:12:35 <sinelaw> noteventime, all I can say is that you're not supposed to guess their interpretation, it's something that conal likes to define precisely.
16:12:58 <ehird> [00:06] <copumpkin> tener: one day, maybe :) a kindclass!
16:13:01 <ehird> Agda is that way →
16:13:02 <sinelaw> and as far as I remember, it's that Event a = sequence, Behavior a = function
16:14:11 <noteventime> sinelaw: Sure, but a sequence is a function
16:14:29 <sinelaw> noteventime, but not a continuous one
16:14:29 <noteventime> Hmm
16:14:34 <Stinger> sequence is a bad term imo, implies regularity
16:14:38 <Stinger> where there may be none
16:14:57 <noteventime> Behaviour is a function on R while Event is one on a countable subset of R
16:15:04 <sinelaw> Behavior = function of continuous time
16:15:12 <noteventime> Well
16:15:13 <noteventime> R*
16:15:16 <noteventime> To be precise
16:15:24 <noteventime> Or was that R+
16:15:31 <tener> ehird: I heard you can simulate dependent types in Haskell, with certain extensions, but I don't really remember which
16:16:12 <Berengal> tener: There's she, which gives your dependent types through magic preprocessing
16:16:14 <sinelaw> noteventime, that's another way to look at it, yes, but conal's definition gives a clearer notion of what the interface for events should be, in my opinion. unless you convince me otherwise
16:16:30 <sinelaw> (i'm talking about events)
16:17:02 <copumpkin> ehird: not really
16:17:08 <copumpkin> tener: sort of
16:17:10 <Stinger> what was conals defn?
16:17:26 <Berengal> tener: And with GADTs and type families you can have the result type of a function being indexed by the type of the argument in nontrivial ways
16:17:38 <sinelaw> noteventime, in any case, the model in the push-pull paper has some other problems, see conal's blog
16:17:54 <Stinger> oh I have to READ something, pass
16:18:05 <Berengal> Haskell pretty much stands at the precipice of dependent types already, except it doesn't have them yet...
16:18:44 <ehird> Berengal: She doesn't give you dependent types.
16:18:51 <augur_> so im going to be teaching an intro to programming tutorial course for linguists this upcoming semester. any suggestions guys?
16:18:58 <ehird> It just automatically translates constructors into types for you.
16:19:12 <ehird> Type families let you translate functions to types.
16:19:19 <ehird> But still nothing that lets values cross the :: barrier.
16:19:57 <taruti> Is there a GHC extension to allow record field disambiguation inside a single module? e.g. "data A = A { x :: Int }; data B = B { x :: Int}" ?
16:21:14 <Philonous1> taruti: No, but you can have it with class HasX where x :: Int and instance HasX A where x = ...
16:21:36 <Berengal> ehird: It's dependent enough for impractical purposes. You have to define each function twice if you want to use it in both value expressions and type expressions, but other than that, using constructors in types is pretty much what dependent typing is
16:22:02 <Philippa_> augur_: cover a little bit of parsing? You might have to build a library for non-deterministic parsing, mind
16:22:17 <sinelaw> augur_, maybe for some cool demos that connect the two fields, look at http://www.cs.chalmers.se/~aarne/GF/
16:22:25 <taruti> Philonous1: so it is "create a dozen modules to do it" ? (I don't want a class in this case) :(
16:22:27 <ehird> Berengal: "for impractical purposes" :-D
16:23:15 <Berengal> ehird: Yes, well, calling dependent typing in Haskell practical would be a stretch in any universe :P
16:23:38 <ehird> I love dependent types
16:23:49 <sinelaw> augur_, there are demos on this page http://www.cs.chalmers.se/~aarne/GF/demos/index.html
16:24:40 <noteventime> sinelaw: I'll go through the paper and read the blog posts :)
16:24:44 <augur_> Philippa_, sinelaw i cant do anything too complex, it has to be for true beginners
16:24:46 <sohum> haskell neeeds a beter namespace system
16:24:49 <ehird> they're already bridged as much as they need to be, iirc there's isomorphisms between all of {linguistics,logic,programming}
16:24:54 <sohum> *better
16:25:04 <ehird> I think linguistics←→logic and then linguistics←→programming is derived per curry-howard
16:25:08 <sinelaw> augur_, that's just to show what's possible
16:25:08 <augur_> im really just looking for like suggestions on how to teach programming
16:25:30 <sinelaw> oh
16:26:14 <ehird> first, apply Haskell
16:26:19 <ehird> second, don't apply anything that is not Haskell
16:26:30 <augur_> im actually probably going to do it SICP style, because scheme has a simple, consistent, unambiguous grammar
16:26:37 <ehird> #scheme is that way
16:26:38 <ehird> →
16:26:39 <lunabot>  luna: Not in scope: `scheme'
16:26:51 <augur> ehird :P
16:26:56 <ehird> (haskell has a "consistent and unambiguous grammar" too.)
16:27:03 <ehird> (and it's not very complex, either)
16:27:14 <augur> eh. but i'd have to explain why you have to use ()'s around some functions when doing fold
16:27:18 <ehird> augur: I don't see how "how should I teach Scheme" is even remotely related to #haskell
16:27:25 <augur> and then i'd have to explain types
16:27:27 <Berengal> The types are a bit complex...
16:27:34 <augur> ehird, im not asking how i should teach scheme
16:27:39 <augur> im asking how i should teach programming
16:27:43 <ehird> Berengal: but also a key part of programming.
16:27:47 <ehird> augur: in #haskell
16:27:57 <augur> yes, but #haskell is effectively #compsci
16:28:06 <augur> given that #compsci is worthless
16:28:07 <ehird> strange definition of effectively
16:28:15 <copumpkin> it is
16:28:16 <augur> and everyone here is hardcore compsci.
16:28:20 <copumpkin> compsci
16:28:31 <Berengal> Well, it's not like scheme doesn't have types, but people don't like being told they're wrong by a machine. They prefer finding that out themselves, after a long debugging session
16:28:36 <pikhq> ehird: Well, Haskellers deal with actual computer science more than most. :P
16:28:44 <Berengal> That is, unless they've done so a couple of times and found the process tedious
16:29:14 <ehird> Berengal: only because that's what they're used to
16:29:21 <augur> but the fact that im using scheme is semi-tangential. im just looking for advice on what sorts of things should be addressed and so forth
16:30:11 <mental> by far the best CS tutorial for beginners is "Land of Lisp"
16:31:28 <ivanm> HugoDaniel: sorry, just use Array
16:31:34 <ivanm> (I was afk for a bit)
16:31:57 <Berengal> ehird: Utter noobs tend to go "Wha?" whenever you introduce a new concept. Getting to types may take a week or two.
16:32:13 <ivanm> HugoDaniel: unless you have an unboxed version of (Double, Double, Double) [see dons' blog post about adaptive lists), you can't use UArray
16:32:15 <ksf> waaagh types are dead simple.
16:32:20 <ehird> Berengal: Explain types first, then explain values.
16:32:24 <noteventime> Couldn't it be interesting to introduce programming beginning with types?
16:32:32 <ksf> there's Naturals, there's Integers, theres Rationals, and Reals.
16:32:33 <ehird> Seriously — we explain types when we say "so, 2 is a number".
16:32:43 <ehird> It's just most of the time we explain them with limited, vague types that aren't documented.
16:32:45 <ehird> And that's uber-lame.
16:32:48 <noteventime> ehird: You beat me to it :)
16:32:50 <ksf> 2 is a Natural
16:32:57 <ksf> not a "number"
16:33:02 <Berengal> ehird: Types don't make sense without values, and programming is going to be very boring if you can't write Hello World after the first lecture.
16:33:05 <ksf> you're already into kinds, there.
16:33:07 <hatds> :t 2
16:33:08 <lambdabot> forall t. (Num t) => t
16:33:09 <idnar> @type 2
16:33:10 <lambdabot> forall t. (Num t) => t
16:33:21 <copumpkin> ksf: it's a bunch of types
16:33:23 <ehird> Berengal: who said it had to take up that long
16:33:26 <damd> a type is a kind of value *FFFFFUUUU...*
16:33:27 <idnar> sure looks like a number to me ;)
16:33:36 <idnar> damd: and a kind is a sort of type?
16:33:36 <ehird> damd: and a value is a kind of type
16:33:39 <ehird> there, dependent programming!
16:33:48 * ksf wonders whether typeclasses and kinds are isomorphic and whether he'd understand the answer
16:33:56 <ehird> idnar: congratulations, you just named metakinds
16:33:57 <ehird> they're sorts
16:34:04 <ehird> and a sort is a ? of kind
16:34:05 <damd> what kind of values do types hold?
16:34:08 <ehird> quick, someone fill in ?!
16:34:09 <idnar> a sort is a bit of a kind
16:34:23 <ehird> idnar: that makes no sense! :P
16:34:27 <idnar> although it's pretty unkind if you ask me
16:34:28 <damd> :t sort
16:34:29 <lambdabot> forall a. (Ord a) => [a] -> [a]
16:34:34 <Berengal> With dependent typing, the sort-hierarchy just folds in on itself
16:34:34 <damd> clearly sort is a value
16:34:35 <ehird> a sort is a class of kind
16:34:45 <idnar> a herd of kinds
16:34:50 <ehird> a class is a ? of sorts
16:34:50 <ksf> don't forget kindfaculties and sortuniversities.
16:34:59 <idnar> ksf: haha
16:35:03 <ehird> lol
16:35:06 <Berengal> Hehe
16:35:10 <ehird> classcongregations
16:35:23 <idnar> Berengal: is dependent typing what happens if you run your children through an inferencer?
16:35:27 <ehird> we'd better stop before Oleg gets lost in the hierarchy
16:35:44 <ksf> oleg _is_ the hierarchy.
16:35:51 <ehird> "Implementing Hygenic Macros using Class Congregations and Mu-Recursive Functions"
16:36:04 <damd> hygenic?
16:36:21 <Berengal> idnar: dependent typing is what happens if you let logicians near computers for long enough.
16:36:32 <idnar> damd: they wash their hands after they go to the little macros' room
16:36:43 <copumpkin> dependent types are fun but I'm not sure they'll ever be practical
16:36:45 <copumpkin> who knows though
16:36:46 <idnar> Berengal: so it's like an allergic reaction?
16:36:48 <ehird> damd: google it :P
16:36:53 <damd> idnar: so lisp is like the brothel of programming languages :|
16:37:03 <idnar> hahahaha
16:37:08 <ehird> damd: PRECISELY!
16:37:18 <ksf> nah I've heard they do safe sex in brothels.
16:37:27 <mental> @quote paradigm
16:37:27 <lambdabot> lennart says: I think people who come from imperative programming come with a mind set that you understand your code by stepping through it in the debugger.  But I find this paradigm much less
16:37:27 <lambdabot> useful for functional code
16:37:32 <mental> @quote paradigm
16:37:32 <lambdabot> qwe1234 says: i can write clean and 'expressive' code (quickly) in any language and paradigm, thank you very much.
16:37:34 <copumpkin> ksf: did "a friend" tell you that?
16:37:39 <tryggvib> Does anybody now how much memory the compilation of cabal takes?
16:37:56 <ksf> copumpkin, nope.
16:37:58 <dcoutts_> tryggvib: are you getting problems with linking?
16:37:58 <aavogt> @quote leet
16:37:59 <lambdabot> No quotes match. BOB says:  You seem to have forgotten your passwd, enter another!
16:38:03 <mental> does anyone know the quote that says that anyone who uses the word paradigm without knowing the dictionary definition should be shot?
16:38:26 <hatds> what's the word paradigm?
16:38:32 <ksf> paradigm == dogma, at least in my head
16:38:32 <dfrey> I have a C++ question, but it's related to Haskell.  I run into scenarios fairly frequently where I want to write a getX() method, but you can only call getX() if hasX() is true.  The problem is that it's expensive to find X, so you end up essentially finding X, forgetting where it is and then finding it again before returning it.  In Haskell, I would have the function return a Maybe X, but I don't see that idiom used in C++.  How do people solve that
16:38:32 <dfrey>  problem in C++?
16:38:40 <tryggvib> dcoutts_: yes, ubuntu kills ghc with an out of memory message
16:38:54 <dcoutts_> tryggvib: kills ghc, or kills ld?
16:38:58 <tryggvib> ghc
16:39:19 <dcoutts_> tryggvib: oh, that's much more rare
16:39:26 <ksf> dfrey, return null
16:39:51 <ksf> ...or, preferrably, a maybe type and code yourself a sequencing abstraction.
16:39:55 <tryggvib> dcoutts_: I only have 512 in memory but I've turned everything off (no graphics running and I still get an out of memory)
16:39:56 <dcoutts_> tryggvib: are you absolutely sure? it killing ld might look rather similar since ghc will then terminate too
16:40:12 <tryggvib> dcoutts_: I'll try again
16:40:18 <noteventime> Hmm, could FRP on a partially ordered time type be used to model nondeterministic reactive things
16:40:33 <ksf> tryggvib, you absolutely should have swap if you've got that amount of memory
16:40:36 <dcoutts_> tryggvib: the usual problem for low memory machines is that the "split objs" feature makes ld take loads of memory
16:40:55 <ksf> ...have at least 2G, better 4G total virtual mem.
16:41:16 <dcoutts_> tryggvib: unfortunately the only way to get ghc built without the base libs using splitobjs is to rebuild it from source
16:41:43 <dcoutts_> tryggvib: the gentoo ebuild (source build) turns off splitobjs for machines with 512 or less for exactly this reason
16:41:52 <tryggvib> ksf: yes I know... my bad but I'm stuck with this for now
16:42:23 <tryggvib> dcoutts_: I would guess that it's ld that's crashing because it happens during "Linking"
16:42:28 <dfrey> ksf: null pointers kind of suck because the client usually forgets to check them.  What did you mean by "a sequencing abstraction"?
16:42:35 <dcoutts_> tryggvib: so one option is to build ghc from source with SplitObjs=NO in mk/build.mk
16:42:43 <tryggvib> dcoutts_: great
16:43:10 <tryggvib> dcoutts_: I am trying to install pandoc so that I don't have to use OpenOffice.org (memory hog)
16:43:18 <dcoutts_> tryggvib: see the ghc building guide for more details on using mk/build.mk to control details of the build
16:44:08 <dcoutts_> tryggvib: note that a source build of ghc will take some time, if you have access to another linux machine with more memory that'd be quicker, build a pandoc binary and copy it over.
16:44:19 <tryggvib> dcoutts_: I should be able to install this on another machine and copy the binaries over right?
16:44:32 <tryggvib> dcoutts_: exactly :D
16:45:10 <dcoutts_> tryggvib: by default ghc produced executables are statically linked to all the base Haskell libs
16:45:45 <dcoutts_> which is partly what the "split objs" feature is for, to reduce the size of the final statically linked exe
16:46:53 <tryggvib> dcoutts_: thanks a bunch... you've saved me from a lot of frustration
16:47:02 <dcoutts_> np
16:51:21 <Guest7203> hello !
16:51:37 <damd> Hello!  How do you do this fine evening?
16:51:46 <Guest7203> good...
16:51:47 <damd> Let me know if I can assist you with any requests you may have.
16:51:58 <Guest7203> thanks...
16:52:40 <Guest7203> I would like to ask how I can do a list of float numbers in haskell...
16:52:54 <damd> > [3.4, 2.8]
16:52:55 <lambdabot>   [3.4,2.8]
16:53:04 <Guest7203> I mean generate...
16:53:12 <damd> how should they be generated?  randomly?
16:53:19 <Guest7203> Like [ 0.1 .. 1 ]
16:53:30 <damd> oh, i see...
16:53:32 <ksf> > [0.1,0.2..1]
16:53:34 <lambdabot>   [0.1,0.2,0.30000000000000004,0.4000000000000001,0.5000000000000001,0.600000...
16:53:48 <Guest7203> yes...
16:53:48 <ksf> > [0.1,0.2..1] :: CReal
16:53:49 <lambdabot>   Couldn't match expected type `Data.Number.CReal.CReal'
16:53:50 <lambdabot>         against infe...
16:54:02 <damd> > [0.1,0.2..1.0] :: CReal -- hm?
16:54:02 <ksf> > [0.1,0.2..1] :: [CReal]
16:54:03 <lambdabot>   Couldn't match expected type `Data.Number.CReal.CReal'
16:54:04 <lambdabot>         against infe...
16:54:04 <lambdabot>   [0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0]
16:54:32 <aavogt> > [exp 1 .. pi]
16:54:33 <lambdabot>   [2.718281828459045]
16:54:38 <ksf> > 1/3 :: CReal
16:54:39 <lambdabot>   0.3333333333333333333333333333333333333333
16:54:54 <Guest7203> yes I would like the one  you have just did
16:55:37 <ksf> CReal means computable real, that is you've got infinite precision and possible non-termination
16:55:41 <damd> That will be 5 USD.  What method of payment would you prefer?
16:55:48 <Stinger> > [0.1 .. 5.1] :: [CReal]
16:55:48 <lambdabot>   [0.1,1.1,2.1,3.1,4.1,5.1]
16:55:52 <ksf> > sin 1.4 :: CReal
16:55:53 <lambdabot>   0.9854497299884601806594745788060975173563
16:56:17 <sinelaw_> @hoogle hSetEncoding
16:56:18 <lambdabot> No results found
16:56:33 <Guest7203> let me try!
16:56:40 <Guest7203> just a moment!
16:56:45 <tener> what should I use to include a nice, colorized haskell into beamer presentation?
16:56:54 <sinelaw_> @hoogle Handle -> TextEncoding -> IO ()
16:56:54 <lambdabot> Warning: Unknown type TextEncoding
16:56:54 <lambdabot> Network.BufferType buf_hPut :: BufferOp a -> Handle -> a -> IO ()
16:56:54 <lambdabot> System.IO hPrint :: Show a => Handle -> a -> IO ()
16:56:58 <ksf> tener, hscolour
16:57:50 <Guest7203> I have installed hscolor in my ubuntu but the code isn't colorized in terminal...
16:58:19 <Guest7203> is it just install ot it need configurations?
16:58:48 <tener> ksf: ah, thank you. I wasn't aware it can output *tex files too
16:59:46 <ksf> Guest7203, depends on how you call it.
17:00:06 <ksf> just starting HsColour should colourize what you type (after pressing enter)
17:04:17 <Guest7203> lambdabot, I didnt understand the :: [CReal]...
17:04:48 <Guest7203> my compilers is not recognizing this type...
17:06:01 <ksf> @vixen , you know, it's polite to answer questions that people ask you directly
17:06:01 <lambdabot> yeah, i know
17:06:33 <ksf> @vixen so do you plan on improving your ways?
17:06:34 <lambdabot> then we have something in common
17:06:55 <ksf> @vixen great! let's make out
17:06:56 <lambdabot> great is like a very good good
17:08:31 <ksf> @hoogle CReal
17:08:31 <lambdabot> No results found
17:09:24 <zygoloid> Guest7203: CReal isn't a standard type. i would recommend not specifying a type for now; defaulting will pick Double for you, which is probably what you want anyway
17:09:30 <ksf> http://hackage.haskell.org/packages/archive/numbers/2009.8.9/doc/html/Data-Number-CReal.html
17:09:58 <sinelaw_> i get this error:
17:10:01 <Veinor> 20:06:32 < lambdabot> great is like a very good good
17:10:02 <sinelaw_> Prelude.chr: bad argument
17:10:04 <Veinor> this is pretty hilarious.
17:10:13 <zygoloid> > [0.0, 0.1 .. 1.0]
17:10:14 <lambdabot>   [0.0,0.1,0.2,0.30000000000000004,0.4000000000000001,0.5000000000000001,0.60...
17:10:16 <sinelaw_> how can i know what causes that?
17:10:20 <ksf> it is perfecly grammatical and makes perfect sense.
17:10:33 <sinelaw_> my code doesn't call 'chr'
17:10:38 <ksf> > chr (-1)
17:10:38 <lambdabot>   * Exception: Prelude.chr: bad argument
17:10:44 <ksf> then something else does?
17:10:57 <zygoloid> > chr 1114112
17:10:58 <lambdabot>   * Exception: Prelude.chr: bad argument
17:10:59 <sinelaw_> yes, but how do i know who?
17:11:08 <ksf> haskell lacking proper stacktraces is a discordian conspiracy.
17:11:24 <zygoloid> sinelaw_: you paste your code and someone tells you :)
17:11:34 <mreh> it's my birthday!
17:11:39 <zygoloid> '
17:11:40 <ksf> plaster Debug.Trace all over the place
17:11:52 <zygoloid> #haskell is a great haskell debugger
17:11:52 <ksf> mreh, cake or it didn't happen.
17:11:53 <lunabot>  luna: Not in scope: `haskell'
17:12:10 <sinelaw_> mreh, happy birthday! it's also my nephew's
17:12:15 <mreh> ksf: there's no cake
17:12:27 <mreh> thankyou sinelaw_
17:13:02 <Guest7203> thanks zygoloid ans ksf
17:13:02 <taruti> DisambiguateRecordFields does not even allow for re-exporting the modules with conflicting field names :(
17:13:04 <mreh> I don't do cake, I don't really do birthdays, I just felt like announcing that to the world
17:16:03 <Guest7203> actually a would like a output like this {0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1]
17:16:23 <monochrom> happy birthday to you all
17:16:44 <Guest7203> The default double is with a lot of that floating point imprecisions..
17:16:57 <sinelaw_> isn't there a way to get something like a traceback for runtime exceptions?
17:17:06 <monochrom> > map (0.1 * ) [1..10]
17:17:06 <sinelaw_> i just want to know how Prelude.chr was called
17:17:07 <lambdabot>   [0.1,0.2,0.30000000000000004,0.4,0.5,0.6000000000000001,0.7000000000000001,...
17:17:13 <erikc> o sweet, kindle dx global jan 19...has anyone tried a kindle dx with pdf/ps academic papers?
17:17:16 <sinelaw_> a traceback would be enough
17:17:18 <monochrom> Oh bother
17:17:24 <sinelaw_> but how?
17:17:33 <monochrom> > map (\x -> 0.1 * fromIntegral x) [1..10]
17:17:34 <ksf> sinelaw_, they recently added it, and it's described
17:17:35 <lambdabot>   [0.1,0.2,0.30000000000000004,0.4,0.5,0.6000000000000001,0.7000000000000001,...
17:17:36 <ksf> somewher.
17:17:42 <monochrom> can't be helped.
17:18:22 <Guest7203> monochrom, the output was.
17:18:33 <Guest7203> [0.1,0.2,0.30000000000000004,0.4,0.5,0.6000000000000001,0.7000000000000001,0.8,0.9,1.0]
17:18:38 <mreh> preflex: seen mmorrow
17:18:38 <preflex>  mmorrow was last seen on #ghc 17 hours, 52 minutes and 4 seconds ago, saying: heh
17:18:56 <ksf> sinelaw_, try http://www.cse.unsw.edu.au/~dons/loch.html
17:18:57 <Guest7203> how can i haldle this rounding errors?
17:19:03 <Guest7203> ops..handle...
17:19:14 <sinelaw_> ksf thanks
17:19:21 <ksf> also, http://research.microsoft.com/~simonpj/papers/stack-trace/DebugTraces.pdf
17:20:16 <Ke> how lovely that localtime is not Ord
17:20:18 <Guest7203> in imperative programming its just use a for loop that add 0.1
17:20:36 <ksf> it's the same in haskell
17:20:37 <Guest7203> but here I want to cut the .000000000000003131
17:20:43 <Guest7203> stuff
17:20:57 <c_wraith> Why do you think imperative languages don't have rounding errors in floating-point values?
17:21:13 <ksf> > map (showFFloat 4 "") [1,1.1..]
17:21:14 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe GHC.Types.Int))
17:21:14 <lambdabot>    arising f...
17:21:15 <Guest7203> Sorry, I 'm  not a professional programmer
17:21:29 <ksf> > map (showFFloat (Just 4) "") [1,1.1..]
17:21:30 <lambdabot>   No instance for (GHC.Float.RealFloat [GHC.Types.Char])
17:21:30 <lambdabot>    arising from a us...
17:21:30 <monochrom> because C's printf display only 5 digits by default
17:21:40 <monochrom> OK 6 digits.
17:21:44 <ksf> :t showFFloat
17:21:45 <lambdabot> forall a. (RealFloat a) => Maybe Int -> a -> String -> String
17:21:50 <Guest7203> I don t say that
17:21:58 <ksf> > map (\x -> showFFloat (Just 6) x "") [1,1.1..]
17:21:59 <lambdabot>   ["1.000000","1.100000","1.200000","1.300000","1.400000","1.500000","1.60000...
17:23:02 <ksf> the thing is, you can't cut the error and still use a floating type, they're designed that way.
17:23:11 <monochrom> Really, double has about 18 digits. Try to get your favourite imperative language to show them all some day. You will be amazed by how much you have been lied to.
17:24:03 <ksf> many, many more or less even fraction just aren't representable and are thus approximated
17:24:19 <Guest7203> guys I junt wanna do a simple list of 0.1,0.2,0.3...
17:24:40 <ksf> ...the question is what you're going to use it for
17:24:59 <Guest7203> Iḿ not a computer science guy...
17:25:14 <Adamant> does that DebugTraces paper actually show up for anyone at any point?
17:25:18 <c_wraith> you know, someone pointed out the OMGPonies article earlier..
17:25:24 <c_wraith> And it's all about this problem.
17:25:26 <Adamant> I think this is the third time I've tried to download it, and nada.
17:25:55 <ksf> Adamant, works just fine
17:26:16 <c_wraith> Guest7203: the data type used for decimal numbers most of the time doesn't support numbers like 1.3 exactly.  If this is a problem for you, reconsider what you're trying to do.
17:26:17 <Guest7203> I wanna do a function that the input is the list 0.1,0.2...
17:26:41 <c_wraith> Guest7203: most likely, what you want to do is ignore it, and just truncate the output.
17:26:51 <ksf> http://scholar.google.de/scholar?cluster=4390299548607697538&hl=de&as_sdt=2000
17:27:10 <monochrom> lambdabot is just being honest about how Double can't possibly be exact.
17:27:19 <Guest7203> Itś not a problem for me cause for example in python I could do...
17:27:37 <Guest7203> a lis exactly The way i want...
17:27:39 <c_wraith> Guest7203: python lied to you.  It certainly uses an inexact type.
17:27:56 <copumpkin> > let f 0.2 = 5 in f (0.1 + 0.1)
17:27:58 <lambdabot>   5
17:27:59 <Adamant> ksf: thanks, I thought it was just that paper, but apparently the whole research.microsoft.com domain is unreachable from here despite being obviously up
17:27:59 <Adamant> 
17:28:03 <monochrom> You are here saying "I'm just trying to be a simple guy". Well lambdabot is here saying "I'm just trying to be an honest girl". I'm sorry apart from my condolence I don't know what else to say.
17:28:31 <ksf> @vixen are you honest?
17:28:32 <lambdabot> i'm always honest
17:28:36 <ksf> see?
17:28:39 <Guest7203> No, I'ĺl explain....
17:28:41 <c_wraith> @vixen are you lying?
17:28:41 <lambdabot> i'm being totally honest
17:28:43 <copumpkin> > let f 0.2 = 5 in f (sum (replicate 200 0.0001))
17:28:44 <lambdabot>   * Exception: <interactive>:1:181-189: Non-exhaustive patterns in function f
17:28:53 <aavogt> @vixen are you not lying?
17:28:54 <lambdabot> i never lie!
17:29:02 <Guest7203> I could do...
17:29:25 <Guest7203> Sorry I need to go, Iĺl study more....
17:29:39 <Guest7203> Tomorrow I will be here again...
17:29:47 <Guest7203> Thasks everybody....
17:29:55 <monochrom> Get python to show you 18 digits so you see it's also like 0.30000000000000004, for crying out loud.
17:30:46 <c_wraith> well, he left.  But in python, sum([.3]*10) is not even shown as 3.
17:31:13 <monochrom> Why do people believe their computers.
17:31:30 <ksf> because they simulate determinism
17:31:39 <monochrom> The modern computer has so many dozen layers of abstraction, any single layer can screw them over.
17:31:48 <ksf> which is the exact same thing most people assume they are expressing.
17:31:59 <ksf> let's call it co-illusive behaviour.
17:33:02 <c_wraith> people are also used to things like Excel, which uses a BCD format, IIRC, so can store things like .3 exactly.
17:33:33 <monochrom> The other prototypical problem of this kind is "I have a character é in my file, why is this program not getting it".
17:33:36 <ksf> stuff like excel comes with more than one numeric type
17:33:51 <c_wraith> ksf: I'm just thinking about the default type.
17:33:55 <ksf> accountants know that kind of stuff, they care about their rounding errors and modes.
17:34:11 <c_wraith> But yes.  accounting is a case where getting rounding right is vital.
17:34:24 <sjanssen_> I found Guest's "I'm not a computer science guy" rationalization a bit scary
17:34:39 <joe1> i have a .hs file and after loading it with ghci, I am trying to use the function from the prompt, and I am getting "Not in Scope".I think I am missing something simple. Any thoughts, please?
17:34:45 <c_wraith> sjanssen: It just means "I don't want to have to learn".
17:34:56 <monochrom> There are so many stages of encoding and decoding from the file system to your program and then to your text screen or GUI that any mismatch at any boundary will screw your é character.
17:35:09 <ksf> joe1, did you :m a module in the meantime?
17:35:18 <sjanssen> I think we ought to have "FPU Permits", like we do with guns and driving
17:35:22 <monochrom> FWIW you probably don't even have infallible evidence that you really have é in your file.
17:35:29 <joe1> ksf: no
17:35:46 <joe1> Prelude Main GOA> :t getdata
17:35:46 <joe1> <interactive>:1:0: Not in scope: `getdata'
17:36:09 <ksf> GOA is your module?
17:36:12 <c_wraith> joe1: did you load it with :load ?
17:36:20 <c_wraith> because that doesn't look like it
17:36:40 <joe1> i started with "ghci <module.hs>"
17:36:58 <ksf> is the fun mentioned in your export list, if you have one?
17:37:50 <joe1> it is actually "ghci <file.hs>"
17:39:05 <joe1> c_wraith: I think I am missing something simple. it was working till a few hours ago..
17:39:27 <c_wraith> joe1: do you have a compiled version of that file in the same place, with a .o and a .hi?
17:39:36 <joe1> c_wraith: yes.
17:39:42 <c_wraith> delete them.
17:39:46 <joe1> oh, ok..
17:40:10 <ben0x539> Why is that necessary?
17:40:15 <ksf> inlining.
17:40:20 <c_wraith> I have no clue.  But it's fixed the same problem for me, many times.
17:40:33 <ksf> ghc optimizes stuff away, and ghci is loading the compiled stuff if it's there instead of interpreting.
17:40:36 <ben0x539> Why does ghci not look up the original definitions anyway?
17:40:38 <joe1> c_wraith: that took care of it.
17:40:47 <c_wraith> joe1: glad to hear it
17:41:00 <ksf> ben0x539, because you might want to run -O2 code
17:41:02 <joe1> c_wraith: i had used "ghc --make -O3 <file.hs>"
17:41:12 <joe1> but looks like it bothers with ghci
17:41:13 <c_wraith> I think there's a way to force ghci to load the source file, but I never learned what it is
17:41:27 <ben0x539> ksf: It can take the -O2 code from the compiled file and the inlined functions from the .hs file
17:41:31 <ksf> probably -interpreted or something.
17:41:41 <ksf> ben0x539, patches welcome?
17:42:11 <monochrom> :load *file.hs
17:42:21 <monochrom> IOW add *
17:42:23 <jrockway> wow, the haskell platform for windows works *perfectly*
17:42:34 <ksf> * is a horrible choice, if that's true
17:42:35 <jrockway> i spent a day trying to get visual C++ to let me link to this library some vendor gave us
17:42:39 <jrockway> the haskell FFI worked immediately
17:42:42 <c_wraith> ah, is that all?  Thanks, monochrom
17:42:46 <jrockway> and now i can write the app in haskell instead of C++
17:42:58 <jrockway> (cabal install also works perfectly from emacs' eshell!)
17:43:08 <monochrom> I learned it just yesterday because I was bored and so I read the ghc manual.
17:43:20 <c_wraith> the things you learn by reading the manual....
17:43:28 <c_wraith> it's almost like it's intended to be read
17:43:33 <joe1> monochrom: what does it do?
17:43:46 <monochrom> Tonight if I can't sleep I might end up learning homotopy, who knows...
17:44:02 <monochrom> joe1: The * instructs ghci to ignore .hi and .8
17:44:06 <monochrom> s/8/o/
17:44:44 <monochrom> Normally ghci decides based on timestamps. I support it because compiled modules are faster.
17:45:58 <monochrom> Sadly the * gets into the way of auto-completion!
17:47:12 <ksf> zsh even makes me escape it if no glob fits.
17:47:57 <joe1> the code was really going slow from the ghci prompt, I thought compiling it with O3 might speed it up.
17:48:24 <joe1> as i was suggested that the ghci loads the compiled file.
17:48:28 <ben0x539> Is there a way to tell ghc "yo, I am going to need this, do not optimise it away"?
17:48:39 <ksf> you can export the function you want to test explicitely and use -O2 (-O3 is the same), and then call it.
17:49:03 <ben0x539> Does exporting a function prevent it from being inlined within the module?
17:49:04 <ksf> I think there's even a way to make ghci compile stuff.
17:49:09 <ksf> nope
17:49:12 <kmc_> {-# NOINLINE #-}
17:49:28 <ksf> it can be cross-module inlined, too.
17:49:30 <Veinor> {-# DOWHATIWANT #-}
17:49:32 <joe1> no, it is not a module. though the function is a top level function.
17:49:50 <monochrom> You can turn off individual optimizations. The manual lists the flags. Too many of them.
17:51:46 <kmc_> funbox!
17:51:50 <kmc_> @quote funbox
17:51:51 <lambdabot> No quotes match. It can only be attributed to human error.
17:53:16 <Veinor> you can't spell it without fun, you know
17:53:27 <kmc_> you can't spell funroll without fun either
17:55:54 <Axman6> mmmmmmmm funrolls
17:56:10 <kmc_> are funrolls like love handles?
18:02:29 * BMeph observes that you can't spell "funeral" without "fun" either. Which holds no implications whatsoever.
18:03:21 <tensorpudding> can't spell dysfunctional without fun either
18:03:32 <ksf> or "enjoyment"
18:05:06 <amigoo> you can spell it like "furenal"
18:05:18 <Veinor> you can't spell party without arty!
18:05:21 <Veinor> unless you misspell party
18:05:22 <BMeph> Remember kids, you can't spell "slaughter" without "laughter"... ;p
18:05:24 <Veinor> or arty
18:05:33 <Veinor> BMeph: Stop Horses' Slaughter....
18:05:37 <Veinor> er
18:05:45 <Veinor> Stop Horse Slaughter.... or Stop Horses' Laughter?
18:08:19 <ivanm> Veinor: wtf? horses are laughing?
18:08:37 <ksf> especially behind your back
18:08:46 <idnar> haha
18:09:06 <idnar> Stop Horse's Laughter
18:12:21 <taruti> What does "Exception when trying to run compile-time code" mean in code that doesn't use TH (GHC 6.12.1)? Seems related to a global variable defined with unsafePerformIO.
18:13:47 <turiya> hi
18:14:39 <turiya> What does principal type mean?
18:19:54 <monochrom> turiya: something like this: if you write (\x -> [x]), you could call it "Int -> [Int]" or "Bool -> [Bool]", but the principal type is "a -> [a]".
18:22:29 <turiya> monochrom: the gentle introduction says that the types [b]->a, a->a, a are correct types for head, i can understand [b]->a but not a->a and a. How are these correct types for head?
18:22:43 <taruti> ah found it. forgetting 'error "Foobar"' in the source compiles that with 6.12 as TH and fails :)
18:23:22 <turiya> monochrom: if i write \x->x+1 in ghci it gives me an error
18:23:24 <monochrom> I don't even see why [b]->a is correct for head.
18:23:41 <turiya> monochrom: it is more general, i think
18:24:23 <monochrom> Also I read the gentle introduction to learn my haskell but I don't recall seeing that.
18:24:37 <ivanm> turiya: head takes a list of values and returns a single value
18:25:00 <turiya> monochrome: page 5 in gentle introduction
18:25:01 <ivanm> monochrom: how isn't it? head [1] can't suddenly become "hi"
18:25:20 <aavogt> @type fix head
18:25:20 <ivanm> but saying a -> a is a type for head doesn't make sense either; because that means that head 1 makes sense
18:25:21 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
18:25:21 <lambdabot>       Expected type: [a]
18:25:21 <lambdabot>       Inferred type: a
18:25:32 <aavogt> @type fix (return . head)
18:25:33 <lambdabot> forall a. [a]
18:26:36 <monochrom> ivanm: Are you saying [b]->a can be a correct type for head?
18:27:03 <ivanm> monochrom: no, I'm saying it can't
18:27:15 <monochrom> Then we are in agreement.
18:27:16 <ivanm> monochrom: oh, I thought you said you couldn't see why it _wasn't_ a correct type
18:27:19 <ivanm> I misread you ;-)
18:27:22 <turiya> ivanm: [b]->a is more general it seems.
18:27:29 <ivanm> turiya: yes? so?
18:27:41 <ivanm> (+) :: a -> b -> c is more general
18:27:43 <ivanm> doesn't mean it makes sense
18:27:45 <turiya> ivanm: it IS a correct type for head
18:27:52 <ivanm> turiya: prove it
18:28:04 <ivanm> turiya: that means that if I have [Int], I can expect to get any other type I want out of it
18:28:08 <turiya> ivanm: put any type in b
18:28:16 <ivanm> I should be able to go read $ head [1,2]
18:28:25 <ivanm> turiya: since the a type isn't constrained
18:28:55 <turiya> ivanm: no
18:28:57 <ivanm> yes
18:29:10 <ivanm> turiya: that's what [b] -> a means
18:29:23 <ivanm> I would prove it with @djinn, but it doesn't understand lists
18:29:51 <turiya> ivanm: [b]->a only says that the type of the function can be represented by using some values in the places b and a
18:30:22 <turiya> ivanm: for head this means that i can put Int in b and Int in a
18:30:29 <ivanm> turiya: no
18:30:50 <ivanm> turiya: [a] -> a means that given a list containing elements of type a, I will get a value of type a back
18:30:55 <Gibbon> Are you tired of niggers?
18:31:00 <Gibbon> Sick of their monkeyshines?
18:31:03 <ivanm> @where ops
18:31:03 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver monochrom
18:31:07 --- mode: ChanServ set +o monochrom
18:31:07 <turiya> ivanm: actually, i am just trying to adapt my knowledge to what i am reading the gentle introduction
18:31:09 <Gibbon> This is Billy Mayes here with an amazing new website!
18:31:12 --- mode: monochrom set +b *!*@201.171.123.85
18:31:12 --- kick: Gibbon was kicked by monochrom (monochrom)
18:31:16 --- mode: ChanServ set +o Saizan
18:31:17 <ivanm> turiya: [b] -> a says that given a list containing elements of type b, then I will get a value of type a back
18:31:19 --- mode: ChanServ set +o dcoutts_
18:31:37 <turiya> ivanm: but type b can be equal to type a
18:31:47 <ivanm> turiya: no, it _has_ to be
18:31:50 --- mode: Saizan set -o Saizan
18:31:52 --- mode: ChanServ set -o dcoutts_
18:31:55 <ivanm> @type (a:_) -> a
18:31:56 <lambdabot> parse error on input `->'
18:32:01 <ivanm> @type \ (a:_) -> a
18:32:02 <lambdabot> forall t. [t] -> t
18:32:19 <ivanm> turiya: if you make the return type different, then it says the caller can set it to be whatever it likes
18:32:20 <turiya> ivanm: can you see this in the gentle introduction in page 5?
18:32:27 <ivanm> I have never read the gentle introduction
18:32:32 <ivanm> @where gentle
18:32:32 <lambdabot> http://www.haskell.org/tutorial/
18:33:30 <ivanm> turiya: can't see anything at all involving "head" in chapter 5
18:33:36 <monochrom> I think the word "correct" there has a very lax meaning.
18:33:40 <turiya> ivanm: page 5
18:33:52 <ivanm> I'm reading an online version...
18:33:56 <ivanm> which chapter/section?
18:34:02 <monochrom> paragraph before 2.2
18:34:06 <turiya> ivanm: section 2.1
18:34:12 <turiya> ivanm: at the end
18:35:19 <monochrom> I could sympathize with it as: "oh you have a function from list to something, so it could be [b]->a", "oh you have something, so it could be a".
18:35:42 <turiya> @moncochrom: that is what i thought it was
18:35:42 <lambdabot> Unknown command, try @list
18:35:45 <ivanm> right
18:36:01 <monochrom> I can't explain a->a
18:36:06 <ivanm> turiya: the problem with [b] -> a is that the calling function can then assume it returns results of any type
18:36:15 <monochrom> I can explain b->a. "oh you have a function, it could be b->a"
18:36:17 <ivanm> monochrom: neither can I; if it was b -> a it might make sense
18:36:21 <ivanm> right
18:37:12 <monochrom> Here is a more precise statement. If you have another function that wants its parameter to be [b]->a, you can pass head to it and there will be no complaint.
18:37:22 <ivanm> monochrom: agreed
18:37:32 <ivanm> it can be _used_ where a generalised context is expected
18:37:39 <ivanm> but you can't use head in a generalised fashion
18:38:27 <turiya> @monchrom: what about a->a and a?
18:38:28 <lambdabot> Unknown command, try @list
18:39:26 <ivanm> turiya: no way you can use it for a -> a
18:39:34 <ivanm> for just 'a', you can because it's just a value
18:39:34 <monochrom> Change it to b->a.
18:39:43 <turiya> ivanm: is it a mistake then?
18:39:56 <ksf> the only a -> a function I know of is id
18:39:57 <monochrom> id :: a->a.  You can pass head to id.  id head.
18:40:04 <ivanm> turiya: yes, I think so
18:40:11 <ksf> or stuff like seq, which is semantically equal.
18:40:27 <turiya> @monochrom a->a need not be only id
18:40:27 <lambdabot> Unknown command, try @list
18:40:37 <ksf> a -> b is just more general than a -> a. the former subsumates the latter.
18:40:37 <ivanm> turiya: please stop starting with @ ;-)
18:40:51 <ivanm> turiya: what other functions can be a -> a ?
18:40:55 <ivanm> (where a is not constrained)
18:41:10 <turiya> ivanm: power 2
18:41:14 <Veinor> ivanm: const (error str)
18:41:16 <Veinor> :D
18:41:20 <Veinor> for str an arbitrary string
18:41:21 <chrisf|work> if you don't constrain `a` at all, then not many.
18:41:22 <ksf> that's Num a => a -> a
18:41:24 <turiya> ivanm: i mean power n = 2 n
18:41:26 <monochrom> Interesting phenomenon.
18:41:30 --- mode: monochrom set -o monochrom
18:41:33 <merehap> turiya: power only works on numbers, not 'a'
18:41:34 <ksf> :t (*2)
18:41:35 <lambdabot> forall a. (Num a) => a -> a
18:41:42 <ivanm> Veinor: it's constrained
18:41:43 <monochrom> Now he will not say @monochrom :)
18:41:44 <Veinor> turiya: okay, what's a filehandle double?
18:41:48 <Veinor> ivanm: oh wait, yeah
18:41:49 <Veinor> const undefined
18:41:49 <ivanm> chrisf|work: there's only id
18:41:53 <uorygl> You know, I suddenly wonder if polymorphic functions can be easily expressed in set theory.
18:42:03 <ivanm> Veinor: oh, yeah
18:42:07 <turiya> Veinor: no idea
18:42:10 <Veinor> also, plain old undefined
18:42:13 <ksf> :t seq
18:42:14 <lambdabot> forall a t. a -> t -> t
18:42:15 <chrisf|work> ivanm: that's what i thought.
18:42:16 <ksf> :t par
18:42:17 <lambdabot> forall a b. a -> b -> b
18:42:21 <ksf> those count, too.
18:42:30 <Veinor> turiya: exactly, you can't express double as a Handle -> Handle
18:42:30 <ivanm> chrisf|work: well, and hacks like const undefined...
18:42:34 <ivanm> but we usually discount those
18:42:37 <ivanm> @djinn a -> a
18:42:37 <lambdabot> f a = a
18:42:52 <uorygl> Naturally, the plain old set-theoretic definition of a function as a set of ordered pairs won't cut it; the fact that id's domain contains id means you can't do that in ordinary set theory.
18:43:05 <dolio> @google Polymorphism is not Set Theoretic
18:43:07 <lambdabot> http://www.springerlink.com/index/yn417gu033x85677.pdf
18:43:07 <lambdabot> Title: SpringerLink Home - Main
18:43:18 <ksf> in type theory, there's an id for every type.
18:43:27 <ksf> polymorphism is mere semantic sugar.
18:44:30 <uorygl> Yeah, perhaps you could remove polymorphism and just use separate ids.
18:44:33 <monochrom> Of course, the collection of all these id's will not be a set, either.
18:44:56 <ksf> uorygl, that's exactly the thing category theory does.
18:45:21 <uorygl> I think there's nothing preventing it from being a set, as long as not every conceivable set has a type.
18:45:35 <ksf> in fact, you can do without objects in your definition of a category, the identities are enough.
18:45:36 <uorygl> ksf: oh, huh. I should learn category theory, then.
18:46:24 <ksf> or, put differently, the objects are generated by a circular argument invoked by pulling identity functions out of your hat.
18:47:31 <monochrom> I guess the collection of type expressions is a set.
18:47:36 <ksf> uorygl, CT texts are kinda tedious, there's not much that caters to computer scientists.
18:47:43 <ksf> type theory might be a better idea.
18:47:51 <uorygl> I'm also a math major.
18:48:01 <ksf> well, then go for it.
18:48:06 <uorygl> Ignore the fact that I'm an undergrad! :P
18:48:44 <uorygl> Hmm, I might be able to go get a category theory text right now. Any recommendations?
18:48:47 <ksf> soon enough, you won't be able to tell your donut from your coffee cup, not just topologically, but algebraicly.
18:48:50 <turiya> what is the best book to study haskell?
18:48:50 <Veinor> ugh
18:49:00 <Veinor> why does this library require me to pack stuff into ByteStrings
18:49:04 <Veinor> it should do it for me >:(
18:49:23 <chrisf|work> .. fix it?
18:49:38 <ksf> turiya,
18:49:38 <monochrom> you won't tell your coffee cup from your cofree cup
18:49:40 <ksf> @where rwh
18:49:41 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
18:49:41 <Veinor> yes, but that would break compatibility!
18:49:44 <Saizan> uorygl: awodey is the most popular, it seems
18:49:48 <Veinor> monochrom I am going to punch you
18:49:54 <monochrom> haha
18:50:01 <ivanm> Veinor: which library?
18:50:06 <Veinor> hszephyr
18:50:34 <Veinor> in order to do anything useful you have to import Data.ByteSTring.Char8 and B.pack everything
18:50:52 <ksf> overloaded string literals?
18:50:57 <uorygl> Huh. They don't have a paper copy, but I can read it online.
18:51:00 <ivanm> that's crazy!
18:51:05 <Veinor> well, it uses the FFI
18:51:44 <ksf> it'd be really cool to be able if modules had a functor instance
18:52:36 <ksf> ...give a bijection from your type to theirs, and get rid of all the plumbing.
18:53:00 <ksf> and as that sounds like a feature that could be useful for records, just make modules records.
18:53:35 <Alpounet> ksf, it'd be very nice indeed
18:53:43 <Alpounet> I encoutered situations similar to Veinor's
18:53:53 <Alpounet> it can be "solved" with typeclasses
18:54:03 <Alpounet> I'm preparing the same for my neural net library
18:54:14 <ksf> oh, and make the type system smart enough to express a HList without necessarily invoking oleg
18:54:45 <Alpounet> I have everything into UArr's but I'm likely to have a typeclass taking care of all the conversions
18:54:47 <Alpounet> haha :-)
18:54:50 <ksf> OOHaskell integrated with the module system would rock the whole OOP world.
18:55:15 <hatds> what would OOHaskell be?
18:55:22 <monochrom> and the whole haskell world too
18:55:29 <ksf> http://homepages.cwi.nl/~ralf/OOHaskell/
18:55:50 <monochrom> perhaps call it OOMHaskell
18:56:10 <chrisf|work> ksf: [rock the OO world...] for the three seconds it took them to not understand it and go back to failing horribly in java, maybe.
18:56:12 * BMeph contemplates using "The Wicked Haskell Object-Oriented Programming System...WHOOPS!"
18:56:26 <monochrom> hahaha
18:56:37 <Ke> monochrom: out of memory?
18:56:45 <monochrom> heh
18:57:00 * ksf wonders whether HList could actually be implemented by mere mortals, now that we have type families
18:57:12 <chrisf|work> really, ralf... did you need a stupid popup ad?
18:57:25 <chrisf|work> [that link]
18:57:28 <kmc> typeclass programming is not much harder than type families, imo
18:57:36 <ksf> type families make undecidableinstances much less evil
18:58:13 <ksf> ...fundeps confuse the hell out of me, if they're used for stuff better expressed as type families.
18:58:39 <kmc> they're definitely suboptimal for that purpose
18:58:55 * ksf didn't notice, adblock.
18:59:46 <Saizan> i don't think you can do HList without OverlappinInstances
19:00:03 <Saizan> (which doesn't apply to type families)
19:01:03 <kmc> does UndecidableInstances apply?
19:01:09 <ksf> yep
19:01:21 <ksf> disables the termination criterion
19:01:29 <ksf> ...so you can write a multiply
19:01:42 <ksf> the totality checker is basically non-existant.
19:02:20 <ksf> spj just outlawed any nested calls on the rhs.
19:03:07 <hatds> ?
19:03:39 <ivanm> ksf: nested calls of what?
19:03:57 <ksf> http://www.cse.unsw.edu.au/~chak/papers/SPCS08.html
19:04:02 <ksf> that's the paper iirc
19:04:05 <ksf> type families.
19:04:07 <ksf> just a sec.
19:04:32 <ksf> type instance Add Zero m = m
19:04:32 <ksf> type instance Add (Succ n) m = Succ (Add n m)
19:04:36 <ksf> ...works out of the box
19:04:44 <ksf> type instance Mul n Zero = Zero
19:04:44 <ksf> type instance Mul n (Succ m) = n `Add` (n `Mul` m)
19:04:50 <ksf> needs undecidable instances
19:26:14 <jmillikin> Hackage currently can't build one of my libraries, due to a version mismatch between "binary" and "bytestring". Is there any way to make it generate the Haddock docs anyway, even without a successful build?
19:27:27 <ido> what's the difference between . and $?
19:27:30 <kmc> @src (.)
19:27:30 <lambdabot> (f . g) x = f (g x)
19:27:31 <kmc> @src ($)
19:27:31 <lambdabot> f $ x = f x
19:27:56 <ido> danke
19:27:59 <kmc> :D
19:28:04 <ido> 8===========D
19:28:09 <kmc> thanks for that
19:28:21 * ido tries to help with the co{q,ck} whenever possible
19:29:14 <ido> @src (8=D)
19:29:14 <lambdabot> Source not found. Just try something else.
19:29:31 <aavogt> not a valid identifier here
19:29:42 <aavogt> >=> is close though
19:32:01 <danblick> hmm, ok, newbie question.  i'm not sure i've ever done this before.  if I want to split a [FilePath] into directories/nondirectories, I can use a function "doesDirectoryExist" (FilePath -> IO Bool).  I'd like to use Data.List.partition ((a -> Bool) -> [a] -> ([a],[a])).  But how do I handle IO here?
19:32:38 <dibblego> @type partitionM
19:32:40 <lambdabot> Not in scope: `partitionM'
19:33:32 <blackh> danblick: Basically in Haskell, you don't. You'll need a monadic version of the function...
19:33:59 <blackh> I don't think partitionM exists, but it would be easy to write.
19:34:31 <blackh> You could write it as a generally monadic function so it's not restricted to IO
19:35:12 <blackh> Actually filterM is nearly what you want
19:36:00 <blackh> You could either peek at the source for filterM to see how that's implemented, or write it in terms of foldM
19:36:03 <danblick> thanks, I will look at how filterM works.
19:37:04 <danblick> ah, foldM looks nicer.
19:37:48 <uorygl> Is ^_^ a valid operator?
19:37:49 <blackh> Note that you can't do it lazily - the most straightforward approach is to construct the list backwards using :, then reverse it at the end
19:39:05 <c_wraith> uorygl: No, _ and ^ can't be used in the same name
19:39:06 <aavogt> > let (^=^) = (+) in 5 ^=^ 9
19:39:07 <lambdabot>   14
19:39:27 <oli28> hello ccan i get a bit of help with some html
19:39:38 <danblick> haha. try googling "ascii art"
19:39:46 <c_wraith> > let (^.^) = const . const $ "hi" in 1 ^.^ 10
19:39:47 <lambdabot>   "hi"
19:39:54 <blackh> oli28: This is not an HTML channel
19:39:55 <uorygl> c_wraith: can ^ and _ be used in separate names?
19:39:56 <danblick> (they have an ascii-fied google logo)
19:40:16 <oli28> thought it was what is it?
19:40:24 <c_wraith> uorygl: _ can't be used as an identifier by itself, but it can be used as part of an alphanumeric identifier
19:40:31 <jmillikin> let (・∀・) = id in (・∀・) "!!!"
19:40:39 <blackh> oli28: No - this channel is for the Haskell programming language
19:40:45 <joe1> can anyone recommend how to get out of this error: "Prelude.(!!): index too large"
19:40:58 <c_wraith> joe1: it means you used an index larger than your list
19:41:05 <oli28> oh got u do u know a good html or web programming chat room and how do i get there please
19:41:06 <jmillikin> joel: Use an index within the bounds of the list, or a safer version of (!!)
19:41:11 <blackh> joe1: Compile your code with -auto-all -prof, then run it with +RTS -xc and it'll tell you where the error is
19:41:17 <jmillikin> oli28: There are no good HTML or web programming chat rooms
19:41:21 <uorygl> > repeat () !! 1000000000000000
19:41:26 <lambdabot>   mueval: ExitFailure 1
19:41:27 <jmillikin> Consider asking on http://stackoverflow.com/
19:41:34 <joe1> c_wraith: oh, ok. I thought there was a limit on (!!).
19:41:36 <oli28> ok ill settle for one with lots of people
19:41:52 <oli28> thanks jmillikin
19:45:47 <roconnor> > repeat () !! (maxbound + 1)
19:45:48 <lambdabot>   Not in scope: `maxbound'
19:45:52 <roconnor> > repeat () !! (maxBound + 1)
19:45:52 <lambdabot>   * Exception: Prelude.(!!): negative index
19:46:00 <roconnor> > repeat () !! (maxBound*2 + 1)
19:46:01 <lambdabot>   * Exception: Prelude.(!!): negative index
19:46:37 <roconnor> > repeat () !! (maxBound*2 + 2)
19:46:37 <lambdabot>   ()
19:49:46 <Veinor> > [1..] !! (maxBound * 2 + 2)
19:49:47 <lambdabot>   1
19:49:51 <Veinor> :O
19:49:57 <Veinor> so maxBound = -1/2, I see
19:50:09 <Veinor> er
19:50:13 <Veinor> -1
19:50:18 <Veinor> > [1..] !! (maxBound)
19:50:22 <lambdabot>   mueval-core: Time limit exceeded
19:52:35 <aavogt> > succ $ fromIntegral (maxBound::Int)
19:52:36 <lambdabot>   9223372036854775808
19:53:37 <Veinor> that sure is a big number!
19:53:39 <Veinor> > :t log
19:53:40 <lambdabot>   <no location info>: parse error on input `:'
19:53:47 <Veinor> > log Comment 37 by SubmitToEsperanto, Today (7 hours ago)
19:53:48 <lambdabot>   <no location info>: parse error on input `,'
19:53:49 <Veinor> ...
19:53:52 <Veinor> stupid copy-paste!
19:54:19 <Veinor> so it's 2^63-1
19:54:49 <Veinor> or 2^31-1 on my machine
19:55:48 <tensorpudding> > pred 0
19:55:49 <lambdabot>   -1
19:55:58 <tensorpudding> unnatural!
19:56:05 <Veinor> I see what you did there.
19:56:14 <ido> @src (<+>)
19:56:15 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
19:56:43 <ido> @src (=>>)
19:56:44 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
19:56:44 <tensorpudding> > maxBound :: Integer
19:56:45 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Integer.Internals.Integer)
19:56:46 <lambdabot>    arising...
19:57:14 <tensorpudding> > maxBound :: Bool
19:57:15 <lambdabot>   True
19:57:24 <tensorpudding> > False < True
19:57:26 <lambdabot>   True
19:57:30 <tensorpudding> huh
19:57:41 <hatds> how poetic
19:57:50 <tensorpudding> not sure why Bool is an instance of Ord
19:58:21 <edwardk> tensorpudding: the boolean lattice
20:01:48 <tensorpudding> @djinn (a -> b) -> a -> b
20:01:48 <lambdabot> f a = a
20:03:19 <jmillikin> @djinn (a -> b) -> (c -> d) -> Either a c -> Either b d
20:03:20 <lambdabot> f a b c =
20:03:20 <lambdabot>     case c of
20:03:20 <lambdabot>     Left d -> Left (a d)
20:03:20 <lambdabot>     Right e -> Right (b e)
20:03:34 <Veinor> @djinn a -> (a -> b) -> b
20:03:35 <lambdabot> f a b = b a
20:03:37 <jmillikin> that never ceases to impress the hell out of me...
20:03:46 <tensorpudding> @djinn (a -> b) -> (b -> a)
20:03:46 <lambdabot> -- f cannot be realized.
20:04:11 <tensorpudding> @djinn (a -> b, b) -> (b -> a)
20:04:11 <lambdabot> -- f cannot be realized.
20:04:16 <jmillikin> @djinn (a -> b -> c) -> b -> a -> c
20:04:17 <lambdabot> f a b c = a c b
20:04:32 <Veinor> @djinn (a -> b) -> (b -> c) -> (a -> c)
20:04:32 <lambdabot> f a b c = b (a c)
20:04:47 <Veinor> @djinn (b -> c) -> (a -> b) -> (a -> c)
20:04:47 <lambdabot> f a b c = a (b c)
20:04:50 <Veinor> :D
20:05:29 <jmillikin> @djinn (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
20:05:29 <lambdabot> f a b c d = a (b c d)
20:05:44 <tensorpudding> @djinn (a -> b, b -> a) -> (Either a b) -> (a, b)
20:05:45 <lambdabot> f (a, b) c =
20:05:45 <lambdabot>     case c of
20:05:45 <lambdabot>     Left d -> (b (a d), a d)
20:05:45 <lambdabot>     Right e -> (b e, a (b e))
20:05:47 <jmillikin> It doesn't use prelude functions?
20:06:28 <edwardk> jmillikin: i believe it only know about what you @djinn-add
20:06:32 <edwardk> @djinn-env
20:06:33 <lambdabot> data () = ()
20:06:33 <lambdabot> data Either a b = Left a | Right b
20:06:33 <lambdabot> data Maybe a = Nothing | Just a
20:06:33 <lambdabot> data Bool = False | True
20:06:33 <lambdabot> data Void
20:06:35 <lambdabot> type Not x = x -> Void
20:06:37 <lambdabot> class Monad m where return :: a -> m a; (>>=) :: m a -> (a -> m b) -> m b
20:06:39 <lambdabot> class Eq a where (==) :: a -> a -> Bool
20:07:47 <jmillikin> @djinn-add (.) f g x = f (g x)
20:07:48 <lambdabot> Cannot parse command
20:07:48 <tensorpudding> @djinn Either a c -> (Not c) -> a
20:07:49 <lambdabot> f a b =
20:07:49 <lambdabot>     case a of
20:07:49 <lambdabot>     Left c -> c
20:07:49 <lambdabot>     Right d -> void (b d)
20:08:38 <jmillikin> @djinn-add (f . g) x = f (g x)
20:08:38 <lambdabot> Cannot parse command
20:08:53 <copumpkin> I thought it only took types
20:09:25 <tensorpudding> @djinn Either (a,b) (a,c) -> (Not b) -> c
20:09:25 <lambdabot> f a b =
20:09:26 <lambdabot>     case a of
20:09:26 <lambdabot>     Left (_, c) -> void (b c)
20:09:26 <lambdabot>     Right (_, d) -> d
20:09:30 <xle> hey all... had a general question: for what kinds of operations do bytestrings really shine over strings? is there a few rules of thumb for this?
20:09:31 <jmillikin> ahhh, it's ruining my hopes of auto-generating all my libraries
20:09:41 <jmillikin> xle: they're much better for storing bytes
20:09:52 <xle> jmillikin: so binary data?
20:09:56 <jmillikin> Right
20:10:34 <xle> jmillikin: i see.. I just saw that hxt documentation for readDocument says you don't gain much from using strict bytestrings in hxt over hGetContents with strings
20:11:08 <jmillikin> That'll depend on the design of the library.
20:11:44 <jmillikin> If you're reading from a file or network, your input will be a bytestring anyway, so you'll save the time and space of decoding it.
20:11:58 <tensorpudding> @djinn a -> b -> (a,b)
20:11:58 <lambdabot> f a b = (a, b)
20:13:12 <scriptdevil> For a new project, are haskell records still OK or is there something new?
20:13:21 <xle> jmillikin: so ghc uses bytestrings in the background even if you use strings?
20:13:48 <kmc> scriptdevil, see hackage packages: fclabels data-accessor lenses
20:13:54 <kmc> they make records much nicer to work with
20:14:25 <scriptdevil> kmc: Thanks :D
20:14:28 <jmillikin> xle: I don't know the implementation details of GHC's hGetContents. Bytestrings are essentially C buffers, so while GHC doesn't use them, it probably uses something very similar
20:15:06 <jmillikin> Let me put it this way: using bytestrings will not be *slower*, and it's much more sensible to read a file as bytes than as characters.
20:15:24 <kmc> jmillikin, not a text file
20:15:32 <kmc> but i guess that was resolved above
20:16:33 <kmc> doesn't each bytestring library provide something like getContents?
20:17:39 <jmillikin> kmc: There's no such thing as a "text file". It might be text in some encoding, but it's still bytes when read.
20:17:40 <jmillikin> Yes, ByteString has an hGetContents
20:18:34 <jmillikin> I'm pretty sure it uses hGetBuf, which just reads into a Ptr ()
20:19:08 <sshc> if I license a cabal package with something such as AllRightsReserved, can I later release it under something such as BSD?
20:19:20 <ivanm> yes
20:19:25 <jmillikin> Yes, you always have the right to license your own code under whatever license you want.
20:19:27 <ivanm> just change the cabal file and re-upload
20:19:41 <ivanm> sshc: the code is yours, _you_ can do whatever you want to do with it
20:19:52 <ivanm> actually, AllRightsReserved packages can't go on hackage IIRC...
20:19:59 <ivanm> sshc: the license is what _other_ people can do
20:20:00 <mreh> this isn't Russia
20:20:01 <dcoutts_> though as a matter of policy hackage does not host packages with AllRightsReserved "license"
20:20:10 <mreh> this isn't Russia is it?
20:20:16 <tensorpudding> it isn't?
20:20:17 <ivanm> it gets trickier when you get code from other people in there....
20:20:23 <sshc> mreh: this isn't, but that is
20:20:24 <ivanm> mreh: what made you think it was?
20:20:43 <mreh> ivanm: it's from Caddyshack :D
20:20:49 <ivanm> from what?
20:20:53 <sshc> so for any code I write, if I release it under the GPL say, could I later close-source it if I wanted or release it under the BSD?
20:21:00 <sshc> regardless of cabal
20:21:01 <mreh> Caddyshack (1980)
20:21:02 <ivanm> sshc: yes
20:21:05 <jmillikin> sshc: yes
20:21:09 <ivanm> but you can't un-release the GPL versions
20:21:16 <ivanm> (whatever tuomov believes)
20:21:16 <dcoutts_> sshc: if you're the copyright holder you can use as many licenses as you like
20:21:18 <jmillikin> You can't un-release any version
20:21:33 <ivanm> you can't do anything retroactively
20:21:54 <ivanm> but as long as all the code is yours you can do whatever you want with it
20:21:54 <dcoutts_> ivanm: except on proprietary licenses that say you can :-)
20:22:00 <ivanm> dcoutts_: heh, true
20:22:04 <bos> uh oh, commit fight with tibbe
20:22:11 <ivanm> sshc: if you use a GPL library, then it gets a little trickier
20:22:13 <ivanm> bos: heh
20:22:18 <ivanm> fight! fight!
20:22:23 <sshc> ivanm: how so?
20:22:30 <tensorpudding> there is an LGPL for libraries
20:22:39 <bos> tibbe converted a bunch of code that used "return $!" to use "return $"
20:22:50 <ivanm> heh
20:22:52 <sshc> ivanm: if I linked with, for example, a C library in C code it'd be trickier?
20:22:58 <bos> i think he misunderstands when evaluation occurs.
20:23:37 <jmillikin> sshc: I can't think of any reason why it would be
20:23:55 <mreh> @google caddyshack 1980
20:23:56 <lambdabot> http://www.imdb.com/title/tt0080487/
20:23:56 <lambdabot> Title: Caddyshack (1980)
20:24:34 <tensorpudding> GPL has strong restrictions on linking to libraries
20:25:31 <ivanm> sshc: the only problem is if you link to a C library that is GPL'd and your library isn't
20:25:48 <tensorpudding> LGPL allows your proprietary software to link to the library and be distributed however they like
20:26:02 <jmillikin> That's not a problem either
20:26:05 <tensorpudding> unless it is deemed a derivative work, apparently
20:26:42 <jmillikin> A BSD library can link to a GPL library without any problems. Unless it's the old four-clause BSD, but nobody sane uses that any more.
20:27:26 <sshc> ivanm: then?...
20:27:42 <ivanm> sshc: then you might have to make sure your code is GPL
20:28:00 <tensorpudding> the solution is to use the BSD license
20:28:02 <jmillikin> No, you don't.
20:28:11 <ivanm> jmillikin: depends on how you link to it
20:28:15 <jmillikin> If your library is BSD, you can use a GPL'd library from it without any problems.
20:28:25 <jmillikin> The only person who has to care is the application author.
20:28:46 <ivanm> jmillikin: I was under the impression he was talking about an application ;-)
20:28:51 <xle> is hdbc the dominant library for db interaction at the moment?
20:29:02 <dcoutts_> xle: yes
20:29:18 <xle> dcoutts_: ok... i'm having lots of trouble getting hdbc-odbc to work under os x...
20:29:23 <jmillikin> Ah, I thought ht meant he wanted use a GPL'd C library into his library
20:29:34 <xle> hdbc-sqlite3 works fine, but mysql support would be great
20:29:46 <ivanm> how does HaskellDB compare to HDBC?
20:30:00 <dcoutts_> ivanm: they're different layers
20:30:01 <ivanm> xle: RWH has a chapter on getting it all working together IIRC
20:30:09 <dcoutts_> I thought someone had written an hdbc-mysql package
20:30:10 <ivanm> dcoutts_: *nod* as in how low/high level they are?
20:30:35 <xle> also, what is the best way to deal with saving, retrieving from a structure perspective? I've so far been writing ADTs for each of the tables.. it's a big hassle to update all the write/read functions after a change in schema
20:30:46 <xle> ivanm: yeah i read that chapter... didn't help with mysql config under os x :)
20:30:47 <dcoutts_> ivanm: hdbc is low level, sending SQL strings, haskelldb is high level, generating SQL strings from typed DSL
20:30:50 <ivanm> sshc: short answer: as long as you follow any licensing requirements of any libraries you use, you can do whatever you want with your code
20:30:54 <ivanm> xle: heh, fair enough
20:31:00 <ivanm> dcoutts_: *nod*
20:31:14 <ivanm> dcoutts_: so haskelldb is potentially safer?
20:31:24 <dcoutts_> ivanm: it's also unmaintained afaik
20:31:27 <xle> is haskelldb actively developed? last version was in feb 09
20:31:31 <ivanm> dcoutts_: :(
20:31:39 <ivanm> xle: dcoutts_ just said it wasn't
20:31:49 <xle> ivanm: yeah saw that after i finished typing
20:31:50 <dcoutts_> oh, feb '09, that's more recent than I thought
20:31:59 <dcoutts_> perhaps it is maintained then
20:32:00 <ivanm> yeah, I don't recognise any of the authors
20:32:18 <xle> too bad... db interaction is a key aspect of a general-purpose language in my opinion..
20:32:27 <ivanm> and their "home page" on sourceforge is rather out of date as well...
20:32:46 <dcoutts_> xle: in practise I think most people use the hdbc layer, that's well maintained
20:33:16 <ivanm> well, the last patch they have on d.h.o is from 2008 ...
20:33:20 <xle> dcoutts_: ok, good to know. also, I love Mr. Goerzen's libraries - always so well documented
20:33:33 <dcoutts_> xle: and it's the equivalent to the db interaction libs in other languages, haskelldb is much higher level than what you find elsewhere
20:33:34 <gwern> indeed
20:33:50 * ivanm had some problems with one of CosmicRay's libraries recently, but can't recall what or why...
20:33:56 <Saizan> ORM layers are much higher lever than HDBC though
20:34:13 <ivanm> I think it was because of him being too strict about when the testsuite needed to be enabled...
20:34:23 <Saizan> comparable to haskelldb, even if less typed
20:34:24 <gwern> haskellers aren't always so great on docs. I wince whenever I see that I want to use sigbjorn's libraries - they work great once you unravel their riddle, within an enigma, within a crumpt...
20:34:47 <xle> Saizan: yeah I'm used to ORM from rails.. i don't like all the weak typing dangers there in general, but AR has lots of time-saving features
20:34:49 <dcoutts_> xle: so if you think hdbc-odbc is not working on osx then I suggest emailing the package author, and/or asking for help on the haskell-cafe mailing list
20:35:25 <xle> gwern: documentation is very very important in my opinion.. makes a huge difference in adoption
20:35:48 <ivanm> gwern: which libraries does he maintain?
20:35:53 <xle> dcoutts_: good idea, I'll do that
20:36:12 <dcoutts_> xle: and have you tried HDBC-mysql?
20:36:13 <gwern> ivanm: i've run into a couple of his. I'm thinking particularly of his wikimedia package
20:36:51 <xle> dcoutts_: that doesn't compile as is.. let me pull the tar and see if I can tweak the includes to get it to compile
20:36:59 <ivanm> gwern: so then, as a documentation connoisuer (however you spell it), how do you rate my humble efforts? ;-)
20:37:14 <gwern> ivanm: what of your stuff have I used?
20:42:07 <ivanm> have you used graphviz?
20:45:03 <jmillikin> What's the preferred suffix for indicating partial functions, ' or _   ?
20:45:36 <xerox>  -> Maybe a  ?
20:45:37 <kmc> hmm, i haven't seen either
20:45:40 <kmc> unsafeFoo
20:45:46 <kmc> although there are different levels of that
20:46:08 <jmillikin> Yeah, it's not really "unsafe", just intended to take off a layer of error handling for constants.
20:46:22 <ivanm> jmillikin: if it's internal only, who cares
20:46:34 <jmillikin> It's not internal
20:46:36 <ivanm> otherwise: use Maybe, specify in the documentation, etc.
20:46:59 <jmillikin> There's two versions of the smart constructors currently, mkFoo :: String -> Maybe Foo and mkFoo' :: String -> Foo
20:47:17 <ivanm> works for me
20:47:28 <arr2> mr magina
20:47:40 <jmillikin> And I'm just noticing that ' is often used for strictness, and _ for partiality, and wonder if I got it wrong initially.
20:47:41 <ivanm> jmillikin: maybe just put something in your documentation indicating your policy wrt primed functions
20:48:04 <jmillikin> It's not a stable API yet, so I can break it any way I want ;)
20:48:11 <ivanm> I used ' to indicate partially inferred versions of functions without knowing that ' implies strictness... >_>
20:48:13 <ivanm> jmillikin: heh
20:48:19 <ivanm> down with stability!
20:48:32 <jmillikin> Better to get the warts fixed before it does go stable, than to have a bunch of "warning: I fucked up" in the documentation.
20:50:48 <xle> how can I add to the search path for dlopen?
20:51:08 <xle> instead of ln -s ing everything to /usr/local/lib, that could be a more sustainable solution :)
20:51:12 <kmc> env var LD_LIBRARY_PATH ?
20:51:21 <ivanm> yeah that's the one IIRC
20:54:19 <kmc> a serious program smell imo
20:54:22 <kmc> but sometimes unavoidable
20:57:00 <xle> hmm.. I don't have a libmygcc.dylib, but I do have a libmygcc.a
20:57:36 <xle> so the hdbc-mysql compiled, but is not working
21:09:31 <ivanm> xle: when you say it doesn't work, do you mean in ghci?
21:09:44 <xle> ivanm: yes, that's where I tried
21:11:24 <xle> this is what I get:
21:11:24 <xle> Loading package HDBC-mysql-0.6 ... can't load .so/.DLL for: mygcc (dlopen(libmygcc.dylib, 9): image not found)
21:20:07 <xle> thanks for the help all... I'm off for now
22:02:12 * hackagebot upload: dbus-core 0.8 - Low-level D-Bus protocol implementation (JohnMillikin)
22:02:14 * hackagebot upload: dbus-client 0.3 - D-Bus client libraries (JohnMillikin)
22:15:22 <Ke> @hoogle f a -> a
22:15:23 <lambdabot> Network.BufferType buf_empty :: BufferOp a -> a
22:15:23 <lambdabot> Data.Monoid getDual :: Dual a -> a
22:15:23 <lambdabot> Foreign unsafePerformIO :: IO a -> a
22:17:02 <Ke> @hoogle (a -> b) -> a -> a
22:17:02 <lambdabot> Data.Generics.Schemes everywhere :: (a -> a) -> a -> a
22:17:03 <lambdabot> Data.Generics.Schemes everywhere' :: (a -> a) -> a -> a
22:17:03 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
22:18:26 <copumpkin> Ke:  what would the latter one do?
22:19:08 <copumpkin> http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Functor-Pointed.html#t%3ACopointed
22:36:03 <Veinor> ugh, I can't get HUnit to build
22:36:17 <Veinor> Test/HUnit/Lang.hs:22:1: lexical error at character 'i'
22:38:14 <ivanm> :o
22:38:17 <ivanm> which version?
22:38:37 <Veinor> 1.2.2.{0,1}
22:38:43 <Veinor> 1.2.0.3 works fine
22:38:44 <ivanm> builds here...
22:38:50 * ivanm tries building again
22:39:06 <Veinor> I just got it from cabal so
22:39:18 <Veinor> also, directory failed
22:39:24 <Veinor> Warning: The 'build-type' is 'Configure' but there is no 'configure' script.
22:39:24 <ivanm> weird :s
22:39:56 <Saizan> Veinor: ghc version?
22:40:07 <Veinor> 6.8.2
22:40:10 <Veinor> is that my problem? :P
22:40:22 <pelotom> isn't there some function that takes a [M a] to a M [a] ?
22:40:31 <ivanm> could be
22:40:42 <ivanm> @hoogle Monad m => [m a] -> m [a]
22:40:42 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
22:40:42 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
22:40:42 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
22:40:48 <Saizan> Veinor: well, sort of, the .cabal file specifies -XCPP only for ghc >= 6.10
22:40:50 <ivanm> pelotom: ^^ sequence is what you want
22:40:56 <Veinor> perhaps I should just upgrade
22:41:09 <pelotom> ivanm: ah, thanks!
22:41:12 <Saizan> though it seems it's needed anyway
22:41:27 <ivanm> yup, still builds here
22:41:35 <ivanm> Veinor: "ghc-pkg check" doesn't reveal any problems?
22:41:41 <ivanm> (just in case it's anything obvious...)
22:41:47 <Veinor> nope
22:42:00 <ivanm> yeah, then maybe it does need -XCPP
22:42:17 <ivanm> you can try downloading it, unpacking it, editing the cabal file and then doing "cabal install" in that directory...
22:42:17 <Saizan> line 22 is an #ifdef ..
22:42:21 <Veinor> so if I have a bunch of stuff installed already via cabal and I install a new version of GHC into ~, will that do horrible things?
22:42:28 <Veinor> ivanm: yeah, but I want 6.12 anyway
22:42:37 <ivanm> Veinor: you'll have to rebuild everything with 6.12
22:42:38 <Saizan> Veinor: no, it'll work fine
22:42:49 <ivanm> Saizan: then yes, it appears that it still needs CPP ;-)
22:42:51 <Veinor> ivanm: I'm fine with that.
22:42:51 <Saizan> but yeah, you'll have to rebuild for 6.12
22:43:01 <Veinor> wait, what exactly do you mean by 'rebuild'? :p
22:43:09 <ivanm> Veinor: rebuild every single library, etc.
22:43:13 <ivanm> and AFAIK there's no automagic way of doing it with cabal-install
22:43:13 <Veinor> also, I'm slightly surprised Haskell only has the one library for IMAP
22:43:20 <Veinor> oh well. I didn't have anything better to do :D
22:43:29 <Saizan> well, that if you need a library for 6.12 that you already have for 6.10 you've to build it
22:43:48 <Saizan> cabal will pick the ghc in $PATH by default
22:44:02 <Saizan> you can override that with -w
22:44:50 <Veinor> hm
22:44:55 <Veinor> should I get 6.12 or 6.10?
22:45:40 <Veinor> cause the download page for 6.12 says 'hey, get 6.10!'
22:46:07 <Saizan> yeah, 6.12 is considered to be only for devs that want to update their libs for the next platform
22:46:17 <Veinor> kay.
22:46:37 <dcoutts> the download page for 6.12 gives wise advise
22:47:19 <Veinor> so I should download from http://haskell.org/ghc/download_ghc_6_10_4.html#binaries , compile and install
22:47:52 <ivanm> Veinor: if you only use haskell, get 6.10.4 with the platform
22:48:00 <Veinor> platform says you need 6.10.4
22:48:07 <ivanm> if you do a lot of coding, maybe get 6.12
22:48:45 <dcoutts> Veinor: the platform page's advice is also wise
22:48:48 <Veinor> ie, you need the binary to get the platform.
22:49:03 <dcoutts> it says get ghc from your distro, if your distro does not supply ghc then get the generic binary
22:49:07 <Veinor> oh boy, I hope this doesn't screw my quota
22:51:43 <Veinor> ./configure --path=/home/veinor/ghc will work fine, right?
22:52:22 <Veinor> for a machine on which I don't have root
23:06:33 <Veinor> checking for GL/glut.h... no
23:06:33 <Veinor> configure: error: The GLUT C library is required
23:06:34 <Veinor> FFFFFFFFFFF
23:06:36 <Veinor> D:
23:08:06 <ski> zygoloid : yes `(exists a. Real a *> a) -> Rational' is isomorphic with `forall a. (Real a *> a) -> Rational'
23:08:11 <ski> zygoloid : but the point what that in `on (==) toRational' the `a1' in `on :: forall a0 a1 b. (a0 -> a0 -> b) -> (a1 -> a0) -> (a1 -> a1 -> c)' would match with `exists a. Real a *> a' (instead of just `a') so that the result type `a1 -> a1 -> c' would be instantiated to `(exists a. Real a *> a) -> (exists a. Real a *> a) -> Bool', becoming `forall a0 a1. (Real a0,Real a1) => a0 -> a1 -> Bool', instead of `forall a. Real a =>
23:08:31 <Veinor> is there any way to tell it 'I don't care about this package'?
23:08:53 <kmc> configure sometimes takes args like --no-whatever
23:08:55 <kmc> try --help
23:09:21 <Veinor> yeah, --without-GLUT fails
23:09:35 <Veinor> ;/
23:10:23 <Saizan> ski: fyi, you got truncated at  `forall a. Real a =>
23:10:33 <ski> (yes, just noticed that)
23:11:02 <ski> zygoloid : ..., instead of `forall a. Real a => a -> a -> Bool'
23:11:21 <Veinor> I'm frustrated now :<
23:14:49 <Veinor> why do I even need GLUT? that seems kinda poor.
23:16:34 <Veinor> I'm vaguely tempted to write my own IMAP library, but... eugh
23:19:09 <Veinor> The following packages are involved in a dependency cycle unix-2.3.0.0, directory-1.0.0.3
23:19:12 <Veinor> aaaa
23:22:28 <Veinor> sup copumpkin/
23:22:32 * Saizan wonders what's going on
23:22:35 <copumpkin> sleeeeeeeepy
23:22:41 <copumpkin> Saizan: what's going on?
23:22:54 <Veinor> I'm bitching about how I can't get haskellnet to install on this machine
23:23:06 <copumpkin> carry on
23:23:37 <Veinor> and I need it for IMAP stuff
23:24:08 <Saizan> btw, you don't need the haskell-platform, you can just use cabal-install
23:24:30 <Veinor> true
23:24:48 <Veinor> how do I get ghci, then?
23:26:13 <luite> hmm? ghci is included with the ghc distribution (or just run ghc --interactive))
23:26:50 <Veinor> ahhh
23:27:10 <Veinor> must be some $PATH fuckery
23:27:23 <phr> y'know one thing I really wish is if ":l filename.hs" in ghci remembered the filename, so ":l" would reload it.  i keep using filenames like "a.hs" just to make loading them easy.
23:27:38 <copumpkin> why not use :r ?
23:27:40 <Veinor> just use :r
23:27:43 <phr> oh!
23:27:43 <phr> tx
23:27:46 <copumpkin> :P
23:27:53 <luite> and it has completion for filenames
23:27:53 <Veinor> I wish there was a standalone IMAP library
23:28:05 <Veinor> I could just pull out the relevant code from haskellnet
23:28:13 <luite> so the first time you load it, type the first few characters and then tab
23:28:37 <Veinor> I also wish haskellnet had examples :/
23:28:59 <phr> hmm, it says "no such module"
23:29:03 <phr> where :l works
23:29:03 <Veinor> perhaps I should just write this in python instead
23:29:13 <Veinor> no, you :l it the first time
23:29:13 <phr> but there's no module command in the .hs file
23:29:15 <Veinor> then :r to reload
23:29:17 <phr> oh i see
23:29:23 <phr> but then what is the :r completion for
23:29:23 <Veinor> so :l module.hs
23:29:23 <phr> ?
23:29:24 <Veinor> then :r
23:29:32 <luite> phr: :l completion :)
23:29:36 <phr> oh
23:29:42 <copumpkin> :load
23:29:43 <copumpkin> :reload
23:29:45 <phr> thanks
23:31:26 <Veinor> it doesn't even have SSL :<
23:33:03 * Veinor throws his hands up in the air
23:57:48 * BMeph throws up air in his hands
23:58:28 <ivanm> wtf?
23:58:36 <redcuber> puking air?
23:59:42 <c_wraith> does anyone know why Control.Monad.State.Classes doesn't appear to declare an "instance (Monad m, Monad (t m), MonadState s m, T.MonadTrans t) => MonadState s (t m) where ..."?
