00:02:11 <wagle> after spending a couple years in dynamic language programming, it is sooooOOOOoo bizarre to have a complex program just work when i get it to compile
00:04:09 <merehap> but, but, unit tests!
00:05:04 <merehap> not saying that they aren't useful, but I find a nice static type system even more so :)
00:06:20 <RichardO> Hi, I remember hearing about another language which borrow features heavily from haskell but has effects and regions built into its type system. Does anyone know what I could be talking about?
00:10:47 <solrize> RichardO, DDC
00:10:47 <RichardO> ah, it's called Disciple
00:10:55 <solrize> http://www.haskell.org/haskellwiki/DDC
00:11:07 <RichardO> yup! Thanks!
00:11:31 <solrize> i just read the dissertation about that last night, it was really interesting
00:11:53 <ivanm> preflex: seen sinelaw
00:11:53 -preflex(n=preflex@95-88-118-220-dynip.superkabel.de)- sinelaw was last seen on #haskell 11 hours, 41 minutes and 1 second ago, saying: pettter, the same kolmogorov from the theorem about FT of a random process' autocorrelation?
00:12:09 <ivanm> @tell sinelaw yeah, I'm working on that...
00:12:10 <lambdabot> Consider it noted.
00:25:08 <Sagi> Hello everyone. I'm thinking about implementing a research tool in Haskell and I'm looking for some packet data-structures. I found Data.IPv6, but it's not really useful. Any other libraries you can advise me?
00:25:58 <Sagi> (I found the network-data package in general and some structures scattered through various others, ie. network, network-fancy etc.)
00:29:16 <Saizan> if you don't find them there are packages like attoparsec, cereal or binary that are quite good to [de]serialize using binary formats
00:35:34 <Sagi> Saizan: ah thanks
00:35:43 <Sagi> I think I'll just contribute some patches
00:35:56 <Sagi> it's kind of stupid that there are no standard libraries for this
00:42:57 <Saizan> i guess the easy way out has been to use FFI to import the network stack from C :)
00:58:37 <wagle> how do i turn on an -X option from inside a program file?
00:59:02 <Saizan> {-# LANGUAGE Foo #-} at the top
00:59:30 <Saizan> {-# LANGUAGE Foo, Bar #-} for more at once
01:00:29 <wagle> -XTypeSynonymInstances
01:00:37 <wagle> oh
01:01:14 <wagle> HA ha, i knew that was doomed
01:04:52 <Jonno_FTW> how can i get this to work
01:04:58 <Jonno_FTW> detec ys n | t == h = putStrLn "Cycle length: " (h - t)
01:05:38 <temoto> What is t?
01:05:47 <temoto> and what is h?
01:06:10 <Jonno_FTW> int
01:06:18 <temoto> I mean it's not defined.
01:06:38 <temoto> you didn't write it
01:06:38 <Jonno_FTW>            | n == (length ys) = error "no cycle" | otherwise = detec ys (n+1)
01:06:40 <Jonno_FTW>             where
01:06:41 <Jonno_FTW>                 t = ys !! n
01:06:44 <Jonno_FTW>                 h = ys !! (n*2)
01:06:45 <Jonno_FTW> there you go
01:06:54 <Raynes> Jonno_FTW: hpaste.org ;)
01:07:06 <Jonno_FTW> i thought the one line would be enough to go on
01:07:24 <Jonno_FTW> because I don't know how to get it to write the string and then the subtraction
01:07:32 <temoto> :t (+) . (*)
01:07:34 <lambdabot> forall a. (Num (a -> a), Num a) => a -> (a -> a) -> a -> a
01:07:40 <wagle> thanks..  i opted for newtypes, though..  bleh
01:08:00 <Veinor> temoto: that doesn't do what you'd expect, I don't think
01:08:04 <Veinor> @unpl (+) . (*)
01:08:04 <lambdabot> (\ c -> (+) ((*) c))
01:08:28 <temoto> > let f = (+).(*) in f 10
01:08:29 <lambdabot>   No instance for (GHC.Num.Num (a -> a))
01:08:29 <lambdabot>    arising from a use of `GHC.Num.+'...
01:08:38 <Jonno_FTW> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16648#a16648
01:08:54 <temoto> > let f = (+).(*) in f $ \x -> 10
01:08:55 <lambdabot>   No instance for (GHC.Num.Num ((t1 -> t) -> t1 -> t))
01:08:55 <lambdabot>    arising from a use ...
01:09:00 <Veinor> temoto: what are you trying to do?
01:09:31 <temoto> Veinor: trying to understand how to compose two functions of two arguments.
01:09:53 <Veinor> I mean, what do you want the function to return, and what inputs do you want?
01:10:22 <Veinor> if you want f a b c = a * b + c, that's ((+) .) . (*)
01:10:32 <temoto> no
01:12:25 <temoto> f a b = (a+b) `hmm...` (a*b)
01:13:09 <temoto> @src (.)
01:13:10 <lambdabot> (f . g) x = f (g x)
01:13:55 <temoto> i guess this is not really expressable
01:14:05 <temoto> because it doesn't make sense :)
01:14:19 <wagle> Saizan: thanks, by the way
01:14:55 <Saizan> wagle: np :)
01:17:33 <temoto> Jonno_FTW: becuase
01:17:36 <temoto> :t print
01:17:37 <lambdabot> forall a. (Show a) => a -> IO ()
01:17:50 <Veinor> temoto: so you want... f a b = (a + b) `g` (a*b)?
01:17:54 <Jonno_FTW> then what do i use?
01:17:59 <temoto> Jonno_FTW: but you're giving 2 args to print.
01:18:19 <temoto> Jonno_FTW: print "Foo: " ++ show 15
01:18:28 <temoto> > print "Foo: " ++ show 15
01:18:29 <lambdabot>   Couldn't match expected type `GHC.IOBase.IO ()'
01:18:29 <lambdabot>         against inferred ty...
01:18:47 <temoto> > "Foo: " ++ show 15
01:18:48 <lambdabot>   "Foo: 15"
01:19:11 <Veinor> @pl \f a b -> (a+b) `f` (a*b)
01:19:11 <lambdabot> (`ap` (*)) . (ap .) . (. (+)) . (.)
01:19:14 <Veinor> oh god D:
01:21:01 <dolio> @pl \f -> uncurry (+) &&& uncurry (*) >>> uncury f
01:21:01 <lambdabot> (uncurry (+) &&& uncurry (*) >>>) . uncury
01:22:01 <Jonno_FTW> well now my function doesn't work properly
01:22:29 <temoto> give me moree
01:22:41 <temoto> more details... hshhhshhhh
01:22:56 <Jonno_FTW> trying to implement this
01:22:58 <Jonno_FTW> http://en.wikipedia.org/wiki/Cycle_detection#Tortoise_and_hare
01:23:00 <Jonno_FTW> but i g2g to work
01:36:19 <Eduard_Munteanu> Hi.
01:40:54 <Eduard_Munteanu> Are there any other optimizations besides deforestation that can be enabled by lazy evaluation?
01:41:27 <quicksilver> is deforestation enabled by lazy evaluation?
01:41:31 <quicksilver> it's a static transform
01:41:40 <quicksilver> surely you could run it independent of evaluation method
01:41:47 <Eduard_Munteanu> quicksilver, oh, right, confusing things. It's purity.
01:41:57 <Eduard_Munteanu> Oh, well, by purity then.
01:43:05 <Eduard_Munteanu> quicksilver, but does laziness has any good sides besides coding style?
01:43:11 <Eduard_Munteanu> *have
01:43:34 * Saizan wonders if map f . map g == map (f . g) holds with eager evaluation
01:43:43 <Eduard_Munteanu> I'm asking because it seems it hurts performance in practice.
01:43:59 <temoto> Eduard_Munteanu: obviously, lazyness is a permanent runtime optimization because you don't need to evaluate stuff you don't need.
01:44:28 <temoto> but the cost at which it comes (thunks, etc) introduces some overhead, yes
01:44:44 <quicksilver> Eduard_Munteanu: well, it turns some linear-space algorithsm into constant-space algorithms
01:44:49 <quicksilver> that's a benefit.
01:45:09 <quicksilver> it's also a benefit in the cases that it entirely eliminates unnecessary work, as temoto suggests.
01:45:36 <quicksilver> SPJ says "it keeps you honest"
01:45:44 <Eduard_Munteanu> Heh.
01:45:53 <quicksilver> meaning that it requires you to be honest about purity
01:46:01 <Eduard_Munteanu> quicksilver, though it seems programmers are actually able to optimize better than the compiler.
01:46:18 <Saizan> yeah, transforming a list into a generator is something you can't really do if you promise eager evaluation, i'd think
01:46:18 <Eduard_Munteanu> Because otherwise we'd see eager languages performing worse in the average case.
01:46:47 <Eduard_Munteanu> or as better at least.
01:47:01 <quicksilver> Eduard_Munteanu: sweeping generalisations like that are almost meaningless
01:47:18 <quicksilver> but it's true that people accustomed to programming in eager languages don't write code that way
01:47:32 <quicksilver> i.e. they don't write code that requires linear space, and they don't write code which does un-necessary work.
01:47:51 <Eduard_Munteanu> quicksilver, it's more like a question. Is laziness worth for performance, or its drawbacks overcome optimizations? Are optimizations trivial from the coder's point of view?
01:47:52 <quicksilver> on the other hand, this makes their job harder
01:48:02 <quicksilver> Eduard_Munteanu: laziness is not worth it for performance.
01:48:12 <quicksilver> is the simple answer.
01:48:15 <Eduard_Munteanu> I see.
01:48:25 <quicksilver> Of all the justifications for laziness, performance is not likely to come in the top 45 ;)
01:49:32 <Eduard_Munteanu> So basically that's the reason Haskell code is generally slower than C?
01:50:04 <Eduard_Munteanu> Because I'd expect things like GC and others to not be a major problem.
01:50:18 <quicksilver> no, it's not.
01:50:24 <Saizan> the reason is that haskell code is generally higher level/more modular, lazyness is one part of this, but so are HOFs
01:50:56 <quicksilver> the reason that haskell code is generally slower than C is that (a) it's harder to write a good haskell compiler than a good C compiler (b) about 1000 times the man hours have been devoted to writing good C compilers
01:51:09 <Eduard_Munteanu> Hm, I see.
01:51:39 <quicksilver> GHC doesn't have a particularly good codegen, for example
01:51:52 <quicksilver> (and that is planned to be rewritten sometime)
01:52:21 <Eduard_Munteanu> quicksilver, that is the stuff that generates the IR? (It was C-- IIRC)
01:52:40 <quicksilver> in fact I am mostly referring to the stuff that generates the machine code
01:52:52 <theorbtwo> In no small part, that's because C was written to be a mildly easier way of writing machine code -- for every construct in C, there's a pretty obvious way to translate it.
01:52:54 <quicksilver> although obviously to get really good results all the layers need to work well and work well together.
01:52:56 <Eduard_Munteanu> quicksilver, um, doesn't it use GCC for that?
01:53:00 <quicksilver> Eduard_Munteanu: no.
01:53:28 <Eduard_Munteanu> theorbtwo, yeah.
01:53:36 <quicksilver> theorbtwo: but not just that; C compilers do all kinds of stuff like loop unrolling and compensation for branch prediction to optimise for modern CPUs
01:53:47 <quicksilver> theorbtwo: GHC doesn't do either of those.
01:54:01 <Eduard_Munteanu> quicksilver, okay, so it has an instruction selector. Does it have a code emitter? Because I remember it uses GCC for at least something.
01:54:10 <quicksilver> and cache behaviour/branch prediction are pretty important factors on current-gen CPUs.
01:54:16 <theorbtwo> quicksilver: Does that imply that via-c should produce better code?
01:54:30 <quicksilver> (but something entirely differnet might be true on the next gen of CPUs)
01:54:40 <quicksilver> Eduard_Munteanu: only if you use via-C does it use GCC and that isn't the default.
01:54:49 <quicksilver> theorbtwo: for certain cases yes
01:55:01 <quicksilver> theorbtwo: but GHC tends not to produce the kind of C that GCC is good at optimising.
01:55:08 <quicksilver> it tends to produce pretty odd looking C
01:55:13 <quicksilver> technically not C at all, in fact
01:55:25 <Eduard_Munteanu> Yeah, it's odd compared to JHC, IIRC.
01:55:28 <quicksilver> but something mangled which it uses GCC to compile to assembly and then unmangles in a post-processing pass.
01:55:43 <theorbtwo> Huh.
01:55:59 <quicksilver> that post-processing step is called the Evil Mangler and is, of course, written in Perl.
01:56:16 <Eduard_Munteanu> LOL
01:56:48 <quicksilver> http://hackage.haskell.org/trac/ghc/wiki/Commentary/EvilMangler
01:57:51 <Eduard_Munteanu> I tried using -c the other day in an attempt to stop GHC from linking the RTS in (there doesn't seem to be another way). But when I disassembled the output it looked very odd, I couldn't pinpoint the code.
02:00:53 <danblick> Could anyone recommend a way to do planning ( http://www.ifi.uzh.ch/ailab/aiwiki/aiw.cgi?Planning ) in Haskell?
02:01:30 <sohum> @pl \n -> f [g n]
02:01:30 <lambdabot> f . return . g
02:06:28 <pozic> danblick: all the algorithms which have been described in the literature can be implemented in Haskell. So, what are you asking? I doubt there is a library which solved your problem.
02:07:10 <quicksilver> agreeed. the big picture answer is "the same way you'd do it in any other language"
02:07:24 <pozic> danblick: probably most real world planning systems use ILP-solvers.
02:07:25 <quicksilver> down at the detail level you might find some neat haskell tricks which make things a bit simpler than they might be in other languages.
02:07:26 <danblick> pozic, I'm just looking for something to play with and I don't necessarily want to devote the time to implement one
02:07:50 <pozic> danblick: I am not aware of an open implementation of a useful system.
02:09:27 <danblick> pozic: me neither.  (is there a reason it's so hard to find mature implementations?)
02:10:20 <danblick> maybe i'll write one and release it.  just trying to do my due diligence and avoid duplicating effort, here.
02:11:03 <pozic> I wrote a program to generate a SAT expression in the syntax of a certain theorem prover in about 2-3 hours to find rectangle free squares, including reading the documented for the theorem prover. So, I guess Haskell is not that bad. Too bad the theorem prover seemed buggy. It would be a nice answer to the "what is Haskell good for"-questions ;)
02:11:46 <pozic> danblick: money
02:11:52 <Taejo> what is a rectangle free square?
02:12:40 <Saizan> pozic: using some SAT-oriented haskell lib, or just doing all the mangling yourself?
02:12:41 <ziman> what comes to my mind is: 4*4 (square) = 16 = (rectangle) 2*8
02:13:33 <Taejo> ziman: in that case a rectangle free square is just the square of a prime (isn't it?)
02:13:42 <pozic> Taejo: http://bit-player.org/2009/the-17x17-challenge
02:14:08 <Taejo> pozic: ah, right... so did you find any?
02:15:00 <pozic> Saizan: I only created the expression. I wanted to use Otter, but it seems that it is really bad on SAT problems. In auto mode "the set of support" goes empty quite soon.
02:15:38 <ziman> interesting
02:15:41 <pozic> Saizan: I first wanted to create something in first-order logic and then I figured I could just encode it in SAT directly too, which should make it a bit easier.
02:16:18 <pozic> I think a super computer can probably solve SAT problems of this size.
02:16:30 <pozic> I am not sure about personal computers, though.
02:17:16 <pozic> Saizan: I wrote my own sat solvers too, but I would not use anything written in Haskell, since they never demonstrated industrial performance in this area.
02:17:45 <pozic> Generating the problem takes about 1 second of user time and 8 second to print it (terminal being slow).
02:19:52 <Saizan> industrial SAT solvers have lots of lowlevel optimizations i guess
02:20:53 <pozic> Saizan: they probably don't do stupid stuff, but I don't think they use special algorithms.
02:21:19 <Saizan> maybe it's easier to get acceptable performance for higher level constraint solvers?
02:21:50 <Saizan> e.g finite integer domains with disequalities and arithmetic
02:22:07 <pozic> Saizan: it might ;)
02:22:15 * hackagebot upload: gt-tools 0.1 - Console and GUI interface for Google Translate service (MikhailPobolovets)
02:22:40 <pozic> Saizan: but in the end it is all the same misery.
02:22:55 <Saizan> misery?
02:24:41 <sohum> Is there any way to access "this record" when assigning a record field?
02:24:55 <quicksilver> sohum: by giving it a name.
02:24:55 <Saizan> no
02:25:01 <quicksilver> (which is in scope)
02:25:19 <pozic> Saizan: apt-get install dict && dict misery
02:25:27 <quicksilver> \r -> r { foo = ( ... some expression mentioning r .. ) }
02:25:42 <quicksilver> or do something sensible with lenses
02:26:04 <quicksilver> Saizan's simpler answer is good too ;)
02:26:18 <Saizan> pozic: i know what misery means in general :)
02:26:22 <sohum> quicksilver: that won't have the semantics of "this" if the fields are later modified...
02:26:34 <sohum> so no?
02:26:53 <theclaw> hmm, shouldn't that be "instance MonadError (Either e) a" in http://www.haskell.org/all_about_monads/html/errormonad.html?
02:27:01 <Saizan> if you need an OO-style "this" you need to add an extra argument to your fields
02:27:24 <sohum> I guess I'll just have to call l fieldName options options
02:27:28 <quicksilver> sohum: not sure what you mean by 'later' in this context.
02:27:43 <quicksilver> sohum: pure expressions don't have a notion of time
02:27:46 <quicksilver> values are just values
02:27:51 <quicksilver> and values can't be later modified
02:27:54 <quicksilver> they're immutable.
02:28:09 <Saizan> theclaw: MonadError e (Either e), actually
02:28:41 <theclaw> Saizan: but generally, if the class definition has two arguments, the instance definitions needs two as well?
02:28:51 <Saizan> theclaw: yes
02:28:55 <theclaw> thanks
02:30:17 <sohum> immutably references whatever "this" was at time of asssignment. any new objects created my replacing fields of the old object will still reference the old object.
02:30:18 <pozic> \Saizan: I meant that while it is possible that my translation is not efficient a good SAT solver should be able to eliminate that (another NP-Hard problem). Your higher-level encoding will have to solve essentially the same problems. They can both do a polynomial amount of work, because they hit the exponential wall( unless P=NP).
02:30:28 <quicksilver> sohum: yes.
02:30:36 <quicksilver> sohum: that is indeed how it works.
02:31:01 <quicksilver> sohum: if you want to reference "the current status of entity FOO, which might have been altered" then just the value isn't good enough
02:31:13 <quicksilver> sohum: you're going to need to code your own notion of Identity
02:31:28 <quicksilver> sohum: e.g. "type EntityID = Int"
02:31:42 <quicksilver> sohum: store the EntityID, and keep entities in a big Map EntityID Entity
02:31:48 <quicksilver> or, something along those generaly lines.
02:31:54 <sohum> @pl \o -> (f o) . (g o)
02:31:54 <lambdabot> liftM2 (.) f g
02:32:19 <quicksilver> in principle you can use an IORef as your identity but I don't really recommend that.
02:32:24 <Saizan> or have data Foo = Foo { foo :: Foo -> A -> B } instead of data Foo = Foo { foo :: A -> B }, and call the methods by self application
02:32:55 <sohum> Saizan: yea, that's what I'm leaning towards
02:33:24 <sohum> @hoogle liftM2
02:33:25 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
02:36:07 <quicksilver> Saizan: sure, if you only ever need it at method call time
02:36:20 <quicksilver> Saizan: I had the impressio, perhaps wrongly, that sohum wanted longer lived references.
02:37:25 <sohum> quicksilver: well, if you never call it, then it doesn't matter :P
02:39:41 <Saizan> yeah, it's a weaker form of identity, you can't compare them for example
02:40:29 <sohum> @pl \(m a, mb) -> m (a, b)
02:40:29 <lambdabot> (line 1, column 5):
02:40:29 <lambdabot> unexpected "a"
02:40:29 <lambdabot> expecting operator or ")"
02:40:37 <sohum> hooglel \(m a, mb) -> m (a, b)
02:40:42 <sohum> bah
02:41:02 <Saizan> maybe it'd please solipsists :)
02:41:09 <sohum> @hoogle \(m a, mb) -> m (a, b)
02:41:09 <lambdabot> Parse error:
02:41:09 <lambdabot>   --count=20 "\(m a, mb) -> m (a, b)"
02:41:09 <lambdabot>              ^
02:41:32 <Saizan> you can't have lambda in your types, sir
02:41:38 <sohum> @hoogle (m a, mb) -> m (a, b)
02:41:39 <lambdabot> No results found
02:41:43 * sohum stabs lag and brain
02:41:49 <quicksilver> :t liftM2 (,)
02:41:50 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m (a1, a2)
02:41:55 <quicksilver> is that what you want, sohum ?
02:41:58 <quicksilver> or possibly
02:42:05 <quicksilver> :t uncurry (liftM2 (,))
02:42:06 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => (m a1, m a2) -> m (a1, a2)
02:42:17 <sohum> that'd be perfect
02:42:23 <pozic> Is there anyone who has written a lot of C (or C++) and a lot of Haskell and can say something about the resulting readability of his/her own code?
02:42:25 <sohum> danke
02:42:48 <quicksilver> Saizan: I found a concrete reason to "prefer" the applicative class for arrows
02:43:14 <quicksilver> Saizan: sequenceA ends up with the type [a ~> b] -> a ~> [b]
02:43:26 <quicksilver> Saizan: which is useful. And really painful to try to write using &&& ;)
02:43:38 <quicksilver> OK not that painful.
02:43:52 <quicksilver> Saizan_: bah. Did you miss that?
02:44:07 <Saizan_> probably :)
02:44:11 <quicksilver> Saizan: I found a concrete reason to "prefer" the applicative class for arrows
02:44:13 <quicksilver> Saizan: sequenceA ends up with the type [a ~> b] -> a ~> [b]
02:44:16 <quicksilver> Saizan: which is useful. And really painful to try to write using &&& ;)
02:44:27 <quicksilver> OK it's not that painful. But it's still useful to have the combinator.
02:45:07 <Saizan_> ah, nice :) i think i've written that one for arrows before
02:45:23 <alp> pozic, I find Haskell code to be way more clear, because of the expressiveness and the conciceness
02:46:37 <alp> BUT with C++ I wrote some nice templates-based code which was quite nice to read (on the side using my classes, not themselves)
02:47:32 <Wooga_tc> hello, i am trying to do my homework: implement for cycle; i did it as http://pastey.net/132024 but isn't there any way to do it better?
02:47:44 <Saizan_> quicksilver: i'm writing an Arrow instance using Category + Applicative in Agda, and it seems i need some additional laws to write the proofs, like const <$> f <*> id = f, but that's not surprising since otherwise we've two sets of combinators without any relation between them
02:48:19 <Saizan_> unless there's some metatheoretic obeservation like parametricity that subsumes those
02:49:26 <quicksilver> Saizan_: that's interesting.
02:49:39 <quicksilver> Saizan_: but it looks like an 'obvious' law ;)
02:50:48 <quicksilver> Saizan_: didn't we agree to define the functor instance that way?
02:50:49 <ivanm> Wooga_tc: what are you trying to implement sorry?
02:50:56 <quicksilver> or hmm
02:50:59 <Wooga_tc> Wooga_tc: for cycle
02:50:59 <ivanm> I don't really understand what you are trying to do
02:51:02 <quicksilver> Wooga_tc: looks OK to me
02:51:07 <ivanm> what does "for cycle" mean?
02:51:08 <quicksilver> Wooga_tc: although you have more () than you need
02:51:12 <quicksilver> ivanm: a for loop, as in C
02:51:13 <Saizan_> quicksilver: we defined arr f = f <$> id
02:51:14 <ivanm> oh, a for loop?
02:51:18 <ivanm> aha
02:51:37 <Wooga_tc> quicksilver: is there any way to get rid of 'do'?
02:51:43 <quicksilver> yes
02:52:02 <ivanm> Wooga_tc: then job i >> for (f i) p f job
02:52:07 <ivanm> else job i
02:52:25 <quicksilver> Wooga_tc: if p i then job i >> for (f i) p f job else job i
02:52:30 <Wooga_tc> thanks
02:52:32 <quicksilver> Wooga_tc: is the same but shorter
02:52:37 <quicksilver> arguably less readable though
02:52:54 <quicksilver> if (p i) then (job i >> for (f i) p f job) else (job i)
02:52:54 <ivanm> alternatively, you could do: mapM_ job . takeWhile p $ iterate f i
02:52:55 <ivanm> ;-)
02:53:00 <sohum> ... I have IO ((),()) and I want IO ().
02:53:16 <sohum> wait.
02:53:21 <quicksilver> is possibly a bit easier to read although those parens are not needed
02:53:26 <quicksilver> sohum: just "return ()" then
02:53:36 <quicksilver> ... .... >> return ()
02:53:51 <c_wraith> () <$ ....
02:54:20 <c_wraith> (if your monad is also a functor)
02:54:21 <ivanm> @type \ i p f job -> mapM_ job . takeWhile p $ iterate f i
02:54:22 <lambdabot> forall a (m :: * -> *) b. (Monad m) => a -> (a -> Bool) -> (a -> a) -> (a -> m b) -> m ()
02:54:29 <c_wraith> :t (<$)
02:54:30 <ivanm> c_wraith: he said IO ...
02:54:30 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
02:54:39 <c_wraith> IO's a functor.
02:54:42 <ivanm> generalise your for loop data signature!
02:54:57 <sohum> @pl \x -> (f . g . h $ x)   >> return ()
02:54:57 <lambdabot> (>> return ()) . f . g . h
02:55:05 <ivanm> after all, is there any reason for job :: a -> IO () ?
02:55:18 <ivanm> @pl \ i p f job -> mapM_ job . takeWhile p $ iterate f i
02:55:19 <lambdabot> flip ((.) . flip . flip ((.) . mapM_) . takeWhile) . flip iterate
02:55:32 <ivanm> Wooga_tc: ^^ there we are, that's your for function in pointfree form!
02:55:57 <Wooga_tc> thanks!
02:56:05 <ivanm> no, do you understand how I got it?
02:56:29 <ivanm> *now
02:57:23 <sohum> basically, I have (IO (),IO()) and I need to sequence the two
02:57:30 <c_wraith> @pl f x = g x : f (h x)
02:57:31 <lambdabot> f = fix (liftM2 (:) g . (. h))
02:57:44 <ivanm> sohum: turn it into a list and then use sequence_ ?
02:58:15 <sohum> @hoogle (a,a) -> [a]
02:58:16 <lambdabot> Data.Ix range :: Ix a => (a, a) -> [a]
02:58:16 <lambdabot> System.Random randomRs :: (Random a, RandomGen g) => (a, a) -> g -> [a]
02:58:16 <lambdabot> Prelude snd :: (a, b) -> b
02:58:37 <c_wraith> :t liftM2 . uncurry
02:58:38 <lambdabot> forall a2 r (m :: * -> *) a b. (Monad m) => (a -> b -> a2 -> r) -> m (a, b) -> m a2 -> m r
02:58:50 <c_wraith> :t liftM2 (,) . uncurry
02:58:51 <lambdabot> forall a1 a2 a b. (a -> b -> a1) -> ((a, b) -> a2) -> (a, b) -> (a1, a2)
02:59:14 <c_wraith> oh, I have that totally backwards
02:59:22 <c_wraith> :t uncurry (liftM2 (,))
02:59:23 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => (m a1, m a2) -> m (a1, a2)
02:59:31 <c_wraith> there
03:01:18 <c_wraith> really, it'd be uncurry (liftM2 whateverFunctionYouWant)
03:01:22 <sohum> ivanm: that's significantly cleaner, thanks
03:02:16 <ivanm> @pl \(a,b) -> a >> b
03:02:17 <lambdabot> uncurry (>>)
03:02:23 <ivanm> sohum: ^^ even cleaner
03:02:29 <ivanm> ;-)
03:02:41 <c_wraith> Oh, I suppose if they're just (), that's fine.
03:02:53 <ivanm> @pl \(a,b) -> a >> b >> return ()
03:02:53 <lambdabot> uncurry (flip flip (return ()) . ((>>) .) . (>>))
03:02:55 <ivanm> heh
03:03:04 <ivanm> it's amazing how more fugly it makes it
03:03:16 <c_wraith> :t () <$ uncurry (>>)
03:03:17 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (m a, m b) -> ()
03:03:22 <ivanm> even though isn't that then just (>> return ()) . uncurry (>>) ?
03:03:35 <ivanm> so I don't know why @pl put the flips in there...
03:03:43 <ivanm> @pl \(a,b) -> (a >> b) >> return ()
03:03:43 <lambdabot> uncurry (flip flip (return ()) . ((>>) .) . (>>))
03:03:47 <ivanm> :s
03:04:24 <c_wraith> wait, why did that type signature come out that way?
03:04:33 <sinelaw> yo ivanm
03:04:33 <lambdabot> sinelaw: You have 1 new message. '/msg lambdabot @messages' to read it.
03:04:46 <ivanm> hey sinelaw
03:05:02 <sinelaw> any clues on what that problem was happening?
03:05:05 <c_wraith> :t () <$ uncurry ((>>) :: IO a -> IO b -> IO b)
03:05:07 <lambdabot> forall a b. (IO a, IO b) -> ()
03:05:07 <sinelaw> s/what/why/
03:05:38 <c_wraith> ...  Shouldn't the return type be IO () ?
03:05:39 <sinelaw> @hoogle a -> ()
03:05:39 <lambdabot> Control.Parallel.Strategies r0 :: Strategy a
03:05:39 <lambdabot> Control.Parallel.Strategies rwhnf :: Strategy a
03:05:39 <lambdabot> Prelude id :: a -> a
03:05:42 <c_wraith> I'm confused
03:05:55 <Saizan> c_wraith: the functor is (->) r there
03:06:01 <ivanm> sinelaw: I believe the message explains it ;-)
03:06:09 <Saizan> c_wraith: so you're just throwing away the whole action
03:06:21 <sinelaw> ivanm, it does! but that was two hours ago :) i'm just being curious, not pushy
03:06:27 <p_l> ^^;
03:06:37 <c_wraith> :t uncurry (>>)
03:06:37 <ivanm> heh, haven't done any hacking since then
03:06:38 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (m a, m b) -> m b
03:06:42 <Saizan> ?type (() <$) .  uncurry (>>)
03:06:43 <lambdabot> forall (f :: * -> *) b a. (Functor f, Monad f) => (f a, f b) -> f ()
03:06:46 <p_l> damn, wrong window
03:06:48 <sinelaw> k
03:06:53 <ivanm> p_l: heh
03:07:14 <ivanm> sinelaw: so what I'm going to investigate is how to call dot, etc. in a lazy fashion
03:07:15 <c_wraith> Oh.  I see.  blah.
03:07:33 <sinelaw> ok
03:08:04 <sinelaw> good luck :) i have some studying to do, unfortunately. digital communications.
03:09:43 <ivanm> heh
03:10:12 <ivanm> Wooga_tc: so, do you understand how I got that version?
03:10:19 <sinelaw> (for which, btw, a visual graph editor would really help!)
03:10:24 <Wooga_tc> ivanm: trying to
03:10:26 <ivanm> sinelaw: heh
03:10:32 <ivanm> Wooga_tc: OK, ignore the @pl'd version
03:10:51 <ivanm> for i p f job = mapM_ job . takeWhile p $ iterate f i
03:11:10 <ivanm> Wooga_tc: first of all, rather than explicitly recurring, this constructs a list of all possible i values
03:11:18 <ivanm> > iterate (+1) 0
03:11:20 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
03:11:24 <ivanm> > iterate (*2) 0
03:11:25 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
03:11:28 <ivanm> > iterate (*2) 1
03:11:29 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
03:11:42 <ivanm> I then only get the valid ones:
03:11:49 <ivanm> > takeWhile (<10) $ iterate (*2) 1
03:11:50 <lambdabot>   [1,2,4,8]
03:11:54 <ivanm> Wooga_tc: with me so far?
03:12:40 <Wooga_tc> yes, but isn't there chance that valid values will be in different places?
03:13:00 <ivanm> hmmm.... what do you mean?
03:13:47 <Wooga_tc> ah, since you can't pass something  like <10 || >20 && < 30, there shouldn't be any
03:14:15 <ivanm> > let forValues i p f = if p i then i : forValues (f i) p f else [] in forValues 0 (<10) (*2)
03:14:16 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
03:14:20 <ivanm> > let forValues i p f = if p i then i : forValues (f i) p f else [] in forValues 1 (<10) (*2)
03:14:21 <lambdabot>   [1,2,4,8]
03:14:22 <ivanm> grrr...
03:14:26 <Veinor> > filter (\x -> x < 10 && x > 20 || x < 30) [1..]
03:14:27 <ivanm> Wooga_tc: well, you can...
03:14:30 <lambdabot>   mueval-core: Time limit exceeded
03:14:34 <Veinor> then that happens.
03:14:59 <ivanm> Wooga_tc: are there meant to be parens around the x > 20 || x < 30 bit?
03:15:12 <ivanm> Veinor: takeWhile, not filter
03:15:30 <Veinor> well yeah :P
03:15:36 <Wooga_tc> yes, and &&, not ||
03:15:37 <ivanm> Wooga_tc: dont' forget, in a for loop as soon as _one_ invalid value is found then it stops looking
03:15:42 <ivanm> right
03:15:52 <Wooga_tc> but it should work withouy parens too
03:15:59 <ivanm> and presumably || not && ? so it's x < 10 || (x > 20 && x < 30)
03:15:59 <Wooga_tc> at least in C
03:16:13 <ivanm> Wooga_tc: yeah, but I can never remember the precedence rules for || and &&
03:16:21 <ivanm> so for things like that I prefer to put the parens explicitly
03:16:28 <Veinor> > True && True || False
03:16:29 <lambdabot>   True
03:16:41 <Veinor> > True || True && False
03:16:42 <lambdabot>   True
03:16:46 <ivanm> > let forValues i p f = if p i then i : forValues (f i) p f else [] in forValues 1 (\x -> x < 10 || (x > 20 && x < 30))) (*2)
03:16:47 <lambdabot>   <no location info>: parse error on input `)'
03:16:50 <Zao> && is tighter than || in C++
03:16:53 <ivanm> > let forValues i p f = if p i then i : forValues (f i) p f else [] in forValues 1 (\x -> x < 10 || (x > 20 && x < 30)) (*2)
03:16:53 <Veinor> && binds tighter.
03:16:54 <lambdabot>   [1,2,4,8]
03:17:06 <ivanm> > let forValues i p f = if p i then i : forValues (f i) p f else [] in forValues 1 (\x -> x < 10 || (x > 20 && x < 30)) (*3)
03:17:07 <lambdabot>   [1,3,9,27]
03:17:25 <Veinor> && has precedence 3, || has precedence 2
03:17:27 <ivanm> > takeWhile (\x -> x < 10 || (x > 20 && x < 30)) $ iterate (*3) 1
03:17:28 <lambdabot>   [1,3,9,27]
03:17:34 <ivanm> Wooga_tc: ^^ same values
03:17:52 <ivanm> all I'm doing is constructing all possible i values and then taking them whilst they're valid, rather than testing for validity at each step
03:18:08 <ivanm> because Haskell is lazy, this is feasible; in C it isn't
03:20:58 <ivanm> Wooga_tc: so, do you believe me that that this is a valid way of getting all the i values for the for loop?
03:24:52 <Wooga_tc> yes
03:25:38 <ivanm> OK, so all that's left to do is to apply the function to each of the i values and sequence them
03:25:40 <ivanm> mapM_ does that
03:25:43 <ivanm> @type mapM_
03:25:44 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
03:25:49 <temoto> How to send a message to someone?
03:26:00 <temoto> i mean offline note
03:26:15 <temoto> lambda bot is capable of something like it
03:26:18 <Wooga_tc> mapM_ seems scary
03:26:33 <Wooga_tc> temoto: look at /memoserv help
03:26:35 <temoto> @src MapM_
03:26:35 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
03:26:40 <temoto> @src mapM_
03:26:40 <lambdabot> mapM_ f as = sequence_ (map f as)
03:26:46 <ivanm> temoto: @tell foo message
03:26:48 <temoto> Wooga_tc: not to worry, man :)
03:26:59 <ivanm> @src sequence_
03:27:00 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
03:27:24 <ivanm> Wooga_tc: so you apply the function to each value in the list, and then join them together using >> (since you don't care what value it returns)
03:27:39 <temoto> Wooga_tc: it's just "apply f to all elements of as, wait for all evaluations and return ()"
03:27:40 <ivanm> this creates one big IO action which can then be used elsewhere
03:27:56 <temoto> omg i just described an algorith in imperative style
03:28:04 <ivanm> note that the actions are indeed _sequenced_, so the first action happens first, etc.
03:28:48 <temoto> inhortte: thanks
03:28:55 <temoto> ivanm: thanks
03:29:00 <ivanm> temoto: no worries
03:32:32 <temoto> @src Num
03:32:33 <lambdabot> class  (Eq a, Show a) => Num a  where
03:32:33 <lambdabot>     (+), (-), (*)           :: a -> a -> a
03:32:33 <lambdabot>     negate, abs, signum     :: a -> a
03:32:33 <lambdabot>     fromInteger             :: Integer -> a
03:38:51 <ketil> I have a program that requires a lot of memory to run - but I don't really understand why.  Running with heap profiling shows a modest 60MB heap being used, but limiting heap to say 200M causes a 'Heap exhausted' message.  Any idea?
03:40:05 <ivanm> ketil: I randomly guess that you have a list or some other large structure you're holding on for too long
03:40:24 <Saizan> it should still show up in the heap profile
03:40:27 <ketil> ivanm: well - maybe. How do I find out if heap profiling doesn't work?
03:40:29 <ivanm> try profiling it normally and seeing what functions use the most memory
03:41:25 <ketil> ivanm, -p, you mean, and check allocations?
03:41:40 <ivanm> yup
03:43:59 <mgsloan> are there any good programs (other than ctrl alt delete, or some linux top equivalent) that charts out the resource usage / allocations
03:45:23 <kamatsu> mgsloan: for what OS?
03:46:11 <temoto> jmcarthur: ping
03:46:33 <temoto> mgsloan: yes, htop.
03:49:06 <sohum> > 0.0/0.0
03:49:07 <lambdabot>   NaN
03:49:23 <sohum> > 0.0/0.0 < 1
03:49:24 <lambdabot>   False
03:51:16 <temoto> > NaN > 1
03:51:18 <lambdabot>   Not in scope: data constructor `NaN'
03:51:33 <temoto> > 0.0/0.0 > 1
03:51:34 <lambdabot>   False
03:51:44 <temoto> Excellent inequation :)
03:52:15 <pozic> Is there a lazy form of liftM2, which does not evaluate the second action, if it is not needed to compute the answer?
03:52:56 <ivanm> pozic: what do you mean?
03:53:00 <ivanm> @src liftM2
03:53:00 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
03:53:16 <ivanm> pozic: I'm not sure if you can have a generic version of such a function...
03:53:18 <pozic> E.g. liftM2 (||) (return True) (do someinfiniteloophere) loops in some monads, AFAIK.
03:53:40 <ivanm> I think that it has to be a per-function thing, because you can't tell if a function is lazy in its second argument
03:53:47 * hackagebot upload: data-aviary 0.2.3 - Combinator birds. (StephenTetley)
03:53:49 <ivanm> and as such there's no need to evaluate the second action
03:53:50 <quuxman> @seen mightybyte
03:53:50 <lambdabot> Unknown command, try @list
03:53:52 <ivanm> :o
03:53:59 <ivanm> preflex: seen mightybyte
03:54:00 -preflex(n=preflex@95-88-118-220-dynip.superkabel.de)- mightybyte was last seen on #haskell 6 days, 15 hours, 20 minutes and 39 seconds ago, saying: @seen ivanm
03:54:03 <ivanm> quuxman: ^^
03:54:21 <quuxman> hah
03:54:28 <pozic> Why is that displayed in color? What's so important about that bot?
03:54:42 <pozic> By why, I don't mean the technical details.
03:56:01 <ivanm> pozic: it uses NOTICE
03:56:05 <ivanm> rather than PRIVMSG
03:56:18 <ivanm> which apparently is the "correct" way for bots to speak, so that they don't accidentally talk to each other
03:56:54 <quicksilver> but it means IRC clients display it more colourfully
03:56:59 <pozic> Did that do anything?
03:57:04 <quicksilver> which is arguably a deficiency in the clients
03:57:09 <pozic> I wrote /notice foobar
03:57:23 <quicksilver> you have to say /notice #haskell foobar, IIRC
03:57:25 <ivanm> well, in xchat you have -preflex/#haskell- in the LHS rather than just preflex
03:57:29 -pozic(n=pozic@unaffiliated/pozic)- foobar
03:57:32 <pozic> Ah, ok.
03:57:36 <ivanm> @slap pozic
03:57:37 <lambdabot> go slap pozic yourself
03:57:37 <ivanm> ;-)
03:57:40 <ivanm> grrr...
03:57:47 <idnar> @slap pozic
03:57:48 <lambdabot> stop telling me what to do
03:57:49 * hackagebot upload: hakyll 1.2 - A simple static site generator library. (JasperVanDerJeugt)
03:57:53 <idnar> heh
03:57:56 <idnar> @slap ivanm
03:57:56 <lambdabot> I don't perform such side effects on command!
03:58:03 <ibid> how do i tell cabal that a module is used by more than one executable, so that it won't rebuild it for all executable separately?
03:58:06 <pozic> @slap lambdabot
03:58:07 <lambdabot> *SMACK*, *SLAM*, take that lambdabot!
03:58:10 <ivanm> lambdabot is obviously in a peace-keeping mood tonight...
03:58:11 <quuxman> wish mightybyte was around so he could explain how to use his happstack-auth library
03:58:15 <ivanm> but still masochistic :s
03:58:35 <ivanm> ibid: in cabal-1.8, you can in a sense
03:58:46 <ivanm> where if your app has a library, then it can use that library rather than rebuilding everything
03:58:57 <ivanm> but if you don't want to expose that module in a library, then there's no way of doing so AFAIK
03:59:05 <ivanm> note that cabal-install can't yet deal with this situation :s
03:59:08 <ibid> no library needed
03:59:19 <ivanm> ibid: well, you do for cabal ;-)
03:59:25 <ivanm> (to get that feature anyway)
03:59:34 <ivanm> ibid: in that case, there's no way as yet
03:59:38 <ibid> let me rephrase: my package has no need for a library
03:59:44 <ibid> but yeah
03:59:46 <ivanm> yeah, I understood that
03:59:47 <ivanm> ping dcoutts about it
03:59:53 <ibid> and yeah, it looks quite stupid that it rebuilds almost everything
04:00:00 <ibid> dcoutts: ping ^^
04:00:14 <ivanm> he's moving offices atm AFAIK
04:00:18 <ivanm> so maybe @tell him
04:00:27 <pozic> What happens when x contains True and y contains undefined?  liftM2 (||) (readSTRef x) (readSTRef y)
04:00:41 * ibid does not believe in lambdabot messaging
04:00:54 <ibid> or perhaps i'll just report the bug :)
04:01:00 <pozic> In every imperative language, this is lazy.
04:01:05 <ivanm> pozic: since I've never used readSTRef, I don't know
04:01:13 <ivanm> ibid: well, there's always MemoServ ...
04:01:16 <ivanm> or email
04:01:17 <ivanm> or phone
04:01:18 <ivanm> or fax
04:01:24 <ivanm> or knocking on his door
04:01:24 <ivanm> ;-)
04:01:33 <ibid> ivanm: or a bug report, which is the most appropriate one for this
04:01:43 <ivanm> ibid: heh, but that's not just dcoutts then!
04:01:45 <pozic> ivanm: I will just test it, but AFAIK, it blows up.
04:01:49 <ibid> knocking is, lackikng teraport, quite impractical :)
04:01:58 <ivanm> "teraport" eh?
04:02:11 <c_wraith> schlock mercenary fan?
04:02:12 <ivanm> "terraport" would be a space port for Earth or something...
04:02:17 <ivanm> ;-)
04:03:01 <ibid> c_wraith: yup. doing the binge, on my off hours :)
04:03:09 <ivanm> c_wraith: dammit, you've just provided me with another online comic strip on which I'll be wasting hours reading all the old strip, etc. :@
04:03:11 <ivanm> ;-)
04:03:22 <ibid> ivanm: weeks, if my experience is of any use
04:03:26 <theorbtwo> Send him a large box, that contains nothing but a small slip of paper that says "read your email".
04:03:29 <c_wraith> about 10 years of daily archives.
04:03:40 <ibid> ivanm: in fact, it's already been reported (#89)
04:03:45 <c_wraith> I'm glad I started reading it when it was only 3 or 4 years in. :)
04:03:47 <ibid> i'm currently in mid-2003
04:03:49 <ivanm> ibid: :s
04:03:50 <pozic> ivanm: hmm, it actually works!
04:03:56 <quicksilver> pozic: in general you need to rewrite ||
04:03:56 <ivanm> theorbtwo: heh
04:04:05 <ivanm> pozic: :o
04:04:07 <pozic> quicksilver: huh
04:04:13 <ivanm> quicksilver: yeah, that was my guess
04:04:17 <quicksilver> pozic: for this particular case, it's fine, because "readSTRef y" does not crash just because the value inside the ref is undefined.
04:04:36 <quicksilver> it just returns undefined quite happily without crashing
04:04:44 <quicksilver> and then (True || undefined) --~--> True
04:04:45 <pozic> quicksilver: ah, so for an infinite loop it would have been a problem.
04:04:49 <pozic> quicksilver: you are right.
04:05:14 <ibid> ivanm: thanks, anyway :)
04:05:23 <pozic> @quote quicksolver
04:05:23 <quicksilver> in general you'd need to write a ||| b = do x <- a; if x then return True else b
04:05:23 <lambdabot> No quotes match. Take a stress pill and think things over.
04:05:38 <pozic> @quote quicksilver
04:05:39 <lambdabot> quicksilver says: <jatqceer> i love them.  Double is my friend <quicksilver> You think he is, sure <quicksilver> he says nice things about you <quicksilver> but one day, when your back is turned, he
04:05:39 <lambdabot> will stab you in the back with a mantissa
04:05:45 <quicksilver> which explicitly doesn't even run b unless needed.
04:05:48 <ivanm> heh
04:06:01 <ivanm> quicksilver: does that type check?
04:06:09 <pozic> quicksilver: yes, that was what I was already writing before doing this little experiment.
04:06:36 <quicksilver> :t let a ||| b = do x <- a; if x then return True else b in (|||)
04:06:37 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m Bool -> m Bool
04:06:43 <quicksilver> ivanm: computer says yes.
04:06:51 <ivanm> quicksilver: oh, m Bool
04:06:52 <ivanm> duh
04:06:52 <ivanm> yeah
04:07:00 <quicksilver> ivanm :: m Duh
04:07:39 <ivanm> heh
04:08:23 <quicksilver> pozic: this kind of "laziness" is not really related to true laziness in any way that haskell can understand
04:08:31 <quicksilver> although there is an intuitive link that we may understand.
04:08:58 <quicksilver> you may do tricks with unsafeInterleave in some cases.
04:09:16 <pozic> quicksilver: it is trivial to prove that for code only involving reads it should not do them.
04:09:26 <pozic> quicksilver: also trivial for a compiler.
04:09:44 <quicksilver> I think it might be the case that "liftM2 (||) (unsafeInterleaveIO $ a) (unsafeInterleaveIO $ b) is what you want, but I'm not 100% sure
04:10:04 <quicksilver> sure, but GHC does not attempt to do any analysis of such things.
04:10:13 <zygoloid> eww :)
04:10:46 <sohum> ($) is surprisingly useful for lists of functions
04:11:03 <sohum> mapping over them, specifically
04:11:07 <pozic> quicksilver: I see no observable difference between your definition with unsafePerformIO and without.
04:11:09 <zygoloid> right sections of $? yeah
04:11:41 <pozic> quicksilver: except that the unsafe one is more specific and has very vague semantics.
04:11:46 <sohum> @pl \x -> f x
04:11:46 <lambdabot> f
04:11:54 <sohum> @pl \f -> f x
04:11:55 <lambdabot> ($ x)
04:12:04 <quicksilver> pozic: well the one with unsafeInterleave re-uses the existing (||)
04:12:15 <quicksilver> pozic: the one without had to re-invent the logic inside || from scratch
04:12:18 <quicksilver> I thought that was what you wanted.
04:13:03 <pozic> quicksilver: ah, ok, that would also work for lifting any.
04:13:11 <pozic> quicksilver: that is the function named any.
04:13:20 <zygoloid> pozic: the second unsafeInterleaveIO is the scary one. consider: (return False ||| (engageSafetyLatch >> return True)) >> maybeLaunchTheNukes
04:13:32 <pozic> Via map unsafeInterleaveIO
04:13:49 <pozic> zygoloid: I have a fairly good idea of what it does operationally.
04:14:09 <pozic> zygoloid: but no guarantees on whether it will keep doing that.
04:14:28 <zygoloid> i think you want: "a ||| b = liftM2 (||) (unsafeInterleaveIO a) b"
04:15:04 <ketil> ivanm, Saizan : I seem to have fixed the heap issue by making a data structure stricter.  Strange about the heap profiles, though...
04:15:28 <ivanm> ketil: ooh, yeah, I've seen something like that before
04:15:36 <zygoloid> i retract my thought :)
04:15:42 <ivanm> the big one is having a counter record field to see how many iterations you do...
04:15:58 <ivanm> if it's Int, then it won't be evaluated until the end, so you need !Int
04:16:24 <zygoloid> "a ||| b = liftM2 (||) a (unsafeInterleaveIO b) >>= evaluate" might work
04:16:28 <ketil> I'll aslo note that +RTS -s reports maximum residency at 160MBytes - yet +RTS -M400M failed with 'Heap exhausted'.
04:16:30 <Saizan> ketil: i still think it's a bug the profiler didn't show it
04:16:44 <quicksilver> ketil: maximum memory required = 3x maximum residency
04:17:04 <ketil> quicksilver, how so?  Oh, space for copying GC?
04:17:09 * quicksilver doesn't understand why it's 3x not 2x
04:17:11 <quicksilver> but yes, the copying.
04:17:15 <ketil> I thought it'd switch to compacting when nearing the ceiling?
04:17:22 <pozic> We talked about allocation yesterday. Why exactly is malloc in C slow where allocating stuff in the heap in Haskell is fast?
04:17:23 <quicksilver> don't think so.
04:17:47 <quicksilver> malloc stores (and keeps up-to-date) more metadata
04:17:53 <ketil> pozic, because it has to handle arbitrarily sized chunks?
04:17:56 <quicksilver> is I think the standard answer.
04:18:11 <quicksilver> in fact, you can make trade a fast malloc for a slow free
04:18:21 <quicksilver> which is a good trade if you never bother to free() ;)
04:18:34 * ketil remembers reading Effective C++(?) where the standard way to improve C++ performance was to write custom allocators.
04:18:36 <zygoloid> i /think/ it's the case that (unsafeInterleaveIO >=> evaluate) == id :: IO a -> IO a
04:18:42 <pozic> It is 3* because X*2 = 2X. Then we also double everytime. So, we get 3X.
04:18:51 <pozic> At least that's my current theory.
04:19:06 <quicksilver> typically mallocs do things like maintain various pools for various different sized allocations
04:19:10 <pozic> If you compute the exact requirements, you can probably get it to 2*.
04:19:15 <quicksilver> and maintain various free lists
04:19:38 <zygoloid> pozic: malloc in C is slow partly because it's poorly implemented. google perftools' tcmalloc is /much/ faster than glibc's malloc
04:19:40 <quicksilver> they try quite hard to do all that stuff fast, but it's still slower than a simple pointer increment.
04:19:46 <ketil> oh - and the stricter version halved GC time: 11% vs 20%.
04:20:08 <pozic> zygoloid: I am actually talking about a perfectly implemented malloc/free combination.
04:20:28 <pozic> zygoloid: it might be that this does not exist.
04:20:48 <idnar> @type (>=>)
04:20:49 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
04:20:59 <temoto> :t evaluate
04:20:59 <zygoloid> pozic: oh, in that case, allocation in haskell is cheap because it doesn't have to do much bookkeeping, because it doesn't have to support arbitrary frees and maintain stable pointers
04:21:00 <lambdabot> Not in scope: `evaluate'
04:21:49 <quicksilver> ketil: the standard C++ allocator improvment is to write an allocator for a specific fixed-sized chunk of memory
04:21:57 <int-e> :t Control.Exception.evaluate
04:21:58 <lambdabot> forall a. a -> IO a
04:21:59 <quicksilver> ketil: (the overwhelmingly common case in an object-heavy program)
04:22:18 <quicksilver> ketil: Foo::allocator only worries about uniform chunks of size sizeof(Foo)
04:22:43 <quicksilver> it wouldn't surprise me if more modern, better, mallocs perform better for that case than the stuff that used to be used when that first became standard advice.
04:23:17 <pokoko222> anyone has read Aristotle Categories?
04:23:28 <temoto> int-e: what the hell is that for?
04:23:58 <int-e> to force evaluation and get a well-defined point where the corresponding exceptions are raised.
04:24:16 <int-e> (like UserError exceptions from  error "foo"  calls)
04:24:27 <quicksilver> its unfortuante that the semantics of evaluate were mis-defined and nobody really knows what it does.
04:24:42 <temoto> You can't catch the error "foo", right?
04:24:47 <quicksilver> sure you can
04:24:53 <temoto> You can?
04:24:54 <quicksilver> it's immoral, not impossible
04:25:01 <temoto> And undefined too?
04:25:07 <zygoloid> @src undefined
04:25:07 <quicksilver> it might even be illegal, depending on your jurisdiction
04:25:07 <lambdabot> undefined =  error "Prelude.undefined"
04:25:10 <quicksilver> but still not impossible.
04:25:17 <temoto> But how?
04:25:23 <zygoloid> @hackage spoon
04:25:23 <lambdabot> http://hackage.haskell.org/package/spoon
04:25:26 <int-e> you can, with Control.Exception.catch, but not with Prelude.catch. (Hopefully I got that right?)
04:25:32 <quicksilver> the spoon is worse.
04:25:44 <zygoloid> there really should be no spoon :)
04:25:47 <quicksilver> the spoon takes mere immorality and broadens it into a violation of monotonicity.
04:26:17 <Badger> teaspoon :: a -> Maybe a -- hah! :D
04:26:25 <temoto> :t catch
04:26:26 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
04:26:33 <int-e> teaspoon a = unsafePerformIO $ (Just `fmap` evaluate a) `catches` handlers
04:26:36 <temoto> :t Control.Exception.catch
04:26:37 <lambdabot> forall a e. (GHC.Exception.Exception e) => IO a -> (e -> IO a) -> IO a
04:26:40 <int-e> so ... pretty?! *ducks*
04:27:07 <temoto> I see, so it turns exception into IO action.
04:27:35 <dolio> Technically, you don't need evaluate at all, though.
04:27:37 <temoto> Does it catch all exceptions and then you patten match on type?
04:28:10 <int-e> not anymore, it uses the extensible exceptions of base 4
04:28:36 <quicksilver> dolio: I am in favour of removing evaluate because I think I understand 'seq' better
04:28:50 <quicksilver> dolio: however I don't think you can *actually* define evaluate with seq.
04:29:00 <quicksilver> you can, however, do the same kinds of things with it in a slightly different way.
04:29:17 <int-e> (Just read the source. It's short. It employs unsafePerformIO. Use at your own risk.)
04:29:20 <dolio> quicksilver: I mean it doesn't matter, because 'error "foo" `catch` \e -> ...' catches the error anyway.
04:29:47 <dolio> So any way of dragging the bottom into the IO action works.
04:30:37 <quicksilver> dolio: that's only because you polymorphed the error "foo"
04:30:48 <quicksilver> dolio: try that with (error "foo" :: Int)
04:31:20 <quicksilver> pure errors aren't generally polymorphic like that. they normally have some intended type.
04:32:29 <dolio> quicksilver: (return $! (error "foo" :: Int)) `catch` \e -> ...
04:32:33 <dolio> That catches the exception.
04:32:42 <quicksilver> yes, I know.
04:32:55 <quicksilver> what's what I meant by "you can do the same kinds of things with it (seq) in a slightly different way)
04:34:12 <besiria> hi, cannot cabal-install SHA-1.4.0 with ghc 6.12.1 .  I get the same buid failure as on hackage. Any ideas?
04:34:17 <dolio> Well, presumably it shouldn't catch that, if evaluate is supposed to have any purpose.
04:34:23 <dolio> But it does, so it doesn't.
04:36:47 <int-e> > (return $! "foo" :: IO String) `seq` 1
04:36:48 <lambdabot>   1
04:37:05 <int-e> > (return $! error "foo" :: IO String) `seq` 1
04:37:06 <lambdabot>   * Exception: foo
04:37:15 <sohum> in fgl, what does "Edge Exception: Node: _" mean?
04:37:22 <int-e> > (Control.Exception.evaluate (error "foo") :: IO String) `seq` 1
04:37:23 <lambdabot>   Not in scope: `Control.Exception.evaluate'
04:37:28 <ivanm> sohum: I think I've seen that before
04:37:33 <ivanm> what function did you call to get that?
04:37:43 <ivanm> because I _think_ it's when you try to build a graph
04:37:47 <ivanm> it gets rather picky with that
04:38:15 <quicksilver> int-e: the difference is that in (return $! foo), foo gets evaluated when that expression is *evaluated*
04:38:29 <quicksilver> int-e: in (evaluate foo) it gets evaluated when that expression is *executed*
04:38:34 <int-e> subtle, but that's a difference between  evaluate  and  return $!. The other is that with  return $!, the compiler could actually evaluate the argument earlier. But GHC is usually careful not to do that.
04:38:36 <sohum> ivanm: I'm not sure where in my codebase it's being called
04:38:49 <ivanm> doesn't the error message say anything? :s
04:38:53 <sohum> ivanm: nup.
04:38:57 <quicksilver> int-e: however I don't know of any case when you care; I challenged JaffaCake once and he couldn't come up with one that convinced me.
04:39:26 <dolio> quicksilver: I think '\x -> (return $! x) >>= return' might actually reduce to something like the definition of evaluate.
04:39:32 <ivanm> sohum: you could always grep the source to find out which function has that error message
04:39:35 <quicksilver> dolio: that's what the docs say
04:39:40 <quicksilver> dolio: they are said to be gravely in error.
04:39:44 <ivanm> (and then find which functions call that one, etc.)
04:39:46 <dolio> Even though it shouldn't, according to the monad laws.
04:40:00 <dolio> But (>>= return) in IO isn't strict.
04:40:24 <quicksilver> dolio: http://www.haskell.org/pipermail/haskell-cafe/2008-May/042367.html
04:41:03 * quicksilver remains in favour of burning evaluate because it is semantically uncertain and appears to be un-necessary.
04:55:47 <gmux> http://apod.nasa.gov/apod/
04:55:52 <gmux> woops, misfire
05:26:52 <mchase> hi i am trying to get running with ghc 10.4 and cabal install, however it looks like the bootstrap.sh script expects the Network package to be installed (and possibly some others, I don't know)
05:27:28 <quicksilver> I suggest to start with an appropraite haskell platform pacakge
05:27:29 <mchase> do people just download and install the dependencies needed by cabal install manually, or is that script supposed to just work?
05:28:38 <mchase> quicksilver: is that what is typically done? that package seems kind of poorly organized and includes a lot of things i don't need
05:29:09 <sohum> is there a way to trace error locations? hat refuses to build, and loch doesn't seem to work.
05:29:50 <Veinor> mchase: you have to manually install the network package
05:30:12 <mchase> Veinor: is that the only package you have to manually install?
05:30:25 <Veinor> if you're on ubuntu or debian you can sudo apt-get install libghc6-network-dev
05:30:36 <quicksilver> the haskell platform is intended to supersede boostrap.sh I think
05:30:47 <quicksilver> and become the main way to get a working base for cabal-install
05:31:01 <quicksilver> what causes you to describe it as "poorly organized" ?
05:31:08 <ivanm> quicksilver: well, because cabal -install is -part_ of the platform ;-)
05:31:22 <quicksilver> ivanm: yes, but it is supposed to be the main way to get cabal-install.
05:31:28 <Veinor> I think you also need zlib
05:31:29 <quicksilver> ivanm: not merely happen to include it.
05:31:43 <Veinor> which presumably you can get in libghc6-zlib-dev
05:32:18 <ivanm> quicksilver: well, for people who don't have linux distros that have decent haskell support maybe...
05:32:38 <mchase> Veinor: what if i am on mac? just manually install network?
05:33:37 <mchase> quicksilver: i guess i just want a little more control over what i install, and what goes where, than the haskell platform provides
05:34:02 <mchase> if that is really the standard thing that the haskell pros use then i could do that :)
05:34:15 <quicksilver> that doesn't appear to match the phrase "poorly organized"
05:34:19 <quicksilver> :P
05:34:52 <quicksilver> I speak from hearsay and ignorance; I've never installed the platform, or cabal-install, and I hardly use libraries
05:34:58 <quicksilver> but I'm not the typical haskell user I guess
05:35:16 <ivanm> :o
05:35:22 <ivanm> quicksilver: you write everything from scratch?
05:35:24 <Veinor> I wouldn't know about macs, sorry :/
05:35:36 * ivanm uses cabal-install just to test his own libraries and programs
05:35:44 <ivanm> and I don't have the platform installed
05:35:50 <ivanm> if I need a new library, I create a new ebuild
05:36:06 <mchase> ivanm: how did you bootstrap cabal install?
05:36:22 <ivanm> mchase: I installed it via ebuild
05:36:26 <ivanm> i.e. system package
05:36:39 <ivanm> mchase: * ivanm uses cabal-install just to test his own libraries and programs
05:36:46 <ivanm> i.e. not to install other libraries and programs
05:36:59 <mchase> ivanm: i see
05:37:46 <mchase> so, has anyone bootrapped cabal install on a platform other than a supported linux, and if so how did they do it? just download and install manually?
05:38:11 <mchase> or is this a crazy thing to do, just use the haskell platform?
05:38:32 <ivanm> mchase: I bootstrapped it on fedora once though...
05:38:47 <ivanm> (before they had packages for it)
05:39:15 <Veinor> Whoa.
05:39:24 <mchase> ivanm: did you just have to manually install network and zlib?
05:39:40 <ivanm> mchase: OK, here's the reason why you do:
05:39:56 <ivanm> ghc used to ship with what's known as the extralibs packages, which most distributions included in their ghc installs
05:40:04 <ivanm> network and zlib used to be part of them IIRC
05:40:18 <ivanm> they're now part of the initial version of the haskell platform, and extralibs is no more
05:40:45 <ivanm> however, the bootstrap script was written assuming that the user had extralibs installed, and hasn't been updated yet
05:41:06 <ivanm> as such, if there's a platform install for your system, it might be easier to install that
05:41:28 <mchase> ivanm: i see
05:41:38 <Veinor> on a related note, I have a fresh Ubuntu install. what's the best way for me to get 6.10 on it?
05:41:50 <ivanm> Veinor: debian has the platform available IIRC
05:41:56 <Veinor> oh hey, yeah.
05:42:15 <Veinor> it doesn't have cabal-install though.
05:42:44 <ivanm> Veinor: :o
05:42:48 <ivanm> then it can't be the platform!
05:42:54 <mchase> ivanm: do you know if the bootstrap.sh is being updated, or is the platform how things will be done in the future
05:42:55 <Veinor> indeed
05:43:07 <Veinor> it has ghc and ghci
05:43:32 <ivanm> mchase: I heard talk about updating the bootstrap.sh
05:43:43 <ivanm> mchase: which cabal install are you trying to install?
05:44:07 <mchase> i kind of just wish "the platform" was just ghc, network, zlib, cabal, and cabal-install, and you could then just cabal-install anything you wanted trivially
05:44:22 <ivanm> ummm.... that's against the whole point
05:44:24 <temoto> Suppose, i've written a class Foo method foo, like Arrow pure: it has an argument (a b c) which, for specialization of Foo (->) is called where foo is called with a function argument.
05:44:30 <ivanm> besides, cabal-install needs other libs than just network and zlib
05:44:35 <Veinor> so should I just install http://hackage.haskell.org/platform/2009.2.0.2/haskell-platform-2009.2.0.2.tar.gz then?
05:44:36 <ivanm> (that's the point of the bootstrap script)
05:44:50 <ivanm> Veinor: that looks like a source tarball to me...
05:44:51 <temoto> So the question is, can i use arguments of that function in my implementation of foo?
05:45:04 <Veinor> or... yeah, i think I'll just install network and zlib from repos and then cabal-install everything else.
05:45:14 <mchase> ivanm: i guess i should say, i wish there was just something you could download that had the absolute minimum number of packages needed for working cabal install :)
05:45:16 <temoto> in other words, for instance Foo (->) can i write method
05:45:26 <temoto>   foo (\x -> y) = ...
05:45:45 <temoto> naive way didn't compile
05:45:52 <ivanm> @ask dcoutts is there any work being done on having the bootstrap script from cabal-install work from a plain ghc install?
05:45:52 <lambdabot> Consider it noted.
05:46:59 <Veinor> ... okay, what the hell
05:47:06 <Veinor> it's freezing on the 'linking setup' step.
05:47:31 <mchase> ivanm and Veinor and quicksilver - thanks all you guys for the help :)
05:47:42 <ivanm> no worries
05:47:52 <Veinor> hm.
05:48:40 <Veinor> okay, the linker appears to be hanging
05:48:59 <Veinor> and... using up a lot of ram. damn.
05:49:29 <Veinor> I think linking this just might require more ram than I have.
05:50:15 <temoto> Veinor: that's normal case for large C++ projects.
05:50:18 <Veinor> let's see if 512 helps.
05:50:28 <Veinor> hooray virtual machines.
05:50:34 <temoto> yeah
05:51:06 <Veinor> maybe I could get the admin to give me a temporary extra gig? <:]
05:51:40 <temoto> Could anyone enlighten about class instances on functions? the instance Foo (->) thing 20 lines upper
05:52:35 <Alpounet> @google Arrows
05:52:37 <lambdabot> http://www.eastonarchery.com/
05:52:37 <lambdabot> Title: Easton Archery | Home
05:52:39 <Alpounet> hmm
05:52:41 <Alpounet> no.
05:52:50 <quicksilver> temoto: what kind of enlightenment do you seek?
05:52:53 <Alpounet> temoto, http://www.haskell.org/haskellwiki/Arrow
05:53:01 <Alpounet> it's a good starting point.
05:53:09 <quicksilver> temoto: (->) is a binary type constructor. As such you can make it an instance of certain classes like any other type constructor
05:53:16 <Alpounet> Veinor, it's just about generalizing/abstracting the notion of "function".
05:53:55 <Veinor> yeah, 512MB is enough. so far, at least.
05:54:57 <endojelly> isn't there an inconsistency as soon as every type constructor is injective?
05:55:37 <endojelly> my project advisor explained this to me
05:56:14 <quicksilver> I would rather think there would be an inconsistency if they *weren't* injective.
05:56:24 <quicksilver> but since they're constructors, they're injective by construction.
05:56:48 <endojelly> (Set -> Set) -> Set
05:57:06 <endojelly> with -> being injective, that means that every function Set -> Set is contained in Set.
05:57:09 <endojelly> which is bad
05:57:17 <endojelly> or at least that's how i understood it.
05:57:23 <endojelly> it's concerning the agda people right now
05:57:42 <endojelly> there's a proof for absurdity using that kind of thing.
05:59:41 <trzkril> endojelly: the injection if from (Set -> Set)  to (Set -> Set) -> Set, isn't it?
06:00:00 <endojelly> trzkril, seems like. you can use cantor's diagonalization argument
06:00:04 <sohum> I'm using :trace main in ghci, and it looks like it's not giving me breakpoints inside a certain one of my file
06:00:07 <sohum> s
06:00:24 <quicksilver> endojelly: doesn't sound relevant to the notion of making (->) an instance of a typeclass.
06:01:06 <Taejo> endojelly: when you say (->) is injective, it means (a -> b) is the same type as (c -> d) if and only if a and c are the same type and b and d are the same type
06:01:33 <Taejo> it doesn't mean a function of type (Set -> Set) -> Set must be injective
06:01:50 <mattam> quicksilver: if there was an inconsistency if they weren't injective you could have it if they were too.
06:02:01 <MissPiggy> 05:54:57 <endojelly> isn't there an inconsistency as soon as every type constructor is injective?
06:02:11 <MissPiggy> endojello maybe he reads the agda/coq mailing list?
06:03:38 <Saizan> if you define "data I : (Set -> Set) -> Set where" and you assume that I is injective you've an inconsistency only if you add impredicativity or excluded middle
06:03:56 <Saizan> that's what i gathered from the agda thread at least :)
06:04:02 <mattam> Saizan: right
06:04:33 * MissPiggy is not sure if that is what they are actually talking about though ?
06:05:29 <endojelly> quicksilver, no, I wasn't referring to that
06:05:44 <endojelly> MissPiggy, I do, but only very casually and I don't understand most of it %)
06:06:33 <endojelly> Saizan, ah. do you know why or should I look for that thread again?
06:06:37 <endojelly> brb
06:06:50 <Alpounet> @src returnA
06:06:50 <lambdabot> returnA = arr id
06:06:59 <dino-> :t flip id
06:07:00 <lambdabot> forall a b. a -> (a -> b) -> b
06:07:22 <dino-> Huh, I was expecting that to be :: a -> (a -> a) -> a
06:07:39 <idnar> @type id
06:07:40 <lambdabot> forall a. a -> a
06:07:41 <idnar> @type flip
06:07:42 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
06:07:48 <Saizan> endojelly: afaiu, you need one of the two to prove that the inverse is surjective so that you can use the constructive version of cantor diagonalization
06:07:56 <idnar> ergh, not that flip
06:08:01 <idnar> @type Prelude.flip
06:08:02 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
06:08:09 <Alpounet> :t Prelude.flip id
06:08:10 <lambdabot> forall b c. b -> (b -> c) -> c
06:08:44 <Saizan> endojelly: since in intuitionistic logic a function that is injective doesn't automatically have a left inverse
06:08:59 <Saizan> or, well, in agda at least
06:09:09 <endojelly> Saizan, oooh, ok
06:09:31 <dino-> Seems like a and b shouldn't be able to be different types because of id here.
06:09:38 <Alpounet> idnar, I guess it's normal, since id normally takes one argument, bure here flips wants a function with two args, thus the type given by lambdabot
06:09:54 <idnar> Alpounet: tell dino, I guess :P
06:09:55 <endojelly> Saizan, thanks!
06:09:57 <Alpounet> hmm
06:10:05 <idnar> dino-: the type of id here is (a -> b) -> (a -> b)
06:10:06 <Alpounet> dino-*, yep, sorry.
06:10:28 <Alpounet> it's not id over "order 0 functions", but order 1
06:10:32 <Alpounet> because of flip's type signature.
06:10:48 <idnar> ie. it's really ($)
06:10:59 <Alpounet> yeah
06:11:06 <idnar> (or at least, I find it easier to think of it like that)
06:11:08 <dino-> hmm. I was manipulating the types kind of from the other direction. flip :: ((a -> a) -> a -> a) -> a -> (a -> a) -> a
06:11:47 <idnar> dino-: yeah, but it's (a -> b) -> a -> b not (a -> a) -> a -> a
06:12:21 <dino-> But with id a and b can't be different types.
06:12:30 <Alpounet> dino-, just try to find a constraint that asks for a -> a and not a -> b, you won't
06:12:31 <idnar> dino-: why not?
06:12:44 <Alpounet> it's id over functions
06:12:48 <Alpounet> not just dumb values
06:12:53 <idnar> dino-: maybe reusing a here is confusing the issue
06:12:54 <Alpounet> because of flip's type.
06:13:25 <dino-> Yes, I was working this out with new letters for each function.
06:13:31 <idnar> let id :: a -> a, flip :: (b -> c -> d) -> c -> b -> d
06:13:43 <dino-> Basically I was trying to type out foldl (flip id) myself.
06:13:58 <dino-> What it does is amazing, but tricky types to me.
06:14:20 <Alpounet> idnar, id here is id :: (b -> c) -> (b -> c)
06:14:30 <Alpounet> (that is, a is b -> c
06:14:31 <Alpounet> )
06:14:33 <dino-> I see what you mean
06:14:36 <idnar> Alpounet: yes, getting there
06:14:48 <Alpounet> damn, sorry idnar
06:14:55 <Alpounet> I meant dino-*
06:15:05 <nainaide> Does HAppS stop development ?
06:15:18 <dino-> nainaide: It's continued in the happstack project now.
06:15:42 <nainaide> dino-,  thanks!
06:16:34 <dino-> I see what you're saying, not just dumb values.
06:16:56 <dino-> thanks!
06:17:22 <idnar> so we need (a -> a) to unify with (b -> c -> d); that gives us a = b and a = c -> d
06:17:48 <idnar> thus b = c -> d; flip id :: c -> (c -> d) -> d
06:18:13 <endojelly> > let x = 1
06:18:14 <lambdabot>   not an expression: `let x = 1'
06:18:16 <Alpounet> the 'c' arg is given by foldl's initial accumulator
06:18:33 <Alpounet> and the c -> d are the functions contained in the list
06:19:00 <idnar> > foldl (flip id)
06:19:01 <lambdabot>   ()->
06:19:01 <lambdabot>    {[]->();[{()->()}]->();[{()->()},{()->()}]->();[{()->()},{()->()},{...
06:19:05 <idnar> oops
06:19:10 <endojelly> @let x = 1
06:19:11 <lambdabot>  Defined.
06:19:12 <endojelly> > x
06:19:13 <lambdabot>   Ambiguous occurrence `x'
06:19:13 <lambdabot>  It could refer to either `L.x', defined at <local...
06:19:15 <idnar> > foldl (flip id) [f,g,h] x
06:19:16 <endojelly> ah, nice.
06:19:16 <lambdabot>   Ambiguous occurrence `x'
06:19:16 <lambdabot>  It could refer to either `L.x', defined at <local...
06:19:21 <idnar> eek
06:19:27 <idnar> @undef
06:19:29 <idnar> > foldl (flip id) [f,g,h] x
06:19:30 <lambdabot>   Couldn't match expected type `[[t] -> [t]]'
06:19:30 <lambdabot>         against inferred type `...
06:19:47 <idnar> > foldl (flip id) x [f,g,h]
06:19:48 <lambdabot>   h (g (f x))
06:19:58 <endojelly> there seems to be no flip ($) in the standard library
06:20:04 <endojelly> this would allow me to do shell-like piping:
06:20:07 <Alpounet> > foldl (flip id) 4 [(+1), (+2), (+3)]
06:20:08 <lambdabot>   10
06:20:14 <endojelly> @let (|$) = flip ($)
06:20:15 <lambdabot>  Defined.
06:20:21 <endojelly> > [4, 3, 2, 9, 9] |$ sort |$ filter (> 3) |$ head
06:20:22 <lambdabot>   4
06:20:23 <idnar> @hoogle (b -> a) -> a -> b
06:20:24 <lambdabot> Data.Generics.Schemes everywhere :: (a -> a) -> a -> a
06:20:24 <lambdabot> Data.Generics.Schemes everywhere' :: (a -> a) -> a -> a
06:20:24 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
06:20:54 <idnar> > sort . filter (> 3) . head $ [4, 3, 2, 9, 9]
06:20:55 <lambdabot>   No instance for (GHC.Num.Num [a])
06:20:55 <lambdabot>    arising from the literal `4' at <inter...
06:21:19 <idnar> ...oh
06:21:37 <idnar> nevermind
06:21:49 <Alpounet> can we have fusion done by ghc with (|$) or can't it just happen with the (.) approach ?
06:21:52 <Alpounet> can*
06:22:16 <endojelly> Alpounet, hm? what do you mean?
06:22:21 <endojelly> Alpounet, maybe you meant this?
06:22:27 <endojelly> @let (.$) = flip (.)
06:22:28 <lambdabot>  Defined.
06:22:57 <endojelly> > [4, 3, 2, 9, 9] |$ (sort .$ head)
06:22:58 <lambdabot>   2
06:23:48 <Alpounet> endojelly, I mean the mechanism that removes intermediary results and just apply the whole function composition resulting function to the input
06:24:05 <Alpounet> applies*
06:24:21 <endojelly> Alpounet, as an optimization? that should still work
06:24:28 <endojelly> flip is pretty trivial to optimize away
06:24:44 <Alpounet> yeah
06:25:04 <Alpounet> in case it doesn't apply, a rewrite rule should fix that
06:26:09 <endojelly> [4, 3, 2, 9, 9] |$ sort evaluates to (flip $) [4, 3, 2, 9, 9] sort which immediately evaluates to ($) sort [4, 3, 2, 9, 9] which is just sort [4, 3, 2, 9, 9]
06:26:13 <mchase> where exactly do the libraries go when you cabal install them?
06:27:34 <kamatsu> mchase: if you're not running as root, ~/.cabal
06:27:53 <mchase> kamatsu: cool
06:28:09 <mchase> i just cabal installed cabal-install, and it put something in ~/.cabal/bin
06:28:19 <kamatsu> right
06:28:24 <kamatsu> add that to your $PATH
06:28:24 <mchase> should i just put that on my path and replace the one i am currently using?
06:28:30 <kamatsu> yes
06:28:38 <mchase> okay cool
06:31:21 <quicksilver> Alpounet: small functions like flip and |$ get inlined immediately
06:31:33 <quicksilver> Alpounet: which means that, in principle, the optimisation rules like fusion can 'see through' them
06:31:44 <quicksilver> however I think it's possible to tie yourself in knots with the phase control stuff
06:31:49 <quicksilver> and break the RULES
06:32:09 <Alpounet> quicksilver, ok thank you
06:32:45 <Alpounet> (really, can't you package yourself ? I'd love to have my own quicksilver copy in trains & planes)
06:35:38 <dino-> :t foldl (flip id)
06:35:39 <lambdabot> forall a. a -> [a -> a] -> a
06:37:00 <Veinor> @src flip
06:37:01 <lambdabot> flip f x y = f y x
06:38:04 <yottis> foldl (flip id) is sort of a unmonadic sequence?
06:38:05 <Veinor> I'm trying to figure out how flip id works.
06:38:50 <opqdonut> yottis: it's kinda like a simpler version of sequence in the state monad
06:39:53 <gwern> > 850 / 280
06:39:53 <lambdabot>   3.0357142857142856
06:39:53 <lambdabot> gwern: You have 1 new message. '/msg lambdabot @messages' to read it.
06:40:18 <gwern> @messages
06:40:18 <lambdabot> dons said 10h 10m 18s ago: hlist doesn't build with 6.12
06:40:43 <gwern> dons: I suspected as much, but I don't have 6.12 so I willn't be fixing it anytime soon
06:40:47 <yottis> opqdonut: without the state monad :)
06:41:04 <mattam> endojelly, quicksilver, Saizan: encoding of the paradox in Haskell: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16653#a16654
06:41:05 <opqdonut> yes, yes
06:41:22 <yottis> or rather without a state and without a monad
06:41:55 <opqdonut> well the "state" flows through the functions in the list left-to-right
06:42:18 <mattam> It loops at type checking interestingly. I'm not sure why.
06:42:38 <opqdonut> State s () is isomorphic to s->((),s) which is isomorphic to s->s
06:44:22 <Kruppe> is there a limit to the number of pattern matches you can have for a function?
06:44:38 <fasta> Kruppe, yes.
06:44:53 <fasta> Kruppe, the time you want to wait for your compiler to finish.
06:44:56 <Kruppe> fasta: guessing its about 10
06:45:03 <Kruppe> fasta: oh
06:45:13 <fasta> Kruppe, that's another way of saying no :)
06:45:17 <Kruppe> fasta: im getting a warning now about pattern matches overlaying
06:45:25 <endojelly> mattam, nice!
06:45:25 <Kruppe> fasta: when i remove ANY of them
06:45:26 <opqdonut> > execState (sequence_ [get >>= put.(+2), get >>= put.(*3)]) 1
06:45:27 <lambdabot>   9
06:45:29 <yottis> well, i guess function application is isomorphic to a whole pile of things that don't affect the function application in any way
06:45:31 <fasta> Kruppe, then probably they are overlapping.
06:45:31 <Kruppe> fasta: i dont get the error
06:45:32 <opqdonut> > foldl (flip id) 1 [(+2),(*3)]
06:45:33 <lambdabot>   9
06:45:36 <opqdonut> yottis: see?
06:46:18 <Kruppe> fasta: I don't think they are though :(
06:46:36 <fasta> Kruppe, also, a warning is not an error and GHC is not infallible with giving warnings.
06:46:37 <yottis> yes, i was just trying to think functionally and not LARP imperative code execution
06:46:57 <Kruppe> fasta: ah ok, ill see if its actually capable of performing all the matches then
06:46:59 <fasta> Kruppe, if you want a better replacement for that warning, please port the Catch tool to GHC.
06:47:16 <idnar> > sequence [f, g, h] $ x
06:47:17 <lambdabot>   Ambiguous type variable `a' in the constraints:
06:47:17 <lambdabot>    `GHC.Show.Show a'
06:47:17 <lambdabot>      a...
06:47:29 <opqdonut> there's nothing unfunctional about the State monad :)
06:47:32 <idnar> hmm
06:47:32 <fasta> Kruppe, just think that the compiler is a stupid machine and that you have orders of magnitude more computational power ;)
06:47:46 <idnar> > sequence [(+1), (+2), (+3)] $ 0
06:47:47 <lambdabot>   [1,2,3]
06:48:16 <Kruppe> fasta: lol, i know compilers are fallable especially in terms of warnings
06:48:23 <idnar> > sequence [(+2), (*3)] 1
06:48:24 <lambdabot>   [3,3]
06:48:31 <Kruppe> fasta: what im making is actually an interpreter
06:48:33 <idnar> oh right
06:48:44 <idnar> wow, I'm really out of it
06:51:01 <yottis> opqdonut: im not sure there's anything unfunctional about c code either, if you think of every statement as a function manipulating state :P
06:51:37 <kamatsu> yottis: C is pretty far removed from the State monad
06:51:49 <kamatsu> yottis: with the State monad, you have to explicitly define what your state is ahead of time
06:52:09 <kamatsu> yottis: and the entire state is transformed with each step
06:52:25 <MissPiggy> everything, potentially, has a pure functional semantics
06:52:31 <kamatsu> this is true
06:52:37 <ddarius> fasta: It's not the the compiler is stupid so much as the compiler is lacking a lot of information that you, the programmer, have.
06:52:41 <yottis> yeah, i'm just twisting your arm(s) here with the thought that it's a matter of degree or pow
06:52:49 <MissPiggy> it is just that may be too low level an abstraction
06:54:02 <dino-> e:new
06:54:20 <dino-> And this would not be vim
06:54:50 <radsis> If you pattern match [] say say in suml [] xs=xs
06:55:03 <radsis> does [] match empty list?
06:55:13 <kamatsu> radsis: yes, but i don't get your example
06:55:35 <Kruppe> [] definately matches the empty list
06:56:33 <copumpkin> it only matches the empty list
06:57:19 <mreh_> It seems that if I want to output messages to a user going thorugh IO monad the actual order of evaluation is never anything like the order of the messages
06:57:36 <copumpkin> how do you output them?
06:57:42 <mreh_> putStrLn
06:57:51 <copumpkin> well, that tells me nothing about the order :P
06:58:40 <mreh_> well okay, do { putStrLn "Doing thing"; thing <- doThing }
06:59:55 <mreh_> doThing might have other messages to print too, but if thing is used later, doThing might not be evaluated until *a lot* later
07:00:20 <mreh_> it makes debugging IO code hard
07:00:35 <fasta> ddarius, fundamentally the problem is indeed information incompleteness. We should be building our compilers based on probabilistic hardware and probabilistic logic to get around that in 1-epsilon*100% of the cases. I don't know of a good formal system for that however. I have only heard people talk about it. Not an actual system which can represent higher-order logics like those of Coq etc.
07:00:43 <temoto> :t liftM
07:00:44 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
07:01:07 <temoto> strange type letters
07:02:39 <mreh> copumpkin: know what I'm talking about?
07:02:40 <temoto> quicksilver: yeah i can make instance Foo (->) with foo f, where f matches b -> c. But can i capture b argument and use it in my function foo?
07:03:24 <copumpkin> mreh: IO should be doing things in order
07:03:27 <temoto> quicksilver: as in instance Foo (->) where foo (f x) = g x ?
07:03:51 <mreh> copumpkin: because it's "strict", is that what people mean when they talk about IO?
07:04:04 <mreh> ...being strict
07:04:08 <copumpkin> mreh: just because effects are sequenced in order
07:04:30 <copumpkin> you aren't unsafePerformIO'ing anything anywhere are you?
07:04:33 <fasta> ddarius, that's probably the most interesting thing one can do in science right now. To write down very exactly what the rules of such a system would be.
07:04:44 <mreh> copupkin: heyyyl no
07:04:53 <mreh> copumpkin: :D
07:05:17 <mreh> "science"
07:05:36 <mreh> big up the scientific method yo'!
07:05:43 <copumpkin> mreh: something weird must be going on if they're printing out of order :P you using forkIO then?
07:05:50 <kamatsu> ah, the first year lecturer at my university pulled the old "To define recursion you must first define recursion"
07:05:51 <copumpkin> or interleaving stderr and -out?
07:06:09 <kamatsu> i promptly demonstrated to my first year class the Y combinator, and why he was wrong >_>
07:06:12 <zygoloid> mreh: are you unsafeInterleaveIOing somewhere?
07:06:14 <sclv> I just asked in ##phyisics, but maybe I'll have better luck here -- is it possible to provide a neat categorical treatment of Noether's theorem as a commutative diagram?
07:06:28 <mreh> copumkin: they're not out of order, something is looping indefinately, and I can't track it down, the code before the last message is all cool
07:06:50 <copumpkin> mreh: oh, I thought you said it was printing messages out of order :P
07:07:09 <copumpkin> sorry
07:07:20 <mreh> copumkin: that was just a general question about IO monad really
07:07:24 <copumpkin> hmm, so it's hanging? can you show us the relevant chunk of code?
07:07:41 <MissPiggy> If you want to define recursion you must first invent the universe
07:07:51 <copumpkin> IO should always be printing things in the order you tell it to :) unlike pure code, the order of effects is deterministic
07:07:53 <zygoloid> mreh: it sounds like your problem is that the pure value 'thing' is _|_, and you want that value forced at the point at which you invoke doThing?
07:08:36 <mreh> i'm not aware of any bottoms in my prog
07:09:02 <mreh> i have isolated the special case where i goes tits up
07:09:03 <mreh> i'll paste
07:11:52 <mreh> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16655#a16655 -- it's a Main module, so you can guess where to begin
07:12:09 <endojelly> can I force hoogle to obey the order of my type search?
07:12:25 <mreh> it's mostly arg processing boilerplate
07:12:27 <endojelly> i.e. I type in a -> b -> a and do not want any results b -> a -> a
07:12:51 <mreh> endojelly, it should show you the best matches first
07:13:04 <mreh> if it can't cant match the order exactly it approximates
07:13:04 <quicksilver> temoto: so f::b->c and you jsut apply it to a b like this : (f b)
07:13:08 <endojelly> mreh, hm, ok, then what I'm looking for just doesn't exist I guess
07:13:16 <radsis> anyone know what Illegal signature in pattern:     ...    Use -XScopedTypeVariables to permit it
07:13:19 <quicksilver> temoto: I can give a better example if you can tell me what your class actually does.
07:13:21 <radsis> means?
07:13:26 <endojelly> mreh, I thought it just ignores it completely
07:13:27 <mreh> endojelly: that's been my experience
07:13:53 <mreh> not generally
07:14:08 <mreh> it's trying to help you, if it looks like something but in the wrong order it'll show that aswell
07:15:03 <mreh> copumpkin: pasted
07:16:21 <copumpkin> mreh: okay, rather hard to help with something that big :P
07:17:13 <mreh> copumpkin: :)
07:17:36 <copumpkin> run it in the ghci debugger maybe?
07:17:54 <temoto> quicksilver: i'm just exploring the mysterious land of classes specialized on functions.
07:18:46 <mreh> copumpkin: I'm just driving down the possiblities of what it could be, I think with your help I've eliminated enough
07:18:57 <temoto> radsis: it means you can't use x::Type there.
07:19:01 <benmachine> radsis: things on the LHS of a lambda -> arrow or an equation are patterns, and aren't allowed type signatures in normal haskell
07:19:33 <quicksilver> temoto: OK, let me give you an example. class Foo x where foo :: x a b -> [a] -> [b]
07:19:49 <quicksilver> temoto: instance Foo (->) where foo f xs = map f xs
07:19:55 <quicksilver> temoto: does that help?
07:20:06 <ziman> (q'q) >- (ɐ'ɐ) >- (q >- ɐ) ǝlƃooɥ
07:20:17 <copumpkin> ziman: backwards
07:20:22 <ziman> argh, i need to turn the script off
07:20:22 <benmachine> -<?
07:20:25 <copumpkin> <-
07:20:32 <ziman> @hoogle (a -> b) -> (a,a) -> (b,b)
07:20:33 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
07:20:33 <lambdabot> Data.Graph.Inductive.Query.Monad mapSnd :: (a -> b) -> (c, a) -> (c, b)
07:20:33 <lambdabot> Data.Graph.Inductive.Query.Monad mapFst :: (a -> b) -> (a, c) -> (b, c)
07:20:35 <copumpkin> failscript
07:20:40 <benmachine> radsis: you can usually give type signatures to something else to achieve the same effect
07:21:03 <MissPiggy> lol you have a script that turns stuff upside down if it's got an @ at the start
07:21:26 <radsis> can you say add _ 0 = _, ie put match all on right side
07:21:46 <dino-> So, when we get the type of foldl (flip id), the types are all the same because that needs to be the case for the fold, not the flip id
07:21:49 <temoto> quicksilver: does (f xs) correspond to ((->)a) in instance?
07:22:14 <ziman> MissPiggy, yeah...
07:22:24 <quicksilver> temoto: no.
07:22:30 <quicksilver> temoto: you're confusing values and types, perhaps?
07:22:39 <temoto> yeah i just got it
07:22:39 <quicksilver> temoto: f is a function.
07:22:47 <quicksilver> temoto: I just use 'map' on f, because I can.
07:23:02 <benmachine> radsis: you can't do that with _ because _ says I'm not going to use this
07:23:19 <benmachine> but you can do it with any normal identifier
07:23:24 <benmachine> like add a 0 = a
07:23:45 <temoto> quicksilver: (f xs) correspond to the whole (a -> b) [a]
07:23:56 <radsis> benmachine++
07:24:37 <temoto> quicksilver: i wonder if it's possible to capture argument of f, but your example seems to do this.
07:25:38 <temoto> quicksilver: no it doesn't.
07:25:50 <aep> how do i loop over the contents of a file, if i have no loops?
07:26:24 <benmachine> aep: recursion, folding, mapping
07:26:31 <benmachine> are three things that are vaguely related
07:26:39 <benmachine> question is why do you want to loop?
07:26:43 <aep> well, i have no list to operate on either
07:26:52 <benmachine> get one then?
07:26:53 <aep> because the format of the file requires it
07:27:10 <benmachine> this is not a complete question
07:27:12 <aep> hGetContents doesn't work here
07:27:21 <aep> true, let me explain
07:27:50 <aep> i have a file in the format   FOO:\nBAR\n\nBAZ:\nBLA
07:27:54 <temoto> quicksilver: you defined a foo method which accepts a function (a -> b) and [a]. (+10) is a valid such function so i wonder if it's possible to use 10 in foo.
07:28:33 <quicksilver> temoto: going back a bit, "capture the argument of f" doesn't seem to make sense
07:28:39 <quicksilver> temoto: f doesn't have an argument per se
07:28:49 <quicksilver> temoto: you *give* f an argument each time you call it
07:28:50 <aep> and i need to parse that into a structure of some sort. i did just use  hGetContents  and dropWhile, which isnt the correct solution either, but it worked, until it run out of file descripors
07:28:54 <quicksilver> (perhaps I different one each time)
07:29:13 <benmachine> aep: so openFile and hGetLine?
07:29:30 <aep> well that would require a loop of some sort to find the relation between the lines
07:29:42 <temoto> quicksilver: yeah i just realized that the argument is in future.
07:29:44 <benmachine> do not follow
07:30:03 <temoto> quicksilver: the whole thing doesn't make sense then.
07:30:18 <benmachine> (you might be able to modify your use of hGetContents to not run out of file descriptors, instead, but lazy IO always seemed untidy to me)
07:30:35 <temoto> Too bad, it would be cool to travel back in evaluation via instances of (->)
07:30:36 <aep> benmachine: in C i would do: string key,value; bool m=false;  while(l=readline){if(m){m=false;value=l;}else{m=true;key=l;}
07:31:11 <benmachine> hmm
07:31:16 <aep> ie alternate between key and value and stick the current line in that
07:31:49 <aep> now haskell has neither loops, nor references, nor hash tables
07:31:52 <aep> so i'm lost
07:32:00 <benmachine> hash tables?
07:32:07 <benmachine> if you want a lookup structure you have Map
07:32:08 <pozic> aep: you might want to put a real example with a real output or preferably a formal specification of your problem on some paste site.
07:32:10 <arw> Data.Map i guess.
07:32:10 <aep> maps, dicts, whatever you call them.
07:32:17 <temoto> objects
07:32:17 <aep> pozic: will do
07:32:26 <aep> benmachine: ah cool, that helps a little
07:32:51 <temoto> quicksilver: thanks for explanation.
07:33:18 <benmachine> your problem with the lines and etc, I think a couple of mutually recursive IO actions would do the trick
07:33:24 <aep> pozic: thats the actual file: http://codepad.org/Ti0txadj
07:33:26 <benmachine> depending on what you wanted to do with the data afterwards
07:33:39 <aep> well i need them in some sort of lookup structure
07:34:00 <pozic> aep: and you want to create a corresponding record from that?
07:34:05 <aep> mostly for display, comparison of fields, etc
07:34:09 <aep> pozic: yes
07:34:19 <pozic> aep: that is an in memory representation of that file.
07:34:38 <aep> kindof, yes
07:34:39 <pozic> aep: you just define a data type which can hold that isomorphic to a C struct,.
07:34:45 <aep> i did
07:35:01 <aep> i am just clueless how to actually parse it
07:35:08 <pozic> aep: then while parsing (use e.g. Parsec), you do things like:
07:35:20 <quicksilver> aep: haskell has loops, and references, and even hashtables although we prefer to use other associative structures.
07:35:33 <benmachine> something like parsec would probably be good
07:35:41 <benmachine> hmm
07:35:53 <benmachine> would it? I don't remember if parsec can operate directly on files
07:35:57 <pozic> parse_name current_record = do string "%name";newline; and then something involving many and anyChar or something like that.
07:36:07 <aep> yeah well, parsec is quite complex.  the file is trivial and since i am learning haskell, it might be a good idea to learn how to do this by hand
07:36:08 <McManiaC> is it possible to export haskell functions to C code?
07:36:16 <benmachine> parsec is really simple to use
07:36:21 <pozic> I don't see where the "has to work directly on files" comes from.
07:36:24 <benmachine> it's one of the better ways to learn haskell imo
07:36:28 <jmcarthur> temoto: pong?
07:36:44 <aep> McManiaC: yes, you can just link to them from C. requires nothing special
07:36:47 <benmachine> pozic: it doesn't necessarily come from anywhere except that I assume you don't want the whole file in memory at once
07:36:50 <pozic> I think it is just an artificial constraint introduced by certain standard way of approaching the problem in C.
07:36:54 * hackagebot upload: hTensor 0.5.0 - Multidimensional arrays and simple tensor computations. (AlbertoRuiz)
07:36:55 <benmachine> if you do then the task is simple
07:37:08 <McManiaC> aep: how?
07:37:26 <aep> McManiaC: just declare the function in your C code, and link the haskell module in
07:37:45 <benmachine> you need to foreign export
07:37:49 <McManiaC> aep: got any example?
07:37:50 <benmachine> and initialise the runtime
07:37:55 <benmachine> it's not that simple iirc
07:38:00 <benmachine> but I've never done it
07:38:07 <McManiaC> #include "Stuff.hs" // won't do it I guess
07:38:07 <McManiaC> :>
07:38:09 <lunabot>  luna: Not in scope: `include'
07:38:09 <fasta> McManiaC, it is not a matter of Just Works.
07:38:09 <aep> right, i only linked C code into a haskell main
07:38:23 <aep> which is trivial
07:38:27 <fasta> McManiaC, but the updated documentation in Trac is correct and shows how you do it.
07:38:42 <fasta> McManiaC, so, it is a solved problem.
07:39:11 <McManiaC> fasta: got a link?
07:39:20 <aep> i can't believe parsing that simple file is so hard in haskell. something must be wrong with my thinking
07:40:02 <fasta> McManiaC,  what is documented here http://gamr7.com/blog/?p=66 also explains it.
07:40:08 <benmachine> it's not that hard, aep
07:40:19 <aep> well, then how do i do it? :D
07:40:20 <temoto> jmcarthur: hello, i was investigating that instance (->) stuff you mentioned yesterday, quicksilver helped me to get through it.
07:40:20 <benmachine> it's very easy if you can read the entire file into memory before starting
07:40:28 <benmachine> it's only slightly more difficult if you can't
07:40:31 <aep> i can. it's small
07:40:49 <doserj> aep: are you looking for sth like: let f (a:b:c:xs) = (a,b):f xs; f _ = [] in f . lines <$> readFile
07:40:59 <temoto> jmcarthur: so this is possible with Num and other types not requiring Show class or if we define a show instance for functions?
07:41:09 <fasta> aep, your problem is not even mathematically trivial ;)
07:41:10 <McManiaC> fasta: ok thx
07:41:27 <fasta> McManiaC, tell me whether you can understand that please.
07:41:46 <aep> doserj: ok i have no idea what that is. i'll go have to look it up.  whats <$> ?
07:41:58 <benmachine> <$> is another name for fmap
07:42:02 <jmcarthur> temoto: you can lift any instance of Applicative to a lot of other classes this way
07:42:03 <aep> ah thanks
07:42:08 <benmachine> it's often more convenient to use fmap infix
07:42:17 <copumpkin> really? I don't enjoy that
07:42:30 <fasta> I just use (.) = fmap, as Cale suggested a long time ago.
07:42:40 <benmachine> I did that for a while
07:42:46 <benmachine> but decided that <$> was less confusing
07:42:47 <jmcarthur> temoto: for example, besides some of the weird requirements, you could make an instance Num a => Num (Maybe a)
07:42:47 <fasta> Away are all the liftMs.
07:42:55 <benmachine> also works better with <*>
07:43:06 <jmcarthur> i suppose you could even do Eq and Show properly there...
07:43:43 <temoto> jmcarthur: i can't imagine such type.
07:44:02 <edwardk> temoto: that transform works for basically any monad or applicative
07:44:03 <temoto> Maybe Num makes sense, Num Maybe doesn't.
07:44:16 <copumpkin> Num a => Maybe a makes sense
07:44:27 <aep> hm what does "in" do?
07:44:29 <copumpkin> Num (Maybe a) makes sense
07:44:30 <copumpkin> :P
07:44:41 <edwardk> you run into some limitations with reader and state because of the silly Show requirements
07:44:44 <copumpkin> Maybe (forall a. Num a => a)
07:44:49 <quicksilver> temoto: you're wrong. Maybe Num doesn't make any sense.
07:44:55 <copumpkin> those are the combinations I can think of
07:45:03 <fasta> aep, there are these things called books. Maybe you have heard of those?
07:45:04 <quicksilver> temoto: 'Maybe' is a type constructor but Num is a class.
07:45:08 <copumpkin> the last one requires impredicative polymorphism though
07:45:10 <temoto> quicksilver: i meant Num a => Maybe a
07:45:11 <quicksilver> temoto: Num a => Maybe a
07:45:14 <Jonno_FTW> right back from work now
07:45:19 <quicksilver> temoto: but that's quite different.
07:45:25 <quicksilver> an instance header is not a type, anyway.
07:45:36 <quicksilver> Num (Maybe a) would be nonsense as a type
07:45:37 <aep> fasta: i've read a couple in fact :P
07:45:50 <quicksilver> as an instance header it says "we are currently declaring Maybe a to be an instance of Num"
07:45:51 <aep> but i get the hint
07:45:57 <copumpkin> quicksilver: that could also be a type
07:46:05 <copumpkin> moo :: Num a => Maybe a -> ??
07:46:09 <edwardk> Num isn't a particular type. Int, Float, etc. are types. Num is a class constraint. (Num a => a) is a type that indicates that a is any type that has an instance for Num. Maybe a is a type, which consists of values Just x and Nothing where x is any member of type a. (Num a => Maybe a) is a type where
07:46:22 <benmachine> aep: in goes with let
07:46:28 <benmachine> > let x = 4 in x
07:46:29 <lambdabot>   4
07:46:29 <jmcarthur> temoto: i threw this together for you. i haven't even type checked it http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16656#a16656
07:46:47 <copumpkin> moo :: Num (Maybe a) => ???? -- with flexible contexts I think
07:46:51 <jmcarthur> temoto: but that *should* work
07:47:06 <edwardk> (Num a => Maybe a) is a type where you have members Just x and Nothing where x is a member of type a, and where you know that that type supports the operations common to all Num instances.
07:47:27 <quicksilver> copumpkin: yes, but Num (Maybe a) is nonsense AS A TYPE
07:47:32 <copumpkin> yeah :)
07:47:33 <quicksilver> copumpkin: which is what I said ;)
07:47:47 * aep facepalms
07:47:49 <copumpkin> lol
07:47:52 <aep> benmachine: yes, thanks
07:47:53 <quicksilver> as a context, sure.
07:47:58 <benmachine> do class constraints and types have different namespaces?
07:48:06 <edwardk> benmachine: nope
07:48:07 <benmachine> well, classes and types
07:48:17 <benmachine> would there be ambiguity if they did
07:48:23 <copumpkin> oddly, classes also have kinds, but you can't ask for their kind
07:48:25 <copumpkin> not sure why
07:48:27 <quicksilver> :t let f x = Just x + 1 in f
07:48:28 <lambdabot> forall a. (Num (Maybe a)) => a -> Maybe a
07:48:33 <quicksilver> copumpkin: there is your constraint.
07:48:35 <temoto> jmcarthur: ah that thing would allow stuff like sin + cos to be f x for Justs?
07:48:41 <copumpkin> quicksilver: yay
07:48:51 <edwardk> benmachine: theoretically not, though parsing becomes a bit trickier and more stuff gets deferred until you figure out that you have an => in there
07:48:53 <jmcarthur> temoto: huh?
07:49:04 <jmcarthur> temoto: it would let you do things like Just 5 + Just 4
07:49:11 <copumpkin> applicative numbers!
07:49:13 <benmachine> edwardk: oh, that's reasonable
07:49:42 <opqdonut> instance (Num a, Applicative f) => Num (f a) where (+) = liftA2 (+)
07:50:02 <copumpkin> it'd be nice to be able to ask :k Monad and get (* -> *) -> %
07:50:04 <quicksilver> edwardk: well, there is actually ambiguity
07:50:06 <copumpkin> or something
07:50:20 <edwardk> opqdonut: instance (Num a, Applicative f, Show (f a), Eq (f a)) => ...
07:50:20 <quicksilver> edwardk: in export/import lists ;)
07:50:30 <opqdonut> edwardk: oh bother :)
07:50:33 <edwardk> quicksilver: ah, yes
07:50:33 <temoto> jmcarthur: let f = sin + cos in f (Just 1.)   that's what i meant
07:50:41 <opqdonut> it'd be nice if classes were more integrated with the type system
07:50:55 <quicksilver> copumpkin: but that makes it look like Monad can be applied
07:51:01 <jmcarthur> temoto: oh, sure, you can do that too
07:51:23 <copumpkin> quicksilver: it can be, to get a valid class constraint... you can't write moo :: Monad => x -> y
07:51:24 <quicksilver> oh, I suppose your argument is that Monad can be "applied" in the language of type contexts
07:51:25 <jmcarthur> opqdonut: what do you mean?
07:51:26 <temoto> jmcarthur: that's totally magic :)
07:51:32 <edwardk> opqdonut: how?
07:51:35 <quicksilver> yes I see
07:51:36 <jmcarthur> temoto: no it's not :P
07:51:57 <McManiaC> aep: http://npaste.de/EQ/
07:52:09 <McManiaC> not that hard
07:52:09 <McManiaC> :>
07:52:12 <opqdonut> edwardk, jmcarthur: in some nice way
07:52:17 <opqdonut> i don't have the answers
07:52:18 <copumpkin> quicksilver: not sure what else you'd do with class kinds though :P I was mostly wanting it so you could do :k Monad and be informed that it expects a (* -> *), which otherwise may not be obvious
07:52:58 <benmachine> McManiaC: that looks odd
07:53:23 <temoto> jmcarthur: f + g leading to \x -> f x + g x   is magic for me. I see how it's nice and meaningful, but it's very hard to defer evaluation of f and g in my head.
07:53:30 <taruti> Is there a way to make a pinned ByteString ?
07:53:44 <benmachine> McManiaC: step has non-exhaustive patterns?
07:53:46 <temoto> taruti: pinned?
07:54:01 <taruti> temoto: "guaranteeded not to be moved by the GC"
07:54:04 <jmcarthur> temoto: you are thinking too operationally then ;)
07:54:13 <endojelly> :t (<*>)
07:54:14 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
07:54:21 <McManiaC> benmachine: hm yeh
07:54:30 <endojelly> > [(+1)] <*> [4]
07:54:31 <lambdabot>   [5]
07:54:38 <endojelly> > [(+1),(+2)] <*> [4,5]
07:54:39 <lambdabot>   [5,6,6,7]
07:54:39 <McManiaC> http://npaste.de/ER/ that should be better
07:54:40 <McManiaC> ^^
07:54:46 <jmcarthur> temoto: it gets even weird when you do it for lists
07:54:49 <jmcarthur> *weirder
07:55:01 <aep> McManiaC: thanks! for me it is. i guess it gets clearer when i fully understand fmap.. reading
07:55:05 <jmcarthur> @let (+^) = liftA2 (+)
07:55:06 <lambdabot>  Defined.
07:55:22 <temoto> ++?
07:55:26 <jmcarthur> > [1..3] +^ [2..5] +^ [6,7]
07:55:28 <lambdabot>   [9,10,10,11,11,12,12,13,10,11,11,12,12,13,13,14,11,12,12,13,13,14,14,15]
07:55:33 <endojelly> hmm. for the first time I have the impression that I actually intuitively grasp all that stuff about Applicative and Functor and (->) as instance of classes...
07:55:44 <McManiaC> aep: thats the same as do { cont <- readFile file; return (foldr step [] (lines cont)) }
07:55:53 <temoto> > [1,2] +^ [1,2]
07:55:55 <edwardk> endojelly: congrats =)
07:55:55 <lambdabot>   [2,3,3,4]
07:55:58 <jmcarthur> @let (*^) = liftA2 (*)
07:56:01 <lambdabot>  Defined.
07:56:02 <endojelly> edwardk, thanks %)
07:56:07 <jmcarthur> > [1..3] +^ [2..5] *^ [6,7]
07:56:09 <lambdabot>   [18,21,24,28,30,35,36,42,24,28,30,35,36,42,42,49,30,35,36,42,42,49,48,56]
07:56:45 <temoto> jmcarthur: that's Decart multiplication with (+) applied at each step, right?
07:57:21 <temoto> ×
07:57:28 <aep> McManiaC: that i understand!  thank you
07:57:36 <temoto> oh wait
07:57:53 <thaldyron> Is there a repository for the STM implementation presented in the latest issue of The Monad.Reader?
07:58:07 <temoto> @let (×) = liftA2
07:58:08 <lambdabot>  Defined.
07:58:09 <jmcarthur> temoto: it does the math for ever possible choice of elements from each list
07:58:16 <jmcarthur> *for every
07:58:24 <jmcarthur> temoto: and it returns a list of the results
07:58:35 <temoto> > [1,2] (× +) [1,2]
07:58:36 <lambdabot>   <no location info>: parse error on input `+'
07:58:44 <temoto> > [1,2] (× . +) [1,2]
07:58:45 <lambdabot>   <no location info>: parse error on input `.'
07:58:47 <jmcarthur> sorry that won't work at all
07:59:03 <jmcarthur> > (?) (+) [1,2] [1,2]
07:59:05 <lambdabot>   Not in scope: `?'
07:59:13 <jmcarthur> oh i don't know what you used in place of
07:59:14 <jmcarthur> ?
07:59:19 <jmcarthur> my client just shows "?"
07:59:34 <temoto> jmcarthur: http://en.wikipedia.org/wiki/Cartesian_product
07:59:43 <jmcarthur> temoto: kind of like that
07:59:52 <temoto> oh, it's called Decart product in russian
08:00:01 <zygoloid> > let (?) = liftA2 in (?) (+) [1,2] [1,2]
08:00:02 <lambdabot>   [2,3,3,4]
08:00:36 <zygoloid> > (×) (+) [1,2] [1,2]
08:00:37 <lambdabot>   [2,3,3,4]
08:00:39 <jmcarthur> > do x <- 1,2] ; y <- 1,2] ; return (x+y)
08:00:40 <lambdabot>   <no location info>:
08:00:40 <lambdabot>      The last statement in a 'do' construct must be an ...
08:00:48 <jmcarthur> > do { x <- 1,2] ; y <- 1,2] ; return (x+y) }
08:00:49 <lambdabot>   <no location info>: parse error on input `,'
08:00:51 <zygoloid> > ([1,2] × (+)) [1,2]
08:00:52 <lambdabot>   Couldn't match expected type `a -> b -> c'
08:00:52 <lambdabot>         against inferred type `[...
08:00:55 <jmcarthur> > do { x <- [1,2] ; y <- [1,2] ; return (x+y) }
08:00:57 <lambdabot>   [2,3,3,4]
08:01:02 <temoto> > let (×+) = (×) (+) in [1,2] ×+ [1,2]
08:01:03 <lambdabot>   [2,3,3,4]
08:01:07 <temoto> cool
08:01:14 <zygoloid> > ((+) × [1,2]) [1,2]
08:01:15 <lambdabot>   [2,3,3,4]
08:01:17 <pretsas> wait..
08:01:25 <pretsas> So when you <- from a list in a do statement
08:01:32 <jmcarthur> temoto: you realize you just redefined my +^ again, right?
08:01:38 <jmcarthur> pretsas: it picks one!
08:01:42 <pretsas> It extracts each value and runs whatever on it?
08:01:45 <temoto> jmcarthur: yes.
08:01:51 <jmcarthur> pretsas: and the result will be every possible choice :)
08:01:53 <pretsas> Aha
08:02:05 <temoto> jmcarthur: i actually wanted to try unicode operator :)
08:02:17 <jmcarthur> temoto: i just see "?" in place of it :P
08:02:37 <jmcarthur> i miss unicode in irc. haven't yet found a good way to have it using screen
08:02:44 <temoto> jmcarthur: sorry for that. I had to recompile weechat with libncursesw to support unicode chars.
08:02:52 <Zao> jmcarthur: Create screen with -U, have a suitable locale, pray.
08:02:56 <jmcarthur> temoto: oh! that's my problem i bet
08:03:00 <jmcarthur> temoto: i am also using weechat
08:03:36 * pretsas uses pidgin :D
08:03:56 <jmcarthur> i just like being able to keep a persistent session and connect to it from anywhere
08:04:25 <aep> can i pattern match a substring? something like  f "a\nb" = use a b  ?
08:04:44 <copumpkin> only a prefix
08:04:54 <copumpkin> and it's rather ugly
08:04:54 <aep> would work.
08:04:57 <aep> oh
08:05:26 <doserj> the recommended way is to use guards
08:05:28 <Kruppe> aep: not sure what your doing, but maybe guards are what your looking for
08:05:49 <aep> can guards do that?  i though you can just use the same expressions for mathing
08:05:55 <aep> *matching
08:06:18 <jmcarthur> aep: guards and an appropriate substring matching function can do it
08:06:36 <aep> is it less ugly? :D
08:06:59 <Kruppe> aep: yes in my opinion, depending on what your doing of course
08:07:18 <aep> old problem.  parsing a file  key\nvalue\nkey\nvalue
08:07:39 <xerox> jmcarthur /set charset.global.decode = UTF-8 (and if you use screen, you need screen -U)
08:07:40 <aep> i know the key, so i wonder if its better to match it directly
08:07:59 <jmcarthur> xerox: thanks. i'll try that
08:08:04 <aep> going to try guards, thanks.
08:08:13 <xerox> jmcarthur np, hope it works.
08:08:41 <aavogt> @type stripPrefix
08:08:43 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Maybe [a]
08:08:43 <fasta> Why are you recommending guards?
08:08:49 <temoto> Yay, pidgin works too.
08:08:54 <temoto> never knew that
08:09:43 <fasta> Guards look nice, but you cannot cut and copy them somewhere else as an expression.
08:09:52 <aavogt> nice with view patterns:
08:10:17 <Kruppe> fasta: what would be best then?
08:10:29 <jmcarthur> xerox: that property doesn't exist. i might have to follow temoto's suggestion before that's available or something. unfortunately, the box i'm running weechat on is an ubuntu box, and i don't really understand the arrangement of ubuntu packages or how to tell what options they are built with yet
08:10:43 <aavogt> , let f (stripPrefix "hello" -> Just rest) = map toUpper rest; f _ = "nothing" in f "helloooooo"
08:10:44 <lunabot>  "OOOOO"
08:10:46 <fasta> Kruppe, I don't like the if then else keywords in Haskell, so I use various vorms of if which are functions.
08:10:51 <aavogt> , let f (stripPrefix "hello" -> Just rest) = map toUpper rest; f _ = "nothing" in f "halloooooo"
08:10:52 <lunabot>  "nothing"
08:10:55 <jmcarthur> it's only ubuntu because i'm running xbmc on it for my tv
08:11:12 <fasta> Kruppe, but most of the time a real if, it's quite arbitrary.
08:11:21 <jmcarthur> i would use arch otherwise :\
08:11:29 <xerox> jmcarthur I skimmed the docs, and it says http://www.weechat.org/files/doc/weechat_faq.en.html#charset
08:11:50 <fasta> Kruppe, e.g. I have an if which takes a function and only applies it to the input when it is True and so on.
08:12:08 <Kruppe> fasta: like when in lisp?
08:12:14 <fasta> Kruppe, in some library I have an overloaded cond, which also works for monadic conditions and normal ones at the same time.
08:12:16 <fasta> Kruppe, yes.
08:12:23 <xerox> jmcarthur yours is 0.2.6.3 I thought it meant it was <= 0.2.6 but that might not be the case afterall
08:12:36 <Kruppe> fasta: i see
08:12:38 <fasta> Kruppe, er, no.
08:12:48 <Kruppe> fasta: oh
08:12:53 <fasta> Kruppe, when is already a function which operates on monads in Haskell.
08:13:18 <jmcarthur> xerox: thanks
08:13:29 <Kruppe> fasta: i said in lisp
08:13:41 <fasta> Kruppe, but that's also what when does in Lisp.
08:14:29 <fasta> Kruppe, hmm, or maybe not.
08:14:45 <fasta> Kruppe, yes, I suppose like 'when', when it is returning a function.
08:15:04 <Kruppe> fasta: alright :P
08:15:08 <Kruppe> fasta: ill take your word for it
08:18:26 <sclv> edwardk: by the way, do you know any cheap categorical approach to noether's theorem that doesn't require that I learn to understand lie groups?
08:19:14 <edwardk> sclv: hrmm not that comes to mind
08:20:58 <edwardk> you can get reasonably far with noether's theorem without understanding lie groups though, no?
08:22:01 <sclv> absolutely. but a categorial approach, with a nice commutitative diagram would be very satisfying to me.
08:22:24 <sclv> i'm just dabbling, really, and it seemed that noether's theorem was very much about parametricity and naturality, so i went looking
08:23:05 <edwardk> sclv: i think i get the rough feel of what you're looking for, but i haven't seen any derivation along those lines
08:23:53 <Pete2> Hello, I can't get wxHaskell to work. I try to run a test program in ghci but it says "Could not find module `Graphics.UI.WX'". What to do?
08:24:24 <sclv> the lie approach seems to be what baez' lecture notes (2008) build up to: http://math.ucr.edu/home/baez/classical/
08:24:37 <sclv> and it looks very cool, but somewhat beyond my ken.
08:24:53 <temoto> :t f $ g x
08:24:55 <lambdabot>     Ambiguous type variable `a' in the constraints:
08:24:55 <lambdabot>       `Show a' arising from a use of `f' at <interactive>:1:0
08:24:55 <lambdabot>       `SimpleReflect.FromExpr a'
08:25:09 <bastl> hi all.
08:25:16 <aavogt> where has the hlist repository gone? http://www.mail-archive.com/haskell-cafe@haskell.org/msg37270.html
08:25:29 <aavogt> it's not a c.h.o or d.h.o
08:25:33 <edwardk> My first thesis chair was a differential geometer, so I slogged through a fair bit of material in that domain
08:25:42 <bastl> i remember some haskell related web-app that showed an infinit sequence, perhaps fibonacci numbers. But i dont find it. can someone help me out ?
08:26:10 <edwardk> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs
08:26:10 <MissPiggy> wow edwardk you make it sound like picking strawberries
08:26:11 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
08:26:41 <edwardk> bastl: oh, web app, no idea
08:26:44 <bastl> edwardk: im more intereseted in the web-app stuff ...
08:27:11 * hackagebot upload: threadscope 0.1 - A graphical thread profiler. (SatnamSingh)
08:27:15 <edwardk> MissPiggy: it was an interesting experience. he was romanian so the main problem with the course was parsing his english =)
08:27:26 <bastl> hmm, with every click, it unfolded one more step in the sequence ...
08:27:30 <temoto> bastl, type the same thing in codepad.org :)
08:27:40 <fasta> edwardk, do you happen to have any idea what the partial derivative of a contour is?
08:27:42 <aavogt> http://foldr.com
08:27:45 <edwardk> afterwards he largely let me run off and do my own thing w.r.t. my thesis though
08:28:15 <aavogt> but it's not a sequence...
08:28:52 <bastl> aavogt: that's it.
08:29:10 <fasta> edwardk, there are people which publish stuff with those terms in it, so I assume it must mean something, but IMHO, if someone else would ask this question to me, I would say it is gibberish.
08:29:11 * hackagebot upload: CheatSheet 2.2 - A Haskell cheat sheet in PDF and literate formats. (JustinBailey)
08:29:13 <bastl> is the source available somewhere ?
08:29:48 <edwardk> fasta: hah, i was trying to figure out a valid interpretation
08:31:05 <aavogt> bastl: I believe it's all client-side anyways
08:31:10 <fasta> edwardk, page 1 here:  http://igitur-archive.library.uu.nl/math/2007-0302-200558/veltkamp_04_straight.pdf is the context
08:31:12 <bastl> oops, it's not written in haskell, but javascript.
08:31:15 <aavogt> so you do have the source when you load the page
08:31:19 <bastl> hm
08:31:35 <edwardk> fasta: My main frame of reference for differential geometry is here: http://www.amazon.com/Elements-Differential-Geometry-Richard-Millman/dp/0132641437/ref=sr_1_15?ie=UTF8&s=books&qid=1264609827&sr=8-15
08:31:54 <aavogt> >  foldr f 1 (repeat 1) :: Expr
08:31:55 <lambdabot>   f 1 (f 1 (f 1 (f 1 (f 1 (f 1 (f 1 (f 1 (f 1 (f 1 (f 1 (f 1 (f 1 (f 1 (f 1 (...
08:32:18 <Cale> > foldr (+) 0 (repeat 1) :: Expr
08:32:19 <lambdabot>   1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (...
08:32:21 <fasta> edwardk, that paper is computational geometry. Do the two have anything to do with each other (I mean do they use the same notation)?
08:32:22 <jmcarthur> test λ
08:32:24 <jmcarthur> sweet!
08:32:36 <temoto> jmcarthur, congratulations :)
08:33:09 <temoto> jmcarthur, do you use compose key to type it?
08:33:29 <jmcarthur> oh i just copied and pasted that. i was just making sure i could read it
08:34:00 <jmcarthur> when i was on xchat i had some agda-mode-like autoreplaces
08:34:08 <edwardk> fasta: very little, you see some differential geometry in the computational space, but it'd mostly be used for moving within a manifold, and when working computationally you are often looking at its extrinsic properties.
08:35:03 <edwardk> fasta: my only real area of computational geometry expertise is in stabbing line problems and visibility algorithms
08:35:10 <bastl> what is the quickest way to try out the cgi-package? I don't want to install a full webserver on my computer...
08:35:14 <fasta> edwardk, it was page 1 of this btw: http://www.cs.rmit.edu.au/~jah/cats09/papers/cats2009_submission_31.pdf
08:35:17 <edwardk> fasta: so i'm hardly an overall domain expert
08:35:40 <fasta> edwardk, overall domain export. Heh, I don't think those exist ;)
08:35:44 <fasta> expert*
08:35:51 <edwardk> fasta: =)
08:36:00 <xerox> jmcarthur great :)
08:36:40 <jmcarthur> xerox: for the record, the ubuntu weechat package *is* already compiled properly for unicode
08:36:40 <fasta> edwardk, my experience with computational geometry is that its a great topic to write books about, but nobody dares to write the software.
08:36:50 <Cale> Differential geometry is the study of manifolds under change of notation.
08:36:57 <jmcarthur> my locale was set wrong
08:37:08 <edwardk> fasta: i do try to skim at least the summary results in http://www.amazon.com/exec/obidos/tg/detail/-/1584883014/qid=1083029409/sr=1-1/ref=sr_1_1/103-5288572-8790232?v=glance&s=books so i know what the rest of the field is doing
08:37:09 <fasta> edwardk, e.g. try to find a good description of (1/sqrt(n))-cuttings.
08:37:13 <jmcarthur> temoto, xerox: thanks, both
08:37:17 <xerox> jmcarthur aha! ok good.
08:37:49 <edwardk> fasta:  but that book is -huge- and just summarizes asymptotic results found in other papers and subdisciplines of computational geometry
08:37:51 <fasta> edwardk, everyone refers to one paper, but that paper is quite vague. That is, it will take a lot of time to construct an algorithm out of it.
08:38:01 <edwardk> i only purport to understand the stabbing line sections
08:38:08 <ystael> Cale: differential geometry is the study of partial differential equations while surrounded by the screaming of the damned
08:38:17 <Cale> (And despite the wide variety of notations that people seem to use, I've never managed to find a treatment whose notation I was actually happy about.)
08:38:22 <quicksilver> fasta: people in computer games occasionally solve interesting problems in computational geometry
08:38:25 <edwardk> cale: yeah
08:38:31 <quicksilver> fasta: but they often don't discuss or publish their work
08:38:46 <quicksilver> fasta: (and almost never share the source)
08:38:47 <edwardk> quicksilver: thats how i tripped over it. calculating visibility for BSPs ;)
08:38:49 <sclv> @remember cale Differential geometry is the study of manifolds under change of notation.
08:38:49 <lambdabot> Nice!
08:38:50 <fasta> edwardk, so, in the mean while, everyone bases their new ideas on results which only exist on paper, with as a result the whole field of computational geometry working in a vacuum.
08:38:56 <fasta> quicksilver, what do you think I am doing? ;)
08:39:12 <quicksilver> people in medical science also, and they are a bit more likely to share it
08:39:20 <quicksilver> although possibly in an obscure place you wouldn't look.
08:39:37 <fasta> quicksilver, I noticed that several other people have implemented an algorithm I need, but they actually don't do it correctly.
08:39:40 * quicksilver nods
08:39:49 <fasta> Or in other words, I have to do it myself.
08:40:03 <edwardk> i wound up playing with stabbing line problems because i misunderstood a paper by seth teller and thought his algorithm was more general than it was. so I implemented my generalization and it worked, then i had to justify it theoretically ;)
08:40:08 <fasta> I think it is a terrible waste of time though.
08:40:22 <fasta> The inventor of an algorithm should just write in a machine readable language.
08:40:50 <fasta> Then you avoid these problems and then only when you need some special performance, you would have to reimplement it.
08:40:57 <edwardk> it only took me ~12 years from the actual implementation to going back to collect enough base mathematical understanding to derive the justification of why it worked ;)
08:41:07 <MissPiggy> hehe
08:41:15 <edwardk> fasta: yeah but then the pesky numerical precision problems kick in
08:41:40 <edwardk> and you lose sight of the forest for the trees
08:41:40 <fasta> edwardk, exact real arithmetic is nice.
08:42:41 <edwardk> afk a bit
08:43:14 <etpace> @hoogle m (m a) -> m a
08:43:14 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
08:43:14 <lambdabot> Prelude concat :: [[a]] -> [a]
08:43:14 <lambdabot> Data.List concat :: [[a]] -> [a]
08:44:01 <luite> does anyone have an idea of how to efficiently count the number of solutions for integer-valued variables x_1 ... x_n where a_i <= x_i <= b_i  and a partial order on the variables (so x_i <= x_j for some i,j satisfying the usual requirements for a partial order)
08:44:59 <Cale> Does this have anything to do with strategic voting?
08:45:03 <quicksilver> fasta: I generally solve these things precisely because I enjoy writing them myself.
08:45:21 <quicksilver> e.g. I tried to write a better marching cubes because I didn't like the hideous case analysis in the published version.
08:45:31 <quicksilver> in doing so, I came to understand why they had that hideous case analysis ;)
08:45:34 <quicksilver> learning process...
08:45:47 <quicksilver> but then I didn't have an end-goal in mind, it was just playing.
08:47:19 <aledge> luite, are you just saying that there are n variables, and each variable is bracketed in [a_i, b_i]?
08:47:24 <cheater> quicksilver: what is marching cubes?
08:47:43 <fasta> @google marching cubes algorithm
08:47:45 <lambdabot> http://en.wikipedia.org/wiki/Marching_cubes
08:47:45 <lambdabot> Title: Marching cubes - Wikipedia, the free encyclopedia
08:47:55 <luite> Cale: it's something that arises when counting the number of integer-valued monotonic regressions according to some norm
08:47:56 <cheater> :)
08:47:58 <temoto> oh boy it can google
08:48:27 <luite> aledge: yes, but in addition, they have to satisfy the partial order constraints, which seems to make it hard(er)
08:48:49 <aledge> oh i see, for some reason i was reading it as just i <= j and was thinking "durr..."
08:48:51 <aledge> hehe
08:49:45 <kquick2> need some advice on cross-referential classes.  One class has methods describing a type of things.  Another class has methods for an instance of a thing.  I'd like to have a mkThing method in the first class, but I'd like to have a method in the second class that can return the instance of the first clas to which it belongs. The problem is the instance declaration requires full definition, so the instance in the first method can't refer to the
08:49:45 <kquick2> second instance yet.
08:49:53 <temoto> googling is pretty restricted though
08:50:17 <Cale> kquick2: You can have mutually recursive instances.
08:50:53 <Cale> kquick2: But... I don't really understand what you mean by these uses of classes.
08:51:22 <Cale> "a type of things" and "an instance of a thing"
08:51:49 <fasta> quicksilver, actually solving a problem is quite fun, but connecting all kinds of badly written papers together to form a coherent picture is slightly less interesting.
08:51:59 <kquick2> class ShapeType a { name :: a -> String; mkShape :: (Shape s) a -> s }; class Shape a { area :: a -> Int; type :: (ShapeType t) a -> t }
08:52:42 <Cale> er...
08:53:04 <luite> Cale: I just wanted to check if this was some well-known combinatorial problem that I don't know about :) (it is a bit more difficult than the usual 'number of solutions to 0 <= x1 <= a1, 0 <= x2  <= a2, ..., x1+x2+...=n')
08:53:34 <kquick2> data CircleType = CircleType; data Circle = Circle r; instance ShapeType CircleType where { name _ = "circle"; mkShape _ = Circle 3 }
08:53:47 <Cale> kquick2: You seem to be missing the =>'s in that first line, btw.
08:53:50 <kquick2> Fails because I haven't yet declared Circle to be instance of Shape.
08:54:07 <kquick2> (yes, I'm paraphrasing quickly, sorry)
08:54:16 <Cale> kquick2: Then why don't you also write that instance?
08:54:35 <Cale> um... actually, that doesn't make sense
08:54:43 <quicksilver> fasta: sure. problems are interesting when I understand enough of them, they're boring when I have to understand lots of boring papers to tackle them. However if I have to read some interesting papers to tackle them it's a bonus. Very subjective.
08:54:49 <kquick2> instance Shape Circle where { area ... ; type _ = CircleType }
08:54:57 <Cale> Your implementation of mkShape is plainly a type error
08:55:02 <kquick2> That would fail because CircleType isn't yet an instance of ShapeType
08:55:03 <quicksilver> fasta: I got quite interested in tesselation and good triangulations for a while, too.
08:55:21 <Cale> It's supposed to produce something which is forall s. (Shape s) => s, but instead it produces a Circle
08:55:23 <fasta> quicksilver, I recently read a derivation of Coq's theorems.
08:55:32 <MissPiggy> derivation?
08:55:35 <kquick2> True.
08:55:48 <fasta> quicksilver, very interesting (probability theory).
08:55:56 <Cale> Even if Circle was an instance, the implementation isn't polymorphic enough.
08:56:40 <Cale> I'm not sure what the motivation is here, but I don't think you really want classes.
08:56:42 <kquick2> Which is where I think I'm lost.  I'd like a number of instances of "describers" that have methods.  Then I'd like a number of instances of each described thing.  I want to be able to look through the describers to see which one I want and then create an instance from the matching describer.
08:57:33 <kquick2> And yes, I think I'm not "Haskellizing" this enough.
08:57:38 <Cale> I'm not sure I understand what the purpose of this one-element type CircleType is.
08:57:57 <kquick2> I'd have SquareType, etc.
08:58:08 <kquick2> And then a list of instances of various types.
08:58:11 <Cale> I mean, that's the sort of thing you use when you're doing type-level hackery and you need to fill in a phantom parameter
08:58:39 <kquick2> So that I can then look through my list of ShapeType instances and find the type of shape that matches my current inputs.
08:58:45 <Cale> But it seems a bit out of place here -- why not just use the actual type of shape in its place?
08:58:51 <kquick2> Based on that ShapeType, I want to create an instance of the Shape.
08:58:51 <Cale> Uhh...
08:59:23 <Cale> What would the type of such a function be?
08:59:36 <kquick2> The separation of ShapeType and Shape is because ShapeTypes have properties (which I'm using methods to access).
08:59:55 <Cale> CircleType has no properties at all.
09:00:02 <quicksilver> kquick2: I'm pretty sure you want ShapeType to be a data, not a class
09:00:04 <Cale> There's only one value of that type.
09:00:04 <kquick2> But the actual Shape has its own properties.
09:00:11 <quicksilver> data ShapeType = CircleType | SquareType
09:00:14 <fasta> quicksilver, good mathematics can and often is interesting to read, but there is so much noise these days, unfortunately.
09:00:35 <fasta> can be*
09:00:40 <quicksilver> then your 'type' method in your Shape class actually has a sensible type signature
09:00:52 <quicksilver> (class Shape a where .... type :: a -> ShapeType)
09:01:38 <Cale> If you're looking for an OO-style solution to representing types of shapes, here's what I recommend...
09:02:07 <kquick2> getShape numVertices size would call getNumVertices on a list of ShapeTypes to find the match (CircleType, TriangleType, SquareType, etc.) then call the mkType for that match with the size parameter.
09:02:25 <Cale> First, work out the complete set of basic operations that you'd like shapes to support, and then define a *datatype* with fields that implement those operations.
09:02:39 <kquick2> quicksilver: I want to describe each ShapeType in an individual module then have one module that imports all known ShapeTypes and creates a list.
09:03:28 <Cale> For instance, if you want functions  name :: Shape -> String, draw :: Shape -> IO (), translate :: Shape -> Vector -> Shape, numVertices :: Shape -> Integer
09:03:34 <Cale> then you want:
09:03:57 <Cale> data Shape = Shape { name :: String, draw :: IO (), translate :: Vector -> Shape, numVertices :: Integer }
09:04:24 <jmcarthur> kquick2: have you peeked at graphics-drawingcombinators?
09:04:44 <kquick2> Cale: I see: use records with function members instead of classes with methods.
09:04:48 <jmcarthur> it's not really OO style, but it might give you some ideas about design
09:05:03 <Cale> kquick2: Right. Classes are about giving *different* types the same interface.
09:05:13 <jmcarthur> kquick2: http://hackage.haskell.org/packages/archive/graphics-drawingcombinators/1.0.3/doc/html/Graphics-DrawingCombinators.html
09:05:22 <Cale> kquick2: Whereas it sounds like you want different values of the same type with the same interface.
09:05:28 <quicksilver> q.v. quicksilver's first rule
09:05:36 <quicksilver> If you think you need a typeclass, think again.
09:05:47 <kquick2> jmcarthur: thanks.  That's part of my question here: I'm trying to turn off the years of OO my brain has learned and do this the Haskell way.  :-)
09:06:01 <Cale> http://cale.yi.org/index.php/A_look_at_OO_from_Haskell
09:06:08 <Cale> Maybe check that out :)
09:06:29 <jmcarthur> kquick2: i like luqui's design for graphics-drawingcombinators, for the record. it's much more functional than the usual direct translation from OO-think
09:06:47 <fasta> jmcarthur, but it is based on GL Doubles.
09:06:51 <jmcarthur> kquick2: it's also very simple, which works out well for beginners :)
09:07:12 <kquick2> OK.  Thanks all... let me research that stuff.  I'll be back after some mental digestion.
09:07:14 <jmcarthur> fasta: i don't see any GL doubles in the exposed API
09:07:29 <fasta> jmcarthur, look at how he defines R.
09:07:38 <jmcarthur> fasta: that's just an implementation
09:07:38 <Cale> jmcarthur: type R2 = (R,R); type R = GLdouble
09:07:51 <jmcarthur> oh i see
09:07:55 <jmcarthur> i was in the wrong file
09:07:57 <jmcarthur> *module
09:08:14 <jmcarthur> eh whatever. it's not perfect. it's a better direction than most though
09:08:17 <fasta> I would have expected him to use exact real arithmetic given all this previous opinions.
09:08:20 <Cale> But it's appropriate, given that it's a functional interface to OpenGL
09:08:29 <jmcarthur> i agree, Cale
09:08:31 <fasta> his*
09:08:34 <Cale> OpenGL doesn't support exact real arithmetic.
09:09:01 <fasta> No, but in the end he could have translated that particular abstraction to OpenGL.
09:09:02 <jmcarthur> it's a matter of "good enough" when it comes to opengl graphics abstractions
09:09:19 <MissPiggy> opinions are one thing :)
09:09:20 <jmcarthur> fasta: truwe
09:09:22 <jmcarthur> *true
09:09:47 <Cale> Also, I've never seen an exact real arithmetic library which was actually practical in the same way that double-precision floating point is. (That's not to say that such a library doesn't exist, just that I've never actually seen it.)
09:09:55 <jmcarthur> maybe somebody to bring it up when luqui's around
09:10:00 <jmcarthur> *somebody should
09:10:10 <fasta> Of course it is nothing new (the picture language as is done in 3d in Clojure is more advanced).
09:10:32 <fasta> And the picture language is from 1970-1980 or something like that.
09:10:37 <jmcarthur> kquick2: another library to look at is FieldTrip. it's more complex, but does 3D
09:10:52 <fasta> "does 3d", heh.
09:11:06 <jmcarthur> fasta: ?
09:11:08 <MissPiggy> Cale in what respect? if you just have got the Num instance isn't that enough?
09:11:12 <fasta> An actual game-engine does 3D, in some limited sense ;)
09:11:33 <Cale> MissPiggy: No, the operations also have to be fast when used at reasonably low precision.
09:11:35 <jmcarthur> fasta: i don't see your point
09:12:08 <fasta> jmcarthur, the point is that to do everything one would want related to 3D, Fieldtrip probably does not come close.
09:12:20 <jmcarthur> fasta: no, not everything, of course
09:12:30 <Cale> MissPiggy: Something like a small constant factor -- maybe 2 to 5 times slower than Double, would be quite acceptable to me.
09:13:01 <jmcarthur> fasta: it seems to be that kquick2 is just after some insight on design, not how to do everything under the sun in one all-inclusive package
09:13:31 <fasta> jmcarthur, yes, but high-jacking topics is so much more fun, no?
09:13:39 <jmcarthur> heh
09:13:45 <Cale> MissPiggy: But if you do something like  sum (replicate 100000 1) and it takes 5 minutes, that's unacceptable.
09:14:06 <fasta> kquick2, the best moment to introduce all these kinds of abstractions is when you actually need them.
09:14:17 <Cale> (when you ask for, say, only a couple digits of precision)
09:14:28 <jmcarthur> MissPiggy: also, since we are talking about (presumably) real time graphics, we'd really need some performance
09:14:35 <fasta> kquick2, that's the philosophy of the Linux kernel and it seems to work fairly well,
09:15:19 <jmcarthur> i find that i need abstractions more often than others think they need them
09:15:26 <jmcarthur> *i think i need
09:15:34 <jmcarthur> well... we never *need* them, really
09:15:59 <fasta> I think abstractions or better said overloading is only very rarely useful.
09:16:14 <fasta> OCaml functors show that.
09:16:15 <jmcarthur> fasta: ah, i'm talking about more than overloading
09:16:27 <jmcarthur> but i think overloading is very useful, too
09:16:33 <jmcarthur> oh... bye fasta
09:17:26 <Cale> kquick2: Here's something which should help guide your intuition about this stuff: Types don't exist at runtime. Types only serve to help make sure that values don't misbehave, and they're checked at compile time and then discarded.
09:17:36 <xemdetia> Is there a good way to handle a large region of text in a text file?
09:17:42 <xemdetia> *in a source file?
09:17:51 <jmcarthur> xemdetia: handle in what way?
09:18:40 <Cale> Two options: Put the text into a file, and load it from main, or use something like unlines with a list of strings.
09:18:59 <dino-> If you mean something like a here document, there have been some sort of hacky tries at that. http://haskell.org/haskellwiki/Poor_man%27s_here_document
09:19:13 <dino-> And something with TH, I believe. Quasiquotes?
09:19:51 <xemdetia> Yeah Cale's probably got the best. I just wondered if there was something like python's """ or something along those lines.
09:19:54 <xemdetia> Thanks everyone.
09:20:03 <MissPiggy> that HTML here doc stuff is the worst idea anyone could have ever thought of
09:20:11 <dino-> That's what I end up doing. What Cale said.
09:21:33 <quicksilver> Cale: well the complexity tends to increase with the number of primops doesn't it? So if you say you only want 2 digits of precision, but you do 50 primops, intermediate results need to be to 100 digits of precision
09:22:12 <quicksilver> Cale: I'm not sure there is any solution to that other than explicitly agreeing that you are prepared to discard intermediate precision... at which point it isn't 'exact' real arithmetic any more.
09:22:37 <jmcarthur> there is also sybolic arithmetic, but that's a whole other can of worms
09:22:41 <MissPiggy> there may be some cases where you can do symbolic optimization,
09:22:52 <jmcarthur> and not necessarily possible for every operation, afaik
09:23:00 <jmcarthur> and can still get as complex
09:23:10 <MissPiggy> but that only improves a tiny fraction of computations..
09:23:13 <jmcarthur> right
09:23:36 <jmcarthur> it especially doesn't help if you need intermediate results too
09:24:54 <Botje> @src maximum
09:24:55 <lambdabot> maximum [] = undefined
09:24:55 <lambdabot> maximum xs = foldl1 max xs
09:24:56 <quicksilver> xemdetia: I don't like heredocs anyway (aesthetically) because they break up the indentation of the code. I use concat/unlines or just an external file.
09:26:11 <MissPiggy> and treating HTML as text is a mistake
09:31:40 <sshc> is there a square root function that I can use when I care about accuracy but not performance?
09:32:09 <jmcarthur> sshc: there is a type you can use (CReal), but it's not in the standard library
09:32:27 <jmcarthur> > sqrt 2 :: CReal
09:32:29 <lambdabot>   1.4142135623730950488016887242096980785697
09:32:34 <jmcarthur> > sqrt 2 * sqrt 2 :: CReal
09:32:36 <lambdabot>   2.0
09:33:15 <jmcarthur> sshc: http://hackage.haskell.org/package/numbers
09:33:47 <jmcarthur> > drop 100 . showCReal 120 $ sqrt 2
09:33:48 <lambdabot>   "2735013846230912297025"
09:34:07 <sshc> thanks
09:34:09 <jmcarthur> > drop 200 . showCReal 220 $ sqrt 2
09:34:10 <lambdabot>   "4701095599716059702745"
09:34:25 <aavogt> @hoogle Record a -> [Dynamic]
09:34:25 <lambdabot> Warning: Unknown type Record
09:34:25 <lambdabot> Prelude repeat :: a -> [a]
09:34:25 <lambdabot> Data.List repeat :: a -> [a]
09:34:26 <Beelsebob> > drop 2000 . showCReal 2020 $ sqrt 2
09:34:29 <lambdabot>   "0834449114818587655554"
09:34:32 <MissPiggy> > pi :: CReal
09:34:32 <Beelsebob> blimeh
09:34:33 <lambdabot>   3.1415926535897932384626433832795028841972
09:34:46 <Beelsebob> is that "infinite" precission, or some extremely high precission?
09:34:48 <jmcarthur> > drop 2000 . showCReal 2020 $ pi
09:34:50 <lambdabot>   "0994657640789512694684"
09:34:54 <MissPiggy> all finite
09:34:54 <jmcarthur> Beelsebob: effectively infinite i think
09:35:11 <jmcarthur> Beelsebob: as infinite as Integer, afaik
09:35:16 <jmcarthur> which is still finite, but whatever
09:35:24 <Beelsebob> fancy pants lazy evaluation of precission or something?
09:35:35 <Beelsebob> yep, it's "infinite"
09:35:41 <jmcarthur> data CReal = CR (Int -> Integer)
09:36:07 * Beelsebob tries to figure out what the argument is
09:36:09 <harlekin> A
09:36:13 <aavogt> how many digits
09:36:15 <quicksilver> Beelsebob: well more to the point, it's not some *fixed* extremely high precision.
09:36:18 <jmcarthur> Beelsebob: number of digits to output?
09:36:22 <harlekin> Ups, sorry.
09:36:39 <quicksilver> Beelsebob: rather, it's adaptively "as much precision as you need to answer a question to within a given tolerance"
09:36:40 <copumpkin> Rational -> Rational is the representation used by roconnor's library
09:36:49 <jmcarthur> copumpkin: link?
09:36:51 * Beelsebob nods
09:37:01 <copumpkin> http://r6.ca/FewDigits/
09:37:03 <quicksilver> so obviously, ultimately the precision is limited by your machine's memeory etc.
09:37:16 <quicksilver> but the good bit is that it doesn't use all that memoery if it doesn't need to.
09:37:23 <Beelsebob> > let unCR (CR f) = f in (unCR pi) 20
09:37:24 <lambdabot>   Not in scope: data constructor `CR'
09:37:27 <Beelsebob> damn
09:37:33 <Beelsebob> thought it would be private, but still
09:37:41 <jmcarthur> copumpkin: thanks
09:39:59 <MissPiggy> infinite here means every finite
09:40:30 <MissPiggy> when you say it has infinnite precision it means that it is an algorithm to compute it to n-precision (for every finite n)
09:41:16 <quicksilver> normally the word for that is 'arbitrary'
09:41:33 <jmcarthur> it's arbitrary-ish
09:41:37 <jmcarthur> of course
09:41:41 <MissPiggy> I thought arbitrary precision meant like you fix a (particular) finite precision and work with that
09:41:51 <MissPiggy> like 300 places (including intermediate calculations)
09:41:55 <jmcarthur> you can't generate more than maxBound :: Int digits for sure
09:42:06 <jmcarthur> actually...
09:42:26 <jmcarthur> if they are generated as a lazy list and it's garbage collected as you go... theoretically it might be possible anyway
09:42:37 <quicksilver> yes, you can
09:42:50 <quicksilver> it's not that hard to demonstrate a > 2^32 item list on a 32 bit machine
09:42:51 <jmcarthur> i don't think this CReal can do that though, afaik
09:42:58 <jmcarthur> right
09:43:03 <quicksilver> it's pretty hard to demonstrate a > 2^64 item list though :)
09:43:07 <jmcarthur> yeah
09:43:09 <quicksilver> takes a little while, people get bored of the demonstration.
09:43:26 <pikhq> quicksilver: 2^64 list of bits is pretty easy.
09:43:33 <jmcarthur> > maxBound :: Int
09:43:34 <lambdabot>   9223372036854775807
09:43:53 <quicksilver> pikhq: well, even display a bit a second it would take <insert statistic here>
09:43:56 <quicksilver> etc.
09:43:58 <pikhq> So long as you mean "list" in the sense of "a series of items" rather than "cons, car, and cdr".
09:44:14 <quicksilver> tennis courts, lifetimes of the universe, double decker busses, etc
09:44:17 <pikhq> quicksilver: Oh, *displaying* the list? That's a PITA.
09:44:18 <quicksilver> choose your metaphor!
09:45:20 <jmcarthur> even assuming you generate each element in just one cpu cycle, it would take quite a while
09:45:41 <pikhq> jmcarthur: Bah, laziness.
09:45:45 <pikhq> Anyways.
09:45:55 <pikhq> I thought 2^64 bits was a *tiny* bit smaller.
09:46:07 <jmcarthur> > 2^64 / (2*1000*1000*1000) / 60 / 60 / 24  -- days
09:46:08 <lambdabot>   106751.99116730066
09:46:11 <pikhq> As it turns out, it's roughly 2 ebibytes.
09:46:31 <jmcarthur> on a 2 GHZ CPU at 1 element per cycle
09:47:05 <pikhq> Erm. Exbibytes.
09:47:07 <jmcarthur> > 2^64 / (2*1000*1000*1000) / 60 / 60 / 24 / 365.24  -- years
09:47:08 <lambdabot>   292.2790252089055
09:47:16 <pikhq> That's "pretty damned large".
09:47:56 <doserj> not if you factor in Moore's law
09:48:02 <Cale> 2^64 bytes is exactly 16 exbibytes
09:48:05 <jmcarthur> this is why we consider IntMap lookup to be basically constant time :P
09:48:30 <pikhq> Cale: 2^64 bits is exactly 2 exbibytes.
09:48:33 <Cale> er, and 2^64 bits is exactly 2 exbibytes
09:48:34 <Cale> yeah
09:48:54 <pikhq> I said "roughly" because for some reason I assumed dc was losing precision in there somewhere.
09:49:12 <pikhq> Which is silly...
09:49:20 <pikhq> Powers of two divided by powers of two.
09:49:26 <jmcarthur> an IntMap with 2^64 elements still does lookup in O(64) time (assuming such an IntMap could even be constructed)
09:49:28 <pikhq> That's bit shifting.
09:49:44 <pikhq> jmcarthur: O(1) time, you mean.
09:49:50 <copumpkin> jmcarthur: zomg but it's a tree!
09:50:00 <jmcarthur> pikhq: right, i used 64 to emphasize where the constant factor comes from
09:50:05 <pikhq> Mmkay.
09:50:14 * copumpkin thinks back to a frustrating exchange he had on reddit about trees/tries/fucking dumbasses
09:50:25 <doserj> O(log n) is in practive just O(1) with a large constant factor...
09:50:33 <jmcarthur> copumpkin: thinks back to yesterday where he had the same problem
09:50:36 <jmcarthur> err
09:50:39 <copumpkin> lol
09:50:40 <jmcarthur>  /me thinks
09:51:12 <copumpkin> methinks indeed
09:51:23 <jmcarthur> doserj: yeah, assuming a reasonably bounded n, where "reasonably" means "within the limits of the known universe"
09:55:53 <edwardk> well, if you only need a set you can use the BitSet from monoids 0.1.36 =)
09:56:42 <edwardk> it at least avoids that n log n fanout... though, at the cost of storing a potentially huge "mantissa" for the set.
09:58:12 <bastl> what is the simplest way to build a minimal template engine? is there already something for that?
09:58:40 <McManiaC> mvar = unsafePerformIO newEmptyMVar -- is that common-and-accepted? I saw this quite a few times now
09:59:10 <Saizan> it's evil.
10:00:34 <Saizan> mostly because it doesn't really guarantee unicity, nor makes it easy to have two instances
10:01:01 <bastl> HStringTemplate, thanks :-)
10:02:08 <McManiaC> Saizan: in combination with {-# NOINLINE mvar #-} ?
10:03:26 <Saizan> McManiaC: i was assuming that was included
10:03:31 <McManiaC> ok
10:03:36 <copumpkin> jmcarthur: I found the dumbass!
10:03:45 <McManiaC> then I wont use it
10:03:46 <McManiaC> :)
10:03:46 <copumpkin> been searching through my history to enlighten you!
10:04:17 <Zao> What's the canonical way of handling missing instances of types defined in other packages, like say, Storable of type RECT = (Long, Long, Long, Long)?
10:04:27 <Zao> Cry silently and hack them into the other package?
10:04:51 <copumpkin> jmcarthur: http://www.reddit.com/r/programming/comments/9mfav/why_isnt_haskell_more_popular/c0dfbwl
10:05:00 * copumpkin apologizes for lowering the channel IQ with that
10:05:31 <Saizan> Zao: implement them in your own for a newtype?
10:06:03 <Zao> Saizan: I do want to use the type as-is if possible.
10:06:55 <McManiaC> TypeSynonymInstances? ^^
10:07:07 <Saizan> Zao: you can make the instance of course
10:07:29 <McManiaC> why not just "instance ... where" ?
10:07:35 <Saizan> Zao: the problem is that if someone else does the same in a different package, the two will be incompatible
10:07:44 <Zao> Saizan: I wouldn't expect someone else to define it in any other way, but it still feels wrong defining instances in my library for things I do not control.
10:08:08 <Zao> (types in question is the RECT type from Win32 and my own DirectX package)
10:08:08 <Alpounet> copumpkin, I admit you found a quite good one...
10:08:36 <copumpkin> Alpounet: yeah, that guy is awesome... I love his conclusion to his discussion with me
10:08:42 <Saizan> Zao: i'd try to get it upstream, since Storable is in base anyhow
10:09:05 <jmcarthur> copumpkin: yes, a fine specimen
10:09:17 <Zao> Saizan: It provides peekRECT and pokeRECT, but no Storable instance for $reason.
10:09:36 <Zao> I have a feeling I'll end up with a hefty Win32 patch when I'm done with this :)
10:09:47 <Alpounet> copumpkin, yeah. Personally, I would not take the risk to assume you don't know about tree performances. Way too risky.
10:10:00 <copumpkin> tries are a good way to show _reasonable_ people that the log factor is practically inescapable, but this guy is an arrogant prick
10:10:02 <copumpkin> so that does not apply
10:11:40 <jmcarthur> oh lovely, harrop has now gotten involved in a spat i've been stuck in with a troll
10:11:46 <jmcarthur> so now i'm dealing with two
10:11:52 <copumpkin> nice
10:11:56 <Alpounet> copumpkin, I think the quote about trying to convince people of the contrary of their beliefs applies here.
10:12:11 <seanmcl> I'm frequently writing things like do x <- comp ; case x of ...  Is there a better way to do a case analysis on the result of a monadic computation?
10:12:25 <copumpkin> Alpounet: yeah
10:12:31 <Saizan> seanmcl: not really
10:12:36 <bastl> hmm, i have problems installing TH 2.4.0.0 on GHC 6.10.4 any suggestions ?
10:12:44 <Alpounet> jmcarthur, you better work on alt-stdlib than losing time with such humanoid-trolls
10:12:45 * Alpounet runs
10:12:48 <Saizan> bastl: yeah, don't :)
10:13:00 <Saizan> bastl: you can't upgrade TH indipendently of GHC
10:13:14 <bastl> hm. but hstringtemplate seems to depend indirectly on it ...
10:13:32 <bastl> via syb with class
10:13:51 <Saizan> use --constraint="syb-with-class < 0.6.1"
10:14:01 <bastl> at cabal install ?
10:14:14 <bastl> what do you mean with --constraint ?
10:14:30 <Saizan> yes, as a flag to cabal install
10:14:45 <Saizan> it's an hint to the solver
10:14:54 <copumpkin> ipad!
10:14:54 <bastl> ah, so i can constrain the version statements from cabal files, when they are "bad" ?
10:15:13 <Saizan> yeah
10:15:15 <bastl> cool
10:15:17 <bastl> tx
10:15:17 <Alpounet>     --constraint=DEPENDENCY        A list of additional constraints on the
10:15:17 <Alpounet>                                    dependencies.
10:15:23 <jneira> @pl ( \(x,y)->(x+1,y+1))
10:15:23 <lambdabot> (1 +) *** (1 +)
10:15:36 <jneira> ***?
10:15:52 <Saizan> ?type (***)
10:15:53 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
10:16:14 <jneira> ok thnx saizan
10:16:16 <Saizan> f *** g = \(x,y) -> (f x, g y) -- for Arrow (->)
10:16:49 <jneira> mm it is not in prelude i suppose
10:17:12 <Saizan> Control.Arrow
10:17:50 <Saizan> ?type join (***) (+1)
10:17:51 <lambdabot> forall c. (Num c) => (c, c) -> (c, c)
10:18:02 <Saizan> > join (***) (+1) (3,4)
10:18:04 <lambdabot>   (4,5)
10:21:12 <Zao> Awfully symmetric library, this. It imports InvalidateRect but not ValidateRect.
10:23:02 <jneira> neat!
10:37:04 <jmcarthur> even harrop defended me today
10:37:36 <Twey> jmcarthur: Now you know you're in trouble
10:38:30 <Alpounet> Twey, haha :)
10:38:35 <jmcarthur> heh
10:38:43 <Alpounet> Hey, the last message on -cafe is a bit weird
10:39:18 <int-e> By Andrew Coppin?
10:39:52 <Alpounet> yes
10:40:10 <Alpounet> is he trying to prove a point or actually asking something ?
10:40:12 <int-e> Ok. No surprise there. ... but yeah, I agree it's weird.
10:40:28 <Alpounet> Oh, he is well-known for posting such messages ?
10:41:22 <int-e> Hmm, let's take it to haskell-blah.
10:41:56 <mreh> if a statement throws an exception in a IO do-block, I could place instrumentation code around it to track which one it is, right?
10:42:08 <Alpounet> done.
10:42:14 <mreh> i should probably be catching exceptions from unsafe code mind
10:43:24 <perverthaskell> So now I have written doubly linked lists with IORefs
10:43:33 <perverthaskell> is there any more ways to pervert haskell?
10:43:38 <sproingie> your nick is so apropos
10:44:00 <perverthaskell> I like to put things INTO IO
10:44:13 <sproingie> that by itself isn't perverse
10:44:17 <shepheb> please tell me you didn't change nicks there because 'pervert' is registered.
10:44:24 <perverthaskell> that was the case
10:44:27 <perverthaskell> hehe
10:44:51 <sproingie> i dunno the BASIC interpreter is perverse enough
10:45:10 <sproingie> type-level forth perhaps?
10:45:15 <sproingie> (if that's possible)
10:45:21 <perverthaskell> but that aside, writing imperative code in haskell that use refs is kinda..
10:45:37 <perverthaskell> I don
10:45:47 <perverthaskell> tI don't want to say hard, but..
10:45:49 <solrize> zomg, 4chan has a programming subreddit or whatever they call subreddits in 4chan land
10:45:51 <zygoloid> perverthaskell: how about a Num instance for Dynamic, with autocoercion between numeric types, strings and so on? :)
10:45:53 <c_wraith> Haskell is actually a pretty clean, if slightly verbose, language for writing imperative code.
10:45:57 <sproingie> solrize: boards
10:46:00 <solrize> http://dis.4chan.org/read/prog/1202913500/1
10:46:06 <sproingie> i'll pass
10:46:18 <perverthaskell> to much porn
10:46:28 <perverthaskell> I don't like 4chan
10:46:36 <pokoko222> do you know some good AI chanell?
10:46:41 <aledge> too much porn...what does this mean?
10:46:50 <sproingie> NSFW isn't really the issue for me, i work in antispam.  people expect i'm going to have porn images up on my screen
10:46:50 <aledge> do you mean for work?
10:47:07 <sproingie> it's the brain-melting stupid i can't stand
10:47:08 <perverthaskell> I just don't like the stuff I see over there
10:47:19 <perverthaskell> Let's not talk about that
10:47:22 <sproingie> that and it's not good porn either
10:47:36 <solrize> man it's terrible
10:47:37 <Alpounet> pokoko222, IIRc there is #AI or ##AI
10:47:39 <solrize> i hadn't looked at it before
10:47:43 <zygoloid> perverthaskell: you may find IORefs nicer with a few synonyms. (=:) = writeIORef works well
10:47:47 <Alpounet> pokoko222, you interested in AI/Haskell ? :)
10:48:01 <pokoko222> something like that yeah
10:48:03 <sproingie> zygoloid: use the statevar package and you get $=
10:48:09 <sproingie> OpenGL uses it all over the place
10:48:16 <perverthaskell> zygoloid: that is a good idea
10:48:24 <zygoloid> sproingie: what does that do for reading variables?
10:48:32 <sproingie> that's for writing them
10:48:33 <perverthaskell> in fact why is that not standard
10:48:43 <Alpounet> pokoko222, did you check http://haskell.org/haskellwiki/AI ? :-)
10:48:49 <zygoloid> sproingie: i mean, what does that package use for reading variables?
10:48:58 <sproingie> zygoloid: i'm not sure, actually
10:49:17 <zygoloid> hohoho
10:49:33 <sproingie> 'get' i think
10:49:39 <sproingie> get someVar
10:50:18 <sproingie> indeed
10:50:21 <sproingie> http://hackage.haskell.org/packages/archive/StateVar/1.0.0.0/doc/html/Data-StateVar.html
10:51:07 <zygoloid> what about... do { x <- newIORef 0; let { x_ = readIORef x }; x =: 42; y <- x_ }
10:52:06 <sproingie> there's examples of that sort of thing on the page
10:52:21 <sproingie> i know, haddock with usage examples, pretty mind-blowing
10:52:53 <sproingie> i think it was written for OpenGL specifically but it's generally useful
10:53:21 <zygoloid> i think you could get "do { x <- var 0; x =: 42; y <- x }" to work too, even. but i think you need parameterized monads to make that properly safe. (that is, only allowing variables on the LHS of =:)
10:53:30 <aavogt> what's the strategy for writing a type when ghc rejects the one that is inferred?
10:53:47 <MissPiggy> what's the 0 for?
10:54:04 <MissPiggy> aavogt, do you mean regarding infinite types?
10:54:39 <MissPiggy> oh you mean annotation
10:54:58 <aavogt> exactly
10:55:53 <int-e> aavogt: 1) check that the function with the inferred type could actually be used ... i.e. that the types of the arguments are enough to fix all the types in the inferred constraints.
10:56:22 <aavogt> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16660#a16660
10:56:48 <aavogt> that's the error when I paste the annotation that ghci infers
10:56:58 <int-e> not helpful without the code, or at least the inferred annotation
10:57:08 <aavogt> the code is useless
10:57:15 <aavogt> it's all at the type level :)
10:57:38 <MissPiggy> just change it to () or whatever then
10:57:48 <int-e> aavogt: But I guess that the e1 type HMapOut PrettyVals a11 e1 occurs in none of the types of the arguments.
10:57:49 <MissPiggy> type level programs can be erased at compile time :D
10:58:30 <int-e> aavogt: give me a moment to type a small example
10:58:51 <aavogt> anyways, I don't see how the ghc wants   a     forall e. HMapOut PrettyVals a11 e
10:59:21 <aavogt> well that's what I see it wanting, but it rejects that additional constraint when I add it
11:01:57 <aavogt> more code if this helps, int-e: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16660#a16661
11:02:43 <int-e> aavogt: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16660#a16662 is a very small example for this type of problems. the comment gives the inferred type
11:03:43 <aavogt> oh, so it needs a type signature on the inside then?
11:04:06 <int-e> yep
11:05:09 <int-e> aavogt: or something involving `asTypeOf` as in  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16660#a16663 -- a type signature (with the ScopedTypeVariables extension) is probably simpler.
11:05:24 <aavogt> or also: class Foo a b | b -> a where
11:07:09 <int-e> aavogt: note that 'foo' can't be used, even without the type signature. Trying to invoke (foo :: Int) with an instance Foo Int Int will say "No instance for (Foo b Int) arising from a use of `foo'"
11:07:30 <jmcarthur> or: class Foo b where type Bar b
11:07:40 <MissPiggy> hi
11:07:53 <jmcarthur> hi
11:09:45 <aavogt> int-e: while the errors are similar sounding, I don't think mine is the same as your reduced case
11:09:58 <aavogt> this code works correctly
11:10:06 <aavogt> your example cannot be used
11:12:34 <MissPiggy> whats going on
11:13:20 <aavogt> I have code that works perfectly but the type signature ghci thinks this function needs is rejected
11:17:30 <BONUS> aavogt: paste code?
11:17:48 <aavogt> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16660#a16662 BONUS
11:17:57 <aavogt> HList stuff
11:18:20 <BONUS> ah i see, yikes (i dont know much about HList)
11:20:13 <sinelaw> i always felt HList's were a dirty trick. Always. Well, at least since I heard about them two months back.
11:20:48 <Twey> Of course they are.  Haha
11:22:05 <solrize> @hoogle HList
11:22:05 <lambdabot> No results found
11:23:03 <aavogt> @where HList
11:23:03 <lambdabot> http://homepages.cwi.nl/~ralf/HList
11:23:11 <aavogt> @hackage HList
11:23:11 <lambdabot> http://hackage.haskell.org/package/HList
11:24:14 <aavogt> what's annoying is how it doesn't build with ghc-6.12 because there are some (I believe) unnecessary constraints on data types
11:24:30 <aavogt> and there doesn't seem to be a repo for it anywhere
11:25:28 <int-e> aavogt: ah I see. You have functional dependencies all the way. So it's my example with the | a -> b  fundep added. In which case foo can be used, but it still won't accept the type signature, and the fix remains basically the same, except without the dummy argument.
11:26:10 <int-e> aavogt: see http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16660#a16672
11:27:04 <int-e> aavogt: uhm. I got the fundep direction wrong. Sorry :(
11:28:11 <int-e> aavogt: so http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16660#a16675 ... that's the last one, hopefully.
11:29:57 <aavogt> it doesn't need the type signature if you flip the fundep
11:30:28 <aavogt> err, wait I wanted to do that :)
11:31:37 <int-e> hmm. does GetRec a b  have a fundep a -> b?
11:32:01 <aavogt> int-e: if the fundep is flipped, ghc accepts    foo :: Foo a b -> b
11:32:12 <aavogt> GetRec has fundeps both ways
11:35:27 <theclaw> is there a reason why there's no if/else if/else in haskell?
11:35:46 <pikhq> theclaw: Uh, what?
11:35:58 <pikhq> > if True then 0 else 1
11:35:58 <lambdabot>   0
11:36:17 <theclaw> pikhq: if foo then 1 else if bar then 2 else 3
11:36:37 <Lemmih> > if False then 0 else if True then 1 else 3
11:36:38 <lambdabot>   1
11:36:38 <monochrom> > if False then 0 else if False then 1 else 2
11:36:39 <lambdabot>   2
11:36:42 <monochrom> Works.
11:36:46 --- mode: Lemmih set -o Lemmih
11:37:03 <theclaw> hmm!
11:37:49 <monochrom> You asked a wrong question. A right question is: why there is "elsif" in shell scripts and C etc.?
11:38:05 <int-e> aavogt: Hmm. HMapOut doesn't have the fundep that I thought it would have. (HMapOut f r e | f r -> e)
11:38:16 <pikhq> monochrom: ... There's "elsif" in C?
11:38:28 <int-e> #define elsif else if
11:38:29 <lunabot>  luna: Not in scope: `define'
11:38:33 <monochrom> Oh darn there isn't.
11:38:37 <theclaw> monochrom: no, I actually just didn't try the obvious. sorry
11:40:10 <monochrom> This is why learning from the raw, authentic, authorative (authoratative?) grammar is more beneficial than from mere tutorials.
11:40:39 <aavogt> @wn authoratative
11:40:41 <lambdabot> No match for "authoratative".
11:40:59 <c_wraith> @wn authoritative
11:40:59 <lambdabot> *** "authoritative" wn "WordNet (r) 2.0"
11:40:59 <lambdabot> authoritative
11:40:59 <lambdabot>      adj 1: having authority or ascendancy or influence; "an important
11:40:59 <lambdabot>             official"; "the captain's authoritative manner" [syn:
11:40:59 <lambdabot>             {important}]
11:41:01 <lambdabot> [6 @more lines]
11:41:44 <monochrom> Failing that, a syntax editor that tells you at every hole all possibilities you are allowed.
11:43:34 <aavogt> int-e: well the only instance for HMapOut involves the class Apply f r e | f r -> e
11:44:10 <int-e> aavogt: Oh well. There are overlapping instances involved, so predictability of type inference and type checking went out of the window. The problem to solve is this: given HMapOut PrettyLabel a11 a1, and looking for HMapOut PrettyLabel a11 a, determine that a = a1. And it turns out that this is impossible, because of the HMapOut f HNil e instance.
11:46:17 <int-e> aavogt: have you tried calling the function with an empty record (i.e. some er with GetRec er HNil) ? I'll be amazed if that works.
11:47:19 <aavogt> well it does reach that case in evaluation
11:47:34 <aavogt> otherwise the lists that are produced would explode when being displayed
11:48:39 <aavogt> hMapOut PrettyLabel HNil == []
11:48:56 <aavogt> hMapOut PrettyLabel HNil :: [e]
11:48:58 <int-e> that's not the point
11:49:15 <MissPiggy> I think you have to pute the annotation before/
11:49:16 <MissPiggy> ?
11:49:33 <MissPiggy> oh nevermind I have just misunderstood that completlely
11:49:35 <aavogt> MissPiggy: before what?
11:49:39 <int-e> aavogt: The point is about infering the type of the elements of the list of lists xs in the end.
11:49:49 <MissPiggy> aavogt, sorry I just realized that was nonsense
11:51:18 <int-e> aavogt: and my current theory is that the compiler will fail to do that for empty records, because your Apply instance is not being used, so there's no fundep to make the result type unique - and that's the third type argument to the HMapOut PrettyLabel a1 a instance that the compiler complains about.
11:53:47 <aavogt> int-e: the result types get unified at some point because they are put into a regular list
11:54:07 <aavogt> perhaps if I remove the X.toHtml...
11:55:03 <int-e> you could probably say  map (X.toHtml . (id :: a -> a))
11:55:35 <int-e> (with scoped type variables and the  forall a .  magic in the type signature to bring a into scope)
11:56:51 <int-e> (and the same with (id :: e -> e) for PrettyVals)
11:57:03 <cheater3> hi int-e
11:57:17 <aavogt> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16660#a16660
11:57:39 <aavogt> yeah, it's the X.toHtml that's messing things up
11:57:47 <cheater3> can i use haskell to help me with studying mathematics?
11:58:14 <shambler> sure you can
11:58:15 <monochrom> can you? yes. how much help? not much.
11:58:27 <paper_cc> @faq can haskell help cheater3 in studying mathematics?
11:58:27 <lambdabot> The answer is: Yes! Haskell can do that.
11:58:40 <cheater3> haha
11:58:41 <cheater3> :)
11:58:56 <cheater3> i was thinking maybe it allows some way of formally expressing constructs in algebra
11:59:01 <cheater3> something like that
11:59:03 <MissPiggy> hm?
11:59:29 <cheater3> and then i could use it to investigate what axioms a certain set with certain operations has ... and stuff
11:59:30 <MissPiggy> cheater3, I found this a less than enjoyable experience
11:59:42 <cheater3> and if not haskell, what do you suggest then?
11:59:50 <cheater3> the pencil and paper method is a bit tired
11:59:55 <MissPiggy> I would just suggest paper and pencil, but maybe I am old fashioned
12:00:37 <MissPiggy> I don't know, what you are talking about sounds like a tremendous idea but equally difficult
12:00:41 <sinelaw> So when's GHC for iPad getting released?
12:00:51 <MissPiggy> explaining things to computers, to help yourself understand them is one thing
12:01:01 <cheater3> isn't there ghc for ipod? that should be the same sinelaw.
12:01:11 <MissPiggy> having computers explain things to us -- that would be powerful
12:01:18 <cheater3> MissPiggy: yes, i want help - i don't want them to do the job for me
12:01:24 <lament> computers explained sex to me!
12:01:30 <monochrom> You need a theorem prover to talk of axioms and their consequences. Isabell/HOL. has typeclass like haskell, but adds axioms.
12:01:31 <sinelaw> cheater3, heh, i was kidding.
12:01:43 <aavogt> int-e: this is what you mean by the ScopedTypeVariable http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16660#a16680
12:01:46 <MissPiggy> iPad...?
12:01:55 <MissPiggy> apples gone into santiary products
12:02:03 <sinelaw> haha
12:02:09 <sinelaw> :)
12:02:19 <monochrom> @remember MissPiggy iPad...? apples gone into santiary products
12:02:20 <lambdabot> I will never forget.
12:02:27 <sinelaw> MissPiggy++
12:03:00 <cheater3> monochrom: i'm not sure i am looking for a strict prover
12:03:17 <int-e> aavogt: aavogt you need to add  forall htmlV htmlL .  to the type signature, I think
12:03:26 <cheater3> monochrom: just something that can tell me, 'could set S with the given chosen elements and functions be an algebra?'
12:03:26 <monochrom> You can't write axioms in haskell, period.
12:03:37 <cheater3> monochrom: know what i mean?
12:04:13 <MissPiggy> ask Cale if GAP can do that
12:04:15 <MissPiggy> :D
12:04:24 <monochrom> That is still a job for a theorem prover.
12:04:29 <cheater3> what's GAP?
12:04:34 <cheater3> monochrom: alright
12:04:44 <MissPiggy> cheater3, to answer a question of that form  - I would try to prove it
12:05:03 <MissPiggy> of course if you have found the problem is in the domain where proof can be done by computation you are in luck..
12:05:16 <aavogt> int-e: you're right. I'm only vaguely familiar with ScopedTypeVariables
12:05:39 <cheater3> monochrom: is isabel/HOL the same language or two different languages?
12:05:39 <cheater3> MissPiggy: proving something is usually much more difficult than proving the feasability.
12:05:47 <pettter> speaking of theorem provers, do you fine people have some suggestions as to where one could find a reasonable list of alternatives for building an app on top of?
12:05:49 <monochrom> One language.
12:06:14 <cheater3> monochrom: ok. is it the 'best one'? are there different ones in common use right now?
12:06:21 <MissPiggy> oh like searching for counterexamples?
12:06:41 <monochrom> It is the best one for your kind of questions.
12:06:42 <MissPiggy> pettter, what do you mean?
12:06:42 <pettter> I'm possibly starting my masters which will concern TP's in a formal languages setting
12:06:46 <cheater3> MissPiggy: yes, and checking general laws in particular situations.
12:07:02 <MissPiggy> pettter: tell me everything! :p
12:07:22 <pettter> MissPiggy: should I really?
12:07:25 <cheater3> monochrom: ok. does it have a good way of manipulating mathematical objects?
12:07:36 <MissPiggy> eyet
12:07:38 <MissPiggy> yes*
12:07:41 <pettter> Because that couldd take a few thousand charactes
12:08:02 <monochrom> Yes.
12:08:30 <cheater3> monochrom: cool. can you tell me some examples of what it can do?
12:09:20 <monochrom> Did you see this? <monochrom> You need a theorem prover to talk of axioms and their consequences. Isabell/HOL. has typeclass like haskell, but adds axioms.
12:10:03 <cheater3> monochrom: yes. but i am asking about practical examples
12:10:27 <monochrom> OK, then does "has typeclass like haskell, but adds axioms" ring a bell?
12:10:43 <cheater3> i don't know what a typeclass is
12:10:54 <nbowler> If I write something like 'Control.Monad.liftM' in haddock markup, it produces a hyperlink whose text is merely "liftM" (the Control.Monad. is lost).  How can I get the fully qualified name to appear in the output?
12:11:08 <cheater3> monochrom: but i am asking for a view of what it can do for me as a mathematician. not as an esolang fan.
12:11:22 <MissPiggy> lol
12:11:27 <lament> if you have to ask...
12:11:34 <lament> then you probably don't need it
12:11:34 <MissPiggy> "Ask not what you can do as a mathematician, but what.."
12:11:42 <aavogt> nbowler: I think the point is that you can click on the link to find where the functoin is defined?
12:11:55 <monochrom> OK, exactly like an algebra. A template that says "given type T and function f, (T,f) is a ring iff T and f satisfy these axioms...."
12:12:05 <aavogt> i think the solution involves hacking haddock
12:12:18 <cheater3> monochrom: an/in?
12:12:29 <nbowler> aavogt: you can, but my sentence refers to the same identifier in different modules, and when you read it as English, it makes no sense.
12:12:31 <aavogt> otherwise your markup could be:    @Control.Monad.@'liftM' ??
12:12:36 <monochrom> There is no typo.
12:12:48 <cheater3> monochrom: ok
12:12:52 <pettter> MissPiggy: basically, the thesis (if this becomes the topic) will concern a new theoretical device called a Millstream system
12:12:55 <monochrom> Or maybe there is. Whatever.
12:13:09 <gwern> so annoying. i have this 'saitek cyborg graphite' joystick and not the slightest idea what to do with it
12:13:32 <MissPiggy> pettter, what's that?
12:13:34 <pettter> MissPiggy: in practise, a numbe of tree generators called modules, linked by a logic, called the inrface
12:13:37 <aavogt> nbowler: this is a problem with a certain style of naming... try reading the haddocks for data-accessor
12:13:39 <cheater3> monochrom: can it transform algebraic elements? like, for example, find the orbit of an element.
12:13:54 <monochrom> No, it doesn't compute for you.
12:14:03 <pettter> MissPiggy: how well acquainted are you with formal language theory?
12:14:16 <MissPiggy> pettter, a wee bit
12:14:25 * Cyneox re
12:14:37 <monochrom> You rather define your own type Int and try to prove that Int is a ring. Some parts of the proof are automatic.
12:15:04 <cheater3> monochrom: gotcha. so i geuss it can take 'hints'?
12:15:24 <monochrom> Yes.
12:15:30 <nbowler> aavogt: my package is a replacement for parts of the Prelude, and the sentence is contrasting the versions in my package with the versions from the Prelude.  With the module names removed, it sounds like I'm saying "Foo is different from itself".
12:15:38 <pettter> MissPiggy: you know grammars?
12:15:40 <cheater3> monochrom: sweet
12:15:42 <MissPiggy> yes
12:15:44 <pettter> tree grammars, even?
12:15:47 <MissPiggy> yes
12:17:45 <pettter> well, an example of a millstream system would be, two regular tree grammars, each defining some regular tree language, with, say, a first-order predicate logic, which restricts the tree pairs in some way
12:18:08 <pettter> it's really loosely defined at the moment
12:18:20 <MissPiggy> pettter, it's sort of like defining a type system then?
12:18:27 <MissPiggy> like a deduction system
12:18:46 <pettter> MissPiggy: I'm sure that could be accomplished, yes
12:19:04 <pettter> but it's actually aimed at natural language aapplications
12:19:11 <MissPiggy> oh cool
12:19:21 <pettter> computational linguistics kind of stuff
12:20:05 <int-e> aavogt: And I confirmed that calling tableDump (as originally defined) does fail for empty records, as claimed.
12:20:10 <pettter> but it's really just starting up now, there's been just the one technical report written about them
12:20:43 <cheater3> monochrom: thanks a lot
12:21:06 <int-e> aavogt: it even gives a helpful error message in that case, namely "Ambiguous type variable `a' in the constraint: X.HTML a arising from a use of `tableDump'" (and the same for e)
12:25:20 <aavogt> int-e: thanks. It turned out to be easier to write: instance Show v => Apply PrettyVals (LVPair l v) X.Html where
12:29:21 <int-e> aavogt: good point.
12:30:18 <xemdetia> Where should I be looking to catch lookupCommand :: [String] -> IO ()
12:30:18 <xemdetia> lookupCommand = do let function = lookup command cmdList
12:30:29 <xemdetia> Sorry guys, right click fail there.
12:32:03 <xemdetia> My *actual* question was how do I catch this: Irrefutable pattern failed for pattern (Data.Maybe.Just function). I have a lookup feeding into a let (Just a) and I can't figure out how to catch a lookup miss
12:33:33 <doserj> xemdetia: well, check for a Nothing result?
12:34:02 <kmc_> xemdetia: pattern match with "case" or a multi-equation function
12:34:10 <kmc_> :t lookup
12:34:11 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
12:34:15 <aavogt> use   fromMaybe
12:34:18 <aavogt> @type fromMaybe
12:34:19 <lambdabot> forall a. a -> Maybe a -> a
12:34:26 <zygoloid> xemdetia: case lookup foo bar of Just a -> ...; Nothing -> ..., or use do notation and the Maybe monad, or use a pattern guard
12:34:37 <kmc_> > case lookup 'z' [('x',3), ('y',4)] of Nothing -> "none" | Just _ -> "some"
12:34:38 <lambdabot>   <no location info>: parse error on input `|'
12:34:52 <kmc_> > case lookup 'z' [('x',3), ('y',4)] of { Nothing -> "none"; Just _ -> "some" }
12:34:53 <lambdabot>   "none"
12:34:56 <kmc_> grr too much coq
12:34:57 <c_wraith> xemdetia: or stop trying to lookup things that aren't in the list, if it *shouldn't* ever be none
12:35:04 <c_wraith> err, Nothing.
12:35:09 <c_wraith> damn python work yesterday corrupting me
12:35:21 <kmc_> hehe
12:35:40 <zygoloid> , let f x | Just r <- lookup x [('a',1), ('b',2)] | otherwise = 0  in  map f ['a', 'b', 'c']
12:35:41 <lunabot>  luna: parse error on input `|'
12:35:57 <zygoloid> , let f x | Just r <- lookup x [('a',1), ('b',2)] = r | otherwise = 0  in  map f ['a', 'b', 'c']
12:35:58 <lunabot>  [1,2,0]
12:36:08 <zygoloid> ^^ pattern guards are great for this sort of thing
12:36:36 <xemdetia> Yeah I am trying to follow the example on learnyouahaskell page regarding the todo list and make it more robust against crappy input. I was wondering if I could strap a guard to a let somehow but I am trying not to pretend to know what I am doing.
12:37:06 <c_wraith> xemdetia: ah, then you definitely should expect to get Nothing sometimes.
12:37:22 <aavogt> , let f (flip lookup [('a',1), ('b',2)] -> x) = x; f _ = 0 in map f ['a', 'b', 'c']
12:37:23 <lunabot>  luna: No instance for (GHC.Num.Num (Data.Maybe.Maybe b))
12:37:29 <aavogt> , let f (flip lookup [('a',1), ('b',2)] -> Just x) = x; f _ = 0 in map f ['a', 'b', 'c']
12:37:31 <lunabot>  [1,2,0]
12:38:38 <xemdetia> Well these are a bunch of good new angles to work with that I wasn't finding from rabid googling. thanks everyone
12:38:54 <kmc_> :t maybe
12:38:55 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
12:39:31 <kmc_> > map (maybe "not found" ("here it is: "++)) [Nothing, Just "foo", Nothing]
12:39:32 <lambdabot>   ["not found","here it is: foo","not found"]
12:39:40 <aavogt> well sometimes there isn't a sensible way to recover
12:40:02 <kmc_> in which case it does make sense to throw an exception up to IO-land, print an error, and quit
12:41:15 <kmc_> hmm, what's the guideline for a monad transformer stack that already contains IO?  is it better to define custom exceptions and throw them in IO, or to add on an ErrorT?
12:42:03 <c_wraith> I hate ErrorT.  >_>
12:42:18 <c_wraith> I wish error handling was abstracted better.
12:42:33 <c_wraith> Though I suppose that's the purpose of the library mentiond in the current issue of TMR
12:42:43 <Saizan> kmc_: now that they are extensible i'd stick with IO
12:43:43 <Saizan> kmc_: better with something that makes them explicit in the type, i think control-monad-exception does this
12:44:08 <Saizan> or that pure-exception thing, i have to try them
12:45:23 <yrlnry> I want to use Control.Concurrent.STM.  I have GHC 6.10.4.  When I try "import Control.Concurrent.STM" it says "Could not find module `Control.Concurrent.STM'".
12:45:28 <yrlnry> What do I need to do to fix this?
12:46:34 <Saizan> cabal install stm
12:46:36 <Zao> Well, do you have it installed?
12:47:09 <yrlnry> Saizan:  Thanks.
12:57:44 <monochrom> kmc_: There is also http://hackage.haskell.org/package/MonadCatchIO-mtl
13:01:40 <yrlnry> cabal says: "Warning: No remote package servers have been specified. Usually you would have one specified in the config file."  I can't find any suggestions in the docs or on the web site for a default package server.
13:02:08 <yrlnry> What have I forgotten?
13:04:12 <aavogt> remote-repo: hackage.haskell.org:http://hackage.haskell.org/packages/archive
13:04:14 <aavogt> remote-repo-cache: /home/aavogt/.cabal/packages
13:04:33 <yrlnry> Aha.  If I have no ~/.cabal/config already. it will create one with reasonable defaults.
13:06:12 <yrlnry> aavogt:  Thanks.  The solution was to move my ~/.cabal/config elsewhere, run cabal, then merge in the settings from the old config.
13:06:43 <cygnus_> hi
13:06:58 <yrlnry> http://hackage.haskell.org/trac/hackage/ticket/523
13:07:01 <cygnus_> if i read that orange and black type theory book what will i understand in practial terms?
13:11:59 <Rotaerk> cygnus_, type theory probably
13:12:35 <monochrom> orange and black?
13:12:54 <MissPiggy> orange and black book?
13:13:11 <yrlnry> Hi, if I read that book with the blue covers and the mustard stain what will I find out?
13:13:32 <Twey> That you shouldn't eat hotdogs whilst reading books.
13:13:37 <medfly> hehe
13:14:09 <Twey> (the Discordians got that right, too!)
13:14:13 <cygnus_> yeah but what can i do with it?
13:14:18 <cygnus_> i started reading it and i couldn't understand it
13:14:32 <yrlnry> Then the answer is "probably nothing".
13:14:47 <Twey> You can lick it
13:15:46 <MissPiggy> cygnus what book!!!!
13:16:19 <cygnus_> it's by the MIT guy
13:16:25 <monochrom> If cygnus_ does not answer straight, it is a troll.
13:16:35 <cygnus_> you know me mono i am not a troll
13:16:44 <MissPiggy> cygnus what book are you talking about!!
13:16:45 <cygnus_> btw this was some years ago but i know it's fmous
13:16:51 <cygnus_> famous
13:16:54 <cygnus_> lemme look
13:16:55 * hackagebot upload: ghc-core 0.5.1 - Display GHC's core and assembly output in a pager (DonaldStewart)
13:17:05 <monochrom> See? The accusation works.
13:17:16 <MissPiggy> wow that guy is devoted to reading GHC output
13:17:20 <cygnus_> that's it i can't tell you the title then
13:17:24 <cygnus_> because then i am just following you
13:17:34 <MissPiggy> cygnus, you're an idiot!!!!
13:17:35 <Twey> dons?  It's because he does an awesome amount of it.  :þ
13:17:39 <monochrom> Well you can pm MissPiggy.
13:18:00 <cygnus_> its called types and progrmaming languages
13:18:00 <MissPiggy> cygnus, why don't you bite off your nose to spite your face
13:18:09 <cygnus_> what a freak
13:18:11 <kmc_> sigh
13:18:13 <MissPiggy> that book is NOT orange and black
13:18:28 <cygnus_> it is
13:18:47 <cygnus_> so if iunderstodo this book what could i do?
13:19:15 <MissPiggy> it's distinctintly sienna
13:19:21 <MissPiggy> no wonder nobody knew what you were talking about
13:19:32 <cygnus_> ok
13:20:57 <dons> Twey: ?
13:20:58 <monochrom> MissPiggy: English is my second language so I now look at the cover on the web and I would call it orange and black too. I haven't learn the word sienna. Oh I also have hard time telling apart "red hair" and "blonde hair" and I am not alone on this.
13:21:10 <dons> hey i love core. i dream about unboxes
13:21:15 <Twey> Hehe.
13:21:19 <dons> its for the iPad
13:21:25 <Twey> Argh.
13:21:27 <dons> now you can get your core in tablet form
13:21:28 <cygnus_> has anyone read this book?
13:21:29 <zachk> i dream about unpants
13:21:34 <cygnus_> i am sure dons has
13:21:34 <monochrom> @remember dons hey i love core. i dream about unboxes
13:21:34 <lambdabot> Okay.
13:21:38 <MissPiggy> cygnus_, I've read it
13:21:49 <dons> tapl?
13:21:52 <dons> cygnus_: we have a copy
13:22:20 <dons> oh, wrong cygnus_ ...
13:22:28 <cygnus_> what can i do if i know this book?
13:23:03 <dons> weird. there are two cygnus'
13:23:20 <MissPiggy> cygnus_: you can implement Perl 6
13:23:26 <dons> one works at galois, and hangs out in #haskell. the other hangs out in #haskell also
13:23:33 <cygnus_> haha
13:23:34 <monochrom> Perhaps you can design better languages and implement them well.
13:23:43 <lament> @quote
13:23:44 <lambdabot> stepcut says: how can you possibly implement business logic without knowing about Schonfinkel!?
13:24:28 <MissPiggy> cygnus_, here http://perl.net.au/wiki/Perl_6#Pugs:_The_Perl6_Users_Golf_System
13:24:48 <monochrom> How did you get @quote to be so aware of the current situation? :)
13:25:01 <monochrom> (I can only get @slap to be. :) )
13:25:35 <cygnus_> cool
13:25:55 <aledge> @slap
13:25:56 * lambdabot places her fist firmly on  jaw
13:26:00 <cygnus_> yeah i think that i am happy enough to use langauges that exist
13:26:05 <cygnus_> i probably dont need this
13:26:06 <aledge> @slap aledge
13:26:07 * lambdabot puts on her slapping gloves, and slaps aledge
13:26:12 <aledge> teehee
13:26:14 <Veinor> Slappin' gloves.
13:26:40 <lament> P is for panda
13:26:59 <lament> not power
13:27:12 <lament> sorry, wrong channel
13:27:24 <aledge> no that is true in any channel
13:27:26 <lament> well yes
13:33:40 <sizur> What RDBS interface is recommended?  haskelldb?
13:34:57 <medfly> is there some kind of data thing that lets me do a constant time lookup?
13:35:06 <endojelly> medfly, an array?
13:35:13 <Saizan> haskelldb is the higher-level richly typed one, HDBC has a more direct interface to sql
13:35:13 <medfly> ok thanks
13:35:25 <medfly> :)
13:36:26 <c_wraith> where's takusen fit into the list?
13:36:33 <opqdonut> to the left
13:36:42 <endojelly> medfly, keep in mind there are many different ones in haskell: mutable and immutable ones, the latters being pure and modifying them looks like modifying a copy, while the formers live in a monad like IO or State. but immutable ones are also available with tactics for just differential copies etc.
13:36:45 <Saizan> heh
13:36:57 <endojelly> medfly, arrays are a lot more interesting in a pure functional language %)
13:37:26 <Saizan> takusen is at the same level as HDBC i think, but with the iteratee interface for results
13:37:29 <opqdonut> medfly: but keep in mind, maps are often faster in practice
13:37:34 <opqdonut> medfly: especially IntMap
13:38:26 <endojelly> opqdonut, really depends on what you want to do!
13:38:33 <endojelly> medfly, but yeah, maybe you just need an IntMap
13:38:45 <medfly> what's an IntMap?
13:38:45 <medfly> I just want to have a constant time lookup
13:38:55 <medfly> @index IntMap
13:38:56 <lambdabot> Data.IntMap
13:38:56 <endojelly> which if I'm not mistaken about its implementation has near-constant access in practice.
13:39:00 <medfly> okay, thanks
13:39:13 <sohum> I'm using :trace main in ghci, and it looks like it's not giving me breakpoints inside a certain one of my files
13:39:17 <kmc_> medfly: how many keys?
13:39:29 <medfly> it's something ridiculously simple. I don't know anything about something cool like all sorts of datastructures and such.
13:39:34 <medfly> something like 50
13:39:37 <sizur> i get
13:39:38 <sizur> HDBC-sqlite3-2.2.0.0 failed during the building phase. The exception was:
13:39:39 <medfly> ;)
13:39:40 <sizur> ExitFailure 1
13:39:45 <opqdonut> with 50, use a map
13:39:57 <kmc_> medfly: so log n < 6
13:39:58 <sizur> ghc-6.12.1
13:40:06 <kmc_> so O(1) vs O(log n) is a meaningless comparison
13:40:11 <opqdonut> with a million, an array might be in order, but you should also be thinking about the cache
13:40:23 <sizur> i yeah, i cannot get hsc2hs to install
13:40:24 * medfly shrugs.
13:40:43 <medfly> jeez.
13:40:45 <xemdetia> What's the best way to type a function to say 'I don't care about what this function evaluates to'
13:40:52 <kmc_> why don't you care?
13:40:59 <kmc_> why would you use this function?
13:41:13 <sizur> :i undefined
13:41:19 <medfly> I'll just use a bloody list then...
13:41:23 <kmc_> if it calls "error" or such, the result is an unconstrained type variable
13:41:31 <kmc_> medfly: did you look at Data.Sequence too
13:41:34 <kmc_> :t error
13:41:35 <lambdabot> forall a. [Char] -> a
13:41:46 <kmc_> xemdetia: ^^^ error is a function whose application never succeeds
13:42:44 <kmc_> > fix error
13:42:45 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
13:43:09 * hackagebot upload: adaptive-tuple 0.1.0 - Self-optimizing tuple types (JohnLato)
13:44:07 <Veinor> > fix show
13:44:08 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
13:44:21 <xemdetia> kmc_: just trying to separate code out a bit and I wasn't sure if it was considered proper to return something like an empty set or something along those lines. Just starting to play with some Win32 happy happy fun times
13:44:43 <Saizan> > ()
13:44:44 <lambdabot>   ()
13:44:57 <Ke> :t fix
13:44:58 <lambdabot> forall a. (a -> a) -> a
13:45:07 <kmc_> xemdetia: there is very rarely a reason for a function to return a "useless" value like ()
13:45:25 <kmc_> this is done in other languages because applying a function might have side effects in addition to returning a value
13:45:29 <Saizan> if you are in a monad and want a noop, "return ()" works
13:45:32 <kmc_> in Haskell, applying a function never has side effects
13:45:38 <Veinor> 'never'
13:45:42 <kmc_> unless you cheat
13:45:54 <kmc_> or unless you consider graph reduction to be a side effect
13:46:08 <kmc_> both of which are cases where returning () and pattern matching on it is used
13:46:15 <xemdetia> Yeah that makes sense /in haskell/ but when you are dealing with stuff from foreign outside libs should you try to keep it that way?
13:46:20 <kmc_> xemdetia: you have to
13:46:23 <kmc_> to preserve the semantics
13:46:35 <xemdetia> alright thanks
13:46:37 <kmc_> a C function like void foo(int) would have a Haskell type like:   Int -> IO ()
13:46:45 <kmc_> note that the function does not return (), the useless type
13:46:50 <kmc_> it returns IO (), which is an "IO recipe"
13:47:08 <kmc_> executing that recipe will produce a value of type (), but it can also have some side effects
13:48:26 <kmc_> http://book.realworldhaskell.org/read/interfacing-with-c-the-ffi.html is a great introduction to importing foreign code in Haskell, including the various considerations of pure vs. impure functions
13:48:49 <xemdetia> Yeah that's the one thing I am having trouble with, I to an extent understand how the arrows are supposed to work when you are taking inputs and providing a result but when you end up having either Haskell infer IO () or you are supposed to use IO () things are getting fuzzy. I've read through real world haskell but it never seems to talk about it all at once
13:49:13 <xemdetia> I'll work through that section again and hope for the best, thanks again.
13:49:15 <kmc_> so you aren't clear on how to use the IO monad?
13:49:30 <holmak> Is () officially called "the useless type" now? Perhaps it should be...
13:49:42 <kmc_> it's more formally called "unit"
13:49:47 <kmc_> and it's not totally useless, but...
13:50:02 <monochrom> If I speak English badly, "unit" and "useless" are not too far apart.
13:50:04 <Saizan> if () is useless, what is Void?
13:50:19 <monochrom> Void is unusable :)
13:50:59 <kmc_> () has one value, also named ()
13:51:02 <kmc_> Void has no values
13:51:19 <kmc_> (excluding bottom in both cases)
13:51:28 <kmc_> xemdetia: you may like http://haskell.org/haskellwiki/Introduction_to_IO
13:51:39 <kmc_> it's a quick introduction to how these IO types work
13:51:45 <kmc_> which avoids the theory behind monads
13:51:55 <kmc_> (if you do want to learn that theory, don't start at IO, as it's an atypical example of a monad)
13:52:33 <xemdetia> Yes in general IO is confusing me mainly because when I was working with scheme/lisp you were always working towards different goals, and in imperative it's entirely different
13:53:01 <kmc_> evaluation is not execution.  getLine is not a function.  a recipe is not a cake.
13:53:23 <MissPiggy> kmc_ the map is not the territory!
13:53:28 <kmc_> indeed
13:53:32 <xemdetia> but but what if you put frosting on your recipe
13:53:32 <c_wraith> > cake !! 22
13:53:33 <lambdabot>   "Nine large egg yolks."
13:53:35 <MissPiggy> the finger that points to the interactive-program
13:53:44 <Veinor> > cake
13:53:45 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
13:53:47 <sizur> if i manually install a package through runhaskell Setup.hs configure, etc. how can i register it with cabal -- cabal does not see it being installed
13:53:49 <Veinor> :|
13:53:53 <kmc_> xemdetia: then you apply "join" to scrape the frosting off into the cake as you bake it
13:54:01 <kmc_> you can have a recipe for a recipe
13:54:09 <kmc_> one of the main properties of monads is that each one
13:54:12 <monochrom> Veinor: If you ask in pm, it gives you more lines.
13:54:19 <kmc_> defines a way to make a recipe for a recipe for a cake into a recipe for a cake
13:54:41 <kmc_> sizur: make sure you configured with the same prefix as cabal's installed packages?
13:54:43 <Alpounet> oh, Veinor is preparing a cake for #haskell ?
13:54:59 <monochrom> movie National Treasure is full of recipes of recipes of recipes of recipes of treasure
13:55:09 <sizur> kmc_: how can i know what is cabal's prefix?
13:55:14 <MissPiggy> I don't get Function-level programming
13:55:17 <MissPiggy> it seems silly
13:55:18 <kmc_> > unwords $ concatMap words cake
13:55:19 <lambdabot>   "One 18.25 ounce package chocolate cake mix. One can prepared coconut pecan...
13:55:25 <kmc_> > unwords . nub $ concatMap words cake
13:55:26 <lambdabot>   "One 18.25 ounce package chocolate cake mix. can prepared coconut pecan fro...
13:55:27 <MissPiggy> why would you want to do Function-level programming
13:55:34 <kmc_> MissPiggy: what does that mean?
13:55:37 <MissPiggy> I mean stuff like f + g for functions is nice
13:55:37 <kmc_> function-level programming?
13:55:42 <MissPiggy> but that's not programming
13:55:49 <kmc_> sizur: by reading the cabal config file, probably
13:55:54 <kmc_> on UNIX systems it might be in ~/.cabal
13:56:11 <MissPiggy> just flddling with notations
13:56:19 <monochrom> MissPiggy: What is function-level programming? What is programming?
13:56:28 <kmc_> what is 'is'?
13:56:32 <MissPiggy> what?
13:56:40 <aavogt> applicative numbers apparently
13:57:12 <jmcarthur> MissPiggy: how is it not programming?
13:57:14 <monochrom> I wouldn't guess like that.
13:57:19 <MissPiggy> function-level programming just to me, seems like programming in SK combinators
13:57:28 <MissPiggy> so it's like forth I guess
13:57:29 <MissPiggy> ?
13:57:30 <kmc_> http://img1.visualizeus.com/thumbs/08/12/03/humor,funny,philosophy,words,lil,jon,nt-5f115b4a48987261eec1881fa3a01651_h.jpg
13:57:44 <jmcarthur> it's just handy, like any abstraction
13:57:54 <jmcarthur> the real benefit comes in being able to program more generically
13:58:07 <monochrom> I personally see nothing wrong or useless in programming in SK.
13:58:23 <monochrom> Now what is programming? Why is function-level programming not programming? Why do you say that?
13:58:25 <jmcarthur> heck, that's pretty much what Applicative is
13:58:33 <kmc_> SK is a fine esolang, good for pure intellectual difficulty, like Brainfuck or C++
13:58:33 <Alpounet> SK ?
13:58:50 <jmcarthur> Alpounet: SK calculus
13:58:56 <jmcarthur> good for googling
13:59:01 <pikhq> Alpounet: s = \x y z -> x z (y z); k = \x _ -> x
13:59:06 <jmcarthur> sometimes called SKI
13:59:07 <kmc_> (but untyped)
13:59:19 <jmcarthur> but I is just identity and encodable using just S and K
13:59:31 <Alpounet> ok thank you
13:59:50 <pikhq> i = s k k
13:59:56 <kmc_> :t ap const const
13:59:57 <lambdabot> forall b. b -> b
14:00:03 <jmcarthur> Alpounet: Applicative defined for functions is the SK calculus
14:00:17 <jmcarthur> pure = K, (<*>) = S
14:00:37 <kmc_> :t pure <*> pure
14:00:38 <lambdabot>     Ambiguous type variable `f' in the constraint:
14:00:38 <lambdabot>       `Applicative f'
14:00:38 <lambdabot>         arising from a use of `pure' at <interactive>:1:9-12
14:00:51 <Alpounet> oooh okay
14:01:13 <Alpounet> it looks interesting.
14:01:30 <vic> @quote
14:01:31 <lambdabot> ghc says: In a case expression, type of scrutinee does not match patterns
14:01:41 <jmcarthur> :t pure <*> pure :: a -> a
14:01:42 <lambdabot>     Ambiguous type variable `f' in the constraint:
14:01:42 <lambdabot>       `Applicative f'
14:01:42 <lambdabot>         arising from a use of `pure' at <interactive>:1:9-12
14:01:45 <jmcarthur> heh
14:01:47 <MissPiggy> if I were to write something in SK I would first write it in lambda and translate it
14:02:15 <jmcarthur> SK is not as unintuitive as it at first may seem, i think
14:02:16 <kmc_> that translation can have exponential size blowup
14:02:41 <kmc_> to avoid this, you can encode your lambda term in a non-executable way, and append it to a fixed size lambda calculus interpreter
14:02:42 <MissPiggy> monochrom, oh sorry - I didn't mean function level programming in general isn't programming, just that one thing -- wherhe you write f+g instead of \x -> f x + g x
14:02:48 <monochrom> MissPiggy: That's just because you receive more training in one of them.
14:03:19 <MissPiggy> monochrom it could be true but I feel like it is actually easier to program in lambda... for one thing it is a superset
14:03:49 <jmcarthur> MissPiggy: the point is that if you say \f g -> f + g then that function can apply to *any* instance Num generically, which happens to include functions returning numbers
14:03:58 <jmcarthur> *instance of Num
14:04:48 <monochrom> There is an application of f+g in differential geometry (the manifold and germ and atlas way). It is crucial.
14:05:01 <jmcarthur> MissPiggy: if i have a function that calculates the area of a circle but then instead of passing the radius as a parameter i pass a time function of the radius of a circle then i can get the time function of the area of that circle
14:05:08 <MissPiggy> I don't know differential geometry :S
14:05:15 <jmcarthur> that's just an example
14:05:37 <monochrom> This is why when people know more they have less opinion.
14:06:07 <Alpounet> heh
14:06:40 <bo0ts__> Ke, I'm a little lost. I have a list of functions and like to apply each function to the same list.
14:06:54 <bo0ts__> Is there a #haskell-noob ?
14:06:55 <aavogt> @type zip
14:06:56 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
14:07:04 <aavogt> @type zipWith ($)
14:07:04 <kmc_> bo0ts__: you're in it :)
14:07:04 <lambdabot> forall b b1. [b -> b1] -> [b] -> [b1]
14:07:18 <jmcarthur> :t (*^)
14:07:19 <lambdabot> forall (f :: * -> *) a. (Num a, Applicative f) => f a -> f a -> f a
14:07:28 <Botje> bo0ts__: map (\f -> f list) functions
14:07:46 <MissPiggy> anyway I still don't get function level programming
14:07:48 <bo0ts__> Botje: Argh, I knew it. Thank you.
14:08:05 <MissPiggy> thou shalt not touch anything that isn't an arrow
14:08:16 <MissPiggy> why?
14:08:19 <kmc_> @yarr
14:08:20 <lambdabot> This is the END for you, you gutter-crawling cur!
14:08:27 <sohum> I don't know what's going on
14:08:46 <Alpounet> :t map ($ [1,2,3])
14:08:47 <lambdabot> forall b t. (Num t) => [[t] -> b] -> [b]
14:08:56 <jmcarthur> > let area r = const pi *^ r *^ r ; let f = sin in area f <$> [0.0,0.5 ... 6]
14:08:57 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
14:09:07 <jmcarthur> > let area r = const pi *^ r *^ r in let f = sin in area f <$> [0.0,0.5 ... 6]
14:09:08 <lambdabot>   Not in scope: `...'
14:09:12 <jmcarthur> > let area r = const pi *^ r *^ r in let f = sin in area f <$> [0.0,0.5 .. 6]
14:09:13 <lambdabot>   [0.0,0.72209144937841,2.2244782490504638,3.1258729040093853,2.5975373254803...
14:09:19 <Alpounet> :t map (\f -> f [1,2,3])
14:09:20 <lambdabot> forall t b. (Num t) => [[t] -> b] -> [b]
14:09:29 <sohum> I have :set -fbreak-on-exception and :set args as needed, and am :trace main to find out where this error is coming from, and the history is a) not consistent and b) never points to a module which could've thrown that error in the first place
14:10:07 <jmcarthur> would be a lot nicer to just say "let area r = pi*r^2" and still have that work
14:10:31 <MissPiggy> ..
14:10:44 <Veinor> > let area r = pi * r * r in area 2
14:10:45 <lambdabot>   12.566370614359172
14:10:45 <MissPiggy> btw
14:10:46 <jmcarthur> because then i can used *any* already-defined area function
14:10:57 <MissPiggy> lifting * and stuff to functions is just one way
14:11:02 <jmcarthur> Veinor: yeah, but we don't have the instance for lifted functions
14:11:18 <jmcarthur> MissPiggy: it's the only way to get the overloading
14:11:19 <MissPiggy> well now I am a bit confused by what monochrom was sayying
14:11:24 <MissPiggy> I mean in math
14:11:35 <MissPiggy> you can just write r = r(t)
14:11:43 <MissPiggy> and then area(r) is a function of t
14:11:50 <jmcarthur> but we don't want that
14:12:00 <jmcarthur> what if we just want to apply area to a constant?
14:12:03 <MissPiggy> I am not sure exactly how this syntax phenomena works
14:12:14 <jmcarthur> with lifted functions, we can use the same definition for both
14:12:20 <monochrom> I don't do that in math either. In differential geometry, when I do f+g, I am not doing the like of r=r(t).
14:12:24 <jmcarthur> since the type of area is just Num a => a -> a
14:13:06 <theorbtwo> Hm.
14:13:21 <theorbtwo> It feels like you should be able to do better then that.
14:13:42 <theorbtwo> LinearMeasure a => a -> a*a
14:13:51 <jmcarthur> huh?
14:14:05 <MissPiggy> dimension types are pretty cool
14:14:17 <jmcarthur> oh i see
14:14:19 <MissPiggy> all that group theory comes into type inference/checking
14:14:24 <theorbtwo> jmcarthur: Length and area aren't just numbers.  They have units; they are different types.
14:14:30 <jmcarthur> yeah, but that can still just rely on Num in the end
14:14:33 <jmcarthur> right
14:14:54 <theorbtwo> jmcarthur: You shouldn't be able to add 5 cm and 3 kg.
14:14:56 <MissPiggy> monochrom do you think anyone did a formal treatment of the r = r(t) stuff?
14:15:12 <jmcarthur> theorbtwo: we are really just talking about the utility of a Num instance for functions, like http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16656
14:15:13 <theorbtwo> MissPiggy: The problem is that you can't use a*a as a type in haskell.
14:15:40 <theorbtwo> Ah, I see what you mean.
14:15:54 <jmcarthur> oh that's Maybe
14:15:59 <jmcarthur> but you get the point
14:16:13 <jmcarthur> s/Maybe/(->)/
14:18:03 <MissPiggy> and what is the difference between function level and Tacit programming
14:18:39 <jmcarthur> tacit == point free?
14:19:32 <jmcarthur> the difference is that tacit programming is purely syntactic, but the ability to use lifted functions in the same places you could otherwise use constants is actually more generic
14:19:58 <jmcarthur> any function i define for Num can be automatically applied to functions of numbers instead of just numbers
14:20:16 <jmcarthur> without any change to type or implementation at all
14:20:34 <zachk> > let dotProduct a b = sum (zipWith (*) a b) in dotProduct [1..3] [5..8]
14:20:35 <MissPiggy> I don't get this
14:20:36 <lambdabot>   38
14:20:36 <MissPiggy> :[
14:20:45 <zachk> ok how do i make that pointfree?
14:21:07 <ddarius> @pl let dotProduct a b = sum (zipWith (*) a b) in dotProduct [1..3] [5..8]
14:21:07 <lambdabot> sum (zipWith (*) [1..3] [5..8])
14:21:08 <MissPiggy> dotProduct = sum .: (zipWith (*))
14:21:16 <ddarius> Hah
14:21:27 <MissPiggy> where .: is some operator that does what you want
14:21:36 <Veinor> @pl \a b -> sum (zipWith (*) a b)
14:21:36 <lambdabot> (sum .) . zipWith (*)
14:21:42 <MissPiggy> (f .: (*)) x y = f (x * y)
14:21:45 <jmcarthur> > let dotProduct = (fmap.fmap) sum (zipWith (*)) in dotProduct [1..3] [5..8]
14:21:46 <lambdabot>   38
14:22:19 <Alpounet> now write with SKI combinators
14:22:24 <Alpounet> +it
14:22:38 <ddarius> (.:) = (.) . (.)
14:22:52 <ddarius> Alpounet: It's BBB.
14:22:54 * zachk brain starts bleeding
14:22:54 <MissPiggy> (.) . (.) is whhy I don't understand function level programing
14:23:17 <Alpounet> :t (.) . (.)
14:23:19 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
14:23:21 <Alpounet> should be easier now.
14:23:33 <idnar> :t let (.) = Prelude.(.) in (.) . (.)
14:23:34 <lambdabot> Not in scope: data constructor `Prelude'
14:23:36 <jmcarthur> Alpounet: if the inputs are ziplists, we have functions lifted to Num, and sum works on ziplists, then it's just: sum $ [1..3] + [5..8]
14:23:36 <BONUS> its easier to view it as result.result
14:23:39 <BONUS> and the SEC approach
14:23:41 <jmcarthur> ;)
14:23:45 <ddarius> idnar: (Prelude..)
14:23:52 <idnar> :t let (.) = (Prelude..) in (.) . (.)
14:23:53 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
14:23:57 <idnar> ddarius: right, that always confuses the heck out of me
14:24:03 <Alpounet> jmcarthur, heh
14:24:11 <jmcarthur> where i mean for the [1..3] syntax to mean a ZipList, not a normal list
14:24:21 <Alpounet> jmcarthur, yeah I got it
14:24:34 <MissPiggy> since expressions are just trees, right
14:24:36 <jmcarthur> grr
14:24:45 <jmcarthur> and i meant we have *ziplists* lifted to Num
14:24:46 <MissPiggy> and say you have a tree with n-variables
14:24:49 <BONUS> > let result = (.) in (result.result.first.first.map) ord (\x y -> (([x,x,x],y),y)) 'a' 33
14:24:50 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
14:24:50 <lambdabot>    arising from the literal `3...
14:25:05 <MissPiggy> you want to define an n-ary function by making some kind of crazy combinator expression that builds the trees with all the holes in the places and right order
14:25:16 <Alpounet> BONUS, you are insane
14:25:18 <Alpounet> :-p
14:25:19 <jmcarthur> MissPiggy: (.) . (.) is not going to be instantly understandable to anybody who has never seen that pattern before
14:25:21 <pikhq> MissPiggy: Just a function that takes a function of one argument and a function of two arguments, then threads two more arguments through the second and the first function.
14:25:33 <idnar> (.) . (.) is still garbage to me, but looking at the type makes it clear
14:25:41 <MissPiggy> that seems ridiculous to do without something like CCG
14:25:42 <BONUS> Alpounet: haha :D
14:25:45 <Twey> You can work it out, though.
14:25:47 <MissPiggy> maybe CCG is the solution?
14:25:47 <BONUS> weird, that worked in my ghci
14:25:51 <jmcarthur> CCG?
14:25:52 <pikhq> Yeah, it's the type that makes it clear.
14:26:01 <Twey> Or the expansion.
14:26:06 <idnar> but honestly, I'd probably just use a lambda most of the time
14:26:09 <kmc_> > let f .: g = \x y -> f (g x y) in (succ .: (+)) 2 3
14:26:10 <lambdabot>   6
14:26:13 <MissPiggy> jmcarthur, basic idea is that instead of having  a -> b,  you have a/b and a\b
14:26:16 <kmc_> it'd be nice if .: were well known
14:26:21 <jmcarthur> :t (.:)
14:26:23 <lambdabot> Not in scope: `.:'
14:26:23 <kmc_> if it's not well known, it's obscure to use it
14:26:26 <idnar> although I must still look at semantic editor combinators some more
14:26:46 <MissPiggy> jmcarthur, so there's two different function types - one for left application and one for right applcation:  Now I can define infix operators with type  (X\X)/X
14:26:50 <MissPiggy> for example
14:26:52 <Twey> I always feel that .: should take three arguments.
14:27:00 <jmcarthur> oh, so fixity is captured in the type?
14:27:05 <Alpounet> damn
14:27:05 <jmcarthur> that seems odd to me
14:27:26 <Alpounet> btw, is there a page/whatever listing the most known/used combinators, like Y, SKI, ...
14:27:36 <MissPiggy> jmcarthur, it's an approach to giving derivations for natural language (and includes ambiguity)
14:27:43 <jmcarthur> ah, i see
14:28:00 <jmcarthur> MissPiggy: see, you fit right in here
14:28:01 <MissPiggy> you can compute semantics for sentences with it -- i.e. turn SK trees into lambda terms
14:28:31 <MissPiggy> maybe function level programming would be bearable with something like that
14:29:44 <jmcarthur> MissPiggy: functional programming becomes easier when you start treating functions as atomic values themselves instead of as things that still need arguments
14:30:10 <MissPiggy> yeah but what does functional programming have to do with function level programming
14:30:20 <jmcarthur> i think i am missing the distinction
14:30:31 <jmcarthur> are you still on lifting functions to Num?
14:30:35 <MissPiggy> no
14:30:38 <MissPiggy> that was just one example
14:30:42 <tromp> i just thought i read UndeniableInstances somewhere
14:30:51 <monochrom> hehehe
14:31:03 <jmcarthur> MissPiggy: what is the meaning of "function level programming" as you are using it?
14:34:14 <tomberek> best way to go from [Maybe a]->[a] ?
14:34:28 <Veinor> map fromJust
14:34:32 <MissPiggy> haha
14:34:33 <tomberek> (I know they will all be Just
14:34:35 <tomberek> ok,, thanks
14:34:44 <MissPiggy> concat
14:35:38 <jmcarthur> if you know they will all be Just you could say: fromJust . sequence
14:35:40 <medfly> @index catMaybes
14:35:40 <lambdabot> Data.Maybe
14:35:48 <jmcarthur> where sequence must come from Data.Foldable
14:35:58 <monochrom> @hoogle [Maybe a] -> [a]
14:35:58 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
14:35:58 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
14:35:58 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
14:35:59 <jmcarthur> :t catMaybes
14:36:00 <lambdabot> forall a. [Maybe a] -> [a]
14:36:07 <jmcarthur> i guess that's best though :)
14:36:30 <dons> it would be nice to have a shootout for haskell xml libs
14:38:02 <Alpounet> @src catMaybes
14:38:03 <lambdabot> catMaybes ls = [x | Just x <- ls]
14:38:06 <dino-> catMaybes is safer, I thought. Throws out the «Nothing»s
14:38:17 <Alpounet> indeed
14:38:37 <dolio> @type (>>= maybeToList)
14:38:37 <jmcarthur> right
14:38:38 <lambdabot> forall b. [Maybe b] -> [b]
14:39:46 <jmcarthur> > fail "ZOMG" :: Maybe Int
14:39:47 <lambdabot>   Nothing
14:40:17 <jmcarthur> > fail "ZOMG" :: [Int]
14:40:18 <lambdabot>   []
14:42:20 <perverthaskell> what is best hash out there these days?
14:43:13 <jmcarthur> perverthaskell: for what?
14:43:41 <tomberek> I have two typclasses A and B.  A just has function declarations.  I want B to set one of those functions to a default function
14:43:57 <perverthaskell> strings
14:44:06 <jmcarthur> tomberek: which requires which?
14:44:11 <sizur> @i mapM_
14:44:11 <tomberek> but I'm getting "eva" is not a (visible) method of class B
14:44:11 <lambdabot> Maybe you meant: id ignore index instances instances-importing irc-connect . ? @ v
14:44:16 <jmcarthur> perverthaskell: you mean this is for a hash table?
14:44:24 <tomberek> class A => B
14:44:26 <sizur> :t mapM_
14:44:27 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
14:44:28 <m3ga> where does one report bugs in packages on hackage?
14:44:32 <perverthaskell> the murmurhash?
14:44:34 <jmcarthur> perverthaskell: i recommend a trie for string keys, not a hash table ;)
14:44:35 <MissPiggy> I don't know, I can't tell if this is really obvious and I'm just not seeing it or if it's pretty deep and I don't have the foundations
14:44:56 <perverthaskell> no I am looking at implenting one
14:44:56 <tomberek> jmcarthur B requires A
14:45:01 <jmcarthur> MissPiggy: if what is obvious?
14:45:10 <jmcarthur> perverthaskell: in haskell?
14:45:10 <MissPiggy> this stuff about FP
14:45:20 <jmcarthur> this "stuff"...
14:45:51 <sizur> what does forall a (m :: * -> *) b. mean?
14:46:12 <Alpounet> m3ga, either email the authors or search if they have a bug tracker or so
14:46:18 <jmcarthur> tomberek: you can't do that, but you can have fooDefault :: B a => a -> ... defined separately and then use that in instances of A
14:47:00 <m3ga> Alpounet: hmm, less than optimal :-)
14:47:02 <jmcarthur> sizur: it means a and b are types, but m is a type constructor (must be applied to a type in order to be a type)
14:47:13 <Alpounet> sizur, it means for all type a, parametrized (by one type) type m, type b
14:47:15 <perverthaskell> jmcarthur: well that depends. Maybe I'll do it directly in haskell or in C and have fun with linking that up to haskell
14:47:19 <monochrom> The best hash for strings is don't-use-hash. Hashing doesn't scale to long strings.
14:47:28 <jmcarthur> sizur: could also be expressed as forall (a :: *) (m :: * -> *) (b :: *).
14:48:09 <perverthaskell> the best thing is a hash combined with a Trie
14:48:09 <sizur> that helps. thanks jmcarthur and Alpounet.
14:48:13 <dino-> Ah, I was just thinking that next, does that then mean the a and b are implied kind *
14:48:18 <perverthaskell> but I just want a hash algorithm
14:48:29 <jmcarthur> perverthaskell: well, regardless, i still recommend going with something other than a hash table, unless this is just an exercise, in which case i wouldn't worry about which hash function to use
14:48:41 <monochrom> Binary search trees, finger trees, tries... they scale because most of the time you just look at the first few characters of the string and you already find the node or declare not-in-there.
14:48:56 <jmcarthur> dino-: yeah they are implied * afaik
14:49:01 <monochrom> Hashing means you look at all 300 characters of your string before anything. Dumb.
14:49:26 <jmcarthur> i'm a fan of tries for this kind of thing
14:49:45 <jmcarthur> compares the minimal number of characters
14:49:46 <perverthaskell> yeah I am not disagreeing here, but I am going to write a hash
14:49:47 <sizur> doesnt m :: * -> * implied by the type signature? or does lambdabot simply show what's derived?
14:49:50 <jmcarthur> okay
14:50:09 <jmcarthur> i'm out of date on hash algorithms too. i can only think of jenkins
14:50:31 <jmcarthur> sizur: it is, but lambdabot gives the foralls anyway
14:50:35 <perverthaskell> I am as well
14:52:01 <sizur> jmcarthur: thanks
14:53:34 <sizur> so am i correct in learning that in haskell we can only differentiate kinds based on the number of type arguments?
14:53:58 <jmcarthur> sizur: besides ghc primitives, yes, i think
14:54:17 <Alpounet> jmcarthur, regarding tomberek's question. Is there really no way to provide a default def for a function being in a typeclass in a deriving typeclass ?
14:54:19 <jmcarthur> for example, the kind for (->) is kind of weird
14:54:21 <doserj> sizur: number *and kind* of type arguments
14:54:28 <jmcarthur> :k (->)
14:54:30 <lambdabot> ?? -> ? -> *
14:54:36 <sproingie> :k weird
14:54:37 <lambdabot> Not in scope: type variable `weird'
14:54:38 <benmachine> :k ReaderT
14:54:39 <lambdabot> * -> (* -> *) -> * -> *
14:54:46 <jmcarthur> sizur: oh yeah, doserj is right. monad transformers are a good example for that
14:55:05 <jmcarthur> sproingie: haha
14:55:10 <pikhq> ... How exactly does the (->) kind work?!?
14:55:20 <jmcarthur> pikhq: it's magic and you shouldn't worry about it
14:55:36 <benmachine> pikhq: ?? and ? are supersets of * that include some unboxed types iirc
14:55:38 <pikhq> jmcarthur: But curiosity compels me!
14:55:44 <pikhq> benmachine: Ah.
14:55:47 <sizur> so we have a few kinds of types of kinds (lol)
14:55:48 <lispy> pikhq: the ?? and ? kinds are special kinds that GHC uses for implementation reasons
14:56:04 <jmcarthur> these kinds are the only subtyping i know of in haskell
14:56:12 <jmcarthur> is there subtyping anywhere else?
14:56:16 <lispy> pikhq: it's documented, but normally you don't need to know what they are about
14:56:33 <lispy> jmcarthur: you can emulate subtyping with classes
14:56:41 <jmcarthur> yeah, well, that's not language level
14:57:01 <Alpounet> Oleg inside heh
14:57:10 <sizur> :k fmap
14:57:11 <lambdabot> Not in scope: type variable `fmap'
14:57:26 <sizur> :f Functor.fmap
14:57:34 <sizur> :k Functor.fmap
14:58:05 <lambdabot> parse error on input `Functor.fmap'
14:58:05 <Twey>  :k is for types
14:58:05 <Twey> fmap is a value
14:58:05 <Twey> :k (,)
14:58:05 <lambdabot> * -> * -> *
14:58:05 <Twey> :k Maybe
14:58:05 <lambdabot> * -> *
14:58:05 <sizur> sorry for flooding.  prolly drank one class too much of whine...
14:58:11 <Twey> That sort of thing
14:58:18 <benmachine> (,) is a type and a value just to confuse you
14:58:20 <jmcarthur> :t fmap
14:58:21 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:58:43 <solrize> :k (->)
14:58:44 <lambdabot> ?? -> ? -> *
14:59:10 <jmcarthur> i never understood why (,) is syntax instead of a normal operator
15:01:19 <sizur> :k Functor
15:01:19 <lambdabot> Class `Functor' used as a type
15:01:19 <sizur> :k Functor []
15:01:19 <lambdabot> Class `Functor' used as a type
15:01:19 <jmcarthur> :k []
15:01:19 <lambdabot> * -> *
15:01:19 <Twey> jmcarthur: Because ‘a, b’ doesn't form a tuple
15:01:19 <benmachine> jmcarthur: it has to be syntax for [a,b,c] and it's probably simpler to make it so for (a,b,c)
15:01:19 <sizur> sorry guys. i'll stop :)
15:01:19 <Twey> The brackets are part of the syntax
15:01:19 <jmcarthur> Twey: that's circular logic :P
15:01:19 <jmcarthur> benmachine:  we could have just used ; for lists
15:01:19 <jmcarthur> Twey: i get that, but is there a *reason* for it?
15:01:19 <benmachine> ugly
15:01:19 <Twey> That's horrible, IMO
15:01:19 <solrize> why is :k ->  not * -> * -> (*->*)    ?
15:01:19 <Twey> There's some other language that does that
15:01:19 <Twey> What was it?
15:01:19 <Twey> MATLAB or something?
15:01:19 <Twey> Or M-exprs?
15:01:19 <Alpounet> sizur, Functor is a typeclass, not a (parametrized) data type
15:01:19 <Twey> Does MATLAB use M-exprs?
15:01:19 <benmachine> solrize: eer, because it takes two concrete types and makes a concrete type?
15:01:19 <Alpounet> whereas [], Maybe, ReaderT and so on are.
15:01:19 <solrize> twey ,does what?  make a,b  a tuple?  python does that
15:01:31 <Twey> solrize: And Python syntax is crazy with regards to ,
15:01:42 <Twey> No, I meant about semicolons for lists
15:01:47 <sproingie> yay for (,)
15:01:49 <solrize> benmachine, [] takes a concrete type and makes another concrete type
15:01:55 <jmcarthur> [a;b;c;d;e] is not so ugly, IMO
15:01:55 <solrize> twey, i think mathematica uses semicolons for lists
15:01:59 <benmachine> solrize: hence it's * -> *
15:02:01 <sproingie> er (1,)
15:02:03 <Twey> Ah, maybe that was it
15:02:28 <solrize> benmachine, you mean [] ?
15:02:31 <benmachine> mmhm
15:02:40 <benmachine> a function can't return Maybe or [] (types)
15:02:48 <benmachine> no wait
15:02:51 <benmachine> that's not what I meant
15:02:52 <sizur> return
15:02:55 <Twey> Hehe
15:03:04 <benmachine> * -> * -> (* -> *) is the same as * -> * -> * -> * anyway
15:03:16 <jmcarthur> compare [(a, b), (c, d), (e, f), (g, h)] to [a, b; c, d; e, f; g, h]
15:03:16 <benmachine> and (->) doesn't accept three type parameters
15:03:17 <benmachine> QEd
15:03:17 <Twey> (->) can't return Maybe or [] (type constructors)
15:03:20 <Twey> Did you mean that?
15:03:20 <benmachine> D
15:03:26 <Twey> QEdD!
15:03:26 <benmachine> more or less, Twey
15:03:27 <jmcarthur> i like the latter
15:03:35 <benmachine> d-d-demonstrandum
15:03:41 <Twey> Hehe
15:03:49 <Twey> jmcarthur: The former is much more obvious to me
15:03:50 <solrize> :k Maybe
15:03:51 <lambdabot> * -> *
15:03:53 <benmachine> jmcarthur: I don't, the delimitation is much less clear
15:03:57 <Twey> I had to look twice to even see the commas in the latter
15:04:03 <jmcarthur> you could use the parens optionally
15:04:10 <Twey> I just automatically parsed them all as semicolons
15:04:12 <solrize> oh right, *->*->*
15:04:19 <jmcarthur> or spacing
15:04:25 <Twey> Plus, what do you do about triples?
15:04:27 <jmcarthur> [a,b; c,d; e,f; g,h]
15:04:43 <monochrom> What's wrong with 2D layout? Throw away plain text file already.
15:04:50 <benmachine> heh
15:05:00 <Twey> We have 2D layout already :þ
15:05:04 <jmcarthur> hmm, yeah, i guess this would also mean we do away with triples in favor of ((a,b),c) or (a,(b,c))
15:05:24 <jmcarthur> which is something i'd rather do anyway
15:05:27 <benmachine> I reckon those types are identical for practical purposes
15:05:35 <Twey> I guess so
15:05:50 <benmachine> , is used for pattern guards
15:05:52 <lunabot>  luna: Not in scope: `is'
15:05:53 <benmachine> as well
15:05:56 <benmachine> shh luna
15:06:00 <Twey> And you can just right-infix ,
15:06:03 <jmcarthur> [a,b,c; d,e,f; g,h,i] seems perfectly nice to me
15:06:03 <Twey> Hmm
15:06:04 <pikhq> jmcarthur: ((a,b),c) looks suspicously like a:b:c:[]
15:06:13 <jmcarthur> pikhq: you mean the other way
15:06:19 <jmcarthur> (a, (b, c))
15:06:21 <benmachine> oh, and in import lists although I guess that's not a big deal
15:06:26 <Twey> Still don't like those semicolons :þ
15:06:29 <pikhq> Well. Right.
15:06:34 <sizur> hi lambdabot
15:06:40 <jmcarthur> pikhq: it's like HList
15:06:50 <sizur> oh, the fun is disabled
15:06:54 <Twey> Can't we use something nicer instead?  I like colons.
15:06:59 <benmachine> @vixen hi
15:06:59 <lambdabot> hiya
15:07:06 <sizur> ah this is it :)
15:07:09 <jmcarthur> Twey: colons are problematic as long as they are valid operators
15:07:09 <Twey> I guess that's confusing.
15:07:34 <jmcarthur> not clear from syntax alone whether something is a list of lists or whatever
15:07:39 <Twey> Well, I was thinking that they needn't be, but of course that's a problem for nested lists in which one is defined using bracket-sugar and one with conses
15:07:57 <Twey> Maybe #
15:08:01 <jmcarthur> ew
15:08:13 <benmachine> what was wrong with , again
15:08:15 <Twey> [ a, b, c # d, e, f # g, h, i ]
15:08:18 <Twey> Hm
15:08:22 <benmachine> ew seconded
15:08:24 <Twey> Ugly, but beats the semicolon
15:08:28 <jmcarthur> benmachine: we're speculating about what we'd do to make , a normal operator
15:08:35 <jmcarthur> i like the semicolon better than that
15:09:00 <benmachine> jmcarthur: I think that for the sake of my poor eyes I'm okay with giving up ,
15:09:13 <benmachine> it just makes things prettier
15:09:19 <jmcarthur> [a, b, c][d, e, f][g, h, i]
15:09:31 <benmachine> oh, clauses in list comprehensions
15:09:34 <benmachine> also separated by commas
15:09:41 <jmcarthur> works as long as we never apply arguments to lists :P
15:09:50 <jmcarthur> benmachine: semicolons man
15:09:52 <jmcarthur> ;)
15:10:01 <benmachine> you and your semicolons
15:10:08 <jmcarthur> the only difference between a semicolon and a comma is a dot
15:10:13 <sizur> lol
15:10:14 <Alpounet> in OCaml you have tons of them
15:10:23 <jmcarthur> Alpounet: and erlang
15:10:43 <jmcarthur> not that i think they put them to good use
15:10:45 <Alpounet> in the OCaml toplevel you have to end your lines with ";;" :D
15:10:51 <jmcarthur> same for erlang
15:10:55 <Alpounet> oh
15:11:00 <Alpounet> wise choice
15:11:04 <Alpounet> for some definition of wise
15:11:49 <sizur> @djinn wise
15:11:49 <lambdabot> -- f cannot be realized.
15:11:52 <Twey> jmcarthur: What?
15:11:55 <Twey> Erlang uses .
15:11:58 <jmcarthur> am i wrong?
15:12:00 <jmcarthur> OH
15:12:02 <jmcarthur> right
15:12:04 <jmcarthur> i'm dumb now
15:12:09 <Twey> Heh
15:12:15 <monochrom> Do you not like [[a,b,c], [c,b,d], [b,a,d]]?
15:12:16 <Twey> It uses ; within the top-level .
15:12:17 <jmcarthur> prolog-based
15:12:22 <Twey> I don't think it uses ;; anywhere
15:12:24 <Twey> Yeah
15:12:26 * Philonous wonders what would be a suitable audio backend for haskell programms. Phono is KDE specific. Maybe gstreamer?
15:12:28 <Alpounet> then the difference between Haskell and OCaml is Erlang ?
15:12:41 <HugoDaniel> :D
15:12:46 <jmcarthur> monochrom: me?
15:12:53 <HugoDaniel> Haskell - OCaml = Erlang :D
15:13:04 <HugoDaniel> this could be funny
15:13:04 <sizur> the difference between A and B is difference.
15:13:09 <monochrom> I guess. All of you who are discussing newfangled matrix notation.
15:13:10 <jmcarthur> monochrom: i'm talking about liberating the comma from haskell syntax and making it a valid operator. requires alternative to syntax using comma
15:13:29 <Twey> monochrom: That would be a list of lists, not a list of tuples
15:13:45 <Twey> (unless you're suggesting something really crazy)
15:14:27 <Twey> jmcarthur: We could do it the other way around — have *tuples* use new syntax
15:14:50 <jmcarthur> all the good operators for tuples are taken :(
15:14:54 <Twey> > let ( # ) = (,) in [1 # 2, 3 # 4]
15:14:55 <lambdabot>   [(1,2),(3,4)]
15:15:10 <Alpounet> ugly :/
15:15:10 <jmcarthur> ugh
15:15:16 <srush> my program crashes with <<loop>>
15:15:21 <srush> what's up with that
15:15:26 <monochrom> A very old version of theorem prover HOL uses # for tuples. Precisely like that.
15:15:27 <Twey> > let infixr #; ( # ) = (,) in [0 # 1 # 2, 2 # 3 # 4]
15:15:28 <lambdabot>   [(0,(1,2)),(2,(3,4))]
15:15:30 <ivanm> srush: there's an infinite loop in your logic somewhere
15:15:30 <sizur> @djin loop
15:15:31 <lambdabot> Maybe you meant: djinn djinn-add djinn-clr djinn-del djinn-env djinn-names djinn-ver
15:15:53 <sizur> :t Maybe
15:15:55 <lambdabot> Not in scope: data constructor `Maybe'
15:15:55 <srush> at the type level?
15:16:02 <Twey> srush: No
15:16:06 <ivanm> in the code
15:16:09 <c_wraith> @djinn (a -> b) -> (b -> c) -> a -> c
15:16:09 <lambdabot> f a b c = b (a c)
15:16:42 <benmachine> Twey: doesn't actually reclaim , then :P
15:16:58 <sizur> @djinn theultimatequestion -> Int
15:16:59 <lambdabot> Error: Undefined type Int
15:17:12 <Twey> benmachine: But it doesn't need to
15:17:15 <sizur> still some time to go
15:17:31 <monochrom> srush: You have some infinite loop or cyclic mistake.
15:17:38 <c_wraith> @@ pl djinn (b -> c) -> (a -> b) -> a -> c
15:17:38 <lambdabot>  pl djinn (b -> c) -> (a -> b) -> a -> c
15:17:43 <benmachine> well we don't need to at all >_>
15:17:46 <c_wraith> @. pl djinn (b -> c) -> (a -> b) -> a -> c
15:17:47 <lambdabot> f = (.)
15:17:52 <ddarius> Particularly a viciously infinite value.
15:18:13 <Twey> benmachine: Well, we do, because it's currently a) magic syntax and b) magic syntax that's horribly defined up to a fixed limit
15:18:33 <benmachine> what is a genially infinite value
15:18:47 <benmachine> Twey: oh, agreed on the second point
15:18:57 <c_wraith> fix ("have a nice day.  " ++)
15:18:58 <benmachine> but I reckon we can fix that without changing how it looks
15:19:01 <Apocalisp> @hoogle (Functor f) => forall b c. a b c -> a (f b) (f c)
15:19:01 <lambdabot> Prelude unzip :: [(a, b)] -> ([a], [b])
15:19:01 <lambdabot> Data.List unzip :: [(a, b)] -> ([a], [b])
15:19:04 <c_wraith> that's a genially infinite value
15:19:16 <Apocalisp> @hoogle (Arrow a, Functor f) => forall b c. a b c -> a (f b) (f c)
15:19:17 <lambdabot> Prelude unzip :: [(a, b)] -> ([a], [b])
15:19:17 <lambdabot> Data.List unzip :: [(a, b)] -> ([a], [b])
15:19:23 <benmachine> I think we should have , as infixr and (a,b,c) as sugar for (a,(b,c))
15:19:25 <benmachine> or something similar
15:19:41 <benmachine> so then you don't get duplicate instances etc.
15:20:11 <sizur>  #haskell rules
15:20:14 <jmcarthur> benmachine: if it's infixr then we don't need the sugar
15:20:29 <jmcarthur> (a,b,c) == (a,(b,c)) already
15:20:31 <Twey> benmachine: …
15:20:34 <benmachine> jmcarthur: hmm, I suppose so
15:20:47 <benmachine> I was thinking for pattern matches but I guess they work too
15:20:49 <Twey> Really?
15:20:58 <Twey> > (1, 2, 3) == (1, (2, 3))
15:20:59 <lambdabot>   Couldn't match expected type `(t, t1, t2)'
15:20:59 <lambdabot>         against inferred type `(...
15:21:01 <Twey> Lies
15:21:04 <benmachine> heh
15:21:11 <jmcarthur> Twey: that's because we don't have nice tuple syntax :P
15:21:19 <jmcarthur> or semantics
15:21:22 * Twey 'splode
15:21:22 <copumpkin> (1, (2, (3, ()))
15:21:26 <benmachine> heh
15:21:29 <Alpounet> :D
15:21:34 <Twey> copumpkin: One-tuples are useless, though
15:21:45 <Twey> Zero-tuples, maybe not :þ
15:21:51 <jmcarthur> they are useful for things like HList
15:21:53 <benmachine> python has one-tuples with (a,)
15:21:54 <copumpkin> Twey: doesn't mean we shouldn't support them... I'm sure it would leave some nasty special cases in generic algorithms
15:21:57 <benmachine> and then people laugh at python
15:22:04 <Twey> Hehe
15:22:20 <Twey> copumpkin: Do we want generic algorithms over tuples?
15:22:27 <Twey> I guess we do.
15:22:31 <MissPiggy> yeah in mathematics people tend to just equate all associativities of tupling
15:22:36 <Alpounet> tuple folding, and all
15:22:44 <Dashkal> @unmtl StateT Maybe
15:22:45 <lambdabot> err: `StateT Maybe' is not applied to enough arguments, giving `/\A B. Maybe -> A (B, Maybe)'
15:23:04 <copumpkin> Twey: don't see why not
15:23:16 <Dashkal> @unmtl StateT (Either String)
15:23:16 <lambdabot> err: `StateT (Either String)' is not applied to enough arguments, giving `/\A B. Either String -> A (B, Either String)'
15:23:21 <c_wraith> @unmtl StateT String Maybe
15:23:22 <lambdabot> err: `StateT String Maybe' is not applied to enough arguments, giving `/\A. String -> Maybe (A, String)'
15:23:38 <c_wraith> @unmtl StateT String (Maybe Int)
15:23:38 <lambdabot> err: `StateT String (Maybe Int)' is not applied to enough arguments, giving `/\A. String -> Maybe Int (A, String)'
15:23:49 <c_wraith> @unmtl StateT String Maybe Int
15:23:49 <lambdabot> String -> Maybe (Int, String)
15:23:52 <c_wraith> Right, there
15:23:57 <Dashkal> aha
15:24:22 <Dashkal> Using newtype to hide the guts of a transformer stack and I forgot what runStateT ended up looking like
15:25:41 <benmachine> look it up in ghci? :P
15:25:53 <benmachine> :t runStateT
15:25:54 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
15:25:55 <Dashkal> It's not written yet, I'm making type signatures
15:26:09 <Dashkal> s/,/;
15:26:31 <Twey> That's amusing
15:26:41 <benmachine> dominating my what?!?!?
15:26:55 <Twey> I think that was a very poor attempt at part-spam
15:27:01 <jmcarthur> haha
15:27:20 <Twey> benmachine: YOUR ENEMIES!
15:27:35 <Twey> (though the inclusion of a chat client seems a rather odd choice)
15:27:36 <benmachine> oh
15:27:39 <idnar> haha
15:27:49 <idnar> Twey: how else will you /find/ your enemies?
15:27:56 <jmcarthur> Twey: botnets are commonly controlled via IRC
15:27:57 <Twey> Oh yeah!  Silly me.
15:27:58 <idnar> or make them, for that matter
15:28:17 <benmachine> anyone want to become my enemy? immunity from domination not guaranteed
15:28:19 <idnar> nothing says "BLOOD FEUD" like kickbanning someone from #leethaxors!
15:28:25 <Twey> jmcarthur: That's true, but would you actually market it as a ‘very unique chat client’?
15:28:28 <jmcarthur> Twey: bots join a channel and somebody can give them commands via IRC, and they relay messages to each other via other channels, etc.
15:28:34 <jmcarthur> i dunno, maybe?
15:28:48 <benmachine> oh hey firefox is 100%ing my CPU
15:28:53 <benmachine> thanks, firefox!
15:29:02 <Twey> benmachine: Depends — can I get domination guaranteed?  :þ
15:29:05 <Alpounet> chrome's a bit better at that
15:29:09 <jmcarthur> that's not a nice thing to do to a CPU
15:29:36 * sproingie 100%s your mom
15:29:42 <benmachine> Twey: ô_ó
15:29:44 <damd> why let so much CPU time go to waste?  i say anything below 100% is a waste.
15:30:00 <Twey> Haha
15:30:18 <jmcarthur> i once considered calling "cpu usage" "efficiency" instead
15:30:23 <benmachine> heh
15:30:31 <medfly> lol
15:30:44 <sproingie> firefox is efficienting me to death
15:30:49 <ddarius> damd: There are clients that will use your spare CPU cycles for something potentially useful.
15:30:50 <jmcarthur> but it's not necessarily correct since it could just be a useless infinite loop
15:31:03 <sproingie> but it's being useless efficiently
15:31:11 <jmcarthur> correct
15:31:27 <damd> ddarius: what spare CPU cycles?  i'm using firefox.  :|
15:31:36 <sproingie> otherwise it would require several more loops to be as efficiently wasteful
15:31:42 <ddarius> damd: In that case, you'd just be a particularly useless node.
15:32:03 <jmcarthur> but really, 100% cpu means you aren't stuck on memory or IO bottlenecks, therefore... efficiency
15:32:30 <jmcarthur> but that probably means CPU is the bottleneck instead :P
15:33:18 <benmachine> if only this CPU wasn't so slow I could infinite loop even more effectively?
15:33:40 <jmcarthur> exactly
15:33:49 <jmcarthur> > sum [1..]
15:33:54 <lambdabot>   mueval-core: Time limit exceeded
15:34:12 * jmcarthur wonders how easy it would be to DoS lambdabot
15:34:19 <benmachine> probably not hard at all
15:34:24 <benmachine> so, don't :P
15:34:26 <c_wraith> Does @pl still work for that?
15:34:30 <damd> don't tempt me to do the old flip trick on it
15:34:38 <benmachine> there was a bug in @pl that got fixed
15:35:07 <damd> @pl \a b c d -> d c b a
15:35:07 <damd> ?!?!?!
15:35:08 <lambdabot> flip (flip . (flip .) . flip (flip . flip id))
15:35:08 <lambdabot> Unknown command, try @list
15:35:33 <benmachine> @pl \a b c d -> d a b c
15:35:34 <lambdabot> (flip .) . flip . flip id
15:35:56 * benmachine wonders if the reversal is always the longest result
15:36:14 <benmachine> I reckon, maybe?
15:36:19 <damd> benmachine: in characters?
15:36:21 <monochrom> Oh that is a sorting problem!
15:36:32 <benmachine> damd: in... length?
15:36:35 <benmachine> characters I suppose
15:36:43 <damd> yes
15:36:44 <benmachine> but function calls'd be just as good
15:36:55 <benmachine> if not better
15:37:00 <damd> probably better
15:37:06 <benmachine> harder to count though
15:37:12 <benmachine> not much
15:37:16 <damd> for some meaning of better
15:37:18 <benmachine> but harder nonetheless
15:37:19 <jmcarthur> words
15:37:39 <benmachine> how about just instances of flip, id, or .
15:37:47 <jmcarthur> or maybe filter (==' ')
15:38:00 <benmachine> maybe
15:38:27 <jmcarthur> could also go for depth... deepest nesting of parens
15:39:03 <damd> that only works in lisp
15:39:13 <jmcarthur> ah yeah
15:39:21 <jmcarthur> no mandatory parens here
15:39:26 <jmcarthur> well, less
15:39:40 <jmcarthur> *fewer
15:39:52 <Apocalisp> Question about arrows. Why do they have "first" rather than (Functor f, Arrow a) => a b c -> a (f a) (f b)
15:40:27 <jmcarthur> you mean second?
15:40:33 <Apocalisp> yeah, that too
15:40:37 <Twey> :t (***)
15:40:41 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
15:40:44 <jmcarthur> looks like your function is generalized fmap
15:41:12 <jmcarthur> it's not as handy as it looks. i tried it in alt-stdlib
15:41:18 <jmcarthur> something like it anyway
15:41:27 <Apocalisp> @src (***)
15:41:27 <lambdabot> f *** g = first f >>> second g
15:41:59 <Apocalisp> @type fmap f >>> fmap g
15:42:00 <lambdabot>     Ambiguous type variable `b' in the constraints:
15:42:00 <lambdabot>       `SimpleReflect.FromExpr b'
15:42:00 <lambdabot>         arising from a use of `f' at <interactive>:1:5
15:42:04 <jmcarthur> well, it's handy, but it can be complex to use
15:42:14 <Apocalisp> @type \f g -> fmap f >>> fmap g
15:42:15 <lambdabot> forall a b (f :: * -> *) b1. (Functor f) => (a -> b) -> (b -> b1) -> f a -> f b1
15:43:13 <BONUS> :t \f g -> fmap $ f . g
15:43:14 <lambdabot> forall a b (f :: * -> *) a1. (Functor f) => (a1 -> b) -> (a -> a1) -> f a -> f b
15:43:38 <jmcarthur> Apocalisp: check this one out for size: http://patch-tag.com/r/jmcarthur/alt-stdlib/snapshot/current/content/pretty/Control/Arrow.hs
15:43:53 <jmcarthur> i think that's a bit out of date to my local copy. don't remember. i'm not at home
15:44:32 <BONUS> :t (.).(.) (fmap . (.))
15:44:33 <lambdabot> forall a (f :: * -> *) (f1 :: * -> *) a1 b (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => (a -> a1 -> b) -> f a -> f (f1 (f2 a1) -> f1 (f2 b))
15:45:13 <jmcarthur> Apocalisp: turns out i am still doing something similar to your proposal
15:45:17 <jmcarthur> but with bifunctors
15:45:23 <ddarius> Apocalisp: You would need two (***) which is essentially what you are looking for two capture its two possible definitions.
15:45:27 <Apocalisp> jmcarthur: I like it.
15:45:30 <ddarius> :t fmap *** fmap
15:45:30 <lambdabot> forall a b (f :: * -> *) a1 b1 (f1 :: * -> *). (Functor f, Functor f1) => (a -> b, a1 -> b1) -> (f a -> f b, f1 a1 -> f1 b1)
15:47:21 <ddarius> Actually, X :: (Functor f, Arrow a) => a b c -> a (f b) (f c) is something else entirely.
15:47:46 <jmcarthur> it's fmap lifted to categories
15:47:54 <ddarius> jmcarthur: Which is something else entirely.
15:48:02 <jmcarthur> yes
15:48:48 <ddarius> There "should" be a generalized functor class, not a method on Arrow.  I actually define a class sort of like that in my Monad Reader article.
15:49:09 <jmcarthur> yeah: http://patch-tag.com/r/jmcarthur/alt-stdlib/snapshot/current/content/pretty/Control/Functor.hs
15:49:39 <Apocalisp> oh, awesome
15:50:20 <jmcarthur> Apocalisp: the magic is (slowly) happening in #alt-stdlib if you like this stuff :)
15:50:43 <Apocalisp> I shall lurk
15:50:51 <dons> ?tell gwern drift-cabalized broken under 6.12 (missing ghc package)
15:50:52 <lambdabot> Consider it noted.
15:59:38 <monochrom> God, two articles in TMR that uses GADT.
16:01:46 <ddarius> Inductive families are all the rage.
16:01:47 <lpsmith> monochrom, don't like GADTs?
16:02:15 <monochrom> Just exclaiming.
16:02:42 <monochrom> This is the United Nation Year of GADT. :)
16:06:09 <Baughn> Hm. Threadscope requires ghc 6.12, right?
16:07:48 <Baughn> monochrom: If I say "data Foo a where Bar :: Serialize a => a -> Bar a", that makes an existential, right?
16:11:41 <monochrom> That may be invalid altogether on the technicality that you don't end with "-> Foo something"
16:12:37 <ddarius> Baughn: No
16:12:37 <monochrom> Suppose you have Ctor0 :: Serialialize a => a -> Foo a. That is not existential.
16:12:45 <jmcarthur> data Foo a where Bar :: Serialize a => a -> Foo a  -- doesn't look like an existential to me
16:13:17 <ddarius> Baughn: If you dropped the 'a' from 'Bar a' (which I assume you meant 'Foo a') it would be.
16:13:19 <jmcarthur> data Foo a where Bar :: Serialize a => a -> Foo () -- does
16:13:41 <Baughn> Ah. Hm.
16:13:42 <ddarius> And I guess you'd need to drop the a from the beginning.
16:13:45 <ddarius> (in my case)
16:13:59 <ddarius> I'd recommend using the explicit kind signatures for GADTs.
16:14:08 <Baughn> ..but they're so ugly. ;_;
16:14:15 <monochrom> Suppose you have Ctor1 :: (forall a. Serialize a => somethingsomething) -> Foo somethingelse. Then it is existential.
16:14:18 <ddarius> Baughn: Not as ugly as meaningless names.
16:14:59 <_> Better?
16:15:17 <jmcarthur> monochrom: that's not rank n polymorphism?
16:15:18 <monochrom> > let foo _ _ = 0 in foo 0 0
16:15:20 <lambdabot>   0
16:15:29 <monochrom> Does that highlight you? :)
16:15:45 <Baughn> monochrom: It didn't, actually
16:15:55 <jmcarthur> s/rank n/higher rank/
16:16:08 <monochrom> It is both rank-n and existential.
16:16:13 <jmcarthur> o_O
16:16:21 <jmcarthur> how can it be both?
16:17:02 <jmcarthur> doesn't "Ctor1 :: (forall a. Serialize a => somethingsomething) -> Foo somethingelse" mean that the argument must be bindable with any instance of Serialize? not that it can be *some* instance of it?
16:17:25 <jmcarthur> unifiable, maybe i mean...
16:18:05 <monochrom> You are right. delete "forall a ."  Now we just have what ddarius says.
16:18:20 <jmcarthur> right
16:18:27 <monochrom> delete some parentheses too.
16:19:31 <lispy> :t (>=>)
16:19:32 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
16:19:37 <lispy> :t (>>>)
16:19:38 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
16:19:57 <lispy> ?hoogle (>>>)
16:19:57 <lambdabot> Control.Arrow (>>>) :: Category cat => cat a b -> cat b c -> cat a c
16:19:57 <lambdabot> Control.Category (>>>) :: Category cat => cat a b -> cat b c -> cat a c
16:20:11 <lispy> HXT also has a (>>>) with a similar looking type
16:42:12 <balboa02> I'm going through the Parsec tutorial, the EBNF expressions at the beginning of the Expression section has me stumped. Can anyone explain that? http://is.gd/7bEGQ
16:43:24 <Axman6> what's the problem?
16:43:25 <CalJohn> i'm guessing you haven't encountered BNF before?
16:43:46 <Raevel> bad normal form
16:43:55 <CalJohn> http://en.wikipedia.org/wiki/Backus–Naur_Form#Introduction
16:44:11 <mauke> that's not an ascii dash
16:44:12 <Axman6> the first line says that an expr is either another expr followed by a literal + followed by a term, or just a term
16:47:10 <balboa02> CalJohn: I've read that entry, but I'm for whatever reason not able to apply that to the content on the parsec page
16:47:31 <monochrom> lispy: HXT's is Arrow's.
16:47:50 <CalJohn> ok, so BNF grammars are made up of two kinds of things: terminals and non-terminals
16:48:17 <applicative> an expression is either a term, or else an expression followed by '+' followed by a term
16:48:22 <CalJohn> terminals are things that are literal, like '+' - they are literally part of the syntax
16:48:32 <lispy> monochrom: So, other than the types is (>=>) different than (>>>)?
16:48:32 <balboa02> CalJohn: so I don't take up all your time, specifically what is vexing me in the infix usage of (+)
16:49:10 <CalJohn> ok, so that rule matches an expression, followed by a '+' followed by a term
16:49:13 <CalJohn> what's vexxing?
16:49:34 <monochrom> They do the same thing because if your arrow is also ArrowApply your arrow is a monad too. HXT's arrows are ArrowApply.
16:49:37 <balboa02> CalJohn: well, that (+) and (*) appear paired with expr and term respectively
16:50:06 <CalJohn> it's not haskell source
16:50:09 <balboa02> CalJohn: I figured that they would be defined both as expr
16:50:47 <applicative> what will be defined as an expr?
16:52:08 <ddarius> (>>>) is (>=>) for Arrows that are Kleisli arrows.
16:52:34 <applicative> '*' and '+' are not expressions in this grammar, they are used to make expressions.
16:53:15 <balboa02> applicative: so why exactly is (+) used in the expr definition but (*) used in the term definition?
16:53:26 <applicative> the simple expressions are terms, the simple terms are  'factors', the simple factors are sequences of digits
16:53:42 <monochrom> To enforce operator precedence.
16:53:48 <sohum> @pl \x -> f . g (h x)
16:53:48 <lambdabot> (f .) . g . h
16:54:28 <applicative> balboa, what monochrom said
16:54:35 <applicative> its a bit of a trick really.
16:54:43 <SANDERS_> what is the best haskell package for writing a simple 2d game?
16:55:40 <balboa02> applicative, monochrom: thanks. So its written like that not out of necessity but to be clever?
16:56:08 <monochrom> I don't see why the two are mutually exclusive.
16:56:08 <CalJohn> are there any haskell editors other than emacs and vim that can do haskell auto-indentation?
16:56:24 <monochrom> Necessity is the mother of cleverness.
16:57:23 <applicative> they could probably do with a simpler example to begin with.
16:57:25 <balboa02> monochrom: not mutually exclusive, but if you're trying to write a tutorial it may not be best idea (depending on your intended audience, which I am guessing I am not)
16:57:57 <balboa02> CalJohn: leskah?
16:58:14 <balboa02> CalJohn: leksah rather
16:58:46 <CalJohn> yeah, i'm reccomending this to a friend who's just starting out though, that's not so suitabl
16:58:50 <applicative> it would be easier to understand if the grammar forced uses of '*' and '+' to come with brackets.  But that would be a pretty ugly grammar.
16:59:00 <applicative> Or rather, an ugly symbolism
16:59:46 <monochrom> Since it is a necessity, you cannot avoid it by signing it off as cleverness.
17:00:17 <ddarius> balboa02: You could also write: expr ::= digits+ | '(' expr ')' | expr + expr | expr * expr, but that would be highly ambiguous, would not represent the precedence, and would not map to a working parser.
17:00:17 <applicative> I take back what I said about cleverness
17:00:19 <monochrom> If the tutorial uses a grammar having only one operator (+), you will say it teaches you nothing, I theorize.
17:00:59 <monochrom> And if the grammar has two operators, it will have precedence issues and it has to do this.
17:01:46 <applicative> This is the way to represent the standard operator precedence, you're forced to it.
17:01:48 <applicative> I see
17:01:50 <ddarius> balboa02: For example, that grammar allows (n-1)! ways of parsing a1 + a2 + ... + an.
17:01:50 <monochrom> The grammars of Algol, C, Pascal... they all do this, and they have to all do this. This is a 40-year old method.
17:02:26 <ddarius> balboa02: By comparision, the more structured grammar in the document allows only one.
17:03:18 <balboa02> applicative: "Programming in Haskell" defines it in a different way, which is how I would think about it: expr ::= expr + expr | term; term ::= term ∗ term | factor; factor ::= (expr ) | nat; nat ::= 0 | 1 | 2 | ···
17:03:20 <applicative> The passage would be clearer if they simply said they were trying to represent the familiar operator precedence
17:03:54 <ddarius> balboa02: That BNF wouldn't work for a recursive descent parser, such as Parsec.
17:04:48 <ddarius> balboa02: If you naively translated that to Parsec code you'd get: expr = (expr >> symbol "+" >> expr) <|> term which is an infinite recursion.
17:04:50 <balboa02> ddarius: is that what is being defined in the Programming in Haskell version? I'm guessing I will need to familiarize myself better with the concepts
17:04:56 <monochrom> Even if this is the first time you look at grammars, it is not that hard to see. The key is to never answer your pressing questions directly; instead to turn what ddarius says into questions asked back to you: "let's say do it the way you expect, flatten it out, what do you get?"
17:05:58 <applicative> All of this is showing that balboa02 is basically right.  The reader doesn't anticipate such a subtle problem at this point.  A bit more signposting would help.
17:06:08 <ddarius> I recommend what (I think) monochrom is saying.  Work through some parsing problems by hand.  Try to find all parses for some simple examples using different grammars.
17:06:52 <ddarius> applicative: The Parsec documentation is not an introduction to parsing.
17:07:00 <balboa02> monochrom: I worked through the previous problems by hand, but my lack of understanding of what they were trying to achieve was kind of a show-stopped
17:07:12 <applicative> It was mine, pretty much...
17:07:12 <applicative> ha
17:07:25 <ddarius> applicative: If the "easier" grammars were used, they would not be translatable to Parsec.
17:08:22 <applicative> No, it's a great grammar, a great example, textbook.  It's just a question of the writing.  They don't prepare you to take account of the problem in question.
17:08:52 <monochrom> Perhaps the Parsec tutorial should be written in Chinese, so I don't have to learn English first. I mean, sheesh.
17:09:36 <sshc> what is the most portable way to define a number that contains the biggest number possible in a floating point number?
17:09:57 <balboa02> monochrom: granted, however there is something to be said for enabling a user to get their foot somewhat in the door - armed with that knowledge they may be better able to continue their studies
17:10:02 <ddarius> applicative: Actually, the grammar is specifically there to account for a totally different problem.  Again, it's not trying to explain BNF at all, it's assuming you already have a basic handle on it.
17:10:17 <ddarius> > maxBound :: Float
17:10:18 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Types.Float)
17:10:18 <lambdabot>    arising from a use of...
17:10:29 <applicative> Why should balboa02 have been tripped up; it doesn't sound like he's stupid.  Much light would have been cast on the passage if they began by saying that the standard grammar for + and *
17:10:41 <applicative> That could be imparted to someone without BNF
17:10:50 <sshc> ddarius: what should I use?
17:11:06 <sshc> > 9.9E999999999
17:11:11 <applicative> this is the BNF way of representing it, which maps nicely to a parsec parser
17:11:11 <lambdabot>   mueval: ExitFailure 1
17:11:19 <sshc> > 9.9E99999
17:11:21 <lambdabot>   Infinity
17:11:22 <ddarius> "Consider the following standard EBNF grammar for expressions: "
17:11:32 <sshc> > 9.9E999
17:11:33 <lambdabot>   Infinity
17:11:50 <sshc> > 9.9E450 :: Float
17:11:52 <lambdabot>   Infinity
17:12:02 <sshc> > 9.9E100 :: Float
17:12:02 <ddarius> applicative: Actually, the example they produce there -doesn't- map nicely to Parsec.  It's there to discuss left-recursion elimination and how that can be handled in Parsec.
17:12:03 <lambdabot>   Infinity
17:12:15 <sshc> float doesn't seem to be very precise
17:12:25 <sshc> > 9.9E60 :: Float
17:12:26 <lambdabot>   Infinity
17:12:28 <sshc> > 9.9E40 :: Float
17:12:29 <lambdabot>   Infinity
17:12:38 <sshc> > 9.9E20 :: Float
17:12:39 <monochrom> Float is about 23 or 24 bits of mantissa.
17:12:40 <lambdabot>   9.9e20
17:12:52 <sshc> > 9.9E30 :: Float
17:12:53 <lambdabot>   9.9e30
17:12:59 <sshc> > 9.9E35 :: Float
17:13:00 <lambdabot>   9.9e35
17:13:04 <sshc> > 9.9E50
17:13:06 <lambdabot>   9.9e50
17:13:10 <sshc> > 9.9E50 :: Float
17:13:11 <lambdabot>   Infinity
17:13:12 <sshc> I see
17:13:13 <applicative> I see that now.   But the point is only about the writing.  The ordinary plus and times grammar we use, has a special rule of precedence.  To represent it, we put it in this BNF.... If they
17:13:15 <monochrom> I mean, does anyone here go through a proper CS curriculum any more?
17:13:31 <sshc> never been through any CS curriculum
17:13:46 <applicative> had said this, they wouldn't have tripped up the reader.
17:13:56 <copumpkin> monochrom: not sure, what counts as proper? I think mine was fairly proper but it's hard to say :P
17:14:21 <applicative> Whats CS?    I learned BNF in a set theory class.
17:14:36 <monochrom> copumpkin: If you have seen both BNF and floating point formats, you're good enough for today.
17:14:51 <copumpkin> as in the IEEE 754 bit layout?
17:14:57 <monochrom> Yeah.
17:15:00 * ddarius pretty much didn't go through a CS curriculum at all.
17:15:15 <monochrom> In fact just knowing how many bits go into what.
17:15:20 <copumpkin> monochrom: ah, but why not throw some formal language theory and algorithms in there too?
17:15:34 <copumpkin> monochrom: I'd say all of those would make a pretty decent curriculum
17:16:16 <monochrom> Perhaps tomorrow you just need to know how to add and multiply polynomials and you will be good enough to be said as "has proper CS curriculum". And who knows, the day after tomorrow you just need to add numbers.
17:17:25 <monochrom> Next week you just need to draw commuting diagrams.
17:17:49 <m0nkfish> in our CS course they teach us the fundamentals so if you need to find out about this stuff you can understand it
17:18:08 <ddarius> applicative: I don't feel that even adding that phrase to the documentation would have much impact.  The vast majority of people either are 1) familiar with probably exactly that example, or 2) completely unfamiliar with BNF.
17:19:28 <balboa02> monochrom: well, I was a psych major ... without a proper cs curriculum, and the environment that academia affords you, ones learning course isn't always planned
17:21:24 * hackagebot upload: Crypto 4.2.1 - Collects together existing Haskell cryptographic functions into a package (CreightonHogg)
17:21:41 <CalJohn> most actual CS courses aren't about CS anyway, they are about Software Engineering
17:21:50 <m0nkfish> hmmm
17:22:00 <m0nkfish> i dont agree
17:22:04 <m0nkfish> at least, not in my experience
17:24:02 <etpace> I have a function (Random a, Num a, Enum a) => a -> a -> Int -> IO [(a,a)], and another Fractional a => [(a,a)] -> a, but when doing first >>= second, I get a type error asking to add other classes sucha s Random (IO b) and I need a FlexibleContexts pragma for it, have I made am istake along the way
17:25:23 <xerox> etpace have you fully applied the first function to its arguments?
17:26:09 <etpace> hmm yes
17:27:08 <xerox> possibly the first argument is an 'IO b' value?
17:27:24 <xerox> or actually, try this
17:27:37 <xerox> liftM second (first ...)
17:28:47 <etpace> aha, now it talks of ambiguous type variable 'a', asking for Fractional, Integral and Random a
17:28:51 <balboa02> applicative, monochrom, ddarius: thanks for your help
17:30:56 <xerox> etpace so the problem now is that you return an Enumerable thing, but Float/Double (Fractionals) aren't
17:31:08 <etpace> Aha
17:31:46 <mreh> how could I split a string at a particular character?
17:32:43 <xerox> no that's not it etpace, they are in Enum
17:32:48 <kmc_> mreh: see 'split' on hackage
17:33:20 <etpace> the second argument of first should be an Enum, id ont think the rest have to be
17:33:59 <kmc_> CalJohn: at my school we had no courses in software engineering at all
17:34:07 <kmc_> a lot of schools teach "programming" which is neither SE nor CS
17:34:19 <xerox> etpace dunno but "fractional and integral" sounds like you need fromIntegral
17:34:29 <kmc_> learning how to use the hot plate is neither chemical engineering nor chemistry
17:34:34 <gwern> mreh: split once, or split many times?
17:34:35 <lambdabot> gwern: You have 1 new message. '/msg lambdabot @messages' to read it.
17:34:38 <gwern> @messages
17:34:38 <lambdabot> dons said 1h 43m 46s ago: drift-cabalized broken under 6.12 (missing ghc package)
17:34:43 <sshc> @quote cowardlydragon
17:34:43 <lambdabot> cowardlydragon says: [from a reddit comment thread] Don't get me started on monad. What is that, a man with a single testicle?
17:34:44 <mreh> gwern, once
17:34:50 <kmc_> hehehe
17:34:52 <gwern> @hoogle break
17:34:52 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
17:34:52 <lambdabot> Data.ByteString break :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
17:34:52 <lambdabot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
17:35:03 <mreh> aaah
17:35:29 <gwern> @tell dons as I said, I don't have 6.12 and I don't plan to upgrade any time soon, so these reports arent very helpful
17:35:29 <sshc> > fix break
17:35:29 <lambdabot> Consider it noted.
17:35:30 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
17:35:34 <sshc> > fix break
17:35:36 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
17:35:43 <sshc> > fix error
17:35:44 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
17:35:47 <ezyang> h'ok, more gtk2hs hacking tonight!
17:36:29 <ezyang> Is the actionmenu demo supposed to work?
17:36:30 <sshc> @qutoe sshc work
17:36:30 <lambdabot> sshc says: that worked well!
17:37:33 <monochrom> ezyang: Thank you for your article in TMR. Many years ago when "prompt monad" started in haskell-cafe, I found it too specific and I paid no attention. I read your article and I see its fully glory, it's pretty nice.
17:37:41 <gwern> @quote gwern
17:37:42 <lambdabot> gwern says: the best way to optimize a program is to make it lazier or stricter.
17:37:56 <ezyang> monochrom: Thanks! ^^
17:38:29 <uorygl_> @type on
17:38:30 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
17:38:51 <medfly> @type foldr
17:38:52 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
17:38:58 <medfly> @djinn forall a b. (a -> b -> b) -> b -> [a] -> b
17:38:58 <lambdabot> Error: Undefined type []
17:39:01 <medfly> :(
17:39:22 <uorygl_> Hmm. I want (a -> a -> b) -> (b -> c) -> a -> a -> c, I think.
17:39:35 <medfly> @hoogle (b -> b -> c) -> (a -> b) -> a -> a -> c
17:39:36 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
17:39:36 <lambdabot> Data.Data gmapQr :: Data a => (r' -> r -> r) -> r -> (d -> r') -> a -> r
17:39:36 <lambdabot> Data.Data gmapQl :: Data a => (r -> r' -> r) -> r -> (d -> r') -> a -> r
17:39:47 <medfly> oh, oops
17:39:54 <medfly> @hoogle (a -> a -> b) -> (b -> c) -> a -> a -> c
17:39:54 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
17:39:55 <lambdabot> Control.Parallel.Strategies parZipWith :: Strategy c -> (a -> b -> c) -> [a] -> [b] -> [c]
17:39:55 <lambdabot> Data.Data gmapQr :: Data a => (r' -> r -> r) -> r -> (d -> r') -> a -> r
17:40:06 <kmc_> @djinn (a -> a -> b) -> (b -> c) -> a -> a -> c
17:40:06 <lambdabot> f a b c d = b (a c d)
17:40:19 <medfly> :]
17:40:20 <uorygl_> @pl f a b c d = b (a c d)
17:40:20 <lambdabot> f = flip ((.) . (.))
17:40:25 <uorygl_> Wow.
17:40:26 <medfly> boobies!
17:40:34 <medfly> sorry
17:40:36 <uorygl_> I don't like boob functions.
17:40:45 <uorygl_> @type (((/= 0) .) . gcd)
17:40:46 <lambdabot> forall a. (Integral a) => a -> a -> Bool
17:41:02 <uorygl_> > nubBy (((/= 0) .) . gcd) [2..]
17:41:06 <lambdabot>   mueval-core: Time limit exceeded
17:41:12 <uorygl_> > take 5 $ nubBy (((/= 0) .) . gcd) [2..]
17:41:16 <lambdabot>   mueval-core: Time limit exceeded
17:41:22 <uorygl_> > nubBy (((== 0) .) . gcd) [2..]
17:41:23 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
17:41:34 <xerox> > [2..]
17:41:35 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
17:41:42 <uorygl_> Those look like the prime numbers to me!
17:41:46 <Apocalisp> @djinn (Monoid m, Monoid m2) => (((s, Maybe v) -> m) -> (m -> v2) -> Set k -> (((s, Maybe (k -> v)) -> m2), m2 -> Maybe (k -> v2))
17:41:46 <lambdabot> Cannot parse command
17:41:48 <uorygl_> > nubBy (((== 1) .) . gcd) [2..]
17:41:49 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
17:41:51 <xerox> you've got more primes than me
17:41:59 <uorygl_> > nubBy (((/= 1) .) . gcd) [2..]
17:42:00 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
17:42:08 <uorygl_> I think I finally got 'em.
17:42:25 <medfly> :)
17:42:37 <CalJohn> m0nkfish: sorry about the delay:  we probably disagree because we have differing definitions of CS.  Do you consider "programming" to be a part?
17:43:07 <CalJohn> kmc_: frankly, a lot of schools (all, possibly) teach a lot of junk really.
17:43:15 <kmc_> yeah
17:43:22 <kmc_> people learn on their own
17:43:30 <kmc_> classes mostly just force people to learn on their own
17:43:32 <kmc_> by having assignments
17:43:38 <CalJohn> they do currently, i don't think it really has to be that way
17:43:39 <medfly> lol
17:43:46 <medfly> is there learning that is not on your own
17:44:21 <uorygl_> @type ((.) . (.) . (.))
17:44:22 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
17:44:31 <CalJohn> on reflection, no.  but universities should have to virtue that the point people in interesting directions and provide a culture that supports their courses
17:44:31 <uorygl_> ...Functors?
17:44:35 <uorygl_> @type (.)
17:44:36 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
17:44:40 <medfly> :o
17:44:40 <medfly> yeah...
17:44:50 <uorygl_> lambdabot, what are you coming to?
17:44:57 <ezyang> uorygl: yup
17:44:59 <medfly> (.) = fmap
17:45:07 <ezyang> uorygl_: We're having fun with operators!
17:45:18 <CalJohn> my university does not point in enough interesting directions
17:45:21 <uorygl_> > (I think you're almost at the point where you'll attain sapience if fed enough English text.)
17:45:22 <lambdabot>   <no location info>: parse error on input `where'
17:45:27 <medfly> @type (++)
17:45:28 <lambdabot> forall m. (Monoid m) => m -> m -> m
17:45:36 <kmc_> @vixen (I think you're almost at the point where you'll attain sapience if fed enough English text.)
17:45:36 <lambdabot> where else would i be?
17:45:40 <medfly> @type Prelude.(++)
17:45:41 <lambdabot> Not in scope: data constructor `Prelude'
17:45:46 <medfly> @type (Prelude.++)
17:45:47 <lambdabot> forall a. [a] -> [a] -> [a]
17:45:51 <uorygl_> > (I think you're almost at the point whereat you'll attain sapience if fed enough English text.)
17:45:52 <lambdabot>   <no location info>: parse error on input `if'
17:46:05 <uorygl_> > (I think you're almost at the point whereat you'll attain sapience when fed enough English text.)
17:46:06 <lambdabot>   Not in scope: data constructor `I'Not in scope: `think'Not in scope: `you'r...
17:46:11 <medfly> @wn sapience
17:46:13 <lambdabot> *** "sapience" wn "WordNet (r) 2.0"
17:46:13 <lambdabot> sapience
17:46:13 <lambdabot>      n : ability to apply knowledge or experience or understanding or
17:46:13 <lambdabot>          common sense and insight [syn: {wisdom}]
17:46:25 <CalJohn> [sentience, surely? Ed.]
17:46:43 <medfly> @vixen hello!
17:46:43 <lambdabot> hiya
17:46:46 <uorygl_> Sentience and sapience mean different things.
17:46:51 <medfly> @vixen are you a human?
17:46:51 <lambdabot> nope, i'm a girly
17:46:57 <uorygl_> My cat is sentient, but she is not sapient.
17:46:57 <medfly> :-)
17:47:13 <medfly> cats are pretty smart.
17:47:21 <medfly> @vixen I think you're almost at the point whereat you'll attain sapience when fed enough English text.
17:47:22 <lambdabot> yup, that's where i am
17:47:27 <CalJohn> uorygl_: now I know :)
17:47:34 <medfly> uorygl_, do you like that? :-)
17:47:46 <uorygl_> @vixen is pretty neat.
17:47:46 <lambdabot> why do you keep repeating yourself?
17:48:13 <medfly> @vixen
17:48:14 <lambdabot> yeah, why not?
17:49:24 <uorygl_> @vixen, is it okay if I put a comma here?
17:49:24 <lambdabot> yeah, it's okay
17:50:26 <theorbtwo> @vixen, how much wood could a wood chuck chuck if a wood chuck could chuck wood?
17:50:26 <lambdabot> how? it depends...
17:55:40 <joem86> evening everyone... I'm going through YAHT on wikibooks, and I'm at the exercise for the fibinacci sequence.
17:56:04 <joem86> to test, I need to call fib inside of my main function
17:56:32 <medfly> what is yaht?
17:56:38 <medfly> oh, neve rmind
17:56:38 <medfly> I can guess
17:56:46 <Zao> Yet Another Haskell Trombone.
17:56:58 <joem86> but neither calling the function nor calling show(fib 5) work
17:56:59 <medfly> :-)
17:57:03 <medfly> nono
17:57:05 <joem86> lol
17:57:08 <medfly> just fib 5
17:57:08 <Zao> @type show
17:57:09 <lambdabot> forall a. (Show a) => a -> String
17:57:28 <Zao> show just makes a String out of something Show'able.
17:57:48 <monochrom> main = print (fib 5)
17:57:49 <joem86> ok, I'll try that
17:57:52 <Zao> If you want to print things, you probably want to invoke putStr or print (which shows internally)
17:57:57 <Zao> @src print
17:57:57 <joem86> I was using printstrln
17:57:57 <lambdabot> print x = putStrLn (show x)
17:58:13 <medfly> wait, why are you using IO for this?
17:58:22 <medfly> a better question.
17:58:24 <Zao> medfly: Because it's in his main?
17:58:25 <monochrom> because main program
17:58:29 <joem86> I can, but I was compiling to the executable
17:58:44 <Zao> ghci is for the weak, and the people with the luxury of registerised builds :P
17:58:50 <monochrom> main = putStrLn ("the answer is " ++ show (fib 5) ++ " this is really cool")
17:58:57 <joem86> the recursion tutorial came after the compile to executable tutorial
17:59:23 <joem86> main = putStrLn show(map fib [1..5])
17:59:31 <joem86> should show the first 5 fib numbers
17:59:42 <joem86> ohhh crap
17:59:43 <monochrom> parentheses problems
17:59:43 <joem86> i know
17:59:44 <Zao> Your parens do not associate the way you think.
18:00:09 <joem86> map(fib, [1..5])?
18:00:27 <monochrom> main = putStrLn (show (map fib [1..5]))
18:00:48 <mreh> joem86, haskell functions aren't called with parens
18:01:06 <joem86> okay, I see now
18:01:09 <Zao> @type (42, id, putStr)
18:01:10 <lambdabot> forall t a. (Num t) => (t, a -> a, String -> IO ())
18:01:23 <Zao> Commas in parenthesis construct tuples.
18:01:40 <joem86> I see, gotcha
18:02:04 <joem86> okay, that works. Thanks
18:02:29 <Zao> foo bar baz  associates to ((foo bar) baz). That is, apply foo to bar. Then apply that to baz.
18:03:16 <Philonous> you can actually do f(x,y) , and it would kind of do what you expect, but curried functions are the default because we like partial application
18:04:08 <Philonous> There are even function to convert between the two variants.
18:04:08 <Philonous> @type curry
18:04:09 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
18:05:04 <tommd1> > "Pong"
18:05:05 <lambdabot>   "Pong"
18:05:42 <joem86> f.g x <=> f(g(x)), right?
18:05:56 <Philonous> @botsnak
18:05:56 <Philonous> @bot
18:05:56 <Philonous> Oh dear.
18:05:56 <lambdabot> :)
18:05:56 <lunabot>  :o
18:05:56 <lunabot>  :o
18:05:56 <lambdabot> :)
18:06:02 <ezyang> joem86: no
18:06:10 <ezyang> (f.g) x, yes
18:06:42 <ezyang> f.g x is actually f . (g x)
18:06:51 <joem86> ohhh i see
18:07:04 <ezyang> "damn fixity"
18:07:47 <joem86> so printStrLn(show(map fib [1..5])) <=> to (printStrLn.show)(map fib [1..5])
18:08:16 <ezyang> right, or, more idiomatically
18:08:24 <ezyang> printStrLn . show $ map fib [1..5]
18:08:39 <xerox> print . map fib $ [1..5] -- I'd say
18:08:42 <Philonous> ($) - the "add parens"-operator
18:09:23 <joem86> interesting
18:12:05 <Axman6> ezyang: print =  putStrLn . show
18:12:38 <ezyang> Oh, right-o :-)
18:12:45 <ezyang> I just did the trivial transformation :-0
18:13:22 <SERBIA> ole ole
18:13:23 <SERBIA> muslimani
18:13:25 <SERBIA> mustafe
18:13:36 <copumpkin> @where ops
18:13:37 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver monochrom
18:13:48 --- mode: ChanServ set +o xerox
18:13:51 <tommd> gahh, wake all the ops!
18:14:10 <SERBIA> otju
18:14:12 <SERBIA> +
18:14:20 <Cordelio> Hello
18:14:28 <SERBIA> xerox de si brate
18:14:40 <Cordelio> O SERBIA where are you from
18:14:40 <copumpkin> is this a serbian attack?
18:14:41 --- mode: ChanServ set +o shapr
18:14:43 --- mode: xerox set +b *!*@*.dynamic.sbb.rs
18:14:46 <Cordelio> xaxax
18:14:49 --- kick: SERBIA was kicked by xerox (xerox)
18:14:50 <Cordelio> co mon
18:14:57 <tommd> Ooo, a second one.
18:14:58 <shapr> Thanks
18:15:01 <Cordelio> ups
18:15:03 --- kick: Cordelio was kicked by shapr (Kicked by shapr)
18:15:10 * xerox high fives
18:15:19 * shapr high fives xerox 
18:15:36 <tommd> But he reentered the room...
18:15:44 --- mode: ChanServ set +o monochrom
18:15:47 <shapr> Cordelio: This channel is about the programming language Haskell.
18:15:52 <shapr> Cordelio: Would you like to learn Haskell?
18:15:55 <tommd> Cordelio is a bot.
18:16:02 <Cordelio> what
18:16:03 --- mode: xerox set +b *!*@212.200.65.73
18:16:10 <shapr> Well then..
18:16:21 <shapr> Cordelio: Would you like to learn Haskell?
18:16:30 <shapr> Cordelio: Can you prove to me that you're a human?
18:16:41 <xerox> the clock is ticking
18:16:42 <tommd> "Cordelio:  Sure, call me at 1-900-..."
18:16:42 <copumpkin> not when he's banned
18:16:49 --- mode: xerox set -b *!*@212.200.65.73
18:16:53 <monochrom> I have just learned that if you place a ban, the target cannot speak.
18:16:57 <shapr> oh really?
18:16:58 <ezyang> If ghci is loading a module as "Prelude Main>" and I'd like to be in its namespace, i.e. "Main>", what do I have to do?
18:16:59 <shapr> huh
18:17:00 <xerox> monochrom weird.
18:17:13 <copumpkin> ezyang: :m - Prelude
18:17:21 <monochrom> I read it on freenode's website and then I empirically verified.
18:17:47 <Cordelio> picke
18:17:49 <Cordelio> picke
18:17:53 <Cordelio> majku vam jebem
18:17:57 <ezyang> Why does it depend on the existence of foo.hi and foo.o?
18:18:02 <xerox> But handy, I guess...
18:18:09 <monochrom> heh, you can restore the ban now :)
18:18:16 --- mode: xerox set +b *!*@212.200.65.73
18:18:36 <copumpkin> where's ivanm when you need him
18:18:50 --- mode: monochrom set -o monochrom
18:19:04 --- mode: xerox set -o xerox
18:19:57 <monochrom> ezyang: short story: :load *foo.hs
18:21:40 <monochrom> medium story: if compiled code is present and not outdated, compiled code is preferred for speed, but non-exported things are inaccessible (hey, it's compiled).
18:21:50 <monochrom> long story: http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-compiled.html
18:22:08 <medfly> :)
18:22:55 <ezyang> aha
18:23:01 <xerox> too-long-for-most-people story: http://darcs.haskell.org/ghc
18:23:45 <medfly> somewhat mathematical question
18:24:39 <medfly> if I have a list of random numbers, and I do map (\n-> n `mod` k) numbers for some k, is this still rather random, I'm just not so sure
18:24:55 <medfly> I think it is...
18:25:11 <etpace> xerox: hmm http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16689#a16689 even with a sprinking of fromIntegral I still get errors when trying to call, any ideas?
18:25:28 <xerox> you could call that one test of randomness, and also try in more dimensions
18:25:35 <sohum> medfly: it is still reasonably random, but possibly with a bias depending on whether the size of your initial range is divisble by k.
18:25:46 <medfly> ah
18:25:50 <sohum> medfly: (assuming a consecutive range)
18:25:55 <monochrom> Yes, only that problem.
18:26:02 <medfly> thanks
18:26:31 <uorygl_> medfly: if your initial range is divisible by k, it's completely unbiased; otherwise, it's slightly biased.
18:27:29 <xerox> etpace try this way, make the function take a list of random numbers as input, instead of doing the pure computations in IO
18:28:33 <medfly> @oeis 1,2,6,24,120
18:28:34 <lambdabot>  Factorial numbers: n! = 1*2*3*4*...*n (order of symmetric group S_n, number ...
18:28:34 <lambdabot>  [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,...
18:28:48 <medfly> I guess it'd be good to use a number like that if I intend to use small k :)
18:29:08 <joem86> okay guys, I have another noob question.
18:29:09 <joem86> http://haskell.pastebin.com/m6ea8832f
18:29:19 <joem86> I'm trying to implement the mult function
18:29:29 <joem86> and I'm running into type issues with my code
18:29:37 <Philonous> I look at the gstreamer documentation and I immediately see arrows. Haskell spoils your mind
18:29:50 <ezyang> what's the type of (+) good sir?
18:29:52 <joem86> I can't understand why, and I think it's due to my lack of understanding of haskell types
18:30:11 <Axman6> > map (+) [a,b,c]
18:30:12 <lambdabot>   Ambiguous occurrence `a'
18:30:12 <lambdabot>  It could refer to either `L.a', defined at <local...
18:30:14 <joem86> (+) afaik is a function in prefix notation
18:30:20 <aavogt> @type map
18:30:21 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
18:30:22 <idnar> @type (+)
18:30:23 <lambdabot> forall a. (Num a) => a -> a -> a
18:30:27 <Axman6> > map f [a,b,c]
18:30:28 <joem86> ohhh
18:30:28 <lambdabot>   Ambiguous occurrence `a'
18:30:28 <lambdabot>  It could refer to either `L.a', defined at <local...
18:30:33 <aavogt> joem86: you can only get a list out of the result of map
18:30:34 <Axman6> > map f [a,b,c] :: [Expr]
18:30:36 <lambdabot>   Ambiguous occurrence `a'
18:30:36 <lambdabot>  It could refer to either `L.a', defined at <local...
18:30:41 <Axman6> > map f [x,b,c] :: [Expr]
18:30:42 <lambdabot>   [f x,f b,f c]
18:30:52 <joem86> so there's no way haskell would know if it's a number type or something else
18:30:52 <idnar> @undef
18:30:56 <Axman6> > map f [a,b,c] :: [Expr]
18:30:57 <joem86> that makes sense
18:30:58 <lambdabot>   [f a,f b,f c]
18:31:05 <idnar> joem86: no, the problem is that (+) has too many arguments
18:31:21 <Axman6> map maps a functions o9nto every element of a list, it won't join the elements together
18:31:34 <Axman6> idnar: uh what?
18:31:35 <joem86> lol I was thinking foldr, my bad
18:31:40 <joem86> foldr or foldl is what I need
18:31:41 <Axman6> it hasn't got enough imo
18:31:49 <Axman6> you want foldl
18:31:54 <Axman6> or, just sum
18:31:54 <idnar> Axman6: huh?
18:32:00 <Axman6> > sum [1..10]
18:32:01 <lambdabot>   55
18:32:07 <idnar> Axman6: map with a function of two arguments gives you a list of functions
18:32:12 <joem86> the tutorial hasn't gotten to that part yet, so it's not allowed :-)
18:32:14 <idnar> Axman6: map with a function of one argument gives you a list of values
18:32:32 <aavogt> "all functions in haskell take only one argument"
18:32:37 <Axman6> yes, so (+) hasn't been applied to enough parameters
18:32:40 <aavogt> you're confusing me :)
18:33:07 <idnar> Axman6: perhaps I should have said "takes" instead of "has"
18:33:17 <Axman6> aye
18:33:20 <syntaxglitch> there's no such thing as a function of two arguments, it's just a shorthand for "a function of one argument that returns a function of one argument"
18:33:29 <medfly> :]
18:33:31 <idnar> syntaxglitch: hopefully everyone knows that's what I meant
18:33:52 <medfly> like tuples being (1,(2,(3,(4,(5,nil)))))
18:33:55 <idnar> anyway, yeah, fold is what was desired here
18:34:49 <Philonous> syntaxglitch: Well, that might be because 2 is just a shorthand for "succ 1"
18:35:19 <joem86> the correct code: http://haskell.pastebin.com/m6a6054dd
18:35:24 <joem86> thanks everyone!
18:35:40 <syntaxglitch> I thought 2 was a shorthand for \f x -> f $ f x
18:35:51 <ezyang> also, note
18:35:53 <ezyang> > [5..7]
18:35:55 <lambdabot>   [5,6,7]
18:37:10 <aavogt> > [5..7]::[Double]
18:37:11 <lambdabot>   [5.0,6.0,7.0]
18:37:53 <etpace> ah great, it works xerox
18:38:06 <xerox> etpace wonderful, purity++
18:38:37 <copumpkin> we should all get purity rings
18:38:53 <etpace> but the algorithm seems to break sometimes because I should be using a finite/galois field, which I don't really understand
18:39:00 <Axman6> joem86: also, makelist is just replicate
18:39:05 <Axman6> > replicate 3 4
18:39:06 <lambdabot>   [4,4,4]
18:39:06 <Philonous> syntaxglitch: Well yeah, in this case 0 = \f x -> x; succ = \n f x -> f $ n f x , 1 = succ 0 and 2 = succ 1
18:39:26 <joem86> ok, cool :-)
18:40:12 <zakwilson> I seem to have no Text.Regex having installed GHC 6.10.4 via apt on Ubuntu 9.10 amd64. Is there a known issue?
18:40:42 <syntaxglitch> Philonous, what are these "0" and "1" things, they don't look like functions to me, better to stuck with lambda abstractions
18:40:45 <xerox> etpace what about it?
18:41:02 <syntaxglitch> all these silly names for things
18:41:39 * syntaxglitch starts doing all his programming in the pure untyped lambda calculus
18:41:40 <Philonous> syntaxglitch: Point being that "functions of two variables" may be a shorthand, but I think it is too strong to say they don't exist.
18:42:17 <syntaxglitch> Philonous, I'm just joking btw :P
18:42:23 <etpace> I'm interpolating a polynomial, and I think I might be getting some floating point errors, especially when the coefficients of the polynomial are really large, but I don't really understand what a galois field is, or how itll stop this
18:43:49 <joem86> can I define a function as communitive?
18:43:55 <joem86> mult a b = mult b a
18:44:08 <medfly> commutative?
18:44:17 <syntaxglitch> When I was first trying to learn Haskell, my main reference for looking up "how do I do ____?" was the wikibook or RWH. Later I started just looking up the source on hackage.
18:44:26 <syntaxglitch> Now when I'm looking for ideas I end up reading stuff on Oleg's site
18:44:29 <syntaxglitch> I wonder if this should worry me
18:44:30 <joem86> s/ni/ta
18:44:32 <joem86> yeah
18:46:32 <copumpkin> joem86: no
18:46:43 <joem86> yeah, it didn't work any
18:46:51 <joem86> it doesn't quite matter though
18:46:55 <copumpkin> joem86: how would it work, anyway?
18:46:58 <joem86> for what I was doing
18:47:47 <joem86> I'm not quite sure... I was trying to define all cases of mult a b, which in my mind included mult b a
18:47:55 <joem86> but in the program, it didn't really matter
18:48:04 <copumpkin> b and a are just names bound to values
18:48:12 <copumpkin> mult a b is always the same thing as mult b a
18:48:23 <copumpkin> ( when you're pattern matching, that is )
18:48:28 <joem86> revised: http://haskell.pastebin.com/m2cf57274
18:49:24 <kmels> I'm new to haskell, would you say Leksah is the best option for an IDE on Mac OS X?
18:49:59 <yf> @a
18:49:59 <lambdabot> Maybe you meant: activity activity-full admin all-dicts arr ask . ? @ v
18:50:05 <tommd> kmels: No.
18:50:26 <applicative> joem86  the function you defined isn't exactly commutative
18:50:28 <joem86> I'm using vim + scons
18:50:37 <tommd> kmels: I'm not big on IDEs beyond emacs and vim but Leksah, last I tried, was not stable enough for real use.
18:50:53 <joem86> mult 5 7 <=> mult 7 5
18:51:02 <applicative> if you ask for the type it's      t -> a -> [a -> a]
18:51:12 <joem86> (domain is positive integers)
18:51:17 <Axman6> kmels: i wouldn't say haskell needs an IDE
18:51:28 <applicative> yeah, you didn't specify that
18:51:29 <copumpkin> it will on the ipad
18:51:30 <copumpkin> mmm
18:51:34 <copumpkin> haskell IDE on ipad!
18:51:41 <medfly> ...
18:51:42 <Axman6> get to it copumpkin
18:51:47 <yf> :-P
18:51:54 <copumpkin> Axman6: I'll be too busy doing things you disapprove of to it
18:51:57 <medfly> it's not even out yet, people!
18:52:07 <Axman6> indeed
18:52:10 <kmels> tommd: is there any way to get syntax highlighting in emacs?
18:52:25 <joem86> these are the exercises I'm going through: http://en.wikibooks.org/wiki/Haskell/YAHT/Language_basics
18:52:43 <uorygl_> I think IDEs are not allowed software on the iPhone.
18:52:44 <aavogt> what is the benefit of scons?
18:52:50 <joem86> actually pretty fun. I don't normally think that recursively normally
18:52:54 <Philonous> kmels: Sure. haskell mode ads syntax highlighting
18:53:00 <yf> haskell-mode + emacs
18:53:07 <kmels> ok, cheers
18:53:44 <joem86> aavogt, * cross-platform; * it's in python, and I happen to know python, so it works for me; * It's what I use for everything else from latex to c++
18:53:47 <applicative> joem86:  I see
18:53:49 <applicative> Define a recursive function mult that takes two positive integers a and b and returns a*b, but only uses addition
18:54:27 <h-cell>  > 1+1
18:54:58 <Axman6> mult 0 b = 0; mult a b = b + mult (a+(-1)) b >_>
18:55:05 <ezyang> So, can someone tell me why, in Cairo, in gtk2hs, I'd be interested in saving states? (save)
18:56:32 <Nafai> ezyang: I think you can use Cairo as a canvas and then save it out to .png or .svg or such
18:56:35 <Nafai> I could be wrong
18:56:39 <joem86> applicative, yep, that's the one
18:57:28 <ezyang> uh, I don't think that's what the save function does
18:57:32 <ezyang> "Makes a copy of the current state and saves it on an internal stack of saved states. When restore is called, the saved state is restored. Multiple calls to save and restore can be nested; each call to restore restores the state from the matching paired save. "
18:57:39 <Nafai> ah
18:57:48 <Nafai> sorry, just speculating
18:59:36 <applicative> joem86: it's a good answer, same as Axman's, but it permits the arguments to be different number types; I got the type wrong above, it's  a -> t -> a
19:00:51 <dibblego> @pl \a -> fmap ($a)
19:00:51 <lambdabot> fmap . flip id
19:01:07 <applicative> of course if you apply it to two positive integers you'll get the right answer, and the same one if you put them in the other order.   So it's commutative when restricted to the positive integers.
19:01:11 <joem86> true, and it wouldn't be ideal for production code. However, for the exercise the domain is given in the problem.
19:01:31 <joem86> is there a way to enforce the domain at runtime?
19:01:53 <applicative> you can add a type signature...
19:02:26 <applicative> joem86: but there's not a standard positive integer type
19:03:07 <joem86> understandable.
19:03:28 <joem86> I'm working on the next exercise now
19:03:31 <zakwilson> I seem to be having an issue where ghc can find packages installed with cabal install, but ghci cannot. Any suggestions?
19:03:35 <joem86> implementing my_map to work just like map
19:04:38 <ezyang> which ghc; which ghci ?
19:04:51 <joem86> ghc
19:05:02 <joem86> GHCi
19:05:22 <joem86> my solution: http://haskell.pastebin.com/m293137b4
19:05:41 <aavogt> if you install a package, a ghci that's been running in the meantime isn't able to load the new modules
19:06:02 <joem86> I was laughing at myself, b/c I was thinking, "darn, how do I handle the case where l is an empty list?"
19:06:09 <joem86> then it hit me
19:06:29 <aavogt> @src map
19:06:29 <lambdabot> map _ []     = []
19:06:29 <lambdabot> map f (x:xs) = f x : map f xs
19:06:37 <aavogt> joem86: you know pattern matching now?
19:06:59 <joem86> only regex pattern matching, and not in haskell
19:07:07 <applicative> stylin' use of function composition...
19:07:40 <joem86> so the answer is no, :-)
19:07:42 <applicative> aavogt means pattern matching against the basic forms of list
19:07:42 <zakwilson> ezyang: running 'which ghci' actually revealed the source of my problem. I had a self-compiled ghci still installed in /usr/local/bin
19:07:49 <ezyang> excellent!
19:09:02 <aavogt> joem86: whenever you bind variables (LHS of a function definition, case expressions, lambdas), you can name the components of a datatype if you also name the constructor
19:09:07 <applicative> a list is either empty, [], or else a cons, so it's x:xs, however you want to write it.   So the simple pattern matching definition will go through those two cases
19:09:07 <joem86> so if I understand, the '_' character is just an un-referenced variables
19:09:49 <joem86> okay, i think I understand that
19:09:53 <aavogt> x and xs are arbitrary variable names
19:10:28 <joem86> so since [1..5] is syntactic sugar for 1:2:3:4:5:[], then x->1 and xs->2:3:4:5:[]
19:10:29 <aavogt> _ is the same, except it isn't in scope on the RHS
19:10:36 <applicative> right, so if you are defining length you don't actually need to know what x in x:xs is, so you can write _:xs
19:10:57 <applicative> length [] = 0 ; length _:xs = 1 + length xs
19:11:07 <medfly> shouldn't the compiler easily optimise this anyway?
19:11:37 <joem86> awesome, that definitely makes sense
19:12:17 <aavogt> medfly: it's an optimization for the reader :)
19:12:41 <medfly> :)
19:12:47 <medfly> hehe
19:40:54 <Wooga_tc> how do i filter list on odd indexes: myfilter [1,5,3,2] = [1,3] ?
19:42:23 <ezyang> I don't think there's a builtin, but writing it would be pretty simple.
19:42:39 <zakwilson> I want to put about half a gig of data in some sort of store I can query it easily from Haskell programs. Bonus points if it's also easy to query from the JVM/Clojure. It should be indexed and fast-ish, but will mostly be used in batch mode, so locking is ok. I'm leaning toward SQLite and hdbc. Any comments?
19:42:45 <copumpkin> > map snd . filter (odd . fst) . zip [0..] $ [1,5,3,2]
19:42:47 <lambdabot>   [5,2]
19:43:00 <copumpkin> > map snd . filter (even . fst) . zip [0..] $ [1,5,3,2]
19:43:01 <lambdabot>   [1,3]
19:43:07 <Wooga_tc> copumpkin: thanks!
19:43:13 <idnar> > tails [1,5,3,2]
19:43:14 <lambdabot>   [[1,5,3,2],[5,3,2],[3,2],[2],[]]
19:43:15 <copumpkin> Wooga_tc: remember that indices go from 0
19:43:32 <idnar> > map (drop 1) (tails [1,5,3,2])
19:43:33 <lambdabot>   [[5,3,2],[3,2],[2],[],[]]
19:43:36 <idnar> no
19:43:59 <idnar> > map take 1 . tails . init $ [1,5,3,2]
19:44:00 <lambdabot>   Couldn't match expected type `a -> b'
19:44:00 <lambdabot>         against inferred type `[[a1] ...
19:44:04 <idnar> > map (take 1) . tails . init $ [1,5,3,2]
19:44:05 <lambdabot>   [[1],[5],[3],[]]
19:44:22 <idnar> what the heck am I doing
19:44:26 <copumpkin> beats me
19:45:33 <idnar> > map head . takeWhile (not . null) . iterate (drop 2) $ [1,5,3,2]
19:45:34 <lambdabot>   [1,3]
19:45:35 <idnar> > map head . takeWhile (not . null) . iterate (drop 2) $ [1,5,3,2,4]
19:45:36 <lambdabot>   [1,3,4]
19:46:09 <idnar> > map head . takeWhile (not . null) . iterate (drop 2) . tail $ [1,5,3,2,4]
19:46:10 <lambdabot>   [5,2]
19:46:38 <sshc> @remember idnar what the heck am I doing
19:46:39 <lambdabot> Done.
19:48:06 <idnar> @quote idnar
19:48:06 <lambdabot> idnar says:  <stepcut> gwern: RAM is overrated, swap is where it's at ;) <idnar> swap to a ramdisk! ;P
19:50:38 <applicative> > let {odds [] = []; odds (x:[]) = [x]; odds (x:y:xs) = x: (odds xs)} in odds [1,5,3,2,4]
19:50:39 <lambdabot>   [1,3,4]
19:51:58 <idnar> > let odds [] = []; odds (x:xs) = (x:odds (drop 1 xs)) in odds [1,5,3,2,4]
19:51:59 <lambdabot>   [1,3,4]
19:54:08 <Zao> http://www.acc.umu.se/~zao/hd3d01.png
19:54:21 <Zao> I must say, I love bindings-DSL. Makes wrapping libraries a breeze.
19:55:25 <medfly> > map fst . filter (\(a,b) -> odd b) $ zip [1,5,3,2,4] [1..]
19:55:26 <lambdabot>   [1,3,4]
19:56:19 <medfly> oh, I thought we're just randomly showing ways to get the odd elements :)
19:56:21 <applicative> > :t odd
19:56:22 <lambdabot>   <no location info>: parse error on input `:'
19:56:32 <medfly> :t odd
19:56:33 <lambdabot> forall a. (Integral a) => a -> Bool
19:56:54 <medfly> @let myOdd n = n `mod` 2 == 1
19:56:55 <lambdabot>  Defined.
19:58:14 <idnar> @check \x -> odd x == myOdd x
19:58:15 <lambdabot>   Not in scope: `myOdd'
19:58:22 <idnar> @type myOdd
19:58:23 <lambdabot> forall a. (Integral a) => a -> Bool
19:58:31 <medfly> ^_^
19:58:46 <idnar> @check let myOdd n = n `mod` 2 == 1 in \x -> odd x == myOdd x
19:58:47 <lambdabot>   "OK, passed 500 tests."
20:00:22 <medfly> strange that @check isn't aware of it
20:00:37 <lpsmith> holy crap the scala compiler is slow.
20:01:12 <idnar> @src odd
20:01:12 <lambdabot> odd = not . even
20:01:15 <idnar> @src even
20:01:16 <lambdabot> even n = n `rem` 2 == 0
20:01:34 <medfly> @src rem
20:01:34 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
20:01:40 <medfly> odd
20:01:42 <idnar> it's a class method
20:01:50 <idnar> I'm not sure how your myOdd is different, though
20:02:16 <medfly> I guess rem is a bit faster or something
20:02:24 <idnar> @type rem
20:02:25 <lambdabot> forall a. (Integral a) => a -> a -> a
20:02:40 <idnar> > 5 `rem` 2
20:02:40 <lambdabot>   1
20:03:03 <medfly> > -1 `rem` 2
20:03:04 <lambdabot>   -1
20:03:12 <medfly> > -2 `rem` 2
20:03:13 <lambdabot>   0
20:03:15 <medfly> :]
20:03:27 <idnar> oh, I see
20:03:34 <Reisen> Am I right thinking, if a function is tail recursive, the compiler will implement it as a loop and so (as long as lazy thunks don't overflow the stack) an overflow won't occur from function calls right?
20:03:36 <idnar> so I wonder why quickcheck isn't finding that
20:03:47 <idnar> > -1 `mod` 2
20:03:47 <lambdabot>   -1
20:03:49 <idnar> oh
20:03:51 <idnar> huh
20:03:59 <idnar> I'm going mad
20:04:06 <idnar> > odd 1
20:04:07 <lambdabot>   True
20:04:08 <idnar> > odd -1
20:04:09 <lambdabot>   No instance for (GHC.Num.Num (a -> GHC.Bool.Bool))
20:04:09 <lambdabot>    arising from the lite...
20:04:12 <idnar> > odd (-1)
20:04:13 <lambdabot>   True
20:04:20 <idnar> > myOdd (-1)
20:04:21 <lambdabot>   True
20:04:37 <idnar> ?!
20:04:38 <lambdabot> Maybe you meant: . ? @ v
20:04:40 <kamatsu> Reisen: yup
20:05:19 <Reisen> kamatsu, most functions I imagine writing in haskell then are almost 100% going to be tail recursive (at least in my head), can you give me an example of a non-tail recusrive function? :o
20:05:20 <idnar> oh, I see
20:05:23 <kamatsu> Reisen: It may not implement it as a straight out loop (some use trampoline methods and so on) but essentially are like that
20:05:29 <idnar> > (-1) `mod` 2
20:05:30 <lambdabot>   1
20:05:30 <Reisen> Ah
20:05:31 <applicative> > (-5) `mod` 2
20:05:32 <lambdabot>   1
20:05:32 <idnar> > (-1) `rem` 2
20:05:33 <kamatsu> Reisen: sure, here's a non-tail recursive factorial
20:05:33 <lambdabot>   -1
20:05:54 <kamatsu> fac n = if n == 0 then 1 else n * fac (n-1)
20:06:02 <kamatsu> not tail recursiv4e
20:06:03 <idnar> so if you test with == 1, you can't use rem; but testing with == 0 is fine
20:06:05 <applicative> > (-5) `rem` 2
20:06:05 <kamatsu> *rescursive
20:06:06 <lambdabot>   -1
20:06:10 <medfly> I see
20:06:10 <kamatsu> *rescursive
20:06:33 <Reisen> kamatsu, just to confirm I understand, it's not tail recursive because the result of the function is not the result of fac, but because it's the result of (*) ?
20:06:34 <idnar> also, I'd like this opportunity to SWEAR VIOLENTLY AT UNARY MINUS
20:06:38 <kamatsu> *recursive
20:06:38 <kamatsu> gah
20:06:46 <Reisen> 3rd time lucky rofl
20:06:47 <kamatsu> Reisen: yes
20:06:50 * idnar rescues kamatsu's typing
20:07:04 <Reisen> interesting
20:07:05 <kamatsu> Reisen: A tail recursive version would look like this
20:07:41 <kamatsu> fac n a =  fac (n-1)  (a*n)
20:07:51 <kamatsu> fac 0 a = a
20:08:06 <kamatsu> i think that's right
20:08:23 <Reisen> Looks fine to me
20:08:23 <monochrom> Beware that tail-recursive code can still produce non-tail-recursive intermediate result.
20:08:36 <kamatsu> and you call it with fac n 1
20:08:42 <Reisen> monochrom, mind elaborating on that?
20:08:52 <Reisen> Sorry if I'm asking too many questions rofl
20:09:04 <idnar> > let fac n a =  fac (n-1)  (a*n); fac 0 a = a in fac 7 1
20:09:06 <monochrom> I'll take that code above as example. It's tail-recursive alright. But then...
20:09:08 <lambdabot>   mueval-core: Time limit exceeded
20:09:23 <medfly> is tail recursive == iterative?
20:09:36 <kamatsu> uh woops, i need to swap those cases arouynd
20:09:36 <monochrom> Because of laziness, the "minus 1" and the "multiply" are not evaluated yet.
20:09:46 <Reisen> monochrom, oh is this stack overflowing from huge thunks?
20:09:48 <idnar> > let fac 0 a = a; fac n a =  fac (n-1)  (a*n) in fac 1 7
20:09:50 <lambdabot>   7
20:09:52 <Reisen> In which case yeah I'm aware of it, mentioned it in my first question
20:09:53 <monochrom> Yes.
20:09:54 <kamatsu> eh?
20:10:01 <idnar> oops
20:10:03 <idnar> > let fac 0 a = a; fac n a =  fac (n-1)  (a*n) in fac 7 1
20:10:04 <lambdabot>   5040
20:10:08 <kamatsu> there we go
20:10:16 <Reisen> monochrom, thank you though, always appreciate extra detail!
20:10:21 <idnar> > let fac 0 a = a; fac n a =  fac (n-1)  (a*n) in fac 20 1
20:10:22 <lambdabot>   2432902008176640000
20:10:25 <idnar> > let fac 0 a = a; fac n a =  fac (n-1)  (a*n) in fac 50 1
20:10:26 <lambdabot>   30414093201713378043612608166064768844377641568960512000000000000
20:10:28 <idnar> > let fac 0 a = a; fac n a =  fac (n-1)  (a*n) in fac 100 1
20:10:29 <kamatsu> seems to be working fast enough ^^
20:10:30 <lambdabot>   933262154439441526816992388562667004907159682643816214685929638952175999932...
20:10:33 <idnar> > let fac 0 a = a; fac n a =  fac (n-1)  (a*n) in fac 1000 1
20:10:34 <lambdabot>   402387260077093773543702433923003985719374864210714632543799910429938512398...
20:10:35 <kamatsu> ah, the stack isn't blowing out
20:10:43 <idnar> > let fac 0 a = a; fac n a =  fac (n-1)  (a*n) in fac 10000 1
20:10:45 <lambdabot>   284625968091705451890641321211986889014805140170279923079417999427441134000...
20:10:45 <kamatsu> nor is thunk heap
20:10:56 <idnar> > let fac 0 a = a; fac n a =  fac (n-1)  (a*n) in fac 100000 1
20:10:58 <applicative> why is it so goos?
20:10:59 <lambdabot>   mueval-core: Time limit exceeded
20:11:01 <applicative> good
20:11:10 <kamatsu> applicative: tail recursive
20:11:22 <kamatsu> So it never ran out of space
20:11:26 <idnar> > let fac n = if n == 0 then 1 else n * fac (n-1) in fac 10000
20:11:27 <lambdabot>   284625968091705451890641321211986889014805140170279923079417999427441134000...
20:11:30 <idnar> I don't think it's that
20:11:30 <monochrom> Oh I can use lambdabot to tell me what we get.
20:11:30 <kamatsu> oh
20:11:40 <idnar> I think it's just that we run out of time before we run out of stack space
20:11:42 <kamatsu> wait, how does that work =/
20:11:47 <monochrom> > let fac 0 a = a; fac n a =  fac (n-1)  (a*n) in fac 4 b
20:11:47 <kamatsu> we must have alot of stack space?
20:11:48 <lambdabot>   b * 4 * (4 - 1) * (4 - 1 - 1) * (4 - 1 - 1 - 1)
20:12:08 <kamatsu> ah, let's add strictness annotations then
20:12:13 <kamatsu>  let fac 0 a = a; fac n a =  fac (n-1)  (a*n) in fac 4 b
20:12:20 <monochrom> You get some thunk like b * 4 * (4 - 1) * (4 - 1 - 1) * (4 - 1 - 1 - 1) first.  This thunk is clearly not a tail-recursive expression.
20:12:20 <idnar> kamatsu: how will that help?
20:12:33 <kamatsu> idnar: wouldn't it force the evaluation of the thunks?
20:12:43 <idnar> kamatsu: how will that help?
20:12:50 <Reisen> monochrom, wait wait
20:13:04 <idnar> kamatsu: I don't understand what problem you're trying to solve now
20:13:04 <kamatsu> idnar: thus giving you a truly tail-recursive function?
20:13:24 <monochrom> Wether you make it b*(4*(3*(2*1)) or (((b*4)*3)*2)*1 you need stack.
20:13:35 <idnar> strictness doesn't affect tail recursion, surely?
20:13:42 <Reisen> monochrom, so, the function kamatsu showed is not tail recursive because of thunking?
20:13:43 <idnar> > let fac n = if n == 0 then 1 else n * fac (n-1) in fac 4
20:13:44 <lambdabot>   24
20:13:47 <idnar> er
20:13:57 <kamatsu> idnar: the thunk buildup is clearly not tail recursive, even in the tail recursive function
20:14:04 <idnar> > let fac n = if n == 0 then a else n * fac (n-1) in fac 4
20:14:05 <lambdabot>   4 * ((4 - 1) * ((4 - 1 - 1) * ((4 - 1 - 1 - 1) * a)))
20:14:09 <monochrom> The function is tail-recursive. It spits out non-tail-recursive thing needing further work.
20:14:17 <Reisen> Oh right right
20:14:29 <idnar> kamatsu: that doesn't have anything to do with strictness, though
20:14:44 <kamatsu> idnar: sure it does, if you force evaluation of the thunks, then the thunks go away
20:14:51 <Reisen> monochrom, one final question, looking at the expression you gave lambdabot, I can't for the life of me see how you managed to get it to throw out a thunk instead of a value
20:15:00 <Reisen> OH, sorry no I do, 4 b
20:15:01 <idnar> kamatsu: they don't go away, they just get evaluated at a different time
20:15:06 <idnar> kamatsu: they're still not tail recursive
20:15:36 <Reisen> Awesome, as usual thanks for the help, much appreciated
20:15:40 <kamatsu> idnar: if the function was evaluated with strict semantics, you don't produce thunks at all
20:16:02 <monochrom> lambdabot has loaded a special module to do that. it is not omnipotent. I have to be careful what it can do and give it just the right thing.
20:16:03 <kamatsu> idnar: similarly if you add strictness annotations, the thunks are created and immediately evaluated, so they are collected earlier
20:16:16 <idnar> kamatsu: well, fine, the thunks you don't produce are still not tail recursive
20:16:30 <Reisen> monochrom, nah I figured as much, that's goign to come in handy though -- thanks
20:16:31 <kamatsu> idnar: i know, strictness gets around this, which was my whole point
20:18:00 <monochrom> We can just agree that tail-recursive code is not enough to save stack, and we can agree what more is enough.
20:18:20 * ddarius thinks Alexander Solla needs to check himself.
20:18:31 <monochrom> IMO anything beyond that is just ideologiy. Go to #haskell-blah to argue capitalism vs communism vs neo-whatever to death.
20:18:47 <Reisen> Rofl
20:19:02 <kamatsu> well, I prefer laziness generally
20:19:13 <kamatsu> i was just pointing out that strictness solves this particular problem
20:19:34 <ddarius> kamatsu: Strictness introduces dual problems.  I think there is an actual duality here with regards to this.
20:19:47 <ddarius> (I could probably work it out with respect to a call-by-push-value semantics.)
20:20:08 <kamatsu> dual problems?
20:20:34 <ddarius> map f (x:xs) = f x : map f xs -- not a good strict definition, but an ideal lazy one
20:20:40 <idnar> kamatsu: I still don't understand what the supposed problem is
20:21:07 <ddarius> kamatsu: Basically, foldl is good for strict languages and foldr is bad, and vice versa for lazy languages.
20:21:10 <idnar> maybe I'm confused about which version you're talking about
20:21:17 <kamatsu> ddarius: i see your point, but does this apply for factorial?
20:21:23 <kamatsu> ddarius: i would say not
20:21:38 <idnar> but as far as I can tell, "fac 0 a = a; fac n a =  fac (n-1)  (a*n)" doesn't blow the stack, even without any strictness annotations
20:22:48 <kamatsu> ghc could just be strictifying it
20:22:58 <monochrom> If you compile with -O maybe the compiler adds ! for you and you don't see stack overflow.
20:23:12 <monochrom> Try it on hugs to be sure.
20:23:27 <idnar> I guess that could be it
20:23:29 <idnar> I don't have hugs handy
20:23:41 <ddarius> The result would be pretty big just before it overflowed too..
20:24:04 <idnar> ah, hang on, I did manage to get a stack overflow now
20:24:33 <idnar> apparently I skipped over the run-out-of-stack point at the same time as I skipped over the run-out-of-memory point
20:25:41 <kamatsu> hugs also stack overflows
20:25:47 <kamatsu> very easily
20:26:25 <monochrom> I have a cunning plan.  fac 0 a = a; fac n 0 = 0; fac n a =  fac (n-1)  (a*n)
20:26:34 <idnar> now I seem to have forgotten the syntax for bang patterns
20:26:47 <monochrom> fac n !a = fac (n-1) (a*n)
20:27:13 <idnar> okay, I haven't forgotten it then
20:27:18 <idnar> what do I need to do to make ghci accept that?
20:27:27 <monochrom> -XBangPattern
20:27:37 <monochrom> Maybe -XBangPatterns
20:27:52 <idnar> ah, I guess -fglasgow-exts doesn't include that
20:28:07 <monochrom> Oh fun.
20:28:20 <sjanssen> idnar: -fglasgow-exts has been deprecated for a while
20:28:45 <idnar> sjanssen: pity
20:28:54 <idnar> is there some other -feverything eption?
20:28:59 <kamatsu> can't you just use $!?
20:29:01 <idnar> *option
20:29:11 <kamatsu> fac 0 a = a; fac n a = fac (n-1) $! (a*n)
20:29:30 <idnar> or -XEverything, or what have you
20:29:49 <monochrom> You can. It is slightly different. Not that it matters.
20:30:12 <idnar> apparently calculating 1000000! takes a while
20:32:19 <tommd> I recall a patch for gtk2hs + GHC 6.12.1 - was that a good patch that would be merged soonish or should I not expect GHC 6.12.1 to work with GTK any time soon?
20:32:25 <medfly> idnar, I wonder why.
20:32:36 <tommd> nevermind
20:32:40 <tommd> file that under a dumb question.
20:32:47 <idnar> medfly: I guess it's just one of those mysteries that will never be solved
20:32:51 <medfly> :)
20:34:35 <applicative> kamatsu: I was just going to ask about the meaning of 'tail recursive' - it's a feature of a definition, that the outermost operation on the right hands side is the same as the being defined?
20:36:06 <monochrom> Yes.
20:36:09 <applicative> so the not-tail-recursive recursive definition buries fac inside (*), saying n * (fac n-1)
20:36:39 <applicative> and the compiler can recognize this and optimize more readily.   Sorry, I'm completely ignorant about this.
20:37:45 <applicative> monochrom: what is the explanation of the metaphor of a 'tail'?
20:39:01 <aavogt> ouroboros
20:39:11 <c_wraith> what's the flag for no implicit prelude?
20:39:17 <monochrom> It comes from imperative code, which is roughly speaking functional code in reverse order. fac(n,a) { /* perhaps do more here*/ return fac(n-1,a*n); }  It is tail because it is the last line.
20:39:24 <aavogt> c_wraith: -XNoImplicitPrelude??
20:39:32 <c_wraith> that one.  thanks
20:39:38 <BMeph> c_wraith: -XNoImplicitPrelude, maybe? ;p
20:40:01 <c_wraith> I can never remember what counts as an extension
20:40:12 <c_wraith> also, ghci fails hilariously without implicit prelude...  *sigh*
20:40:13 <aavogt> all the good things :)
20:41:10 <c_wraith> oh.  nevermind.  NoImplicitPrelude doesn't seem to have helped with what I wanted to do.
20:41:20 <monochrom> perhaps this shows more clearly: fac(n,a) { int newn, newa; newn = n - 1; newa = a*n; return fac(newn,newa) }
20:41:39 <applicative> monochrom: I see, just this example is used in the Wikipedia article, with Scheme as illustrating, and indeed, the Haskell version could as well be called "head recursion"
20:43:22 <monochrom> And now, head recursion in imperative code: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5481  teeheehee!
20:44:10 <idnar> o/` where's your head at? o/`
21:02:06 <o-_-o> http://pastie.org/795329 <- line 31
21:02:18 <o-_-o> what in the universe ?
21:04:08 <Axman6> ?
21:04:26 <aavogt> needs some linebreaks
21:04:37 <Axman6> and some refactoring
21:06:52 <monochrom> could use a better pastebin than this.
21:07:07 <o-_-o> I found the code on reddit
21:07:23 <o-_-o> I am trying to understand it and it is difficult to make sense
21:08:24 <Axman6> @where ops
21:08:25 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver monochrom
21:08:29 <Axman6> someone wanna set +R?
21:09:21 <o-_-o> oh...so this is the thing that was mentioned on reddit
21:09:21 --- mode: ChanServ set +o monochrom
21:09:24 --- mode: monochrom set +b *!*@129.21.133.66
21:10:10 <Axman6> how interesting, we just got flooded in #macosx, but they were all from different hosts
21:10:18 <kamatsu> o-_-o: ah, this is it?
21:10:24 <kamatsu> o-_-o: this is trivially easy to parallelize
21:10:29 <kamatsu> stupid reddit person
21:10:29 --- mode: monochrom set +R
21:10:36 --- mode: monochrom set -b *!*@129.21.133.66
21:10:54 <o-_-o> http://unethicalblogger.com/posts/2010/01/using_browser_piss_irc_users_or_spamming_redditdowntime
21:11:31 <joem86> ohh man, it's like I take 1 stop forward and 2 steps back: http://haskell.pastebin.com/m35533c6f
21:12:00 <monochrom> This is it. I'm going to build and deploy a haskell-powered superweapon for this.
21:12:01 <o-_-o> some mischief maker who's got his hands on the script
21:12:03 <joem86> apparently, let l = (a function that returns a list) won't compile for me
21:12:08 <kamatsu> joem86: what's up?
21:12:36 <kamatsu> joem86: uh, i think you need to start from the beginning
21:12:42 <kamatsu> joem86: there are lots and lots of things wrong with that code
21:12:48 <joem86> output: http://pastebin.org/83458
21:13:15 <o-_-o> kamatsu, what is trivially easy to parallelize ?
21:13:31 <monochrom> joem86: l <- getNum
21:13:37 <joem86> so from the first piece of code that gets executed
21:13:39 <joem86> ohhh
21:13:43 <kamatsu> o-_-o: wasn't there a guy on reddit who wanted to generate fractals, and said parallelizing it was too hard so he wrote it in C
21:13:56 <o-_-o> kamatsu, ah...yeah
21:14:04 <monochrom> joem86: mapM_ prFact l
21:14:12 <monochrom> That is all.
21:14:24 <o-_-o> kamatsu, I was thinking the flooding bot was trivially easy to parallelize in haskell
21:14:32 <kamatsu> o-_-o: oh, right
21:14:33 <monochrom> Oh ha, that is not all.
21:14:42 <kamatsu> monochrom: not by a long shot
21:14:51 <kamatsu> joem86: You don't "import IO"
21:15:38 <joem86> why not? Is it invalid, or frowned upon?
21:15:39 <kamatsu> joem86: I'll correct you on  the pastebin
21:15:44 <o-_-o> the trolls are having a field day
21:15:48 <kamatsu> joem86: IO is a type, not a module
21:16:32 <o-_-o> kamatsu, but the reason he gave was something else
21:16:41 <monochrom> "import IO" is valid, just old.
21:16:55 <monochrom> Yes there is a module called IO in Haskell98.
21:17:03 <o-_-o> kamatsu, for not being able to use haskell to parallelize, he says something about running against the 3GB memory limit, let me dig his comment out
21:17:13 <joem86> that's what this tutorial is based on I think
21:17:21 <joem86> Haskell98
21:17:29 <monochrom> Welcome to Haskell namespace multiplexing!
21:17:53 <o-_-o> kamatsu, http://www.reddit.com/r/programming/comments/aue06/going_back_to_c/c0jhl8n
21:17:58 <kamatsu> joem86: Which tutorial are you using?
21:18:03 <monochrom> You can very well write "module Haha where data Haha = Haha" and they are 3 different Haha's.
21:18:24 <joem86> kamatsu, http://en.wikibooks.org/wiki/Haskell/YAHT
21:18:38 <kamatsu> ah, he should use CHP
21:18:48 <kamatsu> joem86: have you considered Learn You A Haskell?
21:18:52 <kamatsu> @where lyah
21:18:52 <monochrom> joem86: http://haskell.pastebin.com/m3daff68d
21:18:52 <lambdabot> http://www.learnyouahaskell.com/
21:19:31 <monochrom> Claviceps: must have been beaten heavily in other channels :)
21:20:05 <joem86> wow, I was wondering where that link went
21:20:17 <joem86> I saw it like 8 months ago and forgot all about it
21:20:45 <joem86> more up-to-date?
21:20:46 <kamatsu> joem86: also, i might advise you now, avoid formatting function calls like C
21:20:53 <kamatsu> joem86: don't write print("Hello")
21:21:08 <kamatsu> joem86: write print "hello" or (print "hello") if you need the brackets
21:21:28 <monochrom> joem86 didn't write like print("Hello"). Look again.
21:21:29 <joem86> it's needed for show(a) ++ " factorial is " ++ show(fact a), right?
21:21:45 <kamatsu> monochrom: i know, but show(a)
21:21:46 <Axman6> not really
21:21:50 <monochrom> joem86 faithfully wrote  print "Give me a number (or 0 to stop)"  without parentheses
21:21:59 <kamatsu> monochrom: i know, but he did write show(a)
21:22:09 <Axman6> show a ++ " factorial is: " show (fact a)
21:22:10 <joem86> (show a), right?
21:22:20 <Axman6> the brackets aren't needed there
21:22:26 <kamatsu> joem86: in that case, you only need it around (fact a)
21:22:42 <kamatsu> joem86: show a ++ " factorial is " ++ show (fact a)
21:23:00 <monochrom> Perhaps he had "show(f a)" earlier at that place, then deleted f, too lazy to delete more.
21:23:33 <kamatsu> monochrom: true, but seeing as he's a beginner, i thought it best to advise him, because if you write it like other languages, that can end up being confusing and problematic
21:23:35 <joem86> naw, I just had the python str(a) in my mind while I was typing it :-P
21:23:42 <kamatsu> right, that's what I thought
21:23:48 <kamatsu> it can lead to funky precedence errors
21:24:17 <joem86> lol I'm really going to have to put my mind in a different place for haskell coding
21:24:20 <monochrom> I mean if there are 15 function calls and 14 of them used paretheses optimally, only 1 didn't, then you can easily guess my hypothesis of what happened.
21:24:32 <joem86> but it's good to expand
21:24:59 <kamatsu> joem86: generally this is true, but once you become a haskell master, you don't really need to leave the haskell mindset to write imperative code
21:25:11 <kamatsu> at least, that's how it has been in my experience
21:25:32 <joem86> well hopefully I don't lose any of my OO experience while I'm at it.
21:25:39 <kamatsu> ah, OO
21:25:42 <joem86> (I hope that's not a bad word in here :-))
21:25:48 <kamatsu> not really
21:26:02 <monochrom> You lose ignorance only.
21:26:09 <kamatsu> largly, good OO is a failed implementation of good functional programming techniques :P
21:26:26 <kamatsu> certain design patterns spring to mind
21:27:29 <joem86> yeah, and it's largely OO that's taught in schools these days
21:27:36 <joem86> I don't remember much functional programming
21:27:44 <kamatsu> my school is pretty functional
21:27:54 <joem86> heck, the closes I got before haskell was python's lambda and map functions
21:28:03 <kamatsu> ah
21:28:08 <joem86> what school?
21:28:09 <o-_-o> I have a question, if I made someone (who doesn't haskell or FP) write a small program, in C, to fill an int array[1000] with 1..1000, and this needs to be done without loops, pointers and all the variables are const int (so no incrementing) and they cannot , would that be a decent interview question ?
21:28:12 <kamatsu> my university teaches haskell a fair bit
21:28:16 <kamatsu> UNSW in sydney
21:28:19 <Axman6> my uni's first programming courser is 2/3 haskell
21:28:24 <Axman6> that's why i'm here now
21:28:30 <joem86> ohh wow, you're from the future!
21:28:36 <joem86> UCF, United States
21:28:41 <kamatsu> o-_-o: hm, what answer are you gunning for
21:28:44 <Axman6> kamatsu: o/ for ANU :)
21:28:48 <Axman6> from even
21:29:01 <joem86> o-_-o, I would use meta programming
21:29:08 <o-_-o> kamatsu, some sort of recursive function, he need to even give an answer, I am just thinking how he would go about it
21:29:09 <joem86> #defines and such
21:29:10 <lunabot>  luna: Not in scope: `defines'
21:29:11 <kamatsu> Axman6: ah, cool
21:29:22 <kamatsu> Axman6: We used to teach 100% haskell in first year, then engineering made us switch to C
21:29:31 <kamatsu> Axman6: still we have several 3rd year courses in haskell
21:29:45 <Axman6> aye :)
21:29:57 <kamatsu> Axman6: chak works for us too
21:29:57 <o-_-o> joem86, no metaprogramming, no pre-processor things, just to see his reasoning capability
21:30:01 <kamatsu> Axman6: and dons used to be here
21:30:05 <Axman6> i'd like to come up and do my PhD there with chak
21:30:06 <joem86> our classes were taught in C/C++ and Java
21:30:21 <joem86> the only time I touched python was for a freestyle assignment where we could use anything
21:30:24 * Axman6 met chak up there not too long ago
21:30:30 <kamatsu> Axman6: i'm doing my undergraduate thesis with him
21:30:34 <o-_-o> who is chak ?
21:30:35 <kamatsu> Axman6: should be interesting
21:30:42 <kamatsu> o-_-o: a GHC contributor that lives in Australia and works at UNSW
21:30:46 <Axman6> kamatsu: what's your name?
21:30:53 <kamatsu> Axman6: Liam O'Connor-Davis
21:30:55 <clarkb> o-_-o: you would just be testing a candidates ability to write bad code :P
21:31:03 <Axman6> heh, we met at SAPLING i believe :P
21:31:13 <shapr> Axman6: Still want +R?
21:31:23 <o-_-o> clarkb, I would never have him use it in real life
21:31:35 <kamatsu> Axman6: SAPLING?
21:31:47 --- topic: '["msg an op if you can't talk", "find ops: /msg ChanServ access list #haskell", "Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]'
21:31:47 --- topic: set by mauke on [Mon Jan 18 11:11:51 2010]
21:31:47 --- names: list (clog amuck miclorb bdimcheff emma seanl sShintah fhobia jones- Claviceps jsgf inimino Ferdirand zakwilson tmug lst``` ezyang lispy|web duairc potatishandlarn portnov joed novas0x2a cloudhead Hugglesworth regalia alvarezp ps-auxw execve Zeiris dolio araujo SamB_XP otto_s erikc` kfish kqrx edwinb_ Torrieri nettok path[l] gnuvince fbru02 weihsiu kmc applicative tommd blueonyx_ voidprayer joem86 Nereid_ roconnor lsthemes kamatsu Cale dnm_ hiptobecubic)
21:31:47 --- names: list (Reisen m0nkfish Raynes abbe the_andy glith holmak saccade_ SANDERS_ balboa02 mietek TacticalGrace medfly drbean copumpkin Niccus Rotaerk augur dfrey amiri Trafalgard MrDomino Nereid trin_cz tomoj horms NNshag M| _gaffer Alpounet sioraioc_ go|dfish DarthShrine cads solidsnack Philonous voker57_ tgdavies sigh endojelly jao dr_maligno imperialenforcer ulfdoz ystael Uawdal baaba_ elspru cygnus_ Dessous Sagi ddarius Modius IceDane hgolden arnihermann)
21:31:47 --- names: list (kar-1 niksnut gwern fredcy TR2N sjanssen J-Mad @monochrom kniu boyscared s76_ Liskni_si nick8325 ttvd lpsmith dobie_gillis prb lament rfh jlaire gjl_ jmcarthur temoto NEEDMOAR Dashkal aep Cthulhon Cobra^^ luite psault jims wto zhijie dMazz whoppix njbartlett ski lenbust_ mrothe C-S ray bd_ srcerer sebbe1991 wolverian pastorn Taggnostr eagletmt mmmdonuts jql Exteris_ MacCoaster_ ezrakilty kosmikus jontore tarbo EvanCarroll _Jordan_ poucet)
21:31:47 --- names: list (tilman gdsx Veinor otulp skaar_ axiom dons ath mdordal2 clarkb ennen sieni davidL flux dixie_ kolmodin flori_ FullMetalHarlot Bleadof glitch rntz icee_ Tomas_ bolmar_ koninkje1away netcat_ deavidsedice brx mokus_ tkr mchase gju cactii Beelsebob yottis Kyrus c9s__ ToRA matthew-_ prigaux Ke osfameron shepheb kwinz Khisanth Feuerbach opqdonut dejones Davse_Bamse saurik electrogeek nothingmuch dumael Apocalisp fihi09 michael| anekos noj zsol)
21:31:47 --- names: list (kynky Raevel merehap helgikrs jre2 reltuk dejai emias snhmib o-_-o dcolish ezeike oeblink Mortomes levitation_ mjrosenb vy Saizan cathper jtootf__ cods npouillard Berengal scree MoALTz quicksilver cjay jlouis equanimity Botje Eelis xerox Gowilla Aisling_ hackagebot ksf JaffaCake Astro Mr_Awesome eldragon absentia cgibreak Igloo tensorpudding shrughes gbeshers Colours tomberek Polarina qz untwisted gds jorizma mfp wang kadoban willb fnordus)
21:31:47 --- names: list (thetallguy1 thetallguy timlarson mikezackles @shapr jvogel sshc EvanR-work stephen_mcd zachk mikste Boney DekuNut TML thingwath _stenobot angerman jimmyjazz14 dropdrive nathanic_work ville The_third_man blackdog_ aluink Muad_Dibber guerrilla bburhans lostlogic inhortte khiroc Bassetts Blub\0 Peaker joevandyk mattam BMeph Gracenotes Axman6 Paradox924X suiside PsiOmega SimonRC profmakx ziman Nafai magicman jayne wharrgarble aavogt nathanic)
21:31:47 --- names: list (calvins tltstc pikhq sohum ve kaol eek jfredett newsham gspr MadX` pettter galdor Milo- qm13_ blazzy_ trez uorygl_ StarFire_ joga epmf thorkilnaur dmwit BONUS quuxman mreggen anders^^ Twey clanehin _Jedai_ tamiko fabjan AndyP nwf sahazel anji joni6128 hiredman CalJohn dilinger_ etpace kalven karld dcoutts gbacon Valodim jtra juhp bbee arjanoosting dqd lambdabot hellige shachaf Vulpyne nornagon smg Sisu mm_freak dfeuer alios solrize olsner)
21:31:47 --- names: list (BrianHV eelco_ sgf idnar sproingie birkenfeld arw smiler jfoutz Spockz BONUS_ mornfall yahooooo integral nniro Deewiant ClaudiusMaximus tromp coyo zygoloid aiko nimred kloeri jix lars_t Shimei djinni syntaxglitch Baughn int-e alip DigitalKiwi nasloc__ dreixel phnglui caligula_ p_l htoothrot laz0r eno harlekin canvon Counter-Strike jan_ noddy __marius__ ahihi deadguys Lemmih ttmrichter bwr mahogny dogmaT ksandstr wagle +preflex Innominate_)
21:31:47 --- names: list (Runar jonafan dufflebu1k saiam_ pen16 thoughtpolice ibid tafryn Laney gmux zax desu pragma_ orbitz andrewsw erk kw317 jedediah skeptomai|away SmurfOR Raku^ geoaxis elly Twigathy Gilly impl stroan liesen sbok t koala_man shortcircuit keseldude aleator_ encryptio dino- agemo_ dax jml burp Cyneox Gabbie danderson leod rapacity peddie QtPlatypus wormwood mjv ahf jvoorhis zacharyp Stephan202 dionoea geir_ Tupis companion_cube mlh Zao jbauman taruti)
21:31:47 --- names: list (theclaw McManiaC OnionKnight_ AnMaster benmachine wdonnelly byorgey ido bran epokal cYmen bastian Loriel alexbobp daed_ shawn_ allbery_b webframp mercury^ FauxFaux And[y] Badger soeren felipe_ nlogax pcc1 ehamberg +lunabot Ornedan tab _br_ fritschy kakeman Jaak StoneToad_ shrimpx beza1e1 cheater Vq jdavis drhodes sothim DrSyzygy saccade anee dang`r`us mfoemmel gniourf_gniourf_ jystic det zaarg_ SubStack jrockway mrd kevinclark hariju_ jayrk)
21:31:47 --- names: list (djahandarie @ChanServ)
21:31:51 <Axman6> shapr: i'd ask in #freenode and see if the attacks are still ongoing
21:31:51 <o-_-o> clarkb, just to see if he can even think in recursion, or is it too difficult a question...
21:31:53 <clarkb> s/write/right/
21:32:03 --- topic: '["msg an op if you can't talk", "find ops: /msg ChanServ access list #haskell", "Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]'
21:32:03 --- topic: set by mauke on [Mon Jan 18 11:11:51 2010]
21:32:03 --- names: list (clog amuck miclorb bdimcheff emma seanl sShintah fhobia jones- Claviceps jsgf inimino Ferdirand zakwilson tmug lst``` ezyang lispy|web duairc potatishandlarn portnov joed novas0x2a cloudhead Hugglesworth regalia alvarezp ps-auxw execve Zeiris dolio araujo SamB_XP otto_s erikc` kfish kqrx edwinb_ Torrieri nettok path[l] gnuvince fbru02 weihsiu kmc applicative tommd blueonyx_ voidprayer joem86 Nereid_ roconnor lsthemes kamatsu Cale dnm_ hiptobecubic)
21:32:03 --- names: list (Reisen m0nkfish Raynes abbe the_andy glith holmak saccade_ SANDERS_ balboa02 mietek TacticalGrace medfly drbean copumpkin Niccus Rotaerk augur dfrey amiri Trafalgard MrDomino Nereid trin_cz tomoj horms NNshag M| _gaffer Alpounet sioraioc_ go|dfish DarthShrine cads solidsnack Philonous voker57_ tgdavies sigh endojelly jao dr_maligno imperialenforcer ulfdoz ystael Uawdal baaba_ elspru cygnus_ Dessous Sagi ddarius Modius IceDane hgolden arnihermann)
21:32:03 --- names: list (kar-1 niksnut gwern fredcy TR2N sjanssen J-Mad @monochrom kniu boyscared s76_ Liskni_si nick8325 ttvd lpsmith dobie_gillis prb lament rfh jlaire gjl_ jmcarthur temoto NEEDMOAR Dashkal aep Cthulhon Cobra^^ luite psault jims wto zhijie dMazz whoppix njbartlett ski lenbust_ mrothe C-S ray bd_ srcerer sebbe1991 wolverian pastorn Taggnostr eagletmt mmmdonuts jql Exteris_ MacCoaster_ ezrakilty kosmikus jontore tarbo EvanCarroll _Jordan_ poucet)
21:32:03 --- names: list (tilman gdsx Veinor otulp skaar_ axiom dons ath mdordal2 clarkb ennen sieni davidL flux dixie_ kolmodin flori_ FullMetalHarlot Bleadof glitch rntz icee_ Tomas_ bolmar_ koninkje1away netcat_ deavidsedice brx mokus_ tkr mchase gju cactii Beelsebob yottis Kyrus c9s__ ToRA matthew-_ prigaux Ke osfameron shepheb kwinz Khisanth Feuerbach opqdonut dejones Davse_Bamse saurik electrogeek nothingmuch dumael Apocalisp fihi09 michael| anekos noj zsol)
21:32:03 --- names: list (kynky Raevel merehap helgikrs jre2 reltuk dejai emias snhmib o-_-o dcolish ezeike oeblink Mortomes levitation_ mjrosenb vy Saizan cathper jtootf__ cods npouillard Berengal scree MoALTz quicksilver cjay jlouis equanimity Botje Eelis xerox Gowilla Aisling_ hackagebot ksf JaffaCake Astro Mr_Awesome eldragon absentia cgibreak Igloo tensorpudding shrughes gbeshers Colours tomberek Polarina qz untwisted gds jorizma mfp wang kadoban willb fnordus)
21:32:03 --- names: list (thetallguy1 thetallguy timlarson mikezackles @shapr jvogel sshc EvanR-work stephen_mcd zachk mikste Boney DekuNut TML thingwath _stenobot angerman jimmyjazz14 dropdrive nathanic_work ville The_third_man blackdog_ aluink Muad_Dibber guerrilla bburhans lostlogic inhortte khiroc Bassetts Blub\0 Peaker joevandyk mattam BMeph Gracenotes Axman6 Paradox924X suiside PsiOmega SimonRC profmakx ziman Nafai magicman jayne wharrgarble aavogt nathanic)
21:32:03 --- names: list (calvins tltstc pikhq sohum ve kaol eek jfredett newsham gspr MadX` pettter galdor Milo- qm13_ blazzy_ trez uorygl_ StarFire_ joga epmf thorkilnaur dmwit BONUS quuxman mreggen anders^^ Twey clanehin _Jedai_ tamiko fabjan AndyP nwf sahazel anji joni6128 hiredman CalJohn dilinger_ etpace kalven karld dcoutts gbacon Valodim jtra juhp bbee arjanoosting dqd lambdabot hellige shachaf Vulpyne nornagon smg Sisu mm_freak dfeuer alios solrize olsner)
21:32:03 --- names: list (BrianHV eelco_ sgf idnar sproingie birkenfeld arw smiler jfoutz Spockz BONUS_ mornfall yahooooo integral nniro Deewiant ClaudiusMaximus tromp coyo zygoloid aiko nimred kloeri jix lars_t Shimei djinni syntaxglitch Baughn int-e alip DigitalKiwi nasloc__ dreixel phnglui caligula_ p_l htoothrot laz0r eno harlekin canvon Counter-Strike jan_ noddy __marius__ ahihi deadguys Lemmih ttmrichter bwr mahogny dogmaT ksandstr wagle +preflex Innominate_)
21:32:03 --- names: list (Runar jonafan dufflebu1k saiam_ pen16 thoughtpolice ibid tafryn Laney gmux zax desu pragma_ orbitz andrewsw erk kw317 jedediah SmurfOR Raku^ geoaxis elly Twigathy Gilly impl stroan liesen sbok t koala_man shortcircuit keseldude aleator_ encryptio dino- agemo_ dax jml burp Cyneox Gabbie danderson leod rapacity peddie QtPlatypus wormwood mjv ahf jvoorhis zacharyp Stephan202 dionoea geir_ Tupis companion_cube mlh Zao jbauman taruti theclaw McManiaC)
21:32:03 --- names: list (OnionKnight_ AnMaster benmachine wdonnelly byorgey ido bran epokal cYmen bastian Loriel alexbobp daed_ shawn_ allbery_b webframp mercury^ FauxFaux And[y] Badger soeren felipe_ nlogax pcc1 ehamberg +lunabot Ornedan tab _br_ fritschy kakeman Jaak StoneToad_ shrimpx beza1e1 cheater Vq jdavis drhodes sothim DrSyzygy saccade anee dang`r`us mfoemmel gniourf_gniourf_ jystic det zaarg_ SubStack jrockway mrd kevinclark hariju_ jayrk djahandarie @ChanServ)
21:32:04 <clarkb> I think you need a problem that lends itself to recursion
21:32:09 <o-_-o> clarkb, ah you're right
21:32:18 --- topic: '["msg an op if you can't talk", "find ops: /msg ChanServ access list #haskell", "Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]'
21:32:18 --- topic: set by mauke on [Mon Jan 18 11:11:51 2010]
21:32:18 --- names: list (clog alexsuraci amuck miclorb bdimcheff emma seanl sShintah fhobia jones- Claviceps jsgf inimino Ferdirand zakwilson tmug lst``` ezyang lispy|web duairc potatishandlarn portnov joed novas0x2a cloudhead Hugglesworth regalia alvarezp ps-auxw execve Zeiris dolio araujo SamB_XP otto_s erikc` kfish kqrx edwinb_ Torrieri nettok path[l] gnuvince fbru02 weihsiu kmc applicative tommd blueonyx_ voidprayer joem86 Nereid_ roconnor lsthemes kamatsu Cale)
21:32:18 --- names: list (dnm_ hiptobecubic Reisen m0nkfish Raynes abbe the_andy glith holmak saccade_ SANDERS_ balboa02 mietek TacticalGrace medfly drbean copumpkin Niccus Rotaerk augur dfrey amiri Trafalgard MrDomino Nereid trin_cz tomoj horms NNshag M| _gaffer Alpounet sioraioc_ go|dfish DarthShrine cads solidsnack Philonous voker57_ tgdavies sigh endojelly jao dr_maligno imperialenforcer ulfdoz ystael Uawdal baaba_ elspru cygnus_ Dessous Sagi ddarius Modius IceDane)
21:32:18 --- names: list (hgolden arnihermann kar-1 niksnut gwern fredcy TR2N sjanssen J-Mad @monochrom kniu boyscared s76_ Liskni_si nick8325 ttvd lpsmith dobie_gillis prb lament rfh jlaire gjl_ jmcarthur temoto NEEDMOAR Dashkal aep Cthulhon Cobra^^ luite psault jims wto zhijie dMazz whoppix njbartlett ski lenbust_ mrothe C-S ray bd_ srcerer sebbe1991 wolverian pastorn Taggnostr eagletmt mmmdonuts jql Exteris_ MacCoaster_ ezrakilty kosmikus jontore tarbo EvanCarroll)
21:32:18 --- names: list (_Jordan_ poucet tilman gdsx Veinor otulp skaar_ axiom dons ath mdordal2 clarkb ennen sieni davidL flux dixie_ kolmodin flori_ FullMetalHarlot Bleadof glitch rntz icee_ Tomas_ bolmar_ koninkje1away netcat_ deavidsedice brx mokus_ tkr mchase gju cactii Beelsebob yottis Kyrus c9s__ ToRA matthew-_ prigaux Ke osfameron shepheb kwinz Khisanth Feuerbach opqdonut dejones Davse_Bamse saurik electrogeek nothingmuch dumael Apocalisp fihi09 michael|)
21:32:18 --- names: list (anekos noj zsol kynky Raevel merehap helgikrs jre2 reltuk dejai emias snhmib o-_-o dcolish ezeike oeblink Mortomes levitation_ mjrosenb vy Saizan cathper jtootf__ cods npouillard Berengal scree MoALTz quicksilver cjay jlouis equanimity Botje Eelis xerox Gowilla Aisling_ hackagebot ksf JaffaCake Astro Mr_Awesome eldragon absentia cgibreak Igloo tensorpudding shrughes gbeshers Colours tomberek Polarina qz untwisted gds jorizma mfp wang kadoban)
21:32:18 --- names: list (willb fnordus thetallguy1 thetallguy timlarson mikezackles @shapr jvogel sshc EvanR-work stephen_mcd zachk mikste Boney DekuNut TML thingwath _stenobot angerman jimmyjazz14 dropdrive nathanic_work ville The_third_man blackdog_ aluink Muad_Dibber guerrilla bburhans lostlogic inhortte khiroc Bassetts Blub\0 Peaker joevandyk mattam BMeph Gracenotes Axman6 Paradox924X suiside PsiOmega SimonRC profmakx ziman Nafai magicman jayne wharrgarble aavogt)
21:32:18 --- names: list (nathanic calvins tltstc pikhq sohum ve kaol eek jfredett newsham gspr MadX` pettter galdor Milo- qm13_ blazzy_ trez uorygl_ StarFire_ joga epmf thorkilnaur dmwit BONUS quuxman mreggen anders^^ Twey clanehin _Jedai_ tamiko fabjan AndyP nwf sahazel anji joni6128 hiredman CalJohn dilinger_ etpace kalven karld dcoutts gbacon Valodim jtra juhp bbee arjanoosting dqd lambdabot hellige shachaf Vulpyne nornagon smg Sisu mm_freak dfeuer alios solrize)
21:32:18 --- names: list (olsner BrianHV eelco_ sgf idnar sproingie birkenfeld arw smiler jfoutz Spockz BONUS_ mornfall yahooooo integral nniro Deewiant ClaudiusMaximus tromp coyo zygoloid aiko nimred kloeri jix lars_t Shimei djinni syntaxglitch Baughn int-e alip DigitalKiwi nasloc__ dreixel phnglui caligula_ p_l htoothrot laz0r eno harlekin canvon Counter-Strike jan_ noddy __marius__ ahihi deadguys Lemmih ttmrichter bwr mahogny dogmaT ksandstr wagle +preflex Innominate_)
21:32:18 --- names: list (Runar jonafan dufflebu1k saiam_ pen16 thoughtpolice ibid tafryn Laney gmux zax desu pragma_ orbitz andrewsw erk kw317 jedediah SmurfOR Raku^ geoaxis elly Twigathy Gilly impl stroan liesen sbok t koala_man shortcircuit keseldude aleator_ encryptio dino- agemo_ dax jml burp Cyneox Gabbie danderson leod rapacity peddie QtPlatypus wormwood mjv ahf jvoorhis zacharyp Stephan202 dionoea geir_ Tupis companion_cube mlh Zao jbauman taruti theclaw McManiaC)
21:32:18 --- names: list (OnionKnight_ AnMaster benmachine wdonnelly byorgey ido bran epokal cYmen bastian Loriel alexbobp daed_ shawn_ allbery_b webframp mercury^ FauxFaux And[y] Badger soeren felipe_ nlogax pcc1 ehamberg +lunabot Ornedan tab _br_ fritschy kakeman Jaak StoneToad_ shrimpx beza1e1 cheater Vq jdavis drhodes sothim DrSyzygy saccade anee dang`r`us mfoemmel gniourf_gniourf_ jystic det zaarg_ SubStack jrockway mrd kevinclark hariju_ jayrk djahandarie @ChanServ)
21:32:24 <clarkb> as solving that problem in that way is just wrong
21:32:32 --- topic: '["msg an op if you can't talk", "find ops: /msg ChanServ access list #haskell", "Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]'
21:32:32 --- topic: set by mauke on [Mon Jan 18 11:11:51 2010]
21:32:32 --- names: list (clog alexsuraci amuck miclorb bdimcheff emma seanl sShintah fhobia jones- Claviceps jsgf inimino Ferdirand zakwilson tmug lst``` ezyang lispy|web duairc potatishandlarn portnov joed novas0x2a cloudhead Hugglesworth regalia alvarezp ps-auxw execve Zeiris dolio araujo SamB_XP otto_s erikc` kfish kqrx edwinb_ Torrieri nettok path[l] gnuvince fbru02 weihsiu kmc applicative tommd blueonyx_ voidprayer joem86 Nereid_ roconnor lsthemes kamatsu Cale)
21:32:32 --- names: list (dnm_ hiptobecubic Reisen m0nkfish Raynes abbe the_andy glith holmak saccade_ SANDERS_ balboa02 mietek TacticalGrace medfly drbean copumpkin Niccus Rotaerk augur dfrey amiri Trafalgard MrDomino Nereid trin_cz tomoj horms NNshag M| _gaffer Alpounet sioraioc_ go|dfish DarthShrine cads solidsnack Philonous voker57_ tgdavies sigh endojelly jao dr_maligno imperialenforcer ulfdoz ystael Uawdal baaba_ elspru cygnus_ Dessous Sagi ddarius Modius IceDane)
21:32:32 --- names: list (hgolden arnihermann kar-1 niksnut gwern fredcy TR2N sjanssen J-Mad @monochrom kniu boyscared s76_ Liskni_si nick8325 ttvd lpsmith dobie_gillis prb lament rfh jlaire gjl_ jmcarthur temoto NEEDMOAR Dashkal aep Cthulhon Cobra^^ luite psault jims wto zhijie dMazz whoppix njbartlett ski lenbust_ mrothe C-S ray bd_ srcerer sebbe1991 wolverian pastorn Taggnostr eagletmt mmmdonuts jql Exteris_ MacCoaster_ ezrakilty kosmikus jontore tarbo EvanCarroll)
21:32:32 --- names: list (_Jordan_ poucet tilman gdsx Veinor otulp skaar_ axiom dons ath mdordal2 clarkb ennen sieni davidL flux dixie_ kolmodin flori_ FullMetalHarlot Bleadof glitch rntz icee_ Tomas_ bolmar_ koninkje1away netcat_ deavidsedice brx mokus_ tkr mchase gju cactii Beelsebob yottis Kyrus c9s__ ToRA matthew-_ prigaux Ke osfameron shepheb kwinz Khisanth Feuerbach opqdonut dejones Davse_Bamse saurik electrogeek nothingmuch dumael Apocalisp fihi09 michael|)
21:32:32 --- names: list (anekos noj zsol kynky Raevel merehap helgikrs jre2 reltuk dejai emias snhmib o-_-o dcolish ezeike oeblink Mortomes levitation_ mjrosenb vy Saizan cathper jtootf__ cods npouillard Berengal scree MoALTz quicksilver cjay jlouis equanimity Botje Eelis xerox Gowilla Aisling_ hackagebot ksf JaffaCake Astro Mr_Awesome eldragon absentia cgibreak Igloo tensorpudding shrughes gbeshers Colours tomberek Polarina qz untwisted gds jorizma mfp wang kadoban)
21:32:32 --- names: list (willb fnordus thetallguy1 thetallguy timlarson mikezackles @shapr jvogel sshc EvanR-work stephen_mcd zachk mikste Boney DekuNut TML thingwath _stenobot angerman jimmyjazz14 dropdrive nathanic_work ville The_third_man blackdog_ aluink Muad_Dibber guerrilla bburhans lostlogic inhortte khiroc Bassetts Blub\0 Peaker joevandyk mattam BMeph Gracenotes Axman6 Paradox924X suiside PsiOmega SimonRC profmakx ziman Nafai magicman jayne wharrgarble aavogt)
21:32:32 --- names: list (nathanic calvins tltstc pikhq sohum ve kaol eek jfredett newsham gspr MadX` pettter galdor Milo- qm13_ blazzy_ trez uorygl_ StarFire_ joga epmf thorkilnaur dmwit BONUS quuxman mreggen anders^^ Twey clanehin _Jedai_ tamiko fabjan AndyP nwf sahazel anji joni6128 hiredman CalJohn dilinger_ etpace kalven karld dcoutts gbacon Valodim jtra juhp bbee arjanoosting dqd lambdabot hellige shachaf Vulpyne nornagon smg Sisu mm_freak dfeuer alios solrize)
21:32:32 --- names: list (olsner BrianHV eelco_ sgf idnar sproingie birkenfeld arw smiler jfoutz Spockz BONUS_ mornfall yahooooo integral nniro Deewiant ClaudiusMaximus tromp coyo zygoloid aiko nimred kloeri jix lars_t Shimei djinni syntaxglitch Baughn int-e alip DigitalKiwi nasloc__ dreixel phnglui caligula_ p_l htoothrot laz0r eno harlekin canvon Counter-Strike jan_ noddy __marius__ ahihi deadguys Lemmih ttmrichter bwr mahogny dogmaT ksandstr wagle +preflex Innominate_)
21:32:32 --- names: list (Runar jonafan dufflebu1k saiam_ pen16 thoughtpolice ibid tafryn Laney gmux zax desu pragma_ orbitz andrewsw erk kw317 jedediah SmurfOR Raku^ geoaxis elly Twigathy Gilly impl stroan liesen sbok t koala_man shortcircuit keseldude aleator_ encryptio dino- agemo_ dax jml burp Cyneox Gabbie danderson leod rapacity peddie QtPlatypus wormwood mjv ahf jvoorhis zacharyp Stephan202 dionoea geir_ Tupis companion_cube mlh Zao jbauman taruti theclaw McManiaC)
21:32:32 --- names: list (OnionKnight_ AnMaster benmachine wdonnelly byorgey ido bran epokal cYmen bastian Loriel alexbobp daed_ shawn_ allbery_b webframp mercury^ FauxFaux And[y] Badger soeren felipe_ nlogax pcc1 ehamberg +lunabot Ornedan tab _br_ fritschy kakeman Jaak StoneToad_ shrimpx beza1e1 cheater Vq jdavis drhodes sothim DrSyzygy saccade anee dang`r`us mfoemmel gniourf_gniourf_ jystic det zaarg_ SubStack jrockway mrd kevinclark hariju_ jayrk djahandarie @ChanServ)
21:32:46 --- topic: '["msg an op if you can't talk", "find ops: /msg ChanServ access list #haskell", "Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]'
21:32:46 --- topic: set by mauke on [Mon Jan 18 11:11:51 2010]
21:32:46 --- names: list (clog amuck miclorb bdimcheff emma sShintah fhobia jones- Claviceps jsgf inimino Ferdirand zakwilson tmug lst``` ezyang lispy|web duairc potatishandlarn portnov joed novas0x2a cloudhead Hugglesworth regalia alvarezp ps-auxw execve Zeiris dolio araujo SamB_XP otto_s erikc` kfish kqrx edwinb_ Torrieri nettok path[l] gnuvince fbru02 weihsiu kmc applicative tommd blueonyx_ voidprayer joem86 Nereid_ roconnor lsthemes kamatsu Cale dnm_ hiptobecubic)
21:32:46 --- names: list (Reisen m0nkfish Raynes abbe the_andy glith holmak saccade_ SANDERS_ balboa02 mietek TacticalGrace medfly drbean copumpkin Niccus Rotaerk augur dfrey amiri Trafalgard MrDomino Nereid trin_cz tomoj horms NNshag M| _gaffer Alpounet sioraioc_ go|dfish DarthShrine cads solidsnack Philonous voker57_ tgdavies sigh endojelly jao dr_maligno imperialenforcer ulfdoz ystael Uawdal baaba_ elspru cygnus_ Dessous Sagi ddarius Modius IceDane hgolden arnihermann)
21:32:46 --- names: list (kar-1 niksnut gwern fredcy TR2N sjanssen J-Mad @monochrom kniu boyscared s76_ Liskni_si nick8325 ttvd lpsmith dobie_gillis prb lament rfh jlaire gjl_ jmcarthur temoto NEEDMOAR Dashkal Cthulhon Cobra^^ luite psault jims wto zhijie dMazz whoppix njbartlett ski lenbust_ mrothe C-S ray bd_ srcerer sebbe1991 wolverian pastorn Taggnostr eagletmt mmmdonuts jql Exteris_ MacCoaster_ ezrakilty kosmikus jontore tarbo EvanCarroll _Jordan_ poucet tilman)
21:32:46 --- names: list (gdsx Veinor otulp skaar_ axiom dons ath mdordal2 clarkb ennen sieni davidL flux dixie_ kolmodin flori_ FullMetalHarlot Bleadof glitch rntz icee_ Tomas_ bolmar_ koninkje1away netcat_ deavidsedice brx mokus_ tkr mchase gju cactii Beelsebob yottis Kyrus c9s__ ToRA matthew-_ prigaux Ke osfameron shepheb kwinz Khisanth Feuerbach opqdonut dejones Davse_Bamse saurik electrogeek nothingmuch dumael Apocalisp fihi09 michael| anekos noj zsol kynky Raevel)
21:32:46 --- names: list (merehap helgikrs jre2 reltuk dejai emias snhmib o-_-o dcolish ezeike oeblink Mortomes levitation_ mjrosenb vy Saizan cathper jtootf__ cods npouillard Berengal scree MoALTz quicksilver cjay jlouis equanimity Botje Eelis xerox Gowilla Aisling_ hackagebot ksf JaffaCake Astro Mr_Awesome eldragon absentia cgibreak Igloo tensorpudding shrughes gbeshers Colours tomberek Polarina qz untwisted gds jorizma mfp wang kadoban willb fnordus thetallguy1)
21:32:46 --- names: list (thetallguy timlarson mikezackles @shapr jvogel sshc EvanR-work stephen_mcd zachk mikste Boney DekuNut TML thingwath _stenobot angerman jimmyjazz14 dropdrive nathanic_work ville The_third_man blackdog_ aluink Muad_Dibber guerrilla bburhans lostlogic inhortte khiroc Bassetts Blub\0 Peaker joevandyk mattam BMeph Gracenotes Axman6 Paradox924X suiside PsiOmega SimonRC profmakx ziman Nafai magicman jayne wharrgarble aavogt nathanic calvins tltstc)
21:32:46 --- names: list (pikhq sohum ve kaol eek jfredett newsham gspr MadX` pettter galdor Milo- qm13_ blazzy_ trez uorygl_ StarFire_ joga epmf thorkilnaur dmwit BONUS quuxman mreggen anders^^ Twey clanehin _Jedai_ tamiko fabjan AndyP nwf sahazel anji joni6128 hiredman CalJohn dilinger_ etpace kalven karld dcoutts gbacon Valodim jtra juhp bbee arjanoosting dqd lambdabot hellige shachaf Vulpyne nornagon smg Sisu mm_freak dfeuer alios solrize olsner BrianHV eelco_)
21:32:46 --- names: list (sgf idnar sproingie birkenfeld arw smiler jfoutz Spockz BONUS_ mornfall yahooooo integral nniro Deewiant ClaudiusMaximus tromp coyo zygoloid aiko nimred kloeri jix lars_t Shimei djinni syntaxglitch Baughn int-e alip DigitalKiwi nasloc__ dreixel phnglui caligula_ p_l htoothrot laz0r eno harlekin canvon Counter-Strike jan_ noddy __marius__ ahihi deadguys Lemmih ttmrichter bwr mahogny dogmaT ksandstr wagle +preflex Innominate_ Runar jonafan)
21:32:46 --- names: list (dufflebu1k saiam_ pen16 thoughtpolice ibid tafryn Laney gmux zax desu pragma_ orbitz andrewsw erk kw317 jedediah SmurfOR Raku^ geoaxis elly Twigathy Gilly impl stroan liesen sbok t koala_man shortcircuit keseldude aleator_ encryptio dino- agemo_ dax jml burp Cyneox Gabbie danderson leod rapacity peddie QtPlatypus wormwood mjv ahf jvoorhis zacharyp Stephan202 dionoea geir_ Tupis companion_cube mlh Zao jbauman taruti theclaw McManiaC OnionKnight_)
21:32:46 --- names: list (AnMaster benmachine wdonnelly byorgey ido bran epokal cYmen bastian Loriel alexbobp daed_ shawn_ allbery_b webframp mercury^ FauxFaux And[y] Badger soeren felipe_ nlogax pcc1 ehamberg +lunabot Ornedan tab _br_ fritschy kakeman Jaak StoneToad_ shrimpx beza1e1 cheater Vq jdavis drhodes sothim DrSyzygy saccade anee dang`r`us mfoemmel gniourf_gniourf_ jystic det zaarg_ SubStack jrockway mrd kevinclark hariju_ jayrk djahandarie @ChanServ)
21:33:00 --- topic: '["msg an op if you can't talk", "find ops: /msg ChanServ access list #haskell", "Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]'
21:33:00 --- topic: set by mauke on [Mon Jan 18 11:11:51 2010]
21:33:00 --- names: list (clog alexsuraci amuck miclorb bdimcheff emma sShintah fhobia jones- Claviceps jsgf inimino Ferdirand zakwilson tmug lst``` ezyang lispy|web duairc potatishandlarn portnov joed novas0x2a cloudhead Hugglesworth regalia alvarezp ps-auxw execve Zeiris dolio araujo SamB_XP otto_s erikc` kfish kqrx edwinb_ Torrieri nettok path[l] gnuvince fbru02 weihsiu kmc applicative tommd blueonyx_ voidprayer joem86 Nereid_ roconnor lsthemes kamatsu Cale dnm_)
21:33:00 --- names: list (hiptobecubic Reisen m0nkfish Raynes abbe the_andy glith holmak saccade_ SANDERS_ balboa02 mietek TacticalGrace medfly drbean copumpkin Niccus Rotaerk augur dfrey amiri Trafalgard MrDomino Nereid trin_cz tomoj horms NNshag M| _gaffer Alpounet sioraioc_ go|dfish DarthShrine cads solidsnack Philonous voker57_ tgdavies sigh endojelly jao dr_maligno imperialenforcer ulfdoz ystael Uawdal baaba_ elspru cygnus_ Dessous Sagi ddarius Modius IceDane)
21:33:00 --- names: list (hgolden arnihermann kar-1 niksnut gwern fredcy TR2N sjanssen J-Mad @monochrom kniu boyscared s76_ Liskni_si nick8325 ttvd lpsmith dobie_gillis prb lament rfh jlaire gjl_ jmcarthur temoto NEEDMOAR Dashkal Cthulhon Cobra^^ luite psault jims wto zhijie dMazz whoppix njbartlett ski lenbust_ mrothe C-S ray bd_ srcerer sebbe1991 wolverian pastorn Taggnostr eagletmt mmmdonuts jql Exteris_ MacCoaster_ ezrakilty kosmikus jontore tarbo EvanCarroll)
21:33:00 --- names: list (_Jordan_ poucet tilman gdsx Veinor otulp skaar_ axiom dons ath mdordal2 clarkb ennen sieni davidL flux dixie_ kolmodin flori_ FullMetalHarlot Bleadof glitch rntz icee_ Tomas_ bolmar_ koninkje1away netcat_ deavidsedice brx mokus_ tkr mchase gju cactii Beelsebob yottis Kyrus c9s__ ToRA matthew-_ prigaux Ke osfameron shepheb kwinz Khisanth Feuerbach opqdonut dejones Davse_Bamse saurik electrogeek nothingmuch dumael Apocalisp fihi09 michael|)
21:33:00 --- names: list (anekos noj zsol kynky Raevel merehap helgikrs jre2 reltuk dejai emias snhmib o-_-o dcolish ezeike oeblink Mortomes levitation_ mjrosenb vy Saizan cathper jtootf__ cods npouillard Berengal scree MoALTz quicksilver cjay jlouis equanimity Botje Eelis xerox Gowilla Aisling_ hackagebot ksf JaffaCake Astro Mr_Awesome eldragon absentia cgibreak Igloo tensorpudding shrughes gbeshers Colours tomberek Polarina qz untwisted gds jorizma mfp wang kadoban)
21:33:00 --- names: list (willb fnordus thetallguy1 thetallguy timlarson mikezackles @shapr jvogel sshc EvanR-work stephen_mcd zachk mikste Boney DekuNut TML thingwath _stenobot angerman jimmyjazz14 dropdrive nathanic_work ville The_third_man blackdog_ aluink Muad_Dibber guerrilla bburhans lostlogic inhortte khiroc Bassetts Blub\0 Peaker joevandyk mattam BMeph Gracenotes Axman6 Paradox924X suiside PsiOmega SimonRC profmakx ziman Nafai magicman jayne wharrgarble aavogt)
21:33:00 --- names: list (nathanic calvins tltstc pikhq sohum ve kaol eek jfredett newsham gspr MadX` pettter galdor Milo- qm13_ blazzy_ trez uorygl_ StarFire_ joga epmf thorkilnaur dmwit BONUS quuxman mreggen anders^^ Twey clanehin _Jedai_ tamiko fabjan AndyP nwf sahazel anji joni6128 hiredman CalJohn dilinger_ etpace kalven karld dcoutts gbacon Valodim jtra juhp bbee arjanoosting dqd lambdabot hellige shachaf Vulpyne nornagon smg Sisu mm_freak dfeuer alios solrize)
21:33:00 --- names: list (olsner BrianHV eelco_ sgf idnar sproingie birkenfeld arw smiler jfoutz Spockz BONUS_ mornfall yahooooo integral nniro Deewiant ClaudiusMaximus tromp coyo zygoloid aiko nimred kloeri jix lars_t Shimei djinni syntaxglitch Baughn int-e alip DigitalKiwi nasloc__ dreixel phnglui caligula_ p_l htoothrot laz0r eno harlekin canvon Counter-Strike jan_ noddy __marius__ ahihi deadguys Lemmih ttmrichter bwr mahogny dogmaT ksandstr wagle +preflex Innominate_)
21:33:00 --- names: list (Runar jonafan dufflebu1k saiam_ pen16 thoughtpolice ibid tafryn Laney gmux zax desu pragma_ orbitz andrewsw erk kw317 jedediah SmurfOR Raku^ geoaxis elly Twigathy Gilly impl stroan liesen sbok t koala_man shortcircuit keseldude aleator_ encryptio dino- agemo_ dax jml burp Cyneox Gabbie danderson leod rapacity peddie QtPlatypus wormwood mjv ahf jvoorhis zacharyp Stephan202 dionoea geir_ Tupis companion_cube mlh Zao jbauman taruti theclaw McManiaC)
21:33:00 --- names: list (OnionKnight_ AnMaster benmachine wdonnelly byorgey ido bran epokal cYmen bastian Loriel alexbobp daed_ shawn_ allbery_b webframp mercury^ FauxFaux And[y] Badger soeren felipe_ nlogax pcc1 ehamberg +lunabot Ornedan tab _br_ fritschy kakeman Jaak StoneToad_ shrimpx beza1e1 cheater Vq jdavis drhodes sothim DrSyzygy saccade anee dang`r`us mfoemmel gniourf_gniourf_ jystic det zaarg_ SubStack jrockway mrd kevinclark hariju_ jayrk djahandarie @ChanServ)
21:33:04 <Axman6> shapr: hmm, ok it looks like it's causing lots of problems, maybe you should remove it
21:33:07 <kamatsu> Axman6: I am part of FP-Syd tho, maybe there??
21:33:14 --- topic: '["msg an op if you can't talk", "find ops: /msg ChanServ access list #haskell", "Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]'
21:33:14 --- topic: set by mauke on [Mon Jan 18 11:11:51 2010]
21:33:14 --- names: list (clog alexsuraci amuck miclorb bdimcheff emma sShintah fhobia jones- Claviceps jsgf inimino Ferdirand zakwilson tmug lst``` ezyang lispy|web duairc potatishandlarn portnov joed novas0x2a cloudhead Hugglesworth regalia alvarezp ps-auxw execve Zeiris dolio araujo SamB_XP otto_s erikc` kfish kqrx edwinb_ Torrieri nettok path[l] gnuvince fbru02 weihsiu kmc applicative tommd blueonyx_ voidprayer joem86 Nereid_ roconnor lsthemes kamatsu Cale dnm_)
21:33:14 --- names: list (hiptobecubic Reisen m0nkfish Raynes abbe the_andy glith holmak saccade_ SANDERS_ balboa02 mietek TacticalGrace medfly drbean copumpkin Niccus Rotaerk augur dfrey amiri Trafalgard MrDomino Nereid trin_cz tomoj horms NNshag M| _gaffer Alpounet sioraioc_ go|dfish DarthShrine cads solidsnack Philonous voker57_ tgdavies sigh endojelly jao dr_maligno imperialenforcer ulfdoz ystael Uawdal baaba_ elspru cygnus_ Dessous Sagi ddarius Modius IceDane)
21:33:14 --- names: list (hgolden arnihermann kar-1 niksnut gwern fredcy TR2N sjanssen J-Mad @monochrom kniu boyscared s76_ Liskni_si nick8325 ttvd lpsmith dobie_gillis prb lament rfh jlaire gjl_ jmcarthur temoto NEEDMOAR Dashkal Cthulhon Cobra^^ luite psault jims wto zhijie dMazz whoppix njbartlett ski lenbust_ mrothe C-S ray bd_ srcerer sebbe1991 wolverian pastorn Taggnostr eagletmt mmmdonuts jql Exteris_ MacCoaster_ ezrakilty kosmikus jontore tarbo EvanCarroll)
21:33:14 --- names: list (_Jordan_ poucet tilman gdsx Veinor otulp skaar_ axiom dons ath mdordal2 clarkb ennen sieni davidL flux dixie_ kolmodin flori_ FullMetalHarlot Bleadof glitch rntz icee_ Tomas_ bolmar_ koninkje1away netcat_ deavidsedice brx mokus_ tkr mchase gju cactii Beelsebob yottis Kyrus c9s__ ToRA matthew-_ prigaux Ke osfameron shepheb kwinz Khisanth Feuerbach opqdonut dejones Davse_Bamse saurik electrogeek nothingmuch dumael Apocalisp fihi09 michael|)
21:33:14 --- names: list (anekos noj zsol kynky Raevel merehap helgikrs jre2 reltuk dejai emias snhmib o-_-o dcolish ezeike oeblink Mortomes levitation_ mjrosenb vy Saizan cathper jtootf__ cods npouillard Berengal scree MoALTz quicksilver cjay jlouis equanimity Botje Eelis xerox Gowilla Aisling_ hackagebot ksf JaffaCake Astro Mr_Awesome eldragon absentia cgibreak Igloo tensorpudding shrughes gbeshers Colours tomberek Polarina qz untwisted gds jorizma mfp wang kadoban)
21:33:14 --- names: list (willb fnordus thetallguy1 thetallguy timlarson mikezackles @shapr jvogel sshc EvanR-work stephen_mcd zachk mikste Boney DekuNut TML thingwath _stenobot angerman jimmyjazz14 dropdrive nathanic_work ville The_third_man blackdog_ aluink Muad_Dibber guerrilla bburhans lostlogic inhortte khiroc Bassetts Blub\0 Peaker joevandyk mattam BMeph Gracenotes Axman6 Paradox924X suiside PsiOmega SimonRC profmakx ziman Nafai magicman jayne wharrgarble aavogt)
21:33:14 --- names: list (nathanic calvins tltstc pikhq sohum ve kaol eek jfredett newsham gspr MadX` pettter galdor Milo- qm13_ blazzy_ trez uorygl_ StarFire_ joga epmf thorkilnaur dmwit BONUS quuxman mreggen anders^^ Twey clanehin _Jedai_ tamiko fabjan AndyP nwf sahazel anji joni6128 hiredman CalJohn dilinger_ etpace kalven karld dcoutts gbacon Valodim jtra juhp bbee arjanoosting dqd lambdabot hellige shachaf Vulpyne nornagon smg Sisu mm_freak dfeuer alios solrize)
21:33:14 --- names: list (olsner BrianHV eelco_ sgf idnar sproingie birkenfeld arw smiler jfoutz Spockz BONUS_ mornfall yahooooo integral nniro Deewiant ClaudiusMaximus tromp coyo zygoloid aiko nimred kloeri jix lars_t Shimei djinni syntaxglitch Baughn int-e alip DigitalKiwi nasloc__ dreixel phnglui caligula_ p_l htoothrot laz0r eno harlekin canvon Counter-Strike jan_ noddy __marius__ ahihi deadguys Lemmih ttmrichter bwr mahogny dogmaT ksandstr wagle +preflex Innominate_)
21:33:14 --- names: list (Runar jonafan dufflebu1k saiam_ pen16 thoughtpolice ibid tafryn Laney gmux zax desu pragma_ orbitz andrewsw erk kw317 jedediah SmurfOR Raku^ geoaxis elly Twigathy Gilly impl stroan liesen sbok t koala_man shortcircuit keseldude aleator_ encryptio dino- agemo_ dax jml burp Cyneox Gabbie danderson leod rapacity peddie QtPlatypus wormwood mjv ahf jvoorhis zacharyp Stephan202 dionoea geir_ Tupis companion_cube mlh Zao jbauman taruti theclaw McManiaC)
21:33:14 --- names: list (OnionKnight_ AnMaster benmachine wdonnelly byorgey ido bran epokal cYmen bastian Loriel alexbobp daed_ shawn_ allbery_b webframp mercury^ FauxFaux And[y] Badger soeren felipe_ nlogax pcc1 ehamberg +lunabot Ornedan tab _br_ fritschy kakeman Jaak StoneToad_ shrimpx beza1e1 cheater Vq jdavis drhodes sothim DrSyzygy saccade anee dang`r`us mfoemmel gniourf_gniourf_ jystic det zaarg_ SubStack jrockway mrd kevinclark hariju_ jayrk djahandarie @ChanServ)
21:33:18 <Axman6> kamatsu: fair enough
21:33:25 <Axman6> i haven't been to FP-Syd (yet)
21:33:29 <clarkb> o-_-o: you might ask for something like a tree traversal
21:33:38 --- topic: '["msg an op if you can't talk", "find ops: /msg ChanServ access list #haskell", "Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]'
21:33:38 --- topic: set by mauke on [Mon Jan 18 11:11:51 2010]
21:33:38 --- names: list (clog triplez skeptomai|away amuck miclorb bdimcheff emma sShintah fhobia jones- Claviceps jsgf inimino Ferdirand zakwilson tmug lst``` ezyang lispy|web duairc potatishandlarn portnov joed novas0x2a cloudhead Hugglesworth regalia alvarezp ps-auxw execve Zeiris dolio araujo SamB_XP otto_s erikc` kfish kqrx edwinb_ Torrieri nettok path[l] gnuvince fbru02 weihsiu kmc applicative tommd blueonyx_ voidprayer joem86 Nereid_ roconnor lsthemes kamatsu)
21:33:38 --- names: list (Cale dnm_ hiptobecubic Reisen m0nkfish Raynes abbe the_andy glith holmak saccade_ SANDERS_ balboa02 mietek TacticalGrace medfly drbean copumpkin Niccus Rotaerk augur dfrey amiri Trafalgard MrDomino Nereid trin_cz tomoj horms NNshag M| _gaffer Alpounet sioraioc_ go|dfish DarthShrine cads solidsnack Philonous voker57_ tgdavies sigh endojelly jao dr_maligno imperialenforcer ulfdoz ystael Uawdal baaba_ elspru cygnus_ Dessous Sagi ddarius Modius)
21:33:38 --- names: list (IceDane hgolden arnihermann kar-1 niksnut gwern fredcy TR2N sjanssen J-Mad @monochrom kniu boyscared s76_ Liskni_si nick8325 ttvd lpsmith dobie_gillis prb lament rfh jlaire gjl_ jmcarthur temoto NEEDMOAR Dashkal Cthulhon Cobra^^ luite psault jims wto zhijie dMazz whoppix njbartlett ski lenbust_ mrothe C-S ray bd_ srcerer sebbe1991 wolverian pastorn Taggnostr eagletmt mmmdonuts jql Exteris_ MacCoaster_ ezrakilty kosmikus jontore tarbo EvanCarroll)
21:33:38 --- names: list (_Jordan_ poucet tilman gdsx Veinor otulp skaar_ axiom dons ath mdordal2 clarkb ennen sieni davidL flux dixie_ kolmodin flori_ FullMetalHarlot Bleadof glitch rntz icee_ Tomas_ bolmar_ koninkje1away netcat_ deavidsedice brx mokus_ tkr mchase gju cactii Beelsebob yottis Kyrus c9s__ ToRA matthew-_ prigaux Ke osfameron shepheb kwinz Khisanth Feuerbach opqdonut dejones Davse_Bamse saurik electrogeek nothingmuch dumael Apocalisp fihi09 michael|)
21:33:38 --- names: list (anekos noj zsol kynky Raevel merehap helgikrs jre2 reltuk dejai emias snhmib o-_-o dcolish ezeike oeblink Mortomes levitation_ mjrosenb vy Saizan cathper jtootf__ cods npouillard Berengal scree MoALTz quicksilver cjay jlouis equanimity Botje Eelis xerox Gowilla Aisling_ hackagebot ksf JaffaCake Astro Mr_Awesome eldragon absentia cgibreak Igloo tensorpudding shrughes gbeshers Colours tomberek Polarina qz untwisted gds jorizma mfp wang kadoban)
21:33:38 --- names: list (willb fnordus thetallguy1 thetallguy timlarson mikezackles @shapr jvogel sshc EvanR-work stephen_mcd zachk mikste Boney DekuNut TML thingwath _stenobot angerman jimmyjazz14 dropdrive nathanic_work ville The_third_man blackdog_ aluink Muad_Dibber guerrilla bburhans lostlogic inhortte khiroc Bassetts Blub\0 Peaker joevandyk mattam BMeph Gracenotes Axman6 Paradox924X suiside PsiOmega SimonRC profmakx ziman Nafai magicman jayne wharrgarble aavogt)
21:33:38 --- names: list (nathanic calvins tltstc pikhq sohum ve kaol eek jfredett newsham gspr MadX` pettter galdor Milo- qm13_ blazzy_ trez uorygl_ StarFire_ joga epmf thorkilnaur dmwit BONUS quuxman mreggen anders^^ Twey clanehin _Jedai_ tamiko fabjan AndyP nwf sahazel anji joni6128 hiredman CalJohn dilinger_ etpace kalven karld dcoutts gbacon Valodim jtra juhp bbee arjanoosting dqd lambdabot hellige shachaf Vulpyne nornagon smg Sisu mm_freak dfeuer alios solrize)
21:33:38 --- names: list (olsner BrianHV eelco_ sgf idnar sproingie birkenfeld arw smiler jfoutz Spockz BONUS_ mornfall yahooooo integral nniro Deewiant ClaudiusMaximus tromp coyo zygoloid aiko nimred kloeri jix lars_t Shimei djinni syntaxglitch Baughn int-e alip DigitalKiwi nasloc__ dreixel phnglui caligula_ p_l htoothrot laz0r eno harlekin canvon Counter-Strike jan_ noddy __marius__ ahihi deadguys Lemmih ttmrichter bwr mahogny dogmaT ksandstr wagle +preflex Innominate_)
21:33:38 --- names: list (Runar jonafan dufflebu1k saiam_ pen16 thoughtpolice ibid tafryn Laney gmux zax desu pragma_ orbitz andrewsw erk kw317 jedediah SmurfOR Raku^ geoaxis elly Twigathy Gilly impl stroan liesen sbok t koala_man shortcircuit keseldude aleator_ encryptio dino- agemo_ dax jml burp Cyneox Gabbie danderson leod rapacity peddie QtPlatypus wormwood mjv ahf jvoorhis zacharyp Stephan202 dionoea geir_ Tupis companion_cube mlh Zao jbauman taruti theclaw McManiaC)
21:33:38 --- names: list (OnionKnight_ AnMaster benmachine wdonnelly byorgey ido bran epokal cYmen bastian Loriel alexbobp daed_ shawn_ allbery_b webframp mercury^ FauxFaux And[y] Badger soeren felipe_ nlogax pcc1 ehamberg +lunabot Ornedan tab _br_ fritschy kakeman Jaak StoneToad_ shrimpx beza1e1 cheater Vq jdavis drhodes sothim DrSyzygy saccade anee dang`r`us mfoemmel gniourf_gniourf_ jystic det zaarg_ SubStack jrockway mrd kevinclark hariju_ jayrk djahandarie @ChanServ)
21:33:54 <o-_-o> clarkb, I should know tree traversal first for that :-)
21:33:57 <kamatsu> Axman6: No actually, but i just jump in whenever they meet, because they meet at my workplace
21:34:15 <Axman6> google?
21:34:20 <kamatsu> Axman6: indeed
21:34:20 <clarkb> and have them do it in pre, in, and post orders
21:34:40 <o-_-o> clarkb, ok
21:35:01 <kamatsu> specifically Wave, and the operation transforms stuff
21:35:09 <Axman6> kamatsu: i know your name from somewhere anyway
21:35:10 <clarkb> o-_-o: questions like that are doubly good when they can test multiple things at once
21:35:13 <kamatsu> which is so much better suited to Haskell than Java, but sigh
21:35:22 <kamatsu> Axman6: Probably, have anything to do with Informatics Olympiad?
21:35:23 <clarkb> in a case like that you get recursion and an understanding of trees
21:35:24 <monochrom> o-_-o: I first learned BASIC and Pascal and conventional imperative programming (not even OO). Because recursion was taught, and the good practice of "use fewer global vars, use more parameter passing" was taught, pretty soon I could see how to replace mutable variables by recursion and parameter passing. Even when I wrote recursive directory-walking code for my own curiosity, I could see the two choices and how to translate
21:35:24 <monochrom> between. These were before I was taught FP. So your question is a perfectly fair question, any 2nd-year CS student could do it when asked.
21:35:32 <Axman6> heh, i logged back into my wave account for the first time in about 2 months today
21:35:39 <Axman6> nope
21:35:54 <Axman6> kamatsu: -> #haskell-blah ?
21:35:59 <o-_-o> monochrom, ok...thanks
21:36:07 <kamatsu> Axman6: ok
21:37:00 <o-_-o> in fact I gave this question some of my team mates first and then am planning to give to the candidate if they succeed, I don't want to come across as someone who is putting up artificially high barriers for entry
21:37:25 * clarkb would lol if someone wrote embedded asm to do it
21:37:48 <monochrom> Then again I'm talking about CS education 20 years ago. CS education today may be completely dumb.
21:38:05 <clarkb> monochrom: recursion is still actively taught where I go to school
21:38:18 <clarkb> but a problem like that doesnt tell you much about the candidate
21:38:32 <o-_-o> monochrom, they don't even learn fortran today in schools in CS, they are taught C/C++, java and C#
21:39:16 <o-_-o> which is worse than what I was taught and I didn't study CS
21:39:32 <clarkb> in CS they dont teach you to program...
21:40:34 <o-_-o> clarkb, I don't understand (honestly) because that is what people think they do here
21:41:25 <clarkb> You learn Data Structures, Algorithms, Logic, Discrete Math, Language theory, etc and happen to pick up programming on the way
21:43:13 <o-_-o> @remember clarkb,  in CS they dont teach you to program...You learn Data Structures, Algorithms, Logic, Discrete Math, Language theory, etc and happen to pick up programming on the way
21:43:13 <lambdabot> Good to know.
21:44:18 <lament> and that explains why CS graduates can't program
21:44:30 <kamatsu> lament: that's a generalization
21:44:33 <pikhq> Well, yeah.
21:44:33 <clarkb> my first exposure to FP was through mosml. Professor wanted an RE -> NFA -> DFA converter in mosml. He didnt teach any mosml to me
21:44:48 <clarkb> I learned real quick though
21:44:55 <monochrom> mosml has the best module system ever.
21:44:56 <pikhq> Most of the CS graduates that can program either already can or learn really quick.
21:45:16 <pikhq> I'm not entirely sure how you're supposed to even do data structures well without programming knowledge..
21:45:36 <pikhq> Particularly since they tend to do that in a C-oid language.
21:45:49 <pikhq> Or Java.
21:45:50 <nolrai_FG> Though the compilers class tought programing in the you fail if you cant figure it out way.
21:46:39 <clarkb> lament: yes, many can't
21:47:04 <pikhq> nolrai_FG: Yeah, I don't think it's even possible to get >10% in such a course.
21:49:02 --- topic: '["msg an op if you can't talk", "find ops: /msg ChanServ access list #haskell", "Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]'
21:49:02 --- topic: set by mauke on [Mon Jan 18 11:11:51 2010]
21:49:02 --- names: list (clog Stefa1 tgdavies_ tlm texodus emma nolrai_FG path[l] ablokzijl StoneToad__ QinGW headyadmin triplez amuck miclorb bdimcheff sShintah fhobia jones- Claviceps jsgf inimino Ferdirand zakwilson tmug lst``` lispy|web duairc potatishandlarn portnov joed novas0x2a Hugglesworth regalia alvarezp ps-auxw execve Zeiris dolio araujo SamB_XP otto_s erikc` kfish kqrx edwinb_ Torrieri nettok gnuvince fbru02 weihsiu kmc applicative tommd blueonyx_ voidprayer)
21:49:02 --- names: list (joem86 roconnor lsthemes kamatsu Cale dnm_ hiptobecubic Reisen m0nkfish Raynes abbe the_andy glith holmak saccade_ SANDERS_ balboa02 mietek TacticalGrace medfly drbean copumpkin Niccus Rotaerk augur dfrey amiri Trafalgard MrDomino Nereid trin_cz tomoj horms NNshag M| _gaffer Alpounet sioraioc_ go|dfish DarthShrine cads solidsnack Philonous voker57_ tgdavies sigh endojelly jao dr_maligno imperialenforcer ulfdoz ystael Uawdal baaba_ elspru)
21:49:02 --- names: list (cygnus_ Dessous Sagi ddarius IceDane hgolden arnihermann kar-1 niksnut gwern fredcy TR2N sjanssen J-Mad @monochrom kniu boyscared s76_ Liskni_si nick8325 ttvd lpsmith dobie_gillis prb lament rfh jlaire gjl_ jmcarthur temoto NEEDMOAR Dashkal Cthulhon Cobra^^ luite psault jims wto zhijie dMazz whoppix njbartlett ski lenbust_ mrothe C-S ray bd_ srcerer sebbe1991 wolverian pastorn Taggnostr eagletmt mmmdonuts jql Exteris_ MacCoaster_ ezrakilty)
21:49:02 --- names: list (kosmikus jontore tarbo EvanCarroll _Jordan_ poucet tilman gdsx Veinor otulp skaar_ axiom dons ath mdordal2 clarkb ennen sieni davidL flux dixie_ kolmodin flori_ FullMetalHarlot Bleadof glitch rntz icee_ Tomas_ bolmar_ koninkje1away netcat_ deavidsedice brx mokus_ tkr mchase gju cactii Beelsebob yottis Kyrus c9s__ ToRA matthew-_ prigaux Ke osfameron shepheb kwinz Khisanth Feuerbach opqdonut dejones Davse_Bamse saurik electrogeek nothingmuch)
21:49:02 --- names: list (dumael Apocalisp fihi09 michael| anekos noj zsol kynky Raevel merehap helgikrs jre2 reltuk dejai emias snhmib o-_-o dcolish ezeike oeblink Mortomes levitation_ mjrosenb vy Saizan cathper jtootf__ cods npouillard Berengal scree MoALTz quicksilver cjay jlouis equanimity Botje Eelis xerox Gowilla Aisling_ hackagebot ksf JaffaCake Astro Mr_Awesome eldragon absentia cgibreak Igloo tensorpudding shrughes gbeshers Colours tomberek Polarina qz untwisted)
21:49:02 --- names: list (gds jorizma mfp wang kadoban willb fnordus thetallguy1 thetallguy timlarson mikezackles @shapr jvogel sshc EvanR-work stephen_mcd zachk mikste Boney DekuNut TML thingwath _stenobot angerman jimmyjazz14 dropdrive nathanic_work ville The_third_man blackdog_ aluink Muad_Dibber guerrilla bburhans lostlogic inhortte khiroc Bassetts Blub\0 Peaker joevandyk mattam BMeph Gracenotes Axman6 Paradox924X suiside PsiOmega SimonRC profmakx ziman Nafai)
21:49:02 --- names: list (magicman jayne wharrgarble aavogt nathanic calvins tltstc pikhq sohum ve kaol eek jfredett newsham gspr MadX` pettter galdor Milo- qm13_ blazzy_ trez uorygl_ StarFire_ joga epmf thorkilnaur dmwit BONUS quuxman mreggen anders^^ Twey clanehin _Jedai_ tamiko fabjan AndyP nwf sahazel anji joni6128 hiredman CalJohn dilinger_ etpace kalven karld dcoutts gbacon Valodim jtra juhp bbee arjanoosting dqd lambdabot hellige shachaf Vulpyne nornagon smg)
21:49:02 --- names: list (Sisu mm_freak dfeuer alios solrize olsner BrianHV eelco_ sgf idnar sproingie birkenfeld arw smiler jfoutz Spockz BONUS_ mornfall yahooooo integral nniro Deewiant ClaudiusMaximus tromp coyo zygoloid aiko nimred kloeri jix lars_t Shimei djinni syntaxglitch Baughn int-e alip DigitalKiwi nasloc__ dreixel phnglui caligula_ p_l htoothrot laz0r eno harlekin canvon Counter-Strike jan_ noddy __marius__ ahihi deadguys Lemmih ttmrichter bwr mahogny)
21:49:02 --- names: list (dogmaT ksandstr wagle +preflex Innominate_ Runar jonafan dufflebu1k saiam_ pen16 thoughtpolice ibid tafryn Laney gmux zax desu pragma_ orbitz andrewsw erk kw317 jedediah SmurfOR Raku^ geoaxis elly Twigathy Gilly impl stroan liesen sbok t koala_man shortcircuit keseldude aleator_ encryptio dino- agemo_ dax jml burp Cyneox Gabbie danderson leod rapacity peddie QtPlatypus wormwood mjv ahf jvoorhis zacharyp Stephan202 dionoea geir_ Tupis companion_cube)
21:49:02 --- names: list (mlh Zao jbauman taruti theclaw McManiaC OnionKnight_ AnMaster benmachine wdonnelly byorgey ido bran epokal cYmen bastian Loriel alexbobp daed_ shawn_ allbery_b webframp mercury^ FauxFaux And[y] Badger soeren felipe_ nlogax pcc1 ehamberg +lunabot Ornedan tab _br_ fritschy kakeman Jaak StoneToad_ shrimpx beza1e1 cheater Vq jdavis drhodes sothim DrSyzygy saccade anee dang`r`us mfoemmel gniourf_gniourf_ jystic det zaarg_ SubStack jrockway mrd)
21:49:02 --- names: list (kevinclark hariju_ jayrk djahandarie @ChanServ)
21:49:20 --- topic: '["msg an op if you can't talk", "find ops: /msg ChanServ access list #haskell", "Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]'
21:49:20 --- topic: set by mauke on [Mon Jan 18 11:11:51 2010]
21:49:20 --- names: list (clog alexsuraci tgdavies_ tlm texodus emma nolrai_FG path[l] ablokzijl StoneToad__ QinGW headyadmin triplez amuck miclorb bdimcheff sShintah fhobia jones- Claviceps jsgf inimino Ferdirand zakwilson tmug lst``` lispy|web duairc potatishandlarn portnov joed novas0x2a Hugglesworth regalia alvarezp ps-auxw execve Zeiris dolio araujo SamB_XP otto_s erikc` kfish kqrx edwinb_ Torrieri nettok gnuvince fbru02 weihsiu kmc applicative tommd blueonyx_)
21:49:20 --- names: list (voidprayer joem86 roconnor lsthemes kamatsu Cale dnm_ hiptobecubic Reisen m0nkfish Raynes abbe the_andy glith holmak saccade_ SANDERS_ balboa02 mietek TacticalGrace medfly drbean copumpkin Niccus Rotaerk augur dfrey amiri Trafalgard MrDomino Nereid trin_cz tomoj horms NNshag M| _gaffer Alpounet sioraioc_ go|dfish DarthShrine cads solidsnack Philonous voker57_ tgdavies sigh endojelly jao dr_maligno imperialenforcer ulfdoz ystael Uawdal baaba_)
21:49:20 --- names: list (elspru cygnus_ Dessous Sagi ddarius IceDane hgolden arnihermann kar-1 niksnut gwern fredcy TR2N sjanssen J-Mad @monochrom kniu boyscared s76_ Liskni_si nick8325 ttvd lpsmith dobie_gillis prb lament rfh jlaire gjl_ jmcarthur temoto NEEDMOAR Dashkal Cthulhon Cobra^^ luite psault jims wto zhijie dMazz whoppix njbartlett ski lenbust_ mrothe C-S ray bd_ srcerer sebbe1991 wolverian pastorn Taggnostr eagletmt mmmdonuts jql Exteris_ MacCoaster_ ezrakilty)
21:49:20 --- names: list (kosmikus jontore tarbo EvanCarroll _Jordan_ poucet tilman gdsx Veinor otulp skaar_ axiom dons ath mdordal2 clarkb ennen sieni davidL flux dixie_ kolmodin flori_ FullMetalHarlot Bleadof glitch rntz icee_ Tomas_ bolmar_ koninkje1away netcat_ deavidsedice brx mokus_ tkr mchase gju cactii Beelsebob yottis Kyrus c9s__ ToRA matthew-_ prigaux Ke osfameron shepheb kwinz Khisanth Feuerbach opqdonut dejones Davse_Bamse saurik electrogeek nothingmuch)
21:49:20 --- names: list (dumael Apocalisp fihi09 michael| anekos noj zsol kynky Raevel merehap helgikrs jre2 reltuk dejai emias snhmib o-_-o dcolish ezeike oeblink Mortomes levitation_ mjrosenb vy Saizan cathper jtootf__ cods npouillard Berengal scree MoALTz quicksilver cjay jlouis equanimity Botje Eelis xerox Gowilla Aisling_ hackagebot ksf JaffaCake Astro Mr_Awesome eldragon absentia cgibreak Igloo tensorpudding shrughes gbeshers Colours tomberek Polarina qz untwisted)
21:49:20 --- names: list (gds jorizma mfp wang kadoban willb fnordus thetallguy1 thetallguy timlarson mikezackles @shapr jvogel sshc EvanR-work stephen_mcd zachk mikste Boney DekuNut TML thingwath _stenobot angerman jimmyjazz14 dropdrive nathanic_work ville The_third_man blackdog_ aluink Muad_Dibber guerrilla bburhans lostlogic inhortte khiroc Bassetts Blub\0 Peaker joevandyk mattam BMeph Gracenotes Axman6 Paradox924X suiside PsiOmega SimonRC profmakx ziman Nafai)
21:49:20 --- names: list (magicman jayne wharrgarble aavogt nathanic calvins tltstc pikhq sohum ve kaol eek jfredett newsham gspr MadX` pettter galdor Milo- qm13_ blazzy_ trez uorygl_ StarFire_ joga epmf thorkilnaur dmwit BONUS quuxman mreggen anders^^ Twey clanehin _Jedai_ tamiko fabjan AndyP nwf sahazel anji joni6128 hiredman CalJohn dilinger_ etpace kalven karld dcoutts gbacon Valodim jtra juhp bbee arjanoosting dqd lambdabot hellige shachaf Vulpyne nornagon smg)
21:49:20 --- names: list (Sisu mm_freak dfeuer alios solrize olsner BrianHV eelco_ sgf idnar sproingie birkenfeld arw smiler jfoutz Spockz BONUS_ mornfall yahooooo integral nniro Deewiant ClaudiusMaximus tromp coyo zygoloid aiko nimred kloeri jix lars_t Shimei djinni syntaxglitch Baughn int-e alip DigitalKiwi nasloc__ dreixel phnglui caligula_ p_l htoothrot laz0r eno harlekin canvon Counter-Strike jan_ noddy __marius__ ahihi deadguys Lemmih ttmrichter bwr mahogny)
21:49:20 --- names: list (dogmaT ksandstr wagle +preflex Innominate_ Runar jonafan dufflebu1k saiam_ pen16 thoughtpolice ibid tafryn Laney gmux zax desu pragma_ orbitz andrewsw erk kw317 jedediah SmurfOR Raku^ geoaxis elly Twigathy Gilly impl stroan liesen sbok t koala_man shortcircuit keseldude aleator_ encryptio dino- agemo_ dax jml burp Cyneox Gabbie danderson leod rapacity peddie QtPlatypus wormwood mjv ahf jvoorhis zacharyp Stephan202 dionoea geir_ Tupis companion_cube)
21:49:20 --- names: list (mlh Zao jbauman taruti theclaw McManiaC OnionKnight_ AnMaster benmachine wdonnelly byorgey ido bran epokal cYmen bastian Loriel alexbobp daed_ shawn_ allbery_b webframp mercury^ FauxFaux And[y] Badger soeren felipe_ nlogax pcc1 ehamberg +lunabot Ornedan tab _br_ fritschy kakeman Jaak StoneToad_ shrimpx beza1e1 cheater Vq jdavis drhodes sothim DrSyzygy saccade anee dang`r`us mfoemmel gniourf_gniourf_ jystic det zaarg_ SubStack jrockway mrd)
21:49:20 --- names: list (kevinclark hariju_ jayrk djahandarie @ChanServ)
21:49:35 --- topic: '["msg an op if you can't talk", "find ops: /msg ChanServ access list #haskell", "Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]'
21:49:35 --- topic: set by mauke on [Mon Jan 18 11:11:51 2010]
21:49:35 --- names: list (clog alexsuraci skeptomai|away tgdavies_ tlm texodus emma nolrai_FG path[l] ablokzijl StoneToad__ headyadmin triplez amuck miclorb bdimcheff sShintah fhobia jones- Claviceps jsgf inimino Ferdirand zakwilson tmug lst``` lispy|web duairc potatishandlarn portnov joed novas0x2a Hugglesworth regalia alvarezp ps-auxw execve Zeiris dolio araujo SamB_XP otto_s erikc` kfish kqrx edwinb_ Torrieri nettok gnuvince fbru02 weihsiu kmc applicative tommd)
21:49:35 --- names: list (blueonyx_ voidprayer joem86 roconnor lsthemes kamatsu Cale dnm_ hiptobecubic Reisen m0nkfish Raynes abbe the_andy glith holmak saccade_ SANDERS_ balboa02 mietek TacticalGrace medfly drbean copumpkin Niccus Rotaerk augur dfrey amiri Trafalgard MrDomino Nereid trin_cz tomoj horms NNshag M| _gaffer Alpounet sioraioc_ go|dfish DarthShrine cads solidsnack Philonous voker57_ tgdavies sigh endojelly jao dr_maligno imperialenforcer ulfdoz ystael)
21:49:35 --- names: list (Uawdal baaba_ elspru cygnus_ Dessous Sagi ddarius IceDane hgolden arnihermann kar-1 niksnut gwern fredcy TR2N sjanssen J-Mad @monochrom kniu boyscared s76_ Liskni_si nick8325 ttvd lpsmith dobie_gillis prb lament rfh jlaire gjl_ jmcarthur temoto NEEDMOAR Dashkal Cthulhon Cobra^^ luite psault jims wto zhijie dMazz whoppix njbartlett ski lenbust_ mrothe C-S ray bd_ srcerer sebbe1991 wolverian pastorn Taggnostr eagletmt mmmdonuts jql Exteris_)
21:49:35 --- names: list (MacCoaster_ ezrakilty kosmikus jontore tarbo EvanCarroll _Jordan_ poucet tilman gdsx Veinor otulp skaar_ axiom dons ath mdordal2 clarkb ennen sieni davidL flux dixie_ kolmodin flori_ FullMetalHarlot Bleadof glitch rntz icee_ Tomas_ bolmar_ koninkje1away netcat_ deavidsedice brx mokus_ tkr mchase gju cactii Beelsebob yottis Kyrus c9s__ ToRA matthew-_ prigaux Ke osfameron shepheb kwinz Khisanth Feuerbach opqdonut dejones Davse_Bamse saurik)
21:49:35 --- names: list (electrogeek nothingmuch dumael Apocalisp fihi09 michael| anekos noj zsol kynky Raevel merehap helgikrs jre2 reltuk dejai emias snhmib o-_-o dcolish ezeike oeblink Mortomes levitation_ mjrosenb vy Saizan cathper jtootf__ cods npouillard Berengal scree MoALTz quicksilver cjay jlouis equanimity Botje Eelis xerox Gowilla Aisling_ hackagebot ksf JaffaCake Astro Mr_Awesome eldragon absentia cgibreak Igloo tensorpudding shrughes gbeshers Colours)
21:49:35 --- names: list (tomberek Polarina qz untwisted gds jorizma mfp wang kadoban willb fnordus thetallguy1 thetallguy timlarson mikezackles @shapr jvogel sshc EvanR-work stephen_mcd zachk mikste Boney DekuNut TML thingwath _stenobot angerman jimmyjazz14 dropdrive nathanic_work ville The_third_man blackdog_ aluink Muad_Dibber guerrilla bburhans lostlogic inhortte khiroc Bassetts Blub\0 Peaker joevandyk mattam BMeph Gracenotes Axman6 Paradox924X suiside PsiOmega)
21:49:35 --- names: list (SimonRC profmakx ziman Nafai magicman jayne wharrgarble aavogt nathanic calvins tltstc pikhq sohum ve kaol eek jfredett newsham gspr MadX` pettter galdor Milo- qm13_ blazzy_ trez uorygl_ StarFire_ joga epmf thorkilnaur dmwit BONUS quuxman mreggen anders^^ Twey clanehin _Jedai_ tamiko fabjan AndyP nwf sahazel anji joni6128 hiredman CalJohn dilinger_ etpace kalven karld dcoutts gbacon Valodim jtra juhp bbee arjanoosting dqd lambdabot hellige)
21:49:35 --- names: list (shachaf Vulpyne nornagon smg Sisu mm_freak dfeuer alios solrize olsner BrianHV eelco_ sgf idnar sproingie birkenfeld arw smiler jfoutz Spockz BONUS_ mornfall yahooooo integral nniro Deewiant ClaudiusMaximus tromp coyo zygoloid aiko nimred kloeri jix lars_t Shimei djinni syntaxglitch Baughn int-e alip DigitalKiwi nasloc__ dreixel phnglui caligula_ p_l htoothrot laz0r eno harlekin canvon Counter-Strike jan_ noddy __marius__ ahihi deadguys Lemmih)
21:49:35 --- names: list (ttmrichter bwr mahogny dogmaT ksandstr wagle +preflex Innominate_ Runar jonafan dufflebu1k saiam_ pen16 thoughtpolice ibid tafryn Laney gmux zax desu pragma_ orbitz andrewsw erk kw317 jedediah SmurfOR Raku^ geoaxis elly Twigathy Gilly impl stroan liesen sbok t koala_man shortcircuit keseldude aleator_ encryptio dino- agemo_ dax jml burp Cyneox Gabbie danderson leod rapacity peddie QtPlatypus wormwood mjv ahf jvoorhis zacharyp Stephan202 dionoea)
21:49:35 --- names: list (geir_ Tupis companion_cube mlh Zao jbauman taruti theclaw McManiaC OnionKnight_ AnMaster benmachine wdonnelly byorgey ido bran epokal cYmen bastian Loriel alexbobp daed_ shawn_ allbery_b webframp mercury^ FauxFaux And[y] Badger soeren felipe_ nlogax pcc1 ehamberg +lunabot Ornedan tab _br_ fritschy kakeman Jaak StoneToad_ shrimpx beza1e1 cheater Vq jdavis drhodes sothim DrSyzygy saccade anee dang`r`us mfoemmel gniourf_gniourf_ jystic det zaarg_)
21:49:35 --- names: list (SubStack jrockway mrd kevinclark hariju_ jayrk djahandarie @ChanServ)
21:49:40 <kamatsu> my university tends to favor the "We teach you C in first year, first semester. After that it's sink or swim"
21:49:42 <monochrom> I feel sorry for these fine people who get hammered in other channels.
21:49:49 --- topic: '["msg an op if you can't talk", "find ops: /msg ChanServ access list #haskell", "Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]'
21:49:49 --- topic: set by mauke on [Mon Jan 18 11:11:51 2010]
21:49:49 --- names: list (clog jinjing aep Stefa1 tgdavies__ tgdavies_ tlm texodus emma nolrai_FG path[l] ablokzijl StoneToad__ headyadmin triplez amuck miclorb bdimcheff sShintah fhobia jones- Claviceps jsgf inimino Ferdirand zakwilson tmug lst``` lispy|web duairc potatishandlarn portnov joed novas0x2a Hugglesworth regalia alvarezp ps-auxw execve Zeiris dolio araujo SamB_XP otto_s erikc` kfish kqrx edwinb_ Torrieri nettok gnuvince fbru02 weihsiu kmc applicative tommd)
21:49:49 --- names: list (blueonyx_ voidprayer joem86 roconnor lsthemes kamatsu Cale dnm_ hiptobecubic Reisen m0nkfish Raynes abbe the_andy glith holmak saccade_ SANDERS_ balboa02 mietek TacticalGrace medfly drbean copumpkin Niccus Rotaerk augur dfrey amiri Trafalgard MrDomino Nereid trin_cz tomoj horms NNshag M| _gaffer Alpounet sioraioc_ go|dfish DarthShrine cads solidsnack Philonous voker57_ tgdavies sigh endojelly jao dr_maligno imperialenforcer ulfdoz ystael)
21:49:49 --- names: list (Uawdal baaba_ elspru cygnus_ Dessous Sagi ddarius IceDane hgolden arnihermann kar-1 niksnut gwern fredcy TR2N sjanssen J-Mad @monochrom kniu boyscared s76_ Liskni_si nick8325 ttvd lpsmith dobie_gillis prb lament rfh jlaire gjl_ jmcarthur temoto NEEDMOAR Dashkal Cthulhon Cobra^^ luite psault jims wto zhijie dMazz whoppix njbartlett ski lenbust_ mrothe C-S ray bd_ srcerer sebbe1991 wolverian pastorn Taggnostr eagletmt mmmdonuts jql Exteris_)
21:49:49 --- names: list (MacCoaster_ ezrakilty kosmikus jontore tarbo EvanCarroll _Jordan_ poucet tilman gdsx Veinor otulp skaar_ axiom dons ath mdordal2 clarkb ennen sieni davidL flux dixie_ kolmodin flori_ FullMetalHarlot Bleadof glitch rntz icee_ Tomas_ bolmar_ koninkje1away netcat_ deavidsedice brx mokus_ tkr mchase gju cactii Beelsebob yottis Kyrus c9s__ ToRA matthew-_ prigaux Ke osfameron shepheb kwinz Khisanth Feuerbach opqdonut dejones Davse_Bamse saurik)
21:49:49 --- names: list (electrogeek nothingmuch dumael Apocalisp fihi09 michael| anekos noj zsol kynky Raevel merehap helgikrs jre2 reltuk dejai emias snhmib o-_-o dcolish ezeike oeblink Mortomes levitation_ mjrosenb vy Saizan cathper jtootf__ cods npouillard Berengal scree MoALTz quicksilver cjay jlouis equanimity Botje Eelis xerox Gowilla Aisling_ hackagebot ksf JaffaCake Astro Mr_Awesome eldragon absentia cgibreak Igloo tensorpudding shrughes gbeshers Colours)
21:49:49 --- names: list (tomberek Polarina qz untwisted gds jorizma mfp wang kadoban willb fnordus thetallguy1 thetallguy timlarson mikezackles @shapr jvogel sshc EvanR-work stephen_mcd zachk mikste Boney DekuNut TML thingwath _stenobot angerman jimmyjazz14 dropdrive nathanic_work ville The_third_man blackdog_ aluink Muad_Dibber guerrilla bburhans lostlogic inhortte khiroc Bassetts Blub\0 Peaker joevandyk mattam BMeph Gracenotes Axman6 Paradox924X suiside PsiOmega)
21:49:49 --- names: list (SimonRC profmakx ziman Nafai magicman jayne wharrgarble aavogt nathanic calvins tltstc pikhq sohum ve kaol eek jfredett newsham gspr MadX` pettter galdor Milo- qm13_ blazzy_ trez uorygl_ StarFire_ joga epmf thorkilnaur dmwit BONUS quuxman mreggen anders^^ Twey clanehin _Jedai_ tamiko fabjan AndyP nwf sahazel anji joni6128 hiredman CalJohn dilinger_ etpace kalven karld dcoutts gbacon Valodim jtra juhp bbee arjanoosting dqd lambdabot hellige)
21:49:49 --- names: list (shachaf Vulpyne nornagon smg Sisu mm_freak dfeuer alios solrize olsner BrianHV eelco_ sgf idnar sproingie birkenfeld arw smiler jfoutz Spockz BONUS_ mornfall yahooooo integral nniro Deewiant ClaudiusMaximus tromp coyo zygoloid aiko nimred kloeri jix lars_t Shimei djinni syntaxglitch Baughn int-e alip DigitalKiwi nasloc__ dreixel phnglui caligula_ p_l htoothrot laz0r eno harlekin canvon Counter-Strike jan_ noddy __marius__ ahihi deadguys Lemmih)
21:49:49 --- names: list (ttmrichter bwr mahogny dogmaT ksandstr wagle +preflex Innominate_ Runar jonafan dufflebu1k saiam_ pen16 thoughtpolice ibid tafryn Laney gmux zax desu pragma_ orbitz andrewsw erk kw317 jedediah SmurfOR Raku^ geoaxis elly Twigathy Gilly impl stroan liesen sbok t koala_man shortcircuit keseldude aleator_ encryptio dino- agemo_ dax jml burp Cyneox Gabbie danderson leod rapacity peddie QtPlatypus wormwood mjv ahf jvoorhis zacharyp Stephan202 dionoea)
21:49:49 --- names: list (geir_ Tupis companion_cube mlh Zao jbauman taruti theclaw McManiaC OnionKnight_ AnMaster benmachine wdonnelly byorgey ido bran epokal cYmen bastian Loriel alexbobp daed_ shawn_ allbery_b webframp mercury^ FauxFaux And[y] Badger soeren felipe_ nlogax pcc1 ehamberg +lunabot Ornedan tab _br_ fritschy kakeman Jaak StoneToad_ shrimpx beza1e1 cheater Vq jdavis drhodes sothim DrSyzygy saccade anee dang`r`us mfoemmel gniourf_gniourf_ jystic det zaarg_)
21:49:49 --- names: list (SubStack jrockway mrd kevinclark hariju_ jayrk djahandarie @ChanServ)
21:50:04 <kamatsu> what is with this channel today?
21:50:09 <kamatsu> reddit attack?
21:50:21 --- topic: '["msg an op if you can't talk", "find ops: /msg ChanServ access list #haskell", "Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]'
21:50:21 --- topic: set by mauke on [Mon Jan 18 11:11:51 2010]
21:50:21 --- names: list (clog alexsuraci skeptomai|away jinjing aep tgdavies__ tgdavies_ texodus emma path[l] ablokzijl StoneToad__ headyadmin triplez amuck miclorb bdimcheff sShintah fhobia jones- Claviceps jsgf inimino Ferdirand zakwilson tmug lst``` lispy|web duairc potatishandlarn portnov joed novas0x2a Hugglesworth regalia alvarezp ps-auxw execve Zeiris dolio araujo SamB_XP otto_s erikc` kfish kqrx edwinb_ Torrieri nettok gnuvince fbru02 weihsiu kmc applicative)
21:50:21 --- names: list (tommd blueonyx_ voidprayer joem86 roconnor lsthemes kamatsu Cale dnm_ hiptobecubic Reisen m0nkfish Raynes abbe the_andy glith holmak saccade_ SANDERS_ balboa02 mietek TacticalGrace medfly drbean copumpkin Niccus Rotaerk augur dfrey amiri Trafalgard MrDomino Nereid trin_cz tomoj horms NNshag M| _gaffer Alpounet sioraioc_ go|dfish DarthShrine cads solidsnack Philonous voker57_ sigh endojelly jao dr_maligno imperialenforcer ulfdoz ystael Uawdal)
21:50:21 --- names: list (baaba_ elspru cygnus_ Dessous Sagi ddarius IceDane hgolden arnihermann kar-1 niksnut gwern fredcy TR2N sjanssen J-Mad @monochrom kniu boyscared s76_ Liskni_si nick8325 ttvd lpsmith dobie_gillis prb lament rfh jlaire gjl_ jmcarthur temoto NEEDMOAR Dashkal Cthulhon Cobra^^ luite psault jims wto zhijie dMazz whoppix njbartlett ski lenbust_ mrothe C-S ray bd_ srcerer sebbe1991 wolverian pastorn Taggnostr eagletmt mmmdonuts jql Exteris_ MacCoaster_)
21:50:21 --- names: list (ezrakilty kosmikus jontore tarbo EvanCarroll _Jordan_ poucet tilman gdsx Veinor otulp skaar_ axiom dons ath mdordal2 clarkb ennen sieni davidL flux dixie_ kolmodin flori_ FullMetalHarlot Bleadof glitch rntz icee_ Tomas_ bolmar_ koninkje1away netcat_ deavidsedice brx mokus_ tkr mchase gju cactii Beelsebob yottis Kyrus c9s__ ToRA matthew-_ prigaux Ke osfameron shepheb kwinz Khisanth Feuerbach opqdonut dejones Davse_Bamse saurik electrogeek)
21:50:21 --- names: list (nothingmuch dumael Apocalisp fihi09 michael| anekos noj zsol kynky Raevel merehap helgikrs jre2 reltuk dejai emias snhmib o-_-o dcolish ezeike oeblink Mortomes levitation_ mjrosenb vy Saizan cathper jtootf__ cods npouillard Berengal scree MoALTz quicksilver cjay jlouis equanimity Botje Eelis xerox Gowilla Aisling_ hackagebot ksf JaffaCake Astro Mr_Awesome eldragon absentia cgibreak Igloo tensorpudding shrughes gbeshers Colours tomberek Polarina)
21:50:21 --- names: list (qz untwisted gds jorizma mfp wang kadoban willb fnordus thetallguy1 thetallguy timlarson mikezackles @shapr jvogel sshc EvanR-work stephen_mcd zachk mikste Boney DekuNut TML thingwath _stenobot angerman jimmyjazz14 dropdrive nathanic_work ville The_third_man blackdog_ aluink Muad_Dibber guerrilla bburhans lostlogic inhortte khiroc Bassetts Blub\0 Peaker joevandyk mattam BMeph Gracenotes Axman6 Paradox924X suiside PsiOmega SimonRC profmakx)
21:50:21 --- names: list (ziman Nafai magicman jayne wharrgarble aavogt nathanic calvins tltstc pikhq sohum ve kaol eek jfredett newsham gspr MadX` pettter galdor Milo- qm13_ blazzy_ trez uorygl_ StarFire_ joga epmf thorkilnaur dmwit BONUS quuxman mreggen anders^^ Twey clanehin _Jedai_ tamiko fabjan AndyP nwf sahazel anji joni6128 hiredman CalJohn dilinger_ etpace kalven karld dcoutts gbacon Valodim jtra juhp bbee arjanoosting dqd lambdabot hellige shachaf Vulpyne)
21:50:21 --- names: list (nornagon smg Sisu mm_freak dfeuer alios solrize olsner BrianHV eelco_ sgf idnar sproingie birkenfeld arw smiler jfoutz Spockz BONUS_ mornfall yahooooo integral nniro Deewiant ClaudiusMaximus tromp coyo zygoloid aiko nimred kloeri jix lars_t Shimei djinni syntaxglitch Baughn int-e alip DigitalKiwi nasloc__ dreixel phnglui caligula_ p_l htoothrot laz0r eno harlekin canvon Counter-Strike jan_ noddy __marius__ ahihi deadguys Lemmih ttmrichter)
21:50:21 --- names: list (bwr mahogny dogmaT ksandstr wagle +preflex Innominate_ Runar jonafan dufflebu1k saiam_ pen16 thoughtpolice ibid tafryn Laney gmux zax desu pragma_ orbitz andrewsw erk kw317 jedediah SmurfOR Raku^ geoaxis elly Twigathy Gilly impl stroan liesen sbok t koala_man shortcircuit keseldude aleator_ encryptio dino- agemo_ dax jml burp Cyneox Gabbie danderson leod rapacity peddie QtPlatypus wormwood mjv ahf jvoorhis zacharyp Stephan202 dionoea geir_)
21:50:21 --- names: list (Tupis companion_cube mlh Zao jbauman taruti theclaw McManiaC OnionKnight_ AnMaster benmachine wdonnelly byorgey ido bran epokal cYmen bastian Loriel alexbobp daed_ shawn_ allbery_b webframp mercury^ FauxFaux And[y] Badger soeren felipe_ nlogax pcc1 ehamberg +lunabot Ornedan tab _br_ fritschy kakeman Jaak StoneToad_ shrimpx beza1e1 cheater Vq jdavis drhodes sothim DrSyzygy saccade anee dang`r`us mfoemmel gniourf_gniourf_ jystic det zaarg_)
21:50:21 --- names: list (SubStack jrockway mrd kevinclark hariju_ jayrk djahandarie @ChanServ)
21:50:28 <kamatsu> monochrom: what is this then?
21:50:34 <monochrom> You got the CTCP flood earlier, right?
21:50:43 --- topic: '["msg an op if you can't talk", "find ops: /msg ChanServ access list #haskell", "Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]'
21:50:43 --- topic: set by mauke on [Mon Jan 18 11:11:51 2010]
21:50:43 --- names: list (clog QinGW alexsuraci nolrai_FG jinjing aep tgdavies__ tgdavies_ texodus emma path[l] ablokzijl StoneToad__ headyadmin triplez amuck bdimcheff sShintah fhobia jones- Claviceps jsgf inimino Ferdirand zakwilson tmug lst``` lispy|web duairc potatishandlarn portnov joed novas0x2a Hugglesworth regalia alvarezp ps-auxw execve Zeiris dolio araujo SamB_XP otto_s erikc` kfish kqrx edwinb_ Torrieri nettok gnuvince fbru02 weihsiu kmc applicative tommd)
21:50:43 --- names: list (blueonyx_ voidprayer joem86 roconnor lsthemes kamatsu Cale dnm_ hiptobecubic Reisen m0nkfish Raynes abbe the_andy glith holmak saccade_ SANDERS_ balboa02 mietek TacticalGrace medfly drbean copumpkin Niccus Rotaerk augur dfrey amiri Trafalgard MrDomino Nereid trin_cz tomoj horms NNshag M| _gaffer Alpounet sioraioc_ go|dfish DarthShrine cads solidsnack Philonous voker57_ sigh endojelly jao dr_maligno imperialenforcer ulfdoz ystael Uawdal baaba_)
21:50:43 --- names: list (elspru cygnus_ Dessous Sagi ddarius IceDane hgolden arnihermann kar-1 niksnut gwern fredcy TR2N sjanssen J-Mad @monochrom kniu boyscared s76_ Liskni_si nick8325 ttvd lpsmith dobie_gillis prb lament rfh jlaire gjl_ jmcarthur temoto NEEDMOAR Dashkal Cthulhon Cobra^^ luite psault jims wto zhijie dMazz whoppix njbartlett ski lenbust_ mrothe C-S ray bd_ srcerer sebbe1991 wolverian pastorn Taggnostr eagletmt mmmdonuts jql Exteris_ MacCoaster_ ezrakilty)
21:50:43 --- names: list (kosmikus jontore tarbo EvanCarroll _Jordan_ poucet tilman gdsx Veinor otulp skaar_ axiom dons ath mdordal2 clarkb ennen sieni davidL flux dixie_ kolmodin flori_ FullMetalHarlot Bleadof glitch rntz icee_ Tomas_ bolmar_ koninkje1away netcat_ deavidsedice brx mokus_ tkr mchase gju cactii Beelsebob yottis Kyrus c9s__ ToRA matthew-_ prigaux Ke osfameron shepheb kwinz Khisanth Feuerbach opqdonut dejones Davse_Bamse saurik electrogeek nothingmuch)
21:50:43 --- names: list (dumael Apocalisp fihi09 michael| anekos noj zsol kynky Raevel merehap helgikrs jre2 reltuk dejai emias snhmib o-_-o dcolish ezeike oeblink Mortomes levitation_ mjrosenb vy Saizan cathper jtootf__ cods npouillard Berengal scree MoALTz quicksilver cjay jlouis equanimity Botje Eelis xerox Gowilla Aisling_ hackagebot ksf JaffaCake Astro Mr_Awesome eldragon absentia cgibreak Igloo tensorpudding shrughes gbeshers Colours tomberek Polarina qz untwisted)
21:50:43 --- names: list (gds jorizma mfp wang kadoban willb fnordus thetallguy1 thetallguy timlarson mikezackles @shapr jvogel sshc EvanR-work stephen_mcd zachk mikste Boney DekuNut TML thingwath _stenobot angerman jimmyjazz14 dropdrive nathanic_work ville The_third_man blackdog_ aluink Muad_Dibber guerrilla bburhans lostlogic inhortte khiroc Bassetts Blub\0 Peaker joevandyk mattam BMeph Gracenotes Axman6 Paradox924X suiside PsiOmega SimonRC profmakx ziman Nafai)
21:50:43 --- names: list (magicman jayne wharrgarble aavogt nathanic calvins tltstc pikhq sohum ve kaol eek jfredett newsham gspr MadX` pettter galdor Milo- qm13_ blazzy_ trez uorygl_ StarFire_ joga epmf thorkilnaur dmwit BONUS quuxman mreggen anders^^ Twey clanehin _Jedai_ tamiko fabjan AndyP nwf sahazel anji joni6128 hiredman CalJohn dilinger_ etpace kalven karld dcoutts gbacon Valodim jtra juhp bbee arjanoosting dqd lambdabot hellige shachaf Vulpyne nornagon smg)
21:50:43 --- names: list (Sisu mm_freak dfeuer alios solrize olsner BrianHV eelco_ sgf idnar sproingie birkenfeld arw smiler jfoutz Spockz BONUS_ mornfall yahooooo integral nniro Deewiant ClaudiusMaximus tromp coyo zygoloid aiko nimred kloeri jix lars_t Shimei djinni syntaxglitch Baughn int-e alip DigitalKiwi nasloc__ dreixel phnglui caligula_ p_l htoothrot laz0r eno harlekin canvon Counter-Strike jan_ noddy __marius__ ahihi deadguys Lemmih ttmrichter bwr mahogny)
21:50:43 --- names: list (dogmaT ksandstr wagle +preflex Innominate_ Runar jonafan dufflebu1k saiam_ pen16 thoughtpolice ibid tafryn Laney gmux zax desu pragma_ orbitz andrewsw erk kw317 jedediah SmurfOR Raku^ geoaxis elly Twigathy Gilly impl stroan liesen sbok t koala_man shortcircuit keseldude aleator_ encryptio dino- agemo_ dax jml burp Cyneox Gabbie danderson leod rapacity peddie QtPlatypus wormwood mjv ahf jvoorhis zacharyp Stephan202 dionoea geir_ Tupis companion_cube)
21:50:43 --- names: list (mlh Zao jbauman taruti theclaw McManiaC OnionKnight_ AnMaster benmachine wdonnelly byorgey ido bran epokal cYmen bastian Loriel alexbobp daed_ shawn_ allbery_b webframp mercury^ FauxFaux And[y] Badger soeren felipe_ nlogax pcc1 ehamberg +lunabot Ornedan tab _br_ fritschy kakeman Jaak StoneToad_ shrimpx beza1e1 cheater Vq jdavis drhodes sothim DrSyzygy saccade anee dang`r`us mfoemmel gniourf_gniourf_ jystic det zaarg_ SubStack jrockway mrd)
21:50:43 --- names: list (kevinclark hariju_ jayrk djahandarie @ChanServ)
21:50:47 <erikc`> i like to ask ppl to write strcpy as an interview question
21:51:39 <pikhq> erikc`: Do people manage to fail it?
21:51:45 <monochrom> I put this channel to +R mode. That cures CTCP floods to this channel. But people could still be in many other channels, they get flooded, nothing I can do.
21:51:56 <clarkb> monochrom++
21:51:59 <erikc`> a loop-based array-version, a loop-based pointer one, a pointer-based recursive one, tail recursive, and then turn tail recursive back into a loop
21:52:06 <erikc`> pikhq: yes, a lot
21:52:19 --- topic: '["msg an op if you can't talk", "find ops: /msg ChanServ access list #haskell", "Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]'
21:52:19 --- topic: set by mauke on [Mon Jan 18 11:11:51 2010]
21:52:19 --- names: list (clog skeptomai|away Stefa1 nolrai_FG jinjing aep tgdavies__ tgdavies_ texodus emma path[l] ablokzijl StoneToad__ headyadmin triplez amuck bdimcheff sShintah fhobia jones- Claviceps jsgf inimino Ferdirand zakwilson tmug lst``` lispy|web duairc potatishandlarn portnov joed novas0x2a Hugglesworth regalia alvarezp ps-auxw execve Zeiris dolio araujo SamB_XP otto_s erikc` kfish kqrx edwinb_ Torrieri nettok gnuvince fbru02 weihsiu kmc applicative)
21:52:19 --- names: list (tommd blueonyx_ voidprayer joem86 roconnor lsthemes kamatsu Cale dnm_ hiptobecubic Reisen m0nkfish Raynes abbe the_andy glith holmak saccade_ SANDERS_ balboa02 mietek TacticalGrace medfly drbean copumpkin Niccus Rotaerk augur dfrey amiri Trafalgard MrDomino Nereid trin_cz tomoj horms NNshag M| _gaffer Alpounet sioraioc_ go|dfish DarthShrine cads solidsnack Philonous voker57_ sigh endojelly jao dr_maligno imperialenforcer ulfdoz ystael Uawdal)
21:52:19 --- names: list (baaba_ elspru cygnus_ Dessous Sagi ddarius IceDane hgolden arnihermann kar-1 niksnut gwern fredcy TR2N sjanssen J-Mad @monochrom kniu boyscared s76_ Liskni_si nick8325 ttvd lpsmith dobie_gillis prb lament rfh jlaire gjl_ jmcarthur temoto NEEDMOAR Dashkal Cthulhon Cobra^^ luite psault jims wto zhijie dMazz whoppix njbartlett ski lenbust_ mrothe C-S ray bd_ srcerer sebbe1991 wolverian pastorn Taggnostr eagletmt mmmdonuts jql Exteris_ MacCoaster_)
21:52:19 --- names: list (ezrakilty kosmikus jontore tarbo EvanCarroll _Jordan_ poucet tilman gdsx Veinor otulp skaar_ axiom dons ath mdordal2 clarkb ennen sieni davidL flux dixie_ kolmodin flori_ FullMetalHarlot Bleadof glitch rntz icee_ Tomas_ bolmar_ koninkje1away netcat_ deavidsedice brx mokus_ tkr mchase gju cactii Beelsebob yottis Kyrus c9s__ ToRA matthew-_ prigaux Ke osfameron shepheb kwinz Khisanth Feuerbach opqdonut dejones Davse_Bamse saurik electrogeek)
21:52:19 --- names: list (nothingmuch dumael Apocalisp fihi09 michael| anekos noj zsol kynky Raevel merehap helgikrs jre2 reltuk dejai emias snhmib o-_-o dcolish ezeike oeblink Mortomes levitation_ mjrosenb vy Saizan cathper jtootf__ cods npouillard Berengal scree MoALTz quicksilver cjay jlouis equanimity Botje Eelis xerox Gowilla Aisling_ hackagebot ksf JaffaCake Astro Mr_Awesome eldragon absentia cgibreak Igloo tensorpudding shrughes gbeshers Colours tomberek Polarina)
21:52:19 --- names: list (qz untwisted gds jorizma mfp wang kadoban willb fnordus thetallguy1 thetallguy timlarson mikezackles @shapr jvogel sshc EvanR-work stephen_mcd zachk mikste Boney DekuNut TML thingwath _stenobot angerman jimmyjazz14 dropdrive nathanic_work ville The_third_man blackdog_ aluink Muad_Dibber guerrilla bburhans lostlogic inhortte khiroc Bassetts Blub\0 Peaker joevandyk mattam BMeph Gracenotes Axman6 Paradox924X suiside PsiOmega SimonRC profmakx)
21:52:19 --- names: list (ziman Nafai magicman jayne wharrgarble aavogt nathanic calvins tltstc pikhq sohum ve kaol eek jfredett newsham gspr MadX` pettter galdor Milo- qm13_ blazzy_ trez uorygl_ StarFire_ joga epmf thorkilnaur dmwit BONUS quuxman mreggen anders^^ Twey clanehin _Jedai_ tamiko fabjan AndyP nwf sahazel anji joni6128 hiredman CalJohn dilinger_ etpace kalven karld dcoutts gbacon Valodim jtra juhp bbee arjanoosting dqd lambdabot hellige shachaf Vulpyne)
21:52:19 --- names: list (nornagon smg Sisu mm_freak dfeuer alios solrize olsner BrianHV eelco_ sgf idnar sproingie birkenfeld arw smiler jfoutz Spockz BONUS_ mornfall yahooooo integral nniro Deewiant ClaudiusMaximus tromp coyo zygoloid aiko nimred kloeri jix lars_t Shimei djinni syntaxglitch Baughn int-e alip DigitalKiwi nasloc__ dreixel phnglui caligula_ p_l htoothrot laz0r eno harlekin canvon Counter-Strike jan_ noddy __marius__ ahihi deadguys Lemmih ttmrichter)
21:52:19 --- names: list (bwr mahogny dogmaT ksandstr wagle +preflex Innominate_ Runar jonafan dufflebu1k saiam_ pen16 thoughtpolice ibid tafryn Laney gmux zax desu pragma_ orbitz andrewsw erk kw317 jedediah SmurfOR Raku^ geoaxis elly Twigathy Gilly impl stroan liesen sbok t koala_man shortcircuit keseldude aleator_ encryptio dino- agemo_ dax jml burp Cyneox Gabbie danderson leod rapacity peddie QtPlatypus wormwood mjv ahf jvoorhis zacharyp Stephan202 dionoea geir_)
21:52:19 --- names: list (Tupis companion_cube mlh Zao jbauman taruti theclaw McManiaC OnionKnight_ AnMaster benmachine wdonnelly byorgey ido bran epokal cYmen bastian Loriel alexbobp daed_ shawn_ allbery_b webframp mercury^ FauxFaux And[y] Badger soeren felipe_ nlogax pcc1 ehamberg +lunabot Ornedan tab _br_ fritschy kakeman Jaak shrimpx beza1e1 cheater Vq jdavis drhodes sothim DrSyzygy saccade anee dang`r`us mfoemmel gniourf_gniourf_ jystic det zaarg_ SubStack jrockway)
21:52:19 --- names: list (mrd kevinclark hariju_ jayrk djahandarie @ChanServ)
21:52:27 <lament> while (*q++ = *p++)?
21:52:30 <pikhq> void strcpy(char *x, char *y){while(*x++=*y++);}
21:52:31 <erikc`> a lot do 2 passes with strlen too
21:52:40 --- topic: '["msg an op if you can't talk", "find ops: /msg ChanServ access list #haskell", "Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]'
21:52:40 --- topic: set by mauke on [Mon Jan 18 11:11:51 2010]
21:52:40 --- names: list (clog Stefa1 nolrai_FG jinjing aep tgdavies__ tgdavies_ texodus emma path[l] ablokzijl StoneToad__ headyadmin triplez amuck bdimcheff sShintah fhobia jones- Claviceps jsgf inimino Ferdirand zakwilson tmug lst``` lispy|web duairc potatishandlarn portnov joed novas0x2a Hugglesworth regalia alvarezp ps-auxw execve Zeiris dolio araujo SamB_XP otto_s erikc` kfish kqrx edwinb_ Torrieri nettok gnuvince fbru02 weihsiu kmc applicative tommd blueonyx_)
21:52:40 --- names: list (voidprayer joem86 roconnor lsthemes kamatsu Cale dnm_ hiptobecubic Reisen m0nkfish Raynes abbe the_andy glith holmak saccade_ SANDERS_ balboa02 mietek TacticalGrace medfly drbean copumpkin Niccus Rotaerk augur dfrey amiri Trafalgard MrDomino Nereid trin_cz tomoj horms NNshag M| _gaffer Alpounet sioraioc_ go|dfish DarthShrine cads solidsnack Philonous voker57_ sigh endojelly jao dr_maligno imperialenforcer ulfdoz ystael Uawdal baaba_ elspru)
21:52:40 --- names: list (cygnus_ Dessous Sagi ddarius IceDane hgolden arnihermann kar-1 niksnut gwern fredcy TR2N sjanssen J-Mad @monochrom kniu boyscared s76_ Liskni_si nick8325 ttvd lpsmith dobie_gillis prb lament rfh jlaire gjl_ jmcarthur temoto NEEDMOAR Dashkal Cthulhon Cobra^^ luite psault jims wto zhijie dMazz whoppix njbartlett ski lenbust_ mrothe C-S ray bd_ srcerer sebbe1991 wolverian pastorn Taggnostr eagletmt mmmdonuts jql Exteris_ MacCoaster_ ezrakilty)
21:52:40 --- names: list (kosmikus jontore tarbo EvanCarroll _Jordan_ poucet tilman gdsx Veinor otulp skaar_ axiom dons ath mdordal2 clarkb ennen sieni davidL flux dixie_ kolmodin flori_ FullMetalHarlot Bleadof glitch rntz icee_ Tomas_ bolmar_ koninkje1away netcat_ deavidsedice brx mokus_ tkr mchase gju cactii Beelsebob yottis Kyrus c9s__ ToRA matthew-_ prigaux Ke osfameron shepheb kwinz Khisanth Feuerbach opqdonut dejones Davse_Bamse saurik electrogeek nothingmuch)
21:52:40 --- names: list (dumael Apocalisp fihi09 michael| anekos noj zsol kynky Raevel merehap helgikrs jre2 reltuk dejai emias snhmib o-_-o dcolish ezeike oeblink Mortomes levitation_ mjrosenb vy Saizan cathper jtootf__ cods npouillard Berengal scree MoALTz quicksilver cjay jlouis equanimity Botje Eelis xerox Gowilla Aisling_ hackagebot ksf JaffaCake Astro Mr_Awesome eldragon absentia cgibreak Igloo tensorpudding shrughes gbeshers Colours tomberek Polarina qz untwisted)
21:52:40 --- names: list (gds jorizma mfp wang kadoban willb fnordus thetallguy1 thetallguy timlarson mikezackles @shapr jvogel sshc EvanR-work stephen_mcd zachk mikste Boney DekuNut TML thingwath _stenobot angerman jimmyjazz14 dropdrive nathanic_work ville The_third_man blackdog_ aluink Muad_Dibber guerrilla bburhans lostlogic inhortte khiroc Bassetts Blub\0 Peaker joevandyk mattam BMeph Gracenotes Axman6 Paradox924X suiside PsiOmega SimonRC profmakx ziman Nafai)
21:52:40 --- names: list (magicman jayne wharrgarble aavogt nathanic calvins tltstc pikhq sohum ve kaol eek jfredett newsham gspr MadX` pettter galdor Milo- qm13_ blazzy_ trez uorygl_ StarFire_ joga epmf thorkilnaur dmwit BONUS quuxman mreggen anders^^ Twey clanehin _Jedai_ tamiko fabjan AndyP nwf sahazel anji joni6128 hiredman CalJohn dilinger_ etpace kalven karld dcoutts gbacon Valodim jtra juhp bbee arjanoosting dqd lambdabot hellige shachaf Vulpyne nornagon smg)
21:52:40 --- names: list (Sisu mm_freak dfeuer alios solrize olsner BrianHV eelco_ sgf idnar sproingie birkenfeld arw smiler jfoutz Spockz BONUS_ mornfall yahooooo integral nniro Deewiant ClaudiusMaximus tromp coyo zygoloid aiko nimred kloeri jix lars_t Shimei djinni syntaxglitch Baughn int-e alip DigitalKiwi nasloc__ dreixel phnglui caligula_ p_l htoothrot laz0r eno harlekin canvon Counter-Strike jan_ noddy __marius__ ahihi deadguys Lemmih ttmrichter bwr mahogny)
21:52:40 --- names: list (dogmaT ksandstr wagle +preflex Innominate_ Runar jonafan dufflebu1k saiam_ pen16 thoughtpolice ibid tafryn Laney gmux zax desu pragma_ orbitz andrewsw erk kw317 jedediah SmurfOR Raku^ geoaxis elly Twigathy Gilly impl stroan liesen sbok t koala_man shortcircuit keseldude aleator_ encryptio dino- agemo_ dax jml burp Cyneox Gabbie danderson leod rapacity peddie QtPlatypus wormwood mjv ahf jvoorhis zacharyp Stephan202 dionoea geir_ Tupis companion_cube)
21:52:40 --- names: list (mlh Zao jbauman taruti theclaw McManiaC OnionKnight_ AnMaster benmachine wdonnelly byorgey ido bran epokal cYmen bastian Loriel alexbobp daed_ shawn_ allbery_b webframp mercury^ FauxFaux And[y] Badger soeren felipe_ nlogax pcc1 ehamberg +lunabot Ornedan tab _br_ fritschy kakeman Jaak shrimpx beza1e1 cheater Vq jdavis drhodes sothim DrSyzygy saccade anee dang`r`us mfoemmel gniourf_gniourf_ jystic det zaarg_ SubStack jrockway mrd kevinclark)
21:52:40 --- names: list (hariju_ jayrk djahandarie @ChanServ)
21:52:46 <monochrom> hahahaha 2 passes is unforgivable.
21:52:55 <pikhq> 2. Passes.
21:53:08 <erikc`> and yet we hired ppl that did 2 passes despite me saying no hire :P
21:53:20 <pikhq> Granted, since GCC is smart, it'll CSE that out.
21:53:22 <path[l]> 2 passes to copy? Why is that? Because of the length you mean?
21:53:36 <clarkb> path[l]: I cant think of any other reason
21:53:37 <erikc`> gotta know how many times you need to loop mang
21:53:58 --- topic: '["msg an op if you can't talk", "find ops: /msg ChanServ access list #haskell", "Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]'
21:53:58 --- topic: set by mauke on [Mon Jan 18 11:11:51 2010]
21:53:58 --- names: list (clog emma Stefa1 nolrai_FG jinjing aep tgdavies__ tgdavies_ texodus path[l] ablokzijl StoneToad__ headyadmin triplez amuck bdimcheff sShintah fhobia jones- Claviceps jsgf inimino Ferdirand zakwilson tmug lst``` lispy|web duairc potatishandlarn portnov joed novas0x2a Hugglesworth regalia alvarezp ps-auxw execve Zeiris dolio araujo SamB_XP otto_s erikc` kfish kqrx edwinb_ Torrieri nettok gnuvince fbru02 weihsiu kmc applicative tommd blueonyx_)
21:53:58 --- names: list (voidprayer joem86 roconnor lsthemes kamatsu Cale dnm_ hiptobecubic Reisen m0nkfish Raynes abbe the_andy glith holmak saccade_ SANDERS_ balboa02 mietek TacticalGrace medfly drbean copumpkin Niccus Rotaerk augur dfrey amiri Trafalgard MrDomino Nereid trin_cz tomoj horms NNshag M| _gaffer Alpounet sioraioc_ go|dfish DarthShrine cads solidsnack Philonous voker57_ sigh endojelly jao imperialenforcer ulfdoz ystael Uawdal baaba_ elspru cygnus_)
21:53:58 --- names: list (Dessous Sagi ddarius IceDane hgolden arnihermann kar-1 niksnut gwern fredcy TR2N sjanssen J-Mad @monochrom kniu boyscared s76_ Liskni_si nick8325 ttvd lpsmith dobie_gillis prb lament rfh jlaire gjl_ jmcarthur temoto NEEDMOAR Dashkal Cthulhon Cobra^^ luite psault jims wto zhijie dMazz whoppix njbartlett ski lenbust_ mrothe C-S ray bd_ srcerer sebbe1991 wolverian pastorn Taggnostr eagletmt mmmdonuts jql MacCoaster_ Exteris_ ezrakilty kosmikus)
21:53:58 --- names: list (jontore tarbo EvanCarroll _Jordan_ poucet tilman gdsx Veinor otulp axiom skaar_ dons mdordal2 clarkb ennen ath davidL sieni flux dixie_ kolmodin flori_ Bleadof FullMetalHarlot koninkje1away glitch netcat_ rntz icee_ deavidsedice brx mokus_ Tomas_ bolmar_ tkr mchase gju cactii Beelsebob FauxFaux And[y] Badger soeren felipe_ nlogax pcc1 ehamberg +lunabot Ornedan tab _br_ fritschy kakeman Jaak shrimpx beza1e1 cheater Vq jdavis drhodes sothim)
21:53:58 --- names: list (DrSyzygy saccade anee dang`r`us mfoemmel gniourf_gniourf_ jystic det zaarg_ SubStack @ChanServ djahandarie jayrk hariju_ kevinclark mrd jrockway mercury^ webframp allbery_b shawn_ daed_ alexbobp Loriel bastian cYmen epokal bran ido byorgey wdonnelly benmachine AnMaster OnionKnight_ McManiaC theclaw taruti jbauman Zao mlh companion_cube Tupis geir_ dionoea Stephan202 zacharyp jvoorhis ahf mjv wormwood QtPlatypus peddie rapacity leod danderson)
21:53:58 --- names: list (Gabbie Cyneox burp jml dax agemo_ dino- encryptio aleator_ keseldude shortcircuit koala_man t sbok liesen stroan impl Gilly Twigathy elly geoaxis Raku^ SmurfOR jedediah kw317 erk andrewsw orbitz pragma_ desu zax gmux Laney tafryn ibid thoughtpolice pen16 saiam_ dufflebu1k jonafan Runar Innominate_ +preflex wagle ksandstr dogmaT mahogny bwr ttmrichter deadguys ahihi __marius__ noddy jan_ Counter-Strike canvon harlekin eno laz0r htoothrot)
21:53:58 --- names: list (p_l caligula_ phnglui dreixel nasloc__ DigitalKiwi alip int-e Baughn syntaxglitch djinni Shimei lars_t jix kloeri nimred aiko zygoloid coyo tromp ClaudiusMaximus Deewiant nniro integral yahooooo mornfall BONUS_ Spockz jfoutz smiler arw birkenfeld sproingie idnar sgf eelco_ BrianHV olsner solrize alios dfeuer mm_freak Sisu smg nornagon Vulpyne shachaf hellige lambdabot dqd arjanoosting bbee juhp jtra Valodim gbacon dcoutts karld kalven etpace)
21:53:58 --- names: list (dilinger_ CalJohn hiredman joni6128 anji sahazel nwf AndyP fabjan tamiko _Jedai_ clanehin Twey anders^^ mreggen quuxman BONUS dmwit thorkilnaur joga StarFire_ uorygl_ trez blazzy_ qm13_ Milo- epmf galdor pettter MadX` gspr newsham eek jfredett kaol ve sohum pikhq tltstc calvins nathanic aavogt wharrgarble jayne magicman|sleep Nafai profmakx ziman SimonRC PsiOmega suiside Paradox924X Axman6 Gracenotes BMeph mattam joevandyk Peaker Blub\0)
21:53:58 --- names: list (Bassetts khiroc inhortte lostlogic bburhans guerrilla Muad_Dibber aluink blackdog_ The_third_man ville nathanic_work dropdrive jimmyjazz14 angerman _stenobot thingwath TML DekuNut Boney mikste zachk stephen_mcd EvanR-work sshc jvogel @shapr mikezackles timlarson thetallguy thetallguy1 fnordus willb kadoban wang mfp jorizma gds untwisted qz Polarina tomberek Colours gbeshers shrughes tensorpudding Igloo cgibreak absentia eldragon Mr_Awesome)
21:53:58 --- names: list (Astro JaffaCake ksf hackagebot Aisling_ Gowilla xerox Eelis Botje equanimity jlouis cjay quicksilver MoALTz scree Berengal npouillard cods jtootf__ cathper Saizan vy mjrosenb levitation_ Mortomes Lemmih oeblink ezeike dcolish o-_-o snhmib emias dejai reltuk jre2 helgikrs merehap Raevel kynky zsol noj anekos michael| fihi09 Apocalisp dumael nothingmuch electrogeek saurik Davse_Bamse dejones opqdonut Feuerbach Khisanth kwinz shepheb osfameron)
21:53:58 --- names: list (Ke prigaux matthew-_ ToRA c9s__ Kyrus yottis)
21:53:59 <lament> while(i < strlen(s)) ...
21:54:08 <monochrom> My theory: because they only know Java, the duplicate the right thing to do in Java: find length; loop for as many time as length.
21:54:17 --- topic: '["msg an op if you can't talk", "find ops: /msg ChanServ access list #haskell", "Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]'
21:54:17 --- topic: set by mauke on [Mon Jan 18 11:11:51 2010]
21:54:17 --- names: list (clog emma nolrai_FG jinjing aep tgdavies__ tgdavies_ texodus path[l] ablokzijl StoneToad__ headyadmin triplez amuck bdimcheff sShintah fhobia jones- Claviceps jsgf inimino Ferdirand zakwilson tmug lst``` lispy|web duairc potatishandlarn portnov joed novas0x2a Hugglesworth regalia alvarezp ps-auxw execve Zeiris dolio araujo SamB_XP otto_s erikc` kfish kqrx edwinb_ Torrieri nettok gnuvince fbru02 weihsiu kmc applicative tommd blueonyx_ voidprayer)
21:54:17 --- names: list (joem86 roconnor lsthemes kamatsu Cale dnm_ hiptobecubic Reisen m0nkfish Raynes abbe the_andy glith holmak saccade_ SANDERS_ balboa02 mietek TacticalGrace medfly drbean copumpkin Niccus Rotaerk augur dfrey amiri Trafalgard MrDomino Nereid trin_cz tomoj horms NNshag M| _gaffer Alpounet sioraioc_ go|dfish DarthShrine cads solidsnack Philonous voker57_ sigh endojelly jao imperialenforcer ulfdoz ystael Uawdal baaba_ elspru cygnus_ Dessous Sagi)
21:54:17 --- names: list (ddarius IceDane hgolden arnihermann kar-1 niksnut gwern fredcy TR2N sjanssen J-Mad @monochrom kniu boyscared s76_ Liskni_si nick8325 ttvd lpsmith dobie_gillis prb lament rfh jlaire gjl_ jmcarthur temoto NEEDMOAR Dashkal Cthulhon Cobra^^ luite psault jims wto zhijie dMazz whoppix njbartlett ski lenbust_ mrothe C-S ray bd_ srcerer sebbe1991 wolverian pastorn Taggnostr eagletmt mmmdonuts jql MacCoaster_ Exteris_ ezrakilty kosmikus jontore)
21:54:17 --- names: list (tarbo EvanCarroll _Jordan_ poucet tilman gdsx Veinor otulp axiom skaar_ dons mdordal2 clarkb ennen ath davidL sieni flux dixie_ kolmodin flori_ Bleadof FullMetalHarlot koninkje1away glitch netcat_ rntz icee_ deavidsedice brx mokus_ Tomas_ bolmar_ tkr mchase gju cactii Beelsebob FauxFaux And[y] Badger soeren felipe_ nlogax pcc1 ehamberg +lunabot Ornedan tab _br_ fritschy kakeman Jaak shrimpx beza1e1 cheater Vq jdavis drhodes sothim DrSyzygy)
21:54:17 --- names: list (saccade anee dang`r`us mfoemmel gniourf_gniourf_ jystic det zaarg_ SubStack @ChanServ djahandarie jayrk hariju_ kevinclark mrd jrockway mercury^ webframp allbery_b shawn_ daed_ alexbobp Loriel bastian cYmen epokal bran ido byorgey wdonnelly benmachine AnMaster OnionKnight_ McManiaC theclaw taruti jbauman Zao mlh companion_cube Tupis geir_ dionoea Stephan202 zacharyp jvoorhis ahf mjv wormwood QtPlatypus peddie rapacity leod danderson Gabbie)
21:54:17 --- names: list (Cyneox burp jml dax agemo_ dino- encryptio aleator_ keseldude shortcircuit koala_man t sbok liesen stroan impl Gilly Twigathy elly geoaxis Raku^ SmurfOR jedediah kw317 erk andrewsw orbitz pragma_ desu zax gmux Laney tafryn ibid thoughtpolice pen16 saiam_ dufflebu1k jonafan Runar Innominate_ +preflex wagle ksandstr dogmaT mahogny bwr ttmrichter deadguys ahihi __marius__ noddy jan_ Counter-Strike canvon harlekin eno laz0r htoothrot p_l caligula_)
21:54:17 --- names: list (phnglui dreixel nasloc__ DigitalKiwi alip int-e Baughn syntaxglitch djinni Shimei lars_t jix kloeri nimred aiko zygoloid coyo tromp ClaudiusMaximus Deewiant nniro integral yahooooo mornfall BONUS_ Spockz jfoutz smiler arw birkenfeld sproingie idnar sgf eelco_ BrianHV olsner solrize alios dfeuer mm_freak Sisu smg nornagon Vulpyne shachaf hellige lambdabot dqd arjanoosting bbee juhp jtra Valodim gbacon dcoutts karld kalven etpace dilinger_)
21:54:17 --- names: list (CalJohn hiredman joni6128 anji sahazel nwf AndyP fabjan tamiko _Jedai_ clanehin Twey anders^^ mreggen quuxman BONUS dmwit thorkilnaur joga StarFire_ uorygl_ trez blazzy_ qm13_ Milo- epmf galdor pettter MadX` gspr newsham eek jfredett kaol ve sohum pikhq tltstc calvins nathanic aavogt wharrgarble jayne magicman|sleep Nafai profmakx ziman SimonRC PsiOmega suiside Paradox924X Axman6 Gracenotes BMeph mattam joevandyk Peaker Blub\0 Bassetts)
21:54:17 --- names: list (khiroc inhortte lostlogic bburhans guerrilla Muad_Dibber aluink blackdog_ The_third_man ville nathanic_work dropdrive jimmyjazz14 angerman _stenobot thingwath TML DekuNut Boney mikste zachk stephen_mcd EvanR-work sshc jvogel @shapr mikezackles timlarson thetallguy thetallguy1 fnordus willb kadoban wang mfp jorizma gds untwisted qz Polarina tomberek Colours gbeshers shrughes tensorpudding Igloo cgibreak absentia eldragon Mr_Awesome Astro)
21:54:17 --- names: list (JaffaCake ksf hackagebot Aisling_ Gowilla xerox Eelis Botje equanimity jlouis cjay quicksilver MoALTz scree Berengal npouillard cods jtootf__ cathper Saizan vy mjrosenb levitation_ Mortomes Lemmih oeblink ezeike dcolish o-_-o snhmib emias dejai reltuk jre2 helgikrs merehap Raevel kynky zsol noj anekos michael| fihi09 Apocalisp dumael nothingmuch electrogeek saurik Davse_Bamse dejones opqdonut Feuerbach Khisanth kwinz shepheb osfameron Ke)
21:54:17 --- names: list (prigaux matthew-_ ToRA c9s__ Kyrus yottis)
21:54:28 <erikc`> nolrai_FG: i had one person put the strlen in the loop upper bound "for (int i = 0; i < strlen(s); ...)"
21:54:35 --- topic: '["msg an op if you can't talk", "find ops: /msg ChanServ access list #haskell", "Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]'
21:54:35 --- topic: set by mauke on [Mon Jan 18 11:11:51 2010]
21:54:35 --- names: list (clog Stefa1 skeptomai|away emma nolrai_FG jinjing tgdavies__ tgdavies_ texodus path[l] ablokzijl StoneToad__ headyadmin triplez amuck bdimcheff sShintah fhobia jones- Claviceps jsgf inimino Ferdirand zakwilson tmug lst``` lispy|web duairc potatishandlarn portnov joed novas0x2a Hugglesworth regalia alvarezp ps-auxw execve Zeiris dolio araujo SamB_XP otto_s erikc` kfish kqrx edwinb_ Torrieri nettok gnuvince fbru02 weihsiu kmc applicative)
21:54:35 --- names: list (tommd blueonyx_ voidprayer joem86 roconnor lsthemes kamatsu Cale dnm_ hiptobecubic Reisen m0nkfish Raynes abbe the_andy glith holmak saccade_ SANDERS_ balboa02 mietek TacticalGrace medfly drbean copumpkin Niccus Rotaerk augur dfrey amiri Trafalgard MrDomino Nereid trin_cz tomoj horms NNshag M| _gaffer Alpounet sioraioc_ go|dfish DarthShrine cads solidsnack Philonous voker57_ sigh endojelly jao imperialenforcer ulfdoz ystael Uawdal baaba_)
21:54:35 --- names: list (elspru cygnus_ Dessous Sagi ddarius IceDane hgolden arnihermann kar-1 niksnut gwern fredcy TR2N sjanssen J-Mad @monochrom kniu boyscared s76_ Liskni_si nick8325 ttvd lpsmith dobie_gillis prb lament rfh jlaire gjl_ jmcarthur temoto NEEDMOAR Dashkal Cthulhon Cobra^^ luite psault jims wto zhijie dMazz whoppix njbartlett ski lenbust_ mrothe C-S ray bd_ srcerer sebbe1991 wolverian pastorn Taggnostr eagletmt mmmdonuts jql MacCoaster_ Exteris_)
21:54:35 --- names: list (ezrakilty kosmikus jontore tarbo EvanCarroll _Jordan_ poucet tilman gdsx Veinor otulp axiom skaar_ dons mdordal2 clarkb ennen ath davidL sieni flux dixie_ kolmodin flori_ Bleadof FullMetalHarlot koninkje1away glitch netcat_ rntz icee_ deavidsedice brx mokus_ Tomas_ bolmar_ tkr mchase gju cactii Beelsebob FauxFaux And[y] Badger soeren felipe_ nlogax pcc1 ehamberg +lunabot Ornedan tab _br_ fritschy kakeman Jaak shrimpx beza1e1 cheater Vq)
21:54:35 --- names: list (jdavis drhodes sothim DrSyzygy saccade anee dang`r`us mfoemmel gniourf_gniourf_ jystic det zaarg_ SubStack @ChanServ djahandarie jayrk hariju_ kevinclark mrd jrockway mercury^ webframp allbery_b shawn_ daed_ alexbobp Loriel bastian cYmen epokal bran ido byorgey wdonnelly benmachine AnMaster OnionKnight_ McManiaC theclaw taruti jbauman Zao mlh companion_cube Tupis geir_ dionoea Stephan202 zacharyp jvoorhis ahf mjv wormwood QtPlatypus peddie)
21:54:35 --- names: list (rapacity leod danderson Gabbie Cyneox burp jml dax agemo_ dino- encryptio aleator_ keseldude shortcircuit koala_man t sbok liesen stroan impl Gilly Twigathy elly geoaxis Raku^ SmurfOR jedediah kw317 erk andrewsw orbitz pragma_ desu zax gmux Laney tafryn ibid thoughtpolice pen16 saiam_ dufflebu1k jonafan Runar Innominate_ +preflex wagle ksandstr dogmaT mahogny bwr ttmrichter deadguys ahihi __marius__ noddy jan_ Counter-Strike canvon harlekin)
21:54:35 --- names: list (eno laz0r htoothrot p_l caligula_ phnglui dreixel nasloc__ DigitalKiwi alip int-e Baughn syntaxglitch djinni Shimei lars_t jix kloeri nimred aiko zygoloid coyo tromp ClaudiusMaximus Deewiant nniro integral yahooooo mornfall BONUS_ Spockz jfoutz smiler arw birkenfeld sproingie idnar sgf eelco_ BrianHV olsner solrize alios dfeuer mm_freak Sisu smg nornagon Vulpyne shachaf hellige lambdabot dqd arjanoosting bbee juhp jtra Valodim gbacon dcoutts)
21:54:35 --- names: list (karld kalven etpace dilinger_ CalJohn hiredman joni6128 anji sahazel nwf AndyP fabjan tamiko _Jedai_ clanehin Twey anders^^ mreggen quuxman BONUS dmwit thorkilnaur joga StarFire_ uorygl_ trez blazzy_ qm13_ Milo- epmf galdor pettter MadX` gspr newsham eek jfredett kaol ve sohum pikhq tltstc calvins nathanic aavogt wharrgarble jayne magicman|sleep Nafai profmakx ziman SimonRC PsiOmega suiside Paradox924X Axman6 Gracenotes BMeph mattam joevandyk)
21:54:35 --- names: list (Peaker Blub\0 Bassetts khiroc inhortte lostlogic bburhans guerrilla Muad_Dibber aluink blackdog_ The_third_man ville nathanic_work dropdrive jimmyjazz14 angerman _stenobot thingwath TML DekuNut Boney mikste zachk stephen_mcd EvanR-work sshc jvogel @shapr mikezackles timlarson thetallguy thetallguy1 fnordus willb kadoban wang mfp jorizma gds untwisted qz Polarina tomberek Colours gbeshers shrughes tensorpudding Igloo cgibreak absentia eldragon)
21:54:35 --- names: list (Mr_Awesome Astro JaffaCake ksf hackagebot Aisling_ Gowilla xerox Eelis Botje equanimity jlouis cjay quicksilver MoALTz scree Berengal npouillard cods jtootf__ cathper Saizan vy mjrosenb levitation_ Mortomes Lemmih oeblink ezeike dcolish o-_-o snhmib emias dejai reltuk jre2 helgikrs merehap Raevel kynky zsol noj anekos michael| fihi09 Apocalisp dumael nothingmuch electrogeek saurik Davse_Bamse dejones opqdonut Feuerbach Khisanth kwinz shepheb)
21:54:35 --- names: list (osfameron Ke prigaux matthew-_ ToRA c9s__ Kyrus yottis)
21:54:42 <path[l]> whats pure attribute?
21:54:53 --- topic: '["msg an op if you can't talk", "find ops: /msg ChanServ access list #haskell", "Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]'
21:54:53 --- topic: set by mauke on [Mon Jan 18 11:11:51 2010]
21:54:53 --- names: list (clog impl emma nolrai_FG jinjing tgdavies__ tgdavies_ texodus path[l] ablokzijl StoneToad__ headyadmin triplez amuck bdimcheff sShintah fhobia jones- Claviceps jsgf inimino Ferdirand zakwilson tmug lst``` lispy|web duairc potatishandlarn portnov joed novas0x2a Hugglesworth regalia alvarezp ps-auxw execve Zeiris dolio araujo SamB_XP otto_s erikc` kfish kqrx edwinb_ Torrieri nettok gnuvince fbru02 weihsiu kmc applicative tommd blueonyx_ voidprayer)
21:54:53 --- names: list (joem86 roconnor lsthemes kamatsu Cale dnm_ hiptobecubic Reisen m0nkfish Raynes abbe the_andy glith holmak saccade_ SANDERS_ balboa02 mietek TacticalGrace medfly drbean copumpkin Niccus Rotaerk augur dfrey amiri Trafalgard MrDomino Nereid trin_cz tomoj horms NNshag M| _gaffer Alpounet sioraioc_ go|dfish DarthShrine cads solidsnack Philonous voker57_ sigh endojelly jao imperialenforcer ulfdoz ystael Uawdal baaba_ elspru cygnus_ Dessous Sagi)
21:54:53 --- names: list (ddarius IceDane hgolden arnihermann kar-1 niksnut gwern fredcy TR2N sjanssen J-Mad @monochrom kniu boyscared s76_ Liskni_si nick8325 ttvd lpsmith dobie_gillis prb lament rfh jlaire gjl_ jmcarthur temoto NEEDMOAR Dashkal Cthulhon Cobra^^ luite psault jims wto zhijie dMazz whoppix njbartlett ski lenbust_ mrothe C-S ray bd_ srcerer sebbe1991 wolverian pastorn Taggnostr eagletmt mmmdonuts jql MacCoaster_ Exteris_ ezrakilty kosmikus jontore)
21:54:53 --- names: list (tarbo EvanCarroll _Jordan_ poucet tilman gdsx Veinor otulp axiom skaar_ dons mdordal2 clarkb ennen ath davidL sieni flux dixie_ kolmodin flori_ Bleadof FullMetalHarlot koninkje1away glitch netcat_ rntz icee_ deavidsedice brx mokus_ Tomas_ bolmar_ tkr mchase gju cactii Beelsebob FauxFaux And[y] Badger soeren felipe_ nlogax pcc1 ehamberg +lunabot Ornedan tab _br_ fritschy kakeman Jaak shrimpx beza1e1 cheater Vq jdavis drhodes sothim DrSyzygy)
21:54:53 --- names: list (saccade anee dang`r`us mfoemmel gniourf_gniourf_ jystic det zaarg_ SubStack @ChanServ djahandarie jayrk hariju_ kevinclark mrd jrockway mercury^ webframp allbery_b shawn_ daed_ alexbobp Loriel bastian cYmen epokal bran ido byorgey wdonnelly benmachine AnMaster OnionKnight_ McManiaC theclaw taruti jbauman Zao mlh companion_cube Tupis geir_ dionoea Stephan202 zacharyp jvoorhis ahf mjv wormwood QtPlatypus peddie rapacity leod danderson Gabbie)
21:54:53 --- names: list (Cyneox burp jml dax agemo_ dino- encryptio aleator_ keseldude shortcircuit koala_man t sbok liesen stroan Gilly Twigathy elly geoaxis Raku^ SmurfOR jedediah kw317 erk andrewsw orbitz pragma_ desu zax gmux Laney tafryn ibid thoughtpolice pen16 saiam_ dufflebu1k jonafan Runar Innominate_ +preflex wagle ksandstr dogmaT mahogny bwr ttmrichter deadguys ahihi __marius__ noddy jan_ Counter-Strike canvon harlekin eno laz0r htoothrot p_l caligula_)
21:54:53 --- names: list (phnglui dreixel nasloc__ DigitalKiwi alip int-e Baughn syntaxglitch djinni Shimei lars_t jix kloeri nimred aiko zygoloid coyo tromp ClaudiusMaximus Deewiant nniro integral yahooooo mornfall BONUS_ Spockz jfoutz smiler arw birkenfeld sproingie idnar sgf eelco_ BrianHV olsner solrize alios dfeuer mm_freak Sisu smg nornagon Vulpyne shachaf hellige lambdabot dqd arjanoosting bbee juhp jtra Valodim gbacon dcoutts karld kalven etpace dilinger_)
21:54:53 --- names: list (CalJohn hiredman joni6128 anji sahazel nwf AndyP fabjan tamiko _Jedai_ clanehin Twey anders^^ mreggen quuxman BONUS dmwit thorkilnaur joga StarFire_ uorygl_ trez blazzy_ qm13_ Milo- epmf galdor pettter MadX` gspr newsham eek jfredett kaol ve sohum pikhq tltstc calvins nathanic aavogt wharrgarble jayne magicman|sleep Nafai profmakx ziman SimonRC PsiOmega suiside Paradox924X Axman6 Gracenotes BMeph mattam joevandyk Peaker Blub\0 Bassetts)
21:54:53 --- names: list (khiroc inhortte lostlogic bburhans guerrilla Muad_Dibber aluink blackdog_ The_third_man ville nathanic_work dropdrive jimmyjazz14 angerman _stenobot thingwath TML DekuNut Boney mikste zachk stephen_mcd EvanR-work sshc jvogel @shapr mikezackles timlarson thetallguy thetallguy1 fnordus willb kadoban wang mfp jorizma gds untwisted qz Polarina tomberek Colours gbeshers shrughes tensorpudding Igloo cgibreak absentia eldragon Mr_Awesome Astro)
21:54:53 --- names: list (JaffaCake ksf hackagebot Aisling_ Gowilla xerox Eelis Botje equanimity jlouis cjay quicksilver MoALTz scree Berengal npouillard cods jtootf__ cathper Saizan vy mjrosenb levitation_ Mortomes Lemmih oeblink ezeike dcolish o-_-o snhmib emias dejai reltuk jre2 helgikrs merehap Raevel kynky zsol noj anekos michael| fihi09 Apocalisp dumael nothingmuch electrogeek saurik Davse_Bamse dejones opqdonut Feuerbach Khisanth kwinz shepheb osfameron Ke)
21:54:53 --- names: list (prigaux matthew-_ ToRA c9s__ Kyrus yottis)
21:55:11 --- topic: '["msg an op if you can't talk", "find ops: /msg ChanServ access list #haskell", "Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]'
21:55:11 --- topic: set by mauke on [Mon Jan 18 11:11:51 2010]
21:55:11 --- names: list (clog skeptomai|away impl emma nolrai_FG jinjing tgdavies__ tgdavies_ texodus path[l] ablokzijl StoneToad__ headyadmin triplez amuck bdimcheff sShintah fhobia jones- Claviceps jsgf inimino Ferdirand zakwilson tmug lst``` lispy|web duairc potatishandlarn portnov joed novas0x2a Hugglesworth regalia alvarezp ps-auxw execve Zeiris dolio araujo SamB_XP otto_s erikc` kfish kqrx edwinb_ Torrieri nettok gnuvince fbru02 weihsiu kmc applicative tommd)
21:55:11 --- names: list (blueonyx_ voidprayer joem86 roconnor lsthemes kamatsu Cale dnm_ hiptobecubic Reisen m0nkfish Raynes abbe the_andy glith holmak saccade_ SANDERS_ balboa02 mietek TacticalGrace medfly drbean copumpkin Niccus Rotaerk augur dfrey amiri Trafalgard MrDomino Nereid trin_cz tomoj horms NNshag M| _gaffer Alpounet sioraioc_ go|dfish DarthShrine cads solidsnack Philonous voker57_ sigh endojelly jao imperialenforcer ulfdoz ystael Uawdal baaba_ elspru)
21:55:11 --- names: list (cygnus_ Dessous Sagi ddarius IceDane hgolden arnihermann kar-1 niksnut gwern fredcy TR2N sjanssen J-Mad @monochrom kniu boyscared s76_ Liskni_si nick8325 ttvd lpsmith dobie_gillis prb lament rfh jlaire gjl_ jmcarthur temoto NEEDMOAR Dashkal Cthulhon Cobra^^ luite psault jims wto zhijie dMazz whoppix njbartlett ski lenbust_ mrothe C-S ray bd_ srcerer sebbe1991 wolverian pastorn Taggnostr eagletmt mmmdonuts jql Exteris_ MacCoaster_ ezrakilty)
21:55:11 --- names: list (kosmikus jontore EvanCarroll tarbo _Jordan_ poucet tilman gdsx Veinor otulp skaar_ axiom dons ath mdordal2 clarkb ennen sieni davidL flux dixie_ flori_ kolmodin Bleadof FullMetalHarlot koninkje1away glitch netcat_ rntz deavidsedice Tomas_ bolmar_ icee_ brx mokus_ tkr mchase gju cactii Beelsebob yottis Kyrus c9s__ ToRA matthew-_ prigaux Ke osfameron shepheb kwinz Khisanth Feuerbach opqdonut dejones Davse_Bamse saurik electrogeek nothingmuch)
21:55:11 --- names: list (dumael Apocalisp fihi09 michael| anekos noj zsol kynky Raevel merehap helgikrs jre2 reltuk dejai emias snhmib o-_-o dcolish ezeike oeblink Mortomes levitation_ mjrosenb vy Saizan cathper jtootf__ cods npouillard Berengal scree MoALTz quicksilver cjay jlouis equanimity Botje Eelis xerox Gowilla Aisling_ hackagebot ksf JaffaCake Astro Mr_Awesome eldragon absentia cgibreak Igloo tensorpudding shrughes gbeshers Colours tomberek Polarina qz untwisted)
21:55:11 --- names: list (gds jorizma mfp wang kadoban willb fnordus thetallguy1 thetallguy timlarson mikezackles @shapr jvogel sshc EvanR-work stephen_mcd zachk mikste Boney DekuNut TML thingwath _stenobot angerman jimmyjazz14 dropdrive nathanic_work ville The_third_man blackdog_ aluink Muad_Dibber guerrilla bburhans lostlogic inhortte khiroc Bassetts Blub\0 Peaker joevandyk mattam BMeph Gracenotes Axman6 Paradox924X suiside PsiOmega SimonRC profmakx ziman @ChanServ)
21:55:11 --- names: list (djahandarie jayrk hariju_ kevinclark mrd jrockway SubStack zaarg_ det jystic gniourf_gniourf_ mfoemmel dang`r`us anee saccade DrSyzygy sothim drhodes jdavis Vq cheater beza1e1 shrimpx Jaak kakeman fritschy _br_ tab Ornedan +lunabot ehamberg pcc1 nlogax felipe_ soeren Badger And[y] FauxFaux mercury^ webframp allbery_b shawn_ daed_ alexbobp Loriel bastian cYmen epokal bran ido byorgey wdonnelly benmachine AnMaster OnionKnight_ McManiaC theclaw)
21:55:11 --- names: list (taruti jbauman Zao mlh companion_cube Tupis geir_ dionoea Stephan202 zacharyp jvoorhis ahf mjv wormwood QtPlatypus peddie rapacity leod danderson Gabbie Cyneox burp jml dax agemo_ dino- encryptio aleator_ keseldude shortcircuit koala_man t sbok liesen stroan Gilly Twigathy elly geoaxis Raku^ SmurfOR jedediah kw317 erk andrewsw orbitz pragma_ desu zax gmux Laney tafryn ibid thoughtpolice pen16 saiam_ dufflebu1k jonafan Runar Innominate_ +preflex)
21:55:11 --- names: list (wagle ksandstr dogmaT mahogny bwr ttmrichter deadguys ahihi __marius__ noddy jan_ Counter-Strike canvon harlekin eno laz0r htoothrot p_l caligula_ phnglui dreixel nasloc__ DigitalKiwi alip int-e Baughn syntaxglitch djinni Shimei lars_t jix kloeri nimred aiko zygoloid coyo tromp ClaudiusMaximus Deewiant nniro integral yahooooo mornfall BONUS_ Spockz jfoutz smiler arw birkenfeld sproingie idnar sgf eelco_ BrianHV olsner solrize alios dfeuer)
21:55:11 --- names: list (mm_freak Sisu smg nornagon Vulpyne shachaf hellige lambdabot dqd arjanoosting bbee juhp jtra Valodim gbacon dcoutts karld kalven etpace dilinger_ CalJohn hiredman joni6128 anji sahazel nwf AndyP fabjan tamiko _Jedai_ clanehin Twey anders^^ mreggen quuxman BONUS dmwit thorkilnaur joga StarFire_ epmf uorygl_ trez blazzy_ qm13_ Milo- galdor pettter MadX` gspr newsham jfredett eek kaol ve sohum pikhq tltstc calvins nathanic aavogt wharrgarble)
21:55:11 --- names: list (jayne magicman|sleep Nafai Lemmih)
21:55:20 <path[l]> oh ok
21:55:23 <pikhq> And can therefore be common subexpression eliminated.
21:55:35 --- topic: '["msg an op if you can't talk", "find ops: /msg ChanServ access list #haskell", "Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]'
21:55:35 --- topic: set by mauke on [Mon Jan 18 11:11:51 2010]
21:55:35 --- names: list (clog tmug QinGW skeptomai|away impl emma nolrai_FG jinjing tgdavies__ tgdavies_ texodus path[l] ablokzijl StoneToad__ headyadmin triplez amuck bdimcheff sShintah fhobia jones- Claviceps jsgf inimino Ferdirand zakwilson lst``` lispy|web duairc potatishandlarn portnov joed novas0x2a Hugglesworth regalia alvarezp ps-auxw execve Zeiris dolio araujo SamB_XP otto_s erikc` kfish kqrx edwinb_ Torrieri nettok gnuvince fbru02 weihsiu kmc applicative)
21:55:35 --- names: list (tommd blueonyx_ voidprayer joem86 roconnor lsthemes kamatsu Cale dnm_ hiptobecubic Reisen m0nkfish Raynes abbe the_andy glith holmak saccade_ SANDERS_ balboa02 mietek TacticalGrace medfly drbean copumpkin Niccus Rotaerk augur dfrey amiri Trafalgard MrDomino Nereid trin_cz tomoj horms NNshag M| _gaffer Alpounet sioraioc_ go|dfish DarthShrine cads solidsnack Philonous voker57_ sigh endojelly jao imperialenforcer ulfdoz ystael Uawdal baaba_)
21:55:35 --- names: list (elspru cygnus_ Dessous Sagi ddarius IceDane hgolden arnihermann kar-1 niksnut gwern fredcy TR2N sjanssen J-Mad @monochrom kniu boyscared s76_ Liskni_si nick8325 ttvd lpsmith dobie_gillis prb lament rfh jlaire gjl_ jmcarthur temoto NEEDMOAR Dashkal Cthulhon Cobra^^ luite psault jims wto zhijie dMazz whoppix njbartlett ski lenbust_ mrothe C-S ray bd_ srcerer sebbe1991 wolverian pastorn Taggnostr eagletmt mmmdonuts jql Exteris_ MacCoaster_)
21:55:35 --- names: list (ezrakilty kosmikus jontore EvanCarroll tarbo _Jordan_ poucet tilman gdsx Veinor otulp skaar_ axiom dons ath mdordal2 clarkb ennen sieni davidL flux dixie_ flori_ kolmodin Bleadof FullMetalHarlot koninkje1away glitch netcat_ rntz deavidsedice Tomas_ bolmar_ icee_ brx mokus_ tkr mchase gju cactii Beelsebob yottis Kyrus c9s__ ToRA matthew-_ prigaux Ke osfameron shepheb kwinz Khisanth Feuerbach opqdonut dejones Davse_Bamse saurik electrogeek)
21:55:35 --- names: list (nothingmuch dumael Apocalisp fihi09 michael| anekos noj zsol kynky Raevel merehap helgikrs jre2 reltuk dejai emias snhmib o-_-o dcolish ezeike oeblink Mortomes levitation_ mjrosenb vy Saizan cathper jtootf__ cods npouillard Berengal scree MoALTz quicksilver cjay jlouis equanimity Botje Eelis xerox Gowilla Aisling_ hackagebot ksf JaffaCake Astro Mr_Awesome eldragon absentia cgibreak Igloo tensorpudding shrughes gbeshers Colours tomberek Polarina)
21:55:35 --- names: list (qz untwisted gds jorizma mfp wang kadoban willb fnordus thetallguy1 thetallguy timlarson mikezackles @shapr jvogel sshc EvanR-work stephen_mcd zachk mikste Boney DekuNut TML thingwath _stenobot angerman jimmyjazz14 dropdrive nathanic_work ville The_third_man blackdog_ aluink Muad_Dibber guerrilla bburhans lostlogic inhortte khiroc Bassetts Blub\0 Peaker joevandyk mattam BMeph Gracenotes Axman6 Paradox924X suiside PsiOmega SimonRC profmakx)
21:55:35 --- names: list (ziman @ChanServ djahandarie jayrk hariju_ kevinclark mrd jrockway SubStack zaarg_ det jystic gniourf_gniourf_ mfoemmel dang`r`us anee saccade DrSyzygy sothim drhodes jdavis Vq cheater beza1e1 shrimpx Jaak kakeman fritschy _br_ tab Ornedan +lunabot ehamberg pcc1 nlogax felipe_ soeren Badger And[y] FauxFaux mercury^ webframp allbery_b shawn_ daed_ alexbobp Loriel bastian cYmen epokal bran ido byorgey wdonnelly benmachine AnMaster OnionKnight_)
21:55:35 --- names: list (McManiaC theclaw taruti jbauman Zao mlh companion_cube Tupis geir_ dionoea Stephan202 zacharyp jvoorhis ahf mjv wormwood QtPlatypus peddie rapacity leod danderson Gabbie Cyneox burp jml dax agemo_ dino- encryptio aleator_ keseldude shortcircuit koala_man t sbok liesen stroan Gilly Twigathy elly geoaxis Raku^ SmurfOR jedediah kw317 erk andrewsw orbitz pragma_ desu zax gmux Laney tafryn ibid thoughtpolice pen16 saiam_ dufflebu1k jonafan Runar)
21:55:35 --- names: list (Innominate_ +preflex wagle ksandstr dogmaT mahogny bwr ttmrichter deadguys ahihi __marius__ noddy jan_ Counter-Strike canvon harlekin eno laz0r htoothrot p_l caligula_ phnglui dreixel nasloc__ DigitalKiwi alip int-e Baughn syntaxglitch djinni Shimei lars_t jix kloeri nimred aiko zygoloid coyo tromp ClaudiusMaximus Deewiant nniro integral yahooooo mornfall BONUS_ Spockz jfoutz smiler arw birkenfeld sproingie idnar sgf eelco_ BrianHV olsner)
21:55:35 --- names: list (solrize alios dfeuer mm_freak Sisu smg nornagon Vulpyne shachaf hellige lambdabot dqd arjanoosting bbee juhp jtra Valodim gbacon dcoutts karld kalven etpace dilinger_ CalJohn hiredman joni6128 anji sahazel nwf AndyP fabjan tamiko _Jedai_ clanehin Twey anders^^ mreggen quuxman BONUS dmwit thorkilnaur joga StarFire_ epmf uorygl_ trez blazzy_ qm13_ Milo- galdor pettter MadX` gspr newsham jfredett eek kaol ve sohum pikhq tltstc calvins nathanic)
21:55:35 --- names: list (aavogt wharrgarble jayne magicman|sleep Nafai Lemmih)
21:55:43 <monochrom> So I don't know, it only proves they don't know C. Does your employer use C seriously enough to require knowing this?
21:55:51 <lament> but exponential would take some effort
21:56:08 <path[l]> Im not sure if it fails an interviewee though, since they would need to know that length is O(n) and not O(1)
21:56:08 <clarkb> lament: you could just include a few nested loops that do nothing
21:56:13 <pikhq> Basically, so long as it won't change in between calls without something being changed, it's "pure".
21:56:15 <path[l]> yeah as monochrom  said, they just dont know C
21:56:16 <kamatsu> clarkb: that'd get you to higher powers
21:56:21 <kamatsu> clarkb: but not exponential
21:56:23 <path[l]> it doesn't mean they dont know programming
21:56:42 <clarkb> ah yes
21:56:45 <kamatsu> fizzbuzz problem is good
21:56:45 <pikhq> path[l]: Means they're a pretty poor fit for a job using C, though.
21:56:47 <erikc`> monochrom: ex-employer, but yea, console game programming, so very soft real-time C/C++
21:56:53 <path[l]> true
21:57:06 <pikhq> C is not one of those things you "just pick up".
21:57:10 <nolrai_FG> I canz hav help with type families Plz? (or I will contiune to speak in lolcat)
21:57:16 <clarkb> pikhq: it isn't?
21:57:26 <clarkb> pick up K&R and done
21:57:28 <path[l]> why did a "tail recursive" option show up though? Do C compilers do something special for tail recursion
21:57:30 <QtPlatypus> nolrai_FG: Give us your question
21:57:37 <pikhq> clarkb: Well, not in the sense of "oh, I know Python, I can pick up Perl in a day or two".
21:57:39 <monochrom> OH! Then it is ... Well, let's just say, it is smart of you to quit that employer, it is going to be a shipwreck if they hire people who don't know such basic facts!
21:57:43 <nolrai_FG> Anyway, I am now using type families, how would I write the type that I used to write as "(Monad m, MoandState MyType m) => m OtherType"
21:57:45 <QtPlatypus> path[l]: Some can optimize tail recursion
21:57:48 <pikhq> clarkb: Takes at least a bit of work if you're not used to manual memory allocation and pointers.
21:57:56 <clarkb> thats true.
21:57:58 <path[l]> ah I see, I didnt know this
21:57:59 <erikc`> monochrom: yea, i couldnt take it anymore
21:57:59 <pikhq> path[l]: GCC does TCO just fine.
21:58:16 <pikhq> It's pretty simple to do, really.
21:58:31 <erikc`> path[l]: i ask the tail recursive stuff cause it's a real quick way to flush out whether someone gets basic recursion
21:58:33 <path[l]> yeah I just didnt realise it had been done
21:58:40 <pikhq> Replace "call foo;ret" with "jmp foo", et voila.
21:58:49 <monochrom> gcc -O2 does TCO since 15 years ago or something.
21:58:56 <path[l]> heh I see
21:59:30 <nolrai_FG> Basicly I need something like "(Monad m, MoandState m, StateType == MyType) => m OtherType"
22:00:09 <aavogt> you know the ~?
22:00:13 <monochrom> Granted, C is so tricky that there are cases where TCO is wrong. But gcc can identify a subclass of the safe cases. In practice most code is safe.
22:00:17 <path[l]> I remember reading about TCO, seeing the standard factorial example and then being stumped about how I'd do fibonacci for a while :/
22:00:31 <path[l]> monochrom: whoa really? Could you give me an example of such a case
22:00:36 <nolrai_FG> aavogot: was that to me?
22:00:39 <path[l]> I didnt think it was possible for it to be wrong
22:00:42 <aavogt> yes nolrai_FG
22:00:45 <monochrom> I can't. I forgot. It's tricky.
22:01:30 <lament> strlen "" = 0; strlen s = 1 + (maximum (map strlen (subsets s)))  where subsets s = filter (/= s) (subsequences s)
22:01:35 * lament bows
22:01:53 <erikc`> lol
22:02:04 <monochrom> interview question: turn that into C.
22:02:20 <path[l]> :t subsets
22:02:21 <lambdabot> Not in scope: `subsets'
22:02:26 <path[l]> oh bah
22:02:28 <path[l]> didnt read
22:02:31 <pikhq> monochrom: The *exact* semantics?
22:02:33 <path[l]> :t subsequences
22:02:34 <lambdabot> forall a. [a] -> [[a]]
22:02:42 <lament> > subsequences [1,2,3]
22:02:42 <pikhq> I'd not want to do that in an interview.
22:02:43 <lambdabot>   [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
22:02:56 <monochrom> I am not that mean.
22:03:01 <pikhq> monochrom: Though, that's because I'd be implementing lambda and thunks.
22:03:05 <path[l]> lol
22:03:09 <path[l]> thats pretty funny
22:03:11 <kamatsu> Honestly, Google eliminate tons of candidates just by asking
22:03:15 <pikhq> Well, more like "implementing those functions using them".
22:03:19 <kamatsu> "what's the difference between a process and a thread?"
22:03:28 <kamatsu> or "What's the complexity of adding up a list of numbers?"
22:03:46 * pikhq has been toying with them for a couple weeks now... Working on a SKI evaluator.
22:03:55 <monochrom> That really just tells us about the tons of candidates. :)
22:03:59 <kamatsu> apparently they had a guy apply who was reseearching for a PHD, and they asked him that complexity question
22:04:07 <path[l]> lol -> Have you ever wondered why every pornsite banner knows where you live, but no airline website is smart enough to do that?
22:04:11 <kamatsu> and he said he hadn't gotten that far in his research??
22:04:21 <lament> if we're so smart, how come we don't work at google??
22:04:29 <kamatsu> i do work at google
22:04:33 <lament> path[l]: because the porn site doesn't care if it's wrong 10% of the time
22:04:39 <path[l]> I wouldnt be able to answer the threads/process question precisely, only vaguely
22:04:41 <pikhq> kamatsu: That's pretty depressing.
22:04:48 <path[l]> lament: yeah I know, I just found it hilarious
22:04:56 <sohum> :t unsafePerformIO
22:04:57 <pikhq> path[l]: It's pretty easy to do it well.
22:04:58 <lambdabot> Not in scope: `unsafePerformIO'
22:05:00 <sohum> haha
22:05:07 <pikhq> "Processes do not have shared state. Threads do."
22:05:24 <pikhq> Bit rough, but indicates you grok the concept.
22:05:33 <path[l]> yeah or that copies of the stack or roughly more expensive/less expensive
22:05:33 <sohum> @src trace
22:05:33 <lambdabot> trace string expr = unsafePerformIO $ do
22:05:34 <lambdabot>     hPutStrLn stderr string
22:05:34 <lambdabot>     return expr
22:05:34 <Axman6> sounds like i could easily get a job at google :P
22:05:38 <path[l]> but not like exactly
22:05:39 <kamatsu> pikhq: yup, that was my answer when my coworker was shaking his head in disbelief
22:05:50 <sohum> that's what I was thinking, awesome
22:05:52 <pikhq> kamatsu: Man.
22:05:53 <kamatsu> Axman6: ah, well, it's not that easy, but they do filter out most of the applicants with simple questions.
22:06:05 <pikhq> How can people apply to Google not *knowing* such a simple question?
22:06:09 <kamatsu> yeah
22:06:13 <pikhq> I could've answered that when I was 12!
22:06:24 <pikhq> Granted, I was an unusual 12 year old, but still.
22:06:28 <monochrom> If you are looking for a date, you can filter out a ton of candidates by asking those questions too!
22:06:36 <kamatsu> hahaha!
22:06:50 <kamatsu> hm, my girlfriend can answer those questions
22:07:01 <kamatsu> maybe i've been subconsciously filtering this whole time
22:07:05 <monochrom> You're the luckiest man in the world.
22:07:15 <pikhq> monochrom: I'm at a school that's roughly 1/3rd female. I'd say filtering has already happened.
22:07:30 <pikhq> Just I didn't do the filtering.
22:07:37 <monochrom> I really eliminated all candidates, not just a ton.
22:07:37 <path[l]> 1/3rd female? doing programming?
22:07:41 <path[l]> that is unusual
22:07:54 <pikhq> path[l]: It's not just programming. It's an engineering school.
22:07:55 <kamatsu> at my school, there are more girls doing programming than 1/3rd
22:08:00 <pikhq> With a decent CS program and math program.
22:08:04 <kamatsu> but still a minority
22:08:13 <pikhq> There's like 10 girls in the CS program.
22:08:19 <path[l]> pikhq: ah but still
22:08:21 <path[l]> 10 out of ?
22:08:36 <pikhq> path[l]: Can't recall the number.
22:08:44 <path[l]> I mean like ballpark
22:08:52 <pikhq> Few hundred?
22:08:54 <path[l]> when I was in college my class had 2 girls out of 30ish
22:08:55 <pikhq> (small school)
22:08:56 <path[l]> ah ok
22:08:59 <path[l]> yea same ratio
22:09:10 <path[l]> but I was studying aerospace engineering, not cs
22:09:19 <kamatsu> ah, there are more girls in cs than there used to be
22:09:24 <monochrom> FWIW, GRE questions, CS part, are not all that harder than those 1st-tier interview questions, "what is the complexity of this well-known thing" etc.
22:09:26 <kamatsu> cs is certainly alot cooler than it used to be
22:09:55 <kamatsu> GRE questions?
22:10:05 <pikhq> kamatsu: Well, yeah. People actually *use* computers these days. :P
22:10:09 --- mode: ChanServ set +o monochrom
22:10:22 <nolrai_FG> GRE - test like the SAT for grad school.
22:10:31 <kamatsu> nolrai_FG: ah, I am australian
22:10:49 <kamatsu> hence my vacuous lack of knowledge of what GRE was
22:11:27 <kamatsu> pikhq: not only that, but there is more international support of the field. Before it was all white males.
22:11:32 <nolrai_FG> Good thing you know what the SAT is then.
22:11:44 <pikhq> kamatsu: Yeah...
22:12:13 <nolrai_FG> My CS proff is a half Sadie Araribian Woman, must look great for the school.
22:12:45 <kamatsu> er
22:12:48 <kamatsu> Saudi Arabian?
22:13:00 <pikhq> kamatsu: And yet, English is still the lingua franca.
22:13:15 <kamatsu> pikhq: historical reasons
22:13:24 <pikhq> Yeah...
22:13:38 <path[l]> well GRE is known in the US and all asian countries ;-)
22:13:56 <pikhq> Combined with programming being one of the few industries that the US still has that is notable...
22:14:04 <pikhq> (along with war and entertainment)
22:14:37 <kamatsu> pikhq: weapons manufacturing
22:14:49 <kamatsu> pikhq: although you don't *do* the actual manufacturing
22:14:56 <pikhq> kamatsu: "war".
22:14:59 <kamatsu> oh, right
22:15:17 <pikhq> It's the main thing driving the economy here, really.
22:15:27 <kamatsu> yeah
22:15:38 <kamatsu> here it's mineral exports to china
22:15:39 <pikhq> That and the banks shoving money around.
22:15:58 <pikhq> Wishing money into existence.
22:16:35 <kamatsu> with any luck that'll stop soon
22:17:34 <pikhq> Can't keep going on too much longer; they're almost shoving monopoly money around at this point.
22:18:39 <nolrai_FG> err <.< >.> yeah Saudi
22:19:52 <nolrai_FG> The problem is that having really complicated math that no one else understands is seen as a good thing, instead of near garantee that your (at least inadverdantly) perpetrating fraud.
22:20:16 <nolrai_FG>  s/your/you're
22:20:40 <aavogt> why should nobody else understand?
22:21:44 <kamatsu> nolrai_FG: speaking of really complicated math that no one else understands, this is the #haskell channel
22:21:53 <kamatsu> are you saying haskell is fraud?
22:22:14 <monochrom> haskell is a fraud. done. haha
22:22:28 <kamatsu> oh no, wait
22:22:31 <erikc`> heh, the complicated math certainly doesnt help haskell's case :)
22:22:37 <nolrai_FG> true
22:22:39 <kamatsu> haskell provides type-safe guarantees you're committing fraud
22:22:49 <erikc`> "so who is going to maintain these haskell programs if you leave" "..."
22:23:08 <monochrom> moar grad students
22:23:38 <nolrai_FG> Yeah, it is a fact in computer science that being consitantly wrong is often better then being right. anying fact but a fact.
22:26:30 <pikhq> nolrai_FG: Being wrong in a consistent fashion can, in fact, be very useful.
22:27:58 <path[l]> heh I can only dream of my problem being "who is going to maintain these haskell programs". I'm still at "who is gonna maintain these ruby programs if you leave"
22:28:32 <aavogt> who is going to maintain
22:29:24 <nolrai_FG> period?
22:29:42 <amuck> How can I tell cabal-install which version of ghc I have installed?
22:30:02 <amuck> I keep getting There is no available version of ghc that satisfies -any when I try to install things
22:50:53 <cjs> So, anybody using 6.12 yet?
22:52:21 <Saizan> amuck: that's asking for the ghc package, which is a library that comes with ghc, i think
22:52:33 <Saizan> amuck: however theres's the --with-ghc flag
22:52:43 <Saizan> cjs: i do!
22:53:06 <Axman6> cjs: it's my default artm, though i haven't had any time for haskell lately :(
22:55:43 <Axman6> atm*
23:00:00 <cjs> Any idea what's up with the "Warning: -#include is deprecated: No longer has any effect" in .hsc files?
23:00:39 <sinelaw> kamatsu, do you have a github user?
23:00:44 <kamatsu> sinelaw: liamoc
23:01:29 <sinelaw> added, http://github.com/sinelaw/graphics-drawingcombinators
23:01:36 <sinelaw> i'll add my anti-aliasing stuff
23:01:44 <sinelaw> (btw it doesn't work on my Mesa.. :( )
23:03:06 <dmwit> sinelaw: Have you seen the diagrams library?
23:03:48 <kamatsu> sinelaw: then how do you know it works at all?
23:04:22 <sinelaw> kamatsu, i meant it doesn't work with my DRI. after fiddling with drivers for a while i got it to work (without changing code), but it was using 100% cpu
23:04:28 <sinelaw> (because of software rednering)
23:04:45 <sinelaw> dmwit, i've seen it, yeah nice
23:04:59 <dmwit> Never mind, this seems to be for a different kind of thing.
23:05:06 <kamatsu> sinelaw: ah, ok
23:05:09 <tomberek> i'm having issues with kinds matching mis-matches, instances and typeclasses,,, any good documentation anyone recommends? because I must be doing something wrong
23:05:49 <dmwit> tomberek: Have you met a kinding system before?
23:10:12 <kamatsu> sinelaw: i'm going for about 30 minutes, but i'll probably put together a fill-control patch tonight
23:10:22 <kamatsu> seeya
23:10:31 <sinelaw> k bye
23:34:42 <jrockway> there is something satisfying about waking up to find a single line of output from your batch process -- "Right 3874"
23:34:52 <kamatsu> yah
23:34:58 <jrockway> it is less satisfying when the output is "Left SomeTransientErrorThatYouForgotToCatch" :(
23:35:07 <jrockway> which is what i am looking at right now :)
23:35:44 <cjs> Wow. GHC 6.10 was pretty bad at discovering unused imports.
23:36:38 <kamatsu> "instances only" can usually be removed
23:36:39 <tomberek> i'm having issues with kinds matching mis-matches, instances and typeclasses,,, any good documentation anyone recommends? because I must be doing something wrong
23:36:57 <kamatsu> hm
23:37:03 <kamatsu> just tell us your issues?
23:37:55 <balboa02> Anyone using vim? Is it always necessary to :make before tab-completion works (in a previously unsaved file)?
23:38:11 <kamatsu> balboa02: i use vim but not the haskell plugins
23:38:21 <kamatsu> balboa02: it runs ghci in the background
23:38:27 <kamatsu> balboa02: so ghci must be aware of your program
23:38:31 <jrockway> tomberek: indeed.  nopaste your code somewhere, and people will have a look and help you out
23:38:42 <jrockway> a specific case is easier to explain than the general rules, i think :)
23:38:50 <balboa02> kamatsu: any reason you don't use the plugins?
23:39:27 <kamatsu> balboa02: i prefer to have a separate ghci open
23:39:30 <kamatsu> with my program loaded
23:39:34 <cjs> I don't use the plugins either; I also use a separate ghci.
23:39:53 <cjs> I find that the Ctrl-N/P completion works better anyway.
23:40:07 <tomberek> ok,, one sec
23:40:07 <kamatsu> ctrl+n p?
23:40:26 <balboa02> cjs: hmm, I'll have to give that a try
23:41:00 <cjs> It just searches text in all of one's buffers, so it works even if you've not written the definition yet.
23:41:06 <tomberek> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16698#a16698
23:41:19 <jrockway> cjs: i have found the same functionality in emacs to be very, very useful
23:41:42 <jrockway> i have tried "smart" completion, but i've found that this gives better results most of the time
23:41:59 <jrockway> and there is something satisfying about a dumb solution working better than a smart solution :)
23:42:11 <jrockway> tomberek: i'm taking a look
23:42:13 <tomberek> i know my classes and types are all jacked up,,, but i've been playing with it for hours now... there must be something I don't get about the system
23:42:53 <kamatsu> still, i wish there was a more awesome haskell setup, i often miss some Eclipse features like jumping to where something is defined, finding all the places something was called, and automatically managing imports.
23:43:21 <tomberek> kamatsu: a haskell IDE.. isn't Leksah an attempt?
23:43:38 <kamatsu> tomberek: I dislike leksah
23:43:59 <tomberek> kamatsu: me too, i've defaulted back to ghci and an editor
23:44:03 <jrockway> tomberek: i have a feeling it should be "Net Gr"
23:44:06 <balboa02> kamatsu: i haven't tried it yet, but do ctags not work with haskell?
23:44:21 <kamatsu> balboa02: not sure, i think there is a way to generate tags for haskell
23:45:10 <jrockway> tomberek: i am also a bit confused about your definition of NN
23:45:33 <tomberek> jrockway...as am I by now..... i just want NN to be an instance of Net
23:45:52 <jrockway> is the Net class yours or a library somewhere?
23:45:53 <balboa02> balboa02: i figure ack and ctags would help with finding all the places something is called and jumping to where things are defined ... managing imports is nice though. still, they can pry my vim out of my cold dead fingers
23:46:03 <tomberek> it's right there above it
23:46:08 <balboa02> whoops, i meant kamatsu, not myself
23:46:15 <jrockway> tomberek: ah, yes it is :)
23:46:18 <tensorpudding> where is the definition of NN as an instance of Graph?
23:46:35 <tomberek> Graph is defined in Data.Graph.Iductive
23:46:39 <tomberek> fgl package
23:46:45 <kamatsu> balboa02: still, i spend more time designing java than editing it, so I need Eclipse more than Vim for Java
23:46:48 <tensorpudding> but you haven't defined an instance for NN?
23:46:59 <sinelaw> @hoogle fromMaybe
23:47:00 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
23:47:02 <tensorpudding> or is that somewhere else?
23:47:04 <kamatsu> balboa02: It'd be far nicer to press F3 and jump straight to where something is defined
23:47:18 <sinelaw> @hoogle unless
23:47:18 <lambdabot> Control.Monad unless :: Monad m => Bool -> m () -> m ()
23:47:25 <balboa02> kamatsu: fair enough
23:47:43 <tomberek> jrockway: i'm still new to haskell and I think I have too much OOP style ideas in me
23:48:36 <jrockway> tomberek: here is a simplified example that works: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16698#a16699
23:48:41 <kamatsu> many of those ideas stay
23:48:46 <kamatsu> just get rid of inheritance
23:48:53 <jrockway> basically, the extra "a" and "b" are confusing things
23:49:08 <jrockway> i could be missing something, but i don't understand what that is supposed to mean
23:49:32 <tomberek> jrockway: that's required by Graph... it complains without the gr a a
23:49:49 <Saizan> Graph is a constructor class
23:49:59 <tomberek> kamatsu: problem is that I like inheritance... or is that no good, what's a better way?
23:50:00 <Saizan> Graph gr implies gr :: * -> * -> *
23:50:13 <tensorpudding> what is Gr?
23:50:25 <tomberek> Gr is an instance of Graph
23:50:26 <Saizan> tensorpudding: a type from fgl
23:50:31 <tomberek> Data.Inductive.Graph.Tree
23:50:32 <jrockway> instance Gr a => Net (NN a) ?
23:50:33 <tensorpudding> okay
23:50:45 <Saizan> jrockway: Gr is not a class
23:51:18 <Saizan> tomberek: you can define data NN gr a b=NN gr, because gr is not a type, it's a type function
23:51:52 <tensorpudding> but i may be wrong, don't you need to define an instance for NN (Gr a a) as a Graph before using it as a Net?
23:51:56 <tomberek> Saizan: i just have a fundamental misunderstanding of haskell type and class system (syntax especially)
23:52:06 <tomberek> maybe!
23:52:15 <Saizan> tomberek: iow, you can't have a value of type gr, but you can have a value of type (gr a b)
23:52:32 <jrockway> Saizan: ah, ok
23:52:33 <Saizan> tomberek: yeah, i'm trying to explain :)
23:52:42 <jrockway> i am very confused then :)
23:52:46 <kamatsu> tomberek: lots of inheritance means a bad OO design
23:52:53 <kamatsu> tomberek: favour composition over inheritance
23:53:18 <jrockway> that is good advice even in in languages with traditional inheritance
23:53:30 <Saizan> tomberek: basically, haskell types are complex enough to deserve a type system themselves, those are called kinds, and basically tell you how many parameters a type function takes
23:54:05 <Saizan> tomberek: * is the kind of the types of values, e.g. Int :: *, Bool :: *, Char :: * etc..
23:54:26 <tomberek> Saizan: i think i'm most fuzzy on type function and its syntax.... ok...... so far so good
23:54:37 <Saizan> tomberek: then a type parameterized on another single type like Maybe has kind * -> *
23:55:00 <Saizan> tomberek: then you can apply one type to it and get Maybe Int :: *
23:55:16 <tomberek> so Maybe of an Int is *->*.. so Nothing is also *->* ?
23:55:22 <Saizan> no
23:55:30 <Saizan> Maybe by itself is of kind * -> *
23:55:48 <Saizan> and that has nothing to do with the value level constructor of Maybe
23:55:53 <tensorpudding> :k Maybe Int
23:55:54 <lambdabot> *
23:56:16 <tensorpudding> You can think of Maybe Int as having supplied a * for Maybe, just like if f has type a -> b, then (f a) has type b
23:56:50 <tomberek> ok
23:57:18 <Saizan> type variables default to kind *, unless their use requires otherwise
23:57:28 <tensorpudding> values of * -> * are kinda like functions on types
23:57:54 <tomberek> so they are usually inferred?
23:57:57 <Saizan> yes
23:58:05 <tensorpudding> well, you can specify them explicitly
23:58:08 <tomberek> that's where I'm getting it trouble
23:58:14 <Saizan> the kinds are usually inferred
23:58:21 <tensorpudding> @type (>>=)
23:58:23 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
23:58:46 <tensorpudding> right there, it specified that m had kind * -> *, but that is inferred when you say that m is an instance of Monad
23:59:04 <Saizan> which is similar to what is happening with Graph here
23:59:22 <Saizan> the Graph typeclass is defined as a typeclass over type functions of kind * -> * -> *
23:59:32 <tensorpudding> of course, that is the fancier type that isn't available without a GHC extension
23:59:54 <tomberek> Saizan: i found that out by trial and error, but i couldn't find the source that said that
