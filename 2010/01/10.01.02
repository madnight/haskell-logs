00:01:30 <dolio> So when you prove strong normalization of some calculus, you've proved that any machine executing those rewriting (reduction) rules finishes in a finite amount of time for any well-typed term.
00:01:58 <dolio> Which is operational in character.
00:02:04 <cads> bam!
00:02:07 <cads> O
00:02:30 <cads> umm, accidental line break there.
00:03:25 <cads> I've noticed that a few comcurrency calculi seem to be modelled like this - CSP for one
00:04:09 <dolio> My knowledge of formal concurrency stuff is relatively non-existent.
00:06:49 <cads> well, thanks for the notes of wisdom
00:08:15 <dolio> No problem.
00:11:40 <cads> It means a lot - my computers were completely stolen less than 24 hours ago, in a terrible way to start a new year
00:12:23 <Jafet> (... and the first thing you do is search for programming papers)
00:12:32 <cads> but I have my life still though I might not have been so lucky... and now I have some new papers to read
00:13:49 <Adamant> cads: suggestion for the future - for non-video or game type stuff, online backup is a good way to go
00:14:58 <Adamant> even if they steal your computer and external drives, if you have the User/PW copied down somewhere, you can get your stuff back, and I doubt they will steal every piece of paper in the house
00:15:22 <Adamant> also, sorry man
00:18:51 <dibblego> also have the computer "phone home" at boot time
00:19:30 <adu> dibblego: heh interesting idea
00:20:24 <Jafet> Setup encrypted boot, pour epoxy on the chips so they can't reflash the BIOS
00:20:28 <cads> I thought how useful that would be with a linux system that these thugs won't ever crack/decrypt
00:20:35 <Jafet> Write your phone number on mainboard.
00:21:44 <cads> really I'd just like it to send a picture of whoever's using it, and some plastic explosive wired up inside it
00:22:22 <cads> but that's actually illegal for me to say where I live so I completely take that back
00:22:31 <Jafet> Hmm, a hardware honeypot.
00:22:36 <Jafet> Intriuging.
00:23:26 <Twey> Hahaha.
00:23:47 <cads> yeah, that part is pretty nice - suppose the computer is super friendly to everyone and even automatically hops onto wireless networks it breaks automagically -- but it's really phoning home the whole time
00:24:31 <cads> the part where the user is able to remotely detonate the machine, presumably to destroy the data and physically harm an adversary... that's just a bit sadistic
00:25:16 <cads> and plus, imagine that your adversary has knowledge that your machine has such a capability, and tries to activate it _while you have it_
00:25:26 <Jafet> He can't. You run linux
00:25:38 <Jafet> (Hopefully with selinux and ufw)
00:26:22 <cads> hehe, I always said it would be neat if iphones where also programmable grenades
00:26:32 <cads> if only because then more people would blow up iphones
00:26:41 * Twey makes a note to keep well away from cads' hardware.
00:26:42 <adu> I think geolocation would be enough for me... explosives are a bit much
00:26:49 <Jafet> I thought they blew up on their own already
00:26:58 <Twey> No, that's Nokia
00:27:34 <medfly_> cads: there's a problem with that, mainly because no one is stupid enough to stand near that
00:27:38 <medfly_> normal use
00:27:44 <adu> http://www.smashsomestuff.com/iphone/
00:27:52 <Twey> (TFIT ufw)
00:28:26 <medfly_> I personally thought of using some kind of tool that'd regularly try to connect to the Internet, and to some server you own, every so often
00:29:03 <adu> I was thinking of that too, but for dynDNS updating
00:29:07 <cads> and many new laptops have gps and camera/mic built in
00:29:13 <Jafet> adu, is that like fight club except legal
00:29:16 <adu> so I wouldn't have to change anything when my IP address changed again
00:29:43 <adu> there are softwares that do it already, but I never used them
00:29:46 <medfly_> something of this sort. the only thing I cared about is that this wouldn't get deleted if you format the HD or something.
00:30:02 <medfly_> though even that is beyond what most thieves would do.
00:30:19 <adu> like it would upload your current IP to some external server (with static IP of course)
00:30:36 <adu> that would be enough for most geolocation services
00:31:08 <medfly_> I don't think so, it's impossible to locate people from their IP where I am, you'd need to contact the police, though they'd be willing in that case
00:31:18 <medfly_> I think
00:31:27 <cads> medfly_: I think you could directly connect a flash drive to an internal USB heade, and then you'd have to somehow modify your bios to silently boot it first
00:31:40 <cads> header*
00:31:41 <Jafet> Install a GPS device
00:31:51 <medfly_> yeah, I was thinking of something like this, like a floppy that basically has a boot loader
00:32:01 <medfly_> seriously though
00:32:01 <adu> GPS would be infinitely better
00:32:06 <medfly_> what are you going to do if you know where the thief is
00:32:10 <medfly_> break into his home?
00:32:21 <Jafet> Tell the internet about it
00:32:21 <cads> umm
00:32:22 <adu> call the police
00:32:27 <medfly_> doesn't GPS not work so well?
00:32:32 <medfly_> only outside, etc
00:32:33 <cads> yeah, you can call the police
00:32:47 <cads> gps works within meters, it should be enough
00:32:50 <medfly_> I'd just get his IP
00:33:00 <Jafet> The police will confiscate your computer and you'll never see it again
00:33:00 <medfly_> doesn't GPS only work outdoors
00:33:15 <adu> tell them "I had a GPS in my lappy" then they'll look at you funny, then possibly bring a warrant and stuff to the theif's place
00:33:20 <medfly_> and only properly if you got an antenna and shit
00:33:25 <Jafet> medfly, it works anywhere you can get a satellite radio signal
00:33:29 <Jafet> Since that's what it is.
00:33:46 <Jafet> Unless your thieves live in a mine, perhaps
00:33:54 <cads> it'll work inside
00:34:13 <medfly_> GPS is less accurate than the IP
00:34:15 <medfly_> if you have a warrant
00:34:18 <cads> additionally, the device ought to log its path so that you would even know the places the laptop had travelled
00:34:31 <medfly_> that's just inefficient
00:34:35 <medfly_> you'd have a lot of trash data
00:34:37 <medfly_> :)
00:34:43 <Jafet> logrotate
00:34:45 <adu> medfly_: its only usually off by a few meters, much better than IP geoloc
00:34:53 <medfly_> I didn't say "IP geoloc"
00:35:01 <medfly_> I said "get a warrant and ask the ISP for his address"
00:35:12 <cads> adu - but an ip corresponds to an actual physical adress and a customer paying for the ISP service
00:35:22 <adu> o, that's what you meant
00:35:23 <Jafet> Go to Google Maps and you can even see what 'is house looks like, medfly
00:35:28 <cads> I agree that the police have this as a more well established protocol
00:35:51 <cads> but remember, what we're describing here already exists as a service from a company called lo-jack
00:35:57 <adu> cads: as opposed to explosive laptops?
00:36:32 <cads> where your car/computer/whatever has a gps bug, and the lo-jack company is recognized by the police as a trusted authority
00:36:52 <Jafet> And you recognize lo-jack as a trusted authority
00:36:55 <medfly_> I think you can build a chip into the computer if that's popular enough, and then have it update a server with your MAC address and IP address eveyr 24 hours.
00:36:59 <medfly_> or something.
00:37:22 <medfly_> something which is unique enough
00:37:58 <medfly_> I'm leaving this discussion due to feeling too stupid to talk about it in #haskell
00:37:59 <Jafet> The thief could... shut down the computer
00:38:05 <medfly_> what would he do with that?
00:38:10 <medfly_> what's the point of stealing the compute rthen?
00:38:19 <Jafet> To sell it to someone else.
00:38:28 <medfly_> right and... that lets you track him down
00:38:29 <Jafet> To strip for parts.
00:38:55 <cads> the point of stealing a computer as not often "to be able to program haskell with this dude's neat libraries which he's assembled over the last couple of years"
00:39:13 <cads> :P
00:39:32 <medfly_> if one of those parts still reports this unique piece of info and the IP when used, then you can still track him down
00:39:34 <Jafet> I would steal a computer like that
00:39:40 <adu> wouldn't that be funny... if your theif was in this chatroom...
00:39:47 <Jafet> Free technical papers, too
00:39:54 <cads> and love poems
00:39:58 <adu> aww
00:40:01 <cads> don't forget the awesome love poems :D
00:40:01 <medfly_> I think anyone who can program in Haskell can make much better money than by stealing laptops
00:40:12 <Jafet> Hugs all around.
00:40:14 <medfly_> though thieves can do well
00:40:24 <cads> the haskell job marke... exists?
00:40:29 <cads> market*
00:40:37 <medfly_> no, but it usually means you can program in another language too.
00:40:45 <cads> money for mooks who make monads?
00:40:52 <medfly_> what's a mook?
00:41:02 <cads> a generic fleb
00:41:16 <medfly_> @wn fleb
00:41:18 <lambdabot> No match for "fleb".
00:41:24 <medfly_> stop making up words.
00:41:35 <Jafet> "mook" is a word.
00:41:42 <medfly_> @wn mook
00:41:43 <lambdabot> No match for "mook".
00:41:53 <Jafet> Is that wordnet?
00:41:54 <medfly_> deceiving me!
00:41:57 <medfly_> I think so
00:41:58 <medfly_> @help wn
00:41:59 <lambdabot> I perform dictionary lookups via the following 13 commands:
00:41:59 <lambdabot> all-dicts ... Query all databases on dict.org
00:41:59 <lambdabot> devils ...... The Devil's Dictionary
00:41:59 <lambdabot> easton ...... Easton's 1897 Bible Dictionary
00:41:59 <lambdabot> elements .... Elements database
00:42:01 <lambdabot> [9 @more lines]
00:42:17 <Jafet> Indeed, wn is deceiving you!
00:42:20 <cads> heh, a mook is someone you don't want to be taken for, I think a more slow witted person that's not completely aware of tricks that might be played on him
00:42:38 <medfly_> oh, okay
00:42:52 <Jafet> Usually encountered in the plural form
00:43:00 <cads> "A term coined by Douglas Rushkoff in an episode of PBS's "Frontline" entitled "The Merchants of Cool." Mooks are archetypal young males(teens-early 20s) who act like moronic boneheads. They are self centered simpletons who live a drunken frat-boy lifestyle"
00:43:10 <cads> this is not quite the usage
00:44:00 <Adamant> um, I would be very surprised if Douglas Rushkoff coined that term.
00:44:40 <cads> but I was saying that people that program in haskell, the world treats like "awww, idn't that cute, now here I will give you a 6 figure salary if only you _put the damn ghc away and work on java_ ... you mook you.. :P"
00:44:59 <CESSMASTER> idk, that bs sounds like something a pro-open source media theorist would invent
00:45:09 <medfly_> what does 6 figure salary mean
00:45:17 <medfly_> per month? per year seems like a standard thing even if it's really low
00:45:31 * medfly_ assumes we're working in USD/EUR
00:45:52 <Adamant> cads: if you think Haskell makes a programmer better, mook is probably not the appropriate term
00:46:03 <Adamant> medfly_: per year
00:46:39 <Adamant> cads: maybe in an endearing way, like saying schmuck in the same situation
00:46:47 <medfly_> oh
00:46:49 <medfly_> six. right. okay
00:46:50 <cads> medfly_: it's when your salary +bonuses/benifits sums up to more than $100,000USD
00:46:50 <Jafet> Java programmers have 6 figure salaries?
00:47:00 * medfly_ got confused
00:47:04 <Adamant> Jafet: yes, some do
00:47:08 <Adamant> still
00:47:32 <Jafet> How about "rascal", Adamant
00:47:32 <cads> Jafet: when you're Guy Steele, for example, and you're working on the JVM, I think they pay you well
00:47:44 <Jafet> Ah. But I'm not Guy Steele.
00:49:30 <Adamant> cads: I'm talking senior-ish programs that work in Java
00:49:37 <Adamant> *programmers
00:49:52 <Adamant> not guys like Guy Steele that are Fellow-grade
00:50:03 <medfly> do any kind of programmers make 6-figure salaries?
00:50:18 <medfly> o.O
00:50:27 <medfly> when not senior, I guess?
00:50:55 <cads> Usually people that get payed more in the business of programming are those that manage groups of programmers and ensure that whole projects get done
00:51:04 <medfly> ah
00:51:30 <cads> Adamant: I guess I was talking about those higher grade theorist types
00:51:49 <cads> which people often see as disconnected from reality
00:52:04 <Adamant> cads: Guy Steele has shipped a few things
00:52:57 <cads> well, I mean, he's been with Sun a while
00:52:58 <Adamant> medfly: sometimes, depends on what they are doing. expecting to get that much as a junior programmer is probably not that realistic
00:53:26 <cads> and the guy half wrote scheme
00:54:06 <cads> hey, who pasted the iphone smashing link - I have this in reply: http://www.youtube.com/watch?v=qg1ckCkm8YI
00:59:19 <cads> Adamant: I think this is all started by how we see stuff like simon jones and erick meijer both working for microsoft... you just feel like they'd be writing more interesting papers if they stayed in academia - but at the same time perhaps it's more rewarding for them to have the resources that they must have available there in the company, compared to having to drum up grants and such
01:00:13 <Jafet> They write interesting enough papers already
01:00:20 <Jafet> What would you have thought about Bell Labs?
01:00:31 <Adamant> cads: who knows. I think MS Research is generally about as liberal in what you can write about for CS as anything you are going to get without hopping in the time machine to Bell Labs
01:00:36 <Adamant> Jafet: jinx!
01:00:41 <cads> heh, that's a good point jafet! :D
01:02:03 <Jafet> Bell Labs was a place where you could do research on kitchen sinks, though. MSR is more theoretical software oriented
01:02:16 <dark> Adamant, with the exception that you can't really write open source tools, to work in cool open source OSes
01:02:33 <cads> I just know quite a few good papers I've read have come out there :)
01:03:38 <cads> I don't think this hilarious comic is exactly the truth, but it does illustrate a fear of mine: http://xkcd.com/664/
01:04:03 <Adamant> dark: if you're doing really theoretical stuff, you're not producing a ton of stuff that most open source OS's will jump on with both feet
01:04:10 <dark> cads, ^_^
01:04:23 <Adamant> in that your stuff is fairly experimental
01:04:33 <dark> Adamant, hmmm.. but if you then want to implement for linux and not windows, you probably can't..
01:04:51 <dark> many "theoretical" stuff are actually being implemented on top of free oses
01:05:19 <cads> MS is starting to open source more things - there's the two research OSes which are /partially/ open
01:05:24 <Adamant> dark: I'm not sure how hard doing general POSIX stuff is from MS Research
01:05:30 <dark> hmmm
01:05:42 <Adamant> targetting Linux specifically is probably a no-no, yes
01:06:00 <cads> I wonder if they helped mono at all
01:06:04 <bo0ts__> cads: Yeah, sure. Shared Source ain't Open Source.
01:06:31 <cads> I wonder if that's a big "heck no, mono spread like, well, mono, and before we know it those free fucks had a copy of our work"
01:06:46 <dark> cads, there were a tv series here that there is a recurring scene where a character calls another in the cell phone and say "Bino, é uma cilada" (that means "bino, it's a trap")
01:07:23 <cads> no, mono is the GNU implementation of the .Net platform
01:07:28 <Adamant> dark: that was a good point btw, about implementing stuff on top of open source stuff.. I was thinking more about getting stuff, say, integrated into the Linux kernel :P
01:07:33 <dark> cads, the site br-linux.org puts the tag "bino" in all news related to microsoft when they want to be interoperable, open source etc
01:07:48 <cads> ahh
01:07:49 <cads> heh
01:07:58 <Adamant> dark: for translation to geek English, just add Admiral Ackbar
01:07:58 <bo0ts__> dark: I remember some news about MS using shared source programs as a way to identify possible patent infringements. Sounds like fun. Let's sign up for some legal threats.
01:08:22 <Gracenotes> hm. what's a delta in LaTeX?
01:08:36 <Gracenotes> just.. \delta x? hm
01:08:43 <dark> Adamant, admiral ackbar?
01:08:59 <dark> mono isn't from gnu; there is dot gnu instead
01:09:15 <Gracenotes> no, delta as in difference, so should be \Delta
01:09:21 <Adamant> dark: from Star Wars.. there is a point in the film where he says "It's A Trap!"
01:09:38 <Adamant> dark: the image has become a popular meme
01:09:48 <Adamant> at least among geek types
01:09:59 <dark> ah:) (ok didn't know)
01:10:16 <cads> Adamant: I don't think it's very easy for linux developers to work on a obscure kernel branch - for example they might be 5 of them working on say a scheduler, and if their work isn't better at all benchmarks, it is never put into the kernel - or maybe the guy that put his foot down in front of your change turns around and fixes the tiny problem, and then takes your credit
01:10:25 <Adamant> dark: it's OK, it's hard to gauge English media coverage sometimes
01:10:47 <dark> no, i probably should, but i am not very deep into sw
01:10:56 <Adamant> cads: I think messing with the Linux kernel in general just isn't fun times anymore
01:11:01 <cads> but in any case I don't imagine that there is deep branching of the linux kernel where you see groups of people working on a kernel that's radically different than the main branch
01:11:20 <cads> this is probably not true inside actual companies that use the linux kernel inside their products, however
01:11:27 <Adamant> sure
01:13:02 <cads> adamant, outside the environment of coporate sponsorship in the kernel world there might be the feeling that distractions in hopeful directions would tend to waste precious donated time
01:13:27 <cads> what do you think?
01:14:16 <cads> it's almost like the kernel represents a local optimum, and we just polish that without introducing very large variations
01:14:22 <dark> I don't imagine that there is deep branching of the linux kernel where you see grouI don't imagine that there is deep branching of the linux kernel where you see groups of people working on a kernel that's radically different than the main branchps of people working on a kernel that's radically different than the main branch > that's the purpose of gpl
01:14:37 <dark> oops.
01:14:48 <Adamant> cads: I think a few things, but none of them are going to win me any friends on freenode, so I will remain quiet.
01:15:06 <dark> Adamant, hahahaha
01:15:08 <dark> Adamant, say
01:15:54 <dark> Adamant, we will respect your opinion
01:17:07 <dark> cads, the kernel surely is a local optimum -- that's because large reengineering takes too much time
01:17:23 <dark> nhmm
01:17:40 <Adamant> the whole PaX thing kind of soured me on the kernel folks
01:17:50 <dark> pax?
01:18:06 <Adamant> rather large and involved security patch
01:18:09 <dark> for eg. ext4 is a 'conservative' improvement
01:18:20 <dark> hmmmm
01:18:32 <dark> (ps:soured? sorry my english is bad)
01:18:45 <ivanm> dark: he didn't think much of them anymore
01:19:02 <Adamant> it seems more or less that your quality of implementation or ideas matters less than who you know and who Linus trusts
01:19:14 <dark> yeah.
01:19:21 <ivanm> Adamant: the scheduler issue being a case in point?
01:19:22 <dark> i am thinking of -ck
01:19:50 <Adamant> ivanm: I only tangentially followed that drama
01:19:56 <cads> Adamant: http://en.wikipedia.org/wiki/PaX
01:19:59 <dark> In fact it would be better to get the ck code, so that he would feel more comfortable contributing
01:20:19 <dark> Adamant, so what you propose? to incentive more forks?
01:20:34 <Adamant> dark: I don't propose anything
01:20:35 <dark> the reason that nobody can fork is that the linus source is so useful..
01:20:40 <dark> oh :)
01:20:56 <cads> heeh, dude is in the hospital with heart problems, gets out and finds out that the patch he had submitted but had been rejected... had been fixed and the whole scheduler renamed to something else, and the person that had rejected his patch took credit for pretty much the whole work
01:21:34 <dark> he is really in the hospital with heart problems?
01:21:38 <cads> but I guess they don't name theorems after mathematicians that give _nearly_ complete proofs
01:21:53 <dark> cads, hehehe good point
01:22:04 <cads> so maybe that one little change required some very subtle and profound thinking
01:22:24 <dark> cads, but ingo molnar gave credit to him -- he is not on the copyright list simply because ideas can't be copyrighted
01:22:35 <dark> (also ken thompson isn't on the copyright list)
01:23:25 <dark> in fact ingo asked once a guy to send the patch for a typo, so that the guy could have credit for finding it
01:23:41 <dark> but i understand you :P
01:23:58 <cads> Adamant: where I see operating systems going as far as capabilities models, distributed computing, and above all my favorite trend - formal proofs of code correctness... it seems like for at least the final one, linux is a poor choice for research or even implementation
01:24:05 <dark> Adamant, what is the problem with pax/
01:24:33 <dark> yes. i want a formally defined kernel
01:24:58 <dark> and, it's sad that microsoft leads this process
01:25:08 <Adamant> dark: more or less, it was designed before the LSM interface and doesn't interface with it... and it goes a lot further in several ways to ensure security than the kernel team seems to be comfortable with
01:25:14 <dark> i heard about something on top of l4, but i don't know about this
01:25:42 <cads> dark. for example something like L4.verified, or coyotos
01:25:45 <dark> Adamant, why? they don't seems comfortable
01:26:07 <Adamant> and, increasingly, maintaining large patches outside the kernel is much harder than it was when PaX was initially written, due to the changes with 2.6
01:26:13 <dark> cads, what do you think about singularity/
01:26:23 <cads> I think coyotos is dead :/
01:26:24 <kmc> dismantle the moon
01:26:33 <cads> hah, DISMANTLE THE MOON!!
01:27:11 <Adamant> so, enough people like PaX that it's used, but there is about zero chance of it being integrated into the kernel
01:27:28 <dark> o.o
01:27:34 <Adamant> and it's become more or less a running flamewar on lkml that raises everyone's blood pressure
01:27:38 <dark> Adamant, couldn't it be rewrite?
01:27:40 <cads> kmc, now the idea of turning the solar system into inhuman thinking matter is something every human should Support!
01:27:54 <Adamant> dark: they've rewritten some of the functionality of it
01:28:02 <dark> Adamant, :)
01:28:12 <Adamant> it's not as complete or through in the protection as PaX though
01:28:26 <cads> Adamant: shouldn't stuff like SElinux do what PAX does?
01:28:30 <dark> Adamant, so maybe the implementation doens't matter too much, what matter is to please linus
01:28:31 <cads> ah
01:28:36 <Adamant> cads: no, orthogonal
01:28:43 <cads> hmm
01:28:58 <Adamant> cads: they can support each other, but they do different things
01:29:15 <Adamant> dark: the people that wrote it don't think that's highly of Linus, or Linus of them
01:29:20 <dark> pax is like stack-smash (I don't know the exact name) from gcc, for kernel
01:29:21 <Adamant> *that highly
01:29:22 <cads> do you know about the corresponding security situation in freebsd?
01:29:41 <Adamant> I haven't paid attention to that in a long time
01:29:41 <dark> Adamant, who wrote?
01:29:48 <Adamant> I know they had TrustedBSD
01:30:13 <cads> is that integrate into intel's trusted computing platform of scary death?
01:30:32 <Adamant> dark: an anonymous developer "PaX Team" and now spender of the grsecurity project
01:30:38 * cads likes the idea if it was he alone that had the internel private keys
01:30:44 <dark> Adamant, why anonymous?
01:30:59 <Adamant> cads: no, think Orange Book, Common Criteria type stuff
01:31:08 <Adamant> dark: some security folks are paranoid
01:31:15 <dark> ... :)
01:31:19 <Adamant> PaX Team is a security dude
01:31:27 <cads> nice
01:31:29 <dark> Adamant, seems nice ^^
01:31:42 <cads> Adamant: heh, thanks for reminding me of the orange book :)
01:31:58 <cads> anyways, fun chatting you guys, but must dip out
01:32:02 <Adamant> cads: one sec
01:32:05 <cads> with*
01:32:06 <dark> but what linus says? that he will not talk with a cracker?
01:32:13 <cads> happy newyears all though!
01:32:22 <Adamant> check out whatever Robert Watson is doing
01:32:24 <dark> cads, happy new year!
01:32:32 <Adamant> if you want to know what's up with FBSD security
01:32:48 <cads> dark, linus says "you are Styupiet! Styupiet!"
01:32:49 <Adamant> he's a fairly big mover and shaker for that in the FBSD community
01:33:01 <dark> cads, ?.-.
01:33:52 <dark> http://en.wikipedia.org/wiki/PaX dont talk about this controversy
01:33:53 <dark> =/
01:34:32 <Adamant> dark: you can check lkml for a quite a bit of it if you have a lot of time and a strong stomach
01:34:42 <dark> do you have a link?
01:34:46 <Adamant> and hopefully are also bored out of your brain
01:34:51 <dark> wow
01:34:53 <Adamant> no
01:34:56 <dark> they were cursing each other?
01:35:23 <cads> probably not on record :P
01:35:42 <Adamant> dark: look for freemail.hu and grsecurity.net email addresses
01:35:42 <cads> these guys have some sense of poise and professionality
01:35:56 <Adamant> cads: you are being ironic, right :P
01:36:53 <dark> http://lkml.org/ i cant find search
01:36:55 <dark> .-.
01:38:03 <cads> Adamant: partially... butl they don't degrade into arguments like "Aw man that shit is bullshit, i MADE that code, and all you fucking did was change one fucking thing and took credit, while I was in the MOTHERFUCKING HOSPITAL. That's some shit. Fuck you."
01:38:28 <cads> probably because people like that don't take part in a working community for long :)
01:38:44 <dark> what about reiser?
01:40:02 <dark> (well he didnt lasted long)
01:40:20 <Adamant> cads: um, you might want to check some of the comments Linus has put on record, including calling other developers he doesn't like "masturbating monkeys"
01:40:34 <ksf> The problem with being too right is that you might loose the sense of others being right, too.
01:41:23 <Adamant> in general I just don't care about kernel stuff too much anymore, which avoids me having to follow any more of the controversies
01:41:28 <dark> i don't think he was right in this issue. security bugs ARE functionally different than regular bugs
01:41:38 <dark> because random bugs can't be triggered by a foe
01:42:06 <ksf> Oh, I was talking about reiseresque blatant layering violations
01:42:32 <dark> (i was to comment "you still dont accept my new fs you are complaining about it WHILE I AM ON JAIL fuckyou grgr")
01:42:47 <dark> (but i felt it too harsh)
01:42:58 <ksf> oh, reiserfs3 is great, I use it all the time.
01:43:02 <dark> (... wait, i don't know what is harsh)
01:43:21 <cads> dark, actually, I think that you cannot in principle prevent an adversary from using arbitrary design flaws against you - it is even impossible in principle to find out that they have discovered and are using a bug against you
01:43:28 <ksf> I would've probably switched to 4 if I had the spare disk space to switch, and butterfs wasn't that far advanced.
01:44:33 <dark> cads, but the probability of a adversary using a bug flagged as 'security' against you is usually higher than a random bug
01:45:08 <dark> cads, also, a random bug that can be exploited is a actually a security bug
01:45:12 <cads> dark, I've seen where the informal argument I gave was supported by a writer using  rice's theorem http://en.wikipedia.org/wiki/Rice%27s_theorem
01:45:29 <ksf> all in all, I can't blame linus for playing the bad cop.
01:45:45 <ksf> he's the BDFL, after all.
01:46:02 <kmc> yay rice's theorem
01:46:06 <medfly> it's funny that people who are considered known in the world of programming/open source are not the typical people who'd be presentable almost all the time
01:46:34 <Jafet> I wouldn't consider a lot of famous people very presentable
01:46:35 <dark> hmmm. you are talking about rms?
01:46:38 <cads> medfly: I saw stallman and wanted to throw a bar of soap at him
01:46:39 <ksf> uh, selection bias.
01:46:49 <ksf> flames tend to be more visible than anything else.
01:46:50 <dark> cads, hm o.o
01:46:50 <cads> ... or maybe to beat him with a bar of soap in a sock but still
01:46:54 <dark> cads, why?
01:47:07 <kmc> stallman gave a talk at my school
01:47:09 <Jafet> He will catch the soap with his chopstick-fu
01:47:14 <kmc> he was more interested in the free food than in giving the talk
01:47:24 <dark> aHUAHUhaUHUA
01:47:28 <medfly> I suppose, but I'm used to those kind of people being in suits and trying to act like it most of the time
01:47:30 <cads> it would be a battle for the books, my soap fu is buku
01:47:30 <kmc> also someone offered him a coke and he went into a rant about how coca cola oppresses workers in colombia
01:47:35 <Jafet> Well, he's given a lot of talks.
01:47:36 <medfly> not going "motherfucking wanker"
01:47:42 * medfly is entertained
01:47:51 <dark> cads, what's the problem with rms/
01:48:01 <dark> kmc, omg
01:48:29 * ksf would rant and take the coke
01:48:59 <medfly> that'd be being hypocritical
01:49:06 <ksf> how so?
01:49:15 <ksf> the workers have already been opressed.
01:49:21 <cads> "by the way, the benevolent saint ignucious... requires some cocaine right now"
01:49:33 <ksf> can't make that undone by not drinking a produced bottle.
01:49:55 <dark> cads, but if you have a bug *classified* as a security bug, then there is more potential attackers. but, for some systems, the *unclassified* bugs are more dangerous (because the classified ones are fixed earlier)
01:50:07 <Jafet> Taking a bottle causes another value of the infinite stream of imperialist capitalism to be forced
01:50:12 <ksf> furthermore, by not slapping someone in the face by rejecting a gift you can get your point across more easily.
01:50:21 <dark> ksf, but you can prevent more opression by not drinking
01:50:25 <dark> ksf, wait, you cant
01:50:27 <dark> .-.
01:50:38 <medfly> the cola I drink is manufactured locally, strangely...
01:50:45 <medfly> so no problem!
01:50:59 <ksf> you _can_ drink coke and point out that you'd rather have a club mate.
01:51:06 <dark> ... but the evil company that sells you uses your money to oppress distant countries, medfly
01:51:10 <Jafet> Well, I'd rather be an underworked coca cola sweat shop worker in Columbia than an unemployed drug addict in Columbia.
01:51:21 * Jafet pops a can
01:51:28 * medfly agrees
01:51:39 <dark> ksf, rms slapped the guy? i don't think so oo
01:51:51 <cads> I dunno, lord knows stallman doesn't need to be downing 30 grams of sugar per serving...
01:51:52 <ksf> argh.
01:51:56 <ksf> not physically.
01:52:06 <Jafet> M-x slap
01:52:08 <ksf> the point is that to convince someone, you should pay attention not to be disagreeable.
01:52:11 <cads> maybe that was his way of expressing he's self conscious about health issues
01:52:32 <dark> Jafet, (i laughed)
01:52:48 <cads> haskell 2010 is out!
01:52:59 <cads> what a futuristic sounding statement
01:53:08 <medfly> it's 2010 though
01:53:17 <dark> :) what's new for haskell?
01:53:34 <Jafet> Acknowledgement that ghc exists
01:53:37 <cads> medfly:  and we have guitar hero controllers that are wireless... Welcome To The Future!
01:54:00 <dark> ksf, ah now i see the "by rejecting"
01:54:42 <dark> Jafet, ghc might never existed before?
01:55:02 <Jafet> It's extensions didn't.
01:55:13 <Jafet> s/'// # what is this
01:55:37 <medfly> hehe
01:56:11 <kmc> most of the extensions in H2010 are old though
01:57:18 <cads> aw what a gyp, it's been out for two moneths and I just didn't know it
01:58:11 <cads> ok. I am getting loopy, it's time for sleep
01:58:14 <cads> but first
01:58:34 <cads> What does the Modern On-the-Go Business Lion use to keep his appointments in order?
01:58:54 <cads> ... a ROARganizer!
01:59:07 * cads RUNS out of here SO FAST
01:59:22 <cads> heh, night all
01:59:30 <ivanm> begone you cad!
01:59:31 <ivanm> ;-)
02:18:45 <ivanm> @. elite quote
02:18:46 <lambdabot> haxk0 $ays: /\/\os+ PR0grAMm3R5 Ha\/E A L0T oF re1i9iOus i5SUEz0rz 4bouT T|-|3iR WoRx, yEz.
02:19:08 <kmc> @ghc
02:19:08 <lambdabot> ghc says: Can't reify a non-Haskell-98 data constructor
02:21:57 <dark> sfdsddsdfsd
02:22:11 <dark> ivanm, that was said here?
02:22:16 <dark> @help
02:22:16 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
02:22:19 <dark> wow
02:22:21 <dark> :)
02:22:24 <dark> @help list
02:22:24 <lambdabot> list [module|command]
02:22:25 <ivanm> dark: most probably
02:22:25 <lambdabot> show all commands or command for [module]. http://code.haskell.org/lambdabot/COMMANDS
02:22:28 <kmc> not all @quotes are from irc
02:22:33 <dark> @list
02:22:33 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
02:22:54 <kmc> @quote following.diagram
02:22:54 <lambdabot> PhilipWadler says: To see that "in" and "out" are inverses, stare at the following diagram
02:22:55 <ivanm> but most are
02:23:10 <dark> i have a question (i could look the docs but i am feeling lazy now)
02:23:23 <dark> does haskell have a numerical tower?
02:23:26 <dark> like scheme
02:23:34 <kmc> it has a hierarchy of typeclasses for numbers
02:23:56 <kmc> http://www.bucephalus.org/text/Haskell98numbers/Haskell98numbers.png
02:23:57 <dark> what about overflow-to-bignum behavior?
02:24:05 <kmc> dark, no, there are no implicit conversions
02:24:13 <dark> .-.
02:24:14 <kmc> however behind the scenes, a small Integer has a representation similar to an Int
02:24:30 <kmc> i think it's a shame how extensively Int is used throughout the std lib
02:24:41 <kmc> seems like premature optimization
02:24:46 <dark> Integer = fixnum or bignum?
02:24:50 <kmc> Int is machine size
02:24:54 <kmc> Integer is arbitrary size
02:25:00 <dark> hm
02:25:06 <dark> what about +? it's overloaded?
02:25:10 <kmc> yes
02:25:15 <kmc> are you familiar with how typeclasses work?
02:25:17 <kmc> :t (+)
02:25:18 <lambdabot> forall a. (Num a) => a -> a -> a
02:25:31 <dark> no......
02:25:39 <kmc> a typeclass is a set of types
02:25:44 <kmc> (at least in the one-parameter typeclass case)
02:25:48 <kmc> so Num is the set of numerical types
02:25:55 <kmc> (+) takes two values of type a, and returns another value of type a, where a can be any type in Num
02:26:14 <dark> so I can write a function that receive Num easly?
02:26:17 <dark> hmm
02:26:25 <kmc> :t let f x y = 2*x + y in f
02:26:26 <lambdabot> forall t. (Num t) => t -> t -> t
02:26:27 <kmc> :t let f x y = 2*x / y in f
02:26:28 <lambdabot> forall t. (Fractional t) => t -> t -> t
02:26:34 <kmc> in the second case i used (/) which is from Fractional
02:26:42 <kmc> so it infers that t must be Fractional and not just Num
02:26:45 <kmc> > (2 :: Int) / 3
02:26:46 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
02:26:46 <lambdabot>    arising from a use o...
02:26:48 <kmc> > (2 :: Double) / 3
02:26:49 <lambdabot>   0.6666666666666666
02:26:50 <dark> what about a function that takes two nums and return an opaque num? (that could be Int or, if overflow, Integer)
02:27:00 <kmc> you should just return an Integer
02:27:02 <ivanm> what is an "opaque num"?
02:27:14 <kmc> it is not possible to make opaque typeclass instances like that, in Haskell 98
02:27:14 <dark> ivanm, i don't know, i don't know haskell :)
02:27:19 <kmc> it is possible with GHC's extensions
02:27:20 <Cale> I think you're thinking of an existential type
02:27:25 <kmc> specifically "existential types"
02:27:28 <ivanm> dark: you mentioned it, not me!
02:27:30 <kmc> but it's not a typical thing to do
02:27:32 <kmc> for numbers
02:27:45 <dark> ivanm, uhm
02:27:50 <kmc> the numbers representable by Integer are a superset of those representable by Int
02:28:03 <kmc> so you'd just use Integer, and rely on the implementation to pick a good compact representation for small ones
02:28:09 <Cale> Integer will already use machine arithmetic for small numbers
02:28:53 <kmc> dark, so you can think of (+) as a generic function, that can be instantiated at various concrete types
02:29:01 <kmc> and the (Num a) bit of the signature is a constraint on which types are allowed
02:29:02 <dark> Hmmmm it would do it kmc ? so why explicit Ints would be desirable?
02:29:04 <Ke> how does it know that a numbers is small at compile time
02:29:20 <Cale> It doesn't need to
02:29:23 <kmc> Ke, it doesn't.  GHC's Integer is an algebraic type with a few constructors
02:29:27 <kmc> one for small numbers
02:29:36 <Ke> ok
02:29:42 <kmc> dark, explicit ints would get you a bit more performance if you're sure the numbers are small
02:29:45 <Ke> sounds like overhead still
02:29:52 <kmc> Ke, of course there's overhead
02:29:56 <ivanm> dark: if you can use Int, it will have improved performance over Integer
02:29:58 <kmc> it's really not worth worrying about for a first draft program
02:30:04 <Ke> yup
02:30:24 <kmc> the difference is more significant in cases where GHC can find strictness and unbox the Ints
02:30:32 <kmc> or if you explicitly create strict fields
02:30:46 <kmc> likewise the packed mutable arrays and of course C foreign calls will use machine size ints
02:30:58 <dark> strictness?
02:31:06 <kmc> dark, yes, the opposite of laziness
02:31:14 <kmc> (more or less)
02:31:26 <kmc> dark, values in Haskell are not computed until they are required
02:31:40 <Olathe> I think that if there was a way to make small integers faster, GMP would already be using it.
02:32:50 <Olathe> Though I could see how that might be a required tradeoff.
02:33:30 <kmc> intelligent inlining, strictness analysis, and unboxing is really essential for fast numerical code in Haskell
02:33:42 <kmc> which is all the job of the compiler
02:33:47 <kmc> but can get sort of hairy
02:34:28 <dark> @.@
02:34:29 <lambdabot> Maybe you meant: . @
02:34:31 <kmc> there is some point at which you might as well write the numerical code in C and call it via FFI
02:35:23 <dark> A friend of mine pointed out that the filesystem actually offers a good lock-free sync framework
02:35:27 <kmc> dark, are you learning Haskell?
02:35:30 <dark> because mv is atomic
02:35:32 <kmc> heh
02:35:34 <dark> kmc, not yet
02:35:39 <kmc> how is it lock-free?
02:35:45 <kmc> not in implementation certainly
02:36:06 <kmc> dark, you should do it ;)
02:36:20 <dark> well, you can move data from one part to another without worrying to have duplicate copies
02:36:38 <Jafet> And practice with project euler problems!
02:36:50 <dark> project euler problems?
02:37:23 <AmunRa> Hello! I'm learning haskell and I'm struggling with data structures, specifically: is there a multi-indexed table-like structure I can use?
02:37:56 <dark> AmunRa, of course i am suspect, but i think there should be a 'map'
02:38:12 <Jafet> If you want a "database", there are bindings to databases.
02:38:41 <AmunRa> my problem (simplified): colours in a box.. I need to place colours in a box.. for this I can use some multi-map.. box 1: [Red, Blue, Green]
02:38:46 <Cale> AmunRa: You can keep multiple Data.Map values, but there's nothing really multiply indexed.
02:38:48 <dark> maps usually are implemented as (balanced) binary trees on fp languages
02:39:03 <AmunRa> I need the reverse too though: Red : [Box1, Box2, Box7]
02:39:06 <Cale> Yeah, Data.Map is a balanced binary tree
02:39:11 <kmc> AmunRa, two Data.Map
02:39:13 <dark> Cale, what about using pairs to index?
02:39:23 <Cale> AmunRa: Yeah, typical to use two Data.Map values for that
02:39:55 <kmc> Jafet, i'm becoming less enthusiastic about Project Euler as a way to learn Haskell
02:39:57 <Cale> dark: Well, things are stored in lexicographic order, so selecting on the first part would still be easy, but not on the second.
02:39:58 <AmunRa> I need to write a module to track two collections in sync?
02:40:05 <kmc> 'cause you don't use much of the language
02:40:28 <Cale> AmunRa: Perhaps someone has done it for bijections...
02:40:54 * Jafet throws some more obvious sarcasm at kmc
02:41:02 <kmc> oh heh
02:41:11 <AmunRa> coming from C++ I guess I'm a bit spoilt with multi_index collections
02:41:13 <kmc> well people do give that as serious advice...
02:41:19 <AmunRa> thanks
02:41:23 <kmc> i've soured on it, i bet you can guess why
02:41:35 <dark> ...? what is that project euler and why this isn't advised?
02:41:43 <kmc> dark, google it
02:41:51 <kmc> it's a set of mathy programming problems
02:41:58 <kmc> most of the early ones can be done in a few lines of Haskell
02:42:04 <dark> i am with maybe 50 to 100 tabs open
02:42:11 <Cale> http://hackage.haskell.org/package/bimap
02:42:15 <kmc> and don't require any complicated IO
02:42:15 <dark> i just open things with the middle button and never close anything
02:42:35 <kmc> but you also don't use most of the cool features of Haskell in solving them
02:43:03 <ivanm> dark: it's not adviced because too many people become obsessed with it and think it's the only way of learning Haskell
02:43:26 <dark> oh
02:43:27 <kmc> it's good for the early stage where you are staring at the ghci prompt and need something to do
02:43:32 <ivanm> AmunRa: so, how goes the sun-godding? ;-)
02:43:35 <dark> :)
02:43:45 <kmc> but eventually you need to learn to write real programs not just infinite lists of fibonacci primes or whatever
02:43:50 * dark have many many things to learn. such as ruby
02:43:54 <kmc> heh
02:43:56 * dark don't know what learn first
02:43:57 <kmc> haskell is better
02:44:07 <kmc> i am of course an unbiased expert
02:44:07 <dark> o rly
02:44:10 <O_4> Heh
02:44:11 <dark> :)
02:44:25 <Jafet> Hopefully not a ruby expert
02:44:29 <Jafet> I can't stand those
02:44:35 <ivanm> eh, blackdog does both, and he prefers haskell
02:44:42 <kmc> i learned some ruby, wasn't too impressed
02:44:54 <kmc> it's a fine object oriented dynamically typed language
02:44:56 <kmc> so is Python
02:45:00 <kmc> and Python seems less weird overall
02:45:10 <O_4> Hmm, not sure I agree with that
02:45:30 <O_4> (that python is less weird)
02:45:33 <Jafet> That's because it more closely follows the weirdness of existing mainstream languages
02:45:34 <ivanm> kmc: and has more use
02:45:47 <ivanm> whereas ruby is just about all to do with web development AFAICT
02:45:51 <O_4> It does seem to be slightly more widely used.
02:45:54 <Cale> Ruby seemed less weird to me actually.
02:45:56 <kmc> like they both have first class functions... ruby *additionally* has special syntax for functions that take exactly one function parameter
02:46:10 <Jafet> That's like anti-haskell!
02:46:13 <kmc> and you have to convert between those and the usual callable object type
02:46:26 <Cale> Well, okay, that part is strange
02:46:30 <Cale> hehe
02:46:48 <dark> python is foreign to fp
02:47:02 <dark> guido even rant about how nobody cares about fp or something like that
02:47:03 <kmc> python's treatment of first class functions is pretty straightforward
02:47:06 <dark> .-.
02:47:13 <kmc> the lack of a good lambda is an obstacle but only a syntactic one
02:47:14 <dark> he deleted map
02:47:15 <dark> etc
02:47:17 <dark> etc
02:47:19 <dark> .-.
02:47:20 <Cale> Ruby seemed a bit closer to the original vision of OO, by which I mean smalltalk.
02:47:28 <kmc> i thought they just moved those to a standard library module
02:47:30 <dark> he threw away map!
02:47:31 <Ke> dynamic typing is bad
02:47:35 <Jafet> Javascript!
02:47:38 <kmc> hehe
02:47:46 <kmc> Javascript may be the world's most popular functional language
02:48:10 <Jafet> Ironically, its implementations are mutually incompatible
02:48:15 <kmc> imo the biggest problem with Python is not any part of the language, but the lack of high-quality implementations
02:48:23 <kmc> Jafet, really?
02:48:30 <ivanm> kmc: how do you define "high quality"?
02:48:33 <AmunRa> ivanm: keepin' me busy.. you see.. I originally tried writing the universe in Lisp but then realised that it's wasn't very practical.. so I rewrote it in Perl and C.. not happy with it I'm now learning haskell :-D
02:48:36 <Cale> Jafet: It's trying to copy lisp!?
02:48:36 <dark> Jafet, this have something to do with the evilness of implementators
02:48:45 <ivanm> AmunRa: heh
02:48:53 <ivanm> AmunRa: you've seen the xkcd comic I presume?
02:48:54 <Jafet> After two or three years of having to write javascript, I can say that
02:48:54 <kmc> ivanm, hmm... parallel execution of threads would be a start
02:49:01 <Jafet> Of course you can overrule me with more years
02:49:21 <ivanm> kmc: OK, so your problem is the artificial constraints within the main implementation?
02:49:22 <Jafet> Cale, wrong way round, lisp programmers are now writing javascript in lisp
02:49:28 <kmc> ivanm, and the lack of a viable alterntaive
02:49:32 <Cale> heh
02:49:36 <kmc> though we are getting there
02:49:55 <ivanm> kmc: with the moratorium helping?
02:49:58 <kmc> my problem is that CPython is really slow and does not allow parallelism by threading
02:50:05 <Jafet> Zhivago was working on a multitasking lisp to javascript compiler, wonder how that is going now
02:50:09 <kmc> we are getting there because Google is writing a JIT compiler
02:50:19 <kmc> for Python
02:50:26 <kmc> which is the only way to go for fast implementation of a dynamic language
02:50:31 <Jafet> (co-op only)
02:50:36 <kmc> Jafet, do implementations of Javascript actually disagree on the language itself?
02:50:53 <Cale> kmc: Worse than that, concurrent python programs apparently can run much slower on SMP machines than on uniprocessor machines.
02:50:58 <Jafet> kmc, quite.
02:50:58 <AmunRa> kmc: I feel your pain.. what are you trying to use Python for?
02:51:01 <kmc> Cale, wow.  due to lock contention?
02:51:06 <kmc> Jafet, how?
02:51:14 <kmc> AmunRa, various projects in the past
02:51:22 <Jafet> Oh, by language you mean ECMA 262?
02:51:24 <kmc> nothing right now
02:51:33 <Cale> kmc: In a nutshell, yes. The details are really quite amusing.
02:51:33 <kmc> Jafet... probably?
02:51:39 <kmc> i don't mean DOM and all that
02:51:39 <Cale> There's a talk about it I could find.
02:51:52 <O_4> Cale: amusing enough to elaborate on?
02:51:53 <Jafet> That's irrelevant. Plus it sounds like a weird skin disease, which is bad for marketing
02:51:58 <kmc> my guess is that various browsers implement the same language but present a different API
02:52:06 <kmc> Jafet, well, we were talking about languages
02:52:10 <Cale> http://blip.tv/file/2232410
02:53:00 <Jafet> Javascript is pretty much a DSL for making your web browser take up more CPU
02:53:11 * ivanm wishes Niklas Broberg made ANNOUNCE emails for the new haskell-src-exts so we knew what the differences were, etc.
02:53:14 <Jafet> So the interaction with the browser is a pretty important component of the language.
02:53:16 <ivanm> Jafet: heh
02:53:25 <kmc> javascript is an object oriented functional dynamic language
02:53:26 <ivanm> @remember Jafet Javascript is pretty much a DSL for making your web browser take up more CPU
02:53:27 <lambdabot> Nice!
02:53:36 <kmc> which happens to have found a somewhat loathsome niche
02:53:51 <Jafet> Oh, I think you're describing ECMAscript kmc
02:54:02 <kmc> hmm what's the difference?
02:54:40 <Jafet> Mozilla's added some language features in their implementations though
02:54:56 <kmc> also "javascript" is a stupid name
02:55:05 <kmc> Cale, i'm watching now
02:55:10 <kmc> yeah CPython doesn't have TCO either
02:55:25 <Jafet> "Javascript" is more or less a moving target for what makes your web browser consume more CPU (although in firefox this role seems to have been supplanted by CSS3)
02:55:35 <Jafet> So today it includes DOM and AJAX.
02:55:37 <kmc> hehe
02:55:53 <Jafet> Guido doesn't want TCO for cpython
02:56:03 <kmc> fuck that guy
02:56:20 <Jafet> I guess until they put it in elisp, he can point and babble all he wants
02:56:43 <kmc> heh, really?
02:56:48 <kmc> he uses elisp as a counterexample?
02:56:54 <kmc> widely regarded as the worst lisp anyone still uses
02:56:54 <Jafet> No, but I suppose he could
02:56:57 <kmc> heh
02:57:09 <Jafet> No, that would be AutoCAD lisp
02:57:12 <Adamant> kmc: tied with autolisp for MechE's that know programming
02:57:17 <Jafet> (Now with let-bindings!)
02:57:18 <kmc> hehe
02:57:22 <Adamant> Jafet: GET OUT OF MY HEAD
02:57:34 <Adamant> :P
02:57:36 <kmc> greenspun's tenth rule again
02:57:39 * Jafet invokes the escape continuation
02:59:05 <kmc> wow this guy thinks he's hot shit because he read the source of pthreads
02:59:21 <Cale> He said he's ashamed to admit it :)
02:59:29 <kmc> yeah
02:59:36 <shambler> which guy?
02:59:45 <Cale> http://blip.tv/file/2232410
03:00:11 <kmc> i like how his second slide is a disclaimer that he actually likes the awful workaround CPython uses for parallelism, and doesn't mind the GIL
03:00:36 <dark> gil?
03:00:40 <kmc> global interpreter lock
03:00:47 <dark> he=guido?
03:00:52 <Cale> no
03:00:54 <kmc> he = guy in the link Cale sent
03:01:06 <Cale> David Beazley
03:01:07 <kmc> GIL is a feature of the Python interpreter named CPython
03:01:19 <kmc> and by "feature" i mean "crippling design flaw that can never be fixed"
03:01:21 <Cale> (which is the main Python interpreter)
03:01:27 <dark> ocaml has one too
03:01:36 <dark> but it seems unavoidable
03:01:52 <dark> btw how can haskell be parallel?
03:01:56 <ivanm> kmc: so how does Greenspun's tenth apply to Haskell?
03:01:59 <ivanm> dark: how can it not be?
03:01:59 <kmc> dark, GHC has a parallel runtime
03:01:59 <dark> how can GCs synchronize?
03:02:02 <kmc> ivanm, dynamic typing of course
03:02:12 <ivanm> ahhh
03:02:13 <kmc> dark, GHC's current runtime requires all threads to stop to do GC
03:02:16 <Cale> dark: Stop the world, garbage collect everything in parallel
03:02:18 <kmc> however they all do GC in parallel
03:02:21 <dark> .-.
03:02:25 <ivanm> I find that an advantage of Haskell, not a disadvantage ;-)
03:02:38 <dark> this does not help to improve latency
03:02:40 <dark> .-.
03:02:44 <kmc> that's true :/
03:03:01 <kmc> i frequently lament that Haskell is not suitable for realtime applications
03:03:07 <ivanm> Cale: I thought 6.12 had a new parallel GC...
03:03:11 <kmc> in CPython the lock is not merely for GC, but on *every* object access
03:03:15 <Adamant> ivanm: write a basic Scheme tutorials :P
03:03:21 <kmc> GC runs in parallel with other GC
03:03:26 <Cale> dark: I might not be writing the sort of code for which it matters so much, but I've never really run into any problems with GC induced latency
03:03:26 <Jafet> There are real-time GCs, but they have overhead
03:03:47 <Jafet> Maybe one could select them at compile-time, though
03:03:54 <kmc> Cale, I write such code for work :/
03:03:57 <kmc> in C++
03:04:07 <Jafet> GC for C++?
03:04:11 * Jafet sympathizes
03:04:11 <kmc> no
03:04:15 <kmc> i write soft realtime code in C++
03:04:21 <kmc> which could not work with garbage collection
03:04:22 * Jafet also sympathizes.
03:04:31 <dark> i think that the realtime apps has much to gain for being parallel..
03:04:36 <kmc> basically it means i cannot yell at everyone to use Haskell
03:04:38 <kmc> dark, yes, absolutely
03:04:49 <kmc> i hope that stop-the-world gc goes away in a future ghc release
03:05:00 <ivanm> Adamant: why should I?
03:05:04 <Cale> I think it's something that they're looking at
03:05:04 <dark> but its hard. what to do with shared data?
03:05:14 <kmc> anyway the parallel runtime is pretty nice overall
03:05:22 <kmc> it's also one of the main things that improved from ghc 6.10 to 6.12
03:05:26 <mjrosenb> hrmm, is there any way of  referring to the type variable that is being used in an instance declaration?
03:05:33 <Adamant> ivanm: I'm saying, that's how Greenspun's Tenth applies to Haskell :P
03:05:39 <kmc> mjrosenb, by name?
03:05:42 <kmc> i don't understand the question
03:06:04 <Cale> I seem to vaguely recall reading somewhere that genuinely concurrent GC can actually be worse in some ways, but I forget what that was about.
03:06:13 <kmc> heh, this guy says pthreads are lightweight
03:06:26 <Cale> kmc: Probably by comparison :)
03:06:26 <kmc> and that greenthreading is "bogus"
03:06:30 <Jafet> It would be funny if a concurrent GC deadlocks
03:06:30 <kmc> to what?
03:06:33 <kmc> CPython uses pthreads
03:06:38 <mjrosenb> instance Foo a where  let x = foobar where foobar :: a
03:06:53 <mjrosenb> and i get
03:06:54 <mjrosenb>     Ambiguous type variable `b' in the constraint:
03:07:06 <mjrosenb> similar one for `a'
03:07:35 <mjrosenb> err
03:07:48 * mjrosenb messed up the syntax there
03:07:52 <mjrosenb> but
03:08:37 * kmc ponders implications of purity for parallel gc
03:08:43 <mjrosenb> instance Foo a where  f x = y where y = f (foobar :: a)
03:08:59 <Jafet> I bet it'll make FFIs more exciting
03:09:12 <kmc> there's some paper on concurrent FFI i've been meaning to read
03:10:00 <kmc> ultimately lazy graph reduction is based on in-place update of heap structures
03:10:20 <kmc> so purity is not so relevant at that level
03:10:26 <Cale> mjrosenb: You're trying to say that foobar should be completely polymorphic?
03:10:27 <dark> the syntax is let a = b where .. ? @.@ any reason for being verbose? (not wanting to argue about syntax, it's just that in ml it's different)
03:10:36 <kmc> dark, no
03:10:40 <kmc> "let a = b in c"
03:10:43 <kmc> is the basic let syntax
03:10:45 <kmc> iirc the same as ML
03:10:50 <kmc> plus you don't need "rec" for recursive
03:11:02 <kmc> "where" is different, it attaches to a group of bindings, not an expression
03:11:14 <kmc> used to scope some helpers over a function that's defined in tersmo f multiple equations
03:11:27 <mjrosenb> Cale: no, i am saying that foobar should have the type that i am working with in this Instance.
03:11:46 <dark> kmc, ah:)
03:11:56 <mjrosenb> my original line was not really haskell.
03:11:58 <Cale> mjrosenb: hmm... perhaps there's a way to make that work with ScopedTypeVariables
03:12:31 <mjrosenb> ahh, so type variables are not scoped.
03:12:38 <kmc> not in h98
03:12:53 <Cale> mjrosenb: In any case, free type variables in any type signature normally get automatically forall'd at the top of the signature
03:13:32 <mjrosenb> i am trying to force the classes to do all of the work for me
03:14:27 <DrTeggy> mjrosenb, that's what laziness is all about, eh? ;-)
03:14:37 <RayNbow> <Cale> http://blip.tv/file/2232410 <-- one of the mindblowing parts of that talk was that a Python interpreter "tick" can take arbitrarily long
03:14:46 <mjrosenb> i am ignoring my argument and attempting to just use its type to pass undefined into calls to myself and get the right values back
03:15:55 <Cale> mjrosenb: {-# LANGUAGE ScopedTypeVariables #-}  seems like it ought to do the trick for you
03:16:14 <Cale> You can use  undefined :: a  then
03:16:18 <mjrosenb> Cale: unfortunately, i am doing most of this stuff with hugs
03:16:41 <Cale> ah, okay
03:16:54 <mjrosenb> Cale: i also tried to explicitly type the function, but that did not seem to work either
03:17:20 <mjrosenb> as in misplaced type signature
03:17:23 <Cale> yeah
03:17:37 <Cale> for some odd reason, you're not allowed to give type signatures in instances
03:17:57 <Cale> Even if they'd be redundant, I'm not completely sure why that is.
03:18:16 <dark> what if I break a large and complex haskell program in two programs that communicate using text streams? would it be natural and work nicely, or there are shortcomings?
03:18:19 <mjrosenb> so i can just do this outside of the Instance, with the signature, then use it.
03:18:53 <povman> what: let l = length nss in l > 1 && l < 3
03:19:10 <Cale> mjrosenb: oh, you're also going to run into the problem that you're writing an instance which will overlap with everything
03:19:19 <blackh> dark: Sounds good to me. What sort of text streams?
03:19:40 <mjrosenb> Cale: the instance is actuall a -> b
03:19:41 <mjrosenb> well
03:19:48 <mjrosenb> it is actually a -> IO b
03:19:53 <dark> blackh, line-oriented protocols. just like some C gurus advise (like TAOUP)
03:19:53 <mjrosenb> which is also not h98
03:19:56 <Cale> It might help to see what you're actually writing :)
03:19:56 <mjrosenb> but
03:20:03 <mjrosenb> it really cannot be anything else
03:20:16 <dark> blackh, I know that this style has some adepts in C culture, but I don't know about its usage in FP
03:20:31 <Cale> povman: You're asking about that code?
03:20:37 <blackh> dark: Over a socket?
03:20:44 <dark> yes
03:20:55 <Cale> povman: heh, that is kind of odd
03:20:59 <povman> i think it's a bit nuts.
03:21:01 <dark> sockets are painful to work in C.. unless wrapped to a sane api
03:21:20 <Cale> povman: Perhaps at some point those magic numbers were different
03:21:36 <povman> that'd be my guess. </procrastinating>
03:22:16 <Cale> dark: It would be not as fun as just using multiple threads.
03:22:28 <Cale> (to pass streams of text between two Haskell programs)
03:22:37 <dark> :(
03:22:42 <blackh> dark: I don't know what the TAOUP method consists of, but certainly it would be doable in Haskell.
03:22:42 <Cale> Streams of text are untyped and limited in what they can represent
03:23:05 <blackh> dark: Are you more interested in the mechanics of the communication, or the design of the splitting of the Haskell program?
03:23:05 <Cale> If you keep things internal, you can use Chans, through which you can pass any Haskell values, for example.
03:23:25 <mjrosenb> Cale: http://pastie.org/763875
03:23:30 <dark> Cale, I already bought the TAOUP approach of "threads are for wimpys, let fork them all" (well this quote is new)
03:24:01 <dark> blackh, just a random question, but i am actually interested
03:24:02 <blackh> dark: The reason for this approach IMHO is to compensate for the lack of purity.
03:24:10 <dark> in how haskell programs could be modularized
03:24:45 <Cale> dark: What if the values I want to communicate are functions? I'd need to design some text representation of all the functions I could possibly want to communicate. That's doable, but a lot less fun than just shipping functions through a Chan
03:24:54 <blackh> dark: Speaking very generally, a monad is often a powerful way to abstract away the kind of split you're talking about.
03:25:19 <dark> blackh, they say: in platforms where people don't usually fork and talk in plan text, they tend to write bloated software
03:25:53 <blackh> dark: I don't quite understand that
03:25:57 <Cale> That's nonsense
03:25:58 <RayNbow> Cale: serializing functions might be interesting in a distributed setting though
03:26:06 <RayNbow> (but probably headache inducing)
03:26:27 <dark> Cale, but if i communicate functions I can't change the language of one of parts of the program, or many of it's implementation details
03:26:29 <Cale> Serialising and deserialising every value I want to communicate is more bloated than just sharing the value in memory?
03:26:48 <blackh> dark: There are some libraries for inter-process communication, but I haven't looked at them in detail.
03:26:53 <dark> Cale, they talk bloated in code sense, not in speed of run
03:27:16 <Cale> Sorry, that question was backwards.
03:27:28 <dark> as in "huge monolithic monster"
03:27:34 <Cale> It'll take more code to serialise and deserialise everything.
03:27:38 <Cale> and it will be slower
03:27:44 <mjrosenb> Cale: oh yeah, the error is:
03:27:49 <mjrosenb>     Ambiguous type variable `a' in the constraint:
03:27:49 <mjrosenb>       `Conv a' arising from a use of `typeof' at Convert.hs:17:8-30
03:28:13 <dark> well, lisp can send functions over wire (at least sometimes) and they aren't complaining about serialization, but i get your point
03:28:15 <Cale> and on top of that, far, far more error prone
03:28:26 <mjrosenb> it recommends that I add a type signature, but unless I do not know what a type signature is, I have a type signature
03:28:37 <blackh> dark: Cale is right - it is certainly easier to use threads in Haskell than an IPC approach.  Haskell hasn't reached its potential in the area of IPC.
03:29:15 <Cale> Well, one can imagine something like the Haskell RTS extended to IPC between Haskell programs (or via some API)
03:30:26 <Cale> Well, the GHC RTS specifically rather :)
03:30:34 <dark> taoup talks mainly about unix vs. windows. they say that in unix the programs are smaller and does less thing ("less bloated"), many times gui are separated from the heavy code, etc
03:30:49 <Cale> Well, there is that.
03:30:59 <dark> and that's because this 'communicate with text streams' thing
03:31:03 <mjrosenb> Cale: any ideas?
03:31:24 <kmc> dark, as far as amount of code goes, multithreading in Haskell is far less bloated than most languages
03:31:25 <Cale> It's nice to be able to combine smaller programs at the system level, however, unix isn't all that great for composability when compared with Haskell. (It's awesome compared to Windows)
03:31:53 <kmc> you spawn a thread with one function... you pass it a first-class value describing what the thread does, which can be built inline using "do" syntax or monad combinators
03:31:57 <blackh> dark: The trouble with text streams is that they are untyped. You could take a look at haxr, which implements XML-RPC
03:32:10 <poucet> Does anyone thing there'd be interested in writing a git client in haskell?
03:32:14 <kmc> you don't need to declare a class and a bunch of initialization boilerplate just to get a thread
03:32:37 <dark> kmc, but with multithreaded code the parts can't be split and run by themselves, can't easly talk with another implementations etc
03:32:46 <kmc> yes that's true
03:32:50 <Cale> mjrosenb: hmmm...
03:32:58 <Cale> actually, I may have an idea
03:32:58 <kmc> for definitions of "run by themselves"
03:33:14 <kmc> but multithreading is a powerful tool for getting concise, composable code
03:33:20 <kmc> which sounds like your concern here
03:33:53 <dark> blackh, well, those "rich" streams are considered harmful in that book (because they are generally opaque and harder to pass)
03:34:14 <blackh> dark: IPC has not received a lot of attention in the Haskell world, which is why I say the potential hasn't been reached.
03:34:14 <kmc> a Haskell program that does lots of IPC will probably also use threads internally to manage the different IPC connections
03:34:18 <dark> blackh, but maybe you are right: it's harder to do untyped communication in haskell than in c, i guess
03:34:34 <kmc> dark, not really.  Haskell supports the good old UNIX/C datatype "sequence of bytes" just fine
03:34:52 <kmc> regarding ipc and threads, e.g. we don't do much select(), because you can spawn a blocking thread for each fd
03:34:59 <kmc> so even with ipc this is a viable strategy
03:35:14 <dark> but it's not always straightforward to transform them into the preferred form of data
03:35:22 <blackh> dark: Sounds like the book comes out of the stone age to me. :)
03:35:36 <kmc> that's just because Haskell programmers are pickier about data having a preferred form
03:35:39 <dark> Hmmmmmm. @.@
03:35:49 <kmc> it would be very hard to transform those text streams into an AST in C as well
03:35:59 <dark> lisp has their "ipc" with text streams + sexp
03:36:06 <blackh> dark: I say that because they're thinking at a very low level.
03:36:06 <kmc> yes, it's beautiful
03:36:24 <dark> and this seems to work fine (maybe better than C ad-hoc protocol approach)
03:36:32 <kmc> you could use s-exprs for serialization in Haskell too
03:36:38 <kmc> not baked in as deeply
03:36:54 <dark> blackh, thinking low level has it's advantages. (eg: you don't know the next time you will have to analyze a protocol without documentation)
03:36:59 <kmc> JSON is the s-expr of the Web 2.0 crowd
03:37:13 <kmc> you know, every concept from Lisp is continually rediscovered in worse form
03:37:26 <dark> json? i vaguely recognize this acronym
03:37:36 <blackh> dark: Thinking low-level tends to reduce your productivity, though.
03:38:04 <dark> blackh, maybe the way to go isn't to think low level, but to simplify the data
03:38:15 <dark> (not always desirable though)
03:38:24 <dark> hmmm... i think i don't know what is though
03:38:42 <dark> and its relationship to thought (i guess none)
03:39:23 <kmc> Cale, heh, after dismissing green threads as "bogus", the guy proceeds to explain how putting the OS in charge of CPython's threads causes all sorts of problems
03:39:24 <blackh> dark: Small interfaces are usually a good design choice
03:39:43 <dark> small interfaces/
03:40:03 <Cale> kmc: I don't remember him saying that
03:40:09 <dark> kmc, and what is his alternative?
03:40:12 <Cale> kmc: I mean the stuff about green threads
03:40:26 <blackh> dark: Yes - in your example, you'd want to split it in such a way that you had a simple interface between your threads / processes
03:41:04 <dark> I actually would like to design a program in that way
03:41:09 <dark> any non-trivial program
03:41:18 <dark> so that I can test if I enjoy programming in this style
03:41:24 <dark> but maybe haskell could be a poor choice
03:41:59 <Cale> mjrosenb: waaaait, is (TArr x y) a value of type Type?
03:42:09 <mjrosenb> Cale: yes.
03:42:15 <Cale> mjrosenb: Is this an existential?
03:42:25 <Cale> (does Hugs have those?)
03:42:31 <kmc> Cale, it was at the beginning
03:42:54 <Drunkenmonkey> what is this
03:42:59 <mjrosenb> Cale: i do not think it is
03:43:01 <blackh> dark: If you wrote your own communication channel, you could make it strongly typed quite easily in Haskell.  I would be very surprised if Haskell was a poor choice.
03:43:05 <kmc> Drunkenmonkey, welcome to the Internet
03:43:14 <Cale> Drunkenmonkey: An IRC channel for discussing the programming language named Haskell.
03:43:18 <Drunkenmonkey> kmc: Hey, please replace all C++ code with Haskell
03:43:23 <mjrosenb> Cale: i am no entirely sure what existential is though.
03:43:30 <kmc> Drunkenmonkey, no u first
03:43:33 <Cale> mjrosenb: What's the definition?
03:43:43 <dark> blackh, but, communication in a line-oriented fashion? strongly typed? o.o
03:43:58 <Cale> mjrosenb: I'm trying to construct something I can actually plug into an interpreter of some sort here :P
03:44:07 <dark> blackh, it would what, return a maybe for the error case?
03:44:14 <blackh> dark: Yes, strongly typed.  Haskell is very good with wrapping weakly typed stuff so it's strongly typed from the external interface.
03:44:18 <mjrosenb> Cale: data Type = TArr Type Type | TVar String
03:44:26 <Jafet> dark, why don't you, uh, learn haskell
03:44:29 <Drunkenmonkey> Instead of talking endelessly about monads here why don't you people rewrtie the pacgage management system in debian/ubuntu in haskell
03:44:29 <Cale> mjrosenb: oh, right, I see, okay
03:44:34 <dark> Jafet, :)
03:44:37 <dark> Jafet, ok, ok
03:44:42 <dark> i am just talking :P
03:44:48 <kmc> Drunkenmonkey, you are not very good at this
03:45:00 <Drunkenmonkey> kmc: cuase some real trouble
03:45:02 <Jafet> There are several web servers in Haskell, see those for error management
03:45:15 <dark> (well actually ml can do this too, raising exceptions or using options)
03:45:16 <Jafet> Especially the ones in tutorials
03:45:20 <DrTeggy> Drunkenmonkey, why not come back one you're Sobermonkey?
03:45:21 <kmc> trolling is a fine art form
03:45:26 <DrTeggy> s/one/once/
03:45:29 <Jafet> ML doesn't have monads!
03:45:33 <Drunkenmonkey> DrTeggy: I bet it can't be done in Haskell
03:45:34 <kmc> it requires subtlety and finesse
03:45:34 <blackh> dark: Maybe and Either types are generally good for error handling, but exceptions are sensible in some cases
03:45:48 <dark> blackh, there are exceptions in haskell?
03:45:52 <poucet> Drunkenmonkey: Seriously, we've had far better trolls in the past.  You should research your past heroes, like gavino.
03:45:52 <Drunkenmonkey> yes
03:45:59 <kmc> @protontorpedo
03:45:59 <lambdabot> so haskells better than smalltalk and clsip?
03:46:06 * povman looks for gavino logs
03:46:07 <kmc> @HaskellLove
03:46:07 <lambdabot> Unknown command, try @list
03:46:15 <poucet> Or protontorpedo
03:46:17 <blackh> dark: Yes - I use exceptions a lot.  They work great in Haskell for certain things.
03:46:28 <povman> was HaskellLove a troll? I thought he was just a nut
03:46:28 <poucet> @protontorpedo
03:46:29 <lambdabot> The things I dotn get about relatinal databases is that they take wrok to maintain
03:46:33 <kmc> povman, fine line
03:46:46 <dark> this is news to me. in ocaml, exceptions are a imperative thing
03:46:50 <DrTeggy> This is what protontorpdeo said?  Hear, hear...
03:46:50 * poucet started a #zurihac channel for those attending zurihac
03:46:51 <kmc> dark, yes.  applying a function can throw an exception.  an exception can only be caught within the IO monad
03:46:51 <blackh> povman: I don't think HaskellLove is a troll.
03:46:57 <kmc> so yes, imperatively
03:47:08 <Cale> mjrosenb: haha, managed to disambiguate via a series of awful hacks :P
03:47:14 <Drunkenmonkey> dark: There is no reason for exceptions to be imperative
03:47:24 <mjrosenb> Cale: awesome
03:47:27 <poucet> @tell tibbe Started #zurihac.
03:47:27 <lambdabot> Consider it noted.
03:47:33 <blackh> dark: In Haskell they are an imperative thing too.
03:47:34 <kmc> the Either monad provides a more "pure" functional kind of exceptions
03:47:48 <povman> @gavino
03:47:48 <kmc> pure in that it can be implemented in vanilla Haskell
03:47:49 <lambdabot> Unknown command, try @list
03:47:54 <poucet> povman: he was mainly on the ML
03:47:56 <kmc> whereas the IO exceptions are deeper into the implementation
03:48:01 <blackh> dark: Exceptions operate in the IO monad, so they're only useful for IO-monad stuff.
03:48:07 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15478#a15478
03:48:19 <dark> so if a function throw an exception, they don't return a value at all, and instead it's up to the IO to continue the computation?
03:48:24 <kmc> dark, yes
03:48:42 <dark> haskell seems to be very beautiful
03:48:45 <Cale> mjrosenb: Basically, the solution is dead code :P
03:48:45 <Drunkenmonkey> So when will we be seeing Haskell runnin our toasters
03:48:52 <Drunkenmonkey> have anyone made the toaster monad?
03:48:59 <kmc> it's not so common for a "pure" pure function to throw an exception
03:49:02 <blackh> dark: It is possible to throw an exception from a function, but this does not mean that it's a good idea.
03:49:05 <kmc> Drunkenmonkey, you really need some trolling lessons
03:49:12 <mjrosenb> Cale: wow, that is *quite* awful
03:49:15 <theorbtwo> @src split
03:49:16 <lambdabot> Source not found. I've seen penguins that can type better than that.
03:49:21 <mjrosenb> like
03:49:24 <blackh> dark: Or more specifically, it is generally a very bad idea to throw an exception from a function.
03:49:28 <theorbtwo> @src break
03:49:28 <lambdabot> break p =  span (not . p)
03:49:32 <Drunkenmonkey> dons: wake up
03:49:36 <mjrosenb> i feel that this is more useful than having empty datatypes
03:49:59 <dark> there is a tag for functions that never throw exceptions? or functions that throw a and b exceptions
03:50:02 <blackh> dark: Haskell is brilliant! I don't think it's the perfect language, only the best language. ;)
03:50:02 <Drunkenmonkey> kmc: why do you think I am trolling
03:50:13 <Cale> @protontorpedo
03:50:13 <lambdabot> wil I make mroe $$ than learning java or APL or smalltalk or plt scheme or ruby or perl or clisp?
03:50:19 <DrTeggy> Cale, "let xs = [y,v]"... let the type checker recognize that y and v have identical types?
03:50:24 <Cale> DrTeggy: yes
03:50:27 <kmc> dark, not the simplest sort of exceptions
03:50:31 <DrTeggy> hmm
03:50:31 <kmc> there are some efforts in that direction
03:50:39 <dark> <lambdabot> wil I make mroe $$ than learning java or APL or smalltalk or plt scheme or ruby or perl or clisp? > omg
03:50:43 <kmc> dark, exceptions are i think not a big part of Haskell programming
03:50:55 <Cale> Probably a simpler way to get the same effect exists, but it was the first thing I thought of
03:50:55 <poucet> dark: protontorpedo?
03:51:15 <kmc> errors in "pure" code are generally handled through some error-handling monad
03:51:18 <blackh> dark: Exceptions are generally unchecked (though there is a library that makes them checked), but this doesn't matter too much, because you don't use them very often.
03:51:19 <Cale> Oh, at the very least you can use  return [y,v]
03:51:21 <kmc> rather than the IO-level exceptions
03:51:23 * DrTeggy tries to remember Augustsson's Equal a b trick ...
03:51:29 <theorbtwo> dark: Consider, instead of having exceptions, return either your real return value (wrapped up), or an exception thingy.
03:51:38 <dark> poucet, it was his nick?
03:51:39 <blackh> dark: ...but in certain cases, exceptions are just the right thing to use.
03:51:40 <Cale> Or yes, a new datatype expressly for that purpose
03:51:55 <dark> theorbtwo, with maybe?
03:52:05 <kmc> with Either
03:52:07 <kmc> @src Either
03:52:07 <lambdabot> Source not found. Do you think like you type?
03:52:16 <kmc> data Either a b = Left a | Right b
03:52:18 <kmc> :t Left
03:52:19 <lambdabot> forall a b. a -> Either a b
03:52:20 <kmc> :t Right
03:52:20 <lambdabot> forall b a. b -> Either a b
03:52:57 <dark> kmc, i would want something to tag if my function is pure in ocaml, maybe in the type (there is a trick to do this but it doesn't work very well @.@)
03:53:07 <kmc> dark, in Haskell every function is pure
03:53:10 <theorbtwo> The problem with Maybe is that you can't tell the caller what went wrong, just that something did.
03:53:11 <kmc> but not necessarily total
03:53:13 <dark> yes :)
03:53:17 <dark> hmmm
03:53:19 <kmc> as in, pure functions can fail to return on some inputs
03:53:27 <kmc> purists would say that makes them impure
03:53:33 <dark> so raising an exception isn't very different from a endless loop?
03:53:38 <kmc> it certainly makes their curry-howard type logic unsound
03:53:40 <kmc> dark, correct
03:53:43 <kmc> except that it can be caught
03:53:52 <kmc> but catching is not an operation of a pure function
03:53:54 <dark> ok, but turing-complete models can't avoid partial functions
03:53:56 <blackh> dark: Of all the things that Haskell gives you, I think purity is the most important.
03:54:05 <kmc> catching is an IO-recipe, which can be glued onto other IO-recipes
03:54:16 <DrTeggy> There:
03:54:17 <kmc> :t catch
03:54:18 <DrTeggy> data Equal a b where
03:54:18 <DrTeggy>     Eq :: Equal a a
03:54:18 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
03:54:28 <kmc> a `catch` (\e -> b)
03:54:43 <kmc> is a recipe which executes a, if there's an exception calls the function with argument e and executes the recipe specified by the body b
03:54:57 <Cale> mjrosenb:  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15479#a15479
03:55:04 <Cale> mjrosenb: perhaps a bit nicer
03:55:23 <DrTeggy> Cale, nice
03:55:25 <Drunkenmonkey> what a boring bunch
03:55:30 <kmc> heh
03:55:35 <kmc> cool, it worked
03:55:36 <mjrosenb> Cale: indeed.
03:55:50 <mjrosenb> Cale: i feel that we should not need to hack to get around this
03:56:11 <kmc> dark, you can do quite a lot in a non-turing-complete language :)
03:56:15 <ivanm> when did that Drunken guy come in that he thinks we're boring?
03:56:16 <povman> I'm surprised he knew about monads
03:56:43 <Cale> mjrosenb: This was actually something which was debated in Haskell 98, whether to have type variables be scoped, and it was deemed more complicated than it was worth at the time. Personally, I think it was a bit of a mistake, though not the worst one in Haskell 98.
03:56:44 <kmc> we didn't feed the troll, ergo he was bored
03:56:47 <ivanm> oh, there we are
03:56:51 <ivanm> kmc: heh
03:56:59 <ivanm> @remmeber kmc we didn't feed the troll, ergo he was bored
03:56:59 <lambdabot> I will never forget.
03:57:09 <ivanm> @vixen stop lying
03:57:09 <lambdabot> sorry, i'll stop
03:57:10 <mjrosenb> Cale: iirc, it was not fixed in 10
03:57:16 <ivanm> @vixen so you should!
03:57:17 <lambdabot> I don't think you are the one you say you are!
03:57:21 <ivanm> hmmm...
03:57:21 <povman> ivanm: that was such a typo....
03:57:22 <Cale> Haskell 2010 hardly changed anything
03:57:27 <kmc> dark, i've been recently learning Agda and Coq, both of which are non-turing-complete in interesting ways
03:57:31 <ivanm> povman: what was?
03:57:37 <dark> hmmm
03:57:38 <ivanm> oh, lying? yeah...
03:57:43 <ivanm> @wv lying
03:57:44 <lambdabot> Maybe you meant: v wn
03:57:47 <ivanm> @wn lying
03:57:47 <povman> ivanm: remmeber
03:57:50 <lambdabot> *** "lying" wn "WordNet (r) 2.0"
03:57:50 <lambdabot> lie
03:57:50 <lambdabot>      n 1: a statement that deviates from or perverts the truth [syn: {prevarication}]
03:57:50 <lambdabot>      2: Norwegian diplomat who was the first Secretary General of
03:57:50 <lambdabot>         the United Nations (1896-1968) [syn: {Trygve Lie}, {Trygve
03:57:52 <lambdabot> [31 @more lines]
03:57:56 <dark> kmc, coq can be used as a programming language?
03:57:59 <ivanm> povman: oh, that; lambdabot is smart enough to know what I mean
03:58:00 <ivanm> ;-)
03:58:13 <kmc> dark, indeed, a proof system and a dependently-typed functional language are basically the same thing
03:58:16 <ivanm> dark: IIRC it can, but not that well
03:58:16 <kmc> by the curry-howard isomorphism
03:58:27 <ivanm> (as in haskell is easier to use for programming)
03:58:28 <kmc> well, Coq is designed for programming of a certain sort
03:58:39 <kmc> it's designed that you implement your algorithms in Coq, in order to then prove them correct
03:59:14 <dark> yes i heard of it. it's not useful to write a proof that loops forever
03:59:22 <kmc> indeed
03:59:29 <Cale> and you program your proof methods, it seems :)
03:59:38 <kmc> except in the case of coinduction
03:59:46 <mjrosenb> the sad thing is that i want to have separate instances for Conv (a -> IO b) and Conv (a -> b)
04:00:01 <Cale> mjrosenb: hugs will be sad
04:00:06 <mjrosenb> indeed
04:00:11 <kmc> those overlap, but one is more specific
04:00:12 <dark> i once used isabelle: you write it your own logic, then you write a proof on this logic
04:00:12 <Cale> mjrosenb: the usual solution is newtypes
04:00:45 <dark> but i forgot all about this. there is a professor here at my university that works with isabelle (and some kind of weird logic)
04:01:17 <Adamant> HOL?
04:01:18 <kmc> there is a tool for making Haskell code into Isabelle theories
04:01:19 <ivanm> @faq Can newtypes in Haskell be used to solve all of the world's ills?
04:01:19 <lambdabot> The answer is: Yes! Haskell can do that.
04:01:20 <kmc> Haskabelle
04:01:22 <ivanm> \o/
04:01:24 <mjrosenb> Cale: so wrap a -> IO b in a newtype?
04:01:40 <Cale> yeah
04:01:43 <dibblego> Kleisli IO a b
04:02:02 <Cale> Right, it even conveniently exists.
04:02:10 <ivanm> dibblego: you love your Kleisli's, don't you...
04:02:14 <ivanm> @src Kleisli
04:02:14 <lambdabot> Source not found. I've seen penguins that can type better than that.
04:02:17 <ivanm> @type Kleisli
04:02:19 <lambdabot> forall a (m :: * -> *) b. (a -> m b) -> Kleisli m a b
04:02:22 <dibblego> not really; just pops up a lot :)
04:02:32 <mjrosenb> i suspect that this is not actually going to be any cleaner than just doing it all by hand
04:02:40 <mjrosenb> THANK YOU IO.
04:02:43 <Cale> mjrosenb: What are you trying to do?
04:02:56 <Cale> mjrosenb: Something akin to Data.Typeable?
04:03:00 <ivanm> how is the type of Kleisli recursive? :s
04:03:15 <Cale> :t typeOf
04:03:16 <lambdabot> forall a. (Typeable a) => a -> TypeRep
04:03:36 <Cale> > typeOf putStrLn
04:03:36 <mjrosenb> Cale: i have an interpreter for a language that does IO
04:03:37 <lambdabot>   [Char] -> IO ()
04:03:49 <mjrosenb> Cale: so eval :: Expr -> IO Expr
04:04:13 <mjrosenb> Cale: and i want to write builtins in haskell, and convert between haskell expressions and values in this language
04:04:20 <mjrosenb> so i was using a typeclass to convert
04:04:32 <mjrosenb> but there is that pesky IO in there
04:05:11 <mjrosenb> really annoying for something like (+) :: Int -> Int -> Int
04:05:39 <mjrosenb> which first needs to be coerced to add :: Int -> IO (Int -> IO Int)
04:05:42 <Cale> You can convert arbitrary Haskell stuff into expressions?
04:06:02 <mjrosenb> Cale: that is what this class is supposed to do
04:06:09 <Cale> hmm
04:06:14 <mjrosenb> well
04:06:19 <mjrosenb> anything that can be represented
04:06:36 <blackh> mjrosenb: There must be a way to take the IO out of that.
04:07:11 <mjrosenb> blackh: the evaluation needs to do IO sometimes
04:07:33 <Cale> What is your Expr type?
04:07:58 <Cale> I'm thinking some kind of higher-order abstract syntax?
04:08:08 <mjrosenb> Cale: yup
04:08:35 * Beelsebob wonders *why* add would return an IO (Int -> IO Int)
04:08:38 <blackh> mjrosenb: I have a design for representing text output that sometimes needs to look things up in a database.  I haven't quite got it right yet, but the general idea works: One type for IO and one type for pure. Whenever you combine them, it taints (i.e lifts to the IO type) only as needed.
04:08:43 <Beelsebob> what's input/outputty about adding?
04:08:49 <Cale> What if you were just to add a case to it for a pure function?
04:09:15 <knobo> Erik Meijer's lectures are betther at 1.5 speed :)
04:09:19 <BrianB04> Morning all.
04:09:46 <mjrosenb> Cale: i still need to call eval
04:11:01 <ivanm> BrianB04: evening
04:11:03 <ivanm> ;-)
04:11:31 <DrTeggy> knobo, "you know" ;-)
04:11:46 <blackh> mjrosenb: An arrow might work
04:11:49 <BrianB04> ivanm: Not here it ain't. knobo: Are Erik Meijer's lectures any good, or are they more abstract for academia uses of haskell?
04:12:16 <Cale> BrianB04: Well, they're directed at a bunch of C# programmers, I think?
04:12:30 <Cale> I haven't watched them
04:12:40 <mjrosenb> blackh: i have heard of these, but still have basically no clue what they are or how to use them
04:12:46 <DrTeggy> BrianB04, "academia" and "any good" do not preclude each other
04:13:33 <copumpkin> ugh
04:13:42 <blackh> mjrosenb: I spent a bit of time on an arrow tutorial in case that's helpful: http://en.wikibooks.org/wiki/Haskell/StephensArrowTutorial
04:13:50 <BrianB04> DrTeggy: Well, academia uses of a functional language could be far different from general purpose use. In other words, I don't need to know how to go through 8 million dna records to find a common pattern in all of them:)
04:14:30 <copumpkin> yeah, why learn how to think about problems when you can just learn prefab solutions so you can "get shit done"
04:14:33 <DrTeggy> Ack, BrianB04
04:14:33 <medfly> I thought people mean abstract thinking of CS when they say academia
04:15:13 <ivanm> @pl \ x -> f x || g x
04:15:14 <lambdabot> liftM2 (||) f g
04:15:33 <Cale> BrianB04: My impression of them was that he was going over language basics which would apply to any use
04:15:44 <blackh> mjrosenb: I'm suggesting you could have pure expressions and IO expressions, and make them different types.  Then make a lift function to lift pure things into IO things.  Arrows might possibly be useful, but don't quote me. :)
04:15:49 <Cale> (but you'd have to look and see)
04:16:38 <mjrosenb> blackh: and have two separate eval functions?
04:17:07 <knobo> What my impression is, is that it could be compressed down to 4 lecures.
04:17:17 <blackh> mjrosenb: Yes, that's pretty much how I would do it.
04:17:49 <blackh> mjrosenb: Of course it only works if your eval function is simple and there's some general way to lift a pure thing into an IO thing
04:17:53 <mjrosenb> blackh: i do not believe that i can ever avoid calling the IO variant
04:18:18 <mjrosenb> blackh: since to convert (+) :: Int -> Int -> Int, i need to get the initial Int
04:18:32 <mjrosenb> which is going to involve calling one version of eval
04:19:18 * knobo looking at the last lecture at doulble speed :)
04:20:03 <blackh> mjrosenb: What type is the initial Int if it's just a numeric constant?
04:20:25 <mjrosenb> blackh: the non-IO version
04:21:55 <blackh> mjrosenb: I don't have much of a handle on how your code works.
04:22:52 <knobo> When I go back to normal speed, Erik soulds realy drunk. lol
04:24:51 <BrianB04> Sorry bout that, had to go freeze for a cigarette. What I meant was I want more...Practical Haskell not Haskell for Scientists.
04:25:57 <BrianB04> And right now, I need something that goes really indepth into Monads:)
04:26:27 <blackh> BrianB04: I don't know if Erik Meijer's lectures are any good, but they do seem to be aimed at a practical level.
04:27:09 <blackh> BrianB04: Real World Haskell is pretty good for going in-depth into monads.
04:27:41 <BrianB04> Besides, if I wanted to go through 8 million dna records and find a pattern, there are some killer AI data systems I would use.
04:28:22 <blackh> BrianB04: How far have you got with monads up till now/
04:29:33 <copumpkin> monads are useless academic masturbation, don't bother
04:30:13 <Cale> copumpkin: heh
04:30:40 <BrianB04_> Bah, stupid connection
04:31:11 <ivanm> @slap copumpkin
04:31:12 * lambdabot pulls copumpkin through the Evil Mangler
04:31:21 <Cale> Monads are a decent way to structure certain libraries, but aside from that, kind of overhyped :)
04:31:47 <blackh> Monads can be useful.  BrianB04_: How far have you got with monads?
04:32:02 <copumpkin> I wasn't actually being serious
04:32:19 <Cale> copumpkin: I realise that :)
04:32:30 <BrianB04_> I still love how Real World Haskell has the hercules beetle, awesome creatures. Aside from using the I/O Monad, not very far blackh
04:32:33 <copumpkin> :)
04:32:43 * copumpkin stops trolling
04:33:22 <blackh> BrianB04_: IIRC RWH dissects a state monad.  I think that's a really good thing to look at once you've got a basic familiarity with IO.
04:33:44 <Cale> I think the list monad is a pretty good example too.
04:34:26 <mjrosenb> blackh: i vaguely remember seeing an article about arrows and semantic update combinators or something like that
04:34:36 <mjrosenb> blackh: happen to have any idea where that may be?
04:34:43 <Cale> The state monad is usually where people get a little stuck on the functional programming side of things. If you're not comfortable with functions-as-data, it can be pretty challenging to understand.
04:34:47 <blackh> mjrosenb: I don't know
04:35:08 <blackh> That's a good point, Cale. What about Reader?
04:35:30 <copumpkin> I find Maybe pretty bite-sized
04:35:41 * mjrosenb does not think of haskell as functions-as-data
04:36:08 <blackh> The thing I like about State as a way of learning monads is that it's really really easy to understand what it does.
04:36:44 <BrianB04__> I am starting to really think that Linux doesn't actually have problems with my wireless card...rather that my wireless card has issues with my network.
04:37:01 <Cale> Actually I think I properly started understanding the idea behind monads when I got to parsers.
04:37:31 <blackh> I'm probably influenced by the fact that the first monad I understood was the state monad. :)
04:37:50 <Cale> You can do them in almost any order
04:38:09 <blackh> BrianB04__: We're trying to figure out which monad is a good one to learn from. :)  Maybe you should just pick one you like the look of.
04:38:29 <HugoDaniel> the Maybe monad :P
04:38:34 <Cale> I think the list monad is good at disposing of preconceptions
04:38:41 <copumpkin> clearly he should start with Cont ;)
04:38:44 <Cale> and it's simple enough to study
04:38:59 <Cale> > do x <- [1,2,3]; y <- [4,5]; z <- [6,7,8]; return (x,y,z)
04:39:00 <lambdabot>   [(1,4,6),(1,4,7),(1,4,8),(1,5,6),(1,5,7),(1,5,8),(2,4,6),(2,4,7),(2,4,8),(2...
04:39:00 <BrianB04__> blackh: The thing that trips me up on Monadas is are things like ==> and >>?
04:39:26 <RayNbow> join might be easier to understand than bind (>>=)
04:39:27 <Cale> BrianB04__: well, this do-notation desugars into those
04:39:49 <HugoDaniel> BrianB04: those are just functions that help you thread out the sequence of actions inside your monad :P
04:39:52 <BrianB04__> Cale: Now that I understand, you are assigning the lists to x,y,z and returning a triple.
04:39:53 <blackh> BrianB04__: The trouble with monads is that even though they're not that complex, they're a bit abstract, so it's good to start with something concrete where you really understand what the purpose of it is.
04:41:03 <Cale> BrianB04__: well, x itself is just a number, but which number differs over the course of computation (or you can think of it as many-worlds sort of nondeterminism)
04:41:30 <blackh> > runState (modify (1+) >> return "finished") 100
04:41:31 <lambdabot>   ("finished",101)
04:41:33 <Cale> Written using >>= instead, we have:
04:41:38 <Cale> @undo do x <- [1,2,3]; y <- [4,5]; z <- [6,7,8]; return (x,y,z)
04:41:39 <lambdabot> [1, 2, 3] >>= \ x -> [4, 5] >>= \ y -> [6, 7, 8] >>= \ z -> return (x, y, z)
04:42:24 <Cale> Basically, >>= takes a computation of whatever sort we're dealing with on the left (in this case, our lists, representing many possible values), and a function on the right
04:43:01 <Cale> which essentially says how to proceed from the result of that computation
04:43:12 <Cale> another, simpler example
04:43:22 <Cale> do x <- getLine; putStrLn x
04:43:24 <Cale> becomes
04:43:30 <Cale> getLine >>= \x -> putStrLn x
04:43:32 <Cale> or just
04:43:35 <Cale> getLine >>= putStrLn
04:43:59 <Cale> This is describing an IO action which gets a line of text from the user and prints it back out
04:44:01 <blackh> >>= is the 'stuff it into' operator
04:44:37 <blackh> or maybe it's the 'pull it out of and stuff it into' operator
04:44:51 <BrianB04__> Cale: Oh, I see. So similar to say the << in C++...kinda.
04:44:54 <Cale> The idea is that many libraries have an operation like this >>= (and like return, which takes a value and produces a computation which "does nothing" and returns that value)
04:45:04 <povman> imo there needs to be a #haskell-monads
04:45:25 <Cale> So monads abstract over this common pattern, and we have some code which works in any monad
04:45:29 <Cale> :t sequence
04:45:30 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
04:46:06 <Cale> sequence takes a list of m-computations (whose result has type a), and produces a single computation whose result is a list of values of type a
04:46:35 <Cale> and it does the obvious thing, producing a computation which "does" each of them in turn
04:47:11 <Cale> So in the IO monad, this means it produces the IO action which executes each of the IO actions from the list in turn, producing a list of the results
04:47:22 <Cale> Or in a parsing monad, it's the concatenation of a bunch of parsers
04:47:37 <Cale> Or in the list monad, "running" a list means picking an element from it in all possible ways
04:47:57 <Cale> So sequence produces a list of all the ways to pick an element from each of the lists
04:48:01 <scree_> > sequence [[1,2,3],[4,5,6],[7,8,9]]
04:48:03 <lambdabot>   [[1,4,7],[1,4,8],[1,4,9],[1,5,7],[1,5,8],[1,5,9],[1,6,7],[1,6,8],[1,6,9],[2...
04:48:30 <Cale> So we have this one piece of code, and it works in all these different contexts
04:49:33 <Cale> That's really the point of abstracting over monads. If you were only ever to use one monad, or if you were to never write code which worked in more than one monad, it would be pointless.
04:49:51 <Cale> But we have some nice libraries of functions which are at least potentially useful in any monad.
04:52:20 <HugoDaniel> Cale: i really enjoy reading you... things get suprisingly simpler :)
04:52:43 <copumpkin> if you read long enough you'll understand all of math with no effort at all
04:52:48 <copumpkin> it's pretty good
04:52:49 <medfly> HugoDaniel: you should try asking him about mathematics
04:52:53 <scree_> imo the extra functions take back seat to consistency of notation
04:53:47 <scree_> you don't have to learn the twenty new combinators for every new library, 'cos they turn out to be return and >>= in disguise
04:53:49 <Codex_> So, if I have an adjunction with hom and product, can I get a monad out of it? :)
04:54:56 <Codex_> I mean, where our currying monad?
04:54:57 <ivanm> scree_: well, prettified, simplified and doing various things for you
04:55:30 <ivanm> since why re-invent the wheel and re-write liftM each time for example?
04:56:39 <scree_> ivanm: sorry, I'm not knocking the actual monad functions like liftM
04:57:04 <scree_> ivanm: just all the operator noise people used to invent before they could say "holy crap, it's a monad"
04:57:06 <ivanm> OK, what are you talking about?
04:57:20 <ivanm> care to provide an example?
04:57:36 * hackagebot upload: fclabels 0.4.2 - First class accessor labels. (SebastiaanVisser)
05:00:48 <scree_> didn't old parsec have a load of home-grown operators?  someone shout me down if I'm talking nonsense
05:01:39 <ivanm> well, as I was intimating earlier, it probably had a whole bunch of operators written aroudn the monadic functions to make it _easier to use_
05:01:54 * ivanm has never used parsec
05:01:59 * Botje looks for the "your own operators: care and feeding" manual
05:02:22 <Jafet> Operator operator
05:02:42 <copumpkin> some of the Alternative (refinement of Applicative) helpers were duplicated in many parser combinator libraries I think
05:02:44 <copumpkin> or at least
05:02:56 <copumpkin> (probably because Alternative appeared later)
05:03:13 <ivanm> Jafet: heh
05:03:28 <povman> If I have a library in which most functions are IO, but I have a good way of sandboxing them, is it a good idea to use ST and unsafeIOToST?
05:03:29 <ivanm> copumpkin: yeah, dind't yi have a similar problem semi-recently?
05:03:41 <copumpkin> not sure
05:03:58 <Jafet> (That's strange, I didn't mean it to be funny)
05:03:59 <copumpkin> povman: why unsafeIOToST?
05:04:44 <copumpkin> povman: what kind of functions are they?
05:05:10 <povman> evil foreign imported functions
05:05:21 <copumpkin> well yeah
05:05:31 <Stalafin> waddup! :D so... i need a clarification... what is g ( f x y z ) equal to? (g, f functions, x, y, z variables)
05:05:52 <medfly> g . f $ x y z
05:05:54 <medfly> I think
05:06:09 <copumpkin> povman: I mean, what makes you think ST is a good fit for them? do you need to use them in an imperative manner but are able to pull a deterministic result out of them?
05:06:21 <ivanm> povman: isn't the "evil" superfluous here? ;-)
05:06:28 <ivanm> *there
05:06:30 <Stalafin> medfly: no, it's not, unfortunately
05:06:35 <medfly> :-(
05:07:00 <Stalafin> g ( f x y z) compiles, whereas g. f $ x y z does not
05:07:05 <ivanm> @pl \ x y -> g (f x y)
05:07:06 <lambdabot> (g .) . f
05:07:12 <ivanm> @pl \ x y z -> g (f x y z)
05:07:13 <lambdabot> ((g .) .) . f
05:07:22 <povman> medfly: you're trying to apply x to y
05:07:34 <medfly> okay, g $ f x y z?
05:07:53 <medfly> I'm not the one asking the question!
05:07:58 <povman> Stalafin: That's an odd question.
05:08:09 <Stalafin> povman: thank you
05:08:11 <Stalafin> why?
05:08:15 <ivanm> @pl \ x y z -> g (f x y z) -- Stalafin
05:08:15 <lambdabot> ((g .) .) . f
05:08:25 <Cale> Stalafin: they don't mean the same thing
05:08:51 * medfly mutters something about Haskell being a crappy language.
05:08:59 <ivanm> @slap medfly
05:09:00 * lambdabot throws some pointy lambdas at medfly
05:09:02 <Cale> g . f $ x y z  means to apply the function  g . f  to the result of applying the function  x to parameters y and z
05:09:22 <medfly> stop pointing out my errors! I am already aware
05:09:23 * medfly slaps Cale
05:09:26 <povman> copumpkin: I have some IO functions which have no side-effects
05:09:28 <Cale> huh?
05:09:38 <Cale> I wasn't referring to anything that medfly wrote
05:09:39 <povman> Cale: medfly is embarrassed
05:09:55 <copumpkin> povman: do they need to be used imperatively too?
05:09:56 <Cale> (I hadn't read that far yet, actually)
05:10:04 <copumpkin> povman: otherwise, just make a pure function out of them
05:10:07 <Stalafin> Cale: ok, understood
05:10:12 <povman> copumpkin: unsafeperformIO?
05:10:17 <Cale> Oh, I see
05:10:21 <BrianB04> Okay, network issue seems to be fixed.
05:10:24 <Stalafin> Cale: so how do express that g is to be applied to the result of applying f to x y z
05:10:28 <copumpkin> povman: yeah, or just do a foreign import without the IO
05:10:45 <Cale> g $ f x y z, or just what you wrote originally
05:10:49 <Cale> or...
05:10:54 <Stalafin> but it fails
05:11:06 <Cale> You do mean applying f to 3 parameters and not 1, right?
05:11:11 <Stalafin> yeah
05:11:23 <BrianB04> Ah, there is another thing I don't know about: What is the $ in Haskell?
05:11:31 <copumpkin> @src ($)
05:11:32 <lambdabot> f $ x = f x
05:11:42 <ivanm> BrianB04: low level binding for function application
05:11:50 <Cale> BrianB04: It's very low precedence
05:12:02 <ivanm> BrianB04: it's used when you're using a whole bunch of other operators (usually . for function composition)
05:12:03 <Cale> low-level would be a strange way to put it ;)
05:12:13 <ivanm> Cale: bah, you know what I mean ;-)
05:12:16 <Jafet> $ is us being optimistic about Haskell in industry
05:12:28 <povman> copumpkin: erh it's late, thanks
05:12:34 <BrianB04> Jafet: Don't limit yourself then, use $$$$$
05:12:38 <copumpkin> np
05:12:49 <Jafet> :t ($) ($)
05:12:50 <lambdabot> forall a b. (a -> b) -> a -> b
05:12:51 <ivanm> BrianB04: for example, if we wanted to add one to a number and then double it, this won't work: (*2) . (+1) x
05:12:55 <copumpkin> > let ($$$$$$$$$$$) = id in (+1) $$$$$$$$$$$ 5
05:12:56 <lambdabot>   6
05:12:56 <BrianB04> Or just call Haskell Ha$kell....
05:13:11 <ivanm> because of how (.) is defined, it expects the RHS to be a function, but in this case it isn't
05:13:36 <ivanm> so we use $ to finally "apply" the function we've created using .
05:13:42 <ivanm> > (*2) . (+1) $ 4
05:13:43 <lambdabot>   10
05:13:46 <ivanm> BrianB04: ^^
05:13:46 <Jafet> Let's use s-expressions and avoid these complicated operators
05:13:52 <ivanm> @slap Jafet
05:13:53 * lambdabot slaps Jafet
05:13:58 <medfly> what are s-expressions
05:14:04 <ivanm> medfly: what lisp uses
05:14:11 <Cale> Stalafin: anyway, it must be failing for some other reason
05:14:17 <ivanm> (+ 1 2) for example
05:14:20 <Cale> Stalafin: what's the actual expression?
05:14:21 <medfly> > (*2) ((+1) 4)
05:14:22 <lambdabot>   10
05:14:30 <medfly> wait, not enough
05:14:31 <Jafet> > ((+) 1 2)
05:14:31 <ivanm> medfly: yes, but that's fugly ;-)
05:14:32 <lambdabot>   3
05:14:34 <BrianB04> (defun blah (name) (print (str "Hello" name)))
05:14:35 <medfly> > ((*2) ((+1) 4))
05:14:36 <lambdabot>   10
05:14:41 <medfly> better
05:14:51 <povman> medfly: (this (is (what (lisp ((looks)) (like because (it uses (sexpressions)))))) () ()
05:14:59 <Jafet> Brian, not format? Wimp
05:15:02 <copumpkin> mmm sexpressions
05:15:08 <ivanm> povman: do you really need the double parens around "looks"?
05:15:17 <Stalafin> Cale: b = 1/2 * sqrt (lawCos  a a alpha)
05:15:18 <BrianB04> Jafet: Hey, str takes all the arguments and merges them into a string, so :P
05:15:19 <Stalafin> Cale: this works
05:15:28 <povman> ivanm: the second one was for radiance
05:15:32 <ivanm> Stalafin: I'm guessing the / is playing up there
05:15:35 <Cale> Stalafin: okay
05:15:37 <ivanm> povman: wtf?
05:15:43 <Stalafin> ivanm: / ?
05:15:44 <medfly> I think this might be valid lisp, is it?
05:15:46 <Stalafin> Cale: what / ?
05:15:50 <ivanm> Stalafin: oh, that's the one that works...
05:15:55 <Stalafin> i mean ivanm *
05:15:56 <ivanm> Stalafin: the / in 1/2 ;-)
05:16:00 <Jafet> Valid lisp is not the same as valid sexpression
05:16:01 <Stalafin> oh
05:16:01 <Cale> Stalafin: note that $ has lower precedence than *
05:16:08 <Jafet> (Thanks for correction copumpkin)
05:16:16 <Cale> So if you were to write 1/2 * sqrt $ lawCos a a alpha
05:16:17 <copumpkin> what did I correct?
05:16:19 <Stalafin> Cale: yeah, but i had 1/2 * g $
05:16:23 <Jafet> Spelling
05:16:24 <BrianB04> My favorite has always been something like this, in lisp (+ 2 (* 3 (+ 4 (*6 5))))
05:16:28 <Stalafin> Cale: that fails
05:16:29 <Cale> it would mean  (1/2 * sqrt) (lawCos a a alpha)
05:16:32 <ivanm> Jafet: yeah, you're trying to say that copumpkin got something _right_?!?!?! :o
05:16:34 <Cale> which is an obvious type error
05:16:36 <Stalafin> Cale: oO
05:16:43 <copumpkin> damn, if I got something right I did it by mistake
05:16:47 <ivanm> BrianB04: inverse RPN + parens?
05:16:49 <Stalafin> Cale: gna, this is so bloody complicated xD
05:16:49 <Cale> (you're multiplying the sqrt function by 1/2)
05:16:56 <medfly> ivanm: this must be lisp!
05:17:04 <povman> BrianB04: in haskell that would be ((+) 2 ((*) 3 ((+) 4 ((*) 6 5))))
05:17:06 <Cale> You could write  (1/2 *) . sqrt $ lawCos a a alpha
05:17:14 <Jafet> .oO( inverse reverse Polish notation? )
05:17:15 <Cale> But I'd just leave the original
05:17:17 <BrianB04> ivanm: I have no issue with inverse RPN, just the sheer amount of parens to do that simple of a calculation
05:17:24 <medfly> > (+2) . (*3) . (+4) . (*6) $ 5
05:17:26 <lambdabot>   104
05:17:30 <ivanm> Stalafin: in that case, it might be cleaner just to wrap the lawCos with parens
05:17:35 <medfly> >((+) 2 ((*) 3 ((+) 4 ((*) 6 5))))
05:17:37 <medfly> > ((+) 2 ((*) 3 ((+) 4 ((*) 6 5))))
05:17:39 <lambdabot>   104
05:17:41 <ivanm> BrianB04: that was my point
05:17:51 <BrianB04> ivanm: In fact, I rather like inverse RPN.
05:18:02 <Ke> RRPN
05:18:06 * ivanm doesn't
05:18:08 <ivanm> Ke: heh
05:18:16 <BrianB04> Prefix notation.
05:18:20 * copumpkin likes upside-down polish notation
05:18:22 <Cale> That's just polish notation ;)
05:18:27 <dark> 'polish' notation
05:18:27 <povman> (5 * 6 + 4) * 3 + 2 -- i prefer medfly's
05:18:50 <Jafet> (defmacro infix-syntax ...
05:19:14 <BrianB04> That is the other thing I like about lisp: Macros...but anyway...
05:19:16 <idnar> how about reverse hungarian notation? ;)
05:19:19 <povman> @pl \x -> (x*6+4)*3+2
05:19:20 <lambdabot> (2 +) . (3 *) . (4 +) . (6 *)
05:19:33 <Jafet> idnar, :t output
05:19:43 <dark> (infix-syntax 1 + 1) is an improvement?
05:19:55 <BrianB04> "string" print .
05:20:16 <dark> (2 +) . (3 *) . (4 +) . (6 *) is legal on haskell?
05:20:23 <Cale> dark: yes
05:20:30 <povman> > (2 +) . (3 *) . (4 +) . (6 *) $ 5
05:20:31 <Cale> dark: It's the composite of those functions
05:20:31 <lambdabot>   104
05:20:37 <BrianB04> Why wouldn't it be, it's basically currying.
05:20:39 <dark> hmmm :)
05:20:50 <ivanm> preflex: seen pozic
05:20:50 <preflex>  pozic was last seen on #haskell 2 days, 20 hours, 44 minutes and 6 seconds ago, saying: Systems like Coq separate the two.
05:21:05 <dark> why not (2 +) (3 *) (4 +) (6 *) ?
05:21:08 <Cale> Well, the operator sections are technically a special case in the syntax
05:21:35 <Cale> dark: because that would mean "apply the function (2 +) to the parameters (3 *),  (4 +), and (6 *)"
05:21:46 <dark> ah
05:22:40 <copumpkin> you could make that work with some nasty hackery
05:22:41 <Cale> I occasionally wonder if we have it the wrong way around, and function composition should be given the nicer syntax, but this way works reasonably well :)
05:22:44 <Stalafin> Cale: alright.... so can you maybe explain this thing to me? (1/2 *) . sqrt $ ? what exactly is that dot?
05:22:54 <Cale> Stalafin: function composition
05:22:59 <Cale> (f . g) x = f (g x)
05:23:12 <Stalafin> Cale: so 1/2 * is a function?
05:23:16 <Cale> yep
05:23:21 <Stalafin> jesu
05:23:22 <Cale> (1/2 *) is anyway
05:23:23 <Stalafin> s
05:23:27 <Cale> > (1/2 *) 12
05:23:28 <lambdabot>   6.0
05:23:34 <Stalafin> > 1/2 * 12
05:23:35 <lambdabot>   6.0
05:23:37 <Stalafin> o
05:23:38 <Cale> > map (1/2 *) [1..10]
05:23:39 <lambdabot>   [0.5,1.0,1.5,2.0,2.5,3.0,3.5,4.0,4.5,5.0]
05:23:39 <Stalafin> oO
05:23:56 * Stalafin is crying.
05:24:04 <Cale> Not making sense?
05:24:08 <Stalafin> kinda
05:24:13 <Stalafin> it's just... weird
05:24:15 <dark> > (let a = + in 10 a) 2
05:24:16 <lambdabot>   <no location info>: parse error on input `+'
05:24:18 <dark> > (let a = (+) in 10 a) 2
05:24:20 <lambdabot>   Ambiguous type variable `a' in the constraint:
05:24:20 <lambdabot>    `GHC.Num.Num a'
05:24:20 <lambdabot>      aris...
05:24:31 <dark> > (let a = (+) in 10 +) 2
05:24:33 <lambdabot>   <no location info>: parse error on input `)'
05:24:36 <povman> Stalafin: it works the other way as well: (* 1/2) 12
05:24:37 <mjrosenb> it would be *awesome* if precedence rules still applied
05:24:38 <dark> .-.
05:24:42 <povman> > (* 1/2) 12
05:24:43 <lambdabot>   The operator `GHC.Num.*' [infixl 7] of a section
05:24:44 <lambdabot>      must have lower prece...
05:24:53 <dark> > (+ 10) 2
05:24:54 <lambdabot>   12
05:25:02 <Cale> dark: Functions written with alphanumeric symbols use prefix notation
05:25:11 <dark> > ((let a = (+) in a) 10) 2
05:25:12 <Cale> > let a = (+) in a 5 6
05:25:13 <lambdabot>   12
05:25:13 <lambdabot>   11
05:25:19 <idnar> > (let a = (+) in (`a` 10)) 2
05:25:21 <lambdabot>   12
05:25:22 <idnar> but that's just silly
05:25:26 <dark> > (let (!!!) = (+) in 10 !!!) 2
05:25:27 <lambdabot>   <no location info>: parse error on input `)'
05:25:50 <RayNbow> > let (!!!) = (+) in (10!!!) 2
05:25:51 <lambdabot>   12
05:25:53 <idnar> well, I suppose it's not completely silly
05:26:07 <dark> jmmm o.o
05:26:13 <dark> > (let (!!!) = (+) in !!! 10)  2
05:26:15 <lambdabot>   <no location info>: parse error on input `!!!'
05:26:17 <dark> > (let (!!!) = (+) in (!!! 10))  2
05:26:18 <lambdabot>   12
05:26:20 <medfly> > map (\n-> n * 1/2) [1..10]
05:26:22 <lambdabot>   [0.5,1.0,1.5,2.0,2.5,3.0,3.5,4.0,4.5,5.0]
05:26:30 <Stalafin> dark: wtf is that?
05:26:31 <b0fh_ua> Hello! I am trying to figure out how to create functors for an arbitrary data type. I've created the simple example as the one: http://pastebin.com/d47c4fbfa and now I'm lost. Looks like I did a lot of wrong things, but I can't figure which ones :( Can somebody please advice?
05:26:32 <Cale> Stalafin: So if (1/2 *) is the function which multiplies by 1/2, then  (1/2 *) . sqrt  is the function which takes the square root and then multiplies by 1/2
05:26:37 <medfly> @pl (\n->n * 1/2)
05:26:38 <lambdabot> (/ 2)
05:26:47 <Cale> Stalafin: and then we use $ to apply that function to the rest
05:26:54 <Stalafin> Cale: alright, interesting
05:27:05 <dark> hmmm maybe the let syntax in ml is different, regarding the need of ()s
05:27:27 <dark> the precedence of let over other syntax forms
05:27:41 <Cale> dark: operator sections require parens
05:27:45 <povman> b0fh_ua: f :: a -> a but you're applying it to the String
05:27:49 <dark> (let a = b in c) n is the natural in ml
05:28:06 <Cale> That is, in these (3 +) and (+ 4) things, the parens aren't optional
05:28:08 <povman> er, f :: a->b
05:28:11 <dark> let a b in (...) n seems to be the way to do it in haskell
05:28:24 <Cale> yeah
05:28:25 <Botje> b0fh_ua: your fmap is not structure-preserving
05:28:37 <povman> b0fh_ua: That's not what fmap is meant for
05:28:40 <b0fh_ua> povman: I thought that I'm passing MyNewData and getting string back
05:28:50 <dark> it's strange @_@''' it prefers to extend the in part
05:28:54 <Cale> dark: let already uses maximal munching
05:28:56 <dark> hmm odd
05:29:10 <Cale> Of course it would, why wouldn't it?
05:29:33 <povman> b0fh_ua: fmap takes a function which converts anything into anything else, but you're making it take a String and return String
05:29:35 <dark> well the ml parser works in a different way (i am still getting used)
05:29:37 <Botje> fmap should return something of type MyNewData b
05:29:40 <Cale> Besides, (let foo = bar in f) x y z is the same thing as without the parens
05:29:45 <b0fh_ua> povman: am I correct if guess that fmap should return MyNewData but with different type for first element in structure?
05:29:54 <Cale> Well, hmm
05:30:07 <Cale> I suppose that if foo occurs free in y or z then it's different
05:30:14 <povman> b0fh_ua: it would make sense if you had fmap f myNewData = f . getA $ myNewData
05:30:14 <Cale> But shadowing stuff is evil.
05:30:18 <b0fh_ua> povman: the main idea is to pass MyNewData instance and get the String back
05:30:25 <povman> and putStrLn . fmap (++ " there") $ MyNewData "1" "Hello"
05:31:41 <b0fh_ua> well, okay. May be I should try to explain what I'm trying to get in English :)
05:31:44 <povman> b0fh_ua: You can think of Functor types as containers which hold something, which can be mapped into containers which hold something else
05:32:17 <Cale> dark: Are the parens required in ML?
05:32:41 <povman> b0fh_ua: your MyNewData holds type 'a', so the f in fmap must take type 'a' as input
05:32:41 <b0fh_ua> I want to create functor, which can extract second property from MyNewData instance and apply a function to it.
05:33:03 <dark> in ml let q in c d is parsed as let q in (c d)
05:33:04 <b0fh_ua> povman: it holds 2 types - a and String, I thought
05:33:05 <mjrosenb> does haskell have any library like a work queue?
05:33:16 <dark> in haskell it seems to be (let q in c) d
05:33:19 <dark> right?
05:33:30 <Cale> no, it's the same
05:33:39 <Cale> the in part extends as far as possible
05:33:41 <povman> b0fh_ua: No, because it is only parametrised on the a... see    data MyNewData a
05:33:55 <povman> b0fh_ua: you're saying MyNewData is a container for type a
05:33:56 <dark> hmm ah yes
05:34:12 <dark> ok in ml let q in (c d) e could be written as (let q in c d) e
05:34:16 <dark> but i cant here
05:34:26 <povman> b0fh_ua: it just happens to also have a String, but that's fixed
05:34:29 <b0fh_ua> povman: okay, but there're two properties in MyNewData ?
05:34:30 <dark> > let a = 1 in (+ 1) 2
05:34:31 <lambdabot>   3
05:34:38 <dark> > (let a = 1 in + 1) 2
05:34:39 <lambdabot>   <no location info>: parse error on input `+'
05:34:42 <povman> b0fh_ua: the fmap must operate on the parameterised type
05:34:44 <dark> > (let a = 1 in (+) 1) 2
05:34:45 <lambdabot>   3
05:34:46 <Cale> dark: right, because that's the same as  let q in ((c d) e)
05:34:51 <dark> Hmmmm
05:35:03 <dark> he seems to be confused with the =
05:35:04 <dark> +
05:35:04 <Botje> b0fh_ua: the type for fmap is (a -> b) -> MyNewData a -> MyNewData b
05:35:15 <dark> > (let a = 1 in 1 (+)) 2
05:35:16 <lambdabot>   Ambiguous type variable `a' in the constraint:
05:35:16 <lambdabot>    `GHC.Num.Num a'
05:35:16 <lambdabot>      aris...
05:35:21 <dark> but in this case
05:35:25 <povman> b0fh_ua: You probably don't want a functor for what you're trying to do
05:35:26 <dark> > let a = 1 in (1 (+)) 2
05:35:28 <lambdabot>   Ambiguous type variable `a' in the constraint:
05:35:28 <lambdabot>    `GHC.Num.Num a'
05:35:28 <lambdabot>      aris...
05:35:32 <dark> > let a = 1 in (1 +) 2
05:35:34 <lambdabot>   3
05:35:39 <dark> > (let a = 1 in 1 +) 2
05:35:40 <lambdabot>   <no location info>: parse error on input `)'
05:35:44 <b0fh_ua> povman: I know, I just learning things :)
05:35:52 <dark> ;-;
05:36:02 <Cale> hmm, that last one is a curious corner case
05:36:09 <Cale> > ((let a = 1 in 1) +) 2
05:36:10 <lambdabot>   3
05:36:11 <povman> b0fh_ua: Try writing an fmap which modifies getA
05:36:13 <b0fh_ua> Botje: so fmap can't take MyNewData and produce String?
05:36:15 <dark> but ok, they are the same Cale, it's just that ocaml doesn't have this
05:36:19 <dark> (1 +)
05:36:42 <b0fh_ua> like (a->b) -> MyNewData a -> b ?
05:36:43 <Cale> (1 +) = (\x -> 1 + x)
05:36:51 <Botje> b0fh_ua: no. never.
05:37:05 <b0fh_ua> okay, so I wanted something really strange
05:37:05 <Botje> that's the contract you sign when you agree to be a functor :)
05:37:08 <Cale> Or just (+) 1
05:37:23 <b0fh_ua> and fmap can operate on same data types with different type parameters
05:37:27 <Cale> But the other section, it has no choice but to use lambda
05:37:46 <Cale> (+ 1) = (\x -> x + 1)
05:37:54 <Cale> I suppose it could also use  flip (+) 1
05:38:06 <dark> > (\x y -> x + y) 1 2
05:38:08 <povman> b0fh_ua: that's right! it takes a type with one parameter, and returns a type with a maybe different parameter
05:38:08 <lambdabot>   3
05:38:10 <Cale> (when desugaring)
05:38:19 <dark> i liked the syntax :)
05:38:27 <povman> > fmap show [1,2,3,4] -- b0fh_ua
05:38:29 <lambdabot>   ["1","2","3","4"]
05:38:33 <dark> > (\ x y -> x + y) 1
05:38:35 <lambdabot>   {-3->-2;-2->-1;-1->0;0->1;1->2;2->3;3->4}
05:38:46 <dark> @.@
05:38:47 <lambdabot> Maybe you meant: . @
05:38:48 <Cale> clever Show instance
05:38:48 <b0fh_ua> povman: okay, that's clear now, thanks
05:39:23 <Cale> dark: lambdabot has some additional packages loaded up which define instances of the Show typeclass for functions and other things
05:39:28 <b0fh_ua> povman, Botje : btw may be you could suggest how to write pattern match for myNewData ?
05:39:33 <dark> ^^
05:39:39 <b0fh_ua> on line 6 in the pastebin listing
05:39:40 <dark> \ was a wise choice of keyword
05:40:43 <povman> b0fh_ua: you could write fmap f myNewData = f . getA $ myNewData
05:41:00 <Cale> dark: Yeah, it's easy to type, and makes it easy to parse lambdas with multiple parameters
05:41:07 <copumpkin> povman: that wouldn't have the right type, I don't think
05:41:09 <Cale> \x y z -> ...
05:41:42 <povman> copumpkin: ?
05:41:43 <dark> and i love that -- comment
05:41:53 <dark> but there are block comments?
05:42:10 <Cale> {- block comments {- can even be nested -} like this -}
05:42:58 <povman> b0fh_ua: or even fmap f = f . getA
05:43:09 <Botje> povman: no. that type is wrong.
05:43:30 <dark> :)
05:43:40 <povman> Botje: why?
05:43:46 <copumpkin> povman: reduce it further to fmap = (. getA) :P
05:43:54 <Botje> b0fh_ua: fmap f MyNewData{getA=a, getB=b} = MyNewData{getA = f a, getB=b}
05:44:00 <povman> that's far too confusing :)
05:44:12 <povman> oh der, yeah sorry
05:44:14 <copumpkin> povman: anyway, you'd need to wrap it up in the data gain
05:44:17 <copumpkin> *again
05:44:23 <povman> stupid records
05:44:41 <Botje> bor: fmap f (MyNewData a b) = MyNewData (f a) b
05:44:46 <Botje> *or:
05:44:49 <dark> I once wrote a program that I wanted to be as functional as possible. So it had some threads that kept received as parameter a global table. Then I needed a thread to change this table. So I made the receiving thread to check for a message every cycle (it was a recursive functions that kept doing tail calls)
05:44:53 <povman> the other day i really wanted to write map ({ x = m x })
05:45:02 <dark> i think i did a bad design
05:45:16 <Botje> mutable state! aargh!
05:45:25 <Cale> dark: Also, there's literate Haskell, where things are comments by default and only lines starting with "> " or between \begin{code} and \end{code} are code
05:45:54 <povman> or um map ({ x = m . x })
05:46:01 <dark> the program after a while was no fun anymore and since i had no reason to do it other than my own amusement i stopped it
05:46:13 <b0fh_ua> Botje: thanks
05:46:16 <dark> Cale, hmm o.o just like this irc log?:)
05:46:16 <b0fh_ua> awesome :)
05:46:20 <b0fh_ua> so simple
05:46:25 <Cale> dark: sort of, yes :)
05:46:39 <Cale> dark: though you're expected to put declarations and not expressions of course
05:47:30 <povman> imo fmap f = { getA = f . getA }
05:47:46 <Cale> dark: But it's useful for on the web or email, you can write something which also just happens to be a Haskell program.
05:49:14 <Cale> and the \begin{code} ... \end{code} is a provision for making things go smoothly with LaTeX :)
05:49:50 <Cale> So you can write papers which are their own source code :)
05:49:50 <b0fh_ua> Botje: what if I want to apply that functor to a list? I should change instance declaration somehow?
05:51:05 <copumpkin> b0fh_ua: I wouldn't say applying a functor to a list :)
05:51:22 <copumpkin> b0fh_ua: the functor is the list type constructor itself!
05:51:26 <Botje> "apply that functor to a list" ?
05:51:31 <Botje> can you say it in code?
05:51:50 <copumpkin> applying the list functor to [a] gives you [[a]]!
05:52:13 <b0fh_ua> Botje: I want to have something like [MyNewData a] -> [MyNewData b]
05:52:32 <copumpkin> :t \f -> fmap (fmap f)
05:52:33 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f1 (f a) -> f1 (f b)
05:52:57 <Axman6> b0fh_ua: a functor is something of type f a, (where f may be [], Maybe, Either b, IO), which can have a function of type a -> b applied to it, with the use of fmap, and turn it into something of type f b
05:53:08 <Botje> b0fh_ua: then you can use map (fmap f)
05:53:16 <Botje> or fmap (fmap f) if you want
05:53:20 <copumpkin> Axman6: the functor is actually just the f there
05:53:22 <Botje> since map === fmap for lists
05:53:53 <Axman6> copumpkin: well yess, but it's sometimes hard for people to see what you're on about when you start getting too correct :P
05:54:01 <copumpkin> :)
05:54:48 <povman> :t (.) . (.)
05:54:49 <b0fh_ua> okay, but can I create a functor for list of type MyNewType a so it will convert that list to the one of items with type MyNewType b?
05:54:49 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
05:54:52 <povman> :)
05:55:50 <povman> b0fh_ua: List is already a functor, it already does that
05:56:06 <povman> you can go fmap f [1,2,3,4]
05:56:17 <Botje> b0fh_ua: lists are already functors.
05:56:21 <Botje> no need to restrict them
05:56:28 <povman> b0fh_ua: and if f is itself fmap something, then it'll fmap your MyNewType
05:57:01 <povman> b0fh_ua: fmap (fmap show) [MyNewType 1 "beer", MyNewType 2 "cheese"]
05:57:04 <HugoDaniel> which is better: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15480#a15480
05:58:07 <doserj> b0fh_ua: you could use TypeCompose, to build a type like [] `O` MyNewType, which then has a Functor instance that does what you want. But that might be a bit too advanced atm.
05:58:09 <b0fh_ua> got it
05:58:22 <b0fh_ua> doserj: too complicated for me now :)
05:58:33 <povman> HugoDaniel: the second one is pretty gross
05:58:49 <ski> (dark : btw, it is `let <decls> in <expr> end' in SML, so i assume by "ML" you earlier meant O'Caml ?)
05:58:57 <povman> HugoDaniel: I've done things like the first one before
05:59:03 <b0fh_ua> okay, now I understand functors better that yesterday, thank you all :)
05:59:09 <HugoDaniel> gross like in better ?
05:59:17 <povman> HugoDaniel: as in not better
05:59:27 <HugoDaniel> okey
05:59:38 <dark> ski, yes, i know only ocaml (but have programmed a line or two in sml)
06:00:24 <povman> HugoDaniel: the first lets you pattern match a lot easier
06:00:40 <HugoDaniel> nice :)
06:00:40 <HugoDaniel> ill use the first one then
06:01:13 <dark> Cale, hhmmmm @_@
06:01:19 <dark> Cale, clever
06:01:33 <dark> i was watching bb
06:16:24 <joe3> this is not a direct haskell question. I always question myself on what the *real* difference between prolog and haskell are? not the basics of logic vs functional, etc. but when you write a program in prolog vs writing a program in haskell. I feel that both will end up being the same though the semantics of what is called a function vs pattern/action might be different.
06:16:50 <joe3> but, I guess when u look at it that way, a program can be similarly written in any language.
06:17:05 <joe3> maybe it is the *programmer* that makes the difference..
06:17:35 <joe3> just wanted to see if there is anyone has any opinions/comments on this.
06:18:16 <jlouis> I am not sure what to say :)
06:18:48 <jlouis> many prolog relations are moded in practice to be functions
06:19:12 <jlouis> and then the similarity to Haskell, for example, is striking
06:19:33 <kamatsu> hm, has anyone noticed that the HSSDL bindings don't seem to have the Primitives from sdl_gfx implemented?
06:20:07 <kamatsu> I am trying to port a nice ruby library to Haskell and this has blocked further progress =(
06:22:28 <voker57> heh, right
06:22:51 <voker57> looks like somebody was bored to death when writing this file
06:23:24 <gwern> @quote tune
06:23:25 <lambdabot> BillWood says: it became obvious that when a Prolog program is tuned by removing non-determinism it moves towards a functional program.
06:24:31 <povman> kamatsu: Fix hssdl!
06:24:55 <kamatsu> povman: I would, but I have next to no experience with ffi, or sdl's c bindings
06:25:45 <kamatsu> i'm just wondering if i am looking at the wrong place or something, or if they truly aren't implemented
06:25:57 <kamatsu> if they're not, the only course of action is to implement them, but that is somewhat annoying
06:26:23 <jlouis> why? somebody has to do the initial work :)
06:26:40 <kamatsu> indeed, /someone/ does
06:26:49 <kamatsu> preferably not me :P
06:26:51 <povman> kamatsu: the set of people who actually use hssdl is very limited
06:27:00 <kamatsu> i see
06:27:02 <kamatsu> why is that?
06:27:21 <kamatsu> sdl seems like a pretty popular library
06:27:22 <povman> well i mean compared to regular c sdl
06:27:29 <kamatsu> well sure
06:27:41 <kamatsu> butthe set of people that actually use haskell is very limited... compared to the people that use c
06:28:06 <povman> and so there's a proportionally small group of people who actually develop the library
06:28:11 <kamatsu> right
06:28:28 <kamatsu> so, i'll have to implement the foreign bindings
06:28:32 <povman> :)
06:28:39 <jlouis> who is the maintainer?
06:28:41 <Susan> First person to make a useful program gets to fuck me!
06:28:48 <jlouis> Lemmih: ?
06:29:02 <Susan> I know I am safe here!
06:29:08 <povman> jlouis: probably, but i don't think he's touched it much
06:29:09 <kamatsu> SDL says Lemmih
06:29:12 <kamatsu> *hackage
06:29:14 <povman> kmc: look, a good one!
06:29:23 <jlouis> @vixen can you play with Susan?
06:29:23 <lambdabot> i sure can
06:29:51 <jlouis> kamatsu: try giving him a mail and see if he will play
06:29:57 <kamatsu> ok
06:30:00 <Susan> No takers?
06:30:13 <kamatsu> jlouis: if not, i'll just do it myself
06:30:16 <kamatsu> eh, can't be that hard
06:30:25 <kamatsu> ...
06:30:29 <povman> kamatsu: haskell ffi is really cool and pretty simple
06:30:31 <jlouis> kamatsu: it isn't, but try to get code into the SDL bindings
06:30:38 <kamatsu> k
06:30:53 <povman> btw i have a patch for hssdl which makes it cross platform :)
06:30:58 <Susan> If it is so cool and simple, the surely one of you can make a useful program
06:31:02 <kamatsu> povman -- wait, it isn't?
06:31:16 <povman> you have to do weird things to make it run on mac os x
06:31:22 <povman> but not any more
06:31:32 <kamatsu> ah
06:31:33 <povman> well, as soon as my patch is in
06:31:35 <kamatsu> right
06:31:36 <jlouis> otherwise the next guy porting a library from ruby with SDL will have trouble :)
06:31:53 <kamatsu> haha, indeed.
06:32:02 <kamatsu> okay, so, i'll start working on a patch
06:32:39 <Lemmih> jlouis: What?
06:33:23 <povman> bahahaha, Susan = Drunkenmonkey
06:33:45 <Susan> Noooo, I'm a girl
06:33:57 <Susan> Want to see my IO hole?
06:34:02 <copumpkin> o.O
06:34:04 <Susan> I mean Monad
06:34:09 <jlouis> Lemmih: talk to kamatsu regarding the SDL bindings
06:34:11 <Susan> Sorry just a slip
06:34:27 <kamatsu> Lemmih: ah, hi
06:34:30 <jlouis> and povman -- he has some portability patches it seems
06:34:36 --- mode: ChanServ set +o Lemmih
06:34:44 <povman> jlouis: shh, it's a secret
06:34:55 <Lemmih> povman: Hand 'em over!
06:34:56 <kamatsu> ... shut uuup
06:35:22 <jlouis> Lemmih: and while you are at it, boot Susan will you :)
06:35:30 <kamatsu> Lemmih: I was wondering why the Primitives module in the sdl_gfx binding was empty.
06:35:34 <Susan> What that is misogyny!
06:35:38 <povman> Lemmih: currently it's a separate library
06:35:49 <povman> Lemmih: I'll make a patch of it eventually
06:36:08 <kamatsu> Lemmih: Is it because it is left for the library user to implement?
06:36:10 --- mode: Lemmih set +b *!*=55c89673@gateway/web/freenode/x-mwofpgpxoowmwmpr
06:36:10 --- kick: Susan was kicked by Lemmih (Take five to cool off.)
06:36:35 <kamatsu> as an exercise for the reader, perhaps
06:37:39 <Lemmih> kamatsu: Never got around to using SDL-gfx. If you do bind the rest of the functions, send me a patch.
06:37:53 <kamatsu> okay, will do
06:38:30 <Lemmih> kamatsu: Only the base SDL package is complete. The rest I just wrote as I needed them.
06:40:03 <povman> Lemmih: ok, emailed you the thingy
06:41:19 --- mode: Lemmih set -b *!*=55c89673@gateway/web/freenode/x-mwofpgpxoowmwmpr
06:41:34 --- mode: Lemmih set -o Lemmih
06:43:10 <Lemmih> povman: Oh, interesting solution.
06:45:11 <Jonno_FTW> test
06:46:08 <povman> I can't remember if that thing even works on other platforms
06:46:16 <Jonno_FTW> > let xs = [5..43] in length xs -1
06:46:17 <lambdabot>   38
06:46:32 <Lemmih> povman: I'm slightly confused. Is SdlWrapper.main invoked at all?
06:47:05 <povman> on mac os x, SDL renames main to SDL_main then runs its own
06:47:21 <Lemmih> povman: And if it is, don't you end up with two instances of the RTS?
06:47:32 <Stalafin> this 'guards' contruct in haskell: | << that one, to the left of the arrows --- it has nothing to do with sml, does it? coz i remember, in sml it was used to simply avoid writing fun all over the place
06:47:40 <Lemmih> povman: Right, but it can't rename the 'main' from the GHC rts.
06:47:50 <povman> well actually
06:48:33 <povman> ah yeah
06:48:33 <Lemmih> povman: Shouldn't you compile the code without a Haskell 'main'?
06:48:55 <kamatsu> Stalafin: Not exactly the same concept, no
06:49:09 <Lemmih> povman: With the '-no-hs-main' flag, that is.
06:49:13 <povman> Lemmih: the c main is the real main
06:49:42 <Stalafin> kamatsu: so i couldn't/ shouldn't use them for recursion?
06:49:58 <Stalafin> kamatsu: instead of this 'pattern matching'
06:50:01 <Lemmih> povman: Right, but SdlWrapper seems to be dead code.
06:50:25 <povman> Lemmih: umm
06:50:31 <kamatsu> Stalafin: What do you mean 'use them for recursion'?
06:51:23 <Stalafin> kamatsu: http://en.wikipedia.org/wiki/Standard_ML check the defintion of factorial
06:51:33 <Stalafin> kamatsu: under Language
06:51:39 <Stalafin> kamatsu: the second one
06:51:51 <Stalafin> fun factorial 0 = 1
06:51:53 <Stalafin>   
06:52:06 <Stalafin> | factorial n= n * factorial (n-1)
06:52:09 <Lemmih> povman: Also, I don't think always returning '0' is correct.
06:53:07 <Heffalump> Stalafin: in both Haskell and ML, the | helps to select which clause of a definition will be used, but in one case it has a boolean condition and in the other a pattern. There's no special connection to recursion in either case.
06:53:09 <povman> Lemmih: when you link HSSDL in, it expects an SDL_main, which is provided by SdlWrapper
06:53:53 <Stalafin> Heffalump: of course, that i understand.... so i could use it for pattern matching, too? do i understand that correctly?
06:53:55 <povman> Lemmih: because SDL on mac defines main
06:54:05 <gwern> @quote endofunctor
06:54:06 <lambdabot> dmwit says: analogies are endofunctors in the category of bad explanations
06:54:08 <gwern> @quote endofunctor
06:54:08 <lambdabot> thermoplyae says: <thermoplyae> someone finally pointed out to me that a monad is an monoid-object in an endofunctor category <thermoplyae> i have no idea how i've never seen that before
06:54:14 <gwern> @quote endofunctor
06:54:14 <lambdabot> thermoplyae says: <thermoplyae> someone finally pointed out to me that a monad is an monoid-object in an endofunctor category <thermoplyae> i have no idea how i've never seen that before
06:54:14 <kamatsu> Stalafin: Guards essentially allow you to call a function and evaluate a boolean expression as part of a pattern
06:54:17 <gwern> gah
06:54:20 <gwern> @quote wadler
06:54:20 <lambdabot> wadler says: A monad is a monoid in the category of endofunctors, what's the problem?
06:54:38 <Stalafin> Heffalump: say, the way factorial is defined here: http://learnyouahaskell.com/syntax-in-functions#pattern-matching can i rewrite it with guards?
06:54:45 <povman> Lemmih: which in turn calls SDL_main, which is the one in c_main
06:54:59 <kamatsu> Stalafin: yes, but such an exercise would be silly
06:55:00 <povman> Lemmih: well, which is the main() in c_main
06:55:16 <Stalafin> kamatsu: may i ask why?
06:55:30 <kamatsu> Stalafin: because a simple pattern match will suffice
06:55:39 <kamatsu> you'd write it with guards like this
06:55:44 <Heffalump> guards are more verbose than pattern matches so usually only used when pattern matches can't be
06:55:52 <kamatsu> factorial x | x == 0 = 1
06:55:54 <interferon> i'm having a problem with the following recursive code: http://paste.lisp.org/display/92915
06:55:57 <interferon> why does that overflow?
06:56:06 <interferon> i'm trying to use an accumulator to avoid blowing the stack
06:56:29 <kamatsu>             | otherwise = x * factorial (x-1)
06:56:32 <Stalafin> kamatsu: ah, i see... so a guard REQUIRES me to have a boolean expression
06:56:36 <kamatsu> yes
06:56:40 <Stalafin> funky
06:56:52 <kamatsu> it's useful for something like..
06:56:53 <Athas> Did Hackage just go down?
06:57:15 <kamatsu> isAlphaNumeric a | isAlpha a || isNumber a = True
06:57:16 <Heffalump> Stalafin: GHC does have a "pattern guards" extension which is kind of a hybrid of the two
06:57:18 <kamatsu> or something
06:57:20 <Heffalump> but that's for later :-)
06:57:32 <Stalafin> Heffalump: oki ^^
06:57:38 <twanvl> interferon: the expression (count+1) is evaluated lazily, so your accumulator ends up containing a large unevaluated expression ((((...+1)+1)+1)+1)
06:57:55 <interferon> twanvl: ah, that makes sense
06:57:59 <interferon> can i force evaluation?
06:58:06 <CalJohn> interferon: helper xs $! (count + 1)
06:58:14 <interferon> what is $! ?
06:58:18 <koeien37> @src ($!)
06:58:19 <lambdabot> f $! x = x `seq` f x
06:58:23 <Heffalump> can you write helper (x:xs) !count = ... with bang patterns?
06:58:24 <Stalafin> would it be very silly to write a kernel in haskell?
06:58:31 <koeien37> Stalafin: no, it wouldn't
06:58:36 <koeien37> in fact it would be a good idea
06:58:39 <koeien37> (see HOUSE)
06:58:43 <Stalafin> house?
06:58:51 <koeien37> an operating system written in Haskell
06:58:57 <gwern> so I was reading the Functional Testing thesis; Curry looks like a pretty cool language
06:58:58 <interferon> @src (length)
06:58:58 <lambdabot> Source not found. My pet ferret can type better than you!
06:59:04 <koeien37> @src length
06:59:05 <lambdabot> Source not found. You untyped fool!
06:59:08 <interferon> CalJohn, twanvl: thanks
06:59:08 <gwern> Stalafin: also see the sel4 haskell soec
06:59:09 <Heffalump> you would have to decide what do to about the RTS, though
06:59:11 <gwern> *spec
06:59:12 <Jonno_FTW> an OS in Haskell!
06:59:15 <CalJohn> interferon: you could also use bang patterns to make helper strict in the count argument
06:59:20 <Heffalump> gwern: that was an OS in C, verified using a Haskell model
06:59:27 <interferon> CalJohn: ?
06:59:36 <gwern> Heffalump: hand-compiled from haskell, I thought
06:59:36 <koeien37> helper x !count = ...
06:59:42 <Jonno_FTW> could you just compile haskell to c and have an OS?
06:59:45 <CalJohn> http://www.haskell.org/ghc/docs/latest/html/users_guide/bang-patterns.html
06:59:55 <Stalafin> so why is there no OS in haskell actively used/developed?
06:59:57 <koeien37> you'll need {-# LANGUAGE BangPatterns #-}
07:00:01 <Stalafin> is it the complexity of the language?
07:00:07 <koeien37> Stalafin: because writing an OS is a lot of work
07:00:08 <CalJohn> it's a language extension that's sometimes helpful when dealing with inappropriate laziness
07:00:19 <Heffalump> Stalafin: why is there no OS in Java actively used/developed?
07:00:31 <gwern> Heffalump: actually...
07:00:31 <Stalafin> because java is ugly? :D
07:00:37 <CalJohn> interferon: are you using ghci or something?  my hunch is that ghc will make it strict automatically if you're using -O or -O2
07:00:45 <Heffalump> or OCaml or SML or F# for that matter
07:00:56 <interferon> CalJohn: yes, using ghci
07:01:07 <koeien37> you'll need drivers, and lots of 'em
07:01:28 <CalJohn> ok, well my hunch is that ghci isn't using the strictness analyser that ghc -O2 would do, so in compiled code, your problem should be removed automatically
07:01:40 <Heffalump> if you remember optimisations
07:01:48 <koeien37> it's best not to rely on that imon
07:02:03 <CalJohn> koeien37: we rely on TCO ;)
07:02:32 <koeien37> certainly. but if something fails to work with -O but works with -O2, it's different
07:02:51 <CalJohn> i think it probably does work with -O
07:03:34 <Heffalump> I'd expect so too
07:03:42 <Jonno_FTW> what does -O2 and -O actually do?
07:03:58 <Jonno_FTW> can i get some documentation on this?
07:03:59 <Heffalump> generally I'd say that you shouldn't rely on the optimiser if you need it for a complexity improvement like this
07:06:25 <jlouis> Jonno_FTW: look at the ghc man page, the "implied by -Ox" parts in INDIVIDUAL OPTIMIZATIONS
07:07:05 <Stalafin> if i write a function in haskell, do i have to pass it all variables it has to use? or is there a concept such as a global variable, which the function can use?
07:07:15 <CalJohn> jlouis: http://www.haskell.org/ghc/docs/latest/html/users_guide/options-optimise.html
07:07:24 <koeien37> Stalafin: there are no global variables.
07:07:42 <koeien37> you can work in the Reader or State monad, as appropriate, if necessary and convenient
07:07:55 <Eduard_Munteanu> Hi.
07:07:58 <jlouis> CalJohn: that too!
07:08:05 <CalJohn> ;)
07:08:12 <Jonno_FTW> thanks
07:08:28 <CalJohn> that page doesn't actually list what optimisations are what flags, and I know I've seen a document explaining that before
07:08:45 <Stalafin> koeien37: i didn't yet get to the concept of monads :p
07:08:54 <Stalafin> koeien37: so if a function needs to use a variable, i have to pass it?
07:09:00 <jlouis> Stalafin: yes
07:09:01 <CalJohn> in short, yes
07:09:01 <Jonno_FTW> yeah, that just explains the flag
07:09:07 <Jonno_FTW> what does the optimiser actually do?
07:09:16 <gwern> 'Haskell Reddit: Please continue to submit stories while I'm on vacation :-) (self.haskell)' haha
07:09:20 <Jonno_FTW> does it modify source code or byte code?
07:09:21 <jlouis> -O implies -fstrictness
07:09:21 <Stalafin> thanks
07:09:43 <soiamso> Stalafin: or use unsafeperformIO
07:09:47 <koeien37> soiamso: ssshhhh
07:10:10 <jlouis> Stalafin: Note that quite a number of bugs in imperative code stems from the use of global variables. If you can avoid them, your program is probably with less bugs than with them
07:10:31 <Stalafin> jlouis: it's actually fine... i was just wonderin
07:10:33 <Stalafin> :)
07:10:35 <Stalafin> i like it
07:11:20 <jlouis> Stalafin: it yields you some code locality so you don't have to go digging for the def-points of the global in the program to figure our what the code does
07:11:51 <jlouis> State must be killed with merciless zealotry
07:13:09 <medfly> @type newChan
07:13:10 <lambdabot> Not in scope: `newChan'
07:13:19 <medfly> @type Control.Concurrent.Chan.newChan
07:13:21 <lambdabot> forall a. IO (Control.Concurrent.Chan.Chan a)
07:13:23 <koeien37> IO (Chan a), I'd guess
07:13:31 <medfly> hi, just saying
07:14:11 <medfly> when you get sick of Haskell pretending it's not imperative or doesn't have global variable ish things then you can get something pretty close
07:14:29 <koeien37> :t newIORef
07:14:30 <lambdabot> Not in scope: `newIORef'
07:14:38 <jlouis> gwern: A variant of a prioQ is definitely an option. The problem is though that the count is dynamically updated when other peers get the piece
07:14:39 <koeien37> or newEmptyMVar
07:15:04 <gwern> jlouis: hm. offhand, I'm tempted to say, 'use a map where the piece is the key'
07:15:18 <gwern> but I don't think Map has an efficient 'get highest value'
07:15:20 <jlouis> gwern: mm, that was my first idea as well
07:15:39 <gwern> the naive get-highest would be O(n)
07:15:40 <koeien37> the highest value? no, that'd be impossible to do fast
07:15:42 <gwern> maybe some sort of tree
07:15:54 <Cale> Also, you can write things which are semantically a mess just with pure code. But they will look like a mess instead of the way that you're supposed to do things ;)
07:16:01 <koeien37> you could use bimap, I guess
07:16:10 <jlouis> gwern: it has O(lg n) findMin and findMax
07:16:30 <koeien37> yeah, bimap does what you want
07:16:49 <jlouis> I've yet to look at bimaps
07:16:54 <koeien37> you will need Ord on the values too, obviously
07:17:12 <jlouis> I can easily come up with an Ord for that I think
07:17:19 <koeien37> Bimap a b is basically a pair of maps Map a b and Map b a
07:17:33 <jlouis> And then you run them in tandem?
07:17:43 <koeien37> there is a package on Hackage for this
07:17:47 <jlouis> nod
07:17:51 <gwern> koeien37: or better yet, a Map and a single key
07:18:07 <gwern> every insert checks whether its value is higher than the value of the key and updates it if it is
07:18:14 <jlouis> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/bimap
07:18:30 <gwern> so you get fast inserts but still O(index) for highest alue
07:18:39 <Cale> It feels somehow like there ought to be a better datastructure for that than a pair of maps, but that's certainly the easy implementation.
07:18:48 <koeien37> right
07:18:51 <Cale> Something like a quadtree?
07:19:01 <gwern> koeien37: at least, I can't think of any faster datastructure than (key, Map key value)
07:19:28 <Cale> (just talking about a bimap, I'm not sure where this conversation came from)
07:19:44 <gwern> (we can't really get faster pure inserts, and the overhead of checking 'key' on every insert is neglible; likewise, updating existing values is about as fast as can be without switching everything to arrays or something)
07:19:47 <jlouis> Cale: keeping a histogram of torrent pieces
07:19:59 <jlouis> given a piece, we want to know how many peers has it
07:20:16 <jlouis> and we want to know what pieces are the rarest by looking at this count
07:20:20 <Cale> Map Piece Integer ?
07:20:27 <Cale> ah, okay
07:20:52 <Cale> That actually sounds quite a bit like a PSQueue?
07:20:58 <gwern> hm, I suppose ((key,value), Map key value) would save us lookups although make checking a bit more complex
07:21:13 <Cale> http://hackage.haskell.org/packages/archive/PSQueue/1.1/doc/html/Data-PSQueue.html
07:21:18 <Cale> A priority search queue (henceforth queue) efficiently supports the opperations of both a search tree and a priority queue. A Binding is a product of a key and a priority. Bindings can be inserted, deleted, modified and queried in logarithmic time, and the binding with the least priority can be retrieved in constant time. A queue can be built from a list of bindings, sorted by keys, in linear time.
07:21:22 <jlouis> The common operation is the rarity walk. Sometimes however a piece will increase by one in the map when another peer has it
07:21:22 <koeien37> I remember using that, too
07:21:50 <Cale> It seems like a perfect fit to me.
07:21:54 <jlouis> and somethimes a whole slew of pieces will be removed when a peer disconnects the cloud
07:22:19 <jlouis> Cale: yes, it looks like something that should be checked out
07:22:42 <jlouis> Thanks for the discussion, Cale, koeien37, gwern and all the ones I've forgot
07:34:40 <kamatsu> wow, the ffi is completely mechanical and easy
07:34:54 <kamatsu> for some reason i figured it'd be harder than that
07:39:17 <gwern> jlouis: looks like psqueue may sort of implement my idea
07:39:41 <gwern> jlouis: personally I'd just write the (key, Map) myself to avoid a whole dep - the idea can't be more than a few lines total
07:41:15 <jlouis> gwern: I won't bite on it yet. Currently there are other things more important to get into working order than the optimization that is
07:41:36 <gwern> I'd strike while the iron is hot
07:42:09 <gwern> if you put it off you'll wind up spending more time looking at it as a todo than would actually require to do it; as GTD says, if it would take 5 minutes or less, just do it
07:42:31 <jlouis> Reading Hinze's paper is not a 5 minute task :)
07:42:53 <gwern> ...who said you had to read his paper?
07:43:31 <jlouis> I don't. On the other hand, there are some scaffolding that is needed before you can strike unfortunately
07:44:05 <jlouis> I do understand your point about simple things needs to be killed fast.
07:46:04 <gwern> data PQueue k v = PQueue k (Map k v); getHighest (PQueue k m) = lookup m k; insert (PQueue k m) k' = if k' > k then PQueue k' (insert m k') else PQueue k (insert m k')
07:48:40 <gwern> jlouis: ^ see? relatively simple - just wrap the few Map operations you need in a conditional
07:49:27 <jlouis> That is like Okasaki's explicit min functor (functor here is in the style of an ML functor)
07:49:42 * gwern suddenly feels like someone who knows haskell as opposed to being a poseur
07:49:43 <kakjf>  Please click on this link and you will help me - http://www.lostworlds.lv/go.php?1139747394
07:50:05 <gwern> jlouis: possibly. I have a copy of okasaki if I would just work through it...
07:51:03 <maartenm> hello, I need to write some binary data to a file
07:51:29 <gwern> Data.Binary
07:51:30 <gwern> next pls
07:51:32 <maartenm> ppm file, I have headers in ascii and then need to append some binary data to it in the body... I don't know how to do that with erlang
07:51:34 <maartenm> eh, with haskell
07:51:37 <jlouis> gwern: but if (k,v) is in the map, how do I increase it to (k+1,v)? I don't know k
07:52:37 <gwern> jlouis: ah, you're right. you should be doing 'lookup oldKey vs lookup newKey' if you follow
07:54:02 <jlouis> maartenm: erlang: create an iolist of send it to a file process. Haskell: Data.Binary or Cereal are good bets
07:54:17 <maartenm> looking into Data.Binary
07:54:56 <Stalafin> w/out giving you the source code right now... what's usually the source of a "parse error in pattern"?
07:54:58 <maartenm> is cereal more high-level?
07:55:23 <maartenm> I just want to send a stream of bytes to a file
07:55:46 <Jafet> Might as well just use P3 format
07:55:53 <maartenm> yeah but I need 32 bit color
07:55:55 <gwern> Stalafin: missing brackets or operators like :, for me
07:56:06 <maartenm> 24 bit
07:56:07 <jlouis> maartenm: if you have a Data.ByteString you can just BS.hPut handle
07:56:18 <maartenm> does that append as well?
07:56:38 <gwern> I have more than once written [a:as] where I needed (a:as) :)
07:56:40 <jlouis> maartenm: yes, the handle has a file pointer
07:56:55 <maartenm> ok thanks.. sorry don't have much patience today
07:56:57 <Jafet> P3 is 24-bit color
07:57:01 <Stalafin> gwern: arrite :)
07:57:12 <Jafet> Like P6, which you want to implement
07:57:55 <jlouis> maartenm: ppm is simple enough that I would just write data directly via String or Data.ByteString
07:58:46 <BrianB04> I'm back...stupid internet connections.
07:59:11 <BrianB04> So, I have another kind of silly question: I see a lot of use of Maybe, how do you deal with Maybe? Just pattern match against it, or is there another method?
07:59:30 <copumpkin> lots of methods
07:59:38 <gwern> BrianB04: maybe is a monad, so if you're doing *a lot* with it, switch to do notation?
07:59:43 <koeien37> pattern matching. use the "maybe" function. use things like catMaybes, listToMaybe, use (>>=), return and fail
07:59:55 <koeien37> use mzero + mplus
08:00:10 <koeien37> use fmap
08:00:12 <BrianB04> Or rather, something like Just s.
08:00:38 <koeien37> if you don't know about monads, it's an easy monad to learn
08:01:08 <Olathe> > fmap (+5) (Just 10)
08:01:09 <lambdabot>   Just 15
08:01:13 <BrianB04> If a function returns a Just s, for instance where s is a string, how do you get to the string? Just have to pattern match against it, or decompose it?
08:01:37 <koeien37> pattern matching, yes.
08:01:40 <fabjan> > fmap (+5) Nothing
08:01:41 <lambdabot>   Nothing
08:01:44 <koeien37> :t maybe
08:01:44 <fabjan> oh
08:01:45 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
08:01:52 <jlouis> :t fromJust
08:01:53 <lambdabot> forall a. Maybe a -> a
08:02:12 <koeien37> fromJust is partial
08:02:14 <Olathe> @src maybe
08:02:14 <lambdabot> maybe n _ Nothing  = n
08:02:15 <lambdabot> maybe _ f (Just x) = f x
08:02:16 <jlouis> fromJust is dangerous unless you are sure it is a Just
08:02:39 <Olathe> > maybe 0 (+5) (Just 10)
08:02:40 <lambdabot>   15
08:02:44 <Olathe> > maybe 0 (+5) Nothing
08:02:45 <lambdabot>   0
08:03:38 <Stalafin> somebody look at this please.... createX, first guard... http://pastebin.com/d552b099e
08:03:48 <BrianB04> isJust will return true if it's a just, so you use that in conjunction with fromJust?
08:04:11 <Olathe> You can.
08:04:14 <koeien37> Stalafin: you need () around (...:x:xs)
08:04:18 <tibbe> anyone have experience benchmarking data structures using Criterion?
08:04:19 <lambdabot> tibbe: You have 1 new message. '/msg lambdabot @messages' to read it.
08:04:20 <BrianB04> > fromJust (Just a)
08:04:21 <lambdabot>   a
08:04:28 <koeien37> you can, yes. but it's more convenient to use pattern matching
08:04:41 <Stalafin> koeien37: you are a god
08:04:51 <BrianB04> So _ x will grab just x, and not the Just
08:05:01 * copumpkin sacrifices Stalafin to the vengeful god koeien37 
08:05:14 <jlouis> WE DEMAND A SACRIFICE!
08:05:24 <Stalafin> koeien37: can you please tell what was written there before there were () around the (...:x:xs)
08:05:25 <Olathe> BrianB04: No, you always need constructors in patterns.
08:05:46 <Stalafin> koeien37: that is, what it was saying
08:05:47 <koeien37> createX (moveRight ...) : ( x : (xs max_x dist1 dist2) )
08:05:52 <Olathe> BrianB04: You use Just x = y and that throws away the Just from y.
08:05:59 <koeien37> so you applied xs to some arguments
08:06:04 <Stalafin> koeien37: that's the whole left-associativity thing?
08:06:17 <koeien37> no. function application binds very strongly
08:06:18 <Olathe> > let y = Just 5; Just x = y in x
08:06:19 <lambdabot>   5
08:06:35 <Stalafin> koeien37: so, f precedes :
08:06:44 <koeien37> yes
08:06:48 <koeien37> > 1 : (+1) 2
08:06:49 <lambdabot>   No instance for (GHC.Num.Num [t])
08:06:49 <lambdabot>    arising from the literal `1' at <inter...
08:06:50 <DerisionSnort> @pl \p x y = x ++ element:y
08:06:51 <lambdabot> (line 1, column 8):
08:06:51 <lambdabot> unexpected "="
08:06:51 <lambdabot> expecting pattern or "->"
08:06:55 <koeien37> > 1 : (+1) 2 : []
08:06:56 <lambdabot>   [1,3]
08:06:57 <DerisionSnort> @pl \p x y -> x ++ element:y
08:06:58 <lambdabot> const ((. (element :)) . (++))
08:08:22 <Olathe> BrianB04: The Just is like : for lists. You have (x:_) and that throws away part of the data, but you still have the structure ":". "Just" is the structure there, so you can throw away any of the data, but not that.
08:08:37 <koeien37> @src Maybe
08:08:37 <lambdabot> data Maybe a = Nothing | Just a
08:08:39 <Olathe> > let y = Just 5; Just _ = y in "hello"
08:08:40 <lambdabot>   "hello"
08:08:58 <Olathe> You can throw away the data in the Just if you want, but not the Just itself.
08:09:06 <BrianB04> Wow, okay, Comcast issues all over today. I miss my T1
08:09:26 <Stalafin> is ther another expression for [] in haskell? i believe, in sml it was nil: [] == nil
08:09:38 <koeien37> [] is just []
08:09:43 <koeien37> the empty list
08:09:45 <Olathe> > mzero :: []
08:09:45 <lambdabot>   `[]' is not applied to enough type arguments
08:09:46 <lambdabot>  Expected kind `?', but `[]' h...
08:09:51 <Olathe> No, that's not it.
08:09:53 <Olathe> Hmm...
08:09:55 <BrianB04> Is there any good place to find a full writeup on Maybe, and Just and dealing with them?
08:09:56 <koeien37> [] is not a type!
08:09:58 <koeien37> [a] is
08:10:02 <Olathe> > mzero :: [a]
08:10:03 <lambdabot>   []
08:10:04 <koeien37> or [] a, equivalently
08:10:07 <Olathe> Ahh, thanks :)
08:10:13 <Stalafin> koeien37: unfortunate, i always prefered to write nil
08:10:15 <Stalafin> :D
08:10:24 <copumpkin> @let nil = []
08:10:25 <koeien37> then define nil = []
08:10:25 <lambdabot>  Defined.
08:10:27 <copumpkin> there you go
08:10:29 <mercur1> It should be called 0 anyway.
08:10:29 <Jafet> @src []
08:10:29 <CalJohn> > Nothing `mplus` Nothing
08:10:30 <lambdabot> data [] a = [] | a : [a]
08:10:30 <lambdabot>   Nothing
08:10:39 <koeien37> mercur1: no, 0 is the number zero
08:10:48 * Jafet rewrites Stalafin unhygienically
08:10:51 <CalJohn> > Just 4 `mplus` Just 3
08:10:52 <lambdabot>   Just 4
08:10:54 <cytzol> BrianB04: the docs for Data.Maybe ?
08:10:55 <mercur1> 0 should be the monoid zero.
08:11:02 <CalJohn> > Just 4 `mplus` Just undefined
08:11:03 <lambdabot>   Just 4
08:11:06 <Stalafin> what's that @ in @let?
08:11:08 <copumpkin> 0 and 1 are super duper overloaded symbols
08:11:16 <koeien37> in mathematics, yes
08:11:23 <koeien37> why not the bottom of a lattice?
08:11:26 <cytzol> Stalafin: the @ is for lambdabot
08:11:27 <koeien37> or the trivial monoid
08:11:31 <copumpkin> or the empty type
08:11:56 <koeien37> 1 is also the trivial group, like 0
08:12:26 <mercur1> That's because it is final and terminal.
08:12:28 <koeien37> so there are lots of uses for them. in hasekll they mean fromInteger 0 and fromInteger 1, which is okay enough IMO
08:12:32 <Stalafin> 1 = suc(0)
08:12:33 <mercur1> err, initial and terminal
08:12:41 <koeien37> in Grp ?
08:12:42 <Jafet> 1 = {0|}
08:12:45 <mercur1> Yes.
08:12:48 <koeien37> yes.
08:13:43 <Olathe> BrianB04: I'm not sure. I think http://www.haskell.org/onlinereport/maybe.html and asking questions here is the best I know of.
08:13:57 <maartenm> Graphics.Pgm has:   arrayToFile :: IArray m Word16 => String -> m (Int, Int) Word16 -> IO ()
08:14:01 <koeien37> Maybe is probably explained in a lot of tutorials and introductions
08:14:08 <maartenm> but I don't understand hwo to coercde my array into the correct type
08:14:14 <koeien37> probably in LYAH too
08:14:24 <maartenm> I just have an array of (R,G,B) tuples now
08:14:35 <BrianB04> OH...I see, so using pattern matching I would have to do (Just x) = x...
08:15:16 <tibbe> Can I trust GHC to deforest something like: foldl' (\n -> IntMap.insert im n n) IntMap.empty [1..10000]   and not create any intermediate lists?
08:15:46 <koeien37> this sounds like fromAscList . join zip $ [1..10000]
08:15:46 <gwern> check the Core and see
08:16:00 <maartenm> ok, amap (fromIntegral :: Int -> Word16) arr
08:17:23 <Olathe> BrianB04: Well, (Just newvariable) = oldvariable.
08:18:31 <xerox> tibbe probably better to be explicit if you really need it
08:18:43 <tibbe> xerox: so write the recursive loop you mean?
08:19:59 <xerox> tibbe yes, there is an article on dons' blog (at unsw) that shows the different Core produced by the different wordings
08:20:24 <tibbe> xerox: yes, I remember that
08:20:27 <DerisionSnort> @pl \element rest -> concat (map (place element) rest)
08:20:28 <lambdabot> (join .) . map . place
08:20:37 <tibbe> xerox: I wish we had stream fusion based lists in GHC
08:20:45 <tibbe> xerox: would save a lot of typing
08:21:04 <Stalafin> so when do you guys know that the code you wrote is pretty and not complete (ugly) sh*t?
08:21:07 <Stalafin> :D
08:21:11 <koeien37> experience
08:21:18 <xerox> tibbe I'd love to be able to trust GHC to do those optimizations too :)
08:21:32 <koeien37> i have a sense of beauty for some mathematics, and the same holds for code
08:21:39 <gwern> Stalafin: when it fits on a page, uses mostly library imports, and hlint and -Wall don't complain
08:21:46 <c_wraith> isn't supercompilation supposed to be able to optimize things like that?
08:22:05 <BrianB04> Stalafin: You show the code to someone who does not know Haskell, if their ears bleed only, it's pretty. If their head explodes it's ugly.
08:22:26 <koeien37> i have the feeling it's the exact opposite
08:22:31 <Stalafin> hahaha :D
08:23:15 <kamatsu> hey, so, with this ffi binding, i have a c function that takes an array of ints
08:23:31 <kamatsu> how can i construct an array of ints from, say, a haskell list, to pass into this ffi function?
08:23:58 <BrianB04> The other option is to send your code to Simon, and if he deems it pretty, it is.
08:24:00 <koeien37> withArray ?
08:24:12 <Olathe> @type listArray
08:24:13 <lambdabot> forall i e. (Ix i) => (i, i) -> [e] -> Array i e
08:24:19 <koeien37> iirc, I'm not really confident in it
08:24:26 <koeien37> :t withArray
08:24:27 <lambdabot> Not in scope: `withArray'
08:24:35 <koeien37> :t Foreign.Marshal.Array.withArray
08:24:36 <lambdabot> forall a b. (Foreign.Storable.Storable a) => [a] -> (GHC.Ptr.Ptr a -> IO b) -> IO b
08:24:41 <Stalafin> ok, so i have this fairly ugly sonuvabitch here... i am curious about an error... if you load the code in ghci and then run createX (unit:[]) x_max a c you will get an error... i would love if somebody could tell me how to avoid such an error (except for making the value passed a double).... http://pastebin.com/d7d2237a3
08:24:53 <kamatsu> koeien37:  thanks ^^
08:26:29 <Olathe> Stalafin: Can you paste the relevant portions of the ghci session, too ?
08:26:32 <koeien37> Stalafin: it would help if you'd paste the error
08:26:38 <c_wraith> Stalafin: Without running the code, I'm guessing you're getting bitten by the Monomorphism constraint.
08:26:58 <koeien37> oh yes, the alpha and a, and x_max, and so on
08:27:14 <koeien37> {-# LANGUAGE NoMonomorphismRestriction #-} It should die a fast but horrible death
08:28:09 <c_wraith> Stalafin: in particular, since you're not using x_max in that file, it's defaulting it to be of type Integer, which doesn't work with later calculations
08:28:29 <Stalafin> what does a multi-line comment look like?
08:28:35 <koeien37> {- bla \n \n -}
08:28:40 <c_wraith> Stalafin: If you want it to be treated as a particular type, you should put a type annotation on it.
08:28:55 <koeien37> or just switch off the monomorphism restriction
08:29:19 <Stalafin> http://pastebin.com/d5d940b5c
08:29:22 <Stalafin> here with error
08:29:50 <koeien37> yeah, it's the monomorphism restriction
08:29:51 <Stalafin> koeien37: how do i switch sucha restriction off?
08:30:01 <koeien37> {-# LANGUAGE NoMonomorphismRestriction #-} at the top of your file
08:30:23 <Stalafin> is that a good thing to do?
08:30:28 <koeien37> alternatively, you can add a type annotation for x_max, say x_max :: Num a => a
08:30:39 <koeien37> in my opinion, the monomorphism restriction is a mistake, so yes
08:30:45 <c_wraith> Of course, if you just put a type annotation on all your top-level declarations, the monomorphism restriction doesn't do anything.
08:30:54 <koeien37> http://www.haskell.org/haskellwiki/Monomorphism_restriction
08:31:35 <Stalafin> it appears rather painful to have type annotations all over the place
08:31:48 <c_wraith> generally you don't have many top-level definitions
08:32:04 <c_wraith> and supplying a type annotation is a form of documentation
08:32:09 <koeien37> well, they are encouraged (some consider it good style) for toplevel definitions. but for simple things like number constants it's not necessary imo
08:32:11 <tibbe> woot: Making Hinze's priority search queue strict in the sub trees makes it 2x faster for inserts
08:32:36 <Stalafin> koeien37: but in this case, it was a number constant...
08:32:40 <koeien37> (modulo the monomorphism restriction)
08:32:47 <koeien37> right. That's why i'd switch that off :)
08:33:09 <koeien37> type annotations may help you get clearer error messages
08:33:19 <koeien37> but they are only rarely necessary
08:33:44 <Stalafin> koeien37: yeah, somebody told me... so far i am writing the code, check if it works, and then add the type after ghci tells me what it is :D
08:33:54 <koeien37> that is a possibility, yes
08:34:11 <koeien37> it's not strictly necessary but it serves as documentation for later readers of your code (including yourself)
08:34:23 <Stalafin> koeien37: for instance, if you check the type of my createX function, i do not quite get in how far the type restriction (Ord a, Num a) works there
08:34:30 <koeien37> i often do the reverse: make some type annotations and then fill in the definitions
08:34:48 <Stalafin> that seems like advanced magic :D
08:34:54 <koeien37> they are type classes
08:35:05 <koeien37> you use the "<" function in the guard, for example
08:35:34 <koeien37> that means that (<) should be defined for the input type
08:35:48 <koeien37> e.g. Integer and Double, but not a -> a
08:36:20 <Stalafin> koeien37: but not a -> a?
08:36:31 <koeien37> technically, it's saying that type a should be a member of the Ord and Num typeclasses. Ord a => guarantees that you can use (<), (<=) and friends, and Num a => guarantees that you can use (+), (*) and so on
08:36:49 <Stalafin> aaah, ok
08:36:50 <koeien37> you cannot compare functions a -> a
08:37:09 <c_wraith> > id < (+)
08:37:10 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
08:37:34 <c_wraith> err, oops
08:37:41 <koeien37> another example is Complex Double, this type is not an instance of Ord, but it is an instance of Num
08:37:43 <c_wraith> > (+5) < id
08:37:44 <lambdabot>   No instance for (GHC.Classes.Ord (a -> a))
08:37:44 <lambdabot>    arising from a use of `GHC.Cl...
08:38:05 <mreh> hi #haskell!
08:38:08 <koeien37> RWH has a chapter on type classes. They are pretty fundamental to Haskell's approach to overloading
08:38:21 <koeien37> In fact, they *are* Haskell's approach to overloading
08:38:27 <mreh> yes they are!
08:38:31 <Codex_> c_wraith: I wonder how broken it would be if you just implement instance of it :)
08:38:37 <mreh> is that ad-hoc polymorphism?
08:38:50 <Stalafin> koeien37: and complex numbers are not comparable except for real, imaginary and absolute value...
08:39:03 <koeien37> right, so it makes no sense to say 1 < i
08:39:12 <koeien37> so that's why there is no Ord instance for Complex Double
08:39:19 <Stalafin> i see
08:39:39 <koeien37> > let i = 0 :+ 1 in 1 < i -- type error
08:39:40 <lambdabot>   No instance for (GHC.Classes.Ord (Data.Complex.Complex t))
08:39:40 <lambdabot>    arising from ...
08:39:45 <c_wraith> instance Ord ((->) a a) where compare _ _ = LT
08:39:46 <mreh> Ord (Complex Double)?
08:40:16 <koeien37> Eq is arguably the most important type class
08:40:27 <koeien37> it defines (==) and (/=)
08:40:55 <koeien37> it has lots of instances, like Integer, Int, Double, and so on, but most notably the functions are absent (You cannot compare functions for equality)
08:41:05 <kamatsu> Hm, so, SDL_gfx uses Int16's for all coordinates. I am wondering if i should pass this into the haskell version or just wrap them in fromIntegral and use Ints, which is a bit more convenient.
08:41:07 <Jafet> Monad and Show, young padawan
08:41:21 <kamatsu> any thoughts?
08:41:40 <koeien37> > (+1) == (+1)
08:41:40 <lambdabot>   No instance for (GHC.Classes.Eq (a -> a))
08:41:41 <lambdabot>    arising from a use of `GHC.Cla...
08:41:57 <Jafet> Data.Int isn't really much of a dependency, I would think
08:42:08 <Jafet> Graphical code should be correct of all things
08:42:13 * mreh thinks koeien37 is very good value for money
08:42:18 <c_wraith> instance Eq ((->) a a) where _ == _ = False
08:42:31 <koeien37> right, you *can* define an instance, but that doesn't mean that you should
08:42:34 <kamatsu> Jafet: so, keep it as int16?
08:42:40 <c_wraith> In fact, I really shouldn't. :)
08:42:53 <Jafet> > succ
08:42:54 <lambdabot>   * Exception: Prelude.Enum.().succ: bad argument
08:42:55 <koeien37> functions also are generally not instances of Show. But lambdabot has an instance for convenience for the channel
08:43:06 <mreh> > "can you hear me?"
08:43:07 <lambdabot>   "can you hear me?"
08:43:08 <koeien37> > (+1) :: Integer -> Integer
08:43:09 <Jafet> > (+1)
08:43:09 <lambdabot>   {-3->-2;-2->-1;-1->0;0->1;1->2;2->3;3->4}
08:43:10 <lambdabot>   {-3->-2;-2->-1;-1->0;0->1;1->2;2->3;3->4}
08:43:22 <Jafet> Oh boy, quickskell
08:43:24 <burp> one could define an instance via quickcheck testing :D?
08:44:30 <mreh> preflex: seen mmorrow
08:44:30 <preflex>  mmorrow was last seen on #haskell 3 days, 8 hours, 10 minutes and 34 seconds ago, saying: * mmorrow refocuses back on topic
08:46:12 <Codex_> couldnt you do Eq instance for functions by using equivalence of categories and the functors S : A->C and T :: C->A and then natural isomorphism S T == I :: C->C and T S == I :: A->A.
08:48:43 <kamatsu> right, i believe i've finished my sdl_gfx binding
08:48:47 <kamatsu> now to test each function
08:50:03 <mreh> if they don't work then SDL is broken
08:52:13 <mreh> can anyone hear me?
08:52:23 <kamatsu> mreh: hi
08:52:26 <kamatsu> i can hear you
08:53:03 <mreh> now I feel relieved I can send to the channel, but sad that everyone is ignoring me
08:55:03 <Codex_> mreh: it needs to be more compressed information
08:55:25 <mreh> okay
09:01:38 <Baughn> http://marc.info/?l=git&m=124111702609723&w=2 <- So, here are a bunch of problems with Java, presented as problems with high-level languages in general.
09:01:41 * Baughn is unamused.
09:03:10 <mreh> what is he talking about?
09:03:22 <Baughn> Implementation problems of git in java.
09:03:35 <Jafet> Comparing their implementations of git in C and Java
09:03:38 <Baughn> Most of them wouldn't be applicable to haskell.. actually, with storable-vector, I don't think any of them are
09:03:54 <Jafet> Why this ML thread is relevant to Haskell is anyone's guess
09:04:32 <mreh> write it in haskell and kick his ass
09:04:33 <koeien37> I agree with the post by the way
09:04:48 <Jafet> Unless Baughn is recruiting us to do a second gitit or something
09:04:54 <mreh> uh oh..
09:05:10 <Baughn> Jafet: There must be more git implementations
09:05:19 <Jafet> Oh, yes there must!
09:05:24 <koeien37> abstractions are likely to cost you performance
09:05:48 <Jafet> They shouldn't, though
09:05:52 <Baughn> After darcs, we could really use an example of a /high-performance/ haskell RCS. Not that I don't like using darcs, but.. ^^;
09:05:57 * Baughn wouldn't put the kernel tree in it
09:05:57 <Eduard_Munteanu> Um... is this serious? Has anybody reimplemented Git in Java?
09:05:58 <holmak> I don't think Haskell causes nearly as many problems from extra copying and boxing as Java, though.
09:05:58 <CalJohn> mmm, i think abstractions are likely to gain performance in lots of places.
09:05:59 <Jafet> Unless you choose inappropriate abstractions.
09:06:04 <Baughn> Eduard_Munteanu: Why, yes
09:06:07 <koeien37> Eduard_Munteanu: yes
09:06:13 <Eduard_Munteanu> Hm, didn't know.
09:06:22 <koeien37> abstractions may gain performance, but in practice they often don't
09:06:43 <koeien37> darcs is slooooooow
09:07:10 <Heffalump> darcs is slow because it does a lot of unnecessary work, not because it does the work slowly, IMO
09:07:10 <Baughn> Darcs is slow because of its model, not really because of the implementation. :P
09:07:13 <CalJohn> i don't think that's a fundamental barrier.  There is no fundamental reason why "abstraction" means "slow"
09:07:16 <koeien37> right
09:07:19 <Eduard_Munteanu> AFAI've heard, Darcs has a nice model, similar to Git, though I hear people say it's slow too.
09:07:28 <koeien37> darcs is not slow because of Haskell
09:07:33 <Baughn> Eduard_Munteanu: Actually, darcs has a /much/ nicer model than git
09:07:34 <Heffalump> it has a much nicer model than git :-)
09:07:43 <medfly> I see people agreeing
09:07:47 <Baughn> Git has a bunch of nicer features darcs is lacking, though, like in-place branches
09:07:48 <koeien37> because Haskell can be really fast
09:07:48 <medfly> they're even writing the exact same text
09:08:04 <Neuromancer> what do you think is the biggest obstacle to people using haskell for big projects? it being so weird? :)
09:08:08 <Jafet> That doesn't imply they are agreeing!
09:08:09 <koeien37> but idiomatic haskell tends to be slow IME
09:08:13 <dh_> Happy new years guys. I want to give an alias to show as str = show, but it failed when loading, any help ?
09:08:16 <Baughn> Yeah.. this dicussion is going nowhere, due to violent agreement. ^_^;
09:08:25 <koeien37> {-# LANGUAGE NoMonomorphismRestriction #-}
09:08:28 <CalJohn> dh_: monomorphism restriction
09:08:29 * Jafet unplugs Neuromancer
09:08:29 <Eduard_Munteanu> Baughn, what's the hallmark of Darcs in that respect?
09:08:32 <koeien37> dh_: the evil monomorphism restriction
09:08:35 <medfly> no, I think git is much better than darcs
09:08:38 <medfly> now, continue
09:08:40 <Baughn> Neuromancer: Lack of libraries, is a big one. I've been using it for my MSc thesis, and wound up having to reinvent a lot of code.
09:08:40 <mreh> Neuromancer: you wont get far in here with that attitude!
09:08:43 * medfly doesn't know git or darcs
09:08:46 <burp> I prefer working with git
09:08:48 <Neuromancer> Jafet: i changed names and you still wanna unplug me :D
09:08:51 <c_wraith> two MR questions in an hour or so.  hmm
09:08:52 <koeien37> i use hg
09:08:53 <dh_> thanks. I guess I need to google monomorphism restriction.
09:08:57 <c_wraith> 'tis the year for MR!
09:09:03 <Baughn> Eduard_Munteanu: In what regard? Clarify, please
09:09:09 <Neuromancer> mreh: nah, i like it so far... it's still weird :)
09:09:11 <Eduard_Munteanu> Baughn, you said it had a nicer model.
09:09:32 <Neuromancer> mreh: i mean, you do have to get used to doing things differently
09:09:52 <Baughn> Eduard_Munteanu: Ah. Yes. Git and Darcs both use a model where there are patches that are dependent on more patches, and so on, but..
09:09:53 <mreh> Neuromancer: It has the most natural model of computation, you just have to unlearn what you've been taught
09:10:11 <Saizan_> dh_: the description in the haskell report is the best i've found online
09:10:13 <Neuromancer> mreh: i agree
09:10:16 <Baughn> Eduard_Munteanu: Darcs tries very hard to compute a minimal set of dependencies, while git defaults to a patch being dependent on /everything/ that's before it in the history
09:10:27 <mreh> Neuromancer, I'm talking about recursion btw
09:10:28 <Baughn> Eduard_Munteanu: The latter is asymptotically faster, but much less flexible
09:10:37 <dh_> Saizan_: thanks :)
09:10:45 <Neuromancer> mreh: actually, i have learned to program using recursion (namely, in sml)
09:11:01 <Neuromancer> mreh: but since i have switched majors (now physics),my skills got somewhat rusty
09:11:17 <Neuromancer> mreh: and the whole department uses fortran....
09:11:23 <mreh> :O
09:11:32 <vardhanvarma> Trying euler#4 .. how to enumerate x & y in range 999..100, such that product goes down monotonically ( don't want to use sort )
09:11:33 <Baughn> Eduard_Munteanu: Darcs lacks convenient branches, git has them, but in git they are also the only way to avoid spurious dependencies
09:11:36 <Eduard_Munteanu> Baughn, I don't really get it... as long as the patch merges correctly it doesn't depend on anything else.
09:11:42 <Jafet> I would not try to do in Haskell what I would do in Fortran.
09:11:57 <Eduard_Munteanu> Baughn, besides history is important in Git.
09:12:05 <mreh> Jafet, not the other way round?
09:12:09 <Baughn> Eduard_Munteanu: Um. Let's say you have a repository with two files, a and b, and three patches: The initial state (I), a patch to A (A), and one to B (B)
09:12:14 <Jafet> Both ways.
09:12:18 <Eduard_Munteanu> Baughn, yes...
09:12:37 <Baughn> Eduard_Munteanu: In darcs, B will not depend on A, or the other way around, regardless of the order you record them in
09:12:47 <Baughn> Eduard_Munteanu: In git, they do, depending on order.
09:12:53 <Jafet> mreh, unless tomorrow there suddenly appeared on hackage fifty highly optimized linear algebra and numerical modelling libraries
09:12:53 <Neuromancer> Jafet: that implies that you could clearly separate what you would do in fortran and what you would do in haskell
09:12:57 <Neuromancer> Jafet: can you do that?
09:13:11 <mreh> Neuromancer: not computationally, they are identical
09:13:12 <Baughn> Eduard_Munteanu: So when you pull those patches from the repository, you can choose to skip either patch, and they can generally be reordered at will
09:13:23 <Neuromancer> mreh: what do you mean?
09:13:24 <Eduard_Munteanu> Baughn, yeah, but when rebasing/reordering Git commits, I don't see that to matter much. :/
09:13:40 <burp> yup, git has the flexibility
09:13:46 <mreh> Neuromancer: do you know the church turing thesis? that's what I mean
09:13:47 <Baughn> Eduard_Munteanu: And that's a special operation, which you have to be careful when doing
09:14:04 <Baughn> Eduard_Munteanu: In darcs, it's the default state of affairs.  You might say that /every/ operation potentially rebases.
09:14:08 <Eduard_Munteanu> Baughn, of course, it basically touches all commits in question.
09:14:41 <Eduard_Munteanu> Baughn, doesn't that mess up commit hashes?
09:14:48 <Baughn> Eduard_Munteanu: Nope. You see..
09:15:01 <Baughn> Eduard_Munteanu: Git builds a timeline of patches, which you can potentially alter post-build; doing so (rebasing) can potentially mess things up
09:15:16 <Baughn> Eduard_Munteanu: Darcs builds an acyclic graph, and "rebasing" that doesn't actually change the graph at all
09:15:59 <mreh> has anyone here run that 3d game frag? what kind of performance levels did you get in relation to the quality of the graphics
09:15:59 <bob0> mreh: no
09:16:11 <mreh> bob0: no what?
09:16:19 <Baughn> mreh: Me neither
09:16:34 <Eduard_Munteanu> Baughn, I see... but then can you rely anymore on hashes for authenticity? Or you simply tag every significant release to prove authenticity?
09:16:50 <Baughn> Eduard_Munteanu: Oh, the patches are individually signed
09:17:18 <Eduard_Munteanu> Baughn, hm, you have a point. I wonder whether patch order tampering can actually do something.
09:17:21 <Baughn> Eduard_Munteanu: To be honest, I haven't looked very closely at how darcs deals with security. Mostly I haven"t cared.
09:17:34 <Eduard_Munteanu> I see.
09:17:43 <Heffalump> you only really sign them when sending them elsewhere
09:17:45 <Baughn> Eduard_Munteanu: That's what I've been trying to tell you. There is no order in the first place, beyond that acyclic graph.
09:18:04 <Heffalump> the key point of darcs is that if it lets you reorder patches, then order doesn't actually matter
09:18:10 <Baughn> Eduard_Munteanu: By definition (of how it's made), /any/ ordering consistent with the graph will produce the same final codebase
09:18:39 <Heffalump> it might be that removing some key earlier patch could create a security hole, but that's no different to any kind of code change
09:18:39 <Eduard_Munteanu> Heffalump, yeah, it only matters when walking back the history, you might end up with non working builds due to reordering methinks.
09:18:50 <Heffalump> Eduard_Munteanu: yep, entirely possible
09:18:50 <Baughn> See my last sentence.
09:19:01 <Heffalump> but very often it just works and is exactly what you want
09:19:07 <Baughn> Well, if you just pick up part of it..
09:19:21 <Eduard_Munteanu> Baughn, yes, but not when walking back the history, for example bisecting.
09:19:29 <Baughn> You get a non-working codebase if darcs decides that patches are independent which in fact aren't
09:19:45 <Baughn> It's got only the text to work against, after all.
09:19:53 <Eduard_Munteanu> Baughn, yeah.
09:20:33 <c_wraith> I just wish there was a darcs command to add a dependency to a patch similarly to the amend-record command.  unless you can add dependencies with amend-record?
09:20:34 <Eduard_Munteanu> It would be nice if you could annotate logical dependencies between patches. It would be useful in Git as well.
09:20:44 <c_wraith> darcs can annotate logical dependencies
09:20:50 <c_wraith> the --ask-depends flag
09:20:53 <Baughn> Eduard_Munteanu: Still. For some given set of patches, any reordering of the patches internally in that set (consistent with the graph) will not alter the produced codebase by a single byte
09:21:07 <Eduard_Munteanu> c_wraith, logical in the sense of "these two patches look independent to me, but you say they aren't"
09:21:13 <Baughn> Eduard_Munteanu: It's just a bit hard sometimes to figure out what set the writer of some particular patch was looking at when he wrote it..
09:21:17 <joe3> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15485#a15485
09:21:25 <Baughn> Would be nice if it'd annotate that automatically
09:21:30 <c_wraith> Eduard_Munteanu: how is that not what --ask-depends does?
09:21:37 <Eduard_Munteanu> Baughn, hm, it's not really possible.
09:21:38 <joe3> [parse_usb_signals.hs:24:9-17] *Main GOA> :r
09:21:38 <joe3> Ok, modules loaded: Main.
09:21:38 <joe3> *Main GOA> :break 24
09:21:38 <joe3> Breakpoint 3 activated at parse_usb_signals.hs:24:9-17
09:21:38 <joe3> *Main GOA> main
09:21:41 <joe3> Stopped at parse_usb_signals.hs:24:9-17
09:21:43 <joe3> _result :: IO () = _
09:21:46 <joe3> (0.00 secs, 0 bytes)
09:21:48 <joe3> [parse_usb_signals.hs:24:9-17] *Main GOA> :t dplus
09:21:51 <joe3> <interactive>:1:0: Not in scope: `dplus'
09:21:51 <Baughn> joe3: Please don't spam
09:21:53 <Eduard_Munteanu> c_wraith, nah, I was just asking.
09:21:53 <joe3> sorry for pasting the above lines here.
09:21:57 <Eduard_Munteanu> joe3, stop pasting!!!
09:22:07 <joe3> sorry folks.
09:22:07 <Eduard_Munteanu> joe3, use hpaste.org
09:22:21 <joe3> the code is at http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15485#a15485
09:22:29 <Baughn> Eduard_Munteanu: I mean, record the full set of patches checked out /at time of recording/, as well as the computed minimal set of dependencies
09:22:31 <c_wraith> Eduard_Munteanu: Oh.  Yes, you can specify that a patch has logical dependencies on other patches at record-time.
09:23:04 <joe3> i am trying to use ghci to read the value of dplus or dminus by setting a breakpoint in the code and then running till then.
09:23:08 <Eduard_Munteanu> I see.
09:23:16 <Heffalump> c_wraith: I submitted a patch to add --ask-deps support to amend-record on Wednesday.
09:23:16 <joe3> but I get the message of "Not in scope"
09:23:28 <Heffalump> But it hasn't got in yet, so I don't know if it'll make it into the 2.4 release.
09:23:29 <joe3> i think I am missing something small.
09:23:45 <c_wraith> Heffalump: will it work if there are no unrecorded changes in the repo?
09:24:07 <Heffalump> c_wraith: yes (as does the existing --edit option)
09:24:14 <joe3> can someone help? All I am trying to do is see the value of the variable dminus/dplus(at lines 20 & 21) from ghci.
09:24:20 <c_wraith> Heffalump: awesome.
09:24:34 <joe3> Could it be that the lazy module is doing something funny here.L
09:24:37 <joe3> Could it be that the lazy module is doing something funny here.?
09:24:38 <Heffalump> the only thing it won't do is allow you to remove existing deps.
09:25:04 <c_wraith> I think unrecord is acceptable in that case.
09:25:59 <joe3> but I can examine the values if I break into the "getdata" function?
09:26:02 <joe3> but I can examine the values if I break into the "getdata" function.
09:26:17 <skorpan> come again?
09:26:29 <joe3> skorpan: me?
09:28:46 <joe3> can someone help me, please?
09:29:31 <joe3> I am trying to examine a value from ghci and ghci complains "Not in Scope". Could lazy module cause this?
09:30:17 <mreh> joe3: what do you mean examine a value?
09:30:48 <joe3> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15486#a15486
09:31:02 <joe3> mreh: the code is above and I load that code from ghci
09:31:09 <mreh> joe3: are you trying to debug it?
09:31:22 <joe3> mreh: I have a breakpoint at line 21 or 24.
09:32:01 <mreh> joe3: there's a good guide on the haskell.org about the debugger, try reading that before you go diving in
09:32:02 <joe3> mreh: not exactly debugging it, but am trying to use it as interpreter so that I can examine some patterns in "dminus" or "dplus" from the command line.
09:32:23 <kamatsu> Lemmih: mailed you the patch for primitives module bindings :)
09:32:47 <joe3> mreh: i can read the value in the function "getdata" when I break at line 18.
09:33:06 <mreh> joe3 call the function getData and see what ghci spits out
09:33:12 <mreh> ghci executes IO for you
09:33:30 <joe3> mreh: that is smart.. facepalm!! thanks..
09:33:32 <Neuromancer> as i understand it, map takes a function and a list, and applies the function to every element in the list; now, if the function in map needs 2 more variables except the list, can i somehow pass them?
09:33:39 <mreh> you would have to define it as a top level function so it is in scope
09:33:44 <mreh> joe3 ^^
09:33:54 <joe3> mreh: thanks, will do so..
09:33:56 <koeien37> partial application
09:34:05 <ben0x539> Neuromancer: Of course, in a variety of ways.
09:34:11 <koeien37> > let f a b c = a + b + c in map (f 3 2) [1,2,3,4,5]
09:34:12 <lambdabot>   [6,7,8,9,10]
09:34:12 <kamatsu> Neuromancer: you can do this with partial application, closures, or a state monad
09:34:48 <Botje> Neuromancer: map (\x -> f foo bar x)
09:35:01 <Botje> which is usually written map (f foo bar)
09:35:41 <dh_> is there a way to get run time type info in haskell ?
09:35:46 <Olathe> map f will give you a list of functions.
09:36:02 <joe3> mreh: and it works like a charm. thanks a lot. I guess there is an advantage to having a top-level function instead of all your functions as let's..
09:36:04 <Neuromancer> Botje: my function has to follow that convention then, though, right? so that if i have ((f x)y)z, that z is an element from the list
09:36:06 <Olathe> dh_: Yes, with Dynamic, I think it's called.
09:36:19 <Botje> Neuromancer: yes. Although there are tricks with flip
09:36:23 <Botje> @pl \x -> f foo bar x
09:36:23 <lambdabot> f foo bar
09:36:24 <kamatsu> dh_: but typically, you shouldn't need that sort of thing
09:36:31 <Botje> @pl \x -> f x foo bar
09:36:31 <Olathe> > typeOf 5
09:36:31 <lambdabot> flip (flip f foo) bar
09:36:32 <lambdabot>   Integer
09:36:33 <kamatsu> dh_: usually type information disappears
09:36:33 <ben0x539> Neuromancer: Yeah, but you can easily define a new function that is just like your old function except with another order of arguments.
09:36:41 <Olathe> > show $ typeOf 5
09:36:42 <lambdabot>   "Integer"
09:37:07 <dh_> Olather: I like rtti. for example , str = show .
09:37:19 <Olathe> What's rtti ?
09:37:30 <dh_> I guess I like Dynamic then static. I want to be able to program the type system.
09:37:42 <dh_> RTTI : run time type system.
09:38:01 <Olathe> Ahh, OK
09:38:07 <kamatsu> dh_: you can program the type system statically
09:38:17 <kamatsu> dh_:  the whole reason the type system is there is to provide static checking
09:39:12 <dh_> for example : I want give alias to 100 functions, but str = show is not allowed, I have to give a type to str first. So if I can get the type of show at run time, and assign it to str, that would be nice.
09:39:38 <Saizan_> dh_: how is str = show not allowed?
09:39:41 <Heffalump> dh_: just turn off the monomorphism restriction and str = show will be fine
09:39:51 <Heffalump> or give str an explicit type signature
09:39:56 <Heffalump> or an argument, e.g. str x = show x
09:40:01 <Botje> dh_: you can just type :t show
09:40:06 <Botje> :t show
09:40:07 <lambdabot> forall a. (Show a) => a -> String
09:40:16 <Botje> put that as type for str and it'll work.
09:40:47 <dh_> :t show is with ghci. I'm talking about a piece of code that get type of show.
09:40:48 <lambdabot> parse error on input `of'
09:40:51 <kamatsu> also, not sure why you want to do this? some kind of abstraction?
09:41:02 <kamatsu> dh_: yes, that sounds like you're doing it wrong
09:41:35 <kamatsu> if you want behavior that is different depending on type, you use a typeclass.
09:42:34 <dh_> kamatsu: I want to dynamic modify code when it's running.
09:42:48 <kamatsu> dh_: why?
09:43:29 <kamatsu> we have libraries, if you have a really good reason to do it, but i suspect that you might be able to solve this problem without it
09:43:38 <Olathe> dh_: There are usually ways to get the benefits of modifying code without needing to modify code.
09:43:43 <dh_> for exmaple , if I'm developing an opengl program, while the code is running , I would like to modify a few function, watch the effect directly.
09:43:58 <kamatsu> sounds like you want LISP
09:44:05 <kamatsu> or erlang
09:44:07 <dh_> yes, or python :)
09:44:23 <kamatsu> is there any reason behind this?
09:44:30 <kamatsu> or do you just not want to recompile your program/
09:45:00 <kamatsu> Haskell doesn't run in a VM
09:45:01 <Heffalump> there are ways to dynamically modify bits of your code, check out e.g. xmonad, or hint.
09:45:05 <dh_> yes, recompile waste time. and interactively developing programming is very effective.
09:45:19 <kamatsu> thif you want interactive development, we have ghci
09:45:29 <aep> runhaskell :P
09:45:32 <kamatsu> but you need to restart your program to observe changes
09:45:53 <kamatsu> the reason we don't have interactive development is that haskell doesn't run in a virtual machine
09:45:57 <Heffalump> do you just want to dynamically modify bits that will be well-known in advance?
09:46:27 <dh_> Heffalump: no, I don't know which piece of code need to modify in advance.
09:46:42 <kamatsu> dh_: why are you using haskell?
09:46:44 <Heffalump> so you might want to modify absolutely any part of your program?
09:46:48 <Heffalump> if so, I suggest not using Haskell.
09:46:53 <dh_> ghci is great. is it possible to run a opengl loop within ghci ?
09:47:05 <dh_> I like haskell , many things are exciting .
09:47:06 <kamatsu> sure, but you can't modify your code while it's running
09:47:19 <kamatsu> arbitrarily
09:47:22 <medfly> someone is going to be disappointed
09:47:54 <dh_> I think haskell's plugin in architechture use dynamic's as I need. Just didn't read it yet.
09:48:11 <kamatsu> dh_: not really, you can't just swap in and out arbitrary functions at run-time
09:48:17 <kamatsu> you have to specify the functions that you want
09:48:18 <conal> ongoing discussion about program proving at http://www.reddit.com/r/programming/comments/akhvr/reflections_on_a_holy_grail_functional_reactive/c0i2gsd .  I welcome input.
09:49:40 <kamatsu> dh_: the reason we can't do the sort of thing you want is the same reason why we're faster than all the languages which can.
09:49:42 <Saizan_> dh_: there's no builtin support for hot swapping of code, though you can do it via a table, since you can load code at runtime with hint or the ghc-api directly
09:50:07 <dh_> if you have a server running continuously , and you cannot restart the system ( bank system , for example) , and you find a small bug, then dynamic swap code with be good.
09:50:42 <Heffalump> dh_: the kind of thing xmonad does might work well there
09:50:45 <kamatsu> Right, but this problem is solved by having a fairly dumb load distributing process and several processes
09:50:52 <medfly> there are ways to get around having to swap code
09:50:56 <medfly> int hat case
09:50:57 <dh_> Hellfalump: thanks, I'll read that .
09:50:59 <kamatsu> you could restart each process separately and have no downtime
09:51:51 <Heffalump> which is basically the same as what Erlang does, if I understand that correctly - i.e. pass the entire state into the restarted process
09:51:53 <dh_> what if the system is designed from the beginning as a one process program ? ( I know it's wrong )
09:52:17 <osaunders> Do you think Erlang is a better choice of language for writing high performance servers?
09:52:45 <Olathe> osaunders: Yes.
09:52:46 <dh_> sometimes I choose a language by their syntax or things like that :) I prefer haskell .
09:52:47 <kamatsu> osaunders: Erlang gives you automatic restarting and distribution, but haskell gives you type-based assurance
09:53:20 <Heffalump> osaunders: I doubt it, because i have the impression it doesn't produce code that is all that fast, but it certainly is a very good language for designing distributed things, which may make it a good choice if by "high performance" you mean "scalable"
09:53:28 <dh_> Erlang may be better as a server language, but I just don't like it ...
09:53:34 <kamatsu> dh_: if it's designed as a one process program, it's crap
09:53:50 <Olathe> Are there any good servers written in Haskell ?
09:53:57 <Olathe> I'd like to check them out :)
09:54:02 <Heffalump> dh_: there is no reasonable way to replace arbitrary existing code in a running process where no account was taken of the need to replace that code ahead of time
09:54:03 <osaunders> Olathe: Good question.
09:54:06 <dh_> I know it's crap, but that 's the real thing happened in industry.
09:54:14 <kamatsu> dh_: not in haskell it didn't
09:54:31 <Olathe> dh_: You could probably write a Haskell interpreter that would do what you wanted.
09:54:42 <kamatsu> and sacrifice performance greatly
09:54:49 <kamatsu> but if it's just for interactive development, it'd be ok
09:54:49 <Olathe> dh_: Short of that, you probably can't do it with Haskell.
09:55:19 <dh_> I guess a mix of dynamic and static type checking is good.
09:55:42 <kamatsu> dh_: i guess dynamic typing is evil and you should specify the range of types you want explicitly.
09:55:45 <Heffalump> in theory you could write large parts of your code to go through some kind of dispatch operation where you could splice new things in
09:55:58 <Heffalump> but it'd be pretty ugly and Haskell won't really help you make it work well
09:56:26 <kamatsu> also, typing isn't the reason you can't hot-swap code.
09:57:17 <kamatsu> if i give my magic haskell interpreter that hot-swaps code some haskell code, it would have to type-check it and ensure the type i give unifies to the same type that was already declared
09:57:30 <kamatsu> but apart from that, the type system would have nothing to do with it
09:57:55 <ksf> you could hot-swap haskell code right now, with some additional work
09:58:19 <ksf> uh, wait. I'm not sure whether ghc-lib allows you to unload stuff.
09:59:18 <ksf> hum. we got .so support by now, so I guess it _should_ work.
09:59:31 <Ke> \o/
09:59:35 <ksf> if in doubt, wait for the llvm stuff to be ready.
09:59:44 <ben0x539> Clearly the right way to go about this is to FFI dlopen() in
09:59:56 <Ke> ksf: so there will be llvm?
10:00:04 <ksf> .oO( hot cross-module inlining ftw )
10:00:17 <Ke> =o)
10:00:18 <ksf> there's a paper about preliminary stuff, yes.
10:00:25 <Ke> =D
10:00:38 <ksf> dunno if the code is public, yet, but preliminary results are promising
10:00:45 <Ke> ksf: http://www.xkcd.com/678/
10:00:50 <osaunders> @google define: llvm
10:00:51 <lambdabot> No Result Found.
10:01:10 <ksf> like a 20% or such speedup in some programs due to better register allocation
10:01:17 <Ke> ksf: so what's the size of dynamically linked hello world?
10:01:23 <CalJohn> http://www.cse.unsw.edu.au/~pls/thesis/davidt-thesis.pdf
10:01:29 <CalJohn> ^ llvm for ghc
10:01:33 <ksf> ...and no performance benefit by enabling the llvm optimizer
10:01:37 <mux> Ke: 7.3kB here on FreeBSD, after stripping :-)
10:01:42 <ksf> dunno, haven't installed 6.12 yet
10:01:47 <Ke> mux: very nice
10:02:23 <Ke> mux: how about the statically linked one?
10:02:29 * ksf wonders whether we can get it down to the same size as asm with supercompiling
10:03:30 <mux> Ke: 390kB after stripping
10:03:42 <Ke> mux: great
10:03:48 <mux> 595kB before stripping
10:03:59 <CalJohn> i don't think supercompiling with reduce machine code size much
10:04:05 <CalJohn> s/with/will
10:04:06 <Ke> so my point was extremely valid
10:04:47 <ksf> that'd be some 14 bytes for the string, and a couple for the write and exit syscalls.
10:04:53 <ksf> and some elf overhead.
10:05:17 <ksf> I guess it depends on whether the stg gets supercompiled, too.
10:05:31 <ben0x539> How do I link dynamically with ghc 6.12?
10:05:47 <ksf> I've heard that it's enabled by default on linux
10:05:54 <mux> ben0x539: with 6.12.1, you must have built with the --enable-shared configure flag
10:06:07 <mux> if you have done that, you can use the -dynamic flag
10:06:34 <mux> if you want to produce a shared library then you'll also need -fPIC -shared IIRC
10:06:34 <ben0x539> mux: That seems to do it, thanks. I tried -shared and utterly failed :)
10:06:45 <mux> yeah, -shared is different
10:06:50 <mux> check with ldd now
10:06:54 <ben0x539> 16K on a 64bit linux system for a dynamic hello world
10:08:42 <Ke> are there architecture limitations to the dynamic linking
10:08:49 <Ke> like x86 only or so
10:09:29 <ben0x539> Well, it works on x86_64 :>
10:09:39 <Ke> arm mips?
10:10:02 <SamB_XP_> GHC works on ARM right now ?
10:10:04 <ben0x539> Do not have either :V
10:10:27 <Ke> SamB_XP_: also dynamic linking?
10:10:32 <SamB_XP_> that was a question
10:10:50 <Ke> well at least there is gcc backend
10:11:16 <mux> it works on ppc too
10:11:31 <mux> x86, x86_64 and ppc are the only targets supported for now, I believe
10:11:37 <Ke> http://gentoo-portage.com/dev-lang/ghc
10:13:05 <SamB_XP_> you mean for building C-compatible .so/.DLL/etc. plugins/libraries?
10:13:23 <BrianB04> Alright, I'm curious how something would be written in haskell. Fizbaz is the programming exercise I'm thinking of. If a number in a list x % 3 = 0 then replace with fiz, otherwise if x % 5 = 0 replace with baz, otherwise just spit out the number...how could that be done?
10:15:57 <Ke> SamB_XP_: haskell compatibility is good enough for me
10:16:13 <Ke> most libraries are in C anyways
10:16:44 <dh_> BrainB04: haskeller just say: your problem is not type safe, and we'll not solve it.
10:16:52 <mux> > let foo x | x `mod` 3 == 0 = "fiz" | x `mod` 5 == 0 = "baz" | otherwise = show x in map foo [1..20]
10:16:53 <lambdabot>   ["1","2","fiz","4","baz","fiz","7","8","fiz","baz","11","fiz","13","14","fi...
10:17:00 <mux> BrianB04: something like that
10:17:30 <CalJohn> fiz and baz?  the game is called fizzbuzz
10:17:31 <SamB_XP_> well, as opposed to GHC's own dynamic linker/loader
10:17:47 <BrianB04> CalJohn I have heard it may ways, and fizbaz was the first one to come to mind.
10:17:50 <SamB_XP_> the one used for GHCi and TH
10:18:44 <CalJohn> i always wonder whether TH is worth the time investment
10:19:01 <CalJohn> is TH a big help?
10:19:25 <koeien37> depends on your problem of course
10:19:37 <koeien37> i've toyed around a bit with it
10:19:58 <SamB_XP_> it can be, especially if someone else already wrote the hard part ;-)
10:26:29 <jdavis> I'm trying to create my own exception class, and I get "You need -XDeriveDataTypeable to derive an instance for this class". What does that mean?
10:26:30 <Heffalump> I find it has a lot of annoying restrictions
10:26:51 <Heffalump> jdavis: it means you need to enable that language extension to do deriving Data or deriving Typeable
10:26:58 <koeien37> probably you have deriving (Typeable) there
10:26:59 <Heffalump> probably deriving Typeable in this case
10:27:09 <jdavis> Heffalump: why is that not allowed normally? Why is it an extension?
10:27:14 <koeien37> it's not H98
10:27:53 <jdavis> Why would it be prohibited, though, can you derive an instance of any class?
10:28:00 <koeien37> no, you can't
10:28:00 <Heffalump> no
10:28:15 <Heffalump> the compiler has to know something about the class to be able to derive an instance of it
10:28:15 <koeien37> the compiler cannot guess your instances
10:28:27 <koeien37> for Eq, Show, Read, Ord, it's possible
10:28:28 <jdavis> Does H98 not really support exceptions well then?
10:28:41 <koeien37> (maybe I miss a few)
10:28:46 <Berengal> H98 implements exceptions in libraries
10:28:56 <Berengal> But we're on H2010 now
10:29:00 <SamB_XP_> Berengal: say what ?
10:29:00 <koeien37> also for Data and Typeable, but that's an extension of H98
10:29:23 <Berengal> SamB_XP_: It's not hard to code up your own exception monad, is what I meant.
10:29:35 <SamB_XP_> Berengal: ah, true
10:29:59 <SamB_XP_> much more sensible than what it sounded like you meant ...
10:30:48 * Berengal notes English lacks denotational semantics
10:31:16 <osaunders> Is the Ix class in Data.Array supposed to be short for index?
10:31:17 <koeien37> what about Haskell, then?
10:31:24 <koeien37> yes, I'd think so
10:31:31 <jdavis> Is there an example of how to use the standard exceptions in H98 without ghc extensions?
10:31:49 <osaunders> jdavis: Learn You A Haskell.
10:31:55 <osaunders> One of the later chapters.
10:32:03 <osaunders> The Input/Output one I think.
10:33:09 <gwern> arggh. I was going to buy TAPL but all my gift cards are for borders and amazon has it 15$ cheaper
10:33:16 <BrianB04> mux: Thanks, I had forgotten that cases can be done that way.
10:33:31 <jdavis> osaunders: ok, thanks. Looking now.
10:33:39 <gwern> dang it borders, your online site is just a skin around amazon, stop charging so much
10:33:46 <mux> BrianB04: this syntactic form is called pattern guards
10:33:49 <osaunders> jdavis: It's right at the bottom of the page.
10:36:10 <sinelaw> Evening, fellas
10:36:11 <lambdabot> sinelaw: You have 1 new message. '/msg lambdabot @messages' to read it.
10:36:59 <bfh6558> brain fart, setting up a new vim install.  Tab in haskell == ? spaces?
10:37:06 <koeien37> spaces!
10:37:08 <ray> 8
10:37:12 <Heffalump> gwern: borders in the uk just went bust :-)
10:37:14 <koeien37> no tabs, please
10:37:14 <ray> and don't use them
10:37:21 <bfh6558> yeah i know
10:37:44 <bfh6558> but i still need to know how many spaces to insert when i press tab in a .hs file
10:37:48 <ray> your editor is wrong if it displays tabs as anything besides enough whitespace to make the next column a multiple of 8
10:37:48 <bfh6558> or rather would like ti know
10:37:53 <koeien37> i have set that number to 4
10:37:55 <ray> and you are wrong if you use tab characters in your source
10:38:04 <ray> koeien37: you have instructed your editor to be wrong
10:38:05 <koeien37> but all my tabs are converted to spaces
10:38:20 <koeien37> ray: why? I just like to press TAB instead of 4 times space bar?
10:38:25 <ray> pressing the tab key should intelligently push you in one level of layout
10:38:31 <bfh6558> yes vim very easily will convert tabs to spaces, inserting 8 spaces instead of a /t
10:38:34 <ray> but that seems to be equivalent to the halting problem
10:38:48 <koeien37> i like to have indents in multiples of 4
10:38:53 <koeien37> :set et sts=4 ts=4 sw=4
10:38:56 <ray> koeien37: if you've set your editor to display tab chracters as 4 columns, you're wrong
10:39:06 <ray> the other settings, knock yourself out
10:39:24 <koeien37> i may have set that, but if somebody gives me files with tabs, i will shoot her/him immediately
10:39:31 <bfh6558> wrong right? aslong as he sticks to his style consistently
10:39:32 <koeien37> so that's okay
10:39:33 <bfh6558> i can read his code
10:39:45 <Heffalump> koeien37: what if they sent it via email?
10:39:52 <koeien37> then I'll smite them :)
10:39:57 <ray> a right arrow is the ideal way to display tab characters
10:40:03 <koeien37> i was called god earlier today, so that shouldn't be a problem
10:40:14 <ray> a right arrow that is long enough to make the next column a multiple of 8
10:40:17 <ray> not 4 or 6 or 13
10:40:42 <bfh6558> 2*4=8?
10:40:45 <ray> if your screen is really so narrow that this provides problems, i will send you a monitor on which it is not a problem
10:40:49 <bfh6558> yay arithmatic
10:41:01 <bfh6558> no way? i have a 800x600 and it sucks
10:41:05 <ray> you need only pay for shipping, because i am poor and unemployed
10:41:13 <ray> but i sure have plenty of monitors
10:41:40 <bfh6558> :( i have an it job thats consistent but my house costs to much and im lacking moniters. wanna trade?
10:41:43 <koeien37> hmm, i have 1920 + 1680 pixels, so that doesn't count i guess :P
10:41:47 <ray> yes
10:42:04 <ray> i would keep the job and live on the street so it sounds ok
10:42:15 <bfh6558> no way not in michigan
10:42:19 <bfh6558> way to cold
10:42:32 <bfh6558> dont say your from canada cus then i just loose
10:42:44 <ray> if i could i'd move to svalbard :)
10:42:56 <bfh6558> alright but thank you for the information of 8 spaces for tab emulation
10:43:01 <bfh6558> i now must go prepare lunch
10:43:06 <bfh6558> aka penut butter jelly
10:43:14 <ray> i'm from connecticut, it's pratcically tropical here
10:43:18 <ray> practically
10:43:44 <bfh6558> wtb your falls
10:50:30 <dh_> what is the theory background for pattern match ? is it turning complete ? I guess not, because we don't have pattern for  n < 0 , right ?
10:57:37 <sinelaw> dh_, wha?
10:58:10 <dh_> pattern match's theory background, is there a mathematic background of pattern match of haskell?
11:04:13 <jlouis> dh_: there are some interesting CS papers on writing fast pattern matchers
11:04:45 <dh_> jlouis: thanks.
11:04:48 <Lemmih> jlouis: URL?
11:06:40 <jlouis> Lemmih: let me find the one I had in mind
11:07:26 <dh_> is there a fold that do not enforce the order of operation ?  for example foldr assume the operator is left associative ?
11:07:39 <koeien37> "left associative"
11:07:46 <koeien37> what is a "left associative" operator?
11:08:05 <dh_> a + b + c  == (a + b) + c
11:08:11 <jlouis> Lemmih: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.48.1363 Sestoft derives a pattern matcher by partial evaluation. It is rather interesting and an easy read.
11:08:16 <koeien37> how did you define a + b + c there?
11:08:22 <dh_> + here is a general operator .
11:08:34 <koeien37> yes, so a + b + c is not defined, it can mean either a + (b + c) or (a + b) + c
11:08:47 <koeien37> before you can write a + b + c for a binary operator, you'll have to prove associativity
11:09:01 <koeien37> or establish a convention for your associativity
11:10:26 <dh_> well, my question is : I need a fold  that can work parallel if the operator satisfy associative law ( a op b)  op c = a op ( b op c )
11:11:42 <Lemmih> jlouis: Thanks.
11:12:12 <twanvl> dh_: there is Data.Foldable.fold
11:12:32 <dh_> twanvl: thanks.
11:12:36 <twanvl> but that doesn't work in parallel because you usually don't want that
11:14:33 <dafra> hello, anybody uses wxHaskell out there ?
11:16:14 <dh_> @src fold
11:16:15 <lambdabot> Source not found. :(
11:16:24 <dh_> @src Data.foldable.fold
11:16:25 <lambdabot> Source not found. Where did you learn to type?
11:16:39 <dafra> @src foldr
11:16:39 <lambdabot> foldr f z []     = z
11:16:39 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
11:17:14 <dh_> fold use foldMap , and foldMap use foldr ,  bad
11:17:40 <dh_> so I guess there is no fold run's in O(log n ) in haskell now.
11:18:06 <dafra> fold is O(n) for lists
11:18:27 <dafra> how do you want to fold n items in log(n) ?
11:19:07 <dh_> when a operator satisfy associative law, we can fold in parallel
11:19:13 <dafra> for instance, to sum n numbers, you ned n - 1 additions
11:19:17 <dh_> with multiply cpu.
11:19:47 <dh_> things like cuda, ( nvidia )
11:20:00 <monochrom> If you have 1000000 items you may expect to fold in log 1000000 time but using 1000000 CPUs.
11:20:22 <dh_> GPU is already appeared , guys.
11:20:36 <dafra> there are parallel ways to fold
11:20:40 <c_wraith> dh_: you seem to be mistaking "parallel" with "magical"
11:20:40 <monochrom> And one GPU has 1000000 CPUs?
11:20:41 <dh_> GPGPU, general programming on Graphic processor unit.
11:21:01 <shambler> you still need to access n items
11:21:09 <shambler> no matter how much cpu you have
11:21:12 <shambler> many
11:21:26 <BrianB04> Okay, new question: Why does something like this work with mapM: (putStrLn . someFunction) but not with map?
11:21:28 <monochrom> Honestly tell me how many CPUs you have at your disposal.
11:21:30 <dh_> currently hundred of processing unit is feasible.
11:21:33 <dafra> CPUs can access numbers in parallel
11:21:38 <Zao> GPUs tend to be rather unsuitable for everything not trivially parallelizable and batchable.
11:22:01 <c_wraith> dh_: there are very significant practical issues that need to be considered.
11:22:28 <monochrom> I see that you're just hiding behind the "feasible" faÃ§ade.
11:23:01 <aavogt> BrianB04: map works too, it's just the result type   [IO ()]   isn't as useful as the one you get with mapM   IO [()]
11:23:05 <dafra> map builds a list of actions, mapM builds an action
11:23:13 <koeien37> mapM = sequence . map
11:23:16 <dafra> you can run actions, not lists
11:23:19 <BrianB04> aavogt: I get errors when running that through map.
11:23:26 <j4cbo> for one thing, your GPU may have 250 shader units, but it sure doesn't have 250 memory buses
11:23:35 <koeien37> ehm, (sequence .) . map
11:24:12 <monochrom> If you have k CPUs, you can expect to fold a list of n items in n/k time. This is not log n.
11:24:18 <dh_> I'm think about a fold that can run on goole's map reduce architecture, that's why neither foldl nor foldr is good enough.
11:24:27 <BrianB04> aavogt: No instance for (Show (IO ()))
11:24:31 <Ke> actually doesn't some gpu's contain 1600 stream processors nowadays
11:24:38 <Ke> don't
11:24:44 <Zao> Ke: Depends on how you count.
11:24:48 <j4cbo> dh_: parallelism is *not* that simple
11:24:51 <c_wraith> dh_: but don't think that you can run map-reduce on a GPU
11:25:02 <Zao> Much like hyperthreading, it only floats if you have workloads using all kinds of processing units.
11:25:25 <Ke> yup
11:25:28 <dh_> there is a paper on map reduce on GPU. ( just numbers, floats )
11:25:34 <j4cbo> dh_: mapreduce isn't fold, it's mapreduce :P
11:25:57 <dh_> fold is reduce.
11:26:03 <monochrom> Then just use mapreduce.
11:26:09 <c_wraith> Right.  But the map step is not a fold
11:26:14 <j4cbo> no it isn't; the various fold primitives provide guarantees about ordering that reduce doesn't.
11:26:17 <koeien37> map is a fold, isn't it?
11:26:29 <monochrom> "what is a fold that can run on mapreduce?" "mapreduce is a fold that can run on mapreduce"
11:26:54 <c_wraith> koeien37: true.  fold is more general than mapreduce
11:27:02 <dh_> the point is : foldl and foldr added unnecessary order here,
11:27:04 <j4cbo> koeien37: map can be expressed as a fold, but not all folds can be expressed as maps
11:27:06 <monochrom> You're asking for a new invention that fills a much needed gap.
11:27:51 <j4cbo> dh_: you want MapReduce, not fold. :P splitting out the "map" step is why MapReduce works so well.
11:28:01 <dh_> if you reduce + over 10000 numbers, you can reduce on half of them on 1 machine, the other half on another machine.
11:28:12 <c_wraith> dh_: fold can perform actions that cannot be parallelized.  that means it's a more general construct
11:28:20 <monochrom> "hi I need an id that works on mapreduce"
11:29:13 <dafra> btw, nobody uses wxHaskell ? just tried it and need help
11:29:23 <j4cbo> dh_: and you expect a compiler to be able to determine that for you?
11:29:28 <dh_> I agree foldl or foldr can perform actions that cannot be parallelized, but when the action need to be parallelized, then we need a new fold.
11:29:34 <monochrom> I haven't used wxHaskell
11:29:37 <Ke> isn't wxgtk bad
11:29:46 <twanvl> someone should add parFoldMap :: Monoid m => (a -> m) -> [a] -> m to Control.Parallel.Something
11:29:56 * twanvl has used wxhaskell a long time ago
11:30:08 <c_wraith> mapreduce is really an entirely different architecture
11:30:26 <dafra> hsGTL is harder to install, and ugly
11:30:26 <c_wraith> that's why its implementation is the exercise in the RWH chapter on parallel processing
11:30:42 <dh_> j4cbo:  if op is left associative , foldl, else if op is right associative foldr , else parallel fold
11:31:30 * hackagebot upload: pandoc 1.4 - Conversion between markup formats (JohnMacFarlane)
11:31:32 <dh_> else if op satisfy  associative law , use parallel fold
11:31:32 <c_wraith> If the op isn't associative, parallel sounds very wrong.
11:32:07 <dh_> if op is left associative , foldl, else if op is right associative foldr, else  if op satisfy  associative law , use parallel fold
11:32:19 <c_wraith> How do you compose results from a non-associative operator?
11:32:29 <dafra> twanvl: i want to change the text of a label, is it possible
11:32:40 <j4cbo> ok, go write that "is an arbitrary function associative?" oracle for us :)
11:33:10 <koeien37> non-associative operators, my head hurts
11:33:26 <therp> j4cbo: well, everything can be done unless termination matters :)
11:33:27 <dh_> for non-associative operator, use foldl or foldr
11:33:27 <monochrom> (/) is a non-associative operator.
11:33:39 <twanvl> dafra: have you tried  set myLabel [ text := "asdfasdf" ]
11:33:55 <koeien37> (/) is just (uncurry (*) .) . (id *** recip)
11:33:57 <j4cbo> therp: yeah, but that doesn't mean one wants to do it...
11:34:00 <shambler> @src foldr'
11:34:01 <lambdabot> Source not found. I am sorry.
11:34:04 <dh_> j4cbo: that's hard, and I'm not a mathematician, but someday there will be.
11:34:05 <shambler> @src foldl'
11:34:06 <lambdabot> foldl' f a []     = a
11:34:06 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
11:35:35 <dafra> twanvl: i know lable only as part of a layout
11:36:00 <dafra> twanvl: can i do : la <- label [text := "hello"] ?
11:36:02 <dh_> http://www.csd.uoc.gr/~hy529/documents/mars_pact08.pdf , map reduce on GPU
11:36:52 <dh_> j4cbo: at least in practice, we can define a database of associative of operators.
11:36:59 <twanvl> dafra: I don't know, have you looked at the documentation?
11:37:46 <twanvl> dafra: it is called staticText
11:39:43 <dh_> does anybody knows if the set (or whatever) of operators formed an algebraic structure ? so we can find the associative property of each operator ?
11:40:17 <dafra> twanvl: your set ... works with a button, thx
11:40:45 <dafra> twanvl: i need to find a simpler control
11:40:50 <twanvl> dh_: *all* operators? on all types?
11:41:16 <twanvl> dafra: staticText should do the trick if you want just a label
11:41:32 <dh_> maybe just operator that defined by lambda calculus.
11:42:07 <dafra> twanvl: that works, thank you very much
11:42:08 <jlouis> Mr. L. Calculus doesn't really define operators
11:42:28 <j4cbo> i think you mean "functions"?
11:42:46 <dafra> twanvl: btw, do you know how to set the color of the text ?
11:43:07 <dh_> + is an operator and a function.
11:43:19 <Berengal> operator == function
11:43:27 <twanvl> dafra: no, but it should be somewhere in the documentation (http://wxhaskell.sourceforge.net/doc/)
11:43:53 <koeien37> a binary operator is a function A x A -> A imo
11:44:03 <koeien37> often written infix
11:44:30 <dafra> twanvl:  i found this doc, but not always easy to understand. will be easier after some practice
11:44:39 <dh_> I think I made a confusing here on left associative and right associative, they are just syntax sugar, not property of operators.
11:45:30 <j4cbo> koeien37: but that's already more restrictive than what fold can do.
11:45:33 <DrTeggy> Huh?  No, dh.
11:45:43 <Berengal> Fortress has implicit parallellism of associative operations
11:46:01 <koeien37> j4cbo: that's correct.
11:46:13 <twanvl> j4cbo: you can build the normal foldr and foldl from an associative fold
11:46:16 <koeien37> "operator" = "function" is also often used
11:46:27 <dh_> like we define application as left associative , so f g x is (f g) x , while Int->String ->Int is Int -> ( String->Int)
11:46:39 <twanvl> see Foldable and Endo
11:48:17 <EvanCarroll> what is the syntax to have algebraic types with record syntax.
11:48:24 <EvanCarroll> data Foo = Foo {}, Bar {}
11:48:40 <Berengal> EvanCarroll: Pipes, not comma
11:48:42 <aep> | ?
11:49:04 <EvanCarroll> thanks.
11:50:38 <dh_> twanvl: thanks, I guess I need to read another paper again.
11:54:22 <EvanCarroll> `Maybe Int` is a concrete type? How do I read 5 as a `Maybe Int` ? I can do 5 :: Int, but I can't do `5 :: Maybe Int` Is there a way to cast to a concrete type without using the type constructor?
11:54:42 <koeien37> without using the type constructor? in general, no
11:54:54 <koeien37> in this case, you could have an instance of Num for Maybe Int
11:55:03 <koeien37> not the best idea imo
11:55:31 <ben> EvanCarroll: Consider Either Int Int. How would you cast 5 to that type?
11:55:58 <EvanCarroll> I'm not sure, that's why Im asking the question =/
11:55:59 <koeien37> there is no "casting" in haskell to begin with
11:56:01 <j4cbo> you shouldn't read :: as "cast"
11:56:22 <koeien37> why not do Just 5 ?
11:56:25 <EvanCarroll> ok. well thats nomenclature, you know I'm referring to :: as cast, even if it is best referred as, "read into" or "read as"
11:56:26 <j4cbo> it's "hint, compiler, this is of this type". if the compiler knows that it's not of the type you claim it is, it'll call you out on it :P
11:56:29 <EvanCarroll> koeien37: I'm trying to learn.
11:56:31 <koeien37> "is of type"
11:56:50 <EvanCarroll> can I read 5 is of type Maybe Int ?
11:56:57 <j4cbo> but it isn't.
11:57:02 <koeien37> > 5 :: Maybe Int -- the compiler will complain.
11:57:03 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe GHC.Types.Int))
11:57:04 <lambdabot>    arising f...
11:57:09 <j4cbo> Just 5 is of type Maybe Int
11:57:32 <j4cbo> but 5 is not :P
11:57:46 <koeien37> modulo the Num instance for Maybe Int
11:58:07 <EvanCarroll> that makes sense
11:58:19 <kakjf>  Please click on this link - http://www.lostworlds.lv/go.php?1139747536
11:58:23 <ray> koeien37: well, that's just because 5 is weird
11:58:27 <koeien37> @where ops
11:58:27 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver monochrom
11:58:30 <EvanCarroll> > Just 5 :: Maybe Integer
11:58:31 <lambdabot>   Just 5
11:58:31 <koeien37> ray: yeah
11:58:38 <ray> > "5" :: Maybe String
11:58:39 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe GHC.Base.String'
11:58:40 <lambdabot>         aga...
11:58:56 <ray> against inferred type GHC.Base.String
11:59:03 * ray pats lambdabot 
11:59:38 <ray> 5 has a polymorphic type in haskell, which is good and works out well for everything but can confuse newbies
11:59:52 <koeien37> yeah. I don't know how Helium handles numeric integrals
11:59:55 <koeien37> literals*
12:00:03 <ray> probably Integer
12:00:15 <j4cbo> what instances of that are there? integer and real?
12:00:17 <ray> don't know though, because that complicates other things...
12:00:28 <koeien37> maybe it should get more attention. I've never used it myself
12:00:43 <koeien37> j4cbo: what do you mean?
12:01:04 <ray> i'm not in favor of making haskell easier for newbies
12:01:12 <ray> the existence of helium is a good compromise there
12:01:13 <koeien37> it's not haskell then
12:01:25 <koeien37> it's a simpler functional language
12:01:46 <koeien37> sometimes the error messages GHC generates can be confusing
12:01:47 <ray> some people change the actual haskell to make it easier, though
12:01:49 <CESSMASTER> everything should be hard for newbies
12:06:20 <lpjhjdh> so I'm attempting to tinker with happstack and I can't seem to get HStringTemplateHelpers working, hslogger claims to be unusable due to missing or recursive dependencies
12:06:35 <lpjhjdh> it then lists network-2.2.1.5 which I have at both system and user
12:07:05 <lpjhjdh> I can build fine with -package network
12:08:29 <lpjhjdh> what's also strange is /usr/lib/ghc-6.12.1/package.conf.d shows hslogger but unless I have it from cabal install local it claims to be unable to find -lHShslogger
12:12:06 * monochrom hopes it's ok to build haskell-platform with just ghc (and no alex, no happy, no haddock)
12:15:07 <monochrom> Oops looks like I missed an OPportunity!
12:20:23 <monochrom> Oh haha, fgl is a graph library (as in graph theory) not a graphics library. Now I remember! XD
12:20:33 <Eduard_Munteanu> Hi.
12:20:34 <koeien37> lol
12:20:50 <Eduard_Munteanu> Hm, will ask this again, couldn't find an answer a few days ago...
12:21:04 <Eduard_Munteanu> Is there any math-oriented Haskell book you'd recommend?
12:21:14 <monochrom> I was browsing the ubuntu/debian package libghc6-fgl-dev and fully wondering why it does not depend on any graphics lib. :)
12:21:18 <Eduard_Munteanu> I mean, no "Haskell for dummies".
12:22:30 <monochrom> I have read one but I have seen the title of "the haskell road to logic, maths and programming"
12:23:02 <Eduard_Munteanu> monochrom, thanks, will look it up.
12:23:32 <monochrom> Hrm, I thought Haskell Platform built its own ghc.
12:24:00 <monochrom> and haddock.
12:25:21 <monochrom> Oh haddock is consciously omitted.
12:27:00 <Igloo> haddock comes with GHC anyway
12:27:03 <mreh> a dependency in cabal install seems to be missing, i've got time=1.1.* missing
12:27:26 <mreh> s/in/for
12:27:52 <mreh> i thought cabal install was only dependent on zlib and http
12:28:07 <monochrom> OMG. Thanks Igloo
12:28:07 <mreh> and parsec and network
12:28:22 <c_wraith> mreh: are you installing with 6.12?
12:28:31 <c_wraith> 6.12 comes with many fewer libraries
12:28:37 <mreh> c_wraith, nah 6.10.4, it's the ubuntu package
12:28:40 <mreh> ghc6
12:28:48 <c_wraith> oh, hmm.  that's unexpected.
12:29:10 <mreh> i'm taking my new sporty laptop for a spin with a fancy droptop distro
12:29:12 <monochrom> ubuntu packages are splitted finely. libghc6-parsec-dev, libghc6-network-dev...
12:29:23 <Zao> Oh noes.
12:29:44 <c_wraith> also, just out of curiosity, does haskeline work properly in the ubuntu build, for you?  it didn't for me.  (delete key didn't work, in my case)
12:29:53 <monochrom> The debian and ubuntu approah seems to be splitting finely.
12:30:07 <mreh> do they have the whole of hackage on there?
12:30:11 <c_wraith> I ended up using the generic linux ghc instead of ubuntu ghc, just to get a working haskeline
12:30:16 <Eduard_Munteanu> Gentoo seems to have quite a few Haskell and Hackage packages too.
12:31:33 <mreh> c_wraith, what went wrong with the ubuntu one?
12:31:48 <mreh> ubuntu just seems to have more, and more up-to-date
12:32:07 <c_wraith> mreh: various keys just weren't recognized.  the delete key is the one I can remember, but I feel like several others didn't work, either
12:32:31 <mreh> c_wraith, oh,
12:32:59 <mreh> c_wraith, yeah, that's true, it still works though
12:33:15 <Eduard_Munteanu> Good thing they provide a binary ghc ebuild... Compiling ghc takes a lot, more than anything else it seems.
12:33:25 <Veinor> What should I introduce first if I'm teaching someone Haskell? Lists, or types?
12:33:40 <jlouis> expressions and types I'd say
12:33:45 <jlouis> then lists
12:33:50 <c_wraith> Veinor: I think the order LYAH uses works pretty well.
12:34:05 <jlouis> build on the knowledge of mathematical expressions
12:34:09 <EvanCarroll> as compaired to the current LYAH?
12:34:19 <mreh> EvanCarroll: you can't read
12:34:20 <Saizan> Eduard_Munteanu: and you need ghc to compile ghc anyway
12:34:48 <c_wraith> EvanCarroll: I just mean there are audiences LYAH isn't appropriate for, but the order it introduces material in is very good
12:34:48 <Veinor> the expected background is 'some programming knowledge'
12:35:14 <Eduard_Munteanu> Saizan, yeah, it bootstraps it using a binary ghc.
12:35:15 <mreh> c_wraith, my dog?
12:35:15 <EvanCarroll> no I read order as older =(
12:35:17 <EvanCarroll> I can't read.
12:35:21 <EvanCarroll> mreh++
12:35:32 <mreh> @karma
12:35:33 <lambdabot> You have a karma of 2
12:35:33 <Eduard_Munteanu> Saizan, just like gcc.
12:35:36 <mreh> yes!
12:35:40 <EvanCarroll> yea, LYAH has worked pretty good for me =)
12:35:43 <EvanCarroll> I like it.
12:35:49 <EvanCarroll> better than RWH anyway.
12:35:50 <dh_> @src IO
12:35:51 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
12:36:07 <Veinor> I like RWH.
12:36:07 <dh_> does anybody knows what the # here means ?
12:36:10 <c_wraith> mreh: I wouldn't use it to introduce the material to a mixed-gender group of co-workers, due solely to the "spank the monkey" test string in it.
12:36:20 <c_wraith> dh_: nothing.  It's just a legal character in an identifier
12:36:22 <mreh> c_wraith: hahahaha
12:36:38 <Veinor> I'm going to be teaching a haskell class to various people over the next week, so I need to figure out what order I'm going to introduce stuff in.
12:36:39 <mreh> i haven't seen it
12:36:45 <byorgey> dh_: it usually indicates magical GHC-specific unboxing magic
12:36:57 <DrTeggy> Veinor, starting late, eh?
12:37:04 <Zao> Veinor: Horrible monad analogy is mandatory.
12:37:31 <c_wraith> I like of like that LYAH didn't cover monads.  I know it was the next topic he wanted to get to, but I like that they're not even addressed
12:37:53 <Veinor> DrTeggy: indeed :D
12:37:54 <b_jonas> wow, strange error message
12:38:03 <Veinor> a monad is like... a spacesuit!
12:38:12 <b_jonas> http://erxz.com/pb/22479
12:38:22 <koeien37> a monad is somewhat like a monoid :)
12:38:27 <dh_> byorgey: thanks.
12:38:32 <mreh> analogies are like monads
12:38:32 <c_wraith> a monad is like a 50" 1080p plasma hdtv
12:38:40 <Veinor> it's a two-hour/day class, three days long
12:38:43 <koeien37> @quote bad explanation
12:38:44 <lambdabot> No quotes for this person. There are some things that I just don't know.
12:38:48 <koeien37> @quote explanation
12:38:48 <lambdabot> xerox says: * xerox gets sucked in a vortex of -fdisallow-overlapping-explanations
12:38:51 <Veinor> c_wraith: no, that's what understanding of monads is like
12:38:55 <koeien37> @quote endofunctor
12:38:55 <lambdabot> PhilipWadler says: I'm delighted to learn that "a monad is a monoid in the category of endofunctors"---anyone know where I can find a good tutorial?
12:39:00 <Veinor> valuable and elusive :D
12:39:00 <koeien37> @quote endofunctor
12:39:00 <lambdabot> thermoplyae says: <thermoplyae> someone finally pointed out to me that a monad is an monoid-object in an endofunctor category <thermoplyae> i have no idea how i've never seen that before
12:39:03 <EvanCarroll> @src notElem
12:39:03 <lambdabot> notElem x =  all (/= x)
12:39:14 <EvanCarroll> @src all
12:39:15 <lambdabot> all p =  and . map p
12:39:50 <chrisdone> Gracenotes: this is cool http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2364 , thanks for writing it
12:40:08 <mreh> what other languages could you write all as simply as that
12:40:13 <mreh> it speaks for itself really
12:40:21 <mjrosenb> koeien37: there is also this:
12:40:23 <mjrosenb> http://www.cvaieee.org/html/humor/programming_history.html
12:41:09 <b_jonas> mreh: write what as simply?
12:41:12 <mjrosenb> koeien37: specifically, 1990
12:41:21 <mreh> b_jonas: "all"
12:41:23 <koeien37> right
12:41:24 <koeien37> hehe
12:41:25 * sinelaw starts up matlab
12:41:32 <koeien37> 1991 - Dutch programmer Guido van Rossum travels to Argentina for a mysterious operation. He returns with a large cranial scar, invents Python, is declared Dictator for Life by legions of followers, and announces to the world that "There Is Only One Way to Do It." Poland becomes nervous.
12:41:43 <koeien37> nice
12:41:47 * mreh things matlab is the language of satan
12:42:15 <mreh> oh, uh, I tend to think rather than thing
12:42:56 <mjrosenb> mreh: while it is not pleasant to use
12:43:03 <mjrosenb> mreh: it does its job rather well
12:43:11 <EvanCarroll> zomfg that link is awesomely funny
12:43:18 <Veinor> 1987 - Larry Wall falls asleep and hits Larry Wall's forehead on the keyboard. Upon waking Larry Wall decides that the string of characters on Larry Wall's monitor isn't random but an example program in a programming language that God wants His prophet, Larry Wall, to design. Perl is born.
12:43:21 <koeien37> it has one type: matrix of complex numbers
12:43:22 <mjrosenb> mreh: just people tend to use it for things that it was never intended to be used for.
12:43:57 <b_jonas> the problem with matlab is that it's limited
12:44:10 <mreh> no, it's problem is that it has one type
12:44:17 <b_jonas> you can write some stuff loopless, but for those things that you can't and there's no builtin for them, you just can't write it in any short way
12:44:18 <mreh> there's NO type system
12:44:30 <mjrosenb> iirc, it also has some magic that looks like lambdas
12:44:31 <mreh> yeah, that's trye
12:44:35 <b_jonas> mreh: nah, there are other languages similar to that in them
12:44:45 <mreh> mjrosenb: you're thinking of mathematic
12:44:48 <b_jonas> having only a single type
12:44:53 <mreh> mathematica*
12:44:53 <smorg> I've been getting into matplotlib/numpy
12:44:55 <mjrosenb> at least this is what my roommate told me when he was taking a course that taught matlab.
12:45:06 <mjrosenb> mreh: no, they did not teach us mathematica
12:45:17 <mjrosenb> mreh: but mathematica has them as well.
12:45:23 <mreh> it does, they're nice
12:45:30 <sinelaw> b_jonas, matlab has map
12:45:49 <mreh> matlab has vectorisation
12:46:03 <b_jonas> well there's a plus side: matlab has a nice library of functions
12:46:03 <mreh> which I still don't understand
12:46:10 <b_jonas> so sometimes you do want to use it
12:46:13 <mreh> that's the reason peole use it I think
12:46:21 <sinelaw> it's called arrayfun
12:46:24 <b_jonas> sometimes you even want to call it from other languages if it has the function you need
12:46:26 <sinelaw> matlab's map
12:46:31 <EvanCarroll> ahhahahahha
12:46:37 <sinelaw> exactly.  matlab has a huge library
12:46:45 <EvanCarroll> that is one of the best computer history summaries I've ever seen.
12:46:52 <koeien37> most of the functions I needed were available in hmatrix too
12:46:55 <EvanCarroll> It hits on every stereotype absolutely perfectly.
12:47:01 <sinelaw> for some engineers, it has almost everything they'll ever need
12:47:10 <EvanCarroll> a monad is a monoid in the category of endofunctors, what's the problem?
12:47:27 <mreh> sinelaw: the thing is, it's just not mathematical!
12:47:36 <gnuvince>  plus side: matlab has a nice library of functions
12:47:36 <gnuvince> [15:45:43] < mreh> which I still don't understand
12:47:36 <gnuvince> [15:45:49] < b_jonas> so sometimes you do want to use it
12:47:42 <gnuvince> errr
12:47:44 <gnuvince> Sorry
12:48:14 <sinelaw> mreh, what does that mean?
12:48:21 <mreh> hmatrix - now you never need to use matlab again
12:48:25 <mjrosenb> mreh: floating point is not mathematical, either
12:48:54 <mreh> mjrosenb, imagine running quick check with floating points :)
12:48:59 <mreh> epic fail
12:49:09 <mjrosenb> mreh: i am almost willing to guarantee that hmatrix's library isn't as fast or as libraryful as mathematica
12:49:23 <koeien37> is mathematica fast?
12:49:27 <mjrosenb> err
12:49:30 <mjrosenb> not mathematica
12:49:31 <mjrosenb> matlab
12:49:31 <sinelaw> mreh, does hmatrix have a library of primitives for signal processing , communications, avionics, and whatnot?
12:49:37 <koeien37> mjrosenb: no it isn't
12:49:43 <koeien37> but for me it was good enough[tm]
12:49:47 <Veinor> you can't spell arrayfun without fun!
12:49:55 <sinelaw> matlab is for engineers, not mathematicians
12:50:03 <mreh> sinelaw: I'm not trolling matlab
12:50:06 <Veinor> @quote funroll
12:50:06 <lambdabot> No quotes match. This mission is too important for me to allow you to jeopardize it.
12:50:11 <Veinor> I know I had one :/
12:50:30 <mreh> It's good for what it does, i just don't think it's particularly mathematical
12:50:56 <sinelaw> mreh, worry not. i have my own bag of complaints 'bout it. I think it should be embedded in haskell
12:51:06 <sinelaw> it's language sucks
12:51:13 <sinelaw> its , even
12:51:48 <mreh> it's like writing code with magic spells sometimes :)
12:52:01 <chrisdone> programming is casting spells
12:52:08 <b_jonas> sure it is
12:52:13 <mjrosenb> mreh: this is true in most languages
12:52:19 <chrisdone> http://icampus.mit.edu/xTutor/public/images/content/5/sicp-cover.jpg
12:52:26 <mjrosenb> mreh: see also, the hackery that i had to use last night
12:52:31 <Veinor> see: perl
12:52:42 <mjrosenb> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15478#a15478
12:52:44 <Veinor> chrisdone: that made me laugh
12:52:47 <mreh> chrisdone: I have that cover!!!
12:52:47 <mjrosenb> mreh: ^
12:53:00 <mreh> original too :D
12:53:25 <mreh> mjrosenb, is this a binary tree?
12:53:46 <mjrosenb> mreh: it is one part of a type system
12:54:07 <mjrosenb> which is also coupled with an AST
12:54:29 <mjrosenb> and i am trying to use classes to coerce haskell values into values within said AST
12:54:32 <Berengal> http://hacks.mit.edu/Hacks/by_year/1992/spellbook/
12:54:48 <mjrosenb> this was just finding the type of a function
12:56:06 <mreh> mjrosenb, are you programming a type system in haskell?
12:56:08 <McManiaC> hmmm is there something like a backtrace with ghc? I keep on getting stack overflows in one of my threads :S
12:56:18 <Veinor> which is true, type String = [Char] or newtype String = [Char]
12:56:18 <mjrosenb> mreh: possibly.
12:56:20 <Veinor> I forget
12:56:31 <mjrosenb> Veinor: first.
12:56:48 <mjrosenb> > head "Hello"
12:56:50 <lambdabot>   'H'
12:56:56 <Veinor> newtype String = [Char] wouldn't let you do any list operations on Strings, right
12:56:57 <koeien37> the first, the second is impossible since newtypes expect a single constructor
12:57:03 <Veinor> ah.
12:57:07 <mjrosenb> Veinor: you cannot do that if you needed a constructor which you need with newtype
12:57:09 <koeien37> newtype is more like data than type
12:57:51 <koeien37> type gives a type synonym; data introduces a new algebraic data type; newtype gives an existing type a distinct identity
12:57:51 <sinelaw> http://www.cvaieee.org/html/humor/
12:57:55 <Veinor> well, newtype String = String [Char]
12:57:57 <sinelaw> ;)
12:58:01 <sinelaw> (read the error)
12:58:10 <edwardk> Hrmm. http://sage.soe.ucsc.edu/sage-tr.pdf is some neat stuff reminds me of Dana Xu's ESC/Haskell stuff
12:58:13 <Veinor> sinelaw: ...?
12:58:25 <sinelaw> "Additionally, a 404 Not Found error was encountered while trying to use an ErrorDocument to handle the request."
12:58:38 <Veinor> Yeah, I see that sometimes.
12:58:46 <sinelaw> that's pretty humorous, ironically.
13:00:09 <sinelaw> do improving values (or some equivalent) have a value for "completely unknown"?
13:01:46 <Boxo> @pl \f g x y -> f (g x y)
13:01:47 <lambdabot> (.) . (.)
13:01:48 <stu2010> correct link: http://www.cvaieee.org/html/humor/humor.html
13:01:57 <Boxo> @pl \f g x y z -> f (g x y z)
13:01:58 <lambdabot> (.) . (.) . (.)
13:03:52 <Veinor> I spot a pattern :O
13:04:30 <lament> but the pattern stops right there, because there're no letters after z
13:04:49 <Boxo> dots dotting dots... i'll never understand pointfree
13:05:07 <Veinor> I can understand (f .) . g
13:05:21 <Veinor> @unpl (f .) . g
13:05:21 <lambdabot> (\ d i -> f (g d i))
13:05:43 <Boxo> @type (f.).g
13:05:44 <lambdabot>     Ambiguous occurrence `f'
13:05:44 <lambdabot>     It could refer to either `L.f', defined at <local>:7:0
13:05:44 <lambdabot>                           or `SimpleReflect.f', imported from SimpleReflect at State/L.hs:75:0-32
13:05:53 <Boxo> @type \f g -> (f.).g
13:05:54 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f1 (f a) -> f1 (f b)
13:06:53 <dh_> what is the correct way to implement putStr by map putChar ?
13:07:06 <dh_> > map putChar "abc"
13:07:07 <lambdabot>   [<IO ()>,<IO ()>,<IO ()>]
13:07:11 <koeien37> putStr = sequence . map putChar
13:07:22 <koeien37> sequence_
13:07:22 <mjrosenb> dh_: mapM
13:07:26 <koeien37> or mapM_
13:07:26 <dh_> thanks.
13:07:26 <mjrosenb> err
13:07:28 <mjrosenb> mapM_
13:07:41 <sinelaw> matlab has anonymous functions
13:07:59 <mjrosenb> sinelaw: didn't i say that like half an hour ago?
13:08:08 <sinelaw> matlab has anonymous functions
13:08:14 * sinelaw ducks
13:08:23 <b_jonas> yes but it doesn't have a proper lambda constructor for them
13:08:58 <dh_> is it possible to define a general mapx that unify map and mapM_ ?
13:09:11 <b_jonas> dh_: probably no
13:09:15 <sinelaw> b_jonas, RandomBits = arrayfun(@(x) (x > 0.5), rand(NumberOfRandomBits, 1));
13:09:21 <dh_> why ? because of the type system?
13:09:45 <b_jonas> dh_: no, they're just not the same. it's like why you don't want a common generalization of return and id
13:09:54 <b_jonas> and also the type system
13:11:31 <b_jonas> dh_: ah wow
13:11:45 <dh_> for me , it seems the type system is get into my way ( maybe wrong English)
13:11:49 <b_jonas> so it has proper lambda calculus with values from the environment and all that stuff?
13:11:53 <b_jonas> great
13:12:09 <opdolio> Disciple has a single function that's the same as map and mapM for its effect types.
13:12:16 <b_jonas> dh_: thanks
13:12:26 <b_jonas> dh_: I'm not good in matlab so I didn't know that
13:12:35 <dh_> b_jonas: I believe you talk to the wrong guy :)
13:12:41 <b_jonas> ah sorry
13:12:49 <b_jonas> sinelaw: thanks
13:13:20 <lpjhjdh> is there a way to tell cabal not to fetch dependencies or tell me why it is including something
13:13:33 <sinelaw> b_jonas, i have an annoying assignment about digital communications, so i had to learn some
13:13:40 <sinelaw> (more than before)
13:14:24 <Boxo> @pl \f (a,b) x y -> f (a x) (b y)
13:14:25 <lambdabot> (`ap` snd) . (. fst) . ((flip . ((.) .)) .) . (.)
13:14:43 <dh_> lpjhjdh: you can restrict cabal to certain version of lib.
13:14:46 <opdolio> That effectively means that map is parameterized by effects, of course.
13:14:55 <opdolio> And regular map is "no effects".
13:15:08 <Boxo> @pl \f a b x y -> f (a x) (b y)
13:15:08 <lambdabot> ((flip . ((.) .)) .) . (.)
13:15:11 <sinelaw> @pl \(a,b) x y -> ((a x),(b y))
13:15:11 <lambdabot> uncurry (flip . (((.) . (,)) .))
13:15:33 <sinelaw> :t liftA2
13:15:34 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
13:15:59 <sinelaw> > (,) 1 2
13:16:00 <lambdabot>   (1,2)
13:16:22 <Boxo> there must be a lesson here
13:18:09 <Gracenotes> chrisdone: oh, yeah :) Reader and r-> are basically equivalent after all. it's just, the translation had more monadic overhead than I thought it might
13:18:18 <lpjhjdh> did anyone else get strange library issues with ghc 6.12?  cabal keeps installing a bunch of libraries under my user database even though it's the same version as the global package
13:18:22 <Gracenotes> but that's laid out
13:18:48 <b_jonas> lpjhjdh: I did get some strange library stuff but I'm not sure it's from 6.12
13:18:52 <conal> Boxo: i've used that pattern for graphics.  it's a sort of generalized cartesian product
13:19:39 <sinelaw> hey conal
13:19:43 <conal> Boxo: for instance, if a & b are curves.
13:19:48 <conal> sinelaw: hi!
13:19:54 <conal> sinelaw: after sun down?
13:20:12 <sinelaw> conal, yes, the sun goes down before 23:19 here :)
13:20:28 <Boxo> > (liftA2) (,) [0,1] [10,11]
13:20:29 <lambdabot>   [(0,10),(0,11),(1,10),(1,11)]
13:20:30 <conal> sinelaw: oh yeah.  10 hours later than here.
13:21:00 <sinelaw> conal, I re-read some parts of a yampa paper, this time having a much more critical feeling about it
13:21:29 <sinelaw> I have a different perspective after reading push-pull and the design papers
13:21:41 <conal> hey all --- i'm interested in comments on http://www.reddit.com/r/programming/comments/akhvr/reflections_on_a_holy_grail_functional_reactive/c0i2gsd .  it's thread on the viability & usefulness of program specification and proving.
13:22:00 <conal> sinelaw: oh?  you're less content with yampa than you were?
13:22:15 <lpjhjdh> is there a copy of the pan compiler floating around anywhere?
13:22:17 <sinelaw> conal, a lot less. at least documentation-wise, the semantics are unclear
13:23:17 <conal> lpjhjdh: sadly, no.  it seriously bit-rotted.  i'm working on a new version now that compiles to crazy-fast GPU code.  and that does 3d as well.  with the same simple precise semantics in in Pan & Vertigo.
13:24:12 <lpjhjdh> conal: cool, is there anything you could recommend (readings or projects) that continues the work of compiled edsls?
13:24:21 <conal> sinelaw: i've always been confused about yampa semantics as well.  the original arrow-frp paper ("genuinely functional UIs") laid out the model of (T->a) -> (T->b).  i don't know if they stayed with that model.
13:25:15 <conal> lpjhjdh: there are a few Pan papers (though just two very different ones), and there's the Vertigo paper.  thinking what else ...
13:25:46 <schrodycat> Anybody willing to answer a newbie's monad question?
13:25:51 <sinelaw> conal, also, they write about 'integral' and some other functions being 'stateful' (they mean memory-full i think), and if i understand correctly they are semantic primitives. but they also supply loop (feedback) which also gives memory.
13:25:57 <RayNbow> <jlouis> and we want to know what pieces are the rarest by looking at this count <-- are you aware of piece selection strategies other than Rarest First?
13:25:58 <conal> schrodycat: toss out the question and see
13:26:12 <mistermattaway> is there something like CPAN for haskell that works on windows?
13:26:20 <mauke> mistermattaway: cabal
13:26:22 <lpjhjdh> conal: great thanks a bunch! I'll definitely take a look a the vertigo paper as I haven't run across your project until now
13:26:25 <conal> sinelaw: there's a lot of confusion about "statefulness".
13:27:00 <conal> lpjhjdh: cool.  there are a few folks currently pursuing compiled dsels.  let's stay in touch.
13:27:03 <sinelaw> conal, in short, it's a complicated library, with possibly complicated semantics
13:27:35 <sinelaw> conal, but i believe a similar library with precise simple semantics is possible
13:27:40 <lpjhjdh> conal: definitely
13:28:05 <conal> sinelaw: that's my not-very-informed impression as well.  i'm a PITA stickler for denotational precision & simplicity.  i'm not sure they had such a stickler in their group.
13:28:14 <schrodycat> Looking over some monad tutorials and RWH, I'm confused about the typdefs for the example monads. The state-like monads have type definitions along the lines of (a,s), which is fine.  But the random monads have a function (returning a tuple) instead of just a tuple. What's the diff?
13:30:07 <conal> sinelaw: i've been rethinking the denotational model of frp lately.  had a recent realization that the old models are "mostly junk" in a technical sense.  maybe i already mentioned.
13:30:31 <sinelaw> conal, you said something about that. what is the junk?
13:30:37 <Philonous1> schrodycat: A state-changing function takes a value and a state and returns a value and a state. So it's something like (a,s) -> (a,s). Now we usually don't use tuples as input values, so "currying" the function gives a -> s -> (a,s). Now factoring out the right function definition we have a -> m a where m a = s -> (a,s)
13:30:48 <conal> sinelaw: access to the past & future.
13:31:00 <sinelaw> conal, like accumE?
13:31:10 <sinelaw> (and where do you have access to the future?)
13:31:13 <conal> sinelaw: not the combinators.  the model.
13:31:21 <conal> sinelaw: ie the semantic domain.
13:31:54 <conal> sinelaw: i'm thinking about models of interactive behavior that eliminate access to past & future.  the model of (T->a)->(T->b) gives arbitrary access to past & future.
13:32:26 <conal> sinelaw: some folks talk about "causal" models that eliminate access to the future.  i see access to the past as equally problematic/magical.
13:32:41 <c_wraith> the reverse state monad is pretty cool
13:32:45 <sinelaw> conal, first, i still don't get what you mean - where in your model do you have that? second, why is it bad (especially past/causal)?
13:33:22 <conal> sinelaw: look at the type (T->a)->(T->b).  imagine the functions you can write that have that type.
13:33:34 <sinelaw> conal, ok, yeah
13:33:36 <Philonous1> schrodycat: the monad for random number generation is essentially a state monad (because you update the seed)
13:34:52 <conal> sinelaw: two desirable properties of a denotational semantics are full abstraction and junk-freeness.  full abstraction says we mustn't distinguish between the operationally indistinguishable.  junk-freeness says every semantic value must be denotable.
13:35:08 <conal> sinelaw: non-denotable values are referred to as "junk".
13:35:13 <schrodycat> Philonous1: Ok. But here's a definition from RWH that's confusing things:  newtype Logger a = Logger { execLogger :: (a, Log) } .    That to me just looks like a pure state tuple, no?
13:36:04 <sinelaw> conal, so what exactly is not denotable?
13:36:16 <sinelaw> in this case
13:36:27 <b0fh_ua> Hello everybody! Is it possible to use <- within `let' part of "let .. in .. " statement somehow?
13:36:35 <roconnor_> nope
13:36:45 <xerox> b0fh_ua if you have a do block in one of the let bindings
13:36:56 <Philonous1> schrodycat: The logger doesn't really convey any state as you don't have means to access it. The idea there is that your function returns something that is appended to a list (or something similar) so you have a way to log it.
13:37:34 <b0fh_ua> well, I need to call a function, which returns an IO (Int) and then take it's integer value of IO action
13:37:49 <conal> sinelaw: i'm looking at a slightly different question: what do we want to be denotable and what do we not want denotable in a frp system.
13:37:59 <xerox> do { x <- foo; bar x; ... }
13:38:19 <Philonous1> schrodycat: if m a = (a,Log) then a -> m a = a -> (a,Log). As you can see you don't get to look at the Log from inside the monad. You can only return something that (hopefully) will be seen from the caller of the monadic action
13:38:29 <sinelaw> conal, ok, but i'm still trying to understand why access to past/future is junk
13:38:49 <Veinor> http://arcanux.org/lambdacats/concatMap.jpg
13:39:00 <b_jonas> time machines?
13:39:21 <b0fh_ua> xerox: http://pastebin.com/d1f5f305f
13:39:41 <conal> sinelaw: because i'm playing with some possibilities in which they are.  that is, we might want to guide programers to be able to express systems that have some of the restrictions of our physical reality, relative to time.
13:39:42 <schrodycat> Philonous1:  Ok, thanks.  That'll give me something to chew on tonight.
13:40:01 <conal> sinelaw: and space, which is another issue.
13:40:05 <sinelaw> conal, isn't causation enough?
13:40:05 <Philonous1> schrodycat: Hope that helps at all.
13:40:15 <sinelaw> (access to past only)
13:40:46 <b0fh_ua> also I'm wandering what is the correct way to rewrite "let sum = foldl (\acc line -> acc + (read line) ) 0 $ lines content" with function composition instead of lambda. '(+) . show' obviously wouldn't work
13:41:07 * hackagebot upload: gitit 0.7.1 - Wiki using happstack, git or darcs, and pandoc. (JohnMacFarlane)
13:41:16 <kmc> :t (+) . read
13:41:17 <lambdabot> forall a. (Num a, Read a) => String -> a -> a
13:41:26 <kmc> :t ((+) .) . read
13:41:27 <lambdabot> forall a (f :: * -> *). (Num a, Functor f, Read (f a)) => String -> f (a -> a)
13:41:49 <kmc> :t flip ((+) . read)
13:41:50 <lambdabot> forall a. (Num a, Read a) => a -> String -> a
13:42:17 <conal> sinelaw: past-access is problematic for me.  one is that it's terribly hard to implement things like access to "input" arbitrarily long ago.  another is that it breaks symmetry, which i expect leads to a less elegant/compelling theory/system.
13:42:41 <kmc> > foldl' (flip ((+) . read)) 0 $ lines "123\n45\n678"
13:42:42 <lambdabot>   846
13:42:46 <kmc> but i'm not convinced that's more readable than what you have
13:42:46 <conal> sinelaw: past-access also violates a design principle i sometimes invoke, which i call "WWRD" (what would Reality do?)
13:43:04 <b0fh_ua> kmc: yeah, too complicated
13:43:19 <sinelaw> conal, so you want access to the immediate (infinitesimal) past?
13:43:26 <conal> sinelaw: and even though we informally talk about "memory" as if it were access to the past, it isn't really.
13:43:27 <sinelaw> conal, and only that?
13:43:42 <conal> sinelaw: yeah.  something like that.  i'm pondering the options.
13:43:49 <kmc> is it just me or is lambdabot sluggish today
13:43:50 <dh_> how can I find the src of Maybe Monad?
13:44:00 <conal> sinelaw: maybe access to all current *derivatives* of input.
13:44:34 <conal> sinelaw: i guess all derivatives is another way to say immediate/infinitesimal past.
13:44:37 <sinelaw> conal, so how would you model integration?
13:45:04 <sinelaw> conal, with infinitesimal i understand, i was referring to derivatives
13:45:07 <dh_> @instances
13:45:07 <lambdabot> Couldn't find class `'. Try @instances-importing
13:45:11 <conal> sinelaw: and maybe we don't have to treat the future & past differerently.
13:45:21 <dh_> @instance Maybe
13:45:21 <lambdabot> Maybe you meant: instances instances-importing
13:45:28 <dh_> @instances Monad
13:45:28 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
13:45:44 <dh_> @instance Monad Maybe
13:45:44 <lambdabot> Maybe you meant: instances instances-importing
13:45:47 <kmc> @src (>>=) Maybe
13:45:47 <lambdabot> Source not found. Where did you learn to type?
13:45:52 <kmc> @src Maybe (>>=)
13:45:52 <lambdabot> (Just x) >>= k      = k x
13:45:52 <lambdabot> Nothing  >>= _      = Nothing
13:45:54 <conal> sinelaw: i think integration is trivial.  just shift the derivatives and inject the initial value.
13:45:56 <dh_> @src (>>=) Maybe
13:45:56 <lambdabot> Source not found.
13:46:13 <dh_> @src (>>=) Maybe
13:46:13 <lambdabot> Source not found. There are some things that I just don't know.
13:46:21 <conal> sinelaw: oh.  not just initial value.
13:46:41 <b0fh_ua> Can somebody please advice, how should I rewrite the lambda in main function listed at http://pastebin.com/d1f5f305f to fix the issue with <- ?
13:46:54 <gwern> I'm very pleased. I just ordered TAPL, and I used an 'entertainment bestsellers' 20% off coupon to bring it down to ~60, then I had 58$ in borders gift cards, and wound up paying 2$ for it
13:46:57 <dh_> kmc: thanks. why mine is not working?
13:47:02 <mauke> b0fh_ua: you can't do that
13:47:11 <conal> sinelaw: i guess the zero-th order derivative is the intergral, and the other terms taken directly from the integrand.
13:47:22 <kmc> dh_, because you have it flipped
13:47:23 <kmc> @src (>>=) Maybe
13:47:24 <lambdabot> Source not found. Take a stress pill and think things over.
13:47:24 <kmc> @src Maybe (>>=)
13:47:25 <lambdabot> (Just x) >>= k      = k x
13:47:25 <lambdabot> Nothing  >>= _      = Nothing
13:47:27 <dh_> @src Maybe (>>=)
13:47:28 <lambdabot> (Just x) >>= k      = k x
13:47:28 <lambdabot> Nothing  >>= _      = Nothing
13:47:36 <b0fh_ua> mauke: so what's the solution? :(
13:47:38 <gwern> funnily enough, even at 20% off, it was still more expensive than at Amazon :)
13:47:46 <conal> sinelaw: hm.  that probably doesn't make sense either.
13:47:54 <mauke> b0fh_ua: foldM maybe
13:48:06 <b0fh_ua> :t foldM
13:48:08 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
13:48:17 <sinelaw> conal, also I/we may be thinking in terms of Reals, where the real problem is polymorphic
13:48:23 <mauke> b0fh_ua: wait, why is your code so complicated?
13:48:32 <conal> sinelaw: you asked the key question.  integration is the one non-trivial operation.
13:48:34 <b0fh_ua> mauke: I'm just learning basics :)
13:48:58 <conal> sinelaw: yes.  polymorphism is the other question.
13:48:58 <gwern> hm. I have SICP; I have Okasaki; I will soon have TAPL; TAOCP I'm waiting for Knuth to die and the final set come out - am I missing any major current FP books?
13:48:59 <sinelaw> conal, will you allow feedback?
13:49:07 <conal> sinelaw: yes!
13:49:15 <sinelaw> conal, thanks!
13:49:23 <conal> sinelaw: feedback is how "memory" comes into being.
13:49:40 * sinelaw feels the engineer in him rejoice
13:49:51 <b_jonas> gwern: you're actually waiting for Knuth to die? evil.
13:49:53 <conal> sinelaw: i think this model reflects how our universe works.  including our brains.
13:50:00 <gwern> b_jonas: I got burned with Star Wars
13:50:00 <DrTeggy> gwern, The Implementation of Functional Programming Languages, Simon P-J (1987)
13:50:01 <mauke> b0fh_ua: calculateTotals filename = do { c <- readFile filename; return . sum . map read . lines $ c }
13:50:02 <sinelaw> conal, that's how you can implement integration.
13:50:02 <gwern> never again!
13:50:09 <gwern> now I wait for the auteur to die
13:50:15 <gwern> die before I buy
13:50:24 <conal> sinelaw: do you mean odes?
13:50:26 <tensorpudding> knuth might be around for a bit yet
13:50:27 <sinelaw> gwern, get it here http://research.microsoft.com/en-us/um/people/simonpj/papers/slpj-book-1987/index.htm
13:50:29 <xerox> b0fh_ua http://pastebin.com/m44d7542e
13:50:32 <mauke> b0fh_ua: main = do { files <- getArgs; totals <- mapM calculateTotals files; print $ sum totals }
13:50:32 <conal> (ODEs)
13:50:47 <gwern> sinelaw: already have that
13:50:47 <sinelaw> conal, ah i didn't, but i may have meant somethign equivalent
13:51:02 <sinelaw> gwern, it's a lovely book. 1987-ish though
13:51:10 <gwern> > 2010 - 1938
13:51:10 <lament> gwern: what do you mean burned? You feel bad not having the clone wars in your star wars set?
13:51:11 <lambdabot>   72
13:51:13 <conal> sinelaw: i haven't worked this idea through.  it's pretty compelling to me at this point.
13:51:23 <gwern> tensorpudding: 72 is pretty old. he could kick the bucket at any moment
13:51:24 <conal> sinelaw: we'll see about the details.
13:51:37 <gwern> lament: no, it's the whole Special Edition vs original
13:51:39 <sinelaw> conal, integral x = x + pre x
13:51:42 <xerox> b0fh_ua the thing is: since the calculation doesn't actually need IO, it is better to keep all the IO in the main, and do the pure computation just with pure functions (sums)
13:51:43 <sinelaw> pre x = feedback
13:51:44 <tensorpudding> i'd think that discrete mathematics is better than taocp
13:51:49 <gwern> lament: knuth keeps reworking stuff, so as long as he's alive...
13:51:50 <tensorpudding> though he cowrote that
13:51:55 <conal> sinelaw: can you define "pre"?
13:52:00 <lament> cowrote?
13:52:03 <tensorpudding> mostly because TAOCP is so old
13:52:06 <lament> you mean read?
13:52:09 <sinelaw> conal, yes
13:52:15 <tensorpudding> err
13:52:18 <tensorpudding> concrete mathematics
13:52:20 <tensorpudding> is what i meant
13:52:37 <lament> co-knuth co-wrote co-ncrete mathematics
13:52:42 <b_jonas> gwern: but cs is taking shape now. in another few centuries the basics will be so solid that the five volumes needn't be continuously rewritten anymore
13:52:45 <sinelaw> conal, at time t, pre x = limit u->t^- x
13:52:46 <b0fh_ua> xerox: I see, so it's better to read the content of a file in main and then pass lines to some function
13:53:06 <gwern> b_jonas: yes, but that's a long ways away
13:53:09 <sinelaw> conal, at time t, pre x = limit u->t^- x(u)
13:53:10 * hackagebot upload: gitit 0.7.2 - Wiki using happstack, git or darcs, and pandoc. (JohnMacFarlane)
13:53:12 <xerox> b0fh_ua yes, IO is lazy
13:53:15 <tensorpudding> hmm, knuth wrote a lot of books
13:53:15 <b_jonas> I mean red-black trees and finger trees didn't yet exist when he wrote volume 3
13:53:26 <mauke> IO is not lazy
13:53:28 <mauke> readFile is
13:53:34 <xerox> pardÃ²n.
13:53:34 <b_jonas> I for one would prefer if he lived forever and kept revising his books
13:53:34 <conal> sinelaw: what's "^-x(u)"?
13:53:35 <sinelaw> sorry for mixing math/lambda syntax in there
13:53:35 <b0fh_ua> xerox: in such case I don't really need the separate function to calculate sum of lines )
13:53:46 <b_jonas> publishing them ever few decades
13:53:48 <conal> sinelaw: trouble parsing
13:53:50 <tensorpudding> i knew about concrete mathematics, and his book on surreal numbers, the texbook and metafont books, and taocp
13:53:59 <sinelaw> conal, I meant: limit of x at time u, where u approaches t from the negative side
13:54:02 <xerox> b0fh_ua yeah, I just put it in the let. but for complex things you can let the result of more complicated pure functions.
13:54:23 <conal> sinelaw: thx.  then pre x = x for continuous functions, right?
13:54:25 <b_jonas> tensorpudding: those are the main ones
13:54:32 <b0fh_ua> this is something different from my experience with imperative programming. I would create a separate function to calculate the sum of lines within the passed file, and then simply sum outputs of that function
13:54:38 <gwern> b_jonas: sure, and I'd like a pony too
13:54:41 <sinelaw> conal, ah. right.
13:54:45 <sinelaw> conal, so it won't work
13:54:47 <b_jonas> b0fh_ua: you can in haskell too
13:54:54 <tensorpudding> he wrote a book about the bible
13:55:00 <conal> sinelaw: something else might.
13:55:00 <b_jonas> tensorpudding: yep
13:55:04 <b_jonas> anyway, good night now
13:55:06 <b0fh_ua> b_jonas: well, my first attempt simply failed :)
13:55:14 <maartenm> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15495#a15495
13:55:21 <tensorpudding> and a bunch of stuff on CWEB and MMIX
13:55:21 <maartenm> bit opetrations in haskell are driving me mad
13:55:28 <maartenm> Colour is a constructor that takes Doubles
13:55:40 <maartenm> I keep getting division by zero errors at runtime
13:55:50 <maartenm> what am I doing wrong?
13:56:03 <maartenm> I tried all sorts of things already
13:56:04 <mauke> maartenm: dividing by zero
13:56:14 <mauke> > 256 :: Word8
13:56:15 <lambdabot>   0
13:56:22 <maartenm> yes I figured that
13:56:27 <maartenm> then, I tried bitshifting using Data.Bits
13:56:35 <mauke> what?
13:56:39 <maartenm> like in msb there, but that doesn't give the correct results either
13:56:47 <mauke> lsb doesn't make sense
13:56:49 <mauke> you only have one byte
13:57:15 <maartenm> 2 bytes
13:57:15 <conal> maartenm: add types to your local defs (msb,lsb,intval), and you'll see the problem.
13:57:18 <mauke> maartenm: no, one
13:57:32 <sinelaw> conal, come to think of it, they never properly defined it for us in our e.e. courses. trying to find a definition on the net
13:58:06 <conal> sinelaw: there's more than one def, eg riemann vs lebesgue
13:58:15 <sinelaw> conal, no I meant feedback
13:58:42 <maartenm> ok, so msb :: Double -> Word8 ... but how do I do it then?
13:59:11 <sinelaw> conal, i think the definition they assumed was simply that x = pre x
13:59:34 <maartenm> conal= did you ever get IL installed? I found you on Google yetserday when trying to install DevIL wrappers
14:00:12 * hackagebot upload: hpuz 1.0.0 - Haskell bindings for libpuz (ChrisCasinghino)
14:00:26 <conal> maartenm: i think i got IL installed but not working.
14:00:41 <maartenm> yes, me neither..
14:01:25 <conal> cross-platform graphics & UIs for haskell is still a shambles.
14:01:41 <sinelaw> conal, I think i got it.
14:01:46 <sinelaw> conal, feedback is recursion
14:02:00 <conal> for instance, gtk2hs won't run native-mac with 3d, and wxhaskell kills ghci.
14:02:18 <zenzike> heya. is there any reason why i can't seem to have a case expression within a let? I have a monad, and i'm trying to do let x = case foo y  ...
14:02:28 <Twey> zenzike: You can
14:02:31 <mauke> zenzike: probably wrong indentation
14:02:40 <sinelaw> conal, in control theory, you have things like: y = G (x - (H y))
14:02:47 <zenzike> thanks guys, i'll look closer
14:02:55 <maartenm> I guess GD works but I didn't bother checking it out
14:03:00 <conal> sinelaw: yeah.  that's what i'd expect in a classic-frp style: feedback as recursion.
14:03:01 <Twey> > let y = 3; x = case y of 2 -> 'a'; 3 -> 'b' in y
14:03:03 <lambdabot>   3
14:03:09 <maartenm> I'm writing my own image outputter instead but now I have this problem
14:03:26 <conal> sinelaw: in model of *interactive* behavior, we might need something else.
14:03:27 <sinelaw> conal, does that satisfy you?
14:03:41 <sinelaw> i guess not. be back in 3-5 minutes.
14:03:56 <zenzike> oh i mean more like let x = case x of 1 -> 'a'; 2 -> 'b'
14:04:26 <zenzike> Twey: ignore me, i read your code wrong
14:04:31 <mjrosenb> @pl \f x y -> return (f x y)
14:04:31 <lambdabot> ((return .) .)
14:04:40 <conal> sinelaw: two separate issues, iiuc.  one is integration.  another is feedback.
14:04:50 <mjrosenb> @pl \f x -> return (\ y -> return (f x y))
14:04:50 <lambdabot> ((return . (return .)) .)
14:04:57 <mjrosenb> oy.
14:04:59 <conal> @type (fmap.fmap) return
14:05:00 <lambdabot> forall (f :: * -> *) a (f1 :: * -> *) (m :: * -> *). (Functor f, Functor f1, Monad m) => f (f1 a) -> f (f1 (m a))
14:05:14 <conal> or (result.result) return
14:05:27 <conal> @where SEC
14:05:27 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
14:05:42 <mjrosenb> conal: yeah, i have been reading that.
14:06:09 <maartenm> @hoogle Int -> [Word8]
14:06:09 <lambdabot> Prelude replicate :: Int -> a -> [a]
14:06:09 <lambdabot> Data.List replicate :: Int -> a -> [a]
14:06:09 <lambdabot> Prelude drop :: Int -> [a] -> [a]
14:06:21 <conal> mjrosenb: :) .  i still haven't gotten around to the sequel about generalizing past functions, so as to manipulate types, code, GUIs, etc.
14:06:35 <maartenm> isn't there any BIF that converts a large integer into Word8's?
14:06:44 <conal> mjrosenb: as described in "Tangible Functional Programming"
14:07:05 <maartenm> @hoogle Word16 -> [Word8]
14:07:06 <lambdabot> Data.Data gmapQ :: Data a => (d -> u) -> a -> [u]
14:07:06 <lambdabot> Data.List unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
14:07:06 <lambdabot> Data.List genericReplicate :: Integral i => i -> a -> [a]
14:07:14 <conal> mjrosenb: for pointers, see http://conal.net/blog/posts/tangible-functional-programming-a-modern-marriage-of-usability-and-composability/
14:08:54 <zenzike> I can't figure out what's wrong with the indenting still, can someone see what I'm doing wrong for a case within let expression? http://pastie.org/764359
14:09:49 <c_wraith> zenzike: the cases need to be indented *further* than the case keyword
14:10:07 <twanvl> zenzike: the case alternatives should be indented more than the parent scope, which in this case is the definition of imageType
14:10:13 <zenzike> c_wraith: thanks lots. i didn't realise that was the case
14:11:34 <Trinithis> What import would give me the function monad?
14:11:46 <xerox> Control.Monad.Instances
14:11:51 <Trinithis> alright
14:12:02 <xerox> or Control.Monad.Reader
14:13:15 <QP> can anyone explain exactly what an ambiguous type variable error means? I've just realised I don't actually understand what it is...
14:13:52 <schrodycat> Philonous1:  By Jove, I think I've got it now.  In the logger case, the bind function does concatenation of strings, so there's no reason for the monad itself to touch it.  But in the State case, the bind function just passes the state through, and it's up to the monad to change the state.
14:14:52 <Twey> QP: It means that the compiler needs to choose a type as which to interpret the variable, but it can't decide which to use.
14:15:42 <QP> Twey: but often the compiler is happy to leave a function as polymorphic
14:16:42 <maartenm> @hoogle Word16 -> [Word8]
14:16:43 <lambdabot> Data.Data gmapQ :: Data a => (d -> u) -> a -> [u]
14:16:43 <lambdabot> Data.List unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
14:16:43 <lambdabot> Data.List genericReplicate :: Integral i => i -> a -> [a]
14:17:21 <QP> Twey: so i don't think i understand why the compiler is worrying in this case
14:18:15 <Twey> QP: Because there are some cases where it needs to know what to do
14:18:34 <Twey> For example, if you print a value, it needs to know which type to use so it can decide which Show instance to call
14:18:35 <QP> ok, so how does it decide?
14:18:50 <QP> true
14:19:00 <Twey> It tries to pick the most general type possible, I believe
14:19:21 <QP> ok
14:19:26 <mjrosenb> is there any way of doing IO in hugs?
14:19:45 <Twey> mjrosenb: I'm pretty sure hugs has the same IO monad and âmainâ entrypoint as GHCâ¦
14:20:12 <mjrosenb> Twey: i try to evaluate something of type IO Expr
14:20:19 <mjrosenb> Twey: and it does not print anything
14:20:56 <Twey> mjrosenb: Evaluation is not execution
14:21:28 <xerox> amb >>= print
14:21:46 <mjrosenb> Twey: yes, and i do not know how to make it do the latter
14:21:54 <Twey> Hm
14:21:59 <Twey> It may require unsafePerformIO
14:22:16 <sinelaw> conal, washing dishes helps thinking. in control theory feedback does not solve integration. integration is a primitive (or more precisely, laplace-domain functions are primitives).
14:22:37 <maartenm> can someone please explain how to convert a Word16 to a list of Word8's?
14:22:44 <maartenm> I can't for the life figure out how to do it
14:23:30 <conal> sinelaw: i'll check out "laplace-domain functions".  can you give me a starter description or intuition?
14:23:52 <sinelaw> conal, you remember fourier transforms? (frequency domain)
14:23:54 <maartenm> when I do `shiftR` 8  it just goes to 0 because it's working under :: Word8, but that doesn(t make sense to me
14:24:02 <conal> sinelaw: yeah.
14:24:11 <sinelaw> conal, laplace is a simple generalization
14:24:55 <sinelaw> you can check out wikipedia (http://en.wikipedia.org/wiki/Laplace_transform)
14:25:08 <conal> sinelaw: thx
14:25:41 <sinelaw> conal, but the bottom line is, that you get instead of "real" frequency, a complex one.
14:25:54 <conal> sinelaw: oh!
14:26:12 <sinelaw> conal, so the tranform of f(t) has type C -> C
14:26:16 <sinelaw> instead of R -> C
14:26:32 <sinelaw> conal, and the imaginary axis of that corresponds exactly to the fourier transform
14:26:49 <conal> neat
14:27:14 <sinelaw> conal, what's neater still, is that it's possible to tell a lot about a system's behavior from it's laplace-domain reponse
14:27:40 <sinelaw> which is defined as, Y(s) / X(s) , where those two are the laplace transforms of the output (Y) and input (X)
14:28:12 <sinelaw> conal, the most important thing you can tell is whether the system diverges, oscillates, converges to a constant, etc..
14:28:26 <luite> maartenm: shift first, then convert
14:28:26 <conal> sinelaw: wow
14:28:43 <sinelaw> given arbitrary input that satisfies some conditions of regularity (basically any input)
14:28:58 <maartenm> but the shift fails when I give the output the Word8 type
14:28:58 <luite> > concatMap (\x -> [fromIntegral $ shiftR x 8, fromIntegral x]) ([1234::Word16,2352]) :: [Word8] -- something like this maartenm?
14:29:00 <lambdabot>   [4,210,9,48]
14:29:01 <_Jedai_> maartenm: let trans :: Word16 -> [Word8]; trans n = map fromIntegral [n `shiftR` 8, n]
14:29:41 <maartenm> I don't understand why that works
14:29:52 <sinelaw> conal, nyquist's criterion can tell you whether a system will converge. for me it's really insane how it works
14:30:04 <xerox> maartenm it uses fromIntegral :: Word16 -> Word8
14:30:04 <_Jedai_> maartenm: it's quite straightforward code
14:30:25 <maartenm> yes, but
14:30:27 <xerox> maartenm and \n -> shiftR n 8 :: Word16 -> Word16
14:30:46 <maartenm> ok
14:30:56 <maartenm> so, the :: Word8 mapping is postponed until fromIntegral kicks in
14:31:03 <maartenm> the shift is not affected by it
14:31:07 <_Jedai_> Right
14:31:12 <xerox> the type of the first element of the list, the codomain of shiftR, is fixed by the second element of the list, n which is Word16
14:31:15 <sinelaw> conal,  i mean whether it is stable. stability != convergence. stability means bounded output when given bounded input
14:31:24 <xerox> (remember list are homogenous)
14:31:39 <_Jedai_> xerox: that's not the point
14:32:06 <_Jedai_> xerox: the domain and the codomain of shift must be the same anyway and the input is already a World16
14:32:36 <_Jedai_> :type shiftR
14:32:39 <xerox> so his code with shiftR n 8 :: Word8 didn't actually compile.
14:32:47 <_Jedai_> @type shiftR
14:32:48 <lambdabot> forall a. (Bits a) => a -> Int -> a
14:33:13 <maartenm> my code compiled fine
14:33:26 <xerox> what was your code?
14:33:54 <_Jedai_> maartenm: then you didn't force the type of n and so it was inferred as being World8, not World16
14:33:56 <maartenm> I had many attempts, a combination of both methods being http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15495#a15495
14:34:15 <maartenm> msb didn't work because shiftR actually defaults to 0 when it overflows the Word8 type
14:34:27 <maartenm> and lsb didn't work because 256 meant 0 in its context
14:34:45 <maartenm> so I needed fromIntegral here
14:34:46 <_Jedai_> maartenm: That isn't the problem, the problem is that A024 :: Word8 == 0
14:34:58 <_Jedai_> > 1024 :: Word8 == 0
14:34:59 <lambdabot>   Only unit numeric type pattern is valid
14:35:08 <_Jedai_> > (1024 :: Word8) == 0
14:35:09 <lambdabot>   True
14:35:17 <luite> maartenm: the problem is in the floor function
14:35:23 <luite> which is polymorphic
14:35:30 <maartenm> oh
14:35:34 <maartenm> why does it go to Word8
14:35:54 <luite> because you don't use any conversion afterwards, the only type it can return is Word8
14:36:00 <sinelaw> conal, the way it works is awesome. you take a path that start from the origin, goes up the imaginary axis to i*infinity, takes an 180-degrees turn and comes back from -i*infinity to the origin. You then map that curve using the system's laplace response. Then comes the funky part: you count how many times the resulting contour loops around the number -1 in the complex domain. from that you can determine stability
14:36:17 <luite> @type floor
14:36:18 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
14:36:35 <maartenm> so I should map it to ::Word16
14:36:38 <conal> sinelaw: amazing.
14:36:52 <_Jedai_> maartenm: you should use fromIntegral
14:37:01 <sinelaw> conal, yes. it's based on Cauchy's argument principle theorem
14:37:17 <_Jedai_> maartenm: in fact you should use the function I proposed or luite's
14:37:34 <maartenm> yes I'll try to rewrite it, but I'm not understanding everything
14:37:39 <maartenm> I'll examine :t fromIntegral
14:37:52 <sinelaw> conal, i don't like the idea that integration is a special case.
14:38:01 <conal> sinelaw: good.
14:38:07 <_Jedai_> maartenm: it's just a conversion between two integral type
14:38:23 <maartenm> yeah but I don't udnerstand the "passive" typecasting
14:38:24 <sinelaw> conal, for feedback it is fine. but integration is just an instance of memory to me
14:38:25 <_Jedai_> maartenm: instance of the Integral typeclass
14:38:36 <_Jedai_> maartenm: there is no "passive" typecasting
14:38:50 <conal> sinelaw: memory and something more.  accumulation.
14:38:51 <maartenm> but, I make a function Double -> [Word8]
14:39:10 <maartenm> in my where clause, I define an intval, which just does a floor $ x * 0xFFFF
14:39:28 <luite> maartenm: haskell never implicitly converts a value
14:39:32 <sinelaw> conal,  what is accumulation? just an "accumulative" operation on memorized values
14:39:32 <maartenm> I really don't udnerstand how fromIntegral "helps" converting the number there
14:39:33 <conal> sinelaw: and memory in general is overkill.  i'm wondering what is a minimal basis.
14:39:42 <burp> :t fromIntegral
14:39:44 <lambdabot> forall a b. (Integral a, Num b) => a -> b
14:39:54 <burp> does that help?
14:39:59 <conal> sinelaw: i don't know, other than to say it's integration.  (circular)
14:40:08 <maartenm> I used to think I understood that
14:40:09 <luite> maartenm: it just infers that you want a value of Word8 and then has to choose that type for the floor function
14:40:42 <maartenm> but what happens when I do fromIntegral( floor $ x * 0xFFFF) ?
14:40:49 <maartenm> I don't understand
14:41:06 <conal> sinelaw: btw, i also want to eliminate any direct access to "time" in frp
14:41:12 <luite> maartenm: that would be the wrong place to do it
14:41:13 <_Jedai_> maartenm: the problem is you want to work with Word16 before converting to Word8, so you use floor to go from Double to Word16 then fromIntegral to go from Word16 to Wrod8
14:41:30 <maartenm> ah, fromIntegral abstrahizes the type entirely?
14:41:48 <luite> maartenm: it can choose any type for the result, as long as it is an instance of Integral
14:41:49 <sinelaw> conal, another idea i had while washing dishes. about WWRD - in reality, non-causal and also unstable systems don't exist. integration in general can describe both, and causal integration can describe non-stability (unboundedness). in reality, an integrator is implemented as a capacitor: it has memory, it accumulates charge, but it can't keep doing that till infinity
14:41:50 <conal> sinelaw: ditto space.  in part for WWRD
14:41:51 <_Jedai_> maartenm: in your version you went directly from Double to Word8 so you lost the high bit information
14:41:52 <maartenm> like, it opens it back up to then be cast again in a show or anything
14:42:10 <maartenm> yes without loss of information, ok
14:42:23 <sinelaw> conal, that sounds similar to stuff like lucid synchrone (excpet for discreteness)
14:42:29 <sinelaw> *except
14:42:54 <conal> sinelaw: and temporal continuity is very important to me, as is spatial continuity.
14:43:12 <sinelaw> conal, I know.
14:43:30 <conal> sinelaw: a capacitor doesn't really have memory in the sense of random-access to the past right?
14:43:43 <conal> sinelaw: it's more like the result of integration?
14:44:06 <sinelaw> conal, yes it is lossy
14:44:09 <sinelaw> lossy memory
14:44:10 <lament> ah, give me random access to your heart
14:44:16 <luite> maartenm: what you could do is fix the type of intval, using intval::Double -> Word16  (if you use Double for the components, you could also use RealFrac)
14:44:55 <luite> maartenm: then you'd get a type error, indicating that there is still something wrong (the missing fromIntegral)
14:45:23 <maartenm> you woulod geta  type error?
14:45:33 <sinelaw> conal, but it doesn't forget _everything_. in reality memory exists for more than just "how many times event X occured"
14:45:35 <luite> yes, try it if you want
14:45:44 <luite> perhaps you could just move msb, lsb and intval to the top level
14:46:46 <maartenm> ok, I think I understand
14:46:51 <conal> sinelaw: i guess that question of how little can be remembered (and is remembered in reality) is what i'm looking for.
14:47:01 <maartenm> it's amazing how far you can go with haskell while still being absolutely rubbish at some things in it
14:47:39 <conal> sinelaw: do you think integration is too powerful a notion to take as primitive?
14:47:46 <sinelaw> conal, it depends what you want to allow. is your goal a model for realistic systems and nothing else?
14:47:47 <luite> maartenm: the thing is that types can 'flow' in the opposite direction of the data
14:47:53 <sinelaw> conal, no, too weak
14:48:08 <conal> sinelaw: ie not sufficiently expressive?
14:48:11 <sinelaw> conal, that was confusing. i meant too specific
14:48:16 <sinelaw> yeh
14:48:30 <sinelaw> yes. :)
14:48:32 <conal> sinelaw: ah.  what might we want to say that we cannot?
14:48:36 <luite> maartenm: so the behaviour of a polymorphic function can change depending on the result type. it's not actually very hard, but it's something you don't see in many other languages
14:49:13 <joe3> i am analysing a huge data (10Megabyte file) set from the ghci prompt. The response is sluggish. I am using the lazy module. Any suggestions that might help?
14:49:17 <maartenm> yes, it's very close to the compiler itself
14:49:26 <koeien37> String is slow
14:49:33 <koeien37> ByteString is a lot faster
14:49:37 <maartenm> Data.ByteString
14:49:43 <koeien37> although 10 MB is not really "huge"
14:50:01 <kmc> compile your code
14:50:05 <kmc> it's much faster than ghci
14:50:17 <joe3> koeien37: but the way the system is working, it seems huge..
14:50:29 <kmc> 10 MB is certainly huge for a regular String
14:50:46 <joe3> kmc: i am trying to study some patterns and compiling the code might not help. do you mean compile a top level function?
14:50:59 <kmc> compile what you can
14:51:07 <joe3> the datatype is [Integer]
14:51:29 <kmc> ah
14:51:34 <Spockz|lap> can someone suggest follow up reading on "Why Attribute Grammars Matter" by Wouter Swierstra/
14:51:35 <joe3> can I compile a function from ghci?
14:51:36 <kmc> are you doing random access?
14:51:45 <sinelaw> conal, good question. on the surface, maybe one of these: time or frequency filtering/shifting/scaling,
14:51:54 <joe3> kmc: no, did "length list"
14:52:04 <kmc> hmm
14:52:21 <joe3> and it has been more than a few minutes now..
14:52:39 <conal> sinelaw: yeah!  fran had those operations.  it had time-transformation in general.
14:52:44 <twanvl> it could be that you are waiting for the file to be parsed
14:52:52 <joe3> koeien37: did not mean to be rude there. sorry if it came out as that.
14:53:07 <conal> sinelaw: and yes, i do mean to eliminate them.
14:53:12 <sinelaw> conal, as primitives? and because you didn't think they could be modeled otherwise?
14:53:37 <koeien37> joe3: ? didn't notice anything. never mind in any case
14:53:51 <conal> sinelaw: not just as primitives, but as possible to express at all.  they're what i mean by "junk" in the model of interactive behavior.
14:54:00 <sinelaw> conal, so for example time shifting (delay) - you want to disallow that?
14:54:26 <sinelaw> conal, why is that junk again? is it non-denotable?
14:54:44 <conal> sinelaw: yes: junk == non-denotable
14:54:59 <conal> sinelaw: yes, i'd eliminate shifting as a function on signals.
14:55:08 <twanvl> is delay possible if you have memory / integration?
14:55:14 <conal> sinelaw: but i'd keep it as a function on functions between signals.
14:55:15 <sinelaw> conal, why is it non denotable?
14:55:25 <conal> twanvl: delay by how much?
14:55:35 <twanvl> some fixed amount
14:56:07 <joe3> ok, let me try the option :set -fobject-code and see if it helps
14:56:10 <conal> sinelaw: as i mentioned above, i'm changing the question.  not what *is* denotable but what we want to be denotable.  it's a design question.
14:56:31 <conal> twanvl: no
14:56:33 <sinelaw> conal, oh ok, now i got it
14:56:40 <osaunders> Is there a good TextMate bundle for Haskell out there anywhere?
14:56:43 <conal> twanvl: well, i don't think so.
14:57:14 <sinelaw> conal, when you say integration what do you mean? integration up to exactly current time?
14:57:24 <sinelaw> in the new denotation
14:57:44 <joe3> actually the shell (zsh) killed off the ghci before. I am trying with -fobject-code to see if it helps.
14:57:55 <sinelaw> conal, there are many systems that depend on constant time delay
14:57:58 <conal> sinelaw: \ t1 -> integral (t0,t1) f
14:58:12 <conal> sinelaw: continuous systems?
14:58:31 <sinelaw> conal, hmm the examples i had in mind were not continuous
14:58:40 <sinelaw> but they should also be denotable
14:59:03 <conal> sinelaw: is there a finite bound on the info to be remembered?
14:59:21 <sinelaw> conal, i guess there is
14:59:26 <conal> sinelaw: then i expect integration will be adequate.
14:59:48 <conal> sinelaw: maybe even if there isn't a finite bound.
14:59:58 <conal> sinelaw: given a TBD polymorphic notion of integration
15:00:18 <sinelaw> how?
15:00:19 <joe3> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15496#a15496
15:00:29 <joe3> the processing is really slow with this code.
15:00:46 <joe3> even after compiling to "object-code"
15:01:02 <osaunders> Is there any easy way to serialize data structures to binary that you can read and write to files?
15:01:04 <joe3> actually it has still not returned.
15:01:18 <koeien37> unpack is not the best idea i guess
15:01:22 <koeien37> that converts it to a string
15:02:09 <conal> sinelaw: and yes up to the *exact* sample time t1
15:02:11 <joe3> osaunders: serialize data structures. never tried it. will google it.
15:02:35 <sinelaw> conal, doesn't that require the lower bound of integration to vary with time? or am i not getting how you mean time shift can be implemented
15:02:42 <joe3> koeien37: any alternatives to unpack?
15:03:02 <koeien37> joe3: i'm thinking, I don't see a better way right away
15:03:30 <joe3> koeien37: thansk
15:04:00 <osaunders> So erm, how to people normally store stuff to disk?
15:04:19 <osaunders> joe3: I found this library http://hackage.haskell.org/packages/archive/cereal/0.2/doc/html/Data-Serialize.html
15:04:32 <conal> sinelaw: i'm thinking of integration as a continuous accumulation process.  where each accumulation is not necessarily what we think of as numeric addition.  so "accumulate" is probably misleading.
15:05:11 <koeien37> joe3: I'm not sure, I'd have to use the profiler. the definition of splitToBits might be a little bit slow
15:05:18 <conal> sinelaw: sometimes a datum is added to the "memory" and sometimes removed.
15:05:19 <joe3> koeien37: thanks
15:05:52 <conal> sinelaw: the removed value isn't accessed from the past, but rather the the present partial memory of the past.
15:06:02 <conal> s/the the/from the/
15:06:15 <joe3> koeien37: let me try the profiler. the program actually just crashed again. The message is that zsh killed it.
15:06:40 <joe3> osaunders: will check out the link. thanks.
15:06:40 <sinelaw> conal, ok, i agree with that
15:07:11 <conal> sinelaw: as you can tell, these thoughts are still migrating from intuition to precision.
15:07:14 <koeien37> joe3: I just ran your program on a 9.6 MB input file, and it terminated almost instantly
15:07:39 <joe3> koeien37: do you mean successfully?
15:07:50 <joe3> koeien37: the filesize is 19M. sorry.
15:07:57 <koeien37> I didn't see any output, but there is not supposed to be any output anyway
15:07:57 <osaunders> Here's another one: http://hackage.haskell.org/packages/archive/binary/0.3/doc/html/Data-Binary.html I'm really surprised I need libraries to do this though.
15:08:14 <koeien37> mis-CTRL-w'd
15:08:16 <conal> sinelaw: in this way, i expect memory will become more explicit than in fran.
15:08:32 <koeien37> let me try to print the resulting list's length
15:08:45 <conal> sinelaw: have you seen the fran tutorial (http://conal.net/fran/tutorial.htm)?  it has some examples of unbounded memory.
15:09:00 <Boxo> can I make stuff like this work with some extension? http://pastebin.com/m1b1aa3ec
15:09:03 <joe3> koeien37: at ghci, I did: dminus <- getdata "/tmp/dminus" and then "length dminus"
15:09:11 <sinelaw> conal, i feel i am searching for a polymorphic theory of "systems". a non-polymorphic one already exists, but now i see that it has many (implicit?) primitives/assumptions, such as the ability to integrate, time-shift, etc..
15:09:15 <koeien37> right, that should be more time-intensive
15:09:29 <koeien37> on this file, it takes 5.5 s
15:09:38 <conal> sinelaw: great quest!
15:09:55 <koeien37> compiled code with -O2
15:10:05 <joe3> koeien37: that is way too fast from what I have.
15:10:19 <koeien37> did you run the code from the interactice interpreter?
15:10:20 <joe3> koeien37: will try out with -O2
15:10:26 <koeien37> -O0 is still 6 s
15:10:39 <koeien37> my machine is ~3 GHz
15:10:43 <joe3> koeien37: i did "set -fobject-code" before compiling the program.
15:10:50 <joe3> mine is 600MHz
15:11:02 <koeien37> that might explain it
15:11:18 <koeien37> how long did it take on your machine? minutes, you said?
15:11:20 <sinelaw> conal, the reliance on those primitives means they have unsorted junk. the reason is that it's obvious that those things are required for many systems, and nobody cares to define the theory in minimal terms.
15:11:26 <joe3> no, does not finish.
15:11:29 <koeien37> that is far too long anyway
15:11:32 <joe3> it is killed by zsh
15:11:38 <koeien37> out of memory?
15:11:46 <joe3> zsh: killed     ghci parse_usb_signals.hs
15:12:05 <joe3> that is what it says, I have a swap of 1GB.
15:12:06 <sinelaw> conal, and it's also the source of a big problem: it is possible to describe unrealistic systems using that theory
15:12:11 <Ke> zsh doen't probably know anything about memory usage
15:12:15 <koeien37> i don't have an explanation for that. by the way, the program runs in O(1) memory
15:12:31 <koeien37> zsh: it may set ulimits, and then get the result of programs that are terminated
15:12:35 <paper_cc> Ke: it just means the program has received SIGKILL
15:12:36 <koeien37> Ke: ^
15:12:48 <Ke> that too
15:13:08 <conal> hm.  yes.  great.  i guess minimality is valued by pure-math folks.  fewest axioms.
15:13:20 <sinelaw> conal, which is mitigated by adding some limitations post-denotationally (such as: "system must have causal response")  rather than doing it when defining the theory
15:13:29 <conal> sinelaw: and yeah, unrealistic systems is what i'm trying to eliminate -- at compile-time.
15:13:34 <koeien37> on a 27 MiB file, the program runs in 17 s
15:13:47 <conal> sinelaw: which is like dynamic typing.
15:14:00 <sinelaw> conal, or a very smart type system :)
15:14:03 <conal> sinelaw: run-time errors (at best).
15:14:17 <sinelaw> actually infinitely smart, maybe...
15:14:26 <conal> sinelaw: a static type system?  then pre-denotationally, right?
15:14:40 <sinelaw> conal, i guess so.
15:14:48 <sinelaw> that's what we want
15:14:48 <conal> sinelaw: i see static types as a way to whittle down the set of expressions that must be given denotations.
15:15:07 <koeien37> joe3: so I don't have an explanation for it. try to run it from the command line, after adding "print (length dplus)"
15:15:14 <koeien37> then compile with -O2, and run the program
15:15:21 <sinelaw> interesting perspective. many people think of static typing as just a way to prevent some sorts of errors.
15:15:27 <conal> sinelaw: if we used dependent types, then we could require programmers to supply proofs of properties.
15:15:32 <joe3> osaunders: i am clueless with the serialisation and I am searching for more info about it.
15:15:52 <osaunders> joe3: What are you looking for?
15:16:00 <conal> sinelaw: i'm hoping not to have to use dependent types.
15:16:03 <sinelaw> conal, right. but maybe it's better to have some properties be unexpressible in the first place
15:16:06 <sinelaw> exactly
15:16:57 <conal> though i do see dependent typing as an ultimate solution, so i'm uncomfortable about habitually avoiding it.
15:17:15 <conal> i want to see dependent typing made practical.
15:17:44 <sinelaw> agda seems to be something in that direction. but i know almost nothing about this
15:18:08 <osaunders> Is it possible to define lazy data structures that are read off the disk as required?
15:19:03 <conal> sinelaw: the bottom line is that dependent typing allows us to encode formal logics / proof systems into the type system.  values are proofs.  if the programmer doesn't supply a proof, we don't compile his program.
15:19:26 <flux> osaunders, it is possible with unsafeInterleaveIO, but handling error situations in that case becomes extremely difficult
15:19:27 <conal> sinelaw: and while proof-search is creative/intelligent, proof-checking is easily mechanized.
15:19:29 <joe3> koeien37: stupid question: how do you compile the program. I tried "ghc  -c -O2 parse_usb_signals.hs" and "ghc -o parse_usb_signals parse_usb_signals.o" but am getting a bunch of undefined reference errors
15:19:31 <sinelaw> I've defined a typeclass for sets based on the ZFC axioms. can someone comment? I need to go so if anyone wishes to, just @tell sinelaw about it: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15501#a15501
15:19:39 <conal> sinelaw: thanks to de bruijn's automath & descendents.
15:19:42 <koeien37> joe3: --make
15:19:50 <koeien37> ghc --make bla.hs -O2
15:20:02 <sinelaw> conal, sounds very cool. i've seen a few simple examples already
15:20:02 <joe3> osaunders: more details/tutorial-like  on serialisation of data structures.
15:20:08 <osaunders> flux: OK
15:20:09 <koeien37> --make does automagic dependency chasing
15:20:29 <sinelaw> conal, such as the verified yampa thing in the last ICFP (by way of video, of course)
15:20:35 <joe3> koeien37: thanks, that helped.
15:20:58 <koeien37> this is a bug in GHC imo, that it's not suggested
15:21:07 <koeien37> this is a very frequently asked question
15:21:12 <joe3> koeien37: just started the compiled program.. waiting for it to finish.
15:21:33 <twanvl> sinelaw: what does "instance Functor SetOf" mean if SetOf is a class?
15:21:54 <sinelaw> About the set typeclass: try to see beyond the compilation errors...i just remembered i've left it in a broken state
15:22:05 <sinelaw> twanvl, ^^^
15:22:21 <sinelaw> Ok everybody, just ignore my message....i'll fix it and try again tomorrow!
15:22:28 <sinelaw> twanvl, thanks, though.
15:22:35 <ziman> sinelaw, if you allow functions in your set, how can you check for membership?
15:22:43 <mm_freak> happy new year everybody
15:23:04 <ziman> (having instance Applicative SetOf in mind)
15:23:22 <ziman> */computably/ check :)
15:23:41 <sinelaw> ziman, hmm.
15:24:08 <joe3> koeien37: yup, it finished.
15:24:11 <dh_> good evening, is there a better way to do the following ?
15:24:20 <dh_> import Prelude hiding (readFile , print)
15:24:21 <dh_> import qualified System.IO( readFile, print)
15:24:26 <sinelaw> ziman, honestly didn't think about that at all
15:24:28 <Spockz|lap> If in `data A = X B | Z; data B = Y A', A and B are mutually recursive, how would anyone call their relationship in the event A and B would be defined as `data A = X B | Z; data B = Y Foo'?
15:24:50 <dh_> basically, I need to using readFile with qualified name only.
15:25:00 <sinelaw> maybe the Applicative instance is irrelevant
15:25:08 <ziman> sinelaw, maybe if you restricted the set to some kind of funtions only...
15:25:49 * twanvl is wondering: how many of the problems of FRP (if any) would go away if time were discrete?
15:26:15 <ziman> like, total periodic functions :)
15:26:21 <sinelaw> what i imagine is good with my type class is that the primtives all follow from ZFC axioms. i tried to minimize them to the ones needed to satisfy the axioms
15:26:31 <joe3> koeien37: do you know if I can set "-O2" while using the program from the ghci prompt?
15:27:24 <sinelaw> i should have written:
15:27:32 <koeien37> you cannot, ghci will use a bytecode interpreter, but if an .o file is available, ghci will use that
15:27:44 <sinelaw> null = filter s (const False)
15:27:52 <sinelaw> then null is not a primitive.
15:28:24 <twanvl> sinelaw: but then you need a law saying that a set exists
15:28:51 <sinelaw> twanvl, what do you mean
15:29:06 <twanvl> if null = filter s (const False), what is s?
15:29:37 <holmak> dh_: That's the best way I can think of to do it. You can also add an "... as IO" onto your qualified import, if you like.
15:29:38 <twanvl> or does it have the type  null :: s a -> s a?
15:29:47 <joe3> koeien37: can I create the .o file with "ghc -c -O2 parse_usb_signals.hs" and then start ghci? does that help?
15:30:00 <koeien37> that should speed it up, yes
15:30:05 <joe3> thanks.
15:30:09 <dh_> hommak: thanks
15:30:18 <koeien37> but i'm not entirely sure about the interplay there
15:30:30 <koeien37> the definitions in the .hs should be evaluated quickly
15:30:42 <sinelaw> twanvl, right again.
15:31:16 <twanvl> if null :: s a -> s a, then how do you create any set to begin with?
15:31:20 <sinelaw> btw, In haskell terms, Is this type class somehow pointless/useless?
15:31:34 <holmak> @hoogle Set.empty
15:31:34 <lambdabot> No results found
15:31:38 <sinelaw> twanvl, singleton, but that really is another axiom, as the code comments.
15:31:51 <holmak> @hoogle (Set.Set a)
15:31:52 <lambdabot> Parse error:
15:31:52 <lambdabot>   --count=20 "(Set.Set a)"
15:31:52 <lambdabot>                  ^
15:32:13 <c_wraith> @hoogle Data.Set.empty
15:32:14 <lambdabot> Data.Set empty :: Set a
15:32:27 <holmak> @hoogle Data.Set.empty
15:32:27 <lambdabot> Data.Set empty :: Set a
15:32:53 <sinelaw> twanvl, actually singleton is not an axiom.
15:33:16 <sinelaw> twanvl, an instance of SetOf can implement singleton, and in doing such it proves that a set of that type exists.
15:33:57 <sinelaw> and then it can implement null by, for example, null = filter (singleton ()) (const False)
15:34:50 <holmak> There it is...
15:35:04 <sinelaw> conal, i've seen the fran tutorial already, but my perspective has changed so much, i should go through it again.
15:35:34 <sinelaw> my todo list is growing exponentially. every item i deal with brings up 10 new ones.
15:35:59 * mauke links to tvtropes
15:36:22 <conal> sinelaw: okay.  also read http://conal.net/blog/posts/why-classic-frp-does-not-fit-interactive-behavior/
15:36:29 <c_wraith> sinelaw: If your rate of dealing things is constant, that's only linear growth of list length vs time. :P
15:36:46 <conal> sinelaw: related to something earlier in our conversation.
15:36:46 <sinelaw> conal, i think i'll try to talk to one of my lecturers abuot the idea of polymorphic systems. he's very mathematically oriented. i'll update you if i ever do it
15:37:02 <sinelaw> conal, i read that too, and i'll read that again also :)
15:37:38 <conal> sinelaw: great!  you can talk about polymorphism in terms of simple types (numbers), plus products, plus sums.  you want the closure.
15:37:47 <sinelaw> c_wraith, ok, i surrender. you can have my pile of herman hesse books i found near the garbage the other day.
15:38:20 * conal loves hermann hesse!
15:38:27 <sinelaw> conal, you mean polymorphism including various numeric types that are closed under products and sums?
15:38:38 <sinelaw> conal, me too, that's why i dared bring home such filthy books
15:39:24 <conal> sinelaw: oops!  no, i don't.  (language is so ambiguous.)  i meant cross product & sum of *type*
15:39:26 <conal> *types*
15:40:33 <sinelaw> conal, to clarify: cross product meaning something like R x R ( = R2), and sum meaning...what
15:40:36 <conal> sinelaw: your math prof might be more comfortable with products & sums of sets than with programming language details.
15:41:04 <conal> sinelaw: right.  sum is a tag/value pair, where the tag determines the value type.
15:41:27 <sinelaw> conal, like Either?
15:41:34 <conal> sinelaw: exactly
15:41:59 <conal> sinelaw: strangely, haskell (like ml) treats pair more specially than sum
15:42:07 <sinelaw> conal, can you give a simple example that demonstrates why sums and cross products are needed?
15:42:38 <conal> sinelaw: they're the types we use in functional programming.
15:42:58 <conal> sinelaw: we call them (regular) recursive data types
15:44:05 <conal> sinelaw: rather than thinking about general algebraic data types, it's usually enough to think about sums & products, together with a few primitive types.
15:44:26 <conal> sinelaw: oh yeah, also the "unit" type we call "()", often called "1" elsewhere.
15:44:56 <sinelaw> conal, i need to learn more about types, another todo list item.
15:45:09 <sinelaw> conal but for now, i mean a concrete example for the usefulness of system polymorphism.
15:45:10 <conal> sinelaw: and we write "a -> b", where mathematicians often write "b ^ a".
15:45:33 <conal> sinelaw: yeah.  sry.  i made this more complicated while trying to make them simpler.  never mind.
15:47:00 <sinelaw> conal, no damage done.
15:47:24 <sinelaw> conal, do you have a quick example for a non-numeric type, continuously varying ?
15:47:50 <conal> sinelaw: sure.  pair a numeric type with a discrete type
15:47:53 <sinelaw> numeric including vectors, and other combinations of numbers
15:47:57 <conal> sinelaw: and varying the numeric part
15:48:09 <conal> sinelaw: or sum/Either them together.
15:48:44 <conal> sinelaw: luqui is also talking about "connected types", which i haven't yet grokked.
15:49:22 <sinelaw> conal, i'm trying to think of a discrete type that isn't isomorphic to an enumeration
15:49:43 <sinelaw> because then you're back to numbers. tagged numbers, but numbers.
15:49:58 <conal> sinelaw: another example: Bool.  shift from False to True at some point.  there's only a single discontinuity.
15:50:13 <conal> sinelaw: btw, Bool =~ () + ()
15:50:57 <sinelaw> conal, or altenatively, i can argue that allowing direct treatment of types (rather than their possible numeric isomorphic partners) is more convenient and justifies the polymorphic theory
15:52:10 <sinelaw> conal, also, still missing a concrete example, and i mean a realistic one
15:52:16 <conal> sinelaw: if you only needed pairing, then you'd just have vectors.  if you introduce sums, you have something new, i think.
15:52:31 <conal> sinelaw: okay.  i'll think about a concrete example.
15:52:41 <sinelaw> conal, great. i need to go now anyhow.
15:52:57 <conal> sinelaw: good night!
15:52:59 <sinelaw> i'd love an example that summarizes what we want.
15:53:05 <sinelaw> including everything
15:53:13 <sinelaw> conal, thanks. see you later
15:53:23 <conal> yeah
16:15:11 <companion_cube> @type fmap . fmap
16:15:12 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
16:16:52 <cads> oy chums
16:17:15 <cads> ow' ye all be thise eve?
16:22:30 <cads> Hey, the following page expresses the golden rule of haskell indentation as "Code which is part of some expression should be indented further than the line containing the beginning of that expression"
16:22:45 <cads> it's that simple?
16:23:50 <cads> supposing you have  expression e that's broken into e1 e2, then you can say          e1 <linebreak> <indent> e2 ?
16:24:33 <Saizan> yes
16:24:47 <wchogg_> If I'm understanding you right, then yes.  I split application between lines fairly often.
16:25:21 <Saizan> there aren't only expressions in the haskell syntax though :)
16:25:28 <cads> the part of the golden rule that confuses me is this: suppose our expression is split into three lines; will the third line have to be indented further than the second line to be part of the expression, or does it simply need to be indented further than the first line?
16:25:43 <Saizan> the latter
16:25:52 <Berengal> "the line containing the beginning of that expression"
16:25:59 <Berengal> i.e. the first line
16:26:24 <cads> oh, that's exactly what the rule states :D\
16:26:30 <Saizan> yeah, and it's not the beginning of the expression that counts
16:26:43 <cads> the beginning of the statement?
16:26:45 <Saizan> foo =
16:26:52 <Saizan>   a + b
16:27:01 <Saizan> that's valid
16:27:08 <Saizan> or even:
16:27:10 <Saizan> foo = a
16:27:14 <Saizan>  + b
16:27:18 <cads> nice\
16:27:29 <Berengal> It's a nice heuristic, but it's not true all the time
16:27:38 <Berengal> You won't go wrong if you follow it though
16:28:32 <Ke> (one of the things I don't like about haskell)
16:29:08 <cads> well this is what prompted me to wonder, in the past indentation was just something I never used - I mostly use a pencil and paper version of pseudo-haskell to work out programming problems :D
16:29:19 <cads> http://hackage.haskell.org/trac/haskell-prime/wiki/DoAndIfThenElse
16:30:15 * Berengal never got what the problem with that was
16:43:03 <cads> Berengal: the do notation is too subtle for me to quite understand what's going on there, but if the whole thing is one expression(though I think it's a statement), then the golden rule would seem to indicate that the if, then, and else should be indented the same amount
16:44:02 <Berengal> cads: A block of do-notation is an expression, but a single line in a do-notation block can be called a statement
16:44:31 <Phyx-> Hi, happy new year everyone
16:44:51 <cads> happy newyear bud!
16:44:52 <Berengal> cads: Statements in do are basically expressions, optionally with "<var> <- " in front
16:44:53 <Zao> Phyx-: The question is, was it destructive update or not?
16:47:37 <mreh>     Could not find module `Test.QuickCheck':
16:47:38 <mreh>       it is a member of the hidden package `QuickCheck-1.2.0.0'
16:47:38 <mreh>       Use -v to see a list of the files searched for.
16:47:53 <mreh> Quickcheck isn't hidden!
16:48:08 <Phyx-> Zao: i certainly hope so, I have nothing of the last year i want
16:48:16 <Phyx-> I hope the garbage collection kicks in soon
16:48:46 <doserj> mreh: it is when you are compiling using Cabal and QuickCheck is not listed in the dependencies
16:49:16 <Zao> Phyx-: So that's why people drink so much on the eve. To remove any dangling references.
16:49:44 <mreh> doserj, that's the thing, it's listed on hackageDB
16:50:06 <Phyx-> Zao: yes, i've executed many a braincells on new years eve, took me a while to be able to type again
16:50:10 <wchogg_> Are there any convenient workarounds to get ghc 6.12 & gtk2hs playing nice?
16:50:11 <mreh> it still isn't working, although haven't checked the cabal file
16:50:45 <mistermattaway> can anyone tell me why the cabal-install tool isn't doign anything when I run it?
16:51:04 <mreh> mistermattaway, show use what you're typing
16:51:08 <mreh> *us*
16:51:24 <ehamberg> newbie alert: if i have several functions in a program which need randomness, should i make them all return (result,randomGen), or split the generator, pass it as an argument, and only return the result? (or something completely different?)
16:51:38 <mreh> ehamberg: MonadRandom!
16:52:00 <mreh> emhamberg: do you know Monads?
16:52:05 <Phyx-> wchogg_: if you find one, let me know, one with working glade support
16:52:40 <mreh> ehamberg, if a function is random then any function that uses that function is also random, that's the way I Like to think about it
16:52:55 <mreh> i just wrote a program with randomness in it if you want to look at it?
16:53:08 <ehamberg> mreh: not really, but i'm eager to learn how to do this âproperlyâ.
16:53:15 <ehamberg> i'd love to. :)
16:53:43 <mreh> ehamberg: well monads make passing things like random generators around *implicitly* nice and easy
16:53:58 <ehamberg> that's what i'd like.
16:54:05 <mreh> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15507#a15507
16:54:48 <mistermattaway> mreh, I downloaded the cabal install tool for windows here: http://www.haskell.org/cabal/download.html
16:54:52 <mreh> if you can understand this, then that's all you need to do random things in haskell, but you need to grok monads I think, I certainly did before I could usefull program monads
16:55:15 <mreh> mistermattaway, I'm not a windows user, but i'll see what I can do
16:55:51 <mreh> mistermattaway, have you installed the dependencies?
16:56:00 <Berengal> mistermattaway: How are you running it?
16:56:17 <Phyx-> while i'm here, anyway to generate random numbers in a non-io function? While the random functions like randomR are themselves outside of IO, all calls to get a StdGen are IO
16:56:32 <Berengal> Phyx-: MonadRandom
16:56:37 <koeien37> supply moand
16:56:52 <Toxaris> mistermattaway: do you run cabal-install from a console window? you need to run something like "cabal install foo" to install package "foo"
16:56:53 * Phyx- looks it up
16:57:13 <Berengal> Phyx-: Also, you can create your own StdGen, but that means hardcoding the initial seed, or getting it from IO somehow anyway
16:57:15 <c_wraith> Phyx-: I was sure there was a way to construct a StdGen without IO
16:57:23 <mreh> mistermattaway do Run > command.com, do it like that
16:57:33 <mistermattaway> I'll give that a try
16:57:52 <Phyx-> c_wraith: it's an abstract type isn't it? and none of the documented functions (at quick glance) have a non-IO type
16:57:58 <mistermattaway> I didn't realise it was a command line tool :/
16:58:07 <Berengal> @type newStdGen
16:58:09 <lambdabot> IO StdGen
16:58:17 <mreh> Phyx- did what I tell ehamberg
16:58:17 <Berengal> That's not it...
16:58:21 <Berengal> @hoogle Int -> StdGen
16:58:22 <lambdabot> System.Random mkStdGen :: Int -> StdGen
16:58:22 <lambdabot> Prelude (!!) :: [a] -> Int -> a
16:58:22 <lambdabot> Data.List (!!) :: [a] -> Int -> a
16:58:23 <c_wraith> > StdGen 1
16:58:23 <mreh> Phyx- was what I tell ehamberg  wrong?
16:58:24 <lambdabot>   Not in scope: data constructor `StdGen'
16:58:26 <Berengal> There we go
16:58:37 <c_wraith> > mkStdGen 38
16:58:38 <lambdabot>   39 1
16:58:39 <Phyx-> mreh: hm?
16:58:42 <mreh> tell, told
16:59:09 <mreh> > newStdGen
16:59:10 <lambdabot>   No instance for (Data.Typeable.Typeable System.Random.StdGen)
16:59:11 <lambdabot>    arising fr...
16:59:25 <mreh> :t mkStdGen
16:59:27 <lambdabot> Int -> StdGen
16:59:31 <ehamberg> mreh: thanks! that i'll play around with that. did you just read the documentation for MonadRandom? anything else?
16:59:40 <Phyx-> c_wraith: yeah, i saw that one, but the problem is, that Int is the Seed right? so if i call the function 3 times, i'd still get the same 3 numbers, since it would be reseeded with the same number when getting the StdGen
16:59:49 <mreh> ehamberg, learn how to program with monads :)
16:59:52 <koeien37> right
16:59:56 <koeien37> it's a function
17:00:03 <koeien37> f 3 is always f 3
17:00:04 <Phyx-> mreh: sorry, wasn't paying attention to what you were telling ehamberg
17:00:12 <Berengal> Phyx-: The "random" family of functions return a new generator
17:00:14 <mreh> Phyx- oh, it was a new topic
17:00:21 <c_wraith> Phyx-: just about every function that uses a RandomGen instance returns a new instance.  You need to thread use of that through your functions
17:00:29 <mreh> it was a RANDOM topic, haaaaaaaaaa
17:00:36 <c_wraith> Phyx-: MonadRandom is good for that, as Berengal suggested
17:00:53 <Berengal> @type random
17:00:53 <Phyx-> c_wraith: yes, I'm already looking at MonadRandom now :)
17:00:54 <lambdabot> forall g a. (Random a, RandomGen g) => g -> (a, g)
17:01:27 <mreh> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15507#a15507 -- Phyx- working example for you
17:01:29 <Phyx-> yes, that seems like it'll do just fine :)
17:01:31 <ehamberg> mreh: i know the theory. the thing is is that i needed something like this to actually use monads. :)
17:01:48 <mreh> ehamberg, you knew category theory before you know haskell?!
17:02:06 <Phyx-> thanks c_wraith , Berengal :)
17:02:09 <Phyx-> mreh: cool, thanks
17:02:21 <mreh> something I just knocked up ;)
17:02:26 <Phyx-> I think the easiest way to add that to my code is to add another Monad Transformer to my type
17:02:58 <mreh> i'm still having this problem with cabal install, it thinks I have a hidden package
17:03:25 <mreh> but I can see it unparenthesied(?) in ghc-pkg list
17:04:13 <Phyx-> cabal install hides all packages by default no?
17:04:22 <Phyx-> unless you explicitly expose them in the cabal file
17:05:19 <c_wraith> that's correct, Phyx-.  mreh, you have to tell cabal to unhide the package
17:05:38 <Saizan> mreh: cabal doesn't respect what's hidden or not in ghc-pkg, only the what's listed in the build-depends section in the .cabal file matters
17:05:45 <mreh> c_wraith, it's missing the dependency in the cabal file?
17:05:49 <mreh> hackageDB says otherwise
17:06:00 <mreh> maybe they are out of sync
17:06:18 <mreh> im trying to install haskore
17:06:23 <Saizan> http://www.haskell.org/cabal/FAQ.html#hidden-packages-a
17:07:08 <mreh> Saizan: oh, QuickCheck was split was it?
17:08:08 <Saizan> mh, i meant to link the (b)
17:08:09 <mreh> so what do you suggest, cabal fetch, hacking it, and then installing
17:08:39 <Saizan> mreh: can you tell me the name of the package and the exact error message?
17:08:57 <doserj> mreh: do you get the error while building haskore or one of the dependencies of haskore?
17:09:12 <CSWookie> Hey all.  I'm used to Python, and I'd like a list of, "if you're used to doing it this way in Python, do it this way in Haskell."  Can someone recommend me something like that?
17:10:05 <Saizan> i can't find haskore on the package list on hackage..
17:11:04 <Berengal> CSWookie: Many idioms are hard to translate directly. Anything in particular you're wondering?
17:11:35 <mreh> Saizan, doserj, I think it's one of the dependencies, let me check
17:11:48 <Saizan> if you're just starting, you will actually spend most of your energy to _forget_ imperative languages :)
17:11:58 <mreh> it's event list: event-list-0.0.10
17:12:03 <mreh> Saizan: ^
17:12:12 <mreh> doserj: ^
17:12:22 <Saizan> mreh: so, what does it say when you cabal install event-list ?
17:12:47 <doserj> cabal install haskore worked fine here
17:13:25 <Phyx-> wow, that package is old, it has soo many warning
17:14:43 <Saizan> doserj: cabal --version ?
17:14:52 <Saizan> mreh: cabal install event-list -fbuildTests
17:15:04 <Phyx-> hmm event-list failed here too, QuickCheck >=1.1 && <2 is needed in build-depends i think
17:15:29 <doserj> 0.6.4 using Cabal 1.6.0.3
17:15:39 <ezyang> What does "cabal: internal error: impossible"?
17:15:42 <ezyang> mean?
17:15:49 <Berengal> ezyang: someone set up it the bomb
17:16:00 <Saizan> or yeah, "cabal unpack event-list", and put that  QuickCheck >=1.1 && <2 into build-depends: in the Library section
17:16:15 <mreh> i'm ghc 6.10.4 btw
17:16:27 <ezyang> Berengal: oh no
17:16:29 <koeien37> ezyang: that "shouldn't happen"
17:16:59 <ezyang> what should I do?
17:17:12 <koeien37> upgrade cabal if possible
17:17:12 <mreh> Saizan: no errors
17:17:14 <ezyang> or do I have no chance to survive
17:17:45 <mreh> Saizan: could it be haskore's cabal file?
17:17:49 <Saizan> the old Cabal just used the union of executables and library dependencies, the new one is more accurate about them
17:17:49 <Phyx-> Am i still the only one to get "cabal: Codec.Compression.Zlib: premature end of compressed stream" when doing cabal update ?
17:18:03 <Saizan> mreh: if you use "cabal install event-list -fbuildTests" it should build
17:18:07 <koeien37> cabal update works for me.
17:18:33 <Phyx-> i'm using 0.9.0 with cabal lib 1.8.0.2
17:18:47 <Phyx-> and can't get it to update, I resort to manually downloading the tar.gz these days
17:18:50 <koeien37> 0.6.4 with 1.6.0.3
17:18:59 <monochrom> Today I installed Haskell Platform and it gives me cabal-install version 0.6.2. "cabal update" works.
17:19:30 <Saizan> Phyx-: do you have the latest patches?
17:19:43 <mreh> Saizan: should I tell the author of haskore about this problem?
17:19:50 <Phyx-> Saizan: don't know, the last build I did was 2 weeks ago
17:20:05 <Berengal> ezyang: I'd just poke stuff and try again. If that doesn't work, try to look for the error, or ignore the whole thing
17:20:07 <Saizan> Phyx-: istr something similar that got fixed
17:20:09 <CSWookie> Berengal: Well, once upon a time I tried to write a program to randomly generate lineages for a role-playing city using Python.  My computer couldn't handle it because I was creating a massive ammount of objects ahead of time.  Since Haskell is all lazy, I was thinking of writing it in Haskell, but is Haskell object-y?  If it's just functional, I'd like to get a handle on the proper idioms for that.  Any time I've tried to us f
17:20:22 <Phyx-> Saizan: how to i download only the newest patches? I keep downloading the whole repo again
17:20:41 <monochrom> Haskell is not object-y. Haskell is value-y and function-y.
17:20:43 <Saizan> Phyx-: go into the repo and run "darcs pull -a"
17:20:48 <Berengal> CSWookie: Haskell isn't object-y at all. It's very different
17:21:11 <Saizan> mreh: maybe the one of event-list?
17:21:35 <ezyang> I can't update Cabal.
17:21:42 <ezyang> cabal: cannot configure containers-0.3.0.0. It requires base >=4.2 && <6
17:21:46 <ezyang> and I can't update base
17:21:51 <ezyang> maybe I should blow away and try again?
17:21:55 <koeien37> no, you can't update base
17:21:58 <koeien37> that's a GHC part
17:22:26 <Cale> You can fairly closely approximate the essence of object oriented programming, at least, from my point of view.
17:22:45 <koeien37> agreed, but it's not always desireable (often not IMO)
17:22:52 <Phyx-> Saizan: told me no changes. so I guess i do have the latest. The problem might be how i'm building it, I can't build it with my 6.12 since HTTP fails to install, so i'm updating network, cabal lib etc in 6.10.4 and building it that way
17:22:53 <Saizan> ezyang: try with --constraint="containers < 0.3"
17:23:21 <ezyang> Data/Array/IO.hs: Could not find module `GHC.IO.Exception'
17:23:47 <Berengal> Cale: Nobody knows what OOP is exactly anyway, so it's sort of hard to approximate it ;)
17:23:52 <Saizan> ezyang: which version of containers do you have?
17:23:53 <Cale> To me, the thing which characterises OOP more than anything else is the notion that types of data are determined by the operations on that data, and that values are determined by the consequences of those operations.
17:24:00 <Saizan> ezyang: 0.2 should be enough.
17:24:10 <Saizan> ezyang: what are you running to update Cabal, btw?
17:24:13 <Cale> and from that point of view, Haskell can do that rather nicely
17:24:27 <ezyang> "Latest version installed: 0.2.0.1"
17:24:32 <ezyang> "cabal upgrade Cabal"
17:24:42 <Saizan> ezyang: just run cabal install Cabal
17:25:10 <Berengal> Cale: I have a more message-passing duck-typed view of OOP, which is a bit harder to emulate
17:25:14 <ezyang> ok
17:25:21 <CSWookie> Berengal: Hmm.  Should I be thinking in terms of verbs rather than nouns, then?  Like, instead of a structure telling me to whom Mary Beth is related, I make a function that tells me what relationship Mary Beth has to Daniel?
17:25:23 <Cale> i.e. two objects are really the same object if they would respond to the same messages in the same way
17:25:40 <Saizan> upgrade tries to update the dependencies too, and it's more likely to fail
17:25:48 <ezyang> "/home/ezyang/.cabal/lib/unix-2.4.0.0/ghc-6.10.4/libHSunix-2.4.0.0.a(IO.o): In function `slqz_info': (.text+0x227f): undefined reference to `fcntl_read"
17:25:58 <Cale> Oh, what I'm saying applies to the message passing view as well.
17:26:11 <ezyang> also "/usr/lib/ghc-6.10.4/base-4.1.0.0/libHSbase-4.1.0.0.a(PrelIOUtils.o): In function `__hscore_d_name': (.text+0x1c0): multiple definition of `__hscore_d_name"
17:26:20 <Cale> Though, obviously, without the structural subtyping.
17:26:34 <CSWookie> Cale: Are you speaking to me?
17:26:42 <dmhouse> Cale: can we have mbot join #math please?
17:26:58 <Cale> CSWookie: yeah (and Berengal)
17:27:05 <monochrom> mbot still exists?
17:27:07 <Saizan> ezyang: it might be that upgrade screwed up your installation
17:27:09 <Cale> dmhouse: hmm, I'll see about it.
17:27:37 <Berengal> CSWookie: Verbs rather than nouns is a good start, but other useful perspectives are transformations of values and "what is a foo" rather than "how to do foo"
17:27:45 <ezyang> So, reinstall?
17:27:59 <ezyang> (as long as I keep xmonad working, I'm ok.)
17:28:04 <dmhouse> Or whoever's in charge of lambdabot these days, can it please join #math?
17:28:22 <Saizan> ezyang: you might just need to unregister some packages, or at worst wipe your ~/.ghc
17:28:40 <ezyang> I don't know where to start :-(
17:28:48 <Saizan> ezyang: unless you do global installations..
17:29:03 <monochrom> delete everything. install fresh.
17:29:17 <Saizan> that's bound to work :)
17:29:22 <ezyang> ok. So, I need to delete .ghc and .cabal, no?
17:29:33 <Saizan> and if you keep cabal-install around it's easy
17:29:49 <Saizan> .cabal doesn't matter, actually
17:29:50 <ezyang> oh? What should I keep around?
17:30:07 <Saizan> the installed executable "cabal"
17:30:38 <Saizan> then you can remove the whole of the ghc installation and ~/.ghc, reinstall ghc, and install your needed packages with cabal-install
17:31:16 <CSWookie> OK, so I'd like to write a program where I can say, "Is Bob related to Fred?"  If the program has already determined the answer, it says, "Yes," or , "No," as appropriate.  If it hasn't, it finds out, then answers the question.  Ideally, if it knows that Jane is Bob's mother and Fred's great-grand-mother, it should be easier to determine that they are related.
17:31:21 <ezyang> I'm using Karmic's packaged GHC.
17:31:38 <dibblego> CSWookie, that is called memoisation
17:32:46 <Saizan> ezyang: so let apt-get do the removing and installing part, but make sure you rm ~/.ghc first
17:33:31 <ezyang> ok, removed .ghc, and then aptitude reinstall ghc6.
17:33:38 <uorygl> Wasn't there a project in which Haskell or some language was given inflection so that the order of expressions could be freer?
17:33:38 <ezyang> ok, which package should I install first?
17:33:52 <Saizan> well, try "cabal install Cabal"
17:34:10 <Phyx-> CSWookie: this If i remember correct describes what you want to do, and covers some introductory haskell. http://homepages.cwi.nl/~jve/cs/
17:34:30 <ezyang> ok, looks promising
17:34:52 <CSWookie> dibblego: Phyx- Thanks.
17:35:33 <Phyx-> CSWookie: although, it's about computational symantics, It really deals with how to construct a knowledge engine to infer information out of natural language, relationships etc, hence the 410 pages
17:35:56 <Berengal> CSWookie: I'd start by defining what a relation is, then look for some way of encoding that.
17:36:18 <Saizan> uh, nice, you generally see those with logic programming
17:36:37 <ezyang> ok, install went well.
17:36:51 <ezyang> what's next?
17:39:27 <Phyx-> Saizan: it's an interesting read though
17:39:50 <Saizan> ezyang: well, anything you need..
17:40:16 <ezyang> ok
17:40:59 <CSWookie> Berengal: Blood relationships.  I'm trying to think of a precise definition for that.
17:41:05 <McManiaC> can I overwrite an instance declaration of an imported type?
17:41:23 <ezyang> Hmm, stale .cabal makes cabal think that stuff is installed when it isn't.
17:41:25 <ezyang> igh
17:41:36 <Saizan> no, it can't
17:41:56 <Saizan> the register of packages installed is not under ~/.cabal
17:42:05 <Saizan> ezyang: what's the problem?
17:42:06 <Berengal> CSWookie: A tree seems like the natural choice here
17:42:20 <ezyang> For example, I can't import Text.Parsec anymore, since it doesn't exist, but cabal think that it's already installed
17:42:38 <Berengal> CSWookie: Or rather, a forest of trees
17:43:12 <Saizan> ezyang: parsec-2.* is isntalled, and that's what cabal installs by default, so it says it's already installed.
17:43:22 <ezyang> ah.
17:43:29 <Saizan> ezyang: you need to say cabal install "parsec >= 3"
17:45:16 <Berengal> CSWookie: Then looking for a relation is just looking for a common parent node, possibly with a cutoff if you want someone to not be related if they only share a great-great-great-great-grandparent, or something like that
17:46:07 <ezyang> Hm, if base can't be upgraded, I kind of wish Cabal wouldn't tell me about new versions that depend on a newer base.
17:47:04 <Berengal> ezyang: Indeed. There might be a bug report about that. If not, there should be.
17:47:24 <Phyx-> Isn't there an easier way to use FFI with custom datatypes than having to make Storable instances for adt you use. the translation is pretty systematic why can't the compiler do it :S
17:47:43 <Saizan> what does "tell me" means there?
17:47:45 <McManiaC> http://npaste.de/AG/ â if this is the current version, I wonder why there is an toAscList at allâ¦ :O
17:48:08 <McManiaC> or toList
17:48:09 <McManiaC> ^^
17:48:26 <Saizan> Phyx-: c2hs helps with that
17:48:32 <Saizan> or maybe not?
17:49:42 <Phyx-> Saizan: well, only if i have the c types and get use the haskell types it generates, wouldn't be much help i think with existing programs
17:50:16 <Saizan> McManiaC: well the toList implementation could change in the future if the underlying structure changes etc..
17:50:49 <Berengal> McManiaC: The short answer is: Abstraction
17:50:58 <Phyx-> I also have a bone to pick with hsc2hs, i can't figure out why it drops "_" from names and changes the case of names aswell.
17:51:06 <Toxaris> McManiaC: the names toList and toAscList (and many others) are part of a semi-standard interface for container types
17:51:14 <McManiaC> Berengal: abstraction to what? two different names to one and the same function?
17:51:18 <Toxaris> @hoogle toAscList
17:51:19 <lambdabot> Data.IntMap toAscList :: IntMap a -> [(Key, a)]
17:51:19 <lambdabot> Data.IntSet toAscList :: IntSet -> [Int]
17:51:19 <lambdabot> Data.Map toAscList :: Map k a -> [(k, a)]
17:51:38 <Berengal> McManiaC: toList doesn't guarantee ordering, but toAscList does
17:52:20 <McManiaC> ok, and since a Set is "always" ordered its the same?
17:52:23 <Berengal> McManiaC: For example, you could represent a set as a list, in which case toList could just unwrap the underlying list, but toAscList would have to sort it first, because ordering is part of it's contract
17:52:41 <McManiaC> ok
18:03:57 <monochrom> Perhaps CSWookie's brain exploded reading a 420-page book. :)
18:04:17 <Phyx-> wasn't me :)
18:04:44 <monochrom> It's amazing how much programming in an unfamilar language one can accomplish by just talking.
18:05:28 <Phyx-> I find it amazing how much imperative programming just feels "weird" now
18:06:11 <skorpan> right?  for-loops?  gimme a break
18:06:21 <DigitalKiwi> i like mah for loops
18:06:26 <c_wraith> I used a forM loop recently
18:06:34 <skorpan> c_wraith: ew
18:06:36 <c_wraith> it's like the same thing!
18:06:48 <Phyx-> lol
18:06:58 <skorpan> any sane person would use mapM
18:07:06 <koeien37> not necessarily
18:07:07 <c_wraith> (actually, I used a mapM loop.)
18:07:08 <monochrom> skorpan: for (i = 0; i < N; i++) { break; }  // you ask for a break in a for-loop
18:07:18 <HugoDaniel> i like forM
18:07:28 <skorpan> monochrom: touchÃ©
18:07:28 <koeien37> f short long
18:07:35 <skorpan> please, do { continue; }
18:07:47 <koeien37> then choose f in forM, mapM
18:07:52 <monochrom> <<loop>>
18:08:02 <Phyx-> monochrom: undeclared identifier "i" :P
18:08:49 <DigitalKiwi> I want a compiler that spouts error messages with emoticons
18:09:06 <DigitalKiwi> and insults too
18:09:11 <DigitalKiwi> sudo has the right idea
18:09:21 <Phyx-> i chucke everytime i see ghc's "The impossible has happened!"
18:09:29 <Phyx-> chuckle*
18:09:31 <luqui> @src oweij
18:09:32 <lambdabot> Source not found. Take a stress pill and think things over.
18:09:34 <luqui> like that?
18:09:38 <skorpan> DigitalKiwi: how does sudo insult you?  i must have missed out
18:09:47 <luqui> sudo lectures you
18:10:10 <DigitalKiwi> Password: Take a stress pill and think things over.
18:10:10 <DigitalKiwi> Password: You silly, twisted boy you.
18:10:10 <DigitalKiwi> Password: You can't come in. Our tiger has got flu
18:10:11 <koeien37> there is a compiler option for that
18:10:24 <koeien37> erm, option during compilation
18:10:28 <c_wraith> I wrote some iterative code not too long ago.  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15509#a15509
18:10:30 <koeien37> Debian has it disabled, luckily
18:10:42 <skorpan> i don't think arch linux enabled it either
18:10:42 <Phyx-> i've been threatened  by sudo
18:10:43 <monochrom> "inferred type Int :)  does not match  expected type Bool :) " ?
18:10:45 <DigitalKiwi> I know on arch all you have to do is add a line in sudoers
18:10:51 <koeien37> yeah i wrote an MD6 implementation partially with runST too
18:11:13 <ezyang> Hey guys I need typeclass help: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15510#a15510
18:11:19 <DigitalKiwi> Defaults insults
18:11:31 <ezyang> This doesn't typecheck because I need an instance somewhere. I can't figure out /what/ instances though.
18:11:36 <DigitalKiwi> skorpan: add that =D
18:12:14 <Berengal> I wrote some iterative code recently too. It doesn't use ST. http://rosettacode.org/wiki/Midpoint_circle_algorithm#Haskell
18:12:16 <c_wraith> I really like ST, now that I've used it a bit.  It's great for the cases where an algorithm using mutation is the best way to express something.
18:12:52 <luqui> ezyang, what is the error message?
18:12:54 <skorpan> DigitalKiwi: what line?  just "Defaults insults"?
18:13:04 <Phyx-> I wrote some imperative code today too
18:13:21 <DigitalKiwi> yeah
18:13:21 <ezyang> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15510#a15511
18:13:33 <kmc> Haskell is a great imperative language :)
18:13:36 * hackagebot upload: data-memocombinators 0.4.0 - Combinators for building memo tables. (LukePalmer)
18:13:42 <skorpan> i hope it worked
18:14:22 <Berengal> ezyang: Looks like a Failure instance of String is in order
18:14:28 <ezyang> The suggested instance declaration leads to an error message about incoherent instances
18:14:32 <ezyang> let me post
18:14:42 <luqui> kmc, it is a much better functional language
18:15:48 <kmc> luqui, but really you use the two modes together
18:15:59 <luqui> kmc, i prefer to use all functional
18:16:03 <ezyang> sorry about that :-(
18:16:09 <luqui> imperative is a hack :-P
18:16:12 <kmc> we write functions to manipulate datatypes.  IO and ST actions are one of the datatypes we manipulate
18:16:19 <kmc> sometimes the problem you are solving really is about sequences of steps
18:16:23 <Phyx-> luqui: so is unsafePerformIO :P
18:16:29 <kmc> just like sometimes it's about sequences of characters
18:17:09 <Toxaris> but IO and ST actions are kind of dumb, since you can't deconstruct them in any way
18:17:12 <monochrom> @hoogle Control.Monad.Failure.MTL
18:17:13 <lambdabot> package mtl
18:17:27 <kmc> Toxaris, correct, they're an abstract datatype
18:17:30 <luqui> kmc, yeah, but much less than we think
18:17:31 <ezyang> Berengal: you see?
18:17:43 <kmc> luqui,
18:17:44 <kmc> yes
18:17:47 <Toxaris> so if a problem is about some sequence of steps, a problem-dependent action datatype would probably more appropriate
18:17:52 <c_wraith> the shuffle algorithm I posted is one of the cases where using immutable data structures appears to be asymptotically slower than using a mutable structure.
18:18:04 <c_wraith> Given that, it's worth using a mutable structure internally
18:18:11 <kmc> it would be just as crazy to require pure functional style everywhere as to require pure imperative style everywhere.  the latter is of course industry standard practice.
18:18:25 <luqui> kmc, call me crazy then :-)
18:18:28 <Berengal> ezyang: v2 :: (MonadFailure MyError m, Failure String m) => m () work?
18:18:45 <ezyang> trying
18:18:55 <kmc> anyway as i said i don't see them as opposites, any more than "functional" and "string-manipulating" are opposites
18:19:24 <Berengal> c_wraith: Could it be done with lazyness?
18:19:34 <ezyang> Whoa!
18:19:52 <ezyang> what'd you do? :^)
18:20:03 <c_wraith> Berengal: not as far as I know.  it appears to be a case of immutable structures just involving too much copying.
18:20:11 <Toxaris> kmc: being an abstract datatype does not mean you can't look inside it
18:20:22 <Berengal> ezyang: Majic... actually, I just read the errors
18:20:41 <Veinor> ooh, data-memocombinators updated?
18:20:46 <Berengal> ezyang: Here's a hint: Try to remove the type signature and see if it loads then, then just ask ghci to infer the type for you
18:20:49 <ezyang> Berengal: Oh? I don't see anything about constraining m... oh, hm
18:20:51 <Toxaris> kmc: e.g. Data.Set is implemented as an abstract datatype, but there are operations provided to observe sets. Not so with IO.
18:20:51 <Berengal> It's what's type inference is for
18:21:00 <ezyang> Berengal: hahaha, cool cat.
18:21:17 <Veinor> luqui: what'd you change?
18:21:38 <ezyang> no... that makes it incoherent again ^^
18:21:39 <monochrom> I can't find Control.Monad.Failure.MTL
18:21:49 <ezyang> it's in control-monad-failure-mtl
18:22:11 <boucher> anyone know of a good happstack tutorial? happstack's site seems to be down
18:22:23 <Berengal> boucher: happs-tutorial
18:22:39 <boucher> http://www.haskell.org/haskellwiki/HAppS_tutorial ?
18:22:50 <Berengal> It's on hackage
18:23:01 <boucher> forgive my total noob status
18:23:08 <povman> Do computations in IO happen strictly in order?
18:23:15 <ezyang> hm, the first error message suggests adding that constraint
18:23:16 <koeien37> yes, modulo unsafeInterleaveIO
18:23:19 <boucher> just getting this stuff set up for the first time
18:23:19 <boucher> thanks
18:23:23 <ezyang> but it said an OR, so I assumed one or the other was ok.
18:23:52 <povman> koeien37: What does unsafeInterleaveIO do?
18:24:14 <Berengal> c_wraith: I'm a bit sceptical still. I would think tying the knot in some inventive way could've done it
18:25:22 <c_wraith> Berengal: I dunno.  Even Oleg seems to agree that O(n log n) is the best you can do with immutable structures.  (even that much requires some cleverness)
18:25:37 <povman> I'm worried that if I write code like (a <- newPtr 123; n <- getPtr a; setPtr a 0; print n) then I'll end up printing 0
18:25:38 <Berengal> c_wraith: I don't know the algorithm, but it does seem like loeb could've worked...
18:26:08 <shachaf> @quote OlegFacts
18:26:08 <lambdabot> OlegFacts says: Oleg solves NP-hard problems in N log N time... in the type system
18:26:11 <povman> or is n strict?
18:27:14 <Berengal> povman: It's strict. The value of 'n' doesn't change. (If it does, I'd consider it a bug)
18:27:26 <ezyang> Berengal: In fact, I'm only allowed to omit that type signature if I instantiate the type somewhere else. ^^ Type inference is funny...
18:27:48 <Berengal> ezyang: It can be at times
18:28:02 <povman> Thanks.
18:28:24 <Berengal> povman: Of course, you could always test it
18:28:25 <luqui> Veinor, used my new module data-inttrie, got a 10x speedup on the performance of integral
18:28:55 <dolio> povman: You only have to worry if you use "unsafeInterleaveIO (getPtr a)".
18:30:37 <povman> Ok. I had a paranoid moment :)
18:30:53 <povman> I assume the same strictness rules don't apply to other monads?
18:31:33 <dolio> It isn't a necessity, no.
18:31:51 <kmc> (>>=) is an ordinary function, it can be strict or not according to the typeclass instance
18:32:00 <mreh> is (sequence . map) a common idiom?
18:32:02 <povman> yay. Thanks everyone
18:32:12 <dolio> mreh: mapM
18:32:12 <povman> mreh: mapM
18:32:21 <mreh> @src mapM
18:32:21 <lambdabot> mapM f as = sequence (map f as)
18:32:23 <luqui> kmc, but don't the laws imply strictness?
18:32:28 <mreh> coooool
18:32:30 <luqui> kmc, well, some sort
18:32:50 <dibblego> is there a filter for Maybe?
18:33:01 <Berengal> luqui: It implies sequencing, for some value of sequence, but not strictness.
18:33:02 <kmc> luqui, i'm not sure.   i thought the laws were simply "Kleisli m is a category"
18:33:08 <povman> :t catMaybes
18:33:09 <lambdabot> forall a. [Maybe a] -> [a]
18:33:28 <luqui> kmc, certainly (>>= return) = id  means something...
18:33:42 <luqui> not sure what though
18:33:46 <micah> I'm having a problem with modules
18:33:47 <kmc> it means that return is a right identity of (<=<)
18:33:52 <kmc> luqui, id is strict
18:34:35 <luqui> kmc, so (>>= return) must also be strict...
18:39:03 <Saizan> return x >>= f = f x, so return by itself must be non-strict
18:40:07 <dolio> Neither one of those is faithfully adhered to.
18:41:11 <Susan> First guy to make a useful program gets to have sex with me, I feel pretty safe saying that here. Get ready, set, go!
18:41:57 <Cale> Susan: hah
18:42:00 <povman> you said that last night
18:42:05 <monochrom> is it a troll?
18:42:06 <j4cbo> i love IRC.
18:42:15 <povman> yeah it's drunkenmonkey
18:42:19 <BMeph> Susan: So what reward does the guy get? ;p
18:42:19 --- mode: ChanServ set +o monochrom
18:42:22 <Veinor> luqui: nice!
18:42:30 <kmc> "requested"
18:42:42 <monochrom> cool freenode feature
18:42:46 <j4cbo> kmc: it prevents autorejoin from working.
18:43:07 <Veinor> you know what else prevents autorejoin from working?
18:43:09 <Veinor> a ban :O
18:43:15 <j4cbo> it does not, however, prevent manual rejoin from working
18:43:16 <j4cbo> sadly.
18:43:34 <Susan> Where is your humour people
18:43:37 --- mode: monochrom set +b *!i=55c89673@*
18:43:49 <povman> haha
18:44:50 <BMeph> Well, I think a lot of us are laughing now... ;)
18:45:43 <monochrom> BTW what is the "x-kmhhketoasvdrtjz" part?
18:45:54 <Quendus> randomly generated
18:46:00 <Quendus> clearly
18:46:20 <cads> hehe
18:46:42 <cads> susan, susan, can't say the right thing, don't you know where' all turing machines here, we don't have sex
18:46:56 <cads> maybe you could have promist us a beta-reduction-job
18:47:04 <j4cbo> hawt
18:47:21 <cads> ;)
18:47:30 * j4cbo would rather get eta expanded
18:47:38 <dolio> Turing machines get out!
18:51:13 <Veinor> there's a joke about the pumping lemma
18:52:25 <Lycurgus> <conal> i just finished skimming through that reddit thread (http://www.reddit.com/r/programming/comments/ajztk/followup_to_functional_programming_doesnt_work/).  one thought: the critics are more-or-less correct in saying that we pure do not know how to construct large-scale pure functional programs in many domains.  i'm okay with that reality, and because FP is so compelling to me, i'm working on the problem.
18:52:49 <Lycurgus> (just trying to move back on topic with something that interests me)
18:53:48 <Saizan> the whole line was a conal's quote?
18:53:51 <j4cbo> "That's right, mark-and-sweep on these nuts, bitch."
18:54:02 <luqui> fmap.fmap.fmap
18:54:12 <conal> Lycurgus: i'm entirely with you there.  i have a blog post in the works saying exactly that.
18:54:33 <conal> Lycurgus: oh.  you're quoting me!
18:54:35 <Lycurgus> Saizan: yes.
18:54:46 <conal> :)
18:55:00 <luqui> conal, but why work on a problem if it obviously has no solution
18:55:09 <conal> i'm not used to people agreeing with me.  i should have guessed it was my words.
18:55:13 <Saizan> conal: isn't it nice that you agree with yourself?
18:55:26 <Saizan> :)
18:55:26 <conal> luqui: because http://conal.net/blog/posts/fostering-creativity-by-relinquishing-the-obvious/
18:55:41 <mreh> we had a girl on #haskell?
18:55:46 <mreh> does that ever happen?
18:55:54 <luqui> conal, since you pointed it out, i am noticing "proof by lack of imagination" all the time
18:55:55 <c_wraith> what makes you think that was a girl?
18:55:59 <povman> mreh: When? :p
18:56:26 <conal> luqui: awesome!  please spread awareness of that habit.
18:56:48 <mreh> povman, Susan, in the scrollback
18:57:13 <conal> bizarrely, i often hear/read people saying "... because why ...?".  what
18:57:15 <povman> mreh: That was almost not even male, let alone female
18:57:26 <ezyang> I bet bigger open source Haskell projects would go a ways to dispelling the notion.
18:57:26 <conal> what's going on in their brains that they think they've just made an argument?
18:57:35 <Saizan> mreh: there's at least a regular one, and probably others as well.
18:57:56 <mreh> there's a reehul gurl on #haskell!
18:58:06 <j4cbo> *breathes heavily*
18:58:06 <conal> one example of proof by lack of imagination.  and people rarely point it out.
18:58:18 <luqui> conal, relatedly, i've noticed the use of "provably" in CS circles as a tack-on argument strengthener, like "obviously" and "from experience"
18:58:31 <luqui> conal, usually if you say "provably" you would be expected to give a proof :-)
18:59:12 <luqui> anyway... </rant>
18:59:13 <conal> luqui: yeah.  an offer to give a proof.
18:59:30 <mreh> luqui: people always present evidence that they never intend to demonstrate as evidence
18:59:40 <idnar> On the flip side, when grading proofs on math exams, I reliably find that âIt is obvious that Xâ really means âI donât know how to prove X, but I hope itâs true.â :)
18:59:43 <conal> "obviously" is one of those words that is most useful when it is least true.
18:59:44 <idnar> bwahaha
18:59:50 <luqui> conal, :-)
19:00:22 <luqui> that's going in my quotes file
19:00:38 <conal> :)
19:00:43 <luqui> er... we have one of those here
19:00:46 <edwardk> luqui: yes. provably is a nice 'shut up, i'm right' word ;)
19:00:49 <mreh> @remember
19:00:49 <lambdabot> Incorrect arguments to quote
19:00:55 <luqui> @remember conal "Obviously" is one of those words that is most useful when it is least true
19:00:56 <lambdabot> Done.
19:01:07 <conal> luqui: thx! :)
19:02:00 <conal> luqui: here's another mental antipattern i've been noticing a lot lately: "i argue that XYZ", where XYZ is a claim/conjecture.  and then they don't give an argument that XYZ.
19:02:25 <luqui> well, that sentence was their argument.
19:02:31 <luqui> not very compelling...
19:02:35 <conal> luqui: maybe they argue it in secret.
19:02:53 <conal> luqui: not an argument at all.  just a claim.
19:03:05 <conal> go ahead and argue, don't just tell me that you do.
19:03:06 <luqui> a few months ago i found myself spamming the cafe list with opinions
19:03:14 <conal> yeah?
19:03:33 <luqui> so i shut myself up, and resolved to only post posts with content
19:03:34 * conal has no use for opinions -- yech
19:03:40 <luqui> they could be opinions, but i have to back them up
19:03:42 <conal> woot!
19:03:52 <luqui> since then, i've found myself questioning a lot of my opinions
19:03:53 <conal> "The wise speak only of what they know." ~ J.R.R. Tolkien
19:04:05 <luqui> when i've had to abort a post because i couldn't argue my opinion effectively
19:04:07 <conal> glad to hear it.  luke is finding enlightment!
19:04:15 <idnar> the trick to never being wrong is to not say anything unless you're absolutely sure you're right ;)
19:04:17 <luqui> having to push "discard" is a good wake-up call :-)
19:04:24 <luqui> idnar, ...
19:04:33 <luqui> ^ me saying nothing
19:04:42 <conal> lol
19:04:57 <shachaf> luqui: You are wrong. That was not nothing.
19:05:07 <luqui> shachaf, YOU are wrong because i am right.
19:05:13 <luqui> i argue
19:05:34 <idnar> luqui: provably?
19:05:56 <luqui> a proof is obviously not possible.
19:06:34 <Saizan_> being wrong is useful to yourself if someone is there to correct you :)
19:06:37 <luqui> because why can't i think of one?
19:06:38 <idnar> for some reason, I"m reminded of the proof that alexander the great had an infinite number of arms
19:07:26 <luqui> Saizan_, when i told conal what i thought the stone duality was I had the pleasure of being corrected for an hour.
19:07:35 * shachaf was not aware that luqui = Luke Palmer. Huh.
19:07:37 <luqui> so glad i decided to state my wrong opinion :-)
19:07:55 <povman> Saizan_: Therefore being wrong on #haskell is always useful
19:08:11 <conal> asking questions also useful.
19:08:50 <Berengal> conal: Sometimes stating the negative is even more useful...
19:09:03 <Cale> shachaf: I put that together just yesterday too :)
19:09:08 <Berengal> I'm refering to the "foo can't do this!" trolls
19:09:08 <ezyang> Isn't saying controversial things a good way to get lots of feedback? :-)
19:09:41 <luqui> ezyang, depends on how you say it.  if you say with enough force, you will get force feedback, which is not the most useful kind of feedback.
19:09:59 <aavogt> what do you mean by force feedback?
19:10:09 <Berengal> Joystics with motors!
19:10:28 <luqui> aavogt, "I am convinced that Haskell is not suitable for real world applications!"
19:10:34 <luqui> what do you expect the response to that to be?
19:11:01 <Berengal> luqui: "You're wrong. I wrote exactly the program you wanted to prove it."
19:11:03 <Botje> I am convinced of the opposite!
19:11:32 <luqui> Berengal, "But it is ugly and hard to understand, and is not scalable."
19:11:59 <luqui> (3 common subjective vagueries)
19:12:02 <dolio> How do you know?
19:12:09 <Berengal> luqui: "I rewrote it in caligraphy, scaled to work without overheead on the cloud"
19:12:48 <aavogt> but that cloud is overhead, obviously ;)
19:13:12 <luqui> Berengal, "Haskell is full of blind zealots.  This has been fun, but I am never talking to any of you jerks anymore"
19:13:12 <Berengal> provably? ;)
19:13:22 <luqui> btw... i don't know what sort of tangent i have followed
19:13:28 <luqui> or whether i was trying to make a point or be silly :-)
19:13:40 <Berengal> luqui: Can it be a silly point?
19:13:58 <conal> personally, when i hear emphatic/certain statements on #haskell and elsewhere (especially impossible/cannot/must), i guess that the mind behind the statements isn't particularly open/curious, so i'm not very interested in trying to help the speaker see otherwise.
19:14:00 <luqui> Berengal, well you know what they say.  If there is a point to it, what's the point?  If there's no point, what's the point?
19:14:01 <shachaf> Berengal: You can make a silly point in a serious way, or a serious point in a silly way.
19:14:37 <shachaf> luqui: If there's no point, there's no point. Does there need to be one?
19:14:40 <Berengal> luqui: point-free arguing?
19:15:20 <luqui> Berengal, S(KB)(CI(K(SII(SII))))
19:15:24 <Berengal> doesn't scale . looks ugly . not understandable . flip slow
19:15:35 <luqui> nice :-)
19:16:12 <Berengal> instance Arrow Argument where ...
19:16:19 <luqui> flip is slow = (`is` slow)
19:16:48 <luqui> oh yeah, and of course people love to say that X language is slower than Y language.  programs are slow or fast, not languages.
19:17:10 <shachaf> @ty let s = ap; k = const; c = flip; b = (.) in s(k b)(c i (k (s i i(s i i))))
19:17:12 <lambdabot>     Couldn't match expected type `b1 -> a1 -> a -> b'
19:17:12 <lambdabot>            against inferred type `Expr'
19:17:12 <lambdabot>     In the first argument of `c', namely `i'
19:17:15 <Berengal> luqui: I speak English much faster than I speak German
19:17:20 <tensorpudding> some language are slower to learn
19:17:23 <shachaf> @ty let s = ap; k = const; c = flip; b = (.); i = id in s(k b)(c i (k (s i i(s i i))))
19:17:25 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a1
19:17:25 <lambdabot>     Probable cause: `i' is applied to too few arguments
19:17:25 <lambdabot>     In the second argument of `s', namely `i'
19:17:48 <luqui> tensorpudding, that statement is in the Reader Background monad
19:18:04 <Berengal> luqui: `par` and then there's Ruby
19:18:16 <aavogt> luqui: perhaps you're just nitpicking here: if you read those comparisons as asking for the speed of the same algorithm implemented in X vs in Y... but that's too many words
19:18:50 <luqui> aavogt, but in order to express the "same algorithm" in two different languages, you need to have a translation function.  and then it's the translation function which causes slowness or fastness.
19:19:07 <dolio> No it isn't.
19:19:15 <aavogt> but perhaps the problem is that generalizations suck
19:19:16 <dolio> That isn't all there is to it, at least.
19:19:16 <Berengal> First you need implementations, or you won't be running anything
19:19:27 * idnar runs away without an implementation
19:19:47 <j4cbo> the "same algorithm" isn't really a fair comparison either, because some algorithms are better expressed imperatively and some aren't
19:19:50 <j4cbo> see: quicksort
19:19:56 <luqui> dolio, i am overgeneralizing.  but there is rarely a canonical translation function between two languages, so you could implement the "same algorithm" multiple different ways
19:20:04 <j4cbo> "in which language can you accomplish x task", maybe?
19:20:11 <dolio> Any algorithm you write in ruby that actually relies on operations in ruby (and not just calling out to C), and run on the existing ruby interpreters is going to be slower than a lot of other stuff.
19:20:23 <Berengal> j4cbo: If you can't implement the same algorithm in the two languages then they're incomparable on that point
19:20:40 <j4cbo> Berengal: but it doesn't stop people from trying!
19:21:05 <Berengal> j4cbo: Doesn't stop people from being wrong either, but since when is that important?
19:22:19 <Berengal> Anyway, speed is only the concern of mundanes who actually care about running their programs. I never run my programs, making time a non-issue
19:22:22 <monochrom> I argue that translating algorithms between languages is dumb.
19:22:26 <cads> hey, any haskillites that actually have a soft spot for ruby here?
19:22:29 * Berengal imports Acme.Now and is done with it
19:22:41 * cads cautiously raises his hand to count himself in that group
19:22:51 <dolio> cads: I like ruby. But there's no denying that it's pretty slow.
19:23:01 <Berengal> cads: I sort of like it, but I don't know it as well as I should
19:23:25 <skorpan`> i like ruby, but i can't help but dislike its syntax
19:23:25 <Berengal> It'd probably be my goto scripting language if I knew it better than I know python, and I didn't know Haskell
19:23:42 <cads> programming with ruby for me feels like programming with pieces of candy --- it's tasty, for some reason, but also rots me teeth
19:24:20 <dolio> Plus, it doesn't have proper tail recursion, which is a bummer.
19:24:21 <skorpan`> cads: to me it's like sex with a prostitute; feels great at the moment but afterwards you feel dirty
19:24:21 <Lycurgus> ruby isn't as bad as I expected it to be and has some strong points, not in the language but in it's culture and approach to delivery of function
19:24:28 <cads> but it's undoubtedly slow
19:24:50 <skorpan`> ...not that i've had sex with a prostitute. :|
19:25:06 <luqui> skorpan`, uh huh...
19:25:07 <Berengal> skorpan`: Then how do you know?
19:25:17 <Berengal> Heh...
19:25:18 <cads> I agree with what that Lycurgus, though I'd also say that the language is pretty comfortable for people only informally acquainted with theory of computing
19:25:20 <dolio> Cheese it!
19:25:25 <ezyang> I use sup, therefore, I use ruby.
19:25:35 <cads> ezyang: what is sup?
19:25:42 <ezyang> It's a mail client written in Ruby.
19:25:46 <luqui> cads, not much
19:25:54 <cads> hehe
19:26:05 <ezyang> Ruby is ok. On order of Python with a little more syntactic sugar for fp-ish programming.
19:26:19 <Lycurgus> *its
19:26:28 <luqui> ezyang, you mean without irrational fear of higher order functions?
19:26:38 <ezyang> "enh, I wouldn't say that"
19:26:53 <ezyang> Anyway, I have an irrational fear of higher order functions when I don't have my typechecker.
19:27:00 <cads> the one thing that bothers me to no end about ruby is that nobody feels it's important enough to write any papers about it :P
19:27:20 <luqui> ezyang, touche, I also.  Though I didn't when I was a Perl programmer.  I ascribe this to the third virtue.
19:27:25 <Berengal> I have an irrational fear of functions when I don't have a typechecker... people could call them with anything! And how would I know in the function?
19:27:30 <Lycurgus> the original author has I believe
19:27:56 <luqui> Berengal, runtime checks and irrational faith in your test cases, of course
19:27:56 <Lycurgus> though they predate its actual popularity
19:28:08 <Berengal> I've read some papers about Ruby... mostly just comparing the syntax to that of python
19:28:24 <cads> haskell papers have spoiled me, but I don't understand why there aren't any approaches out there to ruby that treat it from a theoretical standpoint - I don't think I've ever seen a book that talked about its grammar in terms of productions, for example
19:28:29 <luqui> we would be having a party if irrational was the secret word
19:28:58 <Lycurgus> i don't think the dearth of real world apps that applies to haskell also applies to ruby
19:29:03 <Berengal> luqui: Can't run runtime checks at compile time :(
19:29:12 <skorpan> isn't the type system *really* just a kind of test suite?
19:29:24 <luqui> skorpan, it's a limited proof suite.
19:29:26 <Berengal> skorpan: It's a proof suite :)
19:29:35 <monochrom> No. change to "really" "just" then yes.
19:29:49 <luqui> "isn't the type system just just a kind of test suite?"
19:29:53 <monochrom> actually "kind" too.
19:30:02 <skorpan> just just a just of?
19:30:13 <Berengal> bork bork bork
19:30:15 <monochrom> Just Just a Just of Nothing
19:30:17 <ezyang> "A really really fast test suite!"
19:30:20 <luqui> monochrom, LOL
19:30:46 <cads> heh, I love how those ruby guys are about using metaprogramming to mock up your test suite as you go along
19:30:52 <monochrom> Anyway, I mean: type checking is "really" "just" a "kind" of "testing".
19:30:55 <cads> it's almost like type annotations in a way
19:31:14 <Berengal> cads: The python decorators also work in a similar way, if you want them to
19:31:31 <skorpan> Berengal: que?
19:31:39 <skorpan> how are decorators and meta-classes even related?
19:31:43 <skorpan> oh, meta-programming
19:31:51 <cads> yeah, not metaclasses
19:31:53 <Berengal> Indeed
19:32:17 * Berengal likes @contextManager
19:32:17 <skorpan> still, one could argue that decorators isn't meta at all :P
19:32:22 --- mode: monochrom set -b *!i=55c89673@*
19:32:28 <Berengal> Not really, they're just higher-order
19:32:28 --- mode: monochrom set -o monochrom
19:32:37 <Berengal> But in a way so is everything meta at runtime
19:32:39 <skorpan> i wrote a decorator today
19:32:41 * ezyang likes decorators. They're a very controlled form of higher order function. 
19:32:45 <luqui> isn't higher order = meta ?
19:32:57 <monochrom> Naw.
19:32:59 <skorpan> luqui: is the definition of "map" meta-programming?
19:33:01 <conal> phew!  finally getting my blogging pipeline unclogged.  more coming.  http://conal.net/blog
19:33:01 <luqui> 2nd order = meta, 3rd order = meta meta, ...
19:33:13 <mauke> bloxative
19:33:15 <cads> err
19:33:17 <luqui> skorpan, sure?
19:33:40 <luqui> skorpan, if the definition of metaprogramming is "map" then at least it has a definition
19:33:42 <Berengal> luqui: foldr is higher order but not meta. TH is meta but not higher order... well, perhaps it is. I don't know how to define higher-order TH
19:33:59 <luqui> I would like a definition of meta...
19:34:07 <cads> I don't think using the map function constitutes "programming your programming language"
19:34:08 <Berengal> @wn meta
19:34:09 <skorpan> lisp macros are kind of meta i would say
19:34:11 <lambdabot> No match for "meta".
19:34:19 <cads> lisp macros are almost the definition of meta :D
19:34:22 <Berengal> @google meta
19:34:23 <lambdabot> http://en.wikipedia.org/wiki/Meta
19:34:23 <lambdabot> Title: Meta - Wikipedia, the free encyclopedia
19:34:26 <dolio> Metaprogramming is writing programs to write programs.
19:34:31 <cads> metaprogramming, I meant
19:34:49 <monochrom> @quote monochrom metaprog
19:34:50 <lambdabot> No quotes match. I've seen penguins that can type better than that.
19:34:54 <ezyang> Metametaprogramming is writing programs to write programs to write programs.
19:34:54 <luqui> dolio, then i would definitely call HOFs metaprogramming.
19:34:54 <Toxaris> I would say, metaprogramming is writing programs to read programs, too
19:35:08 <cads> template haskell is a system for metaprogramming in haskell - at least that's what the title of a paper say ;)
19:35:27 <monochrom> Metamathematics is talking about mathematics. Metaprogramming is talking about programming.
19:35:35 <Berengal> luqui: That only works if you can use term-rewriting, and don't distinguish between compile and runtime
19:35:45 <luqui> Berengal, those are implementation details
19:35:48 <Berengal> luqui: The second works, but the first usually doesn't
19:36:04 <luqui> Berengal, eg. lazy specialization goes somewhere in between
19:36:24 <luqui> but HOFs "compile down" to their specialized equivalents, and in that sense you have written a program with a program
19:36:30 <Saizan_> seeing HOFs as metaprogramming leads to EDSLs
19:36:37 <Berengal> luqui: You still can't use term rewriting in impure strict languages
19:36:39 <luqui> but that is just an evaluation strategy, so... how is it so different?
19:36:54 * cads likes to define metamathematics as doing actual math on mathematics - lots of logic and category theory for example that I'd call that
19:36:55 <luqui> Berengal, I Have No Impure languages
19:37:35 <monochrom> Metaphysics then.
19:38:06 <cads> while the act of wondering about math's nature and "what is the nautre iof the object I evoke when I talk of an integer, and what does that mean for my own existance", that's mathematical philosophy
19:38:07 <Berengal> Metameta
19:38:13 <cads> bo-beta
19:38:22 <cads> banna-fanna
19:38:27 <cads> mmmm, feta...
19:39:17 <cads> monochrom: yeah, metaphysics is usually accepted is thinking about what it is that is outside of physics which cannot be explained in terms of physics (yet)
19:39:56 <cads> meta-wankery :D
19:40:18 <monochrom> haha, thinking about what is outside programming.
19:40:49 <Berengal> Coffee and coke
19:40:55 <Berengal> Sometimes burritos
19:41:04 <Berengal> (But they're just as likely to be inside programming as well)
19:42:01 <skorpan> chipotle
19:42:02 <Berengal> I heard there was something called the sun as well, but I'm not sure it exists
19:42:04 <skorpan> always chipotle
19:42:11 <j4cbo> mmmmm, chipotle.
19:43:14 * cads munches on some pieces of feta cheese and slices of tomatoes, cucumber, and avocado
19:43:33 <cads> clearly I am not a programmer :D
19:43:38 * luqui munches on some apple tree eggs
19:43:40 <tensorpudding> raw avocado?
19:44:01 <dolio> So, anyone have any thoughts on how they'd expect catchError to behave with LogicT (Error e) and such?
19:44:21 <cads> yeah man, you take the avocado out of it's peel, and slice it - a little salt and pepper and a bit of lemon juice, and those slices are the nuclear bomb of taste
19:44:34 <dolio> Or, ErrorT e m, since there is no Error monad by that name.
19:44:34 <skorpan> nucular*
19:45:39 <ahpook> Anyone here do much with Network.Curl ?
19:45:39 <bob0> ahpook: no
19:46:11 <merehap> ahpook: yes, I always hope I can get it to compile properly
19:46:34 <ahpook> Thanks merehap
19:46:41 <Berengal> ahpook: I've done a little bit, but not much
19:46:49 <ahpook> I'm just looking for some usage examples
19:47:02 <luqui> ezyang, so, why are you uneasy as I am?
19:47:35 <luqui> i'm trying to understand what makes me fear haskell as a "real" language, because there is no tangible evidence that I can identify
19:47:51 <ahpook> perform_with_response_ specifically
19:48:13 <Berengal> ahpook: I don't really have any. I was just playing around a bit and don't have the code anymore
19:48:58 <ahpook> Thanks, I was just hopiong that someone had tread where I was about to
19:50:48 <Cale> luqui: uneasy?
19:51:13 <luqui> Cale, re: a comment on my blog.  I was uneasy about making a game in haskell and ezyang agreed.
19:51:51 <ahpook> luqui, my fear of haskell is just unfamilirity...I wonder if I can wrap my mind around it.
19:52:13 <ahpook> I come froma perl background
19:52:24 <ezyang> luqui: It's something that I've been thinking about, and trying to put a finger on.
19:52:25 <luqui> ahpook, me too!  what led you here?
19:53:07 <ezyang> For one thing, I'm not convinced that Haskell has sufficient library support to make a port of any given piece of imperative code easy.
19:53:25 <luqui> ezyang, well sure, but that's why you write libraries :-)
19:53:34 <luqui> ezyang, i think mine stems from a perceived lack of control
19:53:46 <cads> *libraries that do exist seem to be written by hyperbrainiacs
19:53:50 <ezyang> I have a bunch of feelings about this :-)
19:53:56 <luqui> like, what if i build this whole game on a beautiful abstraction and then that abstraction turns out to be insufficient for a small change we want to make
19:53:59 <ezyang> luqui: "lack of control" -> in what way?
19:54:07 <ezyang> ah
19:54:25 <luqui> but i should know better than that.  if that happens, i'm just designing poorly.
19:54:30 <ezyang> Yeah, that's a big one.
19:54:47 <ezyang> I'm not quite convinced purely functional abstractions take hacks easily.
19:54:47 <cads> ezyang, luqui, I feel similar to you guys - ruby background here
19:54:48 <Berengal> I'm a bit scared of the language becoming too popular. If enough people start using it for "serious business", they'll complain when we change things, like making head safe and making Monad a subclass of Functor
19:55:05 <Cale> At the very least, the traditional unprincipled way of writing a game seems like it ought to work anyway.
19:55:05 <luqui> ezyang, they certainly don't.  i love them for it :-)
19:55:10 * hackagebot upload: OSM 0.4.0 - Parse OpenStreetMap files (TonyMorris)
19:55:10 <ezyang> In an academic context, that's not bad. For an engineer, ugggh
19:55:34 <luqui> yeah, though i think our game studio can take it.  we don't have a typical engineering philosophy
19:55:37 <ahpook> luqui, haskell attracted me for it's greater rigor. perl lets you get away with some heinous shxt
19:56:11 <luqui> if the code can't be made beautiful, then maybe the feature is not beautiful.  cut it?
19:56:24 <luqui> (after consideration, or how to make the code accurately represent the feature)
19:56:28 <cads> ehh
19:56:41 <cads> if you're speaking an ugly language.. how will your code be beautiful?
19:57:11 <Berengal> I've done some iterative "agile" programming in haskell, basically building pyramids one side at a time, and it works surprisingly well
19:57:19 <luqui> cads, well code beauty can come out in almost any language.  maybe it won't be poetry (small scale beauty) but it can still be a good story (large scale beauty)
19:57:36 <ezyang> my impression of game code is that you get to throw out the code every time you finish the game?
19:57:45 <cads> not so
19:57:48 <luqui> ezyang, that's just the industry being stupid
19:57:49 <ahpook> I'm tried to pick a real-world learning project for haskell...rewrite an existing C program
19:58:06 <cads> you still have to support the game, and reuse as many libs as possible in other games
19:58:06 <luqui> "we won't need to reuse this" is a great way to write non-reusable code :-)
19:58:10 <djahandarie> Berengal, how about recursive agile programming? :P
19:58:14 <ahpook> It's a FASTCGI that does XSLT transformations on the fly
19:58:31 <ahpook> all the libraies I used have haskell bindings
19:58:37 <Berengal> djahandarie: Agile is all about not having a base. You'll be stuck in an infinite recursion :(
19:58:58 <ahpook> so it's just a matter of experiment and hope, and sometimes beg for help
19:58:59 <cads> ahpook: is this an ongoing project, have you had success?
19:59:00 <Berengal> ahpook: you should look into HXT
19:59:18 <luqui> Berengal, so you better be writing in haskell, which is the only language i know of that supports infinite recursion :-)
19:59:41 <Berengal> luqui: That assumes Agile is productive
19:59:43 <ahpook> Berengal, I never got it working quite right
19:59:56 <luqui> Berengal, that is a big assumption :-)
20:00:00 <cads> luqui: one thing I find is that even if I am implementing an algorithm in ruby, I now first model things at least metnally in a haskell-like functional language
20:00:02 <Berengal> luqui: Exactly
20:00:27 <luqui> cads, it was not long into my haskell experience that i started thinking primarily in types
20:00:32 <Berengal> ahpook: I've done a bit HXT. It's not that hard once you grok the execution model
20:00:54 <luqui> and that has infected my process even in other languages
20:01:24 <cads> luqui: if I'm deriving an algorithm from scratch, it's straight up dependent types and a proof and I'm done :D
20:01:33 <cads> heh, it is not so simple.
20:01:35 <ezyang> Another big question, in my mind, is how hard you should try to make it functional before going imperative.
20:02:10 <cads> but one of the big reasons I think that sometimes people come to haskell and are uncomfortable is that they learned a different programming culture that came from a different line of research
20:02:11 <luqui> ezyang, well say you have time t to complete the problem, and you know it will take time u to make it imperatively
20:02:22 <luqui> you have (t - 10u) time to try functionally
20:02:25 <dolio> Oh well, never mind, catchError clearly doesn't work right.
20:02:31 <ezyang> heh.
20:02:53 <Berengal> luqui: That is provably <0, always
20:03:00 <luqui> Berengal, obviously?
20:03:21 <Berengal> luqui: Per the discussion earlier, I am willing to provide a proof
20:03:23 <cads> haskell and its techniques come from a lot of research in type theory, categories, and logical frameworks - is that a passably correct notion?
20:03:28 <ahpook> Berengal: I've been using XSLT for about 10 years. It's ugly, but I understand it.
20:03:32 <luqui> Berengal, please do :-)
20:03:37 <holmak> ezyang: Often, I find myself refactoring later to make things more functional.
20:04:08 <holmak> ezyang: In my experience, Haskell code is very easy to refactor, even with large changes, so its a viable strategy.
20:04:41 <luqui> holmak, yes!  i had noticed that but never acknowledged it.  Haskell is a pleasure to refactor.
20:04:45 <Berengal> luqui: You know it takes u time. You tell your manager it takes 20u. He gives you 1/3u (deriving of the function left as an excercise). (1/3 - 10)u < 0u
20:05:03 <holmak> So I just make it work first, then fix it up later. I think I'm getting better at writing it well on earlier attempts, so that seems to work out.
20:05:09 <ezyang> I'm glad you guys can say those things. It's heartening.
20:05:28 <cads> ezyang: how strong are you at math/logic?
20:05:32 <ezyang> Another terrifying thing is that I find myself wanting to say "often times", and then stop myself, realizing I've only done that particular thing once.
20:05:35 <luqui> Berengal, that's just bad game theory.  obviously 30u is the correct amount of time to tell your manager.
20:05:40 <holmak> ezyang: My advice would be; just write something, as best you know how. Then go back and critique after.
20:05:48 <luqui> "obviously" :-)
20:05:51 <cads> ezyang: and have you read any academic papers on haskell?
20:05:58 <ezyang> cads: Decently so, although I wouldn't be a good math major.
20:06:00 <ezyang> Yep.
20:06:14 <cads> can you teach someone what a monad is?
20:06:25 <ezyang> I'm going to attempt that this January :-)
20:06:32 <cads> excellent!
20:06:34 <luqui> the rite of passage!
20:06:43 <luqui> what is his initiation?
20:07:17 <Berengal> luqui: The relation isn't linear. In fact, it's inversely proportial when n> 1 (where nu is the time you tell you manager), otherwise it's 1/2n.
20:07:19 <ezyang> Specifically: http://sipb.mit.edu/iap/haskell/
20:07:59 <povman> luqui: http://wwwhome.cs.utwente.nl/~fokkinga/mmf91m.ps
20:08:26 <povman> ezyang: http://wwwhome.cs.utwente.nl/~fokkinga/mmf91m.ps I swear that paper made me rethink programming
20:08:41 <luqui> yeah that is a fokking good paper
20:09:06 <cads> the only problem I have with haskell is that it has motivated me to go onto the path of becoming a mathematician/logician and do not often find time to program anything at all anymore
20:09:19 <luqui> it is the point when you transcend recursion that you know you will never be able to take a java job again
20:09:31 <holmak> I've been reading http://blog.sigfpe.com/2010/01/monads-are-trees-with-grafting.html ; I think it is by far my favorite explanation of monads yet.
20:09:40 <dibblego> ha, I start a new Java job tomorrow
20:09:53 <Berengal> cads: I sometimes think so too, but then I have to code a new webservice in java, and I'm not sure it's a bad thing anymore.
20:10:21 <luqui> Berengal, not so sure java is a bad thing?
20:10:39 <Berengal> luqui: No, the mathematician/logician vs programmer thing
20:10:46 <cads> I can agree with that... once you learn the theory, every language is just another language, and some just require more patience is all
20:11:18 <Berengal> It's a bit funny how the set of programming languages seem to shrink the more of them you learn...
20:12:06 <cads> if my aim was to program more and better and more complex programs, I've succeeded in that I am _able_ to do the last two now, but I fail at the first because I prefer to say write a paper now over writing a program
20:12:06 <Berengal> when I first started programming, Java and python were worlds apart. Then I learned some more imperative languages, and I started to see how they were similar. Then I learned haskell, and they all seemed like dialects of the same language...
20:12:21 <Berengal> Now they all start to look like lambda calculus in the limit...
20:12:39 <medfly> I feel like that too. all languages besides Haskell are dialects of C.
20:12:45 * medfly excludes lisp
20:12:50 <cads> and coq
20:12:52 <mauke> and perl
20:12:57 <Jafet> Perhaps you should learn more languages.
20:12:58 <cads> and smalltalk
20:13:04 <mauke> and prolog
20:13:08 <ezyang> cads: That's funny, because I once heard a mathematician turned programmer say that programming was a trap for enterprising young PhD candidates :-)
20:13:12 <cads> and that new language Boojizznay
20:13:12 <Berengal> and my axe
20:13:18 <cads> and my sword!
20:13:22 <mauke> Berengal++
20:13:35 <Berengal> :)
20:13:37 <medfly> I mean sure, some are different
20:13:51 <dolio> Twelf is just like C.
20:13:54 <medfly> but the few I've seen all look like C dialects.
20:14:09 <medfly> in some way
20:14:14 <medfly> "oh, and we added this thing"
20:14:18 <Saizan_> @remember dolio Twelf is just like C.
20:14:19 <lambdabot> I will never forget.
20:14:43 <Berengal> I don't even understand why people claim "different languages for different tasks" anymore. It used to make sense, but they aren't using different languages anyway, just different syntax...
20:14:48 <ahpook> MJ Dominus did "higher order perl"...reaaly nice code, but so clunky compered to what haskell just does.
20:14:50 <Jafet> Haskell uses the C preprocessor!
20:15:02 <Berengal> Now I'm starting to think there might even be one language to rule them all
20:15:06 <Saizan_> dolio: Twelf didn't make a good impression to you, eh?:)
20:15:21 <mauke> preflex: xseen yrlnry
20:15:21 <preflex>  yrlnry was last seen on freenode/#haskell 4 days, 12 hours and 2 seconds ago, saying: theorbtwo: I got the idea from Emacs.  I had heard that the same thing happened with Emacs's "collecting garbage" messages.  People complained that it was taking too long to do garbage collection.  So FSF eliminated the messages and the "problem" went away.
20:15:23 <dolio> Saizan_: That was supposed to be a counter-example. :)
20:16:15 <cads> Berengal: we're also seeing a lot of languages with much more flexible syntax now that you mention it
20:16:58 <cads> hey, question, is it true that much programming in the windows world for basic desktop applications is now being done in .net and running on the CLI?
20:17:57 <ezyang> Man, the list monad is such a beautiful way to demonstrate monadic concepts.
20:17:58 <dolio> Saizan_: Doing computation in Twelf is sort of like doing it in Prolog, but from what I understand, people don't generally use it for that purpose.
20:17:59 <luqui> cads, IIUC, mostly true.
20:17:59 <dibblego> Berengal, I prefer "some languages rule others"
20:18:10 <luqui> languages form a partial order
20:18:15 <luqui> is there a supremum?
20:18:32 <cads> I mean, there are different ordering relations
20:18:37 <luqui> (the ordering operation being "more awesomer than")
20:18:58 <mauke> blub!
20:19:14 <dolio> Saizan_: Rather, you use it to prove things about terms in the logical framework, where those terms and relations on them would be the computation of your object language.
20:19:31 <dolio> But you can't actually compute with those.
20:19:40 <dolio> So it's even less like C than, say, Coq.
20:19:48 <Saizan_> dolio: i like the idea that you get what would be the stack of the resolution in prolog reified as an inductive
20:20:42 <Saizan_> though i never learned how to use worlds, or higher order terms properly
20:20:52 <cads> luqui:  there's like a minimal 5 color turing machine that's equivalent to universal turing machine, discovered by one of wolfram's students or something, should we say that this language is more awesome than another language because it is the smallest one?
20:21:11 <cads> though I might certainly think so :)
20:21:17 <luqui> cads, ever seen FRACTRAN?
20:21:27 <cads> oh lord that just sounds bad
20:21:39 <cads> hah
20:21:44 <cads> conway has his hand in it
20:21:57 <ezyang> .. if that's a bad pun on FORTRAN, I don't appreciate it! :-P
20:22:19 <cads> http://en.wikipedia.org/wiki/FRACTRAN
20:23:16 <cads> "can be seen as a register machine where the register state is stored in the prime factors of the argument"
20:23:17 <dolio> Saizan_: Yeah, I kind of slacked off about half way through the tutorial I was reading.
20:23:47 <Jafet> http://www.esolangs.org/wiki/Fractran_plus_plus
20:38:08 <cads> hey, anyone here ever play a video game called Carnage Heart?
20:38:08 <bob0> cads: no
20:38:28 <cads> bob0: do you just want to dash my dreams?
20:39:01 <cads> or is it
20:39:21 <cads> hey, anyone here ever *blahblah* really well?
20:39:21 <bob0> cads: no
20:39:55 <cads> hey, anyone here ever given up a klondike bar just to be left alone?
20:39:55 <bob0> cads: no
20:40:09 <cads> For that would be insane.
20:40:26 <elly> this is a little bit surreal.
20:47:21 <cads> elly: I think bob0 is a bot meant to stop people from asking too many "hey, anyone here ever done ____?" type questions with a zen like instantaneous and shocking response, that makes you rethink your question
20:47:22 <bob0> cads: no
20:47:33 <cads> whatever, maaan :P
20:47:38 <elly> cads: I'd be surprised...
20:48:27 <cads> hehe, I suppose we can ask bob0
20:48:35 <mauke> has anyone really been far even as decided to use even go want to do look more like?
20:49:19 <elly> mauke: <3
20:49:47 <cads> hey, has anyone I don't gotten bug bat  bitten jewel powder perhaps dried jews?
20:50:10 <mauke> you mean like deflematron palp thararigomeworthortho gadykitch
20:50:27 <cads> hey, has anyone here ever?
20:50:28 <bob0> cads: no
21:03:53 <mtnviewmark> question about cabal's build-depends lists:
21:04:13 <mtnviewmark> can I have one in the global section, and then one in each of the library and executable sections?
21:04:26 <mtnviewmark> and if so - do they add or replace the global one?
21:05:33 <Axman6> mtnviewmark: may i direct you to #hackage?
21:05:51 <mtnviewmark> oh - didn't realize they ran their own channel!
21:12:49 <gwern> tjere's a #hackage?
21:12:52 <gwern> why ever?
21:13:41 <elly> to talk about hackage?
21:13:43 <Jafet> So that we can doubt its existence
21:15:14 <gwern> elly: is there quite so much discussion?
21:15:21 <elly> gwern: no idea
21:18:51 <Axman6> gwern: not really, we need more people. it was set up to keep cabal/hackage discussions away from here
21:19:39 <gwern> ah yes, fragmenting tiny communities
21:19:56 <gwern> as someone with anti-Occamian priors, I support that: it's never worked before, after all
21:20:32 * mtnviewmark glances at the > 500 members in the channel
21:20:56 <cads> Anti-Occamian? Can such a view be said to be rational?
21:21:48 <gwern> cads: it's something of an open question; better to ask 'does an anti-occamian universe even make sense?'
21:22:07 <kamatsu> Lemmih: get that patch I sent you?
21:22:08 <Jafet> We live in one.
21:22:10 <cads> and if so, what kind of arguments might you give for rejecting a simpler explanation over a more complex one, given equal explanatory power?
21:22:28 <Jafet> cads, complicated ones
21:22:36 <cads> clearly :)
21:23:06 <cads> does an anti-occamian seek an ornate and grandiose explanation for things?
21:23:33 <mtnviewmark> cads: what about "they are funnier"? I like that basis!  :-)   Why should all our mathematical rigor be so dang dry?!?!?!
21:23:45 <Jafet> Just read a few monad tutorials
21:23:58 <kamatsu> monads are a monoid in the category of endofunctors
21:24:02 <kamatsu> it's all very simple
21:24:48 <gwern> cads: mm. I always took an occamian prior to favor things that have previously happened - every time the sun rises our belief it will rise tomorrow also rises; so anti-occamian would be that things that haven't happened are likely and are more likely the less they happen; you see why I wonder whether this is a coherent belief given the infinitude of things that haven't happened
21:24:48 <cads> that's actually the definiton that made everything click
21:24:49 <mtnviewmark> "monads are like a transparent train, moving backward in time... and filled with Jell-O"
21:25:36 <cads> and you need to wear a spacesuit if you're going to work with them or else you get irradiated something bad
21:25:53 <cads> astrocub wonders what the heck he just stumbled into :)
21:25:58 <kamatsu> pretty mean burrito
21:26:05 * gwern decides to go to bed before burritos come up
21:26:05 <kamatsu> all that radiation
21:26:12 <kamatsu> gwern: too late
21:26:17 <cads> gwern, burritos have already come up
21:26:18 <Jafet> @remember mtnviewmark monads are like a transparent train, moving backward in time... and filled with Jell-O
21:26:19 <lambdabot> Nice!
21:26:39 <gwern> dammit
21:26:42 <gwern> @flish
21:26:50 <cads> yup, the good old time travelling mark twain train jello monad
21:26:58 <mtnviewmark> alas - it was in quotes because kmc said it a while back ...
21:27:02 <gwern> incidentally, that's what I use from now on. @flish. the better to confuse people
21:27:19 <medfly> flish flush
21:27:56 <Berengal> slush?
21:28:08 <c_wraith> @slush
21:28:10 <lambdabot> Not enough privileges
21:28:12 <c_wraith> slush works
21:28:29 <Berengal> , length dict
21:28:34 <lunabot>  479830
21:29:32 <Jafet> What a long dict.
21:29:51 <DigitalKiwi> that's what she said
21:30:07 <Berengal> , elem "zebra" dict
21:30:11 <lunabot>  True
21:30:15 <Berengal> Nice
21:30:31 <kamatsu> , elem "endofunctor" dict
21:30:34 <lunabot>  False
21:30:37 <kamatsu> aww
21:31:29 <mtnviewmark> @remember kmc a monad is like an invisible train filled with jello traveling backwards in time
21:31:30 <lambdabot> Okay.
21:31:36 <mtnviewmark> that was the original quote
21:31:53 <Jafet> Hrm
21:32:12 <Jafet> Now we have two jello quotes
21:32:21 <mauke> @quote .chocolate
21:32:21 <lambdabot> SimonBrenner says: 2kg of chocolate 'thunks' to 'force' really might 'blow your stack' later on.
21:32:29 <mauke> @quote monad.*chocolate
21:32:29 <lambdabot> Duqicnk says: a monad is like a train that runs backwards in time, which is made of tiny chocolate robots
21:32:38 <mtnviewmark> well - I didn't feel right, the real credit goes to kmc
21:33:22 <Jafet> @quote monad.*train
21:33:22 <lambdabot> kmc says: a monad is like an invisible train filled with jello traveling backwards in time
21:33:43 <cads> so a monad is an assemblage of complex machinery which work contra-wise to any reasonable intuition you might have before meeting monads?
21:33:56 <mtnviewmark> -- and it wiggles!
21:33:57 <kamatsu> cads: complicated
21:34:22 <mtnviewmark> did I mention it is sweet?
21:34:24 <kamatsu> also tasty
21:34:25 * Jafet takes a monad shot
21:35:17 <cads> I don't see what's so tricky about a monad being a monoid in the category of endofunctors, then all one has to wonder about is "what does it mean for an edofunctor to be a monoid"
21:35:55 <Berengal> , filter (`elem` dict) [x ++ c:tail y | n <- [0..length "flush"], let (x, y) = splitAt n "flush",  not (null y), c <- ['a'..'z']]
21:36:01 <lunabot>  Killed.
21:36:04 <Berengal> :(
21:36:44 <Jafet> > goto "failed"
21:36:45 <lambdabot>   "failed"
21:36:47 <Berengal> , filter (`elem` dict) [x ++ c:tail y | n <- [0..length "flush"], let (x, y) = splitAt n "flush",  not (null y), c <- ['a'..'z']] !! 0
21:36:50 <lunabot>  "blush"
21:36:59 <Berengal> , filter (`elem` dict) [x ++ c:tail y | n <- [0..length "flush"], let (x, y) = splitAt n "flush",  not (null y), c <- ['a'..'z']] !! 1
21:37:03 <lunabot>  "flush"
21:37:10 <Berengal> , filter (`elem` dict) [x ++ c:tail y | n <- [0..length "flush"], let (x, y) = splitAt n "flush",  not (null y), c <- ['a'..'z']] !! 2
21:37:15 <lunabot>  "plush"
21:37:25 <Berengal> I think I'm on to something
21:37:27 <Jafet> Perhaps you should filter the dict instead.
21:37:48 <Berengal> , filter (`elem` [x ++ c:tail y | n <- [0..length "flush"], let (x, y) = splitAt n "flush",  not (null y), c <- ['a'..'z']]) dict
21:37:54 <lunabot>  Killed.
21:37:59 <Berengal> :/
21:38:02 <Jafet> Erm.
21:38:07 <Berengal> > 26^5
21:38:08 <lambdabot>   11881376
21:38:19 <Jafet> > 26 * 5
21:38:20 <lambdabot>   130
21:38:26 <Jafet> > 26 * 5 * 479830
21:38:27 <lambdabot>   62377900
21:38:32 <jfischof> how do you write an Arbitrary instance that only generates list with certain elements?
21:38:33 <Berengal> Right
21:38:34 <Jafet> Well, /2.
21:39:38 <dolio> You probably wouldn't write an Arbitrary instance like that. Just a custom Gen.
21:39:48 <dolio> And use forAll.
21:41:11 <jfischof> dolio: does that mean that I will be writing a coarbitrary method?
21:41:41 <Berengal> , length (takeWhile (<= "flusz") dict)
21:41:43 <lunabot>  146683
21:42:15 <Berengal> , filter (`elem` (takeWhile (<= "flusz") dict)) [x ++ c:tail y | n <- [0..length "flush"], let (x, y) = splitAt n "flush",  not (null y), c <- ['a'..'z']] !! 2
21:42:18 <lunabot>  "flush"
21:42:21 <Berengal> , filter (`elem` (takeWhile (<= "flusz") dict)) [x ++ c:tail y | n <- [0..length "flush"], let (x, y) = splitAt n "flush",  not (null y), c <- ['a'..'z']]
21:42:26 <lunabot>  ["blush","flush","flush","flash","flesh","flosh","flush","flush","flush",...
21:42:30 <Berengal> wow
21:42:35 * Berengal poses
21:42:50 <Cale> jfischof: Probably not?
21:42:52 <Jafet> Won't give you "plush"
21:42:52 <dolio> jfischof: No.
21:42:56 <dolio> @type forAll
21:42:57 <lambdabot> forall a prop. (Show a, Testable prop) => Gen a -> (a -> prop) -> Property
21:43:12 <Cale> jfischof: coarbitrary instances are needed only if you need to generate random functions from a given type
21:43:33 <Berengal> , filter (`elem`dict) [c:"lush" | c <- ['a'..'z']]
21:43:38 <lunabot>  ["blush","flush","plush","slush"]
21:43:39 <mtnviewmark> jfischof: something like   do { n <- someLength; replicateM n (elements "abcdef"); }
21:44:02 <Berengal> Jafet: That's those out of the way
21:44:12 <jfischof> okay cool. Thanks all
21:44:17 <Berengal> , filter (`elem`dict) ['f':c:"ush" | c <- ['a'..'z']]
21:44:22 <lunabot>  ["flush","frush"]
21:44:30 <cads> heh, steganographic programming language, related to BF through a translator: http://www.esolangs.org/wiki/Braincopter
21:44:30 <Berengal> , filter (`elem`dict) ['f':'l':c:"sh" | c <- ['a'..'z']]
21:44:35 <lunabot>  ["flash","flesh","flosh","flush"]
21:44:42 <Berengal> , filter (`elem`dict) ['f':'l':'u':c:"h" | c <- ['a'..'z']]
21:44:47 <lunabot>  ["flush"]
21:44:52 <cads> flosh?
21:44:56 <Berengal> , filter (`elem`dict) ['f':'l':'u':'s':c:"" | c <- ['a'..'z']]
21:45:00 <Jafet> http://www.esolangs.org/wiki/Whitespace http://www.esolangs.org/wiki/Piet
21:45:02 <lunabot>  ["flush","flusk"]
21:45:13 <cads> "but granpa, you don't have any teeth, what would you 'flosh'?"
21:45:19 <mtnviewmark> are you trying to solve a crossword puzzle by brute-force?
21:45:45 <mauke> http://mauke.ath.cx/stuff/whitespace/
21:45:56 <Berengal> mtnviewmark: Finding actual words that differ from "flush" in at most one character
21:46:17 <mtnviewmark> ah - exciting Saturday night, you've got there!  :-)
21:46:36 <dolio> Of course, QuickCheck also defines a Positive newtype for generating positive numbers, instead of having a positive Gen to use with forAll.
21:46:42 <dolio> So it's kind of inconsistent.
21:47:08 <Cale> Generate a dense crossword puzzle for which there is only one true solution, but such that there are at least two possible answers for each clue, and such that the wrong answers can fill the entire puzzle apart from one cell :)
21:47:25 <Veinor> Cale: evil
21:47:48 <Veinor> what do you call m m a -> m a again?
21:47:54 <Cale> join
21:47:56 <Veinor> thanks.
21:48:04 <dolio> Ill-kinded.
21:48:14 <Veinor> join m = m >>= id, right?
21:48:19 <mauke> @src join
21:48:19 <lambdabot> join x =  x >>= id
21:48:21 <Veinor> yay!
21:48:28 <cads> Cale: doubtlessly you'd make some wrong alternatives compatible with correct answers in lines that it crosses
21:49:43 <Jafet> What's the complexity of crosswords?
21:50:05 <Jafet> Generalized sudoku is in NP, sokoban is PSPACE
21:50:21 <cads> I think it can be solved by a contrastraint solver
21:50:28 <cads> constraint*
21:50:30 <mtnviewmark> well - depends on how you write your checks, no? If you just want bare top level properties as your checks, then you need a newtype
21:50:55 <Veinor> Jafet: what do you mean?
21:51:12 <Veinor> I mean, do you have given table of valid words, and a constant-time recognizer of whether a word fits a given clue?
21:51:40 <Jafet> Crossword is probably BRITISH-complete
21:52:41 <Jafet> Veinor, replace each clue by the set of words that fits it
21:53:22 <Jafet> It can probably be reduced to exact cover or something
21:53:44 <Veinor> Jafet: do we assume that the set of words that can fit a given crossword clue is O(1)?
21:54:44 <Berengal> Veinor: It's just length, no?
21:54:50 <cads> that takes the fun out of crosswords, plus, there are different possible words depending on what stage of completion the puzzle is at
21:54:53 <Jafet> Should we?
21:55:19 <Veinor> cads: possible words meaning 'all words that could be considered to fit the clue given no information'
21:55:25 <Berengal> cads: That's the exact cover algorithm's problem
21:55:44 <Veinor> so if it was 'singer Presley', there would be presumably one word
21:55:54 <Veinor> possibly 2
21:56:00 <Veinor> if it was 'odd prime'...
21:56:22 <Berengal> cads: Also, crosswords aren't fun if they're a solved problem. I ruined sudoku by solving it
21:56:37 <cads> no way, that's equivalent to a whole process of having to compute what singers were named presley
21:56:50 <Veinor> cads: we have an oracle! :P
21:57:01 <Berengal> cads: Presumably you have a knowledge engine for that sort of thing
21:57:15 <Berengal> Total in the domain of the crossword
21:57:26 <mtnviewmark> obviously none of you have done the cryptic crosswords in the Atlantic or Harpers
21:57:33 <Berengal> Also, the CPU is spherical and the keyboard is a point.
21:57:36 <cads> so we have an adaptive algorithm that queries a knowledge oracle for stuff like, ie., pop culture
21:58:16 <cads> and our problem reduces to the corver problem Berengal mentions
21:58:25 <Veinor> cryptic crosswords are eeeevil
21:58:45 <mtnviewmark> ya know, Haskell could easily lull me into being complacent about running my unit-tests: If the module compiles the ALWAYS run!
21:59:13 <mtnviewmark> Veinor - which is why I love them so!  (and why my spouse hates them!)
21:59:24 <cads> you can still express well typed bugs though, mtnviewmark
22:00:01 <mtnviewmark> true - actually, adding unit tests to this package actually exposed a moderate to serious bug in it -- so I'm glad I went to the effort
22:00:06 <Berengal> mtnviewmark: You're not complacent about unit tests, you've just replaced a whole bunch of them with automated proofs
22:00:46 <mtnviewmark> speaking of which - anyone here a Criterion user?
22:00:46 <bob0> mtnviewmark: no
22:00:47 <cads> yeah, now you get to write the nitpicky dependent terms of your specification as unit tests, yaaay
22:01:11 <Jafet> Oh, I know
22:01:16 <Jafet> Make the clues refer to each other
22:01:18 <mauke> bob0: how would you pass the turing test?
22:01:40 <Berengal> When I moved from python to haskell, I found unit tests were mostly unneccessary because they would only test the correctness of the compiler or a standard library function...
22:01:49 <cads> mauke: he does alright by simply replying no to the question "anyone here?"
22:01:49 <bob0> cads: no
22:02:01 --- mode: ChanServ set +o mauke
22:02:02 <cads> see, we love and adore him!
22:02:07 <cads> bebe
22:02:11 <cads> hehe*
22:02:37 <Berengal> Not that I wrote unittests before... real programmers always know the context of their environment at any point
22:03:01 --- mode: mauke set -o mauke
22:03:06 <cads> now I don't know if I miss him or am glad you asked him to leave
22:03:23 <mauke> "asked"
22:04:56 <Berengal> I don't know... I sort of like insults being thrown around...
22:05:10 <Berengal> Makes it so much harder to make genuine insults
22:05:17 <cads> mauke: my theory was that he was put here by an op to shock people into asking questions other than "hey has anyone ever done [this or that]?", which is a wrong question usually, as what you're usually looking for is a factual answer, and the only reason you ask "is there anyone that has done [this or that]" is in hopes of getting the attention of someone that can then answer your real question
22:06:03 <cads> very zen was my interpretation, mmm
22:06:12 <Veinor> what's the guideline for when to use a tuple vs when to use a new type?
22:06:24 <Berengal> Veinor: tuples are temporary. Newlines are forever
22:06:27 <mauke> roll 1d2
22:06:34 <Veinor> don't you mean flip?
22:06:39 <Berengal> Also, newtypes
22:06:53 <mtnviewmark> okay, cads, my real question is: is it standard or good practice to runs Criterion benchmarks with -g or not?
22:08:15 <Veinor> well, when do you go with newtype Foo = Foo (Int, Int) vs data Foo = Foo Int Int
22:08:40 <cads> mtnviewmark: oh, shoot, I didn't mean to seem to criticize your question specifically, I'm sorry I don't know the answer to that :(
22:08:51 <Veinor> if you get what I'm trying to say.
22:08:59 <mtnviewmark> no no - just, you're right - and so I put out my real question
22:09:18 <Berengal> Veinor: When you want to unwrap the tuple and pass it around as a tuple for a bit, instead of genuinely caring for the actual values inside
22:09:24 <Berengal> Veinor: i.e. not very often
22:09:24 <mtnviewmark> though it is true, I was doing a sort of "social" segue into a series of Criterion questions,
22:09:46 <mtnviewmark> I always feel a little odd just dumping my question du-moment into the channel
22:09:48 <Veinor> so, don't use tuples except when necessary because code passes them to you?
22:10:02 <Berengal> Veinor: "It depends"
22:10:08 * Veinor throws up his hands
22:10:10 <Berengal> Whatever you feel comfortable with
22:10:50 <Berengal> The only objective criteria I can think of is optimizing syntax
22:10:59 <mtnviewmark> I would say, Veinor, if you don't have a reason to put a newtype around a tuple, use data
22:11:22 <Berengal> Possibly some newtype deriving for some tuple instances
22:12:14 * Veinor shrugs
22:12:39 <Veinor> I swear, if I ever see someone use floating point ranges in actual code
22:12:42 <Veinor> I am going to punch them.
22:13:12 <cads> hey, what was the name of that utter hack that one can use to process arbitrarily typed tuples? some extension dealing with type families, I think?
22:13:35 <Veinor> oh yeah, I remember reading in RWH that it's possible to say 'the second element of an arbitrary tuple'
22:13:41 <mauke> :t snd
22:13:42 <lambdabot> forall a b. (a, b) -> b
22:14:01 <Veinor> I said arbitrary :P
22:14:08 <mauke> that's pretty arbitrary
22:14:11 <Veinor> so, (a, b, c) -> b
22:14:14 <medfly> for a 2-tuple
22:14:20 <Veinor> arbitrary n-tuples!
22:14:25 <cads> but anything less trivial than the projection operators?
22:14:30 <medfly> I think you're supposed to make tuples in a certain manner
22:14:38 <mauke> maybe using Data.Typeable
22:15:37 <Berengal> cads: TH?
22:16:26 <cads> hmm, if you composed f to snd, for example, wouldn't f have to be typed forall a. a -> x?
22:16:41 <mauke> :t ?f . snd
22:16:42 <lambdabot> forall a b a1. (?f::a -> b) => (a1, a) -> b
22:17:04 <Berengal> Prelude Unsafe.Coerce> snd (unsafeCoerce ((1,2,3) :: (Int,Int,Int)) :: (Int,Int))
22:17:04 <Berengal> 2
22:17:46 <cads> mauke: that is quite rad
22:17:46 <Veinor> why fst and snd, not first and second?
22:17:55 <Berengal> @type first
22:17:56 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
22:17:58 <Berengal> @type second
22:17:59 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
22:18:02 <Veinor> :P
22:18:25 <Veinor> Prelude Unsafe.Coerce> unsafeCoerce ((1,2,3) :: (Int,Int,Int)) :: (Int,Int,Int,Int)
22:18:28 <Veinor> (1,2,3,Segmentation fault
22:18:35 <Berengal> Hehehe
22:18:58 <Berengal> "unsafe" isn't french for "harmless"
22:18:59 <Veinor> I like this idea of carrying around a tuple whose fourth element MUST NEVER BE ACCESSED :o
22:19:28 <mtnviewmark> "He who must not  be accessed"
22:19:37 <mauke> the fifth element
22:19:51 <cads> mauke++
22:20:09 <Berengal> Segfault == Love?
22:20:28 <Veinor> Prelude Unsafe.Coerce> let x = unsafeCoerce ((1,2,3) :: (Int,Int,Int)) :: (Int, Int, Int, Int)
22:20:32 <Veinor> Prelude Unsafe.Coerce> x
22:20:34 <Veinor> (1,2,3,-1237105388)
22:20:37 <Veinor> huh
22:20:43 <Berengal> Dumb luck
22:20:59 <Veinor> it segfaults sometimes, but not always
22:21:16 <medfly> o.O
22:21:22 <Berengal> It only segfaults if it tries to read from unmapped pages
22:21:24 <elly> same here - depends how lucky you are with heap layout
22:21:24 <Cale> russianRouletteCoerce
22:21:28 <medfly> that's pretty cool, is that like using arrays in C?
22:21:40 <Cale> Pretty much
22:22:21 <Berengal> Except in C you know you're not pointing off into the unknowns...
22:22:25 <Berengal> Well, sometimes...
22:22:27 <Veinor> oh noes, I can't have a single-element tuple D:
22:22:42 <medfly> > (3)
22:22:43 <lambdabot>   3
22:22:45 <medfly> huuh
22:22:47 <Cale> actually... doesn't this mean that it actually successfully entered an Int thunk which wasn't really a thunk at all?
22:23:48 <Veinor> medfly: yeah :P
22:23:49 <Berengal> Cale: I thought values were just a flag saying "I'm a thunk, jump to here to evaluate me" or "I'm a value, read me!"
22:23:59 <Cale> Berengal: Nope, they're all pointers to code
22:24:08 <aavogt> that sounds too improbable
22:24:10 <Cale> Berengal: The code is shorter after the first time
22:24:41 <Cale> (it rewrites the pointer to point at a short piece of code that just returns the already-evaluated value on the stack)
22:25:13 <Berengal> Cale: Ah
22:25:19 <Berengal> It's still the same code
22:25:28 <Berengal> Jump to X, read value on return
22:25:49 <Berengal> And all values have the same layout (tag [value]*)
22:26:00 <Cale> yeah
22:43:02 <Gnewt> http://pastie.org/764673
22:43:05 <Gnewt> What's up there?
22:43:29 <dolio> So, what are thoughts on: (return 1 `mplus` throwError "hello") `catchError` \e -> return 0 === return 1 `mplus` throwError "hello"?
22:44:18 <shachaf> Gnewt: Perhaps the monomorphism restriction, as it suggests; try giving min2 a type?
22:46:37 <Gnewt> but why does "min2 x = snd (h x)" work?
22:46:57 <shachaf> Gnewt: Because of the monomorphism restriction, as the error says.
22:47:09 <shachaf> ?wiki Monomorphism restriction
22:47:09 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
22:48:18 <Gnewt> I dislike this restriction.
22:49:33 <shachaf> Gnewt: You are not alone. You can disable it if you like.
22:50:27 <shachaf> {-# LANGUAGE NoMonomorphismRestriction #-} or so.
22:51:49 <Cale> Gnewt: There are a lot of people who would like to see it go away.
22:52:21 <cads> hey, anyone here like to spectate/speculate in theoretical physics? http://www.stevens.edu/csw/cgi-bin/blogs/horganism/?p=13
22:52:58 <elspru> how do i do that haskell lambda thing  (\x -> showHex x "")?
22:53:49 <medfly> @type showHex
22:53:51 <lambdabot> forall a. (Integral a) => a -> String -> String
22:53:57 <dibblego> > (\x -> showHex x "") 7
22:53:57 <elspru> hmmm
22:53:58 <lambdabot>   "7"
22:54:04 <elspru> i'm trying to match it onto a string
22:54:18 <elspru> map *
22:54:34 <medfly> > map (\x-> showHex x "") [1..3]
22:54:36 <lambdabot>   ["1","2","3"]
22:54:40 <elspru> > map (\x -> showHex x "") "abc"
22:54:41 <lambdabot>   No instance for (GHC.Real.Integral GHC.Types.Char)
22:54:42 <lambdabot>    arising from a use of...
22:54:47 <elspru> > map (\x -> showHex (ord x) "") "abc"
22:54:48 <lambdabot>   ["61","62","63"]
22:54:52 <elspru> cool okay
22:54:53 <elspru> :)
22:55:15 <shachaf> You're trying to turn a string into a hexadecimal number? This isn't Prolog. :-)
22:55:38 <elspru> i'm making a machine code compiler
22:55:48 <elspru> er, human speakable assembler
22:55:54 <elspru> language
22:56:04 <elspru> want to verify output without using hex editor
22:56:23 <mmmdonuts> cads, that's more like speculating in politics.
22:57:25 <elspru> hmm. it's still not working in my code somehow.
22:57:34 <ski> shachaf : what would it have to do with Prolog ?
22:57:43 <elspru>   Couldn't match expected type `Char' against inferred type `String'
22:57:43 <elspru>     In the expression: showHex (ord x) ""
22:58:14 <shachaf> ski: Trying to use the function backwards.
22:58:16 <elspru> do i have to brake up the string into an array?
22:58:27 <elspru> if so then how?
22:58:50 <elspru>    let translatedLine = translate wordLine -- translate
22:58:50 <elspru>     putStrLn (map (\x -> showHex (ord x) "") translatedLine)
22:59:03 <elspru> translatedLine is a String
22:59:25 <ski> use `concatMap' instead of `map'
22:59:45 <ski> your `map (...) translatedLine' gets you a `[String]'
22:59:50 <elspru> excelent :)
22:59:57 <elspru> got it now
23:00:00 <ski> (since `showHex :: ... -> ... -> String')
23:00:01 <elspru> ski: thanks :)
23:00:41 <ski> shachaf : ok
23:01:23 <ski> (i'm not seeing which function here would be attempted to run backwards)
23:02:59 <shachaf> I suspect I misunderstood the question.
23:03:53 <ski> sometimes it would be quite nice to run some functions backwards in Haskell
23:04:10 <ski> e.g. `stripPrefix'
23:04:21 <shachaf> Or `md5sum`.
23:04:24 <ski> hehe
23:04:29 <smorg> Is there anything like matplotlib for haskell? A quick google doesn't find anything that looks mature at first glance.
23:04:42 <mtnviewmark> Chart
23:04:54 <mtnviewmark> not as mature I suspect, but workable
23:08:02 <bear> FUCK YOU SOFT BITCHES WE GO HARD
23:08:05 <smorg> looks pretty good
23:08:13 * hackagebot upload: PriorityChansConverger 0.1 - Read single output from an array of inputs - channels with priorities (AndreySisoyev)
23:08:18 <cads> bear, I will shoot you in the face
23:08:18 <CESSMASTER> go hard or go home
23:08:48 <bear> DCC SEND "Ð¿Ð¾É¦ÊÉÐ¿É" 0 0 0
23:08:49 --- mode: ChanServ set +o mauke
23:08:50 --- kick: bear was kicked by mauke (mauke)
23:08:50 --- mode: mauke set +b *!*@ip72-218-136-178.hr.hr.cox.net
23:09:50 --- mode: mauke set -o mauke
23:10:18 <cads> what just happened there?
23:10:30 <mxc> netsplit
23:10:52 <smorg> div by zero
23:12:32 <CESSMASTER> dcc exploit
23:12:39 <cads> mmmdonuts: well, check this out, and tell me if as a layman this seems like anything other than garbage: http://arxiv.org/abs/physics/0601140
23:13:58 <mxc> is that why i keep getting /dcc send offers with zero byte lneght files?
23:14:11 <ski> yes
23:14:19 <bob0> mauke: I'm human.
23:14:20 <CESSMASTER> well the trick is port 0
23:14:32 <mxc> so 10 people in this channel accepted that offer?
23:14:44 <CESSMASTER> no, 10 people in this channel have a vulnerable router
23:14:50 <mxc> ah
23:15:04 <Berengal> cads: Looks like dissociated press
23:15:07 <CESSMASTER> certain routers monitor irc connections for ctcp to automatically map ports for dcc
23:15:08 <mxc> oh, so they got completely disconnected from the internet?
23:15:12 <bob0> they should be banned until they get it fixed to reduce the effectiveness of the spam
23:15:13 <cads> bob0, anyone here ever?
23:15:16 <bob0> cads: no
23:15:19 <mxc> got it
23:15:22 <bob0> cads: yes
23:15:32 <cads> bob0: turn that script off and I don't think there's a problem
23:15:41 <CESSMASTER> so whenever they get a dcc request on port 0 they drop the connection
23:15:49 <bob0> cads: it's not meant to respond to those
23:15:50 <smorg> Some channels here do that.
23:16:27 <cads> bob0: actually, I was curious as to the purpose of that script earlier
23:16:36 <bob0> anybody here?
23:16:54 <ivanm> bob0: nope, this channel is completely empty
23:16:55 <Berengal> bob0: no
23:17:03 <bob0> <_<
23:17:07 <Berengal> :P
23:19:35 <cads> Berengal: if you're interested, this is a neat blog post that goes into the "problem" with string theory... the writer of that document then provides a response that is at least interesting, saying that mathematical physics is like a new form of kaballah, where we reject our "base reality" and try to calculate through some mystic method the identity of the "true objects of reality", which in this case end up being mathematical objects... but then the aproa
23:20:14 <medfly> it got cut off at "then the aproa"
23:20:19 <Berengal> cads:  but then the aproa
23:20:49 <ivanm> medfly: it did? it ends in "apro" here...
23:21:12 <cads> "but then the aproach he suggests sounds very mystical in itself! http://www.stevens.edu/csw/cgi-bin/blogs/horganism/?p=13"
23:21:37 <medfly> that's what I mean, I guess
23:22:29 <Berengal> cads: Physics is yucky. It's all full of floats, time, granularity and finite values...
23:23:07 <Cale> This guy seems at least semi-crankish. He has some real qualifications, but the claims he's making are at best outlandish.
23:23:08 <cads> http://myprofile.cos.com/mammoth according to his profile this guy doesn't seem to be currently employed anywhere or that's a pretty old profile - the thing that bugs me is that I'm interested in everything he's interested in, except he's a possible hack
23:23:39 <ivanm> Cale: so, what, about 8.5 on the Crank scale? ;-)
23:23:48 <cads> I'd say
23:24:00 <cads> I'd like to see his other papers and whether there's anyone that cites him
23:24:12 <tensorpudding> who is a crank?
23:24:36 <Cale> http://arxiv.org/abs/physics/0601140 -- Andrei P. Kirilyuk
23:24:48 <cads> another paper for reference http://arxiv.org/abs/physics/0401164
23:25:09 <tensorpudding> that title sounds very sketch
23:25:11 <Cale> http://sites.google.com/site/unifiedcomplexity/ -- I CAN HAS SOLUTION TO EVARYTHING!!11
23:25:17 <ivanm> pandoc no longer uses TH! \o/
23:25:19 <tensorpudding> "symmetry of complexity"?
23:25:30 <cads> oxymoronic, huh?
23:25:40 <tensorpudding> any "energy-complexity"
23:25:43 <tensorpudding> and*
23:26:07 <tensorpudding> it's either complete bullshit or some very fringey stuff
23:26:22 <cads> but you never know, he could be a Super-Kolmogorov and think at a level that defies natural language, plus, there's the foreign language barrier, this fellow is from the ukraine
23:26:38 <cads> ;D
23:26:42 <tensorpudding> stupid chrome not autoloading arxiv pdf's...
23:26:45 <Berengal> cads: I'm all for the gathering experimental data bit. Pure conjecture is worthless when dealing with the real world
23:26:56 <tensorpudding> cads: true, this could be poor translation
23:27:05 <Berengal> cads: At least mathematicians get to define their own universes and have no need for fancy equipment ;)
23:27:20 <tensorpudding> but what he proposes in the abstract sounds way too optimistic
23:27:41 <cads> what he says to me boils down to "mathematical formalism has turned into a new-age mysticism in mathematical physics" kind of strikes a chord in me
23:27:50 <raceRider> is there a fromInt function to convert Int to Float in GHC?
23:27:58 <smorg> define your own universe == religion?
23:28:03 <dibblego> @type fromIntegral
23:28:04 <lambdabot> forall a b. (Integral a, Num b) => a -> b
23:28:11 <tensorpudding> "institute of metal physics"
23:28:26 <ivanm> raceRider: in case you couldn't tell, dibblego's comment was for you
23:28:27 <cads> hehe
23:28:33 <raceRider> thanks
23:29:36 <kmc> institute of mentalphysics
23:29:38 <kmc> (it's all one word)
23:30:00 <tensorpudding> whoashit
23:30:07 <cads> tensorpudding: UNIVERSAL CONCEPT OF COMPLEXITY BY THE DYNAMIC REDUNDANCE PARADIGM: Causal Randomness, Complete Wave Mechanics,and the Ultimate Unification of Knowledge
23:30:20 <tensorpudding> [1-16] of his references are refering to talks he gave and papers he wrote
23:30:34 <cads> I figured I'd find as much :P
23:30:35 <Cale> cads: Now that's just getting ridiculous.
23:30:37 * adu <3 FP
23:30:49 <cads> I love haw he casually throws out the complete unification of knowledge :P
23:30:59 <dolio> "Despite the recognized essential incompleteness and ruptures of canonical fundamental science, its scholar, 'mainstream' development continues in the direction of purely technical variations of existing abstract models of reality that never solve the existing fundamental problems and confirm thus the famous 'end-of-science' thesis."
23:31:04 <ivanm> grrrr...... a new version of Pandoc was released which apparently doesn't need TH, but the cabal file still says it does :s
23:31:45 <Cale> okay, I'm convinced this guy is a total crank now :)
23:31:54 <dolio> Yeah.
23:32:00 <cads> yup.
23:32:03 <Berengal> Strung out sentences much? Hur hur hur
23:32:09 <dolio> The abstract to that second paper reads like a markov chain to me.
23:32:22 <tensorpudding> he uses the word fractalic
23:32:24 <dolio> Maybe I don't know enough physics jargon, though.
23:32:29 <cads> it reminds me of the Brother Bogdanov
23:32:42 <tensorpudding> err, fractality
23:32:46 <cads> dolio: that's terribly fragmented use of the jargon...
23:32:54 <cads> fractality is fine
23:33:08 <dolio> Chaosity's a good one, too.
23:33:54 <tensorpudding> his referenced papers cover the gamut
23:34:28 <cads> I'm having a hard time finding anything I can begin to verify as being correct or not, I have to say though, from his citations it seems like the citations to anyone elses work are all citations to basic text books or essays on the decline in objectivism in science
23:34:36 <tensorpudding> he's talking about how he can rigorously describe genetics with his theory
23:34:54 <dolio> Text books? That's +n crank points.
23:35:39 <tensorpudding> so many made-up italicized Key Phrases it boggles the mind
23:35:41 <Cale> If you're using the word 'fractal' and there's no mention of any other topological concepts, something is wrong.
23:35:43 <cads> well presumably his theory would show the rise of life and consciousness as another facet of the "symmetry of complexity"
23:36:02 <tensorpudding> a quarter of his paper must be italicized
23:36:33 <dolio> This may all be academic, though. How does his work incorporate plutonium atom totality theory?
23:36:55 <cads> hah, where did you spot that gem?
23:37:36 <cads> for fuck's sake, I found Hawking, S.W. (1988). A Brief History of Time (Bantam, New York). in his bib
23:38:02 <dolio> Citing popular science isn't good form?
23:38:43 <cads> hmm... you're right, this paper is more of an informal description
23:38:59 <tensorpudding> "time relativity"
23:39:09 <cads> I don't know though, I think I will close the book on this guy's writing till I know more physics
23:39:29 <tensorpudding> "classicality"
23:39:53 <tensorpudding> this paper looks like someone tried to do a physics paper search-engine optimization on it
23:40:43 <cads> Complexity, nonlinearity, chaos, self-organisation, criticality... The frustration of the incomprehensible, disordered agglomerate of contradictory ideas turns now into the majestic harmony of the...
23:40:48 <cads> ... wait for it ....
23:40:56 <cads> Distributed Creation.
23:41:30 <tensorpudding> he's got the word "matrix" in quotes
23:41:58 <Cale> (3) Irreducibly complex, chaotic dynamics in real nanosystems of natural and artificial origin (e.g. nano-devices, quantum devices, bio-chemical interaction networks, genome interaction dynamics)
23:42:00 <cads> maybe to say he's not referring to a finite linear operator?
23:42:02 <ivanm> tensorpudding: yes, because you know which matrix he means...
23:42:17 <kamatsu> that seems ridiculously odd, sdl_gfx has all this fancy alpha blending but can't replace alpha
23:42:52 <Cale> (5) Consistent, complex-dynamical solution of general biological problems of evolution (qualitatively new form emergence) and essential life properties (autonomous dynamic adaptability, Ã©lan vital, development, etc.); application to creation of qualitatively new, integral medicine framework (complete understanding and control of unreduced complex, multivalued dynamics of each organism) [7]
23:43:25 <Cale> http://en.wikipedia.org/wiki/%C3%89lan_vital
23:43:53 <tensorpudding> i'm trying to read from the beginning, and if it were actually real, it's the worst exposition ever
23:44:21 <cads> Cale, you know, eventually we _will_ need a theory that can explain life and such from the first principles of whatever we accept as the final physical theory of whatever turtle is on the bottom <-- actually, the fact that I feel like there should necessarily exist such a theory make me feel pretty crankish now that I think about it
23:44:47 <cads> makes*
23:45:05 <Cale> We have a physical theory which does explain life.
23:45:10 <tensorpudding> he's got some weird looking generic hamiltonian that supposedly generalization everything
23:45:33 <Cale> Or are you talking about the manner in which abiogenesis is supposed to occur?
23:46:32 <tensorpudding> he never actually says what the variables that these functions are running over are
23:46:35 <cads> Cale, the latter
23:48:57 <Cale> cads: Well, that's probably something which we can't know for certain because the information about how it occurred on Earth has been lost to time. On the other hand, there's plenty of examples of possibilities in that direction.
23:49:01 <cads> hehe, cale I think you have a point, the way he's framing dynamics and complexity is like it is this "Elan vital"
23:50:57 <cads> hmm, why is it that detractors of mysticism usually insist on a wierder form of mysticism than they're trying to free you from :P
23:51:00 <Cale> cads: Regarding the "final physical theory", I don't think it exists.
23:51:16 <Cale> In fact, it goes against scientific principles to call anything that :)
23:53:12 <cads> well, suppose we find evidence that we are running in a simulation and manage to discern the exact rules, and then used that to run simplified models that show that dna does indeed randomly self assemble in this system, I think that would qualify for what I'm talking about
23:53:40 <tensorpudding> "running in a simulation"?
23:54:20 <Cale> cads: It's not clear what it would mean to find evidence that we're running in a simulation.
23:55:33 <cads> it could mean that one turtle in the stack is absolutely not going to tell us anything about any of the turtles beneath him, or that we should try running time attacks to see if we could leak out into base reality :D
23:56:22 <Cale> I don't believe in an objective reality.
23:57:13 <Cale> It's not clear to me what it should mean for such a thing to exist.
23:57:36 <Cale> In terms of things which can be tested observationally.
23:58:14 <cads> right, you could never prove that you are not simply a self aware substructure of a completely abstract and therefore non-objective reality
23:58:40 <tensorpudding> we're jumping into philosophy here
23:59:38 <Jafet> Consider a GÃ¶del encoding of endofunctors. This shows that we live in a simulation.
