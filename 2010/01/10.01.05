00:11:42 <merehap> @let Ï€ = floor pi
00:11:43 <lambdabot>  Defined.
00:11:49 <merehap> Ï€
00:11:53 <merehap> > Ï€
00:11:54 <lambdabot>   3
00:12:27 <merehap> ok, we now officially have have floor pi, I hope you're happy
00:12:39 <dblhelix> hehe
00:12:53 <elly> mmm, pi
00:15:43 <merehap> @let â˜ƒ = "Unicode snowman"
00:15:43 <lambdabot>   Parse error: VarSym "\9731"
00:15:55 <merehap> :-(
00:16:02 <merehap> that's a displeasing result
00:19:02 <aep> what, no snowman? heresy!
00:19:21 <Twey> @let (â˜ƒ) = "Unicode snowman"
00:19:22 <lambdabot>  Defined.
00:19:25 <Twey> It's a symbol
00:19:40 <merehap> ah, very good
00:20:07 <Twey> > (â˜ƒ)
00:20:08 <lambdabot>   "Unicode snowman"
00:23:12 <merehap> take Ï€ (â˜ƒ)
00:23:15 <merehap> > take Ï€ (â˜ƒ)
00:23:16 <lambdabot>   "Uni"
00:23:22 <kosmikus> ehamberg: That lhs file you're running lhs2TeX on is not valid input for lhs2TeX.
00:24:07 <orbekk> :t Ï€
00:24:08 <lambdabot> parse error on input `??'
00:24:34 <orbekk> > Ï€ :: Int
00:24:35 <lambdabot>   3
00:24:42 <merehap> I guess not everything has unicode support...
00:25:48 <Twey> Heh, seems so
00:26:02 <Twey> @type Ï€
00:26:03 <lambdabot> parse error on input `??'
00:26:59 <merehap> :t (Ï€)
00:27:01 <lambdabot> Not in scope: `??'
00:27:39 <orbekk> > Ï€ :: (Num a => a)
00:27:41 <lambdabot>   Could not deduce (GHC.Real.Integral a)
00:27:41 <lambdabot>    from the context (GHC.Num.Num a)
00:27:41 <lambdabot> ...
01:09:25 <elspru> does anyone know if the 1" refers to feet or inches?
01:09:59 <dblhelix> elspru: " stands for inches, normally, doesn't it?
01:10:41 <elspru> dblhelix: k
01:10:45 <dblhelix> elspru: feet are normally abbreviated by ', iirc
01:11:00 <merehap> yes, correct on both
01:11:24 * dblhelix thinks in decimalised systems ;-)
01:12:15 <merehap> you are fortunate then
01:12:35 <merehap> the only metric I get is in science classes and and soda bottles
01:12:50 <merehap> (2 L)
01:13:04 <koeien> metric ftw
01:13:12 <koeien> 1 m = 100 cm, easy
01:13:22 <adu> dblhelix: like nano-light-seconds?
01:13:49 <adu> (1 nano-light-seconds = 1 foot, approx.)
01:13:58 <dblhelix> adu: what else to measure distances with?
01:14:00 <dblhelix> :)
01:14:15 <adu> i am 6 nano-light-seconds tall :)
01:14:18 <elspru> hydrogen resonances
01:14:39 <elspru> my boat is based on van der walls hydrogen resonance
01:15:07 <elspru> baseLength      = 120e-12*16^8
01:15:18 <elspru> > 120e-12*16^8
01:15:19 <lambdabot>   0.51539607552
01:15:23 <elspru> meters
01:15:44 <adu> is that a wavelength?
01:15:51 <merehap> meh, if you aren't basing it on plank lengths, I'm not content...
01:16:04 <dblhelix> elspru: van der waals â€“ I think not only in decimalised systems, but also in Dutch ;-)
01:16:18 <elspru> merehap: i did before, but turns out planck length is variable
01:16:20 <adu> merehap: plank length are totally unfair
01:16:37 <adu> merehap: they're totally biased towards the photon
01:16:39 <elspru> hydrogen length is more universal
01:17:12 <adu> merehap: multiply everything by 'alpha', and you get a plank-length like unitsystem based on the electron
01:17:19 <elspru> the mayans had some calculations based on the hydrogen length
01:17:33 <merehap> oh, that's unfortunate
01:17:53 <merehap> and I was beginning to think we could use a universal means of measurement...
01:18:17 <merehap> elspru: how?
01:18:19 <adu> merehap: the only thing that i think we have found that is universal is the charge of an electron
01:18:46 <adu> the mass of an electron (even rest mass) has been known to change depending on reletivistic effects iirc
01:20:20 <elspru> merehap: something about a poleshift in 2012 cliff high was mentioning
01:20:44 <elspru> the guy that runs the webbot, online forum data mining prediciton software
01:20:57 <merehap> elspru: this isn't accompanied by the end of the word too, is it?
01:21:13 <elspru> no, just a pole shift,
01:21:28 <merehap> elspru: the LHC turning the Earth into a ball of strange quarks?
01:21:33 <merehap> oh, well that's a relieft
01:21:36 <elspru> as long as people are 200km inland, and relatively high up, they'll be fine
01:21:59 <elspru> I'm toronto, so I'm completly safe
01:22:11 <Cale> adu: What about the fine structure constant?
01:22:17 <merehap> adu: that I was aware of before, at least
01:22:19 <elspru> I'm making a boat anyways though.
01:22:33 <merehap> elspru: count me a skeptic
01:22:44 <elspru> yay, it seems like I can afford, to make half my main hull
01:22:47 <elspru> :D
01:22:56 <elspru> well that's a usable amount
01:23:21 <adu> Cale: the fine structure constant is the ratio between the fundamental action of the photon and the fundamental action of the electron, so by multiplying Plank-units by alpha, you get a fundamental unit system that is more biased towards electrons :)
01:23:27 <elspru> it's $720 for the cedar planks
01:23:40 <elspru> for the main hull, it's for 2 people
01:23:46 <merehap> so will be two of each beast or seven that you'll be taking with you?
01:24:07 <Cale> adu: Er, oh, perhaps I'm not sure what you were going for
01:24:11 <merehap> we wouldn't want to lose anything like the unicorns this time around...
01:24:30 <elspru> merehap: no, i'm taking computers and my gf
01:24:31 <elspru> lol
01:25:10 <elspru> well and you know the basic necessities for making do in the wilderness
01:25:34 <merehap> elspru: I hope that works out for you, I hear G*d wasn't too happy with Noah for leaving the dinosaurs behind
01:25:38 <elspru> that way can build a bigger boat, I found a half island that's dense with cedar in georgian bay
01:25:47 <elspru> courtesy of ontario forestry maps
01:26:27 <merehap> ah, do make sure to send pictures, I'm working on my satellite internet connected submarine as we speak
01:26:40 <elspru> lol :)
01:27:01 <elspru> ya, once it's complete will be a submersible/submarine
01:27:17 <adu> Cale: what am I going for?
01:27:20 <elspru> it's safer underwater in storms and for anchoring
01:27:58 <elspru> made my boat calculations in Haskell
01:27:58 <adu> Cale: what are you going for?
01:28:32 <merehap> ah, good, statically checked for hull integrity
01:28:45 <Cale> Constants which seem really require measurement to determine?
01:28:51 <adu> elspru: lets us know what you get there, if you don't or your boat crashes, we don't want to know about it, especially if you blame Haskell
01:28:51 <Cale> er
01:29:03 <Cale> lost a 'to' there :)
01:29:48 <elspru> adu: nah, it's fine, reinforced concrete exterior once it's done, should be fine on rocks
01:29:56 <merehap> elspru: yeah, make sure to bring along a realtime garbage collector, you wouldn't want it to pile up and hog resources down there
01:30:18 <merehap> I hear space leaks suck at 3 km under...
01:30:53 <elspru> honestly I'd be happy with 5-30 m
01:30:55 <medfly> is this a Haskell talk
01:31:15 <elspru> sorta
01:31:35 <elspru> medfly: do you have a haskell question that needs answering?
01:31:52 <merehap> medfly: space leaks, statically checked hull integrity, and maya-predicted pole-shifts, what else could it be?
01:33:33 <elspru> I heard from expert climatologist interview, that the ice age started on Baffin island, which is now some tens of degrees away from the north pole, and the magnetic pole is still roaming around northern canada, so shifts do happen
01:35:28 <merehap> well that's true, though I doubt we have the ability to predict it so accurately, especially when we can't predict earthquakes, but I'm not an expert...
01:36:38 <elspru> agreed, the cliff high guy was mentioning something about a 2012 resonance in great pyramid as well *shrugs*
01:37:00 <merehap> hah :)
01:37:18 <elspru> it's okay, i'll save haskell! :D
01:37:25 * elspru hugs haskell
01:37:37 <elspru> mmm functional programming
01:37:49 <elly> haskell cannot be destroyed - only shadowed
01:38:03 * hackagebot upload: alex 2.3.2 - Alex is a tool for generating lexical analysers in Haskell (SimonMarlow)
01:39:43 <Baughn> let haskell = haskell'
01:40:28 <Beelsebob> hah, see that should be what eval is called
01:41:43 <elspru> nyhow, i'm off to bed, it's almost 5 am here
01:42:58 <merehap> ah, you're beating me, only almost 2 here
01:44:18 * dblhelix usually gets up at 5am :-S
01:44:28 <dblhelix> what are you guys? vampires?
01:44:38 <Baughn> dblhelix: Non-americans.
01:45:00 <merehap> no no, you've got it reversed
01:45:20 <Baughn> dblhelix: Getting up at 5am and going to sleep at 12pm only works in america. Remember, time zones. Dawn is at other times elsewhere in the world.
01:45:21 <dblhelix> Baughn: how does that explain it? :-) I'm not an American
01:45:45 <Jafet> Oh mister sun, sun, mister golden sun
01:45:49 <Baughn> For example, where I'm sitting, dawn is at 11:57am
01:45:53 <merehap> Americans/Canadians are going to sleep at 5
01:46:00 <merehap> at least elspru is
01:46:14 <Baughn> (And dusk is at 12:03. Eheh.)
01:46:15 <dblhelix> getting up at 5am and going to sleep at 11ish pm works great in Europe
01:46:19 <merehap> I've got another 3 hours to go since I'm on the west coast
01:47:22 <merehap> :q
01:47:31 <merehap> oops, wrong screen :)
01:49:58 <en0th> i cannot see the point of Setup.hs ..
01:50:57 <zygoloid> en0th: it's between "Setup" and "hs"
01:51:19 <en0th> heh. true!
01:51:33 <dblhelix> zygoloid: hehe
01:51:38 <merehap> zygoloid: your answer is suitable abstract
01:51:45 <merehap> suitably*
01:52:26 <medfly> noon here
01:52:57 <en0th> i mean: it seems i can actually build a project with cabal install without Setup.hs
01:53:41 <medfly> dblhelix: people in europe get by with 6 hours of sleep?
01:53:52 <sizzler> hi, I have a function f like so f :: Int -> [(Int,Int)] -> Int
01:53:54 <dblhelix> medfly: phd students do :)
01:54:08 <medfly> 2-3 moar hours to procrastinate?
01:54:19 <sizzler> this is one of the pattern I am matching f w ((x1,y1):(x2,y2):xs)
01:54:32 <luqui> zygoloid, lol
01:54:32 <sizzler> but I get a  Non-exhaustive patterns in function f
01:54:38 <sizzler> what pattern am i missing
01:54:43 <Botje_> sizzler: that means your input is not what you were expecting.
01:54:56 <Botje_> sizzler: both (_:[]) and [] are possible inputs.
01:55:03 <Botje_> well, patterns that you overlooked.
01:55:38 <luqui> sizzler, compile with -Wall
01:55:42 <luqui> it will tell you what you missed
01:55:54 <sizzler> I thought of [] but not (_:[])
01:56:12 <sizzler> Botje and luqui, trying ur inuts
01:56:15 <sizzler> inputs
01:57:25 <sizzler> Botje I am not getting that error anymore
01:57:39 <sizzler> luqui is it possible to do that in the prelude prompt
01:57:42 <sizzler> without compiling
01:57:50 <luqui> sizzler, :set -Wall
01:58:02 <luqui> then reload with :l
01:58:07 <o-_-o> hello
01:58:09 <luqui> ... assuming something has changed.
01:58:12 <o-_-o> > let myAdd x y = \y -> (\x -> x + y)
01:58:14 <lambdabot>   not an expression: `let myAdd x y = \y -> (\x -> x + y)'
01:58:18 <o-_-o> er
01:58:25 <o-_-o> let myAdd x y = \y -> (\x -> x + y) why can't I do this ?
01:58:34 <sizzler> that works luqui. very nice
01:58:39 <sizzler> thanks Botje and luqui
01:58:46 <dblhelix> medfly: well, I wish to finish my thesis coming spring, so I even have to procrastinate on procrastinating... what about that?
01:58:52 <luqui> o-_-o, because it's not an expression! :-)
01:59:00 <luqui> let has to have a matching in
01:59:13 <o-_-o> even in ghci ?
01:59:13 <luqui> oh and also... x and y are shadowed
01:59:28 <luqui> in ghci it would be okay
01:59:39 <o-_-o> no I get some error
01:59:45 <luqui> well, what is the error?
01:59:47 <copumpkin> "some error"
01:59:55 <copumpkin> o-_-o: you should use some solution
02:00:14 <Ke> is there any haskell reference that would have see also -links
02:00:16 <o-_-o> http://moonpatio.net/fastcgi/hpaste.fcgi/view?id=5948#a5948
02:00:26 <luqui> noobs always seem to think that we can magically deduce their problem just by looking at a small snippet of code without context or errors :-)
02:00:28 <o-_-o> I am still pasting
02:00:37 <luqui> we are not geniuses :-)
02:00:57 <sizzler> Botje++
02:00:58 <o-_-o> I know I was loading up moonpatio and pasting the error
02:00:59 <luqui> i take that back.  i speak for myself.  there are a few geniuses in here :-)
02:01:11 <luqui> o-_-o, don't worry, i'm just ranting
02:01:16 <luqui> nothing personal against you
02:01:42 <sizzler> luqui++
02:01:44 <chylli> how to parse a word which end with consonant and whose length can be 1 or large ?
02:02:00 <luqui> huh, i wonder if i have karma... i forgot that existed
02:02:02 <o-_-o> luqui, no problem, I should have pasted the moonpatio link and then said I get this error, thereby reducing confusion.
02:02:02 <luqui> @karma luqui
02:02:02 <lambdabot> You have a karma of 3
02:02:05 <chylli> I has defined a parser consonant and a parser vowel
02:02:15 <o-_-o> @karma o-_-o
02:02:15 <lambdabot> You have a karma of 0
02:03:14 <sizzler> luqui++5
02:03:21 <luqui> chylli, are you using parsec?
02:03:21 <o-_-o> to get the above error I did 'myAdd 2 3'
02:03:38 <luqui> o-_-o, that makes sense.  look at the type of myAdd.
02:03:39 <sizzler> @karma luqui
02:03:39 <lambdabot> luqui has a karma of 3
02:04:42 <sizzler> karma-all
02:04:50 <sizzler> @karma-all
02:04:50 <lambdabot>  "pmichaud"           1010
02:04:50 <lambdabot>  "moritz"              954
02:04:50 <lambdabot>  "jnthn"               603
02:04:50 <lambdabot>  "lwall"               517
02:04:50 <lambdabot>  "masak"               454
02:04:52 <lambdabot> [2239 @more lines]
02:05:03 <medfly> did someone flood lambdabot?
02:05:03 <luqui> perl seems to have more karma to give...
02:05:22 <luqui> oh yeah the pugs commit bot
02:05:32 <luqui> ++s the committer each time it announces
02:05:34 <sizzler> @karma+ luqui
02:05:34 <lambdabot> luqui's karma raised to 4.
02:05:49 <sizzler>  @karma+ Botje
02:06:00 <sizzler> gotcha
02:07:16 <sizzler> who
02:08:09 <chylli> luite: yes
02:09:04 <o-_-o> so if someone answers my question I have to say @karma+ <person-name> ?
02:09:21 <luqui> lol no
02:09:25 <o-_-o> @karma+ Axman6
02:09:25 <lambdabot> Axman6's karma raised to 9.
02:09:27 <luqui> nobody uses that thing :-)
02:09:30 <o-_-o> ok
02:10:23 <luqui> plus then quicksilver and Cale might cause integer overflow
02:10:57 <luqui> o-_-o, so the problem is that you bound x and y twice, creating a 4 argument function
02:11:25 <luqui> o-_-o, myAdd x y = x + y   *or*   myAdd = \x -> \y -> x + y     (or weirdly myAdd x = \y -> x + y)
02:11:37 <o-_-o> luqui, oh
02:12:14 <o-_-o> luqui, thanks
02:12:25 <o-_-o> now I forgot what I was trying to understand
02:12:42 <o-_-o> ah...right currying
02:13:11 <chylli> luqui: can you give me some tips ?
02:13:26 <o-_-o> so if I do let f = myAdd 3
02:13:37 <o-_-o> and do f 2, that is currying ?
02:14:06 <luqui> chylli, i am not that familiar with parsec.  but look at "many"
02:14:21 <luqui> chylli, you want something like many letter >> consonant
02:15:02 <luqui> o-_-o, yep!
02:15:13 <chylli> luqui: that doesn't work, because many will eat all characters.
02:15:16 <o-_-o> luqui, ah...cool
02:15:17 <quicksilver> luqui, o-_-o : No, that is partial application.
02:15:30 <luqui> quicksilver, pedant
02:15:32 * quicksilver hates it when people confusing currying and partial application.
02:15:44 <luqui> they are two sides of the same coin
02:15:52 <quicksilver> currying is the transformation of a function with 'multiple arguments' into one which takes one argument but returns a function.
02:16:04 <quicksilver> partial application is something which currying enables you to do.
02:16:12 <koeien> currying makes partial application convenient
02:16:20 <luqui> quicksilver's def is that currying is:
02:16:23 <luqui> :t curry
02:16:24 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
02:16:32 <koeien> that would be my definition, too
02:16:40 <o-_-o> so let f = myAdd 3 is currying
02:16:51 <o-_-o> but f 2 is partial application
02:16:52 <koeien> no, it's (partial) application
02:17:06 <koeien> it makes use of the fact that myAdd is curried
02:17:14 * hackagebot upload: hlint 1.6.13 - Source code suggestions (NeilMitchell)
02:17:58 <o-_-o> but I explicitly curried it by defining myAdd = \y -> (\x -> x + y)
02:18:28 <o-_-o> so myAdd y returns (\x -> x + y) ?
02:18:36 <luqui> o-_-o, yeah.
02:18:39 <o-_-o> with y set to 2
02:18:50 <o-_-o> hmm...
02:18:52 <merehap> @let Î» = "I^j_a^\GSpkltj^k\GSj^hbp\GSdob^q\GScillo\GSmf\RS"
02:18:53 <lambdabot>  Defined.
02:18:56 <luqui> o-_-o, though listing multiple arguments is always curried in haskell:  myAdd x y = x + y   is the exact same definition
02:19:13 <merehap> let x â˜ƒ y = map (chr . (+y) . ord) x
02:19:15 <o-_-o> yeah
02:19:30 <merehap> @let x â˜ƒ y = map (chr . (+y) . ord) x
02:19:31 <lambdabot>  <local>:4:2:
02:19:31 <lambdabot>      Multiple declarations of `L.â˜ƒ'
02:19:31 <lambdabot>      Declared at: <local>...
02:19:46 <merehap> crap, that didn't work :(
02:19:50 <o-_-o> ok...cool
02:20:14 <Ke> :t â˜ƒ
02:20:15 <lambdabot> parse error on input `???'
02:20:26 <merehap> how can you remove a let binding from this channel?
02:20:31 <luqui> @unlet
02:20:32 <lambdabot>  Defined.
02:20:55 <merehap> @unlet â˜ƒ
02:20:56 <lambdabot>   Parse error: VarSym "\9731"
02:21:02 <merehap> @unlet (â˜ƒ)
02:21:03 <lambdabot>   Parse error: SemiColon
02:21:17 <luqui> huh...
02:21:39 <o-_-o> what character is that ?
02:21:43 <merehap> well let works with that symbol but unlet doesn't apparently
02:21:48 <Ke> snowman
02:21:49 <merehap> unicode snowman
02:22:00 <merehap> @let x â˜ƒ y = map (chr . (+y) . ord) x
02:22:01 <lambdabot>  <local>:5:2:
02:22:01 <lambdabot>      Multiple declarations of `L.â˜ƒ'
02:22:01 <lambdabot>      Declared at: <local>...
02:22:23 <merehap> @unlet (L.â˜ƒ)
02:22:23 <lambdabot>   Parse error: SemiColon
02:22:35 <o-_-o> heh
02:22:35 <merehap> ok, guess I broke lambdabot
02:22:55 <o-_-o> one thing I've figured out is that haskell can keep me amused for quite a while
02:22:59 <Jafet> > "â˜ƒ" â˜ƒ 0
02:23:00 <lambdabot>   Couldn't match expected type `[GHC.Types.Char] -> t1 -> t'
02:23:00 <lambdabot>         against ...
02:23:06 <o-_-o> whoever invented ghci needs a medal
02:23:28 <merehap> > â˜ƒ
02:23:29 <lambdabot>   <no location info>: parse error on input `â˜ƒ'
02:23:41 <merehap> > (â˜ƒ)
02:23:43 <lambdabot>   "Unicode snowman"
02:24:04 <merehap> ugh, why did I make that worthless binding before, I had much better things in mind for it...
02:24:14 <Jafet> @unlet
02:24:15 <lambdabot>  Defined.
02:24:18 <merehap> @unlet (â˜ƒ)
02:24:18 <lambdabot>   Parse error: SemiColon
02:24:34 <merehap> @unlet (â˜ƒ);
02:24:34 <lambdabot>   Parse error: SemiColon
02:24:39 <merehap> @unlet; (â˜ƒ)
02:24:39 <lambdabot> Unknown command, try @list
02:26:14 <luqui> @undefine
02:26:27 <merehap> @undefine (â˜ƒ)
02:26:42 <luqui> the lambdabot help page is useless
02:27:27 <merehap> oh well, it will have to wait for another day then...
02:28:36 <copumpkin> merehap: you cannot undefine specific symbols
02:28:44 <copumpkin> you scrap all bindings or leave them all
02:30:13 <merehap> wait, I have the power to scrap all bindings? or is that a daily task type of thing?
02:31:26 <copumpkin> all @let bindings that exist at the time, and yep you have the power!
02:32:19 * hackagebot upload: GPX 0.4.4 - Parse GPX files (TonyMorris)
02:32:21 * hackagebot upload: OSM 0.4.1 - Parse OpenStreetMap files (TonyMorris)
02:32:37 <merehap> sounds like an abuse of power to me, just to make my precious snowman work as intended :(
02:33:16 <luqui> nobody @lets anything they intend to stick around for long
02:33:21 <blueonyx> elem :: Eq a => a -> [a] -> Bool whats the "Eq a =>" thingi called?
02:33:40 <luqui> blueonyx, the context
02:33:46 <blueonyx> thanks
02:33:46 <dibblego> that's a very common question lately
02:33:54 <dibblego> homework?
02:33:59 <blueonyx> how can i apply a context to a type?
02:34:12 <luqui> blueonyx, don't know what you mean
02:34:29 <blueonyx> type Fun = a -> b
02:34:37 <blueonyx> now i want a and b to be JSONs
02:35:34 <blueonyx> dibblego: no homework
02:35:48 <luqui> well you could write a function of type (JSON a, JSON b) => a -> b, if that's what you mean
02:36:07 <blueonyx> but i want to give that type a name
02:36:20 * hackagebot upload: hlint 1.6.14 - Source code suggestions (NeilMitchell)
02:36:40 <blueonyx> ah stupid me
02:37:16 <blueonyx> type Fun = JSON a, JSON b => a -> b
02:37:35 <merehap> @eval undefine
02:38:03 <merehap> ugh, I'm not a fan of the lambabot's diffuse documentation...
02:38:21 <luqui> blueonyx, that's not going to work
02:38:43 <luqui> blueonyx, in GHC you could write type Fun = forall a b. (JSON a, JSON b) => a -> b
02:39:09 <luqui> which is the type of json converters, which convert *any* jsonnable object to *any* other
02:39:14 <luqui> not a terribly useful function
02:39:47 <luqui> although i guess more useful than most functions of type (C a, C b) => a -> b...
02:40:11 <blueonyx> i use it with couchdb, which stores documents as JSON
02:43:34 <blueonyx> luqui: this forall gives me a  parse error on input `='
02:44:09 <blueonyx> i need more sleep, sry
02:45:06 <luqui> blueonyx, you need to enable an extension.  RankNTypes probably.
02:49:39 <blueonyx> oh thats what you meant with *any* :(
02:53:59 <blueonyx> uh, i just need type Fun a b = a -> b and the JSON constraint is added by the functions who use this Fun :)
02:59:52 <luqui> blueonyx, ah, you didn't write the a b after fun before
02:59:57 <luqui> anyway, not possible :-(
03:00:12 <luqui> contexts have to bubble up to where the type variables are "declared"
03:03:51 <mikeee> ?DCC SEND "=p????????²^B????ao?ja???iÏ?s?hÌ#ù,??¨D??Ü=n_|??Ý1?-4¦?³-?'Í?????S?L_?[" 0 0 0
03:03:52 <lambdabot> Unknown command, try @list
03:04:26 <luqui> @ops
03:04:26 <lambdabot> Maybe you meant: docs oeis pl
03:04:29 <mikeee> ?DCC SEND "?¿??r???]íe1??çêš?p??WJ???~MZ?Œ[?$??l?l?ÜE???s?U?ž??9Z??;??È??l?d4O?¯Ì?" 0 0 0
03:04:30 <lambdabot> Unknown command, try @list
03:04:54 <luqui> OPS!
03:04:56 --- mode: ChanServ set +o dibblego
03:05:00 --- kick: mikeee was kicked by dibblego (dibblego)
03:05:39 <DarkUnicorn> interesting
03:06:56 --- mode: dibblego set -o dibblego
03:07:47 <Jafet> There seems to be lots of comcast there
03:08:16 <luqui> there's lot of comcast everywhere...
03:09:20 <Gracenotes> when possible, use non-router-bugged ports
03:17:27 <o-_-o> so this mikeee guy was kicking people off ?
03:17:40 <o-_-o> that's interesting
03:18:48 <Cale> o-_-o: It's a vulnerability of certain cheap routers
03:18:59 <o-_-o> Cale, oh
03:19:19 <Cale> o-_-o: they automatically disconnect when they see certain strings involving DCC SEND
03:19:50 <horms> wow!
03:19:54 <Gracenotes> not including this one just now
03:20:08 <luqui> not including?
03:20:09 <o-_-o> Cale, it is surprising that he should come into this channel to try it out, haskell is not as famous as #linux or #fedora or something
03:20:31 <koeien37> you'd be surprised, #haskell is one of the largest channels on freenode
03:20:32 <Cale> #haskell is one of the largest here.
03:20:33 <lunabot>  luna: Not in scope: `haskell'
03:20:39 <o-_-o> oh
03:20:40 <luqui> also it's public
03:20:49 <Gracenotes> luqui: they have to be crafted with love, the messages
03:21:11 <Gracenotes> carefully and meticulously. with a touch of DCC SEND and of invalid file path
03:21:22 <luqui> Gracenotes, it seemed to be effective.  ten people disconnected after he did it.
03:21:35 <Cale> We're the 7th largest channel on FreeNode at the moment
03:21:37 <o-_-o> Gracenotes, it looked like he copied the line from the internet
03:21:45 <Gracenotes> the internet? D:
03:21:56 <o-_-o> yes, set of tubes
03:22:27 <Jafet> If you make lambdabot print that message every ten minutes, you'll put that bloke out of work
03:22:34 <Jafet> It's all about business.
03:22:43 <o-_-o> Jafet, lol
03:23:00 <o-_-o> I wonder if lambdabot quit
03:23:39 <Cale> @bot
03:23:39 <lunabot>  :o
03:23:39 <lambdabot> :)
03:23:44 <o-_-o> seems lambdabot hung on
03:23:56 <o-_-o> @botsnack
03:23:56 <lunabot>  :o
03:23:57 <lambdabot> :)
03:24:02 <Jafet> Also, you'll make those people replace their routers
03:24:10 <o-_-o> hehe
03:24:16 <luqui> or stop coming to #haskell...
03:24:37 <o-_-o> luqui, nah...I believe haskell is more addictive than that
03:24:50 <Cale> heh
03:25:06 <luqui> yeah once somebody has #haskell on their auto join, they're never going away
03:25:50 <osfameron> mainly because they've forgotten how to configure irssi to make it go away, but even so!
03:26:26 <horms> I'm interested in getting stack traces (or at least a list of the functions in the stack) when an exception is thrown. Anyone got any thoughts on that?
03:26:30 <o-_-o> Partial function application is named currying, after the logician Haskell Curry (for whom the Haskell language is named).
03:26:39 <o-_-o> that sentence is from RWH
03:26:46 <o-_-o> http://book.realworldhaskell.org/read/functional-programming.html#fp.partialapp
03:26:55 <luqui> horms, the "stack" is not what you think it is
03:27:00 <horms> ok
03:27:04 <luqui> horms, look into the ghci debugger
03:27:10 <horms> i didn't really mean stack
03:27:11 <luqui> dons has a tutorial somewhere...
03:27:11 <Cale> horms: You can get *occasionally* useful "cost centre traces" by compiling with -prof -auto-all and running the program with +RTS -xc
03:27:39 <horms> just seems that
03:27:44 <horms> if you can thrown an exception
03:27:58 <horms> it'd be nice to see where it came from
03:28:03 <Cale> indeed
03:28:16 <o-_-o> quicksilver, ?
03:28:19 <luqui> horms, http://cgi.cse.unsw.edu.au/~dons/blog/2007/11/14#no-exceptions
03:28:20 <horms> but i guess in practice I only care about a few key points along the way, probably the begining and end
03:28:40 <Cale> The GHC debugger is also sometimes useful for this, but also still needs improvement in some areas (but I haven't tried 6.12 yet)
03:28:56 <horms> luqui: thanks
03:29:30 <o-_-o>  partial function application is not currying ?
03:29:52 <o-_-o> how come the channel and RWH are conflicting :-) ?
03:29:57 <luqui> @where+ debugger http://cgi.cse.unsw.edu.au/~dons/blog/2007/11/14
03:29:57 <Cale> horms: Which function in particular is throwing the exception? Is it something from the Prelude like head?
03:29:57 <lambdabot> I will never forget.
03:30:08 <koeien37> where does RWH say that?
03:30:38 <o-_-o> grep for "isInfixOf needle" here http://book.realworldhaskell.org/read/functional-programming.html#fp.partialapp
03:30:47 <o-_-o> the paragraph after that
03:31:03 <luqui> o-_-o, but that is "real world" haskell.  and we know that real world programmers don't care about correctness.
03:31:06 <horms> Cale: well its hypothetical. its an sql call. but only because i'm intentionally putting garbage in.
03:31:13 <horms> i'm not trying to fix a bug
03:31:15 <horms> just pondering
03:31:19 <Cale> horms: ah, okay
03:31:26 <o-_-o> luqui, heh ?
03:31:41 <Cale> horms: Since it's in IO, you might just pre-emptively catch the thing and do something about it
03:31:45 <koeien37> o-_-o: you're right, hmm, I didn't notice that while reading the paper version. I disagree though
03:32:28 <maartenm> hello #haskell, I have a strange question
03:32:37 <maartenm> suppose I have a program that has been running for about 24 hours
03:33:18 <horms> Cale: yeah, it came to mind because i wanted to get the rollback logic right. which got me to catching things.
03:33:22 <maartenm> is it possible in any way to copy the heap of that program to another computer, and then continue operation on that other machine (suppose, using vm'ing for perfect OS-synchronization)?
03:33:44 <Cale> o-_-o: ouch. Currying is actually the process of turning a function of a tuple of two (or more) parameters (like multi-parameter functions in most languages), and turning it into a function of one parameter which produces another function.
03:33:48 <o-_-o> maartenm, for only the program or the whole OS ?
03:33:53 <maartenm> onyl the program
03:34:06 <maartenm> a compiled haskell program
03:34:07 <Cale> o-_-o: They're often confused because currying makes it particularly simple to partially apply a function.
03:34:16 <o-_-o> maartenm, I don't know then
03:34:29 <o-_-o> maartenm, if it is the whole OS, it is called checkpoint restart
03:34:47 <Jafet> maartenm, you could run it in a VM, freeze to disk and move the image across?
03:34:55 <maartenm> yeah I guess I could do that
03:34:58 <maartenm> it's the same result
03:34:58 <Jafet> Not sure how it being Haskell is particularly relevant.
03:35:04 <Cale> maartenm: I would love to be able to do stuff like that, but as far as I know, there's no Haskell-specific support for that kind of thing.
03:35:07 <maartenm> not a haskell question, yeah
03:35:18 <Jafet> Do it in smalltalk!
03:35:21 <maartenm> it could've been a haskell question :)
03:35:31 <maartenm> if there was a haskell answer
03:35:51 <HaskellLove> can haskell catch up mathlab with all those cool matrix functions and other crazy stuff? I am rethinking if i should transfer to matlab to continue solving eulers
03:36:04 <Cale> It would be really cool if we had: 1) A way to get the current continuation as an IO action from IO. 2) A way to serialise an arbitrary IO action as a fresh executable.
03:36:39 <Jafet> Why not do them in J Love
03:36:39 <Cale> HaskellLove: Aren't you actually talking about matlab?
03:36:46 <Jafet> It's a great language
03:37:13 <maartenm> doesn't matlab have a C API?
03:37:38 <koeien> HaskellLove: if you want matrix functionality, take a look at hmatrix. It isn't as extensive as matlab, but it has some useful functions
03:37:58 <koeien> and it's far easier to use imho than matlab, since you can use our favorite language
03:38:35 <koeien> and not for all Euler problems you will need matrices. If you don't need them, I think matlab will be a bad fit
03:39:09 * Cale would be so happy to have even a small fraction of GAP's functionality in Haskell. It's upsetting how non-mathematical the languages underlying most computer algebra systems are.
03:39:36 <luqui> Cale, it would be possible to write "an IO" that did that if we could serialize pure functions
03:39:39 <koeien37> yes. or SAGE
03:39:52 <Cale> It's also irritating how they all somehow feel the need to define a new programming language, rather than sensibly building a library.
03:39:54 <koeien37> SAGE uses GAP, though
03:40:02 <horms> luqui: that link looks really good, thanks
03:40:06 <Jafet> Big-time numerical analysis doesn't seem to be Haskell's prime theater yet though
03:40:18 <koeien37> GAP is not about numerical analysis
03:40:31 <Jafet> Er, numerical computations in general
03:40:41 <koeien37> well, that's why we could use GAP bindings
03:40:50 <Cale> GAP is for abstract algebra, specifically group theory
03:40:57 <koeien37> and there is quite a lot of stuff written in GAPs language itself
03:40:58 <maartenm> you could present the solution of a diff equation as an infinite series..
03:41:11 <maartenm> and things like that
03:41:18 <koeien37> or PARI bindings :) would be really cool
03:41:20 <Cale> GAP really must have some kind of sensible C library we could bind to...
03:41:37 <luqui> Cale, you speak in oxymorons
03:41:44 <Cale> luqui: heh
03:41:48 <quicksilver> o-_-o: even the authors of RWH are fallible.
03:41:58 <quicksilver> o-_-o: although It's a bit sad that one got through
03:42:04 <Cale> luqui: It's more sensible to FFI to a C library than doing terminal IO to talk to a GAP subprocess
03:42:21 * quicksilver slaps dons, bos and CosmicRay.
03:42:24 <Cale> (albeit not by much)
03:42:43 <maartenm> if you do terminal IO you can do distributed computation more easily
03:43:14 <Cale> I suppose that's true.
03:43:30 <Cale> I just fear trying to parse all the various representations of GAP values
03:43:47 <HaskellLove> oh well why am i asking... either way i will stay in haskell at least 4 more months to solve eulers so, after i master it i will compare it to matlab then, and if i am crazy enough after that i will solve eulers in matlab and compare.
03:43:48 <Cale> I'm not sure how many it has.
03:44:15 <koeien37> Euler problems are not the way to master Haskell
03:44:43 * koeien37 shudders at the thought of doing them in matlab
03:45:09 <HaskellLove> and for ploting i will use octave for now
03:46:22 <Cale> I wonder how SAGE talks to GAP.
03:48:24 <maartenm> http://sage.math.washington.edu/home/mhansen/sage-epydoc/sage.interfaces.gap-pysrc.html
03:50:04 <maartenm> using terminal commands and stdout, it seems..
03:52:14 <Cale> hmm, yeah
03:53:23 <koeien37> SAGE is actually a pretty cool project imho
03:54:32 <HaskellLove> lets say i want to install this package... http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hmatrix i have cabal and all that installed, what now?
03:54:47 <luqui> cabal install hmatrix ?
03:54:50 <koeien37> what is your operating system?
03:55:14 <koeien37> you will probably need to install LAPACK and blas
03:55:21 <koeien37> the web page for hmatrix should explain it
03:56:03 <HaskellLove> ubuntu
03:56:37 <HaskellLove> sudo runhaskell Setup install, am i suposed to put the name of a setup file instead of setup there?
03:56:57 <quicksilver> no, the setup file should be called Setup
03:57:03 <quicksilver> (well, Setup.hs but that's ok)
03:57:47 <koeien37> for ubuntu it should be pretty easy
03:59:10 <HaskellLove> ok got it
04:00:00 <maartenm> what eule rproblem are you doing?
04:00:54 <HaskellLove> none i am learning matlab now
04:02:37 <HaskellLove> Wow hmatrix has all that GNU Octave has ... awesome
04:02:48 <ehird> I forgot how to write the Show instance for data Z; data S n (with -XEmptyDataDecls; type-level naturals)... I used to be able to. :/
04:02:48 <ehird> instance          Show Z     where show _ = "Z"
04:02:48 <ehird> instance (N n) => Show (S n) where show _ = "S " ++ ???
04:02:53 <ehird> Anyone written that?
04:03:11 <koeien37> HaskellLove: try /nick matlabLove
04:03:41 <HaskellLove> koeien37 not really I just wanna see what it can do... watching videos, not even bothering to read books on it
04:04:38 <koeien37> show _ = "S " ++ show (undefined:: n) ?
04:05:11 <luqui> with -XScopedTypeVariables
04:05:28 <ehird> aha!
04:05:46 <ehird> koeien37: I'd tried that but with annotating show's type, not the value; luqui: that was the missing piece of the puzzle
04:05:47 <ehird> thanks
04:06:03 <Cale> You could also just give them value-level representations though.
04:06:08 <ehird> now let's see if I can't write toNum :: (N n, Num m) => n -> m
04:06:17 <ehird> Cale: Considering I'm doing all the computation at compile-time, that would be difficult/a pain.
04:06:21 <luqui> Cale, wouldn't you need the same trick to reify?
04:06:36 <Cale> I just mean  data Z = Z; data S n = S n
04:06:37 <ehird> yes
04:06:47 <ehird> Cale: That's only useful for value-level computation.
04:07:16 * Cale tries to imagine why that would be
04:07:35 <Cale> It's the same as you have, only there's a non-bottom proof of the existence of each number.
04:07:35 <luqui> oh I see what you mean now!
04:07:41 <ehird> Because if you do show (undefined::MyMagicTypeComputation (S (S Z)))
04:07:43 <ehird> It doesn't work.
04:08:18 <luqui> ehird, it shouldn't, that's not a real proof
04:08:45 <ehird> Well, it's just a helper function for inspecting the results of a type-level computation.
04:08:51 <ehird> I'm just fiddling around, and it's convenient.
04:09:24 <ehird> luqui: it won't type if the computation is wrong
04:09:59 <ehird> although so far none of my computations _can_ fail
04:10:05 <ehird> the trick is just for testing things like :+
04:10:29 <ehird> I am using so many language extensions it's preposterous...
04:11:18 <ehird> *Main> undefined::S (S (S Z))
04:11:19 <ehird> type 3
04:11:36 <Cale> btw, it's more convenient to use {-# LANGUAGE ScopedTypeVariables, ... #-} rather than passing -X options to the compiler
04:11:54 <ehird> Actually, I was using multiple LANGUAGE comments.
04:12:12 <ehird> I could make it all into one, but I'd put one on each line anyway, because there's so many.
04:12:26 <Cale> ah
04:12:26 <koeien37> with a decent editor that's not much of a difference
04:12:29 <ehird> *Main> undefined :: Fact (S (S (S Z)))
04:12:29 <ehird> type 0
04:12:29 <ehird> Aww...
04:12:41 <luqui> I don't know why I still say -XFoo.  I always mean and use {-# LANGUAGE Foo #-}.  convenient notation, I guess...
04:12:51 <ehird> luqui: 'xactly
04:13:15 <Cale> I just call them by the names you use after LANGUAGE
04:13:41 <ehird> Note that you still have to do :set -Xfoo in ghci, even if the file uses foo.
04:13:59 <Baughn> ehird: The number of extensions I usually have to turn on makes me long for -fglasgow-extensions. It would be nice to have bundles.
04:13:59 <ehird> Ah, my :* is broken.
04:14:02 <Cale> I noticed that, it's annoying
04:14:12 <ehird> Does -fglasgow-exts not work anymore?
04:14:23 <Baughn> It gives off noxious warnings.
04:14:47 <koeien37> it's bad practice except for development
04:14:59 <ehird> *Main> undefined :: Fact (S (S (S Z)))
04:15:00 <ehird> type 6
04:15:01 <ehird> JAWSOME
04:15:05 <luqui> Baughn, maybe you should change your personal preferences to not require so many extensions
04:15:07 <ehird> Type families are rad.
04:15:14 <Cale> Hehe, we need an abstraction mechanism at the extension level. Next we'll want extension-level computation.
04:15:17 <ehird> I can almost fool myself into thinking I have dependent types.
04:15:19 <ehird> Almost.
04:15:24 <luqui> I used to use a bunch, but my recent code has pretty much all been Haskell 2010.
04:15:36 <Baughn> luqui: No.
04:15:38 <luqui> Except I use RankNTypes a bit.
04:15:50 <luqui> Baughn, YES
04:16:05 <luqui> Do it because I say so.  Appeal to unauthority.
04:16:07 * ehird writes Fib :: * -> *
04:16:09 <Baughn> luqui: Scoped type variables, view patterns, record extensions, various derive extensions...
04:16:10 <koeien37> I would like parametrized modules and modules as first-classed values first
04:16:16 <Baughn> luqui: I couldn't possibly live without them.
04:16:32 <koeien37> before we are going to have glasgowExts :: [LanguageExtension] :)
04:16:39 <koeien37> s/classed/class
04:16:42 <ehird> Haskell's type system isn't even total is it
04:16:48 <ehird> (w/ extensions)
04:16:57 <ehird> That one-variable LC can run (\x.x x)(\x.x x)
04:17:04 <ehird> So it's pretty powerful, actually
04:17:14 <luqui> koeien37, yes!
04:17:28 <luqui> biggest item on the wishlist for haskell *by far* is parameterized or first class modules
04:17:33 <luqui> not a trivial feature...
04:17:44 <luqui> biggest trivialesque feature is typeclass synonyms
04:17:45 <ehird> I wish Haskell had ML-style modules and functors, yeah.
04:17:46 <koeien37> I really would love   import GaloisField(37)
04:18:00 <maartenm> heh, cool idea
04:18:01 <ehird> They're simply objectively superior in every way to the current system.
04:18:19 <koeien37> import qualified GaloisField(37) as GF37 -- you could have more than one in scope
04:18:37 <luqui> ehird, i agree.  and anyone who argues that they can be encoded with typeclasses has never used that encoding in practice.
04:18:41 <ehird> Actually I'd say that if I could have only one abstraction method to Haskell, ML modules/functors would be it.
04:18:44 <luqui> it's grotesque
04:18:56 <Cale> import qualified forall n. GaloisField(n)
04:19:13 <ehird> Cale: why don't we just make every different level of haskell be haskell
04:19:19 <ehird> dependent types, infinite modules... :-)
04:19:26 <ehird> it'd solve every feature wish ever!
04:19:28 <koeien37> infinite modules?! :o
04:19:34 <ehird> quick; implement it in caleskell
04:19:35 <Baughn> Cyclic modules too. :3
04:19:42 <ehird> the Glasgow Caleskell Compileer
04:19:45 <ehird> *Compiler
04:19:45 <Baughn> Tying the module knot
04:19:53 <ehird> Baughn: Tying the language extension knot
04:19:57 <koeien37> Baughn: yeah, that could be interesting, but it's not *that* big of a deal imho
04:20:06 <Baughn> ehird: Implementing view patterns using view patterns?
04:20:15 <Baughn> ..well, that's pretty common for compilers
04:20:21 <ehird> Baughn: Why not
04:20:26 <ehird> I didn't mean extension implementation though
04:20:34 <ehird> Just extension specification
04:20:43 <ehird> as in glasgowExtensions :: [Extension]]
04:20:44 * Cale installs a heater on the front of the ship to melt the separate compilation iceberg. FULL STEAM AHEAD!
04:20:46 <ehird> *[Extension]
04:21:12 <ehird> Cale: add a halting checker, then we can have turing expressivity at every level *and* safety!
04:21:21 <ehird> everything is possible in the fantasy world of the Caleskell committee!
04:21:34 <koeien37> is there no use for UndecidableInstances in let fix f = f (fix f) in fix haskell  ?
04:22:06 <ehird> *Main> undefined :: Fib (S (S (S (S (S (S Z))))))
04:22:07 <ehird> type 8
04:22:53 <ehird> Somebody should add automatic function â†’ type family conversion to the Strathclyde Haskell Enhancement. :-)
04:23:38 <Cale> ehird: Now let's see you do fib 40 at the type level. ;)
04:24:21 <Cale> (or is it already efficient? :)
04:24:35 <ehird> type family   Fib n
04:24:36 <ehird> type instance Fib Z         = Z
04:24:36 <ehird> type instance Fib (S Z)     = S Z
04:24:37 <ehird> type instance Fib (S (S n)) = Fib (S n) :+ Fib n
04:24:48 <ehird> Implementations of a memoising Fib welcome
04:24:53 <ehird> ;-)
04:25:02 <Cale> Heh, type-level MemoCombinators
04:25:22 <Jafet> You'd still end up with fib 40 S's
04:25:39 <ehird> Jafet: That's the typechecker's problem.
04:25:45 <ehird> *Main> undefined :: Fib (Fact (S (S (S Z))))
04:25:46 <ehird> type 8
04:26:04 <Cale> Yeah, you also need a more efficient representation of the naturals for that
04:26:06 <Jafet> Well, memoizing won't help you in that case
04:26:07 <ehird> Guess I should implement (:-); see if my idea for ... kind-checking? ... works.
04:26:10 <koeien37> is it just me, or is 3! not 8
04:26:18 <luqui> ehird, how far can you go before you stack overflow, bro?
04:26:23 <Cale> koeien37: Fib is not fac
04:26:27 <koeien37> erm, right
04:26:28 <koeien37> thanks
04:26:30 <ehird> fib(fact(3))
04:26:31 <ehird> actually
04:26:39 <Cale> (I have made the same mistake myself :)
04:26:40 <Jafet> luqui, tail recursive type construction!
04:26:45 <ehird> luqui: gimme a suitably nested S-Z expr and i'll evaluate it :P
04:26:48 <ehird> too lazy to write out a bunch of Ss
04:27:11 <luqui> S (S (S (S (S (S (S (S (S (S (S (S Z)))))))))))
04:27:28 <ehird> data Empty; data Full = Full
04:27:28 <ehird> type family NonZero n
04:27:28 <ehird> type instance NonZero Empty = Empty; type instance NonZero Full = Full
04:27:29 <ehird> nonZero :: n -> NonZero n -> ()
04:27:31 <ehird> "I can't believe it's not Agda"
04:27:39 <Baughn> @let fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
04:27:39 <lambdabot>  Defined.
04:27:43 <ehird> luqui: fib or fact
04:27:51 <luqui> ehird, take your pick
04:28:07 <Baughn> @let facs = map (\n -> product [1..n]) [1..]
04:28:08 <lambdabot>  Defined.
04:28:18 <ehird> luqui: Fib outputs a HORRIBLE, HORRIBLE compiler error message
04:28:27 <luqui> :-)
04:28:32 <Baughn> > zipWith (/) fibs facs
04:28:33 <lambdabot>   [0.0,0.5,0.16666666666666666,8.333333333333333e-2,2.5e-2,6.944444444444444e...
04:29:06 <ehird> luqui: Can you increase the compiler's stack space?
04:29:13 <koeien37> > take 10 . drop 10000 . zipWith (/) fibs (tail fibs)
04:29:15 <lambdabot>   No instance for (GHC.Real.Fractional [a])
04:29:15 <lambdabot>    arising from a use of `GHC.Rea...
04:29:26 <luqui> istr you can, but i don't typically partake in this type level business...
04:29:40 <koeien37> > take 10 . drop 10000 $ zipWith ((/) `on` fromIntegral ) fibs (tail fibs)
04:29:42 <lambdabot>   [NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN]
04:30:00 <ehird> luqui: damn you for making me try Fact on your awful number :-)
04:30:02 <koeien37> > take 10 . drop 100 $ zipWith ((/) `on` fromIntegral ) fibs (tail fibs)
04:30:04 <lambdabot>   [0.6180339887498949,0.6180339887498949,0.6180339887498948,0.618033988749894...
04:30:06 <ehird> that *hurt* my computer
04:30:28 <luqui> yeah.  well, 12 *is* a pretty big number for such a little compiler
04:30:36 <ehird> absolutely
04:31:11 <luqui> > take 10 . drop 100 $ zipWith (%) fibs (tail fibs)
04:31:12 <lambdabot>   [354224848179261915075 % 573147844013817084101,573147844013817084101 % 9273...
04:31:24 <Baughn> > fibs !! 1000
04:31:25 <lambdabot>   434665576869374564356885276750406258025646605173717804024817290895365554179...
04:31:26 <luqui> > take 10 . drop 100 . map realToFrac $ zipWith (%) fibs (tail fibs)
04:31:27 <lambdabot>   [0.6180339887498949,0.6180339887498949,0.6180339887498949,0.618033988749894...
04:31:31 <luqui> > take 10 . drop 10000 . map realToFrac $ zipWith (%) fibs (tail fibs)
04:31:32 <lambdabot>   [0.6180339887498949,0.6180339887498949,0.6180339887498949,0.618033988749894...
04:31:39 <Baughn> > fibs !! 1000000
04:31:41 <lambdabot>   * Exception: stack overflow
04:31:43 <koeien37> better, yeah
04:32:06 <Baughn> > (fibs `using` seqList) !! 1000000
04:32:07 <lambdabot>   Couldn't match expected type `[a]'
04:32:07 <lambdabot>         against inferred type `a1 -> Con...
04:32:09 <ehird> yay
04:32:25 <Baughn> @type seqList
04:32:26 <ehird> I have (conceptually) `type family (:-) :: NonZero -> N -> N`
04:32:26 <lambdabot> forall a. Strategy a -> [a] -> Done
04:32:43 <ehird> type family pattern-matching failure == type error :-)
04:33:06 <luqui> :t using
04:33:07 <lambdabot> forall a. a -> Strategy a -> a
04:33:20 <ehird> hey, with type classes + type families you can even do TypeNum
04:33:29 <ehird> have :+ for both type naturals and type rationals etc
04:34:06 <luqui> huh that hadn't occurred to me
04:34:24 <ehird> you won't catch me implementing ratio simplification in the type system, though
04:34:28 <ehird> ... well, maybe you will
04:34:30 <ehird> I'm certainly tempted
04:34:37 * ehird factors everything out into TypeNum, anyway
04:34:59 <ehird> hmm
04:35:12 <ehird> can you do `class ... where type family ...` or do you have to do just type
04:35:15 * ehird tries
04:35:22 <ehird> (I like the function-esque syntax of type families)
04:35:35 <Baughn> @undefined
04:35:38 <Baughn> @undefine
04:36:06 <luqui> > (fibs `using` seqList rnf) !! 100000
04:36:07 <lambdabot>   Not in scope: `fibs'
04:36:29 <luqui> Baughn, oh look what you just did.  that was nice though, clearing out the memory
04:36:30 <Baughn> It won't work. seqList reduces the /entire/ list.
04:36:36 <ehird> btw does ghc 6.10 support the gadt syntax for type families?
04:36:43 <Baughn> I'm trying to cook up an incremental one..
04:36:45 <luqui> Baughn, oh right :-)
04:37:14 <Baughn> @let fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
04:37:15 <lambdabot>  Defined.
04:37:38 <Baughn> @type seqList
04:37:39 <lambdabot> forall a. Strategy a -> [a] -> Done
04:37:42 <luqui> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) ; bangbang (x:xs) 0 = x; bangbang (x:xs) n = x `seq` bangbang xs (n-1) in fibs `bangbang` 100000
04:37:44 <lambdabot>   259740693472217241661550340212759154148804853865176965847247707039525345435...
04:38:17 <medfly> bangbang :)
04:39:35 <Jafet> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) ; (x:xs) !! 0 = x; (x:xs) !! n = x `seq` (xs !! (n-1)) in fibs !! 100000
04:39:37 <lambdabot>   259740693472217241661550340212759154148804853865176965847247707039525345435...
04:41:02 <Baughn> > (fibs `using` parBuffer 1000 rwhnf) !! 1000000
04:41:03 <lambdabot>   Couldn't match expected type `Control.Parallel.Strategies.Done'
04:41:04 <lambdabot>         aga...
04:41:26 <Baughn> > (parBuffer 1000 rwhnf fibs) !! 1000000
04:41:27 <lambdabot>   * Exception: stack overflow
04:42:17 <Baughn> @let depList [] = []; depList (x:xs) = x `seq` (x:(depList xs))
04:42:18 <lambdabot>  Defined.
04:42:25 <Baughn> > depList fibs !! 1000000
04:42:29 <lambdabot>   mueval-core: Time limit exceeded
04:42:32 <Baughn> > depList fibs !! 100000
04:42:34 <lambdabot>   259740693472217241661550340212759154148804853865176965847247707039525345435...
04:42:54 <Baughn> ..well, it'll have to do.
04:44:38 <Accidus> Hmm... Does anyone know the rank of the lifting monad?
04:44:59 <luqui> Accidus, general
04:45:37 <Accidus> luqui, what?
04:46:26 <luqui> well it's not specific, and surely more than just an internal colonel
04:46:48 <osfameron> the french lieutenant's monad
04:47:23 <Accidus> lol
04:47:27 <burp> lol
04:49:29 <Accidus> luqui, A monad has a k-rank if it preserves all k-filtered colimits, where k is some cardinal
04:49:39 <Accidus> Ah, left.
04:50:02 <Accidus> In any case, the question is: is there some cardinal k such that the lifting monad has k-rank?
04:50:22 <Baughn> No.. that's not it... the question is, what is a co-limit?
04:51:20 <dblhelix> luqui: kind of like general recursion? http://www.cs.nott.ac.uk/~txa/GeneralRecursion.jpg
04:51:49 <dblhelix> so much cooler than sgt. pepper
04:52:00 <Accidus> Baughn, do you know what a (categorical) limit is?
04:52:06 <Jafet> http://adrinael.net/hr.gif
04:52:14 <Baughn> Accidus: Nope! ^_^
04:52:33 <Accidus> Baughn, how much category theory do you know?
04:52:39 <Baughn> Accidus: None.
04:52:57 <Accidus> Baughn, then I don't think I'll try to explain then :)
04:53:00 <Baughn> Accidus: ..I'll just go find a tutorial, shall I?
04:53:13 * dblhelix graps Baughn 
04:53:16 <Accidus> Erm.... And a few weeks as well :)
04:53:24 <Baughn> Graps?
04:53:24 <dblhelix> Baughn:  you almost fell into the curlpit
04:53:34 <dblhelix> grabs
04:53:37 <Baughn> dblhelix: And.. grapping me will help?
04:53:38 <Jafet> Culprit?
04:53:43 <Baughn> Curlpit.
04:53:54 <Baughn> It's what you get when curlers clean /too much/.
04:54:14 <dblhelix> terrible typing skills, I'm sorry :)
04:54:39 <dblhelix> but you guys make a far better spell checker than the one I use atm
04:55:31 <dolio> Even if you know what a colimit is, you have to then learn what a k-filtered colimit is.
04:55:52 <Baughn> Do categorical limits have anything whatsoever to do with calculus limits?
04:56:18 <Baughn> Or are we talking the sort of metaphysical limit that would make Lambdadelta proud?
04:56:37 <Jafet> Calculus is metaphysical, son
04:57:33 <dblhelix> ah... copumpkin got triggered by "category theory" and "k-filtered colimit" :)
04:58:30 <quicksilver> Baughn: it's not a directly comparable concept but I bet if you choose your category carefully enough you can turn a calculus limit into a categorical limit of some kind.
04:59:28 <SubStack> hopefully this word packing converter and endianness manipulator I just wrote wasn't actually necessary in the first place
04:59:47 <quicksilver> sounds like the kind of think you could use Data.Binary.Get/Put for
05:00:03 <SubStack> it certainly sounds that way at first
05:01:21 <SubStack> until you need to do the conversions in a manner that is decoupled from a read-only or write-only binary stream
05:02:04 <quicksilver> Baughn: http://mathoverflow.net/questions/9951/limits-in-category-theory-and-analysis
05:03:23 <Baughn> quicksilver: Interesting site, but I think I should read the category theory tutorials first. :P
05:03:43 <Baughn> Mainly I'm gathering that I've got too little knowledge.
05:03:59 <quicksilver> SubStack: well you can always run runGet and runPut on small toy ByteStrings
05:04:03 <Baughn> ..so, I just wrote a Double-to-IEEE754-double converter.
05:04:09 <quicksilver> SubStack: and pack/unpack to [Word8] or similar.
05:04:19 <Baughn> But aren't machine doubles in mainstream desktop CPUs /already/ IEEE754 doubles?
05:04:42 <quicksilver> in memory, yes, in registers, not on x87.
05:04:55 <quicksilver> well still IEEE754, but IEEE754 80bit instead of 64bit
05:04:56 <SubStack> I care more about convenience than speed for this particular application
05:05:12 <Baughn> quicksilver: Well, presumably we'd do a copy from memory to bytestring then
05:05:46 <SubStack> I'll just throw this thing up on github
05:05:50 <Baughn> The current Data.Binary implementation is completely insane, but manually recomposing the double isn't that much better
05:08:23 <SubStack> insane in a good way?
05:08:41 <Baughn> No. Insane in a good way would imply using pointers and memory peeks.
05:08:50 <Baughn> Insane in a "put . encodeFloat" way.
05:09:20 <SubStack> ick
05:17:22 <mreh> > concatMaybes $ (map Just [1..10]) ++ repeat Nothing
05:17:23 <lambdabot>   Not in scope: `concatMaybes'
05:17:30 <mreh> > concatMaybe $ (map Just [1..10]) ++ repeat Nothing
05:17:31 <lambdabot>   Not in scope: `concatMaybe'
05:18:27 <quicksilver> > catMaybes $ (map Just [1..10]) ++ repeat Nothing
05:18:33 <lambdabot>  Terminated
05:18:37 <mreh> i thought so
05:18:38 <quicksilver> is what you wanted ;)
05:18:47 <mreh> i was testing the behaviour
05:18:56 <mreh> I need to stop on the first Nothing
05:19:04 <mreh> takeWhile i suppose
05:19:07 <quicksilver> takeWhile (isJust)
05:19:16 <quicksilver> > catMaybes . takeWhile (isJust) $ (map Just [1..10]) ++ repeat Nothing
05:19:17 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
05:19:32 <mreh> :t msum
05:19:33 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
05:19:57 <mreh> > msum [Nothing, Just 2, Just 14, Nothing]
05:19:59 <lambdabot>   Just 2
05:20:24 <mreh> > msum $ [Nothing, Nothing, Nothing]
05:20:25 <lambdabot>   Nothing
05:20:50 <mreh> so I can stop in the first Just, just not in the first Nothing
05:21:20 <mreh> > msum $ [Nothing, Just 2] ++ repeat Nothing
05:21:22 <lambdabot>   Just 2
05:23:59 <gwern> ...
05:24:13 <gwern> you know, I am seriously getting tired of all the 'foo doesn't work on OS X' messages
05:26:18 <quicksilver> (a) make them work (b) stop reading the messages ? ;)
05:26:28 <mreh> c) get ubuntu
05:26:32 <xerox> what is foo?
05:26:41 <gwern> xerox: foo is a metasyntactic variable
05:26:41 <mreh> solve for "foo"
05:26:48 <mreh> lol
05:26:51 <xerox> I mean in this case :)
05:26:54 <gwern> quicksilver: yes, I've just created a gmail filter to mark them read
05:26:56 <mreh> examples include "bar" and "baz"
05:27:08 <gwern> xerox: what was the straw that broke the camel's back? a pandoc problem, if you must know
05:27:23 <xerox> uninstall foo  :D
05:28:24 <zygoloid> E: Couldn't find package foo
05:30:45 <SubStack> http://github.com/substack/hs-convert-words/blob/master/src/Data/Word/Convert.hs (from earlier)
05:31:02 <gwern> (stupid geeks going to macs. talk about the dark side)
05:32:06 <SubStack> gwern: at least they have shells now
05:32:51 <gwern> SubStack: my threnody is for those going *nix->Mac, not Windows->Mac
05:33:27 <SubStack> I don't understand it either.
05:33:35 <SubStack> but then I'm running xmonad
05:34:56 <pozic> gwern: the battery time is good, though.
05:34:56 <lambdabot> pozic: You have 1 new message. '/msg lambdabot @messages' to read it.
05:35:11 <gwern> pozic: the dark side is easy and seductive, in some ways
05:35:31 <gwern> this is sort of a collective action problem. any individual geek has incentive to defect and use macs, even though collectively that is very bad for us
05:35:59 <fabjan> One can run linux on it
05:36:08 <pozic> gwern: you could say that about every product.
05:36:15 <fabjan> although those who write emails about things not working on os x probably dont :)
05:36:17 <trin_cz> gwern: i have to work on mac sometimes and not having the middle button as Paste really irritates me
05:36:18 <pozic> gwern: e.g., we should have open-source cars.
05:36:29 <pozic> gwern: open-source robotic farms.
05:36:36 <pozic> gwern: ad infinitum.
05:36:46 <pozic> gwern: where do you draw the line?
05:36:58 * Accidus is back to wonder about ranks of monads.
05:37:06 <SubStack> I want some manufacturer who is not sony to put out a cheap version of the vaio p with 12 hours of battery life and linux preinstalled on an arm
05:37:20 <Badger> instance Monad King where
05:37:21 <SubStack> probably it'll be a while
05:37:37 <samulihs> I consider myself a geek and I have no interest in using osx
05:37:42 <pozic> I don't even get 1.3 hours of battery life because of the bad drivers.
05:38:02 <pozic> I have a recent laptop. On Windows Vista it is supposed to be possible to do 4 hours with it.
05:38:33 <Ke> SubStack: why not Mips
05:38:48 <Ke> far more open arch
05:38:51 <pozic> The most practical step would be for some government to decide it is illegal to sell hardware without proper specifications and payment for every bug in the documentation.
05:38:58 <Ke> also no ghc port yet
05:39:01 <SubStack> any kind of risc is fine
05:39:12 <SubStack> good for battery life and keeping everything on the cheap
05:39:28 <fabjan> pozic: for some definition of practical :)
05:40:08 <pozic> fabjan: well, if we would have a rational government that's what would happen.
05:40:21 <pozic> fabjan: I know that is a big if.
05:41:05 <Badger> heh
05:41:16 <Badger> my laptop's battery life is 5-10 minutes
05:41:26 <SubStack> poor thing
05:41:57 <gwern> my laptop's battery is broken, therfore it's life is 0 minutes
05:42:10 <pozic> I am basically at the point that I might want to configure Windows Vista such that I can use it when travelling for example.
05:42:18 <Badger> gwern: as good as the very best desktops!
05:42:33 <gwern> (actually, very good desktop setups usually have UPS)
05:42:33 <pozic> And only that because reverse-engineering all the drivers is too much work for one person.
05:42:48 <Badger> ah
05:42:49 <Adamant> gwern: UI designers generally aren't stupid enough to work for free
05:42:57 <Badger> I suppose they would
05:43:16 <Ke> Adamant: what about xmonad?
05:43:20 <Badger> as good as not quite the best then. :)
05:43:24 <gwern> Adamant: because the hirstory of linux demonstrates that FLOSS is utter poison to developnment of GUI apps
05:43:29 <pozic> Adamant: people still work for US dollars. That's about the same.
05:43:35 <Adamant> gwern: solve that problem and you'll have solved the Linux - > Mac problem
05:43:46 <Adamant> gwern: it's poison to the development of good, usable ones
05:44:06 <Adamant> because developers have to live under the iron first of the UI nazis
05:44:12 <Adamant> and they don't want to do that
05:44:14 <Ke> that's because linux users don't care about the UI
05:44:17 <pozic> Adamant: the thing about GUIs is that there is no GUI which is optimal for everyone.
05:44:18 <Adamant> and I don't blame them
05:44:24 <Adamant> but it's better overall in the end
05:44:33 <Ke> I only care about good hardware abstraction and programmability
05:44:48 <pozic> Adamant: writing a GUI also takes a lot of time and when you have a lot of different users, what should you pick?
05:45:09 <Adamant> pozic: I don't know, I'm not a UI designer?
05:45:13 <mreh> is there something more idiomatic than: (\x -> map (x !!) n')
05:45:17 <pozic> Adamant: that is the real reason why people are not interested in programming UIs.
05:45:48 <pozic> Adamant: UI designers also don't know anything. They have a bunch of heuristics and some experience, but there will always be a user saying "what a stupid UI".
05:46:04 <pozic> I am especially thinking about very complex applications.
05:46:23 <pozic> There are some domains where there are only a few ways in which you present the menus/options/data.
05:46:24 <Adamant> pozic: sounds a lot like most software
05:46:45 <pozic> Adamant: right
05:47:09 <Adamant> and while UI designers might not know much, I tend to think most of here have negative knowledge in terms of making stuff the average person can use
05:47:17 <Adamant> and I would include myself in that
05:47:29 <Adamant> (having negative knowledge)
05:47:43 <CalJohn> imo, there are two fundamental problems with UI "theory" atm
05:48:08 <CalJohn> #1 we don't know any more than "convention is best"
05:48:10 <lunabot>  luna: parse error on input `|]'
05:48:28 <CalJohn>  #2 users never want to learn any new conventions
05:49:07 <medfly> haha
05:49:14 <pozic> In reality I think a good UI is just not making a user input stuff which the computer can derive itself.
05:49:37 <medfly> that's strange. I'm making a UI. am I inherently bad at it?
05:49:46 <medfly> because I'm here
05:49:56 <pozic> medfly: there is no way to mark you as being good at it ;)
05:50:14 * hackagebot upload: stylized 0.1.2 -  (LucaMolari)
05:50:22 <pozic> medfly: you might know all the APIs, which puts you already at the top, though.
05:50:57 <medfly> no, I suck, but okay :)
05:51:17 <medfly> maybe I'll be more careful not to suck too bad :)
05:51:21 <xerox> medfly there is this tool that suggests placements for widgets...
05:51:37 <medfly> nah, I'm not making a huge thing, it's okay:)
05:52:14 <xerox> and then exports an xml, and you load it an bind callbacks. it's quite handy.
05:52:39 * SubStack just uses web browsers for UI
05:53:30 <SubStack> much easier to deploy
05:53:44 <mreh> > flip map (map (flip (!!)) [1,2,0]) . $ [a,b,c]
05:53:45 <lambdabot>   <no location info>: parse error on input `$'
05:54:01 <mreh> > flip map (map (flip (!!)) [1,2,0]) . ($ [a,b,c])
05:54:02 <lambdabot>   No instance for (Test.SmallCheck.Serial SimpleReflect.Expr)
05:54:02 <lambdabot>    arising from...
05:54:10 <mreh> > flip map (map (flip (!!)) [1,2,0]) . ($ [1,2,3])
05:54:11 <lambdabot>   * Exception: Prelude.(!!): index too large
05:57:13 <mreh> @pl (\xs ns -> map ($ xs) (map (flip (!!)) ns))
05:57:14 <lambdabot> (. map (flip (!!))) . map . flip id
05:58:13 <mreh> flip id?!
05:58:18 <mreh> :t flip
05:58:19 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
05:58:52 <koeien37> flip id x = ($x)
05:59:05 <stoop> :t ($x)
05:59:06 <lambdabot> forall b. (Expr -> b) -> b
05:59:07 <stoop> :t id
05:59:08 <lambdabot> forall a. a -> a
05:59:12 <stoop> :t ($o)
05:59:14 <lambdabot> forall b. (Expr -> b) -> b
05:59:18 <stoop> blargh
05:59:32 <mreh> stoop: ($) is function application
05:59:34 <xerox> id :: (a -> b) -> (a -> b)   flip id :: a -> (a -> b) -> b
05:59:42 <stoop> mreh, oh, I know.
05:59:47 <koeien37> > map ($3) [(+1), (*2)]
05:59:49 <lambdabot>   [4,6]
06:00:09 <stoop> @src ($)
06:00:10 <lambdabot> f $ x = f x
06:00:21 <stoop> :t ($3)
06:00:23 <lambdabot> forall a b. (Num a) => (a -> b) -> b
06:00:25 <pozic> SubStack: have you made anything which is on the web?
06:02:01 <mreh> i want to select the same permutation of indexes from a series of lists
06:04:50 <xerox> > (!!) <$> ["a quick","brown fox","jumps over","the lazy dog"] <*> [0,2,4]
06:04:51 <lambdabot>   "aqibonjmstel"
06:06:48 <stoop> rusty :(
06:06:51 <stoop> :t <$>
06:06:52 <lambdabot> parse error on input `<$>'
06:06:56 <stoop> :t (<$>)
06:06:57 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:07:07 <nlogax> :t fmap
06:07:08 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:07:11 <stoop> ah
06:07:19 <stoop> :t (<*>)
06:07:20 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
06:09:05 <tromp_> > 1280 % 720
06:09:06 <lambdabot>   16 % 9
06:10:09 <SubStack> o_O
06:10:24 <SubStack> :t (%)
06:10:25 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
06:30:39 <Absolute0> How can I have a record and a function with the same name in the same file?
06:30:47 <Absolute0> should i use modules?
06:31:03 <Absolute0> I basically want some sort of namespacing.
06:31:14 <Absolute0> DictSpace.foo
06:31:18 <Absolute0> Main.foo
06:32:43 <ivanm> Absolute0: can't do that
06:32:44 <koeien> yes, modules
06:32:58 <ivanm> well, I suppose you can with module aliases, etc.
06:33:01 <koeien> but data Foo = Foo { f :: Int } and a function  in the same file would clash
06:33:02 <ivanm> but why would you want to?
06:33:11 <Absolute0> can you have 2 modules int ehs ame file?
06:33:22 <ivanm> I'm sure most people here agree with me that that's a feature of {Java,C++, etc.} we're more than happy to do without!
06:33:28 <ivanm> Absolute0: no
06:33:45 <Absolute0> say I have a function whitePlayer, and then I want to save the return value in a whitePlayer name
06:33:53 <ivanm> Absolute0: just get inventive in how to name your functions!
06:33:59 <Absolute0> but the saved value must be wPlayer
06:34:02 <Absolute0> or some other silly name
06:34:04 <ivanm> Absolute0: ummm.... what?
06:34:05 <Absolute0> and thats not readable
06:34:23 <Ke> all languages should have C++ style namespaces
06:34:33 <shambler_> return value?
06:34:34 <ivanm> there are various record extensions, one of which lets you (in fact forces you) to have variables the same as the record name...
06:34:38 <ivanm> Ke: why?
06:34:53 <Absolute0> Game {whitePlayer::Foo, blackPlayer::Foo}; wPlayer = ...
06:34:59 <Ke> because there are no significant drawbacks
06:35:21 <ivanm> Ke: so what?
06:35:44 <Absolute0> then I would do Game wPlayer bPlayer
06:35:48 <ivanm> and I think "verbosity" is a serious drawback
06:35:53 <koeien> yeah I'm not totally happy with the record system in Haskell
06:36:05 <ivanm> koeien: _no-one_ is happy with Haskell's record system!
06:36:16 <koeien> I don't have a better proposal though :P
06:36:23 <ivanm> IIRC, SPJ's history of haskell says that the current one is a compromise because no-one could agree on how to do it
06:36:24 <Adamant> Haskell::ivanm: I agree
06:36:29 <ivanm> Adamant: heh
06:36:59 <ivanm> Ke: I find Haskell can get verbose enough as it is since you have to think up a lot more names than in imperative langs
06:37:21 <Ke> !!
06:38:13 <Absolute0> ivanm: usually you just think up of clever operators to overload instead :-P
06:38:27 <Absolute0> but that isnt so readable.
06:38:28 <ivanm> Absolute0: no, overloading is _bad_
06:38:33 <Absolute0> :)
06:38:47 <ivanm> -Wall complains if you overload, and heaven forbid you make -Wall complain!
06:38:48 <ivanm> ;-)
06:38:50 <mreh> :t msum
06:38:51 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
06:39:05 <ivanm> @src msum
06:39:05 <lambdabot> msum =  foldr mplus mzero
06:39:16 <theclaw> hmm, in http://www.haskell.org/all_about_monads/html/readermonad.html, in the definition of (>>=), "f (r e)" results in something of type "Reader", so "f (r e) e" shouldn't work? I.e., is there "runReader" missing?
06:39:21 * hackagebot upload: SimpleAES 0.3 - Fast AES encryption/decryption for bytestrings (DavidHimmelstrup)
06:39:23 * hackagebot upload: stylized 0.1.3 - Ways to output stylized text on ANSI consoles. (LucaMolari)
06:39:51 <Jafet> @hoogle curses
06:39:52 <lambdabot> No results found
06:39:55 <Lemmih> theclaw: Yes.
06:40:37 <ivanm> Jafet: curses, hoogle doesn't know anything about curses...
06:40:42 <theclaw> Lemmih: so it should be "Reader $ \e -> runReader (f (r e)) e" ?
06:40:56 <Jafet> Perhaps it should search in the attic.
06:40:59 <Lemmih> theclaw: Yes, something like that.
06:41:21 <theclaw> Lemmih: thanks. (should I report that?)
06:42:25 <Lemmih> theclaw: Yes, please send any comments, corrections, or suggestions to Jeff Newbern at jnewbern@yahoo.com.
06:43:14 <theclaw> overlooked that. thx
06:45:23 <Absolute0> Is there a version of Numeric that doesn't take an extra argument for the suffix?
06:48:10 <Lemmih> Absolute0: Numeric is a module, not a function.
06:48:57 <Absolute0> Lemmih: all its show*** functions have an extra parameter for the suffix.
06:49:10 <Absolute0> > showHex (0x10 ^3) ""
06:49:11 <lambdabot>   "1000"
06:50:19 <Lemmih> Absolute0: That is correct.
06:50:31 <Absolute0> :)
06:51:06 <Absolute0> why would Numeric assume that you need a suffix?
06:51:13 <Absolute0> thats not very reusable code. :(
06:51:38 <Lemmih> Absolute0: It allows you to efficiently combine the functions.
06:51:44 <Woof> :src showHex
06:51:46 <Absolute0> ah
06:51:54 <Woof> @src showHex
06:51:54 <lambdabot> Source not found. That's something I cannot allow to happen.
06:52:13 <Absolute0> > showHex 5 $ showHex 6 ""
06:52:14 <lambdabot>   "56"
06:52:26 <Absolute0> still silly imo
06:53:53 <ehird> can \begin{code} ... \end{code} be used in a literate haskell file that isn't latex?
06:53:57 <ehird> as an alternative to bird tracks
06:54:14 <pozic> ehird: that doesn't really mean anything.
06:54:25 <Lemmih> Absolute0: You rarely have to use an empty suffix.
06:54:32 <pozic> ehird: the compiler won't analyze your whole code.
06:54:45 <pozic> ehird: that is, to see whether it is \LaTeX.
06:54:50 <Absolute0> Lemmih: everytime i invoked that function i didn't need a suffix. :)
06:54:51 <ehird> pozic: good point
06:55:23 <pozic> ehird: (to see whether something is LaTeX it would have to be executed, which can take an infinite amount of time)
06:55:36 <ehird> well, or simple syntax checking
06:55:48 <Lemmih> Absolute0: Define things in terms of ShowS and enlightenment will come.
06:55:50 <pozic> ehird: heuristics are not very academic ;)
06:56:04 <ehird> a non-terminating TeX program is still a TeX program.
06:56:26 <Absolute0> is there a version of (.|.) that works on lists?
06:56:27 <ehird> you wouldn't argue that a haskell program that evaluates (error "foo") isn't a Haskell program would you?
06:56:30 <ehird> it's just _|_
06:57:36 <Absolute0> ie: .|. [0x01,0x02] -> 0x3
06:57:51 <Lemmih> > (showHex 42 . showString " = " . shows 42) ""
06:57:52 <lambdabot>   "2a = 42"
06:58:13 <xerox> Absolute0 what is .|. ?
06:58:20 <Absolute0> xerox: bitwise or
06:58:22 <ivanm> pozic: the other day you were saying to me that all in one inkjets are bad; do you have any opinions on HP's deskjet range?
06:58:25 <pozic> ehird: so, it would be possible to parse it, but it wouldn't mean a whole lot.
06:58:27 <Absolute0> Data.Bits..|.
06:58:34 <Lemmih> > foldl (.|.) 0 [1,2] :: Int
06:58:36 <lambdabot>   3
06:58:46 <pozic> ivanm: yes, those of HP are particularly bad. :)
06:58:52 <ivanm> heh
06:58:58 <pozic> ivanm: too much maintenance.
06:58:59 <Absolute0> Lemmih: not foldl' ?
06:59:09 <ivanm> pozic: but HP has the best linux support out of the large printer manufacturors :(
06:59:18 <xerox> > zipWith (.|.) [0,1,0]Â [1,0,1] :: [Int]
06:59:19 <lambdabot>   [1,1,1]
06:59:32 <ivanm> Absolute0: for a list that short, foldl' won't make that much of a difference...
06:59:47 <pozic> ivanm: basically everytime you put in a new cartridge you have to print a test page and scan the result to align the printheads.
06:59:48 <Lemmih> Absolute0: Pick whichever fold you want. You could even use a right fold in this case.
07:00:03 <ivanm> pozic: *nod*
07:00:14 <pozic> ivanm: and you cannot print black if you have no colour.
07:00:18 <ivanm> that sucks
07:00:49 <ivanm> pozic: I have a colour laser at home I use for most stuff; it's just that when I move out and need to get a printer of my own, I was looking at an inkjet to be able to print photos and CD labels
07:01:02 <ivanm> even if I go to a shop for photos, that doesn't help me with CD labels
07:01:11 <ivanm> (not that I envisage printing that many... >_>)
07:01:18 <ivanm> oh, and lasers are much dearer :s
07:01:56 <ivanm> (yes, they're cheaper in the long run; but getting a colour all-in-one laser, preferably with network support, is rather pricey from a quick scan I've done)
07:03:26 <Adamant> ivanm: why not get a scanner seperately
07:03:58 <Adamant> that should make the color laser quite a bit cheaper
07:03:58 <ivanm> because
07:03:58 <ivanm> ;-)
07:04:03 <sshc> is there a function in the standard library that squares a floating point number?
07:04:06 <Adamant> ok
07:04:15 <ivanm> (one less unit, integration, blah, blah, blah)
07:04:16 <int-e> > (^2) 10.0
07:04:17 <lambdabot>   100.0
07:04:40 <Adamant> ivanm: well, if you're in a Eurocity, size might also be more of a concern
07:04:48 <ivanm> nope, down under
07:05:05 <Adamant> ah, don't know how tightly packed stuff is in the cities there
07:05:19 <ivanm> it's not that I won't have space
07:05:25 <ivanm> it's just that I might not have _desk space_ ;-)
07:05:30 <Adamant> ah, right
07:05:32 <ivanm> and an extra power point, etc.
07:08:24 <kw317> does anyone have the book "formal semantics of programming languages" by winskel?
07:08:51 <kw317> I need the page 164 :-)
07:09:09 <shambler_> check google books :>
07:09:09 <ivanm> books.google.com ?
07:10:28 <kw317> I've tried, but bits of text seem to be missing
07:10:36 <Absolute0> ghci under ubuntu doesn't seem to have a functioning delete key binding, there is not ghc-readline package either.
07:10:51 <Absolute0> what else might i need to install to get that working;
07:10:52 <Absolute0> ?
07:11:22 <Absolute0> libreadline6-dev ?
07:11:26 <ivanm> Absolute0: it must be using the haskeline bindings...
07:11:33 <ivanm> I mean editline
07:11:49 <ivanm> Absolute0: so see what ubuntu allows in terms of customisation of editline (AKA libedit)
07:11:57 <Absolute0> libghc6-editline-dev
07:12:05 <Absolute0> p   libghc6-editline-dev            - Haskell bindings to the BSD editline libra
07:13:19 <Absolute0> should I logout and login?
07:13:24 <Absolute0> installing it didnt fix it.
07:13:30 <Absolute0> let me install readline
07:14:53 <Absolute0> not that either
07:15:27 <mreh> @hoogle [(a -> b)] -> a -> [b]
07:15:28 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
07:15:28 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
07:15:28 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
07:15:55 <mreh> humpf
07:16:08 <Peaker> @type flip (map . ($))
07:16:09 <lambdabot> forall a b. [a] -> (a -> b) -> [b]
07:16:12 <Peaker> oops
07:16:16 <mreh> i was just thinking that
07:16:28 <Peaker> @type flip (map . flip ($))
07:16:29 <lambdabot> forall a b. [a -> b] -> a -> [b]
07:17:12 <CalJohn> is it possible to get ICFP videos further back than 2009?  specifically, I'm interested in "Backtracking, Interleaving, and Terminating Monad Transformers" by oleg and co
07:18:17 <Jonno_FTW> is it possible to update to ghc 6.12 through cabal? if so how?
07:18:46 <gwern> Jonno_FTW: cabal can't update ghc
07:19:03 <Jonno_FTW> then how?
07:19:16 <sshc> @faq Can Haskell update GHC?
07:19:17 <lambdabot> The answer is: Yes! Haskell can do that.
07:19:47 <mreh> I like how "Haskell" can do things
07:20:36 <sshc> I guess you can write a hashell script or something to download and extract the GHC package
07:23:03 <Lemmih> CalJohn: I don't think they were recorded before 2009.
07:23:25 <Lemmih> Oh wait. I might be wrong about that.
07:24:52 <Lemmih> I remember some guy recording the talks at ICFP'07 but I couldn't find the videos online afterwards.
07:25:04 <xerox> I think it was malcolmw ?
07:25:41 <malcolmw> Lemmih: ICFP'07 was in Freiburg, right?
07:25:57 <Lemmih> malcolmw: Yeah.
07:26:18 <malcolmw> Lemmih: those talks were recorded by Peter Thiemann for the ACM digital library
07:26:32 <malcolmw> but they have never made it online, as far as I can tell
07:28:11 <malcolmw> I did guerilla-record the Haskell'07 talks, and make them available
07:28:47 <xerox> Ah that was it.
07:42:11 <roconnor> A bounded semilattice is an idempotent commutative monoid.
07:42:37 <copumpkin> hell yeah
07:42:57 <roconnor> what do you call an idempotent commutative monad?
07:43:23 <roconnor> A bounded semilatad?
07:43:24 <copumpkin> a banded semalattice
07:43:52 <roconnor> na a semilattice is already a commutative band
07:44:02 <theoros> you should've turned it into a pun
07:44:10 <xerox> like the klein four group
07:44:16 <roconnor> theoros: this is serious stuff :P
07:44:36 <b0fh_ua> Hi there! Can somebody please explain why am I getting the error  Parse error in pattern on line 6 in the source: http://pastebin.com/d39e334af ?
07:46:17 <copumpkin> kleinsli four group?
07:46:43 <xerox> eh eh, should we bring up the youtube clip...
07:46:57 <koeien37> ha, that one is perfect
07:47:45 <malcolmw> b0fh_ua: the error is probably on line 9 really - the "else" should be followed immediately by "do"
07:53:21 <CalJohn> it looks like someone has changed the logo of /r/haskell
07:53:47 <lispy> CalJohn: is that good or bad?
07:54:42 <CalJohn> good, i much prefer the narwhal design
07:55:11 <b0fh_ua> malcolmw: really, thanks
07:55:14 <b0fh_ua> so stupid
08:04:47 <adrianadshe> can someone please help a beginner in distress...
08:05:19 <holmak> sure, ask your question
08:05:25 <adrianadshe> I am trying simpleHTTP (getRequest uri) >>= getResponseBody >>= (writeFile "c:/file.tar.gz") on a windows system and the line endings are being converted
08:06:00 <holmak> You don't want the line endings to be converted?
08:06:05 <adrianadshe> firstly how can I force just binary writing with no conversion
08:06:21 <holmak> there should be a "binaryWriteFile" function
08:06:31 <holmak> or maybe "writeBinaryFile"
08:06:33 <adrianadshe> but more importantly where would I go to find out the answers myself.
08:06:39 <aavogt> you don't leave the simpleHTTP
08:06:39 <holmak> hoogle
08:07:30 <adrianadshe> Hoogle just seemed to point me back to hackage and the source
08:07:33 <aavogt> do your filewriting in the   ServerPartT IO a, with liftIO (writeFile "haha" content)
08:08:38 <betudeuce> i'm getting an error thats telling me that my "do" must end with an expression, which it does. Not sure why i'm getting an error: http://pastie.textmate.org/private/zjfnfzykz3ekhk0xb1hog
08:09:39 <holmak> betudeuce: It looks like line 14 should be indented; its not part of the do block as it is now.
08:09:59 <betudeuce> holmak: still get error
08:10:49 <xerox> it must be indented at the same level of "args <- .."
08:11:04 <betudeuce> oh
08:11:07 <betudeuce> k
08:11:08 <betudeuce> got it
08:11:09 <betudeuce> thnx
08:17:49 <betudeuce>  user error (Prelude.readIO: no parse)
08:18:23 <adrianadshe> is doing the file writing in the ServerPartT IO a with liftIO talking about using HApps? I was just using Network HTTP
08:20:12 <r2q2> I'm having a error when I install something from cabal
08:20:13 <r2q2> http://paste.lisp.org/display/93027
08:22:41 <r2q2> I don't understand because I have an x86-64 processor. Is it because I am using a binary?
08:24:28 <Baughn> r2q2: Are you by any chance on OS X?
08:24:40 <Baughn> Oh. Yes, you are.
08:25:58 <Baughn> r2q2: Which version of OS X is that?
08:26:48 <leimy> Probably Snow Leopard
08:26:54 <Baughn> Probably.
08:26:58 <leimy> that's the only one that gets really confused on 64bit stuff :-)
08:27:12 <leimy> It runs 64bit apps on a 32bit kernel
08:27:19 * Baughn shudders
08:27:23 <leimy> some people boot the 64bit kernel
08:27:34 <leimy> but many devices capable of running the 64bit version don't
08:27:39 <leimy> as they're just not supported by apple to do so yet
08:28:08 <leimy> Eh I'm running it right now.  And I've tried the 64bit kernel, basically no real difference on the desktop was noticed
08:28:48 <leimy> I won't migrate to 6.12 until haskell platform supports it :-)
08:29:28 <r2q2> Baughn 10.6
08:29:47 <r2q2> oh its a snow leopard problem
08:29:51 <Baughn> r2q2: I don't know what that means. You should probably talk to leimy; he seems to know what he's doing.
08:30:04 <leimy> r2q2: What version of GHC you got?
08:30:12 <Accidus> What's the difference between a reflection of an object B along a functor F and a universal arrow from B to F? Reflection along a functor as in definition 3.1.1 here:
08:30:17 <r2q2> leimy: Just upgraded to 6.12.1
08:30:20 <p_l_> leimy: actually, it's a 64bit kernel always, at least the most important partr. Nothing stops you froms switching modes in kernel-space
08:30:23 <r2q2> leimy: That error was on 6.10
08:30:24 <Accidus>  http://books.google.com/books?id=o5Do_Kl6xZUC&lpg=PA96&ots=_LmfTUMi8Z&dq=reflection%20along%20categories&pg=PA97#v=onepage&q=reflection%20along%20categories&f=false
08:30:28 <leimy> r2q2: I've never done that.
08:30:43 <leimy> p_l_: yes that's true, but it's not a fully 64bit kernel.
08:30:52 <Accidus> (a universal arrow is defined in Mac Lane's chapter 3)
08:30:54 <r2q2> Uh
08:31:07 <p_l_> leimy: people don't get that you can't call 32bit kernel from 64bit one and then I hear stuff like "32bit kernel running 64bit code".... urk, I wanna puke
08:31:17 <r2q2> I just upgraded to the latest ghc
08:31:33 <r2q2> i'm guessing that doesn't fix it either
08:31:37 <leimy> p_l_: the kernel has 64bit entry point, but many of the drivers are 32bit :-)
08:31:47 <Baughn> r2q2: Adds problems, more like. 6.12 isn't mature yet.
08:31:48 <pozic> p_l_: uhm, you can, just very slowly. :)
08:32:06 <leimy> and the system call speed is one of the benefits of going all 64bit
08:32:18 <leimy> so my guess is there's a cost for that conversion on entry :-)
08:32:19 <Baughn> r2q2: Though it's getting close, and I think the latest cabal-install tarball will work fine.
08:32:39 <leimy> r2q2: I have no experience at all with 6.12
08:32:40 <p_l_> pozic: you can't call into 32bit kernel other than have a 64bit task switching code and then switch to 32bit mode later.
08:32:57 <leimy> it's a matter of how the address spaces are mapped
08:33:09 <r2q2> Can't i just make mac os x boot into a 64 bit kernel
08:33:14 <leimy> if you make a call to read or write to a 64bit address, the kernel entry point has to know how to deal with it.
08:33:18 <leimy> r2q2: that won't fix your problem
08:33:24 <leimy> the 64bit runtime doesn't work on mac os x
08:33:28 <leimy> of GHC that is
08:33:38 <copumpkin> not yet
08:33:42 <leimy> so you have to make all the GHC scripts use -m32 to or something
08:33:46 <p_l> leimy: not exactly, it's more like 64bit mode has twice the amount of registers if not more, so switching task to 32bit kernel would cause massive breakage
08:33:46 <copumpkin> one of these days I'll stop being useless and port it
08:33:49 <leimy> there's stuff on the mailing list about it.
08:33:57 <copumpkin> leimy: in 6.12 you don't
08:34:13 <leimy> copumpkin: then I can't explain his problem.
08:34:18 <leimy> better off on haskell-cafe
08:34:23 <MbM313> SALaaaaaaaam  /  Hi / to all
08:34:31 <leimy> Someone else may have tried this but it isn't me :-)
08:34:55 <leimy> p_l: all it has to do is save the state of those registers man
08:35:10 <r2q2> I upgraded and now I get this error
08:35:11 <r2q2> ~ $ cabal upgrade
08:35:11 <r2q2> cabal: failed to parse output of 'ghc-pkg dump'
08:35:26 <leimy> weird
08:35:33 <Baughn> Upgraded to 6.12
08:35:35 <leimy> I think you have to upgrade cabal before going to 6.12
08:35:36 <p_l> leimy: yes, but it has to run 64bit to do that ;-) BTW, the 32bit drivers probably run as separate processes from the kernel... though they might run inside the same kernels space mapping and in Ring0
08:35:38 <Baughn> He needs to reinstall cabal-install
08:35:39 <pikhq> leimy: It also has to execute in long mode in order to do so.
08:35:48 <Baughn> leimy: No, after will do fine
08:35:53 <leimy> p_l:  That's not surprising either :-)
08:36:03 <leimy> We can get the source code, it's there :-)
08:36:08 <leimy> if anyone really wants to know
08:36:09 <pikhq> Mac OS runs 32-bit drives on a 64-bit kernel?
08:36:15 <leimy> we don't have to probably this or or that :-)
08:36:15 <pikhq> Yeah, probably using Mach for that.
08:36:17 <Baughn> r2q2: Anyway, grab the latest version of cabal-install from hackage, run the bootstrap script.
08:36:22 <p_l> leimy: well, OSX uses a descendant of the most heavyweight microkernel ever ;-)
08:36:29 <leimy> yep
08:36:42 <absentia> if you hold down 6 and 4 when booting, you get a 64bit kernel... of course, computers hate me.. when I held down 6 and 4, I got a 46bit kernel.  :-/
08:36:46 <r2q2> copumpkin: I like your blog.
08:36:48 <leimy> they took all of mach, messed with it, crammed BSD in there, and it's not a microkernel anymore :-)
08:36:52 <leimy> not even design wise.
08:36:54 <copumpkin> r2q2: I don't have a blog :o
08:36:58 <pikhq> leimy: Oh, it still is.
08:37:01 <leimy> not realy.
08:37:06 <leimy> it doesn't behave at all like one
08:37:07 <pikhq> It's just a microkernel being used to host BSD.
08:37:10 <pikhq> ... And nothing else.
08:37:11 <p_l> leimy: Mach already had BSD in it, they just upgraded parts
08:37:15 <leimy> it hosts BSD in the kenrel.
08:37:23 <leimy> Mach did not already have BSD in it.
08:37:28 <r2q2> copumpkin: Weird do you have a twitter?
08:37:29 <p_l> the only thing Apple actually changed is the IOKit framework
08:37:32 <pikhq> Mach also had Linux in it.
08:37:34 <leimy> There was a version of Mach that had BSD.
08:37:34 <copumpkin> r2q2: yep
08:37:40 <leimy> but that's not how Mach was designed to work
08:37:40 <r2q2> copumpkin: Yea thats what I meant.
08:37:41 <pozic> #macoswhatever?
08:37:43 <lunabot>  luna: A section must be enclosed in parentheses
08:37:47 <copumpkin> r2q2: oh ok :)
08:37:50 <leimy> if you want to see how mach was designed to work, go look at GNU Hurd :-)
08:37:52 <pikhq> (Linux 2.2's drivers)
08:38:05 <leimy> mach 2.5 had BSD in it, but mach 3.0 meant for the OS personalities to be implemented in user space.
08:38:16 <p_l> leimy: you mean that bad contraption of using a heavyweight kernel like it was microkernel? :)
08:38:22 <p_l> (Hurd)
08:38:25 <leimy> Yeah
08:38:30 <leimy> I used to run Hurd, in1998
08:38:37 <pikhq> Which, aside from the usage of multiple processes, and having a worse driver API, is much the same (from Mach's POV).
08:38:48 <leimy> it was a simple mach kernel, and all the unixy bits and device drivers (for the most part) were userland mach servers.
08:38:50 <r2q2> leimy: Same here haha (hurd).
08:39:17 <pikhq> leimy: Actually, GNU Mach has quite a bit of the device drivers in kernelspace.
08:39:20 <leimy> mach itself does not require BSD to live in kernel space with it.
08:39:29 <r2q2> leimy: I ran a posix compliance script and I emailed it to the list.
08:39:30 <leimy> pikhq: yeah, but that wasn't the goal :-)
08:39:33 <p_l> leimy: it had single "unix" process, basically destroying any improvement of microkernel. Somehow, the only succesful Mach/Unixes were the one that moved stuff back to kernel space
08:39:43 <leimy> yep
08:39:44 <leimy> that's very true
08:39:48 <pikhq> leimy: ... They didn't add this.
08:39:50 <pozic> leimy: why does SimpleAES exist? What is wrong with AES?
08:39:51 <leimy> however it's not fair to call xnu a microkernel.
08:39:55 <p_l> after all, a Mach task switch is more costly than NT
08:40:05 <r2q2> Hurd is a great idea of an operating system. Poor execution.
08:40:12 <leimy> Go check out L4 :-)
08:40:17 <pikhq> Well, yeah. XNU is Mach + BSD.
08:40:21 <leimy> much better implementations :-)
08:40:21 <r2q2> Yea I have heard of l4 l4 is interesting.
08:40:22 <betudeuce> is Parsec Haskell's very own lexer and parser generator? if it is, that is very neat.
08:40:25 <p_l> r2q2: it failed the moment they decided to use Mach
08:40:33 <leimy> There's OKL4
08:40:42 <r2q2> Hurd is like the duke nukem forever of operating systems.
08:40:43 <leimy> you can run linux on it, actually, you can run many linuxes on it.
08:40:48 <pozic> An operating system had to be fast. Security has only recently become somewhat of an issue and is only understood by a very small fraction of users.
08:41:06 <p_l> pikhq: Mach + BSD = OSF. XNU is just a variation based on old Mach-with-BSD + OSF code + NextSTEP specific code
08:41:17 <pikhq> Mmm.
08:41:31 <leimy> p_l: that's a really accurate comparison.
08:41:38 <leimy> many people didn't get that.
08:41:39 <r2q2> Oh come on I have to install parsec for cabal-install
08:41:39 <pikhq> r2q2: Except that the Hurd has actually released code to the public.
08:41:45 <leimy> you can still do microkernel things with mac os x.
08:41:45 <r2q2> pikhq: Yea.
08:41:53 <leimy> but it's not a microkernel in any pure sense of the form.
08:41:59 <pikhq> It's slightly less vaporware, by merit of existing.
08:42:03 <pikhq> (not usefully, but hey.)
08:42:04 <leimy> heh
08:42:11 <leimy> L4 exists, and runs in a lot of mobile phones
08:42:12 <p_l> btw, L4/Linux is actually faster than monolithic linux on Arm
08:42:16 <leimy> yep!
08:42:19 <leimy> that's exciting and weird.
08:42:34 <leimy> L4 has 7 system calls
08:42:35 <leimy> that's it.
08:42:38 <p_l> leimy: it uses very specialized codepath for task switching
08:42:45 <leimy> mach had like a jillion.
08:43:01 <leimy> p_l: task switching and L4 IPCs were like the  same thing
08:43:05 <leimy> because they're "register swaps"
08:43:06 <p_l> leimy: and had only one IPC path, the worst one regarding speed and efficiency
08:43:52 <r2q2> If I wipe all traces of haskell from my system and reinstall from the package will that fix it?
08:43:57 <leimy> Anyway, OKL4 is really neat.  They've got and open source implementation of Pistachio, that's been modified, and they support it commercially.
08:44:19 <p_l> L4 only implements the simplest&fastest one, while Spring had at least three specified, giving best performance depending on what kind of call you needed... Mach only used the one that is applicable to giant memory objects
08:44:22 <leimy> http://wiki.ok-labs.com/
08:44:41 <p_l> leimy: I'm planning to use L4 to write my own OS :D
08:44:42 <leimy> p_l: yeah, mach_msg is not the lightweight IPC you were looking for.
08:44:55 <leimy> p_l: there's a userspace version of Fiasco too
08:44:58 <leimy> it runs on linux
08:45:02 <leimy> Fiasco-UX I think
08:45:06 <leimy> you could prototype there.
08:45:19 <leimy> http://os.inf.tu-dresden.de/fiasco/ux/using.shtml
08:45:27 <leimy> L4 is so small that there's a lot of implementations :-)
08:45:35 <leimy> including one in Haskell I think.
08:46:08 <p_l> leimy: heh, I'm going to actually write one later, specialized for a cpu I'm building ;-)
08:46:10 <pikhq> And one formally verified by way of Haskell.
08:46:16 <leimy> p_l: that's awesome.
08:46:33 <leimy> p_l: You sound like my friend Steve :-)
08:46:50 <leimy> He's a friggin hardware/firmware genius
08:47:26 <leimy> the sort of fellow that could literally work anywhere.
08:47:30 <r2q2> Nevermind found a script
08:47:59 <p_l> leimy: I'm just starting out, though
08:48:09 <leimy> Well everyone has to start out :-)
08:48:30 <p_l> leimy: planning to build a machine from bottom up, and then put a Lisp-machine style system on top, except with runtimes for more languages
08:48:37 <leimy> ooh
08:48:40 <leimy> L4-Lisp!
08:48:41 <leimy> :-)
08:48:51 <p_l> (well, Genera supported Lisp, C, Fortran and Prolog...)
08:49:13 <pozic> leimy: what tools does Steve use?
08:49:21 <p_l> I'd like to have CL, Forth, Erlang and Haskell :D
08:49:38 <leimy> pozic: Tools?  He's a hardware guy at heart.
08:49:50 <leimy> but he knows his way around Keil's RTOS and VxWorks and stuff.
08:50:10 <leimy> he also knows more about power than anyone I know.
08:50:27 <pozic> leimy: well, those use soldering devices or lithos or something in the end.
08:50:50 <leimy> yeah, well given that I'm not a hardware guy, I'd have a hard time knowing exactly what it is he uses
08:50:58 <leimy> I wrote the software on his hardware's firmware :-)
08:51:09 <leimy> or rather "to" not "on"
08:51:27 <MbM313> ISLAM !UR Life right n Best future   www.turntoislam.com  www.sultan.org  www.raastenraah.com
08:51:39 <ahf> MbM313: shut up.
08:51:42 <anhe> what in the...
08:51:44 <pozic> leimy: unless you manually solder stuff, you are not a real hardware guy, I think.
08:51:48 <FreakyPenguin> What is the most elegant way to simplify filter a (filter b... ? Is there something better than filter (\x (a x) || (b x))?
08:51:48 <pozic> !OPS
08:51:54 <pozic> OPS
08:51:57 <pozic> @OPS
08:51:57 <lambdabot> Unknown command, try @list
08:52:24 <jmcarthur> FreakyPenguin: filter (liftA2 (||) a b)
08:52:44 <leimy> pozic: yeah he reworked some supermicro motherboards because they screwed up their layout to a high memory capacity board
08:52:45 <pozic> leimy: the trick in the hardware business is to be faster than everyone else, which is pretty much impossible without billions of dollars.
08:52:48 <FreakyPenguin> jmcarthur: thx ;-)
08:53:00 <leimy> and then he found out they're really low level firmware was broken too, and fixed that
08:53:09 <leimy> He used to make AMD motherboards :-)
08:53:13 <leimy> like, by himself.
08:53:21 <pozic> leimy: you mean repair?
08:53:21 <leimy> they had no graphics, but they were for compute :-)
08:53:22 <p_l> leimy: K7 ones, per chance?
08:53:24 <leimy> no I mean MAKE
08:53:36 <leimy> He could design a motherboard
08:53:52 <p_l> leimy: cause the chipsets used for Athlons could often run Alpha as well
08:53:52 <pozic> leimy: can you do that under a few thousand dollars?
08:54:10 <leimy> No, you need to sell them in really high volumes for it to make sense to do it.
08:54:13 <pozic> leimy: designing a motherboard is just a lot of work.
08:54:18 <leimy> luckilly he was rolling out HPC stuff for Cray at the time :-)
08:54:25 <leimy> it's a ton of work
08:54:27 <leimy> he likes it though.
08:54:32 <pozic> leimy: actually building the stuff to get a physical product is the hard part.
08:54:33 <MbM313> ISLAM !UR Life right n Best future   www.turntoislam.com  www.sultan.org  www.raastenraah.com
08:54:57 <r2q2> too many dependancies ;-(
08:55:01 <r2q2> going back to 6.10.1
08:55:03 <pozic> leimy: if you have all the infrastructure that modern companies have, it becomes easy again, of course ;)
08:55:13 <leimy> yeah.
08:55:20 <leimy> if you're small you have to partner
08:55:20 <pozic> leimy: for some value of "easy".
08:55:22 <Baughn> r2q2: Too many dependencies? For what?
08:56:02 * jmcarthur does not envy those whose package managers don't have cabal-install
08:56:07 <pozic> leimy: I would love to read stuff about people who build custom hardware for cheap.
08:56:08 <leimy> ah... I gotta get to work.
08:56:12 <r2q2> cabal-install
08:56:15 <Baughn> jmcarthur: bootstrap.sh works fine.
08:56:16 <leimy> pozic: I'm not sure this stuff was cheap :-)
08:56:18 <r2q2> it wants me to install parsec
08:56:21 <leimy> but it was pretty cool :-)
08:56:24 <Baughn> r2q2: And I told you to run the bootstrap script.
08:56:33 <leimy> Steve doesn't design cheap stuff, he designs robust stuff.
08:56:34 <r2q2> yea i ran the bootstrap script it doesn't work
08:56:37 <jmcarthur> Baughn: but it's still more hassle than "pacman -S cabal-install" ;)
08:56:47 <pozic> leimy: so, who pays so much to get a slightly better motherboard?
08:56:48 <leimy> as a result it costs more than off the shelf, but it's usually correct in a few spins :-)
08:56:51 <Baughn> jmcarthur: But pacman -S cabal-install /doesn't work/
08:56:54 <Baughn> r2q2: How so?
08:57:00 <leimy> pozic: like I said it's a volume/density thing, not necessarily a price thing
08:57:11 <leimy> so if you can cram a lot of compute into a small space, that was good for HPC.
08:57:13 <jmcarthur> Baughn: yes it does...
08:57:18 <leimy> we're talking like top500 list stuff.
08:57:20 <Baughn> Not on 6.12, it doesn't
08:57:30 <leimy> anyway, I really have to get to work
08:57:31 <leimy> ttyl!
08:57:32 <pozic> leimy: ok, cool.
08:57:33 <r2q2> http://paste.lisp.org/display/93027#2
08:57:46 <jmcarthur> Baughn: oh, no, but 6.12 isn't yet intended to actually be in distro repos, is it?
08:58:05 <Baughn> r2q2: That's.. 0.6.2?
08:58:05 <jmcarthur> Baughn: i didn't realize the problem was about 6.12
08:58:11 <Baughn> r2q2: The newest version is /0.8/!
08:58:25 <r2q2> oh
08:58:51 <Baughn> r2q2: Not much point in recompiling the same version that you already knew doesn't work, too.
08:59:07 <r2q2> Oops http://hackage.haskell.org/trac/hackage/wiki/CabalInstall was the firsthit on google
09:00:40 <Baughn> r2q2: Pity. You want this one: http://hackage.haskell.org/package/cabal-install
09:00:48 <r2q2> Yea I got it thanks
09:01:02 <r2q2> Now I know lots more about haskell packaging at least
09:01:49 <r2q2> Thanks for everyone's help today. Everyone here was really nice.
09:05:44 <maartenm> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15631#a15631
09:05:50 <maartenm> my code is running horribly inefficiently
09:06:05 <maartenm> it ran for 48 hours on mandelbrot 1000 2000 without result
09:06:27 <maartenm> I have a feeling the functions in the "let" are not calculated lazily but stricted.. is that one of its problems?
09:06:39 <maartenm> save_ppm isn't an issue, that goes fairly quickly..
09:09:30 <pozic> maartenm: that is not a self-contained example.
09:10:11 <pozic> maartenm: that is, you have not defined what you inputted.
09:10:24 <maartenm> 1000 1000
09:10:44 <maartenm> I am re-writing it now with a shorter "let" and an extra function which defines all the non-input things as where
09:10:58 <pozic> maartenm: but let is lazy.
09:11:02 <maartenm> yeah I know
09:11:12 <maartenm> but there is one thing I don't understand
09:11:24 <maartenm> the program calculates, for some time.. (on smaller inputs)
09:11:30 <maartenm> but I notice the ppm isn't being touched
09:11:35 <maartenm> until the "save_ppm" call is made
09:11:38 <pozic> maartenm: you do some things in a quite stupid way, btw.
09:11:39 <maartenm> which indicated strictness
09:11:53 <maartenm> stupid? that's impossible :)
09:11:54 <pozic> maartenm: calculating sqrt is a fairly stupid thing to do for example.
09:11:56 <r2q2> Weird I ran bootstrap.sh with cabal0.8.0 and it still gives me the error failed to parse output of 'ghc-pkg dump'
09:12:11 <maartenm> I don't calculate sqrt
09:12:17 <pozic> maartenm: yes, you do.
09:12:18 <maartenm> that function isn't used
09:12:40 <pozic> maartenm: right, you don't.
09:12:46 <pozic> maartenm: then don't paste that next time.
09:12:51 <maartenm> yeah sorry
09:13:18 <maartenm> I just got home from work and got a little hotheaded when I noticed the program wasn't finished yet, I thought I'd ask the channel for help
09:13:27 <maartenm> shoudl've been neater.. but all the rest is called
09:13:30 <pozic> maartenm: anyway, it are the usual things probably. Profile the code and see it.
09:13:47 <pozic> maartenm: e.g. lists which are constructed when you don't want them to be constructed.
09:14:12 <maartenm> does the strictness come from UArray?
09:14:12 <jmcarthur> i find the code a bit too hard to follow for me to diagnose efficiently
09:14:18 <pozic> maartenm: compiling with optimization, doing to much work (e.g. look at how an optimized C version works).
09:14:31 <pozic> too*
09:16:25 <maartenm> jmcarthur: I pasted a slightly cleaner version at http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15631#a15632
09:18:02 <maartenm> I compiled it with O2 and it's just as slow.. I'll check out profiling
09:18:07 <maartenm> I never profiled haskell before
09:18:32 <dmhouse> ?google real world haskell profiling
09:18:33 <lambdabot> http://book.realworldhaskell.org/read/profiling-and-optimization.html
09:18:33 <lambdabot> Title: Chapter 25. Profiling and optimization
09:18:42 <dmhouse> maartenm: take a look at that. It's not very hard.
09:19:08 <r2q2> Can I just manually install stuff from cabal?
09:19:09 <maartenm> wow RWH has a chapter
09:19:15 <r2q2> i mean hackagedb.
09:19:33 <damd> r2q2: yes, you can
09:19:44 <dmhouse> Two line summary: compile like ghc --make -prof -auto-all -caf-all, then run with ./your-prog +RTS -p and check your-prog.prof
09:19:44 <damd> just download the tar-ball, unpack it and follow the instructions
09:19:46 <mreh> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15634#a15634 -- could someone please try and work out what I'm missing, i've been starting at this for 10 minutes
09:20:35 <thaldyron> If module Foo.Bar is exported by 2 packages that I use, how is it possible to distinguish which Foo.Bar is imported?
09:20:57 <mreh> I've just realised what the problem is
09:21:06 <maartenm> thaldyron: use the "as" syntax ?
09:21:08 <mreh> feel free to point and laugh if you've spotted it
09:21:42 * dmhouse points and laughs at mreh
09:21:47 <mreh> no wait, i haven't spotted it actually
09:21:48 <mreh> so HA!
09:21:53 <dmhouse> Damnit!
09:22:07 <dmhouse> Okay, the result type for mixN' is a list
09:22:28 <dmhouse> So the `do' block in the first equation for mixN' is in the list monad
09:22:37 <thaldyron> maartenm: But if I write "import Foo.Bar as PkgA.Bar" I still don't know whether it's taken from package A or B, right?
09:22:40 <dmhouse> But randomPerm is in the Rand g monad
09:23:15 * mreh shoots himself
09:23:31 <mreh> ghc can be so cryptic with the errors, especially when you skimp on the type signatures
09:24:05 <oteren> indeed, haskell would be so much better with some sort of modern IDe
09:24:07 <oteren> *IDE
09:24:15 <oteren> or at least real compile errors
09:24:19 <mreh> I even stuck a return in the co-recursive method because of the type check error
09:24:20 <maartenm> thaldyron: sorry I shoudln't answer your question
09:24:47 <maartenm> dmhouse: I have a certain package included, a cabal install (Data.List.Split), which doesn't have any profiling
09:24:59 <mreh> it must have been thinking I was binding in List monad
09:25:05 <maartenm> can I exclude that package when compiling with profiling and including all?
09:25:24 <dmhouse> maartenm: I think you can recompile it to use profiling if you wanted to do that
09:25:30 <dmhouse> ?google haskellwiki profiling
09:25:32 <lambdabot> http://www.haskell.org/haskellwiki/Performance
09:25:32 <lambdabot> Title: Performance - HaskellWiki
09:25:32 <maartenm> using cabal?
09:25:44 <dmhouse> ?google haskellwiki how to profile a haskell applicatoin
09:25:46 <lambdabot> http://www.haskell.org/haskellwiki/Hp2any
09:25:46 <lambdabot> Title: Hp2any - HaskellWiki
09:25:49 <dmhouse> ?google haskellwiki how to profile a haskell application
09:25:50 <lambdabot> http://www.haskell.org/haskellwiki/Xmonad/Using_xmonad_on_Apple_OSX
09:25:50 <lambdabot> Title: Xmonad/Using xmonad on Apple OSX - HaskellWiki
09:26:25 <dmhouse> maartenm: yeah, http://haskell.org/haskellwiki/How_to_profile_a_Haskell_program#Enable_profiling_on_libraries
09:26:30 <mreh> :t liftM2
09:26:31 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
09:26:38 <mreh> :t liftM
09:26:39 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
09:27:15 <mreh> @src liftM2
09:27:16 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
09:27:18 <mreh> @src liftM
09:27:19 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
09:27:32 <mreh> simples
09:27:38 <dmhouse> maartenm: looks like http://haskell.org/haskellwiki/Performance/GHC will also be helpful
09:27:48 <maartenm> ok, thanks!
09:29:40 <copumpkin> preflex: seen conal
09:29:40 <preflex>  conal was last seen on #haskell 15 hours, 58 minutes and 22 seconds ago, saying: jzleibo: daan built wxhaskell on top of the eiffel bindings machinery
09:35:11 <r2q2> yay cabal works.
09:38:22 <jmcarthur> yay!
09:39:43 <koeien37> a translation of RWH in Japanese :|
09:40:30 <copumpkin> ã©ã“ï¼Ÿ
09:40:58 <koeien37> I don't speak japanese. It wouldn't be the first language to come to mind to translate to, but maybe I'm wrong
09:42:37 <mreh> I think i've found fail in GHC, I have a function that executes once, then blocks idefinitely when I try again after that, and after I kill the process GHCi keeps all the memory
09:43:32 <koeien37> interesting. no unsafePerformIO involved?
09:43:44 <koeien37> and GHCi keeping all the memory is a bug in your OS, if you have killed the process
09:43:51 <Stalafin>  /join usp
09:44:01 <copumpkin> ghci always keeps all the memory
09:44:10 <koeien37> not if you kill the process, right?
09:44:12 <copumpkin> the ghc runtime never releases memory to the OS
09:44:16 <copumpkin> oh yeah, obviously :)
09:44:18 <koeien37> if you CTRL+C it, then yes
09:45:00 <mreh> koeien37, no unsafePerformIO, but using evalRandIO
09:45:10 <koeien37> oh
09:45:16 <koeien37> maybe your entropy pool is empty?
09:45:33 <mreh> i have an entropy pool?
09:45:38 <dmhouse> mreh: can you paste a minimal example?
09:45:40 <jzleibo> what?
09:45:46 <jzleibo> why is my name there?
09:45:47 <koeien37> the OS has one, probably. Depends what your source of randomness is
09:46:00 <mreh> dmhouse: it's the code i was just debugging
09:46:12 <koeien37> can you reproduce it?
09:46:21 <dmhouse> jzleibo: copumpkin asked preflex where conal was, and he was last seen talking to you
09:46:38 * copumpkin whistles innocently
09:46:59 <dmhouse> mreh: can you reduce it to a minimal example, and paste that?
09:47:12 <mreh> dmhouse, i'll try
09:48:05 <mreh> it appears its an O/S bug
09:48:15 <mreh> it happens for any evalRandIO I try
09:48:24 <koeien37> good. can you paste it?
09:48:37 <copumpkin> what's evalRandIO?
09:48:47 <mreh> Control.Monad.Random.evalRandIO
09:48:52 <copumpkin> if it's attempting to read from /dev/random it will block
09:49:25 <jzleibo> ah
09:50:54 <mreh> 1) beging GHCi from the command line 2) type "m: Control.Monad.Random" 3) type "evalRandIO $ getRandomR (1,6)
09:51:00 <mreh> something like that does it
09:51:31 <dmhouse> Surely that won't consume very much memory
09:52:01 <HaskellLove> I am sorry for the general question. What do you computer science guys read? What are the last cool books you have read cs related, not just the technical stuff from college.
09:52:05 <mreh> it consumes <100mb at a time
09:52:20 <mreh> HaskellLove: we are not "cool"
09:52:30 <koeien37> HaskellLove: I liked 'Algorithmics, the spirit of computing'. Pretty gentle introduction to computability
09:52:49 <HaskellLove> thanks
09:52:51 <mreh> i meant to say: it consumes >100mb at a time
09:54:26 <mreh> has anyone replicated the problem?
09:55:03 <dmhouse> mreh: what package is Control.Monad.Random in? My ghci can't find it
09:55:43 <mreh> dmhouse: MonadRandom
09:56:03 <mreh> I'm hoping it's just evalRandomIO
09:56:31 * dmhouse doesn't have MonadRandom and backs out
09:56:34 * koeien37 gets a '1' immediately
09:56:39 <koeien37> probably your lack of entropy
09:57:04 <mreh> koeien37, did you try several times?
09:58:26 <Twey> That's the thing about randomnessâ€¦
09:58:40 <Twey> â€¦ nine â€¦ nine â€¦ nine â€¦ nine â€¦
09:58:44 <zygoloid> mreh: works fine here
09:58:55 <koeien37> yes, i've done a few hundred thousand dice rolls now
09:58:57 <mreh> hmmm, the function I've written actually starts this "lack of entropy" off
09:59:15 <mreh> i'll investigate
09:59:45 <zygoloid> mreh: here, i've generated you some entropy: [1,2,6,3,3,3,1,3,6,5,2,5,2,6,5,4,1,6,1,5,5,3,2,4,6,1,3,1,4,4,6,1,2,5,6,3,2,1,4,4,5,3,6,4,4,1,2,6,1,1]
10:00:00 <Botje_> zygoloid: .. but i eated it? :)
10:00:49 <jetxee> Hi guys, does anyone else think, that Batteries of the Haskell platform are inserted with wrong orientation? http://haskell.org/sitewiki/images/thumb/7/7d/Platform.png/300px-Platform.png At least one of them...
10:00:54 <zygoloid> mreh: i generated you some entropees: [1,1,1,1,1,1,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,6] ... but i sorted it
10:01:30 <koeien37> jetxee: my charger has this orientation
10:02:05 <periodic> Indeed, the alternating directions thing is mostly just lazy wiring.
10:02:28 <Stalafin> periodic: which would suit the idea of haskell perfectly
10:02:31 <Stalafin> periodic: ... lazy ... :)
10:02:33 <periodic> But in haskell it's easy! Just apply a "flip"
10:03:00 <Botje_> zygoloid++ # praise the sorter!
10:03:04 <Stalafin> nah, if you apply a flip onto the 2 batteries, they are just exchanged
10:03:04 <koeien37> so it depends, do you want to see programming Haskell as an energy draining activity?
10:03:16 <jetxee> koeien37: Charger ? yes. But in all gadgets I own batteries are inserted with different orrientation.
10:03:48 <koeien37> i like to see Haskell as a source for more energy :)
10:04:06 <jaspervdj> copumpkin: are you around?
10:04:22 <copumpkin> yep
10:04:37 <jaspervdj> copumpkin: I've been thinking about your "Haskell downvoters" question today and talking to some reddit people
10:04:39 <jetxee> Stalafin: Usually two batteries are inserted in two opposite orientations so that one's plus is touches the same plate as the the other's minus...
10:05:08 <jaspervdj> There are in fact two main reasons
10:05:19 <zygoloid> Stalafin: it depends whether you want more voltage or more current
10:05:33 <jaspervdj> One is they downvote articles in general because they want their own articles higher
10:05:44 <copumpkin> jaspervdj: oh? I ended up deleting the post anyway, but what did they say?
10:06:04 <jaspervdj> Haskell articles often have /complicated names/, so people tend to pick them when downvoting random articles
10:06:13 <jetxee> My point is that batteries should stay in different orientations (one with plus downwards, the other with plus upwards).
10:06:14 <zygoloid> s/Stalafin/jetxee/
10:06:28 <jaspervdj> secondly, a lot of people think haskell *is* overrepresented in r/programming
10:06:35 <koeien37> so Haskell gives you more current?
10:06:48 <jaspervdj> which is mainly because reddit is very popular under haskellers, I suppose
10:06:50 <jetxee> zygoloid: I see your point. Good. More current.
10:06:51 <koeien37> jaspervdj: i think i can partially agree with that last sentiment.
10:07:12 <mreh> it's not just blocking on IO, it's eating memory and using loads of flops
10:07:20 <koeien37> although the quality of proggit isn't too high on average IMO
10:07:37 <koeien37> mreh: I can't reproduce it. Do you have the last version of MonadRandom ?
10:07:47 <jaspervdj> It's basically because 90% from the haskell community is on r/haskell, and 90% of those crosspost to r/programming as well
10:07:58 <jaspervdj> those numbers are probably smaller in other communities
10:08:14 <jaspervdj> But I do not think we should care or adapt because of this
10:13:12 <sshc> how do I read and write a floating point number in a file?
10:13:27 <sshc> how does Frag read bsp files?
10:13:28 <koeien37> what representation? Normally I'd just use read & show
10:13:34 * hackagebot upload: darcs-beta 2.3.98.1 - a distributed, interactive, smart revision control system (ReinierLamers)
10:13:37 <koeien37> > read "3.14159" :: Double
10:13:38 <lambdabot>   3.14159
10:13:56 <sshc> koeien37: for speed and efficiency reasaons, a binary representation
10:13:57 <koeien37> darcs is Cabalized now? cool
10:14:36 <sshc> how do I do this?
10:14:51 <koeien37> do you have to read others' files, or just your own?
10:14:56 <koeien37> Data.Binary would be a good choice.
10:15:02 <sshc> koeien37: others'
10:16:10 <koeien37> then you would have to know the specification
10:16:14 <koeien37> try Data.Binary
10:16:20 <periodic> On the reddit subject, wasn't reddit originally very heavy on python due to the preferences of the founders?  I think almost any community will be biased unless you somehow get every possible sub-community on there.
10:16:55 <periodic> Seems silly to complain about it.  I just have to gloss over all these lisp posts that any community with an academic bent will have. :)
10:17:13 <jmcarthur> i think it's unfair for people to expect a social networking site to be unbiased
10:17:15 <koeien37> Haskell is not really dominating, no
10:17:26 <koeien37> web development in general is probably overrepresented, too
10:17:32 <sshc> koeien37: is that a hackage package?
10:17:48 <koeien37> binary is the package
10:18:06 <sshc> thanks
10:18:54 <koeien37> I'm not sure which representation is used for Doubles
10:22:12 <sshc> koeien37: does that package use binary representation or textual representation?
10:22:25 <sshc> koeien37:
10:22:26 <koeien37> binary. What textual representation did you have in mind?
10:22:47 <sshc> koeien37: I didn't have any textual representation
10:22:49 <sshc> in mind
10:22:56 <sproingie> koeien37: haskell dominates on h.r.o :)
10:23:04 <sproingie> er h.r.c
10:23:37 <shambler> what's that
10:23:39 <sproingie> looks like reddit.org is a domain squatter
10:23:41 <sshc> how does Frag read and write values to .bsp files?
10:23:56 <sproingie> sshc: cabal unpack frag and see for yourself
10:24:10 <sshc> sproingie: where will cabal put frag if I do that?
10:24:12 <sproingie> the AFRP stuff in frag is dense, the rest of it is quite readable
10:24:15 <koeien37> .
10:24:16 <sproingie> sshc: in the current directory
10:25:09 <sproingie> don't think it compiles in recent haskell versions, but you shouldn't need to
10:25:26 <sshc> is there a cabal command to update all of the packages?
10:25:48 <sproingie> there was, i think it's been disabled
10:25:54 <sshc> sproingie: why?
10:26:01 <sshc> is it cabal upgrde?
10:26:06 <sproingie> it spits a big scary warning at you telling you why
10:26:16 <sproingie> maybe it's forceable, i don't recall
10:26:55 <jetxee> Again about the batteries of Haskell Platform... If they are in parallel for more current (less voltage), is Haskell Platform designed for low resistance applications aka short-circuit evaluation? It sounds consistent.
10:27:51 <sproingie> short-circuiting is a built-in consequence of laziness, requiring no special support like other languages do
10:29:01 <sshc> how good is perfomance of darcrs?
10:29:04 <sshc> compared to git?
10:29:04 <sproingie> poor
10:29:11 <sproingie> compared to git, extremely poor
10:29:22 <jmcarthur> not as bad as it used to be by any stretch
10:29:34 <sproingie> checking out a new repo is still pretty glacial
10:29:48 <sproingie> or i should say, new checkout of an old repo
10:29:49 <jmcarthur> i switched from git to darcs once darcs got some optimizations and i can't really observe anything too time consuming
10:29:59 <jmcarthur> besides "darcs pull" for a large repository
10:30:09 <jmcarthur> *a large remote repository
10:30:11 <koeien37> I am not experienced with hg, but I find darcs pretty slow
10:30:30 <jetxee> jmcarthur: how much is "large"?
10:30:31 <koeien37> correction: I am more experienced with hg (no git experience), but I find darcs pretty slow
10:30:44 <koeien37> I prefer hg now
10:31:16 <jmcarthur> jetxee: i don't know. i'm not one for counting patches
10:31:23 <jmcarthur> jetxee: ghc is the only one that annoys me
10:32:01 <jmcarthur> jetxee: pulling ghc takes significantly longer than pulling the linux kernel, even though i'm pretty sure the linux kernel has a lot more patches
10:34:20 <jmcarthur> but really, for the most common operations i've never, ever been frustrated
10:34:52 <jmcarthur> i've heard that putting binaries into a darcs repo makes it cry, though
10:39:17 <dino-> In System.Directory.Permissions, what does searchable mean? (how does it differ from readable?)
10:41:32 <sproingie> dino-: probably the 'x' bit in unix
10:42:52 <doserj> http://www.haskell.org/ghc/docs/6.10.4/html/libraries/directory/System-Directory.html#5 seems to agree
10:44:08 <harrisonpartch> there is no longer a channel for "yi"
10:47:11 <dino-> Strange that the type has both executable (for files) and searchable (for dirs) given that the same flag is used for both in the filesystem.
10:47:25 <dino-> But does save you the trouble of checking if it's a file or dir first.
10:47:58 <roconnor> is a heyting algebra a distributive lattice?
10:48:05 <dino-> Thank you
10:48:43 <doserj> roconnor: yes
10:48:54 <roconnor> doserj: really?
10:49:59 <roconnor> ah
10:50:10 <roconnor> wikipedia agrees with you
10:50:16 <roconnor> so wikipedia must be right then
10:50:43 <doserj> non sequitur :)
10:55:59 <harrisonpartch> Are you a heyter then? Shame!
11:00:16 <roconnor> groan
11:02:11 <dhun> I got the very wired idea of wanting to buy "Haskell Functional Underwear", but nobody seems sell it. I think it would fit well to the "avoid success at all costs" style
11:03:20 <mental> dhun: you don't need to change it until you actually shit your pants?
11:03:57 <roconnor> where is all the swag with the new logo?
11:04:04 <roconnor> I couldn't find any on cafepress
11:04:16 <dhun> I don't know. It is cool that nobody sees the logo on the underwear until s/he is in your bedroom
11:04:51 <shepheb> hackage down?
11:05:24 <gsan> I guess it's down...
11:06:03 <shepheb> curses, I wanted to look up matrix libraries.
11:06:06 <djahandarie> Nothing would be better than realizing that your girlfriend of 2 months is into functional programming.
11:06:34 <elly> djahandarie: my boyfriend wasn't surprised :P
11:06:34 <sinelaw> or owrse
11:07:26 <gsan> shepheb: I'm using the google cache :-/
11:07:55 <lpsmith> roconnor:  studying the connections between lattices and algebra?
11:08:35 <shepheb> got a class in which I'm free to use any language, but it's matrix-heavy.
11:08:52 <sinelaw> does it make any sense that after scaling an image primitive, transformation on it is in scaled coordinates?
11:08:57 <roconnor> lpsmith: I'm trying to map out the heirarchy of types of lattices
11:09:26 <sinelaw> translation i meant
11:09:47 <lpsmith> roconnor:  Sounds more fun than trying to understand Visual Studio :-P
11:12:02 <copumpkin_> yay conal
11:12:06 <EvanCarroll> hahahah
11:13:02 <conal> copumpkin: :)
11:13:04 <lambdabot> conal: You have 1 new message. '/msg lambdabot @messages' to read it.
11:13:40 <maartenm> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15636#a15636
11:13:43 <maartenm> I profiled my app
11:13:45 <conal> oh yeah: http://conal.net/blog/posts/can-functional-programming-be-liberated-from-the-von-neumann-paradigm/
11:13:56 <maartenm> am I .. eh to understand that 5Gb of space is allocated?
11:14:02 <conal> might interest some folks here :)
11:14:18 <maartenm> and that buddhabrot function is entered 25 million times?
11:14:47 <monochrom> sinelaw: You mean this? My imagine is initially a disc at centre (0,0) radius 10. I scale it to radius 20. Then I move it right by 10, I get disc centred at (10,0) radius 20.
11:14:47 <sinelaw> conal, you seem pretty busy!
11:14:48 <elly> 'total alloc' doesn't account for frees, I think
11:15:15 <maartenm> ok
11:15:15 <copumpkin> conal: that's what I was yay'ing about :)
11:15:17 <sinelaw> monochrom, that's exactly what happens with luqui's updated version of graphics-drawingcombinators. i found the source of the problem, if it is one
11:15:34 <maartenm> I'll see if I can make the profile more detailed
11:15:38 <sinelaw> monochrom, doesn't make sense to me, to do it that way
11:15:50 <conal> sinelaw: yeah.  i guess i've had a lot of blog posts piling up in my head.
11:15:53 <monochrom> sinelaw: I see no problem. I expect to get disc centred at (10,0) radius 20.
11:16:23 <sinelaw> monochrom, oh i misread your message!
11:16:33 <monochrom> I really do. I took two graphics courses and this is what I expect and this is what is taught too. Three perspectives agreeing independently.
11:17:08 <sinelaw> monochrom, i didn't read through the numbers in what you just said :) what happens (and what i thought you wrote) is not what you wrote
11:17:18 <monochrom> OK.
11:17:26 <sinelaw> monochrom, what happens is you get a disc centered at (20,0)
11:17:29 <EvanCarroll> I tried to explain Maybe and Just on stackoverflow in a humerious fashion I'm amused.
11:17:34 <sinelaw> because the "right by 10" gets scaled too
11:17:48 <sinelaw> it's a bug
11:17:50 <copumpkin> sinelaw: you scale before shifting
11:17:51 <copumpkin> oh
11:18:05 <jmcarthur> conal: oh sweet, glad to see this topic brought up
11:18:06 <sinelaw> at least i think it is...i don't think that was his intention
11:18:24 <monochrom> This is why I don't use words. I use either example numbers or formulas.
11:18:26 <chrisdone> EvanCarroll: can I see?
11:18:31 <EvanCarroll> yea
11:18:57 <EvanCarroll> I don't want this to get taken out of hand though, it is intended to be more humerious than instructive, and it really did authentically confuse me for a solid day
11:18:59 <sinelaw> monochrom, sorry i was quick on the trigger
11:19:00 <EvanCarroll> Haskell's use of Maybe and Just. Maybe a is a type constructor that returns a type of Just a, but Maybe Int won't accept just an Int, it requires it to be a Just Int or Nothing. So in essence in haskell parlance Just Int is about as much of an Int is an apple is an orange. The only connection is that Just 5 returns a type of Maybe Interger, which can be constructed with the function Just and an Integer argument. This makes sense but is about as hard t
11:19:32 <harrisonpartch> oh graphics talk good. why does the cabal "frag" compile with errors? cannot anyone be bothered with grooming the code so it does not ro?
11:19:36 <harrisonpartch> rot?
11:19:37 <jmcarthur> "I look at monadic IO not as any solution to functional I/O, but rather as a (clever) way not to bring I/O into the functional world."  -- well phrased
11:19:50 <sinelaw> harrisonpartch, take the darcs version
11:20:00 <chrisdone> jmcarthur: nice
11:20:15 <conal> :)
11:20:20 <jmcarthur> chrisdone: it's conal's: http://conal.net/blog/posts/can-functional-programming-be-liberated-from-the-von-neumann-paradigm/
11:20:30 <sinelaw> though monadic IO kept the rest of haskell pure, allowing us to keep thinking purely
11:20:31 <harrisonpartch> k good idea. however i have tried this darcs as opposed to cabal approach with "yi" and it does not help.
11:20:47 <sinelaw> harrisonpartch, do you know what darcs is?
11:20:47 <conal> sinelaw: keep thinking purely about parts of our programs
11:20:57 <koeien37> why is the IO monad impure?
11:21:08 <jmcarthur> sinelaw: monadic IO allows software engineers to get things done and allows researchers to declare it "solved"
11:21:11 <conal> koeien: semantics
11:21:17 <jmcarthur> koeien37: it's not. it's just not declarative
11:21:19 <sc``> Hi, how do I 19:19 *** NAMES sc`` hgolden kakeman_ IceDane otulp jimmyjazz14 maartenm J-Mad osaunders edwardk_ CosmicRay mattrepl Alpounet saterus tredontho scree alexsuraci oubiwann andrewe mreh_ Stefan copumpkin nniro monochrom mun_ gniourf_gniourf_ [stoop] phaer Mowah sinelaw cying And[y] spaceodyssey mm_freak_ StoneToad bos Rotaerk DekuNut kmc Trafalgard mfk stevenyvr amiri harrisonpartch comak njbartlett shamble
11:21:19 <sc``> r Raynes erg0t shaleny pantsman ToRA jrib ttt-- jetxee  c_wraith arjanb path[l] QplQyer larrytheliquid erikc dolio deso ketil koeien37 ulfdoz conal gio12345 effigies danly iblechbot RageOfThou blastbeat1 gonsor visof aconbere jzleibo nerfquark boscop napsy jmelesky mmaruseacph2 ehird trie perspectival Saizan kloeri abbe brh miguel-hs irc2samus jystic lsthemes doserj meanburrito920_ dmhouse joe5 gbeshers fredcy holmak
11:21:19 <sc``>  RichardO damd SyntaxNinja Stalafin THC4k nathanic FreakyPenguin lispy oteren  bo0ts__ yibter Nshag jims roconnor gehmehgeh sioraiocht danvet hugod lurkymclurkleton snhmib Icewing lars_t_ arsenm gsan macron reprore ttmrichter ts33kr portnov rrice Zr40 Asztal hrehf dpratt71 Yogsothon jethomas EEEuler eagletmt Eghie lpsmith aluink aeter ddvlad Accidus Ytinasni paulvisschers kqrx HugoDaniel xinming eelco_ hda5 dfeuer no
11:21:23 <koeien37> and if it is, can somebody point me to a paper explaining the difference between "pure" and "impure", because I haven't seen a precise definition
11:21:29 <Trafalgard> what what?
11:21:31 <Rotaerk> ..
11:21:32 <ehird> ugh
11:21:33 <harrisonpartch> yes, I do, darcs is a distributed bersion control system roughtly analogous to cvs, svn, mercury, git, etc
11:21:36 <copumpkin> nice
11:21:36 <harrisonpartch> version
11:21:39 <ehird> someone bludgeon sc`` to death for me
11:21:40 <ehird> thank you
11:21:41 <jrib> :/
11:21:53 <Trafalgard> I think the server already did it for you
11:21:55 <harrisonpartch> and i have the latest darcs. 2.3.1 i think
11:21:55 <copumpkin> koeien37: I don't think there is one
11:21:58 <pikhq> koeien37: "Purely functional" means no side effects.
11:22:00 <pantsman> I thought someone loved me :(
11:22:00 <koeien37> darcs is distributed! cvs/svn isn't
11:22:00 <SyntaxNinja> Hey everyone!
11:22:06 <copumpkin> koeien37: pure with respect to value, maybe
11:22:14 <scree_> ga if anyone replied to my question in the last 5 minutes I didn't hear
11:22:16 <SyntaxNinja> I saw my name mentioned for like the first time in ages and got excited. Damn sc-dude.
11:22:18 <pikhq> It's a slightly informal notion. :P
11:22:28 <koeien37> pikhq: on my computer foldl (+) 0 [1..10^7] worked, but not on my neighbors computer. Is haskell impure now?
11:22:34 <harrisonpartch> you can look up "roughly" online koeien. google is our friend.
11:22:48 <copumpkin> koeien37: don't even get me started on numCapabilities
11:22:49 <sinelaw> conal, i mean in general. we use that "sin bin" but we like to still think purely when we can. if it weren't for a good intermediate solution (monadic IO) we would have to poison the semantically pure part too,  drifting even further away from what we need
11:22:53 <scree_> internet death
11:22:59 <edwardk_> SyntaxNinja: we still love you, man.
11:23:26 <conal> koeien: some of the terms used aren't precise, including "pure", "functional", "declarative", and "referentially transparent".  so i've been pushing for more precise & specific notions and more to the heart of things, rather than "merely technical".   see http://conal.net/blog/posts/notions-of-purity-in-haskell/
11:23:26 <pikhq> koeien37: No.
11:23:46 <sinelaw> harrisonpartch, the version of any program on hackage is not necessarily the latest head on its version control, darcs or otherwise
11:23:49 <pikhq> You're merely failing to use a Turing-equivalent machine.
11:23:50 <koeien37> conal: yeah i noticed your "C is pure!"-post :)
11:23:57 <conal> sinelaw: we would have to?  i'm not so sure.
11:23:59 <sinelaw> so, having a bad experience with Yi says nothing abuot other programs
11:24:01 <copumpkin> haskell isn't pure if you consider execution time :P
11:24:05 <koeien37> pikhq: there do not exist turing machines in the "real world"
11:24:09 <copumpkin> or memory behavior
11:24:14 <copumpkin> or a whole bunch of other things
11:24:16 <pikhq> koeien37: Quite true.
11:24:18 <ehird> koeien37: irrelevant
11:24:20 <sinelaw> conal, ok, not _have_ to, but that is what happened in some other languages
11:24:25 <pikhq> However, Haskell describes a Turing-equivalent system.
11:24:29 <sinelaw> so less people are thinking purely
11:24:30 <ehird> koeien37: haskell is defined as if on a turing machine
11:24:32 <copumpkin> I'd like a side-channel pure language to write crypto iin
11:24:33 <conal> sinelaw: yes indeed.
11:24:36 <jmcarthur> copumpkin: it's pure if those ideas don't exist in the semantic domain
11:24:38 <pikhq> You're bound to have failure when running it on something that's not Turing-equivalent.
11:24:40 <ehird> any implementation limitation is just that
11:24:45 <ehird> a failure to implement Haskell
11:24:53 <pikhq> Assuming that you go beyond the limits, that is.
11:24:57 <copumpkin> jmcarthur: yeah, basically "it's pure if we define purity to not include those"
11:24:59 <sinelaw> conal, so monadic io is perhaps like a life-saving short term thing, until we find the "truth"
11:25:14 <koeien37> or we might pass more into a declarative world
11:25:19 <koeien37> and leave less and less for the IO monad
11:25:19 <jmcarthur> copumpkin: that doesn't sound like the same thing to me
11:25:25 <conal> sinelaw: yes.  a stop-gap.  a coping mechanism.
11:25:34 <conal> sinelaw: not the promised land
11:25:37 <HaskellLove> The more i go i can see programming closer to proving proofs, but i cant see myself enjoying doing proofs. Some of you people really enjoy that as you do programming?
11:25:39 <copumpkin> let's come up with a truly pure language!
11:25:40 <sinelaw> conal, right :)
11:25:47 <copumpkin> HaskellLove: hell yeah
11:25:54 <koeien37> HaskellLove: that depends on how technical the proofs are
11:26:04 <harrisonpartch> how about a truly pure america?
11:26:13 <sinelaw> sounds evil
11:26:14 <koeien37> copumpkin: wouldn't Haskell \\ [unsafePerformIO] suffice?
11:26:20 <conal> sinelaw: because monadic IO is just a packaging trick, it cannot the the *semantic* problems of imperative IO that backus described.
11:26:20 <copumpkin> no sex for three generations!
11:26:24 <monochrom> HaskellLove: Do you?
11:26:25 <jmcarthur> HaskellLove: how can one program if he doesn't know what his program does?
11:26:31 <copumpkin> koeien37: that only gives us value purity!
11:26:36 <HaskellLove> copumpkin hell yeah send me some proofs to see what you do man, i might like it
11:26:45 <koeien37> how do you prove that your specification correctly models your "real world" problem?
11:26:50 <HaskellLove> monochrom not yet, but slowly i will make myself like it
11:26:57 <jmcarthur> koeien37: you can't
11:27:04 <sinelaw> koeien37, , impossible?
11:27:09 <jmcarthur> koeien37: that's why a simple and precise specification is important
11:27:17 <sinelaw> you can only disprove it
11:27:20 <monochrom> HaskellLove: It matters whether you enjoy it. It doesn't matter what label you slap on it.
11:27:22 <jmcarthur> koeien37: it has to be "obvious" that it is what you want
11:27:23 <conal> oops -- i'll try again.
11:27:35 <conal> sinelaw: because monadic IO is just a packaging trick, it cannot solve the *semantic* problems of imperative IO that backus described.
11:27:42 <koeien37> jmcarthur: but (models of) real systems are often very complex
11:27:51 <pikhq> copumpkin: Oh, you want a purely functional langauge?
11:27:56 <sinelaw> conal, my natural language parser is very tolerant, the first message went through :)
11:27:57 <jmcarthur> koeien37: and that is a problem
11:28:03 <SyntaxNinja> edwardk_: Thanks, bro :)
11:28:03 <copumpkin> pikhq: so pure I can lick it
11:28:07 <pikhq> Let's remove the IO monad, and make main be of type: String -> String
11:28:08 <koeien37> jmcarthur: yeah, it's an old problem, sure :)
11:28:14 <koeien37> pikhq: only use interact! :)
11:28:17 <copumpkin> pikhq: nah, that's not pure enough
11:28:21 <koeien37> but how can I talk to the network then?
11:28:28 <jmcarthur> koeien37: what i mean is that maybe the models *shouldn't* be complex
11:28:30 <sc``> Hi, can I use alex to do lexical analisys in happy?
11:28:37 <copumpkin> what I'm getting at is that most people only talk about values when talking about purity
11:28:52 <sinelaw> sc``, i don't know, but what in the world happened before?
11:29:01 <pikhq> copumpkin: And make Int be only 29 bits, and get rid of System.Info?
11:29:02 <copumpkin> if you consider a function's output to be (value, time_of_execution, memory_consumption, cache_usage)
11:29:06 <copumpkin> then haskell isn't pure
11:29:18 <harrisonpartch> the problem of monadic i/o reminds one of maturana's autopoiesis
11:29:31 <koeien37> copumpkin: I can also consider the effect on the temperature of the room... this doesn't end anywhere
11:29:36 <copumpkin> pikhq: and capabilities
11:29:50 <copumpkin> koeien37: just saying that there are some things we can control that we still ignore, and it's worth keeping them in mind sometimes
11:29:54 <copumpkin> (like crypto applications)
11:29:54 <pikhq> copumpkin: Capabilities?
11:30:00 <jmcarthur> koeien37: that doesn't mean what copumpkin is saying is unimportant, though
11:30:14 <jmcarthur> koeien37: although i agree that a line must be drawn somewhere
11:30:15 <Philonous> copumpkin: But all those side effects (run time, CPU heat etc.) only occur in the run time system, which, presumable isn't haskell
11:30:15 <copumpkin> pikhq: the number of OS threads you've given the RTS, a "pure" value in the libraries
11:30:34 <Philonous> copumpkin: It's not haskells fault that the runtime system can't evaluate haskell expressions for free
11:30:38 <koeien37> jmcarthur: not necessarily. But _in practice_, how can we ever constrain, say, the cache usage?
11:30:48 <sc``> sinelaw, I try to make a basic compiler in haskell but I can't use alex and happy in the same way that I used before flex and yacc
11:30:51 <copumpkin> Philonous: yeah, I'm saying haskell has assumed those away but it's conceivable for a language that considers at least some of those explicitly and considers differing characteristics like that impure
11:30:59 <harrisonpartch> gentlemen and others: what say you to the prospect of realtime voxel raytracing using functional languages?
11:31:10 <jmcarthur> koeien37: do you think we can't?
11:31:11 <copumpkin> harrisonpartch: talk to edwardk_!
11:31:25 <harrisonpartch> is he here?
11:31:34 <Lemmih> sc``: The documentation covers using Alex with Happy.
11:31:37 <koeien37> jmcarthur: wouldn't such things depend on 1) the available of cache 2) the operating system used?
11:31:40 <copumpkin> koeien37: for crypto applications you often try hard to make sure you don't leak any information by doing that
11:31:53 <koeien37> copumpkin: that is true. interesting angle
11:32:03 <copumpkin> koeien37: all those "(cache)timing attacks" are results of impurity
11:32:05 <copumpkin> in the non-value sense
11:32:15 <jmcarthur> koeien37: sure, but you assume that there is no control over those factors
11:32:18 <copumpkin> the function always does the same thing, but leaks information about its implementation
11:32:24 <jmcarthur> *you're assuming
11:32:27 <koeien37> jmcarthur: I don't want to imply that
11:32:49 <copumpkin> anyway, not saying I have any answers to that, just that other stronger notions of purity might be interesting to explore sometime
11:33:01 <koeien37> but I think it's pretty difficult. I'm happy to be proven wrong in the future for some cool applications :)
11:33:18 <jmcarthur> koeien37: we could impose requirements on the operating system in the model
11:33:54 <copumpkin> things like no short circuiting can be important for example
11:34:09 <copumpkin> purity in that sense might actually mean artificially slowing down a function so that it's consistent in its timing
11:34:24 <jmcarthur> koeien37: yeah, difficult. all i mean to say is that such things could still be in the model.
11:34:25 <stepcut> if I want my application to work with base 3 and base 4, and I am using deriving (Data, Typeable), what do I need to do? Should I import Data and Typeable from Data.Generics, and make the base-4 option depend on syb, even though I could just import Data.Data in base-4?
11:34:27 <koeien37> something like: f :: Int -> Bool[in precisely 20 cycles]
11:34:29 <copumpkin> although often that might be a function of its input, so I'm not sure if that is still purity
11:34:34 <copumpkin> hmm
11:34:37 <jmcarthur> the implementation is left as an exercise ;)
11:35:06 <copumpkin> hm, maybe not purity
11:35:11 <koeien37> jmcarthur: :) yeah, i explicitly mentioned 'in practice'. I guess you will need a very well-specified operating system and hardware
11:35:16 <sinelaw> conal, my comment on the blog was a little pedantic, but the point was that you said that "FRP has X" and then you talked about how frp SHOULD have X, where X = past/future access being undenotable
11:35:19 <sc``> Lemmih: I don't see any section mention how to use Alex with Happy, neighter in the Alex doc nor Happy doc. where did you see that?
11:35:34 <jmcarthur> stepcut: http://www.searchmarked.com/math/how-to-convert-from-base-10-decimal-to-any-other-base.php ;)
11:35:44 <stepcut> jmcarthur: thanks !!
11:35:56 <conal> sinelaw: yeah.  sry for that confusion.  maybe i could have rewritten more clearly.
11:36:18 <conal> sinelaw: thx for pushing me (again) to clarify.
11:36:27 <koeien37> jmcarthur: or at least model them like that, and hope that in practice it's close enough
11:36:34 <sinelaw> conal, i'm Einstein's grandma!
11:36:45 <conal> hah!
11:36:49 <tromp_> :t arctan
11:36:50 <lambdabot> Not in scope: `arctan'
11:36:58 <tromp_> :t tan
11:36:59 <lambdabot> forall a. (Floating a) => a -> a
11:37:27 <idnar> :t atan
11:37:28 <lambdabot> forall a. (Floating a) => a -> a
11:37:31 <idnar> :t atan2
11:37:32 <lambdabot> forall a. (RealFloat a) => a -> a -> a
11:37:42 <tromp_> > atan2 3 5
11:37:44 <lambdabot>   0.5404195002705842
11:37:50 <idnar> I always want to think of the opposite of "real" as "fake"
11:38:06 <idnar> so when I see names like "RealFloat", I sort of wonder "what the heck is a fake float?"
11:38:19 <Veinor> Haha
11:38:26 <Adamant> the number classes could have been named better, yes
11:38:34 <tromp_> > 3.7* sin (atan2 3 5)
11:38:35 <lambdabot>   1.9036342950818483
11:38:40 <Veinor> it's not really a float, it's just an array of base 10 digits! :O
11:38:41 <tromp_> > 3.7* cos (atan2 3 5)
11:38:43 <lambdabot>   3.172723825136414
11:39:03 <copumpkin> Veinor: ooh, so I can count them
11:39:17 <Veinor> well, floats are countable cause they're not infinite-precision :P
11:39:19 <Adamant> I have to remember Zeihlen or whatever as integerZ
11:39:24 <tromp_> > 3.7* cos (atan2 3 5) * 3.7* sin (atan2 3 5)
11:39:25 <lambdabot>   6.039705882352942
11:39:41 <Veinor> Adamant: is that where we get the script-Z?
11:39:44 <copumpkin> Veinor: oh, but I mean reals
11:39:49 <Veinor> ah
11:39:54 <Adamant> Veinor: the German word, yeah
11:40:08 <Veinor> I don't have any mnemonic for it, I just... know it.
11:40:15 <Veinor> wiki says Zahlen.
11:40:18 <Adamant> ah
11:40:29 <Philonous> That's german for numbers
11:40:31 <Veinor> also, I have a question
11:40:32 <koeien37> Zahl = number
11:40:50 <Veinor> how would I write a program that takes numbers in from the user and displays a running total?
11:40:58 <tromp_> > 3.7* sin (atan2 427 240)
11:40:59 <lambdabot>   3.2254345013296843
11:41:02 <Veinor> er
11:41:15 <copumpkin> Veinor: would you want fancy terminal graphics?
11:41:21 <copumpkin> Veinor: or just spit out a new total after each input?
11:41:23 <Veinor> well, I should probably state what I'm trying to do
11:41:35 <holmak> the total must be displayed as 10-line tall ASCII art
11:41:45 <Veinor> holmak: that's easy, use figlet :D
11:41:54 <holmak> ooh, really?
11:42:08 <Veinor> I have a list of things people want to go to, with priorities
11:42:28 <merijn> Is doing haskell webprogramming a completely stupid idea? If not, any recommendations for frameworks/libraries I need to check out?
11:42:33 <Veinor> I want to determine which events the user should go to; if there are two conflicting events with equal priority, I want to ask them which one they want to go to.
11:42:44 <koeien37> merijn: no, it's not a stupid idea. You might like happstack
11:42:56 <koeien37> or Turbinado (no experience with that myself)
11:43:17 <koeien37> there are also some more lightweight approaches, such as FastCGI or CGI
11:43:37 <Veinor> what I was thinking was I pass the schedule determiner a lazy infinite list of priority resolution objects which are populated from IO; every time a conflict comes up, the user gets asked 'what do you want to do?'
11:43:50 <holmak> merijn: I think Happstack is the usual way to write Haskell webservers.
11:43:54 <Veinor> the problem with that is I can't see how to pass information on what's conflicting out of the function
11:44:08 <Veinor> I think it'd just be easier to work in StateT IO. bleh.
11:44:21 <koeien37> there is an IRC channel, #happs, for Happstack
11:45:02 <merijn> I'm looking for barebones/flexibility more then fully finished solutions. I need to finally start working on getting my website finished and in the air. Was gonna do something in Python first. But I'm already reasonable in python so I figured it might be a nice Haskell exercise :)
11:45:16 <merijn> I'll check out happstack and turbinado first, thanks
11:45:30 <Veinor> and, while I could probably learn StateT, I'm trying to use this as a teaching example and I don't want to get into monad transformers.
11:46:33 <sshc> koeien37: is binary cross-platform?
11:46:53 <Veinor> I might just use this as an example of how to use Either to handle errors insteaed
11:47:40 <merijn> sshc: Depends on how you define cross-platform. But for most purposes executable binaries aren't "cross-platform"
11:48:36 <koeien37> sshc: AFAIK, yes.
11:49:02 <koeien37> as long as you avoid the host order
11:49:44 <copumpkin> Veinor: just define something a bit like an iteratee
11:49:51 <Veinor> ?
11:49:53 <sshc> merijn: not the binaries, but the files from which the program reads and writes values such as Int64's and Double's
11:50:12 <sshc> merijn: I'm referring to the hackage package "binary"
11:50:13 <copumpkin> Veinor: something like data WhatIThink = LooksGood | NopeConflict Reason
11:50:34 <copumpkin> Veinor: [InputState] -> [WhatIThink]
11:50:57 <merijn> sshc: Yeah, I suffer from terminal "answering questions without fully parsing the context" syndrome :)
11:51:50 <Veinor> well, what I was thinking is that Event is data Event = Event String [Block] where Block represents a block of time
11:52:19 <Veinor> and schedule :: [Event] -> [ConflictResolution] -> [Event]
11:52:42 <Veinor> or, without the IO wackiness, [Event] -> Either Failure Event
11:52:56 <Veinor> I'm not sure what your method is exactly :P
11:54:25 <copumpkin> basically encode your resolution logic in a pure function and represent its demands for resolution as an ADT, which an impure processor sits on the outside and consumes (presumably by asking the user for a resolution)
11:55:01 <filcab> Hi all
11:55:27 <Veinor> Yeah, that's what [ConflictResolution] is; it's a list of resolutions that would get pulled from the user as-needed
11:55:55 <jmcarthur> copumpkin: sounds like you are describing Prompt
11:56:10 <copumpkin> Veinor: so your problem is getting the resolved conflicts back to the function?
11:56:35 <copumpkin> jmcarthur: sort of, yeah
11:56:37 <Veinor> hm
11:57:01 <Veinor> well the other thing is, the conflict resolver obviously has to know what's conflicting
11:57:17 <Veinor> but I don't know how to do that. it might be simpler to do [Event] -> Either Conflict [Event]
11:57:38 <copumpkin> Veinor: you could return a function sort of like a continuation
11:58:02 <mreh_> here's a *somewhat* minimal replication of that "lack of entropy" problem I was having earlier
11:58:04 <mreh_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15641#a15641
11:58:15 <copumpkin> Veinor: it contains your current state, and once the resolution has been found, the IO dude calls the function you returned with the resolution and you can get on with your original work
11:58:35 <Veinor> hm
11:58:54 * copumpkin shrugs :)
11:59:00 <Veinor> so return \resolution -> schedule (apply resolution eventList) ?
12:00:01 <copumpkin> yep, something like that wrapped up in an ADT that still says what's wrong, so the IO thingy on the outside gets a reason, asks the user what to do, and then calls your function with the answer and lets you get on with your work
12:00:19 <copumpkin> working in Cont would probably help, but I haven't really thought through it very far
12:00:24 <mreh_> I think I may have exposed an error in GHC or my O/S, can we rule out the former please ^^^^
12:00:37 <mreh_> take a look, and see if you can replicate the problem yourselves
12:00:38 <filcab> I'm having a problem compiling ghc... Anyone has a "Not in scope: `programArgs'" error while executing make?
12:00:50 <Veinor> mreh_: what's the problem?
12:00:51 <filcab> I saw that message in the ghc-cvs mailing list
12:00:53 <filcab> but no reply
12:01:22 <Veinor> copumpkin: yeah, data ConflictError = ConflictError Conflict Resolver
12:01:26 <mreh_> Veinor: the program executes once, and only once, every other time it comes to evaluating something random it hangs indefinitely and consumes loads of memory and cpu time
12:01:38 <Veinor> now I just don't know how to pull from IO as-needed
12:01:50 <mreh_> my O/S fails to give back the memory after I've killed the process too
12:02:00 <copumpkin> Veinor: unsafeInterleaveIO gives you a "lazy IO stream"
12:02:04 <copumpkin> @hoogle unsafeInterleaveIO
12:02:05 <lambdabot> System.IO.Unsafe unsafeInterleaveIO :: IO a -> IO a
12:02:14 <koeien37> mreh_: that pretty unlikely. Which OS ?
12:02:30 <Veinor> but then I'm unsafeInterleavingIO.
12:02:33 <copumpkin> Veinor: but your pure function shouldn't really care what it's coming from. For all it cares the resolution could be const Meh
12:02:36 <Veinor> I want to use this for a beginner class :P
12:02:37 <mreh_> koeien37 Ubuntu running 2.31
12:02:48 <koeien37> 2.31 ?
12:03:09 <mreh_> pardon me linux kernel 2.6.31
12:03:11 <koeien37> oh 2.6.31
12:03:15 <Veinor> what's Control.Monad.Random.Class in?
12:03:19 <copumpkin> Veinor: the idea is to separate the decisionmaking from the logic, but it might not be the easiest thing for a beginner to understand
12:03:25 <Veinor> yeah, so I figured.
12:03:27 <mreh_> Veinor: MonadRandom
12:04:56 <Veinor> is it supposed to not produce output, mreh_?
12:05:30 <LeoD> hm template-haskell fails to install via cabal-install
12:05:34 <mreh_> Veinor: not the second time, it fails to evaluate
12:05:42 <Veinor> copumpkin: I guess the question is, how do I pull the conflict resolutions from the user?
12:05:51 <mreh_> or any time after that even
12:05:59 <Veinor> mreh_: runhaskell randomerror.hs produces no output, but does so in a very finite amount of time.
12:06:13 <mreh_> RandomError.hs?
12:06:20 <Veinor> what I called that paste.
12:06:23 <copumpkin> Veinor: yeah, you might want to look at iteratee for ideas in the mean time
12:06:29 <copumpkin> Veinor: your situation is a bit more complex though
12:06:33 <copumpkin> it's more bidirectional
12:06:42 <Veinor> yeah.
12:06:43 <mreh_> Veinor: as long as you used caps
12:06:50 <Veinor> :P
12:06:55 <Veinor> well actually I called it what.hs, but whatever
12:07:06 <mreh_> load it in GHCi
12:07:10 <copumpkin> wut.hs
12:07:14 <mreh_> that's where I'm getting this problem
12:07:20 <Veinor> ah
12:07:23 <Veinor> yeah, now I get it
12:07:37 <Veinor> same issue here.
12:07:43 <mreh_> i didn't try and compile it actually :)
12:08:12 <Veinor> if I put it in the Main module, compile and run, I get no output.
12:08:16 <Veinor> in ghci, I get your behaivor
12:08:18 <mreh_> i can't think what It might be, i've used up all my entropy :(
12:08:20 <Veinor> *behavior
12:08:35 <mreh_> Veinor: how can you compile it, there's no Main modul
12:08:38 <Veinor> copumpkin: when people say haskell is hard, this is what they're talking about
12:08:46 <Veinor> mreh_: there is if you edit it! :D
12:08:52 <Veinor> :P
12:09:06 <copumpkin> Veinor: it's easy if you're satisfied with making it ugly and interleaved :P
12:09:33 <copumpkin> Veinor: another option is to make it monadic
12:10:02 <Veinor> I don't want to teach people 'hey, if IO is hard, just use unsafe functions!'
12:10:21 <copumpkin> doSchedulingShit :: Monad m => ... -> (a -> m Decision) -> m Schedule
12:10:53 <copumpkin> where the function passed in gets called when something bad happens
12:11:44 <copumpkin> that might be easier, if not necessarily as pretty
12:11:54 * Veinor throws his hands up in the air
12:12:06 <Veinor> oh hey, ezyang just wrote something about IO
12:12:18 <Veinor> http://conal.net/blog/posts/can-functional-programming-be-liberated-from-the-von-neumann-paradigm/
12:12:30 <copumpkin> that's conal, not ezyang
12:12:32 <copumpkin> ;)
12:12:33 <Veinor> oh wait, that was something he linked. nevermind
12:12:39 <Veinor> yeah, I just realized :P
12:12:50 <Veinor> distracted by this stupid problem
12:12:55 <koeien37> mreh_: I'm sorry: I can't find your paste, could you send a link to your code?
12:13:21 <mreh_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15641#a15641
12:13:25 <Veinor> I think for purposes of this class I'll just do schedule :: [Event] -> Maybe Conflict [Event]
12:13:33 <Veinor> s/Maybe/Either/, obviously
12:13:38 <copumpkin> okay :)
12:13:47 <copumpkin> not sure how that works
12:14:27 <koeien37> mreh_: running main twice is a problem here, too. But the memory is returned to the OS for me
12:14:43 <mreh_> koeien37, ubuntu is broken
12:14:46 <mreh_> not a big dealy
12:14:50 <Veinor> I'm going to ignore IO.
12:14:58 <koeien37> mreh_: that is a tautology ;)
12:15:05 <Veinor> and just say 'the program fails if there's a conflict'
12:15:10 <copumpkin> mreh_: that's seriously broken if you don't get memory back after a process quits
12:15:33 <mreh_> copumpkin: It's not quitting, i'm terminating it
12:15:36 <Veinor> although more realistic behavior would be 'if there's a conflict, pick one in some arbitrary deterministic way'
12:15:43 <copumpkin> mreh_: same thing
12:15:45 <merijn> mreh_: Same difference, the OS shouldn't care
12:15:53 <mreh_> hmmm
12:15:57 <koeien37> mreh_: are you sure the process is killed? does it show up on ps aux | grep [g]hci ?
12:16:00 <mle> shm isn't returned
12:16:05 <jfoutz> schedule :: [Event] -> [Either Conflict Event]
12:16:26 <merijn> mle: True, but you should be able to see and close the via ipcs
12:16:27 <mreh_> koeien37: ghci says "C^interrupted"
12:16:33 <jfoutz> but i should read the scrollback.
12:16:40 <koeien37> mreh: do you kill ghci afterwards?
12:16:40 <mreh_> maybe the child processes aren't dead
12:16:52 <mreh_> koeien37, the mem comes back when I kill ghci
12:16:57 <copumpkin> ps axf
12:17:02 <koeien37> good. as expected ...
12:17:03 <mreh_> maybe there are zombie processes
12:17:06 <koeien37> ghci doesn't return memory
12:17:23 <copumpkin> get out the chainsaw
12:17:27 <koeien37> in fact, no Haskell programs compiled with GHC do
12:17:32 <koeien37> (including GHC itself)
12:17:52 <mle> how are you determining memory status?
12:18:06 <mle> (this sounds like virtual memory cached/free confusion)
12:20:18 <periodic> koeien37: You mean once they have allocated memory they will hold on to it and re-use it internally, marking it as free within the program, but won't return it to the operating system, correct?
12:20:33 <periodic> In which case it's not a big deal because those pages will get swapped out if the system needs them.
12:20:55 <koeien37> mreh_: I think I might a problem
12:21:01 <koeien37> periodic: that was what I meant
12:21:11 <mreh_> koeien37, huh?
12:21:29 <koeien37> evalRandIO uses getStdRandom
12:21:43 <mreh_> righty
12:22:09 <mreh_> is ssh a bash shell?
12:22:16 <periodic> no.
12:22:17 <ben> I was not aware that non-haskell applications returned memory in the first place
12:22:20 <ben> ie, free()
12:22:21 <periodic> ssh invokes a shell.
12:22:30 <Veinor> ssh invokes whichever shell you have set as default
12:22:51 <koeien37> mreh_: so your mixN function should return a fresh random number generator to use afterwards
12:22:53 <periodic> mreh_: you can have ssh run any program you want on the target system.  By default it usually invokes the logon program which will invoke the user's shell.
12:23:23 <mreh_> koeien37, that's what MonadRandom is good for
12:23:31 <mreh_> it does that implicitly
12:23:54 <koeien37> not if you use all your entropy by accidentally generating an infinite list of random numbers
12:24:11 <mreh_> koeien37: oh
12:25:09 <mreh_> no i still don't understand
12:25:55 <mreh_> the only way to generate fresh random numbers is make a new generator, that's what monadrandom does for you, calls split on the gen and passes the new one around
12:26:12 <saml> > let gcd (a,b) = Prelude.gcd a b in gcd(2,4)   -- can you generalize this so that i can write haskell as if i'm writing python ?
12:26:13 <lambdabot>   2
12:26:31 <saml> for all functions
12:26:31 <koeien37> mreh_: yes, but if you run main twice, you use the standard number generator twice
12:26:44 <koeien37> apparently, it is not correctly initialized after the first run of main
12:26:56 <koeien37> I don't know why precisely.
12:27:02 <Veinor> saml: no, because that's not how tuples work
12:27:18 <copumpkin> saml: if you really want to, you could rewrite all functions to take a tuple
12:27:21 <mreh_> koeien37, that has to be an error
12:27:28 <copumpkin> saml: not sure why you would though, you lose all currying abilities
12:27:46 <mreh_> i'm not actually generating an infinite list of random numbers
12:28:06 <Accidus> What's the difference between a reflection of an object B along a functor F and a universal arrow from B to F? Reflection along a functor as in definition 3.1.1 here:
12:28:09 <Accidus>  http://books.google.com/books?id=o5Do_Kl6xZUC&lpg=PA96&ots=_LmfTUMi8Z&dq=reflection%20along%20categories&pg=PA97#v=onepage&q=reflection%20along%20categories&f=false
12:28:25 <copumpkin> Accidus: haskell-in-depth might be less noisy for people to see that question
12:28:32 <copumpkin> #haskell-in-depth, that is
12:28:33 <lunabot>  luna: parse error on input `in'
12:28:41 <Accidus> Ooh, didn't know about that one.
12:28:47 <copumpkin> bbl :)
12:29:02 <Twey> We need to start ##cat-theory
12:29:28 <mreh_> meow
12:29:30 <saml> join ##cat-theory
12:31:04 <shambler> morphism from cat X and cat Y to cat Z is loooooove
12:31:37 <ray> @tell conal your blog's rss feed has a newline at the beginning that confuses my xml parser, making it impossible to subscribe
12:31:38 <lambdabot> Consider it noted.
12:31:47 <jfoutz> @hoogle a->b->c
12:31:48 <lambdabot> Prelude curry :: ((a, b) -> c) -> a -> b -> c
12:31:48 <lambdabot> Data.Tuple curry :: ((a, b) -> c) -> a -> b -> c
12:31:48 <lambdabot> Prelude flip :: (a -> b -> c) -> b -> a -> c
12:31:58 <mreh_> can I find out what version of shell i am running?
12:32:05 <mreh_> from within the shell
12:32:18 <periodic> ray: aren't newlines supposed to be ignored in XML?  Or is it getting annoyed that the <xml> tag isn't the very first thing in the file?
12:32:19 <mreh_> or even what shell it is
12:32:32 <dmhouse> periodic: <?xml ?>, you mean
12:32:51 <periodic> dmhouse: yeah, that thing that copy-and-paste in when I work with xml. :P
12:33:07 <shambler> try echo $SHELL
12:34:02 <periodic> do "echo $0".  $SHELL is an evironment variable and may not be set correctly.  For example, I have a system which as the shell for everyone set to tcsh and won't let you change it, so I spawn bash from my login scripts but $SHELL is still "tcsh"
12:34:12 <periodic> but "$0" is "/bin/bash"
12:34:20 <sproingie> newlines are whitespace and technically aren't ignored at the start of a document, but it's usually something a decent parser will forgive
12:34:23 <shambler> oh I see
12:34:40 <ray> periodic: yes
12:34:46 <sproingie> an RSS reader choking on it is inexcusable, it's not even strictly xml anyway
12:35:07 <periodic> Yeah, seems pretty lame to care about white space in one spot.  I would think you'd just strip all whitespace in a lexer phase.
12:36:12 <periodic> But hey, at least XML has a coherent spec, unlike a lot of things I've had to parse.
12:36:20 <kmc_> perhaps it needs <?xml to be the very first bytes in the file, in order to detect character encoding
12:36:29 <sproingie> strictly speaking whitespace makes it a mixed content doc, but every parser i know of has a mode to ignore it
12:36:33 <mreh_> it's hard to search for the unix command '.'
12:36:42 <sproingie> mreh_: it's a shell builtin
12:37:06 <kmc_> help .
12:37:18 <sproingie> RSS isn't even really xml anyway
12:37:25 <sproingie> the namespace stuff is hardwired
12:37:33 <pikhq> mreh_: It's impossible to exist as a Unix binary.
12:38:10 <mreh_> pikhq: okay, the shell command '.'
12:38:19 <pikhq> mreh_: There we go.
12:38:23 <pikhq> Yeah, that's bloody hard to search for.
12:38:24 <kmc_> it's the same as "source" in bash i believe
12:38:31 <pikhq> What with not existing on the filesystem and all. ;)
12:38:32 <sproingie> alias for source.  man bash
12:39:27 <mreh_> do you know the csh equiv?
12:39:46 <sproingie> should be the same
12:40:10 <sproingie> might have to spell out "source"
12:42:14 <LeoD> trying to install template haskell, anything i could be doing wrong there? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15642#a15642
12:42:38 <koeien37> I think template-haskell is shipped with GHC
12:43:08 <LeoD> oh, hm.. data-accessor-template still has it as a dependency though
12:44:39 <koeien37> which ghc version are you using?
12:44:54 <LeoD> 6.10.4
12:45:47 <koeien37> can't you say cabal install data-accessor-template --constraints='template-haskell<2.4'   (not sure about exact syntax)
12:46:53 <LeoD> huh, i think that worked! thanks :)
12:51:30 <Absolute0> Is there a portable version of the sleep function? No System.Posix on Windows.
12:51:42 <Botje_> @hoogle sleep
12:51:42 <lambdabot> No results found
12:51:44 <mauke_> @hoogle threadDelay
12:51:44 <lambdabot> Control.Concurrent threadDelay :: Int -> IO ()
12:51:53 <Absolute0> ah thanks
12:51:57 <kmc_> threadDelay will delay a Haskell thread for a number of microseconds
12:52:05 <kmc_> that's not the same as a foreign call to the OS's sleep
12:52:12 <kmc_> but it's more likely to be what you want
12:52:18 <mauke_> yeah, it's better
12:53:02 <Absolute0> is that in nanoseconds?
12:53:03 <Absolute0> :)
12:53:07 <koeien37> micro
12:53:08 <kmc_> microseconds
12:53:12 <Absolute0> doesnt seem to be
12:53:14 <koeien37> 10^-6
12:53:17 <Absolute0> 1000 returns right away
12:53:24 <koeien37> right. that's 1 millisecond
12:53:36 <mauke_> lern2metric
12:53:37 <Absolute0> so 1 is microsecond..
12:53:39 <Absolute0> ok thanks
12:53:48 <kmc_> "threadDelay 1000000" should sleep for one second.
12:53:49 <Absolute0> sorry i thought you meant milliesecond
12:54:02 <mauke_> see also: bilisecond
12:54:03 <kmc_> what's three orders of magnitude between friends
12:54:24 * koeien37 did this wrong the first time too
12:59:00 <kmc_> 1 microsecond is about four city blocks
12:59:10 <kmc_> 1 millisecond is about the distance from New York City to Baltimore
13:00:01 <c_wraith> can you translate that to west coast cities? ;)
13:00:12 <koeien37> can you translate that to western european cities? ;)
13:00:18 <mauke_> EAST COAST REPRESENT
13:00:32 <kmc_> koeien37, i tried and failed :/
13:00:45 <sproingie> can you translate that into football fields and libraries of congress?
13:01:27 <CalJohn> i am unable to understand things that are not measured in double-decker buses
13:01:30 <jmcarthur> translate it to suthun
13:01:34 <kmc_> the distance from san diego to los angeles is about 650 us
13:01:57 <jmcarthur> DOLLARS?
13:02:15 <koeien37> berlin to hamburg :)
13:02:23 <kmc_> okay :)
13:02:32 <doserj> London to Manchester
13:02:37 <kmc_> the distance from carteret, new jersey to weehawken, new jersey is about 100 us
13:03:11 <mreh_> when GHC executes IO it goes to the standard output right?
13:03:14 * jmcarthur vows to measure all distances in US dollars from now on
13:03:22 <Heffalump> mreh_: depends where the IO is sent...
13:03:24 <koeien37> maybe more for us haskellers: a little bit less than glasgow to manchester ;)
13:03:29 <koeien37> mreh_: it depends.
13:03:43 <mauke_> mreh_: that question makes no sense
13:03:46 <Lemmih> mreh_: That question doesn't make sense.
13:03:47 <koeien37> a value of type IO a is just an IO action. It can sent data to the standard output, but not necessarily so
13:03:51 <jmcarthur> mreh_: not all IO actions make textual output at all
13:04:03 <koeien37> send*
13:04:03 <kmc_> mreh_, "putStrLn" and friends go to stdout
13:04:05 * mauke_ high fives Lemmih
13:04:06 <kmc_> if that's what you're asking
13:04:18 <kmc_> there are more general functions to send to any file handle
13:04:18 <koeien37> It can also talk to the network, launch nuclear missiles, and so on
13:04:30 <Heffalump> has any Haskell program ever launched nuclear missiles?
13:04:31 <mreh_> "Launch the missiles"
13:04:34 <mauke_> or read/write memory
13:04:43 <mreh_> yeah, okay, I understand
13:04:46 <sproingie> unsafePerformNuclearLaunch
13:04:47 <kmc_> Heffalump, doubtful
13:04:55 <kmc_> live nuclear missiles have only been launched a couple times
13:05:08 <mreh_> @faq Can Haskell destroy worlds?
13:05:09 <lambdabot> The answer is: Yes! Haskell can do that.
13:05:16 <jmcarthur> typeSafeButNotActuallySafeLaunchNuclearMissiles :: IO ()
13:05:17 <kmc_> @faq Can Haskell destroy minds?
13:05:18 <lambdabot> The answer is: Yes! Haskell can do that.
13:05:20 <Heffalump> kmc_: I wasn't serious :-)
13:05:32 <kmc_> Heffalump, my answer still stands
13:05:38 <Heffalump> haven't any nuclear tests involved missile launches, though?
13:05:42 <kmc_> yes, a few
13:05:52 <kmc_> that's what i meant
13:05:57 <lispy> How do ghc-options combine?
13:06:03 <lispy> Is it concenation?
13:06:20 <kmc_> most tests have not, and nuclear-armed missiles have never been used in combat
13:06:29 <ray> i wrote the package for destroying the universe, but i don't have a hackage account
13:06:42 <jmcarthur> ray: i am glad for that
13:07:29 * jmcarthur premptively attacks ray for having a weapon
13:07:32 <ray> destroying the universe is a lot more safe than launching nuclear missiles though
13:08:12 <jmcarthur> ray: you might be right. i'm not sure if the side effect is observable
13:08:28 <c_wraith> I already fired my weapon to destroy the universe
13:08:39 <ray> not only is the side-effect not observable, it can't even be evaluated observably
13:08:51 <c_wraith> The effects are visible: the rate of expansion is increasing
13:09:16 <ray> of course it doesn't work because i don't have a usb large hadron collider to write the drivers for
13:09:29 <ray> not that this makes any semantic difference
13:11:40 <Absolute0> Is it possible to input numbers in binary format?
13:12:17 <c_wraith> what do you mean by "binary format"?
13:12:31 <mauke_> Absolute0: no
13:12:32 <Absolute0> b010101
13:12:42 <Absolute0> i've only found 0x for hex on google.
13:12:46 <CalJohn> in little endian base-2, i would assume
13:12:53 <c_wraith> you'd have to write your own parser for that.
13:12:57 <mauke_> big endian
13:13:05 <Absolute0> i guess hex suffices
13:13:19 <mauke_> Just use Perlâ„¢
13:13:35 <Absolute0> why perl?
13:13:52 <CalJohn> right, big endian, i mix those up at every opportunity
13:14:07 <mauke_> because perl lets you do stuff like 0b0011_1000_0000_0110
13:14:18 <Absolute0> doesn't C let you as well?
13:14:22 <ray> big endian = big end in = start with the most significant
13:14:33 <mauke_> Absolute0: no
13:14:41 <Absolute0> switching a language based on preference of literal formats is silly.
13:15:01 <mauke_> depends on what your program does
13:15:54 <edwardk_> Absolute0: color me silly ;)
13:16:31 <CalJohn> ray: i will try and remember that mnemonic, but it's almost more complicated than just remembering which way around it is
13:16:52 <ray> it's more like the etymology than a mnemonic, i think
13:17:02 <ray> that and swift
13:17:02 <monochrom> hex and oct are compact forms of binary anyway
13:17:16 <conal> ray: thx for the alert about my blog's rss.  i haven't been able to fix it.  i think i'll just upgrade to a much newer wordpress.
13:17:17 <lambdabot> conal: You have 1 new message. '/msg lambdabot @messages' to read it.
13:17:26 <CalJohn> anyone know a good free (as in beer) resource for learning term rewriting?  I can't really afford Term Rewriting And All That
13:17:35 <edwardk_> conal: probably safer to upgrade anyways
13:17:47 <conal> edwardk_: yep
13:17:58 <edwardk_> which reminds me i need to do the same
13:18:02 <ray> i had never seen that particular issue on wordpress before
13:19:03 <conal> turned up quite a lot while googling
13:32:47 <yrlnry> I implemented a state-transformer monad State s a, and then I wanted to use it where the state was a simple queue type.  I implemented push, pull, and isEmpty operators of types a -> State (Queue a) (),  State (Queue a) a, and State (Queue a) Bool, respectively.  All is okay so far.  Now I want "safePull", of type  State (Queue a) (Maybe a), which yields Nothing if the queue is empty, and Just x otherwise.
13:33:07 <yrlnry> Code is a http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15643#a15643
13:33:29 <yrlnry> Everything seems to work OK, but safePull seems to return the front of the queue without changing the state.
13:33:55 <yrlnry> Given the definitions in the code, I execute "qt" with  (exec qt) and get [Just 5, Just 5, Just 5], instead of [Just 5, Just 23, Nothing].
13:34:46 <yrlnry> I tried working up a simpler example, with an ordinary list as a stack, and a "safePop", and it did work as I expected.
13:36:19 <theclaw> I have a Parsec related question. The ParsecT datatype is an instance of MonadTrans, and ParsecT is *also* an instance of several monads, e.g. MonadState, MonadIO; is it possible  to use for example functions from MonadIO and MonadState at in the same "do" block?
13:36:39 <theclaw> -at
13:37:01 <Heffalump> theclaw: yes
13:37:19 <Heffalump> "instance of several monads" isn't quite accurate terminology. "instance of several monad-related typeclasses".
13:37:37 <theclaw> Heffalump: yes, that was what I meant. Hmm.
13:38:02 <Heffalump> Any given do-block has to be the same monad right through (though it can be polymorphic). But you will only be using one monad, just one that happens to be in several different typeclasses.
13:40:20 <theclaw> Heffalump: I have to think about that. :)
13:46:43 <sshc> how do I define a variable as NaN?
13:46:49 <theclaw> Heffalump: the type is "ParsecT s u m a = State s u -> m (Consumed (m (Reply s u a)))"; "m" is the underlying monad here. So when I use another underlying monad, ParsecT changes. I don't get why I will be using just one monad?
13:46:59 <Lemmih> > 0/0
13:47:00 <lambdabot>   NaN
13:47:28 <Heffalump> that's what I mean about being polymorphic
13:48:00 <Heffalump> it's like \x -> x - it has a polymorphic type, but each call to it at runtime is with a specific type.
13:48:16 <Heffalump> like that, you can write do blocks and they'll get a polymorphic type inferred
13:48:31 <Heffalump> but the type will be constrained to support all the operations you use in that block
13:49:10 <theclaw> Heffalump: hmm. For example, "liftIO = lift . liftIO" (MonadIO) for example, and "get = lift" (MonadState) - so when I use "lift . liftIO", what I get is a monad for type "ParsecT s u MonadIO a", right?
13:49:41 <Heffalump> that type isn't well formed. MonadIO is a type class and can't be a parameter to a type constructor like ParsecT
13:50:04 <Stalafin> what do people in this channel think of 'a gentle introduction to haskell'?
13:50:15 <merehap> not so gentle
13:50:17 <Heffalump> Stalafin: it's generally considered to be not very gentle.
13:50:23 <Heffalump> But quite good for otherwise experienced programmers.
13:50:57 <theclaw> Heffalump: what would the type be then?
13:51:14 <Heffalump> @type lift . liftIO
13:51:15 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, MonadIO m) => IO a -> t m a
13:51:18 <Stalafin> i figured, since at some point i have to leave "learn you a haskell" i could need a book; is real world haskell then the book to go for?
13:51:19 <Heffalump> that :-)
13:51:22 <sshc> if I'm importing a module, how do I import the typeclass so that I can make an instance of it?
13:51:32 <merehap> seconded
13:51:37 <Heffalump> Stalafin: learn you a haskell is coming out in print at some point
13:51:47 <sshc> Stalafin: that's would I did
13:51:48 <Heffalump> RWH is pretty good too, from what I know of it
13:51:59 <Stalafin> Heffalump: yes, but it is not complete; for example, monads are not explained
13:51:59 <Heffalump> sshc: just mention the type class by name.
13:52:09 <Heffalump> Stalafin: ah, right.
13:52:26 <hoknamahn> hi guys. quick question - does ghc support sse?
13:52:30 <merehap> Stalafin: I wouldn't say that is a problem
13:52:32 <sshc> Stalafin: although the first few chapters or so reviewing, there are a few things you might have not picked up or have examples for later chapters
13:52:41 <sshc> Stalafin: it was well worth reading it imo
13:53:11 <Stalafin> sshc: what are you referring to? RWH?
13:53:32 <sshc> Stalafin: yes, I am
13:53:50 <tibbe> Stalafin: I liked RWH.
13:53:57 <Stalafin> sshc: alright, thanks; guess that's what i am gonna go for
13:53:59 <Stalafin> thenm
13:54:28 <EvanR-work> the best tutorial is to write your own programs!
13:54:49 <Stalafin> EvanR-work: of course, but you always need a point to start at ^^
13:55:09 <EvanR-work> neva!
13:55:47 <foolio_> what is the recommended way to use basic data structures? EdisonCore? collections? If I need priority queues, perhaps heaps or PQueue?
13:56:34 <sshc> EvanR-work: as Stalafin stated, you always need a point at which to start.
13:56:51 <EvanR-work> as EvanR-work stated, neva!
13:57:04 <sshc> EvanR-work: never what?
13:57:12 <EvanR-work> start at the end
13:57:22 <sshc> EvanR-work: that won't work
13:57:25 <sshc> EvanR-work: take for example
13:57:37 <foolio_> I was unable to cabal install heaps and collections. The latter seems to be somewhat inactive based on mailing list discussion from 2005. It has not been deprecated though, so it's hard for a newbie to know what should be used.
13:58:29 <sproingie> edison is good.  depends on the data structure you want.
13:58:37 <jmcarthur> i think hackage should have some visible statistics about popularity
13:58:59 <jmcarthur> and i believe there have been discussions about a rating system, but i don't know what became of that
14:00:14 <theclaw> Heffalump: okay, I see that liftIO is complicated for an example, so when I use "get", what I get as a type is essentially "ParsecT s u <instance_of_MonadState> a", right? :)
14:01:08 <aavogt> :k ParsecT
14:01:10 <lambdabot>     Not in scope: type constructor or class `ParsecT'
14:01:23 <sproingie> liftIO is simple to use.  explaining how it works is another story
14:01:45 <Heffalump> theclaw: yes.
14:01:54 <foolio_> cabal list says QuickCheck latest installed is 1.2.0.0 (after haskell platform on mac) but 2.1.0.2 is available
14:02:21 <theclaw> Heffalump: what my concern is: when I use "lift" on another monad, I once get "ParsecT s u <instance_MonadA>", and once I get "ParsecT s u <instance_MonadB>" - I don't see where there's polymorphism
14:02:23 <Heffalump> at least, it will be if the definition of get for ParsecT is "lift get"
14:02:39 <theclaw> Heffalump: yes, it is
14:02:39 <Heffalump> so if you use those two things in the same do block, the type is
14:02:41 <foolio_> cabal install QuickCheck fails, however, saying all requested packages are already installed, and recommends --reinstall. The option just forces 1.2.0 reinstallation
14:02:51 <Heffalump> ParsecT s u <instance_MonadA and instance_MonadB>
14:02:52 <foolio_> what is the way QuickCheck should be brought to newest version?
14:03:00 <Heffalump> i.e. you're constrained to types that are instances of both classes.
14:03:26 <sproingie> foolio_: cabal install quickcheck
14:03:52 <Heffalump> foolio_: it's possibly the hackage admins have set the default to an old version
14:04:02 <Heffalump> you can use cabal install QuickCheck-2.1.whatever to get a specific version.
14:04:18 <foolio_> sproingie: "No packages to be installed. All requested packages are already installed."
14:04:26 <sproingie> what Heffalump said
14:04:39 <theclaw> Heffalump: oh. How would the type then be written, formally? (just to get the idea)
14:04:56 <Heffalump> theclaw: (MonadA m, MonadB m) => ParsecT s u m
14:04:57 <theclaw> Heffalump: doesn't have to be 100% correct :) I'd just like to see the syntax
14:05:02 <theclaw> Heffalump: thanks!
14:05:28 <foolio_> Heffalump, great! Thank you! Seemed to start downloading
14:11:12 <luite> is there an example for pure XML processing with HXT? All examples on haskellwiki seem to use the IO xml arrow
14:12:55 <newsham> hey arr
14:13:00 <arr2> hey newsham
14:13:06 <arr2> g'day
14:13:26 <newsham> > map succ "arr"
14:13:27 <lambdabot>   "bss"
14:13:43 <arr2> heh
14:13:52 <arr2> shifty
14:13:53 <arr2> ;-)
14:19:19 <mreh> did anyone get anywhere with that GHCi "lack of entropy" issue, otherwise i'm going to try and see exactly what causes it, and report it
14:19:43 <Baughn> mreh: Lack of entropy?
14:20:11 <mreh> Baughn: it tries to get random numbers from the system but cant
14:20:27 <Baughn> mreh: That should block. Wait, why does GHCi need to do that?
14:20:40 <mreh>  Baughn: because I asked it to
14:21:05 <Baughn> More to the point, what part of this is a bug
14:21:06 <Baughn> ?
14:21:38 <mreh> when the execution returns, it fails to evaluate the same expression again
14:22:02 <jmcarthur> mreh: how are you getting the values from the system? /dev/random?
14:22:07 <chrisdone> http://i42.tinypic.com/2ujlem0.jpg
14:22:14 <Baughn> jmcarthur: Oh, are you using unsafePerformIO somewhere?
14:22:19 <Baughn> Er, mreh
14:22:44 <mreh> jmcarthur: I haven't checked the implementation, but the doc says it uses /dev/random on unix systems
14:22:50 <jmcarthur> mreh: it sounds like you are asking the system to do something that it simply can't do
14:22:52 <mreh> Baughn: No
14:23:07 <jmcarthur> mreh: entropy is something that can only be accumulated by time
14:23:20 <Baughn> mreh: I think I'd need to see the code, here.
14:23:35 <Baughn> I can't quite envisage what's failing.
14:23:41 <jmcarthur> mreh: /dev/random is meant to be truly random. if the operation you are using blocks you could see if you get more information by jiggling the mouse around
14:23:46 <jmcarthur> mreh: but it will be slow
14:24:01 <jmcarthur> mreh: if you want something faster i recommend using a different source of random numbers
14:24:38 <mreh> it's not slow, it just block indefinitely
14:24:46 <Baughn> It won't block /forever/
14:25:06 <Baughn> mreh: If what you want are cryptographically secure random numbers, I can recommend the Random module in the AES package. ;)
14:25:08 <jmcarthur> mreh: it should generate more numbers as you move the mouse, but very very very slowly
14:25:21 <mreh> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15651#a15651 -- run this *twice* in GHCi
14:25:21 <jfoutz> would you say, it will block for a random amount of time?
14:25:22 <Baughn> Much, much faster, and just as random in practice
14:25:33 <jmcarthur> mreh: it uses sources of entropy besides the mouse too, but the mouse is the handiest way
14:25:54 <jmcarthur> mreh: you really are only supposed to use /dev/random for things like generating keys, not for general purpose RNG
14:26:07 <mreh> just run it and see what happens
14:26:17 <sproingie> use /dev/urandom
14:26:35 <Baughn> Nothing in that even refers to /dev/random..
14:26:59 <jmcarthur> yeah...
14:27:05 <kmc_> @type (<$)
14:27:06 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
14:27:08 <kmc_> @type ($>)
14:27:09 <lambdabot> Not in scope: `$>'
14:27:20 <mreh> I NEVER SAID I WAS USING /DEV/RANDOM!
14:27:22 <Absolute0> What's wrong with "instance Show (Maybe Foo) where" ?  -XFlexibleInstance doesn't seem to work in Windows.
14:27:31 <mreh> i said it might!
14:27:38 <kmc_> Absolute0, put this on the first line of your file:
14:27:43 <kmc_> {-# LANGUAGE FlexibleInstances #-}
14:27:56 <jmcarthur> huh, 100% cpu...
14:27:58 <kmc_> this is preferable to giving command line args to ghc
14:28:11 <mreh> jmcarthur, same here :)
14:28:12 <kmc_> you can give a comma-sep list of multiple extensions
14:29:07 <Baughn> mreh: Can you try to strace it?
14:29:13 <Absolute0> kmc_ thanks
14:29:16 <mreh> Baughn: stack trace?
14:29:21 <Baughn> mreh: No, strace
14:29:25 <benignvulcan> >length [throwError "consternated"]
14:29:31 <mreh> Baughn: I'm not sure :)
14:29:33 <Baughn> mreh: Actually, I'll just do it here
14:29:58 * Baughn hugs cabal-install
14:30:15 <mreh> can you strace a haskell application?
14:30:22 <mreh> duh..
14:30:26 <Baughn> You can strace anything. But huh.
14:30:30 <Baughn> It locks at 50% cpu use?
14:30:33 <oteren> urandom is really slow as well
14:30:41 <jmcarthur> well, a whole core
14:30:53 <kmc_> the question is how to get fast prng?
14:30:59 <jfoutz> > [0..0]
14:31:00 <mreh> jmacarthur: I get the same thing, the code works the first time doesn't it?
14:31:00 <lambdabot>   [0]
14:31:06 <jfoutz> > [0..-1]
14:31:07 <lambdabot>   Not in scope: `..-'
14:31:07 <jmcarthur> mreh: yes
14:31:14 <jfoutz> > [0..(-1)]
14:31:15 <lambdabot>   []
14:31:19 <jmcarthur> mreh: oh i have an idea. let me check this
14:31:21 <Baughn> That's odd
14:31:26 <Baughn> mreh: Are you running 6.12?
14:31:45 <benignvulcan> > length [throwError "consternated"]
14:31:46 <lambdabot>   No instance for (Control.Monad.Error.Class.MonadError
14:31:46 <lambdabot>                     [...
14:32:03 <mreh> Baughn 6.10.4
14:32:13 <zygoloid> > [1..-5]
14:32:15 <lambdabot>   [[1,0,-1,-2,-3,-4,-5]]
14:32:21 <Baughn> mreh: Okay, so probably not a (new) ghc bug
14:32:42 <mreh> do i get a placard for uncovering a bug?
14:32:50 <Baughn> I think so.
14:32:54 <Baughn> You should take this to #ghc.
14:32:56 <mreh> yes!
14:33:11 <koeien37> the same code?
14:33:12 <Baughn> There is nothing in MonadRandom using global variables, there are no global variables in your program, this Should Not Happen.
14:33:15 <mreh> Baughn what was the result of your strace
14:33:25 <Baughn> mreh: Weird.
14:33:39 <mreh> lol
14:33:41 <Baughn> mreh: Well, nothing useful there, just the usual "stracing ghc programs" weird.
14:33:54 <koeien37> I didn't really debug it, but does the monad ever return the "next StdGen"
14:34:11 <koeien37> basically what it does, after some transofmration is StdGen -> (a, StdGen)
14:34:17 <jmcarthur> Baughn: there is a global
14:34:25 <jmcarthur> Baughn: the seed
14:34:29 <koeien37> after one invocation the StdGen should be replaced and used the next time
14:34:35 <Baughn> jmcarthur: Admittedly.
14:34:48 <jmcarthur> and what koeien37 is saying is what i am suspecting
14:34:57 <jmcarthur> but i don't see anything like randoms being used
14:34:58 <koeien37> if that StdGen is not replaced correctly (because for some reason it is never calculated completely), you will get an infinite loop
14:35:12 <koeien37> waiting for the _new_ StdGen to be calculated
14:36:00 <Baughn> Oh, let me read this..
14:36:13 <jmcarthur> there is a fair bit of recursion in this program. perhaps there is some nontermination on the StdGen
14:36:29 <koeien37> jmcarthur: that was my suspicion earlier tonight. I didn't really look into it though
14:36:39 <jmcarthur> (this is one of the reasons that i hate explicit recursion)
14:36:45 <mreh> jmcarthur: it's programmed in the lazy style
14:36:46 <zygoloid> mreh: is mixN' supposed to terminate?
14:36:46 <jmcarthur> (so hard to tell what's happening)
14:36:49 <Baughn> Well, handling the gen should be taken care of by the Random monad, though
14:36:52 <mreh> zygloid: no
14:37:00 <jmcarthur> mreh: that's the problem!
14:37:06 <Baughn> Since that monad invocation returns, it /should/ be fine
14:37:12 <benignvulcan> > length [throwError "consternated" :: (MonadError String m) => m Int]
14:37:13 <mreh> yes :D
14:37:13 <lambdabot>   No instance for (Control.Monad.Error.Class.MonadError
14:37:13 <lambdabot>                     G...
14:37:23 <jmcarthur> Baughn: nope, you can get the value without finishing the StdGen, can't you?
14:37:48 <Baughn> Uguu..
14:37:58 <Baughn> Laziness.. approaching critical
14:38:06 <jmcarthur> mreh: you are generating an infinite list in the Rand monad even though you only use some of the values
14:38:10 <luite> hm, is there a more accessible XML library than HXT?
14:38:18 <mreh> jmcarthur, okay
14:38:19 <koeien37> HaXml is probably more accessible
14:38:29 <jmcarthur> mreh: the StdGen is returned to the global as an unevaluated thunk
14:38:38 <jmcarthur> mreh: and it needs infinite computation to get the "final" StdGen
14:38:42 <Baughn> jmcarthur: I think the correct fix for this would be to make MonadRandom use newStdGen instead
14:38:50 <jmcarthur> mreh: even though you aren't using all the elements of the list
14:38:53 <Baughn> At least for the IO variant
14:39:05 <jmcarthur> Baughn: i agree
14:39:10 <benignvulcan> > length [(throwError :: String -> Either String Int) "consternated"]
14:39:12 <lambdabot>   1
14:39:22 <jmcarthur> so it's really a bug in MonadRandom
14:39:23 <Baughn> jmcarthur: Hang on, right now it'd also serialize a program using it
14:39:25 <Baughn> Yeah.
14:39:32 <jmcarthur> but not unavoidable in client code
14:39:34 <koeien37> maybe there is another helper function that does that?
14:39:35 <kmc_> > length [Left "consternated"]
14:39:36 <lambdabot>   1
14:39:57 <kmc_> > sequence [Left "foo", Left "bar"]
14:39:57 <Baughn> koeien37: Nope
14:39:58 <lambdabot>   Left "foo"
14:39:59 <jmcarthur> koeien37: well, we could just generate a StdGen manually and then use it
14:40:04 <kmc_> > sequence [Right "foo", Left "bar"]
14:40:05 <lambdabot>   Left "bar"
14:40:07 <kmc_> > sequence [Right "foo", Right "bar"]
14:40:09 <lambdabot>   Ambiguous type variable `a' in the constraints:
14:40:09 <lambdabot>    `GHC.Show.Show a'
14:40:09 <lambdabot>      a...
14:40:18 <sproingie> har
14:40:21 <kmc_> > sequence [Right "foo", Right "bar"] :: Either String [String]
14:40:22 <lambdabot>   Right ["foo","bar"]
14:40:27 <Baughn> mreh: So, not a GHC bug. Sorry.
14:40:34 <jmcarthur> mreh: so the quick fix is to do what i just told koeien37
14:40:46 <Baughn> newStdGen, then evalRand
14:40:47 <mreh> i got that, shall i tell the maintainer
14:40:49 <jmcarthur> mreh: instead of using evalRandIO
14:40:58 <Baughn> mreh: Someone needs to. By all means. ;)
14:41:00 <benignvulcan> > length [throwError "working it out"] :: Either String Int
14:41:02 <lambdabot>   Couldn't match expected type `Data.Either.Either
14:41:02 <lambdabot>                           ...
14:41:26 <zygoloid> @type (fmap . first) mkStdGen next
14:41:27 <lambdabot> forall g. (RandomGen g) => g -> (StdGen, g)
14:41:39 <luite> koeien37: hmm, I looked at that library before, but I found the examples pretty useless... perhaps because I didn't want to use xml enough to justify the effort in understanding them
14:41:41 <benignvulcan> > length [throwError "working it out"] :: Either String [Int]
14:41:42 <lambdabot>   Couldn't match expected type `Data.Either.Either
14:41:43 <lambdabot>                           ...
14:42:34 <zygoloid> benignvulcan: length produces an Int.
14:43:01 <benignvulcan> Right.  So I can't specify anything about the supposedly ambiguous innards of the list from outside.
14:43:18 <foolio_> what is the best tutorial to learn how to use Edison structures?
14:43:26 <zygoloid> no, function application binds tighter than ::. you can say...
14:43:41 <foolio_> the docs state what is there in the library, but not so much how to use the structures
14:43:47 <zygoloid> > length ([error "blargh"] :: [Either String Int])
14:43:49 <lambdabot>   1
14:43:57 <benignvulcan> But I can't seem to figure out how to type (throw "up")
14:44:10 <benignvulcan> well, (throwError "up")
14:44:41 <zygoloid> > throwError "erk!" :: Either String Int
14:44:42 <lambdabot>   Left "erk!"
14:44:44 <benignvulcan> > length [throwError "up" :: Either String Int]
14:44:46 <lambdabot>   1
14:44:58 <benignvulcan> ha, amazing
14:45:02 <mreh> jmcarthur, Baughn, works like a dream now
14:45:27 <mreh> can you think of a simple program to demonstrate this bug?
14:45:42 <mreh> i suppose an infinite lists of random numbers
14:45:46 <Baughn> Yeah.
14:46:14 <Baughn> mreh: MonadRandom is actually a mixed strict/lazy monad. How amusing. ^^;
14:46:32 <mreh> I don't get it
14:46:42 <benignvulcan> Don't see how "No instance for (Control.Monad.Error.Class.MonadError..." means I should length [throwError "up" :: Either String Int]
14:47:17 <Baughn> mreh: The returned value is calculated lazily, but the returned generator is strict in /all/ intermediate generator states
14:47:25 <Baughn> Of course, it really couldn"t be lazy
14:47:27 <zygoloid> mreh: something like: (evalRandIO . sequence . repeat $ getRandomR (0,1)) >> (evalRandIO $ getRandomR (0,1))
14:48:09 <mreh> oh, god, another program is doing it now
14:48:31 <benignvulcan> I can sort of see how the compiler demands an unambiguous list type (despite `length` ignoring the values), but I don't really understand "no instance".
14:48:48 <jmcarthur> mreh: evalRandIO . sequence . getRandoms >> evalRandIO getRandom  -- probably requiring some type annotations
14:48:58 <jmcarthur> oh i'm a dummy
14:49:09 <mreh> jmcarthur: no that does the trick
14:49:23 <jmcarthur> mreh: evalRandIO . liftM (take 10) getRandoms >> evalRandIO getRandom  -- probably requiring some type annotations
14:49:55 <jmcarthur> probably good to show you can even get some output from the first use and stil can't use it again
14:49:55 <mreh> ^^^ zygloid beat you to it
14:50:09 <jmcarthur> neither of our examples show any output
14:50:15 <mreh> okay
14:50:26 <mreh> stick a putStrLn in there
14:51:18 <c_wraith> @pl pull (a, b) = liftM ((,) a) . fromJust $ b
14:51:19 <lambdabot> pull = uncurry ((. fromJust) . fmap . (,))
14:51:19 <zygoloid> benignvulcan: the full message is "No instance for (MonadError String m)", which makes some sense since you wrote ... :: (MonadError String m) => m Int
14:51:47 <c_wraith> huh.  that's actually shorter.  I didn't see that coming.
14:52:09 <zygoloid> @slap c_wraith for using fromJust
14:52:09 * lambdabot pushes c_wraith for using fromJust from his chair
14:52:27 <jmcarthur> :t \(a, b) -> liftM ((,) a) . fromJust $ b
14:52:29 <lambdabot> forall t a1 (m :: * -> *). (Monad m) => (t, Maybe (m a1)) -> m (t, a1)
14:52:36 <olsner> for "using fromJust from his chair" :)
14:52:47 <benignvulcan> > length [throwError "unspecified"]
14:52:48 <lambdabot>   No instance for (Control.Monad.Error.Class.MonadError
14:52:49 <lambdabot>                     [...
14:52:51 <c_wraith> how did \bot know I was in a chair!
14:53:15 * olsner fromJusts leisurely in his chair
14:53:21 <c_wraith> fromJust isn't wrong, in this case.  This is much clearer as separate filter and map steps
14:53:43 <mreh> I've just applied the fix to another program, but that one doesn't work anymore
14:53:45 <zygoloid> you can't catMaybes?
14:53:46 <benignvulcan> I have to specify the type of the list elements, *and* get it right?
14:53:46 <aavogt> you know mapMaybe?
14:53:47 <mreh> hard to say why
14:54:07 <c_wraith> zygoloid: the Maybe is one element of the pair.  so no.
14:54:18 <olsner> well, fromJust implies non-totality since each application is a pattern match failure waiting to happen
14:54:18 <gwern> http://www.americanscientist.org/issues/pub/group-theory-in-the-bedroom/4 <-- you know, I think this is the clarest explanation of groups I've ever seen
14:54:30 <zygoloid> benignvulcan: usually you don't need to since it's used in a context where the type can be deduced
14:54:38 <benignvulcan> well yes
14:54:55 <olsner> if you *know* they're all "Just", why have maybe in the type at all - if you *don't know*, you don't know and can't use fromJust anyway
14:55:20 <mreh> jmcarthur, Baughn, there's another side effect to this error
14:55:20 <olsner> fromJust is smelly
14:55:25 <c_wraith> olsner:  Like I said.  clearer with independent filter and map steps
14:55:30 <aavogt> :t uncurry (fmap . (,))
14:55:31 <lambdabot> forall a (f :: * -> *) a1. (Functor f) => (a1, f a) -> f (a1, a)
14:55:49 <Baughn> mreh: Yes?
14:55:55 <olsner> c_wraith: ooh, I thought you were saying clearer *than* filter and map steps
14:56:01 <mreh> jmcarthur, Baughn, infact, I think it stems further than just evalRandIO
14:56:12 <zygoloid> c_wraith: why not do it the other way around?
14:56:38 <Baughn> mreh: I'm /quite/ certain that no pure function should be able to affect global state, and evalRandIO is it
14:57:37 <mreh> Baughn, this is all Monadic stuff though
14:57:45 <zygoloid> @type let pull = uncurry (fmap . (,)) in catMaybes . map (fmap pull . pull) -- c_wraith
14:57:46 <lambdabot> forall a (f :: * -> *) a1. (Functor f) => [(a, Maybe (f a1))] -> [f (a, a1)]
14:57:50 <mreh> i just realised what I said
14:57:56 <Baughn> mreh: Monads aren't magic.
14:58:24 <Baughn> mreh: If you mean that using an infinite loop inside monadrandom will cause any further use of it afterwards to lock up, then yes, it will. :P
14:58:45 <Baughn> Really, I get the impression that MonadRandom should either be strict, or use split a lot.
14:58:48 <mreh> Baughn, that's what is happening
14:59:15 <mreh> so we can make another suggestion to Cale about MonadRandom then
14:59:20 <Baughn> mreh: That's unavoidable, but it isn't quite as pathological as evalRandIO doing the same /globally/
14:59:27 <Cale> nyao?
14:59:42 <zygoloid> Baughn: splitting a lot would be nasty performance-wise. in the evalRandIO case, could it unsafePerformIO the random number generation steps? :)
14:59:54 <Baughn> Cale: MonadRandom. Infinite loops. The thing is insufficiently lazy, or possibly insufficiently strict.
15:00:10 <zygoloid> unsafeInterleaveIO is enough i think actually
15:00:19 <Baughn> zygoloid: No, it's unneccessary
15:00:29 <Baughn> Actually, MonadRandom is already built on State..
15:00:38 <Baughn> It should be able to just grab the random numbers as needed
15:01:10 <sproingie> my golden rule for matress flipping: four inch temperfoam pad on top of the mattress.  what flipping?
15:02:02 <foolio_> my golden rule: replace the matress as needed
15:02:23 <mreh> my advice: don't cook with matresses
15:02:34 <zygoloid> @type let mattress of sproingie =( 4" temperfoam + sprung base (10") in flip mattress
15:02:36 <lambdabot> parse error on input `of'
15:02:47 <zygoloid> @type let mattress (sproingie's) =( 4" temperfoam + sprung base (10") in flip mattress
15:02:48 <lambdabot> forall t a b. (Num ([Char] -> a -> b)) => a -> t -> b
15:03:08 <zygoloid> @faq can haskell flip your mattress?
15:03:09 <lambdabot> The answer is: Yes! Haskell can do that.
15:03:29 <aavogt> > s
15:03:31 <lambdabot>   s
15:03:43 <mreh> :t a
15:03:44 <lambdabot> Expr
15:05:32 <edwardk> i finally got around to figuring out why the state monad is isomorphic to the codensity monad of reader.(which explains a bit about that monad-ran package of mine)
15:05:52 <Taejo> what is codensity?
15:05:59 * zygoloid takes cover
15:06:09 <Paczesiowa> how hard would be to check if two strings represent equal types?
15:06:12 <damd> a zygohistopropoisohomomorphism
15:06:17 <jmcarthur> actually. the problem is not not using split
15:06:25 <edwardk> codensity is 'ContT' for a functor that may or may not be a monad, where you universally quantify over the result type of the continuation.
15:06:28 <jfoutz> dual of continuation, one more time
15:06:30 <jmcarthur> the problem is the explicit recursion instead of using getRandoms
15:06:48 <edwardk> newtype Codensity f a = Codensity (forall r. (a -> f r) -> f r)
15:06:51 <jmcarthur> (assuming getRandoms uses split)
15:07:32 <edwardk> basically i started building a bunch of right kan extension transformers, because the types fit without understanding exactly why it all worked out so well,
15:07:41 <edwardk> it finally clicked why some of them had the right form
15:07:53 <edwardk> er i guess that isn't so much of a 'basically'
15:07:59 <Cale> Paczesiowa: I'm not sure I understand
15:08:15 <Cale> Paczesiowa: Using the GHC API, there might be a way, but I'm not sure.
15:08:41 <zygoloid> @djinn ((a -> f r) -> f r) -> (a -> ((b -> f r) -> f r)) -> ((b -> f r) -> f r)
15:08:42 <lambdabot> f a b c = a (\ d -> b d c)
15:09:21 <edwardk> a right kan extension where all of the functors are endofunctors over Hask looks like newtype Ran f g a = Ran (forall r. (a -> f r) -> g r) -- where f and g are functors in some category, preferably, but not necessarily, Hask.
15:09:32 <Paczesiowa> Cale: i get types using typeOf from hint, but I cannot compare those strings for equality (doesn't make sense)
15:09:35 <edwardk> er are endofunctors over some category
15:10:09 <edwardk> zygoloid: exactly
15:10:13 <Baughn> zygoloid: I take it back. Sort of. You don't need unsafeInterleavIO - you need unsafeInterleaveST, otherwise you'd also need unsafePerformIO.
15:10:57 <edwardk> zygoloid: i have that definition buried in category-extras and in monad-ran
15:11:08 <edwardk> zygoloid: modulo newtype noise
15:11:10 <zygoloid> Baughn: doesn't that mean you have to add a phantom type to your random monad?
15:11:26 <Baughn> zygoloid: But I'm not very happy about generating random numbers in order of thunk evaluation. It's still sort-of, just-barely, if-you-squint pure, but it makes my ziver itch, and I don't even /have/ that organ.
15:11:44 <Paczesiowa> Cale: some canonical form would be great (sorted type constraints, inlined type synonym definitions, variable naming that depends on its position to avoid alpha-conversion problems)
15:11:57 <zygoloid> Baughn: i know what you mean. there's random and then there's nondeterministic ... :)
15:12:17 <Baughn> zygoloid: I'm not sure, though I suspect you could get away without the free variable. I'm not going to investigate it, either. This is a horrible idea.
15:12:39 <edwardk> so what i noticed is i had all of the machinery to explain why most of the monad-ran stuff worked out with the types it did... in a blog post i wrote myself two years ago =/
15:12:42 <zygoloid> i seem to recall a supply monad on hackage which took a list and gave out elements in the order the thunks were forced...
15:13:07 <zygoloid> (with unsafePerformDeepestVoodooEvil of course)
15:13:07 <Baughn> zygoloid: Yeah. The random numbers would vary unpredictably depending on input (bad enough), but /also on evaluation order, optimization, and parallelization/
15:13:41 <Baughn> Turning on the optimizer could make the program produce different output..
15:13:50 <Baughn> Aha. That's not even pure if you squint.
15:13:52 <edwardk> so what i needed was why Ran ((->)s) ((->)s) a ~ State s a, where State s a ~ s -> (s,a) -- the arguments being slightly flipped for sanity
15:14:14 <zygoloid> Baughn: it's pure if your source of entropy is already nondetermistic, isn't it?
15:14:23 <c_wraith> argh.  stupid monomorphism restriction
15:14:35 <edwardk> but State s a is the monad given rise to by the adjunction between hom and prod as i noted in: http://comonad.com/reader/2008/kan-extensions-ii/
15:14:42 <edwardk> a fairly common observation
15:15:04 <edwardk> instance Adjunction ((,)e) ((->)e) where leftAdjunct f a e  = f (e,a); rightAdjunct f ~(e,a) = f a e
15:15:35 <Baughn> zygoloid: That's the if-you-squint version, and it might be good enough for some. I've got a random generator that does exactly that, but making it is in IO.
15:15:46 <Baughn> zygoloid: Problem is, MonadRandom, allows you to use a /deterministic/ seed
15:16:45 <edwardk> and, given an adjunction between two functors f and g, you can appeal to a relationship between the right kan extension and the adjunction: there is an isomorphism between Ran g h a and (h `O` f) a -- again assuming f -| g
15:16:57 <Baughn> zygoloid: Generating the numbers on demand is no problem if you can't observe that, which you can only do if you can control the seed
15:17:15 <edwardk> but I have an adjunction:  (,) e -| (->) e
15:18:01 <edwardk> so plugging it in, Ran ((->) e) h ~ (h `O` (,) e)
15:18:33 <edwardk> which when h is (->)e -- is the same as saying that Ran ((->)e) ((->)e ~ State e
15:18:36 <zygoloid> Baughn: yeah, this is why i only wanted to target the evalRandIO case (where you can't specify the seed explicitly)
15:18:40 * hackagebot upload: hricket 0.5 - A Cricket scoring application. (AnthonySimpson)
15:18:53 <edwardk> which is how i finally excuse the isomorphism between codensity reader and state
15:19:08 <edwardk> realized it on the drive home and it made me very happy =)
15:19:22 <zygoloid> edwardk: what you just said has the aura of text that, if read, will make my head explode
15:20:04 <edwardk> zygoloid: meh, you can get there much easier, just by looking at the types without all the synonyms, but then the results don't generalize to all my other right kan extension transformers
15:20:24 <Baughn> zygoloid: All right, I think I'll do that. It should be factorizable to a RandomGen(^2) wrapper that just makes split very cheap indeed.
15:20:25 <jfoutz> where is instance Functor ((->) r) defined? i can't seem to work out the hoogle syntax
15:21:08 <zygoloid> jfoutz: Control.Monad.Instances maybe :o
15:21:21 <edwardk> zygoloid: basically i use the fact that you can make a 'cps transformed' state monad. (forall r. (a -> s -> r) -> s -> r), which you can do everything you can do with s -> (a,s)
15:21:35 <Paczesiowa> how do I import hidden modules?
15:21:49 <Veinor> f "x" "fooxxbarxxxxbaz" = ["foo", "bar", "baz"]
15:21:50 <edwardk> jfoutz: zygoloid is right
15:21:56 <Veinor> does f have a name?
15:22:02 <jfoutz> hrm. ok, thanks!
15:22:08 <mauke_> probably one of the splits
15:22:15 <koeien37> Veinor: not in the prelude
15:22:36 <koeien37> it may be instructive to write one with span
15:22:56 <sshc> how do I change a single field of a data type that uses record syntax without using any hackage packages?
15:23:00 <koeien37> if you're lazier, there is a package
15:23:02 <mauke_> wordsBy ('x' ==)
15:23:18 <mauke_> sshc: x{ y = z }
15:23:24 <Veinor> wordsBy?
15:23:33 <mauke_> it's in Data.List.Split
15:23:34 <sshc> mauke_: what should each of those refer to?
15:23:35 <Veinor> hoogle says no such
15:23:41 <koeien37> hayoo
15:23:44 <edwardk> now what might be interesting to explore is if i can use left kan extension transformers to obtain anything interesting, but i think in the end it does nothing that isn't secretly handled by closure conversion
15:23:51 <mauke_> Veinor: hoogle isn't omniscient
15:23:51 <sshc> @data Foo = Foo {bar1, bar2, bar3 :: Int}
15:23:51 <lambdabot> Unknown command, try @list
15:23:58 <koeien37>  wordsBy (=='x') "dogxxxcatxbirdxx" == ["dog","cat","bird"] -- almost your example :o
15:23:59 <Veinor> yeah.
15:24:16 <Veinor> is hayoo better or worse than hoogle?
15:24:26 <koeien37> i find myself more often at hayoo nowadays
15:24:36 <koeien37> it has more packages indexed
15:24:58 <koeien37> but it can't search on types AFAIK
15:24:58 <mauke_> preflex: seen ndm
15:24:59 <preflex>  ndm was last seen on #haskell 241 days, 13 hours, 6 minutes and 18 seconds ago, saying: plus with current compiler technology, it would be slower
15:25:21 <Veinor> hm
15:25:41 <Veinor> wordsBy does indeed Do What I Need
15:25:44 <koeien37> oh it can
15:25:57 <Veinor> but I think I want to write it anyway, because this is going to be for a class, and I don't want to have to teach everybody how to set up cabal :P
15:26:08 <koeien37> right
15:26:13 <koeien37> :t span -- useful
15:26:14 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
15:26:33 <mauke_> wordsBy = split . dropBlanks . dropDelims . whenElt
15:26:33 <koeien37> > span (=='x') "dogxxxcatxbirdxx"
15:26:35 <lambdabot>   ("","dogxxxcatxbirdxx")
15:26:46 <koeien37> > break (=='x') "dogxxxcatxbirdxx"  -- whoops
15:26:47 <lambdabot>   ("dog","xxxcatxbirdxx")
15:26:58 <dolio> > let f p [] = Nothing ; f p s = Just . fmap (dropWhile p) . break p $ s in unfoldr (f (=='x')) "dogxxxcatxbirdxx"
15:27:00 <lambdabot>   ["dog","cat","bird"]
15:27:09 <Veinor> blah
15:27:14 <Veinor> I want something I can understand :P
15:27:16 <koeien37> it's an unfold
15:27:38 <dolio> You can understand that.
15:27:41 <dolio> The power is yours!
15:27:44 <Veinor> mauke_: also, whenElt is in Split as well :P
15:28:12 <Veinor> hm.
15:28:21 <mauke_> > let f p [] = Nothing ; f p s = Just . fmap (dropWhile p) . break p $ s in map (unfoldr (f (=='x'))) ["", "x", "a", "xxx", "xax", "xaxb"]
15:28:22 <lambdabot>   [[],[""],["a"],[""],["","a"],["","a","b"]]
15:28:46 <mauke_> dolio: fail
15:29:48 <koeien37> i wouldn't use dropWhile I guess, and just drop the empty lists afterwards
15:31:12 <dolio> Needs a little preprocessing is all.
15:31:26 <dolio> Or view patterns.
15:32:09 <zygoloid> > unfoldr (\xs -> case break (=='x') xs of ([],[]) -> Nothing; (w,ys) -> Just (w, dropWhile (=='x') ys)) "fooxxbarxxxbaz"
15:32:11 <lambdabot>   ["foo","bar","baz"]
15:32:33 <dolio> > let f p (dropWhile p -> []) = Nothing ; f p (dropWhile p -> s) = Just . break p $ s in map (unfoldr (f (=='x'))) ["","x","a","xxx","xax","xaxb"]
15:32:35 <lambdabot>   Illegal view pattern:  (dropWhile p -> [])
15:32:35 <lambdabot>  Use -XViewPatterns to enable vi...
15:32:44 <dolio> Whaaaat?
15:32:56 <mauke_> > map (unfoldr (\xs -> case break (=='x') xs of ([],[]) -> Nothing; (w,ys) -> Just (w, dropWhile (=='x') ys))) ["", "x", "a", "xxx", "xax", "xaxb"]
15:32:57 <lambdabot>   [[],[""],["a"],[""],["","a"],["","a","b"]]
15:33:22 <mauke_> seriously, "xax" should not return ["", "a"]
15:33:33 <sshc> is there a way to "include" a haskell source file similar to the manner of doing it in C?
15:33:50 <koeien37> you can use a preprocessor
15:33:57 <koeien37> {-# LANGUAGE CPP #-}
15:34:02 <dolio> > let f p [] = Nothing ; f p s = Just . fmap (dropWhile p) . break p $ s in map (unfoldr (f (=='x')) . dropWhile (=='x')) ["","x","a","xxx","xax","xaxb"]
15:34:03 <sshc> koeien37: oh, I don't need to pass a flag?
15:34:04 <lambdabot>   [[],[],["a"],[],["a"],["a","b"]]
15:34:12 <sshc> koeien37: great
15:34:24 <dolio> preflex: seen Cale
15:34:24 <preflex>  Cale was last seen on #haskell 26 minutes and 9 seconds ago, saying: Paczesiowa: Using the GHC API, there might be a way, but I'm not sure.
15:34:33 <sshc> koeien37: in which files to I need to add {-# LANGUAGE CPP #-}?
15:34:48 <koeien37> the files that you want preprocessed
15:34:54 <c_wraith> @pl m f x = g x (f (h x))
15:34:54 <lambdabot> m = ap g . (. h)
15:34:57 <sshc> right
15:35:05 <mauke_> sshc: why do you want to do that?
15:36:14 <zygoloid> > let f'x'=' ';f' '='x';g=map f.words.map f in map g ["", "x", "a", "xxx", "xax", "xaxb"]
15:36:15 <lambdabot>   <no location info>: parse error on input `;'
15:36:45 <sproingie> spacing fail there
15:37:44 <zygoloid> > let f 'x'=' ';f ' '='x';f a=a;g=(map.map)f.words.map f in map g ["", "x", "a", "xxx", "xax", "xaxb"]
15:37:45 <lambdabot>   [[],[],["a"],[],["a"],["a","b"]]
15:38:14 <mauke_> I'm not sure if [] is the right answer for ""
15:38:14 <Veinor> I have a definition of the function that works, whoo
15:38:28 <Veinor> and is pretty simple
15:38:36 <Veinor> f p xs = let broken = break p xs in dropWhile ("" ==) $ fst broken : f p (dropWhile p $ snd broken)
15:38:38 <zygoloid> mauke_: if you want ["a"] for "xax" then i think [] is right for ""
15:38:50 <Veinor> er, replace "" with [] :P
15:39:05 <Veinor> actually, replace ([] ==) with null
15:39:05 <benmachine> hi I'm having difficulty finding any decent documentation on syb since http://www.cs.vu.nl/boilerplate/ is 403ing me
15:39:06 <zygoloid> Veinor: replace (""==) with null
15:39:13 <Veinor> yeah.
15:39:20 <mauke_> zygoloid: ok, perl agrees :-)
15:39:31 <Veinor> so f p xs = let broken = break p xs in dropWhile null $ fst broken : f p (dropWhile p $ snd broken)
15:39:35 <Veinor> and f p [] = []
15:39:41 <benmachine> does anyone know where else I can find the SYB original papers, or any other introduction to Data.Generics and friends?
15:40:39 <sproingie> benmachine: http://research.microsoft.com/en-us/um/people/simonpj/Papers/hmap/
15:40:48 <mauke_> http://mauke.ath.cx/stuff/papers/syb1.pdf http://mauke.ath.cx/stuff/papers/SYB3.ppt possibly related
15:40:57 <sproingie> papers in .ps unfortunately
15:41:02 <benmachine> thanks
15:41:08 <mauke_> firefox 1.0.2? you're doing it wrong
15:43:03 <mauke_> yes, thanks
15:43:23 <mauke_> but that's a different ip address
15:43:26 <benmachine> :P
15:43:27 <c_wraith> hah.  I finally figured out precisely what ap is in ((->) a)
15:43:35 <Veinor> actually, I could just use takeWhile and dropWhile
15:43:42 <Cale> c_wraith: It's S :)
15:43:57 <c_wraith> Cale:  I've never learned SKI calculus
15:44:07 <dolio> Cale: We need view patterns.
15:44:13 <xerox> > ap f g x y :: Expr
15:44:13 <lambdabot>   Ambiguous type variable `a' in the constraints:
15:44:14 <lambdabot>    `SimpleReflect.FromExpr ...
15:44:19 <xerox> :/
15:44:27 <sshc> why is this not compiling?  "import Graphics.UI.SDL.General (init) as S"  the error is "parse error on input `as'""
15:44:28 <dolio> > let f (id -> x) = x in f 5
15:44:29 <lambdabot>   Illegal view pattern:  (id -> x)
15:44:30 <lambdabot>  Use -XViewPatterns to enable view patterns
15:44:40 <Paczesiowa> sshc: as S (init)
15:44:48 <Paczesiowa> sshc: and qualified!
15:44:50 <sshc> Paczesiowa: oh, ok
15:44:58 <c_wraith> But I wondered for a while how to do what ap does.  I finally figured out the name of it
15:45:06 <Paczesiowa> sshc: qualified was the problem, disregard the first "answer"
15:45:36 <sshc> Paczesiowa: no it wasn't
15:45:45 <sshc> Paczesiowa: I don't want qualified because I only want to type "S." for ambiguous occurences
15:45:51 <xerox> > ap (f :: Expr -> Expr -> Expr) g x
15:45:52 <lambdabot>   f x (g x)
15:46:00 <Paczesiowa> sshc: then use two imports for this module
15:46:03 <c_wraith> generally, I've been looking for how to write modify cleanly.  ap does it.
15:46:05 <xerox> > (=<<) (f :: Expr -> Expr -> Expr) g x
15:46:06 <lambdabot>   f (g x) x
15:46:09 <xerox> :)
15:46:11 <Paczesiowa> sshc: one with hiding, and one qualified
15:46:14 <sshc> Paczesiowa: why?
15:46:32 <sshc> Paczesiowa: putting "as S" before the list of things to export solved it
15:46:32 <c_wraith> modify f = put `ap` (f . get)
15:46:52 <Paczesiowa> sshc: hmm, good to know, I guess:)
15:47:39 <zygoloid> @set -XViewPatterns
15:47:40 <lambdabot>   Parse error: SemiColon
15:47:42 <Zariel> how do I do something like, [ p | p <- [ 1 .. ], p < 10 ] and make it stop?
15:47:51 <c_wraith> It's unfortunate `ap` and . have the same infix precedence
15:48:02 <mauke_> Zariel: takeWhile
15:48:10 <c_wraith> >  [ p | p <- [ 1 .. ], p < 10 ]
15:48:14 <lambdabot>   mueval-core: Time limit exceeded
15:48:26 <benmachine> > [ p | p <- [1 .. 10] ]
15:48:28 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
15:48:31 <Saizan> c_wraith: modify f = fmap put f `ap` get ?
15:48:48 <Saizan> ?type \f -> fmap put f `ap` get
15:48:49 <lambdabot> forall a a1 (m :: * -> *). (MonadState a ((->) a1), Functor m, MonadState a1 m) => m a -> m ()
15:48:55 <Saizan> ugh
15:49:15 <Saizan> oh, right
15:49:23 <Saizan> ?type \f -> fmap put f =<< get
15:49:25 <lambdabot> forall (m :: * -> *) a. (MonadState a m) => (a -> a) -> m ()
15:49:43 <benmachine> @type \f -> put (fmap f get)
15:49:44 <lambdabot> forall a b (f :: * -> *) (m :: * -> *). (MonadState a f, Functor f, MonadState (f b) m) => (a -> b) -> m ()
15:49:52 <mauke_> ?type \f -> (.) put f =<< get
15:49:53 * benmachine blinks
15:49:53 <lambdabot> forall (m :: * -> *) a. (MonadState a m) => (a -> a) -> m ()
15:50:03 <benmachine> oh, silly me
15:50:30 <c_wraith> mauke's cheating with caleskell. :)
15:50:39 <mauke_> I don't think so
15:50:58 <c_wraith> :t put <$> f =<< get
15:51:00 <lambdabot> forall (m :: * -> *) a. (MonadState a m, SimpleReflect.FromExpr a, Show a) => m ()
15:51:20 <c_wraith> :t \f -> put <$> f =<< get
15:51:21 <lambdabot> forall (m :: * -> *) a. (MonadState a m) => (a -> a) -> m ()
15:51:43 <mauke_> ?type \f -> (Prelude..) put f =<< get
15:51:44 <lambdabot> forall (m :: * -> *) a. (MonadState a m) => (a -> a) -> m ()
15:52:18 <c_wraith> :t \f -> put . f =<< get
15:52:20 <lambdabot> forall (m :: * -> *) a. (MonadState a m) => (a -> a) -> m ()
15:54:06 <Zariel> what about if I wanted to take elements from the list, sum them untill the sum reaches a limit?
15:54:49 <mauke_> > head . dropWhile (< 1000) . scanl (+) 0 $ [0 ..]
15:54:50 <lambdabot>   1035
15:56:02 * hackagebot upload: explicit-iomodes 0.1.4 - File handles with explicit IOModes (BasVanDijk)
15:57:13 <jfoutz> > fix (\r (x:xs) s -> if s < 1000 then r xs (x+s) else s) [0..] 0
15:57:15 <lambdabot>   1035
15:58:25 * edwardk had to laugh. http://events.ccc.de/congress/2009/Fahrplan/events/3576.en.html
15:59:45 <Veinor> how can I install http://home.arachsys.com/~chris/haskell-ghci.el into emacs?
15:59:55 <mauke_> edwardk: why?
16:00:08 <edwardk> mauke: i just love when
16:00:12 <Veinor> Although quantum cryptography has been proven unconditionally secure, by exploiting physical imperfections (detector vulnerability) we have successfully built an intercept-resend attack and demonstrated eavesdropping under realistic conditions on an installed quantum key distribution line.
16:00:21 <edwardk> provably secure systems are broken because of an implementation detail
16:00:27 <Veinor> "Although this system has been proven secure, you can still eavesdrop on it."
16:00:47 <sproingie> it's secure til you observe it
16:01:40 <zygoloid> that's the difference between theory and practice: in theory there's no difference between theory and practice
16:01:50 <edwardk> sproingie: yes, but to me the whole point of quantum crypto is supposed to be the lack of a non-detectable observer model.
16:01:58 <Zariel> is there an equivalent of 1e3?
16:02:06 <zygoloid> > 1e3
16:02:08 <lambdabot>   1000.0
16:02:14 <Zariel> eh
16:02:39 <Zariel> wrong error, ll
16:02:40 <Zariel> lol
16:02:45 <Veinor> edwardk: I'm interested, how do they get around the usual 'compare 1/10 of your bits' step
16:03:04 <sproingie> edwardk: it was a joke
16:03:09 <sproingie> it was funny until it was observed
16:03:16 <sproingie> hey that trick works for a lot of things
16:03:33 <mauke_> it makes sense if you don't think about it!
16:03:47 <sproingie> now you're getting it.  as long as you don't.
16:04:28 <sproingie> lewis carrol would have had a lot of fun with QM
16:04:32 <dolio> "Puke" is a funny word. I like things you don't have to think about too much.
16:04:33 <idnar> haha
16:05:05 <edwardk> Veinor: they can force the receptor on either end to give the answer they want by exploiting the properties of extant photosensors
16:06:09 <sproingie> so it's more about exploiting the construction than the theory?
16:06:14 <edwardk> sproingie: yes
16:06:20 <Veinor> edwardk: but doesn't only one person have to send a photon?
16:06:23 <sproingie> sounds fixable.  theoretically.
16:06:32 <Veinor> ahh, now I think I see it
16:06:47 <edwardk> Veinor: Single photon detectors based on passively quenched avalanche photodiodes are used in a number of quantum key distribution experiments. A vulnerability has been found in which these detectors can be temporarily blinded and then forced to produce a click [1]. An attack exploiting this vulnerability against a free-space polarization based quantum cryptosystem [2,3] is feasible. By controlling the polarization o
16:07:07 <edwardk> veinor: just intercept and repeatedly blind the one side in the pattern you desire
16:07:13 <jfoutz> @hoogle a -> b -> (Bool -> Either a b)
16:07:14 <lambdabot> Text.Parsec.Prim runP :: Stream s Identity t => Parsec s u a -> u -> SourceName -> s -> Either ParseError a
16:07:14 <lambdabot> Text.Parsec.Prim runParser :: Stream s Identity t => Parsec s u a -> u -> SourceName -> s -> Either ParseError a
16:07:14 <lambdabot> Text.ParserCombinators.Parsec.Prim runParser :: GenParser tok st a -> st -> SourceName -> [tok] -> Either ParseError a
16:08:53 <Veinor> edwardk: but part of the protocol is for A and B to compare random bits from the key
16:08:56 <Veinor> ahhh
16:08:57 <Veinor> okay
16:09:14 <Veinor> anyway.
16:09:30 <Dashkal> Hoogle is working for base libs again? *dances*
16:09:47 <Veinor> yeah :P
16:10:58 <edwardk> found a reference via schneier. http://www.schneier.com/blog/archives/2009/12/quantum_cryptog_1.html with more commentary
16:11:44 <xerox> schneier book is full of errors! there! I said it!
16:12:14 <edwardk> xerox: he's also made a career out of telling people not to try to implement dumb cryptosystems based on partially understanding his first book ;)
16:12:44 <Adamant> one-time pads are proven secure.. as long as you don't violate any of the assumptions the proof is based on... which there are quite often strong temptations to violate in the real world
16:12:44 <xerox> and his passion for squids is creepy :P
16:12:48 <sshc> I've always been impressed with how often Haskell programs work flawlessly on first run, compared to C.
16:13:35 <ben> sshc: I always thought Haskell's greatest strength were the low expectations of your typical imperative programmer ;)
16:13:51 <edwardk> heh, and video
16:13:55 <edwardk> http://mirror.fem-net.de/CCC/26C3/mp4-ipod/26c3-3576-de-how_you_can_build_an_eavesdropper_for_a_quantum_cryptosystem_iProd.mp4
16:14:09 <sproingie> OTP is perfectly secure as long as you have a channel to transmit it
16:15:11 <xerox> edwardk yeah, the torrent is pretty fast too
16:15:49 <mauke_> oh yeah, I've had 1.5Mb downstream with the torrents
16:16:05 <sproingie> i like schneier because he seems to actually understand the human element too
16:16:12 <mauke_> wait, or is that MB
16:17:14 <sproingie> the first rule according to Schneier is "is this even worth securing"?
16:17:36 <xerox> omg http://brownsharpie.courtneygibbons.org/?p=1216
16:18:13 <Veinor> Has anybody here has any luck with haskell-ghci.el?
16:18:21 <sproingie> works fine for me
16:18:23 <xerox> I have!
16:18:31 <Veinor> I can't get the keybindings to work.
16:18:35 <Paczesiowa> isn't it deprecated?
16:18:40 <Vulpyne> I have a monad transformer stack that contains two Error monads. I'm able to lift throwError to throw the inner type, but applying lift to catchError doesn't seem to work.
16:18:41 <Veinor> Paczesiowa: in favor of?
16:18:46 <sproingie> there are special keybindings in that mode?
16:18:54 <xerox> Vulpyne maybe it's better to sum the errors?
16:18:54 <Vulpyne> I'm probably doing something dumb, but I don't see it...
16:19:01 <Paczesiowa> Veinor: I don't know, but it just work with haskell-mode for me
16:19:04 <Veinor> the keybindings to open a ghci session, reload the current file, etc.
16:19:13 <Vulpyne> xerox: One of the Error monads is in an external library, and one's in my application.
16:19:17 <zygoloid> @type catchError
16:19:18 <lambdabot> forall (m :: * -> *) a e. (MonadError e m) => m a -> (e -> m a) -> m a
16:19:19 <sproingie> oh those are bindings in haskell-mode
16:19:23 <Veinor> ah
16:19:35 <xerox> Vulpyne ah too bad
16:19:36 <zygoloid> Vulpyne: ^^ that's the problem. the first argument won't be 'm a'
16:19:50 <zygoloid> (at least, not for the right m)
16:19:51 <Vulpyne> zygoloid: Is there any way for me to catch it?
16:20:02 <Vulpyne> Or did I paint myself into a corner with that design.
16:20:14 <Paczesiowa> Vulpyne: run outer layers, catch error, wrap again
16:20:17 <Veinor> maybe I should use the latest haskell-mode instead of ubuntu's
16:20:19 <zygoloid> you'd need to run the outer monad to get a value of the right type
16:20:34 <Vulpyne> Ugh.
16:20:45 <Paczesiowa> Veinor: what version do you use? It worked for me even before it was ressurected
16:20:52 <Vulpyne> Well, thanks for the help.
16:20:57 <Veinor> 2.4-1
16:21:08 <Veinor> what're the ghci keybindings?
16:21:10 <Paczesiowa> Vulpyne: why do you have two error layers?
16:21:22 <Paczesiowa> Veinor: load is C-c C-l
16:21:23 <sproingie> i dont think there's a key within the inferior haskell mode buffer to reload
16:21:29 <Vulpyne> Paczesiowa: One thing is an interface that runs in a state/error stack.
16:21:31 <Veinor> yeah, C-c C-l doesn't work
16:21:43 <Paczesiowa> Veinor: but, that works from haskell file
16:21:48 <Vulpyne> Paczesiowa: And the other is the application that uses it which also uses a state/error stack.
16:21:58 <Veinor> I just tried it, it didn't work.
16:22:23 <Veinor> going to try installing manually
16:22:27 <Paczesiowa> Vulpyne: is it because you have different exceptions?
16:22:35 <Vulpyne> Paczesiowa: Yeah.
16:22:44 <Paczesiowa> Vulpyne: if so, I'd suggest using a monad with extensible exceptions
16:23:16 <Paczesiowa> Vulpyne: and perhaps Failure combinators like try if you cannot change inner monad
16:23:31 <zygoloid> Vulpyne: instead of lifting the catchError, can you wrap the catchError around the invokation in the inner monad, and lift the whole thing?
16:24:01 <Vulpyne> Hmm, I don't think so.
16:24:08 <Paczesiowa> Vulpyne: do you prefer unchecked (Attempt) or checked (control-monad-failure) exceptions?
16:24:36 <Vulpyne> I'm not completely sure what you mean.
16:24:48 <zygoloid> Vulpyne: you should be able to transform inner monad errors into outer monad errors  that way
16:27:02 <Vulpyne> I need to catch and handle the error right where it happens.
16:27:10 <Vulpyne> Not once it's propogated far up the callstack (if that's what you meant)
16:28:05 <Veinor> bleh. okay, I just downloaded the latest haskell-mode. now how do I enable inferior ghci?
16:28:56 <Veinor> ah, C-c C-z
16:29:08 <Veinor> whee
16:29:12 <Paczesiowa> Veinor: require it and enable haskell-mode
16:29:48 <Veinor> got it. now how do I switch via keyboard?
16:30:40 <Paczesiowa> Veinor: ?
16:30:53 <Veinor> I mean, switch between the two buffers solely though my keyboard
16:30:56 <Veinor> as opposed to clicking.
16:30:58 <Paczesiowa> C-o
16:31:03 <Paczesiowa> C-x o
16:31:25 <Veinor> \o/
16:35:06 <luite> is there an easy way to generate hoogle indexes for all installed packages?
16:35:23 <Saizan> luite: no
16:35:54 <Saizan> luite: actually, currently you need the sources to generate an hoogle index
16:36:08 <luite> even if I have haddock for all packages?
16:36:13 <Saizan> yeah.
16:37:06 <Saizan> the hoogle index is generated passing --hoogle to haddock when you feed it the sources
16:38:00 <Saizan> afaik the .haddock interfaces alone don't contain enough information to generate an hoogle index
16:38:18 <luite> hmm, is there a cabal configuration option to have it do that automatically?
16:38:36 <Saizan> it'd be really nice if they did.
16:38:48 <Saizan> luite: no
16:38:48 <luite> :)
16:40:22 <mreh> @pl (\x y z -> f y z x)
16:40:23 <lambdabot> flip (flip . f)
16:40:33 <luite> by the way, does anyone know why the HaXml data types don't implement Show?
16:41:22 <sshc> would should I use instead of the state monad when all I care about is the state itself the entire way through and not any results of state computations?
16:41:26 <Paczesiowa> you can use standalone deriving
16:41:55 <Paczesiowa> sshc: functions?
16:43:08 <jfischoff> luite: the Derive tool might come in handy
16:43:24 <Saizan> or standalone deriving.
16:43:51 <xerox> or HXT :)
16:44:02 <jfischoff> is standalone deriving recursive?
16:44:08 <jfischoff> I don't think so
16:44:30 <sshc> Paczesiowa: let {foo = bar; foo' = bar foo; foo'' = bar foo'; foo''' = quuoux foo''} can get ugly
16:45:35 <sshc> Paczesiowa: I need to refer to all of foo, foo', foo'', and foo''', which I can do using monads
16:45:40 <luite> xerox: do you know good examples that show basic stuff for HXT, and not just "look at my l33t IOListStateRandomReaderWriterArrow that does everything for you"? for example simple things like selecting some attributes or elements in pure code, adding an element somewhere etc?
16:46:04 <xerox> luite yes, there is a comprehensive tutorial on the haskellwiki
16:47:07 <Paczesiowa> sshc: what's wrong with State? you can get final state from runState
16:47:08 <xerox> http://www.haskell.org/haskellwiki/HXT  and  http://www.vex.net/~trebla/haskell/hxt-arrow/index.xhtml
16:47:29 <lispy> Hmm
16:47:33 <lispy> I think cabal is acting up
16:47:44 <jfischoff> it was earlier today
16:47:59 <luite> xerox: how do I get a pure thing that can process xml? not an IOSArrow that needs to be run with runX in IO?
16:48:04 <Saizan> sshc: that's because you should write it like "quuoux . bar . bar . bar"
16:48:09 <lispy> Not hackage, but I mean, I'm telling cabal to use base < 4, and it's picking base == 4.*
16:48:24 <jfischoff> ah :)
16:48:31 <xerox> luite I myself have used it some time ago, and it was quite nice, let me remember...
16:48:41 <xerox> (I don't remember messing with IO at all)
16:49:20 <sshc> Saizan: how do I refer to what the result of bar is before quuox then?
16:49:27 <dark> ' is valid in a haskell identifier?
16:49:32 <copumpkin> yep
16:49:35 <koeien371> yes, not at the start
16:49:40 <Saizan> sshc: you can't, but why do you want to do that?
16:49:40 <xerox> luite but maybe that was because I didn't find the ArrowXml type at all
16:49:50 <xerox> luite when writing my filters / traversals
16:49:51 <sshc> Saizan: after looking at this again, I actually do need results and the State monad would be good
16:50:28 <Saizan> xerox, luite: can't you use one of the other arrows defined in HXT?
16:51:01 <dark> hmm i see
16:51:20 <Saizan> SLA is an instance of ArrowXml too
16:51:38 <Saizan> LA too
16:52:22 <luite> hmm, I've never worked with these arrows, I don't think I need state or anything currently
16:53:24 <luite> but how to I read an xml file from a ByteString? the examples use readDocument, which returns an IOSomethingArrow
16:53:51 <Paczesiowa> luite: probably you have to inject that bytestring to an arrow with const
16:54:05 <Paczesiowa> luite: and then use readDocument version that takes input from arrow input
16:54:23 <Paczesiowa> luite: you'd probably have to go through String
16:54:42 <luite> hmm, could you give an example?
16:55:06 <lispy> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15653#a15653
16:55:24 <lispy> That is the result of:
16:55:32 <lispy> $ cabal install --reinstall show --constraint="base < 4" -v 2>&1 | grep base
16:55:40 <Paczesiowa> imo the biggest problem with HXT is, that all those functions have the same type - "I take XmlTree, I return some XmlTrees, and I can do whatever I want - IO, state, hidden failures"
16:55:46 <lispy> I'm forcing base < 4 on the commandline but then cabal uses base 4.2
16:55:56 <Saizan> readDocument is in IOStateArrow for some reason
16:56:07 <Paczesiowa> using hxt looks like coding in an imperative language, whatever you type in, compiles just fine, and you fix a lot of bugs.
16:56:39 <lispy> This only seems to happen on cabal newer than 0.6
16:57:07 <Saizan> yeah, i think it's a bug introduced with the fix to cope with two base packages.
16:57:29 <Paczesiowa> luite: use readFromString
16:57:32 <Saizan> your constraint is indeed satisfied, in a twisty way :)
16:57:39 <luite> Paczesiowa: that is IO
16:57:53 <luite> at least, it returns an IOStateArrow
16:58:07 <Paczesiowa> luite: you don't want IO?
16:58:18 <Saizan> lispy: so you need to edit the .cabal file
16:58:20 <Paczesiowa> readString
16:58:38 <luite> readString :: Attributes -> String -> IOStateArrow s b XmlTree
16:58:44 <luite> is this not the same readString?
16:59:03 <Paczesiowa> luite: oh yeah:(
16:59:05 <luite> I don't have a hoogle index so I'm not sure if there are more
16:59:28 <Paczesiowa> luite: what's wrong with IO? using hxt usually involves plenty of IO
17:00:02 <luite> Paczesiowa: I don't have any IO values, I have a ByteString, need to return a ByteString
17:00:04 <monochrom> module Text.XML.HXT.Arrow.XmlArrow does not require IOStateArrow.
17:00:06 <Ruth> The first one here to make a useful program gets to fuck me.
17:00:16 <Ruth> I feel pretty safe.
17:00:31 <Paczesiowa> luite: it needs IO for loading schema definitions and things like that
17:00:43 <luite> oh I don't need validation at all
17:00:46 <Paczesiowa> luite: if you don't need those, you could just, you know
17:00:55 <Paczesiowa> luite: do that ugly thing
17:01:04 --- mode: ChanServ set +o monochrom
17:01:17 --- mode: monochrom set +b *!*@ip68-7-5-98.sd.sd.cox.net
17:01:24 <sproingie> Ruthless
17:01:26 <luite> Paczesiowa: you mean switch to perl? :p
17:01:45 <Paczesiowa> luite: even better, unsafePerformIO!
17:01:56 <merehap> Ruth: damn, if only I weren't straight...
17:02:05 <luite> I'm pretty sure that I don't want to use HXT if I need unsafePerformIO
17:02:13 <sproingie> ironically the useful program would be one that gets rid of Ruth
17:03:41 <merehap> luite: yeah, I never needed to touch IO when I was using HXT other than the initial file reading, it is dealing with pure data transformations after all
17:04:15 <monochrom> See http://hackage.haskell.org/packages/archive/hxt/8.3.2/doc/html/Control-Arrow-ListArrow.html
17:04:29 <luite> Saizan: yes I noticed that, but I don't know how to actually use it in pure code. it alsos doesn't seem consistent with this line from the XmlArrow haddock: "All arrows use IO and a global state for options, errorhandling"
17:04:42 <monochrom> LA is an instance of ArrowXml. LA is pure-functional. instance of ArrowXml means you can do xml processing.
17:05:09 <Paczesiowa> monochrom: but parsing arrows needs IOSLA
17:05:15 <Paczesiowa> *need
17:06:15 <monochrom> http://hackage.haskell.org/packages/archive/hxt/8.3.2/doc/html/Text-XML-HXT-Arrow-ParserInterface.html#v%3AparseXmlDoc  requires just ArrowXml
17:06:23 <lispy> Saizan: but this released version is on hackage and it used to work
17:06:45 <lispy> It seems like we should discourage people from editing things locally and installing them
17:06:48 <luite> merehap: all my code is pure here, I work in a zip archive (a pdfxml file, which is a zip file with some xml files and binary resources (fonts, images)), most of the functions are Zip.Archive -> Zip.Archive
17:09:43 <luite> monochrom: do you have an example of how to use that function?
17:10:49 <monochrom> The statement "All arrows use IO and a global state for options, errorhandling, ..." is wrong, even if it's in the doc. The doc is wrong. "instance ArrowXml LA" completely disproves it. LA is just a->[b], cannot possibly do IO, state, error handling...
17:11:24 <monochrom> I don't have an example. Granted it is not documented.
17:11:46 <luite> google doesn't seem to have examples either
17:12:22 <Saizan> lispy: of the show package you mean?
17:12:32 <lispy> yeah
17:12:53 <Paczesiowa> monochrom: it does errorhandling by returning empty list
17:14:42 <dmhouse> Is there any way of forcing GHCi to execute something without printing its result?
17:15:22 <dmhouse> I want to time how long something takes, but it produces a lot of output which I don't want filling up my terminal. (Secondary concern: it produces so much output, printing to the terminal might be a bottleneck.)
17:15:25 <kmc_> execute an IO action?
17:15:28 <kmc_> m >> return ()
17:15:34 <monochrom> So how about this? You still use runIOSLA readDocument or runIOSLA readString to read and parse. If all goes well you get [XmlTree]. Now you pass it to LA for pure processing.
17:15:54 <dmhouse> kmc_: what IO action?
17:16:10 <kmc_> dmhouse, you said "execute something".  i was asking did you mean execute an IO action?
17:16:26 <kpreid> dmhouse: do you mean to evaluate something? if so the question is how far
17:16:35 <kpreid> if you want to do exactly as much as printing would, then
17:16:41 <kpreid> length (show something)
17:16:49 <Paczesiowa> :set -fno-print-bind-result
17:16:50 <dmhouse> kpreid: yep. Right down to normal form.
17:16:52 <dmhouse> Ah, that'll do it
17:16:54 <Paczesiowa> x <- action
17:16:59 <kpreid> well, show doesn't guarantee that :-)
17:17:06 <kmc_> dmhouse, if you only want weak head normal form, seq will do it
17:17:10 <kmc_> e `seq` ()
17:17:17 <dmhouse> kmc_: no, I want it fully evaluated
17:17:18 <Saizan> lispy: well the .cabal file for show is just broken, it says it works for base < 5, but it should say <4, then cabal-install would be able to pick the right one
17:17:29 <kmc_> dmhouse, then you will need some type-specific function which walks the entire structure
17:17:36 <Saizan> lispy: the fact that --constraint="base < 4" doesn't work it's a bug, there's a ticket open
17:17:37 <luite> monochrom: hm, I could do that... but I really find it hard to believe that parsing xml would require IO
17:17:43 <kmc_> look at Control.Parallel.Strategies; rnf works for any instance of NFData
17:17:44 <dmhouse> I think length $ show x will do the trick
17:17:57 <kmc_> only if the show instance forces the entire structure
17:18:03 <dmhouse> Yeah, it does.
17:18:05 <kmc_> quite a few don't
17:18:07 <CalJohn> does (>>) actually cause things to be evaluated in the IO monad?  isn't it lazy?
17:18:11 <monochrom> Because readDocument and readString potentially needs to read an external DTD and validate.
17:18:16 <dmhouse> kmc_: really? For example?
17:18:21 <kmc_> CalJohn, (a >> b) definitely performs the side effects of both a and b
17:18:30 <monochrom> Oh you can turn it off but that's beside the point. The point is someone can turn it on.
17:18:39 <kmc_> CalJohn, "lazy" refers to evaluation which is a completely separate issue from execution
17:19:04 <kmc_> the question was how to ensure something is executed yet throw out the result
17:19:10 <kmc_> at least it was at first
17:19:28 <kmc_> dmhouse, i've often defined a big structure with a Show instance that only gives a summary or an identifier
17:19:39 <kmc_> especially if some of the fields are functions, which you can't easily show
17:19:46 <dmhouse> That's true
17:19:47 <CalJohn> so IO is strict WRT side effects?
17:20:07 <kmc_> CalJohn, what would that mean?
17:20:14 <kmc_> side effects are a result of execution, not evaluation
17:20:24 <kmc_> "lazy" and "strict" are terms applied to evaluation
17:20:33 <CalJohn> i don't really understand the distinction between execution and evaluation
17:20:37 <monochrom> xread :: ArrowXml a => a String XmlTree  you can use LA for this.
17:20:41 <kmc_> evaluation is reduction of terms to normal form
17:20:52 <kmc_> function application and such
17:20:59 <CalJohn> right
17:21:10 <CalJohn> but execution is?
17:21:17 <dmhouse> kmc_: mine is an IntMap of (essentially) (Int, IntSet, IntSet), so show works fine.
17:21:19 <kmc_> performing the side effects specified by an IO action
17:21:47 <dmhouse> (The three things are the vertex's label, its neighbourhood, and its "co-neighbourhood", i.e. the labels of G - nhood(v) - v.)
17:21:50 <copumpkin> dmhouse: why not rnf? or deepseq?
17:21:56 <copumpkin> dmhouse: better be safe than sorry!
17:22:59 <CalJohn> thanks, kmc_
17:23:02 <dmhouse> copumpkin: saved myself typing the import ;)
17:23:04 --- mode: monochrom set -b *!*@ip68-7-5-98.sd.sd.cox.net
17:23:10 <copumpkin> :P
17:23:10 --- mode: monochrom set -o monochrom
17:23:46 <kmc_> evaluating an IO action does not perform IO
17:24:04 <Paczesiowa> can I do anything do derive a Show,Eq instance for a type that doesn't export its constructors?
17:24:11 <kmc_> just as evaluating the string "send an email to the pope" does not send an email to the pope
17:24:24 <kmc_> Paczesiowa, it's not working?
17:24:36 <kmc_> you'd derive where you declare the type
17:24:41 <kmc_> and the instances get exported with the type
17:24:58 <Paczesiowa> kmc_: I want derive stuff for ghc stuff
17:25:12 * kmc_ is confused
17:25:18 <Paczesiowa> kmc_: I want to Show Types
17:25:30 <kmc_> oh, you want to derive outside the module
17:25:35 <monochrom> You don't need their constructors if they are already Show instances.
17:25:40 <kmc_> sorry, i don't know how to do that
17:25:55 <Paczesiowa> kmc_: and there are only prettyprinting functions that don't work for me
17:25:55 <dmhouse> I think you can only specify derived instances when declaring the type itself.
17:26:06 <kmc_> dmhouse, there is a ghc extension to the contrary
17:26:06 <dmhouse> However, what are you trying to show? I might already instantiate Show.
17:26:09 <monochrom> "data Me = Me Int deriving Show" works without constructor of Int.
17:26:45 <Paczesiowa> dmhouse: I want to show Type (from ghc-api)
17:27:23 * dmhouse has no idea whether that's in Show
17:27:48 <monochrom> It is not in Show but it is in Outputable. Almost just as good.
17:28:11 <augur> i have a blackboard now :D
17:28:11 <luite> bah I hate it that the HXT wikibooks examples do not use actual XML documents...
17:28:29 <monochrom> What is "actual XML documents"?
17:28:50 <monochrom> Then again I haven't read said wikibook and plan to never do.
17:28:59 <luite> they use snippets like "<foo></foo>", ant their functions work fine on those, but they don't accept full xml files that start with <?xml .... ?>
17:29:26 <monochrom> Oh right, at least my tutorial provides short but complete xml files.
17:29:40 <monochrom> Scientific method. Reproducible.
17:30:00 <gwern> hm. isn't -O3 considered harmful?
17:30:05 <monochrom> Falsifiable statements and reproducible experiments only.
17:30:06 <luite> yes it's quite annoying to find that complete files have to be processed in a totally different way
17:30:50 <Paczesiowa> monochrom: outputable or not, that isntance is still based on pretty printing
17:31:16 <monochrom> So you completely dislike the result of the pretty-printing?
17:32:14 <dmhouse> You could write your own pprType :: Type -> String function, no need to use an existing function
17:32:18 <monochrom> I guess there is the last resort or 2nd last resort of unpacking ghc source, going in to add "deriving Show", building...
17:32:30 <Paczesiowa> monochrom: now that you mention it, I don't care about it, I just need Eq for it and parsing funciton
17:32:44 <Paczesiowa> monochrom: I need to compare two types for equality
17:33:00 <monochrom> Eq is Equally a lot of work. <duck>
17:33:29 <dmhouse> Paczesiowa: you could also wrap it up in a newtype for which you define Eq
17:33:33 <Paczesiowa> monochrom: no, standalone deriving works for Eq, because subtypes have Eq instances
17:33:41 <Ramchip> I'm trying to modify a single element in a list - wondering if there's a simple way. Let's pretend for simplicity I want to increment the maximum in a list of integers
17:33:42 <monochrom> Oh wait, how could a compiler API not have type equality provided...
17:34:12 <Paczesiowa> so now all I need is parsing fun for types
17:34:26 <Ramchip> I could do a map and if the element is equal to the maximum of the list, I return elem + 1, else elem. But now I increment all elements equal to the maximum, not just the first maximum
17:34:39 <Ramchip> any suggestions?
17:35:02 <monochrom> So actually ghc api has type comparison functions of several varieties.
17:35:29 <monochrom> tcEqType may be good for most purposes.
17:36:33 <solidsnack> monochrom: Are you the Austrian hacker dude?
17:36:39 <monochrom> No.
17:36:44 <solidsnack> Oh.
17:36:47 <monochrom> I am not even Austrian.
17:36:55 <solidsnack> Thought it would be hilarious if you were.
17:36:55 <Paczesiowa> monochrom: but I want to write a testcase, that says that inferred type (by hint) of some funciton is equal to "parse \"SomeType\""
17:36:57 <ray> or a hacker
17:37:11 <solidsnack> monochrom: He uses the same mis-spelling.
17:37:41 <monochrom> I am the Chinese Canadian counterexample generator.
17:37:56 <FliPPeh> Gahh, I always feel bad when I'm installing GHC.. it uses sooo much disk space
17:38:10 <solidsnack> monochrom: Hmmm.
17:38:31 <monochrom> I bring up factoids to destroy people's beliefs.
17:38:33 <solidsnack> monochrom: Next time I'll see him, I'll ask him if he's the Chinese Canadian contraditionator.
17:39:56 <monochrom> Do not try to prove a conjecture unless I hear it and admit I can't think of a counterexample.
17:41:50 <Saizan> Ramchip: use a map
17:42:17 <kmc_> Ramchip, by "modify" you mean return a new list with the number incremented, correct?
17:42:22 <Ramchip> yes
17:42:24 <kmc_> i agree, use a map
17:42:31 <kmc_> lists are not good for random access
17:42:34 <Saizan> Ramchip: map (\x -> if x == maximum xs then x + 1 else elem) xs
17:42:50 <wdonnelly> he only wants to increment the first instance though
17:43:06 <wdonnelly> so a fold is going to be necessary to make that distinction
17:44:08 <Saizan> aah, i read it backwards
17:44:38 <Saizan> you can use span or break to find the element and increment it then
17:44:57 <Saizan> > span (==3) [1,2,3,2,1]
17:44:59 <lambdabot>   ([],[1,2,3,2,1])
17:45:04 <Saizan> > break (==3) [1,2,3,2,1]
17:45:05 <lambdabot>   ([1,2],[3,2,1])
17:46:27 <Saizan> > let xs = [1,2,3,2,1] in let (as,b:bs) = break (== maximum xs) xs in as ++ b + 1 : bs
17:46:29 <lambdabot>   [1,2,4,2,1]
17:46:36 <Ramchip> yes that sounds good
17:49:29 <Ramchip> thanks! that's better
17:50:05 <Saizan> it'll crash with an empty list
17:50:11 <Saizan> > let xs = [] in let (as,b:bs) = break (== maximum xs) xs in as ++ b + 1 : bs
17:50:13 <lambdabot>   * Exception: <interactive>:1:156-191: Irrefutable pattern failed for patter...
17:56:29 <benmachine> infix flip actually makes a lot of sense
17:56:51 <benmachine> it's like, the argument will go here
17:56:57 <benmachine> can't think of a good name for it though
17:57:25 <benmachine> > let (\/) = flip in elem \/ [1,2,3] $ 2
17:57:26 <lambdabot>   True
17:57:35 <benmachine> > let (\/) = flip in find \/ [1,2,3] $ 2
17:57:36 <lambdabot>   No instance for (GHC.Num.Num (a -> GHC.Bool.Bool))
17:57:36 <lambdabot>    arising from the lite...
17:57:42 <benmachine> whoops
17:57:57 <benmachine> > let (\/) = flip in find \/ [1,2,3] $ (== 2)
17:57:58 <lambdabot>   Just 2
17:58:14 * benmachine tries to remember what he was doing before he noticed this
17:58:47 <gwern> > 10 * 1/3
17:58:48 <lambdabot>   3.3333333333333335
17:58:59 <gwern> > 10 `div` 3
17:59:00 <lambdabot>   3
17:59:02 <monochrom> Sorry I find (flip f) more sensible.
17:59:04 <gwern> > 10 `div` 4
17:59:05 <lambdabot>   2
17:59:18 <Ramchip> saizan: can't really avoid an explicit check since maximum itself doesn't like the empty list, but it's quite pretty with a little refactor
17:59:20 <Ramchip> incmax xs = doToFirst (== maximum xs) (+1) xs
17:59:37 <gwern> > round (10 * 1/3)
17:59:38 <lambdabot>   3
17:59:51 <benmachine> no-one except me likes (f \/ y) = (\x -> f x y)?
17:59:56 <gwern> > round (10 - (10 * 1/3))
17:59:57 <lambdabot>   7
18:00:31 <gwern> hm. suppose I have a list or Seq with 10 entries, and I'm moving the head to the tail, and then jumping it forward by a fraction of the list, say, 1/4
18:00:37 <gwern> (this is kind of a circular list)
18:01:21 <gwern> is the new index going to be 'round (length - (length * 1/n))' where length obviously is the list/seq length and n is the fraction to promote by
18:01:26 <monochrom> In (f \/ y) = (\x -> f x y), you make y special.
18:01:52 <benmachine> monochrom: special?
18:02:28 <monochrom> Why do you not write like (f \/) = (\y x -> f x y) ?
18:03:31 <benmachine> because sectioning on it isn't that helpful?
18:03:41 <luite> monochrom: I now have something like this, is that what you meant? http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=15654#a15654
18:04:12 <monochrom> No, not unsafePerfomIO.
18:04:32 <monochrom> runIOSLA or runX.
18:04:45 <benmachine> my most common use for flip is to partially apply a function in the second argument
18:04:58 <luite> monochrom: but then I could never get rid of the IO?
18:05:43 <benmachine> in this particular case I was doing flip App x <$> stepeval g
18:05:52 <sshc> how do I specify the optimisation level in a pragma?
18:06:05 <luite> transforming the xml files is about the deepest function in my program, I'd have to move almost everything into IO
18:06:10 <Saizan> sshc: {-# OPTIONS_GHC -O2 #-}
18:06:25 <gwern> :t round (length - (length * 1/4))
18:06:26 <lambdabot>     No instance for (RealFrac ([a] -> Int))
18:06:27 <lambdabot>       arising from a use of `round' at <interactive>:1:0-30
18:06:27 <lambdabot>     Possible fix:
18:06:30 <sshc> Saizan: do I need to put that in every file that gets compiled?
18:06:34 <gwern> :t round (10 - (10 * 1/4))
18:06:36 <lambdabot> forall b. (Integral b) => b
18:06:37 <monochrom> Must I actually write you code to show you thus?
18:06:51 <gwern> :t fromIntegral $ round (10 - (10 * 1/4))
18:06:52 <lambdabot> forall b. (Num b) => b
18:06:55 <gwern> > fromIntegral $ round (10 - (10 * 1/4))
18:06:56 <lambdabot>   8
18:07:01 <gwern> > round (10 - (10 * 1/4))
18:07:02 <lambdabot>   8
18:07:09 <gwern> :t (round (10 - (10 * 1/4)) :: Int)
18:07:10 <lambdabot> Int
18:07:21 <xerox> gwern I gather -O3 *was* considered bad, but nowadays it is considered good.
18:07:29 <gwern> xerox: really? when did that change?
18:07:43 <Saizan> sshc: yes
18:08:25 <monochrom> luite: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=15654#a15655
18:09:06 * benmachine wonders about the balance between introducing new combinators to make code easier to write and keeping them few to make code easier to read
18:09:29 <benmachine> (the hope is that for someone who knows the code, it's easier to read and write, but I'm thinking of people who would have to look everything up)
18:09:37 <gwern> > 10 * (1/4) == 10 / 4
18:09:38 <lambdabot>   True
18:09:54 <monochrom> benmachine: OK, if you always partial apply, that does make one parameter more special than the other, and that is what I mean by special.
18:09:57 <luite> monochrom: uh yes, but in my real program, parseXmlString needs to be called in a function  f::SomeOptions -> Zip.Archive -> Zip.Archive,  it reads a String from the zip archive, which is a pure value
18:09:57 <sshc> why was level 3 thought to bebad?
18:10:22 <xerox> gwern although shootout code compiles with -O2 and -optc-O3
18:10:24 <benmachine> monochrom: I don't always partial apply, but that's the only time I intend to use infix flip
18:10:35 <gwern> xerox: well, w know -o3 is good for *gcc*
18:10:39 <luite> oh that the string is pure doesn't realy matter
18:11:16 <Saizan> i think -O3 was bad because there was a bug that made it work like -O0
18:11:27 <xerox> gwern if only I remembered who told me about -O3...
18:11:27 <Saizan> currently -O3 is just the same as -O2
18:11:40 <luite> monochrom: anyway, thanks for the help and suggestions, I guess I'll have to restructure my program a bit
18:12:20 <xerox> http://hackage.haskell.org/trac/ghc/ticket/1371
18:12:46 <gwern> > 26 `div` 3
18:12:47 <lambdabot>   8
18:12:58 <monochrom> luite: I am not completely sure what xread does but it is pure.
18:13:02 <sshc> are pragmas required to be at the beginning of a source file?
18:13:09 <gwern> hm. yi no longer compiles
18:13:12 <sshc> or can they be anywhere on their own line?
18:13:17 <gwern> maybe it's time to upgrade to 6.12
18:13:22 <Saizan> sshc: they must be at the top
18:13:25 <copumpkin> anywhere, but some must be at the top
18:13:31 <monochrom> {-# INLINE me #-} cannot possibly be at the beginning of a source file.
18:13:50 <Saizan> ah, yeah, it depends on the pragma
18:13:52 <luite> monochrom: that's the function they use on the wikibooks, it reads the content part of the xml, without the <?...?> and dtd
18:14:02 <copumpkin> {-# UNPACK #-} is even context-sensitive
18:14:28 <monochrom> Then xread is not very suitable.
18:15:02 <monochrom> Isn't it fun that people ask questions and the correct answers are "it depends".
18:15:23 <benmachine> well, sometimes things depend.
18:15:49 <sshc> monochrom: it depends on the pragma is specific enough to be a reasonable answer, but not just "it depends"
18:16:38 <monochrom> "Hi is haskell compiled or interpreted?" It depends. "Hi how do I solve equations?" It depends. "Can Haskell serve web pages?" It depends.
18:17:08 <gwern> > ['1'..]
18:17:09 <lambdabot>   "123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxy...
18:17:21 <gwern> :t show '1'
18:17:22 <lambdabot> String
18:17:26 <gwern> > show 1
18:17:27 <lambdabot>   "1"
18:17:40 <pikhq> monochrom: s/haskell/C/
18:17:40 <pikhq> ;)
18:17:48 <monochrom> And note I carefully wrote "the correct answers" not "the correct answer". It's a polymorphic "it depends". It depends on the question.
18:17:55 <xerox> What is the solution to y'' + y = 0? It depends.
18:18:27 <gwern> > 10 - (10 `div` 1)
18:18:28 <lambdabot>   0
18:18:40 <Saizan> xerox: madness
18:20:09 <smorg> Wow I didn't know bash had {1..n} syntax for sequences. Wonder if they stole that from haskell. Alas, it doesn't have {1..}
18:20:15 <pikhq> xerox: Well, clearly in this context, (+)::(Num c)=>a->b->c;_+_=0
18:20:16 <pikhq> :P
18:21:10 <xerox> I was thinking of boundary conditions, but ok.
18:21:54 <pikhq> > let (+)::(Num c)=>a->b->c;_+_=0 in "Flimble" + (+)
18:21:56 <lambdabot>   0
18:26:49 <interferon> as a way of learning haskell, i built a simple BST module
18:26:52 <interferon> it's at http://paste.lisp.org/display/93048
18:27:17 <interferon> it works, but can anyone help me make it more concise?
18:28:00 <interferon> i keep coming across new tricks, but i think i've reached the end
18:28:02 <mistermattaway> does anyone know why gtk2hs isn't on cabal's package list?
18:28:25 <ben> Because it uses a non-cabal build system.
18:31:45 <Paczesiowa> interferon: you could use $ insteaf of parens in a few places
18:32:39 <interferon> Paczesiowa: what does that do?
18:32:48 <c_wraith> @src ($)
18:32:49 <lambdabot> f $ x = f x
18:32:56 <Paczesiowa> Node leaf Empty (Leaf target) == Node leaf Empty $ Leaf target
18:32:58 <xerox> mistermattaway it is hard to build gtk2hs, but duncan's Makefile do that work well. At some point cabal will.
18:33:18 <c_wraith> interferon: it just takes advantage of haskell's precedence rules to enable writing expressions with many fewer parens
18:33:30 <interferon> i see
18:33:34 <mle> I just wish <$> has precedence like $ :(
18:33:50 <interferon> so instead of doing func (x + y) i can do func $ x + y?
18:33:55 <c_wraith> exactly
18:34:00 <interferon> great, thanks
18:34:27 <Paczesiowa> interferon: you also should use "insert target l@(Leaf leaf)" and then use l inside, instead of Leaf leaf, that way you reuse previous value insteaf of creating another, equal to the previous one
18:34:31 <interferon> actually, one of my only issues with Real World Haskell is that they use $ a lot without first explaining what it does
18:34:44 <interferon> Paczesiowa: that's good too, thanks
18:39:21 <c_wraith> mle: <$> can't really have precedence like $, because "f <$> x <*> y" needs to be "((f <$> x) <*> y)"
18:40:16 <mle> c_wraith: yes, but very often I want (f <$> (x <*> y)) instead.  Maybe I'm using it wrong?
18:41:02 <c_wraith> mle: do you mean some operator other than <*>?  I chose that one specifically because it's the whole point of the applicative idiom which led to the <$> operator.
18:41:07 <interferon> i'd like to look at a reasonably large system (but small enough to be comprehensible) so i can better understand how haskell is used in the real world
18:41:08 <interferon> any ideas?
18:41:29 <Luke> xmonad
18:41:29 <interferon> bigger than the examples in Real World Haskell but smaller than, say, GHC :)
18:41:43 <Luke> that's what I always look at
18:41:56 <Luke> and i also look at the source on hackage
18:42:06 <Luke> yi is also good
18:42:10 <interferon> wow, thanks
18:42:11 <interferon> this is impressive
18:42:23 <Luke> np
18:43:09 <interferon> i'm interested in yi as well
18:43:17 <interferon> it seems nontrivial to get it running though
18:43:29 <mle> c_wraith: hmmm, well I have things like
18:43:30 <mle> e.g.
18:43:40 <mle> parseStartOfScan = JpegStartOfScan <$> (byte 0xda *> parseScanHeader Baseline <* (many1 parseNormalByte))
18:43:50 <mle> or as a more simple case
18:44:01 <mle> parseStartOfImage = JpegStartOfImage <$ ((many1 $ byte 0xff) *> byte 0xd8)
18:44:19 <mle> (parsec on binary data)
18:45:11 <interferon> what do i do when "cabal install yi" gives me a ton of error messages about "base"?
18:45:38 <damd> use emacs
18:45:42 <xerox> do they say '... are belong to us'. (sorry I'm sleepy)
18:45:49 <damd> hahaha
18:45:58 <mle> interferon: different versions of ghc use different versions of base
18:46:16 <Lycurgus> cry like a baby?
18:46:17 <mle> various releases of various libraries have different base requirements, and so different effective ghc requirements
18:46:20 <xerox> I think you need to cabal unpack it. Then fix the .cabal file and build.
18:46:21 <interferon> i have a pretty recent ghc
18:46:33 <Saizan> interferon: version?
18:46:35 <interferon> 6.6
18:46:44 <mle> er, what?
18:46:44 <interferon> it's looking for base-4
18:46:46 <Saizan> 6.6 is pretty old.
18:47:03 <mle> ancient, heh
18:47:04 <c_wraith> mle: I see your issue.  It feels like it's related more specifically to *> and *<.  I wonder if it would be coherent to make those higher-precedence
18:47:13 <pragma_> I disagree with your inferior views.
18:47:15 <c_wraith> err, <*
18:47:20 <Saizan> i think you need 6.8 at least, maybe 6.10
18:47:30 <interferon> hmm
18:47:45 <interferon> i just downloaded the Haskell Platform yesterday, the ghc in my path must be an old one
18:48:13 <mle> c_wraith: it works okay in some areas
18:48:26 <mle> e.g. <* but not *>
18:48:45 <mle> parseApplication = (JpegApplication . ((.&.) 0x0f)) <$> byteMatch 0xe0 0xf0 <* parseSizedBlock
18:48:53 <interferon> oof, it's just a path issue
18:48:58 <interferon> let me try again before complaining :)
18:49:02 <c_wraith> mle: oh, right.
18:49:19 <ccasin> when I compile a program with ghc on windows, it launches in a terminal.  How can I get rid of the terminal?  (The program has its own gtk2hs gui)
18:51:14 <mle> in practice I need to rewrite all that as it's clearly placeholder stuff, but... is there a better way to do things involving <$ and <$>?
18:51:44 <c_wraith> Actually, in a more complex example, <* should be higher-precedence, too
18:52:02 <interferon> i can't believe xmonad is only 3900 lines of code
18:52:12 <c_wraith> f <$> a *> b <* c <*> d
18:52:28 <c_wraith> you really want that to work out as kind of f b d
18:52:47 <mle> hmmmm
18:53:05 <mle> Ahh, I think one of the problems is if any of a b c d contain application
18:53:34 <mle> e.g. f <$> a 5 *> b ... fails because of <$> relative to normal function application.  maybe?
18:53:35 <c_wraith> indeed.  No way out of that aside from parens or refactoring
18:53:51 <mle> okay.
18:53:56 <interferon> i get the impression from Real World Haskell that monads are pretty pervasive in Haskell applications - i was under the impression that they were relegated to smallish parts of your program
18:54:04 <interferon> but even parsec, for example, seems to involve monads
18:54:30 <c_wraith> interferon: it would be (generally) more accurate to say IO is smallish parts of the program.
18:54:55 <interferon> i see
18:55:13 <interferon> i'm curious, though, why does parsec need monads?  couldn't it be purely functional?
18:55:16 <c_wraith> other things end up being monads because it's a really convenient way to structure your code.
18:55:22 <c_wraith> parsec *is* purely functional
18:55:30 <c_wraith> monads are just a way to structure code.
18:55:33 <interferon> oh...
18:55:48 <interferon> the CVS parser in RWH is all monads
18:55:51 <interferon> is that necessary?
18:56:00 <interferon> or is it just the implementor's choice?
18:56:00 <c_wraith> technically, no.
18:56:07 <interferon> but is the alternative CPS?
18:56:19 <c_wraith> The only necessary monad is IO, in modern haskell.
18:56:21 <Pseudonym> interferon, one of the ways that Haskell uses monads is to make pure functional code _look_ imperative.
18:56:41 <Pseudonym> c_wraith, even that isn't strictly necessary.
18:56:58 <c_wraith> Pseudonym: it is if you compile.  need to define main.  :)
18:57:25 <Pseudonym> Oh, I thought you meant in the type system.
18:57:31 <Pseudonym> Yes, the RTS knows about IO and ST.
18:58:13 <interferon> hmm
18:58:16 <c_wraith> interferon: monads are a way of structuring code that makes it easy to compose small calculations into larger ones.
18:58:35 <interferon> c_wraith: but don't they destroy purity?
18:58:36 <c_wraith> interferon: But they're not necessary, by any means.
18:59:23 <c_wraith> interferon:  No.  IO is the special case.  (and even it is only slightly special)
18:59:34 <interferon> hmmm
19:00:07 <interferon> i think i need to continue plugging away at RWH
19:00:25 <interferon> monads are basically just nice syntax on top of CPS, right?
19:01:17 <c_wraith> No.  Monad is a typeclass that gives two basic functions (and two others that aren't as interesting).  do-notation is nice syntax for working with monads, but the typeclass is the important part
19:02:02 <poet> can someone explain to me what a memo table is?
19:02:23 <interferon> c_wraith: so i'll keep in mind that monad != IO as i continue reading
19:02:26 <c_wraith> poet: it caches results from a calculation so they aren't calculated multiple times
19:02:31 <interferon> c_wraith: i think i need to read more before i'm qualified to discuss :)
19:02:56 <c_wraith> interferon: You sound like you've got a great grasp, for a beginner.  Don't try to force it.  Just learn as much as you need to, and keep an open mind. :)
19:02:57 <poet> c_wraith: so a hash table with the keys being a function name and unique arguments, and the value being the return value of the function?
19:03:06 <interferon> c_wraith: thanks!
19:03:51 <c_wraith> poet: it's typically more limited, ie inside the context of an outer function that uses a memoized inner function.  But that's the idea
19:04:48 * interferon is delighted to have Yi running
19:05:39 <c_wraith> poet:  http://hackage.haskell.org/packages/archive/data-memocombinators/0.4.0/doc/html/Data-MemoCombinators.html  <-- there's a *very* short example in there that might make it clear
19:05:43 <interferon> Yi is CUI only, right?
19:06:04 <poet> c_wraith: great, thanks :)
19:07:21 <c_wraith> @where dynamic programming
19:07:21 <lambdabot> http://www.cse.unsw.edu.au/~dons/papers/SC05.html
19:07:30 <c_wraith> Hmm.  That's not the link I was hoping for
19:09:14 <c_wraith> poet:  http://haskell.org/haskellwiki/Dynamic_programming_example <-- a less magic example, this one uses a simple array as the memo table.  Note that dynamic programming and memoization are very similar, and nearly the exact same thing in a lazy language
19:10:38 <jfoutz> oh wow. i didn't realize this would work...
19:10:51 <jfoutz> >  foldr (\ a f -> (\k -> if a == 3 then 3 else f a)) id [1,2,3,4,5, undefined] 1
19:10:52 <lambdabot>   3
19:11:11 <jfoutz> continuations are neat.
19:15:03 <xerox> > foldr (\x acc -> if x < 10 then acc else x) undefined [1..]
19:15:04 <lambdabot>   10
19:16:32 <jfoutz> ah, hmm. good point.
19:20:31 <Veinor> does Data.Time have a convenient way to go from month, day, hour, minute, second to an appropriate type?
19:21:01 <monochrom> Supposedly yes.
19:21:36 <Veinor> well, I guess the question is: what's the best type for storing the start/end times of an event?
19:22:47 <xerox> It depends. Eh. E.g. If they are short-timed you might want microseconds.
19:23:29 <Veinor> they're <12 hours. but I still need a way to go from month day year hour minute second to microseconds.
19:25:17 <Veinor> how does haskell not have a good library for this already?
19:25:53 <monochrom> Is this the provocative tactic?
19:26:10 <Veinor> perhaps it is :P
19:26:26 <Veinor> but seriously, neither Data.Time nor Data.DateTime do what I want.
19:26:54 <FliPPeh_> :)
19:27:08 <roconnor> Veinor: What's the problem with Data.Time?
19:27:10 <monochrom> IMO Data.Time does the job. Note that by Data.Time I include its submodules.
19:27:41 <Veinor> I want one object that carries year, month, day, hour, minute, second information
19:27:44 <monochrom> Use Data.Time.Clock.UTCTime.
19:27:49 <roconnor> Data.Time is a bit complicated, but only because time is complicated
19:27:58 <FliPPeh_> offtopic: once you learn how to split irssi windows, it'll be awesome
19:28:03 <roconnor> Veinor: UTC or local time?
19:28:22 <Veinor> local.
19:28:48 <roconnor> really?
19:29:17 <Veinor> yeah, this is for a very specific use case :p
19:29:33 <roconnor> http://www.haskell.org/ghc/docs/6.10.4/html/libraries/time/Data-Time-LocalTime.html#t%3ALocalTime
19:29:42 <roconnor> LocalTime is a pair of Day and Time of Day
19:29:47 <Veinor> well, how do I compute localDay?
19:29:55 <roconnor> compute from what?
19:30:07 <Veinor> year/month/day
19:30:09 <monochrom> localDay is a record file of LocalTime
19:30:18 <monochrom> s/file/field/
19:30:26 <roconnor> LocalTime :: Day -> TimeOfDay -> LocalTime
19:30:45 <Veinor> right. what  Imean is, suppose I want to create a LocalTime that represents noon on my birthday. how do I do that?
19:31:14 <monochrom> Data.Time.Calendar.Julian and Data.Time.Calendar.MonthDay has functions to extract year, month, day.
19:31:16 <roconnor> Veinor: Gregorain Calender I presume
19:31:24 <Veinor> I'm really old!
19:31:46 <roconnor> Veinor: (fromGregorian birthYear birthMonth birthDay) midday
19:32:05 <Veinor> ahhh.
19:32:19 <roconnor> Veinor: LocalTime (fromGregorian birthYear birthMonth birthDay) midday
19:32:34 <monochrom> And toGregorian for the reverse.
19:33:08 <Veinor> thank you. :)
19:33:25 <monochrom> We should start charging money seriously.
19:33:44 <monochrom> Really, I don't mind this provocative tactic as long as I'm reimbursed for the insult.
19:33:49 <Veinor> Haha.
19:33:55 <Veinor> I was just being stupid.
19:33:56 <xerox> It's astounding that Haskell doesn't have a library to do XYZ!!
19:34:06 <roconnor> xerox: what's wrong with Data.XYZ?
19:35:04 <monochrom> This is why I love the RTFM approach.
19:35:34 <xerox> http://abstrusegoose.com/double-secret-archives/RTFM.htm
19:35:49 <monochrom> At least it should be the legally allowed answer to the provocative tactic.
19:39:10 <jfoutz> a somewhat more exiting version,
19:39:12 <jfoutz> > foldl (\f val -> (\k -> if f k == 0 then 0 else val * f k )) id [2,3,2] 1
19:39:13 <lambdabot>   12
19:46:04 <adu> roconnor: are you "roc" on mozilla?
19:48:05 <adu> Veinor: what about (DateTime, DateTime)?
19:51:33 <Veinor> what's stored in a DateTime?
19:55:58 <Berengal> Date and Time, presumably...
19:56:13 <djahandarie> Berengal, unlikely!
20:01:18 <sshc> how do I pattern match against a data type defined using pattern syntax?
20:01:45 <QtPlaty[HireMe]> sshc: Can you show an example of what your trying to do?
20:01:52 <sshc> can I patern match as I would if the data type were not defined using record syntax?
20:02:08 <sshc> and can I also pattern match using other syntax?
20:02:44 <ezyang> sshc: Yes.
20:02:54 <ezyang> The ordering is preserved.
20:02:58 <ezyang> "try it"
20:03:00 <sshc> ezyang: ok
20:03:15 <sshc> ezyang: how else can I pattern match?
20:03:46 <sshc> ezyang: besides (Foo {bar=a,quux=b})
20:04:10 <ezyang> (Foo a b) should work
20:06:07 <jmcarthur> i'm surprised you learned record pattern matching first, honestly
20:19:26 <MASSIVE_COCK> (BREAKING NEWS)(AP/REUTERS) - Iran has just launched a nuclear assault on Tel Aviv Israel causing an estimated 4.9 million deaths. Israel's Prime Minister is quoted as saying, "Israels military will defend Israel with the full force of its nuclear arsenal". Details Soon.
20:20:18 <dolio> preflex: seen monochrom
20:20:18 <preflex>  monochrom was last seen on #haskell 44 minutes and 29 seconds ago, saying: At least it should be the legally allowed answer to the provocative tactic.
20:20:33 --- mode: ChanServ set +o monochrom
20:20:53 --- mode: monochrom set +b *!*@user-24-236-92-14.knology.net
20:21:26 <monochrom> What was I thinking? I saw the nick and I could have banned right away, not waiting for it to speak.
20:21:33 <jmcarthur> is the hackage package list having issues for anybody besides me?
20:21:57 <ezyang> cabal list?
20:22:05 <dolio> Seems dead.
20:22:28 <jmcarthur> ezyang: the actual page and package documentation, but cabal update might have the same problems
20:22:34 <dolio> http://downforeveryoneorjustme.com/hackage.haskell.org
20:22:47 <monochrom> Perhaps Sun Microsystem has launched a nuke to take away hackage? <duck>
20:23:12 <Veinor> cabal install is having issues as well, yeah
20:23:16 <jmcarthur> oh, i thought the front page was working. i guess it was cache
20:23:18 <jfoutz> nucular. it's nucular lisa
20:23:21 <monochrom> cabal install relies on hackage.
20:23:24 <ezyang> The Sun is, after all, a giant nuclear furnace
20:23:26 <Veinor> right
20:23:44 <Veinor> I'm surprised there was no link to nimp in that fake article.
20:24:09 <Veinor> oh hay ezyang
20:24:15 <ezyang> oh hai
20:24:58 <Veinor> great, I can't work on the demo I was planning until hackage goes back up
20:25:03 <Veinor> because I need datetime on this machine
20:25:43 <Veinor> :S
20:26:05 <ezyang> "there's always the hour before the lecture"
20:26:37 <Veinor> Haha
20:27:06 <Veinor> it's an IAP class schedule conflict resolver! you feed it a tab-separated file of the IAP classes you want, as well as priorities, and it tells you which ones to take!
20:27:36 <Berengal> Does it do sudoku?
20:27:42 <dolio> ezyang: You know of any logict things I need to fix before I release a new version?
20:28:06 <Veinor> can use it to show off typeclasses, Either, IO, and basic algorithm design
20:28:51 <Veinor> cause I'm rewriting wordsBy so people can run it without having to install split
20:28:53 <Berengal> I need a structured, human-readable dataformat with haskell parser support
20:28:55 <ezyang> dolio: Not that I know of :-)
20:29:05 <Berengal> Xml doesn't count
20:29:08 <Veinor> csv?
20:29:10 <ezyang> really, the Failure monad was the /big/ offender ^^
20:29:14 <Berengal> Not structured
20:29:14 <Veinor> oh wait, structured >_>
20:29:18 <Veinor> ... xhtml!
20:29:26 <ezyang> What's in the new version?
20:29:34 <dolio> ezyang: What Show instance did you use for it, by the way?
20:29:35 <Berengal> Veinor: ... That's my target ...
20:29:45 <ezyang> dolio: I, uh, didn't
20:29:49 <dolio> Right now, I think the only thing I changed is exporting the constructors.
20:29:57 <Veinor> oh, well
20:30:03 <Veinor> json?
20:30:05 <dolio> Oh, okay. I thought someone on reddit said they needed a Show instance, and you said you'd written one.
20:30:20 <ezyang> Oh; were they talking about a Show instance on Logic itself?
20:30:21 <Berengal> Json looks a bit ugly, but maybe
20:30:26 <dolio> I thought so.
20:30:29 <ezyang> There were a bunch of Show instances for other bits of the Turing machine
20:30:38 <Berengal> I was thinking of yaml, but there don't seem to be any particularly nice libraries for it
20:30:43 <mmmdonuts> Veinor, I have datetime-0.1.tar.gz if that would help
20:30:56 <dolio> I'm not really sure why you'd want to show a Logic computation, though.
20:31:03 <ezyang> lemme clarify on the reddit comment
20:32:04 <Veinor> I'll just wait, I've got other stuff I really should be doing anyway
20:32:20 <ezyang> oooh, did you actually define "pick"?
20:32:33 <ezyang> (just saw your comment)
20:32:50 <Berengal> instance Show Logic where show = const "âˆ€ x -> x â‹ Â¬x"
20:33:30 <Saizan> that's a lie!
20:35:26 <Veinor> Berengal: haha
20:35:34 <dolio> Kind error.
20:36:19 <Berengal> Not with data Logic = AWESOME
20:36:36 <Berengal> But I suspect that's sort of useless
20:36:37 <dolio> Well played.
20:37:28 <Veinor> it's true, logic is awesome
20:37:58 <ezyang> In many ways, it's just the list monad implemented efficiently
20:38:24 <dolio> That's pretty much exactly what it is.
20:38:42 <ivanm> what is?
20:38:45 <dolio> Logic.
20:38:47 * ivanm just came in
20:38:48 <ezyang> With also AWESOME operators of >>-, interleave, ifte and once!
20:39:00 <ivanm> there's a Logic monad?
20:39:27 <dolio> And LogicT is the same for 'data ListM m a = Nil | Cons a (m (ListM m a))'.
20:39:45 --- mode: monochrom set -o monochrom
20:40:34 <Veinor> hackage D:
20:41:03 <dolio> I put a cap on the mtl version, as is now standard, as well.
20:42:20 <ezyang> ok. When you push the new version I should be sure to go and test my lhs file and make sure it still works
20:42:57 <dolio> Well, I shouldn't have changed anything that would make any difference.
20:43:12 <dolio> The only code changes are to export two constructors.
20:43:21 <dolio> Oh, and two record accessors.
20:44:33 <ezyang> savvy
20:44:40 <ivanm> dolio: what kind of a cap? a generic baseball one or something a little more fancy? ;-)
20:44:41 <jmcarthur> could conflict with identifies that already existed in the client code, but that's all
20:44:44 <ezyang> Do you think mere mortals would be interested in those accessors?
20:44:48 <jmcarthur> *identifiers
20:45:02 <dolio> A bowler.
20:45:04 * ezyang is working on an awesome blog post showing how Haskell has built-in checks for pylint's errors ^^ 
20:45:58 <dolio> Someone sent me a mail about a MonadError instance for LogicT m when m has such an instance. You can't even try implementing catchError without those accessors/constructors.
20:46:13 <ezyang> Interesting.
20:46:46 <monochrom> Is the definition of LogicT pretty stable?
20:46:54 <ezyang> That's seems... fairly heavyweight
20:47:00 <dolio> And I elected to not include such an instance, because I don't think it works right.
20:47:13 <dolio> But someone might want to try.
20:47:47 <dolio> The newtype declaration is (I believe) the same as in Oleg's paper, aside from the name LogicT.
20:51:33 <dolio> Anyhow, catchError can only catch exceptions like "throwError e `mplus` stuff" not "stuff `mplus` throwError e".
20:51:39 <dolio> Unless stuff is mzero, perhaps.
20:51:56 <dolio> Otherwise the successes hide the error, and it bubbles up at the end.
20:53:07 <dolio> So "(return 1 `mplus` throwError "foo") `catchError` \e -> return 0" will be Left "foo" if you try to observe more than one result.
20:54:39 <ezyang> Ugggh
20:54:44 <Saizan> you can't push the catch through the mplus?
20:55:56 <dolio> I haven't figured out how, at least.
20:56:49 <dolio> Maybe I should play with the un-cpsed version to see if it's possible there.
20:57:19 <Saizan> data ListM m a = Nil | Cons a (m (ListM m a)) ?
20:57:25 <dolio> Yes.
21:01:10 <Saizan> catch m h = fmap aux m `catchError` h where aux Nil = Nil; aux (Cons a m) = Cons a (catch m h) <- i'd guess like this, if it typechecks
21:11:18 <mcnster> hi.  i am getting an error from "cabal install" during compilation that i don't get when i compile manually... can someone assist?
21:11:57 <ivanm> mcnster: paste it up somewhere and let us have a squiz
21:14:04 <mcnster> ivanm, the error is "Type constructor 'Exception' used as a class in the instance declaration for 'Exception BfdException'".  (i am importing Control.Exception)
21:14:24 <ivanm> mcnster: ahhh, right, in that case I think I know what the problem is
21:14:27 <ivanm> you have ghc-6.10.4?
21:14:45 <mcnster> ghc-6.10.3
21:14:53 <mcnster> (fedora install)
21:14:56 <ivanm> oh, yeah, I meant 6.10.*
21:15:04 <ivanm> mcnster: what line do you have containing "base" in your cabal file?
21:15:35 <mcnster>    build-depends:    base, containers, unix
21:15:44 <ivanm> mcnster: I think you want base == 3.*
21:15:51 <Saizan> no base == 4.*
21:15:53 <ivanm> as you seem to be using old-style exceptions
21:15:57 <ivanm> Saizan: oh, right, yeah
21:16:04 <ivanm> I got cabal-install's behaviour mixed up
21:16:09 <ivanm> it assumes base-3 if you don't specify
21:16:12 <stevenyvr>  /p
21:16:14 <ivanm> mcnster: listen to Saizan, not me ;-)
21:16:47 <Saizan> to recap, put "base == 4.*" instead of "base" in build-depends
21:17:04 <mcnster> ivanm, saizan.  excellent, thanks!  :)
21:19:24 <ivanm> I was about to say that required him to specify cabal >= 1.6 ...
21:21:21 <Saizan> ghc 6.10 comes with base 1.6 anyway, iirc
21:21:31 <ivanm> cabal you mean? ;-)
21:22:01 <ivanm> Saizan: I meant that to use == 4.* in the cabal file, you're meant to specify in that cabal file "Cabal-Version: >= 1.6"
21:24:54 <Saizan> yeah, Cabal
21:25:31 <ivanm> (the reason for doing so is if someone with only cabal 1.4 tried to use it, it could get to that line and then chuck a fit with a semi-sensible error message)
21:30:30 <kmc> @bot
21:30:30 <lunabot>  :o
21:30:30 <lambdabot> :)
21:33:33 <dolio> Okay, I might have something.
21:33:51 <dolio> Now I just need to figure out how to CPS it.
21:34:28 <copumpkin> :O
21:36:09 <alex404> Stupid newbie question time: I'm trying to setup a darcs repository, and am typing darcs push user@address.com:/place. Darcs then asks me for my password, and yet when I enter my password it rejects it. I can ssh into my server just fine.
21:36:41 <alex404> addendum: I have zero grasp of networking stuff.
21:36:56 <copumpkin> try #darcs maybe? :)
21:36:56 <Heffalump> are you sure it rejects it, rather than just asking for it again a bit later?
21:37:21 <alex404> copumpkin: #darcs might be an idea, eh?
21:37:24 <ivanm> use an ssh-agent if its what Heffalump suggests
21:37:25 <Heffalump> darcs makes multiple ssh connections, generally it's a bit of a pain to use without setting up ssh keys to avoid the password prompts
21:37:46 <copumpkin> alex404: but all the people there are probably here too, so it's not that bad an idea to ask here :P
21:37:51 <alex404> Heffalump: I've tried it a number of times and the password never succeeds.
21:38:23 <alex404> Heffalump: I've tried at different times too.
21:38:41 <alex404> ivanm: But ssh-agent. What?
21:38:48 <Heffalump> so what's the evidence that it fails? Do you actually get a message, or does it ask for the password again?
21:38:58 <alex404> Heffalump: Just asks again.
21:39:06 <trie> Is hackage.haskell.org down for everyone?
21:39:13 <Heffalump> that's what I mean by it making multiple connections
21:39:16 <ivanm> alex404: it remembers your ssh password for you so you don't have to keep entering it (just do it once)
21:39:22 <ivanm> trie: yeah, looks like it
21:39:33 <Heffalump> are you saying you've kept answering the question for the same invocation of darcs and it never finishes?
21:39:36 <ivanm> alex404: if it didn't like your password, it would probably say so
21:39:54 <alex404> So what do I do when it asks for the password again?
21:40:06 <alex404> I can't seem to get past the prompts.
21:40:15 <ivanm> alex404: keep giving it to you
21:40:17 <ivanm> *it
21:40:21 <ivanm> bah
21:40:27 <alex404> interesting... I'll try again.
21:40:28 <ivanm> try again: keep entering your password in
21:40:43 <jfoutz> hunter2
21:40:50 <jfoutz> sorry. couldn't resist.
21:40:52 <cord> data Maybe a = Nothing | Just a, i know that Maybe is the type constructor, and nothing, just are the value constructors
21:40:57 <ivanm> jfoutz: hmmmm?
21:41:07 <cord> but what makes me fuzzy the role of "a" in Maybe a
21:41:21 <ivanm> cord: well, what is the type of the value in the Just?
21:41:25 <jfoutz> it's an old old joke. http://www.bash.org/?244321
21:41:27 <ivanm> is it an Int? a Bool? a list?
21:41:32 <Heffalump> cord: it's a type parameter
21:41:57 <alex404> Well that's funny. So why does darcs maintain multiple ssh clients? And is there a way to fix that behaviour?
21:41:59 <ivanm> jfoutz: heh
21:42:08 <cord> ivanm, don't know
21:42:09 <ivanm> alex404: use an ssh-agent
21:42:19 <ivanm> cord: that's the point
21:42:29 <ivanm> cord: I can have a "Maybe Int", a "Maybe Bool", etc.
21:42:29 <alex404> ivanm: Cool, thanks. I'll look into it.
21:42:34 <ivanm> it can store any type of value you want
21:42:39 <ivanm> alex404: which OS are you using?
21:42:59 <cord> oh ivanm thanks got it
21:43:07 <ivanm> no worries
21:43:51 <Heffalump> alex404: try darcs push --ssh-cm
21:43:54 <alex404> ivanm: Arch linux
21:43:56 <Heffalump> (and then the other option)
21:44:13 <ivanm> alex404: OK, which DE are you using?
21:44:23 <ivanm> (if you're using one)
21:44:25 <alex404> e17
21:44:29 <alex404> ivanm: e17
21:44:39 <ivanm> OK, don't know if it has one
21:44:47 <ivanm> alex404: see if there's a package called "keychain" available
21:45:11 <Heffalump> if --ssh-cm works for you then it'll be less hassle
21:45:39 <dolio> Success.
21:45:40 <alex404> --ssh-cm Didn't seem to do anything, but there is a keychain package for my distro.
21:45:43 <ivanm> Heffalump: what does it do?
21:45:46 <jfoutz> there is a walkthrough here, http://wiki.archlinux.org/index.php/Using_SSH_Keys but, it takes a while to set up. ssh-agent is really really great when it's configured
21:45:55 <alex404> So I'll look into that.
21:46:03 <Heffalump> uses ssh control master, which means one connection with lots of sub-connections
21:46:07 <ivanm> ahhh
21:46:14 <alex404> jfoutz: Thanks.
21:46:26 <Heffalump> I think it can cause trouble so isn't the default
21:46:42 <alex404> Okay, new problem: What's the best way to deal with the fact that I've got Darcs 2, and my school seems to be running an older version. If the answer is simply build older darcs, I can manage that.
21:46:59 <Heffalump> make darcs 1 repos
21:47:01 <dolio> copumpkin: So here's my query: does "(throwError "foo" `mplus` ...) `catchError` \e -> return 0 === return 0" seem acceptable?
21:47:02 <ivanm> alex404: make sure you use darcs-1 format
21:47:05 <ivanm> that's it
21:47:06 <Heffalump> darcs init --old-fashioned
21:47:10 <alex404> cool.
21:47:18 <alex404> Any major drawback to that?
21:47:26 <alex404> Depending on version 1, I mean?
21:47:31 <ivanm> nope
21:47:34 <Heffalump> less robust, more likely to get into conflict fights
21:47:37 <ivanm> just that darcs-2 format is faster
21:47:43 <alex404> I can deal with that.
21:47:48 <alex404> Thanks for all the help.
21:48:59 <dolio> Actually, that's probably a property of throwError, so I don't think there's anything that can be done about it...
21:55:47 <cord> can you give something to cleanly understand the State Monad ?
21:57:26 <kmc> @unmtl State s a
21:57:27 <lambdabot> s -> (a, s)
21:57:29 <copumpkin> define understand
21:57:40 <kmc> that is, a value of type (State s a) is simply a wrapper around a function of the form s -> (a, s)
21:57:50 <kmc> it takes a state, and produces a "result" and a new state
21:58:12 <dolio> Someone's going to have to rename that command once we purge the mtl from existence.
21:58:22 <kmc> you can implement the State monad in a few lines of Haskell
21:59:18 <cord> kmc, yes i understand the basic idea of the State Monad i'm stuck with the implementation in RWH http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15658#a15658
21:59:31 <kmc> okay well that doesn't implement the monad
21:59:35 <kmc> that just defines a datatype named State
21:59:46 <kmc> to make it a monad you would say "instance Monad (State s) where ..."
21:59:52 <kmc> and give definitions for return and (>>=)
22:00:13 <cord> great, what's runState encapsulated in the State type ?
22:00:19 <kmc> that's a record field label
22:00:22 <kmc> consider:
22:00:29 <kmc> newtype State s a = State (s -> (a, s))
22:00:40 <kmc> runState :: State s a -> s -> (a, s)
22:00:44 <kmc> runState (State f) = f
22:00:51 <kmc> those three lines together are equivalent to that declaration
22:01:38 <cord> uha, i think there's something wrong with me getting the abstractions from RWH
22:01:50 <kmc> the record field syntax is ugly imo
22:02:09 <kmc> cord, do you understand the type once the record syntax is removed?
22:02:09 <jfoutz> the record syntax it tricky. i think it's either very slick or horribly hacky depending on if i parse it correctly.
22:02:14 <Raynes> cord: I recommend the cowboy monad tutorial.
22:02:19 <Raynes> It worked for me.
22:02:27 <cord> kmc, yup
22:02:29 <Gracenotes> cord: the idea of a function being a newtype might be somewhat odd. To make it more concrete: suppose you have something, call it foo, of type State Int String. then runState foo gives you a function, Int -> (String, Int). This is *all* the data that's contained in a State monad. If you do runState foo 4, then you get something of type (String, Int), with the state fed into it being 4.
22:02:41 <kmc> jfoutz, i dislike it because the signature given on a field is a lie
22:03:39 <c_wraith> kmc: do you prefer GADTs then?
22:03:41 <cord> Gracenotes, so it's all about implicit pass of the state ?
22:03:58 <cord> Raynes, http://www.muitovar.com/monad/moncow.xhtml ?
22:04:01 <kmc> c_wraith, that's an orthogonal question
22:04:02 <kmc> but yes
22:04:02 <jfoutz> kmc, how so? i... i still have trouble with the function form, but everything else seems fairly clear.
22:04:07 <Raynes> cord: Indeed.
22:04:18 <kmc> jfoutz, data Foo = Foo { bar :: Int }
22:04:18 <c_wraith> kmc: I suppose it is orthogonal...  But at least the type signatures don't lie.
22:04:20 <cord> Raynes, thanks alot ^^
22:04:22 <kmc> what is the type of "bar"?
22:04:24 <kmc> it's not Int
22:04:26 <kmc> it's Foo -> Int
22:04:28 <kmc> that's the lie
22:04:42 <jfoutz> ah, i see what you mean. the implicit Foo ->
22:04:44 <kmc> (x :: T) should always mean "x has type T"
22:04:53 <kmc> also, labels are not first clas
22:04:57 <kmc> only the accesor functions are
22:05:06 <kmc> you have to pair it with one of the first class label packages
22:05:09 <kmc> to make somethinfg actually useful
22:05:10 <jfoutz> that's likely the reason i screw up the function form, now that you mention it.
22:05:10 <Gracenotes> kmc: isn't it the same thing for data Foo = Bar Int? Bar isn't of type Int, it's of type Int -> Foo.
22:05:12 * Raynes hasn't figured out what GADTs are good for yet.
22:05:16 * Raynes should google.
22:05:17 <Gracenotes> kmc: but I don't see you complaining about that
22:05:25 <kmc> Gracenotes, where's the "::" in your example?
22:05:53 <kmc> Raynes, http://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html#gadt has a good motivating example
22:05:53 <Gracenotes> you'd rather it use some other syntax for records, like =?
22:06:24 <kmc> data Foo = Foo { bar _ :: Int } -- even this is preferable imo
22:06:47 <Gracenotes> cord: more often than not, in real life, you don't have functions just of type State Int String, but rather something like foo :: String -> State Int String. Which, based on the String argument and current Int state, gives you another String and possibly another Int state.
22:07:15 <kmc> always another state, which could be equal to the first one
22:08:36 <Gracenotes> generally, if you have a function that only modifies the State, it's of type State Int ().
22:08:50 <kmc> :t modify
22:08:52 <lambdabot> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
22:09:05 <kmc> ^^^^ lifts a state-modifier into a State monad action
22:09:20 <Gracenotes> yes. modify (+1) :: State Int (). Could also be written do
22:09:23 <kmc> a more concrete type:   (s -> s) -> State s ()
22:09:38 <Gracenotes> er. do { s <- get; put (s+1); }
22:09:51 <kmc> @src modify
22:09:51 <lambdabot> Source not found. That's something I cannot allow to happen.
22:10:05 <kmc> :t let modify f = do { x <- get; put (f x) } in modify
22:10:07 <lambdabot> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
22:10:55 <Gracenotes> get :: State s s; put :: s -> State s (). The idea behind get's type is that the value it yields is the same type as the current state, because it *is* exactly the current state.
22:10:58 <elspru> is there any way to make the error messages more verbose?
22:11:08 <kmc> error messages from what?
22:11:12 <elspru> Prelude.head: empty list
22:11:23 <Gracenotes> the idea behind put's type is that you send it a new state, which replaces the current one, with no useful value to return (so () is used)
22:11:25 <kmc> oh dear
22:11:27 <kmc> don't use head
22:11:30 <elspru> like what function it was located in
22:11:46 <elspru> kmc: what's the alternative?
22:11:51 <kmc> pattern matching
22:11:53 <Gracenotes> well head can be useful, as long as you know for sure the list isn't empty
22:12:18 <Gracenotes> I don't think I've used it any time in the past few months though -.-
22:12:20 <elspru> oiyoyoi
22:12:22 <kmc> > let f [] = "list is empty"; f (x:xs) ("list has head: " ++ show x) in map f [[], [3,4,5], [], [2]]
22:12:23 <lambdabot>   <no location info>: parse error on input `in'
22:12:45 <kmc> > case [] of { [] -> "empty", (_:_) -> "not empty" }
22:12:46 <lambdabot>   <no location info>: parse error on input `,'
22:12:51 <kmc> > case [] of { [] -> "empty"; (_:_) -> "not empty" }
22:12:53 <lambdabot>   "empty"
22:13:30 <kmc> elspru, i think the GHCi debugger can give you an evaluation trace
22:13:34 <kmc> there's a way to make it breakpoint on errors
22:13:40 <elspru> how to use?
22:13:42 <Gracenotes> elspru: what you're thinking about is having stack traces, that tell you what's called what. That's in the works to an extent... but stacks in the Haskell sense are rather different from what you'd expect for, say, Java or Python
22:13:52 <kmc> elspru, i don't know.  probably by reading the documentation
22:13:58 <Gracenotes> that is in the work to an extent, right.  -.-
22:14:35 <elspru> like i mentioned before, it would be a good idea to retain function names in compiled code
22:14:48 <elspru> awww, my kitties are licking each other :D
22:14:59 <elspru> their so cute
22:15:22 <Gracenotes> elspru: the function name is retained in compiled code. See? "Prelude.head: empty list"
22:15:42 <Gracenotes> except you don't want to know the function it happened in, you want to know the function *before* it happened :)
22:15:42 <elspru> it doesn't say what function head is located in
22:15:46 <Gracenotes> aka the one you defined
22:15:54 <kmc> elspru, because of laziness, you would need to save a lot of extra data
22:16:07 <elspru> oi
22:16:15 <kmc> the caller of head is not necessarily active at the point the head is forced
22:16:22 <Gracenotes> well, the error is located in the head function, and that is how it goes -.-
22:16:32 <elspru> ya
22:16:32 <kmc> the solution is not to use partial functions
22:16:38 <kmc> and to remove them from the prelude so beginners don't use them
22:16:49 <elspru> what are partial functions?
22:16:59 <Gracenotes> non-total functions
22:17:00 <kmc> functions that sometimes crash the program rather than returning a value
22:17:10 <ivanm> elspru: e.g. head
22:17:13 <ivanm> head [] is undefined
22:17:14 <kmc> if you really really want to take the head of a list or die trying (\(x:_) -> x) is nice and explicit about the risk
22:17:20 <ivanm> and thus it is a partial function
22:17:47 <Gracenotes> total functions have a non-error (non-bottom) answer for every value
22:17:53 <kmc> the correct type of head would be [a] -> Maybe a
22:17:54 <ivanm> listToMaybe is a nice safe version of head
22:17:56 <kmc> :t listToMaybe
22:17:57 <lambdabot> forall a. [a] -> Maybe a
22:18:03 <kmc> this forces the caller to handle the empty-list case
22:18:05 <ivanm> kmc: you mean should rather than would?
22:18:12 <kmc> would rather than is
22:18:17 <elspru> i've been using haskell for years, but i guess i'm still a beginner, haven't made any monads, or created any new data types
22:18:27 <kmc> yeah
22:18:29 <ivanm> elspru: there aren't really many new monads to create...
22:18:45 <ivanm> but at the very least surely you've created custom data types just to pass data around your code...
22:18:46 <kmc> if you haven't created data types, you have not used the language thoroughly
22:18:50 <elspru> ya, i've never come across requiring them
22:18:53 <kmc> or you're overusing tuples
22:18:54 <kmc> and Either
22:18:56 <elspru> pure functions have always been enough
22:18:58 <ivanm> kmc: that's probably it
22:19:08 <ivanm> elspru: ummm... I use pure functions with custom data types...
22:19:23 <elspru> ya, i only use String, [String] and Int
22:19:29 <Twey> â€¦ hahaha
22:19:34 <ivanm> *shudder*
22:19:36 <Gracenotes> hm. that works.
22:19:38 <elspru> I love it :D
22:19:40 <kmc> okay, i mean, Haskell is a fine desk calculator
22:19:42 <elspru> it's so simple
22:19:47 <Twey> I think you want Tcl, elspru
22:19:56 <elspru> ew
22:20:08 <elspru> that's dirty
22:20:15 <elspru> *shakes head*
22:20:17 <Gracenotes> elspru: well, if you are interested in the language in a way that lets you be much more expressive, try reading
22:20:19 <Gracenotes> @where lyah
22:20:19 <Raynes> kmc: Oh, I see.
22:20:19 <lambdabot> http://www.learnyouahaskell.com/
22:20:20 <Twey> I know!  It uses strings for everything!  :Ã¾
22:20:23 <kmc> you really ought to define new types rather than using tuples.  because (person's name, person's age) and (name of nuclear test, yield in megatons) may both be represented (String, Float), but they sure as hell aren't the same type
22:20:34 <Twey> Heheh
22:20:41 <elspru> Gracenotes: I know how to make new datatypes, I've just never needed to
22:21:05 <ivanm> then you must write really boring code, or really unsafe code
22:21:11 <kmc> also, using Int is premature optimization
22:21:21 <kmc> except for the unfortunate fact that some library functions take it where they could take Integer
22:21:22 <ivanm> e.g. trying to continually parse a string representation of your data
22:21:25 <Gracenotes> well. text processing is interesting :) not as interesting as other uses
22:21:30 <ivanm> kmc: I disagree
22:21:35 <Twey> kmc: Well, sometimes you *want* overflow
22:21:37 <ivanm> I usually see no reason to use Integer
22:21:39 <kmc> Twey, eeew
22:21:49 <kmc> the overflow size of Int is platform specific
22:21:51 <ivanm> kmc: note that IntMap needs Int...
22:21:56 <kmc> hmm, that's a good point
22:22:06 <elspru> so is Integer safer than Int ?
22:22:10 <Twey> Like I saidâ€¦ :Ã¾
22:22:12 <Twey> elspru: Yes
22:22:13 <kmc> elspru, Integer has arbitrary range
22:22:15 <Twey> Integer won't overflow
22:22:19 <kmc> Int overflows at machine size
22:22:22 <elspru> cool
22:22:26 <elspru> perhaps I should do that
22:22:30 <Twey> (it'll just eat all your memory instead.  Muhaha)
22:22:44 <Gracenotes> well. Integers in Int range have Int size :x
22:22:47 <kmc> ivanm, would be nice to make IntegerMap, which would pair an IntMap with a (Map Integer), and would pattern-match on the Integer to see if it's the short-form or long-form (iirc, GHC's Integer is an algebraic type of this form, though i could be wrong)
22:23:00 <c_wraith> @src Integer
22:23:00 <lambdabot> data Integer = S# Int#
22:23:00 <lambdabot>              | J# Int# ByteArray#
22:23:03 <Gracenotes> there is a bit of overhead sorting the cases though
22:23:08 <Dashkal_> 2^(2^(2^(2^(2)))) :P
22:23:08 <c_wraith> @src Int
22:23:09 <lambdabot> data Int = I# Int#
22:23:10 <kmc> yeah that
22:23:22 <Twey> Weird
22:23:40 <c_wraith> so the unboxed Int# type is the same underneath
22:23:48 <Twey> What's the effective difference between Int# and Int, then?
22:23:53 <ivanm> elspru: Int is more efficient than Integer though
22:23:56 <kmc> Int# is strict and unboxed
22:23:57 <c_wraith> Int# is unboxed
22:23:58 <ivanm> Twey: unboxed vs boxed
22:23:59 <Gracenotes> Twey: the types or the values?
22:24:00 <kmc> can't be used polymorphically
22:24:01 <kmc> no [Int#]
22:24:05 <Twey> Ahh
22:24:07 <kmc> no id :: Int# -> Int#
22:24:13 <elspru> hmmm, well mainly i just write compilers
22:24:18 <Twey> But the only constructor for Int seems unboxed
22:24:19 <Gracenotes> unless you define an id in your own scope
22:24:19 <kmc> ahahahahaha
22:24:27 <elspru> text files aren't usually all that long
22:24:36 <Twey> elspru: *eyebrow*
22:24:38 <Gracenotes> elspru: no ASTs for them?
22:24:43 <elspru> AST?
22:24:45 <kmc> the representation of Int# is a machine integer, not a pointer to a heap-allocated object containing a machine integer
22:24:48 <c_wraith> Twey: # doesn't mean unboxed.  It just means "this is kind of an internal reference detail"
22:24:49 <kmc> abstract syntax tree
22:24:49 <Gracenotes> abstract syntax trees
22:24:52 <Twey> 9.2M    /home/twey/Languages/Japanese/edict.utf8
22:24:57 <Twey> c_wraith: Oh, okay
22:25:00 <elspru> those are gross
22:25:02 <kmc> # is technically just another character you can use in identifiers, with ghc extension
22:25:04 <lunabot>  luna: parse error on input `in'
22:25:13 <kmc> but it's generally used for unboxed or otherwise special low-level stuff
22:25:14 <Gracenotes> unless you just do all text-to-text transformation, with state entirely kept in some CPS-like construct
22:25:18 <elspru> well i mean, it's okay for visual thinkgers i guess
22:25:27 <elspru> but i'm doing a spoken language
22:25:41 <kmc> how can you possibly compile something without building a data structure
22:25:44 <elspru> so, i just do text parsing
22:25:53 <kmc> how can you parse text without a structure to parse it into
22:25:59 <elspru> wordGet caseGet sentenceGet
22:26:02 <Gracenotes> Twey: Int# also means that no value of the type is a reference. all bits to contribute to some primitive value, of what bit pattern it actually *has*
22:26:11 <kmc> there are also the unboxed tuples which use syntax like (# 1, 2 #)
22:26:11 <elspru> kmc: it's already structures
22:26:19 <kmc> elspru, no, you said it's strings
22:26:31 <elspru> if i don't find the structure i'm looking for, i return an error
22:26:43 <Gracenotes> Twey: not just a memory pointer. so the optimization of unboxing constructors gets rid of a layer of memory pointers, which can speed things up
22:26:53 <Twey> elspru: Sounds like you're rather masochistic :Ã¾
22:26:58 <elspru> er a structure i mean like "subject quote hello world" is a case "structure"
22:27:01 <Twey> Gracenotes: *nod*
22:27:13 <kmc> elspru, and you represent that as strings all the way through?
22:27:22 <elspru> well i use [String]
22:27:28 <Gracenotes> you can only pattern match a primitive value on other primitive values as well, effectively other bit patterns. :x
22:27:30 <kmc> not, say, data Sentence = Simple { subject, verb, object :: String }
22:27:38 <elspru> so i don't have to getWord every time
22:27:51 <elspru> kmc: that's not scalable
22:27:56 <elspru> or forward compatible
22:28:06 <kmc> so how are you representing the structure of these things?
22:28:11 <kmc> if every sentence is a flat list of words
22:28:17 <kmc> how do you know what parts of speech, clauses, etc. there are?
22:28:29 <elspru> by the case markers
22:28:43 * Twey suspects there's a â€˜getSubjectâ€™ function in there somewhere
22:28:49 <BMeph> elspru: Does your language have reflexive cases? :)
22:28:54 <kmc> by magical words which are also strings?
22:29:06 <elspru> subject elspru do say object quote hello enquo to name haskell irc channel ya
22:29:17 <elspru> subject name elspru *
22:29:19 <kmc> wow, this is a profoundly bad way to do natural language processing
22:29:24 <Gracenotes> to quote Perlis, "The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information."
22:29:30 <elspru> kmc: it's a constructed language
22:29:38 <Gracenotes> you are duplicating much process. Why not let Haskell do the work for you?
22:29:53 <kmc> Gracenotes, good quote
22:30:07 <kmc> why is your language flat?
22:30:12 <elspru> maybe i'm just not smart enough *shrugs*
22:30:16 <kmc> most languages have a recursive structure of clauses which are made of other clauses
22:30:31 <kmc> elspru, i doubt that
22:30:36 <elspru> kmc: which just makes it more confusing
22:30:42 <kmc> seems more like you haven't been exposed to the right concepts for this task
22:31:14 <kmc> even if your language is flat, you should at least mark the words with proper constructors rather than magical string words that are compared character by character every time
22:31:56 <kmc> data Tag = Subject | Do | Object | Name | ...
22:32:22 <elspru> but humans don't make parse trees when they process language
22:32:26 <kmc> yes we do
22:32:29 <kmc> not rigidly
22:32:32 <elspru> oh well i don't
22:32:34 <Gracenotes> linguistics would tend to disagree with you.
22:32:42 <kmc> anyway why do you think a computer should process language the way a human does?
22:32:54 <kmc> if that worked, you'd simply buy a new computer and spend a year talking at it
22:32:54 <elspru> well they way the programmer does
22:32:58 <Gracenotes> all languages commonly in use are recursive
22:33:02 <kmc> programmers definitely build parse trees
22:33:05 <kmc> how else would you program?
22:33:06 <elspru> kmc: that's the goal
22:33:10 <kmc> computer languages definitely aren't flat
22:33:27 <elspru> kmc: as in to have a human speakable language, that you can just talk to the computer
22:33:34 <kmc> no i mean
22:33:39 <kmc> you would buy a new computer with no OS in it
22:33:41 <kmc> and just talk at it
22:33:43 <kmc> and it would learn
22:33:47 <kmc> as long as you also pour apple sauce on it
22:33:54 <Gracenotes> I like apple sauce
22:33:57 <elspru> well it has a bios, the bios could have the human speakable language
22:34:06 <elspru> i'm currently working on human speakable assembly
22:34:09 <kmc> elspru, someone had to program the bios
22:34:17 <kmc> why would they program it using [String] rather than AST?
22:34:18 <mtnviewmark> oh - and bananas and graham crackers - those kind of computers definitely like graham crackers!
22:34:26 <kmc> mmm graham crackers
22:34:42 <elspru> are those vegan?
22:34:54 <kmc> elspru, your argument that "computers should be just like humans" fails once you're the one programming the computer
22:34:55 <dolio> I don't think you can give them graham crackers until they're a year or two old.
22:34:55 <elspru> i prefer whole foods anyway
22:35:21 <elspru> kmc: well computers are like humans, they just have much better memories
22:35:27 <elspru> and logical facilities
22:35:43 <elspru> like autistic people
22:35:48 <Gracenotes> is it just me, or is the actual structure of that memory very important
22:36:05 <elspru> Gracenotes: well, can represent it using the source code
22:36:19 <elspru> one language, for all things
22:36:23 <elspru> just like a human does it
22:37:02 <kmc> elspru, okay, you can buy a new Dell and leave it at the BIOS screen and pour apple sauce on it for a year
22:37:09 <kmc> and i'll write a parser with a proper AST
22:37:11 <Gracenotes> elspru: your subconscious certainly doesn't use language
22:37:25 <kmc> and after a year we'll see whose computer can identify the object in "hello world"
22:37:32 <mtnviewmark> I'm not sure there is any consensus on just how humans represent information or think or compute -- or if they even use "one langauge"
22:37:58 <elspru> well some people are bilingual
22:37:59 <dolio> You're not sure?
22:38:12 <dolio> There might be such a consensus that you aren't aware of?
22:38:16 <elspru> i'm a cognitive scientist and specialize in artificial intelligene
22:38:16 <dolio> :)
22:38:58 <lament> I'm a troll and I specialize in trolling
22:39:09 <mtnviewmark> I've just been reading a history of Bertrand Russel -- I'm inclined to not be sure of ANYTHING
22:39:14 <Gracenotes> anyhow. a key selling point of Haskell is that type safety helps ensure program correctness.
22:39:16 <dolio> :)
22:39:19 <elspru> dolio: there isn't really a consensus, most in my field are busy making up new formats and algorithms, trying to making "intelligence" emerge from their abstract mathematical dohickies
22:40:00 <elspru> while themselves having little idea of what the word "intelligence" means to them or anyone else
22:40:17 <elspru> lol, it's quite silly really
22:40:40 <Paczesiowa> is there a way to import a hidden module? or do I have to hide that package and use its sources explicitily?
22:41:00 <dolio> Paczesiowa: I don't think there's a way.
22:41:54 <Paczesiowa> great, I have to fork a library because it doesn't want to export some function:/
22:42:32 <dolio> Yeah.
22:43:38 <Paczesiowa> I need unsafeImportIO
22:44:11 <kmc> hehe
22:44:23 <kmc> yeah, i'm annoyed by the lack of an easy way to override export lists
22:44:24 <Paczesiowa> how about an ugly hack? I just need to write testcases, doesn't have to be pretty or reliable
22:44:36 <elspru> yay it worked :D
22:44:42 <elspru> !
22:46:08 <elspru> i found the empty head
22:46:40 <elspru> and compiled into machine code
22:47:12 <Paczesiowa> hackage died:/
22:49:42 <elspru> it's okay my kitty congratulated me
22:51:26 <ivanm> Cat: the other white meat
22:51:26 <ivanm> ;-)
22:53:06 <elspru> ivanm: i heard human tastes like lamb, were lots of famines where I'm from (Ukraine), lots of cannibal jokes to
22:53:33 <ivanm> ÐÑƒ, Ð¥Ñ€Ð¸ÑÑ‚Ð¾Ñ Ð Ð¾Ð¶Ð´Ð°Ñ”Ñ‚ÑŒÑÑ Ð·Ð° Ð·Ð°Ð²Ñ‚Ñ€Ð° Ñ‚Ð¾Ð´Ñ–!
22:53:39 * ivanm is of Ukrainian descent
22:53:59 <ivanm> elspru: and AFAIK, it's usually said that people taste like pork (long pig, etc.)
22:54:22 <ivanm> (but my joke was me channeling my food studies teacher from high school...)
22:54:41 <elspru> oh ya? that's cool :), ya recently i heard a cannibal joke, about how one shouldn't cook student stew, since they might eat all the vegetables
22:55:15 <ivanm> heh
22:55:54 <elspru> i guess students ate vegetables in the Ukraine
22:56:01 <elspru> lol
22:56:11 <ivanm> because they're cheap ;-)
22:56:30 <kmc> i don't get ivanm's joke
22:56:33 <elspru> ya, that's the explanation they told me to!
22:56:36 <kmc> possibly because i don't speak ukranian
22:56:47 <ivanm> kmc: the other white meat?
22:56:53 <ivanm> nah, it's not ukrainian
22:57:18 <ivanm> more like situational humour
22:57:23 <elspru> kmc: the cyrilic says christ was bord
22:57:27 <elspru> born*
22:57:37 <kmc> "Well, Christ is Born by tomorrow then!"
22:57:39 <kmc> says google
22:57:46 <elspru> ya
22:57:56 <elspru> orthodox christmas
22:58:03 <ivanm> not quite: "Well, Merry Christmas for tomorrow!" is a more idiomatic translation
22:58:12 <ivanm> elspru: well, ukrainian catholic as well...
22:58:29 <ivanm> so for google s/by/for/ ;-)
22:58:37 <elspru> really? from the west then.
22:58:52 <ivanm> yeah
22:58:56 <elspru> polish influence
22:59:03 <ivanm> ummm, no
22:59:14 <ivanm> if you look in the history books, Ukraine started off Catholic...
22:59:25 <elspru> wel ya, poles are catholics as well
22:59:31 <ivanm> then most of them became Orthodox to be different from the Polish and due to the Russian influence
22:59:49 <elspru> o, ya, i always heard it the other way around, but i'm from Kiev
23:00:42 <ivanm> heh, fair enough
23:01:20 * ivanm prefers Lviv over Kiev for tourist purposes
23:01:43 <Paczesiowa> does ghc keep some kind of cache for .conf files?
23:01:51 <elspru> from the stories I hear, I wouldn't go within a thousand miles of eastern europe
23:01:59 <ivanm> Paczesiowa: don't think so
23:02:17 <ivanm> elspru: even though you're from there and have relatives there, etc.? :o
23:02:21 <Paczesiowa> I modified .conf from hint to expose that module, but it still says it;s hidden
23:02:31 <elspru> ivanm: well they are the ones that tell me the tales
23:02:32 <ivanm> Paczesiowa: :o
23:02:37 <ivanm> Paczesiowa: which ghc?
23:02:41 <ivanm> elspru: heh
23:02:45 <Paczesiowa> 6.12.1
23:02:49 <ivanm> elspru: it's changed a lot over the past 12 years
23:03:04 <ivanm> Paczesiowa: well, maybe with the whole package ID stuff you've borked something...
23:03:18 <ivanm> Paczesiowa: might be easier to download, edit, cabal install it
23:03:41 <elspru> ya, my aunt came by for a visit, she says beer's not alcohol, and the mafia keeps everything in order
23:04:06 <Paczesiowa> ivanm: what id? I've only moved module name from hidden list to exposed.
23:04:26 <ivanm> Paczesiowa: 6.12 uses some id based stuff for packages
23:04:36 <ivanm> elspru: heh
23:05:07 <ivanm> elspru: well, soft-drink/pop/juice/whatever == water there in some parts...
23:05:30 <elspru> like texas
23:05:41 <ivanm> but what I've always found weird in central/eastern europe (don't know about western): no-one opens windows, and no-one keeps drinks cold
23:05:44 <ivanm> even in summer!
23:05:46 <elspru> the land of giants
23:06:30 <elspru> ya, i haven't visited in a long time, I'm also told smiling offends people
23:06:47 <elspru> since they think you have something they dont
23:07:10 <fooblya_monad> No one open windows because here is very long history of wars and other such events
23:07:27 <Paczesiowa> don't forget the thieves!
23:07:41 <elspru> Paczesiowa: it's an official occupation,
23:07:47 <fooblya_monad> open window attract unnecessary attention
23:08:40 <Paczesiowa> could someone resurrect hackage?
23:09:04 <ivanm> Paczesiowa: have to get the galois people to do so
23:09:13 <ivanm> dons is on leave, and I don't know if any of the rest of them idle here...
23:09:15 <Gracenotes> it was unsurrected at some point?
23:09:41 <ivanm> fooblya_monad: no, no-one opens windows because you might catch a chill from the draft (that's the explanation I was given anyway)
23:10:11 <Paczesiowa> @seen jcpetruzza
23:10:11 <lambdabot> Unknown command, try @list
23:10:14 <hiredman> http://en.wikipedia.org/wiki/Fan_death possibly related
23:10:28 <Paczesiowa> ,seen jcpetruzza
23:10:29 <lunabot>  luna: Not in scope: `seen'
23:10:36 <Paczesiowa> preflex: help
23:10:38 <preflex>  try 'help help' or see 'list' for available commands
23:10:43 <Paczesiowa> preflex: list
23:10:56 <preflex>  Cdecl: [cdecl]; 8ball: [8ball]; Factoid: [+, -, ., ?, delete, get, store]; Help: [help, list]; Karma: [++, --, karma, karmabot, karmatop]; Nickometer: [nickometer]; Nickr: [nickr]; Seen: [seen]; Sixst: [6st]; Tell: [ask, clear-messages, messages, tell]; Rot13: [rot13]; Quote: [be, quote, remember]; WCalc: [calc, wcalc]; Version: [version]; XSeen: [xseen]; ZCode: [zdec, zenc]
23:10:56 <ivanm> hiredman: :o
23:10:56 <ivanm> preflex: seen jcpetruzza
23:10:56 <preflex>  jcpetruzza was last seen on #ghc 188 days, 21 hours, 28 minutes and 55 seconds ago, saying: yes
23:10:56 <ivanm> Paczesiowa: ^^
23:11:00 <fooblya_monad> yes, weather here also doesn`t suit for open windows
23:11:03 <Paczesiowa> ivanm: thx
23:11:15 <ivanm> fooblya_monad: where is "here"?
23:11:25 <fooblya_monad> eastern europe
23:11:28 <fooblya_monad> belarus
23:11:30 <ivanm> fooblya_monad: even in summer?
23:11:55 <ivanm> it was sweltering when I was in Ukraine in August 07!
23:12:04 <fooblya_monad> in summer I am opening windows :)
23:12:05 <ivanm> and I was just in Serbia last year in August, and it was hot then as well
23:12:12 <ivanm> fooblya_monad: right, I was talking about summer
23:13:31 <fooblya_monad> but I really think that draft is not mail reason to not open windows
23:13:52 <fooblya_monad> main
23:14:14 <hiredman> possibly a belief in reverse fan death
23:14:47 <fooblya_monad> nice!
23:15:00 <fooblya_monad> soo good urban legend.
23:15:33 <hiredman> is it really an urban legend if a whole country believes it?
23:15:55 <fooblya_monad> it doesn`t matter :)
23:15:58 <hiredman> large parts of korea are rather rural
23:16:17 <kmc> haha fan death
23:16:58 <hiredman> http://www.fandeath.net/ :D
23:17:31 <fooblya_monad> excellent
23:17:32 <elspru> :t ord
23:17:33 <lambdabot> Char -> Int
23:17:42 <elspru> hmm is there one that converts to Integer?
23:17:54 <kmc> :t fromIntegral . ord
23:17:56 <lambdabot> forall b. (Num b) => Char -> b
23:19:21 <elspru> Couldn't match expected type `a -> b' against inferred type `Int' In the second argument of `(.)', namely `ord char' In the expression: fromIntegral . ord char
23:19:49 <kmc> (fromIntegral . ord) char
23:19:56 <kmc> fromIntegral . ord $ char
23:20:00 <kmc> fromIntegral (ord char)
23:20:07 <kmc> fromIntegral $ ord char
23:20:09 <kmc> take yr. pick
23:20:22 <kmc> function application associates tighter than binary operators
23:20:40 <kmc> hence what you wrote is fromIntegral . (ord char), which don't make sense as (ord char) is not a function, and (.) composes two functions
23:20:52 * kmc recommends fromIntegral . ord $ char
23:21:22 <elspru> fromIntegral (ord char)
23:22:47 <fooblya_monad> i think that $ operator is main and most crazy haskell feature :)
23:23:53 <kmc> hahaha
23:24:10 <kmc> @src ($)
23:24:10 <lambdabot> f $ x = f x
23:24:34 <Paczesiowa> $ =
23:25:37 <tensorpudding> i would argue that (.) is superior to ($)
23:25:49 <elspru> i dislike both
23:25:52 <kmc> @src (.)
23:25:53 <lambdabot> (f . g) x = f (g x)
23:25:55 <elspru> just makes for added confusion
23:26:13 <tensorpudding> why?
23:26:13 <elspru> elitest syntax sugar
23:26:16 <Guest10026> @tell luqui There is a tiny bug (I think) in the new drawing combinators library. The affine transforms are applied in reverse. Try scaling and then translating - is that how you want it to be? I "fixed" it here by changing the order in the function that applies a new affine transform on an Image (I think %%)
23:26:16 <lambdabot> Consider it noted.
23:26:49 <tensorpudding> it makes things clearer and takes less space
23:26:55 <kmc> is it really sugar?
23:26:59 <tensorpudding> it saves you having to write a lot more parentheses
23:27:00 <kmc> it's an ordinary user-defined binary operator
23:27:23 <cizra> .. but it's a sweet ordinary user-defined binary operator.\
23:27:25 <kmc> are data types elitist too?
23:27:47 <elspru> maybe
23:27:52 <elspru> lol
23:27:59 <elspru> well it's okay, you seem to find them useful
23:28:06 <fooblya_monad> $ and . is just user-defined operators. And it makes haskell and them soo good :)
23:28:18 <elspru> go ahead
23:28:24 <elspru> i use $ sometimes as well
23:28:33 <elspru> haven't wrapped my head around . though
23:28:41 <fooblya_monad> but $ really adds to confusion
23:28:42 <kmc> @src (.)
23:28:43 <lambdabot> (f . g) x = f (g x)
23:28:52 <elspru> ya, like what's that?
23:28:57 <tensorpudding> (.) is exactly function composition
23:28:59 <kmc> > filter (not . isAlphaNum) "some, text ! here."
23:29:00 <lambdabot>   ",  ! ."
23:29:05 <kmc> it's useful
23:29:06 <tensorpudding> just like in maths
23:29:18 <kmc> elspru, what do you mean? it says that ((f . g) x) is f (g x)
23:29:31 * elspru sighs
23:29:52 <kmc> i think by using Haskell you are already exposed to accusations of elitism
23:29:54 <tensorpudding> i suppose point-free style is debatable
23:29:56 <elspru> looks like f g x to me
23:30:10 <kmc> elspru, f (g x)  is not the same as  (f g) x
23:30:15 <fooblya_monad> f g x its application f to g and x
23:30:15 <kmc> which is what f g x is
23:30:25 <elspru> kmc: you just said it was
23:30:29 <kmc> no
23:30:38 <elspru> well there was a dot
23:30:39 <kmc> ((f . g) x) is f (g x)
23:30:46 <elspru> see, f g x
23:30:50 <kmc> grr
23:30:53 <elspru> :)
23:30:54 <kmc> do you not see the dot?
23:30:59 <kmc> or do you just choose to ignore it
23:31:00 <elspru> it's so small
23:31:02 <kmc> sigh
23:31:06 <Axman6> -_-
23:31:07 <elspru> ya exactly
23:31:08 * kmc is done getting trolled
23:31:11 <elspru> that's how i feel
23:31:25 <Axman6> yeah, i'm sensing some trolling here too
23:31:53 <tensorpudding> if there is a function i'm not sure about the merits of, it's flip
23:32:52 <jaspervdj> tensorpudding: for function composition
23:33:11 <jaspervdj> tensorpudding: for example, forM could be defined as `flip mapM`
23:33:27 <tensorpudding> well, in simple definitions like that, yes
23:33:43 <orbekk> > foldl1 (flip const) [1..10]
23:33:44 <lambdabot>   10
23:33:45 <tensorpudding> i would be aghast to see a function def that used flip twice
23:35:02 <Stinger> @pl \a b c d -> a d b c
23:35:02 <lambdabot> (flip .) . flip
23:35:04 <lament> :t flip
23:35:05 <tensorpudding> in such a case i'd prefer a lambda
23:35:05 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
23:35:11 <lament> oh god
23:35:15 <lament> it's a caleflip
23:35:20 <kmc> hehe
23:35:29 <tensorpudding> that case is definitely clearer as a lambda than in @pl
23:35:43 <kmc> that's not rare ;)
23:36:02 <Twey> Eh
23:36:08 <Twey> (flip .) . flip isn't too scary
23:36:25 <tensorpudding> it's much more unpacking than the lambda, for no space gain
23:36:39 <Twey> Yeah, but lambdas are just ugly :Ã¾
23:36:46 <tensorpudding> not as a rule
23:36:49 <medfly> Twey: to you, maybe
23:37:13 <tensorpudding> lambdas are preferrable than a plate of uncurry with a flippant side of flips
23:37:52 <tensorpudding> flip is not as visual as lambdas
23:37:56 <kmc> :t \m -> map (flip M.lookup m)
23:37:57 <lambdabot> forall a a1. (Ord a) => M.Map a a1 -> [a] -> [Maybe a1]
23:38:03 <Twey> IMO, lambdas are an ugly resort that's useful only when the equivalent is even worse
23:38:08 <kmc> ^^^^ a reasonable use of flip i think
23:38:12 <Twey> Yeah
23:38:16 <tensorpudding> lambdas are good hacks
23:38:19 <kmc> some uses of flip can be subsumed as sections
23:38:26 <kmc> :t \m -> map (`M.lookup` m)
23:38:26 <Twey> Although you could use (`M.lookup` m) there
23:38:26 <tensorpudding> you put them in, then try to refactor them out
23:38:27 <Twey> Yeah
23:38:27 <lambdabot> forall a a1. (Ord a) => M.Map a a1 -> [a] -> [Maybe a1]
23:38:29 <kmc> that's weird though
23:38:33 <medfly> I like lambdas. it's very clear what's happening.
23:38:35 <Twey> kmc: Nah
23:38:38 <tensorpudding> if the alternative is worse, you leave the lambda in
23:38:40 <medfly> somehow this channel likes unreadable code a lot.
23:38:42 <Twey> tensorpudding: Yeah
23:38:43 <tensorpudding> in this case, the lambda is clearer
23:38:53 <Twey> Arguably
23:39:04 <Twey> I don't think there's a major gain in legibility
23:39:07 <medfly> how can you read a combination of ., () and flip?
23:39:12 <elspru> @search Integer -> Int
23:39:12 <lambdabot> Unknown command, try @list
23:39:18 <elspru> how convert?
23:39:21 <Twey> medfly: Right-to-left
23:39:22 <tensorpudding> it's uglier, but it's immediately clear what effect the function has on the terms
23:39:28 <Twey> :t fromInteger
23:39:29 <lambdabot> forall a. (Num a) => Integer -> a
23:39:30 <Stinger> fromInteger
23:39:32 <medfly> Twey: it's just unreadable for me.
23:39:39 <Twey> medfly: You just need practice â˜º
23:39:47 <elspru> o
23:39:47 <tensorpudding> for example
23:39:51 <medfly> Twey: if I need to practice it's probably unreadable
23:40:05 <orbekk> elspru: @hoogle
23:40:05 <kmc> that's an extreme view
23:40:07 <Twey> medfly: Err
23:40:13 <Twey> A very extreme view
23:40:15 <elspru> orbekk: i tried that, didn't work
23:40:16 <Twey> Go back to COBOL :Ã¾
23:40:27 <kmc> :t fromIntegral
23:40:29 <lambdabot> forall a b. (Integral a, Num b) => a -> b
23:40:33 <tensorpudding> @pl \x y z a b c -> c y a x b z
23:40:34 <lambdabot> ((flip . ((flip . (flip .) . flip) .)) .) . flip (flip . (flip .) . flip . flip id)
23:40:40 <kmc> > fromIntegral (3 :: Integer) :: Int
23:40:41 <elspru> orbekk: oh, okay, ya thanks
23:40:41 <lambdabot>   3
23:40:42 <Twey> Like any marginally powerful syntax, Haskell requires practice to read anyway
23:40:43 <tensorpudding> an extreme example
23:40:51 <Twey> tensorpudding: Yeah, that's obviously better as the lambda
23:41:24 <chelz> anyone else having trouble getting anything to load on hackage.haskell.org ?
23:41:54 <Twey> http://downforeveryoneorjustme.com/hackage.haskell.org
23:42:13 <Twey> I've been using this site an awful lot this weekâ€¦ what's happening to the Internetâ€½
23:43:27 <chelz> ah, good to know it isn't just me. i too have been experiencing a lot of weird technical issues.
23:43:34 <elspru> Twey: it's those socialists
23:43:41 <chelz> damn socialists!
23:43:43 <elspru> lol
23:43:52 <tensorpudding> socialists, on my internet?
23:44:01 <elspru> they think they own it
23:44:26 <Twey> Y2K10 bugs, maybe
23:44:34 <Ramchip> @unpl ((flip . ((flip . (flip .) . flip) .)) .) . flip (flip . (flip .) . flip . flip id)
23:44:34 <lambdabot> (\ ai be b c f i -> i be c ai f b)
23:44:40 <Twey> Haha
23:44:44 <Twey> ai be?
23:44:45 <tensorpudding> there is an @unpl?
23:44:55 <Twey> Interesting variable names
23:44:59 <Ramchip> yes
23:44:59 <tensorpudding> @unpl (flip (.)) . flip
23:45:00 <lambdabot> (\ l c f -> c (\ i -> l i f))
23:45:09 <tensorpudding> @unpl ($)
23:45:10 <lambdabot> (\ a b -> a b)
23:45:21 <tensorpudding> it's all lambdish
23:45:26 <Twey> Haha
23:45:36 <Paczesiowa> can you delete packages from hackage?
23:45:49 <tensorpudding> the moral is, @pl and @unpl mostly output ugly stuff
23:46:51 <mauke_> @pl \f g x y -> f y (g y (f x y) x)
23:46:51 <lambdabot> ap ((.) . (.) . ap) (flip flip id . (liftM2 flip .) . flip ((.) . ap))
23:46:55 <mauke_> @. unpl pl \f g x y -> f y (g y (f x y) x)
23:46:55 <lambdabot> ((\ ak b c f -> ak >>= \ aq -> (b c f) >>= \ ao -> return (aq ao)) >>= \ ad -> (\ ax l -> (\ ab -> l >>= \ bf -> (ax ab) >>= \ be -> return (bf be)) >>= \ o -> (\ m -> m) >>= \ n -> return (\ u -> o
23:46:55 <lambdabot> u n)) >>= \ ac -> return (ad ac))
23:46:56 <jaspervdj> Paczesiowa: I don't think so
23:46:59 <mauke_> MONSTERKILL
23:47:40 <tensorpudding> @pl \_ _ _ _ _ -> undefined
23:47:40 <chelz> wow
23:47:40 <lambdabot> const (const (const (const (const undefined))))
23:47:41 <medfly> hehe
23:47:54 <elspru> so okay, let me really try to grasp this . thing.   f . g x, is the same as g x f ?
23:48:06 <tensorpudding> no
23:48:18 <lifflander> I need cabal-install-0.8.0.tar.gz but hackage.haskell.org is down. Anyone know why?
23:48:19 <elspru> hmmm, g f x ?
23:48:27 <tensorpudding> (f . g) returns a function that applies g, then applies f to the result
23:48:41 <elspru> so it's g f ?
23:48:43 <mauke_> f . g x is \y -> f (g x y)
23:48:44 <tensorpudding> so (f . g) x = f (g x)
23:49:00 <elspru> can you not use brackets? like one concept a time please
23:49:05 <chelz> lifflander: http://haskell.org/cabal/release/cabal-install-0.8.0/cabal-install-0.8.0.tar.gz
23:49:08 <mauke_> err...
23:49:09 * Twey snrk
23:49:37 <mauke_> elspru: that's like trying to explain a * (b + c) = a*b + a*c without using brackets
23:49:37 <lifflander> chelz: Thanks
23:49:50 <tensorpudding> > (const 5) . (const undefined) 5
23:49:51 <lambdabot>   No instance for (GHC.Show.Show (f t))
23:49:51 <lambdabot>    arising from a use of `M1828449907...
23:50:02 <tensorpudding> > (const 5) . (const undefined)
23:50:04 <lambdabot>   {()->5}
23:50:08 <tensorpudding> huh
23:50:16 <elspru> mauke_: functions don't have bedmas
23:50:28 <mauke_> elspru: what?
23:50:45 <kyagrd> Has anyone used the new IO library in GHC 6.12?  I wonder what changes have been made since the announcement says it has become unicode friendily or something like that.  Would that men we no longer need utf8-string library?
23:50:47 <Ramchip> > (const 5) . (const undefined) $ 5
23:50:47 <Twey> 06:17:54 < elspru> i've been using haskell for years
23:50:48 <lambdabot>   5
23:50:48 <elspru> > 5 . * 5
23:50:49 <lambdabot>   <no location info>: parse error on input `*'
23:50:52 <tensorpudding> hmm, wait
23:50:55 <Twey> And I'm the Sultan of Australia.
23:51:03 <tensorpudding> > (\x -> 5) . (const undefined)
23:51:05 <lambdabot>   {()->5}
23:51:25 <elspru> i never learned this . thing, i just had people translate it to brackets for me
23:51:38 <kmc> elspru, i thought you didn't want to use brackets either
23:51:39 <tensorpudding> :t seq
23:51:40 <lambdabot> forall a t. a -> t -> t
23:51:43 <elspru> i understand the $ cause that's just a starting bracket, and ends with new line
23:51:48 <kmc> no it's really not
23:51:52 <kmc> it's a binary operator
23:51:55 <tensorpudding> > (\x -> x `seq` 5) . (const undefined)
23:51:57 <lambdabot>   * Exception: Prelude.undefined
23:51:59 <tensorpudding> there we go
23:52:06 <kmc> > map ($ 3) [pred, succ]
23:52:07 <mauke_> elspru: new line? you're confused
23:52:07 <lambdabot>   [2,4]
23:52:18 <elspru> or a  ending bracket
23:52:44 <elspru> > 3 . chr
23:52:45 <lambdabot>   No instance for (GHC.Num.Num (GHC.Types.Char -> b))
23:52:45 <lambdabot>    arising from the lit...
23:52:48 <medfly> > map (\n-> n 3) [pred, succ]
23:52:49 <lambdabot>   [2,4]
23:52:51 <medfly> ^_^
23:53:10 <tensorpudding> > map ($ 3) [pred, succ]
23:53:11 <lambdabot>   [2,4]
23:53:17 <elspru> > chr . 3
23:53:18 <lambdabot>   No instance for (GHC.Show.Show (f GHC.Types.Char))
23:53:19 <lambdabot>    arising from a use of...
23:53:28 <elspru> > ord . 3
23:53:29 <lambdabot>   No instance for (GHC.Show.Show (f GHC.Types.Int))
23:53:29 <lambdabot>    arising from a use of ...
23:53:36 <elspru> > ord 3
23:53:37 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
23:53:37 <lambdabot>    arising from the literal `3...
23:53:43 <elspru> > chr 61
23:53:43 <tensorpudding> :t ord
23:53:44 <lambdabot>   '='
23:53:44 <lambdabot> Char -> Int
23:54:10 <elspru> >  ord 6
23:54:11 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
23:54:11 <lambdabot>    arising from the literal `6...
23:54:13 <newsham> ?type zipWith ($) (cycle [toUpper, id])
23:54:14 <lambdabot> [Char] -> [Char]
23:54:21 <elspru> ord '6'
23:54:26 <elspru> > ord '6'
23:54:27 <lambdabot>   54
23:54:34 <tensorpudding> @src cycle
23:54:35 <lambdabot> cycle [] = undefined
23:54:35 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
23:54:36 <elspru> > '6' . ord
23:54:37 <lambdabot>   Couldn't match expected type `a -> b'
23:54:37 <lambdabot>         against inferred type `GHC.Ty...
23:54:41 <lifflander> chelz: I'm trying to bootstrap cabal-install using the script that is provided. However it uses the base path "http://hackage.haskell.org/packages/archive" to download the packages it needs, which doesn't work. Do you know an alternative to this for all the packages that it is trying to download?
23:54:41 <elspru> oh well
23:54:44 <kmc> elspru, you can private message lambdabot
23:54:50 <elspru> oh thanks
23:54:56 <newsham> > map (\c -> ord c - read c) "0123456789"
23:54:56 <lambdabot>   Couldn't match expected type `GHC.Base.String'
23:54:57 <lambdabot>         against inferred typ...
23:54:57 <kmc> @run foo
23:54:58 <lambdabot>   Not in scope: `foo'
23:55:09 <kmc> she doesn't understand > in private message
23:55:16 <newsham> > map (\c -> ord c - read [c]) "0123456789"
23:55:17 <lambdabot>   [48,48,48,48,48,48,48,48,48,48]
23:55:36 <kmc> > zipWith ($) (cycle [toUpper, id]) "i understand the $ cause that's just a starting bracket, and ends with new line"
23:55:38 <lambdabot>   "I UnDeRsTaNd tHe $ cAuSe tHaT'S JuSt a sTaRtInG BrAcKeT, aNd eNdS WiTh nEw...
23:55:43 <mauke_> kmc: yes, she does
23:55:53 <kmc> oh, hmm
23:55:57 <kmc> i think that used to not work
23:56:04 <mauke_> :t doesn't work IIRC
23:56:05 <lambdabot> Not in scope: `doesn't'
23:56:05 <lambdabot> Not in scope: `work'
23:56:05 <lambdabot> Not in scope: data constructor `IIRC'
23:56:25 <lifflander> Does anyone know an alternative to http://hackage.haskell.org/packages/archive path which hangs?
23:56:55 <Paczesiowa> lifflander: why do you need cabal-install if hackage is down?
23:57:26 <lifflander> I did not know that cabal-install gets it packages from hackage
23:57:28 <medfly> hehehe
23:57:33 <medfly> :t (4)
23:57:34 <lambdabot> forall t. (Num t) => t
23:57:34 <lifflander> Is that true?
23:57:38 <Paczesiowa> lifflander: yes
23:57:45 <lifflander> Why is it down?
23:58:00 <alex404> Is there anyway to pattern match against a global variable?
23:58:01 <newsham> must not be written in haskell
23:58:14 <Paczesiowa> lifflander: no idea
23:58:17 <newsham> case expr ?
23:58:25 <newsham> or do you mean something else?
23:58:41 <kmc> alex404, what do you mean by a global variable?
23:58:49 <kmc> you want to match x so long as x == y, for some global y?
23:58:51 <alex404> Just a variable set at the top of my program
23:58:57 <alex404> Yah
23:59:02 <newsham> if you're thinking of comparison, thats not what pattern matching does
23:59:04 <kmc> you can't accomplish that with a pattern alone, but you can use a guard
23:59:05 <kmc> on (==)
23:59:10 <newsham> pattern matching deconstructs data, it doesnt do comparisons
23:59:30 <alex404> I understand your way of doing it kmc...
23:59:41 <alex404> But why can I pattern match against, say, '7'
23:59:47 <alex404> But not, lucky, where lucky = 7
23:59:53 <kmc> because 7 is a pattern
23:59:54 <Paczesiowa> > let x = 2 +2 in case x of 4-> "yay"; _ -> ":/"
23:59:55 <lambdabot>   "yay"
