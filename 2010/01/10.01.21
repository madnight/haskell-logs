00:01:53 <avizit> so i am back with somemore issues, what is wrong with http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16382#a16382 ? I thought  after the readFile action , input should have the content of the whole file as a string
00:03:35 <c_wraith> what error are you getting?
00:03:48 <c_wraith> actually, I see at least two things wrong there.
00:03:51 <Adamant> space?
00:04:05 <avizit>  Couldn't match expected type `IO' against inferred type `[]'
00:04:06 <c_wraith> First, the type signature is wrong
00:04:21 <c_wraith> second, the function is doing IO, so it needs to be in the IO monad
00:04:21 <Adamant> think there needs to be a space between do and <-
00:04:34 <Adamant> or maybe not
00:04:36 <c_wraith> meaning you need to use return on the last line
00:05:27 <avizit> whats wrong with the type ? I think String belongs to EQ , i need it to be Eq cos later i take union of  the lists
00:06:06 <c_wraith> avizit: you're doing IO, so the type needs to have IO in it.
00:06:33 <c_wraith> avizit: also, the type of the list will be [[String]], not [[t]].
00:06:53 <Adamant> gun. meant do and <-
00:06:56 <Adamant> *guh
00:07:08 <avizit> I see .
00:08:02 <c_wraith> you can't make a type more polymorphic than it actually is.  the compiler will tell you so if you try.  Since the return values of lines and words say String, that's what you're stuck with.
00:10:07 <avizit> oh okay. But should my function type now be String-> IO [[String]] ?
00:10:35 <c_wraith> I believe so.  (I haven't tried to compile it, so I'm not the ultimate authority here. :)
00:13:05 <c_wraith> You'll run into one additional problem.
00:13:51 <avizit> i already am.
00:13:54 <c_wraith> Specifically, the last line of the do block is current not an IO expression, so you'll need to make it one. (use the return function)
00:15:56 <avizit>  Couldn't match expected type `IO t', against inferred type `[[String]]' <-- this after the typed was changed to String->IO [[String]] and also adding a return at the end of the do block.
00:16:10 <c_wraith> avizit: can you post what you have now?
00:17:06 <avizit> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16385#a16385
00:17:43 <c_wraith> ah.  return isn't like return in a language like C or Java.  It's pretty horribly misnamed, really.
00:17:48 <c_wraith> it's actually a function
00:17:53 <c_wraith> :t return
00:17:54 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
00:18:17 <jaspervdj> return should probably be called "inject"
00:18:18 <c_wraith> The basic idea is that it takes a value that's not in a monad context, and returns that same value in the monad context.
00:18:50 <c_wraith> So you really want that second line to be "return (map words (lines input))"
00:19:05 <c_wraith> because it makes an IO value out of the otherwise non-IO expression there
00:19:50 <avizit> oh okay thanks thats more comprehensible to me than the explaination with monad context. though would be glad to have a really good reference to monads.
00:20:07 <c_wraith> Eh.  For the time being, don't worry about monads.  Just think of return for IO
00:20:22 <c_wraith> just remember that return makes a non-IO value into an IO value.
00:20:32 <c_wraith> And you probably won't have cause to use it anywhere else
00:21:02 <avizit> compiled fine thanks.  I remember I stopped haskell some 3-4 years ago when i had probs with monads.this is my second try.
00:21:05 <jaspervdj> avizit: this blogpost might be helpful: http://neilmitchell.blogspot.com/2010/01/haskell-io-without-monads.html
00:21:15 <avizit> thanks jaspervdj
00:22:07 <Saizan> http://www.haskell.org/haskellwiki/Monads_as_computation <- this one is quite good for the more general notion of monads
00:22:28 <Saizan> however what is really needed to make monads easy is a good grasp of the type system
00:22:35 <c_wraith> Yeah.  Learn how to do stuff in haskell before you learn about monads.  They're really not as complicated as they seem, you just need some exposure to the language for a while before you get a good feel of how they fit in.
00:23:47 <avizit> thanks Saizan, c_wraith . yeah this time i dont intend to give up.
00:25:47 <c_wraith> avizit: haskell's a great language to learn, because it does so much well.  Learn it at your own pace.  Enjoy it. :)
00:27:47 <avizit> yeah I am aware of the goodies. Previously I was doing scheme but its lack of IO was very limiting hence  the move to haskell.
00:29:53 <Botje> lack of IO?
00:30:44 <avizit> as in i could not read a file or write a file in scheme . or maybe i did not know scheme well enough either.
00:30:50 <avizit> i was only using the interpreter.
00:32:17 <c_wraith> scheme certainly can do that, but it's nice having a type system that enforces that IO only takes place in some places.
00:33:37 <avizit> ah  did not know that.
00:35:30 <Botje> (call-with-input-file "foobar" (lambda (port) (display (read port))))
00:35:53 <Botje> for the record :)
00:36:26 <avizit> i feel dumb :)
00:36:40 <c_wraith> lisp function names sorta weird me out sometimes.  Of course, it doesn't help that the lisp I'm exposed to most is elisp.
00:36:52 <c_wraith> And I'm sure elisp is probably the worst lisp in common use.
00:36:57 <avizit> even DrScheme implements the call-with-input-file
00:43:24 <avizit> okay the function return type is now  say IO [[String]], now can it be given as argument to any function which expects a [[String]] or I need to do some massaging of the return type ?
00:44:33 <c_wraith> You can only use IO values in other functions with an IO return type.
00:44:59 <c_wraith> That's why people often say that you can't escape from IO, you can only put stuff into it.
00:45:16 <c_wraith> So it's common to write as much of the code as possible in a way that doesn't touch IO.
00:45:30 <avizit> yeah I am having a feeling that a chain of my functions are going to get a IO inside it somehow
00:46:10 <c_wraith> So think about reversing it...  have main read your file, apply some string-processing function to it, and then do whatever it was going to do with the processed result.
00:46:23 <c_wraith> that's a very common pattern for a lot of IO
00:46:34 <c_wraith> and it lets you keep the part of your program in IO small
00:46:51 <avizit> thanks , this probably means a bit of redesigning on my part.
00:48:07 <c_wraith> It's a different way of thinking about it than a lot of people initially have, but it has some strong benefits when you can fit it to the problem you're solving.
00:54:07 <avizit> yeah needs rework . I could get my small functions working when using GHCi and read the input file from inside the interpreter. Facing trouble only when it comes to making an executable , thats when i come across all these IO etc.
00:55:07 <c_wraith> well, those same small functions that you can test with ghci should be the building blocks of your program anyway.
00:55:58 <c_wraith> The last jump is to do IO on top of those small functions
00:59:34 <tomoj> I just realized about the audio-visual isomorphism for haskell that there can also be information transmitted in text which can't really be transmitted through voice
00:59:56 <tomoj> both at the same time is probably best
01:01:25 <solrize> whatsis
01:01:28 <solrize> oops sorry
01:21:52 <pozic> How do I enable >>= showing a type in the minibar in Emacs in Haskell mode?
01:45:34 <pozic> What's the name of a function which is applied to every element of a data structure, but doesn't change the type?
01:46:28 <dobblego> endofunctor?
01:55:56 <Peaker> I like the new "Practical language" instead of "Functional language" :)
01:58:37 <temoto> @hoogle intercalate
01:58:38 <lambdabot> Data.ByteString intercalate :: ByteString -> [ByteString] -> ByteString
01:58:38 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
01:58:38 <lambdabot> Data.ByteString.Char8 intercalate :: ByteString -> [ByteString] -> ByteString
02:01:21 <temoto> @hoogle catchError
02:01:22 <lambdabot> Control.Monad.Error.Class catchError :: MonadError e m => m a -> (e -> m a) -> m a
02:06:48 <temoto> > 2**3
02:06:49 <lambdabot>   8.0
02:07:03 <temoto> @src (**)
02:07:03 <lambdabot> Source not found. Where did you learn to type?
02:10:12 <Veinor> @src (**) :: Int -> Int -> Int
02:10:12 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
02:14:52 <temoto> Lord Veinor?
02:15:04 <temoto> FF10?
02:15:07 <temoto> no, 12?
02:22:21 <Alpounet> @hoogle (**)
02:22:22 <lambdabot> Prelude (**) :: Floating a => a -> a -> a
02:22:22 <lambdabot> Control.Arrow (***) :: Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
02:22:22 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
02:27:10 <Veinor> temoto: ... what?
02:27:15 <Veinor> oh.
02:27:25 <Veinor> You're thinking of Vayne Solidor :P
02:40:34 <EnglishGent> hello :)
02:41:15 <Botje> hello!
02:42:01 <EnglishGent> hi Botje :)
02:43:04 <temoto> eval (If cond e1 e2) = do
02:43:06 <temoto>     cond_val <- eval cond
02:43:08 <temoto>     choice cond_val
02:43:10 <temoto>          where choice (Bool b) = return $ if b then e1 else e2
02:43:12 <temoto>                choice _ = throwError $ EType (SimpleType "Bool") cond
02:43:14 <temoto> Does it make sense?
02:43:21 <Botje> temoto: please don't paste code in the channel
02:43:52 <Botje> temoto: and it looks like there's an eval missing in the return
02:44:18 <Botje> also, the cond in the error should be a cond_val, i think
02:44:23 <temoto> eval e1!
02:44:26 <temoto> right, thanks
02:47:06 <EnglishGent> how's things Botje? :)
02:47:17 <Botje> busy, at the moment
02:47:23 <Botje> i'm taking C++ exams
02:47:26 * EnglishGent trying to make sense of 'type level instant insanity' from the Monad reader
02:47:32 <EnglishGent> oh - well, good luck :)
02:47:55 <Botje> it's mostly waiting for students and telling them why they're wrong
02:48:02 <Botje> i'm not sure if taking was the right verb there
02:51:30 <EnglishGent> ah! invigilating? marking? :)
02:58:17 <sohum> so which ghc is -XDeriveFunctor valid in?
02:58:27 <Saizan> 6.12
02:58:39 <sohum> right
03:03:17 * Cyneox re
03:07:30 <sohum> fmap (Branch as) = Branch (map (fmap f) as)
03:07:31 <sohum> ^ ...
03:15:13 <sohum> @hoogle gr a b -> [a]
03:15:14 <lambdabot> Did you mean: Gr a b -> [a] /count=20
03:15:14 <lambdabot> Data.Graph.Inductive.Query.DFS topsort' :: Graph gr => gr a b -> [a]
03:15:14 <lambdabot> Data.Map keys :: Map k a -> [k]
03:16:24 <sohum> @hoogle gr a b -> [LNode a]
03:16:24 <lambdabot> Did you mean: Gr a b -> [LNode a] /count=20
03:16:25 <lambdabot> Data.Graph.Inductive.Graph labNodes :: Graph gr => gr a b -> [LNode a]
03:16:25 <lambdabot> Data.Graph.Inductive.Graph edges :: Graph gr => gr a b -> [Edge]
03:29:07 <sohum> @pl \x -> f k (g x)
03:29:07 <lambdabot> f k . g
03:30:56 <temoto> @src div
03:30:56 <lambdabot> Source not found. My pet ferret can type better than you!
03:31:01 <temoto> @src (+)
03:31:01 <lambdabot> Source not found. There are some things that I just don't know.
03:31:09 <temoto> @src (mod)
03:31:09 <lambdabot> Source not found. :(
03:31:13 <temoto> @src mod
03:31:14 <lambdabot> Source not found. Do you think like you type?
03:31:28 <temoto> @hoogle mod
03:31:29 <lambdabot> Prelude mod :: Integral a => a -> a -> a
03:31:29 <lambdabot> Data.Fixed mod' :: Real a => a -> a -> a
03:31:29 <lambdabot> Text.PrettyPrint.HughesPJ data Mode
03:32:17 <temoto> HughesPJ?
03:33:38 <ccasin> One guesses it's named after the authors of a paper
03:34:46 <temoto> > show (+)
03:34:47 <lambdabot>   "-3->\n  {-3->-6;-2->-5;-1->-4;0->-3;1->-2;2->-1;3->0}\n-2->\n  {-3->-5;-2-...
03:36:28 <sohum> @hoogle LEdge a -> Edge
03:36:28 <lambdabot> Data.Graph.Inductive.Graph insEdge :: DynGraph gr => LEdge b -> gr a b -> gr a b
03:36:29 <lambdabot> Data.Graph.Inductive.NodeMap insMapEdge :: (Ord a, DynGraph g) => NodeMap a -> (a, a, b) -> g a b -> g a b
03:36:29 <lambdabot> Data.Graph.Inductive.Graph insEdges :: DynGraph gr => [LEdge b] -> gr a b -> gr a b
03:37:34 <tomoj> what type for the components of an RGB color, I wonder..
03:38:09 <Alpounet> @hoogle Color
03:38:09 <lambdabot> Text.Html color :: String -> HtmlAttr
03:38:09 <lambdabot> Text.XHtml.Transitional color :: String -> HtmlAttr
03:38:09 <lambdabot> Text.Html bgcolor :: String -> HtmlAttr
03:38:14 <Alpounet> hmm
03:38:16 <Alpounet> @hoogle rgb
03:38:17 <lambdabot> No results found
03:38:37 <Alpounet> there was something, somewhere, with RGB color related datatypes already defined.
03:39:50 <tomoj> RSAGL.Color.RGB has 3 Floats
03:39:59 <temoto> @src foldl1
03:39:59 <lambdabot> foldl1 f (x:xs) = foldl f x xs
03:40:00 <lambdabot> foldl1 _ []     = undefined
03:42:57 <temoto> @hoogle Num a => a -> Integer
03:42:57 <lambdabot> Prelude abs :: Num a => a -> a
03:42:57 <lambdabot> Prelude negate :: Num a => a -> a
03:42:57 <lambdabot> Prelude signum :: Num a => a -> a
03:43:18 <HugoDaniel> how do i get only the first 'n' elements of a list?
03:43:27 <temoto> > take 10 [5..]
03:43:28 <lambdabot>   [5,6,7,8,9,10,11,12,13,14]
03:43:32 <HugoDaniel> thanks
03:43:44 <Taejo> @quote Cale
03:43:44 <lambdabot> Cale says: But in another sense, functional programmers are applied logicians who spend all their time proving trivial theorems in interesting ways in an inconsistent intuitionist logic.
03:43:59 <Taejo> @quotes
03:43:59 <lambdabot> NormanRamsey says: Type annotations in OCaml are completely broken and always have been.
03:44:51 <temoto> Is there a coercion function for Num -> Integer?
03:46:05 <temoto> @src Integral
03:46:05 <lambdabot> class  (Real a, Enum a) => Integral a  where
03:46:05 <lambdabot>     quot, rem, div, mod :: a -> a -> a
03:46:05 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
03:46:05 <lambdabot>     toInteger           :: a -> Integer
03:46:24 <temoto> @src Num
03:46:25 <lambdabot> class  (Eq a, Show a) => Num a  where
03:46:25 <lambdabot>     (+), (-), (*)           :: a -> a -> a
03:46:25 <lambdabot>     negate, abs, signum     :: a -> a
03:46:25 <lambdabot>     fromInteger             :: Integer -> a
03:46:42 <temoto> How is integral different than num?
03:48:19 <Alpounet> Integral is rather division oriented
03:48:31 <idnar> @src Real
03:48:31 <lambdabot> class  (Num a, Ord a) => Real a  where
03:48:32 <lambdabot>     toRational      ::  a -> Rational
03:48:38 <sohum> :t sortBy
03:48:39 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
03:48:41 <sohum> :t sort
03:48:42 * idnar scratches his head
03:48:42 <lambdabot> forall a. (Ord a) => [a] -> [a]
03:48:50 <sohum> @src sort
03:48:50 <lambdabot> sort = sortBy compare
03:49:48 <sohum> is there an f in the standard library such that f g = sortBy (compare `on` g) ?
03:50:24 <sohum> :t \g -> sortBy (on compare g)
03:50:25 <lambdabot> forall b a. (Ord b) => (a -> b) -> [a] -> [a]
03:50:48 <sohum> @hoogle (Ord b) => (a -> b) -> [a] -> [a]
03:50:49 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
03:50:49 <lambdabot> Prelude filter :: (a -> Bool) -> [a] -> [a]
03:50:49 <lambdabot> Prelude takeWhile :: (a -> Bool) -> [a] -> [a]
03:51:04 <temoto> What, Num doesn't imply Ord?
03:51:22 <solrize> complex numbers are not ordered
03:51:45 <temoto> oh boy
03:51:53 <temoto> thanks..
03:54:53 <sohum> @pl \x -> f x y
03:54:53 <lambdabot> flip f y
03:58:37 <b52> hey guys
03:58:50 <b52> is there somethin like a map function which takes two arguments instead of one?
03:59:25 <Lemmih> b52: Uh, 'map' takes two arguments.
03:59:46 <b52> i mean the function which u pass to map
04:00:00 <b52> wait, ill explain what i wanna do
04:00:06 <Alpounet> hmm
04:00:16 <Alpounet> map (f.g) yourList ?
04:00:26 <Alpounet> oh
04:00:32 <Alpounet> zipWith ?
04:00:38 <Alpounet> :t zipWith
04:00:39 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
04:00:51 <Alpounet> but it thus needs two lists.
04:01:02 <Alpounet> > zipWith (+) [1,2,3] [-1, -2, -3]
04:01:03 <lambdabot>   [0,0,0]
04:01:04 <b52> i got a list L = [1, 2, 3, 4, 5] and i to generate a new list out of it like this: [a_fct 1 L\1, a_fct 2 L\2, a_fct 3 L\3, ...]
04:01:34 <Lemmih> b52: What does L\1 mean?
04:01:35 <Alpounet> zipWith a_fct [1..5] L
04:01:37 <Alpounet> ?
04:01:48 <b52> the list L except the element 1
04:01:57 <Alpounet> oh
04:03:21 <Lemmih> b52: Make a list from L\1 to L\5 and then use zipWith.
04:03:34 <b52> how?
04:04:22 <Lemmih> b52: First try to make L\1.
04:04:40 <b52> Lemmih: i got a random list, i dont know if 1 is in it
04:06:14 <Lemmih> b52: You can look in L to find out.
04:07:48 <Lemmih> b52: How about making L\1 mean 'L without the first element'?
04:08:19 * Lemmih has classes. Bye.
04:10:43 <sohum> :t (Data.List.//) -- b52
04:10:44 <lambdabot> Not in scope: `Data.List.//'
04:10:49 <sohum> :t (Data.List.\\) -- b52
04:10:50 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
04:11:08 <b52> how can i take an element out of alist?
04:11:42 <sohum> > [1,2,3,4,5,12,3,1] \\ [1,3]
04:11:44 <lambdabot>   [2,4,5,12,3,1]
04:11:54 <sohum> > delete 3 [1,2,3,4,5,12,3,1]
04:11:55 <lambdabot>   [1,2,4,5,12,3,1]
04:12:09 <b52> [my_fct x (L \\ x) | x <- L]
04:12:14 <b52> would tht work?
04:12:41 <sohum> probably
04:12:51 <sohum> but the zipWith method is better, I think
04:13:25 <etpace> :t (||) *** max
04:13:26 <lambdabot> forall b'. (Ord b') => (Bool, b') -> (Bool -> Bool, b' -> b')
04:13:41 <etpace> :t (***)
04:13:43 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
04:14:00 <b52> sohum: which zipwith method?
04:14:13 <benmachine> :t \f -> (f ***) `const` f undefined
04:14:14 <lambdabot> forall b c b' c'. (b -> c) -> (b' -> c') -> (b, b') -> (c, c')
04:14:15 <sohum> b52: the one Lemmih was talking about
04:14:18 <sohum> :t zipWith
04:14:19 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
04:14:38 <b52> i cant say that i understand what that mean :/
04:14:53 <sohum> zipWith my_fct L $ map (flip delete L) L
04:15:06 <sohum> heh, that looks weird
04:15:23 <sohum> essentially, create a second list that is a list if [L\1,L\2,L\3...]
04:15:41 <sohum> :t \l -> map (flip delete l) l
04:15:42 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
04:15:58 <sohum> and then use zipWith
04:16:40 <etpace> benmachine: isnt just the type of *** on the function arrow (b -> c) -> (b' -> c) -> (b, b') -> (c, c')? if so why is (||) *** max messing up
04:17:02 <benmachine> etpace: the thing I did was the type of *** forcing a = (->)
04:17:37 <benmachine> I wasn't particularly trying to prove anything by doing it?
04:17:47 <benmachine> what do you mean by messing up
04:18:22 <etpace> :t (||) *** max
04:18:23 <lambdabot> forall b'. (Ord b') => (Bool, b') -> (Bool -> Bool, b' -> b')
04:18:46 <etpace> that last part should be (Bool, b') innit?
04:18:55 <benmachine> err, no
04:19:14 <benmachine> you're applying Bool -> Bool -> Bool to Bool on the left
04:19:18 <benmachine> giving Bool -> Bool
04:19:26 <etpace> oh duh
04:19:26 <benmachine> and similarly with b' on the right
04:20:21 <b52> do i need to import somethin to use delete?
04:20:32 <benmachine> @hoogle delete
04:20:33 <lambdabot> Data.HashTable delete :: HashTable key val -> key -> IO ()
04:20:33 <lambdabot> Data.IntMap delete :: Key -> IntMap a -> IntMap a
04:20:33 <lambdabot> Data.IntSet delete :: Int -> IntSet -> IntSet
04:20:38 <benmachine> erm
04:20:40 <benmachine> that's not useful
04:20:48 <benmachine> try Data.List
04:21:14 <temoto> > (((5)))
04:21:15 <lambdabot>   5
04:21:23 <temoto> Shouldn't this be forbidden?
04:21:25 <etpace> @hoogle (a -> b, c -> d) -> (a, c) -> (b, d)
04:21:26 <lambdabot> No results found
04:21:34 <benmachine> temoto: why on earth would you forbid that
04:21:52 <temoto> benmachine: because it makes no sense?
04:21:56 <benmachine> :t ($) *** ($)
04:21:57 <lambdabot> forall a b a1 b1. (a -> b, a1 -> b1) -> (a -> b, a1 -> b1)
04:22:04 <benmachine> err
04:22:27 <benmachine> temoto: it's redundant, but it makes perfect sense
04:23:28 <temoto> benmachine: i don't get any sense. Could you explain?
04:23:45 <benmachine> temoto: parenthising an expression doesn't change its meaning
04:23:55 <sohum> temoto: (x) = x, for all x.
04:24:05 <benmachine> pretty much
04:24:25 <sohum> > 5 , 3
04:24:26 <lambdabot>   <no location info>: parse error on input `,'
04:24:39 <sohum> tuples are an unfortunate exception to that
04:24:43 <sohum> :t (,)
04:24:44 <lambdabot> forall a b. a -> b -> (a, b)
04:24:51 <temoto> Not in python, btw.
04:24:53 <sohum> > (,) 5 3
04:24:54 <lambdabot>   (5,3)
04:25:08 <sohum> yea, haskell's tuple grammer is a bit weird
04:25:09 <benmachine> luckily no-one cares about python
04:26:01 <sohum> *grammar
04:26:07 <benmachine> :t uncurry (***) -- etpace?
04:26:08 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => (a b c, a b' c') -> a (b, b') (c, c')
04:26:34 <etpace> nice
04:31:33 <etpace> > (\a b -> (uncurry (***)) ((||) *** max a) b) (True, 3) (False, 5)
04:31:34 <lambdabot>   Couldn't match expected type `(b, b')'
04:31:34 <lambdabot>         against inferred type `GHC.B...
04:32:00 <etpace> > (\a b -> (uncurry (***)) (((||) *** max) a) b) (True, 3) (False, 5)
04:32:00 <lambdabot>   (True,5)
04:32:07 <etpace> Not that readable it seems :p
04:32:08 <benmachine> hooray
04:32:54 <temoto> :t (5,(4.2,True),["foo"])
04:32:55 <lambdabot> forall t t1. (Num t, Fractional t1) => (t, (t1, Bool), [[Char]])
04:33:11 <benmachine> > (\(a, b) -> (|| a) *** (max b)) (True, 3) (False, 5)
04:33:12 <lambdabot>   (True,5)
04:33:33 <b52> how can i get the smallest number out of list√ü
04:33:53 <temoto> something with min or minimum
04:33:55 <benmachine> :t minimum
04:33:56 <lambdabot> forall a. (Ord a) => [a] -> a
04:34:03 <benmachine> > minimum [] -- beware
04:34:04 <lambdabot>   * Exception: Prelude.minimum: empty list
04:34:20 <b52> that case wont happen
04:34:51 <temoto> Alright, redundant parenthesis are useful for "least surprise" principle.
04:36:55 <benmachine> temoto: indeed
04:38:15 <dobblego> > let minimum' = foldl (\a -> Just . ap min (flip fromMaybe a)) Nothing in minimum' []
04:38:16 <lambdabot>   Nothing
04:41:08 <b52> :http://paste.pocoo.org/show/167946/ im trying to implement a method to solve tsp
04:41:29 <b52> but somethin is wrong :/
04:41:56 <drostin77> ignorant question: What is the standard way to build sizable haskell projects.  Makefiles? Cabal? Something completely different? (sorry if i just sent this msg 3 times, irssi was giving me troubles)
04:42:38 <dobblego> drostin77, I use ghci and cabal
04:42:48 <benmachine> drostin77: it differs according to need but everything on hackage is (by necessity) built with cabal
04:43:16 <benmachine> a notable exception is gtk2hs which I believe can't be cabalised (and hence isn't on hackage)
04:46:46 <temoto> What is the name of operators in haskell that do not require backticks?
04:46:59 <temoto> "normal operator" doesn't sound good
04:47:22 <benmachine> operator?
04:47:40 * benmachine shrugs
04:47:47 <temoto> I want to distinguish (+) and `plus`.
04:47:56 <dqd> I would say an infix operator.
04:48:01 <mauke> symbolic operators
04:48:04 <benmachine> I think I might call `plus` an infix function
04:48:12 <benmachine> or a function used infix
04:48:17 <mauke> or just "operator"
04:48:36 <temoto> Thanks.
04:54:37 <Quadrescence> WOW, I joined just to say that I just realized http://media.nokrev.com/junk/haskell-logos/logo1.png has a >>= in it
04:54:38 <Quadrescence> !!!
04:56:16 <mauke> it's lambda + bind, or "blind" for short
05:01:31 <Veinor> Quadrescence: you just fedex-arrowed me.
05:01:55 <Quadrescence> Veinor: Oh my
05:03:09 <temoto> oh my.. another toy language parser just compiled!
05:03:16 <temoto> ghc --make is great
05:04:12 <temoto> hm but it didn't produce an executable
05:04:25 <temoto> ghc --make MicroFlow/Main.hs
05:04:33 <temoto> it compiled 3 dependant modules
05:04:43 <temoto> but no executable, what did i do wrong?
05:05:18 <mauke> I think you're wrong
05:05:52 <temoto> Is it because i placed "module MicroFlow.Main" into Main.hs?
05:06:20 <mauke> do you have a file called Main or Main.exe or MicroFlow/Main or MicroFlow/Main.exe?
05:06:21 <temoto> mauke: what do you mean?
05:06:36 <temoto> no /i'm on linux/
05:07:53 <temoto> Now i removed "module MicroFlow.Main where" first line from Main.hs and --make produced an executable MicroFlow/Main.
05:08:05 <Quadrescence> temoto: I made a toy language
05:08:35 <quicksilver> temoto: yes, you need -main-is
05:08:43 <quicksilver> unless you have that option, main is in 'Main'
05:08:49 <quicksilver> (and unnamed moduels are 'Main')
05:08:57 <quicksilver> with the option you can choose which module's 'main' to use.
05:09:25 <temoto> Ah, so i should call the module just Main, not MicroFlow.Main?
05:09:41 <temoto> I wonder what's common practice is.
05:09:45 <quicksilver> http://www.haskell.org/ghc/docs/latest/html/users_guide/options-phases.html
05:09:53 <quicksilver> no you absoultely can call it MicroFlow.Main
05:09:59 <quicksilver> you just need to tell GHC you've done so.
05:10:08 <quicksilver> it's quite handy to have several main functions in various modules.
05:10:18 <quicksilver> or indeed in one module (although then you have to give them different name)
05:10:23 <quicksilver> -main-is is the path to happiness.
05:12:25 <temoto> Alright. What's common build/try/test routine way?
05:13:05 <temoto> Quadrescence: what is that language? Do you translate it into something?
05:13:28 <EnglishGent> hi
05:13:53 <EnglishGent> would someone be willing to help me with some code from a Monad reader article?
05:14:10 <EnglishGent> I've followed the instructions - but it doesnt seem to work - and I really dont know why not
05:14:36 <EnglishGent> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16389#a16389
05:15:06 <EnglishGent> hi Grey_Fox :)
05:15:32 <Grey_Fox> hi EnglishGent
05:16:22 <EnglishGent>  :type apply (u :: Orientations) (u :: Cube1) - gives an error
05:16:53 <EnglishGent> Top level:
05:16:53 <EnglishGent>     Couldn't match expected type `Nil'
05:16:53 <EnglishGent>            against inferred type `Cube W B G R G B
05:16:53 <EnglishGent>                                   ::: (Cube G R B B W G ::: Nil)'
05:16:53 <EnglishGent>     When using functional dependencies to combine
05:16:54 <EnglishGent>       ListConcat Nil l l,
05:16:56 <EnglishGent>         arising from the dependency `l1 l2 -> l'
05:17:03 <EnglishGent> whereas in the article - that produces a very long type signature
05:17:23 <EnglishGent> but as far as I can see - the code is the same - with the same compiler flags being used
05:23:16 <Grey_Fox> *Main> :type apply (u::Rotation) (u::Cube1)
05:31:17 --- mode: irc.freenode.net set +o quicksilver
05:31:17 --- mode: irc.freenode.net set +v ddarius
05:31:43 <EnglishGent> wb all
05:32:28 <quicksilver> am I going to have to ban alexsuraci again?
05:32:30 --- mode: irc.freenode.net set +v lunabot
05:32:40 <quicksilver> mauke: where's preflex?
05:32:55 <quicksilver> oh, netsplit still in progress
05:33:10 --- mode: irc.freenode.net set +o ChanServ
05:36:15 <quicksilver> preflex: seen alexsuraci
05:36:33 <benmachine> preflex might need voice?
05:36:42 <quicksilver> was just wondering that
05:36:58 <quicksilver> shouldn't do, it's identified
05:36:59 -preflex(n=preflex@95-88-118-220-dynip.superkabel.de)- alexsuraci was last seen on #haskell 22 days, 17 hours, 48 minutes and 41 seconds ago, saying: hmmmmm
05:37:04 <quicksilver> ah, there you go.
05:37:09 --- mode: quicksilver set +b *!*=alexsura@*.aubnin.fios.verizon.net
05:37:10 <benmachine> heh
05:37:34 <SamB_XP> hehehehehe
05:40:47 <elt0n> can somebody please explain me the meaning of the ":" in this code \f p -> f++'*':p
05:41:10 * SamB_XP /msg's alexsuraci to tell him why he was banned
05:41:18 <SamB_XP> elt0n: it's like "cons" in lisp
05:41:26 <SamB_XP> only it goes in the middle
05:41:48 <Lemmih> > '*':" is a star"
05:41:48 <lambdabot>   "* is a star"
05:42:27 <SamB_XP> elt0n: I have often wished I could write that as (++"*"++)
05:42:29 <Lemmih> SamB_XP: Why was he banned?
05:42:53 <quicksilver> Lemmih: because he keeps excess flooding
05:42:58 <quicksilver> Lemmih: I suspect his client has been exploited
05:43:03 <SamB_XP> Lemmih: he kept getting disconnected from Freenode for excess flooding, apparantly ...
05:43:13 <Lemmih> Oh.
05:43:26 <quicksilver> he'll probably get K-lined at some point but mostly his messages were filling the channel, for people who don't have them hidden.
05:43:26 <SamB_XP> quicksilver: oh, I was just assuming he was not aware of the existance of pastebins
05:43:37 <quicksilver> SamB_XP: no, it's repeated and consistent for hours at a time
05:43:40 <quicksilver> (yesterday)
05:43:40 <SamB_XP> ah
05:44:05 <dang`r`us> is there a difference between 'foo' and "foo" ?
05:44:09 <quicksilver> I unbanned him after a few hours assuming he'd probably have been K-lined and had a chance to fix it.
05:44:11 <SamB_XP> dang`r`us: yeah
05:44:13 <SamB_XP> > 'foo'
05:44:14 <lambdabot>   <no location info>:
05:44:14 <lambdabot>      lexical error in string/character literal at chara...
05:44:16 <quicksilver> dang`r`us: yes, 'foo' isn't legal at all ;)
05:44:20 <dang`r`us> oh. ok.
05:44:24 <quicksilver> > 'f'
05:44:25 <lambdabot>   'f'
05:44:29 <quicksilver> '' for Chars, "" for strings
05:44:29 <dang`r`us> single char, got it.
05:44:37 <SamB_XP> hmm, I wish lambdabot took a bit more of the error message :-(
05:44:48 <SamB_XP> though actually that wouldn't help, would it?
05:45:11 <benmachine> well, if she just dropped the no location info message that would be a start
05:45:34 <benmachine> > (\x -> x x) (\x -> x x)
05:45:35 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
05:45:38 <SamB_XP> oh, right
05:45:43 <benmachine> hmm
05:45:45 * benmachine shrugs
05:45:57 <SamB_XP> well, actually, I wish that she could tell GHC something about the location!
05:46:15 <benmachine> > ''
05:46:16 <lambdabot>   <no location info>:
05:46:17 <lambdabot>      lexical error in string/character literal at chara...
05:46:31 <benmachine> > let a in a
05:46:32 <lambdabot>   <no location info>: parse error on input `in'
05:46:49 <ddarius> > '\&'
05:46:49 <lambdabot>   <no location info>:
05:46:50 <lambdabot>      lexical error in string/character literal at end o...
05:46:51 <b52> this is my solution for the tsp http://paste.pocoo.org/show/167981/ it actually only calculates the length of the shortest route, but doesnt remember the route itself, how could i make it remember the shortest route?
05:46:57 <SamB_XP> @run x
05:46:58 <lambdabot>   x
05:47:01 <elt0n> Lemmih, hey ok i got it, thx
05:47:18 <SamB_XP> so, like, she could tell GHC that the user input came from a file called "@run"
05:48:25 <SamB_XP> so GHC would be like "@run:0:1:", in the "''" case
05:48:36 <quicksilver> SamB_XP: or, how cares what the file's called, we just want the 0:1 part
05:48:40 <quicksilver> s/how/who/
05:48:54 <SamB_XP> well, I just figure that that name is nice and short
05:49:06 <SamB_XP> as opposed to whatever GHCi uses
05:49:39 <xerox> L.hs has a filename pragma
05:50:14 <quicksilver> GHCi uses <interactive>
05:50:22 <quicksilver> which is still shorter than <no location info>
05:50:28 <SamB_XP> quicksilver: true
05:50:41 <SamB_XP> quicksilver: that's better than I thought!
05:52:05 <Alpounet> b52, by putting each step of the shortest route in a list ?
05:52:36 <quicksilver> b52: change your 'route' function to not just return the distance/cost but also the route taken
05:52:47 <quicksilver> b52: change the zipWith to combine this appropriately
05:53:10 <b52> could you give me some hints how to do that? im completly new to haskell
05:53:11 <quicksilver> and change the minimum to minimum on only the cost/distance part
05:53:26 <quicksilver> make it return a tuple (cost,route)
05:53:30 <quicksilver> that is, (Int,[Int])
05:53:40 <b52> ok
05:56:07 <SamB_XP> are you guys trying to solve the traveling salesman problem?
05:56:15 <b52> yeah, i do
05:56:20 <SamB_XP> didn't amazon solve that like a decade ago?
05:56:28 <b52> ?
05:56:40 * SamB_XP waits for someone else to explain ;-P
05:56:51 <Alpounet> haha
05:56:52 <Alpounet> nice
05:57:47 <SamB_XP> nobody else wants to explain?
05:58:21 <ddarius> SamB_XP: There are still girl scount.
05:58:27 <ddarius> s/scount/scouts/
05:58:52 <SamB_XP> the idea is that Amazon doesn't travel to sell you stuff ;-P
05:59:06 <SamB_XP> ddarius: they go to multiple cities to sell scalp cookies ?
05:59:29 <ddarius> Some probably do.
06:00:28 <SamB_XP> well, in this economy I guess it might make sense -- except how do they pay for gas money?
06:00:37 <Alpounet> they walk.
06:00:44 <SamB_XP> !
06:00:47 <LeNsTR> (-:
06:00:57 <Alpounet> scout spirit inside
06:01:30 <SamB_XP> anyway, I think their actual problem is a bit more like the "shortest knight's tour" ;-P
06:01:54 <b52> zipWith (\x y -> let r = route x y in (distance i x + fst r, snd r ++ [i]))
06:02:07 <b52> would that be a valid solution for the zipWith part?
06:03:26 <SamB_XP> 'twould be more efficient to do "i : snd r"
06:03:37 <b52> yeah already fixed that
06:03:54 <SamB_XP> and then, if desired, reverse the list after
06:04:03 <b52> ?
06:04:08 <SamB_XP> but I dunno if that code actually makes any sense anyway ;-P
06:04:49 <SamB_XP> b52: well, (i :) adds i to the opposite end of the list from (++ [i])
06:06:14 <SamB_XP> > (i :) [1,2,3]
06:06:15 <lambdabot>   [i,1,2,3]
06:06:23 <SamB_XP> > (++i) [1,2,3]
06:06:24 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
06:06:24 <lambdabot>         against inferred ...
06:06:34 <SamB_XP> > (++[i]) [1,2,3]
06:06:35 <lambdabot>   [1,2,3,i]
06:06:47 <SamB_XP> @type i
06:06:48 <lambdabot> Expr
06:07:20 <b52> hmm ok, i got list like that [(a, [a]), (a, [a])] where a is an Int
06:07:52 <b52> i now need to find the minimum, by minimum i mean the smallest fst value of eaczh tuple
06:07:56 <b52> how could i do that?
06:08:06 <Alpounet> @type minimumBy
06:08:07 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
06:08:41 <Alpounet> @type minimumBy (compare . fst)
06:08:42 <lambdabot>     Occurs check: cannot construct the infinite type: a = (a, b)
06:08:42 <lambdabot>       Expected type: (a, b)
06:08:42 <lambdabot>       Inferred type: a
06:08:59 <SamB_XP> > minimumBy (comparing fst) [(24, [41]), (13, [14,52])]
06:09:00 <lambdabot>   (13,[14,52])
06:09:06 <Alpounet> comparing yeah
06:09:17 <SamB_XP> or, for purists:
06:09:18 <b52> oh
06:09:26 <SamB_XP> > minimumBy (compare `on` fst) [(24, [41]), (13, [14,52])]
06:09:27 <lambdabot>   (13,[14,52])
06:09:52 <Alpounet> and then, snd on the result to get the route :-)
06:10:36 <b52> what do i need to import to use comparing?
06:10:36 <SamB_XP> or, heck, you could just use minimum
06:10:43 <SamB_XP> @hoogle comparing
06:10:44 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
06:10:52 <SamB_XP> @hoogle on
06:10:52 <Alpounet> @type minimum
06:10:53 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
06:10:53 <lambdabot> Text.PrettyPrint.HughesPJ OneLineMode :: Mode
06:10:53 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
06:10:53 <lambdabot> forall a. (Ord a) => [a] -> a
06:10:55 <b52> how could i just use minimumon a list of tuples?
06:11:17 <SamB_XP> > minimum [(24, [41]), (13, [14,52])]
06:11:18 <lambdabot>   (13,[14,52])
06:11:30 <b52> interesting
06:12:08 <SamB_XP> see, the default ordering for a pair already goes primarily by the first component ;-)
06:12:11 <DekuNut> I know I can use sqrt and cbrt to get the square and cube root of a number, but is there a way to specify that first number, like the 2 or 3
06:12:19 <DekuNut> As in: http://upload.wikimedia.org/math/a/1/0/a10c7f2aa138b1565920d17c22062a35.png
06:12:25 <DekuNut> The '3' in there
06:12:25 <b52> SamB_XP: :D really nice
06:12:37 <b52> only a few lines :>
06:12:39 <benmachine> DekuNut: raise to the power 1/n?
06:12:40 <b52> haskell is awesome
06:13:11 <DekuNut> benmachine, er, are you not just talking about exponentiation now? (My math is REALLY bad)
06:13:22 <benmachine> > 8 ** (1/3)
06:13:23 <lambdabot>   2.0
06:13:32 <DekuNut> Oh I see
06:13:38 <SamB_XP> comparing can be quite handy for records, or if you want to compare the *second* component, or if you have a slightly less simple (but still quite fast!) function you want to compare the results of ...
06:13:42 <benmachine> so, yes :P
06:13:49 <DekuNut> Didn't know that :o, thanks
06:13:50 <benmachine> but beware:
06:13:55 <benmachine> > (-1) ** (1/3)
06:13:56 <lambdabot>   NaN
06:14:21 <benmachine> if you want to take odd roots of negative numbers, you have to temporarily make them positive
06:14:35 <DekuNut> Ah ok
06:14:45 <benmachine> due to the weird way floating-point numbers work
06:15:02 <benmachine> (1/3 is not exactly representible in a finite number of binary digits)
06:15:14 <SamB_XP> (if it's not a really fast function, you might as well map (f &&& id) over the list first, then pass (comparing fst) to the By function ...
06:16:37 <SamB_XP> ... evidently, the first part of that is a common idiom in Python, though of course there they use list comprehensions, not Arrow notation, to build the list of tuples ...)
06:18:58 <DekuNut> Ok, thanks benmachine
06:18:59 * Baughn is ever so slowly falling in love with arrows
06:19:10 <pao> what are other notable Arrow instances?
06:19:19 <pao> other that r->a, obviously...
06:19:37 <Baughn> I don't know about notable, but I'm working on one right now that lets the flow of execution jump from machine to machine
06:19:58 <pao> Baughn: nice :-)
06:20:14 <Baughn> Dealing with shared subexpressions is hard, though. :/
06:20:21 <quicksilver> pao: a -> m b for all monads m
06:20:23 <benmachine> pao: newtype Kleisli m a b = Kleisli { runKleisli :: a -> m b } is the only other one in Control.Arrow
06:20:27 <quicksilver> pao: is just about the most notable.
06:20:32 <benmachine> where m is a monad
06:21:22 <pao> @type (***)
06:21:23 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
06:22:26 <Baughn> Oleg++
06:22:33 <quicksilver> Baughn: funnily enough, me too
06:22:59 <pao> > runKleisli $ Kleisli (\x -> [x x x]) *** Kleisli (\x -> [x x])
06:22:59 <Baughn> quicksilver: You too what, exactly?
06:22:59 <quicksilver> Baughn: in my case for "parsing" tree-like structures, such as recursive ADTs
06:22:59 <Baughn> Ah yeah.
06:22:59 <quicksilver> Baughn: ever so slowly falling in love with arrows.
06:23:00 <lambdabot>   Occurs check: cannot construct the infinite type: b = b -> b -> c
06:23:22 <Baughn> quicksilver: Well, it's an incredibly general structure for specifying data flow. :)
06:23:27 * quicksilver nods
06:23:29 <Baughn> Yet it still somehow manages to be useful
06:23:42 <quicksilver> in a way, although not the same way as monad
06:23:56 <quicksilver> monad manages to be useful because there are useful functions which work on all monads
06:23:58 <benmachine> > runKleisli $ Kleisli (\x -> [x, x, x]) *** Kleisli (\x -> [x, x, x])
06:23:59 <lambdabot>   ((),())->
06:23:59 <lambdabot>    [((),()),((),()),((),()),((),()),((),()),((),()),((),()),((),(...
06:24:00 <quicksilver> (like mapM_, for example)
06:24:04 <benmachine> erk
06:24:14 <benmachine> > runKleisli (Kleisli (\x -> [x, x, x]) *** Kleisli (\x -> [x, x, x])) ()
06:24:14 <lambdabot>   Couldn't match expected type `(b, b')' against inferred type `()'
06:24:16 <quicksilver> whereas there don't seem to be that many general functions which run on all aroows
06:24:36 <benmachine> > runKleisli (Kleisli (\x -> [x, x, x]) *** Kleisli (\x -> [x, x, x])) (x, y)
06:24:36 <lambdabot>   [(x,y),(x,y),(x,y),(x,y),(x,y),(x,y),(x,y),(x,y),(x,y)]
06:24:42 <Baughn> Arrows are useful because what I'm writing is an Arrow, would always have been an Arrow, and fortunately I don't have to reinvent them.
06:24:54 <Baughn> Also, the syntax is handy
06:25:09 <benmachine> > runKleisli (Kleisli (\x -> [x+1, x+2, x+3]) *** Kleisli (\x -> [x, x*2, x*3])) (x, y)
06:25:10 <lambdabot>   [(x + 1,y),(x + 1,y * 2),(x + 1,y * 3),(x + 2,y),(x + 2,y * 2),(x + 2,y * 3...
06:25:13 <pao> > runKleisli (Kleisli (\x -> [x, x, x]) *** Kleisli (\x -> [x, x])) (x, y)
06:25:14 <lambdabot>   [(x,y),(x,y),(x,y),(x,y),(x,y),(x,y)]
06:25:36 <quicksilver> Baughn: Ah. I've not used the syntax yet.
06:25:41 <quicksilver> Baughn: must try that soon :)
06:25:48 <quicksilver> I'm just writing combinators by hand
06:26:00 <pao> benmachine: x and y are handled as "symbols"?
06:26:10 <quicksilver> a baffling range of them and I'm not sure how many are definable on general arrows or what other laws they are requiring.
06:26:14 <benmachine> pao: they are constants defined by the SimpleReflect module
06:26:18 <benmachine> :t x
06:26:19 <lambdabot> Expr
06:26:19 <pao> > x + y
06:26:20 <lambdabot>   x + y
06:26:36 <benmachine> they are values just like 2 and 'x', but with clever typeclass instances
06:26:43 <pao> benmachine: SimpleReflect is a module specific to lambdabot or general?
06:26:50 <benmachine> it's in the show package I think
06:27:45 <Baughn> quicksilver: Mine's much simpler. I think using a parser as your first arrow might be a bit baffling in itself. ;)
06:27:58 <quicksilver> perhaps. I'm not using it because it's an arrow
06:28:03 <quicksilver> I just happen to have noticed it is
06:28:06 * Baughn nods
06:28:09 <quicksilver> I haven't even written the instance
06:28:24 <Baughn> Even so. You might find something /else/ to notice is an arrow. :P
06:29:29 <b52> :t main
06:29:30 <lambdabot> Not in scope: `main'
06:29:43 <Baughn> Like, for example.. any imperative program / machine code can be interpreted as an arrow
06:29:52 <Baughn> Or rather, generated from one, which makes the data-flow explicit
06:31:20 --- mode: irc.freenode.net set +v ddarius
06:31:53 <pao> benmachine: nice to know! I didn't know about them
06:31:53 <pao> quicksilver: Baughn: would you suggest a Arrow reading/studying list?
06:31:53 <pao> hmm in fact also r -> a is an arrow instance via Kleisli
06:32:16 <Baughn> pao: Hey, I just got started
06:32:31 <Baughn> pao: Also, r -> a is an /uninteresting/ Arrow. The whole /point/ of Arrow is being able to inspect the internals of the function.
06:32:46 <Baughn> pao: That said..
06:32:53 <Baughn> pao: http://www.haskell.org/ghc/docs/latest/html/users_guide/arrow-notation.html <-- This
06:33:14 <Baughn> pao: The first document there (link-less, can be found via google scholar pretty easily) is a good introduction. I'd start there. ;)
06:33:30 <pao> Baughn: good
06:33:44 <Baughn> It's also the only one I've read, so I haven't gotten very far.
06:34:04 <Baughn> pao: http://okmij.org/ftp/Haskell/DSLSharing.hs <-- This is not directly related, but when using arrows you'll probably want to learn it too.
06:35:07 <pao> thanks
06:35:17 --- mode: irc.freenode.net set +o ChanServ
06:39:18 <mreh> > (\f -> (first f >>> second f)) . reverse $ ([1..10],[10..1])
06:39:19 <lambdabot>   Couldn't match expected type `cat b c' against inferred type `[a]'
06:39:27 <mreh> > [10..1]
06:39:28 <lambdabot>   []
06:39:33 <mreh> > [10,9..1]
06:39:34 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
06:39:37 <Absolute0> When I try to install xmobar in debian I get the following error during configure: Setup.lhs: xmobar.cabal:42: Parse of field 'build-depends' failed:
06:39:39 <mreh> > (\f -> (first f >>> second f)) . reverse $ ([1..10],[10,9..1])
06:39:40 <lambdabot>   Couldn't match expected type `cat b c' against inferred type `[a]'
06:39:40 <Absolute0> I tried installing ghc-cabal-dev but its already installed
06:39:42 <Absolute0> the error is not very informative
06:41:02 <xerox> > join (***) reverse ([1..10],[10,9..1])
06:41:03 <lambdabot>   ([10,9,8,7,6,5,4,3,2,1],[1,2,3,4,5,6,7,8,9,10])
06:41:11 <mreh> ahh, join
06:41:25 <mreh> :t join
06:41:26 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
06:41:33 <mreh> what monad are functions in?
06:41:46 <xerox> m = (r ->)
06:41:56 <mreh> Arrow?
06:42:08 <xerox> ?src Reader
06:42:08 <lambdabot> Source not found. :(
06:43:19 <mauke> mreh: the function monad
06:44:26 <ddarius> Monads are fun because so many handy functions are just special cases of monad operations.
06:44:45 <mreh> can you generalise this Arrow stuff to functions of n arguments
06:45:59 <jmcarthur> mreh: you mean besides things like this?   a (b, c) d
06:47:04 <mreh> jmcarthur: yes,
06:47:29 <temoto> > read "7.8"
06:47:30 <lambdabot>   * Exception: Prelude.read: no parse
06:48:19 <mauke> > read "7.8" + 1.0
06:48:20 <lambdabot>   8.8
06:48:23 <mauke> > read "7.8" :: Double
06:48:24 <lambdabot>   7.8
06:48:27 <temoto> ah
06:48:28 <jmcarthur> mreh: i'm not sure what such a generalization would look like exactly, but there probably is one somewhere
06:48:37 <temoto> Thanks.
06:49:58 <mreh> I THINK THERE WAS A NETSPLIT GUYS
06:50:25 <medfly> OH NO
06:52:26 <Jonno_FTW> the net went through meiosis?
06:52:27 <temoto> @hoogle ParsecToken
06:52:27 <lambdabot> No results found
06:58:40 <temoto> What could cause trouble loading ParsecToken while Text.ParsecCombinators.Parsec imports fine?
06:59:01 <temoto> ParserCombinators* of course
06:59:18 <uorygl> It went through meiosis, but then fertilized itself and... I can't think of any processes that result in a cell dividing in two and then reuniting.
06:59:36 <uorygl> Unless it's halfway through meiosis, in which case it won't be afterward.
07:00:18 <medfly> it's twins and then they had sex.
07:00:52 <Ferdirand> it was actually mitosis. You don't realise it, but everyone here has an evil twin present. There was no rejoining, the missing evil twins were reassembled from our own image.
07:00:54 <medfly> extremely dangerous.
07:01:36 <dino-> temoto: ym it can import Text.ParserCombinators.Parsec but not Text.ParserCombinators.Parsec.Token ?
07:02:11 <temoto> dino-: i didn't try it as separate Parsec.Token. Docs says it's whole ParsecToken, will try now.
07:03:01 <dino-> temoto: I wonder if that doc is wrong. Is it on the web, can I see it?
07:04:30 <temoto> dino-: yes, separated works, thank you very much.
07:04:55 <temoto> http://legacy.cs.uu.nl/daan/download/parsec/parsec.html
07:05:23 <temoto> If that's not best doc to parsec, i'd be very glad for another link.
07:05:39 <dino-> Sure does look old, 2001!
07:05:59 <temoto> I believe i followed a link on hackage.
07:06:16 <dino-> But this is what I have in my bookmarks too, that page.
07:08:20 <uorygl> Once I install a cabal package, can I find its docs on my system somewhere?
07:09:23 <dino-> uorygl: If it's a library and was installed with documentation enabled, yes. /usr/share/doc probably
07:09:58 <Voker57> uorygl: if you have documentation: True in ~/.cabal/config, then in $docdir from same file
07:10:07 <dino-> uorygl: I'm picky about wanting API docs always built and installed with cabal things, so I have documentation: True in my config
07:10:17 <dino-> What Voker57 said
07:13:06 <uorygl> Having installed stuff without documentation enabled, how do I get the documentation?
07:13:10 <dino-> temoto: That document seems to be the current tutorial for parsec and that's that.
07:13:15 <uorygl> Just tell cabal to install again?
07:13:35 <dino-> uorygl: yes
07:19:19 <uorygl> Heh, cabal wants Haddock, which is not installed.
07:20:22 <uorygl> And trying to install it through cabal tells me I don't have exactly the version of GHC it wants. It's aptitude time!
07:24:27 <nominolo> @pl (:) <$> blah <*> pure foo
07:24:27 <lambdabot> (:) <$> blah <*> pure foo
07:25:20 <nominolo> @src ($>)
07:25:21 <lambdabot> Source not found. It can only be attributed to human error.
07:27:02 <shepheb> the Hackage version of hmatrix has a screwy .cabal file. It has a couple of < constraints that mean it can't build against the libraries that come  stock with 6.12.1. I edited the file, and it seems to work just fine, passes all tests and so on.
07:27:24 <Alpounet> you should report that to its author.
07:29:43 <quicksilver> nominolo: (:foo) <$> blah
07:30:00 <quicksilver> nominolo: and that's not a pointless transformation but it is arguably simpler.
07:30:20 <nominolo> yeah, I need a simplifier
07:30:30 <quicksilver> that's what I'm here for ;)
07:30:48 <Alpounet> always ? :p
07:31:00 <nominolo> Are you downloadable?
07:31:13 <Alpounet> nominolo, cabal install quicksilver
07:32:22 <nominolo> I'll wait for the 1.0 release
07:33:19 <Paczesiowa> is it normal for ghc to miss docs for ffi and rts and make haddock complain?
07:33:40 <quicksilver> Alpounet: always. Where else would I go?
07:33:53 <siki> I'm using exceptions for the first time and having a bit of a hard time....:)
07:34:18 <Alpounet> quicksilver, #php ?
07:34:19 <siki> Why is this not returning 'Nothing'? handle (\DivideByZero -> return Nothing) (return (Just (5 `div` 0)))
07:34:20 * Alpounet runs away
07:35:05 <Paczesiowa> > 5 `div` 0
07:35:06 <lambdabot>   * Exception: divide by zero
07:35:31 <Paczesiowa> siki: where did you get that 'handle' from?
07:36:01 <siki> I know but I thought that the whole point of handle is that the 1st argument gets called (lambda function) if the 2nd throws and exception.
07:36:45 <Paczesiowa> siki: it's because of laziness
07:37:27 <Paczesiowa> handle (\DivideByZero -> return Nothing) (let x = 5 `div` 0 in seq x (return (Just x)))
07:37:37 <quicksilver> Alpounet: if this wasn't such a polite and friendly channel you'd have been kicked for that ;)
07:38:14 <Paczesiowa> siki: (but remember that laziness is good!)
07:38:52 <Alpounet> quicksilver, heh
07:38:57 <siki> what if I had this: let x = 5 `div` 0; handle (\DivideByZero -> return Nothing) (return $ Just x)
07:39:13 <mux> I'd use spoon for that purpose
07:39:16 <siki> this would still not be good, right?
07:39:17 <Paczesiowa> siki: let is lazy construct
07:39:26 <Botje> siki: x is never evaluated.
07:39:32 <Paczesiowa> siki: you could try case div 5 0 of x -> ...
07:39:43 <mux> siki: http://hackage.haskell.org/packages/archive/spoon/0.3/doc/html/Control-Spoon.html
07:39:44 <quicksilver> Paczesiowa: that doesn't force it either.
07:40:28 <quicksilver> spoon violates monotonicity
07:40:34 <quicksilver> round here that is one of the most serious crimes there is.
07:40:46 <siki> I see. I love laziness, but it's still hard for me to think like that sometimes and it kicks my a$$ in some unexpected places.
07:41:10 <quicksilver> > case div 5 0 of x -> "no exception here guv"
07:41:10 <lambdabot>   "no exception here guv"
07:41:13 <BONUS> exceptions are bleh anyway
07:41:22 <quicksilver> > (div 5 0) `seq` "no exception here guv"
07:41:22 <lambdabot>   "* Exception: divide by zero
07:41:31 <quicksilver> that's the difference
07:41:44 <mux> :t spoon
07:41:45 <lambdabot> Not in scope: `spoon'
07:41:50 <mux> we should add Control.Spoon to LB
07:42:06 <quicksilver> in the specific case of divide by zero, it's saner to catch it first by checking the denominator.
07:42:25 <quicksilver> mux: hell, no. Spoon encourages immoral thoughts.
07:42:59 <mux> it's sooo cute though.
07:43:23 <quicksilver> it is a common property of things encourage immoral thoughts, that they be immoral.
07:43:27 <quicksilver> erm
07:43:28 <quicksilver> cute!
07:43:34 <quicksilver> it is a common property of things encourage immoral thoughts, that they be cute.
07:43:45 <mux> kitten encourage immoral thoughts?
07:44:00 <mux> :)
07:44:10 <Paczesiowa> I don't think he meant kittens-kittens
07:48:14 <medfly> the opposite gender with kitten ears and a tail
07:48:24 * medfly translates
07:49:18 <quicksilver> no, that was just reading what I said backwards.
07:49:24 <quicksilver> I said "immoral things are often cute"
07:49:29 <quicksilver> not "cute things are often immoral"
07:50:24 <quicksilver> http://arcanux.org/lambdacats.html#entry8
07:51:04 <mux> I was trying to be funny, and apparently failed.
07:52:15 * edwardk keeps his cats away from mux and quicksilver, just in case.
07:52:46 <edwardk> gah i wish i had some indication when the server was swallowing my words
07:53:26 <int-e> clearly that's a foldl1
07:55:08 <xerox> good choice a lazy one
08:02:50 <jmcarthur> siki: laziness is something you get used to, and once the annoyance is gone it leaves only love behind
08:03:42 <EvanCarroll> sounds like herpies from a third party.
08:05:18 <jmcarthur> haha
08:15:38 <MissPiggy> what should I do instead of data Complex f = f :+i f?
08:15:56 <MissPiggy> (since that's forbidden)
08:16:10 <quicksilver> symbols must consist entirely of symbols
08:16:27 <quicksilver> you could try :+ or :+. or :.+ or :++
08:16:31 <quicksilver> whatever looks nice to you
08:16:45 <gwern> MissPiggy: isn't complex already defined?
08:16:52 <MissPiggy> yeah but it's defined wrong
08:17:04 <quicksilver> defined wrong how?
08:17:07 <Botje> @info Complex
08:17:07 <lambdabot> Complex
08:17:08 <Eduard_Munteanu> Hi
08:17:14 <MissPiggy> It wont allow me to use complex rational numbers
08:17:53 <quicksilver> yes, putting a constraint on the data decl was a mistake
08:18:01 <quicksilver> constraints on data decls aren't really useful anyway
08:18:21 <quicksilver> they should just have put constraints on those instances which needed them
08:18:37 <PeakerWork> what's the constraint?
08:18:40 <PeakerWork> @src Complex
08:18:41 <lambdabot> data (RealFloat a) => Complex a = !a :+ !a
08:18:43 <PeakerWork> ah
08:19:20 * Eduard_Munteanu thinks of an idea to experiment with today: Church numbers using comonads
08:20:11 <Eduard_Munteanu> or monads, I'm not really sure. I could define succ as both return and duplicate.
08:26:11 <Cale> Eduard_Munteanu: whaaaat
08:26:53 <mauke> succ doesn't even have the right type
08:27:42 <Cale> succ :: ((a -> a) -> (a -> a)) -> ((a -> a) -> (a -> a))
08:27:54 <Botje> O_O
08:28:22 <mauke> succ :: a -> a, return :: a -> m a, therefore a = m a
08:28:56 <jmcarthur> church numbers as a monad would really have to be a list or something, and succ /= return
08:29:20 <Eduard_Munteanu> Cale, a successor of a Church number.
08:29:32 <jmcarthur> and using the list idea, you can't have a comonad
08:29:42 <Eduard_Munteanu> if there's another function defined named succ, I'm not referring to it.
08:29:57 <jmcarthur> Eduard_Munteanu: so what is the type of the succ you are talking about?
08:29:58 <Eduard_Munteanu> mauke, ^
08:29:58 <Cale> Eduard_Munteanu: yeah. A church numeral is a function which takes a function a -> a and composes it with itself a given number of times.
08:30:34 <jmcarthur> Eduard_Munteanu: it doesn't sound like what you want is possible, to me
08:30:34 <Cale> Eduard_Munteanu: and the successor function for Church numerals then takes such a numeral ((a -> a) -> (a -> a)) and gives another.
08:30:36 <Eduard_Munteanu> Cale, yes. And now I'm referring to the monad. To get the next number, simply return self.
08:30:46 <jmcarthur> huh?
08:30:47 <Cale> what?
08:30:55 <jmcarthur> Eduard_Munteanu: what is the *type*?
08:31:05 <Cale> I don't understand how there's a monad here...
08:31:09 <Eduard_Munteanu> Cale, suppose you have m a. Then you do return to this m a. You get m m a.
08:31:29 <Eduard_Munteanu> jmcarthur, MyType a, where a doesn't even matter.
08:31:32 <jmcarthur> but that's only a specific use of return. you have to generalize that
08:31:46 <jmcarthur> Eduard_Munteanu: no, what is the type of this succ function you are talking about?
08:31:47 <Cale> ah, okay, so a funky kind of Peano arithmetic on the level of types?
08:31:58 <Eduard_Munteanu> Cale, yes, type-level
08:32:06 <jmcarthur> Eduard_Munteanu: and how does MyType a look like a church numeral? is it a list?
08:32:07 <Eduard_Munteanu> jmcarthur, (m a
08:32:11 <Eduard_Munteanu> sorry
08:32:20 <jmcarthur> types!
08:32:20 <Cale> You don't mean Church numerals then :)
08:32:20 <Eduard_Munteanu> m a -> m (m a) for instance.
08:32:39 <Eduard_Munteanu> Cale, oh. I thought they were so abstract I could refer to them this way.
08:32:42 <jmcarthur> m a -> m (m a) is not every possible use of return, though
08:33:10 <jmcarthur> now i see where you were going with duplicate at least
08:33:11 <Eduard_Munteanu> jmcarthur, yeah, that's more like duplicate/cojoin
08:33:28 <Cale> jmcarthur: The idea is, I think, that you have (for any type a) a chain of types: a -> m a -> m (m a) -> ... with return going between them.
08:33:37 <jmcarthur> i see
08:33:44 <jmcarthur> and join is pred
08:33:49 <Eduard_Munteanu> jmcarthur, yes.
08:33:54 <Cale> well...
08:34:00 <Cale> various liftings of it are :)
08:34:09 <jmcarthur> yes
08:34:10 <Cale> Yeah, I guess join alone is :)
08:34:14 <Eduard_Munteanu> Am I too off-base with this?
08:34:17 <jmcarthur> there is more than one pred
08:34:22 <jmcarthur> and more than one succ
08:34:29 <Cale> also, 1 doesn't have a predecessor like that
08:34:39 <jmcarthur> i guess not
08:35:04 <Eduard_Munteanu> Yeah, perhaps duplicate and coreturn then?
08:35:15 <Eduard_Munteanu> Or just return and coreturn.
08:35:31 <jmcarthur> Eduard_Munteanu: i think it's an interesting exercise, but not very useful and possibly not much insight gained from it
08:35:32 <Eduard_Munteanu> (coreturn = extract in category-extras lingo)
08:35:39 <Eduard_Munteanu> jmcarthur, I see.
08:38:21 <Cale> I wonder if there are any monads for which return has a fixed point. Probably not in Hask.
08:38:39 <MissPiggy> it's a shame typeclasses don't work on values too
08:38:49 <Cale> Oh, of course, completion.
08:39:08 <elt0n> hey is there a way to acces the n'th element of a list?
08:39:10 <Eduard_Munteanu> > fix return
08:39:11 <lambdabot>   Occurs check: cannot construct the infinite type: a = m a
08:39:12 <MissPiggy> then you could write Group (0,(+),neg) => ...
08:39:15 <Eduard_Munteanu> Heh.
08:39:32 <Cale> elt0n: xs !! n, but don't overuse it
08:39:47 <Cale> elt0n: Needing to use !! is a good sign you're doing something wrong in general.
08:39:48 <elt0n> Cale, can you give me an example?
08:39:56 <Cale> > "hello" !! 1
08:39:57 <lambdabot>   'e'
08:40:06 <Eduard_Munteanu> > [1,2,30,4,5] !! 2
08:40:07 <lambdabot>   30
08:40:12 <Cale> xs !! n takes O(n) steps to compute
08:40:26 <elt0n> Cale, ahh ok i see
08:40:35 <Cale> and it usually results in something more inelegant than necessary
08:41:03 <elt0n> Cale, yeah but my skills are not that good ;)
08:41:06 <Cale> Usually you'd prefer to use operations that work on entire lists, if you can get away with it.
08:41:24 <Botje> > let { fibs = 1 : 1 : fib 3; fib x = fibs !! (x-1) + fibs !! (x-2) : fib (x+1) in take 10 fibs
08:41:25 <lambdabot>   <no location info>: parse error on input `in'
08:41:31 <Botje> > let { fibs = 1 : 1 : fib 3; fib x = fibs !! (x-1) + fibs !! (x-2) : fib (x+1) } in take 10 fibs
08:41:34 <lambdabot>   mueval-core: Time limit exceeded
08:41:37 <Botje> hah.
08:41:59 <Cale> You can add indices to a list using  zip [0..]  which is often a good way to avoid indexing.
08:42:00 <Botje> of course it should be fib 2. bah.
08:42:08 <Cale> > zip [0..] "hello"
08:42:09 <lambdabot>   [(0,'h'),(1,'e'),(2,'l'),(3,'l'),(4,'o')]
08:42:34 <Cale> After that, when you use map or filter, etc. you'll know which element it is that you're working with
08:44:04 <Eduard_Munteanu> :t liftM
08:44:05 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
08:44:21 <Cale> > concatMap (\(n,x) -> replicate n x) . zip [1..] $ "hello"
08:44:22 <lambdabot>   "heelllllllooooo"
08:44:54 <Cale> > filter (even . fst) . zip [0..] $ "hello"
08:44:55 <lambdabot>   [(0,'h'),(2,'l'),(4,'o')]
08:45:00 <Cale> > map snd . filter (even . fst) . zip [0..] $ "hello"
08:45:01 <lambdabot>   "hlo"
08:47:31 <Eduard_Munteanu> Brrr, defining a useful fmap seems difficult.
08:48:35 <Eduard_Munteanu> If I want to do addition for example, it should be something like (m a -> m1 a) -> m a -> m1 a
08:48:57 <Eduard_Munteanu> e.g. to be able to write fmap (+2) church
08:49:09 <Cale> Er...
08:49:17 <Cale> Shouldn't it consist of an operation on the type level?
08:49:34 <Eduard_Munteanu> Cale, yeah, I'm thinking fmap would apply return a number of times.
08:49:46 <Cale> that doesn't make sense :)
08:49:49 <Eduard_Munteanu> Heh.
08:50:29 <Cale> You'd presumably want  Add (m a) (m (m a)) ~= m (m (m a))
08:50:34 <Eduard_Munteanu> Addition should be m a -> m1 a -> m m1 a
08:50:46 <Cale> It shouldn't be a function at the value level
08:50:55 <Cale> hmm
08:50:56 <Eduard_Munteanu> Cale, yes. That's what I mean ^
08:51:41 <Eduard_Munteanu> I don't even care what happens to the underlying value.
08:52:06 <Cale> But since the monad is already applied, it's super-awkward to express any functions like this
08:52:14 <MissPiggy> what does this mean? Not in scope: `>>',  I've turned off implicit prelude so I think it's telling me all about the things nobody wants to know
08:52:31 <Botje> that's probably in Control.Monad
08:52:34 <Botje> @hoogle (>>)
08:52:34 <lambdabot> Prelude (>>) :: Monad m => m a -> m b -> m b
08:52:35 <lambdabot> Control.Monad (>>) :: Monad m => m a -> m b -> m b
08:52:35 <lambdabot> Control.Monad.Instances (>>) :: Monad m => m a -> m b -> m b
08:52:36 <Paczesiowa> is it normal for ghc to miss docs for ffi and rts and make haddock complain?
08:52:38 <kmc> it means the operator (>>) is not in scope
08:52:43 <kmc> it's a member of the typeclass Monad
08:52:50 <MissPiggy> oh right, ghci wants monad
08:52:51 <kmc> and is invoked implicitly when you use the ´doª notation
08:53:07 <Cale> MissPiggy: (>>) is an operator in the Prelude, it's always defined so as to be equivalent to x >> y = x >>= const y
08:53:19 <Eduard_Munteanu> It's >>= without binding...
08:53:27 <MissPiggy> why do they make it so difficult to define your own prelude :(
08:53:32 <Eduard_Munteanu> :t (>>)
08:53:32 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
08:53:39 <Eduard_Munteanu> :t (>>=)
08:53:40 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
08:53:42 <kmc> MissPiggy, it's not difficult, most of Prelude is imports from other modules
08:53:46 <kmc> you can put together your own imports
08:53:51 <kmc> e.g. Control.Monad
08:53:56 <Cale> It is difficult when you want to change how the Monad class looks.
08:54:04 <Eduard_Munteanu> IOW, it ignores the result of the previous action.
08:54:16 <Cale> ;)
08:54:16 <MissPiggy> I don't care about monad
08:54:42 <kmc> then don't use it
08:54:44 <Cale> MissPiggy: To define your own Prelude, you absolutely must define the Monad class, because do-notation translates in terms of it.
08:54:49 <kmc> but you're right that ghci might force you to
08:55:04 <Eduard_Munteanu> And even stuff like [] is a monad.
08:55:23 <kmc> Eduard_Munteanu, sure, but that's irrelevant if you're not using ´doª or any monad operators
08:55:27 <PeakerWork> Cale: I suppose even if you import Prelude hiding (>>=), (>>) and return, "do" and list comprehension syntax would still work...
08:55:34 <Eduard_Munteanu> kmc, oh.
08:55:59 <kmc> PeakerWork, yes, but ´import Prelude hiding...ª is different from -XNoImplicitPrelude
08:56:01 * MissPiggy wonders if I can redefine fail to be return ()
08:56:05 <Cale> PeakerWork: Well, lift comprehensions translate in terms of concatMap
08:56:08 <Cale> list*
08:56:12 <kmc> MissPiggy, it won't typecheck
08:56:13 <PeakerWork> oh
08:56:27 <Paczesiowa> why not?
08:56:28 <kmc> the latter actually changes the rules for which names desugarings bind to
08:56:32 <kmc> :t fail
08:56:33 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
08:56:34 <kmc> :t return ()
08:56:35 <lambdabot> forall (m :: * -> *). (Monad m) => m ()
08:57:34 <quicksilver> MissPiggy: what are you actually trying to do though?
08:57:41 <Eduard_Munteanu> Bah, I wish Monad defined join and others in the class, so you could define either join or >>=.
08:57:54 <quicksilver> if you don't care about Monad, you can not bother to use do notation
08:57:58 <MissPiggy> > do Just x <- Nothing ; return ()
08:57:59 <lambdabot>   Nothing
08:58:06 <quicksilver> you don't need the 'no-implicit-prelude' thing
08:58:17 <MissPiggy> ghci wants monad
08:58:21 <quicksilver> right
08:58:33 <quicksilver> why not just let it have it?
08:58:39 <MissPiggy> I am
08:59:06 <MissPiggy> I had to do module PiggyPrelude where (..., Monad((>>=), (>>), return, fail)) where  import Control.Monad
08:59:45 <Cale> What are the goals of your new replacement Prelude? :)
08:59:49 <Paczesiowa> MissPiggy: you only need new Monad class (without fail)?
09:00:14 <Cale> Paczesiowa: fail is unfortunately required, because do-notation translates in terms of it :(
09:00:45 <Paczesiowa> Cale: so what? it doesn't have to typecheck
09:00:48 <MissPiggy> Cale it's so I can do this http://www.pasteit4me.com/100115
09:01:00 <temoto> @hoogle unsafePerformIO
09:01:00 <lambdabot> Foreign unsafePerformIO :: IO a -> a
09:01:00 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
09:01:46 <temoto> I'm experimenting with Parsec for the first time.
09:01:57 <quicksilver> MissPiggy: you don't need to disable implicit prelude for that
09:02:03 <quicksilver> or even skip the prelude
09:02:03 <Cale> MissPiggy: Ah, it's also possible to  import Prelude hiding ((+), (*))
09:02:09 <quicksilver> you just need to hide (+) and (*)
09:02:16 <quicksilver> and any other methods you're doing to redefine.
09:02:16 <temoto> Did i made some common error that parseTest program ""  produces stack overflow?
09:02:29 <quicksilver> if you want to define your own fromIntegral to make literals work
09:02:34 <kmc> temoto, infinite recursion in one of your parsers probably
09:02:36 <quicksilver> *then* you will need to disable implicit prelude.
09:02:37 <Cale> temoto: Maybe an infinite loop in your parser?
09:02:46 <kmc> expr = expr <|> (string "foo")
09:02:56 <Cale> temoto: I'm betting that you have some parser which is left recursive like kmc shows.
09:03:10 <Paczesiowa> :t let fromInteger = Prelude.fromInteger :: Integer -> Int in 1
09:03:11 <lambdabot> forall t. (Num t) => t
09:03:22 <Cale> The usual way out of that problem is to refactor the parser in terms of chainl
09:03:44 <temoto> i have  parseExpr = braces parseExpr <|> other parsers...
09:03:46 <temoto> does it count?
09:03:53 <kmc> that should be okay
09:03:59 <temoto> i thought so too
09:04:01 <kmc> because it will have to see a brace before it self-invokes
09:04:02 <MissPiggy> is this okay module PiggyPrelude where ( Eq(..), Show(..), fromInteger, Monad((>>=), (>>), return, fail))
09:04:17 <MissPiggy> and I'll add more if ghc gets shirty with me again
09:04:37 <Paczesiowa> MissPiggy: I think that ghci always imports Prelude
09:04:46 <MissPiggy> not if you do ghci -XNoImplicitPrelude
09:04:55 <jmcarthur> not if you have a Prelude module locally, either
09:05:16 <MissPiggy> well the documentation said I'm now allowed to call mine Prelude so I just didn't
09:05:24 <MissPiggy> not*
09:05:28 <jmcarthur> yeah you really shouldn't
09:05:37 <Paczesiowa> MissPiggy: don't konw about custom Prelude module, but NoImplicitPrelude still imports Prelude, but you can redefine builtins
09:05:40 <jmcarthur> ghci *will* complain a lot if it even works if you have a local prelude
09:05:44 <temoto> what about program = do { whiteSpace; e <- parseExpr; eof; return e }     <- is whiteSpace recursive here? is it fine anyway?
09:05:59 <MissPiggy> Paczesiowa: what does it mean to still import prelude?
09:06:21 <Paczesiowa> MissPiggy: ghci -XNoImplicitPrelude, and ask :t (>>=)
09:06:32 <temoto> also, i wonder if do { foo; e <- func; bar; return e } is equal to do { foo; bar; return $ func }
09:06:37 <Cale> temoto: whiteSpace might be able to match the empty string
09:06:55 <Paczesiowa> temoto: it's not
09:06:56 <Cale> temoto: if parseExpr uses program at the top level, that might lead to a loop...
09:06:59 <temoto> I used whiteSpace from haskellStyle.
09:07:23 <MissPiggy> Paczesiowa: what does that prove? :P
09:07:42 <temoto> i guess these disperse questions only confuse things
09:07:53 <jmcarthur> @undo do { foo; e <- func; bar; return e }
09:07:53 <lambdabot> foo >> func >>= \ e -> bar >> return e
09:08:01 <MissPiggy> Paczesiowa: if we ask the type of >>= inside:   Prelude>    then it still has it but if you do it inside your own module, it does not
09:08:08 <jmcarthur> @pl foo >> func >>= (\e -> bar >> return e)
09:08:08 <lambdabot> foo >> func >>= (bar >>) . return
09:09:00 <temoto> here's the whole Parser module
09:09:01 <temoto> http://codepad.org/PLQKB5WK
09:09:23 <temoto> if anyone could point why it leads to recursion i would be so glad
09:09:47 <Cale> temoto: parseExpr -> parseIf -> parseExpr
09:09:54 <temoto> AH!
09:10:24 <Cale> Also,  parseExpr -> parseInfix -> parseExpr
09:10:30 <temoto> Cale: thank you! I knew this infix if is no good.
09:10:55 <temoto> oh well, that should be fine somewhow
09:11:11 <temoto> Maybe i should introduce another parser?
09:11:28 <Paczesiowa> MissPiggy: but what's the problem? I thought that you have problems inside ghci
09:11:46 <MissPiggy> no I have it all working now
09:11:55 <MissPiggy> thanks to all the suggestions and such
09:12:20 <Eduard_Munteanu> Is there any identity function a -> b ?
09:12:27 <jmcarthur> identity?
09:12:28 <ivanm> Eduard_Munteanu: that doesn't make sense
09:12:29 <Cale> Eduard_Munteanu: How could that be?
09:12:33 <Paczesiowa> no!
09:12:36 <burp> yeah, doesn't make sense
09:12:39 <Saizan> unsafeCoerce!
09:12:46 <jmcarthur> Saizan: sssshhhhhh
09:12:51 <ivanm> Eduard_Munteanu: id can be used as an argument for a function which _requires_ a function of type a -> b
09:12:51 <Paczesiowa> Saizan: how dare you?!
09:12:56 <Eduard_Munteanu> Heh, I want to define succ for both a and Church a
09:12:58 <ivanm> @slap Saizan
09:12:58 * lambdabot places her fist firmly on Saizan's jaw
09:13:03 <ivanm> @hoogle succ
09:13:03 <lambdabot> Prelude succ :: Enum a => a -> a
09:13:03 <lambdabot> Data.Graph.Inductive.Internal.FiniteMap succFM :: Ord a => FiniteMap a b -> a -> Maybe (a, b)
09:13:03 <lambdabot> System.Exit ExitSuccess :: ExitCode
09:13:06 <Eduard_Munteanu> And I need something b -> Church a
09:13:08 <ivanm> Eduard_Munteanu: ^^ it's in Enum
09:13:11 <ivanm> @src Enum
09:13:12 <lambdabot> class  Enum a   where
09:13:12 <lambdabot>     succ                     :: a -> a
09:13:12 <lambdabot>     pred                     :: a -> a
09:13:12 <lambdabot>     toEnum                   :: Int -> a
09:13:12 <lambdabot>     fromEnum                 :: a -> Int
09:13:13 <Cale> temoto: Well... if you want to maintain the present syntax, every expr is possibly followed by an "if"
09:13:14 <lambdabot> [3 @more lines]
09:13:19 <Paczesiowa> Eduard_Munteanu: introduce a type class
09:13:24 <jmcarthur> Eduard_Munteanu: define a type class or something
09:13:35 <Eduard_Munteanu> ivanm, no, I want to introduce a succ that works at type level.
09:13:46 <Eduard_Munteanu> Paczesiowa, jmcarthur, thanks.
09:13:50 <ivanm> wtf?
09:13:56 <Paczesiowa> data Succ a = Succ a
09:14:10 <Eduard_Munteanu> Paczesiowa, that's how I do it.
09:14:23 <Paczesiowa> Eduard_Munteanu: so what's the problem?
09:14:28 <jmcarthur> ivanm: yeah, Eduard_Munteanu is up to something that none of us fully understand or something
09:14:29 <temoto> Cale: i can say goodbyte to infix if. But i don't understand how to parse 'expr `op` expr `op` expr' then.
09:14:29 <Eduard_Munteanu> ivanm, suppose you wish to increment Church a. The result is Church (Church a)
09:14:36 <Paczesiowa> Eduard_Munteanu: and what are you trying to achieve?
09:14:43 <ivanm> jmcarthur: heh
09:14:55 <jmcarthur> Eduard_Munteanu: how do you increment a?
09:14:55 <quicksilver> temoto: there combinators for that purpose
09:14:55 <ivanm> Eduard_Munteanu: what's "Church a" ?
09:15:08 <Eduard_Munteanu> ivanm, data Church a = Church a
09:15:12 <ivanm> data ChurchNumeral a = Empty a | Succ (ChurchNumeral a)
09:15:13 <Cale> temoto: chainl does what you want. You can build a list of applications (and then reassociate them however you want)
09:15:17 <quicksilver> temoto: (expr `sepBy` op), if I remember correctly
09:15:25 <ivanm> Eduard_Munteanu: what's the point of that?
09:15:25 <Eduard_Munteanu> ivanm, the actual value is the number of times it's contained in itself.
09:15:35 <Cale> http://hackage.haskell.org/packages/archive/parsec/3.0.1/doc/html/Text-Parsec-Combinator.html#v%3Achainl
09:15:35 <quicksilver> temoto: or you can use chainil, but sepBy and its friends are the common case.
09:15:41 <Eduard_Munteanu> ivanm, expermenting with monads and Church numerals in that context
09:15:50 <Paczesiowa> Eduard_Munteanu: isn't that Peano, not Church?
09:15:51 <Eduard_Munteanu> jmcarthur, incrementing is simply return
09:15:59 <Cale> (or you can just use chainr as appropriate -- if you know the associativity beforehand)
09:15:59 <temoto> sepBy and chainl, thanks.
09:16:12 <jmcarthur> Eduard_Munteanu: you could use a data family to say things like:    data Succ (Church a) = <something> ; data Succ SomethingElse = <something else> ; etc.
09:16:18 <Cale> Oh, yes, there's sepBy as well.
09:16:22 <Eduard_Munteanu> Paczesiowa, I don't know.
09:16:43 <Paczesiowa> jmcarthur: he would probably want things to overlap
09:16:50 <jmcarthur> Eduard_Munteanu: i still think your exercise is not well defined, personally
09:16:53 <Eduard_Munteanu> jmcarthur, nah, I was looking for it to be the same type. And succ :: b -> Church a so that succ takes both a and Church a
09:17:19 <temoto> Is   "sepBy parseExpr operator"   makes sense?
09:17:20 <jmcarthur> Eduard_Munteanu: don't you mean succ :: a -> Church a ?
09:17:47 <Eduard_Munteanu> jmcarthur, hm, would that take 5 into Church 5 as well as Church 5 into Church (Church 5)?
09:17:55 <idnar> Church 5 isn't a type
09:18:01 <Eduard_Munteanu> idnar, it's a value.
09:18:10 <jmcarthur> Eduard_Munteanu: assuing by 5 you mean a type-level peano numeral or something
09:18:15 <EnglishGent> hi - can someone help me debug some code from a Monad reader article please? it's on type-level programming (which I am really trying to understand) - only it doesnt work as the article says it does
09:18:18 <EnglishGent> and I'm not sure why
09:18:21 <Eduard_Munteanu> jmcarthur, I don't care about the 5 really.
09:18:22 <idnar> Eduard_Munteanu: well, sure, I don't see why not
09:18:28 <idnar> Eduard_Munteanu: that's just the Church constructor
09:18:32 <idnar> Church :: a -> Church a
09:18:34 <Eduard_Munteanu> jmcarthur, I only care about the number of times the base value is contained into Church
09:18:44 <idnar> so for a = Church b, you get Church b -> Church (Church b)
09:18:45 <Eduard_Munteanu> idnar, oh, right.
09:18:50 <Eduard_Munteanu> Thanks.
09:19:18 <Eduard_Munteanu> So my succ = return
09:19:36 <idnar> but yeah, I think that's Peano not Church
09:20:58 <Eduard_Munteanu> idnar, I don't see how. Here I translate the Church numbers \f\x -> f . f ... x into type level equivalents. They seem pretty isomorphic to me.
09:21:20 <Eduard_Munteanu> In fact my f is the monad itself.
09:21:36 <quicksilver> Cale: can you think of a clever way of writing (\foo bar -> (.....)) <$> mkFoo <*> mkBar?
09:21:38 <Eduard_Munteanu> It's quite natural to use return for that.
09:21:40 <idnar> Eduard_Munteanu: the point of Church encoding is the lambdas / composition
09:21:43 <EnglishGent> hi quicksilver :)
09:21:59 <quicksilver> Cale: the annoyance here is the visual distance between the 'mkFoo' and the 'foo' so you have to count parameters to work out what comes from where.
09:22:11 <idnar> Eduard_Munteanu: you encode every data type as a catamorphism
09:22:16 <Eduard_Munteanu> idnar, oh. I'm thinking in terms of compositions of functors.
09:22:17 <quicksilver> I find this pattern quite often when using applicatives-which-are-not-monads.
09:22:29 <idnar> Eduard_Munteanu: so church numerals are the catamorphism on peano numerals
09:22:35 <idnar> Eduard_Munteanu: at least, that's my understanding, I'm just a dabbler
09:22:44 <Cale> Ah, I was about to suggest just using do-notation :P
09:22:46 <Eduard_Munteanu> idnar, could you explain? I think I need catamorphisms to translate from type level to value level.
09:22:58 <quicksilver> Cale: yeah, I'm sort of asking for do-notation for applicatives.
09:23:11 <quicksilver> Cale: but I'm wondering if thre is a simple source level transformation I'm missing to make it more obvious.
09:23:26 <idnar> Eduard_Munteanu: well, in Haskell terms
09:23:36 <MissPiggy> does anyone have some advice about my numbers before I take it too far?
09:23:54 <MissPiggy> Add and Mul in <http://www.pasteit4me.com/100115>
09:24:22 <idnar> Eduard_Munteanu: if you have some algebraic data type, you can implement a catamorphism with a function that takes an n-ary function or value for each constructor
09:24:23 <Cale> MissPiggy: I would call e'add "zero", and e'mul "one"
09:24:25 <quicksilver> Cale: (I appreciate the toy exaple is a poor one, but imagine that mkFoo is a slightly large subexpression)
09:24:32 <MissPiggy> okay I will do that
09:24:34 <idnar> Eduard_Munteanu: and then replaces each constructor with the corresponding function / value
09:24:48 <ivanm> Cale: so, can you think of any way of adding map-ping support to the Graph classes?
09:24:49 <Cale> quicksilver: hmm, maybe use let?
09:25:11 <Eduard_Munteanu> idnar, yes, that function would be succ on integers, right? (When converting types to values)
09:25:12 <MissPiggy> any more :)
09:25:33 <Cale> ivanm: I'm not sure I fully comprehend why it's hard?
09:25:45 <idnar> Eduard_Munteanu: I don't think succ is a catamorphism
09:26:04 <Eduard_Munteanu> idnar, no, but it's the function applied by the catamorphism.
09:26:12 <idnar> Eduard_Munteanu: if you use Peano encoding for numerals, you get something like data Natural = Zero | Succ Natural
09:26:17 <EnglishGent> that depends on what your objects are surely? succ is an isomorphism over integers (I think!)
09:26:48 <idnar> Eduard_Munteanu: so the catamorphism function needs to take two parameters; a value to replace Zero with, and a function to replace Succ with
09:26:48 <ivanm> Cale: I couldn't work out a way of having a class that specified that (g n e) is an instance of FiniteGraph with VLabel (g n e) ~ n and ALabel (g n e) ~ e
09:26:51 <Eduard_Munteanu> convertToValue n (Church a) = convertToValue (n + 1) a
09:26:55 <quicksilver> Cale: Hmm. (let foo = (....); bar = (....); in (\foo bar -> .....) <$> foo <*> bar) and let the deliberate re-use of names act as the mnemonic hint...
09:27:04 <MissPiggy> what's succ^-1 zero? its only an isomorphism between N and N\{zero}
09:27:14 <idnar> Eduard_Munteanu: which gives you fold :: a -> (a -> a) -> Natural -> a
09:27:24 <MissPiggy> bijection**
09:27:36 <Eduard_Munteanu> ivanm, nice, I wonder if catamorphism can replace the fmap.
09:27:48 <Eduard_Munteanu> Um... not really.
09:27:50 <idnar> fold a _ Zero = a
09:27:51 <ivanm> Eduard_Munteanu: hmmm?
09:27:59 <quicksilver> The Egyptians worshipped catamorphisms as gods.
09:28:09 <Eduard_Munteanu> ivanm, nah, my mistake.
09:28:19 <idnar> fold a f (Succ n) = f (fold a f n)
09:28:21 <idnar> or something like that
09:28:25 <MissPiggy> lol
09:28:33 <Eduard_Munteanu> Yeah.
09:28:42 <EnglishGent> has anyone here managed read the article on 'type level instant insanity' in the Monad reader?
09:28:44 <Cale> class (FiniteGraph (g n e), VLabel (g n e) ~ n, ALabel (g n e) ~ e) => ...
09:28:50 <idnar> Eduard_Munteanu: catamorphism is more powerful than fmap
09:28:50 <Cale> ^^ ivanm: this doesn't work?
09:29:24 <idnar> Eduard_Munteanu: if you want to implement fmap, you just replace every constructor with the same constructor, except with some function applied to the value
09:29:26 <ivanm> Cale: not with 6.10.4; I dont' have 6.12 to be able to check
09:29:35 <ivanm> since 6.10 doesn't allow ~ constraints for type classes :s
09:29:43 <Cale> ah, okay
09:29:47 <Cale> (weird)
09:29:49 <Eduard_Munteanu> idnar, hm, I'll give it a try, thanks.
09:29:57 <idnar> Eduard_Munteanu: for example, for lists: map f = foldr ((:) . f) []
09:30:02 <ivanm> Cale: they didn't know how to do it if I understand the error command ;-)
09:30:19 <EnglishGent> is fold a catamorphism? (serious question)
09:30:24 <idnar> Eduard_Munteanu: for Maybe, you can do: fmap f = maybe Nothing (Just . f)
09:30:24 <Paczesiowa> EnglishGent: just start reading Oleg, he has useful examples, not puzzles for kids
09:30:28 <Eduard_Munteanu> idnar, is fmap in any way a hylomorphism?
09:30:52 <Eduard_Munteanu> Cata then ana.
09:30:52 <idnar> EnglishGent: foldr is, I believe
09:30:53 <quicksilver> Paczesiowa: the rubik's cube example is quite instructive, I would say
09:31:24 <idnar> Eduard_Munteanu: hylomorphism is ana then cata
09:31:28 <EnglishGent> Paczesiowa - got a recommended link?
09:31:33 <Paczesiowa> quicksilver: I hate puzzles
09:31:35 <idnar> Eduard_Munteanu: and I don't think so
09:31:39 <Paczesiowa> EnglishGent: HList paper
09:31:39 <Eduard_Munteanu> idnar, hm, a `then` b = b . a
09:31:42 <temoto> sepBy worked flawlessly!
09:31:44 <Eduard_Munteanu> for me :)
09:31:59 <EnglishGent> Paczesiowa - it's that (HList paper) that I'm trying to work my way up to understanding! :)
09:32:01 <temoto> parseExprs = many parseExpr
09:32:03 <temoto>     <|> (parseExpr `sepBy` (operator <|> parseInfixFun))
09:32:03 <Eduard_Munteanu> So yes, ana . cata, right?
09:32:06 <temoto> This is totally magic!
09:32:23 * EnglishGent has the HList library working but wants to *grok* it - not just use it
09:32:24 <idnar> Eduard_Munteanu: no, cata . ana
09:32:27 <Paczesiowa> EnglishGent: than ask your questions:)
09:32:29 <idnar> Eduard_Munteanu: unless I'm confused
09:32:35 <idnar> Eduard_Munteanu: ana . cata is a metamorphism
09:32:37 <Eduard_Munteanu> idnar, oh.
09:32:37 <quicksilver> temoto: AIUI that shouldn't work
09:32:55 <quicksilver> temoto: you have 'many parseExpr' as the first choice
09:32:58 <quicksilver> so if your input stream is
09:32:59 <temoto> quicksilver: it works fine for empty input string.
09:33:02 <quicksilver> <expr> <op>
09:33:10 <quicksilver> it will consume the first expr with manyparseexpr
09:33:11 <Eduard_Munteanu> idnar, oh, so I could think of fmap as a metamorphism? Looks very much like it, because of the fold.
09:33:12 <quicksilver> and then stop
09:33:16 <quicksilver> so you'll get just one expr
09:33:28 <temoto> :)
09:33:31 <quicksilver> 2nd alternative will never get tried
09:33:44 <temoto> For expr op it yields irrefutable pattern :)
09:33:50 <idnar> Eduard_Munteanu: I don't think so; eg. those definitions I gave above just have a catamorphism, no anamorphism
09:34:02 <temoto> quicksilver: should i exchange them?
09:34:03 <Eduard_Munteanu> idnar, isn't the anamorphism just the (:) part? :)
09:34:12 <Eduard_Munteanu> in the list example.
09:34:19 <quicksilver> temoto: similar problem, really
09:34:22 <idnar> Eduard_Munteanu: well, no, that's part of the catamorphism
09:34:26 <Eduard_Munteanu> Oh.
09:34:40 <quicksilver> temoto: <expr> <expr> will get parsed successfully as a degenerate example of the op case
09:34:47 <quicksilver> temoto: that is, one expression and no op.
09:35:01 <Eduard_Munteanu> idnar, thanks.
09:35:21 <quicksilver> temoto: I think you need to (1) swop the cases (2) use sepBy1 to indicate there must be at least one op (3) wrap the entire sepBy case in 'try' to make it backtrack if it doesn't find an op.
09:35:31 <quicksilver> temoto: you may wish Cale to sanity check my suggestion :)
09:35:42 <jmcarthur> swop the cases!
09:35:52 <Cale> Eh, it's not like I write Parsec parsers all day either :)
09:35:59 <jfredett> quicksilver: I read that as "You may wish Cale to sanctify my suggestion"
09:35:59 <lambdabot> jfredett: You have 1 new message. '/msg lambdabot @messages' to read it.
09:36:04 <ivanm> Cale: you don't? :o
09:36:07 <jfredett> which is infinitely more hilarious, i think.
09:36:34 <idnar> jfredett: haha
09:37:01 <quicksilver> jfredett: yes, typo. That's what I meant. Sorry.
09:37:15 <MissPiggy> grumble I can't program in haskell like I wanted to do
09:37:27 <EnglishGent> what did you want to do MissPiggy?
09:37:37 <Paczesiowa> ivanm: what do you mean by "~ for classes"
09:37:39 <MissPiggy> data Vector a n where Nil :: Vector a Zero ; (:::) :: a -> Vector a n -> Vector a (Succ n)
09:37:42 <quicksilver> If you can't program in the way you love, then love the way you program.
09:37:45 * jfredett makes the sign of the Haskell, "Hail Cale, full of Functor."
09:37:57 <ivanm> Paczesiowa: ~ puts a constraint on associated types
09:37:59 <MissPiggy> but now you cannot define   zero :: Vector Integer n
09:38:11 <jmcarthur> MissPiggy: but why would you?
09:38:18 <MissPiggy> it is not possible to synthesize n from the type, you'd have to use classes
09:38:21 <Paczesiowa> ivanm: no, ~ puts a constraint on two types.
09:38:27 <ivanm> right
09:38:39 <MissPiggy> synthesize /a length n vector/
09:38:42 <ivanm> Paczesiowa: but 6.10.* doesn't allow you to use it in the constraint for a type class
09:39:19 <jmcarthur> ivanm: does 6.12?
09:39:23 <jmcarthur> i've been bitten by that before
09:39:23 <MissPiggy> this is nice but I don't think I can even do it with this http://personal.cis.strath.ac.uk/~conor/pub/she/faking.html
09:39:28 <EnglishGent> you could use a multiparameter type class & a functional dependency to solve that I think
09:39:30 <ivanm> jmcarthur: don't know; I don't have 6.12 installed ;-)
09:39:46 <Paczesiowa> ivanm: don't you mean 6.8?
09:39:54 <ivanm> Cale: oh, and apparently "class (Graph (g n e)) => MappableGraph (g n e) where" isn't valid...
09:39:55 <jmcarthur> Paczesiowa: 6.10 doesn't do it either
09:39:58 <ivanm> Paczesiowa: no
09:40:11 <MissPiggy> gosh that picture at the bottom makes me laugh
09:40:47 <Paczesiowa> ivanm: do you want to put that in the constraint of class instance?
09:40:54 <ivanm> Paczesiowa: yes
09:41:03 <temoto> quicksilver: when i said irrefutable pattern it returned parse error as Left which i tried to match to Right. But now i applied your changes and it returns parse errors to all erroneous cases. Thanks.
09:41:20 <jmcarthur> MissPiggy: what is an example of a length n vector that you would want to define?
09:41:40 <Paczesiowa> ivanm: instance parent ~ AnyException => Parent child parent where
09:41:44 <Paczesiowa> ivanm: works under 6.10.4
09:42:13 <Paczesiowa> ivanm: and I mean works, not only is accepted
09:42:24 <ivanm> Paczesiowa: I want: "class (Graph (g n e), VLabel (g n e) ~ n, ALabel (g n e) ~ e) => MappableGraph (g n e) where"
09:42:35 <MissPiggy> jmcarthur, scribbling leads me to believe that newtype Polynomial v = Polynomial (Complex Rational :*: Vector Integer v) admits a nice normal form for polynomials
09:42:41 <ivanm> Paczesiowa: the thing is it doesn't work with _associated types_ for type class constraints
09:42:53 <ivanm> and I'm talking about the class definition, not just the instance definitions
09:43:11 <MissPiggy> sorry, square brackets, Polynomial [Complex Rational :*: Vector Integer v]
09:43:13 <Paczesiowa> ivanm: oh. I don't use associated anything
09:43:20 <ivanm> heh
09:43:23 <jmcarthur> MissPiggy: and that is not doable... why?
09:43:31 <jmcarthur> MissPiggy: besides Complex Rational, i mean
09:43:41 <Paczesiowa> ivanm: why would I? there's no overlapping
09:43:43 <MissPiggy> I've done Complex Rational
09:43:51 <ivanm> Paczesiowa: hmmm?
09:43:58 <ivanm> Paczesiowa: my point is, _I_ need it...
09:44:05 <ivanm> and then you keep saying that it's possible when I know it isn't
09:44:06 <ivanm> ;-)
09:44:06 <jmcarthur> MissPiggy: actually, what is :*: here?
09:44:17 <MissPiggy> data a :*: b = a :&: b
09:44:33 <Paczesiowa> ivanm: I've misunderstood yout, I've missed negation
09:44:36 <Paczesiowa> ivanm: why not stick to fundeps?
09:44:39 <jmcarthur> :&: ?
09:44:53 <ivanm> Paczesiowa: because I started defining it with Cale, and he suggested ATs
09:44:54 <jmcarthur> oh, the constructor
09:45:00 <jmcarthur> i'm a dummy today
09:45:11 <ivanm> since I use in one class 3 different associated types ;-)
09:45:17 <Paczesiowa> ivanm: oh. can't argue with Cale:)
09:45:22 <ivanm> heh
09:45:42 <ivanm> @remember Paczesiowa oh. can't argue with Cale:)
09:45:42 <lambdabot> Nice!
09:45:45 <temoto> Also, i think that 'many parseExpr' is not correct in first place. There must be many bindings of names to expressions, not the expressions.
09:45:58 <jmcarthur> MissPiggy: are you prevented from defining that Polynoial newtype somehow?
09:46:05 <jmcarthur> *Polynomial
09:46:06 <MissPiggy> no
09:46:12 <Paczesiowa> ivanm: but I think you could do all that with fundeps and -XOleg
09:46:14 <MissPiggy> I defined it, but I can't program with it
09:46:29 <jmcarthur> MissPiggy: for example?
09:46:36 <ivanm> Paczesiowa: there's an extension called Oleg? :o
09:46:37 <ivanm> ;-)
09:46:57 <Cale> ivanm: Well, it seemed like a sensible thing at the time
09:47:00 <ivanm> right
09:47:01 <Paczesiowa> ivanm: it's just a macro for other extension, and being awesome
09:47:02 <lysgaard> Anyone have a good datastructure for math expressions?
09:47:03 <MissPiggy> zero :: Polynomial n, it can't just reify the type and start recursing on it
09:47:05 <ivanm> and it still does
09:47:18 <ivanm> (except that type sigs are more verbose for ATs... :s)
09:47:24 <MissPiggy> so I need to stuff a witness into the newtype
09:47:25 <ivanm> Paczesiowa: heh
09:48:37 <jmcarthur> MissPiggy: i don't understand how you could define a top-level vector of polymorphic length anyway, myself
09:48:50 <MissPiggy> (forget that witnessing doesn't make any difference)
09:49:09 <MissPiggy> jmcarthur did you miss my definition I pasted a moment ago?
09:49:18 <jmcarthur> the GADT?
09:50:18 <MissPiggy> this is frustrating, it all looked great on paper
09:50:53 <jmcarthur> MissPiggy: oh i think i see now. you are wanting to define a vector full of zeros?
09:51:28 <jmcarthur> MissPiggy: i was reading it as a vector of length zero, but with the type being polymorphic on the length. that's what didn't make sense to me
09:52:28 <MissPiggy> I was thinking about  3*x^8*y^7*z^6 could be represented as 3 :&: (8 ::: 7 ::: 6 ::: Nil)
09:53:29 <jmcarthur> it looks to me like you need a pi type or something
09:53:31 <lysgaard> MissPiggy: Hmm? What is that notation?
09:54:39 <jmcarthur> lysgaard: data Vector a n where Nil :: Vector a Zero ; (:::) :: a -> Vector a n -> Vector a (Succ n) ; newtype Polynomial v = Polynomial (Complex Rational :*: Vector Integer v) ; data a :*: b = a :&: b
09:55:33 <lysgaard> jmcarthur: Ah, so one can't express anything else than polynomials with it?
09:56:10 <jmcarthur> lysgaard: i've not thought about the full implications of MissPiggy's data type. i'm just focusing on what feature MissPiggy is lacking in haskell
09:57:23 <jmcarthur> MissPiggy: yeah i think a type class of some sort is your best bet
09:57:37 <maltem> @tell Peaker I put some MList additions in a github fork, in case you're interested
09:57:37 <lambdabot> Consider it noted.
09:57:42 * Cale likes using monoid rings to get polynomials in multiple indeterminates
09:58:00 <mercury^> What's a monoid ring?
09:58:22 <mercury^> Something like a group ring but with a monoid?
09:58:46 <ivanm> yeah, IIRC
10:01:25 <opqdonut> can i give ghc the name of the Main module?
10:01:41 <opqdonut> I mean an alternate name, like MyProgram
10:02:07 <kmc_> yes
10:02:11 <opqdonut> how?
10:02:19 <opqdonut> didn't see an option for that on the man page
10:02:27 <kmc_> thought it was --main-is or such
10:03:08 <ivanm> kmc_: that's the main function IIRC
10:03:14 <MissPiggy> Cale, does that work as a normal form too?
10:03:38 <opqdonut> relatedly, what would be the best way to run something typed IO a and get me a profile
10:03:43 <Cale> MissPiggy: If you use the right monoid.
10:03:47 <opqdonut> does ghci work with profiling?
10:03:57 <kmc_> i think not
10:04:02 <kmc_> build a program
10:04:29 <Cale> MissPiggy: Polynomial rings in multiple indeterminates are monoid rings over the monoid N^k
10:04:49 <maltem> ivanm, I think you can qualify the name of the main function there
10:05:36 <MissPiggy> Cale, do you know if there's something I can read - to get to grips with that
10:07:19 <opqdonut> kmc_: thus me wanting alternate Main modules :)
10:07:42 <aconbere> this is the description of a command to an ascii protocol I'm working with. SORT key [BY pattern] [LIMIT start count] [GET pattern] [ASC|DESC] [ALPHA] [STORE dstkey]
10:07:48 <aconbere> in an imperative language
10:07:55 <aconbere> I would use optional args
10:08:02 <aconbere> and mutate a list or string
10:08:04 <aconbere> to build that up
10:08:06 <ivanm> maltem: oh
10:08:22 <aconbere> any suggestions on how to best approach that in haskell?
10:08:32 <jmcarthur> optional args have nothing to do with imperative or declarative, btw
10:08:48 <jmcarthur> aconbere: "best" is subjective
10:09:09 <aconbere> jmcarthur: clearly, but they aren't supported in haskell. The bit I was talking about was mutation.
10:09:18 <aconbere> jmcarthur: yep!
10:09:42 <uorygl> Haskell has Maybe, which is a lot like an optional argument.
10:09:45 <Cale> MissPiggy: Well, if R is any ring, and M is any monoid, then R[M] is the ring consisting of finite sums of elements of M. We can choose to write an element (a,b,c) of N^3, say, as x^a y^b z^c. Multiplying elements in this monoid is just elementwise addition of triples of natural numbers.
10:09:47 <aconbere> jmcarthur: I guess I'm looking for ideas from people who might have tackled similar problems in haskell, and liked the solution.
10:09:50 <Eduard_Munteanu> Is there any way I can relax Haskell's type system so that m a = m (m a)? For example I want to build a list [Church a, Church (Church a), ...]
10:10:06 <maltem> aconbere, a parsing library like parsec should make this really easy
10:10:12 <Eduard_Munteanu> And to avoid "occurs check" stuff
10:10:21 <jmcarthur> aconbere: a straightforward way would be: sort :: Key -> Maybe Pattern -> Maybe (Start Count) -> Maybe Pattern -> Maybe Order -> Maybe Alpha -> Maybe DSTKey -> WhateverItShouldReturn
10:10:25 <Eduard_Munteanu> Like "can't build infinite type a = Church a"
10:10:28 <jmcarthur> but that is ugly to me ;)
10:10:35 <mercury^> Eduard_Munteanu: is there no other solution to that?
10:10:35 <aconbere> jmcarthur: yeah, that's what I have right now
10:10:45 <Eduard_Munteanu> mercury^, hm, I don't see it.
10:10:45 <mercury^> Probably having "Church" include a field for the depth?
10:10:49 <xerox> Eduard_Munteanu add a case in data Church a = ... | Mu (Church a) ?
10:10:49 <zachk1> Eduard_Munteanu: is there a difference between church numerals and peano numerals?
10:10:58 <jmcarthur> aconbere: another way would be to have a record type for all these parameters
10:10:59 <Eduard_Munteanu> mercury^, that defies the point of my (futile) exercise.
10:11:04 <temoto> What is this an alias for   "do { s <- foo; return s }" ?
10:11:16 <quicksilver> temoto: excellent. Do you understand why?
10:11:16 <aconbere> jmcarthur: That was my second solution, with a function that constructs a good default
10:11:16 <Eduard_Munteanu> zachk1, I'm really unsure.
10:11:22 <Cale> MissPiggy: Or, more formally, the elements of R[M] are functions M -> R with finite support. (That is, only finitely many elements of the monoid are not sent to 0)
10:11:24 <quicksilver> temoto: that is simply "foo"
10:11:26 <xerox> temoto 'foo'
10:11:46 <Eduard_Munteanu> xerox, that still defies the point of what I want to do. :)
10:11:54 <uorygl> Eduard_Munteanu: well, you could make a data declaration that looks something like data Foo = F a | B (Church Foo)
10:11:54 <temoto> hm
10:11:56 <temoto> Thanks.
10:11:59 <mercury^> Eduard_Munteanu: data Church a = Base a | Ind (Church a)
10:12:12 <Cale> MissPiggy: addition is pointwise, and multiplication is  (f * g)(m) = sum over u*v = m of f(u)*g(v)
10:12:31 <Eduard_Munteanu> mercury^, hm, that could work.
10:12:47 <Eduard_Munteanu> It's similar to what uorygl says.
10:13:00 <jmcarthur> aconbere: i don't know what kind of operations you need or what data structures you are working with, so i can't really recommend a particular implementation. also, lacking what uses this is for, i can't really recommend a particular interface
10:13:09 <Eduard_Munteanu> I wish I could construct infinite types.
10:13:10 <jmcarthur> aconbere: so... i guess i can't really help you ;)
10:13:21 <jmcarthur> Eduard_Munteanu: use a newtype wrapper
10:13:28 <zachk1> Eduard_Munteanu: data Peano = Zero | Succesor Peano
10:13:29 <Eduard_Munteanu> jmcarthur, nice, thanks.
10:13:32 <zachk1> seems to be the same thing
10:14:00 <MissPiggy> Cale, so x^2 + x^2 = x^4?
10:14:04 <Eduard_Munteanu> zachk1, yeah.
10:14:06 <Cale> MissPiggy: no
10:14:12 <Cale> MissPiggy: x^2 * x^2 = x^4
10:14:31 <jmcarthur> x^2 + x^2 = 2*x^2
10:15:26 <jmcarthur> oh this isn't plain arithmetic. ignore me
10:15:32 <jmcarthur> i might be right anyway, but i don't know now
10:15:36 <Cale> Assuming we're in R[N] here, where N is the natural numbers under addition, and R is some general ring, the notation x^2 represents the function N -> R which sends 2 |-> 1, and n |-> 0 for any n /= 2.
10:15:37 <jmcarthur> not keeping up with conversation
10:15:48 <Cale> jmcarthur: You're right, anyway
10:16:17 <Cale> It's all just a mechanism to recover normal arithmetic with polynomials (and generalise it at the same time)
10:16:18 <uorygl> So, this program: {newtype Wrap a = Wrap {unWrap :: Wrap a -> a}; main = (\(Wrap x) -> x (Wrap x)) (Wrap (\(Wrap x) -> x (Wrap x)))}
10:16:29 <uorygl> Does that compile yet?
10:17:01 <benmachine> write it and find out?
10:17:06 <Cale> MissPiggy: Does that make sense?
10:17:10 <Eduard_Munteanu> benmachine, he was suggesting it to me.
10:17:11 <MissPiggy> no
10:17:35 <Cale> MissPiggy: Okay, I'll try to explain more carefully. First of all, are you familiar with the usual formal construction of the polynomial ring?
10:18:27 <Eduard_Munteanu> uorygl, wow, compilation never ends.
10:18:29 <Cale> R[x] is a ring consisting of functions N -> R, where f(n) represents the coefficient of x^n in the polynomial f
10:18:38 <Cale> so we define (f + g)(n) = f(n) + g(n)
10:18:56 <Cale> and (f*g)(n) = sum over i+j = n of f(i)*g(j)
10:19:17 <MissPiggy> Cale, oh right these are in one variable
10:19:26 <Cale> Okay, so that's in one variable
10:19:28 <MissPiggy> in two variables would be NxN -> R?
10:19:31 <Cale> yeah
10:19:37 <MissPiggy> okay then it does make sense
10:20:06 <Cale> and the functions have finite support
10:20:11 <Eduard_Munteanu> uorygl, is that messing up with type inference?
10:20:31 <Cale> So it's possible to use a Data.Map from a given monoid to a given instance of Num to represent these things in Haskell :)
10:21:26 <MissPiggy> I guess you can't ask one of these polynomials what order it is, though
10:21:41 <MissPiggy> you'd have to pair it up with an upper bound, along for the ride
10:22:01 <c_olin> How could haskell handle a tree structure where a single object can belong to multiple leaves?  Seems like pointers are required.
10:23:15 <Eduard_Munteanu> c_olin, not really pointers, you could use indexes into a store.
10:23:36 <c_olin> Yeah, I guess that could work
10:23:55 <kmc_> c_olin, the same object can appear in multiple points in a structure
10:24:02 <kmc_> > let x = "foo" in [x,x]
10:24:03 <lambdabot>   ["foo","foo"]
10:24:12 <kmc_> those are the *same* string in memory (in any sane implementation)
10:24:32 <kmc_> Haskell datastructures typically encourage sharing and copy-as-needed
10:24:33 <c_olin> even on a more complex data type?
10:24:46 <kmc_> (different from an all-or-nothing copy-on-write... small changes involve small copying)
10:24:52 <MissPiggy> Cale, on well I was thinking about representing N -> R as an actual haskell function - but I suppose that would be a mistake
10:24:53 <Eduard_Munteanu> c_olin, yes, you can regard data as functions.
10:24:59 <kmc_> c_olin, that will depend on how the type is defined
10:25:04 <kmc_> do you have a specific one in mind?
10:25:11 <Eduard_Munteanu> So x is actualy x() which resolves to "foo".
10:25:14 <MissPiggy> since it doesn't seem like you can eval this representation
10:25:31 <c_olin> Lets say I'm implementing a KDTree for a ray tracer, and some objects are arbritrary collections of polygons that may appear in multiple leaves
10:26:25 <kmc_> remember, since Haskell values are immutable, sharing is always safe, so things are designed for maximal sharing
10:26:56 <kmc_> c_olin, yeah, it sounds like a prime candidate for this sort of sharing
10:27:10 <c_olin> cool
10:27:22 <c_olin> I didn't realize Haskell already solved it for me
10:27:48 <kmc_> trees are nice; if you need to produce a modified copy, you will generally only have to duplicate the nodes leading up the spine of the tree.  the rest of the new tree will point back into the original one
10:28:01 <c_wraith> well..  it's up to you to do the sharing, rather than recalculating the same expression each time.
10:28:14 <c_wraith> Haskell doesn't automatically memoize everything.
10:28:21 <kmc_> right.  this is a typical use of a "let" binding
10:28:25 <kmc_> as in my list example above
10:28:31 <int-e> can anybody explain this cabal-install behaviour? (parsec-3.0.1 is installed and it claims there's no parsec>=3 available, and -v3 isn't producing any helpful output either) http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16399#a16399 ... and the same thing happens with cabal-install 0.8
10:29:49 <Eduard_Munteanu> newtype Wrap a = Wrap {unWrap :: Wrap a -> a}; main = (\(Wrap x) -> x (Wrap x)) (Wrap (\(Wrap x) -> x (Wrap x)))
10:29:59 <Eduard_Munteanu> Can I make this compile in any way? ^
10:30:31 <Eduard_Munteanu> Seems like GHC runs into an infinite cycle, probably in computing types.
10:30:46 <Eduard_Munteanu> So compilation never ends and eats up lotsa memory.
10:30:54 <ivanm> Eduard_Munteanu: unwrap :: a
10:30:58 <ivanm> I think that's what you want
10:31:15 <ivanm> since why would you have Wrap take a function that takes a Wrap (that takes a function, etc.)
10:31:20 <Eduard_Munteanu> ivanm, this is what uorygl gave me, I don't want this particularly. But I want to build infinite types.
10:31:26 <Eduard_Munteanu> e.g. a = Type a
10:31:29 <ivanm> do I dare ask why?
10:31:33 <kmc_> Eduard_Munteanu, you managed to put *GHC* into an infinite loop??
10:31:41 <Eduard_Munteanu> kmc_, yes.
10:31:42 <ivanm> I have nfi what you're doing there :s
10:31:46 <kmc_> that's possible, but the obvious ways of doing it are not present here
10:32:17 <kmc_> yep, it loops for me too
10:32:22 <kmc_> 6.10.4
10:32:24 <Eduard_Munteanu> ivanm, remember my Church numbers? How can I transform a value into Church and the other way around without constructing infinite types?
10:32:39 <kmc_> how do Church numerals involve infinite types?
10:32:44 <ivanm> yeah, but I still don't understand why you were trying to do that ;-)
10:32:44 <kmc_> they have type (a -> a) -> a -> a
10:32:48 <kmc_> forall a
10:33:01 <kmc_> they're the fold over:  data Nat = Zero | Succ Nat
10:33:13 <maltem> Eduard_Munteanu, kmc_, it doesn't loop for me, 6.12.1
10:33:16 <elt0n> in case i want to create an anonymous function which gets a list of ints as parameter how do i have to write that?
10:33:16 <elt0n> \[myList] -> ... or \myList -> ...
10:33:21 <Eduard_Munteanu> succCh :: a -> Church a
10:33:22 <Eduard_Munteanu> succCh = return
10:33:22 <Eduard_Munteanu> succCh :: a -> Church a
10:33:22 <Eduard_Munteanu> succCh = return
10:33:24 <zachk1> > (<) 3 5
10:33:25 <lambdabot>   True
10:33:26 <Eduard_Munteanu> (sorry)
10:33:27 <kmc_> elt0n, the former does the pattern matching for you
10:33:31 <kmc_> and will only match a list of one element
10:33:36 <kmc_> > (\[x] -> x) "z"
10:33:37 <lambdabot>   'z'
10:33:38 <kmc_> > (\[x] -> x) "zz"
10:33:39 <lambdabot>   * Exception: <interactive>:1:134-142: Non-exhaustive patterns in lambda
10:33:39 <Eduard_Munteanu> now my Church is data Church a = Church a
10:33:39 <zachk1> > (not <) 3 5
10:33:40 <lambdabot>   Couldn't match expected type `t1 -> t'
10:33:40 <lambdabot>         against inferred type `GHC.B...
10:33:41 <ivanm> elt0n: depends how you'ree using it
10:33:48 <kmc_> the latter just matches a listn
10:33:48 <temoto> What is this long alias for   "do { n <- integer; return $ Cons n }" ?
10:33:50 <kmc_> a list*
10:33:55 <ivanm> \ (x:xs) -> ; \ xs -> ; \ [x] -> ; etc.
10:33:57 <kmc_> temoto, Cons <$> integer
10:34:09 <kmc_> <$> is just "fmap" but infix
10:34:10 <temoto> kmc_: fmap!
10:34:13 <Eduard_Munteanu> Can you think of any way to do toChurch :: Integer -> Church a ?
10:34:17 <elt0n> ivanm, hmm i want to use it as a list
10:34:23 <kmc_> Eduard_Munteanu, how are these Church numerals?
10:34:23 <temoto> kmc_: thank you.
10:34:44 <ivanm> elt0n: yes, but what do you mean by that?
10:34:47 <kmc_> Eduard_Munteanu, did you see the Russel's paradox example at:  http://www.haskell.org/ghc/docs/latest/html/users_guide/bugs.html#bugs-ghc
10:34:50 <kmc_> it's possibly related
10:34:52 <Eduard_Munteanu> kmc_, Peano, Church, nevermind. The number represented is the number of times a is dressed up in Churches :)
10:34:57 <ivanm> you want to access some of the elements? you're going to apply some [a] -> b function?
10:35:22 <elt0n> i want to access the elements of the list to do stuff with them ^^... sry I'm very new to haskell
10:35:36 <ivanm> I mean, "\ xs -> xs ++ xs" is a valid way of using the parameter of a lambda function as a list
10:35:50 <ivanm> elt0n: generally,  you don't want to write anonymous functions
10:35:54 <ivanm> unless the functioin is very small
10:36:00 <temoto> > map (+1) [1,2,4]  -- elt0n
10:36:00 <ivanm> *function
10:36:00 <lambdabot>   [2,3,5]
10:36:03 <elt0n> ivanm, yes it is very small
10:36:06 <kmc_> Eduard_Munteanu, you're trying to force the numbers to exist at type and value level at the same time?
10:36:11 <ivanm> elt0n: well, what are you wanting to do exactly?
10:36:52 <Eduard_Munteanu> kmc_, no. Say I have Church (Church a). I don't care about a. All I know that number is 2.
10:37:00 <kmc_> it's certainly not 2
10:37:00 <elt0n> ok ivanm I try to explain it
10:37:01 <Eduard_Munteanu> kmc_, 1 would be Church a.
10:37:04 <kmc_> what if a is Church b?
10:37:05 <Eduard_Munteanu> and 0 would be a.
10:37:17 <ivanm> Eduard_Munteanu: I think kmc_ is arguing that there's better ways of representing church numerals/peano arithmetic
10:37:29 <kmc_> more than that, i don't think this way makes any sense
10:37:35 <Eduard_Munteanu> ivanm, yeah, I'm doing this as an exercise and want to see where it leads.
10:37:39 <ivanm> kmc_: well, I was trying to say so politely... ;-)
10:37:45 <elt0n> ivanm, I'm writing a algebra to build a compiler and in this target algebra I have to define my attributes... maybe I show you
10:37:53 <kmc_> your toChurch seems impossible.  it must return a value of type (Church a).  the only way to build such a value is to apply the Church data constructor to a value of type "a".  but the caller can choose absolutely any type "a" so you have no way to make a value of that type
10:37:59 <kmc_> except to cheat and use "undefined"
10:38:01 <Eduard_Munteanu> kmc_, if a = Church b, then succ a = Church a = Church (Church b)
10:38:15 <elt0n> ivanm, http://pastebin.com/d19f55303
10:38:18 <ivanm> elt0n: yeah, sounds like you _don't_ want a lambda function ;-)
10:38:30 <kmc_> data Zero; data Succ a
10:38:31 <Eduard_Munteanu> kmc_, can't I use pattern matching to determine when it's a non-Church a?
10:38:33 <pikhq> type Church a = (a -> a) -> a -> a
10:38:37 <kmc_> you can't pattern match on types
10:38:38 <ivanm> and that you're doing a rather ambitious project if you've just started learning haskell...
10:38:41 <Eduard_Munteanu> kmc_, ouch.
10:38:49 <kmc_> well, you sort of can, with type families
10:38:53 <kmc_> but i think you are pretty confused
10:38:57 <Eduard_Munteanu> Heh, I am.
10:39:10 <pikhq> Unless that's your definition of church numerals, you're not doing church numerals.
10:39:10 <ivanm> elt0n: yeah, that looks fugly
10:39:19 <kmc_> if your numbers are at type level, you don't even need any data constructors
10:39:22 <kmc_> data Zero; data Succ a
10:39:32 <Eduard_Munteanu> pikhq, yeah, they're not Church per se, I'm just calling them that way because they look isomorphic to the real Church.
10:39:33 <idnar> Eduard_Munteanu: I think you're mixing value-level stuff and type-level stuff to a degree that doesn't really work in Haskell
10:39:38 <kmc_> they're not isomorphic
10:39:39 <kmc_> type family Plus a b :: *
10:39:44 <idnar> maybe if we had dependent types, or something...
10:39:45 <kmc_> type instance Plus Zero a = a
10:39:48 <ivanm> elt0n: for example, what happens if you pass a list with more than one or zero elements to the gpxMT function?
10:39:55 <kmc_> type instance Plus (Succ a) b = Succ (Plus a b)
10:40:05 <ivanm> also, for future maintenance purposes, you may want better names for your record fields ;-)
10:40:18 <Eduard_Munteanu> kmc_, \f \x -> x  ------> a, \f \x -> f x --------> Church a
10:40:23 <elt0n> ivanm, you really wanna know what i thinnk... i have no clue
10:40:23 <Eduard_Munteanu> That how I think of it.
10:40:24 <pikhq> Eduard_Munteanu: They're not isomorphic at all. Church numerals represents a number n by a function that applies a function n times.
10:40:31 <kmc_> Eduard_Munteanu, all representations of numbers are isomorphic...
10:40:39 <Eduard_Munteanu> pikhq, yes, here you apply the data constructor over and other.
10:40:42 <Eduard_Munteanu> s/other/over
10:40:55 <elt0n> ivanm, yeah but i have some examples where it's done like that by my prof and i have to do this excerice till sunday ... but we never learned to code haskell
10:40:56 <Eduard_Munteanu> kmc_, yeah.
10:40:59 <ivanm> elt0n: heh
10:41:00 <pikhq> Well, there exists an isomorphism, by merit of both defining naturals... Otherwise.
10:41:03 <kmc_> the conventional name for what you're trying to define would be Peano numbers, not Church numbers
10:41:04 <idnar> pikhq: Church numerals are just church encoding of peano numerals
10:41:08 <idnar> pikhq: so they're related
10:41:14 <kmc_> right
10:41:17 <elt0n> ivanm, the structure of the class is not that well organized
10:41:19 <Eduard_Munteanu> kmc_, ok.
10:41:23 <idnar> I'm not sure if "isomorphic" is the correct word
10:41:29 <pikhq> idnar: Fair enough.
10:41:33 <Eduard_Munteanu> kmc_, so if I look into type families, there's a slight chance I could do this?
10:41:41 <kmc_> Eduard_Munteanu, it's not clear to me what "this" is
10:41:47 <ivanm> elt0n: heh
10:41:48 <kmc_> you want to define natural numbers at type level?
10:42:02 <ivanm> elt0n: OK, if you "knkow" that you're only going to have a singleton list, etc. then that looks OK
10:42:12 <Eduard_Munteanu> kmc_, defining toChurch/toPeano to lift values to type-level applications.
10:42:24 <Eduard_Munteanu> Integers.
10:42:34 <elt0n> ivanm, ok so do i have to write the brackets?
10:42:36 <Eduard_Munteanu> kmc_, yes.
10:42:36 <tal> Could somebody please look at a script (xmonad) and tell me what's wrong?
10:42:38 <kmc_> what would the type of toPeano be?
10:42:44 <ivanm> elt0n: square brackets, yes
10:42:45 <kmc_> tal, sure, hpaste it
10:42:46 <ivanm> @type [1]
10:42:47 <MissPiggy> Cale, so is it possible to write show for these monoidal polynomial forms?
10:42:47 <lambdabot> forall t. (Num t) => [t]
10:42:47 <Eduard_Munteanu> kmc_, Integer -> Church a
10:42:50 <kmc_> Eduard_Munteanu, no
10:42:57 <kmc_> and please stop calling it Church
10:43:01 <Eduard_Munteanu> kmc_, ok.
10:43:02 <ivanm> elt0n: [a,b,c] is syntactic sugar for a:b:c:[]
10:43:03 <kmc_> the caller gets to choose 'a'
10:43:04 <elt0n> ivanm, thx that helped me a lot
10:43:07 <Eduard_Munteanu> kmc_, Integer -> Peano a
10:43:10 <ivanm> elt0n: no worries ;-)
10:43:10 <tal> kmc_, http://shorttext.com/gojwl1pw2
10:43:15 <elt0n> ivanm, kk
10:43:19 <uorygl> I don't think lifting values into the type level is possible. After all, typechecking is done before there are any values in there at all.
10:43:20 <Cale> MissPiggy: Sure, hang on...
10:43:26 <kmc_> tal, so what's wrong?
10:43:44 <kmc_> hmm it looks like you commented out the first line of the defn of modMask, but it continues on later lines
10:44:02 <elt0n> ivanm, but \[gpxTypeAvList]  means that its a list with the name gpxTypeAvList right?
10:44:14 <Eduard_Munteanu> kmc_, can't I use a newtype somehow to abstract Peano a?
10:44:21 <ivanm> elt0n: no, it means its a list with a single value which you're calling gpxTypeAvList
10:44:22 <kmc_> i don't see how
10:44:25 <kmc_> or indeed what you mean
10:44:26 <Eduard_Munteanu> I figure I need some sort of infinite types.
10:44:26 <pikhq> Eduard_Munteanu: I think you could only do an "Integer -> Peano a" sort of thing with Template Haskell...
10:44:27 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16402#a16402
10:44:34 <Eduard_Munteanu> pikhq, yeah, I thought about it.
10:44:36 <kmc_> Eduard_Munteanu, you need to choose a concrete type for the "bottom"
10:44:38 <kmc_> that's why I had
10:44:40 <kmc_> data Zero
10:44:40 <Cale> MissPiggy: ^^
10:44:41 <kmc_> data Succ a
10:44:57 <kmc_> so type level 2 is Succ (Succ Zero)
10:45:01 <elt0n> ivanm, arg...thats not what i want... i want to use a parameter that is type of a list which i can iterate over or sth like that
10:45:13 <ivanm> nope, don't get what you mean ;-)
10:45:19 <Eduard_Munteanu> kmc_, oh, so that makes it possible to pattern-match on simple a?
10:45:22 <tal> kmc_, I've no idea what's up - it's not to do with the modmask though, that's just an overwrite that I didn't want just yet
10:45:24 <pikhq> ... Or you could just do it right, as kmc suggests.
10:45:24 <ivanm> elt0n: you want to get the type of a list and use the type in your function?
10:45:34 <ivanm> not sure why you'd want to use the actual type in your function though...
10:45:36 <MissPiggy> Cale, oh, for some reason I thought it would be Map a n -> R, rather than just Map a n
10:45:40 <kmc_> Eduard_Munteanu, i don't understand what that would mean
10:45:49 <kmc_> you can then define some type families in terms of Zero and Succ
10:46:00 <kmc_> but you could never write the correct toPeano :: Integer -> Succ a
10:46:03 <Eduard_Munteanu> kmc_, I'm asking why it works. Because I can do pattern matching on Zero and Succ separately?
10:46:03 <elt0n> ivanm, no i always thpought, that i define a parameter there and get a java like list parameter which i can access
10:46:18 <ivanm> ummm.... it's been a while since I used java ;-)
10:46:25 <Cale> MissPiggy: Then all you need is a Bag monoid, for polynomials in arbitrarily many indeterminates :)
10:46:26 <kmc_> Eduard_Munteanu, it's not the same as pattern matching on values.  but yes, both type families and typeclasses do a form of pattern matching on types
10:46:26 <Eduard_Munteanu> kmc_, oh, so it doesn't work even that way :/
10:46:41 <kmc_> you can't write that toPeano
10:46:45 <kmc_> the caller chooses 'a'
10:46:52 <ivanm> > (\[n] -> "This function brought to you thanks to the number " ++ show n) [1]
10:46:52 <kmc_> that being how polymorphism works
10:46:53 <lambdabot>   "This function brought to you thanks to the number 1"
10:46:56 <ivanm> elt0n: ^^
10:47:16 <Eduard_Munteanu> kmc_, isn't there any newtype declaration that 'hides' away the number of Succ applications for the caller?
10:47:19 <ivanm> what exactly do you want?
10:47:23 <aavogt> how do people handle libraries that export all these different monad libraries?
10:47:24 <kmc_> Eduard_Munteanu, that would be an existential type
10:47:31 <elt0n> ivanm, sry seems i really don't know what i'm doing...
10:47:32 <kmc_> which is fine, but you can't do much with the value after
10:47:40 <ivanm> elt0n: heh
10:47:40 * MissPiggy tries to figure out if it should be a bag of monoid rings or a monoid ring of bags :S
10:47:44 <Cale> I have one handy... http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16402#a16403
10:47:52 <aavogt> as in, mismatches between record libraries (like fclabels) and monads-fd, mtl, transformers....
10:47:57 <Cale> MissPiggy: A monoid ring, where the monoid is bags of elements.
10:48:02 <kmc_> Eduard_Munteanu, especially since there is no value-level representation of your numbers
10:48:03 <Cale> (under bag-union)
10:48:11 <kmc_> so all the existential does is to throw out the type information
10:48:13 <kmc_> which is all you have
10:48:32 <Eduard_Munteanu> kmc_, oh so even if I manage to do toPeano, I can't do toValue?
10:48:47 <kmc_> elt0n, in Haskell, function parameters are specified using "patterns".  [x] is a pattern that matches a list which has one element (and binds it to the name 'x' locally).  in the same way, [x,y,z] matches a list of three elements and [] a list of none.
10:49:04 <kmc_> if you want to match the list itself rather than some fixed number of elements, you just give a variable name
10:49:15 <kmc_> > (\x -> "Hello " ++ x) "world"
10:49:16 <lambdabot>   "Hello world"
10:49:26 <kmc_> (strings are lists, by the way)
10:49:35 <pikhq> Eduard_Munteanu: You sure you don't want actual Church numerals? :P
10:49:41 <elt0n> kmc_ so there are no infinite lists?
10:49:47 <kmc_> elt0n, there definitely are
10:49:59 <Eduard_Munteanu> pikhq, um, I'm not doing anything practical, just wrapping my mind around stuff.
10:50:02 <pikhq> > fix show
10:50:03 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
10:50:03 <kmc_> the point of pattern matching is that you can have multiple cases
10:50:15 <c_wraith> let zeroes = 0:zeroes in zeroes
10:50:25 <pikhq> > fix (0:)
10:50:26 <MissPiggy> Cale, thanks! I have to read a bit more about this to properly get it but it seems very perfect
10:50:26 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
10:50:27 <Eduard_Munteanu> Okay, so what does Haskell need in order to make this possible? Dependent types?
10:50:36 <kmc_> yes
10:50:40 <Eduard_Munteanu> kmc_, thanks.
10:50:41 <kmc_> your toPeano has a dependent type
10:50:44 <uorygl> > fix (map (\x -> case x of '"' -> '\\'; '\\' -> '"'). show)
10:50:45 <lambdabot>   "\\\"\"\"\\\"\\\"\\\"\"\"\\\"\"\"\\\"\"\"\\\"\\\"\\\"\"\"\\\"\\\"\\\"\"\"\\...
10:50:47 <kmc_> the return type depends on the input value
10:50:50 <elt0n> kmc_ so i will try to use finite lists ^^ maybe i'll get some credits too
10:51:02 <kmc_> elt0n, i think you are confused
10:51:06 <kmc_> you wanted to match the list itself
10:51:09 <kmc_> rather than some of its elements
10:51:10 <kmc_> right?
10:51:16 <uorygl> Actually, I wonder if it isn't possible to do what Eduard_Munteanu is trying to do, using existential types and classes.
10:51:30 <elt0n> elt0n, yeah I'm definetly confused ^^
10:51:31 <kmc_> it is definitely possible to write type-level numbers
10:51:50 <elt0n> kmc_ yes i want to match the list
10:51:52 <uorygl> I mean, we have a typeOf function that's pretty much a toValue. I think we can hide values of arbitrary Peano-ey types inside an existential type.
10:51:56 <sshc_> @src fix
10:51:56 <lambdabot> fix f = let x = f x in x
10:52:08 <kmc_> > (\x -> "Here is the list I got: " ++ x)  "foobar"
10:52:09 <lambdabot>   "Here is the list I got: foobar"
10:52:11 <kmc_> elt0n, ^^^^^ matching a list
10:52:14 <kmc_> the list is named "x"
10:52:22 <kmc_> you don't have to name it "specially" because it's a list
10:52:28 <kmc_> it's just another value
10:52:38 <elt0n> kmc_ ahhh now i got it, that was my initial question ^^
10:52:41 <MissPiggy> Cale, why does finite support matter?
10:53:07 <kmc_> whereas, [x] is a more restricted pattern that only matches a list of one element.  it's most useful as part of a "case" expression or multiple-equation functnion definition
10:53:14 <kmc_> because you can account for the other cases elseways
10:53:17 <elt0n> kmc_ now i can go on thx
10:53:20 <kmc_> cool :)
10:53:41 <Eduard_Munteanu> @hoogle typeOf
10:53:41 <lambdabot> Data.Typeable typeOf :: Typeable a => a -> TypeRep
10:53:42 <lambdabot> Data.Typeable typeOf1 :: Typeable1 t => t a -> TypeRep
10:53:42 <lambdabot> Data.Typeable typeOf1Default :: (Typeable2 t, Typeable a) => t a b -> TypeRep
10:53:47 <ivanm> kmc_: and here I was thinking I had already said that... ;-)
10:53:51 <kmc_> me too
10:53:53 <ivanm> (with a (\x -> x ++ x) example)
10:53:54 <Eduard_Munteanu> uorygl, neat, I'll look it up.
10:54:12 <uorygl> > typeOf "Blaaaah!"
10:54:13 <lambdabot>   [Char]
10:54:21 <sshc_> :t typeOf
10:54:22 <lambdabot> forall a. (Typeable a) => a -> TypeRep
10:54:26 * MissPiggy sorry &
10:54:34 <sshc_> :t typeOf "t"
10:54:35 <lambdabot> TypeRep
10:54:37 <Eduard_Munteanu> > typeOf Just (Just (Just 2))
10:54:37 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe
10:54:38 <lambdabot>                             ...
10:54:43 <uorygl> Unfortunately, it hates polymorphism.
10:54:45 <sshc_> can you get the String of a type?
10:54:46 <Eduard_Munteanu> > typeOf (Just (Just (Just 2)))
10:54:47 <lambdabot>   Maybe (Maybe (Maybe Integer))
10:54:52 <uorygl> > typeOf id
10:54:52 <lambdabot>   Ambiguous type variable `a' in the constraint:
10:54:53 <lambdabot>    `Data.Typeable.Typeable a...
10:55:02 <kmc_> sshc_, yes, TypeReps have a Show instance
10:55:07 <kmc_> that's how lambdabot is printing them
10:55:10 <kmc_> if that's what you meant
10:55:12 <Eduard_Munteanu> sshc_, sure
10:55:13 <kmc_> > show $ typeOf Nothing
10:55:14 <lambdabot>   Ambiguous type variable `a' in the constraint:
10:55:14 <lambdabot>    `Data.Typeable.Typeable a...
10:55:15 <sshc_> kmc_: yes
10:55:20 <kmc_> > show $ typeOf (Nothing :: Maybe Char)
10:55:21 <lambdabot>   "Maybe Char"
10:55:41 * sshc_ looks up documentation on Data.Typeable
10:56:28 <kmc_> there's a big difference between dynamic types and dependent types
10:56:39 <kmc_> and we can implement Eduard_Munteanu's toPeano using dynamic typing of sorts
10:56:46 <Eduard_Munteanu> uorygl, so how does it work with existential types? I can choose different constructors depending on the underlying value type?
10:56:50 <kmc_> toPeano :: Integer -> Maybe (Peano a)
10:57:02 <kmc_> the caller chooses a type-level number, and passes in an Integer
10:57:08 <kmc_> you get back Nothing if the two do not match
10:57:24 <kmc_> this is much like fromDynamic
10:57:34 <kmc_> :t toDyn "foo"
10:57:35 <lambdabot> Dynamic
10:57:40 <kmc_> :t fromDynamic (toDyn "foo") :: Int
10:57:41 <lambdabot>     Couldn't match expected type `Int' against inferred type `Maybe a'
10:57:41 <lambdabot>     In the expression: fromDynamic (toDyn "foo") :: Int
10:57:43 <kmc_> :t fromDynamic (toDyn "foo") :: Maybe Int
10:57:44 <lambdabot> Maybe Int
10:57:50 <sshc_> :t toDynamic "bar"
10:57:50 <kmc_> > fromDynamic (toDyn "foo") :: Maybe Int
10:57:51 <lambdabot> Not in scope: `toDynamic'
10:57:51 <lambdabot>   Nothing
10:57:53 <Eduard_Munteanu> kmc_, yeah, though you can't build them at runtime.
10:57:55 <sshc_> :t toStatic "bar"
10:57:56 <lambdabot> Not in scope: `toStatic'
10:58:00 <kmc_> > fromDynamic (toDyn "foo") :: Maybe String
10:58:00 <lambdabot>   Just "foo"
10:58:20 <kmc_> Data.Dynamic uses Data.Typeable + an underlying unsafe cast
10:58:24 <kmc_> it's actually a very small module
10:58:38 <Eduard_Munteanu> So it's like Presburger arithmetic in that sense, you need to define stuff explicitly.
10:58:39 <pikhq> > fromDynamci (toDyn "foo") :: Int
10:58:40 <lambdabot>   Not in scope: `fromDynamci'
10:58:43 <pikhq> > fromDynamic (toDyn "foo") :: Int
10:58:45 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
10:58:45 <lambdabot>         against inferred type ...
10:58:47 <kmc_> :k Mu Maybe
10:58:48 <lambdabot> *
10:58:53 <pikhq> > fromDynamic (toDyn "foo") :: Maybe Int
10:58:54 <lambdabot>   Nothing
10:59:05 <Eduard_Munteanu> You don't have an axiom schemata that gives you the set of integers at type level :/
10:59:10 <uorygl> Eduard_Munteanu: define your Zero and Succ types, then define a class called P or something containing them.
10:59:21 <pikhq> Hmm. That's an interesting module. It's like, typesafe dynamic types.
10:59:32 <kmc_> yeah
10:59:36 <uorygl> Then do this: data Peano = forall a. P a => Peano a
10:59:37 <kmc_> most dynamically typed languages are typesafe
10:59:46 <Eduard_Munteanu> uorygl, my numbers are already an instance of Monad and Copointed (for return and coreturn :) )
10:59:49 <kmc_> Eduard_Munteanu, http://haskell.org/haskellwiki/Peano_numbers
10:59:58 <kmc_> Eduard_Munteanu, http://haskell.org/haskellwiki/Type_arithmetic
11:00:15 <kmc_> note that these writeups predate type families
11:00:16 <Eduard_Munteanu> kmc_, thanks.
11:00:16 <uorygl> Then you can convert from Integer to Peano and back. For the conversion back, use classes.
11:00:23 <kmc_> so they use typeclasses and fundeps to accomplish the same thing in a more awkward way
11:01:22 <Eduard_Munteanu> Nice, in fact I started this as an exercise in (co)monads, I was going to use return and coreturn to define succ and pred.
11:01:25 <kmc_> Eduard_Munteanu, note how most of the types involved have no data constructors
11:01:46 <Eduard_Munteanu> kmc_, yeah.
11:08:41 <mola89> i want to make xmonad write to a named pipe, and have 'tail' piped to 'dzen' read from it. However (i guess for some buffering issues), the read is done only when i quit xmonad. Here is a snip http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16404#a16404
11:09:45 <c_wraith> mola89: did you try adding a flush?
11:10:01 <kmc_> mola89, ppOutput = \xs -> hPutStrLn h xs >> hFlush h
11:10:16 <kmc_> also, why is "tail" involved?
11:11:13 <mola89> kmc_: to have the named pipe redirected to dzen's stdin.. is there a better way?
11:11:27 <kmc_> dzen2 ... < myfifo
11:11:32 <kmc_> cat myfifo | dzen2 ...
11:11:39 <kmc_> either will work
11:12:57 <mola89> i'll try that. And for the buffering i tried: ppOutput = hPutStrLn h >> \s -> hFlush h  i don't know if it's exactly the same
11:13:18 <kmc_> oh, tricky
11:13:20 <kmc_> that's not the same
11:13:33 <mola89> :O why!?
11:13:34 <kmc_> i think that (>>) is in the ((->) String) monad, not the IO monad
11:13:42 <kmc_> the thing to the left of >> is not an IO action
11:14:03 <kmc_> :t hPutStrLn h >> \s -> hFlush h
11:14:03 <lambdabot> Not in scope: `hPutStrLn'
11:14:04 <lambdabot> Not in scope: `hFlush'
11:14:33 <zachk1> 38 pages into a tutorial on agda "In Agda, these problems are solved by allowing arbitrary
11:14:33 <zachk1> Haskell functions to be imported as axioms" :-O
11:14:33 <ivanm> kmc_: it's type would be a -> IO () I think
11:14:36 <ivanm> @hoogle hFlush
11:14:36 <lambdabot> System.IO hFlush :: Handle -> IO ()
11:14:44 <ivanm> yeah, that looks about right
11:14:55 <kmc_> right
11:14:55 <ivanm> kmc_: actually, that won't typecheck...
11:15:03 <ivanm> hPutStrLn h <-- needs a String!
11:15:06 <kmc_> zachk1, hehe
11:16:04 <kmc_> mola89, i got bit by this a while ago
11:16:38 <mola89> kmc_: i'm totally harmless in front of this
11:16:52 <kmc_> uhm
11:17:21 <mola89> i mean, i cannot really understand why those two functions are different
11:17:50 <kmc_> the type of (hPutStrLn h) is (String -> IO ())
11:17:57 <temoto> > type A
11:17:58 <lambdabot>   <no location info>: parse error on input `type'
11:18:03 <kmc_> the top level type constructor is (->)
11:18:38 <kmc_> (>>) :: (Monad m) => m a -> m b -> m b
11:19:04 <kmc_> you are passing (hPutStrLn h) as the first arg to that
11:19:09 <kmc_> so we try to unify the types (String -> IO ()) and (m a)
11:19:16 <dolio> Man, Awodey has like 10 different functors, all denoted by asterisks.
11:19:26 <mola89> so i'm dealing with -> monad ..
11:19:41 <kmc_> with the result that:   m = ((->) String)   and   a = (IO ())
11:19:59 <kmc_> where ((->) String) we would write as (String ->), if we had type-operator sections
11:20:03 <kmc_> yes
11:20:13 <mola89> wow.
11:20:22 <kmc_> it is totally irrelevant to this invocation of (>>) that the type "a" is in another monad
11:20:29 <kmc_> :t liftM2 (>>)
11:20:30 <lambdabot> forall (m :: * -> *) a b (m1 :: * -> *). (Monad m, Monad m1) => m1 (m a) -> m1 (m b) -> m1 (m b)
11:20:38 <kmc_> ^^^^ this is more what you want
11:20:50 <kmc_> but i think it's unnecessarily fancy
11:21:13 <Berengal> ppOutput s = hPutStrLn h s >> hFlush h
11:21:29 <c_wraith> Berengal: does that work in record syntax?
11:21:46 <Berengal> ppOutput = \s -> hPutStrLn h s >> hFlush h
11:21:52 <Berengal> Now it does
11:22:01 <c_wraith> Which is the same thing kmc_ suggested initially
11:22:26 * Berengal wishes it worked in record syntax
11:22:45 <c_wraith> it'd be nice if it did.
11:22:49 <mola89> wow. you guys are amazing. thank you!
11:23:06 <Berengal> Although, that kind of syntax isn't really high on my priority list
11:23:33 <kmc_> mola89, :)
11:23:35 <kmc_> glad to help
11:24:38 <Berengal> ... even heredocs would be nicer, I think
11:24:44 <mola89> but is hflush always evaluated before that hputstrln?
11:24:56 <mola89> err.. the opposite
11:24:58 <Berengal> No, it's always evaluated later
11:24:59 <Berengal> Yes
11:25:13 <temoto> x <- try (foo)   or     try (x <- foo) ?
11:25:21 <temoto> (Parsec)
11:25:22 <monochrom> x <- try foo
11:25:34 <temoto> Thanks.
11:27:44 <mola89> ok. now i try with flush, see you later! (hopefully)
11:28:13 <kmc_> evaluated is not the issue
11:28:16 <kmc_> but anyway
11:36:22 <kmc_> temoto, (x <- e) is not an expression; it's a do statement
11:36:37 <kmc_> you can however:  try (do { x <- a; b; ... })
11:36:45 <kmc_> more commonly written: try $ do { x <- a; b; ... }
11:40:01 <temoto> Yeah i wonder what x will be if try fails.
11:40:17 <temoto> x <- try foo
11:40:35 <kmc_> it will fall out of this scope
11:40:59 <kmc_> do { x <- try foo; bar }   desugars to:    (try foo) >>= (\x -> bar)
11:41:23 <kmc_> (>>=) will be defined such that it doesn't call its right argument if the left argument is failure
11:41:28 <kmc_> btw, this has nothing to do with "try"
11:41:35 <kmc_> parsers that aren't wrapped in "try" can fail too
11:41:48 <temoto> I think i got it, thanks.
11:42:02 <temoto> i just wanted to try a complex parser
11:42:15 <paper_cc> temoto: the documentation of 'try' describes its behaviour pretty well - http://hackage.haskell.org/packages/archive/parsec/3.0.1/doc/html/Text-Parsec-Prim.html#v%3Atry
11:42:22 <kmc_> the point of wrapping with "try" is that, if the parser fails, it will consume no input
11:42:29 <temoto> as in x <- try $ do { char 'f'; char 'o' }
11:43:14 <temoto> <|> must be using try too
11:43:20 <ivanm> IIRC, it does
11:43:24 <ivanm> @hoogle try
11:43:24 <lambdabot> Control.Exception try :: Exception e => IO a -> IO (Either e a)
11:43:24 <lambdabot> Control.OldException try :: IO a -> IO (Either Exception a)
11:43:24 <lambdabot> Control.Exception.Base try :: Exception e => IO a -> IO (Either e a)
11:43:27 <ivanm> heh
11:43:35 <temoto> @hoogle (<|>)
11:43:35 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
11:43:36 <lambdabot> Text.Parsec.Prim (<|>) :: Monad m => ParsecT s u m a -> ParsecT s u m a -> ParsecT s u m a
11:43:36 <lambdabot> Text.ParserCombinators.Parsec.Prim (<|>) :: Monad m => ParsecT s u m a -> ParsecT s u m a -> ParsecT s u m a
11:43:40 <kmc_> no i don't think so
11:43:42 <temoto> @src (<|>)
11:43:42 <lambdabot> Source not found. Where did you learn to type?
11:44:05 <kmc_> the example in that doc
11:44:15 <kmc_> shows why try is needed with (<|>)
11:45:30 <kmc_> parsers not wrapped with "try" can fail too
11:47:08 <kmc_> the point of "try" is to request lookahead, while otherwise parsers are greedy
11:48:49 <mux> yeah, try with <|> is only needed with the first parser if it can fail while having consumed input
11:49:24 <mux> otherwise it's just a pessimization
11:50:17 <monochrom> Enjoy http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=6356#a6447
11:50:58 <kmc_> man, Uniplate looks really nice
11:51:00 <kmc_> anyone used it?
11:52:02 <roconnor> ‚á±
11:53:06 <kmc_> simpler than SYB, and with a less disturbing implementation
11:53:37 <temoto> > parse parseModule "test" "module Fo\nf = 1"
11:53:38 <lambdabot>   Not in scope: `parse'Not in scope: `parseModule'
11:53:39 <temoto> Right (Module "Fo" [FuncDecl ("f",[]) (Integer 1)])
11:53:44 <temoto> This is wonder.
11:53:58 <kmc_> temoto, are you writing a Haskell compiler? ;)
11:54:06 <kmc_> i hear that's a good way to learn Haskell
11:54:17 <Ke> !!
11:54:36 <temoto> kmc_: no but syntax is almost haskell.
11:55:17 <kmc_> temoto, cool.  are you implementing layout?
11:55:38 <temoto> And as long i'm a total nothing in compilers, i'll execute code in interpreter written in Haskell too.
11:55:59 <kmc_> i find compiling to a high-level language is a good strategy
11:56:05 <temoto> kmc_: what do you mean by layout?
11:56:11 <kmc_> whitespace sensitive parsing
11:56:23 <kmc_> in the Haskell style, by allowing indentation to stand for implicit { } ;
11:56:26 <temoto> I like that, yeah.
11:56:42 <temoto> Not there yet, though.
11:57:15 <kmc_> i found it a bit awkward to do layout with Parsec; i implemented a two-step lex/parse combination (common in other systems but uncommon with Parsec), with a non-Parsec layout desugarer in between
11:57:31 <kmc_> the latter being a direct implementation of http://www.haskell.org/onlinereport/syntax-iso.html#sect9.3
11:57:44 <temoto> May i take a look?
11:57:58 <kmc_> the code is not at hand right now
11:58:06 <kmc_> perhaps i can dig it up later
11:59:59 <nyloc> hi
12:00:19 <kmc_> hi
12:00:22 <nyloc> I'm learning Haskell and have question
12:00:29 <nyloc> I tryed this http://pastebin.com/m7d214edd
12:00:32 <nyloc> in ghci
12:00:39 <kmc_> (for a sec i was wondering why the ##c++ factoid bot joined our channel)
12:00:43 <nyloc> the first version is working
12:00:48 <nyloc> the second is not
12:01:32 <kmc_> nyloc, i wouldn't use ghci for multi line layout sensitive stuff
12:01:36 <kmc_> put it in a file
12:02:01 <kmc_> this looks valid by the usual layout rule... but perhaps GHCi uses a variation
12:02:12 <nyloc> okaj, but theoretically its correct to use indention to spcify ..ok
12:02:38 <kmc_> yeah
12:02:51 <kmc_> it's also unusal to use "where" inside "let"
12:03:02 <sproingie> looks like a test to me
12:03:05 <kmc_> and this "let" is the do-statement form of let
12:03:25 <kmc_> bottom line, I would just stuff the other definitions in the "let"
12:03:32 <Berengal> I think you need to start explicit layout with {
12:03:38 <sproingie> i would put it all in a file
12:03:44 <kmc_> you can use ; within implicit layout though
12:03:46 <Berengal> But perhaps not
12:04:06 <sproingie> i like how the :{ and :} look like smiley faces
12:04:14 <kmc_> man with moustache
12:04:14 <nyloc> thanks
12:04:15 <nyloc> ;)
12:04:28 <kmc_> there are certain cases where the "where" is convenient... if you want arguments to a function to be free variables in your bindings, yet need said bindings to scope over multiple equations
12:05:15 <nyloc> nut using ghci would mean writing a file and using ghc to compile it
12:05:24 <kmc_> you can load the file into ghci "directly"
12:05:35 <Berengal> nyloc: you can load it in ghci with :load. It's actually pretty convenient
12:05:41 <kmc_> GHCi> :load foo.hs
12:05:44 <nyloc> ah, ok
12:05:44 <Berengal> More so than writing everything in ghci all the time
12:05:47 <kmc_> my-shell-prompt$ ghci foo.hs
12:05:53 <Berengal> Also, :r reloads the last loaded
12:06:04 <Berengal> (and :edit opens it in your editor)
12:06:24 <nyloc> oh thats rellay convenient
12:07:29 <nyloc> dammed my typos are getting the upper hand, I hope you can understand what I write ;)
12:07:36 <Berengal> The :edit one supposes you have a default editor set already. On unix it just looks at the EDITOR environment variable, and on windows I have no idea
12:08:30 <sproingie> it starts notepad
12:09:20 <nyloc> hmm, :editor seems not to work maybe because my default editor is nano
12:09:27 <Berengal> :edit
12:09:34 <Berengal> (or :e, maybe)
12:09:39 * Berengal tests
12:09:58 <sproingie> ghci on windows starts notepad by default, it does respect the EDITOR environment variable
12:09:59 <nyloc> *Main> :edit
12:09:59 <nyloc> SIGHUP oder SIGTERM empfangen
12:10:03 <Zao> It uses EDITOR on Windows as well.
12:10:32 <nyloc> hmm, I gonna try with an x11 aware edit
12:11:04 <sproingie> i prefer haskell-mode anyway
12:12:03 <Berengal> Me too
12:12:15 <nyloc> export EDITOR=/usr/bin/kate  solved it
12:12:23 <Berengal> But haskell-mode requires emacs, which I admit might not be to everyone's liking
12:12:34 <nyloc> themse the :edit command does not work with console based editor
12:12:42 <nyloc> seems ...
12:12:46 <Berengal> It does for me
12:12:52 <nyloc> hmm
12:13:04 <Berengal> The bug must be more specific than that...
12:13:05 <nyloc> with vim ed or nano ?
12:13:13 <Berengal> I used yi
12:13:44 <kmc_> does :edit do a :reload after your editor returns?
12:13:57 <Berengal> (But then I switched to emacs, because using a haskell-based editor to write haskell when my haskell environment is as unstable as it is turned out to be a bad idea)
12:14:05 * Berengal checks that too
12:14:51 <monochrom> export EDITOR=gedit; unset VISUAL; ghci; :edit xxx.hs  works for me. gedit is the gnome editor, patently x11.
12:15:24 <ivanm> Berengal: well, there's haskellmode for vim as well...
12:16:24 <kmc_> i've never had a desire to entangle my editor and language implementation to this degree
12:16:27 <kmc_> but there are some advantages
12:16:28 <Berengal> Doesn't seem like it reloads...
12:16:30 <temoto> (parsec) typeIdent = upper . (many alphaNum)  is this a proper parser for capitalized identifiers?
12:16:35 <kmc_> if a Haskell IDE supported Agda-style holes, I might switch
12:16:58 <Botje> temoto: shouldn't that be >> ?
12:17:02 <jmcarthur> i think there is a project to develop exactly that, kmc_. i forget the name though
12:17:07 <jmcarthur> i think it's on github somewhere
12:18:01 <kmc_> you might be able to do it within scion
12:18:10 <jmcarthur> i don't think it was scion
12:18:11 <kmc_> if you can insert an "undefined", then ask for its type after inference
12:18:12 <Berengal> kmc_: "might" is the wrong word. "Absolutely" is more correct.
12:18:17 <kmc_> cool
12:18:28 <Berengal> Also, editor support is not enough. I want repl support as well
12:18:44 <Berengal> Including asking about the context of the hole
12:18:51 <kmc_> type inference context?
12:18:57 <Berengal> Yep
12:19:05 <Berengal> Including local bindings
12:19:17 <kmc_> i wonder if Coq-style proof scripts are applicable to writing "real" programs as well
12:19:22 <Berengal> Also, I think the project was called ghc-goals or something
12:19:22 <kmc_> Coq's proof scripts are a huge hack, though
12:19:25 <kmc_> ah
12:19:32 <jmcarthur> Berengal: that sounds right
12:20:39 <kmc_> very cool
12:21:29 <jmcarthur> kmc_: you might find this interesting: http://www.iis.sinica.edu.tw/~scm/2009/algebra-of-programming-in-agda-dependent-types-for-relational-program-derivation/
12:21:32 <MissPiggy> kmc_, you can use refine to put down the skeleton (and then fill in proof obligations with search tactics) but writing programs by search tactics is bad style
12:21:44 <jmcarthur> i haven't actually read it yet, but it seems at least loosely related to tactics
12:21:52 <jmcarthur> but for real programs
12:22:08 <MissPiggy> it's (a beautiful example of) derivation carrying code
12:23:03 <temoto> \@undo is desugar bot?
12:23:18 <kmc_> @undo do { x <- a; b; y <- c }
12:23:18 <lambdabot>  Parse error at "}" (column 24)
12:23:30 <Berengal> It undoes do sugar only
12:23:54 <dolio> @undo [ x | x <- l ; p x ]
12:23:54 <lambdabot>  Parse error at ";" (column 14)
12:23:58 <temoto> @undo do { reserved "pass"; return Pass }
12:23:58 <lambdabot> reserved "pass" >> return Pass
12:23:59 <dolio> @undo [ x | x <- l , p x ]
12:23:59 <lambdabot> concatMap (\ x -> if p x then [x] else []) l
12:24:12 <temoto> Thanks. Excellent tool.
12:24:25 <kmc_> there was a time when comprehensions were just an alternate syntax for "do"
12:25:07 <Berengal> I've almost completely stopped using list comprehensions
12:25:16 <temoto> @undo [1..]
12:25:16 <lambdabot> [1 ..]
12:25:19 <jmcarthur> me too
12:25:20 <aavogt> @hoogle unzipWith
12:25:20 <lambdabot> No results found
12:25:21 <temoto> @undo [1..2]
12:25:22 <lambdabot> [1 .. 2]
12:25:50 <aavogt> @hoogle (a -> b -> (c,d)) -> [a] -> [b] -> ([c],[d])
12:25:50 <lambdabot> No results found
12:26:06 <nyloc> the not working editor seems somehow directly related to nano
12:26:25 <jlouis> I never cared too much for list comprehensions
12:26:30 <nyloc> with vim its working fine
12:26:31 <nyloc> http://ubuntuforums.org/archive/index.php/t-1034388.html
12:26:46 <nyloc> but I think I can live with that :p
12:26:53 <jlouis> OTOH I never had them in ML, so I did not know what I was missing out on
12:27:59 <temoto> nyloc: my vim is working like nano - no pissing modes, almost everything is mapped to insert-mode key. I think this is the only way to get any use of vim.
12:28:19 <Botje> temoto: that's a horrible thing to do :'(
12:28:52 <aavogt> I don't see why you'd use vim then
12:28:54 <temoto> Botje: yeah, so true. But other editors without modes are even worse.
12:29:18 <nyloc> I also still have my problems with vim
12:29:30 <nyloc> last time I wanted to deleate a whole line
12:29:45 <nyloc> it took me ages to finde out how this worked
12:29:47 <nyloc> :P
12:30:02 <Botje> have you run through vimtutor and/or printed out a cheat sheet yet?
12:30:10 <Berengal> To me, at least, learning vim has proved harder than learning emacs
12:30:23 <Botje> yes, emacs is also nice
12:30:33 <benmachine> I don't think anyone claims learning vim is easy
12:30:55 <Berengal> In emacs I ran through a quater of the tutorial, and have been able to use it since. I still don't know how to use vim properly...
12:31:11 <temoto> Because it's 1) fast, 2) composes highlighting, 3) i understand how to configure it
12:31:16 <nyloc> but seems I have to because its the only editor running on the strato webhost server
12:31:51 <benmachine> I get on well with vim
12:32:08 <benmachine> I'd probably get on well with emacs but I reckon learning one editor very well is better than two mediocre
12:32:48 <Berengal> I still don't know all the fancy features of emacs...
12:32:54 <olsner> learning two mediocre editors are definitely worse that learning one good :P
12:32:59 <olsner> *is
12:33:02 <nyloc> u cant know all features of emacs
12:33:13 <nyloc> emacs is like a os for it slef ^
12:33:16 <Berengal> By the power of turing completeness, there's probably an infinite amount of them
12:33:26 <benmachine> everyone should be using yi of course
12:34:05 <benmachine> huh, yi skips down by half a page when I am scrolling through something
12:34:09 <aavogt> yi's vim emulation is missing a couple things last I tried
12:34:09 <Berengal> benmachine: I stopped after I had used yi as a tool in breaking my haskell environment, and then needing yi to fix it, but it was broken because I had broken my haskell environment
12:34:10 <benmachine> how incredibly awkward and annoying
12:34:11 <nyloc> I think emacs is evolving after beeing installed like the fat thing in evolution (movie)
12:34:43 <nyloc> once u think u got it next time there are more features you didn't think of :p
12:34:47 <Berengal> emacs = trapperkeeper
12:35:04 <temoto> I don't want to touch anyone, but talking about emacs... an *editor* consisting of over 1M lines is clearly done/designed wrong.
12:35:34 <temoto> Still C-x f completion in emacs is awesome.
12:35:39 * Berengal thinks that if it had been written in forth it would be 1kb, and just as featureful
12:35:48 <temoto> vims wildmenu is only halfway there
12:36:43 <solrize> @src groupBy
12:36:44 <lambdabot> groupBy _  []       =  []
12:36:44 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
12:36:44 <lambdabot>     where (ys,zs) = span (eq x) xs
12:37:19 <solrize> @src span
12:37:19 <lambdabot> Source not found. Are you on drugs?
12:37:27 <temoto> Backwards written in as Forth?
12:37:43 <temoto> Berengal: ^
12:37:48 <Berengal> Haha
12:38:04 <Berengal> @remember <temoto> Backwards written in as Forth?
12:38:04 <lambdabot> Done.
12:38:14 <solrize> emacs isn't anything like 1m lines unless you count every library anyone has ever written
12:38:23 <temoto> I assume you meant that forth then. :)
12:39:11 * Berengal must now download the emacs source to count
12:39:37 <MissPiggy> I wish I knew algebra like Cale does :P
12:39:41 <temoto> solrize: i read it in some news last year.
12:39:47 <temoto> maybe it was wrong
12:40:19 <solrize> i guess if calc.el is included ... ;)
12:40:25 <Cale> I don't even know as much algebra as I'd like to.
12:40:46 <flux> "As of right now (23 June 2008), a checkout of GNU Emacs has 1,112,341 lines of Lisp as well as 346,822 lines of C."
12:41:10 <solrize> ok, mostly libraries
12:41:12 <temoto> Yeah that's what i read.
12:41:16 <chrisf> so much for a small editor core.
12:41:25 <chrisf> 340KLOC is a lot of C.
12:41:28 <solrize> a lot of the C stuff is libraries too
12:41:36 <solrize> it's not that hard to hack on
12:41:40 <solrize> it's not like gcc
12:42:01 <dolio> Cale: So, I'm on chapter 9 of the Awodey category theory book, and I'm starting to see a somewhat higher rate of typos (I think).
12:42:17 <Cale> dolio: Oh?
12:42:28 <kmc_> Berengal, can't you keep a statically linked yi saved away somewhere?
12:42:32 <chrisf> dolio: either that, or you're missing something ;)
12:42:40 <dolio> Yeah. That's the problem.
12:42:41 <medfly> there's an acronym for "lines of C"?
12:42:51 <kmc_> err i guess it does the xmonad-style recompile-to-config
12:42:59 <kmc_> so that's a problem :/
12:43:00 <Cale> medfly: lines of code
12:43:03 <medfly> oh
12:43:13 <kmc_> greenspun's tenth rule again
12:43:15 <medfly> well, it didn't include the lisp code...
12:43:28 <kmc_> at least they admit it
12:43:58 <Cale> dolio: something in particular?
12:44:31 <dolio> Cale: For instance, he's talking about locally cartesian closed categories, and he's got some example of finding Pi_f : E/A -> E/B, for f : A -> B.
12:45:00 <dolio> Then he says we'll change notation, and says something along the lines of (I can't use different fonts, so I'll use more letters)...
12:45:13 <monochrom> This is the problem with manual use of LaTeX. You miss the forest for the \'s.
12:45:19 <Cale> what page?
12:45:46 <dolio> F = E/B, G = f : A -> B, F/G = E/A. Then he wants Pi_F : F/G -> G, which doesn't seem right, because G = f, a morphism...
12:45:48 <dolio> 207.
12:46:33 <Cale> Which would be Pi_G in your notation
12:46:35 <dolio> And he wants p : X -> G to be a morphism in F/G, but F/G = E/A, and f : A -> B would be in the slice category E/B, not E/A.
12:46:46 <dolio> Right, Pi_G, sory.
12:47:02 <chrisf> @where Awodey
12:47:02 <lambdabot> http://www.math.uchicago.edu/~may/VIGRE/VIGRE2009/Awodey.pdf
12:47:42 <Cale> I think that version of Awodey has different page breaks
12:48:03 <dolio> There was something on page 204 that didn't immediately make sense to me either, when he went from alpha(j) = i to i \in alpha^-1(j).
12:48:06 <Berengal> kmc_: In theory you could. In practice, I'm lazy...
12:48:11 <Cale> http://cale.f10.ca/share/Category%20Theory%20-%20Awodey.pdf
12:49:18 <mreh> how can I document an import explicity but still import everything else?
12:49:24 <dolio> Yeah, I've got a 266 page one, which I think is Cale's copy.
12:49:26 <mreh> oh, I have an idea
12:50:26 <aavogt> yeah, just write two imports
12:50:47 <aavogt> that does trigger warnings on -Wall most likely
12:51:27 <aconbere> when trying to load my package after installing it through cabal I get this odd error
12:51:31 <aconbere> unknown symbol `___stginit_rediszm0zi1_RedisziCommandsziBasic_'
12:51:39 <aconbere> which makes me go "huh?"
12:52:05 <kmc_> aconbere, are you building with --make ?
12:52:07 <mauke> preflex: zdec ___stginit_rediszm0zi1_RedisziCommandsziBasic_
12:52:07 -preflex(n=preflex@95-88-118-220-dynip.superkabel.de)- ___stginit_redis-0.1_Redis.Commands.Basic_
12:52:12 <kmc_> :O
12:52:16 <kmc_> cool
12:52:44 <mauke> preflex: zenc kmc_!n=kmcallis@76.8.64.166
12:52:44 -preflex(n=preflex@95-88-118-220-dynip.superkabel.de)- kmczuznnzekmcallisz40U76zi8zi64zi166
12:52:45 <c_wraith> it really does sound like you're compiling something with ghc, without using --make
12:52:49 <mauke> you are now a symbol
12:52:59 <kmc_> :O
12:53:21 <kmc_> does it do c++filt too
12:53:25 <mauke> no
12:53:27 <kmc_> good
12:53:38 <aconbere> kmc_: I'm just using a simple cabal file I've been using for ages :P
12:53:42 <kmc_> :(
12:54:52 <aconbere> this one is a little different than I've used before
12:54:56 <aconbere> maybe I screwed something up
12:54:59 <aconbere> http://paste.pocoo.org/show/168153/
12:55:00 <Cale> dolio: Yeah, that does seem to be a typo. He wants Pi_F: \mathcal{F}/F \to \mathcal{F}. I don't understand the desire to change notation here.
12:55:15 <BONUS> @botsnack
12:55:15 <lambdabot> :)
12:55:15 <lunabot>  :o
12:55:36 <BONUS> > 1 + 1
12:55:37 <dolio> Cale: Yeah, that one's easy enough to figure out. I'm not sure about p : X -> F, though.
12:55:37 <lambdabot>   2
12:55:48 <aconbere> my thoughts are maybe I should bump my required cabal version
12:55:51 <aconbere> since I'm running 1.8 now
12:55:52 <Cale> Er, also, does this notation even make any sense?
12:55:59 <mreh> :t readFile
12:56:00 <lambdabot> FilePath -> IO String
12:56:55 <roconnor> let e x = foldr gcd 0 [a|a <- [2..x], x `mod` a == 0] in map e [1..]
12:56:57 <roconnor> > let e x = foldr gcd 0 [a|a <- [2..x], x `mod` a == 0] in map e [1..]
12:56:58 <lambdabot>   [0,2,3,2,5,1,7,2,3,1,11,1,13,1,1,2,17,1,19,1,1,1,23,1,5,1,3,1,29,1,31,2,1,1...
12:57:24 <roconnor> > let e x = foldr gcd 0 [a|a <- [1..x], x `mod` a == 0] in map e [1..]
12:57:26 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
12:57:50 <Cale> dolio: I sort of see how the idea is that we're "pulling back" along f to go from E/B to E/A
12:57:57 <MissPiggy> Cale, actually I don't think I understood this bit about bags, is this correct? type Polynomial a = MonoidRing (Bag a) (Product Integer)
12:58:21 <Cale> MissPiggy: Er, just Integer, not Product Integer
12:58:25 <Berengal> wc says: 3556658 total
12:58:35 <MissPiggy> mm
12:58:37 <Berengal> That 3.5MLOC
12:58:46 <MissPiggy> so maybe it should be  MonoidRing Integer (Bag a)?
12:58:50 <MissPiggy> where a will be Complex Rational
12:58:53 <Berengal> Including install scripts, comments, whatnot
12:59:07 <Cale> MissPiggy: Whaaaat
12:59:09 <dolio> I think Cal{F}/F is supposed to relate to slice-of-a-slice-is a slice of the original category.
12:59:18 <MissPiggy> sorry I'm confused
12:59:20 <Cale> MissPiggy: It should be bags of whatever indeterminates you're using
12:59:28 <Cale> MissPiggy: I usually use String values
12:59:48 <MissPiggy> so how do you represent something like  (2/3)x  ?
12:59:51 <Cale> and the other parameter should be the ring of coefficients
13:00:04 <MissPiggy> oh I see
13:00:04 <roconnor> what is a MonoidRing?
13:00:23 <ivanm> roconnor: a ring of monoids?
13:00:25 <ivanm> ;-)
13:00:43 <Cale> roconnor: Like a group ring, but without the requirement that it be a group.
13:00:43 <dolio> In which case, Cal{F}/F is equivalent to E/A, but F still isn't an object in Cal{F}/F or E/A (I think).
13:01:04 <roconnor> what is a group ring?
13:01:22 <sproingie> a groupoid perhaps?
13:01:38 <Cale> Okay, for any ring R and any monoid M, the monoid ring R[M] consists of functions M -> R with finite support and
13:01:49 <Cale> (f + g)(m) = f(m) + g(m)
13:02:03 <Cale> (f * g)(m) = sum over u*v = m of f(u)*g(v)
13:02:16 <xerox> convolution!
13:02:51 <BONUS> @pl \x -> runST $ (readSTRef =<<) $ newSTRef x
13:02:51 <lambdabot> runST . (readSTRef =<<) . newSTRef
13:03:05 <BONUS> hmm, @pl isn't good with rank 2 polymorphism i suppose
13:03:10 <dolio> Oh, wait, p is an object in Cal{F}/F, which means it's a morphism X -> F in E/B. Now I get it.
13:03:48 <Cale> The polynomial ring R[x] is isomorphic to the monoid ring R[N], where N is the natural numbers under addition
13:04:20 <Cale> and, using various monoids, you can get polynomial rings in as many commuting or noncommuting indeterminates as you'd like
13:04:24 <MissPiggy> I did (x^2+y^2)^2 and got [((["x","x","y","y"]),Rational (2 % 1) :+^ Rational (0 % 1)),((["x","x","x","x"]),Rational (1 % 1) :+^ Rational (0 % 1)),((["y","y","y","y"]),Rational (1 % 1) :+^ Rational (0 % 1))]
13:04:40 <MissPiggy> which is correct
13:05:13 <Cale> Seems like you changed the Show instance :)
13:05:27 <Cale> er...
13:06:30 <aconbere> hmmm
13:06:50 <aconbere> what could be going on with stginit when installing with cabal that isn't happening when I just load the libs directly from ghci?
13:07:48 <Cale> Ah, you have your own version of Complex
13:08:05 <Cale> also your own version of Rational?
13:08:20 <MissPiggy> I had to use newtype Rational = Rational Data.Ratio.Rational
13:08:34 <MissPiggy> because I wanted to define some instances on Rational
13:08:35 <Cale> why?
13:08:37 <Cale> oh
13:08:43 <Cale> Which ones?
13:08:53 <MissPiggy> instance Add Rational where zero = Rational 0 ; ...
13:09:08 <Cale> Oh, why did you feel like overriding addition and multiplication again?
13:09:29 <Cale> (also, you could have defined those instances directly for Rational)
13:13:33 <MissPiggy> I think my whole approach to programming in haskell is wrong
13:13:53 <kmc_> what's your approach?
13:14:33 <MissPiggy> prelude causes me a lot of trouble
13:14:48 <jmcarthur> me too, and i don't think i do all that badly
13:15:01 <jmcarthur> the standard library is in need of a major overhaul in my opinion
13:15:30 <Cale> The warts in the Prelude bother me slightly, but the alternative is presently far more painful
13:16:01 <jmcarthur> where the alternative is writing your own prelude?
13:16:03 <Cale> yes
13:16:28 <Cale> Or importing the Prelude hiding a bunch of stuff every time because you defined things with the same names.
13:16:36 <jmcarthur> yeah
13:16:49 <Cale> Just avoid using the names in the Prelude altogether, and things will go more smoothly.
13:16:59 <Berengal> Cale: I've suggested an -XAlternativePrelude=MyPrelude extension...
13:17:07 <CalJohn> I really wish String was ByteString and that functions like read a -> Maybe a
13:17:26 <MissPiggy> the other thing is just having a good feeling of abstract algebra and programming general things from that, so your program is just an instance
13:17:27 <Cale> Berengal: Yeah, I saw that and thought that the treatment on the mailing list was a bit unfair. I think it's a good idea.
13:17:36 <CalJohn> OverloadedStrings and the Safe library work for the minute
13:17:46 <MissPiggy> I don't think I have this skill
13:18:21 <jmcarthur> MissPiggy: i think the standard library doesn't give us enough of these abstractions, myself
13:18:56 <MissPiggy> I hate standard libraries, I will there wasn't one
13:18:57 <jmcarthur> MissPiggy: the skill is gained through experience, mainly
13:19:08 <Berengal> Cale: Heh, only a little bit unfair though. For something like that to be useful it can't be specified in the source files themselves, and having them outside is a bad idea in the general case
13:19:08 <Cale> MissPiggy: Well, when you're writing programs which do abstract algebra, it's more important than in general :)
13:19:15 <monochrom> The problem is the algebraists and the numerical analysts will never agree on what the ideal Prelude number hierarchy should be.
13:19:36 <Cale> Berengal: Perhaps if it was just phrased as a suggestion for a GHC flag, rather than an extension.
13:20:00 <Berengal> Cale: Indeed. I regretted not doing that two seconds after I sent the mail...
13:20:05 <jmcarthur> monochrom: that doesn't mean we shouldn't try
13:20:05 <Cale> monochrom: I consider myself more of an algebraist sort of person, and I think Ring has no place in the Prelude.
13:20:55 <jmcarthur> i have been convinced that the ideal is to use type classes to capture properties, and the idea of "ring" is just a collection of those properties, not necessarily its own type class
13:21:00 <Cale> The various sorts of concepts about what numbers should be from abstract algebra are mostly impractical for real computing, where you have to deal with inaccuracy.
13:21:15 <monochrom> The fun begins when the numerical linear algebra analysts speak up... They are like the best of both worlds.
13:21:22 <MissPiggy> oh we need CHR in the typeclass contexts
13:21:31 <jmcarthur> and things like constraint aliases could be used to create a Ring constraint which is really just the same as applying each of its constraints individually
13:21:48 <jmcarthur> so Ring isn't itself first class
13:21:54 <Berengal> context families :)
13:22:03 <monochrom> They will want Ring for their matrices and they will also want IEEE 754 and NaN for their matrix elements.
13:22:06 <Cale> I think we should keep the name "Num"
13:22:09 <jmcarthur> Berengal: those are two parts of the same coin ;)
13:22:19 <Cale> and possibly split it into Additive and Multiplicative
13:22:25 <MissPiggy> jmcarthur Haskell Type Constraints Unleashed have you seen this
13:22:34 <MissPiggy> <http://www.cs.kuleuven.be/~toms/Research/papers/constraint_families.pdf>
13:22:35 <Cale> However, fromInteger is a lot more elegant/efficient than using one and zero
13:22:44 <jmcarthur> Cale: constraint Num a = Ring a, FromInteger a, etc...
13:22:50 <Berengal> jmcarthur: context families are larger than just aliases though. You could put them in classes and make Set a Monad
13:22:50 <Cale> ?
13:22:51 <jmcarthur> MissPiggy: yes :)
13:23:01 <Cale> Oh, constraint synonyms?
13:23:02 <jmcarthur> Berengal: yes. the aliases are a prerequisite
13:23:13 <jmcarthur> yes, synonyms
13:23:55 <jmcarthur> MissPiggy: i haven't made it public, but in my private branch of alt-stdlib i have been using the authors' preprocessor for those ideas
13:24:05 <MissPiggy> why don't you make it public
13:24:32 <jmcarthur> i simply haven't yet
13:25:03 <jmcarthur> alt-stdlib itself is public already though
13:25:10 <jmcarthur> well, what exists of it
13:25:16 <Berengal> One problem I see with synonyms is that the compiler is more likely to infer the large real constraint instead of the synonym
13:25:25 <jmcarthur> which is basically still completely subject to change and in need of lots of input
13:25:32 <Berengal> Just as it is with type synonyms
13:25:42 <MissPiggy> Berengal you could use CHR to simplify things down for display
13:25:50 <jmcarthur> Berengal: i do not see that as any more of a problem than it is with type synonyms
13:26:07 <jmcarthur> it's not really an abstraction leak, and if it is then you used the wrong language feature
13:26:10 <Berengal> jmcarthur: Well, me neither, but I do see it as a problem with type synonyms alreaduy
13:26:21 <jmcarthur> agreed
13:26:44 <MissPiggy> you lot make me want to design a haskell like language :(
13:27:01 <ivanm> why should you? we already have haskell...
13:27:18 <medfly> it's a nice way to learn?
13:27:24 <Berengal> MissPiggy: You'll only feel sad when we start complaining about the lack of higher order kindpolymorphism :)
13:27:28 <jmcarthur> ivanm: haskell suffers from some sever flaws, in my opinion. still my favorite language though
13:27:45 <ivanm> jmcarthur: well, language design involves compromise
13:27:55 <ivanm> so it's not like we'll ever have a perfect language...
13:28:05 <jmcarthur> ivanm: some of it is compromise, but a lot of it is simply not keeping up with new ideas
13:28:12 <jmcarthur> not that it can be helped
13:28:17 <jmcarthur> it's just good reason for new languages
13:28:36 <Berengal> ivanm: I look at Haskell and I see a language that went up and said "Screw your compromises. I'll have everything, and make it work!" to just about every other language I know
13:28:37 <MissPiggy> what new ideas?
13:29:02 <ivanm> Berengal: *cough* record syntax *cough*
13:29:23 <ivanm> read SPJ's history paper; it admits that the record syntax is a big huge compromise because they couldn't agree on what to do
13:29:25 <jmcarthur> MissPiggy: just all the various extensions, syntactical proposals, etc. in particular, i think we suffer because libraries are not taking advantage of things
13:29:29 <Berengal> ivanm: Well, it's not 100% successful in that regard...
13:29:36 <ivanm> yeah
13:29:51 <Berengal> (But then again, that's the point of Haskell, is it not?)
13:29:57 <ivanm> jmcarthur: well, I've heard researchers bitching about extensions, etc.
13:30:10 <ivanm> as it makes it hard to write tools (e.g. HaRe)
13:30:28 <jmcarthur> ivanm: like i said, that's why new entirely languages are good things
13:30:43 <Berengal> Extensions are by definition just a hack to fix things that weren't thought of in the design of the language
13:30:52 <jmcarthur> exactly
13:31:05 <ivanm> jmcarthur: except then you have to construct an entirely new ecosystem of users, package formats, distribution sites, etc.
13:31:16 <jmcarthur> ivanm: "Avoid success at all costs"
13:31:17 <ivanm> jmcarthur: look at how long it took to get hackage...
13:31:22 <ivanm> true
13:31:34 <jmcarthur> success is part of the reason we are lagging behind, too
13:31:54 <monochrom> By now the head of every source file has language pragmas so HaRe could just read and report "I can't do it".
13:31:54 <jmcarthur> beginning to, i mean
13:31:55 <dino-> But I would rather have the record field name scope warts than not have record style at all.
13:32:44 <ivanm> monochrom: every? really?
13:32:58 <ivanm> you're saying no package puts -fglasgow-exts or something into cabal nowadays?
13:33:11 <Berengal> That's bad practice anyway
13:33:22 <ivanm> monochrom: though I talked to simon thompson and chris brown the other day about it; they're considering switching to ghc for parsing
13:33:48 <ivanm> (they don't think they can use haskell-src-exts because they need extra semantic info it doesn't provide)
13:33:48 <monochrom> OK, only 1% of the source files has language pragmas, OK?
13:33:59 <monochrom> And the 99% can be as well considered bitrotted.
13:34:11 <tensorpudding> > "ping"
13:34:12 <lambdabot>   "ping"
13:34:17 <ivanm> monochrom: I would think that most new libraries that use extensions in the files; but some of them that are version bumps of old packages don't IIRC
13:34:20 <tensorpudding> oh hey, it works
13:34:34 <kmc_> this is a point in favor of "meta-extensions" like Template Haskell; they provide a slightly more structured way to extend the language
13:34:48 <Berengal> Template Haskell isn't structured
13:35:05 <jmcarthur> assuming that the extension is only syntactic...
13:35:05 <kmc_> it's more structured than changing the compiler and the grammar
13:35:17 <kmc_> a tool can skip over TH splices
13:35:23 <Berengal> It requires you to run arbitrary code to get at the real code, which makes parsing it solving the halting problem...
13:35:23 <kmc_> or it can execute them and attempt to process the result
13:35:40 <MissPiggy> Berengal: not really no
13:35:41 <c_wraith> Yeah, TH can't do things like flexible contexts or flexible instances
13:36:01 <kmc_> of course, "static analysis" would have to include compile-time execution
13:36:19 <Berengal> MissPiggy: Assuming you want your parser to be total... and that people will write looping TH code
13:36:26 <kmc_> that's also true with undecidable instances, etc.
13:36:49 <kmc_> jmcarthur, do you mean that TH is only usable for "syntactic extensions"?
13:36:53 <pikhq> Berengal: Eh, it's better than many other languages with compile-time code execution.
13:36:53 <kmc_> i don't really agree
13:36:56 <monochrom> I mean, HaRe does not have to work for 100% of source code. Not even 90% or 70%. If it just works for 1% which hasn't bitrotted, that is good enough. The reality is, like, in an exaggerated form of the 20-80 rule, 1% of source code has 99% importance.
13:37:03 <Berengal> pikhq: That it is
13:37:12 <kmc_> in fact it's not too good for syntactic extensions, because you can't modify the concrete syntax
13:37:16 <kmc_> (or you can a little, with quasiquotation)
13:37:20 <pikhq> *cough*C++*cough*
13:37:48 <jmcarthur> kmc_: okay, i'll just go with "it's only good for a small subset of extensions"
13:37:52 <kmc_> i agree
13:37:59 <medfly> Haskell has too much mindblowing stuff no one understands. it's too big
13:38:16 <jmcarthur> medfly: i disagree. it's just too ad hoc
13:38:20 <PeakerWork> medfly: what? Haskell is pretty small
13:38:20 <kmc_> medfly, i understand every GHC extension, and i'm far from a world expert
13:38:26 <kmc_> Haskell is much much smaller than C++
13:38:30 <Berengal> medfly: You can ignore most of it though. You have a perfectly useable language with just datatypes, functions and HM
13:38:41 <aconbere> AH HA!
13:38:44 <kmc_> and more orthogonal -- the features don't interact as much
13:38:47 <aconbere> I think I have two versions of cabal-install
13:38:49 <PeakerWork> Haskell has a "big" type system, maybe, but if you ignore it, its a very small language :)
13:38:55 <kmc_> haha
13:38:57 <pikhq> medfly: Haskell has a decent handful of mindblowing *libraries* and *extensions.
13:38:59 <medfly> I just said that for no reason. commence arguing!
13:39:01 <pikhq> *
13:39:09 <tensorpudding> Ignoring the type system is hard
13:39:12 <medfly> I don't know most of Haskell :)
13:39:13 <PeakerWork> Haskell98's type system is not that big, maybe
13:39:15 <medfly> I ignore the type system!
13:39:24 <c_wraith> aconbere: that's especially easy to do if you installed haskell platform
13:39:27 <jmcarthur> the type system is not that complicated
13:39:29 <PeakerWork> I haven't implemented it so I can't tell for sure
13:39:44 <Berengal> PeakerWork: HM + type classes, no?
13:40:16 <MissPiggy> What books are there about algebra and algebra algorithms?
13:40:23 <PeakerWork> Berengal: I think so.. If you add the GHC exts it may become somewhat bigger tho
13:40:40 <pikhq> PeakerWork: If you add GHC extensions, it gets to be somewhat sizable.
13:40:44 <kmc_> a lot of the GHC extensions are self-contained syntactic sugar
13:40:45 <pikhq> But still not too bad.
13:40:50 <kmc_> and also a lot of the standardized language is
13:41:06 <Berengal> There aren't that many non-typeclass extensions either. GADTs, type families and rank n types
13:41:11 <kmc_> Haskell does a good job defining sugar in terms of other stuff, rather than introducing three or four incomparable features that do slightly different things
13:41:15 <kmc_> the way C++ does
13:41:21 <PeakerWork> Berengal: type families are kinda type-class related
13:41:29 <PeakerWork> Berengal: rank-n and existentials
13:41:48 <Berengal> PeakerWork: They are, but they have an effect even without type classes in the language
13:41:53 <pikhq> PeakerWork: Still, not a whole lot.
13:41:57 <kmc_> imo, some of the GHC extensions are pretty essential for writing real large programs
13:41:58 <Berengal> existentials wouldn't work without type classes
13:42:01 <kmc_> nah
13:42:05 <Berengal> Well, they'd be useless
13:42:11 <kmc_> i used to think that, but it's not true
13:42:15 <PeakerWork> Berengal: not at all
13:42:16 <quicksilver> Berengal: that's not the case.
13:42:20 <pikhq> kmc_: Such as?
13:42:25 <Berengal> Explain
13:42:27 <quicksilver> Berengal: exists a . (a,IO a, IO (a -> a))
13:42:27 <kmc_> data Showable = forall a. Showable a (a -> String)
13:42:36 <quicksilver> is perfectly using with no classes in sight.
13:42:36 <kmc_> data Showable = forall a. (Show a) => Showable a
13:42:36 <PeakerWork> Berengal: (exists a. TypeClass a => a) vs.  (exists a. (TypeClassMethods a, a))
13:42:42 <MissPiggy> type Showable = String
13:42:45 <kmc_> exactly, there's a correspondance
13:42:46 <jmcarthur> well, Showable might as well be String
13:42:47 <MissPiggy> toShowable = show
13:42:56 <quicksilver> which is why I gave a more interesting one :)
13:42:56 <Berengal> PeakerWork: Oh, true. I've even used something like that...
13:43:00 <kmc_> sure, but you can come up with examples where that's not true
13:43:09 <jmcarthur> yes
13:43:20 <kmc_> existentials are useless if they're a product over *unrelated* types
13:43:31 <monochrom> data LongShowable = forall a. LongShowable { val :: a, method :: a -> String -> String , ... }  just inconvenient.
13:43:33 <kmc_> but you can reuse the same existentially quantified variable
13:43:37 <tibbe> dons: http://blog.johantibell.com/2010/01/scalable-timeout-support-for-ghcs-io.html
13:43:44 <kmc_> they basically express a relationship between types without forcing a single concrete type
13:44:14 <PeakerWork> quicksilver: in your example, you can re-encode something equivalent without existentials (Which I find is always the case with them)
13:44:46 <PeakerWork> I think existentials don't add interesting power
13:44:52 <Berengal> Speaking of extensions, is there a use for datafamilies outside of type classes?
13:45:05 <PeakerWork> But I think rankN-types might, and they give you existentials anyway, pretty much
13:45:16 <PeakerWork> (or rank2)
13:45:46 <kmc_> Berengal, yes
13:45:48 <monochrom> <3 rank n types
13:45:58 <kmc_> "data family Foo a :: *"
13:46:01 <kmc_> TypeFamilies iirc
13:46:17 <PeakerWork> I don't understand why type families add both indexed types and the "family" keyword
13:46:19 <Berengal> kmc_: Please show me. I haven't found something I couldn't do with regular data types
13:46:32 <kmc_> Berengal, with "family"?
13:46:39 <kmc_> you mean that you couldn't do with regular datatypes or with classes?
13:46:39 <Berengal> kmc_: I don't mean the syntax...
13:46:44 <PeakerWork> Berengal: VectorSpace library has a class Vector which has an associated Scalar type
13:46:58 <Berengal> PeakerWork: As a type family or data family?
13:47:04 <PeakerWork> Berengal: I think a type family
13:47:11 <PeakerWork> Berengal: so if (Double, Double) is a Vector, then Double is the Scalar
13:47:22 <Berengal> PeakerWork: Well, type families are obivously useful. I've used them for several things
13:47:26 <PeakerWork> Berengal: oh, ok
13:47:27 <kmc_> i think these extensions are pretty essential: MPTC, fundep, flexible instances, rank-N, existentials, lexical tyvars, generalized deriving.  plus some of the trivial syntax extensions we take for granted
13:47:33 <PeakerWork> Berengal: what were you asking about, data families?
13:47:37 <kmc_> i would like to see asstypes edge out fundeps
13:47:52 <quicksilver> PeakerWork: no you can't
13:47:54 <Berengal> PeakerWork: Yeah, outside of type classes
13:48:01 <PeakerWork> Berengal: Oh, I don't know
13:48:08 <quicksilver> PeakerWork: how would you encode exists a . (a, IO a, IO (a -> a)) ?
13:48:21 <kmc_> Berengal, so you want a use case for "data family" as opposed to either "type family" or associated "data"?
13:48:26 <Berengal> PeakerWork: Essentially I've found them to be regular data types with just a common name...
13:48:38 <Berengal> kmc_: Yep
13:48:52 <kmc_> i think you can always re-cast a data family as an ass-data
13:48:59 <opdolio> quicksilver: Inconveniently.
13:48:59 <kmc_> by inventing a new class
13:49:00 <PeakerWork> quicksilver: Well, the only thing you can do with the left "a" is give it to the IO (a -> a).  So you have two actions.  The latter action can be parameterized on either 0 (initial a) or the result of either action
13:49:03 <jmcarthur> ass-data?
13:49:05 <PeakerWork> quicksilver: its not simple, but its possible
13:49:07 <kmc_> associated data
13:49:16 <quicksilver> PeakerWork: but they're IO actions.
13:49:18 <kmc_> class-associated data
13:49:19 <jmcarthur> i totally read that literally
13:49:23 <kmc_> "asstype" has a better ring to it
13:49:27 <kmc_> but we're being precise now :)
13:49:27 <quicksilver> PeakerWork: they might give different results run at different times
13:49:30 <monochrom> smart associated constructor XD
13:49:31 <PeakerWork> quicksilver: sure, the encoding would also have IO actions
13:49:47 <PeakerWork> quicksilver: Is it ok if I encode (IO a, IO (a -> a)) as a simpler case?
13:49:49 <Berengal> I'd hoped I could write functions of type Foo a -> a, for a data family Foo
13:49:53 <kmc_> Berengal, so if you're looking for a situation where you *can't* use associated "data", i don't think you'll find one
13:49:58 <quicksilver> PeakerWork: sure
13:49:59 <Berengal> It'd obviously be partial, since families are open...
13:50:30 <PeakerWork> quicksilver: uglily: (IO Int, IO (Int -> Int))  (the IO action can have its own memo of Int->a)
13:50:34 * monochrom imagines "data/type communities"
13:50:50 <kmc_> fwiw i have used type families much more than data families
13:51:05 <PeakerWork> quicksilver: I guess since you can fabricate Ints its not quite the same
13:51:05 <Berengal> kmc_: No, I'm looking for a situation where you can't just give your data instances their own names and otherwise have them behave the same
13:51:30 <quicksilver> PeakerWork: no, it's not.
13:51:36 <quicksilver> PeakerWork: you've taken away the abstraction
13:51:44 <jmcarthur> Berengal: well, having separate data families means you can use them in multiple type classes, neither of which requires the other
13:51:44 <quicksilver> PeakerWork: (which is the point of the exists - to abstract the a)
13:52:01 <kmc_> Berengal, data family Map k :: * -> *; lookup :: Map k v -> k -> Maybe v
13:52:14 <kmc_> the data family param and the other function param are linked
13:52:16 <Berengal> jmcarthur: That's true. I hadn't thought of that
13:52:21 <solrize> i wish there was a way to have more than one module in the same source file.  that would make it much less hassle to encapsulate access to data constructors of new types.
13:52:22 <kmc_> now quite often this would live in a class
13:52:27 <kmc_> but it's not in principle required
13:54:12 <Berengal> kmc_: You can't have such a function that doesn't live in a class
13:54:12 <solrize> they should even be nestable.
13:54:12 <kmc_> hmm
13:54:12 <kmc_> that's true
13:54:12 <kmc_> then i will fall back to jmcarthur's point :)
13:54:12 <jmcarthur> Berengal: so for example, i could define data family Elem a for the elements of collections, including things like bytestrings. then i could use that in whatever i want without regard to type class
13:54:12 <PeakerWork> quicksilver: Yeah, since the IO actions can be intertwined with other IO actions I can't just encode all the possible sequences or such.  Yeah, this gives a valuable addition of abstraction, thanks for the example. I finally have my counter example :)
13:54:40 <jmcarthur> well, without some superclass at elast
13:54:42 <jmcarthur> *least
13:55:01 <kmc_> jmcarthur, but your "Elem" case should probably be a type family, not a data family
13:55:03 <Berengal> jmcarthur: Indeed. That does seem useful in some cases
13:55:08 <jmcarthur> kmc_: ah you're right
13:55:15 <kmc_> unless you want to wrap elements for some reason
13:55:25 <kmc_> which is not an obviously crazy idea
13:55:38 <jmcarthur> okay, consider "tags" for constructors as i use in my procrastinating-structures package.
13:55:59 <Berengal> It seems like any data family could be replaced by a regular data type and a type family pointing to it...
13:56:00 <jmcarthur> those might be useful for cases outside of just that library
13:56:08 <kmc_> Berengal, I think that's true
13:56:14 <kmc_> but more syntactic overhead
13:56:23 <jmcarthur> Berengal: it's nice to be able to define the data structure in the type class sometimes though
13:56:27 <Berengal> Or more syntactic flexibility, if you want :)
13:56:37 <Berengal> jmcarthur: Oh, yes, that's definitely useful
13:56:43 <jmcarthur> Berengal: the reason i designed procrastinating-structure the way i did was because it was unlikely that just structures already existed
13:57:12 <Berengal> jmcarthur: I haven't looked at it. Is it interesting?
13:57:18 <quicksilver> PeakerWork: :)
13:57:23 <kmc_> data family IndexOf container :: *; data instance IndexOf [a] = IndexList Int; data instance IndexOf (Map k v) = IndexMap k
13:57:35 <jmcarthur> Berengal: for what is probably a small number of uses, sure
13:57:37 <kmc_> now you can make these abstract
13:57:42 <kmc_> right, that's the key
13:58:00 <kmc_> if you used a type family for non-family data, you'd have less export control, i think
13:58:12 <jmcarthur> Berengal: i'm going to use it to feed pure structures in an FRP implementation with values from IO as the program runs
13:58:30 <jmcarthur> for an example of how it might be useful
13:58:30 <Berengal> jmcarthur: Ah, neat. I'll have a look
13:58:39 <kmc_> or at least, for abstract data, you have to take care to export each of your implementation data without its constructors
13:58:46 <kmc_> with the data family you just export one thing
13:59:08 <jmcarthur> Berengal: the catch, of course, is that you have to be careful how far you evaluate it, otherwise you get _|_
14:00:14 <Berengal> jmcarthur: Is that going to be taken care of in the framework?
14:01:02 <jmcarthur> Berengal: in the frp framework? yes
14:01:32 <jmcarthur> Berengal: it is the responsibility of the client code of procrastinating-structure to avoid evaluating thunks which have been assigned no value yet
14:02:52 <Berengal> jmcarthur: As long as only have to be careful once in the framework, not every time you write a program using it...
14:03:40 <Cale> Oh, wow, so Data.PSQueue is being used in the new GHC I/O manager? :)
14:03:57 <tensorpudding> > (+) <$> Just 5 <*> Just 10
14:03:58 <lambdabot>   Just 15
14:04:07 <jmcarthur> Berengal: right
14:04:09 <mreh> is "really" a nown? http://www.haskell.org/sitewiki/images/1/17/Haskell-wordle-irc.png
14:04:10 <Cale> http://blog.johantibell.com/2010/01/scalable-timeout-support-for-ghcs-io.html :)
14:04:16 <mreh> noun, lol
14:04:31 <jmcarthur> Berengal: the use of procrastinating-structure is an implementation detail to be hidden by the abstraction
14:04:57 <Cale> mreh: It's an adverb.
14:05:02 <monochrom> I may have to yield to pressure and finally embrace $, e.g., fff $ ggg $ \continuation -> do x; y; z
14:05:30 <Cale> Well, there's a verb re-ally :)
14:05:33 <jmcarthur> Berengal: it's really not even that hard to do though. the code that is feeding the values into the pure structures is the same code driving its evaluation. at all times it knows exactly how far it can go
14:05:55 <monochrom> The reason is that in fff (ggg (\continuation -> do x; y; z)) it is unclear where best to put the closing parentheses.
14:06:02 <mreh> Cale: quickly is an adverb
14:06:06 <mreh> anyway :D
14:06:08 <jmcarthur> Berengal: it's just a matter of using only sufficiently lazy algorithms
14:06:21 <Cale> mreh: indeed.
14:06:32 <Cale> (but really is too)
14:06:46 <Berengal> jmcarthur: Indeed. Seems like a nice way of "unwrapping" IO
14:06:48 <mreh> "He is running really"
14:07:04 <mreh> "He is running, really"
14:07:10 <mreh> "He is running." "Really?"
14:07:58 <Berengal> mreh: To me, that picture reads "Just use one type. Think like Haskell"
14:08:01 <Cale> "He is running really." is grammatical, but semantically odd.
14:08:07 <mreh> Should I lump lots of musical libraries into one super library?
14:08:48 <mreh> they're all kind of relevant, but they could stand alone, I just wrote them all at the same time
14:09:05 <gwern> mreh: I'd lump together
14:09:08 <gwern> less administrivia
14:09:22 <monochrom> Until then, please enjoy! http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=6356#a6448
14:09:23 <mreh> gwern, lazy distribution
14:10:12 <monochrom> But it is a bit said that moonpatio receives quite a share of spam.
14:10:14 <mreh> it's going to take some work to get these libraries up to standard first, documentation and layout what not
14:10:17 <monochrom> s/said/sad/
14:11:01 <mreh> does anyone in the civilised world still work on a 80x24 screen?
14:11:27 <jmcarthur> i work on a 80xover9000 screen
14:11:30 <c_wraith> when I play nethack
14:11:53 <mreh> jmcarthur: I'd like to see that
14:11:57 <Zao> mreh: Active work area, quite possibly 80, sometimes narrower.
14:12:16 <jmcarthur> mreh: the point is i tend to stick within 80 cols
14:12:21 <Zao> There's always auxillary things you want to see; file listings, output, docs, etc.
14:12:31 <mreh> so I have to reformat my code to fit in 80 columns
14:12:49 <c_wraith> I edit in an 80 col window.
14:13:01 <c_wraith> My terminals are bigger than that, though, since not everyone is so kind
14:13:40 <jmcarthur> i don't even mind when people go >80 as long as they follow some given upper bound
14:13:40 <dolio> monochrom: At least the spam correctly fills in the name and title fields.
14:14:01 <mreh> do you prefer code to fit in those 80 cols? I'll just do it for the sake of backwards compatibility
14:14:04 <jmcarthur> i will gladly resize by editor to 120 columns if i can be assurred that that is large enough
14:14:10 <jmcarthur> *my editor
14:14:30 <Berengal> I have one 30'' screen and a secondary 19'' (I think). I've also made sure the menues and bars on anything I work with are as small as possible
14:14:31 <idnar> the fact that your display is 500 columns wide doesn't necessarily mean that you want to read lines that long
14:14:47 <idnar> longer lines are harder to read
14:14:48 <c_wraith> Reading long lines tends to be tougher, anyway.  I think 80 cols is a reasonable limit, for the sake of readability
14:14:57 <jmcarthur> agreed
14:15:09 <idnar> as a side benefit, I can put more code side-by-side if the line length is limited
14:15:14 <monochrom> dolio: I think any dumb html parser can do that. I can write one with hxt real quick...
14:15:35 <dolio> Human beings can't, though, apparently.
14:15:35 <Berengal> For example, I don't have a output pane open by default.
14:15:50 <mreh> pattern matching on a record eats up the characters
14:16:26 <kmc_> damn, Uniplate is sexy
14:16:34 <monochrom> See, the problem with html form is that the computational problem "where is the submit url" is so bloody computable.
14:16:42 <kmc_> i like this generic programming stuff
14:17:06 <kmc_> because it illustrates the approach of "identify design patterns, then eliminate them using smart libraries"
14:17:18 <kmc_> rather than "identify design patterns, then write a book about how great they are"
14:17:54 <monochrom> Human beings can do it, but they are too proud of themselves to.
14:17:54 <dolio> None of the Haskell libraries for it has ever struck me as very satisfying.
14:18:06 <kmc_> monochrom, outsource it to MTurk
14:18:09 <MissPiggy> I like Andreas' stuff
14:18:17 <dolio> The stuff in the new Epigram makes me more excited.
14:18:21 <MissPiggy> and you can do basic generic programming yourself with GADTs
14:20:30 <dolio> I haven't really looked at the new-ish one involving fixed points.
14:20:37 <Berengal> Design patterns always struck me as a flaw in the target language...
14:20:48 <dolio> But defining datatypes with fixed points isn't very well supported in Haskell.
14:20:49 <Berengal> You have a pattern already, why can't you automate the thing?
14:21:13 <gwern> I wonder how much one could make on mechanical turk; for teens, it'd be better than flipping burgers even if it paid less
14:21:45 <monochrom> I wait for the day when "I'm editing plain text file" means: 1280 columns, 1024 rows, one pixel for one character, each character is mapped to a colour for its pixel. You may be able to view and edit the whole of GHC this way.
14:22:05 <Berengal> > 1280*1024
14:22:06 <lambdabot>   1310720
14:22:31 <gwern> monochrom: what on earth?
14:22:36 <kmc_> Berengal, right.  every language has these flaws, but I think there's a big difference between the language communities that try to eliminate them one by one, and the communities that embrace them
14:23:04 <Berengal> kmc_: Indeed. And then there's language communities that try to eliminate all of them in as few steps as possible...
14:23:18 <kmc_> yeah, that's better
14:23:19 <jmcarthur> i just wish function definitions didn't have to be one-over-the-other. why can't i just put them side by side on the same lines?
14:23:30 <kmc_> type classes were a huge unexpected success in this way
14:23:53 <kmc_> you might say the same about C++ templates, but i think they create more problems than they solve
14:24:25 <Berengal> kmc_: C++ and perl belongs in the one-by-one camp, I think. I don't have much experience with the languages, but that's the general attitude I've gotten from those who have
14:24:38 <monochrom> gwern: Editor and source file screen width.
14:24:54 <gwern> eyes can't even saccade that many columns...
14:25:04 <kmc_> yeah, Perl is flexible enough to capture most patterns as a library
14:25:07 <monochrom> Then consider it satire.
14:25:08 <kmc_> and can even redefine its concrete syntax
14:25:30 <Berengal> Also LISP
14:25:32 <kmc_> i think C++ is firmly in the camp of "embrace the repetition and write books about it"
14:25:57 <Berengal> Though lisp basically tells its users to "go forth and write new languages"
14:26:05 <jmcarthur> i remember a time that the Io language's *parser* was written in Io itself
14:26:29 <jmcarthur> it's dynamically typed and interpreted
14:26:33 <elspru> is there a showBinary like there is a showHex?
14:26:38 <Berengal> kmc_: C++ does have lots of "features" that eliminate spesific patterns though
14:26:43 <p_l> Berengal: A lisp programmer replaces God with a macro on the seventh day of Genesis ;-)
14:27:20 <elspru> i'm trying to convert from integer to base 4
14:27:25 <monochrom> But God did nothing on the 7th day. So, the macro does nothing too?
14:27:57 <LeNsTR> lols  (-:
14:28:24 <Berengal> So the apocalypse is just a type-error waiting to happen?
14:28:28 <p_l> monochrom: it was optimizing him out
14:28:32 <xerox> > showIntAtBase 2 ("01"!!) (2^6-1) "" -- elspru
14:28:33 <lambdabot>   "111111"
14:28:46 <p_l> Berengal: St. John didn't notice (unwind-protect ...) ;P
14:29:03 <elspru> > showIntAtBase 4 0x34
14:29:04 <lambdabot>   No instance for (GHC.Num.Num (GHC.Types.Int -> GHC.Types.Char))
14:29:04 <lambdabot>    arising ...
14:29:19 <Berengal> p_l: Also, any programmer worth his salt would've recognized the pattern on the third day :P
14:29:24 <elspru> > showIntAtBase 4 0x34 ""
14:29:24 <lambdabot>   No instance for (GHC.Real.Integral [GHC.Types.Char])
14:29:25 <lambdabot>    arising from a use ...
14:29:30 <xerox> > showIntAtBase 2 ("0123"!!) 0x34 ""
14:29:31 <lambdabot>   "110100"
14:29:35 <p_l> Berengal: the programmer got created on the sixth
14:29:36 <xerox> > showIntAtBase 4 ("0123"!!) 0x34 "" -- pardon
14:29:37 <lambdabot>   "310"
14:29:41 <monochrom> > showIntAtBase 2 intToDigit 42 ""
14:29:42 <lambdabot>   "101010"
14:29:54 <elspru> > showIntAtBase 4 ("0123") 0x34 ""
14:29:54 <lambdabot>   Couldn't match expected type `GHC.Types.Int -> GHC.Types.Char'
14:29:55 <lambdabot>         agai...
14:30:10 <elspru> > showIntAtBase 4 ("0123"!!) 0x34 ""
14:30:11 <lambdabot>   "310"
14:30:19 <xerox> elspru you can't omit parts and hope for it to work :)
14:30:43 <elspru> i've only a vague notion of how it works
14:30:53 <kmc_> > unwords . map (showIntAtBase 4 ("GATC"!!)) $ fix ((0:) . scanl (+) 1)
14:30:54 <lambdabot>   Couldn't match expected type `GHC.Base.String'
14:30:54 <lambdabot>         against inferred typ...
14:30:56 <monochrom> :t showIntAtBase
14:30:57 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
14:31:03 <kmc_> > unwords . map (pure . showIntAtBase 4 ("GATC"!!)) $ fix ((0:) . scanl (+) 1)
14:31:04 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
14:31:04 <lambdabot>         against inferred type...
14:31:09 <monochrom> The type will give you more concrete notions.
14:31:29 <elspru> > showIntAtBase 4 ("drgb"!!) 0x34 ""
14:31:30 <lambdabot>   "brd"
14:31:36 <monochrom> This is not python and you can't expect to randomly mutate parameters to find how it works. Intelligent design, no evolution.
14:32:04 <kmc_> > unwords . map (\n -> showIntAtBase 4 ("GATC"!!) n "") $ fix ((0:) . scanl (+) 1)
14:32:05 <lambdabot>   "G A A T C AA TG CA AAA TGT CAC AATA TAGG CTTA AACTA TATGT CCATC ATGCCA TTG...
14:32:19 <sinelaw> preflex, seen PeakerWork
14:32:20 -preflex(n=preflex@95-88-118-220-dynip.superkabel.de)- PeakerWork was last seen on ##c 35 minutes and 49 seconds ago, saying: gionnico: that's not a very good sorting algorithm
14:32:22 <sinelaw> preflex, seen Peaker
14:32:22 -preflex(n=preflex@95-88-118-220-dynip.superkabel.de)- Peaker was last seen on #haskell 12 hours, 36 minutes and 25 seconds ago, saying: I like the new "Practical language" instead of "Functional language" :)
14:32:26 <kmc_> monochrom, har har ;)
14:32:28 <elspru> > map (showIntAtBase 4 ("drgb"!!) "") (map (ord) (words "hello world"))
14:32:29 <lambdabot>   Couldn't match expected type `GHC.Base.String'
14:32:29 <lambdabot>         against inferred typ...
14:32:33 <xerox> That is, @djinn doesn't use genetic algorithms
14:32:46 <mreh> heh, I told my class that evolutionary computation seems to support ID more rather than natural selection
14:32:47 <elspru> > map (showIntAtBase 4 ("drgb"!!) "") (map (ord) ("hello world"))
14:32:47 <idnar> heh
14:32:48 <lambdabot>   Couldn't match expected type `GHC.Base.String'
14:32:48 <lambdabot>         against inferred typ...
14:32:51 <gwern> sinelaw: guess haskell isn't peaker's money language
14:33:03 <kmc_> > unwords . map (\n -> showIntAtBase 4 ("GATC"!!) n "") $ iterate (*2) 1
14:33:04 <lambdabot>   "A T AG TG AGG TGG AGGG TGGG AGGGG TGGGG AGGGGG TGGGGG AGGGGGG TGGGGGG AGGG...
14:33:06 <mreh> I was not popular
14:33:15 <sinelaw> gwern, ???
14:33:30 <gwern> sinelaw: since it's peaker|work in #c and peaker in #haskell
14:33:30 <elspru> > map (ord) "hello"
14:33:31 <lambdabot>   [104,101,108,108,111]
14:33:32 <gwern> get it
14:33:44 <sinelaw> oh
14:33:50 <sinelaw> :)
14:34:08 <elspru> > map (\x -> showIntAtBase 4 ("drgb"!!) x "") (map (ord) (words "hello world"))
14:34:09 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
14:34:09 <lambdabot>         against inferred type...
14:34:37 <kmc_> > unwords . concatMap (\n -> showIntAtBase 4 (words ":) :( :O :P" !!) n "") $ fix ((0:) . scanl (+) 1)
14:34:38 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
14:34:38 <lambdabot>         against inferred type...
14:34:42 <kmc_> :t showIntAtBase
14:34:43 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
14:34:51 <kmc_> bah, that could be more general ;P
14:35:26 <elspru> > map (\x -> showIntAtBase 4 ("drgb"!!) x "") [34,33]
14:35:27 <lambdabot>   ["gdg","gdr"]
14:35:44 <elspru> > map (\x -> showIntAtBase 4 ("drgb"!!) x "") (map ord "hello")
14:35:45 <lambdabot>   ["rggd","rgrr","rgbd","rgbd","rgbb"]
14:35:48 <kmc_> > unwords . map (( words ":) :( :O :P" !!) . read . (\n -> showIntAtBase 4 ("0123"!!) n "")) $ iterate (*2) 1
14:35:49 <lambdabot>   ":( :O * Exception: Prelude.(!!): index too large
14:36:41 <elspru> > map (\x -> showIntAtBase 4 ("bRGB"!!) x "") (map ord "hello world! of high density paper and ceramic printing")
14:36:41 <lambdabot>   ["RGGb","RGRR","RGBb","RGBb","RGBB","Gbb","RBRB","RGBB","RBbG","RGBb","RGRb...
14:37:07 <elspru> excellent
14:37:47 <elspru> > map (\x -> showIntAtBase 4 (["0 0 0","1 0 0","0 1 0","0 0 1"]!!) x "") (map ord "hello world! of high density paper and ceramic printing")
14:37:47 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
14:37:48 <lambdabot>         against inferred type...
14:38:03 <elspru> oh well
14:38:24 <dolio> GHC.Types.Char... haven't seen that one before.
14:39:36 <mreh> can this be refactored? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16412#a16412
14:39:37 <monochrom> No wonder someone said type synonym is abstraction leak.
14:40:23 <kmc_> mreh, eek
14:40:39 <mreh> kmc_ don't be afraid
14:40:49 <dolio> Yes, it can.
14:40:52 <kmc_> mreh, write a function that does what each "do" case does
14:41:04 <c_wraith> mreh: this is not your biggest issue, but "foo >> return x" can be rewritten as "x <$ foo"
14:41:24 <mreh> heh
14:41:26 <monochrom> mreh: Note that there must be some numerical correlation between Char's and your note type if you make it Enum.
14:41:36 <kmc_> then use map or zipWith to apply it
14:41:41 <kolmodin> tibbe: really good work lately with the event library. also great blog post today! much joy to read it :)
14:41:47 <kmc_> and msum over that
14:41:55 <tibbe> kolmodin: thanks :)
14:41:58 <kmc_> which has the effect of gluing them together with <|>
14:42:22 <kolmodin> tibbe: have you heard anything of when it might go into ghc?
14:42:26 <mreh> kmc_ so <|> = msum?
14:42:30 <kmc_> no
14:42:38 <kmc_> msum [a,b,c,d] = a <|> b <|> c <|> d
14:42:43 <kmc_> in this case
14:42:46 <kolmodin> tibbe: I guess you're not done yet... :)
14:43:06 <mreh> msum = foldr1 <|>
14:43:09 <tibbe> kolmodin: no date set yet. We need solid benchmark to prove improvements in all areas and then debugging and testing to make sure we get all the tricky corner cases
14:43:17 <PeakerWork> @src msum
14:43:17 <lambdabot> msum =  foldr mplus mzero
14:43:18 <tibbe> kolmodin: right :)
14:43:23 <kmc_> it's defined in terms of MonadPlus
14:43:27 <kmc_> which will coincide with <|> for Parsec
14:43:41 <kmc_> mreh, why not introduce another datatype for accidentals
14:43:49 <kolmodin> tibbe: will it be able to go into the 6.12 branch, or will it have to wait for 6.14?
14:43:54 <mreh> kmc_ it's haskore
14:43:55 <kmc_> make a parser for a natural note, then another for an accidental
14:44:03 <kmc_> and a function to combine them
14:44:07 <kmc_> (which is not parsing-related)
14:44:15 <tibbe> kolmodin: I don't really know. I don't know Simon's feelings on the topic.
14:44:34 <mreh> kmc_ there is a parser already, well a "readNote" function that is :: String -> Note
14:44:47 <tibbe> kolmodin: it's not an API change so theoretically it could go in 6.12. I think it would have to be behind a command line flag though
14:44:48 <kolmodin> tibbe: right, I thought there might be some kind of policy about this
14:45:02 <kolmodin> tibbe: since it's a big change, aye
14:45:19 <tibbe> kolmodin: while I have you on the hook. do you mind sending me the continuation experiment you did for Data.Binary? I'd like to take a look at the core. I might have an idea on how to improve things
14:46:03 <tibbe> kolmodin: did you use a data type like: data Result a = Cont (ByteString -> Result a) | Done a ?
14:46:14 <kolmodin> tibbe: right, I don't recall how far I got with that project. not sure I ever published anything
14:46:22 <tibbe> kolmodin: sure
14:46:25 <mreh> kmc_ could you write what you mean? I can't parameterise it easily
14:46:29 <kmc_> mreh, sec
14:46:29 <kolmodin> tibbe: I found that several binary clone packages already implemented what I did
14:46:33 <tibbe> kolmodin: might be faster if I have a base to start from
14:46:37 <tibbe> kolmodin: ah ok
14:46:39 <kolmodin> tibbe: sure
14:46:50 <kolmodin> tibbe: I'll look and see where I left off...
14:46:53 <tibbe> kolmodin: but I remember that you benchmarked something?
14:46:59 <tibbe> kolmodin: great, thanks
14:47:19 <tibbe> kolmodin: perhaps we could hack on it during ZuriHac if I'm done with event by then
14:47:19 <kolmodin> yes, very simple benchmarks. it showed worse performance than the original binary
14:47:41 <kmc_> mreh, is your Pitch.Class type a member of Enum?
14:47:42 <kolmodin> tibbe: but with the avantage of better control
14:47:50 <kmc_> such that (succ A) = As, and (pred A) = Ab?
14:47:50 <tibbe> kolmodin: I believe you can convert the library to continuation style without using any data structures (which hurt performance)
14:47:59 <kmc_> that'd be most convenient
14:48:01 <Alpounet> damn
14:48:02 <tibbe> kolmodin: yes, you get proper error handling
14:48:40 <mreh> kmc_ deriving (Eq,Ord,Ix,Enum,Show,Read)
14:49:04 <kolmodin> tibbe: right. error handling, better control of consumption. I'm also thinking of partial results
14:49:05 <kmc_> mreh, is the order right?
14:49:21 <tibbe> kolmodin: it would be great if we could resolve this issue (at least know if it's possible) so we can put binary in the HP
14:49:22 <mreh> kmc_ I suspect that the succ of As is Gf
14:49:27 <mreh> kmc_ yes
14:49:39 <mreh> kmc_ http://hackage.haskell.org/packages/archive/haskore/0.1/doc/html/src/Haskore-Basic-Pitch.html#Class
14:49:45 <kolmodin> tibbe: iirc I ripped out the original Data.Binary.Get and replaced it with a partial implementation
14:49:56 <tibbe> kolmodin: ok
14:49:56 <kmc_> ah
14:49:58 <kmc_> cool
14:50:15 <kolmodin> tibbe: for HP I think we should review the interface too. it has a lot of junk
14:50:47 <Alpounet> I gotta try the new event manager
14:50:50 <tibbe> kolmodin: what you can do instead of returning e.g. a `Cont k` when you need more data is to call a function: ((ByteString -> a) -> a), passing it a continuation. That way you don't have to construct/deconstruct the Cont value
14:50:53 <tibbe> kolmodin: agreed
14:51:22 <kmc_> @undo do { x <- a; f <- b; return (f x) }
14:51:23 <lambdabot> a >>= \ x -> b >>= \ f -> return (f x)
14:51:29 <kmc_> @pl a >>= \ x -> b >>= \ f -> return (f x)
14:51:29 <lambdabot> (`fmap` b) . flip id =<< a
14:52:05 <kmc_> :t (<$)
14:52:06 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
14:52:38 <kolmodin> tibbe: I don't think the "suspend/I need more data" operation is too costly, it doesn't happen very often in comparison to how often it reads a value
14:52:58 <tibbe> kolmodin: did that make sense? each function would get passed an extra argument: onCont :: ((ByteString -> a) -> a), instead of returning a Cont (ByteString -> a)
14:53:02 <monochrom> How worse does the benchmark say?
14:53:12 <kmc_> :t liftM ($)
14:53:13 <lambdabot> forall a b (m :: * -> *). (Monad m) => m (a -> b) -> m (a -> b)
14:53:14 <kolmodin> tibbe: ah, maybe I missunderstood you
14:53:15 <tibbe> kolmodin: that's true, I wonder why it's slower in that case
14:53:18 <kmc_> :t liftM (flip ($))
14:53:19 <lambdabot> forall a1 b (m :: * -> *). (Monad m) => m a1 -> m ((a1 -> b) -> b)
14:53:36 <kmc_> :t liftM2  (flip ($))
14:53:37 <lambdabot> forall a1 b (m :: * -> *). (Monad m) => m a1 -> m (a1 -> b) -> m b
14:55:54 <kmc_> mreh, something like this? not tested:  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16412#a16414
14:55:58 <kmc_> (double pasted by accident, sorry)
14:56:20 <mreh> visualising hackage broke my computer
14:56:22 <mreh> hang on
14:56:25 <kmc_> hehe
14:56:47 <temoto> Is there a way to parse infix `if` in parsec?
14:56:58 <temoto> as in f = 10 if b else 20
14:57:18 <kmc_> temoto, ah, the problem is that you first recurse on the expression parser and this causes infinite descent?
14:57:26 <temoto> kmc_: yes.
14:57:40 <c_wraith> parsers that aren't parsec can do that. >_>
14:57:54 <mreh> kmc_ that's what you meant
14:57:55 <mreh> thanks
14:58:07 <kmc_> mreh, i had to tune my own ideas in writing it
14:58:12 <kmc_> wasn't quite what i said initially
14:58:19 <temoto> "look ahead" is written many times in parsec documentation but i couldn't come up with a solution.
14:58:22 <mreh> kmc_ I was a bit confused :)
14:58:34 <kmc_> you don't need a datatype for accidentals, because the type (Enum a) => a -> a already exists :)
14:58:58 <kmc_> also, i switched to Applicative style
14:59:12 <kmc_> but that's not essential -- the monadic style would be about the same length
14:59:23 <monochrom> temoto: Something like this? parseExpr; keywordIf; parseExpr; keywordElse; parseExpr
14:59:32 <MissPiggy> Cale I'm sorry to bug you but want to ask one more thing
14:59:39 <kmc_> monochrom, parseExpr = do { parseExpr; ... }
14:59:40 <Cale> MissPiggy: Sure
14:59:44 <kmc_> that's infinite recursion
14:59:46 <monochrom> Oh!
15:00:04 <MissPiggy> Cale, just wondering if you know any books or texts or whatever that I could learn a bit more of the algorithms for abstract algebra?
15:00:15 <kmc_> this is one of those situations where i'd start changing the order of cases
15:00:16 <Cale> I haven't read any myself
15:00:24 <temoto> monochrom: yes, like that.
15:00:32 <temoto> monochrom: but working.
15:00:37 <kolmodin> tibbe: darcs get http://haskell.org/~kolmodin/code/binary-push/
15:00:41 <monochrom> parseExpr = do { <what you normally have here>; optional keywordIf; parseExpr; keywordElse; parseExpr }
15:00:50 <monochrom> err
15:00:53 <lispy> MissPiggy: algorithms for abstract alg?
15:00:55 <hiptobecubic> I have a real task that i can finally justify learning some haskell for :D
15:00:59 <monochrom> parseExpr = do { <what you normally have here>; optional (do { keywordIf; parseExpr; keywordElse; parseExpr } )}
15:01:02 <MissPiggy> lispy yes
15:01:04 <kolmodin> tibbe: I just recorded what I had and copied the files to the non-darcs-2 server haskell.org :)
15:01:16 <temoto> monochrom: <what you normally have here>=parseExpr. That's the problem.
15:01:16 <lispy> MissPiggy: Sorry, I don't understand the statement
15:01:26 <kolmodin> tibbe: but it should at least be good enough to get the files from... not to push to though :/
15:01:30 <lispy> MissPiggy: could you expand or clarify?
15:01:51 <tibbe> kolmodin: that's good enough, which benchmark did you run?
15:02:23 <kolmodin> tibbe: tests/Benchmark.hs
15:02:26 <monochrom> Gosh. OK, suppose I ask you to rid your grammar of infix if. What does your parser look like? I mean you don't get what I mean by <what you normally have here> so you have to show me actual code so I can show you actual code.
15:02:37 <monochrom> Gosh, template programming over IRC is so hard.
15:02:40 <kolmodin> tibbe: you can run it with "make bench" in tests/
15:02:57 <kolmodin> tibbe: (after you have registered the package)
15:03:03 <tibbe> kolmodin: ok, do you remember how much slower it was? (I won't have time to look at this in the next few weeks but when I do it would be nice to know here to start)
15:03:17 <sinelaw> hiptobecubic, which is?
15:03:24 <kolmodin> tibbe: no exact numbers, no
15:03:48 <kolmodin> tibbe: but you should be able to compile the current version I uploaded, unless I've done something stupid after I benchmarked
15:03:51 <MissPiggy> lispy, for example long division of polynomials, computations with ring moniods or knuth-bendix
15:04:02 <hiptobecubic> sinelaw, i thought you'd never ask \o/   I have a 277 meg file of words that i need to sort by frequency and remove duplicates
15:04:10 <tibbe> kolmodin: ok
15:04:40 <solrize> hah, firefox javascript now has parallel garbage collection
15:04:43 <lispy> MissPiggy: Hmm...I wonder if any one has written a book like that.  I would assume many of those are discussed in research papers.
15:04:53 <temoto> monochrom: http://codepad.org/JXfBpVYM
15:05:13 <lispy> MissPiggy: And likely Knuth has documented his algorithm in his series the art of computer programming, but I'd have to check
15:05:18 <temoto> monochrom: i removed infix if and it works fine. But if possible, i'd like to leave it back.
15:05:36 <MissPiggy> I think I just need to have studied much more
15:06:02 <Alpounet> MissPiggy, reading papers/articles and practice are the key
15:06:15 <gwern> so, yesterday or so, I made a wiki account for a Djikstra
15:06:22 <kolmodin> tibbe: in twitter I wrote the Nov 18th: Naive optimization of "push style binary package" gives 1/3 of the performance of the original package... hmm... what's next?
15:06:26 <gwern> I was tempted to ask whether he was any relation
15:06:28 <sinelaw> hiptobecubic, I know it's not what you need, but: cat myfile | sort -u
15:06:32 <kolmodin> tibbe: but that might not have been the final version you got
15:06:37 <sinelaw> will at least do the unification
15:06:42 <tibbe> kolmodin: hmm, interesting
15:06:52 <sinelaw> (assuming one word per line)
15:07:00 <tibbe> kolmodin: seems like some big optimization fails for some reason, perhaps the fusion
15:07:05 <hiptobecubic> sinelaw, and make it impossible to do the frequency.
15:07:08 <kolmodin> tibbe: and iirc it was differently slow depending on the size of the data you read (ie. word8, word16, etc)
15:07:13 <sinelaw> hiptobecubic, yes.
15:07:16 <sinelaw> :\
15:07:20 <kolmodin> tibbe: right, I never looked into it properly
15:07:31 <kolmodin> tibbe: tried to analyze the Core, but gave up :D
15:08:08 <MissPiggy> I don't have any papers to read
15:08:13 <tibbe> kolmodin: yeah, the core for binary is tough
15:08:17 <tibbe> kolmodin: lots of inlining
15:08:23 <sinelaw> hiptobecubic, my first haskell program (only a about month ago) was something similar. I parsed a textual database of word pronounciations into a dictionary, allowing you query for a word's pronounciation
15:08:33 <sinelaw> *pronunciation
15:08:40 <temoto> MissPiggy: wanna links to papers?
15:08:47 <MissPiggy> ok
15:08:50 <temoto> MissPiggy: http://research.microsoft.com/en-us/um/people/simonpj/Papers/marktoberdorf/mark.pdf
15:08:51 <kolmodin> tibbe: right, a lot probably got inlined. although we removed a lot of inlining because ghc was smarter than we were
15:09:03 <temoto> MissPiggy: http://conal.net/papers/type-class-morphisms/type-class-morphisms-long.pdf
15:09:13 <MissPiggy> thanks
15:09:49 <temoto> MissPiggy: http://math.ucr.edu/home/baez/rosetta.pdf
15:10:04 <MissPiggy> temoto, that rosetta one is too difficult for me
15:10:11 <kolmodin> tibbe: also, there is no fusion any more, no rules to do clever things. I think that was to hard or something... I got quite surprised to see that we commented them out, I thought we had something at least. in the darcs changelog we didn't write why we removed all rules
15:10:12 <MissPiggy> I've seen it before
15:10:16 <temoto> MissPiggy: yeah for me too :)
15:10:50 <temoto> MissPiggy: i also recommend Tangible Functional Programming video on youtube.
15:10:55 <tibbe> kolmodin: right, dcoutts seemed surprised as well when I pointed out they were gone
15:11:13 <kolmodin> tibbe: aye. I thought they were very clever
15:11:27 <kolmodin> tibbe: and I can't remember exactly why we did that
15:11:45 <tibbe> kolmodin: it's a mystery. Python programmers hacked the server and removed it ;)
15:12:35 <kolmodin> tibbe: and we're very far from the performance of C, as you will see in the benchmark. the benchmark first tries throughput in C, then the exact same in haskell, then tries to do similar things with the binary package
15:12:50 <kolmodin> tibbe: I'm sure they did :)
15:12:58 <Cale> tibbe: So the IO manager is using PSQueue now?
15:13:10 <monochrom> temoto: unchecked and untested by I'm over-confident: http://codepad.org/40IVbBMT
15:13:43 <monochrom> s/by/but/
15:13:55 <monochrom> though "by" is not wrong either ha
15:14:09 <tibbe> Cale: the data structure yes, although not the exact implementation in the library with the same name
15:14:19 * tibbe has some ideas how the library can be made faster
15:14:41 <kolmodin> tibbe: great! :)
15:14:51 <Cale> tibbe: Ah, you're adjusting the implementation? Any reason not to contribute back to the library?
15:15:33 <tibbe> Cale: some of it can be contributed back. some are specialization that makes the library less general (unless it's reimplemented with associate data types)
15:15:40 <Cale> ah, okay
15:16:25 <tibbe> Cale: making the tree strict in the subtrees should be a no-brainer. Inlining tourView manually everywhere should give another 20-30%
15:16:26 <monochrom> tibbe: I'm also interested in continuation-style suspendible parsing and how to make them fast. Let me know your wild suggestions!
15:16:58 <tibbe> monochrom: nothing clever. one can avoid constructing/deconstructing some values
15:17:08 <tibbe> monochrom: it's pretty straightforward
15:18:08 <hiptobecubic> sinelaw, so......... in python i trashed 2gb of ram before it finished reading the file into my data structure
15:18:24 <tibbe> monochrom: I have an old version of such a parser at http://github.com/tibbe/hyena
15:18:47 <hiptobecubic> sinelaw, i assume there will be a better way to handle this in haskell
15:18:49 <lispy> hiptobecubic: I've done that with python too.  Rewrote in Haskell and saved time and memory :)
15:18:56 <monochrom> hiptobecubic: heh in haskell you may trash 20gb of ram <duck>
15:19:10 <sinelaw> hiptobecubic, if anything, haskell is more prone to space leaks than python
15:19:13 <kolmodin> tibbe: the constructor "HereItIs a" actually only gets created exactly once, and then only one "NeedMore cont" for each time it needs something more
15:19:29 <sinelaw> hiptobecubic, but i guess your basic algorithm could be better
15:19:43 <tibbe> kolmodin: you could avoid the NeedMore altogether
15:20:01 <tibbe> kolmodin: by passing in a function of the type I gave above
15:20:16 <hiptobecubic> i was using a big dictionary with the word as key and incrementing value each time
15:20:17 <tibbe> kolmodin: instead of returning NeedMore you call that function
15:20:26 <kolmodin> tibbe: ah, I see what you mean
15:20:44 <kolmodin> tibbe: but even without ever using that constructor it's still slow (I think)
15:20:47 <monochrom> tibbe: Haha, like church encoding? Don't use Either, use more continuations?
15:20:54 <tibbe> kolmodin: not as nice a programming model perhaps, but works for the lowest common layer
15:21:00 <tibbe> monochrom: yes
15:21:09 <sinelaw> hiptobecubic, hmm
15:21:12 <tibbe> monochrom: in theory GHC should do it for us
15:21:18 <Saizan> hiptobecubic: you've to make sure the increment is evaluated strictly
15:21:28 <sinelaw> Saizan, in python.
15:21:38 <kolmodin> tibbe: I much liked the NeedMore constructor, but maybe it's not strictly required
15:21:38 <sinelaw> hiptobecubic, how many distinct words does that file have?
15:21:44 <Saizan> ah, then it's easy _)
15:21:49 <hiptobecubic> Saizan, ? starting from 0 and doing += 1 each time.
15:21:54 <tibbe> kolmodin: it might not hurt performance, we need to measure
15:21:57 <hiptobecubic> sinelaw, not sure, probably tens of millions?
15:22:01 <hiptobecubic> :D
15:22:07 <sinelaw> hiptobecubic, what language is that?
15:22:11 <hiptobecubic> let me check with sort
15:22:22 <sinelaw> make sure to use the -u flag
15:22:23 <kolmodin> tibbe: if you're reading from a socket (for example), wouldn't that put your "runGet" in the IO monad?
15:22:24 <monochrom> tibbe: But supposedly since GHC 6.6 or something, such use of Either and Done/NeedMore is much less problematic. They introduced "tagging", meaning that kind of returning Done/NeedMore and the caller casing and dispatching is very cheap.
15:22:40 <sinelaw> has anyone succesfully compiled/used HaRe?
15:22:44 <kmc_> tagless G-machine my ass ;)
15:22:51 <tibbe> kolmodin: no
15:22:58 <tibbe> kolmodin: run get would return NeedMore
15:22:58 <kolmodin> tibbe: since your function now must read from the socket from within binary, instead of returning and re-enter?
15:23:02 <hiptobecubic> i wish sort was multithreaded
15:23:27 <hiptobecubic> and how on earth do they avoid using any ram sorting 32 million elements?
15:23:28 <tibbe> monochrom: yes, it could get in the way of optimizations though
15:23:35 <sinelaw> hiptobecubic, mmapped files
15:23:42 <monochrom> tibbe: nonetheless it worths trying and benchmarking for the final winner.
15:24:08 <tibbe> kolmodin: runGet :: ByteString -> Result a where data Result a = Done a | NeedMore (ByteString -> Result a)
15:24:10 <sinelaw> hiptobecubic, in python there is http://docs.python.org/library/mmap.html
15:24:11 * monochrom has lately pondered on two-continuations passing style again.
15:24:17 <tibbe> monochrom: absolutely
15:24:27 <tibbe> kolmodin: no IO
15:24:28 <Saizan> monochrom: the advantage of church encoding is basically the same as foldr/build fusion for lists
15:24:45 <tibbe> monochrom: (it's more or less the same idea as is used in iteratees)
15:24:46 <Saizan> monochrom: i.e. when you don't need sharing you can avoid intermediate data
15:24:57 <sinelaw> has anyone succesfully used mmap in haskell?
15:25:03 <sinelaw> *successfully
15:25:45 <tibbe> kolmodin: does that make sense
15:25:50 <kolmodin> tibbe: how does that differ from the implementation I gave you? isn't it doing exactly that?
15:26:00 <tibbe> kolmodin: you can then write a driver that repeatedly calls runGet with the content of a lazy bytestring
15:26:11 <tibbe> kolmodin: I haven't read your implementation yet
15:27:00 <tibbe> kolmodin: another possible implementation, the one I mentioned, would be: runGet :: ByteString -> ((ByteString -> a) -> a) -> a
15:27:28 <tibbe> kolmodin: (except we can't communicate failure here)
15:27:41 <tibbe> kolmodin: it's church encoding of the NeedMore constructor
15:27:56 <tibbe> kolmodin: hmm
15:28:08 <tibbe> kolmodin: although perhaps that needs to be in IO. let me think
15:28:42 <aconbere> oh man
15:28:47 <aconbere> i'm having a rough ghc day
15:28:50 <kolmodin> tibbe: my runGet takes a lazy bytestring and works as a driver/helper around runGetPush
15:28:57 <aconbere> so trying to compile ghc 6.12.1
15:29:00 <aconbere> I get this error
15:29:01 <aconbere> unknown section type: @progbits
15:29:10 <tibbe> kolmodin: right
15:29:26 <tibbe> kolmodin: people who work in IO could write another driver but still use runGetPush
15:29:29 <aconbere> anyone know /anything/ about that error
15:29:34 <kolmodin> tibbe: so maybe we could get around creating and destroying the result tuple
15:29:41 <kolmodin> tibbe: which is probably quite expensive
15:29:44 <aconbere> looking around google didn't turn up anything super useful
15:29:46 <tibbe> kolmodin: yes
15:30:17 <kolmodin> tibbe: I think when I wrote the "module Foo ( func1, func2 ...)" declaration I got a lot better speed
15:30:20 <tibbe> kolmodin: http://okmij.org/ftp/Haskell/Iteratee/IterateeMCPS.hs <-- look at Iteratee there. That's a monadic version of iteratee. a non-monadic version should correspond to what we need
15:30:21 <kolmodin> tibbe: better than the 1/3
15:30:30 <tibbe> kolmodin: inlining :)
15:30:42 <kolmodin> tibbe: I guess it's because GHC was allowed to do some dirty things in the dark... :D
15:30:52 <kolmodin> aye
15:32:02 <tibbe> kolmodin: haha, yes
15:32:17 <temoto> > (if True then 1 else 2,3)
15:32:17 <tibbe> kolmodin: I think GHC more or less unconditionally inlines non-exported definitions
15:32:18 <lambdabot>   (1,3)
15:32:23 <temoto> well
15:32:36 <tommd> tibbe: In Portland now?
15:32:47 <tibbe> tommd: not until friday next week
15:32:51 <tibbe> tommd: still in zurich
15:33:00 <tibbe> tommd: flying to SF on monday
15:33:02 <kolmodin> tibbe: ok, we can discuss it more later. need to go, kind of promised I'd be on time at work tomorrow :D
15:33:10 <tibbe> kolmodin: sure. gnight
15:33:12 <tommd> Huh - I must have misunderstood Don ten.
15:33:13 <tommd> then
15:33:14 <tibbe> kolmodin: I need sleep too
15:33:22 <kolmodin> tibbe: right, you're giving a talk? too bad I'll miss it
15:33:29 <tibbe> tommd: what did he say?
15:33:34 <tibbe> kolmodin: yes :/
15:33:46 <uorygl> @type ?x
15:33:46 <lambdabot> forall t. (?x::t) => t
15:33:59 <uorygl> > ?x
15:34:00 <lambdabot>   Unbound implicit parameter (?x::a)
15:34:00 <lambdabot>    arising from a use of implicit parame...
15:34:05 <kolmodin> tibbe: well, I'll follow your work through git and your and bos' blogs :)
15:34:09 <kolmodin> tibbe: cheers, g'night
15:34:10 <tommd> tibbe: Invited me to do some hacking at Galois on Friday - said you'd be there.
15:34:21 <tibbe> kolmodin: :) gnight
15:34:32 <tibbe> tommd: yes, but next week
15:34:38 * bos is trying to find a way to get to portland on friday too
15:34:43 <tommd> Ahh, good to know - that day I can make.
15:34:43 <uorygl> @type \f -> let ?x = 3 in f
15:34:44 <lambdabot> forall t. t -> t
15:34:55 <bos> maybe dons can get galois to pay for a flight
15:34:57 <uorygl> > (\f -> let ?x = 3 in f) ?x
15:34:58 <lambdabot>   Unbound implicit parameter (?x::a)
15:34:58 <lambdabot>    arising from a use of implicit parame...
15:35:10 <tibbe> tommd: http://www.galois.com/blog/category/techtalks/
15:35:12 <uorygl> Make that work, and I'll be a happier person.
15:35:16 <temoto> :t ()
15:35:17 <lambdabot> ()
15:35:27 <tommd> @tell dons If the invite is still open, I'd be happy to hack next week - thought you ment the hacking would be this week.
15:35:27 <lambdabot> Consider it noted.
15:35:31 <tibbe> bos: how am I supposed to lie and claim all credit during the talk then?
15:35:36 <temoto> > length (1,2)
15:35:37 <lambdabot>   Couldn't match expected type `[a]' against inferred type `(t, t1)'
15:35:45 <bos> tibbe: i accept bribes in most major currencies
15:35:53 <tibbe> bos: beer?
15:35:56 <bos> :-)
15:37:12 <idnar> temoto: a tuple's "length" is statically fixed
15:37:13 <lispy> tibbe: oh, you'll be here next week right?
15:38:02 <tibbe> lispy: if by here you mean SF, yes. Jan 25 - Feb 11
15:38:05 <temoto> idnar: which shouldn't prevent length to find it at run time :)
15:38:17 <lispy> tibbe: Hmm...I meant Galois :)
15:38:27 <tibbe> lispy: yes, on the 29th
15:38:43 <lispy> Cool, I'm looking forward to your talk
15:39:59 <tibbe> lispy: thanks. although if any more people say that I'll be nervous giving it ;)
15:40:01 <uorygl> class Long a where longth :: a -> Int; instance Long (a,b) where longth = const 2; instance Long (a,b,c) where longth = const 3; . . .
15:40:38 <lispy> tibbe: hehe.  If you're like me you'll get nervous regardless. :P
15:40:50 <tibbe> lispy: heh
15:40:56 <tibbe> lispy: I really need to get to bed
15:41:03 <lispy> tibbe: cool, tty
15:41:06 <lispy> er,ttyl
15:41:08 <tibbe> it's passed midnight, again. and I have to get up at 7
15:41:12 <tibbe> ttyl
15:41:14 <tibbe> gnight all
15:41:39 <sinelaw> night
15:44:13 <solrize> > [5, 4 .. 5]
15:44:14 <lambdabot>   [5]
15:44:16 <solrize> heh
15:44:28 <temoto> Anyone heard of sleetracker btw?
15:44:48 <medfly> > [0.2,0.4..0.7]
15:44:49 <lambdabot>   [0.2,0.4,0.6000000000000001]
15:44:53 <medfly> yaay
15:45:27 <temoto> it's like hand watches with alarm and it is supposed to wake you up in most appropriate time
15:45:33 <xerox> > [1%5,2%5,..,7%10]
15:45:34 <lambdabot>   <no location info>: parse error on input `..'
15:45:42 <xerox> dwim!
15:45:43 <temoto> something about sleep cycles
15:49:49 <hiptobecubic> sinelaw, 14.3 million words
15:50:05 <sinelaw> what language is that?
15:50:16 <monochrom> tibbe, kolmodin, Saizan: I now recall that Appel was championing CPS in the 80s. My memory is he was like "compile everything to CPS! need moar continuations! it's faster!" In retrospect, his advice was not heeded because handwriting fast code in impure eager FP was so easy, no one stress-tested pure lazy FP like we do now where his advice is needed. Someone should send him a thank-you card. :)
15:50:21 <hiptobecubic> sinelaw, what language is what?
15:50:31 <sinelaw> the words
15:50:53 <temoto> You see The Words?
15:51:59 <solrize> rabbit
15:52:00 <solrize> ?
15:52:02 <hiptobecubic> The words in the file are not in a human language. just ascii strings like "3838$$fff"
15:52:21 <Philonous> > [1%5,2%5..7%10]
15:52:21 <lambdabot>   [1 % 5,2 % 5,3 % 5,4 % 5]
15:52:22 <solrize> i mean, there was a whole series of CPS scheme compilers
15:52:22 <damd> what's not human about three eight three eight dollar dollar fuck fuck fuck
15:52:28 <solrize> that i thought vindicated the concept
15:52:39 <damd> that could actually make a good marilyn manson song
15:52:42 <solrize> rabbit -> orbit -> gambit
15:52:48 <hiptobecubic> damd, it could, yes.
15:53:10 <damd> amirite?!?!?
15:53:30 <hiptobecubic> Y
15:53:43 <hiptobecubic> sinelaw, ^
15:53:48 <monochrom> amy rite
15:53:50 <sinelaw> hiptobecubic, so try mmapping it in python
15:53:58 <sinelaw> ...in haskell, i don't know.
15:54:30 <hiptobecubic> sinelaw, oh. alright i'll give it a shot, i thought haskell would be better suited to something like this. I don't really know haskell at all
15:54:34 <sinelaw> in haskell you might be able to use mmapped-lazy-bytestrings
15:54:52 <sinelaw> hiptobecubic, nor do I. maybe someone else has an idea?
15:55:03 <hiptobecubic> sinelaw, I was reading wikipedia and thinking maybe a trie?
15:55:12 <hiptobecubic> I don't know much about them either, but it looked appropriate
15:55:32 <damd> hm, you could possibly use a Functor... hm...
15:56:13 <sinelaw> hiptobecubic, it does indeed
15:56:18 <sinelaw> look appropriate
15:56:47 <sinelaw> hiptobecubic, there is http://hackage.haskell.org/package/bytestring-trie
15:57:00 <hiptobecubic> hmm
15:57:19 <hiptobecubic> sinelaw, interesting. i'll take a look. Got to do some errands. I'll be back. Thank you for you help :)
15:58:05 <sinelaw> hiptobecubic, no problem. when you come back, ask (other people) again. some experienced people here will probably give you a much more informed answer
16:02:16 <solrize> hiptobecubic, maybe you really want judy?
16:02:52 <solrize> http://hackage.haskell.org/packages/archive/judy/0.2.2/doc/html/Data-Judy.html
16:03:03 <solrize> http://donsbot.wordpress.com/2009/09/26/very-fast-scalable-mutable-maps-and-hashes-for-haskell/
16:03:26 <mreh> kmc_ I dont understand how parseNote works, it seems incomplete - http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16412#a16412
16:04:19 <elspru> No instance for (RealFrac Int) rows = floor $ sqrt pixelLength
16:04:22 <elspru> ?
16:04:50 <ddarius> monochrom: What happened was "Compiling with Continuations, Revisited"
16:04:52 <monochrom> type of pixelLengh is ?
16:05:02 <elspru> Int i think
16:05:20 <monochrom> floor $ sqrt $ fromIntegral pixelLength
16:05:25 <monochrom> @quote monochrom fromIntegral
16:05:26 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
16:06:12 <monochrom> ddarius: Oh, is that someone's thank-you paper to Appel?
16:06:13 <kmc_> mreh, well as i said, it's untested
16:06:17 <kmc_> hmm yes
16:06:22 <mreh> heh
16:06:33 <kmc_> parseNote = liftM2 (flip ($)) parseNatural parseAccidental
16:06:36 <elspru> aha!
16:06:36 <elspru> merci
16:06:38 <kmc_> does that make more sense?
16:06:39 <kmc_> sorry
16:06:49 <mreh> yes thanks kmc_
16:08:17 <marcot> Good evening.
16:08:48 <marcot> I can't login to GHC's Trac.  Iceweasel is telling me: The page isn't redirecting properly.
16:08:56 <marcot> Is it just here or is it a problem in the server?
16:09:01 <marcot> Rest of the message in iceweasel: Iceweasel has detected that the server is redirecting the request for this address in a way that will never complete.
16:09:30 <ddarius> monochrom: Actually, this paper is the one I meant: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.48.8807
16:09:32 <marcot> This problem can sometimes be caused by disabling or refusing to accept cookies.
16:09:41 <ddarius> "The Essence of Compiling with Continuations"
16:12:12 <monochrom> ddarius: hahaha that's fun!
16:14:02 <marcot> Other browsers, such as Epiphany and Midori just hang, using a lot of connection.
16:17:19 <temoto> kmc_: could you please help with parsec?
16:17:58 <temoto> http://codepad.org/zHn2oXCU can't find how to satisfy types
16:18:14 <Pseudonym> Has anyone else tried the intuitionism test? http://intuitionism.org/
16:18:20 <kmc_> temoto, this has nothing to do with parsec
16:18:24 <kmc_> err sorry
16:18:24 <temoto> basically, i want to repeat tuple construction semantic from haskell
16:18:27 * Pseudonym has had more than one "I object to the question" moments
16:18:29 <kmc_> the codepad error is not your error ;)
16:18:32 <kmc_> i see
16:18:57 <temoto> yeah the problem is about composing parsers
16:18:59 <kmc_> temoto, you put tuple0 first, so it will always match that one
16:19:07 <kmc_> because it consumes no input
16:19:10 <kmc_> put the biggest one first
16:19:15 <kmc_> and wrap it in "try"
16:19:48 <temoto> they all consume parens
16:19:56 <kmc_> oh right
16:19:59 <kmc_> they'll consume the closing paren
16:20:00 <kmc_> makes sense
16:20:06 <kmc_> so what's the problem?
16:20:39 <ddarius> Pseudonym: Indeed.  What if I believe there are 0-2 infinite cardinalities?
16:20:42 <Pseudonym> Example: "Do you agree that the axiom which states the existence of an inaccessible cardinal is a meaningful statement that has a definite truth value, even if we do not know what it is? "
16:20:49 <Pseudonym> Dude, it's an AXIOM.
16:21:06 <temoto> kmc_: http://codepad.org/EgOU86jM
16:21:08 <Pseudonym> Axioms are, a priori, assumed to be true.
16:21:16 <Pseudonym> In that system.
16:21:25 <temoto> kmc_: the code in prev. link only seems to be valid.
16:21:28 <Pseudonym> "Do you agree that for any two statements the first implies the second or the second implies the first?"
16:21:35 <ddarius> Pseudonym: I think that particular question is not unreasonable.  It's whether you would accept a system with that axiom.
16:21:40 <Pseudonym> There's more than one kind of implication.
16:21:55 <Pseudonym> ddarius: I'd accept any system which is consistent as valid for study..
16:22:04 <Pseudonym> Oh, and sound.
16:22:10 <Pseudonym> I guess that's the same thing.
16:22:13 <ddarius> Pseudonym: Yes...
16:22:32 <kmc_> :t commaSep1
16:22:33 <lambdabot> Not in scope: `commaSep1'
16:22:47 <kmc_> where's that combinator from?
16:22:49 <Pseudonym> Sorry, I meant only one full stop there.
16:23:02 <ddarius> Pseudonym: I don't think the idea is what you consider valid for study or not.
16:23:16 <ddarius> I like constructive logic, but have no problem with studying classical logic.
16:23:17 <temoto> CharParser st a -> CharParser st [a]
16:23:30 <temoto> kmc_: from Parsec.Language
16:23:38 <Pseudonym> Here's the one that really puzzles me:
16:23:40 <Pseudonym> "Do you agree that a constructive proof of a theorem gives more insight than a classical proof?"
16:24:05 <Pseudonym> A truly novel classical proof can provide far more insight than a pedestrian constructive proof.
16:24:30 <kmc_> you mean Text.Parsec.Token?
16:24:44 <temoto> :t Text.ParserCombinators.Parsec.Token.commaSep1
16:24:45 <lambdabot> forall s u (m :: * -> *) a. Text.Parsec.Token.GenTokenParser s u m -> Text.Parsec.Prim.ParsecT s u m a -> Text.Parsec.Prim.ParsecT s u m [a]
16:24:46 <temoto> yes
16:24:54 * shapr boings cheerfully
16:25:05 <shapr> What's the closest thing to Zope/Plone for Haskell?
16:25:15 <temoto> Happstack i guess.
16:25:16 <Pseudonym> But maybe I'm misunderstanding the question.
16:25:22 <lispy> Pseudonym: the emphasis is on novel vs. pedestrian, right?
16:25:28 <temoto> but that's closer to Pylons, i guess
16:25:31 <shapr> It looks like I might be building a website for a client who doesn't want to write their own html at all, so I could use anything I want.
16:25:38 <Pseudonym> lispy: Quite.
16:25:46 <kmc_> temoto, hmm, your definition of tuple1 is broken i think
16:25:49 <kmc_> do { return [expr]; comma }
16:25:59 <kmc_> do { return x; y }    is always equivalent to   do { y }
16:26:07 <Pseudonym> The problem is that it depends on the problem.
16:26:07 <kmc_> plus [expr] is a singleton list of parsers
16:26:10 <kmc_> is that what you want?
16:26:33 <kmc_> i think you want something like:    do { x <- expr; comma; return [x] }
16:26:48 <temoto> I want haskell tuple construction semantics.
16:26:55 <Pseudonym> I think that what they meant is that if you have a classical proof, then coming up with a constructive proof does add something, where the converse is usually not true.
16:27:01 <kmc_> well, Haskell has no syntax for the 1-tuple
16:27:02 <temoto> So, for singleton yes, i want that.
16:27:07 <temoto> It has.
16:27:10 <temoto> > (1,)
16:27:10 <kmc_> > (3,)
16:27:11 <lambdabot>   <no location info>: parse error on input `)'
16:27:11 <lambdabot>   <no location info>: parse error on input `)'
16:27:16 <kmc_> Python has
16:27:17 <kmc_> Haskell hasn't
16:27:18 <temoto> damnit
16:27:25 <shapr> temoto: I'll try happstack, thanks.
16:27:25 <kmc_> in GHC 6.12 with the appropriate extension, that'd be a tuple section
16:27:31 <Pseudonym> But there's a lot of "all other things being equal" and "usually" thrown in there.
16:27:32 <kmc_> equivalnet to \x -> (3,x)
16:27:48 <kmc_> also, i think you mean "syntax" rather than "semantics", unless i'm missing a layer here
16:27:48 <temoto> Just hasn't?
16:28:05 <kmc_> > let hasn't = () in Just hasn't
16:28:06 <lambdabot>   Just ()
16:28:07 <temoto> Syntax, right.
16:28:20 <temoto> heh
16:28:20 <kmc_> do you see why   do { return x; y }   is pointless?
16:28:43 <temoto> I have little to nothing understanding how do notation is desugared.
16:29:05 <kmc_> "return" injects a value into the monad
16:29:13 <kmc_> then, since the statement has no "<-", the value is thrown away
16:29:45 <kmc_> do { a ; b }   desugars to   a >> do { b }
16:29:53 <temoto> So return is only useful with <- ?
16:29:59 <kmc_> or at the end of the block
16:30:06 <kmc_> or in various other contexts
16:30:09 <temoto> What does it do at the end?
16:30:10 <kmc_> but never before ';'
16:30:14 <kmc_> the same thing
16:30:19 <kmc_> it is, after all, just a function
16:30:24 <kmc_> do { b }    desugars to simply    b
16:30:41 <temoto> I see then, thanks.
16:31:03 <kmc_> it's commonly seen at the end because, after binding together a number of monadic actions and getting their results into local variables, you want to apply some function before yielding a result
16:31:26 <kmc_> do { x <- expr; y <- expr; return (Add x y) }
16:31:37 <kmc_> in this case we'd rather write:  liftM2 Add expr expr
16:31:37 <temoto> Yeah, i have such code. Few times.
16:31:45 <temoto> yay
16:31:48 <kmc_> or,  Add <$> expr <*> expr
16:31:54 <temoto> oh noes
16:32:42 <temoto> I like liftM most.
16:33:09 <temoto> but hey stop
16:33:13 <temoto> <$> is fmap
16:33:18 <temoto> <*> is what?
16:33:37 <temoto> @src <*>
16:33:37 <lambdabot> Source not found. I am sorry.
16:33:40 <temoto> @src (<*>)
16:33:40 <lambdabot> Source not found. The more you drive -- the dumber you get.
16:33:46 <temoto> @hoogle (<*>)
16:33:46 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
16:33:54 <temoto> ap?
16:34:15 <stroan> happy is able to parse Haskell isn't it?
16:34:23 <tensorpudding> ap = <*>
16:34:26 <dibblego> yes, all Monads are Applicative by (<*>) = ap and pure = return
16:35:04 <kmc_> but the instance might not actually exist :/
16:35:31 <kmc_> temoto, essentialy,   f <$> a <*> b <*> ... <*> z    ==   liftMn f a b ... z
16:35:34 <kmc_> for the appropriate n
16:35:45 <temoto> I got that.
16:35:57 <temoto> Too bad that it's not arity polymorphic.
16:36:05 <Axman6> ?
16:36:07 <kmc_> liftM?
16:36:14 <temoto> Yes.
16:36:16 <kmc_> variadicity is annoying in Haskell
16:36:19 <tensorpudding> <$> is fmap
16:36:20 <temoto> And zip too.
16:36:22 <kmc_> though, you could use Template Haskell
16:36:28 <kmc_> $(liftMn 17) f a b ...
16:36:48 <kmc_> i'm not sure if the typeclass approach to variadic functions would work here
16:36:55 <kmc_> i think it would confuse the issue substantially
16:37:16 <temoto> A fellow showed me how this could be autoresolved via type class for some subset of n.
16:37:31 <kmc_> iirc, She has an extension roughly like  (| f a b c d |)  ==>  f <$> a <*> b <*>  c <*> d
16:37:37 <temoto> But that's like haskell tuples, only first 64 are predefined.
16:37:52 <kmc_> temoto, look at Text.Printf
16:37:53 <temoto> She?
16:37:57 <kmc_> there's no need to predeclare up to some level
16:38:00 <kmc_> @where she
16:38:00 <lambdabot> http://personal.cis.strath.ac.uk/~conor/pub/she/
16:38:53 <kmc_> "idiom brackets"
16:39:38 <temoto> Well that's nice enough.
16:40:31 <aconbere> crrrrapppp
16:40:35 <aconbere> unknown symbol `___stginit_rediszm0zi4_RedisziCommandsziBasic_'
16:40:49 <temoto> Though, i think making more operators and syntaxes is Perl way.
16:41:06 <kmc_> well, syntaxes anyway
16:41:14 <kmc_> Haskellers define new operators all the time
16:41:15 <dibblego> > getZipList (ZipList (+) <$> ZipList [1,2,3] <*> ZipList [4,5,6])
16:41:16 <lambdabot>   Couldn't match expected type `[a]'
16:41:16 <lambdabot>         against inferred type `a1 -> a1 ...
16:41:19 <Axman6> aconbere: did you compile with --make?
16:41:47 <aconbere> Axman6: no I used cabal
16:41:55 <aconbere> Axman6: but that's what someone else asked
16:42:51 <temoto> aconbere: I resolved it by removing 'module MicroFlow.Main where' from Main.hs.
16:43:36 <aconbere> temoto: ?
16:43:46 <aconbere> Axman6: is there any reason using --make causes that error?
16:43:55 <aconbere> maybe it would give me a place to start trying to fix what I have
16:44:12 <c_wraith> --make usually fixes errors like that, not causes them
16:44:29 <aconbere> ah
16:46:51 <aconbere> c_wraith: when I compile within ghci
16:46:54 <aconbere> it all works fine
16:47:00 <aconbere> but from cabal
16:47:07 <aconbere> it crashes with that error
16:51:26 <A1kmm> Hi, I would like to transform a function as follows: (a -> b -> m c) -> m a -> m b -> m c (like (=<<) but with one more argument).
16:51:44 <A1kmm> What is the best code style for this? Is there a better way than using an explicit do?
16:52:55 <monochrom> liftM2
16:53:05 <monochrom> @type liftM2
16:53:06 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
16:53:10 <monochrom> \o/
16:53:21 <monochrom> Oh wait, not exactly.
16:53:41 <Pseudonym> Perhaps this is an Applicative?
16:55:02 <aavogt> @type bind2
16:55:03 <lambdabot> forall t t1 (m :: * -> *) b. (Monad m) => (t -> t1 -> m b) -> m t -> m t1 -> m b
16:55:26 <monochrom> @src bind2
16:55:26 <lambdabot> Source not found.
16:55:27 <aavogt> it would be nice to have such in the library
16:55:39 <Pseudonym> @hoogle (Monad m) => (a -> b -> m c) -> m a -> m b -> m c
16:55:39 <lambdabot> Control.Monad zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
16:55:39 <lambdabot> Control.Monad zipWithM_ :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m ()
16:55:39 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
16:55:59 <aavogt> @type ((join .) .) . liftM2
16:56:00 <lambdabot> forall (m :: * -> *) a a1 a2. (Monad m) => (a1 -> a2 -> m a) -> m a1 -> m a2 -> m a
16:56:06 <Pseudonym> Yow.
16:56:35 <Pseudonym> @type \f -> fmap f
16:56:36 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:56:46 <dmwit> ?unpl ((join .) .) . liftM2
16:56:47 <lambdabot> (\ j o r -> (o >>= \ d -> r >>= \ c -> return (j d c)) >>= \ k -> k)
16:56:50 <dmwit> ack
16:57:06 <Pseudonym> @type \f m -> (<*>) (fmap f m)
16:57:07 <lambdabot> forall a a1 b (f :: * -> *). (Applicative f) => (a -> a1 -> b) -> f a -> f a1 -> f b
16:57:27 <dmwit> Oh, I see.
16:57:33 <aavogt> I believe you can't do it with just Applicative
16:58:02 <Pseudonym> aavogt: It's got the right type. :-)
16:58:08 <dmwit> ...no it doesn't
16:58:19 <aavogt> the difference is the function you supply
16:58:25 <Pseudonym> Ah, yes.
16:58:39 <aavogt> (a -> a1 -> b)  vs  (a -> a1 -> f b)
16:58:44 <Pseudonym> @type \f m n -> fmap f m <*> n
16:58:45 <lambdabot> forall a a1 b (f :: * -> *). (Applicative f) => (a -> a1 -> b) -> f a -> f a1 -> f b
16:59:02 <Pseudonym> @type \f m n -> join (fmap f m <*> n)
16:59:02 <lambdabot> forall a a1 (m :: * -> *) a2. (Applicative m, Monad m) => (a -> a1 -> m a2) -> m a -> m a1 -> m a2
16:59:06 <aavogt> @type liftA2
16:59:07 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
16:59:08 <Pseudonym> That's it.
16:59:21 <temoto> kmc_: interesting that adding try to    parens (try choice1 <|> choice2)  doesn't help to parse (1,) as much as changing the order to 'the biggest to the left'.
16:59:27 <dibblego> @type \f m n -> join (f <$> m <*> n)
16:59:28 <lambdabot> forall a a1 (m :: * -> *) a2. (Applicative m, Monad m) => (a -> a1 -> m a2) -> m a -> m a1 -> m a2
16:59:33 <aavogt> yes, see the scrollback ;)
16:59:39 <dibblego> @type \f m n -> join (liftA2 f m n)
16:59:39 <lambdabot> forall a b (m :: * -> *) a1. (Applicative m, Monad m) => (a -> b -> m a1) -> m a -> m b -> m a1
16:59:54 <dibblego> @pl \f m n -> join (liftA2 f m n)
16:59:54 <lambdabot> ((join .) .) . liftA2
16:59:55 <Pseudonym> Right, either of those work.
17:00:02 <dibblego> @type ((join .) .) . liftM2
17:00:03 <lambdabot> forall (m :: * -> *) a a1 a2. (Monad m) => (a1 -> a2 -> m a) -> m a1 -> m a2 -> m a
17:00:21 <dmwit> ?pl \f x y -> x >>= \x -> y >>= \y -> f x y
17:00:21 <lambdabot> flip ((.) . (>>=)) . (const .) . (=<<) . join
17:00:31 * Pseudonym doesn't like the pointless version there
17:00:38 <aavogt> I think it is possible to get used to writing    (f .) . g
17:00:50 <aavogt> meaning that g takes two arguments
17:00:58 <Pseudonym> ((f .) .) . g seems wrong, though.
17:01:01 <dmwit> :t \f x y -> liftM2 (,) x y >>= uncurry f
17:01:01 <lambdabot> forall a1 a2 (m :: * -> *) b. (Monad m) => (a1 -> a2 -> m b) -> m a1 -> m a2 -> m b
17:01:07 <Pseudonym> :t \f g -> ((f .) .) . g
17:01:08 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => (a -> b) -> f2 (f1 (f a)) -> f2 (f1 (f b))
17:01:19 <dmwit> ?pl \f x y -> liftM2 (,) x y >>= uncurry f
17:01:19 <lambdabot> flip (flip . ((>>=) .) . liftM2 (,)) . uncurry
17:01:23 <A1kmm> @type \f m n -> do { m' <- m; n' <- n; f m' n' }
17:01:24 <lambdabot> forall (m :: * -> *) t b t1. (Monad m) => (t -> t1 -> m b) -> m t -> m t1 -> m b
17:01:51 <temoto> Yes, #haskell is unique in many ways.
17:02:05 <A1kmm> I guess that it is probably not worth doing pointless unless there is a pre-built library version for it.
17:02:05 <Pseudonym> I think I like join (liftA2 f m n) and join (f <$> m <*> n) best.
17:02:26 <Pseudonym> Slight preference for the latter.
17:02:38 <dmwit> I would prefer liftM2 to liftA2 here.
17:02:44 <Pseudonym> Yeah.
17:02:45 <aavogt> I don't like the class context
17:02:47 <dmwit> No sense mixing Applicative and Monad when only one is necessary.
17:03:21 <dmwit> ?pl \x y f -> liftM2 (,) x y >>= uncurry f
17:03:21 <lambdabot> flip flip uncurry . (((.) . (>>=)) .) . liftM2 (,)
17:03:30 <dmwit> Still so much flipping.
17:03:44 <dmwit> ?pl \f x y -> uncurry f =<< liftM2 (,) x y
17:03:45 <lambdabot> (. liftM2 (,)) . (.) . (=<<) . uncurry
17:03:51 <dmwit> so readable
17:03:58 <aavogt> @pl \x -> f =<< g x
17:03:58 <lambdabot> (f =<<) . g
17:04:16 <aavogt> I guess @pl doesn't know about <=< ?
17:04:21 <dmwit> ah
17:04:25 <dmwit> Would that help here?
17:04:35 <aavogt>   lambdabot | (. liftM2 (,)) . (.) . (=<<) . uncurry
17:04:46 <dibblego> @type \x -> f =<< g x
17:04:47 <lambdabot> forall t a (m :: * -> *) b. (Show a, SimpleReflect.FromExpr (m b), SimpleReflect.FromExpr (t -> m a), Monad m) => t -> m b
17:04:53 <dibblego> @type \f g x -> f =<< g x
17:04:54 <lambdabot> forall t a (m :: * -> *) b. (Monad m) => (a -> m b) -> (t -> m a) -> t -> m b
17:05:07 <aavogt> is also:   ((. liftM2 (,)) . (.) .) <=< uncurry -- maybe
17:05:13 <aavogt> @type ((. liftM2 (,)) . (.) .) <=< uncurry
17:05:14 <lambdabot>     The operator `.' [infixr 9] of a section
17:05:14 <lambdabot>         must have lower precedence than that of the operand,
17:05:14 <lambdabot>           namely `.' [infixr 9]
17:05:20 <dmwit> aavogt: I don't think so...
17:05:31 <aavogt> @type (((. liftM2 (,)) . (.) .) <=< uncurry
17:05:32 <lambdabot> parse error (possibly incorrect indentation)
17:05:44 <Pseudonym> We're seriously in the territory of write-only code, BTW.
17:05:52 <dmwit> yes
17:06:21 <dmwit> But sometimes an excursion into write-only code reveals something interesting. =)
17:06:46 <aavogt> @type (uncurry .) . liftM2 (,)
17:06:47 <lambdabot>     Couldn't match expected type `b -> c'
17:06:47 <lambdabot>            against inferred type `(a1, a2)'
17:06:47 <lambdabot>     In the first argument of `liftM2', namely `(,)'
17:06:52 <Pseudonym> join (liftM2) is something I'm seriously considering using at some point.  (((. liftM2 (,)) . (.) .) is not.
17:07:02 <Pseudonym> But point taken.
17:07:09 <aavogt> that doesn't work though
17:07:12 <monochrom> @unpl join liftM2
17:07:12 <lambdabot> ((\ c d e -> d >>= \ b -> e >>= \ a -> return (c b a)) >>= \ f -> f)
17:07:22 <Pseudonym> I meant join (liftM2 f m n)
17:07:30 <monochrom> Thanks.
17:08:52 <lpjhjdh> so I'm a bit confused about data families, I'm trying to model :< as a data family and can't seem to get it right.  In the past I've used fundeps
17:09:27 <aconbere> one thing I do get
17:09:34 <lpjhjdh> I have "type instance Zero :< Suc n = Tru" and "type instance Suc m :< Suc n = m :< n" and it always seems to compile just fine
17:09:37 <aconbere> is if I compile my package in cabal I get this warning
17:09:37 <aavogt> @pl \f -> (uncurry f <=<) . liftM2 (,)
17:09:38 <lambdabot> (. liftM2 (,)) . (<=<) . uncurry
17:09:41 <aconbere> Warning: Module `Prelude' is deprecated:
17:09:50 <aconbere> and it tells me to update base to 4.x
17:10:02 <aconbere> I'm not sure what to do there except depend on base >= 4
17:10:11 <aavogt> that's just a warning
17:10:24 <aavogt> so you aren't surprised when the package won't build with the next ghc, aconbere
17:11:02 <aconbere> aavogt: which ghc wont it build on?
17:11:06 <aconbere> I'm on 6.12
17:11:12 <aconbere> (just curious)
17:11:41 <aavogt> probably the next one to come out 6.14, which may be this year?
17:11:58 <aconbere> k
17:12:00 <aconbere> hmpf
17:12:13 <aconbere> well I have no idea why this package doesn't build correctly under cabal
17:12:15 <aconbere> :-/
17:12:39 <aavogt> the main thing that changed is Control.Exception
17:12:52 <aconbere> yeah but I bet that's not it
17:14:08 <aavogt> well if you've got error I (or somebody else) can try to take a look
17:14:21 <aconbere> yeah I've asked quite a few times, but nobody seems to have any idea
17:14:22 <aconbere> :)
17:14:38 <aavogt> but how about this time?
17:14:40 <dibblego> is it wrong to write and use a flip function so that you can write a point-free expression when using python?
17:14:53 <aconbere> unknown symbol `___stginit_rediszm0zi4_RedisziCommandsziBasic_'
17:15:00 <aconbere> aavogt: ^ (thanks a bunch)
17:15:11 <aconbere> so in cabal, it seems to build and install just fine
17:15:22 <aconbere> then in ghci it loads
17:15:27 <aconbere> but if I call any functions from it
17:15:32 <aconbere> that error is raise
17:15:44 <aavogt> this package uses the ghc-api?
17:16:00 <aconbere> http://paste.pocoo.org/show/168207/
17:16:09 <aconbere> aavogt: this package only depends on base and network
17:16:11 <gwern> dibblego: probably. python isn't so hot for FP, don't treat it so
17:16:51 <dibblego> gwern, I'm not going anywhere near as far as I would with Haskell, but I get frustrated with some of the clumsiness, so I tend toward a more compositional solution
17:17:21 <aavogt> at least with haskell you have type signatures when you go pointfree
17:17:30 <aavogt> in python what's left?
17:17:50 <temoto> @undo do { x <- foo; return [x] }
17:17:51 <lambdabot> foo >>= \ x -> return [x]
17:18:11 <dibblego> aavogt, sure, but why is the alternative any better?
17:19:17 <aavogt> because when you name arguments that's a sort of documentation (unless you use meaningless names like x)
17:19:30 <temoto> well thank you
17:19:33 <kmc_> aavogt, which is interesting, because i think Haskellers tend to choose meaningless names like x
17:19:43 <kmc_> for highly local things
17:19:48 <gwern> kmc_: because often the name is meaningless
17:19:48 <kmc_> it seems to work out fine
17:19:58 <kmc_> well... the name is always meaningless, in a formal sense
17:20:03 <aavogt> exactly why @pl is not unpopular?
17:20:05 <kmc_> it's all for the human's benefit
17:20:14 <gwern> kmc_: but I have been bitten by that for heavily io or string or multiple argument stuff
17:20:28 <kmc_> yeah
17:20:48 <kmc_> i once spent 2 weeks tracking down a bug that turned out to be an xs where an xs' was wanted
17:21:00 <temoto> @pl foo >>= \x -> return [x]
17:21:00 <lambdabot> return `fmap` foo
17:21:03 <aavogt> yeah, if you only have one argument to a reasonably named function, it should probably be pointfree
17:21:07 <temoto> well how nice
17:21:24 <temoto> fmap return, who could've thought
17:21:34 <deteego> hey, does anyone know if there is an ETA for gtk2hs next release
17:21:39 <deteego> that works with ghc 6.12
17:21:40 <Eduard_Munteanu> kmc_, now I realize something like toPeano is rather stupid, unless someone wishes to include a compiler with the output program, complete with a type-checker :)
17:21:59 <aavogt> because   y >>= \x -> return x = y, temoto
17:22:00 <Eduard_Munteanu> I see nobody tried to write it, and it occured to me why.
17:22:47 <aavogt> deteego: might be done already in gtk2hs in darcs?
17:22:52 <temoto> aavogt: it's just i wouldn't ever allow myself to think about putting 'return' as an argument to some function.
17:23:14 <gwern> hm, what was that pastebin site that would compile & run yer haskell?
17:23:16 <temoto> Because i cam from the world where return is a statement.
17:23:20 <Vanadium> aavogt: Nope.
17:23:22 <Eduard_Munteanu> If toPeano could be written, then it could also produce arbitrary Peano numbers from IO at runtime. But that's impossible, since the output program has no compiler/type-checker functionality.
17:23:23 <aavogt> > return 'a' :: [Char]
17:23:24 <lambdabot>   "a"
17:23:24 <temoto> gwern: codepad.org
17:23:32 <aavogt> Vanadium: yes?
17:23:33 <gwern> ah thanks
17:23:41 <Vanadium> regarding gtk2hs
17:23:44 <deteego> aavogt: where is the gtk2hs darcs repository
17:23:47 <Vanadium> Tried it earlier today, anyway.
17:23:49 <deteego> cant find it on their website
17:23:54 <Vanadium> http://code.haskell.org/gtk2hs
17:24:13 <kmc_> Eduard_Munteanu, you don't need that; you only need something like Data.Typeable + Data.Dynamic
17:24:14 <aconbere> aavogt: any ideas?
17:24:20 <kmc_> which implements a runtime type checker of sorts
17:24:26 <kmc_> (it's very simple because it only handles monomorphic types)
17:24:44 <aavogt> anyways, I thought dcoutts did some work on ghc-6.12 compatibility for gtk2hs
17:25:09 <Vanadium> Apparently not enough of it. No idea, but I cannot seem to link my hello-world program.
17:25:19 <Vanadium> Hooray for him working on it, anyway :)
17:25:23 <Eduard_Munteanu> kmc_, hm interesting, will look at those.
17:25:32 <kmc_> anyway, it's pointless, because the entire usefulness of the type-level number is its type, not its value.  and you have to tell fromDynamic the type you want.  so the most you can do is push the comparison between two compile-time integers into runtime ;)
17:25:35 <aconbere> aavogt: http://github.com/aconbere/redis
17:25:36 <kmc_> which is an interesting pessimization
17:25:38 <aconbere> is the library
17:25:44 <aconbere> builds fine with ghc --make or ghci
17:25:45 <temoto> @undo do { a <- f; b <- g; return $ h a b }
17:25:45 <lambdabot> f >>= \ a -> g >>= \ b -> return $ h a b
17:25:50 <aconbere> but not in cabal
17:25:55 * aconbere goes to do laundry
17:26:06 <temoto> @pl f >>= \ a -> g >>= \ b -> return $ h a b
17:26:06 <lambdabot> (`fmap` g) . h =<< f
17:26:26 <dmwit> liftM2 h
17:26:28 <dmwit> ?
17:26:40 <temoto> Yeah i was going to propose lift too.
17:26:46 <deteego> Vanadium: thanks
17:26:54 <temoto> strange that @pl doesn't
17:26:55 <kmc_> :t liftM2 ?h ?f ?g
17:26:56 <lambdabot> forall a1 a2 r (m :: * -> *). (?h::a1 -> a2 -> r, ?f::m a1, ?g::m a2, Monad m) => m r
17:27:12 <Eduard_Munteanu> What would you suggest to get started with Curry-Howard isomorphism? Some type theory?
17:27:20 <kmc_> Eduard_Munteanu, TaPL
17:27:22 <kmc_> @where tapl
17:27:22 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
17:27:32 <kmc_> I can give you the 5-min overview
17:27:34 <kmc_> of CH
17:27:39 <kmc_> or you can read on Wikipedia, etc
17:27:50 <trainpic> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=16417#a16417
17:27:53 <kmc_> it'll help to know basic logic as well
17:27:57 <kmc_> and, or, implication
17:28:01 <Eduard_Munteanu> kmc_, thanks
17:28:01 <trainpic> I'm trying to install jack and it's missing the st.h header file
17:28:04 <trainpic> what library is that from?
17:28:23 <trainpic> *the jack haskell bindings
17:28:36 <temoto> i'd listen to 5min overview
17:28:50 <kmc_> okay
17:29:05 <kmc_> so Curry-Howard says "types are propositions; terms are proofs"
17:29:14 <kmc_> what do we mean by "types are propositions"?
17:29:18 <Eduard_Munteanu> kmc_, yeah, I know the basics.
17:29:26 <kmc_> okay
17:29:26 <Eduard_Munteanu> kmc_, types are theorems
17:29:43 <dmwit> trainpic: Have you got libjack-dev (or whatever) installed?
17:29:50 <Eduard_Munteanu> And inhabitation of types is proofs.
17:29:52 <kmc_> Eduard_Munteanu, do you understand how and, or, implication work?
17:29:53 <Eduard_Munteanu> kmc_, right?
17:30:04 <dmwit> I guess so, if it found jack/jack.h
17:30:07 <dmwit> Never mind me.
17:30:18 <Eduard_Munteanu> kmc_, partially, I need to review it.
17:30:48 <kmc_> So we know that a type is a set of values, which could be empty or not.  We interpret a type "T" to be the proposition "T is not empty", i.e. "Some value has type T"
17:31:05 <trainpic> dmwit: yes
17:31:07 <kmc_> So for example "Integer" is obviously a true proposition, because there are integers
17:31:27 <Eduard_Munteanu> kmc_, yes.
17:31:34 <kmc_> Then a proof of type T is just a value of that type
17:31:38 <kmc_> So 3 is a proof of Integer
17:31:49 <Eduard_Munteanu> kmc_, yes.
17:32:17 <kmc_> The interesting stuff starts when you consider implication:  a function of type A -> B is a proof that "A implies B", because it will take a proof of A and return to you a proof of B
17:33:02 <Eduard_Munteanu> kmc_, in that case I only need to provide a function A -> B?
17:33:30 <kmc_> A function of type "A -> B" is a proof that A implies B
17:33:46 <kmc_> And it's a *constructive* proof, because it tells you how to build the proof of B given the proof of A
17:33:59 <kmc_> That's why these simple type theories correspond to constructive, not classical, logic
17:34:23 <kmc_> Eduard_Munteanu, do you know how to define "and", "or", and "not" in this framework?
17:34:47 <Eduard_Munteanu> kmc_, I know NOT I think... it was something forall b, a->b
17:35:25 <dibblego> forall a b. a -> b is uninhabited
17:35:40 <kmc_> Eduard_Munteanu, that works.  or you can pick a specific concrete type with no inhabitatns
17:35:42 <kmc_> data Void
17:35:51 <kmc_> no constructors
17:36:00 <kmc_> and say:   type Not a = a -> Void
17:36:00 <Eduard_Munteanu> kmc_, I see. That was easy to remember via the principle of explosion.
17:36:04 <kmc_> right
17:36:14 <Eduard_Munteanu> Oh.
17:36:29 <Eduard_Munteanu> It proves the unprovable.
17:36:52 <Eduard_Munteanu> kmc_, oh, I think I remember AND was isomorphic to tuples.
17:38:01 <Eduard_Munteanu> as in (a, b) -> c means a AND b -> c
17:38:50 <sproingie> i thought the principle of explosion was how michael bay makes movies
17:39:05 <Eduard_Munteanu> sproingie, heh.
17:41:37 <Eduard_Munteanu> kmc_, thanks for making me remember this.
17:41:45 <sproingie> ever hear a song parody that makes it so you can't hear the original anymore?
17:41:52 <idnar> @type foo >>= \x -> return [x]
17:41:53 <lambdabot> Not in scope: `foo'
17:41:56 <idnar> @type ?foo >>= \x -> return [x]
17:41:57 <lambdabot> forall (m :: * -> *) a. (?foo::m a, Monad m) => m [a]
17:42:03 <sproingie> listening to House of the Rising Sun, all i can think of is Puff the Magic Dragon sung to the same tune
17:42:10 <idnar> I think that should really be fmap (:[])
17:42:35 <idnar> fmap return may be overly general
17:43:15 <Eduard_Munteanu> idnar, what's the ? in there?
17:43:21 <Eduard_Munteanu> ?foo
17:43:22 <lambdabot> Maybe you meant: do faq ft todo yow
17:43:51 <BMeph> Eduard_Munteanu: Implicit Parameter
17:44:08 <Eduard_Munteanu> BMeph, yes, but is it '?'? I never knew how to do that with lambdabot
17:44:18 <Eduard_Munteanu> :t ?x + ?y
17:44:19 <lambdabot> forall a. (?x::a, ?y::a, Num a) => a
17:44:26 <Eduard_Munteanu> Oh, it's actually '?'
17:44:32 <drdr> anyone know a simple haskell html server?
17:44:34 <Eduard_Munteanu> I thought irssi was mangling UTF8 for me.
17:44:36 <drdr> like webrick
17:44:42 <BMeph> Eduard_Munteanu: Implicit Param, for short (i.e., :set -XImplicitParams lets you do it in GHCi).
17:44:56 <drdr> ive ben thinking ide write a serch engene to force myself to learn haskell
17:44:57 <Eduard_Munteanu> BMeph, oh, nice.
17:45:16 <sproingie> http-server is simple
17:45:26 <sproingie> @hackage http-server
17:45:26 <lambdabot> http://hackage.haskell.org/package/http-server
17:46:01 <drdr> snap i thought olny ruby had a nice plugin repo
17:47:34 <sproingie> shh, don't tell anyone.  we're supposed to avoid success :)
17:47:53 <c_wraith> ...  only ruby?
17:47:55 <c_wraith> seriously?
17:47:56 <drdr> well gemcutter is freeken l33t
17:47:59 <drdr> yep
17:48:03 <Eduard_Munteanu> CPAN anyone? :P
17:48:05 <drdr> i find PEAR retarted
17:48:08 <c_wraith> I don't like perl at all, but CPAN is a brilliant system
17:48:10 <Vanadium> CTAN anyone
17:48:12 <drdr> CPAN is made by necros
17:48:33 <drdr> and c/c++ has none
17:49:02 <theorbtwo> drdr: "Necros"?  That's some chip you've got on your shoulder, there, son.
17:49:09 <sproingie> necromancers perhaps
17:49:16 <Eduard_Munteanu> To tell the truth, I'm mainly a C programmer, and I tend to take all this plugins and customs from Haskell with a grain of salt.
17:49:20 <drdr> ...
17:49:42 <sproingie> i put the "romantic" in "necromantic" baby!
17:49:51 <drdr> well perl is really bad
17:49:55 <sproingie> bad?
17:50:05 <sproingie> cpan is like the goddam gold standard of community contributions
17:50:11 <monochrom> Why are we talking about perl and cpan and c/c++?
17:50:17 <drdr> like really really really so bad that you had to use ASM to do somthing and then jumped off a cliff bad
17:50:24 <sproingie> like really really who cares?
17:50:31 <drdr> i guss no one
17:50:32 <sproingie> some of us work for a living and use it anyway
17:50:56 <Eduard_Munteanu> monochrom, you don't even know how far offtopic people go sometimes...
17:51:13 <Eduard_Munteanu> like some things I've seen in another channel I hang on around.
17:51:22 <theorbtwo> I'm quite fond of perl, and it really sounds like you are basing your opinion on very little.
17:51:53 <sproingie> heck ghc even has a dependency on perl
17:52:09 <BMeph> drdr: Your case would be improved by pointing out that perl is so complicated that php was invented to tame it.... ;)
17:52:37 <sproingie> trolly troll troll
17:53:00 <Eduard_Munteanu> http://axgle.github.com/images/haskell.jpg
17:53:08 <drdr> hahah
17:53:18 <Eduard_Munteanu> (somebody here posted it earlier/yesterday)
17:54:00 <sproingie> i think some of those pictures in the right hand column should be this: http://www.ugo.com/movies/best-death-scenes/images/entries/scanners.jpg
17:54:13 <djahandarie> lmao at that picture
17:55:03 <Eduard_Munteanu> Heh.
17:56:03 <Eduard_Munteanu> sproingie, somebody I know said "In C you write a lot, think less, in Haskell, you write less code, but you think a lot"
17:56:39 <sproingie> i dunno, in C i'm always having to think about nulls and getting function pointer types wrong and so on
17:57:23 <theorbtwo> It's been my experince that with Haskell, the computer spends a lot of time saying "I'm sorry, Dave, but I can't let you do that", and in C, it says "I was just following orders!"
17:57:48 <sshc_> theorbtwo: mine too
17:57:48 <sproingie> i'd rather have the compiler tell me i screwed up than the runtime
17:58:03 <jrockway_> i was shocked when i wrote my first big haskell program
17:58:11 <jrockway_> lots of errors from ghci as it was being developed
17:58:11 <monochrom> And Adga, "I'm sorry, Dave, but I can't let you do that, I am just following orders!"
17:58:24 <jrockway_> but when i first unleashed it on 10G of data, it produced the correct answer and didn't leak memory
17:58:27 <jrockway_> i was honestly shocked
17:58:48 <jrockway_> i think people like php (etc.) because their project starts working immediately
17:58:59 <jrockway_> but then... they never get to finish it, because it collapses onto itself at runtime
17:59:55 <kmc_> sorry, got distracted, and have to head out now
17:59:56 <kmc_> ttyl all
18:00:10 <tomoj> hmm
18:00:17 <tomoj> I wonder how much static typing contributes to this
18:00:45 <tomoj> and how far is a dynamically typed functional language in between haskell and php?
18:01:05 <tomoj> er, a dynamically typed functional language with immutable data
18:01:15 <monochrom> static typing plus choosing good type rules.
18:01:58 <jrockway_> i have made perl pretty manageable by keeping things immutable and by type checking before and after method calls
18:02:07 <jrockway_> but i always wonder, "what is the point of dynamic typing again?"
18:02:07 <tomoj> did I miss any other important causes of this fail early thing?
18:02:37 <sproingie> plt scheme has immutable conses
18:02:37 <tomoj> that sounds painful to write...
18:02:47 <jrockway_> nope, not at all
18:02:54 <sproingie> that would be your dynamically typed functional language with immutable data
18:02:55 <tomoj> cool
18:02:56 <jrockway_> i have a helper-Moose that does all the hard work ;)
18:02:57 <sproingie> erlang would be another
18:03:00 <tomoj> never learned perl
18:03:05 <tomoj> sproingie: I was actually thinking of erlang
18:03:09 <tomoj> (and clojure to a lesser extent)
18:03:26 <tomoj> how far from haskell do they fall, I wonder
18:03:37 <sproingie> pretty far i'd say
18:03:41 <jrockway_> i agree
18:03:44 <jrockway_> erlang is nothing like haskell
18:03:53 <jrockway_> it is in kind of a no-man's land between perl and haskell
18:03:56 <sproingie> with the new i/o manager, haskell could really give erlang a run for its money
18:03:58 <jrockway_> it doesnt' have the good features of either
18:04:01 <tomoj> it's a bit closer to haskell than, say, ruby, isn't it?
18:04:06 <jrockway_> yes
18:04:10 <jrockway_> "immutable"
18:04:10 <sproingie> the thing erlang has is what perl has: an awesome library
18:04:12 <Adamant> jrockway_: what does Erlang have to do with Perl, at all?
18:04:20 <tomoj> yeah...
18:04:20 <sproingie> there's nothing else like OTP out there
18:04:22 <Adamant> ah, libraries
18:04:23 <jrockway_> dynamically typed
18:04:28 <tomoj> I don't think I can handle doing what OTP does with haskell
18:04:51 <Adamant> jrockway_: I guess, it's not very Perl-like though
18:05:02 <tomoj> I read about the new I/O manager earlier
18:05:22 <sproingie> i hope windows gets a little love with the i/o manager too
18:05:27 <sproingie> completion ports would be nice
18:06:11 <monochrom> Two dimensions: static-dynamic is how early errors are caught, strong-weak is how many errors are caught.
18:06:12 <tomoj> oh, galois talk about it yesterday
18:06:32 <sproingie> dunno how much completion ports scale.  in fact i don't know what large-scale i/o constructs work on windows
18:06:35 <jrockway_> btw, does anyone use the "test-framework" library?
18:06:39 <sproingie> WFMO certainly isn't it
18:06:47 <jrockway_> seems to be broken with quickcheck2, and i'm wondering if it's worth my time to fix it
18:06:49 <tomoj> hmm, I guess immutable data and functional style don't help to _catch_ errors much
18:06:54 <tomoj> but they help a bit to avoid them, I hope
18:06:54 <monochrom> You combine static and strong to fail early and more often.
18:06:59 <jrockway_> (i don't have a really good way to manage my test suites, which is annoying me)
18:07:38 <Draconx|Laptop> sproingie, ugh, not _another_ thing called "OTP".
18:07:56 <sproingie> Draconx|Laptop: i suspect erlang's had the acronym a while longer than most
18:08:05 <sproingie> initialism whatever
18:08:43 <Draconx|Laptop> longer than "One Time Pad" and "One Time Programmable"?
18:08:53 <Adamant> Draconx|Laptop: everything is overloaded once you start mixing fields
18:08:54 <sproingie> i've never heard of the second
18:09:13 <Adamant> just flow with it :P
18:09:16 <sproingie> TLA's get reused, just gotta deal
18:09:42 <monochrom> TLA: http://research.microsoft.com/en-us/um/people/lamport/tla/tla.html
18:10:06 <Draconx|Laptop> hah!
18:10:11 <monochrom> I'm sure Lamport was secretly chuckling evilly when he decided on that name.
18:10:16 <tomoj> "My ultimate goal is to be able to get the GHC runtime into a position of being able to handle hundreds of thousands of concurrent network connections."
18:10:18 <c_wraith> sounds likely
18:10:25 <tomoj> I hope that happens soon
18:10:36 <c_wraith> they're making fast progress on their project.
18:10:47 <tomoj> is there a status or wiki page or anything?
18:10:55 <tomoj> maybe I should check the bug tracker
18:10:56 <c_wraith> just their blogs, as far as I know
18:11:01 <Eduard_Munteanu> Good way of pissing off LKML people: http://lwn.net/Articles/352432/
18:11:04 <jrockway_> how do you guys get your OS to give you thousands of file descriptors?
18:11:09 <jrockway_> i can only get about 30,000 on my machine
18:11:13 <jrockway_> and even perl can handle that many :)
18:11:18 <c_wraith> jrockway_: mac?
18:11:18 <Draconx|Laptop> 30,000 would count as thousands.
18:11:29 <jrockway_> yeah
18:11:31 <sproingie> jrockway_: doing useful work, with fast response time?
18:11:38 <sproingie> not likely with select
18:11:49 <jrockway_> it's libev/epoll of course
18:11:53 <c_wraith> I'm pretty sure osx just is braindead after that many file descriptors
18:11:55 <jrockway_> and on linux
18:11:59 <sproingie> perl can do it because it has modules for things that do scale, like libevent
18:12:10 <jrockway_> but anyway, i saw some article on HN asking "how can i handle 100,000 concurrent connections"
18:12:12 <c_wraith> like how mv on osx isn't atomic
18:12:19 <jrockway_> so that's what i was thinking of when "thousands" was mentioned
18:12:25 <jrockway_> c_wraith: yeah
18:12:26 <jrockway_> very nice
18:12:26 <sproingie> 100K connections is getting pretty obscene.  i remember when it was 10K
18:12:41 <sproingie> i guess if you're writing a load balancer or something
18:13:01 <c_wraith> yeah, a proxy of any sort might easily want that many sockets
18:13:35 <jrockway_> 100k is a lot of people
18:13:41 <sproingie> more than 30K or so fd's and you almost certainly have to tweak the OS to allow more
18:13:47 <tomoj> if I don't need that many, can I get away with hundreds now?
18:13:59 <jrockway_> that makes sense
18:14:06 <jrockway_> but anyway, about "useful work"
18:14:11 <jrockway_> most sockets just sit idle
18:14:14 <jrockway_> think about push imap, etc.
18:14:40 <sproingie> sometimes as simple as a ulimit, other annoying limits are lying around in various places
18:15:57 <sproingie> just selecting an active socket out of tens of thousands of idle ones will spike CPU like mad with a simple select
18:16:19 <theorbtwo> sproingie: ...which is why you use poll, not select.
18:16:21 <sproingie> busting cache just to load the fd set, etc
18:16:39 <theorbtwo> sproingie: Even when you have a couple of dozen, the difference is noticable.
18:16:50 <theorbtwo> (Well, noticiable on a graph designed to show off the effect...)
18:16:51 <sproingie> well /dev/poll anyway.  poll as sysv specifies it can't ever scale
18:17:18 <jrockway_> the key is to use some library that handles that for you :)
18:17:26 <sproingie> and since /dev/poll is a nasty hack, we have nicer things like kqueue or epoll
18:17:33 <jrockway_> 'cause basically, every OS' implementation is broken in some different way
18:17:46 <jrockway_> (or so the libev manpage suggests...)
18:17:51 * Eduard_Munteanu untargzips House
18:18:11 <jrockway_> then again, i don't think the author of EV has ever seen something that isn't "unusably-broken" ;)
18:22:09 <Eduard_Munteanu> Argh, no Haskell support in (my) exuberant-ctags.
18:23:11 <Eduard_Munteanu> Suggestions?
18:24:17 <jrockway> ghci can generate a tags file
18:25:00 <jrockway> if that is inadequate, i think ctags can accept a list of regexes
18:25:03 <jrockway> which might be Good Enough
18:25:22 <jrockway> ^([a-z]\w+) == function
18:25:23 <jrockway> etc.
18:25:59 <Eduard_Munteanu> :ctags [<file>]             create tags file for Vi (default: "tags")
18:26:08 <Eduard_Munteanu> jrockway, thanks, I'll try the ghci stuff.
18:26:21 <aavogt> also hasktags
18:26:31 <aavogt> which is probably the same as :ctags
18:27:08 <jrockway> i like the slime-style approach haskell-mode uses; just ask ghci every time a tag is requested
18:27:09 <Eduard_Munteanu> aavogt, hm, hasktags looks better, I might be able to run it recursively in some dir.
18:27:12 <jrockway> that way it is always up to date
18:27:42 <jrockway> (and for perl, i have a process that runs in the background and keeps TAGS up to date :)
18:27:43 <Eduard_Munteanu> jrockway, hm, can I do that in vim?
18:27:59 <jrockway> probably
18:28:29 <Eduard_Munteanu> Yeah, I'm reluctant to switch to Yi or other stuff for Haskell.
18:28:40 <jrockway> there is this vim mode called taglist that generates the tag list every time you ask for the list
18:28:54 <jrockway> (and amusingly, horribly misparses ctags...)
18:29:25 <Eduard_Munteanu> jrockway, yeah, that might be suboptimal in some cases. I'm quite sure that won't work well when working with stuff like the Linux kernel tree :)
18:29:35 <jrockway> you'd be surprised
18:29:52 <jrockway> it annoyed me because i was trying to set up a coworker with my auto-generate-in-the-background-script
18:30:01 <jrockway> but we couldn't get vim to parse its own file format
18:30:16 <jrockway> so eventually i make a client that connects to the server over a socket, and gets the tags for the requested file in the "right" format
18:30:20 <jrockway> * made
18:30:31 <jrockway> incidentally, the client is written in haskell ;)
18:30:38 <Eduard_Munteanu> Oh.
18:55:38 <o-_-o> Morning folks
18:55:58 <ski> night, o-_-o
18:56:25 <o-_-o> heh...
18:56:37 <o-_-o> Good night ski
19:01:39 <kmc> hi
19:02:07 <mreh> hello
19:02:24 <arw> hi. i'm looking for something to parse C.
19:02:32 <mreh> haskell.org says we all know each other in here, I've never met anyone in here in my life
19:02:40 <mreh> as far a I know...
19:02:42 <c_wraith> @hoogle Language.C
19:02:43 <lambdabot> Language.Haskell.TH data Callconv
19:02:43 <lambdabot> Language.Haskell.TH.Syntax data Callconv
19:02:43 <lambdabot> Language.Haskell.TH CaseE :: Exp -> [Match] -> Exp
19:02:47 <arw> thx.
19:02:53 <o-_-o> I've friends on IRC,whom I invited to my marriage
19:02:56 <arw> i thought i overlooked something :)
19:02:58 <c_wraith> There doesn't appear to be a Language.C
19:03:15 <o-_-o> but of course they were too far away and didn't turn up
19:03:28 <o-_-o> but still...
19:03:41 <o-_-o> hey bran
19:03:45 <jrockway> there are not enough haskell conferences :)
19:03:48 <jrockway> then we could all meet in real life
19:03:55 <o-_-o> heh...true
19:04:21 <o-_-o> if anyone is in Bangalore dial me up and we can go for dinner or something
19:04:51 <kmc> http://hackage.haskell.org/package/language-c ?
19:06:14 <mreh> > "> it"
19:06:15 <lambdabot>   "> it"
19:06:22 <mreh> > print "> it"
19:06:23 <lambdabot>   <IO ()>
19:06:32 <mreh> I'm trying to crash lambdabot
19:06:45 <c_wraith> lambdabot isn't ghci
19:06:53 <c_wraith> there's no special it variable
19:07:19 <mreh> can I make here instruct herself in an infinite loop of printing instructions
19:07:30 <c_wraith> not likely
19:07:34 <c_wraith> since all her output starts with a space
19:08:08 <mreh> > concat . map (takeWhile (/= '>')) . lines "Test comment\n Hello mum >I'm on the telly"
19:08:09 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
19:08:09 <lambdabot>         against inferred ty...
19:08:16 <mreh> > concat . map (takeWhile (/= '>')) . lines $ "Test comment\n Hello mum >I'm on the telly"
19:08:17 <lambdabot>   "Test comment Hello mum "
19:08:27 <mreh> oh
19:08:37 <tomoj> :)
19:08:41 <mreh> > intercalate '\n' . map (takeWhile (/= '>')) . lines $ "Test comment\n Hello mum >I'm on the telly"
19:08:42 <lambdabot>   Couldn't match expected type `[a]'
19:08:42 <lambdabot>         against inferred type `GHC.Types...
19:08:49 <mreh> :t intercalate
19:08:50 <lambdabot> forall a. [a] -> [[a]] -> [a]
19:09:06 <mreh> > intercalate "\n" . map (takeWhile (/= '>')) . lines $ "Test comment\n Hello mum >I'm on the telly"
19:09:07 <lambdabot>   "Test comment\n Hello mum "
19:09:25 <mreh> @hoogle a -> [a] -> [a]
19:09:26 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
19:09:26 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
19:09:26 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
19:09:40 <mreh> > intersperse '\n' . map (takeWhile (/= '>')) . lines $ "Test comment\n Hello mum >I'm on the telly"
19:09:41 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
19:09:41 <lambdabot>         against inferred type...
19:09:55 <o-_-o> How are the . and $ operator different ?
19:10:03 <mreh> they do different things
19:10:06 <MoALTz> @type .
19:10:07 <lambdabot> parse error on input `.'
19:10:07 <MoALTz> @type $
19:10:08 <lambdabot> parse error on input `$'
19:10:09 <aavogt> @src (.)
19:10:09 <lambdabot> (f . g) x = f (g x)
19:10:12 <MoALTz> @type ($)
19:10:13 <lambdabot> forall a b. (a -> b) -> a -> b
19:10:14 <aavogt> @src ($)
19:10:14 <lambdabot> f $ x = f x
19:10:25 <aavogt> types and implementations are different
19:10:36 <MoALTz> @type (.)
19:10:36 <o-_-o> ah...
19:10:37 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
19:10:40 <mreh> $ is pretty trivial, but it's real use is as the lowest fixty operator
19:10:50 <o-_-o> fixty ?
19:10:53 <tomoj> also treating function application as a function, yes?
19:10:55 <tensorpudding> (.) is just fmap
19:11:06 <mreh> tensorpudding: don't confuse him
19:11:14 <jrockway> ap = liftA ($) is also enlightening
19:11:17 <tensorpudding> well, according to lambdabot
19:11:25 <o-_-o> fixty. A person who joined Digg on January 20th, 2007 ?
19:11:30 <aavogt> what is this liftA, jrockway?
19:11:56 <aavogt> liftA = liftA2, to get ap, but liftA sounds more like fmap
19:11:56 <mreh> fixity is how sticky an operator is, functions included, also known as the precedence
19:12:03 <jrockway> yeah, i mistyped
19:12:07 <tensorpudding> fixity is like order of operations
19:12:13 <MoALTz> > (show . id) 5
19:12:14 <lambdabot>   "5"
19:12:20 <MoALTz> @type (show . id)
19:12:21 <lambdabot> forall a. (Show a) => a -> String
19:12:37 <MoALTz> @type (. id)
19:12:38 <lambdabot> forall a b. (a -> b) -> a -> b
19:12:47 <MoALTz> @type ($)
19:12:48 <lambdabot> forall a b. (a -> b) -> a -> b
19:13:11 <tomoj> > map ($5) [(1+), (3-)]
19:13:12 <lambdabot>   [6,-2]
19:13:14 <o-_-o> but...
19:13:17 <mreh> basically nothing sticks to ($) so it is applied to everything to the right and left of it
19:13:21 <tomoj> heh, is that gross?
19:13:24 <o-_-o> > show $ id 5
19:13:25 <lambdabot>   "5"
19:13:27 <tomoj> I am a still new to haskell
19:13:31 <o-_-o> > show . id 5
19:13:32 <lambdabot>   Ambiguous type variable `a' in the constraint:
19:13:32 <lambdabot>    `GHC.Show.Show a'
19:13:32 <lambdabot>      ar...
19:13:37 <o-_-o> > (show . id) 5
19:13:38 <lambdabot>   "5"
19:13:40 <tensorpudding> > ($ 5) <$> [succ, id, pred]
19:13:40 <lambdabot>   [6,5,4]
19:13:43 <aavogt> > sequence [(1+), (3-)] 5
19:13:44 <lambdabot>   [6,-2]
19:14:06 <tomoj> nice
19:14:07 <aavogt> > [(1+), (3-)] `sequence` 5 -- or as such?
19:14:08 <lambdabot>   [6,-2]
19:14:23 <tomoj> I didn't know (<$>) or sequence
19:14:33 <mreh> o-_-o, read about operator precedence and use ghci to look at the operator precedence of some operators
19:14:36 <aavogt> <$> = fmap
19:14:42 <o-_-o> mreh, ok
19:14:44 <mreh> what's the precedence of function application? is it 1?
19:14:48 <tomoj> oh, I read about fmap but didn't really grok
19:14:57 <o-_-o> mreh, function application is the highest
19:14:59 <tensorpudding> > zipWith (<$>) (repeat succ) [Just 1, Just 2, Just 3]
19:14:59 <c_wraith> no, function application is approximately -1
19:15:00 <lambdabot>   [Just 2,Just 3,Just 4]
19:15:03 <o-_-o> mreh, the space operator
19:15:11 <c_wraith> record syntax is -2, though
19:15:25 <MoALTz> > 5 ((+) . (*5)) 7
19:15:26 <lambdabot>   Ambiguous type variable `a' in the constraint:
19:15:27 <lambdabot>    `GHC.Num.Num a'
19:15:27 <lambdabot>      aris...
19:15:35 <aavogt> c_wraith: aren't lower numbers more weakly binding?
19:15:42 <c_wraith> err, right.
19:15:45 <c_wraith> ok, yes.
19:15:49 <c_wraith> function application is 10
19:15:52 <mreh> aavogt ($) is like 7
19:15:54 <aavogt> infixr 0 $
19:15:58 <c_wraith> record update syntax is 11
19:16:07 <tensorpudding> fixity goes up to 11
19:16:17 <MoALTz> > 5 (replicate) 't'
19:16:18 <lambdabot>   No instance for (GHC.Num.Num
19:16:18 <lambdabot>                     ((GHC.Types.Int -> a -> [a...
19:16:36 <tensorpudding> @type replicate
19:16:37 <lambdabot> forall a. Int -> a -> [a]
19:16:41 <mreh> i didn't mean ($) function application :D I mean't... function application!
19:16:43 <MoALTz> > 5 `(replicate)` 't'
19:16:44 <lambdabot>   <no location info>: parse error on input `('
19:16:46 <aavogt> > let infixr 11 oO; oO = (+) in 1 `oO` 2 * 3
19:16:47 <lambdabot>   <no location info>: Precedence out of range
19:16:49 <MoALTz> a pitty
19:16:54 <aavogt> > let infixr 10 oO; oO = (+) in 1 `oO` 2 * 3
19:16:55 <lambdabot>   <no location info>: Precedence out of range
19:16:56 <tensorpudding> > 5 `replicate` 't'
19:16:57 <lambdabot>   "ttttt"
19:17:02 <aavogt> > let infixr 9 oO; oO = (+) in 1 `oO` 2 * 3
19:17:02 <lambdabot>   <no location info>: parse error on input `oO'
19:17:11 <o-_-o> @remember tensorpudding fixity goes up to 11
19:17:11 <lambdabot> Nice!
19:17:12 <MoALTz> tensorpudding: wanted to see if i could infix more complicated stuff
19:17:31 <aavogt> > let infixr 9 `oO` ; oO = (+) in 1 `oO` 2 * 3
19:17:32 <lambdabot>   9
19:18:08 <mreh> why don't you just make 10 one more fixity and use that?
19:18:23 <aavogt> why make fixities bounded at all?
19:19:08 <MoALTz> > show {5}
19:19:09 <lambdabot>   <no location info>: parse error on input `5'
19:19:33 <tensorpudding> > show (+5)
19:19:34 <lambdabot>   "{-3->2;-2->3;-1->4;0->5;1->6;2->7;3->8}"
19:19:58 <tensorpudding> hmm, interesting
19:20:06 <tensorpudding> > show not
19:20:07 <lambdabot>   "{True->False;False->True}"
19:20:19 <kmc> Agda has... 100 fixities?
19:20:38 <kmc> you could make them rational numbers
19:21:09 <tensorpudding> > show (\() -> ())
19:21:10 <lambdabot>   "{()->()}"
19:21:33 <kmc> > id
19:21:34 <lambdabot>   {()->()}
19:21:45 <tensorpudding> > show (return :: a -> [a])
19:21:45 <lambdabot>   "{()->[()]}"
19:22:08 <kmc> > show succ
19:22:09 <lambdabot>   "* Exception: Prelude.Enum.().succ: bad argument
19:22:14 <aavogt> *> let infix 0 `rock`; infix 1 `paper`; infix 2 `scissors`; ...
19:22:30 <tomoj> @type ap
19:22:31 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
19:22:41 <tensorpudding> > show fmap
19:22:42 <lambdabot>   No instances for (Test.SmallCheck.Serial (f a),
19:22:42 <lambdabot>                    GHC.Show...
19:22:45 <tomoj> I can't understand this type
19:22:51 <monochrom> Enjoy more: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=6356#a6451
19:23:02 <kmc> tomoj, which part?
19:23:02 <tensorpudding> > show map
19:23:03 <lambdabot>   "{{()->()}->{[]->[];[()]->[()];[(),()]->[(),()];[(),(),()]->[(),(),()]}}"
19:23:14 <jrockway> > (1+) <$> (1,2)
19:23:15 <lambdabot>   (1,3)
19:23:19 <tomoj> kmc: well, both. the forall and * * stuff which isn't in the paper I'm reading, and the type itself
19:23:29 <tomoj> it takes a function from a to b wrapped in a monad, yes?
19:23:38 <tensorpudding> fmap doesn't always do what you think it will
19:23:47 <kmc> tomoj, it takes a monadic value that yields a function, and applies it monadically
19:23:54 <kmc> compare to fmap
19:23:55 <kmc> :t fmap
19:23:56 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
19:24:11 <kmc> same, except the first arg is ´a -> bª instead of ´f (a -> b)ª
19:24:18 <jrockway> > (+) <$> (1,2) <*> (3,4)
19:24:19 <lambdabot>   Ambiguous type variable `t' in the constraints:
19:24:19 <lambdabot>    `Data.Monoid.Monoid t'
19:24:19 <lambdabot>  ...
19:24:20 <tomoj> tensorpudding: that's ski?
19:24:40 <tomoj> ok, in this paper they do   return (:) `ap` c `ap` sequence cs
19:24:46 <kmc> tomoj, forall is a GHC extension.  in Haskell 98 all type variables get an implicit "forall"
19:24:46 <tomoj> OH
19:24:48 <tensorpudding> ugh, interlag
19:25:04 <tensorpudding> what i said was meant in response to jrockway's thing
19:25:05 <tomoj> my poisoning by other languages keeps making me think that return binds weakly
19:25:09 <kmc> tomoj, return f `ap` a `ap` b `ap` c     ===>    liftM3 f a b c
19:25:18 <kmc> right, return is a normal function
19:25:35 <tomoj> tensorpudding: ok, but is that an SKI rendering of fmap?
19:25:37 <jrockway> tensorpudding: yeah, that's interesting
19:25:43 <kmc> tomoj, these days you may see it instead with Applicative operators:   f <$> a <*> b <*> c
19:25:44 <tensorpudding> SKI?
19:25:50 <tensorpudding> as in the combinators?
19:25:51 <jrockway> i needed a quad today and defined my own applicative instance, which does what i think :)
19:25:56 <tensorpudding> I have no idea
19:26:00 <tomoj> I thought it was applying ap to (:)
19:26:08 <jrockway> f <$> (a,b,c,d) = (f a, f b, f c, f d)
19:26:12 <tomoj> oh, what's that {[[{}{}[{})){} crap?
19:26:22 <kmc> tomoj, lambdabot has a Show instance for funcions
19:26:25 <kmc> > (+ 3)
19:26:26 <lambdabot>   {-3->0;-2->1;-1->2;0->3;1->4;2->5;3->6}
19:26:30 <tensorpudding> (,,,) is not a functor normally
19:26:39 <kmc> it picks a few small values and shows you how the function maps them
19:26:41 <jrockway> i noticed
19:26:44 <jrockway> it is a monoid, oddly
19:26:47 <tomoj> oh, I see
19:26:57 <tensorpudding> also, it's only a functor in the last position, because of the types
19:26:59 <tomoj> so for map picked a bunch of void and tuples?
19:27:15 <kmc> tomoj, it defaults to the type ()
19:27:20 <kmc> based on the ad hoc defaulting rules
19:27:25 <mreh> how do you get at Either a b values easily? there are no fromLeft fromRight functions
19:27:28 <kmc> () is "unit" not "void"
19:27:30 <mreh> i'm just going to make my own
19:27:32 <kmc> mreh, pattern matching!
19:27:33 <tomoj> oh, whoops
19:27:33 <tensorpudding> when the type is highly polymorphic, it defaults to (), then to [()], and other things
19:27:40 <tomoj> I see
19:27:47 <tomoj> I thought I heard you could compile haskell into SKI somewhere
19:27:53 <kmc> tomoj, you could in theory...
19:27:54 <mreh> can I pattern match in a Case?
19:28:00 <tensorpudding> mreh: what will fromLeft do on a Right "foo"?
19:28:04 <kmc> mreh, that's all ´caseª does
19:28:04 <jrockway> its algorithm seems a lot like quickcheck's
19:28:09 <kmc> (i guess it does guards too)
19:28:22 <mreh> tensorpudding: die
19:28:34 <dino-> mreh: There's an either function too
19:28:34 <tensorpudding> that doesn't sound terribly useful
19:28:37 <kmc> > let f x = case x of { Left _ -> "left!"; Right _ -> "right :(" } in map f [Left 3, Right 17, Left 0]
19:28:38 <lambdabot>   ["left!","right :(","left!"]
19:28:44 <mreh> tensorpudding: use fromLeft and fromRight with etiher
19:28:56 <mreh> dino- I'm way ahead of you :)
19:29:18 <kmc> :t either
19:29:19 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
19:29:22 <mreh> kmc, but right is good!
19:29:36 <mreh> Right is right, that's what I say!
19:29:39 <kmc> mreh, says you (and Control.Monad.Error)
19:29:44 <kmc> i take issue wit that instance though
19:30:12 <mreh> either error fromRight is what i'm thinking
19:30:18 <kmc> :t either error fromRight
19:30:19 <mreh> or just either error id
19:30:19 <lambdabot> Not in scope: `fromRight'
19:30:23 <kmc> :t either error id
19:30:24 <lambdabot> forall b. Either [Char] b -> b
19:30:29 <kmc> indeed, that's useful
19:30:31 <tensorpudding> hmm
19:30:32 <kmc> as is
19:30:38 <kmc> :t either (error. show) id
19:30:39 <lambdabot> forall a b. (Show a) => Either a b -> b
19:30:45 <tensorpudding> > (1,2) `mappend` mzero
19:30:46 <lambdabot>   No instance for (Control.Monad.MonadPlus ((,) t))
19:30:46 <lambdabot>    arising from a use of ...
19:30:48 <mreh> woop!!
19:31:28 <aavogt> > mempty `asTypeOf` (First Nothing,Last Nothing)
19:31:29 <lambdabot>   (First {getFirst = Nothing},Last {getLast = Nothing})
19:33:09 <mreh> I've stayed up until three doing haskell again
19:34:04 <mreh> :t ParseError
19:34:05 <lambdabot> Not in scope: data constructor `ParseError'
19:34:43 <mreh> @src ParseError
19:34:43 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
19:34:44 <mreh> pardon
19:34:56 <jrockway> haha
19:35:26 <tensorpudding> haskell is more important than sleep
19:36:01 <monochrom> mreh: That's OK, I stayed up until 5pm recently to hack continuations. :)
19:36:03 <aavogt> strong static typing is not a substitute for sleep
19:36:18 <monochrom> @remember aavogt strong static typing is not a substitute for sleep
19:36:18 <lambdabot> Done.
19:37:31 <mreh> monochrom: did you not go to sleep and head off to work?
19:37:41 <mreh> or are you a PhD student
19:38:28 <monochrom> I admit if I had to go to work, I would have disciplined myself not to do it.
19:38:56 <mreh> I always get my Haskell on at 1pm, it's bizzare
19:39:25 <aavogt> I've had some moments with haskelldb recently
19:39:38 <mreh> sexual moments?
19:39:56 <aavogt> all the typeclasses make it tough to see what's going on at first
19:40:43 <mreh> heh, my parser says it's parsed the file before it has fully evaluated the expression
19:40:45 <mreh> halp!
19:41:21 <monochrom> Oh heh. I read the academic paper and it talked about the types first before it talked about how to use the API, so I was fine.
19:41:23 <aavogt> mreh: bang patterns?
19:41:32 <mreh> aavogt: what are those?
19:41:51 <aavogt> oh, I'm just playing with you
19:42:16 <mreh> !bang
19:42:24 <aavogt> but maybe it would make sense to make your AST strict?
19:42:32 <aavogt> or write a NFData instance?
19:42:35 <aavogt> @type rnf
19:42:36 <lambdabot> forall a. (NFData a) => a -> Done
19:42:57 <mreh> I didn't understand most of that
19:43:15 <aavogt> what does your parser do?
19:43:16 <mreh> NF... sounds like something I did in my undergrad
19:43:24 <mreh> FSM?
19:43:27 <aavogt> normal form or some such
19:43:34 <aavogt> means fully evaluated
19:44:01 <mreh> it parses a chord chart and makes it into a data structure that represents the semantics of that chart in an abstract way
19:44:45 <mreh> I modified it from lament's code
19:48:27 <mreh> I've just finished a three month job
19:48:42 <mreh> thank goodness for that
20:07:26 <merehap> ikefruusto: did you ever get your stack overflow problem figured out?
20:08:57 <ikefruusto> merehap: not yet
20:09:16 <ikefruusto> merehap: I came here to ask a different question
20:09:19 <merehap> :(
20:09:41 <juhp> [30 of 30] Compiling Language.Haskell.HLint ( src/Language/Haskell/HLint.hs, dist/build/Language/Haskell/HLint.dyn_o )
20:09:41 <juhp>  /usr/bin/ld: dist/build/CmdLine.dyn_o: relocation R_X86_64_PC32 against undefined symbol `hlintzm1zi6zi15_Pathszuhlint_version1_closure' can not be used when making a shared object; recompile with -fPIC
20:09:50 <juhp> anyone hit this?
20:10:06 <juhp> guess not so many using shared libs yet...?
20:13:16 <ikefruusto> is there a common name for "(a -> a -> b) -> a -> b"? Something like "binaryToUnary" or "withSelf"? Example: "square = withSelf (*)"
20:13:40 <merehap> @hoogle (a -> a -> b) -> a -> b
20:13:40 <lambdabot> Data.Foldable foldl1 :: Foldable t => (a -> a -> a) -> t a -> a
20:13:40 <lambdabot> Data.Foldable foldr1 :: Foldable t => (a -> a -> a) -> t a -> a
20:13:40 <lambdabot> Prelude foldl1 :: (a -> a -> a) -> [a] -> a
20:14:21 <ikefruusto> merehap: cool trick
20:14:27 <merehap> hm, I know there is, can't remember right now though
20:14:54 <dibblego> join
20:15:06 <merehap> :t join
20:15:06 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
20:15:21 <dibblego> > let square = join (*) in square 3
20:15:22 <lambdabot>   9
20:15:29 <merehap> @src join
20:15:29 <lambdabot> join x =  x >>= id
20:16:46 <dibblego> let m = (t ->) in m (m a) -> m a
20:16:55 <dibblego> (t -> (t -> a)) -> (t -> a)
20:17:11 <tensorpudding> > join (Just Nothing)
20:17:11 <lambdabot>   Nothing
20:17:43 <aavogt> > join `asTypeOf` fromJust
20:17:44 <lambdabot>   {Nothing->Nothing;Just Nothing->Nothing;Just (Just ())->Just ()}
20:25:42 <ikefruusto> dibblego, aavogt: interesting, thank you.
20:26:44 <ikefruusto> dibblego: I'm having trouble getting your example to work in ghci: "No instance for (Monad ((->) a))"
20:26:54 <aavogt> import Control.Monad.Instances
20:26:56 <dibblego> :m + Control.Monad.Instances
20:27:46 <ikefruusto> merci
20:31:52 <hydo> A question in handy, portable "Gist" form!  http://gist.github.com/283507
20:33:40 <o-_-o> is there anything like the C operator (issomething) ?True goes here :false here in haskell ?
20:33:50 <aavogt> hydo: comment out the type signature for rpTemplate
20:34:10 <aavogt> @type (??)
20:34:10 <lambdabot> Not in scope: `??'
20:34:32 <dibblego> o-_-o, if/then/else
20:34:38 <o-_-o> dibblego, :-) ok
20:34:52 <aavogt> > let p (??) x = \y -> if p then x else y in (True ?? "hai") "bye"
20:34:53 <lambdabot>   Not in scope: `??'
20:35:03 <aavogt> > let p ?? x = \y -> if p then x else y in (True ?? "hai") "bye"
20:35:04 <lambdabot>   "hai"
20:35:16 <mreh> > if' True "hello" "go away"
20:35:17 <lambdabot>   "hello"
20:35:24 <aavogt> > let p ?? x = \y -> if p then x else y in True ?? "hai" $ "bye"
20:35:25 <lambdabot>   "hai"
20:35:42 <hydo> aavogt: Thanks!  Is there no way to keep a type signature of any sort?  Compiler warnings make me twitch.  Don't get me wrong, I don't want to come off as complaining.
20:36:01 <aavogt> that's because your type signature was wrong
20:36:58 <hydo> ah, ok.  What should it have been?  I want to be able to make types and throw them at that function and have it work so long as the types derive typeable.  Am I not approaching it right?
20:36:59 <aavogt> you claim that   args :: [(String,a)], while you use it as  [(String, LoggedInUser)]
20:37:34 <hydo> oh... I think I see.
20:38:21 <aavogt> the other way around would work
20:39:06 <aavogt> > let x = undefined :: a; in x :: Int
20:39:07 <lambdabot>   * Exception: Prelude.undefined
20:39:12 <aavogt> > let x = undefined :: Int; in x :: a
20:39:13 <lambdabot>   Couldn't match expected type `a'
20:39:13 <lambdabot>         against inferred type `GHC.Types.I...
20:39:53 <hydo> I think I need to read the stringtemplate wiki page again.
20:39:58 <hydo> Thanks for the help, aavogt
20:40:10 <aavogt> no problem
20:40:43 <o-_-o> is there a map with a skip ?
20:41:14 <o-_-o> [[2,7,4,9,10,45,0,-1,-5,3,5,7] <- I want to go 0,2,4,6,8th element etc
20:42:07 <aavogt> > zipWith (\b x -> if b then succ x else x) (cycle [True,False]) [0..]
20:42:08 <lambdabot>   [1,1,3,3,5,5,7,7,9,9,11,11,13,13,15,15,17,17,19,19,21,21,23,23,25,25,27,27,...
20:43:12 <o-_-o> wow...
20:43:23 <o-_-o> ok...that code is way beyond my comprehension
20:43:51 <hydo> o-_-o: the important part, I think, is 'cycle'
20:44:11 <o-_-o> hydo, yeah...I am reading up cycle
20:44:11 <hydo> which gives true then false then true then.... and so on?
20:44:20 <aavogt> > flip evalState True $ mapM (\x -> do b <- get; modify not; return $ if b then negate x else x) [0..]
20:44:21 <lambdabot>   [0,1,-2,3,-4,5,-6,7,-8,9,-10,11,-12,13,-14,15,-16,17,-18,19,-20,21,-22,23,-...
20:45:26 <tensorpudding> @type get
20:45:27 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => m s
20:46:01 <aavogt> the zipWith is probably more declarative
20:46:08 <Axman6> :t ask
20:46:09 <lambdabot> forall (m :: * -> *) r. (MonadReader r m) => m r
20:46:29 <Axman6> @src Reader (>>=)
20:46:29 <lambdabot> Source not found. Maybe if you used more than just two fingers...
20:46:32 <Axman6> :(
20:47:05 <aavogt> @nixon
20:47:05 <lambdabot> Americans admire a people who can scratch a desert and produce a garden. The Israelis have shown qualities that Americans identify with: guts, patriotism, idealism, a passion for freedom. I have
20:47:06 <lambdabot> seen it. I know. I believe that.
20:56:40 <o-_-o> so List.sort sorts from low to high, is there a reverse ?
20:56:42 <tomoj> what if you wrote a free theorem prover and had it prove theorems about itself
20:57:23 <aavogt> o-_-o: sortBy (flip compare)
20:57:39 <merehap> @seen lostlogic
20:57:39 <lambdabot> Unknown command, try @list
20:58:20 <merehap> ?seen lostlogic
20:58:20 <lambdabot> Unknown command, try @list
20:58:31 <merehap> ugh, what is that command?
20:58:35 <aavogt> preflex: seen lostlogic
20:58:35 -preflex(n=preflex@95-88-118-220-dynip.superkabel.de)- Sorry, I haven't seen lostlogic
20:58:47 <merehap> thanks aavogt
21:03:39 <ddarius> tomoj: The input to a free theorem generator takes types but is itself a program.
21:04:38 <o-_-o> hmmm...when I try to search haskell libraries both firefox and chrome hang
21:07:04 <c_wraith> o-_-o: dhtml doesn't work well for data sets that big.  search with hoogle or hayoo instead
21:07:48 <solrize> > mfix Maybe
21:07:49 <lambdabot>   Not in scope: data constructor `Maybe'
21:07:54 <solrize> > mfix Just
21:07:58 <lambdabot>   mueval-core: Time limit exceeded
21:12:54 <monochrom> See http://www.haskell.org/haskellwiki/MonadFix for mfix
21:14:34 <solrize> thanks, that's clearer than what i was reading (typeclassopedia)
21:14:50 <solrize> well, more detailed anyway
21:29:28 <solrize> http://www.google.com/search?q=monad+burrito    ==>  14,000 google hits.  threshhold of immortality?
21:32:47 <merehap> I was trying to avoid looking at that, but I guess I'll have to now...
21:32:52 <monochrom> Blogs are contagious.
21:39:55 <tomoj> ddarius: ah, yes
21:40:15 <tomoj> if only it were a selfinhabiting type
21:52:50 <kmc> :O
21:52:59 <kmc> selfinhabiting types
21:55:02 <monochrom> data Void is self-inhibiting type
21:56:46 <dolio> What?
22:14:02 <dolio> Hey guys, [Char] is slower than C's char*. What do I do!?
22:14:19 <Axman6> use bytestrings
22:14:28 <ddarius> dolio: Rewrite your program in assembly.
22:14:34 <Axman6> they practically are C strings
22:15:44 <c_wraith> ddarius: You're on the righ path, but you could take it further.
22:16:10 <arw> or lazy bytestrings if you are worried about memory consumption.
22:21:50 <Draconx|Laptop> c_wraith, verilog RTL?
22:22:31 <c_wraith> sounds good.  any program worth writing is worth putting in hardware, right?
22:22:51 <ddarius> If only we could actually write those programs worth writing.
22:22:55 <arw> please. not on an empty stomach...
22:23:16 <c_wraith> I just bought a new ls coprocessor for my machine!
22:23:44 <o-_-o> what is ls co-processor ?
22:23:54 <c_wraith> ... a joke.
22:23:55 <arw> and verilog is for wussies. real men[tm] use a soldering iron...
22:24:01 <ddarius> Someone doesn't use *nix...
22:24:04 <tomoj> say I have some haskell code which compiles a file into some haskell code
22:24:30 <tomoj> can I call this haskell code, then in the same runtime recompile the new code?
22:24:43 <tomoj> (and load it)
22:25:07 <o-_-o> tomoj like a parser ?
22:25:11 <tomoj> seems I can do it with the GHC library I guess
22:25:20 <tomoj> a parser for a file format which generates haskell code, yes
22:25:35 <o-_-o> http://bloggingmath.wordpress.com/2010/01/20/writing-a-compiler-in-haskell-compiler-series-part-i/
22:25:40 <tomoj> (a parser for a file format) which generates haskell code
22:26:03 <o-_-o> hutton has a chapter on writing parsers in haskell
22:26:07 <tomoj> thanks, looks great
22:26:20 <tomoj> I also need to figure out how to load the newly compiled code
22:26:46 <o-_-o> tomoj, what are you trying to do ?
22:27:30 <c_wraith> tomoj: I'm betting hint is a library you'd find useful
22:27:36 <c_wraith> @hackage hint
22:27:36 <lambdabot> http://hackage.haskell.org/package/hint
22:28:09 <tomoj> I want to write a protobuf library for haskell
22:28:25 <tomoj> http://code.google.com/apis/protocolbuffers/docs/overview.html
22:28:47 <tomoj> so I need to parse the .proto file and generate haskell code from this programatically, and then compile and dynamically load this new code
22:28:51 <ddarius> tomoj: There is one already by the way.
22:28:55 <tomoj> oh, great
22:29:08 <tomoj> I thought to check google but forgot in my excitement about the implementation
22:29:39 <c_wraith> Huh.  You'd rather implement that with a translate/compile/execute cycle than a simple interpreter?
22:29:56 <tomoj> yes, I think
22:29:59 <tomoj> though I may be wrong
22:30:10 <tomoj> my idea was that the .proto file would generate data types
22:30:21 <ddarius> @hackage hproto
22:30:22 <lambdabot> http://hackage.haskell.org/package/hproto
22:30:22 <tomoj> so that these .proto message types would go into the type system
22:30:27 <ddarius> @hackage hprotoc
22:30:28 <lambdabot> http://hackage.haskell.org/package/hprotoc
22:30:32 <tomoj> I found http://hackage.haskell.org/package/protocol-buffers
22:31:05 <tomoj> also it would generate parsing and serializing
22:31:10 <tomoj> (functions)
22:31:13 <c_wraith> regardless of all of this, I do recommend checking out hint.  It's a pretty awesome library
22:31:16 <o-_-o> where would I use protocol buffers ?
22:31:21 <tomoj> I see the hackagedb package does this
22:31:33 <tomoj> I want to use them to send data between haskell nodes
22:31:45 <tomoj> with the ability to easily communicate to python and the jvm
22:31:56 <o-_-o> o_0
22:31:57 <tomoj> (I imagined also writing or finding a clojure library)
22:32:06 <arw> o-_-o: communication. yet another method of rpc or passing data...
22:32:21 <o-_-o> arw, ah..ok
22:32:31 <o-_-o> tomoj, something like erlang ?
22:32:39 <arw> o-_-o: the marketing says "like xml, only better"
22:32:49 <tomoj> the idea is to write a distributed database in haskell and access it from python or clojure clients
22:32:59 <tomoj> (or ObjC? dalvik?)
22:33:10 <o-_-o> arw, yeah I read that, I am not entirely convinced, it might look simpler, but so does yaml
22:33:15 <tomoj> erlang was my top choice until I thought of this protobuf idea
22:33:32 <o-_-o> tomoj, you can use erlang with haskell I think
22:33:37 <tomoj> because now the docs are typechecked, and I don't have to work around couchdb's shortcomings for my problem
22:33:43 <kmc> seven is the largest prime number
22:33:44 <ddarius> I don't think protocol buffers cover the same area as XML...
22:33:51 <tomoj> yes, but I'd rather write a database from scratch in haskell than in erlang
22:33:55 <tomoj> considering happstack-state
22:34:11 <o-_-o> http://www.haskell.org/haskellwiki/Applications_and_libraries/Interfacing_other_languages/Erlang
22:34:11 <c_wraith> kmc: that's no surprise, given that 10 is the largest number, and everyone knows 8, 9, and 10 are composite
22:34:55 <arw> o-_-o: i'm not really convinced either. most of it just looks like "uh, we just reinvented asn.1 or sunrpc".
22:35:11 <o-_-o> arw, yeah...true
22:36:05 <jrockway> this is nice: if you pass this C library an empty string, windows pops up a dialog box saying "Due to security restrictions in effect, Windows has canceled this action"
22:36:11 <jrockway> and then the function returns 2
22:36:16 <jrockway> and the program continues running
22:36:34 <kmc> 2 is the loneliest number
22:36:39 <jrockway> unsafePerformIO indeed...
22:36:44 <kmc> ehehehehe
22:38:03 <jrockway> i am trying to imagine what the code must be like
22:38:18 <jrockway> maybe while ( ++*p ) { ... }
22:38:27 <jrockway> so that is ++s past the first byte, which is nul
22:38:29 <jrockway> *sigh*
22:38:41 <jrockway> this is why i give people weird looks when they say "i'm going to write my application in C!"
22:38:55 <kmc> language of kings
22:39:02 <Twey> jrockway: Hahaha!
22:39:17 <jrockway> it's so fast!
22:39:33 <jrockway> it gets the wrong answer really, really quickly!
22:41:18 <arw> stupid people write broken code in any language. at least in C you quickly see the broken parts :)
22:41:54 <jrockway> at least when you are binding C to a high-level language you can abstract away the badness
22:41:59 <jrockway> Left "No empty strings, sorry"
22:42:16 <arw> that is very dangerous.
22:42:41 <arw> many people who used java thought so and got burned badly.
22:43:20 <jrockway> but not as badly as using the C directly ;)
22:43:24 <arw> take for example javas image handling, which is mostly C libs with the badness abstracted away. except that you could always feed it broken images...
22:43:34 <jrockway> yeah
22:44:15 <jrockway> i am always glad when i see "pure haskell" implementations of things that most other languages use C libraries for
22:44:22 <arw> so everybody felt safe while you could easily inject code into any jvm, and nobody updated because "its java, nothing bad can happen"
22:44:25 <jrockway> md5 calculation, mp3 decoding, etc.
22:44:44 <jrockway> yeah
22:45:00 <jrockway> the problem is that most C code doesn't bother to validate its arguments
22:45:04 <jrockway> it just assumes they are correct
22:45:40 <jrockway> things are getting better though
22:45:52 <jrockway> i notice that when i play a video in player, it prints things like "bad frame" instead of segfaulting :)
22:45:56 <jrockway> * mplayer
22:46:23 <Twey> Sometimes it segfaults too
22:46:29 <jrockway> xmonad is another example of things shifting the right way
22:46:38 <arw> tons of other code also doesn't. my favourite example are python programmers. wrong parameter somewhere and the user gets shown an uncaught exception and a backtrace...
22:46:55 <jrockway> yeah, that's a little different
22:47:06 <jrockway> in that it's an assertion that there's a bug somewhere
22:47:17 <jrockway> in an ideal world, the compiler would catch that
22:47:45 <jrockway> (but even statically-typed languages can have runtime errors, like failed pattern matches)
22:48:33 <arw> yes. but you never give an end user a backtrace or an uncaught exception. you catch it and handle it, gracefully if possible.
22:48:52 <jrockway> depends on the situation
22:49:03 <jrockway> if you are a web app and the database is gone, there's not much you can do
22:49:19 <jrockway> but if you are a desktop application, you can at least save the open files somewhere before you die :)
22:50:15 <arw> you can always switch to "technical difficulties, come back later" by giving back 500 server error. just killing the webserver by an exception is not the right thing to do.
22:50:28 <jrockway> yeah, you are right about that
23:00:47 <Twey> http://tutorial.happstack.com/tutorial/macid-stress-test ‚Äî does this still hold?
23:03:57 <mtnviewmark> wow - is the compiler in GHC 6.12 much faster than 6.10?
23:04:44 <c_wraith> are you compiling with -dynamic?
23:04:54 <c_wraith> because if it skips the linker, it should compile a lot faster
