00:00:01 <syntaxglitch> pff, what kind of mathematician worries about stuff like that?
00:00:14 <monochrom> Set theory has had numerous bugs. Russell found some early ones. History shows us what happens: bugs get fixed, no one abandons set theory altogether.
00:00:44 <kmc> not very much history imo
00:00:51 <monochrom> Using set theory bugs to tell people to abandon set theory is harder than using OS bugs to tell people to switch OS.
00:01:21 <syntaxglitch> just look at erdos: a homeless drug abuser
00:01:26 <mm_freak> using OS bugs to tell people to abandon OS bugs
00:01:46 <dolio> Well, he told me the other day that he hopes that it's inconsistent to a degree that Coq's impredicative Prop would have to be abandoned, because it's able to correctly encode theorems about power sets.
00:01:54 <dolio> (I think that's about right.)
00:01:54 <kmc> what, 130 years?
00:03:05 <dolio> I'm not sure what set theory without power sets would be like.
00:03:13 <solrize> http://www.math.princeton.edu/~nelson/papers/hm.pdf  dolio, this guy thinks peano arithmetic is inconsistent
00:05:02 <kmc> ah, philosophy
00:05:34 <kmc> haha @ page 6
00:06:55 <solrize> heh
00:11:43 <mm_freak> lol
00:12:47 <dolio> So, this guy is an ultrafinitist, or what?
00:13:08 <solrize> yeah i guess so
00:13:59 <dolio> I have a PDF of his Predicative Arithmetic book.
00:14:10 <solrize> yeah, it's on his site
00:14:20 <dolio> I'm less impressed with hm.pdf.
00:14:24 <solrize> http://www.math.princeton.edu/~nelson/books.html
00:14:35 <solrize> hm.pdf just sort of quickly describes the idea
00:14:41 <dolio> I didn't find the repeated "OMG ALL MATHEMATICIANS ARE PLATONISTS" stuff to be very persuasive.
00:14:49 <solrize> lol
00:15:51 <dmwit> Hm.
00:15:52 <merehap> that paper is getting more and more painful to read
00:16:04 <dmwit> Isn't the point of the new Parsec stuff to be able to parse bytestrings?
00:16:13 <dmwit> How come I'm getting a type error when I try?
00:16:17 <solrize> http://www.math.princeton.edu/~nelson/papers/e.pdf maybe this one is better
00:16:20 <merehap> quotes and historical meaning in order to build his argument, very persuasive
00:16:44 <merehap> how did he get into princeton?
00:17:06 <solrize> he's a really good math guy
00:17:15 <solrize> he did a lot of mathematical physics
00:17:17 <mm_freak> dmwit: note that there are two ByteString types (lazy, strict) each coming with two different interfaces (Char, Word8)
00:17:32 <solrize> and at one point had some kind of epiphany that the natural numbers didn't really exist
00:17:40 <solrize> and got involved in logic that way
00:17:41 <merehap> nice
00:17:44 <dmwit> mm_freak: urgh
00:18:03 <solrize> mm_freak,  don't forget Text
00:18:16 <mm_freak> solrize: Text?
00:18:34 <solrize> yeah, sort of bytestrings for unicode... i dunno if parsec handles it yet
00:18:49 <mm_freak> ah, dunno
00:19:03 <dmwit> mm_freak: Okay, well, Data.ByteString.Lazy doesn't work; how do I get the strict one?
00:19:10 <dmwit> (Data.ByteString also doesn't work.)
00:19:14 <kmc> at the end of that document he says he wants to find "an explicit superexponentially long recursion and prove that it does not terminate"
00:19:31 <solrize> he's the same guy who came up with what's now called the hadwiger-nelson problem, about finding the chromatic number of the plane
00:19:32 <mm_freak> dmwit: Date.ByteString and Date.ByteString.Char8 are strict
00:19:46 <solrize> it turns out it depends on what kind of set theory you use
00:20:05 <dmwit> mm_freak: Each of those modules gives the same type error.
00:20:09 <dmwit> Maybe I should paste.
00:20:21 <mm_freak> dmwit: that would be useful
00:20:42 <solrize> predicative arithmetic (that theory he talks about, which says PA is wrong) turns out to be important in complexity theory
00:20:56 <kmc> solrize, wow
00:21:20 <solrize> if you restrict recursion to predicative recursion the functions you get are exactly the P-time functions
00:21:21 <kmc> hadwiger-nelson depending on choice of axioms
00:21:31 <dmwit> http://codepad.org/Pv2Miidj
00:21:36 <kmc> so what was that earlier about ZFC being just another faithful implementation of the same high level constructs ;)
00:21:51 <solrize> ;)
00:22:15 <solrize> there's a book called "mathematical coloring book" that talks about that problem... it's online someplace
00:22:25 <dmwit> I never imagined that treating a ByteString as a stream of Word8's would be so difficult. =P
00:22:29 <monochrom> same up to documented features. you're now using undocumented or fringe features
00:23:14 <kmc> ah, so i should RTFM ;)
00:23:37 <kmc> perhaps someone will give a denotational semantics for set theory so i know what i can depend on ;)
00:23:39 <monochrom> Granted, mathematicians are poor documenters.
00:25:32 <dmwit> mm_freak: Those two modules do not seem to have the Char/Word8 schism you suggested.  They are both Char streams (which strikes me as somewhat odd).
00:25:58 <dmwit> Am I hosed?
00:26:17 <dmwit> Is there an efficient way to read a file that results in something that is a Word8 stream (in Parsec's eyes)?
00:26:27 <mm_freak> dmwit: http://hackage.haskell.org/packages/archive/parsec/3.0.1/doc/html/Text-Parsec-ByteString.html
00:26:56 <dmwit> mm_freak: That also has Char as the token type. =/
00:27:30 <mm_freak> well, yes, sure
00:27:38 <mm_freak> did you expect Word8?
00:27:41 <dmwit> Yes.
00:27:43 <kmc> Data.Bytestring is a Word8 stream
00:27:50 <dmwit> kmc: Surprise!  No it's not.
00:27:59 <kmc> really?
00:28:03 <dmwit> Really!
00:28:04 <kmc> i see Word8 all over the doc
00:28:09 * dmwit shrugs
00:28:14 <kmc> http://www.haskell.org/ghc/docs/6.10-latest/html/libraries/bytestring/Data-ByteString.html
00:28:16 <dmwit> GHC says its instance of Stream is Char.
00:28:20 <solrize> http://www.uccs.edu/~faculty/asoifer/docs/AXIOMOFCHOICEinJCT.pdf  kmc, here's the paper about hadwiger-nelson and set theory
00:28:33 <dmwit> kmc: Yes, in *reality* it is just a bunch of Word8s.
00:28:38 <kmc> ahh, i see
00:28:43 <dmwit> kmc: So it's a Word8 stream, but not a Word8 Stream. =)
00:28:45 <dolio> The ByteString from D.B.Char is the same as from D.ByteString.
00:28:45 <kmc> bad instance then?
00:28:53 <copumpkin> bytestring should stop trying to act like it's for tex t:P
00:28:56 <copumpkin> now that we have Data.Text
00:28:59 <dmwit> agreed
00:29:04 <monochrom> You are all violently agreeing again. Data.ByteString gives you Word8. Text.Parsec then converts that to Char. Is that so impossible to accept?
00:29:08 <copumpkin> get rid of all the Char stuff
00:29:16 <kmc> burn down the building
00:29:20 <mm_freak> dmwit: ByteString is an array of Word8, but Parsec's Stream instance gives you Chars
00:29:25 * copumpkin gets out his torch and pitchfork
00:29:27 <dmwit> monochrom: Yes!  I have a Word8 parser... what am I supposed to do with it!
00:29:51 <dolio> Wrap a newtype around ByteString and make a new Stream instance.
00:30:11 <monochrom> Steal the source code of Parsec's Stream instance for ByteString. Change it to delete the conversion.
00:30:24 <dmwit> Well.  That's reasonable.
00:31:48 <tomberek> monochrom: would comonads be appropriate for a neural network.. repeated applications of similar computations?
00:31:56 <monochrom> Parsec source code says import qualified Data.ByteString.Char8 as C
00:32:31 <mm_freak> dmwit: instance Monad m => Stream MyByteString m Word8 where uncons = Data.ByteString.uncons
00:32:35 <mm_freak> that should do it
00:33:03 <dmwit> something like that, yeah
00:33:10 <monochrom> I believe it should be uncons = return . Data.ByteString.uncons
00:33:27 <dmwit> return . fromJust ;-)
00:33:41 <dmwit> Oh, no.
00:33:44 <dmwit> I read the type wrong.
00:33:46 <mm_freak> monochrom: indeed
00:34:46 <monochrom> Oh, MyByteString, we need unwrappers and wrappers. Well, you figure it out.
00:34:58 * dmwit nods
00:35:09 <dmwit> I'm a pretty savvy Haskeller, when it's not so late. ;-)
00:35:37 <copumpkin> dmwit: riiiight, keep telling yourself that!
00:35:42 <dmwit> ;-)
00:35:48 <copumpkin> oh wait, you were helping me when I just got started
00:35:57 * copumpkin dips his head in shame and goes back to wor
00:36:10 <mm_freak> monochrom: again, indeed
00:37:22 <mm_freak> the Stream class has that unfortunate fundep
00:37:35 <mm_freak> otherwise you could just add a ByteString m Word8 instance
00:38:19 <dmwit> yeah
00:39:03 <dmwit> Ok, modules loaded: Main.
00:39:05 <dmwit> \o/
00:45:50 <jrockway> wow, windows ghc actually works under wine
00:46:15 <jrockway> now i can run my program which requires a windows-only dll on unix
00:46:23 <jrockway> instead of as a windows scheduled task
00:47:48 <tomberek> dmwit: any good info on comonads out there? (btw: thanks for the help on other abstractions earlier)
00:48:01 <dmwit> hrm
00:48:12 <dmwit> I believe sigfpe has written the only stuff I've ever read about comonads.
00:48:19 <tomberek> i just read that
00:48:27 <dmwit> Then, nope. =P
00:48:27 <tomberek> "whenever you see large datastructures pieced together from lots of small but similar computations there's a good chance that we're dealing with a comonad."
00:48:36 <dmwit> exactly
00:48:51 <tomberek> i was thinking a neural network might benefit from comonad thinking... but i have yet to grok it
00:49:49 <tomberek> is there a way to contact him?
00:50:03 <dmwit> not sure
00:50:27 <dmwit> However, edwardk is pretty interested in category theory and its applications in Haskell -- you might ask him for more pointers.
00:50:29 <Saizan> he posted on haskell-cafe in the past
00:50:47 <dmwit> sigfpe's RL name is Dan Piponi or something like that, if that helps.
00:51:00 <tomberek> i found his website
00:51:43 <Saizan> neural networks are pretty similar to cellular automata, right?
00:52:47 <tomberek> well......  no, but it DOES deal with repeated applications of simple rules
00:53:00 <tomberek> it's computation by structure
00:53:59 <solrize> typeclassopedia says something about comonads .... i never understood them
00:54:02 <Saizan> i meant that you calculate the next state for a neuron by looking at the current state of the neurons connected to it?
00:54:16 <jrockway> the comonads paper is very helpful
00:54:16 <tomberek> i'm reading some of that...
00:54:19 <tomberek> Saizan: yes
00:54:20 <jrockway> but it seems to be dead now
00:54:44 <tomberek> are there any other suggestions for abstractions that lend themselves to neural networks?
00:54:58 <Saizan> so, if you write the zipper for your neural network
00:55:13 <Saizan> then the associated comonad should be useful
00:55:18 <jrockway> ooh, it is un-dead: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.45.4741
00:55:54 <tomberek> Saizan: can you elaborate?
00:56:12 <solrize> jrockway, neat
00:56:17 <Saizan> tomberek: do you know what a zipper is?
00:56:22 <tomberek> yes
00:58:45 <Saizan> then for any Zipper a, you can build a comonad where duplicate :: Zipper a -> Zipper (Zipper a), creates a Zipper with the same shape and containing all the possible shifts of the input one
00:58:57 <Saizan> just like in the cellular automata example
00:59:06 <Saizan> where you're using the list zipper
00:59:45 <Saizan> at that point you can fmap it with a function that calculates the next state of the neuron in the focus using the ones around it
01:00:16 <Saizan> and the result is the next state of the neural network
01:00:38 <tomberek> Saizan:  that sounds perfect, but to be honest, you lost me somewhere there in the middle
01:00:50 <Saizan> w =>> f = fmap f (duplicate w) btw
01:01:46 <dmwit> whoa
01:01:47 <Saizan> tomberek: have you read this? http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html
01:01:54 <tomberek> yes
01:02:11 <Saizan> "U a" there is the zipper for [a]
01:03:11 <Saizan> and cojoin (which i called duplicate) creates an universe of all the possible universes
01:04:15 <Saizan> where the difference between them is only which element is currently in the focus
01:04:21 <tomberek> lazily i hope
01:04:32 <Saizan> yeah
01:04:56 <dmwit> If you'd like to bake an apple pie from scratch... you must first invent the Universe.
01:05:05 <tomberek> well, it sounds like what I need, update all neurons (we also have recurrent signals to deal with)
01:05:38 <Saizan> so where you had the element e.g. x, you instead have the universe centered on x
01:06:22 <Saizan> so if you write a function that works only for the center of the universe, using =>> you can apply it uniformly to all the points in the universe
01:07:20 <tomberek> again, it sounds right,,, keep in mind, i'm still new to haskell... looks like i have more to read
01:07:43 <Saizan> heh, yeah, i'm repeating myself :)
01:07:51 <Saizan> well, just look at the implementation
01:08:00 <Saizan> and how to derive a zipper automatically
01:08:08 <Saizan> from a type
01:08:34 <Saizan> you've to make sure that moving your zipper in any direction is O(1) for this to work sanely
01:09:38 <Saizan> if you've some structure with fast random access the zipper might just be a pair of the structure and the index of the current element
01:09:40 <tomberek> Saizan: moving through the NN should be O(1) because the connections of stored
01:10:00 <tomberek> are stored
01:11:15 <Saizan> tomberek: the nodes have an Id, i guess?
01:11:46 <tomberek> Saizan: no, but that can be added easily
01:11:58 <tomberek> (in fact, some implementations require it)
01:31:34 * ddarius has used a backward state monad for multilayer perceptron backpropagation.
01:33:27 <copumpkin> :O
01:33:33 <copumpkin> sounds interesting
01:33:38 <copumpkin> was it a good fit?
01:35:01 <ddarius> Not really.  The function was small enough that it would have been nicer to explicitly pass the state backwards.
01:35:14 <ddarius> In a larger example, it may have been more useful.
01:52:24 <mmaruseacph2> does the id function occur a performance penalty?
01:52:46 <dmwit> Profile and find out.
01:58:26 <mm_freak> mmaruseacph2: depends on whether a thunk is allocated for id
01:58:50 <mm_freak> in some trivial cases, id is optimized away, but not in others
02:00:05 <mm_freak> > sum . map (foldl' (.) id $ replicate 0 id) $ [1..10000000]
02:00:14 <lambdabot>   mueval: ExitFailure 1
02:00:17 <mm_freak> > sum . map (foldl' (.) id $ replicate 0 id) $ [1..10000]
02:00:22 <dmwit> It is extremely likely that if the performance hit of id is enough to notice, then either 1. you are doing something Very Wrong or 2. your application is hard real-time, and you should not be using Haskell.
02:00:25 <lambdabot>   50005000
02:00:48 <mm_freak> > sum . map (foldl' (.) id $ replicate 1000 id) $ [1..10000]
02:00:50 <lambdabot>   50005000
02:01:11 <mm_freak> this is such a non-trivial case, where id has a noticable impact on performance performance
02:01:28 <mm_freak> hmm
02:01:36 <dmwit> I would categorize this under 1. Very Wrong.
02:02:02 <c_wraith> performance^2?
02:02:08 <mm_freak> c_wraith: yeah
02:02:18 <mm_freak> dmwit: that's made up
02:02:48 <EnglishGent> morning all :)
02:03:20 <domor> good morning old chap
02:03:21 <mm_freak> the rule of thumb is:  if you apply id to something right away, it'll likely get optimized away, but if you pass it around like a value, then it'll get a thunk
02:04:10 <ddarius> In many cases, the HOF will get inlined and allow id to be inlined.
02:04:31 <EnglishGent> hello domor :)
02:04:37 <ddarius> Other times rules will kick in.
02:05:28 <mmaruseacph2> well, i have a data definition which is in fact only a function from an Int to an a
02:05:58 <mmaruseacph2> when I want to change the result of this function in one place i compose another function with it
02:06:12 <mmaruseacph2> the second function is id except for one single point
02:06:36 <mm_freak> Int -> a?
02:06:41 <mmaruseacph2> guess i'll profile it
02:06:49 <mm_freak> sounds like undefined or \_ -> undefined
02:06:56 <mmaruseacph2> yup, data D = Int -> a
02:07:14 <mm_freak> huh?
02:07:33 <dmwit> likely data D a = Int -> a
02:07:38 <mm_freak> type D a = Int -> a
02:07:39 <mmaruseacph2> not a complete definition, of course
02:07:43 <c_wraith> still needs a constructor
02:07:54 <mmaruseacph2> data D a = D {f:: Int->a}
02:07:55 <c_wraith> oh, type, not data
02:08:01 <c_wraith> or that
02:08:02 <c_wraith> :)
02:08:30 <mm_freak> mmaruseacph2: so you're composing a function by adding points to it?
02:08:43 <mmaruseacph2> no
02:08:56 <mmaruseacph2> to change a value in the D structure i compose the function
02:09:31 <mm_freak> ok, then id will most likely have a performance impact here
02:09:36 <mmaruseacph2> change d where withwhat = (\x -> if x == where then (\_->withwhat) else id) . f d
02:09:57 <mmaruseacph2> i'll test now
02:10:19 <mmaruseacph2> hopefully, there will be not so many single value changes in the structure
02:11:13 <mm_freak> why not use a Map or something?
02:11:25 <copumpkin> or IntTrie
02:11:27 <mmaruseacph2> isn't Map bounded on the keys?
02:12:01 <copumpkin> http://hackage.haskell.org/package/data-inttrie
02:12:13 <mmaruseacph2> IntTrie seems ok:)
02:12:27 <mm_freak> a (Map k e) can be seen as a (Ord k => k -> e)
02:12:37 <mm_freak> and if k = Int, you can use IntMap
02:12:38 <copumpkin> more like k -> Maybe e
02:12:46 <copumpkin> unless you like partial functions :)
02:13:00 <mm_freak> indeed =)
02:14:42 <copumpkin> bedtime!
02:14:45 <copumpkin> ciao :)
02:21:49 <mmaruseacph2> unfortunately it comes with a penalty :(
02:22:27 <dmwit> There's one upside to being a library author: if you need to change something, you just change it. =P
02:23:09 <dmwit> The downside, as I'm learning, is that you probably screwed up pretty badly with your first version.
02:25:33 <mm_freak> mmaruseacph2: copumpkin's IntTrie suggestion is quite useful
02:25:45 <mm_freak> probably better than IntMap
02:25:46 <mmaruseacph2> it is
02:25:54 <mmaruseacph2> now i have to see if i can extend it
02:26:10 <mmaruseacph2> because i must not be limited by int
02:29:28 <mmaruseacph2> i think i got a workaround
02:29:54 <mmaruseacph2> though, now i don't use higher level functions
02:33:13 <shambler> @hayoo blah
02:33:14 <lambdabot> Unknown command, try @list
02:35:08 <kamatsu> @hoogle blah
02:35:09 <lambdabot> No results found
02:43:08 <maltem> Um. Why do some packages on hackage require the haskell98 package, even if they don't use the non-hierarchical modules?
02:44:48 <maltem> (example: hmatrix)
02:46:20 <Cale> maltem: I can't think of a good reason
02:46:48 <maltem> Cale: ok, then it's probably "by accident"...
02:47:17 <Cale> Numeric.GSL seems to import Complex
02:47:23 <Cale> rather than Data.Complex
02:48:12 <Cale> But I'm not aware of significant differences between the two.
02:49:44 <maltem> Officially, Complex should just wrap Data.Complex
02:52:10 <danderson> I have a little strangeness that is confusing me here: in ghci, I ran a function of mine that returns a non-showable value (missing a Show instance for one of the nested types), and ghci displayed nothing instead of complaining.
02:52:40 <danderson> however, if I input x <- runFunc followed by x, then it complains. And if I define the Show instance, runFunc by itself displays the result.
02:53:02 <danderson> how come ghci doesn't display or complain in the first case?
02:54:54 <maltem> danderson, "x <- runFun" does not complain, because it's reasonable to bind the result to x without showing it
02:55:19 <Taejo> and in fact, you can tell ghci to never show bound results (I think this is sensible)
02:56:22 <maltem> oops, hmatrix doesn't come with a Show instance for matrices - I was hoping for a saner environment to check my homework than is Maple
02:58:15 <Cale> danderson: This is just how it works. It might be a little confusing because GHCi uses the same syntax for what is essentially two things. If you give it most values, it will evaluate the value, and if there is a Show instance, print it, and if not, complain about there not being a Show instance.
02:58:40 <Cale> danderson: However, if you give it an IO action, it doesn't just evaluate, but also executes the action.
02:59:15 <Cale> It used to be the case that it just never printed the result of an executed IO action. (I liked this behaviour, and I'm not sure why it changed.)
02:59:38 <Cale> However, it now prints the result of the IO action as well, if there's a Show instance available, and it's not of type ()
03:00:37 <mm_freak> i view the GHCi prompt as a do block with the additional rule that non-IO actions are automatically 'print'-ed
03:00:50 <Cale> mm_freak: That used to be true.
03:01:08 <Cale> But now it jams extra prints in for the results of IO actions too.
03:01:19 <mm_freak> well yes, it also prints the result of IO actions, but i think that's ok
03:01:33 <mm_freak> after all you do testing an calculations in GHCi, no actual programming
03:01:51 <Cale> I rather dislike that. If I wanted to print the result, I would have added the ">>= print" myself
03:02:16 <mm_freak> for me that would mean adding it all the time
03:02:20 <Cale> It can be annoying because printing the result forces its evaluation.
03:03:14 <Cale> Also, sometimes the result is something which I'm not interested in at all, but takes lots of space on the screen to print.
03:03:31 <Cale> (actually a fair proportion of the time)
03:10:26 <Berengal> Cale: ">>= const $ return ()"
03:10:50 <mm_freak> Cale: :m Control.Applicative
03:10:58 <mm_freak> () <$
03:10:58 <mm_freak> =)
03:11:21 <Berengal> True
03:11:22 <dolio> I don't think >>= const $ return () parses the way you want it to.
03:11:42 <mm_freak> how about >> return () anyway?
03:11:51 <Berengal> dolio: Depends on how you've redefined ($) :P
03:12:04 <Berengal> I like the () <$ suggestion
03:12:19 <mm_freak> i don't like it too much
03:12:40 <mm_freak> firstly it needs Control.Applicative, secondly it requires you to know beforehand when you're not interested in the result
03:12:44 <Berengal> I use it at times
03:13:06 <mm_freak> that may scatter your line of thought
03:13:20 <Berengal> Handy in parsers, so you can write something like Equals <$ string "=="
03:31:51 <cheater2> hi guys
03:32:20 <kamatsu> hi
03:33:13 <EnglishGent> hi cheater2
03:37:00 <cheater2> how is haskell doing today?
03:38:33 <kamatsu> cheater2: okay
03:38:42 <kamatsu> sort of an odd question
03:38:53 <kamatsu> community is growing despite SPJ's wishes
03:38:57 <kamatsu> as per usual
03:41:01 <cheater2> what is SPJ?
03:41:07 <Heffalump> the "avoid success at all costs" quote isn't actually his opinion, btw.
03:41:51 <Heffalump> at least, he's said several times since that it wasn't serious
03:42:52 <cheater2> i have no idea what you guys mean, want to let me in on that?
03:43:03 <kamatsu> SPJ is one of the guys that worked on haskell at the beginning
03:43:09 <kamatsu> simon peyton jones
03:43:25 <kamatsu> he is well known for saying that haskell should "avoid success at all costs" so the community could remain small and make changes easily
03:43:29 <kamatsu> he wasn't serious
03:47:36 <cheater2> ah ok
03:47:36 <cheater2> :)
03:52:36 <cheater2> is the comma in haskell, as seen in list comprehensions, an expression of something similar to continuation-passing style?
03:55:36 <cheater2> for example if i do [ (a,b,c) | a<-[0..100], b<-[0..100], c<-[0..100], b < a, let x = a*b, c < x ] then x doesn't exist in the predicated before i defined it, right?
03:56:12 <Saizan> i don't what that has to do with CPS, but yeah
04:00:08 <cheater2> Saizan: i am trying to figure out what CPS actually is and how it relates to functional programming :-)
04:02:25 <Saizan> continuation passing style is a way to write functions such that you never return, but rather call another function with what would be your result
04:02:31 <kamatsu> cheater2: hm, okay, so, CPS doesn't exactly relate to high level constructs like comprehensions.
04:03:16 <Saizan> it's mostly about having more control over the control flow
04:03:26 <kamatsu> a point where they might relate is that compilers can transform imperative programs into pure ones that use CPS.
04:03:55 <Saizan> kamatsu: really?
04:04:12 <kamatsu> sure
04:04:38 <dolio> I've seen programming with monads called "effect passing style", so it would relate to list comprehensions in that way.
04:05:33 <Saizan> kamatsu: how? i mean, you can implement some control flow effects like breaking from a loop etc.. with CPS, but not e.g. mutable variables i think
04:05:55 <Saizan> unless you lambda-lift your continuation, i guess
04:06:01 <cheater2> Saizan: cps has nothing to do with variables being mutable or not
04:06:13 <Saizan> cheater2: yeah, that was my objection
04:06:28 <cheater2> you just add another frame in the spaghetti stack
04:06:55 <Saizan> CPS and first-class continuations via stack manipulation are not the same thing
04:07:06 <cheater2> upstream stack frames don't have to get changed, they can get masked, that's why it doesn't have to have side effects
04:07:32 <kamatsu> right, you just rename the bindings
04:07:52 <kamatsu> (you don't actually do this, but you would do so in formal inference)
04:08:13 <Saizan> ok, so that's more about converting to SSA than continuations
04:09:17 <kamatsu> according to Kelsey, SSA and CPS are equivalent
04:10:13 <opqdonut> kamatsu: you have a link for that?
04:10:42 <kamatsu> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.3.6773
04:10:51 <opqdonut> thanks :)
04:14:13 <Saizan> heh, the useful route seems to be functional -> CPS -> SSA -> imperative code, rather than vice versa, but ok :)
04:14:33 <kamatsu> yeah
04:14:41 <kamatsu> i wonder if such a transformation is efficient
04:15:06 <kamatsu> ah, this was done in 1995, so we've probably already got results that will answer that question
04:28:25 <Cale> > let get = Cont (\f s -> f s s); put = Cont (\f s -> f () s'); runS = runCont x (,); inc = do x <- get; put (x+1); return x in runS (sequence [inc,inc,inc]) 0
04:28:26 <lambdabot>   Not in scope: `s''
04:28:33 <Cale> > let get = Cont (\f s -> f s s); put s' = Cont (\f s -> f () s'); runS = runCont x (,); inc = do x <- get; put (x+1); return x in runS (sequence [inc,inc,inc]) 0
04:28:35 <lambdabot>   Couldn't match expected type `Control.Monad.Cont.Cont r a'
04:28:35 <lambdabot>         against ...
04:29:36 <Cale> > let get = Cont (\f s -> f s s); put s' = Cont (\f s -> f () s'); runS x = runCont x (,); inc = do x <- get; put (x+1); return x in runS (sequence [inc,inc,inc]) 0
04:29:37 <lambdabot>   ([0,1,2],3)
04:39:42 <PeakerWork> Did anyone look at the Scala/Haskell comparison link by dons on Reddit? http://www.reddit.com/r/haskell/comments/atbo4/comparing_haskell_and_scala/
04:40:14 <PeakerWork> Scala seems much more verbose/uglier-syntax, but it's implicit-parameters seem like it might be a nice feature (that could possibly replace simple type-classes, if done right?)
04:40:33 <vegai> scala's a mess, imho
04:41:43 <BONUS> i don't like the strict by default with lazy annotations thing
04:42:02 <BONUS> if you're writing functional code, lazy by default seems much more natural
04:42:27 <opqdonut> for data structures strict-by-default is nicer
04:42:49 <BONUS> well depends on what kind of data structures
04:42:50 <jaspervdj> opqdonut: you mean for data structure analysis
04:42:53 <BONUS> imo
04:43:26 <PeakerWork> for the linked list data structure, for example, lazy by default seems nice :)
04:43:30 <opqdonut> BONUS: sure
04:44:17 <Cale> I like lazy-default for data structures. I think scala's choice is more about the expectation that since you're going to be calling lots of Java code, there will be lots of mutation going on.
04:44:42 <opqdonut> but generally we want stuff like insert x tree to do something and not just sit around, waiting for the first read
04:45:12 <opqdonut> but sure, if you can make a lazy data structure (like okasaki's queue) it's really nice
04:45:34 <Cale> Well, insert is necessarily strict in the tree...
04:45:54 <Cale> But that's because it has to pattern match anyway
04:46:20 <BONUS> but yeah for some data structures strict is best
04:46:38 <BONUS> i tried making a trie for kicks in haskell but then i had to add loads of strictness annotations
04:47:02 <opqdonut> i did a bit-fiddling structure and ditto
04:47:04 <Cale> If insert x _|_ was not _|_, then I'm pretty sure your tree wasn't a tree after all, but a list :)
04:47:09 <blobl> whats the advantage of point free?
04:47:18 <BONUS> blobl: more cool
04:47:19 <opqdonut> Cale: yeah, bad example
04:47:26 <kamatsu> blobl: more awesome!
04:47:29 <Cale> blobl: Not giving names to things which don't deserve them.
04:47:35 <opqdonut> and I guess I meant strict-and-eager anyway
04:47:37 <BONUS> sometimes it's more readable
04:47:46 <blobl> ya it is. but has nothing to do with the compiled thing?
04:47:54 <opqdonut> because eagerness is what strictness annotations in fields really are
04:47:59 <opqdonut> on a high level
04:48:01 <blobl> like makes faster code.. or something?
04:48:07 <Cale> blobl: If you've ever used a unix/linux shell, then the reason we like points-free compositions is much the same reason people like shell pipelines.
04:48:18 <Cale> blobl: It doesn't affect the performance of the coed.
04:48:20 <BONUS> like consider f x = blah (foo (tahtah (woot x))) vs f x = blah . foo . tahtah . woot $ x vs. f = blah . foo. tahtah . woot
04:48:20 <Cale> code*
04:48:48 <blobl> its pretty much the same as pipelines huh?
04:48:58 <Cale> (the compiler will generally compile it to the very same thing as the pointful version)
04:49:05 <opqdonut> blobl: well that's one aspect of it
04:49:59 <Cale> Writing functions as compositions of other functions also gets you into the right frame of mind for functional programming, I think.
04:50:27 <blobl> i can feel that :D still i cant understand why it produces the same code
04:50:34 <Cale> That is, thinking of *functions* as the main thing that you're manipulating, rather than the values that they act on.
04:50:55 <Cale> blobl: because the compiler is nonidiotic, and will inline the definition of (.)
04:51:16 <BONUS> blobl: well think about f x = g (h x). thi sis a function that takes one thing, passes it to h and then passes that result to g
04:51:21 <blobl> meaning it will infer the variables i didnt write?
04:51:37 <BONUS> g . h means: make a function that takes one thing, passes it to h and then passes that result to g
04:51:41 <BONUS> so it's the same thing
04:51:46 <blobl> ya
04:51:54 <BONUS> in fact, f . g is defined as (f . g) x = f (g x)
04:51:55 <blobl> ya got it cheers
04:52:19 <tensorpudding> fun fact, it's the same as the composition of functions in maths
04:52:27 <Loriel> I always feel icky talking about *manipulating* function like data when the only thing I can really do with functions is to build bigger functions out of them.
04:52:43 <Cale> Loriel: well...
04:52:54 <Cale> Loriel: There are quite a few ways to do that.
04:52:55 <opqdonut> @src on
04:52:55 <lambdabot> (*) `on` f = \x y -> f x * f y
04:53:03 <opqdonut> it's still a surprisingly rich world
04:53:37 <blobl> loriel: what else would you like to do as manipulating functions?
04:54:24 <Loriel> Deconstruct them, get values or bound variables out of them, I suppose
04:54:30 <Cale> You could build every sort of value you'd ever want out of functions.
04:54:51 <Saizan> Loriel: you'd like Twelf :)
04:54:53 <Berengal> In a way, data are functions, not just the other way around
04:55:57 <Berengal> Constructors are functions that build destructors
04:56:02 <maltem> Oh, so wenn the Lisp people talk about functions as data, they really just mean that they compose functions? I always thought they were up to some trickier stuff. When I compose functions, I don't care about them being data or not...
04:56:16 <BONUS> > let result = (.); f = (result.result.first.map) (*1000) (\x y -> ([x,x,x],y) in f 2 3
04:56:17 <lambdabot>   <no location info>: parse error on input `in'
04:56:33 <Veinor> weird, I thought that worked
04:56:36 <Veinor> > let x = 2; y = 3 in x + y
04:56:38 <lambdabot>   5
04:56:44 <Berengal> maltem: The lisp people talk about _code_ as data, and they're thinking of macros. Usually.
04:56:49 <Cale> maltem: Well, they can be parameters to, and produced by other functions, and put into any datastructure you'd care to mention.
04:56:56 <Loriel> Bonus is short a )
04:57:00 <Veinor> ah
04:57:26 <Cale> But yeah, as for lisp, there you have code as data, rather than just functions.
04:57:30 <Veinor> let result = (.); f = (result.result.first.map) (*1000) (\x y -> ([x,x,x],y)) in f 2 3
04:57:33 <Veinor> > let result = (.); f = (result.result.first.map) (*1000) (\x y -> ([x,x,x],y)) in f 2 3
04:57:34 <lambdabot>   ([2000,2000,2000],3)
04:57:43 <BONUS> ah yeah
04:57:48 <Veinor> so what's result.result.first.map doing?
04:57:48 <idnar> maltem: to compose functions, you need to pass them around as values
04:58:05 <Loriel> @type (.)
04:58:07 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
04:58:11 <maltem> Ah ok, then I did not have a misconception there. So, macros.
04:58:18 <BONUS> Veinor: well map takes a function a -> b and turns it into [a] -> [b]
04:58:20 <idnar> but yeah, "functions as data" is a lot less complicated than "code as data"
04:58:36 <BONUS> and first takes a function a -> b and truns it into (a,c) -> (b,c)
04:58:39 <Loriel> @type first
04:58:40 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
04:58:44 <idnar> functions are values in Haskell, but they're pretty much black boxes
04:59:01 <Veinor> @unpl (.) . (.) . f . g
04:59:01 <lambdabot> (\ k b c h -> f (g k) (b c h))
04:59:03 <BONUS> so if we have first.map, it takes an a -> b and turns it into a function ([a],c) -> ([b], c)
04:59:06 <idnar> the only way you can create a function is by composing other functions
04:59:35 <Cale> > let myTree = (\t b -> b 1 (b 2 t (b 3 t t)) (b 4 (b 5 t t) (b 6 t t))); inorder tree = tree (\x l r -> l . (x:) . r) id [] in inorder myTree
04:59:36 <lambdabot>   No instance for (GHC.Num.Num
04:59:37 <lambdabot>                     (([a] -> ([[a]] -> b) -> f...
04:59:54 <Loriel> Much like the only way to create a data structure is to tie together other data structures :>
05:00:02 <maltem> Cale, idnar: That's about storing functions, and that's just a necessity to use them in code. "functions are data" sounds like data Function = ...
05:00:18 <BONUS> and (.) takes a function a -> b and turns it into a function that operates on results of functions, so into an (c -> a) -> (c -> b)
05:00:37 <mauke> maltem: are numbers data?
05:00:55 <maltem> alright, alright.
05:01:06 <Cale> > let myTree = (\t b -> b 1 (b 2 t (b 3 t t)) (b 4 (b 5 t t) (b 6 t t))); inorder tree = tree id (\x l r -> l . (x:) . r) [] in inorder myTree
05:01:08 <lambdabot>   [2,3,1,5,4,6]
05:01:34 <maltem> But you don't go around telling everyone, hey, numbers are data!
05:01:47 <idnar> maltem: maybe /you/ don't
05:01:49 <idnar> maltem: ;)
05:01:57 <Cale> There, I used a function to build my tree structure rather than an algebraic datatype
05:02:03 <Cale> and function application rather than case
05:02:19 <maltem> heh
05:02:22 <Cale> They are roughly the same thing.
05:02:47 <idnar> yay church encoding
05:02:49 <Loriel> neat
05:03:13 <Veinor> guys, numbers are data!
05:03:18 <Veinor> :O
05:03:30 <opqdonut> Cale: shouldn't that be "function application rather than catamorphism"
05:03:39 * Loriel composes numbers
05:03:41 * Loriel is drunk with power
05:03:42 <opqdonut> you need a different encoding to make function application be case
05:03:45 <Cale> Well, yes
05:03:58 <opqdonut> just nitpickign :)
05:04:43 <idnar> maltem: maybe I should go around saying "numbers are functions!"
05:05:09 <Cale> opqdonut: In other news, it would be nice to have general syntax for catamorphisms in Haskell.
05:05:16 <blobl> if numbers are data and functions are data could i say functions are numbers ?
05:05:25 <idnar> let's not forget THREADS ARE PIDS!
05:05:30 <Cale> (which looked similar to case syntax, but would describe how to replace structure recursively)
05:05:32 <Berengal> blobl: In Lambda Calculus they are
05:05:52 <Cale> Well, not all functions are numbers
05:05:57 <Cale> Just some of them
05:05:58 <blobl> its getting really groovy sometimes
05:06:05 <Berengal> blobl: But it general x `elem` S && y `elem` S does not imply x == y
05:06:24 <blobl> ya :D haha
05:06:30 <opqdonut> Cale: true
05:06:36 <idnar> blobl: if boys are humans, and girls are humans, could I say boys are girls?
05:06:50 <blobl> but it is not `elem` what i said. its more like =
05:06:59 <idnar> it's subset, however you write that
05:07:24 <Berengal> Algebraic data types are just a convenient notation for grouping functions that return destructors. Pattern matching is just a convenient notation for calling the destructors
05:07:35 <blobl> hmm no im stupid
05:07:48 <idnar> A ⊆ S && B ⊆ S does not imply A == B
05:07:49 <Saizan> oh, god, so boys are not girls?
05:08:01 <Berengal> nothing = \d f -> x; just x = \d f -> f x
05:08:04 <idnar> Saizan: well, not all of them, anyhow
05:08:18 <Cale> > let add n m = (\succ zero -> n succ (m succ zero)); reify n = n (+1) 0 in reify $ add (\s z -> s (s (s z))) (\s z -> s (s z))
05:08:19 <lambdabot>   5
05:09:56 <Cale> Every natural number is zero, or is the successor of another natural number. We can then represent natural numbers using (\s z -> ...) where ... is some number of applications of s (successor) to z (zero)
05:11:34 <blobl> how can i write in haskell numbers are composed by data, functions are composed by data, evaluate functions == numbers ? :D
05:12:38 <Berengal> There's also the other way around: functions are data with lambda as the constructor and application as the destructor
05:12:45 <Cale> For instance, the number 3 is the successor of the successor of the successor of zero, so it's encoded as (\s z -> s (s (s z)))
05:13:10 <tensorpudding> Cale's playing some peano today
05:13:16 <Cale> heh
05:13:24 <blobl> haha
05:13:32 <blobl> i will go now :D ciao
05:14:23 <SKK> hello?  anybody copy?
05:14:30 <Loriel> Yep
05:14:47 <SKK> yay! thanks guys!
05:15:21 <SKK> anyway, my question was if i could override package version dependency when using "cabal install"
05:16:28 <SKK> i am trying "cabal install yi" but it says that it requires Cabal == 1.6, which I don't have (I have cabal 1.8.0.2)
05:16:30 <Saizan> from the CLI you can only add more constraints
05:16:33 <Saizan> with --constraint
05:17:19 <SKK> would be a little silly to install cabal 1.6 just because some package wants it
05:17:21 <Saizan> but you can "cabal unpack yi" and modify the resulting sources, and then run "cabal install" from the created directory
05:18:13 <SKK> oh, which part should I modify?
05:18:42 <Saizan> the .cabal file at least
05:18:52 <Berengal> > let nil = \f d -> d; cons x xs = \f d -> f x (xs f d) in (cons 1 (cons 2 (cons 3 nil))) (:) []
05:18:54 <lambdabot>   [1,2,3]
05:19:04 <Saizan> relaxing the constraint on Cabal in the build-depends field
05:19:34 <SKK> (trying)
05:19:42 <Saizan> maybe you should try with the darcs repo
05:26:41 <temoto> Please help to write a parser for lower-case-starting identifiers in a shorter way than    do { first <- lower ; rest <- identifier ; return first:rest }
05:27:03 <temoto> @undo do { first <- lower ; rest <- identifier ; return first:rest }
05:27:03 <lambdabot> lower >>= \ first -> identifier >>= \ rest -> return first : rest
05:27:03 <opqdonut> liftM2 (:) lower identifier
05:27:21 <opqdonut> or: (:) <$> lower <*> identifier
05:27:21 <Axman6> (:) <$> lower <*> identifier
05:27:22 <temoto> @pl lower >>= \ first -> identifier >>= \ rest -> return first : rest
05:27:23 <lambdabot> (identifier >>=) . (:) . return =<< lower
05:27:28 <temoto> omg
05:27:30 <Berengal> (:) <$> lower <*> identifier
05:27:41 <Axman6> Applicative++
05:27:43 <opqdonut> hmm, was it: lower <^(:)^> identifier
05:27:46 <temoto> ah, applicative styl
05:28:17 <temoto> Nah, thanks, i don't want to draw scary ascii animals.
05:28:22 <Berengal> Applicative is usually better for parsers. You normally don't want your grammar to change depending on what's previously parsed
05:28:33 <temoto> just <$> and <*> would be enough short and nice :)
05:28:40 <Axman6> temoto: that's the majestic applicative cons bird
05:28:42 <Loriel> Berengal: How insensitive
05:28:43 <xerox> > liftM2 (f::Expr->Expr->Expr) g h x -- return .liftM2 (:) lower identifier
05:28:44 <lambdabot>   f (g x) (h x)
05:29:00 <Berengal> (In the few cases you do, it's quick to drop back into monads for a spell)
05:29:27 <temoto> Thanks for help.
05:29:35 <Loriel> @src <^
05:29:35 <lambdabot> Source not found. That's something I cannot allow to happen.
05:29:51 <opqdonut> @src (<^)
05:29:51 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
05:29:57 <opqdonut> it's folklore
05:30:00 <SKK> ok, it says packaedstring failed to install, and when i try to cabal install that, says "could not find DAta.data.  member of hidden package 'base'."
05:31:01 <temoto> @hoogle <$>
05:31:02 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
05:31:22 <Berengal> <$> is fmap
05:31:25 <Loriel> @type ^^vv<<>>ba
05:31:26 <lambdabot> parse error on input `^^'
05:31:44 <temoto> heh well these operators confront with Parsec's
05:31:46 <mauke> this is not #konami
05:32:14 <Berengal> temoto: Parsec was written before applicatives were widely known
05:32:23 <tensorpudding> some people want to know the cheat codes for GHC
05:32:34 <Berengal> tensorpudding: unsafePerformIO and template haskell
05:32:35 <tensorpudding> to do their unsafe IO
05:32:36 <temoto> Berengal: what about <*>?
05:32:39 <temoto> is it ap?
05:32:43 <Berengal> temoto: Yep
05:32:44 <tensorpudding> it is ap
05:32:56 <tensorpudding> except ap is Monad and <*> is Applicative of course
05:32:59 <taruti> unsafeCoerce# is the ultimate cheat ;)
05:33:07 <temoto> oh
05:33:19 <Loriel> You cannot write unsafePerfomIO with just unsafeCoerce#, can you?
05:33:21 <Berengal> What's the difference between unsafeCoerce and unsafeCoerce#?
05:33:22 <temoto> well is that makes difference?
05:33:22 <Loriel> But the other way around works?
05:33:56 <taruti> Loriel: actually one can do unsafePerformIO with unsafeCoerce#
05:34:06 <Berengal> temoto: Morally they should be the same, but they might not be in the hands of nefarious authors
05:34:28 <taruti> Berengal: unsafeCoerce is just unsafeCoerce# re-exported iirc.
05:34:28 <idnar> Berengal: unsafeCoerce# has a different kind, it can work with unboxed types
05:34:33 <temoto> I mean can i write (fmap (:) lower `ap` identifier) ?
05:34:40 <Berengal> idnar: Ah
05:34:43 <taruti> idnar has a point.
05:34:46 <idnar> (I think?)
05:34:58 <Berengal> temoto: Yep, should work
05:35:01 <taruti> in the past there used to be only unsafeCoerce# iirc
05:35:38 <temoto> Yeah it works. Excellent.
05:35:43 <tensorpudding> unsafeEatRawEggs
05:37:23 <SKK> hm, "base" is already in build-depends, but it still says "it's a member of the hidden package 'base' "
05:38:16 <kamatsu> SKK: did you specify the version?
05:38:51 <SKK> no :[ how?
05:40:17 <SKK> hm, ghc-pkg  has both base-3.0.3.2 and base-4.2.0.0
05:40:26 <SKK> could that be the problem?
05:41:00 <Axman6> possibly
05:41:20 <SKK> should I remove 3.0.3.2?
05:41:30 <Berengal> No, you should specify the version
05:41:49 <SKK> how?  where?
05:41:54 <Berengal> In the .cabal file
05:42:19 <Berengal> Or on the command line when building
05:42:30 <SKK> the .cabal has "build.depends: base >= 4 && <5"
05:44:54 <SKK> how do i specify which version of the dependency to use on the CLI?
05:45:47 <Berengal> --constraint="base > 4"
05:46:42 <SKK> ok, thanks
05:57:12 <SKK> ok, just last question:  has anybody gotten yi to work with 6.12.1 ??
05:57:23 <SKK> (or managed to build it?)
06:00:01 <Saizan> SKK: unlikely
06:00:19 <SKK> :"'(
06:07:17 <voidprayer> is there some well-known libraries about judge what encoding a file uses?
06:08:47 <mauke> I don't know any
06:09:40 <Botje> determineEncoding = const "UTF-8"
06:10:01 <Veinor> I wish.
06:10:09 <mauke> const "ISO 8859-1"  -- superior
06:10:31 <Veinor> const "EBCDIC"
06:11:37 <Botje> mauke: -15, surely? think of the euro sign!
06:11:43 <Zao> const "ASCII" -- those moonspeakers can go gently caress themselves
06:12:01 <Veinor> this isn't logged-out SA, you know.
06:12:02 <voidprayer> not understand.
06:12:24 <mauke> Botje: -1 is still more widespread
06:12:26 <Zao> Veinor: Most people do not tend to get that rewrite, heh.
06:12:42 <Veinor> :P
06:12:50 <Botje> i knew it was from SA, i didn't know it wasn't done for logged-in people
06:14:09 <Veinor> logged-in people don't have silly filters, no
06:14:14 <Veinor> it'd be vaguely amusing.
06:25:26 <vyom> I am trying to upgrade HLint on my system (OS X, GHC 6.12.1) and when I do `cabal upgrade hlint` I get `cabal: fromFlag NoFlag. Use fromFlagOrDefault`.. any idea how to fix it?
06:25:55 <Saizan> vyom: "cabal install hlint" works?
06:26:54 <vyom> Saizan: looks like it does.. wonder why I did not think of that! Thanks
07:16:04 <BenceF> hi!
07:16:42 <BenceF> how do i declare a complex number?
07:17:01 <benmachine> import Data.Complex
07:17:02 <BenceF> using Data.Complex
07:17:08 <benmachine> then
07:17:11 <benmachine> > 1 :+ 3
07:17:13 <lambdabot>   1.0 :+ 3.0
07:17:16 <benmachine> is 1 + 3i
07:17:34 <BenceF> ahh
07:18:00 <benmachine> > (0 :+ 1) ^ 2
07:18:01 <lambdabot>   (-1.0) :+ 0.0
07:18:08 <BenceF> > (1 :+ 0) + (0 :+ 1)
07:18:10 <lambdabot>   1.0 :+ 1.0
07:18:15 <BenceF> cool
07:18:42 <BenceF> quite straightforward
07:19:07 <benmachine> yus
07:20:02 <Loriel> > i
07:20:04 <lambdabot>   i
07:20:32 <benmachine> > sqrt 2 * cis (pi / 4)
07:20:33 <lambdabot>   1.0000000000000002 :+ 1.0
07:20:42 <Loriel> @type cis
07:20:44 <lambdabot> forall a. (RealFloat a) => a -> Complex a
07:20:46 <benmachine> Loriel: different i :P
07:20:54 <benmachine> > k
07:20:56 <lambdabot>   k
07:21:06 <BenceF> yeah thats a char i think :D
07:21:13 <benmachine> it's not a char exactly
07:21:18 <Loriel> @type k
07:21:19 <lambdabot> Expr
07:21:25 <benmachine> it's a special data type with a clever Show instance
07:21:28 <benmachine> > var "x"
07:21:30 <lambdabot>   x
07:21:34 <benmachine> :t var
07:21:37 <lambdabot> forall a. String -> Sym a
07:21:59 <benmachine> hmm that might not be what I was looking for
07:22:19 <BenceF> can i make an infix operator prefix (polish notation)
07:22:21 <BenceF> ?
07:22:28 <benmachine> > (+) 2 3
07:22:30 <lambdabot>   5
07:22:44 <BenceF> ahh parens
07:23:16 <tensorpudding> prefix can be made infix with backticks also
07:23:36 <Twey> @let infixl (<|); (<|) = flip id in 3 <| 5 <| (+)
07:23:36 <lambdabot>   Parse error: LeftParen
07:23:40 <Twey> Boo
07:23:44 <tensorpudding> > 5 `elem` [1..10]
07:23:45 <lambdabot>   True
07:23:50 * Twey wants RPN :<
07:24:08 <Cale> @let infixl 0 (<|); (<|) = flip id in 3 <| 5 <| (+)
07:24:09 <lambdabot>   Parse error: LeftParen
07:24:15 <Twey> @let infixl 0 <|; (<|) = flip id in 3 <| 5 <| (+)
07:24:15 <lambdabot>   Parse error: KW_In
07:24:22 <Twey> Haha, hmm
07:24:22 <tensorpudding> i'm afraid RPN in Haskell would ruin it
07:24:23 <Cale> ah, right
07:24:28 <benmachine> KW_what
07:24:29 <Cale> > let infixl 0 <|; (<|) = flip id in 3 <| 5 <| (+)
07:24:31 <lambdabot>   Ambiguous type variable `t' in the constraint:
07:24:31 <lambdabot>    `GHC.Num.Num t' arising f...
07:24:46 <Cale> > let infixr 0 <|; (<|) = flip id in 3 <| 5 <| (+)
07:24:47 <lambdabot>   8
07:25:27 <benmachine> @let infixr 0 <|
07:25:28 <lambdabot>  <local>:6:9:
07:25:28 <lambdabot>      The fixity signature for `<|' lacks an accompanying bindin...
07:25:31 <Twey> Oh, duh
07:25:33 <Twey> Haha.
07:25:42 <benmachine> @let infixr 0 <|; (<|) = flip id
07:25:43 <lambdabot>  Defined.
07:25:52 <benmachine> > 2 <| 4 <| (*)
07:25:53 <lambdabot>   8
07:26:06 <Twey> > 4 <| 2 <| subtract
07:26:06 <Stinger>  > let infixr 0 <|; (<|) = flip id in 3 <| 5 <| (+) <| 4 <| (*)
07:26:08 <lambdabot>   2
07:26:15 <Stinger> > let infixr 0 <|; (<|) = flip id in 3 <| 5 <| (+) <| 4 <| (*)
07:26:16 <lambdabot>   No instance for (GHC.Num.Num (a -> a -> a))
07:26:16 <lambdabot>    arising from the literal `4'...
07:27:40 <benmachine> the fixity doesn't really work
07:27:56 <benmachine> you need it to sometimes associate left and sometimes right
07:28:02 <benmachine> maybe you could do it with another operator
07:28:49 <Cale> > let start k = k (); end = fst; push x s k = k (x,s); app2 f (a,(b,s)) k = k (f a b, s) in start (push 5) (push 7) (app2 (+)) end
07:28:51 <lambdabot>   12
07:29:18 <benmachine> hah nice
07:29:38 <Cale> > let start k = k (); end = fst; push x s k = k (x,s); app2 f (a,(b,s)) k = k (f a b, s) in start (push 3) (push 5) (push 7) (app2 (+)) (app2 (*)) end
07:29:40 <lambdabot>   36
07:30:08 <interferon> so i understand that the IO monad provides a way to do imperative programming in a pure language, but are there practical benefitst that the IO monad provides over old-fashioned imperative programs?  is the main factor that IO code is cordoned off from the rest of an app?
07:30:32 <Cale> interferon: Well, that's a major thing.
07:30:44 <interferon> i realize it's a broad question
07:30:56 <Loriel> interferon: Another neat side effect is that IO operations are first class values.
07:31:02 <Loriel> You can put them into lists and everything.
07:31:07 <Cale> interferon: There's also the advantage that IO actions are values, which can be combined safely without worrying about things going off prematurely.
07:31:15 <interferon> but does programming in the IO monad alleviate any of the problems of stateful, side effect-ful programming, or are you in the same boat as you'd be in another imperative language?
07:31:21 <interferon> hmm that's a good point
07:31:34 <Cale> and the advantage of IO being a monad is mostly in the fact that you get all the stuff in Control.Monad for free
07:31:56 <Cale> That's not such a big deal. People focus on the "monad" part a bit too much, I think.
07:31:58 <benmachine> :t replicateM getLine
07:31:59 <lambdabot>     Couldn't match expected type `Int'
07:32:00 <lambdabot>            against inferred type `IO String'
07:32:00 <lambdabot>     In the first argument of `replicateM', namely `getLine'
07:32:01 <benmachine> err
07:32:04 <benmachine> :t replicateM 5 getLine
07:32:05 <lambdabot> IO [String]
07:32:13 <Cale> The real innovation is that IO actions are values of a separate type.
07:32:22 <Loriel> interferon: You are pretty much in the same boat as long as you are in the IO monad. The idea is that you drop to pure code or other, less dangerous monads for as large chunks of your program as possible.
07:32:35 <interferon> Cale: sorry, which isn't such a big deal?
07:32:40 <Loriel> IO being a monad
07:32:41 <Cale> interferon: The fact that IO is a monad
07:33:04 <Cale> That just implies something about the API we have for combining IO actions
07:33:19 <Loriel> and, well, do-syntax
07:34:01 <Loriel> interferon: There is a bunch of other neat things you get from Haskell doing monad-ish IO, like software transactional memory as a monad
07:34:05 <EvilMachine> hi guys. why is the show function wrapping strings in quotes? that makes it impossible to write a function that accepts everything that is showable, and then just do "("++ show x ++")".
07:34:08 <syntaxglitch> interferon, note that you can write 100% imperative code if you want, just put everything in IO and write like you're using an impure language
07:34:12 <Loriel> which is separate from IO, but still
07:34:28 <mauke> EvilMachine: why does that make anything impossible?
07:34:45 <mauke> EvilMachine: it wraps strings in quotes because that's how you write strings in haskell
07:35:01 <Cale> EvilMachine: It puts strings in quotes because it's desirable to have Show instances which produce valid Haskell code.
07:35:16 <benmachine> and it's definitely desirable to be able to Read them again
07:35:25 <benmachine> which you can't do unless the quotes are there
07:35:33 <syntaxglitch> EvilMachine, Show just turns things into strings anyway, if you don't want quotes then don't show the string
07:35:41 <EvilMachine> mauke: because let evil x = "("++ show x ++")" in evil "betty" results in: ("betty") instead of (betty)
07:35:42 <Cale> Right, consider something like the Read instance for [String]
07:35:49 <mauke> EvilMachine: how is that evil?
07:35:56 <syntaxglitch> EvilMachine, then just use "(" ++ x ++ ")"
07:36:04 <mauke> EvilMachine: it's supposed to do that
07:36:11 <syntaxglitch> unless there's some reason you want to be showing x there
07:36:21 <Loriel> "betty" is a string, if you show a string, you want to see the "", otherwise you would not know it is a string
07:36:29 <EvilMachine> syntaxglitch: then “evil 1“ would not work.
07:36:33 <Cale> You *usually* know at compile time whether something is a string or not.
07:36:45 <EvilMachine> i need something that allows to show everything. you know. basic stuff
07:36:47 <mauke> EvilMachine: how would you distinguish evil 1 from evil "1"?
07:36:47 <Cale> So you can just use show or not accordingly.
07:36:48 <benmachine> EvilMachine: think about how evil 2 differs from evil "2", or evil (Just 2) from evil "Just 2" ... think about evil "2) lol butts (7"
07:36:52 <Loriel> Someone remind me how show special-cases [Char] to show different from all the other [a]
07:37:06 <mauke> Loriel: showList
07:37:09 <EvilMachine> mauke: i do not want it to be distinguishable, when printed :)
07:37:10 <mauke> special method hack
07:37:11 <syntaxglitch> Loriel, Show has a class function for showing a list of things
07:37:17 <benmachine> EvilMachine: write (evil 2) as (evil (show 2))
07:37:19 <benmachine> sorted
07:37:22 <mauke> EvilMachine: that's evil
07:37:54 <EvilMachine> Guys, do I really have to implement a special case just for strings, and use show for every other value? that’s just silly…
07:37:58 <Eduard_Munteanu> Hi.
07:38:07 <Cale> EvilMachine: You could also just make your own new typeclass.
07:38:08 <benmachine> if you want special behaviour for strings
07:38:14 <benmachine> then you have to have a special case for strings
07:38:16 <syntaxglitch> EvilMachine, what you're doing isn't what show is intended for, that's the thing
07:38:42 <EvilMachine> lol. i only used “evil” because “evil betty” is a inside joke here. sorry, i did forget that. ;)
07:38:43 <interferon> Cale, Loriel: thanks
07:38:59 <EvilMachine> (here= physical here. not here in this chatroom)
07:39:18 <Cale> EvilMachine: consider something like  show ["hello, there", "world"], and imagine trying to write a Read instance which would be able to read the result back into a value.
07:39:19 <benmachine> what you're doing isn't sensible to do imo :P ref. evil "7)\nlook I am on the next line ("
07:39:44 <benmachine> EvilMachine: evil betty is from kung pow, right?
07:40:00 <Berengal> EvilMachine: If you want to print things differently from show, that's just a matter of inventing prettyprinters. There are nice combinator libraries for those already
07:40:01 <Eduard_Munteanu> Heh, Kung Pow.
07:40:09 <mbln> Hi! I get a dependency problem involving quickcheck when trying to install lambdabot.
07:40:10 <syntaxglitch> EvilMachine, if it helps, think of show as being a very minimalist serialization API
07:40:12 <mbln> show-0.3.4 requires QuickCheck <2, but tagsoup-0.8 requires QuickCheck ==2.1.*
07:40:28 <Cale> mbln: I think I got an email about this...
07:40:32 <EvilMachine> syntaxglitch: ok, agreed. :) then let me ask a better question: how do I write a function, that allows you to pass anything that’s showable, and concat it no a string, so that I don’t have to handle strings in a special way?
07:40:38 * Cale is lazy about these things.
07:40:39 <EvilMachine> benmachine: yes
07:40:42 <Berengal> mbln: try with --constraint="tagsoup == 0.6"
07:40:50 <Cale> Did I even put lambdabot on hackage in the first place?
07:41:05 <Berengal> Cale: Yep
07:41:06 <EvilMachine> Cale: i do not need a read instance. it’s no meant to be parsable. ;)
07:41:06 <mauke> EvilMachine: that breaks parametricity or whatever it's called, so I don't think it's possible
07:41:08 <benmachine> EvilMachine: you're asking how to handle strings in a special way without handling strings in a special way, if you ask me :P
07:41:14 <Berengal> Or at least someone did
07:41:21 <Cale> Berengal: nope, gwern did.
07:41:24 <Berengal> Ah, ok
07:41:27 <benmachine> the solutions are, new typeclass, new function evil' = evil . show
07:41:35 <Cale> But somehow I'm the "maintainer"
07:41:38 <EvilMachine> benmachine: lol.
07:41:46 <Berengal> Cale: Well, you're the sucker that wrote it :P
07:41:51 <Cale> I didn't write it!
07:41:58 <Cale> I only *run* it.
07:42:00 <Berengal> Well, runs the one here
07:42:09 <Berengal> Those are synonyms on the internet boat
07:42:11 <benmachine> we are retroactively editing history so that Cale wrote lambdabot
07:42:37 <syntaxglitch> EvilMachine, like Berengal said, you want a pretty printer, you might be able to find something that already exists
07:42:46 * Cale sighs. Okay okay, let me take a look at this dependency bug patch
07:42:59 <Berengal> benmachine: No we aren't. Cale always wrote lambdabot. We were always allies with Oceania
07:43:05 <benmachine> cabal list show says
07:43:08 <benmachine>     License:  GPL Nothing
07:43:12 <EvilMachine> hmm, i just noticed that haskell does not even allow lists over type classes. :( why in the world not?
07:43:19 <benmachine> Berengal: :)
07:43:25 <mbln> Berengal: Thanks that appears to be working.
07:43:28 <mauke> EvilMachine: huh? typeclasses are not types
07:43:35 <EvilMachine> so?
07:43:35 <benmachine> EvilMachine: it does, it just takes a bit more ingenuity than you think
07:43:47 <mauke> EvilMachine: and [] takes a type
07:44:16 <EvilMachine> benmachine: it should not take any ingenuity. it’s plainly obvious that that is so useful that it should be a simple built-in functionality. :)
07:44:26 <benmachine> it's not that useful though
07:44:37 <BenceF> :t []
07:44:38 <lambdabot> forall a. [a]
07:44:43 <mauke> :k []
07:44:44 <lambdabot> * -> *
07:44:48 <interferon> are there any libraries for doing dataflow GUI programming in haskell?
07:44:54 <interferon> like lisp's cells?
07:45:02 <BenceF> :t (:)
07:45:03 <EvilMachine> mauke: if [] takes a type, then I surely could say Show a => [] a. no?
07:45:03 <lambdabot> forall a. a -> [a] -> [a]
07:45:12 <mauke> EvilMachine: yes, you can
07:45:15 <thaldyron> does anyone know a skip list implementation in Haskell?
07:45:21 <Berengal> EvilMachine: You can't have [forall a. Show a => a], but you can have data Showable = forall a. Show a => Showable a, and [Showable]
07:45:24 <Eduard_Munteanu> interferon, FRP?
07:45:29 <Eduard_Munteanu> Look at Grapefruit.
07:45:32 <mauke> you can have [forall a. Show a => a]
07:45:33 <benmachine> EvilMachine: if you did that then the *only* thing you could do would subsequently be show them
07:45:36 <mauke> it's just not useful
07:45:40 <benmachine> so why not just make them all Strings in the first place?
07:45:48 * Cale decides to just forward the email to gwern
07:45:50 <Berengal> mauke: Not without wrapping you can't
07:45:51 <Cale> hehe
07:45:52 <EvilMachine> uum, forall a.? that is no haskell, is it?
07:45:54 <benmachine> it really doesn't come up as often as you'd think
07:46:00 <benmachine> EvilMachine: GHC extension
07:46:11 <mauke> > [] :: [forall a. Show a => a]
07:46:11 <lambdabot>   No instance for (GHC.Show.Show (forall a. (GHC.Show.Show a) => a))
07:46:12 <lambdabot>    arisi...
07:46:17 <benmachine> hah
07:46:23 <mauke> > const 42 ([] :: [forall a. Show a => a])
07:46:24 <lambdabot>   42
07:46:30 * EvilMachine hates it when people introduce stuff that looks like made-up syntax, because it’s impossible to understand what was meant. ;)
07:46:30 <mauke> Berengal: looks like I can
07:46:45 <Berengal> > const 42 ([1, 2, "Hello"] :: [forall a. Show a => a])
07:46:47 <lambdabot>   Couldn't match expected type `a'
07:46:48 <lambdabot>         against inferred type `[GHC.Types....
07:46:49 <EvilMachine> benmachine: that would be an idea
07:47:06 <mauke> > length ([undefined, undefined, undefined] :: [forall a. Show a => a])
07:47:06 <lambdabot>   3
07:47:15 <Beelsebob> EvilMachine: forall is valid Haskell, yes
07:47:29 <Beelsebob> all types are assumed to be universally quantified though
07:47:37 <syntaxglitch> EvilMachine, I'm still inclined to say that it sounds like you're going about things the wrong way
07:47:47 <benmachine> agreed
07:47:57 <syntaxglitch> What you're trying to do is probably at least not idiomatic Haskell
07:48:17 <EvilMachine> Beelsebob: not really. it’s an extension. I can also define an extension where you can draw silly monkeys, and then throw that in your face, and expect you to understand what i meant. ;) (but i’m not that evil. ;)
07:48:22 <syntaxglitch> Things tend to be easier if you work with your tools instead of fighting them
07:48:42 <benmachine> EvilMachine: it's an extension that is implemented by every popular haskell compiler, I think
07:48:52 <benmachine> uhm, *the popular haskell compiler :P
07:48:57 <EvilMachine> lol
07:49:02 <benmachine> I think hugs has Rank2Types
07:49:04 <Twey> Haha
07:49:06 <Twey> Yeah
07:49:06 <benmachine> not sure though
07:49:20 <syntaxglitch> as an aside, forall is an ugly keyword, we should get rid of it
07:49:29 <syntaxglitch> enabling that extension should automatically enable unicode syntax
07:49:35 <Twey> Heh
07:49:38 <syntaxglitch> and you'd just use the upsidedown A
07:49:42 <syntaxglitch> much tidier
07:49:44 <benmachine> agh I can't remember the unicode for it
07:49:51 <Twey> That's lovely, until I have to code on Windows
07:49:53 <mauke> U+2200 (e2 88 80): FOR ALL [∀]
07:50:04 <benmachine> oh, I was trying 2201
07:50:05 <EvilMachine> yes, you know it just makes it panful beyond what is bearable, when you have to use advanced extensions and weird syntax hackery, just to do something that in every other language is built-in, because really everybody uses it all the time.
07:50:07 <benmachine> :(
07:50:10 <benmachine> ∃
07:50:24 <mauke> EvilMachine: what, like mutable variables?
07:50:28 <EvilMachine> syntaxglitch: i second unicode! :D
07:50:35 <EvilMachine> mauke: like whatever forall is
07:50:49 <benmachine> EvilMachine: everybody does not use it all the time
07:50:52 <mauke> EvilMachine: forall is not something everybody uses all the time in other languages
07:51:02 <mauke> EvilMachine: mutable variables are
07:51:18 <Eduard_Munteanu> I'm not sure making Haskell a pure functional APL is good.
07:51:21 <mauke> this clearly proves that Haskell sucks for writing programs
07:51:38 <benmachine> everyone knows that there are no programs written in haskell
07:51:39 <mauke> incidentally
07:51:41 <mauke> :t runST
07:51:42 <lambdabot> forall a. (forall s. ST s a) -> a
07:52:19 <Badger> @index runST
07:52:19 <lambdabot> Control.Monad.ST.Lazy, Control.Monad.ST, Control.Monad.ST.Strict
07:52:25 <EvilMachine> syntaxglitch: let unifun xs = map (λ x → x²) in putStr ⊗ show ⊗ unifun [1,2,3]
07:52:42 <syntaxglitch> EvilMachine, I wish
07:52:45 <benmachine> λ isn't allowed in lambdas
07:52:50 <Badger> ha
07:52:50 <mauke> yes, it is
07:52:51 <EvilMachine> syntaxglitch: i can
07:52:52 <syntaxglitch> lambda is a letter :(
07:52:54 <benmachine> unless you use that magic emacs thing
07:52:55 <Badger> control.monad.st is a website
07:53:00 <mauke> map (\λ → λ²)
07:53:07 <EvilMachine> syntaxglitch: well, with leksah, I can do it right now
07:53:09 <benmachine> mauke: pedant :P
07:53:22 <syntaxglitch> mauke, somehow that doesn't quite help
07:53:30 <mauke> map (join (*))
07:53:41 <mauke> PROBLEM SOLVED, WHO NEEDS LAMBDA ANYWAY
07:53:46 <benmachine> heh
07:53:59 <Eduard_Munteanu> :t >>=
07:54:00 <lambdabot> parse error on input `>>='
07:54:04 <Eduard_Munteanu> :t (>>=)
07:54:04 <syntaxglitch> EvilMachine, leksah cheats and displays a lambda, but puts a \ in the file
07:54:05 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
07:54:17 <EvilMachine> syntaxglitch: yes.
07:54:20 <benmachine> EvilMachine: leksah is lying to you
07:54:38 <EvilMachine> syntaxglitch: i think haskell 2011 should expect λ instead of \. :D
07:55:15 <Eduard_Munteanu> :t map (join (*))
07:55:16 <lambdabot> forall a. (Num a) => [a] -> [a]
07:55:17 <benmachine> EvilMachine: but then greeks would have weird parse errors when they tried to name variables beginning with l
07:55:20 * syntaxglitch should hack GHC so that enabling unicode syntax adds a special case to not treat λ as alphanumeric
07:55:21 <BenceF> exclusivly
07:55:26 <Eduard_Munteanu> :t (join (*))
07:55:27 <lambdabot> forall a. (Num a) => a -> a
07:55:47 <Eduard_Munteanu> Bah, no monadic join in Prelude IIRC.
07:56:01 <benmachine> it's in Control.Monad
07:56:03 <Loriel> @type Prelude.join
07:56:05 <lambdabot> Not in scope: `Prelude.join'
07:56:05 <mauke> import Control.Monad.Instances
07:56:06 <syntaxglitch> benmachine, isn't there a separate unicode character for the "math" lambda vs. the greek alphabet?
07:56:09 <benmachine> :t (>>= id)
07:56:11 <lambdabot> forall (m :: * -> *) b. (Monad m) => m (m b) -> m b
07:56:13 <EvilMachine> benmachine, mauke: i did not saythat everybody uses forall all the time. i said that everybody tries to print values and strings all the time, and that they ofter are stored in lists. besides, type classes are cool because you can ignore the type, as long as it’s of that class. which is not the case if you want to print strings and numbers. well, whatever…
07:56:16 <benmachine> syntaxglitch: pass
07:56:34 <mauke> EvilMachine: I don't understand your obsession with forall
07:56:42 <EvilMachine> benmachine: lol. yes @ weird pars errors
07:56:59 <jaspervdj> Module/Library/Testing question here. It seems that it is the convention for testing libraries to have your library, and then an program testing this library with QuickCheck/HUnit
07:57:01 <EvilMachine> mauke: again: i am not talking about forall! damnit! ;)
07:57:14 <mauke> EvilMachine:  "mauke: i did not saythat everybody uses forall all the time."
07:57:16 <jaspervdj> but what is the way to go if you also want to test non-exposed Modules?
07:57:34 <kamatsu> jaspervdj: can't you import the modules directly?
07:57:46 <mauke> EvilMachine: no matter what you do, [] is homogenous. all elements have the same type.
07:57:48 <syntaxglitch> EvilMachine, "printing values and strings" without having any idea what their types are is probably not idiomatic haskell
07:58:10 <benmachine> haskell does things differently
07:58:24 <EvilMachine> mauke: aaaaahhhhh! *that* is a sentence that says that I did not talk about forall, and you are trying to use it, to show me that i talk about forall?? are you doing this deliberately? stop it! ^^
07:58:28 <jaspervdj> kamatsu: how would I go about that?
07:58:48 <mauke> EvilMachine: dude, that sentence contains "forall". of course you are talking about it
07:58:53 <kamatsu> jaspervdj: you have a module, say A.A, A.B, and A.C
07:58:58 <Eduard_Munteanu> forall body. forall b. a -> b
07:59:00 <kamatsu> and A export A.A and A.C
07:59:05 <kamatsu> but not A.B
07:59:07 <mauke> EvilMachine: which makes me thing you completely missed my point (by defending against something you weren't accused of)
07:59:11 <kamatsu> your test program just imports and tests A.B directly
07:59:15 <kamatsu> rather than importing A.
07:59:17 * BenceF sees the tought police approaching
07:59:19 <EvilMachine> mauke: aaaahhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhrrrgg!!!
07:59:24 * benmachine giggles
07:59:43 <benmachine> EvilMachine: you are not going to convince mauke that he is wrong (largely because he isn't)
07:59:47 <benmachine> go and get a cup of tea or something
07:59:49 <syntaxglitch> EvilMachine, again, stop fighting your tools
08:00:01 <jaspervdj> kamatsu: well, but these modules are not listed under exposed-modules in the cabal file
08:00:08 <mauke> syntaxglitch: who are you calling a tool?!!?!@#
08:00:10 <jaspervdj> kamatsu: so you can't do that
08:00:23 <kamatsu> jaspervdj: this is a test, you don't need to distribute it in the package
08:00:36 * benmachine wonders whether q x || or (gmapQ anywhereBut p q) x) is better or worse than or (q x : gmapQ (anywhereBut p q) x) stylistically
08:00:36 <EvilMachine> mauke: you are forcing me to talk about that thing i will not mentioning anymore from now on. i always say that that was not my point, and you always drag me back in. sorry, i will not play that silly game anymore.
08:01:02 <EvilMachine> benmachine: i am also not trying to convince anything.
08:01:02 <mauke> EvilMachine: yes. why do you always say that wasn't your point when that's completely irrelevant?
08:01:09 <benmachine> oh wait, parenthised that wrong
08:01:11 <benmachine> oh well.
08:01:18 <kamatsu> EvilMachine: benmachine Let's slow down here
08:01:18 <benmachine> EvilMachine: well, what *are* you trying to do then?
08:01:23 * EvilMachine wonders why he expected normal human interaction in here. ;)
08:01:24 <kamatsu> what do you want to do?
08:01:25 <syntaxglitch> EvilMachine, your problem is very likely to be that you're not writing idiomatic Haskell
08:01:30 <benmachine> oh man zing
08:02:03 <Sagi> so, you basicly had this question about debugprinting, didn't you?
08:02:15 <mauke> I don't think it's for debugging
08:02:18 <Eduard_Munteanu> :t interact
08:02:19 <lambdabot> (String -> String) -> IO ()
08:02:25 <EvilMachine> mauke: because it’s not. but hey, you did not even understand what i meant. i also do not think you ever will, because i think you’re not able to. so i’m going to stop this discussion now.
08:02:30 <Eduard_Munteanu> No human inthere :P
08:02:39 * EvilMachine ends the discussion about this
08:02:58 <Badger> Eduard_Munteanu: humans are all IO :P
08:03:09 <Eduard_Munteanu> Badger, hm, good way to think about it.
08:03:16 <BenceF> EvilMachine: escape the infinite loop of this conversation, and get to the actual problem. irc doesnt have lazy evaluation
08:03:33 <benmachine> BenceF: I think we've escaped now
08:03:40 <BenceF> cool
08:03:53 <Badger> break;
08:03:58 <kamatsu> EvilMachine: explain what you want
08:04:01 <BenceF> so what are we want to do?
08:04:18 <BenceF> overwrite the show instance of strings?
08:04:19 <Eduard_Munteanu> I sometimes think people will invent PHC, the Procrastinating Haskell Compiler :P
08:04:26 <benmachine> haha
08:04:32 <EvilMachine> Badger: see, that’s what’s wrong in here. ;) humans can’t be treated like computers. we have normal discussion.… oh well, what’s the point of explaining it. :(
08:04:32 <mauke> custom show instance for strings + existential types
08:04:33 <benmachine> *really* lazy evaluation
08:04:42 <Eduard_Munteanu> Terribly lazy :P
08:04:47 <kamatsu> EvilMachine: Please re-explain it because I dont want to read pages of history
08:05:01 <olsner> Eduard_Munteanu: perhaps one that outputs a shell script that compiles the source before running :)
08:05:06 <BenceF> existential types?
08:05:10 <mauke> EvilMachine: what do you know about humans anyway, you're just an evil machine :-)
08:05:16 <EvilMachine> remember that i respect you all, so no, i do not want tocause any flaming in here. :) i will stop now.
08:05:17 <BenceF> :t Camus
08:05:18 <syntaxglitch> I think lazy compilation is called "JIT"
08:05:19 <lambdabot> Not in scope: data constructor `Camus'
08:05:35 <Eduard_Munteanu> olsner, heh, yeah.
08:05:38 <benmachine> mauke: do you have something against machines :O
08:05:44 <kamatsu> EvilMachine: You're having a problem, we can help, mauke may have been a bit harsh, whatever, just tell us the problems.
08:05:56 <kamatsu> EvilMachine: pouting will not help
08:05:59 <olsner> if you can make the lazy haskell compiler do lazy (run-time) typechecking, you get something like a dynamically typed language
08:06:42 <syntaxglitch> olsner, except that type checks are still compile time, even if lazily evaluated
08:06:54 <BenceF> EvilMachine: what do you want to use it for? that might help
08:07:00 <EvilMachine> kamatsu: thank you. :) but i have lost faith. i’ll do it in python, in about 30 seconds without learning advanced CS theory and extension. ;)
08:07:02 <Eduard_Munteanu> olsner, hm, we do have Data.Dynamic... I thought about doing type arithmetic on runtime values.
08:07:06 <benmachine> dude doesn't want to talk about it
08:07:08 <syntaxglitch> so it'd be like a dynamic language, except any type check errors get displayed on the terminal of the programmer who wrote the code, not the user
08:07:09 <benmachine> so let's not try to make him
08:07:11 <EnglishGent^bbl> wouldnt doing the type-checks at runtime eliminate most of the benefits of the type system?
08:07:20 <olsner> syntaxglitch: that's what I meant it wouldn't do
08:07:22 <Badger> benmachine: no! there is a problem, and it Must Be Solved!
08:07:28 <EnglishGent^bbl> the whole point is that you find out you have a bug at compile time - not *maybe* later at run time
08:07:33 <benmachine> Badger: someone is *wrong* on the Internet!
08:07:37 <kamatsu> EvilMachine: Python does it worse ;) And You don't need advanced cs for anything in haskell for most problems
08:07:41 <kamatsu> EvilMachine: except cs problems
08:08:02 <Eduard_Munteanu> That would also make types lazy.
08:08:04 <EvilMachine> kamatsu: yes i do. i need forall a. whatever, just to print a list of strings and numbers.
08:08:08 <syntaxglitch> EvilMachine, writing Python code using Python is probably better than writing Python code using Haskell, which is what I suspect you were trying to do
08:08:22 <Eduard_Munteanu> "You know, he's the lazy type" :)
08:08:25 * Sagi kickstarts mauke 
08:08:45 * EnglishGent^bbl waits for someone to invent bone-idle evaluation
08:08:52 <kamatsu> EvilMachine: Oh, if you want to make a list of both numbers and strings, you need forall, but if you want to just print them all out, why don't you show them before adding them to the list, then print the list?
08:08:52 <benmachine> syntaxglitch: kamatsu: learn to recognise stubbornness when you see it :P
08:08:53 <EnglishGent^bbl> I'd do it myself - but I'm too lazy
08:08:54 <EnglishGent^bbl> :)
08:09:05 * benmachine hugs EnglishGent^bbl 
08:09:10 <BenceF> were on the verge of losing someone for python
08:09:15 <Eduard_Munteanu> Yeah, something that never starts work, not to mention finishing it.
08:09:18 <benmachine> oh they deserve each other
08:09:19 <EvilMachine> syntaxglitch: lol. you suspected wrong. wanna know the funniest thing? i came to haskell, because i designed a language after the way i myself think of programs, and then noticed that haskell was pretty much the same thing thought to the end.
08:09:22 <Eduard_Munteanu> EnglishGent, heh.
08:09:31 <nh2> can somebody explain me the "data List a = Nil | Cons a (List a) deriving Show" syntax? What is a in this case?
08:09:40 <kamatsu> EvilMachine: Lists are homogeneous
08:09:46 <kamatsu> EvilMachine: Every value in a list must be the same time
08:09:46 <benmachine> nh2: a is a type variable
08:09:47 <Eduard_Munteanu> nh2, it can be any type
08:09:53 <benmachine> nh2: so you can have a List of any type you like
08:09:59 <Eduard_Munteanu> nh2, for example, you can have List Int
08:10:11 <benmachine> nh2: so, List Int is either Nil or Cons Int (List Int)
08:10:32 <EvilMachine> kamatsu: i can’t just show them before adding them to the list, because showing a string results in quotes being put around it, which i do not want, expect, and no other language i know does.
08:10:59 <Berengal> EvilMachine: Python does.
08:11:07 <EnglishGent> also (important note) - you can in fact have Lists where elements are of different types - as long as they have a type-class in common (existential types) - and you can even ditch _that_ restriction if you really want to (HLists)
08:11:14 <Berengal> EvilMachine: Haskell's 'show' is like Python's 'repr'
08:11:26 <EvilMachine> Berengal: hmm… i have to check that. i don’t think so.
08:11:26 <EnglishGent> (two things I have discovered whilst learning Haskell I wish I'd discovered sooner) :)
08:11:48 <Twey> So what's the equivalent of Python's ‘str’?
08:11:55 <Berengal> We don't have one
08:12:07 <kamatsu> Yeah, I've never encountered a situation where it's needed
08:12:08 <Berengal> Because "human readable" is abigous
08:12:23 <Twey> I'd think printf or PrettyPrint
08:12:23 <Berengal> s/ab/amb/
08:12:30 <EvilMachine> Berengal: ok, i expect to have a function that can concat anything to a string that is showable. which for me means, that strings are not additonally wrapped in quotes.
08:12:31 <benmachine> printf uses Show doesn't it?
08:12:34 <EnglishGent> coi Twey :)
08:12:39 <Twey> Berengal: ‘human readamble’?  :þ
08:12:46 <syntaxglitch> EvilMachine, I'll say this one final time: trying to print a bunch of things without distinguishing their types is a sign you're doing it the wrong way
08:12:52 <benmachine> individual types have their own prettyprinting toold
08:12:54 <benmachine> tools
08:13:01 <benmachine> like there is a showTree I think
08:13:08 <kamatsu> EvilMachine: Use printf?
08:13:09 <Twey> benmachine: Right
08:13:14 <Twey> EvilMachine: Use PrettyPrint!
08:13:16 <Eduard_Munteanu> show simply represents stuff as they would appear instantiated in code.
08:13:16 <benmachine> maybe it would be nice to have a class that gathered those
08:13:20 <EnglishGent> syntaxglitch - you could do that - have a list of Show - you need -XExistentialTypes as a compiler option though
08:13:21 <EvilMachine> Twey: exactly. you asked the right question. i need something like str
08:13:24 <benmachine> or maybe there is one
08:13:37 <Eduard_Munteanu> > putStrLn $ show [1, 2, 3]
08:13:38 <lambdabot>   <IO ()>
08:13:48 <Eduard_Munteanu> > show [1, 2, 3]
08:13:49 <syntaxglitch> EnglishGent, of course it's possible, it's just usually not the right way to do it
08:13:49 <lambdabot>   "[1,2,3]"
08:13:57 <Eduard_Munteanu> > show "Hello"
08:13:57 <nh2> ok, I understand. But what makes it possible to write "List a", the identifiers after each other? is it the List keyword of the data keyword (I think its the latter, it seems to work with Listfoo, too, but am not sure)
08:13:57 <lambdabot>   "\"Hello\""
08:14:01 <EvilMachine> Berengal: consider human readability to be more important,when it’s supposed to be printed for a *human* :)
08:14:09 <kamatsu> EvilMachine: The main thing is
08:14:15 <benmachine> nh2: List is not a keyword
08:14:18 <kamatsu> EvilMachine: You need to be able to "Read" a "Show" type
08:14:29 <benmachine> data Wibble a = Bleep | Bloop a (Wibble a) -- is exactly the same type
08:14:31 <Eduard_Munteanu> nh2, no, you define List a to be the expression after the equal sign.
08:14:31 <syntaxglitch> EvilMachine, "show" prints for the programmer, not the user, it's human-readable serialization
08:14:36 <Twey> kamatsu: s/need to/should/
08:14:42 <kamatsu> Twey: right right
08:14:42 <Berengal> EvilMachine: Yes, but it's still ambigous. Human readable formats aren't context free
08:14:56 <benmachine> eee writing speed in here just eclipsed reading speed
08:14:57 <Eduard_Munteanu> nh2, so when you actually do List Int, it can take one of the two possible values.
08:15:02 <syntaxglitch> EvilMachine, perhaps if you showed us more of your program you'd get more help
08:15:03 <EnglishGent> actually - would there be a way to define a List type as an alias for [] - so you could write List Int instead of [Int] ? (newtype or something like that?)
08:15:05 * benmachine starts skimming
08:15:22 <Twey> EnglishGent: type List a = [a]
08:15:22 <kamatsu> Indeed, I think EvilMachine has approached it the Python way
08:15:24 <Eduard_Munteanu> EnglishGent, um, I think so.
08:15:25 <kamatsu> Not the Haskell way
08:15:28 <Berengal> EvilMachine: So instead of providing something that's correct on some contexts, haskell gives you tools that can build something for any context
08:15:32 <Twey> EnglishGent: But you can already write [] Int
08:15:43 <EnglishGent> ty twanvl, Eduard_Munteanu :)
08:16:22 <twanvl> wow, that was easy, I don't have to do anything :)
08:16:30 <benmachine> heh
08:16:31 <syntaxglitch> I'll note that when I first started messing with Haskell I had a lot of headaches because of trying to use foreign idioms
08:16:36 <benmachine> thanks, twanvl!
08:16:55 <sshc> if I have an algorithm that brute-force checks every possible unique combination of three things, how would I write this in big O notation?
08:16:56 <twanvl> thanks, benmachine :)
08:17:03 <syntaxglitch> I think I kept trying to write Python in IO, and scheme everywhere else
08:17:19 <EnglishGent> another question - is there an accessible paper on how the type checker works anywhere? I'm really trying to acquire deep understanding of the type system - I dont mind investing effort
08:17:20 <EvilMachine> syntaxglitch: i do not want to see that it was a string. it’s not only irrelevant to the output,it is weird, because e.g. "mister " ++ name ++ " knows " ++ show property ++ " cars" would result in: mister nisbit knows "good" cars. and: mister nisbit knows 5 cars.
08:17:31 <benmachine> sshc: are the combinations ordered?
08:17:43 * EnglishGent trying to get a good understanding of type level programming
08:17:44 <EnglishGent> :)
08:17:48 <Berengal> EvilMachine: So write your own typeclass
08:17:50 <benmachine> sshc: uh, you can't really because you need to have a variable in there somewhere
08:18:04 <benmachine> every possible combination of n things, or every possible combination of three things chosen from n
08:18:34 <kamatsu> EvilMachine: Or just don't show the string ;)
08:18:36 <sshc> benmachine: say, I have a list of Int's, and I do something with every possible combination of three of those Int's
08:18:43 <benmachine> ah
08:18:46 <Twey> twanvl: Hehe
08:18:54 <Berengal> EvilMachine: Show is for serialization and debugging. You wouldn't use repr in python to interpolate strings for output either, but you would use it for serialization
08:19:09 <EvilMachine> kamatsu: yes, but if i don’t show the number 5, it will result in an error, so i have to use show
08:19:11 <benmachine> sshc: so, you're looking for the subsets of size 3 of a set of size n?
08:19:12 <Twey> sshc: O(l*n*m) I think
08:19:20 <kamatsu> EvilMachine: What about Printf?
08:19:29 <benmachine> that would be O(n^3) I think
08:19:36 <EvilMachine> ok, hey, let’s start over. what would be the proper haskell idioms. forget the python stuff. :)
08:19:42 <Twey> Is it really exponential?
08:19:43 <EvilMachine> ?
08:19:47 <Berengal> EvilMachine: Text.PrettyPrint
08:19:48 <benmachine> Twey: um, no
08:19:51 <benmachine> it's polynomial
08:19:53 <Twey> 16:12:51 < Twey> EvilMachine: Use PrettyPrint!
08:19:55 <BenceF> map / fold?
08:19:58 <kamatsu> Okay, so what you're trying to do shouldn't happen in most Haskell programs anyway
08:20:04 <kamatsu> But yeah, PrettyPrint might do it
08:20:05 <Twey> benmachine: Er, yes
08:20:16 <syntaxglitch> EvilMachine, the first question is why you're trying to apply a function to something of two radically different types
08:20:18 <EvilMachine> oh, PrettyPrint? didn’t know that existed. i’ll look it up.
08:20:41 <benmachine> sshc: think of it as, how many ways can I choose the first int, how many ways can I choose the second, how many ways can I choose the third
08:20:42 <kamatsu> EvilMachine: Don't just accept PrettyPrint as your solution
08:20:45 <mbln> Why does lambdabot (in ghci) fail with "A Hoogle error occurred." every time I type :hoogle?
08:20:46 <EvilMachine> syntaxglitch: i’m applying a function to a values of the class Show.
08:20:47 <kamatsu> I still think you're doing something wrong
08:20:52 <benmachine> wait, if order doesn't matter it's still n cubed isn't it
08:20:59 <Twey> I'd imagine so
08:21:01 <EvilMachine> syntaxglitch: wich means they can be printed out
08:21:07 <benmachine> because you divide by the number of orderings and that's just si
08:21:09 <benmachine> six
08:21:10 <sshc> (I don't choose the same Int twice)
08:21:15 <Twey> benmachine: Actually…
08:21:32 <benmachine> sshc: right, so you can choose the first one in n ways, then there are n-1 left to choose for the second, then n-2
08:21:34 <nh2> ok thx @all
08:21:44 <benmachine> so n(n-1)(n-2) = n^3 + something
08:21:46 * syntaxglitch has to go do non-Haskell-related chores :(
08:21:49 <sshc> benmachine: so it is n^3?
08:21:54 <benmachine> sshc: I think so
08:22:04 <sshc> Twey: what are l and am in O(l*n*m)?
08:22:06 <benmachine> it's possible I've misunderstood your problem
08:22:17 <sshc> benmachine: you seem to understand it
08:22:28 <benmachine> note that if you're choosing k things I don't think it's O(n^k)
08:22:37 <Twey> I think it's O(3!) maybe
08:22:49 <Twey> Yeah
08:22:56 <sshc> benmachine: wouldn't it be?
08:23:03 <EnglishGent> hi dolio
08:23:07 <Twey> nCr = n! / r! (n - r)!
08:23:11 <sshc> Twey: don't you need a variable in there?
08:23:20 <benmachine> sshc: no, because there are some more k terms
08:23:24 <Twey> sshc: No, because you're choosing a consant three things
08:23:30 <Twey> constant**
08:23:33 <benmachine> that become constant terms and are hence ignored for constant k
08:23:37 <Twey> For an arbitrary number, it would be O(n!)
08:23:55 <benmachine> an arbitrary number?
08:24:00 <benmachine> is 7 arbitrary enough
08:24:06 <Twey> Ha ha :þ
08:24:43 <sshc> Twey: if I were doing something with every 1 integer, then the big-O notation for that would be O(1)?
08:24:47 <EvilMachine> kamatsu: oh, offer me a function that takes everything that is showable, and results in the sentence "Mr. Nisbit knows many cars" when it is given a string, but in "Mr. Nisbit knows X cars" (where X is the shown value). :)
08:25:04 <benmachine> it'd have to be O(n)
08:25:06 <sshc> Twey: but a longer list will obviously take longer to do something with
08:25:08 <benmachine> cos there are n of them
08:25:22 <EvilMachine> kamatsu: because you must agree, that in every other language, that is no problem to do, is it? :)
08:25:25 <benmachine> sshc: is doing something with 1 and 2 different from doing something with 2 and 1?
08:25:27 <sshc> benmachine: Twey was saying that it's O(n!) for any arbitrary number
08:25:30 <mauke> EvilMachine: impossible
08:25:33 <kamatsu> EvilMachine: It requires a typeclass
08:25:41 <EvilMachine> kamatsu: and: yes, i should not have started again. ^^
08:25:53 <mauke> EvilMachine: all other languages don't have Show
08:26:01 <mauke> so that comparison doesn't make sense
08:26:02 <sshc> benmachine: the algorithm wouldn't do that
08:26:03 <EvilMachine> mauke: ouch. other languages: 1, Haskell: 0 (because impossible)
08:26:11 <mauke> EvilMachine: all other languages don't have Show
08:26:16 <benmachine> sshc: so you choose 1 and 2 but not 2 and 1
08:26:17 <kamatsu> EvilMachine: That is an unfair comparison
08:26:22 <EvilMachine> mauke: because they don’t need it! ^^
08:26:24 <benmachine> right?
08:26:34 <sshc> right
08:26:38 <mauke> EvilMachine: then how do you write that function in other languages?
08:26:45 <kamatsu> EvilMachine: Such an example is contrived because we don't need to solve such programs if we write the code righ
08:26:51 <kamatsu> *right
08:26:54 <sshc> benmachine: if all the integers were different, you won't see the same integers in any two combinations, regardless of order
08:27:02 <benmachine> okay
08:27:15 <EvilMachine> mauke: i could become evil, and do it in php. ;))) but something inside me stops me from such a cruelty. ;)
08:27:19 <kamatsu> EvilMachine: I could just as easily say Haskell: 1000, Other Languages: 1 because Haskell has higher kinded polymorphism that most other languages dont
08:27:30 <kamatsu> which opens up thousands of possibilities
08:27:30 <benmachine> so basically you are looking for the complexity of nCr
08:27:39 <sshc> benmachine: I'm not sure?
08:27:54 <sshc> I don't think it's O(3!)
08:27:55 <BenceF> however it seems haskell is not for writing viruses
08:27:56 <BenceF> :D
08:27:56 <SKK> what is lambdabot?
08:27:57 <ClaudiusMaximus> O(n^n) = O(n!) afaik, so i think O(n^k) is a reasonable measure, been a while since i measured asymptotics though
08:28:10 <benmachine> sshc: http://en.wikipedia.org/wiki/Combinations you can skip to the interesting formulae if you like
08:28:10 <kamatsu> EvilMachine: Also, it's quite achievable with typeclasses, but this sounds like you're doing it wrong
08:28:21 <mauke> @let evil x = let y = show x in case reads y of [(z, "")] -> x `asTypeOf` z; _ -> y
08:28:22 <lambdabot>  Defined.
08:28:27 <mauke> > evil 42
08:28:28 <kamatsu> EvilMachine: Please share more of your program
08:28:28 <lambdabot>   No instance for (GHC.Num.Num GHC.Base.String)
08:28:28 <lambdabot>    arising from the literal `...
08:28:33 <sshc> ClaudiusMaximus: what are n and k?
08:28:38 <benmachine> ClaudiusMaximus: I think n^n grows faster than n!
08:28:42 <benmachine> could be wrong about that though
08:28:47 <mauke> ah, I see
08:28:49 <mauke> @undefine
08:28:56 <mauke> @let evil x = let y = show x in case reads y of [(z, "")] -> z; _ -> y
08:28:56 <Twey> ClaudiusMaximus: Certainly not
08:28:57 <lambdabot>  Defined.
08:28:58 <EvilMachine> mauke: is JavaScript it would be bla = function (val) { return "Mr Nisbit knows "+val+" cars." }; alert(bla(5)); alert(bla("many"));
08:29:02 <mauke> > evil 42
08:29:03 <lambdabot>   "42"
08:29:06 <mauke> > evil "many"
08:29:07 <lambdabot>   "many"
08:29:07 <SKK> wow cool
08:29:10 <SKK> evil "hi"
08:29:18 <ClaudiusMaximus> ok, i was wrong it seems!
08:29:20 <benmachine> SKK: don't forget the >
08:29:21 <mauke> EvilMachine: how do you define your own type in javascript?
08:29:22 <SKK> > evil 20
08:29:24 <lambdabot>   "20"
08:29:36 <EnglishGent> surely it's let evil = unsafePerformIO :)
08:29:45 <kamatsu> EnglishGent: not helping
08:29:50 <EnglishGent> sorry
08:29:52 <EvilMachine> kamatsu: ok yes, i agree that haskell had a score of 1000 and others maybe a score of 100. but now haskell has just lost a point and stands at 999. ;)
08:29:53 * benmachine hugs EnglishGent 
08:29:58 <Twey> mauke, EvilMachine: Javascript toString() is ‘human-readable’ and therefore not comparable to Show
08:30:02 <benmachine> eer where was I
08:30:09 <sshc> it's not linear because adding an integer to the list adds another possible combination for all the other integers in the list except two
08:30:31 <benmachine> sshc: did you read the wikipedia page? (don't blame you if you didn't, it's kind of tedious)
08:30:45 <mauke> > (evil '"', evil "\"")
08:30:46 <lambdabot>   ("'\"'","\"")
08:30:47 <sshc> my algorithm takes a list of integers and does something with every possible unique combination of three integers
08:30:50 <sshc> benmachine: not yet
08:31:01 <SKK> @add 2/3 (1 :+ 3)
08:31:01 <kamatsu> EvilMachine: Why, because haskell has sane types?
08:31:01 <lambdabot> Maybe you meant: arr ask bid do id
08:31:04 <kamatsu> EvilMachine: That's a good thing
08:31:10 <sshc> benmachine: what would big O notation be?
08:31:16 <kamatsu> EvilMachine: Your program has been incorrectly designed
08:31:20 <Twey> @let fact = (facts !!) where facts = scanl1 (*) [1 ..]
08:31:21 <lambdabot>  Defined.
08:31:24 <kamatsu> EvilMachine: When do you intend to use this function?
08:31:24 <EvilMachine> mauke: ok, then what is comparable to toString() in haskell?
08:31:28 <BenceF> sshc: then O(n^3)
08:31:33 <kamatsu> EvilMachine: There is virtually no need for it
08:31:36 <BenceF> sshc: i think
08:31:48 <sshc> BenceF: I think you're right
08:31:54 <benmachine> sshc: well, that page tells you what the number of combinations is, the big O depends on which you hold constant
08:31:54 <BenceF> sshc: but why do you need to know? is it a homework?
08:31:55 <sshc> although I would like a certain answer
08:31:58 <mauke> EvilMachine: dunno, you could write your own
08:32:01 <kamatsu> EvilMachine: You never have a situation in haskell were you do not know the type or type class of a value
08:32:10 <rovar> has anyone used the hs-plugins library recently?
08:32:13 <PeakerWork> the Haskell Platform source: make install tries to run mtl-1.1.0.2/Setup -- but the mtl-1.1.0.2 dir is under packages/  Anyone knows anything about this?
08:32:13 <kamatsu> EvilMachine: Hence you rarely need functions overloaded across types
08:32:16 <sshc> BenceF: it's not homework
08:32:18 <benmachine> sshc: if we're still only talking about 3 then I think O(n^3) too, but I was interested in the general case
08:32:32 <benmachine> if you're not then ignore all my rambling :)
08:33:03 <EvilMachine> mauke: lol. are you telling me the great Haskell (which i still love) does not even have a toString() function? what else? no additon? ;)
08:33:16 <kamatsu> EvilMachine: You don't need it!
08:33:17 <mauke> EvilMachine: yes
08:33:18 <sshc> benmachine: in this specific algorithm with which I'm dealing, yes, it is 3, but out of curiosity, I would like to know what big O notation would be for algorithm that did the same but instead did combinations of n integrs
08:33:22 <sshc> integers
08:33:25 <Twey> @let tetrate n m = foldl' (^) m $ replicate (n - 1) m
08:33:26 <lambdabot>  Defined.
08:33:30 <mauke> EvilMachine: addition is also part of a typeclass in a library
08:33:40 <mauke> EvilMachine: which you could define yourself
08:33:54 <BenceF> sshc: however i never get the big o notation. but if you take all the (a,b,c) variables from a list, where a can be =b=c then youve got n^3 tuples
08:33:58 <BenceF> thats sure
08:34:00 <mbln> How can I enable GNU readline in ghci (on Ubuntu Karmic)? Do I need to re-build ghc?
08:34:00 <kamatsu> Yep, addition is not part of the core semantics of the language, as such
08:34:12 <mauke> mbln: which version of ghci?
08:34:26 <mbln> mauke: 6.10.4
08:34:26 <Twey> > map (tetrate 2 &&& fact) [1 .. 10]
08:34:27 <benmachine> sshc: for choosing 3 things from n things, the formula on the wiki page is n!/3!(n-3)!, but 3! is a constant so this is O(n!/(n-3)!) but that's just O(n(n-1)(n-2)) which is a cubic
08:34:27 <lambdabot>   [(1,2),(4,6),(27,24),(256,120),(3125,720),(46656,5040),(823543,40320),(1677...
08:34:32 <mauke> mbln: impossible AFAIK
08:34:34 <EvilMachine> mauke: i seriously think about ever using Haskell again, right now. because this is just silly.
08:34:36 <Twey> ClaudiusMaximus: ^
08:34:40 <mbln> mauke: argh
08:34:43 <kamatsu> EvilMachine: YOU DO NOT NEED IT
08:34:47 <mauke> EvilMachine: no, your requirements are silly. I've never needed that
08:34:55 <benmachine> kamatsu: jeez, indoor voice please
08:34:56 <mauke> (regardless of language)
08:35:08 <Twey> As you can see, the order of growth of n ↑↑ 2 and n! are quite different
08:35:16 <kamatsu> benmachine: I am repeating myself due to obstinate not listening on the part of the other party
08:35:24 <kamatsu> benmachine: hence my frustration
08:35:35 <benmachine> kamatsu: it's easy to not listen to people on IRC, nothing you do will change that
08:35:36 <mauke> EvilMachine: also, javascript, php and perl are not "all other languages"
08:35:40 <benmachine> if you get frustrated, give up
08:35:44 <benmachine> that is my advice
08:35:46 <ClaudiusMaximus> Twey: thanks
08:35:49 <benmachine> but you are welcome to do whatever pleases you
08:35:50 <kamatsu> benmachine: ah, i guess you're right
08:35:52 <mauke> "if at first you don't succeed ..."
08:35:57 <EvilMachine> kamatsu: are you telling me i will never have the need to print strings or numbers as-is? and that i only need to print strings that have quotes around them? ;)
08:36:05 <kamatsu> EvilMachine: Yes.
08:36:07 <sshc> benmachine: thanks!
08:36:20 <Twey> @let (↑↑) = flip tetrate
08:36:22 <lambdabot>  Defined.
08:36:22 <kamatsu> EvilMachine: You can print strings without quotes, just don't use "show"
08:36:35 <benmachine> sshc: if you were generalising to k things, I think you get big-O notation just by putting an O() around the formula
08:36:47 <benmachine> could be wrong about that though
08:36:48 <Twey> EvilMachine: kamatsu is saying that you should never need to output something without knowing its type
08:36:57 <shambler> @hoogle putstr
08:36:58 <lambdabot> Prelude putStr :: String -> IO ()
08:36:58 <lambdabot> Data.ByteString putStr :: ByteString -> IO ()
08:36:58 <lambdabot> System.IO putStr :: String -> IO ()
08:37:08 <shambler> @hoogle putstrln
08:37:09 <lambdabot> Prelude putStrLn :: String -> IO ()
08:37:09 <lambdabot> Data.ByteString putStrLn :: ByteString -> IO ()
08:37:09 <lambdabot> System.IO putStrLn :: String -> IO ()
08:37:17 <Twey> And if you do, you're either doing crazy type-hackery measurable in deciOlegs, or your program design is bad
08:37:17 <sshc> benmachine: for choosing 7 things from n things, that would be
08:37:22 <EvilMachine> kamatsu: i’m sorry that we have such a hard time communicating. believe me that you sound completely silly and irrational from my p.o.v.. so you’re not the only one having a hard time. :)
08:37:35 <sshc> benmachine: O(n!/(n-7)!) ?
08:37:39 <kamatsu> EvilMachine: Think about it this way
08:37:52 <sshc> benmachine: since 7! is constant, it doesn't go in the big-O thing?
08:37:53 <kamatsu> EvilMachine: In any haskell function, you know about the types of all values in the functions
08:37:59 <benmachine> sshc: right
08:38:01 <Twey> EvilMachine: It's easily solved: come up with a program where you need to do that, and we'll show you how you should refactor it.  ☺
08:38:02 <kamatsu> EvilMachine: You know all the types, at the time of writing
08:38:16 <benmachine> sshc: but n!/(n-7)! = n(n-1)(n-2)...(n-6)
08:38:17 <mreh> if I want a user to supply configuration files, isn't that going to be a nightmare of cross platform compatibility
08:38:18 <kamatsu> EvilMachine: You should never need to make a function that deals with stuff, regardless of type
08:38:24 <benmachine> all the other terms cancel
08:38:28 <kamatsu> EvilMachine: Because you already know the type-specific way to deal with it
08:38:31 <sshc> benmachine: alright, thanks :)
08:38:33 <benmachine> then you just get O(n^7)
08:38:40 <PeakerWork> EvilMachine: Your tone sounds hostile and annoying, completely in contrast to #haskell's usual :-(
08:38:59 <EvilMachine> Twey: i know its type class. should be enough. after all that’s the point of type classes: that knowing its functions is all you need to handle all type that implement it.
08:39:06 <sshc> benmachine: so you can simplify choosing k things from n things to O(n^k)?
08:39:16 <mauke> EvilMachine: but that typeclass doesn't do what you want
08:39:21 <sshc> benmachine: I'll have to check that when I'm done eating
08:39:24 <benmachine> sshc: kind of...
08:39:34 <PeakerWork> What does EvilMachine want?
08:39:36 <Twey> EvilMachine: And in some cases, that's appropriate, and Show is the class you want.
08:39:36 <kamatsu> EvilMachine: you are fighting the type system, cooperate with it
08:39:47 <sshc> benmachine: that makes as much sense as "yes or no" or "true and false"
08:39:51 <benmachine> heh
08:39:54 <Twey> EvilMachine: Generating user-oriented output, however, is not what the Show class is for
08:39:55 <kamatsu> PeakerWork: long story
08:40:06 <PeakerWork> it sounds he just wants Show?
08:40:07 <Twey> EvilMachine: For that, you should use something like printf or PrettyPrint
08:40:17 <mauke> PeakerWork: custom show instance for strings + existential types
08:40:17 <benmachine> sshc: to be honest I only did order-notation recently myself, so I think you've reached the limit of my expertise
08:40:31 <Twey> PeakerWork: He wants Show to generate user-oriented output
08:40:39 <Twey> Rather than debugging representation
08:40:41 <mauke> where "user-oriented output" = id
08:40:50 <PeakerWork> mauke: for strings, I suppose
08:40:55 <kamatsu> PeakerWork: yeah
08:40:59 <PeakerWork> why existential types??
08:41:00 <sshc> benmachine: btw, yes, it is unorderd
08:41:05 <benmachine> sshc: yeah I got that :P
08:41:08 <mauke> PeakerWork: for a list of Showables
08:41:09 <kamatsu> PeakerWork: He wants a function to deal with stuff regardless of type
08:41:14 <PeakerWork> mauke: why not a list of strings?
08:41:19 <mauke> ask him, not me
08:41:22 <kamatsu> yeah
08:41:27 <EvilMachine> PeakerWork: oh, i’m sorry. i do not want to sound hostile. believe me that i respect you all guys. everybody is different, and so it’s ok that you think differently. it just is really hard to stay nice when someone else seems to deliberately drive you crazy. it’s hard to look past that.
08:41:39 <PeakerWork> EvilMachine: Why do you want a list of showables, and not a list of strings? There's only a small difference between the two in a lazy language
08:42:04 <PeakerWork> EvilMachine: basically, if Show only had the  show :: a -> String   function - then there'd be no difference at all
08:42:05 <EvilMachine> mauke: ok, there we agree. :) that type class does not do what i want.
08:42:15 <kamatsu> EvilMachine: This problem is easily solved by giving us a program where you actually need this, and we'll show you how to do it properly
08:42:27 <kamatsu> PeakerWork: doesn't it only have show?
08:42:29 <mauke> EvilMachine: so why do you keep wanting to use it?
08:42:35 <PeakerWork> EvilMachine: if you want a new type-class, you can create it (though a Pretty type-class does exist). But there are infinite ways to format any piece of data as a string
08:42:39 <benmachine> kamatsu: it also has showList for silly reasons
08:42:42 <PeakerWork> kamatsu: No, there's showsPred
08:42:47 <PeakerWork> @src Show
08:42:47 <lambdabot> class  Show a  where
08:42:48 <lambdabot>     showsPrec :: Int -> a -> ShowS
08:42:48 <lambdabot>     show      :: a   -> String
08:42:48 <lambdabot>     showList  :: [a] -> ShowS
08:42:50 <mauke> EvilMachine: insisting on Show is one of the things that make your requirements impossible to implement
08:42:57 <PeakerWork> showsPrec is really the fundamental method
08:43:02 <kamatsu> benmachine: showlist for strings i assume
08:43:20 <Twey> It enables stuff like show "\"\\\"\\\"\""
08:43:22 <benmachine> kamatsu: yeah, those reasons qualify as silly in my book :P
08:43:26 <benmachine> necessary but silly
08:43:43 <kamatsu> or just use overlapping instances
08:43:44 <BenceF> sshc: here it is: http://pastebin.com/db85b9c5
08:43:53 <kamatsu> but that's not h98
08:44:11 <EvilMachine> mauke: i just stopped wanting to use it. :)
08:44:12 <PeakerWork> the main difference between (exists a. Show a => a)  and   String   would be the existence of showsPrec.   I guess its more equivalent to:  (Int -> ShowS)
08:44:21 <mauke> EvilMachine: cool, then just make your own typeclass, done
08:45:09 <kamatsu> I still think he shouldn't need it in the first place
08:45:10 <mauke> I've done this on a smaller scale in preflex: printf "%_ is %_" x y
08:45:13 <pikhq> @src ShowS
08:45:14 <lambdabot> type ShowS = String -> String
08:45:19 <mauke> where x :: String and y :: ByteString
08:45:26 <EvilMachine> kamatsu: i really want to do it the proper haskell way.
08:45:32 <mauke> this is purely for programming convenience
08:45:43 <kamatsu> EvilMachine: Well, if the problem is, implement the function as you described
08:45:49 <kamatsu> EvilMachine: Then you have to use a type class
08:46:06 <kamatsu> EvilMachine: but if you have a broader problem, where you need such a function, it should be possible to refactor it so you don't need it
08:46:31 <mauke> btw, did you see my 'evil' function?
08:46:40 <EvilMachine> mauke, kamatsu: i can implement a type class, or use PrettyPrint. but it’s not the Haskell way. right?
08:46:47 <mauke> no
08:46:51 <kamatsu> EvilMachine: haskell way to do what?
08:46:57 <kamatsu> What exactly do you want to achieve here?
08:47:13 <EvilMachine> kamatsu: lool. what we just bashed out heads in over for the last 20 minutes. ;)
08:47:13 <BenceF> EvilMachine: not haskell causes can demand non haskell ways
08:47:20 <mauke> I don't know what the "haskell way" is, you'll have to talk to kamatsu about that
08:47:20 <BenceF> we wont get angry
08:47:26 <Twey> EvilMachine: The Haskell way is to use printf or PrettyPrint.
08:47:30 <mauke> I'd make my own typeclass
08:47:35 <EvilMachine> mauke: yes, i saw it. :)
08:47:39 <kamatsu> Just to solve this problem
08:47:42 <kamatsu> make your own typeclass
08:47:43 <Twey> Really, we should probably use those for many places where we currently use Show
08:47:45 <kamatsu> what I'm saying is
08:47:52 <kamatsu> are you writing a large library or program, and have encountered this?
08:47:59 <kamatsu> or are you just wondering how to write such a function?
08:48:05 <Twey> Why would it be necessary to write one's own typeclass when such a typeclass already exists?
08:48:14 <mauke> Twey: where does it exist?
08:48:30 <kamatsu> mauke: pretty
08:48:52 <mauke> might be overkill
08:48:57 <EvilMachine> mauke: you know, a huge ideal for me, is to have to write as little new code as possible. writing a new type class really is the opposite. so i’d go with Pretty
08:49:00 <Twey> mauke: http://hackage.haskell.org/packages/archive/wl-pprint/1.0/doc/html/Text-PrettyPrint-Leijen.html
08:49:33 <Twey> It's not overkill when you're suggesting reïmplementing it anyway
08:49:39 <kamatsu> EvilMachine: Can you answer the question: Are you just wondering how to write such a function, or have you encountered this problem in a real project?
08:49:42 <gwern> http://docs.google.com/present/view?id=dhmnf9cf_26cgst4zg8 why is scala syntax so ugleeeee?
08:49:47 <Twey> Although I still think that printf is more than sufficient in this case
08:49:50 <kamatsu> gwern: i know it's awful looking
08:49:51 <EvilMachine> kamatsu: it’s supposed to be a core element of a core library of the core of a new UI and data management paradigm.
08:50:00 <kamatsu> EvilMachine: what?
08:50:25 <kamatsu> EvilMachine: Have you written large parts of your program already? If you're starting your design here, you haven't designed it with types in mind.
08:50:39 <kamatsu> EvilMachine: You need to do that, for haskell
08:51:15 <gwern> '((s:String) => s.length)("Foo") ' zomgwtf
08:51:21 <EvilMachine> kamatsu: i’m obviously on the first protoype. since everything else depends on the design of that part. (specifically the interface of course)
08:51:23 <gwern> type signatures?
08:51:45 <kamatsu> EvilMachine: Okay, so, I suggest throwing out your design, and coming up with one that works with the type system.
08:51:57 <kamatsu> EvilMachine: It'll probably be better in the long run
08:52:03 <gwern> 'def id[A](x:A):A = x' <-- and people complain haskell is read-only
08:52:09 <kamatsu> EvilMachine: Why, do tell, do you need such a type class?
08:52:16 <EvilMachine> kamatsu: i have a hard time thinking about type signatures. they just say nothing to me.
08:52:41 <EvilMachine> kamatsu: i mean just haskell ones. i’m a pretty good coder, i think.
08:52:52 <kamatsu> EvilMachine: Haskell type sigs are the easiest part of haskell to read =/
08:53:21 <EvilMachine> kamatsu: lol. possibly
08:53:24 <Twey> Sometimes they confuse me when they're very general
08:53:31 <kamatsu> EvilMachine: So, is this to, say, label a button?
08:53:41 <gwern> kamatsu: true, but only once I forced myself to mentally see foo:: a -> b -> c as foo :: a, b -> c
08:53:42 <kamatsu> EvilMachine: If you want to label a button, that's simply a string, forget numbers
08:53:59 <kamatsu> gwern: nah, I just imagine it as a -> (b -> c)
08:54:03 <EvilMachine> kamatsu: yes. it’s a label (there are no buttons in my UI paradigm)
08:54:06 <kamatsu> gwern: which is what it is
08:54:10 <gwern> kamatsu: what
08:54:26 <EvilMachine> kamatsu: but can you imagine me going “WTF?” when i noticed that the type system itself is basically a language with its own type system (the “kind”s)
08:54:32 <kamatsu> gwern: function that takes a, returning a function that takes b and returns c
08:54:42 <kamatsu> EvilMachine: right, but this is an incredibly powerful thing
08:54:47 * gwern is reminded of the engineer asking his mathematician friend for help - how do you visualize an 8 dimensional space? easy, says, the mathematician, I simply visualize a n-dimensional space and then set n=8
08:54:56 <kamatsu> EvilMachine: and means haskell programs are much more reliable than pythons in the general case
08:55:18 <kamatsu> EvilMachine: If you want to label stuff, that's just String
08:55:21 <kamatsu> EvilMachine: forget numbers
08:55:30 <kamatsu> EvilMachine: if people want to put a number on a label, they can Show it themselves
08:55:42 <EvilMachine> kamatsu: yes. i do not disagree that is it powerful. :) because on the second glance it’s like seeing the matrix. ^^
08:57:18 <kamatsu> This is a classic case I see of new haskell programmers that came from dynamic languages such as python
08:57:24 <kamatsu> "omg types how do i get rid of them"
08:57:44 <pikhq> kamatsu: The answer to that is, of course, Dynamic.
08:57:44 <pikhq> :P
08:57:45 <BenceF> EvilMachine: if you were born in the middle. i just started to learn a few months ago and basic things still confuse me sometime. but when i finally get it it like an epiphyna
08:57:47 <EvilMachine> kamatsu: i chose haskell mainly, because functional programming, especially the one that you can imagine as streams of data packets between transformations , is the way i always thought about programs. even when i started with basic and pascal, writing programs on bare metal back then. :)
08:57:48 <kamatsu> pikhq: hahqa
08:58:15 <kamatsu> EvilMachine: Right, what I suggest you do is do some work involving severe type hackery
08:58:21 <kamatsu> EvilMachine: Get right into the type system
08:58:31 <EvanCarroll> 4~/win6
08:58:45 <kamatsu> EvilMachine: And then you will understand when you're doing things wrong by the type system
08:59:01 <kamatsu> EvilMachine: But yeah, for this case, just take a string, forget typeclasses
08:59:25 <EvilMachine> kamatsu: i came from pascal/delphi, then java, then python and dare i say that i was forced to use php (*oww*) and js (which is actually quite nice nowadays).
08:59:41 <Twey> 16:54:24  * gwern is reminded of the engineer asking his mathematician friend for help - how do you visualize an 8 dimensional space? easy,  says, the mathematician, I simply visualize a n-dimensional space and then set n=8
08:59:45 <EvilMachine> kamatsu: good suggestion
08:59:45 <Twey> gwern: Hahaha
08:59:49 <Sagi> kamatsu: I've lurked on the entire conversation while reading realworldhaskell at the same time. I admire your perseverance and patience.
09:00:07 <BenceF> EvilMachine: would be quite nice nowadays if not everybody were using it the old way
09:00:09 <nlogax> EvilMachine: my condolences (for php)
09:00:14 <kamatsu> Sagi: Ah, thanks!
09:00:21 <kamatsu> Sagi: good luck working on haskell fu
09:00:32 <kamatsu> EvilMachine has the room's condolences
09:00:49 <kamatsu> php recently got closures
09:00:55 <kamatsu> except you have to declare what it closes over
09:00:56 <EvilMachine> Sagi: that book is stored on my phone, and will get read in the next days. i just have to finish a h.p. lovecraft story first. i sometimes mix cthuluh and haskell up. ;)
09:00:59 <Sagi> I know the basics and some of the math behind monads / arrows. Now I want to build something useful :)
09:00:59 <kamatsu> because php is too stupid to figure it out
09:01:17 <pikhq> kamatsu: So. Much like the C closures I implemented a while back.
09:01:34 <kamatsu> pikhq: yeah, but why does it have to be like that in PHP?
09:01:46 <kamatsu> pikhq: surely the PHP developers are smart enough to.. oh wait.. right..
09:01:47 <pikhq> Except you also have to allocate the memory for what it closes over...
09:01:53 <pikhq> kamatsu: PHP devs.
09:01:54 <EvilMachine> BenceF: you’d be surprised how much you can write JS just likef you’d do it in haskell, nowadays.
09:01:55 * BenceF has realwolrdhaskell in human skin case
09:02:19 <pikhq> It's understandable in C. Not so much in PHP.
09:02:38 <kamatsu> EvilMachine: The main difference with JS and Haskell is, JS is what I call a retardedly typed language
09:02:48 <kamatsu> It is only a smidgeon above PHP in terms of retarded types
09:02:58 <EvilMachine> nlogax: thank you. but i was still quite thriving. i used something like AJAX (but with the object tag) years before the API or the word were invented. ;)
09:03:07 <pikhq> kamatsu: Not quite so bad with Coffeescript...
09:03:26 <pikhq> (which at least gets rid of the absolutely freaking *retarded* == behavior)
09:03:29 <kamatsu> pikhq: Hey, did I see you in the discussions about that?
09:03:32 <BenceF> EvilMachine: yeah i know but if you look around on the tubes most of the js is like if it were from an obfuscated C contest
09:03:39 <pikhq> kamatsu: Maybe.
09:03:45 <kamatsu> pikhq: I offered alot of help to jashkenas developing the significant whitespace lexer
09:03:53 <nlogax> EvilMachine: i worked with it for a year and a half, felt like i was getting dumber every day :(
09:04:07 <pikhq> kamatsu: Hmm.
09:04:19 <kamatsu> pikhq: what's your github username?
09:04:40 <mbln> mauke: It says ghci-6.10.4 comes with haskeline, but my key-bindings seem to be ignored. Also cabal says haskeline is not installed.
09:04:58 <pikhq> kamatsu: Don't have one...
09:05:04 <kamatsu> pikhq: ah, wasn't you then
09:05:05 <zachk> maybe try the haskell platform mbln
09:05:06 <EvilMachine> kamatsu: seriously, i could tell you stories about PHP… ^^ we had Zeev in the house back then. but then i’d continue right into Internet Explorer. which actually really gave me nightmares for at least a year. i even lost my job because i had a fight about me not wanting to do it in IE anymore.
09:05:09 <pikhq> I've only futzed with Coffeescript and talked about it on IRC.
09:05:12 <Cale> Who was it that was looking for examples of cereal/binary the other day?
09:05:21 <kamatsu> pikhq: ah, ok
09:05:31 <mbln> zachk: I have the platform, but using GHC from the Ubuntu repositories. Is that bad?
09:05:32 <kamatsu> pikhq: there was another haskeller involved, thought it mighta been you
09:05:43 <zachk> from what i remember yes thats bad
09:06:07 <zachk> ghc from the ubuntu repositories is usually quite outdated
09:06:15 <zachk> or it was last time i tried ubuntu
09:06:24 <kamatsu> yeah, it still is afaik
09:06:55 <BenceF> yeah its pretty fun that JS is basically portable to everything except to IE which in a just world wouldnt even be used by anyone
09:06:59 <mbln> ok thanks guys
09:07:03 <EvilMachine> i love that there is such a nice Haskell overlay in gentoo.
09:07:13 <kamatsu> EvilMachine: you use gentoo, man
09:07:17 <kamatsu> EvilMachine: i don't have the time
09:07:25 <Cale> On Ubuntu, I install the generic linux binary of GHC, and then get cabal-install.
09:07:28 <Sagi> ubuntu karmic currently has ghc-6.10.4
09:07:35 <kamatsu> ah, that's fine
09:07:51 <kamatsu> 6.10.4 is the latest in the platform
09:07:54 <Cale> gentoo is an even bigger waste of time than compiling your own GHC, which itself is a tremendous waste of time if you're not hacking on it
09:08:18 <Sagi> but that's 9.10, which is probably not what people are running production.
09:08:26 <EvilMachine> BenceF: at least JS has a proper interpreter. PHP’s interpreter and IE’s Trident engine are very close in terms of quality. :)
09:08:31 <Sagi> as it is only 3 months old :)
09:08:33 <Cale> But I don't trust Ubuntu to get anything right with respect to GHC.
09:08:49 <kamatsu> EvilMachine: Haskell has no interpreter
09:08:53 <kamatsu> EvilMachine: except hugs and ghci
09:09:01 <taruti> Arch is quite nice with respect to GHC.
09:09:01 <Cale> kamatsu: whaaaat, heh.
09:09:23 <Sagi> so why doesn't someone new step up as maintainer?
09:09:30 <EvilMachine> kamatsu: lool. yes, i agree about the time. it’s ok when you use it on the server, with the hardenend profile. but a GUI in the unstable profile… you need two days just to do the weekly update. ;)
09:09:47 <EvilMachine> kamatsu: i know.
09:10:04 <kamatsu> EvilMachine: I know, i was being evangelical
09:10:14 <kamatsu> EvilMachine: As in, haskell is awesome, haskell needs to interpreter
09:10:17 <kamatsu> *needs no
09:10:25 <kamatsu> but then I realised what a stupid statement i was making
09:10:31 <pikhq> Cale: Gentoo's not really a waste of time. Maybe *CPU* time, but it's not like you need to actually *wait* for it to finish compiling.
09:10:38 <taruti> interpreters are nice
09:10:47 <kamatsu> pikhq: on a laptop, i'd rather not have my battery melt
09:10:51 <EvilMachine> kamatsu: by the way: does haskell have a way to generate bytecode and then run that one on something like a JVM for haskell?
09:10:55 <taruti> electricity is not free
09:11:00 <EvilMachine> kamatsu: i know that Ocaml does
09:11:19 <pikhq> kamatsu: On a laptop, I'd either only build when plugged in or use a binary distro.
09:11:22 <Cale> pikhq: Well, no, but you do need to wait for things to compile before you can use the packages you wanted to install.
09:11:27 <taruti> EvilMachine: yes. nhc for example.
09:11:34 <pikhq> Cale: Eh.
09:11:37 <kamatsu> EvilMachine: JVM does not have the required goodies to be easily receptive to Haskell, but it has been done
09:11:38 <EvilMachine> kamatsu: but haskell IS awesome. maybe too awsome to be practical in the real world, but who cares. ;)
09:11:52 <kamatsu> ah, I disagree, I think haskell is very practical in the real world
09:11:59 <kamatsu> most of the software i use is written in it
09:12:11 <Cale> pikhq: Which means that instead of getting on with what you were doing, you probably just have to leave your machine to compile and go do something else.
09:12:50 <kamatsu> EvilMachine: But yes, it has been built for the JVM and similar, but it's rare that such things are useful
09:13:05 <kamatsu> EvilMachine: and the JVM is really quite hostile to functional programming =(
09:13:26 <pikhq> Cale: Doesn't really come up all that often.
09:13:34 <Philonous> Are there no precompiled packages for Gentoo?
09:13:35 <EvilMachine> pikhq, Cale: just so you know, haskell wanted to update 98 packages this weekend on the weekly update. 4 of them failed, and i had to manually patch the ebuild! yes, i’d never use it again, on the desktop. :)
09:13:47 <pikhq> Philonous: They exist.
09:13:53 <pikhq> EvilMachine: Abuh?
09:13:55 <endojelly>     Could not find module `Control.Monad.Trans':
09:13:55 <endojelly>       it was found in multiple packages: transformers-0.1.4.0 mtl-1.1.0.2
09:13:57 <kamatsu> EvilMachine: ah, it might have been trying to update you to 6.12
09:13:57 <endojelly> that's new.
09:14:10 <pikhq> EvilMachine: Entire thing worked just fine for me.
09:14:11 <Philonous> pikhq: But they are cumbersome to use?
09:14:21 <EvilMachine> pikhq, Cale: oh, and it all ALL of my 2GB ram and slowed the system to a crawl for moth of the hours it took to update.
09:14:25 <pikhq> Philonous: No, they're just not the norm.
09:14:28 <EvilMachine> moth=most
09:14:40 <pikhq> It's only stuff like Firefox and OpenOffice that have official binary packages.
09:14:49 <Eduard_Munteanu> EvilMachine, you should nice emerge
09:14:53 <pikhq> EvilMachine: Dear God, what did you *do*?
09:15:05 <Sagi> and use paludis instead of emerge
09:15:20 <Sagi> we're in the holywar section anyway, aren't we :)
09:15:22 * Eduard_Munteanu nods to Sagi
09:15:29 <kamatsu> imo, Arch Linux gets the best balance between configurability and convenience
09:15:54 <Eduard_Munteanu> pikhq, um, GHC has binaries too on Gentoo.
09:15:58 <EvilMachine> pikhq: the worst offenders are NetBeans (40 minutes dual cores at 90% and 1.5 gb ram), OpenOffice, and GHC (up to 8 GB of ram, hours of compilation because of swapping)
09:16:03 <Eduard_Munteanu> But it's not a separate thing, it's a USE flag.
09:16:18 <pikhq> EvilMachine: ... GHC takes hours?
09:16:23 <kamatsu> EvilMachine: Compiling haskell does use alot of RAM
09:16:23 <endojelly> so, actually, why is it that compiling GHC is so resource intensive?
09:16:24 <pikhq> News to me.
09:16:28 <endojelly> is there one particular culprit?
09:16:33 <endojelly> or is it just overally complex?
09:16:35 <pikhq> OpenOffice is just plain horrid.
09:16:41 <kamatsu> EvilMachine: But it's nothing compared to MLton
09:16:52 <pikhq> Like, "I'd use binaries if they existed for my architecture" horrid.
09:16:52 <kamatsu> EvilMachine: Compiling that used huge amounts of ram and took ages too
09:17:05 <BenceF> i use arch. nice binary repo.
09:17:09 <kamatsu> yeah
09:17:12 <EvilMachine> pikhq: as i said: it’s really the swapping. i watched it and it said “heap: 8GB” when it compiled some files.
09:17:14 <kamatsu> arch ftw
09:17:22 <pikhq> endojelly: GHC is just very complex.
09:17:26 <pikhq> EvilMachine: 4GB RAM here.
09:17:29 <Eduard_Munteanu> pikhq, um, it's reasonable to compile your own OpenOffice on Gentoo.
09:17:32 <kamatsu> it's probably ghc optimizing ghc
09:17:42 <kamatsu> the optimizations ghc does are not exactly light on memory
09:17:59 <Eduard_Munteanu> pikhq, considering your hardware, and if it's something dual core, it's probably okay.
09:18:08 <Ke> I compile ghc from source and never noticed swapping
09:18:11 <pikhq> Eduard_Munteanu: Uses tons of memory and disk space. Quite annoying.
09:18:16 <Cale> endojelly: It's just really really big, and it compiles itself multiple times to reach something close to a fixed point.
09:18:35 <Eduard_Munteanu> Cale, heh
09:18:40 <endojelly> Cale, something close? which means it doesn't reach the fixed point?
09:18:42 <pikhq> I only don't use binaries because of a notable lack of AMD64 binaries for that.
09:18:46 <EvilMachine> yes, compared to GHC or  NetBeans, OpenOffice is nice. oh, kde is also huge. but firefox is fast, because it’s all in xulrunner
09:19:01 <damd> is kde xulrunner? :|
09:19:08 <kamatsu> damd: NO
09:19:09 <pikhq> damd: ... No.
09:19:10 <kamatsu> *no
09:19:21 <pikhq> KDE is large, but legitimately so.
09:19:23 <Cale> endojelly: Well, I don't know. I'm not sure that I'd expect it to always find a fixed point.
09:19:52 <Paczesiowa> xulrunner fast? let's turn everything into slow interpreted javascript?
09:20:06 <Eduard_Munteanu> Besides, it sometimes happens you run into problem because of unreasonable USE flags, or pushing the limits. Like -O3
09:20:10 <BenceF> and KDE is modular, so you dont have to compile everything. however i still wouldnt wanna compile kde :d
09:20:12 <EvilMachine> Ke: try -j${YourCoresPlusOne} for make. then you’ll have fun with swapping.;)
09:20:17 <Philonous> Cale: Optimizing code shouldn't change it's semantics, right? So stage 1 and stage 2 should be semantically equivalent, since they are generated from the same code. Am I missing something?
09:20:51 <EvilMachine> damd no, firefox is
09:20:53 <Eduard_Munteanu> EvilMachine, it's possible you've got something shady going on inthere. Like overcommiting or messed swapinness
09:21:14 <BenceF> yes, but if the code is written well -O3 can be a huge boost in the binary
09:21:27 <pikhq> BenceF: -O3 can also break.
09:21:29 <Eduard_Munteanu> Philonous, yes. First compiler is probably slow, but generates good code. The second should be fast in both respects.
09:21:49 <Eduard_Munteanu> The zeroth might be older, thus slow and not uptodate.
09:21:52 <EvilMachine> Paczesiowa: no. firefox is fast to *compile*. because xulrunner contains all the code. so xulrunner is taking long. that’s what i said. you missed the context. :)
09:21:55 <Eduard_Munteanu> (the one you bootstrap from)
09:21:56 <pikhq> (granted, it only breaks certain bits of undefined behavior, but stilll.)
09:22:20 <Philonous> Well, my point is that stage 1 and stage 2 (and any subsequent stage) should generate exactly the same executable. I thought that's why we build stage 3, to test whether this is the case
09:22:29 <EvilMachine> Eduard_Munteanu: -O3 is considered evil. ^^ i use -s.
09:22:31 <Eduard_Munteanu> BenceF, it's really a corner case last time I checked, most apps weren't worth wasting time on -O3
09:22:39 <Eduard_Munteanu> EvilMachine, hehe.
09:23:40 <BenceF> Eduard_Munteanu: if you use huge amounts of inline functions (const readouts for example) then its worth it
09:23:57 <BenceF> otherwise stay away
09:24:14 <Eduard_Munteanu> I only do CFLAGS="-O2 -march=native -pipe"
09:24:20 <Paczesiowa> EvilMachine: oh!
09:24:36 <Eduard_Munteanu> I sometimes add -msse stuff if -march=native misses them.
09:24:58 <EvilMachine> but really, most of the opimizations in gentoo, are not worth the effort. like prelink. it means your apps eat so much ram that it swaps (e.g. java apps then eat up to 1.5G ram). if you start your main apps in autostart anyway, there is no big point in prelinking
09:25:09 <Ke> EvilMachine: I have -j4
09:25:19 <Eduard_Munteanu> BenceF, GCC is pretty well known for messing -O3 completely, due to aggressive inlining which can make code slower.
09:25:36 <Eduard_Munteanu> EvilMachine, prelink is bad.
09:25:43 <Eduard_Munteanu> Unless you do it for a couple of apps.
09:26:12 <Ke> -march is mostly useless too
09:26:15 <Eduard_Munteanu> I'd do it for Firefox/OO, but heck, it starts fast enough I don't care
09:26:16 <EvilMachine> Ke: do you have 3 cores? (as far as i know -j4 would mean 3 compilations at the same time, and one process for make itself). no?
09:26:54 <Eduard_Munteanu> Ke, um, depends on your heuristic of "usefulness".
09:26:58 <Ke> EvilMachine: I think it's 4, the +1 in for IO idle
09:27:02 <pikhq> Ke: It's *exceptionally* useful for i686, actually.
09:27:11 <Ke> Eduard_Munteanu: any measurable performance gains
09:27:13 <kmc> i've run make with -j (2 x # cores)
09:27:15 <endojelly> you should try chrome. it's so much faster than firefox that you'll have a hard time going back to firefox.
09:27:18 <kmc> it doesn't make much difference
09:27:43 <EvilMachine> Eduard_Munteanu: well, i tried prelink for half a year. startup really is accelerated. but it just eats too much ram. even when prelink intelligenly maps common libs so that they only take up space once.
09:27:46 <BenceF> yeah i switched to chrome too
09:27:47 <pikhq> Without it, GCC will implement floats using x87.
09:27:49 <pikhq> Yes, really.
09:27:51 <Eduard_Munteanu> Ke, -march is quite measurable. Might not be the case for some apps, but you generally want it and doesn't make GCC slower.
09:27:51 <Philonous> endojelly: is there a vimperator equivalent for chrom{e|ium]
09:28:04 <EvilMachine> keseldude: why is march useless?
09:28:05 <Eduard_Munteanu> Like -ffast-math is good for some apps too.
09:28:09 <Ke> Eduard_Munteanu: any example code for that
09:28:14 <Ke> ?
09:28:21 <pikhq> Ke: Anything with floats.
09:28:25 <pikhq> *ANYTHING*.
09:28:29 <pikhq> SSE > x87.
09:28:30 <Eduard_Munteanu> Ke, well, if you do anything that can be translated to SIMD stuff.
09:28:49 <BenceF> Philonous: the only thing i miss :D
09:28:56 <Ke> Eduard_Munteanu: gcc doesn't produce simd code by default
09:29:08 <Sagi> have you tried 3.6?
09:29:09 <Ke> Eduard_Munteanu: SSEn yes, simd no
09:29:20 <mreh> can anyone say how getOpt works? does it only sniff out the "-s" and "--long" in the argument strings?
09:29:31 <mreh> System.Console.getOpt
09:29:36 <Sagi> it's been released 3 days ago and it feels a bit faster again.
09:29:38 <pikhq> Ke: Without -march (or the appropriate -msse options), it won't use SSE.
09:29:47 <Eduard_Munteanu> Ke, yeah, I mean anything which operates on vect/much data
09:29:47 <EvilMachine> endojelly: unfortunately, there are a ton of extensions that prevent me from going to chrome. also statements from Google CEOs about there being no privacy, prevent me from trusting Google apps.
09:29:57 <pikhq> -march also makes GCC output code that works nicer with the CPU's pipeliner (not a huge deal)
09:30:06 <kamatsu> EvilMachine: I work for Google. Trust me, we take privacy very seriously.
09:30:12 <kmc> hahaha
09:30:23 <kamatsu> yeah, i get the irony
09:30:28 <Sagi> "now let me write down your name" ;)
09:30:38 <Eduard_Munteanu> Secondly, -march provides cheap 1% improvements.
09:30:49 <kmc> trust the computer. the computer is your friend.
09:30:56 <kamatsu> but seriously, all eschmidt was saying was that Google are required by law to hand over information if served a subpoena
09:31:05 <Ke> pikhq, EvilMachine I was unable to benchmark any diff for MD, but offtopic
09:31:10 <kamatsu> so, if you don't want that information to potentially go to the government, then you shouldn't do it
09:31:15 <kamatsu> but it sounds bad, the way he said it
09:31:43 <EvilMachine> pikhq: i recently saw someone explain modern CPUs and how to optimize them. pipelining is a HUGE deal. and fitting everything in the cache.
09:31:51 <BenceF> whats a subpoena?:
09:32:03 <EvilMachine> kamatsu: :)
09:32:07 <pikhq> Ke: What architecture?
09:33:07 <Eduard_Munteanu> It depends on who makes the big deal.
09:33:11 <kamatsu> EvilMachine: Also, if you really don't trust the benign and loving company that is Google, you can use Chromium, and compile it yourself
09:33:14 <Eduard_Munteanu> If you ask a normal user, it probably isn't much.
09:33:16 <Ke> core 2, x86_64
09:33:20 <Philonous> BenceF: It's the legal equivalent of a flail. You hit someone with it to make him comply.
09:33:21 <kamatsu> EvilMachine: and inspect the source for privacy violations
09:33:27 <pikhq> Then -march won't make a very noticable difference.
09:33:29 <Eduard_Munteanu> If you ask a kernel developer messing with hot paths in the SLAB allocator, it matters a lot.
09:33:34 <pikhq> Improves the code, but not massively.
09:33:53 <pikhq> (SSE can be assumed)
09:34:05 <EvilMachine> here, that’s the video plus self-updating slides, about how to optimize modern cpus. very interesting stuff: http://www.infoq.com/presentations/click-crash-course-modern-hardware
09:34:07 <Eduard_Munteanu> Ke, do you use a GCC with explicit core2 -march support?
09:34:38 <BenceF> kamatsu: can you recommend a good source on how to write extensions for chrome?
09:34:56 <pikhq> Grr. -ggdb got removed from CFLAGS.
09:34:58 <kamatsu> BenceF: I'm on the Wave team, not the Chrome team, so i'd just be googling it ;)
09:35:06 <EvilMachine> kamatsu: I would not say i prefer any browser. what i prefet are my >70 carefully collected extensions. :)
09:35:12 <EvilMachine> t=r
09:35:12 <pikhq> Better fix that before I want to debug something where it matters.
09:35:19 <Eduard_Munteanu> For example, I would not even dare to incur *any* overhead when I wrote some slab debugging patches and the feature was disabled.
09:35:19 <kamatsu> BenceF: But it's fairly simple. At their heart, chrome extensions are basically just user scripts
09:35:41 <BenceF> kamatsu: ok then ill just look some up
09:35:48 <Eduard_Munteanu> Even when enabled, but disabled at runtime, it should be very very unintrusive.
09:35:55 <kamatsu> BenceF: yeah, plenty of good examples
09:36:01 <kamatsu> BenceF: and there are API docs
09:36:17 <Eduard_Munteanu> So yes, in a sense I don't get Haskellers/Javaers/etc. who say "it doesn't matter".
09:36:24 <EvilMachine> kamatsu: ah, wave. is it still closed for the pubilc?
09:36:42 <kamatsu> EvilMachine: No, it's an invitation-only preview
09:36:47 <kamatsu> EvilMachine: I can invite you if you like
09:37:06 <kamatsu> EvilMachine: but it is still in preview, expect poor performance, bugs and missing features
09:37:08 <EvilMachine> kamatsu: oh, that would be cool!
09:37:21 <EvilMachine> kamatsu: don’t worry. i won’t badmouth it. :)
09:37:23 <kamatsu> I need a gmail address, and it takes a few days to go through
09:37:37 <kamatsu> The offer applies to anyone else as well
09:37:42 <kamatsu> just pm me your email address
09:37:45 <Eduard_Munteanu> On x86 kernel devs have devised self-modifying code for tracepoints, so there's no branching and ~nil overhead.
09:37:58 <kpreid> kamatsu: huh? google wave invites AFAIK work for any email address
09:38:31 <kamatsu> kpreid: you need a google account though.
09:38:39 <BenceF> kamatsu: i only use it to play sudoku with my friend :) but serves that purpos well
09:38:40 <kpreid> true, but that doesn't necessitate using gmail.
09:38:53 <kamatsu> kpreid: ah, i guess
09:39:03 <kpreid> I have a google account which has nothing at all to do with gmail
09:39:30 <kamatsu> kpreid: right right, well, you still get a gmail address with wave
09:39:37 <kpreid> well, actually, google webmaster tools thinks I have a gmail account ... with the username I created for google wave. I don't know whether that's a bug or implicit creation
09:39:53 <Ke> Eduard_Munteanu: nowadays yes, I would bet I was very aware of gcc cpu support earlier too, but can't guarantee
09:39:55 <RayNbow> hmm... a new book titled "Real-World Functional Programming"...
09:40:04 <RayNbow> ...and it uses F# and C#
09:40:43 <EvilMachine> kpreid: a goole account is global.you can use any tool with it.at least as far as i know.
09:41:11 <Ke> RayNbow: well C# is at least very real world
09:41:19 <EvilMachine> RayNbow: is that like the book “Real-World Haskell”?
09:41:24 <Eduard_Munteanu> Are you guys aware of any VMs besides .NET and Java?
09:41:31 <kamatsu> EvilMachine: Parrot
09:41:33 <kamatsu> oops
09:41:38 <kamatsu> that was for Eduard_Munteanu
09:41:39 <Eduard_Munteanu> I got it
09:41:42 <Eduard_Munteanu> :)
09:41:59 <Ke> Eduard_Munteanu: llvm for unladen swallow
09:42:00 <EvilMachine> Eduard_Munteanu: Ocaml has a kind of bytecode with VM, as far as I know.
09:42:01 <pikhq> Eduard_Munteanu: LLVM.
09:42:04 <Eduard_Munteanu> Will have a look. I'm interested in VMs not tied to a particular language, I think that would be great for Haskell.
09:42:09 <pikhq> Erlang.
09:42:10 <al-maisan> hello, I am using "ghc -XOverloadedStrings" along with Data.ByteString.Char8 which takes care of "normal" strings but get compile errors for soemthing like FilePath which is basically an alias for a string.
09:42:13 <BenceF> Eduard_Munteanu: there are smalltalk vms
09:42:18 <Eduard_Munteanu> pikhq, no, something like Java, but not so bloated with Java lingo.
09:42:32 <Eduard_Munteanu> So something language-independent, more like .NET
09:42:37 <endojelly> Philonous, EvilMachine, sorry, was away. yeah, there are tons of extensions missing from chrome, yet. I for one would really want a delicious extension for bookmark integration, and a passwordmaker extensions. that's why I haven't abandoned Firefox yet. but still I find myself opening up Chrome instead of Firefox most of the time. it's so... snappy...
09:42:43 <al-maisan> Any recommendation on how to make ghc understand that a FilePath is a string as well?
09:42:44 <RayNbow> EvilMachine: only the title shows resemblance. The two books are published by different publishers
09:42:46 <Ke> Eduard_Munteanu: that's llvm for ouy
09:42:54 <pikhq> Eduard_Munteanu: LLVM.
09:43:14 <Eduard_Munteanu> Ke, pikhq, I don't think LLVM is really suitable for JIT.
09:43:14 <pikhq> LLVM doesn't define a machine-independent C FFI, but otherwise fits the bill.
09:43:16 <Ke> Eduard_Munteanu: also mono had some other vm, but probably not as good as llvm
09:43:22 <pikhq> Eduard_Munteanu: LLVM JITs just fine.
09:43:23 <Eduard_Munteanu> and for portability.
09:43:35 <pikhq> And is portable, aside from linking to C.
09:43:47 <Eduard_Munteanu> Ke, pikhq, hm, could you throw a language/compiler on top and expect it to perform like Java?
09:43:55 <pikhq> Yes.
09:44:00 <Eduard_Munteanu> Interesting.
09:44:14 <EvilMachine> endojelly: well, the project i talked about earlier, would in fact make every program have the ability to use extensions written in any language with a compatible api. which would be pretty much anything, including shell commands.
09:44:20 <kmc> @hoogle FilePath
09:44:20 <lambdabot> module System.FilePath
09:44:20 <lambdabot> Prelude type FilePath = String
09:44:20 <lambdabot> System.IO type FilePath = String
09:44:25 <kmc> al-maisan, it already is
09:44:29 <kmc> totally interchangeable
09:44:30 <pikhq> It's been used as a replacement for a JVM on architectures where the JVM hasn't been ported, but LLVM has.
09:44:31 <Eduard_Munteanu> I know they use it for DX->OpenGL and that sort of stuff, but I'm not sure if something more CISC-ish would be better.
09:44:36 <pikhq> (there's a JVM->LLVM compiler)
09:44:38 <EvilMachine> endojelly: yes, that would require very tight security. :)
09:44:53 <Eduard_Munteanu> Thanks.
09:44:57 <EvilMachine> endojelly: and you could even use chrome as a firefox extension. ^^
09:45:35 <kmc> al-maisan, i think your error is elsewhere, GHC should see no difference between a String and a FilePath especially in terms of which instances they have
09:46:17 <kmc> however, BS.Char8 is not interchangeable with FilePath -- you'd need a conversion there
09:46:23 <endojelly> EvilMachine, heh, interesting
09:46:40 <pikhq> (OpenJDK's "Shark" VM just compiles to LLVM and JITs)
09:46:44 <endojelly> EvilMachine, how exactly would you achieve that?
09:46:56 <nh2> when I do "f [] x = x" and call "f [] (2+3)", is (2+3) evaluated before the = or is the result of f (2+3) and this is evaluated later?
09:46:59 <Eduard_Munteanu> I wonder if there's any Haskell equivalent to Java. On top of LLVM or anything else.
09:47:14 <endojelly> EvilMachine, wouldn't there be problems related to performance and a smooth interface to whatever you want to extend?
09:47:15 <pikhq> Eduard_Munteanu: In what sense?
09:47:26 <kmc> nh2, the latter
09:47:31 <Paczesiowa> nh2: possibly never
09:47:35 <Eduard_Munteanu> pikhq, you get a binary that you can run on anything that has a JIT/VM installed :)
09:47:42 <nh2> ok, then it works as expected
09:47:45 <kpreid> nh2: when or whether f's argument 2+3 is evaluated is entirely determined by the definition of f
09:47:45 <Paczesiowa> nh2: that depends on the caller of f
09:47:58 <EvilMachine> endojelly: well, basically, imagine the same stuff bash can do, in terms of piping things between apps, but on a GUI. the unix paradigm taken to the GUI. because unfortunately, all graphical linux apps seem to be completely monolithic.
09:47:58 <kmc> it's evaluated whenever someone does pattern-matching on the expression
09:48:03 <kmc> e.g. to print it
09:48:07 <al-maisan> kmc: hmm .. oK .. will look some more then .. thanks!
09:48:08 <pikhq> Eduard_Munteanu: Well, there was that port of GHC to LLVM.
09:48:21 <kmc> binary portability is overrated imo
09:48:28 <kmc> but there are other good reasons to target a platform independent VM
09:48:50 <Eduard_Munteanu> pikhq, um, is it ready? I mean, do you get an IR you can simply run on anything?
09:48:54 <endojelly> hm. ironically, it seems that the most trivial function I can imagine is not part of the standard library!
09:48:58 <endojelly> it has type a -> ()
09:49:09 <pikhq> Eduard_Munteanu: ... LLVM is very, very, very ready.
09:49:10 <kmc> is not () -> () more trivial? ;)
09:49:21 <endojelly> kmc, I was thinking exactly the same right after pressing enter %)
09:49:21 <kmc> LLVM backend for GHC, though?
09:49:25 <Eduard_Munteanu> kmc, for the most part I agree. The tough issue isn't binary compatibility, but environment compat, which neither Java nor .NET do excellently.
09:49:25 <pikhq> endojelly: \_->()
09:49:27 <EvilMachine> endojelly: but of course they would not pipe strings between each other. they would pipe packets of graph data structures. (there would be a wrapper for the common old apps, like a string wrapper for cli apps, etc.)
09:49:35 <Eduard_Munteanu> pikhq, well, LLVM is just part of the solution.
09:49:40 <kmc> Eduard_Munteanu, yeah.  and LLVM has no opinion on that issue
09:49:48 <nh2> can one in general say that haskell never evaluates anything unless the result is needed right at the moment or are therer exceptions?
09:49:53 <kmc> you'd have to layer that on top
09:49:55 <pikhq> Eduard_Munteanu: Dunno where you can download the GHC patches to check, unfortunately.
09:50:04 <Eduard_Munteanu> pikhq, oh, will have a look.
09:50:08 <kmc> nh2, that's broadly correct
09:50:14 <kmc> you can introduce an "artificial" need
09:50:21 <endojelly> pikhq, yeah, as I said, it's most trivial 8) but it's not there! (probably because it's likely to never be useful at all, except for strange corner cases)
09:50:42 <Eduard_Munteanu> kmc, yeah, VMs I was talking about aren't simply IR compilers/processors.
09:50:49 <endojelly> EvilMachine, isn't that what "power shells" do?
09:51:03 <pikhq> @pl \_->()
09:51:03 <lambdabot> const ()
09:51:08 <endojelly> EvilMachine, or at least I think I remember it of being somehow related. you should look into it!
09:51:11 <pikhq> Whoo.
09:51:15 <kmc> nh2, for example, if the value of the expression seq a b is required, both a and b are evaluated, and then only the value of b is returned
09:51:16 <Berengal> nh2: If GHC can see that a value is going to be evaluated anyway, it might decide that it's best to evaluate it first rather than later, but that is simply a compiler optimization. The semantics are the same
09:51:21 <kmc> this is a special property of seq
09:51:22 <EvilMachine> endojelly: if they allow you to use the brush of photoshop in your OOo document, then yes. :D
09:51:40 <CalJohn> imo, binary portability is a make-or-break feature for a somewhat large niche
09:51:43 <kmc> nh2, which property is useful for optimizations that the compiler can't figure out on its own
09:51:47 <CalJohn> no one else really cares
09:51:57 <kmc> however, we try to avoid caring about evaluation order
09:52:05 <EvilMachine> ok, gotta go. GF just came home. :) thank you all again! :)
09:52:07 <kmc> and especially, that's why side effects are not modeled by function application and evaluation
09:52:23 <endojelly> EvilMachine, how would *that* particular example work? 8) or would OOo actually have to explicitly support photoshop brushes?
09:52:24 <kmc> CalJohn, which niche?
09:52:56 <Eduard_Munteanu> I think web apps mostly.
09:53:07 <Eduard_Munteanu> Other than that, I don't see it as extremely important.
09:53:08 <kmc> the client-side part?
09:53:14 <Eduard_Munteanu> kmc, yes.
09:53:24 <CalJohn> no i think it's important for server side also
09:53:34 <kmc> well, the majority of client-side webapps are distributed in source form
09:53:41 <kmc> there is no standard binary IR for Javascript
09:54:08 <CalJohn> being able to stop caring about hardware arch is a really nice feature for lots of "good old fashioned" server programs
09:54:17 <Eduard_Munteanu> Which isn't really a bright idea.
09:54:34 <kmc> CalJohn, of course you shouldn't care about architecture, but do you need to still not care once the code is compiled?
09:54:34 <Eduard_Munteanu> It probably stems from web developers fear of compiling stuff.
09:54:44 <kmc> you can write portable code in most any language
09:54:48 <Eduard_Munteanu> (who also invented HTML, PHP and all that :) )
09:54:53 <CalJohn> right, but say you are using heterogenerous machines
09:54:59 <dmwit> Any web developer will tell you that hardware arch is not the only possible way to break portability.
09:54:59 <kmc> why would you be
09:55:08 <EnglishGent> Eduard_Munteanu - proof that web developers are *evil* :P
09:55:09 <EnglishGent> :)
09:55:09 <CalJohn> it's common
09:55:12 <dmwit> IE6, for example, will break your webapp unless you've already tested it there.
09:55:18 <CalJohn> lots of people mix suns and xeons and many other things
09:55:21 * Eduard_Munteanu nods to dmwit 
09:55:21 <kmc> there are established ways to build an app for multiple architectures
09:55:26 <kmc> it's not that hard a problem
09:56:01 <Eduard_Munteanu> And I don't get that HotSpot propaganda that JIT is actually good for performance or anything.
09:56:15 <Eduard_Munteanu> Just build the damn thing ahead-of-time if you want performance, and profile it.
09:56:30 <kmc> dynamic JIT can be much faster than precompiled code
09:56:36 <kmc> for dynamic languages i expect it's the only solution
09:56:51 <CalJohn> hotspot has clearly shown that jit'ing exposes optimisation opportunities
09:56:53 <kmc> Java is not so dynamic and so it might not matter
09:57:09 <kmc> but I doubt we'll see a good static compiler for Python
09:57:16 <CalJohn> i'm don't know enough to talk about how valuable they are in practice, but the hotspot jvm is much faster than the old one
09:57:24 <Eduard_Munteanu> kmc, I think that's partly bull, because they claim profiling is the reason. While profiling also slows your code. Just write something in C++/C/whatever and it won't be slower than Java.
09:57:32 <kmc> ...
09:57:37 <CalJohn> C++ normally is slower than java
09:57:50 <Loriel> Seriously?
09:57:58 <CalJohn> good garbage collection is a pretty big advantage
09:57:58 <kmc> that's a nonsense statement
09:58:02 <kmc> and also false
09:58:03 <Eduard_Munteanu> I really doubt that's a property of the language/compiler.
09:58:08 <nh2> yep
09:58:15 <nh2> even c if you want portable apps
09:58:37 <CalJohn> kmc: it's not a nonsense statement.  java does output C++, not only on a lot of benchmarks, but in real life
09:58:52 <kmc> CalJohn, which Java implementation? which C++ implementation?
09:58:53 <Eduard_Munteanu> s/output/outperform/ ?
09:58:55 <kmc> languages don't have speeds
09:58:57 <nh2> if you write a stupid prime sieve in c and in java and compile the first one with gcc -O2 -g, the java one is faster on normal machines
09:59:09 <bo0ts__> Now we move into the realm of fairy stories.
09:59:13 <mreh> is there an unsafe version of try?
09:59:38 <CalJohn> g++ and the sun jvm.  there's lots of literature on this, i would've thought it was obvious
09:59:44 <mreh> I'm reading command line arguments, I'd rather just have the prog fail than fail gracefully if the user supplied some garbled args
09:59:59 <CalJohn> there's a great paper where they add garbage collection to existing C++ programs and get a speed improvement
10:00:00 <cheater3> in haskell, every new line does not effect the previous lines, right?
10:00:02 <Eduard_Munteanu> kmc, I can say there are particular properties of either the environment or the language that can make it slower. Like mandatory GC in Haskell.
10:00:06 <mreh> can anyone hear me?
10:00:10 <kmc> mreh, i can
10:00:11 <benmachine> mreh: hi
10:00:11 <pikhq> CalJohn: Not surprising.
10:00:12 <Zao> mreh: No.
10:00:17 <Twey> mreh: Not a peep.
10:00:21 <Eduard_Munteanu> CalJohn, I seriously doubt it.
10:00:31 <Eduard_Munteanu> Unless the program was written badly.
10:00:41 <CalJohn> pikhq: right, except the evidence is important to convince people who are ignorant of modern gc methods
10:00:50 <nh2> a problem is that it is hard to find out what a JIT does at a moment
10:00:51 <kmc> :t \m -> either error id <$> try m
10:00:52 <lambdabot> Not in scope: `try'
10:00:57 <kmc> :t \m -> either error id <$> Control.Exception.try m
10:00:58 <lambdabot>     No instance for (GHC.Exception.Exception [Char])
10:00:58 <lambdabot>       arising from a use of `Control.Exception.Base.try'
10:00:58 <lambdabot>                    at <interactive>:1:26-48
10:01:09 <kmc> :t \m -> either (error . show) id <$> Control.Exception.try m
10:01:10 <lambdabot>     Ambiguous type variable `a' in the constraint:
10:01:10 <lambdabot>       `GHC.Exception.Exception a'
10:01:10 <lambdabot>         arising from a use of `Control.Exception.Base.try'
10:01:12 <mreh> @hoogle unsafe try
10:01:12 <kmc> grr
10:01:12 <lambdabot> No results found
10:01:14 <benmachine> isn't an unsafe version of try just id
10:01:15 <pikhq> CalJohn: Keep in mind that I have this tendency to use Boehm GC in C. ;)
10:01:27 <Eduard_Munteanu> Boehm is kinda slow.
10:01:30 <kmc> :t \m -> either (error . show :: SomeException -> String) id <$> Control.Exception.try m
10:01:31 <lambdabot>     Not in scope: type constructor or class `SomeException'
10:01:37 <pikhq> Makes C a bit slower, because good garbage collection in C is *hard*, but it's often worth it.
10:01:39 <kmc> mreh... you can see what i'm trying to do anyway
10:01:50 <kmc> boehm is an awful hack
10:01:58 <pikhq> kmc: Why yes, yes it is.
10:02:01 <CalJohn> Eduard_Munteanu: i'll try and find you the paper, since you think I'm lying
10:02:11 <pikhq> A useful hack, but a hack.
10:02:19 <mreh> kmc: aah, either
10:02:19 <Eduard_Munteanu> CalJohn, no, I think they messed up.
10:02:29 <mreh> I'd seen that last night, forgotten about that
10:02:31 <kmc> mreh, or you bind the result and then pattern match
10:02:38 <Eduard_Munteanu> where they in ["C++ app developers", "paper authors", ...]
10:02:43 <kmc> :t either (error . show) id
10:02:44 <lambdabot> forall a b. (Show a) => Either a b -> b
10:02:52 <CalJohn> Eduard_Munteanu: well, you haven't even seen the paper yet, so how would you know?
10:03:10 <kmc> mreh, also... "error" produces a kind of exception
10:03:13 <kmc> so this seems backwards
10:03:22 <kmc> if you want to die on exceptions, why catch them in the first place?
10:03:28 <Eduard_Munteanu> CalJohn, all I'm saying you can write C++ code that isn't improved by GC.
10:03:49 <Eduard_Munteanu> GC might in theory converge to static allocation speedwise.
10:03:51 <CalJohn> ok, i don't think you really understand what gc can do
10:03:58 <mreh> kmc: what about const . exitWith ExitFailure?
10:04:00 <Eduard_Munteanu> s/static/manual/
10:04:04 <CalJohn> garbage collectors allow you all sorts of optimisations
10:04:08 <kmc> mreh, ok
10:04:19 <Eduard_Munteanu> CalJohn, um, like?
10:04:31 <Loriel> Not refcounting?
10:04:34 <kmc> copying GC can improve locality and decrease fragmentation
10:04:38 <Eduard_Munteanu> You can't actually do anything that can't be done with manual allocation.
10:04:43 <mreh> what is exitWith? some kind of type magic?
10:04:46 <CalJohn> erm, obviously you can Eduard_Munteanu
10:04:48 <CalJohn> you get all the runtime information on memory usage, so there's lots of things
10:04:50 <kmc> mreh, hmm?
10:04:51 <mreh> has whatever type you want it to
10:04:53 <kmc> :t exitWith
10:04:54 <lambdabot> Not in scope: `exitWith'
10:04:58 <CalJohn> for example, freeing memory as soon as it's unused
10:05:00 <Eduard_Munteanu> kmc, which is why some apps implement special allocators that are still manual.
10:05:06 <kmc> mreh, that's not too magical.  error is the same way
10:05:09 <Eduard_Munteanu> Like slab allocators.
10:05:17 <kmc> mreh, it knows the evaluation will never complete
10:05:18 <mreh> kmc: true
10:05:18 <CalJohn> allocating larger blocks of memory (like G1 does)
10:05:22 <kmc> so the result type is unimportant
10:05:29 <Eduard_Munteanu> CalJohn, yes, some apps actually do that manually.
10:05:36 <kmc> GC systems often have faster alloc
10:05:45 <kmc> because they don't need to search a free list
10:05:52 <CalJohn> right, and not only faster alloc, but sooner alloc
10:05:58 <kmc> they will simply use the next piece of heap until it is filled
10:06:09 <kmc> i.e. you defer all the freeing to the GC step
10:06:10 <CalJohn> in C++, you need to know statically when it is safe to free something.  that often means you have to wait longer
10:06:21 <CalJohn> when you are looking dynamically, you can do it sooner
10:06:34 <kmc> if you want to program C++ without going mad, you will do a lot of refcounting anyway
10:06:36 <CalJohn> when you're concurrent, knowing statically can be impossible
10:06:39 <kmc> and this has an overhead too
10:06:40 <Eduard_Munteanu> CalJohn, um?
10:06:44 <PeakerWork> attempting to compile the Haskell platform killed my system.. the linkage there is really really heavy (in Linux, at least)
10:06:46 <kmc> esp. wrt multithreading and atomic ops
10:06:46 <Loriel> Going mad is not that bad
10:07:03 <Eduard_Munteanu> Any semantically correct program would know it statically when it can free.
10:07:04 <CalJohn> sorry, Eduard_Munteanu, if you want to undertand this, you need to read a book on gc techniques
10:07:13 <sinelaw> PeakerWork, you're still here though, so it's not perfect yet.
10:07:21 <PeakerWork> sinelaw: After a reboot!
10:07:22 <Eduard_Munteanu> s/know/be able to know
10:07:26 <kmc> Eduard_Munteanu, of course it knows statically, but there may be an earlier point where it might know dynamically
10:07:29 <sinelaw> PeakerWork, heh
10:07:42 <sinelaw> avoiding success since 1987
10:08:03 <Eduard_Munteanu> kmc, yes, if you assume the programmer messed up.
10:08:03 <CalJohn> Eduard_Munteanu: the point is, GC's have much more information about the program because they are runtime.  and more information means more opportunities for optimisation
10:08:13 <mreh> kmc: it seems the only way to die with some useful output is using error
10:08:20 <Eduard_Munteanu> CalJohn, and overhead.
10:08:37 <kmc> mreh, if you let your non-error exception through, it doesn't produce useful output?
10:08:42 <CalJohn> nope, there are parallel, non-pause garbage collectors
10:08:45 <kmc> also, you can of course print output and exit yourself
10:08:52 <mreh> kmc: yes, that's true
10:08:56 <Eduard_Munteanu> It's actually laughable when they try to do runtime optimization by profiling, while profiling is generally more expensive than a bad branch.
10:08:58 <CalJohn> the sun jvm 7 will have one
10:09:26 <kmc> Eduard_Munteanu, but JIT is not only about runtime optimization through profiling
10:09:28 <Eduard_Munteanu> CalJohn, yeah, I know, but it still steals CPU time from somewhere, it's not free.
10:09:41 <kmc> unless you take a seriously broad view of what "profiling" is
10:10:11 <CalJohn> erm, sorry, is pausing executation to do a slow freeing of memory faster than having another thread free memory en masse?
10:10:28 <CalJohn> you have the common 1980s understand of GC's
10:10:31 <CalJohn> *ing
10:10:35 <CalJohn> afk
10:10:55 <Eduard_Munteanu> kmc, I just don't think a complete JIT approach is the best way. I'd agree with you if JIT compilers actually did AOT + JIT, that is cache results (or IOW, precompile stuff)
10:11:27 <kmc> yes, once you compute something you might as well cache it
10:11:36 <Eduard_Munteanu> CalJohn, no, but you still have to understand it incurs a cost.
10:12:09 <pikhq> Eduard_Munteanu: Just like manual allocation incurs a cost.
10:12:24 <CalJohn> the cost incured by GC's is lower than with manual allocation
10:12:29 <Eduard_Munteanu> pikhq, note that GC means GC costs + manual allocation costs.
10:12:30 <kmc> in dynamic languages, most operations can in theory depend on expensive lookups (e.g. symbol table, dynamic type dispatch), but most invocations of most code will share a common pattern
10:12:37 <Eduard_Munteanu> LOL
10:12:51 <kmc> and so it's valuable to recognize the pattern and compile a specialized version
10:12:52 <Eduard_Munteanu> You guys think manual allocation is malloc()
10:12:55 <kmc> lol
10:12:56 <Eduard_Munteanu> Well it is not only malloc()
10:13:00 <kmc> lol lol lol lol lol
10:13:02 <Eduard_Munteanu> It is anything!
10:13:04 <sinelaw> ZOMG
10:13:04 <kmc> go to #haskell-blah
10:13:07 <kmc> lol
10:13:19 <kmc> afk
10:13:23 <sinelaw> fak
10:13:29 <Loriel> It is operator new()
10:13:30 <Loriel> 8)
10:13:31 <sinelaw> oops. afk
10:13:35 <Eduard_Munteanu> If you have a malloc' that gives you pointers from a preallocated array, it's still manual.
10:13:55 <pikhq> Eduard_Munteanu: malloc() + free() + mmap() + brk() + paging, for this context. Plus all the necessary record keeping to actually free when appropriate.
10:14:24 <pikhq> Obviously, only the record keeping is different from the GC case.
10:14:27 <benmachine> Eduard_Munteanu: surely you are just manually implementing a GC then :P
10:14:28 <Eduard_Munteanu> pikhq, um, I wasn't specifically referring to those. I thought I was clear that some apps use memory pools and manual allocation _at the same time_
10:14:33 <Eduard_Munteanu> benmachine, no.
10:14:48 <Eduard_Munteanu> Memory pools != GC
10:14:53 <pikhq> benmachine: Manually implementing malloc + mmap + brk, more like.
10:15:00 <pikhq> Oh, and free.
10:15:05 <Eduard_Munteanu> Yeah.
10:15:22 <benmachine> manually implemented manual allocation
10:15:25 <benmachine> neat
10:15:36 <pikhq> It's commonly done in C++.
10:15:38 <pikhq> Yes, really.
10:15:56 <Eduard_Munteanu> Saying that GC is faster than manual alloc surely misses the point that dynamic object allocation does not equal pools.
10:16:15 <Eduard_Munteanu> The Linux kernel does GC techniques then :P
10:16:33 <Eduard_Munteanu> Since it uses slabs, pages and other allocation techniques.
10:17:11 <benmachine> it sounds to me like you are saying that the way to be as fast as a GC is basically to imitate its methods
10:17:16 <sinelaw> Eduard_Munteanu, what exactly are you trying to say?
10:17:27 <pikhq> Eduard_Munteanu: Uh... That's the most retarded thing I've ever heard.
10:17:39 <Eduard_Munteanu> sinelaw, I'm saying that GC isn't provably faster than manual allocation.
10:17:41 <benmachine> pikhq: *that*'s inflammatory language
10:17:53 <pikhq> benmachine: ... Why yes, yes it is.
10:17:55 <sinelaw> Eduard_Munteanu, how can it be "provably" faster?
10:18:05 <benmachine> pikhq: inflammatory language makes me sad :(
10:18:08 <pikhq> It's gotten a bit too easy.
10:18:11 <Eduard_Munteanu> benmachine, memory pools are not something specific to GCs.
10:18:13 <pikhq> Damned IRC. :P
10:18:24 <sinelaw> _Darned_
10:18:28 <benmachine> heh
10:18:30 <sinelaw> :P
10:18:37 <pikhq> Eduard_Munteanu: Memory pools have absolutely nothing to do *with* GC, other than that they're commonly used for GC.
10:18:37 <Eduard_Munteanu> sinelaw, somebody claimed GC is faster than manual alloc because it uses pools.
10:18:46 <Eduard_Munteanu> pikhq, exactly.
10:18:57 <Eduard_Munteanu> That's what I've been saying for the past 15 mins.
10:19:02 <kmc> i'm angry
10:19:04 <kmc> angry about memory
10:19:11 <pikhq> ... That's not what we've been hearing at all.
10:19:14 <sinelaw> there's no point about talking about proofs, it's an empiric science
10:19:21 <benmachine> woo I fixed my stapler
10:19:23 <Eduard_Munteanu> pikhq, heh, read again :)
10:19:36 <CalJohn> Eduard_Munteanu: http://xrl.in/4bv5 is a helpful (but slightly out of date) post about java's old gc method
10:19:37 <kmc> go to #haskell-anywhere-but-here
10:19:37 <benmachine> I used the skills I had developed from breaking my stapler
10:19:40 <benmachine> to fix it
10:19:46 <pikhq> It sounded like you were under the impression that all GC has something to do with pools, and you were then claiming that all the benefits can be had using manual pools.
10:19:55 * benmachine hugs kmc
10:20:11 <Eduard_Munteanu> sinelaw, it's not proofs, but it's surely unprovable best case GC can't be faster than best case manual alloc. Since the former must go through the latter.
10:20:28 <Eduard_Munteanu> CalJohn, oh, I'll take a look.
10:20:30 <sinelaw> Eduard_Munteanu, i have no idea what you're talking about
10:20:39 <PeakerWork> One way to manually manage memory is to write a GC and use that :P
10:20:41 <Loriel> Eduard_Munteanu: With that argument, you are reducing the term "manual allocation" to be meaningless.
10:20:49 <PeakerWork> so sure, whatever the fastest way to do it is, manual memory management can do it
10:21:07 <sinelaw> PeakerWork, well stated.
10:21:09 <Eduard_Munteanu> Loriel, the main thing about GC is not pools, but *automatic* malloc and free
10:21:16 <Eduard_Munteanu> or rather free
10:21:33 <burp> dcoutts: does glade work for you with your gtk2hs 6.12 patch?
10:21:55 <pikhq> Eduard_Munteanu: Often with manual allocation, you have to hold onto pointers longer in order to be able to free them at the right time.
10:22:15 <pikhq> You also need to do record keeping such as "keeping track of who owns something".
10:22:15 <burp> I still have linking problems with glade
10:22:16 * Eduard_Munteanu suggests Linux kernel truly has GC because of slabs and OOM reaper </joke> :P
10:22:49 <Eduard_Munteanu> pikhq, um, so does GC.
10:22:54 <Eduard_Munteanu> It can't be done otherwise.
10:23:07 <taruti> Eduard_Munteanu: not really
10:23:10 <CalJohn> no
10:23:30 <taruti> Eduard_Munteanu: it can form a reachablity graph and consider the rest garbage
10:23:31 <pikhq> Eduard_Munteanu: ... No.
10:23:38 <pikhq> GC needs to check what's reachable.
10:23:41 <pikhq> That's it.
10:23:44 <taruti> Eduard_Munteanu: ownership is not important
10:23:48 <CalJohn> i think we should go to overflow though, because this discussion isn't for the benefit of the channel any more
10:24:23 <Eduard_Munteanu> taruti, well, for the most part it does that because it obviously has no understanding of the underlying program semantics.
10:25:11 <Eduard_Munteanu> OTOH, on the manual case, the program knows its own semantics, so it can free something after it's done with it.
10:25:13 <Loriel> Eduard_Munteanu: And that makes it faster. Semantics slow shit down.
10:25:29 * Eduard_Munteanu *sigh*
10:25:42 <taruti> Eduard_Munteanu: and many times semantics don't have a clean 'ownership'
10:25:55 <Twey> CalJohn: I don't know.  I'm enjoying it.
10:26:39 <CalJohn> well, ok, a little longer :p
10:26:44 <Eduard_Munteanu> taruti, please just don't try to pit good/research/brilliant/etc GCs against poorly written manual allocation code. Please don't do it, it's really unfair to do that and claim best case GC is better than best case manual alloc.
10:27:25 <pikhq> Eduard_Munteanu: Best-case manual allocation is roughly the same as best-case GC. :P
10:27:33 <Eduard_Munteanu> pikhq, yes :)
10:27:48 <taruti> "typical case" is much more interesting
10:27:49 <Twey> But of course GC is always going to be best-case (implementation), whereas manual allocation is inevitably going to suffer from programmer error.
10:27:52 <Eduard_Munteanu> GC converges to manual allocation performance.
10:27:56 <Eduard_Munteanu> in best case.
10:28:13 <Eduard_Munteanu> Or they're equal, doesn't really matter.
10:28:45 <pikhq> Manual allocation performance is heavily dependent on whether or not recordkeeping needs to be done on pointers.
10:28:46 <taruti> or GC is better (in typical settings) for some problems
10:29:03 <Eduard_Munteanu> taruti, Twey, well I can cite quite a few scenarios where the typical case is sensibly worse when used with GC.
10:29:10 <pikhq> GC performance is heavily dependent on how quickly the GC can determine what is and isn't reachable.
10:29:17 <Eduard_Munteanu> Typically small code for tight math loops and all that.
10:29:39 <Twey> Eduard_Munteanu: So long as it's properly written, of course
10:29:40 <Eduard_Munteanu> Typically stuff that it's obviously correct manual-alloc-wise
10:29:44 <Twey> Yeah
10:29:46 <taruti> small code in tight math loops does typically not need to allocate things
10:29:48 <CalJohn> Twey: the only way to get manual allocation to be as good as the best GC's is to use manual allocation to build a high end GC
10:30:02 <Eduard_Munteanu> Note that I'm not claiming in any way manual alloc is the way to go.
10:30:15 * Eduard_Munteanu *sighs* louder
10:30:35 <Loriel> So how do i manually allocate my memory in haskell
10:30:45 <copumpkin> Foreign.
10:30:49 <copumpkin> if you really want to
10:30:53 <Eduard_Munteanu> I asked that before, it seems you can't really do without a GC in Haskell.
10:30:57 <mauke> @hoogle malloc
10:30:57 <lambdabot> Foreign.Marshal.Alloc malloc :: Storable a => IO (Ptr a)
10:30:57 <lambdabot> Foreign.Marshal.Array mallocArray :: Storable a => Int -> IO (Ptr a)
10:30:57 <lambdabot> Foreign.Marshal.Array mallocArray0 :: Storable a => Int -> IO (Ptr a)
10:31:20 <Eduard_Munteanu> You can alloc manually for some stuff, but you can't get rid of a GC completely.
10:31:22 <aavogt> @hoogle alloca
10:31:23 <lambdabot> Foreign.Marshal.Alloc alloca :: Storable a => (Ptr a -> IO b) -> IO b
10:31:23 <lambdabot> Foreign.Marshal.Array allocaArray :: Storable a => Int -> (Ptr a -> IO b) -> IO b
10:31:23 <lambdabot> Foreign.Marshal.Array allocaArray0 :: Storable a => Int -> (Ptr a -> IO b) -> IO b
10:31:32 <CalJohn> Eduard_Munteanu: the problem you're not considering is when the program semantics are ambigious (or very hard) about when something isn't being used any more
10:31:48 <CalJohn> concurrency can create a lot of these situations
10:32:16 <pikhq> Eduard_Munteanu: A lack of GC makes *closures* absolutely insane.
10:32:26 <Loriel> Surely whenever I say something like let (a, b) = splitAt ..., I need to allocate a tuple on the gc heap
10:32:27 <pikhq> (you can do it, but boy is it a pain)
10:32:39 <Heffalump> presumably if you know the end of the life of something in the sequential case, you just have to use some kind of counting to detect the end of life in the concurrent case.
10:32:40 <taruti> CalJohn: cyclic graphs + concurrency :)
10:33:06 <CalJohn> Eduard_Munteanu: sometimes, the only time a static analysis will tell you you can free something safely is when the program ends
10:33:12 <Eduard_Munteanu> CalJohn, hm, I don't think it's as bad as you put it. Linux deals with it quite fine, see per-cpu stuff for example.
10:33:12 <Loriel> and when Foreign says alloca, it really means malloc and attach a finalizer
10:33:16 <CalJohn> when the program never ends, that is not acceptable
10:33:24 <taruti> Heffalump: counting thus needs locks and cycle detection...
10:34:01 <Eduard_Munteanu> pikhq, I wonder, can I turn off embedding a GC from GHC?
10:34:29 <taruti> Eduard_Munteanu: that would be a massive fail.
10:34:57 <Eduard_Munteanu> taruti, yes, of course. I was interested for OS programming so I can make the runtime smaller.
10:35:17 <taruti> Eduard_Munteanu: why not OS programmin *with* GC?
10:35:20 <Eduard_Munteanu> taruti, it's reasonable to do some management if you can get hold of all heap refs somehow.
10:35:43 <Eduard_Munteanu> taruti, it's perfectly fine, but then you have code embedded from GHC. Which might or might not be suitable.
10:35:45 <CalJohn> taruti: well, the main problem is that you want determinism
10:35:49 <taruti> Eduard_Munteanu: except Prelude things will allocate memory behind your back.
10:35:55 <Heffalump> why do you need cycle detection? Anyway, GC needs locks too.
10:36:04 <CalJohn> that can be done with GC's, but i'm not sure if it can be done well
10:36:37 <Eduard_Munteanu> taruti, obviously if you write an OS you might consider writing your own GC / manual alloc system, and same thing goes for Prelude.
10:36:52 <taruti> Eduard_Munteanu: iirc Haskell as a kernel module and on bare iron have been both done.
10:37:16 <Eduard_Munteanu> taruti, heh yeah, but I still think it embeds a GC in there.
10:37:24 <taruti> Eduard_Munteanu: you can replace the GC if you really really want.
10:37:26 <pikhq> Eduard_Munteanu: Functional languages almost *need* a GC.
10:37:34 <aavogt> well in the latter case there's lots of code to run before you get the GC up
10:37:36 <Eduard_Munteanu> I don't think static analysis can do away with freeing.
10:38:02 <pikhq> Every single closure creates another reference to memory.
10:38:25 <pikhq> Haskell is almost made of closures.
10:38:35 <Eduard_Munteanu> pikhq, yeah, I suppose you could allow GC-less behavior until you get your own up, then get all refs and free what's needed.
10:38:48 <Eduard_Munteanu> pikhq, I'm actually looking if it's possible to write the GC itself in Haskell.
10:39:10 <taruti> Eduard_Munteanu: so given a manual alloc and free and the Haskell code of: "x = sum (take 100 (map (*2) [1..]))" how do you manage without a GC?
10:39:11 <Loriel> Wow, the haskell-for-kernel-modules setup compiles gmp to run in the kernel :o
10:39:32 <pikhq> Eduard_Munteanu: Maybe, but it'd be a royal pain.
10:39:37 <pikhq> And you'd be writing C in Haskell.
10:39:51 <Eduard_Munteanu> taruti, obviously I think you'd need some sort of state transformer that brings up the GC. And you're GC-less until then, which might not be a problem.
10:40:05 <pikhq> And you'd have to hack up your Haskell compiler pretty well.
10:40:05 <taruti> Loriel: there is a pure-Haskell integer replacement
10:40:09 <Eduard_Munteanu> pikhq, yeah, at least imperative code in Haskell.
10:40:42 <pikhq> Nope, not just imperative. Pointer manipulating code.
10:40:52 <Dashkal> Is there a good description of monoids out there that isn't described from the math angle?
10:40:55 <Eduard_Munteanu> Yeah, sending Haskell modules to LKML sure is going to be a pissing contest.
10:41:16 <Eduard_Munteanu> pikhq, yeah, unboxed data and all that.
10:41:23 <taruti> sending anything but C to LKML is going to be a disaster
10:41:33 <aavogt> Dashkal: how about the actual code?
10:41:35 <Eduard_Munteanu> taruti, um, perl/bash is accepted :)
10:41:41 <Eduard_Munteanu> For scripts/
10:41:45 <pikhq> And Make.
10:41:50 <taruti> haha
10:41:51 <Loriel> From what I heard, sending anything to LKML is going to be a disaster.
10:41:55 <Dashkal> aavogt: I'm trying to get a better grasp as to what they are.  So far I've failed to grok the concept.
10:42:00 <dmwit> Wasn't there a blog post about writing kernel modules in Haskell recently?
10:42:07 <Eduard_Munteanu> Though you won't merge anything #!/bin/runhaskell anytime soon :D
10:42:08 <pikhq> Yes.
10:42:14 <taruti> dmwit: yes
10:42:16 <Eduard_Munteanu> Yes, even on LWN.
10:42:17 <dmwit> Is that what we're talking about?
10:42:20 <dmwit> Sorry, I just walked in.
10:42:21 <dmwit> =P
10:44:18 <taruti> having a short C bootstrap code that sets everyting up for the runtime is not bad.
10:44:33 <kmc> isn't this where we came in?
10:44:39 <taruti> the entire rts is written in C.
10:45:26 <Eduard_Munteanu> Yeah, it's actually interesting if one could implement it all in C, and possibly some asm.
10:45:32 <Eduard_Munteanu> s/C/Haskell/
10:45:51 <kmc> sure, precompile the C bits to asm
10:45:56 <kmc> now it's all Haskell and asm
10:46:02 <Eduard_Munteanu> Heh.
10:46:37 <taruti> there is also some C--/Cmm there iirc
10:46:58 <aavogt> Dashkal: well the idea is very simple, so maybe just looking at the implementations (provided you've looked at another explanation of typeclasses, pattern matching etc.) would be best
10:47:08 <ddarius> Dashkal: There really isn't much to a monoid at all.  It's a pretty general concept so a whole lot of different things are monoids.
10:47:12 <aavogt> of course if you have specific questions feel free to ask
10:47:19 <Eduard_Munteanu> I'm not really comfy with the idea of having a small runtime along the kernel, even if I write it. The idea would be to handle pages and slabs from within Haskell code.
10:47:23 <Eduard_Munteanu> That would be awesome.
10:47:38 <kmc> again i ask, what is a kernel if not a runtime
10:47:45 <Eduard_Munteanu> Hence the idea to start with a non-GC-ized binary and do the GC yourself.
10:47:49 <Dashkal> hmm, I'll try that then and see if any coherent questions shake loose
10:48:08 <kmc> it's a set of library functions that co-routines with user code and provides commonly needed functionality, including mediating hardware access
10:48:39 <Eduard_Munteanu> kmc, it is true, but I'd would sure be awesome if you could handle it all from Haskell code.
10:48:43 <taruti> Eduard_Munteanu: you can do that, 1) C cpde in the binary starts up and sets things up, 2) you jump into the Haskell that uses the said GC
10:49:02 <kmc> not really sure this would be awesome
10:49:11 <taruti> Trying to fit one hammer into every hole is not good.
10:49:29 <Eduard_Munteanu> kmc, what I mean is: start Haskell code with no embedded GC, and power up the GC.
10:49:29 <kmc> said the actress to the bishop
10:49:39 <Eduard_Munteanu> taruti, yeah, that might be also true.
10:50:01 <taruti> just do the setup in C.
10:50:14 <ddarius> kmc: See exokernels.
10:50:16 <taruti> even C code has setup things that are run before main
10:50:19 <kmc> wouldn't it be awesome if you could build a motherboard with no discrete resistors on it
10:50:48 <Eduard_Munteanu> taruti, yeah, but these days they are either minimal or nonexisting (of course, you still use some inline asm)
10:50:55 <ddarius> kmc: Switching capacitors ho!
10:51:06 <Dashkal> hmm, I think I'll probably just have to play with them a few times to get this.  I at that point where I know it hasn't clicked but I don't know why.
10:51:17 <kmc> yes, ld.so is minimal or non-existing
10:51:30 <Eduard_Munteanu> kmc, no, I meant the Linux boot code for example.
10:51:39 <ddarius> Dashkal: You are probably expecting too much to be there.  There is really very little there.
10:51:56 <kmc> monoids are much simpler than monads, applicative functors, or any of that
10:52:16 <kmc> in part because they're not parametrized over another type
10:52:24 * Dashkal clicks
10:52:27 <Dashkal> That's what I was missing
10:52:31 <kmc> if your type T has an "empty" element, and a way to combine two elements, it's probably a monoid
10:52:41 <taruti> Eduard_Munteanu: the simplest way is to just use C and asm
10:52:44 <kmc> e.g. lists with [] and (++), or numbers with 0 and (+), or numbers with 1 and (*)
10:52:54 <kmc> or functions of the form (a -> a) with id and (.)
10:53:26 <aavogt> @instances-importing Monoid
10:53:27 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
10:53:29 <Eduard_Munteanu> taruti, if I bootstrap it this way, I wonder if it's possible to switch to an all-Haskell-written GC after the bootstrapping.
10:53:57 <kmc> the required properties are:  (0 + a) = a;  (a + 0) = a;  (a + (b + c)) = ((a + b) + c)
10:54:01 <Eduard_Munteanu> this way = C/asm code
10:54:33 <taruti> Eduard_Munteanu: if you provide suitable primitive operations for it ;)
10:54:41 <aavogt> > mconcat (map (Sum . ) [subtract 5,(+3),(1-)]) 1
10:54:43 <lambdabot>   Sum {getSum = 0}
10:54:47 <Dashkal> *nods* ok, that's my issue.  Much like when I was strugglign with monads, I'm overcomplicating things
10:54:57 <kmc> mm, that's often the issue :)
10:55:49 <olsner> @ty (map (Sum . ) [subtract 5,(+3),(1-)])
10:55:50 <lambdabot> forall a. (Num a) => [a -> Sum a]
10:56:07 * aavogt wonders how   instance (Monoid ())   helps much
10:56:08 <Eduard_Munteanu> Does anyone know any embedded/small/minimal GC algorithms/ideas?
10:56:12 <Dashkal> Alrighty.  Another piece of the puzzle in place.  Thank's for the help there.
10:56:13 <olsner> was that a use of the (->) monoid?
10:56:16 <Twey> Sum is a Monoid for Nums?
10:56:37 <kmc> yeah
10:56:44 <kmc> Sum and Product wrap numbers
10:56:59 <kmc> and provide the monoid {0, (+)} and {1, (*)} resp.
10:57:05 <aavogt> olsner: yes,   instance Monoid b => Monoid (a -> b) where mempty = const mempty; mappend x y = \a -> x a `mappend` y a
10:57:13 <taruti> Eduard_Munteanu: there are tons of papers on various designs.
10:57:20 <HaskellLove> What is a mediating arrow, and what does it mean "a category has a distinquished products"?
10:57:23 <pikhq> Eduard_Munteanu: A semi-space collector is pretty easy.
10:57:36 <Eduard_Munteanu> pikhq, thanks, I'll google that.
10:57:39 <HaskellLove> you choose who are THE destuingished ones?
10:57:43 <taruti> Eduard_Munteanu: why not use the builtin GC and just make it get the memory in a different way?
10:57:50 <ddarius> aavogt: How can you appreciate monoids and not appreciate instance Monoid () ?
10:58:02 <ddarius> olsner: Which one?
10:58:17 <pikhq> Eduard_Munteanu: It's kinda slow, though. Every collection copies objects.
10:58:18 <Eduard_Munteanu> taruti, um, the trouble with GHC is that it makes huge binaries. Could try with JHC though.
10:58:22 <olsner> ddarius: aavogt's snippet of code
10:58:24 <ddarius> olsner: Nevermind, I misread you.
10:58:37 <Eduard_Munteanu> JHC outputs small code, just less than double of C code on a Hello World test.
10:58:42 <taruti> Eduard_Munteanu: try splitting objects for a start
10:58:45 <kmc> JHC also fails hard at memory management
10:58:51 <ddarius> HaskellLove: Yes.
10:58:56 <taruti> Eduard_Munteanu: then get rid of gmp
10:59:13 <aavogt> ddarius: it's not terribly useful, except for avoiding some sorts of overlapping (or flexible instances?) instances which could be had by:  instance Monoid (IO ())
10:59:18 <Eduard_Munteanu> kmc, yeah, but I suppose that's not really a concern if I initialize another GC from Haskell itself.
10:59:24 <taruti> Eduard_Munteanu: the GC is not the guilty party in binary size
10:59:30 <kmc> Eduard_Munteanu, ah, that's a good point
10:59:37 <olsner> hmm, feels like mconcat is kind of like sequence on the function monad
10:59:56 <Eduard_Munteanu> taruti, hm, I think JHC excludes all that's not needed, maybe that includes GMP if I don't use arbitrary precision integers.
10:59:59 <kmc> :t mconcat
11:00:00 <lambdabot> forall a. (Monoid a) => [a] -> a
11:00:07 <aavogt> as in, when I write    mappend :: () -> () -> () -- this should never be called directly in my code
11:00:13 <Eduard_Munteanu> taruti, yeah.
11:00:17 <ddarius> aavogt: The whole spirit of monoids is capturing an "empty" case and a means of combination.  () is an empty case and should be captured.  Capturing these empty cases turns out to be more useful than they at first seem.
11:00:29 <taruti> Eduard_Munteanu: JHC is not production-ready.
11:00:39 <aavogt> @src () mappend
11:00:39 <lambdabot> Source not found. There are some things that I just don't know.
11:01:04 <pikhq> @instances Monoid
11:01:04 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
11:01:20 <olsner> @src (,) mappend
11:01:20 <lambdabot> Source not found. Wrong!  You cheating scum!
11:01:21 <Eduard_Munteanu> taruti, is it a library problem only? Because if it so, I expect I'd reimplement Prelude myself to experiment with OSes and Haskell.
11:01:38 <ddarius> aavogt: The correct source is () `mappend` () = (), but that may or may not be what is in the libraries.
11:01:56 <aavogt> > mappend undefined undefined
11:01:57 <lambdabot>   ()
11:02:03 <aavogt> ddarius: it's lazy
11:02:10 <ddarius> aavogt: Indeed, which is wrong.
11:02:12 <HaskellLove> Ok i understand what an injective function is, but an injective arrow?
11:02:17 <benmachine> ddarius: why is it wrong?
11:02:27 <pikhq> HaskellLove: Y'know functions?
11:02:32 <taruti> Eduard_Munteanu: also compiler side of things. I think the House-approach makes more sense.
11:02:34 <HaskellLove> ya
11:02:41 <pikhq> There you go.
11:02:42 <olsner> wouldn't it be legal for a compiler to optimize pattern-matching on () to a no-op?
11:02:44 <ddarius> HaskellLove: Arrows aren't injective.  If someone is saying they are, they have defined the term.
11:02:50 <ddarius> olsner: No.
11:02:55 <kmc> olsner, no, it must force the value
11:03:05 <ddarius> benmachine: () `mappend` undefined = undefined by the left identity law.
11:03:08 <Eduard_Munteanu> taruti, heh, but House annoys me in that it wants to patch and compile GHC code.
11:03:43 <HaskellLove> pikhq?
11:03:48 <taruti> Eduard_Munteanu: so do a cleaner House2 with the recent ghc-lkm stuff included.
11:03:49 <kmc> olsner, with strictness analysis, you might could optimize
11:04:54 <Eduard_Munteanu> ddarius, AFAICT, arrows are nowhere as specific as functions. What are they really, arbitrary binary relations?
11:04:57 <copumpkin> HaskellLove: injective arrow? you reading about mono- and epi-?
11:04:59 <ddarius> kmc: Strictness analysis isn't what's necessary.  However, simple inlining can and would lead to such cases when it was obvious the value was not undefined.
11:05:31 <ddarius> Eduard_Munteanu: They are nothing.  What an arrow is for a particular category is part of what is provided in the definition for a particular category.
11:06:00 <kmc> ddarius, ah.  so the forward-propogation of information about which values are already in whnf is not considered part of strictness analysis?
11:06:08 <Eduard_Munteanu> ddarius, oh, I see, thanks. That's why it can represent arbitrary "relations" between objects.
11:06:08 <pikhq> @src Arrow
11:06:09 <lambdabot> class Arrow a where
11:06:09 <lambdabot>     arr, pure   :: (b -> c) -> a b c
11:06:09 <lambdabot>     (>>>)       :: a b c -> a c d -> a b d
11:06:09 <lambdabot>     first       :: a b c -> a (b,d) (c,d)
11:06:09 <lambdabot>     second      :: a b c -> a (d,b) (d,c)
11:06:10 <lambdabot>     (***)       :: a b c -> a b' c' -> a (b,b') (c,c')
11:06:13 <lambdabot>     (&&&)       :: a b c -> a b c'  -> a b (c,c')
11:06:20 <pikhq> That's what they are.
11:06:31 <kmc> Haskell's Arrow class does not correspond very well to what category theorists mean when they say "arrow"
11:06:43 <Eduard_Munteanu> Maybe functors?
11:06:53 <kmc> Haskell's Arrow class represents some kind of category with products along with a functor from Hask
11:06:55 <ddarius> Yes, just to be clear, I'm talking about categorical arrows here.
11:07:00 <pikhq> kmc: And the same is true of Monad v. monad, Functor v. functor, etc. :P
11:07:04 <kmc> i think HaskellLove is too, despite the name and channel
11:07:07 <Eduard_Munteanu> ddarius, yeah, I was too.
11:07:10 <kmc> pikhq, those are much closer
11:07:12 <HaskellLove> http://img689.imageshack.us/img689/7906/screenshotzcy.png copumpkin, pikhq, ddarius>	
11:07:15 <pikhq> True.
11:07:17 <kmc> Functor is "endofunctor in Hask"
11:07:18 * Baughn ponders the intricacies of ContT IO. Is anything going to blow up?
11:07:27 <pikhq> Those are more "off because of bugs" than anything else...
11:07:29 <ddarius> kmc: It's similar to a closed Freyd category.  There's a talk which spells out what is needed to make them match exactly.
11:07:38 <kmc> cool ddarius
11:07:39 <ddarius> Baughn: No.
11:07:40 <PeakerWork> quicksilver: you there?
11:07:49 <copumpkin> HaskellLove: okay, yes?
11:08:09 <kmc> Baughn, it can't reverse time and undo IO when following a continuation
11:08:10 <EnglishGent> HaskellLove - if your learning category theory I recommend 'conceptual mathematics - a first introduction to categories'
11:08:14 <kmc> otherwise, sounds like a barrel of fun
11:08:20 <EnglishGent> by _far_ the best textbook I've seen on the subject :)
11:08:28 <ddarius> pikhq: Other than not being able to enforce the functor laws, Functor, is an accurate capturing of a special case of the general notion of functor.
11:08:29 <Baughn> kmc: No, for that I'd need IOT Cont
11:08:34 <kmc> yes
11:08:42 <HaskellLove> copumpkin i am confused about injective arrows, I see them as injective functions which map distinct things, and that is not what is going on in that example, and still they are called injective
11:08:43 <Eduard_Munteanu> HaskellLove, I guess it also defines _injection_ arrows as that particular stuff.
11:08:45 <Baughn> kmc: Which can be implemented using unsafePerformIO.
11:08:56 <copumpkin> HaskellLove: injections
11:09:06 <kmc> i wonder if any of the pure-Haskell models of the IO monad have an IOT transformer
11:09:12 <benmachine> Baughn: except of course it can't really be implemented at all
11:09:16 <ddarius> HaskellLove: "injections" /= "injective"
11:09:28 <kmc> i think you also need unsafeUnperformIO
11:09:31 <copumpkin> HaskellLove: projections <-> injections
11:09:32 <benmachine> heh
11:09:39 <Baughn> benmachine: It can, but only by jumping up a layer and embedding it below the laws of physics
11:09:41 <copumpkin> HaskellLove: at least for products/coproducts
11:09:43 <ddarius> "injections" are just a name for those particular arrows, just like projections for products.
11:09:53 <EnglishGent> hi copumpkin, benmachine :)
11:09:53 <benmachine> Baughn: haha, yeah I suppose so
11:09:55 <benmachine> hi
11:09:56 <copumpkin> hi EnglishGent :)
11:10:14 <kmc> :t Left
11:10:15 <lambdabot> forall a b. a -> Either a b
11:10:17 <kmc> :t Right
11:10:18 <lambdabot> forall b a. b -> Either a b
11:10:23 <copumpkin> HaskellLove: Left/Right (if you ignore bottoms) are those injections into Either a b (an almost coproduct)
11:10:42 <copumpkin> HaskellLove: fst/snd (again ignoring bottoms) are projections from (a, b) (an almost product)
11:11:03 <Eduard_Munteanu> I believe that definition is actually a multiple one. Like saying "A bipedal animal consists of head, trunk and limbs"
11:11:23 <HaskellLove> interesting copumpkin thank you
11:11:39 <Eduard_Munteanu> That is, it also names those two things and defines them simultaneously with the main thingy.
11:12:00 <kmc> a man is a featherless biped
11:12:44 <Eduard_Munteanu> Um... would a wolf, monkey etc. have feathers oO ?! :))
11:12:59 <Eduard_Munteanu> Perhaps furless.
11:13:11 <dmwit> wolves and monkeys are not bipeds
11:13:37 <Eduard_Munteanu> Interesting, if there are no furry bipeds, then that is true.
11:14:08 <HaskellLove> so copumpkin, injective vs injection, sorry i did not get that part
11:14:09 <dmwit> "furless" is not a good replacement for "featherless" because chickens are feathery bipeds.
11:14:52 <copumpkin> HaskellLove: they're related, but injection in this case just means you can take something and stick it into something else
11:14:55 <ddarius> HaskellLove: "injective" and "injection" are different words.  That's all I meant.  The paragraph said "injections" not "injective."  The concept of injective was not mentioned at all.
11:15:13 <ddarius> copumpkin: They are not really related in CT.
11:15:21 <kmc> HaskellLove, read the paragraph as if the word "injection" was not there
11:15:23 <ddarius> copumpkin: Injections don't have to be monos.
11:15:31 <kmc> then append the sentence "By the way, we will call i1 and i2 'injections'"
11:15:31 <HaskellLove> ok
11:15:38 <copumpkin> ddarius: oh, I had it backwards
11:15:48 <ddarius> kmc: Has it.  That paragraph -defines- "injection arrows".
11:15:50 <kmc> thus definining the term
11:17:00 <mlesniak> What is the name of the function that transforms (a,a) -> a into a -> a -> a, i.e. kind of untuples the parameters and returns a function that want the single paramaters successively? (Hoogle couldn't help)
11:17:23 <Taejo> mlesniak: curry
11:17:39 <ddarius> @hoogle ((a,a) -> a) -> a -> a -> a
11:17:40 <lambdabot> Prelude curry :: ((a, b) -> c) -> a -> b -> c
11:17:40 <lambdabot> Data.Tuple curry :: ((a, b) -> c) -> a -> b -> c
11:17:47 <mlesniak> Taejo, ah, right
11:17:59 <mlesniak> Did not got the type right, thanks!
11:20:56 <Lemmih> > 3.6/20100115144158
11:20:57 <lambdabot>   1.791034516061627e-13
11:21:00 <kmc> @djinn ((a, b) -> c) -> a -> b -> c
11:21:01 <lambdabot> f a b c = a (b, c)
11:22:01 <PeakerWork> @src curry
11:22:01 <lambdabot> curry f x y = f (x, y)
11:22:35 <PeakerWork> if djinn chose f,g,... for func-typed values, and x,y... for non-func-typed values, it would generate this exactly :)
11:23:22 <Taejo> :t \a b c -> a b c
11:23:22 <lambdabot> forall t t1 t2. (t -> t1 -> t2) -> t -> t1 -> t2
11:23:50 <dmwit> What's to say b and c are non-func-typed values, though?
11:25:16 <PeakerWork> dmwit: they're more polymorphic than that
11:25:23 <PeakerWork> they're allowed to take non-func-typed values
11:25:42 <mreh> how are ' const . error "a" ' and ' const (error "a") ' different
11:25:46 <HaskellLove> This is not the place to ask such question i am sorry, but, what are your knowledge and reasoning foundations? Mine are the old Greeks, Plato and Aristotle, if you know what I mean. Any fundemental books a smart guy should have read, you smart people, please recommend me here or pm
11:25:51 <mreh> :t const
11:25:52 <lambdabot> forall a b. a -> b -> a
11:26:00 <mreh> oh i know
11:26:27 <mreh> :t const $ error "a"
11:26:28 <sinelaw> HaskellLove, modern mathematical logic systems seem a good start - but i know nothing about them
11:26:28 <lambdabot> forall a b. b -> a
11:27:30 <Ke> I just mixed bits and pieces
11:27:43 <Ke> mostly maths
11:28:09 <PeakerWork> @type (const . error "a")
11:28:10 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (b -> a)
11:28:12 <syntaxglitch> HaskellLove, you could try looking into inferential/probabilistic models of reasoning
11:28:12 <PeakerWork> @type (const $ error "a")
11:28:14 <lambdabot> forall a b. b -> a
11:28:22 <syntaxglitch> But I don't know of any books off hand
11:28:34 <PeakerWork> having a mis-typed . is really bad for pedagogical purposes :(
11:30:03 <nlogax> o_O what happened to (.) ?
11:30:44 <olsner> renamed to fmap maybe?
11:31:05 <Eduard_Munteanu> :t <$>
11:31:06 <lambdabot> parse error on input `<$>'
11:31:09 <Eduard_Munteanu> :t (<$>)
11:31:10 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:31:22 <olsner> @src (<$>)
11:31:23 <lambdabot> f <$> a = fmap f a
11:32:17 <mreh> Control.Exception	try :: Exception e => IO a -> IO (Either e a)   <= type woes, using "try" causes an "ambiguous type variable"
11:32:40 <kmc> yeah, you'll have to do something to nail down the type of e
11:32:43 <kmc> such as add a signature
11:32:47 <kmc> or use it in a type specific wya
11:33:06 <Eduard_Munteanu> @src try
11:33:07 <lambdabot> try a = catch (a >>= \ v -> return (Right v)) (\e -> return (Left e))
11:33:20 <mreh> kmc: I don't want to do anything to it, is there a better try that just returns Nothing?
11:33:27 <Eduard_Munteanu> :t try
11:33:28 <lambdabot> Not in scope: `try'
11:33:36 <kmc> mreh, you might want catch not try
11:33:37 <mreh> I'd like to throw my own exception
11:33:41 <mreh> ah
11:34:14 <kmc> :t \m -> catch (Just <$> m) (const $ return Nothing)
11:34:15 <lambdabot> forall a. IO a -> IO (Maybe a)
11:34:17 <Eduard_Munteanu> Um, I think throw is fail in Haskell
11:34:22 <Eduard_Munteanu> Right?
11:34:40 <kmc> not really
11:34:46 <kmc> fail is a per-monad function
11:34:46 <dmwit> :t throwError
11:34:47 <lambdabot> forall e (m :: * -> *) a. (MonadError e m) => e -> m a
11:34:51 <kmc> invoked for pattern match failures only
11:34:51 <dmwit> :t catchError
11:34:52 <lambdabot> forall (m :: * -> *) a e. (MonadError e m) => m a -> (e -> m a) -> m a
11:34:58 <kmc> for IO monad it probably throws some kind of exception
11:35:00 <Eduard_Munteanu> Oh.
11:35:19 <kmc> throwError and catchError are independent of the Control.Exception stuff
11:35:23 <kmc> :t throw
11:35:24 <lambdabot> Not in scope: `throw'
11:35:30 <kmc> :t Control.Exception.throw
11:35:31 <lambdabot> forall e a. (GHC.Exception.Exception e) => e -> a
11:35:50 <burp> dcoutts: never mind, gtkbuilder works, and it's anyway preferred
11:35:53 <kmc> :t Control.Exception.throwIO
11:35:54 <lambdabot> forall e a. (GHC.Exception.Exception e) => e -> IO a
11:36:02 <Eduard_Munteanu> I guess fail makes sense in Maybe.
11:36:15 <kmc> there's an interesting subtle difference between throw and throwIO
11:36:38 <Eduard_Munteanu> kmc, I presume it does IO in some way?
11:36:46 <kmc> throw e is an expression whose evaluation causes an expression to be thrown
11:37:01 <kmc> throwIO e is an expression which evaluates normally to an IO action.  if the IO action is executed, an exception will be thrown
11:37:24 <Eduard_Munteanu> Ah, I see.
11:37:56 <kmc> you can use throw at the type of throwIO but it will do something different
11:38:00 <Eduard_Munteanu> So you can lazily throw an IO exception such that, when another thing reads you pipe, then is the exception actually thrown.
11:38:09 <Eduard_Munteanu> *your
11:38:13 <Eduard_Munteanu> for example ^.
11:38:28 <Eduard_Munteanu> Interesting.
11:38:32 <kmc> lazy IO is dubious
11:38:40 <kmc> i don't claim to understand how it interacts with exceptions
11:39:52 <kmc> explicit models of communication are better
11:40:08 <mreh> kmc, isn't your catch the wrong way round?
11:40:10 <Eduard_Munteanu> Um, if I were to implement that in C, I'd open a file descriptor normally (synchronously) and mmap on it.
11:40:28 <kmc> mreh, how so?
11:40:30 <Eduard_Munteanu> On reading somewhere inside the map, you block waiting for results.
11:40:35 <Eduard_Munteanu> Am I close?
11:40:38 <mreh> :t catch
11:40:39 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
11:40:52 <kmc> that's the H98 catch
11:40:55 <kmc> Control.Exception generalizes
11:41:00 <kmc> :t Control.Exception.catch
11:41:01 <mreh> i thought so
11:41:01 <lambdabot> forall a e. (GHC.Exception.Exception e) => IO a -> (e -> IO a) -> IO a
11:41:22 <Eduard_Munteanu> kmc, what do you mean? I'm using getContents, is it in any way this bad?
11:41:25 <mreh> oh, i'm getting confused by the type signature
11:41:31 <mreh> well, i'm just confused
11:41:31 <Eduard_Munteanu> :t getContents
11:41:32 <lambdabot> IO String
11:41:46 <kmc> mreh, the args are the action to attempt, then the function which receives any exception
11:41:49 <Eduard_Munteanu> It seems to work like a charm with lines and other stuff.
11:41:54 <kmc> stuff `catch` handler
11:44:01 <Eduard_Munteanu> I do stuff like getContents >>= process . lines
11:44:30 <Eduard_Munteanu> in my attempt at writing a gnuchess replacement in Haskell.
11:44:33 <Eduard_Munteanu> :)
11:44:48 <xerox> main = interact process :D
11:45:14 <Eduard_Munteanu> xerox, hm, does that work? I need to output intertwined with input.
11:45:25 <xerox> let's see
11:45:41 <Eduard_Munteanu> hpaste the code? Sure.
11:45:50 <ddarius> Eduard_Munteanu: If you are just doing basic textual output, then yes, that would work.
11:46:09 <xerox> good, let me not see then :)
11:47:25 <Eduard_Munteanu> xerox, http://pastebin.org/81736
11:47:36 <kmc> basically, lazy IO can break referential transparency
11:47:49 <kmc> when you use it you have a certain proof obligation
11:48:01 <kmc> which is not nearly as clear as with unsafePerformIO etc
11:48:06 <Eduard_Munteanu> kmc, does that use seem okay with you? ^
11:48:10 <kmc> lazy IO operators use unsafeInterleaveIO
11:48:18 <kmc> i don't know, i'll let smarter people analyze it
11:48:32 <Eduard_Munteanu> ddarius, I was under the impression the output "came" after processing the whole input.
11:48:41 <Eduard_Munteanu> In the case of interact.
11:48:53 <aavogt> @src interact
11:48:53 <lambdabot> interact f = do s <- getContents; putStr (f s)
11:49:05 <kmc> http://hackage.haskell.org/package/safe-lazy-io
11:49:21 <aavogt> Eduard_Munteanu: you are basically using interact
11:49:21 <Eduard_Munteanu> aavogt, oh, so f must first return stuff.
11:49:23 <ddarius> Eduard_Munteanu: Nope.
11:49:36 <kmc> try it in ghci
11:49:39 <kmc> interact (map succ)
11:50:15 <Eduard_Munteanu> aavogt, kmc, ddarius, nice thanks
11:50:27 <aavogt> need some read and words in there
11:50:47 <olsner> interact in ghci isn't such a good idea though... it'll read to eof and ghci will die afterwards or something, iirc
11:50:51 <Eduard_Munteanu> But how does this work? It seems to me f must return before putStrLn can output the result.
11:50:58 <olsner> I guess it works once though
11:51:07 <kmc> putStrLn starts to print characters as they are produced
11:51:13 <Eduard_Munteanu> olsner, yeah, I had problems with ghci and stdio/out.
11:51:24 <Cale> Eduard_Munteanu: lazy IO?
11:51:27 <kmc> > ['a'..]
11:51:28 <lambdabot>   "abcdefghijklmnopqrstuvwxyz{|}~\DEL\128\129\130\131\132\133\134\135\136\137...
11:51:35 <kmc> > cycle "foo "
11:51:36 <lambdabot>   "foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo fo...
11:51:38 <aavogt> buffering is kind of weird with interact
11:51:49 <Eduard_Munteanu> Cale, yes.
11:52:02 <sinelaw> @type scanl
11:52:03 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
11:52:07 <Cale> Eduard_Munteanu: getContents is magic. It produces a String which isn't really a proper String, but something which as it's evaluated starts demanding characters from stdin.
11:52:16 <sinelaw> @type foldl
11:52:17 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
11:52:44 <aavogt> as in, words eats too much, so you get your output for the last word the moment you start typing the next one
11:52:49 <Cale> Eduard_Munteanu: Printing doesn't require any magic, but reading does.
11:52:51 <Eduard_Munteanu> Cale, yeah, I figure it's some sort of mmap.
11:52:52 <kmc> Eduard_Munteanu, a String is a linked list.  as individual nodes are produced they can be printed
11:52:58 <olsner> > length ['a'..]
11:52:59 <lambdabot>   1114015
11:53:00 <kmc> it has nothing to do with mmap
11:53:22 <Eduard_Munteanu> kmc, heh, I'm still struggling with the idea that a function must "return" before the caller continuing :)
11:53:22 <Cale> Eduard_Munteanu: What's mmap? ;)
11:53:33 <kmc> Eduard_Munteanu, right, that's not true in Haskell
11:53:44 <aavogt> > interact (unlines . map (("->" ++) . show) . map (succ . read :: String -> Int) . words)
11:53:45 <lambdabot>   <IO ()>
11:53:56 <kmc> Eduard_Munteanu, it's helpful to think of lists as being more like control flow structures than datastructures
11:54:06 <Eduard_Munteanu> Cale, well, in C it's a way to map a file descriptor to a memory region. And it's like lazy I/O.
11:54:09 <Cale> The important thing is just that the list returned by getContents causes I/O to occur as each cons is evaluated.
11:54:11 <kmc> by composing a lazy consumer and a lazy producer of lists, we establish an implicit coroutine between them
11:54:35 <aavogt> that interact has a bug because the  "->" gets printed too early
11:54:49 <Eduard_Munteanu> Cale, yeah, I'm using a recursive x:xs pattern, so I guess I'm reading it in the right order.
11:54:55 <Eduard_Munteanu> Not doing anything weird.
11:55:11 <aavogt> for actual interactive use, it's not easy to add the data dependencies needed to order stuff
11:55:18 <Eduard_Munteanu> kmc, oh.
11:55:19 <Cale> Eduard_Munteanu: Well, yeah, as you walk down the spine of the list, the I/O is actually forced to happen.
11:55:47 <kmc> yes, the list produced by getContents breaks a basic rule of Haskell
11:55:54 <kmc> which is that merely evaluating something cannot perform IO
11:56:01 <ddarius> kmc: unsafeInterleaveIO can reasonably well be implemented with unsafePerformIO.
11:56:23 <Eduard_Munteanu> Cale, yup, looks analogous to mmap to me... s = mmap (...); for (i = 0; i < size; i++) do_something(s[i]);
11:56:37 <kmc> the analogy is not very deep
11:56:50 <kmc> for starters, Strings in GHC Haskell are not implemented as contiguous memory regions
11:56:57 <Eduard_Munteanu> Yeah, there are probably other mechanisms employed, since Haskell is lazier than that :)
11:57:05 <olsner> if a read on /dev/missiles can launch them, getContents can be quite dangerous :P
11:57:09 <Eduard_Munteanu> kmc, hm, yeah, they're linked lists.
11:57:17 <Eduard_Munteanu> olsner, heh.
11:57:23 <Cale> ddarius: If that's the case, I wonder why it's not...
11:57:31 <Ke> though mmap is as lazy as it gets
11:57:42 <Cale> (I agree that it seems that it should be implementable with unsafePerformIO)
11:57:42 <aavogt> kmc: it's not so bad since at least the IO only happens once (provided you evaluate the contents)
11:57:49 <Eduard_Munteanu> Yeah, it is, the kernel pagefaults on accesses.
11:57:54 <kmc> the laziness of mmap is provided by the kernel, not by your language runtime
11:57:55 <mreh> this getOpt in System.Console is great, but how can I remove the flags from the args once I've found them
11:58:16 <dmwit> aavogt: Really?  I don't see a bug here.
11:58:20 <mreh> it's like doing the work twice
11:58:21 <kmc> mreh, "getOpt returns a triple consisting of the option arguments, a list of non-options, and a list of error messages."
11:58:25 <kmc> you want the "non-options"?
11:58:26 <dmwit> aavogt: What's the bug?
11:58:39 <Eduard_Munteanu> What's a better way of doing such I/O nicely? Comonadic streams?
11:58:40 <aavogt> dmwit: sample output: 1->23 124
11:58:47 <aavogt> I typed 123<space>
11:58:57 <dmwit> aavogt: I do not see that behavior.
11:59:04 <dmwit> aavogt: Oh, you must be using ghci.
11:59:05 <mreh> kmc: ah yes
11:59:08 <Eduard_Munteanu> Because I actually like the feel of lazy I/O.
11:59:28 <dmwit> aavogt: GHC-compiled code defaults no LineBuffering, unlike ghci's NoBuffering default.
11:59:32 <Twey> Iteratee
11:59:38 <Twey> @ Eduard_Munteanu
11:59:45 <Eduard_Munteanu> Twey, thanks, will have a look at it.
12:00:03 <dmwit> Regardless, I understand what you're getting at.
12:00:13 <dmwit> It's just coincidence that LineBuffering happens to solve this problem.
12:00:14 <Cale> Eduard_Munteanu: Well, if you want stronger guarantees and less cheating, there's something called Iteratees, but they're very very heavyweight (conceptually) for what they do. (Efficiency-wise they're very good though.)
12:00:35 <kmc> they are oleg-weight conceptually
12:00:36 <Eduard_Munteanu> Cale, I see, will have a look.
12:00:46 <Twey> They're not *that* tricky to get one's head around
12:00:55 <Twey> It's just kind of like learning monads again :þ
12:01:00 <Eduard_Munteanu> Who's that Oleg guy anyway? He seems to have written lots on Haskell.
12:01:06 <syntaxglitch> heh, oleg-weight
12:01:22 <Eduard_Munteanu> His page looks interesting.
12:01:23 <Twey> They're only about .25 Olegs
12:01:27 <ddarius> Cale: I believe it is implemented with unsafePerformIO in Hugs and NHC as: unsafeInterleaveIO = return . unsafePerformIO
12:01:33 <Twey> No type-hackery at all, even
12:01:41 <Cale> Well...
12:01:50 <olsner> .25 Olegs is like three orders of magnitude more than most of us will ever have
12:01:53 <kmc> still, 100 micro-olegs is considered a strong dose
12:02:00 <Eduard_Munteanu> Heh :)
12:02:10 <Cale> type EnumeratorN  s_outer el_outer s_inner el_inner m a = IterateeG  s_inner el_inner m a -> IterateeG  s_outer el_outer m (IterateeG  s_inner el_inner m a)
12:02:13 <Eduard_Munteanu> Some sort of Uustalu/Vene :)
12:02:18 <kmc> i think 250 milliolegs is enough to kill an elephant
12:02:38 <Twey> olsner: Yeah, but thankfully that's referring to the Olegness needed to actually come up with such a thing.  We mortals only need to comprehend it, which doesn't take nearly as much Olegage.  ;)
12:02:40 <syntaxglitch> every time I have a cool idea about something that might work in Haskell, I go check Oleg's stuff and find that 1) he already did it 2) thought it out better 3) did it incidentally while working on something way more interesting
12:02:45 <olsner> kmc: ... to kill an elephant - in the type system!
12:02:53 <Eduard_Munteanu> syntaxglitch, :)
12:02:56 <Twey> syntaxglitch: Hahaha
12:02:58 <Twey> olsner: :-D
12:03:02 <Cale> foldl  :: (ListLike  (s el) el, FoldableLL  (s el) el, Monad  m) => (a -> el -> a) -> a -> IterateeG  s el m a
12:03:03 <BONUS> ahaha
12:03:08 <BONUS> remember syntaxglitch every time I have a cool idea about something that might work in Haskell, I go check Oleg's stuff and find that 1) he already did it 2) thought it out better 3) did it incidentally while working on something way more interesting
12:03:09 <Cale> No type hackery there.
12:03:14 <BONUS> @remember syntaxglitch every time I have a cool idea about something that might work in Haskell, I go check Oleg's stuff and find that 1) he already did it 2) thought it out better 3) did it incidentally while working on something way more interesting
12:03:14 <lambdabot> Nice!
12:03:16 <Cale> :P
12:03:18 <Twey> Cale: Exactly
12:03:25 <Eduard_Munteanu> @quote Oleg
12:03:25 <lambdabot> Oleg says: The implementation of RSA on type level is left for future work
12:03:32 <Eduard_Munteanu> @quote Oleg's stuff
12:03:33 <lambdabot> No quotes for this person. Sorry about this, I know it's a bit silly.
12:03:41 <Eduard_Munteanu> oh, I thought it did full grep
12:03:57 <Twey> @remember olsner < kmc> i think 250 milliolegs is enough to kill an elephant  < olsner> kmc: ... to kill an elephant - in the type system!
12:03:57 <lambdabot> Nice!
12:03:58 <Eduard_Munteanu> WTF, RSA on type level ?!?!?
12:03:59 <kmc> @quote [Oo]leg.*stuff
12:04:00 <lambdabot> syntaxglitch says: every time I have a cool idea about something that might work in Haskell, I go check Oleg's stuff and find that 1) he already did it 2) thought it out better 3) did it incidentally
12:04:00 <lambdabot> while working on something way more interesting
12:04:17 <Eduard_Munteanu> LOL
12:05:29 <syntaxglitch> one time I spent several days failing to pin down a hazy idea, then later realized that what I was trying to implement was an incomplete and broken version of the polymorphic zipper he talks about
12:06:03 <Eduard_Munteanu> Edward Kmett also seems to work on lots of weird stuff too.
12:06:27 <Eduard_Munteanu> Zygohistoprepromorphisms FTW :)
12:06:39 <Twey> edwardk does more theoretical stuff, AIUI
12:06:55 <Eduard_Munteanu> Yeah, he maintains category-extras it seems.
12:07:00 <Twey> Oleg's things mostly have practical applications
12:07:03 <copumpkin> he also likes down-to-earth things
12:07:05 <Twey> (eventually)
12:07:06 <copumpkin> (edwardk)
12:07:11 <Twey> Really?  Huh
12:07:13 <Eduard_Munteanu> :)
12:07:27 <copumpkin> he's got an x86_64-to-x86_64 tracing JIT, for example
12:07:33 <Twey> Sweet
12:07:48 <Eduard_Munteanu> copumpkin, what's it for?
12:08:01 <copumpkin> Eduard_Munteanu: making code faster :P
12:08:04 <Eduard_Munteanu> Oh.
12:08:24 <Twey> Haha
12:08:27 <copumpkin> if it notices certain kinds of inefficient behaviors it can optimize them out
12:08:41 <dmwit> :t zipWithM
12:08:42 <lambdabot> forall a b (m :: * -> *) c. (Monad m) => (a -> b -> m c) -> [a] -> [b] -> m [c]
12:08:56 <Eduard_Munteanu> Lazy languages, but lazy programmers? :)
12:09:32 * BenceF wishes ghci had syntax highlighting
12:09:37 <ddarius> Eduard_Munteanu: It would actually not be very hard at all to implement RSA at the type level.  It'd be slow as molasses though.
12:10:44 <Cale> I understand how Iteratee works conceptually, but somehow I feel like it's something that I'd never actually use directly myself. Somehow it feels like something which ought to be hidden behind RULES pragmas to me.
12:11:07 <Cale> (If that actually made sense to do)
12:11:21 <Eduard_Munteanu> ddarius, looks interesting, you could write a quine that self generates a SHA hash for itself at type-level. Not RSA, but still crypto.
12:11:25 <Twey> Cale: I like them a lot
12:11:41 <Twey> *Creating* iteratees is a bit clumsy, but the interface is very nice
12:11:49 <sshc> @hoogle combinations
12:11:49 <lambdabot> No results found
12:11:54 <sshc> @hoogle combination
12:11:55 <lambdabot> No results found
12:12:08 <Twey> It's kind of hard to take another step away from the imperative IO model, but I prefer it in the end
12:12:13 <sshc> @hoogle (Integral a) => a -> [b] -> [[b]]
12:12:14 <lambdabot> Data.List genericDrop :: Integral i => i -> [a] -> [a]
12:12:14 <lambdabot> Data.List genericTake :: Integral i => i -> [a] -> [a]
12:12:14 <lambdabot> Data.List genericReplicate :: Integral i => i -> a -> [a]
12:13:12 <Twey> Infinite type…
12:13:19 <Eduard_Munteanu> Hm, Oleg has stuff on Iteratee and lazy I/O
12:13:27 <Twey> Eduard_Munteanu: Yes, of course
12:13:32 <Twey> He authored it
12:16:21 <sinelaw> @scan
12:16:21 <lambdabot> I'd rather not;  looks rather dangerous.
12:16:23 <sinelaw> @type scan
12:16:24 <lambdabot> Not in scope: `scan'
12:16:26 <Cale> I just wonder if it's actually a step in the right direction away from imperative I/O. It's a weird compromise between abstraction and practicality, and the types are too far away from anything which would give me the feeling that it's something fundamental.
12:17:19 <Eduard_Munteanu> Lazy I/O looks nice to me, but it kinda misrepresents the nature of I/O.
12:17:41 <Eduard_Munteanu> So perhaps only imperative-ish methods are correct.
12:17:57 <Twey> Eduard_Munteanu: Iteratee is not lazy I/O
12:18:10 <Eduard_Munteanu> Twey, I know.
12:18:16 <Cale> Well, it's not like the semantics of lazy I/O are really all that nice either, but it has its place.
12:18:25 <Twey> Eduard_Munteanu: It's also a correct method that isn't imperative-ish :þ
12:19:03 <Eduard_Munteanu> Twey, I meant iteratee is probably non-lazy and monadic.
12:19:10 <Twey> Nope
12:19:12 <dmwit> ?src intersect
12:19:12 <lambdabot> intersect = intersectBy (==)
12:19:17 <Twey> Read it before you judge it :þ
12:19:18 <dmwit> ?src intersectBy
12:19:18 <lambdabot> intersectBy eq xs ys = [x | x <- xs, any (eq x) ys]
12:19:42 <Twey> It's strict I/O that can play nicely with lazy evaluation
12:19:43 <Eduard_Munteanu> Twey, I did not say it was incorrect, I said that about lazy I/O
12:19:51 <Twey> It's not monadic
12:19:55 <Eduard_Munteanu> Oh.
12:20:00 <Eduard_Munteanu> Yeah, will look more closely.
12:20:13 <Twey> It's based on the concept of the fold
12:20:20 <Twey> (like foldr/foldl)
12:20:39 <Cale> Actually, IterateeG does have a monad instance.
12:20:42 <Twey> With some convenience stuff and allocation abstraction capabilities built in
12:20:55 <Twey> Does it?  I've never seen monadic Iteratee code
12:20:58 <Twey> What does it look like?
12:21:12 <syntaxglitch> what kind of term is "fold" anyway, that's not nearly obscure enough, we should replace it with some cryptic category theory term
12:21:38 <Eduard_Munteanu> What really happens if I do evaluate (!! n) on lazy I/O? It reads everything up to n, right?
12:21:39 <copumpkin> catamorphism
12:21:41 <sinelaw> gogomorphotic
12:21:46 <ddarius> syntaxglitch: There is a cryptic term for it, but it doesn't really come from category theory.
12:21:51 <Twey> Eduard_Munteanu: Yes
12:21:52 <sinelaw> copumpkin, oh hm :)
12:22:01 <copumpkin> it sort of uses category theory notions though
12:22:16 <ddarius> copumpkin: Categorists are more likely to say "fold."
12:22:26 <syntaxglitch> yeah, I couldn't remember if catamorphism actually meant folds or just something related
12:22:32 <Eduard_Munteanu> Twey, so in a sense it's "cached" if I do random access. How is this bad?
12:22:41 <koala_man> catamorphl
12:22:45 <sinelaw> i think it's much more general than fold, no?
12:22:47 <ddarius> It was really the Squiggolist people that popularized "catamorphism" and co.
12:22:55 <ddarius> sinelaw: They are synonyms.
12:22:59 <Twey> Eduard_Munteanu: Nothing.  The ‘bad’ part is the fact that I/O can result in more things than just the data you requested.
12:23:16 <sioraiocht> Catamorphism is a stupid word, imo
12:23:29 <Twey> For example, you can't tell if an EOF occurs, or the file gets deleted, or the filesystem goes away, or…
12:23:46 * syntaxglitch also suggests replacing "left" and "right" with "dextral" and "sinistral" for additional obscurity power
12:23:50 <sioraiocht> They are both terms for the unique arrow form an initial algebra to another one
12:23:53 <Twey> syntaxglitch: I actually like that
12:23:55 <Eduard_Munteanu> Twey, oh, I understand. What happens then, segfault?
12:23:57 <sioraiocht> *from
12:24:00 <Twey> Or ‘diesel’ and ‘widdershins’
12:24:09 <sioraiocht> syntaxglitch: you reversed those, I think ;)
12:24:15 <Twey> Eduard_Munteanu: Current lazy I/O just ends the list
12:24:28 <ddarius> sioraiocht: Or he's going for even more obscurity.
12:24:28 <Twey> So you get a pattern match failure on !! n
12:24:38 <syntaxglitch> sioraiocht, yeah, wasn't paying attention
12:24:50 <Cale> "The unique morphism from the initial F-algebra."
12:24:53 <dmwit> Wow, it would be really malicious if the OS segfaulted you for trying to read a non-existent file.
12:24:57 <sioraiocht> Cale: indeed
12:25:04 <syntaxglitch> sioraiocht, I think they're stored in my head alphabetically or something
12:25:10 <Eduard_Munteanu> Twey, hm so AFAICT, for my chess engine, it should be fine. I don't do anything that might cause problems.
12:25:24 <Cale> sioraiocht: ah, yeah, you mentioned that too :)
12:25:28 <sioraiocht> syntaxglitch: I'm only so aware because, as a lefthander, I am sinister ;)
12:25:40 <Twey> Eduard_Munteanu: In simple cases it's okay, sometimes
12:25:54 <Twey> But it seriously impacts the robustness of the application
12:26:03 <Twey> Also, that ‘caching’ isn't always desirable
12:26:13 <Twey> It can result in a lot of memory usage if you're not careful
12:26:19 <sioraiocht> and of course, we know have even more evil terms
12:26:31 <Eduard_Munteanu> Twey, yeah, I don't do it anyway, I use a recursive f x:xs to process line by line.
12:26:34 <sioraiocht> effing histomorphism, paramorphism, hylomorphism
12:26:38 <Eduard_Munteanu> And use only stdin and stdout.
12:26:55 <syntaxglitch> sioraiocht, I think people are just messing with us at this point
12:26:56 <Twey> Eduard_Munteanu: There are still more cases you should check for if you're developing Serious Code
12:27:09 <Twey> Eduard_Munteanu: Like SIGPIPE
12:27:16 <sioraiocht> I actually don't thin there is a less obscure word for a paramorphism, though
12:27:22 <sshc> @let combinations :: (Integral a) => a -> [b] -> [[b]]; combinations 1 xs = map (:[]) xs; combinations k (x:xs) = (:) x . combinations (pred k) $ xs
12:27:23 <lambdabot>  <local>:5:51:
12:27:23 <lambdabot>      Occurs check: cannot construct the infinite type: b = [b]...
12:27:26 <Eduard_Munteanu> Twey, well it should die then, it's supposed to interface with xboard.
12:27:30 <sshc> hmm
12:27:30 <sioraiocht> can we just call a hylomorphism a "funfold"?
12:27:50 <bos> dons: the mystery deepens
12:28:05 <Twey> Also, console input is a particularly tricky case, because evaluation of a certain value causes execution to halt and prompt the user for input
12:28:10 <sshc> > map (:[]) [1..8]
12:28:10 <lambdabot>   [[1],[2],[3],[4],[5],[6],[7],[8]]
12:28:16 <Twey> You lose a lot of purity guarantees
12:28:21 <sshc> @let combinations :: (Integral a) => a -> [b] -> [[b]]; combinations 1 xs = map (:[]) xs; combinations k (x:xs) = (:) x . combinations (pred k) $ xs
12:28:22 <lambdabot>  <local>:5:51:
12:28:22 <lambdabot>      Occurs check: cannot construct the infinite type: b = [b]...
12:29:11 <Eduard_Munteanu> Twey, hm, it already works with both console and xboard. Xboard merely sends data like I would type commands on console.
12:29:12 <Cale> A metamorphism should be called a "crease"
12:29:24 <Cale> (fold, followed by unfold :)
12:29:28 <sshc> @let combination 1 xs = map (:[]) xs
12:29:29 <lambdabot>  Defined.
12:29:31 <Eduard_Munteanu> Twey, http://pastebin.org/81736
12:29:33 <sshc> :t combinations
12:29:34 <lambdabot> Not in scope: `combinations'
12:29:39 <sshc> @let combinations 1 xs = map (:[]) xs
12:29:40 <lambdabot>  Defined.
12:29:40 <sshc> :t combinations
12:29:41 <lambdabot> forall t a. (Num t) => t -> [a] -> [[a]]
12:29:51 <sioraiocht> Cale: genius
12:30:00 <Twey> Eduard_Munteanu: Well, of course it *works*
12:30:01 <sshc> @let combinations :: (Integral a) => a -> [b] -> [[b]]; combinations 1 xs = map (:[]) xs; combinations k (x:xs) = (:) x . combinations (pred k) $ xs
12:30:02 <Cale> So maybe by analogy with that, a hylomorphism is an uncrease?
12:30:03 <lambdabot>  <local>:7:51:
12:30:03 <lambdabot>      Multiple declarations of `L.combinations'
12:30:03 <lambdabot>      Declared a...
12:30:04 <Twey> That's not the issue :þ
12:30:06 <sioraiocht> Cale: then what about a hylomorphism? an iron? =p
12:30:08 <sshc> @undefine
12:30:10 <Cale> hehe
12:30:12 <sshc> @let combinations :: (Integral a) => a -> [b] -> [[b]]; combinations 1 xs = map (:[]) xs; combinations k (x:xs) = (:) x . combinations (pred k) $ xs
12:30:14 <lambdabot>  <local>:1:51:
12:30:14 <lambdabot>      Occurs check: cannot construct the infinite type: b = [b]...
12:30:28 <mreh> hmm, how can I work on files locally then synch them to a remote backup?
12:30:34 <sioraiocht> Cale: Next paper I write, I will make sure to establish these terms
12:30:36 <dmwit> sshc: You probably don't mean (x:) . in your second case.
12:30:50 <dmwit> sshc: Maybe you mean map (x:) ?
12:30:52 <Eduard_Munteanu> If I use interact, how do I do output?
12:30:57 <sioraiocht> Cale: I'm make sure to credit you for "crease
12:30:59 <sshc> dmwit: yes
12:31:02 <Eduard_Munteanu> Just return strings? :/
12:31:09 <dmwit> Eduard_Munteanu: Yup!
12:31:14 <sshc> @let combinations :: (Integral a) => a -> [b] -> [[b]]; combinations 1 xs = map (:[]) xs; combinations k (x:xs) = (x:) $ combinations (pred k) $ xs
12:31:15 <lambdabot>  <local>:1:51:
12:31:15 <lambdabot>      Occurs check: cannot construct the infinite type: b = [b]...
12:31:21 <sshc> @let combinations :: (Integral a) => a -> [b] -> [[b]]; combinations 1 xs = map (:[]) xs; combinations k (x:xs) = (:) x . combinations (pred k) $ xs
12:31:21 <lambdabot>  <local>:1:51:
12:31:22 <lambdabot>      Occurs check: cannot construct the infinite type: b = [b]...
12:31:24 <sshc> they're both the same
12:31:28 <dmwit> sshc: Needs more map.
12:31:32 <dmwit> sshc: In the second case.
12:31:46 <dmwit> (like I said ;-)
12:31:46 <Eduard_Munteanu> dmwit, um, so if I want to write "A\nB\n", I simply do return "A"; return "B" ?
12:31:55 <dmwit> Eduard_Munteanu: Hm?
12:31:56 <dmwit> No.
12:32:05 <dmwit> Eduard_Munteanu: If you just want to write that, you simply do
12:32:12 <dmwit> interact input = "A\nB\n"
12:32:13 <sioraiocht> Cale: I see you in ##linguistics, are you primarily a linguist or an FPer?
12:32:20 <Eduard_Munteanu> dmwit, then how do I interleave input with output?
12:32:38 <Eduard_Munteanu> dmwit, I figure my interact-called function should not return before finishing.
12:32:42 <Cale> sioraiocht: Primarily a mathematician, I think :)
12:32:54 <dmwit> Eduard_Munteanu: interact ('a':xs) = "A\n" ++ interact xs; interact ('b':xs) = "B\n" ++ interact xs
12:33:00 <sioraiocht> Cale: ah, what languages interest you?
12:33:01 <Cale> (and then functional programmer)
12:33:10 <dmwit> Eduard_Munteanu: (for example)
12:33:27 <Cale> Well, I'm learning Japanese.
12:33:28 <Taejo> jfredett_: you seem to have marked Paczesiowa with ++s in the HWN, but it says "Blog posts from people new to the Haskell community are marked with >>>"
12:33:28 <sshc> @let combinations :: (Integral a) => a -> [b] -> [[b]]; combinations 1 xs = map (:[]) xs; combinations k (x:xs) = (:) x $ map (combinations (pred k)) xs
12:33:30 <lambdabot>  <local>:1:51:
12:33:30 <lambdabot>      Occurs check: cannot construct the infinite type: b = [b]...
12:33:33 <sioraiocht> al, brilliant!
12:33:45 <sshc> I'm particularly confused
12:34:05 <Eduard_Munteanu> dmwit, oh, so I write my program as interact f, where f x = "something" ++ f (x + 1) in my case
12:34:18 <dmwit> ?let combinations 0 xs = [[]]; combinations k (x:xs) = map (x:) (combinations (k-1) xs)
12:34:19 <Eduard_Munteanu> dmwit, that's what I'm doing: http://pastebin.org/81736
12:34:20 <lambdabot>  Defined.
12:34:36 <dmwit> sshc: Like I said, you don't mean (x:), you mean map (x:).  Otherwise your code was right. =)
12:34:42 <copumpkin> > combinations 5 "abc"
12:34:43 <lambdabot>   * Exception: <local>:1:0-81: Non-exhaustive patterns in function combinations
12:34:46 <copumpkin> :P
12:34:50 * dmwit knows
12:34:57 <dmwit> I preserved sshc's bugs for him. =)
12:34:58 * copumpkin hrrmpfs
12:35:06 <copumpkin> > combinations 5 "abcdef"
12:35:07 <lambdabot>   ["abcde"]
12:35:15 <sshc> > combinations 3 "abcdef"
12:35:16 <lambdabot>   ["abc"]
12:35:19 <copumpkin> very nice
12:35:38 <sshc> that doesn't work as intended
12:35:41 <dmwit> Nope.
12:35:41 <copumpkin> > let combinations = (pure .) . take in combinations 3 "abcdef"
12:35:42 <lambdabot>   No instance for (GHC.Show.Show (f [GHC.Types.Char]))
12:35:42 <lambdabot>    arising from a use ...
12:35:46 <dmwit> But it's not a type error any more. =)
12:35:51 <copumpkin> ah well
12:36:13 <copumpkin> > let combinations :: Int -> [a] -> [[a]]; combinations = (pure .) . take in combinations 3 "abcdef"
12:36:13 <sshc> > combinations 2 "abc" -- should return ["ab", "ac", "bc"]
12:36:14 <lambdabot>   ["abc"]
12:36:14 <lambdabot>   ["ab"]
12:36:36 <Cale> sioraiocht: At first I came to #linguistics for some reason or another, and at some point I realised that nobody ever seemed to actually talk about linguistics there. Someone suggested ##linguistics, and it does seem more topical, but I've yet to actually participate in a conversation there. :)
12:37:13 <sioraiocht> Cale: haha, yes, well, linguistics conversations flow among everything else in #linguistics
12:37:14 <dmwit> Eduard_Munteanu: If you write your program as (interact f), then (f :: String -> String)... so I'm not sure what (f x = "something" ++ f (x+1)) would mean.  What is String addition?
12:37:46 <dmwit> Eduard_Munteanu: In any case, the idea of "interact" is that you send it a function; the input to that function is the contents of stdin, and the output of that function gets dumped to stdout.
12:37:50 <dmwit> Laziness takes care of the rest.
12:37:57 <Eduard_Munteanu> dmwit, concatenate additional output every time.
12:38:11 <dmwit> Eduard_Munteanu: What is ("abc" + 1)?
12:38:32 <Eduard_Munteanu> dmwit, no, x is a parameter, an integer.
12:38:40 <Ke> so how does one create cyclic data structures on haskell
12:38:41 <dmwit> Eduard_Munteanu: No, x is a parameter, a String.
12:39:09 <dmwit> ?wiki Tying the Knot
12:39:09 <lambdabot> http://www.haskell.org/haskellwiki/Tying_the_Knot
12:39:14 <Eduard_Munteanu> dmwit, oh right, say f :: Integer -> String -> String, and I do interact $ f 0
12:39:15 <dmwit> Ke: ^_^
12:39:27 <dmwit> Eduard_Munteanu: sure
12:39:50 <Ke> dmwit: thanks
12:40:56 <Cale> Ke: Well, that creates cyclic structures in memory, but they're not really the right thing for representing cyclic structures that you'll need to manipulate.
12:41:06 <djahandarie> I'm planning on writing a program that can interpret JavaDoc style documentation... would parsec be a good choice?
12:41:17 <pikhq> djahandarie: Yes.
12:41:30 <kmc> Ke, a very simple cyclic data structure is:  let x = 'z':x in x
12:41:33 <Cale> Ke: For example, to represent a directed graph, you might use something like Map Vertex (Set Vertex), or some variation thereof.
12:41:33 <kmc> > let x = 'z':x in x
12:41:34 <lambdabot>   "zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz...
12:41:52 <Cale> (something not really cyclic in memory, but much easier to work with)
12:42:00 <kmc> it's a single linked-list cell, whose "tail" field is a pointer to itself
12:42:45 <sioraiocht> Cale: it copies the 'z'?
12:42:58 <Cale> sioraiocht: kmc's example?
12:42:59 <pikhq> sioraiocht: No, there is only one 'z'.
12:43:10 <Cale> sioraiocht: There's only one cell, it just points at itself.
12:43:16 <pikhq> And there is only one linked-list cell.
12:43:28 <Cale> However, it's very easy to create a structure which is infinite by doing anything to that list.
12:43:34 <sioraiocht> Cale: oh, okay, you mentioned something not being cyclic, but you weren't referring to kmc's example
12:43:38 <Cale> ah
12:43:40 <Cale> yeah
12:44:04 <sioraiocht> was going to be surprised if it weren't
12:44:05 <Cale> I meant representing cyclic graphs using Map Vertex (Set Vertex)
12:44:08 <pikhq> It's pretty much equivalent to the following C code: struct list {char car;struct list *cdr;} x = {'z', &x};
12:44:12 <sioraiocht> Cale: indeed
12:44:45 <Cale> pikhq: Except that they're actually function pointers ;)
12:45:04 <pikhq> Cale: Well, yes.
12:45:07 <sioraiocht> C makes me cry
12:45:19 <sioraiocht> but not as much as C++
12:45:21 <sioraiocht> which makes me angry
12:45:31 <Cale> C++ is a horrible monster
12:45:32 <dmwit> ?hoogle delete
12:45:32 <lambdabot> Data.HashTable delete :: HashTable key val -> key -> IO ()
12:45:33 <lambdabot> Data.IntMap delete :: Key -> IntMap a -> IntMap a
12:45:33 <lambdabot> Data.IntSet delete :: Int -> IntSet -> IntSet
12:45:56 <Cale> C isn't fit for humans, but it's a moderately acceptable target language
12:46:27 <sioraiocht> Cale: haha, I consider it a necessary evil, and C++ an unnecessary one,
12:46:59 <syntaxglitch> C is rather nice as a more portable assembly
12:47:45 <Cale> Well, if you were designing a more portable assembly for use as a target language specifically, you probably wouldn't end up with C exactly.
12:47:50 <ddarius> -In typical implementations-, let zs = 'z':zs in zs allocates a single cell, but that is not guaranteed and I would not be surprised if it doesn't always happen in some implementations.
12:48:08 <sioraiocht> Cale: nowadays, no, you wouldn't.
12:48:23 <syntaxglitch> Cale, no, but C is good enough and I don't think platforms without C compilers exist
12:48:32 <gwern> @quote plot
12:48:32 <lambdabot> tensorpudding says: the Plot monad allow you to keep the story pure by containing all the glaring time travel silliness
12:48:35 <ddarius> syntaxglitch: Sure they do.
12:48:44 <gwern> @quote quickcheck
12:48:44 <lambdabot> dmwit says: Nobody quickcheck'd that @babel de en . @babel en de === id.
12:48:50 <gwern> @quote quickcheck
12:48:50 <lambdabot> dmwit says: Nobody quickcheck'd that @babel de en . @babel en de === id.
12:48:56 <sioraiocht> hahaha
12:48:58 <gwern> @quote quickcheck.*Web
12:48:58 <lambdabot> sproingie says: quickcheck myLanguage.hs --> "Web browser created after 285,731 tests"
12:49:07 <gwern> @quote voided
12:49:07 <lambdabot> lennart says: Even though I'm largely responsible for making CPP available in a Haskell compiler I think it's an abomination.  It should be avoided
12:49:18 <sioraiocht> hahaha
12:49:26 <gwern> well sure lennart but then how do we do platform-specific extensions?
12:49:37 <gwern> @quote UndecidableInstances
12:49:37 <lambdabot> RossPaterson says: I'm afraid you voided the warranty when you used UndecidableInstances.
12:49:44 <gwern> @quote substitute.*sleep
12:49:45 <lambdabot> aavogt says: strong static typing is not a substitute for sleep
12:49:59 * gwern nods. goes surprisingly far though
12:50:05 <gwern> @quote fixity
12:50:06 <lambdabot> tensorpudding says: fixity goes up to 11
12:50:18 <gwern> @quote Backwards.*written
12:50:18 <lambdabot> <temoto> says: Backwards written in as Forth?
12:50:32 <gwern> @quote and.*smilies
12:50:32 <lambdabot> Axman6 says: and smilies make code run faster
12:50:36 <gwern> @flish
12:50:48 <BenceF> how do i pattern match a list, which has only one element?
12:50:52 <sioraiocht> BenceF: [x]
12:50:53 <Botje> [x]
12:51:05 <sioraiocht> BenceF: or, (x:[]) if you want
12:51:34 <BenceF> ahh i just remembered i already asked it once here :D
12:51:35 <Cale> > let f [] = "empty"; f [x] = "only one"; f (x:xs) = "more than one if you get to here" in map f [[],[1],[1,2,3]]
12:51:37 <lambdabot>   ["empty","only one","more than one if you get to here"]
12:52:03 <sioraiocht> Nice example, heh
12:52:03 <Cale> You could also make that last pattern (x:y:xs) or something
12:52:09 <gwern> @remember bartek
12:52:10 <lambdabot> Incorrect arguments to quote
12:52:16 <Cale> (since you know there are at least two elements)
12:52:16 <gwern> @remember bartek It took me 2 years of studying teachings of Oleg Kiselyov (who was raised among types, where he learned to speak their language), but finally, I have the solution.
12:52:17 <lambdabot> I will remember.
12:52:18 <dmwit> > let f [] = "empty"; f [x] = "only one"; f (x:xs) = "more than one if you get to here" in map f (inits [1..])
12:52:19 <lambdabot>   ["empty","only one","more than one if you get to here","more than one if yo...
12:52:19 <BenceF> [a] confuses me, cause when used as a type it is a list of any number of elements
12:52:45 <kmc> right
12:52:54 <kmc> in Haskell, a type and a data constructor will often have the same name
12:53:03 <Cale> BenceF: Well, the mimickry of the value-level syntax at the type level only goes so far
12:53:32 <sioraiocht> data Confusing a = Confusing a
12:53:33 <sioraiocht> =p
12:53:39 <BenceF> but (a:[]) is pretty straightforward
12:53:43 <ddarius> sioraiocht: data Pair a b = Pair a b
12:53:51 <sioraiocht> @quote typeclasses
12:53:51 <lambdabot> No quotes match. BOB says:  You seem to have forgotten your passwd, enter another!
12:53:54 <sioraiocht> @quote typeclass
12:53:54 <lambdabot> No quotes match. There are some things that I just don't know.
12:53:57 <sioraiocht> damn
12:54:01 <sioraiocht> must have lost that quote
12:54:01 <Cale> BenceF: If it helps to know, you can also use [x,y] as a pattern which only matches lists of length 2
12:54:06 <ddarius> @quote type.classes
12:54:06 <lambdabot> cjeris says: wants ghc for wii. "Build and deploy an army of functional dependencies and multi-parameter type classes to defend Hyrule from the menacing MUTATRON and his legion of Java programmers!"
12:54:40 <BenceF> or (x:y:[])
12:54:43 <BenceF> now its clear
12:54:49 <nlogax> mutatron sounds more like a decepticon
12:54:49 <BenceF> i just got confused
12:55:56 <BenceF> empty list is my friend. thats what i gotta remember
12:56:13 <gwern> @flish
13:04:22 <BenceF> primetime films ended in west europe :D
13:04:56 <BenceF> no they just starting. then i dont get it
13:30:19 <benbc> I'd like to share some code. hpaste.org seems to have evaporated. What are people here using instead?
13:30:42 <Twey> moonpatio.com exists
13:30:43 <dmwit> codepad, maybe?
13:30:54 <ddarius> @where paste
13:30:54 <lambdabot> http://hpaste.org/new
13:30:58 <ddarius> @where hpaste
13:30:59 <lambdabot> http://hpaste.org http://moonpatio.com/fastcgi/hpaste.fcgi/
13:31:39 <BONUS> http://moonpatio.com/fastcgi/hpaste.fcgi/ ftw
13:32:24 <copumpkin> doesn't bos own hpaste.org?
13:32:33 <copumpkin> or maybe "didn't bos own hpaste.org?"
13:32:45 <copumpkin> looks like someone snapped it up
13:34:20 <dmwit> I believe bos is aware of the situation.
13:34:46 <copumpkin> I'm sure he is, I was just wondering what the situation actually was.
13:40:25 <bos> copumpkin: i renewed it, but it might take a little while for the DNS update to propagate
13:40:34 <copumpkin> ah, cool :)
13:42:02 <dmwit> Would you like others to pitch in?
13:43:02 <copumpkin> I'd definitely be willing to :)
13:43:28 <monochrom> Oh heh, hpaste.org resolves right for me now.
13:43:38 <copumpkin> same here
13:44:20 <dmwit> So, if I started a prelude package (with a new Prelude.*) hierarchy on Hackage, would other people submit theirs?
13:44:31 <dmwit> I mean, I know everybody has a file full of stuff that they import for one-offs...
13:45:00 <benbc> I've impleneted Kadane's algorithm for the maximum subarray problem (http://en.wikipedia.org/wiki/Maximum_subarray_problem). I used a wrapper type for lists so that I could hide the memoizing that is needed to keep the solution linear (http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=6471). None of this is terribly interesting. But I have a (probably trivial) question about the type declarations. Without any declarat
13:45:01 <benbc> ions GHCI types maxSubSequence as [Integer] -> [Integer]. That looks unnecessarily restrictive to me (I put 'fromInteger' into the definition of 'empty' to try to make it more permissive). But in order to get GHCI to accept maxSubSequence :: (Num a, Ord a) => [a] -> [a], I have to put a declaration on 'empty' too. Can anyone explain what is going on here? (Comments on the solution/style gratefullly received as well.)
13:45:31 <dmwit> ?wiki monomorphism restriction
13:45:31 <lambdabot> http://www.haskell.org/haskellwiki/monomorphism_restriction
13:45:42 <dmwit> benbc: All is explained there.
13:46:56 <monochrom> benbc: fromIntegral 0
13:47:05 <dmwit> benbc: As for style, it seems mostly fine.
13:47:09 <Cale> benbc: I usually just end up turning off the MR when it does things like this. (In fact, I have :set -XNoMonomorphismRestriction in my .ghci so at least it won't bother me at that point.)
13:47:26 <dmwit> benbc: But there is an important efficiency issue:
13:47:28 <monochrom> @type fromIntegral 0
13:47:30 <lambdabot> forall b. (Num b) => b
13:47:57 <Cale> Right, if you have constants that you don't want being recomputed, you must make them monomorphic
13:47:58 <dmwit> benbc: You should use (x:xs) instead of (xs ++ [x]), then let (toList (Sequence xs) = reverse xs).
13:48:01 <monochrom> @type fromInteger
13:48:02 <lambdabot> forall a. (Num a) => Integer -> a
13:48:26 <monochrom> Hrm, perhaps fromInteger doesn't cause a problem.
13:48:29 <dmwit> :t 0 -- no from* needed
13:48:29 <lambdabot> forall t. (Num t) => t
13:49:17 <dmwit> benbc: (xs ++ ys) is O(n) in n the length of xs, so your algorithm is probably quadratic. =)
13:51:19 <Twey> What does Marlow's ‘Wander through the New IO Library’ mean when it says that on Windows, FilePath = String, but on UNIX, FilePath = Word8?
13:51:33 <Heffalump> I imagine it means [Word8]
13:51:39 <Twey> Er, [Word8], sorry, yes
13:51:46 <Twey> UNIX file paths can be Unicode, though, surely
13:51:46 <Heffalump> i.e. on Windows you can have unicode characters in filenames, but not on UNIX
13:51:50 <Twey> But you can
13:52:01 <Heffalump> how? (without encoding)
13:52:06 * Cale has quite a few UTF-8 encoded filenames.
13:52:14 <Twey> So do I…
13:52:21 <Twey> What do you mean by ‘without encoding’?
13:52:21 <Heffalump> I imagine the point is that the native format is different
13:52:31 <Twey> It's UTF-16 in both, I believe
13:52:32 <gwern> hm. I have an old PDF that makes evince segfault. I think that's probably a bug
13:52:42 <Twey> At least for Linux
13:52:56 <Cale> gwern: try gv
13:53:01 <gwern> ah, xpdf reads it
13:53:18 <gwern> oh, it's my old copy of the los alamos report on whether nukes could ignite the global atmosphere
13:53:38 <Twey> Two very common encodings are UTF-16 and UTF-8. In UTF-16, which is used by modern Microsoft Windows systems, each character is represented as one or two 16-bit (two-byte) words. Unix-like operating systems, including Linux, use another encoding scheme, called UTF-8, where each Unicode character is represented as one or more bytes (up to four; an older version of the standard allowed up to six).
13:53:40 <Heffalump> ok, I'm not sure what the situation is then. I had assumed that filenames on UNIX were always lists of 8 bit chars, whereas on Windows they would be lists of 16 bit chars.
13:53:44 <Twey> — http://hektor.umcs.lublin.pl/~mikosmul/computing/articles/linux-unicode.html
13:53:59 <Twey> But you can definitely write Unicode filenames, whatever they're represented as internally
13:54:10 <Heffalump> Twey: that doesn't say what the default interpretation of the disk's filenames is
13:54:15 <olsner> ah, I've read that one (pdf about atmosphere ignition), it was slightly over my head physics-wise
13:54:18 <Heffalump> I assume it's just a different convention
13:54:22 <Twey> Heffalump: Depends how you define ‘default’
13:54:32 <Twey> I guess ‘default’ would be C, but nobody uses that nowadays
13:54:34 <Heffalump> "generally agreed"
13:54:38 <copumpkin> can I see equivalence mod n as a ternary relation?
13:54:46 <Twey> I think the most common locale encoding is UTF-8
13:54:50 <tensorpudding> not every os avoids using C as the default locale
13:54:55 <copumpkin> I guess pretty obviously yes
13:54:58 <olsner> afaik, linux filenames are in the current locale, whatever that is
13:55:00 <copumpkin> (for a non-fixed n, that is)
13:55:16 <Twey> olsner: Yeah, I figure so on reflection
13:55:27 <Twey> tensorpudding: All the widely used ones do
13:55:33 <Twey> (no?)
13:56:18 <monochrom> > foldl1 max (scanl (\a b -> max (a+b) 0) 0 [-2, 1, -3, 4, -1, 2, 1, -5, 4])
13:56:19 <lambdabot>   6
13:58:33 <monochrom> Windows since 2000 uses utf-16 in NTFS. But I don't know what the API exposes.
13:59:03 <Twey> UTF-16
13:59:18 <benbc> dmwit: Cale: thank you
13:59:34 <Twey> Oh, but it's set by default to use codepages
14:00:26 <ddarius> copumpkin: Obviously yes.
14:00:36 <copumpkin> okay :)
14:00:39 <ddarius> copumpkin: Any boolean function can be viewed as a relation.
14:00:40 <adekoba> is there a haskell equivalent of GetTickTime from windows?
14:00:44 <copumpkin> ddarius: yeah
14:00:47 <copumpkin> are there any common quaternary relations?
14:01:02 <copumpkin> I'm trying to think of n-ary relations for n higher than 2
14:01:38 <ddarius> copumpkin: One way of constructing the rationals is to quotient pairs of pairs by an equivalence relation.
14:02:20 <copumpkin> oh, so ((1,2),(2,4)) = (1,2,2,4) would be a quaternary relation of rationals?
14:02:23 <ddarius> copumpkin: Any predicate in Prolog or most tables in a (relational) database can be viewed as relations.
14:02:24 <CalJohn> adekoba: what is GetTickTime?
14:02:37 <adekoba> returns the amount of time since the program has started
14:02:55 <ddarius> copumpkin: It could be viewed as quaternary, but then it could also be viewed as a binary relation between pairs.
14:03:06 <copumpkin> ddarius: yeah, I see
14:04:14 <adekoba> also, is there a way to convert between DiffTime and NominalDiffTime in Data.Time?
14:04:23 <ddarius> copumpkin: A lot of type theory judgements also would count as usually binary/ternary/quaternary relations.
14:04:36 <copumpkin> ddarius: oh, that makes sense
14:04:37 <CalJohn> adekoba: apparently the only function of type IO UTCTime is getCurrentTime, so I think there isn't
14:04:42 <CalJohn> http://www.haskell.org/hoogle/?hoogle=%3A%3A+IO+UTCTime
14:05:00 <ddarius> E.g.  Γ ⊢ e : τ is ternary
14:05:40 <ddarius> copumpkin: Similarly for big-step semantics.
14:05:48 <copumpkin> haven't come across that
14:10:56 <dmwit> adekoba: System.CPUTime.getCPUTime?
14:11:59 <dmwit> adekoba: Also, the API would be pretty broken if it allowed conversions between DiffTime and NominalDiffTime, as they're quite different.
14:12:34 <adekoba> yes I see know
14:12:51 <adekoba> getCPUTime will work, thanks
14:16:49 <cadr> Can someone look at some code I wrote?  I had a question about it.
14:16:55 <cadr> I was doing Question 4 from http://www.md.chalmers.se/~rjmh/Combinators/fingers.html
14:17:10 <cadr> And I have something that works, but I'm not very satisfied with it
14:17:29 <cadr> I put it up at http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16479
14:19:44 <cadr> I don't feel like I should need the newIORef in there
14:20:06 <aavogt> that's not very idiomatic haskell
14:20:27 <dmwit> The assignment isn't very idiomatic.
14:20:49 <dmwit> Also, yes, the standard in-place reverse does not allocate new cells.
14:20:59 <dmwit> You may have to think a little harder. =)
14:21:12 <cadr> I've been thinking pretty hard to get this far :)
14:21:21 <dmwit> Have you done this task in other languages?
14:21:35 <cadr> At some point
14:22:03 <dmwit> Right.  So, you should use the same algorithm here.
14:24:13 <cadr> So, what I want to do is change the second part of each cell to point to the previous cell.  Which I think I'm doing.  But I need to hold on to the value of the point and pass that into the next iteration.
14:24:24 <cadr> But somehow I am finding that very hard to get right
14:24:36 <mauke> btw, I'd define an alias for IORef (RList a)
14:24:41 <mauke> just to reduce typing
14:25:57 <mauke> ... why does revR return a list?
14:27:14 <cadr> revR is what was in the assignment
14:27:21 <mauke> this makes no sense
14:27:26 <mauke> xs' shouldn't even exist
14:27:33 <mauke> not your xs', the one in test
14:28:26 <mauke> revHelper :: RList a -> RX a -> IO ()
14:28:38 <RayNbow> hmm... the solution to http://www.haskell.org/haskellwiki/Euler_problems/1_to_10#Problem_8 doesn't necessarily give the right solution for all 1000-digit numbers
14:28:48 <mauke> ah, wait
14:29:09 <mauke> cadr: sorry, I'm wrong :-)
14:29:56 <cadr> mauke: no worries :)
14:30:10 <RayNbow> for example, if the input number has the form 10000[...]000001, then the function problem_8 will return 1, instead of the correct answer 0
14:30:32 <RayNbow> ah crap
14:30:43 <cadr> dmwit: so, I take it from your statement that I'm *not* doing the same algorithm?
14:30:43 * RayNbow notices this has already been discussed on the Talk page :p
14:32:05 <ddarius> cadr: You shouldn't be making any new IORefs, not making new IORefs is what makes it in-place.  Your solution doesn't meet the specification because it is not in-place.
14:32:24 <ddarius> cadr: Instead of allocating new IORefs, simply modify the existing ones.
14:33:42 <mauke> I'm tempted to prototype this in C
14:33:44 <cadr> ddarius: I was trying that, but I kept getting stuck as to what to pass back into revHelper when I recurse
14:34:04 <cadr> mauke: Yeah, I don't have any problems with it in C
14:34:26 <ddarius> mauke: It's just as easy to do in Haskell.
14:34:37 <mauke> yes, but harder to think about
14:34:37 <ddarius> mauke: Easier in some respects, but noisier in others.
14:34:50 <mauke> I confuse myself with levels of indirection, etc
14:35:05 <ddarius> mauke: I'd say it is easier in some respects to think about because it is more explicit about levels of indirection and what can and can't change.
14:35:24 <mauke> that's what makes it harder
14:35:26 <ddarius> Admittedly, for C, it is still pretty explicit.
14:36:07 <mauke> haskell values are implicit pointers
14:36:11 <cadr> ddarius: so, I do "writeIORef xs' prev" to update the second part of the current cons to point to the previous RList
14:36:17 <ddarius> mauke: Which is irrelevant for this.
14:36:20 <mauke> nope
14:36:23 <mauke> it's essential
14:36:28 <ddarius> mauke: You can treat all Haskell values as straight values.
14:37:06 <monochrom> cadr: Good, but before that, you should readIORef xs' because you could use its old value later.
14:37:08 <mauke> that would lead to code like *p->next = *prev;
14:37:13 <mauke> which you'd never do in C
14:37:46 <cadr> monochrom: which I do:  ys <- readIORef xs'
14:38:06 <cadr> monochrom: but ys isn't a pointer then, its the value at the pointer
14:38:20 <ddarius> mauke: I would find it exactly as easy conceptually to write this program in Haskell or C with the only difference being the handling of Nil.
14:38:20 <cadr> monochrom: and when I recurse, I need the pointer...
14:38:31 <mauke> ddarius: in fact, I think *p->next = *prev; is exactly what's confusing me
14:38:48 <ddarius> mauke: In Haskell and in C the types lead you right.
14:38:49 <monochrom> I personally don't like the sig RList a -> IORef (RList a) -> IO (IORef (RList a)). I prefer RList a -> RList a -> RList a
14:39:01 <monochrom> err, RList a -> RList a -> IO (RList a)
14:39:17 <ddarius> I would use IORef (RList a) -> IORef (RList a) -> IO (IORef RList a)
14:39:21 <mauke> monochrom: no, that's too much like lisp
14:39:39 <cadr> ddarius: which is what I originally did
14:39:58 <cadr> ddarius: but the initial value for 'prev' was giving me problems
14:40:16 <cadr> ddarius: as it really ought to be a pointer to Nil
14:40:23 <ddarius> cadr: Nope.
14:40:24 <mauke> ah, screw it, I'm just going to pretend IORef (RList a) is a struct node **
14:40:31 <ddarius> Nil is not the previous node.
14:40:43 <ddarius> cadr: What is the previous node at the beginning?
14:40:56 <cadr> Nothing?
14:41:07 <ddarius> cadr: Yes (as long as you don't mean Nothing :: Maybe a)
14:41:22 <ddarius> cadr: You don't have a previous element until you look at at least one Cons.
14:42:03 <sshc> is it possible to declare special syntax similar to []?
14:42:04 <ddarius> So do the outer function by cases: revR <ioref holding Nil> = ?; revR <ioref holding Cons x xs> = ?
14:42:07 <mauke> sshc: no
14:42:41 <tensorpudding> can you create a type with an infix constructor?
14:42:47 <ddarius> tensorpudding: Sure.
14:42:48 <mauke> tensorpudding: yes
14:42:56 <ddarius> @src Complex
14:42:56 <lambdabot> data (RealFloat a) => Complex a = !a :+ !a
14:43:03 <cadr> ddarius: ok, but when I'm done, what was previously the first element would have it's cdr pointing to Nil, right?
14:43:12 <tensorpudding> hmm
14:43:38 <ddarius> cadr: You may not even have a first element.
14:47:39 <cadr> ddarius: (Thinking)
14:50:19 <mauke> monochrom: I think I've found your solution
14:51:39 <monochrom> Yes, it is like that.
14:54:05 <HaskellLove> Does Lift in Haskell has anything to do with CT?
14:54:21 <HaskellLove> the choice, or lifting problem
14:54:35 <monochrom> Which Lift? In which module? More context?
14:55:29 <HaskellLove> well any, all i know is there are Lift functions in Haskell...
14:55:39 <HaskellLove> never used them or understand the manual
14:55:42 <HaskellLove> about them
14:56:12 <monochrom> Insufficient data for a meaningful answer. Thank you.
14:56:17 <tensorpudding> @src liftM
14:56:18 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
14:56:28 <tensorpudding> eh
14:57:05 <tensorpudding> pretty sure liftM is just fmap
14:57:12 <monochrom> Yes.
14:57:27 <PeakerWork> @type [liftM, fmap]
14:57:28 <lambdabot> forall a1 r (m :: * -> *). (Monad m, Functor m) => [(a1 -> r) -> m a1 -> m r]
14:57:31 <Paczesiowa> snoyberg: are you here?
14:57:55 <tensorpudding> and the higher liftM* functions are analogous
14:58:14 <PeakerWork> HaskellLove: there's liftA* and liftM* (which are the same), and there's monad transformers' lift, and perhaps others
14:58:53 <aavogt> liftIO
14:59:23 <HaskellLove> you see i tried to understand the Lift commands and now i study them in CT and get back to the Haskell ones and try to get them, that is why i did not supply enough info and asked such general question
14:59:27 <PeakerWork> liftIO, liftState, etc are monad transformers' generalized lifts -- though I dislike them...
15:00:21 <ddarius> cadr: I guess your solution is fine enough actually.
15:00:24 <mauke> there's a liftState?
15:00:33 <HaskellLove> my question is, i guess, is there some general LIFT concept?
15:00:42 <HaskellLove> or just meaningless use of the word here and there
15:01:26 <HaskellLove> for example, x+4=10, finding x is a lifting problem
15:01:38 <ddarius> HaskellLove: Yes, there is a general meaning to the word "lift," namely it's English meaning.
15:01:58 <ddarius> HaskellLove: I've never heard "lifting problem" used for that.
15:02:01 <tensorpudding> what is a lifting problem exactly
15:02:06 <cadr> ddarius: What you were saying before...  if I call revR with an <ioref holding Nil>, I can just 'return' my input
15:02:14 <ddarius> cadr: Yep.
15:02:25 <Zao> HaskellLove: Grab the expression tree by the x, lift it up and see what dangles below?
15:02:47 <cadr> ddarius: ok, just had a thought
15:03:18 <mauke> wow, I'm having serious trouble doing this in terms of IORef (RList a)
15:03:31 <ddarius> cadr: You are going to need the newIORef call in your Cons case, it corresponds to list *tmp = current->next in C.
15:03:37 <HaskellLove> Zap u sound close like what i want, more explanation please so i am sure what u mean
15:03:39 <HaskellLove> http://img34.imageshack.us/img34/3918/screenshotic.png
15:03:58 <HaskellLove> Zao, not Zap, sorry
15:04:18 <cadr> ddarius: wait, so I *do* need a newIORef?
15:04:22 <Zao> HaskellLove: That was my interpretation of your statement.
15:04:33 <ddarius> HaskellLove: I'm pretty sure that is in the context of cartesian categories.
15:04:56 <HaskellLove> yes
15:05:09 <ddarius> (And is incidentally not (obviously) related to any of the uses of the word "lift" in Haskell function identifiers.)
15:05:20 <ddarius> HaskellLove: Context like that is important for people to understand you.
15:05:35 <Zao> I can't see how one would draw a parallel between a trivial equation and how to decompose functions.
15:05:43 <ddarius> HaskellLove: Even the little image you provided doesn't give that context.
15:05:52 <Zao> I call hogwash.
15:05:54 <HaskellLove> yeah but i thought there is this concept of LIFTING, like the concept of MAPPING so i thought no context is needed
15:05:56 <ddarius> Zao: It's more than that.
15:06:04 <tensorpudding> this lift is probably unrelated, as far as i can tell
15:06:24 <ddarius> Zao: But you can't get that from the image.
15:06:43 <HaskellLove> ok enough, tnx guys i go back to the book
15:06:46 <ddarius> Zao: (By "that" I mean "decomposing functions")
15:07:23 <ddarius> Zao: There's a reason why the f? arrow is dashed and has that ? appended to the name.
15:07:28 <Loriel> My functions seem to decompose on their own if I am not careful where I put them
15:08:32 <ddarius> cadr: You can avoid some, but yes, the natural thing is to use a newIORef in the Cons case, though you could do it another way, but it would just move the data around to somewhere else.
15:08:41 <tensorpudding> i thought that lifting in haskell referred to transforming functions by a functor into functions in the image category
15:08:54 <Zao> ddarius: As my only excursions into functions is a chapter in an introductory course in discrete mathematics, I have not the faintest.
15:09:05 <PeakerWork> tensorpudding: that's one sense. There's also the monad-transformer sense. And the new-bottom-in-product-types-sense, and more
15:09:18 <tensorpudding> i've not gotten to monad transformers
15:09:20 <ddarius> tensorpudding: "lifting" is used in a loose sense in Haskell and many areas of mathematics.  If a precise sense is intended it will (in published works at least) be specified.
15:09:23 <cadr> ddarius: It really seems like you shouldn't have to use *any* newIORefs
15:09:40 <HaskellLove> ddarius that is the answer i needed tnx
15:11:12 <ddarius> tensorpudding: The usual idea behind the use of the word "lifting" is we view some things (e.g. monadic values) as "hovering above" other things (regular values) and fmap(=liftM), in this example, "raises" the "lower" things up to the level of the "higher" things.
15:11:20 <tensorpudding> hmm, but lots of problems in CT are similar to that one it seems
15:12:28 <ddarius> tensorpudding: This is the same visual metaphor used for Cartesian categories where we thing of the elements in the fiber categories as hovering over the base categories and the "lifting problem" for cartesian categories is how to canonically choose an arrow "above" a given base arrow.
15:12:34 <DigitalKiwi> when I think of lifting I think of bras, not Haskell or maths, does this mean I am not a geek? :(
15:12:54 <ddarius> tensorpudding: For monad transformers, we view lifting a given monad into transformed monads.
15:13:08 <tensorpudding> i don't know enough category theory to understand that
15:13:26 <mauke> <+ddarius> I would use IORef (RList a) -> IORef (RList a) -> IO (IORef RList a)  <-- can you show me that solution?
15:14:19 <ddarius> mauke: I've since changed my mind or rather don't really think it makes too much of a difference.
15:14:37 <mauke> ok, then I'm not going completely crazy
15:15:08 <ddarius> tensorpudding: The idea is that the common part of the terminology of "lifting" is this visual metaphor and not some all-encompassing concept.
15:16:17 <mauke> cadr: I have a solution with no newIORefs, want to see it?
15:16:35 <cadr> mauke: so you *can* do it with no newIORefs?
15:16:38 <mauke> yes
15:16:43 <cadr> mauke: that makes me feel better
15:16:45 <cadr> :)
15:17:08 <cadr> is the signature for your helper method  RList a -> IORef (RList a) -> IO (IORef (RList a))
15:17:13 <mauke> no
15:17:28 <ddarius> cadr: I said it was possible to do it without.
15:17:40 <cadr> ddarius: oh, sorry, I missed that update
15:17:40 <monochrom> This is like "simple group" and "simple graph" being unrelated.
15:18:48 <monochrom> Or "haskell module" and "finitely generated noetherian module"
15:19:18 <tensorpudding> a basis of fact and a basis of vectors
15:19:28 <cadr> mauke: yeah, I guess.  (I mean, no, but the wife is telling me I need to go to the store soon...)
15:19:30 <sshc> is there a null or undefined type defined in the standard library?
15:19:42 <mauke> sshc: data () = ()
15:19:53 <c_wraith> sshc: do you want Maybe?
15:19:58 <sshc> () was it
15:20:08 <mauke> cadr: http://codepad.org/fnDMqyuw
15:20:08 <c_wraith> Oh, you want more like void.
15:23:34 <cadr> mauke: ok, cool.  This is what I was trying to do, but because I had my type signature on the helper like it was, I had to make a new ioref to recurse...
15:24:42 <cadr> ddarius, mauke - thanks for the help.
15:26:59 <HaskellLove> how do you make difference what is a choice and what a determination problem in CT?
15:29:02 <ddarius> HaskellLove: Once again no one knows what you are talking about because you have provided no context.
15:29:41 <HaskellLove> hmm well when i say the bla bla problem people usualy know, CT seems complicated... ok let me get it
15:30:55 <HaskellLove> http://img132.imageshack.us/img132/6546/screenshot1js.png
15:33:30 <Axman6> HaskellLove:  i thought you were learning haskell
15:33:45 <HaskellLove> CT is haskell man ;O
15:34:15 <kmc> HaskellLove, why are you sending us an answer to your own question?
15:34:38 <tensorpudding> these two problems are sometimes dual
15:34:38 <mreh> ghc handles unicode right?
15:34:40 <HaskellLove> i wish i was
15:34:45 <copumpkin> mreh: yep
15:35:05 <ddarius> HaskellLove: That paragraph defines both of the terms.
15:35:07 <mreh> I can't get the input working on my laptop thought :D~~~
15:35:12 <tensorpudding> for example, products and coproducts are usually defined by the unique arrows that factor through them
15:36:07 <tensorpudding> with diagrams that are roughly the same
15:36:15 <mreh> ctrl+shift+0233 nothing happens
15:36:59 <copumpkin> sounds like an input method problem, not something with ghc :)
15:37:38 <mreh> i'm asking in ##linux
15:37:54 <HaskellLove> so i am suposed to remember determination as given a composed function h = g . f, finding all g when h and f are given... and choose problem as finding  all f?
15:38:12 <tensorpudding> for example, the coproduct of a family of sets A_n is an object A, together with a collection of inclusion maps i_n that take A_n to A, such that for every map f : A_n -> B, there is a unique map g : A -> B such that g . i_n = f
15:38:54 <ddarius> HaskellLove: What book is this?
15:39:04 <xerox> (I wonder why coproduct and not direct sum, aren't they the same thing?)
15:39:06 <HaskellLove> Conceptual mathematics
15:39:17 <copumpkin> yay, new version of MPS on hackage :)
15:39:30 <ddarius> HaskellLove: I guess.  That terminology is not used elsewhere to my knowledge.
15:39:36 <jlouis> xerox: IIRC the DS is a CP in most cases
15:40:13 <tensorpudding> err, that should have been "family of objects"
15:40:15 <jlouis> xerox: but Mac Lane is currently the Toilet reading... I can fetch it and check if you need it :)
15:40:50 <ddarius> Many times a relevant notion of "direct sum" is the coproduct for the relevant category.
15:40:57 <xerox> jlouis wow my toilet reading is Sets for Mathematics
15:41:12 <ddarius> But then coproducts don't need to be anything like direct sums.
15:41:12 <tensorpudding> Mac Lane is good for keeping your bowels commutative
15:41:48 <ddarius> (But arguably, products don't need to be anything like cartesian products.)
15:42:24 <ddarius> xerox: Just "sum" is often used for coproduct.
15:42:37 <tensorpudding> monics and epis don't have to be like injective or surjective functions either
15:42:46 <Axman6> HaskellLove: if CT is haskell, how come i know no CT, and have been using haskell happily for 2 years now?
15:43:02 <tensorpudding> Axman6: you've been living in denial obviously
15:43:03 <ddarius> tensorpudding: Yes but we don't say "injective and coinjective".
15:43:03 <HaskellLove> Axman6 you are doing it on the syntax level only
15:43:10 <xerox> ddarius perfect.
15:43:19 <Axman6> HaskellLove: well, no, i'm not
15:43:39 <copumpkin> cosum = product!
15:44:00 <Axman6> CT is not something you need to know to use haskell well. there's a hell of a lot of people who know no CT and are doing some very impressive things in haskell
15:44:32 <HaskellLove> Axman6 I am talking about Haskell ninjas here
15:44:50 <mauke> HaskellLove: no, you said "syntax level only"
15:44:50 <ddarius> Axman6: I recommend terminating the conversation immediately.
15:44:53 <Philonous> Obviously, Axman6 is more of a Pirate
15:45:00 <Axman6> no, you're talking about people who know CT
15:45:01 <mreh> Axman6: ooh, like what?
15:45:02 <jlouis> Arrr
15:45:14 <mauke> HaskellLove: it doesn't require a ninja to go below the syntax level
15:45:15 <Axman6> Philonous: yarr
15:45:25 <Axman6> mreh: hmm?
15:45:28 <kmc> oh for fuck's sake
15:45:32 <mreh> Axman6: impressive things
15:45:42 <mreh> i like hearing about haskell impressive things
15:45:54 <Axman6> oh, i can't _name_ any, but i'd say it's a pretty safe assumption
15:46:00 <Axman6> :P
15:46:16 <ddarius> Well different things are impressive to different folks.
15:46:17 <copumpkin> kmc: FIGHT!
15:46:22 <Axman6> jlouis: you know much/any CT and are you using it in haskell-torrent?
15:46:44 <CoqLove> mmm, I love me some coq
15:47:13 <mauke> I invented the reverse-state monad
15:47:39 <Axman6> did you use CT to do it?
15:47:43 <mauke> no
15:47:50 <mauke> I don't know any CT
15:47:53 <copumpkin> I thought mauke thought CT was bs
15:47:53 <jlouis> Axman6: I've had a couple of courses in it, but I read it because I also like algebraic topology, not for haskell
15:47:53 <Axman6> well you're not a ninja then
15:47:58 <copumpkin> clearly not
15:48:06 <Philonous> mauke: You reversed the arrow in (State, a) -> (State,  b) ?
15:48:21 <ddarius> Philonous: That would not really accomplish much...
15:48:22 <mauke> Philonous: huh?
15:48:40 <mauke> mreh: does http://mauke.ath.cx/stuff/haskell/hell.hs count as impressive?
15:48:53 <copumpkin> cute :)
15:48:59 <copumpkin> mmorrow had something similar
15:48:59 <jlouis> mauke: I don't know about the rev-state monad... does it have an one-line explanation?
15:49:05 <ddarius> mauke: No, I used to do that in QBASIC 13 years ago.
15:49:14 <olsner> jlouis: state - backwards!
15:49:18 <xerox> :O
15:49:20 <copumpkin> does my ascending code count as impressive? :O
15:49:36 <ddarius> jlouis: A one page explanation is in "The essence of functional programming"
15:49:37 <mauke> ddarius: hah, 13 years ago I didn't even have a computer
15:49:38 <mreh> mauke: I don't know
15:49:41 * xerox launches backspaces at copumpkin 
15:49:42 <dolio> You got that from in IOCCC entry I showed you. :)
15:49:58 <mauke> what, me?
15:50:05 <dolio> I thought so.
15:50:22 <jlouis> ddarius: Wadler, 92?
15:50:26 <ddarius> jlouis: Yes.
15:50:33 <ddarius> jlouis: A good paper.
15:50:48 <dolio> Of course, figuring out how to do it in Haskell (GHC) is certainly something.
15:51:02 <ddarius> dolio: Looks much easier than doing it in QBASIC.
15:51:22 <dolio> One more point for Haskell, then!
15:51:28 * copumpkin shows everyone how long his e-penis is
15:51:33 * dolio disappears.
15:51:40 <copumpkin> damn, I scared him
15:51:40 <mauke> I couldn't find a way to do it in ocaml
15:52:14 <jlouis> ddarius: ah yes, neat
15:52:30 <ddarius> I do appear to still have an ocaml implementation on my computer.
15:52:34 <mauke> I like figuring out how to run native machine code in a language
15:52:41 <jlouis> ddarius: I actually read that one a couple of years ago. Somehow that did not glue to the brain
15:52:46 <ddarius> (Unfortunately, it stopped being able to run LolliMon which is the only reason I had it.)
15:53:02 <mauke> the ultimate inspiration was probably mullender.c, but I've known that long before hearing about haskell
15:53:13 <xerox> ddarius didn't QBASIC have inline asm syntax
15:53:24 <xerox> ddarius I might be confusing with pascal, fuzzy memories
15:53:25 <ddarius> xerox: No, at least not the version I used.
15:53:27 <mauke> and mullender.c is total hax in that it's only data, no code
15:53:50 <ddarius> xerox: It did have something specifically for calling machine code, but you still had to poke bytes into an array by hand.
15:54:17 <tensorpudding> bytestrings, lovingly rolled by hand
15:54:27 <mreh>  typing unicode digits into gedit just moves my cursor around
15:54:30 <mreh> numlock is on
15:54:51 <xerox> tensorpudding someone should take an old cigarette ad and put ByteStrings on it
15:55:15 <tensorpudding> "this bytestring is the cuban cigar of bytestrings"
15:55:36 <damd> morally questionable?
15:55:52 <tensorpudding> are cuban cigars morally questionable?
15:56:08 <damd> well, not to me :)
15:56:08 <copumpkin> not smoking them is
15:56:46 <tensorpudding> they may be embargoed
15:57:15 <interferon> is there a standard function that will return a list without its final item
15:57:22 <kmc> > init "abcde"
15:57:23 <lambdabot>   "abcd"
15:57:25 <kmc> > init ""
15:57:26 <interferon> nice
15:57:26 <lambdabot>   "* Exception: Prelude.init: empty list
15:57:27 <interferon> thanks
15:57:31 <ddarius> I would recommend against using it too much.
15:57:32 <kmc> unsafe just as "head" is
15:57:48 <interferon> how do people normally handle that unsafeness?
15:58:04 <ddarius> interferon: If removing things from the end of a list is something you want to do a lot of, use a more appropriate data structure e.g. Data.Sequence.Seq
15:58:05 <kmc> don't use it unless you can prove the list is non-empty
15:58:06 <pikhq> interferon: ... They confirm that they don't pass an empty list to it.
15:58:07 <damd> using dependent types
15:58:09 <kmc> if it could be empty, pattern-match first
15:58:12 <tensorpudding> head is unsafe, but can be made safer by initially wrapping in latex^H^HMaybe
15:58:21 <interferon> dependent types
15:58:25 <interferon> ?
15:58:26 <monochrom> interferon: I prove that I use it properly.
15:59:01 <pikhq> interferon: Dependent types in some other languages are types that are dependent upon some other expression.
15:59:11 <interferon> but not in haskell?
15:59:14 <ddarius> Types that depend on values.
15:59:21 <kmc> haskell doesn't have them
15:59:22 <pikhq> Dependent types do not exist in Haskell.
15:59:28 <copumpkin> (also, they aren't free)
15:59:38 <PeakerWork> copumpkin: what do they cost?
15:59:46 <kmc> $1.05
15:59:50 <copumpkin> a lot of people seem to think that you can just add dependent types to a language and you've solved all your problems :)
15:59:59 <kmc> @quote two.problems
15:59:59 <lambdabot> jwz says: Some people, when confronted with a problem, think "I know, I'll use regular expressions." Now they have two problems.
16:00:00 <interferon> so something like "Int n, n >= 4" ?
16:00:01 <copumpkin> kmc: I paid 2 bucks
16:00:03 <ddarius> copumpkin: Who are these people?
16:00:03 <monochrom> They cost 7 sleepless nights because you're addicted.  :)
16:00:05 <pikhq> PeakerWork: Makes the type system uncomputable.
16:00:08 <PeakerWork> copumpkin: that's not true?? :)
16:00:09 <interferon> copumpkin: ?
16:00:12 <pikhq> interferon: That's an example, yes.
16:00:13 <copumpkin> kmc: now I feel ripped off
16:00:16 <PeakerWork> pikhq: not necessarily...?
16:00:32 <copumpkin> ddarius: I've seen several people say things to that effect on the haskell subreddit
16:00:32 <PeakerWork> pikhq: you can use a partiality monad for turing completeness
16:00:37 <copumpkin> can't think of anyone off the top of my head
16:00:42 <kmc> it means that typechecking can perform the same computation as your language's evaluation
16:00:50 <pikhq> PeakerWork: Well... Yeah, you can make it total. Never mind.
16:00:56 <kmc> in Agda or Gallina, that evaluation comes with totality proofs
16:01:02 * copumpkin clucks
16:01:15 <kmc> @quote pink
16:01:15 <lambdabot> roconnor says: [on Agda] and if your code is pink, you might as well write it in some crappy langauge like Haskell
16:01:22 <pikhq> Of course, then you've got a toal functional language to think about.
16:01:46 <pikhq> (presumably either your language is total, or it has a total subset)
16:02:08 <monochrom> I just add formal methods and I've solved all my problems.
16:02:15 <copumpkin> nice
16:06:00 <ddarius> Which ML implementation uses JIT compilation?
16:06:03 <monochrom> If you sit in this channel you will run into people who cite dependent types to answer all problems anyway. In fact, someone just did.
16:06:40 <interferon> it's an interesting idea
16:06:45 <interferon> but it sounds incredibly expensive
16:08:57 <xerox> it's for $9,999.99 only until easter!
16:09:26 <Twey> monochrom: Yeah, it's really annoying.  I suggest we solve it by implementing dependent types.
16:10:20 <mreh> Hllo
16:10:23 <mreh> w00t
16:10:29 <mm_freak> well, i'd love to see them, to be honest, but as soon as they're implemented, we'll find something new, which would be great to have =)
16:10:33 <mreh> turns out I wasn't pressing "U"
16:10:42 <Twey> mm_freak: Maybe
16:10:50 <mm_freak> no, we already have Maybe
16:10:53 <Twey> mreh: Also turns out your IRC client isn't set to send UTF-8.  ;)
16:10:57 <Twey> mm_freak: Haha
16:11:12 <mreh> Twey: what does it show as?
16:11:55 <mauke> \λ→λ
16:12:00 * ddarius doesn't want to see dependent types in Haskell.
16:12:14 <Twey> Why not?
16:12:28 <copumpkin> mm_freak: they'd be nice, but they make programming a lot harder (if you choose to use them)
16:12:35 <copumpkin> of course, it's because you're proving stuff :)
16:12:39 <theorb> mreh: Shows fine to me, which suggests that it's sending latin-1.
16:12:43 <mm_freak> copumpkin: huh?
16:12:49 <copumpkin> (dependent types)
16:12:58 <mm_freak> copumpkin: you don't _need_ to use them
16:12:58 <ddarius> Twey: It would be a massive change to Haskell and would take it in a totally different direction than it is currently heading (in my opinion.)
16:13:13 <ddarius> Twey: I don't have a problem with dependent types, I just don't want them in Haskell.
16:13:16 <mm_freak> but of course, if we had them, the libraries would slowly start to adopt them
16:13:33 <theorb> (My client will send utf8, and display incomming utf8.  If the input isn't valid utf8, it will assume it's latin-1.  Since I can see it and mauke cannot, it's probably latin-1.)
16:13:35 <tensorpudding> dependent types would not work well with HM would they?
16:13:36 <Twey> ddarius: What is the direction in which it is currently heading?
16:13:45 <mauke> theorb: I can see it
16:13:56 <copumpkin> mm_freak: yes, but they effectively break abstraction
16:14:02 <theorb> Oh.  Thought you said you cannot.  Nevermind, then.
16:14:11 <idnar> theorb, mauke, mreh: it did come through in latin1, though
16:14:14 <ddarius> Twey: Deeper into polymorphic types and qualified types and their practical application.
16:14:32 <mm_freak> copumpkin: what do you mean?
16:14:33 <idnar> 48 e9 6c 6c 6f
16:14:51 <Twey> ddarius: And you consider dependent types distinct from and irreconcilable with this?
16:14:58 <arjanb> i want to see dependent types in haskell, but only when the ease of use to benefit ratio is as good as HM
16:15:19 <copumpkin> mm_freak: well, most dependent type systems out there know the implementation of every value, and don't support extensional equality
16:15:38 <ddarius> Twey: They are definitely distinct from the polymorphic part, and currently they are irreconcilable with the practical part.
16:15:50 <mm_freak> copumpkin: ah, i understand
16:16:05 <xerox> Like quantum and relativity theory
16:16:19 <copumpkin> apparently epigram is working to make it a little nicer
16:16:40 <Twey> Hm, I see
16:17:31 <Berengal> Haskell + dependent types would be pretty neat, I think, but only if you got the current haskell back when you ignored the dependent types
16:17:49 <Berengal> They'd be a neat alternative to tests
16:18:12 <copumpkin> some agda has tests built in at compile time
16:18:27 <copumpkin> test1 : f x == [1,2,4,]
16:18:29 <copumpkin> test = refl
16:18:35 <Berengal> Hah, indeed
16:18:50 <copumpkin> of course, you don't get the list literal
16:18:53 <copumpkin> but you get the idea
16:20:11 <mm_freak> well, yes, i'm talking a lot about dependent types, because i'm experiencing the blub paradox
16:20:22 <Berengal> I was pleasantly surprised the first time I wrote something like that. It hadn't occured to me that simple unit-tests can all be implemented as 'refl' in agda
16:20:23 <mm_freak> i got to know haskell, so i started to hate writing programs in all other languages
16:20:43 <mm_freak> now i got to know agda and parts of idris, so i'm missing things in haskell
16:20:47 <copumpkin> :)
16:20:55 <copumpkin> yeah, going from agda to haskell can be painful sometimes
16:21:01 <Berengal> mm_freak: Indeed, I've gone through the same experience
16:21:03 <mm_freak> probably it would have been better not to look at agda
16:21:26 <copumpkin> most of the stuff I miss isn't the hardcore proving stuff but simple type-level values
16:22:06 <Berengal> The thing about Agda, however, is that even though it's a "better" language that haskell, it's also worse at writing programs in
16:22:33 <Philonous> Agda doesn't have general recursion, does it?
16:22:40 <Berengal> This makes me think that Haskell is still at the top of the language order
16:22:50 <roconnor> is that like saying that Haskell is a better language than scheme but worse for writing porgrams in?
16:23:07 <ddarius> roconnor: No, because your statement is clearly false.
16:23:09 <Berengal> Philonous: It does, but it'll yell at you
16:23:18 <theorbtwo> It Haskell is better at writing programs in, then in what sense is Agda better?
16:23:27 <Berengal> theorbtwo: dependent types :)
16:23:30 <copumpkin> theorbtwo: proving things about your programs, or making them beautiful
16:23:36 <copumpkin> beautiful unicode-wise
16:23:47 <copumpkin> sometimes you'll need to sacrifice your firstborn to prove that your terminating function does indeed terminate
16:23:58 <roconnor> I don't really see why Haskell better at writing programs than Agda
16:24:02 <mm_freak> ddarius: actually plt-scheme is quite practical
16:24:07 <theorbtwo> copumpkin: It's a programming language, not a paint program.
16:24:08 <mm_freak> you can do a lot with it fast
16:24:09 <Berengal> Agda's unicode syntax is both beautifull and messy at the same time. It's like modern art...
16:24:09 <ddarius> mm_freak: So?
16:24:18 <ddarius> mm_freak: I'm also aware of that.
16:24:39 <copumpkin> theorbtwo: syntax is your interface to the language... interface aesthetics do make using something more or less pleasant
16:24:41 <mm_freak> so it's not really "clearly false"
16:24:48 <ddarius> mm_freak: Sure it is.
16:25:15 <theorbtwo> copumpkin: Absolutely.  That makes aesthetics important because they make the programming language easier to write programs in.
16:25:27 <Berengal> Even without unicode agda has a beautiful syntax
16:25:32 <mm_freak> roconnor: have you ever written an agda type signature?
16:25:39 <roconnor> yes
16:25:48 <copumpkin> I quite like the explicit "polymorphism" in agda
16:25:59 <mm_freak> now compare them with haskell type signatures =)
16:26:01 <roconnor> I don't recall it being very painful
16:26:02 <copumpkin> through implicit parameters, that is
16:26:06 <Berengal> I like the polymorphic modules
16:26:10 <copumpkin> yeah, I don't think it's terribly painful
16:26:13 <copumpkin> yeah, the modules are nice too
16:26:38 <mm_freak> not painful, but more verbose
16:26:46 <Berengal> It might be a better alternative to type-classes, even. I can see some problems with classes that records would solve
16:26:51 <mm_freak> not necessarily usefully
16:26:54 <copumpkin> well things like dependent function composition are necessarily more verbose
16:27:07 <roconnor> mm_freak: aren't they only more verbose in as much as they are more expressive?
16:27:19 <mm_freak> and in haskell it is sometimes very useful to write:  forever doSomething =)
16:27:23 <ddarius> Berengal: The same problems with classes that records solve in Haskell...
16:27:33 <roconnor> mm_freak: forever is perfectly co-recursive
16:27:35 <copumpkin> mm_freak: you can still do that, if you prove that you're being productive
16:27:51 <Berengal> ddarius: You can't open records in records in Haskell
16:28:04 <mm_freak> yes, and that's something agda's "standard" library lacks
16:28:05 <ddarius> Berengal: Nope, you can't.
16:28:26 <roconnor> I'd like to learn more about these "open" types
16:28:39 <copumpkin> mm_freak: corecursion is painful in general :) there's some basic support for some codata types, though
16:29:18 <mm_freak> copumpkin: i think i like lists + unsafeInterleaveIO =)
16:29:27 <copumpkin> fair enough
16:29:29 <copumpkin> :)
16:34:47 --- mode: ChanServ set +o Lemmih
16:34:53 --- mode: Lemmih set +v _andy_
16:35:04 <_andy_> @src Monad (->) a
16:35:04 <lambdabot> Source not found. :(
16:35:22 <_andy_> @src Monad ((->) a)
16:35:22 <lambdabot> Source not found. Just what do you think you're doing Dave?
16:35:48 <pikhq> @src Monad ((->) r)
16:35:48 <lambdabot> Source not found. Where did you learn to type?
16:36:16 <copumpkin> @src (->) (>>=)
16:36:17 <lambdabot> f >>= k = \ r -> k (f r) r
16:36:21 <copumpkin> @src (->) Monad
16:36:21 <lambdabot> Source not found.
16:42:45 <roconnor> What do we make of Paczesiowa's exception mechinism?
16:48:09 <chrisdone> mauke: Adams Apples was great. really enjoyed it
16:49:05 <juhp> does anyone use profiling much?
16:51:39 <Axman6> juhp: i've used it, though i'm no expert
17:03:13 <juhp> Axman6:
17:03:22 <juhp> ok
17:14:09 <ddarius> When saying a "first order, ordinary differential equation is essentially a vector field" is asking for "autonomous" to be included too much?
17:15:11 <xerox> I don't think so
17:15:45 <xerox> do you mean you want autonomous to be included or that it is kind of implicit?
17:16:41 <ddarius> xerox: The statement holds for autonomous 1ODEs but not (naturally) for non-autonomous ones.  I'm assuming that's just supposed to be understood.
17:18:04 <augur> anyone interesting in syntactic theory? :x
17:18:22 <augur> surely some of you haskell peeps have an interest in language, ey? :x
17:18:30 <xerox> ddarius in that case, agreed
17:26:47 <BMeph> Off hand, does anyone know if there's a standard combinator like "flip", except 1) it takes a three-arg func and three args; 2) It "rotates" the firs arg to last?
17:27:03 <dang`r`us> sounds like you want FORTH
17:27:04 * dang`r`us runs
17:27:20 <BMeph> I.e., combo f c a b = f a b c
17:27:25 <xerox> there you go
17:28:11 <augur> xerox is indeed correct: you just defined the function. who cares if its standar
17:28:11 <BMeph> xerox: "does anyone know if there's a standard combinator" - i.e., is there a standard name already for this function?
17:28:12 <augur> d
17:28:26 <xerox> let's see what pl does
17:28:34 <xerox> ?pl \f c a b -> f a b c
17:28:34 <lambdabot> flip . (flip .)
17:28:42 <xerox> :/
17:28:57 <augur> haha
17:29:14 <BMeph> augur: I care if it's standard. If it already has a name, I want to know it, and use it. If it doesn't have a standard name, then I know that I can make one up and propose it to be in a package somewhere. :)
17:29:45 <augur> i dare say that if it were necessary enough to put in a package, it would be there already
17:30:35 <ddarius> BMeph: I doubt there is any standard name for it.  If there is it's via some function that would be being horribly abused.
17:30:44 <dino-> BMeph: Now I want to know what that's useful for! Can you give me an example?
17:30:54 <xerox> ?type \f c a b -> f a b c
17:30:55 <lambdabot> forall t t1 t2 t3. (t1 -> t2 -> t -> t3) -> t -> t1 -> t2 -> t3
17:31:00 <BMeph> augur: Ah, but "necessary enough" is almost worthlesly subjective. Many people have oft-used functions that they never put in a package, except for using in other ones.
17:31:19 <ddarius> I can't say that it comes up too often (either for me personally or for the masses that have passed through #haskell)
17:33:31 <interferon> how would i read in the string "3/4" as a rational?
17:33:54 <xerox> > toRational (read "3/4") -- crosses fingers
17:33:55 <lambdabot>   * Exception: Prelude.read: no parse
17:34:33 <kpreid> > show (3/4 :: Ratio Integer)
17:34:34 <lambdabot>   "3 % 4"
17:34:43 <dino-> > toRational (read "¾")
17:34:44 <kpreid> > read "3 % 4" :: Ratio Integer
17:34:44 <lambdabot>   * Exception: Prelude.read: no parse
17:34:45 <lambdabot>   3 % 4
17:34:45 <xerox> so, you don't.
17:34:52 <BMeph> dino-: I'm sure I've seen it used elsewhere, but I'd like see 1) if there's a pattern between it and flip, similar to the Lift[A/M]n series, to be pulled out; 2) if it's more useful besides in the Peano-to-Church conversion.
17:35:43 <kpreid> > read $ map (\c -> if c == "/" then "%" else "/") $ "3/4" :: Ratio Integer
17:35:44 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
17:35:44 <lambdabot>         against inferred ty...
17:35:45 <dino-> BMeph: ok, thanks
17:36:20 <kpreid> > read $ map (\c -> case c of '/'->'%'; _->c) $ "3/4" :: Ratio Integer
17:36:21 <lambdabot>   3 % 4
17:36:25 <kpreid> there we go
17:37:53 <BMeph> E.g.: peanoToC :: Peano -> Church; peanoToC peano = \succ zero -> fold succ zero peano -- now we can just say "peanoToC = combo fold"
17:39:06 <interferon> kpreid: thanks!
17:55:30 <dolio> Are Agda types more verbose than these types: http://hackage.haskell.org/packages/archive/sessions/2008.7.18/doc/html/Control-Concurrent-Session.html
17:58:13 <copumpkin> lol
17:59:26 <DekuNut> forkIO's implementation in GHC.Conc is case (fork# action_plus ...     the magic hash here does mean that fork is a primitive operation built into GHC right?
17:59:39 <DekuNut> With the # being an unboxed type
17:59:45 <copumpkin> well, you can put hashes on your names too if you really want to
17:59:51 <copumpkin> but in this case, it's a built-in function
17:59:58 <DekuNut> Fantastic, thank you
18:01:49 <ddarius> dolio: Are there any programs which use that package?
18:02:12 <dolio> Doubtful, unless the author has used it for something.
18:02:55 <copumpkin> a bit like mps :)
18:03:02 <copumpkin> wtf in different ways
18:03:04 <dolio> I don't think you're supposed to look at the types at all, really, because they're so gigantic.
18:03:15 <copumpkin> he could at least hide them behind aliases
18:03:31 <copumpkin> or try to compose them out of smaller parts
18:03:40 <dolio> As I recall, there are combinators for building up session types using term-level expressions, because writing down the types directly is completely unworkable.
18:04:17 <Axman6> dolio: holy jesus...
18:04:22 <Axman6> ...
18:04:25 <Axman6> ow
18:04:26 <Axman6> :'(
18:04:28 <dolio> And one of the complaints he got from a reviewer of the associated paper was that there were no actual type declarations (or something like that) in a paper about session types.
18:04:42 <Axman6> heh
18:07:39 <mreh> mapM over [Maybe] will give Nothing if one of the list is Nothing
18:07:42 <mreh> correct?
18:07:55 <ddarius> Yes.
18:08:45 <copumpkin> :t mapM
18:08:47 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
18:08:52 <copumpkin> :t sequence
18:08:53 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
18:09:27 <mreh> I'm trying to parse a list of things, if one fails then the whole lot fails
18:09:38 <dolio> Anyhow, my overall point is that "verbose" isn't a very good word for describing types like those, necessarily. They're big, but they're big because there's a lot going on in them. Verbosity implies that they're longer than they need to be.
18:10:07 <dolio> The session types might actually be verbose, because Haskell lacks a bit on the type-level abstraction front.
18:10:09 <copumpkin> dolio: I'd hope that some of the length could be factored out
18:11:17 <dolio> But complaining that the type of a strong inductive eliminator for the naturals is "more verbose" than (o -> o) -> o -> Nat -> o, because it's longer, is missing what's going on.
18:12:32 <ddarius> dolio: I agree.
18:13:06 <dolio> And I can write "forall {o} -> (o -> o) -> o -> Nat -> o" in Agda anyway. It just doesn't do everything the fancier type does.
18:18:03 * BMeph smiles at dolio; "I see what you did there..." :)
18:20:57 <kmc> according to Google, 42% of occurrences of the phrase "monomorphism restriction" on the Web prefix it with the word "dreaded"
18:21:27 <ddarius> "monomorphism restriction" isn't a really common phrase...
18:22:13 <dolio> How about "value restriction"? Is that as dreaded?
18:22:24 <ddarius> No, that's necessary.
18:22:40 <ddarius> Or something to do what it accomplishes.
18:22:48 <kmc> no, less than a hundredth of a percent
18:22:53 <dolio> Heh.
18:23:04 <xerox> http://www.googlefight.com/index.php?lang=en_GB&word1=monomorphism+restriction&word2=value+restriction
18:32:37 <DrSyzygy> Man, I'm loving the latest batch of Haskell quotes!
18:39:09 <tim-m89> Hi I feel real foolish to ask but why doesn't this code work: http://gist.github.com/285597
18:39:39 <dolio> seq doesn't do what you think it does.
18:39:44 <ddarius> tim-m89: It does.  It just probably doesn't do what you think.
18:40:41 <Philonous> tim-m89: There is a difference between evaluating an IO action and performing it
18:40:44 <tim-m89> ddarius funny but it compiles fine and doesn't print any of it's args
18:40:57 <tim-m89> seq fully evaulautes though?
18:41:10 <copumpkin> evaluates, doesn't execute
18:41:28 <copumpkin> > print "abc"
18:41:29 <tim-m89> ok cool any good reading material you can link me too
18:41:29 <lambdabot>   <IO ()>
18:41:34 <Philonous> tim-m89: Yes. It builds the action. But the action is a mere recipe. You have to give it to main to actually execute it.
18:41:51 <Peaker> s/give it/bind it
18:41:52 * Zao has some nice words to say to whoever wrote the Win32 package.
18:41:58 <copumpkin> mapM putStrLn args
18:42:02 <Zao> I guess that anyone that uses it is supposed to contribute patches with nigglings ;P
18:47:44 <DekuNut> Something very simple that I can't figure out, I want to create my own local module, just for a test project. I've got my module decl: module MyTest (firstFunction) where ... and the function decl
18:48:13 <DekuNut> It's saved in the project dir as, LocalModules/MyTest.hs    problem is when I try and compile the main project
18:48:21 <Philonous> tim-m89: An IO action is a little bit like a shell script. You can build it from smaller parts, you can even compile it to binary form (that is, sort of, what seq does here), but you have to actually invoke it to see something happen
18:48:25 <DekuNut> I get an error about the names differing in the interfaces
18:48:56 <aavogt> DekuNut: where is your Main relative to LocalModules?
18:49:16 <DekuNut> ./main.hs   and ./LocalModules/MyTest.hs
18:49:27 <aavogt> your issue can probably be solved by compiling with   -iLocalModules
18:49:50 <aavogt> or calling your module   LocalModules.MyTest
18:50:09 <DekuNut> If you mean calling your module as in, in main.hs
18:50:14 <tim-m89> DekuNut thanks. I've been stuck on the assumption that evaluate IO means perform IO all day.
18:50:15 <DekuNut> I am doing: import LocalModules.MyTest
18:50:28 <DekuNut> tim-m89, I think you mean Philonous
18:50:52 <aavogt> then you must write     module LocalModules.MyTest where ...
18:51:06 <Axman6> tim-m89: think of it this way: the IO monad creates a C program, when when evaluated gets compuled and run
18:51:12 <Axman6> it's not true, but it helps
18:51:20 <DekuNut> Oh right, let me try that aavogt
18:51:33 <Axman6> so, something of type IO a is a CProgram which returns an a
18:52:57 <DekuNut> (.text+0x425): undefined reference to `__stginit_LocalModuleziMyTest_'
18:53:05 <DekuNut> At least it's not complaining about the interface file anymore
18:54:51 <aavogt> hmm, weird.  Does compiling with flag --make work, DekuNut?
18:55:25 <aavogt> it also might help to remove the old .hi and .o files, but ghc should do that itself....
18:55:26 <DekuNut> ghc: no input files
18:55:42 <DekuNut> If it helps, I did
18:55:43 <aavogt> in addition to naming your main.hs
18:55:47 <DekuNut> ghc --make main.o -o main
18:55:54 <aavogt> no
18:56:02 <aavogt> ghc main.hs
18:56:19 <aavogt> or ghc --make main.hs -o main
18:56:34 <DekuNut> Ah yes that worked
18:56:51 <aavogt> by telling ghc to compile the object files, it's probably expecting you to name the interface files too
18:57:00 <aavogt> *link
18:57:25 <DekuNut> How would I do that? -J or something similar?
18:57:31 <DekuNut> Or -L even
18:57:38 <DekuNut> (Taking random shots in the dark D:)
18:58:09 <aavogt> I dunno, it works all the time if you name the .hs, and possibly --make
18:58:21 <DekuNut> I'll have to rewrite my makefile then
18:58:35 <DekuNut> Thanks
18:58:37 <aavogt> check the ghc manual if you're really that interested
18:58:48 <aavogt> oh, you wouldn't rather just use cabal?
18:58:50 <DekuNut> Well I'm reading this: http://www.haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html
18:59:24 <DekuNut> aavogt, I haven't touched cabal yet, I haven't planned to make any projects that will actually GO anywhere, I just want to play with haskell
19:01:11 <Cale> You can also just  ghc --make foo  and it will compile foo.hs to produce an executable named foo
19:01:44 <DekuNut> Nah I get that now, I was just wondering if I could do it 'old school' style, with .o files, I'm reading the manual now so I'll find out anyway
19:14:37 <sshc> can a type have the same name as a type class?
19:14:53 <copumpkin> no
19:15:04 <aavogt> if they come from separate modules, yes
19:15:18 <aavogt> but I suppose the qualification is part of the name
19:15:23 <aavogt> so copumpkin wins
19:36:03 <pastorn> can anyone se me writing this?
19:36:14 <Zao> Yes.
19:36:22 <pastorn> YES
19:36:26 <pastorn> goddamn nickserv
19:36:45 <seydar> pastorn: one more time, i missed it
19:36:55 <pastorn> :p
19:43:34 <Cale> > iterate (liftM2 (zipWith (+)) ([0]++) (++[0])) [1]
19:43:36 <lambdabot>   [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1]...
19:44:51 <seydar> > putStrLn "I tapped your mom, Cale"
19:44:52 <lambdabot>   <IO ()>
19:44:55 <seydar> dammit
19:45:03 <seydar> > identity "I tapped your mom, Cale"
19:45:04 <lambdabot>   Not in scope: `identity'
19:45:10 <seydar> > id "I tapped your mom, Cale"
19:45:10 <lambdabot>   "I tapped your mom, Cale"
19:45:22 <seydar> whoa, did you see what lambdabot said?
19:45:46 <Cale> fail
19:45:52 <Zao> I believe I'm obliged to counteract that cute Haskell snippet with http://codepad.org/j8qf0M5y
19:46:04 <Zao> That should normalize any elegance measurement devices.
19:46:09 <copumpkin> > text "seydar fails"
19:46:10 <lambdabot>   seydar fails
19:46:21 <copumpkin> Zao: ACH MY EYES
19:46:59 * copumpkin prepares for his l33t loose indexscan
19:47:47 <Zao> > fail "seydar" :: IO ()
19:47:48 <lambdabot>   <IO ()>
19:48:00 <copumpkin> > fix fail
19:48:01 <lambdabot>   ""
19:48:18 <Zao> Are there any monads that would produce a more amusing result?
19:48:22 <Zao> Maybe () gives Nothing.
19:48:42 <copumpkin> > fail "seyar" :: Either String a
19:48:43 <lambdabot>   Left "seyar"
19:48:49 <pikhq> > fail "seydar" :: String
19:48:50 <copumpkin> seydar, even
19:48:51 <lambdabot>   ""
19:48:56 <pikhq> Aaaw.
19:49:12 <Axman6> > text "I tapped your mum, seydar"
19:49:13 <lambdabot>   I tapped your mum, seydar
19:49:16 <Zao> pikhq: That's what, mzero of [a]?
19:49:39 <copumpkin> it is, but in this case it's just fail of []
19:49:46 <copumpkin> mzero would be of [], too
19:49:56 <seydar> text "stop making me say mean things about seydar he was the only one who came to my birthday party"
19:49:56 <Cale> Does anyone else feel that the Win32 API looks like it was designed to make assembly programmers' lives easy, rather than even C programmers? I'm not 100% sure why I feel that way.
19:50:05 <seydar> > text "stop making me say mean things about seydar he was the only one who came to my birthday party"
19:50:06 <lambdabot>   stop making me say mean things about seydar he was the only one who came to...
19:50:13 <pikhq> Cale: Not even that.
19:50:14 <copumpkin> fail
19:50:24 <pikhq> The Win32 API was designed to make everyone's lives painful.
19:50:37 <Cale> pikhq: I suppose that's the only other possibility.
19:50:38 <copumpkin> it even clubs baby seals
19:50:41 <copumpkin> when you're not looking
19:51:00 <pikhq> Yup, that's the clubBabySeals function it calls all the time.
19:51:36 <Cale> Microsoft has a secret shootBabySeals API.
19:52:44 <pastorn> @type text
19:52:45 <lambdabot> String -> Doc
19:52:57 <pastorn> @scr text
19:52:57 <lambdabot> Maybe you meant: arr rc src
19:52:59 <pikhq> Or, to fully qualify it: CHARP clubBabySeals(BOOL x, BOOLEAN y, VARIANT_BOOLEAN z, bool bthisisabool);
19:53:03 <pastorn> @src text
19:53:03 <lambdabot> Source not found. My mind is going. I can feel it.
19:53:30 <pikhq> (BOOL != BOOLEAN != VARIANT_BOOLEAN)
19:54:02 <pastorn> pikhq: while(1==1) epicAPI.clubBabySeal();
19:54:18 <Cale> text  s = case length s of {sl -> textBeside_ (Str s)  sl Empty}
19:54:21 <pikhq> pastorn: Not Microsofty enough.
19:54:33 <pikhq> Insufficient Hungarian.
19:54:40 <pikhq> And not enough #defines.
19:54:42 <pastorn> pikhq: while(1==1) epicAPI.clubBabySeal(1,true,NULL, NULL, NULL, NULL);
19:55:11 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/pretty/src/Text-PrettyPrint-HughesPJ.html#text
19:55:12 <pastorn> Cale: cool, thanks :)
19:55:20 <pastorn> hughes, is it?
19:55:24 <Cale> heh, the type signature is waaay far away from the implementation
19:55:46 <pikhq> while(toBOOL(toBOOLEAN(toVARIANT_BOOLEAN(-1)))) printf("%s", clubBabySeals(1, (char)1, -1, true));
19:55:55 <kmc> pikhq, needs more hungarian notation
19:56:10 <kmc> lpbsLongPtrToBabySeal
19:56:18 <pastorn> pikhq: is that M$ style?
19:56:26 <kmc> oh, you said that
19:56:35 <pikhq> (a BOOL is an int, a BOOLEAN is a byte, a VARIANT_BOOLEAN is a short where -1 is true and 0 is false, and bool is C++)
19:56:55 <pikhq>  All 4 can see use in code written to Win32.
19:57:05 <pastorn> win
19:57:14 <pastorn> pikhq: but what's true?
19:57:33 <pikhq> pastorn: For which?
19:58:10 <Cale> I like that the code for Text.PrettyPrint.HughesPJ includes the comment "I'll send you the code if you are interested." referring to code which is actually in the very same source file.
19:58:32 <pastorn> pikhq: in a more philosophical sense...?
19:58:32 <monochrom> haha
19:59:15 <Zao> pikhq: My favourite function is PeekMessage which returns a BOOL and is documented to return "non-zero on new message, zero if no new message"
19:59:36 <BMeph> houldn't that be: "while(1==1) epicAPI.clubBabySeal(1,true,NULL, NULL, NULL, NULL, 0xDEADBEBE);" ;)
19:59:37 <Zao> pikhq: And is implemented in the Win32 package as "failIf_ (== -1)" :)
19:59:44 <BMeph> *shouldn't
19:59:56 <Veinor> 0xDEADBABECAFE
19:59:59 <Zao> And returning IO ().
20:00:14 <pikhq> Zao: Ugh.
20:00:19 <Zao> So you can call it to determine whether there are any new messages, but it won't tell you.
20:00:26 <Veinor> Oh ma
20:00:27 <Veinor> n
20:00:49 <Zao> I have a feeling I'll have a hefty patch when this work is done.
20:00:51 <Veinor> "Patrick, why do I find the functional nature of Haskell combined with the strong type system so appealing?"
20:01:06 <aavogt> Veinor: you did fail to build gtk2hs with ghc-6.12, right?
20:01:07 <gwern> @quote sauce
20:01:07 <lambdabot> tensorpudding says: so you boil lisp for an hour to sift out the parentheses and impurities, make a whitespace sauce with liberal syntactic sugar, and you have haskell a la mode
20:01:59 <Veinor> You're thinking of someone else.
20:03:34 <Cale> http://www.haskell.org/pipermail/haskell-cafe/2003-August/004978.html
20:04:18 <dolio> That's a good'n'.
20:04:27 <solrize> huh??????
20:04:33 <gmg__> I'm having trouble installing hugs98 on Show Leopard. Can someone point me in the direction of some sort of guide or someting?
20:04:46 <pastorn> gmg__: use GHC
20:04:47 <copumpkin> that can be done in a single line, too
20:04:56 <Cale> > iterate (liftM2 (zipWith (+)) ([0]++) (++[0])) [1]
20:04:57 <lambdabot>   [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1]...
20:04:59 <pastorn> @where ghc
20:04:59 <lambdabot> http://haskell.org/ghc
20:05:00 <copumpkin> but I kind of like his thing
20:05:02 <pastorn> ^^ gmg
20:05:08 <gmg__> okay, thanks
20:05:08 <pastorn> ^^ gmg__
20:05:24 <solrize> boggle
20:05:26 <_andy_> is there a way, given a function of type [Maybe a] -> Maybe a
20:05:34 <pastorn> gmg__: sorry, i lied: http://hackage.haskell.org/platform/
20:05:38 <_andy_> to get [a -> Maybe b] -> a -> Maybe b
20:05:39 <Cale> ghc requires special instructions on Snow Leopard... :(
20:05:40 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
20:05:40 <pastorn> that's what you want
20:05:45 <dolio> The point was to give an over-blown answer to a simple homework problem.
20:05:51 <bob0> /msg lambdabot @messages
20:05:52 <copumpkin> _andy_: how would it work?
20:05:55 <_andy_> i mean i know the obvious
20:05:59 <kmc> @djinn ([Maybe a] -> Maybe a) -> ([a -> Maybe b] -> a -> Maybe b)
20:05:59 <lambdabot> Error: Undefined type []
20:06:03 <kmc> sigh
20:06:10 <_andy_> well, the first is using the First monoid in my case
20:06:26 <Cale> http://www.haskell.org/haskellwiki/Mac_OS_X#Mac_OS_X_10.6_.28Snow_Leopard.29
20:06:34 <_andy_> and the second is (specifically), given a series of Typeable cast operations, takes the method that succeeds
20:06:37 <pastorn> has anyone here tried GPipe?
20:06:44 <_andy_> perhaps not the most well worded
20:06:47 <uorygl> If I had an FPGA, could I get Reduceron and run it on it?
20:06:48 <pastorn> it looks pretty awesome...
20:06:58 <_andy_> @src GPipe
20:06:59 <lambdabot> Source not found. Do you think like you type?
20:07:10 <_andy_> @hoogle GPipe
20:07:11 <lambdabot> No results found
20:07:31 <pastorn> _andy_: http://www.haskell.org/haskellwiki/GPipe
20:08:30 <pastorn> uorygl: doesn't "Reduceron" have to have a "The" in front of it
20:08:37 <seydar> gangster pipe
20:08:42 <_andy_> the idea is to generate JSON without requiring any class instantiation on the users part
20:08:45 <pastorn> uorygl: otherwise it won't sound like something amazing from the 50s
20:08:50 <_andy_> not a really great idea, but just wanted to try it
20:09:00 <copumpkin> Redutron
20:09:11 <seydar> _andy_: gpipe should link to this: http://z.about.com/d/chemistry/1/0/f/n/meth_pipe.jpg
20:09:12 <copumpkin> we need more -tron words
20:10:48 <kmc> that's a meth pipe??
20:10:55 <copumpkin> meff
20:10:57 <pastorn> fucking yankees
20:11:02 <pastorn> all you do is take drugs
20:11:04 <_andy_> anyways, i've gone as far as doing weird stuff with
20:11:09 <kmc> well i dunno how to smoke meth
20:11:14 <_andy_> >newtype FList a b = FList { unFList :: [a -> b] }
20:11:21 <kmc> but i think you use the same kind of pipe as for crack
20:11:29 <kmc> and that's nicer than any crack pipe i've seen
20:11:32 <_andy_> >import Control.Category
20:11:49 <_andy_> meh
20:12:10 <_andy_> > import Prelude hiding ((.), id)
20:12:11 <lambdabot>   <no location info>: parse error on input `import'
20:12:53 <pastorn> _andy_: what do you think you're doing?
20:13:32 <DigitalKiwi> why does _andy_ have a +?
20:13:39 <_andy_> your me earlier, or the > that aren't correct
20:13:43 <kmc> _andy_, are you an infix operator?
20:13:48 <_andy_> ?
20:13:49 <_andy_> *you
20:13:50 <copumpkin> DigitalKiwi: he isn't registered
20:13:53 <copumpkin> and wanted to talk, I guess
20:14:04 <pastorn> fx _andy_ gx
20:14:08 <pastorn> > fx _andy_ gx
20:14:09 <lambdabot>   Not in scope: `fx'Not in scope: `_andy_'Not in scope: `gx'
20:14:13 <copumpkin> in agda that would just be
20:14:16 <copumpkin> x andy y
20:14:21 <DigitalKiwi> oh so someone voiced him instead of having him register like he should? :P
20:14:23 <pastorn> kmc: didn't work :(
20:14:24 <Veinor> copumpkin: oh hush you
20:14:27 <copumpkin> since the _ trigger the mixfix beauty
20:14:30 <copumpkin> :(
20:14:32 <_andy_> > _andy_ x y = x
20:14:32 <lambdabot>   <no location info>: parse error on input `='
20:14:34 <Veinor> you and your agda
20:14:43 <copumpkin> :( :(
20:14:44 <_andy_> @let _andy_ x y = x
20:14:44 <lambdabot>  Defined.
20:15:00 <Veinor> argh, I wish I could get a real install of ghc 6.10 on this machine instead of running it out of _
20:15:03 <pastorn> > 1 _andy_ 2
20:15:04 <lambdabot>   Ambiguous type variable `t' in the constraint:
20:15:04 <lambdabot>    `GHC.Num.Num t' arising f...
20:15:11 <pastorn> awww
20:15:15 <kmc> in agda you can define fr. example a 9-ary infix operator named _lift_yr_skinny_fists_like_antennas_to_heaven_
20:15:22 <kmc> and you should
20:15:27 <Veinor> so 1 lift 2 yr 3 skinny etc.?
20:15:32 <kmc> yes
20:15:40 <Veinor> I... don't know what to think about that
20:15:52 <kmc> that's all right, we'll tell you what to think
20:15:58 <pastorn> kmc: put_in_while_goes_your_
20:16:20 <Veinor> hm, hmatrix won't install from cabal
20:16:29 <Veinor> says it found a duplicate definition for    __hscore_S_IFDIR
20:17:42 <Veinor> in ~/.cabal/lib/directory-1.0.1.0/ghc-6.10.4/HSdirectory-1.0.1.0.o
20:18:28 <sealion> Ahabfun14
20:19:19 <kmc> good password man
20:20:07 <Veinor> someone ghost him!
20:20:14 <copumpkin> lol
20:20:25 <copumpkin> omg it's ezyang
20:20:28 <Veinor> this is all because the maintainers of this machine are still on 6.8 :(
20:20:36 <Veinor> I kind of want to pester them to upgrade it
20:21:38 <Veinor> also oh hai ezyang
20:21:41 <ddarius> kmc: Why did you abbreviate "for" with "fr." ?
20:22:00 <kmc> not sure
20:22:05 <kmc> probably because of 'yr'
20:22:13 <copumpkin> f'r
20:22:22 <kmc> fo'
20:22:51 <uorygl> The best abbreviation of "for" is "g.".
20:23:06 <uorygl> Placed after the noun.
20:23:18 <uorygl> So then you can abbreviate "for example" as "e.g.".
20:23:34 <Veinor> exempli gratis :P
20:23:44 <merehap> kmc: you made sealion quit and change his password :(
20:23:51 <uorygl> That too.
20:23:57 <kmc> yes it's all my fault
20:24:11 <copumpkin> exempli gratia
20:24:34 <Veinor> that, yeah
20:29:39 <Cale> > map (sum . takeWhile (>0)) . transpose $ zipWith (++) (iterate (-1:) []) (iterate (liftM2 (zipWith (+)) ([0]++) (++[0])) [1])
20:29:41 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
20:30:48 <Veinor> one of the oh, nevermind, it's available
20:31:09 <Veinor> ... -'one of the '
20:31:24 <Cale> Kind of an ugly way to extract the antidiagonals... hmm...
20:31:39 <Veinor> anyway, it's still giving me that error using a non-homedir GHC
20:33:12 <Veinor> HALP
20:46:58 <Cale> @let diagonals = map (map fromJust . takeWhile isJust) . transpose . zipWith (++) (iterate (Nothing:) []) . map (map Just) -- there must be a nicer way...
20:46:59 <lambdabot>  Defined.
20:47:28 <Cale> > diagonals . iterate (scanl1 (+)) $ repeat 1
20:47:29 <lambdabot>   [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1]...
20:47:39 <Cale> > diagonals . diagonals . iterate (scanl1 (+)) $ repeat 1
20:47:40 <lambdabot>   [[1],[1],[1,1],[2,1],[1,3,1],[3,4,1],[1,6,5,1],[4,10,6,1],[1,10,15,7,1],[5,...
20:47:44 <Cale> > map sum .diagonals . diagonals . iterate (scanl1 (+)) $ repeat 1
20:47:48 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
20:48:19 <copumpkin> very nice :)
20:50:56 <aavogt> @type diagonals
20:50:57 <lambdabot> forall a. [[a]] -> [[a]]
20:51:07 <Cale> > map sum . diagonals . diagonals . diagonals . iterate (scanl1 (+)) $ repeat 1
20:51:08 <lambdabot>   [1,1,1,3,2,6,6,11,16,22,37,49,80,113,172,257,377,573,839,1266,1874,2798,417...
20:51:16 <Cale> @oeis 1,1,1,3,2,6,6,11,16,22,37,49,80,113,172,257
20:51:17 <lambdabot>  Number of compositions of n such that two adjacent parts are not equal modul...
20:51:17 <lambdabot>  [1,1,1,3,2,6,6,11,16,22,37,49,80,113,172,257,377,573,839,1266,1874,2798,4175...
20:51:47 <Cale> (modulo 2)
20:51:55 <Cale> Wow, how cool.
20:52:07 <Cale> Let's stick another one in :)
20:52:14 <Cale> > map sum . diagonals . diagonals . diagonals . diagonals . iterate (scanl1 (+)) $ repeat 1
20:52:15 <lambdabot>   [1,1,1,1,3,4,4,5,12,15,8,32,47,25,78,128,103,203,303,377,588,666,1191,1766,...
20:52:27 <Cale> @oeis 1,1,1,1,3,4,4,5,12,15,8,32,47,25,78,128,103,203
20:52:28 <lambdabot>  Sequence not found.
20:52:39 <Cale> It's got to be something :)
20:52:46 <copumpkin> everything is something!
20:52:51 <copumpkin> find the pattern!
20:55:00 <Cale> btw, the diagonals^3 list also apparently counts the number of binary strings such that all maximal blocks of 1's have even length and all maximal blocks of 0's have odd length
20:56:05 <copumpkin> glad to hear it
20:56:23 <copumpkin> now find a general description of diagonals^n
20:56:32 <dmead> hey channel
20:56:46 <dmead> :o
20:58:25 <BMeph> t'sUp, dmead? ;)
20:59:11 <Gracenotes> h' 're y' doin'
20:59:26 <Cale> So I guess that would be strings of length n matched by the regular expression (11)*(0(00)*11(11)*)*(0(00)*|)
20:59:39 <dmead> i'm trying to install hdbc on ubuntu
20:59:45 <dmead> but it's missing a .so :/
20:59:58 <Gracenotes> did it say what it was called?
21:00:16 <dibblego> @type zip [0..] -- does this exist in python?
21:00:17 <lambdabot> forall t b. (Num t, Enum t) => [b] -> [(t, b)]
21:00:23 <dmead> Loading package HDBC-sqlite3-2.1.0.2 ... can't load .so/.DLL for: HSHDBC-sqlite3-2.1.0.2
21:00:24 <Gracenotes> enumerate?
21:00:46 <dons> dmead: via cabal?
21:00:48 <Gracenotes> enumerate(list) gives you a zippy generator
21:00:57 <dmead> dons, via apt
21:01:11 <dmead> i can't even find cabal in apt
21:01:13 <dons> but with ghc 6.12?
21:01:34 <dmead> 6.10
21:01:37 <dmead> hmm
21:01:47 <dmead> strange
21:02:12 <dibblego> Gracenotes, ta
21:03:58 <dmead> what the ell
21:05:59 <dmead> is there some reason apt on the latest ubuntu doesn't pull in 6.12?
21:07:52 <kmc> 6.12 is not blessed for end users yet
21:07:59 <kmc> the Haskell Platform is still on 6.10.4
21:08:04 * ddarius gives copumpkin the digits of Chaitin's Ω.
21:08:13 <copumpkin> oh, thank you
21:08:25 <copumpkin> I was waiting for my program to compute those digits to finish
21:08:30 <copumpkin> but it didn't seem to be doing much
21:09:03 <Veinor> okay, I can't install hmatrix :(
21:09:10 <copumpkin> Veinor: sure you can
21:09:12 <copumpkin> just try harder
21:09:22 <Veinor> it says there's a duplicate definition for GHCi runtime linker: fatal error: I found a duplicate definition for symbol __hscore_S_IFDIR
21:09:24 <ddarius> copumpkin took the words right out of my mouth
21:09:40 <ddarius> Luckily I just brushed.
21:09:42 <copumpkin> :)
21:09:48 <copumpkin> Veinor: I installed it a while ago on 10.5
21:09:52 <copumpkin> not sure if something changed for 10.6
21:10:05 <Veinor> this is 6.10.4 though
21:10:21 <copumpkin> yeah, so was that
21:11:31 <dmead> poopie
21:11:57 <dmead> anyone have an idea about this error?
21:11:58 <dmead> Loading package HDBC-sqlite3-2.1.0.2 ... can't load .so/.DLL for: HSHDBC-sqlite3-2.1.0.2 (libHSHDBC-sqlite3-2.1.0.2.so: cannot open shared object file: No such file or directory)
21:12:18 <dmead> i installed hdbc-sqlite-dev via apt
21:12:31 <Veinor> this might have to do with the fact that I have some horrible combination of ~/.ghc and ~/.cabal and 2 different versions of ghc and and and
21:12:32 <dolio> Is there such a file or directory?
21:12:47 <Veinor> deleting ~/.ghc fixed it
21:13:03 <Veinor> and it can't link gsl :(
21:13:40 <Veinor> this is why I want a real virtual machine!
21:14:16 <Eduard_Munteanu> Offtopic, but it pisses me off: http://www.cnn.com/2010/OPINION/01/23/schneier.google.hacking/index.html?hpt=T2
21:23:02 <Eduard_Munteanu> Oh, another thing that sucks... I actually need sleep.
21:49:01 <sohum> :t 1.2
21:49:03 <lambdabot> forall t. (Fractional t) => t
21:49:22 <sohum> what's the default type for Fractional?
21:49:23 <sshc> @let 1.2 = pi
21:49:24 <lambdabot>  Defined.
21:49:41 <dibblego> @hoogle (Monad f, Monad g) => [f (g a)] -> f (g [a])
21:49:41 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
21:49:41 <sshc> > pi * 1.2 - pi * pi
21:49:42 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
21:49:42 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
21:49:42 <lambdabot>   -6.099693216781606
21:49:54 <sshc> > pi * L.1.2 - pi * pi
21:49:55 <lambdabot>   Not in scope: data constructor `L'
21:50:00 <dolio> Double, probably.
21:50:07 <sohum> danke
21:50:14 <dolio> > pi
21:50:15 <lambdabot>   3.141592653589793
21:50:20 <dolio> > pi :: Float
21:50:21 <lambdabot>   3.1415927
21:50:21 <sshc> @let 1.2 = 1.2
21:50:22 <lambdabot>  Defined.
21:50:34 <sshc> @undefine 1.2
21:50:37 <sshc> > 1.2
21:50:38 <lambdabot>   1.2
21:50:58 <sohum> :t show &&& id
21:50:59 <lambdabot> forall b. (Show b) => b -> (String, b)
21:51:16 <sshc> :t Int
21:51:17 <lambdabot> Not in scope: data constructor `Int'
21:59:11 <sohum> @hoogle gr a b -> Node -> Node -> b
21:59:11 <lambdabot> Did you mean: Gr a b -> Node -> Node -> b /count=20
21:59:11 <lambdabot> Data.Graph.Inductive.Query.SP spLength :: (Graph gr, Real b) => Node -> Node -> gr a b -> b
21:59:11 <lambdabot> Data.Graph.Inductive.Query.BFS lesp :: Graph gr => Node -> Node -> gr a b -> LPath b
21:59:29 <sohum> @hoogle gr a b -> Node -> Node -> Maybe b
21:59:30 <lambdabot> Did you mean: Gr a b -> Node -> Node -> Maybe b /count=20
21:59:30 <lambdabot> Data.Graph.Inductive.Query.SP spLength :: (Graph gr, Real b) => Node -> Node -> gr a b -> b
21:59:30 <lambdabot> Data.Graph.Inductive.Query.MaxFlow maxFlow :: (DynGraph gr, Num b, Ord b) => gr a b -> Node -> Node -> b
22:00:06 <sohum> @hoogle gr a b -> Node -> [LEdge b]
22:00:07 <lambdabot> Did you mean: Gr a b -> Node -> [LEdge b] /count=20
22:00:07 <lambdabot> Data.Graph.Inductive.Graph inn :: Graph gr => gr a b -> Node -> [LEdge b]
22:00:07 <lambdabot> Data.Graph.Inductive.Graph out :: Graph gr => gr a b -> Node -> [LEdge b]
22:01:25 <sohum> @pl \x -> out x ++ inn x
22:01:26 <lambdabot> liftM2 (++) out inn
22:02:23 <sohum> @hoogle liftM2
22:02:24 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
22:02:54 <sohum> :t liftM2 (++) out inn
22:02:55 <lambdabot> Not in scope: `inn'
22:03:09 <sohum> :t liftM2 (++) sort sort
22:03:11 <lambdabot> forall a. (Ord a) => [a] -> [a]
22:03:34 <sohum> :t (++) <$> sort <*> sort
22:03:35 <lambdabot> forall a. (Ord a) => [a] -> [a]
22:04:22 <sohum> oh woops
22:04:31 <sohum> @pl \g x -> out g x ++ inn g x
22:04:31 <lambdabot> ap (ap . ((++) .) . out) inn
22:04:34 <sohum> ew.
22:11:25 <sohum> @hoogle (a,b,c) -> c
22:11:25 <lambdabot> Data.Typeable typeOf3 :: Typeable3 t => t a b c -> TypeRep
22:11:25 <lambdabot> Data.Typeable typeOf2Default :: (Typeable3 t, Typeable a) => t a b c -> TypeRep
22:13:31 <tomberek> hey
22:13:44 <pastorn> hoy
22:15:04 <pastorn> @paste
22:15:05 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
22:15:07 <pastorn> tomberek: ^^
22:15:11 <pastorn> paste shit there
22:15:13 <tomberek> k
22:16:10 <tomberek> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=6475
22:17:04 <pastorn> you shouldn't have typeclass restrictions in your datatype declarations
22:17:11 <pastorn> also: they don't do shit for you
22:17:13 <pastorn> remove them
22:17:51 <tomberek> I would like to have Weights and Pulses be in the Num class, but then have specific versions be more specific and use Floating
22:18:10 <pastorn> you want GeneralizedNewtypeDeriving
22:18:26 <pastorn> tomberek: http://necrobious.blogspot.com/2009/03/fun-example-of-haskells-newtype.html
22:18:29 <pastorn> there you go
22:18:33 <pastorn> knock yourself out
22:19:12 <tomberek> what is the downside of adding the pragma?
22:19:19 <pastorn> ehm... dunno
22:19:27 <pastorn> nothing... perhaps?
22:19:34 <pastorn> just use it
22:19:37 <pastorn> it's gonna be swell
22:19:40 <tomberek> does it prevent certain optimizations etc.?  or asked a different way: why is it not in haskell standard?
22:19:53 <pastorn> nono
22:19:58 <pastorn> this is you who did this
22:20:00 <pastorn> not haskell
22:20:08 <pastorn> you said "data Weight a = W a
22:20:30 <pastorn> so you can't force it to be a Num or Rational
22:20:43 <pastorn> had you had "data Weight = W Float" then you could have
22:20:53 <pastorn> instance Num Weight where ...
22:21:19 <c_wraith> isn't what you really want: newtype Weight = W Float deriving (Eq, Ord, Num, Read, Show)
22:21:34 <c_wraith> And possibly a few other derivings?
22:21:38 <tomberek> sort of, but still not quite
22:21:41 <pastorn> but using GeneralizedNewtypeDeriving makes so you don't have to have write massive instances for your numbers
22:21:51 <pastorn> tomberek: why do you need to have it generalized
22:21:53 <c_wraith> how is it not what you want?
22:22:16 <sshc> does GeneralizedNewtypeDeriving work for data types too?
22:22:20 <tomberek> i'm still new to this, so maybe it isn't possible,,, but I want to make a type that is only restricted to be Num
22:22:34 <sshc> how is the type system different when yo udon't use that extention?
22:22:35 <c_wraith> What does that even mean?
22:22:42 <pastorn> tomberek: then it can't have an 'a'
22:22:58 <c_wraith> sshc: it's just for newtypes.  It just lets you derive anything that what you're wrapping is an instance of
22:23:22 <tomberek> pastorn: ok... but I don't want to specify exactly what type it will be (Double, Float, Int, Integer, etc)
22:23:49 <pastorn> sshc: if you have "data Decimal = D Float" then you can't do (dec0 + dec1)
22:24:01 <Saizan> tomberek: you can write newtype Weight a = W a deriving (Eq, Ord, Num, Read, Show)
22:24:07 <pastorn> tomberek: you've got no choice here, unless you're gonna be annoying
22:24:23 <pastorn> Saizan: he can?
22:24:30 <Saizan> i'm pretty sure he can
22:24:33 <tomberek> i'll try
22:24:38 <pastorn> i don't think so...
22:25:02 <pastorn> typeclass restrictions in datatypes always goes bad for me...
22:25:33 <sshc> c_wraith: can you do that with "newtype Foo = Foo Bar Int"?
22:25:37 <pastorn> sshc: sure, you can have "add (D x) (D y) = D (x+y)
22:25:42 <pastorn> but that's annoying
22:25:49 <Saizan> {-# LANGUAGE GeneralizedNewtypeDeriving #-} newtype Weight a = W a deriving (Num,Show,Eq,Fractional,Floating) <- this compiles.
22:25:52 <tomberek> it compiles
22:25:52 <c_wraith> sshc: No, but newtype can't do that anyway
22:26:00 <pastorn> sshc: you want to have Num for Decimal
22:26:03 <c_wraith> sshc: newtype can only wrap *one* value
22:26:14 <sshc> oh
22:26:31 <pastorn> sshc: just copy the example from the link and try it out
22:26:34 <pastorn> it's pretty cool
22:27:08 <pastorn> Saizan: i have no haskell going on atm... :i Weight plz+
22:27:10 <pastorn> ?
22:27:41 <pastorn> or maybe :t W
22:27:43 <Saizan> instance (Eq a) => Eq (Weight a) <- all like this
22:27:55 <tomberek> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=6475#a6477
22:28:01 <tomberek> that works
22:28:02 <Saizan> newtype Weight a = W a
22:28:15 <pastorn> seriously?
22:28:20 <pastorn> :t (W "lol"
22:28:21 <lambdabot> parse error (possibly incorrect indentation)
22:28:21 <pastorn> )
22:28:24 <dibblego> what's the easiest way to get [(a, b) -> c] -> (a, b) -> [c] ?
22:28:25 <pastorn> hehe
22:28:48 <pastorn> dibblego: map ($ pair) fs
22:28:50 <tomberek> Saizan: am I making sense with what I want, and does that look right?
22:28:56 <Saizan>  W "lol" :: Weigth String, of course
22:29:02 <dibblego> pair?
22:29:07 <Saizan> tomberek: you can avoid the wrapping/unwrapping too
22:29:19 <pastorn> Saizan: but what about the deriving Num stuff?
22:29:24 <pastorn> this is just weird
22:29:25 <dibblego> @typr pair
22:29:26 <lambdabot> Not in scope: `pair'
22:29:39 <pastorn> dibblego: wtf?
22:29:42 <pastorn> are you daft?
22:29:48 <pastorn> pair :: (a,b)
22:29:49 <tomberek> Saizan: how? without that is says something about could not deduce (Floating (Pulse a))...
22:29:51 <dibblego> oh
22:30:07 <Saizan> tomberek: ah, right, you didn't derive Floating
22:30:24 <Saizan> tomberek: if you added that too you could
22:30:37 <c_wraith> But if you derive Floating, you can no longer use Int
22:30:53 <c_wraith> Really, it sounds like you require a specific type anyway, so why are you trying to be polymorphic?
22:30:53 <Saizan> pastorn: what's so weird in an instance Num a => Num (Weight a) ?
22:30:59 <dibblego> actually that's just sequence
22:31:07 <Saizan> c_wraith: you can use Int when you don't use the Floating instance
22:31:14 <tomberek> Saizan: i don't want to require Pulse to be a Float....
22:31:15 <pastorn> Saizan: because you can do (W "hello")
22:31:23 <pastorn> ok, maybe not
22:31:25 <tomberek> c_wraith: I am learning,, so I'm trying to see what is possible
22:31:31 <pastorn> but i would want it so that
22:31:45 <Saizan> pastorn: String is not a instance of Num, so that instance doesn't apply
22:32:04 <pastorn> W :: (Eq a,Ord a,Num a,Read a,Show a) => a -> Weight a
22:32:08 <Saizan> no
22:32:15 <Saizan> W :: a -> Weight a
22:32:24 <Saizan> there's not context on the constructor.
22:32:31 <Saizan> s/not/no/
22:32:34 <pastorn> yeah, i get it... i just think it behaves... unexpectedly
22:33:12 <c_wraith> I don't like contexts on data declarations anyway.
22:33:22 <pastorn> c_wraith: THANK YOU :D
22:33:35 <Saizan> this declaration doesn't have any context :)
22:33:43 <Saizan> tomberek: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=6475#a6479 <- i'd go with this
22:33:47 <c_wraith> It's true, it doesn't.  And I like that. :)
22:34:30 <tomberek> Saizan: what happens when someone wants to implement using just Int?
22:34:53 <c_wraith> Things like the whole "Set can't be an instance of monad because of its context constraint" are silly.  Why does it have a context constraint then?  If every function for manipulating sets requires an Ord key, why does the data declaration need it?
22:35:02 <tomberek> and they write a different function to accommodate?
22:35:03 <Saizan> tomberek: he can't use sigmoidMod, like he couldn't before
22:35:15 <tomberek> yes, he would have to write his own
22:35:19 <Saizan> tomberek: but he can still use the Pulse type
22:35:44 <tomberek> even though it has to be Fractional and Floating?
22:36:05 <Saizan> c_wraith: the data declaration for Set doesn't have a constraint :)
22:36:17 <Saizan> tomberek: it doesn't have to
22:36:34 <tomberek> oh.. ok, one sec (thanks for helping btw)
22:37:01 <Saizan> tomberek: the deriving part only says that if 'a' is you get those instances lifted to "Pulse a" for free
22:38:08 <solrize> @where readS
22:38:08 <lambdabot> I know nothing about reads.
22:38:21 <solrize> @hoogle readS
22:38:22 <lambdabot> Prelude type ReadS a = String -> [(a, String)]
22:38:22 <lambdabot> Text.Read type ReadS a = String -> [(a, String)]
22:38:22 <lambdabot> Text.ParserCombinators.ReadP type ReadS a = String -> [(a, String)]
22:38:24 <pastorn> enough of this
22:38:27 <pastorn> i'm going to bed!
22:38:30 <pastorn> good night :)
22:39:05 <Saizan> so if your type T is only Num then you get Num (Pulse T) and not Floating (Pulse T), but noone complains unless you give it to a function that requires that context
22:39:51 <tomberek> Saizan: sweet,, something like this...http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=6475#a6480
22:39:59 <pastorn> Saizan: before i leave
22:40:13 <pastorn> you seem to be very with this whole Deriving business
22:40:38 <pastorn> could you write me a monad that is just StateT SomeState IO
22:40:44 <pastorn> that derives MonadIO
22:40:51 <Saizan> yes
22:40:57 <pastorn> i've tried like five times and never succeded
22:42:13 <Saizan> tomberek: yeah, that works because you don't actually use the Real context in the body, otherwise you'd have to add Real to the deriving clause, but the idea is sound :)
22:42:20 <solrize> is there a version of read that gives a Maybe?  ie. (mread "foo" :: Integer) gives Nothing instead of throwing an error
22:42:36 <c_wraith> :t reads
22:42:38 <lambdabot> forall a. (Read a) => String -> [(a, String)]
22:42:43 <c_wraith> a list is sort of like maybe
22:42:47 <solrize> aha, thanks
22:43:05 <pastorn> solrize:
22:43:09 <pastorn> @type catMaybes
22:43:10 <lambdabot> forall a. [Maybe a] -> [a]
22:43:13 <pastorn> oh, sorry
22:43:16 <pastorn> wrong way
22:43:20 <Saizan> pastorn: newtype Foo s a = Foo (StateT s IO a) deriving (MonadIO, Monad) <- this works
22:43:22 <solrize> i understand about reads, thanks
22:43:25 <pastorn> @hoogle [a] -> Maybe a
22:43:25 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
22:43:25 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
22:43:25 <lambdabot> Prelude head :: [a] -> a
22:43:50 <Saizan> pastorn: newtype FooT s m a = Foo (StateT s m a) deriving (MonadIO, Monad) <- this too
22:43:58 <pastorn> Saizan: it does? weird
22:44:06 <pastorn> oh, what about monadstate?
22:44:09 <tomberek> Saizan: oops... so should I just like is like .. newtype Weight a = W a deriving (Eq,Show,Read,Ord,Num,Real,Fractional,RealFrac,RealFloat,Floating,Integral)
22:44:22 <tomberek> Saizan: **list it like**
22:44:36 <Saizan> tomberek: yeah, which is a bit long, but works :)
22:45:07 <tomberek> Saizan: looks like it works just the way I want it, but I don't know if there is a better way to get the same idea
22:45:07 <Saizan> pastorn: that's the trickier one, newtype FooT s m a = Foo (StateT s m a) deriving (MonadIO, Monad, MonadState s)
22:45:08 <pastorn> Saizan: "deriving {t : Set}"
22:45:35 <pastorn> maybe that's where i messed up :(
22:46:19 <pastorn> Saizan: thanks for that :)
22:46:30 <pastorn> i'm jolting this down for later exploitation :)
22:48:03 <Saizan> tomberek: nothing intrinsically better comes to mind at this level
22:48:47 <tomberek> Saizan: thanks for the help!  once i learn more haskell maybe i can ask questions a bit more clearly
22:49:10 <Saizan> tomberek: np :)
22:53:54 <tomberek> is there a command like :type but for classes? so I can see what is derived or what needs to be defined?
22:54:32 <Saizan> there's :info
22:54:54 <Saizan> which can used for both types and classes, not sure if it gives you what you want though
22:56:38 <tomberek> Saizan: perfect
23:02:59 <merehap> openFile "foo" ReadMode >>= if' blah stdin
23:03:07 <merehap> will openFile execute if blah is false?
23:04:13 <Saizan> yes
23:04:25 <merehap> how can I use a lazy bind then?
23:04:40 <c_wraith> IO's bind isn't lazy
23:04:45 <Saizan> you'd have to unsafeInterleaveIO the openFile
23:04:58 <Saizan> which is just weird
23:05:14 <merehap> ok, ill do a better, though more verbose, way then
23:05:16 <merehap> thanks!
23:05:24 <Saizan> if blah then return stdin else openFile "foo" ReadMode -- or flipped
23:05:56 <merehap> yeah, that's what I was thinking
23:06:02 <Saizan> the nice thing is that you can pass IO actions around
23:06:47 <Saizan> ?type let if' b t f = if b then t else f in \blah -> if' blah (return stdin) $ openFile "foo" ReadMode
23:06:49 <lambdabot> Not in scope: `stdin'
23:06:49 <lambdabot> Not in scope: `openFile'
23:06:49 <lambdabot> Not in scope: data constructor `ReadMode'
23:07:01 <Saizan> heh, well, you get the idea :)
23:07:10 <merehap> right, thank you
23:09:58 <tomberek> Saizan: this is less clunky than before,,,, but I don't know what the functional difference is http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=6475#a6481
23:10:12 <tomberek> Saizan: it compiles and works just as expected
23:10:50 <tomberek> or is it too lose and more prone to breaking?
23:11:20 <Saizan> well that way the type system can't help you if you mistake a Pulse for a Weight somewhere
23:11:37 <tomberek> good point
23:11:48 <tomberek> that was part of the whole reason i wanted this
23:20:49 <kmc> yeah, type is a simple alias
23:21:19 <tomberek> kmc: hi there!
23:21:24 <kmc> hi
23:22:19 <tomberek> kmc: still learning,,, got some info on GeneralizedNewTypeDeriving... but I'm not sure if I'm even thinking of this in the right way
23:25:33 <kmc> ah
23:26:03 <kmc> well, newtype is a good way to make sure that semantically-distinct values which happen to have the same representation don't mix in unwanted ways
23:26:53 <tomberek> well, that's what I want with Pulse and Weight.  So that big deriving statement seems to work fine.  Now I'm trying to extend this to nodes, neurons and nets
23:27:16 <tomberek> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=6475#a6482
23:27:25 <BMeph> :t flip
23:27:27 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
23:27:40 <BMeph> @src flip
23:27:40 <lambdabot> flip f x y = f y x
23:27:59 <BMeph> Bah. :)
23:28:48 <merehap> @pl flip' x y = f y x
23:28:49 <lambdabot> flip' = flip f
23:28:58 <mauke> :t \f x -> ($ x) . f
23:28:59 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a -> b) -> a -> f b
23:29:10 <merehap> @pl flip' f x y = f y x
23:29:11 <lambdabot> flip' = flip
23:29:12 <Taejo> : or
23:29:15 <Taejo> :t or
23:29:17 <lambdabot> [Bool] -> Bool
23:37:24 <solrize> @hoogle fix
23:37:24 <lambdabot> Data.Function fix :: (a -> a) -> a
23:37:24 <lambdabot> Control.Monad.Fix fix :: (a -> a) -> a
23:37:24 <lambdabot> module Control.Monad.Fix
23:38:00 <tensorpudding> what's the difference between the two instances?
23:38:22 <c_wraith> they're actually the same.  Control.Monad.Fix imports it from Data.Function, I believe
23:38:42 <c_wraith> If you import them both, they won't collide, as they're actually the same
23:39:22 <tensorpudding> ah
23:39:30 <tensorpudding> that module also has mfix
23:39:32 <tensorpudding> @type mfix
23:39:33 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
23:40:00 <tensorpudding> hmm, but no instances for MonadFix are defined
23:40:12 <mauke> @instances MonadFix
23:40:12 <lambdabot> ((->) r), Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
23:40:38 <tensorpudding> hmm
23:40:41 <tensorpudding> :t fixIO
23:40:42 <lambdabot> Not in scope: `fixIO'
23:40:50 <c_wraith> it's broken?
23:41:18 <tensorpudding> > mfix Nothing
23:41:19 <lambdabot>   Couldn't match expected type `a -> m a'
23:41:19 <lambdabot>         against inferred type `Data...
23:41:26 <tensorpudding> bleh
23:41:28 <tensorpudding> > mfix Just
23:41:31 <lambdabot>   mueval-core: Time limit exceeded
23:42:35 <c_wraith> > mfix (0:)
23:42:36 <lambdabot>   Occurs check: cannot construct the infinite type: t = [t]
23:43:01 <c_wraith> one of these days, I might learn how to use mfix
23:43:44 <c_wraith> > mfix (:[1,2,3])
23:43:48 <lambdabot>   mueval-core: Time limit exceeded
23:45:38 <mauke> :t mfix const
23:45:39 <lambdabot> forall a b. b -> a
23:45:54 <BMeph> :t mfix return
23:45:56 <lambdabot> forall a (m :: * -> *). (MonadFix m) => m a
23:46:20 <Alpounet> @src MonadFix
23:46:21 <lambdabot> class (Monad m) => MonadFix m where
23:46:21 <lambdabot>     mfix :: (a -> m a) -> m a
23:46:35 <BMeph> :t mfix (flip id)
23:46:36 <lambdabot> forall a. (a -> a) -> a
23:47:08 <BMeph> > mfix (flip id) error
23:47:10 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
23:47:30 * BMeph wins teh Intarwebz!
23:47:46 <BMeph> :
23:47:53 <c_wraith> By building fix from mfix?
23:48:27 <BMeph> c_wraith: Now, the fun part - let's see if cfix is defined! ;)
23:48:40 <BMeph> :t cfix
23:48:41 <lambdabot> Not in scope: `cfix'
23:48:48 <BMeph> Awwww....
23:49:12 <dolio> @type runIdentity . mfix . (return .)
23:49:13 <lambdabot> forall a. (a -> a) -> a
23:49:17 <mauke> @src Mu
23:49:17 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
23:51:02 <BMeph> :t mfix (return :: Cont a)
23:51:03 <lambdabot>     `Cont a' is not applied to enough type arguments
23:51:03 <lambdabot>     Expected kind `*', but `Cont a' has kind `* -> *'
23:51:03 <lambdabot>     In an expression type signature:
23:51:15 <BMeph> :t mfix (return :: Cont r a)
23:51:16 <lambdabot>     Couldn't match expected type `Cont r a'
23:51:16 <lambdabot>            against inferred type `a1 -> m a1'
23:51:16 <lambdabot>     In the first argument of `mfix', namely `(return :: Cont r a)'
23:51:34 <BMeph> :t mfix (return :: a -> Cont r a)
23:51:35 <lambdabot> forall a r. (MonadFix (Cont r)) => Cont r a
23:51:56 * BMeph is underwhelmed... :(
23:52:10 <BMeph> :t runCont . mfix (return :: a -> Cont r a)
23:52:11 <lambdabot> forall r a r1. (MonadFix (Cont r1)) => Cont r1 ((a -> r) -> r)
23:52:34 <BMeph> Okay, that wasn't what I wanted... :(
23:53:27 <dolio> I don't think there's an mfix for Cont, because no one can figure out what the right instance is.
23:53:28 <BMeph> :t runCont . mfix $ return
23:53:29 <lambdabot> forall r a. (MonadFix (Cont r)) => (a -> r) -> r
23:53:55 * BMeph smirks saucily!
23:53:57 <dolio> If there even is one.
23:57:09 <kmc> i was wondering that
23:57:14 <kmc> recursive continuations from outer space
23:57:57 <kmc> @unmtl Cont r a
23:57:57 <lambdabot> (a -> r) -> r
23:57:59 <kmc> @type mfix
23:58:00 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
23:58:21 <kmc> @unmtl (a -> Cont r a) -> Cont r a
23:58:21 <lambdabot> (a -> Cont r a) -> Cont r a
23:58:43 <kmc> @djinn (a -> (a -> r) -> r) -> (a -> r) -> r
23:58:43 <lambdabot> -- f cannot be realized.
23:59:26 <Saizan> there's an mfix for MonadRef ref m => ContT r m in some slides somewhere
23:59:42 <kmc> MonadRef?
23:59:57 <Saizan> as in "some monad with mutable references"
