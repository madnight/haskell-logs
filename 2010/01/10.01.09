00:00:24 <kmc> instance Category (->) where { id x = x; (f . g) x = f (g x) }
00:00:50 <DekuNut> Mmm
00:02:01 <DekuNut> I'm still lost kmc, but that's not your fault, I don't know enough about haskell or category I think to really put 2 and 2 together, I'm going to read more about both now and hopefully it'll click
00:02:05 <DekuNut> I appreciate you helping though
00:02:07 <kmc> cool :)
00:02:09 <kmc> good luck
00:02:12 <DekuNut> Thanks
00:02:19 <kmc> i don't know much CT and so can only explain via Haskell
00:02:34 <kmc> i knew Haskell pretty well before i started learning any CT at all
00:02:39 <kmc> but others have taken a different path
00:02:54 <DekuNut> Ah, well, maybe I'll try the same then
00:03:16 <DekuNut> Well, in the future when I think I've got it down, if you're about I'll try running it by you, you can crush my dreams if I've still got it wrong ;p
00:03:17 <DekuNut> :o
00:05:29 <kmc> :)
00:12:01 <gwern> Our revels now are ended
00:12:12 <gwern> These our actors, I foretold you
00:12:14 <gwern> were all spirits
00:12:22 <gwern> and are melted into AIr
00:12:25 <gwern> thin air
00:12:42 <gwern> if they have offended
00:12:48 <gwern> but think it,
00:13:00 <gwern> friends, and robin will make amends
00:14:55 <Gorbachev> Fuck you and your non-procedural language!
00:15:12 <gwern> that would have been funnier if you had been here for my shakespeare quoting
00:15:24 <Gorbachev> Haskell Curry was a crazy brain-damaged fuckhead.
00:15:30 <kmc> sigh
00:15:30 --- mode: ChanServ set +o Saizan
00:15:35 --- mode: Saizan set +b *!*=4858e6bd@gateway/web/freenode/x-vebkgdfrwwuqjrvp
00:15:35 --- kick: Gorbachev was kicked by Saizan (Saizan)
00:15:36 <kmc> amateur hour again
00:15:44 <Bacta> oh come on
00:15:49 <Bacta> he was just getting started!
00:15:59 <kmc> they don't even do their homework
00:16:14 <Berengal> Yeah, crappy trolls like that aren't even entertaining
00:16:28 --- mode: Saizan set -o Saizan
00:17:55 <jaspervdj> Does this channel suffer a lot from trolls? It's the first time I've seen this.
00:18:14 <Jafet> @protontorpedo
00:18:15 <lambdabot> check otu squeak seems dope
00:18:33 <gwern> @quote qwe
00:18:34 <lambdabot> glguy says: [concerning qwe1234] that God hasn't smote him yet is an argument against said God's existence..
00:18:46 <kmc> jaspervdj, i feel like there's been more trolling in recent weeks
00:19:06 <Guest51469> hi, lispy
00:19:33 <kmc> it is not hard to troll #haskell for real
00:20:00 <kmc> you just have to get confused and confrontational about how to convert IO String to String
00:20:03 <jaspervdj> Yeah, I suppose, this one was a little to obvious ;-)
00:20:16 <ivanm> kmc: heh
00:20:20 <Guest51469> Is 2010 the year of functional programming?
00:20:29 <Beelsebob> Guest51469: nope, linux on the desktop
00:20:31 <ivanm> @remember kmc it is not hard to troll #haskell for real; you just have to get confused and confrontational about how to convert IO String to String
00:20:32 <lambdabot> It is stored.
00:20:42 <Beelsebob> everything else has been delayed until that one's gone through
00:20:47 <ivanm> Beelsebob: _again_? I'm getting sick and tired of linux on the desktop
00:20:52 <kmc> 1958 is the year of functional programming
00:20:56 <ivanm> I want linux on the actual damn desk! ;-)
00:21:05 <Guest51469> I thought that most reviews said that Linux wasn't functional on the desktop
00:21:27 <ivanm> depends on how you define "functional"
00:22:06 <Guest51469> Also, if you are bored, check out my game clone http://github.com/glguy/set-game
00:22:10 <ivanm> most of those "reviews" are by people deliberately crippling linux or having unfair comparisons (omg, linux doesn't have support for <insert proprietary software here>! ergo, it sucks!)
00:22:16 <Guest51469> (specifically the vty branch)
00:22:24 <ivanm> preflex: seen glguy
00:22:24 <preflex>  glguy was last seen on #haskell 22 days, 13 hours, 42 minutes and 26 seconds ago, saying: Anyone familiar enough with the iteratee library to help me figure out what an EnumeratorN for converting streams of Char to streams of Word8 (using base 64) would look like?
00:22:34 <ivanm> Guest51469 == glguy?
00:22:51 <glguy`> better?
00:23:05 <jaspervdj> I thought 2010 was the year of the tiger, but I fixed that there http://img33.imageshack.us/img33/9539/1232818920ipkbe5.jpg
00:24:46 <glguy`> (also, I worked out the iteratee question I had 22 days ago)
00:25:51 <ivanm> I _suppose_ so...
00:26:07 <ivanm> jaspervdj: heh
00:26:22 <ivanm> \ tiger -> ..... ?
00:28:45 <kmc> ùÖ† it's the, eye of the tiger, it's the thrill of the fight ùÖ†
00:29:01 <Athas> @hoogle Monad m => (m a, m b) -> m (a, b)
00:29:02 <lambdabot> No results found
00:29:19 <kmc> :t liftM2 (,)
00:29:20 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m (a1, a2)
00:29:25 <Athas> Yeah, I just hate how that looks.
00:29:28 <kmc> :t uncurry $ liftM2 (,)
00:29:29 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => (m a1, m a2) -> m (a1, a2)
00:29:33 <kmc> yeah, it's not so pretty
00:29:36 <Athas> It's the beer gut operator.
00:29:42 <kmc> haha
00:32:19 * glguy remembers his nickserv password
00:36:52 <geir_> hrm.. I'm trying to build "platform" on Centos 5.x, and has managed after some crying and swearing to make it actually find the editline.so.0 library file. However, now it is making the following complaint :
00:36:56 <geir_> dist/build/System/Console/Editline/Readline.hs:1:0:
00:36:58 <geir_>     File name does not match module name:
00:36:59 <geir_> has anyone seen this?
00:37:02 <geir_>     Saw: `Main'
00:37:04 <geir_>     Expected: `System.Console.Editline.Readline'
00:37:47 <geir_> when looking into the file under packages/editline-0.2.1.0/dist/build/System/Console/Editline/Readline.hs
00:37:53 <geir_> it actually is empty
00:38:28 <geir_> is this file "generated" by some other part of the configure/make script?
00:40:52 <Cale> geir_: It's a lot less trouble on linux currently just to download the generic linux binary of GHC and then install cabal-install.
00:41:48 <Cale> I have no idea why Platform includes editline, since it's a stupidly broken library even when it does install correctly.
00:42:15 <geir_> Cale: ok. I've allready buildt and installed ghc, so I can do the same with cabal then I guess. There are no packegs in yum for centos.
00:42:35 <Cale> You shouldn't ever have to compile ghc yourself unless you're hacking on it.
00:42:36 <geir_> Thank you btw. :) I'll try your approach.. I've allready wasted a day using mine.
00:42:46 <Saizan> i guess it was required by ghci when they made the first platform and never got it you?
00:42:50 <Saizan> *out
00:42:55 <Cale> Saizan: I guess
00:43:12 <Saizan> ?hackage cabal-install
00:43:13 <lambdabot> http://hackage.haskell.org/package/cabal-install
00:43:38 <Cale> download the .tar.gz of cabal-install from Saizan's link and just run the bootstrap.sh script from it
00:44:39 <geir_> thanks
00:44:39 <Cale> geir_: But just for the future, building GHC from source is typically a massive waste of time, since you need a GHC binary in the first place, so you might as well just install the binary version of the one you want anyway.
00:45:14 <Cale> (if your package manager doesn't have it, the generic one typically works well)
00:46:24 <geir_> yeah.. I found it now. My eyes skiped it when I originally downloaded I think.. :) I took the source packages below them.
00:50:13 <ivanm> Cale: bah, I build my ghc from source!
00:50:28 <ivanm> I also first build the bootstrapping ghc from source first as well so that I can build ghc from source!
00:50:28 <ivanm> ;-)
00:51:53 <Cale> Are you building it on a new platform?
00:52:01 <ivanm> nope
00:52:13 <geir_> Cale / Saizan : Thank you both. Up and running. You have been most helpfull.
00:52:14 <ivanm> but I _do_ build the bootstrapping binaries for all x86 gentoo users to use ;-)
00:56:58 <Cale> Gentoo's distribution model would be better if the second law of thermodynamics weren't as true. I'm totally blaming the heat-death of the universe on it.
00:59:17 <drhodes> all that compiling, who needs central heating?
00:59:24 <Athas> Each time you install Gentoo, another polar bear drowns.
00:59:38 * drhodes calls al gore
01:00:30 <HaskellLove> It would have been lot better if you can just say :: Num instead of 3+5 :: Num a => a
01:00:30 <lambdabot> HaskellLove: You have 1 new message. '/msg lambdabot @messages' to read it.
01:07:06 <Gracenotes> lot better? surely not.. them type theorists would be angry
01:08:39 <Cale> I think you could get away with a syntax like that if and only if it was an alternative to the existing one. You still need a way to express when two things are the same type and not just an arbitrary one belonging to that class.
01:14:58 <ivanm> Cale: guilty as charged! ;-)
01:15:16 <ivanm> drhodes: with the climate where I'm at, I don't need central heating in the first place!
01:15:46 <ivanm> Cale: yeah, the problem with that kind of syntax is that it isn't obvious if Num is a type or a class
01:15:51 <ivanm> maybe if you had ::: Num or something...
01:16:14 <Cale> Well, you'd have to put types and classes in the same namespace
01:16:14 <ivanm> but how often do you have something like that with just _one_ value (i.e. not a function) which will let you do that?
01:16:17 <drhodes> grey snowbanks until may here. May! ivanm .
01:16:27 <Cale> :t fromIntegral
01:16:28 <lambdabot> forall a b. (Integral a, Num b) => a -> b
01:16:34 <ivanm> May? that's when it starts to get a tad chilly...
01:16:42 <Cale> We would be able to write  fromIntegral :: Integral -> Num
01:16:50 <Cale> also, you could use functional dependencies
01:16:56 <ivanm> drhodes: I can quite proudly say that I've never seen snow before!
01:17:05 <Cale> But yeah, it would get confusing quickly
01:17:15 <ivanm> Cale: yes, but how can you (either as someone reading the code or a parser/compiler) tell if Num is a class or a type?
01:17:15 <ivanm> yeah
01:17:28 <Cale> By looking up the definition of Num
01:17:35 <dolio> Cale: They're already in the same namespace.
01:18:28 <Cale> dolio: I thought so, but didn't feel like checking
01:18:51 <dolio> That is, GHC says so. I'm not really sure what the report specifies.
01:19:27 <HaskellLove> did you guys ever needed to disable monomorphism restriction?
01:19:32 <Cale> often
01:19:54 <Cale> It's widely considered a mistake in the standard
01:20:36 <HaskellLove> Cale can you give me some typical cases please where i would use -fno-monomorphism-restriction?
01:20:58 <ivanm> does Haskell10 remove it?
01:20:59 <HaskellLove> in the book it does not say anything, just explains what it is
01:21:01 <ivanm> I can't recall...
01:21:06 <ivanm> HaskellLove: which book?
01:21:14 <ivanm> HaskellLove: RWH has a good section the monomorphism restriction
01:21:15 <Cale> ivanm: no
01:21:25 <ivanm> @google monomorphism restriction real world haskell
01:21:26 <lambdabot> http://book.realworldhaskell.org/read/using-typeclasses.html
01:21:26 <lambdabot> Title: Chapter 6. Using Typeclasses
01:21:27 <ivanm> Cale: :(
01:21:30 <Cale> ivanm: Haskell 2010 doesn't change much of interest at all
01:22:16 <paolino> HaskellLove: when I'm too lazy to write a signature is my case
01:22:36 <ivanm> yeah, it's stuff that's from the revisions, etc. of 98 + stuff everyone uses for the most part
01:22:47 <ivanm> HaskellLove: see http://book.realworldhaskell.org/read/using-typeclasses.html
01:23:53 <Cale> ivanm: If it was even just the stuff which everyone uses, that would be good, but it somehow failed to even get that far
01:24:16 <HaskellLove> ivanm this one http://upload.wikimedia.org/wikibooks/en/2/26/Haskell.pdf
02:05:59 <Zr40_> I see what point-free style is, but what does it actually offer? Is it just considered cleaner, or are there other benefits as well?
02:06:41 <Jafet> It's pointless
02:06:46 <Cale> Well, one nice thing about writing f . g . h $ x in place of f (g (h x)) is that the first effectively has more subexpressions, because (.) is associative
02:06:58 <Cale> So g . h, for example, is meaningful on its own
02:07:09 <Cale> as is f . g
02:09:16 <Cale> Going too far in making things points-free can result in an unreadable mess, but where you draw the line can be a matter of taste.
02:09:38 <Cale> It can also clean things up a lot
02:10:17 <Zr40> I mean, is it only useful for me, or does Haskell/ghc do things differently?
02:12:05 <Cale> Zr40: hm?
02:12:32 <Cale> Oh, you shouldn't expect any difference in the generated code
02:14:02 <gio123> Cale: hi
02:14:08 <Cale> gio123: hello
02:14:17 <gio123> pm?
02:17:34 <Athas> How do I control which version of, say, Parsec is used by GHCi?
02:18:04 <Athas> Specifically, it seems to be using 2.x, but I want 3.x (my program compiles fine through Cabal where I know how to ask for the right version).
02:18:05 <Berengal> Athas: :set -hide-package
02:18:15 <Berengal> And -package
02:18:53 <Berengal> Look at the ghc manual. You can apply the same options for controlling visible packages to ghci as you can to ghc
02:19:05 <Athas> Thanks.
02:19:44 <Berengal> I've also found it useful to write a small script that calls ghci with the same arguments cabal calls ghc...
02:20:51 <opqdonut> nice
02:21:04 <opqdonut> that needs to be integrated into cabal IMO
02:21:08 <opqdonut> or something like that
02:21:12 <Berengal> There are plans to
02:21:16 <opqdonut> good
02:21:17 <Berengal> cabal ghci, or some command like that
02:21:22 <opqdonut> mhmm
02:21:24 <Berengal> At least that's what I'm told
02:22:44 <b_jonas> hello,
02:22:56 <Berengal> Hi
02:23:25 <b_jonas> if I reinstall ghc 6.12.1 to the same prefix, will I lose the libraries I installed? if so, how do I recover them?
02:24:09 <b_jonas> I want to try to fix that broken library problem by reinstalling ghc because some of the libraries it affects are core libraries
02:24:36 <b_jonas> and I suspect it might have been me breaking stuff by installing some older library from hackage over a newer one that comes with ghc
02:25:48 <Berengal> ghc isn't ABI compatible between versions
02:25:55 <Berengal> Even minor versions
02:26:20 <Berengal> So all libraries have to be recompiled with the new compiler
02:26:39 <Athas> Huh, is it Text.ParserCombinators.Parsec or Text.Parsec that's the modern version?
02:26:50 <Cale> Text.Parsec
02:28:22 <Athas> Odd, it looks like I'm getting Parsec 2.x despite specifying parsec==3.* in my .cabal.
02:28:50 <Athas> Specifically, the kind of GenParser is the '* -> * -> * -> *' of 2.x, not the '* -> * -> *' of 3.x.
02:31:57 <opqdonut> :k Text.Parsec.String.GenParser
02:31:58 <lambdabot> * -> * -> * -> *
02:32:34 <opqdonut> hayoo shows parsec-3.0.1 providing Text.Parsec
02:34:53 <Athas> Wait, then what's up with http://hackage.haskell.org/packages/archive/parsec/3.0.1/doc/html/Text-Parsec-String.html#t%3AGenParser ?
02:35:01 <Athas> Is the documentation wrong?
02:36:22 <Cale> 2.x also provide Text.Parsec
02:37:15 <Athas> Right, but the documentation linked above says 3.0.1, yet the kind for GenParser differs from the one claimed by lambdabot (and my own GHC).
02:37:43 <opqdonut> well there's no way of knowing which Parsec lambdabot has, right?
02:37:48 <opqdonut> i mean, at least not over irc
02:38:21 <Cale> hmm
02:38:30 <opqdonut> there really should be something like Hie.Rarchy.Package.version
02:38:38 <opqdonut> or __version__ or whatever
02:39:34 <Athas> The documentation must be wrong.  Everything on my end claims to be 3.0.1.
02:39:42 <Athas> How frustrating.
02:39:48 <Cale> uh, what?
02:39:59 <Gracenotes> the version is a lie
02:40:03 <Cale> I see that in 3.0.1, GenParser has kind * -> * -> * -> *
02:40:49 <Cale> But the haddock documentation doesn't tell you the kind, so how are you determining it?
02:40:51 <Athas> Hmm, I think I was confused by some earlier output.
02:41:14 <Cale> ParsecT :: * -> * -> (* -> *) -> * -> *
02:41:31 <Cale> type Parsec s u = ParsecT s u Identity
02:41:45 <Cale> So  Parsec :: * -> * -> * -> *
02:41:54 <Cale> type GenParser tok st = Parsec [tok] st
02:42:04 <Cale> So GenParser has the same kind as Parsec
02:42:39 <Athas> Yes, you are correct, I was confused.
02:51:21 <ivanm> preflex: seen cjs
02:51:21 <preflex>  cjs was last seen on #haskell 31 days, 3 hours, 3 minutes and 38 seconds ago, saying: I didn't realize that Haddock generated an index-frames.html as well.
02:55:26 <b_jonas> Berengal: it's the same version, 6.12.1, from the same source
02:55:50 <b_jonas> Berengal: only I'm getting these strange problems
02:56:34 <b_jonas> these: http://erxz.com/pb/22657
02:56:55 <b_jonas> and I can't install some cabal libraries like hexpat because they complain that the haskell98 library is broken
02:57:03 <Spockz> is there a function that given a data type will give me the name of the constructor it was built with?
02:58:55 <b_jonas> Berengal: it's good to know that though, so thanks
02:58:59 <jaspervdj> anyone here who read "Purely Functional Data Structures" by Chris Okasaki? And would you recommend the book?
02:59:00 <bob0> jaspervdj: no
02:59:16 <b_jonas> that likely means it will forget about the libraries
02:59:25 <b_jonas> jaspervdj: I lent it once but didn't read all of it
02:59:27 <b_jonas> I liked it
02:59:36 <b_jonas> in particular it explains red-black trees well
02:59:53 <Cale> anyone here who thinks bob0 is a bot who responds to any question beginning with "anyone here" with "no"?
02:59:53 <bob0> Cale: no
03:00:01 --- mode: ChanServ set +o Cale
03:00:13 * RayNbow has read a small part of Okasaki's book
03:00:20 --- mode: Cale set +b *!*@unaffiliated/bob0
03:00:21 --- kick: bob0 was kicked by Cale (Cale)
03:00:25 <b_jonas> jaspervdj: did you look at the thesis first though? it has some (but not all) of the material of the book
03:00:32 --- mode: Cale set -o Cale
03:00:39 <b_jonas> the book is harder to get, the thesis is available on the net for free
03:00:51 <jaspervdj> b_jonas: okay, I'll do that
03:00:58 <RayNbow> b_jonas: harder to get?
03:01:19 <b_jonas> RayNbow: I did read some of it, so I know
03:01:33 <b_jonas> harder to acquire a copy physically I mean
03:01:34 <jaspervdj> But I saw the book was only 27 euro for the hardback on bookdepository, so I'm probably getting it
03:02:00 <RayNbow> b_jonas: it's not out of print or anything? :p
03:03:04 <b_jonas> RayNbow: nah, it's just that specialized foreign language books like that that no-one here reads aren't easy to get here, and functional programming is just not in fashion here so few people need it
03:03:25 <b_jonas> you could probably order it if you actually wanted to buy
03:03:39 <b_jonas> I only wanted to lend it though, and it's only in one departmental library
03:03:42 * RayNbow buys nearly all of his books online nowadays
03:04:05 <b_jonas> I don't want to buy too many books, I don't have shell space for them
03:04:47 <RayNbow> heh
03:05:07 <b_jonas> so do you suppose reinstalling ghc would be a good idea, and if so, how do I restore the packages installed then? or should I just try to reinstall the random library from the core somehow?
03:05:20 <b_jonas> and, eh, why can't it just work
03:05:26 <ivanm> *sigh* why do most beamer themes consist solely of blacks, blues and purples?
03:05:30 * RayNbow bought a book case a long while after he noticed his books started to pile up...
03:06:15 <RayNbow> after filling the book case with my books, it was already, say..., 80% full :p
03:08:21 <ivanm> RayNbow: heh
03:13:24 <Cale> ivanm: DO NOT QUESTION THE OFFICIAL LOOK OF BEAMER. YOU WILL ENJOY THE SAME COLOURS AS EVERYONE ELSE.
03:13:31 <ivanm> heh
03:34:35 <mmaruseacph2> is it normal for darcs to block?
03:34:49 <mmaruseacph2> i've tried a darcs get for frag
03:34:57 <mmaruseacph2> but it stopped at patch 4/6
03:35:02 <mmaruseacph2> (first time using it)
03:38:27 <ivanm> not usually it doesn't
03:38:33 <ivanm> but if there's network problems, etc. ...
03:38:53 <HaskellLove> I understood the difference between a data type and a classtype or typeclass as haskellers call it. With data type you just pack data suitable to your needs but later you write functions to work with them. But with typeclass you make make a type but also provide functions to deal with it.
03:39:03 <HaskellLove> I might be wrong though...
03:39:18 <Heffalump> when you declare a typeclass you don't make a type
03:39:44 <Heffalump> when you declare a typeclass instance you are just making a global statement about a particular type being in that class.
03:48:51 <HaskellLove> "The difference between let and where lies in the fact that let foo = 5 in foo + foo is an expression, but foo + foo where foo = 5 is not." Is this done with some reason behind?
03:49:10 <ivanm> where's that from?
03:49:20 <HaskellLove> the book i told you
03:49:30 <ivanm> IIRC, <foo> where <bar> desugars to let <bar> in <foo>
03:49:38 <ivanm> the wikibook?
03:49:43 <ivanm> @where wikibook
03:49:44 <lambdabot> http://en.wikibooks.org/wiki/Haskell
03:49:49 <Beelsebob> ivanm: it does ‚Äì but only if it's on the right hand side of a function
03:49:55 <Beelsebob> you can't use where in arbitrary places
03:50:02 <ivanm> Beelsebob: right
03:50:13 <ivanm> oh, right, you can shove let in anywhere
03:50:29 <BONUS> where is useful because it can span across guards
03:50:32 <ivanm> HaskellLove: so you can say \ x -> (let y = x + 1 in y*x), but you can't use a where statement in there
03:50:37 <ivanm> BONUS: yup
03:50:51 <ivanm> BONUS: and I find it neater to have all that at the end of a function rather than at the beginning
03:51:03 <ivanm> (more horizontal line space for starters!)
03:51:16 <HaskellLove> BONUS oh yeah i have done that thousand times, really cool use of  where and guards
03:53:43 <HaskellLove> ivanm i dont get your explanation above, sorry? I mean, why not, \ x -> (y*x where y = x + 1)
03:53:58 <b_jonas> you could shove 'let { r = foo + foo where { foo = 5; }; } in r' anywhere
03:54:00 <ivanm> HaskellLove: because it isn't designed to work that way ;-)
03:54:07 <b_jonas> and then you can use where inside an expression
03:54:17 <ivanm> b_jonas: yes, but that's cheating ;-)
03:54:21 <b_jonas> but I just don't like postfix where
03:54:27 <b_jonas> I just don't like it for some reason
03:54:37 <ivanm> b_jonas: well, I don't know of any other type of where... ;-)
03:55:03 <b_jonas> there's module where, class where, instance where, gadt where, ...
03:56:06 <b_jonas> (otoh I like these new pattern guards)
03:57:10 <ivanm> true
03:57:19 <ivanm> but you could consider them all to be the same thing
03:57:28 <ivanm> you define a module, where the definitions are
03:57:33 <ivanm> same with a class
03:57:43 <ivanm> not sure about gadts since I haven't used them
04:00:02 <b_jonas> maybe that's the analogy why they're reusing the same keyword
04:01:04 <b_jonas> I mean, 'case' is using a different keyword 'of' because it's not followed by stuff that looks like definitions and type declarations, but with 'pattern | guards -> expr' things
04:03:15 <HaskellLove> what was the haskell specific problems web site? Someone compared it to eulers, but instead you concentrate on haskell stuff...
04:05:00 <DigitalKiwi> there was this one that wasn't haskell specific but had like thousands of challenges and like 80 languages or something but I forgot the name :(
04:05:04 <DigitalKiwi> anyone know it?
04:12:35 <mauke_> DigitalKiwi: spoj.pl?
04:12:59 <DigitalKiwi> yes!
04:13:08 <DigitalKiwi> much thanks
04:13:39 <DigitalKiwi> oh it's only 41 languages :(
04:25:03 <HaskellLove> wow observe is so cool, you guys use it ?
04:25:26 <HaskellLove> DigitalKiwi yeah cool site, got it bookmarked, like the euler project is not already giving me headaches...heh
04:54:09 <lpsmith> hackage is still down?
04:54:13 <lpsmith> dang
04:55:08 <lpsmith> wait, n/m
05:06:09 <b0fh_ua> Hi there! Can somebody please explain - does the code at http://pastebin.com/d71fcabc8 conforms to CPS, and what is the "c" type in function defined (I've got it from haskell with :t in fact)
05:11:29 <Cale> b0fh_ua: The c means that parameter goes unused.
05:12:06 <b0fh_ua> Cale: nice
05:12:13 <Cale> b0fh_ua: As you can see, because the y bound by the lambda goes unused
05:12:23 <b0fh_ua> Cale: yeah, I see
05:12:35 <b0fh_ua> and that makes me think that I did something wrongly
05:13:47 <Cale> Well, it doesn't really look like a CPS version of map to me... Normally when you transform something into CPS, it takes an extra function parameter which gets what would otherwise be the result of the function.
05:14:33 <b0fh_ua> yes, I feel so
05:15:08 <b0fh_ua> I don't like the fact that I used to pass xs to g and to mycmap itself
05:17:39 <b0fh_ua> btw that cps stuff looks like inter-recursion, when A calls B and B in turn calls A
05:27:56 <Zariel> Why does this happen ? http://pastebin.com/d4600307f
05:32:45 <Beelsebob> > fromEnum 1.4291596e11
05:32:46 <lambdabot>   142915960000
05:33:07 <Beelsebob> > toEnum 142915960000
05:33:09 <lambdabot>   * Exception: Prelude.Enum.().toEnum: bad argument
05:33:14 <Beelsebob> > toEnum 142915960000 :: Float
05:33:15 <lambdabot>   1.4291596e11
05:33:33 <Beelsebob> > toEnum (fromEnum 1.4291596e11) :: Float
05:33:34 <lambdabot>   1.4291596e11
05:33:44 <Beelsebob> Zariel: looks like a bug ‚Äì it happens on my system too
05:33:48 <Beelsebob> 64 bit compilation bug?
05:34:03 <Zariel> 64bit
05:34:15 <FauxFaux> Comparing floats with == bug?  No suprise.
05:34:22 <doserj> > (toEnum (fromEnum 1.4291596e11)::Float) == 1.4291596e11
05:34:23 <lambdabot>   True
05:34:35 <doserj> int overflow
05:34:37 <Beelsebob> FauxFaux: no, those two really should be equal, and anyway, the result is *massively* different on my system
05:34:46 <Beelsebob> doserj: Int and Float are the same size on my system
05:34:53 <Beelsebob> but I still see the bug
05:35:04 <doserj> > fromEnum 1.4291596e11
05:35:05 <lambdabot>   142915960000
05:35:16 <doserj> > maxBound::Int32
05:35:17 <lambdabot>   2147483647
05:35:22 <doserj> Int overflow
05:35:33 <Beelsebob> why on earth does it overflow though...
05:35:38 <Beelsebob> there are 2^32 possible floats
05:35:42 <Beelsebob> and 2^32 possible ints
05:35:53 <doserj> > fromEnum (1::Float)
05:35:53 <Beelsebob> so it *should* be able to enumerate them
05:35:54 <lambdabot>   1
05:36:06 <doserj> Enum for floats doesn't enumerate
05:36:10 <Beelsebob> oh, lame
05:36:18 <Beelsebob> so yeh, a Bug
05:36:20 <Beelsebob> but not where I thought
05:36:52 <doserj> > [1.0..10.0] -- that's the reason
05:36:53 <lambdabot>   [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0]
05:37:14 <Beelsebob> oh, duh
05:37:28 <doserj> but it is unfortunate
05:37:53 <Zariel> why does this not work if I use ints? http://github.com/Zariel/euler-haskell/blob/6ae1139e752437745c931e3a18e7e64abdad0fc7/10.hs
05:38:32 <Beelsebob> Zariel: what doesn't work
05:38:33 <Beelsebob> ?
05:38:45 <Zariel> it gives the wrong answer
05:38:50 <Zariel> when summed
05:39:09 <Beelsebob> then that's probably the answer
05:39:12 <Beelsebob> you're adding lots of large ints
05:39:18 <Beelsebob> which will result in an even larger int
05:39:30 <Beelsebob> (probably larger than 2^32)
05:40:17 <Zariel> if I do it with doubles i get the issue described earlier
05:40:35 <Beelsebob> for reference ‚Äì you can use infinite lists in Haskell
05:40:36 <Beelsebob> use them
05:40:52 <Beelsebob> if you use the infinite list of primes, you can use that in the definition of the infinite list of primes
05:40:55 <Beelsebob> to try dividing against
05:41:04 <Beelsebob> Zariel: try it with Integers then
05:43:40 <Beelsebob> > let primes = 2 : [p | p <- [3,5..], isPrime p] where isPrime p = not (any (\d -> x `mod` d == 0) (takeWhile (< (iSqrt x)) primes)) where iSqrt = ceiling  sqrt . fromIntegral in take 10 primes
05:43:41 <lambdabot>   No instances for (GHC.Real.RealFrac (a -> a),
05:43:41 <lambdabot>                    GHC.Real.I...
05:43:46 <Beelsebob> bugger
05:44:39 <Berengal> > 2 : nubBy (\x y -> mod x y == 0) [3,5..]
05:44:40 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
05:44:54 <Beelsebob> Berengal: right, I was trying to show something closer to what he had already
05:45:14 <Beelsebob> > let primes = 2 : [p | p <- [3,5..], isPrime p] where isPrime x = not (any (\d -> x `mod` d == 0) (takeWhile (< (iSqrt x)) primes)) where iSqrt = ceiling  sqrt . fromIntegral in take 10 primes
05:45:15 <lambdabot>   No instance for (GHC.Real.RealFrac (a -> a))
05:45:15 <lambdabot>    arising from a use of `GHC....
05:45:20 <Beelsebob> bugger more
05:45:58 <Beelsebob> > let primes = 2 : [p | p <- [3,5..], isPrime p] where isPrime x = not (any (\d -> x `mod` d == 0) (takeWhile (< (iSqrt x)) primes)) where iSqrt = ceiling . sqrt . fromIntegral in take 10 primes
05:46:00 <lambdabot>   [2,3,5,7,9,11,13,17,19,23]
05:46:14 <Beelsebob> > let primes = 2 : [p | p <- [3,5..], isPrime p] where isPrime x = not (any (\d -> x `mod` d == 0) (takeWhile (< (iSqrt x)) primes)) where iSqrt = ceiling . sqrt . fromIntegral in primes
05:46:16 <lambdabot>   [2,3,5,7,9,11,13,17,19,23,25,29,31,37,41,43,47,49,53,59,61,67,71,73,79,83,8...
05:46:19 * Berengal likes primes = 2 : filter isPrime [3,5..]; isPrime = (==) <*> head . factorize; factorize n = go n primes where go [...]
05:46:26 <Beelsebob> I have 9 in there
05:46:29 <Beelsebob> why do I have 9 in there
05:46:47 <doserj> because 3 is not smaller than 3
05:46:49 <Berengal> Beelsebob: <= iSqrt
05:46:51 <Beelsebob> Berengal: that is nice, yes
05:46:56 <Beelsebob> ah, well spotted
05:47:03 <Beelsebob> > let primes = 2 : [p | p <- [3,5..], isPrime p] where isPrime x = not (any (\d -> x `mod` d == 0) (takeWhile (<= (iSqrt x)) primes)) where iSqrt = ceiling . sqrt . fromIntegral in primes
05:47:07 <lambdabot>   mueval-core: Time limit exceeded
05:47:17 <Beelsebob> splode \o/
05:47:49 <Beelsebob> > let iSqrt = ceiling . sqrt . fromIntegral in iSqrt 3
05:47:50 <lambdabot>   2
05:48:07 <Beelsebob> ah, suckage
05:48:36 * Beelsebob ponders how to fix that in a nice way
05:49:48 <Beelsebob> I can ofc fix it in a nasty way...
05:50:04 <Beelsebob> > let primes = 2 : 3: [p | p <- [5,7..], isPrime p] where isPrime x = not (any (\d -> x `mod` d == 0) (takeWhile (<= (iSqrt x)) primes)) where iSqrt = ceiling . sqrt . fromIntegral in primes
05:50:08 <lambdabot>   mueval-core: Time limit exceeded
05:50:24 <Beelsebob> oh, no, that still explodes on every square
05:50:25 <Beelsebob> >.<
05:50:33 <Berengal> > let primes = 2:3: [n | n <- [5,7..], all (\p -> mod n p /= 0) $ takeWhile (<= (floor . sqrt . fromIntegral $ n)) primes ] in primes
05:50:45 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
05:50:51 <Beelsebob> heh
05:51:46 <Zariel> works with Int64's
05:52:00 <Beelsebob> Zariel: no surprise
05:52:08 <Beelsebob> if you want it to work with anything, use Integer
05:52:11 <Beelsebob> not Int or Int64
05:52:30 <Beelsebob> Integer can store infinitely* large integers
05:52:36 <Beelsebob> * for small definitions of infinite
05:52:52 <Raevel> unrestrictedly large integers?
05:53:06 <opqdonut> well, only restricted by your memory
05:53:07 <Beelsebob> still not quite right
05:53:16 <doserj> arbitrarily large integers. there are no infinitely large integers
05:53:22 <Berengal> Restricted by memory, but we pretend memory doesn't exist.
05:54:11 <Raevel> my professor always corrects me when i say infinite :-P
05:54:39 <opqdonut> you're on the wrong courses if they only deal with finite things :)
05:55:00 <Berengal> data IPlus = NegativeInfinity | Finite Integer | PositiveInfinity
05:55:45 <opqdonut> why have separate Negative and Positive infinities
05:55:53 <maltem> Raevel, sometimes the distinction is important between infiinitely large, or arbitrarily large
05:56:10 <Berengal> forall x. NegativeInfinity <= x and x <= PositiveIntinity
05:56:29 <ivanm> anyone knkow who Peter Bartke is?
05:56:29 <opqdonut> ah yes for ordering purposes
05:56:32 <Berengal> opqdonut: Because I don't have separate signs
05:56:41 <opqdonut> for arithmetic one infinity suffices IIRC
05:58:24 <ivanm> because, whoever he is, he should be shot for the atrocious mess that he did for the listings defaults
05:58:34 <ivanm> I mean, including every single Prelude function as a keyword? really?
05:59:10 <koeien37> aw yes I noticed that
05:59:12 * Berengal must now google
05:59:22 <koeien37> normally I use lhs2TeX though
06:00:20 * Berengal fails to find anything of obvious relevance
06:00:35 <koeien37> yeah I scratched my head when "head" was bold
06:01:29 <Berengal> Where  is this?
06:02:00 <opqdonut> Berengal and his existensial questions
06:02:30 * Berengal thinks he is more of a forall kind of guy
06:04:10 <ivanm> koeien37: I just want to embed a small snippet of code into a slide; using lhs2tex for that is an utter waste IMHO
06:04:29 <ivanm> gwern: you around?
06:05:20 <koeien37> ivanm: yeah i"ve used listings for that purpose too
06:05:32 <koeien37> just a small snippet
06:05:58 <ivanm> yeah, that's what I've normally used, but I want to add colour to it
06:07:01 * ivanm installs source-highlight to see how it fares
06:13:34 <andrewe> Can someone get me out of this loop, please? 1. cabal update => reports there's a new version of cabal-install, 2. cabal install cabal-install 3. goto 1
06:14:32 <Axman6> you don't have ~/.cabal/bin in your PATH before `which cabal`
06:15:04 <doserj> cabal install cabal-install-0.8.0
06:15:26 <andrewe> Axman6: I didn't know I have to.
06:16:13 <Axman6> well, you do :)
06:19:10 <andrewe> Axman6: thanks, it works now, I think this should be documented here http://www.haskell.org/haskellwiki/Mac_OS_X .
06:19:36 <Axman6> i'm sure it's documented elsewhere. but go ahead and add it :)
06:19:54 <Axman6> unless you don't have an account, then i guess i could do it
06:21:05 <gwern> ivanm: I dreamed I committed suicide last night
06:21:21 <gwern> ivanm: so either I'm still dreaming I'm dead or I'm here
06:21:27 <ivanm> heh
06:21:44 <ivanm> gwern: do you know if highlighting-kate supports latex output?
06:21:47 <ivanm> or is it only html?
06:22:06 <gwern> ivanm: pandoc only highlights html; I believe that's a -kate limitation as well
06:22:17 <gwern> athough I'd have to check
06:22:33 <HaskellLove> (>>=) :: forall a b. m a -> (a -> m b) -> m b I am learning monads, but i cant understand this type. It takes a monad of value a right? and a function that takes a value of type a and turns it into a monad of some other value b, and then the final result is a monad of b.It is too abstract can someone please give me an example
06:22:46 <ivanm> gwern: *nod*
06:23:04 <ivanm> HaskellLove: very simply, you get a monad, extract the value out of it then apply the function on it
06:23:05 <koeien37> your terminology is a little bit strange
06:23:14 <gwern> ivanm:  ConTexT output doesn't highlight, no
06:23:17 <ivanm> (this is wrong since in many cases you can't "extract" the value)
06:23:26 <koeien37> it takes a monadic value of type m a, a function a -> m b, and results in a value of type m b
06:23:44 <koeien37> Let's take an example monad, Maybe
06:23:47 <Twey> > Just 5 >>= return . succ
06:23:49 <lambdabot>   Just 6
06:23:57 <gwern> ivanm:  see Text.Highlighting.Kate.Format
06:24:01 <Axman6> HaskellLove: concatMap is the how >>= is defined for the list monad
06:24:02 <koeien37> then (>>=) is of type,    Maybe a -> (a -> Maybe b) -> Maybe b
06:24:10 <koeien37> Axman6: well, flip concatMap
06:24:21 <maltem> HaskellLove, that's all exactly right, and that's really all there is to it. Except, please don't say "it takes a monad", because a monad is a structure resp. a type constructor, not a value.
06:24:33 <Axman6> i was going to say it was,how >= is defined koeien37, but then rtemembered that ;)
06:24:51 <Axman6> > concapMap (\x -> [x,-x]) [1..10]
06:24:52 <lambdabot>   Not in scope: `concapMap'
06:24:58 <Axman6> > concatMap (\x -> [x,-x]) [1..10]
06:25:00 <lambdabot>   [1,-1,2,-2,3,-3,4,-4,5,-5,6,-6,7,-7,8,-8,9,-9,10,-10]
06:25:16 <Axman6> > [1..10] >>= (\x -> [x,-x])
06:25:17 <lambdabot>   [1,-1,2,-2,3,-3,4,-4,5,-5,6,-6,7,-7,8,-8,9,-9,10,-10]
06:25:29 <koeien37> coincidence? I think not
06:25:34 <copumpkin> zomg
06:27:25 <Axman6> @src Maybe (>>=)
06:27:26 <lambdabot> (Just x) >>= k      = k x
06:27:26 <lambdabot> Nothing  >>= _      = Nothing
06:29:00 <Axman6> HaskellLove: are you willing to take my advice? i showed you a link a while ago, which is what really get me to understand the workings of monads (http://blog.tmorris.net/20-intermediate-haskell-exercises/) is highly suggest you take a look at it, and ask us questions about it
06:29:08 <HaskellLove> I think i understand, I will keep reading. Wow after a month in haskell, i start learning monads. Now it makes more sense and i continue reading the book from where i stopped
06:29:15 <Axman6> s/is/I
06:29:31 <koeien37> Fluffy
06:29:32 <koeien37> zomg
06:29:38 <Axman6> :)
06:29:42 <copumpkin> OMG SO CUTE
06:30:28 <koeien37> I'm not sure the "relative difficulty" is correct, but whatever
06:30:28 <Axman6> HaskellLove: if you can fill in all those definitions, you will understand the Functor and Monad classes quite well indeed
06:30:31 <koeien37> that's hard to estimate anyway
06:30:36 <koeien37> Axman6: sshshshshhshs
06:30:42 <Axman6> i found them pretty accurate
06:30:46 <koeien37> s/Functor/Fluffy
06:30:52 <koeien37> s/Monad/Misty
06:30:55 <copumpkin> Axman6: not sure I'd say he'll understand those, but he'll have a better idea of types at least
06:31:00 <Axman6> koeien37: yeah... i found it easier once i figured out what i was actually implementing :)
06:31:02 <copumpkin> which is pretty fundamental
06:31:22 <koeien37> s/he forgets the laws though
06:31:34 <koeien37> although I don't think that'll be a huge problem
06:32:26 <koeien37> haha, I love the names of those functions
06:32:33 <koeien37> the slight hint to the real name is awesome
06:32:53 <copumpkin> we should ask dibblego for some more
06:32:59 <copumpkin> write loop for (->)
06:33:04 <koeien37> arrow instances
06:33:07 <copumpkin> that should keep people on their feet for a while
06:33:40 <copumpkin> I don't really think the connection to monads in that page is terribly useful
06:33:47 <copumpkin> it's more of a proof practice
06:39:22 <lpsmith> HaskellLove,  have you ever covered Induction in say, a discrete math class?
06:40:17 <lpsmith> understanding what an induction hypothesis is greatly helps coming up with a recursive function
06:40:19 <HaskellLove> lpsmith I have read about logic and philosophy on induction, and of course have used induction all the time while programming, inducing property for more members in a set based on one or two members having the property
06:40:33 <HaskellLove> lpsmith yeah i know, i am not that dumb ;)
06:40:35 <copumpkin> HaskellLove: induction over naturals?
06:40:48 <HaskellLove> succ and pred and 0
06:40:49 <elly> copumpkin: induction over the reals is how real mathematicians do it :)
06:40:52 <HaskellLove> or church numerals
06:40:53 <copumpkin> lol
06:40:57 <lpsmith> well,  recursion and induction are almost the same thing
06:41:25 <elly> I take issue with your use of the word 'almost' :P
06:41:27 <copumpkin> HaskellLove: I mean, would you be able to prove that the sum of the first n odd numbers is n^2 by induction, for example?
06:41:30 <elly> they are identical :P
06:42:34 <HaskellLove> copumpkin well sounds like recursive function i guess i can do it
06:42:48 <mauke_> copumpkin: counterexample: n = 0
06:43:00 <copumpkin> sum of 0 odd numbers is 0^2?
06:43:01 <elly> the sum of the first 0 odd numbers is certainly 0
06:43:05 <lpsmith> :)
06:43:08 <mauke_> oh, woops
06:43:13 * mauke_ kicks brain
06:43:23 <copumpkin> how about first -1 odd numbers?!
06:43:39 <b_jonas> did I tell you my favourite programming exercise yet?
06:43:50 <elly> to borrow prolog for a moment, add(X,Z,X). add(X,s(Y),s(Z)) :- add(X,Y,Z).
06:44:54 <Axman6> i should learn prolog sometime
06:45:03 <elly> it is quite pretty for some tasks
06:45:18 <b_jonas> consider those 7 x 7 tables where each row and each column is the permutation of [0,0,0,1,1,2,2], there are no two identical rows, and no two identical columns.
06:45:19 <elly> the prolog maze solver is an almost legendary example of the power of builtin backtracking search
06:45:42 <HaskellLove> prolog kicks ass
06:45:59 <mauke_> backtracking? sounds like something you could solve with regexes
06:46:10 <b_jonas> first, compute the number of such tables. then compute the number of such tables starting with the two rows given in the input.
06:46:17 <copumpkin> haskell typesystem allows some amount of logic progamming
06:46:20 <elly> solve(X,Y,[X,Y]) :- edge(X,Y). solve(X,Z,[X | S]) :- edge(X,Y), solve(Y,Z,S).
06:46:21 <copumpkin> but most people don't program much in it
06:46:26 <elly> is the prolog maze solver :)
06:46:44 <b_jonas> then figure out all possible really different inputs (first two rows) for the previous task (there are less than 20) and run the previous program on all of them.
06:46:50 <elly> where | is read 'cons'
06:46:56 <elly> and :- is read 'if'
06:47:12 <b_jonas> also, try to make your program run fast.
06:47:14 <lpsmith> b_jonas:  if there is at least one solution to the problem,  then there is at least two,  that much is obvious :-)
06:47:35 <elly> the joke resulting from this language design is 'All prolog programs have the same runtime - O(2^N)'
06:48:33 <elly> actually, solve(X,X,[]). solve(X,Z,[X | S]) :- edge(X,Y), solve(Y,Z,S). is prettier
06:48:42 <elly> (and also correct in the base case)
06:48:45 <lpsmith> actually,  it's easy to prove that there are an even number of solutions to b_jonas's problem
06:48:49 <therp> has anyone tried to use ghci as a replacement (using the right packages) for say, mathematica, R, or maxima? every of those programs has its own set of problems..
06:49:32 <lpsmith> therp:  I don't think so;  Haskell would come up pretty short against any of those languages in their respective problem domains
06:50:06 <lpsmith> But if somebody were to create enough libraries... I don't know how good of a CAS haskell would make,  but certainly it could compete with R
06:50:15 <therp> lpsmith: I need it for simple tasks like defining a few functions, plotting them, doing some interpolation. nothing spectacular.
06:51:12 <koeien37> I want GAP bindings :(
06:51:18 <therp> it annoys me for instance that I can't find how to make a list of [1..10] in maxima, and I can't google it because I always end up at pages discussing the maximum and minimum of a function
06:51:22 <koeien37> but I'm too lazy etc. to make them
06:51:34 <lpsmith> heh
06:51:41 <b_jonas> therp: try looking for an irc channel for maxima then
06:52:02 <therp> R was also named before the google aera.
06:52:12 <therp> b_jonas: nobody there..
06:52:30 <koeien37> try #math-software, but that's unlikely to give you a result ime
06:52:43 <lpsmith> although,  I think it's slightly unfortunate that Haskell wasn't selected for the Sage project :-D
06:52:54 <koeien37> yeah :(:(
06:52:59 <koeien37> SAGE is awesome
06:53:01 <Axman6> what's Sage again?
06:53:21 <HaskellLove> "to program a state transformer, we can use a monad to model state. To solve a logic problem, we use the list monad to transparently handle backtracking." It seems haskell is multi-paradigm haha
06:53:21 <koeien37> the free software python CAS using GAP, PARI, Maxima, and so on
06:53:44 <Axman6> HaskellLove: not at all. that's all functional
06:53:58 <b_jonas> no, haskell is quite the opposite of multi-paradigm, and it's definitely not a dwim langauge
06:54:18 <Axman6> andrewe: http://www.haskell.org/haskellwiki/Mac_OS_X
06:54:20 <b_jonas> both the language and the community are trying to force you to write haskell programs in the one true way
06:54:24 <b_jonas> which I hate
06:54:27 <b_jonas> I prefer dwim
06:54:39 <Axman6> use something else then
06:54:44 <Axman6> go play with python and ruby :)
06:54:45 <therp> b_jonas: yeah, but all other languages force you to write it in the wrong way :p
06:55:38 <HaskellLove> the shitty way, and haskell is like heaven`s way
06:55:47 <b_jonas> I want freedom to shoot myself in the foot. I want to show that I _can_ write programs the wrong way in haskell too if I want.
06:55:57 <andrewe> Axman6: thank you, I still have to wait for my account to the wiki.
06:55:58 <koeien37> :t unsafeCoerce
06:55:59 <lambdabot> Not in scope: `unsafeCoerce'
06:56:09 <mauke_> I think haskell is very TMTOWTDI
06:56:25 <b_jonas> I demand that I may or may not be Vroomfondel.
06:56:38 <ivanm> b_jonas: heh
06:56:49 <ivanm> b_jonas: well, go forth and write wrong programs then!
06:57:21 <b_jonas> I want to
06:57:33 <b_jonas> but this effing library install problem is stopping me
06:57:41 <therp> haskell isn't the best for rapid prototyping true, but that doesn't mean that I can't express my initial attempt easily in haskell
07:00:48 <b_jonas> actually I want to write good programs the bad way just to show that the one true way doesn't restrict me,
07:01:16 <Axman6> what's the problem?
07:01:31 <b_jonas> and want to write good but ugly and unreadable programs too, to start the prejudgice that haskell is unreadable (it worked for some guys with perl and apl)
07:02:01 <mauke_> I'd start with the BASIC monad
07:08:09 <b_jonas> ah great, I think reinstalling those packages like (haskell98) that depend on the broken package (random) fixes the error
07:08:25 <b_jonas> let me check if I can install hexpat now
07:08:46 <b_jonas> yep, I can
07:08:47 <b_jonas> great
07:09:28 <b_jonas> I think I fixed the program
07:09:33 <b_jonas> s/program/problem/
07:11:32 <jaspervdj> I think I need some help fixing this bug: http://groups.google.com/group/hakyll/browse_thread/thread/f4ef41d3041951d7
07:12:20 <jaspervdj> is using regex-compat recommended at all, or should I switch to a more portable regex-* package?
07:15:44 <b0fh_ua> Hi there. I am trying to create function, which does the same as 'map', but is writted in CPS-like way. I've created something like http://pastebin.com/dd95452c - and it seems to work fine, however I'm not sure is that CPS way.
07:16:34 <b0fh_ua> So may be somebody could correct me and explain what did I do in wrong way, please?
07:19:59 <b_jonas> that looks like the same as last time
07:20:37 <b0fh_ua> b_jonas: yup, I still trying to understand this
07:20:48 <b0fh_ua> may be I missed some comments last time
07:20:54 <trin_cz> hi all, does anyone know where Functor Id is defined? Not that the reimplementation is hard ;-)
07:21:05 <b_jonas> well I'm not sure how the "cps" would work
07:21:11 <b_jonas> trin_cz: Control.Monad.Identity
07:21:16 <Axman6> trin_cz: run :info Id in ghci
07:21:20 <trin_cz> b_jonas: thanks
07:21:33 <b_jonas> > runIdentity (fmap (10 *) (Identity 4))
07:21:34 <lambdabot>   40
07:23:59 <mreh> are there any plans to include automatic generation of semantic type editors in future versions of GHC?
07:24:15 <HaskellLove> join :: Monad m => m (m a) -> m a Is this the same as concat for lists?
07:24:27 <b_jonas> yes
07:24:30 <koeien37> yes
07:24:39 <koeien37> > join [[1],[2],[3,4]]
07:24:40 <lambdabot>   [1,2,3,4]
07:24:50 <koeien37> join = (>>= id)
07:25:17 <koeien37> so join xs = xs >>= id = flip concatMap xs id = concatMap id xs = concat xs . map id = concat xs
07:25:23 <mreh> :t join
07:25:24 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
07:28:43 <mreh> are all arrows functors?
07:29:01 <koeien37> arrow :: * -> * -> *
07:29:05 <koeien37> functor :: * -> *
07:29:13 <maltem> mreh, what's a semantic type editor? An editor that supports the user wrt types?
07:30:41 <mreh> maltem: they're Arrows and they work on functors I think, they let you apply a function to part of a data structure
07:30:49 <mreh> or even to a function
07:31:27 <mreh> and you can compose them quite nicely
07:31:53 <mreh> > first (+1) (1,"Hello")
07:31:54 <lambdabot>   (2,"Hello")
07:32:30 <mreh> > second.first.(+1) ((1,True),"Hello")
07:32:32 <lambdabot>   Couldn't match expected type `a b c'
07:32:32 <lambdabot>         against inferred type `[GHC.Ty...
07:32:46 <burp> > fmap (+1) (1,"Hello")
07:32:48 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
07:32:48 <lambdabot>    arising from the literal ...
07:32:48 <maltem> Would that be combinators, or a data type?
07:32:55 <mreh> > second.first.(+1) $ ((1,True),"Hello")
07:32:56 <burp> hm, wasn't there a functor instance for (,)?
07:32:56 <lambdabot>   No instance for (Control.Arrow.Arrow (,))
07:32:56 <lambdabot>    arising from a use of `Control...
07:33:10 <mreh> burp, you use Arrows
07:33:14 <burp> > fmap (+1) ("Hello",1)
07:33:15 <lambdabot>   ("Hello",2)
07:33:15 <mreh> :t first
07:33:17 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
07:33:20 <burp> ah for the second argument
07:34:53 <mreh> can you really map over a tuple?
07:35:17 <koeien37> burp: yes. That's because in Haskell, there is no way to flip the type arguments
07:35:24 <trin_cz> b_jonas: what if I want to rename Identity to Id? Both type and constructor? type Id = Identity does only type.
07:35:30 <koeien37> instance Functor ((,) a) where ...
07:35:48 <koeien37> there is no way to say instance Functor (\a -> (,) a b) where ..., except for newtyping
07:36:28 <burp> oh, ok
07:37:01 <b_jonas> trin_cz: I don't think you can rename the data constructor
07:37:59 <trin_cz> b_jonas: damn, I thought so. Thanks for confirmation.
07:41:55 <interferon> i'm having a hard time understanding why monadic functions don't take a monad as an argument
07:42:26 <interferon> for example, if i use getChar in the middle of a series of IO actions, how does it get the IO monad that it returns
07:43:59 <ben0x539> interferon: The entire point of monadic code is to hide that in the implementation of the monad
07:44:13 <burp> http://www.downforeveryoneorjustme.com/hackage.haskell.org
07:44:23 <burp> arg.. hackage down always on weekends
07:44:28 <DrTeggy> interferon, a monad is not a data structure or similar. It's a ... uh...  family of functions adhering to specific laws.
07:45:07 <Ke> http://haskell.org/haskellwiki/IO_inside I think this was pretty easy to understand
07:45:29 <b_jonas> interferon: because it's the >>= thing that takes a monadic action
07:45:38 <interferon> hmm
07:46:14 <HaskellLove> "the structure of the Maybe monad propagates failures." wow this is amazing
07:46:33 <ben0x539> interferon: The thing that the IO actions take as hidden argument is not known as "a monad" but informally as "RealWorld"
07:46:44 <b_jonas> interferon: you could write your program in such a way that you always use (getChar >>=) instead of just getChar
07:46:52 <b_jonas> interferon: in fact ContT can rewrite your program that way
07:47:10 <b_jonas> interferon: then your character getter takes a monadic action as the argument
07:47:13 <ben0x539> interferon: The idea is that your code does not have any real worlds, so you just compose your IO actions, and the runtime system will then take the result, the main function of type IO a, pass a Real World to it to get the a...
07:47:25 <b_jonas> interferon: but the way it is is usually more convenient
07:48:37 <interferon> so in getChar >>= (\x -> putChar x), the putChar that IO returns is totally different from the one getChar returns?
07:48:45 <interferon> i thought they were somehow being chained together
07:50:28 <b_jonas> I don't understand that question
07:50:59 <Ke> IO is a type, not a value
07:52:16 <burp> @hoogle acot
07:52:16 <lambdabot> No results found
07:52:47 <pikhq> interferon: Well, it takes the a from getChar, passes it to the \x->putChar x function. Behind the scenes (and this is only a specific implementation), it takes the RealWorld from getChar, and threads it into putChar's RealWorld -> (RealWorld, a). Thereby evaluating putChar.
07:52:57 <pikhq> ^ The above assumes that getChar has already been evaluated.
07:53:42 <omak> hi, under mac os i'm getting undefined symbols: _containerszm0zi2zi0zi1_DataziMap_lookup_closure during linking
07:53:43 <Axman6> interferon: try this: http://random.axman6.com/blog/?page_id=70
07:53:55 <tener> does anyone have any idea why Hackage server is so fragile lately? It's down again.
07:54:15 <Axman6> because it needs more devs!
07:59:11 <interferon> monads are like zen...the more you try to understand them, the more they slip away :)
07:59:13 <xerox> tener check out the torrent as well
07:59:31 <b_jonas> no they aren't
08:00:16 <b_jonas> quite the opposite
08:01:07 <tener> xerox: i did, it'm downloading it right now. i also used http://downforeveryoneorjustme.com/http://hackage.haskell.org/packages/archive/pkg-list.html to find the package i need
08:01:15 <tener> uhm, sorry
08:01:18 <tener> not that link
08:01:26 <maltem> @quote endofunctor
08:01:27 <lambdabot> psykotic says: [monads aren't hard] they're just monoids on the category of endofunctors over some category, what's the big deal?
08:01:27 <tener> http://bifunctor.homelinux.net/~roel/hackage/packages/hackage.html
08:01:40 <interferon> :)
08:05:48 <koeien37> does monoids mean "monoidal objects" in that context?
08:06:17 <b0fh_ua> Can somebody please tell me is that the correct type definition for map function, written using CPS style: mycmap :: (a -> ( [a] -> [b] ) -> [b] ) -> [a] -> [b]
08:07:20 <interferon> wow: type IO a  =  RealWorld -> (a, RealWorld)
08:07:52 <Axman6> the GHC one is even stramger, according to lambdabot:
08:07:54 <Axman6> @src IO
08:07:55 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
08:08:09 <koeien37> it uses some # magic
08:09:46 <pikhq> Only minor magic.
08:10:05 <pikhq> (strict, unboxed type)
08:10:36 <koeien37> yeah the RealWorld is wiped out and only used as a data dependency to ensure the correct ordering of IO effects, afaik
08:10:48 <koeien37> so the tuples and the state constructor are not necessary
08:11:11 <pikhq> The State# bit forces it to be strict.
08:11:41 <Axman6> you don't want a lazy RealWorld
08:12:11 <koeien37> in the real world, I'm lazy though
08:12:11 <interferon> so is RealWorld just a token?
08:12:30 <interferon> or is it accruing a list of actions (input and output) ?
08:13:27 <pikhq> interferon: Yes.
08:13:33 <interferon> yes to which?
08:13:43 <interferon> if you say both, i return to my zen analogy :P
08:14:19 <pikhq> Both are valid interpretations of the semantics.
08:14:54 <interferon> awwwww :)
08:16:07 <interferon> seeing the definition of >>= is helpful
08:18:49 <xerox> anybody has a definition of foldr in matlab? :P
08:19:37 <Axman6> yes... but it involves killing yourself
08:23:02 <gwern> my tapl came today!
08:23:15 <gwern> and it has a really nice feeling hardcover, as it otter considering its price
08:23:58 * copumpkin has a ratty library version
08:24:30 <Athas> What's the best way to handle end-of-input in Parsec?  I mean, my parser is reading a list of declarations, and it's no error that the file ends between then.
08:26:46 <Athas> Hmm, looks like '(eof *> pure []) <|> whatever' is what I want.
08:26:58 <gwern> copumpkin: but you're better off than me as far as understnding it :)
08:27:04 <b0fh_ua> damp, that understanding of CPS drives me crazy
08:27:38 <copumpkin> gwern: I've only skimmed parts of it, sadly :( it wasn't as captivating as I was hoping, but it's still a good reference
08:28:05 <interferon> tapl?
08:28:14 <gwern> @where tapl
08:28:15 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
08:28:30 <copumpkin> I also have a lib copy of attapl lying around which seems more interesting
08:28:31 <Axman6> b0fh_ua: hang in there, someone will be able to help you eventually :)
08:29:02 <b0fh_ua> yeah )
08:29:22 <voidprayer> excuse me, what is "_"? i see all kinds of messages in ":t _" or ":i _"?
08:29:24 <gwern> copumpkin: I always saw tapl as advanced topics ~-~
08:29:27 <voidprayer> but nothing
08:29:29 <b0fh_ua> I hope I will not go mad before somebody will help me :)
08:29:47 <gwern> voidprayer: underscore means ignore
08:29:49 <Axman6> voidprayer: it's the 'ignore what would be here" character
08:29:58 <gwern> > let foo _ = "10" in foo undefined
08:29:59 <lambdabot>   "10"
08:29:59 <copumpkin> gwern: well attapl deals with some of the more interesting type systems we see, and has bite-sized chapters on them
08:30:15 <Axman6> so, you could write const x y = x, but it's clearer to write const x _ = x
08:30:34 <copumpkin> moo
08:30:59 <Axman6> voidprayer: it explicitly says that you are not going to be using that binding
08:31:00 <voidprayer> ahh, very amazing.
08:31:04 <copumpkin> gwern: http://www.cis.upenn.edu/~bcpierce/attapl/frontmatter.pdf is the beginning
08:31:45 <gwern> copumpkin: pierce is offering it for free?
08:31:57 <gwern> man, so it's so difficult he can't even sell it for 70$
08:31:58 <copumpkin> just the beginning with the ToC and intro
08:32:02 <copumpkin> :)
08:32:18 <jmcarthur> i've bought both and don't regret it
08:32:31 * Alpounet will offer himself *tapl's for his birthday
08:36:16 <koeien37> yeah _ is not an identifier
08:36:19 <koeien37> you can have more than one
08:36:33 <koeien37> > let f x x = 37 in f -- not legal
08:36:34 <lambdabot>   Conflicting definitions for `x'
08:36:34 <lambdabot>  In the definition of `f'
08:36:43 <slom> hi there, can someone offer me a short explanation of  a "strictly positive  recursive occurence is" (or a link ...)
08:36:44 <koeien37> > let f _ _ = 37 in f -- legal
08:36:45 <lambdabot>   {()->{()->37}}
08:36:56 <copumpkin> koeien37 has a 37 fetish
08:37:10 <koeien37> heh
08:37:20 <koeien37> it's the smallest irregular prime
08:37:31 <copumpkin> oh, of course
08:38:24 <koeien37> there are some heretics that prefer 42
08:41:34 <mreh> :t pure
08:41:35 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
08:41:40 <mreh> that's in the prelude right?
08:41:50 <copumpkin> Control.Applicative
08:42:01 <mreh> aah
08:46:01 <voidprayer> how can i directly define a new data type in ghci without write code in file and :load them?
08:46:08 <koeien37> you can't
08:46:12 <koeien37> use the file anyway :)
08:48:03 <mreh> how does <*> work for lists?
08:48:13 <mreh> concat map?
08:48:25 <xerox> :t (<*>)
08:48:26 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
08:48:31 <Axman6> it's ap
08:48:43 <doserj> and ap is liftM2 ($)
08:48:57 <mreh> so it takes a list of functions and a list of values?
08:49:03 <Axman6> > [(+1),(*2) <*> [1,2,3]
08:49:05 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
08:49:11 <Axman6> > [(+1),(*2)] <*> [1,2,3]
08:49:12 <lambdabot>   [2,3,4,2,4,6]
08:49:25 <mreh> yeah, okay
08:49:30 <Axman6> yep
08:50:36 <mreh> :t liftM2
08:50:37 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
08:50:53 <trin_cz> does anybody know about an explanation, why ((,) a) functor is defined as fmap f (x,y) = (x, fy) ? Some article perhaps?
08:51:07 <mauke_> do you have a better definition?
08:51:17 <xerox> > (*) <$> [1,10,100] <*> [3,5,7]
08:51:18 <lambdabot>   [3,5,7,30,50,70,300,500,700]
08:51:32 <b_jonas> trin_cz: that's the only way the types work out
08:51:48 <b_jonas> (trin_cz: you can't define an instance for type synonym heads)
08:52:00 <trin_cz> I wanted to do (Functor a, Functor b) => Functor (a,b)
08:52:06 <xerox> altough if you make it a newtype you can use whatever component you want of a (n-)tuple
08:52:35 <idnar> trin_cz: wrong kind
08:52:57 <idnar> trin_cz: (Functor f, Functor g) => Functor (f a,g b) maybe?
08:53:08 <xerox> you can do newtype Double a = Doulbe a a
08:53:14 <mauke_> idnar: still wrong kind
08:53:23 <idnar> oh, true
08:53:26 <xerox> maybe that needs data... Double (a,a)
08:54:33 <voidprayer> koeien37: then at least plz teach me how to unload my .hs. thx. i use :m - 1.hs and then i can only see ">" in the front without Prelude load?
08:54:34 <c_olin> Is there an easy way to save ghci settings so I don't have to ":set editor vi" every time I open ghci?
08:54:42 <xerox> c_olin .ghci
08:54:49 <c_olin> awesome.. thanks
08:55:03 <xerox> c_olin that is my only line as well hehe.
08:56:30 <trin_cz> mauke_: ah, now I get it. Functor has only 1 type variable, but (,) has 2.
08:56:48 <mauke_> @kind (,)
08:56:49 <lambdabot> * -> * -> *
08:58:11 --- mode: ChanServ set +o mauke_
08:58:11 --- topic: set to '["hackage torrent @ http://bit.ly/7ObzIP ","Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]' by mauke_
08:59:11 --- mode: mauke_ set -o mauke_
08:59:24 <jmcarthur> dang, hackage is down *again*?
08:59:37 <mreh> :t first
08:59:39 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
08:59:46 <mreh> jmcarthur: yeah
08:59:58 <mauke_> good thing I made a new torrent today :-)
09:00:10 <Axman6> heh :)
09:00:18 <mreh> we need to flog the responsible parties
09:00:21 <jmcarthur> trin_cz: i would link you to TypeCompose's :*: type if hackage was up
09:00:40 <jmcarthur> trin_cz: it has the behavior you are looking for
09:02:03 <trin_cz> jmcarthur: good keyword, thanks
09:03:15 <holmak> Are all the Haskell websites hosted from someone's basement?
09:03:29 <ben0x539> Dorm room, rather.
09:04:59 <j4cbo> woohoo dorm hosting
09:05:14 <holmak> are they really hosted from dorm rooms?
09:05:24 <Axman6> they're hosted at Golois Inc.
09:05:50 <ben0x539> holmak: No, but I seem to recall that some parts at least were hosted by university groups.
09:06:06 <ben0x539> I am sure they are really in some sort of faculty buildings, but dorms would be closer than basements
09:06:29 <j4cbo> http://b.j4cbo.com/temp/r7-servers-1.jpg is my basemet at school... the server count has since doubled
09:06:46 <j4cbo> the thing on the far right is a VAX
09:07:12 <ben0x539> Is that a laptop under the desk?
09:07:17 <j4cbo> yep.
09:07:19 <ben0x539> I bet the entirety of waffleimages runs on that.
09:07:32 <j4cbo> it's closer than you think :P
09:08:12 <j4cbo> i believe one of the mirrors involves long stretches of cat5 run between buildings outside... in Sweden
09:08:30 <ezyang> Good morning.
09:08:54 <burp> mauke_: why is hmatrix missing in that torrent?
09:09:10 <burp> oh it's not
09:09:20 <burp> never mind
09:12:46 <jlouis> Unfortunately, haskell-torrent is not ready for that torrent :/
09:12:57 <jlouis> But it'll be there :)
09:13:07 <gwern> j4cbo: a vax? bah, come back when you have some lisp machines
09:13:20 <ben0x539> jlouis: What is missing? Or rather, what is there?
09:14:07 <jlouis> ben0x539: The two main things missing is choking/unchoking and survivability if a peer dies
09:15:17 <jlouis> ben0x539: other than that, it is working. With some hacks, it seeds and leeches to a single peer at the moment, if the torrent is not too big
09:15:49 <jlouis> if it is too big, it uses memory proportional to the size of the torrent, if you must know, hehe
09:16:07 <ben0x539> Right
09:17:42 <ben0x539> jlouis: Would it be appropriate to use haskell-torrent as a library to parse torrent files and, for example, dump the files contained in it on the commandline?
09:17:57 <ben0x539> I had a look at the repository a few days ago but I did not quite grasp the structure
09:18:08 <jlouis> ben0x539: sure
09:18:26 <jlouis> ben0x539: if you need some hints, don't hesitate to ask
09:18:43 <ben0x539> Okay, cool, thank you. I will see whether I can get around to doing my thing tonight.
09:20:02 <jlouis> ben0x539: basically, you can leverage almost all of the nice work Axman6 did on parsing BCoded data I think
09:20:12 <Axman6> o/
09:20:29 <jlouis> though we might need some patches for multi-file torrents, I dunno
09:20:40 <jlouis> Axman6: hah, I thought you were sleeping :)
09:20:43 <Axman6> ben0x539: i've been doing exactly that while testing the BCode stuff :)
09:20:49 <Axman6> i should be :)
09:20:58 <Axman6> people are wrong on the internet though, and need correcting
09:21:06 <cloudhead> hey anyone here use `yi` ?
09:21:40 <Axman6> i do not get people who are against speed cameras. the idea of being against stopping people doing dangerous and illegal activities boggles my mind
09:22:14 <b_jonas_> Axman6: people against speed cameras in Europe or America?
09:22:19 <Axman6> australia
09:22:34 <jlouis> Axman6: that approach is not trollish enough. Suggest that all have have GPS trackers in them
09:23:36 <Athas> Hmm, hpaste.org does not handle Literate Haskell?
09:24:49 <c_wraith> axman, the problem with speed cameras is that "dangerous" is mostly false.  "profitable for the camera operator" is the real motive.
09:25:18 <Axman6> c_wraith: it's a very useful side effect, but it is not the main reason for having them
09:25:31 <xerox> -blah
09:25:51 <Axman6> yeah i don't want to continue anyway
09:27:08 <Axman6> jlouis: did you like the changes i made to BCode by the way?
09:27:44 <htoothrot> I read in the newspaper that the redlight camreas they put up around here were working too well and that they were no longer paying for themsleves.
09:27:59 <htoothrot> *cameras
09:27:59 <Axman6> heh
09:28:27 <SamB_XP> hmm.
09:28:38 <SamB_XP> whose money are they saving?
09:29:12 <jlouis> Axman6: You mean the one correcting all my mistakes regarding the spec :)
09:29:30 <Axman6> heh, yeah :P
09:29:48 <jlouis> Axman6: Indeed I like that. I also like the cereal-style much more than what I had hacked up
09:29:56 <Axman6> don't worry, i didn't even really read the spec (the thing i read i don't think made any mention of negative numbers)
09:30:52 <jlouis> I've never seen negative numbers in torrent files, but as a format it is probably the most correct thing
09:31:06 <Axman6> yeah
09:31:10 <jlouis> anyway, I am vanishing for a while
09:31:29 <Axman6> i was thinking that i couldn't see a use for negative numbers in a torrent file either, but the spec says they can exist
09:31:35 <xerox> I hope you are not analytic in time, jlouis!
09:31:45 * Axman6 is quite proud of the new getBString function
09:31:52 <Axman6> o/ jlouis
09:33:03 <timlarson> how can I diagnose "user error (Curses[-1]:waddstr:..."?
09:33:26 <gwern> looks an ffi exception?
09:33:37 <gwern> what with c functions returning -1 signaling error
09:33:39 <timlarson> this is a runtime error when using hscurses
09:34:10 <gwern> maybe insert a trace call to whatever is being passed to waddstr so you know what the input is?
09:34:11 <timlarson> ok, that makes sense...any ideas how to track down a cause?
09:34:28 <timlarson> (\ a -> C.wAddStr C.stdScr (show a))
09:34:45 <timlarson> this is the function that is causing this
09:35:04 <timlarson> a is [B.ByteString]
09:36:35 <timlarson> this works: C.wAddStr C.stdScr $ show env1
09:36:42 <gwern> env1?
09:36:49 <timlarson> this causes the above error: mapM (\ a -> C.wAddStr C.stdScr (show a)) env1
09:37:12 <gwern> maybe it doesn't like ""s
09:37:19 <timlarson> env1 is a [[B.ByteString]]
09:37:59 <gwern> since env1 presumably gets turned into "foo", not "\"foo\""; and show on a [String] would be like "[\"fo\", \"ba\"...]"
09:41:26 <timlarson> this works: C.wAddStr C.stdScr "[\"fo\", \"ba\"...]"
09:41:46 <timlarson> or was I misunderstanding what I should be testing?
09:42:45 <gwern> nope, guess that wasn't it
09:43:15 <gwern> I'd really see what trace says your show [Bystring] is actually becoming
09:43:40 <timlarson> how do I do that?
09:43:55 <timlarson> (sorry, I am pretty new to haskell)
09:45:21 <gwern> it'd be like (trace (show a) (show a))
09:47:03 <gwern> @hoogle trace
09:47:03 <lambdabot> Debug.Trace trace :: String -> a -> a
09:47:04 <lambdabot> Network.HTTP.Base TRACE :: RequestMethod
09:47:04 <lambdabot> module Debug.Trace
09:51:59 <timlarson> ok, I tried this: mapM (\ a -> C.wAddStr C.stdScr (T.trace (show a) (show a))) env1
09:52:25 <timlarson> and ended up still getting the error (as expected) but getting way too much data to paste...
09:52:50 <timlarson> this is getting its data from a db, so I tried using a trimmed down table to select from...
09:53:01 <timlarson> and that did not produce the error...
09:53:32 <timlarson> so I do think it is related to what data is being processed, so I will try to track down which data causes it now.
09:54:00 <gwern> timlarson: try binary searching the string - take the first half, see if it triggers, then take the first quarter, etc
09:54:14 <timlarson> will do, tnx
09:54:36 <gwern> classic debuggin technique
09:54:43 <timlarson> yup
10:00:54 <roconnor> is a three-way merge a pushout in the category of patches?
10:02:35 <jlouis> roconnor: perhaps. It definitely could be
10:02:42 <timlarson> gwern, turns out it is issuing a Curses.wAddStr which attempts to print off the bottom of the screen
10:02:55 <gwern> timlarson: ah, it was sheer length then?
10:03:11 <timlarson> so too many wAddStr calls without monitoring the cursor position produced.
10:03:45 <timlarson> the length of the list being printed with a sequence of wAddStr calls, yes.
10:04:34 <timlarson> thanks for the help, and for aquainting me with trace
10:05:20 <mreh> :t fmap
10:05:21 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:05:41 <mreh> I want to compose two operations over one data structure, I suppose defining it as a functor would let me do that right?
10:06:14 <HaskellLove> I get confused from the book. What is the difference betweeen a list and a list monad?
10:06:26 <mreh> HaskellLove, nothing
10:06:35 <HaskellLove> aha
10:06:46 <mreh> a monad is a type constructor and associated methods from the class Monad
10:07:01 <mreh> plus some Monad Laws
10:07:05 <HaskellLove> lists are implemented as monads, i mean, they gota be... right?
10:07:10 <HaskellLove> yeah i learned the monad laws
10:07:24 <mreh> lists implement Monad, yes
10:09:48 <jlouis> mreh: yes, because fmap f . fmap g == fmap (f . g) (modulo notation)
10:10:09 <mreh> jlouis, and the RHS is more efficient!
10:10:33 <mreh> HaskellLove: (>>=) = concatMap
10:10:36 <Eduard_Munteanu> Hi. I used Glade to build an interface and I load it with gtk2hs in my program. However, the Notebook control doesn't show all tabs.
10:10:40 <Eduard_Munteanu> What's wrong?
10:10:49 <roconnor> jlouis: now I really want to find that web page that showd how darcs does a proper 3-way merge while others do not
10:11:01 <b_jonas> mreh: what?
10:11:06 <Eduard_Munteanu> I get (main:20724): Gtk-CRITICAL **: gtk_notebook_set_tab_label: assertion `GTK_IS_WIDGET (child)' failed
10:11:23 <mreh> map f . map g is slow than map (f . g)
10:11:31 <mreh> s/slow/slower/
10:11:38 <jlouis> roconnor: what eludes me is that I have seen that page as well at some point I think
10:11:38 <xerox> there is a rewrite rule for that, isn't there
10:11:57 <b_jonas> mreh: concatMap doesn't have the right type to be the same as (>>=)
10:12:07 <b_jonas> mreh: it might be something similar though
10:12:11 <mreh> :t concatMap
10:12:13 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
10:12:15 <roconnor> jlouis: zooko.com is down, and if it was there it isn't available.  I'm trying to use the internet archive, but it is not indexed like google.
10:12:21 <HaskellLove> mreh that is crazy :) i dont get it... concatMap is syntactic sugar for ==> or the other way around?
10:12:27 <jlouis> :t (=<<)
10:12:28 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
10:12:29 <Eduard_Munteanu> Is there a better place to ask the previous question?
10:12:49 <mreh> :t flip concatMap
10:12:50 <lambdabot> forall a b. [a] -> (a -> [b]) -> [b]
10:12:53 <mreh> tada!
10:12:58 <b_jonas> maybe that then
10:13:03 <jlouis> roconnor: arh, shame. I would have liked to refresh my memory on it as well
10:13:16 <mreh> HaskellLove: they're just equivalent
10:13:37 <HaskellLove> ok i will remember it for now and things will get clear as i read more
10:14:23 <mreh> If I bind (a list :: [a]) to a function that takes a (something :: a) and returns a :: [b], the only real funtion that fits the type signature for >>= is concatMap
10:14:39 <mreh> HaskellLove, they have the same type signature more or less, you just need to flip the arguments
10:14:52 <jlouis> roconnor: however if it *is* a pushout, then the "solution" is universal ... which is awfully neat
10:14:53 <b_jonas> mreh: are you sure?
10:14:54 <aavogt> HaskellLove: the specialization is:   (Monad m => m a)  is the same as   [a]
10:14:57 <nainaide> Any one use haskellmode in vi?
10:15:08 <jlouis> nainaide: vim?
10:15:14 <jlouis> yes
10:15:19 <mreh> b_jonas, almost
10:15:27 <b_jonas> yeah, I guess that's the only sane one that fits
10:15:31 <roconnor> jlouis: http://web.archive.org/web/20070308132012/zooko.com/badmerge/simple.html
10:15:40 <HaskellLove> aavogt wow i see thanks buddy
10:15:42 <b_jonas> or the simplest or most natural one or something
10:15:45 <mreh> > [1,2,3] >>= replicate 3
10:15:46 <lambdabot>   [1,1,1,2,2,2,3,3,3]
10:15:49 <roconnor> there are more recent versions, but for some reason they try to redirect me out fo the web.archive
10:15:52 <nainaide> jlaire, I found I can only get info from _ct after successfully  :make,
10:15:59 <mreh> > [1,2,3] `concatMap` replicate 3
10:16:00 <lambdabot>   Couldn't match expected type `a -> [b]'
10:16:01 <lambdabot>         against inferred type `[a1]'
10:16:04 <mreh> other way round
10:16:19 <mreh> > replicate 3 `concatMap` [1,2,3]
10:16:20 <lambdabot>   [1,1,1,2,2,2,3,3,3]
10:16:23 <jlouis> roconnor: oh, thanks
10:16:34 <roconnor> where is zooko?
10:16:40 <roconnor> and why is zooko.com gone?
10:17:18 <mreh> b_jonas, I don't think there is anything else that would be useful, and it means you can use List monad to simulate backtracking when you evaluate it lazily
10:18:02 <jlouis> nainaide: I just have a makefile target for that, so I don't use it
10:18:22 <nainaide> jlouis, thanks.
10:20:09 <b_jonas> mreh: yep. there's another less natural monad instance (for a newtype) in some library that is such that even if f returns infinite lists, l >>= f contains all the elements in some other order, not just the ones from f (first l), but flip concatMap is indeed the most useful one
10:20:42 <b_jonas> control-monad-omega is the name of the library
10:20:53 <mreh> sounds exciting
10:20:55 <gwern> roconnor: the IA will provide all urls in a domain
10:21:02 <gwern> should be good enough for you
10:21:14 <Eduard_Munteanu> Right, I shouldn't leave empty pages in a Notebook, I found the answer.
10:21:30 <Eduard_Munteanu> Resolution: NOTAGTK2HSPROBLEM :)
10:22:54 <roconnor> gwern: the IA?
10:23:05 <gwern> interent archive
10:23:13 <jlouis> roconnor: You know more about darcs than I do.. have operational transforms ever been considered in the darcs theory of patches setting? (http://en.wikipedia.org/wiki/Operational_transformation)
10:24:27 <roconnor> jlouis: There was one paper that tried to formalize the theory of patches, but it was rejected.
10:24:42 <jlouis> :/
10:24:46 <roconnor> however, thanks to the www, it is available to the world!
10:24:57 <roconnor> I thin wouter was one of the authors  Not sure
10:24:59 <roconnor> think
10:25:29 <roconnor> gwern: actually the IA doesn't :/  http://web.archive.org/web/20070813064106rn_4/zooko.com/badmerge/simple.html
10:25:48 <mreh> how does the visitor pattern relate to Haskell's class hierachy?
10:26:00 <roconnor> mreh: it is the Traversable class
10:26:29 <gwern> roconnor: so find an older copy in http://web.archive.org/web/*/zooko.com/*
10:30:06 <HaskellLove> What monadic functions do you use the most? So far I learnt ap and filterM, pretty cool stuff...
10:30:29 <roconnor> sequence
10:30:33 <jlouis> mapM and mapM_
10:31:26 <jlouis> HaskellLove: also, hoogle is a nice tool http://www.haskell.org/hoogle/ you hand it a type and it tells you functions that match the given type
10:31:26 <koeien37> join, sequence
10:31:46 <koeien37> liftM
10:32:10 <HaskellLove> jlouis yeah i know, i learn functions there, monadic ones since i am new to monads
10:32:13 <copumpkin> untilM ;)
10:32:39 <c_wraith> copumpkin: you're not allowed to use functions that don't exist. :P
10:32:41 <koeien37> monadic functions are also functions
10:32:45 <copumpkin> it's funny that most things people listed in response to his question don't need a monad
10:32:59 <copumpkin> they're just Traversable methods
10:33:07 <copumpkin> or even Foldable
10:33:17 <c_wraith> heck.  liftM is Functor.  ap is Applicative
10:33:23 <copumpkin> yeah :)
10:33:23 <roconnor> copumpkin: ya, I was thinking that Traversable is probably more important.
10:33:50 <koeien37> hmm
10:33:56 <koeien37> if they're so close, then how are they related?
10:34:00 <copumpkin> what kinds of convenience functions do we use often that fundamentally need a monad?
10:34:16 <copumpkin> also, the only Traversable instances I know are also Monads
10:34:39 <HaskellLove> Oh yeah and if you guys have code where you use loooots of monads please send me i will be very happy to study it and ask you 1000 questions ;)
10:34:54 <c_wraith> does filterM require monad?
10:35:06 <copumpkin> c_wraith: yeah
10:35:11 <c_wraith> so...  there's one.  :)
10:35:12 <copumpkin> I'm pretty sure
10:35:22 <copumpkin> it's making local decisions based on state
10:35:45 <roconnor> @src filterM
10:35:46 <lambdabot> Source not found. The more you drive -- the dumber you get.
10:35:50 <roconnor> pft
10:35:53 <copumpkin> :)
10:36:48 <copumpkin> HaskellLove: I think the most elegant presentation of monads is either using <=< and return, or with join and return
10:36:59 <copumpkin> HaskellLove: your initial experiments should be based around those :)
10:37:09 <koeien> in the latter case you need fmap as well
10:37:16 <copumpkin> koeien37: yeah
10:37:20 <copumpkin> I think >>= is useful but is doing too many things at once and is hard to grasp
10:37:27 <b_jonas_> what?
10:37:33 <koeien37> depends
10:37:38 <koeien37> for lists join, fmap & return are easy
10:37:43 <koeien37> easier than (>>=) I'd guess
10:37:44 <b_jonas_> last time didn't you prove that you can write fmap from join and return ?
10:37:55 <b_jonas_> don't you need something extra for <=< and return though?
10:37:56 <copumpkin> b_jonas: nope, from >>= and return
10:37:58 <c_wraith> is there a practical with join and fmap?  Like, they'd be less efficient than >>= in do syntax?
10:38:04 <koeien37> join = (>>= id)
10:38:05 <copumpkin> b_jonas: const and undefined, I guess :)
10:38:24 <b_jonas_> okay, now wait
10:38:24 <koeien37> fmap f = (>>= return . f)
10:38:33 <roconnor> HaskellLove: http://r6.ca/Haskell/FPI
10:38:34 <roconnor> er
10:38:36 <roconnor> HaskellLove: http://r6.ca/Haskell/FPI.pdf
10:38:39 <b_jonas_> yes, what he says
10:39:30 <HaskellLove> roconnor reading it right away thank you ;)
10:40:14 <roconnor> HaskellLove: especially starting on page 21
10:41:31 <roconnor> well especially pages 21 and 22
10:41:38 <koeien37> why do we have both filter and filterM
10:41:46 <koeien37> can't we run filterM in the identity monad
10:41:57 <copumpkin> koeien37: we could do a lot of those things in Identity
10:41:58 <roconnor> koeien37: running the identity monad is annoying
10:42:01 <copumpkin> but it's a pain so we don't :)
10:42:24 <b_jonas_> koeien37: sure, but that's awkward, you need a return ., a map Identity, and a getIdentity
10:42:38 <koeien37> but it is awful that we have to provide "the same" function twice
10:42:47 <koeien37> @src filterM
10:42:47 <lambdabot> Source not found. Just what do you think you're doing Dave?
10:42:47 <roconnor> koeien37: one thing about using runIdentity is that you build up all this sequencing of operations information, and then toss it away.
10:42:50 <copumpkin> :t runIdentity . sequence . map Identity
10:42:50 <koeien37> @src mapM
10:42:50 <lambdabot> mapM f as = sequence (map f as)
10:42:50 <lambdabot> forall a. [a] -> [a]
10:42:54 <koeien37> @src foldM
10:42:55 <lambdabot> foldM _ a []     = return a
10:42:55 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
10:43:48 <koeien37> roconnor: what do you mean?
10:43:58 <koeien37> runIdentity doesn't do anything in run-time surely
10:44:09 <mauke_> hey, when did hackage come back?
10:44:24 * copumpkin accidentally put it in his pocket when he left
10:44:29 <copumpkin> when I came back I put it back
10:44:29 <roconnor> koeien37: I mean taht using >>= gives an order of effects, but then the identity monad (of course) doesn't use any of this information.
10:44:42 <roconnor> koeien37: it's not really a big point.  Just a little point.
10:44:48 <koeien37> I've always been under the impression that (>>=) is not about ordering
10:44:58 <copumpkin> |___|
10:44:59 <roconnor> koeien37: >>= orders effects IMHO
10:45:23 <koeien37> in IO or State maybe
10:45:23 <c_wraith> roconnor: not always.  Lazy State doesn't order anything.
10:45:27 <koeien37> but not in other monads
10:45:37 <copumpkin> it's always ordering effects
10:45:41 <roconnor> c_wraith: sure it does.  It order the state transformations.
10:46:02 <copumpkin> if it's a commutative monad it might not matter
10:46:05 <koeien37> well, just like (.) is
10:46:12 <koeien37> (.) also "orders"
10:46:16 <roconnor> c_wraith: Maybe doesn't order anything; it is a commutative monad.
10:47:01 <koeien37> or Reader
10:47:20 <koeien37> http://www.haskell.org/haskellwiki/What_a_Monad_is_not point 10
10:47:47 <copumpkin> there's still a sequencing of effects, even if those effects end up in the same result
10:48:20 <roconnor> koeien37: I totally disagree with point 10 and have said so before.
10:48:26 <roconnor> I was tempted to delete it the first time I read it
10:48:36 <wto> @src foldl'
10:48:36 <lambdabot> foldl' f a []     = a
10:48:36 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
10:48:45 <copumpkin> I think monads are definitely about ordering if they're about something beyond their formal definition
10:48:59 <roconnor> actually I don't really disagree with point 10
10:49:01 <koeien37> if you take the join, fmap, return definition of a Monad
10:49:12 <roconnor> I do agree that monad aren't not all about ordering.
10:49:18 <HaskellLove> I guess I will have to join some game project to learn monads
10:49:18 <koeien37> then it is not really obvious that there in fact _is_ a sequencing
10:49:19 <roconnor> but ordering is important.
10:49:19 <vishal> hello
10:49:26 <jlouis>  /1
10:49:28 <jlouis> hrmf
10:49:41 <koeien37> for say, IO
10:49:48 <koeien37> well, not obvious to me
10:49:59 <copumpkin> you mean how to get from join to an order?
10:50:17 <koeien37> yes, join m does x <- m; x
10:50:24 <copumpkin> yeah
10:50:36 <copumpkin> it just means that before you can move on you need to "flatten" the computations before you
10:50:38 <koeien37> so first run m, and then run the resulting action
10:51:04 <koeien37> maybe my view of monads is a bit skewed, but I like the return/fmap/join-definition better
10:51:15 <copumpkin> me too
10:51:21 <mauke_> > let poly = repeat in  poly"nom"
10:51:21 <lambdabot>   ["nom","nom","nom","nom","nom","nom","nom","nom","nom","nom","nom","nom","n...
10:51:26 <roconnor> copumpkin: the order is outside to inside?
10:51:49 <b_jonas_> > let poly = cycle in  poly"nom "
10:51:50 <lambdabot>   "nom nom nom nom nom nom nom nom nom nom nom nom nom nom nom nom nom nom no...
10:52:04 <copumpkin> roconnor: it's just setting up a dependency on joining (i.e., running) the earlier computation
10:52:12 <copumpkin> as far as I can see
10:52:17 <copumpkin> but hey, I'm no expert :)
10:52:25 <roconnor> neither am I.
10:52:29 <koeien37> me neither
10:52:33 <copumpkin> damn
10:52:43 <copumpkin> this channel is supposed to be full of experts
10:52:52 <b_jonas_> no it's not
10:52:58 <HaskellLove> Haskell has nice community but it misses one thing, a video tutorials collection on Haskell. If only there was such youtube chanel where people would do such tutorials
10:52:59 <b_jonas_> it's supposed to be full of helpful people
10:53:12 <copumpkin> HaskellLove: watch erik meijer's tutorials
10:53:15 <koeien37> video tutorials? I think that is an awful idea
10:53:18 <copumpkin> b_jonas_: EXERTS I TELL YOU
10:53:22 <copumpkin> I don't like video myself
10:53:24 <c_wraith> I don't know.  the only ordering in the lazy state monad comes from data dependencies.  And since >>= *can* introduce a data dependency, it *can* order.  But it doesn't necessarily.
10:53:24 <b_jonas_> video tutorials suck
10:53:27 <roconnor> copumpkin: there is no way to re-order the "inputs" to join but they are ordered .. kinda
10:53:30 <HaskellLove> copumpkin I did... not much to learn there, litle information
10:53:51 <aavogt> @google catsters
10:53:53 <lambdabot> http://www.catster.com/
10:53:54 <lambdabot> Title: Cat breed, adoption, health & care information at Catster. Photo, video, sharing ...
10:53:55 <Saizan> if you've a function f :: A -> B -> M C, to arguments mx :: M A, my :: M B, there's no monad law saying do x <- mx; y <- my; f x y == do y <- my; x <- mx; f x y; while in a pure settings there is, or well, the question can't even be posed.
10:54:02 <copumpkin> roconnor: yeah, that's what I mean. the joins enforce an ordering
10:54:12 <copumpkin> aavogt: not sure HaskellLove wants that :P
10:54:31 <aavogt> that actual link, copumpkin?
10:54:36 <copumpkin> yeah
10:54:42 <aavogt> or the video tutorials on cat. theory?
10:54:49 <koeien37> oh yes, those are better
10:54:51 <copumpkin> oh I meant the actual real youtube link
10:55:02 <koeien37> http://www.youtube.com/watch?v=FZSUwqWjHCU
10:55:02 <copumpkin> but I doubt HaskellLove would gain much from her definition of a CT monad
10:55:10 <roconnor> copumpkin: hmm
10:55:25 <b_jonas_> you interact haskell in plain text which is why you don't need video tutorials to extend text
10:55:28 <aavogt> I've used commutative diagrams in physical chemistry
10:55:41 <HaskellLove> haha no way this girl is a mathematician she does not explain for programmers
10:55:45 <aavogt> why not in haskell?
10:56:00 <copumpkin> aavogt: see above ;)
10:56:21 <b_jonas_> copumpkin: "CT" monad? what's that?
10:56:31 <copumpkin> b_jonas_: a categorical definition of a monad
10:56:39 <b_jonas_> oh, you _doubt_. I see.
10:57:30 <HaskellLove> there is a looot of difference betweeen the programmer point of view vs the mathematician point of view on haskell... that video is math bla bla
10:57:42 <copumpkin> HaskellLove: it's fairly simple to map to haskell
10:57:48 <copumpkin> but yeah, I didn't think you'd like it :)
10:58:08 <koeien37> I liked those video tutorials
10:58:19 <koeien37> but I still need to read something on it, too
10:58:20 <HaskellLove> i will like it probably, after 5 months or so
10:58:21 <b_jonas_> using commutative diagrams don't imply the knowledge of category theory becuase you can prove things about concrete things with them without knowing general category theory
10:58:28 <copumpkin> koeien37: the catsters ones?
10:58:33 <koeien37> copumpkin: yeah
10:58:37 <copumpkin> yeah, they're nice
10:58:58 * ezyang loves commutative diagrams
10:59:09 * copumpkin only uses associative diagrams
10:59:10 * Saizan prefers equations
10:59:13 <copumpkin> sometimes even alternative ones
10:59:30 <koeien37> I prefer nonassociative noncommutative diagrams
11:00:39 <HaskellLove> I enjoy the ignorance not knowing what commutative diagrams and associative diagrams are...
11:01:40 <copumpkin> I just made up the latter term
11:01:54 <copumpkin> a commutative diagram looks like a graph :)
11:02:09 <ben0x539> HaskellLove: We do not enjoy your ignorance, at least not when it ends up getting in the way of you solving your next problem euler
11:04:05 <HaskellLove> copumpkin yeah I have seen similar things from category theory books that i tried to read and left like after 10 pages ... if i learn haskell first the math might be easier to understand later
11:04:22 <koeien37> that is probably true
11:04:35 <koeien37> you don't need to know it before you can use monads and so on in Haskell
11:04:43 <koeien37> it's just that, once you know it, it's a convenient language
11:12:35 <Saizan> imo it's not that monads are about sequencing, but that they don't guarantee order indipendence like pure code does, in the sense that f <$> a <*> b can't be generally rewritten as flip f <$> b <*> a, while f a b = flip f b a, so this holds just as well for applicatives and arrows
11:13:07 <Saizan> (yeah, i like to write the same thing with different wording)
11:13:17 <koeien37> that is a good explanation
11:13:59 <koeien37> some monads are about sequencing, others arent
11:14:01 <koeien37> '
11:14:18 <HaskellLove> I passed some monads stuff from the book, and i got to Monad transformers. Nothing makes sense here, anyone can help me in pm so we dont flood here with basic questions?
11:14:44 <jlouis> HaskellLove: one way to think about transformers are stacks of monads
11:15:13 <jlouis> HaskellLove: so it is a way to compose the effects of different monads by stacking them on top of each other
11:17:12 <jmcarthur> well, the be more clear, a monad transformer is not a monad until it is stacked on top of something that is already monad
11:17:33 <jmcarthur> it's a method of monad transformation more than it is of monad composition
11:17:57 <jlouis> that is indeed true
11:17:58 <jmcarthur> it just so happens that many monad transformers are implemented with a composition of monads
11:18:12 * hackagebot upload: GPipe 1.1.4 - A functional graphics API for programmable GPUs (TobiasBexelius)
11:18:27 <koeien37> jmcarthur: well, that's not a coincidence
11:18:48 <jmcarthur> koeien37: not entirely, anyway
11:19:18 <jmcarthur> koeien37: i think a lot of it is simply that we tend to come up with a plain monad to capture an effect before we think about the transformer version
11:19:30 <ezyang> Any monad transformer is trivially a monad when applied to the Id monad, though...
11:19:32 <koeien37> yes
11:19:38 <jmcarthur> koeien37: but some monads are instead defined as a transformer applied to Identity
11:19:44 <koeien37> ezyang: this touches slightly the point that I tried to make earlier
11:19:48 <jmcarthur> uh, yes, as ezyang said
11:20:04 <koeien37> having 2 versions of functions
11:20:11 <koeien37> filterM, filter; mapM, map; and so on
11:20:12 <jmcarthur> but that doesn't mean the transformer must use any monad besides the one it is transforming internally, at least not explicitly
11:20:39 <koeien37> but in most cases you're not going to be able to do a whole lot with the MT NotMonad then
11:21:13 <jmcarthur> i only brought it up because i wanted to emphasize that a monad transformer by itself doesn't magically make a monad
11:21:23 <koeien37> ack
11:21:25 <b_jonas_> sure it does, it's the other way
11:21:34 <b_jonas_> a monad transformer makes a monad from Identity,
11:21:38 <jmcarthur> the distinction between transformation and composition sometimes slips peoples' minds
11:21:41 <b_jonas_> but a monad doesn't automatically generalize to a monad transformer
11:22:00 <jmcarthur> b_jonas_: yes, but Transformer NotAMonad doesn't necessarily make a monad, is all i mean
11:22:18 <b_jonas_> by NotAMonad, do you mean Identity?
11:22:28 <jmcarthur> no, i mean something that's not a monad
11:22:34 <b_jonas_> oh, sure
11:22:58 <b_jonas_> gigo applies to monad transformers
11:23:04 <jmcarthur> i think my point has now passed us by
11:23:44 <c_olin> is there a similar splitAt function that splits the list into a list instead of a tuple?
11:24:20 <koeien37> :t (\(x,y) -> [x,y] .) . splitAt
11:24:21 <lambdabot> parse error on input `)'
11:24:31 <koeien37> :t ((\(x,y) -> [x,y]) .) . splitAt
11:24:32 <lambdabot> forall a. Int -> [a] -> [[a]]
11:24:40 <b_jonas_> c_olin: no, because people couldn't agree on which one is the best to include in base, so there are whole split combinator libraries on cabal
11:24:53 <b_jonas_> that give lots of such functions
11:25:05 <c_olin> ok thanks
11:25:10 <b_jonas_> c_olin: you can abuse groupBy though
11:25:13 <koeien37> yeah, the "splits" or "breaks" function doesn't exist
11:25:39 <jmcarthur> :t uncurry (:) . second pure . splitBy
11:25:41 <lambdabot> Not in scope: `splitBy'
11:25:41 <koeien37> mainly because of such differences as, do you want to include the breaking element, what about multiple occurring breaking elements after each other and so on
11:25:45 <jmcarthur> :t uncurry (:) . second pure . splitAt
11:25:46 <lambdabot>     Couldn't match expected type `(a, a)'
11:25:47 <lambdabot>            against inferred type `[a1] -> ([a1], [a1])'
11:25:47 <lambdabot>     Probable cause: `splitAt' is applied to too few arguments
11:26:00 <jmcarthur> eh, the idea is there. i will not flood the channel
11:26:09 <jmcarthur> needs another (.) in there
11:26:21 <b_jonas_> > groupBy (\_ x -> ' ' /= x) "you can abuse groupBy though"
11:26:22 <lambdabot>   ["you"," can"," abuse"," groupBy"," though"]
11:26:55 <c_olin> hmmm
11:28:04 <jaredj> @hoogle a -> [(a,b)] -> maybe b
11:28:05 <lambdabot> Did you mean: a -> [(a, b)] -> Maybe b /count=20
11:28:05 <lambdabot> Prelude lookup :: Eq a => a -> [(a, b)] -> Maybe b
11:28:05 <lambdabot> Data.List lookup :: Eq a => a -> [(a, b)] -> Maybe b
11:28:16 <jaredj> heck with the map then
11:28:17 <koeien37> lookup
11:32:41 <jaredj> is it true that the primary reason to use maps is they're faster?
11:32:50 <jaredj> (when larger?)
11:33:04 <koeien37> compared to assoc. lists?
11:33:14 <koeien37> yes, they are faster and also provide a convenient API
11:34:06 <jaredj> oh, like all the union and update and all
11:35:12 <koeien37> Data.List has at least a few of those
11:37:04 <HaskellLove> people recommend me some project so I learn monads, euler project thought me list operations and basics of haskell but does not motivate the need to learn monads and advanced haskell...
11:37:30 <ben0x539> Write an IRC bot
11:37:37 <aavogt> solve project euler at the type level!!
11:37:58 <mreh> is there monad more general than List?
11:38:13 <HaskellLove> ben0x539 seriosly?
11:38:14 <idnar> project typeler
11:38:15 <jmcarthur> more general?
11:38:15 <mreh> :t concapMap
11:38:17 <lambdabot> Not in scope: `concapMap'
11:38:21 <mreh> :t concatMap
11:38:22 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
11:38:38 <nniro> is there a standard network IO library?
11:38:42 <koeien37> Network
11:38:43 <idnar> mreh: how would a monad be "more general"?
11:38:54 <aavogt> you could deal with a general monad
11:39:00 <ben0x539> HaskellLove: Anything but juggling numbers and then coming to IRC being all indignant about maths
11:39:02 <aavogt> Monad m => ...
11:39:09 <idnar> mreh: I think there's a MonadLogic typeclass in one of the logic packages, if that's what you mean
11:39:18 <ben0x539> Presumably writing a thing that connects to irc and does things will make you solve more interesting problems
11:39:21 <jmcarthur> mreh: are you looking for a monad that works on list-like structures the same way the list monad works?
11:39:29 <mreh> jmcarthur: yes
11:39:41 <jmcarthur> like instance Foldable f => Monad f or something?
11:39:43 <nniro> koeien37: Network is not part of the base right (just to know if I already have it)?
11:39:45 <HaskellLove> ben0x539 any interesting links you can recommend for this project?
11:39:53 <mreh> jmcarthur: yeah i suppose
11:39:55 <jmcarthur> Foldable is not sufficient
11:40:05 <koeien37> I meant network
11:40:10 <jmcarthur> need a way to convert back from a list to the other type
11:40:14 <koeien37> network is not base, but it is in HP iirc
11:40:15 <ben0x539> HaskellLove: You could look at lambdabot or the geordi bot or something for inspiration
11:40:30 <ben0x539> but the interesting part would be figuring it out on your own instead of looking at links before even doing something
11:40:37 <koeien37> if you want better performance, there is network-bytestring
11:40:51 <jmcarthur> if you can make a type class that do that then you can make your generalized list monad type
11:40:57 <jmcarthur> but you'd need it to obey some laws
11:41:04 <jmcarthur> like fromList . toList = id
11:41:52 <idnar> isn't there a type class like that? Sequence or something
11:42:05 <jmcarthur> i don't think it's in base, at least
11:42:17 <idnar> hmm, no, Sequence is a type
11:42:25 <jmcarthur> well, Seq is
11:42:32 <idnar> well, yeah
11:42:43 <aavogt> @type S.fromList
11:42:45 <lambdabot> forall a. (Ord a) => [a] -> S.Set a
11:42:49 <aavogt> @type Seq.fromList
11:42:50 <lambdabot> forall a. [a] -> Seq.Seq a
11:43:15 <idnar> anyhow, I think MonadLogic is more like what you want
11:43:32 <idnar> assuming you want the backtracking-like behaviour of the list monad
11:44:31 <mreh> jmcarthur: concat map is defined for Foldable
11:44:48 <idnar> mreh: not really, the result would have to be of list type
11:45:07 <idnar> unless I'm missing something
11:45:20 <idnar> the problem is that concatMap doesn't really make sense for something like a tree
11:45:25 <jmcarthur> :t Data.Foldable.concatMap
11:45:27 <lambdabot> forall a b (t :: * -> *). (Data.Foldable.Foldable t) => (a -> [b]) -> t a -> [b]
11:45:33 <jmcarthur> yeah, that's a list
11:45:39 <mreh> poo
11:45:41 <idnar> you can flatten the tree into a list, and then concatMap on that
11:45:51 <jmcarthur> but then you have to fromList it
11:45:58 <jmcarthur> which is not provided by Foldable
11:46:11 <mreh> it seems you can concatMap a tree, but the result is a list
11:46:31 <idnar> concatMap just isn't really a generic fold operation
11:46:46 <idnar> well, mind you, I don't think Foldable is a generic fold anyway
11:47:32 <idnar> I guess by generic fold I mean catamorphism
11:47:46 <mreh> foldr is a catamorphism
11:47:54 <idnar> only on lists, though
11:48:01 <idnar> Foldable defines foldr :: (a -> b -> b) -> b -> t a -> b
11:48:26 <mreh> ooh
11:49:20 <idnar> so for a list, that's (a -> b -> b) -> b -> [a] -> b, which is the right type
11:49:26 <jmcarthur> but if you want exactly the same semantics as list for this monad then the concatMap semantics is perfect
11:49:33 <idnar> for Maybe, that's (a -> b -> b) -> b -> Maybe a -> b which doesn't make any sense
11:49:47 <jmcarthur> it's only if you want something more native to the type in question that it might not work
11:49:59 <idnar> you want (a -> b) -> b -> Maybe a -> b
11:50:16 <jmcarthur> i'd say concatMap makes sense if you can define both toList and fromList for the type in question such that fromList . toList == id
11:50:35 <idnar> for a binary tree, you want something like (a -> c -> c) -> (b -> c -> c) -> c -> Tree a b -> c
11:50:38 <jmcarthur> even if it's not the only possible monad
11:51:10 <idnar> jmcarthur: sure, that makes sense for a "Listy" typeclass; I'm not sure "Foldable" would be the right name for that
11:51:24 <jmcarthur> no
11:51:46 <idnar> you probably wouldn't want to define instances for all the types that have Foldable instances, at any rate
11:51:46 <jmcarthur> but Foldable isn't enough anyway, so it's a non-issue
11:51:59 <jmcarthur> surely any listy class would also be foldable, though
11:52:14 <idnar> sure, you could define a Foldable instance for it
11:52:25 <idnar> or maybe it should subclass Foldable
11:52:36 <idnar> I'm never sure which way around those things should work :/
11:52:36 <jmcarthur> class Foldable f => Sequence f where fromList :: [a] -> f a
11:53:15 <Saizan> you could use unfoldr :)
11:53:37 <idnar> Foldable doesn't have unfoldr
11:53:53 <Saizan> yeah, i meant as method for Sequence, sorry
11:53:59 <idnar> oh, yeah
11:54:54 <idnar> well, I'd probably define fromList using foldr
11:56:00 <Saizan> Foldable's foldr? can you?
11:56:05 <idnar> no, list's foldr
11:56:24 <Saizan> ah, ok, i see
11:56:25 <idnar> I mean in a Sequence instance definition
11:56:47 <idnar> I still need to read that paper about bananas and lenses
11:56:55 <idnar> or whatever it's called
11:59:58 <nswill> Attempting to do any functional programming in mathematica *really* makes you appreciate the rigorous and predictable foundations of haskell
12:00:23 <ben0x539> Predictability is the most underrated property of programming languages :V
12:00:56 <koeien37> Haskell is not very predictable
12:01:10 <sinelaw> C rules!
12:01:12 <koeien37> C is
12:01:18 <monochrom> Nondeterminism: the most underrated property of programming languages.
12:01:30 <sinelaw> wait. Assembly rules!
12:01:32 <koeien37> nah not really. C leaves too much behavior implementation-defined
12:01:52 <sinelaw> voltage rules!
12:01:52 <j4cbo> C is predictable until you try to do something interesting, and then you realize that (a) you don't know as much C as you thought and (b) what koeien37 said
12:01:57 <monochrom> Nondeterminism forces programmers to prove rather than just test.
12:01:59 <j4cbo> (aliasing rules, oh god D:)
12:02:31 <sinelaw> a turned-off computer rules even more!
12:02:46 <sinelaw> nothing doin'
12:12:32 <saiko> hi all
12:14:07 <sinelaw> yo!
12:14:45 <koeien37> hello!
12:15:11 <saiko> hey!
12:15:42 <saiko> I'm a haskell newbie.. had a simple question.. tht I'd come by ask here..
12:15:48 <koeien37> feel free to ask
12:15:54 <Botje> ready the hot pokers!
12:16:56 <saiko> I'm using Data.Binary.Get to parse some data.. I have a function
12:17:06 <saiko> parseData :: Get Msg
12:17:21 <koeien37> if it's more than one line, basically, we prefer it if you paste it
12:17:23 <koeien37> ?hpaste
12:17:23 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
12:17:27 <saiko> I want to have a lazy list of these Msgs
12:17:50 <saiko> well, its just a simple getWord8
12:17:58 <saiko> type Msg = Char
12:18:19 <saiko> parseData = chr . fromIntegral <$> getWord8
12:18:42 <aavogt> > fromIntegral (1::Word8) :: Char
12:18:43 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
12:18:43 <lambdabot>    arising from a use of `GHC....
12:18:57 <aavogt> > chr $ fromIntegral (1::Word8) :: Char
12:18:58 <lambdabot>   '\SOH'
12:19:27 <saiko> i wanted to know how I can construct a lazy list of messages.. basically given function :: Get a, how do I get Get [a]
12:19:29 <saiko> ?
12:19:42 <aavogt> @type replicateM
12:19:43 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
12:19:57 <Asztal> @src ap
12:19:57 <lambdabot> ap = liftM2 id
12:20:02 <xerox> ?type sequence . repeat . chr . fromIntegral <$> (undefined :: IO Int)
12:20:03 <lambdabot>     Couldn't match expected type `m a' against inferred type `Char'
12:20:03 <lambdabot>     In the first argument of `(.)', namely `chr'
12:20:03 <lambdabot>     In the second argument of `(.)', namely `chr . fromIntegral'
12:20:09 <xerox> ?type sequence . repeat $ chr . fromIntegral <$> (undefined :: IO Int)
12:20:10 <lambdabot> IO [Char]
12:20:11 <xerox> sorry
12:20:53 <aavogt> does saiko need unsafeInterleaveIO to make Get lazy?
12:21:21 <xerox> is Get in Applicative?
12:21:31 <aavogt> Get is a Monad
12:21:48 <xerox> many = sequence . repeat for Applicatives
12:23:05 <mercury^> How can you sequence applicative?
12:23:22 <xerox> Alternative, not Applicative, pardon
12:23:33 <b_jonas> mercury^: sequenceM
12:23:47 <b_jonas> or sequenceA
12:23:53 <b_jonas> @type sequenceA
12:23:54 <lambdabot> Not in scope: `sequenceA'
12:23:57 <b_jonas> hmm
12:24:00 <b_jonas> how's it called then?
12:24:08 <aavogt> it's not in scope
12:24:16 <aavogt> @type Data.Traversable.sequenceA
12:24:17 <lambdabot> forall (t :: * -> *) (f :: * -> *) a. (Data.Traversable.Traversable t, Applicative f) => t (f a) -> f (t a)
12:25:16 <b_jonas> that then
12:25:42 <jimmyjazz14> is there a standard way to apply a list of functions over a single value (not fold)
12:25:47 <jimmyjazz14> like:  t -> [t -> b] -> [b]
12:25:51 <b_jonas> xerox: are you sure many is that? I don't think it is
12:25:59 <xerox> b_jonas hmm
12:26:10 <sinelaw> @hoogle t -> [t->b] ->[b]
12:26:10 <aavogt> > sequence [succ, pred, (+2)] 0
12:26:11 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
12:26:11 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
12:26:11 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
12:26:11 <lambdabot>   [1,-1,2]
12:26:32 <aavogt> jimmyjazz14: you probably need to import  Control.Monad.Instances for that to work
12:26:44 <sinelaw> @hoogle [t->b] ->t->[b]
12:26:45 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
12:26:45 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
12:26:45 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
12:26:59 <sinelaw> @type sequence
12:27:00 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
12:27:03 <xerox> b_jonas maybe not.
12:27:08 <saiko> hmm.. thanks guys.. need to read through all that..  me = not too fast
12:27:13 <jimmyjazz14> this is my version of it: mapR u = map (\f-> f u)
12:27:30 <mercury^> @pl \t f -> map ($ t) f
12:27:30 <lambdabot> map . flip id
12:27:40 <mercury^> jimmyjazz14: that.
12:27:58 <aavogt> jimmyjazz14: well I showed a library function that's exactly the same as your mapR
12:28:09 <aavogt> but sequence does other things too
12:28:20 <jimmyjazz14> oh yeah sorry didn't see that
12:30:37 <luite> is there some standard way to handle 'flags' in haskell? (usually stored as int in C, using bitwise operations to combine or check for flags)
12:31:02 <xerox> ADTs
12:31:20 <mental> i don't think that's "usually" even done in C anymore
12:31:22 <b_jonas> luite: well, haskell has ints and bitwise operations too
12:31:29 <burp> @oeis 0 2 6 8 12 14 18 22 24 26 32 34 36 38 42 48 50 54 56 62 66 68
12:31:30 <lambdabot>  Sequence not found.
12:31:35 <luite> xerox: yes I guessed that, but how?
12:31:37 <Twey> mental: You'd be surprised‚Ä¶
12:31:45 <Twey> luite: Records
12:32:02 <luite> b_jonas: yes I know, but that's not really typesafe unless wrapped in data or newtype
12:32:10 <Twey> data FlagField = FlagField { flag1 :: Boolean, flag2 :: Boolean, flag3 :: Boolean }
12:32:49 <xerox> data Conf = ...; f :: Conf -> ...
12:33:08 <lispy|web> preflex: seen dcoutts
12:33:08 <preflex>  dcoutts was last seen on #haskell 10 days, 6 hours, 34 minutes and 37 seconds ago, saying: Raevel: your main modules do not need to be called Main.hs
12:33:13 <lispy|web> Hmm
12:33:15 <xerox> You can also store better informations than True-False values.
12:33:46 <lispy|web> data BetterThanBool = ContextSpecificAffirmative | ContextSpecificNoWay
12:34:20 <lispy|web> Might want to do the constructors in a different order if you derive Ord, simple because True is way more than False
12:34:22 <ClaudiusMaximus> data Flag = A | B | C deriving (Eq, Ord)    type Flags = Set Flag   -- how i would probably do it
12:35:25 <luite> Twey: hmm, that doesn't make combining flags very convenient
12:35:45 <b_jonas> just use ints
12:36:00 <luite> Twey: although you could make something to take a list of flag functions
12:36:24 <luite> hasFlags xs c = and $ map ($c) xs
12:37:02 <luite> otherwise it gets something like:  flag1 c && flag2 c || (not.flag3) c
12:37:51 <Twey> luite: Indeed
12:38:13 <Twey> hasFlags [flag1, flag2, not . flag3] c
12:38:21 <jaredj> how "bad" is it to use TH?
12:38:23 <Twey> Oh, or
12:38:35 <Twey> all ($ c) [flag1, flag2, not . flag3]
12:38:46 <Twey> djinni: Not bad‚Ä¶
12:38:49 <Twey> er, jaredj
12:39:46 <jaredj> i'm parsing an sgml file into records, and different tags should result in different types of records
12:40:05 <jaredj> since polymorphism is hard, different types of records means differently named functions
12:40:07 <b_jonas> jaredj: I think there are some xml libraries based on that
12:40:08 <sshc> which hackage package exports renderString?
12:40:19 <jmcarthur> data Flag = Foo | Bar | Baz | ... deriving Ord ; newtype Flags = Flags (Map Flag Bool)
12:40:19 <sshc> I'm reading http://www.haskell.org/haskellwiki/Opengl#I_can.27t_display_text_with_renderString
12:40:25 <jmcarthur> luite: ^^
12:40:33 <jaredj> b_jonas: it isn't xml though :( e.g. unmatched tags
12:40:39 <b_jonas> sure
12:40:41 <jmcarthur> then you get insertions, removals, unions, etc. for free form the map
12:40:45 <jmcarthur> *from
12:40:52 <jaredj> b_jonas: oh you mean based on TH?
12:40:54 <jmcarthur> and it's easy to add more flags later
12:41:04 <b_jonas> jaredj: I'm not really sure
12:41:08 <jaredj> oh ok
12:41:09 <jmcarthur> and you could use Monoid or something to make certain operations more convenient
12:41:15 <jmcarthur> say, union
12:42:10 <jmcarthur> or you could even just say fromList [(Foo, False), (Baz, True)]
12:42:16 <b_jonas> jaredj: look at second part of http://haskell.org/HaXml/icfp99.html
12:42:21 <jmcarthur> oh i'm dumb
12:42:27 <jmcarthur> use Set Flag, not Map Flag Bool
12:42:51 <luite> jmcarthur: yes ClaudiusMaximus already suggested that
12:42:52 <jmcarthur> and don't even both newtype wrapping it
12:42:57 <jmcarthur> *bother
12:43:06 <jmcarthur> oh i missed that entirely
12:43:14 <jmcarthur> sorry for the noise then
12:43:15 <luite> I like it, it also accuratly describes what it represents
12:43:21 <luite> +e
12:44:12 <b_jonas> and then to create that set, you have to pass the set library a flagset to tell what hashing and allocation strategy it should use for that set
12:44:19 <b_jonas> nah, just use ints
12:44:26 <b_jonas> foo = 1; bar = 2
12:44:30 <jmcarthur> huh?
12:44:34 <b_jonas> that's the simplest. you just combine them with .|.
12:44:37 <jmcarthur> hashing and allocation strategies?
12:44:49 <b_jonas> I'm just saying using a set it too heavyweight
12:45:00 <jmcarthur> for what?
12:45:05 <luite> b_jonas: it depends on the situation, it might be a premature optimization
12:45:05 <b_jonas> for just passing some flags
12:45:10 <jmcarthur> flags are not typically set, unset, and read very often
12:45:29 <jmcarthur> why use an awkward interface for something that won't even save much time or space in the long run?
12:45:51 <b_jonas> jmcarthur: Set.fromList [foo, bar] is the awkward interface, not foo .|. bar
12:45:59 <jmcarthur> not that i disagree that foo .|. bar .|. etc is an alright interface
12:46:31 <jmcarthur> luite: most functions that take flags just use [Flag], btw
12:46:38 <jmcarthur> that i have seen, anyway
12:47:42 <luite> jmcarthur: that probably faster in general too
12:47:44 <joe1> wondering if you have checked out http://code.google.com/p/anic/
12:48:07 <Twey> Haha, /p/anic/
12:49:04 <Twey> Interesting
12:49:47 <luite> ok, I'll just use lists then :)
13:02:48 * hackagebot upload: hakyll 0.4.1 - A simple static site generator library. (JasperVanDerJeugt)
13:05:23 <gwern> @hoogle (a -> a) -> a -> (a -> a) -> a -> a
13:05:24 <lambdabot> No results found
13:05:41 <xerox> ?djinn (a -> a) -> a -> (a -> a) -> a -> a
13:05:41 <lambdabot> f a b c _ = c (a b)
13:12:03 <jlouis>  /20
13:13:00 <gwern> :t iterate
13:13:01 <lambdabot> forall a. (a -> a) -> a -> [a]
13:14:56 <gwern> > iterate (^3) 2
13:14:57 <lambdabot>   [2,8,512,134217728,2417851639229258349412352,141347765182270746366663800059...
13:16:16 <gwern> @src iterate
13:16:16 <lambdabot> iterate f x =  x : iterate f (f x)
13:19:33 <lispy|web> > iterate (join (^)) 2
13:19:39 <lambdabot>   mueval: ExitFailure 1
13:19:48 <lispy|web> > join (^) 2
13:19:49 <lambdabot>   4
13:20:22 --- mode: ChanServ set +o monochrom
13:20:41 --- mode: monochrom set -bbbb *!*@unaffiliated/bob0 *!*=4858e6bd@gateway/web/freenode/x-vebkgdfrwwuqjrvp *!*@117.20.26.32 *!*@12.182.142.213
13:20:41 --- mode: monochrom set -bbbb *!*@92.1.247.* *!*=freefree@*.103-56-74.mc.videotron.ca *!*i=MbM313@119.63.138.* *!*@119.63.138.34
13:20:41 --- mode: monochrom set -bbbb *!*@user-24-236-92-14.knology.net *!*n=Ucuntu@*.79.151.34.dsl.dyn.telnor.net *!*@CPE-124-179-50-115.lns9.ken.bigpond.net.au *!*@ip72-218-136-178.hr.hr.cox.net
13:20:41 --- mode: monochrom set -bbbb *!*@115.128.30.22 *!*n=forth@*.hsi4.kabel-badenwuerttemberg.de *!*n=Lexclu@124.238-67-87.adsl-static.isp.belgacom.be *!*n=nds@*.dsl.scrm01.sbcglobal.net
13:20:43 --- mode: monochrom set -bbbb *!*n=enzo71@94.162.62.* *!*@80-254-73-139.dynamic.swissvpn.net *!*n=usesec@*.dynamic.swissvpn.net *!*n=lol@*.hsd1.ma.comcast.net
13:20:46 --- mode: monochrom set -bbbb *!*n=19736@*.revip.asianet.co.th *!*n=78910@*.revip.asianet.co.th plinka!*@* *!*@87.110.231.94
13:20:48 --- mode: monochrom set -bbbb *!*n=plinka@87.110.228.* *!*@c-98-218-95-239.hsd1.dc.comcast.net *!n=gschuett@* *!*@pool-71-172-173-171.nwrknj.east.verizon.net
13:20:51 --- mode: monochrom set -bbbb *!*@72-61-98-46.pools.spcsdns.net *!*n=ioerror@*.pools.spcsdns.net *!*=indiante@*.dsl.renocs.pacbell.net *!*=michael_@88.235.165.*
13:20:54 --- mode: monochrom set -bbbb *!n=Ic@cpe-71-66-232-204.columbus.res.rr.com *!*@178.z2.klimovsk.net *!*@217.118.66.101 *!*n=Igor@87.110.193.*
13:20:57 --- mode: monochrom set -bbbb *!*n=hugo@*.dsl.telepac.pt *!*n=plinka@87.110.242.* *!*n=NaDa@87.196.235.* *!*@dsl51B7A23A.pool.t-online.hu
13:20:58 <lispy|web> monochrom: ?
13:21:00 --- mode: monochrom set -bbbb *!*n=jabbarz@80.79.157.* *!*@96.234.239.219 *!*=Stim_Jim@*.vic.bigpond.net.au *!*@cpe-066-057-078-104.nc.res.rr.com
13:21:02 <gwern> @src sum
13:21:02 <lambdabot> sum = foldl (+) 0
13:21:03 --- mode: monochrom set -bbbb *!*=vrul*@* *!*n=Krintus@195.85.238.* *!*@195.85.238.205 *!*@85.219.193.*
13:21:05 --- mode: monochrom set -bbbb *!*i=irc@*.kraslan.ru *!*n=makubex@77.90.75.* *!*n=oke@*.dsl.bell.ca imxsd!*@*
13:21:07 --- mode: monochrom set -bbbb *!*@78-57-141-87.static.zebra.lt *!*=arssami0@119.30.36.* *!*=midnight@*.pitbpa.fios.verizon.net *!*=484df868@gateway/web/ajax/mibbit.com/x-4d2439e9099c8d72
13:21:10 --- mode: monochrom set -bbbb *!*n=Sanane@88.241.117.* *!n=legalgol@84.228.158.103 *!*i=saippua@*.kpylaajakaista.net *!*@91.135.163.63
13:21:13 --- mode: monochrom set -bbbb *!*=Maxicann@*.ai.une.maxicanne.com *!*@f049129202.adsl.alicedsl.de *!v_fgd@194.44.175.44 *!*@ip-81-11-183-100.dsl.scarlet.be
13:21:16 --- mode: monochrom set -bbbb *!*n=a9b@*.rabat2-27-236-12-196.wanamaroc.com *!*n=asdgas@*.syr.edu *!*Gast*@*!#haskell-ops xah_lee!*@*
13:21:19 --- mode: monochrom set -bbbb *!*i=dan@67.102.103.* *!*@79.116.188.129 joshs!*@* *!*i=JaVaK@*.adsl196-15.iam.net.ma
13:21:21 --- mode: monochrom set -bbbb *!n=chatzill@*.wa.bigpond.net.au *!*@200.79.144.187.dsl.dyn.telnor.net *!*@203-219-131-38.static.tpgi.com.au *!*n=andrew@*.hsd1.co.comcast.net
13:21:25 --- mode: monochrom set -bbbb *!*@*.prtelecom.hu *!*=victimof@218.75.17.* *!n=g@* *!*n=ijase@24.42.187.*
13:21:26 --- mode: monochrom set -bbbb *!*@pool-71-183-59-77.nycmny.fios.verizon.net *!*@c-66-30-245-236.hsd1.ma.comcast.net *!*n=qqqq@* coldpizza72i@*!*@*
13:21:29 --- mode: monochrom set -bbbb *!n=s_e-b-e_@77.253.183.172 *!*@kansas.shawnetworks.com *!*@or-69-68-252-13.dyn.embarqhsd.net *!*=newdog27@76.73.16.*
13:21:32 --- mode: monochrom set -bbbb angles!*@* *!*=mapbc000@*.pool.t-online.hu *!*=jairiiuk@121.121.39.* palomer!*@*
13:21:34 --- mode: monochrom set -bbbb *!*=tstrogen@*.hari.cable.virginmedia.com *!n=somethin@209.56.61.28 *!*@91.185.246.98 *!*=Nigh8ter@*.76.241.56.dsl.dyn.telnor.net
13:21:37 --- mode: monochrom set -bbb *!n=palomer@* *!n=dongs@* *!*@201.170.169.23.dsl.dyn.telnor.net
13:21:39 --- mode: monochrom set -e fxr!i=user@gateway/tor/x-95d6de60578c1498
13:21:46 <copumpkin> oh my
13:21:49 <monochrom> Oops I pressed the wrong button! Sorry.
13:21:51 <monochrom> Oops I pressed the wrong button! Sorry.
13:22:00 <copumpkin> twice!
13:22:18 <lispy|web> is that banning or unbanning people?
13:22:18 <monochrom> But it seems I should restore the exempt at least.
13:22:25 <Ke> so you can have quite a few bans on this network
13:22:38 <monochrom> Is exempt +e?
13:22:50 --- mode: monochrom set +e fxr!i=user@gateway/tor/x-95d6de60578c1498
13:22:55 <monochrom> OK good.
13:23:02 --- mode: monochrom set -o monochrom
13:23:04 <bob0> monochrom: thank you
13:23:57 * copumpkin awaits a thousand trolls now
13:24:01 <copumpkin> omg palomer
13:24:14 <copumpkin> @palomer
13:24:14 <lambdabot> Blargh!
13:24:16 <copumpkin> @palomer
13:24:17 <lambdabot> Category theory is the Paris Hilton of mathematics
13:24:37 <Ke> Yeeaaaah!
13:25:02 <lispy|web> ?keal
13:25:02 <lambdabot> can you make a macro that builds the expression accoridng to a genetic algorithm where you decide what is good and what is bad?
13:25:08 <monochrom> (I won't restore the bans. The important ones are already stored in ChanServ --- lazy evaluation.)
13:25:37 <xerox> monochrom fine
13:25:57 <copumpkin> zomg monochrom is a rebel
13:26:10 <arr2> <lambdabot> Category theory is the Paris Hilton of mathematics
13:26:12 <arr2> hardly
13:26:25 <medfly> oh yeah, are you going to argue with lambdabot now?
13:26:30 <arr2> lol
13:26:30 <luite> does chanserv only restore the ban after the person has already joined?
13:26:37 <monochrom> Yes.
13:26:48 <luite> ah more fun that way, you can see the bans actually working :)
13:27:21 <RayNbow> ChanServ bans are awesome
13:27:59 <RayNbow> put someone on the akick list, remove the ban, watch as people rejoin and get banned again
13:28:47 <elly> monochrom: why do you have a button for failing like that? :P
13:29:15 <Ke> people have all sorts of buttons
13:29:55 <monochrom> OK, so it's xchat, the banlist window. There is the "remove" button, which I knew and intended. But there is also the "crop" button, I was wondering what it meant, (and no hover tips), so I tried...
13:30:02 <Ke> like the one that starts mplayer with some bizarre japanese show, takes a screenshot and scps it to a www-server
13:30:18 <elly> monochrom: :P oops
13:31:16 <Zao> monochrom: Almost as fun as when an op on service-less networks manage to /deop -yes *
13:31:20 <Zao> Including himself.
13:31:47 <Ke> well there is mode +R at least on the ircnet
13:32:05 <mreh> > let f 1 = 2; f = id in map f [1..10]
13:32:06 <lambdabot>   Equations for `f' have different numbers of arguments
13:32:06 <lambdabot>    <interactive>:1:4-...
13:32:21 <mreh> no they dont
13:32:30 <jlouis> Even some opless networks can survive that
13:32:31 <mreh> one is partial application
13:33:12 <monochrom> The pattern-matching syntax doesn't cater for that.
13:34:26 <mreh> humpf
13:34:38 <monochrom> I imagine maybe you can design a language to support it. But add type inference and what you get is misunderstanding the programmer left right and centre when the programmer makes a mistake.
13:36:13 <LordMetroid> I hear a lot of DSL mentioned, what does the abbreviation stand for?
13:36:22 <mreh> domain specific language
13:36:31 <aavogt> > reverse "DSL"
13:36:32 <lambdabot>   "LSD"
13:36:41 <monochrom> domain-specific language
13:36:51 <aavogt> that's what they call it in french
13:37:31 <LordMetroid> ahh
13:40:57 * benmachine is writing his lambda step-evaluator but stuck on what to do with "(\x y -> x + y) y"
13:41:27 <monochrom> rename to (\x newname -> x + newname) y
13:41:45 <benmachine> then I need a way to make new names on demand
13:42:06 <benmachine> I'm not sure I like the idea of, for example, just adding 's until I run out of collisions
13:42:13 <monochrom> Yes! This is why most people's evaluator is in some "deal out unique thingies" monad.
13:42:20 <benmachine> ho hum
13:42:31 <xerox> ?fresh
13:42:32 <lambdabot> Hach
13:42:45 <aavogt> @list
13:42:45 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
13:42:50 <c_wraith> it's also why people use de bruijn indices.
13:42:50 <monochrom> The rest of the people use de Bruijn numbering at the very beginning.
13:42:52 <kpreid> you could generate a name which is not any of the names currently in use
13:43:04 <Saizan> unless you use stacks/closures to delaying the substitions
13:43:26 <benmachine> kpreid: you could, the difficulty is generating one that isn't horrible
13:43:26 <Saizan> s/ing//
13:43:42 <jlouis> Or (P)HOAS :)
13:43:47 <benmachine> Saizan: this is another idea but I'm not sure it's a full solution
13:43:55 <Saizan> (the stack structure gives you shadowing for free)
13:44:03 <monochrom> This is also why GHC's inferred type variables seem to be bizzare patterns.
13:44:17 <Saizan> benmachine: well, you end up not evaluating to a single lambda term but to a term paired with an environment
13:45:03 <benmachine> Saizan: you end up getting let x = y in \y -> x + y, or something similar?
13:45:42 <Spockz> Why are folds on datatypes other than list called catamorphisms and not just folds?
13:45:45 <benmachine> I suppose that doesn't work if the outer y is an expression containing an x
13:46:07 <jlouis> Spockz: a catamorphism is the generalization of a fold
13:46:19 <Saizan> benmachine: not exactly like let in haskell, because of how naming is used there
13:46:47 <Spockz> jlouis: in other words a fold is a catamorphism on a list
13:46:50 <benmachine> Saizan: the purpose of my exercise is to produce a haskell expression
13:47:11 <jlouis> Spockz: yep. see http://en.wikipedia.org/wiki/Catamorphism
13:47:32 <Spockz> jlouis: yes I read that, but I was more interested in the origins of the terminology
13:47:33 <benmachine> jlouis: googling HOAS got me nothing that sounds useful, what is it?
13:47:42 <aavogt> @where hoas
13:47:43 <lambdabot> I know nothing about hoas.
13:47:44 <jlouis> benmachine: higher order abstract syntax
13:48:13 <jlouis> Use a binder from the meta-language to represent one in the object language
13:48:24 <Saizan> benmachine: in theory, once you've this (expression, environment) pair, you can inline the environment into the expression, not sure if that's any better than substituting from the start
13:48:26 <monochrom> HOAS maybe does not help because the point of this evaluator is to show intermediate educational steps.
13:48:48 <jlouis> ah yes, then HOAS might be a bad idea
13:48:51 <benmachine> monochrom is correct
13:49:11 <benmachine> I suppose I'm going to have to come up with a name factory
13:50:07 <jlouis> a name supply :)
13:50:22 <jlouis> x <- fresh
13:50:25 <jlouis> or something such
13:50:30 <xerox> ?fresh
13:50:30 <lambdabot> Haci
13:50:33 <monochrom> What kpreid says. If you have the whole expression, you can just look at it and pick a non-clashing name. This is pure functional.
13:51:05 <jlouis> &20
13:51:19 <benmachine> pure functional, agreed
13:59:34 <tromp_> still it's nice to extend the name, so you can see that e.g. y21 is some renaming of y
13:59:59 <CalJohn_> a fold is more than a cata on a list
14:00:16 <CalJohn_> associativity matters in a fold
14:00:38 <Spockz> hmm  yes
14:02:17 <sinelaw> @seen Peaker
14:02:17 <lambdabot> Unknown command, try @list
14:02:21 <sinelaw> preflex, seen Peaker
14:02:22 <preflex>  Peaker was last seen on #haskell-blah 4 days, 6 hours, 16 minutes and 44 seconds ago, saying: also have been programming for fun since age 10 or so
14:02:35 <sinelaw> for fun
14:04:01 <lispy|web> A cata also reduces something right?
14:04:03 <lispy|web> > (\f -> foldr (\x acc -> f x : acc) []) (+1) [1,2,3,4]
14:04:04 <lambdabot>   [2,3,4,5]
14:04:06 <LOL> hi everyone
14:04:12 <lispy|web> That's map in terms of foldr
14:04:18 <copumpkin> lispy|web: yep
14:04:44 <copumpkin> > foldr ((:) . (+1)) [] [1..5]
14:04:45 <lambdabot>   [2,3,4,5,6]
14:06:23 <Guest20523> hi room
14:06:28 <potatishandlarn> quit
14:06:41 <copumpkin> hi Guest20523
14:08:03 * jmcarthur wonders what a good model for a partial map with an enumerable domain would be
14:08:29 <copumpkin> jmcarthur: model?
14:08:37 <jmcarthur> yeah, a semantic model
14:09:12 <jmcarthur> kind of like how k -> Maybe a is a semantic model for Map except that it doesn't capture the ability to get the keys of the map
14:09:21 <Guest20523> that's forward  thinking xD
14:10:07 <lispy|web> jmcarthur: What makes k -> Maybe a, into a semantic model for Map?
14:10:10 <jmcarthur> well, it applies to both conal's proposal to make Map more semantically general and events in the usual FRP sense
14:10:15 <lispy|web> jmcarthur: (these terms are new for me)
14:11:03 <jmcarthur> lispy|web: http://conal.net/papers/type-class-morphisms/
14:11:07 <jmcarthur> lispy|web: the Map example is in that paper
14:11:30 <copumpkin> jmcarthur: ([k], k -> a) :P
14:11:47 * copumpkin tries to not write [(k, a)]
14:12:12 <jmcarthur> copumpkin: but now the partiality is limited to Maybe (it's either in the list or it's not)
14:12:25 <jmcarthur> copumpkin: i'd like it to stay general so i can, say, use [a] instead of Maybe
14:12:44 <copumpkin> ((n : Natural), Fin n -> k, k -> v)
14:13:03 <copumpkin> ;)
14:13:07 <jmcarthur> helpful
14:13:10 * copumpkin keeps saying the same thing
14:13:20 <copumpkin> sorry :)
14:13:38 <jmcarthur> that model also fails for things like applicative
14:13:55 <copumpkin> how so?
14:14:45 <jmcarthur> (ks, ff) <*> (ks', fx) = (ks'', fy)  -- ks'' now might list keys for values in fy that are undefined
14:14:52 <mreh> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15750#a15750 -- did I mess up the formatting or something?
14:15:03 <jmcarthur> since the semantic model says ks'' = ks++ks'
14:15:06 <mreh> it says LilyPond.hs:77:5:
14:15:06 <mreh>     The last statement in a 'do' construct must be an expression
14:15:42 <jmcarthur> well, and of course the fact that a key might be listed more than once
14:15:42 <mreh> and it's pointing at the 4th line!
14:15:48 <jmcarthur> but that would be solvable by using Set instead
14:16:01 <Veinor> mreh: the 'key <- local' line?
14:16:01 <jmcarthur> but then we have to model Set
14:16:09 <jmcarthur> and it has to be enumerable, ah!
14:16:14 <copumpkin> jmcarthur: I guess you're not talking about my Fin one?
14:16:14 <mreh> Veinor: yup
14:16:18 <Veinor> hm.
14:16:30 <mreh> oh, rogue bracket
14:16:31 <mreh> see it?
14:16:34 <Twey> Extra bracket, mreh
14:16:35 <Veinor> ahh.
14:16:36 <Veinor> yeah.
14:16:38 <Twey> Oh, you saw it
14:16:47 <jmcarthur> copumpkin: it's the same thing, isn't it?
14:16:51 <Twey> Misleading error, though‚Ä¶
14:17:12 <jmcarthur> copumpkin: but now, i was talking about ([k], k -> a)
14:17:12 <mreh>  Twey: yeah
14:17:15 <jmcarthur> *but no
14:17:35 <jaredj> is there a complete, single document about template haskell 2, or should i read both the th1 paper and the th2 notes?
14:17:45 <mreh> @hoogle (a -> a) -> Int -> a -> a
14:17:46 <lambdabot> Data.Sequence adjust :: (a -> a) -> Int -> Seq a -> Seq a
14:17:46 <lambdabot> Data.IntMap adjust :: (a -> a) -> Key -> IntMap a -> IntMap a
14:17:46 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
14:18:00 <gwern> jaredj: there is no good TH documentation
14:18:02 <gwern> abandon all hope
14:18:07 <jaredj> ok :)
14:18:15 <copumpkin> jmcarthur: hmm, I see what you're aiming for now
14:18:30 <mreh> how to apply a function n times?
14:18:51 <copumpkin> mreh: iterate f xs !! n
14:18:58 <jaredj> @src iterate
14:18:58 <lambdabot> iterate f x =  x : iterate f (f x)
14:19:01 <copumpkin> that's not ideal though
14:19:23 <Veinor> why does Haskell have if/then/else as keywords as opposed to an operator?
14:19:29 <mreh> it's pretty monstrous
14:19:29 <gwern> jaredj: you seem too cheerful for a man who has abandoned all hope
14:19:35 <gwern> jaredj: turn that frown rightside up
14:19:35 <copumpkin> Veinor: I want to kill it with fire
14:19:38 <mreh> Veinor: haskell 98 on has "if"
14:19:50 <Twey> foldr (.) id (replicate n f) $ n
14:19:55 <copumpkin> mreh: ?
14:19:58 <jmcarthur> copumpkin: heh, that's another case where generalized application would be cool, for iterate
14:20:00 <Twey> Veinor: Because :√æ
14:20:06 <copumpkin> jmcarthur: :) yeah
14:20:14 <mreh> if True a _ = a; if False _ a = a
14:20:18 <gwern> too bad liskell is dead. might be interesting to see what haskell with lisp syntax is like
14:20:37 <Twey> I think it's probably because of the limited precedence levels of H98‚Ä¶
14:20:46 <Veinor> > if True 2 3
14:20:48 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
14:20:51 <Veinor> :|
14:20:53 <Twey> It's kind of tricky to make things that are lower-precedence than ($)
14:21:02 <Veinor> precedence -1!
14:21:06 <c_wraith> Should precedence be a float?  >_>
14:21:12 <gwern> @let if True a _ = a; if False _ a = a
14:21:13 <lambdabot>   Parse error: KW_If
14:21:18 <gwern> @let fi True a _ = a; if False _ a = a
14:21:19 <lambdabot>   Parse error: KW_If
14:21:24 <Veinor> I use ?
14:21:24 <sproingie> mreh: don't you mean if' ?
14:21:29 <mreh> yeah, that's right
14:21:30 <Veinor> because that way I can say (True?) a b
14:21:32 <Veinor> :D
14:21:39 <copumpkin> mreh: that doesn't exist anywhere
14:21:40 <sproingie> i thought if' was a Caleskell thing
14:21:45 <copumpkin> it's a @pl thing
14:22:02 <mreh> if' is on Wikipedia
14:22:02 <copumpkin> you could define it easily
14:22:15 <jaredj> gwern, D;
14:22:17 <jmcarthur> @let fi True a _ = a; fi False _ a = a
14:22:18 <copumpkin> mreh: fine, it isn't in any standard modules
14:22:19 <lambdabot>  Defined.
14:22:21 <sproingie> half the stuff in the prelude you can define easily
14:22:23 <Veinor> > let (?) a b c = if a then b else c in (True?) 2 3
14:22:24 <lambdabot>   2
14:22:26 <Veinor> :D
14:22:26 * gwern nods approvingly
14:22:29 <xerox> we need Data.Catamorphisms
14:22:32 <sproingie> point is to have it always available
14:22:40 * Twey shakes his head disapprovingly
14:23:06 <jaredj> :S
14:23:09 <Twey> @let (y ?? n) p = if p then y else n
14:23:11 <lambdabot>  Defined.
14:23:24 <Twey> If you're going to do (?) then you really want it lower-precedence than function application
14:23:29 <Twey> So you can say True ? 2 3
14:23:37 <sproingie> everything is lower precedence than function application
14:23:41 <Twey> Er, higher-
14:23:54 <sproingie> > True ?? 2 $ 3
14:23:55 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
14:23:55 <lambdabot>    arising from the literal `2'...
14:24:06 <Twey> sproingie: No, that's not ?
14:24:07 <benmachine> 2 ?? 3 $ True
14:24:08 <jmcarthur> > 2 ?? 3 $ True
14:24:10 <lambdabot>   2
14:24:11 <Twey> Right
14:24:13 <sproingie> oh ick
14:24:19 <jmcarthur> i like it
14:24:21 <jaredj> > let {wtf=False;omg=False,bbq=False} in wtf ?? omg bbq
14:24:22 <lambdabot>   <no location info>: parse error on input `,'
14:24:22 <Veinor> it's the ternary operator!
14:24:23 <jmcarthur> point free conditionals
14:24:24 <Twey> @let (?) p y n = if p then y else n
14:24:25 <lambdabot>  Defined.
14:24:28 <jaredj> doh
14:24:29 <sproingie> in reverse anyway
14:24:32 <sproingie> very smalltalky
14:24:34 <Twey> That was Veinor's (?)
14:24:40 <sproingie> actually it looks like forth
14:24:44 <Twey> > 2 ? 3 $ True
14:24:44 <jmcarthur> sproingie: it mirrors foldr, maybe, and either
14:24:45 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
14:24:45 <lambdabot>    arising from the literal `2'...
14:24:51 <Twey> Er
14:24:55 <Twey> > True ? 2 $ 3
14:24:57 <lambdabot>   2
14:24:58 <jmcarthur> sproingie: the target of the catamorphism is the last argument in those
14:24:59 <sproingie> forth love if honk then
14:25:00 <Twey> I guess that works
14:25:07 * Twey honk
14:25:18 * jaredj else
14:25:21 <Twey> (??) is about currying, though
14:25:30 <Twey> You generally want to curry ‚Äòif‚Äô on the predicate
14:25:36 <Twey> Never on the false branch
14:25:47 <jmcarthur> :t 2 ?? 3
14:25:48 <lambdabot> forall t. (Num t) => Bool -> t
14:25:56 <jmcarthur> see? it's nice
14:26:01 <Twey> *nod* Precisely
14:26:06 <sproingie> at this point i'm back to liking the builtin if syntax
14:26:19 <jmcarthur> i like to call it bool, though
14:26:28 <Dashkal> tslashdot
14:26:30 <jmcarthur> like maybe and either
14:26:42 <Twey> I see the attraction, but prefer operators
14:27:01 <Dashkal> meh, only problem with xmonad is that the active window isn't nearly as clear
14:27:10 <jmcarthur> i like every operator to have a prefix notation equivalent, but not necessarily the other way around
14:27:16 <sproingie> i can see a use for both
14:27:28 <jmcarthur> Dashkal: i have my xmonad set to make inactive windows slightly translucent
14:27:43 <Dashkal> That might be a good move.
14:28:25 <jmcarthur> Dashkal: XMonad.Hooks.FadeInactive along with xcompmgr
14:28:55 <Dashkal> heh, and here I already went and manually wrote my own fade routines.  I'll look into that
14:29:01 <jmcarthur> heh
14:29:56 <Dashkal> Discovered in the process that haskell's X bindings lack a delete window property function
14:30:07 <jmcarthur> eww
14:30:11 <Dashkal> Or was that attribute.  I get confused.
14:36:40 <Veinor> I think I'm going to install xmonad on my netbook for lightweightness. but compiz is so pretty~
14:37:14 <jmcarthur> i don't think compiz is pretty at all
14:37:28 <sproingie> who cares about pretty after a few minutes
14:37:34 <kqrx> compiz can be MADE pretty, with some time
14:38:20 <jmcarthur> sure, but so can most other things
14:38:23 <roostaj> what? you don't like big spinning boxes?
14:38:29 <sproingie> hard to make twm pretty
14:38:32 <Veinor> I just like the preview for window switchers. :p
14:38:54 <jmcarthur> why use previews when you can just switch windows live?
14:38:59 <sproingie> i use a pretty plane-jane alt-tab
14:39:09 <Veinor> true. I guess I just like the feeling of smoothness it gives me
14:39:22 <sproingie> the animations just makes it slow and makes the windows dance around
14:39:39 <Veinor> I just realized I haven't booted my big laptop into linux in, like, ages.
14:39:41 <Veinor> :/
14:39:46 <roostaj> I wish I was on *nix :(... but I'm an audio junkie and my fancy soundcard only works nicely with Windows
14:39:55 <jmcarthur> the only use i can think of for the animations is for people who are hopelessly lost in spatial modes of thought
14:40:06 <Veinor> jmcarthur: or by people who like shiny things
14:40:08 <Veinor> (most computer users)
14:40:14 <roostaj> lol
14:40:34 <sproingie> stuff like expose is actually a useful animation
14:40:35 <jmcarthur> roostaj: what sound card do you have?
14:40:39 <sproingie> i dont use it myself, others love it
14:40:49 <jmcarthur> sproingie: i used to like it before i got a tiling window manager
14:40:49 <Alpounet> how many of you running xmonad on an archlinux ?
14:40:52 <Alpounet> just to know :-)
14:40:55 <jmcarthur> Alpounet: me me me!
14:40:59 <roostaj> jmcarthur: it's actually old now... it's a soundblaster X-FI
14:41:15 <roostaj> jmcarthur: but it has no support for linux
14:41:15 <Alpounet> jmcarthur, why comes I'm not surprised ? heh
14:41:25 <jfhall> Alpounet: me
14:41:35 <monochrom> not me.
14:41:44 <jfhall> sucks to be you...
14:41:49 <Alpounet> haha
14:41:55 <monochrom> (OK, I am using neither archlinux nor xmonad anyway)
14:42:14 <jfhall> out of curiosity, what do you use?
14:42:21 <Alpounet> as long as you're not using windows, it's okay.
14:42:24 <sproingie> i like minimization/restore animations with the taskbar too, makes it easier to follow where the window is going to be mapped
14:42:29 <jmcarthur> roostaj: http://www.phoronix.com/scan.php?page=article&item=990&num=1
14:42:32 <monochrom> ubuntu and no customization.
14:42:37 <jmcarthur> roostaj: the situation looks bad, yeah
14:42:51 <sproingie> otherwise it's distracting when it pops up and the eyes have to immediately seek for the content
14:43:19 <roostaj> jmcarthur: i've gotten it to work before, but it doesn't have all of the features and it is VERY flakey
14:43:29 <jmcarthur> Alpounet: actually, why *are* you not surprised?
14:43:36 <jmcarthur> roostaj: :(
14:43:40 <jfhall> monochrom: ubuntu's not bad, I used it for a while. For me it seems a bit bloated, but it makes things a lot easier most of the time
14:43:43 <roostaj> it's a shame :)
14:44:20 <Alpounet> jmcarthur, hmm, I'd say it fits the idea I have of you
14:44:27 <jmcarthur> jfhall: every time i have a problem not solvable with a GUI tool i thank god that i'm not using ubuntu
14:44:41 <Alpounet> simple, efficient, but powerful and flexible
14:44:50 <Alpounet> much like alt-stdlib's desired design
14:44:52 <Alpounet> :-p
14:44:54 <jmcarthur> Alpounet: i like that idea of me :)
14:44:59 <Twey> Any problem is solveable with the right GUI tool ;)
14:44:59 <sproingie> yah it's totally like winbloze LOL LOL
14:45:20 <jmcarthur> Twey: okay, i should have qualified that with an *existing* GUI tool
14:45:28 <jfhall> jmcarthur: ya, I do everything from the command line, so I'm more into the do it yourself distros
14:45:42 <Twey> jmcarthur: Let's cheer on Eros, then, eh
14:45:57 <jmcarthur> heh
14:46:22 <sproingie> the only thing that makes me squirm on any debian is if i have problems with the package database
14:46:31 <jmcarthur> i've actually been considering giving FreeBSD a shot as my primary OS
14:46:42 <sproingie> cant remember the last gui admin thing i did
14:46:44 <jmcarthur> now that GHC is seeing some up-to-date support on it
14:46:59 <sproingie> maybe aptitude counts as gui?
14:47:03 <jfhall> jmcarthur: I used to run FreeBSD as my main OS and I loved
14:47:31 <jmcarthur> jfhall: what made you switch away, out of curiosity?
14:47:41 <monochrom> gnome-terminal is a GUI tool.
14:48:07 <jfhall> jmcarthur: but there were things that linux had in the desktop realm that FreeBSD didn't have. To be specific... I can't really remember right now... give me a second :)
14:48:24 <Ke> valgrind!
14:48:49 <Ke> that's also one reason why linux is as x86-locked as windows
14:48:59 <Twey> monochrom: But you don't solve the problems with gnome-terminal
14:49:12 <jmcarthur> Ke: http://bugs.kde.org/show_bug.cgi?id=208531
14:49:17 <Twey> You solve the problems with the command-line apps you run in it (like zsh, &c.)
14:49:33 <monochrom> I don't use zsh. I use bash.
14:49:52 <Veinor> bash-basher!
14:49:53 <Twey> That's okay
14:50:09 <Twey> The 21st century will catch up with you eventually
14:50:11 <pikhq> monochrom: Then you should start using a shell with an editor in it.
14:50:17 <Twey> Until then, that's what I inserted the ‚Äò&c.‚Äô for ;)
14:50:53 <jfhall> jmcarthur: I can't really remember why I switched, linux has flash but that doesn't really matter. Arch is easier to maintain, i just run yaourt -Syu rather than portsnap for ports and updating binary sources for the OS. Either way, I've been thinking about switching back, I run FreeBSD on all my servers, so it would keep things uniform.
14:51:15 <sproingie> yaourt?
14:51:18 <jmcarthur> jfhall: flash works with the linux emulation, doesn't it?
14:51:28 <jmcarthur> sproingie: yaourt is like pacman but also supports aur packages
14:51:38 <jfhall> sproingie: it's a bash script that sits on top of pacman for aur packages
14:51:39 <monochrom> I thank you for your advice, but it leads me to think also "a GUI-hater talking about catching up with the 21st century"
14:51:46 <sproingie> it looks like the cat stepped on the keyboard
14:51:58 <jmcarthur> yeah it's a horrible name
14:52:02 <pikhq> Ke: Valgrind also works on x86_64-pc-linux-gnu, ppc-unknown-linux-gnu, ppc64-unknown-linux-gnu, and x86-apple-xnu, y'know.
14:52:11 <jfhall> jmcarthur: kind of, I'm on x64, and in firfox it would work for a while and then crash firefox
14:52:20 <jfhall> jmcarthur: it was just a pain
14:52:25 <Twey> monochrom: I'm no GUI-hater!  I use GUIs for lots of things.  Browsing, image-viewing‚Ä¶
14:52:34 <Twey> ‚Ä¶ Windows-emulating‚Ä¶
14:52:39 <Alpounet> jmcarthur, and yaourt uses pacman-color !
14:52:40 <jmcarthur> jfhall: using 64 bit flash?
14:52:40 <sproingie> these days i can deal even with windows except for the crummy terminal
14:52:42 <Alpounet> very important, heh
14:52:49 <sproingie> there's mintty if i want cygwin, but i don't always
14:53:19 <jfhall> jmcarthur: 64 bit freebsd with 32 bit linux emulation for the flash
14:53:25 <Twey> sproingie: ‚Äòyaourt‚Äô is French for ‚Äòyoghurt‚Äô
14:53:28 <sproingie> mostly because ghci and crew don't work well in it, and ghcii.sh has no line editing
14:53:30 <SamB_XP_> yeah, why the heck did they bake in the terminal so hard ?
14:53:32 <Twey> (which also looks like a cat stepped on the keyboard)
14:53:50 <Twey> jfhall: I switched to Chromium because of that
14:53:52 <jmcarthur> jfhall: ah. now that there is a 64 bit flash for linux i wonder if it is any different
14:54:05 <Twey> It's much more stable, and when Flash crashes it doesn't take the browser with it, which makes it actually usable
14:54:26 <jfhall> jmcarthur: possibly, I hadn't even thought about that
14:54:31 <SamB_XP_> Twey: another nice thing is that you can kill flash when it steals too much RAM
14:54:36 <Twey> Yeah
14:54:39 <Twey> Which it always does :√æ
14:54:53 <jfhall> Twey: I can't use chromium because there is no good alternative to vimperator
14:55:09 <jmcarthur> jfhall: how about uzbl?
14:55:13 <Ke> pikhq: yes, but none of the interesting archs like arm and mips!
14:55:31 <jfhall> jmcarther: I have read a little about uzbl, but never tried it.
14:55:32 <Alpounet> Twey, you French ?
14:55:37 <jfhall> jmcarthur: is it stabel?
14:55:45 <Twey> Alpounet: No, English
14:56:00 <Alpounet> oh
14:56:02 <jmcarthur> jfhall: i think officially, but i've not had it crash. i don't really use it though
14:56:15 <jmcarthur> jfhall: i meant i think *not* officially
14:56:15 <Alpounet> then you're just interested in spelling "yoghurt" in different languages ? :-)
14:56:22 <Twey> jfhall: http://code.google.com/p/vimlike-smooziee/
14:56:33 <Twey> Alpounet: No, I'm *English*
14:56:44 <Twey> Alpounet: And therefore had French drilled into me from an early age :√æ
14:56:53 <jfhall> Twey: I have that, but it still doesn't have all the features of vimperator, mainly o for open page t for new tab...
14:57:05 <Alpounet> Twey, it was sarcastic
14:57:07 <Twey> jfhall: Hmm
14:57:14 <Twey> Alpounet: I figured :√æ
14:57:31 <jfhall> jmcarthur: oh alright, I'll still have to check it out because it looked promising when I first heard about it.
14:57:40 <Alpounet> English people get French drilled into them ? didn't know that.
14:57:50 <monochrom> Twey: The right tool of the 21st Century is not a shell with an editor buffer, but a terminal emulator with an editor buffer so all shells, all REPLs, all theorem provers, and all text-mode irc clients can enjoy it.
14:57:56 <sproingie> thought the normal conquest ended a while ago
14:58:00 <sproingie> norman
14:58:29 <Twey> monochrom: I'll drink to that
15:03:30 <Saizan> monochrom: indeed
15:05:13 <Twey> Still, a shell with an editor buffer is better than nothing :√æ
15:06:16 <Veinor> you know what'd be interesting? haskell bindings for git :O
15:06:54 <Twey> Aren't there already?
15:07:29 <Veinor> are there?
15:07:44 <Veinor> google isn't finding me anything.
15:07:59 <Twey> Huh.
15:08:01 <CalJohn_> Twey: I think the rule is that you have to renounce your citizenship if you actually _learned_ any french in school
15:08:14 <Twey> Damn
15:08:17 <Veinor> I might just implement this in python and use git-python, then.
15:08:22 <Twey> Oh well, I was planning to move to Finland anyway
15:08:45 <Twey> Veinor: Hm :-\
15:08:52 <Twey> I imagine it should be fairly easy to write some‚Ä¶
15:08:59 <Twey> Can't you just call it via the shell?
15:09:05 * benmachine , having written anywhere :: (Typeable a) => (a -> Bool) -> GenericQ Bool, is now struggling to write anywhereBut :: GenericQ Bool -> GenericQ Bool -> GenericQ Bool
15:09:13 <Veinor> Twey: via whatever Haskell has for system("git status')?
15:09:22 <Veinor> I suppose.
15:09:26 <Twey> HSH
15:09:31 <Twey> Probably
15:09:34 <benmachine> (anywhere also appears as :: GenericQ Bool -> GenericQ Bool, with minor modification)
15:09:45 <Veinor> what's the function I want to use?
15:09:50 * hackagebot upload: haskell-src-exts 1.6.0 - Manipulating Haskell source: abstract syntax, lexer, parser, and pretty-printer (NiklasBroberg)
15:10:38 <c_wraith> Veinor: if you want to read the output, look at System.Process
15:10:50 <c_wraith> http://www.haskell.org/ghc/docs/6.10.4/html/libraries/process/System-Process.html
15:11:25 <Twey> Veinor: http://hackage.haskell.org/packages/archive/HSH/2.0.3/doc/html/HSH.html
15:11:44 <Veinor> Twey: ooh.
15:12:15 <Veinor> well, the other advantage of writing it in Python would be that it'd be easier for other users to customize :p
15:12:38 <benmachine> hmmmmmm
15:13:07 <monochrom> Haskell is an easier customization language.
15:13:23 <Veinor> yes, but fewer people know it is what I'm saying.
15:13:36 <Veinor> plus python is built-in to most distros, haskell isn't.
15:13:51 * ski . o O ( how to fix that ? )
15:13:57 <benmachine> would I be right in thinking that I can't make a GenericQ that queries polymorphic types (e.g. finding the length of an [a])?
15:14:07 <Veinor> ski: hah
15:14:36 <Ke> Veinor: haskell allows you to compile binaries so you don't need a full compiletime environment in most distros
15:14:56 <Veinor> true, but then it'd be harder for other people to customize if I just ship the binary
15:15:22 <Veinor> my point is that if I want User X who has a fresh ubuntu install to customize it, I'd want to use python. that or come up with a DSL and a config file
15:15:32 <Veinor> (which would give me an excuse to learn parsec!)
15:15:47 <SamB_XP_> .. and reimplement half of lisp ...
15:16:01 <Veinor> Haha
15:16:11 <Veinor> DSL feature creep.
15:17:01 <Zariel> I have a list of tuples, is there a way to plot them with haskell into a basic X/Y scatter?
15:17:06 <benmachine> is there any reason why one would use Rank2Types given the option of using RankNTypes?
15:17:18 <Veinor> @faq I have a list of tuples, is there a way to plot them with haskell into a basic X/Y scatter?
15:17:18 <lambdabot> The answer is: Yes! Haskell can do that.
15:17:35 <Veinor> :D
15:18:02 <Zariel> lol
15:18:08 <Veinor> you might want to look into this
15:18:09 <Veinor> http://hackage.haskell.org/package/Chart
15:18:10 <monochrom> Some people are rigorous about asking for the minimal.
15:18:15 <Zariel> thanks :D
15:18:24 <SamB_XP_> ... without using HaskellDirect to call into Excel?
15:19:05 <Veinor> documentation seems a bit lacking.
15:20:06 <Saizan> benmachine: iirc there are/were some compilers that supported one and not the other
15:20:06 <sproingie> hdirect hasn't been updated in a long time
15:20:23 <Saizan> s/compilers/implementations/
15:20:38 <benmachine> Saizan: you mean there's more than one compiler? :P
15:20:57 <monochrom> Yeah, there are 1.3928394039 compilers.
15:21:31 <Veinor> What's the .39 etc from?
15:21:50 <sproingie> average of codebases to working compilers?
15:21:54 <Veinor> Hah.
15:22:07 <sproingie> (ratio perhaps)
15:22:48 <monochrom> from lateral thinking outside the box
15:23:00 <Veinor> I think I'll just go with a very simple config file
15:23:08 <Veinor> PROPERTY=value, that sort of thing
15:23:35 <monochrom> Do you support comments? (To complicate your life.)
15:24:44 <sproingie> consider ConfigFile
15:25:45 <Veinor> monochrom: I'll just use ConfigFile
15:26:13 <monochrom> Heh
15:26:48 <kquick2> What can I use to push a function into an IO monad operation as a composition?  basically (a->b) -> IO a -> IO b,  but not fmap, because I want the function applied to a before evaluation of >>= on a.   More specifically I'm trying to do: attempt (makeHandler [h1, h2] d) id on an IO (Attempt x) operation, the IO operation throws various Exceptions and I want the handler to operate on those exceptions.  The Control.Monad.Attempt >>= (or return
15:26:48 <kquick2> the Attempt x will call fail on exception and so my handlers never get invoked.
15:27:30 <xerox> > reads "[2 -- foo\n,3]" :: [(Int,String)]
15:27:31 <lambdabot>   []
15:27:41 <xerox> > reads "[2 -- foo\n,3]" :: [([Int],String)]
15:27:42 <lambdabot>   []
15:27:45 <xerox> :/
15:27:49 <sproingie> :t bracket
15:27:50 <lambdabot> Not in scope: `bracket'
15:28:42 <monochrom> @type liftM
15:28:43 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
15:28:59 <sproingie> hm bracket probably isnt it
15:29:52 <monkfish> is there a quicker way to write "if b then 1 else 0"
15:30:13 <monochrom> > fromEnum True
15:30:14 <lambdabot>   1
15:30:18 <monochrom> \o/
15:30:29 <Veinor> and then fromEnum False turns out to be 0, just to screw with you.
15:30:31 <Veinor> er, -1
15:30:39 <monochrom> > fromEnum False
15:30:40 <lambdabot>   0
15:30:42 <monkfish> :p
15:30:42 <Veinor> > (toEnum (-1)) :: Bool
15:30:44 <lambdabot>   * Exception: Prelude.Enum.Bool.toEnum: bad argument
15:30:47 <Veinor> > (toEnum 0) :: Bool
15:30:48 <lambdabot>   False
15:30:55 <ski> > (reads :: ReadS [Int]) "[2 {- foo -},3]"
15:30:56 <lambdabot>   []
15:30:58 <kquick2> liftM didn't seem to do it either.
15:31:29 <c_wraith> liftM is just fmap
15:31:40 <c_wraith> this is for IO?
15:32:04 <c_wraith> You might want to just use Evaluate in order to force the whole expression
15:32:10 <luite> what is the correct way to FFI an enum using hsc2hs? (both constructing the enum type and converting from a Ptr to that type (and vice versa)
15:32:13 <c_wraith> before passing it to the function
15:33:07 <ski> @type Control.Exception.try
15:33:08 <lambdabot> forall a e. (GHC.Exception.Exception e) => IO a -> IO (Either e a)
15:34:40 <kquick2> It's in main.  I'm calling a function that does IO and returns IO (Attempt x).  If the function returns a Failure Attempt, the fromFailure conversion into IO will cause that Failure to be turned into a fail call.  Instead, I want a handler for the failure via attempt's withHandler.
15:35:42 <kquick2> Probably should be asking Snoyberg...
15:36:03 * ski wonders how `Attempt' is defined
15:51:49 <mreh> are classes the only way to overload a function name?
15:52:09 <sproingie> yep
15:52:24 <sproingie> it's not really overloading, it just feels kinda like it
15:54:20 <Twey> I always expect to be able to do something like (+) :: Num a => a -> a -> a; (a :: Integer) + (b :: Integer) = addInteger a b; (a :: Int) + (b :: Int) = addInt a b
15:54:31 <Twey> (semantically)
15:54:36 <Twey> It confuses me when I can't :√æ
15:58:07 <sproingie> yeah once one class owns a function no one else can
15:58:30 <aavogt> type-directed-name-resolution?
15:58:42 <Twey> sproingie: Yeah, but if a type is *in* the class‚Ä¶
15:58:51 <Twey> I expect to be able to treat it like a constructor
15:59:05 <sproingie> well with numbers you can "cast" using fromIntegral
15:59:12 <sproingie> i'm having to do that all the damn time with my GL stuff
16:00:28 <mreh> it's nice to have a class then there's only one function name to remember
16:03:12 * hackagebot upload: hack-handler-epoll 0.1.2 - hack handler implementation using epoll (ToralfWittner)
16:07:41 <mreh> anyone interested or involved with haskore here?
16:13:22 <sshc> can Haskell do this?
16:13:56 <kmc> @faq Can Haskell do this?
16:13:56 <lambdabot> The answer is: Yes! Haskell can do that.
16:15:14 <Ke> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15751#a15751 I still can not figure out why this crashes on ghci PQ.minPriority (makeQueue (PQ.insert () (QueueEvent 1 "ab")  (PQ.insert () (QueueEvent 2 "ba") PQ.empty)) [])
16:17:40 <Ke> also () is not in Ord is it
16:18:00 <Ke> how come I can switch the parameter order
16:18:02 <mauke_> > () > ()
16:18:02 <lambdabot>   False
16:18:08 <mauke_> it totally is
16:18:09 <Ke> AAAAAA
16:18:14 <Ke> BBBBBBB
16:18:28 <Ke> that explains a lot
16:20:21 <Ke> so is insert by tail recursion more safe than insert by foldl
16:20:35 <Ke> with regard to stack overflows
16:21:30 <gwern> man, finger-trees are complex
16:21:44 <gwern> all the little pieces and intricate update rules
16:21:54 <lispy|web> gwern: that's why everyone is switching to jazz-hands
16:22:07 <gwern> lispy|web: what complexities does that have?
16:22:29 <lispy|web> not much, most people can understand it in just their first or second time looking at them
16:23:13 <gwern> src plox
16:25:23 <knobo> Is there a better way then using a (Writer w a) if one is not interested in the return part (a),but only the "stream of data"/log (w)?
16:26:02 <ben0x539> @type execWriter
16:26:03 <lambdabot> forall w a. Writer w a -> w
16:26:18 <lispy|web> knobo: Well, Writer has a way to execute it that does what you want, but maybe you just want State?
16:26:26 <Heffalump> knobo: just working with the monoid directly might make most sense
16:26:42 <Heffalump> if you want to use do-notation then using a writer is necessary
16:26:44 <lispy|web> actually, I guess switching to State isn't such a great suggestion
16:26:57 <nolrai_FG> I need a discription of the G-machine that lists how it behaves at each step. I know I got one from here before but cant remember what it was called. (should I ask this at #haskell-in depth instead?)
16:27:15 <knobo> Ok, then I think Writer is probably what I use.
16:27:40 <lispy|web> nolrai_FG: hmm...there are papers that document it, I think.
16:27:45 <lispy|web> nolrai_FG: is that what you got before?
16:27:54 <Heffalump> you'll probably find yourself using the 'a' in intermediate bits, anyway. It's just the final one you won't use. Any you can force it not to be there by demanding Writer w () if you want.
16:28:58 <nolrai_FG> lispyIweb: yes I think so.
16:29:39 <nolrai_FG> never mind I'm an idiot.
16:29:41 <Zariel> How can i make this not over flow ? http://github.com/Zariel/euler-haskell/blob/master/025.hs
16:29:43 <Zariel> (i assume it is overflowing)
16:29:47 <nolrai_FG> I have it right here.
16:30:10 <knobo> code is here, if anyone cares: http://github.com/knobo/woim-haskell/blob/writerMonad/woim.hs
16:30:14 <mauke_> Double‚Åà
16:30:33 <lispy|web> nornagon: I'm having trouble finding the pdf, but this paper has some documentation on it: http://portal.acm.org/citation.cfm?id=99385
16:30:59 <sproingie> the euler boid gets the woim?
16:31:39 <Zariel> and how can i stop this ? GHC stage restriction: `len'
16:31:45 <lispy|web> sproingie: hehe
16:31:52 <mauke_> stage restriction‚Åà
16:32:00 <mauke_> what the heck are you doing
16:33:04 <tartaglia> type theory
16:33:06 <tartaglia> can I haz it ?
16:33:13 <lispy|web> tartaglia: yes
16:33:13 <mauke_> @where tapl
16:33:14 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
16:33:52 <Zariel> mauke_: just trying to run the function len, which it wont let me
16:34:02 <mauke_> how are you trying to run it?
16:34:51 <knobo> sproingie: what does euler boid mean?
16:34:59 <mauke_> knobo: "early bird"
16:35:00 <Ke> does haddock generate docs from the code, ie. are the 100% precise with regard to types?
16:35:11 <sproingie> picture saying it in a jersey accent
16:35:18 <Zariel> mauke_: http://github.com/Zariel/euler-haskell/blob/master/025.hs#L12
16:35:37 <knobo> I don't get it :/
16:35:39 <mmorrow> Zariel: i think something odd is happening like you have -XTemplateHaskell on and are not putting a space after some occurrence of "$" ?
16:35:44 <tartaglia> lispy|web: is that book written for haskell, have you read it ?
16:36:07 <mauke_> Zariel: irc.hs:14:0: parse error (possibly incorrect indentation)
16:36:08 <mmorrow> Zariel: since "stage restriction" has to do with template-haskell
16:36:22 <mauke_> that's all I get
16:36:39 <Zariel> i cant see any incorrect indent / brackets anywhere
16:36:49 <mauke_> well, line 12 is simply wrong
16:36:49 <lispy|web> tartaglia: I have a copy, but I never finished it.  I think it develops the language + type system of ML, but that's close enough to get you understanding Haskell's type system
16:36:58 <mmorrow> , let x = [|()|] in $x
16:36:59 <lunabot>  luna: GHC stage restriction: `x'
16:37:02 <mauke_> Zariel: you can't just put expressions in a file and compile it
16:37:10 <mmorrow> , $(let x = [|()|] in x)
16:37:11 <lunabot>  ()
16:37:36 <lispy|web> tartaglia: it goes through all the definitions, much of the design space, and the proof techniques needed to understand the on going research
16:38:35 <tartaglia> does Prolog have anything to do with Type Theory ?
16:38:42 <tartaglia> I'm asking this because I don't really know Haskell
16:38:45 <tartaglia> but I know Prolog
16:38:54 <tartaglia> because I wrote a bunch of stuff in it
16:38:58 <mauke_> as far as I know, no
16:39:16 <lispy|web> understanding the way prolog searches for solutions and horn clauses would certainly help you understand type classes and functional dependencies, but prolog doesn't use type theory
16:39:31 <ezyang> Finally read spj's interview in "Coders at Work"
16:40:04 <gwern> anyone here familiar with disjoint-set/union-find datastructures?
16:40:18 <lispy|web> In other words, knowing and understand prolog would help you learn parts of Haskell, but it's is in no way necessary :)
16:40:30 <mauke_> main = print $ head $ map snd $ filter ((1000 <=) . length . fst) $ zip (map show fibs) [1 ..]
16:40:47 <mmorrow> tartaglia: though class constraints on instances and how ghc resolves them is similar to how prolog searches for a goal or some such
16:41:28 <mmorrow> or at least conceptually
16:41:43 <lispy|web> The best way to learn X is to study X, try X, talk to people about X, and try to teach X.
16:41:54 <mmorrow> i don't know prolog very well though, so that might not be the best way to say that
16:42:12 <gwern> @quote prolog
16:42:12 <lispy|web> Studying Y as a means to learn X has diminishing returns
16:42:12 <lambdabot> ddarius says: Unfortunately, the logic programming community has this unhealthy death grip on Prolog.
16:42:28 <gwern> @quote tune
16:42:29 <lambdabot> BillWood says: it became obvious that when a Prolog program is tuned by removing non-determinism it moves towards a functional program.
16:42:31 <sproingie> .oO( )
16:43:03 <monochrom> heh
16:43:14 <Cale> anyone here who knows if bob0 is still running that script which auto-responds to questions starting with "anyone here" with "no"?
16:43:21 <Cale> I guess not ;)
16:43:25 <gwern> anyone here?
16:43:31 <mmorrow> no
16:43:36 <lispy|web> Hi Cale
16:43:39 <Cale> hi
16:43:48 <lispy|web> I has questions for you :)
16:43:58 <monochrom> That's a cool script. I want more people running it. <duck>
16:43:59 <Cale> oh?
16:44:03 <lispy|web> Did the email I forwarded make any senes?
16:44:04 <lispy|web> sense*
16:44:08 <lispy|web> The one about Show
16:44:12 <lispy|web> well, show package
16:44:15 <Cale> I haven't checked my email...
16:44:22 <mauke_> Show must go on ...
16:44:23 <lispy|web> hehe, it was lke 2 days ago
16:44:30 <tartaglia> thanks all
16:44:37 <tartaglia> mauke_: does the Haskell community have a mst as well ?
16:44:48 <tartaglia> mauke_: you know, that kind of dictator guy ..
16:44:53 <mauke_> haha, what
16:44:57 <tartaglia> mauke_: the Hitler of Perl
16:44:57 <monochrom> minimum spanning tree?
16:44:58 <aavogt> what's a mst?
16:45:07 <mauke_> mst is in no way the dictator of perl
16:45:08 <lispy|web> Cale: the show package compiles fine with base 3, but when using base4 it needs to depend on syb.  Due to cabal bugs with picking base versions it's only a problem for some people
16:45:14 <tartaglia> mst = the Hitler of Perl
16:45:14 <Drunkenmonkey> I see there is an article now on reddit on Haskell and cocaine
16:45:17 <mauke_> some aspects of him overlap with dons, though
16:45:30 <tartaglia> mauke_: who's don ?
16:45:36 <Zao> As long as they don't have a JDH, I'm happy.
16:45:36 <monochrom> don dons
16:45:36 <Cale> lispy|web: I don't really know that much about it, apart from installing it for lambdabot...
16:45:42 <gwern> mst theatre
16:45:44 <mauke_> preflex: seen dons
16:45:44 <preflex>  dons was last seen on #haskell 16 days, 23 hours, 8 minutes and 59 seconds ago, saying: no serious haskell program needs hlist.
16:45:58 <aavogt> @uptime
16:45:59 <lambdabot> uptime: 11d 6h 30m 23s, longest uptime: 1m 10d 23h 44m 29s
16:46:01 <hatds> mst3k?
16:46:01 <tartaglia> hmm ,
16:46:09 <tartaglia> mauke_: I'm qp_pq aka spx2
16:46:14 <lispy|web> Cale: okay, I emailed the person from the "author" field and I forwarded it to you because hackage claims you uploaded the latest version
16:46:22 <Cale> lispy|web: Oh, perhaps the reason I uploaded it was that I fixed a stupid bug in it.
16:46:37 <tartaglia> mauke_: tell me about dons , does he pack the same intolerance as mst ?
16:46:37 <lispy|web> dons is on holiday (that lucky bastard)
16:46:48 <Cale> It used to implement the instance of Show for IO by calling error, iirc.
16:46:54 <luite> where is he?
16:46:55 <mmorrow> haha
16:47:04 <gwern> luite: australia, I hear
16:47:15 <lispy|web> Yeah, something about having summer twice this year
16:47:20 <luite> hehe
16:47:26 <luite> I like winter better :)
16:47:29 <tartaglia> I need to know if I can come here asking loads of questions without some "mst" - like dude telling me
16:47:32 <luite> (going skiing next week)
16:47:34 <tartaglia> "You're drawing too much resources"
16:47:53 <lispy|web> tartaglia: #haskell is very welcoming to people who want to learn
16:47:59 <gwern> tartaglia: I think if there were such a person, they would have flamed you by now
16:48:02 <gwern> I know I would have
16:48:07 <Drunkenmonkey> Can I instead say you're a dumbass?
16:48:12 --- mode: ChanServ set +o Cale
16:48:13 <Drunkenmonkey> To strike a balance
16:48:14 <luite> if anyone else is in zermatt next week we could meet and code some haskell :p
16:48:17 <Drunkenmonkey> oops
16:48:25 --- mode: Cale set -o Cale
16:48:26 <gwern> balance - restored!
16:48:43 <mauke_> tartaglia: there are some people here who care about community management
16:48:55 <lispy|web> Cale: so do you think I should fix it and do an upload?
16:48:58 * ezyang snerks at "community management" 
16:48:58 <gwern> reminds me of my dad watching star wars episode 1 - 'why do they want to restore balance to the force? the light side is dominant! balance means the dark side wins!'
16:49:02 <Cale> lispy|web: go for it
16:49:08 <tartaglia> mauke_: which mst also cares about eh ? what in gods name is this "community management" ?
16:49:09 <lispy|web> Cale:  I feel bad uploading other people's packages normally -- OK
16:49:45 <Cale> I think I mentioned it to twanvl before uploading last time, but even if not, it was a minor change.
16:49:46 <zygoloid> tartaglia: if you want to talk about and learn haskell here, no-one will stop you. if you want to talk about this mst person, however, ...
16:50:30 <lispy|web> tartaglia: zygoloid has a good point.  We have an offtopic channel for when you want to talk to haskell people about non-haskell stuff, it's called #haskell-blah
16:50:34 <Cale> Drunkenmonkey: Be polite to the people here. It might help to not IRC while drunken.
16:50:54 <lispy|web> twanvl: ping
16:51:01 <lispy|web> preflex: seen twanvl
16:51:01 <preflex>  twanvl was last seen on #haskell-blah 3 days, 1 hour, 24 minutes and 47 seconds ago, saying: * twanvl didn't think the question about "data MyType = MyType String | MyType Int" was a bad one
16:51:16 <Drunkenmonkey> My mother always said be yourself and now this, very confusing
16:51:25 --- mode: ChanServ set +o monochrom
16:51:34 <lispy|web> ?tell twanvl I'd like to upload a new version of the show package to fix a dependency bug in the .cabal file.  Is that okay with you?
16:51:34 <lambdabot> Consider it noted.
16:51:45 --- mode: monochrom set +b *!i=55c89673@*
16:51:56 --- mode: monochrom set -o monochrom
16:52:23 <Cale> monochrom: I'm not sure that much was necessary, was it?
16:52:38 <lispy|web> Cale: this all came up because I was pushing goa on people at work :)
16:53:06 <sshc> monochrom: did he part by himself?
16:53:13 <Cale> sshc: no
16:53:23 <sshc> Cale: how did he do that?
16:53:45 <ezyang> operator bits
16:53:46 <Cale> FreeNode has a special way to kick people so that autorejoiners don't work.
16:53:53 <gwern> lispy|web: you shouldn't inflict your musical taste on others. non disputatis gustatorum or whatever the latins said
16:54:06 <Cale> Though, if you're banning the person anyway, I don't see the point in it.
16:55:07 <sshc> Cale: how does freenode do it?
16:56:11 <lispy|web> gwern: similarly with good advice ;)
16:56:58 <Cale> sshc: You mean, what does the server do?
16:57:04 <Twey> What's the command to do that, again?
16:57:07 <Twey> I forget
16:57:29 <mauke_> sshc: freenode has a REMOVE command. it works like KICK, except the server acts as if the victim had sent a PART
17:00:13 <gwern> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15752 <-- does anyone know ML modules? I'm a little confused about what haskell equivalent would be
17:00:27 * j4cbo investigates
17:00:46 <monochrom> This is just an interface.
17:01:15 <monochrom> It is hard to translate to Haskell. No notion of interface except typeclass. But module /= typeclass.
17:01:21 <gwern> yes, but I've never seriously looked at ml modules before
17:01:22 <jlouis> gwern: I know the ML module system has been encoded by Oleg
17:01:26 <monochrom> I mean module system /= typeclass system
17:02:02 <monochrom> But oh! module system can be translated to associated typeclass system.
17:02:10 <gwern> monochrom: true, but don' they both function similarly in this instance, allowing multiple concrete instantiations of a unionfind structure?
17:02:12 <jlouis> gwern: a module type ... is also called a signature. It is an obligation which a module (a structure) can implement
17:02:16 <gwern> eg. first simple lists, then trees, etc
17:02:56 <gwern> jlouis: that sounds like a typeclass to me
17:03:07 <monochrom> The "type t" part needs associated typeclass, not just Haskell typeclass, unless you settle for imperfect translation.
17:03:49 <jlouis> gwern: it isn't. For instance you would have to qualify M.create, where M is hte name of the structure
17:04:02 <monochrom> So, if you like, haskell98 approximation: typeclass PUF t where create :: Int -> t; find :: t -> Int -> Int; union :: t -> Int -> Int -> t
17:04:04 <jlouis> and G.create for another implementor
17:04:21 <monochrom> (Are you aware of the problem with this translation?)
17:04:30 <gwern> monochrom: give me a second :)
17:05:16 * gwern feels I do not understand 'union'
17:05:26 <DigitalKiwi> !troll
17:05:31 <DigitalKiwi> hmm
17:05:38 <DigitalKiwi> is there a troll factoid on one of the bots
17:05:40 <DigitalKiwi> ?
17:05:43 <DigitalKiwi> I thought there was...
17:05:44 <monochrom> No.
17:05:47 <gwern> ?fact troll
17:05:48 <lambdabot> I know nothing about troll
17:06:01 <DigitalKiwi> maybe it's a different channel bot, sorry for troubles
17:06:20 <nominolo> @seen Conal
17:06:20 <lambdabot> Unknown command, try @list
17:06:27 <gwern> preflex: seen Conal
17:06:27 <preflex>  Conal was last seen on #haskell 1 day, 3 hours, 57 minutes and 15 seconds ago, saying: oh well
17:06:29 <nominolo> preflex: seen conal
17:06:29 <preflex>  conal was last seen on #haskell 1 day, 3 hours, 57 minutes and 17 seconds ago, saying: oh well
17:06:32 <gwern> jinx
17:06:36 <monochrom> I'll also need a minute to write the associated typeclass translation.
17:06:41 <gwern> monochrom: ok, I give up. what's the problem?
17:07:12 <conal> nominolo: hi
17:07:20 <nominolo> conal: hiii
17:07:28 <conal> nominolo: hi
17:07:33 <nominolo> hi
17:07:35 <conal> nominolo: how's tricks?
17:07:38 <lispy|web> hey conal
17:07:50 <monochrom> You cannot have two "instance PUF Whee"s. You can have two implementations of that module sig, both with t=Whee.
17:07:54 <conal> lispy|web: yo!  what are you doing these days?
17:08:00 <lispy|web> conal: John L. gave  your beautiful differentiation talk the other day at work, pretty cool!
17:08:04 <monochrom> (You just give the two implementations two different names.)
17:08:16 <gwern> hm. I think I may've misunderstood something. looks like you're supposed to think of it as DisjointSet = [Set], but you can't add two DosjointSets together, you can only add and create sets within a DisjointSet
17:08:19 <nominolo> Your von-Neumann article got me thinking.
17:08:35 <nominolo> About scion's design -- which I'm not really happy with.
17:08:36 <lispy|web> conal: I'm doing well.  I was just going to hack on darcs a bit and then go meet a friend for drinks
17:08:41 <gwern> monochrom: couldn't a newtype get around that?
17:08:43 <lispy|web> conal: how about you?
17:08:43 <conal> lispy|web: glad you liked it.  did he get to "AD, naturally?"
17:09:00 <monochrom> Yes a newtype gets around that. Nothing to get around in ML modules.
17:09:03 <gwern> monochrom: rename Whee Whee' with a newtype, make the second implementation with Whee'
17:09:20 <jlouis> gwern: it is a unionfind. union s A B says that A and B are the same
17:09:21 <lispy|web> conal: we focused on the type class instances and the principles you used to derive the instances
17:09:27 <jlouis> in s
17:09:27 <conal> lispy|web: doing well.  two of my kids (20&25) are coming to live down the road (on the 60 acres next to my 20).  glad to have them here.
17:09:40 <lispy|web> cool
17:09:41 <nominolo> conal: did you have any other general ideas for composotionality except FRP?
17:09:54 <sproingie> kid #20 and kid #25 eh?  conal's been busy.
17:10:04 <nominolo> that's age
17:10:04 <gwern> jlouis: I think I'm starting to understand that. I was getting very confused by what could combine with what
17:10:14 <jlouis> find s A gives you some representant for A. In general not the same as A
17:10:29 <sproingie> nominolo: thanks captain buzkill :p
17:10:33 <jlouis> A and B is in the same set of find s A == find s B
17:10:37 <conal> lispy|web: atm,  i'm also feeling discouraged.    have been trying to nurture a young fellow, who keeps acting reddit-ish on me (http://www.reddit.com/r/programming/comments/alzg3/conal_elliott_can_functional_programming_be/c0ihf87) :(
17:10:37 <jlouis> if..
17:10:38 <nominolo> at your service
17:10:56 <conal> nominolo: "scion's design"?
17:11:05 <gwern> jlouis: one thing I haven't seen mentioned - all the find definitions I've seen never use Maybe or anything like that. is there some trick where you can't look for something not in the union-find?
17:11:25 <jlouis> create 30 creates a disjoint union of 30 elements I guess
17:11:36 <conal> lispy|web: so you got to see design driven by type class morphisms.  cool.  i've gained a lot of faith in that technique.
17:11:36 <nominolo> conal: yeah, or GHC API design.  It's essentially all living in IO
17:11:41 <conal> sproingie: :)
17:12:08 <gwern> jlouis: yeah, but what if I do 'let x = create 20 in find x 30'?
17:12:16 <jlouis> gwern: exception
17:12:20 <gwern> :(
17:12:25 <j4cbo> :(
17:12:34 <jlouis> it is ML, side effects are EVERYWHERE!
17:12:35 <conal> nominolo: about compositionality, yes!  denotational design.  frp is just a special case (and neglected in many frp variations).
17:12:53 <j4cbo> jlouis: only OCaml has that problem, really
17:13:01 <sproingie> i wish i knew exactly what denotational design meant
17:13:10 <gwern> jlouis: well great but this is #haskell!
17:13:16 <j4cbo> jlouis: SML stylistically prefers to use option (Maybe)
17:13:27 <jlouis> j4cbo: true indeed
17:13:34 <mauke_> but SML uses tuples for parameters lists :-(
17:13:41 <nominolo> conal: denotational design requires a simple model, no?  what else?
17:13:44 <conal> nominolo: practicing denotational design, one would never design an API with IO in it.
17:14:01 <j4cbo> mauke_: not always? too often in the library, yes :(
17:14:04 <lispy|web> conal: (reading reddit) wow yeah.  Hmm...I have to admit, I try to avoid having correspondence with people that exhibit his communication style
17:14:09 <monochrom> Yeah I was wondering why this ML code doesn't go "find : t * int -> int". :)
17:14:31 <lispy|web> conal: I'll be honest that I don't understand the principles you used 100%, but they did look very promising
17:14:36 <jlouis> it is Ocaml. Their style is to use currying
17:14:40 <gwern> monochrom: what does that sig mean?
17:14:45 <conal> lispy|web: yeah, me too.  some intuition urged me to give him a chance.  like he has some potential and needs guidance.
17:14:50 <mauke_> gwern: * is type product (tuples)
17:14:52 <lispy|web> gwern: * is like (,)
17:15:04 <jlouis> partially because the ZINC machine originally underlying caml has fast currying application (it doesn't build intermediate closures(
17:15:07 <gwern> ah, so like 'find :: (t,int) -> int'
17:15:25 <monochrom> In ML you write x*y at the type level and (x,y) at the value level.
17:15:25 <sproingie> does ML have kind signatures?
17:15:37 <monochrom> No.
17:15:40 <jlouis> nope
17:15:46 <j4cbo> ML tends to use different syntax for types and values... tuples like monochrom said, unit vs (), etc
17:15:47 <conal> nominolo: DD requires a precise compositional model (in the style of denotational semantics).  simplicity is something to optimize.  i.e. make the model as simple as possible, while still adequate.  get to the essence of the problem domain.
17:15:53 <lispy|web> conal: I think I could learn a lot from your gentle/expressive communication style :)
17:15:56 <j4cbo> 'a list vs [a]
17:16:19 <mauke_> 'a option list
17:16:28 <sproingie> 'x foo always bugged me
17:16:30 <conal> lispy|web: aww, thanks.  :)  i take my time with it.
17:16:31 <nominolo> lispy|web: ever met conal in person?
17:16:34 <monochrom> 'a list opion
17:16:41 <mauke_> feels rather ... German
17:16:54 <monochrom> feels English to me.
17:17:00 <Veinor> which GHC version is the first one to use base 4?
17:17:12 <nominolo> 6.10
17:17:27 * sproingie keeps reading base 4 as {0,1,2,3}
17:17:28 <nominolo> I would think
17:17:31 <Veinor> ugh, this machine has 6.8.2 :(
17:17:32 <monochrom> denotational design favouring guy  <---  ML type expression
17:17:48 <jlouis> lol monochrom
17:18:10 <mauke_> donaudampfschiffahrtskapit√§nsm√ºtze
17:18:16 <j4cbo> exn option cont list ref
17:18:16 <jlouis> gwern: if you ever hit the term 'Functor' in ML land, be aware it is completely different from the Haskell Functor.
17:18:27 <dolio> English is fairly German, isn't it?
17:18:31 <mauke_> monochrom: not quite, because "favouring" connects "denotational design" and "guy"
17:18:34 <gwern> my laziness in not learning haskell functors pays off!
17:18:44 <conal> i programmed a lot in ml before learning haskell.  i often pronounce types in postfix (ml-style) but write types prefix (haskell-style).
17:18:52 <lispy|web> nominolo: yes, once or twice
17:19:09 <lispy|web> nominolo: he gave some talks at my university and think we bumped into each other at icfp
17:19:21 * j4cbo once used a value of type exn option cont list ref in an actual program D:
17:19:35 <dolio> "Integer list" is clearly correct English, though.
17:19:50 <dolio> And "list integer" isn't. It'd need to be "list of integers".
17:19:52 <conal> lispy|web: that was a fun visit.
17:20:06 <dolio> At least, "list integer" wouldn't mean the same thing as "integer list".
17:20:08 <mauke_> English limits itself to two or three levels in my experience
17:20:38 <sproingie> the obvious reason to have the functor type in front is to curry it.  Either String
17:20:45 <lispy|web> conal: also, I don't recall if I told you, but I've been at Galois since October :)
17:21:04 <sproingie> well i guess Either a b isn't a functor, nevermind my goofy language
17:21:04 <nominolo> conal: I have to admit, I learned semantics from Pitts
17:21:04 <lispy|web> conal: I'm working with some really exceptional people and it's been fun
17:21:05 <arr2> curious: how many people here are grad students (perhaps an estimate from someone familiar with the channel)?
17:21:17 <gwern> @quote grad.*stud
17:21:17 <lambdabot> yrlnry says: <byorgey> yrlnry: just some lady who had a lot of money and decided she wanted poor grad students to have some of it after she died... pretty nice of her, actually   <yrlnry> senile
17:21:18 <lambdabot> dementia, more likely.
17:21:21 <conal> lispy|web: oh, yeah.  maybe you did tell me.  congratulations!
17:21:31 <nominolo> conal: well, from his lecture notes, but that didn't include denotational semantics
17:21:31 <lispy|web> conal: thanks!
17:21:32 <gwern> @quote dead.*grad.*student
17:21:33 <lambdabot> No quotes match. Take a stress pill and think things over.
17:21:34 <conal> nominolo: operational?
17:21:36 <monochrom> theorem prover correctness proof report cover <--- 5 levels, or 6, I don't know.
17:21:37 <arr2> :-)
17:21:37 <gwern> what
17:21:43 <nominolo> conal: yep, big step and small step
17:21:44 <gwern> @quote dead.*end
17:21:45 <lambdabot> MarkPilgrim says: "In the long run, the utility of all non-Free software approaches zero. All non-Free software is a dead end."
17:21:49 <gwern> @quote dead.*end
17:21:49 <lambdabot> MarkPilgrim says: "In the long run, the utility of all non-Free software approaches zero. All non-Free software is a dead end."
17:21:52 <gwern> what the heck
17:22:05 <gwern> did we not have a quote to the effect that #haskell is populated by dead-end grad students?
17:22:14 <lispy|web> Except when the grad student continues to work on the project post-grad school?
17:22:16 <sproingie> in the really long run, the utility of everything but reproducing approaches zero
17:22:20 <arr2> lol; gotcha
17:22:22 <sjanssen> gwern: lambdabot loses state at least once a month
17:22:32 <dolio> Also, I'm about 95% sure that Oleg's encoding of ML modules uses functional dependencies, which are comparable to the associated types monochrom has been suggesting.
17:22:38 <gwern> sjanssen: yes, but this is a years-old quote - it should be safe on disk
17:22:52 <mauke_> > fmap succ (Right 41)
17:22:53 <lambdabot>   Right 42
17:22:59 <lispy|web> gwern: unless it was lost the last time lambdabot had to move servers
17:23:13 * lispy|web still needs to get that data to Cale
17:23:15 <gwern> but lots of my old quotes are still there
17:23:18 <gwern> @quote gwern
17:23:18 <lambdabot> gwern says: The Java programmers will welcome us as liberators! I estimate that we will need 50,000 haskellers at most and will be able to wind up the occupation quickly
17:23:25 <gwern> see? that was like '08
17:23:29 <arr2> gwern: I appreciate the point, thou; thank you :)
17:23:29 <conal> nominolo: i renamed my design style from "semantic design" to "denotational design" a while back.  i have a strong personal preference toward denotational semantics.  somehow operational leaves me dissatisfied.  i want to say "yes, but what does it mean?!"
17:23:39 <arr2> s/thou/though/
17:24:05 <monochrom> I agree "semantic design" just asks for a semantic war.
17:24:08 <sproingie> the alliteration makes it more catchy
17:24:19 <conal> nominolo: so "denotational design" is my way of clarifying and acknowledging that there are other kinds of semantics.
17:24:27 <mauke_> demotivational design
17:24:28 <nominolo> conal: Yeah, but denotational semantics seems to have problems when in comes to functions (and computability).  But that may not be a problem for designing APIs
17:24:29 <twanvl> lispy|web: regarding the show package: sure, go ahead and upload it.
17:24:29 <lambdabot> twanvl: You have 1 new message. '/msg lambdabot @messages' to read it.
17:24:34 <conal> monochrom: yes, and confusion.
17:24:45 <lispy|web> twanvl: thanks, I'll do that RealSoonNow
17:24:50 <lispy|web> twanvl: but not likely to be today
17:25:21 <conal> nominolo: what sort of problems?  maybe they are relevant to design, and i haven't noticed.
17:25:53 <nominolo> well, all that stuff about fixpoints, scott domains, and that stuff girard tried to use
17:26:12 <monochrom> <3 fixpoints
17:26:14 <jlouis> scott topology?
17:26:31 <monochrom> powerdomains are powerful
17:26:52 <nominolo> "coherence spaces"
17:26:53 <conal> nominolo: "problems" as in maybe unnecessary complexity?
17:28:06 <nominolo> not sure if it's unnecessesary, but it sure is difficult stuff
17:28:38 <conal> i think of denotational semantics as having two halves -- the harder scott half and the easier strachey half.  the strachey half is more relevant for library design.
17:28:49 <conal> nominolo: yeah.  difficult.
17:29:08 <luite> is it possible to copy a ByteString to a Ptr CString without appending a \0 ?
17:29:30 <luite> oh Ptr CChar, CString is already a pointer
17:29:33 <sproingie> mighty morphing powerdomains
17:29:39 <mauke_> luite: er, why?
17:30:34 <monochrom> You will break procedures that want to see \0
17:30:40 <nominolo> conal: Strachey is new to me
17:30:47 <luite> mauke_: I have an FFI function that requires a pointer to an array and a length
17:30:54 <mauke_> luite: ok?
17:31:08 <conal> nominolo: iirc, strachey had the method of denotational semantics before scott arrived.
17:31:33 <luite> it's binary data, so the \0 is unnecessary
17:31:54 <mauke_> why do you care?
17:31:58 <conal> nominolo: strachey has the idea of compositional translation of programming languages into the untyped lambda calculus.
17:32:24 <conal> nominolo: but at the time, no one had proved that the lambda calculus was consistent, ie had a model.
17:33:11 <conal> although the lambda calculus had been in use for 25 years or so.  people thought it was probably consistent, but there was uneasiness.
17:33:24 <luite> mauke_: I want to do it the correct way :) perhaps I should use a different data structure?
17:33:38 <mauke_> luite: I don't understand the problem
17:33:49 <nominolo> luite: the module Data.ByteSTring.Internal should have some functions
17:34:10 <mauke_> actually, I wouldn't be surprised if bytestrings kept a \0 at the end anyway
17:34:10 <conal> which also mean that the translation to the LC might or might not give meaning to languages.  scott's discovery answered that important question.
17:34:22 <arr2> uneasiness is that of a mathematician listening to Grothendieck in 1958!
17:34:27 <arr2> ;-)
17:34:32 <conal> iirc from my semantics class in 1986 or so.
17:35:17 <monochrom> luite: how does this sound? http://www.haskell.org/ghc/docs/latest/html/libraries/bytestring-0.9.1.5/Data-ByteString-Unsafe.html#v%3AunsafeUseAsCStringLen
17:35:17 <nominolo> Pitts has also given a course on denotational semantics
17:35:21 <nominolo> I'm reading that now
17:35:27 <arr2> nominolo: url?
17:35:30 <luite> mauke_: hm, as far as I know, strings in haskell are never \0 terminated (so at least it shouldn't treat de \0 character as denoting the end of the string)
17:35:33 <nominolo> http://hackage.haskell.org/packages/archive/bytestring/0.9.0.4/doc/html/Data-ByteString-Internal.html#v%3AmallocByteString
17:35:49 <mauke_> ByteStrings aren't Strings
17:35:50 <nominolo> er, http://www.cl.cam.ac.uk/teaching/1998/DenoSema/
17:35:53 <arr2> danke
17:36:18 <polk330> Does any one have a place for me to host a small site.. Please PM me.
17:36:25 <nominolo> this course is good too: http://www.cl.cam.ac.uk/teaching/2001/Semantics/
17:36:39 <Twey> polk330: If it's Haskell-related, you might be able to get a c.h.o site
17:36:41 <luite> nominolo: ah thanks
17:36:44 <nominolo> polk330: would Haskell wiki do?
17:36:57 <polk330> Maybe.
17:37:01 <nominolo> luite: why do you think that a \0 gets added, btw?
17:37:04 <conal> nominolo: as you guessed, you can do denotational design without fretting much about that hard stuff.
17:37:32 <nominolo> conal: I like your simple semantic model (in Haskell) idea.
17:38:11 <luite> nominolo: the documentaiton says so :) (second warning for unsafeUseAsCString)
17:38:13 <nominolo> although, I'm not so convinced how serious type class morphisms should be taken.
17:39:08 <conal> nominolo: have you yet gotten the relevance of TCMs to checking and avoiding abstraction leaks?
17:39:40 <nominolo> conal: I understand that.  But e.g., there are two valid Applicative definitions for [a]
17:40:47 <nominolo> so if my model is [Something] it suddenly has to follow the (arbitrarily?) chosen instance meaning of [a]
17:41:34 <mmorrow> you can put a monoid structure on Integer in two different ways as well
17:41:37 <conal> nominolo: yeah.  [] applicative bothers me also.  the choice of nondeterminism feels arbitrary to me.
17:41:58 <luite> nominolo: oh I guess the CStringLen type is what I should use instead (string with explicit length information)
17:42:21 <conal> mmorrow: yep.  so Integer by itself is more a carrier than an algebra
17:42:29 <nominolo> conal: So, I get the basic idea to describe new things in terms of well understood things.  But I wonder how often that is possible.
17:42:53 <conal> nominolo: i wonder the same.
17:43:12 <conal> nominolo: so i'm working on finding out, by trying.  i hope other people will help.
17:44:00 <mmorrow> conal: does "carrier" have a defined meaning in that sentence? (i suspect from your typeclass morphisms stuff?)
17:44:02 <conal> i'm usually pretty happy to help people brainstorm about denotational design for their domains.  just ask me.
17:44:12 <mmorrow> conal: (also, this just prompted me to read that)
17:44:41 <conal> mmorrow: oh, i mean the set part, omitting the operations & axioms.
17:45:02 <nominolo> conal: I liked Koen's Parallel Parsing Processes paper: http://www.cs.chalmers.se/~koen/pubs/entry-jfp04-parser.html  It ascribes a meaning to every combinator of his DSL.  This seems to follow similar ideas.
17:45:16 <nominolo> Though he uses it to derive an efficient implementation.
17:45:30 <conal> mmorrow: and no, i don't think i use "carrier" in the TCM paper.  i'm remembering its use from math, or logic or something.
17:45:33 <nominolo> And, there may be other possible ways to specify the semantics.
17:45:43 <mmorrow> conal: also, i just became aware the other day that semantics in computer science (or whatnot) is commonly separated into denotational, axiomatic, <another one>. this finally made me grok wtf you actually meant by giving denotational semantics to something (wrt to programming language constructs)
17:45:56 <conal> nominolo: oh, thx.   i'll read koen's paper.  i'm looking for more examples.
17:46:30 <conal> mmorrow: super.  <another one> is probably operational
17:47:00 <mmorrow> conal: also this made me wonder what the gain is (in your opinion) by translating things into another language to give them meaning as i done in denotational semantics, rather than just axiomatize things to begin with?
17:47:11 <mmorrow> s/i done/is done/
17:47:19 <mmorrow> conal: oh right, operational.
17:47:41 <nominolo> mmorrow: you forgot "specification by implementation"
17:47:48 <nominolo> that's the standard way to do it
17:48:02 <mmorrow> heh
17:48:11 <conal> nominolo: yeah. :) :(
17:48:41 <jmcarthur> conal: did you ever happen to think of a reasonable way to model (keys :: Map k a -> [k]) in your semantic model for Map? i'm feeling like the difficulty with that example is similar to the difficulty with Event
17:49:38 <jmcarthur> conal: in that part of Event's purpose is to accumulate information over time, but we don't know what times to accumulate over in a model that looks like T -> Maybe a
17:49:49 <conal> mmorrow: by axiomatize, do you mean sufficiently to define exactly?  i'm always curious about what properties hold, but for me i still get the feeling of talking around something, rather than saying exactly what it is.  please don't read this remark as saying anything about relative merits of approaches.  i just mean to share my own preference.
17:49:56 <mmorrow> conal: so i guess my question is, how do you personally view the difference between denotational and axiomatic semantics? (because i think hearing how it's laid out in *your* head will give some motivation to things in mine)
17:50:29 <mmorrow> conal: right, i'm not sure exactly *what* "axiomatize" means yet in this context, but that's mainly what i'm trying to grok at this point.
17:50:36 <conal> jmcarthur: about keys, i don't think i'd want to reveal a *list*.  probably a set, ie the domain of the function.
17:50:57 <jmcarthur> conal: agreed. i was getting lazy in typing
17:51:12 <jmcarthur> conal: although with the Event version i think we *would* want a list
17:51:21 <conal> jmcarthur: i've never liked the T -> Maybe a model.  because it forbids simultaneous occurrences.  awkward exception.
17:51:26 <jmcarthur> actually, i guess we wouldn't need it
17:51:30 <jmcarthur> conal: well, T -> [a] then
17:51:36 <conal> jmcarthur: for event, yes, i'm with you.  a list.
17:52:08 <jmcarthur> i tend to just say Maybe to avoid explaining why i chose a list ;)
17:52:10 <patch-tag> is there a library function for foldl1 (>>)     ?
17:52:21 <conal> jmcarthur: :)
17:52:37 <nominolo> luite: I read that warning as "it comes out exactly as you put it in".  I.e., ByteString construction never changes the bytes in any way.
17:52:59 <conal> jmcarthur: yeah, T -> [a] is one model i mostly prefer over the one i used on push-pull frp.  or maybe [] :. (-> T), for the sake of Functor
17:53:00 <jmcarthur> conal: the Set thing adds to the confusion of the Map model, though. should a Set be enumerable?
17:53:32 <luite> nominolo: yes, but that is the problem. I read the ByteString from a file which is not \0 terminated
17:53:34 <conal> jmcarthur: a great question for Set.  i like separating this question out of Map.
17:53:54 <mmorrow> jmcarthur: iff it's countable?
17:54:17 <mmorrow> i believe is the def.. dunno how that applies to this though
17:54:25 <conal> jmcarthur: oops -- i mean [] :. (->) T
17:54:55 <luite> nominolo: (so actually it's not a problem with the unsafe version, but it means that the safe version does add a \0 if it isn't in the ByteString)
17:55:10 <dolio> Don't you mean (->) :. []? Or is :. like >>>?
17:55:11 <jmcarthur> conal: do you mean (->) T :. [] ?
17:55:13 <conal> jmcarthur: though applicative for T -> [a] and [] :. (->) T  trouble me
17:55:14 <nominolo> Ah. I see
17:55:22 <dolio> Er, (->) T :. [].
17:55:30 <conal> jmcarthur: thanks.
17:55:30 <mmorrow> jmcarthur: but giving a particular set a *canonical* map to N is the unclear part
17:55:36 <conal> dolio: yeah, thanks
17:55:50 <jmcarthur> mmorrow: indeed
17:56:05 <luite> nominolo: but I found that there is a safe version that returns a (CString,CInt) pair, that doesn't null-terminate the string
17:56:23 <jmcarthur> the only reason we can so easily define toList for Set is because we have an arbitrary Ord constraint on it
17:56:29 <jmcarthur> which i'd rather ignore
17:57:07 <conal> jmcarthur: oh yeah.  nice insight.
17:57:24 <mmorrow> jmcarthur: and "canonical" can be either "up to isomorphism" or "up to exact equivalence"
17:57:30 <conal> jmcarthur: it's perhaps dumb luck that we can sort the domain.
17:57:45 <jmcarthur> it's an abstraction leak, really
17:59:18 <conal> jmcarthur: yeah, probably so
17:59:20 <jmcarthur> conal: what about applicative for (->) T :. [] troubles you?
17:59:38 <jmcarthur> oh, it makes a lot of events at once
17:59:48 <mmorrow> jmcarthur: i guess the only way around that would be to somehow only ever have a single copy of any one equal thing, then use memory address for the arbitrary Ord you need to do Set efficiently
18:00:00 <mmorrow> which unfortunately is impractical in Haskell
18:00:09 <conal> jmcarthur: and makes no occurrences at all except when events have simultaneous occurrences.
18:00:23 <jmcarthur> conal: yeah
18:00:35 <conal> jmcarthur: maybe that's okay.  maybe i ought to trust the model.
18:00:38 <jmcarthur> conal: honestly, though, that doesn't sound so unreasonable to me
18:00:42 <jmcarthur> yeah :)
18:00:46 <conal> jmcarthur: :)
18:01:06 <jmcarthur> conal: i'm more bothered by the difficulty of accumE
18:01:29 <conal> i think before push-pull frp, Event had no Applicative or Monad instance.  i made a guess about their meaning, and so maybe now have some attachment that i ought to let go of.
18:01:31 <jmcarthur> and related functions
18:01:35 <conal> jmcarthur: me too!
18:01:49 <conal> jmcarthur: related: there's junk in that model.
18:02:01 <jmcarthur> conal: it requires an enumerable domain, just like our issue with Map
18:02:05 <jmcarthur> yes?
18:02:42 <conal> jmcarthur: yeah.  we're saying the same thing.  functions with non-enumerable domains constitute the junk.
18:03:06 <jmcarthur> i still do not understand junk i think
18:03:18 <conal> jmcarthur: ooh -- "just like our issue with Map".  hm!
18:03:31 <jmcarthur> conal: Event pretty much is a partial map
18:03:57 <mmorrow> well, isn't the requirement of an enumerable domain the same as just requiring the domain to be Integer? i.e. just push the work of determining the enumeration off onto the "caller"
18:03:58 <conal> jmcarthur: to a list.  which is kind of awkward too.  it's *almost* a relation, but not quite.
18:04:09 <conal> jmcarthur: that "almost" bugs me. :(
18:04:42 <jmcarthur> mmorrow: but we want the domain to be continuous, so the structure must have the enumeration :(
18:04:44 <mmorrow> hmm, well i guess just having it be Integer would lose the other structure it has
18:05:13 <jmcarthur> conal: it's related to TMap T [a], though
18:05:14 <mmorrow> jmcarthur: wait, what? i thought the "structure" was the domain here?
18:05:46 <jmcarthur> mmorrow: i might be fudging terminology, but the issue is just the we have a partial map and need to be able to observe where it is defined and where it is not
18:05:50 <conal> jmcarthur: and more generally to a monoid-style container.
18:06:16 <conal> jmcarthur: junk is non-denotable semantic values.  i think that's all.  in this case, those non-denotable "event" meanings interfere with definability of accumE & friends.
18:07:15 <conal> jmcarthur: and maybe more than enumerable.  for instance, if an event occurs at every rational number, i think we're still in trouble.
18:07:26 <mmorrow> conal: non-denotable := map to "bottom" (:= initial object in the semantic domain), right?
18:07:32 <jmcarthur> conal: yes, this was a fudge of terminology
18:07:36 <mmorrow> s/map to ../maps to../
18:07:57 * mmorrow is trying to grok denotational semantic terminology
18:07:59 <conal> mmorrow: no.  it means the semantic function is not onto.
18:08:18 <mmorrow> conal: ohh.
18:08:27 <dolio> Girard's coherence spaces semantics for System F have a lot of extra semantic values, as I recall.
18:08:37 <jmcarthur> conal: i like that definition better
18:08:53 <conal> jmcarthur: cool.  sry it took so long to drag it out of me.
18:09:28 <dolio> Or maybe it's System T that has lots of extras...
18:10:21 <mmorrow> ok, knowing the definition of "non-denotable" just made a lot of things clear to me here.
18:10:32 <dolio> Anyhow, System T has natural numbers built in, and the denotational semantics uses sets of tokens like 1, 2, 3....
18:11:06 <dolio> And the natural N denotes {1,2,3 ... N}, possibly with some other stuff.
18:11:33 <conal> dolio: thx for the pointers. i hadn't heard of system T.
18:11:36 <dolio> So there are lots of other sets, like {3, 4, 5, 7} that aren't denoted by any natural in the language.
18:11:38 <mmorrow> i always thought that in "A is non-denotable", A was an item in the "modeled" system/whatever, rather than in the /model/
18:12:07 <jmcarthur> yeah i think i had that backward, too
18:12:22 <conal> oh -- that'd explain the confusion!
18:12:29 <dolio> I guess, strictly speaking, there's also a sort of bottom-like set in the semantics that isn't used by anything in either System T or System F, because those are both strongly normalizing.
18:12:41 <conal> yeah.  it's the model that has junk.
18:13:09 <gwern> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15752#a15755 <-- moderately confused. the second variable for the typeclass is [a], and that's what's beeing passed in but I can't zip on it?
18:13:56 <conal> there's principle in denotational semantics (or was when i learned it) that the model itself (the semantic domain) is the most potent description of the nature of the language.  even more so than the semantic clauses (defs of meanings of ctors).
18:14:16 <conal> if a model/domain is junky, then it's going to tell us less.
18:14:59 <mmorrow> interesting. so a "perfect" model would in some sense be isomorphic to the thing it's modeling?
18:15:23 <gwern> the map would be the territory
18:15:27 <mmorrow> (equivalently, every model trivially perfectly models itself?)
18:17:04 <conal> mmorrow: you mean a sort of degenerate semantics?  ie syntax *as* semantics?
18:17:27 <mmorrow> hmm. i'm not sure. the mental image i have is:
18:17:49 <mmorrow> Modeled --meaningOf--> Model
18:18:11 <conal> mmorrow: what's "Modeled"?
18:18:16 <mmorrow> and if (--meaningOf-->) is an iso, then Model "perfectly" models Modeled?
18:18:24 <conal> mmorrow: i'm suspicious of some confusion hiding behind "Modeled"
18:18:34 <mmorrow> Modeled := "the language" (or whatever (i'm not sure))
18:18:39 <jmcarthur> is it "implementation"?
18:18:47 <gwern> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15752#a15755 no thoughts?
18:18:55 <mmorrow> conal: yeah, what exactly is the domain of the semantic function?
18:19:32 <conal> mmorrow: for "languages", the domain is abstract syntax trees for the language
18:19:50 <mmorrow> ahhh, ok.
18:20:05 <conal> mmorrow: for data types (generalization of "language"), it's values of the type.
18:20:29 <mmorrow> conal: ok, right. so in retrospect yes, i meant "ie syntax *as* semantics?"
18:20:46 <mmorrow> (but i wasn't thinking about it as such)
18:22:26 <conal> mmorrow: yes, such a degenerate semantics would be junk-free
18:22:39 <mmorrow> ooh. also i've been reading various things about abstract interpretation recently, and i think it's very related here. "Abstract Interpretation" is modeled as an adjunction/(commonly referred to as a galois connection in the papers) between syntax and semantics
18:22:45 * gwern wonders why it doesn't matter if it's [a] or a in my instance declaration. that feels like a sign I screwed up somewhere
18:22:49 <conal> though junk-freeness is only one desirable property for a semantics.
18:23:10 <conal> mmorrow: ooh.
18:24:01 <conal> another commonly prescribed property is "full abstraction".  a degenerate/syntactic semantics is at the opposite end of the spectrum from full abstraction.
18:24:07 <mmorrow> conal: this guy apparently is the coiner-of-the-term http://www.di.ens.fr/~cousot/
18:24:18 <conal> it's fully unabstract.  (emptily abstract?)
18:24:20 <mmorrow> conal: and he has an online book http://www.di.ens.fr/~cousot/AI/
18:24:45 <monochrom> "syntax is semantics" is aka "term model"
18:24:50 <conal> mmorrow: thx.
18:24:57 <monochrom> "term" as in syntactic terms.
18:25:11 <conal> monochrom: yeah.  not very illuminating.  "initial" i think is another descriptor.
18:25:38 <mmorrow> conal: i found all of this by googling the author of this one particular paper i found, which is an interesting paper (trying to find it currently)
18:26:06 <monochrom> galois connection is a very simple version of adjunction (since partial order is a very simple version of category). for beginners like me galois connection is easier to learn.
18:38:41 <chrisdone> anyone got a working mysql library?
18:38:51 <chrisdone> HDBC.MySQL kind of spits out nonsense
18:39:24 <chrisdone> "select 1+1" -> [SqlInteger 139730290994840]
18:39:48 <chrisdone> what's the latest coolest database library, I wonder
18:40:13 <monochrom> some kind of 32-64 mistmatch?
18:40:59 <sproingie> shouldn't even link if that were the case
18:40:59 <chrisdone> well, I am on 64-bit
18:41:46 <chrisdone> I'll try hsql
18:44:27 <chrisdone> haha, the hsql mysql version was uploaded by me a year ago. I guess that one must've worked
18:44:54 <monochrom> X|
18:47:59 * gwern ponders. there must be some way to express unionfind as a typeclass
18:48:40 <BootDisk> Tired of NIGGERS?  Sick of their monkeyshines?  Would you rather never have to deal with the fecal-colored beast?  Then you are not alone!  Join us at Chimpout Forum!  http://www.chimpout.com/forum  At Chimpout WE ARE NOT WHITE SUPREMACISTS!  We welcome anybody who isn't a NIGGER and who HATES NIGGERS!   http://www.chimpout.com/forum
18:48:54 --- mode: ChanServ set +o mauke_
18:48:55 --- mode: mauke_ set +b *!*@201.171.121.13
18:48:56 <chrisdone> oh balls yeah. just got hold of an old haskell web site source of mine. s'got some decent library usage. also wrote an HSBC bank communication lib in it. if it's any good I'll put on hackage
18:49:10 <sproingie> remind me why we allow unregistered nicks?
18:49:19 <mmorrow> conal et al: ooh nice find! (cousot home -> MIT webpage -> course webpage) http://web.mit.edu/afs/athena.mit.edu/course/16/16.399/www/
18:49:22 <chrisdone> for the IRC newbies!
18:49:55 --- mode: mauke_ set -o mauke_
18:50:50 <mmorrow> damn, <i>Symbolic abstract domains (abstraction of sequences, trees and graphs, BDDs, word and tree automata, pointer analysis)</i>      "Italicized topics could not be handled by lack of time."
18:51:05 <felzix> When trying to use Graphics.GD, I get this error: "can't load .so/.DLL for: pthread (/usr/lib/libpthread.so: invalid ELF header)"
18:51:23 <mmorrow> syntax for semantics of other syntaxes!
18:51:25 <felzix> how do I resolve this?
18:51:27 <dilinger> sproingie: and for people like me who can't be bothered to register
18:51:50 <chrisdone> felzix: you have to remove something from the .cabal file.. let me check
18:52:01 <gwern> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15756#a15756 <-- it compiles, but darn if I understand what 'makeSet 10 ["foo"]' evaluates to
18:52:10 <mmorrow> felzix: /usr/lib/pthread.so.###.## is a linker script, and ghci can't grok them
18:52:27 <mmorrow> felzix: i did
18:52:56 <felzix> mmorrow: what did you do?
18:52:57 <mmorrow> lrwxrwxrwx 1 root root  22 2009-04-02 01:24 /usr/lib64/libpthread.so -> /lib64/libpthread.so.0
18:52:57 <mmorrow> -rw-r--r-- 1 root root 222 2008-12-08 07:00 /usr/lib64/libpthread.so_
18:53:11 <felzix> oh..
18:53:12 <mmorrow> where libpthread.so_ is the original linker script
18:53:49 <mmorrow> and just look inside the linker script to find out what you should point the new symlink to
18:54:05 <mmorrow> (linker scripts are text)
18:54:17 <mmorrow> (in case that needs mentioning :)
18:54:54 <felzix> so replace the linker script with the .so is refers to?
18:55:24 <alp_> did anyone read my blogpost about library design ?
18:55:32 <mmorrow> cp libpthread.so libpthread.so_ && ln -s libpthread.so.0 libpthread.so
18:55:37 <mmorrow> for me
18:55:46 <hatds> posted on reddit?
18:56:00 <alp_> yeah
18:56:04 <mmorrow> but "cat /usr/lib*/libpthread.so" first to see what you should make the target of the symlink on your setup
18:56:07 <hatds> yeah
18:56:22 <alp_> I thought it'd be the kind of topic I could get much feedback on
18:57:07 <alp_> about my approach, my way of reasonning about library usage, etc
18:57:15 <sproingie> ooh not fun
18:57:17 <alp_> since I'm not *that much* experienced in Haskell
18:57:24 <sproingie> GROUP ( /lib/libpthread.so.0 /usr/lib/libpthread_nonshared.a )
18:57:35 <mmorrow> right
18:57:37 <sproingie> not sure how you'll get at the latter
18:57:58 <mmorrow> if you have the former, you'd never need to
18:57:59 <sproingie> looks like it's just pthread_atfork
18:58:31 <mmorrow> i think that that linker script is just always the same, to handle the case where you only have the static version
18:58:50 <mmorrow> but if you have the dyn version, the static version never'll get touched
18:58:53 <sproingie> nonshared only has five symbols
18:59:04 <mmorrow> oh, hmm
18:59:09 <mmorrow> ahh
18:59:10 <felzix> awesome, it works. thank you!
18:59:15 <mmorrow>    Use the shared library, but some functions are only in
18:59:15 <mmorrow>    the static library, so try that secondarily.  */
18:59:23 <Cale> http://www.steike.com/code/php-must-die/ -- haha
18:59:28 <sproingie> atfork can't handle being shared i guess
18:59:29 <mmorrow> felzix: nice!
18:59:43 <mmorrow> sproingie: hmm, interesting. i wonder why
18:59:56 <chrisdone> felzix: I added one or two updates to gd (pixel querystring and bytestring support), but uploaded as 1000.0 http://hackage.haskell.org/package/gd-1000.0
19:00:03 <alp_> oh by the way I wrote a script for fetching titles of given urls
19:00:06 <alp_> in Haskell
19:00:11 <alp_> it may be interesting for lambdabot
19:00:18 <chrisdone> it used to do that
19:00:18 <sproingie> possibly every process gets it freshly initialized
19:00:30 <sproingie> i dont really know the interaction of the linker and fork
19:00:34 <chrisdone> dunno if it was disabled or what
19:00:40 <sproingie> especially when it comes to pthreads
19:00:40 <chrisdone> @title http://chrisdone.com/
19:00:44 <mmorrow> sproingie: yeah, must be something like that
19:00:48 <chrisdone> dead
19:03:16 <alp_> indeed
19:03:19 <aavogt> alp_: yeah the code for such is already in lambdabot, just not enabled because it's annoying
19:03:25 <aavogt> at least to some pepole
19:03:30 <alp_> oh
19:03:31 <alp_> okay
19:03:55 <felzix> chrisdone: why did you upload as 1000.0?
19:04:45 <chrisdone> felzix: didn't get a response from bringert about it, didn't want to make mine the default
19:04:48 <monochrom> http://www.steike.com/code/php-must-die/ is kettle laughing at pot. Has the author wondered about dangerous wrong answers to ""+3 in perl?
19:05:28 <felzix> chrisdone: ah, ok
19:06:06 <aavogt> the saying involves being black
19:06:19 <Axman6> > 0123
19:06:20 <lambdabot>   123
19:06:23 <Axman6> hmm
19:06:35 <aavogt> haskell doesn't do octal
19:06:39 <Axman6> > 0x0123
19:06:40 <lambdabot>   291
19:06:46 <mauke_> > 0o123
19:06:47 <lambdabot>   83
19:06:57 <Axman6> thought it might be that
19:07:09 * Axman6 did know 0x would be hex, don't worry
19:07:41 <aavogt> that's new to me
19:08:29 <mauke_> monochrom: that generates a warning
19:08:32 <sproingie> wow they implemented ternary and got the associativity wrong
19:08:42 <sproingie> sounds like php to me
19:08:51 <mauke_> sproingie: perl got the precedence of ?: wrong :-)
19:09:00 <Axman6> mauke_: heh, the one printing the array values and types is pretty messed up
19:09:04 <Axman6> uuh, monochrom
19:09:13 <sproingie> i thought perl did ?: the same as C
19:09:17 <mauke_> not quite
19:09:25 <mauke_> in C you can write A ? B, C : D
19:09:30 <mauke_> in Perl it's a syntax error
19:09:33 <sproingie> oh precedence
19:09:44 <sproingie> whoopdee.  the associativity is what lets you set up nice tables
19:09:50 <mauke_> this only affects you if you want to use the comma operator in the middle part of ?:
19:10:06 <sproingie> the comma operator in C is quite different than perl
19:10:13 <mauke_> not really
19:10:31 <sproingie> yarly.  perl uses it to create a list
19:10:35 <mauke_> no
19:10:51 <mauke_> in scalar context, comma works as in C
19:10:59 * copumpkin moos
19:10:59 <mauke_> in list context, comma is (++)
19:11:17 <Axman6> you're all making me cry :(
19:11:28 <Axman6> stop telling me scary stories!
19:11:35 <mauke_> what's so scary about that?
19:11:38 <sproingie> expecting comma to work the same as C is madness
19:11:47 <sproingie> scalar context or no
19:12:10 <sproingie> comes in handy in c-style for loops i guess, if you're that nuts
19:12:42 <mauke_> well, technically perl doesn't need C's comma operator, since you can turn statements into expressions
19:12:54 <sproingie> i love the snarky comment about unit tests
19:12:57 <mauke_> (which python can't do, hence crippled lambda)
19:13:05 <sproingie> it's like all the science of computing over the last 60 years has been for naught
19:13:22 <gwern> > msum [Nothing, Nothing, Nothing]
19:13:24 <lambdabot>   Nothing
19:13:28 <gwern> > msum [Nothing, Nothing, Just 5]
19:13:29 <lambdabot>   Just 5
19:13:52 <sproingie> i have a great unit test runner. it's called a *compiler*
19:14:12 <pikhq> sproingie: That's not a unit test runner.
19:14:16 <pikhq> That's a sanity checker.
19:14:32 <sproingie> i guess that's putting it better
19:14:39 <pikhq> Now quickCheck, on the other hand... ;)
19:15:04 * sproingie is getting *&@(*&^! index errors with his CA code that unit tests would have helped catch
19:15:24 <idnar> quickCheck isn't a unit test runner either
19:15:39 <pikhq> No, it's better.
19:15:55 <idnar> not really, it's just different
19:16:30 <idnar> quickcheck isn't a substitute for unit tests any more than unit tests are a substitute for quickcheck
19:19:08 <sproingie> it's nice not having to write unit tests for basic things though
19:20:37 * alp_ should consider writing quickcheck tests for hnn
19:21:28 <Cale> quickCheck is strictly more general than unit tests.
19:21:41 <Cale> Unit tests are QuickCheck tests with no parameters :)
19:22:09 <idnar> writing unit tests as QuickCheck tests with no parameters sounds painful :P
19:22:24 <idnar> I would expect most Haskell unit tests to involve IO, though
19:22:28 <chrisdone> ahh
19:22:33 <chrisdone> hsql's MySQL works fine
19:22:34 <idnar> can you write QuickCheck tests that use IO?
19:23:40 <chrisdone> idnar: yeah, but they have to run the IO
19:24:18 <chrisdone> which can be more annoying than you'd suppose
19:24:30 <idnar> how do they do that?
19:24:36 <chrisdone> http://hackage.haskell.org/packages/archive/QuickCheck/2.1.0.2/doc/html/Test-QuickCheck-Monadic.html
19:24:54 <idnar> anyhow, it seems like quickcheck's nondeterminism would be undesireable for tests involving IO and such
19:24:56 <chrisdone> it's just a monadic version of the quickcheck functions
19:24:56 <felzix> any idea what I need to do to draw a .png file to the screen using opengl? I can see that Graphics.GD gives me an Image IO, but I don't see how to actually use it in Graphics.Rendering.OpenGL
19:25:33 <idnar> when you're making sure the missiles launch, you don't want to fire them at random countries ;)
19:25:41 <chrisdone> heh, doing something useful in OpenGL? enjoy your weeks of learning
19:26:09 <chrisdone> idnar: well you can tell it to use specific countries, it doesn't all have to be random
19:26:29 <idnar> chrisdone: sure, but you don't want it to pass one run and fail the next
19:26:31 <felzix> chrisdone: D:. Well, I know how to draw pixels using objective-c, at least...
19:26:31 <chrisdone> no real point in testing IO anyway, the logic is always pure
19:27:06 <idnar> for non IO stuff, you can run a thousand tests and have reasonably consistent coverage each time
19:27:20 <idnar> launching missiles might be a bit expensive to do it a thousand times, though
19:28:17 <idnar> but sure, the majority of your code should be outside of IO; that's one of the reasons Haskell is great in the first place
19:28:30 <mmorrow> felzix: you need to first decode the .png into an array/equivalent of (R,G,B) triples, then copy that data into graphics mem with opengl functions
19:29:05 <mmorrow> felzix: also, you can use opengl textures and copy the pixel data into one of those
19:29:49 <mmorrow> felzix: you'll need code to decode the .png, there's a pkg on haskell for that iirc
19:30:03 <felzix> mmorrow: ok, thanks!
19:30:17 <mmorrow> (.png's have pixel data compressed with one of the variants of zlib compression)
19:30:20 <sproingie> Codec-Image-DevIL
19:30:53 <sproingie> actually just pngload might do the trick
19:31:53 <alp_> damn
19:32:13 <alp_> I definitely must use criterion and quickcheck, at least, for hnn
19:32:50 <mmorrow> felzix: here's a (somewhat messy/coded-in-an-ad-hoc-manner) module that renders images with opengl textures (the original image data comes from .bmp's here, but that's irrelevant at this point)  http://moonpatio.com/repos/vacuum-gl/haddocks/System-Vacuum-OpenGL-HsGLIV.html  (has a source link)
19:33:05 <mmorrow> felzix: (the root of that package http://moonpatio.com/repos/vacuum-gl/)
19:33:57 <mmorrow> the very bottom of that module is the relevant part
19:35:23 <dolio> mmorrow: Do you remember a while back talking about regular types, and specifically modeling them with an inductive family with explicit substitutions in a dependently typed language?
19:35:32 <dolio> And an associated paper.
19:36:14 <mmorrow> hmm, i'm not sure. is that a question question or a lead-in?
19:36:26 <dolio> I'm trying to remember which paper it was.
19:36:31 <mmorrow> ah, ok. hmm
19:36:41 <saiko> hi all!
19:36:43 <chrisdone> how do you catch exceptions for code that isn't in the IO monad?
19:36:55 <dolio> Oh, I may have figured it out.
19:37:09 <mmorrow> dolio: link me if you find it
19:37:28 <chrisdone> I'm stuck with a monad transfor that transforms IO
19:37:30 <dolio> It's The Derivative of a Regular Type is its Type of One-Hole Contexts.
19:37:38 <mmorrow> ahh, ok
19:37:49 <mmorrow> i haven't read that one, but i know of it
19:38:02 <dolio> I was thinking that wasn't it, because it wasn't colorful enough.
19:38:03 <mmorrow> err, maybe i've looked it over
19:38:07 <mmorrow> heh
19:38:08 <dolio> But I think it's the right one.
19:38:30 <sproingie> frag has some texture loading too
19:38:33 <sproingie> i think it's just tga tho
19:38:51 <sproingie> but it loads mipmaps and everything
19:40:02 <saiko> I have a newbie question.. can anyone help me figure out why "bytes" in this code is strict? shouldn't this result in only the first element being evaluated? I run out of stack in this example: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=15757#a15757
19:40:04 <mmorrow> felzix: oh right, the source data is RGBA there rather than RGB..
19:40:42 <mmorrow> but you can load either with opengl by specifying the appropriate flag to `texImage2D' function
19:40:54 <dolio> I think Get is pretty eager.
19:41:06 <dolio> If I had to guess.
19:41:46 <mmorrow> yeah, using sequence in Get will need to decode everything before anything is available
19:41:53 <dolio> > runState (sequence . repeat $ return 0)
19:41:57 <lambdabot>   mueval-core: Time limit exceeded
19:42:21 <dolio> sequence . repeat isn't the sort of thing that works in a state monad.
19:42:29 <c_wraith> @hoogle unsafePerformIO
19:42:29 <lambdabot> Foreign unsafePerformIO :: IO a -> a
19:42:29 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
19:43:05 <c_wraith> This is going to be the most pointless abuse of unsafePerformIO ever.  >_>
19:43:39 <pikhq> c_wraith: Oh?
19:43:45 <saiko> dolio: is that because getting the [a] from "State [a]" results in [a] being evaluated?
19:44:13 <c_wraith> pikhq: let me get it into code
19:44:14 <saiko> how do I make this lazy?
19:44:30 <pikhq> c_wraith: K.
19:45:03 <dolio> saiko: sequence goes like "sequence (m:ms) = do x <- m ; xs <- sequence ms ; return (x:xs)". So it makes a sequenced call for the tail of the list before returning anything.
19:45:13 <mm_freak> i have a long running message handler thread, which runs a 'forever' loop and uses ContT/callCC to escape when it's told to exit
19:45:15 <dolio> And it's not the sort of thing that magically works out in lazy state.
19:45:18 <mm_freak> is there a cleaner way to do this?
19:45:40 <dolio> You could use Either instead.
19:45:46 <mmorrow> saiko: so basically you can't make that code work with an infinite list
19:46:04 <mmorrow> saiko: if the list /is/ infinite you'll need to decode in chunks or something
19:46:51 <mmorrow> err, sorry s/the list/the list you want to produce/
19:46:58 <mmorrow> or something
19:47:10 <saiko> dolio: thanks.. that makes sense.. sequence is no good on infinite lists then..
19:47:30 <dolio> Whether it works will depend on the monad.
19:47:49 <dolio> But for state-like monads, it won't work.
19:48:04 <glguy> > sequence (repeat Nothing)
19:48:05 <dolio> And that includes Get.
19:48:05 <lambdabot>   Nothing
19:48:19 <saiko> mmorrow: yeah.. i think I will have to use runGetState, get a piece, and repeat.. something like: infList bs = firstpiece:infList bs'
19:48:37 <mmorrow> saiko: right
19:48:49 <dolio> > runStateT (sequence (repeat (lift Nothing))) 5
19:48:50 <lambdabot>   Nothing
19:49:29 <dolio> That's sort of cheating. :)
19:49:41 <mmorrow> cheater!
19:51:00 <saiko> thanks guys.. good to know im not doing something too roundabout.. appreciate it
19:51:19 <copumpkin> CheaterT
19:51:57 <dolio> > sequence (repeat (:)) 5
19:51:58 <lambdabot>   [[]->
19:51:58 <lambdabot>    [5]
19:51:58 <lambdabot>  [-2]->
19:51:58 <lambdabot>    [5,-2]
19:51:58 <lambdabot>  [-2,-1]->
19:52:00 <lambdabot> [3 @more lines]
19:52:08 <dolio> > sequence (repeat (:)) 5 []
19:52:10 <lambdabot>   Couldn't match expected type `[a] -> t'
19:52:10 <lambdabot>         against inferred type `[[a1...
19:52:45 <Axman6> :t sequence (repeat (:))
19:52:46 <dolio> > sequence (repeat ask) 5
19:52:46 <lambdabot> forall a. a -> [[a] -> [a]]
19:52:47 <lambdabot>   [5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,...
19:52:47 <mmorrow> , zipWith ($) (repeat []) (sequence (repeat (:)) 5)
19:52:49 <lunabot>  luna: Couldn't match expected type `b -> b1' against inferred type `[a]'
19:52:50 <dolio> There we go.
19:53:18 <mmorrow> ohh, slick with `ask' ;)
19:53:33 <mmorrow> , zipWith ($) (sequence (repeat (:)) 5) (repeat [])
19:53:34 <lunabot>  [[5],[5],[5],[5],[5],[5],[5],[5],[5],[5],[5],[5],[5],[5],[5],[5],[5],[5],...
19:57:08 <c_wraith> gah.  I thought Control.Exception catch would catch anything.  >_>
19:57:24 <alp_> do you think it's misnamed ?
19:59:04 <c_wraith> No.  The thing I'm trying to catch isn't supposed to be catchable
20:00:42 <alp_> (was doing a bit of humor)
20:01:12 <roconnor> jlouis: google `three way merge pushout' yields lots of interesting hits
20:01:33 <jmcarthur> especially without safe search enabled?
20:03:21 <copumpkin> jmcarthur: did you figure out your Map model?
20:03:27 <jmcarthur> copumpkin: no
20:03:31 <jmcarthur> did you? :)
20:03:41 <copumpkin> jmcarthur: sorry for being half-absent before, was in a symposium and occasionally paying attention :)
20:03:44 <copumpkin> nope!
20:03:53 <copumpkin> went to a party after that instead
20:04:03 <jmcarthur> lame. socializing and crap
20:04:40 <copumpkin> yeah, I hate it
20:05:05 <mmorrow> nice, lunabot's been up since Nov 17
20:05:27 <jmcarthur> copumpkin: well, if you read up a bit you will see a little conversation about it, but nothing conclusive
20:05:44 <jmcarthur> it transformed into a discussion about denotational semantics
20:05:47 <mmorrow> forkIO'ing a thread for every single irc msg (regardless of whether it contains a lunabot-directed command or not)
20:06:00 <copumpkin> ah :)
20:06:08 * mmorrow wonders how many forkIO threads that is since Nov 17
20:06:16 <c_wraith> ok, I think it's actually evaluate that's totally not doing what I think it should.  Or maybe unsafePerformIO.  Always a great combination, I'm sure.
20:08:48 <c_wraith> Ok, it looks like it's evaluate I'm misunderstanding
20:08:54 <mm_freak> Could not find module `Control.Monad.Cont': it was found in multiple packages: monads-tf-0.0.0.1 mtl-1.1.0.2
20:09:05 <mm_freak> how can i shadow one of the two without having to use cabal?
20:09:57 <c_wraith> mm_freak: pass ghc(i) the -hide-package flag, hiding one of them
20:10:37 <mm_freak> c_wraith: works, thanks
20:13:56 <raceRider> what's the import module for the function replace
20:14:09 <c_wraith> @hoogle replace
20:14:09 <copumpkin> never heard of such a function
20:14:09 <lambdabot> Network.CGI.Protocol replace :: Eq a => a -> a -> [a] -> [a]
20:14:09 <lambdabot> System.FilePath.Posix replaceBaseName :: FilePath -> String -> FilePath
20:14:09 <lambdabot> System.FilePath.Windows replaceBaseName :: FilePath -> String -> FilePath
20:14:30 <c_wraith> Do you really mean Network.CGI?  Or is this something else entirely?
20:15:33 <raceRider> c_wraith: I meant simple text replace, Data.String.Utils seems to have replace function according to Hayoo but can't import
20:16:05 <c_wraith> raceRider: probably in a package you don't have, then.  check hackage
20:16:39 <raceRider> thx
20:16:48 <c_wraith> it appears to be in a package named MissingH
20:16:59 <raceRider> means what?
20:17:16 <c_wraith> do you have cabal installed?
20:17:20 <raceRider> yes
20:17:39 <c_wraith> then run "cabal install MissingH"
20:17:56 <c_wraith> here's the description of what all is in the package:  http://hackage.haskell.org/package/MissingH
20:19:12 <raceRider> c_wraith: I assumed these would be installed through haskell platform. Thanks for the tip
20:19:41 <c_wraith> raceRider: Platform only installs some of the more common packages.  hackage is huge.  Be aware that there's a bunch there that isn't in platform
20:20:01 <raceRider> yes, I'm learning that. thx.
20:20:34 <Axman6> there's over 1500 packages on hackage i think
20:20:54 <Axman6> maybe that's uploads
20:21:00 <Axman6> ionno, there's a lot :)
20:26:26 <monochrom> Haskell Platform includes System.Regex.* and can replace substrings.
20:27:48 <Cale> > cake !! 40
20:27:50 <lambdabot>   "And it contains proven preservatives, deep penetration agents, and gas and...
20:28:35 <monochrom> Oops, Text.Regex.*
20:30:59 <mm_freak> > length cake
20:31:00 <lambdabot>   42
20:31:04 <mm_freak> hehe
20:31:36 <mm_freak> > map head cake
20:31:37 <lambdabot>   "OOTFOTOTDFFFFFPFCOAUFANTOATTOOTOOTASCIICAT"
20:31:45 <mm_freak> ASCIICAT?
20:31:47 <kmc> > cake
20:31:48 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
20:31:56 <kmc> > transpose cake
20:31:57 <lambdabot>   ["OOTFOTOTDFFFFFPFCOAUFANTOATTOOTOOTASCIICAT","nnhonhnwoiiiiiuianlniniwnnww...
20:32:09 <mm_freak> > drop 34 . map head $ cake
20:32:10 <lambdabot>   "ASCIICAT"
20:32:12 <mm_freak> lol
20:34:01 <kmc> hahaha
20:34:22 <kmc> > fix (interleave ['A'..])
20:34:23 <lambdabot>   "AABACBDAECFBGDHAIEJCKFLBMGNDOHPAQIRESJTCUKVFWLXBYMZG[N\\D]O^H_P`AaQbIcRdEe...
20:34:42 <elly> that's disturbing.
20:34:53 <mm_freak> > (do l <- length; splitAt (l - 8)) cake
20:34:55 <lambdabot>   (["One 18.25 ounce package chocolate cake mix.","One can prepared coconut p...
20:35:13 <mm_freak> uhm
20:35:16 <mm_freak> ok
20:35:27 <mm_freak> > (do l <- length; splitAt (l - 8)) $ map head cake
20:35:28 <lambdabot>   ("OOTFOTOTDFFFFFPFCOAUFANTOATTOOTOOT","ASCIICAT")
20:39:34 <mm_freak> hmm
20:39:38 <mm_freak> the pointless ascii cat
20:39:44 <mm_freak> > (length >>= fmap snd . splitAt . subtract 8) . map head $ cake
20:39:46 <lambdabot>   "ASCIICAT"
20:41:23 <alp_> > cake
20:41:24 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
20:41:33 <alp_> haha
20:42:22 <aavogt> > last cake
20:42:24 <lambdabot>   "That will deodorize and preserve putrid tissue."
20:42:45 <djahandarie> ...
20:43:33 <aavogt> > last cake > death
20:43:35 <lambdabot>   True
20:43:45 <mm_freak> > death
20:43:46 <lambdabot>   "Death"
20:43:50 <mm_freak> lol
20:43:57 <mm_freak> yeah, cake is much greater
20:44:13 <aavogt> @type or
20:44:14 <lambdabot> [Bool] -> Bool
20:44:43 <copumpkin> mm_freak: is the secret cake recipe from portal?
20:44:56 <mm_freak> dunno
20:45:29 <aavogt> @vixend what is it with you and recipes?
20:45:31 <lambdabot> i dunno...
20:45:43 <path[l]> > let a=true;b=id in b a
20:45:45 <lambdabot>   Not in scope: `true'
20:45:51 <luite> how can you get the haskell type of a C enum with hsc2hs?
20:45:52 <path[l]> > let a=True;b=id in b a
20:45:54 <lambdabot>   True
20:47:48 <path[l]> > let lie=True;a=id;is=id;cake=id;the=id in the cake is a lie
20:47:49 <lambdabot>   True
20:48:51 <copumpkin> omg harrop on the ghc list
20:49:06 <Axman6> :o
20:49:22 <copumpkin> not even being an asshole really :)
20:49:27 <copumpkin> quite amazing
20:49:43 <Axman6> yeah :O
20:49:51 <Axman6> i read it as him being smug though
20:50:09 * kmc reduces everyone to whnf
20:50:13 <copumpkin> just a tad, but it can't be avoided
20:50:29 <copumpkin> it'd be interesting to see dph in that list too
20:50:35 <copumpkin> but someone would have to write a dph raytracer
20:51:17 <jmcarthur> huh i must have already deleted whatever email it is that's in question
20:53:24 <Axman6> mmmmmm, christmas cake, with super thick double cream ^____^
20:55:31 <copumpkin> :)
20:57:46 <mm_freak> > map (\x -> "-=*#" !! (truncate $ 3 * (1 - x^2))) $ [-1.0, -0.9375 .. 1.0]
20:57:47 <lambdabot>   "---====*********#*********====---"
20:59:55 <uorygl> > "ingo"
20:59:56 <lambdabot>   "ingo"
21:00:15 <mm_freak> > 'c' : reverse "igno"
21:00:16 <lambdabot>   "congi"
21:00:27 <kmc> > repeat "super thick double cream "
21:00:28 <lambdabot>   ["super thick double cream ","super thick double cream ","super thick doubl...
21:00:34 <kmc> > cycle "super thick double cream "
21:00:35 <lambdabot>   "super thick double cream super thick double cream super thick double cream...
21:01:20 <kmc> > map (\n -> '8' : (replicate n '=') ++ "D") [0..]
21:01:21 <lambdabot>   ["8D","8=D","8==D","8===D","8====D","8=====D","8======D","8=======D","8====...
21:02:06 <dolio> Classy.
21:02:46 <mm_freak> > [ "8" ++ x ++ "D" | x <- map (`replicate` '=') [0..] ]
21:02:47 <lambdabot>   ["8D","8=D","8==D","8===D","8====D","8=====D","8======D","8=======D","8====...
21:02:53 <Axman6> copumpkin: well, assuming i have the right code, i've just added {-# OPTIONS -fvia-C -fexcess-precision -XBangPatterns -funbox-strict-fields #-} to the top of the file, and it takes the runtime from 15s to 8s
21:03:08 <kmc> ooh look at mr. list comprehension over here
21:03:16 <mm_freak> hmm
21:03:17 <c_wraith> woo!  I've just proven my total lack of knowledge of the type system!
21:03:26 <Axman6> hooray!
21:03:42 <c_wraith> Only needed a little unsafePerformIO and exception throwing!
21:03:49 <Axman6> bah, ok maybe that didn't do anything
21:05:03 <mm_freak> > do x <- inits (repeat '='); return ("8" ++ x ++ "D")
21:05:05 <lambdabot>   ["8D","8=D","8==D","8===D","8====D","8=====D","8======D","8=======D","8====...
21:05:07 <c_wraith> hmm.  what's the extension to allow no-constructor types?
21:05:34 <kmc> EmptyDataDecls
21:05:37 <c_wraith> thanks
21:06:04 <aavogt> , case do x <- inits (repeat '='); return ("8" ++ x ++ "D") of lol @ (head -> x) -> x
21:06:05 <lunabot>  "8D"
21:06:37 <c_wraith> d'oh.  You can't use that exception when you're constructing data with that type.  >_>
21:06:49 <c_wraith> As you can tell, I'm all confused about what my own code does
21:07:30 <c_wraith> Ok.  Time to be educated.  I have this http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15758#a15758
21:07:46 <c_wraith> It works, but it's a horrible hack.  It must be possible to do the same thing within the type system
21:08:25 <monochrom> what is "the same thing"?
21:08:40 <c_wraith> Fully lazy monadic support of a Maybe-like type
21:09:36 <Cale> c_wraith: Catching exceptions thrown with throw outside of IO is impossible by design.
21:09:50 <c_wraith> Cale: Right.  I mean a system that doesn't use exceptions.
21:10:53 <c_wraith> "runM $ do { a <- return 5 ; b <- return 6 ; c <- undefined ; return (a + b) }" results, with that loaded, in Just 11
21:11:32 <monochrom> > do { a <- return 5 ; b <- return 6 ; c <- undefined ; return (a + b) } :: Maybe Integer
21:11:34 <lambdabot>   * Exception: Prelude.undefined
21:11:55 <c_wraith> See?  in the Maybe monad, >>= is strict in its first argument
21:12:13 <Veinor> but why?
21:12:13 <c_wraith> It pattern matches on it, so it has to be.
21:12:27 <Cale> Right, it's because undefined might specialise to Nothing there, which would result in something else.
21:12:46 <Veinor> so it has to WHNF it?
21:12:55 <Cale> Veinor: right
21:13:09 <c_wraith> I mean something with different semantics than Maybe has, obviously.  Sort of similar, but fully lazy.  It doesn't care if you bind Nothing, so long as you don't try to use it.
21:13:10 <kmc> > cycle "whnf "
21:13:11 <lambdabot>   "whnf whnf whnf whnf whnf whnf whnf whnf whnf whnf whnf whnf whnf whnf whnf...
21:13:12 <Veinor> Remind me, what's the difference between RWHNF and WHNF.
21:13:21 <Veinor> I know NF is fully evaluated, basically.
21:14:03 <Cale> Veinor: rwhnf is the Control.Parallel.Strategies strategy which reduces things to WHNF
21:14:13 <Veinor> ah.
21:14:22 <Veinor> I was thinking 'reduced weak head normal form' as another form something could be in.
21:14:27 <Cale> HNF
21:14:34 <c_wraith> rnf is the strategy that reduces to normal form
21:14:45 <Cale> reducing to HNF will evaluate underneath an under-applied lambda
21:15:03 <Cale> (but we can't do that in GHC Haskell)
21:15:32 <Cale> For example, (\x -> 3 + 7) is in whnf, but not in hnf
21:15:53 <Cale> (\x -> 10) is in both
21:16:21 <Axman6> so, if calculation needs to be performed to get the result, then it's in whnf?
21:16:23 <c_wraith> Ah.  I was always told the difference between the two was subtle.  Now I see how.
21:16:27 <monochrom> c_wraith: I am not convinced that it is a good idea to have do { _|_ ; return 'x' } = something other than _|_.  Here is the key question: what would you like happen to do { Nothing; return 'x' } ?
21:16:42 <patch-tag> Can somebody explain this?
21:16:44 <patch-tag> *S3Utils> getDirectoryContents inD
21:16:44 <patch-tag> ["..","#sanity.txt#",".","sanity.txt","etc.txt","patchTagDir.txt","jail.txt","notjail.txt","alldata.txt","allobjs.txt","namesNSizes.txt"]
21:16:44 <patch-tag> *S3Utils> filterM doesFileExist =<< getDirectoryContents inD
21:16:47 <patch-tag> ["sanity.txt"]
21:16:50 <patch-tag> *S3Utils>
21:16:52 <c_wraith> monochrom: I'd like the result to be Just x
21:17:03 <Axman6> :o
21:17:06 <Cale> WHNF means that the top level of the expression is a data constructor (possibly applied to some arguments) or a lambda
21:17:08 <c_wraith> monochrom: which, yes, is a divergence from the semantics of Maybe
21:17:15 <monochrom> OK! ~(Just x) >>= f = f x
21:17:42 <c_wraith> I thought about that.  That's still strict, though.
21:17:51 <Cale> HNF means that the top level of the expression is a data constructor possibly applied to some arguments, or a lambda whose body is in HNF.
21:17:52 <c_wraith> I wanted fully non-strict
21:18:00 <Cale> er, hmm
21:18:11 <Cale> Not sure if I got that quite right
21:18:13 <c_wraith> well, I guess that's non-strict if f is non-strict
21:18:33 <Axman6> > undefined >> (Just 1)
21:18:34 <lambdabot>   * Exception: Prelude.undefined
21:19:19 <dolio> It's any irreducible application.
21:19:23 <Cale> c_wraith: What should  do x <- Nothing; return (1:x)  be?
21:19:35 <c_wraith> Cale:  I'd want Nothing.
21:19:45 <Axman6> then you'll get Nothing!
21:19:48 <c_wraith> heh, it wouldn't be in my code, would it?
21:19:49 <Cale> c_wraith: So return has to be *very* strict?
21:19:54 <Axman6> </dramatic voice>
21:20:06 <dolio> So \x y -> x ((\z -> z) y) is hnf.
21:20:08 <monochrom> Your two wants are inconsistent.
21:20:13 <c_wraith> So yes, return would have to be completely strict.
21:20:30 <patch-tag> k... still stumped. gonna ask haskell cafe.
21:21:28 <c_wraith> And, I see the inconsistency you mean, monochrom
21:21:42 <Cale> Or how about  do x <- Nothing; return (\y -> x)
21:21:57 <Cale> You have to evaluate underneath the lambda :)
21:22:02 <monochrom> Under my scheme, (do x <- Nothing; return (1:x)) = Just (1:_|_). I think it is a good compromise.
21:22:19 <c_wraith> That probably is the best compromise.
21:24:55 <monochrom> It is not clear to me how to implement the 2nd want unless you use rnf, which implies you can only work with NFData instances.
21:25:17 <c_wraith> Even then, it's not really consistent, since you can't return an infinte list
21:25:29 <c_wraith> Which is what you and cale managed to make me see
21:26:20 <c_wraith> also, your implementation makes  (do x <- undefined ; return 5 ) non-_|_
21:26:29 <monochrom> You see, where conal engages in denotational design, I engage in axiomatic design! I ask you what laws you want.
21:26:46 <Lemonator> So, for GHC's default pseudoRNG,
21:27:08 <Lemonator> what would be the number of numbers it can crank out before it loops?
21:27:54 <c_wraith> Actually, I'd say that implementation models computations that aren't allowed to fail.
21:29:03 <c_wraith> as Cale pointed out when talking about GHC's inability to reduce under a lambda, what I want actually can't be done.  At all.
21:29:36 <c_wraith> Or it can only work with things that are instances of NFData, as you say.
21:29:38 <c_wraith> oh well.
21:29:45 <monochrom> ~(Just x)>>=f = f x  collapses to the identify monad.
21:29:54 <monochrom> s/identify/identity/
21:29:57 <c_wraith> It was my first experiment into the pitfalls of unsafePerformIO.  At least I learned something
21:30:04 * c_wraith reads a monad of identify
21:30:19 <monochrom> Yes I have a typo.
21:30:42 <c_wraith> I wouldn't have noticed it if you hadn't pointed it out.  But since you did, I tried to unsafeCoerce it into a nethack joke.
21:31:04 <monochrom> There are more exploits in signal handlers, more fun than unsafePerformIO. :)
21:31:34 <c_wraith> Eh.  I don't like signals, despite using mainly unix-like systems.  I'll pretend they don't exist!!!
21:34:30 <conal> monochrom: do you intend that the axioms be a complete specification, i.e. that *any* implementation satisfying the axioms is satisfactory?
21:34:57 <kmc> :t unsafeCoerce
21:34:58 <lambdabot> Not in scope: `unsafeCoerce'
21:35:23 <c_wraith> kmc: it's (a -> b).  what other type would you expect for it?
21:35:32 <conal> monochrom: a non-example would be specifying IO by saying it satisfies the monad laws.  or specifying [a] by saying it's a monoid.
21:35:32 <monochrom> Yes at a late stage. No at an early stage. Depends on how the negotiation with the customer goes.
21:35:57 <c_wraith> :t Unsafe.Coerce.unsafeCoerce
21:35:58 <lambdabot> forall a b. a -> b
21:36:28 <monochrom> But if I am my own customer then it's easy. I can put a stop and sign my own contract very early.
21:37:28 <kmc> i was wondering if it was in scope for lambdabot
21:44:12 <dolio> monochrom: Would categorical semantics (say, initial algebras for data types) fall under axiomatic semantics?
21:45:16 <monochrom> Yes.
21:45:48 <conal> monochrom: i like your idea of relating various semantics styles to design methodologies.
21:46:29 <monochrom> Ha, so don't scorn the UML use-case people, they're just doing operational design!
21:47:08 <dolio> All right. I guess that gives me a better idea of axiomatic semantics, then.
21:48:01 <monochrom> What you should scorn is that the UML use-case language is very limiting and cannot express a lot of use-cases of interest (and cannot express any of the must-not-happen safety properties).
21:48:54 --- mode: ChanServ set +o mauke_
21:48:54 --- mode: mauke_ set -b *!*@201.171.121.13
21:49:54 --- mode: mauke_ set -o mauke_
21:51:05 <conal> monochrom: (continuing from earlier) ah, so you accumulate axioms as you go, which progressively refines the specification.  i like the incrementality.  i don't see how to get refinability in denotational design.
21:52:01 <conal> ie monotonic refinement
21:52:40 <conal> the closest i'm seeing right now is exploring simpler & more complex models, in pursuit of the simplest adequate model.
21:58:36 <monochrom> In denotational design, or in any denotational work, you sometimes have to completely scratch and rewrite your ‚ü¶‚üß function just because the customer says a new idea. This problem is not exclusive to denotational design. Axiomatic design merely postpones the problem, perhaps by not building any prototype early; but it is there: if you do build a prototype, it can be completely invalidated at a whim just because the custome
21:58:36 <monochrom> r says a new axiom.
21:59:16 <kmc> nice marmot
22:00:07 <dolio> Fair? Who's the nihilists around here.
22:03:16 <monochrom> Cale is the formalist nihilist around here.
22:03:26 <monochrom> I am just formalist.
22:04:59 <kmc> say what you will about the tenets of operational semantics
22:05:02 <kmc> at least it's an ethos
22:05:59 <andrewe> @src liftM
22:05:59 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
22:08:52 <Cale> Well, I wouldn't normally call myself a nihilist, but I don't believe in an objective reality anyway.
22:09:41 <Jafet> Is that an objective belief?
22:10:05 <Cale> It's really just what I seem to believe
22:10:10 <Cale> hehe
22:10:17 <kmc> monochrom, i think you stand poised to be a leader in the field of agile denotational design
22:10:46 <Jafet> Extreme graph pair reduction (TM)
22:10:56 <kmc> ADD "is a second-generation, outside-in, pull- based, multiple-stakeholder, multiple-scale, high-automation, agile methodology. It describes a cycle of interactions with well- defined outputs, resulting in the delivery of working, tested software that matters."
22:11:42 <Jafet> Impressive.
22:11:49 <Jafet> I couldn't write that in forty seconds.
22:11:55 <kmc> don't thank me
22:12:05 <kmc> thank (wikipedia)[https://secure.wikimedia.org/wikipedia/en/wiki/Behavior_driven_development]
22:12:17 <Cale> Do descriptions of that kind ever impress people in the way that they appear to be intended to impress people?
22:12:44 <kmc> Cale, i've never worked for an organization clueless enough to contain people impressed by such.  but i sense it in my future :/
22:12:56 <Jafet> The only reason people sell lemons is because there are people who buy lemons.
22:13:17 <dolio> Connectitude. Transformitation.
22:13:23 <kmc> "software that matters"?? Why, that's much better than our "software that doesn't give a flying fuck"!
22:13:53 <Jafet> Connectituded via enterprise-oriented transmogrification
22:14:33 <kmc> denotational semantics: "but... what does it *mean*, man?!?"
22:14:34 <Jafet> Er, why are you browsing wikipedia through https?
22:14:35 * BMeph prefers writing code that doesn't give a rip ;p
22:14:40 <kmc> Jafet, blame xmonad
22:15:09 <Berengal> Cale: I haven't actually seen it happen, but I do believe some people I know would be swayed by that
22:16:20 <kmc> Jafet, http://hackage.haskell.org/packages/archive/xmonad-contrib/0.8.1/doc/html/src/XMonad-Actions-Search.html#wikipedia
22:16:34 <Cale> It seems to be designed to cause people to buy into the thing just so they won't have to think too hard about what was just said about it. :)
22:16:55 <Jafet> kmc, heh
22:35:09 <JoshTriplett> Any good graph databases with Haskell interfaces?
22:39:09 <Jafet> I assume other people here know what a graph database is, so I won't ask.
22:58:47 <falconair> I have a question about monads/comonads and their relation to .NET's linq/Rx...is this the wrong place to ask it?
22:59:00 --- mode: ChanServ set +o monochrom
22:59:03 --- mode: monochrom set -b *!n=ush@*
22:59:12 --- mode: monochrom set -b *!i=55c89673@*
22:59:23 <Niccus> this is probably a good place to ask it but whether or not someone can answer it at the moment is a different story
22:59:51 --- mode: monochrom set -o monochrom
23:00:26 <monochrom> .NET's linq is a monad
23:00:48 <falconair> so...is LINQ to monad as Rx is to comonads?
23:01:10 <falconair> (Rx is the new reactive framework, Eric Meijer calls it a dual to Iterators)
23:02:28 <JoshTriplett> Jafet: A perfectly reasonable question to ask, actually.  http://en.wikipedia.org/wiki/Graph_database
23:03:02 <monochrom> I don't know Rx.
23:03:35 <Cale> JoshTriplett: Ah, I thought you were asking about databases of graphs having special properties.
23:03:56 <Cale> (rather than a database constructed as a graph)
23:04:00 <JoshTriplett> Cale: Ah, no.  I mean a Haskell interface to a database for storing graphs of data.
23:04:01 <JoshTriplett> Yeah, that.
23:04:22 <falconair> monochrom: how abou this: if monads can be thought of as lists or iterators (I know they can do more), can comonads be thought of as streams of data?
23:04:42 <pigdude> #erlang
23:04:43 <lunabot>  luna: Not in scope: `erlang'
23:04:51 <dolio> Streams are comonads.
23:04:52 <c_wraith> A stream is the prototypical comonad
23:04:52 <Cale> falconair: streams are an example of a comonad
23:05:16 <Cale> (just as lists are an example of a monad)
23:05:30 <falconair> so what is the difference between stream processing with comonads and the same with arrows?
23:05:54 <Cale> Well... the interface.
23:06:15 <falconair> Cale: i mean in terms of power, what one can do and the other can't
23:07:57 <falconair> i am trying to understand why, given all the work on FRP in the haskell world, why there is no Rx equivalent in Haskell...if it is just due to lack of Rx marketing to appropriate people (such as present company :), or if I am misunderstanding something more fundamental
23:08:35 <Cale> It's not clear that there's a difference in terms of power. Well, we are talking about two different datatypes of course, since streams are not an Arrow instance, but stream transformers are.
23:09:14 <Cale> You could have the same stream/stream transformer library implement both instances.
23:10:04 <c_wraith> falconair: most of the FRP work has been deemed not good enough for general purpose use, as I understand it.
23:10:08 <Cale> Comonad and Arrow are just common APIs for libraries to implement that characterise ways in which you can stick together computations from that library.
23:10:09 <idnar> "all the work" on FRP seems like a bit of an exaggeration
23:10:30 <idnar> I don't mean to put down the efforts of those working on FRP, but it's a few dedicated people plugging away at this or that, not a horde of developers churning out frameworks
23:10:42 <idnar> (at least, as far as I can tell)
23:10:54 <c_wraith> speaking of...
23:11:00 <kmc> :D
23:11:07 <c_wraith> conal, do you know anything about Rx in .net?
23:11:22 <idnar> hmm, I see falconair sneakily waited until conal quit to ask his question
23:11:23 <idnar> *efg*
23:11:26 <conal> c_wraith: i've taken a superficial look
23:11:29 <falconair> even though I don't have a very good handle on this stuff, basic papers on catamorphisms, fold/unfold, 'monad comprehensions' have been very inspirational...i've always wondered why this couldn't be extended to streaming data
23:11:50 <c_wraith> conal: falconair was asking why there didn't seem to be a haskell equivalent
23:11:56 <falconair> idnar:  haha, i was disappointed to see conal quit just as I came in :)
23:12:01 <falconair> glad he is back
23:12:03 <conal> :)
23:12:34 <conal> c_wraith: didn't look like the kind of thing i like.  it's awfully implementation-oriented, rather than semantics-oriented.
23:12:35 <Cale> falconair: Are you familiar with the basic definitions of what a monad and comonad are?
23:13:06 <conal> all elbows & gears
23:13:40 <falconair> Cale: eh...not really, comonad less so than monad.  I think I have a superficial appreciation for it
23:14:04 <Cale> falconair: But you're familiar with the basics of things like type constructors?
23:14:27 <Cale> Like, if a is any type, then we might have a type Stream a of streams of values of type a
23:14:30 <conal> in other words, exposing imperative machinery, which i'd prefer be kept entirely on the *inside* of an API with simple & precise (denotational) semantics.
23:15:19 <c_wraith> conal, well, that certainly explains why your look was only superficial. :)
23:15:28 <falconair> Cale: let's save me the embarrassment and say that I am a newbie, I haven't written any Haskell code, but I have read plenty about it :)
23:15:35 <Cale> falconair: All right.
23:15:45 <falconair> I believe I do know type constructors
23:15:55 <conal> c_wraith: yeah.  and normally i really like erik's work.
23:16:04 <Cale> yeah, you've probably seen plenty of parametric polymorphism at work in C#
23:16:20 <falconair> conal: you are exaclty right, I wish they would put out a simple "lambda-the-ultimate stream processor" or something
23:16:54 <falconair> Cale: right (although, to make things worse, I am a Java programmer, not C#)
23:17:20 <Cale> Or sure, Java has some of that too, they call it generics (which is different from what we call generics :)
23:17:39 <dolio> It was even Wadler's doing.
23:17:59 <Cale> falconair: So one thing I should probably start with is what a functor is (at least in the programming context), since monads and comonads are both special types of functor.
23:18:34 <tensorpudding> functors are like functions, but more meta
23:18:35 <falconair> basically here is my motivation: i want to deal with multiple sterams of data feeds, i'd like to do it as simply as one executes sql...i'd like to understand how to do it (at a semantic level) rather than buying "CEP" products
23:19:05 <falconair> Cale: functors, I think of them basically as maps
23:19:08 <Cale> A functor f is a type constructor with an operation  fmap :: (a -> b) -> f a -> f b  -- in case you're not familiar with the syntax of types in Haskell, that means that fmap takes a function of type a -> b (that is, which takes a value of type a and produces a value of type b)
23:19:27 <Cale> and turns it into a function f a -> f b
23:19:51 <Cale> (usually, for "container-like" functors, this means applying the function to each element of the container)
23:20:16 <Cale> (for "computation-like" functors, it means applying the function to the eventual result of the computation)
23:21:04 <tensorpudding> fmap takes functions which act on a and returns functions that act on f a
23:21:51 <falconair> makes sense so far
23:22:14 <Cale> okay, so a functor is just any type constructor which implements this simple API
23:22:18 <dolio> I still haven't seen anything comparable to do or monad comprehensions for comonads.
23:22:47 <dolio> I guess dataflow languages would be the place to look.
23:23:41 <tensorpudding> what is a "dataflow language"?
23:23:47 <tensorpudding> someone in
23:23:52 <Cale> (well, there are actually some rules which should be followed, but I'll not bother with them for now)
23:24:33 <tensorpudding> err, someone in blah was talking about a "dataflow language" that was trying to implement parallelism through pipes
23:24:44 <Cale> A monad m is a functor, plus a little bit more. It also has  return :: a -> m a  and  join :: m (m a) -> m a.  From the container-like perspective, you can think of return as just making a container with a single element, and join as performing some kind of concatenation.
23:24:45 <dolio> It is a language that is impure with the Stream comonad (or something like it) similar to how an imperative language is impure with the IO monad.
23:25:08 <tensorpudding> i'm not at all aware what Stream is...
23:25:25 <dolio> It's an infinite sequence of values.
23:25:27 <Cale> From the computation-like perspective, return produces a computation which does nothing except to produce the given value
23:25:40 <Cale> and join does something perhaps a little less familiar
23:25:58 <falconair> Cale: so far with you (I undertand the need for return, join always seems like a strange jump in complexity)
23:26:28 <tensorpudding> join can be expressed in terms of bind, which i find easier to think about
23:26:30 <c_wraith> join is a big jump in complexity.  It's where the interesting stuff happens
23:26:45 <tensorpudding> well, bind and return
23:26:49 <Cale> Right, join takes a computation x which computes as its result another computation, and produces the computation which if you run it, will first run x, then its result
23:27:02 <dolio> So variables/values in a dataflow language are actually time-varying, rather than being constants, or something like that.
23:27:17 <Cale> join is a bit unnatural as a primitive for the computational perspective on things
23:27:18 <tensorpudding> okay
23:27:31 <Cale> Normally we want to think of sequencing computations one after the other
23:27:44 <dolio> fib :: Int ; fib = 0 `followedBy` 1 `followedBy` fib + next fib, or something of that sort.
23:28:18 <tensorpudding> > join [[1,2,3],[4,5,6]]
23:28:19 <lambdabot>   [1,2,3,4,5,6]
23:28:34 <Cale> So there's actually another function you might have seen, written >>= and pronounced "bind"
23:28:49 <tensorpudding> > join (Just (Just "this"))
23:28:50 <lambdabot>   Just "this"
23:28:55 <Cale> If we have fmap and join, we can write  x >>= f = join (fmap f x)
23:29:03 <falconair> Cale: do a computation on a parameter, get the result, pass it as a parameter to the next similar computation (thus forcing order), correct? if so, is this join or bind?
23:29:35 <Cale> falconair: That's sort of like bind, yeah
23:29:43 <Cale> (>>=) :: m a -> (a -> m b) -> m b
23:30:23 <Cale> Bind takes a computation whose result has type a, and a function from possible results of that computation to further stuff to be done, and glues them together in the only obvious way
23:30:56 <Cale> It might help to see how it looks in do-notation:   x >>= f  =  do { v <- x; f v }
23:31:16 <falconair> ok, bind makes sense, i see that join flattens nested lists, but don't see how it applies in computational metaphore
23:31:22 <Cale> To run (x >>= f), we run x, getting the result v, and then we run f v
23:31:34 <Apocalisp> falconair: There are constructs in between functor and monad (pointed functor, applicative functor). E.g. a functor with `return` is a "pointed functor". Functor to monad is a big jump in complexity.
23:31:56 <tensorpudding> one might say we have a zoo
23:32:01 <tensorpudding> of typeclasses
23:32:03 <Cale> Well, we can write join x = x >>= id, and we can write x >>= f = join (fmap f x)
23:32:12 <Cale> So join and >>= can be defined in terms of each other
23:32:15 <c_wraith> I don't see any piece smaller than join that you can build on top of <*>, fmap, and return that gives join.
23:32:39 <Cale> join is a little less natural as a primitive for computation, but it's often easier to define, especially for container-like situations
23:32:54 <Apocalisp> c_wraith: There isn't one. If there were, then all applicative functors would be monads.
23:33:10 <tensorpudding> it's kinda like in algebra how there is a heirarchy of different structures with names you always confuse
23:33:11 <idnar> Apocalisp: I think he means something you can add to <*>, fmap, and return
23:33:12 <Cale> (and it's part of the original definition of what a monad is, whereas >>= is a newer invention)
23:33:23 <c_wraith> Apocalisp:  sorry, I meant additional functionality that gives you a monad that's less complex than join
23:33:32 <Apocalisp> oh, right
23:33:32 <tensorpudding> magmas, monoids, semigroups
23:33:37 <idnar> the thing is, if you add join to the list, <*> becomes redundant
23:34:03 <falconair> Cale: now we are getting into deeper waters, but let's continue
23:34:20 <c_wraith> falconair: sorry, I kind of introduced a detour.  feel free to ignore it. :)
23:35:08 <Cale> falconair: Anyway, the important thing is that a monad is anything which implements this API well (where by "well", I mean that it satisfies some laws which basically serve to enforce that return does nothing interesting, and that you can chop up long chains of computations into smaller definitions)
23:35:26 <falconair> c_wraith, no prob :)
23:35:39 <tensorpudding> can you define a monad which breaks the laws?
23:35:51 <Cale> tensorpudding: You can define an instance of the Monad typeclass which does.
23:35:53 <falconair> Cale: makes sense, the monad interface and the laws
23:36:09 <tensorpudding> yes, that is what i meant
23:36:13 <tensorpudding> but that is really strange
23:36:15 <Cale> tensorpudding: But it may not work very nicely with the libraries that assume the laws are true.
23:36:17 <Apocalisp> @type \f x -> f x x
23:36:17 <tensorpudding> why does it let you do that?
23:36:18 <lambdabot> forall t t1. (t -> t -> t1) -> t -> t1
23:36:27 <Cale> tensorpudding: Because Haskell isn't a theorem prover.
23:36:46 <Cale> Encoding the laws in the type system would be far too complicated.
23:36:55 <tensorpudding> hmm
23:37:08 <tensorpudding> so it's practically motivated, there is no good reason to make a monad that didn't follow the laws
23:37:12 <Cale> right
23:37:35 <Veinor> @pl \f x -> f x x
23:37:35 <lambdabot> join
23:37:39 <Veinor> :O
23:37:46 <Apocalisp> gasp!
23:38:04 <Cale> It would mean that users of your library would tear their hair out trying to work out why when they performed sensible refactorings, they ended up with different results.
23:38:17 <Apocalisp> falconair: This is an example of a join for computations.
23:38:22 <Cale> falconair: So comonads are similar to this
23:38:26 <falconair> Cale: so given the monad interface, if I just flipped the arrows, I would get a comonad? (coreturn::a <- ma, or coreturn::ma->a)?
23:38:38 <Cale> yeah
23:38:48 <Cale> Keep fmap, flip the arrows on return and join
23:39:04 <tensorpudding> keep your functors contravariant
23:39:12 <Cale> covariant
23:39:13 <tensorpudding> but flip the arrows in the category
23:39:17 <tensorpudding> yes, that one
23:39:26 <Cale> return :: a -> m a  becomes  extract :: m a -> a
23:39:44 <Cale> join :: m (m a) -> m a  becomes  duplicate :: m a -> m (m a)
23:39:48 <falconair> so given coreturn:: ma->a, in terms of containers, it says given a list, get an element out of it?
23:39:55 <Cale> yeah
23:39:57 <falconair> s/coreturn/extract
23:40:11 <Cale> So right away, we see that the lists can't be empty if they're to be a comonad.
23:40:17 <tensorpudding> is there a comonad library?
23:40:24 <Apocalisp> yeah, so container-like comonads have a "distinguished element"
23:40:28 <c_wraith> falconair: the space between the m and a is important in haskell.  It indicates that m is a type constructor, and a is the argument to it.
23:40:29 <Cale> The usual type of lists isn't a comonad, but nonempty lists are.
23:40:34 <falconair> but if extract is applied to a computation, then are we getting a out of m a, which means side-effects could leake into a purely functional program?
23:40:55 <Cale> falconair: Well, you can't think in terms of side-effects
23:40:57 <tensorpudding> @type []
23:40:59 <lambdabot> forall a. [a]
23:41:02 <Cale> Certainly IO is not a comonad.
23:41:27 <tensorpudding> unfortunately [] is too polymorphic for extract [] to have a sensible solution
23:41:33 <Cale> tensorpudding: See category-extras on hackage :)
23:41:35 <falconair> Cale: so what keeps IO from not being a comonad?  does it violate the comonad laws?
23:41:46 <Veinor> tensorpudding: it's called head!
23:41:51 <tensorpudding> > head []
23:41:52 <lambdabot>   * Exception: Prelude.head: empty list
23:42:00 <Veinor> oh, you wanted a total function :p
23:42:07 <Cale> falconair: Well, you just nailed it -- there's no way to extract a value of type a from something of type IO a
23:42:13 <tensorpudding> wouldn't having non-total functions break the monad laws?
23:42:20 <falconair> Cale: also, why are empty lists comonads, but not populated lists?
23:42:29 <Cale> falconair: You'd have to actually *run* the IO action, which is something only the runtime system is allowed to do
23:42:34 <Veinor> Cale> tensorpudding: Because Haskell isn't a theorem prover.
23:42:43 <idnar> falconair: other way around; lists aren't comonads, but non-empty lists are
23:43:04 <Cale> ^^ idnar's response :)
23:43:18 <Cale> tensorpudding: yes
23:43:46 <Cale> tensorpudding: So you might define a comonad instance for something like  data NEList a = One a | Cons a (NEList a)
23:44:00 <Cale> tensorpudding: But not for the usual list type
23:44:40 <falconair> Cale: so I need to pay attention to the laws to understand why only non-empty lists can be comonads and why IO can't leake results?
23:44:52 <Cale> falconair: Well, not for those...
23:45:20 <Cale> falconair: The reason why possibly-empty lists aren't a comonad is that when you try to write extract, what value can you extract from the empty list?
23:45:33 <Cale> falconair: You're stuck. The best you could do is throw an exception.
23:45:58 <Cale> (which you could do, but it might be considered a bit evil)
23:46:00 <tensorpudding> if you made extract = head, that is exactly what would happen
23:46:14 <falconair> Cale: i see, so i can't implement the extract function on an empty list (i would think the compiler would catch this one, no?)
23:46:32 <Cale> well, if you try to write something unsensible, it will
23:47:03 <Cale> You can throw an exception, or leave that case undefined (which may give you a warning)
23:47:51 <Cale> But properly, it's not what you really want to do. You can also construct a type of lists which are not allowed to be empty, and give that a comonad instance.
23:48:20 <c_wraith> and that type is also known as streams, getting back to the earlier question. :)
23:48:34 <Berengal> Or non-empty lists
23:48:42 <Berengal> (streams are infinite, no?)
23:49:04 <falconair> Cale:ok, but say I am reading a data feed off the network, the data will obviously be inside IO, but I want to process it as it comes in, using a comonad...but comonad doesn't work well with IO...what's wrong with this picture?
23:49:26 <Cale> The reason that IO isn't a comonad is that, let's suppose you have something like getLine :: IO String for getting a line of text from the user.  extract getLine :: String  should always be the same String given that you always apply it to getLine (the same IO action), so it can't be the line that the user typed, but then what String ought it to be?
23:49:31 <c_wraith> Oh, I suppose you can have a type for non-infinite non-empty lists, even though it's not easy in haskell
23:50:09 <Cale> falconair: You can use a *different* comonad for processing the data after it comes in.
23:50:19 <Cale> falconair: (possibly)
23:50:27 <Berengal> c_wraith: What about the one Cale provided? data NEList a = One a | Cons a (NEList a)
23:50:33 <Cale> But IO actions themselves don't form a comonad.
23:50:35 <Apocalisp> the non-empty list is the cofree comonad of the Maybe functor. Infinite streams, identity functor.
23:50:39 <idnar> c_wraith: NEList can be finite as well as infinite
23:50:58 <idnar> c_wraith: whereas, say, data Stream a = Cons a (Stream a) is always infinite
23:51:01 <c_wraith> It's not clear that you can write split for that type, though.
23:51:22 <Berengal> split (One x) = One (One x)
23:51:43 <Cale> duplicate for list/stream comonads is just (nonempty) tails
23:51:50 <Cale> Or some variation on that
23:52:05 <Cale> (there are various instances which satisfy the comonad laws)
23:52:26 <Cale> "inits" also works
23:53:16 * c_wraith hopes all this learning stuff sticks around in the morning. :)
23:53:32 <Cale> er, though I think you have to put each initial subsequence in reverse order
23:53:43 <falconair> Cale: i see your point, so the result will be "IO Int", not "Int" (let's assume I end up with integers) ... now if I wanted to use my handy map function to double each of these numbers and send send them back out over another network, or read two int streams, do some calculation on them and send out something over the network if the result passes some predicate...how would that be done?
23:53:51 <Cale> because you want  fmap extract . duplicate = id
23:54:35 <path[l]> how does event driven programming work with haskell? If I want to write a program that responds everytime a user does something like click
23:54:46 <Apocalisp> There's always the OI comonad :)
23:54:54 <Cale> Apocalisp: not a comonad
23:55:01 <c_wraith> path[l]: that's up to the UI library you use.
23:55:07 <Apocalisp> oh?
23:55:33 <falconair> Cale: something like do { x <- readStream; if x>5 <dosomething>}
23:55:36 <Cale> Apocalisp: (even though there was a paper about it, it was determined not to actually work -- that is, unless you can split the real world ;)
23:56:14 <path[l]> c_wraith: I just recently this article about Linq RX where they point out that event driven programming is just another way of operating on a lazy list. Except here the laziness is not pulled as in "when you need the data" but pushed as in "when an even enters the list"
23:56:21 <Cale> falconair: Well, using the IO monad is not unlike traditional imperative programming.
23:56:29 <path[l]> I was wondering if thats what happens in haskell
23:56:42 <path[l]> http://themechanicalbride.blogspot.com/2009/07/introducing-rx-linq-to-events.html <-- the link
23:56:47 <Cale> falconair: There are a lot of ways you could arrange for the processing to be done... I'm not *quite* sure what you're looking for.
23:57:20 <path[l]> oh I think falconair  is talking about the same thing
23:57:24 <c_wraith> path[l]: it remains the case that there's no one way that haskell UI libraries work.  There are various reactive libraries that work somewhat like that.
23:57:39 <path[l]> ah
23:57:42 <path[l]> hmm
23:57:57 <path[l]> I never realised that duality before I read that link
23:58:00 <falconair> Cale: I'm not sure either :) partly curious, partly trying to get a handle on the semantics of stream processing (like what are the basic combinators needed)...once i have this, i can even implement it in java
23:58:09 <path[l]> which was because falconair mentioned it on another channel
23:58:19 <Apocalisp> Cale: That's odd. Maybe the way I think it would work actually violates comonad.
23:58:24 <falconair> I asked path[l] the same question in scala :)
23:58:36 <Cale> Apocalisp: Well, what's the type of getLine?
23:59:27 * Apocalisp looks at old notes
