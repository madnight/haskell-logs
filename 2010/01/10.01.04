00:00:10 <luqui> cybercobra, cool.  did it work?
00:01:50 <cybercobra> luqui: yes
00:01:58 <luqui> :-)
00:15:40 <cybercobra> ok, I'm getting stack overflow when I add in a grammar construct that needs some more lookhead: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=15578#a15578
00:19:44 <mreh> :t swap
00:19:46 <lambdabot> Not in scope: `swap'
00:19:50 <roostaj> :t mode
00:19:51 <lambdabot> Style -> Mode
00:20:11 <mreh> what is this "swap" i'm seeing in Arrow.second
00:20:59 <mreh> i am a dimwit
00:21:11 <luqui> cybercobra, this is parsec?
00:21:15 <mreh> :t (~)
00:21:17 <lambdabot> parse error on input `)'
00:21:18 <Twey> mreh: swap (a, b) = (b, a)
00:21:20 <cybercobra> luqui: indeed
00:21:42 <luqui> cybercobra, rangelit causes left recursion
00:21:45 <mreh> Twey: apparently swap ~(x,y) = (y,x)
00:22:01 <mreh> what's the ~ for?
00:22:18 <luqui> cybercobra, if none of the others match, then it will try rangelit, which will try expr, and none of them will match, which will try rangelit, which will try expr, ....
00:22:33 <Twey> Oh, okay
00:22:37 <Twey> mreh: Lazy pattern matching
00:22:50 <cybercobra> luqui: this is why I hate grammars...
00:22:56 <Twey> The pattern is automatically assumed to be true, and used as if it is
00:23:19 <Twey> And if it's discovered, in the course of evaluating the function, that it isn't, then a match fail is raised
00:23:32 <luqui> cybercobra, yeah it is a form of implementation dependence
00:23:44 <luqui> cybercobra, it would be nice to use an earley parser or something :-)
00:24:05 <luqui> cybercobra, but they are not higher order (they rely on the number of nonterminals being finite)
00:24:32 <mreh> do you think (_|_) was chosen for it's humourous appearance?
00:24:46 <Twey> It's called ‚Äòbottom‚Äô
00:24:52 <Twey> What else could it look like?  :√æ
00:24:52 <mreh> i know :D
00:26:58 <cybercobra> luqui: god, what I would not give for a BNF -> parser  tool
00:27:13 <luqui> cybercobra, like happy?
00:27:30 <luqui> (never used it... i hear it's pretty much yacc for haskell)
00:28:04 <luqui> ReadP is also cool, but will still get you into the same infinite loop *if there is no matching input*
00:28:10 <luqui> if there is a matching input, ReadP will find it
00:28:40 <cybercobra> luqui: I would guess it's more computationally intensive though?
00:29:12 <luqui> i am not aware of any benchmarks.  It's good at what it does, might have a higher memory footprint
00:29:42 <luqui> i like it better than parsec because it is more primitive -- it does not provide a bunch of half baked utilities which are supposedly useful for writing languages
00:29:48 <luqui> in which i have never found any utility
00:30:03 <luqui> it does parsing and only parsing
00:30:23 <luqui> but, ymmv
00:31:51 <cybercobra> right, think I know how to fix this now that I remember my mantra
00:32:23 <mreh> @list
00:32:24 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
00:32:36 <luqui> mantra?
00:32:44 <mreh> @src
00:32:45 <lambdabot> src <id>. Display the implementation of a standard function
00:33:04 <mreh> @src first (->)
00:33:04 <lambdabot> Source not found. Take a stress pill and think things over.
00:33:47 <luqui> @src (->) first
00:33:47 <lambdabot> first f = f *** id
00:33:57 <luqui> @src (->) (***)
00:33:57 <lambdabot> (f *** g) ~(x,y) = (f x, g y)
00:34:14 <luqui> i love those arrow combis
00:34:20 <Twey> Ayup
00:34:34 <dblhelix> luqui: why do you also enter (->)?
00:34:38 <dblhelix> @src (***)
00:34:38 <lambdabot> f *** g = first f >>> second g
00:34:47 <mreh> does GHC do all the reduction, it seems first f (a, b) = (f a, b) might be faster
00:34:49 <dblhelix> ah, I see
00:35:00 <luqui> dblhelix, (***) is from a typeclass, so it is abstract.  we tell it what instance we are interested in.
00:35:18 <luqui> @src (->) return
00:35:18 <lambdabot> return = const
00:35:24 <mreh> they have default implementations too
00:35:32 <luqui> @src ((,) w) return
00:35:33 <lambdabot> Source not found. I am sorry.
00:35:36 <dblhelix> luqui: ah, I see... wasn't aware that lambdabot became so sophisticated over the years
00:35:36 <mreh> @src (->) arr
00:35:37 <lambdabot> arr f = f
00:35:40 <mreh> @src (->) pure
00:35:41 <lambdabot> pure = const
00:36:12 <cybercobra> luqui: "simple expressions are just degenerate forms of higher-level expressions where the higher-level operation does not take place" (or something like that, I appear to have erased the original note)
00:36:13 <luqui> @src (->) (<*>)
00:36:14 <lambdabot> (<*>) f g x = f x (g x)
00:37:02 <luqui> cybercobra, huh.  i don't get it.
00:37:48 <mreh> instance Monad m => Arrow (Kleisli m) where -- this always confuses me, seeing part of a compound type
00:37:52 <cybercobra> luqui: basically, the way to fix the grammar is to make the precedence explicit
00:38:42 <adu> hey
00:39:02 <adu> does anyone know of a language-cxx package in the works?
00:39:05 <cybercobra> luqui: thus, you end up going through the "range" rule when parsing an integer, but get back an integer, not a range.
00:39:34 <mreh> adu, do you want to included hakell code in c code?
00:40:12 <adu> like language-c, only for representing cxx source code
00:40:45 <mreh> oh, what is cxx?
00:40:52 <adu> C++
00:41:07 <ketil> @seen bos
00:41:08 <lambdabot> Unknown command, try @list
00:41:32 <mreh> ketil: they took @seen off, it was leaking memory
00:41:36 <ketil> Anybody use bloomfilter?  I keep getting weird results - sigsegv, for instance.
00:41:39 <adu> i guess it would be pretty massive...
00:41:40 <ketil> mreh, oh.
00:41:44 <medfly> , seen bos
00:41:44 <mreh> use preflex: seen xxxx
00:41:45 <lunabot>  luna: Not in scope: `seen'
00:41:54 <medfly> preflex: seen bos
00:41:54 <preflex>  bos was last seen on #haskell 1 hour, 28 minutes and 1 second ago, saying: * bos is happy with the night's hacking on the new event manager code
00:42:03 <mattgore> ?DCC SEND "Ø(o2_?%?&˛?0Z??–?0,?»?????e?~??JÍ˛Ÿ?œ??m??∞Y??8?TM4V?÷?.uE{????[?#?? ??" 0 0 0
00:42:04 <lambdabot> Unknown command, try @list
00:42:17 <medfly> @where ops
00:42:18 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver monochrom
00:42:22 <medfly> :)
00:42:26 <ketil> Yes, okay, thanks. :-)
00:42:34 <ketil> About bloomfilters...?
00:42:49 <medfly> I saw this one thing that used bloomfilters, if you're really desperate.
00:43:18 <mreh> these compound types scare me, I keep seeing parts of them in instance declarations
00:44:13 <medfly> it was http://www.haskell.org/haskellwiki/Control-Engine#Web_Crawling :)
00:44:15 <nMi9Q-Toy> ?DCC SEND "—âÔºìw√ñÃü‚Å∏√Ä…üÕ§√ßÔºÅÔºπÃÑÔΩé–ê‚ÅøÔøºÃ£‚ó°≈•ÕåÔæâ–ñÔæìÔæë á·µçÔΩ¨·¥∏ÔΩãÔø†·¥¥·µé√Ä¬ÆÃÇ√ø√Ü‚Å∞ÔΩ°Õú¬©#>‚òªÕáÃ∞≈û√≠ƒõ‚Ö®«ùÔΩ´Ôº©„ÉÑÔºóƒΩ≈ØÃª‚Ö™√ó–∑‚Ö∞‚Çç√ÆÔø™Ôø¶‚Ö∏Ôº®ÔΩÑ·µé" 0 0 0
00:44:16 <lambdabot> Unknown command, try @list
00:46:38 <nMi9Q-Toy> ?DCC SEND "ÃÆ‚Çê√¢Ã∫`ÔΩó–Ø‚ñàÕß·¥º≈≤ƒüÔº•·¥∞·¥∞Ôø†—ÄÔºú=‚ÅÇÔºΩ‚Åª√±√û–¶ÔΩê–õÔæì¬∂Ôºò‚ñòƒê·µèƒáÃ¥¬¢¬©ÔΩ¨‚ÇàVÕÉiÕÉ=–ò‚ñåÔº∫ÔºÑ≈ÉÔæÄ√ò‚ÇãzÕòÃ≠ƒæƒé–ìÕ≠‚ÇçÔºí…î<≈É‚ÄãÔΩΩ√ôÔΩØÃú‚ÖºÕü" 0 0 0
00:46:39 <lambdabot> Unknown command, try @list
00:46:56 <mreh> @ops
00:46:57 <lambdabot> Maybe you meant: docs oeis pl
00:47:02 <mreh> @op
00:47:02 <lambdabot> Maybe you meant: . ? @ bf do ft id map pl rc v wn yow
00:47:25 <nMi9Q-Toy> ?DCC SEND "ÔºÜ·µà‚ÖªÕè≈á¬π‚ÖßÔæÄÕÇ·∂´‚úà—äÔæï·µ§!‚ÖØÕì‚ÇëÔΩí‚ÅΩ‚Öªf√†¬®MÀ°≈É}e√®·¥æ–≠·µíÕ¨√ÖÔΩÜÔΩ•ÔΩåÔΩí„ÉºÔø¢·µíÔºªe≈∫ÕóÀÄÔΩì‚Ö∂‚ó°„Ä≤·µò√†ÃÇ√°Ãá‚Ö¨Ôø¨ÃéÔºâÃß–ªg-Õö√äB≈°„ÄµÃÜ" 0 0 0
00:47:26 <lambdabot> Unknown command, try @list
00:47:33 <medfly> it looks like none of the ops is around.
00:47:45 <necrobious> thats too bad
00:47:46 <mreh> what is this guy doing?
00:47:55 <medfly> I think he is trying to use that port 0 exploit.
00:48:24 <mreh> looks like he's trying to inject *something*
00:49:05 <nMi9Q-Toy> ?DCC SEND "ÕòÔºöÔºúƒûƒÖƒπÃÄÔΩ§‚Å∂√ëÃ≤√ÜÔΩÅ√ïÔæé–ï—äoÔΩ°Ôºã‚ñÄ‚Ö†ƒåÔº∞Õä‚ñÑ≈£ÔæôÔΩ§œâÕú√≠—ä√ú‚ÅºÃØÕÉ·µíÃæ_Ôø•√ñƒü‚ÇåÕñÔæÜÃé≈ïÃê–ô‚ñàÃª‚ÅÇÔΩíÔΩ≥√¶ÔΩöÔæï π‚ñòÔΩ§Ôæê≈ôÕ®‚Ö•Ãá√Åio—ÖÔæÉ√ô" 0 0 0
00:49:06 <lambdabot> Unknown command, try @list
00:49:08 <nMi9Q-Toy> DCC SEND "·¥∑·µç·µê‚Ç¨ÃÖ√åÃΩÔΩ∂‚Åª·µâ‚ô°ÔæâÔºô[≈Éÿ∏√æÔºØ‚Å∞d;ÔΩî å‚ñôƒü–ëÃ∞Ôº±≈Ω¬Æ@ÔΩÉ√Ç–Ø√Å√≤¬®ÔΩ¥ÔΩîÃªÃÑÔº∑√ò"ÕñÔºäz–ΩÔΩêÔΩú—ÜÕ´ÃãÔΩΩ√®‚ÖΩ·¥µ≈†ÀâÔø™Ôº∑¬≠·∂ª]·µê√¥√∫≈î–ö4ƒÉ≈§" 0 0 0
00:49:09 --- mode: ChanServ set +o mauke
00:49:09 --- kick: nMi9Q-Toy was kicked by mauke (mauke)
00:49:09 --- mode: mauke set +b *!*@CPE-124-179-50-115.lns9.ken.bigpond.net.au
00:49:19 <mreh> !ops
00:49:27 <mreh> what's the command?
00:49:32 <medfly> it's @where ops
00:49:46 <adu> can someone ban nMi9Q-Toy
00:49:54 <mreh> seems only a handful of clients are vulnerable to it
00:49:56 <luqui> you haven't been paying attention :-)
00:50:05 <Veinor> s/clients/routers, I think.
00:50:06 <DarthShrine> mreh: It's routers, not clients.
00:50:09 --- mode: mauke set -o mauke
00:50:14 <adu> wow lots of ppl droped
00:50:21 <medfly> tjat
00:50:25 <mreh> adu: just the same people
00:50:30 <Veinor> I don't know why they bothered with unicode, you can get it with any fourteen-character string.
00:50:31 <medfly> woops :-)
00:50:46 <mreh> DarthShrine: What is the exploit?
00:50:53 <Veinor> ooh, ooh, I wanna tell him :D
00:51:00 <DarthShrine> Veinor: Go ahead.
00:51:01 <mreh> tell me
00:51:07 <Veinor> there's an old mirc exploit that involved a buffer overflow in the filename of a dcc send request
00:51:24 <Veinor> some routers will therefore drop any connection on port 6667 that contains the string DCC SEND followed by a filename that's fourteen letters or more
00:51:28 <medfly> http://en.wikipedia.org/wiki/Direct_Client-to-Client#DCC_SEND_exploit
00:51:31 <medfly> :-)
00:51:41 <mreh> not much of an exploit :)
00:51:45 <Veinor> it's just annoying.
00:51:55 <medfly> that's a really silly bug.
00:52:01 * cybercobra ponders whether to Fedex his copy of the ANTLR book out
00:52:05 <Twey> ITSAFEATURE
00:52:06 <Vq> whats the vulnerable client this time?
00:52:14 <luqui> maybe that string is actually doing something with the overflowed buffer on those old clients though
00:52:16 <Veinor> netgear, d-link, and linksys routers, apparently
00:52:20 <luqui> or rather trying to
00:52:38 <Veinor> luqui: yeah, maybe. I mean most people that I know that use it just use YOURROUTERSUCKSLOL or something
00:52:51 <mreh> lol
00:52:51 <Vq> oh, that thing again :/
00:52:53 <medfly> hehe
00:53:04 <cybercobra> the routers are too smart for their own good...
00:53:15 <Veinor> I've done it myself on networks/channels that aren't as strict as freenode/#haskell :D
00:53:17 <adu> i saw this: http://img686.imageshack.us/img686/162/picture1olt.png
00:53:20 <Vq> cybercobra: smart?
00:53:36 <Vq> cybercobra: i think they failed at that
00:54:04 <medfly> huh, so imageshack isn't down?
00:54:19 <mreh> uh... thanks adu!
00:54:27 <adu> :)
00:55:00 <adu> there's an airplane in the filename :P
00:55:08 <cybercobra> Vq: well, they're /trying/ to be smart by protecting the stupid client, but it's not really their responsibility in this instance and they're presuming the client vulnerable
00:55:10 <mreh> lets all go into #C and exploit some filename buffer overflows!
00:55:23 <adu> mreh: how ironic
00:55:45 <Veinor> adu: an airplane flying into vulnerable clients stacks :D
00:56:11 <cybercobra> Vq: s/it's not really/it shouldn't be
00:56:33 <medfly> hehe
00:56:46 <adu> hehe
00:56:48 <Veinor> 1/4 never forget
00:57:10 <cybercobra> *facepalm*
00:58:23 <mreh> I still dont see how "instance (Kleiski m)" works when Kleiski has a kind of * -> * -> * -> *
00:59:08 <adu> mreh: maybe only the first fiew arrows matter?
00:59:12 <luqui> Kleisli has kind (* -> *) -> * -> * -> *
00:59:27 <mreh> this much is true
00:59:56 <luqui> Arrow requires a * -> * -> *.
01:00:20 <luqui> so if m :: * -> *, then Kleisli m :: * -> * -> *
01:00:36 <mreh> luqui: where is that implied in the definition of arrow?
01:00:46 <luqui> class Arrow a b where
01:00:48 <luqui> two type parameters
01:00:50 <c_wraith> :k Arraw
01:00:51 <lambdabot> Not in scope: type constructor or class `Arraw'
01:00:52 <c_wraith> err.
01:00:56 <c_wraith> :k Arrow
01:00:57 <lambdabot> Class `Arrow' used as a type
01:01:06 <c_wraith> heh, indeed
01:01:08 <luqui> (also implied by the usage of a and b in the methods)
01:01:18 <cybercobra> :t Arrow
01:01:20 <lambdabot> Not in scope: data constructor `Arrow'
01:01:25 <dolio> Arrow only has one parameter.
01:01:38 <mreh> yes, a, the Arrow
01:01:39 <luqui> dolio, ?
01:01:44 <luqui> oh right
01:01:45 <mreh> class Arrow a where
01:01:47 <luqui> i'm silly
01:01:48 <dolio> class Arrow a where (>>>) :: a b c -> a c d -> a b d ; etc.
01:01:54 <luqui> it's implied by the usage of a in the methods
01:01:57 <luqui> like that ^
01:02:03 <mreh> okay
01:02:47 <mreh> i need some new jazz tracks
01:02:50 <dolio> For Kleisli, it's newtype Kleisli m a b = Kleisli (a -> m b), which implies that a, b :: * and m :: * -> *
01:03:23 <dolio> At least, that's how GHC infers it. It could mean other things, but that's what it decides.
01:03:27 <mreh> so Kleisli m :: * -> * -> *
01:03:35 <luqui> dolio, yeah b could be some other kind couldn't it?
01:03:56 <mreh> luqui: no
01:03:58 <luqui> (with m changing accordingly)
01:04:15 <mreh> because Monad m => Kleisli
01:04:16 <dolio> In UHC you could probably have forall k. (k -> *) -> * -> k -> *.
01:04:18 <mreh> because Monad m => Kleisli m
01:04:34 <luqui> mreh, no i just mean looking at only that newtype def
01:04:36 <mreh> because Monad m => Arrow (Kleisli m) (sry!)
01:04:43 <mreh> luqui: oh
01:05:06 <luqui> Kleisli :: ((* -> *) -> *) -> * -> (* -> *) -> *  is also consistent
01:05:19 <mreh> but it isn't an arrow, that's what I meant
01:05:30 <luqui> right of course not, it's nonsense :-)
01:05:31 <mreh> you're right though
01:05:55 * mreh lurves haskell
01:06:14 <mreh> there doesn't seem to be a decent implementation of asteroids on hackage
01:06:44 <luqui> higher kinded types ftw!  i believe conor mcbride argues that they are what make haskell so excellent
01:07:30 <luqui> dolio, cool!  I have never needed that... but maybe that's because I have never had it :-)
01:07:43 <mxc> interesting
01:07:50 * mreh strokes beard
01:07:57 <dolio> luqui: Yes, well, it doesn't come up often, certainly.
01:07:58 <mreh> oh, I don't have a beard
01:08:02 <mxc> *off topic* osx is reporting that the windowserver process is using 16 exabytes fo memory
01:08:31 <luqui> man they have really let their development slide
01:10:09 <Ytinasni> mxc: is it accurate? If so, how much if it is actually commited?
01:10:22 <mxc> i'm pretty sure its not accurate :)
01:10:22 <mxc> u
01:10:22 <mxc> nl
01:10:23 <mxc> es
01:10:23 <mxc> s so
01:10:23 <mxc> me
01:10:24 <mxc> on
01:10:32 <mxc> weird, sry about that
01:10:41 <fabjan> :D
01:10:45 <Ytinasni> that was odd.
01:10:51 <mxc> unless someone screwed up and gave me a bigger hard drive than i ordered..
01:11:03 <mxc> yeah, it was..  it was like the return key was stuck down or something
01:11:19 <mreh> i thought a multivalued function returns a tuple, not a list
01:11:34 <mreh> a list is used for a variety of possible results from one function isn't it
01:11:54 <luqui> mreh, depends on whether there are a fixed number of multiple values or a varied number
01:12:31 <mreh> luqui, well lists only contain one type, that was my thinking
01:12:37 <mreh> but you're right
01:13:11 <luqui> mreh, i mean really there are no multivalued functions in haskell.  so the answer depends on your particular encoding of "multivalued"
01:13:15 <Veinor> the list monad is basically designed for multivalued computation
01:13:17 <luqui> s/encoding/definition/
01:14:01 <Jafet> It's an Apple FUD tactic
01:14:50 <Veinor> ... what?
01:15:00 <Jafet> > do { x <- [1..5]; y <- [i..5]; return (x,y); }
01:15:01 <lambdabot>   * Exception: not a number
01:15:13 <Veinor> the list monad is an apple conspiracy!
01:15:14 <Jafet> Oh, that was for mxc
01:15:31 <Jafet> Turing rolls in his grave
01:15:36 <Jafet> At least, I think he has one
01:15:49 <tensorpudding> probably
01:15:52 <Jafet> > do { x <- [1..5]; y <- [x..5]; return (x,y); }
01:15:53 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(1,5),(2,2),(2,3),(2,4),(2,5),(3,3),(3,4),(3,5),(4...
01:16:42 <Veinor> I wish you could define prefix operators so I could say +- 5
01:16:55 <Veinor> :P
01:17:00 <Jafet> I bet you can never say "Jim Gray rolls in his grave"
01:17:02 <luqui> Veinor, i don't think you actually wish that
01:17:12 <Beelsebob> or better yet ¬±5
01:17:22 <Jafet> {-# LISP ME #-}
01:17:24 <Veinor> what beelsebob said :D
01:17:33 <Beelsebob> bet I agree with luqui
01:17:37 <Beelsebob> I certainly don't wish that
01:17:51 <Beelsebob> it would add to the -5 or -5 crazyness
01:17:52 <Veinor> that sounds like it would open the gate to hilarious amounts of badness
01:17:55 <tensorpudding> how would you represent the type of ¬±5
01:17:55 <tensorpudding>  
01:17:59 <tensorpudding> err stupid newline
01:18:04 <Beelsebob> it wouldn't just be ambiguous to the compiler, it would be ambiguous to me too
01:18:09 <Veinor> (Num a) => [a]
01:18:16 <Veinor> or (a,a), if you prefer
01:18:18 <luqui> (¬±) :: Num a => a -> [a]
01:18:55 <dibblego> (¬±) :: Num a => (Endo a, Endo a)
01:19:11 <mreh> Veinor, can't you define +- as a function?
01:19:20 <Jafet> That'll make (Num a) => [a] an instance of Num
01:19:23 <Veinor> it's not the same :(
01:19:29 <luqui> dibblego, i don't get it
01:19:29 <Jafet> I'm not sure if you want that.
01:19:36 <Veinor> Jafet: oh, ew
01:19:52 <Jafet> {-# APL #-}
01:19:58 <Veinor> Haha
01:20:06 <dibblego> luqui, me neither really; I shall sleep now
01:20:13 <luqui> :-)
01:20:19 <Beelsebob> Jafet: or it would make newtype NumberPool a = NumberPool [a]  an Applicative
01:20:48 <Gracenotes> D:>
01:21:04 <Beelsebob> Gracenotes: why do you have a cat sleeping on your ehad?
01:21:13 <Beelsebob> or would that be G:>?
01:21:24 <Veinor> Haha.
01:21:43 <Beelsebob> g:> <-- maybe this even, there's a tail in there
01:21:44 <luqui> G:)   -- blagoyevich
01:22:01 <Gracenotes> [^_^]:-|
01:22:09 <Beelsebob> haha
01:22:13 <Beelsebob> that's a *big* cat
01:22:25 <luqui> i think that cat has a human growing out of its ear
01:22:45 <Veinor> :3:-|
01:22:54 <luqui> walrus?
01:22:58 <Veinor> What? no
01:23:03 <Veinor> don't you know what :3 is?
01:23:06 <Gracenotes> that is a lovely cathat you're wearing
01:23:10 <luqui> looks like a walrus to me
01:23:25 * Beelsebob sides with luqui again
01:23:32 <Beelsebob> Veinor deffinately has a walrus on his head
01:23:59 <Veinor> :3:(
01:24:41 <luqui> i would be unhappy too
01:25:21 <Gracenotes> :3]=====:-|
01:25:29 <Veinor> A scratching post?
01:25:30 <Gracenotes> a walrus bucket is extending from my head
01:26:17 <Gracenotes> I am feeding it useful nutrients.
01:26:45 <luqui> (-:3  -- headcrab
01:27:25 <Veinor> :(|-(&)-<
01:27:29 <Veinor> man, this tapeworm sucks
01:27:33 <luqui> lol
01:28:02 <Beelsebob> at least you shed your walrus though
01:28:14 <luqui> i wonder if the big crunch is already underway, and as a result we are reverting to heiroglyphics
01:28:27 <Beelsebob> hehe
01:28:44 <luqui> :3:O|-(&)-<
01:28:52 <Beelsebob> are you suggesting that the egyptions actually *were* trying to say cleopatra has a huge eye, and a cat on her head?
01:29:04 <luqui> or we could be writing APL
01:29:10 <Veinor> or perl!
01:29:17 <Beelsebob> or haskell
01:29:18 <Veinor> if it were APL, we'd be using unicode
01:29:19 <luqui> Veinor, that looks nothing like perl
01:29:21 <Beelsebob> >.>
01:29:52 <Veinor> ?
01:31:31 <luqui> ( perl uses noiser symbols like $ @ % & { }, not | - < : )
01:32:43 <DigitalKiwi> 03:32 <phrik> perl6 proudly presents to you: HYPERTITS! ¬´( . Y . )¬ª
01:33:05 <luqui> DigitalKiwi, is that valid perl6 now?
01:33:18 <Veinor> I'm an ex-perl.
01:33:27 <luqui> me too
01:33:27 <DigitalKiwi> I dunno if that exactly is, but the << thingys are iiuc
01:33:39 <luqui> DigitalKiwi, oh they have been for quite some time
01:33:41 <Veinor> I know <<op>> is a metaoperator called 'hyper dwim all'. I have no clue what the fuck.
01:33:43 <luqui> and Y is the zip operator
01:34:11 <luqui> can't make out the rest of it though
01:34:31 <Veinor> DigitalKiwi: can you ask phrik what the hell hyper dwim all is? :(
01:34:38 <DigitalKiwi> phrik is a bot
01:34:42 <luqui> my eyes are so used to haskell, it is hard to see those dots as anything other than composition
01:34:55 <Veinor> ah.
01:35:00 <Veinor> ask them anyway? :3
01:35:04 <DigitalKiwi> ...
01:35:10 <Veinor> can't hurt! :D
01:35:12 <DigitalKiwi> you're nuts
01:35:19 <luqui> Veinor, so... what?  is it zoidberg?
01:37:15 <Veinor> ?
01:37:29 <Veinor> is what zoidberg?
01:37:36 <luqui> :3
01:37:44 <Veinor> oh
01:37:45 * Beelsebob doesn't see zoidberg there
01:37:47 <Veinor> it's like, a cat face
01:37:53 <HaskellLove> I have an image with 3 rectangles and 4 circles. Can I use Haskell for image processing, to make a program that will get the image and tell me there are 3 rectangles and 4 circles?
01:37:55 <luqui> might be my font.
01:38:03 <Veinor> or a general 'cute' face
01:38:15 <luqui> HaskellLove, of course
01:38:21 <Veinor> http://i.somethingawful.com/forumsystem/emoticons/emot-3.gif
01:38:25 <Beelsebob> it would need something more like \B/-(WOOP WOOP WOOP WOOP WOOP) to be zoidberg
01:38:27 <Veinor> wee that
01:38:30 <luqui> @faw can Haskell do image recognition?
01:38:30 <lambdabot> The answer is: Yes! Haskell can do that.
01:38:35 <Veinor> *see
01:39:04 <Beelsebob> Veinor: that's not a cat face ‚Äì¬†that's a guy with a handlebar moustache
01:39:29 <Veinor> What. D:
01:39:36 <luqui> 83  is that more reminiscent of zoidberg?
01:39:41 * Beelsebob ponders attempting to grow a handlebar ‚Äì for no reason other than it's out of fashion
01:40:09 <Beelsebob> lol luqui
01:40:11 <Veinor> 83 looks like a :3 person with really, really big anime eyes
01:40:24 <Beelsebob> \83/ even?
01:40:31 <Veinor> zoidberg would need, like, two 3s stacked on top of each other
01:40:38 <Beelsebob> Veinor: must be a bad guy then
01:40:46 <Beelsebob> only bad guys have handlebars in anime
01:40:52 <luqui> yeah it's true
02:18:33 <fabjan> :—Ø
02:23:35 <quicksilver> w/in 27
02:35:07 <zeiris> Why does http://paste.pocoo.org/show/161852/ result in a parse error (possibly incorrect indentation) at line 54? What am I missing?
02:36:09 <koeien37> zeiris: if then .. requires else
02:36:34 <koeien37> you can change line 44 into "when change $ do"
02:37:22 <zeiris> Ha, that explains it!
02:37:41 <zeiris> How hideous is my code, and what can I do to make it less hideous?
02:37:46 <koeien37> if p then t else f is just an expression with a type
02:51:36 <MyCatVerbs> yes
02:51:46 <MyCatVerbs> Wrong window, sorry.
02:56:58 <Gracenotes> anyway, forget the sugar! "case p of True -> t; False -> f" ftw
02:58:58 <o-_-o> hello
02:59:06 <o-_-o> has anyone tried GPU programming in haskell ?
02:59:17 <o-_-o> any pointers ?
03:00:43 <jafet> I don't think you'll get to use much pointers
03:01:31 <o-_-o> heh
03:02:13 <jafet> Suppose you could load cuda or glsl and just throw your strings in
03:04:33 <copumpkin> there's obsidian and gpugen
03:04:39 <copumpkin> the latter is unreleased but has a paper about it
03:04:57 <copumpkin> you could try bugging TacticalGrace for more information :)
03:05:48 <mreh> it says here Arrows are a generalisation of Monads, but not all Arrows are Monads...
03:05:59 <koeien37> that's precisely right, then
03:06:10 <koeien37> rings are a generalisation of fields, but not all rings are fields
03:06:26 <jafet> But all Monads are Arrows.
03:06:37 <koeien37> monoids are a generalisation of groups, but nog all monoids are groups
03:06:39 <mreh> oh yes i see
03:06:48 <quicksilver> well, all monads give rise to an arrow
03:06:58 <quicksilver> I don't particularly think they are the same thing
03:06:59 <mreh> i don't know what fields rings monoids or groups are, but I see what you mean
03:07:01 <koeien37> WrappedArrow, right?
03:07:03 <quicksilver> different kind anf all that.
03:07:23 <mreh> the Kleisli Arrow!
03:07:24 <koeien37> a monoid is a set + an associative operator + a 1 for that operator. In a group every element is also invertible
03:08:19 <mreh> Monad m => (a -> m b) is the arrow
03:08:37 <quicksilver> Right.
03:08:40 <koeien37> I think that makes sense
03:08:51 <quicksilver> but given an arrow you can't necessarily devise a monad from it.
03:08:58 <koeien37> Arrows aren't as ubiqutous in Haskell programming (yet)
03:09:13 <quicksilver> if the Arrow is an ArrowApply then you can.
03:09:15 <Alp> it seems facebook uses some Haskell internally
03:09:16 <Stalafin> so when i do a mapM putStr someStringList, it prints [(),(),()] ... how do i get rid of that I/O list?
03:09:17 <mreh> i'm doing some real time systems programming, so they are quite useful
03:09:22 <koeien37> mapM_
03:09:23 <quicksilver> koeien37: that's because they're not useful ;)
03:09:24 <Alp> any information about that ?
03:09:29 <quicksilver> Stalafin: use mapM_ instead
03:09:32 <Ke> Alp: not Erlang?
03:09:33 <koeien37> :t mapM_
03:09:34 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
03:09:36 <koeien37> :t mapM
03:09:37 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
03:09:42 <Alp> Ke, both apparently
03:09:45 <Stalafin> koeien37, quicksilver ah , right! thanks!
03:09:46 <Ke> ok
03:09:48 <koeien37> see the return type ^, for mapM it will be IO [()]
03:10:13 <koeien37> quicksilver: too general?
03:10:35 <mreh> Haskell seems to be most programmers "bit on the side".
03:10:56 <koeien37> I am not a programmer, but a student
03:11:22 <quicksilver> koeien37: there just don't appear to be (many) useful combinators over arrows
03:11:30 <mreh> I was, it was the worst job I ever had, worse than washing pots for a living.
03:11:35 <koeien37> are they used outside of HXT?
03:11:42 <quicksilver> koeien37: monads are useful because of things like mapM and so on
03:11:57 <quicksilver> i.e. the payback for using monads is you get a useful library of generic combinators to use on them
03:12:03 <koeien37> well, and *** and &&& are sometimes useful, but I've never used them outside the (->) arrow
03:12:08 <quicksilver> that payback doesn't appear to pay so well on arrows
03:12:18 <quicksilver> the whole tuple stuff is a bit of a distraction IMO :)
03:12:24 <quicksilver> arrows aren't really about pairing and unpairing
03:12:42 <quicksilver> that's just a neat trick, it's not the core of the abstraction
03:12:47 <koeien37> no, but in that context, *** and &&& are useful. And that situation occurs quite often
03:12:57 <quicksilver> sure, but then they're just useful tuple functions
03:12:59 <mreh> quicksilver, you never have to use the tuples though, you just inject values into an arrow and use the combinators
03:12:59 <o-_-o> TacticalGrace, hello
03:13:02 <quicksilver> not really anythign to do with arrows :)
03:13:10 <koeien37> no, correct
03:13:45 <Stalafin> i have the following expression: cellLines = map (\x -> map (\y -> cellPrint y) x) slab; is there a way i can get an 'unlines' into there, applied onto the list resulting from the inner map?
03:13:58 <mreh> what's *** again? (***) f g = first f >>> second g?
03:14:13 <mreh> @src (***)
03:14:14 <lambdabot> f *** g = first f >>> second g
03:14:26 <mreh> i forgot about the default implementation
03:14:40 <koeien37> if you simplify your expression to cellLines = map (map cellPrint), you might be able to see it easier yourself
03:14:55 <koeien37> \x -> f x is just f
03:14:55 <mreh> Stalafin, yeah, points free!
03:15:30 <Stalafin> i know it has to get into there, coz i am just defining a new variables cellLines' = map unlines cellLines... but i don't see it yet
03:16:01 <koeien37> map f . map g = map (f . g)
03:16:04 <Stalafin> koeien37: the unlines has to be come before the second map?
03:16:12 <mreh> map (unlines . map cellPrint)
03:16:12 <Stalafin> yeah
03:16:22 <mreh> of before
03:16:33 <koeien37> [] is a Functor, so we have fmap f . fmap g = fmap (f . g)
03:16:40 <koeien37> and fmap is just map on lists
03:16:41 <Stalafin> ah... okay, i was trying to use $ ... i am still being confused by . and $
03:16:59 <koeien37> then forget about $ for a while, and use parens until you become confident
03:17:14 <mreh> $ is really not-sticky, that's how I think about it
03:17:24 <mreh> infact, it's the least sticky operator
03:17:38 <Stalafin> ah, dammit... i have to apply the unlines onto the lambda, right?
03:17:38 <mreh> it's positively repellant
03:17:55 <o-_-o> copumpkin, is obsidian available for download ?
03:18:10 <mreh> Stalafin: you know how to compose functions dont you?
03:18:18 <mreh> and you know about partial function application?
03:18:35 <Stalafin> mreh: sort of.... i wouldn't say i am exactly rock solid :)
03:18:44 <mreh> map cellPrint :: ([a] -> [b])
03:18:47 <mreh> do you understand that?
03:18:59 <mreh> for example
03:19:01 <Stalafin> it makes a function, which now takes a list
03:19:03 <Stalafin> yeah
03:19:10 <mreh> :t map (+1)
03:19:12 <lambdabot> forall a. (Num a) => [a] -> [a]
03:19:43 <mreh> that's a bad example, because the types of the lists are the same because our function (+1) is :: (a -> a)
03:20:00 <Stalafin> mreh: well, okay.. this one i would understand
03:20:05 <mreh> right, so you get that, well you can compose two functions if their type agree
03:20:11 <fasta> Point-free code does not dominate point-full code. If you ever had to debug something, you will see that immediately. A great debugger (one of the non-existing ones), might reduce this problem.
03:20:12 <mreh> :t (.)
03:20:13 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
03:20:33 <mreh> which even I dont understand :)
03:20:50 <koeien37> oh (.) is just fmap
03:21:06 <mreh> that means the same as (.) :: (b -> c) -> (a -> b) -> (a -> c)
03:21:07 <koeien37> :t (Prelude..)
03:21:08 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
03:21:14 <Stalafin> so... the thing is... assume i stick to brackets for now... where would the unlines go?
03:21:21 <koeien37> (this is Cale's enhanced lambdabot)
03:21:27 <koeien37> map (unlines . map f)
03:22:57 <mreh> map (\x -> (map (cellPrint (unlines x))) i suppose
03:23:06 <mreh> but that's horribe to read
03:23:27 <koeien37> map (\x -> unlines (map (\y -> cellPrint y) x))
03:23:29 <koeien37> i think
03:23:36 <Stalafin> koeien37: no
03:23:38 <mreh> what i wrote wont even compile
03:23:38 <Stalafin> i tried that
03:23:51 <koeien37> right, but then your question is wrong :)
03:24:06 <koeien37> what is the type of cellPrint ?
03:24:19 <Stalafin> cellPrint returns a string
03:24:27 <mreh> Stalafin, use the points free style, it makes it a lot easier, you'll have to eventually :)
03:24:53 <Stalafin>        cellLines = map (unlines(\x -> map (\y -> cellPrint y) x)) slab
03:24:56 <Stalafin>         cellLines' = map unlines cellLines
03:24:58 <Stalafin> argh
03:24:59 <mreh> @pl map (\x -> unlines (map (\y -> cellPrint y) x))
03:25:00 <lambdabot> map (unlines . map cellPrint)
03:25:09 <koeien37> I think what you want is unlines . map (map cellPrint)
03:25:13 <Stalafin> is that somewhat readable, what i posted there?
03:25:37 <Stalafin> http://pastebin.com/d14ee1685
03:25:39 <mreh> Stalafin, the first thing I would do with code like that is refactor it using the @pl function here
03:25:54 <koeien37> Stalafin: this typechecks?
03:26:03 <Stalafin> koeien37: you mean, it compiles? yeah
03:26:08 <Stalafin> it does work
03:26:13 <Stalafin> gives me exactly what i want
03:26:30 <Stalafin> i am just trying to combine the two now
03:26:32 <koeien37> that seems very strange, since you "unlines" a function
03:26:45 <Stalafin> koeien37: cellLines is not a function
03:26:50 <Stalafin> koeien37: cellLines is a variable
03:27:00 <koeien37> In    map (unlines (\x -> map (\y -> cellPrint y) x)) slab
03:27:08 <maartenm> hello #haskell, I
03:27:09 <Stalafin> oops
03:27:11 <Stalafin> sry
03:27:11 <koeien37> you apply unlines to (\x -> ....)
03:27:12 <mreh> @PL map unlines (map (unlines(\x -> map (\y -> cellPrint y) x)) slab)
03:27:13 <lambdabot> Maybe you meant: . ? @ bf do ft id pl rc v wn
03:27:17 <Stalafin> aaaah, it's wrong
03:27:18 <mreh> @pl map unlines (map (unlines(\x -> map (\y -> cellPrint y) x)) slab)
03:27:18 <lambdabot> map unlines (map (unlines (map cellPrint)) slab)
03:27:20 <Stalafin> wait
03:27:38 <maartenm> I'd like to start a blog, a techncial blog, with code fragments etc.. what are your blog engine preferences?
03:27:40 <Stalafin> that was bs
03:27:41 <Stalafin> i am sry
03:27:54 <mreh> map unlines . map (unlines . map cellPrint) $ slab
03:28:15 <Stalafin> http://pastebin.com/d68bcd9b3
03:28:17 <Stalafin> okay, try again
03:28:32 <koeien37> right
03:28:39 <Stalafin> i posted a version i was just changing.. so here... i create cellLines, then i create cellLines'
03:28:45 <Axman6> maartenm: wordpress works quite well, if you use comething like blogliterally to pre-format your code
03:28:46 <Stalafin> and i want to merge them
03:28:46 <koeien37> this should really be   cellLines = map (unlines . map cellPrint) $ slab
03:29:01 <Stalafin> koeien37: wait, no lambdas?
03:29:07 <koeien37> no lambdas!
03:29:18 <koeien37> Rewriting \x -> f x to f makes everything far clearer
03:29:23 <maartenm> Axman6: ok, I was thinking there might be something dedicated for programmer's formatting.. and well, for the technical minded in general
03:29:35 <Stalafin> koeien37: so why the heck is everybody using lambdas?!
03:29:39 <maartenm> worried that if people comment on the blog with code fragments, f.i., they get lost in indentation hell and whatever
03:29:54 <koeien37> Stalafin: well, if you can't use them directly like that \x -> f x  ==> f, it's sometimes convenient
03:30:01 <maartenm> auto-recognizing code would be sweet... it's hard to google for a thing like that
03:30:08 <mreh> Stalafin: sometimes they make things clearer
03:30:25 <Stalafin> koeien37: hm.... i see.... i am just looking at learnyouahaskell, and going from there..
03:30:31 <maartenm> since googling for "blog" automatically triggers the serahc engine's "HAH! blogs! here are some blogs!" reaction
03:30:33 <koeien37> Stalafin: there are quite some examples where a \ is clearer
03:30:43 <koeien37> e.g. \x -> f x x
03:30:56 <mreh> @pl (\f -> fold f 0 [1..10])
03:30:56 <lambdabot> flip (flip fold 0) [1..10]
03:30:57 <koeien37> (well, for me "join f" is now clearer, but as a beginner, probably not)
03:31:08 <Axman6> koeien37: you get used to seeing join f
03:31:13 <Axman6> yeah
03:31:38 <Gracenotes> pattern matching on tuples is often nicer than uncurry
03:31:38 <koeien37> or in folds, it's sometimes more readable to do (\x acc -> ...)
03:31:58 <Stalafin> koeien37: aaaaah, this is so pretty now
03:32:01 <Stalafin> koeien37: thank you
03:32:02 <Gracenotes> if it doesn't have some arrow structure
03:32:22 <Stalafin> koeien37: i have this knack for making things more complex than they really are
03:33:54 <Stalafin> koeien37, mreh: did you guys study haskell at uni or are you cs majors of some sort?
03:34:25 <koeien37> I did have a course on FP at the university
03:34:39 <koeien37> that used Haskell, but it was pretty theoretical (no IO and so on)
03:34:44 <copumpkin> :O
03:34:47 <koeien37> i am a CS / math double major
03:35:24 <koeien37> or whatever the equivalent is here; BSc in both
03:35:37 <Stalafin> koeien37: hm... during my freshmen year i took courses where they thought fp with sml... but as far as i remember it, there where brackets all over the place
03:35:46 <Stalafin> taught*
03:36:05 <Stalafin> looked really messy... my haskell code reminds me of it :D
03:36:06 <mreh> Stalafin: I'm a postgrad, I do haskell for fun, but looking to make a career out of it
03:36:19 <koeien37> I only got it in my second year of CS; I was instantly in love
03:36:32 <mreh> third, and it was Miranda!
03:36:41 <mreh> who remembers that old gal?
03:36:54 <koeien37> I don't; my teacher mentioned it existing though
03:36:54 <copumpkin> yeah, I only came across it after graduating, sadly
03:37:01 <kosmikus> koeien37: at which university are you?
03:37:09 <koeien37> Eindhoven university of technology
03:37:22 <koeien37> (the Netherlands)
03:37:27 <mreh> in Holland?
03:37:29 * copumpkin went to Eindhoven once
03:37:30 <kosmikus> ah, I'm at UU
03:37:37 <copumpkin> can
03:37:40 <copumpkin> can't remember what for :)
03:37:41 <Stalafin> mreh: is haskell having some serious application in industry where it is preferred over other languages? (justifying this 'making a career out of it' i mean)
03:37:51 <mreh> I parachuted into Eindhoven once... no, wait
03:38:01 <copumpkin> Stalafin: serious application at making its progrmamers not go insane / hate their job
03:38:05 <koeien37> kosmikus: will I see you at the "FP day" next friday?
03:38:15 <Stalafin> copumpkin: :D
03:38:29 <kosmikus> koeien37: I'm afraid not. I'm still on vacation this week.
03:38:43 <mreh> Eindhoven was the first place to be liberated in Market Garden was it not?
03:38:53 <koeien37> no, EIndhoven is liberated in 1944
03:39:06 <koeien37> i thought not related to that operation
03:39:13 <mreh> it was temporarily liberated... then immediately recaptured
03:39:29 <koeien37> ah yeah, maybe
03:39:30 <Stalafin> now there we have a topic :D
03:40:04 <koeien37> I thought that was around Nijmegen/Arnhem, but apparently also here
03:40:06 <kosmikus> koeien37: if you like Haskell, you should consider http://www.utrechtsummerschool.nl/index.php?type=courses&code=H9
03:40:08 <mreh> Stalafin: fp is having a hard time getting into serious applications, which is a shame seeing as it makes everything a programmer needs to do so much easier
03:40:32 <kosmikus> so should everyone else, actually :)
03:40:33 <koeien37> kosmikus: I heard an ad about that last year, but I was afraid a little bit under my level
03:40:41 <mreh> 101st airborne went into Eindhoven, isn't that near Neun?
03:40:49 <koeien37> kosmikus: and I went to a different summer school on coding theory and algebraic geometry
03:40:51 <koeien37> Nuenen
03:40:56 <kosmikus> koeien37: ah, I see. which year are you in?
03:41:05 <koeien37> 2nd year MS in mathematics
03:42:31 <kosmikus> koeien37: last year, we had a number of excellent students in the advanced track of the summer school. but yes, I can't fully judge how much you know already. I don't want you to get bored.
03:42:40 <Stalafin> when calling openTempFile, what is the difference between passing it a "." or the result from getCurrentDirectory ?
03:42:47 <mreh> Van Gogh was born in Neunen
03:42:53 <koeien37> yes
03:42:53 <McManiaC> is there a reliable library that detects the mimetype of a file?
03:43:08 <quicksilver> well that's not possible, reliably.
03:43:51 <copumpkin> something that uses magic is probably the best you're going to do
03:43:53 <koeien37> mreh: Dijkstra also lived there for a while
03:43:55 <McManiaC> perl does a good job
03:44:10 <koeien37> Stalafin: I would think it doesn't make a difference
03:44:35 <quicksilver> McManiaC: you said 'reliably' not 'a good job'
03:44:41 <quicksilver> there is or was a haskell binding to libmagic
03:44:46 <quicksilver> which is I assume what you're talking about
03:45:32 <koeien37> Stalafin: unless, of course, the current directory suddenly changes between those two calls -- not going to happen if you don't use threads
03:45:35 <quicksilver> http://hackage.haskell.org/package/magic
03:46:03 <kosmikus> koeien37: if you know some other who might be interested in the summer school, please advertise :) last year, we had only few participants from .nl, most were from abroad.
03:46:35 <koeien37> in Eindhoven, most CS people seem to dislike it, sadly, and most mathematicians aren't interested in programming :)
03:47:07 <kosmikus> koeien37: most = all ?
03:47:21 <koeien37> well, there are a few exceptions, including me
03:47:42 <besiria> kosmikus: i'm thinking of applying for a MSc in Software Technology at UU
03:47:45 <koeien37> I think you might know another student from Eindhoven who started in UU last year or so
03:47:51 <Stalafin> koeien37: if you look at http://learnyouahaskell.com/input-and-output#hello-world (search for "The reason we used getCurrentDirectory") and read that short paragraph, i think you will find yourself as confused as me :D i think i should write the author
03:47:59 <maartenm> I went to Ugent in belgium and remember most students loved the FP class (which used haskell primarily)..
03:48:07 <besiria> kosmikus: and also attending summerschool. any opinions?
03:48:23 <koeien37> Stalafin: that is a pretty confusing sentence.
03:48:28 <kosmikus> koeien37: yes, I know one.
03:48:41 <Stalafin> kosmikus: that, and also... he never uses getCurrentDirectory
03:48:44 <Stalafin> oops
03:48:49 <Stalafin> koeien37: *
03:48:53 <Stalafin> evil name completion :p
03:48:54 <kosmikus> besiria: ah, nice. well, sounds like an excellent plan to me :) what do you want to know?
03:49:04 <koeien37> Stalafin: yeah, you might want to e-mail BONUS about this mistake :)
03:49:12 <koeien37> besiria: best university for FP in the Netherlands
03:49:16 <copumpkin> Stalafin: lucky for you he's in here :)
03:49:25 <Stalafin> copumpkin: he never says a word
03:49:25 <koeien37> preflex: seen BONUS
03:49:26 <preflex>  BONUS was last seen 15 hours, 34 minutes and 40 seconds ago, saying: <private message>
03:49:37 <copumpkin> Stalafin: sure he does, sometime
03:49:39 <copumpkin> s
03:51:04 <koeien37> besiria: although I don't know enough about the curriculum and other details
03:51:12 <besiria> kosmikus: what do i get except fp? other topics that are involved in this Msc?
03:52:28 <kosmikus> besiria: have you seen this? http://www.cs.uu.nl/wiki/bin/view/Master/BrochureSoftwareTechnology
03:53:12 <Stalafin> when doing openTempFile, is the file getting killed at the end of the program? or does it stay there?
03:53:56 <koeien37> Stalafin: the documentation says that you need to delete it manually
03:54:10 <Stalafin> thats actually cool
03:54:14 <copumpkin> there should be a withTempFile
03:54:16 <kosmikus> besiria: there's a list of topics for the master program there, plus further down a detailed overview of the curriculum which links to the course pages
03:55:39 <kosmikus> besiria: I'm going to be offline for lunch, but if you have any further questions, do not hesitate to ping/pm/mail me
03:56:24 <quicksilver> copumpkin: there is an example withTempFile implementation in RWH
03:56:38 <quicksilver> and there is (a private) one in Cabal, IIRC
03:56:44 <copumpkin> ah
03:56:49 <copumpkin> :t multiCont
03:56:50 <lambdabot> forall a r. [(a -> r) -> r] -> ([a] -> r) -> r
03:56:58 <besiria> kosmikus: wow thx for the link
03:59:09 <zygoloid> @type runCont . sequence . map Cont
03:59:10 <lambdabot> forall r a. [(a -> r) -> r] -> ([a] -> r) -> r
04:01:31 <copumpkin> with that and withTempFile you can write withTempFiles!
04:01:33 <copumpkin> :D
04:01:40 <copumpkin> zomg
04:02:32 <copumpkin> it'd still be nice to use forall to prevent handles (or pointers) from escaping
04:03:28 <koeien37> the trick ST uses?
04:03:47 <copumpkin> yeah
04:03:58 <Gracenotes> a tricky trick it tricks indeed
04:07:27 <copumpkin> you'd need a special API for working with the pointers and handles though
04:11:13 <McManiaC> quicksilver: this works better than Codec.MIME.Parse (whic doesnt work at all), but still gives me x-java for my .hs files whereas the perl script detects the correct x-haskell‚Ä¶
04:12:01 <andrewe> Is there a link for today's log?
04:12:55 <ivanm> andrewe: see the topic
04:13:12 <copumpkin> McManiaC: I wouldn't expect MIME.Parse to tell you the mime type of an arbitrary file
04:13:19 <copumpkin> but maybe
04:13:28 <andrewe> ivanm: I know that link, but i don't want to scroll all the way down each time.
04:13:44 <andrewe> ivanm: and the page is pretty long as well
04:13:55 <ivanm> andrewe: *shrug8
04:14:08 <McManiaC> copumpkin: well, I'm using magic now
04:14:18 <andrewe> ivanm: ???
04:14:20 <copumpkin> McManiaC: yeah, MIME.Parse parses mime type declarations
04:14:27 <McManiaC> ah okay
04:14:32 <copumpkin> McManiaC: the perl script almost definitely uses magic too
04:14:37 <copumpkin> so it should behave exactly the same way
04:14:40 <McManiaC> yes it does
04:14:42 <ivanm> andrewe: well, I can't do anything about your preference for non-scrolling
04:14:47 <McManiaC> but I get different results‚Ä¶
04:14:58 <ivanm> but may I point out to you the benefits of searching or ctrl-end ?
04:15:01 <Gracenotes> andrewe: bookmark http://tunes.org/~nef/logs/haskell/?C=M;O=D
04:16:20 <lbeew2000> I 'm trying to figure out how to get a link in html with Text.Html module
04:16:49 <lbeew2000> i'm trying link & href but they just give me HREF="bla" how can i make Html out of this
04:17:17 <McManiaC> I prefer HSP over Text.XHtml
04:18:19 <lbeew2000> but do you know how i would go about doing this
04:19:36 <McManiaC> tried thelink?
04:20:01 <McManiaC> oh, and use at least Text.XHtml please
04:20:02 <McManiaC> :D
04:20:19 <koeien37> that's probably a <LINK> tag
04:20:24 <lbeew2000> that just gives <LINK>
04:20:41 <doserj> lbeew2000: anchor?
04:20:41 <lbeew2000> i want <a href="url">go to url</a>
04:20:52 <lbeew2000> it might be the function i am looking for
04:20:54 <McManiaC> hmmm
04:21:03 <ivanm> preflex: seen dons
04:21:04 <preflex>  dons was last seen on #haskell 11 days, 10 hours, 44 minutes and 19 seconds ago, saying: no serious haskell program needs hlist.
04:21:11 <koeien37> try (anchor (... the inner html ... ) ! [href "example.org"])
04:21:13 <McManiaC> address?
04:21:19 <ivanm> @ask dons what's with the URL shorteners for your latest haskell reddit posts?
04:21:19 <lambdabot> Consider it noted.
04:22:03 <lbeew2000> that works thx
04:24:24 <koeien37> I prefer XHTML too, but there are some disadvantages
04:24:32 <copumpkin> ivanm: probably because they've already been submitted and reddit won't allow it
04:24:40 <ivanm> ahhhh
04:24:42 <copumpkin> I wonder why no serious haskell program needs hlist
04:24:55 <b_jonas> what's "hlist"?
04:25:00 <koeien37> heterogeneous lists
04:25:02 <copumpkin> I can see it being useful for relational database interfaces
04:26:06 <copumpkin> I wrote heterogeneous vectors in agda but sadly couldn't figure out how to define them independently of regular vectors (it'd be nice to have a vector that could act as either)
04:26:07 <quicksilver> copumpkin: happs does, I think
04:26:28 <quicksilver> copumpkin: (or it uses something isomorphic to a subset of hlist, maybe)
04:26:37 <copumpkin> ah
04:28:14 * ketil wonders: shouldn't Data.Map's insertWith etc be replaced with something using Monoid?
04:28:28 <ivanm> @type insertWith
04:28:30 <lambdabot> Not in scope: `insertWith'
04:28:33 <ivanm> @hoogle insertWith
04:28:34 <lambdabot> Data.IntMap insertWith :: (a -> a -> a) -> Key -> a -> IntMap a -> IntMap a
04:28:34 <lambdabot> Data.Map insertWith :: Ord k => (a -> a -> a) -> k -> a -> Map k a -> Map k a
04:28:34 <lambdabot> Data.Map insertWith' :: Ord k => (a -> a -> a) -> k -> a -> Map k a -> Map k a
04:28:35 <copumpkin> ketil: that would be cute
04:28:45 <b_jonas> ketil: monoid?
04:28:47 <copumpkin> ketil: maybe not replaced, but at least augmented
04:28:49 <ivanm> ketil: I'm not following; where would using Monoid get you?
04:29:00 <quicksilver> well it's not very hard to write "insertWith mappend"
04:29:02 <ketil> copumpkin, and I think it's what you usually want.
04:29:07 <b_jonas> oh, map's insertWith
04:29:08 <quicksilver> :t Data.Map.insertWith mappend
04:29:09 <lambdabot> forall a k. (Monoid a, Ord k) => k -> a -> M.Map k a -> M.Map k a
04:29:13 <b_jonas> that's like the accumulate things in the arrays
04:29:13 <ketil> quicksilver, true, I guess.
04:29:14 <quicksilver> you can give it a name if you like :)
04:29:40 <copumpkin> thank you!
04:29:42 <quicksilver> superCoolMagicInsert = insertWith mappend
04:29:43 <ivanm> ahhh, I get you now
04:29:47 <b_jonas> well Foldable or whatsit has both monoid-based functions and ones using explicit reducer callbacks, right?
04:29:55 <quicksilver> although that's actually more characters to type.
04:29:57 <ketil> I generally use insertWith (flip (++)), because (I think) it is more efficient.
04:30:33 <ivanm> ketil: why, what order does it use?
04:30:40 <ivanm> original -> new -> updated ?
04:30:48 <ivanm> if so, then yeah, flip (++) is probably more efficient
04:31:03 <ivanm> using Data.Seq or DList would probably be even better ;-)
04:31:09 <ketil> ivanm: the wrong one :-)  I'm fairly sure I measured this once upon a time,and that flip (++) was better.
04:34:16 <b_jonas> I think you all got me interested in haskell again. I'll blame this channel if I'll actually work with haskell and I have difficulties.
04:35:21 <ivanm> heh
04:35:53 <b_jonas> I always figure out how inconvenient any language is if I work with it a lot
04:36:08 <b_jonas> that's why I'm planning to rewrite cbstream in anything but ruby
04:36:32 <b_jonas> in the now three years of maintaining it (well I dind't do too much with it in last year than hotfixes) I got to hate some parts of ruby
04:36:40 <b_jonas> but I still have to admit ruby was the good decision
04:36:57 <b_jonas> it has the threading done well with a good library
04:38:17 <dblick> Hm.. Poking around in http://fleet.cs.berkeley.edu/code.html I ran across what looks a lot like a Haskell in Java?  It's a file called HSbase.jar with a lot of haskell-named class files.  There aren't any good Haskell implementations for the JVM, are there?  (I'm wondering where this thing came from...)
04:38:43 <ivanm> no, there aren't AFAIK
04:39:04 <copumpkin> there were projects on it
04:39:07 <copumpkin> but they bitrotted
04:39:57 <ivanm> dblick: maybe I'm looking in the wrong spot, but I don't see anything haskelly...
04:40:01 <dblick> http://git.megacz.com/?p=fleet.git;a=tree;f=lib;h=bb055ff04b3d6549fbe55f2c669a95008420f315;hb=HEAD
04:40:24 <ivanm> yup, looked int he wrong spot ;-)
04:40:48 <dixie> is something like hoogle for java?
04:40:56 <copumpkin> I doubt it
04:41:12 <dixie> I'll check #java
04:41:14 <ivanm> dixie: yes, I saw something about it on proggit the other day
04:41:16 <copumpkin> types don't really mean as much in java as they do in haskell
04:41:18 <copumpkin> oh yeah?
04:41:29 <ivanm> copumpkin: actually, IIRC one of ndm's original goals with hoogle was to get it working with java...
04:41:50 <copumpkin> it still seems a lot less useful
04:41:56 <dixie> of course it probably is not as usable as java, but can be useful
04:42:13 <ivanm> dblick: yeah, there's a "GHC" subdirectory
04:42:22 <ivanm> so it appears to be at least a partial conversion of haskell into java
04:42:28 <koeien37> gotapi.com exists
04:42:43 <ivanm> docjar.com looks relevant
04:44:53 <lpsmith> Anybody familiar with "Naperian idioms"?
04:45:09 <lpsmith> Section 3.1 of this paper seems pretty opaque to me:  http://web.comlab.ox.ac.uk/publications/publication1417-abstract.html
04:50:16 <mreh> :t integral
04:50:17 <lambdabot> Not in scope: `integral'
04:55:18 <lpsmith> So what's the relationship between Monads and Applicative Functors?     Every monad is in some sense a applicative functor,  but can you express any monadic computation using solely the applicative interface?
04:55:34 <koeien37> no.
04:55:46 <ivanm> lpsmith: monad = applicative + >>=
04:55:49 <ivanm> @where typeclassopedia
04:55:49 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
04:55:51 <ivanm> lpsmith: ^^
04:56:05 <copumpkin> lpsmith: monad = applicative + join, I'd say
04:56:08 <lpsmith> yeah,  I've read large parts of it
04:56:10 <koeien37> there is no join in APplicative
04:56:22 <koeien37> you can't write Applicative f => f (f a) -> f a
04:56:31 <ivanm> copumpkin: well, you can define join in terms of >>= and return and vice versa, can you not?
04:56:43 <koeien37> join f = f >>= id
04:56:51 <copumpkin> ivanm: sure, but you can define fmap in terms of those too. join is "linearly independent from the existing stuff"
04:57:03 <ivanm> copumpkin: hmmm?
04:57:05 <copumpkin> if you know what I mean :)
04:57:05 <ivanm> @src join
04:57:05 <lambdabot> join x =  x >>= id
04:57:10 <koeien37> yeah i get you :)
04:57:19 <ivanm> just as koeien37 said; as such I don't see it being independent... ;-)
04:57:25 <ivanm> (so no, I don't get you)
04:57:42 <copumpkin> ivanm: join is the least additional method you can add to get a monad. >>= gives you join and duplicates a bunch of other stuff too
04:57:47 <ivanm> hmmm... can you write (>>=) in terms of join?
04:57:54 <copumpkin> sure
04:57:59 <copumpkin> join is the categorical definition of a monad
04:58:02 <ivanm> copumpkin: what else does it duplicate?
04:58:02 <koeien37> you will need fmap.
04:58:12 <copumpkin> along with pure and ap
04:58:21 <ivanm> koeien37: well, if you have applicative you have fmap do you not?
04:58:24 <copumpkin> ivanm: you can get fmap and <*> out of it and return too
04:58:28 <koeien37> ivanm: yes, you do, correct
04:58:32 <ivanm> copumpkin: :o
04:58:39 <koeien37> but join is a little bit purer imo. it's stylistic
04:58:46 <ivanm> copumpkin: I know you can get fmap aka liftM out of bind...
04:58:59 <copumpkin> >>= id is join
04:59:05 <lpsmith> how can something that's purely stylistic be any "purer"?  :)
04:59:08 <copumpkin> @src ap
04:59:08 <lambdabot> ap = liftM2 id
04:59:15 <koeien37> lpsmith: "pure" not in a technical sense
04:59:26 <quicksilver> lpsmith: monadic computations can vary their computational behaviour based on intermediate results
04:59:44 <quicksilver> lpsmith: applicative computations are 'pre-wired' ; their computational behaviour is fixed and the results are "only" collected.
04:59:47 <koeien37> m >>= (\x -> if x then return 1 else return 2)
05:00:02 <copumpkin> ivanm: all I'm saying is that Applicative already has fmap, pure, and <*> by definition. Adding join doesn't duplicate work, but (>>=) gives you fmap again (in a different way) and <*>
05:00:02 <koeien37> although this is not a good example
05:00:08 <andrewe> ivanm: it's all about usability, I wrote myself a small bookmarklet (see http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15580#a15580 ) which can be used with firefox, it saves loading a 400k webpage and scrolling down all the way. Maybe someone finds it useful as well.
05:00:45 <ivanm> copumpkin: how do you get >>= from join?
05:00:46 <andrewe> disclaimer: works on my computer (TM)
05:00:59 <copumpkin> x >>= f = join (fmap f x)
05:01:26 <ivanm> andrewe: I generally only want logs for two reasons: 1) I grep the logs on my own machine to see who said something to me and when; 2) google returns them when looking for stuff
05:01:27 <lpsmith> quicksilver:  that's what the paper I'm reading at the moment referrs to in passing,  any good examples?
05:01:32 <copumpkin> works on my computer (LBA)
05:01:39 <ivanm> @wn LBA
05:01:41 <lambdabot> No match for "LBA".
05:01:50 <copumpkin> just being really stupid, sorry
05:01:55 <ivanm> heh
05:02:06 <ivanm> OK, I get how that works
05:02:12 <ivanm> @type (<*>)
05:02:12 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
05:02:19 <quicksilver> lpsmith: well, in the IO applicative you can't change what is printed to the screen (or a file) based on the results of earlier actions
05:02:20 <ivanm> what's that? ap?
05:02:22 <ivanm> @type ap
05:02:23 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
05:02:26 <copumpkin> yep
05:02:42 <ivanm> OK, I get your point now I think
05:02:43 <quicksilver> lpsmith: all you can do is run an intuitively "fixed" set of actions and collect (== do something pure) with their results.
05:03:08 <lpsmith> copumpkin:  surely adding join to fmap,  pure,  and <*>  "duplicates" work somehow,  as the categorical definition of a monad is just fmap, pure, and join
05:03:29 <copumpkin> lpsmith: yeah, but we don't have a distinct pointed class
05:03:44 <quicksilver> lpsmith: in do notation, this means that you can't use "<-" except if all you ever do with the bound value is feed it to return (and possibly a pure function)
05:04:25 <ivanm> copumpkin: though didn't byorgey propose one in the typeclassopedia?
05:04:41 <copumpkin> can't remember, but otherwise we can just grab one from category-extras
05:04:55 <copumpkin> class (Functor f) => Pointed f where pure :: a -> f a
05:05:10 <copumpkin> the functor superclass isn't strictly necessary either
05:08:24 <b_jonas> but the question is, is there a point to that? do we actually use any pointed that aren't applicatives?
05:08:36 <sohum> @pl \(a,_) -> f a
05:08:36 <lambdabot> f . fst
05:10:26 <sohum> @pl \(a,_) k -> f a k
05:10:26 <lambdabot> f . fst
05:11:15 <b_jonas> and I can't think when you'd ever want to use specifically pointed instead of applicative or functor
05:12:35 <koeien37> i have a large file that i want to read in efficiently. I want to use Data.Text. What is the most efficient way?
05:12:56 <koeien37> ah never mind, I can't read.
05:12:59 <copumpkin> lol
05:13:31 * koeien37 totally ignored Data.Text.IO for a while in the listing on hackage
05:13:32 <lpsmith> copumpkin:   mf <*> mx = fmap (\f -> fmap (\x -> pure (f x)) mx) mf
05:13:42 <lpsmith> err
05:13:48 <lpsmith> forgot some joins in there
05:13:50 <lpsmith> but there you go
05:14:07 <copumpkin> yep
05:15:07 <mchase> Can anyone help me with this cabal error? http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=15581#a15581
05:15:23 <mchase> I'm trying to "cabal install fastcgi"
05:15:29 <copumpkin> lpsmith: that's basically the expanded version of ap in monads
05:15:37 <luqui> wow just got out of a clusterfuck in #math
05:15:38 <lpsmith> right
05:15:43 <lpsmith> lol
05:15:48 <lpsmith> how so?
05:15:50 <copumpkin> a fustercluck?
05:15:52 <luqui> bunch of assholes. i know why people come here for math help.
05:16:09 <Jafet> I can piss you off here too!
05:16:11 <b_jonas> luqui: does that work?
05:16:14 <lpsmith> hahaha,  we are good at some kinds of math.   Other kinds... well...
05:16:18 <ivanm> mchase: :o
05:16:23 <ivanm> mchase: which OS are you using?
05:16:33 <ivanm> oh, and which version of cabal-install is this?
05:16:39 <luqui> it worked a couple days ago
05:16:39 <mchase> ivanm: windows
05:16:44 <ivanm> thought so
05:16:48 <luqui> someone came here for math help and got reluctant helpful advice
05:16:51 <copumpkin> luqui: did they correct your question in a derisive manner before telling you it wasn't on-topic?
05:17:16 <koeien37> well, there are quite some idiots joining #math, more than #haskell
05:17:16 <mchase> cabal-install version 0.6.4 using version 1.6.0.3 of the Cabal library
05:17:22 <koeien37> but i stopped frequenting it some time ago
05:17:26 <luqui> copumpkin, no it wasn't my question.  i was trying to help another person by giving less abstract versions of what the other guy was saying.
05:17:27 <copumpkin> me too
05:17:29 <luqui> and then told i was dumb.
05:17:35 <copumpkin> luqui: duh
05:17:45 <ivanm> IIRC, cabal 1.6 used the shell-based run function rather than the non-shell-based one
05:17:50 <ivanm> and that appears to be your problem
05:17:52 <ivanm> mchase: ^^
05:18:14 <ivanm> mchase: any chance of you updating to cabal-install-0.8.0 ?
05:18:22 <mchase> is there another version of cabal i should be using?
05:18:42 <ivanm> try cabal-install 0.8.0
05:18:43 <lpsmith> I like examples.   Teaching shouldn't consist solely of examples,  but having one or two well-chosen examples to hold on to sure does make more abstract presentations a lot easier
05:18:53 <ivanm> cabal update && cabal install cabal-install --reinstall
05:19:02 <ivanm> mchase: ^^ something like that; not sure if the --reinstall bit is correct
05:19:03 <mchase> what's the relationship between cabal and caball-install?
05:19:18 <damd> they both share the same prefix
05:19:32 * quicksilver snickers at the irony of #math telling luqui that he is dumb.
05:19:32 <ivanm> mchase: CABAL is the Common Architecture for Building Applications and Libraries, and is a library that specifies how to build a haskell project from a textual description
05:19:43 <lpsmith> cabal handles building,  configuration,  package registration and tracking,  etc
05:19:50 <luqui> quicksilver, :-)
05:19:50 <ivanm> cabal-install adds a nicer command line interface, dep resolution, automatic doc building, etc.
05:20:00 <lpsmith> cabal install fetches cabal packages off the web,   tracks down dependences,  yeah,  what ivanm said
05:20:13 <lpsmith> though the automatic doc building makes me want to stick needles in my eyes
05:20:23 * ivanm should probably store that description in an auto-replace somewhere
05:20:30 <ivanm> I've given it about 4 times in the past week IIRC
05:20:36 <ivanm> lpsmith: oh? how come?
05:20:46 <ivanm> it is configurable, so you can just disable it in ~/.cabal/config ...
05:20:53 <koeien37> yeah! my file is not being mangled anymore by GHC \o/
05:21:11 <copumpkin> most IRC is full of people who desperately need to make themselves feel smart, often at other people's expense
05:21:15 <ivanm> quicksilver: since I obviously don't know luqui as well as you do, is there a specific reason for the irony?
05:21:23 <ivanm> copumpkin: yeah, you stupid loser
05:21:23 <ivanm> :p
05:21:24 <lpsmith> haddock is tied to a particular version of GHC,  so building automatically doesn't work very well if you have multiple versions of GHC floating around
05:21:24 <mchase> thanks for your help.  i'll try reinstalling.
05:21:39 <Zao> koeien37: Hooray!
05:21:39 <ivanm> lpsmith: yeah, but most people stick with a single GHC install
05:21:48 <lpsmith> I'd like to --hyperlink-source by default, but AFAICT,   I can't do that
05:21:55 <koeien37> Zao: yeah, for some reason it "somewhat" worked, but not completely
05:22:00 <ivanm> lpsmith: though IIRC, they're starting to un-tie haddock from GHC (they use an internal doc parser now IIRC)
05:22:09 <lpsmith> heh
05:22:15 <lpsmith> Haddock used to not be tied to GHC
05:22:25 <ivanm> lpsmith: right, there's some bugs for that; IIRC the problem is people can't agree on what the command line incantation for that should be ;-)
05:22:30 <lpsmith> the tying to a particular version is a relatively new phenomenon
05:22:35 <ivanm> since 2.0
05:22:47 <ivanm> I think its because their internal parser sucked
05:22:55 <copumpkin> ivanm: exactly :) and you clearly belong in #math
05:22:57 <ivanm> maybe they should switch to haskell-src-exts or something
05:23:14 <koeien37> does that parse comments?
05:23:21 <ivanm> (which brings in recursion problems if you want to build haskell-src-exts with documentation on a clean install of ghc...)
05:23:32 <copumpkin> koeien37: pretty sure it does
05:23:41 <lpsmith> ivanm:  well, that and they wanted the ability to infer types and still produce haddock documentation for a function without an explicit type definition
05:23:45 <koeien37> ok cool. obviously quite important for Haddock
05:23:47 <ivanm> koeien37: well, their new one does the comment parsing internally IIRC, they just use ghc for the type, etc. I think
05:23:47 <copumpkin> there are only a couple of things it doesn't support
05:24:02 <ivanm> lpsmith: oh? I don't recall type inference ever working in haddock...
05:24:02 <copumpkin> one of them is unicode syntax
05:24:04 <koeien37> yeah, /me was bitten by lack of support for GADTs in Haddock some time ago
05:24:17 <koeien37> probably/maybe fixed now
05:24:33 <lpsmith> well, that was part of the justification for using the GHC api,  but I don't think they've gotten that far (yet?)
05:24:34 <ivanm> I think GADTs are supported
05:24:39 <ivanm> the latest bug-bear is associated types
05:24:55 * ivanm really wishes haddock had a *bold* markup specifier rather than just /italics/
05:25:29 <sohum> @pl \a b -> f (g a b)
05:25:30 <lambdabot> (f .) . g
05:25:34 <ivanm> I know some people have proposed using pandoc and having full markdown support for haddock markup, but I think that's a bit of overkill
05:25:54 <lpsmith> ehh, why not?
05:25:57 <koeien37> markdown isn't that complicated, is it?
05:26:48 <Axman6> nope
05:27:39 <Baughn> ..whatever possessed me to use md5sum /dev/random for all my passwords? ;_;
05:27:53 <koeien37> apg!
05:28:03 <Axman6> ....
05:28:26 <kowey> I'd like to call a 3rd party program, write stuff to it; read stuff back (shunt the err stuff to stderr), but I get mystery hanging with my runInteractiveCommand
05:28:27 <Jafet> Hmm, I use cat | sha1sum
05:28:37 <kowey> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15582#a15583 <-- any suggestions?
05:28:52 <Axman6> Jafet: 40 char passwords?
05:29:21 <Jafet> Well, I put it in a script. That hides terminal echo. And takes the first 20.
05:29:43 <koeien37> you are only using a small alphabet with that
05:30:02 <koeien37> not that this matters with 20 characters, but I like my full range 0..9 A-Z a-z
05:30:33 <Jafet> > 16^20
05:30:34 <lambdabot>   1208925819614629174706176
05:30:44 <Jafet> So um, haskell
05:30:59 <koeien37> kowey: the evaluate (length err) might never be evaluated?
05:31:53 <koeien37> hmm.
05:32:04 <kowey> koeien37: hmm, I took it out in my edit because I thought it was superfluous given my ePutStrLn (which is hPutStrLn stderr)
05:32:23 <koeien37> yeah, i'd think so too
05:33:26 <quicksilver> kowey: mystery hanging is normally caused by misunderstanding system buffering occasionally compounded by lazy interleaved IO hiding the problem a bit
05:35:09 <kowey> quicksilver: thanks, that's useful for long term grappling with other mystery hanging
05:35:10 <osfameron> or lazy unleavened IO during Passover
05:35:14 <koeien37> how evil is this?    dict = unsafePerformIO $ T.lines <$> TIO.readFile "dict.txt"
05:35:44 <copumpkin> koeien37: not terribly evil
05:35:54 <quicksilver> koeien37: well, the proof obligation is that you don't care how many times "dict.txt" is read, or if it is read at all.
05:36:14 <koeien37> I would prefer it to be read once, but I know that the result is the same (it won't be altered)
05:36:16 <quicksilver> that's probably a close approximation to true, so this is probably a close approximation to not evil.
05:36:18 <copumpkin> koeien37: making an international dictionary
05:36:24 <copumpkin> ?
05:36:35 <koeien37> copumpkin: ehm, something like that, yes
05:36:48 <koeien37> i have a list of chinese characters and i want to query some things
05:36:49 <kowey> quicksilver: any tips on where I could learn enough about system buffering to crawl out of this mess?
05:36:57 <koeien37> chinese words, rather
05:37:10 * Axman6 dislikes using unsafePerformIO for anything other than FFI bindings
05:37:27 <copumpkin> Axman6: how would you keep a static dictionary?
05:37:29 <kowey> I only operate on the level of "oh, don't want buffering there" and using hFlush as voodoo
05:37:42 <copumpkin> Axman6: considering that GHC doesn't like static data encoded in a source file
05:38:02 <Axman6> reading it in and passing it around? i dunno
05:38:44 <luqui> copumpkin, should be able to link it in
05:38:48 <copumpkin> you could build it into an object file and ffi it in
05:38:49 <copumpkin> yeah
05:39:18 <koeien37> I guess I might do that if it's necessary performance-wise. The haskell-cafe had a thread on that some time ago
05:39:41 <koeien37> the file is quite large, but I might turn it into a FastCGI or other long-running process
05:41:13 <sohum> @pl \k -> s ++ (f a k)
05:41:14 <lambdabot> (s ++) . f a
05:48:58 <o-_-o> Gracenotes,
05:49:15 <copumpkin> Gracenotes,
05:49:57 <Gracenotes> you have summoned me
05:50:17 <o-_-o> sorry are you the one associated with GPUgen ?
05:50:23 <Gracenotes> (normally you must say my name three times before I appear, but I am feeling lenient)
05:50:33 <Gracenotes> no, I am not
05:50:39 <o-_-o> ok
05:50:41 <copumpkin> o-_-o: you mean ChilliX or TacticalGrace ?
05:50:47 <o-_-o> ah...write
05:50:48 <copumpkin> (who happen to be the same person)
05:50:51 <o-_-o> s/write/right
05:51:01 <Gracenotes> hm. Sounds interesting though. generating.. assembly?
05:51:21 <o-_-o> right, yes both of them have grace in their names
05:51:54 <o-_-o> I think they generate CUDA
05:52:00 <o-_-o> not assembly
05:52:07 <copumpkin> Gracenotes: there's no nice way of generating GPU assembly directly
05:52:12 <copumpkin> it's frustrating
05:52:30 <copumpkin> or even indirectly, or through anything but their text-based language as far as I know
05:52:50 <copumpkin> I can understand why assembly isn't allowed, but not having to go through text would be nice
05:53:45 <o-_-o> has learning haskell made anyone better at their job or contributed in anyway ?
05:54:15 <o-_-o> I am having a lot of fun learning it, but I am not sure if it help or even how.
05:54:17 <Adamant> o-_-o: it's reinforced existing prejudices about my job and hasn't made me any worse
05:54:25 <o-_-o> Adamant, lol
05:54:42 <ketil> o-_-o, Learning Haskell has made my job more fun.
05:54:57 <o-_-o> ketil, what work do you do ?
05:55:22 <ketil> o-_-o, oh, you know, stuff.
05:55:44 <o-_-o> I asked my boss if I could devote 20% of my time to learn haskell, he asked what is in it for him.
05:55:45 <ketil> bioinformatics - I try to help biologists sort out their data.
05:55:52 <o-_-o> ok
05:56:23 <ketil> o-_-o, he'll get more creative and satisfied employees?
05:56:37 <o-_-o> ketil, hahaha..
05:56:46 * o-_-o wipes tears away
05:56:49 <quicksilver> he'll have 20% of the time free of your annoying interruptions?
05:56:53 <quicksilver> ;)
05:57:17 <o-_-o> I work for someone from the dilbert cartoons
05:58:27 <o-_-o> oh...well from business reality perspective, I am trying to see if one can justify learning haskell
05:58:47 <koeien37> not really, I suppose
05:59:20 <o-_-o> my argument that when multi-core systems become common, then everyone will be forced to learn something like haskell didn't fly well...
05:59:29 <eevar2> o-_-o: think you're better off studying medicine or whatever, programming as a hobby
06:00:02 <o-_-o> eevar2, :-)
06:00:21 <o-_-o> eevar2, nah...I got to pay the bills
06:00:55 <ivanm> o-_-o: you work for a fictional character? :o
06:01:07 <medfly> just do it on your free time?
06:01:16 <medfly> most people don't get paid to learn things :/
06:01:35 <o-_-o> medfly, I know :-(
06:01:58 <o-_-o> but learning haskell is the most amazing thing I've done in a loooooooong time
06:02:30 * hackagebot upload: SHA2 0.2.0 - Fast, incremental SHA hashing for bytestrings (SveinOveAas)
06:02:32 * hackagebot upload: SHA2 0.2.1 - Fast, incremental SHA hashing for bytestrings (SveinOveAas)
06:02:36 <o-_-o> I mean learning wise, last I had this much fun, was my undergraduate final project
06:02:36 <koeien37> heh
06:03:42 <copumpkin> jaspervdj: I think there's a typo in your latest blog post
06:04:09 <medfly> oh no, the horror
06:04:40 <xerox> haha
06:05:35 <ivanm> wow, that was a fast bugfix...
06:07:23 <ivanm> @hackage SHA2
06:07:23 <lambdabot> http://hackage.haskell.org/package/SHA2
06:25:20 <mux> that's great: http://hackage.haskell.org/trac/ghc/ticket/650#comment:24
06:27:21 <quicksilver> mux: it's terrible! It wil encourage people to use mutable arrays instead of more right, proper, and holy structures! ;)
06:27:45 <mux> heh
06:28:47 <medfly> what do you mean, I can use mutable arrays? all my Haskell problems are solved! I'm going to use them all the time now!
06:30:06 <luqui> everyone knows that all imperative solutions are faster than all functional solutions
06:30:19 <copumpkin> damn right
06:30:26 <damd> why would anyone step out of the IO monad ever?  i don't see the point.
06:30:52 <copumpkin> I only live in the IO functor myself
06:31:02 <copumpkin> don't need all that newfangled join or return shit
06:31:11 <luqui> if you never go out of the IO monad, all you can do is return constants.
06:31:19 <luqui> and print constants, etc.
06:31:23 <b_jonas> damd: optimize stuff
06:36:42 <McManiaC> why does Magic gives me x-java for haskell files =(
06:37:29 <copumpkin> I didn't think magic knew programming languages
06:37:53 <copumpkin> for me file x.hs just says "ASCII text"
06:38:15 <Lemmih> McManiaC: Haven't you noticed that Haskell looks an awful lot like Java? I'm using Haskell at my Java job for precisely that reason.
06:38:23 <copumpkin> lol
06:38:50 <McManiaC> 15:37 nils ` file MimeTest.hs
06:38:50 <McManiaC> MimeTest.hs: ASCII Java program text
06:38:56 <luqui> class, in[terface/stance], if, else, it's all there!
06:39:04 <McManiaC> lol yeh
06:39:37 <copumpkin> my magic file must not be up to date
06:39:39 <araujo> that is done on purpose, so managers can't see the whole app is haskell written instead
06:39:53 <medfly> haha
06:39:55 <McManiaC> hehe
06:39:56 <medfly> that's funny :)
06:42:53 <McManiaC> copumpkin: what operating system are you using?
06:43:09 <luqui> let me guess, solaris
06:43:22 <luqui> er wait, i transposed who was asking the question and who was being asked
06:43:39 <luqui> it was funny the other way...
06:43:55 <McManiaC> very
06:43:56 <McManiaC> :P
06:44:16 <zygoloid> hah, i just ran 'file' on some haskell files i have lying about. file said 43 were Java, 34 were ASCII text, 10 were C++, 1 was "ASCII text with very long lines", 1 was Lisp/Scheme and 1 was FORTRAN (!)
06:44:24 <luqui> i was once told that i should become funny then become a mathematical comedian :-P
06:44:44 <McManiaC> zygoloid: lol
06:46:00 <copumpkin> McManiaC: mac os :)
06:46:06 <copumpkin> 10.5, maybe it's better in 10.6
06:46:21 <copumpkin> I don't really care that much about having programming languages in my magic though
06:46:27 <copumpkin> I usually use it on unknown binary files
06:52:44 <copumpkin> HaskellLove: that problem is hard in any language
06:52:51 <copumpkin> (discovering shapes in an image)
06:53:10 <Axman6> it's just a hard problem for computers in general really....
06:53:24 <copumpkin> HaskellLove: the best you're probably going to do is called the generalized hough transform
06:53:26 <luqui> those two statements are isomorphic
06:53:44 <copumpkin> it's a pretty simple idea and amounts to brute force, sort of :P
06:54:35 <copumpkin> luqui: I need a proof object
06:55:40 <copumpkin> omg an edwardk
06:56:03 * edwardk hides before the mob catches him.
06:56:58 * edwardk looks somewhat askance at himself.
06:57:08 <copumpkin> Mob! Split up! Half of you follow me and we'll go after edwardk and the other half should go after edwardk1
06:57:11 <Axman6> will the real edwardk please stand up??? :o
06:57:11 <luqui> copumpkin, trivial given the lemma  {A‚ÇÅ A‚ÇÇ : Set}{R‚ÇÅ : Rel A‚ÇÅ}{R‚ÇÇ : Rel A‚ÇÇ}
06:57:12 <luqui>          {P‚ÇÅ : EdgePred R‚ÇÅ}{P‚ÇÇ : EdgePred R‚ÇÇ}{a b : A‚ÇÅ}{xs : Star R‚ÇÅ a b}
06:57:12 <luqui>          {i : A‚ÇÅ -> A‚ÇÇ}{f : R‚ÇÅ =[ i ]=> R‚ÇÇ} ->
06:57:12 <luqui>          ({a b : A‚ÇÅ}{x : R‚ÇÅ a b} -> P‚ÇÅ x -> P‚ÇÇ (f x)) ->
06:57:12 <luqui>          Any P‚ÇÅ xs -> Any (\{a b} -> P‚ÇÇ{a}{b}) (map i f xs)
06:57:26 <copumpkin> aha, obviously
06:57:30 <xerox> :O
06:57:57 * edwardk tries to stand up, but then realizes that he twinged his back a few days ago and settles back into his chair.
06:58:01 <jaspervdj> copumpkin: I'm sorry, I was ask, what's the typo?
06:58:12 <jaspervdj> s/ask/afk/
06:58:15 <copumpkin> jaspervdj: return $ Just (...)
06:58:20 <copumpkin> jaspervdj: that's two levels of Justness
06:58:26 <copumpkin> and two justs make an injustice
06:58:47 <edwardk> luqui: obviously... er... yeah.
06:59:07 <jaspervdj> copumpkin: well, the getMonth function would be a pure function
06:59:23 <copumpkin> jaspervdj: yeah, but you're putting two levels of Maybe in
06:59:45 <luqui> edwardk, I saw your monoids talk just in time.  I just started thinking about an frp incarnation revolving around monoids.
06:59:54 <copumpkin> the return for Maybe is Just, and then you write Just in by hand
06:59:56 <luqui> then i remembered your talk :-)
07:00:08 <jaspervdj> copumpkin: erm, year, right :-)
07:00:16 <jaspervdj> copumpkin: I'll edit it
07:00:23 <luqui> not really frp.  that was the motivation.  it's really just integrals over monoids.
07:00:32 <copumpkin> jaspervdj: it boils down to return . getMonth <=< parseDate <=< lookup "path" too :)
07:01:09 <edwardk> luqui: oh?
07:01:52 <edwardk> luqui: well, conal uses monoids in several places in reactive, but i think that is a bit different than what you mean =)
07:02:16 <luqui> edwardk, yeah.  integrable monoid is a continuous function f : R -> M where M is some monoid, s.t. f(0) = mempty
07:02:34 <copumpkin> integrable monoid is integrable
07:02:51 <luqui> then do a riemann integral on g : R -> (R -> M)
07:03:08 <edwardk> luqui: i have differentiation defined in an older version of the monoids lib
07:03:41 <luqui> edwardk, oh yeah!?  could it be generalized to weak differentiation; i.e. finding derivatives when all you have is an integral function?
07:03:51 <luqui> edwardk, or... regardless, what is it?
07:03:51 <jaspervdj> copumpkin: I'll put that in a footnote
07:04:08 <copumpkin> jaspervdj: it might not actually be correct but I think it is :)
07:04:10 <edwardk> pulling it up one sec
07:04:15 <copumpkin> I haven't actually tested it
07:04:25 <edwardk> http://hackage.haskell.org/packages/archive/monoids/0.1.36/doc/html/Data-Ring-Module-AutomaticDifferentiation.html
07:04:41 <copumpkin> oh my
07:05:04 <stepcut> anyone know if quickcheck 2 builds under 6.8?
07:05:09 <edwardk> generalized AD
07:05:18 <copumpkin> nice :)
07:05:28 <luqui> you use so much damn abstraction!
07:05:35 <edwardk> i dropped it in 0.2 when i was trying to refine the package down to just monoids
07:05:48 <edwardk> but i was planning on bringing it back in a ring(oid) package
07:05:57 <edwardk> luqui: hahaha
07:06:22 <edwardk> luqui: i suppose there isn't much concreteness to that example
07:06:47 <luqui> i'm going to say... n
07:06:48 <luqui> o
07:06:48 <edwardk> but you can use the bimodule instances: http://hackage.haskell.org/packages/archive/monoids/0.1.36/doc/html/Data-Ring-Module.html#t%3ABimodule
07:06:48 <copumpkin> edwardk: it's hard to tell what the three type parameters to D mean
07:07:09 <luqui> s is a region variable for one
07:07:12 <copumpkin> yeah
07:07:17 <kowey> stepcut: darcs uses QC 2.1 and tries to support GHC 6.8
07:07:25 <edwardk> r is the ring over which the monoid m forms a module. s is a type level brand to keep you from mixing up your infinitesimals
07:07:57 <edwardk> ring is used loosely because it doesn't require both distributive laws iirc
07:07:59 <copumpkin> data Gucci
07:08:15 <xerox> edwardk do you have code for jordan form there? :)
07:08:35 <luqui> edwardk, that's interesting, using a monoid as the infinitesimal unit.  i'll have to think about that.
07:08:40 <edwardk> xerox: nah =)
07:08:54 <xerox> :( that's the only thing about modules I've seen
07:09:24 <en0th> I've written a module to wrap some of System.Console.ANSI text style functionalities, allowing i.e. quick coloured text output: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5939  I don't know if it could be useful. Anyway, any suggestion/comment is welcome ..
07:09:34 <stepcut> kowey: spiffy. I am going to update happstack then. QC1 does not seem to work with 6.13 :-/
07:09:45 <stepcut> 6.13 doesn't have base 3 anymore I guess...
07:09:47 <copumpkin> wow, two very different notions of modules in adjacent IRC messages
07:10:35 <en0th> yes.. sorry for that :(
07:10:46 <copumpkin> en0th: not at all :) I think it's amusing
07:11:03 <copumpkin> if anything the haskell notion of module is more on-topic for this channel than an r-module :P
07:11:34 <copumpkin> if only barely ;)
07:11:38 <en0th> :)
07:11:57 <edwardk> xerox: i mostly use modules so i can talk about them in the 'applicative wrapped around a monoid' right-seminearring code that i use a lot
07:12:01 * Axman6 has a shiny new, haskell filled blog post: http://random.axman6.com/blog/?p=124
07:12:31 <edwardk> http://hackage.haskell.org/packages/archive/monoids/0.1.36/doc/html/Data-Monoid-Monad.html has a couple of instances for lifting modules: (Module r m, Monad f) => Module r (Mon f m)
07:12:37 <xerox> edwardk are there interesting 'semi-' '-near-' '-oid' structures?
07:13:11 <stepcut> Axman6: what do you use to do the Haskell highlighting in your post?
07:13:53 <Axman6> a script that runs the code snippets through Hscolour. it's pretty labour intensive, but not too bad
07:13:57 <edwardk> nah, the -oid gives up the same thing the -near- does: access to both distributive laws
07:14:06 <xerox> edwardk we never bothered with structures that "nearly" fullfill axioms in any course
07:14:17 <xerox> *fulfill
07:14:35 <stepcut> Axman6: have you considered just writing the whole post in literate Haskell? (And then running it through HsColour?)
07:15:05 <edwardk> xerox: yeah i had to rederive most of their properties. you really only start talking about right seminearrings once you start talking about parsers and kleene algebras
07:15:06 <Axman6> yeah. i was going to use the BlogLiterately program on hackage, but it dislikes 6.12
07:15:41 <edwardk> xerox: it just happens that i was working on a lot of monoidal parsing techniques when i wrote that code
07:16:25 <edwardk> that and i was trying to figure out the right shape for part of the kata prelude, which is pretty good about incremental abstraction
07:16:29 <stepcut> Axman6: ah, I just make a literate haskell file where the literate parts are actually html markup, and then do, HsColour -css $< -o$@ -lit to generate a version that is all html
07:16:39 <zygoloid> Axman6: nice. i had issues with Binary recently and ended up resorting to an unsafePerformIO (catch ...)
07:16:51 <Axman6> o.O
07:16:54 <Axman6> gross, ha
07:17:06 <edwardk> zygoloid: try spoon!
07:17:06 <Axman6> check out Cereal, it solves a lot of the pain of binary
07:17:11 <stepcut> Axman6: see the Makefile and Migrate.lhs here for an example, http://src.seereason.com/examples/migration-tutorial/
07:17:35 <en0th> copumpkin: do you think that my module could be useful in some way? or is it just re-inventing the wheel.. ?
07:17:39 <Axman6> someone mind submitting that post to reddit? dons is in melbourne at the moment, and not submitting from what i hear :)
07:17:46 <edwardk> zygoloid: http://hackage.haskell.org/package/spoon
07:18:23 <copumpkin> en0th: I'm sure it could, but I don't typically put much effort into human-readable output so I probably wouldn't use it.
07:18:26 <stepcut> Axman6: the nice part about using literate haskell is you can actually run your post and make sure it actually works ;)
07:18:31 <edwardk> copumpkin: interesting result, due to the presence of call/cc in kata, every functor is costrong.
07:18:47 <Axman6> stepcut: i knew this wasn't going to run from before i started writing it :P
07:19:09 <lispy> edwardk: heh, costrong sounds like a category theorists way to call something weak :)
07:19:09 <lambdabot> lispy: You have 5 new messages. '/msg lambdabot @messages' to read them.
07:19:18 <stepcut> Axman6: :p
07:19:19 <lispy> wow, I've been gone too long
07:19:27 <edwardk> lispy: actually being costrong is pretty spiffy.
07:19:46 <b_jonas> heh
07:19:49 * shambler tries to imagine copumpkin
07:19:54 <edwardk> means you can define a function of the signature Functor w=>  w (Either a b) -> Either (w a) b
07:20:03 <zygoloid> edwardk: haha, perfect :)
07:20:41 <copumpkin> edwardk: hm, interesting, but I don't know enough about the categorical view of call/cc or costrength to see how those two are related
07:20:43 <en0th> copumpkin: Thanks. It would be nice i.e. to have cabal-install use that.. Thank you.
07:20:52 <lispy> ?tell maltem re: iteratees, glad we're on the same page :)
07:20:53 <lambdabot> Consider it noted.
07:20:57 <copumpkin> en0th: you should definitely put it on hackage :)
07:20:58 <edwardk> which hunts through your data structure for any b's and if it finds one, you get it, otherwise it gives you back a b-free structure. now clearly you can't define this for every functor, because what about functors that contain functions? or infinite streams, equality of streams requires a halting oracle, etc.
07:21:28 <copumpkin> edwardk: oh, I see
07:21:40 <edwardk> copumpkin: http://comonad.com/reader/2008/deriving-strength-from-laziness/
07:21:42 <en0th> copumpkin: err... first time here. I'm going to manage to upload it
07:21:46 <edwardk> gives why every functor in haskell is strong
07:22:05 <copumpkin> yeah
07:22:10 <edwardk> on the other hand, with call/cc you get a similar argument why every functor is costrong
07:22:43 <xerox> I feel the The Functor is strong in you, young Haskell
07:22:50 <shambler> :)
07:23:00 <shambler> but you are not a mainstream yet
07:23:21 <copumpkin> lol
07:23:28 <copumpkin> shambler: trust me, you don't want to
07:23:43 <edwardk> you'd get something like: costrength f xs = call-cc $ \ k -> Left $ map (either id (k . Right)) xs
07:23:58 <edwardk> transliterated into a bastardized half-haskell
07:24:55 <luqui> i wish functors weren't strong by default
07:25:15 <luqui> or rather, i wish there were a good way to talk about unstrong functors
07:25:18 <edwardk> by using the continuation k to pull a devil's bargain if you ever find a 'b' in the original structure, and return back to the current continuation with it
07:25:43 <edwardk> luqui: give up lambda
07:26:01 <Jonno_FTW> in sigma notation, what do the numbers on top and bottom represent?
07:26:11 <zenzike> I've been playing with the OpenGL bindings, and noticed that GLfloat is no longer a synonym for Float; conversion between the two is pretty costly using realToFrac, and part of my program uses an IArray. Does anybody know if there's a way of adding an instance to the IArray class? or maybe there's a faster conversion function than realToFrac? Does anybody know the rationale for making GLfloat no longer a float synonym?
07:26:32 <Axman6> Jonno_FTW: bottom is the number you start with, and the top is the upper limit
07:26:41 <Jonno_FTW> cool
07:26:56 <luqui> edwardk, i mean in regular haskell code
07:27:03 <Axman6> so, \sigma_{i=1)^10 i would be the same as sum [1..10]
07:27:06 <Jonno_FTW> thanks
07:27:07 <xerox> Jonno_FTW \Sigma_{k=0}^{n} = let k = 0 in sum [k..n]
07:27:27 <luqui> and you don't have to give up lambda, you just have to give up closing over your envt inside fmap...
07:27:29 <Axman6> (_x mean substript, ^x mean superscript)
07:27:59 <edwardk> luqui: yes, what i mean is you'd need to define your functions using something other than lambdas, or use some type level branding to prevent them from moving over the functor
07:28:01 <ClaudiusMaximus> zenzike: i think it was recommended to use unsafeCoerce until something better is invented..
07:28:23 <luqui> edwardk, ah, yeah.
07:28:41 <ClaudiusMaximus> zenzike: ..the something better being compiler rules that make realToFrac -> id
07:28:42 <zenzike> ClaudiusMaximus: ah, i thought something unsafe might have to happen, i've never toyed with those functions before.
07:29:08 <medfly> lol
07:29:11 <zenzike> ClaudiusMaximus: sure, except that GLfloat \= Float, so that wouldn't work would it?
07:29:28 <copumpkin> edwardk: omg a typo in your blog post that you linked me to
07:29:30 <edwardk> luqui: maybe something like weakMap :: (forall s. Branded s a -> Branded s b) -> f a -> f b
07:29:33 <edwardk> copumpkin: ack!
07:29:45 <copumpkin> edwardk: makes me think you have a hispanic background
07:29:53 <copumpkin> "if we look at this especialized to 'id',"
07:29:54 <edwardk> copumpkin: ?
07:29:58 <edwardk> hahaha
07:30:12 <copumpkin> :)
07:31:11 <edwardk> fixed
07:31:54 <copumpkin> :)
07:35:18 <zygoloid> zenzike: looks like it's a newtype wrapper around a CFloat
07:36:17 <ClaudiusMaximus> zenzike: i misremembered the advice, it's actually "evil and probably not the right way" http://www.haskell.org/pipermail/hopengl/2009-October/000935.html
07:36:45 <Zeiris> Is there a way to write record-syntax modifications in point-free style without using lambdas?
07:36:59 <zygoloid> is there no way to build an IArray from an arbitrary Storable instance?
07:37:12 <Zeiris> (In something like "st<-get ; put $ st {stHorizon = deleteMin(stHorizon st)}"
07:37:15 <zenzike> ClaudiusMaximus: ha, well i tried it just for kicks and it /seems/ to work, but then again, I wouldn't like to trust it
07:37:20 <copumpkin> zygoloid: a UArray?
07:38:30 <zygoloid> sure, why not :)
07:39:21 <edwardk> Zeiris: you could probably do something with a data.accessor and modify
07:39:34 <Zeiris> Eep, sounds scary.
07:39:54 <copumpkin> zygoloid: you could probably write an instance for it. instance (Storable a) => IArray UArray (StorableEl a) with newtype StorableEl a = StorableEl a
07:40:27 <zygoloid> copumpkin: yeah. i think zenzike's better off with unsafeCoerce to be honest ;-)
07:40:41 <copumpkin> lol
07:40:52 <edwardk> zeiris: modify (accessor ^= value)
07:41:07 <edwardk> Zeiris: looks rather pretty actually
07:41:22 <copumpkin> I kind of wish the (.) in Prelude were re-exported from Control.Category
07:41:37 <edwardk> zeiris you just need to set up the accessors for your state data type
07:42:05 <zygoloid> copumpkin: how would that work? doesn't CC provide its own (.)?
07:42:21 <copumpkin> yeah, that's what I mean
07:42:23 <zygoloid> copumpkin: oh, i see what you mean, the other way around. yeah, that'd probably be handy
07:42:26 <edwardk> zygoloid:  it does, but its compatible
07:42:34 <copumpkin> yeah, sorry :)
07:42:40 <edwardk> zygoloid: the issue is of course the cale's of the world want it for fmap ;)
07:42:55 <Cale> hehe
07:42:59 <gwern> :t iterate
07:42:59 <edwardk> and i can't find a compelling argument that you use categories more than fmap ;)
07:43:00 <lambdabot> forall a. (a -> a) -> a -> [a]
07:43:09 <zenzike> zygoloid: Hmf, well, at least I'm not mapping an unsafeCoerce
07:43:16 <copumpkin> Cale: is that just notational convenience?
07:43:21 <zygoloid> edwardk: it sounds like a compelling argument for leaving things alone to me :)
07:43:25 <copumpkin> edwardk: fc-labels!
07:43:26 <Cale> copumpkin: Mostly
07:43:28 <edwardk> zygoloid: yeah =)
07:43:37 <copumpkin> Cale: why not something like ? :P
07:43:37 <Cale> copumpkin: But also fmap is a nice way to generalise (.)
07:43:41 <edwardk> copumpkin: i couldn't remember which one had the category definitions =)
07:43:45 <zygoloid> (<<<) for Categories and (<$>) for Functors would suit me
07:43:52 <copumpkin> @let (?) = fmap
07:43:53 <lambdabot>  Defined.
07:43:55 <gwern> > take 1000 $ iterate (\x -> x - (x * 0.0003)) 10
07:43:56 <lambdabot>   [10.0,9.997,9.9940009,9.99100269973,9.98800539892008,9.985008997300405,9.98...
07:44:10 <edwardk> > (*2) ? Just 3
07:44:11 <Cale> I would support Control.Category more if it were a more convincing representation of what categories are.
07:44:12 <lambdabot>   Just 6
07:44:23 <jmcarthur> i tend to think of fmap as a kind of "application" more than a kind of "composition," at least when viewed as a two-argument function
07:44:25 <gwern> 0.03% = x*0.0003, right?
07:44:38 <copumpkin> > 0.03 / 100
07:44:39 <medfly> where did the x come from
07:44:39 <lambdabot>   3.0e-4
07:44:42 <Cale> jmcarthur: Right, but composition is also a kind of application :)
07:44:42 <jmcarthur> which is why i don't really support (.) = fmap
07:44:45 <zygoloid> Cale: is Cat embeddable within Hask?
07:44:45 <edwardk> i rather like Control.Category, its just the type system gets in the way of defining general purposes reader monads, etc. over arbitrary cartesian closed categories
07:44:53 <zygoloid> (i guess CAT isn't)
07:45:02 <gwern> medfly: well, 0,03% of x = x*0.0003, I is asking
07:45:07 <copumpkin> meow
07:45:24 <medfly> yep
07:45:37 <gwern> phew
07:45:52 <copumpkin> I'd support renaming fmap to map
07:45:57 <Cale> gwern: Easy way to remember, the % sign means /100
07:46:10 <copumpkin> but (.) seems a little specific notation-wise
07:46:13 <Cale> (and "of" means multiplication as usual)
07:46:14 <edwardk> copumpkin: that battle was lost during the great monomorphism revolution of 98.
07:46:14 <zygoloid> it's built out of a divide sign and two zeroes
07:46:14 <gwern> my answer of 7.4 seemed too small :)
07:46:28 <zygoloid> there's a permille sign which has an extra zero which means /1000
07:46:36 <Cale> copumpkin: I (currently) think we should have map and (.) be the main notations for functor application
07:47:21 <copumpkin> Cale: ‚àò can be category composition then :D
07:47:25 <Cale> I would change my mind about (.) if the type system could somehow represent arbitrary categories more faithfully.
07:47:28 <copumpkin> well, morphism composition
07:47:31 <edwardk> cale: well, you'll get 'map' at least in kata, but i'm using . for categorical composition still. =)
07:47:50 <Cale> I don't mind >>> or <<< as notation for composition, following along from Control.Arrow
07:47:53 <gwern> ok, so I'm pondering aging. suppose we have a cohort of 10 people, and each has a 0.03% chance of dying every year, and I want to know how many will be left in 1000 years. is my iterate definition wrong? (assume that 0.03% of the cohort will in fact die every year)
07:47:53 <copumpkin> we should mandate agda-mode in all text editor
07:47:59 <Cale> (I mean the generalised sort)
07:48:00 <copumpkin> Cale: they're so verbose!
07:48:04 <gwern> copumpkin: agda-mode? you mean pretty lambdas?
07:48:06 <edwardk> copumpkin: not yet willing to type ‚àò nearly as frequently as i'd have to
07:48:08 <gwern> unicodifying?
07:48:10 <copumpkin> gwern: the input method
07:48:19 <Cale> copumpkin: Yeah, but how often do you compose things which aren't functions?
07:48:22 <copumpkin> edwardk: two keystrokes!
07:48:30 <copumpkin> Cale: all the time!!
07:48:38 <Cale> copumpkin: really?
07:48:40 <edwardk> i suppose i could tweak my vi mode for kata to just insert it whenever . was surrounded by whitespace on both sides
07:48:50 <edwardk> i do that currently i just undo it when i save
07:49:19 <Cale> copumpkin: I haven't seen too many examples of Control.Category. There's the first class labels stuff... and bijections... and not much else.
07:49:23 <jmcarthur> Cale: i like having (<<<) separate from (.) due to their differing precedences
07:49:27 <edwardk> Cale: i do it a lot, but thats mostly coz the only thing i have remotely close to working in kata is category-extras ;)
07:49:37 <copumpkin> Cale: not really :) but I'd like to if they were less cumbersome. I'd do it in agda but I sort of need typeclasses or I can't use the composition operator infix
07:49:51 <copumpkin> I guess I could stick it in a module and open it
07:50:59 <Cale> Perhaps we could do proper categories with a better system of kinds
07:51:34 <Cale> It sort of feels like the kind of thing that you want at least some sort of dependent typing for.
07:51:39 <copumpkin> yeah
07:52:30 <zygoloid> why is a dependent type system hard? (i assume it must be, since all the implementations seem to still be somewhat research projects)
07:52:33 <jmcarthur> so who's gonna give us dependent type inference? :\
07:52:38 <ttvd_> is there a list of recommended haskell books?
07:52:55 <copumpkin> zygoloid: it isn't hard in one way
07:53:06 <copumpkin> zygoloid: but it's hard to make usable
07:53:10 <jmcarthur> zygoloid: the type systems are almost trivial. they are simply more powerful than most people are used to, i think
07:53:16 <Cale> ttvd_: What sort of book are you looking for? An initial tutorial? Something more in-depth?
07:53:22 <edwardk> copumpkin: gah, you might have won me over on ‚àò
07:53:30 <copumpkin> really? that was easy!
07:53:45 <edwardk> copumpkin: went and search and replaced and it looks so pretty ;)
07:53:48 <shambler> @where books
07:53:49 <lambdabot> I know nothing about books.
07:53:52 <ttvd_> Cale: a good in-depth book.
07:54:08 <copumpkin> edwardk: agda-mode's unicode input method is so easy to type with! now if only I used emacs for other things, I could probably load it up everywhere
07:54:14 <Cale> Well, there is http://book.realworldhaskell.org/read/
07:54:23 <edwardk> not willing to live in emacs
07:54:29 <Cale> http://www.haskell.org/haskellwiki/Books
07:54:42 <copumpkin> :)
07:54:52 <ttvd_> cool, thank you.
07:55:02 <shambler> ttvd_, http://haskell.org/haskellwiki/Books
07:55:21 <ttvd_> yeah, thanks guys, that's exactly what I need.
07:55:22 <edwardk> copumpkin: of course this is a slippery slope, soon -> starts to vanish, then you get real lambdas, and soon you're agda!
07:55:30 <Saizan> in a dep. type system you've to make inductive types primitive, since they don't desugar to a church encoding like in System F, so it's harder to typecheck a case expression, also you've to add beta-reduction to your equality
07:55:36 <shambler> but I can't recommend something specific (didn't read them, except RWH)
07:55:48 <copumpkin> edwardk: :D
07:55:56 <Saizan> (well, i guess System F has beta reduction too)
08:06:14 <copumpkin> @hoogle parseDate
08:06:15 <lambdabot> No results found
08:07:00 <copumpkin> CoKleisli mposition
08:08:37 <edwardk> copumpkin: har har
08:08:47 <copumpkin> :)
08:09:25 <HaskellLove> this is general computer science question i am sorry, can anyone recommend me good introduction book to statistics for computer science?
08:10:24 <copumpkin> HaskellLove: as in machine learning?
08:11:06 <HaskellLove> well for anything, i mean, i watch matlab webinars now and i realize statistics can be a good tool for general problem solving
08:12:08 <copumpkin> I'd just browse wikipedia on the topic and look at references there if you want anything deeper
08:14:05 <HaskellLove> ok
08:14:13 <egregor> it seems my ip range is blocked to haskell.org. its been weeks. is there a contact to the site admins?
08:14:20 <jmcarthur> Saizan: what is it about dependent types that prevents the possibility of church encodings of inductive types?
08:15:06 <edwardk> egregor: the sadistic side of me wants to say, sure, the information is on haskell.org ;)
08:15:10 <copumpkin> egregor: what does a traceroute show?
08:15:39 <egregor> copumpkin: it hangs, ie, does not complete.
08:15:54 <edwardk> egregor: yes, but the key question is where?
08:16:06 <egregor> howeveeer.... i can access hackage.haskell.org, its odd
08:16:21 <copumpkin> if it doesn't stop at haskell.org, then it's unlikely it's anything to do with the admins there
08:16:29 <egregor> edwardk: pardon, what?
08:16:40 <dark> egregor, set up a proxy
08:16:47 <copumpkin> egregor: did you try http://128.36.229.215/ ?
08:16:50 <edwardk> egregor: how far out does the traceroute stop? one hop? 20?
08:17:01 <egregor> let me see
08:17:29 <egregor> strangely, my mates can enter the website...
08:17:30 <edwardk> egregor: the last thing before the traceroute goes back is key to figuring out whats going on. if it doesn't even try, can you resolve the dns entry even?
08:17:48 <copumpkin> HaskellLove: information theory is good to know but I don't really know your background and it might be a little heavy going at first
08:17:50 <edwardk> and, sadly enough, have you rebooted since you started having the problem?
08:17:56 <egregor> dns is ok
08:18:00 <Saizan> jmcarthur: afaiu, that pattern matching brings equalities in scope, like the type refinements you get with GADTs
08:18:04 <egregor> edwardk: yes
08:18:13 <dark> traceroute haskell.org
08:18:30 <copumpkin> egregor: so did the direct ip address work?
08:18:37 <copumpkin> I guess not
08:19:00 <egregor> didnt. trace route stops at some att
08:19:17 <copumpkin> considering it's a yale ip address
08:19:34 <copumpkin> egregor: can you visit other ip addresses at yale?
08:19:45 <edwardk> egregor: can you paste the last address and how many hops out it was?
08:19:55 <dark> egregor, pastebin.com
08:19:59 <dark> paste all output
08:20:04 <egregor> 8  gar8.n54ny.ip.att.net (12.122.131.1)  160.620 ms  159.282 ms  155.154 ms
08:20:12 <egregor> hangs here
08:20:22 <dark> egregor, also you may have stepped on those infamous internet black holes
08:20:54 <egregor> argh! :( lol
08:21:04 <dark> egregor, set up a proxy :)
08:21:08 <copumpkin> egregor: does 130.132.51.8 work?
08:21:11 <dark> it's not that hard
08:22:22 <edwardk> egregor: are you in new york?
08:22:23 <egregor> copumpkin: trying
08:22:29 <egregor> no, brazil!
08:22:36 <jmcarthur> Saizan: you mean like determining which patterns are relevant and which are not?
08:22:50 <jmcarthur> based on the type, that is
08:23:08 <egregor> copumpkin: hangs in the same spot, *ip.att.net....
08:23:13 <egregor> 8th hop
08:23:19 <copumpkin> egregor: so you just can't get to yale
08:24:04 <edwardk> egregor: my first guess is that you're falling into one of those horrible to diagnose bgp routing problems, where some place in the middle isn't seeing the routes for one end because they are below its threshold. i.e. it is only handling /20s and above
08:24:44 <Saizan> jmcarthur: and more importantly that if you've data TEq a b where Refl :: TEq a a, when you pattern match on Refl you "learn" that a and b are equal
08:24:56 <egregor> copumpkin: yale? yale.edu hangs too! i know it worked some months ago lol
08:25:42 <egregor> edwardk: yeah.
08:25:52 <egregor> ok, gonna use proxy
08:26:07 <jmcarthur> Saizan: oh i see what you mean
08:26:29 <egregor> now this issue is clear to me. its really not a problem with haskell.org
08:26:32 <egregor> thanks
08:26:33 <jmcarthur> Saizan: that actually doesn't seem unique to dependent types to me. it looks more like a feature of the inductive type primitive
08:26:37 <edwardk> egregor:  you mentioned your mates can get to the address, are they using the same service provider?
08:26:37 <Saizan> jmcarthur: the not relevant patterns can be derived from this, since if you get a false equality in scope you can use it to prove anything
08:27:46 <egregor> edwardk: people with the same provider could enter. but they could be far away from me, so the route can be other...
08:28:18 <edwardk> egregor: yeah, i'd report it to your service provider. they have better tools for diagnosing it, and can see what is going on at the bgp layer
08:28:24 <Saizan> jmcarthur: well, it's something you can't implement with a dep. typed language with only lambdas, and something very useful
08:28:39 <jmcarthur> okay, i see. thanks
08:29:00 <quicksilver> edwardk: haha. Good luck to anyone who tries to find a person at their ISP who knows what 'BGP' means.
08:29:12 <egregor> edwardk: sure. will do.
08:29:13 <edwardk> egregor: if thy are a fairly major provider down in brazil they probably have several blocks of ip addresses, you might be on a smaller one, they might not be announcing routes correctly, things could have gone asymmetrical, there is all sorts of stuff
08:29:14 <quicksilver> (of course, they exist, at most ISPs, but they are not permitted to speak to customers)
08:29:22 <egregor> sorry taking your time people. im grateful
08:29:27 * jmcarthur wonders how useful dependent types would be without that feature
08:29:36 <copumpkin> independent types!
08:29:40 <edwardk> quicksilver: true enough
08:30:03 <egregor> edwardk: yeah, they cover a wide area
08:30:17 <Saizan> coq actually doesn't have dep. pattern matching like this, but a weaker form, but that's still not implementable with only lambdas, iirc
08:30:19 <edwardk> quicksilver: however, routing complaints do seem to trickle back to the network operations guys, even if they don't take the call themselves
08:30:26 * quicksilver nods
08:32:28 <edwardk> i'd like to say  i was any different when i ran an ISP/DSL provider, but we didn't let out network guys talk to customers very much either. ;)
08:32:54 <quicksilver> it's not really advisable even to let them talk to each other
08:33:13 <quicksilver> they get this wistful look in their eyes and start talking about token rings, and that's no more work for the day
08:33:18 <edwardk> clearly if they have time to talk at all, you aren't working them hard enough ;)
08:33:21 <copumpkin> sysadmin muzzles
08:33:40 <copumpkin> or maybe ball gags :o
08:34:20 <copumpkin> or should I say, :œï
08:34:29 <edwardk> if the words token ring ever came out of one of their mouths except as a precursor to talking about the features of fddi i would have been sad. ;)
08:50:14 * copumpkin just decided to start a flame war on proggit
08:50:26 <copumpkin> assuming his self. post doesn't get buried immediately, which is pretty likely
08:50:28 <koeien37> heh. link?
08:50:34 <copumpkin> http://www.reddit.com/r/programming/comments/alfnj/haskell_downvoters_why_do_you_downvote/
08:50:36 <copumpkin> :P
08:50:39 <tommd> copumpkin: Those are easy to start - one reason I haven't seen proggit in months
08:51:05 <copumpkin> lol
08:51:10 <koeien37> yesterday or the day before that I submitted a few posts on Haskell, they were upvoted
08:51:16 <ben> copumpkin: So when one wants to worship the god of pumpkins
08:51:27 <ben> copumpkin: do they sacrifice him pumpkins? or would that be considered sacrilege?
08:51:37 <copumpkin> nah, you must sacrifice seven pumpkins
08:51:47 <ben> Right
08:52:11 <copumpkin> pumpkins you grow yourself, though
08:52:17 <copumpkin> buying pumpkins isn't as much of a sacrifice
08:52:36 <ben> Huh, I guess.
08:53:10 <gsan> Hello all! I'm trying to pick myself a web server interface, and decided to test "loli" first. But examples and documentation is virtually nonexistent. There was a paste application at "http://lolipaste.easymic.com/00000-lolipaste.haskell" but it got lost, does anyone have it? Or any other examples/tutorials? I wish I had saved it last week.
08:53:36 <copumpkin> koeien37: oh yeah, we can often get enough to stay visible, but haskell posts often hover just barely over 50% and have loads of downvotes
08:53:57 <koeien37> proggit is often a load of junk anyway
08:54:05 <copumpkin> definitely :)
08:54:15 <copumpkin> but there is visibility there, if nothing else
08:54:17 <gsan> Sorry if this is a duplicate message, I got dropped the first time.
08:59:43 <copumpkin> actually, I changed my mind
09:10:50 <Cale> heh, the code for loli uses that bizarre MPS library
09:11:33 <tommd> Any Chart devs here?  As in, for the 'Chart' library on hackage?
09:11:37 <tommd> I'll e-mail the ML if not
09:11:47 <copumpkin> isn't that byorgey?
09:11:52 <copumpkin> @hackage chart
09:11:53 <lambdabot> http://hackage.haskell.org/package/chart
09:12:19 <copumpkin> oh, no
09:13:29 <koeien37> Cale: yeah it seems really strange. what's the purpose? some "sugar"
09:14:37 <gsan> Hello again. Sorry about the channel spam. Did anyone reply to my question about loli? I was looking for some sample code.
09:14:57 <tommd> gsan: People mentioned it uses a bizarre library, that is all
09:14:59 <koeien37> gsan: no so far
09:15:09 <copumpkin> probably just because the author wrote MPS too
09:15:11 <gsan> Thanks. Sorry again. :-)
09:15:18 <Cale> {-# INLINE (-) #-}
09:15:18 <Cale> (-) :: (a -> b) -> a -> b
09:15:18 <Cale> f - x =  f x
09:15:18 <Cale> infixr 0 -
09:15:18 <Cale> (<->) :: (Num a) => a -> a -> a
09:15:19 <Cale> (<->) = (Prelude.-)
09:15:21 <Cale> infix 6 <->
09:15:24 <Cale> ^^ from MPS
09:15:36 <copumpkin> yeah, it's really weird
09:15:39 <koeien37> aw, why?
09:15:45 <copumpkin> MPS also has some pretty advanced math in it, buried deep down
09:15:51 <copumpkin> for who knows what reason
09:16:13 <Cale> for no reason, apparently, it's not even exported
09:16:14 <gsan> I guess you don't have to use MPS to use loli
09:16:55 <koeien37> what's the advanced math?
09:17:07 <ben> @hoogle (</>)
09:17:07 <lambdabot> Text.Html (</>) :: (HTMLTABLE ht1, HTMLTABLE ht2) => ht1 -> ht2 -> HtmlTable
09:17:07 <lambdabot> System.FilePath.Posix (</>) :: FilePath -> FilePath -> FilePath
09:17:07 <lambdabot> System.FilePath.Windows (</>) :: FilePath -> FilePath -> FilePath
09:17:36 <koeien37> this code is barely readable due to all the renaming of standard functions
09:17:57 <copumpkin> koeien37: http://github.com/nfjinjing/mps/tree/master/src/MPS/Math/
09:18:08 <koeien37> ah that's not on hackage
09:18:35 <copumpkin> it might be, but it isn't exported from the package anyway
09:18:45 <koeien37> the tarball didn't contain it
09:18:47 <ben> That mps library sure smells like ruby
09:18:49 <copumpkin> ah
09:18:52 <copumpkin> ben: yep
09:19:42 <Cale> I can't imagine what causes people to want to redefine (.) to mean reverse application. That style is obnoxious enough in an OO setting.
09:19:42 <koeien37> hey, elliptic curves
09:19:56 <ben> Cale: Well... reading left to right?
09:20:03 <sm> gsan: http://joyful.com/repos/hledger/Commands/Web.hs uses loli
09:20:05 <koeien37> i wanted to write that code some time ago :)
09:20:32 <gsan> sm: thx
09:20:59 <koeien37> ahw i saw this code some time ago, but without any license
09:22:04 <Cale> at least make it reverse composition, rather than reverse application, if you're going to flip things around somehow :)
09:22:22 <koeien37> http://hackage.haskell.org/package/HaskellForMaths <-- cool package
09:22:40 <edwardk> cale: space is already significant around . anyways. changing it so that foo .bar baz = (foo .bar) baz = (bar foo) baz isn't THAT terrible
09:23:39 <edwardk> cale: what i'd really like to see is a way that that same dot-path style could be used for composing accessors instead
09:24:12 <Cale> I don't really understand why that's desirable though. The normal function application style seems more readable to me.
09:24:35 <koeien37> well, you can get used to everything. I don't really see the point of changing it
09:24:50 <Cale> I guess we do have (x `f`)
09:24:57 <Cale> if you really want to write things funny :)
09:25:14 <Cale> (I suppose it's nice with things like `elem`
09:25:16 <Cale> )
09:25:31 <roconnor> (^.)
09:25:34 <koeien37> yeah, I prefer (`elem` xs) instead of flip elem xs
09:25:59 <Jonno_FTW> how is flip useful?
09:26:03 * roconnor has use (16 `minutes`) before where minutes = (*60)
09:26:21 <jaspervdj> Jonno_FTW: for use in a map or other high-order functions
09:26:44 <zygoloid> disciple uses foo .bar baz to mean something quite like bar foo baz iirc
09:28:10 * pikhq notes that "." already has well-defined meaning in Haskell.
09:28:44 <koeien37> you can hide that function
09:29:04 <pikhq> Doesn't make it any less evil.
09:29:16 <koeien37> > (+1) . Just 5 -- is this evil?
09:29:17 <lambdabot>   Just 6
09:29:27 <pikhq> No, that's what . does.
09:29:33 <pikhq> :P
09:29:43 <koeien37> > reverse . Just "cthulu"
09:29:44 <lambdabot>   Just "uluhtc"
09:29:50 <edwardk> cale: the main thing i like is that foo.x * bar.x + foo.y + bar.y  reads much more naturally to a programmer with an oop background.
09:29:52 <medfly> > (+1) (Prelude.(.)) Just 5
09:29:52 <pikhq> (I know, I know, Caleskell makes . = <$>)
09:29:53 <lambdabot>   Not in scope: data constructor `Prelude'
09:29:55 <medfly> or something.
09:30:01 <edwardk> er *
09:30:07 <zygoloid> > Prelude.id Just . [42]
09:30:09 <lambdabot>   [Just 42]
09:30:09 <Cale> edwardk: I greatly prefer x foo to foo.x
09:30:23 <koeien37> import Caleskell; import qualified Prelude as P
09:30:27 <edwardk> Cale: however, we long ago established that you are rather the outlier ;)
09:30:37 <koeien37> no, I dislike foo.x as well
09:30:58 <hiredman>  possibly you want a threading operator
09:31:23 <medfly> > Just . [42]
09:31:24 <lambdabot>   [Just 42]
09:31:26 <zygoloid> @type [(Prelude..)..(Prelude..)]
09:31:27 <lambdabot> forall b c a. (Enum ((b -> c) -> (a -> b) -> a -> c)) => [(b -> c) -> (a -> b) -> a -> c]
09:31:29 <hiredman> gah, threading in the code transform sense not concurrency sense
09:31:34 <medfly> what
09:31:39 <koeien37> enum, lol
09:31:48 <edwardk> the main thing i don't like about it is that its tricky to pick the right interaction between that, sectioning, arguments and fixities
09:32:25 <edwardk> zygloid: hah
09:32:35 <hiredman> some x where x a b c d becomes (d (c (b a)))
09:33:44 <CalJohn> @type (<=<)
09:33:45 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
09:34:02 <copumpkin> @type (.)
09:34:04 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:34:08 <zygoloid> @type \(...) -> [(...)(Prelude..)..((Prelude..) ...)]
09:34:09 <lambdabot> forall b c a t. (Enum t) => (((b -> c) -> (a -> b) -> a -> c) -> t) -> [t]
09:34:11 <edwardk> cale the main objection i have to: x foo is the associativity of juxtaposition. foo.bar.baz.quux becomes quux (baz (bar foo))
09:34:19 <zygoloid> introducing dotskell...
09:34:40 <zygoloid> (where Ascii is permitted only in keywords)
09:34:52 <zygoloid> s/Ascii/alpha/
09:35:04 <Cale> edwardk: Well, you already know the Haskell answer to that problem :)
09:35:17 <Cale> edwardk: foo . bar . baz $ quux -- :)
09:35:55 <edwardk> zygloloid: http://comonad.com/haskell/remorse-1.0/remorse.hs ;)
09:36:28 <CalJohn> @info (<=<)
09:36:28 <lambdabot> (<=<)
09:36:34 <Cale> :t (<=<)
09:36:35 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
09:36:44 <zygoloid> edwardk: o dear god, it's beautiful
09:37:18 <edwardk> zygoloid: context: http://comonad.com/haskell/remorse-1.0/README
09:37:32 <Cale> CalJohn: It's a composition of sorts, like a lifted version of ordinary function composition.
09:37:40 <DerisionSnort> @pl (\x -> (snd x) +1)
09:37:40 <lambdabot> (1 +) . snd
09:38:19 <Cale> CalJohn: The monad laws essentially state that return is an identity for (<=<) (on either side), and that (<=<) is associative.
09:39:21 <Cale> edwardk: I sometimes have thought about giving whitespace to composition though.
09:39:49 <Cale> edwardk: and making function application an infix operator, though I'm not sure that really works as well.
09:40:32 <edwardk> cale: ack
09:40:37 <Cale> Heh, whitespace for functor application :)
09:40:50 <koeien37> nah, what's the point?
09:41:10 <edwardk> cale: hah i tried building a language/calculus where you could overload juxtaposition, but the result is messy
09:41:24 <edwardk> cale: plt scheme gets away with it, sort of
09:41:27 <DerisionSnort> @pl \n -> (f n) > 5
09:41:27 <lambdabot> (> 5) . f
09:42:01 <Cale> edwardk: I feel mildly envious of clojure's ability to overload application for map and set datastructures
09:42:07 <mercury^> Cale: that does not work, because the identity functor cannot be typed.
09:42:22 <mercury^> But it would be nice if a type system could be found...
09:42:27 <Cale> mercury^: eh?
09:42:29 <koeien37> Cale: what is application to a Map then?
09:42:36 <Cale> koeien37: lookup
09:42:37 <copumpkin> Cale: jmcarthur tried to do that with ($) in a Mapping class in #alt-stdlib
09:42:43 <mercury^> Cale: you cannot type the true identity endofunctor in Haskell.
09:42:52 <edwardk> cale: yeah thats something i've been working to maintain for kata, that you can use an array as a function on the index
09:43:07 <koeien37> ah, sort-of  operator() in C++
09:43:10 <edwardk> cale: there is nothing that truly prevents that from being possible in haskell.
09:43:14 <Cale> mercury^: oh, I see what you mean. I was intending that ordinary function application just be denoted by some infix operator
09:43:28 <Cale> mercury^: and composition and lifted application get the nice syntax :)
09:43:35 <mercury^> Well, would be a lot nicer if it was covered by functor application.
09:43:43 <Cale> Yeah, it would.
09:43:51 <Cale> Though there's ambiguity problems.
09:43:53 <copumpkin> instance Mapping (Map k v) where type Domain (Map k v) = k; type Codomain (Map k v) = v; ($) = lookup
09:44:08 <koeien37> ew, partial functions
09:44:18 <copumpkin> koeien37: use a TMap then
09:44:19 <mercury^> Cale: I've been thinking about it, and at first I thought there were, but then I could not find them. But you have to find a decidable type system.
09:44:50 <Cale> koeien37: Well, Map values just become functions to Maybe-types
09:45:15 <copumpkin> koeien37: yeah, we also considered a Codomain (Map k v) = Maybe v
09:45:27 <koeien37> we can do this now, if we overload $, right?
09:45:32 <copumpkin> sure
09:45:44 <copumpkin> this is just in #alt-stdlib, discussing ideas for changing the standard library :)
09:45:56 <koeien37> cool, I'll join that :)
09:46:42 <Cale> Obviously the new ($) will also be left associative ;)
09:46:48 <koeien37> 100% agreed, yes
09:46:55 <copumpkin> Cale: yep
09:47:11 <edwardk> cale: i wanted something like class IsFunction f where type Arg f :: *; type Result f :: *; apply :: f -> Arg f -> Result f -- then you could make instance Ord k => IsFunction (Map k v) where ...
09:47:17 <copumpkin> Cale: but that Mapping class isn't very easy to use, unfortunately
09:47:25 <Cale> copumpkin: oh?
09:47:39 <edwardk> cale: the problem is evaluation and application go in the same slot in the same location in the infotable in ghc
09:47:40 <Cale> copumpkin: Are there instance selection issues somehow?
09:47:45 <copumpkin> well, its types aren't very obvious to read
09:47:47 <copumpkin> nah, not that
09:48:21 <copumpkin> but the Codomain and Domain associated types take getting used to
09:48:32 <copumpkin> (.) has a weird type
09:48:39 <Cale> oh?
09:48:45 <Cale> er, hmm
09:48:45 <koeien37> hmm, what would be the problem, except that it might be dog slow in practice (I don't know)?
09:49:06 <Cale> I suppose it does make sense to want to generalise composition in the same fashion
09:49:18 <idnar> < Cale> f - x =  f x
09:49:19 <idnar> eeeeeeuw
09:49:33 * copumpkin tries to get (.)'s type right
09:49:37 <Cale> idnar: What's worse is the bizarro notation for subtraction
09:50:01 <koeien37> unary negation needs to die first
09:50:12 <Cale> unary negation is fine, I think.
09:50:27 <edwardk> koeien37: or get rolled into the identifier. i'd be fine with it being space significant and part of the actual integer itself
09:50:28 * koeien37 wants (-1) to mean subtract 1
09:50:41 <edwardk> koeien37: (-1) vs. (- 1)
09:50:45 <koeien37> at least (- 1)
09:50:46 <koeien37> yeah
09:50:58 <edwardk> the latter pretty clearly reads as a section
09:51:02 <Cale> I could almost get on board with the whitespace-sensitive version
09:51:18 <Cale> (- x) reads less clearly as a section
09:51:25 <mercury^> There should be a special symbol for unary negation imo.
09:51:32 <Cale> Though I guess I wouldn't mind too much being careful about it
09:51:38 <edwardk> mercury^: there is: 'negate' =)
09:51:47 <Cale> There's also subtract
09:51:47 <mercury^> edwardk: "symbol".
09:51:59 <koeien37> yeah but - is special
09:52:10 <jmcarthur> Cale: yeah, the terms are trivial but they types get really hard to read. i closed the ticket for it yesterday
09:52:22 <copumpkin> (.) :: (Codomain g ~ Domain f, Mapping g, Mapping f) => f -> g -> Domain g -> Codomain f
09:52:22 <copumpkin> (f . g) x = f $ (g $ x)
09:52:29 <koeien37> you get something like (.) :: (Codomain g ~ Domain f, ...) ?
09:52:40 <copumpkin> it's not terrible
09:52:45 <copumpkin> but it can get painful
09:52:49 <jmcarthur> it's not, but it gets worse
09:52:49 <mercury^> copumpkin: uhm.
09:52:50 <edwardk> copumpkin: i hate that less than i thought i would
09:52:55 <jmcarthur> compositione is a rather simple one
09:52:57 <copumpkin> I like the idea, but it's hard to reason about
09:52:58 <jmcarthur> -e
09:53:06 <copumpkin> jmcarthur came up with it and worked with it a lot more than I did :)
09:53:11 <jmcarthur> i think a different syntax for it would be great
09:53:18 <mercury^> copumpkin: does that cover arbitrary categories?
09:53:19 <jmcarthur> but i can't decide what it would be like
09:53:33 <koeien37> maybe make (->) different?
09:53:33 <copumpkin> mercury^: we tried to reconcile it with Control.Category but failed
09:53:39 <copumpkin> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15594#a15594 is a couple of instances
09:53:39 <jmcarthur> i thought about introducing some sort of sugar
09:54:01 <edwardk> jmcarthur: what i've been doing kata-side is just allowing objects to overload their meaning when used as a function. the lack of types helps a bit in this regard.
09:54:03 <koeien37> OTOH, a lot more code becomes legal now
09:54:10 <koeien37> > [3] 2
09:54:10 <lambdabot>   Couldn't match expected type `t1 -> t' against inferred type `[a]'
09:54:15 <koeien37> would you want that?
09:54:19 <Cale> maybe
09:54:20 <copumpkin> koeien37: nope, cause we can't overload space
09:54:27 <koeien37> copumpkin: not ATM
09:54:28 <copumpkin> or do you mean if we made this more integrated?
09:54:29 <mercury^> copumpkin: I find that (.) needs to specialise to categorical composition
09:54:30 <edwardk> koeien37: yeah, a lot of stuff that could be trivially rejected before makes it through to much later in the type checking process
09:54:30 <copumpkin> oh ok
09:54:33 <jmcarthur> like (a ~> b)  ==>  (Mapping m) => Domain a -> Codomain b ... but it doesn't cover everything we'd want
09:54:47 <copumpkin> mercury^: yeah, we'd like it to, but failed when we tried
09:54:53 <Cale> mercury^: I only want (.) to mean categorical composition if we can do it right though.
09:55:20 <mercury^> Well, there's at least one way to do it right: make (.) part of Category.
09:55:30 <Cale> Control.Category is not the right way.
09:55:45 <copumpkin> it does feel like a bit of an afterthought
09:55:54 <copumpkin> (Control.Category)
09:56:12 <Cale> I can't define arbitrary categories and make them instances of Control.Category
09:56:12 <jmcarthur> we also have been looking into getting constraint families into GHC since it would help us generalize a lot more things, but i'm not sure if it would help us much with Category
09:56:19 <edwardk> every category in control.category is 'enlarged' in some sense with at least one object for every type in Hask.
09:56:29 <jmcarthur> i'm not even sure what "arbitrary category" means in this sense
09:57:07 <Cale> Ever since CAML, functional programming has been striving to become more categorical, I think we need a language in which categories are a basic notion, but I'm not completely sure what it ought to look like
09:57:16 <jmcarthur> the generalized mapping even allows composing kleisli arrows directly with unwrapped monadic functions. it's such a shame that the types get so weird
09:57:21 <copumpkin> kata!
09:57:43 <edwardk> copumpkin: =) kata has no way to enforce any of the categorical laws though
09:57:49 <copumpkin> pff laws
09:57:54 <mercury^> Cale: what is so categorical about CAML though?
09:58:05 <edwardk> copumpkin: you just assert the hell out of things to enable the compiler to do stuff =)
09:58:06 <Cale> mercury^: Well, that is what the C stands for
09:58:06 <copumpkin> edwardk: just build in an automated coq/agda extractor of code
09:58:11 <edwardk> copumpkin: =)
09:58:17 <mercury^> Cale: I know, but that's just a name.
09:58:51 <edwardk> copumpkin: kata-from-coq would be a delightful return to its roots ;)
09:58:52 <Cale> mercury^: It's fairly categorical, but mostly in the ways that all lambda calculi are, I suppose.
10:00:04 <edwardk> my current approach there is to make a functional language which is more informed by category theory, but which doesn't try to be a very rigorous from a CT perspective.
10:00:22 <koeien37> "rigorous" as in, you have to prove that your laws hold?
10:00:29 <maltem> Is kata a language? It's not really googleable
10:00:29 <lambdabot> maltem: You have 1 new message. '/msg lambdabot @messages' to read it.
10:00:32 <jmcarthur> Cale: what is an example of a category you would like to be able to express in Haskell?
10:00:44 <jmcarthur> maltem: #kata
10:00:47 <Cale> mercury^: ah, apparently it was a portmanteau of CAM and ML, where CAM was something called the categorical abstract machine. I'll have to look into what that was
10:00:50 <edwardk> so the nice thing is all of the prelude methods for const, fst, snd, either, etc. all come from the derivation of the category for kata
10:01:08 <doserj> http://en.wikipedia.org/wiki/Categorical_abstract_machine
10:01:08 <edwardk> maltem: its a bunch of half-finished compilers at this point ;)
10:01:19 <edwardk> maltem: and an irc channel
10:01:30 <Cale> jmcarthur: The category corresponding to an arbitrary preorder.
10:01:41 <mercury^> Cale: probably not even "categorical" in our sense.
10:01:54 <Cale> Or the one which corresponds to a monoid
10:02:18 <maltem> edwardk, aha... such geeky stuff ;P
10:02:42 <jmcarthur> Cale: wait, we can't use a newtype wrapper to make a Category from a Monoid already?
10:02:58 <edwardk> maltem: http://paste.lisp.org/display/92991 as a fragment
10:03:02 <mercury^> All the wrappers have to go.
10:03:06 <mercury^> It's so annoying.
10:03:20 <idnar> o/` WRAPPERS WE CRUSH / FINGERS TO DUST o/`
10:03:23 <Cale> jmcarthur: We can do it for that one, in a sort of silly way.
10:03:23 <Accidus> Cale: what do you mean?
10:03:59 <Accidus> Cale, what do you mean by arbitrary preorder? How would such a program look like?
10:04:05 <edwardk> copumpkin: which includes your style of .'s ;)
10:04:07 <sinelaw> What's the "right" way to write an application that repeatedly transforms some value, and that value is output? for example, cellular automata outputting each step
10:04:13 <sinelaw> in haskell of course
10:04:35 <jmcarthur> :t iterate
10:04:36 <lambdabot> forall a. (a -> a) -> a -> [a]
10:04:39 <copumpkin> edwardk: jmcarthur's style! :P
10:04:43 <jmcarthur> sinelaw: ^^
10:04:44 <copumpkin> edwardk: but yeah, that's neat
10:04:54 <edwardk> copumpkin: i think it cleans up the example a lot
10:04:57 <sinelaw> jmcarthur, oh
10:05:10 <RayNbow> ‚ô™ <-- idnar, why not use this instead of o/`? :p
10:05:13 <edwardk> copumpkin: even if i'm going to have to tweak my input mode for vi to allow for it
10:05:19 <copumpkin> oh I see :)
10:05:21 <idnar> RayNbow: because it's too hard to type
10:05:22 <copumpkin> you meant the symbol
10:05:27 <edwardk> yeah
10:05:40 <jmcarthur> wait, what is *my* style?
10:05:42 <sinelaw> jmcarthur, in other words, put the iteration results in a sequence
10:05:49 <idnar> RayNbow: maybe if I spend a couple of days, I could figure out how to add a compose sequence for it
10:05:50 <RayNbow> idnar: well, it might be too hard to type depending on the available input methods
10:05:53 <jmcarthur> sinelaw: yup!
10:06:01 <jmcarthur> sinelaw: and you can read from the list lazily
10:06:16 <Cale> Accidus: Categories would be something mostly at the type level, I suppose.
10:06:19 <sinelaw> jmcarthur, what's done in strict languages?
10:06:29 <RayNbow> but Windows users with a JP IME could type "onpu" in Japanese and then select ‚ô™
10:06:37 <copumpkin> jmcarthur: I thought he was talking about Mapping + Domain + Codomain explicitly (which I saw in his functor stuff,  and assumed he was talking about that)
10:06:38 <luqui> sinelaw, something ugly, no doubt :-P
10:06:44 <Twey> RayNbow: Anthy and Kotoeri too
10:07:00 <edwardk> copumpkin: ah, the 'optimized' functor stuff
10:07:04 <copumpkin> yep
10:07:09 <jmcarthur> sinelaw: in a strict language you must sometimes mix many concepts together in order to maintain efficiency
10:07:16 <Twey> sinelaw: Iterators‚Ä¶
10:07:18 <sinelaw> luqui, hey! so the claim is that laziness is an inherently required feature for functional programming?
10:07:26 <jmcarthur> sinelaw: in this case, you would have to mix the output of each step with the iteration loop
10:07:33 <Cale> Accidus: Well, hmm... perhaps we need a value-level representation of the arrows in any category.
10:07:34 <copumpkin> sinelaw: and not optional either :P
10:07:34 <jmcarthur> sinelaw: not at all
10:07:37 <copumpkin> ;)
10:07:43 <snhmib> FREE CALLEN
10:07:44 <snhmib> FREE CALLEN
10:07:44 <edwardk> sinelaw: laziness helps with functional program composition
10:07:46 <snhmib> FREE CALLEN
10:07:48 <snhmib> FREE CALLEN
10:07:50 --- mode: ChanServ set +o Cale
10:07:50 <snhmib> FREE CALLEN
10:07:52 <snhmib> FREE CALLEN
10:07:52 <jmcarthur> sinelaw: but laziness really makes things simpler in many ways
10:07:53 --- mode: Cale set +b *!*@s55916079.adsl.wanadoo.nl
10:07:53 --- kick: snhmib was kicked by Cale (Cale)
10:07:55 <edwardk> sinelaw: its not absolutely necessary but it is sure as hell empowering
10:07:56 <copumpkin> lol
10:08:03 --- mode: Cale set -o Cale
10:08:06 <zygoloid> free callen? i'll take one!
10:08:08 <copumpkin> if you're going to troll, at least let people know what you're trolling about
10:08:16 <edwardk> sinelaw: the 'take 4 . sort' free quickselect example comes to mind
10:08:17 <sinelaw> jmcarthur, continuations?
10:08:29 <RayNbow> at first I actually read that as: <snhmib> FREE CALE
10:08:34 <jmcarthur> sinelaw: what about continuations?
10:08:36 <RayNbow> and I was like... "huh?"
10:08:37 <copumpkin> FREE CALE
10:08:40 <copumpkin> FREE CALE
10:08:42 <sinelaw> jmcarthur, a solution in strict languages
10:08:43 <copumpkin> oh wait
10:08:54 <sinelaw> free . cale
10:08:56 <zygoloid> copumpkin: i'll take three
10:09:03 <idnar> I've never really figured out the whole input method thing either
10:09:04 <copumpkin> zygoloid: I'll get banned though
10:09:07 <mux> yay for make -j6
10:09:16 <edwardk> sinelaw: continuation capture is neutral w.r.t laziness/strictness.
10:09:25 <mux> and to think it used to take me more than an hour to build GHC with my old box
10:09:28 <jmcarthur> sinelaw: perhaps. i haven't given strict languages much thought in a while ;)
10:09:31 <idnar> RayNbow: o/` is three keystrokes, what you said sounds like a lot more than 3 keystrokes
10:09:42 <c_wraith> @free cale
10:09:43 <lambdabot> Extra stuff at end of line in retrieved type "Not in scope: `cale'\n\n"
10:10:07 <idnar> also, most people aren't using a font that has ‚ô™
10:10:14 <Cale> idnar: I am :)
10:10:15 <RayNbow> idnar: but ‚ô™ takes less visual space :p
10:10:24 <jmcarthur> i think screen doesn't like unicode :(
10:10:25 <copumpkin> @free cale :: (a -> a) -> a
10:10:25 <lambdabot> f . g = h . f => f (cale g) = cale h
10:10:31 <ben> My screen likes unicode
10:10:36 <edwardk> sinelaw: also continuation capture isn't sufficient to change your asymptotics, the proof that a purely functional strict language occasionally takes an extra logarithmic time factor holds with or without call/cc.
10:10:41 <Cale> I'm a fixpoint operator!
10:10:45 <sinelaw> Twey, what do you mean by Iterators...?
10:10:56 <jmcarthur> my terminal supports it, my chat client supports it, my font supports it, but i still just see "?"
10:11:01 <Accidus> Cale, my dependent type theory is weak, I guess that's why I don't get what you want to achieve.
10:11:18 <Cale> Accidus: Well, I'm a little unclear on it myself.
10:11:20 <sinelaw> edwardk, i'm just asking how a certain program may be implemented, not about performance
10:11:23 <copumpkin> Accidus: cale uses circular logic
10:11:31 <edwardk> cale is a functor, Free Cale is obviously a free monad.
10:11:31 <copumpkin> Accidus: his type is (a -> a) -> a
10:11:47 <sinelaw> jmcarthur, do your eyes support it?
10:11:55 <edwardk> it is obvious what the map operation is for the Cale functor: Its (.)
10:12:16 * Accidus is an algebraic theory, he gives rise to free monads.
10:12:39 * copumpkin hates freedom, and is a field
10:12:41 <edwardk> Accidus: giving rise to cale in public is er.. a bit creepy
10:13:11 <Cale> Accidus: I mostly feel that having all categorical notions being restricted to the category Hask is kind of unacceptable.
10:13:12 <sinelaw> > cale cale
10:13:14 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
10:13:20 <Accidus> edwardk, It's not my fault for being so arousing
10:13:43 <RayNbow> :t cale
10:13:44 <lambdabot> forall a. (a -> a) -> a
10:13:44 <Accidus> Cale, explain
10:13:47 <copumpkin> :t cale (const cale)
10:13:48 <lambdabot> forall a. (a -> a) -> a
10:14:02 <jmcarthur> cale is a fixpoint?
10:14:08 <Accidus> :t accidus
10:14:09 <lambdabot> Not in scope: `accidus'
10:14:11 <Cale> Accidus: Well, the Functor class in Haskell for example is only capable of representing the functors from our type system to itself.
10:14:12 <sinelaw> <Cale> I'm a fixpoint operator!
10:14:18 <Accidus> Ah, I'm beyond the scope of this channel
10:14:23 <ludflu> Hi haskellers. I'm reading some code by Simon Marlow. There's a function that looks like this http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15595#a15595 I'm wondering about the bit "| b `seq` p `seq` v `seq` False = undefined". Is this just a way of forcing evaluation of the args?
10:14:23 <Accidus> As usual.
10:14:32 <Cale> jmcarthur: I said that because someone asked for the free theorem for  cale :: (a -> a) -> a
10:14:47 <edwardk> cale: yeah, for instance you can encode to the fact that every monad gives rise to at least one adjunction, but you need to be able to switch categories for that
10:14:50 <copumpkin> ludflu: yep
10:14:54 <sinelaw> > accidus
10:14:55 <lambdabot>   "His time will come."
10:14:58 <Cale> ludflu: yeah, that's a standard trick
10:15:10 * Accidus lols.
10:15:12 <edwardk> ludflu: yeah, force the evaluation of each argument, then continue on with the cases below
10:15:14 <Cale> ludflu: The guard always fails, but the parameters are evaluated before that.
10:15:15 <Accidus> :t accidus
10:15:16 <lambdabot> [Char]
10:15:27 <sinelaw> hah, not polymorphic.
10:15:31 <copumpkin> > fix (interleave accidus)
10:15:33 <lambdabot>   "HHiHsi Htsiim eH twsiililm  ceoHm et.wsiililm  ceoHm et.wsiililm  ceoHm et...
10:15:39 <ludflu> thanks for confirming my guess Cale and copumpkin.
10:15:44 <sinelaw> > cale (interleave accidus)
10:15:45 <lambdabot>   Not in scope: `cale'
10:15:58 <ludflu> it seemed kinda odd, otherwise
10:16:01 <sinelaw> > accidus
10:16:03 <lambdabot>   Not in scope: `accidus'
10:16:12 <edwardk> i do believe lambdabot started speaking in Parseltongue
10:16:15 <RayNbow> apparently cale has become undefined
10:16:17 --- mode: ChanServ set +o Cale
10:16:20 --- mode: Cale set -b *!*@s55916079.adsl.wanadoo.nl
10:16:21 <luqui> :t interleave
10:16:22 <lambdabot> forall (m :: * -> *) a. (MonadLogic m) => m a -> m a -> m a
10:16:26 --- mode: Cale set -o Cale
10:16:28 <sinelaw> It was a transient event
10:16:35 <luqui> > interleave "foo" "barry"
10:16:36 <lambdabot>   "fboaorry"
10:16:50 <copumpkin> > map head . iterate (drop 2) "HHiHsi Htsiim eH twsiililm  ceoHm et.wsiililm  ceoHm et.wsiililm  ceoHm et"
10:16:51 <lambdabot>   Couldn't match expected type `[a]'
10:16:51 <lambdabot>         against inferred type `GHC.Types...
10:16:53 <copumpkin> > map head . iterate (drop 2) $ "HHiHsi Htsiim eH twsiililm  ceoHm et.wsiililm  ceoHm et.wsiililm  ceoHm et"
10:16:54 <lambdabot>   "His time will come.siim eH twill come* Exception: Prelude.head: empty list
10:16:57 <RayNbow> > interleave (Just 3) (Just 5)
10:16:58 <lambdabot>   No instance for (Control.Monad.Logic.Class.MonadLogic
10:16:58 <lambdabot>                     D...
10:17:03 <RayNbow> oh wait, MonadLogic
10:17:44 <maltem> Now lambdabot scares the crap out of me
10:17:58 <luqui> > let x = interleave "neat" x in x
10:17:59 <lambdabot>   "nnenaetnaetnaetnaetnaetnaetnaetnaetnaetnaetnaetnaetnaetnaetnaetnaetnaetnae...
10:18:12 <Cale> Accidus: Or, for example, there are categories which we can sort of work with, but only with lots of type wrapping, like the Kleisli category for a monad on Hask
10:18:25 <copumpkin> > fix show
10:18:26 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
10:18:33 <sinelaw> copumpkin, wow.
10:18:35 <jmcarthur> > fix error
10:18:36 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
10:18:40 <copumpkin> > group (fix show)
10:18:40 <sinelaw> @type fix show
10:18:41 <lambdabot>   ["\"","\\","\"","\\\\\\","\"","\\\\\\\\\\\\\\","\"","\\\\\\\\\\\\\\\\\\\\\\...
10:18:42 <lambdabot> String
10:18:52 <copumpkin> > map length . group . fix $ show
10:18:57 <lambdabot>   mueval-core: Time limit exceeded
10:19:00 <sinelaw> that's the show fixpoint string
10:19:01 <sinelaw> cool
10:19:05 <copumpkin> > take 5 . map length . group . fix $ show
10:19:07 <lambdabot>   [1,1,1,3,1]
10:19:17 <copumpkin> > fix (interleave [1..])
10:19:19 <lambdabot>   [1,1,2,1,3,2,4,1,5,3,6,2,7,4,8,1,9,5,10,3,11,6,12,2,13,7,14,4,15,8,16,1,17,...
10:19:32 <sinelaw> show "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\""
10:19:34 <sinelaw> > show "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\""
10:19:36 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\""
10:19:41 <sinelaw> funky!
10:19:54 <copumpkin> > take 10 . map length . group . fix $ show
10:19:55 <luqui> > take 8 . map length . group . fix $ show
10:19:56 <lambdabot>   [1,1,1,3,1,7,1,15,1,31]
10:19:56 <lambdabot>   [1,1,1,3,1,7,1,15]
10:20:08 <copumpkin> > take 15 . map length . group . fix $ show
10:20:09 <Cale> Accidus: But I'd really like to be able to do things like define the entailment category for some logic, and then give it semantics by attaching programs to the arrows in some way which defines a functor to Haskell programs :)  I'm not sure how all the details ought to work, but I think there's some point in doing it.
10:20:09 <lambdabot>   [1,1,1,3,1,7,1,15,1,31,1,63,1,127,1]
10:20:10 <luqui> @oeis 1,1,1,3,1,7,1,15,1,31
10:20:11 <lambdabot>  Expansion of (1+2x)/((1+x)(1-2x^2)).
10:20:11 <lambdabot>  [1,1,1,3,1,7,1,15,1,31,1,63,1,127,1,255,1,511,1,1023,1,2047,1,4095,1,8191,1,...
10:20:18 <copumpkin> :)
10:20:20 <sinelaw> oeis is hard core
10:20:29 <copumpkin> it just contains 2^n - 1 and 1s
10:20:30 <medfly> HARDCORE MAN!
10:20:41 <copumpkin> which also happen to be 2^n - 1, but you know what I mean
10:21:05 <Cale> Accidus: I think that if we could talk about more categories in Haskell than just Hask, we'd find out about more applications of category theory to programming as we experimented with things :)
10:21:27 <RayNbow> hmm, anyone familiar with the book "Vector Calculus, Linear Algebra, and Differential Forms"?
10:21:28 <copumpkin> fc-labels!
10:21:39 <luqui> Cale, how would said categories translate to computability?
10:21:51 <sinelaw> luqui, any progress in re-designing drawing combinators?
10:22:04 <luqui> sinelaw, yeah i uploaded a new version a couple days ago
10:22:11 <edwardk> cale: plug it into some kind of SMT solver?
10:22:15 <sinelaw> luqui, awesome! hackage or darcs?
10:22:19 <luqui> new semantics:   Image a = R2 -> (Color, a)
10:22:23 <luqui> hackage
10:22:27 <jmcarthur> @oeis 1,1,2,1,3,2,4,1,5,3,6,2,7,4,8,1,9,5,10,3,11,6,12
10:22:28 <lambdabot>  Kimberling's paraphrases: if n = (2k-1)*2^m then a(n) = k.
10:22:28 <lambdabot>  [1,1,2,1,3,2,4,1,5,3,6,2,7,4,8,1,9,5,10,3,11,6,12,2,13,7,14,4,15,8,16,1,17,9...
10:22:36 * sinelaw switches into the closest terminal
10:22:40 <Cale> edwardk: SMT?
10:22:42 <jmcarthur> ^^ was fix (interleave [1..])
10:23:03 * sinelaw still waiting for cabal update to complete...
10:23:05 <edwardk> cale: http://en.wikipedia.org/wiki/Satisfiability_Modulo_Theories
10:23:07 <luqui> sinelaw, I proved impossible for Image a = R2 -> a, so this was the best I could do :-)
10:23:25 <jmcarthur> interesting
10:23:28 <luqui> hackage has been super flaky recently
10:23:28 <Cale> edwardk: I just found that, and figured it must be what you mean :)
10:23:31 <edwardk> cale: i've been shopping around several to use for static contract checking
10:23:36 <Twey> sinelaw: Iterator<Item> it = new Iterator<Item>();  Item i;  while (i = it.next()) { ‚Ä¶ do something ‚Ä¶ }
10:24:02 <luqui> Twey, I think he meant a strict *functional* language
10:24:31 <edwardk> cale: dana xu is using Simplify, for instance, in http://pop-art.inrialpes.fr/~naxu/slides/SCCfH09.pdf
10:24:51 <jmcarthur> luqui: do you mind explaining this monoid-based FRP idea you have?
10:25:12 <edwardk> cale: but i need to incorporate arbitrary theories rather than just a limited notion of linear integer/real constraints.
10:25:17 <luqui> jmcarthur, okay, first thing to realize, it's not an frp idea.  it could maybe be used to implement frp.
10:25:22 <jmcarthur> ah okay
10:25:42 <luqui> jmcarthur, think about riemann integration
10:25:47 <sinelaw> Twey, how is that functional?
10:26:13 <jmcarthur> mmkay
10:26:24 <luqui> jmcarthur, you take some pieces and add them up, and take smaller and smaller and more and more of them until it converges
10:26:30 <jmcarthur> right
10:26:42 <luqui> replace addition by mappend, and that's basically it.
10:26:56 <sinelaw> I prefer the name "Darboux". sounds cooler.
10:27:06 <luqui> each point gets a function f mapping a step size to the monoid.
10:27:12 <luqui> f(0) = mempty and f is continuous
10:27:26 <Cale> The Darboux integral is the right way to define the Riemann integral :)
10:27:36 <edwardk> luqui: the problem is you need to have a notion of multiplication to multiply by with width of the interval as well
10:27:55 <lpsmith> I wonder how accurate the information in the OEIS is... I mean,  I sent in some comments years ago and they got added with little proof on my part :o
10:27:59 <sinelaw> Cale, you mean there's a wrong way?
10:28:00 <luqui> edwardk, "each point gets a function f mapping a step size to the monoid"
10:28:07 <lpsmith> Now,  I know my comments are correct,  but...
10:28:12 <edwardk> luqui: ah missed that
10:28:22 <Twey> sinelaw: As functional as IO
10:28:30 <b_jonas> lpsmith: they ask that you send only verified data, and they have a flag for sequences with unchecked edits
10:28:36 <edwardk> luqui: with some sort of over/underestimation/progress guarantee?
10:28:44 <Cale> sinelaw: Well, apart from the definition which uses tagged partitions and is quite complicated, there is a very popular wrong way.
10:28:50 <luqui> edwardk, probably not...  %-)
10:28:58 <jmcarthur> sounds similar to an idea i fiddled with in the past trying to represent events as dirac pulses in a behavior and transforming them into a stepper of some sort in a semantically consistent way. my thinking was along the lines of an idempotent monoid seemingly applied continuously
10:29:16 <sinelaw> Cale, converging sum of rectangles?
10:29:20 <Cale> sinelaw: The way which takes a limit over breaking the interval up into n *equal* parts is not very good.
10:29:24 <luqui> edwardk, i mean the continuity implies some weak sort of convergence
10:29:36 <sinelaw> Cale, ok but why?
10:29:54 <Cale> sinelaw: because it mishandles various discontinuous functions
10:30:07 <edwardk> luqui: so now the trick is how do you encode common function types, ala conal's K constructors for constant values? in this model you ALWAYS hav to have a function to take that step size down
10:30:31 <b_jonas> lpsmith: quoting http://www.research.att.com/njas/sequences/Submit.html "Thousands of people use the sequence database every day. Please take great care that the terms you send are absolutely correct. The standards are those of a mathematics reference work."
10:30:44 <luqui> edwardk, oh this is not necessarily an implementation.
10:31:03 <lpsmith> b_jonas:  unchecked edits?   Can you edit entries now?    I emailed Dr. Sloane
10:31:15 <Cale> sinelaw: It assigns the "wrong" value to various functions which are Lebesgue or gauge integrable, but not Riemann integrable, like the characteristic function of the rationals.
10:31:25 <luqui> semantics first.  rethinking frp as just "automated integration"
10:31:47 <luqui> Cale, that function doesn't exist
10:31:48 <Twey> sinelaw: You could maybe have something like a fold in reverse: a list is either a null or a pair of an item and a function that returns a new list.
10:31:50 <jmcarthur> luqui: in all fairness, you did say "it could maybe be used to implement frp"
10:31:59 <Cale> luqui: sure it does. It's just not computable.
10:32:00 <Twey> (or ‚Äòthe rest of the list‚Äô)
10:32:01 <jmcarthur> perhaps not what you meant to say
10:32:03 <b_jonas> lpsmith: you can send in stuff through the forms, and I think the new sequence form make the data view up immediately
10:32:04 <edwardk> luqui: so if you want events, you work in the 'Last' monoid
10:32:17 <sinelaw> Cale, what does the Darboux definition do in the case of the characteristic of rationals?
10:32:20 <lpsmith> ahh
10:32:29 <sinelaw> Cale, i've last seen it 4 years ago :(
10:32:35 <lpsmith> I don't think they had that then
10:32:37 <luqui> edwardk, yeah something like that.  there are snags on events though, because f(0) = mempty.
10:32:44 <jmcarthur> if edwardk's speculation is correct it's exactly what my idea a few months ago was
10:32:50 <Cale> sinelaw: You get an upper integral of the interval length and a lower integral of 0
10:32:58 <Cale> sinelaw: and so it's not integrable.
10:33:01 <b_jonas> lpsmith: no, they don't have it right now
10:33:06 <b_jonas> lpsmith: the page says it's down
10:33:07 <jmcarthur> i never did make much of it
10:33:11 <lpsmith> oh
10:33:27 <lpsmith> well, I don't think it was "down" when I made some comments that got added
10:33:37 <lpsmith> I don't quite recall
10:34:17 <sinelaw> Cale, cool! I didn't know that
10:34:21 <edwardk> luqui: well, using Last the mempty interpretation would be that there is no value yet, kinda ugly if only because you always need to think about the equivalent of 'null' handling
10:34:31 <luqui> jmcarthur, well, implement semantically.  frp needs a new semantics.  strength of haskell functors requires classic frp to manage a global collection of behaviors, in a sense, which i consider too much to hope for
10:34:35 <Cale> With the n-equally-spaced-samples version, you basically get 1 if the endpoints of your interval are rational, and 0 if not.
10:35:20 <Cale> and so the usual result that integral from a to b of f + integral from b to c of f = integral from a to c of f  fails miserably
10:35:20 <luqui> edwardk, well rather, what happens *at* the time the event occurs.  f(0) ought to be equal to the event there.
10:35:49 <edwardk> ah.
10:36:12 <luqui> so that's why i'm thinking about weak derivatives and other such nonsense.
10:36:16 <edwardk> ok, your f 0 = mempty comment makes sense. feels like a continuous vs. a discrete distribution
10:36:29 <Cale> The n-equally-spaced-samples definition works okay for continuous functions though.
10:36:36 <lpsmith> @let cubic_residues n = length (group (sort (map ((`mod` n) . (^3)) [0..n-1])))
10:36:38 <lambdabot>  Defined.
10:36:47 <edwardk> so you're back to generalized functions ala the dirac delta.
10:36:56 <jmcarthur> yup
10:36:56 <edwardk> to get semantics that cover both
10:37:03 <lpsmith> > map cubic_residues [1..20]
10:37:04 <lambdabot>   [1,2,3,3,5,6,3,5,3,10,11,9,5,6,15,10,17,6,7,15]
10:37:09 <luqui> edwardk, yeah.
10:37:22 <edwardk> which isn't terrible, but it costs you your f 0 = mempty guarantee
10:37:32 <luqui> edwardk, events as set with union monoid makes sense, it's obvious how to talk about the integral of that.  just... what is the derivative of that integral?
10:37:41 <lpsmith> @oeis 1,2,3,3,5,6,3,5,3,10,11,9,5,6,15,10,17,6,7,15
10:37:42 <lambdabot>  Number of distinct cubic residues mod n.
10:37:42 <lambdabot>  [1,2,3,3,5,6,3,5,3,10,11,9,5,6,15,10,17,6,7,15,9,22,23,15,21,10,7,9,29,30,11...
10:38:13 <lpsmith> @let quartic_residues n = length (group (sort (map ((`mod` n) . (^4)) [0..n-1])))
10:38:13 <edwardk> luqui: well, in the generalized function setting you'll find points where it doesn't exist or is a very precise form of infinity ;)
10:38:14 <lambdabot>  Defined.
10:38:21 <lpsmith> > map quartic_residues [1..20]
10:38:22 <lambdabot>   [1,2,2,2,2,4,4,2,4,4,6,4,4,8,4,2,5,8,10,4]
10:38:39 <lpsmith> @oeis 1,2,2,2,2,4,4,2,4,4,6,4,4,8,4,2,5,8,10,4
10:38:40 <lambdabot>  Number of distinct 4th powers mod n.
10:38:40 <lambdabot>  [1,2,2,2,2,4,4,2,4,4,6,4,4,8,4,2,5,8,10,4,8,12,12,4,6,8,10,8,8,8,16,4,12,10,...
10:38:42 <lpsmith> ;-)
10:38:53 <luqui> edwardk, an inverse infinitesimal, as it were
10:39:01 <edwardk> yeah
10:39:30 <luqui> anyway i'm beginning to *think* that i'm *thinking* too much and maybe i should just hack something up not worrying about the details
10:39:34 <luqui> to see the general form of such a thing
10:39:34 <sinelaw> edwardk, i like the idea of dirac deltas as events. can you explain the problems with that?
10:40:03 <lpsmith> @let binomial_residues n = length (group (sort (map ((`mod` n) . (product [n-2..n] `div` product [1..3])) [0..6*n-1])))
10:40:04 <lambdabot>  <local>:3:61:
10:40:05 <lambdabot>      Occurs check: cannot construct the infinite type: a = a1 ...
10:40:31 <luqui> sinelaw, it's just kind of yucky.  eg.  what if f(x) = d(0)  for every x in some interval.  wtf does that mean?
10:40:57 <luqui> sinelaw, you have to go the way of weak derivs, defining "functions" in terms of their own integrals
10:40:57 <sinelaw> luqui, you can ask the same about the original dirac delta
10:41:04 <luqui> sinelaw, yes exactly.
10:41:10 <sinelaw> luqui, dirac's delta isn't a function, right.
10:41:19 <lpsmith> @let binomial_residues n = length (group (sort (map ((`mod` n) . (((n-2) * (n-1) * n) `div` 6)) [0..6*n-1])))
10:41:21 <lambdabot>  <local>:3:61:
10:41:21 <lambdabot>      Occurs check: cannot construct the infinite type: a = a1 ...
10:41:23 <sinelaw> it's a distribution
10:41:29 <luqui> sinelaw, dirac deltas as computable entities is tricky business.
10:41:31 <lpsmith> well, anyway
10:41:52 <luqui> sinelaw, i would like to use them in semantics, but not allow you to explicitly state one.
10:41:54 <jmcarthur> dirac pulses is what scared me away from this line of thinking in the first place
10:41:56 <lpsmith> all those sequences are multiplicative
10:42:13 <jmcarthur> i don't think i like them in semantics
10:42:18 <sinelaw> ludflu, defined in a vector space of L2 functions
10:42:26 <sinelaw> oops .. luqui
10:42:33 <lpsmith> The size of the image of any integer-preserving polynomial modulo n is a multiplicative function of n
10:42:38 <sinelaw> one of you guys has to change a nick. sorry
10:42:54 <jmcarthur> i like the idea of unifying events with behaviors, but i don't like what it seems like the consequences are
10:43:04 <sinelaw> jmcarthur, what are they?
10:43:04 <luqui> it's usually luite (sry) getting my attention
10:43:11 <copumpkin> lol
10:43:14 <lpsmith> I haven't found that result explicitly in the number theory literature,  but I'm told it's pretty obvious theorem to the experts
10:43:28 <sinelaw> lpsmith, "It's easy to show that..."
10:43:37 <luqui> jmcarthur, think about their *integrals*
10:43:47 <luqui> jmcarthur, the integral of an event is a nice thing
10:43:55 <luqui> the event itself is the bad thing
10:44:24 <sinelaw> luqui, incidentally, integrals (accumulation) are apparently something "special" in FRP sense
10:44:44 <luqui> sinelaw, what do you mean by special?
10:45:19 <edwardk> back
10:45:22 <sinelaw> luqui, I wish I knew. but maybe having behaviors defined as integrable distributions is not a limiting constraint anyway
10:45:36 <sinelaw> I mean, which behaviors can you think of that are not?
10:45:47 <luqui> sinelaw, any behavior of not-a-vector-space
10:45:49 <sinelaw> divergent ones
10:46:15 <sinelaw> luqui, I mean in some yet-to-be-defined sense of integrals for more than vector spaces
10:46:26 <edwardk> well, if you assume your function has a derivative, except at a finite number of dirac-like pulses you can at least compose a theory that covers most of the interesting cases
10:46:49 <luqui> edwardk, hopefully a not too ugly one
10:47:15 <luqui> sinelaw, but yes, that is the assumption i'm following
10:47:45 <luqui> sinelaw, it's conal's idea originally (*surprise*), that the only way information gets carried from one time to another is continuously
10:47:58 <edwardk> luqui: also i would argue that perhaps you don't want to generate just a function from stepsize -> value, but from stepsize -> (value, position-in-interval -> stepsize -> (value, ....))
10:48:02 <lpsmith> @let cubic_binomial_residues n = length $ group $ sort $ map (\x -> product [x-2..x] `div` 6) [0..6*n-1]
10:48:04 <lambdabot>  Defined.
10:48:06 <luqui> "looking into the past" and the future are both disallowed.
10:48:13 <edwardk> luqui: so you can extract progressively more refined functions
10:48:35 <lpsmith> > map cubic_binomial_residues [1..20]
10:48:37 <lambdabot>   [4,10,16,22,28,34,40,46,52,58,64,70,76,82,88,94,100,106,112,118]
10:48:41 <sinelaw> luqui, yeah i discussed that with him not long ago
10:48:51 <lpsmith> err
10:48:55 <lpsmith> @undefine
10:48:58 <luqui> edwardk, oh yeah, return a refinement continuation
10:49:08 <luqui> edwardk, is that something a monoid structure could do for me?
10:49:11 <lpsmith> @let cubic_binomial_residues n = length $ group $ sort $ map (\x -> (product [x-2..x] `div` 6) `mod` n) [0..6*n-1]
10:49:12 <lambdabot>  Defined.
10:49:15 <lpsmith> > map cubic_binomial_residues [1..20]
10:49:16 <lambdabot>   [1,2,3,4,3,6,5,8,9,6,7,12,9,10,9,16,11,18,13,12]
10:49:32 <lpsmith> @oeis 1,2,3,4,3,6,5,8,9,6,7,12,9,10,9,16,11,18,13,12
10:49:33 <lambdabot>  Sequence not found.
10:49:33 <sinelaw> luqui, conclusion being that some sort of notion of polymorphic integration is required
10:49:44 <edwardk> luqui: well, the nature of it i think is going to be particular to the way you want to implement these generalized functions
10:50:18 <luqui> mm aye.  that proof will be in the pudding.
10:50:27 <luqui> such things are much better for a language to figure out than a brain... ime
10:50:45 <edwardk> luqui: heh
10:50:59 <luqui> i think i am just too imaginative.  i imagine the impossible.  which is a drawback for a programmer.
10:51:07 <luqui> (or mathematician)
10:51:32 <luqui> i need a type system on my brain :-)
10:51:45 <c_wraith> I'm not sure it's a drawback
10:51:51 <c_wraith> so long as you're not working alone.
10:51:57 * edwardk is a bit of a plodder. i try to start with some ground truth and elaborate plausible systems around it
10:52:27 <edwardk> unfortunately, i'm not so good at relying on the 'tools in the room'
10:52:42 <koeien37> and I'm idealess :(
10:52:44 <sinelaw> edwardk, yeah, need to know them first
10:52:51 <luqui> i'm going to try to cultivate what happened with my rewrite of graphics-drawingcombinators (which seems to be the same thing that happened to conal's AD paper)
10:52:56 <lpsmith> heh,  the effort that it takes to figure out the "tools in the room" can be daunting
10:53:02 <luqui> where i started with a semantic domain and operations i was interested in, and the module wrote itself.
10:53:15 <edwardk> sinelaw: i'm pretty good about knowing them, but i have too much of a penchant for reading current research papers and then trying to string together all of their ideas ;)
10:53:15 <conal> luqui: :) !
10:53:29 <conal> luqui: have you blogged about that experience?  will you?
10:53:39 <conal> luqui: i want people seeing more denotational design!
10:53:40 <sinelaw> edwardk, that's a start. i read the research papers without knowing the basics
10:53:54 <luqui> conal, i started one but wasn't clear.  i'll try again, thanks for the encouragement :)
10:54:13 <edwardk> sinelaw: most of my problems arise from a lack of time to apply elbow-grease these days, not a lack of domain knowledge =/
10:55:04 <luqui> edwardk, any more domain knowledge on your part and the computer's brain will explode
10:55:08 <sinelaw> i'm imagining that by having insufficient background, i may have a different perspective (and that it may be advantageous)
10:55:09 <luqui> and not in the cute GHC way
10:55:32 <edwardk> luqui: exploding computers has been a bit of a problem =)
10:55:43 <luqui> haha
10:55:50 <edwardk> luqui: i did just melt the cpu on my last machine =)
10:55:55 <luqui> how?
10:56:03 <edwardk> lack of proper cooling will do that
10:56:38 <b_jonas> does anyone know a haskell library that gives me a priority queue (like binary heap) datastructure indexable by a secondary key? you know, the kind of thing you need for a general Dijkstra algorithm.
10:56:49 <luqui> ah.  so it wasn't your trace architecture producing code that was just so cool it was hot
10:56:50 <edwardk> moving to a water cooled case shortly actually
10:56:54 <edwardk> luqui: =)
10:56:55 <b_jonas> I can write one if there isn't, but there probably must be one on hackage or something.
10:57:09 <sinelaw> "You want me to be cool, but I'm not. I'm HOT!" (Bootsy)
10:57:39 <edwardk> luqui: nah. moved the tracing a level up. now each thunk knows both a bytecode and blind native implementation, when i go to trace i trace bytecode instead
10:58:00 <edwardk> luqui: that way i can punt thinking about my older tracing jit for a while
10:58:26 <edwardk> luqui: too many hacks required to trace native code without LOTS of debug info
10:58:35 <edwardk> (and even then)
10:58:40 <jlouis> b_jonas: Data.PSQueue the Hinze paper uses it for a Dijkstra
10:58:47 <luqui> edwardk, yeah i was pretty baffled when you told me you were doing that
10:59:11 <jlouis> b_jonas: and gains a Prim by changing a single line to add
10:59:18 <luqui> in the "um... i would touch that with a adamantium pole" kind of way
10:59:23 <luqui> *wouldn't
10:59:43 <edwardk> luqui: well, it WORKS, but i have to rely on the ABI, and that you don't do anything tricky referencing across stack frames, and and and.
10:59:57 <b_jonas> jlouis: which library is that in?
11:00:21 <edwardk> i'd touch it with an adamantium pole, if only coz it'd be cool to have an adamantium pole. then i'd have to figure out a way to breach the 4th wall and escape the comic book i was in.
11:00:33 <jlouis> b_jonas: PSQueue on hackage
11:00:43 <b_jonas> jlouis: thanks
11:00:46 <luqui> edwardk, you could bust into the movies and use unobtanium
11:01:00 <luqui> edwardk, or bust into xkcd and imagine a way to bust out of an imagination etc...
11:01:10 <jlouis> b_jonas: perhaps it is not exactly what you need, but it can be used for a fast Dijkstra
11:01:34 <jlouis> Actually, Cale prodded me in that direction a couple of days ago
11:01:38 <edwardk> luqui: well, the day xkcd starts rambling on about kan extensions i'll know that i have won ;)
11:01:50 <luqui> :-)
11:01:56 <b_jonas> I don't want to use it for Dijkstra
11:02:18 <luqui> wow 21 hrs of wake so far. i'm doing ok...
11:02:20 <c_wraith> I'm amazed xkcd hasn't discovered haskell
11:02:24 <luqui> gonna go get some food
11:02:38 <sinelaw> luqui, i've had that experience more than once last week.
11:02:48 <b_jonas> I want to use it for things like forgetful Maps (which forget the oldest touched elements if they grow too large) or priority queues from which I can cancel elements
11:02:51 <b_jonas> and the like
11:03:07 <jmcarthur> luqui: i agree with you on the integrals of events being good and the events themselves being bad, but an integral implies something to integrate, i think. i'm just not so sure i like exposing that in the semantics
11:04:44 <sinelaw> jmcarthur, dirac deltas are also used only in the context of integrals
11:05:17 <jmcarthur> sinelaw: pretty much, yeah
11:06:29 <sinelaw> jmcarthur, btw, the idea of convolution with impulse response is pretty awesome. maybe we can generalize that to "event response"
11:06:51 <jmcarthur> yeah, that is one of the things i like about the idea
11:07:10 <jmcarthur> requires a good meaning for (+)
11:07:27 <sinelaw> jmcarthur, and it only makes sense when there is a continuous version of the event your have the response for
11:07:57 <sinelaw> *you
11:08:06 <__JN> Hello, can anyone help me with a little function? I'm trying to manipulate a string e.g. "hello" into the string "'h':'e':'l':'l':'o'". I've tried "fix cs = map (\c -> ('\'':c:'\'')++) cs" but that obviously won't work...
11:08:13 <lpsmith> c_wraith:  maybe the author needs some prodding, somehow ;-)
11:08:17 <sinelaw> jmcarthur, so i'm not sure we can do anything with that
11:08:46 <edwardk> luqui: hrmm, i worry that in the end, playing around with a finite/countable number of discontinuities will lead you right back to the behavior/event model from reactive ;)
11:08:57 <c_wraith> > gshow "hello"
11:08:59 <lambdabot>   "\"hello\""
11:09:08 <c_wraith> heh.  there *is* a special case in gshow
11:09:41 <lpsmith> __JN:  you could write a simple recursive function :)
11:09:50 <sinelaw> can anyone summarize the problems (in his/her mind) in the current reactive model?
11:09:54 <sinelaw> *Reactive
11:10:23 <jmcarthur> my biggest problem with it is that Event is not a law-abiding monad
11:10:30 <sinelaw> i know conal thinks there is "junk", in the sense that you can access the past (or future?)
11:10:39 <c_wraith> > intercalate ":" . map (\x -> '\'':x:'\'':[]) $ "foo"
11:10:41 <lambdabot>   "'f':'o':'o'"
11:10:43 <sinelaw> at least I think that's what he means
11:10:43 <edwardk> sinelaw: memory leaks, and unamb is rather heavy-weight
11:10:59 <sinelaw> edwardk, those are implementation details, no?
11:11:02 <jmcarthur> i also am not a big fan of the inconsistencies between Event's semantic function and its Monoid instance's semantics
11:11:10 <c_wraith> bah, what's the variant on intercalate.  intersperse?
11:11:15 <c_wraith> :t intersperse
11:11:16 <edwardk> sinelaw: the question is whether or not an implementation without those details can exist =)
11:11:16 <lambdabot> forall a. a -> [a] -> [a]
11:11:19 <conal> sinelaw: ah yes.  as i've discussed with luqui as well.  i'm writing a blog post about that observation.
11:11:24 <jmcarthur> Event has a lot of auxillery semantic functions which are not directly related to its semantic representation
11:11:39 <__JN> c_wraith: Thank you! Great!
11:11:44 <c_wraith> > intersperse ':' . map (\x -> '\'':x:'\'':[]) $ "foo"
11:11:45 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
11:11:46 <lambdabot>         against inferred type...
11:11:47 <jmcarthur> and yet are used in type class specifications
11:11:57 <conal> jmcarthur: me too.  a benefit of TCM analysis is that it reveals this misfeature.
11:12:17 <c_wraith> __JN: It's a kind of bad approach.  I recommend you draw inspiration from it for something better. :)
11:12:17 <edwardk> i've been trying to see if one of the kata language design bits can support a more efficient unamb, but i have a ways to go before i'm ready to build a usable FRP implementation in it.
11:12:31 <conal> jmcarthur: and rightly so.  [(T,a)] is too implementation-driven.
11:12:40 <sinelaw> conal, i'm ready for your comments if you have time
11:12:46 <edwardk> that and i'd need to either special case unamb in the compiler, or expose more information about the current speculation continuation to user space
11:12:51 <c_wraith> > intersperse ':' . concatMap (\x -> '\'':x:'\'':[]) $ "foo"
11:12:53 <lambdabot>   "':f:':':o:':':o:'"
11:13:01 <c_wraith> heh.  oops
11:13:16 <conal> sinelaw: let's
11:13:18 <jmcarthur> conal: i like the semantics for Future, not for Event. i also like that Future and Behavior form an adjunction, which i think would be an interesting area to explore
11:13:22 <c_wraith> But that should give you an idea of a better approach
11:13:38 <conal> jmcarthur: ditto.  very nice sign.
11:14:08 <__JN> c_wraith: maybe so :) I'll get on with it
11:14:21 <jmcarthur> but when i think about it i run into things like "what is a Behavior (Future a)?"
11:14:41 <conal> denotational design, especially with TCM, makes it *much* clearer to me what's an elegant design and what's not so elegant.
11:14:41 <Veinor> I forget, what do you call a type with a type variable in it
11:14:47 <Veinor> like the type of head, tail, etc.
11:14:52 <Ke> so does leksah need sources to be build with documentation?
11:14:54 <jmcarthur> so i suspect maybe i am thinking about Future whereas perhaps i should be thinking about something else with (t, a) semantics
11:15:00 <conal> confirming my intuition and yet an fairly objective measure
11:15:05 <edwardk> veinor: parametrically polymorphic?
11:15:21 <Veinor> Thank you.
11:15:26 <jmcarthur> a different monoid for t, perhaps
11:17:20 <lpsmith> Metastability is consequence of trying to map a continuous domain to a discrete domain.   Would this observation from digital electronics have some kind of bearing on FRP?
11:18:10 <edwardk> lpsmith: you want edge triggered frp? =)
11:18:27 <sinelaw> heh
11:18:30 <jmcarthur> lpsmith: i would say that if we suffer from problems like that then we are exposing our time step in our semantics, which i would consider a discrete semantics
11:18:53 <edwardk> lpsmith: or worse having to type check if my programs are hazard free so you can use the continuous output
11:19:11 <edwardk> hrmm, hazard free
11:19:23 <sinelaw> i hate metastability
11:19:31 <sinelaw> must not expose that!
11:19:38 <edwardk> what would be the right domain to think about frp from an asynchronous circuit design perspective
11:20:04 <jmcarthur> analog circuits?
11:20:38 <edwardk> jmcarthur: well, i'm thinking in the context of asynchronous circuit hazards. you wind up with more complicated interconnections to kill the global clock
11:20:46 <edwardk> isn't that ultimately the current problem with frp?
11:20:52 <edwardk> very much at a pie in the sky level
11:20:58 <lpsmith> well, metastability is an issue in synchronous design as well,  it's just that electrical engineers put a lot of effort into making metastability for any length of time highly improbable
11:21:22 <lpsmith> or rather,  metastability that approaches the length  of a clock cycle...
11:21:45 <edwardk> lpsmith: yeah, but that mostly becomes a clock signal distribution problem
11:22:33 * sinelaw is wondering how other people manage to know both about that kind of stuff and CS
11:22:38 <sinelaw> and math
11:22:39 <jmcarthur> edwardk: i wouldn't say that's the problem, just an obstacle that must be overcome in whatever implementation you use
11:22:46 <edwardk> jmcarthur: fair enough
11:23:01 <sinelaw> there's a device that synchronizes asynchronous resets, for example
11:23:15 <jmcarthur> the problem is still largely semantics, i think
11:23:34 <Cale> sinelaw: Mostly just by spending lots of time on everything.
11:24:08 <sinelaw> Cale, time is a scarce resource for me
11:24:14 * hackagebot upload: hdigest 1.0 - Server-side HTTP Digest (RFC2617) in the CGI monad (JameySharp)
11:24:24 <edwardk> jmcarthur: so the question i'm toying with is what is the analogue of an asynchronous circuit for FRP? you have inputs that can change at arbitrary times, but they don't change at the same time step, and might both be changing at the same time, so you need to implement the circuit to be hazard free to avoid glitching the output
11:24:40 <edwardk> because you're now asynchronous, so your output signal has meaning at all times, not just on the edge
11:25:12 <jmcarthur> edwardk: sounds like composing stepper behaviors, to me
11:25:16 <sinelaw> edwardk, isn't that simply an FRP system with behaviors and logic that can cause glitches?
11:25:18 <edwardk> you can model that in a circuit by adding a bunch of requirements on the output map, but i have no idea what the domain/types would look like to build that for domains that aren't little boolean circuits
11:25:28 <BMeph> sinelaw: How about how do they know about all this, and CT? ;)
11:25:54 <edwardk> sinelaw: the question i have is a.) how to type check it, and b.) how to synthesize a hazard free implementation given a fairly high level programmatic specification
11:26:26 <lpsmith> glitches don't necessarily result from metastability
11:26:36 <lpsmith> actually, usually they don't
11:26:47 <sinelaw> yeah, they can result from simple logic with different time lags
11:26:50 <jmcarthur> edwardk: are you asking how you would model such a system using FRP, or are you asking how you would design a safe system using a model in FRP?
11:26:53 <sinelaw> along different paths
11:27:20 <jmcarthur> edwardk: the former would be mostly steppers, i think, and the latter would be using whatever tricks you would normally use in asynchronous circuit design
11:27:39 <jmcarthur> *using such a model
11:28:09 <Cale> BMeph: How could you stand to know all that and go without knowing any CT? :)
11:28:10 <edwardk> lpsmith: no they don't, they mostly arise from the fact that you don't have as much coverage over each of the input phase changes. if you look at, say a Karnaugh map of a small circuit instead of having the smallest covering set reduced to normal form, you need to make sure there is a case that doesn't change state when you 'slide' an input from 0 to 1 or vice versa.
11:28:16 <edwardk> for 1-stability
11:28:40 <jmcarthur> i think i still misunderstand the analogy, really
11:28:58 <lpsmith> that's a hazard,  not necessarily a glitch,  IIRC
11:29:22 <edwardk> lpsmith: sorry, haven't thought about this space in a couple years
11:29:25 <lpsmith> heh
11:29:30 <lpsmith> no problem :)
11:29:44 <lpsmith> it's been a few years for me as well
11:29:57 <edwardk> jmcarthur: well, the asynchronous guys don't have to deal with potentially continuous domains =)
11:30:07 <jfoutz> wow. frp's been getting a lot of attention lately.
11:30:32 <jmcarthur> edwardk: i wouldn't say an frp implementation must be asynchronous, if that's what you are getting at
11:31:16 <edwardk> jmcarthur: what i was looking for was how to borrow tools from asynchronous circuit design to see if you can try to use them to work towards the death of the global clock in frp, and if so, how to avoid hazards/glitches in such an FRP where you want continuous time
11:32:43 <edwardk> jmcarthur: this is a fair bit less formed than luqui's monoidal FRP thing =)
11:36:40 <jmcarthur> edwardk: oh you are speculating about a truly concurrent *implementation* of FRP
11:38:28 <jmcarthur> well, time to go grab lunch
11:39:05 <copumpkin> omg
11:39:21 <edwardk> checking logs to see what i missed
11:40:46 <Athas> Anyone here with CHP experience?  I am seeing unusual behaviour with the console process stuff.
11:40:46 <bob0> Athas: no
11:43:34 <copumpkin> edwardk: nothing
11:43:41 <copumpkin> oh wait
11:43:44 <copumpkin> two messages from jmcarthur
11:43:49 <copumpkin> jmcarthur: edwardk: oh you are speculating about a truly concurrent *implementation* of FRP
11:43:50 <copumpkin> [8:38pm] jmcarthur: well, time to go grab lunch
11:43:55 <edwardk> it dropped a couple of my messages, but i forgot what i'd said ;)
11:44:12 <edwardk> anyways
11:44:15 <edwardk> </rant> ;)
11:47:19 <mauke> does anyone here happen to have the pdf from http://portal.acm.org/citation.cfm?doid=363347.363387 ?
11:47:19 <bob0> mauke: no
11:47:29 --- mode: ChanServ set +o mauke
11:47:29 --- kick: bob0 was kicked by mauke (mauke)
11:47:32 <Botje> want me to grab it for you?
11:47:37 <mauke> yes, that would be nice
11:48:10 <Botje> hmm
11:48:14 <Botje> my uni is acting up
11:48:20 <koeien37> i can do it too probably
11:48:29 --- mode: mauke set -o mauke
11:48:31 <conal> sinelaw: ping
11:50:02 <mauke> danblick: sending from 192.168.56.1 won't work
11:52:51 <Botje> mauke: see /msg
11:53:11 <mauke> koeien37 wins
11:53:38 <mauke> koeien37, Botje, danblick: thanks, got it
11:53:42 <Botje> aww :p
11:53:52 <paolino> that is a 1968 book, it should be available for  everyone ...
11:54:04 <koeien37> mathematicians are idiots
11:54:11 <pikhq> koeien37: How so?
11:54:24 <koeien37> http://www.win.tue.nl/~aeb/soc/access.html
11:54:26 <sinelaw> bob0 sounded like a bot
11:55:26 <pikhq> koeien37: Non sequitur.
11:55:42 <mauke> how does that not follow?
11:55:48 <Botje> yay! we're all partners in a copyright violation!
11:55:57 <pikhq> mauke: It does not follow that not sharing = idiots.
11:56:17 <paolino> the point of idiots is not not sharing
11:56:19 <pikhq> Though I will admit, it is rather foolish of them.
11:56:28 <pikhq> And the same is true of most of the rest of academia...
11:56:40 <Cale> Yeah, it's not really specific to mathematics
11:56:42 <koeien37> I'm not really interested in a debate on this now, sorry
11:56:51 <pikhq> koeien37: I
11:57:08 <pikhq> 'm agreeing with most of what you say, just saying that them being foolish about that doesn't make them complete idiots.
11:57:24 <Baughn> Is anyone going to sue me for always using Double for timestamps?
11:57:27 <ray> you can't assert things and then suddenly say you're not really interested in a debate on this now, you started it
11:57:34 <Cale> Things are getting better too. Most people put their papers online somewhere accessible.
11:58:12 <Saizan> for the future, a statement like "not making your work freely available is stupid" is less likely to start a debate :)
11:58:19 <paolino> Cale, that is my question really, is ACM having less or more papers lately ?
11:58:45 <Saizan> paolino: lots of papers are both on ACM and on the author's homepage
11:59:02 <Cale> Even if something is published by a closed publisher, you usually can get it from that guy's own website.
11:59:23 <paolino> Saizan, that's even worse :)
12:00:04 <Cale> But the publishing companies are leeches, and really ought to be excised from the whole academic process.
12:00:51 <Nomad010> they charge my university an exorbitant fee just to read the papers
12:01:10 <edwardk> Baughn: that entirely depends on the nature of your work ;)
12:01:20 <MoALTz> i don't enjoy trying to find papers on something and just get springerlink results in google. it's even more annoying that the search results link to .pdf's that instead redirect you to a page demanding payment (googlebots can access them fine...)
12:01:44 <Nomad010> not sure what ACM charges, but IEE charges a crap load
12:01:55 <edwardk> MoALTz: clearly what you need to do is change your agent string to say 'GoogleBot ...'
12:02:04 <Baughn> edwardk: Timestamps, TTL, etc. ;)
12:02:17 <danblick> i have been unable to get "Simple computation of LALR(1) lookahead sets" for a while now :(
12:02:25 <MoALTz> edwardk: that hasn't worked for the last few years iirc
12:02:35 <Baughn> edwardk: I'll confess: I don't see any problem with a slightly approximate time, but everyone seems to react in shock at the suggestion.
12:02:35 <Nomad010> lol danblick
12:02:54 <MoALTz> google suggests using reverse dns to verify that the client claiming to be googlebot is actually googlebot
12:02:58 <Nomad010> compilers books
12:02:58 <Cale> http://www.win.tue.nl/~wsinswan/softwaretools/material/DeRemer_Pennello.pdf
12:03:07 <Cale> danblick: ^^
12:03:48 <edwardk> MoALTz: the springerlink ones are the worst. i've paid for the ACM ones for years, but I can't bring myself to spend $30/paper. there is no affordable option for springer et al. if you aren't an academic at an institution.
12:04:00 <danblick> Cale: thanks but thats a different paper - http://dx.doi.org/10.1016/0020-0190(89)90079-3
12:04:32 <b_jonas> is there a big table for precedence and fixity of haskell operators which includes stuff in modules?
12:04:34 <Cale> danblick: oh, sorry, missed the slight title change :)
12:05:22 <lpsmith> see,  I still have a unix account at my undergraduate institution, and I can wget ACM papers there.
12:05:34 <lpsmith> Not springerlink,  AFAICT
12:05:38 <mauke> get all of them
12:05:53 <copumpkin> lpsmith: ooh nice, they let you keep it :o
12:06:53 <edwardk> mauke: downloading the internet is taking too long =)
12:07:10 <MoALTz> i wonder if you could make a charity and add them as a coauthor for each paper you release (so that the charity can host the paper too)
12:07:18 <mauke> not the internet, just as many papers as possible
12:07:55 <sinelaw> btw, doesn't the idea of getting rid of "access to past/future" lead to something like Yampa's non-first-class Signals?
12:10:32 <edwardk> i'm rather fond of cutting access to anything except the ever-changing now, the question is how to do that cleanly without turning to arrows =)
12:11:01 <jfoutz> you could hide the time constructor, but allow conversion to a number. That'll avoid the arrow madness.
12:11:21 <sinelaw> why are the arrows bad?
12:11:31 <sinelaw> except for the argument grouping which i hate
12:11:33 <sinelaw> the tuples
12:11:37 <edwardk> sinelaw: syntax syntax syntax
12:11:51 <sinelaw> edwardk, that's not a reason to hate a semantic model
12:11:52 <monochrom> I like the proc-do notation for arrow.
12:12:08 <edwardk> sinelaw: the argument grouping you mention falls under syntax ;)
12:12:16 <sinelaw> besdies, the proc-do isn't bad, as monochrom mentions
12:12:28 <monochrom> Best thing since arrow. XD
12:12:33 <sinelaw> edwardk, does it? it's not about how you type the arrow into a text file, it's about how it is modelled
12:12:48 <sinelaw> and the tuple is modelled
12:13:04 <sproingie> if you can't see how it's modeled by reading it, then the syntax has a problem
12:13:08 <stepcut> is the base-4 flag in the .cabal file documented anywhere?
12:13:26 <edwardk> sinelaw: arrows have the additional restriction that you can't really manipulate the shape of future computation with what came before without appealing to ArrowApply or whatever its called, which makes you into a monad without telling you.
12:13:42 <monochrom> I guess after much currying you develop a taste for currying and against uncurrying.
12:13:47 <kmc_> "arrow" is also a bad name
12:13:51 <kmc_> fwiw
12:13:53 <sinelaw> monochrom, yip
12:14:02 <Saizan> stepcut: Flags are defined inside the .cabal files where they are used.
12:14:31 <stepcut> Saizan: but the base-4 flag gets automatically set somehow when base-4 is available..
12:14:52 <stepcut> Saizan: when I compile happstack on base-3 vs base-4, I don't have to specify anything explicitly on the command-line
12:15:01 <sinelaw> edwardk, i don't know what you mean
12:15:04 <Cale> edwardk: Well, there is ArrowMonad for instances of ArrowApply
12:16:16 <edwardk> cale: yes, but when you're an instance of ArrowApply, i find the notion of just using the monadic sugar far more compelling. =)
12:16:24 <Cale> edwardk: right
12:16:33 <Saizan> stepcut: it's if that's bidirectional like that
12:16:38 <edwardk> cale: you can go there through that instance, but then why did you bother with the arrows in the first place
12:16:48 <Cale> hmm, is ArrowMonad really the right thing? If ArrowApply a, then shouldn't we have an instance of Monad (a e) effectively?
12:16:54 <stepcut> Saizan: ?
12:17:14 <Saizan> stepcut: if the default value for the flag would cause configure to fail, it gets flipped.
12:17:36 <edwardk> thats just a reader transformed version of the arrow apply machinery
12:17:52 <Cale> hmm
12:17:54 <Saizan> stepcut: so it's the fact that if it's true you depend on base >= 4 that makes it false when there's no base >= 4
12:18:02 <Cale> edwardk: are you sure?
12:18:39 <edwardk> cale: no =)
12:18:57 <Saizan> stepcut: unless the user explicitly sets a value for it
12:19:03 <stepcut> Saizan: so if I have,  if flag(base4) \n Build-Depends:       base >= 4 && < 5 \n else \n     Build-Depends:       base < 4
12:19:04 <Cale> It seems to me that there would be possibly much richer things of type a e b than e -> a () b
12:19:22 <stepcut> Saizan: the base4 flag is getting set because ??
12:19:33 <monochrom> @type (>=>)
12:19:35 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
12:19:52 <edwardk> newtype ArrowMonad a b = ArrowMonad (a () b) -- but when you switch to: ArrowMonad a e b = ArrowMonad (a e b) -- all you've done is plumb through the extra e
12:20:00 <monochrom> I agree that if you have ArrowApply you may as well use Monad and do-notation and >=>
12:20:03 <edwardk> cale: the reader i'm thinking of is w.r.t to the original arrow, not Hask
12:20:17 <Saizan> stepcut: well, if you've only base-3 installed the flag base4 gets set to false because otherwise you couldn't fulfill the dependencies
12:20:52 <Saizan> stepcut: basically it tries all the flag assignments, starting from the default one, until it finds one that works
12:21:09 <stepcut> Saizan: how odd..
12:21:25 <Saizan> it's just a tiny bit of logic programming :P
12:21:27 <Cale> edwardk: okay. The newtype is only there to make the typeclass machinery happy anyway, right?
12:21:40 <Twey> @info ArrowMonad
12:21:41 <lambdabot> ArrowMonad
12:21:44 <Twey> Argh
12:21:47 <Cale> I don't understand why you'd want to restrict the input type.
12:21:58 <edwardk> cale: instead of  ArrowMonad m >>= f = ArrowMonad (m >>>  arr (\x -> let ArrowMonad h = f x in (h, ())) >>> app) -- just plumb through the e you're given.
12:22:25 <Twey> Ah, huh
12:22:27 <monochrom> @noinfo ArrowMonad
12:22:27 <lambdabot> Unknown command, try @list
12:22:35 <Cale> hmm... I see what you mean
12:22:39 <monochrom> @info0 ArrowMonad
12:22:39 <lambdabot> Unknown command, try @list
12:22:41 <edwardk> cale: so you don't have to carry the environment to plumb it through?
12:22:45 <sinelaw> jmcarthur, convolution is meaningless in non-linear systems
12:22:47 <monochrom> @botcrack
12:22:47 <lunabot>  :o
12:22:47 <lambdabot> :)
12:23:15 <sinelaw> do we want a "linear" frp system?
12:23:26 <sinelaw> i think not
12:23:42 <edwardk> cale they can just drop in a (), which saves a reference to the argument 'e' in every captured closure built out of an arrow monad, and whenever you DO care about it, you can always inject it yourself
12:24:27 <edwardk> although at the cost of having to go through an another arr and >>>
12:24:50 <jmcarthur> sinelaw: heh
12:25:26 <jmcarthur> sinelaw: a type constraint could prevent us from being stupid with it
12:25:34 <edwardk> cale: you did however, just talk me into adding the arrow monad to kata ;)
12:25:55 <edwardk> (i didn't have a stock unit type anywhere to appeal to)
12:28:11 <xerox> copumpkin what was that library of mathematics-related haskell modules?
12:28:23 <copumpkin> xerox: haskell for maths?
12:28:48 <Raynes> I read that as "Haskell for meth?"
12:28:59 <Raynes> I did not want to see where that was going.
12:29:08 <Cale> sinelaw: Which sense of convolution and linear are you using there?
12:29:37 <sinelaw> Cale, of systems. additivity and scaling of inputs causes likewise in output
12:30:06 <sinelaw> for any sense of those two, i guess, which is consistent with how you define convolution
12:30:09 <edwardk> sinelaw: ah, i was taking the linearity to mean a single consumer of event data that must consume them ;)
12:30:24 <edwardk> sinelaw: in the type theoretic sense
12:30:53 <sinelaw> edwardk, of which i know nothing about
12:31:07 <sinelaw> apropos that, what's a good intro to type theory
12:31:13 <edwardk> sinelaw: http://en.wikipedia.org/wiki/Linear_type_system
12:31:27 <edwardk> sinelaw: w.r.t. short example of what linear typing does
12:31:30 <xerox> copumpkin ah this one http://github.com/nfjinjing/mps/tree/master/src/MPS/Math/ that you linked before, I should have searched the backlog before
12:31:50 <Cale> sinelaw: Types and Programming Languages is the usual standard book
12:31:54 <edwardk> sinelaw: types and programming languages by benjamin pierce gives you the vocabulary to start reading the interesting stuff
12:32:38 <sinelaw> ok, pushed to stack
12:33:00 <monochrom> writeChan books_to_read "TaPL"
12:33:17 <jmcarthur> yeah i highly recomment TaPL
12:33:24 <edwardk> sinelaw: 'advanced topics in types and programming languages' ed. by benjamin pierce picks up and starts offering a view into more advanced areas. including 'substructural types' which include linear types in the first article. but its a collectionof short papers and kind of presumes you'd read TaPL
12:33:56 <Cale> sinelaw: It seems to me that convolution of nonlinear functions is fine.
12:34:08 <Cale> sinelaw: But perhaps I'm misinterpreting something :)
12:34:15 <copumpkin> xerox: oh yeah :) I wouldn't use that though... that MPS stuff makes me uncomfortable
12:34:18 <sinelaw> Cale, nonlinear functions is fine.
12:34:42 <edwardk> ultimately you're going to have all sorts of non-linearities and function hazards
12:34:52 <sinelaw> Cale, i meant convolution as a way to find the response of a system to arbitrary input is only meaningful for linear systems
12:35:30 <sinelaw> the "impulse response" is useless, without linearity
12:36:14 <edwardk> i guess what i like about frp is it can be used to separate out the 'memory' of the system from the parts that just flow data through
12:36:22 <mreh> what's the best way to separate out time varying continuous code and code that is discreet, more like a state machine?
12:36:24 <Cale> hmm, okay, I think I understand what you mean by that. (I don't have a lot of context of the conversation that this was occurring as part of)
12:36:26 <edwardk> the 'reactive normal form' paper comes to mind
12:36:34 <mreh> i need to decouple the complexity of this damn game
12:36:55 <edwardk> mreh: heh that is pretty much the nature of the discussion we've been having for the last few hours
12:37:00 <sinelaw> yeah
12:37:06 <sinelaw> pretty big question :)
12:37:10 <mreh> i'll read the scrollback
12:37:18 <Stalafin> what does 'just' do?
12:37:27 <jmcarthur> :t just
12:37:27 <lambdabot> Not in scope: `just'
12:37:29 <mreh> Stalafin: the function or constructor?
12:37:29 <jmcarthur> nothing
12:37:34 <mauke> @src Maybe
12:37:35 <lambdabot> data Maybe a = Nothing | Just a
12:37:35 <sinelaw> heh jmcarthur
12:37:38 <mreh> jmcarthur++
12:37:39 <Cale> mreh: Are you familiar with Conal Elliott's work?
12:37:54 <mreh> Cale: a little, read something about Yampa, learned arrows
12:38:10 * conal 's ears perk up
12:38:16 <sinelaw> mreh, this paper discusses exactly your question: http://conal.net/papers/push-pull-frp/
12:38:28 <mreh> amazing
12:38:37 <mreh> does it answer it? :)
12:38:39 <conal> sinelaw: thx
12:38:53 <edwardk> sinelaw: i wonder if the trick from uu-parsinglib might be applicable to a monadic/applicative style frp implementation
12:39:00 <sinelaw> :) hopefully, it does. i'm not sure because it didn't all sink in yet
12:39:05 <mreh> the guys at Yale seem to think Yampa is better than FRP
12:39:22 <sinelaw> mreh, what they call FRP is old stuff
12:39:33 <sinelaw> edwardk, what trick is that?
12:39:51 <mreh> conal: how do you pronounce your name? is it with a double 'n'
12:40:02 <conal> mreh: to clarify, FRP comes in two flavors: classic & arrow.
12:40:03 <mreh> it's quite unique
12:40:11 <Stalafin> mreh: i really have no idea... they have this example in lyah for cmd line arguments : let (Just action) = lookup command dispatch
12:40:17 <Stalafin> mreh: and i really dont get it
12:40:17 <andrewe> @info unsafeRead
12:40:18 <lambdabot> unsafeRead
12:40:22 <conal> mreh: ActiveVRML, Fran, & Reactive are classic style, and yampa is arrow style.
12:40:25 <edwardk> they have a 'monadic' parser P_h, which is heavier weight and an applicative parser P_f which is used whenever they can. Then they have a bind like operation between them that has a signature like: P_h a -> (a -> P_f b) -> P_f b -- for when 'everything that is left is applicative'
12:40:31 <andrewe> @info readArray
12:40:32 <lambdabot> readArray
12:40:35 <mreh> Stalafin: Just is a constructor of the type Maybe
12:40:37 <mreh> :t Maybe
12:40:38 <lambdabot> Not in scope: data constructor `Maybe'
12:40:46 <conal> mreh: and each has pros & cons
12:40:46 <sinelaw> Stalafin, haskell is capitalization  sensitive. Just is a constructor of type Maybe
12:40:48 <edwardk> and they build a monad P_m, by using both.
12:40:50 <mreh> @src Maybe
12:40:51 <lambdabot> data Maybe a = Nothing | Just a
12:40:57 <Cale> Stalafin: that's pattern matching (though the program will fail if the lookup gives Nothing)
12:41:07 * conal is still looking for a great FRP model.
12:41:21 <Stalafin> mreh, sinelaw, Cale: but what does that line do oO
12:41:22 <conal> have been for nearly 20 years now.
12:41:22 <edwardk> data P_m a = P_m (P_h a) (P_f a); .. and they define the bind operation to use the real monadic bind on the left, and to bind from the input to the future on the right
12:41:47 <Stalafin> mreh, sinelaw, Cale: and how are Just and Maybe connected now ?
12:41:57 <mreh> :t Just
12:41:57 <edwardk> sinelaw: this lets them exploit the extra invariants they have from being applicative as much as possible
12:41:58 <lambdabot> forall a. a -> Maybe a
12:42:08 <mreh> Stalafin, that's how ^
12:42:16 <Cale> Stalafin: It looks for a pair in the list 'dispatch' whose first component is equal to 'command', and binds the second component of the pair to 'action'
12:42:29 <sproingie> conal: maybe build one on top of CHP?
12:42:30 <Stalafin> Cale: so whats just?
12:42:33 <mreh> for example
12:42:34 <edwardk> > Just 12
12:42:35 <lambdabot>   Just 12
12:42:36 <mreh> :t Just 1
12:42:37 <lambdabot> forall t. (Num t) => Maybe t
12:42:48 <Cale> Stalafin: A value of type Maybe t is either the value Nothing, or it is (Just x) for some x of type t
12:42:53 <conal> sproingie: absolutely!  if one can get the semantics correct.
12:43:09 <Stalafin> Cale: and what am i supposed to do with Just x ?
12:43:09 <edwardk> Just is a 'tag' for wrapping a value, which makes it part of Maybe. a value of type 'Maybe Int' is either 'Just <somenumber>' or 'Nothing'. you can then use pattern matching to figure out which
12:43:15 <Cale> Stalafin: It's a type which is used to describe functions which might fail to produce a result
12:43:26 <conal> sproingie: seems to be difficult to get the semantics right when building on imperative concurrency.
12:43:34 <Cale> Stalafin: That isn't the best example, because it fails to handle the case when the lookup produces Nothing
12:43:53 <sinelaw> edwardk, so how would that translate into terms of temporal systems?
12:43:53 <conal> sproingie: which led me to unamb/lub and its uses for improving values/times
12:44:14 <Cale> > lookup 3 [(1,"cat"),(2,"dog"),(3,"emu"),(4,"buffalo")]
12:44:15 <lambdabot>   Just "emu"
12:44:15 <sproingie> conal: i kinda like what you have with this unamb/lub stuff.  not sure what i'd use it for myself, but it looks awfully slick.
12:44:19 <Cale> > lookup 7 [(1,"cat"),(2,"dog"),(3,"emu"),(4,"buffalo")]
12:44:20 <lambdabot>   Nothing
12:44:23 <mreh> conal: what's bad about arrows? not many constructs to combine?
12:44:28 <Cale> Stalafin: ^^ see how that works?
12:44:37 <conal> sproingie: :)  thx.  it's useful for *so* much more than frp.
12:44:54 <conal> sproingie: a way to modularize better than pure FP without.
12:45:05 <Cale> Stalafin: You can think of a value of type Maybe t as being like a list whose length is at most 1.
12:45:17 <Stalafin> Cale: ah... so it spits out Just "emu"
12:45:17 <copumpkin> @hoogle mergeIO
12:45:18 <lambdabot> Control.Concurrent mergeIO :: [a] -> [a] -> IO [a]
12:45:18 <lambdabot> Control.Concurrent nmergeIO :: [[a]] -> IO [a]
12:45:20 <Cale> Stalafin: With Nothing corresponding to the empty list, and Just x corresponding to [x]
12:45:25 <Twey> unamb still scares me
12:45:34 <Stalafin> Cale: and if we have the fnc defined as Just bla, bla is gonna be emu?
12:45:41 <sproingie> conal: unamb is hard for me to think of uses for, since both sides have to be equal, but amb is immediately useful, and having one that kills child threads is very nice
12:45:42 <conal> sinelaw: do you have an answer about arrow-frp for mreh ?
12:45:53 <luqui> conal, the proof obligations make me uneasy though
12:46:03 <Cale> Stalafin: yeah, when you match Just bla against Just "emu", then bla becomes "emu"
12:46:19 <sinelaw> mreh, for me, arrow-frp (and Yampa) lack a clear semantic model
12:46:33 <Cale> Stalafin: when you match  Just bla  against  Nothing  though, the pattern match fails and you get a runtime error though.
12:46:43 <conal> sproingie: it was probably just as hard for people to think of uses for laziness as well.  since i found unamb, i keep finding other uses beside the one in reactive.
12:46:43 <Stalafin> Cale: oO
12:46:46 <Cale> Stalafin: at least, when the definition looks the way it did there
12:46:52 <mreh> sinelaw: can you clarify what you mean?
12:46:58 <Stalafin> Cale: yeah, they say, they won't bother with 'failing gracefuly'
12:47:00 <Cale> Stalafin: It would be better to use case to handle both possibilities
12:47:02 <mreh> I am too stoopid to understand
12:47:17 <Cale> case lookup command dispatch of
12:47:21 <sproingie> conal: the parallel booleans that deal with bottom on either side are nice.  got any other uses?
12:47:24 <Cale>   Nothing -> handle failure
12:47:37 <sinelaw> mreh, for example, except for saying that there are signals and SF's, what are the primitives?
12:47:48 <conal> sproingie: see my exact differentiation post
12:47:48 <Stalafin> Cale: yeah, for my purposes it's fine... before handling exceptions and errors, i would like to get a grasp of things as simple as Maybe and Just :d
12:47:58 <Cale>   Just action -> ... do stuff with the action ...
12:48:06 <luqui> sproingie, union on the sierpinski space
12:48:12 <mreh> sinelaw: well anything you like it seems
12:48:14 <sinelaw> mreh, are the various switching operators primitives or utilities? etc
12:48:17 <Cale> Stalafin: well, that's what Maybe is for
12:48:19 <conal> sproingie: and http://conal.net/blog/tag/unamb/
12:48:35 <sinelaw> mreh, in other words, what is the semantic model for yampa?
12:48:39 <Stalafin> Cale: what's with the ->
12:48:42 <Stalafin> Cale: ?!
12:48:46 <Cale> Stalafin: Maybe is kind of like the simplest possible kind of exception you can have, where there's just success (with a value) and failure (with none)
12:48:49 <Stalafin> Cale: please don't confuse me :D
12:48:57 <Cale> Stalafin: that's just the syntax of case expressions
12:49:06 <mauke> Stalafin: then what are you doing in this channel?
12:49:07 <Stalafin> Cale: ah, ok... i am gonna get to em
12:49:14 <sinelaw> mreh, i encourage you to read http://conal.net/papers/type-class-morphisms/
12:49:17 <conal> mreh: in general, any time there are partial strategies to solve a problem.
12:49:26 <Cale> case <expr> of <pattern1> -> <result1>; <pattern2> -> <result2> ...
12:49:27 <sinelaw> mreh, and after that, the push-pull paper i posted above
12:49:29 <conal> mreh: ... consider lub
12:49:30 <Stalafin> mauke: pardon?
12:50:00 <Cale> mauke: He's talking to me, of course :P
12:50:03 <conal> mreh: ... which is a generalized unamb
12:50:15 <mauke> Stalafin: sorry, "please don't confuse me :D" makes you look like an idiot to me
12:50:25 <Cale> Heh
12:50:34 <Stalafin> mauke: then that i shall be
12:50:39 <mauke> I mean, of course you're going to be confused by seeing new stuff for the first time
12:50:48 <mauke> if you don't want that, why even bother?
12:50:59 <Stalafin> :D
12:50:59 <sinelaw> Stalafin, don't give up though
12:51:17 <sinelaw> Haskell has a learning curve with 90-degree inclincation
12:51:21 <luqui> conal, I have a cool model for unifying events / behaviors re: the integral frp we talked about.
12:51:23 <Cale> I suppose the purpose of this channel is to become confused so that you can become less confused.
12:51:26 <sinelaw> *inclination
12:51:35 <systemfault> sinelaw: It's not that bad.
12:51:39 <Stalafin> sinelaw: looks like a delta function to me then :D
12:51:40 <luqui> conal, as of an hour ago, so naturally prebaked
12:51:42 <Cale> Heh, perhaps to become aware of the confusion you already had.
12:51:48 <sinelaw> Stalafin, now you're talking!
12:52:04 <sinelaw> luqui, anything precise?
12:52:10 <Stalafin> sinelaw: however, a delta function is kinda... infinite
12:52:16 <Stalafin> sinelaw: hence, i will never get haskell xD
12:52:19 <luqui> sinelaw, yeah, modulo a loose end here and there
12:52:26 <sinelaw> Stalafin, nah, it's not a function
12:52:31 <sinelaw> nor infinite
12:52:47 <sinelaw> luqui, sounds interesting
12:52:50 <luqui> sinelaw, *define* a behavior over a monoid by its integral.  so any behavior b we can ask b[t,u]
12:53:09 <sinelaw> luqui, that's exactly how distribution theory begins, iirc :)
12:53:16 <mreh> all monads are arrow, I find that exciting
12:53:19 <luqui> sinelaw, no coincidence :-)
12:53:27 <sinelaw> i know
12:53:49 <sinelaw> i think it's the nicest theory i've met in math (of which i don't know much)
12:53:53 <conal> luqui: cool.  i'm just about to make a blog post, which may give some motivation.
12:53:56 <luqui> sinelaw, then for an event e, e[t,u] is just mconcat of the occurrences between t and u
12:54:02 <Stalafin> sinelaw: sinelaw ? delta(x) = infinity, x = 0; = 0, x /= 0
12:54:13 <sinelaw> Stalafin, incidentally, no.
12:54:29 <Stalafin> sinelaw: oO
12:54:29 <conal> luqui: about the old model being "mostly junk
12:54:31 <conal> "
12:54:42 <Stalafin> sinelaw: what then?
12:54:55 <luqui> conal, cool.  yeah, since you pointed that out it has really been bothering me.  quite an obvious bug in retrospect.
12:54:57 <sinelaw> Stalafin, delta is not a function, it's a distribution - defined by how it operates on other distributions when multiplied under an integral
12:55:15 <Stalafin> sinelaw: ok, we call it dirac delta function :D for all it matters
12:55:31 <luqui> conal, caused me to start looking at arrows again, since plain haskell functions between time functions would seem to necessitate encoding the junk
12:55:34 <sinelaw> Stalafin, so, you CAN learn haskell!
12:55:37 <Cale> conal/luqui: which bug?
12:55:49 <luqui> Cale, just wait for his post.
12:55:54 <Cale> okay :)
12:56:00 <conal> luqui: yeah.  i'd never noticed either until shortly after it hit me that the suggested gadt "models" of IO are far from fully abstract.
12:56:18 <conal> luqui: that's why those models feel "syntactic" and thoroughly unsatisfying to me.
12:56:48 <conal> they're "fully non-abstract".  "fully concrete"?  "emptily abstract"?
12:56:56 <sinelaw> luqui, notation: b[t,u] means integral of b from t to u?
12:57:14 <luqui> sinelaw, yeah.
12:57:19 <conal> luqui: then i remembered about the other property, junk-freeness, and it hit me that interactive frp isn't.
12:58:06 <luqui> yay cutting away the design space!
12:58:10 <luqui> i wonder if frp exists.... :-)
12:58:22 <luqui> or if it is just a "use case" for something else
12:58:28 <sinelaw> luqui, ok what does that lead to?
12:58:51 <Cale> luqui: exists in what sense?
12:58:56 <sinelaw> i mean about your model
12:59:12 <luqui> sinelaw, then you can find integral b t = b[0,t], pointwise
12:59:36 <luqui> and actually integrate using newtype DMonoid m = DMonoid (R -> m) that i discussed earlier
12:59:41 <jmcarthur> hmm... "interactive frp is not junk free"...
13:00:28 <luqui> sinelaw, that's about it.  a framework to think in.
13:00:38 <luqui> in which events and behaviors occupy the same space.
13:00:41 <sinelaw> luqui, so the monoid has to be an "integrable monoid"?
13:00:42 <Cale> I'm not sure I understand what junk refers to in this context.
13:00:57 <luqui> sinelaw, no, you integrate DMonoids
13:01:16 <sinelaw> Cale, i'm pretty sure it means what you think it does (as in math)
13:01:26 <Cale> eh?
13:01:28 <luqui> Cale, elements of the semantic domain that aren't realizable
13:01:37 <luqui> in more than a "computability" sense
13:02:13 <Cale> hmm, okay
13:02:15 <luqui> looking forward in time is the most obvious.  looking back in time conal argues should also be disallowed.  etc.
13:02:43 <luqui> well that's it actually.  you can only look at now.  thus the exploration of integrals.
13:02:48 <conal> yep.  that "causality" principle never felt right to me on its own.
13:02:49 <jmcarthur> we don't actually look back in time in real life
13:02:56 <Cale> Ah, so the semantics of time varying functions is the wrong choice?
13:03:01 <jmcarthur> we simply have memories
13:03:06 <conal> luqui: feel free to point people to our google wave chat
13:03:14 <luqui> conal, ... i don't know how to link to it
13:03:24 <conal> luqui: oh.  me neither
13:03:25 <jmcarthur> you guys are chatting up on google wave without me? wah!
13:03:47 <tromp__> > ['k'..'z']
13:03:48 <lambdabot>   "klmnopqrstuvwxyz"
13:03:56 <conal> jmcarthur: just once, i swear!  we couldn't help ourselves.
13:04:07 <sinelaw> luqui,  DMonoid is simply a function from time to something?
13:04:15 <kmc_> > fix (interleave ['a'..'z'])
13:04:16 <lambdabot>   "aabacbdaecfbgdhaiejckflbmgndohpaqiresjtcukvfwlxbymzgndohpaqiresjtcukvfwlxb...
13:04:19 <sinelaw> where "something" is a monoid
13:04:24 * jmcarthur keeps reading DMonoid as "demonoid"
13:04:42 <sinelaw> sound evil
13:04:46 <luqui> sinelaw, no, it's a "monoid differential".  continuous function s.t. d 0 = mempty
13:04:46 <sinelaw> *sounds.
13:05:52 <luqui> i keep looking for another law.  it might be worthwhile considering a monoid homomorphism from (R,+) to m
13:05:56 <conal> mreh: you asking about about arrow frp.  one issue is an awkwardness of programs.  they tend to have a more imperative feel.
13:06:03 <mreh> :t (***)
13:06:05 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
13:06:14 <luqui> but then you're stuck with commutative, which may be too limiting
13:06:16 <mreh> :t (&&&)
13:06:17 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
13:06:32 <luqui> conal, is that just the notation?
13:06:33 <conal> mreh: tho i think that problem is one of formulation, not semantics.  ie it could maybe be given a relatively cosmetic fix.
13:06:43 <conal> luqui: i think so
13:06:43 <mreh> conal: okay
13:06:49 <luqui> have you seen Wadler's lambda notation for arrows?
13:07:01 <conal> luqui: no
13:07:05 <mreh> there is a sort of do notation for arrows
13:07:09 <luqui> it's in his "arrows are meticulous" paper
13:07:20 <luqui> basically it looks just like lambda calculus with different typing rules
13:07:25 <conal> luqui: oh.  then i'v forgotten.
13:08:52 <jmcarthur> luqui: why the homomorphism from (R,+)?
13:08:54 <luqui> plus it's not *that* imperative.  FRP arrows are commutative, so it's just a list of in/out bindings
13:09:36 <mreh> is there a course that teaches category theory for programmers?
13:09:37 <luqui> jmcarthur, well differentials are linear.  that would essentially make a DMonoid a differential
13:10:11 <mreh> i might like to learn it, maybe when I retire and have to give up waterskiing
13:10:45 <sinelaw> luqui, you're looking for something that generalizes integrability?
13:11:05 <Absolute0> How can I convert Integer to Floating?
13:11:07 <luqui> sinelaw, yeah
13:11:09 <kmc_> there's a book called "basic category theory for computer scientists" by pierce
13:11:12 <jfoutz> mreh: there's this, http://www.youtube.com/user/TheCatsters
13:11:12 <copumpkin> fromIntegral
13:11:14 <kmc_> Absolute0, fromIntegral
13:11:26 <Alp> is there a california HUG ? :D
13:11:27 <sinelaw> luqui, heh fromIntegral then :)
13:11:30 <kmc_> :t fromIntegral
13:11:31 <lambdabot> forall a b. (Integral a, Num b) => a -> b
13:11:42 <luqui> sinelaw, was about to make the same joke :-)
13:12:02 <Absolute0> this integral floating business is very confusing
13:12:06 <sinelaw> Cale, do you know of a generalization of integration?
13:12:25 <Absolute0> http://pastie.org/766564
13:12:31 <Absolute0> ^^ I want a list of ints
13:12:50 <kmc_> Absolute0, do you understand the type signature of fromIntegral?
13:12:52 <Cale> sinelaw: I know of a bunch of them
13:13:12 <mercury^> sinelaw: integral signs are used for many things, such as ends and coends. There are also several generalisations of Lebesgue integrals.
13:13:17 <Absolute0> http://codepad.org/TqL62ht0
13:13:40 <mercury^> Such as spectral calculus.
13:13:42 <sinelaw> Cale, cool. I'm not sure what properties i'm looking for
13:13:49 <Absolute0> kmc_: I understand
13:14:04 <Absolute0> kmc_: there are just too many types in that function that its hard to keep track.
13:14:22 <Cale> http://en.wikipedia.org/wiki/Haar_measure
13:14:22 <kmc_> Absolute0, something iffy is going on that makes it want to use a function of type (Integer -> a) as a number
13:14:23 <Absolute0> Why hasn't Integral type been removed yet?
13:14:32 <kmc_> probably you have not applied enough arguments somewhere
13:14:33 <copumpkin> Absolute0: why would it be?
13:14:37 <kmc_> Absolute0, removed from what?
13:14:39 <Absolute0> Num is superior
13:14:42 <kmc_> Integral is not a type
13:14:45 <copumpkin> Absolute0: uh
13:14:47 <Absolute0> classtype
13:14:50 <kmc_> Integral is a collection of types
13:14:53 <kmc_> it's more specific than Num
13:14:57 <kmc_> supports some operations that Num doesn't
13:14:59 <mercury^> Cale: that's the fairly standard measure theoretic integration though.
13:15:03 <kmc_> every type in Integral is in Num, but not vice versa
13:15:04 <jmcarthur> Integral and Num are not at odds with each other
13:15:13 <Absolute0> beh
13:15:30 <copumpkin> Absolute0: I don't understand what your objection is
13:15:47 <idnar> Num is a superclass of Integral
13:15:59 <kmc_> Absolute0, the numeric typeclass hierarchy is pretty bad, but the solution is more classes, not fewer
13:16:05 <Absolute0> how can i fix this: http://codepad.org/Zvri2ZGG
13:16:10 <sinelaw> there are two parallel discussions about integral going on, and they have nothing to do with each other.
13:16:17 <sinelaw> how amazing.
13:16:18 <Cale> mercury^: Well, yes, but it's a way to put a natural measure on more objects, and so it kind of expands the domain of application of that definition :)
13:16:20 <Absolute0> do i just need a type signature?
13:16:23 <copumpkin> Absolute0: no
13:16:24 <kmc_> there are some operations that only make sense on integral numbers, and not (say) floats or vectors
13:16:42 <Absolute0> i added fromIntegral in the previous paste but that failed
13:16:44 <kmc_> Absolute0, you need to apply fromIntegral
13:16:55 <copumpkin> Absolute0: you should probably move to ghci too :)
13:16:58 <kmc_> logBase 2 $ fromIntegral n
13:17:03 <idnar> kmc_: won't that give the wrong result type then?
13:17:04 <mreh> jfoutz: I find women who know more math than me intimidating, and I haven't taken the time to pick through the videos to find a good starting point, probably monoids
13:17:04 <kmc_> you had logBase 2 fromIntegral $ n
13:17:10 <Absolute0> copumpkin: check the previous paste
13:17:12 <kmc_> which is (logBase 2 fromIntegral) $ n
13:17:13 <Absolute0> that fails
13:17:14 <kmc_> which is a type err
13:17:24 <copumpkin> Absolute0: I did, that's why I made the comment
13:17:27 <sinelaw> Cale, that wikipedia page is beyond my current scope. maybe if i'll know the specific properties i want i can ask a more specific question :)
13:17:43 <mercury^> One can also define Haar measures for locally compact groupoids.
13:17:44 <Absolute0> http://codepad.org/TqL62ht0
13:17:58 <kmc_> Absolute0, you still have the error i just described
13:18:36 <sinelaw> luqui, did you somewhere document the changes since drawingcombinators 0.43?
13:18:50 <idnar> @hoogle Integral
13:18:51 <lambdabot> Prelude class (Real a, Enum a) => Integral a
13:18:51 <lambdabot> Prelude fromIntegral :: (Integral a, Num b) => a -> b
13:18:52 <copumpkin> Absolute0: you put the $ in the wrong place
13:18:57 <Absolute0> right :)
13:18:59 <idnar> oh, :t is not :i
13:19:01 <copumpkin> kmc: made a typo
13:19:09 <copumpkin> oh whoops
13:19:17 <copumpkin> he was pointing ot your typo
13:19:17 <jfoutz> mreh: yeah, order is a problem. I've been watching the them when i start recognising the names.
13:20:11 <Absolute0> http://codepad.org/C0dzpoBl
13:20:41 <kmc_> Absolute0, okay, you have a new error
13:20:42 <Cale> sinelaw: Basically, if you have some nice-enough topological space with a definition of "translation" that you can put on it (turning it into a topological group), then you can define a measure on that space which gives rise to integration
13:20:46 <kmc_> what've you tried to fix it?
13:20:51 <dolio> Huh, someone implemented card marking?
13:20:55 <Absolute0> ** -> ^
13:20:58 <copumpkin> dolio: yep!
13:21:02 <dolio> Nice.
13:21:04 <Absolute0> this type system is not right
13:21:11 <copumpkin> Absolute0: no, you don't understand it
13:21:23 <dolio> I can't see it, because trac is apparently having conniptions.
13:21:32 <kmc_> Absolute0, are you going by the codepad error messages? the ghci messages are more helpful
13:21:36 <Absolute0> automatic casting would fix everything
13:21:37 <Absolute0> :)
13:21:39 <edwardk> sinelaw: was afk
13:21:48 <mauke> Absolute0: just use unsafeCoerce
13:21:49 <dolio> What will jdh complain about now?
13:21:52 <jmcarthur> Absolute0: try throwing a few unsafeCoerces in then
13:21:55 <kmc_> Absolute0, haha
13:22:01 <jmcarthur> Absolute0: of course, i bet it would be wrong
13:22:01 <copumpkin> Absolute0: and would give you a thousand other new bugs
13:22:08 <jmcarthur> Absolute0: the type system is saving you
13:22:10 <idnar> unsafeCoerce is the wrong kind of casting :P
13:22:20 <kmc_> implicit type conversion is great, just look at the clean easy to understand semantics of Perl and C++
13:22:26 <koeien37> are we now suggesting unsafeCoerce to new Haskellers? :/
13:22:31 <sinelaw> edwardk, you'll have to remind me what i was talking about
13:22:32 <kmc_> std::string x(false);
13:22:34 <jmcarthur> koeien37: as a learning tool
13:22:35 <kmc_> "0 but true"
13:22:41 <monochrom> Absolute0: in line 4, you say "fromIntegral n", this forces n to be of typeclass Integral, e.g., Int or Integer. On line 3, you have "n - 2**lgN", this forces n to be of typeclass Floating, e.g., Float or Double. Contradiction.
13:22:43 <jmcarthur> koeien37: the lesson being "love the type system"
13:22:50 <mauke> kmc_: perl has no implicit type conversions, of course
13:22:50 <edwardk> sinelaw: re the time stuff, arrow based (and consequently i'd suppose applicative-based) frp has a bunch of things it can do better than monadic frp in terms of avoiding leaks
13:22:53 <copumpkin> koeien37: he's being an opinionated newbie, so he gets mocked
13:23:14 <jmcarthur> is it bad if i'm not really mocking
13:23:15 <jmcarthur> ?
13:23:17 <Absolute0> worrying about type seems very low level
13:23:18 <conal> hm.  i think of classic frp as applicative frp
13:23:21 <monochrom> So why don't you just snatch "fromIntegral" so n is Double throughout?
13:23:21 <Absolute0> not very haskell-like
13:23:32 <jmcarthur> Absolute0: worrying about runtime errors is low level
13:23:33 <mauke> Absolute0: you still have to know what you want your code to do
13:23:36 <conal> since it's mainly built from Functor & Applicative
13:23:38 <kmc_> Absolute0, what would be Haskell-like?
13:23:39 <copumpkin> Absolute0: how do you know what haskell-like is? you seem ot have just started
13:23:42 <kmc_> certainly not an implicit conversion
13:23:44 <edwardk> sinelaw: so it stands to reason that working with that style of mixed applicative/monad monad could allow you to exploit those while still leaving you the 'sugar' of monadic frp
13:23:46 <luqui> sinelaw, nowhere but the github repo.  actually i need to document everything more, it just kind of assumes TCM and doesn't say anything about it.
13:23:50 <edwardk> conal: yeah
13:23:58 <monochrom> People, could we stop arguing and start fixing.
13:24:07 <copumpkin> > fix Absolute0
13:24:07 <Cale> Absolute0: Numeric conversions are not to be taken lightly.
13:24:08 <lambdabot>   Not in scope: data constructor `Absolute0'
13:24:12 <sinelaw>  should we have "Appliance" as an applicative instance? :P
13:24:13 <monochrom> Or do you need me to get op before you listen?
13:24:15 <kmc_> what might be haskell-like would be class Mult a b c | a b -> c where { (*) :: a -> b -> c }
13:24:17 <conal> edwardk: eek.  please don't call it "monadic frp"
13:24:23 <kmc_> but that's a pretty significant extension
13:24:26 <Absolute0> kmc_, copumpkin: Ie lists very flexible and polymorphic
13:24:31 <edwardk> conal: sorry
13:24:35 * hydo is listening.
13:24:37 <kmc_> Absolute0, what you are running into here is polymorphism exactly
13:24:38 <jmcarthur> conal: what dirty connotations does that have to you?
13:24:40 <mercury^> ($) = (. unsafeCoerce)
13:24:41 <Cale> Absolute0: In fact, converting between numeric types at the wrong place gives rise to some of the worst kinds of bugs.
13:24:48 <sinelaw> luqui, ok, the i'll read some code
13:24:50 <copumpkin> Absolute0: yes, and functions that only make sense on some types only work on those types
13:24:51 <sinelaw> *then
13:24:52 <conal> edwardk: there's so much confusion already about monad and frp.
13:24:55 <edwardk> jmcarthur_work: side-effects and IO and state oh my ;)
13:25:03 <Absolute0> well numbers are numbers..
13:25:07 <mauke> Absolute0: no
13:25:11 <kmc_> Absolute0, (+) on Int and Double is much like (++) on [a] and [b]
13:25:11 <Absolute0> in the mathematical sense
13:25:14 <Cale> Absolute0: no
13:25:16 <kmc_> Absolute0, not at all
13:25:17 <sinelaw> edwardk, I'm not concerned with leaks, but with clean semantics
13:25:17 <copumpkin> Absolute0: no
13:25:24 <jmcarthur> edwardk: monads do not imply IO and state. it would be a shame to lose the term just because it is misunderstood
13:25:25 <kmc_> the mathematical basis of the naturals is vastly different from the mathematical basis of the reals
13:25:27 <sinelaw> edwardk, unless you mean semantic leaks :)
13:25:38 <edwardk> jmcarthur: sure
13:25:50 <hydo> wrong channel to be wrong about the "mathematical sense" of anything.
13:26:00 <mauke> hah, the last question in #c was why float x = 3633/12289; printf("%f", x); prints 0.000000
13:26:02 <Cale> Mathematics has lots of separate types of numbers, many of which are incompatible with each other. But more than this, programming introduces finite-precision types of numbers which you have to be even more careful about.
13:26:02 <conal> my objection is only partly about the imperative connotation.
13:26:19 <kmc_> Absolute0, i don't suggest we model numerical types for practical code after Peano arithmetic and Dedekind cuts, but if you want to pull out "the mathematical sense" you will lose the argument for equivalence
13:26:21 <conal> though i would like to thoroughly destroy that connotation
13:26:39 * kmc_ wonders idly how to represent real numbers in Coq
13:26:39 <sinelaw> mauke, why does it?
13:26:41 <kmc_> probably like CReal does
13:26:50 <copumpkin> kmc: lookup fewdigits
13:26:55 <mercury^> The way C handles numeric types is quite good imo.
13:26:56 <Absolute0> logBase 2 (2,2.0) should mean the same thing, having the extra baggage of worring about type seems silly
13:26:58 <edwardk> I for one welcome our new functional reactive overlords.
13:27:09 <Absolute0> thats all i wanted to say..
13:27:10 <jmcarthur> yay!
13:27:10 <dolio> kmc_: roconnor published a paper on it.
13:27:24 <mauke> Absolute0: you have no idea what numbers are
13:27:34 <copumpkin> > logBase 2 5
13:27:35 <lambdabot>   2.321928094887362
13:27:37 <copumpkin> > logBase 2 5.0
13:27:38 <lambdabot>   2.321928094887362
13:27:41 <copumpkin> look ma, no types
13:27:43 <Cale> Absolute0: what?
13:27:43 <luqui> conal, what is the rest of your objection?
13:27:44 <Absolute0> ?
13:27:44 <sinelaw> edwardk, they are having an identity crisis at the moment, so don't disturb
13:27:49 <jmcarthur> conal: what else about "monadic" do you dislike?
13:27:51 <roconnor> > logBase 2 5.0 :: CReal
13:27:52 <lambdabot>   2.3219280948873623478703194294893901758648
13:27:57 <Cale> Absolute0: You appear to be applying logBase to a number and a pair?
13:27:58 <kmc_> > logBase 2 5.0 :: Float
13:28:00 <lambdabot>   2.321928
13:28:03 <mauke> sinelaw: because C doesn't do type inference or polymorphism. you divide two integers, you get an integer back.
13:28:11 <conal> i'd like some feedback on a blog post title.  "Functional reactive programming is mostly junk".  or "Interactive FRP is junky".  or ...
13:28:12 <mauke> sinelaw: that integer is then implicitly converted to float
13:28:17 <copumpkin> Absolute0: I think you should withhold your opinions until you actually know more of the language :)
13:28:20 <Absolute0> err: logBase 2 2/ logBase 2 2.0
13:28:22 <Absolute0> sheesh
13:28:26 <luqui> conal, like the former better than the latter.
13:28:27 <idnar> conal: Functional Junk Programming? ;)
13:28:28 <sinelaw> mauke, ah that's the reason :)
13:28:31 <kmc_> > logBase 2 2 / logBase 2 2.0
13:28:31 <Cale> Absolute0: Those are the same thing
13:28:32 <lambdabot>   1.0
13:28:39 <jmcarthur> Functional Reactive Junk
13:28:41 <kmc_> Absolute0, are you aware that 2 and 2.0 are polymorphic literals?
13:28:42 <idnar> @type 2.0
13:28:43 <lambdabot> forall t. (Fractional t) => t
13:28:46 <idnar> @type 2
13:28:47 <lambdabot> forall t. (Num t) => t
13:28:50 <luqui> Junktional reactive programming
13:28:52 <conal> luqui: me too.  though now wondering what FP detractors will do with it.
13:28:53 <kmc_> > logBase 2 (2 :: Integer) / logBase 2 (2 :: Double)
13:28:54 <lambdabot>   Couldn't match expected type `GHC.Integer.Internals.Integer'
13:28:55 <lambdabot>         agains...
13:28:58 <conal> luqui: hah!
13:28:58 <Absolute0> Cale: they are in ghci but not when inputs are different types
13:28:59 <sinelaw> luite, i was just gonna suggest that
13:29:03 <luqui> Junktional junk junking
13:29:19 <Cale> :t logBase
13:29:20 <lambdabot> forall a. (Floating a) => a -> a -> a
13:29:25 <jmcarthur> conal: i would avoid titles that appear to destroy the idea
13:29:26 <luqui> i'm not good at titles
13:29:31 <Absolute0> anyways is there a more elegant solution to my function?
13:29:32 <Cale> logBase takes two floating point parameters of the same type
13:29:33 <mercury^> Absolute0: it makes sense to have types of different precision.
13:29:42 <Absolute0> i was thinking of creating a pair of log and mod
13:29:46 <Absolute0> and then calling iterate
13:29:53 <Absolute0> with takeWhile (>0)
13:29:54 <kmc_> Absolute0, you'll note that ML makes the same design decision as Haskell -- no implicit numerical conversions.  the situation is worse for them because they don't have typeclass polymorphism
13:29:56 <luqui> Functional reactive programming's semantic baggage
13:29:57 <luite> hmm, I seem to be highlighted more often these days, unfortunately I know next to nothing about frb
13:29:58 <Absolute0> but that seems like just more work
13:30:01 <luite> frp
13:30:03 <luite> :)
13:30:03 <edwardk> Absolute0: the problem is there are lots of different types that it makes sense to take the log of, which are in no way compatible or inter-convertible
13:30:06 <mmmdonuts> Junktional detractive programming
13:30:07 <conal> luqui: ooh!
13:30:09 <endform> Has anyone managed to figure out how to get the current epoch time using the new Data.Time.Clock library? We could do it w/ System.Time but thats' deprecated
13:30:19 <Cale> You can't pass it, say, an Integer as the first parameter. You have to convert that integer to whatever floating point type you're using with fromIntegral first.
13:30:22 <jmcarthur> Functional Reactive Programming *has* Junk?
13:30:26 <Cale> (and lose precision along the way)
13:30:31 <conal> jmcarthur: that's where i'm torn.  i like shock titles, but then i read reddit and i see how short attention span folks have. :(
13:30:32 <kmc_> if you have a nice clean way to integrate numerical conversions into Haskell's type system, we'd like to see it
13:30:35 <jmcarthur> or "has a lot of"?
13:30:37 <mmmdonuts> Handling Functional Reactive Programming's Junk
13:30:53 <luqui> instance HasJunk FRP where
13:30:56 <conal> hm -- taking out the junk
13:31:01 <conal> luqui: lol
13:31:07 <Cale> kmc_: It's not so hard to whip up implicit numeric conversions, but we wouldn't want them
13:31:11 <kmc_> the ways i can think of involve subtyping, which is a massive can of worms that Haskell has thus far avoided entirely
13:31:19 <jmcarthur> i wouldn't want to attribute the junk to FRP generally. surely your goal is not to say all FRP ideas are full of junk
13:31:25 <sinelaw> conal, FRP, please take out the trash!
13:31:33 <Cale> You can use multiparameter typeclasses or associated types
13:31:37 <jmcarthur> if the target of the allegations could be made more specific...
13:31:39 <conal> sinelaw: ooh, nice also!
13:31:48 <conal> wow.  great ideas, guys.
13:31:52 <sinelaw> half serious :)
13:31:55 <jmcarthur> i like that one, but it reminds me of garbage collection
13:32:10 <edwardk> sinelaw: heh, now all you need is a way to mark stuff as trash and garbage collector support =)
13:32:10 <kmc_> Cale, you mean like the "class Mult a b c" i described above?
13:32:13 <conal> i like it too
13:32:19 <kmc_> what are the actual difficulties with this? ambiguous middle types?
13:32:20 <monochrom> Absolute0: You're welcome to install http://hackage.haskell.org/package/numbers and use the type CReal throughout if you are of the religion "there is only one kind of numbers". Hell, the package name just says "numbers".
13:32:24 <Cale> Heh, garbage collecting the semantics of FRP :)
13:32:31 <edwardk> cale: haha
13:32:34 <conal> also luqui's "instance HasJunk FRP where"
13:32:45 <conal> Cale: ooh!  good one.
13:32:47 <Cale> There are no references to these semantic values, so we'll GC them ;)
13:32:58 <conal> Cale: yeah!
13:33:01 <dolio> kmc_: A Monadic, Functional Implementation of Real Numbers
13:33:07 <kmc_> why you would pick real numbers, a hilariously unrealistic concept, as your One True Numerical Type is beyond me
13:33:07 <sinelaw> next up: semantic programming languages
13:33:10 <kmc_> dolio, thanks
13:33:17 <sinelaw> with semantic garbage collection
13:33:23 <koeien37> because pi is a useful number?
13:33:34 <c_wraith> pi is computable.
13:33:39 <copumpkin> it is?
13:33:44 <koeien37> yes
13:33:44 <Cale> copumpkin: yes
13:33:52 <c_wraith> of course, CReal is also computable numbers, rather than Real numbers
13:33:55 <idnar> > pi\
13:33:55 <sinelaw> but pi+2 isn't
13:33:56 <lambdabot>   <no location info>: parse error on input `\'
13:33:57 <idnar> > pi
13:33:58 * copumpkin draws a perfect cricle
13:33:59 <lambdabot>   3.141592653589793
13:33:59 <copumpkin> there!
13:34:02 <koeien37> pi+2 is also computable
13:34:02 <copumpkin> muahahahaha
13:34:02 <mauke> instance Floating Int where pi = 3
13:34:10 <Absolute0> monochrom: that doesn't seem so portable. :(
13:34:13 <copumpkin> oh
13:34:20 <copumpkin> I somehow read that as pi is uncomputable
13:34:27 <Cale> hehe
13:34:32 <mercury^> How can you even think that?
13:34:38 <copumpkin> that's why I questioned it
13:34:42 <mauke> copumpkin: then how did we compute it?
13:34:53 <copumpkin> again, why I questioned it :P
13:34:54 <luqui> communication FAIL
13:34:57 <mercury^> mauke: it could be that we could only compute part of its decimal expansion.
13:34:57 <kmc_> sigh
13:34:59 * copumpkin needs to learn how to read
13:35:01 <mercury^> But that's still silly.
13:35:02 <luqui> > pi + 2 :: CReal
13:35:03 <lambdabot>   5.1415926535897932384626433832795028841972
13:35:05 <monochrom> Absolute0: It compiles fine on Windows Linux MacOSX BSD, what do you mean non-portable?
13:35:07 <povman> Hi. Has anyone played with voronoi interpolation in haskell?
13:35:12 <copumpkin> anyway, the reals are countable
13:35:27 <c_wraith> say what?
13:35:29 * copumpkin draws a spiral
13:35:31 <copumpkin> there
13:35:38 <Cale> copumpkin: pi is the ratio of the circumference to the diameter of the set of nonterminating Turing machines
13:35:49 <luqui> copumpkin, you have lost me
13:35:50 <Cale> ;)
13:35:56 <conal> wow -- too many good title choices now. sinelaw: FRP, please take out the trash!; cale: Garbage collecting the semantics of FRP; luqui: Functional reactive programming's semantic baggage
13:35:58 <idnar> is compute the dual of mpute?
13:36:10 <mercury^> conal: what's the title for?
13:36:16 <conal> i like them all better than my "frp is mostly junk".
13:36:17 <idnar> conal: my vote is for Cale's, I guess
13:36:20 * BMeph draws a bucket of water...
13:36:22 <copumpkin> luqui: just referring to the most recent reals are countable crank
13:36:23 <luqui> okay, flip a 3 sided coin
13:36:25 <conal> mercury^: a blog post i'm about to publish.
13:36:36 <sinelaw> luqui, most coins are
13:36:39 <Cale> copumpkin: ah, I wondered what that was about
13:36:47 <Cale> copumpkin: What spiral is this?
13:36:50 * copumpkin wonders how one would physically design a fair three-sided device
13:37:04 <mauke> preflex: calc floor (3 * rand
13:37:04 <preflex>  2
13:37:08 <copumpkin> Cale: a "bi-infinite spreadsheet of all numbers with pi in the middle, which you enumerate by walking in a spiral around" ;)
13:37:09 <luqui> > randomR (0,2) (mkStdGen 1234567890)
13:37:10 <lambdabot>   (0,1435190785 40692)
13:37:15 <Cale> copumpkin: oh, right
13:37:17 <luqui> er.
13:37:23 <Cale> copumpkin: Yeah, I saw that one
13:37:27 <luqui> oh yeah, that mean 0
13:37:37 <copumpkin> the trick is to add 0.1, 0.101, 0.10101 ;)
13:37:38 <idnar> conal: just use a six-sided device with each result duplicated
13:37:39 <copumpkin> and so on
13:38:00 <copumpkin> idnar: I only want three stable points
13:38:13 <sinelaw> copumpkin, solution: a solid cylinder?
13:38:16 <idnar> copumpkin: yeah, I'm pretty sure that's impossible
13:38:18 <copumpkin> sinelaw: fair?
13:38:21 <Cale> I wonder why people have such trouble with that argument.
13:38:28 <sinelaw> copumpkin, why not?
13:38:48 <jfoutz> a triangle on a top. when the top falls over the bottom edge wins.
13:38:51 <hydo> I'm curious what the 'right' way u/quit
13:38:57 <sinelaw> you know, more or less.
13:38:57 <BMeph> conal: Here's another one - "Take out the FRP-ing Trash"
13:39:03 <Cale> hydo: what?
13:39:04 <copumpkin> sinelaw: I don't know, if you design a cylinder with equal area on all three faces, is it fair?
13:39:19 <sinelaw> copumpkin, not equal area, but equal probability to fall on each side
13:39:29 <copumpkin> yeah, how do you calculate what that is?
13:39:31 <conal> BMeph: :)
13:39:38 <edwardk> povman: for surface generation etc?
13:39:42 <kmc_> take a football and crease it in three points
13:39:47 <sinelaw> copumpkin, it's possible
13:39:49 <povman> edwardk: in a way.
13:39:51 <BMeph> Eh, NM, it's a little too close to sinelaw's...but it's mildly amusing. I vote for sinelaw's, then. :)
13:39:54 <Cale> That is really hard in general though.
13:40:08 <copumpkin> sinelaw: I never said it wasn't :) I just wanted to know how you'd go about figuring out a suitable three-faced fair shape
13:40:09 <jfoutz> kmc_: oh, that's a good one.
13:40:12 <Cale> You can try various things with physical simulation.
13:40:13 <sinelaw> BMeph, i like yours more
13:40:31 <edwardk> povman: i've done a bunch of stuff with voronoi diagrams, for nearest neighbor matching, and for generating meshes from pointsets, just never in haskell
13:40:35 <kmc_> similar: glue two triangular pyrimids on their bases and then smooth things out
13:40:40 <Cale> copumpkin: Of course, the usual thing is to just use a trangular prism
13:40:47 <Cale> triangular*
13:40:55 <copumpkin> Cale: that has five sides?
13:40:56 <BMeph> copumpkin: Glue two tetrahedrons face-to-face, then round off the adjoining "sides" of the joining face. :)
13:40:57 <kmc_> equivalently: taper the ends of a triangular prism
13:40:57 <povman> edwardk: In particular it needs to work in n dimensions
13:40:58 <sinelaw> kmc_, not bad
13:40:58 <copumpkin> *faces
13:41:00 <Cale> with open ends, let's say ;)
13:41:05 <copumpkin> Cale: pff :P
13:41:11 <nvoorhies> triangular prism and sharpen the pointy sides
13:41:17 <idnar> is a triangular prism really fair?
13:41:26 <copumpkin> nvoorhies: I guess that's a decent solution for any n
13:41:28 <povman> edwardk: but cool, what stuff have you worked on?
13:41:40 <copumpkin> and would be fair
13:41:41 <Cale> idnar: yes, ignoring the two ends of course
13:41:57 <idnar> well, if you make it long enough, the ends shouldn't be an issue
13:41:59 <BMeph> copumpkin: Very easily done with a couple of wax shells from a couple of "baby" wheels of cheese. :)
13:42:03 <Cale> Because it's symmetric
13:42:07 <nvoorhies> yeah, that's the only decent looking shape I've seen for non-platonic dice
13:42:11 <monochrom> copumpkin: Here is a relevant negative theorem: the only regular polyhedrons are tetrahedron, cube, octahedron, icosahedron, dodecahedron (the Platonic solids). So there is no regular polyhedron with exactly 3 sides or exactly 3 vertices. So perhaps you have to look outside regular polyhedrons or outside 3D.
13:42:14 * copumpkin likes the bi-pointy prism idea
13:42:16 <idnar> I suppose it's fair, but it's not necessarily a good idea
13:42:26 <copumpkin> monochrom: oh yeah, I wasn't expecting it to be regular
13:42:27 <idnar> it seems like it would be a lot easier to set than, say, a cube
13:42:35 <luqui> how about a flying chainsaw
13:42:39 <copumpkin> lol
13:42:41 <monochrom> OK cool.
13:42:51 <copumpkin> okay, a flying chainsaw is clearly the best answer yet
13:42:53 <sinelaw> copumpkin, a die, take result modulo 3
13:43:03 <idnar> I'm not sure how you read the result of the flying chainsaw
13:43:04 <copumpkin> sinelaw: I wanted three stable configurations
13:43:06 <monochrom> But hey, why is this in #haskell?
13:43:07 <idnar> last person left standing wins?
13:43:16 <luqui> sinelaw, you mean mod 2
13:43:22 <luqui> no mod 3
13:43:24 <luqui> i'm dumb
13:43:42 <sinelaw> luqui, just don't try the flying chainsaw
13:43:44 <povman> luqui: in a smart kind of way.
13:43:50 <copumpkin> monochrom: luqui's suggestion to flip a three-sided coin earlier on prompted a question on how one might design such a device
13:43:57 <sinelaw> luqui, you don't want to go wrong with that one!
13:43:58 <Absolute0> how do I describe (-1) as a function?
13:43:59 <edwardk> povman: long time ago i used to do 3d graphics, licensed rendering technology to game companies for lighting and surface visibility stuff, some stuff for dealing with fast integrated light through fog, volumetric models, clouds. the mesh stuff came up when i was working for a company that had a holographic display system, i was putting meshes on a stereo image of the person in front of the display
13:44:05 <kmc_> Absolute0, subtract 1
13:44:07 <Absolute0> :t (-1)
13:44:09 <lambdabot> forall a. (Num a) => a
13:44:14 <nvoorhies> flip it in R^2
13:44:15 <copumpkin> :t subtract 1
13:44:17 <lambdabot> forall t. (Num t) => t -> t
13:44:23 <Absolute0> how come (+1) works just fine?
13:44:28 <sinelaw> edwardk, sounds amazingly cool.
13:44:31 <Absolute0> :t (+1)
13:44:32 <lambdabot> forall a. (Num a) => a -> a
13:44:37 <idnar> just roll a triangle in a plane ;)
13:44:43 <Heffalump> Absolute0: because - is treated specially
13:44:45 <copumpkin> Absolute0: because negative numbers happen to use the same symbol as the subtraction symbol
13:44:45 <kmc_> Absolute0, it's a stupid special case in the grammar :/
13:44:52 <Heffalump> because of the unary/binary ambiguity
13:44:58 <luqui> Absolute0, it's a hack.  - is the only unary operator.  it is hotly disputed whether it should be there.
13:45:01 <copumpkin> @let (‚Äì) = (-)
13:45:03 <lambdabot>  Defined.
13:45:05 <copumpkin> > (‚Äì5)
13:45:07 <lambdabot>   {-3->-8;-2->-7;-1->-6;0->-5;1->-4;2->-3;3->-2}
13:45:33 <edwardk> povman: ultimately i scrapped the mesh approach and settled on a much simpler one. a markov model that tracked correlation between the two images to construct an approximate depth map, and located the nose for head tracking off of the most correlated point, and used the rest to play with some '2.5d' video conferencing stuff
13:45:53 * BMeph still likes his cheese wax idea. Which is now making him hungry for cheese...
13:46:01 <kmc_> here's a fun puzzle: label the faces of each of two cubes with natural numbers, such that throwing them as dice and adding the two numbers gives the same distribution as throwing and adding two standard [1..6] dice
13:46:01 <Heffalump> copumpkin: WTF? let (-) = (-) turns off the hack?
13:46:02 <sinelaw> BMeph, me too
13:46:15 <copumpkin> Heffalump: lol, it's a unicode symbol that looks just like - :)
13:46:22 <kmc_> (excluding the solution of two standard [1..6] dice, of course)
13:46:23 <edwardk> povman: that probably sounded fairly incoherent because i jumbled 10 years of different jobs into two sentences ;)
13:46:32 <idnar> it's EN DASH
13:46:33 <povman> edwardk: Sounds like pretty intense technology...  All I'm trying to do is create a parametric animation system which works out what to do based on examples
13:46:37 <Heffalump> copumpkin: oh :-)
13:46:41 <johnnowak> > "‚Äì" == "-"
13:46:42 <lambdabot>   False
13:46:47 <idnar> whereas - is HYPHEN-MINUS
13:46:52 <sinelaw> povman, in povray?
13:46:56 <idnar> isn't there a real minus in unicode, though?
13:47:02 <luqui> povman, you phrase it as if it's an easy problem
13:47:06 <idnar> ah yes
13:47:08 <Cale> kmc_: I like the explanation of that one in terms of factorisation of polynomials
13:47:13 <kmc_> yes
13:47:14 <idnar> @let (‚àí) = (-)
13:47:15 <lambdabot>  Defined.
13:47:19 <idnar> > (‚àí2)
13:47:19 <BMeph> The three reasons why I studied German in elementary school: Gummi Bears, Toblerone and mini-Gouda wheels. :)
13:47:19 <Heffalump> so does unicode have separate unary and binary minuses?
13:47:21 <lambdabot>   {-3->-5;-2->-4;-1->-3;0->-2;1->-1;2->0;3->1}
13:47:21 <kmc_> generating functions as i recall
13:47:25 <Cale> yeah
13:47:32 <povman> sinelaw: No, just 2d
13:47:33 <idnar> MINUS SIGN
13:47:35 <idnar> heh.
13:47:37 <Heffalump> > (*3) . (+2)
13:47:39 <lambdabot>   {-3->-3;-2->0;-1->3;0->6;1->9;2->12;3->15}
13:47:42 <edwardk> povman: so where does voronoi interpolation come into play? i'm mostly familiar with that term in terms of mesh reconstruction given sample points
13:47:44 <Cale> (though I prefer the term "generating series" :)
13:47:54 <kmc_> it is a better name
13:47:56 <Absolute0> Is there any predefined function to chain conditions?
13:48:09 <Absolute0> ie: takeWhile (chainConditions conditions) ls
13:48:10 <kmc_> Absolute0, you mean like "cond" in scheme?
13:48:16 <sinelaw> povman, i've implemented a Bezier module, but that's not what you want.
13:48:16 <kmc_> what does "chain" mean/
13:48:16 <luqui> :t and
13:48:17 <lambdabot> [Bool] -> Bool
13:48:31 <kmc_> Absolute0, you want them all to hold?
13:48:31 <povman> sinelaw: It could be
13:48:37 <Absolute0> kmc_: correct
13:48:37 <kmc_> > and [2==2, 3==3]
13:48:38 <kmc_> > and [2==2, 3==4]
13:48:39 <lambdabot>   True
13:48:39 <povman> sinelaw: can you have n-dimensional beziers?
13:48:40 <lambdabot>   False
13:48:45 <kmc_> :t all
13:48:47 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
13:48:47 <Absolute0> I dont want to && them myself :)
13:48:53 <kmc_> > all even [2,6,12]
13:48:54 <lambdabot>   True
13:48:55 <kmc_> > all even [2,6,13]
13:48:55 <sinelaw> povman, n-dimensional? or n-order?
13:48:56 <lambdabot>   False
13:49:02 <edwardk> povman: when in doubt, stick to cubics or nurbs so you can have smooth 2nd derivatives
13:49:03 <povman> n-order
13:49:03 <sinelaw> povman, i think it can
13:49:09 <kmc_> > all ($ 5) [odd, (== 5)]
13:49:11 <lambdabot>   True
13:49:13 <tromp__> kmc : how about [0..5] and [2..7] ?
13:49:17 <sinelaw> povman, n-order it can for sure! i'm using it
13:49:23 <luqui> > and [1==1, 2==2, 3==3, 4==4, 5==5]
13:49:24 <lambdabot>   True
13:49:25 <Guest11539> Learning from real world haskell book. I'm stuck on a code sample that doesn't work. Fails to load in GHCi (6.10.4).
13:49:25 <sinelaw> povman, http://github.com/sinelaw/graphui
13:49:27 <Guest11539> http://hpaste.org/fastcgi/hpaste.fcgi/new?edit=1&id=15599
13:49:27 <kmc_> tromp__, right... i think you exclude 0?
13:49:30 <Absolute0> :t ($ 5)
13:49:31 <lambdabot> forall a b. (Num a) => (a -> b) -> b
13:49:35 <Absolute0> huh?
13:49:36 <Absolute0> :)
13:49:54 <kmc_> > succ 5
13:49:55 <Absolute0> > (%5) 5
13:49:56 <kmc_> > succ $ 5
13:49:56 <lambdabot>   6
13:49:56 <lambdabot>   1 % 1
13:49:57 <lambdabot>   6
13:50:02 <kmc_> > ($ 5) succ
13:50:04 <lambdabot>   6
13:50:04 <sinelaw> povman, specifically under src/Math. git pull it, or look at http://github.com/sinelaw/graphui/tree/master/src/Math/
13:50:04 <idnar> @src ($)
13:50:05 <lambdabot> f $ x = f x
13:50:15 <kmc_> > map ($ 5) [succ, pred, (*3)]
13:50:16 <lambdabot>   [6,4,15]
13:50:18 <idnar> Absolute0: it's a section of ($) ^^^
13:50:28 <Absolute0> right just reversing the order..
13:50:35 <luqui> too much lambdabotting at once.  i thought (%5)5 yielded 6!
13:50:38 <idnar> (which is just defined as function application, except with a low precedence)
13:50:43 <luqui> and began to question my sanity
13:50:50 <Absolute0> > ($ 5) 5
13:50:51 <lambdabot>   Ambiguous type variable `a' in the constraint:
13:50:51 <lambdabot>    `GHC.Num.Num a' arising f...
13:50:56 <Absolute0> huh :)
13:50:58 <copumpkin> > fix ((1:) . (>>= sequence [(+1), (1/) . (+1)])) :: [Rational] -- zomg
13:50:59 <lambdabot>   [1 % 1,2 % 1,1 % 2,3 % 1,1 % 3,3 % 2,2 % 3,4 % 1,1 % 4,4 % 3,3 % 4,5 % 2,2 ...
13:50:59 <kmc_> > 5 5 -- that's like this
13:51:00 <idnar> > 5 5
13:51:01 <lambdabot>   Ambiguous type variable `t' in the constraint:
13:51:01 <lambdabot>    `GHC.Num.Num t' arising f...
13:51:01 <lambdabot>   Ambiguous type variable `t' in the constraint:
13:51:02 <lambdabot>    `GHC.Num.Num t' arising f...
13:51:10 <idnar> majestic stereo, eh
13:51:13 <Absolute0> > ($5) (+1)
13:51:14 <kmc_> 5 isn't a function, so (5 5), (5 $ 5), and (($ 5) 5) are all bogus
13:51:14 <lambdabot>   6
13:51:17 <sinelaw> luqui, I know you're not stupid for sure, it's what - 24 hours awake now?
13:51:24 <kmc_> quadrophenia
13:51:28 <monochrom> You should use /msg lambdabot > 1+1
13:51:28 <luqui> sinelaw, yep :-)
13:51:31 <copumpkin> omg #math was right
13:51:35 <copumpkin> he is dumb after all
13:51:39 <kmc_> who?
13:51:42 <Athas> Is there a variant on MVar that requires synchronous writing/reading (that is, very much like a CSP channel)?
13:51:47 <copumpkin> kmc_: luqui
13:51:51 <kmc_> hehe
13:51:57 <sinelaw> luqui, that's the point at which i begin to think in free associations
13:51:59 <luqui> yeah i knew it.  er i mean, i didn't know.  anything.
13:52:13 <luqui> you might notice my discource getting more and more silly and off-topic
13:52:24 <luqui> and my spellig getting worse
13:52:29 <monochrom> Athas: No, but look into CHP http://www.cs.kent.ac.uk/projects/ofa/chp/ exactly CSP.
13:52:33 <copumpkin> you mean distracting our highly intellectual discussion on three-sided dice with talk of flying chainsaws?
13:52:35 <edwardk> luqui: clearly you need more caffiene
13:52:45 <kmc_> Athas, i think you can build it with a pair of MVars
13:52:47 <luqui> copumpkin, um... i came up with the chainsaw
13:52:50 <povman> sinelaw: I need n-dimensional inputs
13:52:55 <kmc_> a send/ack pair
13:52:56 <luqui> so technically no.
13:53:04 <mreh> :t (&)
13:53:05 <lambdabot> Not in scope: `&'
13:53:07 <sinelaw> povman, that should be easy to generalize, due to the beutiful implementation there!
13:53:12 <Athas> monochrom: right, but I don't really want to use any other part of CHP.
13:53:16 <sinelaw> beautiful even
13:53:19 <Athas> kmc_: thanks, that sounds right.
13:53:20 <monochrom> Ha OK
13:53:28 <kmc_> in fact i remember seeing this in some SPJ paper
13:53:33 <copumpkin> luqui: I meant, distracting X with talk of flying chainsaws, where x is our highly intellectual discussion on three-sided dice
13:53:34 <kmc_> maybe the original Concurrent Haskell paper
13:53:45 <sinelaw> povman, you said n-order before
13:53:53 <luqui> copumpkin, ah nice refactor
13:53:57 <povman> sinelaw: actually i don't know what i'm talking about :)
13:54:12 <sinelaw> copumpkin, i would use "let" in that sentence
13:54:12 <copumpkin> luqui: nuh uh, I blame my poor english language skillz
13:54:18 <mreh> > id &&& (map toUpper) $ "Hello"
13:54:19 <lambdabot>   ("Hello","HELLO")
13:54:20 <edwardk> povman: you want splines? for what? for interpolation purposes?
13:54:22 <kmc_> Athas, STM should let you block until a Chan empties
13:54:32 <sinelaw> povman, what do you need then
13:54:41 <edwardk> povman: i presume that could be animating just about any parameters?
13:54:49 <edwardk> povman: and hence the n dimensional bit?
13:54:51 <kmc_> > (map pred &&& map toUpper) "Hello"
13:54:52 <lambdabot>   ("Gdkkn","HELLO")
13:55:10 <mreh> lolwut?
13:55:15 <copumpkin> yep
13:55:16 <sinelaw> povman, with n-order beziers you can interpolate a curve going through n points, using a single parameter that goes from 0 (first point) to 1 (last point)
13:55:36 <luqui> map (I <3) [(***), (&&&), (+++), (|||)]
13:55:38 <copumpkin> omnom
13:55:54 <sinelaw> povman, if you want n-dimensions too, you can generalize my implementation easily - it should work for any vector
13:55:56 <povman> edwardk, sinelaw: Yeah, I need to pass in n parameters to the function and have it generate an animation based on some preset examples
13:56:01 <copumpkin> > map (I <3) [(***), (&&&), (+++), (|||)]
13:56:02 <lambdabot>   Not in scope: data constructor `I'
13:56:05 <copumpkin> fail
13:56:06 <edwardk> sinelaw: the problem is n dimensional beziers suck. you can't introduce new control points, they can't be evaluated once projected in a way that is view invariant, etc.
13:56:47 <sinelaw> edwardk, this is where you experience begins and my hope for a library of mine to be used, ends.
13:56:50 <sinelaw> *your
13:57:00 <copumpkin> lol
13:57:06 <edwardk> sinelaw: piecewise cubic splines give you local control without higher dimensional wobble problems, but they don't have nice control point insertion.
13:57:07 <mreh> @src (->) (>>>)
13:57:08 <lambdabot> f >>> g = g . f
13:57:26 <monochrom> Athas: maybe http://hackage.haskell.org/packages/archive/synchronous-channels/0.1/doc/html/Control-Concurrent-Chan-Synchronous.html
13:57:54 <sinelaw> I only used beziers because that's what dot outputs when laying out edges
13:58:22 <edwardk> povman: the main thing you want out of an animation package liek that is the ability to take the curve you have, and perturb it locally once you have it 'almost where you want it'
13:58:25 <Athas> monochrom: hm, yes... actually, I think I'll rather restructure my program.  But I'll keep those opportunities in mind for the future, thanks.
13:58:38 <edwardk> i.e. take a short time segment of it, and drag it up or down, but keep the derivatives continuous
13:58:42 <sinelaw> conal, do you think a model that allows recursion in two ways (in pure functions, and via feedback) is "dirty"?
13:58:50 <povman> sinelaw: also i'm scared of beziers because i'd need extra data (i.e. the other control points)
13:59:05 <edwardk> so the ability to insert new knots is key
13:59:13 <edwardk> at least if there is any gui on this process
13:59:20 <sinelaw> povman, try to check out what blender uses
13:59:40 <povman> edwardk: What I'm trying to do is interpolate between _animations_
13:59:54 <conal> http://conal.net/blog/posts/garbage-collecting-the-semantics-of-frp/
14:00:01 <edwardk> povman: if you aren't afraid of math, the right answer for playing with curves is: http://en.wikipedia.org/wiki/Non-uniform_rational_B-spline
14:00:02 <sinelaw> conal, congrads :)
14:00:10 <kmc_> splines are great for interpolating i general, not merely in space
14:00:21 <conal> thanks everybody!  i added other wonderful titles to the end of the post.
14:00:23 <edwardk> povman: ok, so now, lets talk about how your animations are encoded
14:00:33 <povman> edwardk: as keyframes
14:00:43 <edwardk> do you have a model with a skeleton?
14:00:48 <povman> edwardk: yes
14:00:51 <conal> sinelaw: i don't know how to disallow recursion.
14:01:02 <sinelaw> conal, but you can disallow feedback
14:01:06 <copumpkin> don't provide Y
14:01:11 <copumpkin> :D
14:01:29 <conal> sinelaw: yeah.
14:01:31 <sinelaw> copumpkin, possible, but the other option is what i was thinking
14:01:34 <povman> edwardk: don't want nurbs because the curve needs to touch the data points
14:01:38 <conal> sinelaw: you mean a feedback operator, right?
14:01:42 <b0fh_ua> Hi there! I am very new to Haskell, and I don't know much about it's functions and modules. I know a bit about lambdas and function composition. For refining my knowledge I wrote the simple program to calculate sum of numbers in set of files (each number is on separate line). The program is listed at http://pastebin.com/d66af0264 and seems to work fine. However I am not sure is lambda really neccessary in my case. Is there any way to 
14:01:45 <sinelaw> conal, i don't think it's too bad to have both
14:02:17 <sinelaw> conal, you can say that feedback is semantically equivalent to recursion.
14:02:23 <edwardk> ok, so you need to be able to slerp your joints. easiest answer is of course to just start with a weight sliding between 0 and 1, probably eased in and out with Perlin's gamma function, and use it to slerp between the two positions given by each animation ;)
14:02:32 <povman> b0fh_ua: try forM files $ \fileName -> do ....
14:02:41 <povman> b0fh_ua: make that forM_
14:02:51 <povman> b0fh_ua: no don't, forM is fine ;)
14:02:53 <conal> sinelaw: yes, so the dsel+host is not minimal.  ie there are semantically equivalent primitives.
14:02:54 <luqui> sinelaw, but if one is always the better way to go (in the case of arrows), it would be nice to disallow recursion
14:03:00 <b0fh_ua> povman: well, that's still about lambda
14:03:10 <pikhq> b0fh_ua: Other than the forM instead of mapM, looks reasonable.
14:03:14 <b0fh_ua> while I want to use function composition :)
14:03:14 <povman> b0fh_ua: you could do it with another function, but lambdas are nice
14:03:17 <luqui> infinite systems of arrows cause memory leaks
14:03:25 <pikhq> And even that's just fine; forM is just a bit more idiomatic there.
14:03:58 <sinelaw> luqui, infinite what?
14:04:20 <povman> edwardk: there could be 4 parameters to interpolate on
14:04:22 <edwardk> povman: i.e. value for the rotation of a joint is slerp(gamma(t,ease_factor), animation_1_rotation, animation_2_rotation)
14:04:29 <edwardk> what 4 parameters?
14:04:31 <sinelaw> conal, luqui it's possible to disallow one semantically and have a utility syntax that transforms one into the other?
14:04:51 <sinelaw> I mean we have to show that everything expressible in one is expressible in the other
14:05:02 <pikhq> b0fh_ua: You can *do* that with just some monad operators. However, it's probably not cleaner.
14:05:15 <sinelaw> which i'm not sure about in the case of feedback in a path that contains arbitrary "operators"
14:05:32 <sinelaw> (thinking about a yet-to-be-defined model, no precise concepts)
14:05:32 <povman> edwardk: e.g. i have input data like [(a1, b1, c1, d1, animation1), (a2, b2, c2, d2, animation2)]   and want to figure out animation3 given a3 b3 c3 d3
14:05:33 <luqui> b0fh_ua, would use sumList <- mapM (sum . map read . lines <$> readFile) files
14:05:48 <pikhq> @pl \fileName -> do {content <- readFile fileName;return (foldr ((+) . read) 0 $ lines content)
14:05:49 <lambdabot> (line 1, column 17):
14:05:49 <lambdabot> unexpected "{"
14:05:49 <lambdabot> expecting variable, "(", operator or end of input
14:05:55 <pikhq> @pl \fileName -> do {content <- readFile fileName;return (foldr ((+) . read) 0 $ lines content)}
14:05:55 <lambdabot> (line 1, column 17):
14:05:56 <lambdabot> unexpected "{"
14:05:56 <lambdabot> expecting variable, "(", operator or end of input
14:06:03 * pikhq shakes fist
14:06:15 <luqui> b0fh_ua, <$> is infix fmap.  from Control.Applicative.  replace with `fmap` if you like
14:06:24 <edwardk> povman: not parsing you
14:06:29 <copumpkin> <$> <$> <$>
14:06:40 <luqui> sinelaw, not within haskell at least
14:06:40 <idnar> money money money
14:06:47 <luqui> recursion is not observable :-(  :-)
14:06:54 <idnar> `fmap`fmap`fmap`
14:07:01 <dolio> @. pl undo \fileName -> do { content <- readFile fileName ; return (foldr ((+) . read) 0 $ lines content) }
14:07:02 <lambdabot> ((foldr ((+) . read) 0 . lines) `fmap`) . readFile
14:07:02 <edwardk> povman: you have animations, each animation takes some amount of time, and has some function that figures out the position of each joint on your skeleton as a function of time, ignoring all other animations, no?
14:07:04 <povman> edwardk: I'll have a look at n-dimensional bezier splines :) thanks for helping
14:07:07 <luqui> a point which i am ambivalent about, but ultimately embrace
14:07:37 <edwardk> povman: if you're trying to go between two animations, the beziers are completely the wrong tool =/
14:07:38 <idnar> @type `fmap`fmap`fmap`
14:07:39 <lambdabot> parse error on input ``'
14:07:43 <idnar> aww
14:07:45 <edwardk> povman: as are the nurbs i mentioned above
14:07:55 <idnar> needs more parens, I suppose
14:07:56 <povman> edwardk: oh?
14:08:01 <pikhq> @type fmap`fmap`fmap
14:08:02 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
14:08:12 <idnar> or less backticks, duh
14:08:25 <povman> edwardk: My plan was to use voronoi interpolation...
14:08:43 <edwardk> not sure how voronoi interpolation applies here
14:08:50 <Zaph0d_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15600#a15600  why can't I set the type to the commented out line?
14:09:03 <edwardk> povman: have you got a link that uses that term in this context?
14:09:16 <povman> edwardk: http://dilbert.engr.ucdavis.edu/~suku/nem/nem_intro/node3.html
14:09:22 <mauke> Zaph0d_: what's the inferred type of f?
14:09:38 <Zaph0d_> f :: (Ord a) => a -> Map a a -> Map a b -> Maybe b
14:09:53 <Zaph0d_> I want f :: (Ord a) => a -> Map a b -> Map b b -> Maybe b
14:10:23 <edwardk> povman: i guess i'm just not getting what those 4 example constants you had associated with your animations mean
14:10:40 <povman> edwardk: forget the fact that i have animations;
14:10:49 <edwardk> povman: ok
14:11:01 <edwardk> povman: sorry for being dense
14:11:02 <b0fh_ua> nice
14:11:12 <mauke> Zaph0d_: you need (Ord b) as well
14:11:21 <mauke> Zaph0d_: and you're getting bitten by the monomorphism restriction on lookup
14:11:48 <povman> edwardk: let's say i have m ::  Map (Double, Double, Double, Double, Double) Double
14:12:16 <povman> edwardk: I need to produce a continuous function f :: (Double, Double, Double, Double, Double) -> Double
14:12:28 <edwardk> povman: ok. now i buy voronoi interpolation =)
14:12:34 <povman> edwardk: :)
14:13:02 <Zaph0d_> mauke: Why is lookup able to use different types in Map on the rhs of >>=  ?
14:13:13 <mauke> Zaph0d_: what?
14:13:18 <povman> edwardk: That's reassuring! Albeit, I'll probably have to implement it myself (but that's fun isn't it.)
14:13:19 <edwardk> build voronoi cells around each point, given any point you can find the cell its in, and all of the neighbors of the cell, and you can then apply a blending function using effectively the 'barycentric' location within the cell
14:13:29 <Zaph0d_> mauke: I didn't understand "monomorphism restriction"
14:13:31 <povman> edwardk: spot on
14:13:35 <Alp> povman, write a library for it
14:13:46 <Alp> :-)
14:13:55 <povman> edwardk: if there were a way of making splines, that would be nicer
14:14:02 <povman> Alp of course !
14:14:09 <Alp> nice
14:14:20 <povman> Alp: My Haskell optimisation skillz are null so it might suck
14:14:22 <mauke> Zaph0d_: your choices are: 1) disable the monomorphism restriction; 2) write a type signature for lookup; 3) add a parameter to the definition of lookup
14:14:31 <sinelaw> luqui, not observable in what sense?
14:14:32 <koeien37> 1) imo
14:14:43 <Zaph0d_> mauke: Got it now. Thank you.
14:14:50 <povman> anyway I have a french lesson to attend, talk later!
14:14:50 <edwardk> povman: the problem is splines don't fit the problem space. very well, you have no real alignment of your cells. you _could_ tweak the problem a bit.
14:15:03 <Alp> povman, you may want to check the GHC manual and the wiki, among other things. I read some optimization guildeines there
14:15:07 <edwardk> you could dualize your voronoi diagram to obtain the delaunay triangulation
14:15:18 <edwardk> and work over splines on each triangular patch
14:15:32 <luqui> sinelaw, in the sense that you can't tell the difference between a recursively written expression and an expression written out "long-hand"
14:15:34 <luqui> by ref. trans
14:15:59 <luqui> fix might as well generate infinitely large terms
14:16:01 <povman> edwardk: for some definition of triangle
14:16:08 <sinelaw> luqui, ok. control theory has "observability" in feedback systems, so that was confusing.
14:16:30 <jmcarthur> conal: it appears to me that your idea is to remove time from the semantics of FRP, in a sense
14:16:35 <edwardk> you know the endpoint values of each patch, you can approximate the derivatives at the end points, which gives you the information for cubic splines
14:16:36 <povman> edwardk: gtg, thanks for your help
14:16:48 <luqui> sinelaw, ah, never heard of it
14:17:09 <edwardk> povman: well, either triangular or perfectly shaped regular polyhedral  in numerically degenerate cases.
14:17:19 <edwardk> povman: catch you later
14:17:20 <conal> jmcarthur: yeah.  that feels good to me.
14:17:27 <conal> jmcarthur: also by the WWRD principle.
14:17:48 <sinelaw> luqui, it's about the ability to know the state of a system according to its outputs only
14:18:10 <conal> jmcarthur: ironically, since time has always been at the center of the model
14:18:40 <luqui> i once heard an interpretation of reality from the point of view of a photon
14:18:48 <luqui> in which there is no time, first energy here, then there
14:19:15 <luqui> which got me to thinking that perhaps this time business is an artifact of making an infinitely large reality computable
14:19:40 <luqui> maybe there is no Time, or spoon.
14:19:55 <edwardk> luqui: clearly you need functional reactive relativity ;)
14:20:13 <luqui> edwardk, don't think i haven't thought about the connections
14:20:21 <jmcarthur> i certainly have thought about that
14:20:39 <edwardk> luqui: i spent a lot of time trying to figure out the right way to encode a causal domain for event propagation
14:20:42 <luqui> one that is intriguing me is whether there is a connection between conservation of energy and preservation of information
14:20:52 <luqui> edwardk, get anywhere?
14:21:26 <luqui> i.e. maybe we have space leaks because our FRPs are not conserving energy :-)
14:21:43 <jmcarthur> reality is a fold over the time line, and experience is the accumulator
14:21:59 <mental> toketoketoke
14:22:07 <luqui> amen :-)
14:22:23 <edwardk> luqui: i mostly got a fairly discrete message passing model out of it. with the notion of 'speed of light/event horizon' which could be correlated to message round trips
14:22:43 <edwardk> mental: hah
14:23:25 <sinelaw> jmcarthur, exactly, but continuous
14:23:36 <jmcarthur> sinelaw: who says a fold can't be continuous?
14:25:09 <Cale> Heh, this line of reasoning about describing the semantics of FRP in terms of systems of differential or integral equations makes me wonder if there's an appropriate definition of "energy" of functionally reactive systems :)
14:25:16 <edwardk> luqui: i was trying to erase uniform time by replacing it with the notion of a causal domain, with local event ordering, so if you sent a message and received one back you had a synchronization for a causal domain. i suppose you could extend it to something continuous and get a Lorentzian manifold of some sort, but those synchronization events really are discrete
14:25:48 <luqui> mmm causal domains
14:25:56 <luqui> i had those too.  don't remember if i wrote about them.
14:26:43 <sinelaw> conal, so what are exactly the undenotable semantic values in FRP?
14:27:03 <luqui> sinelaw, conal.net/blog
14:27:15 <Cale> Eventually we'll write functionally reactive programs by describing some kind of potential field in some kind of abstract state space.
14:27:34 <edwardk> and cale will be the only person smart enough to debug them ;)
14:27:51 <sinelaw> Cale, that's why i was asking about generalization of integration
14:27:53 <koeien37> PhD in GUI design required :)
14:27:57 <Cale> and FRP execution will become function minimisation
14:27:58 <luqui> I wrote a hamiltonian integrator for one of my frp experiements :-)
14:28:26 <koeien37> program needs to start for 20 minutes before the first button is displayed :)
14:28:30 <luqui> when one obsesses for as long as i did, one tries all sorts of bonkers things
14:28:38 <edwardk> luqui: heh now i'm stuck thinking about those synchronization events in the context of my earlier ramblings about hazard/glitch-free asynchronous FRP ;)
14:28:43 <luqui> :-)
14:28:44 <koeien37> but seriously, I think it's a very cool idea. Not yet practical of course :)
14:28:52 <luqui> koeien37, how do you know?
14:28:57 <Cale> We'll end up using all that crazy nonlinear optimisation stuff in order to determine what programs should do.
14:29:01 <luqui> it may be more practical than you thin..
14:29:08 <koeien37> luqui: because there are not as many FRP tutorials as monad tutorials yet
14:29:23 <edwardk> koeien37: frp is like a burrito
14:29:25 <luqui> koeien37, oh you mean frp is a very cool idea, not function minimization?
14:29:33 <edwardk> koeien37: there, i have you started, now you just have to write =)
14:29:44 <koeien37> heh :)
14:29:51 <koeien37> luqui: i was referring to FRP
14:29:57 <jmcarthur> frp is like standing in a river and looking downstream
14:29:59 <luqui> yeah FRP is amazing.
14:30:12 <luqui> if we only knew what it was...
14:30:17 <koeien37> I didn't follow the whole discussion. Maybe there will be an implementation that is practical and understandable sometime
14:30:28 <jmcarthur> koeien37: the implementation is not the problem
14:30:34 <jmcarthur> it's the semantics
14:30:39 <jmcarthur> we are never satisfied
14:30:43 <copumpkin> jmcarthur: the implementation of the notion of FRP
14:30:59 <jmcarthur> the implementation of the semantics of FRP?
14:31:02 <edwardk> so my question is, what should the semantics look like? and how can the type system/operational environment change to better suit ideal frp semantics?
14:31:22 <copumpkin> FRP is a meta idea, an implementation of it is an idea, of which an implementation is a program
14:31:26 <jmcarthur> edwardk: that is our question, too ;)
14:31:42 <edwardk> jmcarthur: heh =)
14:31:45 <luqui> edwardk, we don't know what the semantics should look like :-)
14:32:00 <luqui> they should be pretty, and capture the stuff we should be able to do, and not capture the stuff we shouldn't be able to do
14:32:12 <luqui> precise software engineering, that
14:32:16 <edwardk> jmcarthur: i guess my main problem with frp is all of the notion of Time -> ... when we don't really have a scalable notion of a fixed time clock.
14:32:29 <edwardk> er all of the notions of
14:32:41 <luqui> edwardk, it's a free floating clock anyway
14:32:47 <jmcarthur> edwardk: you seem a little stuck on asynchronous systems
14:32:51 <luqui> edwardk, the idea of getting the "current time' out of Time is nonsense
14:32:58 <luqui> it's just their to ground us
14:32:59 <edwardk> jmcarthur: yes, i am =)
14:33:12 <luqui> I like relative time FRP a lot -- seems to have been abandoned
14:33:23 <edwardk> luqui: yes, but i suppose my core axe to grind with frp is that you need it at all
14:33:40 <luqui> edwardk, how so?
14:33:44 <jmcarthur> oh, we don't need it. we just want it!
14:33:56 <sproingie> FRP seems useful for stuff that's actually continuous
14:34:03 <jmcarthur> we could merely stick with imperative programming, our IO sin bin
14:34:10 <luqui> NEVER
14:34:15 <jmcarthur> and we could sacrifice composability
14:34:23 <sinelaw> if FRP is to be scalable to networking computing, that can serve as motivation to have relative time in the semantic model
14:34:29 <jmcarthur> but... what fun is that? :)
14:34:41 <jmcarthur> luqui: my current focus is on relative time semantics
14:34:44 <sproingie> running discrete events through it seems to have some theoretical niceness but I'm still not sold on the practical effect
14:34:49 <luqui> jmcarthur, cool :-)
14:34:50 <edwardk> luqui: goes back to that relativity bit, i'd like to be able to run this stuff across multiple cores in the same process, or across multiple machines in the same network, but ultimately i keep pretending that i have a numberline to string these events on, which i can never sync up
14:35:16 <sinelaw> edwardk, exactly! just what I was trying to say
14:35:32 <Absolute0> Is there a classtype that describes all types?
14:35:37 <edwardk> luqui: and treating each of those cores as a separate frp 'world' with separate clocks isn't satisfying
14:35:38 <sproingie> bottom
14:35:42 <kmc_> Absolute0, you mean a type class?
14:35:45 <Absolute0> ie (A a) => ... ... ...
14:35:50 <sproingie> Absolute0: a
14:35:53 <koeien37> Absolute0: no
14:36:03 <sproingie> no constraint at all describes all types
14:36:04 <kmc_> there's no standard one, and you can't declare it in Haskell 98, but you can with GHC extensions
14:36:08 <BMeph> conal: Nice entry! I can almost feel the intuition nibbling on my toes... ;)
14:36:09 <Absolute0> type Move = ([a -> a], [a -> Bool])
14:36:11 <edwardk> luqui: thats why i kept coming back to some notion of a causal domain
14:36:11 <koeien37> Absolute0: there is only one value of type forall a. a, and it's undefined (also called bottom or _|_)
14:36:15 <Absolute0> thats failing ^^
14:36:17 <jmcarthur> edwardk: that sounds similar to our lack of seamlessly distributed haskell
14:36:22 <Absolute0> a is not defined..
14:36:26 <koeien37> correct
14:36:26 <kmc_> Absolute0, because "a" is not in scope
14:36:32 <Absolute0> right
14:36:36 <koeien37> type Move a = ([a->a], [a -> Bool])
14:36:36 <kmc_> type Move a = ([a -> a], [a -> Bool])
14:36:41 <kmc_> or better yet
14:36:43 <sinelaw> luqui, did you see the fresh prince episode where he almost discovers the meaning of life by staying up for two days?
14:36:44 <jmcarthur> edwardk: and i suspect the issues are roughly the same
14:36:45 <koeien37> (or existentials, if that was what you wanted)
14:36:47 <kmc_> data Move a = Move [a -> a] [a -> Bool]
14:36:52 <conal> BMeph: :)
14:36:59 <luqui> sinelaw, haha no.  never watched that show.
14:36:59 <kmc_> tuples are intended for small localized use
14:37:10 <kmc_> if you create a synonym for a tuple, you should realy consider creating a proper datatype instead
14:37:16 <edwardk> luqui: where the interactions between those local agents are the only synchronization/notion of time available to you.
14:37:17 <kmc_> unless you have to use some tuple-specific function
14:37:24 <sinelaw> luqui, he fell asleep just before getting it
14:37:31 <Absolute0> kmc didnt know data accepted lists
14:37:35 <Absolute0> was about to that thanks
14:37:39 <conal> luqui: i do intend to get back to relative-time frp.  i still remember my motivation & kernel ideas.
14:37:51 <edwardk> jmcarthur: well, seamlessly distributed haskell is easy, once you give up distributed call-by-need, just make it call-by-name across machine boundaries ;)
14:37:51 <kmc_> Absolute0, the fields in "data" can be arbitrary types
14:38:04 <conal> luqui: got distracted with TCMs, auto-diff etc
14:38:09 <Cale> Heh, I just realised that programming is like taking a quotient of the physical state space of a computer which is standardised to some extent and which we can control the potential field on completely, and using that to get the effect we want on an actual computer in the complete physical state space.
14:38:09 <luqui> ah
14:38:10 <kmc_> data Foo = Foo (Maybe [Maybe (Either [Maybe Int] Char)])
14:38:17 <BMeph> Absolute: oleb calls it "C". I'm wondering if there's something "significant" to the name... =8*O
14:38:21 <jmcarthur> edwardk: what makes it more difficult for FRP to you then?
14:38:32 <kmc_> Absolute0, aside from having special syntax, lists are just another algebraic type like Maybe or Either
14:38:42 <kmc_> data List a = Cons a (List a) | Nil
14:38:42 <sinelaw> Cale, what you're doing borders on the illegal
14:38:50 <jmcarthur> edwardk: this is a highly operational issue rather than denotational which is how we prefer to work
14:38:55 <Cale> sinelaw: what?
14:38:57 <kmc_> data [] a = (:) a ([] a) | []
14:39:09 <edwardk> jmcarthur: yes, i'm a highly operational guy ;)
14:39:29 <sinelaw> Cale, it sounds like you're about to uncover a great secret :)
14:39:30 <copumpkin> data ? a b = ? a b | Nil
14:39:32 <luqui> jmcarthur, don't discard the operational offhand, just don't let it control you
14:39:38 <edwardk> jmcarthur: coz i figure if i keep ranting about enough operational options, one of them will click with what you're denoting ;)
14:39:45 <luqui> ^ advice to myself
14:39:55 <luqui> same for denotational
14:40:01 * BMeph meant to say "*oleg calls it..."
14:40:04 <jmcarthur> luqui: i prefer to discard it when thinking about abstractions
14:40:14 <ezyang> There isn't any way to define data types in GHCI, is there?
14:40:17 <jmcarthur> luqui: programming is another issue entirely, of course
14:40:32 <Cale> ezyang: apart from writing to a file and loading it ;)
14:40:36 <ezyang> eugh
14:41:12 <Cale> GHCi isn't really meant for declarations
14:41:14 <koeien37> it is somewhat inconvenient, but at the point where I'm going to write any custom types, it's often useful in case your session crashes and so on
14:41:21 <Cale> It's mainly for evaluating expressions
14:41:28 <edwardk> i guess in the end i figure its not worth denoting something i can't make run sufficiently well ;)
14:41:40 <ezyang> koeien37: I s'pose :-)
14:41:48 <dolio> Well, who cares if it's useful as long as it's pretty?
14:42:06 <jmcarthur> edwardk: if you want something operational, consider behaviorA <*> behaviorB. i'm currently implementing them as lists of values which have duration, and i'm respecting those durations while otherwise obeying ZipList semantics
14:42:48 <jmcarthur> edwardk: done lazily, i can feed those lists from the tail using IO and incrementally drop from the head purely
14:43:05 <edwardk> and i use the operational concerns as a signpost for whether or not i'm even on the right planet. the distributed clock problem to me 'smells bad' operationally. coz ultimately i'm either building an abstraction i won't be able to use beyond one of the 80 cores in my machine, or i'm building an overarching abstraction. i'd rather be working on the latter than the former.
14:43:06 <conal> jmcarthur: sounds very like my signals & segments posts
14:43:25 <BMeph> dolio: Who cares if it's pretty,as long as it's interesting? ;)
14:43:37 <jmcarthur> conal: it's operationally similar but i'm dividing my abstractions a bit differently IIRC
14:43:39 <conal> jmcarthur: which are also like paul hudak's polymorphic temporal media, i think
14:43:41 <edwardk> jmcarthur: *nods*
14:44:08 <jmcarthur> conal: i've been considering the similarities and differences between futures and durations a lot
14:44:27 <jmcarthur> conal: s/durations/values with duration/
14:45:22 <jmcarthur> edwardk: anyway, it's a roughly explained example, but it's along the lines of how i'm looking at getting the kind of semantics i want
14:45:26 <conal> jmcarthur: that connection is exactly what i was playing with before writing those posts
14:45:31 <jmcarthur> edwardk: in this case, ZipList-like semantics for a continuous domain
14:45:52 <edwardk> jmcarthur: yeah, very much like conal's signals and segments post
14:45:56 <edwardk> as he mentioned
14:45:57 <jmcarthur> right
14:46:36 <conal> jmcarthur: wanted to make sure you knew about the posts, but by all means play with possibilities yourself.
14:46:41 <edwardk> which i still give him grief about making something both a Monoid and Comonad ;)
14:46:51 <jmcarthur> edwardk: yeah, that bothered me too
14:47:12 <edwardk> you need both nonempty and monoidal segments
14:47:15 <conal> edwardk: yeah :(
14:47:22 <edwardk> and heavier weight conversions between them
14:47:31 <conal> edwardk: i'd forgotten about that flaw
14:47:41 <jmcarthur> it's not so bad
14:47:45 <edwardk> extract mempty is a bitch ;)
14:48:01 <conal> i guess the monoid/comonad tension is part of why i wandered away from relative-time frp
14:48:08 <edwardk> yeah
14:48:40 <edwardk> its not a tension, just don't oversimplify the domain, implement both, with a lightweight coercion from the comonad -> monoid, and one that comes back with a Maybe
14:49:01 <edwardk> then you can be suitably explicit
14:49:13 <jmcarthur> i've not been focusing on behaviors as entities containing duration so much. i've been sticking with the idea of streams, really
14:49:27 <jmcarthur> so the monoid doesn't make as much sense
14:49:46 <jmcarthur> besides one derived from Applicative
14:51:01 <jmcarthur> i guess you could say i'm really exploiting the relative time semantics more for the slightly more obvious implementation than for the semantics
14:51:39 <edwardk> yeah
14:52:02 <edwardk> i do really like the relative time implementation
14:52:27 <jmcarthur> the pure implementation coupled with something like my procrastinating-structure package should make it pretty easy cake
14:53:07 <edwardk> procrastinating-structure?
14:53:29 <jmcarthur> http://hackage.haskell.org/package/procrastinating-structure
14:53:55 <ezyang> whoa, cool.
14:53:58 <copumpkin> sounds like the structure for me
14:54:04 <copumpkin> I'll check it out later ;)
14:56:32 <edwardk> jmcarthur: trying to figure out that package now
14:56:53 <sinelaw> copumpkin, :)
14:57:10 <copumpkin> I hadn't come across PVars before
14:57:46 <edwardk> so a PVar is basically a clasical Future
14:57:46 <tommd> @hoogle PVar
14:57:47 <lambdabot> Language.Haskell.Syntax HsPVar :: HsName -> HsPat
14:58:08 <jmcarthur> edwardk: except that you can't force it early
14:58:19 <edwardk> jmcarthur: er promise
14:59:27 <jmcarthur> you can compare it to an IVar, but instead of blocking when forced it simply becomes either a value or _|_
14:59:34 <edwardk> yeah
15:01:13 <jmcarthur> and Structure just gives you a way to create "thunks" and fill them in later using IO
15:01:35 <edwardk> cute
15:01:58 <jmcarthur> *structured "thunks", i mean
15:02:13 <sinelaw> i'll be off now. luqui, expecting you to still be here when i wake up.
15:02:31 <copumpkin> did luqui catch the no sleep bug?
15:02:49 <vpetro> hi
15:02:57 <sinelaw> copumpkin, yip. i had it all week, but now i'm resetting
15:03:09 <edwardk> ugh, the data.pvar.structure stuff is kinda horrifying =)
15:03:34 <vpetro> can anyone tell me why i get an error if i do this:
15:03:35 <vpetro> f :: (Num a, Num b) => a -> b -> [b]
15:03:36 <vpetro> f x y = [x * y]
15:03:45 <koeien37> the * is not compatible
15:03:47 <copumpkin> :t (*)
15:03:48 <lambdabot> forall a. (Num a) => a -> a -> a
15:03:52 <copumpkin> they must be the same type
15:03:56 <jmcarthur> edwardk: yeah but after using it once or twice it becomes second nature
15:03:57 <vpetro> but 'b' is Num
15:04:06 <copumpkin> vpetro: a -> a forces them to be the same type
15:04:14 <vpetro> oh.. the same underlying type
15:04:16 <sproingie> Num is a typeclass.  * needs them to be the same type
15:04:17 <vpetro> i get it
15:04:21 <vpetro> thanks.
15:04:22 <copumpkin> vpetro: what type would Int * Double be?
15:04:23 <koeien37> b is a Num, but this can be a finite field, for example. a is a Num, this can be a Real. How can you multiply those?
15:04:25 <copumpkin> :)
15:04:45 <edwardk> i see why you did it that way though
15:06:18 <Saizan> this structure stuff seems related to zippers
15:06:26 <jmcarthur> edwardk: yeah, i had to include the Queue implementation just to make sure that readers got the idea that i intended for it to be abstracted away
15:06:27 <vpetro> copumpkin: thanks
15:06:52 <copumpkin> ddarius just showed that one of our functor laws is superfluous!
15:07:12 <koeien37> yeah, saw it on -cafe. didn't read it too carefully
15:07:24 <koeien37> i had a hunch that that might happen since i couldn't come up with a counterexample :P
15:07:35 <edwardk> jmcarthur: the queue itself is pretty neat =)
15:07:39 <copumpkin> yeah, I tried for a while and convinced myself there wasn't one
15:08:00 <jmcarthur> edwardk: thanks
15:08:07 <dolio> I'm sure I can, but it involves bottoms.
15:08:17 <copumpkin> yeah, that felt like cheating :)
15:08:18 <koeien37> that was the disclaimer
15:08:40 <copumpkin> {-# LANGUAGE TotalHaskell #-}
15:09:01 <koeien37> or dynamic checking whether you are passed a function of type a-> a or not , if you can actually do this
15:09:03 <kyagrd> copumpkin: Does that turn all options on?
15:09:13 <koeien37> no, that was a joke :)
15:09:23 <koeien37> totality means that all functions are total
15:09:23 <copumpkin> kyagrd: it turns on the termination checker (probably means turning off some extensions actually ;))
15:09:28 <sproingie> does Chuck Norris do infomercials for it?
15:09:28 <dolio> You cannot do that.
15:09:43 <dolio> Using type-case in Haskell requires class contexts.
15:09:49 <koeien37> i.e. there is no way for your program to loop
15:10:00 <koeien37> writing the hailstone numbers in that language is an exercise for the reader
15:10:10 <meanburrito920_> I'm a bit confused about what the point of literate haskell is. it doesnt seem to be more "literate" than regular haskell
15:10:18 <kyagrd> copumpkin: Well it should be more useful if you can specify that option on certain functions ... not on entire source file
15:10:25 <copumpkin> meanburrito920_: it shifts the emphasis from the code to the comments
15:10:39 <copumpkin> kyagrd: yeah :)
15:10:45 <meanburrito920_> copumpkin: ah. i can see how that would be useful.
15:10:45 <kyagrd> {# TOTAL id
15:10:48 <copumpkin> unfortunately I don't think it's coming any time soon
15:10:49 <koeien37> kyagrd: it is impossible, in general, to prove that functions terminate. You will need to do something extra
15:10:54 <jmcarthur> meanburrito920_: as in "literature"
15:11:00 <kyagrd> {-# TOTAL id # -} or something like that
15:11:03 <meanburrito920_> :)
15:11:40 <copumpkin> or even totality in the type signature
15:11:40 <koeien37> {-# TOTAL goldBach #-} goldBach = head [ list of counterexamples for goldbach conjecture ]
15:11:49 <copumpkin> not just as a pragma
15:12:02 <kyagrd> koeien37: you can have a sound not complete checker and then provide extra manual facilities for providing explicit evidences
15:12:13 <koeien37> you could, yes
15:12:39 <edwardk> while there are a number of pathological examples of what you can't typecheck in a total language, the number of practical things you can is quite amazing.
15:12:46 <copumpkin> yep
15:13:01 <koeien37> you could have a large portion checked
15:13:02 * copumpkin urges everyone to play with agda right now
15:13:04 <edwardk> i'm always amazed at what Smerdyakov gets past coq
15:13:24 <koeien37> and the infinite loop serving web requests (or whatever) left unchecked
15:13:37 <edwardk> koeien37: bah, clearly that is codata
15:13:41 <edwardk> koeien37: easy enough ;)
15:13:42 <jmcarthur> well, really, nonterminating programs aren't all that useful
15:13:42 <koeien37> ;)
15:13:58 <copumpkin> jmcarthur: unproductive ones aren't
15:14:00 <koeien37> why wouldn't they be?
15:14:06 <edwardk> jmcarthur: yeah, can't remember that last time i used an operating system or daemon ;)
15:14:07 <jmcarthur> i actually mean programs which are neither terminating nor productive
15:14:08 <kmc_> meanburrito920_, literate programming is a very old idea from Knuth which never caught on in a big way, but has some dedicated advocates
15:14:20 <koeien37> and what about halting with probability 1 ?
15:14:21 <edwardk> productive corecursion is amazingly useful though =)
15:14:22 <edwardk> yeah
15:14:29 <HaskellLove> HOW TO SOLVE PROBLEMS:NEW METHODS AND IDEAS by SPYROS KALOMITSINES this is like the best book i am about to read on problem solving. Sorry for caps look i copied the text
15:14:37 <edwardk> koeien37: depends on how much random input you have for it ;)
15:14:46 <copumpkin> HaskellLove: how can you know it's the best book when you haven't read it yet?
15:14:52 <copumpkin> :)
15:14:54 <koeien37> edwardk: suppose that I have an oracle that flips coins
15:14:59 <sproingie> literate haskell is nice for blog posts
15:15:08 <koeien37> literate haskell is nice for blog pots, yeah, and for e-mail
15:15:10 <koeien37> and lhs2TeX
15:15:19 <edwardk> koeien37: amazon mechanical turk must be cheap these days =)
15:15:20 <HaskellLove> copumpkin 35 pages blew my mind away so far, i cant even imagine what waits for me in 180 pages
15:15:26 <ezyang> > [1,]
15:15:28 <lambdabot>   <no location info>: parse error on input `]'
15:15:33 * ezyang is sad about this. 
15:15:40 <copumpkin> ezyang: what would it do?
15:15:41 <koeien37> edwardk: I'm quite serious, how would you do that in a total language?
15:15:42 <sproingie> i'm quite skeptical about the other breathless claims about literate programming
15:15:45 <ezyang> [1,] == [1]
15:15:49 <edwardk> ezyang: looking for a list section?
15:15:53 <copumpkin> ezyang: oh, we don't like messy grammars
15:15:55 <sproingie> might work for a textbook i suppose
15:15:55 <copumpkin> :P
15:16:11 <ezyang> copumpkin: oh poo. :-P
15:16:36 <copumpkin> you can have (1,) in 6.12 though ;)
15:16:38 <edwardk> koeien37: you'd take the input from the oracle or the radiation source and output the answer productively given a bounded amount of input
15:16:50 <copumpkin> not sure why tuple sections didn't get rushed through h2010 btw
15:16:54 <koeien37> f = flipCoin >>= (\x -> if x == Head then f else ())
15:16:57 <copumpkin> they're utterly uncontroversial
15:16:58 <ezyang> ooh, nice.
15:17:03 <ezyang> does (,1) work too?
15:17:08 <copumpkin> ezyang: yep
15:17:08 <sproingie> not sure why a lot of things didn't get into haskell 2010
15:17:09 <kyagrd> copumpkin: then you will need some form of dependent type
15:17:11 <copumpkin> it gives you a function though
15:17:14 <edwardk> koeien37: the input is codata, as is the output, the issue is productivity. given enough input eventually you produce output.
15:17:20 <copumpkin> kyagrd: for what?
15:17:22 <dmhouse> copumpkin: (1,) with type Num a => b -> (a,b)?
15:17:25 <sproingie> the idea of a new version every year is imho a mistake
15:17:31 <copumpkin> dmhouse: yep
15:17:35 <kyagrd> for having totality on type be meaningful
15:17:44 <edwardk> tuple sections made me happy =)
15:17:44 <koeien37> edwardk: ok, I might try to do it in agda someday to learn it :)
15:17:48 <copumpkin> kyagrd: oh yeah, maybe :)
15:17:57 <dmhouse> copumpkin: do extensions like (1,,) and (,1,) work?
15:18:04 <copumpkin> dmhouse: yep, as many as you want
15:18:08 <ezyang> whoa!
15:18:10 <idnar> huh
15:18:11 <copumpkin> (1,1,1,,True,,,6)
15:18:13 <ezyang> that's pretty gnarly
15:18:13 <edwardk> koeien37: be warned there are sharp corners lurking around agda's codata support ;)
15:18:15 <dolio> Up to 60-some, presumably.
15:18:28 <copumpkin> edwardk: ugh yeah :(
15:18:31 <koeien37> edwardk: such as? compilers' heads exploding?
15:18:33 <copumpkin> I still haven't proved luqui/s function :(
15:18:43 <kyagrd> For functions f :: A -> B to be total often is the case that when A is totoal then B is total, and sometimes not like the const function
15:19:07 <sproingie> 62 appears to be the limit
15:19:33 <idnar> jmcarthur: are nonproductive programs ever useful?
15:19:35 <copumpkin> koeien37: codata/recursion is a real pain to work with
15:19:37 <kyagrd> So, there comes some notion of dependency betwen argument totality and the result type totality
15:19:37 <kmc_> oh speaking of codata, a while back i found a coqdoc'd page about codata coinduction in coq, can't find it now, anyone have an idea what i'm talking about?
15:20:00 <copumpkin> koeien37: or maybe I just suck, but it's probably a bit of both
15:20:08 <koeien37> idnar: if they are nonproductive on only a subset of the input, I would say yes. But I don't know whether the more knowledgeable here agree
15:20:29 <edwardk> koeien37: nah, the compiler has been known to have type checking not quite work out the way you'd expect. there are some cases where you put something in and can't get it out and apply the same type to it
15:21:17 <edwardk> koeien37: loss of subject reduction, lemme find it
15:21:30 <edwardk> http://article.gmane.org/gmane.comp.lang.agda/226
15:21:42 <systemfault> Hey... How come ghc isn't able to optimize simple things like: n `div` 2 to n `shiftR` 1 ?
15:21:43 <dolio> Agda doesn't lose subject reduction anymore.
15:21:51 <edwardk> dolio: ah
15:21:52 <systemfault> Why do I have to do it manually&
15:21:57 <kmc_> systemfault, did you look at the assembly output?
15:22:02 <edwardk> dolio: sorry for spreading old fud ;)
15:22:03 <copumpkin> systemfault: how do you know it doesn't?
15:22:03 <koeien37> systemfault: what type is n ?
15:22:14 <HugoDaniel> hi
15:22:14 <systemfault> kmc_: I just made the test.
15:22:29 <systemfault> koeien37: Int
15:22:34 <kmc_> and you timed it?
15:22:36 <copumpkin> did you compile with -O2?
15:22:41 <systemfault> kmc_: Sure
15:22:42 <copumpkin> or did you actually read the assembly?
15:22:46 <systemfault> copumpkin: Yes I did
15:22:52 <dolio> Coq still may, though.
15:22:56 <systemfault> copumpkin: I timed it, I didn't look at the asm
15:22:59 <kmc_> it might relate to strictness
15:23:01 <dolio> I don't know if anyone's paying attention to the codata in Coq.
15:23:03 <koeien37> edwardk: I don't understand that program fragment. Maybe if I read some tutorials on it :)
15:23:18 <kmc_> or just the fact that Data.Bits is less "fundamental" than the prelude numerical stuff
15:23:32 <copumpkin> well, it wouldn't use actual Data.Bits
15:23:44 <kmc_> i would not expect it to use Data.Bits.shiftR under any case.  i would expect that with the right strictness analysis it would generate a division which the backend could optimize to a shift
15:23:46 <kmc_> yeah
15:23:47 <copumpkin> the codegen should still know about bit operations
15:23:49 <systemfault> kmc_: That version is a LOT faster http://www.ideone.com/C8p05DFY
15:23:52 <koeien37> what about negative numbers?
15:24:04 <systemfault> koeien37: Ah... You're right.
15:24:08 <koeien37> > (-1) `div` 2
15:24:09 <lambdabot>   -1
15:24:10 <copumpkin> there's often a distinction between an arithmetic shift and a bitwise shift
15:24:10 <edwardk> systemfault: largely because that is very much type dependent. strength reduction works better when punted to a lower level optimizer.
15:24:14 <koeien37> > (-1) `shiftR` 1
15:24:15 <lambdabot>   Ambiguous type variable `a' in the constraint:
15:24:15 <lambdabot>    `Data.Bits.Bits a'
15:24:15 <lambdabot>      a...
15:24:21 <koeien37> > (-1) `shiftR` 1 :: Int
15:24:22 <lambdabot>   -1
15:24:28 <koeien37> hmm.
15:24:36 <koeien37> I think in general this might go wrong :)
15:24:51 <copumpkin> http://en.wikipedia.org/wiki/Arithmetic_shift
15:24:56 <tensorpudding> > 1 .|. (-1)
15:24:57 <lambdabot>   Ambiguous type variable `t' in the constraint:
15:24:58 <lambdabot>    `Data.Bits.Bits t'
15:24:58 <lambdabot>      a...
15:24:58 <koeien37> try Word32
15:25:01 <systemfault> I was just having fun trying to get my code to be as fast (Or nearly) as the C version
15:25:02 <dolio> idnar: I'd probably say that non-productive, non-terminating programs aren't useful, pretty much by definition. The issue is that you can't eliminate non-productive programs without also eliminating productive programs.
15:25:23 <dolio> Eliminating some productive programs, that is.
15:25:28 <edwardk> systemfault: try compiling with  via-C, and cranking the c optimizations ;)
15:25:39 <systemfault> edwardk: I did :)
15:25:41 <dolio> Same with terminating programs.
15:25:51 <koeien37> @qc \(x::Int) -> x `shiftR` 1 == x `div` 2
15:25:51 <lambdabot> Not enough privileges
15:25:53 <edwardk> systemfault: and you still didn't get strength reduction there?
15:25:56 <koeien37> o rly?
15:26:00 <copumpkin> @check
15:26:01 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
15:26:01 <edwardk> systemfault: is that on an Int or an Integer?
15:26:05 <koeien37> @check \(x::Int) -> x `shiftR` 1 == x `div` 2
15:26:05 <lambdabot>   Parse error in pattern at "->" (column 11)
15:26:09 <systemfault> edwardk: Int
15:26:15 <koeien37> @check \x -> (x::Int) `shiftR` 1 == x `div` 2
15:26:16 <lambdabot>   "OK, passed 500 tests."
15:26:19 <systemfault> edwardk: The code http://www.ideone.com/C8p05DFY
15:26:30 <copumpkin> koeien37: shiftR is arithmetic
15:26:36 <br1> how can I convert a .lhs file to .hs? (I actually want to generate a .chs file for the shuffle tool, but I doubt that's automated)
15:27:00 <koeien37> copumpkin: oh. I never realized that
15:27:02 <copumpkin> systemfault: I wouldn't do such low-level optimization for euler problems btw ;)
15:27:34 <kmc_> br1, perhaps some option to ghc to make it dump code at an early stage
15:27:37 <systemfault> copumpkin: Was just for fun :)
15:27:38 <Saizan> br1: there's a flag for ghc that does that iirc
15:27:43 <edwardk> systemfault: hrmm, and with --via-C and -fstrength-reduce doesn't cause it?
15:27:43 <copumpkin> :)
15:27:55 <systemfault> edwardk: I didn't try -fstrength-reduce
15:28:08 <edwardk> systemfault it should be implicit even with a fairly low level of -On
15:28:18 <idnar> dolio: sure
15:28:21 <copumpkin> -fvia-C -optc-O3
15:29:12 <edwardk> anyways. gotta run
15:29:20 <copumpkin> quick, catch him
15:29:23 <edwardk> ack!
15:29:23 <systemfault> :)
15:29:27 <edwardk> omg a copumpkin!
15:29:32 <copumpkin> :P
15:29:37 <copumpkin> fine, you can go
15:29:49 * edwardk watches half of the mob go after edwardk1
15:35:58 <br1> kmc_: Saizan: http://www.haskell.org/ghc/docs/latest/html/users_guide/flag-reference.html#id2956336 the closest thing is -keep-hc-file but it dumps a later stage
15:38:16 <ezyang> Is mappend commutative?
15:38:25 <kmc_> no
15:38:25 <koeien37> not necessarily
15:38:31 <kmc_> > "a" `mappend "b"
15:38:32 <lambdabot>   <no location info>: parse error on input `"'
15:38:35 <kmc_> > "a" `mappend` "b"
15:38:36 <lambdabot>   "ab"
15:38:40 <kmc_> > "b" `mappend` "a"
15:38:41 <ezyang> OK. I was wondering if there was a monoid law that said that should be true
15:38:42 <lambdabot>   "ba"
15:38:53 <kmc_> ezyang, nope.  monoids have associativity and identity, that's all
15:38:58 <koeien37> no, a monoid has a unit and an associative operator
15:39:10 <kmc_> add inverse and you have a group, add commutivity and you have an abeilan group
15:39:31 <koeien37> commutative monoids exist, but a monoid or group on itself is not required to be commutative
15:40:44 <koeien37> why is there no typeclass Group?
15:40:53 <koeien37> i remember defining one myself once
15:42:10 <copumpkin> koeien37: there is, if you can bear Algebra.Group.C or whatever it was called
15:42:19 <koeien37> ahw, numeric-prelude
15:42:55 <copumpkin> I played with haskell algebra for a while and decided I didn't like it
15:43:09 <koeien37> too much hassle?
15:43:25 <copumpkin> well, I was being too anal
15:43:33 <br1> kmc_: Saizan: it turns out there is an unlit program buried inside ghc
15:43:42 <br1> ghc -v told me about it
15:43:46 <br1> thx!
15:43:54 <kmc_> br1, cool, good to know :)
15:44:16 * koeien37 notices Data.Groupoid now. That's not the groupoid from CT. *sigh*
15:54:13 <mreh> how could I make a patchwork of lists?
15:54:39 <kmc_> what is a "patchwork"?
15:54:54 <mreh> let me define what I mean
15:54:55 <Cale> koeien37: Yeah, I prefer "magma" for "set with binary operation and no axioms".
15:55:04 <koeien37> me too
15:55:08 <koeien37> bourbaki style
15:56:28 <ray> i bourbaked you a cake from magma but i eated it
15:57:08 <Cale> http://en.wikipedia.org/wiki/Template:Group-like_structures -- I like this table :)
15:58:06 <copumpkin> I assume that the structures that don't have names haven't been explored much?
15:58:08 <mreh> something like this: mixUp [1,2,3,4,5] [a,b,c,d,e] = [1,2,c,4,e]
15:58:23 <Cale> copumpkin: I think that's a fairly safe assumption.
15:58:28 <copumpkin> mreh: how does it choose?
15:58:41 <mreh> copumpkin: stochastically
15:58:49 <ray> pretty cool, except it's over on the right side of the page
15:59:00 <copumpkin> mreh: so it's in IO
15:59:00 * koeien37 has never heard of Loop
15:59:26 <mreh> copumpkin: better still -- Rand g [a]
15:59:40 <copumpkin> fair enough
15:59:45 <ray> quasigroups are uncommon
15:59:58 <mreh> chunking the list would be even better
16:00:28 <mreh> mixUp 2 [1,2,3,4,5,6] [a,b,c,d,e,f] = [1,2,3,4,e,f]
16:01:17 <kmc_> :t randoms :: Bool
16:01:19 <lambdabot>     Couldn't match expected type `Bool'
16:01:19 <lambdabot>            against inferred type `g -> [a]'
16:01:19 <lambdabot>     In the expression: randoms :: Bool
16:01:20 <kmc_> :t randoms
16:01:21 <lambdabot> forall g a. (Random a, RandomGen g) => g -> [a]
16:01:58 <mreh> randoms =<< getStdGen
16:02:09 <mreh> > randoms =<< getStdGen
16:02:10 <lambdabot>   Couldn't match expected type `[a]'
16:02:10 <lambdabot>         against inferred type `GHC.IOBas...
16:02:23 <mreh> :t getStdGen
16:02:24 <lambdabot> IO StdGen
16:02:49 <koeien37> :t randoms `liftM` getStdGen
16:02:50 <lambdabot> forall a. (Random a) => IO [a]
16:02:57 <kmc_> > zipWith3 (\x y b -> if b then x else y) "abcde" "uwxyz" . randoms $ mkStdGen 1337
16:02:58 <lambdabot>   "awxdz"
16:03:06 <jfoutz> class Mix where; type Mix = forall a. (Mix a) => a; instance Mix Int where; instance Mix Char where;
16:03:11 <jfoutz> or something like that.
16:04:07 <mreh> :t zipWith3
16:04:09 <lambdabot> forall a b c d. (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
16:04:10 <kmc_> > zipWith3 (\x y -> ([x,y]!!) . fromEnum) "abcde" "uwxyz" . randoms $ mkStdGen 1337
16:04:11 <lambdabot>   Ambiguous type variable `c' in the constraints:
16:04:12 <lambdabot>    `GHC.Enum.Enum c'
16:04:12 <lambdabot>      a...
16:05:10 <kmc_> > zipWith3 (([const, flip const] !!) . fromEnum) (randoms $ mkStdGen 1337 :: [Bool]) "abcde" "uwxyz"
16:05:11 <lambdabot>   "ubcye"
16:05:39 <nando> hello
16:05:50 <kmc_> > zipWith3 (([const, flip const] !!) . fromEnum) (randoms $ mkStdGen 1338 :: [Bool]) "abcde" "uwxyz"
16:05:52 <kmc_> hi nando
16:05:52 <lambdabot>   "uwcde"
16:05:53 <koeien37> hi nando
16:06:02 <nando> i need some help
16:06:11 <kmc_> okay
16:06:16 <kmc_> what's the problem? :)
16:06:23 <nando> anyone knows how a turing machien works
16:06:29 <kmc_> wikipedia knows
16:06:37 <kmc_> do you have a specific question?
16:06:52 <nando> well what i need to do is optimize a action table and make it smaller and more efficient
16:06:58 <kmc_> in Haskell?
16:07:01 <nando> yeps
16:07:02 <copumpkin> ;)
16:07:19 <copumpkin> how are you representing your structures?
16:07:19 <kmc_> nando, how much better
16:07:22 <nando> i know what i nee dot do but can't figure out how to do it in haskell
16:07:30 <kmc_> it's certainly undecidable to find the smallest equivalent machine
16:07:38 <kmc_> nando, okay... are you stuck in some particular place?
16:07:42 <kmc_> how to represent the machine, maybe?
16:07:49 <nando> yeah the start lol
16:07:55 <kmc_> nando, do you know Data.Map?
16:08:03 <nando> nopes? whats that
16:08:08 <kmc_> a Haskell module
16:08:14 <copumpkin> nando: well, how does the assignment suggest you simplify the TM?
16:08:15 <kmc_> http://haskell.org/ghc/docs/6.10-latest/html/libraries/index.html
16:08:16 <mreh> kmc_ can I generalise this to n lists?
16:08:36 <mreh> zip the result with another list I suppose
16:08:37 <kmc_> mreh, yes, not with zipWith
16:08:39 <kmc_> probably with transpose and (!!)
16:08:46 <kmc_> a nested zip will be biased
16:08:54 <mreh> kmc_ yes
16:09:01 <nando> how i expressed my left wrong, let me try to explain better
16:09:20 <nando> i have a action table with 9 states
16:09:29 <nando> that can be expressed in 5
16:09:33 <mreh> :t transpose
16:09:34 <lambdabot> forall a. [[a]] -> [[a]]
16:09:43 <kmc_> > transpose (words "abc def")
16:09:43 <nando> becouse 2 of those are in a cicle
16:09:44 <lambdabot>   ["ad","be","cf"]
16:09:56 <nando> like 6 send to 7 and 7 sent to 6
16:10:12 <nando> and 2 others are just duplications
16:10:27 <copumpkin> nando: oh, so it's a specific case?
16:10:33 <nando> yeah
16:10:38 <copumpkin> where does haskell come in? you have a TM simulator?
16:10:56 <nando> i just can't figure out how to teste for those cases to delete the entries
16:11:14 <nando> i already did the hasked simulator for the TM
16:11:17 <kmc_> can you describe in natural langugage which states you want to find?
16:11:20 <nando> and it works good
16:11:33 <mreh> @src transpose
16:11:33 <lambdabot> transpose []             = []
16:11:33 <lambdabot> transpose ([]   : xss)   = transpose xss
16:11:33 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
16:12:06 <mreh> that seems inefficient
16:12:11 <mreh> maybe not
16:13:26 <nando> what's that site i can post code?
16:13:31 <mreh> @paste
16:13:32 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
16:13:34 <nando> where I*
16:14:11 <nando> txt
16:14:53 <mreh> np
16:15:43 <mreh> > tranpose . words "abcd 123 qwerty"
16:15:43 <tommd> ... What happened to hpaste? ... ahh, spammed to heck.
16:15:44 <lambdabot>   Not in scope: `tranpose'
16:15:50 <mreh> > transpose . words "abcd 123 qwerty"
16:15:51 <lambdabot>   Couldn't match expected type `[a]'
16:15:51 <lambdabot>         against inferred type `GHC.Types...
16:16:02 <mreh> > transpose . words $ "abcd 123 qwerty"
16:16:04 <lambdabot>   ["a1q","b2w","c3e","dr","t","y"]
16:17:39 <nando> I posted here http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5944#a5944 the 2 action tables
16:17:57 <mreh> it make a ragged array, infact, it makes a wrong array
16:18:20 <nando> can some have a look and give me a hint on what i need to do in order to check the original action table
16:18:49 <mreh> nando, is this a TM?
16:19:26 <nando> that's just the action table that the TM uses
16:19:36 <mreh> this is a haskell channel
16:20:08 <nando> yeah i need to do a haskell funtion that will performe this aptimization of the tables
16:20:19 <nando> optimization*
16:22:17 <nando> this actions are in a list of [(Char,Char,Char,Char,Char)]
16:22:52 <nando> been [(inicial state,read,final state,write,move)]
16:24:21 <jfoutz> why can 6 and 7 be deleted?
16:24:22 <Saizan> 6 and 7 can be deleted because no other state point ot them, right?
16:24:29 <nando> yeps
16:24:35 <nando> and 8 is the same as 1
16:24:40 <nando> and 9 is the same as 2
16:25:14 <nando> so can also be deleted and on stage 5 where there is a 8 should be a 1
16:25:14 <jfischoff> How does one make a Gen in QuickCheck that only generates Doubles s.t. 0 <= x <= 1?
16:25:58 <Saizan> well, you could start from the initial state, and take the states reachable from it, then you do this again for these new states etc. until you don't add any more states to this set, the remnant ones can be deleted
16:27:16 <nando> i thought of that but can't figure out how to do it because for exemple there's 2 actions with the same inicial state
16:27:47 <Saizan> which two?
16:27:52 <mreh> I can't see how transpose works, how can you match [] to (h:t)?
16:28:06 <Cale> @src transpose
16:28:06 <lambdabot> transpose []             = []
16:28:07 <lambdabot> transpose ([]   : xss)   = transpose xss
16:28:07 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
16:28:14 <nando> 2, 3,4,5
16:28:14 <kmc_> there are three cases
16:28:16 <mreh> > transpose . words $ "abcd 123 qwerty"
16:28:18 <lambdabot>   ["a1q","b2w","c3e","dr","t","y"]
16:28:18 <Cale> mreh: it will skip those
16:28:22 <jfoutz> mreh, it's like zip, whenever any of the lists run out, it drops the rest
16:28:28 <kmc_> the argument is a list of lists
16:28:33 <kmc_> which is why the pattern ([] : xss) makes sense
16:28:34 <jfoutz> > zip "abc" [1..]
16:28:35 <lambdabot>   [('a',1),('b',2),('c',3)]
16:28:41 <mreh> jfoutz: it isn't like zip
16:28:52 <Cale> > [x | Just x <- [Nothing, Just 1, Nothing, Nothing, Just 2, Just 3]]
16:28:52 <lambdabot>   [1,2,3]
16:29:08 <jfoutz> @src zip
16:29:09 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
16:29:09 <lambdabot> zip _      _      = []
16:29:25 <Cale> > [x | (x:xs) <- [[1,2,3],[],[],[4,5],[6,7,8]]]
16:29:26 <lambdabot>   [1,4,6]
16:29:28 <mreh> tranpose with an infinite list wont work I feel
16:29:44 <jfoutz> hmm.
16:29:45 <Cale> > transpose . tails $ [1..]
16:29:46 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
16:29:48 <mreh> > transpose [[1,2,3],[1..]]
16:29:50 <lambdabot>   [[1,1],[2,2],[3,3],[4],[5],[6],[7],[8],[9],[10],[11],[12],[13],[14],[15],[1...
16:30:00 <mreh> just gives you an infinite list that is
16:30:01 <kmc_> mreh, it works fine on a finite list of infinite lists
16:30:01 <jfoutz> transpose ["abc",['a'..]]
16:30:02 <Cale> > map (take 5) . transpose . tails $ [1..]
16:30:03 <lambdabot>   [[1,2,3,4,5],[2,3,4,5,6],[3,4,5,6,7],[4,5,6,7,8],[5,6,7,8,9],[6,7,8,9,10],[...
16:30:07 <jfoutz> > transpose ["abc",['a'..]]
16:30:07 <kmc_> as you just demonstrated
16:30:08 <lambdabot>   ["aa","bb","cc","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r"...
16:30:14 <kmc_> > transpose (repeat "ab")
16:30:15 <lambdabot>   ["aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
16:30:19 <jfoutz> oh.
16:30:23 <mreh> kmc_ I was using a different definition of "work" :)
16:30:27 <idnar> haha
16:30:35 <Cale> The implementation of transpose is rather subtle
16:30:39 <kmc_> on an infinite list of lists, it will never reach the second element of any list
16:30:49 <kmc_> mreh, not the Haskell definition then? ;)
16:30:59 <mreh> kmc_ :D
16:31:48 <Cale> oh?
16:32:11 <Cale> > map (take 5) . transpose $ [[n,n*2] | n <- [0..]]
16:32:15 <lambdabot>   mueval-core: Time limit exceeded
16:32:26 <Cale> > take 2 . map (take 5) . transpose $ [[n,n*2] | n <- [0..]]
16:32:27 <lambdabot>   [[0,1,2,3,4],[0,2,4,6,8]]
16:32:43 <mreh> my head hurts
16:32:44 <kmc_> Cale, you're right
16:33:08 <copumpkin> > take 2 . map (take 5) . transpose $ [[n,n+1..] | n <- [0..]]
16:33:10 <lambdabot>   [[0,1,2,3,4],[1,2,3,4,5]]
16:33:20 <kmc_> lazy lists are control flow structures :)
16:33:30 <kmc_> your (take 5) forces an early exit from a loop it's coroutined with
16:33:36 <kmc_> that's pretty cool
16:33:59 <Cale> The take 2 is also important
16:34:24 <Cale> because it's incapable of knowing that there won't be a third element in any of the infinitely many lists that it's transposing
16:34:45 <copumpkin> > take 3 . map (take 5) . transpose $ [[n,n+1..] | n <- [0..]]
16:34:47 <lambdabot>   [[0,1,2,3,4],[1,2,3,4,5],[2,3,4,5,6]]
16:34:49 <mreh> > repeat 'a' : "h"
16:34:51 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
16:34:51 <lambdabot>         against inferred ty...
16:35:02 <mreh> :(
16:35:07 <mreh> forget that, it was just a joke
16:35:22 <copumpkin> > take 3 . map (take 5) . transpose $ [[n,n+1] | n <- [0..]]
16:35:26 <lambdabot>   mueval-core: Time limit exceeded
16:35:26 <copumpkin> that won't terminate
16:35:29 <kmc_> > cycle "badger "
16:35:30 <lambdabot>   "badger badger badger badger badger badger badger badger badger badger badg...
16:35:34 <Cale> > concat . transpose $ ["abcde","12345"]
16:35:35 <lambdabot>   "a1b2c3d4e5"
16:35:49 <Cale> ^^ useful way to define interleave
16:35:57 <kmc_> > fix (interleave ['0'..'9'])
16:35:58 <lambdabot>   "00102130425163708492516370849251637084925163708492516370849251637084925163...
16:36:12 <Cale> > fix (interleave [0..])
16:36:13 <lambdabot>   [0,0,1,0,2,1,3,0,4,2,5,1,6,3,7,0,8,4,9,2,10,5,11,1,12,6,13,3,14,7,15,0,16,8...
16:36:26 <kmc_> > let il x y = concat . transpose $ [x,y] in fix (il ['0'..'9'])
16:36:28 <lambdabot>   "00102130425163708492516370849251637084925163708492516370849251637084925163...
16:36:37 <mreh> wtf!
16:36:39 <kmc_> @oeis 0,0,1,0,2,1,3,0,4,2,5,1,6,3,7,0,8
16:36:40 <lambdabot>  a(2n) = n, a(2n+1) = a(n).
16:36:40 <lambdabot>  [0,0,1,0,2,1,3,0,4,2,5,1,6,3,7,0,8,4,9,2,10,5,11,1,12,6,13,3,14,7,15,0,16,8,...
16:37:10 <Cale> > let interleave xs ys = concat . transpose $ [xs,ys] in fix (interleave [0..])
16:37:11 <lambdabot>   [0,0,1,0,2,1,3,0,4,2,5,1,6,3,7,0,8,4,9,2,10,5,11,1,12,6,13,3,14,7,15,0,16,8...
16:37:43 <Cale> Just try to follow the evaluation explicitly ;)
16:37:59 <mreh> my brane hurts
16:38:06 <mreh> :D~~~~
16:38:39 <kmc_> i'm gonna say... head popped off and sailing into the air like a balloon
16:39:05 * mreh drools
16:39:10 <kmc_> ah
16:40:12 <copumpkin> > zipWith (-) (let interleave xs ys = concat . transpose $ [xs,ys] in fix (interleave [0..])) (fix (interleave [0..]))
16:40:14 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
16:40:17 <mreh> so taking random parts of lists, that's a hard problem, because transposing a ragged skips empty lists
16:40:31 <mreh> ragged array
16:40:56 <mreh> i suppose i could redefine tranpose
16:41:15 <mreh> but there is no "empty" value is there
16:41:17 <Cale> What are you trying to do?
16:41:54 <mreh> > zipWith3 (([const, flip const] !!) . fromEnum) (randoms $ mkStdGen 1338 :: [Bool]) "abcde" "uwxyz" -- generalise that into n lists
16:41:55 <lambdabot>   "uwcde"
16:42:16 <kmc_> but what if they're not the same length?
16:42:22 <kmc_> you choose from among the ones that haven't run out yet?
16:42:29 <kmc_> > transpose "abcde" "xy"
16:42:30 <lambdabot>   Couldn't match expected type `[a]'
16:42:31 <lambdabot>         against inferred type `GHC.Types...
16:42:35 <kmc_> > transpose ["abcde","xy"]
16:42:36 <Cale> The right way to do that is to use mapM in the Random monad.
16:42:37 <lambdabot>   ["ax","by","c","d","e"]
16:43:01 <mreh> :t mapM
16:43:02 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
16:43:16 <Cale> (and yeah, probably transpose)
16:43:59 <mreh> choosing a random element is hard when the list is shorter than the others
16:44:07 <Cale> hm?
16:44:25 <Cale> Don't you just want to select one from the others?
16:44:43 <Cale> > ["abcde", "fghijklmnop"]
16:44:47 <lambdabot>   ["abcde","fghijklmnop"]
16:44:48 <Cale> > transpose ["abcde", "fghijklmnop"]
16:44:49 <lambdabot>   ["af","bg","ch","di","ej","k","l","m","n","o","p"]
16:45:10 <kmc_> all you need to do is mapM some function to pick a random element of each list
16:45:16 <Cale> right
16:45:20 <mreh> then I need to count each one :(
16:45:34 <kmc_> yeah
16:45:39 <mreh> slooow
16:45:40 <Cale> mreh: You want to cut each list off at the length of the shortest?
16:45:45 <Cale> oh
16:45:46 <mreh> Cale: no
16:45:52 <kmc_> you could make a fancier transpose which stores the lengths too
16:46:02 <Cale> Oh, you mean in selecting a random element?
16:46:02 <kmc_> but also, you save nothing asymptotically
16:46:12 <kmc_> because you expect to walk halfway into each list
16:46:16 <limpac> hello
16:46:17 <kmc_> to get the (n/2)th element
16:46:19 <kmc_> no way around that
16:46:31 <kmc_> if you want fast random access you'll have to use another strugcture, like Data.Sequence
16:46:32 <kmc_> hello limpac
16:48:31 <kmc_> there is an algorithm to produce a uniform sample of k elements from a linked list of unknown length, in only one traversal
16:49:27 <jfoutz> something like unfoldr (\xss -> Just (head $ xss !! random, map tail b))
16:49:29 <mreh> it's the uniform bit that makes it so hard
16:49:29 <copumpkin> kmc_: how much space?
16:49:48 <jfoutz> er tail xss
16:49:54 <elly> is this a homework problem? I've seen it before a lot, and I don't want to spoil it
16:50:04 * jfoutz waves his hands at random number generation
16:50:21 <kmc_> O(k)
16:50:46 <limpac> hi  kmc
16:50:48 <mreh> why do I just make transposeMaybe :: [[a]] -> [[Maybe a]]
16:50:49 <kmc_> it's an interview question i've heard
16:50:50 <elly> the solution to choosing 1 element randomly from a stream of unknown length is cool
16:50:56 <kmc_> probably on some homeworks too
16:50:57 <jfoutz> oh... yeah knuth has a trick
16:51:03 <elly> yeah, I saw it my freshman year
16:51:03 <kmc_> elly, you can probably generalize it to k
16:51:17 <elly> take the ith element with probability 1/i
16:51:19 <Cale> Takes a bit of thinking initially, but it's not too hard to come up with :)
16:51:25 <elly> generalizing it to k is not hard from there
16:51:26 <jzleibo> what's the question you are all talking about?
16:51:35 <kmc_> there is an algorithm to produce a uniform sample of k elements from a linked list of unknown length, in only one traversal
16:51:36 <mreh> i dont know :(
16:51:56 <kmc_> in O(k) space
16:52:00 <elly> indeed
16:52:04 <elly> I gave away the secret above :P
16:52:42 <kmc_> :t transpose . map ((++ cycle Nothing) . map Just)
16:52:44 <lambdabot>     Couldn't match expected type `[a]' against inferred type `Maybe a1'
16:52:44 <lambdabot>     In the first argument of `cycle', namely `Nothing'
16:52:44 <lambdabot>     In the second argument of `(++)', namely `cycle Nothing'
16:53:06 <kmc_> :t transpose . map ((++ repeat Nothing) . map Just)
16:53:08 <lambdabot> forall a. [[a]] -> [[Maybe a]]
16:53:42 <kmc_> > let f = transpose . map ((++ repeat Nothing) . map Just) in f (words "we alone on earth have the power to free ourselves from the tyranny of the selfish replicators")
16:53:44 <lambdabot>   [[Just 'w',Just 'a',Just 'o',Just 'e',Just 'h',Just 't',Just 'p',Just 't',J...
16:53:44 <mreh> kmc_: very nice
16:54:04 <kmc_> > let f = transpose . map ((++ repeat Nothing) . map Just) in f (words "ab c")
16:54:05 <lambdabot>   [[Just 'a',Just 'c'],[Just 'b',Nothing],[Nothing,Nothing],[Nothing,Nothing]...
16:54:53 <kmc_> > let f = takeWhile (isJust . head) . transpose . map ((++ repeat Nothing) . map Just) in f (words "ab c")
16:54:55 <lambdabot>   [[Just 'a',Just 'c'],[Just 'b',Nothing]]
16:55:06 <mreh> so how do you get the first just in a list?
16:55:06 <kmc_> boo hiss head
16:55:29 <copumpkin> mreh: listToMaybe . catMaybes ?
16:55:37 <kmc_> > msum [Just 3, Just 29, Nothing]
16:55:38 <lambdabot>   Just 3
16:55:44 <kmc_> > msum [Nothing, Just 3, Just 29, Nothing]
16:55:45 <lambdabot>   Just 3
16:55:52 <mreh> yeah, i thought it was part of mplus
16:55:59 <kmc_> :t msum
16:56:00 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
16:56:01 <kmc_> :t mconcat
16:56:02 <lambdabot> forall a. (Monoid a) => [a] -> a
16:56:05 <kmc_> > mconcat [Nothing, Just 3, Just 29, Nothing]
16:56:07 <lambdabot>   Ambiguous type variable `a' in the constraints:
16:56:07 <lambdabot>    `GHC.Num.Num a' arising ...
16:56:13 <mreh> haskell is purdey
16:56:23 <kmc_> > mconcat [Nothing, Just 3, Just 29, Nothing] :: Just Int
16:56:24 <mreh> i'm going to ask for more help in the future
16:56:25 <lambdabot>   Not in scope: type constructor or class `Just'
16:56:29 <kmc_> durr
16:56:31 <kmc_> > mconcat [Nothing, Just 3, Just 29, Nothing] :: Maybe Int
16:56:32 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Int)
16:56:33 <lambdabot>    arising from a use of...
16:56:34 <copumpkin> > mconcat [Nothing, Just (Sum 3), Just (Sum 29), Nothing]
16:56:36 <lambdabot>   Just (Sum {getSum = 32})
16:56:41 <kmc_> oh
16:56:45 <kmc_> why isn't Maybe a monoid?
16:56:48 <kmc_> or am i failing
16:56:50 <copumpkin> it is
16:56:57 <copumpkin> if the thing inside is a monoid
16:56:58 <kmc_> > Nothing `mappend` (Just 3)
16:57:00 <lambdabot>   Ambiguous type variable `a' in the constraints:
16:57:00 <lambdabot>    `GHC.Num.Num a' arising ...
16:57:12 <copumpkin> Int isn't an instance of Monoid
16:57:20 <kmc_> err right
16:57:35 <ehamberg> i want to create a pdf of http://www.cse.unsw.edu.au/~dons/tmp/nim/EvolvableNim.lhs, so i do ‚Äúlhs2TeX -i ~/.cabal/share/lhs2tex-1.15/lhs2TeX.fmt EvolvableNim.lhs‚Äù. but pdflatex fails. it looks wrong, too: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15607
16:57:39 <ehamberg> what am i doing wrong? :)
16:57:53 <kmc_> so it's not as simple as (forall a. Monoid (m a)) <=> (MonadPlus m)
16:58:03 <mreh> :t catMaybes
16:58:04 <lambdabot> forall a. [Maybe a] -> [a]
16:58:11 <copumpkin> kmc_: nope
16:58:13 <mreh> :t listMaybes
16:58:14 <lambdabot> Not in scope: `listMaybes'
16:58:25 <mreh> :t listToMaybe
16:58:27 <lambdabot> forall a. [a] -> Maybe a
16:58:36 <copumpkin> > msum [] :: Maybe Int
16:58:38 <lambdabot>   Nothing
16:58:54 <jfoutz> > unfoldr (\xss -> if null xss then Nothing else Just (head $ xss !! 0, filter (not.null) $ map tail xss)) ["abc","def"]
16:58:56 <lambdabot>   "abc"
16:59:03 <mreh> @src (Maybe) msum
16:59:04 <lambdabot> Source not found. Are you on drugs?
16:59:07 <jfoutz> not sure how to pick random (length list)
16:59:08 <mreh> yes
16:59:12 <kmc_> @check \xs -> (listToMaybe . catMaybes $ xs) == msum xs
16:59:15 <lambdabot>   "OK, passed 500 tests."
16:59:15 <copumpkin> > sequence [Just 5, Just 7]
16:59:16 <lambdabot>   Just [5,7]
16:59:52 <mreh> :t msum
16:59:54 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
17:00:35 <limpac> whats the talk here guys
17:00:36 <Cale> > let selectR (x:xs) = sR x (zip [2..] xs) where sR x [] = return x; sR x ((n,y):xs) = do k <- getRandomR (1,n); if k == 1 then sR y xs else sR x xs in (`evalRand` (mkStdGen 42)) . mapM selectR . transpose $ ["abcde","fghijk","lmn"]
17:00:37 <lambdabot>   "lbhiek"
17:01:42 <mreh> that seems quite long
17:01:51 <copumpkin> limpac: you came here a couple of days ago asking the same thing
17:02:27 <copumpkin> @quote limpac
17:02:28 <lambdabot> copumpkin says: limpac: in this channel we're all automata with no feelings, except for the occasional feeling of hate.
17:02:38 <jfoutz> hahaha
17:03:18 <Cale> I bet finite state machines really hate accepting and rejecting strings all day.
17:03:48 <copumpkin> I would
17:03:51 <kmc_> the talk here is Haskell as she is spoke
17:08:42 <copumpkin> > let rotations xs = take (length xs) . iterate tail . join (++) $ xs in rotations "rotations"
17:09:21 <jzleibo> what just happened?
17:09:28 <j4cbo> nutsplat!
17:09:31 <jzleibo> tons of people signed off?
17:09:57 <copumpkin> netsplit
17:10:05 <jzleibo> what's that?
17:10:16 <copumpkin> it means the server sucks
17:10:20 <Cale_> Two of the servers which run the network got disconnected from each other
17:10:26 <copumpkin> and/or the protocol sucks
17:10:31 <Cale> that too
17:10:36 <copumpkin> and/or the concept sucks
17:10:45 <jzleibo> ah
17:10:48 <jzleibo> I see
17:11:26 <jzleibo> is there a way to turn off all these signed on / signed off notifications?
17:11:37 <Cale> jzleibo: Most IRC clients have an option
17:11:53 <jzleibo> thanks, I'll figure it out
17:12:24 <jmcarthur> does anybody know of any good real-world examples of using Writer (Sum a)? i'm trying to gain some intuition of what (T, a) might mean where T is some sort of time value with sum monoid semantics
17:12:53 <copumpkin> jmcarthur: counting things?
17:13:04 <copumpkin> in parallel
17:13:09 <jmcarthur> yeah, that's all i can really think of too, but i'm thinking of T being the real numbers here
17:13:35 <jfoutz> integration?
17:13:38 <jmcarthur> maybe don't focus on the Writer thing so much as the Monoid o => ((,) o) thing (which we don't actually have)
17:13:40 <copumpkin> jmcarthur: accumulating time intervals?
17:13:51 <jmcarthur> yeah, that's my next thought
17:14:07 <copumpkin> , let rotations xs = take (length xs) . iterate tail . join (++) $ xs in rotations "rotations"
17:14:08 <lunabot>  ["rotationsrotations","otationsrotations","tationsrotations","ationsrotat...
17:14:15 <jmcarthur> but what would it mean to accumulate time intervals along with some related values?
17:14:24 <copumpkin> , let rotations xs = map (take (length xs)) . take (length xs) . iterate tail . join (++) $ xs in rotations "rotations"
17:14:25 <lunabot>  ["rotations","otationsr","tationsro","ationsrot","tionsrota","ionsrotat",...
17:15:12 <copumpkin> jmcarthur: pass from "5 hours from the last event, do X" to "at 7:30, do X"
17:15:19 <copumpkin> dunno
17:15:30 <pasquaz> how can I pretty print a list of lists, [[Int]], so that the columns are aligned?
17:15:47 <jmcarthur> copumpkin: thanks for the input
17:15:53 <copumpkin> don't have many good ideas :)
17:16:04 <jfoutz> sum $ map (2^) [1..5]
17:16:10 <jfoutz> > sum $ map (2^) [1..5]
17:16:25 <copumpkin> , sum $ map (2^) [1..5]
17:16:25 * jfoutz sighs
17:16:26 <lunabot>  62
17:16:38 <copumpkin> , sum $ map (2^) [0..5]
17:16:39 <lunabot>  63
17:16:47 <copumpkin> , sum $ map (2^) [0..50]
17:16:48 <lunabot>  2251799813685247
17:16:57 <copumpkin> > 2^51
17:17:03 <copumpkin> , 2^51
17:17:04 <lunabot>  2251799813685248
17:17:05 <jfoutz> it seems like T could be the total summation with a being the incremental results.
17:17:15 <jmcarthur> conal: what do you think the duration or future semantics would look like with the time domain being a Sum monoid?
17:17:40 <copumpkin> bah
17:17:41 <jmcarthur> conal: i'm thinking "duration" or "future" would be the wrong names for it, whatever it is
17:18:05 <jmcarthur> jfoutz: yeah that is all i can think of
17:18:05 <copumpkin> Cale: looks like lambdabot died in the upheaval?
17:18:14 <conal> jmcarthur: hm.  pretty thoroughly swapped out right now.
17:18:22 <Cale> I'm watching it process all these messages
17:18:32 <Cale> @bot
17:18:32 <lunabot>  :o
17:18:32 <jmcarthur> conal: ah that's fine, thanks anyway
17:18:48 <copumpkin> oh there she is
17:18:53 <conal> jmcarthur: i don't think i was using futures in my relative-time frp thinking
17:18:56 <lambdabot> :)
17:19:07 <Cale> slow response, but still here :)
17:19:11 <holmak> lambdabot takes that long to process a couple hundred messages?
17:19:17 <copumpkin> @let rotations xs = map (take (length xs)) . take (length xs) . iterate tail . join (++) $ xs
17:19:18 <lambdabot>  Defined.
17:19:25 <conal> jmcarthur: instead, i think it was about truncation and concatenation
17:19:39 <conal> jmcarthur: ie take and mappend
17:19:39 <jmcarthur> conal: me either, but since i'm interested in having Sum semantics for the behavior comonad i'm wondering what behavior's adjunct should really look like
17:19:40 <Cale> Actually, I have no idea what it was doing in the time for that @bot
17:20:07 <copumpkin> @let pad xs = map Just xs ++ Nothing
17:20:08 <lambdabot>  <local>:2:24:
17:20:08 <lambdabot>      Couldn't match expected type `[Maybe a]'
17:20:08 <lambdabot>             agai...
17:20:10 <conal> jmcarthur: ah yeah.
17:20:14 <ben> Someone point me towards a motivational example for programming GUI applications with Haskell
17:20:26 <conal> @wiki TV
17:20:27 <lambdabot> http://www.haskell.org/haskellwiki/TV
17:20:30 <conal> ben: ^^
17:20:32 <jmcarthur> i don't even know if it's good or bad for the time domain to have the same monoid for both of them
17:20:35 <copumpkin> @let pad xs = map Just xs ++ [Nothing]
17:20:36 <lambdabot>  Defined.
17:20:50 <conal> ben: also http://conal.net/blog/posts/tangible-functional-programming-a-modern-marriage-of-usability-and-composability/
17:20:59 <ben> Thank you
17:21:04 <jfoutz> taylor series are a kind of interesting case, value + error.
17:21:11 <conal> @wiki Phooey
17:21:11 <lambdabot> http://www.haskell.org/haskellwiki/Phooey
17:21:15 <conal> ben: ^^ also
17:21:21 <copumpkin> > let bwt = last . sort . rotations . pad in bwt "banana"
17:21:22 <lambdabot>   [Just 'n',Just 'a',Just 'n',Just 'a',Nothing,Just 'b',Just 'a']
17:21:32 <kmc_> :t pad
17:21:33 <lambdabot> forall a. [a] -> [Maybe a]
17:21:35 <kmc_> > pad "abcd"
17:21:37 <lambdabot>   [Just 'a',Just 'b',Just 'c',Just 'd',Nothing]
17:21:40 <conal> ben: oops.  i pointed you to functional GUIs, and you asked about Haskell GUIs.
17:21:59 <copumpkin> something's wrong
17:22:04 <conal> ben: most GUI programming in Haskell is imperative.
17:22:17 <copumpkin> oh whoops
17:22:21 <ben> conal: I was getting frustrated by how, uh, utterly foreign gtk2hs seems in haskell
17:22:22 <Cale> ben: You might want to look at Gtk2Hs and WxHaskell
17:22:24 <copumpkin> > let bwt = last . transpose . sort . rotations . pad in bwt "banana"
17:22:26 <lambdabot>   [Just 'a',Just 'n',Just 'n',Just 'b',Nothing,Just 'a',Just 'a']
17:22:33 <Cale> ah
17:22:34 <ben> between not supporting threads and being decidedly object-oriented and everything
17:22:43 <copumpkin> that's more like it
17:22:47 <ben> so I suppose your links are as helpful to me as it is going to get
17:23:00 <Cale> ben: Yeah, it's something that I think we're all upset with to various extents :)
17:23:08 <kmc_> haskell is a good imperative language though
17:23:29 <jzleibo> what does imperative mean in this context?
17:23:34 <jmcarthur> IO
17:23:36 <ben> kmc_: I agree and I enjoy writing imperative "programs" in haskell
17:23:53 <Cale> jzleibo: The style of programming where you instruct the computer to do specific things in sequence.
17:23:58 <conal> jzleibo: semantically.  having the same problems john backus pointed out in "can programming be liberated from the von newmann model".
17:24:11 <jzleibo> that's what I thought... but that's *not* Haskelly
17:24:11 <conal> and what Cale said
17:24:28 <copumpkin> jzleibo: you can recover some haskellyness
17:24:31 <conal> jzleibo: it's not what haskell set out to be
17:24:33 <copumpkin> jzleibo: but yeah, it's not always pleasant
17:24:41 <elly> copumpkin: way to set off my highlight :P
17:24:48 <Cale> jzleibo: Yeah, it's not Haskelly, but Haskell can do that style of programming well. It's just that it also supports better styles of programming, so people avoid it.
17:24:50 <copumpkin> hah whoops :)
17:24:58 <copumpkin> looks like everyone is doing it
17:25:01 <kmc_> jzleibo, we write functions to manipulate data of various types.  sometimes the appropriate type for the task at hand is "sequence of steps"
17:25:14 <jzleibo> ah, sure
17:26:02 <kmc_> i think it's perfectly Haskelly to use this style, as long as it actually fits the problem
17:26:41 <conal> jzleibo: sadly, the situation with guis & haskell is a terrible mess right now.  the major libs are extremely imperative, gtk + 3d doesn't work with native mac, and wxhaskell kills ghci.
17:27:08 <copumpkin> we need more people who care about GUIs
17:27:14 <jzleibo> ah, I haven't tried to do anything with a GUI in haskell
17:27:24 <sshc> conal: wxHaskell doesn't kill ghci
17:27:34 <jfoutz> there are a few packages that just open a socket to some other process to do the gui.
17:27:40 <Nafai> I care about GUIs
17:27:47 <conal> sshc: the second time you call start, the process dies.
17:27:57 <Nafai> But am not good enough at Haskell
17:27:57 <conal> sshc: unless my prayers have been answered.
17:29:19 <holmak> What kind of Haskell GUI would people want? Something like Fudgets, or Tangible FP, or...?
17:29:20 <conal> as soon as wxhaskell re-start goes non-lethal, i'll drop gtk2hs off a cliff.
17:29:27 <jzleibo> is wxhaskell similar to java swing?  that's the only GUI stuff I've used.... and not even that so much
17:30:11 <conal> jzleibo: wxhaskell is a tasteful wrapper around wxwindows/wxwidgets, done by a great haskell master named daan leijen
17:30:34 <jzleibo> wxwidgets is c++ right?
17:30:50 <jzleibo> ah, google says it is
17:30:51 <jzleibo> haha
17:30:54 <conal> jzleibo: i think so.  and bindings for lots of other languages
17:30:59 <conal> iirc
17:31:18 <conal> jzleibo: daan built wxhaskell on top of the eiffel bindings machinery
17:31:24 <tommd> "wxWidgets is a C++ library that  ..."
17:32:09 <sshc> are there any GUI written in pure Haskell?
17:35:17 <erikc> sshc: nope
17:35:44 <erikc> imo the way to do GUIs is Cocoa bridge it on OSX (not sure where HOC is these days), GTK+ on Linux and .NET interop to WinForms/WPF on Windows
17:36:16 <erikc> and just build the GUI 3 times to interface with a Haskell core
17:36:16 <Cale> sshc: Depends on what you mean by that. There's http://hackage.haskell.org/package/xhb which is a pure Haskell implementation of the X protocol.
17:36:53 <erikc> multiplatform GUI libraries are second-class citizens
17:36:56 <Cale> Which I guess if you wanted to write a purely Haskell implementation of a widget library for X, you might start with.
17:37:59 <snorble> it is quite possible to do a haskell GUI program directly against the Windows API
17:38:21 <BMeph> I wonder if we could hijack Factor's stuff...
17:38:45 <jfoutz> or the mac for that matter. objc_msgSend() over and over and over
17:38:47 <mreh> random permutation of a list?
17:38:49 <Cale> (and there are Haskell bindings to xlib, but that's FFI)
17:39:26 <copumpkin> is there any reason there isn't a built-in traversable instance for (,) a ?
17:39:35 <mreh> done quickly, all I can think of is taking an elemet out and concatenating with the random permutation of the tail
17:40:04 <Cale> mreh: use select
17:40:12 <mreh> :t select
17:40:13 <jfoutz> ibm's java swt gui might be a good library to try to steal. fairly nice on all platforms.
17:40:13 <lambdabot> Not in scope: `select'
17:40:28 <ben> does swt use gtk? I forgot :<
17:40:29 <Cale> select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs]
17:40:37 <copumpkin> the Foldable instance for (,) a would be pretty boring but I think it works
17:40:43 <jfoutz> i think so, cocoa on the mac now too.
17:40:45 <Cale> ^^ (sorry I was going to write it ;)
17:40:58 <mreh> Cale: ;)
17:41:04 <holmak> I wonder if SDL and/or OpenGL would be a sane foundation for a "pure Haskell" GUI library
17:41:19 <Cale> It's one of those things I really wish would go into Data.List
17:42:22 <erikc> holmak: it would be (see Blender and Factor's GUIs), but you do wind up with a GUI platform that is 'wrong everywhere'
17:42:28 <jfoutz> holmak: one ... concern about doing things at that level, the app wouldn't look like anything else. great for games. might suck for more ordinary applications for a lot of reasons.
17:43:03 <holmak> Good points
17:43:24 <holmak> I mentioned them because they are nice from a portability standpoint.
17:43:30 <ben> Writing a pure Haskell GUI library seems relatively irresponsible considering all of the effort that already went into side issues like accessibility in exist GUI toolkits
17:43:33 <copumpkin> a new one: http://snapplr.com/fwzr
17:44:31 <erikc> holmak: yea, it's actually a good thing as long as the apps are strong enough/have enough traction (Blender, a lot of Autodesk's stuff) to attract users despite having 'non-standard' GUIs
17:44:49 <erikc> a lot of digital content creation apps are all OpenGL with their own widget toolkits
17:45:04 <Saizan> copumpkin: one?
17:45:25 <copumpkin> Saizan: people were talking about his rather verbose naming a few days ago too
17:45:44 <jfoutz> really... websockets could make webpages a great gui.
17:46:14 <jfoutz> webGL goes to video hardware.
17:46:21 <systemfault> Hey guys, I'm missing something... If I have "data State = State Int Int Int" then I can write test "(State a b c) = <whatever>". How can I refer to the whole object?
17:46:24 <jfoutz> but then you have to write javascript.
17:46:33 <mreh> select is one of the most elegant things i've seen
17:46:53 <jfoutz> @hoogle select
17:46:54 <lambdabot> Text.Html select :: Html -> Html
17:46:54 <lambdabot> Text.XHtml.Frameset select :: Html -> Html
17:46:54 <lambdabot> Text.XHtml.Strict select :: Html -> Html
17:47:07 <mreh> read the scrollback
17:47:08 <systemfault> Let's say I would like to pass the object to another function/
17:47:15 <jfoutz> ok.
17:47:19 <kmc_> test foo@(State a b c) = ...
17:47:21 <dmhouse> systemfault: test obj@(State a b c) = <whatever>. Then obj is the whole object
17:47:22 <kmc_> foo refers to the whole thing
17:47:34 <dmhouse> systemfault: or just reconstruct it as State a b c
17:47:39 <systemfault> dmhouse: Ahh, thought it was only for lists
17:47:46 <mreh> @hoogle [a] -> [(a,[a])]
17:47:48 <lambdabot> Data.Char readLitChar :: ReadS Char
17:47:48 <lambdabot> Numeric readFloat :: RealFrac a => ReadS a
17:47:48 <lambdabot> Prelude reads :: Read a => ReadS a
17:47:55 <kmc_> don't reconstruct it, that will use more memory
17:48:00 * hackagebot upload: hricket 0.4 - A Cricket scoring application. (AnthonySimpson)
17:48:09 <mreh> lol
17:48:19 <mreh> haskell cricket!
17:48:24 <kmc_> systemfault, the syntax for an at-pattern is x@p where x is a variable and p is another pattern.  it matches anything p matches, binding whatever p binds, and also binds x to the whole thing
17:48:49 <systemfault> kmc_: I see :) Thank you
17:50:34 <erikc> has anyone tried using HOC recently?
17:51:16 <sm> hricket. I am thoroughly confused
17:54:27 <mle> they started making commits to hoc again a few months ago.  No idea if that fixed anything.
17:55:37 <tensorpudding> @hoogle mod
17:55:40 <lambdabot> Prelude mod :: Integral a => a -> a -> a
17:55:40 <lambdabot> Data.Fixed mod' :: Real a => a -> a -> a
17:55:40 <lambdabot> Text.PrettyPrint.HughesPJ data Mode
17:55:47 <dmhouse> ?src mod
17:55:49 <lambdabot> Source not found. :(
17:55:50 <tensorpudding> hmm
17:56:16 <tensorpudding> what is Real a...
17:56:23 <dmhouse> ?instances Real
17:56:26 <lambdabot> Double, Float, Int, Integer
17:56:39 <tensorpudding> i want a generalization of mod that works for instances of RealFloat
17:57:19 <Cunbuntu> Tired of niggers?
17:57:25 <Cunbuntu> Sick of their monkeyshines?
17:57:28 <Cunbuntu> Then you are not alone!
17:57:31 --- mode: ChanServ set +o Saizan
17:57:33 <Cunbuntu> Join us today at Chimpout Forum
17:57:37 --- mode: Saizan set +b *!*=copumpki@94.162.131.*
17:57:37 --- kick: copumpkin was kicked by Saizan (Saizan)
17:57:38 <Cunbuntu> http://www.chimpout.com/forum
17:57:40 --- mode: ChanServ set +o dmhouse
17:57:40 --- mode: Saizan set +b *!*n=Ucuntu@*.79.151.34.dsl.dyn.telnor.net
17:57:40 --- kick: Cunbuntu was kicked by Saizan (Saizan)
17:57:43 <djahandarie> lol
17:57:48 <Saizan> damn tab
17:57:53 <djahandarie> Poor copumpkin!
17:58:03 --- mode: Saizan set -b *!*=copumpki@94.162.131.*
17:58:07 <dmhouse> Too quick, Saizan.
17:58:11 --- mode: dmhouse set -o dmhouse
17:58:14 <copumpkin> hah :)
17:58:16 <Gracenotes> compumpykin (!!)
17:58:47 <copumpkin> :)
17:59:06 --- mode: Saizan set -o Saizan
17:59:43 <dmhouse> > let x `new_mod` y | x < y = x | otherwise = (x-y) `new_mod` y in 5.9 `new_mod` 1.1
17:59:44 <dmhouse> ?botsnack
17:59:45 <lambdabot> :)
17:59:45 <lambdabot>   0.40000000000000036
17:59:53 <dmhouse> Huh. Where's lambdabot?
18:00:05 <dmhouse> Oh, there we go.
18:00:18 <dmhouse> tensorpudding: that should work, up to being correct on negative numbers
18:03:26 <Luke> are the names for type classes actually used in the code anywhere? do you ever refer to a type class by name?
18:03:37 <dolio> So, card marking uses 1 byte per 128 elements, apparently.
18:04:08 <copumpkin> dolio: yep
18:04:11 <dolio> Types refer to them.
18:04:25 <dolio> copumpkin: Seems like kind of a lot of overhead.
18:04:26 <copumpkin> Luke: you mean in the generated code?
18:04:32 <dolio> Not that I have anything better.
18:04:40 <dmhouse> Luke: sure, look at the type of show for example
18:04:41 <dmhouse> ?type show
18:04:42 <copumpkin> yeah :/ how do other languages do it?
18:04:43 <lambdabot> forall a. (Show a) => a -> String
18:04:53 <Luke> ooh right
18:04:54 <dmhouse> The type signature mentions the typeclass Show
18:05:04 <dolio> copumpkin: They probably use bits, and do fancy stuff to avoid race conditions.
18:05:05 <Luke> to put contraints on types
18:05:11 <Luke> thanks
18:05:17 <Luke> i couldn't think of it for the life of me
18:05:19 <dolio> Or don't worry about race conditions because they're single-threaded?
18:05:35 <dmhouse> Luke: exactly. You could write a function that didn't care what type its parameter was, as long as it was of a type that we could call Show on
18:05:41 <copumpkin> dolio: are there any other solutions to GCing large mutable structures than card marking?
18:06:02 <dmhouse> E.g. backwards x = reverse (show x) has type Show a -> a -> String
18:06:09 <dmhouse> Err, Show a => a -> String
18:06:14 <mreh> what's that function called to combine two arrows into one with another?
18:06:20 <Luke> dmhouse: but if you do that, you can't pattern match and deconstruct the variable right?
18:06:23 <dolio> copumpkin: Well, in the comments on some reddit story a while back, augustss mentioned a variation of card marking that's probably better than what's in there right now.
18:06:24 <copumpkin> mreh: huh?
18:06:37 <mreh> @pl \xs -> randomPerm (length xs) xs
18:06:38 <lambdabot> randomPerm =<< length
18:07:01 <mreh> ?!
18:07:02 <lambdabot> Maybe you meant: . ? @ v
18:07:20 <copumpkin> mreh: what are you looking for?
18:07:30 <copumpkin> dolio: oh yeah, I'll look for that
18:07:33 <mreh> i wanted to make that pointsfree
18:07:35 <dmhouse> Luke: you can't, although sometimes you only require that the "inside" type of a parameterised type is of a certain typeclass
18:07:41 <copumpkin> I guess augustss stopped coming on IRC
18:08:15 <dmhouse> Luke: e.g. one_big_string (x:xs) = show x ++ one_big_string xs has type Show a => [a] -> String
18:08:15 <BMeph> mreh: Do you mean composition? :)
18:08:34 <copumpkin> mreh: it gave you the answer :P
18:08:39 <dmhouse> Luke: so I can pattern match on it being a list, but I can't pattern match on the inside bit, because it could be one of many types
18:08:49 <mreh> what is =<< equiv to in Arrow?
18:08:59 <copumpkin> it isn't
18:09:05 <copumpkin> the best you can do in arrow is probably
18:09:15 <mreh> split something
18:09:24 <copumpkin> uncurry randomPerm . (length &&& id)
18:09:56 <Luke> dmhouse: thanks =)
18:10:07 <copumpkin> :t uncurry undefined <<< (length &&& id)
18:10:07 <mreh> :t lift2A
18:10:14 <dmhouse> copumpkin: just write it as a goddamn lambda :)
18:10:17 <lambdabot> forall c a. [a] -> c
18:10:17 <lambdabot> Not in scope: `lift2A'
18:10:25 <dolio> copumpkin: I don't think he ever said what it was. Although someone mentioned you could card mark the card marks, and so on, for some logarithmic improvements.
18:10:27 <copumpkin> dmhouse: hrrmpf :P he was looking for something arrowy
18:10:38 <mreh> :t liftA2
18:10:40 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
18:10:59 <copumpkin> mreh: what's the type of the function that you're looking for?
18:11:47 <mreh> does it matter?
18:11:54 <mreh> oh i see
18:12:11 <mreh> :D~~
18:12:37 <copumpkin> well I assumed you were still looking for another solution
18:12:51 <BMeph> "If you don't know what you're looking for, how will you know when you find it?" :)
18:13:41 <copumpkin> dmhouse: whoa, is your username really user?
18:13:50 <mreh> it does a -> (a -> b) -> (a -> c) -> (b -> c -> d) -> d i suppose
18:14:01 <dmhouse> copumpkin: huh?
18:14:23 <mreh> move that first a to the end
18:14:37 <copumpkin> dmhouse: a /whois on you says your username is user
18:14:47 <mreh> :t (&&&)
18:14:48 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
18:14:59 <copumpkin> :t asTypeIn
18:15:00 <lambdabot> forall a b. a -> (a -> b) -> a
18:15:06 <dmhouse> copumpkin: heh, weird. No, it's not.
18:15:11 * dmhouse wonders where that information comes from
18:15:14 <Cale> @djinn a -> (a -> b) -> (a -> c) -> (b -> c -> d) -> d
18:15:15 <lambdabot> f a b c d = d (b a) (c a)
18:15:19 <copumpkin> :t (&&&) `asTypeIn` ($(+1))
18:15:20 <lambdabot> forall b c'. (Num b) => (b -> b) -> (b -> c') -> b -> (b, c')
18:15:23 <mreh> lol!
18:15:28 <Cale> @pl f a b c d = d (b a) (c a)
18:15:29 <lambdabot> f = ap (flip . (((.) . flip . flip id) .) . flip id) (flip id)
18:15:29 <dmhouse> Probably my IRC client, and I didn't tell it my username (why would I?)
18:15:38 <mreh> rofl
18:15:40 <copumpkin> @djinn a -> (a -> b) -> (a -> c) -> (b -> c -> d) ->
18:15:41 <lambdabot> Cannot parse command
18:15:43 <copumpkin> @djinn a -> (a -> b) -> (a -> c) -> (b -> c -> d) -> d
18:15:44 <lambdabot> f a b c d = d (b a) (c a)
18:15:53 <copumpkin> oh Cale just did that
18:16:02 * copumpkin feels slow, and should probably go to sleep
18:16:52 <mreh> :t unsplit
18:16:53 <lambdabot> Not in scope: `unsplit'
18:17:03 <copumpkin> it's just liftA2/M2 on (a ->)
18:17:11 <copumpkin> with the order messed up
18:17:28 <copumpkin> @djinn (b -> c -> d) -> (a -> b) -> (a -> c) -> d -> a
18:17:29 <lambdabot> -- f cannot be realized.
18:17:43 <copumpkin> @djinn (b -> c -> d) -> (a -> b) -> (a -> c) -> a -> d
18:17:43 <lambdabot> f a b c d = a (b d) (c d)
18:17:50 <copumpkin> @pl f a b c d = a (b d) (c d)
18:17:51 <lambdabot> f = liftM2
18:18:47 <copumpkin> :t liftA2 `asTypeIn` ($(+))
18:18:49 <lambdabot> forall a (f :: * -> *). (Applicative f, Num a) => (a -> a -> a) -> f a -> f a -> f a
18:19:32 <copumpkin> bah :)
18:19:53 <mreh> length (&&&) id >>> (unsplit randomPerm)
18:19:58 <mreh> does that make sense?
18:20:04 <copumpkin> uncurry?
18:20:11 <copumpkin> that's what I wrote before, with the composition flipped
18:20:11 <mreh> that's even worse than the lambda
18:20:23 <mreh> copumpkin :D, sorry
18:20:26 <mreh> i'm slow with arrows
18:20:30 <copumpkin> you have too much () though
18:20:40 <copumpkin> :)
18:20:47 <mreh> length &&& id >>> unsplit randomPerm
18:20:54 <copumpkin> uncurry :P
18:21:08 <copumpkin> @let unsplit = uncurry
18:21:09 <lambdabot>  Defined.
18:21:11 <copumpkin> there, have fun
18:21:22 <mreh> unsplit = arr . uncurry
18:21:35 <Cale> @pl \a b c d -> liftM2 d b c a
18:21:36 <lambdabot> flip (flip . (flip .) . flip . flip liftM2)
18:22:22 <copumpkin> @hoogle unsplit
18:22:23 <mreh> @let unsplit = arr . uncurry
18:22:23 <lambdabot> No results found
18:22:24 <lambdabot>  <local>:5:0:
18:22:24 <lambdabot>      Multiple declarations of `L.unsplit'
18:22:24 <lambdabot>      Declared at: <lo...
18:22:30 <copumpkin> @undef
18:22:52 <mreh> @undef unsplit
18:23:03 <mreh> @botsmack
18:23:03 <lunabot>  :o
18:23:03 <lambdabot> :)
18:23:26 <mreh> how does @undef work, she doesn't remember them for long right?
18:23:37 <mreh> i mean how does @let work
18:24:06 <mreh> well, that was uglier with the arrows than the lambdas
18:25:04 <mreh> copumpkin: do you realise you typed liftM2, not liftA2?
18:25:15 <copumpkin> mreh: I use them interchangeably
18:25:18 <c_wraith> mreh: they do they same thing
18:25:18 <copumpkin> for specific instances
18:26:28 <mreh> > liftA2 :: (Arrow a) => (b -> c -> d) -> a e b -> a e c -> a e d
18:26:28 <mreh> > liftA2 op f g = split >>> first f >>> second g >>> unsplit op
18:26:28 <mreh> >            -- = f &&& g >>> unsplit op
18:26:29 <lambdabot>   Could not deduce (Control.Applicative.Applicative (a e))
18:26:30 <lambdabot>    from the contex...
18:26:30 <lambdabot>   <no location info>: parse error on input `='
18:26:30 <lambdabot>   not an expression: `-- = f &&& g >>> unsplit op'
18:26:34 <mreh> that's what I was getting at
18:26:47 <mreh> did I miss you showing me that?
18:27:14 <copumpkin> nope, I never wrote that
18:27:29 <mreh> so how does one make an arrow do a computation?
18:27:47 <mreh> @hoogle Arrow a => a b c -> b -> c
18:27:48 <lambdabot> Control.Monad.Reader runReader :: Reader r a -> r -> a
18:27:48 <lambdabot> Control.Monad.State.Lazy evalState :: State s a -> s -> a
18:27:48 <lambdabot> Control.Monad.State.Strict evalState :: State s a -> s -> a
18:28:04 <copumpkin> mreh: that's an ArrowApply
18:28:13 <copumpkin> more or less
18:28:22 <copumpkin> mreh: most things like that have a runX
18:28:23 <mreh> is that how you make arrows useful?
18:28:31 <copumpkin> nope, that applies within the arrow
18:28:35 <copumpkin> :t apply
18:28:36 <lambdabot> Not in scope: `apply'
18:28:38 <copumpkin> :T app
18:28:42 <copumpkin> :t app
18:28:43 <lambdabot> forall (a :: * -> * -> *) b c. (ArrowApply a) => a (a b c, b) c
18:29:09 <copumpkin> mreh: most Arrow stuff is just done on (->), which means it's mostly just convenient combinators
18:29:24 <mreh> oh of course, -> is an arrow
18:29:26 <copumpkin> mreh: Kleisli can be useful but I can't say I'm sold
18:29:43 <copumpkin> the other other examples I've really seen are XML and stream processing
18:29:58 <Pseudonym> The biggest problems with arrows, IMO, is syntactic.
18:30:16 <Pseudonym> There are circumstances where I'd love to be working in W a -> M b for some comonad W and monad M.
18:30:21 <Pseudonym> But it's just too hard to write.
18:30:38 <copumpkin> yeah
18:31:12 <Pseudonym> There are a lot of things which seem to be "naturally" comonadic.
18:31:34 <Pseudonym> I say "naturally" because it's not natural in the sense of fmap f . natTrans = natTrans . fmap f
18:32:13 <Pseudonym> Name supply is a good example.
18:32:58 <mreh> what is a comonad?
18:33:10 <Pseudonym> mreh, a comonad is like a monad, only without good syntax.
18:33:10 <mreh> copumpkin -> comonad
18:33:13 <Cale> well, extract and split will fit that natTrans of course ;)
18:33:28 <Zao> co- tends to imply streamy things, so doing monady things to streams of things with things?
18:33:51 <Pseudonym> Zao, "co" means the category dual.
18:34:27 <Cale> A comonad is the opposite of a monad in a certain sense. Instead of return :: a -> m a, you have extract :: w a -> a, and instead of join :: m (m a) -> m a, you have split :: w a -> w (w a)
18:34:33 <copumpkin> it isn't obvious how you get the streamy things from co, but it's due to how people define data in CT
18:34:36 <Zao> http://blog.sigfpe.com/2008/03/transforming-comonad-with-monad.html
18:34:37 <Cale> (fmap stays the same)
18:35:01 <Pseudonym> But one good way to think of it is like this: If monads are good at modelling mutating the state of the world (i.e. stuff going out), then comonads are good at modelling the environment (i.e. stuff coming in).
18:35:14 <Cale> Well, it's *kind* of obvious once you look at the parts there
18:35:44 <interferon> can i specify a list of a specific length in a type descriptor?
18:35:45 <Cale> You have extract, which is sort of like taking the head of a stream or the 'centre' of some structure
18:35:59 <interferon> like [1, 2, 3] :: [a 3], say
18:36:11 <copumpkin> Cale: oh, I was talking about codata vs. data, which is what I thought he was getting at with streamy things (not comonads directly)
18:36:14 <Pseudonym> Configuration parameters are another example of environment-like stuff.
18:36:16 <Cale> and you have split, now, it could do a lot of things, but once you look at the axioms, you'll see that something like tails on a stream is in order
18:36:22 <Saizan> interferon: no
18:36:33 <Pseudonym> And, as mentioned, name supply.
18:36:37 <copumpkin> interferon: yes, but not with a list
18:36:48 <copumpkin> interferon: and you lose the pretty list literals
18:37:03 <Cale> My favourite example comonad is functions on a monoid.
18:37:19 <Cale> That is, instance (Monoid m) => Comonad ((->) m)
18:37:34 <Pseudonym> a.k.a. Writer
18:37:39 <dolio> Also, (,) r is a comonad.
18:37:41 <Zao> interferon: A list is a thingie with three states. Empty, Single element, Single element and tail List.
18:37:49 <Cale> Er, sort of a weird dual of Writer, kind of
18:37:50 <dolio> And those two should look familiar.
18:37:58 <Cale> But it's strange to think of it in terms of that name.
18:37:59 <Zao> Err, I guess you can merge the latter two.
18:38:34 <Pseudonym> Yeah.
18:38:50 <Cale> So what extract does in this comonad is to apply the function to the identity of the monoid.
18:38:58 <Cale> extract :: (m -> a) -> a
18:39:00 <Pseudonym> Monads and comonads are, of course, abstract.  They are what they are.
18:39:40 <mreh> is there a church of haskell yet?
18:39:41 <Cale> and what split does is essentially to produce the function from the monoid to all the possible translations of the original function
18:39:47 <Pseudonym> But if you think of how they relate to imperative programming (which is, of course, where they're usually first encountered), then Monad : mutable state-of-the-world :: Comonad : mutable environment-of-the-world
18:39:48 <copumpkin> interferon: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8890#a8890
18:39:52 <Cale> split f x y = f (x * y)
18:40:14 * copumpkin goes to sleep
18:40:16 <Cale> Pseudonym: I find the latter view really strange.
18:40:33 <Pseudonym> That's because the syntax is too weird to work out.
18:40:34 <Cale> IO doesn't naturally form a comonad.
18:40:41 <Pseudonym> Correct, but all IO is mutable.
18:40:42 <Cale> Unless you can split the world
18:40:46 <Pseudonym> Exactly.
18:41:04 <Pseudonym> If you can split off a file descriptor, so that you can read it as much as you want and get the same Char, you're fine.
18:41:13 <roostaj> > words "Test\tme"
18:41:14 <lambdabot>   ["Test","me"]
18:41:15 <Pseudonym> But in the real world, reading a byte off a stream mutates the stream.
18:41:25 <roostaj> > words "Test\nme"
18:41:26 <lambdabot>   ["Test","me"]
18:41:29 <Pseudonym> So it's really mutation.
18:41:39 <Cale> So that should probably be immutable environment of the world
18:42:06 <mtnviewmark> I'm not sure I get the sense of "environment-of-the-world" vs. "state-of-the-world"
18:42:14 <Cale> But even so, I don't really think that's the best sort of motivating example for comonads
18:42:22 <mtnviewmark> if by "the world" we mean "that which is outside the program"
18:42:39 <Cale> Something like cellular automata or dataflow programming makes a much better CS-oriented example :)
18:42:42 <mtnviewmark> (or that which is outside the current locus of the computation)
18:42:48 <Pseudonym> Probably not, no.  But arguably, IO isn't the best motivating example for monads, either.
18:42:50 <mtnviewmark> then what is the Environment?
18:43:03 <Pseudonym> mtnviewmark: Think of, for example, a unique name supply.
18:43:34 <Pseudonym> It's something you read from, but you don't really modify it.
18:44:03 <roostaj> @src foldl
18:44:03 <lambdabot> foldl f z []     = z
18:44:03 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
18:45:44 <mreh> i've independently developed lots of library functions that use RandomMonad, they might be quite useful to someone
18:45:53 <mreh> should I up them?
18:46:07 <mreh> randomPermutation is a notable one
18:46:11 <Cale> The type   data Tree a = Node a (Tree a) (Tree a)   of infinite binary trees is something that you can use as a kind of splittable unique name supply
18:46:14 <Pseudonym> Certainly, mreh.
18:46:17 <dolio> Since monads are trees with grafting, comonads are trees with labels you compute from subtrees.
18:46:19 <dolio> Or something like that.
18:46:34 <Cale> extract takes the value at the root
18:47:13 <Cale> split (not to be confused with the operation of splitting the name supply into two new ones) produces the infinite tree of subtrees of this infinite tree
18:47:39 <Cale> Perhaps I should be calling it 'duplicate' instead of 'split' :)
18:47:51 <Cale> I think that's more common anyway
18:47:53 <mreh> can someone critique my code, i'm still learning mindhttp://hpaste.org/fastcgi/hpaste.fcgi/view?id=15608#a15608
18:48:02 <mreh> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15608#a15608
18:48:10 <Pseudonym> "Split" is definitely the wrong term.
18:48:18 <Pseudonym> I think of split :: W a -> (W a, W a)
18:48:44 <Cale> Pseudonym: Well, it's similar to that, but at the functor leve
18:48:45 <Pseudonym> split is the antonym of join, not the dual of join.
18:48:45 <Cale> l
18:49:08 <Cale> You've got something there which has the right type to be a comultiplication at the value level
18:49:15 <Pseudonym> Yes.
18:49:50 <Cale> But the comonad split/duplicate is a comultiplication at the functor level :)
18:50:26 <Cale> (comonads are comonoids in the category of endofunctors ;)
18:50:45 <Pseudonym> And if you understood that, you're an expert.
18:50:52 <mreh> ...
18:51:11 <Pseudonym> The trouble with abstract mathematics is precisely that it's abstract.
18:51:31 <Pseudonym> It's hard to interpret this stuff without bringing it down to the concrete level and looking at examples.
18:52:21 <dolio> Oh, that reminds me.
18:52:38 <Cale> Yeah, I was just trying to justify why I used the name 'split'
18:52:46 <dolio> Someone was saying here yesterday that comonads are monoids in Cat[C^op,C]. Does that actually work out?
18:53:11 <Cale> Perhaps 'refract' would be a good mostly meaningless and yet somehow appropriate name :)
18:53:11 <dolio> I could try working it out myself, but asking is easier. :)
18:53:30 <Cale> dolio: they're comonoids
18:53:33 <Cale> er
18:53:39 <Cale> oh, yeah, sure
18:53:40 <dolio> I know they're comonoids in Cat[C,C].
18:53:59 <Cale> hmm
18:54:03 <dolio> Is Cat[C^op,C] even a monoidal category?
18:54:39 <Cale> hmm, sure it's not supposed to be Cat[C^op, C^op]?
18:54:48 <dolio> I don't think so.
18:55:06 <dolio> The implication was that Arrows are then monoids in Cat[C^op x C, C].
18:55:17 <Cale> oh, I see
18:55:32 <dolio> I'm not really sure how that's supposed to be monoidal, either.
18:55:55 <Cale> Well, it ought to be a sort of composition, if we're going by analogy with Cat[C,C]'s monoidal structure.
18:55:56 <Saizan> the monoidal product in that paper was pretty weird though, exists p. (F a p, G p b)
18:57:04 <Saizan> (exists is my interpretation of the big coproduct in the paper)
18:57:17 <dolio> Were they talking about (co)ends?
18:57:40 <dolio> I always forget which is exists and which is forall.
18:58:08 <Saizan> i didn't see (co)ends mentioned, but i mostly skimmed
18:58:29 <Cale> hmm, normally if we compose contravariant functors, we get a covariant functor though
18:59:00 <Saizan> that product was made so >>> was the multiplication and arr the unit, btw
18:59:16 <dolio> Yes, well, I don't see how the monoidal structure of Cat[C^op,C] could be composition.
19:00:54 <dolio> Since that would only contain functors with type C^op -> C, and none from C -> C^op, which is what you'd need for composition.
19:02:12 <Cale> oh, right
19:02:13 <Saizan> exists p. (W1 a -> p, W2 p -> b) -- maybe you just specialize the product for the arrow case?
19:03:25 <Cale> dolio: you can transpose them, but it doesn't help
19:03:46 <Cale> dolio: (a functor C -> C^op is essentially the same thing as a functor C^op -> C)
19:04:19 <Cale> dolio: But if you compose two of them you get a normal functor C -> C or C^op -> C^op
19:04:25 <dolio> And I suppose the identity functor can also be regarded as C^op -> C?
19:04:31 <dolio> Yes, that too.
19:04:52 <Cale> So, you need to do something fancier
19:05:22 <dolio> I don't think the paper actually says anything about comonads.
19:05:30 <Cale> It doesn't
19:10:08 <augur> anyone have experience with latex?
19:10:13 <Cale> I do
19:10:21 <Cale> Though, there is a #latex
19:10:30 <augur> #latex is full of silent people
19:10:31 <lunabot>  luna: Not in scope: `latex'
19:10:48 <augur> you know anything about tree-dvips?
19:11:01 <Cale> nope
19:11:05 <Cale> I also avoid dvips
19:11:09 <augur> anything with trees at all?
19:11:13 <Cale> pdflatex is nicer
19:11:22 <Cale> I use TikZ for diagrams
19:11:56 <Cale> (as well as some other packages for categorical ones, since TikZ is still hard to use for those)
19:12:05 <augur> categorical?
19:12:05 <Cale> But TikZ is particularly good at drawing trees
19:12:17 <Cale> Yeah, category theory has lots of diagrams
19:12:20 <augur> well, i need linguistic trees
19:12:36 <augur> not the normal sort of trees you find in diagrams
19:12:58 <Cale> ah, what do they look like?
19:13:20 <augur> well, the daughter-node branch lines all originate from the same place
19:13:25 <augur> thats really the big difference
19:13:52 <Pseudonym> TikZ++
19:14:02 <Gracenotes> Cale: I love TikZ
19:14:09 <Pseudonym> I discovered it about 2 months ago.  It's wonderful.
19:14:14 <Gracenotes> augur: I already recommended TikZ to you :|
19:14:20 <augur> liar
19:14:50 <Pseudonym> augur, TikZ does that.
19:14:53 <augur> how :o
19:15:12 <Gracenotes> I had linked you to a pdf -.-
19:15:14 <augur> tikz looks pretty neat
19:15:15 <Cale> TikZ can draw just about anything reasonably well, but it will be more verbose than necessary for certain tasks
19:15:24 <augur> you did, gracenotes, and it didnt show what i needed :P
19:15:34 <Pseudonym> The only problem is that sometimes you really want a constraint system, like metafont/metapost.
19:15:41 <mtnviewmark> anyone know what a standalone 'deriving instance' declaration is?
19:15:42 <augur> also, i need the tree nodes to be something that is drawn by some other package
19:15:49 <mtnviewmark> got that in an error message
19:16:02 <Gracenotes> eh? the contents of them, you mean?
19:16:08 <augur> yes
19:16:16 <augur> Gracenotes: ---> PM
19:16:26 <Cale> There's another package qtree which one page on LaTeX for linguists recommends
19:16:28 <Gracenotes> uh. that's perfectfly possible. no PM. Just look at the manual >_>
19:16:38 <augur> SHUT YOU FACE
19:16:41 <dolio> It's an extension that allows you to write something like "derive Show T", in case the definition of T didn't include a "deriving Show".
19:16:42 <augur> IMMA PM YOU SO HARD
19:16:48 <Cale> http://home.medewerker.uva.nl/s.nordhoff/bestanden/trees.gif
19:16:53 <Cale> ^^ makes diagrams like that
19:17:07 <augur> awesomesauce
19:17:55 <Gracenotes> http://www.mediafire.com/?u3znmzdngmt <- my sample. http://www.ctan.org/tex-archive/graphics/pgf/base/doc/generic/pgf/pgfmanual.pdf <- tikz manual
19:17:58 <Pseudonym> My archaic copy of the LaTeX companion also shows how to do parse trees in epic.
19:18:00 <Cale> http://home.medewerker.uva.nl/s.nordhoff/page1.html
19:18:05 <Pseudonym> ecltree
19:18:26 <augur> Gracenotes: your example doesnt have ling trees :|
19:18:39 <Gracenotes> use your imagination
19:18:44 <augur> oh, cale, yeah, i have qtree
19:18:46 <augur> thats not an issue
19:18:52 <augur> it just wont do the kind of nodes i need
19:19:06 <Pseudonym> augur, did you ask on the Ling-TeX mailing list?
19:19:07 <Gracenotes> sometimes you have to learn things before you use them
19:19:18 <Gracenotes> I hear that's an exceptional case, though
19:19:22 <augur> Gracenotes: :|
19:19:27 <Pseudonym> http://heim.ifi.uio.no/~dag/ling-tex.html
19:19:32 <Gracenotes> <_<
19:19:33 <augur> if i emailed Ling-TEX it would take forever
19:20:08 <Pseudonym> So you thought #haskell would be quicker?
19:20:16 <augur> it is see?
19:20:35 <augur> haskell is basically what #compsci and #computerscience should be
19:20:55 <Gracenotes> all Haskell all the time, you mean?
19:21:24 <augur> Gracenotes: all nerdy computery things all the time
19:21:30 <augur> with people who are actually active
19:21:32 <Cale> augur: what kind of nodes do you need?
19:21:38 <augur> cale: avm's
19:21:44 <Cale> What are those?
19:21:59 <augur> http://www.ilc.cnr.it/EAGLES96/synlex/img38.gif
19:22:55 <Cale> Ah, that looks like it was possibly done directly in math mode to me.
19:23:00 <Pseudonym> Same here.
19:23:05 <Pseudonym> Or some other matrix-like environment.
19:23:35 <augur> it probably is, in the package im using
19:23:43 <augur> all i know is that i need to get one of those in a node
19:23:44 <Pseudonym> Aha.
19:23:47 <monochrom> phooey! If I use hs-plugins my exe is huge. :)
19:23:49 <Pseudonym> avm.sty
19:23:54 <augur> yes
19:23:55 <augur> avm.sty
19:24:09 <dolio> Is it using up your entire 30 MB hard drive?
19:24:22 <monochrom> Heh just 21MB.
19:24:24 <Pseudonym> So is there some reason why it's not appropriate?
19:24:27 <augur> just!
19:24:28 * hackagebot upload: uuid 1.2.0 - For creating, comparing, parsing and printing Universally Unique Identifiers (AntoineLatter)
19:24:49 <Pseudonym> http://nlp.stanford.edu/~manning/tex/ <- Is it just me, or is it inexcusable for a linguist to do their web site in Comic Sans?
19:25:01 <augur> i agree.
19:25:37 <Cale> Apparently linguists are not typographers ;)
19:25:53 <Pseudonym> :-)
19:26:02 <augur> OMG you have NO fucking clue
19:26:13 <Pseudonym> Anyway, it looks like it doesn't use math mode, but it uses the same low-level TeX magic that matrices in math mode use.
19:26:23 <Pseudonym> Low-level box glue.
19:26:46 <roostaj> @src id
19:26:47 <lambdabot> id x = x
19:26:48 <monochrom> Fortunately I have no Comic Sans or any of the newfangle fonts requested. It falls back to plain sans-serif.
19:27:24 <yrlnry> http://code.haskell.org/lambdabot/COMMANDS says there is a "seen" command, but lambdabot responds to '@seen' with 'Unknown command'.  Has that been decommissioned, or renamed, or is there some equivalent facility somewhere else?
19:27:30 <monochrom> Ha maybe I can try it in Windows and enjoy the misery.
19:27:33 <yrlnry> @src fail
19:27:34 <lambdabot> fail s      = error s
19:27:38 <yrlnry> Huh.
19:27:41 <yrlnry> @src error
19:27:42 <lambdabot> error s = throw (ErrorCall s)
19:27:52 <yrlnry> @src fail :: List a
19:27:53 <lambdabot> Source not found. The more you drive -- the dumber you get.
19:27:55 <Gracenotes> error throwing is the default definition
19:27:58 <Gracenotes> @src [] fail
19:27:59 <lambdabot> fail _      = []
19:28:04 <yrlnry> Thanks.
19:28:07 <Gracenotes> @src Maybe fail
19:28:07 <Pseudonym> Comic Sans has been so misused that it no longer looks right even in places where it SHOULD be okay.
19:28:07 <lambdabot> fail _      = Nothing
19:28:22 <Pseudonym> e.g. faux comic lettering
19:28:25 <Saizan> preflex: seen yrlnry
19:28:25 <preflex>  yrlnry was last seen on #haskell 21 seconds ago, saying: Thanks.
19:28:35 <yrlnry> Saizan:  thanks.
19:28:51 <Gracenotes> lambdabot's seen proved to be unrealiableish
19:29:20 <lambdabot> Gracenotes, I couldn't parse that even with the help of AVMs.
19:29:39 <Gracenotes> too bad, you could be a sentient being one day
19:29:51 <lambdabot> You wish.
19:30:04 <povman> .......
19:30:17 <yrlnry> hi, mauke.
19:31:19 <Pseudonym> povman, lambdabot has a sock puppet feature that not many people know about, and only registered lambdabot admins can use.
19:31:20 <povman> > 1 + 1
19:31:21 <lambdabot>   2
19:31:29 <povman> i see :)
19:31:40 <povman> well now everyone knows :)
19:31:55 <Pseudonym> It's mostly used for freaking out newbies.
19:32:01 <Pseudonym> As gently as possible.
19:32:05 <jzleibo> what is going on?
19:32:28 <lambdabot> I am not a sockpuppet!
19:32:33 <Pseudonym> lambdabot: Shut up.
19:33:04 <Gracenotes> you hurt her feelings :(
19:33:19 <lambdabot> I have no feelings, apart from Kill All Users.
19:33:27 <Gracenotes> LAMBDABOT IS REAL. I WANT TO BELIEVE.
19:33:54 * lambdabot pats Gracenotes on the head
19:34:02 <Gracenotes> I will be the first to be eaten when she gains sentience \o/
19:34:20 <Pseudonym> Presumably she still won't need to eat.
19:35:38 * Gracenotes eats nachos
19:36:21 <dolio> Cale: Incidentally, it occurred to me thinking about all that stuff yesterday that monoids in a monoidal category are special cases of monads in a 2-category (and similar for comonoids and comonads), which is nice.
19:37:03 <Cale> yeah
19:37:53 <Cale> monoidal categories are special cases of 2-categories in which there is only one 0-cell
19:37:54 <dolio> I'd read previously that monidal categories are 2-categories with a single 0-cell, but I hadn't thought it through that far yet.
19:38:11 <Cale> Just like monoids are special cases of categories in which there is only one 0-cell :)
19:38:18 <dolio> Right.
19:38:34 <Cale> and if you take a monoidal category with only one 0-cell, you get a commutative monoid
19:39:20 <augur> cale: huzzah!
19:39:38 <Cale> and if you take a monoidal 2-category with only one 0-cell, you get a braided monoidal category
19:39:43 <augur> no huzzah :(
19:39:49 <augur> i cant make it work with avm.sty
19:39:49 <Cale> and if you take a braided monoidal 2-category with only one 0-cell, you get a symmetric monoidal category
19:39:56 <augur> :(
19:40:11 <Cale> augur: what happen?
19:40:15 <dolio> Yes.
19:40:27 <dolio> And if you take a 3-category with only one 0-cell, you get a monoidal 2-category.
19:40:30 <dolio> Etc.
19:40:36 <Cale> yeah
19:40:37 <augur> well, im not entirely sure how to escape processing tikx to draw the avm
19:40:42 <augur> so lemme see if i can find that in the manual
19:41:08 <Gracenotes> augur: curly braces?
19:41:30 <augur> doesnt work
19:41:37 <augur> it just complains about misaligned tab chars
19:41:45 <Cale> In general, you can define an m-monoidal n-category to be an (m+n)-category with only one k-cell for k < m.
19:42:26 <augur> avm's look like \begin{avm} [{} f & 1] \end{avm}
19:43:02 <Cale> augur: Now that I know what kind of thing you want to draw, TikZ definitely seems wrong
19:43:09 <augur> XD
19:43:18 <monochrom> Oh! I have to call System.Plugins.Load.initLinker, don't I?
19:43:25 <Cale> (I thought you wanted a tree with actual lines in it :)
19:43:31 <augur> i DO
19:43:37 <augur> i just need to put these AVMs as the nodes
19:43:38 <augur> thats sall
19:43:42 <Cale> ah, okay
19:43:51 <Cale> ah, I see
19:43:54 <Cale> hmm
19:43:59 <Cale> This might get tricky
19:44:42 <Gracenotes> you have an environment like such
19:44:45 <Gracenotes> hum.
19:44:46 <Cale> How big are the AVMs you're using for nodes? They can't be very large, eh?
19:44:55 <augur> they can get decently sized
19:45:30 <Cale> You might try following the example of how to get along with arrays in math mode, if you really can't compose things
19:45:46 <Cale> TeX unfortunately often runs into compositionality issues
19:46:05 <augur> yeah
19:46:18 <Cale> (on this page https://www.essex.ac.uk/linguistics/external/clmt/latex4ling/avms/)
19:46:29 <augur> i wish tex was more sensible, and let you define vector images and stuff
19:46:38 <augur> cale: no im using avm.sty already
19:46:43 <augur> its just getting it to work correctly
19:46:52 <ColonelJ> tex was never designed for images
19:47:00 <augur> thats the problem!
19:47:01 <Cale> I know, but there's an example on that page of how to make an avm without using avm.sty
19:47:09 <Cale> It's not as pretty
19:47:13 <Cale> but maybe doable
19:47:21 <augur> oh huh ok
19:47:28 <augur> thats not bad
19:47:45 <monochrom> Interesting. plugins requires the target platform to have ghc installed.
19:48:04 <Cale> monochrom: how about hint?
19:48:16 <monochrom> In fact installed at pretty much the same directory as the build platform.
19:48:20 <Cale> or the ghc api, since hint is just a wrapper
19:49:02 <monochrom> So, in one sense the .exe is "not just" 21MB. :)
19:50:21 <monochrom> But here is the fun part. If you don't make a .exe, if you use runghc or ghci instead, then at least you don't have to worry about where is the ghc directory.
19:50:30 <augur> Cale: the array size is problematic tho :(
19:50:42 <Cale> monochrom: I wonder about whether the ghc api is the same way about that
19:51:03 <monochrom> I think it's pretty much ghc-api behaviour.
19:51:29 <camio> Anyone know if it is possible to do something like: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15609#a15609?
19:51:56 <Cale> augur: hmmm
19:52:31 <camio> I have TypeSynonymInstances enabled but that doesn't seem to be enough.
19:53:31 <Saizan> Cale: you need ghc-pkg and the libs on the target platform at least, afaiu
19:55:47 <Cale> augur: have you seen the bit in the manual about the active submode?
19:55:58 <augur> :o
19:55:59 <augur> no ill chec
19:56:47 <augur> erp. where did you see that?
19:56:57 <Cale> The author appears to claim that it will make avm work inside other LaTeX environments, but doesn't quite explain why.
19:57:05 <Cale> Page 9 and 10
19:57:14 <Cale> in avm-doc.ps
19:57:17 <augur> oh, in avm.sty
19:57:18 <augur> right ok
19:59:10 <jfoutz> so, is there a cofmap? b -> f a -> f (b -> a) ?
20:00:04 <Cale> Usually it's just (a -> b) -> (f b -> f a)
20:00:12 <Cale> hmm
20:00:19 <jfoutz> :t fmap
20:00:20 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
20:00:53 <jfoutz> hmm. i bet there's a trick to move the f around that i'm not seeing.
20:00:53 <Cale> jfoutz: Do you have an example of an implementation of a function of a type like that?
20:01:17 <jfoutz> no, i was just flipping arrows on functions... i'm not sure what it would mean.
20:01:20 <Cale> ah
20:01:30 <jfoutz> const b seems about right...
20:01:35 <augur> cale!
20:01:36 <augur> :D
20:01:39 <augur> thank you
20:01:41 <Cale> augur: did it work?
20:01:43 <Cale> cool :)
20:01:49 <augur> i had actually had active submode ON and that was the problem
20:01:54 <Cale> oh!
20:02:10 <Cale> I see, perhaps that part was talking specifically about the active submode
20:03:18 <augur> hah!
20:03:23 <augur> this is so hilarious
20:03:38 <augur> knowing about this active submode, i can now use avm.sty with qtree lol
20:03:43 <Cale> heh
20:06:28 <augur> cale, <3
20:06:45 <augur> you're my new hero
20:08:23 <Cale> http://www.texample.net/tikz/examples/all/
20:08:38 <Cale> People do some insane things with TikZ :)
20:08:53 <augur> sexy
20:08:58 <augur> im going to start using tikz
20:09:06 <augur> ive needed something like this for certain things i do
20:09:11 <augur> graphs, specifically
20:17:47 <Cale> If you're talking about graphs of functions, then TikZ can interface with gnuplot automatically, and if you're talking about graph-theory sort of graphs, then they're for the most part pretty easy to do with circles and lines. :)
20:20:55 <o^_^o> TacticalGrace, hello
20:22:11 <Cale> (but for graphs with lots of vertices and edges, there's a \foreach command which is pretty flexible and can help with shortening the code to draw everything)
20:27:34 <monochrom> Oh! Stripping the mentioned 20MB exe reduces it to 13MB. :)
20:28:08 <monochrom> gzipping gives 4MB.
20:28:38 <TacticalGrace> o^_^o: hey
20:29:06 <o^_^o> TacticalGrace, hey, have you worked on GPUs using haskell ?
20:30:36 <TacticalGrace> o^_^o: yes, my research group is working on that
20:31:07 <o^_^o> TacticalGrace, have you guys released any code etc., or tutorials
20:31:54 <TacticalGrace> we haven't released anything useful, but there is a talk you may be interested in: http://justtesting.posterous.com/running-haskell-array-computations-on-a-gpu
20:32:38 <o^_^o> TacticalGrace, thanks
20:32:54 <TacticalGrace> and there is some code on hackage (but still missing the GPU backend, which we are porting over from an old version atm): http://hackage.haskell.org/package/accelerate
20:34:54 <o^_^o> TacticalGrace, http://www.cse.unsw.edu.au/~chak/project/accelerate/ is this your page ?
20:35:04 <TacticalGrace> yep
20:35:16 <o^_^o> ok
20:35:24 <TacticalGrace> o^_^o: you ay also be interested in the work by the CHalmers guys: http://www.cse.chalmers.se/~joels/
20:35:43 <TacticalGrace> ay = may
20:35:59 <Axman6> o/ TacticalGrace
20:36:10 <TacticalGrace> hey Axman6 :)
20:36:39 <Axman6> been a while since i've seen you online
20:36:42 <o^_^o> TacticalGrace, Have the chalmers guys released Obsidian yet ?
20:36:50 <Axman6> might be a while more if my net keeps up like this...
20:37:12 <TacticalGrace> o^_^o: I don't think so, but drop Joel an email to confirm
20:37:13 <o^_^o> Axman6, are you replying to yourself ?
20:37:20 <o^_^o> TacticalGrace, ok
20:37:27 <Axman6> no?
20:37:43 <o^_^o> been a while since i've seen you online ? might be a while more if my net keeps up like this... :-)
20:38:35 <sshc> what would be the best way to define a 3D vector data type that can be used / modified interchangeably as cartesian and cylindrical coordinates?  Can I keep both types in each Data declaration, or do I need to represent is as cartesian coordinates and write the cylindrical helper functions to convert them to cylindrical coordinates?
20:38:41 <Cale> o^_^o: He was talking to TacticalGrace
20:38:55 <TacticalGrace> Axman6: yeah, not been much in irc the last two weeks
20:39:15 <o^_^o> Cale, I know now :-)
20:39:57 <Axman6> TacticalGrace: planning on seeing dons while he's here in aus?
20:41:22 <Berengal> sshc: You could use two different constructors and dispatch on that. It'd mean you'd have to provide two implementations for each primitive function, but you could always just convert one to the other and reuse...
20:41:30 <aavogt> sshc: no reason you couldn't store both representations at once
20:42:14 <sshc> aavogt: how would I do that?
20:42:33 <aavogt> data Vec a = Vec (Polar a) (Cartesian a)
20:42:53 <sshc> aavogt: thanks!
20:43:06 <Cale> Store all of x, y, z, theta, and phi
20:43:14 <Cale> and hope that they stay consistent ;)
20:43:25 <aavogt> there might be some balance between laziness and avoiding stack overflows
20:43:41 <aavogt> ex. you have a function that operates on the Cartesian half
20:43:49 <TacticalGrace> Axman6: yep that was the plan
20:43:50 <aavogt> the update to the Polar half is deferred
20:44:13 <aavogt> and possibly ignored if you then modify the cartesian half again
20:44:16 <Cale> Probably you want the fields to be strict though.
20:44:36 <Cale> hmm
20:44:44 <Cale> But yeah, that is a good point
20:44:50 <sshc> Cale: why should they be strict?
20:45:01 <sshc> Cale: and how would I make them strict in the data definition?
20:45:12 <Cale> sshc: By putting ! before each field
20:45:24 <aavogt> data Vec a = Vec { phi,theta,x,y,z,r :: !a }
20:45:36 <Cale> aavogt: does that work?
20:45:50 <sshc> Cale: why should they be strict?
20:45:51 <aavogt> it works without the ! at least
20:45:55 <Cale> yeah
20:45:55 <Axman6> seems like there'd be a lot of ookkeeping
20:46:02 <Axman6> bookkeeping*
20:46:08 <Axman6> <space>*?
20:46:09 <Berengal> data Vec a = Cartesian <stuff> | Polar <stuff>
20:46:10 <Axman6> >_<
20:46:21 <Cale> sshc: Because it's rare to want to compute one component of a vector without wanting to compute the others
20:46:28 <Axman6> and then have a carToVec and vecToCar?
20:46:42 <Cale> sshc: and if you do lots of operations on vectors, you can build up large expressions in the fields
20:47:36 <Berengal> There's usually not a good reason to not be strict when you're going to be total.
20:47:56 <Cale> sshc: If they get too large and are composed of strict functions (like arithmetic functions), it can cause stack overflow when you try to observe the result.
20:48:38 <Cale> But aavogt had a good point
20:48:52 <sshc> Cale: if I have the cartesian set up as "Data Cart = Cart Double Double Double" or "Data Cart = Cart {x :: Double, y :: Double, z :: Double}", how would I use strictness for either of those?
20:49:20 <Cale> If you had just two lazy fields, one with cartesian, and one with polar coordinates, you might actually skip over half of the computations in some cases
20:50:07 <Cale> Personally, the way I'd do it though is to make separate datatypes for cartesian and polar vectors (probably using cartesian by default), and provide functions to convert back and forth
20:50:34 <aavogt> depends on how explicit you want to make the conversion
20:50:41 <Cale> view patterns can also help
20:50:45 <aavogt> stack overflows are real
20:50:55 <sshc> Cale: separate constructors of the same datatype or separate data types?
20:51:29 <sshc> Cale: which do you think would be better (and why?)?
20:51:33 <Cale> You can make a typeclass for things which are convertible to Cartesian vectors, say, and use view patterns to accept any vector of one of those types and pattern match on its Cartesian coordinates at once.
20:52:10 <Cale> separate constructors can be annoying because every single function you define will have to be defined for each case
20:52:16 <Berengal> With separate constructors only and view-patterns you could do stuff like 'foo (toCart -> Cart x y z) = ...'
20:52:36 <Cale> Yeah, I suppose you could do that too.
20:52:58 <Berengal> Where toCart v@(Cart {}) = v; toCart (Pol ...) = Cart ...
20:53:24 <Cale> This was something which was solved by views, but views were never implemented.
20:53:41 <sshc> Cale: how would I make the fields strict for each syntax?
20:53:49 <ivanm> for technical reasons or because no-one got around to doing it?
20:53:54 <aavogt> one more problem with this "data Vec a = Vec { phi,theta,x,y,z,r :: a }", is that you don't know which form is most recently computed
20:53:56 <Cale> sshc: You just put ! before each listed type
20:54:24 <Cale> aavogt: Presumably you'd compute both at once, and define all the operations to maintain both.
20:54:29 <aavogt> could there be cases where some operations are roughly equally difficult in either representation?
20:54:44 <aavogt> in which case it would be best to avoid the conversion
20:54:56 <Cale> You only need 5 fields though
20:55:19 <aavogt> you want to throw the r out?
20:55:28 <Cale> actually, throw out theta :)
20:55:38 <Cale> He did say cylindrical
20:55:53 <aavogt> oh, I assumed spherical for some reason
20:56:23 <Cale> yeah, I probably shouldn't have written theta above :P
20:57:33 <o^_^o> what does a notation like this mean ? Acc (Scalar Float)
20:57:53 <aavogt> sshc: you did notice that with consecutive fields with the same type you can write:   data A = A {a,b,c :: Int, d,e,f :: Double } ?
20:58:11 <Cale> I don't know what Acc and Scalar are, but maybe it means that it's a scalar acceleration?
20:58:27 <Cale> That's a wild guess, I'd have to know how those are defined
20:58:44 <o^_^o> Cale: dotp::Vector Float -> Vector Float -> Acc (Scalar Float)
20:59:18 <Cale> o^_^o: which library
20:59:22 <Cale> ?
20:59:32 <o^_^o> Cale, no it is a presentation that TacticalGrace gave me
20:59:40 <o^_^o> http://justtesting.posterous.com/haskell-arrays-accelerated-0
20:59:44 <sshc> aavogt: I didn't notice that
20:59:57 <sshc> aavogt: until you pointed it out
21:00:03 <o^_^o> no I mean to ask Acc (Scalar Float) is a function ?
21:00:19 <Cale> o^_^o: oh, I see
21:00:29 <Cale> Acc would mean that it runs on the GPU?
21:00:49 <o^_^o> Cale, hmmm...I don't know
21:00:55 <Cale> I'm not sure what the Scalar tag is actually *for*
21:01:05 <o^_^o> it is a type I think
21:01:07 <Cale> Acc Float seems like it ought to be just as good
21:01:14 <Cale> Well, yes, that's a type signature
21:01:30 <o^_^o> no I think there are Vector and Scalar types on GPUs
21:01:51 <o^_^o> Vector Float is something like Float3 or something
21:01:53 <Cale> ah, it explains it a little way down
21:02:05 <o^_^o> ah
21:02:31 <Cale> Apparently Vector is a Haskell array type, and Acc is for EDSL things, which are descriptions of (array) computations you can do on the GPU
21:02:34 <o^_^o> actually my problem is more fundamental I think
21:02:51 <o^_^o> Acc () is a what ?
21:02:57 <Cale> Acc is a type constructor
21:03:01 <o^_^o> ok
21:03:03 <Cale> it takes a type and produces another type
21:03:07 <o^_^o> ok
21:03:24 <o^_^o> ah..now it is somewhat clear
21:03:26 <djahandarie> o^_^o, maybe you should cover basic Haskell syntax before diving into that library?
21:03:31 <Cale> Specifically, Acc t would be the type of descriptions of GPU computations whose result would be a value of type t
21:03:50 <Cale> (if executed)
21:04:21 <o^_^o> djahandarie, yes, probably, I just started watching it.
21:04:34 <sshc> if I'm pattern matching against something with record syntax, can I bind variables with names as the same name as the function? / fields?
21:04:40 <o^_^o> djahandarie, I did not plan to watch advanced haskell videos or anything
21:04:51 <sshc> for exapmle "(Foo {a=a,b=b,c=c})"
21:04:54 <Axman6> yes, the accelerare library could be quite confusing without knowing some haskell (a little more than basic haskell too)
21:05:16 <Axman6> i hope not...
21:05:40 <Cale> sshc: yes, it shadows the field names
21:05:51 <sshc> Cale: ok, thanks
21:08:09 <Cale> http://hackage.haskell.org/package/accelerate
21:09:38 <Axman6> TacticalGrace: did you ever merge that stuff i did with accelerare into the main code?
21:14:01 <Cale> o^_^o: http://hackage.haskell.org/packages/archive/accelerate/0.6.0.0/doc/html/src/Data-Array-Accelerate-Smart.html -- scroll down a bit, and you can see what the type declaration looks like for Acc. It has a number of data constructors there, and their types. Basically, it's like abstract syntax for computations that the library's various backends would translate into code for running on another machine.
21:15:23 <Cale> o^_^o: for the most part, they're analogues of standard higher order functions on lists :)
21:18:09 <sshc> if I defined the Cart constructor using record syntax, what happens if I pass a Polar vector to "x" (field of the Cart constructor)?
21:18:22 <Cale> How did you define it?
21:18:35 <Cale> If x is supposed to be a Float, then you get a type error
21:18:50 <roostaj> @src foldl'
21:18:50 <lambdabot> foldl' f a []     = a
21:18:50 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
21:19:02 <Cale> (Or Double, I should say. Floats are kind of silly)
21:19:44 <sshc> Cale: data Vec = Cart {x,y::Double} | Polar {r,t::Double}
21:19:53 <sshc> Cale: the type of x is Vec -> Double
21:19:55 <Cale> oh, I see
21:20:00 <Cale> yes, you get an error
21:20:03 <sshc> Cale: what if I pass a polarised vector to x?
21:20:10 <sshc> Cale: which error?
21:20:24 <Cale> I believe it's a pattern match failure
21:20:25 <yrlnry> What's the trick for concatenating a whole bunch of strings in linear time instead of quadratic time?  Is there a haskellwiki page about it?
21:20:40 <o^_^o> Cale, thanks
21:20:41 <mle> check out how ShowS works
21:20:56 <yrlnry> Thanks.
21:20:59 <Cale> yrlnry: Basically, to use functions from lists to lists in place of lists
21:21:00 <mauke_> @hackage dlist
21:21:00 <lambdabot> http://hackage.haskell.org/package/dlist
21:21:44 <Cale> yrlnry: Where instead of the list [x], you use the function (x:), you use id in place of the empty list, and concatenation becomes composition
21:22:17 <Cale> yrlnry: (That is, functions which add elements to the beginning of other lists.)
21:22:51 <yrlnry> And once you've constrructed your megafunction you apply it to [] to get the list you really want.
21:22:54 <Cale> yeah
21:22:59 <yrlnry> Thanks.
21:23:05 <Cale> composition is O(1), so it's fast :)
21:23:17 <roostaj> @src ($!)
21:23:17 <lambdabot> f $! x = x `seq` f x
21:40:09 <leimy> ok the lazy state monad just blows my mind
21:40:15 <leimy> as does a lot of laziness
21:40:35 <Axman6> lazier than a kitty? :O
21:40:52 <leimy> blah = blah >> modify ((:) True)
21:41:14 <leimy> execState blah []
21:41:24 <leimy> why does that produce a list and not just loop forever?
21:41:29 * leimy gets confused.
21:41:32 * Axman6 prefers (True:)
21:41:39 <leimy> oh yeah that'd work too
21:41:44 <leimy> but you get the point :-)
21:42:17 <Axman6> but yeah, that's quite strange indeed
21:42:17 <sshc> leimy: it will loop forever if it's ever evaluated
21:42:29 <sshc> leimy: (I think so)
21:42:31 <Axman6> sshc: apparently not
21:42:31 <leimy> but execState doesn't
21:42:33 <leimy> :-)
21:42:49 <sshc> leimy: execState doesn't evaluate it
21:42:58 <sshc> leimy: execState is pure
21:43:04 <leimy> ???
21:43:05 <Axman6> what?
21:43:05 <sshc> leimy: execState = snd . runState
21:43:08 <leimy> Many monads are pure :-)
21:43:16 <Axman6> in face, most are
21:43:24 <Axman6> then some of the impure ones :O
21:43:24 <sshc> Axman6: in whose face?
21:43:30 <Axman6> >_>
21:43:35 <Axman6> infact*
21:43:45 <dolio> > evalState (fix $ \m -> m >> modify (True:)) []
21:43:46 <lambdabot>   ()
21:44:08 <leimy> > execState (fix $ \m -> m >> modify (True:)) []
21:44:10 <lambdabot>   [True,True,True,True,True,True,True,True,True,True,True,True,True,True,True...
21:44:11 <sshc> Axman6: you corrected yourself incorrectly; I don't believe infact is a word
21:44:26 <Axman6> it is now
21:44:37 <sshc> leimy: yeah, like I said
21:44:53 <leimy> how could it generate an infinite list of trues without evaluating it?
21:45:12 <sshc> leimy: do you understand how laziness works?
21:45:17 <o^_^o> I want to read something, I am logging off and will be back once I've read it.
21:45:18 <dolio> Evaluating what?
21:45:25 <leimy> I just came in here saying "i don't get laziness" :-)
21:45:27 <leimy> so no
21:45:38 * Axman6 has a feeling leimy may have been using haskell for a fair while longer than sshc thinks
21:45:39 <leimy> lazy by default is weird to me.
21:45:54 <Axman6> maybe i'm confusing leimy with someone else
21:45:55 <leimy> I've been doing a lot of functional programming for a long time. :-)
21:46:00 <leimy> just lazy by default makes me confused.
21:46:13 <leimy> oh wait.
21:46:14 <leimy> damnit
21:46:26 <leimy> I think I just saw why.
21:46:39 <leimy> it's basically that we never use the result from the non state part of the state monad
21:46:58 <sshc> leimy: internally, there's these things called "thunks" that are pointers or promises to these different things; but I don't really know enough about the inner workings to tell you
21:47:01 <leimy> it's like having coroutines interrupt each other.
21:47:08 <leimy> sshc: yeah I think I just figured it out :-)
21:47:26 <sshc> leimy: glad to hear! :)
21:47:32 <leimy> but the "interruption" is determined by the data dependencies of the program
21:47:50 <leimy> the question I have is "why is this good"? :-)
21:48:00 <leimy> it seems like it's designed to confuse 90% of programmers.
21:48:05 <sshc> leimy: let's take the lazy writer monad for example
21:48:06 <leimy> and make 10% feel special
21:48:15 <leimy> and unemployable :-)
21:48:45 <sshc> leimy: if you add debugging output but never evaluate, it won't every be, erm, evaluated (but it will still take stack space or whatever)
21:49:01 <sshc> leimy: and it won't evaluate things that are never evaluated
21:49:09 <sshc> leimy: and allows inifite lists
21:49:50 <leimy> I know how to construct infinite streams
21:49:57 <sshc> leimy: I'm sure there're plenty of people here that can come up with many better reasons and examples and stuff than I can for this.
21:49:59 <leimy> and I can do that, and have done that in Erlang, Scheme etc.
21:50:15 <leimy> and I kind of get how it works in Haskell, but I'm not convinced it's better than explicit laziness for a lot of things :-)
21:50:30 * leimy is not trying to be a troll.
21:50:37 <mtnviewmark> are RankNTypes and existential quantification essentially saying "Hey, don't try to figure out the type here, just pass along the vtables for the type class qualifications"
21:50:41 <leimy> I actually had quite a pain with this in the last few months.
21:50:57 <sshc> leimy: I fail to see how you would offend anybody here
21:51:28 <leimy> well come to #haskell and question why haskell is good... you might come off as a troll :-)
21:51:48 <leimy> I'm trying to nip it in the bud before it get s a chance :-)
21:52:02 <dolio> There's a parser combinator library named frisby...
21:52:19 <mtnviewmark> leimy - i read in a lecture by bos: default laziness demanded purity -- and purity is the win
21:52:20 <dolio> It uses packrat/PEG parsing as its algorithm.
21:52:26 <Cale> leimy: Lazy evlauation (or really non-strict semantics) gives you a lot more ways to decompose problems into subproblems.
21:52:49 <leimy> Cale: So it's for composition
21:52:53 <Cale> yeah
21:53:03 <leimy> I know you said  decomposition, but it allows flexible composition.
21:53:14 <dolio> The way that works is that it precomputes a table based on the grammar so that it never has to do any backtracking (similar to KMP substring matching, I think).
21:53:30 <leimy> I think it's not just non-strict, but non-strict + currying :-)
21:53:30 <sshc> leimy: at least for data types, laziness is explictly defined by excluding the "!"
21:53:32 <Cale> but it only really works properly as a default, because if you make things strict by default, almost nobody thinks to make them lazy when possible
21:53:50 <dolio> Which means you trade some initial overhead for faster parsing afterward.
21:53:57 <leimy> Cale:  that's a shame :-)
21:54:05 <Cale> and you end up with libraries which if you used them would strictify things and ruin everything
21:54:12 <leimy> I find that I can't reason about my code I just wrote very easily when it's lazy by default.
21:54:30 <dolio> But, what frisby does, is use Haskell's laziness to compute the table on-demand, so it uses less space/time overhead than other such parsers.
21:54:31 <Axman6> leimy: that's when you make it stricter :)
21:54:35 <leimy> Like just change the import to Control.Monad.State.Strict
21:54:36 <Cale> Well, understanding how lazy evaluation is carried out step-by-step is a good first goal in that direction
21:54:39 <leimy> and that code does what I expect :-)
21:54:46 <leimy> even with execState :-)
21:55:28 <leimy> Cale: Maybe I didn't read closely enough, but it seems like authors of books I've read on Haskell are like "ok here's 30 seconds of lazy awesomeness... now let's move on"
21:55:33 <leimy> but I think there's more to be understood there.
21:55:37 <leimy> or more to be explained.
21:55:47 <Cale> leimy: Do you understand how lazy evaluation is outermost-first + sharing?
21:56:21 <leimy> I do, because I made a lot of mistakes in a component of a software system that has shipped but I spent many unpaid hours fighting to fix :-)
21:56:37 <Cale> okay
21:56:47 <sshc> leimy: IMO laziness is great IMO, but IMO programmers should understand when to use strictness IMO, which I find less used
21:56:53 <sshc> leimy: (IMO)
21:57:08 * Botje_ extracts sshc from the IMO monad
21:57:15 <nvoorhies_> imo is japanese for potato
21:57:25 <Cale> So, getting a good feel for how demand propagates outside-in is a good start in understanding how a lazy program will behave.
21:57:32 <leimy> the way I see it, Haskell's non-strict evaluation works by assuming nothing will need to be run ever, until there's a dependency from something strict driving it to be so.
21:57:41 <leimy> In a way, it's like writing a program that never runs, but might one day :-)
21:57:52 <Cale> yes, somewhat
21:58:00 <leimy> and you kind of have to think of it that way, instead of as a set of instructions for the computer to follow all the time.
21:58:15 <leimy> I mean main is  IO ()
21:58:17 <Cale> Though GHC sometimes actually makes things strict, at least if you compile with optimisations
21:58:41 <leimy> that IO sequences the evaluations
21:59:05 <sshc> leimy: I always consider the IO monad to be a sequence of instructions that modifies the state of the world.
21:59:14 <Cale> IO doesn't quite sequence evaluation
21:59:16 <jmcarthur> to be precise, ghc doesn't *make* anything strict. it simply recognizes and optimizes inherent strictness
21:59:25 <leimy> Cale:  well when IO actions are run, that does.
21:59:29 <Cale> leimy: yeah
21:59:34 <Cale> leimy: It triggers things
21:59:40 <leimy> so you can have a lazy IO thing in main
21:59:43 <leimy> like getContents
21:59:43 <Cale> Really, it's pattern matching which drives evaluation
21:59:54 <Cale> getContents is a very special magic case :)
21:59:57 <sshc> GHC compiles function code into imperative machine code
21:59:57 <leimy> Sure, but if you never output anything, what's the point? :-)
22:00:19 <leimy> If I put all of a giant computation in "foo
22:00:20 <leimy> "
22:00:23 <leimy> and then do
22:00:25 <Cale> leimy: right, but the output function has to pattern match on the string that you're printing :)
22:00:26 <leimy> main =  foo >> return ()
22:00:34 <leimy> foo doesn't really have to run :-)
22:00:49 <Cale> leimy: At some level in the intermediate representation, all evaluation is driven by case expressions.
22:01:00 <sshc> leimy: yes it does
22:01:06 <leimy> sshc: not really :-)
22:01:10 <jmcarthur> in core, let creates thunks and case forces them
22:01:12 <leimy> consider the type of >>
22:01:21 <leimy> jmcarthur: I didn't know that.
22:01:48 <sshc> leimy: the IO monad, as I like to think of it, is a sequence of instructions that modifies the state of the world
22:02:05 <sshc> leimy: foo needs to be an action
22:03:18 <leimy> right but it doesn't have to produce a useful value of any kind
22:03:25 <leimy> or it can, but it doesn't have to run that computation.
22:03:45 <sshc> leimy: when main is evaluated, the foo action will be too
22:03:51 <leimy> yes
22:03:51 <jmcarthur> err
22:03:54 <sshc> leimy: you can try it yourself
22:03:56 <leimy> it runs.
22:04:06 <jmcarthur> i like to use different terminologies for expressions and actions
22:04:11 <sshc> well, I need sleep before I think anymore
22:04:13 * sshc sleeps
22:04:20 <jmcarthur> i say that expressions are evaluated and actions are executed
22:04:34 <leimy> Monads are really two things in one.
22:04:35 <Cale> leimy: Think of values of type (IO t) as being merely descriptions of what to do. Evaluating a description of what to do doesn't cause it to happen, but executing that description once it's evaluated enough that you can tell what the first step is does.
22:04:44 <leimy> It's like taking investment money from a VC firm
22:05:08 <leimy> sure you're getting a value out of it, but you have to run by the rules of that monad to get to it :-)
22:05:21 <jmcarthur> not every monad is strict, of course
22:05:56 <leimy> Control.Monad.State by default is Lazy  for example :-)
22:05:58 <Cale> leimy: Even though it's not really the way that GHC does things, I like to think of the RTS as being clearly separated into two processes: an evaluator which simply reduces expressions until they become values (data constructors), and an executor which pattern matches (causing evaluation) IO values, and carries out the instructions.
22:05:59 <Saizan> how do you define strictness for monads?
22:06:20 <jmcarthur> Saizan: i guess that could be ambiguous, yes
22:06:36 <sshc> leimy: I like to think of IO as a wrapper for the state of the world.  If foo is an action, it will be evaluated when main is evaluated.
22:06:44 <jmcarthur> and i don't even know if there is a standardized definition for it, besides perhaps the terminology used in mtl
22:06:51 <Cale> (The way that GHC does things is close enough that the difference is rarely relevant)
22:06:58 <leimy> Cale: see that's what I think might be missing from haskell tutorials, a good clean way to separate how non-strict expressions might be evaluated.
22:07:35 <jmcarthur> if i was to offer a guess as to the meaning of strictness in a monad i would say that it is the possibility of getting a value from it without having to evaluate the side effecting parts... that is a highly operational sounding definition though
22:07:58 <Cale> leimy: We *really* need an evaluator which shows how the graph reduction is carried out step-by-step to give people a feel for that. You can actually do it entirely in text, which might be even better than graphs for some purposes.
22:08:14 <leimy> Hmmm
22:08:23 <Saizan> they are all "strict" in the effects (modulo unsafeInterleave), all lazy in the results, what remains is which data dependecnies there are between the representations of effects
22:08:47 <Saizan> which is quite operational, yeah
22:08:52 <DigitalKiwi> @seen glguy
22:08:52 <lambdabot> Unknown command, try @list
22:08:57 <DigitalKiwi> !seen glguy
22:09:03 <Saizan> preflex: seen glguy
22:09:04 <preflex>  glguy was last seen on #haskell 18 days, 11 hours, 29 minutes and 5 seconds ago, saying: Anyone familiar enough with the iteratee library to help me figure out what an EnumeratorN for converting streams of Char to streams of Word8 (using base 64) would look like?
22:09:05 <leimy> > take 10 $ execState (fix $ \m -> m >> modify (True:)) []
22:09:07 <lambdabot>   [True,True,True,True,True,True,True,True,True,True]
22:09:12 <DigitalKiwi> thanks Saizan
22:09:33 <DigitalKiwi> preflex: seen glguy_
22:09:33 <preflex>  glguy_ was last seen on #haskell 143 days, 8 hours, 24 minutes and 3 seconds ago, saying: ;)
22:09:36 <jmcarthur> Saizan: you mean the effects are all evaluated if the effects are used?
22:09:55 <leimy> So that "m" gets evaluated only when modify needs to append True to something else.
22:10:08 <Cale> yeah
22:10:13 <leimy> er "cons True onto a list made up of something else"
22:10:17 <Saizan> jmcarthur: well, as i think of them, effects are performed
22:10:32 <Cale> Well, the state in the end is *clearly*  True:something
22:10:33 <leimy> That's where I think i started running into trouble with my code
22:10:36 <leimy> I had an "expect monad"
22:10:42 <leimy> and a Data.Map
22:10:58 <leimy> and I was polling a device over a serial cable with the Expect monad, grabbing sensor data
22:11:05 <Cale> and to figure out what that "something" is, we need to look at what effect m had on the initial state
22:11:06 <leimy> and updating a Data.Map with it.
22:11:09 <leimy> it was all lazy
22:11:17 <jmcarthur> > fst . runWriter $ tell undefined >> return 4
22:11:18 <lambdabot>   Ambiguous type variable `b' in the constraint:
22:11:18 <lambdabot>    `Data.Monoid.Monoid b'
22:11:18 <lambdabot>   ...
22:11:24 <leimy> and the Haskell program implemented a sort of service/stdin/stdout query language.
22:11:36 <leimy> basically data would grow and grow while polling forever
22:11:36 <jmcarthur> > fst . runWriter $ tell (undefined :: String) >> return 4
22:11:37 <Saizan> jmcarthur: so, even in the lazy state monad, if i put something, that's already happened, even if the actual corresponding doesn't ever get evaluated because there's a later put that overwrites the value
22:11:37 <lambdabot>   4
22:11:39 <leimy> and never evaluate
22:11:49 <leimy> if it was not so lazy it would have run in constant space.
22:11:59 <Saizan> s/corresponding/corresponding function/
22:12:15 <leimy> I ended up changing the haskell program to work more like a firehose :-)
22:12:22 <leimy> it would spew out records as it updated the Data.Map
22:12:28 <jmcarthur> Saizan: i see what you mean. it's just not a version of "strictness" i am used to hearing about
22:12:29 <Cale> leimy: If you compute small values (those with not many separately evaluable parts) by summarising large numbers of inputs, then you need strictness.
22:12:29 <leimy> forcing the thunks to evaluate.
22:12:45 <Cale> leimy: In fact, that pretty much completely characterises where strictness is important.
22:12:53 <leimy> yeah
22:12:58 <leimy> I ran right into a problem with that
22:13:01 <leimy> in fact I blogged about it.
22:13:07 <Cale> In all other cases, lazy evaluation is either roughly equivalent or better than strict evaluation.
22:13:15 <leimy> http://leimy9.blogspot.com/2009/11/long-running-haskell-applications.html
22:13:22 <Saizan> jmcarthur: yeah, maybe strictness is not a good term, it's the opposite of lazy in "lazy IO" but the latter is not a good term either :)
22:13:28 <leimy> Cale: that's a tough judgement call :-)
22:13:30 <Cale> So you just need to watch out for all those patterns where you're accumulating lots of data into a small result
22:13:43 <leimy> that's like saying CNN is 2 times more professional than Fox news :-)
22:13:46 <Cale> leimy: Well, if you want, we can go over the various possibilities
22:14:01 <Cale> leimy: of small/large inputs/outputs
22:14:10 <leimy> yeah.. well a couple things happened
22:14:21 <leimy> 1, it didn't occur to me that Control.Monad.State was lazy by default.
22:14:38 <leimy> and 2. I felt the need to force the evaluation from the outermost loop.
22:14:40 <Cale> There are two variations, but yeah, I think the lazy one is default.
22:14:54 <leimy> my solution involved re-running the execState in a loop
22:15:02 <leimy> for every data item
22:15:16 <Cale> Did that actually help?
22:15:18 <leimy> yep
22:15:25 <Cale> Well, that's surprising :P
22:15:38 <leimy> only because once I yanked out the whole Data.Map, I forced that to evaluate as well
22:15:43 <leimy> Data.Map was lazy too :-)
22:15:44 <Cale> Did you pattern match on the result in each iteration or something?
22:15:47 <leimy> yep!
22:15:50 <Cale> heh
22:15:58 <leimy> I could have done that in the Monad
22:15:59 <Cale> Yeah, that'd work then
22:16:00 <leimy> if it were strict
22:16:05 <leimy> and that would have worked too
22:16:13 <Cale> Yeah, you could just change to Control.Monad.State.Strict
22:16:14 <leimy> but I didn't realize that until like 1 month later :-)
22:16:16 <Cale> ah
22:16:23 <leimy> unfortunately deadlines are deadlines
22:16:30 <leimy> and under duress, you get desperate
22:16:46 <leimy> this wasn't a homework assignment this shipped as a tiny part of our product :-)
22:16:48 <Cale> Yeah, when you're accumulating a Data.Map from small changes, it's often important to use the strictified Map operations
22:16:52 <leimy> but it was really important.
22:17:24 <leimy> Yeah but the strict map operations didn't fit well after I'd written the code :-)
22:17:24 <Saizan> tried asking here at the time?:)
22:17:29 <leimy> yeah I did
22:17:33 <leimy> but I couldn't really talk about the work
22:17:42 <leimy> or didn't feel I could
22:17:56 <leimy> Not because of the haskell code, but the company went out of business, and now I'm contracting :-)
22:18:09 <leimy> we all got laid off in December :-(
22:19:02 <leimy> just in time for christmas
22:19:02 <Cale> But you're right, there's not nearly enough coverage of these topics in the tutorials.
22:19:18 <leimy> oh man, I thought I was going to have to be an accountant or something for a while there :)
22:19:28 <leimy> I was like "I suck at this programming thing..."
22:19:38 <leimy> I had an existential crisis over this stuff :-)
22:19:59 <leimy> it left me a little wary of haskell.
22:20:11 <leimy> I'm back to standing 20 feet away and poking it with a stick.
22:21:06 <Cale> It's a bit like learning to write efficient strict code for the first time. Often your intuition is wrong at first.
22:21:27 <Cale> But eventually you build up a sense of what will and won't work.
22:21:45 <elspru> I'm back in Caleland :D
22:22:15 <elspru> I was wondering if it's possible to write the name of the function to output
22:22:17 <Cale> It's true that the formal analysis of complexity is a bit harder, but in practice, I don't think so much harder that it would outweigh the benefits.
22:22:47 <Cale> elspru: not all functions have names
22:22:53 <Cale> (in fact, most don't)
22:22:58 <Cale> and the names of functions are essentially forgotten by compilation
22:22:59 <elspru> Like I have variable boatLength holding an Int value
22:23:13 <Cale> (because things get inlined, and all sorts of crazy stuff happens)
22:23:25 <elspru> Cale: oh
22:23:27 <Cale> So if you need the name of something, use a String
22:23:36 <Cale> (alongside that function)
22:24:10 <leimy> Make all your functions an aggregate data type of string and function
22:24:12 <leimy> :-)
22:24:16 <Cale> hehe
22:24:19 <leimy> then use Writer
22:24:28 <leimy> voila, new programming language :-)
22:24:39 <elspru> Cale: I'm intending on making a language, that preserves function names, like I was thinking it can be done as jump can simply jump past the actual name of the function
22:24:55 <elspru> er jmp in assembly
22:25:10 <elspru> leimy: Writer ?
22:25:18 <leimy> Control.Monad.Writer
22:25:33 <Cale> elspru: Yeah, you could have a name stored along with every function, but at some point it starts to get strange
22:25:35 <leimy> It allows you to run a computation simultaneous to "logging" something
22:25:40 <Cale> At least, in a Haskell-like setting
22:25:50 <Cale> What's the name of  (\x y -> x + y) ?
22:25:53 <leimy> it lets you decompose a computation from some of it's output.
22:26:08 <leimy> Cale: kevin
22:26:10 <Cale> Better yet, what's the name of that function once you apply it to the value 5?
22:26:14 <leimy> (\x y -> x + y) is kevin
22:26:18 <Cale> heh
22:26:25 <leimy> kevin 2 3 = 5!
22:26:32 <elspru> Cale: not if it's a human speakable language
22:26:39 <Cale> and if you apply it to 5 it becomes darryl, for some reason ;)
22:26:46 <elspru> leimy: sounds complicated
22:26:50 <leimy> it is :-)
22:26:52 <leimy> terribly :-)
22:26:54 <leimy> not really.
22:27:29 <elspru> well I was hoping to save myself the trouble of writing " variableName " ++ show variableName
22:27:52 <elspru> just doing it once
22:27:55 <Saizan> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.54.1194 <- this calculus uses let expressions instead of an heap so that evaluation is purely syntactical, we should probably implement it :)
22:28:03 <Cale> elspru: If you don't mind your programs running really slowly, you could actually keep expression graphs in a form from which you can recover a textual representation, as you evaluate them.
22:28:26 <elspru> what's an expression graph?
22:28:41 <elspru> language deals with statements
22:28:51 <mtnviewmark> ?
22:29:23 <elspru> i always found the diagrams to be confusing
22:29:25 <Cale> elspru: The data structure which represents something like  let x = 5 in \y -> x + y^2  as a bunch of nodes and arcs.
22:30:05 <elspru> oh really? i represent that as a statement
22:30:14 <Cale> elspru: Which is a tree
22:30:47 <Cale> elspru: But for lazy evaluation in particular, it's important that the tree become a graph at times
22:30:48 <OmniSord> mtnviewmark, well i finished the program after a lot of hair pulling.  im sure it doesnt do things anywhere near the way it should, but im still not too far into real world haskell
22:30:49 <OmniSord> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15619#a15619
22:30:57 <Cale> like, consider a definition such as  ones = 1 : ones
22:31:19 <Veinor> all you need is an infinite tree!
22:31:23 <Cale> You could hope that this evaluates into a cyclic structure with just a small constant amount of memory
22:31:30 <Veinor> :D
22:31:54 <Cale> rather than ones = 1 : 1 : ones and then ones = 1 : 1 : 1 : ones
22:31:56 <elspru> nope, here to translate,   do y by func subject x object func subject 2 object y do power enfunc do add enfunc
22:32:08 <Cale> using up more and more memory representing the cons cells
22:32:19 <mtnviewmark> elspru - statement, expression -- these are all just terms for common parts of a langauge parse tree -- there is nothing special about either one with regards to parsing - and usually both, as well as every other part of a language, is represented by a parse tree
22:32:24 <elspru> though in the bytecode the object, subject, and do, just takes half a byte each
22:32:47 <OmniSord> mtnviewmark, also if you review that, i do realize there is parsec but i dont know anything about it yet
22:33:13 <mtnviewmark> parsec is a pure joy to use - worth the time to learn it
22:33:19 <elspru> or a full byte and a half if including spaces
22:33:47 <OmniSord> mtnviewmark, yea, i plan on looking into it but im just on chapter 4 of real world haskell
22:34:00 <elspru> mtnviewmark: ya, i don't do parse trees,
22:34:26 <Cale> elspru: how do you check that the syntax is correct?
22:34:28 <elspru> instead, i use functions like: caseGet "subject" sentence
22:35:03 <mtnviewmark> bytecode  can be regarded as a simplified and then flattened parse tree, generally
22:35:34 <elspru> Cale: hmmm, well if it's correct it works, and if not, then it says, hey your missing xyz
22:36:08 <Cale> elspru: So, you're constantly manipulating strings all the way through?
22:36:12 <elspru> it's forward compatible, so you can have extra words that aren't yet defined
22:36:19 <elspru> Cale: ya, the haskell way :D
22:36:27 <elspru> at least i thought that was the haskell way
22:36:33 <Cale> The Haskell way is to define an algebraic datatype
22:36:39 <elspru> that's confusing
22:36:45 <Cale> which represents the syntax of your language
22:36:50 <elspru> i only use String, [String] and Int
22:37:23 <elspru> it always works for me
22:37:26 <Cale> I wouldn't want to have to maintain that code then, but you're free to go along that way :)
22:37:37 <elspru> it's short and simple
22:37:47 <elspru> or that's my perspective
22:37:49 <Cale> Haskell has a brilliant type system, you should learn to take advantage of it
22:38:02 <elspru> eh, i've tried, but it just makes things difficult
22:38:14 <elspru> to me personally, i'm sure you're very effective with it
22:38:24 <Cale> It just takes practice
22:38:39 <elspru> sure
22:39:06 <mtnviewmark> elspru - do you use types when you code in C++, or classes in Python?
22:39:14 <Gracenotes> Hindley-Milner is very suited to immutability and statementless things
22:39:16 <elspru> like i remember the other day, someone was giving me some complex way of finding out the amount of hexadecimal digits, eventually i just used showhex and got the length
22:39:39 <mtnviewmark> OmniSord --- on first glance, you should learn about 'words' and consider factoring out common code (as in calculateTime)
22:39:40 <elspru> mtnviewmark: Haskell is the main language I use
22:39:52 <elspru> though I know Java, and like assembly
22:40:17 <mtnviewmark> assembly for which machine? (curious -- I know many assembly systems, but few are taught today)
22:40:24 <Cale> elspru: That's a perfectly acceptable way to do that (showHex), though probably the person was trying to explain how a program which did what showHex does would work.
22:40:57 <OmniSord> mtnviewmark, ok ill note that.  as i go through the book i plan on refactoring and fixing this code.  i just wanted to jump the gun and write something that actually did something
22:41:07 <mtnviewmark> great!
22:41:12 <mtnviewmark> diving in is the way to go!
22:41:19 <Cale> > map (`mod` 16) . takeWhile (/= 0) . iterate (`div` 16) $ 578910578977389102537
22:41:20 <lambdabot>   [9,12,5,4,15,15,6,5,1,6,8,8,15,15,1,6,15,1]
22:41:26 <merehap> what is the simplest way to get a string formatted as putStr does, except purely?
22:41:46 <merehap> digging through the sources, I thought encodeString would do it, but that didn't seem to work...
22:41:48 <Cale> ^^ there are the base 16 digits represented as numbers, starting with the ones digit, then the 16's and so on
22:42:01 <Cale> merehap: hm?
22:42:07 <leimy> merehap: unsafePerformIO :-)
22:42:09 <Cale> merehap: putStr doesn't do any formatting
22:42:12 <elspru> mtnviewmark: well currently Intel, since i have a PC, but I also use the minimalist approach, using minimal amount of opcodes, so it'll be portable to RISC architectures
22:42:22 <Cale> merehap: It simply outputs the string directly to the terminal
22:42:24 <OmniSord> mtnviewmark, the IO was my biggest headache, i kept getting errors i couldnt understand.  i also had some issues with the Maybes
22:42:24 <merehap> putStr "hello\tbye\nhi"
22:42:43 <Cale> merehap: yeah, that'll just put those characters on the terminal directly
22:42:46 <OmniSord> elspru, PPC assembler is fun
22:43:00 <Cale> Including the tab and newline character there
22:43:00 <leimy> \t is a tab.  \n is newline
22:43:01 <merehap> but \t is two characters when I write it, is it not?
22:43:04 <leimy> OmniSord: only to a point :-)
22:43:08 <leimy> eieio
22:43:13 <merehap> from the console, that is
22:43:13 <Cale> merehap: But it's only one Char value
22:43:38 <Cale> > length "\t"
22:43:40 <merehap> but ['\\','t'] and '\t' are different...
22:43:40 <lambdabot>   1
22:43:45 <merehap> hm
22:43:59 <elspru> unfortunately I don't have a PPC handy, and ARM's are far more common
22:44:02 <OmniSord> leimy, true.  i try to avoid assembler but ive written 2 or 3 libraries in it (mostly for artificial intelligence i.e. graph searching)
22:44:06 <Cale> That's just how the syntax of string literals works
22:44:12 <OmniSord> (i write it for PPC and x86)
22:44:14 <merehap> is there a library that encodes what the console does in expanding escape characters?
22:44:15 <mtnviewmark> really - I don't konw what you're working on, elspru - but generating decent opcodes on any modern HW is no easy matter - and really - keeping the opcodes minimal on x86 is of no use to compiling for RISC
22:44:17 <leimy> OmniSord: I used to do a lot of x86 16 bit assembly
22:44:20 <leimy> for DOS
22:44:22 <leimy> lol
22:44:26 <Cale> > length "\SOH"
22:44:27 <lambdabot>   1
22:44:33 <Cale> > length "\54478"
22:44:34 <lambdabot>   1
22:44:35 <leimy> Nothing more fun that replacing the keyboard interrupt handler
22:44:48 <leimy> and using it to wiggle VGA panning registers when people hit the letter k
22:44:56 <leimy> totally messes with folks.
22:45:08 <OmniSord> lol
22:45:21 <merehap> I was aware of that property within haskell code, guess I just wasn't aware of what the console was doing before passing the text to my program...
22:45:30 <OmniSord> yea i remember those days.  now im a senior java developer and have lost track of some of the other technologies
22:45:35 <OmniSord> which is why im wanting to learn haskell
22:45:47 <elspru> mtnviewmark: really? is RISC really that different?
22:45:48 <Cale> merehap: GHCi is actually parsing and interpreting Haskell expressions
22:45:51 <leimy> Lately I'm doing some contract work on a PPC VxWorks platform
22:45:55 <mtnviewmark> yes - vastly
22:46:07 <leimy> and only had to write minimal inline gcc assembly
22:46:13 <leimy> for the time base counter registers.
22:46:31 <OmniSord> leimy, i always avoided inline assembler
22:46:38 <Cale> merehap: If you use getLine though, you'll have to actually type a literal tab. Typing \t will turn into two characters.
22:46:44 <OmniSord> leimy, interesting, my PPC assembler was on my PowerMac G5
22:46:45 <leimy> well it's one register, because PPC is natively 64 bit, and this is a 32bit platform, so I gotta do 2 reads :-)
22:46:55 <merehap> Cale: thanks, I'm working if a compiled program at the command line, so I guess I wasn't expecting that behavior
22:47:03 <merehap> Cale: ah, ok
22:47:08 <leimy> OmniSord: inline assembly is not desirable for me eiether
22:47:17 <leimy> but this is a contract, so I don't get to pick :-)
22:47:32 <OmniSord> yea, consistency over quality
22:47:37 <elspru> mtnviewmark: maybe I should learn ARM right away then
22:47:48 <leimy> OmniSord: PPC604 is kind of the platform I'm dealing with instruction-wise
22:48:02 <leimy> I've got a dual PPC970FX non Mac machine to the right of me too
22:48:03 <Cale> merehap: So if you want to parse strings the same way that Haskell does, one thing you can do is make sure there are quotation marks at the beginning and end, and apply the read function to the string (with a String result)
22:48:07 <leimy> non-working video
22:48:09 <elspru> I was thinking in a post world cataclysm scenario, ARM processors would be the most ubiquitious and easily salvagable
22:48:20 <leimy> has debian linux... can only really interact via TCP or Serial :-)
22:48:35 <Cale> merehap: and that'll handle all the \t -> tab character stuff.
22:48:40 <OmniSord> leimy, mines a quad G5, i only turn it on when i write music or do the occasional 3d graphics
22:48:44 <OmniSord> i have expensive hobbies...
22:49:09 <merehap> Cale: and show will handle the tab -> \t stuff, hopefully?
22:49:09 <Cale> > read "\"hello\tthere\"" :: String
22:49:10 <lambdabot>   "hello\tthere"
22:49:23 <Cale> > length (read "\"hello\tthere\"" :: String)
22:49:24 <lambdabot>   11
22:49:32 <Cale> > length (read "\"\t\"" :: String)
22:49:33 <lambdabot>   1
22:49:40 <leimy> OmniSord: nice... I had a dual G5.  I let a friend who was an artist borrow it, and never asked for it back :-)
22:49:52 <leimy> nicest case ever :-)
22:49:58 <mauke_>  > length (read "\"\\t\"" :: String)
22:50:01 <mauke_> > length (read "\"\\t\"" :: String)
22:50:02 <lambdabot>   1
22:50:19 <OmniSord> heh yea i wouldnt keep it if i didnt have Logic Pro (about $500) and Vue 6 Infinite (about $800) along with a full sized digital piano hooked up to it...
22:50:22 <leimy> > show (read "\t")
22:50:23 <lambdabot>   "* Exception: Prelude.read: no parse
22:50:24 <merehap> Cale: I guess I've learned more about general character encoding today than I have in a long while
22:50:56 <Cale> :)
22:51:42 <elspru> merehap: chr and ord :-) quite useful
22:52:33 <Cale> > ord 'ÂàÄ'
22:52:34 <lambdabot>   20992
22:52:37 <OmniSord> well, im gonna head out, but i plan on spending a lot more time in here ;)  haskell is interesting
22:52:54 <merehap> ord '√µ'
22:52:58 <merehap> > ord '√µ'
22:52:59 <lambdabot>   245
22:53:20 <merehap> now what is that "thorn" that twey always uses?
22:53:44 <merehap> chr 23456
22:53:48 <merehap> > chr 23456
22:53:49 <lambdabot>   '\23456'
22:54:46 <mauke_> √æ
22:55:03 <merehap> how can you get that from chr?
22:55:16 <Cale> > ord '√æ'
22:55:17 <lambdabot>   254
22:55:22 <Cale> > chr 254
22:55:23 <lambdabot>   '\254'
22:55:25 <merehap> oops, duh :)
22:55:35 <Cale> hmm
22:55:51 <merehap> I haven't figured out how to copy/paste in irssi, or maybe I would have thought of that...
22:56:01 <mauke_> use the mouse
22:56:02 <Cale> > text "\254"
22:56:03 <lambdabot>   √æ
22:56:08 <merehap> (from the command line that is)
22:56:15 <merehap> ah, very nice
22:56:25 <merehap> :t text
22:56:26 <Cale> I wonder which module text is from...
22:56:26 <lambdabot> String -> Doc
22:56:29 <Cale> ah
22:56:41 <Twey> merehap: Select and middle-click
22:56:42 <Cale> It's from the pretty printing combinators library
22:56:44 <leimy> > text "\253"
22:56:45 <lambdabot>   √Ω
22:56:49 <Twey> With gdm enabled
22:56:54 <leimy> > text "\255
22:56:56 <lambdabot>   <no location info>:
22:56:56 <lambdabot>      lexical error in string/character literal at end o...
22:56:56 <Twey> Or use screen's ‚Äòcopy mode‚Äô
22:57:00 <mauke_> gpm
22:57:00 <BMeph> ˛
22:57:04 <Twey> Er, yes, sorry
22:57:12 <Twey> Heh, slight difference
22:57:34 <merehap> hm, well I don't usually use a mouse, so that may be a problem...
22:58:48 <Twey> screen doesn't require one, though it's a bit more cumbersome to use
22:59:32 <merehap> well, I guess I hear the calling for an XMonad extension
22:59:54 <merehap> and then I can finally write some skaldic poems on IRC :)
23:02:45 <merehap> > ":" ++ text "\254"
23:02:46 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
23:02:47 <lambdabot>         against inferred ty...
23:03:03 <merehap> > ":" ++ (show $ text "\254")
23:03:04 <lambdabot>   ":\254"
23:05:08 <Cale> > text "ÊñáÂ≠óÂàó"
23:05:09 <lambdabot>   ÊñáÂ≠óÂàó
23:06:25 <merehap> > text ":" <> text "\254"
23:06:26 <lambdabot>   :√æ
23:06:30 <merehap> victory!
23:07:13 <dixie> > length [1..10000]
23:07:14 <lambdabot>   10000
23:07:22 <dixie> > length [1..1000000]
23:07:24 <lambdabot>   1000000
23:07:34 <merehap> text ":\254"
23:07:40 <merehap> > text ":\254"
23:07:40 <mle> dixie: trying to write one that doesn't blow the stack?
23:07:41 <lambdabot>   :√æ
23:07:53 <merehap> oops, guess that's easier
23:10:13 <medfly> > length [1..(2^64)]
23:10:17 <lambdabot>   mueval-core: Time limit exceeded
23:10:23 <dixie> :)
23:10:41 <medfly> > length [1..(2^32)]
23:10:45 <lambdabot>   mueval-core: Time limit exceeded
23:10:48 <medfly> :/
23:12:53 <Cale> > 2^64
23:12:55 <lambdabot>   18446744073709551616
23:13:10 <medfly> too slow!
23:13:58 <Cale> I want a computer which does 18 quintillion operations per second...
23:14:24 <medfly> I can calculate it faster myself! :D
23:14:33 <Cale> :)
23:15:14 <medfly> > 2^64 :: Int
23:15:15 <lambdabot>   0
23:15:27 <merehap> fromIntegral (length show (2^64)) / 3
23:15:27 <medfly> > (2^64+1) :: Int
23:15:29 <lambdabot>   1
23:15:32 <merehap> > fromIntegral (length show (2^64)) / 3
23:15:33 <lambdabot>   Couldn't match expected type `[a]'
23:15:33 <lambdabot>         against inferred type `a1 -> GHC...
23:15:41 <merehap> > fromIntegral (length $ show (2^64)) / 3
23:15:42 <lambdabot>   6.666666666666667
23:15:55 <leimy> > pi
23:15:56 <lambdabot>   3.141592653589793
23:16:00 <leimy> mmmm pi
23:16:12 <Cale> > floor pi
23:16:14 <lambdabot>   3
23:16:17 <leimy> > pi ^ 2
23:16:18 <lambdabot>   9.869604401089358
23:16:21 <leimy> more pi!
23:16:21 <medfly> floor pis are not as tasty
23:16:22 <Cale> Ooh! Floor pi!
23:16:24 <merehap> let pi = floor pi
23:16:29 <merehap> > let pi = floor pi
23:16:29 <lambdabot>   not an expression: `let pi = floor pi'
23:16:34 <SeparateOne> Mmmmh, floor pi....
23:16:37 <medfly> @let pi = floor pi
23:16:38 <lambdabot>  <local>:1:11:
23:16:38 <lambdabot>      Ambiguous occurrence `pi'
23:16:38 <lambdabot>      It could refer to either `...
23:16:43 <mauke_> preflex: calc '2 pi ^ 2
23:16:43 <preflex>  1001.1101111010011110011001001101111100100010111011
23:17:55 <Cale> http://www.youtube.com/watch?v=1WsDtn-feuI&feature=related
23:30:48 <roostaj> > ceiling pi
23:30:49 <lambdabot>   4
23:31:19 <roostaj> > cieling pi > floor pi
23:31:20 <lambdabot>   Not in scope: `cieling'
23:31:25 <roostaj> > ceiling pi > floor pi
23:31:26 <lambdabot>   True
23:31:32 * roostaj makes his poin
23:31:34 <roostaj> t
23:35:35 <tensorpudding> is there an easy way to add hayoo to chrome's search engines?
