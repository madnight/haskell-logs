00:00:16 <Saizan> so, when you say "class Graph gr => Net gr  where" you are making Net also a typeclass over type functions of kind * -> * -> *
00:00:32 <cjs> Anybody have any idea how I might turn off "Warning: -#include is deprecated: No longer has any effect" warnings?
00:00:37 <cjs> (In 6.12.)
00:00:44 <Saizan> tomberek: yeah, it's not explicit, it'd derived by the fact that in the type signatures for the methods gr is applied to two type variables
00:00:58 <tomberek> yeah, like in empty
00:01:24 <tomberek> that's what gave me some clues and i got rid of some warnings... ..
00:01:30 <Saizan> ok
00:01:30 <tensorpudding> hmm
00:01:39 <tensorpudding> there are more complicated kinds
00:01:58 <tensorpudding> :k ReaderT
00:02:00 <lambdabot> * -> (* -> *) -> * -> *
00:02:18 <tomberek> from Source: class Graph gr where   -- essential operations   -- | An empty 'Graph'.   empty     :: gr a b
00:02:30 <tensorpudding> @src ReaderT
00:02:31 <lambdabot> Source not found. I've seen penguins that can type better than that.
00:02:34 <tensorpudding> meh
00:02:41 <Saizan> tomberek: yeah
00:02:46 <tensorpudding> @hoogle ReaderT
00:02:47 <lambdabot> Control.Monad.Reader newtype ReaderT r m a
00:02:47 <lambdabot> Control.Monad.Reader ReaderT :: (r -> m a) -> ReaderT r m a
00:02:47 <lambdabot> Control.Monad.Reader mapReaderT :: (m a -> n b) -> ReaderT w m a -> ReaderT w n b
00:03:09 <tensorpudding> hmm, that's complicated
00:03:20 <Saizan> tomberek: so, in the definition of NN, if 'a' and 'b' are supposed to be the parameters for your graph type, you can't defined it like that
00:03:38 <tomberek> so the rhs of the data declaration needs to include a and b?
00:03:50 <tomberek> what if I want to make sure they are the same,, so a and a?
00:04:32 <Saizan> mh, you can't make sure they are the same if you want NN Gr to be an instance of Graph
00:05:22 <Saizan> however, something that works is "data NN gr a b = NN (gr a b)"
00:05:25 <tomberek> Saizan: so no instance of Graph can be forced to only allow the same type?  that was the idea behind the function declaration:   step :: Neuron a => gr a a -> gr a a
00:05:27 <Saizan> not that it adds much
00:06:17 <Saizan> tomberek: the Graph typeclass forces you to support any two types
00:07:09 <Saizan> but your step function requires the two types to be the same in the graph it takes as argument
00:07:19 <Saizan> and those two statements are not in conflict.
00:07:27 <tomberek> Saizan: ok, so a function can restrict it, but not the class?
00:08:13 <Saizan> tomberek: yeah, the signature for step is not restricting what the type can accept in general, it's just restricting the types for the graphs the function accepts
00:08:57 <Saizan> mh
00:09:03 <tomberek> Saizan: ok... whew....
00:10:09 <Saizan> (you could also make all the graphs contained in NN have the same type for both arguments and still be an instance of Graph, but that's using some advanced feature)
00:11:04 <tomberek> Saizan: ok, i'll try to stay basic then... what should I make the data declaration of NN?  I'm still running into "enough type arguments" issues
00:11:14 <Saizan> data NN gr a b where NN :: gr a a -> NN gr a a -- simple to write, but maybe too early to learn :)
00:11:35 <Saizan> tomberek: data NN gr a b = NN (gr a b)
00:11:57 <Saizan> tomberek: and then instance Net (NN Gr) where ..
00:12:05 * jaspervdj just realised bash stdout is a monad... cat is return and | is >>=
00:12:33 <Saizan> tomberek: but you'd also need to write a Graph instance for (NN Gr)
00:12:54 <kamatsu> jaspervdj: echo is return.. isn't it?
00:12:58 <tensorpudding> isn't stdout a stream?
00:13:14 <kamatsu> yeah, it's not stdout but shell in general
00:13:18 <sinelaw> I need a favor. need to "statistically sample" which fonts (linux) people have installed, so i can pick a sensible fall-back default for when the user doesn't supply the font file
00:13:25 <sinelaw> so if you can run this:
00:13:30 <Saizan> http://okmij.org/ftp/Computation/monadic-shell.html <- unix pipes as IO Monad
00:13:34 <kamatsu> sinelaw: just use "Sans"
00:13:48 <kamatsu> sinelaw: freetype registers "Sans" and "Serif" in a font-independent way
00:13:52 <Saizan> tomberek: are you sure Net should be a typeclass?
00:13:54 <jaspervdj> sinelaw: yep, use sans or sans-serif as fallback
00:13:56 <kamatsu> sinelaw: also "Monospace" i think
00:14:09 <sinelaw> i need the ttf file
00:14:11 <sinelaw> path
00:14:26 <kamatsu> sinelaw: the ttf file path can change from distribution to distribution
00:14:30 <sinelaw> i know
00:14:42 <Saizan> tomberek: btw, if you write newtype NN gr a b = NN (gr a b) you can add deriving (Graph) to get the Graph instance for free
00:14:45 <tensorpudding> is there a standard way to figure out where fonts are?
00:14:47 <sinelaw> maybe there's a command that will usually return the ttf path?
00:15:00 <sinelaw> yeah, what tensorpudding said
00:15:22 <kamatsu> most programs that use ttf just use system libraries to get the fonts themselves, irrespective of where the files are
00:17:27 <sinelaw> aha, got it.
00:17:35 <sinelaw> if fontconfig is installed
00:17:44 <tomberek> Saizan: i am NOT sure that Net should be a typeclass
00:17:52 <sinelaw> fc-match -v Sans | grep file
00:18:12 <sinelaw> or grep ttf, etc..
00:18:48 <sinelaw> maybe there's a binding for fontconfig
00:19:02 <sinelaw> nope.
00:23:33 <Saizan> tomberek: well, do you need to have different implementations of view and step for different types ? or could you implement them uniformly for every instance of Graph?
00:24:07 <sinelaw> tomberek, just curious - what are you working on?
00:25:30 <Saizan> tomberek: a thing that works well is to start with concrete types and maybe generalize later, and to generalize you might just want to take some functions as parameters rather than writing a typeclass
00:26:15 <Saizan> tomberek: you don't use typeclasses as often as you'd use classes or interfaces in OOP
00:26:23 <sinelaw> kamatsu, i've pushed a few changes
00:26:41 <Saizan> because we've other methods of abstractions :)
00:26:59 <Saizan> typeclasses are mostly for overloading
00:27:09 <monochrom> @quote monochrom
00:27:10 <lambdabot> monochrom says: The problem is that bad programmers will assess tutorials for good programmers as "ivory tower", and moreover bad programmers are the vocal majority.  It gets you bad press.
00:27:14 <kamatsu> sinelaw: thanks
00:27:41 <monochrom> @quote monochrom premature
00:27:41 <lambdabot> monochrom says: premature generality is the root of OOP
00:27:46 <sinelaw> kamatsu, including the antialiasing, which i hope will work in your place
00:28:07 <sinelaw> @quote vixen
00:28:08 <lambdabot> vixen says: If you see this, gentle sir, know that you are being trolled by a poorly configured VixenLove program
00:28:23 <monochrom> haha
00:30:31 <tommd> @vixen say it ain't so!
00:30:32 <lambdabot> wanna hear a story?
00:30:46 <ray> @vixen are you poorly configured?
00:30:47 <lambdabot> i truely am
00:30:55 <kamatsu> sinelaw: any simple test?
00:31:30 <ray> @quote lu
00:31:30 <lambdabot> newsham says: functional programmers know the value of everything and the cost of nothing
00:31:35 <sinelaw> kamatsu, yes. one sec.
00:31:44 <koala_man> haha
00:31:50 <ray> for reference, 2 letter combinations are the best wau to use @quote
00:33:48 <sinelaw> kamatsu, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16700#a16700
00:34:02 <merehap> @vixen your love is a heart-breaker
00:34:02 <lambdabot> You think this is a botiecall??
00:34:17 <sinelaw> @vixen what's your take on that iPad?
00:34:18 <lambdabot> i don't know, what?
00:34:28 <sinelaw> @vixen what's your take on that iPad?
00:34:28 <lambdabot> i dunno...
00:34:32 <sinelaw> @vixen what's your take on that iPad?
00:34:33 <lambdabot> let's don't talk about that
00:34:37 * jrockway loves #haskell because the bot is as bitter about programming as he is
00:34:43 <sinelaw> heh
00:34:44 <jrockway> and about apple too, apparently
00:34:59 <sohum> @pl \x y -> f y . g x
00:35:00 <lambdabot> flip ((.) . f) . g
00:35:10 * Beelsebob is just waiting for the WiMax iPad
00:35:15 * Beelsebob runs
00:35:25 <sinelaw> @vixen catch Beelsebob
00:35:25 <lambdabot> are you being sincere?
00:35:42 <sinelaw> ok, 'nuff for one day.
00:35:48 <sohum> @vixen who /are/ you?
00:35:48 <lambdabot> i dunno, who?
00:36:15 <jrockway> in soviet russia, lambdabot is you!
00:36:28 <sinelaw> heh
00:36:40 <sohum> :t \f -> ((Prelude..) Prelude.. f)
00:36:42 <lambdabot> forall b c a a1. (a1 -> b -> c) -> a1 -> (a -> b) -> a -> c
00:38:23 <kamatsu> sinelaw: how do i tell if it works?
00:38:46 <sinelaw> does the line look jagged, or smoothly anti-aliased?
00:40:16 <kamatsu> sinelaw: kinda jagged, but i zoomed in, and i saw faded pixels, i think it's antialiased
00:43:22 <kamatsu> yeah, antialiased
00:43:33 <kamatsu> i'll try turning it off and see how jagged it can really get
00:44:16 <kamatsu> ah yeah, very jagged
00:44:33 <sinelaw> :)
00:45:01 <sinelaw> kamatsu, next up: opengl-based bezier curves.
00:45:05 <sinelaw> working on it
00:45:39 <tensorpudding> this channel is unusually friendly
00:46:03 <sinelaw> tensorpudding, you new to #haskell? it's (almost) always like this
00:46:05 <pastorn> what are you two up to?
00:46:26 <pastorn> kamatsu, sinelaw &&
00:46:27 <pastorn> ^^
00:46:41 <lpsmith> "Functional programmers know the value of everything and the cost of nothing"  <-- is a Perlis quote
00:47:03 <sinelaw> pastorn, we share a common need. opengl-wrapping functional library. using luqui's lib graphics-drawingcombinators, adding a few patches.
00:47:11 <sinelaw> for 2d, not 3d, btw.
00:47:17 <jrockway> drawingcombinators sounds nice
00:47:24 <cjs> Is something compiled with -eventlog slower if I don't use the logging at runtime?
00:47:32 <jrockway> i tried writing a library like that for CL a few years ago
00:47:34 <pastorn> sinelaw: what about GPipe? Too technical?
00:47:46 <jrockway> eventually gave up due to ... i forget why :)
00:47:56 <sinelaw> jrockway, that would be cool
00:48:15 <jrockway> i think i made a diagram to model the class hierarchy ... and that was the end of that project :)
00:48:21 <sinelaw> pastorn, never saw that before. looking
00:48:51 <pastorn> sinelaw: it's pretty awesome, or so it seems
00:49:00 <sinelaw> pastorn, do you have an example program?
00:49:04 <pastorn> haven't gotten around to using it yet, but it will happend :)
00:49:23 <pastorn> sinelaw: there's a page on the haskell wiki, linked from its hackage page
00:49:25 <pastorn> has examples
00:52:06 <sinelaw> pastorn, looks interesting, but i think that the drawingcombinators approach is more compositional. as a hand waiving argument only, it seems better for 2d.
00:52:16 <sinelaw> its much simpler
00:52:49 <pastorn> i guess so :)
00:53:02 <sinelaw> but for 3d, i'm not sure.
00:53:11 <sinelaw> pastorn, did you see fieldtrip?
00:53:16 <pastorn> ehm... no?
00:53:29 <sinelaw> http://www.haskell.org/haskellwiki/FieldTrip
00:54:04 <sinelaw> not much info there, but it gives an idea of what's that about
00:54:09 <sinelaw> (have never used it)
00:54:39 <sinelaw> the same spirit as drawingcombinators
00:58:10 <tensorpudding> i meant that the channel was unusually friendly by freenode standards
00:58:32 <tensorpudding> i've been hanging in more channels lately and have more comparisons
00:59:07 <Ke> well most people here are and behave quite mature by internet standards
00:59:23 <jrockway> nice... my app now uses 11M of RAM instead of 200M
00:59:27 <Ke> so it's easy to be civil by culture
00:59:30 <jrockway> all because of one $! :)
00:59:37 <medfly> :t ($!)
00:59:38 <lambdabot> forall a b. (a -> b) -> a -> b
00:59:43 <medfly> o.O?
00:59:46 <medfly> what does it do?
00:59:49 <kamatsu> haskell reddit is the same compared to other reddits
00:59:56 <jrockway> evaluates the argument immediately
01:00:03 <idnar> @src ($!)
01:00:03 <lambdabot> f $! x = x `seq` f x
01:00:11 <medfly> I'm a noob :(
01:00:15 <jrockway> so that, for example, a recursive call like "foo (x + 1)" does not thunk the addition
01:00:24 <jrockway> (and cause the stack to overflow)
01:00:28 <Alpounet> it's the classical ($) but forces the evaluation of x
01:00:30 <medfly> oh
01:00:31 <medfly> I see
01:00:36 <medfly> thanks
01:00:43 <idnar> well, specifically, x is forced when (f x) is forced
01:00:51 <idnar> er, is evaluated
01:01:13 <tensorpudding> haskell reddit is better than most reddits because it seems to have consistent material
01:01:25 <tensorpudding> since dons is prolific at posting
01:01:31 <Alpounet> so is the haskell community, anyway.
01:01:42 <Alpounet> (in my opinion, at least)
01:01:49 <jrockway> and because the kind of people that want to waste their day complaining about how bad functional programming is don't read the haskell subreddit :)
01:02:07 <jrockway> regular programming reddit though... sometimes i hope that the human race wipes itself out so that that will go away :)
01:02:19 <medfly> really?
01:02:24 <medfly> trhere is stuff much worse at humanity
01:02:34 <mm_freak> is there a nice, memoizing way to write ByteString literals?
01:02:37 <jrockway> "hi guys, i wrote an app in haskell and it worked but i wanted to write it in c instead.  it's slower and is 100x longer, but c is awesome so yeah"
01:02:41 <mm_freak> currently i write (pack "string")
01:03:35 <kalven> jrockway: where was that post?
01:03:45 <jrockway> http://www.reddit.com/r/programming/comments/aue06/going_back_to_c/
01:03:49 <sinelaw> jrockway, yeah.
01:04:00 <kamatsu> Haskell source code typically contains the lowest "fuck" count
01:04:02 <kamatsu> perl being the highest
01:04:17 <sinelaw> reddit has gone down the drain, by all means.
01:04:33 <sinelaw> ways, means, whatever.
01:04:47 <kamatsu> we should write a version of reddit in haskell and make a haskeller's reddit
01:04:54 <sinelaw> exactly
01:05:20 <jrockway> i stopped reading proggit about 2 years ago... but i have recently been lured back
01:05:24 <jrockway> because HN has gotten so boring lately
01:05:35 <tensorpudding> proggit is pretty lame, but it's much better than /r/politics...
01:05:42 <kamatsu> oh oh
01:05:44 <kamatsu> r/politics
01:05:47 <kamatsu> corporate overlords
01:05:51 <kamatsu> two party system is screwing us over
01:05:59 <jrockway> vote for ron paul!
01:06:02 <kamatsu> wah wah sensationalist headlines
01:06:14 <jrockway> "AP: WORLD WILL END"
01:06:18 <kamatsu> haha
01:06:41 <tensorpudding> i get squicked out every time i open reddit when i'm not logged in and see the unfiltered frontpage
01:06:42 <kamatsu> The whole political system is gamed by the corporations and no one else seems to understand?
01:07:14 <jrockway> btw, is there a tool i can use to profile what's using memory?
01:07:18 <Veinor> kamatsu: it is though :|
01:07:45 <Veinor> I mean especially with the recent supreme court ruling
01:07:45 * jrockway watches his program slowly allocate more and more memory
01:07:51 <kamatsu> I know, but the r/politics solution is to found their own political party
01:08:15 <Alpounet> jrockway, check the GHC manual : alt-stdlib@projects.haskell.org
01:08:19 <Alpounet> damn
01:08:21 <Alpounet> http://www.haskell.org/ghc/docs/latest/html/users_guide/profiling.html
01:08:28 <jrockway> thanks
01:08:34 <Alpounet> in particular, there's a new tool being written
01:08:37 <Alpounet> @hackage hp2any
01:08:37 <lambdabot> http://hackage.haskell.org/package/hp2any
01:08:51 <Alpounet> you can read about it in the last Monad Reader Issue (#15 IIRC)
01:09:13 <Alpounet> http://www.haskell.org/haskellwiki/Hp2any
01:09:28 <Alpounet> there are 3 packages actually.
01:11:51 <jrockway> yeah
01:12:24 <jrockway> i mentally skipped over hp2ps because this is a windows program and i don't want to figure out how to view postscript files on windows :)
01:12:29 <jrockway> but i guess i will do that now
01:12:42 <jrockway> (anything outside of emacs on windows frightens me deeply)
01:13:09 <kamatsu> aw come on
01:13:16 <kamatsu> Linux aint that bad
01:13:38 <jrockway> linux is great
01:13:42 <jrockway> windows, though, scares me
01:13:46 <medfly> haha
01:13:50 <medfly> why does it scare you?
01:13:56 <tensorpudding> emacs on windows is kinda like a linux gated community in the middle of the sahara
01:14:08 <jrockway> especially if you are an eshell user, like me :)
01:14:18 <jrockway> medfly: mostly because everything is so tedious
01:14:35 <medfly> "ugh, moving the mouse"
01:14:42 <jrockway> if i need to view a postscript file on linux, i just apt-get install gv
01:14:44 <Alpounet> :D
01:14:59 <jrockway> for windows, i will have to google, then download something, then find the file on my desktop, then ...
01:15:01 <tensorpudding> there are plenty of user apps on windows, but not enough glue utilities
01:15:02 <medfly> finding programs on windows is indeed a bit tedious
01:15:03 <jrockway> what was i doing?
01:15:04 <kamatsu> hey, is there a haskell shell?
01:15:06 <jrockway> oh yeah, reading "hacker news"!
01:15:30 <jrockway> now pure haskell stuff... that is easy
01:15:35 <jrockway> cabal-install works fine on windows
01:15:41 <medfly> you can't program in Haskell unless you're using a Haskell OS with a Haskell text editor in a Haskell shell
01:15:50 <jrockway> (and fwiw, writing my app in haskell is MUCH easier than using visual studio / C# / F#)
01:16:01 <jrockway> medfly: so true!
01:16:03 <Alpounet> HP on Windows works pretty well IIRC
01:16:16 <sizzler> has somebody installed Yi with Pango frontend on windows?
01:16:25 <jrockway> also, the ability to overlap windows bothers me
01:16:30 <jrockway> why can't windows arrange the windows for me?
01:16:32 <jrockway> so annoying.
01:16:33 <jrockway> :)
01:16:50 <medfly> "ugh, it's not emacs. so hard"
01:16:52 <kamatsu> xmonad yay
01:17:00 <kamatsu> we need a Haskell X11 server
01:17:13 <kamatsu> and a haskell shell
01:17:17 <jrockway> s/X11 server//
01:17:21 <kamatsu> hah
01:17:29 <kamatsu> but without x11, we can't use xmonad
01:17:37 <jrockway> yeah, i meant to change that to a *
01:17:48 <jrockway> in addition to the X server, we also need ... everything else :)
01:17:57 <kamatsu> we already have window manager, text editor
01:18:02 <medfly> OS
01:18:05 <kamatsu> revision control system
01:18:11 <kamatsu> except the OS isn't POSIX, right?
01:18:20 <medfly> I read someone wrote an OS to give that a shot
01:18:36 <jrockway> someone write a haskell web browser and i will ditch UNIX forever :)
01:18:40 <kamatsu> Haha
01:18:41 <Alpounet> heh we'll be able to ship my Pong server/client with it
01:18:46 <jrockway> text editor + web browser == what more do you need
01:18:50 <kamatsu> shell
01:18:53 <jrockway> a music player and irc client, i guess :)
01:18:55 <kamatsu> yep
01:19:00 <kamatsu> media playing etc.
01:19:26 <jrockway> a haskell shell like eshell would be very interesting
01:19:35 <jrockway> i really like shells based on OS-independent abstraction layers
01:19:44 <tensorpudding> you need a pdf view
01:19:45 <tensorpudding> er
01:19:51 <jrockway> seriously
01:19:53 <tensorpudding> all this stuff windows has
01:19:57 <jrockway> there is no good pdf viewer to use with xmonad
01:20:06 <medfly> xpdf is bad?
01:20:08 <tensorpudding> evince is good
01:20:14 <jrockway> they both need the mouse
01:20:21 <tensorpudding> evince doesn't need the mouse
01:20:28 <medfly> ugh, so tedious, I need to move the MOUSE.
01:20:29 <tensorpudding> unless you want to open files
01:20:46 <medfly> I usually just use a command to start xpdf
01:21:03 <tensorpudding> i usually open documents using rox, and then stick with the keyboard to scroll the document
01:21:04 <jrockway> ah, you're right
01:21:09 <jrockway> but it does need arrow keys, which is annoying
01:21:17 <tensorpudding> evince can do vi-keys
01:21:20 <jrockway> scrolling should be C-v/M-v/C-p/C-n :)
01:21:21 <medfly> ugh, arrow keys
01:21:24 <jrockway> yeah, not a vi user
01:21:33 <medfly> what's with this mouse hate? c'mon :)
01:21:34 <tensorpudding> i don't use vi much either
01:21:46 <tensorpudding> but vikeys is better than page up and page down :)
01:22:01 <jrockway> first i would have to learn vi key bindings, then i would have to use them
01:22:04 <jrockway> now i have two problems :)
01:22:05 <medfly> although, maybe if I were using something like an iphone...
01:22:08 <pettter> medfly: using the mouse means moving the hand away from the keyboard
01:22:14 <pettter> doing that a lot = strain
01:22:16 <tensorpudding> there are only four keys to learn
01:22:24 <medfly> how often do you open files? :)
01:22:31 <pettter> lots of strain = terribad pain in arms
01:22:33 <jrockway> which one of hjkl is "page down"? :)
01:22:39 <tensorpudding> j
01:22:48 <tensorpudding> it's like wasd, basically
01:22:51 <jrockway> that is "line down" :)
01:22:59 <medfly> wasd is more friendly for me. it's what games use
01:23:05 <tensorpudding> do you need to go down a page at a time?
01:23:23 <tensorpudding> if you are okay with xpdf, i think that one uses n and p
01:23:28 <tensorpudding> to go one page at a time
01:24:30 <jrockway> ok
01:24:36 <jrockway> both seem like workable solutions
01:24:48 <jrockway> now back to my actual problem... viewing ps files on windows :)
01:25:15 <pettter> jrockway: ghostview
01:25:22 <jrockway> thanks
01:25:25 <jrockway> google seems to agree
01:25:35 <jrockway> (unix utilities available on windows)++
01:25:45 <medfly> hehe
01:26:00 <medfly> "man, windows is so unpopular no one writes apps for that. it's so hard to use it."
01:26:04 <kamatsu> cygwin?
01:26:31 <pettter> medfly: well, yeah :)
01:26:36 <jrockway> it constantly surprises me that anyone bothers to make stuff work on windows
01:26:41 <jrockway> but they do, and it's nice
01:27:30 <cjs> Anybody know how to install ThreadScope? My system complains that it requires cairo, glade and gtk,, and that I have none of these.
01:27:59 <dcoutts> cjs: you need to install gtk2hs
01:28:00 <lambdabot> dcoutts: You have 5 new messages. '/msg lambdabot @messages' to read them.
01:30:12 <cjs> Is there a gtk2hs built for x64 and ghc 6.12 kicking around somewhere, or do I have to build it myself?
01:30:32 <dcoutts> cjs: do you mean windows?
01:30:37 <cjs> Sorry, Linux.
01:30:51 <dcoutts> everyone builds from source on linux, unless you use a distro package
01:31:12 <medfly> using a distro package is common
01:31:14 <medfly> it's what everyone does
01:31:40 <dcoutts> right, though if you're using 6.12 then the distros will not have it packaged yet
01:31:51 <cjs> Ubuntu 9.04 doesn't seem to have one. And yes, I'm using 6.12. (This is so I can run ThreadScope.)
01:32:06 <dcoutts> and I'm not actually sure gtk2hs works with 6.12 yet
01:32:07 <cjs> Hm. Any suggestions on what source to use? I understand I need a patch to build under 6.12?
01:32:27 <dcoutts> there's a note on the gtk2hs site
01:32:45 <cjs> It says that "Duncan posted a patch that allows compilation of Gtk2Hs with ghc 6.12.". :-)
01:32:55 <dcoutts> :-)
01:33:13 <int-e> http://sourceforge.net/mailarchive/message.php?msg_name=1260471581.13548.13986.camel%40localhost
01:33:17 * dcoutts hasn't checked what's happened to it recently
01:33:29 <int-e> dcoutts may have a better link.
01:33:39 * dcoutts knows nothing
01:34:50 <int-e> hmm, what has happened: You can build gtk2hs with it, provided you use --disable-splitobjs when configuring, and don't build the docs. None of the patches have landed yet, as far as I'm aware.
01:35:28 <int-e> err, it's --disable-split-objs
01:35:42 <dcoutts> of course, you don't need 6.12 to build ThreadScope
01:35:51 <dcoutts> you just need 6.12 to be able to use it
01:36:01 <ivanm> heh
01:36:05 <sinelaw> @hoogle numComponents
01:36:05 <lambdabot> No results found
01:36:07 <dcoutts> I think that's what the ThreadScope devs have been doing
01:36:08 <sinelaw> damn.
01:36:14 <sinelaw> anyway succesfully used opengl evaluators?
01:36:20 <dcoutts> building it with 6.10, and using it on logs generated with 6.12
01:36:31 <dcoutts> it's probably the easiest method at the moment
01:36:41 <cjs> That's a good thought.
01:36:51 <dcoutts> especially seeing how it's so easy to have multiple versions of ghc installed
01:36:55 * dcoutts has 5 versions
01:37:06 <cjs> I was about to say that I've got about five, too.
01:37:19 * benmachine has one and one source build that isn't really installed
01:37:29 <cjs> Oops, I lied. Six.
01:37:38 <benmachine> they're a few hundred megabytes each aren't they?
01:37:45 <benmachine> or can you share some of the bits
01:38:12 <cjs> Yeah, maybe 600 MB each. It's livable in this day and age. I wouldn't want to try sharing....
01:38:45 <benmachine> hmm
01:38:52 <benmachine> there is a gtk2hs package in the arch repositories
01:38:57 <benmachine> and 6.12 is in the arch repositories
01:38:57 <kamatsu> sinelaw: so, yours just sets it to antialias by default?
01:39:04 <ivanm> cjs: in case you didn't hear, SourceGraph now deals with underscored functions
01:39:12 <benmachine> soo I *assume* they work together
01:39:15 <kamatsu> benmachine: means nothing
01:39:19 <sinelaw> kamatsu, yea...
01:39:20 <benmachine> nothing?
01:39:40 <kamatsu> sinelaw: hm, i think it'd be better if we exposed the options for drawing somehow
01:39:45 <sinelaw> kamatsu, i don't know how to generalize it. it doesn't make sense to start wrapping each and every possible configuration for opengl
01:39:49 * benmachine shrugs
01:39:55 * benmachine doesn't fiddle with it
01:39:58 <kamatsu> sinelaw: just let the openGL configuration be done separately?
01:40:08 <sinelaw> kamatsu, that's possible.
01:40:21 <kamatsu> benmachine: the gtk2hs package is generated from hackage, and whether or not it will build with arch's ghc is not determined
01:41:24 <benmachine> kamatsu: if you say so
01:41:26 <dcoutts> kamatsu: that one is not generated from hackage
01:41:30 <kamatsu> dcoutts: it  isn't?
01:41:33 <benmachine> I am not feeling anarchic enough to prove you wrong :P
01:41:41 <dcoutts> kamatsu: since it's not on hackage
01:41:41 <cjs> ivanm: Yes, I noticed. Thanks.
01:41:46 <ivanm> no worries
01:41:47 <kamatsu> dcoutts: oh, there you go
01:42:10 <benmachine> it's in the community repository so I guess it's a binary package
01:42:12 <Alpounet> benmachine, arch packages are being updated to 6.12
01:42:28 <Alpounet> but it's not complete yet
01:42:35 <Alpounet> see the arch-haskell ML
01:42:36 <benmachine> Alpounet: cool
01:42:44 <kamatsu> sinelaw: hm, if you know a little something about GL, perhaps you can tell me this: Is it possible to have off-screen buffers that you draw to, i.e other than the screen itself?
01:42:58 <sinelaw> kamatsu, i don't know much at all. but i think you can.
01:43:10 <sinelaw> i'm pretty sure
01:43:31 <trzkril> arch just replaced ghc 6.10.4 with 6.12 when i decided to try out Yi :(
01:43:47 <kamatsu> Yi had build problems on 6.10 as of a few months ago too
01:43:52 <Alpounet> you still can remove 6.12 et install back 6.10.4
01:43:53 <kamatsu> trivial to fix tho
01:44:04 <Alpounet> oh, then it's nice.
01:44:21 <kamatsu> sinelaw: ok,  i'll pore over the GL docs
01:44:33 <sinelaw> good luck....
01:44:58 <Alpounet> kamatsu, you mean e.g Double Buffering ?
01:45:38 <kamatsu> Alpounet: not specifically
01:45:48 <kamatsu> i want to be able to have an arbitrary number of surfaces i can draw to
01:46:04 <Alpounet> and display one at a time ?
01:46:13 <kamatsu> Alpounet: i want to be able to blit one onto the screen
01:46:29 <int-e> kamatsu: look for frame buffer objects
01:46:38 <kamatsu> int-e: thanks for the tip
01:49:48 <sinelaw> wooho, segfault
01:51:06 <kamatsu> sinelaw: hm?
01:51:44 <sinelaw> kamatsu, trying to play with opengl evaluators in ghci
01:51:47 <sinelaw> it segfaulted.
01:51:59 <kamatsu> ah
01:52:40 <kamatsu> okay, buffer objects almost do what I want, but then, how can I blit one onto another?
01:52:53 <sinelaw> try #opengl?
01:53:03 <sinelaw> there are a few opengl hackers here, but i guess they're not present
01:53:23 <kamatsu> ah, i'm more thinking aloud than demanding answers
01:53:42 <sinelaw> :)
01:54:03 <kamatsu> to blit one onto the other, there is no clear straightforward way to do it
01:54:16 <kamatsu> perhaps I can access the raw bitmap data of the buffer, convert that to something else, and then blit that
01:54:33 <int-e> kamatsu: by attaching a texture to the FBO. (but I'm afraid I don't know how that is done in detail. learning this is on my long term todo pile)
01:55:20 <kamatsu> so, FB0 is I assume the default buffer, i.e screen?
01:55:40 <kamatsu> oh wait, you said FBO
01:55:47 <kamatsu> now i see
01:56:02 <kamatsu> okay, i'll look into figuring it out
01:56:40 <sinelaw> I have an exact example in C to do what i want
01:56:50 <sinelaw> but i just can't translate it to haskell's opengl
01:57:08 * sinelaw *bangs head*
01:57:45 <kamatsu> sinelaw: apparently ghci can randomly segfault
01:57:50 <kamatsu> sinelaw: tried compiling?
01:57:59 <sinelaw> yes, now i ahve other problems
02:01:05 <solrize> is PLAI a good book?  www.plai.org
02:01:46 <kamatsu> int-e: http://www.gamedev.net/reference/articles/article2331.asp
02:01:52 <kamatsu> int-e: does this look like the right track?
02:02:15 <kamatsu> int-e: it lets me attach a texture to an FBO, and then rendering to the FBO will be reflected in the texture, which I can then blit elsewhere
02:03:06 <int-e> kamatsu: yep
02:04:09 <solrize> oh this does look good, it says how to do type inference, which i was asking about yesterday
02:06:07 <solrize> ehh, the examples are all in scheme :P
02:06:51 <kamatsu> solrize: type inference is usually specified with formal inference rules
02:07:20 <kamatsu> solrize: essentially you set up a system of type equations that are solved with a series of substitutions called unifiers
02:07:24 <solrize> well i wanted to know how to implement it
02:07:26 <solrize> right
02:07:41 <kamatsu> i've done it before, but don't want to get sidetracked atm :P
02:07:57 <kamatsu> what would be the haskell openGL equivalent of glGenFrameBuffersEXT ?
02:08:03 <solrize> for some reason i thought that for a fancy type system like GHC's, unification was sort of like a SAT solver, i.e. exponential if you do it the obvious way but tractable for most cases if you use enough tricks
02:08:08 <sinelaw> ok, giving up. i'll try to fix the bezier stuff later.
02:08:17 <solrize> however from discussions last night it sounds easier than that
02:08:19 <kamatsu> solrize: i dunno about ghc
02:08:20 <sinelaw> :(
02:08:28 <solrize> i looked at the description of algorithm W in wikipedia
02:08:29 <kamatsu> sinelaw: aw =(
02:08:45 <sinelaw> i'm pretty sure i'm almost there. it compiles and runs, just doesn't shwo anything
02:09:01 <kamatsu> hm
02:09:05 <kamatsu> you probably missed something trivial
02:10:15 <solrize> "24.1     What Are Types?
02:10:15 <solrize> A type is any property of a program that we can establish without executing the program."
02:10:40 <solrize> that's an interesting alternative to pierce's description
02:11:09 <kamatsu> solrize: that description comes from the curry howard ismorphism
02:12:02 <solrize> hmm, even for non-lambda-calculus languages ?
02:12:52 <kamatsu> solrize: oh well, it depends on what you mean
02:13:14 <kamatsu> solrize: it should be possible to convert any language to some form of typed lambda calculus
02:13:17 <ivanm> when using rnf, if I just do "return $ rnf foo" in a do block, will it actually force evaluation of foo?
02:13:51 <solrize> kamatsu, ic.  i was thinking of (e.g.) imperative languages with hoare logic
02:14:17 <solrize> assembly language etc
02:14:20 <Lemmih> ivanm: No.
02:14:27 <ivanm> didn't think so
02:14:43 <kamatsu> solrize: well, the type information doesn't have to be meaningful
02:14:51 <kamatsu> :P
02:15:10 <medfly> even stuff like asm? o.O
02:16:49 <kamatsu> medfly: just imagine it as each command piping a brand new machine state into the next
02:17:19 <int-e> solrize: You can say that the types of Hoare logic are the sets of states of the world that satisfying certain conditions, and functions from one of those types to another.
02:17:53 <solrize> can that be mapped onto typed lambda calculus?
02:18:02 <kamatsu> should be possible
02:18:23 <kamatsu> anyway
02:18:23 <kamatsu> bah
02:18:26 <kamatsu> getting sidetracked
02:18:42 <kamatsu> glGenFrameBuffersEXT doesn't seem to be in HOpenGL
02:18:50 <kamatsu> don't tell me i'll have to do my own bindings :(
02:19:19 <sinelaw> check OpenGLRaw
02:19:34 <raceRider> @hpaste
02:19:35 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
02:19:35 <solrize> do you have to keep using more and more powerful type systems?  is there something beyond (say) martin-lof type theory?
02:20:04 <solrize> i mean, what if you have a program that's only provably total using ZFC+some large cardinals, or something like that?
02:20:04 <Alpounet> damn
02:20:11 <Alpounet> I really gotta get a copy of TAPL
02:20:48 <solrize> Alpounet, it's a good book
02:21:04 <solrize> i have a borrowed copy that i've been wanting to read since i first got interested in haskell
02:21:17 <solrize> but i've only flipped thru it a little.  i couldn't understand much when i first started
02:21:23 <solrize> but could probably get a bit further now
02:21:32 <medfly> what is TAPL?
02:21:51 <erikc`> kamatsu: use factor, it has full opengl 3.1 and dx11 bindings ;)
02:22:16 <sinelaw> @hoogle evalCoord1
02:22:17 <lambdabot> No results found
02:22:18 <Alpounet> medfly, Types and Programming Languages, by Benjamin C. Pierce
02:22:20 <Alpounet> @where tapl
02:22:20 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
02:22:25 <solrize> @where tapl
02:22:25 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
02:22:33 <solrize> heh jinx
02:22:39 <Alpounet> yeah, sometimes people call me Lucky Luke
02:22:46 <erikc`> i think ive given up on types
02:22:51 <raceRider> Is there an easier approach to converting hex to dec than this: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=6510#a6510
02:23:00 <erikc`> well, static ones anyway
02:23:45 <solrize> raceRider, there's some module in hackage that can do it ?
02:23:55 <solrize> or just use the appropriate fold
02:24:02 <kamatsu> @hoogle hex
02:24:03 <lambdabot> Text.Parsec.Token hexadecimal :: GenTokenParser s u m -> ParsecT s u m Integer
02:24:03 <raceRider> solarize, no I couldn't find any
02:24:03 <lambdabot> Text.ParserCombinators.Parsec.Token hexadecimal :: GenTokenParser s u m -> ParsecT s u m Integer
02:24:03 <lambdabot> Text.Parsec.Char hexDigit :: Stream s m Char => ParsecT s u m Char
02:25:16 <medfly> oh, okay, thanks
02:25:23 <solrize> http://hackage.haskell.org/packages/archive/dataenc/0.13.0.2/doc/html/Codec-Binary-Base16.html
02:25:29 <solrize> might help
02:31:11 <jrockway> note to self: make use of +RTS -B at work
02:31:18 <jrockway> it makes me feel like my program is useful...
02:32:10 <jrockway> (it also makes my remote desktop session lock up...)
02:32:51 <cads> is there an exact copy of the haskell channel's lambdabot that I can get? or does she have private information stored?
02:33:17 <Lycurgus> when did it become she?
02:33:17 <solrize> Ian Barland: “In Ginsberg’s Howl, the name of the ancient god Moloch is used to exemplify society’s embracing of soulless
02:33:17 <solrize> machines, machines for the sake of machines rather than the elegance they can embody. I do not consider it coincidental that this
02:33:17 <solrize> name sounds like ‘malloc’.”
02:33:26 <solrize> @vixen asl
02:33:26 <lambdabot> 19/f/California
02:33:40 * cads wolf-whistles
02:33:56 <int-e> also, http://www.haskell.org/haskellwiki/Lambdabot
02:34:04 <sinelaw> allright, something appears on the screen!
02:35:06 <Lycurgus> i see I guess bots default gender from Eliza
02:35:25 <Lycurgus> when they have a conversational component
02:36:30 <Alpounet> cads, hackage
02:36:37 <Alpounet> @hackage lambdabot
02:36:37 <lambdabot> http://hackage.haskell.org/package/lambdabot
02:36:38 <Alpounet> IIRC
02:36:57 <quicksilver> cads: she has private information.
02:37:11 <quicksilver> cads: however, it's probably possible to persaude people to share it. I think you have to ask Cale.
02:37:24 <sinelaw> kamatsu, works!
02:37:28 <cads> thanks quicksilver , int-e, Alpounet
02:37:41 <quicksilver> the private info is mostly @where and @quote
02:37:47 <kamatsu> sinelaw: yay:D
02:37:50 <quicksilver> the other stuff should be in the repo IIRC>
02:38:04 <kamatsu> sinelaw: i'm making progress with my surfaces thing
02:38:22 <cads> yeah, there are those wacky quotes by the famous computer scientist that I dig
02:38:31 <jrockway> hmm, so it looks like my memory use problems are related to my use of a WriterT [String]
02:38:40 <sinelaw> kamatsu, great. I just pushed the bezier addition commit
02:38:44 <jrockway> is there some known caveat against using WriterT in a monadic fold?
02:38:56 <jrockway> because I am actually not writing anything, it just exists and uses a lot of stack
02:39:12 <kamatsu> sinelaw: nice
02:40:16 <IceDane> How would I go about converting a string containing a hexadecimal number to an integer in haskell?
02:40:47 <int-e> :t readHex
02:40:49 <lambdabot> forall a. (Num a) => String -> [(a, String)]
02:40:51 <IceDane> Ah, thanks.
02:41:03 <jrockway> interestingly, someone asked that about 10 minutes ago :)
02:41:11 <int-e> (from the Numeric module)
02:42:04 <Wooga> is thare any way to get terminal size in haskell?
02:42:43 <jrockway> Vty has something
02:43:03 <jrockway> and i might have some code for that somewhere, actually... let me look
02:46:37 <cads> hey, are you guys familiar with the xkcd 'sierpinski valentine'?
02:46:50 <solrize> iirc
02:47:05 <cads> http://3.bp.blogspot.com/_wMTxUKS--NQ/SZcQA0B6IVI/AAAAAAAAA_c/sD41vmaPbn4/s1600/sierpinski_valentine.png
02:47:10 <cads> eek
02:47:25 <cads> well, that was last year, I believe
02:47:37 <Alpounet> cads, haha nice
02:47:46 <Alpounet> I'll try to offer a program rendering it to my gf
02:47:59 <cads> this year I want to make a .. hey don't steal my idea :)
02:48:30 <cads> Alpounet, I'm having a hard time finding a way to map the hearts into the subregions
02:48:53 <Alpounet> heh
02:49:04 <Alpounet> are you really writing a haskell program for that ? :)
02:49:27 <cads> I'll probably end up doing it in processing
02:49:43 <cads> but the math part needs to be done
02:49:54 <Alpounet> I had written a program to render Cantor's set
02:49:59 <Alpounet> much less romantic, though.
02:50:25 <Alpounet> "when not with you, I feel like the Cantor set, darling"
02:50:42 <trzkril> the gtk2hs package in arch fails to register its packages because the dependency base-4.1.0.0 is missing.
02:50:47 <cads> I'm a man of measure 0
02:51:07 <trzkril> is there an alternative to switching back to ghc 6.10?
02:51:16 <Alpounet> trzkril, AFAIK, ghc 6.12 related updates are being processed
02:51:21 <Alpounet> check the mailing list
02:51:35 <Alpounet> but until it's completely done, I advise you to switch back to 6.10.4 indeed
02:51:53 <trzkril> Alpounet: thanks, i will have a look
02:51:57 <cads> well, this fractal is rather more complicated than the normal sierpinski - he seems to use some kind of artist-approximated conformal mapping for placing and distorting the hearts in each subregion, the effect is real nice
02:52:39 <Alpounet> trzkril, i686 or x86_64 ?
02:52:51 <Alpounet> cads, indeed
02:52:55 <trzkril> x86_64
02:53:04 <trzkril> ah
02:53:34 <Alpounet> trzkril, IIRC, pacman -Qu http://arm.konnichi.com/extra/os/x86_64/ghc-6.10.4-1-x86_64.pkg.tar.gz and you should be done
02:53:52 <Alpounet> don't forget to uninstall ghc 6.12 and all the 6.12-built packages
02:53:56 <Alpounet> (before)
02:56:35 <Alpounet> is there any difference between runghc and runhaskell if the only compiler I have is ghc ?
02:56:51 <cads> Alpounet, but yeah, I'm serious about constructing this fractal in a real sense, now the question is can I discover a way of naturally mapping a triangle's internal coordinate system into a edge curve parameterized region.. in the 14 or so days before valentine's
02:57:37 <zygoloid> cads: what's your approach for rendering it?
02:57:59 <Alpounet> cads, wanna find a bijection between a triangle and a heart ?
02:57:59 <Alpounet> hmm
02:58:35 <cads> it needs to be a bigejction between a triangle and a subregion of the triangle after a heart has been removed
02:58:59 <cads> so between a triangle and a region bounded by 3 or 4 curved segments
02:59:16 <Alpounet> good luck
02:59:46 <zygoloid> cads: i think i'd approximate the boundary of the heart as a polygon when positioning the smaller hearts
03:00:15 <zygoloid> do you want to allow arbitrary zooming?
03:00:38 <cads> zygoloid, definitely in practice (about the approximation)
03:00:45 <cads> nah, don't want to zoom
03:01:46 <kamatsu> aw crap
03:01:48 <cads> but we can see from the drawing that the shape of the subregions affect not only the positioning of the smaller hearts, but also the hearts are distorted to "flow" with a distorted coordinate system for each subregion
03:01:51 <kamatsu> my gl program segfault
03:02:56 <cads> what I'll try at first it simply placing a heart in each region so that it's "packed" against the region's edges
03:03:08 <cads> I can do that with a simpler heart shape
03:03:13 <cads> anyways, I gotta go
03:05:51 <cads> hmm, if I constructed a smoothly bijective chart parameterized by a curved polygon.. I could approximate it arbitrarily well and perform arbitrary zooms as well :)
03:06:12 <zygoloid> cads: you could take the triangle and tesselate it with small triangles, then you could probably work out a mapping for those based on the distortion of the boundary
03:06:42 <cads> hmm, a spring relaxation process, even
03:07:03 <IceDane> !books ?
03:07:08 <cads> wow zygoloid, I think that works
03:07:11 <IceDane> Nope - what was the command for haskell books again?
03:07:26 <IceDane> !enlighteningreadingmaterial
03:07:29 <IceDane> Hmm.
03:08:20 <Saizan> @where books
03:08:20 <lambdabot> I know nothing about books.
03:08:23 <Saizan> @where book
03:08:23 <lambdabot> I know nothing about book.
03:08:52 <SubStack> yay 6.12
03:08:57 <cads> goodnight
03:09:24 <SubStack> getting so many deprecation warnings now cabal installing things
03:09:25 <IceDane> I had a book here, somewhere, as ebook. I can't remember what it was called so I can't search for it on my system, but I remember that some of the authors were supposedly frequent visitors here
03:09:31 <ehamberg> @where gentle
03:09:31 <lambdabot> http://www.haskell.org/tutorial/
03:09:38 <ehamberg> @where lyah
03:09:38 <lambdabot> http://www.learnyouahaskell.com/
03:09:40 <Alpounet> @where rwh
03:09:41 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
03:09:44 <IceDane> there it was
03:09:45 <IceDane> RWH
03:09:49 <IceDane> thanks
03:20:56 <Wooga> hello, i am trying to instal through cabal-install package vty, but i am getting error: There is no available version of ghc-prim that satisfies -any
03:21:05 <Wooga> what should i do with this?
03:25:04 <IceDane> Do I have to download the quickcheck library separately or something in that direction, or is the book just outdated(E.g. Is it somewhere else than Test.QuickCheck?)
03:26:21 <Alpounet> IceDane, IIRC, it's shipped with GHC
03:26:32 <Alpounet> check that you have it with : $ ghc-pkg list | grep QuickCheck
03:27:46 <IceDane> I don't, apparently x.x
03:27:48 <IceDane> I'll just download it
03:31:35 <quicksilver> it was shipped with GHC but isn't in recent GHCs, I think
03:31:40 <quicksilver> the trend is to bundle the minimum amount.
03:33:31 <Alpounet> yeah
03:33:44 <Alpounet> that caused few package dependency issues in arch
03:43:45 <solrize> what's "miller pattern unification"?  (agda uses it)
03:44:51 <fasta> solrize, google tells me it is some kind of higher-order pattern unification.
03:45:00 <fasta> solrize, you did google, didn't you?
03:45:16 <solrize> thanks, yeah, i found a couple references but would have to chase down the paper
03:45:26 <fasta> solrize, uh, that's what everyone has to do.
03:45:39 <solrize> well i was hoping for a 1-sentence explanation
03:45:54 <solrize> anyway it'll have to go on my infinite stack overflow of stuff to read
03:46:16 <fasta> solrize, ah, an algorithm about which people write a 10 page article can be described with all its details in 1 sentence. That's news.
03:46:31 <solrize> i didn't want the details i just wanted to know what it was
03:47:11 <solrize> anyway thanks
03:47:45 <fasta> solrize, normal unification only does first-order unification. This apparently also works when the terms are of higher-order. Probably with some annotations required by the user.
03:48:44 <solrize> what would it mean for a term to be higher order?  it has quantifiers of its own?
03:49:19 <fasta> solrize, yes, that you can pass functions to terms for example.
03:50:34 <fasta> solrize, in first order logic you cannot state theorems about functions.
03:51:24 <solrize> ok
03:51:28 <fasta> solrize, unless you interpret the domain in some specific way, but in principle you would have to add axioms for new functions.
03:51:44 <solrize> sure
03:52:05 <fasta> solrize, e.g. in first order logic you can define the natural numbers, but you cannot define map.
03:52:14 <ivanm> anyone know how I can call a different application and have "buffered" I/O via stdin and stdout whilst still being able to pick up errors, etc.?
03:52:46 <solrize> would map count as a higher order term?
03:54:06 <mjrosenb> ivanm: errors are not reported on stderr?
03:54:31 <ivanm> mjrosenb: yes, that's what I meant
03:54:53 <ivanm> from what I understood dcoutts telling me, ensuring I can still get stderr out is the tricky part
03:55:50 <mjrosenb> ivanm: this sounds like a job for threading
03:56:03 <ivanm> hmmm....
03:56:25 <fasta> solrize, map(f,x) assumes that f is a function, so that's a term from second order logic.
03:56:39 <ivanm> well, I'm using threads to manage getting the stdout and stderr
03:56:56 <ivanm> the problem is, is that it's strict in returning the output; no output is returned until the entire thing is finished
03:58:43 <ivanm> hey malcolmw
03:58:59 <malcolmw> hi ivanm
03:59:01 <mjrosenb> ivanm: you mean the output from stdout or from stderr?
03:59:06 <ivanm> mjrosenb: both
03:59:10 <solrize> so that term would have type (a->b)->[a]->[b]  .... i guess normal haskell pattern matching can't recognize something like that, but i remember noticing that you could do something like it with gadt's... i guess that explains the difference
03:59:16 <solrize> this is starting to make sense
03:59:18 <mjrosenb> also, once you get an error, do you care about the output from stdout at all?
03:59:24 <ivanm> I was going to blame polyparse for being so slow with something, then I realised that the profile output was lying
03:59:30 <ivanm> mjrosenb: nope
04:00:16 <malcolmw> if the profile lies, report it as a bug
04:00:54 <mjrosenb> ivanm: so can you set up stderr to be unbuffered, then just force everything to exit when you read from stderr
04:01:29 <ivanm> malcolmw: the profile lies because most of the time is spent waiting for an external app
04:01:48 <ivanm> (well, the time is mainly spent constructing input, passing it through, then getting the output back)
04:01:55 <ivanm> at least I _think_ that's the main problem
04:02:07 <ivanm> mjrosenb: uhhhh..... what?
04:02:45 <fasta> solrize, for the actual types, things are different.
04:03:03 <fasta> solrize, the term which corresponds to the type is not higher-order for the standard map function.
04:03:15 <fasta> solrize, for map it is a standard rank-1 type.
04:04:03 <solrize> a rank-2 type is something like List ?
04:04:13 <fasta> solrize, no, that's a type constructor.
04:04:27 <solrize> hmm
04:04:32 <fasta> solrize, the rank is simply the amount of nested foralls + 1.
04:04:55 <fasta> solrize, runST is of rank-2 for example.
04:05:00 <fasta> @type runST
04:05:01 <lambdabot> forall a. (forall s. ST s a) -> a
04:05:11 <solrize> aha
04:05:23 <mjrosenb> gah, i want a binding from within a do block to escape the block :(
04:05:35 <ivanm> mjrosenb: hmmm?
04:05:43 <Alpounet> do you want to escape from a monad ?
04:05:45 <fasta> solrize, to who am I speaking? A student?
04:05:53 <solrize> so this gets more relevant when you're using existentials etc a lot
04:06:20 <fasta> solrize, you can write every program using just Haskell98 + ST.
04:06:25 <mjrosenb> ivanm: combinator parser.  it is beautiful, but lacking on the error reporting
04:06:26 <solrize> me?  just a programmer interested in logic and trying to pick up haskell and some related topics
04:06:35 <fasta> solrize, in fact, you don't need ST.
04:06:37 <mjrosenb> ivanm: type Parser a b = [b] → [(a, [b])]
04:06:41 <mjrosenb> is the type
04:06:41 <ivanm> heh
04:06:47 <mjrosenb> p +++ q = λstr → [((x,y),t) | (x,t') ← p str, (y,t)← q t']
04:06:51 <ivanm> which parser are you using? one of your own?
04:06:52 <fasta> solrize, so, to write useful programs, you don't need to know anything about rank-2 stuff.
04:07:04 <mjrosenb> is sequencing two parsers
04:07:14 <solrize> well i'm interested in implementing DSL's with their own type systems
04:07:26 <fasta> solrize, well, then you might be interested in them.
04:07:29 <mjrosenb> i now want to find which parse tree consumed the most tokens
04:07:56 <mjrosenb> hopefully while still using the list wrapper for a do block
04:08:35 <solrize> also interested in type-level hackery in haskell... i'm fooling around with Atom which uses GADT's to carry types of the client programs
04:08:44 <ivanm> @tell sinelaw OK, I _think_ I've made one big call a tad more efficient
04:08:45 <lambdabot> Consider it noted.
04:08:46 <ivanm> mjrosenb++
04:10:58 <solrize> anyway thanks... it's the middle of the night here, i'm not very awake... i'll see if i can keep making sense of this article (agda tutorial) and also the "power of pi" paper which talked about using agda for typed DSL's
04:11:29 <fasta> solrize, yes, Atom is relatively interesting. Agda is kind of in-flux, in that fundamental parts of their type-system are broken.
04:11:45 <mjrosenb> ivanm: ?
04:12:34 <ivanm> mjrosenb: well, I shifted getting the stderror output till after checking to see if the process has finished, and it seems to make it a tad faster...
04:12:39 <solrize> oh that's interesting about agda's type system being broken.  you mean like logically unsound or so?
04:12:50 <fasta> solrize, yes, I mean logically unsound.
04:12:57 <solrize> ouch
04:13:00 <fasta> solrize, the mailing lists are full of it.
04:13:04 <Alpounet> I'm getting : Could not find module `Text.HTML.TagSoup.Parser' when importing that module
04:13:14 <Alpounet> with : "it is a hidden module in the package `tagsoup-0.8'"
04:13:17 <Alpounet> any clue
04:13:18 <Alpounet> ?
04:13:22 <solrize> they just noticed the problem recently?  that's scary
04:13:31 <fasta> solrize, they are parts which can be repaired, probably.
04:13:41 <Botje> Alpounet: are you using ghc --make to compile?
04:13:47 <fasta> solrize, that is by simply disabling some code.
04:13:58 <solrize> do they try to machine check these things?
04:14:13 <fasta> solrize, if you want that you can better go to the Coq camp.
04:14:23 <solrize> hmm
04:14:31 <fasta> solrize, Coq also had a hole a few years ago.
04:14:32 <Alpounet> Botje, yep
04:14:49 <fasta> solrize, that said, most real programming languages are much more buggy ;)
04:14:50 <Alpounet> should I use "-package tagsoup" instead ?
04:15:31 <solrize> there's a guy at princeton trying to prove that first order peano arithmetic is unsound... we were just talking about him here a couple nights ago ;)
04:15:45 <solrize> s/unsound/inconsistent/
04:16:04 <Botje> try it ?
04:16:12 <Botje> though i think --make should take care of that
04:16:14 <fasta> solrize, didn't Gentzen already proved it was consistent?
04:16:24 <fasta> solrize, like 70 years ago if not more.
04:16:37 <fasta> I am going to take side with Gentzen ;)
04:17:00 <solrize> i don't think gentzen's proof goes through in this guy's arithmetic
04:17:06 <solrize> his arithmetic is weaker than PRA
04:17:24 <fasta> solrize, URL?
04:17:27 <solrize> sec
04:18:04 <solrize> http://www.math.princeton.edu/~Nelson/papers.html  here are a bunch of papers, there is also a book
04:18:20 <solrize> http://www.math.princeton.edu/~Nelson/papers/hm.pdf  this is a starting point
04:18:46 <solrize> http://www.math.princeton.edu/~Nelson/papers/e.pdf or this might be better
04:19:18 <solrize> http://www.math.princeton.edu/~Nelson/books.html  the book is here, "predicative arithmetic"
04:20:54 <ivanm> mjrosenb: I think I spoke too soon...
04:20:58 <ivanm> for larger inputs it hangs :s
04:21:19 * ivanm might have to loop the interior bit of his run function
04:21:26 <kamatsu> ah, too many segfaults
04:21:33 <kamatsu> why does HOpenGL not have framebuffer objects
04:21:37 * kamatsu is sad
04:22:56 <Alpounet> Botje, yeah it should but it looks like it doesn't that well for this particular case
04:23:41 <fasta> solrize, I just skimmed one of them, but I haven't seen any new points.
04:25:06 <solrize> basically he doesn't like the way the PRA induction scheme quantifies over N without first proving that N actually exists
04:25:19 <Alpounet> damn, I can't install download
04:26:49 <Alpounet> @hoogle openURI
04:26:50 <lambdabot> No results found
04:26:54 <solrize> http://math.ucsd.edu/~sbuss/ResearchWeb/nelson/talk.pdf  here's a description written by a CS guy (one of nelson's students)
04:28:45 <solrize> these things explain reasonably well why nelson doesn't like PA or PRA, but nothing gives any hint of why nelson thinks there is an actual demonstrable inconsistency
04:29:24 <solrize> the first few of buss's slides sum it up, i guess
04:31:06 <solrize> anyway the thing with Atom is that it makes C programs that have the usual bugs of C programs... so I think it needs user definable types that are hopefully comparable to haskell types
04:32:56 <Wooga> anyone know any location with simple haskell programs with sources?
04:33:58 <Wooga> doing primitive tasks such as parsing xml document, grabbing images from site, and etc
04:34:05 <solrize> wooga
04:34:06 <solrize> @where rwh
04:34:07 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
04:34:14 <solrize> also hackage
04:34:23 <Wooga> thanks
04:34:31 <solrize> but the programs on hackage tend to use advanced stuff and be hard to read
04:34:35 * mjrosenb would not consider those things primitave
04:34:50 <solrize> which things mjrosenb ?
04:34:59 <solrize> oh the tasks
04:35:00 <solrize> sorry
04:35:23 <Wooga> mjrosenb: it just matter of knowing your language. i know bash and posix sh and think about doing such tasks in sh as primitive task
04:35:43 <mjrosenb> Wooga: you parse xml using sh?
04:35:59 * solrize tries to sleep again ... nite
04:36:03 <mjrosenb> (+>>) ∷ Parser a x → (a → Parser b x) → Parser (a,b) x
04:36:06 <mjrosenb> oh god
04:36:15 <mjrosenb> how does that one work again?
04:36:16 <Wooga> mjrosenb:  well, sorta
04:36:41 <Wooga> i transformed xml document with sed and |while read
04:37:20 <Wooga> sed is really powerful when you work with structured data
04:37:49 * mjrosenb tries to avoid while read at all costs
04:38:08 <Wooga> why?
04:38:22 <mjrosenb> painfully slow
04:38:33 <Wooga> never noticed that
04:39:04 * mjrosenb has attempted to muck with 10 million line files using while read
04:39:12 <benmachine> isn't bash supposed to be slow in general anyway
04:39:19 <benmachine> I mean
04:39:29 <benmachine> by comparison
04:39:37 <mjrosenb> benmachine: i have not heard an argument that anything other than C is fast :-p
04:40:40 <Wooga> well, awk is fast
04:41:12 <Wooga> and sed is slow
04:47:37 * opdolio still isn't convinced by "you must either be a Platonist, or only use predicative arithmetic."
05:02:27 <ivanm> @tell sinelaw I'm afraid that my troubles have been for naught; if I want to have it such that an error is returned as soon as a single problem is found, then I can't return the generated list until they've all been generated; in this case, running dot multiple times is faster (more than about 10 input graphs and doing it all in one becomes unfeasible) :s
05:02:27 <lambdabot> Consider it noted.
05:10:57 <mjrosenb> how do i hide +++ when importing Control.Arrow?
05:11:16 <mjrosenb> hiding (+++) gives a syntax error
05:11:43 <dolio> hiding ((+++))
05:12:07 <mjrosenb> oh
05:12:10 <mjrosenb> *sigh*
05:12:51 <mjrosenb> why do i need a second pair of parens?
05:13:17 <dolio> Because the function is named (+++), not +++.
05:13:34 <dolio> +++ is how it looks infix.
05:13:51 <mjrosenb> yes, but according to the internet, you can say import Prelude hiding length
05:14:12 <mjrosenb> which would indicate that you do not need parens around the non-infix function
05:14:19 <dolio> If you had more things to hide, it'd look like: hiding (id, (+++), length)
05:14:26 <mjrosenb> and the non-infix function is (+++)
05:15:42 <dolio> Well, if that's valid, the difference is probably that it thinks "hiding (+++)" is introducing a parenthesized list of names, containing just +++.
05:18:31 <ivanm> mjrosenb: where does it say that on the internet?
05:19:08 <mjrosenb> ivanm: http://www.haskell.org/tutorial/modules.html
05:19:27 * mjrosenb has a tendency to trust URLs that look like that
05:21:58 <ivanm> bah, what would it know? :p
05:22:12 <ivanm> looks like either its out of date, or else ghc doesn't follow that part of the report anymore...
05:28:33 <jaspervdj> Hey, I'm having a Haddock problem here... can anyone see what is wrong with this definition? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16710#a16710
05:29:29 <jaspervdj> The arguments documentation seems "shifted" (so the wrong explanation appears next to the wrong argument)
05:29:49 <malcolmw> It is a known bug
05:32:28 <jaspervdj> malcolmw: okay, any known workaround?
05:33:46 <malcolmw> not that I know of
05:34:26 <jaspervdj> I'll try to find a way aroung it then
05:38:54 <malcolmw> actually, I can't find that bug on the haddock bug tracker.  Maybe it would be worth reporting it again.  http://trac.haskell.org/haddock/
05:39:29 <Veinor> that seems like a pretty major bug :/
05:42:01 <quicksilver> hmm we're +R again I see
05:42:05 <quicksilver> spammers were still at it?
05:42:18 <Loriel> Constant vigilance!
05:42:30 * quicksilver vigilates.
05:44:28 <fasta> quicksilver, what's +R?
05:44:46 <Veinor> can't talk unless you're registered with nickserv
05:44:53 <fasta> Google should imlement special character support some day.
05:45:00 <fasta> implement*
05:45:23 <Beelsebob> fasta: only people ID'd with nickserv can speak
05:45:52 <fasta> Does that actually add something?
05:46:13 <fasta> If you have a 100,000 size bot net, you can just register and then send a message.
05:46:47 <Twey> fasta: The particular attack that's affecting Freenode at the moment doesn't use registration.
05:46:58 <fasta> That's what I would do if I was in the spam business.
05:47:01 <Twey> It's actually rather harder than that
05:47:07 <Twey> Registration requires a valid email
05:47:13 <quicksilver> fasta: but it's fairly simple for freenode to disable resigstered accounts
05:47:20 <quicksilver> and disable creation of new registrations
05:47:21 <quicksilver> etc.
05:47:22 <fasta> Twey, since when?
05:47:25 <quicksilver> they have tools to fight that.
05:47:36 <Twey> And given that each connection effectively needs a unique nickname…
05:47:40 <Twey> Since about a year ago, I think
05:48:39 <fasta> quicksilver, if attackers then just register in some period X and post random copies of messages then it is also relatively hard to spot fakes.
05:49:11 <fasta> Even better is to just copy actual conversations in previously empty channels.
05:49:24 <fasta> Then there is no way to know that in fact they are all machines.
05:50:22 <fasta> I think a trust system is the only real solution in the end.
05:50:26 <dolio> That isn't what's actually happening, though.
05:50:50 <fasta> dolio, what is happening?
05:51:20 <dolio> People post links to websites that use javascript to connect to freenode and spam links to the site.
05:51:55 <Veinor> fasta: that would take large amounts of effort though
05:52:23 <mjrosenb> @hoogle (a -> b -> c) -> (d -> e -> f) -> (a,d) -> (b,e) -> (c,f)
05:52:23 <lambdabot> No results found
05:52:46 <fasta> Why can browsers do that in the first place?
05:52:47 <Veinor> @djinn (a -> b -> c) -> (d -> e -> f) -> (a,d) -> (b,e) -> (c,f)
05:52:48 <lambdabot> f a b (c, d) (e, f) = (a c e, b d f)
05:52:59 <Veinor> symbol collision
05:53:01 <Veinor> !
05:53:10 <Veinor> @pl \a b (c, d) (e, f) = (a c e, b d f)
05:53:15 <quicksilver> fasta: browsers can post to any port
05:53:15 <lambdabot> (line 1, column 20):
05:53:17 <lambdabot> unexpected "="
05:53:19 <lambdabot> expecting pattern or "->"
05:53:21 <Veinor> @pl \a b (c, d) (e, f) -> (a c e, b d f)
05:53:22 <fasta> Veinor, I mean is it by design or is it a bug?
05:53:23 <lambdabot> flip flip snd . (ap .) . flip flip fst . ((.) .) . flip flip snd . ((flip . ((flip . (ap .)) .)) .) . flip flip fst . ((flip . ((flip . ((.) .)) .)) .) . flip . (((.) . flip . (((.) . (,)) .)) .)
05:53:29 <quicksilver> fasta: (stupid) IRC servers ignore the HTTP shit that doesn't make sense to them
05:53:34 <Veinor> well there you go!
05:53:39 <quicksilver> fasta: and then obey the commands which come after it.
05:53:47 <mjrosenb> Veinor: i was looking for something like ***
05:54:28 <quicksilver> it's something like (uncurry *** uncurry) >>> uncurry  plus another curry, mjrosenb
05:54:30 <dolio> There also seems to be something going on where random clients will log into a channel, and send version requests to lots of users, causing certain clients to respond too much and get kicked off the network.
05:54:37 <quicksilver> I haven't quite got time to work out what.
05:54:41 <dolio> I'm not really sure how that propagates, though.
05:55:47 <Beelsebob> Veinor: that looks like a curry of one of the arrow functions
05:55:54 <mjrosenb> quicksilver: well better than the output of @pl
05:56:03 <Beelsebob> @pl \(a,b) (c,d) (e,f) -> (a c e, b d f)
05:56:06 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . flip flip snd . ((flip . ((flip . (ap .)) .)) .) . flip flip fst . ((flip . ((flip . ((.) .)) .)) .) . flip . (((.) . flip . (((.) . (,)) .
05:56:07 <lambdabot> )) .))
05:56:10 <mjrosenb> Beelsebob: like i said, i was looking for something like ***
05:56:48 <Veinor> and then there's the good old DCC SEND exploit
05:57:04 <Beelsebob> oh, I see
05:57:04 <Beelsebob> oh wait
05:57:04 <Beelsebob> it's ap in a BiApplicative
05:57:34 * Beelsebob wonders if BiApplicative exists
05:57:54 <Veinor> BiApplicatives don't exist, either you're Applicative or not.
05:57:56 <Veinor> :|
05:58:52 <Beelsebob> heh, not quite what I meant by BiApplicative, I meant a Binary Applicative, like Binary Functor
05:59:03 <fasta> I did read the code, but I don't understand how non-user initiated code can give rise to submitting a request. That's a bug, IMHO.
05:59:14 <Eduard_Munteanu> Hi.
05:59:32 <And[y]> hi edi :D
05:59:47 <Eduard_Munteanu> And[y], hey
06:00:23 <Zao> fasta: Why shouldn't automatically running code be able to perform asynchronous requests?
06:00:36 <Beelsebob> class f :: * -> * -> * => BiApplicative f where bap :: f (a -> b) (c -> d) -> f a c -> f b d; instance BiApplicative (,) where bap (f,g) (x y) = (f x, g y)
06:01:53 <fasta> Zao, the Java designers apparently believe that you need permission to make a socket connection already in 1995. You could ask them too.
06:02:32 <Zao> Rumor has it that Java /= JavaScript
06:02:44 <fasta> Zao, do you really think I don't know that?
06:03:25 <Zao> Not really, but it never hurts to point out for annoyance credit.
06:04:11 <fasta> Zao, right, it did build annoyance.
06:04:53 <fasta> Zao, anyway, I can turn anyone into a criminal with that default.
06:05:18 <Veinor> fasta: that speaks more to our laws than it does to computers
06:05:23 <fasta> Zao, that shows that either the laws are wrong or the computers.
06:05:27 <fasta> Veinor, right.
06:05:52 <Saizan> fasta: clicking on a link on irc and clicking on some button in a page linked on irc, where's the difference?
06:08:12 <fasta> Saizan, well, in this case it kind of breaks the expectation that you are only reading a webpage and not sending information, but otherwise your logic is sound.
06:10:24 * Beelsebob wonders if there are any Biapplicatives other than (,)
06:11:05 <Beelsebob> I guess (Maybe :. Either) would be one
06:11:41 <Loriel> @google (:.)
06:11:42 <lambdabot> No Result Found.
06:11:46 <Loriel> err. hoogle.
06:11:49 <Loriel> @hoogle (:.)
06:11:49 <lambdabot> No results found
06:12:26 <edwardk> Beelsebob: My question to you is, are there any instances of that that can't be just implemented with a couple of combinators like ap2 :: Applicative f => f (a -> b, c -> d) -> f (a,c) -> f (b,d)
06:12:54 * edwardk grumbles about the fact that the webchat seems to like to misauthenticate me somehow, so i can never know if i can talk =)
06:13:04 <Beelsebob> edwardk: oh, interesting question
06:13:24 <Beelsebob> Loriel: (:.) is type composition – so (Maybe :. Either) a b == Maybe (Either a b)
06:18:21 <dolio> @type (<*>) . fmap (uncurry (***))
06:18:22 <lambdabot> forall (f :: * -> *) b c b' c'. (Applicative f) => f (b -> c, b' -> c') -> f (b, b') -> f (c, c')
06:18:49 <Beelsebob> neatly done dolio
06:19:38 <Twey> Beelsebob: Not Maybe (Either a) b?
06:19:38 <Beelsebob> which I guess is revealing about Biapplicatives, they're actually Applicative Functor Arrows
06:20:05 <Beelsebob> Twey: oh right
06:20:13 <Beelsebob> should have been a (:. :. :.)
06:20:24 <Beelsebob> with some extra parens
06:20:36 <Beelsebob> Maybe ((:.) :. (:.)) Either
06:20:39 <dolio> Clearly :. automatically figures out the right way to compose things based on the kinds. :)
06:20:45 <Beelsebob> hehe
06:20:46 <Twey> Hehe.
06:21:02 <Twey> And telepathy :þ
06:21:09 * Beelsebob wonders who has boobs with star constalations instead of nipples
06:21:23 <Twey> I don't know, but I'd like to meet them.
06:21:38 <Beelsebob> haha
06:21:40 <Twey> Zandramas maybe.
06:22:06 * fasta recommends Beelsebob: /nick Beelseboob
06:22:33 <Beelsebob> that's the nick I use from UKC's servers
06:22:55 <fasta> @google UKC
06:22:56 <lambdabot> http://www.ukcdogs.com/
06:22:56 <lambdabot> Title: Redirecting...
06:23:09 <Beelsebob> @google university of Kent
06:23:11 <lambdabot> http://www.kent.ac.uk/
06:23:11 <lambdabot> Title: University of Kent - the UK's European university
06:24:14 <Twey> Hum… I think my ex is there
06:24:23 <fasta> Is there anyone who thinks the if then else syntax is a good one in Haskell? A block with let's say 3 or 4 nested ifs is hard to read.
06:24:42 <fasta> Twey, please, no pictures.
06:25:43 <Beelsebob> fasta: not at all – I'd love to see if/then/else replaced with a function
06:25:55 <edwardk> fasta: yes and no, its advantage is that it avoids a lot of parentheses in the common case.
06:26:06 <Saizan> i stick to guards most of the time
06:26:41 <edwardk> fasta: and if you want to chain them, just use the case () of () | ... -> ...; | ... _> ... idiom
06:26:46 <Beelsebob> edwardk: I'm not sure that's an advantage – then and else are more verbose than () and ()
06:27:03 <fasta> I think a flag like "OverrideIf" would be used a lot.
06:27:24 <Beelsebob> indeed
06:27:27 <fasta> edwardk, that is done with macros in Lisp.
06:28:02 <mjrosenb> ugh, this could be signifigantly less ugly
06:28:03 <edwardk> Beelsebob: the other question is, in true haskell style the args for if feel like they are in the wrong order anyways. you most commonly would want to partially apply it without the condition, like 'either'
06:28:35 <Beelsebob> edwardk: very true
06:29:01 <edwardk> we clearly need if then else sections. ;)
06:29:47 <Twey> edwardk: I prefer: case True of foo x -> bar; baz x -> quux; otherwise -> somethingElse
06:29:49 <Beelsebob> indeed
06:29:59 <edwardk> (if then x else y) => (\z -> if z then x else y), (if then else) => \x y z -> if x then y z), ...
06:30:09 <edwardk> er
06:30:12 <edwardk> you get the idea
06:30:25 <Twey> (y ?? n) p = if p then y else n
06:30:27 <Twey> &c.
06:30:57 <Twey> Haha, nice
06:31:25 <edwardk> fasta: yeah, in kata i had to give up pattern guards recently (at least for now), and am replacing them with a cond-like macro.
06:31:27 <fasta> ifC b f e | b = f e
06:31:27 <fasta>           | otherwise = e
06:31:58 <Twey> (y ?? _) True = y; (_ ?? n) False = n
06:32:01 <fasta> That's also something which happens quite often.
06:33:23 <edwardk> anyways i suppose the biggest sin of 'if then else' is that it has one more word than it would need if it was just a ternary operator ;)
06:33:36 <fasta> http://probabilistic-programming.org/wiki/NIPS*2008_Workshop/Schedule and then e.g. the Church language.
06:34:07 <fasta> That seems more interesting than the thousand dependently typed programming language.
06:34:34 <fasta> thousandth*
06:35:27 <edwardk> fasta: first time stumbling across church?
06:36:18 <fasta> edwardk, what do you mean? It is not as if probabilistic programming languages are in wide use.
06:37:15 <fasta> edwardk, I read about an axiomatic complete and consistent semantics of a first order probabilistic language. Now, THAT, was interesting.
06:38:24 <edwardk> fasta: never said it wasn't interesting =)
06:38:53 <fasta> edwardk, but do you know anything about Church then?
06:39:04 <fasta> edwardk, (the language, obviously)
06:39:39 <edwardk> fasta: mostly just stuff i've read on http://projects.csail.mit.edu/church/wiki/Church
06:41:35 <edwardk> fasta: beyond that, i'm rather comfortable with MCMC, i've been poking at the haskell bayes compiler with a statistician friend of mine for a while now
06:43:37 <edwardk> fasta: i've been plodding away in my downtime, trying to build a good monad/applicative for doing mcmc models in haskell
06:43:59 <Twey> fasta: Thousandth dependently-typed programming language?  What?  :þ
06:44:03 * Twey counts… two?
06:44:36 <fasta> Twey, every paper describes a language.
06:44:37 <Botje> it's 1000 in basis sqrt(sqrt(2))
06:44:45 <Twey> Heh.
06:44:56 <Twey> It's not a programming language unless you can program in it.
06:45:04 <Twey> Which means it needs a compiler.  :þ
06:45:14 <Twey> (or interpreter, hardware or software)
06:45:54 <edwardk> fasta: did you see oleg and cc shan's paper on doing probabalistic programming in ocaml using delimited continuations?
06:46:02 <Twey> Anything else is just a formal language.
06:46:12 <IceDane> What topics would I have to be pretty clear on to write a relatively simple irc bot? Just monads and the basic core language?
06:46:30 <fasta> edwardk, I have not read it. I think I heard about it.
06:46:48 <edwardk> IceDane: pretty much, maybe a little bit of how to use a socket, etc. i think there is a tutorial on how to learn haskell by writing an irc bot, actually.
06:47:25 <edwardk> IceDane: http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
06:47:34 <IceDane> Holy hell, that's just awesome.
06:47:42 <edwardk> IceDane: glad i could help =)
06:47:45 <IceDane> thanks.+
06:48:11 <fasta> IceDane, that describes a very Haskelly way to do it. xmonad is structured in the exact same way.
06:49:00 <IceDane> Sweet. The projects in RWH are just too uninteresting. This should be more fun
06:49:12 <Twey> To follow that well, you need to understand type synonyms, basic monads, and have a vague grasp of how to use monad transformers
06:50:26 <fasta> IceDane, why not just try to write what you actually find interesting?
06:50:56 <fasta> (It sounds like the IRC bot is a compromise. )
06:51:01 <edwardk> fasta: sounds like he finds the prospect of writing an irc bot interesting ;)
06:51:07 <Twey> IRC bots are interesting :<
06:52:25 <domor> @pl sqr a = a * a
06:52:25 <lambdabot> sqr = join (*)
06:52:55 <IceDane> Yeah, I like writing irc bots. And fasta: I have written a few things on my own, but unless it's something that isn't abundantly ubiquitous, I won't bother writing it. There are many ircbots, obviously, but what functionality they have varies
06:55:15 <Twey> Indeed
07:02:59 <gspr> Isn't a setup.hs that only contains "import Distribution.Simple" supposed to recognize the makefile command?
07:03:49 * mjrosenb wonders how good @pl is
07:05:20 <edwardk> mjrosenb: its pretty good actually
07:05:44 <mjrosenb> @pl inserts x l = zipWith (++) (inits l) (map (x:) (tails l))
07:05:44 <lambdabot> inserts = ap (zipWith (++) . inits) . (. tails) . map . (:)
07:13:50 <Raevel> mjrosenb: it is very good at times, and very terrible at other times
07:19:04 <Botje> gspr: no, you still need a main = ...
07:19:14 <Botje> look at existing setup.hs scripts
07:21:35 <gspr> Botje: Hehe, I'm sorry, it's there. This is not my program, but a library that needs to be built with the makefile option, yet I am told by Setup.hs that makefile is not a recognized option
07:24:17 <Botje> oh. no experience with that, i'm afraid
07:24:37 <edwardk> @type ap (zipWith (++) <$> inits) `fmap` fmap tails `fmap` fmap `fmap` (:)
07:24:38 <lambdabot> forall a. a -> [[a]] -> [[[a]]]
07:27:00 <aavogt> @unpl ap (zipWith (++) <$> inits) `fmap` fmap tails `fmap` fmap `fmap` (:)
07:27:01 <lambdabot> (fmap (fmap (fmap (\ e -> ((zipWith (++)) <$> inits) >>= \ b -> e >>= \ a -> return (b a)) (fmap tails)) fmap) ((:)))
07:27:14 <aavogt> @@ do unpl ap (zipWith (++) <$> inits) `fmap` fmap tails `fmap` fmap `fmap` (:)
07:27:15 <lambdabot>  do unpl ap (zipWith (++) <$> inits) `fmap` fmap tails `fmap` fmap `fmap` (:)
07:29:46 <edwardk> @. do unpl ap (zipWith (++) <$> inits) `fmap` fmap tails `fmap` fmap `fmap` (:)
07:29:46 <lambdabot> (fmap (fmap (fmap (\ e -> do { b <- ((zipWith (++)) <$> inits); a <- e; return (b a)}) (fmap tails)) fmap) ((:)))
07:30:13 <edwardk> much clearer now
07:33:31 <mjrosenb> hrmm, my error checking seems to be far too slow
07:33:55 <mjrosenb> then again i *know* that some of these functions take exponentially longer than they should
07:36:49 <Veinor> @type fmap fmap
07:36:50 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
07:36:52 <Veinor> @type fmap fmap fmap
07:36:54 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
07:37:14 <Veinor> @type fmap succ (+)
07:37:16 <lambdabot> forall a. (Enum (a -> a), Num a) => a -> a -> a
07:37:23 <Veinor> > fmap succ (+) 8 9
07:37:25 <lambdabot>   No instance for (GHC.Enum.Enum (a -> a))
07:37:25 <lambdabot>    arising from a use of `GHC.Enum...
07:37:31 <Veinor> oh, yeah.
07:37:32 <Veinor> :(
07:37:45 <lispy> Enum (a -> a), may be hard to satisfy
07:38:10 <lispy> :t liftM2 (+) succ
07:38:11 <lambdabot> forall a1. (Num a1, Enum a1) => (a1 -> a1) -> a1 -> a1
07:39:04 <aep> McManiaC: yes, i have ;)
07:39:11 <Veinor> lispy: well... you can write an Enum instance for Int -> Int :D
07:39:25 <Veinor> for that matter, Bounded a => Enum (a -> a)
07:39:47 <lispy> Veinor: cool
07:40:04 <Veinor> wait.
07:40:06 <Veinor> no you can't :/
07:40:19 <Veinor> wait yes you can, only since Int is bounded
07:42:11 <Veinor> you can enumerate Bounded a, Enum b => a -> b
07:45:52 <mreh> I've got a function inside a record structure that works on that record structure
07:46:16 <mreh> the type of the accessor is: accessor :: Record -> Record -> a -> b
07:46:26 <mreh> it's pretty ugly
07:47:03 <mreh> am I thinking too much like a Java programmer?
07:47:07 <domor> hmm, I'm looking for something like zipWith, but I want to apply my function on every combination of two lists
07:47:20 <quicksilver> domor: liftM2
07:47:20 <mreh> domor: how so exactly?
07:47:34 <quicksilver> > liftM2 (*) [1,2,3] [4,5,6]
07:47:35 <Veinor> :t liftM2
07:47:36 <lambdabot>   [4,5,6,8,10,12,12,15,18]
07:47:36 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
07:47:57 <domor> as in (???) myfn [1,2] [3,4] would myfn 1 3, myfn 1 4..
07:48:10 <quicksilver> domor: liftM2
07:48:16 <domor> yup thanks
07:48:17 <mreh> domor: use the list monad, quicksilver has just shown you how
07:48:34 <mreh> or use a list comprehension
07:48:40 <Veinor> @do liftM2 f
07:48:40 <lambdabot> liftM2 f
07:48:58 <Veinor> > do {x <- [1,2,3]; y <- [4,5,6]; return x * y}
07:48:59 <lambdabot>   No instance for (GHC.Num.Num [b])
07:48:59 <lambdabot>    arising from the literal `4' at <inter...
07:49:04 <domor> actually I'm rewriting a list comprehension to use stream fusion
07:49:43 <Veinor> > do {x <- [1,2,3]; y <- [4,5,6]; return $ x * y}
07:49:45 <lambdabot>   [4,5,6,8,10,12,12,15,18]
07:49:56 <mreh> @src liftM2
07:49:56 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
07:50:16 <Veinor> yep.
07:50:25 <mreh> list monad is one of the hardest to get your head around
07:50:30 <Veinor> @undo do { x1 <- m1; x2 <- m2; return (f x1 x2) }
07:50:31 <lambdabot> m1 >>= \ x1 -> m2 >>= \ x2 -> return (f x1 x2)
07:51:38 <Veinor> @ @do @undo do { x1 <- m1; x2 <- m2; return (f x1 x2) }
07:51:42 <Veinor> @@ @do @undo do { x1 <- m1; x2 <- m2; return (f x1 x2) }
07:51:42 <lambdabot>  do { x1 <- m1; x2 <- m2; return (f x1 x2)}
07:51:52 <mreh> uuhh
07:51:52 <Veinor> :D
07:52:14 <mreh> do do do do the monad boogie
07:52:27 <Veinor> do be do be do
07:53:04 <mjrosenb> i have something that looks like [() | _ <- foo bar, stuff] ... [() | _ <- foo bar, other stuff]
07:53:23 <mjrosenb> is there any way to avoid computing everything multiple times?
07:53:34 <quicksilver> let x = foo bar
07:53:39 <quicksilver> somewhere outside the scope of those
07:53:49 <mjrosenb> rather
07:54:01 * mjrosenb looks at his code again
07:54:41 <mjrosenb> right, i have that
07:54:48 <mjrosenb> and
07:55:29 <mjrosenb> i have something that looks like [() | x <- foo bar, _ <- baz x,stuff] ... [() | x <- foo bar, _ <- baz x,  other stuff]
07:55:51 <mjrosenb> actually not quite
07:55:58 <mjrosenb> grr
07:56:08 <mjrosenb> this expression is horrible
07:56:21 <mjrosenb> p +++ q = λstr → ([((x,y),t, n + m) | (x,t',n) ← fst $ p str, (y,t,m) ← fst $ q t'],
07:56:24 <mjrosenb>                  maximum $ snd (p str) : [init + (snd $ q t') | (x,t',init) ← fst $ p str])
07:56:39 <idnar> yuck
07:57:02 <jmcarthur> o_O
07:57:26 <Twey> Truly
07:57:46 <quicksilver> so, just let pstr = p str in .... ?
07:57:52 <quicksilver> and qt' = q t'
07:57:58 <quicksilver> not quite sure what your question is.
07:58:15 <mjrosenb> yes, but q still gets computed multiple times
07:58:22 <jmcarthur> i doubt that
07:58:50 <mjrosenb> rather, q gets called more than it should
07:59:00 <jmcarthur> not if you use let like quicksilver suggested
07:59:03 <jmcarthur> or where
07:59:18 <mjrosenb> let qt = q t'
07:59:23 <mjrosenb> where should that go?
07:59:49 <jmcarthur> you would say p +++ q = let qt = q t' in <rest of expression>
07:59:51 <mjrosenb> the two different t's are bound in two different scopes
08:00:00 <jmcarthur> oh
08:00:13 <jmcarthur> then it's not computing the same thing anyway, is it?
08:00:47 <quicksilver> well, "q" will still only be computed once
08:00:52 <quicksilver> (unless "q" is typeclass polymorphic)
08:01:06 <mjrosenb> but it is, since it is being bound to the same rhs in each instance
08:01:06 <DekuNut> I'm reading up on haskell standard libraries, and have a question or two about hGetContents
08:01:16 <jmcarthur> quicksilver: q is a parameter, i think it should be monomorphic
08:01:25 <Twey> DekuNut: It's bad.  Don't use it.  :þ
08:01:27 <quicksilver> probably, yes
08:01:29 <mjrosenb> quicksilver: it gets called more than it should, not computed.
08:01:35 <DekuNut> Twey, Oh, how come?
08:01:37 <jmcarthur> well, in the absense of higher ranked types
08:01:37 * quicksilver nods
08:02:01 <Twey> DekuNut: It's unsafe
08:02:08 <Twey> And doesn't allow you to handle errors
08:02:13 <jmcarthur> mjrosenb: what exactly is computed more than once?
08:02:30 <DekuNut> Twey, ah ok, thanks for the tip
08:02:46 <Twey> DekuNut: Iteratees are the future.  ☺
08:02:55 <mjrosenb> jmcarthur: q t' will be computed twice, once in the first list comprehension, and once in the second
08:02:58 <DekuNut> The question I had however was about how it works, it returns a lazy string right, and as you read the string the file is read into the buffer
08:03:20 <jmcarthur> mjrosenb: but those are two different computations...
08:03:24 <DekuNut> Seeing as the function has already returned, I can't think of any way in straight haskell to edit the list like that as it's read
08:03:52 <DekuNut> So, just curious, if I were to try and write a similar function in C, would I have access to the string I returned if I wanted? Such that I could modify it while it's being used?
08:03:56 <jmcarthur> oh i think i see
08:04:10 <DekuNut> Or would replicating that function be impossible outside of built in to the standard library?
08:04:36 <lispy> are we talking about lazyIO?
08:04:47 <jmcarthur> mjrosenb: i bet if you try doing this without the list comprehensions something will become more obvious
08:05:28 <bd_> DekuNut: you'd need to use unsafeInterleaveIO to load it in chunks
08:05:28 <pikhq> DekuNut: The only way to do that in C would be explicit usage of thunks.
08:05:50 <quicksilver> DekuNut: it's an evil evil function.
08:05:53 <quicksilver> it's not "laziness"
08:05:59 <quicksilver> (although people call it that I agree)
08:06:09 <quicksilver> it's a spooky interleaving of IO code with pure code
08:06:12 <DekuNut> Yeah someone already mentioned it's evilness, I won't use it, I'm just curious as to how it works
08:06:16 <quicksilver> a generalisation of the idea of thunks
08:06:18 <DekuNut> I'll check out bd_s function
08:06:29 <quicksilver> pure thunks, the idea is that all they can do is evaluate some expression on demand
08:06:40 <quicksilver> whereas this has a 'special' kind of thunk that can actually do some IO on demand
08:07:18 <bd_> DekuNut: http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-IO-Handle-Text.html#hGetContents  implementation here, look at lazyRead
08:07:19 <mjrosenb> jmcarthur: yes,jmcarthur i would not be suprised, but i am using them because they are concise :(
08:07:20 <DekuNut> I don't see why that's special?
08:07:23 <DekuNut> Thanks bd_
08:08:06 <DekuNut> Oh wait, so this IS implemented in straight haskell, no compiler magic?
08:08:32 <pikhq> The unsafePerformIO is magic.
08:08:44 <bd_> and evil
08:08:47 <int-e> DekuNut: that depends on the compiler.
08:09:24 <bd_> http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-IO.html#unsafeInterleaveIO <-- look, magic! :)
08:09:31 <int-e> From a compiler-neutral point of view, unsafePerformIO and unsafeInterleaveIO are purely magical.
08:10:21 <int-e> If you implement IO as state-token-passing functions, they can be implemented in Haskell (more or less. and ghc goes one step further and completely eliminates the tokens in the end.)
08:10:45 <DekuNut> I'll have to checkout state-token-passing functions in a minute
08:11:03 <DekuNut> I'm just reading these functions real quick, I think I get the idea though
08:11:11 <lispy> Heh, I love the implicit doubt in this statement, "We believe that INLINE on unsafeInterleaveIO is safe,..."
08:11:29 <int-e> note I made up that term on the spot. what I mean is  IO a = World -> (World, a)
08:12:09 <pikhq> int-e: The elimination of the tokens is a mere optimisation on GHC's part.
08:13:02 <bd_> In the case of GHC it's actually newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
08:13:16 <int-e> pikhq: but it means that they are magical :)
08:13:17 <bd_> where State# is magic, and (# #) is magic :)
08:13:42 <pikhq> Mmm, strictness.
08:13:54 <Veinor> what does (# #) mean?
08:13:59 <int-e> (# #) is less magical - it implements tuple returns.
08:14:16 <int-e> "unboxed tuple" but they can only appear as return values of functions
08:14:27 <int-e> @kind (->)
08:14:28 <lambdabot> ?? -> ? -> *
08:14:50 <Veinor> what is the difference between that and a regular tuple?
08:15:01 <int-e> ? = ?? or (#), ?? = * or #; (#) is the kind of unboxed tuples, # the kind of unboxed types
08:15:14 <DekuNut> I only just learnt about unboxed types recently :o, what was it. ? -> (??/(#)   where ?? -> (#/*)
08:15:15 <int-e> Veinor: no tuple is actually constructed at runtime.
08:15:25 <Veinor> also, if i wanted to tell someone who's just learning, could I use int-e's simplification of IO a = World -> (World, a)?
08:15:29 <DekuNut> Oh, thanks int-e
08:16:05 <DekuNut> I'm a little confused about some of the functions here relating to hGetContents
08:16:09 <int-e> Veinor: I wouldn't. I would say that  IO a  is a description of IO operations for computing a value of type a.
08:16:23 <DekuNut> Why is the type of: returnn (handle_, "")   IO String?
08:16:49 <paper_cc> DekuNut: it shouldn't be
08:16:50 <welterde> hi :)
08:16:54 <int-e> Veinor: And it's the run time system's responsibility to take that description and run it. So the Haskell code remains pure - all IO is done by the RTS.
08:17:04 <paper_cc> DekuNut: maybe it is IO (Handle, String) ?
08:17:15 <paper_cc> welterde: hello
08:17:24 <DekuNut> lazyRead :: Handle -> IO String     -- this is the type of the function
08:17:31 <Veinor> ah.
08:17:33 <Twey> DekuNut: Depends on the definition of ‘returnn’
08:17:41 <DekuNut> return, the extra n was my mistake
08:17:44 <int-e> Veinor: (the good thing about that is that unsafePerformIO clearly can't exist *g*)
08:18:10 <Veinor> Haha
08:18:20 <Twey> DekuNut: Needs more code
08:18:30 <DekuNut> http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-IO-Handle-Text.html#lazyRead
08:18:43 <DekuNut> Hell, just look in hGetContents
08:18:45 <Veinor> someone find me the 'what X programmers think of Y' one where everybody thinks haskell programmers are Einstein
08:18:45 <DekuNut> It's the same there
08:18:49 <DekuNut> return (handle_{ haType=SemiClosedHandle}, xs )
08:18:53 * paper_cc looks there
08:19:01 <paper_cc> oh
08:19:26 <ehamberg> Veinor: http://axgle.github.com/images/haskell.jpg
08:19:32 <Veinor> \o/
08:19:40 <int-e> DekuNut: note that this is an argument to withHandle ...
08:20:08 <elly> I believe this is the original, fyi: http://i.imgur.com/1gF1j.jpg
08:20:20 <elly> it also has lisp on it :P
08:20:28 <DekuNut> int-e, ah, I'll go read the definition of withHandle and wantReadableHandle then
08:20:53 <paper_cc> DekuNut: yes, it should be the case that withHandle :: String -> Handle__ -> IO (Handle__, a) -> IO a
08:20:58 <Veinor> so haskell fans see lispers as... darwin?
08:21:11 <elly> apparently?
08:21:21 <elly> I guess as one of their spiritual predecessors
08:21:31 <Veinor> makes sense.
08:21:44 <int-e> DekuNut: which has type withHandle :: String -> Handle -> (Handle__ -> IO (Handle__, a)) -> IO a  -- the pair has type (Handle__, String), a is String.
08:22:05 <int-e> DekuNut: it's defined in GHC.IO.Handle.Internals
08:22:55 <DekuNut> Ah ok I see
08:23:06 <Veinor> so wait, why do lisp hackers see C as putin?
08:23:08 <DekuNut> Just tracking it down now
08:23:26 <ehamberg> Veinor: because they are crazy, hardcore bastards.
08:23:38 <elly> Veinor: it's not clear
08:23:52 <DekuNut> int-e, I can't find GHC.IO.Handle.Internals in the GHC docks?
08:23:54 <elly> I write the majority of my code in scheme, but I also know C pretty well and like using it at times :P
08:24:07 <DekuNut> docks... rofl, docs even
08:24:58 <int-e> DekuNut: http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-IO-Handle-Internals.html ... got there by editing the URL
08:25:07 <DekuNut> I did try that, I swear rofl
08:25:15 <int-e> note the line saying -- #hide
08:25:41 <DekuNut> Ah
08:25:54 <DekuNut> The forbidden docs
08:27:22 <execve> Is there any issues with building ghc/linux-x86_64 base libs as shared with -fPIC? The user guide says "we do not do that at the moment".
08:29:11 <execve> Is it impossible with current ghc, or just nobody cares?
08:29:40 <DekuNut> Right, just to confirm I understand then
08:29:59 <Veinor> execve: ... try and see?
08:30:30 <execve> Veinor: want to know anything about before diving into it )
08:30:43 <DekuNut> hGetContents throws the filehandle into lazyRead, which uses unsafeInterleaveIO to force the file to be read lazily, withHandle doing the dirtywork
08:31:38 <DekuNut> unsafeInterleaveIO is the compiler magic part
08:32:07 <zygoloid> unsafeInterleaveIO means, "defer this IO until the value it produces is demanded"
08:32:24 <DekuNut> nah I know
08:32:38 <DekuNut> I'm just making sure I understand roughly what happens with hGetContents
08:34:25 <zygoloid> so when the result of lazyRead is demanded, it involes lazyReadBuffered which reads a chunk of data from the file, then queues up another lazyRead for when that chunk is exhausted
08:37:32 <quicksilver> int-e: If you implement IO as state-token-passing functions, [unsafePerformIO] can be implemented in Haskell
08:37:35 <MissPiggy> fasta?
08:37:37 <quicksilver> int-e: is that really true?
08:37:52 <quicksilver> int-e: sure you also need some kind of evaluation order guarantees which functions don't have
08:37:55 <quicksilver> (to make sense of IO)
08:37:57 <fasta> MissPiggy, ?
08:38:17 <MissPiggy> fasta are you sure that partial derivative of a contour is nonsense?
08:38:36 <fasta> MissPiggy, no, that's why I asked.
08:38:49 <int-e> quicksilver: sorry, does that make my implication wrong? you have to deal with those when you implement IO that way.
08:38:57 <MissPiggy> I got this idea that a contour just a path and the partial derivative like the normal at that point? sort of like a gradient field
08:39:18 <Cale> quicksilver: Except that you need some impure functions to get started that way
08:39:18 <quicksilver> int-e: well it's not really "in Haskell" then
08:39:31 <quicksilver> int-e: it's more "in a language which looks like haskell but has some evaluation order guarantees"
08:39:44 <fasta> MissPiggy, that's not a complete definition, though.
08:40:02 <fasta> MissPiggy, it can only be a function of its length then and it has to begin somewhere.
08:40:09 <int-e> quicksilver: okay.
08:40:15 <MissPiggy> fasta, oh I see what you mean
08:40:43 <quicksilver> int-e: "...and evaluation has side-effets too..."
08:40:49 <fasta> MissPiggy, anyway, having to guess what symbols mean is what makes me classify papers which do this as garbage.
08:40:55 <quicksilver> so it's an impure, strict, haskell
08:40:59 <Cale> quicksilver: WRT the order issue, I think all you really need is the guarantee that it won't evaluate underneath an as-yet-unapplied lambda.
08:40:59 <quicksilver> you could call it "ML"
08:41:00 * quicksilver ducks
08:41:09 <Alpounet> haha
08:41:13 <Cale> You don't really need it to be strict.
08:41:14 <int-e> quicksilver: it's hard to go against data dependencies, so those take care of a lot.
08:41:17 <MissPiggy> fasta, I don't know what half the symbols I use every day mean :(
08:41:32 <int-e> quicksilver: but I believe you know that.
08:41:36 * quicksilver nods
08:41:46 <Cale> Knowledge is a succession of ever-improving lies.
08:41:47 <fasta> MissPiggy, I happen to believe that I understand everything I use.
08:42:49 <dolio> What guarantees on evaluation order do you need?
08:43:58 <quicksilver> dolio: whatever it takes to ensure that putStrLn "hello" happens before the next thing.
08:44:47 <dolio> So, the guarantee is that the magic impure functions are strict in the token?
08:45:35 <dolio> I'm not sure that's ML.
08:46:34 <quicksilver> well, in ML "case putStrLn "hello" of () -> ...."
08:46:39 <Cale> You just need that the evaluator doesn't evaluate the body of a lambda before it's been applied to its parameter
08:46:42 <quicksilver> will actually execute the putStrLn wouldn't it?
08:46:56 <quicksilver> (ML-but-with-haskell-syntax, obviously)
08:47:10 <dolio> ML doesn't do world token passing.
08:47:13 <Cale> yeah, but that's different, because you can not has RealWorld token.
08:47:25 <quicksilver> no, and there is no world token there
08:47:32 <quicksilver> just evaluating a procedure to ()
08:47:51 <Cale> putStrLn still wouldn't print random strings before you apply it :)
08:49:39 <dolio> IO implemented as token passing makes everything look like: case foo tok of tok' -> case bar tok' of tok'' -> ...
08:50:10 <dolio> Or 'case bar (foo tok) of tok'' -> ...'.
08:50:47 <mjrosenb> *Parse> full . tok $ "if (((((((x)))))))) then 2 else 3"
08:50:47 <mjrosenb> (Killed
08:50:52 <mjrosenb> well that is a first
08:51:00 <quicksilver> case unIO (putStrLn "hello" W#) of W# -> ....
08:51:16 <quicksilver> case unIO (putStrLn "hello" W#) of (W#,()) -> .... rather
08:51:48 <dolio> And all you need for that to work out in the right order is for those functions to demand the tokens eagerly. You don't need any overall guarantee on function evaluation.
08:51:51 <quicksilver> mjrosenb: I once wrote a parser which went double exponential on nested parens ;)
08:51:58 <quicksilver> mjrosenb: perhaps it's a rite of passage?
08:52:13 <quicksilver> not a very successful rite, if so, because I can't remember what I did to fix it.
08:53:30 <mjrosenb> quicksilver: i'm more confused about ghc
08:53:48 <mjrosenb> quicksilver: normally it does something a bit more gracefully than that.
08:55:01 <Botje> mjrosenb: i think that's your OS's out of memory killer
08:55:55 <mreh> is there an easier way of nesting lots of if then elses?
08:56:00 <mreh> a more readable way
08:56:02 <mjrosenb> Botje: possibly
08:56:04 <quicksilver> mreh: normally, yes.
08:56:15 <mreh> quicksilver: boolean guards or something
08:56:22 <quicksilver> mreh: normally using guards or boolean combinators or maybe combinators
08:56:26 <quicksilver> depends on the exact code
08:56:46 <Berengal> mreh: case () of () | guards guards! = ...
08:56:48 <mjrosenb> or a case on a tuple of booleans
08:57:28 <mreh> vendor buy the bank some guards!
08:58:13 <mreh> cool, so I can bind the result to a pattern in a case
08:58:27 <Berengal> Or just a regular case on some patterns, or call a function, or... there are many ways.
08:59:19 <Berengal> I tend to abuse lazy evaluation and the ability to use guards on simple values in local definitions
08:59:53 <Berengal> (You can use guards on top-level definitions as well, but they're useless in non-function values)
09:00:18 <mreh> ?!@*~ :(
09:00:18 <lambdabot> Unknown command, try @list
09:00:35 <quicksilver> universeconsistent | 1 > 0 = "Yes" | otherwise = "No"
09:01:06 * Twey chuckles.
09:01:11 <mreh> you can only do that kind of thing on the top level
09:01:12 <Twey> Can't be too careful
09:01:39 <mreh> in God's Universe.hs module
09:01:57 <Berengal> Well, I guess they could be useful when you have cheater-constants... foo | ghcVersion > 6.10 = "Foo" | otherwise = "foo"
09:02:20 <mreh> ooh, hack-a-licious
09:02:35 <mreh> > ghcVersion
09:02:36 <lambdabot>   Not in scope: `ghcVersion'
09:02:40 <quicksilver> Berengal: yeah or evil top-level unsafePerformIO $ readFile stuff
09:03:07 <Berengal> quicksilver: That's not just cheating, that's outright malicious
09:03:57 <mreh> how can I define something functionally but have the value saved once computed?
09:04:01 <mreh> memoization?
09:04:11 <mreh> is that what it's called?
09:04:33 <Berengal> mreh: memoization is just remembering the result of previous computation, by whatever means, so yeah
09:05:14 <jmcarthur> mreh: within a function definition, use let. at the top level, look into memoization. this would be good to check out for that, but is not the only way: http://hackage.haskell.org/package/data-memocombinators
09:05:16 <mreh> can I do it implicitly in haskell or does it have to be done explicitly with maps
09:05:38 <Berengal> Are memocombinators better than MemoTrie?
09:05:49 <jmcarthur> Berengal: i only have experience with the former
09:05:57 <Berengal> I like MemoTrie for only having one function: memo
09:06:19 <jmcarthur> i do also like tries
09:06:29 <jmcarthur> been meaning to give memotrie a shot
09:06:44 <Berengal> I like how it dispatches on the type to build the combinators automagically
09:06:54 <jmcarthur> Berengal: MemoTrie appears to have more than one memo function, just like data-memocombinators
09:07:04 <jmcarthur> memo, memo1, memo2...
09:07:20 <jmcarthur> *memo, memo2, memo3
09:07:25 <mreh> If I have a function on the top level that computes a certain scale for a certain key, can I just then define it and just be sure that it does the memoization when called multiple times?
09:07:55 <jmcarthur> mreh: just google it. there are good guides on the wiki and good libraries on hackage
09:08:03 <mreh> k
09:08:37 <Berengal> jmcarthur: I thought it dispatched on functions as well...
09:09:02 <jmcarthur> Berengal: i don't see a HasTrie instance for functions :\
09:09:24 <jmcarthur> which i assume is the necessary part for that
09:09:43 <Berengal> I wonder why not...
09:10:05 <Berengal> It does some crazy enumeration of the domains, which may be why
09:10:05 <jmcarthur> Berengal: you can ask. conal just stepped in
09:10:43 <Berengal> conal: Why is there no instance for functions in MemoTrie?
09:11:27 <conal> Berengal: because i don't know an isomorphism for them.  ((a->b) -> c) =~ ??
09:12:05 <conal> Berengal: tries are based on isomorphisms like ((a,b)->c) =~ (a -> (b -> c))
09:12:50 <conal> oh.  as memo tries.
09:12:51 <conal> hm
09:13:00 <conal> that's a good idea.
09:13:06 <Berengal> Yeah, I meant for multiple arguments
09:13:11 <jmcarthur> :D
09:13:30 <conal> Berengal: multiple arguments?
09:13:51 * mjrosenb stabs tuple syntax
09:13:54 <mjrosenb> "whoops"
09:14:04 <Jonno_FTW> > 1/42
09:14:05 <lambdabot>   2.3809523809523808e-2
09:14:48 <Berengal> conal: Currently the memo function only works for single-argument functions. There's memo2 and memo3 which memoize the second and third argument as well, for such functions
09:15:18 <Berengal> conal: And according to the source, it looks like it's just about applying mup enough times
09:15:30 <mreh> :t fib
09:15:31 <lambdabot> Not in scope: `fib'
09:15:34 <conal> Berengal: yeah
09:15:50 <jmcarthur> data (a -> b) :-> x = ?
09:16:07 <mreh> scanl1 (+) [1..] !! 10
09:16:13 <mreh> > scanl1 (+) [1..] !! 10
09:16:15 <lambdabot>   66
09:16:22 <Berengal> Ah, well, you might not want to memoize all arguments...
09:16:32 <Berengal> I guess that's a point
09:17:56 <conal> jmcarthur: .. = FunctionTrie ((a :->: b) :->: c)
09:18:29 <conal> jmcarthur: an unfortunate catch is that MemoTrie uses assoc'd data families instead of assoc'd type families.  i couldn't get the latter to work.
09:18:49 <jfischoff> quick newb question, what's the haskell equivalent of c++'s "const int a = 3"? I want to use the const in case pattern match...
09:18:57 <conal> jmcarthur: if assoc'd type families, then ((a :->: b) :->: c) would have a chance of being defined.
09:19:09 <jmcarthur> yeah that would be nice
09:19:12 <conal> jmcarthur: specifically, the outer/second :->:
09:19:16 <jmcarthur> conal: what was the problem with assoc type families?
09:19:24 <Berengal> jfischoff: a = 3 is a constant
09:19:30 <conal> jmcarthur: non-surjectivity
09:19:43 <Berengal> jfischoff: But you can't pattern match on variables. You'll just shadow the old variable
09:19:53 <conal> jmcarthur: which often defeats type-inference
09:20:07 <jfischoff> Berengal: right, so how do I get around that? #define the const?
09:20:21 <Berengal> jfischoff: define a datatype with enums in it
09:20:28 <Jonno_FTW> how can i make errors be exceptions ignored in a map?
09:20:33 <jfischoff> Berengal: thanks!
09:20:47 <Alpounet> anyone here has used the vc-darcs emacs mode ?
09:20:48 <MissPiggy> conal is function level programming lambda free programming?
09:20:49 <Jonno_FTW> *exceptions be ignored
09:21:10 <Berengal> jfischoff: And a converter function, if you need that. toStatus 0 = Canceled; toStatus 1 = InProgress and so on
09:21:20 <jmcarthur> that sounds like point free programming to me, MissPiggy
09:21:43 <conal> MissPiggy: almost, but not quite.  in *purely* function-level programming, there are no non-functions.
09:22:13 <conal> MissPiggy: so there is not \ x -> ... x ...  for non-function-typed
09:22:15 <conal> x
09:23:12 <conal> MissPiggy: if a language has no definable higher-order functions, then yes, function-level programming wouldn't have lambda.  as in backus's FP.
09:23:19 <jmcarthur> conal: how does using data families instead of type families make it surjective? or is it really a matter of making the non-surjectivity unimpactful on the type checker instead of making it surjective?
09:23:30 <mreh> pred 1
09:23:31 <mreh> > pred 1
09:23:33 <lambdabot>   0
09:23:43 <mreh> enumFromTo 1 (pred 1)
09:23:45 <mreh> > enumFromTo 1 (pred 1)
09:23:46 <lambdabot>   []
09:23:47 <Berengal> jmcarthur: data families are one to one, but type families can be many to one
09:24:18 <Berengal> jmcarthur: data instance Foo Int = NewConstructor, but type instance Foo Int = Int; type instance Foo Double = Int
09:24:23 <mreh> I need a way of enumerating all things in a cyclic enum...
09:24:27 <jmcarthur> Berengal: i just don't see how that's a problem here
09:24:29 <dolio> It's injectivity that you're concerned with, I think, not surjectivity.
09:24:39 <dolio> Data families just are injective, by fiat.
09:24:41 <conal> dolio: thanks.  that's it.
09:24:45 <jmcarthur> ah
09:24:50 <conal> jmcarthur: sorry.  brain fart.  injectivity.
09:24:58 <jmcarthur> conal: it happens :)
09:25:02 <conal> :)
09:25:07 <lysgaard> Hi, I've been searching around trying to find a decent image manipulation library in haskell, but can't seem to find any. What do you guys suggest?
09:25:44 <conal> lysgaard: what sort of functionality?
09:26:09 <Berengal> conal: Haskell has function and ADTs only, but aren't constructors isomorphic to functions that return destructors? Wouldn't this make Haskell pure function-level as well?
09:26:21 <Berengal> functions*
09:26:26 <lysgaard> conal: I need to load a PNG, crop and scale it, then save it as a hig compression jpeg
09:26:42 <lysgaard> conal: s/hig/high/
09:26:56 <conal> lysgaard: ah.  maybe the devIL wrapper by luqui.
09:27:16 <MissPiggy> conal, so the question is to define some n-ary function in variable (x,y,z,..) for example, Considering the (pointful) expressions as a tree with holes (variables) in them (which maybe the permutated and duplicated or even dropped) -- we need some set of combinators that will give a natural description of that tree without writing any variables down?
09:28:24 <quicksilver> Berengal: yes you can encode ADTs as functions. Isn't that called functionialization?
09:28:28 <aavogt> > cycle [minBound .. maxBound] :: [Bool] -- mreh
09:28:29 <lambdabot>   [False,True,False,True,False,True,False,True,False,True,False,True,False,Tr...
09:28:32 <lysgaard> conal: Hm, yeah, I'll have to implement my own crop and scale though?
09:28:33 <conal> Berengal: maybe so.  though probably not in the spirit of backus's use of "function-level" -- which i think is what MissPiggy is asking about.
09:28:35 <quicksilver> it's a serious compilation technique although not the one that GHC uses.
09:28:37 <jmcarthur> lysgaard: i've used the gd package for that kind of thing before
09:28:49 <jmcarthur> it's not beautiful, but it works
09:28:49 <quicksilver> IIRC neilm's supercompiler was going to do that.
09:28:57 <MoALTz> @type fromList
09:28:58 <lambdabot> forall a (m :: * -> *). (MonadRandom m) => [(a, Rational)] -> m a
09:29:06 <aavogt> though maybe leave out the cycle...
09:29:45 <mreh> aavogt: donkey penis, it's an unbounded class
09:29:56 <mreh> ah well, I'll just enumerate them by hand
09:30:16 <MoALTz> @type Set.fromList
09:30:16 <mreh> sometimes it's faster to write things about in a look-up table
09:30:17 <lambdabot> Couldn't find qualified module.
09:30:23 <MoALTz> @type Data.Set.fromList
09:30:25 <lambdabot> forall a. (Ord a) => [a] -> S.Set a
09:30:27 <aavogt> @src Enum
09:30:27 <lambdabot> class  Enum a   where
09:30:28 <lambdabot>     succ                     :: a -> a
09:30:28 <lambdabot>     pred                     :: a -> a
09:30:28 <lambdabot>     toEnum                   :: Int -> a
09:30:28 <lambdabot>     fromEnum                 :: a -> Int
09:30:29 <lambdabot> [3 @more lines]
09:30:49 <mreh> @ src Bounded
09:30:51 <lysgaard> jmcarthur: Is that a image library?
09:30:53 <mreh> @src Bounded
09:30:54 <lambdabot> class  Bounded a  where
09:30:54 <lambdabot>     minBound, maxBound :: a
09:30:58 <MoALTz> @type Data.Set.toList
09:30:59 <lambdabot> forall a. S.Set a -> [a]
09:31:09 <aavogt> how can you enumerate by hand an unbounded sequence?
09:31:10 <MissPiggy> conal so what is the purpose?
09:31:23 <jmcarthur> lysgaard: it does the things you need
09:31:32 <mreh> aavogt: It's not unbounded, it's a cycle
09:31:40 <jmcarthur> lysgaard: all in IO :(
09:31:44 <mreh> it doesn't implement Bounded is what I meant :)
09:32:13 <conal> MissPiggy: i don't think there's just one.
09:32:46 <lysgaard> jmcarthur: Hm.. I hate that there's no native crop or scale algorithms, kinda strange actually. What's the name of the gm package, link?
09:33:58 <jmcarthur> ?hackage gd
09:33:58 <lambdabot> http://hackage.haskell.org/package/gd
09:34:57 <lysgaard> jmcarthur: Man, I almost feel stupid every time i forget i can do that :P
09:35:09 <jmcarthur> lysgaard: heh
09:35:21 <aavogt> mreh: hmm, I don't think it's customary to have cyclic enum instances. It's probably just as convenient to have a regular Enum and Bounded, then add another case for cyclicSucc that checks vs maxBound (and likewise for pred)
09:35:25 <conal> MissPiggy: have you read backus's turing award lecture?
09:35:47 <MissPiggy> yes
09:36:08 <aavogt> or at least, that's how I think about it, mreh
09:36:14 <jmcarthur> ?hackage it-is-just-a-string-concatenation-and-does-not-even-check-to-make-sure-it-is-a-real-package
09:36:15 <lambdabot> http://hackage.haskell.org/package/it-is-just-a-string-concatenation-and-does-not-even-check-to-make-sure-it-is-a-real-package
09:36:54 <mreh> aavogt: that seems using bounded for something it wasn't meant for... but maybe I'm using Enum for something it wasn't meant for
09:38:23 <conal> MissPiggy: maybe it's time for a re-read.
09:38:24 <aavogt> I thought that it was  class Ord a => Enum a, but I guess not
09:38:45 <MissPiggy> :(
09:38:52 <edwardk> re: compile ADTs down to functions http://en.scientificcommons.org/43361893 was a nice read
09:39:03 <edwardk> er compiling
09:39:05 <aavogt> but cyclic enum instances can't play well with Ord, since you sort of assume    succ x > x
09:39:54 <edwardk> aavogt: if you're cyclic you probably aren't Ordered =)
09:41:18 <lysgaard> jmcarthur: Would you agree that it's almost embarresing that haskell has no simple image library for the most basic tasks that's not a binding
09:41:20 <temoto> When succ x <= x ?
09:41:26 <jmcarthur> lysgaard: yup
09:41:54 <jmcarthur> lysgaard: or at least embarassing that we don't at least have one with a more pure interface
09:42:11 <zygoloid> ?hackage foo@some.evil.site.com
09:42:11 <lambdabot> http://hackage.haskell.org/package/foo@some.evil.site.com
09:42:13 <lysgaard> jmcarthur: Also, lazy functional programming goes hand in hand with image manipulation, maybe not the datatypes, but everything else
09:42:14 <kmc_> nothing wrong with bindings
09:42:26 <Eduard_Munteanu> edwardk, interesting stuff.
09:42:31 <edwardk> mreh: the use of Bounded for something cyclic doesn't seem all that kosher
09:42:49 <temoto> kmc_ +1
09:43:09 * kmc_ `succ`
09:43:20 <kmc_> > 3 `succ`
09:43:21 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
09:43:25 <kmc_> > (3 `succ`)
09:43:26 <lambdabot>   4
09:43:29 <Eduard_Munteanu> Succ kmc_
09:43:38 <Eduard_Munteanu> For type-level kmc_ :P
09:43:40 <temoto> I didn't mean *that* :)
09:43:45 <kmc_> hehe
09:43:47 <aavogt> edwardk: it is convenient if your data have  deriving (Bounded,Enum)
09:43:57 <jmcarthur> lysgaard: yeah. check this out: http://www.vips.ecs.soton.ac.uk/index.php?title=VIPS
09:44:07 <xerox> > succ . "kmc" -- muahah.
09:44:09 <lambdabot>   "lnd"
09:44:23 <temoto> > succ . "omg"
09:44:25 <lambdabot>   "pnh"
09:44:33 <jmcarthur> lysgaard: vips/nip2 are lazy functional image manipulation
09:44:35 <kmc_> crazy superhaskell that if smoked would bring about world peace
09:44:35 <temoto> haha
09:44:38 <Alpounet> any emacs haskell-mode expert in here ?
09:44:40 <edwardk> aavogt: convenient, yes, though your other operations on, say, a cyclic group don't respect the ordering, so it is at best a pleasant fiction that is convenient
09:44:49 <temoto> "pnh" is russian for "fu"
09:45:08 <Eduard_Munteanu> rin?
09:45:16 <Eduard_Munteanu> Or how does that read?
09:45:36 <lysgaard> jmcarthur: Yeah
09:45:49 * lysgaard craves a lib for fp image processing
09:46:10 <MissPiggy> fp?
09:46:12 <temoto> Eduard_Munteanu, no, it's 3 letters just like fu are two: an acronym. "peh, ehn, ha"
09:46:16 <jmcarthur> lysgaard: apple's shake software also has a functional-feeling to it, although i don't know if it's actually implemented to be lazy in implementation
09:46:30 <Eduard_Munteanu> temoto, oh.
09:49:20 <conal> lysgaard: i wonder if you'd like a new Pan, together with rich import & export.
09:50:07 <gspr> What's a typical reason for a Setup.hs (using Cabal) to complain with "unrecognised command: makefile" when being told to run in makefile mode?
09:52:43 <Saizan> where did you find that command?
09:55:52 <gspr> Saizan: http://www.haskell.org/cabal/release/cabal-latest/doc/users-guide/builders.html#setup-makefile
09:56:13 <lysgaard> conal: New Pan?
09:56:24 <temoto> gspr, typically, you run S configure, S build, S install where S = Setup.hs
09:56:55 <conal> @where pan
09:56:56 <lambdabot> http://conal.net/Pan
09:58:12 <gspr> temoto: Yeah, I know, but as the cabal docs (linked above) talk about, there is also a "makefile mode", where a makefile is generated instead of using ghc's --make. As the docs state, this can be useful for example if you want to do parallell builds. Also, QtHaskell has so many modules that ghc --make easily consumed more than 4GB of memory while building it, so it simply must be run in makefile mode.
09:58:23 <gspr> (or aborted and restarted manually whenever all the RAM is gobbled up)
09:58:53 <conal> lysgaard: i'm working on a rewrite of Pan & Vertigo, for imagery & 3D, rendered on GPU. i wonder if that sort of thing would give you what you're looking for. maybe vast overkill.
09:59:24 <temoto> gspr, Setup.hs build doesn't use parallel building?
10:00:03 <gspr> temoto: Oh, maybe it does, I don't know. Could be. It's not important to be anyway, the main problem is the memory usage of ghc --make
10:00:27 <gspr> So I was just wondering if it is well-known that Setup.hs' makefile mode is broken
10:01:22 <temoto> gspr, do you happen to know if that memory overrun is a known bug in ghc?
10:01:43 <temoto> only the word 'known' is under question :)
10:02:31 <gspr> temoto: According to the people I've spoken to earlier, it's "well known" that --make gobbles up insane amounts of memory if there are many (hundreds and hundreds) of modules to compile. This is the case of QtHaskell.
10:02:49 <benmachine> is this actually that surprising :P
10:03:10 <temoto> Well i don't think it should consume 4 gigs of memory.
10:03:13 <gspr> temoto: Its docs recommend using "makefile mode"
10:03:16 <temoto> so yes, surprising.
10:03:30 <temoto> gspr, i see now, thanks.
10:03:39 <gspr> according to the cabal docs, makefile mode should cause each module to be compiled separately, which I guess solves the problem
10:04:26 <temoto> gspr, i wonder if you could just run something like find . -name '*.hs' -exec ghc "{}" \; to compile files separately
10:04:48 <temoto> and then --make would probably pick up everything compiled and just link it
10:05:27 <sinelaw> or use ugly makefiles
10:05:43 <gspr> temoto: yeah, good idea, I'll try that.
10:06:14 <temoto> sinelaw, now what's wrong with makefiles?
10:06:15 <gspr> temoto: I was just asking to see if people knew about certain versions of cabal breaking this "makefile mode"
10:07:41 <sinelaw> temoto, ugly disgusting language, for one. second, it doesn't cope with changes in the compilation metadata (such as, if I change the command line or anything else that would cause the build to need updating, it doesn't detect it)
10:08:05 <sinelaw> the assumption that modification time is the only indication of anything is silly
10:08:23 <jmcarthur> conal: there is no such thing as overkill if the API is simple enough ;)
10:09:53 <MissPiggy> my program says 1 * -i = 0
10:10:40 <temoto> sinelaw, how would you fix the second problem?
10:11:20 <sinelaw> temoto, save the command line (more likely, a hash of the command) to detect if the file's creation policy has changed
10:11:48 <idnar> > i
10:11:49 <lambdabot>   i
10:11:53 <idnar> @type i
10:11:54 <lambdabot> Expr
10:12:00 <temoto> sinelaw, into file attributes?
10:12:08 <idnar> no, not that one
10:12:17 <sinelaw> > 1:+1
10:12:18 <lambdabot>   1.0 :+ 1.0
10:12:26 <sinelaw> @type 0:+1
10:12:28 <lambdabot> forall t. (RealFloat t) => Complex t
10:12:34 <Cale> MissPiggy: OH NO TEH COMPLEX NUMEBRS CAN HAS ZERO DIVISORS!!!11
10:12:40 <MissPiggy> lol
10:12:58 <sinelaw> Cale, indeed?
10:13:01 <idnar> > 1 * 0 :+ (-1)
10:13:02 <lambdabot>   0.0 :+ (-1.0)
10:13:11 <Cale> sinelaw: It would prevent them from being a field.
10:13:14 <sinelaw> > (0:+1)^2
10:13:15 <lambdabot>   (-1.0) :+ 0.0
10:13:30 <largos> @version
10:13:31 <lambdabot> lambdabot 4.2.2.1
10:13:31 <lambdabot> darcs get http://code.haskell.org/lambdabot
10:13:35 <sinelaw> ooh
10:13:44 <idnar> > (0 :+ (-1))^2
10:13:45 <lambdabot>   (-1.0) :+ (-0.0)
10:13:52 <sinelaw> -0!
10:13:56 <sinelaw> i love that number
10:14:00 <idnar> gah, stupid floats
10:14:08 <lament> -0! is the loneliest number that you'll ever do
10:14:42 <MissPiggy> (x :/ y) + (u :/ v) = (x * v + y * u) :/ (y * v)
10:14:45 <MissPiggy> there's an error in that line
10:14:55 <idnar> that's a lot of slanty faces
10:14:56 <sinelaw> temoto, also, allow the user to program (in a sane language) additional rule functions to tell when a build target needs updating (in addition / instead of the regular rules)
10:14:57 <MissPiggy> it's meant to add rationals
10:15:40 <sinelaw> MissPiggy, what's the error
10:16:11 <MissPiggy> O____O
10:16:27 <sinelaw> temoto, and i didn't get your question
10:16:43 <temoto> sinelaw, that's pervertly possible through an artifical dependancy which would touch other files.
10:17:01 <MissPiggy> this is wrong (x :+ y) * (u :+ v) = (x * u - y * v) :+ (x * v + y * u)
10:17:02 <sinelaw> temoto, that's what make is all about. perversion.
10:17:28 <sinelaw> MissPiggy, it is?
10:18:05 <temoto> sinelaw, :) i never needed user update predicates.
10:18:13 <MissPiggy> *Algebra> (0 :/ 1) + ((-1) :/ 1)
10:18:13 <MissPiggy> (-1) :/ 1
10:18:13 <MissPiggy> *Algebra> ((-1) :/ 1) + (0 :/ 1)
10:18:13 <MissPiggy> 0 :/ 1
10:18:17 <MissPiggy> can you beleive this
10:18:22 <temoto> sinelaw, the question was where would you store that command line or hash of it.
10:18:26 <idnar> shouldn't it be (x :+ y) * (u :+ v) = (x * u) :+ (y * v) ?
10:18:36 <Twey> (x :+ y) * (u :+ v) = (x * u) :+ (y * v), I'd think
10:18:42 <sinelaw> temoto, however, possibly like git stores its metadata
10:18:45 <Cale> idnar: It's meant to be complex multiplication
10:18:46 * Twey slow
10:18:47 <sinelaw> (in a separate dir)
10:18:48 <MissPiggy> this is all wrong
10:18:50 <Twey> Hmn
10:18:53 <kmc_> e^x dx dx, e^x dy
10:19:04 <MissPiggy> kmc_?
10:19:09 <kmc_> old joke
10:19:15 <Cale> MissPiggy: Let's see the whole program
10:19:30 <sinelaw> MissPiggy, something's uncommutatively fishy there
10:19:39 <temoto> sinelaw, okay, this makes sense. Have you looked at mk? other solutions?
10:19:52 <MissPiggy> what is the point in me writing a program since I can't even got it write
10:20:13 <sinelaw> temoto, nope, i know that CMake is nicer (because of language features, it's in Python) but i never checked if it supports that stuff
10:20:19 <Cale> MissPiggy: It must be something else.
10:20:25 <MissPiggy> x/y + u/v = xv/yv + yu/yv = (xv + yu)/yv
10:20:33 <MissPiggy> hence (x :/ y) + (u :/ v) = (x * v + y * u) :/ (y * v)
10:20:41 <sinelaw> MissPiggy, that's right
10:20:46 <Cale> MissPiggy: the problem can't be with that line
10:21:25 <MissPiggy> *Algebra> (-1) * 1 + 1 * 0
10:21:26 <MissPiggy> 0
10:21:31 <temoto> sinelaw, a friend of mine loves CMake for high level abstractions over platform dependant stuff.
10:21:31 <MissPiggy> oh god
10:21:49 <Cale> MissPiggy: What types?
10:21:53 <sinelaw> temoto, yeah, i used it a bit and it makes life much easier. never had any need yet since then.
10:21:53 <MissPiggy> I'm not cut out for this stuff
10:22:02 <Cale> MissPiggy: hehe
10:22:10 <Cale> MissPiggy: Let's see your whole program
10:22:20 <Cale> @where hpaste
10:22:20 <lambdabot> http://hpaste.org http://moonpatio.com/fastcgi/hpaste.fcgi/
10:22:31 <MissPiggy> @info +
10:22:31 <lambdabot> (+)
10:22:32 <MissPiggy> Cale, okay
10:22:48 <temoto> @where codepad
10:22:48 <lambdabot> codepad.org
10:23:09 <MissPiggy> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16721 -- this is a fixed version
10:23:11 <Cale> ah, good, hpaste.org is back to functioning correctly
10:23:18 <MissPiggy> the problem was that + and * had wrong precidence
10:23:35 <MissPiggy> and that is why that stupid bugs happened
10:23:37 <Cale> Yeah, I suspected something like that
10:24:04 <Cale> Or else it was going to be crazy instance selection issues with weird custom numeric classes :)
10:26:58 <Cale> http://corte.si/posts/code/sortvis-fruitsalad/quicksort.png -- mmm
10:27:34 <lament> is the right side sorted? It doesn't look sorted.
10:28:02 <Cale> It's a Hilbert-cube traversal of an RGB colourspace
10:28:11 <kmc_> very nice
10:28:23 <kmc_> that'd make a good album cover
10:28:28 <MissPiggy> that's nice
10:28:29 <lament> too confusing, the right side looks like something that needs to be sorted.
10:29:05 <MissPiggy> http://corte.si/posts/code/sortvis-fruitsalad/timsort.png
10:30:38 <Vq> oh, nice visualisation of sorting algorithms
10:31:00 <Cale> (http://corte.si/posts/code/sortvis-fruitsalad/index.html)
10:33:37 <Vq> timsort somewhat reminds me of mergesort
10:34:00 <Vq> never heard of timsort before :/
10:34:27 <dolio> Timsort is a fancy mergesort.
10:34:45 <gwern> who cares abotu timsort or introsort? j.d. salinger is dead
10:35:39 <Cale> gwern: I don't understand
10:36:58 <gwern>  /methinks my statement was perfectly comprehensible
10:38:03 <sinelaw> :(
10:38:13 * augur thinks gwern left out some whitespace
10:38:29 <gwern> augur: no, it's a joke - there is no /methinks irc commend, just /me
10:38:37 <augur> oic
10:38:51 <augur> METHINKS THE LADY DOTH PROTEST TOO MUCH
10:38:58 <gwern> augur: exactly
10:42:50 <kmc_> can anyone recommend some papers on supercompilation?
10:43:30 <akappa> supercompilation?
10:44:08 <akappa> (okay, okay, i'll RTFM)
10:44:09 <edwardk> kmc_ have you read all the stuff that ndm has written on the topic?
10:44:26 <kmc_> no, i'm wondering where to start
10:44:35 <edwardk> kmc_ basically wade through his blog ;)
10:44:43 <kmc_> cool :)
10:44:55 <Dashkal> What's a good way to force strict evaulation in a data structure?  The reason I ask is that I don't want a bug (partial function or errant undefined) to put a "sleeper" into this structure that will cause an exception at some time later.  I'd rather crash instantly.
10:45:14 <kmc_> Dashkal: that's one reason not to throw exceptions from pure code
10:45:28 <kmc_> but anyway, if you are writing the "data" declaration, you can put ! before a field to make it strict
10:45:33 <gwern> kmc_: ndm told me, iirc, that the whole-program compilation stuff, and partial evaluation in general, is basically supercompilation
10:45:34 <kmc_> e.g. data Foo = Bar !Int ![Char]
10:45:41 <Dashkal> Ahh, danke.  This is pretty much for instant bug detection.
10:45:43 <edwardk> Dashkal: there are a few options, one is if you control the type of the structure, add !'s before each field. and possibly {-# UNPACK #-} pragmas
10:46:06 <gwern> kmc_: so if you throw in ndm's papers, the REFAL papers, and random prolog/lisp partial evaluation stuff, you should have basically that subsubfield
10:46:08 <Dashkal> I'm not in the habit of using error, undefined, etc.  But partial function bugs happen if I'm not paying attention
10:46:29 <kmc_> Dashkal: precisely, this requires that if a Foo is reduced to WHNF, each of its fields must be reduced to WHNF
10:46:29 <edwardk> Dashkal: the other option is to add or use any existing NFData instances for the types involed in the structure, so you can 'rnf' it when you want to ensure there are no 'sleepers' =)
10:46:52 <int-e> Dashkal: the downside of putting ! everywhere is that you won't be able to build cyclic data structures that way.
10:46:57 <kmc_> it doesn't require deeper forcing... so e.g. the first cons cell in that [Char] will be reduced, but not the whole spine of the list or individual Chars
10:47:11 <kmc_> rnf will reduce everything all the way
10:47:18 <kmc_> gwern: thanks
10:47:26 <kmc_> there are some refs from ndm's papers that i'll follow
10:47:29 <Dashkal> int-e: Fortunately this structure is defined to have no cycles anyway.
10:47:58 <gwern> kmc_: actually I can forward you some emails
10:48:46 <kmc_> nah that's okay, i'll start with the papers
10:49:07 <Dashkal> is ! recursive?  Or does it just apply to the immediate field it annotates?
10:49:17 <kmc_> Dashkal: just immediate
10:49:22 <Dashkal> hmm
10:49:29 <Dashkal> ok, plan B then
10:49:30 <edwardk> i think I  have enough of a small supercompiler that you could tweak it and get something useful out of it around here somewhere that i can dig up if you need something for reference
10:49:49 <edwardk> Dashkal: ! i immediate. that is why i mentioned rnf as a fallback
10:49:53 <edwardk> er is
10:50:18 <kmc_> Dashkal: it requires that, when reducing the data value to whnf, one must reduce this field also to whnf
10:50:25 <kmc_> are you familiar with what is meant by whnf?
10:50:33 <Dashkal> I am not, I was about to start googling :P
10:50:43 <kmc_> iirc google is not too helpful
10:50:51 <gwern> kmc_: ndm's emails might help since he was comparing supero to others, but if you don't want'em nm
10:51:04 <kmc_> gwern: maybe eventually, thanks though
10:51:35 <kmc_> Dashkal: it means that the outermost part of the expression is not a redex
10:51:37 <sinelaw> @hoogle sin
10:51:38 <lambdabot> Prelude sin :: Floating a => a -> a
10:51:38 <lambdabot> Text.Html.BlockTable single :: a -> BlockTable a
10:51:38 <lambdabot> Data.ByteString singleton :: Word8 -> ByteString
10:51:46 <gwern> @quote kmc
10:51:47 <lambdabot> kmc says: i am Jack's monad operator
10:51:57 <kmc_> Dashkal: a redex is a reducible expression, specifically an expression to which the beta-reduction rule of lambda calculus applies
10:51:57 <Dashkal> "redex"?  I'm suspecting there's a paper or two I need to read...
10:52:09 <kmc_> meaning an application of a lambda term to a value
10:52:13 <pastorn> lambdabot: that's good :)
10:52:14 <kmc_> ((\x -> e) a)
10:52:17 <kmc_> that's a redex
10:52:28 <Dashkal> ahh, I'm only passingly familiar with the lambda calculus.  I studied SKI calculus awhiel back, but I never grasped how they relate
10:52:41 <kmc_> because you can reduce it by substituting a for each free occurance of x within e
10:52:48 <pokoko222> someone has experience with Petri Nets?
10:53:18 <tromp> you can easily translate between lambda and SK expressions
10:53:27 <MissPiggy> pokoko222: not really no
10:53:31 <kmc_> if a Haskell expression is not a redex, it's usually either a constructor (with fields) or a lambda by itself (without being applied)
10:53:39 <MissPiggy> pokoko222: I just see them come up in a few different places
10:53:58 <Alpounet> are there applications of type level SK combinators ?
10:54:01 <Dashkal> ahh, that's starting to click
10:54:06 <kmc_> since WHNF only requires that the *outermost* part of the expression is not a redex, a constructor with a redex in a field is still in WHNF
10:54:16 <MissPiggy> Dashkal, well you can implement S K and I using lambda calculus, going the other way is possible but quite difficult
10:54:21 <kmc_> annotating that field with ! requires that it's not a redex
10:54:52 <kmc_> in Haskell evaluation proceeds by reduction to WHNF.  the reason is that WHNF is the least amount of evaluation required to pattern-match on the outermost constructor
10:55:01 <Dashkal> My experiments with SKI were actually a test case for learning parsers.  Along the way I implemted SKI and boolean logic on top.  But this is going offtopic.
10:55:04 <tromp> bracket abstraction translates lambda into SK
10:55:36 <tromp> of course it's limited to untyped calculus
10:56:06 <Dashkal> this might help.  What is WHNF short for?  I'm guessing ** Normal Form
10:56:29 <monochrom> weak head
10:56:57 <Dashkal> ok.  Thanks for the help understanding this.  Now I'm realizing I'm attacking the problem the wrong way.
10:57:00 <MissPiggy> I guess there's a simply typed way to relate them too, since they're both complete for ND
10:57:00 <Dashkal> hrm
10:57:04 <kmc_> weak head normal form
10:57:06 <MissPiggy> no idea how to translate though
10:57:19 <Dashkal> Actually, I think I can solve this with a single $! expression...
10:57:28 <Cale> Dashkal: A term is in weak head normal form if it is either a lambda, or it is a constructor applied to some arguments.
10:57:46 <MissPiggy> it's not just |- P <-> |= P, (one for lambda one for SK) because you also want to preserve computational aspects
10:57:56 <Cale> (i.e. it is not a function application or a case expression)
10:58:42 <Cale> Well, that should probably be "e.g." rather than "i.e.", because you might have more types of expressions :)
11:00:15 <Dashkal> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16722#a16722
11:00:44 <Dashkal> Basically the only place sleepers can get in there is via Entity itself.  If I make EntityData and the related *Data data types strict, I should be safe.
11:00:59 <mauke> @msg mauke t
11:02:53 <Dashkal> While the structure of World doesn't enforce it, the functions that operate on it ensure that it describes a DAG.
11:03:06 <Dashkal> I need to be able to serialize it
11:03:12 <Dashkal> without jumping through hoops
11:03:34 <MissPiggy> how do you guys keep your head screwed on while you deal with all this stuff?
11:04:03 <sproingie> sheet metal screws
11:04:11 <Dashkal> MissPiggy: I came to terms with my insanity years ago.  Embrace it, it's easier that way
11:11:06 <MissPiggy> Cale?
11:12:33 <Cale> MissPiggy: yes?
11:12:36 <MissPiggy> what about calculus you aren't allowed to get rid of dx until the end, that's a bit like CReal
11:14:06 * Cale blinks
11:14:11 <Cale> what?
11:14:22 <MissPiggy> yesterday we were talking about CReal
11:14:31 <Cale> yeah?
11:14:32 <zygoloid> *-* iRC FaiL: parse error on 19:12 MissPiggy *-*
11:14:34 <MissPiggy> and how that even if you only want 10 places, the intermediate computations can take millions
11:14:42 <Cale> Yeah.
11:15:11 <Cale> Though I'm not sure that's something really fundamental, or just a problem with CReal
11:15:11 <MissPiggy> so it's a bit like the intermediate computations with dx, it has to come along for the ride even if standardification throws it away at the end
11:15:56 <Twey> How does that work?
11:16:14 <Cale> I don't really understand the analogy with nonstandard analysis here.
11:16:35 <Twey> Can't you just do truncating arithmetic on BCD to the requested number of places plus one, then round the last one away?
11:16:58 <monochrom> You can safely say "yes" to all questions of the form "is X like Y?"
11:17:15 <Cale> Twey: mmm... there are cases where you really do need more precision
11:17:23 <zygoloid> @faq Can Haskell determine whether life is like a box of chocolates?
11:17:23 <lambdabot> The answer is: Yes! Haskell can do that.
11:17:32 <Twey> ‘Are coconuts like pigs?’ ‘Yes!  They both have hair.’
11:17:36 <sinelaw> @vixen is life like a box of chocolates?
11:17:37 <lambdabot> nevermind about that
11:17:46 <Twey> Cale: But you *get* the required precision, no?
11:17:47 <zygoloid> @vixen are coconuts like pigs?
11:17:47 <lambdabot> let's don't talk about that
11:17:49 <sinelaw> always avoiding to address the issues at hand
11:17:56 <Twey> Hehe
11:17:59 <Cale> Twey: But for smooth functions at least, I think it's possible to determine how many places that you'll need, at least.
11:18:10 <Cale> I'm not 100% certain why:
11:18:13 <ElfArmy> I've got a question about installing hxt with cabal. I get a message saying that it requires base >=4.2 - but I only have 4.1 as that's what seems to come with the latest haskell platform -  but it was excluded because of the top level dependancy base -any. If I try to invoke an install for base (which I seem to recall is unadvisable anyway) it says it can't satisfy the dependancy of integer-simple -any. Any ideas?
11:18:15 <aavogt> @vixen what is a smooth function?
11:18:16 <lambdabot> fun is the opposite of work
11:18:24 <Twey> Heh
11:18:25 <Cale> > showCReal 10 (sum [1..10000])
11:18:30 <lambdabot>   mueval-core: Time limit exceeded
11:18:32 <Cale> ^^ that is so slow
11:18:40 * sinelaw is happy - program finally working!
11:18:54 <sinelaw> but code could be nicer
11:19:02 <Cale> ElfArmy: Maybe install an older hxt.
11:19:22 <Cale> ElfArmy: 4.2 is, I believe, the base which comes with GHC 6.12
11:19:29 <Twey> aavogt: You'll note that Erlang uses a lot of funs.
11:19:44 <ElfArmy> Ah.
11:19:45 <Cale> ElfArmy: You never upgrade the base package using cabal, you install a newer GHC and base comes with it.
11:20:01 <Zao> Your probably do not want to upgrade the core packages either.
11:20:11 <Alpounet> are there applications of type level SK combinators ?
11:20:17 <Zao> Had some nice breakage updating Win32 recently :)
11:20:26 <ElfArmy> I didn't have much luck trying to get a previous version of hxt with cabal, perhaps I'll try upgrading ghc instead.
11:20:28 <Cale> Alpounet: proving that the type system is Turing complete?
11:20:35 <Alpounet> yes
11:20:39 <Alpounet> ok
11:20:53 <Cale> I'm not sure if there are any really practical ones :)
11:20:56 <zygoloid> > showCReal 10 $ sum ([10^100] ++ take 100 (iterate (/2) 1) ++ [-10^100])
11:20:57 <lambdabot>   "2.0"
11:21:01 <zygoloid> > sum ([10^100] ++ take 100 (iterate (/2) 1) ++ [-10^100])
11:21:02 <lambdabot>   0.0
11:21:08 <Alpounet> Cale, I guess it was implied by what you said :-p
11:21:11 <Alpounet> thanks anyway
11:21:24 <zygoloid> ^^ that needs over a hundred intermediate digits
11:21:28 <Cale> If you can do SK, then there's probably a nicer way to do whatever computation you want to do at the type level than encoding it as an SK term.
11:21:38 <pokoko222> anyone knows what high-level replacements systems are? I see this term first time...
11:21:49 <monochrom> ElfArmy: cabal-install hxt-8.3.2
11:21:57 <pokoko222> oops sorry that was for math
11:22:11 <ElfArmy> monochrom, thanks, I'll give that a go.
11:30:00 <aavogt> Twey: apparently ocaml is also full of fun
11:35:51 <MissPiggy>         cannot mix `+' [infixl 3] and `:/' [infix 2] in the same infix expression ?
11:35:53 <MissPiggy> why can't I do that
11:35:56 <MissPiggy> it doesn't make sense
11:37:35 <aavogt> is it in a section?
11:37:39 <MissPiggy> no
11:38:52 <aavogt> > let infixl 3 +; infix 2 -; (+) = (Prelude.+); (-) = (Prelude.-) in 1 + 2 - 2
11:38:53 <lambdabot>   1
11:39:11 <aavogt> > let infixl 3 +; infix 2 -; (+) = (Prelude.+); (-) = (Prelude.-) in 1 - 2 + 1
11:39:12 <lambdabot>   -2
11:39:35 <aavogt> MissPiggy: what's your code?
11:39:51 <aavogt> it doesn't seem possible to reproduce the error here
11:40:03 <MissPiggy> if I use brackets it works
11:40:57 <Twey> > let infixl 3 +; infix 2 - in 1 - 2 + 1
11:40:57 <lambdabot>   The fixity declaration for `+' lacks an accompanying binding
11:40:57 <lambdabot>    (You cannot...
11:41:00 <Twey> Shame
11:41:20 <doserj> > let infixl 3 +; infix 2 -; (+) = (Prelude.+); (-) = (Prelude.-) in 1 - 2 + 3 - 3
11:41:21 <lambdabot>   Precedence parsing error
11:41:21 <lambdabot>      cannot mix `-' [infix 2] and `-' [infix 2] in...
11:41:30 <doserj> but thats a different error
11:42:14 <MissPiggy> how do you make a set like {(x,2),(y,5)}
11:42:17 <aavogt> Twey: yeah for reasons of sanity, you can only specify fixities where the function is defined
11:42:35 <MissPiggy> and you want to add in like (x,7) to get {(x,9),(y,5)}
11:42:37 <Twey> aavogt: But it would be very handy to be able to specify fixities in a where clause
11:42:51 <MissPiggy> and Eq and Ord them..
11:43:07 <doserj> MissPiggy: Data.Map?
11:43:12 <aavogt> Twey: you can as I did up there, except that means your function has to have some kind of qualified name
11:43:19 <Twey> Yeah
11:43:23 <Twey> It's awkward
11:43:28 <MissPiggy> Data.Map
11:43:40 <aavogt> I guess if it doesn't, then you would modify the fixity directly
11:43:59 <aavogt> (meaning, when the function is defined in the same module)
11:44:28 <MissPiggy> hm Monoid (Map k v) ?
11:44:45 <MissPiggy> mappend = union
11:45:20 <monochrom> You miss "Ord k"
11:46:14 <aavogt> @type M.unionWith
11:46:15 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> M.Map k a -> M.Map k a -> M.Map k a
11:46:51 <aavogt> > mconcat [M.singleton 0 (Sum 2),M.singleton 0 (Sum 3)]
11:46:52 <lambdabot>   fromList [(0,Sum {getSum = 2})]
11:47:24 <aavogt> aww, I wanted   instance (Monoid e, Ord k) => Monoid (Map k e)
11:47:27 <MissPiggy> I don't understand that
11:47:52 <aavogt> > M.unionsWith mappend [M.singleton 0 (Sum 2),M.singleton 0 (Sum 3)]
11:47:53 <lambdabot>   fromList [(0,Sum {getSum = 5})]
11:48:13 <MissPiggy> > (\f -> (f [M.singleton 0 (Sum 2),M.singleton 0 (Sum 3)], f ())) mconcat
11:48:14 <lambdabot>   Couldn't match expected type `()'
11:48:15 <lambdabot>         against inferred type `[Data.Map....
11:48:34 <MissPiggy> M.Map t (Sum t1) is a monoid but why?
11:48:49 <aavogt> @hoogle Alternative f => [f a] -> f a
11:48:50 <lambdabot> Data.Foldable asum :: (Foldable t, Alternative f) => t (f a) -> f a
11:48:50 <lambdabot> Control.Monad msum :: MonadPlus m => [m a] -> m a
11:48:50 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
11:48:56 <MissPiggy> instance (Ord k) => Monoid (Map k v) where   does not require v to me a monoid
11:49:02 <MissPiggy> so how does it use the sum instance....
11:49:33 <aavogt> MissPiggy: it doesn't at all?
11:50:13 <idnar> @instances Monoid
11:50:13 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
11:50:26 <idnar> no
11:52:26 <idnar> anyway, I don't think the Monoid instance does anything with the values in the Map at all
11:53:41 <aavogt> it's missing from that list
11:54:28 <idnar> @instance-importing Monoid Data.Map
11:54:29 <lambdabot> Couldn't find class `Data.Map'. Try @instances-importing
11:54:34 <idnar> @instance-importing Data.Map Monoid
11:54:34 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Map k v, Maybe a, Ordering, Product a, Sum a, [a]
11:54:43 <MissPiggy> is there one for a set of pairs (a,b) that is unique for a? so like {("foo",3),("bar",3)} is okay but {("foo",3),("foo",4)} is not.. it should be merged to {("foo",7)}?
12:00:51 <raceRider> is there a simple pad function to pad ints with zeros as in 1 returns 01, 2 returns 02, but 22 returns 22. Function type will be Int -> String.
12:02:06 <Botje> raceRider: pad n x = let xs = show x in take (n-length sx) (repeat '0') ++ xs
12:02:14 <Botje> s/sx/xs/
12:02:40 <Twey> pad n = printf ("%" ++ show n ++ "d")
12:02:49 <raceRider> thanks Botje and Twey
12:02:55 <Botje> Twey: heh heh :)
12:03:04 <Twey> ☺
12:03:29 <Twey> pad n = printf ("%" ++ show n ++ "d") :: Int -> String -- strip away all that printf type nastiness
12:05:47 <Twey> Hmn, needs a 0 in there
12:05:57 <Twey> pad n = printf ("%0" ++ show n ++ "d") :: Int -> String
12:06:06 <Twey> Ooh, $
12:06:12 <Twey> pad n = printf $ "%0" ++ show n ++ "d" :: Int -> String
12:06:21 <Twey> Hmm
12:06:44 <MissPiggy> im just wondering if such a data structure exists already
12:07:00 <MissPiggy> that if you have something like (x,y) it joins all the y's which have the same x
12:07:12 <Twey> pad = printf . printf "%%0%dd" :: Int -> Int -> String
12:07:15 <raceRider> thanks Twey that works
12:07:35 * Twey loves the iterative improvement process that goes into Haskell code
12:07:45 <raceRider> yes indeed
12:23:03 <MissPiggy> if you were to render LaTeX output from haskell would you just use Text.PrettyPrint?
12:23:05 <jlouis> MissPiggy: building one on Data.Map and the 'alter' function is probably easy
12:23:15 <MissPiggy> jlouis, okay thanks I will use Data.Map then
12:23:19 <jlouis> and can be generalized to work for any monoid
12:23:20 <kmc_> MissPiggy: you might want to build an abstract syntax tree first
12:23:30 <kmc_> i don't know if there's an existing library for a LaTeX AST
12:23:31 <MissPiggy> I have abstract syntax for mathematical expressions
12:23:37 <MissPiggy> oh you mean for LaTeX
12:23:41 <kmc_> the syntax of LaTeX is pretty hairy
12:23:50 <MissPiggy> oh hm
12:24:08 <kmc_> well, both, definitely -- but if you're only using LaTeX for your single math AST, it might not be worth it to generate an intermediate LaTeX AST
12:24:11 <Saizan> ?type Data.Map.fromListWith
12:24:11 <MissPiggy> I just want to render these things in a nice readable way
12:24:12 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> [(k, a)] -> M.Map k a
12:24:14 <kmc_> Text.PrettyPrint is pretty nice
12:24:24 <Cale> I wonder if LaTeX even can be said to have a fixed syntax. It's all crazy macro expansion crap.
12:24:38 <Cale> TeX was invented before most effective parsing techniques
12:24:44 <Twey> Yeah
12:24:46 <Twey> Sadly
12:25:04 <pettter> Cale: TeX is the language, though
12:25:14 <pettter> LaTeX is just built on top, iirc
12:25:17 <Cale> right
12:25:29 <Twey> LuaTeX might be the way out of that mess
12:25:43 <Twey> I anticipate it with gladness
12:25:57 <jlouis> LuaTeX definitely looks interesting
12:26:03 <MissPiggy> nice Saizan
12:26:31 <jlouis> A XeTeX and pdfLaTeX merger would also be awfully cool
12:26:38 <MissPiggy> the thing is I don't even know TeX :D
12:26:44 <MissPiggy> I just know it makes the nice output
12:26:53 <MissPiggy> better than trying to read this stuff in the command line
12:27:10 <Cale> yeah
12:27:19 <Cale> It's easier to emit TeX than it is to parse it, anyway
12:27:39 <jmcarthur> > M.fromListWith (+) [("foo",3), ("bar",4), ("foo",5)]
12:27:40 <lambdabot>   fromList [("bar",4),("foo",8)]
12:28:45 <Twey> jlouis: I believe that LuaTeX intends to supersede both
12:29:21 <pettter> in ten years time, they might, somewhat
12:29:40 <Twey> I don't know… that's when it's planned, but apparently it's pretty far forward already
12:29:50 <pettter> but it''ll take at least that long
12:30:11 <Twey> Well, I hear reports it's actually usable alreadyy
12:30:47 <koala_man> did they use lua just to call it LuaTex?
12:30:53 <Twey> Haha
12:30:59 <Twey> I think they just wanted a tiny scripting language
12:31:00 <MissPiggy> the idea is like put ghci in a browser
12:31:06 <MissPiggy> then you can use LaTeX and nice stuff like that
12:31:13 <MissPiggy> just for output
12:31:47 <Twey> There used to be a Haskell-in-the-browser interpreter
12:31:51 <Twey> It died
12:32:04 <MissPiggy> it's not like I need to write that in haskell or anything
12:32:14 <MissPiggy> just a bash webserver that runs a ghci or whatever
12:32:54 <Cale> There's Lout, but Lout unfortunately seems to be implemented as a poorly organised C program.
12:33:22 <pettter> MissPiggy: doesnt wikipedia use latex to generate formulae and stuff?
12:33:23 <Twey> So, a C program?  :þ
12:33:24 <Cale> At least, I seem to recall that it had numbered source files.
12:33:28 <MissPiggy> pettter, yes
12:33:38 <Cale> Like, worse than your average C program.
12:33:59 <Twey> Gosh.
12:34:13 * Cale checks to see if his memory is correct
12:34:35 <pettter> most programming languages can be used to write structured and readable code
12:34:43 <pettter> and most can be used to produce garbage
12:34:50 <Cale> Yep, the main source directory has z01.c through to z52.c
12:34:57 <MissPiggy> Cale wow lol
12:34:58 <Cale> all of various sizes
12:35:04 <pettter> now taht's garbage
12:35:24 <jlouis> hah
12:35:32 <MissPiggy> I know a guy who writes the whole game in one 300000 line C file
12:35:43 <MissPiggy> seems to work though
12:35:47 <pettter> but whyyyyy
12:35:54 <benmachine> that must be painful to edit
12:35:58 <pettter> Seriously, why would you DO that?
12:36:08 <benmachine> don't have to worry about static/extern :P
12:36:14 <MissPiggy> hey these people are devoted
12:36:22 <Twey> I once wrote a 10,000-line single-file PHP application
12:36:24 <MissPiggy> you don't need a lot of skill just a lot of devotion
12:36:37 <MissPiggy> well skill is the wrong word there
12:37:03 <benmachine> Twey: were 9,998 of those lines blank?
12:37:05 <Cale> Also, there are single C functions which are over 1000 lines long here.
12:37:09 <Twey> It was actually pretty handy, but in retrospect I think I should have found some way to bundle multiple files into one rather than writing it as one initially
12:37:12 <Twey> benmachine: No :þ
12:37:26 <Twey> It comprised about twenty HTML pages
12:37:32 <benmachine> cool
12:37:54 <Cale> z12.c contains a function called MinSize which runs from line 368 to line 1375
12:38:07 <Twey> … pain …
12:38:16 <Cale> and it's all nested cases and if/then/else
12:38:24 <Twey> How deep does the nesting go?
12:38:29 <jlouis> beautiful!
12:38:47 <dolio> I think I have an entire language interpreter in less than 1000 lines.
12:38:51 <Cale> I'm not sure, the indentation is a bit haphazard
12:40:35 <Twey> There's this: http://www.annexia.org/_file/jonesforth.s.txt
12:40:45 <Twey> Which is only something like 500 lines of assembler excluding comments, I think
12:41:02 <jmcarthur> i don't understand andrew coppin
12:41:36 * MissPiggy doesn't understand this: It might be useful to use the notation '7' for the cyclic group with 7 elements. 
12:41:51 <MissPiggy> what a ridiculous thing to say???
12:43:21 <Cale> Huh?
12:43:31 <Cale> It's not terribly ridiculous. You could do that.
12:43:34 <MissPiggy> the notation is Z_7
12:43:40 <Cale> sure
12:44:20 <Cale> or C_7 or Z/7 or Z/<7> or Z/7Z
12:44:40 <dolio> I've seen people use '7' as the name for the finite set with 7 elements.
12:44:50 <Cale> I use that notation all the time
12:44:56 <MissPiggy> set theory
12:45:07 <Cale> n is the set of natural numbers less than n :)
12:45:10 <jmcarthur> i think 7 is a perfectly reasonabl notation for it
12:45:17 <Twey> I've seen lots of people use 1 for ()
12:45:26 <jmcarthur> it requires context to understand, of course, but reasonable
12:46:07 <Cale> If you're making a table in which there are lots of cyclic groups involved, it might be natural to adopt a shorthand like that.
12:47:06 * MissPiggy just whines a bit more about having to learn LaTeX :P
12:47:27 <HugoDaniel> are there arrows that work on (a,b,c) ?
12:47:29 <gspr> MissPiggy: just think of the beautiful typeset result
12:47:38 <HugoDaniel> instead of just a tuple of (a,b) ?
12:47:51 <mauke> > () :: 1
12:47:52 <lambdabot>   Couldn't match expected type `GHC.Generics.Unit'
12:47:52 <lambdabot>         against inferred t...
12:48:07 <benmachine> I don't think latex is unpleasant to write
12:48:14 <benmachine> at least for most things
12:48:17 <benmachine> am I weird
12:48:21 <benmachine> well yes
12:48:29 <benmachine> does this in particular contribute to my weirdness
12:48:33 <MissPiggy> benmachine you can collab with me i.e. write it for me :P
12:48:38 <benmachine> <_<
12:48:44 <monochrom> >text "Gödel"
12:48:48 <monochrom> > text "Gödel"
12:48:49 <lambdabot>   Gödel
12:49:06 <Twey> benmachine: I agree, on the whole
12:49:34 <Twey> It's a fairly decent system to use.  The problem is in what goes on behind the scenes (and as such rears its head when one has to work with such)
12:49:53 <benmachine> mm
12:49:55 <benmachine> I suppose so
12:50:05 * benmachine carefully doesn't work with such
12:50:19 <Twey> Hehe
12:50:36 <Twey> Well, for example, if you write a command that uses align, you have to do weird stuff
12:51:36 <Twey> Like \csname align*\endcsname instead of \begin{align*}
12:51:51 <benmachine> oh, that does sound like a barrel of laughs
12:51:59 <benmachine> a whole barrel.
12:52:16 <Twey> You still have to end it with \end{align*}, of course
12:52:21 <benmachine> of course!
12:53:30 <MissPiggy> http://hackage.haskell.org/packages/archive/hscolour/1.15/doc/html/src/Language-Haskell-HsColour-LaTeX.html
12:53:36 <MissPiggy> interesting perl styple
12:54:37 <benmachine> I know you can do the work of case statements in function equations, but sometimes the former is much less verbose
12:55:23 <MissPiggy> looking for more haskell code that outputs latex
12:55:30 <benmachine> pandoc?
12:56:16 <MissPiggy> http://hackage.haskell.org/packages/archive/Monocle/0.0.4/doc/html/src/Monocle-Tex.html
12:56:20 <MissPiggy> same style there
12:59:42 <andrewe> Unfortunately, it's hard to google "X -> 1 + A * X" and "list", I'm looking for an article about that, can someone give me a hint?
13:00:09 <temoto> @where hoogle
13:00:10 <lambdabot> http://haskell.org/hoogle
13:00:35 <tommd> That doesn't look like a type to me.
13:00:55 <temoto> That looks like an Erlang expression without parens.
13:00:57 <kmc_> "X -> 1 + A * X" is a type in non-Haskell notation
13:01:23 <andrewe> and list is a fix point of that equation?
13:01:26 <kmc_> rather, what they probably mean is a function on types that takes a type X to the type 1 + A*X
13:01:32 <andrewe> or a solution?
13:01:38 <kmc_> and yes, a list of A would be the least fixed point of that type-function
13:01:47 <kmc_> data List a = Nil | Cons a (List a)
13:01:58 <kmc_> Nil is 1, A*X is Cons a X
13:02:04 <andrewe> and I'm looking for an article about that.
13:02:14 <kmc_> an article about what about it?
13:02:21 <temoto> @where scholar
13:02:21 <lambdabot> I know nothing about scholar.
13:02:41 <temoto> @where google.com/scholar
13:02:41 <lambdabot> I know nothing about google.com/scholar.
13:02:46 <temoto> Did you try it?
13:02:56 <andrewe> kmc_: I know I'm being vague, maybe it was the sigfpe blog
13:03:10 <kmc_> ah, a specific article?
13:03:37 <HugoDaniel> is there something like this: (a,b,c) -> (a -> b -> c)  ?
13:03:58 <kmc_> @djinn (a,b,c) -> (a -> b -> c)
13:03:59 <lambdabot> f (_, _, a) _ _ = a
13:04:03 <andrewe> kmc_: I'd be happy to find any article that explains something about list being a solution to the equation above.
13:04:05 <kmc_> not too useful
13:04:12 <kmc_> andrewe: well, i can explain it
13:04:12 <Cale> A Haskell list would be the greatest fixed point, actually :)
13:04:15 <HugoDaniel> oh :/
13:04:23 <benmachine> HugeDaniel: ((a,b,c) -> d) -> a -> b -> c -> d?
13:04:26 <kmc_> @djinn c -> (a -> b -> c)
13:04:27 <lambdabot> f a _ _ = a
13:04:36 <andrewe> kmc_: please do
13:04:42 <benmachine> er, HugoDaniel
13:04:58 <dolio> In haskell, the least fixed point is the greatest fixed point.
13:05:11 <benmachine> (did I actually *type* someone's *name*? I wonder why)
13:05:15 <HugoDaniel> i have a function that has type Double -> Double -> Double ->Double, and i want to define an arrow over this...
13:05:33 <MissPiggy> church of the least fixed point?
13:05:35 <HugoDaniel> how do i do that ?
13:05:38 <temoto> @djinn a -> [a]
13:05:39 <lambdabot> Error: Undefined type []
13:05:56 <temoto> @djinn (a,b) -> (b,a)
13:05:56 <lambdabot> f (a, b) = (b, a)
13:06:12 <MissPiggy> temoto, it doesn't know recursion
13:06:24 <MissPiggy> which is a shame
13:06:41 <temoto> MissPiggy, i was expecting   f a = [a]   for first :)
13:07:03 <kmc_> andrewe: first of all, do you understand the type expression 1 + A*X
13:07:12 <MissPiggy> @djinn a -> (Maybe a, Either a a, (a,a))
13:07:12 <lambdabot> f a = (Nothing, Left a, (a, a))
13:07:16 <andrewe> maybe
13:07:20 <kmc_> in Haskell it would be roughly:   Either () (A, X)
13:07:44 <mauke> temoto: it doesn't know what [] is, though
13:07:49 <andrewe> ok, that's how I understood it
13:08:09 <MissPiggy> in haskell you go
13:08:20 <kmc_> 1 is a type with one value, such as ()
13:08:23 <MissPiggy> Mu (One :+: (Var :*: Rec))
13:08:25 <MissPiggy> or something like that
13:08:31 <MissPiggy> you define :+: and such as functors
13:08:39 <MissPiggy> then Mu takes the LFP
13:08:59 <MissPiggy> and Mu (One :+: (Var :*: Rec)) ~ [] is straight forward to prove by implementation
13:09:19 <MissPiggy> (by construction?)
13:09:33 <andrewe> kmc_: how do I solve that equation?
13:09:43 <andrewe> kmc_: without only guessing
13:09:48 <kmc_> X = 1 + A*X
13:09:53 <MissPiggy> andrewe, the X = 1 + A*X? Mu solves it
13:10:10 <MissPiggy> or you can take a course in domain theory :D
13:10:14 <temoto> What is + in type expression?
13:10:24 <andrewe> What is Mu?
13:10:37 <kmc_> @src Mu
13:10:37 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
13:10:47 <MissPiggy> Mu X. F[X] ~ F(Mu X. F[X])
13:10:56 <etpace> I understand the simple context based zippers, but I'd like to understand delimited continuations which are used with zippers, does anyone know of a good website/paper to read?
13:11:00 <idnar> 1 = 1/X + A
13:11:50 <kmc_> temoto: + for types is "disjoint union".  A + B is a type like Either A B in Haskell
13:12:00 <kmc_> it contains the elements of A plus the elements of B, each tagged saying which one it came from
13:12:22 <temoto> Why don't we have + as a shorthand for Either?
13:12:35 <kmc_> because people should write their own algebraic types
13:12:42 <kmc_> instead of overusing Either and tuples
13:13:02 <temoto> What's the point in newtype for Either?
13:13:05 <MissPiggy> temoto, sometimes I use :+:
13:13:05 <kmc_> for theory it's convenient to have a single canonical type.  but for good software engineering it's desirable to name each type according to what it does
13:13:36 <temoto> MissPiggy, it's a shorthand for Either?
13:13:44 <kmc_> Mu "solves" a type equation (expressed as a type constructor of kind * -> *) in the same way that fix "solves" a value equation (expressed as a function of type a -> a)
13:13:52 <MissPiggy> temoto, well I tend to use it for something similar but slightly different
13:13:58 <temoto> :t Int :+: Bool
13:13:59 <lambdabot> Not in scope: data constructor `Int'
13:13:59 <lambdabot> Not in scope: data constructor `:+:'
13:13:59 <lambdabot> Not in scope: data constructor `Bool'
13:14:06 <kmc_> Natural numbers are isomorphic to Mu Maybe
13:14:29 <idnar> :k Int :+: Bool
13:14:30 <lambdabot> *
13:14:39 <temoto> oh right :k
13:14:49 <temoto> :k Either Int Bool
13:14:51 <lambdabot> *
13:14:52 <idnar> but that's not particularly enlightening
13:14:59 <idnar> @type undefined :: Int :+: Bool
13:14:59 <lambdabot> Int :+: Bool
13:15:04 <idnar> and neither is that, I guess
13:15:12 <andrewe> kmc_: great, you explain Mu by fix, which made my head hurt two weeks ago ;-)
13:15:22 <kmc_> andrewe: ah, but does it still hurt? ;)
13:15:42 <sinelaw>  > fix head
13:15:47 <kmc_> haha
13:15:50 <kmc_> type error
13:15:52 <kmc_> > fix head
13:15:53 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
13:15:58 <andrewe> kmc_: for sure, watching some videos about FRP increased the pain
13:16:08 <ElfArmy> Surely there's only a finite number of things that can cause your head to hurt, so getting them other with is a good thing :)
13:16:16 <andrewe> sinelaw: :)
13:16:22 <ElfArmy> over with rather
13:16:34 <temoto> I guess andrewe tried to construct the infinite type and that caused the pain.
13:16:38 <Berengal> @type fix (head . out)
13:16:39 <lambdabot> Mu []
13:17:04 <sinelaw> andrewe, which videos?
13:17:31 <temoto> Yeah, share your pain video links.
13:17:49 <sinelaw> @type out
13:17:50 <lambdabot> forall (f :: * -> *). Mu f -> f (Mu f)
13:17:51 <andrewe> e.g. the one on this page (http://conal.net/papers/push-pull-frp/)
13:18:19 <sinelaw> !! I read that paper but never noticed there was a video
13:18:26 <sinelaw> andrewe, what else
13:19:01 <temoto> I'd be glad if someone explained Push-pull-FRP in simpler words some day.
13:19:39 <andrewe> sinelaw: I don't remember the others now
13:20:15 <andrewe> it's probably a self-protective property of my brain ;-)
13:20:59 <andrewe> what really freaked me out was unamb.
13:21:08 <andrewe> and lub
13:21:58 <sinelaw> andrewe, oh, yeah :) mine went to hibernate and then deleted its own swapped when i got to that part
13:22:01 <sinelaw> i feel your pain.
13:22:08 <sinelaw> s/swapped/swap
13:22:18 <andrewe> Thank you :)
13:24:02 <temoto> Isn't unamb like just spawn two threads, eval arguments in different threads and take value of thread that didn't produce exception?
13:24:59 <andrewe> yes, but I don't see how that could be so useful
13:25:07 <c_wraith> Hmmm.  the LRU package is deprecated.  What's taken over that functionality?
13:25:29 <jmcarthur> temoto: it's return the first value that finishes evaluating
13:26:29 <temoto> jmcarthur, what i said + first of two?
13:26:29 <sinelaw> temoto, one of the options could be non-terminating, and also sometimes one option uses partial information that the other one doesn't have
13:26:51 <sinelaw> oops. i meant andrewe
13:27:09 <MadHatterDude> Hello guys
13:27:25 <sinelaw> hey dude
13:27:26 <benmachine> hello
13:27:32 <andrewe> hello MadHatterDude
13:27:48 <MadHatterDude> Stupid nick serv
13:30:47 <temoto> What is ~ in type expression?
13:31:05 <aavogt> type equality
13:31:05 <benmachine> equality, I think
13:31:12 <benmachine> used with type families mainly
13:32:22 <temoto> Uh but how is it useful?
13:33:11 <benmachine> temoto: are you familiar with type families?
13:33:38 <dolio> Lots of stuff in GHC is implemented in terms of type equalities in the intermediate language.
13:33:43 <temoto> benmachine, if you mean type classes, then yes.
13:33:48 <benmachine> I don't
13:33:51 <benmachine> I mean -XTypeFamilies
13:33:52 <temoto> Then no.
13:34:09 <dolio> For instance, "newtype Foo = Foo Int" introduces an equality "Foo ~ Int" in the intermediate language.
13:34:25 <dolio> Or something along those lines.
13:35:09 <temoto> So type equality is all about newtypes?
13:35:10 <MadHatterDude> Is ther for convenience sake a function that is equivalent to 'fromInteger . toInteger' ?
13:35:27 <temoto> MadHatterDude, id?
13:35:27 <dolio> And type checking/inference involves collecting and solving those sorts of equalities with variables.
13:35:44 <Lemmih> MadHatterDude: fromIntegral?
13:35:49 <xerox> temoto until associated types were implemented in haskell itself :)
13:35:51 <MadHatterDude> temoto: no, i mean to "cast" between integer types
13:36:17 <MadHatterDude> temoto: as in '(fromInteger . toInteger x) :: Word32'
13:36:54 <MadHatterDude> temoto: I find myself doing that alot and I wondered if there was some Prelude function or similar...
13:37:20 <Lemmih> > fromIntegral (10::Word) :: Int
13:37:21 <lambdabot>   10
13:37:23 <dolio> Type equality is not about newtypes. Newtypes are implemented (in part) via type equalities in GHC.
13:37:31 <MadHatterDude> Lemmih: Yup, thanks
13:37:48 <temoto> xerox, newtype is associated types?
13:37:58 <theclaw> when having multiple monad transformers stacked on each other, like in http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16726#a16726, does it matter in which order I use the "runT" functions?
13:38:22 <temoto> Forbidden word: order. mwahaha
13:39:11 <theclaw> ?
13:39:27 <MadHatterDude> I still can't get over implementing mersenne twister in less than 50 lines of code
13:39:49 <temoto> theclaw, never mind :)
13:40:11 <theclaw> temoto: stupid question? :[
13:40:28 <temoto> theclaw, no, stupid answer :)
13:40:36 <IceDane> I've been reading about monads for the better part of today, but I'm still nowhere closer to actually seeing 'why' they are needed. I've seen some examples of them shortening code and some such, but I can't really think of any situation on my own where I think "Ah, that's perfect for monads," heh. Any hints? Any exercise-oriented program to write that will have me understanding them?
13:41:04 <theclaw> temoto: do you have a non-stupid one? :P
13:41:57 <temoto> IceDane, for example, it's one of two common ways to introduce IO into a pure functional language. The other way is uniqueness types.
13:42:34 <Lemmih> IceDane: Try passing around a state argument without using a monad.
13:42:38 <temoto> theclaw, no, i never used more than one transformer.
13:42:55 <IceDane> Lemmih: I saw the irc bot tutorial, where he used a monad to preserve some kind of state globally
13:43:08 <theclaw> temoto: oh, okay (I need the state, error and parsec monad)
13:43:22 <Lemmih> IceDane: Smaller examples are much easier to grok.
13:43:45 <IceDane> Lemmih: Yeah, I assume so
13:43:51 <IceDane> I'll check my book
13:43:57 <Veinor> Is there a library analogous to imagemagick?
13:44:10 <temoto> theclaw, i separated error+parsec and error+IO. Parsec has implicit state, btw.
13:44:24 <jmcarthur> IceDane: monads are a common api for things that are related (although they may not always seem related at first). it helps you write more generic code, and when things expose monadic APIs and you know a set of monadic functions then you already know that part of the API
13:44:28 <theclaw> temoto: yes, but it's a backtracking state
13:45:21 <jmcarthur> IceDane: monads aren't really any more special than any other type class. it's all about writing more general code and using overloading to control expectations about how an interface works
13:45:34 <jmcarthur> s/control/guide/
13:45:41 <IceDane> jmcarthur: I think I understand. I'll just have to come up with something that needs monads to work properly(or to be written optimally), and learn that way.
13:45:58 <jmcarthur> IceDane: you never need monads
13:46:07 <theclaw> temoto: when I have try parser1 <|> parser2, they both get the same state, even if parser1 changes something
13:46:16 <theclaw> temoto: (if I didn't get something wrong)
13:46:24 <jmcarthur> IceDane: just use Monad as a handy tool when you get the chances to do so
13:46:30 <jmcarthur> you will catch on
13:46:32 <temoto> theclaw, obviously, you can at least move IO out of that function.
13:47:02 <theclaw> temoto: I don't need IO at the moment, only state/error
13:47:05 <IceDane> jmcarthur: Alright, thanks.
13:47:11 <ElfArmy> It's not as much as coming up with instances to use monads, it's more about recognising what you're writing already is monadic in nature, and leveraging the monadic interface that allows you to prevent repetition.
13:47:49 <kwos> but monadic interface is actually quite common
13:48:08 <MissPiggy> what /is/ the best way to get a ghci repl inside a web browser?
13:48:09 <kwos> despite that notion may seem odd at first
13:48:32 <jmcarthur> IceDane: as i think kwos is trying to imply, you might "need" Monad when the only interface exposed for something is monadic. IO is an example, i guess
13:48:46 <Lemmih> MissPiggy: webirc + lambdabot?
13:49:20 <kwos> hmm.. an idea
13:49:24 <kwos> start with applicative functors
13:49:27 <jmcarthur> the trick when you are forced to use Monad is to just pretend you are using less generic functions than you really are... (>>=) :: IO a -> (a -> IO b) -> IO b, etc.
13:49:41 <temoto> theclaw, well suppose error is outside, it is thrown when parser fails, then you have state+parsec = 2 monads, one transformer. :)
13:49:45 <IceDane> Heh, it's just much more abstract of a programming concept than anything else I've ever come into touch with before
13:49:58 <kwos> IceDane: not really, it just sounds scary
13:50:01 <jmcarthur> IceDane: trust me, there is a lot more beyond Monad :)
13:50:03 <kwos> you can treat them as just another interface
13:50:08 <kwos> like any interface in java
13:50:27 <kwos> but such that when you write your own, you need to verify some properties -- again, just some invariants
13:51:06 <kwos> because essentially whatever implements the interface and conforms to laws is a monad, by definition
13:51:06 <jmcarthur> IceDane: what makes a monad special is that it separates side effects (meaning something more general than just I/O) from your code, which is something that most newcomers aren't used to
13:51:15 <theclaw> temoto: I don't quite get that, you mean state+parsec as an inner monad for ErrorT? how would that be possible?
13:51:35 <jmcarthur> IceDane: most people are used to just mixing such concepts all together with their main program logic and don't realize the opportunity they are missing
13:51:39 <MissPiggy> you know PLT?
13:51:44 <kwos> IceDane: radical idea, start with applicative functors, and then move to monads
13:51:54 <IceDane> kwos: haha, I'll look them up
13:51:55 <MissPiggy> the repl lets you have imagne and stuff <http://docs.plt-scheme.org/quick/>
13:52:00 <kwos> IceDane: there's a good and very accessible paper by patterson and mcbride
13:52:07 <MissPiggy> anyone that knows HTML want to help me make this ?
13:52:28 <kwos> IceDane: they also discuss what the difference beteen monad and an applicative functor is (every moand is an applicative functor)
13:52:34 <jmcarthur> kwos: not that radical ;)   i normally advise to start with Functor
13:52:42 <kwos> yeah
13:52:51 <kwos> IceDane: and then it will come to you naturally
13:53:03 <MissPiggy> or should I just do a really rtivial version and let people hack it if they want
13:54:14 <temoto> theclaw, no, i mean StateT as outer monad for Parsec.
13:54:16 * kwos finds it funny that ages ago he heard that "moands are just monoids in the category of endofunctors" and was baffled and now finds it such an obvious description
13:54:28 <IceDane> hahaha
13:54:29 <jmcarthur> kwos: yeah, really
13:54:29 <IceDane> oh god.
13:54:32 <gwern> kwos: I think that's part of the joke
13:54:38 <gwern> the ha ha only serious vein
13:54:40 <IceDane> Well, thanks for the help, I'll look up applicative functors and keep reading.
13:54:44 <jmcarthur> IceDane: you will become a nerd just like the rest of us ;)
13:54:59 <kwos> IceDane: patterson and mcbride are your friends in that quest :)
13:55:59 <IceDane> Alright, thanks =)
13:56:23 <temoto> MissPiggy, i know html
13:57:05 <theclaw> temoto: hrm.
13:57:17 <theclaw> temoto: but I don't see where's the error monad then
13:58:22 <temoto> theclaw, parse returns Either (Left err) (Right parsed-stuff). That was enough for me.
13:58:33 <MissPiggy> temoto what do you think of the PLT thing?
13:59:01 <theclaw> temoto: oh, okay
13:59:26 <temoto> MissPiggy, i don't like Lisp syntax. But if i were lisper, PLT is probably the best thing i know.
13:59:37 <MissPiggy> temoto I just mean having pictures in the REPL
13:59:51 <augur> REPL! :D
14:00:11 <MissPiggy> hehe
14:00:33 <gwern> whenever I hear about awesome new stuff like typed scheme, PLT seems to be involved
14:00:54 <temoto> MissPiggy, PLT is not about pictures in REPL lol. But yeah, i like they don't constrain editor to text.
14:01:05 <kmc_> IceDane: i have some small bits of advice about learning monads
14:01:07 <MissPiggy> temoto, did you see my link??
14:01:11 <kmc_> firstly that IO is a bad example of a monad
14:01:24 <temoto> MissPiggy, yes, i even tried PLT on my box.
14:01:45 <benmachine> you can do IO without understanding monads
14:01:45 <kmc_> second is that, despite the hype, they're not very complicated
14:01:59 <benmachine> you can probably do monads without understanding monads :P
14:02:02 <kmc_> Monad is just a typeclass; it only has two essential methods
14:02:12 <benmachine> but how well that works for you depends on your methods of learning, I suppose
14:02:48 <mauke> well, you can just understand concatMap
14:03:15 <MissPiggy> oh rubbish you can't do AJAX locally can you?
14:03:36 <MissPiggy> so you can't make a javascript thing to load ghc output
14:03:42 <mauke> I can because I'm awesome like that
14:03:46 <kmc_> IceDane: you can define your own type that's like Maybe, and then make it an instance of Monad in three lines of code
14:03:51 <kmc_> that takes a lot of the mystery out of it
14:04:08 <temoto> MissPiggy, of course you can to first, you have to do some server-side application to second.
14:04:34 <temoto> MissPiggy, in this case server-side means out-of-browser. Totally possible on localhost.
14:04:55 <MissPiggy> okay
14:05:23 <MissPiggy> suppose I have a webserver in haskell
14:05:40 <MissPiggy> how would you get the page to load a bit more info from that server and add it to the current page?
14:06:44 <mauke> connect to 127.1:80, GET /moar
14:07:02 <MissPiggy> using XMLHTTPrequest or whatever it is called?
14:07:14 <kmc_> yes, you'd do that
14:07:30 <MissPiggy> what's the javascript function?
14:07:32 <temoto> MissPiggy, to get the job done you would avoid direct usage of XHR at all costs.
14:07:42 <kmc_> read about AJAX
14:07:45 <MissPiggy> temoto, what would be the best then?
14:08:05 <temoto> MissPiggy, use some kind of framework, like jQuery, Prototype, Dojo, Mootools.
14:08:10 <MissPiggy> :|
14:08:19 <kmc_> XHR has nothing to do with XML, it's just the way javascript code retrieves a document over HTTP
14:08:27 <temoto> MissPiggy, then it's as simple as $.load("/foo")
14:08:38 <kmc_> what you send can be JSON, javascript, HTML fragment, XML, whatever
14:08:57 <MissPiggy> temoto, it is a bit intimidating for me when something is called 'framework' but i will try
14:09:04 <kmc_> jQuery is nice
14:09:07 <kmc_> pretty simple too
14:09:15 <MissPiggy> kmc_, yeah I was thinking plain HTML
14:09:20 <kmc_> i've used it for basic things and found the learning curve to be fast enough
14:09:26 <temoto> MissPiggy, okay, we will call it a library and not telling anyone :)
14:09:30 <MissPiggy> :p
14:09:36 <kmc_> jQuery is just a JS file you include in your page; it doesn't require any server support
14:09:45 <MissPiggy> jQuery is a new kind of JavaScript Library.
14:09:54 <kmc_> a new kind of science
14:10:08 <Twey> jQuery is a big fat monad
14:10:09 <MissPiggy> hehe "Congratulations! You just ran a snippet of jQuery code. Wasn't that easy?"
14:10:15 <MissPiggy> they really don't want to scare me off
14:10:25 <MissPiggy> Just like going to the dentist
14:10:31 <Twey> Haha
14:13:10 <pantsman> the dentist is terrifying... http://failblog.org/2010/01/26/mask-fail/
14:13:27 <temoto> Advanced javascripters were actually scaring me with all kinds of troubles jQuery can give. But i seldom ran into those.
14:14:45 <monadic_kid> Did you guys get my last message before registering?
14:15:08 <aavogt> no
14:15:18 <monadic_kid> nicer way to get rid of excessive liftIO?
14:15:47 <aavogt> is your IO interspersed with other stuff?
14:15:55 <monadic_kid> yep
14:16:02 <aavogt> or is it a bunch of IO, then some lookup, then ...
14:16:19 <aavogt> by lookup I mean whatever else your Monad does
14:17:10 <aavogt> you can 1) rename it to IO, or 2) find a library (or make one) that has all those regular IO functions already lifted to  MonadIO m
14:17:17 <aavogt> err, io = liftIO
14:17:27 <aavogt> then it's less annoying
14:18:24 <monadic_kid> it's the former, interspersed and what do you mean by No. 1?
14:18:32 <monadic_kid> No 2. is not feasible
14:18:57 <aavogt> I mean rename liftIO so it's less intrusive
14:21:24 <temoto> 3) unsafePerformIO lol
14:22:11 <temoto> You shouldn't really use that :)
14:24:57 <pastorn> @type liftIO
14:24:58 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
14:25:18 <MissPiggy> does anyone have a really really simple webserver in haskell?
14:29:40 <temoto> MissPiggy, you don't need a webserver in haskell to execute ghc /tmp/file.
14:31:18 <temoto> MissPiggy, you want to make a web version of lambdabot, right?
14:32:56 <dons> note that lispy had lambdabot running on the web (in a sandbox) 5 years ago
14:34:35 <jfischoff> has anyone put together a somesort of replay system for Haskell? Its seems like it would be easier then in other languages
14:34:46 * Alpounet began learning C++ 5 years ago.
14:34:47 <jmcarthur> replay?
14:35:17 <Alpounet> I wish I started learning Haskell instead.
14:35:32 <Zao> Alpounet: Time well spent, I'd say.
14:35:42 <byorgey> jfischoff: you mean something for observing animations of reductions?
14:35:55 <byorgey> I think something like that exists, I forget where though
14:35:57 <jrockway> wow, interesting: http://www.twistedsquare.com/Haskell-Experience.pdf
14:36:09 <jrockway> this guy has almost the exact same problem i do
14:36:20 <Alpounet> Zao, actually I don't really regret it. I've been far in learning C++, and saw the metaprogramming power, thus got some functional programming basics, and then OCaml then Haskell :-)
14:36:27 <jrockway> (using a WriterT to collect warnings, and then using too much memory)
14:36:43 <jrockway> anyone have a better solution than "don't do that?"
14:36:51 <gwern> hm. we don't have 'time travelling' debuggers?
14:36:59 <pikhq> ... Metaprogramming power? C++?
14:37:05 <kmc_> oh dear
14:37:08 <jmcarthur> jrockway: are you by chance using WriterT String?
14:37:13 <pikhq> What does it have, beyond C macros and type-level lambda?
14:37:15 <medfly> I think C++ or C++ like languages are necessary for making a living, no?
14:37:17 <jrockway> [String] yeah
14:37:20 <jrockway> i know what the problem is
14:37:25 <jrockway> `mappend` is thunked until the very end
14:37:25 <jmcarthur> jrockway: DList, baby
14:37:28 <kmc_> C++'s "type level lambda" is a turing complete programming language
14:37:30 <kmc_> an awful one
14:37:34 <jrockway> ok, that was going to be my next thing to try
14:37:40 <kmc_> but just enough that you can do very complicated things
14:37:45 <jrockway> (and after that, writing my own writer)
14:37:46 <benmachine> s/'s "type level lambda"//
14:37:46 <pikhq> kmc_: It is the type-level lambda calculus, in essence.
14:37:47 <jfischoff> byorgey: Not sure, something for beable to debug backwards in time after a crash
14:37:52 <benmachine> (of course)
14:37:54 <pikhq> It's quite painful, but... Yeah.
14:38:00 <kmc_> you should take a look at Boost, they implement things like Maybe and tuples in only a few thousand lines of C++
14:38:06 <byorgey> jfischoff: well, there's the ghc debugger
14:38:06 <jrockway> jmcarthur: thanks!
14:38:08 * benmachine giggles
14:38:10 <jmcarthur> jrockway: Writer is not the problem. it's the particular monoid
14:38:16 <jrockway> odd
14:38:23 <jrockway> i tried my own monoid that i am sure is strict
14:38:31 <pikhq> kmc_: I can implement the same in a couple hundred lines of C.
14:38:31 <jmcarthur> kmc_: lol
14:38:37 <pikhq> Though, that's run-time evaluation.
14:38:43 <jrockway> but the idea of dlists did pop into my head, for some reason
14:38:43 <byorgey> jfischoff: but unlike C, Java, etc., what happens at runtime once your Haskell program has been compiled has so little resemblance to the code you actually wrote that it might not be that useful.
14:38:46 <pikhq> Bit easier to manage.
14:38:50 <jrockway> so it is nice to hear someone that is sure that will work
14:38:52 <jmcarthur> @remember kmc_ you should take a look at Boost, they implement things like Maybe and tuples in only a few thousand lines of C++
14:38:53 <lambdabot> Good to know.
14:38:57 <jrockway> or at least not be a waste of time to try :)
14:39:02 <kmc_> they even have a parser combinator library
14:39:08 <kmc_> it's 100,000 lines of code
14:39:14 <jmcarthur> kmc_: o_O
14:39:21 <jmcarthur> how horrible
14:39:34 <kmc_> it has to use existing C++ operators because you can't define new ones
14:39:37 <jfischoff> byorgey: interesting, still it seems like something logged out input and output of functions might suffice...
14:39:58 <kmc_> it will become more usable in the next C++ standard
14:40:05 <kmc_> which will have this advanced feature called "type inference"
14:40:07 <byorgey> jfischoff: indeed, and there has been some research on adding stack traces to GHC, but it's still experimental
14:40:13 <kmc_> and another advanced feature called "lambda"
14:40:41 <pikhq> kmc_: Eh, C++'s lambda is implementable via a macro.
14:40:51 <jfischoff> byorgey: It is possible that sampling the state every so often would be fine for crash handling.
14:40:54 <Loriel> pikhq: Really?
14:40:56 <jrockway> kmc_: broken implementations of said features, though, of course :)
14:40:59 <pikhq> They allow defining classes in the middle of a function.
14:41:09 <Loriel> Not in the middle of expressions
14:41:14 <jfischoff> byorgey: could be easy to do with template haskell
14:41:21 <temoto> Boost actually has something *like* lambda via some kind of dirty magic.
14:41:26 <pikhq> Oh, right, you need GNU C statement expressions for that.
14:41:27 <Zao> pikhq: Local classes do not have linkage until C++1x.
14:41:30 <kmc_> jrockway: the type inference is very basic, certainly not as powerful as HM.  not sure it's broken for what it claims to be
14:41:54 <byorgey> jfischoff: I'm not sure I understand what you mean.
14:41:54 <jrockway> that's a good point
14:42:00 <Zao> So you couldn't use one of your macro lambdas in say, std::foreach.
14:42:01 <pikhq> Zao: ... Why should they? You would want to just pass around a pointer to an object with operator(), right?
14:42:01 <temoto> @quot Boost
14:42:02 <lambdabot> kmc_ says: you should take a look at Boost, they implement things like Maybe and tuples in only a few thousand lines of C++
14:42:17 <Zao> pikhq: You cannot instantiate any templates with them, among other things.
14:42:18 <pikhq> Zao: ...
14:42:19 <temoto> Yeah, now we have this awesome quote.
14:42:28 <Zao> pikhq: Just about anything taking functors take them by value.
14:42:29 <kmc_> as for lambda, closures have explicit memory management, and they can close by value, pointer, reference, const pointer, const reference, etc.  that's a pain but probably unavoidable for anything that will integrate with the rest of C++
14:42:33 <medfly> it's funny how much this channel discusses it's dislike of C++.
14:42:37 <pikhq> Zao: That's dumbtarded.
14:42:37 <jmcarthur> kmc_: the type inference is only for local variables, isn't it?
14:42:44 <kmc_> i think it's for variables, period
14:42:52 <benmachine> medfly: hilarious, I agree
14:42:52 <jmcarthur> kmc_: function parameters?
14:43:05 <kmc_> don't know about thosne
14:43:11 <jrockway> medfly: use perl for a while
14:43:19 <Loriel> I think the type inference is only for things you initialise right away
14:43:23 <jrockway> it helps you build up an immunity to getting mad about people that don't like your language
14:43:29 <Loriel> like where you say yo_use_type_inference_here foo = bar
14:43:36 <jmcarthur> var
14:43:36 <medfly> I actually use PHP.
14:43:41 <kmc_> "auto"
14:43:45 <jrockway> medfly: lies
14:43:47 <jfischoff> bygorey: I am assuming the program is single threading for now, but if every 100 functions calls the input of the currently executing function is logged out, it could allow crashes to be debugged after the fact pretty easily
14:43:49 <Loriel> var is the c# guys isn't it
14:43:51 <dolio> Who keeps brining it up?
14:43:52 <ahf> you can't use auto in function parameter list.
14:43:52 <jmcarthur> auto
14:43:54 <pikhq> kmc_: Basically, it's only easily usable if you use Boehm GC. Which means no destructors...
14:43:55 <Zao> pikhq: It's idiomatic. Don't try to change how things always have been and always will.
14:43:58 <jrockway> nobody that knows about the existence of haskell admits to using PHP ;) ;)
14:44:05 <medfly> hehe
14:44:19 <kmc_> pikhq: nah, i think lambda will be pretty usable with smart pointers, by C++ standards
14:44:20 <Zao> jrockway: I used Perl yesterday. To generate Haskell and C :)
14:44:26 <kmc_> there will of course be a smart pointer that forwards operator()
14:44:26 <jfischoff> bygorey: you would never guess it, but english is my first language ;)
14:44:40 <pikhq> kmc_: And smart pointers aren't all that usable. :P
14:44:43 <Loriel> Are you not supposed to stash lambdas into std/boost::functio<...> objects anyway?
14:44:46 <Zao> kmc_: auto, decltype and lambdas make C++ much nicer to use.
14:44:50 <Loriel> I mean, if you end up naming them after all
14:45:12 <kmc_> Loriel: i think a lambda expression evaluates to an object of std::function type
14:45:15 <Zao> Loriel: I believe you need linkage for doing that as.
14:45:17 <monadic_kid> Loriel: no use auto but if you wanna store it use std::function
14:45:20 <kmc_> which is a fairly unspecified type that has operator()
14:45:32 <Zao> kmc_: It evaluates to something that you can shove into a std::function.
14:45:35 <kmc_> ah
14:45:42 <monadic_kid> Loriel: if it's going to be used in a local scope you can use auto to store lambda expression
14:45:44 <Loriel> Zao: Oh, probably, I was trying to respond to the smart pointers thing.
14:45:53 <kmc_> it makes me sad that #haskell has become ##c++1x
14:45:59 <Loriel> kmc_: I think they are defined by translation to an internal-named struct type
14:46:05 <Zao> kmc_: It's a brief discourse.
14:46:13 <monadic_kid> kmc_: no lamdba doesn't have a  type of std::function
14:46:17 <Zao> Loriel: Much like anonymous namespaces, I guess.
14:46:25 <benmachine> it makes me happy that #haskell has an opinion on a wide range of issues
14:46:34 <benmachine> and frequently a well-informed one
14:46:47 <pikhq> kmc_: The first thing I intend to do with a C++1x implementation is some lazy C++.
14:46:50 <pikhq> Hooray, thunks.
14:46:55 <monadic_kid> the type of lambda expression in C++0x is local generated struct with functional call operator overload, you cannot name the type of each lambda expression
14:47:17 <Loriel> It is neat that they are defining it like that instead of proclaiming that it is magic.
14:47:23 <kmc_> ah right.  but somehow std::function will be constructible from any of them?
14:47:40 <kmc_> Loriel: i'm not convinced, in most languages functions are a built in abstract type
14:47:45 <Loriel> kmc_: Yeah, std::function can be constructed from pretty much anything that works like a function right now
14:47:49 <jmcarthur> the first thing i intend to do with a C++1x implementation is close my eyes, cover my ears, and pretend the evil isn't there ;)
14:47:52 <kmc_> Loriel: ah, because it's templated
14:47:53 <monadic_kid> of-course, the type is deduced from template function arguments so doesn't need to be named
14:47:59 <kmc_> if you only want one built in abstract type, functions are a good one to pick
14:48:02 <Zao> kmc_: It has linkage, so whatever function template std::function's ctor has and the internal class template std::function uses can be instantiated with it.
14:48:10 <Loriel> It is only templated on the function parameter types and the return type
14:48:27 <Loriel> There are probably smaller templates inside that template, I guess, but they are hidden from the user
14:48:30 <Zao> Loriel: I would fathom a guess that the function is a function template.
14:48:37 <Zao> Err, ctor.
14:48:53 <Loriel> I think I misunderstood kmc, yeah
14:49:18 <HugoDaniel> is it possible to add two monads of the same type ?
14:49:26 <Zao> "add"?
14:49:30 <Loriel> I was trying to get that that you can have a single std::function<> instance and you can assign a regular function to it in one line and one of those fancy lambdas or a regular function-style object in the next line.
14:49:39 <kmc_> HugoDaniel: you mean, is it possible to add two values of type (m a) for some Monad m?
14:49:41 <Loriel> so the exact kind of function is not part of *that* template
14:49:45 <kmc_> "a monad" is a type constructor, not a value
14:49:48 <HugoDaniel> yes
14:49:52 <HugoDaniel> that kmc_ :D
14:49:57 <kmc_> IO is a monad, Maybe is a monad, getChar is not
14:49:58 <Loriel> Do you want liftM2 (+)
14:50:06 <kmc_> "add" in what sense
14:50:08 <HugoDaniel> no, not liftM2
14:50:10 <Zao> @type liftM2 (+)
14:50:11 <lambdabot> forall a1 (m :: * -> *). (Num a1, Monad m) => m a1 -> m a1 -> m a1
14:50:13 <kmc_> do you mean mplus?
14:50:15 <kmc_> :t mplus
14:50:16 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
14:50:20 <kmc_> > Nothing `mplus` (Just 3)
14:50:21 <lambdabot>   Just 3
14:50:23 <kmc_> > (Just 2) `mplus` (Just 3)
14:50:24 <lambdabot>   Just 2
14:50:25 <HugoDaniel> yes, i mean to thread the state ...
14:50:32 <kmc_> monads don't have "state" in general
14:50:33 <kmc_> some do
14:50:38 <HugoDaniel> sorry
14:50:42 <kmc_> HugoDaniel: do you just want to do A then B?
14:50:42 <Zao> @type (>>)
14:50:43 <HugoDaniel> i didn't meant state
14:50:43 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
14:50:44 <HugoDaniel> i meant input
14:50:50 <Zao> @type (>>=)
14:50:51 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
14:50:52 <kmc_> monads don't have "input" in general
14:50:54 <HugoDaniel> i just want to thread input
14:51:14 <Loriel> (I will forever feel funny talking about C++ because I cannot say 'functor' to mean 'object with operator()' anymore without feeling ridiculous. Thanks, Haskell!)
14:51:15 <kmc_> HugoDaniel: it sounds like what you want can be accomplished with (>>=) or with the "do" notation
14:51:21 <kmc_> Loriel: indeed
14:51:38 <HugoDaniel> yes, it can...
14:51:39 <MissPiggy> temoto, not like lambdabot
14:51:45 <Zao> Loriel: I love the term, as it makes people squirm in here.
14:51:57 <MissPiggy> what I need is like a REPL but it should be able to do pretty graphics as well as text
14:52:05 <kmc_> it's brilliant marketing, they took a flaw of the language and gave it a fancy name so people would consider it a feature instead of a bug
14:52:06 <HugoDaniel> ok, thanks
14:52:12 <MissPiggy> im going to make it in PLT because that seems easiest
14:52:24 <kmc_> now i'm sure many would say the same about Haskell monads
14:52:39 <kmc_> but i'm prepared to defend those on technical merit beyond having a cool name ;)
14:53:06 <Loriel> kmc_: If you consider it from the perspective of C, C++'s ability to have 'functors' instead of this whole "okay, so give me a function pointer for this callback and an opaque pointer to some state you want it to be called with" business is kind of a feature
14:53:21 <lispy> FWIW, Haskell on the web via lambdabot is very much still possible to resurrect if people are interested in it
14:53:24 <Loriel> "yeah, eh, whatever, give me anything that responds to ()"
14:53:25 <Zao> Loriel: Especially as they can be overloaded.
14:53:37 <lispy> ?quote skynet
14:53:38 <lambdabot> dons says: note down this date, people, 13-09-2006. today lambdabot == skynet
14:53:39 <Zao> (see the visitor for boost::variant)
14:53:40 <HugoDaniel> kmc_: are you going to the zurihac ?
14:53:42 <lispy> That was the day we got it working
14:53:48 * Loriel is an unrepenting C++ fanboy
14:53:50 <temoto> MissPiggy, i'd take lambdabot and render some types in a special way.
14:53:52 <kmc_> HugoDaniel: no
14:53:57 <kmc_> Loriel: sure, it's better
14:54:01 <MissPiggy> temoto, alright
14:54:06 <kmc_> but it's still a workaround for a basic flaw
14:54:08 <temoto> MissPiggy, but that's just me.
14:54:10 <MissPiggy> yes okay it does make sense to use lambdabot
14:54:18 <monadic_kid> Zao: you mean static visitors, not variant itself
14:54:25 <jmcarthur> > Just 5 +^ Just 6
14:54:26 <lambdabot>   Not in scope: `+^'
14:54:30 <jmcarthur> aw, it's been reset
14:54:32 <solrize> s/monad/WFT/
14:54:35 <kmc_> which flaw is also disguised up by the myth that "functional" and "imperative" are irreconcilable "paradigms" instead of feature-sets that can coexist
14:54:42 <Alpounet> <Loriel> (I will forever feel funny talking about C++ because I cannot say 'functor' to mean 'object with operator()' anymore without feeling ridiculous. Thanks, Haskell!) <<< haha the very same for me
14:54:43 <Zao> monadic_kid: Correct.
14:54:44 <solrize> warm fuzzy thing
14:54:53 <kmc_> @remember Loriel I will forever feel funny talking about C++ because I cannot say 'functor' to mean 'object with operator()' anymore without feeling ridiculous. Thanks, Haskell!
14:54:53 <lambdabot> Done.
14:55:23 <jrockway> amusing
14:55:24 <Zao> I wrote some horribly imperative Haskell the other day.
14:55:34 <Loriel> kmc_: I thought that C++'s shtick was to be "multi-paradigm" compared to its competitors which were all about OOP
14:55:35 <jrockway> we have this in-house library that calls everything a functor
14:55:38 <jrockway> it drives me insane
14:55:49 <Loriel> so kind of reconciling it :I
14:55:50 <jrockway> a function that calculates the date difference between two dates is not a functor
14:55:52 <kmc_> Loriel: i don't think anyone says that
14:55:53 <jrockway> it's a function.
14:55:59 <kmc_> anyway if that was their goal, they failed spectacularly
14:56:14 <Loriel> C++'s wikipedia article says multi-paradigm in the first sentence
14:56:15 <jrockway> glad i haven't had to bind that library to haskell yet :)
14:56:22 <Loriel> after calling it "free-form", which might be rather telling too
14:56:25 <kmc_> or perhaps they succeeded in making the OOP support as bad as the support for other stuff
14:56:26 <dolio> What are the paradigms?
14:56:31 <etpace> @hoogle xor
14:56:31 <lambdabot> Data.Bits xor :: Bits a => a -> a -> a
14:56:40 <dolio> Bad OO and non-OO imperative?
14:56:50 <kmc_> brainfuck is a multiparadigm language.  it can host a C interpreter *and* a LISP interpreter!
14:57:08 <temoto> See, imperative + procedural is already a multiparadigm language.
14:57:16 <Loriel> dolio: Bad OO and non-OO imperative and bad functional and bad generic I guess
14:57:17 <jmcarthur> i still like to maintain a distinction between imperative and declarative
14:57:41 <solrize> http://www.cs.brown.edu/~sk/Publications/Papers/Published/sk-teach-pl-post-linnaean/     Abstract
14:57:41 <dolio> Generic isn't a programming paradigm.
14:57:41 <solrize>     Programming language ‘‘paradigms’’ are a moribund and tedious legacy of a bygone age.
14:58:54 <kmc_> Haskell is the best multiparadigm language I know
14:59:04 <kmc_> LISP is a metalanguage for implementing custom multiparadigm languages
14:59:14 <kmc_> in that sense LISP only has one paradigm ;)
14:59:21 <dolio> Macros?
14:59:25 <kmc_> yeah
14:59:28 <Loriel> dolio: The C++ crowd seems to disagree, welp
14:59:32 <Alpounet> kmc, C++ IS multiparadigm
14:59:39 <Loriel> Wikipedia lists "Generic" in their programming paradigms sidebox, anyway!
14:59:49 <MissPiggy> Wikipedia is mostly wrong
14:59:59 <Loriel> I guess I am not making an argument about veracity here but just that some people are making that argument
15:00:00 <kmc_> it seems like these days we should focus on, for example, "paradigms" for concurrency or parallelism
15:00:00 <MissPiggy> or at least confused
15:00:00 <Alpounet> dolio, would you say Generative is ?
15:00:04 <kmc_> rather than paradigms for how you add two integers
15:00:11 <MissPiggy> lispy what is this lambdabot web thing?
15:00:21 <kmc_> C: mutate a stack variable
15:00:22 <MissPiggy> I mean maybe I can take it and just add a bit to it and be done
15:00:23 <jmcarthur> what is a paradigm?
15:00:28 <kmc_> Java: instantiate the AbstractIntegerAdditionFactory
15:00:33 <Loriel> kmc_: I suppose back in the day being able to write a container type that could hold both ints and floats without any ugly typecasting was a big deal
15:00:36 <kmc_> Haskell: wrap the Integers in Sum, use the Monoid instance
15:00:40 <dolio> Alpounet: I'm not sure what that word would mean.
15:00:47 <lispy> MissPiggy: it was a cgi wrapper around lambdabot (built on top of goa) and then a javascript part to make the cgi script palatable for webusage
15:00:54 <kmc_> Loriel: you can do that with C macros
15:00:58 <kmc_> and hide the ugly typecasting
15:01:07 <Alpounet> dolio, I refer mostly to http://www.generative-programming.org/
15:01:07 <MissPiggy> lispy, wow I could use that!
15:01:09 <Alpounet> (the book)
15:01:12 <Loriel> Okay, let us say C++ made it marginally more palatable
15:01:17 <MissPiggy> do you know if the source is around
15:01:34 <Loriel> and more so than java does to this day, I guess
15:01:52 <Alpounet> it's that book that popularized the "generative programming" expression, AFAIK
15:02:00 <lispy> MissPiggy: I'll have to look and see where the source it.  It broke when lambdabot's config system changed.  Otherwise it should be workable.  First step would be to get goa installed and setup.  If you can make it that far we can get the rest working again.
15:02:29 <MissPiggy> okay ill try and get goa
15:04:00 <etpace> Does anyone know of a galois field/GF(256) library, and if not, any help implementing multiplication? the algorithm given on wikipedia is very imperative
15:04:24 <solrize> etpace, gf(256) multiplication is usually just done with table lookups
15:04:29 <temoto> @src Sum
15:04:30 <lambdabot> Source not found. You untyped fool!
15:04:38 <dolio> Alpounet: The topics in "About This Book" just looks like a not-particularly-related list of features.
15:04:39 <solrize> i.e. make tables of logs and antilogs
15:04:40 <temoto> kmc, what is that Sum?
15:04:53 <solrize> then ab = antilog(log a + log b)
15:04:56 <MissPiggy> hm cabal install lamdabot? does not work
15:04:59 <MissPiggy> but cabal install goa does
15:05:00 <etpace> hmm
15:05:22 <idnar> temoto: newtype Sum a = Sum { getSum :: a }
15:05:28 <dolio> So I'm not exactly sure what generative programming is supposed to be.
15:05:37 <idnar> temoto: it's just a trivial wrapper for the purposes of defining a Monoid instance
15:06:02 <dolio> On their list is "aspect oriented programming" which I could possibly be bullied in to dubbing a "paradigm".
15:06:16 <temoto> idnar, but where's the (+) implementation?
15:06:27 <dolio> Generally I'd associate the word with things like: imperative, OO, functional, logic.
15:06:42 <idnar> temoto: the actual instance is defined as instance Num a => Monoid (Sum a)
15:06:48 <idnar> temoto: so (+) comes from the Num instance for a
15:07:08 <Loriel> I think C++ templates are crazy enough that none of the other paradigms want anything to do with them
15:07:08 <temoto> idnar, is that instance defined in standard library?
15:07:29 <kmc_> ain't goin' to goa
15:07:38 <idnar> temoto: Sum and the corresponding Monoid instance are defined in Data.Monoid
15:08:11 <dolio> But those aren't really mutually exclusive in any compelling way.
15:08:39 <Alpounet> dolio, hmm, generative programming is about using templates to generate code, not for simple genericity
15:08:54 <pikhq> Loriel: Other paradigms do them better.
15:09:13 <kmc_> everyone learns C++ templates first as being a dumb macro processor.  they would be a much better feature if that were actually the case.
15:09:15 <pikhq> Loriel: By making the runtime code execution useful, rather than barely TC.
15:10:00 <MissPiggy> Copying patch 599/1875
15:10:02 <MissPiggy> forgoodness sake
15:10:07 <MissPiggy> I just want to download like 3 files
15:10:10 <kmc_> hehehe
15:10:35 <idnar> if that's darcs, --lazy or --partial might be of help
15:10:52 <temoto> git clone has something like --deep 1 which doesn't copy history, i belive, darcs ought to have similar option.
15:11:26 <MissPiggy> ah my ghc is too new for lambadbot
15:11:41 <idnar> I think --lazy may only work with hashed and darcs-2 repos; it doesn't fetch the patches right away, but any later operation that requires the actual patches will cause them to be fetched
15:11:48 <jmcarthur> temoto: darcs is a little different from git though. it doesn't have a "history," just a collection of patches
15:11:50 <idnar> (but only the patches that are needed)
15:11:52 <MissPiggy> yeah I think I give up on the lambdabot thing
15:12:03 <kmc_> git is sort of the opposite -- patches and diffs are implicit
15:12:10 <kmc_> i really like the simplicity of the git data model
15:12:12 <dolio> Alpounet: Generally, I suppose I'd associate a paradigm with a mindset you're supposed to have while programming.
15:12:16 <jlouis> kmc_: mmm
15:12:24 <MissPiggy> still want to see its source code :[
15:12:24 <jmcarthur> i was about to say i like the simplicity of the darcs model
15:12:25 <temoto> jmcarthur, and an order in which those patches are applied, which is called history :)
15:12:31 <kmc_> heh jmcarthur
15:12:37 <kmc_> i don't know anything about the darcs data model
15:12:39 <jmcarthur> temoto: nope, the patches are commutative aside from dependencies
15:12:44 <sshc> how do I get GHC working with FlexibleContents extension?
15:12:49 <Alpounet> dolio, it's hard to exlain in a few words what generative programming consists in
15:12:57 <kmc_> -XFlexibleContexts
15:12:59 <kmc_> on the cmd line
15:13:00 <Loriel> kmc_: I like git, but I cannot really come to terms without seeing git's history snapshots as the kind of patches it handles them as when you merge or rebase
15:13:00 <kmc_> or (better)
15:13:03 <MissPiggy> lispy, do you think the source code is online somewhere?
15:13:06 <kmc_> {-# LANGUAGE FlexibleContexts #-}
15:13:08 <kmc_> at the top of yr. file
15:13:09 <temoto> jmcarthur, dependencies form an implicit order.
15:13:09 <dolio> Alpounet: In imperative programming, you think of programs as a series of instructions. In OO, you think about interacting objects. In functional programming, you think about functions operating on values. In logic programming, you think about collections of logical predicates.
15:13:19 <jmcarthur> temoto: it's more like a makefile that applies patches
15:13:21 <sshc> kmc_: Main.hs: : unsupported extension: FlexibleContents
15:13:27 <kmc_> Cont*ex*ts
15:13:33 <jmcarthur> temoto: sort of, but not a total ordering
15:13:36 <kmc_> there is no FlexibleContents extension
15:13:42 <sshc> kmc_: oh, contexts
15:13:42 <dolio> I don't think writing meta-code to generate the actual code of your programs is really comparable.
15:14:07 <Alpounet> yeah
15:14:18 <temoto> jmcarthur, yes, i like the idea. I miss that in git sometimes.
15:14:18 <Alpounet> but it seems it's been accepted to call it a "paradigm"
15:14:24 <Alpounet> so I stuck with that for the moment.
15:14:54 <jmcarthur> temoto: i switched from darcs to git for a year and then back to darcs. there are things i like about both
15:15:24 <temoto> jmcarthur, like speed and exit() calls in libgit? :)
15:15:34 <temoto> it's abort() even
15:15:44 <jmcarthur> temoto: i actually don't feel like speed is an issue for me
15:16:02 <jmcarthur> and exit calls in libgit sounds absolutely horrible
15:16:09 <jrockway> well, at least there is libgit now
15:16:19 <temoto> It wasn't designed to be a lib. :)
15:16:30 <jrockway> most of the programs are still duct-taped-together shell scripts and c apps
15:16:30 <kmc_> ah that's not so bad
15:16:33 <kmc_> setjmp()
15:16:36 <kmc_> then atexit() longjmp()
15:16:45 <kmc_> problem solved
15:16:46 <jrockway> fine if you're a user, not fine when you want to write programs to interact with git
15:16:57 <jmcarthur> most programs should be libraries first, in my completely meaningless and subjective opinion
15:17:00 <jrockway> linus doesn't believe in exceptions (probably)
15:17:11 <temoto> jmcarthur, in mine too.
15:17:19 <kmc_> if you return error codes in C, people will ignore them anyway
15:17:43 <jrockway> jmcarthur: i think anyone would agree with you
15:17:50 <jrockway> i don't get why so many C apps are not libraries
15:17:54 <Loriel> kmc_: I spent half an hour last weekend coming up with entertaining ways to silence gcc's unused return value warnings
15:17:59 <Loriel> so that I could get stuff to compile with -Werror
15:18:02 <jmcarthur> jrockway: because not everyone agrees with me
15:18:09 <kmc_> Loriel: what's the most entertaining one?
15:18:10 <temoto> That's how they found another bug in samba: git checked return code of fclose() :)
15:18:18 <jrockway> (gpg was like that for a while too, and it made dealing with anything pgp-related a real PITA)
15:18:19 <kmc_> for many use cases, it really is fine for a library to define its API as aborting the program upon a serious error
15:18:27 <jrockway> now there is a library that forks gpg for you with the right settings
15:18:32 <jrockway> horrible horrible hack
15:18:32 <kmc_> a lot of production critical software even runs this way
15:18:35 <kmc_> because of course it might crash anyway
15:18:43 <kmc_> so of course you must have a wrapper to restart from a clean state
15:18:54 <kmc_> and restarting from a clean state is much better than trying to fix a broken state
15:18:55 <pikhq> jrockway: In GPG's case, that's also a *legal* hack.
15:19:02 <Loriel> kmc_: doing if (foo() == -1) Failure("some pretentious description"); where Failure /* TODO: maybe we should handle this */
15:19:03 <pikhq> jrockway: GPG is GPL. The library is LGPL.
15:19:03 <jrockway> really?
15:19:14 <Loriel> If I was any good at it it probably would not have taken me half an hour >:(
15:19:17 <pikhq> If GPG weren't GPL, they would have made GPG into a library.
15:19:18 <jrockway> i thought it was for being able to lock pages without requiring your app to be setuid root
15:19:24 <jrockway> pikhq: strange
15:19:29 <kmc_> jrockway: with capabilities sure
15:19:37 <jrockway> i was writing a GPLd app that didn't need locked pages, so i would have been fine with a library
15:19:38 <jmcarthur> kmc_: i would prefer a process-oriented environment for critical software like that. the "library" crashes, but the client code gets an error message and can "restart" the library if needed
15:19:40 <kmc_> oh misread
15:19:42 <kmc_> sorry
15:19:42 <jrockway> (signature verification only)
15:19:58 <jrockway> but anyway, library first, and this issue would be  solved for everyone
15:20:07 <jrockway> libgpg = gpl, libgpgme = lgpl
15:20:07 <kmc_> jmcarthur: yeah.  networks of loosely coupled communicating processes
15:20:09 <jrockway> everyone is happy
15:20:14 <jmcarthur> erlang model ftw
15:20:28 <jrockway> the people unwilling to "pay for" the gpl get a slightly more hackish implementation
15:20:32 <jrockway> seems fine to me (tm)
15:21:30 <sshc> how are type classes without any type variables uselful?
15:21:35 <sshc> class Foo where
15:21:37 <kmc_> they're not
15:21:41 <kmc_> i don't think that's legal
15:21:41 <MissPiggy> sshc, I don't think they are??
15:21:51 <sshc> how would such a class be used?
15:21:56 <Loriel> instance Foo where
15:22:02 <jrockway> wha?
15:22:08 <uorygl_> Import the module and provide your own instance.
15:22:12 <kmc_> it would provide a way to enable or disable certain functions
15:22:16 <kmc_> i've never seen this though
15:22:17 <Saizan>  you can have type families like that
15:22:26 <sshc> kmc_: how?
15:22:46 <kmc_> sshc: my ghc does not allow it
15:23:04 <kmc_> in theory, you could write f with an artificially constrained type (Foo) => A -> B
15:23:13 <kmc_> and then you could only use f if you said somewhere "instance Foo"
15:23:19 <kmc_> this doesn't seem too useful
15:23:36 <kmc_> anyway, my GHC does not allow it
15:23:42 <sshc> why not?
15:23:46 <kmc_> why not?
15:23:51 <jrockway> wht not.
15:23:52 <kmc_> i don't know
15:23:53 <sshc> yes, why not?
15:23:57 <jrockway> bah :]
15:23:58 <sshc> which version?
15:23:59 <kmc_> perhaps the Haskell Report says it's not allowed?
15:24:03 <kmc_> 6.10.3
15:24:03 <copumpkin> huh?
15:24:08 <copumpkin> (Foo) => A -> B
15:24:09 <copumpkin> ??
15:24:18 <copumpkin> what does that mean?
15:24:24 <jmcarthur> class Foo where?
15:24:27 <kmc_> yeah, we're discussing 0-param type classes
15:24:30 <kmc_> which are not supported
15:24:30 <sshc> bar :: (Foo) => Int -> Int
15:24:30 <Twey> ZeroParameterTypeClasses?
15:24:31 <copumpkin> what would be the point?
15:24:32 <Twey> Heh
15:24:39 <uorygl_> It's like (Foo a) => A -> B, but without the a.
15:24:47 <gwern> copumpkin: maybe to make sure a typeclass is defined at all?
15:24:49 <copumpkin> a typeclass is an n-ary relation on types
15:24:50 <aavogt> well you can't use (Foo a)
15:24:51 <jrockway> copumpkin: to make your program longer without adding any functionality
15:24:56 <jrockway> good for people migrating over from Java
15:24:58 <copumpkin> what are 0-ary relations?
15:25:00 <copumpkin> ah
15:25:01 <Twey> Haha
15:25:03 <kmc_> jrockway: hehe
15:25:09 <damd> copumpkin: mabey u can force haskell into type inferense
15:25:10 <jrockway> :)
15:25:14 <damd> with this
15:25:14 <kmc_> copumpkin: elements of the 0-ary cartesian product
15:25:16 <copumpkin> damd: ?
15:25:17 <aavogt> you could use  data Empty; .... (Foo Empty) =>
15:25:18 <kmc_> empty tuples of types
15:25:20 <jmcarthur> why enable and disable functions when you could just export or not export them?
15:25:34 <uorygl_> A 0-ary relation is a proposition.
15:25:40 <Twey> aavogt: Is that valid?
15:25:46 <gwern> like, if you wanted to make a haskell '98 test suite on the type level, you could have stuff like 'foo :: (Ix, Read, Show, Eq, Enum, Bounded) => a ->; foo = id'
15:25:48 <jrockway> jmcarthur: because then nobody would be baffled when reading your code
15:25:55 <jmcarthur> *sigh*
15:25:57 <aavogt> Twey: if you've got   instance Foo Empty
15:25:58 <copumpkin> uorygl_: fair enough, but that doesn't really make much sense in the typeclass context
15:25:58 <gwern> if it compiles, then you know part of your implementation is right?
15:25:59 <Twey> :t (+) :: Bounded Void => Int -> Int -> Int
15:26:00 <lambdabot> Not in scope: type constructor or class `Void'
15:26:03 <Twey> Aw
15:26:11 <kmc_> hehe, Bounded Void
15:26:22 <damd> :t Void
15:26:23 <lambdabot> Not in scope: data constructor `Void'
15:26:26 <copumpkin> :k Void
15:26:27 <gwern> @hoogle Void
15:26:27 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
15:26:27 <lambdabot> Not in scope: type constructor or class `Void'
15:26:31 <damd> =( y is not Void define
15:26:32 <copumpkin> :k 1
15:26:33 <lambdabot> *
15:26:35 <kmc_> there exist a, b such that each non-bottom value of type Void appears in enumFromTo a b
15:26:40 <kmc_> therefore, Void should be in Enum and Bounded
15:26:44 <copumpkin> damd: Void would by definition not have a constructor
15:26:47 <sshc> what is the kind of a zero parameter type class?
15:26:53 <kmc_> sshc: *
15:27:02 <copumpkin> %
15:27:05 <aavogt> how do classes have kinds?
15:27:05 <kmc_> i'm not sure we talk about kinds of classes though
15:27:09 <kmc_> but they do sort of have them
15:27:12 <copumpkin> % is the kind of classes that I defined
15:27:19 <jmcarthur> they accept parameters that have kinds
15:27:20 <aavogt> don't the types that inhabit them have kinds
15:27:23 <copumpkin> Monad :: (* -> *) -> %
15:27:23 <kmc_> at least, each parameter to a class has a kind
15:27:29 * MissPiggy hates this part :(
15:27:33 <aavogt> copumpkin: you made that up?
15:27:35 <copumpkin> aavogt: yep
15:27:39 <kmc_> perhaps a class has a tuple-of-kinds as its characterization
15:27:41 <jmcarthur> a reasonable notation
15:28:01 <damd> we should all strive towards a classless society
15:28:17 <kmc_> http://strictlypositive.org/winging-jpgs/
15:28:33 <Twey> Ew, no… voluntary classes beat classlessness hands-down :þ
15:28:41 <kmc_> we need typecastes
15:28:55 <temoto> and pointer arithmetic
15:29:14 <uorygl_> Agda has typecastes. Some types are of type Set, some are of type Set1, some are of type Set2...
15:29:28 <damd> now we see the violence inherent in the system!
15:29:45 <copumpkin> aka universes :P
15:30:32 <lispy> MissPiggy: The server that used to host it is no longer online so I think the code is on a backup drive at my house, but I seriously doubt you could find it online at the moment.
15:30:47 <MissPiggy> lispy, oh well thanks for checking though
15:31:12 <lispy> MissPiggy: np, I'll look for it over the weekend
15:33:26 <mauke> kmc_: it was all nice until the C code showed up :-(
15:34:51 <etpace> whats the pragma to switch off monomorphism
15:35:14 <jrockway> NoMonomorphismRestriction?
15:35:18 <mauke> heh
15:35:26 <mauke> no more Ints!
15:35:47 <uorygl_> It would just make all types also be classes.
15:35:55 <etpace> {-# NoMonomorphismRestriction #-} is unrecognised
15:36:01 <jrockway> LANGUAGE
15:36:03 <uorygl_> {-# OPTIONS -fno-monomorphism-restriction #-}, perhaps?
15:36:11 <jrockway> {-# LANGUAGE ... #-}
15:36:19 <jrockway> this is assuming GHC of course
15:36:30 <uorygl_> instance Bool Integer where True = 1; False = 0
15:36:31 <mauke> not really, LANGUAGE is supposed to be compiler independent
15:36:50 <jrockway> but they are not required to have the NoMonomorphismRestriction pragma :)
15:36:55 <mauke> instance Boolean Integer where toBool = (0 /=)
15:37:08 <uorygl_> @type False
15:37:09 <lambdabot> Bool
15:37:18 <uorygl_> Does the -f prefix denote a language flag?
15:37:43 <mauke> no, -X does
15:37:48 <uorygl_> Probably from the Latin, uh, "flingua".
15:37:51 <jrockway> -X means eXtension, i assume
15:37:56 <uorygl_> What does -f mean?
15:38:19 <jrockway> .oO( we need an "ail" flag )
15:38:30 <aavogt> -funsafe
15:38:38 <jrockway> -Ofun
15:40:54 <mauke> I'm disappointed. There are 2 bugs in 7 lines of code, 2 of which are variable declarations. Conor McBride doesn't know C :-(
15:41:07 <jrockway> Vty?
15:41:23 <mauke> the slides at http://strictlypositive.org/winging-jpgs/
15:41:25 <etpace> bah, generating the log/antilog tables has a bug, and im unable to find where
15:41:30 <etpace> translating algorithms suck :(
15:41:39 <jrockway> quickcheck?
15:42:39 <etpace> i'm not sure how thatll help
15:42:47 <jrockway> mauke: heh
15:42:56 <jrockway> i got half of the name right
15:43:17 <jrockway> but Vty claims to be 5 lines of C and it segfaults on me from time to time, so i assumed that's what the issue is :)
15:43:32 <jrockway> etpace: you will find a value that doesn't meet a property you define
15:43:35 <jrockway> then you will find your bug
15:43:36 <jrockway> right?
15:43:43 * MissPiggy fails
15:44:50 <danderson> so, I'm having some trouble with QuickCheck.
15:45:14 <danderson> I'm defining a couple of Arbitrary instances for my data, and QC is warning me that I haven't explicitly defined coarbitrary for my instance
15:45:31 <jrockway> upgrade to QC2, which puts coarbitrary in another typeclass?
15:45:42 <danderson> thing is, I have no idea what QC uses coarbitrary for, and explanations I see I'm failing to parse
15:45:46 <danderson> there's a QC2?
15:45:49 * danderson hoogles
15:45:53 <jrockway> yeah
15:46:14 <jrockway> dunno what the official verdict is, but it seems very clean to me
15:46:17 <jrockway> and is quite functional
15:46:46 <jrockway> http://hackage.haskell.org/package/QuickCheck-2.1.0.3
15:47:58 <danderson> hmm
15:48:03 <danderson> strange, why am I not using that
15:48:06 <jrockway> btw, reading the source, it appears the default coarbitrary is "id"
15:48:48 <thefeds> !tutorial
15:49:12 <danderson> hmm, weird. Cabal says QC 2.1.0.3 is installed
15:49:21 <danderson> and the docs do say that Coarbitrary is a different type class
15:49:27 <danderson> so, um, bwuh?
15:49:34 <jrockway> time to nopaste your error message then :)
15:49:45 <jrockway> also maybe check ghc-pkg to see that you are actually using version 2
15:50:02 <danderson> hmmm
15:50:05 <monochrom> > text "Gödel ♥ ∀ and ∃"
15:50:07 <lambdabot>   Gödel ♥ ∀ and ∃
15:50:08 <danderson> I must in fact be on crack or something
15:50:14 <temoto> MissPiggy, something wrong with lambdabot?
15:50:14 <danderson> I exited ghci, messed with cabal a bit
15:50:21 <danderson> and now I get no warnings on compile
15:50:23 <aavogt> coarbitrary instances can be written quite mechanically
15:50:25 <MissPiggy> temoto, I can't build it and stuff
15:50:33 <etpace> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16729#a16729 anyone able to spot an obvious algorithm error?
15:50:44 <temoto> MissPiggy, i'd ask its author.
15:50:51 <MissPiggy> temoto, I'm thinking I will try and write this thing using PLT and jQuery but I am not very good at the HTML and all that stuff
15:50:57 <MissPiggy> I just wish someone would do it for me :[
15:51:02 <jrockway> aavogt: what is the coarbitrary instance used for?
15:51:13 <temoto> MissPiggy, ah you wanna be a manager then?
15:51:29 * MissPiggy sort of just wants this thing to already exist so I don' thave to write it..
15:51:37 <mauke> etpace: in Haskell or C (or both?)
15:51:47 <danderson> jrockway: yeah, so I'm not sure what I did. But I'm using the right QC now :-)
15:52:00 <jrockway> problem solved then  :)
15:52:12 <temoto> MissPiggy, well lispy said that it's possible to resurrect lambdabot on web project.
15:52:20 <aavogt> jrockway: it's for shrinking values I think
15:52:25 <etpace> haskell, I took the C code from a website where I'm trying to figure out GF(256)
15:52:26 <jrockway> hmm
15:52:28 <temoto> MissPiggy, then you could add special rendering.
15:52:32 <jrockway> i always implement my own shrink method
15:52:32 <benmachine> etpace: most irrelevant point: you can use hexadecimal literals in haskell too
15:52:38 <benmachine> > 0x80
15:52:39 <lambdabot>   128
15:52:44 <jrockway> shrink is such a good idea :)
15:53:01 <danderson> omg QC2 is so sexy
15:53:06 <MissPiggy> temoto, the rendering is pretty trivial since HTML does that: the difficult bits for me is (1) getting a textbox type thing in HTML that calls on the server (2) getting the server to reply to that
15:53:09 <jrockway> "if i were debugging this, what would i type into ghci?"
15:53:13 <danderson> I've been futzing around with verboseCheck for hours to see what my Arbitrary generates
15:53:15 <jrockway> and then QC does that for me :)
15:53:17 <danderson> sample <3
15:53:22 <jrockway> yes, sample <3 indeed
15:53:25 <etpace> oh, cheers
15:54:05 <aavogt> @src Bool Arbitrary
15:54:06 <lambdabot> Source not found. The more you drive -- the dumber you get.
15:54:14 <aavogt> @src Arbitrary Bool
15:54:15 <lambdabot> Source not found. My mind is going. I can feel it.
15:54:20 <mauke> etpace: obvious difference: your a is not an unsigned char
15:54:39 <etpace> hm
15:54:44 <temoto> MissPiggy, i could help you with in on weekend if you're still interested.
15:54:48 <danderson> jrockway: what is shrink supposed to do?
15:54:52 <etpace> @hoogle byte
15:54:53 <lambdabot> System.Posix.Types type ByteCount = CSize
15:54:53 <lambdabot> module Data.ByteString
15:54:53 <lambdabot> module Text.Parsec.ByteString
15:55:02 <etpace> is there an equivelent in haskell?
15:55:14 <MissPiggy> temoto, if I still haven't done it by then I will ask you ^..^
15:55:25 <mauke> etpace: yes, CUChar; but I think they meant Word8
15:55:42 <temoto> MissPiggy, temotor@gmail.com
15:56:17 <etpace> @hoogle Word8
15:56:18 <lambdabot> Data.Word data Word8
15:56:18 <lambdabot> Data.ByteString.Internal isSpaceWord8 :: Word8 -> Bool
15:59:04 <sshc> is there an extension that enables me to do "class (Quux b, Foo a b) => Bar a"?  I am doing nothing with b
15:59:33 <mauke> sshc: then how would it choose b?
15:59:49 <mauke> oh wait, you said class, not instance
16:00:27 <aavogt> sshc: depends how you define Foo
16:00:48 <sshc> aavogt: ok
16:00:50 <aavogt> it works with:   class Foo a b | a -> b where ...
16:01:02 <aavogt> making Foo a function
16:01:09 <aavogt> hence -XFunctionalDependencies
16:01:20 <etpace> Hmm, I don't actually have to change anything there right mauke? just do gen_tables :: (Array Word8 Word8, Array Word8 Word8)? it prints sane stuff but things are still incorrect, although now all the indices in log are defined
16:01:32 <sshc> is that the only way to do that, and if it is, is that the only extension I need?
16:01:49 <aavogt> multiparameter typeclasses too...
16:01:58 <mauke> etpace: yeah
16:02:03 <sshc> aavogt: what about them?
16:02:09 <aavogt> you're using them
16:02:16 <aavogt> so you need to enable that extension too
16:02:18 <temoto> aavogt, what guard means in class declaration?
16:02:21 <etpace> something wrong with gen I guess, hmm
16:02:21 <sshc> aavogt: oh, right
16:02:29 <sshc> aavogt: I have both enabled, so is that the only way?
16:03:20 <aavogt> @google associated type ghc
16:03:24 <lambdabot> http://www.haskell.org/haskellwiki/GHC/Indexed_types
16:03:24 <lambdabot> Title: GHC/Type families - HaskellWiki
16:03:41 <aavogt> that's a newer alternative to fundeps
16:04:17 <aavogt> temoto: it means that the type 'a' uniquely determines the type 'b'
16:04:23 <sshc> aavogt: what is that?
16:04:30 <sshc> aavogt: what is the never alternative?
16:04:47 <aavogt> yes, but in this case, the point of view of fundeps makes more sense
16:05:10 <aavogt> but I don't really understand type families
16:05:14 <sshc> aavogt: if I defined class Bar by "class (Quux b, Foo a b) => Bar a", GHC complains: Not in scope: type variable `v'
16:05:50 <temoto> aavogt, as in Maybe Int determines Int?
16:06:10 <sshc> how would the State monad be defined without the Multiparamerter type class extension?
16:06:23 <aavogt> temoto: it only makes sense for multiparameter typeclasses... Maybe isn't even a typeclass...
16:06:37 <aavogt> @src State
16:06:37 <lambdabot> Source not found. It can only be attributed to human error.
16:07:31 <temoto> Heh, i don't know a single >1 parameter type class :)
16:08:33 <temoto> But in expression Foo a b | a -> b, aren't 'a' and 'b' types?
16:08:57 <aavogt> sshc: class MonadState s m where get :: m s; put :: s -> m () -- this could still work
16:09:19 <aavogt> oh, you do need multiparameter type classes
16:09:36 <sshc> aavogt: if I defined class Bar by "class (Quux b, Foo a b) => Bar a", GHC complains: Not in scope: type variable `b'
16:10:54 <temoto> sshc what if you remove Quux b?
16:11:48 <sshc> temoto: same error.
16:14:18 <mauke> etpace: I only see a single difference
16:15:02 <aavogt> sshc: I dunno, what are you trying to accomplish here... and why can't you leave the 'b' as a parameter to Bar?
16:15:43 <sshc> aavogt: because I'll need to end up rewriting a lot of code
16:15:46 <temoto> '*' is a term in kinds?
16:15:53 <sshc> aavogt: how do I write a class definition such as that?
16:16:28 <aavogt> does Bar have lots of methods?
16:16:49 <sshc> aavogt: yes
16:18:34 <c_wraith> hmm.  if anyone answered this earlier, I missed it.  Is there a good LRU package?
16:20:16 <Alpounet> c_wraith, it seems there is
16:20:26 <Alpounet> http://hackage.haskell.org/packages/archive/LRU/0.1.1/doc/html/Data-LRU.html
16:20:32 <c_wraith> the only one I could find listed itself as deprecated
16:20:35 <c_wraith> yes, that one
16:20:40 <Alpounet> oh
16:20:45 <c_wraith> but gives no clue what it's deprecated in favor of
16:21:01 <Alpounet> I see 'experimental'
16:21:16 <Alpounet> but not 'deprecated'
16:21:49 <c_wraith> deprecated - true
16:22:25 <Alpounet> oh yeah sorry
16:22:26 <Alpounet> weird.
16:22:30 <Alpounet> have you actually tried it ?
16:22:42 <Alpounet> it may be sufficient for your usage.
16:22:46 <c_wraith> No.  I suppose I should.  I'm glancing at the code now
16:25:22 <c_wraith> based on its implementation, I have a suspicion that the docs are lying about time complexities.
16:25:42 <aavogt> it's all O(0)?
16:25:54 <c_wraith> Looks like hit is O(n)
16:26:29 <c_wraith> Since it's rethreading a doubly-linked list when that's called
16:26:52 <c_wraith> Oh, unless the links point to keys.  I should look a bit closer
16:26:59 <c_wraith> explicit sharing!
16:27:46 <aavogt> sshc: hmm, maybe you want a monomorphic type for 'b', as in   class (Quux Int, Foo a Int) => Bar a
16:28:42 <aavogt> such tends to be the case for, say instances of State, because you usually can't put a state of one type and then put a different type (though also a member of the same class)
16:29:26 <aavogt> a sensible trick around this, if you can't make your various types of state into a single ADT, is to do what extensible-exceptions does
16:29:43 <aavogt> http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
16:31:34 <c_wraith> Oh, blargh.  that package is an LRU set, not an LRU map
16:34:09 <Alpounet> c_wraith, look at the persistant-map package
16:34:15 <Alpounet> they wrap that LRU package
16:34:21 <Alpounet> ... for a map, I guess.
16:35:31 <c_wraith> hmm.
16:35:37 <c_wraith> What are the options for the persistent backend?
16:35:57 <Alpounet> dolio, regarding our earlier discussion, you may want to take a look at either "Multi paradigm design for C++" by James O. Coplien, or the thesis on the same topic, still by Coplien, which is freely available.
16:37:07 <Alpounet> c_wraith, http://hackage.haskell.org/packages/archive/persistent-map/0.3.5/doc/html/Data-TMap-Backend.html
16:37:56 <c_wraith> oh, hey a null backend. that works. :)
16:38:52 <mauke> etpace: http://codepad.org/y6W2FAcH
16:41:11 <sshc> would overriding several of Haskell's operations by making a vector an instance of the Num typeclass be a good idea?
16:41:44 <kmc_> "Functions are the masters of reuse: when you use an advanced feature, you need a yet more advanced feature to abstract over it (think: classes < existential types < universally quantified constraints < unknown). But all you need to abstract over a function is another function."
16:41:46 <kmc_> interesting
16:42:15 <aavogt> kmc_: how about Rank whatever polymorphism?
16:42:31 <kmc_> how about it?
16:42:33 <luqui> yeah RankN is nice for abstracting over functions
16:42:37 <kmc_> yeah
16:42:40 <aavogt> in that sense, polymorphic functions are not first-class
16:42:45 <luqui> with only top-level universal you run into some abstraction issues
16:42:50 <kmc_> polymorphism is not really complete without rank-N
16:42:58 <kmc_> System F allows it
16:43:14 * aavogt keeps type inference, thank you :)
16:43:33 <kmc_> eh, i'm fine with having type inference mostly work
16:43:39 <tensorpudding> is type inference that necessary?
16:43:47 <luqui> I'm elated with GHC's treatment of rank-n
16:44:14 <kmc_> tensorpudding: no, much of the software in the world is written in languages like Java that require you to write a type twice just to create a value
16:44:30 <tensorpudding> i should have said
16:44:43 <kmc_> if you're using rank-N types, you probably want to include a signature anyway, as documentation
16:44:53 <tensorpudding> is type inference that big of a feature that losing it would depress people
16:45:03 <kmc_> losing it entirely, yes
16:45:14 <Alpounet> it's very handy.
16:45:18 <theorbtwo> tensorpudding: It really is.
16:45:19 <Twey> In Haskell, certainly yes
16:45:42 <tensorpudding> lately i've used ghci with -Wall, and it warns whenever a type is defaulted, so I've been specifying the type everywhere
16:46:03 <Twey> You might end up having to write ((+) :: Integer -> Integer -> Integer) (3 :: Integer) (5 :: Integer)
16:46:16 <tensorpudding> why would you have to do that?
16:46:18 <Twey> tensorpudding: You're still using type inference
16:46:35 <mauke> (((+) :: Integer -> Integer -> Integer) (3 :: Integer) :: Integer) (5 :: Integer) :: Integer
16:46:37 <Twey> Just specifying the top-level type and having it infer the rest from that
16:46:40 <mauke> er
16:46:45 <Twey> Oh yeah, forgot the return type
16:47:00 <tensorpudding> if you specify the type of (+) in its definition, you don't have to specify it every time you use it do you?
16:47:14 <Twey> tensorpudding: No, but the type in the definition is Num a => a -> a -> a
16:47:17 <tensorpudding> yes
16:47:22 <theorbtwo> There's a lot more then just one (+).
16:47:31 <Twey> Which is not a very useful type — you need to narrow it down
16:47:41 <tensorpudding> so you'd have to specify the Integer parts
16:47:43 <Twey> Usually type-inference just does that for you where it needs to be done
16:47:59 <tensorpudding> but i don't see why you'd need to specify (+) to, since it will know to use the one that takes Integers
16:48:07 <Twey> How will it know?
16:48:10 <Twey> Without any type inference?
16:48:15 <tensorpudding> because you gave it Integers
16:48:19 <Twey> That's type inference
16:48:27 <Twey> (or part of it, anyway)
16:48:48 <tensorpudding> so without type inference you have to specify the type of everything, every time you use it?
16:49:02 <tensorpudding> and not just when you define it?
16:49:04 <aavogt> if the types are polymorphic
16:49:06 <Twey> Without any type inference at all, yes
16:49:07 <Twey> Yes
16:49:22 <watermind> there's pairing and projections, and injection and ... (?)
16:49:38 <aavogt> Twey: it's inference to look up the monomorphic type specified somewhere else?
16:49:40 <watermind> I know that if we do it categorically we have pairing of functions and sum of functions
16:49:57 <watermind> but if we're thinking about value constructors and destructors
16:49:57 <Twey> aavogt: No, I don't think so (that was the second ‘yes’)
16:50:29 <watermind> the constructors are pairing and injections and the destructors are... projections and... (?)
16:50:39 <watermind> I know it's "case"
16:50:45 <watermind> but is there any nicer name
16:52:02 <lpsmith> coprojections
16:53:09 <interferon> are there any case studies of webapps done in haskell, other than vocabulinks?
16:53:09 <tensorpudding> so why does System F break type inference?
16:53:25 <sproingie> it makes it undecideable
16:53:45 <tensorpudding> hmm
16:54:49 <tensorpudding> i should learn more about HM
16:57:04 --- mode: ChanServ set +o monochrom
16:57:10 --- mode: monochrom set -o monochrom
16:58:34 <c_wraith> Hmm.  Looking at EdisonCore.  What are the performance differences between TernaryTrie and StandardMap
17:13:19 <etpace> thanks mauke
17:15:19 <meanburrito920_> So Google Summer of Code 2010 has been announced, and I was thinking about applying. I was considering working on something for haskell.org for my project, but the only thing that immediately comes to mind as something I really would love to do is to add jvm support to ghc. Obviously that isnt a trivial project, so I was curious as to whether or not it would be useful for me to work on it this summer if it would be unlikely I would fi
17:15:19 <meanburrito920_> nish it (although i probably would continue to work on it afterwards, just for fun)
17:16:18 <Alpounet> meanburrito920_, there have been few projects about that
17:16:23 <Alpounet> maybe you should take a look at them
17:16:55 <Alpounet> http://www.scdi.org/~avernet/projects/jaskell/
17:17:21 <Alpounet> nice that GSoC are opened. I will apply too, probably for Haskell.
17:17:28 <meanburrito920_> Alpounet: I have, but none of them are related to GHC. My only concern is that they will not fall under "haskell.org" for an open source organization. although I guess it probably doesnt matter all that much
17:18:13 <monochrom> > text " "
17:18:18 <Alpounet> meanburrito920_, the link I gave you is.
17:18:34 <monochrom> @bots
17:18:34 <lambdabot> :)
17:18:34 <lunabot>  :o
17:18:39 <Alpounet> but there is another "jaskell" that hasn't that much to do with it.
17:19:21 <sproingie> jvm support for ghc is pretty darn ambituous
17:19:50 <sproingie> llvm support might be a little more doable
17:19:55 <c_wraith> Argg...  No instance for (stm-io-hooks-0.4.2:Control.Monad.AdvSTM.Class.MonadAdvSTM STM) arising from a use of `Data.TMap.lookup' at <interactive>:1:13-36
17:20:17 <c_wraith> Oh, I see the problem
17:20:39 <Alpounet> meanburrito920_, where has it been announced btw ?
17:20:53 <kamatsu> sproingie: llvm support has already been done
17:21:11 <meanburrito920_> Alpounet: they havent updated the page yet, but its announced on the google groups and on #gsoc
17:21:16 <Alpounet> ok
17:21:22 <meanburrito920_> kamatsu: it has?
17:21:34 <meanburrito920_> sproingie: yeah, but its awesome
17:22:31 <Alpounet> haha, Haskell EJBs
17:22:42 <sproingie> hm ehc has a llvm backend, does the ghc llvm backend even work or has it bitrotted?
17:23:24 <sproingie> woohoo enterprise haskellbeans
17:24:11 <danderson> ew
17:24:16 <danderson> go wash your mouth out with soap
17:24:22 <sproingie> you mean with SOAP
17:24:37 <danderson> better make that industrial detergent...
17:24:56 <monochrom> haha
17:25:02 <Alpounet> heh
17:25:13 <monochrom> @bots
17:25:13 <lambdabot> :)
17:25:13 <lunabot>  :o
17:25:42 <meanburrito920_> Alpounet: that jaskell link you gave me has no links to source or anything of the such. it also looks to be from around '98. is anything really being done with it?
17:25:46 <sproingie> then there's preflex which doesn't respond to @bots
17:26:16 <monochrom> :t id
17:26:17 <lambdabot> forall a. a -> a
17:27:03 <Alpounet> meanburrito920_, dunno, you should consider mailing the author
17:27:13 <sproingie> :t \x -> x
17:27:14 <lambdabot> forall t. t -> t
17:28:51 <Twey> :t \t -> (t t) t
17:28:53 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1 -> t2
17:28:53 <lambdabot>     Probable cause: `t' is applied to too many arguments
17:28:53 <lambdabot>     In the expression: (t t) t
17:33:13 <danderson> so, I'm haivng more QuickCheck trouble. I'm trying to figure out how to write an Arbitrary instance for Data.ByteString.Lazy.ByteString that actually generates the random data lazily
17:33:56 <danderson> case in point, I'm generating random IP packets, and for many header decoding prop tests, I don't actually need to generate the payload at all
17:34:04 <danderson> but, with a strict bytestring generator, well...
17:34:11 <pretsas> What would I want to use if I was matching pieces of strings?
17:45:06 <aavogt> http://code.haskell.org down again?
17:53:23 <xerox> preflex prefixes?
17:53:28 <xerox> oops.
17:56:54 <Alpounet> aavogt, it answers to ping at least
17:57:29 <xerox> no cabal-over-icmp yet =)
17:57:48 <aavogt> xerox: it works over ssh though
17:58:19 <aavogt> or at least darcs does
18:12:37 <sshc> is mutable state possible in Haskell?
18:13:08 <sshc> outside the IO monad?
18:13:33 <pikhq> Probably not, but you can pretend.
18:13:36 <Twey> sshc: Sure, inside the ST monad ☺
18:13:46 <pikhq> Oh, right, ST.
18:13:46 <Twey> Also, inside the State monad, for some definition of ‘mutable state’
18:13:52 <pikhq> Another bit of magic.
18:14:09 <Twey> Well, mutable state is fundamentally magic.
18:14:15 <Twey> Takes magic to implement magic.
18:15:00 <sshc> I don't care whether or not it actually is mutable behind the seens; as long as I can treat it as mutable
18:15:18 <sshc> scenes
18:15:35 <Twey> Well, it depends what you want to do with it
18:15:55 <Twey> State will give you some of the convenience of mutable state
18:16:22 <dibblego> does python allow me to write \_ _ -> x i.e. ignoring the lambda arguments?
18:16:30 <Twey> dibblego: No
18:16:34 <dibblego> bugger thanks
18:16:38 <medfly> isn't this #haskell
18:16:57 <Twey> sshc: But it's not truly mutable state (e.g. you can't access your changes from an external function unless you pass it back out, and you can't actually mutate values (update a single element in-place in an array, for example)
18:17:18 <pikhq> sshc: So long as you can treat it *as* mutable?
18:17:24 <pikhq> That's pretty easy to do.
18:17:24 <Twey> ST gives you truly mutable state safely encapsulated in a pure-guaranteed container
18:17:35 <pikhq> ST, State.
18:18:04 <sshc> when I think about it, it's pretty easy to emulate mutable state purely with immutable state
18:18:18 <Twey> That's what State does
18:18:47 <Twey> s/\)/))/
18:22:33 <dolio> You can implement ST using Map and Dynamic. The fact that it's actually implemented as actual mutable state can be viewed as just an optimization.
18:23:04 <dibblego> what is Dynamic?
18:23:37 <pikhq> dibblego: Dynamic typing.
18:23:54 <dibblego> @src ST
18:23:55 <lambdabot> newtype ST s a = ST (STRep s a)
18:23:59 <dibblego> @src STRep
18:23:59 <lambdabot> type STRep s a = State# s -> (# State# s, a #)
18:25:31 <dolio> > let l = [toDyn (5 :: Int), toDyn "hello", toDyn ('c', 1.5 :: Float)] in fromDynamic (head l) :: Int
18:25:32 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
18:25:32 <lambdabot>         against inferred type ...
18:26:55 <dolio> > let l = [toDyn (5 :: Int), toDyn "hello", toDyn ('c', 1.5 :: Float)] in fromDynamic (head l) :: Maybe Int
18:26:56 <lambdabot>   Just 5
18:27:22 <sshc> will GHC compile the State monad as mutable state when it builds into mcachine code?
18:27:38 <pikhq> sshc: Magic!
18:27:49 <dolio> > let l = [toDyn (5 :: Int), toDyn "hello", toDyn ('c', 1.5 :: Float)] in (l !! 0 :: Maybe Int, l !! 1 :: Maybe String, l !! 2 :: Maybe (Char, Float))
18:27:50 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe GHC.Types.Int'
18:27:50 <lambdabot>         again...
18:27:55 <pikhq> (... Probably. GHC is pretty smart.)
18:28:46 <dolio> > let l = [toDyn (5 :: Int), toDyn "hello", toDyn ('c', 1.5 :: Float)] in (fromDynamic (l !! 0) :: Maybe Int, fromDynamic (l !! 1) :: Maybe String, fromDynamic (l !! 2) :: Maybe (Char, Float))
18:28:47 <lambdabot>   (Just 5,Just "hello",Just ('c',1.5))
18:32:10 <CalJohn> i wouldn't think so, sshc
18:32:21 <kwos> CalJohn: hi
18:32:29 <CalJohn> ?? hello
18:32:29 <lambdabot>  hello
18:32:35 <CalJohn> lambdabot: not you
18:32:44 <kwos> :-)
18:32:54 <CalJohn> kwos: oh, i recognise you now :)
18:33:22 <kwos> random question: is "Work Completed and to be Carried Out" a proper capitalisation for a section of a report?
18:33:46 <aavogt> @vixen is "Work Completed and to be Carried Out" a proper capitalisation for a section of a report?
18:33:47 <lambdabot> let's don't talk about that
18:34:08 <aavogt> capitalize your titles like you capitalize sentences
18:34:28 <Twey> kwos: ‘Be’ should be capitalised
18:35:07 * kwos hates any form of "formal" writing
18:35:44 <kwos> Twey: thanks
18:35:52 <m0nkfish> formal writing is fun if you make it fun!
18:37:54 <kwos> if only it was that simple :D
18:44:27 <NullEntity> Anybody try F#?
18:44:28 <Draconx|Laptop> kwos, there are at least three different styles in common use for capitalising titles.  At least one of which does not capitalise "to be".
18:45:08 <m0nkfish> i wouldnt capitalise to be
18:45:52 <Draconx|Laptop> kwos, whoever is receiving your work probably has a style guide.
18:51:23 <NullEntity> Is there a XNA guide for beginner C#?
18:51:42 <NullEntity> Oops, wrong channel
19:00:20 <Alpounet> indeed...
19:04:41 <Raynes> @quote Raynes
19:04:41 <lambdabot> Raynes says: F# isn't a cousin [of Haskell], it's the retarded son in law.
19:04:48 <Raynes> NullEntity: :)
19:05:44 <lpjhjdh> why did ms push f# so much and not haskell.  Aren't they sponsoring ghc?
19:06:05 <Cale> lpjhjdh: Well, F# is designed to run on .NET
19:06:36 <lpjhjdh> is there a reason they didn't just ruin haskell with objects and make that run on .net?
19:07:02 <lpjhjdh> the ml family has such hideous syntax :(
19:07:29 <medfly> I don't think they are the ones calling the shots with Haskell
19:07:39 <lpjhjdh> ah, that's probably a good thing I suppose
19:08:01 <Cale> Well, also .NET integration of that sort imposes ugly constraints on what the language can look like.
19:09:10 <lpjhjdh> what does a language need to be clr compliant?
19:10:01 <lpjhjdh> the one nice thing about .net is the cross language integration, if only it didn't embed a notion of objects so deeply
19:11:39 <medfly> the nice thing about .NET is that you can get paid to write it
19:12:11 <lpjhjdh> haha, what about galois and inria?
19:12:12 <Cale> I'm not sure F# is really much more popular than Haskell.
19:12:23 <lament> i wrote an industrial-strength kitten-killer application for .NET.
19:12:29 <lament> It gets a lot of use.
19:12:35 <pikhq> Cale: .Net.
19:13:04 <c_wraith> medfly, you say that as if I'm not getting paid to write haskell *at this very moment*
19:13:09 <Cale> pikhq: I know. Writing C# code isn't much different from writing code in other imperative OO languages though.
19:13:29 <medfly> well, there are a few lucky people
19:13:31 <pikhq> Well, except that C# has monads, if you so chose to use it.
19:15:19 <Cale> pikhq: Can C# even manage polymorphism over type constructors?
19:15:38 <pikhq> No.
19:15:48 <pikhq> I didn't say it did monads *well*.
19:15:52 <Cale> Then it can't really support monads at all.
19:15:56 <pikhq> But it does have them builtin.
19:16:06 <Cale> It has something which happens to be a monad built in.
19:16:15 <Cale> But so does every language. :P
19:16:26 <pikhq> You can define instances for it.
19:16:49 <Twey> You could write *everything* as a LINQ query.
19:16:51 <pikhq> You just don't get any functions that are polymorphic on the monads...
19:17:01 <Twey> But you'd get beaten to death by your coworkers.
19:17:23 <Cale> The only real point of recognising that something is a monad is to be able to use functions which are polymorphic over all monads with it.
19:17:45 <Twey> You can do that with LINQ
19:17:49 <pikhq> Cale: It has monad comprehensions as syntax...
19:17:54 <Twey> You can write functions on IEnumerable
19:18:24 <pikhq> So if you make a monad, you can use the monad comprehensions.
19:20:43 <medfly> this channel should discuss Haskell more
19:22:25 <lpjhjdh> are recursion schemes more general than fold well known to most haskell programmers?
19:23:11 <medfly> what, like fix?
19:23:23 <Twey> Or unfold?
19:23:37 <medfly> I don't really have a recursion meter
19:23:38 <medfly> er
19:23:41 <medfly> generalisation meter
19:23:41 <lpjhjdh> like zygomorphism
19:23:56 <Twey> I think we mostly *know* of them
19:24:04 <Twey> I doubt many have *used* them, though
19:26:03 <c_wraith> :t mod
19:26:04 <lambdabot> forall a. (Integral a) => a -> a -> a
19:36:17 <c_wraith> @hoogle fromMaybe
19:36:17 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
19:37:15 <Twey> :t maybe
19:37:16 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
19:37:29 <Twey> fromMaybe = flip maybe id
19:37:50 <Twey> = (`maybe` id)
19:38:56 <Twey> Hm, three characters longer.  Oh well, the import makes it useless anyway.  :þ
19:57:55 <c_wraith> well, I needed maybe anyway, because I needed return instead of id.  *sigh*
20:01:24 <Twey> There you go, then :þ
20:07:37 <c_wraith> > cake !! 19
20:07:38 <lambdabot>   "Unsaturated polyester resin."
20:09:56 <Twey> Haha
20:10:27 <Twey> > foldr (</>) (text "") $ map text cake
20:10:29 <lambdabot>   Not in scope: `</>'
20:10:34 <Twey> Huh
20:11:20 <Twey> > foldr (<+>) empty $ map text cake
20:11:21 <lambdabot>   Ambiguous occurrence `<+>'
20:11:21 <lambdabot>  It could refer to either `Control.Arrow.<+>', i...
20:11:24 <Twey> Ych
20:11:46 <Twey> > foldr (Text.PrettyPrint.HughesPJ.<+>) Text.PrettyPrint.HughesPJ.empty $ map text cake
20:11:47 <lambdabot>   Not in scope: `Text.PrettyPrint.HughesPJ.empty'
20:11:54 * Twey gives up
20:15:14 <xerox> > cake
20:15:16 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
20:16:10 <xerox> > foldr1 (Text.PrettyPrint.HughesPJ.<+>) . map text $ cake
20:16:14 <lambdabot>   One 18.25 ounce package chocolate cake mix. One can prepared coconut pecan ...
20:18:25 <centrinia> > map head cake
20:18:27 <lambdabot>   "OOTFOTOTDFFFFFPFCOAUFANTOATTOOTOOTASCIICAT"
20:18:47 <centrinia> Hmm, besides the ASCII CAT, I don't see any other obvious messages.
20:21:25 <xerox> > map (head . tail) cake
20:21:26 <lambdabot>   "nnhonhnwoiiiiiuianlniniwnnwwnnhnnwdlonnrnh"
20:21:39 <xerox> > map (head . tail . tail) cake
20:21:40 <lambdabot>   "eeruereonssssslsnepsbdnee ooeereeojarjjada"
20:28:53 <solrize> planet.haskell.org is down?
20:30:32 <pretsas> Indeed
20:31:05 <pretsas> http://downforeveryoneorjustme.com/planet.haskell.org
20:42:20 <tommd> I have to ask this question once every 6 months - what is the way to derive functions of the form is*, as in "isContstructorName".
20:42:34 <tommd> DerIVE does it?
20:42:52 <tommd> Or something else
20:47:14 <raceRider> Short of using an HDBC interface, what's a good library for storing large number of records (a million or so) for parsing and evaluating?
20:47:59 <kmc> what's in a record?
20:48:17 <kmc> tommd, it could be done in principle with Template Haskell
20:48:26 <kmc> i'm not aware of a premade package to do it
20:48:54 <raceRider> each record has about a dozen fields, most of them hex codes, but one date/time and another string
20:49:04 <kmc> what do you want to do with them?
20:49:35 <raceRider> find some stats, min, max, recent, avg, and so on.
20:49:44 <tommd> kmc: Yes, I'm aware of the TemplateHaskell method but am thinking of a specific solution.  It just for general use.
20:50:45 <tommd> Yes, it is "derive"  in the "Data.Derive.Is" module.
20:56:04 <kmc> tommd, cool, i didn't know Derive did things besides classes
21:02:23 <amuck> Has anyone used Data.Digest.Pure.SHA and found a memory leak with the sha512 function?
21:11:01 <DekuNut> Extremely simple question
21:11:07 <DekuNut> :t (>2)
21:11:08 <lambdabot> forall a. (Num a, Ord a) => a -> Bool
21:11:17 <DekuNut> > nubBy (>2) [1,2,3,4]
21:11:18 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
21:11:18 <lambdabot>         against inferred ...
21:11:31 <DekuNut> > nubBy (>2)
21:11:32 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
21:11:33 <lambdabot>         against inferred ...
21:12:04 <DekuNut> Why, the type it expects is a -> Bool, lambdabot says (>2)'s type is a -> Bool, what's wrong?
21:12:47 <copumpkin> :t nubBy
21:12:48 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a]
21:12:51 <copumpkin> that's what's wrong
21:12:58 <DekuNut> Oh right yeah I'm a moron
21:13:04 <copumpkin> :)
21:13:13 <DekuNut> :(
21:13:18 <DekuNut> Thanks
21:14:35 <amuck> DekuNut: Do you want filter?
21:17:53 <quuxman> so I've read a few people saying that Haskell (and all other languages for that matter) have an arbitrary bias towards data in that data types are gauranteed to be memoized, but functions are not. Are there any papers out there that explore eliminating the difference between data types and functions?
21:19:12 <pikhq> quuxman: It's trivial to do, but only if you have infinite memory.
21:19:55 <pikhq> quuxman: Also, you'll do a lookup at the begin of every function call to see if it's been called before.
21:20:01 <pikhq> Exceptionally slow.
21:21:58 <SANDERS_> is gtk2hs dead?
21:22:06 <xerox> no!
21:23:21 <SANDERS_> code.haskell.org/gtk2hs seems to be gone
21:23:31 <xerox> it's c.h.o that is down
21:23:36 <quuxman> pikhq: what you're saying is that functions and data are as close as is reasonable is Haskell
21:23:45 <quuxman> *in Haskell
21:23:53 <pikhq> quuxman: Yes.
21:24:13 <pikhq> Well, strictly speaking *functions are data*. ;)
21:24:20 <SANDERS_> xerox: ah yeah
21:24:23 <SANDERS_> :(
21:25:16 <elly> surprise lisp!
21:25:45 <syntaxglitch> it's fairly easy to wrap a function into a memoizing data structure anyway, if you really want to
21:26:30 <pikhq> syntaxglitch: Yeah, just make a list et voila.
21:27:15 <syntaxglitch> unmemoizing something that's eating too much memory, on the other hand, I'm not sure how you'd go about doing
21:27:29 <quuxman> it should be part of the memoizing function
21:27:50 <quuxman> the memoizing function would take some arguments about the map size
21:27:55 <pikhq> quuxman: What, implicit function memoization?
21:28:00 <pikhq> :P
21:28:24 <copumpkin> functions are data that you can't serialize in any meaningful way right now :(
21:28:26 <quuxman> pikhq: yeah... ;)
21:28:34 <copumpkin> (from within the language)
21:29:53 * syntaxglitch actually thinks some sort of unmemozing might be more useful than implicit function memoizing
21:33:45 <syntaxglitch> Unmemoizing wouldn't even break referential transparency, it'd just force the same structure to be recomputed
21:42:48 <pretsas> Is there a way to compile a windows binary with ghc on linux?
21:44:05 <nus> pretsas, supposedly, with the C backend and a cross-compiler
21:52:07 <SANDERS_> anyone know whats up with code.haskell.org?
21:52:44 <Zao> SANDERS_: Not much at all seems up there :)
21:52:45 <copumpkin> not the server
21:53:20 <SANDERS_> is it mirrored anyway?
21:53:30 <SANDERS_> er anywhere
21:56:47 <SANDERS_> i need  to get to the gtk2hs darcs repo
21:57:28 <SANDERS_> anyone have an up to date version mirrored anywhere?
22:09:04 <dons> mm. vm might be down.
22:39:11 <hydo> Using HStringTemplate - $foreach x in blob$\n$blob.name$\n$end$ aside from the fact that it's on one line for irc, what am I doing wrong?  The position called in the error is the 'o' in foreach but according to a couple of links from google, that should work.
22:43:30 <Cale> hydo: Not that I'm familiar with that library, but that doesn't look anything like Haskell code...
22:43:53 <c_wraith> cale: hstringtemplate is a templating library
22:43:58 <hydo> cale: heheh no, it's a string templating lib.  I'm using it to generate html
22:43:58 <c_wraith> so it's not haskell code
22:44:11 <hydo> s/using/trying to use/
22:45:28 * hydo scours github for examples...
22:48:09 <Cale> hydo: If it's any use, 'foreach' doesn't occur anywhere in the source code for HStringTemplate.
22:49:48 <hydo> awww damnit!  a feature taken out?  that seems weird.  someone suggests that syntax in here on 6/2/09 and it apparently "works well".
22:50:38 <hydo> http://tunes.org/~nef//logs/haskell/09.06.02 for context.  search for 08:18:15
22:51:25 <hydo> Well, I guess I'll go back to rendering the elements as individual elements to strings and then blorting that into a ain template.
22:51:50 <hydo> err... rendering the templates as individual elements, I mean.
22:52:04 <hydo> ugh... more coffee.
22:56:13 <hydo> ah ha!  $bundle:{x| <a href="$x.element$">}$  it -was- replaced with something.  Thanks for saving me some time and also pointing out what I should have done before asking the channel, Cale! :)
23:56:10 <solrize> community.haskell.org is down
23:59:39 <domor> I have a program which spends 60% of its time in GC but the heap profile is constant at 200k or so.. is there a common cause for that? essentially I liftM2 a function on a couple of lists
