00:00:30 <Cale> c_wraith: because it would overlap with everything?
00:00:33 <BMeph> Why would you need to? :)
00:00:45 <c_wraith> it only overlaps with things it makes redundant
00:02:15 <Cale> c_wraith: It overlaps with any instance of MonadState s (t m) for various specific t and m, regardless of what instances may exist for those.
00:02:19 <Saizan> it overlaps with the instance for StateT s m, which isn't redundant
00:02:58 <c_wraith> Ok, yes.  it does overlap StateT.  That's a real problem.
00:04:37 <Saizan> and it also overlaps with my "MonadWhichIsNotATransformerButHasAParameterOfTheSameKindAsMonads p" instance
00:05:14 <Saizan> since contexts are not taken into consideration when deciding which instance to pick
00:05:23 <c_wraith> oh.  I forgot about that.
00:05:59 <c_wraith> What's the problem with taking the context into consideration again?  I think I've seen a description of the issue, but I can't recall it
00:06:51 <Saizan> that you can't really know if a type is not an instance of a class, since it might be later
00:07:39 <Saizan> in the sense that you might import the instance in a module further down in the hierarchy, so which instance is picked strongly depends on where resolution is resolved
00:07:56 <Saizan> if you want to keep separate compilation
00:08:35 <c_wraith> ah, right.  But I don't really want to keep separate compilation. :)  (I'm actually really interested in seeing what supercompilation manages)
00:08:44 <Saizan> err, where the instance is resolved
00:09:04 <c_wraith> I gathered that. ;)
00:09:31 * glguy_ invites fans of the card game "Set" to try http://github.com/glguy/set-game/tree/vty
00:09:38 <Saizan> yeah, so i guess you've more freedom in exploring the design space :)
00:10:01 <c_wraith> I suspect supercompilation will be *slow*, though.
00:11:12 <bauchus> hi! a posix question: I do `createNamedPipe "/tmp/p" $ foldl1 unionFileModes [stdFileMode, groupWriteMode, otherWriteMode]', but the write permissions arent set for group+others. Maybe umask is somehow involved, but how can I overwrite the umask?
00:11:34 <luite> Cale: do you have an ebook of Computable analysis: an introduction, by Klaus Weihrauch? (it struck me as a subject you might be interested in, and you often seem to know where to find these things :) )
00:12:01 <c_wraith> Also, this is the best error message I've seen in a while:    Can't make a derived instance of `MonadState GameM'      (even with cunning newtype deriving:       `MonadState' does not have arity 1)    In the newtype declaration for `GameM'
00:12:13 <ivanm> @google pdf "computable analysis" klaus weihrauch
00:12:14 <lambdabot> No Result Found.
00:12:18 <luite> :)
00:12:33 <luite> ivanm: google books does have a preview
00:12:52 <Saizan> c_wraith: you've to give it the state argument in the deriving clause
00:12:53 <ivanm> springerlink seems to have one if you have access...
00:13:16 <c_wraith> Saizan: yeah, it was a pretty clear message, I had no trouble figuring it out.  I just enjoyed the wording.
00:13:36 <Saizan> hah, k :)
00:14:30 <ivanm> this google search returns only springerlink as a valid solution :( : intitle:"computable analysis" klaus weihrauch filetype:pdf
00:16:15 <local> this is lame, but could someone explain a line to me?
00:16:36 <c_wraith> bauchus: that does sound like umask.  I'm not sure you can override that.
00:16:39 <luite> ivanm: do you have the springerlink url, I might have access
00:17:29 <mmmdonuts> shamgar03, what line?
00:17:32 <shamgar03> unmarshall = ((S . read) *** drop 1) . break (=='_')
00:17:42 <ivanm> http://www.springerlink.com/index/n8pr00ag7kj55kxw.pdf
00:17:45 <luite> although I think my university only has access to their papers, not their books
00:17:59 <shamgar03> I don't know what the *** does, and I can't seem to find where S is declared
00:18:10 <luite> ivanm: oh that's just a 2-page pdf with an introduction
00:18:26 <shamgar03> although above that line there is another declaration:
00:18:27 <shamgar03> marshall (S sc) vws = show sc ++ '_':vws
00:18:52 <c_wraith> shamgar03: S is something you'll have to find.  *** takes two functions, and returns a function that applies those two functions to the first and second positions in a tuple.
00:19:30 <c_wraith> > ((+1) *** (++ "!")) (5, "hello")
00:19:31 <lambdabot>   (6,"hello!")
00:19:40 <ivanm> luite: :(
00:19:46 <shamgar03> S is definitely not in the file, I guess it could be imported?
00:20:09 <c_wraith> shamgar03: yeah, you'll have to figure out where it's imported from.
00:20:33 <ivanm> luite: only other one I can find is an ebook on amazon...
00:20:41 <ivanm> which they want US$60 for
00:20:41 <shamgar03> ok, well the *** thing I never would have figured out, you know how hard it is to google ***
00:20:47 <ivanm> (which IMHO is a ripoff)
00:21:11 <mmmdonuts> You can use hoogle to look up *** : http://www.haskell.org/hoogle/?hoogle=***
00:21:13 <c_wraith> shamgar03: did my description (or example) clear that part up, at least?
00:21:38 <shamgar03> yeah, I get that, I guess I have another question
00:21:47 <luite> ivanm: oh well, I could request a copy from my university's library, but then I'll not have it in time for my holiday next week (and I can't take too many physical books because I already have too much luggage)
00:21:54 <ivanm> heh
00:21:56 <ivanm> fair enough
00:22:02 <luite> thanks for the help though :)
00:22:06 <ivanm> no worries
00:22:13 <shamgar03> dot operator is the composition of 2 functions right?
00:22:29 <mmmdonuts> yes
00:22:29 <shamgar03> essentially f(g(x))?
00:22:44 <mmmdonuts> yes
00:22:46 <shamgar03> so in the line I posted, S must be a function then
00:23:06 <mmmdonuts> It's probably a constructor, being capitalized.
00:23:10 <c_wraith> shamgar03: not only is it a function, it's a data constructor.
00:23:21 <shamgar03> is that a convention?
00:23:21 <mmmdonuts> And used in the definition of marshall as a constructor.
00:23:33 <kmc> @src (.)
00:23:34 <lambdabot> (f . g) x = f (g x)
00:23:37 <Cale> shamgar03: It'll be declared in a line which starts with data or newtype
00:23:38 <mmmdonuts> No, part of the syntax of identifiers.
00:23:39 <c_wraith> shamgar03: actually, it's enforced by the compiler
00:23:57 <shamgar03> ok
00:24:16 <kmc> however, a constructor can be used wherever a function can be used
00:24:22 <kmc> :t Just
00:24:24 <lambdabot> forall a. a -> Maybe a
00:24:35 <Cale> shamgar03: It's important that ordinary functions and values be syntactically different from data constructors so that it's easy to tell whether they're something to be matched in a pattern, or a variable to be bound.
00:24:39 <kmc> i guess c_wraith said that
00:25:02 <Veinor> I like to think of constructors as functions
00:25:04 <shamgar03> ic
00:25:12 <Cale> Well, not all data constructors are functions.
00:25:12 <shamgar03> that return a constant?
00:25:28 <Cale> The ones which take parameters are functions :)
00:25:38 <Veinor> the ones that don't are zero-argument functions!
00:25:43 <kmc> no such thing
00:25:47 <Veinor> :p
00:25:55 <kmc> but this argument is tiring ;P
00:26:09 <Cale> If you're willing to allow "zero argument functions", then "functions" are the same thing as "values"
00:26:18 <Cale> (and you might as well say values at that point :)
00:26:21 <kmc> in mathematics, what is the one element of the cartesian product of no sets?
00:26:32 <Veinor> yeah, yeah
00:26:35 <Veinor> I was just joking.
00:26:51 <ddarius> kmc: It depends on the details of your Cartesian product construction.
00:27:05 <Cale> kmc: Doesn't really matter what it is, but it depends on the precise definition, yeah.
00:27:16 <kmc> so it depends on the precise implementation of tuples and such
00:27:19 <Cale> yeah
00:27:20 <Veinor> couldn't you identify it, in a sense, with ()?
00:27:21 <kmc> in terms of sets
00:27:23 <kmc> that's acceptable, i guess
00:27:24 <ddarius> kmc: That is the way of set theory.
00:27:49 <kmc> it's also problematic to ask what the union of no sets is ;)
00:27:58 <Eduard_Munteanu> Hi.
00:28:00 <Cale> well, that's easy
00:28:05 <Cale> It's the empty set
00:28:12 <kmc> err, i meant the intersection
00:28:26 <c_wraith> the intersection of no sets is clearly the set of everything.  :)
00:28:27 <Cale> Yeah, the intersection of no sets doesn't exist.
00:28:36 <kmc> it's not a set, anyway
00:28:41 <Eduard_Munteanu> I want to do something like x <- head $ listStoreGetValue store z, however it complains.
00:28:57 <Eduard_Munteanu> How do I pass an IO a to a functional function? :)
00:28:57 <kmc> Eduard_Munteanu, within what monad?
00:29:06 <Cale> When you're talking about the intersection of no subsets of any fixed set, then it makes sense.
00:29:11 <Eduard_Munteanu> kmc, "Couldn't match expected type `[a]' against inferred type `IO a1'"
00:29:19 <kmc> on which part?
00:29:28 <c_wraith> yes.  there are some issues with the idea of "the set of everything".  :)
00:29:29 <Cale> Eduard_Munteanu: fmap head
00:29:32 <luite> Eduard_Munteanu: you could replace the $ by <$>
00:29:39 <luite> which is the same as fmap :)
00:29:40 <Eduard_Munteanu> kmc, on listStoreGetValue
00:29:40 <kmc> oh, listStoreGetValue is the IO action?
00:29:40 <shamgar03> is there a way to turn an array into a tuple?
00:29:48 <kmc> shamgar03, an array?
00:29:50 <Eduard_Munteanu> luite, Cale, hm, lemme try.
00:29:51 <kmc> from Data.Array?
00:29:55 <shamgar03> yeah
00:30:05 <Cale> shamgar03: Not a trivial way.
00:30:06 <kmc> shamgar03, doubtful, what would its type be?
00:30:09 <Eduard_Munteanu> kmc, yes, returns IO [String] or something
00:30:22 <kmc> the types of tuples of each size are totally unrelated
00:30:22 <shamgar03> [char] (I know there will only be 2)
00:30:34 <Cale> shamgar03: That's a list, not an array.
00:30:45 <Eduard_Munteanu> :t fmap
00:30:45 <kmc> lists and arrays are very very different
00:30:46 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
00:30:48 <Cale> (\[x,y] -> (x,y))
00:30:52 <kmc> the length of a list is not even known at compile time
00:30:57 <kmc> so no, you can't make it into a tuple
00:31:06 <Cale> The length of an array isn't known at compile time either
00:31:17 <kmc> Eduard_Munteanu, yeah, use <$> from Control.Applicative instead of $ there.  the long way is:  do { x <- listStoreGetValue store z; return (head x) }
00:31:32 <kmc> f <$> a = do { x <- a; return (f x) }
00:31:35 <Eduard_Munteanu> Hmm, fmap head $ listStoreGetValue ... works also
00:31:36 <Cale> But practically speaking, if you're *certain* that it's a list of length exactly 2, you can use (\[x,y] -> (x,y))
00:31:38 <kmc> (except more general)
00:31:42 <c_wraith> you can't make it into a generic-length tuple.  But Cale's suggestion works just fine if you know the length is 2
00:31:52 <kmc> fmap is a synonym for <$>
00:31:59 <Cale> That will die with an exception if the list is any other length though, so it's good to be cautious.
00:32:00 <Eduard_Munteanu> I see.
00:32:08 <kmc> :t fmap
00:32:09 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
00:32:19 <kmc> :t liftM
00:32:20 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
00:32:32 <Cale> You may want to use  case myList of [x,y] -> doSomethingWith (x,y); _ -> someOtherContinuation
00:32:53 <kmc> shamgar03, why do you know there will be only two?
00:33:21 <Eduard_Munteanu> Cale, yeah, but fmap does it, I only need the head
00:33:42 <kmc> if you have lists that can only take on certain lengths, you are failing to express some of the structure of your data in the type system
00:33:59 <kmc> however it could be the case that you're failing because the Haskell type system is not powerful enough
00:34:14 <shamgar03> I'm trying to configure friggin xmonad
00:34:21 <kmc> haha
00:34:36 <shamgar03> by now I could have written have of dwm
00:34:44 <kmc> where did you get this two-element list from?
00:34:54 <shamgar03> presumably S
00:35:10 <kmc> ?
00:35:21 <shamgar03> http://xmonad.org/xmonad-docs/xmonad-contrib/src/XMonad-Layout-IndependentScreens.html
00:35:28 <shamgar03> thats the original code I am trying to modify
00:35:44 <shamgar03> in particul the marshall and unmarshall lines
00:35:53 <kmc> ah
00:36:13 <shamgar03> basically the default config stores things as 1_1 1_2 1_3 0_1 0_2 0_3 ....
00:36:22 <kmc> the thing wrapped by S is just an Int
00:36:30 <shamgar03> I want to store as L1 L2 L3 R1 R2 R3
00:36:41 <kmc> S simply turns an Int into a ScreenId
00:36:55 <kmc> ah okay i see
00:36:57 <kmc> what you need to do
00:37:24 <tomas_> is there a lazy array with O(1) access time... (I am OK with creating the array, i just want the elements to be lazy)
00:37:35 <kmc> tomas_, regular immutable Data.Array
00:37:55 <kmc> marshall (S sc) vws = ("LR" !! sc) ++ vws
00:38:08 <tomas_> kmc: is there one that is mutable?
00:38:14 <shamgar03> kmc: marshall was the easy part
00:38:19 <kmc> tomas_, IOArray and STArray are mutable and lazy
00:38:19 <shamgar03> kmc: =)
00:38:24 <kmc> but there are some problems with those
00:38:31 <kmc> you can build big arrays of thunks
00:38:36 <kmc> shamgar03, so you want to write unmarshall
00:38:41 <shamgar03> yeah
00:38:55 <Cale> Big arrays of unevaluated expressions are sometimes what you want though.
00:39:03 <shamgar03> I'm just having trouble grasping why unmarshall doesn't take any arguments
00:39:09 <kmc> unmarshall ('L':xs) = (S 0, xs)
00:39:16 <kmc> unmarshall ('R':xs) = (S 1, xs)
00:39:16 <Cale> You just have to be careful about how big the expressions get. :)
00:39:46 <Stinger> unmarshall is a pointfree expression
00:39:53 <tomas_> kmc: i don't really need the array to be mutable, just the items in the array.. or is that a haskell no-no?
00:39:58 <kmc> (***) combines two functions
00:40:02 <Stinger> a function made by combining functions
00:40:04 <kmc> tomas_, then you can use a regular Array of IORefs
00:40:09 <kmc> but that'd be a strange thing to do
00:40:18 <kmc> what would it mean for the array to be mutable?
00:40:24 <shamgar03> Stinger: pointfree? Pretend like I started learning haskell today
00:40:39 <Stinger> yeah thats why I explained it in the next line :)
00:40:40 <kmc> you can make an immutable array of references to mutable cells.  they are values like any other
00:40:41 <tomas_> kmc: that's why i added comment
00:40:57 <kmc> shamgar03, a simple example is (f . g)
00:40:59 <kmc> composes two functions
00:41:02 <kmc> @src (.)
00:41:02 <lambdabot> (f . g) x = f (g x)
00:41:14 <shamgar03> Stinger: oh yeah, thanks
00:41:14 <kmc> so instead of writing "h x = f (g x)" you can write "h = f . g"
00:41:25 <Cale> unmarshall *does* take arguments, but its definition doesn't introduce any new ones, instead, the definition of unmarshall just combines existing functions together into a new one
00:41:29 <kmc> and now the argument is implicit
00:41:56 * shamgar03 is excited to run back to c++
00:41:57 <tomas_> @src ($)
00:41:57 <lambdabot> f $ x = f x
00:42:01 <kmc> shamgar03, if you are a Haskell beginner your life will be easier to rewrite unmarshall with arguments
00:42:05 <kmc> boo hiss C++
00:42:08 <kmc> did you see my unmarshall above?
00:42:18 <shamgar03> yeah, I am about to try it
00:42:56 <Cale> unmarshall = ((S . read) *** drop 1) . break (=='_')  is equivalent to
00:43:03 <Cale> unmarshall x = ((S . read) *** drop 1) (break x)  which in turn is equivalent to
00:43:19 <Cale> er, oops
00:43:31 <Cale> unmarshall x = ((S . read) *** drop 1) (break (=='_') x)  which in turn is equivalent to
00:43:44 <Cale> (missed the parameter in break)
00:43:58 <Cale> unmarshall x = let (u,v) = break (=='_') x in ((S . read) u, drop 1 v)
00:44:09 <tomas_> kmc: actually, the more I think of it, i'm not sure my idea is going to work..... i'm trying to implement van Embde Boas trees. (operations in O(log log n) )
00:44:10 <Cale> unmarshall x = let (u,v) = break (=='_') x in (S (read u), drop 1 v)
00:44:18 <kmc> yeah, this version of unmarshall is clever one-liner code, not clear code
00:44:31 <Cale> I think it's clear, but maybe not for a beginner.
00:44:32 <shamgar03> dude it works
00:44:35 <kmc> yeah
00:44:37 <tomas_> kmc: or at least I'm not knowledgeable yet
00:44:39 <Cale> It avoids naming things that don't need names
00:45:10 <shamgar03> yeah, none of the beginner guides even came close to covering the stuff that was going on
00:45:11 <kmc> i agree that it's clear once you have skill in reading pointsfree code
00:45:46 <Cale> shamgar03: Okay, so are you comfortable with what the function composition operator does?
00:45:54 <kmc> (f . g) x = f (g x)
00:45:59 <shamgar03> yeah
00:46:21 <kmc> (f *** g) (a, b) = (f a, g b)
00:46:28 <Cale> If f and g are both functions, then f . g is the function which when applied to x, gives f (g x) -- rather like a unix pipeline, but in the reverse order :)
00:46:46 <Cale> and yeah, that (***) is the other component here.
00:46:54 <shamgar03> can you create a tuple just by using:
00:47:09 <Cale> It just takes some functions for acting on each part of a pair, and turns them into a function on pairs.
00:47:10 <shamgar03> foo = (a, b)
00:47:11 <kmc> (***) has a confusing actual type because it's defined in a more general way
00:47:17 <Cale> shamgar03: yes
00:47:23 <kmc> shamgar03, yes, that builds a tuple and additionally gives it a name
00:47:39 <shamgar03> and if foo were a function and a and b were as well?
00:47:41 <kmc> people mostly use (***) on functions, in which case it has type:  (a -> b) -> (c -> d) -> (a, c) -> (b, d)
00:47:48 <kmc> shamgar03, you can make a tuple of functions
00:47:52 <kmc> however that foo is not a function
00:47:57 <kmc> :t (id, succ)
00:47:57 <Cale> shamgar03: well, foo won't be a function because it's a pair
00:47:58 <lambdabot> forall a a1. (Enum a1) => (a -> a, a1 -> a1)
00:48:00 <kmc> ^^^^ a tuple of functions
00:48:32 <shamgar03> how would you create a function that returns a new tuple then?
00:48:38 <Stinger> (,)
00:48:39 <kmc> foo x = (x, x+3)
00:48:43 <Stinger> > (,) 1 2
00:48:44 <lambdabot>   (1,2)
00:48:45 <shamgar03> ahh
00:48:45 <Cale> foo (x,y) = (f x, g y)
00:48:52 <shamgar03> 10 answers
00:48:52 <kmc> or, foo = \x -> (x, x + 3)
00:48:53 <kmc> equivalently
00:48:54 <dibblego> what other useful arrows are there besides (->), Kleisli and Cokleisli?
00:48:55 <Cale> hehe
00:49:06 <kmc> @quote stereo
00:49:07 <lambdabot> dolio says: fasta: At least the 'stereo' quote is no longer in lambdabot. That was _way_ overused.
00:49:20 <Stinger> heh Haskell : there is one (up to isomorphism) way to do it!
00:49:38 <kmc> there is one type to do it, the rest is irrelevant detail
00:50:14 <shamgar03> anyway, its 3:50 in the morning here. thanks for the help guys
00:50:21 <Cale> > let foo x = (x, x^2) in map foo [1..10]
00:50:22 <lambdabot>   [(1,1),(2,4),(3,9),(4,16),(5,25),(6,36),(7,49),(8,64),(9,81),(10,100)]
00:50:30 <kmc> indeed, Cale's foo above can be written as simply "foo = f *** g"
00:51:05 <kmc> whether a definition has arguments syntactically, and whether the value being defined is a function, are two different things
00:51:08 <Cale> Yeah, the one which is foo (x,y) = (f x, g y)
00:51:13 <kmc> yeah
00:51:33 <sfuentes> can somebody help me with this piece: http://pastie.org/776187
00:51:51 <sfuentes> i can't figure out what's the right type sig
00:51:58 <aeter> is Data.Map the Haskell equivalent of Java's TreeMap?
00:52:16 <dibblego> aeter, no, java.util.TreeMap is mutable for one
00:52:42 <Cale> sfuentes: Well... you could always ask ghci what it thinks the type is, supposing that this compiles
00:52:44 <aeter> ah, thanks - I have just read about the data structures in RWH, and I was wondering about it
00:52:55 <Cale> sfuentes:  :t mean
00:53:11 <dibblego> aeter, there is fj.data.TreeMap from Functional Java which is more like Data.Map
00:53:17 <Cale> sfuentes: You could also decide on what types of numbers mean is supposed to be working with right here.
00:53:37 <aeter> I guess it's not in the standard library though ;]
00:53:41 <Cale> You should also note that mean isn't being defined for lists of length 1
00:54:01 <dibblego> aeter, the Java standard library is quite poor
00:55:27 <sfuentes> Cale: well i thought mean :: [Numeric] -> Double should be the type signature, but i get an error with that
00:57:30 <Cale> sfuentes: Well, possibly  (Fractional a) => [a] -> a
00:57:36 <Cale> Numeric isn't a type
00:57:57 <sfuentes> aww. i see.
00:58:01 <Cale> sfuentes: Clearly not any numeric type will work, because you're using / which only works for fractional types.
00:58:35 <sfuentes> thanks very mucho Cale
00:59:10 <Cale> no problem
00:59:47 <tensorpudding> so what do type classes represent, CT-wise?
01:00:11 <Cale> Nothing too specific
01:00:18 <tensorpudding> it seems like a type that contains other types, instead of types that contain values
01:00:58 <Cale> You can think of them as predicates on types/objects, together with certain related arrows which must be present, but it doesn't correspond directly to anything from CT.
01:01:21 <tensorpudding> defining a class is the same as providing the means by which you would prove a type is that class, and instantiating a typeclass is providing the proof objects
01:02:07 <bauchus> c_wraith: (sorry for late response, I'm talking about the permission problem) it was indeed a problem with the umask. I could solve it with a foreign-ccall to umask(2). there isn't a binding in unix for that. thanks for your answer.
01:03:12 <c_wraith> bauchus: thanks for getting back to me.  I wasn't aware of that, so..  hey.  something new learned!
01:05:34 <drhodes> :t (***)
01:05:35 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
01:06:17 <bauchus> I wrote an request to the unix package maintainers, so maybe they include umask(2) someday...
01:06:34 <sfuentes> Cale: ok (Fractional a) => [a] -> a works, but why wouldn't (Num a, Fractional b) => [a] -> b work?
01:08:38 <tensorpudding> @hoogle [a] -> b
01:08:38 <lambdabot> Prelude head :: [a] -> a
01:08:39 <lambdabot> Prelude last :: [a] -> a
01:08:39 <lambdabot> Data.List head :: [a] -> a
01:09:48 <sfuentes> ok i need to read my book again
01:10:10 <tensorpudding> @type fromIntegral
01:10:11 <lambdabot> forall a b. (Integral a, Num b) => a -> b
01:10:58 <tensorpudding> @src fromIntegral
01:10:59 <lambdabot> fromIntegral = fromInteger . toInteger
01:11:06 <tensorpudding> @type toInteger
01:11:07 <lambdabot> forall a. (Integral a) => a -> Integer
01:11:17 <tensorpudding> @src toInteger
01:11:18 <lambdabot> Source not found. Just try something else.
01:11:22 <tensorpudding> meh
01:11:31 <tensorpudding> numbers have some black magic
01:20:02 <Veinor> haskell is making me think functional in other languages
01:20:10 <Veinor> this may or may not be a good thing
01:22:18 <mental> it is imperative that you think functional
01:22:30 <Stinger> yeah that always happens
01:22:38 <Stinger> depends what language you are using
01:23:01 <tensorpudding> some languages have poorer support for functional style than others
01:23:02 <pelotom> anyone doing it in java? :)
01:23:11 * Baughn has done it in java
01:23:20 <aeter> yup, I miss recursion optimisations in Java
01:23:23 <Beelsebob> Veinor: it's amazing how much I write Haskell in Objective-C these days
01:23:24 <pelotom> it's painful and exhilarating at the same time
01:23:24 <Baughn> I ran into the recursion limit. ^^;
01:23:28 <Beelsebob> and it's horrible when it breaks :(
01:23:32 <Stinger> Blacksting has done it in c++ *bleah*
01:23:43 <Beelsebob> luckily, most Obj-C compilers have tail call optimisation
01:23:47 <Baughn> Also, I spent half a day trying to recreate the functor/applicative/monad hierarchy
01:23:59 <Baughn> Didn't work.
01:24:13 <pelotom> Baughn: it can't be done in java, can it?
01:24:31 <pelotom> type system isn't powerful enough
01:24:33 <Baughn> pelotom: I was hoping the parametric polymorphism added lately would be enough. It wasn't.
01:24:53 <sfuentes> what about functional asm programming
01:25:11 <tensorpudding> don't try recursion in python
01:25:18 <sfuentes> can't really picture it
01:25:19 <Stinger> its hard to do functional programming in something that barely has an idea of functions
01:25:22 <tensorpudding> if you want to recurse over something rather large
01:26:06 <tomas_> i'm trying to implement a tree in haskell, but I don't think I am organizing myself right,  Is there an example that I can use to help me out... (should I be using monads,etc?)
01:27:07 <Veinor> I'm doing it in python, so
01:27:30 <Baughn> tomas_: Your tree might be a monad, but that's something you discover, not something you aim for
01:27:55 <Baughn> tomas_: (Practically speaking, trees usually /are/ monads)
01:28:45 <tomas_> Baughn: then I am NOT going about Haskell the right way
01:29:06 <tomas_> Baughn: I'm still in the "going through tutorials" stage
01:29:14 <Baughn> tomas_: Then don't worry about monads.
01:29:22 <int-e> Baughn: how do you deal with labels at internal leafs?
01:29:28 <int-e> argh
01:29:29 <tensorpudding> a binary tree is a pretty simple algebraic data structure
01:29:31 <int-e> internal nodes.
01:30:02 <Baughn> int-e: Depends on the exact kind of tree
01:30:18 <Baughn> int-e: There are lots of options, and yes, some kinds would not be usefully monadic at all
01:30:50 <Baughn> Though the problem seems to be with applicative, not monad; the monad operation (i.e. join) is pretty obviously just tree grafts
01:31:07 <tensorpudding> data Tree a = Tip | Node a (Tree a) (Tree a) seems to be the common one
01:31:50 <Baughn> data Tree a = Leaf a | Tree a a is the other one
01:32:07 <Baughn> Er.
01:32:20 <int-e> Tree (Traa a) a (Tree a) :)
01:32:33 <Baughn> data Tree a = Leaf a | Node (Tree a) (Tree a)
01:32:53 <int-e> sorry. I should read more carefully.
01:33:50 <Baughn> tomas_: Monads aside, you'd probably get some use from the Writer monad.
01:34:11 <tomas_> mine is close to this: data Tree a = Empty | Tree a [Tree a]
01:34:30 <Baughn> ..that's a syntax error, isn't it?
01:34:37 <Baughn> Hm. No.
01:34:38 <koeien37> no, why?
01:34:55 <Baughn> Just a mental error. :P
01:34:56 <tensorpudding> hmm
01:35:10 <Baughn> I'm unused to reusing the type name as a constructor unless it's the only one, but it makes sense here
01:35:16 <tensorpudding> that allows for arbitrary numbers of branches i suppose
01:35:36 <Baughn> There's redundancy, though
01:35:46 <tomas_> Yeah, it splits into a top branch, and a bunch of bottom branches
01:35:50 <Baughn> data Tree a = Tree a [Tree a] would be sufficient; EMpty corresponds to []
01:35:56 <tensorpudding> yeah
01:35:59 <tensorpudding> i just noticed that
01:36:21 <tensorpudding> essentially eache tree is a list of its immediate subtrees
01:36:30 <Saizan> ?
01:36:43 <Saizan> Baughn: Empty doesn't have an 'a'
01:36:50 <Baughn> The question is, does [Empty,Empty] differ from []?
01:36:51 <tensorpudding> that allows you to create infinite trees of finite height
01:37:01 <tomas_> but what I really want is O(1) access to those branches... so I was thinking of using an array and then got confused with monads and stuff
01:37:02 <tensorpudding> the leaves have no branches though
01:37:26 <tensorpudding> so instead of having Tree a Empty Empty, you just have Tree a []
01:37:29 <int-e> Baughn: ah, there are at least two applicatives that could be interesting - a grafting one, and a zipping one. for grafting, I guess my problem is that in the case of labeled internal nodes it's not clear where to put the grafted tree, and what to do about the label of that tree.
01:37:59 <Baughn> tomas_: Usually, you'd use a fixed number of subtrees per node
01:38:15 <tomas_> yes!
01:38:18 <tensorpudding> well, in general
01:38:25 <Baughn> tomas_: "data Tree a = Empty | Tree (Tree a) (Tree a)" also gives you O(1) access to the subtrees
01:38:48 <Baughn> ..missing an a there
01:38:51 <tensorpudding> you will have O(n_max) lookups for the subtrees of root
01:38:59 <tomas_> Baughn: no, no... i want the number of "bottom branches" to go down as I go down the tree
01:39:01 <Saizan> trees with labeled internal nodes are instances of the cofree comonad, trees with labeled leafs of the free monad
01:39:15 <tensorpudding> where n_max is the maximum number of immediate descendents
01:39:16 <Baughn> tomas_: In that case, you probably would have to use arrays
01:39:24 <tensorpudding> because you'll need (!!) to do a lookup
01:39:25 <Baughn> tomas_: But it's an unusual requirement. What are you modelling?
01:39:39 <tensorpudding> you could use an array of subtrees instead
01:39:39 <Saizan> which you can picture as zipping/grafting
01:39:40 <tomas_> I am trying to make a van Embde Boas tree
01:40:23 <Baughn> *Emde
01:41:15 <Baughn> tomas_: ..with the usual associated asymptotics? And persistent?
01:41:15 <fasta> tomas_, good, remember to post to Hackage when you are done :)
01:41:23 <tomas_> ata Tree a = Empty | Tree a (UA (Tree a))   something like this?
01:41:49 <Baughn> tomas_: Well, it can't be an /unboxed/ array
01:42:19 <Baughn> tomas_: To be honest, I suspect you're gaping over too much at once now, but it's an interesting thing to try. I wasn't aware of vEB trees. :)
01:43:09 <tomas_> Baughn : i don't know if making it persistent is better.... but I had a treap implementation to look at while writing,,, but I just can't get off the ground... maybe this is just too much for me at the moment
01:43:53 <Baughn> tomas_: By "persistent", I don't mean disk storage. A persistent structure is one where, if you alter it, you still have the original.
01:44:05 <Baughn> tomas_: For haskell, that's pretty much a given.
01:45:01 <tomas_> Baughn: space is already a problem for these trees.. that was my thinking it should be mutable
01:45:16 <Baughn> tomas_: It gets complex to guarantee structures that use /amortized/ complexity then, since you might e.g. keep hold of the structure just before a rebalancing operation and redo that a lot (it's possible, though), but vEB trees don't seem to use this.
01:46:28 <tomas_> it takes advantage of the fact that there are a limited number of things in the world... can get O(log log n) operations
01:46:34 <Baughn> tomas_: Ideally, a tree operation should use only O(1), or at most O(lg n) additional space, and the GC is good
01:46:48 <int-e> Well, modification is O(sqrt(M)) in a persistent setting, M being the number of keys.
01:46:49 <Baughn> tomas_: ..I'd say, make it pure. It'll probably work fine.
01:47:04 <int-e> (because you have to copy the root array)
01:47:51 <tomas_> Baughn: so I was thinking of a module where you could enter something like maxNumberOfEntries  and get to work with a structure for your problem
01:47:54 <int-e> hmm. wrong O, I mean Omega.
01:48:17 <Baughn> tomas_: You'd want that as a parameter for a makeTree function, sure
01:48:46 * Baughn notes that, for a priority queue, join has to be zip
01:49:12 <tomas_> Baughn: ok, i'll try pure... then i run into the same question, I need O(1) access to the [Tree a] .... or is Array (Tree a) ok?
01:50:08 <Baughn> tomas_: Array is fine.
01:50:43 <tomas_> Baughn: ok.. cause I know just enough that [Tree a] will give me O(n) which won't work
01:51:10 <Baughn> tomas_: Array gives you O(n) modification, though. Hm.
01:51:57 <Baughn> tomas_: I'm positive it's possible to do this purely, but.. maybe you /should/ make it mutable first. In which case, look at STArray.
01:52:27 <tomas_> Baughn: what if I do it first with a list,, and then try to improve?
01:52:43 <Baughn> tomas_: Well, I'm not sure what you could improve /to/
01:53:09 <tomas_> well... using something better than a list
01:53:10 <Baughn> You want an int-keyed map with O(1) lookup and modification..
01:53:18 <Baughn> That's mutable arrays, and only mutable arrays
01:53:34 <Baughn> The pure alternative probably requires an entirely different data structure
01:54:02 <tomas_> dang
01:54:02 <Baughn> tomas_: There's IntMap, which is O(lg n) on both, but.. it's O(lg n).
01:54:25 <tomas_> .... that might work... i'll bet it's somesort of balanced binary tree implementation
01:55:20 <tomas_> nope, radix
01:55:26 <sohum> is there an algorithm that finds the minimal set of edges to remove from a graph to create more disconnected components?
01:55:42 <Baughn> tomas_: http://hackage.haskell.org/package/EdisonCore <- Also, have you looked at this?
01:56:24 <tomas_> I have not... what is it?
01:57:07 <tomas_> looks like a 'Bible' of data structures
01:58:31 <Baughn> tomas_: Pretty much
01:58:38 <tensorpudding> there are lots of data structures available in haskell, there doesn't appear to be a lack of them
01:59:00 <fasta> tensorpudding, trust me, there is still a lack.
01:59:00 <Baughn> tomas_: Chris Okasaki's PhD is /the/ bible on how to port data structures to pure, lazy languages (i.e. haskell)
01:59:09 <fasta> You cannot have enough data structures.
01:59:14 <Baughn> tomas_: The package contains the structures he figured out while writing the bible. ;)
01:59:20 <luite> sohum: it's called edge connectivity. you can find it by finding the number of edge-disjoint paths between vertices (which you can do with maximum flow on a modification of the graph)
01:59:37 <tensorpudding> there is such a thing as too many, when there are so many that you need a fancy algorithm to choose which one to use :P
01:59:40 <Baughn> tomas_: His PhD is also available online, and definitely required reading if you're going to do this a lot.
01:59:57 <sohum> luite: fancy words I need to look up, gotcha! :P
02:00:04 <Baughn> tomas_: ..there are some very neat tricks in there.
02:00:10 <fasta> tensorpudding, you can automate that. If there are a thousand packages with the same interface, at least. :)
02:00:45 <luite> sohum: I'm not sure if there's a more efficient algorithm than just trying that max flow on all pairs of vertices, there might be :)
02:01:05 <luite> sohum: a graph is k-edge connected if you have to cut at least k edges to create two components
02:01:17 <tomas_> Baughn: well, i did some research to find an interesting data structure that I don't think is a part of haskell yet, So I thought I could make a project out of it.  Perhaps i need his book.
02:01:20 <tensorpudding> in any case, it highlights one way that haskell has a vastly different focus than some languages
02:01:26 <tensorpudding> or rather, the haskell community
02:01:40 <Baughn> tomas_: Probably. Let's see..
02:01:56 <Baughn> tomas_: http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf
02:02:08 <tomas_> yeah,,,, I saw that.
02:02:11 <Baughn> tomas_: There's also an actual book of it, which I recommend, but the contents are the same
02:02:31 <Baughn> ..but this is the sort of thing you'll want to bring on the bus for rumination.
02:02:47 <luite> sohum: but it is probably more complicated if you want to generalize it to the minimum number of edges to cut if you want to make k components, instead of just 2
02:03:01 <tomas_> sometimes a paper copy is helpful, maybe i'll read some of the pdf tonight to see how to implement ... um.. just had an idea
02:03:02 <mxc> has anyone here switched to emacs/viper from VIM for the supposedly excellent haskell-mode for emacs?
02:03:15 <Baughn> luite: Somehow, that problem just screams NP-complete at me.. it isn't, I guess?
02:03:34 <tomas_> Baughn: i just need O(1) access to that [Tree a] by index, not by any comparison or anything
02:03:37 <tensorpudding> i use haskell-mode although i used emacs before i used haskell
02:03:39 <Baughn> mxc: I don't think haskell-mode would be very happy in viper-mode..
02:03:50 <shambler> @where okasaki
02:03:51 <lambdabot> http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf
02:04:06 <Baughn> tomas_: And you'd think there would be a solution for that, but I don't think there is. Not for O(1) read /and/ write.
02:04:14 <mxc> @baughn - i hear great things about emacs haskell mode, but I love my vi-style editing
02:04:14 <lambdabot> Unknown command, try @list
02:04:28 <fasta> Baughn, if you consider DiffArrays, you can.
02:04:38 <Baughn> fasta: I don't want to consider those.
02:04:55 <fasta> Baughn, yes, it is more of a theoretical thing, not something you would want to use.
02:05:15 <Baughn> fasta: Besides, I can think of access patterns that'd break them nicely
02:05:22 <fasta> Baughn, like?
02:05:24 <tomas_> Baughn: i think I'll just implement as a standard List, and then (after having learned more) try to change it to something else
02:05:40 <Baughn> fasta: They /copy/ the array on write, except the "head"..
02:05:51 <sohum> luite: right. 2 components will do nicely for the time being, but k-edge-connectivity looks like a related but separate problem.  lemme read more...
02:05:57 <Baughn> fasta: Wait, actually, it was on read of the pre-written version, wasn't it?
02:06:03 <Baughn> fasta: So just do that. A lot.
02:06:19 <Baughn> tomas_: How large are those lists going to be, anyway?
02:06:43 <fasta> Baughn, it was my understanding that you can implement single-threaded algorithms with the same complexity as in C.
02:06:58 <Baughn> fasta: So long as you don't do anything you couldn't do in C.
02:07:08 <luite> Baughn: determining edge connectivity isn't :) I think that for fixed k, the other problem isn't either
02:07:14 <fasta> Baughn, yes, you should not go and share stuff.
02:07:15 <luite> but I'm not sure
02:07:17 <Baughn> fasta: It allows you to pretend the structure is persistent, and everything is fine until you try to /use/ the persistence.
02:07:24 <fasta> Baughn, yep.
02:07:25 <Baughn> Seems pretty pointless to me
02:07:41 <fasta> Baughn, but for an index structure in a tree, that works fine, no?
02:07:42 <tomas_> Baughn: it all depends on the 'universe' size.  the rood node will have sqrt(w)  w=elements in universe     so BIG overhead in space unless you use a lot of the universe
02:08:11 <Baughn> tomas_: Wait, w is the universe size in bits, isn't it?
02:08:41 <tomas_> no,, actual universe size
02:08:45 <Baughn> Ulp
02:08:56 <Baughn> ..you don't want a list for that.
02:09:08 <Baughn> tomas_: Use an IntMap. It's not ideal, but it's a heck of a lot better than a list.
02:09:13 <tomas_> so doing this on 32-bit sized universe would take 64Mb just for the pointers!
02:09:21 <Baughn> tomas_: You'll miss the complexity requirements, but not by nearly as much. ^^;
02:09:22 <tomas_> for just the node!
02:09:49 <Baughn> fasta: I'm pretty sure it'd be way slower than the list
02:09:53 <sohum> luite: and, hm, this seems to treat minimal as just number of edges. though I suppose that's easily extendable to weights...
02:09:57 <Baughn> fasta: For non-64MB lists.
02:10:10 <Baughn> fasta: Actually, even for 64MB lists, if you invoke the copying a lot..
02:10:33 <mxc> is yi dead?
02:11:12 <fasta> mxc, it was never alive unless I missed some break-through in our understanding of life.
02:11:38 <tomas_> data VEB a = Int a a (VEB a) IntMap (VEB a)  something like this?
02:11:41 <mxc> is the yi editor project no longer under active development
02:11:43 <luite> sohum: oh I guess you can just run it on the original graph because you are just looking for edge independent paths (and not vertex independent paths like with vertex connectivity)
02:12:00 <luite> sohum: the max flow algorithm will also give you a minimum cut
02:12:45 <luite> sohum: for weighted edges, you can just determin the maximum flow first, and use a minimum cost flow algorithm to determine the minimum cost cut
02:13:32 <luite> sohum: each arc still has unit capacity, the weights are in the costs
02:15:04 <sohum> luite: /me reeeads
02:17:02 <luite> sohum: ok, just ask if anything isn't clear. my explanation is probably not very coherent :)
02:19:01 <luite> sohum: oh you might want to look up the max-flow min-cut theorem, this basically tells you that if each arc has capactity 1, and you can send n units of flow from s to t, there is a way to disconnect s and t, by cutting n arcs
02:21:03 <sohum> luite: ok, first problem. how do I pick s and t?
02:21:24 <luite> sohum: try each pair :)
02:23:02 <luite> sohum: (that was the part where I wasn't sure if there is a more efficient way to do it)
02:30:08 <tomas_> um.... what's a good type for a field that could be either an Int or []?
02:30:33 <tomas_> "Maybe' would work, but i'm not sure if there is something else?
02:31:03 <koeien37> [] is not a type
02:31:15 <koeien37> if you mean the empty list as value, then, yes, Maybe
02:31:18 <koeien37> Maybe Int
02:32:06 <tomas_> i just want it to have 'another' value that I can check against, but otherwise an Int
02:32:22 <tensorpudding> > Nothing :: Maybe Int
02:32:23 <lambdabot>   Nothing
02:32:25 <koeien37> yeah, just use Maybe Int then
02:32:36 <tensorpudding> > Just 5 :: Maybe Int
02:32:37 <tomas_> Ok
02:32:37 <lambdabot>   Just 5
02:32:40 <koeien37> (on a related note, normally I would advise against using Int and use Integer instead.)
02:33:03 <tensorpudding> using Int is okay if you are only working with "small enough" numbers
02:33:18 <tomas_> which one is limited to 32 bits (or architecture limited?)
02:33:37 <koeien37> Int is implementation-defined, but at least 29 bits iirc
02:33:45 <tensorpudding> @type maxBound :: Int
02:33:45 <lambdabot> Int
02:33:50 <tensorpudding> err
02:33:53 <koeien37> then you're lucky
02:33:54 <tensorpudding> > maxBound :: Int
02:33:55 <lambdabot>   9223372036854775807
02:33:58 <koeien37> if it's 2^63-1
02:35:03 <tomas_> > (maxBound :: Int ) == 2^31-1
02:35:04 <lambdabot>   False
02:35:13 <tomas_> > (maxBound :: Int ) == 2^31 - 1
02:35:14 <lambdabot>   False
02:35:23 <ddarius> > maxBound Int
02:35:24 <lambdabot>   Not in scope: data constructor `Int'
02:35:28 <ddarius> > maxBound :: Int
02:35:29 <lambdabot>   9223372036854775807
02:35:29 <tomas_> > (maxBound :: Int ) == 2^63 - 1
02:35:30 <lambdabot>   True
02:36:02 <Cale> Int is at least 30 bits actually
02:36:06 <ddarius> If you need a specific number of bits, use Data.Int (or Data.Word for unsigned data) and the Int32, etc. types.
02:36:18 <tomas_> haha,, lambdabot is 64 bit.... my computer returns true as if it is only 32 bits
02:36:30 <koeien37> precisely
02:36:35 <koeien37> that's one of the reasons that it's evil
02:36:47 <Cale> (which gives it a range from -2^29 to 2^29 - 1)
02:36:52 <koeien37> ah yes, that was it
02:38:12 <tomas_> well,,, i need it to specify the number of bits in something... i don't think 2^64 bits (ie: 2^2^64) is really going to be needed
02:38:51 <koeien37> a) you just said that for you it's only 2^31 - 1; b) intermediate calculations also shouldn't cross the bound of 2^29 - 1
02:39:03 <koeien37> of course, for one-off scripts it's fine
02:39:47 <ddarius> For one-off scripts, usually Integer is fine too...
02:39:54 <tensorpudding> i use Integrable sometimes
02:40:04 <tensorpudding> err, Integral*
02:40:13 <koeien37> ddarius: yeah, but then length returns an Int, and you need to fromIntegral it, and so on
02:40:22 <ddarius> Who uses length?
02:40:30 <koeien37> I sometimes, I hope to avoid it though
02:40:47 <b_jonas> koeien37: no, you can use genericLength
02:40:52 <b_jonas> @type genericLength
02:40:53 <lambdabot> forall b i. (Num i) => [b] -> i
02:40:53 <koeien37> I know. That's longer to type
02:41:05 <b_jonas> which does the fromIntegral for you
02:41:05 <koeien37> length should return an Integer (or Num i => i)
02:41:48 <Ke> so I can't pattern match constructors that take the same arguments separately?
02:42:02 <b_jonas> Ke: what?
02:42:04 <koeien37> I'm not sure what you're asking
02:42:11 <Ke> like data timeInterval = Hourly | Daily
02:42:26 <Ke> Warning: Pattern match(es) are overlapped
02:42:39 <koeien37> oh you can do this, but Haskell works from top to bottom
02:42:55 <Ke> what's the overlapping
02:42:59 <koeien37> so first line is tried. If it matches, it's used and the rest is ignored. Then the second match
02:43:13 <Ke> surely It can't have 2 different constructors
02:43:28 <koeien37> > let f [] = "Empty"; f (x:xs) = "not empty;" f (x:y:xs) = "this is never reached because it overlaps" in f [1,2]
02:43:29 <Cale> Ke: btw, careful about case -- type names must start with an uppercase letter (same as data constructors)
02:43:29 <lambdabot>   <no location info>: parse error on input `='
02:43:41 <koeien37> > let f [] = "Empty"; f (x:xs) = "not empty"; f (x:y:xs) = "this is never reached because it overlaps" in f [1,2]
02:43:42 <lambdabot>   "not empty"
02:44:04 <koeien37> GHC will give a warning for this ^
02:44:08 <Ke> http://pastebin.com/m24b81cd5 this is the error
02:44:27 <Baughn> That is not an actual error, but instead a warning
02:44:32 <Ke> you can see the patterns
02:44:34 <Ke> true
02:44:43 <b_jonas> Ke: could you show us the code too?
02:44:43 <Cale> is that the whole definition?
02:44:47 <koeien37> we would need the source code of the getNextTime (and preferrably of the data type too)
02:45:01 <koeien37> Cale: unlikely, there are some more dots there
02:45:03 <Cale> From only the visible code, I don't see any overlapped patterns
02:45:12 <koeien37> in the second-to-last line
02:45:23 <Cale> koeien37: yeah, I see that
02:45:55 <Ke> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15828#a15828 code
02:46:10 <koeien37> Ke: ah yes, the second line matches all
02:46:14 <koeien37> line 93
02:46:18 <Cale> getNextTime timing thisTime = getNextSetTimeMonth timing thisTime True
02:46:25 <Cale> this overlaps with everything below it
02:46:46 <Ke> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15829#a15829 data declaration
02:47:21 <Ke> oops, true
02:47:30 <koeien37> you missed the SetTime constructor
02:48:43 <Cale> which is important, because most of the cases are handled by recursion with a SetTime as the new parameter
02:48:45 <Ke> hanks
03:18:18 <blackh> Do you guy know if space allocated by 'malloc' is counted in the heap profile?  It looks like it isn't.
03:18:29 <blackh> e.g. ByteString content
03:21:58 <koala_man> I have no idea, but mallocing more than some limit (128k on glibc I think) will skip the heap and mmap some cow memory instead
03:24:41 <phr> does anyone ever think about modifying/extending haskell's syntax to make it more EDSL-friendly?
03:24:50 <blackh> I've done a whole lot of experimenting and it seems that 'live' (as reported by +RTS -S) reflects my ByteString content but the heap profile (as reported by +RTS -hc) doesn't.
03:27:40 <sohum> @pl \(a,b,c,d) -> (a, b, f c, d)
03:27:41 <lambdabot> (line 1, column 6):
03:27:41 <lambdabot> unexpected ","
03:27:41 <lambdabot> expecting letter or digit, operator or ")"
03:27:41 <lambdabot> ambiguous use of a non associative operator
03:27:47 <sohum> right
03:33:16 <koeien37>  @pl can't do large tuples
03:38:46 <b_jonas> @pl (a, (b, (c, d)) -> (a, (b, (f c, d))
03:38:47 <lambdabot> (line 1, column 3):
03:38:47 <lambdabot> unexpected ","
03:38:47 <lambdabot> expecting letter or digit, variable, "(", operator or ")"
03:38:53 <b_jonas> @pl (a, (b, (c, d))) -> (a, (b, (f c, d)))
03:38:54 <lambdabot> (line 1, column 18):
03:38:54 <lambdabot> unexpected ">" or "-"
03:38:54 <lambdabot> expecting variable, "(", operator or end of input
03:38:59 <b_jonas> @pl \(a, (b, (c, d))) -> (a, (b, (f c, d)))
03:39:00 <lambdabot> uncurry ((`ap` snd) . (. fst) . flip flip snd . (ap .) . flip flip fst . ((.) .) . (. ((. ((,) . f)) . (.) . (,))) . (.) . (.) . (,))
03:39:53 <koeien37> quite pleasant
03:45:37 <HugoDaniel> "cow memory" :D
03:45:39 <HugoDaniel> thats a nice term
03:46:25 <luite> > let ssf = second.second.first in ssf f (a,(b,(c,d))) :: (Expr,(Expr,(Expr,Expr)))
03:46:27 <lambdabot>   (a,(b,(f c,d)))
03:59:25 <pozic> I have a data structure containing a set of objects, but some of the properties of these objects can only be computed when the whole list has been computed. This leaves me with a choice: either generate a bogus value for one of the fields of the object, or create a completely new structure which basically encodes that they field has been set. If the implementation is correct, these bogus values will later be replaced with useful information, of course. W
03:59:44 <Botje> you got cutoff after "of course"
04:00:49 <pozic> . What do you think is the best solution in these cases? The bogus value way does not lead to an explosion of data types, but does lose the ability to show every possible value in the system while debugging.
04:00:56 <Cale> pozic: Isn't that just normal recursion?
04:01:21 <pozic> Cale: everything is recursion in Haskell.
04:01:24 <Cale> pozic: You define the values such that their fields depend on the list that they belong to.
04:01:38 <Cale> There's not necessarily any problem with doing that.
04:02:39 <Cale> > let xs = [Just (length xs), xs !! 1, Nothing] in xs
04:02:40 <pozic> Cale: data Foo = Foo Int SetLater. The Ints are computed via some function map f, but the SetLater field will be undefined at that point.
04:02:43 <lambdabot>   mueval-core: Time limit exceeded
04:02:48 <Cale> > let xs = [Just (length xs), xs !! 0, Nothing] in xs
04:02:49 <lambdabot>   [Just 3,Just 3,Nothing]
04:03:02 <Cale> But you do need to be careful about infinite loops of course :)
04:03:22 <pozic> Cale: if you want to avoid that, the only thing you really can do is to encode data Foo = Foo Int (Maybe SetLater) or something isomorphic.
04:03:53 <Cale> Why does it need to be set later?
04:04:12 <Cale> Is it because you need to do some I/O before they can be determined?
04:04:30 <pozic> Cale: because it depends on two subsequent elements from the list actually.
04:04:47 <Cale> Why is that a problem?
04:05:02 <pozic> Cale: I can also write it in a similar way like fibs.
04:05:08 <Cale> Why not just set it to depend on those elements now?
04:05:42 <Cale> As long as there is *some* order in which things can be computed, you'll be fine
04:06:19 <pozic> Cale: I will see how that comes out.
04:07:21 <pozic> Cale: I already see the problem with that.
04:08:42 <pozic> Cale: I already zip [1..] before to set an index in the objects. So, unless I inline the meaning of all the standard functional combinators, it won't work.
04:11:32 <Cale> hmm, I'm not sure I understand
04:14:33 <pozic> Cale: Currently, I use map (\(index,oneField) -> MyObject{i= index, someField=oneField})(zip [1..] xs). If I delete that code I basically have to do the enumeration of [1..] in the function proposed by you.
04:16:15 <pozic> Cale: never mind. I will just write it with undefined and if there is a bug, I will change it into Maybes.
04:31:08 <Designer> can i make a GUI with haskell?
04:31:23 <koeien37> @faq Can you make a GUI with Haskell?
04:31:23 <lambdabot> The answer is: Yes! Haskell can do that.
04:31:37 <wto> Designer: Yes, certainly.
04:32:38 <slava> dons: have you been deleting jdh30's comments on proggit?
04:34:06 <slava> dons: even if you dislike his trolling, that seems unfair, I think only spam should be deleted
04:39:18 <jkramer> Hello again
04:39:40 <jkramer> Is there a way to prevent Data.Text.toUpper from converting  to SS?
04:39:57 <Axman6> a
04:40:02 <Axman6> whoops
04:40:14 <koeien37> I think that is defined like that by Unicode
04:40:51 <jkramer> Really? I think it's pretty weird
04:41:08 <jkramer> There's no way to convert it back to lower case in a sane way
04:41:14 <koeien37> nope
04:41:20 <jkramer>  -> SS -> ss
04:41:21 <slava> jkramer: toLower(toUpper(x)) != id(x)
04:41:21 <koeien37> toUpper is not an injection
04:41:56 <jkramer> That's why I'd prefer to retain the 
04:42:22 <koeien37> I believe in German, you would get SS in an upper case word
04:42:28 <koeien37> not sure about other lagnuages that use it
04:44:01 <jkramer> Looks like there actually is a uppercase version of : http://en.wikipedia.org/wiki/Capital_%C3%9F
04:45:30 <Baughn> Just barely. It seems to be missing in the standard fonts.
04:45:47 <burp> > exp (-10^39) :: CReal
04:45:53 <lambdabot>   mueval: ExitFailure 1
04:46:31 <jkramer> So there's no way to prevent the  from being converted to SS?
04:46:56 <koeien37> none that I know of -- except for the slow version : unpack all chars, convert by hand, repack
04:47:36 <HugoDaniel> i have a list like: [(0,"","","",""),(0,"","","",""), ..  how do i easily remove the first value from the first tuple ?
04:47:48 <HugoDaniel> is it always necessary to create a matching function ?
04:47:49 <koeien37> extract?
04:48:03 <HugoDaniel> oh, i dont know that one... let me check it out
04:48:05 <koeien37> (\(x, _, _, _)) . head -- Beware! partial
04:48:21 <koeien37> no, I meant, what do you mean by "remove"?
04:48:26 <HugoDaniel> extract yes
04:48:27 <HugoDaniel> sorry
04:48:29 <HugoDaniel> access
04:48:33 <HugoDaniel> s/remove/extract
04:48:34 <koeien37> (\(x, _, _, _) -> x) . head -- Beware! partial
04:48:38 <HugoDaniel> yes
04:48:43 <HugoDaniel> head can output an exception
04:48:51 <koeien37> that is correct.
04:49:02 <koeien37> So you'd have to specify what should happen if your list is empty
04:49:43 <Baughn> HugoDaniel: It is unusual to use N-tuples (for N>2). Usually, at that point you want an ADT instead.
04:50:45 <koeien37> that is a good suggestion
04:50:50 <koeien37> you also get record accessors then
04:51:00 <koeien37> (if you opt to use record notation)
04:51:02 <interferon> why does  filter ("." /=) ["." "foo"] give me type inference errors?
04:51:08 <interferon> i want to return all elements not equal to "."
04:51:16 <koeien37> you miss a comma (,)
04:51:20 <koeien37> after "." in your list.
04:51:32 <interferon> oh no
04:51:33 <koeien37> > filter ("." /=) [".", "foo"]
04:51:33 <interferon> :)
04:51:34 <interferon> tahnks
04:51:34 <lambdabot>   ["foo"]
04:51:53 <interferon> that's silly on my part
04:52:02 <jkramer> intercalate (Data.Text.pack "") $ Prelude.map Data.Text.toUpper $ Data.Text.split (pack "") $ Data.Text.pack "Strae"
04:52:08 <jkramer> > intercalate (Data.Text.pack "") $ Prelude.map Data.Text.toUpper $ Data.Text.split (pack "") $ Data.Text.pack "Strae"
04:52:09 <Baughn> interferon: And though it's mainly irrelevant, I think (/= ".") reads better, don't you?
04:52:10 <lambdabot>   Not in scope: `Data.Text.pack'Not in scope: `Data.Text.toUpper'Not in scope...
04:52:15 <Baughn> "Doesn't equal ".""
04:52:49 <koeien37> very stylistic, although i would probably write it like (/= ".") too
04:53:09 <Baughn> interferon: There's no need to replicate the typical "if (0 == foo)" scheme of C, since it' simpossible to mix up assignment and comparison
04:53:47 <koeien37> I find that hard to read, although the rationale to use it is sound. Assignments shouldn't be expressions anyway
04:54:17 <slava> its handy in C when asigning the same value to multiple variables
04:54:19 <slava> x = y = foo
04:54:34 <koeien37> ugly, I'd prefer, x,y = foo, foo
04:54:41 <slava> that would compute foo twice :)
04:54:44 <interferon> if i have a binding of type IO [String] in an IO monad and want to map and filter over it, do i need to lift map and filter?
04:54:52 <koeien37> slava: that's why we have referential transparency :)
04:55:02 <slava> interferon: there's mapM
04:55:05 <koeien37> interferon: depends how you want to map
04:55:14 <koeien37> if you want to map String -> a, then yes, use liftM
04:55:17 <b_jonas> koeien37: you still have to _write_ foo twice, and it can be a complicated expression
04:55:39 <slava> koeien37: referential transparency does not give you automatic memoization for everything, though
04:55:41 <koeien37> b_jonas: ack. but then I'd prefer x = foo; y = x; anyway. In haskell it is a meaningless operation anyway
04:55:46 <Baughn> koeien37: foo <- thingOfTypeIO[String]; let bar = map f . filter p $ foo
04:55:51 <slava> and pure languages are a pain in the ass anyway :)
04:55:55 <Baughn> Er, interferon
04:55:57 <koeien37> slava: yeah, I hate them
04:56:33 <interferon> i have  entries <- getDirectoryContents storeDir;   ok <- mapM (storeDir ++) . filterM (/= ".") $ entries
04:56:41 <interferon> but it doesn't compile due to typing errors
04:56:44 <koeien37> that's correct
04:57:01 <koeien37> entries <- getDir.... ; let ok = map (storeDir ++). filter (/= ".") $ entries
04:57:29 <koeien37> that's the better way of writing it ^
04:57:42 <interferon>     Couldn't match expected type `Char' against inferred type `[Char]'
04:57:42 <interferon>     In the second argument of `(/=)', namely `"."'
04:57:48 <koeien37> you use <- to extract values from IO computations, and you use let to bind variables to (pure) values
04:58:03 <koeien37> interferon: was that what you got?
04:58:14 <interferon> yeah...strange
04:58:21 <koeien37> that is probably due to the fact that the monad inferred is the list monad
04:58:26 <koeien37> that can be confusing
04:58:28 <koeien37> oh no
04:58:33 <koeien37> well, maybe
04:58:47 <interferon> but the function is typed IO
04:58:58 <interferon> IO [FilePath]
04:58:58 <koeien37> yeah, but locally you are using filterM
04:59:02 <interferon> i see
04:59:08 <interferon> ah!
04:59:18 <interferon> switching back to filter and map with the let = syntax did it
04:59:34 <koeien37> you could write it as a one-liner with    map .. . f ... `liftM` getDirectoryContents "bla"
04:59:44 <koeien37> but this way is clearer I think
05:00:27 <koeien37> basically, everytime you see   do { x <- m; return (f x) }, you can replace it by f `liftM` m
05:00:38 <voidprayer> koeien37: what module should I import if I want to use <- ?
05:00:44 <koeien37> voidprayer: None!
05:00:52 <koeien37> it's special syntax
05:01:17 <interferon> i see
05:01:22 <interferon> thanks koeien37 and Baughn
05:01:28 <koeien37> > do { x <- [1,2,3]; return (x+1) } -- voidprayer
05:01:29 <lambdabot>   [2,3,4]
05:02:40 <voidprayer> koeien37: Then if I want to return the value (getStdRandom $ randomR (1, 100)) in Int, what should I do?
05:02:46 <Baughn> voidprayer: You'll use <- and do-syntax /all the time/ for IO, but there's a bit more to it than just that
05:02:58 <koeien37> :t getStdRandom
05:02:59 <lambdabot> forall a. (StdGen -> (a, StdGen)) -> IO a
05:03:07 <koeien37> :t randomR (1,100)
05:03:08 <lambdabot> forall t g. (Num t, Random t, RandomGen g) => g -> (t, g)
05:03:24 <jkramer> Is there a way to load a Main.hs (including a definition of main) in ghci and import the other functions in that file too?
05:03:24 <koeien37> :t getStdRandom $ randomR (1,100) :: IO Int
05:03:25 <lambdabot> IO Int
05:03:38 <jkramer> When I do :l Main.hs, I only see the main function
05:03:53 <koeien37> voidprayer: it works ^, what is your question?
05:03:56 <voidprayer> Baughn: hmmm. That's a little beyond me. I will read more about this.
05:04:20 <koeien37> if you want to use random numbers, the best thing is to read a little about IO in Haskell
05:04:46 <koeien37> jkramer: is there module Main(main) where .. at the top?
05:04:47 <Baughn> voidprayer: It just codes for a particularily useful pattern of function combination
05:04:54 <jkramer> koeien37: No
05:05:11 <koeien37> then you should be able to see all the functions in the file.
05:06:09 <jkramer> But I only see main. When I comment that function out and load Main.hs again, all the other functions become visible
05:06:23 <koeien37> your file is named Main.hs ?
05:06:29 <jkramer> Yup
05:06:30 <koeien37> I'll try to reproduce here
05:07:16 <koeien37> it works here. what's your GHC version?
05:07:22 <voidprayer> koeien37: Sorry for asking these before I learn IO. IO Int -> Int? also <- ?
05:07:25 <blackh> jkramer: I have noticed that too (with ghc 6.10.4)
05:07:30 <jkramer> The Glorious Glasgow Haskell Compilation System, version 6.10.3
05:07:32 <PeakerWork> @type uncurry . flip $ (,)
05:07:33 <lambdabot> forall a b. (a, b) -> (b, a)
05:07:33 <koeien37> -> and <- are not related
05:07:45 <koeien37> voidprayer: there is no function IO a -> a
05:07:53 <b_jonas> jkramer: try :l *Main.hs
05:08:03 <b_jonas> with the asterisk
05:08:14 <koeien37> -> is used for function declarations, <- is used in do-notation to extract values
05:08:15 <jkramer> b_jonas: That worked, thanks :)
05:08:24 <koeien37> why did it work for me then? (6.10.4)
05:08:58 <jkramer> koeien37: Did you provide a main function in your Main.hs?
05:09:05 <koeien37> yes.
05:09:08 * Baughn pokes unsafePerformIO with a stick
05:09:14 <koeien37> Baughn: ssh
05:09:16 <jkramer> And the other functions showed up in ghci anyway?
05:09:19 <koeien37> yes
05:09:24 <jkramer> Weird
05:09:25 <PeakerWork> -> is also used in "case" and <- is also used in list comprehensions
05:09:40 <koeien37> PeakerWork: ah yes
05:09:43 <Baughn> However, the <- in list comprehensions is the same as the <- in do-syntax
05:10:18 <blackh> jkramer, koeien37: A compiled vs. interpreted thing?
05:10:22 <b_jonas> blackh: yep
05:10:26 <koeien37> ah that could be it
05:10:26 <b_jonas> that's why they star helps
05:10:36 <koeien37> the star forces interpretation?
05:10:53 <benmachine> yes
05:11:05 <koeien37> then the rest is inlined or not visible to the world. makes sense.
05:11:23 <jkramer> Good to know :)
05:11:50 <benmachine> koeien37: well, it must not be visible to the world, I guess it's not exported for some reason
05:12:33 <benmachine> things that are inlined but exported would have to have stuff about them in the interface file
05:12:45 <benmachine> so you'd expect to be able to use them
05:14:53 <mchase> Hi.  Does anyone know which yum repository to add under CentOS/Red Hat to install ghc?
05:17:30 <mchase> I think I can get away with just connecting to the fedora repositories, but I can't find the repository URLs listed anywhere.  If anyone has a current fedora installation, could you please pass me the URLs from /yum.repos.d/*.repo?
05:20:16 <mchase> nevermind; all set, thanks.
05:24:48 <Feuersalamander> Hi,
05:25:47 <Feuersalamander> I want to know if it is possible to calculate something like sqrt 5 with higher precision in ghci
05:26:29 <Feuersalamander> Would be nice if someone could help me.
05:30:45 <ivanm> Feuersalamander: you can, but it'd be slow
05:30:53 <ivanm> get the CReal data type from the numbers package
05:31:04 <gwern> wow. Cryptonomicon is 42 hours in audiobook
05:31:06 <ivanm> it uses computable reals, which are technically infinite in precision
05:31:14 <gwern> the hebrews crossed the desert in less!
05:31:25 <PeakerWork> 40 years?
05:32:03 <ray> > sqrt 5 :: CReal
05:32:04 <lambdabot>   2.2360679774997896964091736687312762354406
05:32:06 <Feuersalamander> @ ivanm: thanks
05:32:38 <ivanm> PeakerWork: year, hour, same diff ;-)
05:32:43 <ivanm> Feuersalamander: no worries!
05:42:22 <pozic> slava: what did jdh30 say?
05:44:49 <ivanm> pozic: knowing jdh30, a load of garbage
05:44:50 <ivanm> ;-)
05:46:05 <pozic> If you have data A = A B and data B = B C and data C = C D and so on for some very large finite chain and then you decide to parameterize the final type let's say for this simple example Z. Now, you have to make changes in your whole program, just because of one silly type-parameter.
05:46:19 <pozic> Isn't there some better way of doing these things?
05:46:20 <slava> pozic: some of his criticisms are legitimate, others are not, but none of it justifies deletion
05:46:42 <ivanm> pozic: if you do that, then you're probably doing it wrong
05:46:47 <ivanm> slava: where's this?
05:47:11 <pozic> ivanm: it is just trivially generalizing some code.
05:47:20 <phr> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15838#a15838   is there some workable way to do what this is aiming at?
05:47:34 <pozic> ivanm: existentials can _sometimes_ do the same thing.
05:47:44 <koeien37> Suppose that I implemented an algorithm. suppose that I want to write a numeric type that keeps track of how often (*) is used in a certain section of the code
05:47:58 <koeien37> then you're normally out of luck, since you introduced a side effect :(
05:48:38 <ivanm> koeien37: I would argue that unless you can actually produce some code that _needs_ that, then you're scare mongering
05:48:47 <koeien37> i am not scare mongering
05:48:54 <b_jonas> lol
05:48:57 <koeien37> this is just a hypothetical scenario
05:49:11 <pozic> koeien37: I don't think you are right, btw.
05:49:25 <ivanm> koeien37: but one way of doing it is possibly with a State monad, make an instance of Num such that the State param keeps track of how many times you call (*)
05:49:27 <koeien37> pozic: i'd *love* to hear the best way
05:49:46 <koeien37> ivanm: yep, I would think that, too. Unfortunately this introduces some rewriting
05:50:01 <koeien37> in an impure language, it is easier but also a lot hackisher
05:50:11 <b_jonas> ivanm: you mean the Writer monad, right?
05:50:37 <koeien37> the Writer monad with some monoid with succ
05:51:00 <pozic> koeien37: you have to create a type-class which implements Num, but also operations which construct new numbers with a count already in them and a way to extract these numbers.
05:51:24 <koeien37> pozic: hrm.
05:51:28 <pozic> koeien37: but it is not completely transparent as a mutable solution might be.
05:51:29 <b_jonas> pozic: that might not work if your computation tree isn't tree-like
05:51:34 <koeien37> i didn't think of such an approach. Interesting!
05:51:59 <phr> there's some oleg-ism for enumerated trees that might handle koeien37's problem
05:52:48 <koeien37> the total number of calls to (*) is also not well defined in Haskell, I guess
05:52:56 <koeien37> if it's pure, anyway
05:53:07 <Jafet> Depends on how you want it defined
05:53:11 <ivanm> b_jonas: or could be Writer
05:53:13 <Jafet> (And if it's non-strict)
05:53:24 <ivanm> koeien37: laziness doesn't help
05:53:32 <ivanm> I would still wonder _why_ you'd want that
05:53:44 <Jafet> * is normally strict, though, for the built-in Num instances
05:53:49 <ivanm> the closest I've had is to make sure a program was working I had it call trace for every 1000th value it produced
05:53:52 <koeien37> I just was entertaining the thought, because I wanted to compare two algorithms via the total number of "primitive operations"
05:53:53 <ivanm> (or was it 10 000th?)
05:54:35 <Jafet> (Num t, Monad t) =>
05:54:40 <Jafet> (le gasp)
05:54:50 <pozic> koeien37: why not just run it in a simulator?
05:55:08 <pozic> koeien37: then you have actual values instead of fantasy ones.
05:55:38 <phr> koeien37, http://okmij.org/ftp/Haskell/numbered-monad.txt
05:56:13 <koeien37> phr: cool, thanks
05:57:05 <Jafet> > let sortedElem list x = elem x $ takeWhile (<=x) list; figure = 1 : 3 : scanl (+) 7 (drop 2 ground); ground = filter (not . (sortedElem figure)) [1..] in figure
05:57:06 <lambdabot>   [1,3,7,12,18,26,35,45,56,69,83,98,114,131,150,170,191,213,236,260,285,312,3...
05:57:50 <pozic> koeien37: that numbered monad is just State Int
05:58:44 <koeien37> pozic: yeah, I see it
05:58:45 <phr> anyone know anything about SMT?  it sounds scarily close to completely automatic theorem proving
06:01:06 <Jafet> "Most SMT solvers support only quantifier free fragments of their logics."
06:01:13 <Jafet> Not to me
06:01:43 <phr> hmm ok
06:02:13 <Jafet> From wikipedia, it sounds like a way to classify ATP heuristics
06:03:56 <phr> i wonder how hard it is to write one of those things.  i sort of understood how DPLL works, so starting from that
06:07:20 <Jafet> @faq Can Haskell solve the halting problem?
06:07:20 <lambdabot> The answer is: Yes! Haskell can do that.
06:07:38 <shambler> :S
06:09:59 <phr> aww, that yices package has no source code
06:10:16 <phr> i'm looking at tom hawkins' thing about atom verification
06:10:59 <ivanm> yay! CosmicRay is here! ;-)
06:11:16 <CosmicRay> uh oh
06:11:31 <CosmicRay> usually that is followed by "I've found a bug in..." ;-)
06:12:13 <ivanm> nah, I don't need anything
06:14:16 <ivanm> it's just that we see you so rarely here
06:14:47 <dmwit> And now you know why. ;-)
06:16:03 <ivanm> heh
06:16:18 <ivanm> dmwit: here I was thinking it was his son that took up all his time and prevented him from being here...
06:17:45 <voidprayer> koeien37: I finally understand a little about what you said. It seems if I touched anything with IO, I can never treat these information as pure information out of do.
06:18:16 <koeien37> that is the point, yep
06:18:33 <koeien37> there is no IO a -> a function
06:19:09 <koeien37> but you can use "pure" functions (without IO) from within do blocks, which we strive to do
06:19:19 <koeien37> typically we want few functions with IO type signatures
06:19:22 <gwern> (that, of course, is a Noble Lie)
06:19:37 <koeien37> gwern: I know :)
06:19:53 <koeien37> undefined, const undefined, and another one, even ;)
06:20:50 <ziman> :)
06:23:54 <Jafet> @hoogle IO a -> a
06:23:54 <lambdabot> Foreign unsafePerformIO :: IO a -> a
06:23:55 <lambdabot> Data.ByteString.Internal inlinePerformIO :: IO a -> a
06:23:55 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
06:24:04 <Jafet> One?
06:25:52 <dmwit> inlinePerformIO?
06:26:22 <dmwit> haha, "Very unsafe."  in italics
06:27:02 <dmwit> That sounds akin to "only a little bit pregnant".
06:27:54 <b_jonas> great!
06:28:20 <b_jonas> this hexpat module works
06:28:25 <b_jonas> I could parse and dump xml with it
06:30:04 <Philonous1> Jafet: Mind you, unsafePerformIO is neither a function nor haskell.
06:32:22 <djahandarie> unsafestPerformIO
06:34:10 <fasta> Philonous1, You don't consider the FFI spec to be part of Haskell?
06:35:52 <b_jonas> wtf
06:36:23 <Raynes> ftw
06:36:29 <b_jonas> I just entered this to ghci and it loaded a pageful of packages
06:36:32 <b_jonas> > Data.Encoding.decodeString Data.Encoding.CP1252.CP1252 (map toEnum (enumFromTo 0 128))
06:36:33 <lambdabot>   Not in scope: `Data.Encoding.decodeString'Not in scope: data constructor `D...
06:37:14 <mxc> i think haskell's imperative abilities are vastly underestimated
06:37:26 <mxc> the usual refrain is "haskell sux for IO lolz.."
06:38:17 <mxc> but, monadic IO programming can be super convenient
06:38:23 <mxc> imho
06:38:37 <koeien37> IO actions are first class values!
06:38:58 <koeien37> very useful
06:41:12 <ivanm> b_jonas: right, it loads up all the packages needed
06:41:40 <Philonous1> fasta: Well, that really is a sore spot. C functions should always be IO Foo -> IO Bar. Unfortunately we want to use some of them in pure code. I think it's a rather ugly hack.
06:41:51 <b_jonas> ivanm: why's template haskell and all that stuff needed?
06:42:07 <ivanm> b_jonas: because one of the libraries needs it
06:42:41 <Philonous1> fasta: Errr, Foo -> IO Bar I meant
06:43:29 <fasta> Philonous1, the Haskell assembly instruction to add two numbers in x86 is just as dangerous as the C one.
06:44:05 <fasta> Philonous1, so, some stuff is not a problem at all. That's the real reason unsafePerformIO exists.
06:44:17 <mxc> philonous1 - do you think pure DiffArrays should be allowed?
06:44:41 <mxc> semantically, they're pure, but there's a lot of unsafePerformIO in the background
06:48:10 <benmachine> isn't the same true of ByteStrings?
06:48:12 <Philonous1> fasta: It's not about how dangerous some code is, but whether or not the compiler can check it. And I have no problem with unsafePerformIO. My point is just that it leaves the burden of prooving that the code won't make your computer explode with the programmer. It's still an ugly hack. It's better than not having it, though
06:48:32 <benmachine> it's not an ugly hack, imo
06:48:55 <benmachine> weeeeell depends
06:49:01 <fasta> Philonous1, and the compiler cannot check everything until we have decent AI.
06:50:20 <fasta> (that is, in 2099, but probably earlier, you could try to scream to your compiler a proof of why something is safe).
06:54:12 <Jafet> Agda cries.
06:56:29 <fasta> Jafet, I got the impression Agda is still very much in flux and rather hackish.
06:56:41 <Jafet> Oh lord now everything is a hack
06:57:24 <Jafet> Next we'll call Coq a hackjob
06:57:29 <fasta> Jafet, I don't consider Coq to be hack.
06:57:53 <fasta> Jafet, but they do change their semantics still from release to release, which is a bad idea for these kinds of tools.
06:58:18 <Jafet> So... old programs work differently?
06:58:27 <fasta> Jafet, yes, they just don't work anymore.
06:58:39 <Jafet> Ah well, that isn't the worst that could happen
06:58:59 <fasta> Jafet, they do say in their release notes what should be changed to upgrade it to the new version, though.
06:59:15 <fasta> Jafet, and they are really minor points most of the time.
06:59:44 <fasta> Jafet, so overall, I am really positive about Coq :)
07:00:14 <Jafet> I think languages should have version pragmas
07:00:29 <Jafet> lilypond has it, but they don't use it properly, which is too bad
07:03:33 <bastl> lilypond is a very good program
07:03:59 <bastl> any interfaces to haskell? (besides the stuff in haskore)
07:04:22 <Jafet> It's not very good, actually, and it uses guile-scheme
07:04:34 <Jafet> And I don't know of any uses of it as a library
07:05:59 <bastl> At least the best I know for rendering music. though from software-engineering perspective some things are strange ...
07:20:57 <danr> is there a satisfy function in Parsec even when you are not parsing lists of chars?
07:22:49 <trez> hi there danr :)
07:23:51 <danr> hi trez ;)
07:24:04 <danr> maybe tokenPrim will do the job for me...
07:25:05 <Cale> danr: I was about to suggest that
07:25:52 <danr> Cale: it seems a bit cumbersome... is there a simpler function
07:26:54 <Cale> You could make one for your particular token type
07:29:03 <danr> Cale: I see...
07:34:16 <danr> @hoogle a -> (a -> Bool) -> Maybe a
07:34:17 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
07:34:17 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
07:34:17 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
07:35:11 <danr> @hoogle a -> Bool -> Maybe a
07:35:11 <lambdabot> Control.Exception assert :: Bool -> a -> a
07:35:12 <lambdabot> Control.OldException assert :: Bool -> a -> a
07:35:12 <lambdabot> Control.Exception.Base assert :: Bool -> a -> a
07:36:27 <benmachine> danr: are you looking for Nothing if the bool is false?
07:36:53 <benmachine> :t \x b -> x <$ guard b :: Maybe a
07:36:54 <lambdabot>     Inferred type is less polymorphic than expected
07:36:55 <lambdabot>       Quantified type variable `a' is mentioned in the environment:
07:36:55 <lambdabot>         x :: a (bound at <interactive>:1:1)
07:37:00 <benmachine> :t \x b -> x <$ (guard b :: Maybe a)
07:37:02 <lambdabot>     Couldn't match expected type `a' against inferred type `()'
07:37:02 <lambdabot>       `a' is a rigid type variable bound by
07:37:02 <lambdabot>           an expression type signature at <interactive>:1:31
07:37:06 <benmachine> oh yeah
07:37:09 <benmachine> :t \x b -> x <$ (guard b :: Maybe ())
07:37:10 <lambdabot> forall a. a -> Bool -> Maybe a
07:37:22 <benmachine> (in the real thing you wouldn't need the type annotation
07:37:24 <benmachine> )
07:37:36 <benmachine> :t \x b -> x <$ guard b
07:37:37 <lambdabot> forall a (f :: * -> *). (MonadPlus f, Functor f) => a -> Bool -> f a
07:38:02 <copumpkin> ugh
07:38:40 <benmachine> what WHAT
07:39:27 <copumpkin> MonadPlus f, Functor f bothers me
07:39:33 <benmachine> oh
07:39:35 <benmachine> yeah
07:39:45 <benmachine> is there a guard for Alternative?
07:40:32 <benmachine> doesn't look like it.
07:40:51 <danr> benmachine: i found toMaybe in utilityht
07:40:57 <danr> @hoogle toMaybe
07:40:57 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
07:41:04 <benmachine> @let guardA b = if b then pure () else empty
07:41:06 <lambdabot>  <local>:4:34:
07:41:06 <lambdabot>      Ambiguous occurrence `empty'
07:41:06 <lambdabot>      It could refer to eithe...
07:41:06 <danr> not in hoogle though
07:41:16 <benmachine> @let guardA b = if b then pure () else Control.Applicative.empty
07:41:18 <lambdabot>  Defined.
07:41:34 <benmachine> :t guardA
07:41:35 <lambdabot> forall (f :: * -> *). (Alternative f) => Bool -> f ()
07:41:50 <benmachine> :t \x b -> x <$ guardA b
07:41:51 <lambdabot> forall a (f :: * -> *). (Alternative f) => a -> Bool -> f a
07:41:57 <benmachine> copumpkin: better?
07:42:00 <danr> @hoogle (<$)
07:42:00 <lambdabot> Control.Applicative (<$) :: Functor f => a -> f b -> f a
07:42:01 <lambdabot> Text.Parsec.Perm (<$$>) :: Stream s Identity tok => (a -> b) -> Parsec s st a -> StreamPermParser s st b
07:42:01 <lambdabot> Text.ParserCombinators.Parsec.Perm (<$$>) :: Stream s Identity tok => (a -> b) -> Parsec s st a -> StreamPermParser s st b
07:42:19 <benmachine> x <$ f = const x <$> f
07:42:21 <benmachine> I think
07:42:22 <copumpkin> benmachine: yep
07:42:41 <danr> interesting combinator...
07:49:14 <benmachine> why is Applicative a superclass of Alternative?
07:49:43 <benmachine> actually, why is Alternative not just Monoid again
07:50:36 <copumpkin> benmachine: we like duplication, but it's also kind of different
07:50:48 * benmachine doesn't like duplication
07:51:05 <copumpkin> > Just 5 <|> Just 6
07:51:06 <lambdabot>   Just 5
07:51:18 <copumpkin> > Just (Sum 5) <|> Just (Sum 6)
07:51:20 <lambdabot>   Just (Sum {getSum = 5})
07:51:25 <copumpkin> > Just (Sum 5) `mappend` Just (Sum 6)
07:51:26 <lambdabot>   Just (Sum {getSum = 11})
07:53:07 <benmachine> > First (Just (Sum 5)) `mappend` First (Just (Sum 6))
07:53:09 <lambdabot>   First {getFirst = Just (Sum {getSum = 5})}
07:55:16 <benmachine> newtypes save the day
07:56:19 <aavogt> > () `mappend` ()
07:56:20 <lambdabot>   ()
07:56:34 <aavogt> > () `mappend` undefined
07:56:35 <lambdabot>   ()
07:57:30 <copumpkin> > undefined `mappend` ()
07:57:32 <lambdabot>   ()
07:57:37 <benmachine> > undefined `mappend` undefined :: ()
07:57:38 <lambdabot>   ()
07:57:45 <copumpkin> nice
07:57:48 <benmachine> :P
07:58:26 <aavogt> > fix (join mappend) :: ()
07:58:27 <lambdabot>   ()
07:59:00 <aavogt> > fix (join mappend)
07:59:01 <lambdabot>   ()
07:59:20 <aavogt> you don't need the type signature at all
07:59:26 <aavogt> thanks to defaulting
07:59:30 <benmachine> thanks, defaulting!
07:59:42 * benmachine notes there is also ArrowZero and ArrowPlus and hmphs
08:00:02 <benmachine> does every class need its own monoid?
08:00:05 <copumpkin> benmachine: there are at least three different ones with different kinds
08:00:21 <copumpkin> *, * -> *, and * -> * -> * and they necessarily behave differently
08:00:29 <benmachine> how?
08:00:36 <copumpkin> * can "look inside" because it knows the full type
08:00:39 <copumpkin> * -> * can't
08:00:46 <aavogt> class Hmphs a where hempty :: a; happend :: a -> a -> a
08:01:00 <benmachine> Monoid (f a) can't look in a
08:01:20 <copumpkin> benmachine: you could put a constraint like Monoid a => Monoid (f a)
08:01:22 <aavogt> it can if you have   Monoid a => Monoid (f a)
08:01:30 <copumpkin> benmachine: `mplus` or <|> can't at all
08:01:31 <benmachine> true
08:01:36 <benmachine> hmm
08:01:46 <benmachine> hmmmmm
08:01:55 <aavogt> that's not a H98 instance declaration though?
08:02:00 <benmachine> it is
08:02:07 <benmachine> well
08:02:11 <benmachine> for some f, it is
08:02:34 <benmachine> copumpkin: so Alternative is naturally more restricted in what it can do
08:02:49 <copumpkin> benmachine: in a sense, yeah
08:03:01 <copumpkin> that's why mappend can add the inner Sums in the Maybe
08:03:04 <benmachine> copumpkin: okay, but there's still not really any sense in having MonadPlus and Alternative with their irrelevant superclasses
08:03:09 <copumpkin> yeah, definitely :P
08:03:27 <copumpkin> there should probably be three such classes, with all the appropriate superclass relations in place
08:03:41 <aavogt> there's no class for ones with kind:   * -> * -> * -> *
08:03:48 <benmachine> mm
08:03:59 <aavogt> that's probably too many type variables to be of practical use
08:04:13 <benmachine> well, two was too many until Arrows came along
08:04:29 <benmachine> copumpkin: what are the appropriate superclass relations?
08:04:32 <aavogt> but for the most part it still is?
08:04:37 <benmachine> yes
08:04:41 <benmachine> I suppose so
08:04:46 <aavogt> yeah, arrows aren't used too much
08:05:50 <benmachine> people import Control.Arrow quite a lot but mostly just to use the (->) instance
08:05:53 <benmachine> which doesn't really count
08:06:08 <copumpkin> benmachine: would need to think about it. Definitely the usual Functor, Applicative, Monad one, but I'd want to pull fail out of Monad and maybe add it to one of those monoidish classes, but I'm not sure if it would behave correctly
08:06:57 <benmachine> copumpkin: oh, you just mean general superclass fixing, not specific to the monoidal classes?
08:07:17 <copumpkin> benmachine: well, it would help monoidal classes too
08:07:17 <benmachine> (hey, isn't Category a monoid too?)
08:07:48 <aavogt> copumpkin: well fail can just be  const mempty, which it is for most Monad where it is used intentionally
08:08:10 <benmachine> hmm, monoids with two type parameters get interesting
08:08:29 <ski> (benmachine : well, each monoid gives rise to a category, at least)
08:08:59 <copumpkin> a category is like a generalized monoid
08:09:42 <benmachine> I think a general * -> * -> * monoid isn't possible, because what the two type variables are can become significant
08:09:49 <benmachine> mmmmaybe
08:10:37 <rfh> could someone help me with this please:
08:10:38 <benmachine> (e.g. we have cat b c -> cat a b -> cat a c, but who says we can't have some other thing with m a b -> m a b -> m a b?)
08:10:38 <rfh> http://pastebin.com/m36a587a7
08:11:15 <benmachine> :t toEnum
08:11:17 <lambdabot> forall a. (Enum a) => Int -> a
08:11:29 <copumpkin> rfh: you can have haskell derive Enum for you
08:11:29 <benmachine> rfh: looks like you've got fromEnum and toEnum the wrong way around
08:12:05 <rfh> copumpkin: but in this case i have to declare explicitly
08:12:07 <benmachine> toEnum transforms an int to your type, fromEnum transforms from your type to an int
08:12:40 <copumpkin> > toEnum `asTypeOf` id $ 5
08:12:41 <lambdabot>   5
08:13:49 <rfh> benmachine: right, now i have:
08:13:50 <rfh> http://pastebin.com/m2ae6b127
08:14:18 <koeien37> turn the mod into `mod`
08:14:21 <benmachine> rfh: if you want to use mod infix, you have to put ` around it
08:14:37 <koeien37> mod is not special like in some other languages
08:14:41 <koeien37> > mod 43 3
08:14:42 <lambdabot>   1
08:14:45 <koeien37> > 43 `mod` 3
08:14:45 <lambdabot>   1
08:14:47 <benmachine> you can either do (mod (fromEnum x - 1) 7) or (fromEnum x - 1 `mod` 7)
08:14:59 <benmachine> wait no
08:15:03 <koeien37> add parens there
08:15:06 <rfh> benmachine: wait, the order was right, the input is a day
08:15:07 <benmachine> (fromEnum x - 1) `mod` 7
08:15:23 <benmachine> rfh: the input is a day, so you use fromEnum to make it an Int
08:15:37 <benmachine> :t fromEnum
08:15:38 <lambdabot> forall a. (Enum a) => a -> Int
08:15:44 <benmachine> ^ a is Day here
08:15:55 <rfh> in the Enum type class its defined: toEnum :: a -> Int
08:16:01 <Nomad010> i'm a C person, but wouldn't (fromEnum x + 6) `mod` 7 be safer
08:16:07 <koeien37> no.
08:16:09 <Nomad010> is mod sign safe?
08:16:17 <koeien37> mod does the good thing
08:16:18 <burp> :type mod
08:16:24 <Nomad010> oh ok
08:16:26 <burp> :t mod
08:16:28 <lambdabot> forall a. (Integral a) => a -> a -> a
08:16:34 <koeien37> but in C it's implementation or platform dependent
08:16:39 <Nomad010> ya
08:16:41 <benmachine> rfh: open ghci and check :info Enum
08:17:11 <koeien37> > divMod (-1) 3
08:17:12 <lambdabot>   (-1,2)
08:17:20 <benmachine> > quotRem (-1) 3
08:17:20 <koeien37> > quotRem (-1) 3 -- for the other behavior
08:17:21 <lambdabot>   (0,-1)
08:17:21 <lambdabot>   (0,-1)
08:17:24 <rfh> benmachine: well, thank you, thats right
08:17:28 <joe1> just venting, please excuse. I wish ghci was as fast as the shell prompt.
08:17:48 <PeakerWork> having "platform-dependent" arithmetic operators is silly
08:17:59 <burp> @hoogle abs
08:18:00 <lambdabot> Prelude abs :: Num a => a -> a
08:18:00 <lambdabot> System.IO AbsoluteSeek :: SeekMode
08:18:00 <lambdabot> Data.Time.Clock.TAI data AbsoluteTime
08:18:02 <joe1> i do not want to be seen as a loser, someone who cannot contribute code but complains.. but, just a thought..
08:18:08 <PeakerWork> (which is why "Int" should be an internal type not used for most stuff
08:18:09 <koeien37> and on my platform % is "wrong" in C
08:18:24 <koeien37> at least, not the convenient mod of Haskell
08:18:47 <benmachine> koeien37: I think the idea is that you want (a / b) + (a % b) == a
08:18:50 <Gracenotes> % is defined in C much like / is, with respect to negative numbers
08:18:58 <koeien37> benmachine: surely you miss a b* there
08:19:01 <benmachine> and / tends to go towards 0 for some reason
08:19:03 <benmachine> koeien37: yeah
08:19:09 <rfh> but why i do get a type error
08:19:10 <koeien37> also true in Haskell
08:19:11 <rfh> http://pastebin.com/m2ae6b127
08:19:13 <Gracenotes> hey, in Java % is defined for doubles :/ so, C isn't that bad
08:19:20 <koeien37> Gracenotes: really? lol
08:19:34 <koeien37> rfh: change the mod into a `mod`
08:19:34 <benmachine> rfh: you haven't fixed the mod
08:19:38 <Gracenotes> well. it makes some sense mathematically. I've no idea how it's implemented
08:19:56 <rfh> yes right i forgot
08:19:59 <koeien37> benmachine: I use mod often to find a canonical representative of the residue classes mod n
08:20:14 <rfh> but mod a b goes well too
08:20:23 <koeien37> that is possible in Haskell with 'mod', and still the useful a = b*(a div b) + a mod b is true
08:20:31 <benmachine> rfh: mod a b and a `mod` b works, but a mod b doesn't
08:20:50 <rfh> ineed
08:20:53 <rfh> indeed
08:21:00 <benmachine> koeien37: yes, but I think haskell's div isn't the magic machine one
08:21:04 <koeien37> benmachine: I don't even know if that identity is supposed to hold in conforming C implementations
08:21:11 <koeien37> benmachine: probably not, if C does it differently
08:21:28 <benmachine> koeien37: that is how the weirdness of % was explained to me and it made sense, and then I stopped caring :)
08:21:53 <benmachine> so you can look it up if you like (and if you do I'd be curious to know) but I'm not going to bother
08:23:25 <b0fh_ua> Hi there! I am trying to create the function, which reads the line from console and appends it to list of lines if it doesn't match "quit" word. While it's simple to create such function using recursion - http://pastebin.com/d6500a305 - it is not clear for me of how to create the CPS-ed version of such function. So I could pass some lambda to define what to do next after line was read and it is not "quit". Can somebody please help?
08:23:37 <koeien37> wikipedia says C99 defines it
08:24:00 <benmachine> good old wikipedia
08:24:04 <koeien37> :t untilM
08:24:05 <lambdabot> Not in scope: `untilM'
08:24:14 <ski> > 6 `divideModulo` pi
08:24:16 <lambdabot>   (1,0.909859317102744)
08:24:56 <b0fh_ua> I can't even imagine the type of such function :(
08:25:00 <benmachine> > 1000000000 `divideModulo` 1.1
08:25:02 <lambdabot>   (909090909,9.090900421142578e-2)
08:25:09 <koeien37> > let (x,y) = divideModulo 6 pi in (x+y)*pi
08:25:10 <lambdabot>   Ambiguous type variable `t' in the constraints:
08:25:10 <lambdabot>    `GHC.Float.Floating t'
08:25:10 <lambdabot>  ...
08:25:13 <benmachine> :t divideModulo
08:25:14 <lambdabot> forall r i. (RealFrac r, Integral i) => r -> r -> (i, r)
08:25:20 <koeien37> > let (x,y) = divideModulo 6 pi in (fromIntegral x+y)*pi
08:25:21 <lambdabot>   6.0
08:25:54 <benmachine> so floordiv, multiply, and find the remainder?
08:25:58 <ski> > 6 `divideModulo` 0  -- er ?
08:25:59 <lambdabot>   (17976931348623159077293051907890247336179769789423065727343008115773267580...
08:26:06 <benmachine> neat
08:26:09 <ski> > properFraction (1/0)
08:26:11 <lambdabot>   (17976931348623159077293051907890247336179769789423065727343008115773267580...
08:26:16 <ski> is that a bug ?
08:26:42 <fasta> ski, it is just the largest double.
08:26:56 <koeien37> just below Infinity
08:27:06 <aavogt> > maxBound :: Double
08:27:07 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Types.Double)
08:27:07 <lambdabot>    arising from a use o...
08:27:08 <fasta> ski, and AFAIK, no.
08:27:18 <copumpkin> infinity - 1/infinity?
08:27:20 <benmachine> it involves doubles, therefore all bets are off :P
08:27:28 <aavogt> > first succ $ properFraction (1/0)
08:27:29 <lambdabot>   (17976931348623159077293051907890247336179769789423065727343008115773267580...
08:27:54 <koeien37> benmachine: that's how I think of floating point arithmetic generally :P
08:28:09 <fasta> CReal++
08:30:28 <benmachine> > properFraction (1/0) == (2 ^ 1024, 0)
08:30:30 <lambdabot>   True
08:30:42 <benmachine> 2 ^ 1024 is a strange number to have there
08:31:13 * benmachine tries to remember how floating-point works
08:31:13 <copumpkin> how did it get there?
08:31:32 <benmachine> experimentation in ghci put it there
08:32:48 <Twey> Wha'
08:33:00 <Twey> > 1/0
08:33:01 <lambdabot>   Infinity
08:33:09 <Twey> > properFraction (1 / 0)
08:33:10 <lambdabot>   (17976931348623159077293051907890247336179769789423065727343008115773267580...
08:33:16 <Twey> Interesting
08:33:20 <Twey> :t properFraction
08:33:20 <benmachine> > properFraction (0 / 0)
08:33:21 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> (b, a)
08:33:22 <lambdabot>   (-2696539702293473861593957786183537100426965468413459859101451217365990137...
08:33:40 <benmachine> that makes about as much sense
08:34:03 <aavogt> @src properFraction
08:34:04 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
08:34:16 <ski> @src RealFrac
08:34:16 <lambdabot> class  (Real a, Fractional a) => RealFrac a  where
08:34:17 <lambdabot>     properFraction                   :: (Integral b) => a -> (b,a)
08:34:17 <lambdabot>     truncate, round, ceiling, floor  :: (Integral b) => a -> b
08:34:21 <benmachine> fst (properFraction (0/0)) isn't even a power of two
08:35:34 <aavogt> > 2 ^ 1024 :: Double
08:35:35 <lambdabot>   Infinity
08:35:36 <niezapomniana> http://www.youtube.com/watch?v=PJWPN1DMOc0
08:35:45 <benmachine> 2 ^ 1023 :: Double
08:35:48 <benmachine> > 2 ^ 1023 :: Double
08:35:50 <lambdabot>   8.98846567431158e307
08:35:55 <aavogt> > 2 ^ 1024 :: Integer
08:35:56 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
08:36:05 <koeien37> 2^1023 should be enough for anybody
08:36:29 <Jafet> > 2 ^^ 1024 :: CReal
08:36:30 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
08:36:36 <aavogt> > iterate (^2) 2
08:36:37 <lambdabot>   [2,4,16,256,65536,4294967296,18446744073709551616,3402823669209384634633746...
08:36:57 <benmachine> > iterate (2^) 2
08:36:59 <lambdabot>   [2,4,16,65536,2003529930406846464979072351560255750447825475569751419265016...
08:39:13 <djahandarie> > 2^2^2
08:39:14 <lambdabot>   16
08:39:20 <Jafet> Don't make me pull out ackermann's
08:39:21 <djahandarie> \o/
08:41:06 <copumpkin> @let bb :: Integer -> Integer; bb = undefined
08:41:08 <lambdabot>  Defined.
08:41:35 <copumpkin> 2^2^2 proves that ^ is associative!
08:41:38 <copumpkin> yay
08:43:04 <djahandarie> I actually owned my memory one time forgetting to put parenthesis
08:43:11 <djahandarie> It was such an innocent statement too. =[
08:44:51 <Twey> > 2^3^4
08:44:52 <lambdabot>   2417851639229258349412352
08:44:56 <Twey> > 2^(3^4)
08:44:58 <lambdabot>   2417851639229258349412352
08:45:04 <Twey> Oh, of course it is
08:45:10 <Twey> Heh
08:45:16 <Twey> > (2^3)^4
08:45:18 <lambdabot>   4096
08:45:25 <Twey> There we go
08:45:43 <djahandarie> I happen to have a bad memory stick in my computer too
08:45:46 <muneson> Dear all good people, has anyone had troubles with readline in ghci 6.10.4 on Ubuntu?
08:48:18 <muneson> (troubles like: Home/End/Insert/Delete/Up/Down/Left/Right keys won't work)
08:49:18 <Jafet> Presumably it's in emacs-mode
08:50:12 <muneson> well, Ctrl+U and friends work as in shell, but not the others. How could I tell?
08:50:48 <Jafet> You can configure your readline library, I expect
08:52:30 <muneson> ok, i'll have to keep digging i guess
08:53:24 <Jafet> .oO( M-x run-haskell )
08:55:04 <Eduard_Munteanu> Hi.
08:59:17 <burp> @hoogle getArgs
08:59:18 <lambdabot> System.Environment getArgs :: IO [String]
08:59:41 <burp> wasn't this in System.IO before 6.12?
09:00:17 <muneson> @burp : no, i think not
09:00:18 <lambdabot> Maybe you meant: bug url
09:00:21 <burp> ok
09:06:42 <ski> > (exp (exp (-1)) **) `iterate` 1
09:06:44 <lambdabot>   [1.0,1.444667861009766,1.7014206956610736,1.8699612238030825,1.989573491776...
09:06:46 <joe1> > :t zip
09:06:47 <lambdabot>   <no location info>: parse error on input `:'
09:06:52 <joe1> :t zip
09:06:54 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
09:07:00 <Eduard_Munteanu> Are 'do' and '<-' defined as part of Prelude?
09:07:05 <koeien37> no
09:07:08 <koeien37> they are keywords
09:07:24 <Eduard_Munteanu> koeien37, hm, are there equivalent code snippets for any of them?
09:07:32 <koeien37> they get desuraged in terms of >>= (and fail), those are in the Prelude
09:07:50 <koeien37> yes, do-notation is not more or less powerful than using >>=
09:08:38 <koeien37> AFAIK these (>>=) and fail that are desuraged refer to the Prelude, even if you hid it by importing it qualified. There is an option NoImplicitPrelude that turns that off
09:08:45 <aavogt> @undo do (x:y:_) <- [1,2,3,4]; return (x+y)
09:08:46 <lambdabot> [1, 2, 3, 4] >>= \ a -> case a of { (x : y : _) -> return (x + y); _ -> fail ""}
09:09:03 <dolio> There's an extension that disables that.
09:09:04 <Eduard_Munteanu> koeien37, how would you do f = do x <- something; use1 x; use2 x, in terms of >>=
09:09:08 <Eduard_Munteanu> ?
09:09:16 <aavogt> it is cases where you do invoke fail that do notation is very helpful
09:09:20 <Eduard_Munteanu> koeien37, I mean, how would you retain a value otherwise?
09:09:25 <ski>   [x+y | x:y:_ <- [1,2,3,4]]
09:09:28 <koeien37> ask lambdabot :) but in this case  something >>= (\x -> use1 x >> use2 x)
09:09:48 <ski> (aavogt : .. fyi, the brackets around the pattern are not necessary)
09:09:49 <joe1> is there a way that I can tell ghci to free its buffers?
09:10:01 <aavogt> ski: unfortunately that doesn't work for other Monads
09:10:04 <Eduard_Munteanu> koeien37, thanks. Though it looks cumbersome to do some stuff in terms of >>=
09:10:14 <joe1> I am analysing a huge dataset from the ghci command prompt and it slows down after the operation.
09:10:16 <koeien37> sometimes
09:10:17 <ski> aavogt : *nod* (but it should :)
09:10:43 <ski> Eduard_Munteanu : you can actually write like
09:10:46 <koeien37> Eduard_Munteanu: for larger blocks, it's often more convenient to use do. For smaller blocks, >>= is fine
09:10:48 <joe1> I presumed that it could be because ghci is not releasing its memory allocation after the operation
09:11:05 <koeien37> someting >>= \x ->   \n   use1 x >>= \y ->   \n  ...
09:11:13 <ski>   something >>= \x ->
09:11:14 <koeien37> programming with "hanging lambda"
09:11:16 <ski>   use1 x    >>
09:11:17 <ski>   use2 x
09:11:17 <aavogt> it's a redundancy in having both do and comprehensions
09:11:57 <Eduard_Munteanu> koeien37, ski, oh, so you use a lambda expression to bring the binded value within scope. And then you use >>.
09:12:01 <Eduard_Munteanu> Nice.
09:12:05 <koeien37> yep
09:12:20 <ski> well, with `do', if you omit `<-' it calls `(>>)', but with list comprehensions, it calls (basically) `guard' (and `(>>)')
09:12:26 <koeien37> but do notation also desugars using fail
09:12:36 * Eduard_Munteanu advocates removing do-notation just like everybody else now :P
09:12:43 <koeien37> no
09:12:46 <koeien37> I like it
09:12:55 <koeien37> but list comprehensions should become MonadZero-comprehensions
09:13:08 <aavogt> > [ () | _ <- "hai", _ <- [1,2], x <- [1,2]]
09:13:09 <lambdabot>   [(),(),(),(),(),(),(),(),(),(),(),()]
09:13:55 <aavogt> > do "hai"; [1,2]; [1,2]; return ()
09:13:55 <dolio> That one doesn't need MonadZero.
09:13:56 <lambdabot>   [(),(),(),(),(),(),(),(),(),(),(),()]
09:14:05 <koeien37> no, but you very quickly need it
09:14:40 <aavogt> > [ () | "hai", [1,2], [1,2]]
09:14:42 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
09:14:42 <lambdabot>         against inferred type ...
09:14:55 <koeien37> those would be guards
09:16:22 <Eduard_Munteanu> koeien37, you said something like I can't prohibit Prelude from loading?
09:16:36 * hackagebot upload: HaXml 1.20.1 - Utilities for manipulating XML documents (MalcolmWallace)
09:17:13 <Eduard_Munteanu> Because I'd like to redefine some things from Prelude.
09:17:44 <dolio> Well, none of the --supported-languages looks promising, but I know there's some way to make GHC desugar do notation to non-prelude functions, if it doesn't by default.
09:18:28 <Dashkal> I thought you could explicitly import prelude and hide some symbols.  At least I've seen that in the odd source file.
09:18:51 <Eduard_Munteanu> What if you do import Prelude as Prelude?
09:19:09 <Dashkal> The way I saw it was: "import Prelude hiding (foo, bar)"
09:19:53 <Eduard_Munteanu> Hm, I thought that if you did 'import x as y', you'd have to refer to all stuff from that module as y.function for example.
09:20:13 <dolio> Only if you import qualified.
09:20:29 <Dashkal> I've never seen prelude used in import qualified.  Would that work?  Even if it did that sounds like it would make coding very very tedious.
09:20:48 <dolio> Yes, you can import it qualified.
09:21:03 <Eduard_Munteanu> Dashkal, of course not for actual work, but for redefining things from Prelude for pedagogical/self-teaching purposes.
09:21:09 <Jafet> You could import just the symbols you need.
09:21:27 <Jafet> If you're a control freak, or have OCD, or something
09:21:35 <Eduard_Munteanu> Heh.
09:21:38 <dolio> If you want to prevent the prelude from being loaded entirely, you can use the NoImplicitPrelude extension.
09:29:38 <Eduard_Munteanu> :t writeCharBuf
09:29:39 <lambdabot> Not in scope: `writeCharBuf'
09:30:01 <Eduard_Munteanu> Is this a keyword or language function? ^
09:30:13 <ksf> :t hPutBuf -- ?
09:30:14 <lambdabot> Not in scope: `hPutBuf'
09:30:19 <Eduard_Munteanu> I'm reading the definition of putStrLn to understand IO
09:30:23 <ksf> uh well, it's there.
09:30:37 <Dashkal> Try :t in ghci and see if that works
09:30:40 <ksf> that's implementation-dependent.
09:30:44 <Eduard_Munteanu> Dashkal, it doesn't.
09:30:57 <Eduard_Munteanu> ksf, oh so it's like a keyword.
09:31:03 <ksf> ...most likely defined somewhere in GHC.Prim or such
09:31:13 <Eduard_Munteanu> !hoogle writeCharBuf
09:31:15 <ksf> nope, not a keyword, but a more or less primitive function.
09:31:25 <ksf> the real primitives end with #, at least in ghc
09:31:44 <Eduard_Munteanu> ksf, hoogle doesn't find it (in browser, not here, seems not to work here)
09:32:24 <dolio> In jhc they have lots of underscores.
09:33:16 <ksf> Eduard_Munteanu, http://hackage.haskell.org/package/base-4.2.0.0 , GHC.IO.Handle.Types
09:34:15 <ksf> or, actually, http://hackage.haskell.org/package/base-4.2.0.0
09:34:19 <ksf> duh.
09:34:20 <Eduard_Munteanu> ksf, hm, it seems I can't browse it. Perhaps it's not indexed by Hoogle?
09:34:25 <ksf> http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.2.0.0/GHC-IO-Buffer.html#v%3AwriteCharBuf
09:35:01 <ksf> writeCharBufPtr seems to be the bottom layer, implemented with pokeElemOff
09:35:40 <Eduard_Munteanu> pokeElemOff p ix (fromIntegral (c' `div` 0x400 + 0xd800))
09:35:47 <Eduard_Munteanu> Wow, wow, so BASIC-ish :)
09:35:49 <Eduard_Munteanu> :P
09:35:51 <ksf> ...which is documented in Foreign.Ptr or somewhere close.
09:36:07 <Eduard_Munteanu> I get nasty flashbacks.
09:36:12 <ksf> yep, haskell is quite a system langugage.
09:36:38 <ksf> it certainly won't stop you from mmaping a file and messing up your pointers.
09:37:07 <jmcarthur> not very convenient sometimes since the function names for such low level operations are quite verbose and you usually have to use several at a time
09:37:25 <ksf> that's why abstraction is free.
09:37:27 <jmcarthur> but it does provide you with some nicer abstractions than you get in C
09:38:17 <ksf> ghc ends up inlining virtually all smallish functions
09:40:45 <dolio> Not always free enough, unfortunately.
09:41:37 <Eduard_Munteanu> Does anyone understand this? http://haskell.org/ghc/docs/latest/html/libraries/base-4.2.0.0/src/Foreign-Storable.html#poke
09:41:44 <Eduard_Munteanu> Those definitions look circular to me.
09:41:54 <Eduard_Munteanu> poke, pokeElemOff and pokeByteOff.
09:42:30 <dolio> In the class?
09:42:43 <jmcarthur> those are defaults
09:42:48 <Eduard_Munteanu> dolio, no.
09:42:51 <jmcarthur> you are supposed to override some or all of them
09:42:54 <Eduard_Munteanu> dolio, the global ones.
09:43:20 <dolio> I don't think there are any global ones.
09:43:34 <Eduard_Munteanu> dolio, oh, right, I mean the ones in Storable.
09:43:44 <jmcarthur> in the class?
09:43:44 <ksf> is the shootout going to run 6.12, soon?
09:43:51 <dolio> Then, yes, they're circular so that you only have to implement one of them.
09:43:53 <jmcarthur> those are default definitions and are meant to be overloaded in the instances
09:44:09 <jmcarthur> if you define one you define them all
09:44:42 <ksf> I didn't submit my fasta entry because the guys fucked up account registration at alioth, and I'm kinda hesitating to try again now that 6.12 is out.
09:45:13 <Eduard_Munteanu> I see, thanks.
09:45:17 <ksf> ...especially because the current code has some nasty edges that are possibly less ugly with 6.12
09:45:22 <mreh> > map (flip evalRand =<< newStdGen) . replicate 2 . random
09:45:23 <lambdabot>   Couldn't match expected type `Control.Monad.Random.Rand a a1 -> a'
09:45:23 <lambdabot>         ...
09:45:32 <Eduard_Munteanu> Will have to look em up manually, hoogle returns only the Foreign.Storable definitions.
09:45:40 <mreh> :t evalRand
09:45:41 <lambdabot> forall g a. (RandomGen g) => Rand g a -> g -> a
09:46:42 <mreh> :t evalRand =<< newStdGen
09:46:43 <lambdabot>     Couldn't match expected type `g -> Rand g b'
09:46:43 <lambdabot>            against inferred type `IO StdGen'
09:46:43 <lambdabot>     In the second argument of `(=<<)', namely `newStdGen'
09:47:40 <Eduard_Munteanu> :t flip (=<<)
09:47:41 <lambdabot> forall a (m :: * -> *) b. (Monad m) => m a -> (a -> m b) -> m b
09:47:58 <mreh> :t (>>=)
09:47:59 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
09:48:09 <mreh> i like (=<<)
09:48:32 <ksf> Eduard_Munteanu, the best way to learn about low-level haskell might be to look at ghc core
09:48:39 <mreh> :t flip evalRand =<< newStdGen
09:48:40 <lambdabot>     Couldn't match expected type `Rand a b -> a'
09:48:40 <lambdabot>            against inferred type `IO StdGen'
09:48:40 <lambdabot>     In the second argument of `(=<<)', namely `newStdGen'
09:48:47 <Eduard_Munteanu> mreh, you should flip =<< not evalRand if that's what you're looking for.
09:49:07 <mreh> Eduard_Munteanu: I'm trying to do too many monads
09:49:16 <Eduard_Munteanu> :t evalRand $ flip =<< newStdGen
09:49:17 <lambdabot>     Couldn't match expected type `Rand g a'
09:49:17 <lambdabot>            against inferred type `a1 -> f b'
09:49:17 <lambdabot>     In the first argument of `(=<<)', namely `flip'
09:49:43 <mreh> I want to map an "evalRand" with a new standard gen to every (Random g a)
09:49:46 <mreh> in a list
09:49:47 <Eduard_Munteanu> :t evalRand (flip =<<) newStdGen
09:49:48 <lambdabot>     Couldn't match expected type `Rand g a'
09:49:48 <lambdabot>            against inferred type `(a1 -> f (a1 -> b)) -> a1 -> f b'
09:49:48 <lambdabot>     In the first argument of `evalRand', namely `(flip =<<)'
09:50:14 <mreh> those two statements are identical
09:50:19 <Eduard_Munteanu> ksf, hm, you mean GHC.Core or should I also download GHC's source code?
09:50:36 <mreh> or not, anyway
09:50:43 <ksf> cabal install ghc-core
09:50:52 <ksf> then ghc-core file.hs
09:51:00 <ksf> ...and maybe pass -O2 or something
09:51:02 <mreh> is it crazy to encapsulate one monad inside another?
09:51:04 <theclaw> is it possible to put let expression with two or more variables in a single line?
09:51:09 <mreh> like IO (Rand g a)?
09:51:13 <jmcarthur> not at all
09:51:15 <ksf> mreh, have a look at monad transformers
09:51:31 <jmcarthur> well, there is no IOT, though
09:51:44 <ksf> STM (STM a) is a _very_ useful idiom.
09:51:48 <Eduard_Munteanu> theclaw, like (a, b) <- (getStuff1, getStuff2) ?
09:51:53 <ksf> pass a reply channel over a channel.
09:52:10 <theclaw> Eduard_Munteanu: no, like "let a = 3; b = 4 in return a+b"
09:52:12 <c_wraith> If you just want to return one monadic value from another function, that's quite common.  Look how many functions there are like IO (Maybe a)
09:52:21 <ksf> or another typical construct, join . atomically
09:52:25 <jmcarthur> there are things a like and dislike about transformers
09:52:27 <mreh> jmcarthur: I need to do some randomness in IO, IO (Rand g a) would suffice wouldn't it?
09:52:35 <ksf> ...return an IO action to execute from an STM action.
09:52:39 <c_wraith> mreh: IO implements MonadRandom
09:52:43 <jmcarthur> mreh: isn't IO an instance of MonadRandom already?
09:53:07 <Eduard_Munteanu> ksf, nice, ghc-core seems fine.
09:53:42 <jmcarthur> i really like the Composing Monads paper
09:53:59 <Cale> > let a = 3; b = 4 in a+b
09:54:00 <lambdabot>   7
09:54:07 <Eduard_Munteanu> Hm, is it possible to break monads using stuff like f :: m a -> a ?
09:54:16 <koeien37> that function is in general not possible
09:54:18 <ksf> :t runState
09:54:19 <lambdabot> forall s a. State s a -> s -> (a, s)
09:54:20 <Cale> Eduard_Munteanu: Most monads have such a function
09:54:22 <koeien37> for some monads, it is
09:54:23 <jmcarthur> Eduard_Munteanu: looks like a typical run functions to me
09:54:29 <jmcarthur> *function
09:54:40 <Cale> Eduard_Munteanu: But it's not a *requirement* of being a monad.
09:54:42 <ksf> Eduard_Munteanu, it's not part of monads, but many things that give raise to monads have it, anyway.
09:54:49 <Eduard_Munteanu> So the world ends if I do using that function, f getArgs ? :)
09:54:56 <jmcarthur> Eduard_Munteanu: i wouldn't call it "breaking" a monad unless it's some sort of abstraction leak, like for IO
09:55:00 <koeien37> Eduard_Munteanu: correct
09:55:02 <Cale> Eduard_Munteanu: Oh, you can't write a polymorphic function of that type
09:55:11 <koeien37> but there are no functions of that type
09:55:15 <jmcarthur> Eduard_Munteanu: unsafePerformIO is called unsafe for a reason
09:55:16 <koeien37> except for undefined
09:55:24 <Vitka_> > [0..]
09:55:25 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
09:55:29 <Eduard_Munteanu> But can I define it for IO?
09:55:38 <koeien37> No[1].
09:55:40 <jmcarthur> Eduard_Munteanu: it's already defined
09:55:41 <koeien37> [1] it is not a good idea
09:55:44 <Eduard_Munteanu> Or is there some lang feature that won't let me end the world?
09:55:51 <Eduard_Munteanu> jmcarthur, oh?
09:55:55 <jmcarthur> Eduard_Munteanu: unsafePerformIO
09:55:55 <Cale> Eduard_Munteanu: You can't.
09:55:56 <koeien37> unsafePerformIO
09:55:59 <koeien37> don't use it
09:56:03 <jmcarthur> Eduard_Munteanu: you are not encouraged to use it
09:56:12 <Eduard_Munteanu> Yeah, this is only theoretical.
09:56:15 <theclaw> Cale: I overlooked your reply; thanks
09:56:15 <c_wraith> I think you should use it.
09:56:26 <c_wraith> And then you'll understand why you shouldn't use it.
09:56:31 <c_wraith> hint: it doesn't work like you think.
09:56:34 <mreh> so if IO is an instance of MonadRandom, I can just call a function (Rand g a) from inside IO, and not worry about evaluating it explicitly?
09:56:39 <jmcarthur> Eduard_Munteanu: using only "safe" functions, you cannot define unsafePerformIO yourself, afaik
09:56:55 <Eduard_Munteanu> :t unsafePerformIO
09:56:56 <jmcarthur> mreh: a function (MonadRandom m => m a)
09:56:56 <lambdabot> Not in scope: `unsafePerformIO'
09:57:00 <Cale> unsafePerformIO should be handled with the same sort of care that you'd take in modifying your compiler.
09:57:14 <jmcarthur> mreh: such as getRandom
09:57:24 <simard> I'm trying to install Cabal, however it needs directory, and directory needs Cabal..... what am I to do ?
09:57:33 <koeien37> well, there is unsafeCoerce, but it's also unsafe :P
09:57:47 <koeien37> and it won't solve your problem anyway
09:57:53 <c_wraith> unsafeCoerce is even wronger than unsafePerformIO :)
09:57:55 <simard> (I can't use the repository, I'm doing a manual installation with runghc Setup.hs configure --prefix ...)
09:57:57 <Cale> It's possible to write unsafeCoerce with unsafePerformIO + IORefs
09:58:17 <koeien37> yes, your program can core dump because of unsafePerformIO
09:58:21 <jmcarthur> c_wraith: in the sense that Cale just said, the two are equally "wrong" ;)
09:58:22 <Cale> (it's even a one-liner)
09:58:39 <ksf> simard, cabal should come with ghc, which bootstraps it.
09:58:56 <c_wraith> jmcarthur: I just mean in the sense of getting an a out of an IO a
09:59:01 <koeien37> i haven't found the need for unsafeCoerce up until now
09:59:04 <jmcarthur> not only is it possible, i'm pretty sure unsafCoerce *is* written in terms of unsafePerformIO
09:59:06 <ksf> ...newer versions, that is, since 6.10 iirc.
09:59:25 <jmcarthur> c_wraith: ah
09:59:27 <Cale> (well, close to a one-liner anyway -- the identifiers involved are kind of long :P)
09:59:28 <Eduard_Munteanu> BTW, does Haskell optimize programs collapsing lists to vectors if possible?
09:59:29 <c_wraith> unsafeCoerce is the sort of thing that's only useful in *very* rare circumstances.
09:59:45 <ksf> Eduard_Munteanu, no.
09:59:45 <jmcarthur> Eduard_Munteanu: no
09:59:48 <Eduard_Munteanu> :(
09:59:56 <ksf> ...it does do deforestation, though.
10:00:07 <jmcarthur> Eduard_Munteanu: that would be a compiler that's probably a bit too smart
10:00:11 <c_wraith> GHC will deforest and fuse, though.  Which can sometimes eliminate lists entirely.
10:00:30 <vpetro> hi
10:00:32 <jmcarthur> Eduard_Munteanu: we have deforestation and some really nice array types though, such as the uvector package
10:00:50 <Eduard_Munteanu> Can I use the list "API" for vectors?
10:00:52 <ksf> lists aren't a good choice as a data structure if you do other stuff than head and tail and need speed
10:00:58 <Eduard_Munteanu> (I haven't looked at all into the latter)
10:01:01 <vpetro> can someone point me in the right direction? i am looking to find out how lazy eval is implemented in haskell.
10:01:16 <ksf> Eduard_Munteanu, what do you want to do?
10:01:20 <Cale> Eduard_Munteanu: There's Data.Foldable, which is a sizeable chunk of the list api.
10:01:21 <jmcarthur> Eduard_Munteanu: there are also stream fusion versions of the list functions on hackage. forget the package name as i don't use it much
10:01:22 <Eduard_Munteanu> vpetro, try searching for "thunks" on the wiki or google relating to haskell.
10:01:32 <ksf> that is, what operations do you need, and how often do you need to do each in relation?
10:01:47 <jmcarthur> Eduard_Munteanu: if it doesn't exist already, you could define a type class for that
10:01:50 <Cale> vpetro: What aspects of it are you more interested in?
10:01:57 <Eduard_Munteanu> ksf, nothing in particular, it's just that I'm a C programmer mostly and I don't feel like using lists always :)
10:02:08 <ksf> oh.
10:02:11 <ksf> just a sec
10:02:16 <koeien37> I felt the other way around
10:02:22 <koeien37> resizing arrays is horrible
10:02:24 <jmcarthur> Eduard_Munteanu: lists are really what you want most of the time, but there are times when an array is definitely a better idea
10:02:36 <vpetro> Cale: i would like to know more about the basic implementation.. ie how does it know what should be evaled and what shouldn't be
10:02:49 <jmcarthur> Eduard_Munteanu: it's actually not very common that you need constant time access to everything
10:02:50 <ksf> Eduard_Munteanu, read this: http://www.soi.city.ac.uk/~ross/papers/FingerTree.html
10:03:01 <Cale> vpetro: If you're just interested in understanding the performance behaviour of programs, I'd say understanding the real implementation is probably going too far. You can understand a toy implementation and it gets across most of the idea.
10:03:03 <jmcarthur> yeah, finger trees are awesome
10:03:07 <Eduard_Munteanu> jmcarthur, matrices come to mind...
10:03:27 <Cale> vpetro: But the central idea of the real-world implementation in GHC is that values are represented as pointers to code.
10:03:28 <ksf> ...which doesn't only introduce a really, really sweet data structure, but also sheds much light on how we like to do data structures
10:03:33 <Eduard_Munteanu> Or at least, there are almost nil algos that use a functional approach.
10:03:45 <ksf> Eduard_Munteanu, we _do_ have packages for that.
10:03:55 <koeien37> Eduard_Munteanu: that is true. Algorithms are often described imperatively
10:04:08 <Eduard_Munteanu> ksf, I've seen stuff using FFI to GSL, but it's not really functional :)
10:04:14 <vpetro> Cale: ah, that is interesting
10:04:26 <Cale> vpetro: The first time that code is executed, it does whatever is necessary to evaluate the value to the point of determining the top-level constructor in it, then rewrites the pointer to point at a shorter piece of code which simply returns the value immediately, before returning the result.
10:04:53 <ksf> http://hackage.haskell.org/package/vector-space comes to mind, but I'm not sure how much conal optimized it for speed
10:05:04 <jmcarthur> not much i think
10:05:09 <Cale> vpetro: This ensures that the value of any variable is not recomputed as long as that variable remains in scope.
10:05:19 <jmcarthur> there's a link i'm looking for, can't remember the name
10:05:34 <ksf> Eduard_Munteanu, but this: http://www.haskell.org/haskellwiki/GPipe might solve all your matrix problems.
10:05:38 <Cale> vpetro: Another possibility is to use a pointer to either code or data, together with a boolean flag, but this avoids the flag.
10:05:52 <ksf> (dense matrix, that is)
10:06:02 <Eduard_Munteanu> ksf, yeah, dense.
10:06:09 <ksf> and then there's dph
10:06:16 <vpetro> Cale: is the something that describes the specific data structures for this mechaism?
10:06:16 <Cale> vpetro: Evaluation, after enough desugaring, is entirely driven forward by case expressions.
10:06:25 <ksf> http://www.haskell.org/haskellwiki/GHC/Data_Parallel_Haskell
10:06:29 <Cale> vpetro: Well, there's a nice paper about it...
10:06:37 <ksf> still a bit preliminary, but apperently working just fine.
10:06:38 <Cale> http://citeseer.ist.psu.edu/peytonjones92implementing.html
10:07:04 <vpetro> Cale: thank you.
10:07:12 <Cale> GHC actually works a little differently than that paper describes -- in fact, the 'tagless' part is no longer true.
10:08:15 <Cale> GHC uses a bit of pointer tagging -- storing extra information in the low order 2 or 3 bits of the code pointer for evaluated values.
10:08:24 <Eduard_Munteanu> ksf, I tried implementing Gaussian elimination using a list-of-lists approach... it was hell.
10:08:41 <koeien37> I wouldn't do that
10:08:54 <koeien37> ST + arrays
10:08:57 <c_wraith> Eduard_Munteanu: matrices have length rules that make lists not a good choice.
10:09:08 <Cale> This means that if you have a value of a type with few constructors (like Bool), it can actually pack the evaluated boolean value into the low-order bits of the pointer itself, and avoid dereferencing it altogether.
10:09:10 <Eduard_Munteanu> I see.
10:09:28 <mreh> I've got that interesting problem again, evaluating two infinite and random lists :: Rand g [a] in sequence hangs indefinitely
10:09:29 <Eduard_Munteanu> Well, ST is nice because it's in place.
10:09:50 <mreh> did we establish a workaround?
10:09:53 <c_wraith> mreh: IO is strict.
10:10:03 <ksf> if you have dimenionality in your types, you can even have the compiler figure out the best way to multiply multiple matrixes.
10:10:06 <Eduard_Munteanu> Are there any optimizations that avoid copying, thus making some code in-place?
10:10:11 <c_wraith> mreh: that means it will attempt to calculate the entire infinite list before moving on
10:10:11 <vpetro> Cale: alright. thank you. I will have a look at the paper and come back if i have more questions.
10:10:17 <Cale> mreh: sequence on an infinite list of actions in the Rand monad creates a data dependency chain which is infinite
10:10:46 <mreh> it's trying to return the generator which is at the end of a infinitely long thunk, is my understanding of the issue
10:10:48 <Cale> vpetro: But you should certainly understand what lazy evaluation is separately from its implementation.
10:11:03 <Eduard_Munteanu> Because it seems to me the functional style can be optimized to avoid copying.
10:11:07 <Cale> vpetro: As in, from the point of view of simply transforming expressions into other expressions.
10:11:27 <jmcarthur> Eduard_Munteanu: a couple of our libraries on hackage have array fusion or similar optimizations
10:11:31 <ksf> Eduard_Munteanu, you can play around with vacuum
10:11:35 <c_wraith> mreh: right.  don't create infinite random lists in a strict monad.
10:11:45 <Eduard_Munteanu> ksf, is that some sort of garbage collector?
10:11:49 <ksf> ...which gives you a nice graph of how stuff is laid out in memory
10:12:04 <Eduard_Munteanu> I meant something like "if the compiler can figure out dependencies at compile-time, maybe it can avoid copying"
10:12:05 <c_wraith> mreh: or in a monad, like MonadRandom, that puts data dependencies between every evaluation
10:12:06 <mreh> c_wraith: boo, I want to!
10:12:10 * Cale really wishes that people wouldn't use the word 'thunk' in a normal programming context.
10:12:26 <Cale> Thunks are so low-level-implementation-detaily.
10:12:28 <ksf> the compiler knows all dependencies.
10:12:32 <Eduard_Munteanu> Cale, why? I picked that up from the wiki, regarding laziness.
10:12:34 <ksf> it's the data/control flow.
10:12:44 <Eduard_Munteanu> Cale, oh.
10:12:46 <Zao> Cale: Everyone knows that a thunk is a generated function stub that forwards a call to a member function.
10:12:50 <Cale> I prefer to use the term 'expression' or 'unevaluated expression'
10:12:52 <Zao> :P
10:12:54 <jmcarthur> Eduard_Munteanu: http://hackage.haskell.org/package/uvector and http://hackage.haskell.org/package/accelerate are nice. i've only used uvector
10:13:02 <c_wraith> mreh:  If you want an infinite random list, don't use MonadRandom.
10:13:09 <mreh> Cale: blame the haskel wiki
10:13:12 <Cale> thunks are the implementation of expressions
10:13:31 <Cale> (at runtime)
10:13:44 <Eduard_Munteanu> Yay, unboxed arrays.
10:14:00 <c_wraith> mreh: also be aware that if you want *two* infinite random lists, you'll need a different RandGen to start each.
10:14:06 <aavogt> and currently the only implementation, Cale?
10:14:28 <Cale> aavogt: Well, I treat "thunk" as the generic term for any implementation mechanism for that.
10:14:57 <mreh> c_wraith: that seems to be the case, mapM evalRandIO doesn't work like that
10:15:07 <Cale> So, however you represent as-yet-unevaluated expressions at runtime, those are your thunks.
10:15:15 <Eduard_Munteanu> Guys, I can't really tell how the House guys managed to write it in Haskell.
10:15:29 <Cale> Eduard_Munteanu: GHC is most of an OS already.
10:15:37 <Eduard_Munteanu> Not being an "asm preprocessor" like C, Haskell really makes it strange to tell things.
10:15:44 <Eduard_Munteanu> Cale, hm, what do you mean?
10:16:51 <Eduard_Munteanu> Cale, you mean it's more like the JVM to Java code?
10:16:52 <Cale> Well, it's got so much useful fancy machinery in it -- a scheduler, IO system, etc.
10:17:05 <Eduard_Munteanu> I see.
10:17:44 <ben0x539> Is the scheduler not implemented on top of OS mechanisms?
10:18:05 <c_wraith> :t unfoldr (Just . random) -- mreh
10:18:06 <lambdabot> forall a b. (Random a, RandomGen b) => b -> [a]
10:18:25 <Guest523> What does it mean when the compiler is saying "Expected kind '*', but 'Tree' has kind '* -> *'
10:18:29 <Guest523> what is *?
10:18:37 <ben0x539> A kind.
10:18:44 <c_wraith> * is the kind of concrete types
10:18:49 <ben0x539> http://hackage.haskell.org/trac/ghc/wiki/IntermediateTypes
10:18:52 <mreh> Guest523: a kind is the type of types!
10:18:54 <Cale> Guest523: A kind is the type of something at the type level.
10:18:56 <ben0x539> has a diagram
10:18:57 <koeien37> Tree is not a type, Tree a is a type
10:19:09 <koeien37> like [], it is not a type, it is a type constructor
10:19:25 <Cale> ben0x539: In part, in that it schedules N Haskell threads to run on M OS threads.
10:19:27 <koeien37> it is of kind * -> *, so it takes one type, and returns one. For example [] Integer
10:19:32 <Eduard_Munteanu> $ echo 'main = print "Hi"' > test.hs; ghc --make test.hs 2>/dev/null; du -sh test
10:19:35 <Eduard_Munteanu> 608K    test
10:19:53 <Eduard_Munteanu> Any hopes to ever use it in an embedded-like environment?
10:19:56 <ben0x539> Cale: Does it not all come down to select() at some point?
10:20:25 <c_wraith> ben0x539: only IO.
10:20:34 <Cale> ben0x539: Well, select is presently used for blocking IO
10:20:35 <Eduard_Munteanu> A whole OpenWRT fits in 1.8M :)
10:20:52 <c_wraith> ben0x539: also, bos and tibbe are rewriting the IO manager to not use select. :)
10:20:54 <Cale> ben0x539: (though that's probably about to change :)
10:21:01 <ben0x539> Right
10:21:32 <ksf> ben0x539, ghc both uses the os scheduler to do multicore, but multiplexes its own managed coroutines on them.
10:21:36 <Cale> http://ogi.altocumulus.org/~hallgren/ICFP2005/
10:22:00 <ksf> and managed coroutines are basically preemptive multitasking, if you're the compiler that compiles the code.
10:22:38 <koeien37> House could only run Haskell programs, and compiled those first, right?
10:22:54 <koeien37> oh I missed the fact that Cale's link was related, I should read
10:23:22 <ksf> doing a posix interface in haskell might actually be fun.
10:23:37 <ksf> ...just a couple of ffi functions, callable from c.
10:23:59 <Eduard_Munteanu> Why isn't the runtime split into some sort of lib?
10:24:07 <Eduard_Munteanu> I presume that's why the executables are so big.
10:24:12 <ben0x539> It is now
10:24:15 <koeien37> you mean, as a dynamic library?
10:24:19 <Eduard_Munteanu> koeien37, yes.
10:24:19 <ksf> we got dynamic linking on linu
10:24:20 <c_wraith> Eduard_Munteanu: in 6.12, it will be dynamically loaded
10:24:21 <ksf> x
10:24:21 <Eduard_Munteanu> Like ld.so
10:24:28 <Eduard_Munteanu> c_wraith, I see.
10:24:33 <Cale> http://web.cecs.pdx.edu/~rebekah/papers/plos07.pdf -- another related paper
10:24:46 <ben0x539> That has the disadvantage that you cannot distribute haskell binaries without making the other guy install ghc, I suppose
10:24:52 <c_wraith> You could even say "in 6.12, it *is* dynamically loaded".  But 6.12 isn't end-user ready yet.
10:25:08 <ksf> so far, stuff worked out fine for me.
10:25:14 <c_wraith> ben0x539: I don't think dynamic loading is the default in 6.12
10:25:18 <koeien37> ksf: good. Thanks for testing then :)
10:25:25 <ben0x539> c_wraith: It is not, I got confused.
10:25:38 <ksf> completely painless, if you compare it with the 6.8->6.10 move
10:25:48 <Eduard_Munteanu> Yeah, I can't really wrap my head around the 608KiB of the print program :)
10:25:56 <Cale> Besides, the binaries aren't all *that* large.
10:25:57 <koeien37> I vaguely recall 6.6->6.8
10:26:04 <Cale> They're not noticeably large.
10:26:15 <Guest523> thanks for benox539, c_wraith, mreh, Cale, and especially koeien37 who made me understand I need to add 'a' for Tree a.
10:26:20 <koeien37> Cale: well, not that I *really* care, but for some embedded applications they might be on the heavy side, I suppose?
10:26:26 <ksf> but what's _really_ annoying is that stuff now doesn't compile "just" twice, but rather four times
10:26:28 <Eduard_Munteanu> Cale, I'd really like to see Haskell being usable on embedded systems.
10:26:37 <ben0x539> Does 6.12 have gtk2hs yet? :)
10:26:46 <koeien37> Guest523: you can ask ghci for the kind of your type constructors, too, with ":k"
10:27:00 <Cale> Haskell is better as a metalanguage for embedded systems I think.
10:27:03 <Eduard_Munteanu> ben0x539, builtin? On 6.10 I had to cabal install / emerge it
10:27:05 <ksf> ghc should really be able to typecheck once, and generate all kind of profiled, static and dynamic stuff from that.
10:27:45 <ben0x539> Eduard_Munteanu: No, I meant whether it compiles on 6.12 yet.
10:28:02 <Eduard_Munteanu> If you make Haskell eager, would it break programs? I imagine that eagerness will improve size noticeably.
10:28:05 <Cale> At least until embedded systems become sufficiently powerful...
10:28:06 <Guest523> I must say these things probably get easier later on but it does not really help a newbie at all to talk about types with kinds, then differentiate through capitalizing the letter, and finally talk about types differently at types level and when used.
10:28:14 <ksf> eagerness breaks a lot
10:28:14 <koeien37> Eduard_Munteanu: it would break lots of stuff
10:28:16 <Cale> Eduard_Munteanu: Most programs.
10:28:21 <Guest523> but I guess I'll learn to love this later on :]
10:28:33 <Cale> and it would *kill* performance on a lot of others
10:28:41 <RaceCondition> I think I just figured out the working principle of Haskell's IO monad system 5 years after my Haskell course in the uni
10:28:44 <koeien37> Guest523: you're lucky that Haskells type system is untyped ;)
10:28:44 <Eduard_Munteanu> Oh, yes, [1..] and such stuff will get evaled.
10:29:00 <ksf> kinds are what the type of a type is kalled. the type of a kind is called a sort, and the type of a sort a class.
10:29:04 <ksf> it's a hierarchy.
10:29:27 <Cale> Eduard_Munteanu: Strict programming basically forces you to turn your whole program inside out in order to ensure that no more stuff is generated than needed.
10:29:27 <Eduard_Munteanu> ksf, can it be nested arbitrarily much?
10:29:27 <koeien37> laziness is both a virtue and a vice. Lots of programs become easily composible and elegant
10:29:39 <koeien37> but it can sometimes introduce space leaks
10:29:40 <ksf> koeien37, not for long, if my prayers are heeded.
10:29:53 <koeien37> ksf: you want full dependent types?
10:29:56 <ksf> Eduard_Munteanu, there's some langugaes that have an infinite tower, yes.
10:30:31 <Cale> Eduard_Munteanu: People get used to that inverted and not-very-composable style of programming, and that's I think a major reason why it's so hard for beginners who are well-versed in strict programming to write programs which perform sensibly.
10:30:46 <Traveler7> hey there, can I experiment with the pointfree plugin here?
10:30:51 <ksf> koeien37, http://hackage.haskell.org/trac/ghc/wiki/KindSystem
10:31:05 <Cale> Traveler7: Yes, though you could also send private messages to lambdabot
10:31:06 <koeien37> Traveler7: you can, but if you have lots of stuff, you can /msg lambdabot too
10:31:11 <ksf> koeien37, "Fun with Type Funcitons" has a good usecase for them.
10:31:26 <Traveler7> thanks
10:31:30 <Guest523> ksf, I guess this could be made even more confusing by clever english use. I get always doublecrossed to guess if 'a type' means 'a single type' or 'type of whatever'.
10:31:34 <ksf> basically, they're needed for closed type functions, which'd be really, really good to have.
10:31:36 <Eduard_Munteanu> Full dependent types might allow totality, AFAIR.
10:31:48 <Eduard_Munteanu> Though I'm not exactly sure _how_.
10:31:58 <koeien37> I don't want a total language
10:32:05 <Guest523> Then deciphering 'A type of A type of a kind which sort of is a sort of A sort" will be indefinitely beyond me.
10:32:12 <simard> I need ghc --make to take into account a -LLIBDIR flag during linking with ld, is there a way to do that directly on the ghc --make line ?
10:32:25 <Cale> RaceCondition: The idea that it really has much to do with monads is a red herring. The real innovation is representing I/O effects as values.
10:32:34 <pikhq> simard: ... ghc --make -LLIBDIR?
10:32:35 <Eduard_Munteanu> koeien37, why? You could include proofs along for stuff that can be written reasonably as total.
10:32:41 <simard> pikhq: meh
10:32:41 <ksf> ...I want a turing-complete language amended with a total type system which can be turned turing-complete with a switch.
10:32:45 <simard> gonna try that
10:32:46 <koeien37> Eduard_Munteanu: right. Which can be extremely combersome
10:32:50 <Eduard_Munteanu> ksf, I agree.
10:32:56 <Cale> RaceCondition: and then providing operations for combining those in some way to build up more complicated programs.
10:33:14 <koeien37> I would probably work with the totality checker switched off _all the time_
10:33:23 <Eduard_Munteanu> Basically, I think it's similar to monads as an issue.
10:33:40 <Eduard_Munteanu> You could encapsulate non-total code in some stuff.
10:33:54 <Eduard_Munteanu> And then you can have the totality checker always on.
10:33:59 <Eduard_Munteanu> I think it's called co-data.
10:34:01 <Cale> RaceCondition: It's just that it ends up being a monad, and we like that because it means we get to reuse libraries of code which are written to work with any monad.
10:34:02 <ksf> I _do_ know that I wouldn't be able to prove the totality of much more stuff than what coq's auto tactic can do.
10:34:37 <Eduard_Munteanu> ksf, Agda seems reasonable on some stuff. And the type system looks powerful
10:34:48 <koeien37> did you ever write a nontrivial Agda program?
10:34:53 <Eduard_Munteanu> koeien37, no :)
10:34:59 <koeien37> (I didn't, by the way. So feel free to berate me :)
10:35:01 <Cale> I'm unconvinced as of yet that pulling the same trick as IO with non-total functions is really workable.
10:35:04 <Eduard_Munteanu> But it seems a lovely concept :)
10:35:39 <ksf> I've spend some time with agda, and besides having a hard time because everyone writing tutorials seems to assume that I eat proofs for breakfast, compared to coq it felt like spoon-feeding the system.
10:35:55 <Eduard_Munteanu> This is just awesome: http://code.haskell.org/Agda/examples/Introduction/Basics.agda
10:35:59 <ksf> ...coq can get stuck, too, and it's not easy to get started to direct it, but it's at least not utterly stupid.
10:36:28 <Cale> The fact that every program can be reasonably decomposed as a thin candy coating of IO and a rich creamy centre of pure code is roughly the same idea as model-view-controller, and it's not that hard to see that it's possible to always do it.
10:36:29 <ksf> oh, and unicode syntax. I _hate_ unicode syntax.
10:36:31 <mental> has any big agda programs been written?
10:36:39 <koeien37> Eduard_Munteanu: I hope that those peano numerals are encoded as Integer
10:36:57 <Cale> With the total/partial distinction, it's not at all clear to me that it's a reasonable way to decompose programs.
10:37:25 <Eduard_Munteanu> koeien37, aren't Peano completely definable as Church numerals?
10:37:28 <ksf> We need type-level numerals for haskell.
10:37:46 <ksf> ...built-in, that is.
10:37:47 <Eduard_Munteanu> ksf, Church?
10:37:50 <Eduard_Munteanu> Oh.
10:37:53 <ksf> nope, readable.
10:38:02 <ben0x539> Can we not just have a generic way to lift the entire language to the type level?
10:38:08 <koeien37> I want ML functors first
10:38:16 <Cale> ben0x539: That's basically what dependent types are about.
10:38:18 <ben0x539> Otherwise, someone is going to start asking for numerals at the kind level
10:38:33 <ksf> although one could generate say N000 to N999 and then calculate base 1000, that'd work quite fine for readability.
10:39:00 <ksf> ben0x539, I think the better way is to go typelevel -> value level.
10:39:09 <ksf> ...as the latter is more expressive.
10:39:49 <ksf> proper kinds can be emulated with typeclasses and equality constraints, though.
10:40:27 <Cale> ksf: I don't really understand that comment. I don't really care about representing 'Integer' at runtime.
10:40:55 <ksf> moving code from the type level to the value level, automagically.
10:41:12 <Cale> ksf: But lifting values like 5 up to the type level seems more useful.
10:41:36 <ksf> ...but that won't work for runtime values.
10:41:37 <Eduard_Munteanu> Aren't GADTs a _bit_ like dependent types?
10:41:52 <ksf> yep
10:42:02 <Cale> Programming at the type level is (presently) awkward, so most things that you can reasonably write at the type level, you might as well just rewrite them at the value level anyway.
10:42:11 <ksf> there's a lot of cool stuff people do with depentent types that don't really need dependent types
10:42:32 <tommd> People say the same thing about static types.
10:42:47 <Eduard_Munteanu> I see some correspondence between higher-order logic and type lifting.
10:43:08 <Cale> There are things in between what we presently have and full dependent types which would be nice.
10:43:39 <Eduard_Munteanu> Gah, I really need to read Awodey's to get up to speed with this stuff.
10:44:22 <Cale> (how does Tim Sheard's Omega fit in?)
10:45:42 <Guest523> sorry to ask stupid things, but why am I bitten by compiler type checks for this simple code constructing all variations of balanced trees (#54 of 99 problems): http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15840#a15840
10:46:13 <Cale> Guest523: first of all, there are tabs in this code
10:47:02 <Cale> Guest523: You really ought to configure your text editor not to produce them, as it will cause you no shortage of pain in getting the indentation right and/or working with other people whose text editors treat tabs differently.
10:47:15 <Guest523> inferred type for first parameter of [a] while expected is Tree Char
10:47:39 <Eduard_Munteanu> Cale, you're saying I shouldn't use proper tabs in, say, vim?
10:47:42 <Guest523> Cale, thanks for pointing out, I guess clicking soft tabs (spaces) at the bottom of TextMate window was not enough
10:48:02 <Cale> Eduard_Munteanu: Add  set expandtab  to your .vimrc
10:48:02 <koeien37> Eduard_Munteanu: no! definitely not
10:48:05 <koeien37> :set et
10:48:39 <Eduard_Munteanu> Cale, why is this necessary? Some people (e.g. Linux people) always use tabs.
10:48:45 <koeien37> Guest523: change the : into a ++
10:48:51 <Cale> Guest523: but the type error here is that you have a list of one type and you're consing it onto a list of the same type
10:48:52 <suchsuch> just don't go by visual layout and you can use your tabs :)
10:48:59 <Cale> Guest523: (rather than a list of lists)
10:49:01 <koeien37> Eduard_Munteanu: Haskellers don't :)
10:49:02 <suchsuch> forces you to learn the rules
10:49:15 <Cale> Guest523: x : xs means the list whose *first element* is x, and whose tail is xs
10:49:25 <Eduard_Munteanu> It worked okay as far as compiler and indentation like each other.
10:49:46 <Cale> Eduard_Munteanu: Because Haskell is not just indentation-sensitive.
10:50:05 <Cale> Eduard_Munteanu: It's sensitive to how things are aligned vertically.
10:50:15 <aavogt> suchsuch: well if people get by without knowing the precise indentation rules, maybe it's enough to just have a feeling about them?
10:50:21 <Cale> Eduard_Munteanu: consider something like this:
10:50:27 <Cale> main = do putStrLn "Hello there"
10:50:42 <Eduard_Munteanu> Cale, my coding style is okay, I always align stuff well, like arguments on the next line are aligned with the opened brace.
10:50:57 <Eduard_Munteanu> Cale, yes..
10:51:04 <suchsuch> aavogt: well I mean know the rules enough to be scared straight...
10:51:19 <Cale> To be part of the do-block, the next line must be aligned to the p in putStrLn
10:51:27 <aavogt> suchsuch: what do you mean?
10:51:38 <Cale> That is, it must be indented exactly  length "main = do "  spaces.
10:51:46 <Eduard_Munteanu> Cale, yeah, I do that in C as well like...
10:51:58 <Eduard_Munteanu> blah(1, 2, 3,
10:52:04 <Guest523> Cale, thanks! I would not have guessed from the compiler error that I'm using entirely wrong operator function.
10:52:06 <Eduard_Munteanu>      4, 5, 6)
10:52:20 <Cale> Tabs are treated by the compiler as aligning to the following multiple of 8-spaces.
10:52:23 <koeien37> Guest523: the compiler error makes sense though
10:52:25 <suchsuch> aavogt: well you can still use tabs to quickly indent things in situations where tab character widths won't ever be compared to space widths
10:52:31 <koeien37> Guest523: but it takes some experience to learn how to interpret them
10:52:33 <Eduard_Munteanu> Cale, yeah, ts = 8 here as well.
10:52:42 <Cale> Eduard_Munteanu: But not everywhere.
10:52:50 <Eduard_Munteanu> Cale, oh, I see the point.
10:53:12 <Eduard_Munteanu> Though tab is always 8 spaces as far as Linux guys are concerned.
10:53:14 <Eduard_Munteanu> :)
10:53:28 <Cale> It's even more awkward that tab isn't really 8 spaces
10:53:29 <Eduard_Munteanu> Even GNU uses 4 spaces instead of tabs when indenting.
10:53:44 <Cale> It's however many spaces are necessary to reach the next multiple of 8 column.
10:54:18 <Eduard_Munteanu> Hm, yeah.
10:54:30 <Guest523> koeien37: true, it might be useful. But it would have lead me to wonder how to tease the compiler believing both sides of ':' were actually known instead of vaguely inferred. Maybe I'll learn after few such problems that "you might be using incorrect function" instead.
10:54:39 <Eduard_Munteanu> Not sure if that poses a problem, since I always do tabs then spaces.
10:55:03 <koeien37> Guest523: well, (:) is of type a -> [a] ->[a], so it expects a list of lists as second argument there
10:55:03 <Cale> While it's possible to code in a style which makes the effect of hard tabs irrelevant, it does make things look ugly and/or introduces the possibility of editing mistakes.
10:55:19 <Cale> Personally, I think tab characters should be considered a lexical error by the standard.
10:55:36 <koeien37> yes, except in string literals
10:55:43 <koeien37> and in comments
10:55:45 <Cale> Even in string literals
10:55:49 <Cale> But maybe not comments.
10:56:07 <aavogt> I don't think that -fwarn-tabs looks in comments and litterals
10:56:20 <Cale> String literals can affect alignment too.
10:56:33 <temoto> Hello. I have troubles with Int vs. Integer
10:56:35 <koeien37> and in Literate Haskell, obviously not in the non-haskell parts
10:56:40 <koeien37> temoto: more specifically?
10:56:41 <Cale> foo "hello <hardtab>" $ do ...
10:56:47 <temoto> let nat = [1..]
10:56:58 <temoto> let tri n = sum $ take n $ nat
10:57:00 <Cale> (though I'll admit that's an odd case)
10:57:12 <koeien37> hm. I didn't consider that
10:57:14 <Eduard_Munteanu> Cale, hm, I treat do as an open { brace.
10:57:21 <koeien37> but then {-  -} can also mess it up
10:57:21 <temoto> this doesn't happen, because take wants Int as i understood error message
10:57:30 <Cale> koeien37: right.
10:57:32 <Eduard_Munteanu> In that case it doesn't care about indentation I think.
10:57:49 <Cale> temoto: convert using fromIntegral
10:57:49 <Eduard_Munteanu> as in no code after do, only on next line.
10:57:51 <suchsuch> I find indentation in the middle of expressions weird
10:58:07 <temoto> which is very stunning, because Int is a very limited type isn't it? Why would 'take' be specified on it?
10:58:16 <ksf> depends on how long they are.
10:58:19 <Cale> temoto: Because the standard is dumb in this regard.
10:58:26 <koeien37> because the standard is broken IMO
10:58:27 <Guest523> koeien37: I'm not going to oppose. But let me add that for newbiew type a -> [a] does not mean the latter is list of list, as 'a' feels at (:) one could be passing anything. Maybe one sees that after thinking the first parameter should be a list.
10:58:28 <Cale> temoto: Int ought to be banished from the Prelude.
10:58:35 <temoto> Cale: i see :)
10:58:42 <Guest523> Well, I just got messed up with the operator, will learn them surely.
10:58:43 <koeien37> Guest523: right, a can be anything. It can mean [[Integer]] as well
10:58:46 <Eduard_Munteanu> Umm, wasn't Int the largest integral type?
10:58:49 <aavogt> Cale: actually, tabs in litterals are checked
10:58:50 <Cale> no
10:58:51 <koeien37> Eduard_Munteanu: Int is bounded.
10:58:58 <temoto> Eduard_Munteanu: i believe Integer is.
10:59:02 <Eduard_Munteanu> Oh, I'm mixing up.
10:59:03 <koeien37> temoto: that's correct
10:59:06 <Cale> Eduard_Munteanu: Integer is larger. mnemonic: longer word.
10:59:20 <Eduard_Munteanu> But is it a good idea to always use Integer? :/
10:59:23 <Cale> Yes.
10:59:23 <ksf> Eduard_Munteanu, Int is at least 31 bits, iirc.
10:59:34 <koeien37> and Int should be removed from the Prelude and go to Data.Int, not in the Prelude
10:59:39 <Cale> Unless you're absolutely forced to use Int for performance's sake
10:59:41 <aavogt> > log (fromIntegral (maxBound ::Int))
10:59:42 <lambdabot>   43.66827237527655
10:59:47 <ksf> if you need the speed, use Int64 or Word64 or such
10:59:56 <Eduard_Munteanu> Cale, I'm used to sizing things up sensibly, like in C.
10:59:56 <koeien37> Generally, using Integer is better.  Except for reasons of run-time efficiency
10:59:58 <Cale> Integer is already quite fast enough for most applications.
11:00:09 <koeien37> but you ought to change it only after profiling
11:00:36 <koeien37> and then using Int32 might be a better idea
11:00:39 <Eduard_Munteanu> Yeah, but it's like I wrote all my C programs using long only :)
11:00:44 <Cale> Int is an optimisation which is usually premature and very often correctness-destroying.
11:00:45 <koeien37> that doesn't say much? :)
11:00:59 * jmcarthur is also not a fan of Int being the default for so many things
11:01:00 <ksf> > log (fromIntegral (maxBound ::Int) * 2)
11:01:01 <lambdabot>   44.3614195558365
11:01:19 <koeien37> Eduard_Munteanu: why not int32_t and friends?
11:01:21 <ksf> > log (fromIntegral (maxBound ::Int - minBound :: Int) )
11:01:22 <lambdabot>   <no location info>: parse error on input `-'
11:01:37 <Eduard_Munteanu> Shouldn't there be a generic integral type used for most Prelude stuff?
11:01:41 <Cale> Int is actually a good idea over Int32 for cross-platform performance, because it will always be whatever machine integer type is most natural for the platform.
11:01:48 <Eduard_Munteanu> koeien37, yeah, but you still want things to size up according to the machine.
11:01:58 <ksf> > log (fromIntegral (maxBound ::Int) - fromIntegral (minBound :: Int) )
11:01:58 <koeien37> Cale: that is true. OTOH you can't use wrapping then (and the modulo 2^n behavior)
11:01:59 <lambdabot>   44.3614195558365
11:02:00 <Eduard_Munteanu> koeien37, so ints and longs do make sense.
11:02:14 <koeien37> which is, I admit, a rather limited case
11:02:15 <Cale> But if the bounds actually matter to you, you need to use maxBound/minBound, yeah.
11:02:45 <suchsuch> I remember something about the standardness of the wrapping behavior being confusing
11:02:51 <ulfdoz> Eduard_Munteanu: Oh yes, makes well readable #ifdef'd C-Code.
11:02:52 <ksf> Eduard_Munteanu, there's Integer, and it's even the default type for Num a
11:03:09 <ulfdoz> Eduard_Munteanu: A must for every masochist.
11:03:11 <Eduard_Munteanu> koeien37, I agree int*_t should be default and int, long etc. should be defined in terms of the first.
11:03:21 <Eduard_Munteanu> ulfdoz, stdint.h
11:03:51 <Eduard_Munteanu> Right now it's the other way around.
11:04:16 <ksf> types like AtLeast32BitsInt and such would be useful, too, if you don't need wrapping
11:04:18 <Cale> Mostly, using machine integers directly is just a form of stupidity which is perpetuated by programmers using low-level languages. I also vaguely suspect that unbounded integer types could be a lot faster if their use was more common and the people designing processor architectures were designing for that case.
11:04:26 <Eduard_Munteanu> ulfdoz, so you don't need ifdefs at all.
11:05:05 <ksf> unbounded integers could be even faster if ghc wouldn't be using gmp
11:05:12 <koeien37> Cale: and programming languages like Java, that make them hell to use
11:05:13 <Cale> But already, Integer will fall back to machine integers for small values (though there's the overhead of doing some bounds checking)
11:05:21 <ben0x539> How much slower are unbounded integer types if you stick to the range that is covered by machine interger types?
11:05:31 <ksf> ...stuff like inlining and specializing functions, that stuff doesn't work via the ffi
11:05:39 <Cale> ksf: Is gmp particularly poor performance-wise?
11:05:46 <ksf> it's awesome.
11:05:47 <Cale> ah, I see
11:06:02 <HugoDaniel> the way haskell handles encodings is really appalling :(
11:06:08 <ulfdoz> Eduard_Munteanu: But when do you test that? I'm primarily programming java and I really like the fixed-length of the primitves, there is seldom a need to test code on different platforms.
11:06:13 <Cale> Yeah, we might actually do better with a native library.
11:06:34 <Cale> HugoDaniel: The text encoding issue should be better in 6.12
11:06:36 <ksf> sometimes I even believe that having C99 as EDSL would be a hell of a good idea
11:06:44 <koeien37> or we might not be: GMP is pretty well optimized
11:06:46 <HugoDaniel> oh, nice then :)
11:06:59 <koeien37> HugoDaniel: is there something wrong with Data.Text?
11:07:10 <Eduard_Munteanu> ulfdoz, if you don't do messy stuff (like unaligned pointer access, depending on endianness etc), you don't really need to test. You can trust stuff like uint32_t
11:07:17 <Cale> ben0x539: I seem to recall something like at worst a factor of 2?
11:07:37 <ben0x539> That seems benign enough
11:07:51 <Cale> Yeah, it's mostly very reasonable.
11:07:55 <Eduard_Munteanu> ksf, EDSL?
11:08:07 <ksf> it's fast enough to be a sensible default. especially as replacing it in tight loops is a simple type annotation (and fromIntegral)
11:08:10 <jmcarthur> i just wish we had Integer, Int8, Int16, Int32, Int64, Natural, Nat8, Nat16, Nat32, and Nat64 (the Nat series is called Word right now, which i guess is okay, too), without plain Int or Word with underspecified number of bits
11:08:14 <ksf> embedded domail specific language
11:08:22 <ksf> well it actually dosent' even have to be embedded
11:08:33 <Cale> jmcarthur: I think there's a place for the unspecified size.
11:08:42 <ksf> Int128. Even my cpu has them, and it's ancient.
11:08:56 <ben0x539> FastestIntWithAtLeast32
11:08:56 <Eduard_Munteanu> No offense intended, but now I understand people who are against writing OSes in high-level languages.
11:09:16 <Eduard_Munteanu> I mean a factor of 2 might throw others into LOLing :)
11:09:19 <suchsuch> once all OSes become written in haskell things will be a lot nicer
11:09:53 <burp> let's start with one first ;)
11:10:01 <koeien37> Eduard_Munteanu: we (at least I am) are not against the existence of Data.Int
11:10:04 <Cale> Eduard_Munteanu: This has to be taken with the understanding that Int actually silently introduces bugs into your code.
11:10:06 <koeien37> just that it should not be the default.
11:10:09 <Eduard_Munteanu> And I was bashing people who wrote asm-coded routines for BLAS and the likes :)
11:10:12 <jmcarthur> Eduard_Munteanu: we are not against exposing certain things in the name of optimization
11:10:12 <ksf> Eduard_Munteanu, I witnessed Haskell being faster than C.
11:10:13 <koeien37> for the reason Cale mentioned
11:10:19 <ksf> hell, I've written the code myself.
11:10:24 <Eduard_Munteanu> Cale, hm, that's not good...
11:10:28 <jmcarthur> Eduard_Munteanu: as long as said exposure is selective and controlled
11:10:30 <dolio> If you don't have Int, you're going to cause people to use CPP to decide between Int32 and Int64 depending on what the system does best.
11:10:39 <dolio> Which isn't great.
11:10:41 <Cale> Eduard_Munteanu: Of course, in C, you just can't avoid it.
11:10:42 <ksf> ...the reason isn't so much that haskell would be that much faster, by itself, but that a better algorithm can be used because of haskell.
11:11:02 <ben0x539> Because only CS nerds who are good at algorithms write programs in Haskell?
11:11:04 <Cale> Eduard_Munteanu: At least, without using something like GMP all the time, which would be seen as ridiculous.
11:11:15 <ksf> Eduard_Munteanu, write that in C: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12290
11:11:37 <jmcarthur> dolio: well, my intent is really that Int should be exposed but not encouraged outside of optimizations after profiling
11:11:46 <mreh> :t unfoldr
11:11:47 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
11:11:54 <jmcarthur> dolio: and perhaps it shouldn't have such a short name ;)
11:11:55 <koeien37> jmcarthur: yep, tucked away in Data.Int
11:12:03 <koeien37> Can't wait for a better Haskell :)
11:12:18 <koeien37> although these things are mostly library issues
11:12:26 <jmcarthur> koeien37: #alt-stdlib
11:12:29 <ksf> ...there's just no easy way in C to say "take that list and reify it into a chain of elseifs so we have binary lookup"
11:12:32 <koeien37> jmcarthur: yep, I'm there :)
11:12:35 <jmcarthur> koeien37: a slow work in progress
11:12:40 <jmcarthur> oh, righto!
11:12:43 <temoto> koeien37: what is a better haskell?
11:12:51 <jmcarthur> i do not pay enough attention i think
11:12:54 <suchsuch> H2011?
11:12:58 <Cale> temoto: The Haskell that is to come.
11:13:01 <koeien37> jmcarthur: there is only silence
11:13:05 <ksf> there's clean and uniqueness typing.
11:13:18 <Cale> The standardisation process is the wrong place for meaningful changes to the language.
11:13:22 <koeien37> I'd really like ML functors in haskell.
11:13:25 <ksf> I don't even know whether anybody has even investigated if it could be added to haskell
11:13:25 <koeien37> with a different name though
11:13:36 <Eduard_Munteanu> ksf, you mean I'd quickly run into the problem of getting extra number width/precision?
11:13:37 <temoto> It was said like the characteristics of 'better Haskell' are defined already.
11:13:40 <ksf> koeien37, records = modules = objects
11:13:42 <Eduard_Munteanu> ksf, I agree.
11:14:07 <Eduard_Munteanu> ksf, but there are C implementations for arbitrary-precision numbers, and I'd rather have that as a special case rather than default.
11:14:08 <koeien37> I have not used Clean and its uniqueness typing
11:14:18 <temoto> Were you talking about specific features?
11:14:20 <Cale> Change has to occur in the implementation first. (By all means, specify what you're implementing clearly if you want. but putting it into a standard before implementing isn't good.)
11:14:24 <newsham> can we get rid of partial functions?
11:14:28 <mreh> is this whole strict/lazy monad distinction a general strategy of evaluation?
11:14:40 <dolio> ksf: I don't see why it wouldn't be able to be added, since Clean is pretty close to Haskell. It's just one step closer to SPJ's head exploding. :)
11:14:42 <ksf> Eduard_Munteanu, haskell taught me what rapid prototyping means
11:14:52 <koeien37> newsham: I'm not against partial functions
11:14:54 <ksf> basically, using a bounded integer by default is premature optimization.
11:15:01 <mreh> a set of laws that (>>=) must obey ontop of the others
11:15:20 <ksf> dolio, so we should just claim it can't be done?
11:15:22 <Eduard_Munteanu> ksf, I agree, for most stuff it is. Maybe I'm too used to it though.
11:15:32 <dolio> Who claimed it can't be done?
11:15:39 <Cale> mreh: It's about how >>= is implemented in each specific case, rather than something which we can really generalise about.
11:15:41 <ksf> oh, it's a tactical argument.
11:15:50 <suchsuch> records = data imho, they need to be more cleanly separated from modules
11:16:01 <ksf> code = data
11:16:05 <Cale> mreh: Like, there's a strict and lazy version of State, but that doesn't mean that there'll be a strict and lazy version of everything.
11:16:08 <temoto> So there is 'take 1' aka head, there is 'takeWhile' with predicate. What's nicest way to take first element satisfying predicate?
11:16:10 <koeien37> ksf: Haskell /= lisp IME
11:16:11 <ksf> ...in haskell even more so than lisp
11:16:26 <koeien37> temoto: head . filter; although you must prove that such an element exist.
11:16:27 <mreh> I'm doing my genetic programming in haskell
11:16:34 <suchsuch> well, 'data' as in algebraic data types without labels I mean
11:16:39 <ksf> heck with data Foo = Bar Int, Bar is a _function_
11:16:44 <koeien37> ksf: ah. how then?
11:16:54 <temoto> koeien37: prove to whom?
11:17:09 <koeien37> temoto: to yourself. if you call head on an empty list, you will get an error
11:17:14 <dolio> I'd like to see uniqueness typing in GHC/Haskell, but I'm not really waiting for it to happen.
11:17:15 <Eduard_Munteanu> temoto, you should really be using Maybe for that.
11:17:27 <ksf> there's virtually no conceptual or semantic difference between a module with functions foo and bar, and data Baz = { foo :: ... , bar :: ... }
11:17:35 <temoto> ah, that i know, there will be an element, thanks.
11:17:37 <Eduard_Munteanu> Like findIndex or whatsitsname does.
11:17:46 <Gracenotes> even data, stored in memory, is stored as code which (when executed) dispatches data as appropriate
11:17:50 <Cale> I might like uniqueness typing, but not for I/O.
11:18:04 <ksf> Cale, ack
11:18:04 <koeien37> ksf: but I can't parametrize the data type with an integer
11:18:05 <Gracenotes> as a loose STG-y summary of things
11:18:09 <Cale> Or, if we're going that way, please wrap the whole thing up in a monad for me.
11:18:13 <dolio> No, I don't think it's better for I/O. It's better for optimized pure arrays.
11:18:19 <koeien37> unless I want to give up on performance
11:18:33 <ksf> ...you can give a type parameter.
11:18:34 <temoto> By the way there was a big discussion on RSDN about records and problems of their members globalness.
11:18:35 <dolio> Like DiffArray, only actually fast.
11:18:40 <Eduard_Munteanu> BTW, if I want to study FRP, which stuff should I be looking into? Grapefruit or what else is best?
11:18:43 <koeien37> ksf: I can, sure
11:18:55 <ksf> ...my point isn't that modules and records are the same, but that they could and should be the same.
11:19:01 <Eduard_Munteanu> Gtk2Hs was pleasant, but it can be better.
11:19:07 <PeakerWork> Eduard_Munteanu: despite not working correctly at the moment, Reactive is really nice, and Phooey too
11:19:09 <koeien37> ksf: I would love to see modules as first-class values
11:19:40 <Eduard_Munteanu> PeakerWork, thanks, I'll look at Reactive too. I only looked at some Grapefruit snippets.
11:19:41 <Cale> I *really* wish that Reactive actually worked.
11:19:41 <ksf> and as that'd be awfully close to OOP, we could then as well go for all of it and include OOHaskell in the standard.
11:19:56 <Eduard_Munteanu> What do you mean it doesn't work? Some corner cases or nothing at all?
11:19:58 <suchsuch> I think a better record system should change labels from being projection functions
11:20:07 <koeien37> I don't think more object orientation is what haskell needs
11:20:23 <newsham> suchsuch: it would be nice if you could use the same record fieldname in different records
11:20:31 <ksf> it's awfully messy when you need it.
11:20:31 <Eduard_Munteanu> ksf, but AFAIU, Haskell is OOP. It's just implemented different than in C++.
11:20:32 <mental> koeien37: i agree - it would be too comprehensible
11:20:36 <Cale> Eduard_Munteanu: There are performance problems that shouldn't be there, which kill nearly any nontrivial use.
11:20:40 <koeien37> mental: :)
11:20:52 <Eduard_Munteanu> Cale, hm, trivial use is good for me, I'm interested in the concept.
11:20:53 <dolio> Modules need to be able to contain types, not just functions.
11:20:54 <ksf> it surely would be a different kind of OOP
11:21:26 <ksf> ...most importantly, not be used everywhere in the program.
11:21:27 <Cale> Eduard_Munteanu: and by "performance problems" I mean that programs that should work end up looping forever in some cases.
11:21:30 <Eduard_Munteanu> Polymorphism brings it quite into OOP.
11:21:37 <mreh> if MonadRandom is a strict monad, why does it allow getRandomRs, and the like, a function that will generate an infinite list of numbers
11:21:55 <PeakerWork> Eduard_Munteanu: OOP is a lot about "inheritance"
11:22:05 <Eduard_Munteanu> PeakerWork, type classes ? :)
11:22:09 <PeakerWork> Eduard_Munteanu: Haskell has the desirable traits of OOP, without the undesirable ones (Inheritance)..
11:22:19 <PeakerWork> Eduard_Munteanu: Type-classes are not inheritance, and in fact are much superior to inheritance :)
11:22:19 <ksf> but e.g. Yi modes are objects, and it makes sense, you can switch between parsers, analyzers and highlighters on run-time and still have them work together.
11:22:27 <Eduard_Munteanu> Well, it's not traditional OOP, but looks very OOP to me.
11:22:29 <Cale> Well...
11:22:43 <PeakerWork> Eduard_Munteanu: Can you have "conditional inheritance"?  instance Eq a => Eq (Maybe a) where ..  <-- is this inheritance? how do you inherit conditionally?
11:22:54 <Cale> Actually, OOP is usually better represented without typeclasses, in my opinion.
11:23:07 <Cale> Just create datatypes which consist of records of operations.
11:23:10 <PeakerWork> Eduard_Munteanu: Well, if OOP is so vaguely defined that even Haskell is an OOP language, then it really is a meaningless term
11:23:13 <koeien37> the canonical way is a typeclass + an existential, no?
11:23:17 <ksf> implementation inheritance is usually evil
11:23:19 <Eduard_Munteanu> PeakerWork, I don't see that as a problem, C++ doesn't seem to have it.
11:23:31 <Cale> and constructor functions which take the private data of the objects as parameters
11:23:40 <simard> I need cabal to add -L"something" everytime it calls ghc.. how can I do that ? I tried to add a ghc-option: -L"something" to .cabal/config, but it doesn't seem to work
11:23:46 <Eduard_Munteanu> PeakerWork, you can do OOP in C too, albeit more cumbersome.
11:23:53 <Eduard_Munteanu> PeakerWork, look at Linux and Wine code.
11:23:53 <PeakerWork> Eduard_Munteanu: It doesn't have conditional inheritance - which makes it less apt for code re-use (e.g: It can't have Maybe instances via interface inheritance)
11:24:07 <Cale> Eduard_Munteanu: http://cale.yi.org/index.php/A_look_at_OO_from_Haskell -- let me know if this doesn't load for you - a friend was having trouble with my DNS record
11:24:14 <PeakerWork> Eduard_Munteanu: You can do OOP in Haskell - but type-classes are not inheritance - and Haskell doesn't have facilities to support "OOP"
11:24:30 <Eduard_Munteanu> Cale, loads fine.
11:24:54 <Apocalisp> OOP == _|_
11:24:56 <koeien37> Cale: does not work for me, I get redirected to some search website
11:25:17 <Eduard_Munteanu> Cale, if you changed A records, the TTL might not have expired yet.
11:25:23 <PeakerWork> Eduard_Munteanu: I don't think "OOP" is really a good thing -- encapsulation is good, polymorphism is good, code re-use is good.  Haskell does all of these *better* than all of the OOP languages I know, and is not really "OOP", not having inheritance
11:25:45 <kmc> OO means a lot of different things http://www.paulgraham.com/reesoo.html
11:25:48 <Cale> koeien37: yeah, that's the same as my friend.
11:25:59 <ksf> http://yi-editor.blogspot.com/2008/12/prototypes-encoding-oo-style.html
11:26:07 <koeien37> thanks.
11:26:12 <kmc> "Perhaps part of the confusion... is that the C/C++ folks see OO as a liberation from a world that has nothing resembling a first-class functions, while Lisp folks see OO as a prison since it limits their use of functions/objects"
11:26:17 <Eduard_Munteanu> PeakerWork, yeah, I'm not really a supporter of OOP in the sense it's done in say C++.
11:26:33 <Cale> Somehow some people are getting sent to an address which is owned by the sponsoring registrar of yi.org, (which is a free subdomain provider)
11:26:35 <jmcarthur> mreh: MonadRandom is not a monad, it's a type class
11:26:40 <kmc> "One of the stated goals of C++ is support for object-oriented programming. This page introduces C++ classes and outlines the tactics they use to defeat their purpose." -- C++ FQA
11:26:50 <Eduard_Munteanu> kmc, well, Lisp is kinda evil with the things it allows you to do.
11:26:54 <PeakerWork> @quote ill defined
11:26:54 <lambdabot> No quotes for this person. You speak an infinite deal of nothing
11:26:55 <Cale> 99.247.248.73 should work
11:27:03 <PeakerWork> someone said "OOP is an ill-defined fad"
11:27:14 <simard> never mind it works now
11:27:14 <Eduard_Munteanu> @quote ill-defined
11:27:14 <lambdabot> No quotes match. BOB says:  You seem to have forgotten your passwd, enter another!
11:27:14 <koeien37> meh, the FQA sometimes a bit silly imo, but it does have some good criticisms
11:27:15 <kmc> @quote abstraction.oriented
11:27:16 <lambdabot> JonFairbarn says: I think we should call it "Abstraction Oriented Programming". It's got the "oriented" buzzword in it, and we don't need to tell folk that "abstraction" means more than one thing to
11:27:16 <lambdabot> us until we're sure they're OK.
11:27:31 <mental> @quote oop
11:27:31 <lambdabot> ihope says: Oops, I forgot that Djinn doesn't do GADT's.
11:27:32 <kmc> the FQA gets a bit hysterical, so does the FAQ
11:27:33 <mental> @quote oop
11:27:34 <lambdabot> ghc says: Oops!  Entered absent arg
11:27:37 <mental> @quote oop
11:27:37 <lambdabot> ihope says: Oops, I forgot that Djinn doesn't do GADT's.
11:27:40 <mental> oops :(
11:27:50 <kmc> @quote oriented
11:27:51 <lambdabot> Cale says: Ruby is kind of a nice language, for an imperative object oriented language that isn't smalltalk.
11:27:55 <koeien37> that is a nice technique
11:28:11 <suchsuch> what do we think of this as a new records systems?
11:28:12 <suchsuch> 1. data Foo = {x::Int, y::Int, ...} doesn't create any projection functions (avoiding problem of sharing labels)
11:28:14 <suchsuch> 2. since there are no projectors, you need a way to bring the labels into scope, say:
11:28:16 <suchsuch> let (x,y) from (rec :: Foo) in ...   will bind the fields to x and y and bring them in scope (as Ints, not Foo->Int)
11:28:18 <suchsuch> finally, you need a way to deal with trying to bring 2 labels with the same name into scope:
11:28:20 <suchsuch> let (x1,y1) = (x,y) from rec1;
11:28:21 <suchsuch>      (x2,y2) = (x,y) from rec2;   --brings x1,y1,x2,y2 into scope but not x or y
11:28:23 <suchsuch> in ..
11:28:34 <ksf> suchsuch, I think you should use a pastebin
11:28:35 <sinelaw> Eduard_Munteanu, also, "OOP" usually implies mutable objects
11:28:44 <suchsuch> apologies
11:28:49 <sinelaw> and who is "we"?
11:28:59 <Cale> suchsuch: Have you looked at Daan Leijen's system?
11:29:10 <kmc> sinelaw, not only that -- it usually implies confusing the concepts of "value" and "state"
11:29:15 <Cale> suchsuch: I would really like his system, but with a more Haskell-y syntax.
11:29:24 <kmc> a mutable value is not a value at all
11:29:40 <ksf> it is, in fact, a function of time.
11:29:44 <kmc> a value can be a reference to a mutable cell -- the cell itself is not a value
11:29:44 <ksf> ...which is a value
11:29:47 <mreh> Haskell-why?
11:30:02 <Eduard_Munteanu> sinelaw, some combination of ST-like classes perhaps might do it?
11:30:06 <sinelaw> kmc, true. and a set of interacting mutable objects is something that's very hard to analyze
11:30:06 <Cale> suchsuch: If we're going to do a new record system, I think we really want some kind of row-polymorphism
11:30:25 <suchsuch> Cale: does his do that?
11:30:31 <suchsuch> looking for it right now..
11:30:53 <ksf> sinelaw, depends. aggregations of DFAs are quite easy to deal with.
11:30:57 <Cale> http://research.microsoft.com/en-us/um/people/daan/download/papers/scopedlabels.pdf
11:30:57 <Ke> indenting is hard =o(
11:31:00 <PeakerWork> Eduard_Munteanu: the question is whether you'd WANT to do it
11:31:01 <Ke> I like C!
11:31:17 <sinelaw> ksf, it is?
11:31:19 <Cale> suchsuch: and he has a system which avoids the use of lacks-predicates (the assertion that some record does not contain a particular field, which seems unnatural at least to me)
11:31:23 <ksf> yep.
11:31:25 <PeakerWork> Eduard_Munteanu: Mutable objects go further away from simple systems that have mathematically describable semantics
11:31:42 <Eduard_Munteanu> PeakerWork, not really. Perhaps some namespace hack might be better to make it look more OOP.
11:31:47 <ksf> you can even combine them into one and slice them up as you want.
11:31:52 <sinelaw> ksf, what exactly is "aggerations of DFAs"?
11:31:54 <kmc> Ke, you don't have to indent in Haskell
11:32:06 <mental> Ke: you don't indent in C?
11:32:27 <Eduard_Munteanu> PeakerWork, I'm not really a OOP supporter.
11:32:32 <ksf> sinelaw, something like a program in a synchronous language like atom or lustre looks like
11:32:36 <newsham> suchsuch: those arent firstclass
11:32:45 <newsham> you'd have to create new functions or use lambdas to pass those around
11:32:46 <kmc> you can write Haskell with { } ; plus whatever indentation you like
11:32:49 <Cale> Ke: It's easy if you remember the following: 1) Tab characters are pure evil and you must configure your text editor properly not to produce them. 2) Things which are at the same level in the syntax start in the same column. 3) If something is part of something else on the line before it, it starts in a deeper column.
11:32:52 <kmc> exactly the same as C
11:32:56 <sinelaw> ksf, ok that's more like FRP than OOP (at least lustre)
11:33:01 <PeakerWork> Eduard_Munteanu: well, the question is why then
11:33:11 <jmcarthur> i think of OOP as a decent idea that has been applied to far more things than it ever should have been
11:33:14 <Eduard_Munteanu> Tabs are so evil they should be typed IO (Tab) :P
11:33:15 <PeakerWork> Eduard_Munteanu: OOP was a *huge* improvement over the entire mess that preceded it
11:33:26 <PeakerWork> but I think denotational programming is a huge improvement over OOP
11:33:27 <suchsuch> newsham: I suppose
11:33:58 <Eduard_Munteanu> PeakerWork, not really, I saw lots of C code that used OOP concepts when needed, without going through the C++ mess.
11:34:00 <ksf> I've seen enough C programs passing structs to track their state.
11:34:09 <ksf> there's no need to do all that inheritance bunk.
11:34:10 <PeakerWork> Eduard_Munteanu: well, C code using OOP concepts classifies as OOP
11:34:27 <jmcarthur> PeakerWork: i think denotational programming is too much of a work in progress to claim that it has much over OOP yet
11:34:30 <PeakerWork> ksf: and "virtual tables" (records of functions), and encapsulating abstract data types
11:34:36 <Eduard_Munteanu> PeakerWork, I think it's more a matter of languages. C++ isn't really the best stuff out there.
11:34:41 <temoto> denotational?
11:34:43 <jmcarthur> PeakerWork: we don't even know for sure how well it fits many domains
11:34:57 <newsham> what if you had to explicitely use a special accessor function?   (fetch field record)?  where "field" was some sort of type parameterized by the record and its result type?
11:34:57 <PeakerWork> jmcarthur: for a wide class of problems (almost everything that's not reactive?) I think it's already covered..
11:35:03 <ksf> ...though virtuals aren't always as useful.
11:35:05 <Cale> (At least what I consider to be) the essence of OOP isn't a bad thing. There are a lot of other non-essential concepts surrounding it which I think are less than productive.
11:35:05 <jmcarthur> PeakerWork: don't get me wrong, i'm a huge proponent of it
11:35:11 <Eduard_Munteanu> ksf, PeakerWork, Wine code does virtual functions in pure C code.
11:35:23 <Eduard_Munteanu> Quite neat as an exercise.
11:35:23 <newsham> err.. that still makes field a global name :(
11:35:33 <PeakerWork> Eduard_Munteanu: Passing function pointers around is not really harder in C than using "virtual" in C++, yea
11:35:35 <kmc> yes, C++ is a terrible OOP language
11:35:37 <newsham> i wish field names were scoped by record somehow :(
11:35:37 <ksf> I think I nearly always went with an interpreter approach instead, just passing an enum to choose the format string and such.
11:35:37 * Eduard_Munteanu nods to Cale.
11:35:39 <kmc> it makes creating a new class so hard
11:35:41 <kmc> so much boilerplate
11:35:48 <ben0x539> class A { };
11:35:54 <Cale> I consider the essence of OOP to be the view that values are characterised by the operations which are supported by those values.
11:35:55 <kmc> cool, a class that does nothing
11:35:57 <kmc> i hated OOP until I used Python, where creating a new class is one line of code
11:36:02 <ksf> typeclasses in C would be a cool thing to try.
11:36:08 <ben0x539> gobject does vritual functions too and is probably more interesting because we might want to wrap gobject classes in haskell APIs
11:36:17 <newsham> class MyError(Exception) : pass
11:36:17 <PeakerWork> newsham: Do you want  RecordType.name  for every access?
11:36:17 <Cale> (or, using slightly different terminology, the messages which those objects respond to)
11:36:23 <jmcarthur> ksf: Go might be worth looking at for that, from what i hear
11:36:25 <Eduard_Munteanu> kmc, I definitely agree. C++ supporters quote improved productivity, but you need to write so much useless code.
11:36:42 <ksf> jmcarthur, I'm boycotting issue9.
11:36:42 <Eduard_Munteanu> kmc, at least without using templates or other features.
11:36:46 <newsham> peaker: i would prefer not.  I can get that same effect through consistent naming of fields
11:36:46 <Cale> That is, an object is its own responses to messages.
11:36:48 <kmc> Eduard_Munteanu, indeed, and the syntax is so hellish that writing automated tools to ease that burden is too hard
11:36:50 <Eduard_Munteanu> I had a hell of a time with wxWidgets.
11:36:55 <ksf> ...it fails badly on the polymorphism front.
11:36:59 <PeakerWork> newsham: do you want name resolution to depend on type resolution?
11:37:05 <Eduard_Munteanu> Maybe it would have been better had it used templates.
11:37:13 <PeakerWork> newsham: I think great horrors lie that path
11:37:30 <newsham> peaker: possibly.. I just miss the scoped field names
11:37:39 <PeakerWork> newsham: Way beyond the slight gain of not having to prefix record field names
11:37:40 <kmc> speaking of GObject, Vala is an interesting language
11:37:42 <ben0x539> Go is too different from C++ to be any good
11:37:44 <newsham> having to manually scope or avoid clashes in record names is a chore
11:37:48 <kmc> ben0x539, haha
11:37:54 <PeakerWork> newsham: have tiny modules :)
11:37:56 * PeakerWork gtg
11:38:03 <newsham> *nod* can use the module system for that
11:38:14 <Cale> The sort of polymorphism this makes natural is akin to existential types: there exists some type of data which supports these operations making up the object.
11:38:29 <newsham> would be nicer in a way if modules werent tied to files
11:38:36 <newsham> i hate having tons of tiny files
11:38:44 <newsham> but thats another can of worms
11:38:57 <Eduard_Munteanu> I thought I was insane at first writing a school project in Haskell and Gtk2Hs, and having to deliver it in 2 days, and not knowing much Haskell.
11:39:04 <Eduard_Munteanu> But it was definitely a good thing.
11:39:10 <Cale> Whereas the traditional FP approach views data as structure, and makes parametric polymorphism more natural
11:39:17 <kmc> type-dependent name resolution is a very un-haskelly idea
11:39:19 <newsham> anyway, I have no good answers, just a laundry list of small complaints :)
11:39:29 <kmc> you can put each record accessor name into its own typeclass
11:39:35 <kmc> that seems like an abuse of
11:39:37 <kmc> the class system
11:39:45 <suchsuch> I don't really like the view that everything with 'field x' is related, but I admit it would find use
11:39:45 <ben0x539> I still think it would be neat if we had some way to automatically generate (entirely imperative and unhaskell) wrappers for gobject libraries like vala does
11:40:03 <newsham> kmc: what if the accessors access diff typed things?
11:40:08 <Eduard_Munteanu> I'd really like some reflection capabilities in Haskell.
11:40:19 <Eduard_Munteanu> Not that they should be encouraged.
11:40:30 <Eduard_Munteanu> But they make extending the language in corner cases very easy.
11:40:42 <Cale> The advantage of the FP approach is that adding more operations which operate on existing values is simpler. The advantage of the (essential) OOP perspective is that adding new variations on data with the same operations is simpler.
11:41:03 <jmcarthur> Eduard_Munteanu: what is an example situation where reflection would help you in haskell?
11:41:31 <Cale> They are in a sense duals to one another, at least, once you cut away all the other stuff which has got itself mixed up into the idea of OO.
11:41:38 <Eduard_Munteanu> jmcarthur, maybe not reflection, but preprocessor stuff. For example using a directive to define mapping between a data structure and a list.
11:41:51 <Eduard_Munteanu> You'd need a strong preprocessor though.
11:42:06 <newsham> jmc: print '[Fields %s]' % (' '.join('%s=%s' % (n, getattr(self, name)) for name in dir(self)))
11:42:14 <mreh> I've been feedding mine fission chips
11:42:17 <jmcarthur> Eduard_Munteanu: something template haskell can't provide?
11:42:20 <newsham> stuff like that is very easy with reflection
11:42:28 <newsham> template haskell is considerably harder to wield
11:42:34 <phr> does data.generic Typeable count as reflection?
11:42:34 <Eduard_Munteanu> jmcarthur, I didn't look into template haskell, will do.
11:42:39 <Cale> (I don't know if anyone's listening to this though :)
11:42:55 <Eduard_Munteanu> BTW, do these things even stand a chance to get into standard Haskell?
11:42:56 <suchsuch> so basically you'd want a "has field x" constraint in the type system Cale?
11:43:21 <Philonous1> Cale: Trying to comprehend
11:43:23 <sinelaw> PeakerWork, btw we presented our verilog design, the guy was in a small shock over the recursion
11:43:24 <phr> newsham, that getattr example would be done with an explicit dictionary in haskell
11:43:29 <jmcarthur> Eduard_Munteanu: no idea
11:43:31 <suchsuch> spj's type directed name resolution proposal is on the wiki, but doesn't have support
11:43:33 <sinelaw> said he never saw such a thing :)
11:43:47 <newsham> phr: the idea isnt to use a dictionary..  python has dictionaries.
11:43:52 <jmcarthur> Eduard_Munteanu: i honestly don't like template haskell. it only seems useful if you haven't come up with a good enough abstraction for your API to avoid boilerplate
11:43:54 <newsham> the idea is to print an arbitrary record
11:44:05 <Cale> suchsuch: Basically, a kind of types with the ability to express that they have certain fields, and express things like that, for example, a function adds a certain field to any row type that you pass it.
11:44:12 <jmcarthur> although i suppose some level of boilerplate is unavoidable sometimes
11:44:36 <ksf> template haskell is really easy to wield. the problem is lacking quasiquote support
11:44:37 <Cale> suchsuch: And of course, if we're going that far, might as well do variants at the same time, as the paper explains how to do :)
11:44:43 <suchsuch> Cale: I'm not sure I understand adding fields to something
11:44:55 <Cale> suchsuch: Of course, it's a different type
11:45:03 <ksf> oh, and the stage restrictions could be less restrictive, that is, smarter.
11:45:13 <mreh> does anyone know a strategy for discovering what expression in my program is being evaluated currently? I've got an infinite unevaluated expression being evaluated thing going on.
11:45:18 <Eduard_Munteanu> jmcarthur, I see preprocessor hacks even in very mature languages. So I guess it's always nice to have a strong preprocessor. It shouldn't be encouraged to go wild with it though.
11:45:23 <ksf> you sometimes need to split up modules for no good reason whatsoever.
11:45:27 <newsham> i've used it several times.. i've never found it wasy to wield
11:45:28 <newsham> ymmv
11:45:29 <suchsuch> Cale: so like 'record updates', except the new value has more fields?
11:45:43 <kmc> Template Haskell is not just a preprocessor
11:45:48 <Berengal> Something a bit simpler than TH would be nice
11:45:53 <kmc> but yes, it's a powerful complicated tool of last resort
11:45:54 <suchsuch> Cale: and a different type
11:45:55 <jmcarthur> Eduard_Munteanu: i have honestly never seen a use of template haskell where i wouldn't have rather used the native haskell API
11:45:56 <Cale> suchsuch: A kind of row types who are characterised by which labels at which types they have, and nothing else.
11:45:59 <ksf> newsham, did you ever try to do the same kind of stuff in c++?
11:46:02 <Cale> suchsuch: right
11:46:08 <newsham> ksf: I'm not comparing it with c++
11:46:14 <kmc> the canonical uses of TH are automatically deriving boilerplate from datastructures
11:46:21 <kmc> like what fclabels does
11:46:31 <Eduard_Munteanu> jmcarthur, one thing that springs to mind... would TH be better than heterogenous lists?
11:46:31 <kmc> also specializing functions at compile time
11:46:33 <ksf> it's no lisp, but as I said, most of that is due to quasiquoting.
11:46:36 <Philonous1> Cale don't HLIsts already do that?
11:46:45 <Cale> Philonous1: extremely awkwardly
11:46:51 <ksf> ...and all that static typing is really cool.
11:46:52 <jmcarthur> kmc: i don't mind it as much when it's very obvious what it's doing
11:46:55 <Berengal> IMHO, the perfect language has no need for compile-time code generation
11:47:06 <jmcarthur> Eduard_Munteanu: i don't see how the two are related
11:47:17 <Berengal> Haskell isn't quite there yet (but it's damned close compared to some other languages)
11:47:27 <Cale> Philonous1: (just to be clear, the discussion with suchsuch is separate from the OOP one ;)
11:47:34 <jmcarthur> Berengal: should the perfect language need a compiler?
11:47:37 <ksf> Berengal, well yes supercompilation would certainly be better.
11:47:52 <Eduard_Munteanu> jmcarthur, nevermind, it's not straightforward to explain what I meant :)
11:47:55 <ksf> ...but I'd still want to be able to say "have this done by compile-time"
11:48:06 <ksf> we could term that "deadline-oriented programming"
11:48:08 <Berengal> jmcarthur: No language _needs_ a compiler, just semantics. Everything else is just implementation
11:48:09 <Eduard_Munteanu> jmcarthur, it's something I encountered while using Gtk2Hs with ModelViews.
11:48:32 <suchsuch> now I'm interested Cale, what's your idea for the OOP idea?  or is typeclasses close enough?
11:48:47 <jmcarthur> ksf: i wouldn't mind partial lazy evaluation / JIT instead of a rigid line between compile time and run time
11:48:56 <Berengal> Who maintains gtk2hs by the way?
11:49:03 <suchsuch> I mean implementation wise
11:49:18 <Cale> suchsuch: Basically, that the essence of OOP is that values (objects) are characterised entirely by what various operations do to those values (that is, how those objects respond to messages)
11:49:26 <ksf> jmcarthur, oh, that, too.
11:49:29 * Eduard_Munteanu thinks Gtk2Hs has some charming features that make it go along with functional stuff surprisingly well
11:49:34 <Eduard_Munteanu> I mean GTK.
11:49:41 <ben0x539> All the callbacks?
11:49:47 <ksf> llvm sounds promising, there.
11:49:51 <jmcarthur> in fact, i would *love* to have partial lazy evaluation
11:50:16 <Eduard_Munteanu> ben0x539, from what I've seen so far. I mean data stores, like ModelView is nice for instance.
11:50:21 <Berengal> jmcarthur: Under lambdas, you mean?
11:50:26 <taruti> Is it possible to instruct Haddock to generate a document with the instances hidden by default?
11:50:44 <Cale> suchsuch: In Haskell, a simple, but often quite sufficient way to implement this essence of what OO programming is about is just to use record types with the various operations in them.
11:50:44 <jmcarthur> Berengal: haskell may not provide us with the proper control we might need, but yes
11:51:26 <Berengal> jmcarthur: You can already make it evaluate under lambdas if you split them into several lambdas taking one argument each
11:51:38 <Ke> mental: in C i use tabs so I dont need intelligent indenting from editor, this vim autoindent I have is broken
11:51:47 <Cale> suchsuch: You get no subtyping and no inheritance, but those I consider much less essential. You can use typeclass polymorphism at the same time, but I see that as kind of orthogonal.
11:51:49 <Eduard_Munteanu> Are monads usable for encapsulation? I mean even for immutable stuff.
11:51:56 <Eduard_Munteanu> s/usable/good/
11:51:59 <jmcarthur> Berengal: lazily?
11:52:00 <Berengal> jmcarthur: There are many ways of writing functions and bindings that are semantically equal, but operationally different
11:52:05 <Cale> Eduard_Munteanu: I don't understand the question.
11:52:49 <Eduard_Munteanu> Cale, I mean they're often used to encapsulate the "world" and mutable stuff. Is it also a good idea to implement OOP-style encapsulation using monads or similar structures?
11:53:00 <Cale> Eduard_Munteanu: Monads are a style of library/API design, basically -- it effectively just says that you have an implementation of operations of a certain "shape". That's really all there is to it.
11:53:04 <Berengal> jmcarthur: `\x y -> let bar = foo x in bar y' vs `\x -> let bar = foo x in \y -> bar y' for example
11:53:34 <jmcarthur> Berengal: would i be able to make a list type using church encoding, apply a tail function to it, and expect the head to be garbage collected?
11:54:05 <Berengal> jmcarthur: I don't know about that...
11:54:08 <Cale> Eduard_Munteanu: Encapsulation in Haskell is mostly covered by the module system, though my method of representing objects also does it to some extent.
11:54:16 <jmcarthur> Berengal: that's the kind of thing i'm wanting
11:54:48 <Eduard_Munteanu> Yeah, I'm not sure making things truly private is worth it. Better label them as such and don't bother to actually deny access to them.
11:54:49 <djahandarie> jmcarthur, luckly for you Haskell has all sorts of kinds!
11:54:52 <Philonous> Cale: So would you describe type classes to somewhat resemble the esence of OOP, since they describe data in terms of what you can do with it, but hiding it's actual structure?
11:54:55 <Cale> (because once you've constructed an object by calling a function with some parameters and getting a record of functions, it's impossible to tell with which parameters that function was called)
11:54:59 <pvdbrand> hello
11:55:04 <Berengal> jmcarthur: It might be possible, but I can't rightly imagine how it'd look. I'm pretty sure it would look rather ugly if possible...
11:55:15 <Eduard_Munteanu> Cale, I see.
11:55:19 <jmcarthur> Berengal: that is my suspicion as well
11:55:31 <Cale> Philonous: Well, typeclasses classify *types* according to the operations they support.
11:56:24 <Berengal> Type classes are an overloading mechanism
11:56:26 <Cale> Philonous: When you make something an instance of Eq, it's not like you're saying that values of that type are entirely characterised by how they react to the (==) operator (that doesn't even really make good sense).
11:56:39 <ksf> Cale, doesn't that make them kinds?
11:56:48 <pvdbrand> I'd like to write a small library which provides reading and writing of CSV files, with the ability to (de)serialize a data object to/from a single row in the CSV file. I have a feeling I can use Data.Data for that, but can anyone give some more specific pointers? I don't really grok the haddock docs of Data.Data...
11:56:49 <Cale> ksf: They are sort of like kinds.
11:57:10 * Berengal thinks of type classes as imaginary kinds
11:57:11 <Cale> ksf: Just not in Haskell. If Haskell had a richer kind system, we might not want typeclasses.
11:57:20 <Cale> (or maybe typeclasses would be part of it)
11:57:23 <Berengal> So kinds and type classes together are complex
11:57:59 <koeien37> pvdbrand: The library csv exists, and provides a good way to read & parse csv files
11:58:18 <Cale> It's common to think of kinds as partitioning the things at the type level into disjoint sets, and typeclasses don't do that.
11:58:30 <koeien37> you will get a list of list of Strings though, you will need to write the mapping [String] <--> your data type
11:58:41 <Cale> (though with the simple subkinding in GHC, that's not quite true)
11:58:42 <pvdbrand> koeien37: thanks, I know of it and have used it. Besides some issues, it doesn't provide the serialize/deserialize functionality
11:58:48 <koeien37> pvdbrand: correct
11:59:31 <Cale> Now, where was I... right.
12:00:24 <Berengal> pvdbrand: serialization can be considered outside the scope of a csv parsing library. It's not too hard to just plug in the default read/show mechanism, or some other mechanism if that's what you want (you just have to be careful about escaping any separators)
12:00:41 <koeien37> pvdbrand: I don't know the answer to your other question. I am not sure it can be done easily. but it's probably somewhat doable, with gunfold or so.
12:01:12 <ksf> Cale, yes, if typeclasses would have to be disjoint, we would need inheritance.
12:01:25 <Cale> There is a relationship between typeclasses and this style of OOP, in that you can construct typeclasses of operations, and then build existential types like  data SomeFoo where SomeFoo :: (Foo a) => a -> SomeFoo
12:01:30 <ksf> ...or some other kind of hierarchy.
12:01:46 <pvdbrand> Berengal: that's right, strictly speaking it's outside the scope of csv parsing, so let me restrict my question to just (de)serializing :)
12:01:51 <Cale> and that amounts to something very very similar to just packaging up the operations
12:02:02 <Cale> (using a plain old record type)
12:02:17 <Cale> There are advantages to each style.
12:02:46 <Cale> Values of type SomeFoo are indeed entirely characterised by how they respond to the operations in the Foo typeclass though.
12:02:58 <Cale> (that's the point of existential types)
12:04:08 <pvdbrand> I know happstack serializes objects, but uses template haskell for it
12:04:17 <Cale> The SomeFoo data constructor forgets/encapsulates the specific datatype, leaving only the interface.
12:04:17 <pvdbrand> happstack state that is
12:04:51 <koeien37> pvdbrand: what exactly did you have in mind?
12:04:54 <Philonous> Cale: Whenever we have a function like "(Foo x) => x -> y" we already project out the actual type of the data we receive. We don't need to invoke existentials explicitly there.
12:05:17 <koeien37> data X = X a b   ["csv1", "csv2"] -> X (read "csv1") (read "csv2")
12:05:29 <Cale> Philonous: well, yes, I suppose you can look at polymorphic parameters that way
12:05:48 <Cale> Philonous: In the body of such a function, the parameter effectively has an existential type
12:06:56 <Cale> Philonous: But you can't do things like make lists of differently constructed values supporting the same interface that way
12:07:41 <pvdbrand> koeien37: something like: data MyObject = {x: Int, y: String}; myListOfObjects = csv.read(myFile) :: [MyObject]
12:07:55 <Cale> But it's a good point, there's a little hint of OO going on every time we write a function like that.
12:08:10 <Philonous> Cale: I wonder why. I don't see why "foo :: [forall x . Show x ]" shouldn't make sense
12:08:20 <Cale> That would be something different
12:08:53 <Philonous> "Show x => x" even
12:08:55 <Eduard_Munteanu> Wow, I'm looking at comonads and they seem to be usable as hidden data processors.
12:08:58 <Eduard_Munteanu> Is this correct?
12:09:23 <Eduard_Munteanu> You have a monad which hides some state, and a comonad which somehow processes that state.
12:09:40 <Cale> [forall x. Show x => x] would mean the type of lists of values all of which can be treated as *any* showable type.
12:09:51 <Cale> (which is basically nothing except undefined)
12:10:13 <pvdbrand> koeien37: preferably I'd like to write this kind of code without having to write tedious parsing functions for each type of object I want to read/write, just derive from Data, Typeable or something
12:10:28 <koeien37> pvdbrand: yeah I see what you want. Unfortunately I don't know how to do that myself :(
12:10:36 <Eduard_Munteanu> For example, consider stuff that operates on a Maybe as it is.
12:10:38 <joe1> :browse System.IO
12:10:49 <joe1> > :browse System.IO
12:10:50 <Cale> Eduard_Munteanu: 'hiding state' doesn't really correspond with how I think about monads...
12:10:50 <lambdabot>   <no location info>: parse error on input `:'
12:10:51 <Philonous> Cale: ah, right. So it would need to be exists x
12:10:55 <joe1> > browse System.IO
12:10:56 <lambdabot>   Not in scope: `browse'Not in scope: data constructor `System.IO'
12:11:00 <joe1> > System.IO
12:11:01 <lambdabot>   Not in scope: data constructor `System.IO'
12:11:13 <joe1> :ind FilePath
12:11:14 <joe1> > :ind FilePath
12:11:15 <lambdabot>   <no location info>: parse error on input `:'
12:11:20 <joe1> > ind FilePath
12:11:21 <lambdabot>   Not in scope: `ind'Not in scope: data constructor `FilePath'
12:11:26 <joe1> :ind FilePath
12:11:38 <joe1> @hoogle FilePath
12:11:38 <lambdabot> module System.FilePath
12:11:38 <lambdabot> Prelude type FilePath = String
12:11:38 <lambdabot> System.IO type FilePath = String
12:11:44 <Eduard_Munteanu> :t (>>=) . (=>>)
12:11:45 <lambdabot> Not in scope: `=>>'
12:11:50 <Eduard_Munteanu> Bah.
12:12:09 <Eduard_Munteanu> Aren't there Comonads in Prelude?
12:12:20 <Cale> no
12:12:37 <Cale> Not even in the libraries which come with GHC
12:12:45 <kmc> category-extras has them
12:12:54 <Eduard_Munteanu> Cale, is it worth taking a look at comonads?
12:13:10 <Cale> Yes, though relatively few good examples for programming are known.
12:13:20 <Eduard_Munteanu> I see.
12:13:22 <kmc> [exists x. Show x] would be a useful type
12:13:28 <kmc> but you can't write existentials "in line" like that
12:13:28 <Cale> One beautiful insight is that evaluation of cellular automata is comonadic.
12:13:35 <pvdbrand> koeien37: I just found the 'scrap more boilerplate' paper which talks about (de)serialization in the abstract. So I'm off to read it now :)
12:13:49 <Cale> and to explain what I mean by that, let me introduce my favourite comonad
12:13:57 <kmc> you have to declare a new data type, and to do that we (somewhat confusingly) use "forall" in a different position rather than "exists"
12:14:03 <Cale> Do you happen to know what a monoid is already?
12:14:16 <Eduard_Munteanu> Cale, mathematically, yes.
12:14:24 <dansa> ``monad'' comes from ``monoid''?
12:14:27 <Cale> Eduard_Munteanu: Okay, so same thing in programming :)
12:14:29 <kmc> dansa, no
12:14:32 <Cale> dansa: monoid and triad
12:14:37 <kmc> ah
12:14:38 <jmcarthur> Eduard_Munteanu: comonads seem to mostly come up when you are uniformly applying some operation to a zipper-like structure, at least in my experiences
12:14:50 * dansa will look up what a triad is
12:15:00 <dolio> And yet it seems to be pronounced moan-ad.
12:15:02 <Cale> dansa: It was another name for monads initially
12:15:14 <Eduard_Munteanu> Cale, so a monoid is a comonad of sorts?
12:15:14 <dansa> what? triad?
12:15:17 <kmc> dansa, i think it's just a 3-tuple of (type, return, bind)
12:15:21 <Cale> dolio: I don't use that pronunciation myself
12:15:22 <sproingie> can't seem to install 32-bit 6.12 on EL4.  getting this error: checking for path to top of build tree... ghc-pwd: timer_create: Invalid argument
12:15:28 <kmc> "a functor together with two natural transformations"
12:15:32 <kmc> and sorry that'd be join not bind
12:15:34 <dansa> kmc: i see... this makes some sense to me
12:15:36 <Cale> Eduard_Munteanu: no, but I need monoids to build the example :)
12:15:51 <dansa> join... okay; now, composition makes that into... a monoid?
12:15:57 <dansa> function-composition, that is
12:16:24 <dansa> taking that each 3-tuple as a function in the lambda-calculus way of things
12:16:24 <dolio> Cale: Well, I'm going to take Eugenia Cheng's word for it over yours. :)
12:16:39 <Cale> dansa: the analogy is that if you generalise the idea of a monoid from being a construction in the category of sets, to an arbitrary-enough sort of category with an operation on objects to replace Cartesian product on sets
12:16:54 <Cale> then monads follow that general sort of pattern in a different category
12:17:13 <Cale> Specifically, the category of functors C -> C for some category C.
12:17:19 <Eduard_Munteanu> Cale, the dual of a monoid?
12:17:27 <Cale> with composition of functors replacing Cartesian product
12:17:29 <dansa> cale, i can see the intention; but things aren't too clear for someone who knows no category theory;
12:17:39 <dansa> but aw... i need to continue this conversation in a bit later; i'm sorry for starting it up; i shouldnt have :)
12:17:39 <Eduard_Munteanu> Cale, as in dual vector space?
12:17:47 <Cale> dansa: Right, I'll describe it later
12:17:58 <Cale> dansa: (ask me sometime :)
12:18:48 <Cale> dolio: Well, it's sort of an English language issue more than anything. There's a fair amount of both pronunciations as far as I can tell, depending on accent.
12:18:57 <EvanR-work> speaking of pronouncing, what is 'automata'
12:19:13 <Cale> Eduard_Munteanu: okay, so, maybe to avoid the noise, come to #haskell-overflow :)
12:19:20 <Eduard_Munteanu> Cale, okay.
12:19:28 <dolio> Well, she says monoid with a short o, as far as I can tell. But who knows?
12:19:48 <sproingie> ah-tom-ah-tah
12:20:22 <EvanR-work> i like that one
12:20:54 <dolio> Accent on the tom.
12:21:00 <sproingie> yep.  the first 'ah' is bit more a dipthong, the second a schwa
12:21:07 <sproingie> i wouldn't know how to type either
12:21:59 <ksf> gosh english tongues just can't pronounce latin
12:22:02 <ksf> ...or greek.
12:22:36 <sproingie> go dig 'em up so they can complain
12:23:03 <sproingie> who here pronounces 'Cerberus' with a hard 'C'?
12:23:06 <ksf> it's actually the english spelling.
12:23:14 <ksf> ...no vowel means the same thing, anywhere.
12:23:42 * sproingie doesn't, just curious who goes for the "proper" pronunciation
12:23:43 <ksf> english spelling is much more a record of from where words where imported than a document of how stuff is pronounced.
12:23:59 <ksf> uh, the pope, probably.
12:24:01 <dolio> dansa: The way it's a monoid is that you have an endofunctor T, and then you have ways of multiplying TT => T (TT being T composed with itself), and of getting a unit I => T (I being the identity functor), such that going IT => TT => T is an identity of sorts (and so is TI), and when going TTT => T, it doesn't matter which way you associate the Ts.
12:24:30 <dolio> TT => T is join, and I => T is return.
12:24:47 <dolio> And the monad laws are associativity and identity.
12:25:34 <dansa> okay; a monoid is a group without inverses then, right?
12:25:42 <kmc> yes
12:25:57 <dansa> so monads are some sort of monoids then?
12:25:59 <kmc> the best way to state the monad laws in Haskell is that (>=>) is associative and return is an identity
12:26:33 <dansa> okay; return is the element of the monoid which is its identity; can i say that?
12:26:34 <kmc> for it
12:26:53 <kmc> return is the identity for the Kleisli category of any monad
12:27:07 * hackagebot upload: uu-parsinglib 2.3.1 - New version of the Utrecht University parser combinator library (DoaitseSwierstra)
12:27:09 <kmc> the kleisli category of monad M is the category of functions of the type (a -> M b)
12:27:14 <kmc> under function composition
12:27:32 <kmc> a category is like a "typed monoid"
12:27:42 <dansa> hm; that's helpful
12:27:46 <dolio> I wouldn't talk about 'elements' of the monoid. Because these are generalized 'monoids in a (monoidal) category'.
12:27:49 <dansa> so it's a particular monoid?
12:28:06 <kmc> and in this sense, return is like a monoid's identity.  but so is "id", which is the identity of the category Hask
12:28:08 <dansa> well, every monoid has to have its elements; right?
12:28:39 <EvanR-work> what is Hask?
12:28:52 <kmc> the category whose objects are Haskell types and whose morphisms are Haskell functions
12:29:20 <kmc> "object" is a misleading term in this context -- the category objects are types, not values
12:29:26 <kmc> the morphisms are values, specifically values of function type
12:29:40 <kmc> the composition operator for the category Hask is (.)
12:29:43 <kmc> the identity is id
12:29:43 <dansa> i see; categories are a generalization of algebraic structures;
12:30:02 <kmc> and you can verify yourself that (.) is associative and "id" is a left and right identity for it
12:30:07 <jmcarthur> a generalization is many things
12:30:14 <jmcarthur> s/is/of/
12:30:47 <dolio> Monoids in a category are objects M together with morphisms I -> M (unit) and M (x) M -> M (multiplication). But I wouldn't necessarily say that the unit is an element of M, aside from the fact that you can define "generalized elements" in category theory, in which case the unit is a generalized element. :)
12:30:53 <EvanR-work> still trying to get the haskell terminology, 'a monad' is a... type class? instance? type? value of instance? ...
12:31:15 <kmc> "a monad" is a type constructor of kind * -> *, which is an instance of the typeclass "Monad"
12:31:19 <kmc> which is defined in the Prelude
12:31:25 <dolio> But category theory encourages you not to think of things as sets containing elements and such.
12:31:32 <EvanR-work> ok
12:31:42 <kmc> in Haskell terminology, that is
12:31:49 <dansa> dolio: what do they encourage us to think of them?
12:31:52 <kmc> in CT terminology, it's a functor with some additional structure
12:32:08 <EvanR-work> a monad is a functor in haskell?
12:32:18 <kmc> every instance of Monad can be made an instance of Functor in a mechanical way
12:32:24 <dolio> dansa: Opaque objects whose only defining characteristics are what operations you can perform on them.
12:32:25 <kmc> unfortunately this was not codified in the constraints
12:32:33 <kmc> but it could be if we're willing to start over building the Prelude
12:32:53 <kmc> now, the Haskell typeclass "Functor" is less general than the CT idea of functors
12:32:58 <danr> I am not sure whether I like or dislike the fact that on a productive haskell coding day, I only produce 200 lines of code.
12:33:04 <kmc> the typeclass Functor only represents endofunctors in Hask
12:33:22 <kmc> that is, a functor maps some category C to another category D, but haskell's Functors can only map Hask to Hask
12:33:23 <dansa> dolio: that sounds good; and what operations are these?
12:33:39 <jmcarthur> danr: *only*?
12:33:43 <ksf> kmc, if you're doing that, don't forget indexed applicatives+monads
12:33:52 <jmcarthur> danr: that's a lot of code in any language, IMO
12:33:59 <dolio> The morphisms/arrows are the operations.
12:34:16 <kmc> because fmap :: (a -> b) -> (f a -> f b).  each object of Hask (each Haskell type) "a" is mapped to some other Haskell type "f a", and each morphism (Haskell function) of type (a -> b) is mapped to a function of type (f a -> f b)
12:34:33 <kmc> but those are still types and functions in Hask, not morphisms in some other category
12:34:40 <dansa> dolio: such as bind and return?
12:34:43 <danr> jmcarthur: I cannot remember how many lines it were back in the days when I wrote java or C++ but closer to 1000 I think.
12:34:50 <jmcarthur> danr: !!!
12:35:00 <gwern> @wn subversive
12:35:02 <lambdabot> *** "subversive" wn "WordNet (r) 2.0"
12:35:02 <lambdabot> subversive
12:35:02 <lambdabot>      adj : in opposition to a civil authority or government [syn: {insurgent},
12:35:02 <lambdabot>             {seditious}]
12:35:02 <lambdabot>      n : a radical supporter of political or social revolution [syn:
12:35:03 <danr> jmcarthur: or maybe I just wrote worse, unterse and sloppy code back then :)
12:35:04 <lambdabot>          {revolutionist}, {revolutionary}, {subverter}]
12:35:05 <dolio> Sure.
12:35:18 <jmcarthur> danr: i do not consider a large number of lines of code to be a good thing, usually ;)
12:35:39 <dolio> In the case of sets, you can actually get back to talking about elements by defining 'elements' in terms of the external structure/operations.
12:35:45 <danr> jmcarthur: this is indeed the correct observation... :-)
12:35:45 <gwern> lines of code are not produced, they are spent; to paraphrase djikstra
12:35:58 <dansa> and the idea of monads is to isolate side effects, or it is to serialize side effects?
12:36:02 <dolio> For instance, any one-element set is a terminal object in the category of sets.
12:36:06 <danr> gwern: clever
12:36:17 <jmcarthur> gwern: yeah, i like to say "feature X costs us Y lines of code"
12:36:19 <kmc> dansa, monads are not about side effects
12:36:23 <kmc> that's only one application
12:36:28 <danr> well with that quote I'm off to bed. gnite
12:36:37 <jmcarthur> or "i am burning through X lines of code per day"
12:36:38 <ksf> the idea of monads is to join the result of applying an applicative functor
12:36:40 <ksf> :t join
12:36:41 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
12:36:47 <dolio> So you can denote a terminal object as 1. And then, a morphism 1 -> S is an element of S, in that functions from one-element sets to other sets pick out specific elements of the target set.
12:36:58 <kmc> dansa, we use monads to model nondeterminism, logical search, parsing, side effects, state, exceptions, concurrency, code generation, ...
12:37:03 <ksf> that's the single operation that makes them more powerful than applicatives
12:37:11 <kmc> the power is that each of these is described using the same uniform syntax and combinators
12:37:15 <kmc> rather than a special case for each one
12:37:21 <kmc> which is what most languages do
12:37:24 <dansa> so i could think of them is chaining operations *to be* performed?
12:37:27 <jmcarthur> kmc: more correctly, we use monads to provide a common API for those things
12:37:33 <kmc> jmcarthur, yes
12:37:47 <ksf> dansa, more like building up a graph of dependencies
12:37:47 <kmc> dansa, not all monads are even sensibly thought of as consisting of "operations"
12:38:07 <dansa> kmc, i suppose; bear with my vocabulary :)
12:38:10 <kmc> but certainly the ST or IO monad is about chaining together operations
12:38:11 <jmcarthur> :t (+.)
12:38:12 <lambdabot> forall (f :: * -> *) a. (Num a, Applicative f) => f a -> f a -> f a
12:38:15 <jmcarthur> good still around
12:38:20 <dansa> ksf, i see; i'm getting the idea
12:38:25 <kmc> the problem is, many people see the IO monad first, but it's a very atypical monad
12:38:29 <dansa> my world is essentially just i/o for now
12:38:31 <dansa> yes yes :)
12:38:36 <jmcarthur> > [1,2,3] +. [2,4] +. [1] +. [5,6]
12:38:37 <lambdabot>   [9,10,11,12,10,11,12,13,11,12,13,14]
12:38:39 <dansa> so it's okay for me to get surprised later, actually
12:38:43 <kmc> if you are just doing IO, you can ignore the theory of monads
12:38:49 <jmcarthur> monads rock
12:38:58 <jmcarthur> (that only requires applicative, though)
12:39:00 <kmc> and just think of (IO a) as an abstract datatype, which allows you to build values with return and (>>=)
12:39:08 <copumpkin> you can treat an IO do block as a single lump of imperative code
12:39:11 <copumpkin> with one caveat
12:39:19 <b_jonas> how is IO an atypical monad?
12:39:20 <ksf> heh. return.
12:39:43 <copumpkin> dansa: return is a false friend!
12:39:43 <ksf> there's been enough newbies here being confused about return not exiting the function.
12:39:52 <jmcarthur> b_jonas: it uses magical primitives and doesn't have a clear run function
12:39:59 <dansa> return to me just wraps a value in a monad
12:40:04 <kmc> b_jonas, it's one-way, it's strict, it doesn't have an easy and faithful implementation in Haskell
12:40:29 <aavogt> there is lazy IO if you want to use such primitives
12:40:31 <jmcarthur> as a monadic abstraction by itself i think it's a perfectly normal monad
12:40:34 <ksf> jmcarthur, also if the os is house?
12:40:40 <b_jonas> kmc: it doesn't have an easy implementation only because there are so many IO functions
12:40:41 <kmc> whereas Maybe is "runnable" (you can get the value out), fully lazy, and can be implemended as a monad in 3 lines of very ordinary Haskell code
12:40:41 <jmcarthur> but by introducing it first we introduce misconceptions about monads
12:41:00 <copumpkin> kmc: you can't always get a value out... it's not "copointed" :P
12:41:13 * jmcarthur just realized that ksf and kmc are different nicks
12:41:14 <b_jonas> you can easily implement IO as IdentityT IO and wrapping all the IO functions to it, and then you'll have a runMyIO :: MyIO a -> IO a function
12:41:15 <kmc> b_jonas, no, it doesn't have an easy faithful implementation because there's no portable way to do IO other than the IO monad
12:41:32 <b_jonas> kmc: then the run function will run in the IO monad
12:41:37 <ksf> jmcarthur, though should not use colour-coding
12:41:45 <ksf> ...especially if the client gets it wrong
12:41:51 <kmc> what does it mean for a function to "run in" a monad?
12:41:51 <ksf> *thou
12:42:08 <EvanR-work> kmc: returns type m a ? :)
12:42:22 <kmc> but that has no bearing on how the evaluation of the function to normal form proceeds
12:42:31 <pikhq> kmc: I'm going to guess that a function "runs in" a monad m if its final result is of type (Monad m) => m a.
12:42:33 <dansa> yeah; that is bad terminology :)
12:42:35 <b_jonas> as for you can't get a value out, you just as well can't get a value out of a state or reader monad if you don't have a starting value
12:42:44 * dansa enjoys himself
12:42:51 <b_jonas> sure, maybe is different in that respect
12:42:52 <kmc> i think it's essential to remember that functions are distinct from their return types
12:43:24 <dansa> oh, they are? haskell makes that distinction? it takes something else to sort of match a function and a type? at least in theory?
12:43:25 <copumpkin> class Monad m => CommutativeMonad m -- that's it
12:43:34 <jmcarthur> all functions are "in" the ((->) a) monad ;)
12:43:43 <b_jonas> now you could say that IO is an unusual monad becuase it doesn't have an obvious monad transformer counterpart
12:43:59 <kmc> dansa, i mean that functions of type "a -> m b" are not special.  they are ordinary functions that happen to return values in this type m
12:44:00 <dansa> what's a monad transformer?
12:44:02 <pikhq> dansa: All functions are quite distinct from the type of the value they result in when fully applied. ;)
12:44:04 <kmc> which might or mightn not even be an abstract type
12:44:11 <dansa> kmc: okay
12:44:17 <jmcarthur> b_jonas: monads don't need transformers to be perfectly fine monads though
12:44:22 <b_jonas> jmcarthur: yep
12:44:26 <dansa> pikhq: i didnt get the joke or the technical remark :)
12:44:31 <b_jonas> that's why I'm arguing that IO is a perfectly normal monad
12:44:31 <Vitka_> Is there any way to upgrade base via cabal? It says it impossible to resolve dependencies.
12:44:41 <kmc> it's silly to say that (\x -> Just (x+3)) "runs in" the Maybe monad
12:44:41 <b_jonas> or if it isn't, I at least want to think of it as such
12:45:06 <jmcarthur> b_jonas: it's fine. IO is simply misleading for beginners, that's all
12:45:08 <pikhq> dansa: foo = \_->() :: a->b is different from b.
12:45:10 <pikhq> That's about it.
12:45:15 <b_jonas> jmcarthur: oh, now that's different
12:45:18 <EvanR-work> evaluation of IO is strict, right. that makes it unusual
12:45:31 <EvanR-work> dunno if that has anything to do with monads
12:45:34 <pikhq> Oh, and s/b/()/
12:45:34 <b_jonas> jmcarthur: but is it more misleading than the other monads? I don't think so
12:45:36 <xerox> (for what it's worth, it's nice to think of  amb :: Maybe a  as an action that can fail.)
12:45:50 <copumpkin> amb?
12:45:50 <dansa> pikhq: i see what you're saying; you're saying every function has a type that ``defines'' itself
12:45:56 <pikhq> EvanR-work: IO, strictly evaluated?
12:46:00 <pikhq> Lawlwut?
12:46:04 <dansa> in the same way that 1 is an Int, a function is something else
12:46:30 <dansa> (i think i see the idea)
12:46:36 <EvanR-work> pikhq: a function that returns IO [a] will generate all of [a] even if you only want the first element
12:46:50 <pikhq> EvanR-work: Ah. Yes, yes it will.
12:46:55 <copumpkin> unless you interleave it :)
12:46:59 <dansa> but not if we had [IO a], right?
12:46:59 <c_wraith> pikhq: IO is strict unless you unsafeInterleaveIO it
12:47:14 <pikhq> Actually, it will only generate all of [a] if the function resulting in IO [a] is evaluated...
12:47:16 <EvanR-work> dansa: right, but you would have 'unexecuted actions', not values of type a
12:47:21 <pikhq> But anyways.
12:47:25 <dansa> EvanR-work: okay
12:48:02 <dansa> so im going to keep in mind that monads sort of chain things together
12:48:11 <dansa> that doesnt sound horribly wrong, does it? :)
12:48:15 <copumpkin> there's a view of monads that sees it that way
12:48:19 <c_wraith> dansa: it can be a dangerous way to look at things.
12:48:22 <pikhq> dansa: That's a primary use of monads, at least.
12:48:30 <dansa> that's okay; i should take it easy :)
12:48:30 <b_jonas> not worse than burritos
12:48:32 <pikhq> Though not the only thing you can do.
12:48:38 <c_wraith> dansa: the lazy state monad can work in a way very different from what you would expect
12:48:49 <dansa> hm... due to laziness?
12:48:53 <c_wraith> yes
12:49:05 <dansa> but dont we say that io in haskell is lazy?
12:49:17 <copumpkin> nope
12:49:22 <EvanR-work> usually isnt
12:49:26 <copumpkin> IO in haskell is controversially lazy
12:49:27 <c_wraith> IO in haskell is only lazy if it's been interleaved, like a few streaming functions do (like getContents)
12:49:29 <copumpkin> in some cases
12:49:43 <dolio> Monads are about algebraic theories, more or less.
12:49:58 <dansa> if i let b = print "aa" --- that doesnt create its side effects immediately
12:50:04 <dansa> an action is stored in b
12:50:07 <dansa> i say that's lazy
12:50:26 <c_wraith> dansa, correct.  think of it as "the >>= operator is strict"
12:50:29 <dolio> Lots of computational stuff is some kind of algebraic theory.
12:50:39 <dansa> but >>= merely chains things together
12:50:39 <copumpkin> hell yeah!
12:50:44 <c_wraith> so chaining things together is strict.
12:50:46 <dansa> it sure chains immediately
12:50:51 <dansa> right; okay :)
12:51:24 <EvanR-work> c_wraith: things? or just IO actions
12:51:28 <dansa> after i chain something together; is there an inverse thing to undo it? :)
12:51:45 <kmc> not in general
12:51:55 <dansa> okay
12:51:55 <c_wraith> EvanR-work: IO, of course
12:52:00 <dansa> but mere chains aren't side effects, right?
12:52:01 <EvanR-work> ok just checking
12:52:07 <kmc> a chain is a description of a side effect
12:52:12 <EvanR-work> dansa: not until they are 'chained' to main
12:52:14 <kmc> just like the string "send an email to the pope" is a description of a side effect
12:52:23 <dansa> once it's chained to main, it's good bye?
12:52:23 <kmc> evaluating that string doesn't send an email to the pope
12:52:24 <EvanR-work> or maybe not
12:52:27 <kmc> but "executing it" would
12:52:45 <dansa> right; okay
12:52:49 <kmc> dansa, to run a Haskell program, you 1) evaluate "main" to a value, 2) perform the side effect described by thet value
12:52:59 <dansa> right; i have that view
12:53:00 <kmc> (except these things have to happen in parallel)
12:53:09 <dansa> why in parallel?
12:53:10 <copumpkin> if a monad is a monoid object in the category of endofunctors, is there a categorical notion of a group? what would it add?
12:53:13 <b_jonas> I thought it's only 2, because performing has to evaluate it
12:53:17 <ben0x539> Not in parallel, just ideally lazily
12:53:19 <EvanR-work> dansa: because the game wouldnt happen until you quit ;)
12:53:46 <dansa> until "i" quit? :)
12:53:56 <kmc> dansa, because executing an IO action of the form (a >>= f) requires one to evaluate a function application
12:54:03 <dolio> copumpkin: Group objects also have a morphism neg : G -> G, which interacts with the identity and multiplication appropriately.
12:54:25 <dansa> kmc: but the *value* of main could be computed before the actions are executed, no?
12:54:33 <dansa> hey, by value do u mean the value  returned to the OS?
12:54:35 <copumpkin> dolio: does a group object in the category of endofunctors have any interesting properties? besides being a monad with some extra fuzz?
12:54:40 <kmc> dansa, yes, but that value is only to weak head normal form
12:54:44 <dansa> in that case, it surely needs the actions executed, right?
12:54:45 <kmc> as is all evaluation in Haskell
12:55:05 <kmc> forcing main to whnf does not perform any IO action; nor does it ensure that another evaluation to whnf will not be needed later
12:55:23 <dansa> whnf is very new terminology to me :)
12:55:46 <kmc> dansa, an expression is whnf if the outermost part of the syntax tree is not a function application
12:55:56 <monochrom> weak tagless form  <duck>
12:56:16 <dansa> kmc: i see; but i can think of any example
12:56:31 <kmc> so ((\x -> x+3) 7) is not whnf -- you can reduce it by applying the arg
12:56:41 <kmc> but (Just ((\x -> x+3) 7)) is whnf
12:56:47 <kmc> even though there's an unevaluated applicaiton "inside"
12:56:51 <kmc> because the outermost thing is a constructor
12:56:53 <dansa> well, the first case has a lambda function
12:56:59 <dansa> oh, i see
12:57:05 <dansa> constructor =/= function
12:57:10 <kmc> yes
12:57:11 <danly> thunk
12:57:16 <EvanR-work> so putStrLn 'abc' is not in whnf
12:57:17 <kmc> in Haskell evaluation is to whnf, because that's what you need in order to do pattern matching
12:57:45 <dansa> EvanR-work: agreed; putStrLn is a function
12:57:46 <elly> @hoogle unsafePerformIO
12:57:46 <lambdabot> Foreign unsafePerformIO :: IO a -> a
12:57:47 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
12:57:47 <dolio> copumpkin: I'm not sure exactly what would happen, but there'd be some kind of opposite operation.
12:57:50 <kmc> correct.  under GHC, it reduces to IO (\s -> case crazyInternalShit# "abc" of s' -> ((), s'))
12:57:55 <kmc> and that's whnfd
12:58:06 <kmc> because the outside is a constructor
12:58:17 <kmc> however, that's not part of the semantics of Haskell
12:58:48 <EvanR-work> IO (lambda thing) ?
12:58:58 <kmc> what about it
12:59:01 <dolio> copumpkin: Like, for every g : A -> T A, join (g (op (g x))) = return x, something like that.
12:59:04 <EvanR-work> in this case IO is a data constructor?
12:59:21 <copumpkin> hmm
12:59:24 <dansa> IO is a type constructor?
12:59:30 <kmc> EvanR-work, yes.  not directly related to the type constructor IO
12:59:34 <EvanR-work> ok
12:59:39 <kmc> would be more clear if they'd named it MkIO or such
12:59:41 <EvanR-work> and data constructors arent functions
12:59:42 <danly> > :t IO
12:59:43 <kmc> but it's internal anyway
12:59:43 <lambdabot>   <no location info>: parse error on input `:'
12:59:48 <jmcarthur> it's both a type constructor and a data constructor in GHC, but we don't use the data constructor'
12:59:48 <danly> doh
12:59:49 <kmc> EvanR-work, they are in many respects functions
12:59:50 <b_jonas> it's not exported so who cares
12:59:52 <Paczesiowa> why ScopedTypeVariables didn't make it into H2010?
13:00:03 <copumpkin> Paczesiowa: because very little made it into H2010
13:00:05 <sproingie> danly: you can't get at the data constructor for IO
13:00:05 <copumpkin> maybe 2011
13:00:05 <kmc> EvanR-work, but an application of a ctor is already whnf
13:00:08 <kmc> that's a key difference
13:00:34 <jmcarthur> i'm not actually sure i like scoped type variables so much. there is almost always a way to avoid it in my experiences
13:00:42 <EvanR-work> kmc: even Ctor (a+b) ?
13:00:50 <sproingie> unsafePerformIO could be seen as a, uh, "smart constructor" for IO
13:00:55 <kmc> EvanR-work, yes.  that's whnf but not "full" normal form
13:00:55 <jmcarthur> i like to avoid unnecessary extensions. maybe i have a little oleg in me
13:00:57 <kmc> sproingie, heh
13:01:01 <kmc> smart destructor?
13:01:18 <b_jonas> EvanR-work: yes (not counting banged algebraic types or newtypes)
13:01:18 <EvanR-work> kmc: Ctor (2+2) ?
13:01:50 <Berengal> kmc: dumb destructor, more like, because using it is probably dumb, and there's a large chance it'll destroy everything
13:02:45 <kmc> EvanR-work, that too
13:02:47 <kmc> is whnf
13:02:59 <EvanR-work> hmm.
13:03:22 <jmcarthur> EvanR-work: if we have data Thunk a = Thunk a ; data Strict a = Strict !a, then Thunk (2+2) is in whnf, but Strict (2+2) is not. at least, i think that is how whnf applies to constructors with strict fields
13:03:42 <kmc> whnf means "outermost thing is not an application"
13:03:44 <EvanR-work> so evaluation is a process of doing whnf, then doing something, then getting another whnf
13:03:46 <Berengal> whnf just means there's a constructor in front, which any expression containing a constructor in front trivially satisfies...
13:03:54 <kmc> sorry "not a function application"
13:04:00 <kmc> a constructor application is whnf
13:04:04 <kmc> as is a primitive value
13:04:05 <jneira> pf
13:04:16 <jmcarthur> ah i guess i fudged it a bit
13:04:25 <jmcarthur> Strict (2+2) should never happen, really
13:04:31 <jmcarthur> it should just be Strict 4
13:04:39 <kmc> you'll never have a value in heap that looks like Strict (2 + 2)
13:04:44 <jmcarthur> right
13:04:47 <kmc> if you write that expression, the value you get in heap is Strict 4
13:04:54 <kmc> not so with Thunk
13:05:04 <jneira> @pl (\x->[x])
13:05:05 <lambdabot> return
13:05:10 <kmc> however Strict (Just (2+2)) can exist
13:05:14 <kmc> because Just (2+2) is whnf
13:05:28 <kmc> a bang-field or bang-pattern only reduces to whnf
13:05:40 <sproingie> fully normal form would be Just 4?
13:05:44 <kmc> there is no universal way to reduce deeply.  you can do it with instances of the NFData class, which implement traversal
13:05:50 <kmc> sproingie, yes, no redexes anywhere
13:05:51 <EvanR-work> what about Ctor ( (\x -> -x) 2 )
13:05:55 <kmc> redex = "reducible expression"
13:06:03 <kmc> EvanR-work, also whnf.  constructor on the outside => whnf
13:06:06 <kmc> no exceptions ;)
13:06:08 <EvanR-work> ok
13:06:22 <EvanR-work> so how does this relate to evaluation of IO, or anything else
13:06:43 <kmc> it relates closely to pattern matching
13:07:01 <jneira> @pl (\x->[1]++[x])
13:07:01 <lambdabot> (1 :) . return
13:07:19 <kmc> the primitive form of algebraic pattern matching is: case e of { C1 x1 -> ...; C2 x1 -> ...; ... }
13:07:27 <kmc> where the Ci are exactly the set of constructors for the type
13:07:34 <kmc> and the xi are just variables (i.e. not nested patternsQ)
13:07:38 <kmc> patterns*
13:08:20 <kmc> and so the evaluation rule for this expression is to reduce e to whnf, so you know which constructor Ci it has, then bind xi to the inside (without reducing it further)
13:09:16 <Paczesiowa> what's the cabal option to use root dir for sources under src/ ?
13:09:28 <kmc> all of the fancy nested pattern matches can be desugared into nested uses of this construct
13:09:40 <b_jonas> and lets, right?
13:09:41 <Berengal> Paczesiowa: source-directly I think. Let me look it up...
13:09:47 <kmc> yeah lets too probably
13:10:03 <Berengal> Paczesiowa: hs-source-dir
13:10:17 <b_jonas> and some stuff for funny patterns like numeric, negated numeric, view, character, n+k
13:10:27 <taruti> Is there a decent way to handle a large number (~40) records that share field names with each other in an intelligent fashion in Haskell? Currently using structureNameFieldName but that makes the record fields very long.
13:11:00 <Berengal> taruti: type classes
13:11:27 <Paczesiowa> Berengal: thanks
13:11:33 <EvanR-work> how does haskell decide what to evaluate, if its lazy, does it choose randomly?
13:11:42 <Berengal> taruti: Possibly with some TH to generate the boilerplate...
13:11:42 <kmc> what, no
13:11:59 <taruti> Berengal: don't support record updates nicely and that would make for a lot of code. (~40 records, ~5 fields average -> ~200 instances)
13:12:01 <Berengal> EvanR-work: It needs to evaluate to do pattern matching. That's basically it.
13:12:13 <kmc> EvanR-work, when you type something at the GHCi toploop, it invokes "show" on that value
13:12:17 <kmc> which probably forces at least some of it
13:12:35 <kmc> it then invokes "putStrLn" on that string, and forces that until it gets an executable IO action.  then executes it.
13:12:50 <Berengal> taruti: That's why I suggested TH as well, and the classes could just have a function for updating as well
13:12:54 <jneira> @pl (\x->[1,2]++[x])
13:12:55 <lambdabot> ([1, 2] ++) . return
13:13:13 <EvanR-work> kmc: such as IO ()
13:13:14 <kmc> when you run a compiled program, it forces main, then executes the IO action it describes.  executing an IO action can in turn trigger further evaluation
13:13:32 <kmc> now, there is research in speculative evaluation
13:13:37 <kmc> of languages with non-strict semantics
13:13:47 <kmc> "lazy" is a strategy for implementing non-strict semantics
13:13:59 <kmc> "speculative" is another strategy, or rather a very general class of strategies
13:14:00 <Ke> so what's haskell filetype in vim
13:14:10 <Ke> or does it depend on something
13:14:21 <kmc> e.g. if you have spare CPU cores doing nothing, you might as well speculate and evaluate some stuff there in case it turns out to be useful later
13:14:29 <taruti> Berengal: isn't that basically reinventing lenses/accessors? (do they have polymorphic field support)
13:14:43 <EvanR-work> seems like when evaluating main, you will get to a form  IO action >>= (lots of stuff), so at this point it simply does the action and then continues with lots of stuff?
13:14:44 <kmc> standard GHC does not do this in a purely transparent way.  you can accomplish it by annotating your code with functions such as "par"
13:14:48 <taruti> of course if giving up record syntax using some hlist variant is also possible
13:15:26 <kmc> EvanR-work.  the rule is "to execute a >>= f:  execute a, call the result x, reduce (f x) to whnf, execute that"
13:15:40 <kmc> note that the execution rule invokes the reduction (evaluation) rule
13:15:56 <Berengal> taruti: I haven't used accessors much, but I think their main feature is composability and a uniform expression for setting and getting values. I don't think they're polymorphic.
13:16:15 <kmc> the other rule is "to execute (return x):  yield the value x without doing anything else"
13:16:21 <kmc> and then a rule for each IO primitive
13:16:31 <kmc> "to execute (putChar c):  put the char c, then yield ()"
13:16:39 <EvanR-work> kmc: so we are guaranteed to have IO something if we reduce it to whnf
13:16:45 <kmc> yes
13:16:57 <kmc> well, i'm not sure that question is answerable within the semantics of Haskell
13:17:04 <kmc> it is answerable within the implementation chosen by GHC
13:17:11 <Berengal> whnf is about evaluation, but IO is about execution
13:17:21 <Berengal> They're basically different concepts
13:17:23 <EvanR-work> it makes sense because if main is of type IO (), then there are type errors if that is not satisfied
13:17:28 <kmc> yes
13:17:48 <dolio> copumpkin: nlab says that group objects can only be defined in categories with products, which rules out groupads.
13:17:50 <kmc> within GHC, the IO type has only one constructor, so reducing any value of type (IO a) to whnf will give you something with that one constructor in front
13:18:11 <EvanR-work> which is mighty convenient
13:18:18 <kmc> in fact, in GHC, IO is a newtype, meaning that this constructor is not present in memory at runtime
13:18:26 <Berengal> IO values are programs to be executed. You can reduce them to whnf as much as you want, but nothing'll happen
13:18:44 <EvanR-work> yes
13:18:45 <kmc> in GHC, each IO action is represented in memory as a function, with the very unHaskelly property that applying it has side effects
13:18:56 <kmc> and in fact these functions get inlined and strictness-analyzed and such
13:19:19 <EvanR-work> what does strictness analysis do
13:19:23 <kmc> and the end result is that despite using an abstract categorical description of IO actions, the generated code can look very much like code generated from impure function application or imperative loops
13:19:49 <kmc> EvanR-work, if you can determine that an expression will be forced later, you might want to force it earlier to save memory or time
13:19:57 <EvanR-work> ah
13:20:00 <kmc> so you don't need to build a thunk and then force it
13:20:08 <kmc> so this is an important optimization GHC does
13:20:21 <kmc> and the fact that IO actions are not really opaque on the backend means that it can do it through imperative code as well
13:20:22 <Berengal> It can also remove bottoms
13:20:24 <Paczesiowa> what do you think about libraries such as control-monad-exception, that are split into 4 separate packages?
13:21:48 <EvanR-work> does haskell love show up in here anymore
13:22:00 <kmc> @quote HaskellLove
13:22:01 <lambdabot> HaskellLove says: your Phd supervisor is my uncle, watch out !
13:22:08 <sproingie> @seen haskellove
13:22:08 <lambdabot> Unknown command, try @list
13:22:10 <jmcarthur> while i think it's annoying to have things so split up, i like having small, simple packages when possible
13:22:14 <kmc> preflex, seen HaskellLove
13:22:15 <preflex>  HaskellLove was last seen on #haskell 3 days, 1 hour, 7 minutes and 12 seconds ago, saying: ...in the register, and then try not to give me errors and then do that and so on...
13:22:20 <elspru> hey, i'm getting a real weird error: No instance for (Num [String]) arising from a use of `fromIntegral'
13:22:26 <kmc> preflex, seen scalalove
13:22:26 <preflex>  scalalove was last seen on #haskell 36 days, 18 hours, 21 minutes and 39 seconds ago, saying: soon :)
13:22:30 <djahandarie> Uh sorry just randomly commenting on something someone said before... but wasn't there a try at higher kinded type variables in like '95?
13:22:36 <elspru> fromIntegral ( div (fromInteger bitBase) 8 )
13:22:44 <kmc> what's the type of bitBase
13:22:46 <sproingie> maybe he's become ClojureLove
13:22:54 <djahandarie> Which was from the original Wadler/Blott type classes
13:22:55 <elspru> bitBase is Integer
13:22:55 <kmc> elspru, you're calling fromIntegral on a list, directly or indirectly
13:23:19 <elspru> but i'm really now
13:23:21 <elspru> not*
13:23:21 <elspru>  bitBase = if length locativeArg > 1 then wordsToNum (tail locativeArg) ::Integer else defaultBitBase
13:23:28 <EvanR-work> i was going to say maybe he finished all the eulers
13:23:33 <elspru> wordsToNum returns an Integer
13:23:56 <gwern> we need a better name for Seqs
13:24:01 <HugoDaniel> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15841#a15841
13:24:03 <gwern> too much overlap
13:24:05 <HugoDaniel> can someone help me out with this ?
13:24:25 <gwern> and no one can remember the name - 'sequence' describes lasy lists just as well
13:24:49 <gwern> HugoDaniel: is iarray a typeclass?
13:24:58 <HugoDaniel> isn't it ?
13:25:02 <ben0x539> @hoogle IArray
13:25:02 <lambdabot> module Data.Array.IArray
13:25:02 <lambdabot> Data.Array.IArray class IArray a e
13:25:13 <kmc> it is
13:25:35 <elspru> locativeArg is a [String], but it returns an Integer
13:25:44 <elspru> er wordsToNum returns an Integer
13:25:59 <b_jonas> it's an abstract typeclass
13:26:29 <b_jonas> opaque rather
13:26:33 <knobo> Can anyone show me a realy simple example with monad transformer?
13:27:19 <HugoDaniel> b_jonas: abstract ?!
13:27:46 <Paczesiowa> there was a nice tutorial by some german guy I think
13:27:48 <HugoDaniel> so, how do i declare an unboxed immutable array of (Double, Double, Double) ?
13:29:03 <kmc> knobo, check out All About Monads
13:29:49 <kmc> HugoDaniel, do you also want the tuples to be unboxed?
13:29:56 <monochrom> knobo: try this: runReaderT "hello" (do {s <- ask; liftIO (putStrLn s)})
13:30:00 <b_jonas> HugoDaniel: not abstract, but opaque as in that it's not documented how you can define your own instances of IArray
13:30:12 <kmc> HugoDaniel, the simple thing would be to add another index to your array
13:30:15 <monochrom> The type of do {s <- ask; liftIO (putStrLn s)} is ReaderT String IO ()
13:30:15 <kmc> which ranges [0,1,2]
13:30:40 <HugoDaniel> kmc, i need indexing to be *really* fast
13:31:05 <kmc> if you use StorableArray, you can control the layout of the tuple in memory
13:31:19 <kmc> (i'd of course switch from a tuple to a custom newtype)
13:31:19 <Paczesiowa> knobo: http://www.grabmueller.de/martin/www/pub/Transformers.en.html
13:31:24 <kmc> (so you can cleanly define your own Storable instance)
13:31:27 <kmc> in particular to put them adjacent so you have cache locality
13:31:37 <gwern> hm. data.sequence was removing frmo http://www.haskell.org/ghc/docs/latest/html/libraries/base/ ?
13:31:42 <HugoDaniel> yes
13:31:58 <HugoDaniel> where can i read about storable instances ?
13:32:16 <kmc> Data.Array.Storable, Foreign.Storable
13:32:24 <monochrom> (Double, Double, Double) is boxed by definition.
13:32:30 <kmc> though, i've heard StorableArray is slower than IOUArray
13:32:30 <EvanR-work> are monad transformers useful? recommended? not considered harmful? necessary for typical applications?
13:32:30 <gwern> http://hackage.haskell.org/package/containers-0.3.0.0 <-- no haddocks! that's just great
13:32:38 <kmc> EvanR-work, quite useful, quite necessary imo
13:32:43 <HugoDaniel> kmc: "It is similar to IOUArray but slower. Its advantage is that it's compatible with C."  in the haddock of storable
13:32:44 <EvanR-work> ah
13:32:45 <kmc> EvanR-work, i usually wrap them in a newtype
13:32:50 <kmc> HugoDaniel, yes, i'm not sure how they're slower
13:32:56 <kmc> i expect cache issues to matter a lot
13:33:05 <HugoDaniel> what about uvectors ? are these faster for indexation ?
13:33:15 <kmc> so, if you represent the tupling by an additional index, you want to make sure it's the innermost index
13:33:19 <kmc> in memory layout
13:33:26 <HugoDaniel> hmm
13:33:38 <Paczesiowa> does every package have to depend on base?
13:34:08 <kmc> :k Double#
13:34:09 <lambdabot>     Not in scope: type constructor or class `Double#'
13:34:21 <gwern> Paczesiowa: I think prelude-only packages escape base
13:34:23 <monochrom> gwern: no haddock because of build failure. see the build log. didn't go very far actually.
13:34:25 <gwern> @hoogle elem
13:34:26 <lambdabot> Prelude elem :: Eq a => a -> [a] -> Bool
13:34:26 <lambdabot> Data.ByteString elem :: Word8 -> ByteString -> Bool
13:34:26 <lambdabot> Data.Foldable elem :: (Foldable t, Eq a) => a -> t a -> Bool
13:34:38 <gwern> ah, so I'll use elem from foldable on a Seq
13:35:52 <Paczesiowa> gwern: nope:/
13:36:07 <gwern> really? how do prelude users depend on base?
13:36:23 <Paczesiowa> gwern: importing base just to get Monad class sucks...
13:36:45 <Paczesiowa> gwern: and suddenly I have to worry about base version, but Monad was there from the beginning...
13:37:06 <elspru> is the not equal operator /= ?
13:37:10 <kmc> yes
13:37:13 <Paczesiowa> > 1 /= 2
13:37:14 <elspru> kk thanks :)
13:37:14 <lambdabot>   True
13:37:17 <kmc> > "not equal operator" /= "/="
13:37:19 <lambdabot>   True
13:37:44 <EvanR-work> true its not not equal
13:37:45 <kmc> > let () = (/=) in 2  3
13:37:46 <lambdabot>   True
13:38:58 <gwern> wonder what life would be like if everyone preferred to use Data.Sequence
13:39:32 <Cale> mostly slower than it needed to be
13:39:45 <monochrom> Programs would be more imperative.
13:40:20 <Cale> Data.Sequence is wonderful if you need random access, but it sucks (constant factor wise) at the operations lists are fast at.
13:41:26 <Cale> Also, I basically can't program anymore without infinite lists. ;)
13:41:57 <EvanR-work> i wish more IO stuff resulted in infinite lazy lists :(
13:42:14 <monochrom> Suppose a beginner is tasked to re-implement map for educational purpose. The imperative instinct is to "initialize" an empty list and keep "appending" answers to it. Data.Sequence fully supports it with good-enough speed. The only reason past beginners didn't do it is just because they only had Data.List which made it too slow.
13:42:16 <jmcarthur> that doesn't sound so great to me
13:42:29 <Cale> EvanR-work: hGetContents is already mysterious enough :)
13:42:59 <EvanR-work> i like hGetContents >_<
13:43:13 <jmcarthur> oleg would like to have a word with you
13:43:26 <EvanR-work> @seen oleg
13:43:27 <lambdabot> Unknown command, try @list
13:43:40 <jmcarthur> (getContents is great for little oneshot programs)
13:43:41 <EvanR-work> gelo backwards/
13:43:50 <Cale> EvanR-work: It's lovely for what it's lovely for. But if you're opening lots of files, or if you need to modify any of the files you're reading from, it's the wrong thing.
13:44:13 <Cale> It's good for more than just one shot programming.
13:44:17 <EvanR-work> i was thinking about a server
13:44:22 <jmcarthur> well, a little more
13:44:32 <jmcarthur> for a server i would never use hGetContents
13:44:43 <jmcarthur> no control over file handles, etc.
13:44:45 <Cale> Never ever use hGetContents on a socket.
13:45:06 <jmcarthur> errors silently terminate the string, no visible error at all :(
13:45:15 <Paczesiowa> speaking of Oleg, I've just run hlint on a file with typeCast definition and it suggested a change that broke the code, it didn't even compile anymore. I guess that's what you get for daring to correct His code.
13:45:17 <EvanR-work> what about exceptions
13:45:24 <Saizan> i've horror stories to tell about the old http code in happs, using hGetContents with lazy ByteStrings.
13:45:25 <knobo> monochrom: runReaderT "hello" (do {s <- ask; liftIO (putStrLn s)}) ..'t match expected type `ReaderT r m a' against inferred type `[Char]'
13:45:26 <Cale> EvanR-work: same.
13:45:38 <jmcarthur> Paczesiowa: i've noticed that hlint gets a lot wrong
13:46:18 <EvanR-work> so im guessing lazy IO is a no no
13:46:28 <Saizan> knobo: "hello" goes as the second argument
13:46:28 <Cale> EvanR-work: Not entirely.
13:46:30 <monochrom> knobo: Sorry. Correction: runReaderT (do {s <- ask; liftIO (putStrLn s)}) "hello"
13:46:37 <Cale> EvanR-work: But there are appropriate and inappropriate uses.
13:46:39 <Paczesiowa> what? laziness and  side-effect don't play along?
13:46:46 <monochrom> . o O ( The impossible has happened! monochrom made a mistake. )
13:46:55 <EvanR-work> i like my side effects indeterminate
13:49:46 <kmc> lazy IO is good for simple hacks
13:50:05 <kmc> using it in big production code is dubious
13:50:18 <knobo> why not just use lift instead of liftIO?
13:50:24 <aavogt> @type runReaderT
13:50:25 <lambdabot> forall r (m :: * -> *) a. ReaderT r m a -> r -> m a
13:50:30 <sproingie> liftIO works through any number of transformers
13:50:36 <sproingie> it's magical
13:50:40 <gwern> jmcarthur: remember, only *you* can fight hlint bugs!
13:50:51 <gwern> Paczesiowa: remember, only *you* can fight hlint bugs!
13:50:52 <aavogt> lift is shallow liftIO goes deep
13:50:58 <jmcarthur> gwern: yeah, i've been meaning to report them
13:51:05 <jmcarthur> or fix them of course
13:51:23 <EvanR-work> sure a lot of things are magical in haskell!
13:51:33 <sproingie> liftIO is more magical than most
13:51:37 <monochrom> liftIO out of habit
13:51:42 <jmcarthur> EvanR-work: it's not really magical
13:51:56 <aavogt> the IO it manipulates is magical
13:52:03 <jmcarthur> sproingie: it's no more magical than ask, tell, get, put, etc.
13:52:04 <aavogt> in non-magical ways
13:52:09 <knobo> I don't like magic. Perl is magic.
13:52:23 <EvanR-work> can i has more magic?
13:52:32 <Paczesiowa> what does this mean "There are files missing in the `ptce-0.1' package", my package installed with cabal without any problems
13:52:47 <jmcarthur> magic is fugly
13:53:53 <EvanR-work> i vim 'magic' 'very magic'
13:53:56 <EvanR-work> i like*
13:54:08 <knobo> magic is cool until you understand you are beeing fooled. Then technique becomes cool.
13:54:31 <jmcarthur> leimy: doing some hunting?
13:55:00 <leimy> job hunting yes :-)
13:55:35 <jmcarthur> have a specialty?
13:56:09 <leimy> I suppose it'd be distributed systems programming.
13:56:21 <leimy> mainly non-windows stuff.
13:56:58 * leimy has done a lot of work on MPI implementations and such
14:03:01 <ksf> stream fusion is magic.
14:03:21 <ksf> it's a trick you want to see over and over again, even if you understand it.
14:04:17 <ksf> specifically, there are three semantic categories of magic: a) the inexplicable b) the wonderful c) the metaphysical
14:04:40 <ksf> or rather aspects
14:06:00 <Dodek> hey
14:06:10 <Dodek> i'm trying to define church numerals in haskell
14:06:25 <ksf> data Num = Z | S Num
14:06:34 <Dodek> i already have a predecessor function, but i can't define minus in terms of it
14:06:47 <ksf> minus is non-total
14:06:51 <Dodek> enterprise.hs:44:23:
14:06:51 <Dodek>     Occurs check: cannot construct the infinite type:
14:06:51 <Dodek>       t = t1 -> (t2 -> t3 -> t3) -> (t4 -> t5 -> t5) -> t
14:07:06 <ksf> can you paste the code?
14:07:09 <ksf> @where hpaste
14:07:09 <lambdabot> http://hpaste.org http://moonpatio.com/fastcgi/hpaste.fcgi/
14:07:37 <Dodek> ok, wait a second, let me clean it up
14:10:40 <ksf> it doesnt' have to be spotless
14:10:56 <ksf> ...just remove the porn links and you're fine.
14:11:28 <Dodek> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15844#a15844
14:11:32 <Dodek> heh.
14:11:34 <kmc> ksf, i've usually seen it with a total minus function that clamps at 0
14:12:11 <aavogt> kmc: that breaks some laws with minus, no?
14:12:15 <kmc> oh yes
14:12:17 <Dodek> i included a dysfunctional minus function
14:12:24 <kmc> but (+) on nat is not a group anyway
14:12:27 <Dodek> it compiles cleanly without it
14:12:38 <ksf> oh
14:13:01 <aavogt> interesting variable names
14:13:18 <Dodek> they actually make sense in my native language
14:13:19 <aavogt> that's transliterated russian or similar?
14:13:29 <ksf> sounds like polish
14:13:29 <Dodek> no, it's polish.
14:14:02 <EvanR-work> you could have used actual polish letters right ;)
14:14:19 <aavogt> you can?
14:14:24 <aavogt> or they are
14:14:25 <EvanR-work> i thought haskell lets you
14:14:38 <benmachine> it does if your text editor doesn't ruin it
14:15:16 <EvanR-work> like what, with a legacy encoding
14:15:19 <ksf> mhhh. m, n and minus n m have to be of the same type.
14:15:51 <ksf> ...which is not going to work, because dec m and m can't have the same type.
14:16:04 <benmachine> EvanR-work: with a being-terrible-at-its-job
14:16:36 <EvanR-work> ill be sure not to edit haskell code with MS word
14:16:50 <ray> facepalm!
14:17:39 <ksf> which, in the end, means that you won't be able to do church in haskell without using a data type, because haskell doesn't allow recursive types because they're an error in 99.999% of the cases
14:18:06 <ray> you have to massage the type system
14:18:10 <kmc> i thought church numerals had type (a -> a) -> a -> a
14:18:15 <kmc> seems fine
14:18:18 <jmcarthur> i typically use newtypes for church encoding
14:18:21 <damd> @faq can haskell do church without using a data type?
14:18:22 <lambdabot> The answer is: Yes! Haskell can do that.
14:18:36 <Dodek> hm
14:18:46 <dolio> Church numerals have the type (forall r. r -> (r -> r) -> r).
14:18:49 <ksf> I would go for peano, as it's equivalent, anyway.
14:18:50 <Dodek> as far as i remember, ocaml allows recursive types
14:18:55 <dolio> Or flip the first two arguments.
14:18:55 <Dodek> with a special compiler switch
14:19:06 <dolio> You need the RankNTypes extension for that.
14:19:08 <ray> newtype's good
14:19:14 <kmc> > let zero f x = x; succ n f x = f (n f x); n = succ (succ (succ zero)) in n ('S':) "Z"
14:19:15 <lambdabot>   "SSSZ"
14:19:34 <jmcarthur> RankNTypes is one of my favorite extensions
14:19:42 <kmc> yes
14:20:09 <Dodek> dolio: flip arguments?
14:20:15 <Dodek> dolio: how would it help?
14:20:31 <jmcarthur> dolio just meant that it doesn't matter
14:20:50 <dolio> It doesn't really matter. But (r -> r) -> r -> r lacks canonical forms in a way.
14:21:13 <jmcarthur> although the form (r -> r) -> (r -> r) looks attractive
14:21:30 <dolio> Because \f -> f and \f z -> f z are the same numeral, but may not be considered equal unless you have eta expansion.
14:21:33 <Dodek> you think so? it looks cleaner in code
14:21:36 <Dodek> zero = id
14:21:40 <Dodek> one f = f
14:21:41 <Dodek> etc
14:21:58 <jmcarthur> :t maybe
14:21:59 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
14:22:01 <jmcarthur> :t either
14:22:02 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
14:22:10 <ksf> anyway, the proper way to implement minus on naturals is to restrain its type such that the second operand is <= the first.
14:22:20 <dolio> Of course, that doesn't really matter for something like Haskell.
14:24:00 <dolio> By contrast, \z f -> f z cannot be eta converted.
14:24:44 <ksf> really, people, keep your domains clean.
14:25:27 <ksf> there's a way to substract two arbitrary naturals in the same way as there's a way to divide by zero: by expanding the codomain.
14:25:30 <ziman> Dodek, a bit OT; you can write "dzdz = razy dziewiec jedenascie" as "dzdz = dziewiec `razy` jedenascie", that reads _much_ better :)
14:26:15 <Dodek> ziman: i know about it, i just translated this code straightly from ocaml and didn't actually bother
14:26:34 <ziman> i see :)
14:27:31 <Gracenotes> ksf: my codomain has a puppy
14:27:47 <Gracenotes> I have to keep it here, for backwards compatibility :|
14:28:13 <mental> it reads better in english, not sure aobut polish
14:28:44 <EvanR-work> after all they invented reverse polish notation
14:28:49 <ksf> we need proper natural language support for haskell.
14:28:54 <ksf> inflection, cases, stuff, you know.
14:29:15 <dolio> They invented Polish notation. Did they reverse it as well?
14:29:19 <dolio> Or was that someone else?
14:29:29 <EvanR-work> haha
14:29:35 <kmc> that's from reverse poland
14:29:36 <ziman> reverse polish notation is also known as hungarian notation, isn't it? :)
14:30:08 <ziman> ah, it is not.
14:30:11 <kmc> wouldn't equality be extensional?
14:30:19 <kmc> ziman, that's a different thing :/
14:30:27 <mental> "Factorial is a function that takes an integer and returns an integer. The factorial of a number N is equal to the product of the list of numbers from 1 to N."
14:31:12 <Ke> @hoogle (a -> IO b) -> IO [a] -> IO [b]
14:31:13 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
14:31:13 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
14:31:13 <lambdabot> Control.Monad forM :: Monad m => [a] -> (a -> m b) -> m [b]
14:31:30 <ksf> ...about as many cases as http://www.ithkuil.net/ithkuil-ch4-case.htm#Sec4o3 would about suffice for a computer language, I guess.
14:31:46 <monochrom> Haskell already has natural language support. Just switch your natural language to simple-typed lambda calculus.
14:31:55 <glguy> Ke, the "most general" function would be Data.Traversable.traverse
14:32:00 <kmc> Lojban has particles for the lambda calculus
14:32:38 <ksf> I'm not learning lojban, any time soon.
14:32:39 <glguy> oh, nevermind
14:32:47 <ksf> I'm barely managing learning toki pona
14:32:49 <glguy> I didn't see that the 2nd argument was /IO/ [a]
14:33:30 <glguy> :t fmap . fmap
14:33:31 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
14:33:46 <glguy> :t fmap . fmap ::  (a -> IO b) -> IO [a] -> IO [b]
14:33:47 <lambdabot>     Occurs check: cannot construct the infinite type: b = IO b
14:33:47 <lambdabot>     In the expression: fmap . fmap :: (a -> IO b) -> IO [a] -> IO [b]
14:33:53 <glguy> bah :)
14:34:10 <dolio> @type \f -> join . liftM (mapM f)
14:34:11 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> m [a] -> m [b]
14:34:21 <glguy> :t f m -> x >>= mapM f
14:34:22 <lambdabot> parse error on input `->'
14:34:27 <glguy> :t f m -> m >>= mapM f
14:34:28 <lambdabot> parse error on input `->'
14:34:33 <glguy> :t \ f m -> m >>= mapM f
14:34:34 <glguy> sorry
14:34:34 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> m [a] -> m [b]
14:35:04 <dolio> @type (=<<) . mapM
14:35:04 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> m [a] -> m [b]
14:36:09 <cord> how to use http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15845#a15845 ? i only get Pascal while doing mylang ? shouldn't all the injected strings get unwrapped sequentially ?
14:36:13 <sproingie> @remember monochrom Haskell already has natural language support. Just switch your natural language to simple-typed lambda calculus.
14:36:14 <lambdabot> It is forever etched in my memory.
14:36:36 <monochrom> ha
14:36:49 <ziman> @quote etched
14:36:49 <lambdabot> command says: lambdabot will say 'it is forever etched into my memory' and then forget the quote by tomorrow.
14:37:02 <kmc> cord, no
14:37:05 <kmc> that's not what return does
14:37:07 <Cale> cord: return v is the IO action which does nothing, returning v as its result.
14:37:11 <kmc> (return a >> return b) is the same as (return b)
14:37:20 <Cale> cord: The result of an do-block is the result of the last action in it.
14:37:25 <Cale> a*
14:37:57 <cord> hmmm then it's worthless to inject many actions in the do block ?
14:38:03 <kmc> i don't know what that means
14:38:10 <kmc> (return a >> return b) is useless
14:38:17 <kmc> but you may have more than one "return" within a do block, syntactically
14:38:17 <EvanR-work> cord: many actions that have no effect, yes
14:38:19 <kmc> on multiple paths
14:38:24 <kmc> e.g., (if b then return foo else return bar)
14:38:31 <kmc> though, that's the same as return (if b then foo else bar)
14:38:31 <Cale> I don't know what you mean by 'inject', but any return which is not at the end of a block can be eliminated
14:38:56 <kmc> @undo do { return "CSharp"; return "Haskell"; return "Pascal" }
14:38:57 <lambdabot> return "CSharp" >> return "Haskell" >> return "Pascal"
14:39:03 <c_wraith> Cale:  usually they would need to be moved into a let block, though.
14:39:15 <kmc> cord, i'm not clear on what you thought this code would do
14:39:24 <Cale> c_wraith: if you're capturing the result, yeah
14:39:25 <c_wraith> err, wtf.
14:39:30 <c_wraith> yes, that's what I meant.
14:39:32 <cord> i read that the word "return" ain't the appropriate word "inject" is
14:39:33 <c_wraith> wow, I confused myself
14:39:43 <DrTeggy> Nice, @undo... what an appropriate command name.
14:39:54 <Cale> cord: People have strange ideas sometimes about naming.
14:40:01 <jmcarthur> cord: return, pure, inject, point, all the same thing
14:40:06 <cord> i don't know why i got the idea that injecting many values may return generator :(
14:40:06 <kmc> cord, "return x" takes a value x, and returns an IO action which does nothing except yield x as a result
14:40:13 <monochrom> cord's IP seems to be from Egypt. Please load your universal translators.
14:40:16 <Cale> cord: Other people like the word 'pure' because it conveys less to the imperative programmer.
14:40:17 <jmcarthur> cord: what do you mean generator?
14:40:20 <EvanR-work> cord: try putStrLn instead of return
14:40:22 <kmc> cord, maybe you want to return a list?
14:40:42 <kmc> a Haskell list is a lot like a generator in other languages, because of laziness
14:40:46 <jmcarthur> cord: words "CSharp Haskell Pascal" ?
14:40:53 <kmc> but, this'd have nothing to do with the IO monad
14:41:02 <Cale> cord: Notice that return doesn't quite have the usual meaning it does in imperative languages, though it's similar in usage.
14:41:14 <kmc> mylangs :: [String]; mylangs = ["CSharp", "Haskell", Pascal"]
14:41:22 <cord> with generator, i mean to each call of mylang it yields some value
14:41:29 <kmc> you don't call mylang
14:41:32 <kmc> it's an IO action, not a function
14:41:35 <kmc> you execute it
14:41:36 <jmcarthur> cord: sounds like a list to me. with laziness you can effectively do that
14:41:43 <cord> at first call yields csharp, at the second yields haskell, .. etc
14:41:46 <jmcarthur> and it's pure!
14:41:49 <kmc> by gluing it onto other actions
14:41:52 <Cale> You don't really 'call' functions either.
14:42:01 <kmc> cord, is there a specific reason to do this as an IO action with state?
14:42:11 <kmc> the standard technique would be a list
14:42:12 <jmcarthur> cord: so for example, mapM_ putStrLn ["CSharp", "Haskell", "Pascal"]
14:42:26 <taruti> Has anyone hacked together ssh-client support for Haskell (libssh or equivalent)?
14:42:30 <ziman> cord, are you looking for an equivalent of C#'s yield?
14:42:42 <kmc> the equivalent is to just return a list :)
14:42:49 <Cale> > do "CSharp"; "Haskell"; "Pascal" -- ;)
14:42:49 <cord> ziman, yes finally
14:42:50 <lambdabot>   "PascalPascalPascalPascalPascalPascalPascalPascalPascalPascalPascalPascalPa...
14:42:56 <ziman> i think it might be put in the writer monad
14:43:10 <Cale> (sorry, that's just a distraction :)
14:43:22 <kmc> a list of three constant strings would not be a function even
14:43:25 <kmc> just... a list
14:43:29 <kmc> > ["foo", "bar"]
14:43:30 <lambdabot>   ["foo","bar"]
14:43:35 <kmc> that's a generator effectively
14:43:46 <Cale> > [0..]
14:43:47 <damd> > ["hello"] >>= ["what"]
14:43:47 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
14:43:48 <lambdabot>   Couldn't match expected type `[GHC.Types.Char] -> [b]'
14:43:48 <jmcarthur> > do l <- words "CSharp Haskell Pascal" ; return ("Language: " ++ l)
14:43:48 <lambdabot>         against infe...
14:43:49 <lambdabot>   ["Language: CSharp","Language: Haskell","Language: Pascal"]
14:43:59 <monochrom> with haskell's lazy list you don't need yield in most cases.
14:44:20 <EvanR-work> what is the point of yield
14:44:24 <jmcarthur> now you could use Cont to make your own yield, but i don't think that's necessary
14:44:24 <Cale> However, it's possible to construct a yield for a monad in which you can perform IO actions.
14:44:44 <ziman> cord, in Haskell you usually do things in a different way -- but it is doable if you insist
14:44:47 <monochrom> the point of yield is to re-live the joy of lazy list in an eager language.
14:45:13 <Cale> EvanR-work: Being able to stop an effectful computation, producing a result, and then return to the computation exactly where you left off
14:45:27 <sproingie> ContT
14:45:43 <cord> folks easy, i'm experimenting learning monads, and it came to my mind that many returns in an actions is equivalent to "yield" in the generator --C# for example. that's why i'm asking for elaborating
14:45:43 <kmc> cord, can you explain why you want this to be an IO action with state rather than a list?
14:45:54 <kmc> ah
14:45:59 <kmc> well, many returns in an action is not equivalent to yield
14:46:03 <Cale> cord: The short answer is that it's just not
14:46:06 <EvanR-work> seems like a wierd way to do a list, continuation, or a regular generator function
14:46:11 <kmc> you could make a monad with a "yield" function that's *like* yield
14:46:15 <kmc> but it would not be "return"
14:46:17 <sproingie> cord: in haskell you just return the entire list.  you can think of 'yield' as being built-in
14:46:19 <kmc> which is shared by all monads
14:46:34 <ziman> > snd . runWriter $ do { tell ["Haskell"]; tell ["Fortran"]; tell ["Java"] }
14:46:35 <lambdabot>   ["Haskell","Fortran","Java"]
14:46:36 <kmc> cord, a monad with this yielding property would be the Writer monad
14:46:42 <kmc> ^^^^ what ziman just said
14:46:49 <kmc> here it's called "tell"
14:47:06 <Cale> I'm not sure that's an appropriate interpretation, though it does cover some of the same applications.
14:47:11 <kmc> cord, http://haskell.org/ghc/docs/6.10-latest/html/libraries/mtl/Control-Monad-Writer-Lazy.html
14:47:19 <monochrom> > take 3 (snd . runWriter $ forever (tell ["Haskell"]))
14:47:20 <lambdabot>   ["Haskell","Haskell","Haskell"]
14:47:25 <kmc> cord, http://www.haskell.org/all_about_monads/html/writermonad.html
14:47:26 <Cale> (even with the lazy writer)
14:47:29 <ziman> it's lazy! :)
14:47:34 <kmc> (the latter is probably more usefl)
14:47:55 <sproingie> > take 3 (snd . runWriter $ forever (tell ["Marcia"]))
14:47:56 <lambdabot>   ["Marcia","Marcia","Marcia"]
14:48:03 <cord> thanks, checking ... :)
14:48:20 <kmc> cord, but this "tell" is a property of only some monads
14:48:26 <kmc> not of all monads in general
14:48:28 * EvanR-work takes note. if he needs a shiton of answers at all once he needs to ask the question at 4:45pm on wednesday (local time) ;)
14:49:09 * sproingie GGGRRRRYYYYAAARRRRRGHH!!!
14:49:17 <sproingie> sorry that was just me trying to get ghc on RHEL4
14:49:24 <aavogt> @quote stereo
14:49:24 <lambdabot> omnId says: geez, how many metastereo quotes are going to be @remembered?  >_>
14:49:26 <blobl> anyone knows what on earth is Trace/BPT trap ?
14:49:28 <kmc> sproingie, hahaha
14:49:31 <lpsmith> Is HaskellDirect usable in it's current state?
14:49:31 * kmc did that
14:49:32 <monochrom> @quote fugue
14:49:32 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
14:49:34 <cord> it appears the next "The Continuation monad" is it like continuation in scheme ?
14:49:42 <monochrom> fugue is more accurate
14:49:43 <kmc> cord, yes
14:49:47 <kmc> it has callCC
14:49:49 <kmc> :t callCC
14:49:50 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
14:49:56 <kmc> cord, but it's much less used in Haskell
14:49:58 <sproingie> gotta go back to 6.6, build 6.10 with it, upgrade make, god only knows what else
14:50:04 <aavogt> monochrom: also some kind of mental state too
14:50:09 <kmc> because laziness provides a conceptually simpler way to do many of the things that schemers do with continuations
14:50:19 <sproingie> i gave up because i just *know* deep down there are probably deadly bugs in the RTS on such ancient glibc versions
14:50:29 <blobl> sorry guys, anyone knows what Trace/BPT trap is ?
14:50:39 <cord> kmc, thanks!
14:50:50 <cord> catch up later, and thanks for the help everyone
14:50:53 <kmc> cord, and it's not like scheme call/cc in that you can't get the current continuation anywhere, only within a continuation monad.  it's more like syntactic sugar over a continuation-passing style transformation
14:51:54 <Cale> blobl: context?
14:52:14 <sproingie> ContT can create truly mind-bendy code
14:52:40 <monochrom> for example http://www.vex.net/~trebla/haskell/ContMonad.lhs
14:52:55 <sproingie> tho not quite as surprising as scheme's uses since if you're not in the Cont monad, you know you're not going to get jumped with it
14:52:55 <Cale> It can, if you abuse it, but mostly it's pretty straightforward if used appropriately.
14:53:00 <monochrom> but I didn't add a yield example to it.
14:53:23 <blobl> Cale: im in ghci, trying to load a module that used to work that downloads a url, now i get this while it loads the other modules needed. pretty weird
14:53:28 <sproingie> call/cc is basically functional GOTO
14:54:02 <monochrom> OTOH I have a contrived example of delimited continuation providing mutable cell. I just haven't posted it.
14:54:14 <sproingie> ooh i could use that
14:54:32 <monochrom> It is just fun to watch. It has to be inefficient.
14:54:35 <sproingie> well actually i just use IOrefs
14:54:41 <sproingie> much more efficient
14:54:57 <benmachine> is this basically implementation of State in terms of Cont?
14:55:36 <Cale> blobl: It seems to be the message which is printed when a program dies because it receives a SIGTRAP that it doesn't handle.
14:55:44 <sproingie> sic transit my quest to port my perl one-offs to haskell
14:55:52 <sproingie> at least if i can't trust ghc on EL4
14:55:52 <monochrom> In a nutshell, you begin by hiding the cell at the bottom of the stack. Then every time you use it, you have to spend n steps walking the stack to find it, if your stack is currently n units high. You're really better off adding StateT.
14:56:56 <Cale> blobl: Which library are you using?
14:57:23 <blobl> cale: it dies before loading http last version.
14:58:11 <Cale> blobl: which ghc version?
14:58:45 <Cale> If you want, I could try it on 6.10.4.
14:59:29 <roostaj> @src mapM
14:59:29 <lambdabot> mapM f as = sequence (map f as)
14:59:30 <Cale> I'm pretty sure I've written stuff which uses HTTP successfully.
15:00:07 <roostaj> @src forM
15:00:07 <lambdabot> forM = flip mapM
15:00:30 <blobl> cale: i got 6.10 too.
15:01:59 <blobl> cale: ya i believe that. ive used the very same module again. that is the weird bit :D
15:03:29 <blobl> cale: well now.. i am getting segmentation fault :D
15:03:52 <blobl> cale: the devil is after me. thanks anyway
15:04:28 <EvanR-work> your wife?
15:05:34 <blobl> when you compile a module that uses http, the http's module code is in the object file created or not? as in that version's of http you had when compiled the module
15:06:59 <holmak> What is the difference between the transformers and mtl packages?
15:07:05 <holmak> Should I prefer one over the other?
15:08:00 <HugoDaniel> is it possible to use uvector with any other datatype thats not already an instance of the type class UA ?
15:08:15 <HugoDaniel> i mean... just look at that class...
15:08:46 <HugoDaniel> im finding it extremely hard to use unmutable arrays in haskell...
15:09:17 <monochrom> blobl: If you turn off optimizations, no. If you turn on optimizations, sometimes yes because of inlining.
15:09:55 <HugoDaniel> ..and about to start coding this part of my code in C :/
15:10:19 <xerox> ...and then FFI it :)
15:10:38 <HugoDaniel> xerox: it would proabably be done by now...
15:10:47 <taruti> HugoDaniel: what is the type of data you need?
15:10:50 <blobl> i see.. havent done it that way back then. cool. im gutted :D
15:10:56 <HugoDaniel> (Double, Double, Double) :)
15:11:19 <EvanR-work> HugoDaniel: three things? just Array would work
15:11:31 <EvanR-work> or arrays of triplets
15:12:00 <HugoDaniel> its only 256 elements, but i need the indexing to be fast
15:12:16 <EvanR-work> whats wrong with Array
15:12:21 <c_wraith> HugoDaniel: are the values ever going to be changed, or is this just a lookup table?
15:12:30 <HugoDaniel> just a lookup
15:12:42 <c_wraith> Array should be fine, then
15:12:50 <HugoDaniel> they are not going to be changed, thats why i thought of unmuttable arrays
15:13:03 <taruti> HugoDaniel: 1) make modular code, 2) just use a simple Array, 3) if it becomes an issue you can change it later.
15:13:07 <sproingie> holmak: i would use mtl
15:13:37 <taruti> isn't there supposed to be a transition from mtl to transformers
15:13:55 <HugoDaniel> isnt the indexation slower on Array than on uvector ?
15:13:59 <c_wraith> No
15:14:10 <c_wraith> @src Ix
15:14:11 <lambdabot> class (Ord a) => Ix a where
15:14:11 <lambdabot>     range           :: (a,a) -> [a]
15:14:11 <lambdabot>     index           :: (a,a) -> a -> Int
15:14:11 <lambdabot>     inRange         :: (a,a) -> a -> Bool
15:14:11 <lambdabot>     rangeSize       :: (a,a) -> Int
15:14:32 <HugoDaniel> what about the boxing ?!
15:14:40 <taruti> @type unsafeAt
15:14:41 <lambdabot> Not in scope: `unsafeAt'
15:14:46 <HugoDaniel> the boxing adds a pointer to indexation
15:14:49 <c_wraith> There's some overhead in the boxing, sure.  But you shouldn't care.
15:14:54 <taruti> @type Data.Array.unsafeAt
15:14:55 <HugoDaniel> thus making it slower than unboxed arrays... right ?
15:14:55 <lambdabot> Not in scope: `Data.Array.unsafeAt'
15:15:04 <c_wraith> Array lookups aren't going to be the slow part of whatever you're doing
15:15:13 <HugoDaniel> c_wraith: they are
15:15:14 <HugoDaniel> :)
15:15:40 <c_wraith> also, if you're not storing a primitive type, you have no choice but to box.
15:15:40 <HugoDaniel> its an immutable 256 entries array
15:15:44 <taruti> HugoDaniel: well if you want the last ounce of performance you can just use a IOUArray Int Double
15:15:48 <monochrom> I don't like the way it is first said "indexing needs to be fast" and then switch to boxing issues.
15:16:31 <taruti> HugoDaniel: just flatten your (Double,Double,Double) to three elements in the array if boxing is an issue
15:16:37 <HugoDaniel> by indexation i mean reading the values at random positions...
15:16:51 <monochrom> "access"
15:16:58 <EvanR-work> that is fast in all array types
15:17:11 <HugoDaniel> hmm
15:17:33 <c_wraith> Sure, boxed types give you issues with being non-local in the cache
15:17:37 <taruti> most of the time boxing is not an issue. if it is you can manually flatten your types.
15:17:52 <HugoDaniel> hmm ok
15:18:04 <c_wraith> But I'm almost certain arrays lookups aren't going to be the slow part of your program.
15:18:14 <HugoDaniel> ill add a padding 0, so i can use 256*4 and bit shifting to index values
15:18:27 <HugoDaniel> c_wraith: do you know what im doing ?
15:18:35 <c_wraith> Doesn't matter.  Array lookups aren't slow.
15:18:35 <monochrom> Have you benchmarked this yet?
15:18:40 <c_wraith> IO is slow.
15:18:48 <c_wraith> IO is likely to be your bottleneck.
15:18:59 <HugoDaniel> i wont have IO
15:19:11 <HugoDaniel> all the functions in this module are pure
15:19:14 <c_wraith> then your program isn't doing anything.
15:19:20 <taruti> IO is not necessarily slow ;)
15:19:23 <HugoDaniel> ...this is a module
15:19:58 <c_wraith> benchmark first.  after that shows that array lookups are your slow point, then come and tell me you told me so. :)
15:20:36 <sproingie> i'm using IOUarray myself because it's smaller, not for the speed
15:20:58 <c_wraith> I can't help but read that as an array of debts
15:21:07 <sproingie> overhead on a 500x500 array adds up
15:21:56 <blackh1> IO is not slow
15:22:21 <taruti> speaking of arrays is there a variant that allows for semilazy initialization?
15:22:33 <c_wraith> taruti: just use fromList
15:22:44 <monochrom> how semilazy is semilazy?
15:22:51 <sproingie> the IO scheduler is a little dinky, brian o'sullivan's working on fixing that
15:23:02 <sproingie> er bryan
15:23:02 <EvanR-work> HugoDaniel: im thinking that if you need unboxed, you would use UArray. and since its all the same interface anyway, whatever problems you are having need to be solved first
15:23:19 <taruti> I want a huge "Array Int (TVar Foo)" and would like to avoid the cost of initializing it all at once.
15:23:21 <c_wraith> I don't mean that IO underperforms.  I mean that talking to the real world is slow, compared to anything that stays in memory.
15:23:33 <c_wraith> taruti:  use fromList
15:23:38 <HugoDaniel> EvanR-work: ill use a UArray of Double
15:23:51 <roostaj> @src do
15:23:51 <lambdabot> Source not found. It can only be attributed to human error.
15:24:14 <HugoDaniel> with padding 0's, and bitshifting to index it
15:24:28 <HugoDaniel> im not so sure how to bitshift in haskell yet...
15:24:35 <EvanR-work> HugoDaniel: there, now youre coding in c. you should be happy now ;)
15:24:36 <monochrom> Then no.
15:24:38 <c_wraith> @hoogle shiftR
15:24:38 <lambdabot> Data.Bits shiftR :: Bits a => a -> Int -> a
15:25:37 <taruti> c_wraith: ok, I'll try that.
15:26:39 <EvanR-work> HugoDaniel: since you cant use (double, double, double), have you tried a Data structure with four doubles?
15:26:57 <HugoDaniel> no
15:27:14 <HugoDaniel> EvanR-work: so what do you recommend, IntMap ?
15:27:25 <EvanR-work> an array
15:27:29 <EvanR-work> lookup table = array
15:27:41 <EvanR-work> and i just checked, you cant use data structures with unboxed
15:27:47 <EvanR-work> >_<
15:27:50 <EvanR-work> no c for you
15:27:53 <sproingie> if you think the flavors of array are too slow, any of the Maps are going to be a heartbreak
15:29:19 <EvanR-work> lookup in IntMap is something like O(log(n)), not O(1)
15:29:53 <HugoDaniel> well... if its a very slow 1 and a very fast log(n) :P
15:30:16 <sproingie> it's slower, believe me
15:30:38 <EvanR-work> lets through an education in computer science out the window ;)
15:30:47 <sproingie> one of the shootouts has a reasonably fast hash table.  no idea what the collision rate is like
15:30:47 <EvanR-work> and english spelling along with it
15:30:48 <HugoDaniel> :D
15:31:57 <sproingie> all those 'u's in "English" spelling came from the french
15:31:59 <Eduard_Munteanu> I remember having seen an infix operator for the Kleisli arrow.
15:32:04 <Eduard_Munteanu> Anyone knows it?
15:32:07 <Eduard_Munteanu> I can't find it.
15:32:08 <sproingie> no idea England was still a subject of Le Francais
15:32:14 <EvanR-work> for IntMap it actually says lookup is O(min(n,W)). *scratches head*
15:32:34 <c_wraith> IntMap is not a binary search tree.
15:32:46 <EvanR-work> whats W
15:32:48 <sproingie> what's W?
15:33:02 <HugoDaniel> width
15:33:46 <EvanR-work> what kind of map is this >_<
15:33:56 <c_wraith> it's a trie
15:34:03 <Eduard_Munteanu> Umm... isn't O(min(n, W)) = O(n) ?
15:34:13 <c_wraith> not if W < n
15:34:23 <EvanR-work> and isnt O(n) comparible to checking through a regular list
15:34:26 <Eduard_Munteanu> It's asymptotic, so why would it matter?
15:35:19 <sproingie> without knowing how W is computed, it's hard to say
15:35:20 <Eduard_Munteanu> I can understand O(n x m), but min?
15:35:34 <Eduard_Munteanu> sproingie, well, I suppose they're independent.
15:35:39 <c_wraith> Eduard_Munteanu: if W is not a function of n
15:35:46 <EvanR-work> im just wondering why IntMap is better than a list of pairs
15:35:48 <taruti> W is constant
15:35:55 <dibblego> is there a library for load testing websites?
15:36:00 <Eduard_Munteanu> Then it's O(1)
15:36:13 <tibbe> Does an unboxed tuple (# a, b #) act like like a strict tuple PairS = PS !a !b when it comes to strictness?
15:36:14 <Eduard_Munteanu> because asymptotically, n < W for W const.
15:36:15 <taruti> Eduard_Munteanu: for suitable values of 1 ;)
15:36:22 <Eduard_Munteanu> Heh :).
15:36:33 <sproingie> 1 + 1 = 3 -- for large values of 1
15:36:59 <Eduard_Munteanu> sorry, n > W
15:37:10 <Eduard_Munteanu> still O(1)
15:37:25 <c_wraith> > let 1 + 1 = 3 in if 1 + 1 == 3 then "these are large values of one" else "nevermind"
15:37:26 <lambdabot>   "these are large values of one"
15:38:18 <Eduard_Munteanu> > let 2 = 3 in show 2
15:38:19 <lambdabot>   "2"
15:38:24 <Eduard_Munteanu> > let 2 = 3 in 2
15:38:25 <lambdabot>   2
15:38:26 <theclaw> I'm having some problems with haskell's syntax. what's wrong with this code? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15848#a15848
15:38:32 <Eduard_Munteanu> How does that work? :)
15:38:44 <damd> theclaw: what are you trying to do?
15:38:52 <theclaw> err, missing semicolon :(
15:39:23 <theclaw> damd: I have to generate haskell code for a project, and have to know what I'm allowed to do an what not
15:40:46 <c_wraith> theclaw:  typically, haskell is easier if you don't use {} and ;
15:40:55 <sproingie> Eduard_Munteanu: let 1 + 1 = 3 works because it's redefining (+)
15:41:03 <sproingie> > let 1 + 1 = 3 in 2 + 2
15:41:04 <lambdabot>   * Exception: <interactive>:1:157-165: Non-exhaustive patterns in function +
15:41:06 <Eduard_Munteanu> sproingie, oh, thanks.
15:42:19 <theclaw> c_wraith: yes, I just want to know what's allowed :)
15:42:30 <Eduard_Munteanu> let False == True == True in show (False == True)
15:42:33 <Eduard_Munteanu> > let False == True == True in show (False == True)
15:42:34 <lambdabot>   <no location info>: parse error on input `in'
15:43:26 <sproingie> you've got two =='s in there
15:43:36 <Eduard_Munteanu> Yeah, I was checking if that could work.
15:43:46 <Eduard_Munteanu> I was going to redefine == :)
15:43:53 <Eduard_Munteanu> sproingie, oh
15:43:57 <sproingie> > let False == True = True in False == True
15:43:58 <lambdabot>   True
15:44:06 <Eduard_Munteanu> Dang :)
15:44:37 <Eduard_Munteanu> So anybody remembers if there was a symbol (infix operator) for the Kleisli arrow, like for >>=?
15:44:40 <sproingie> that's small enough that you could invert all logic, yes
15:45:14 <Veinor> @quote
15:45:15 <lambdabot> Igloo says:  Did hugs' ./configure always end with "config.status: executing ultra-evil commands"?
15:45:17 <glguy> >=>
15:45:26 <Eduard_Munteanu> :t >=>
15:45:27 <lambdabot> parse error on input `>=>'
15:45:31 <Eduard_Munteanu> :t (>=>)
15:45:32 <sproingie> :t (>=>)
15:45:32 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
15:45:33 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
15:45:42 <sproingie> it's compose for kleisli arrows
15:45:43 <Veinor> @src (>=>)
15:45:43 <lambdabot> Source not found. Take a stress pill and think things over.
15:45:48 <Eduard_Munteanu> glguy, thanks
15:45:59 <Eduard_Munteanu> sproingie, so no Kleisli arrow operator alone?
15:46:12 <sproingie> 'return'
15:46:15 <Eduard_Munteanu> sproingie, or is that just lift?
15:46:17 <Eduard_Munteanu> Oh.
15:46:22 <sproingie> :t return
15:46:23 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
15:46:33 <Eduard_Munteanu> Hm, nice, thanks.
15:46:44 <Eduard_Munteanu> :t liftM
15:46:45 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
15:48:00 <Eduard_Munteanu> :t return . (\f x -> f x)
15:48:01 <lambdabot> forall (m :: * -> *) t t1. (Monad m) => (t1 -> t) -> m (t1 -> t)
15:48:35 <sproingie> @pl (\f x -> f x)
15:48:36 <lambdabot> id
15:49:06 <sproingie> sometimes masquerading as $
15:49:29 <Eduard_Munteanu> :t (\f x -> f x)
15:49:30 <sioraiocht> I have a multiparameter type class that has class a f where...
15:49:30 <lambdabot> forall t t1. (t -> t1) -> t -> t1
15:49:34 <Eduard_Munteanu> :t id
15:49:35 <lambdabot> forall a. a -> a
15:49:44 <sioraiocht> and I have instance [a] (F a) where...
15:49:46 <Eduard_Munteanu> Oh yeah, it takes second order stuff.
15:50:19 <sioraiocht> and I am getting the error message no instance typeclass [Integer] (F a)
15:50:53 <sioraiocht> is haskell not smart enough to see that the type variable a scopes over BOTH of those?
15:51:50 <Saizan_> it does see that
15:52:00 <sproingie> FlexibleInstances maybe?
15:52:05 <Saizan_> but at the point where it should pick the instance
15:52:13 <Saizan_> you're not telling it that a = Integer
15:52:18 <sioraiocht> hmmm
15:52:19 <sioraiocht> okay
15:52:27 <sioraiocht> and it can't figure that out on its own?
15:52:47 <sioraiocht> or I can't get it to guess a bit?
15:52:50 <Saizan_> because you could have an instance C [a] (F b) where later
15:52:57 <ddarius> sioraiocht: It doesn't guess.
15:53:08 <Saizan_> it doesn't guess by purpouse of being predictable
15:53:18 <sioraiocht> Okay
15:53:37 <sioraiocht> There's no way to strength that relationship?
15:53:56 <sioraiocht> to say if it's [a], it's always F a?
15:54:06 <sioraiocht> *strengthen
15:54:09 <ddarius> You can add a functional dependency.
15:54:14 <ddarius> That might do what you want.
15:54:23 <sioraiocht> ddarius: Yes, I think so =)
15:54:40 <sioraiocht> what would the syntax be in this case?
15:54:48 <ddarius> Well, functional dependencies get added to class declarations, so such a dependency would have to hold for all instances.
15:54:54 <sioraiocht> that's fine
15:55:11 <ddarius> Okay, then it is class Foo x y | x -> y where ...
15:55:23 <sioraiocht> okay, thanks!
15:57:06 <ehird> Anyone have some example code that changes meaning depending on the indentation of one line? (both indentations resulting in valid code)
15:57:50 <sioraiocht> This is going to haunt me later in my research, I can feel it
15:58:35 <tibbe> @src ($!)
15:58:35 <lambdabot> f $! x = x `seq` f x
15:58:52 * sioraiocht wonders how his supervisor feels about fundeps...
15:59:02 <ehird> They're fun and they're deps!
15:59:45 <ddarius> sioraiocht: Multiparameter type classes usually require functional dependencies.
15:59:54 <ddarius> They are extensions that go together for the most part.
15:59:56 <Saizan_> ehird: suppose you've "do if x then y else do a; b" <- depending on the indentation of b, it could either go inside the else branch or be another statement in the surrounding do-block
16:00:04 <Saizan_> ehird: the types have to work out though
16:00:04 <sioraiocht> ddarius: oh okay, well, they were an expected part of this work
16:00:07 <sioraiocht> so I guess tht's okay ;)
16:00:13 <ehird> Saizan_: yeah, should have thought of that
16:00:30 <sioraiocht> the constraint is probably good for helping to enforce isomorphism this typeclass is supposed to represent
16:00:33 <sioraiocht> *the
16:00:41 <ddarius> sioraiocht: You could alternatively use associated types and such, but those are newer and less commonly implemented (but it does seem to be the direction Haskell is going)
16:01:01 <sioraiocht> that can be another paper...
16:01:20 <c_wraith> ehird: there's also this very imperative-looking code  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15849#a15849
16:01:23 <Saizan_> that's what the implementors said :)
16:01:41 <ehird> Is there a page anywhere that explains why Haskell needs layout as opposed to just Python-style indentation? (not for me)
16:02:12 <ddarius> ehird: Versus python, I assume it's just prettier.
16:02:33 <sproingie> ehird: hysterical raisins
16:02:46 <ehird> ddarius: I tried "because Haskell is based on nested expressions, not linear imperative code" but that doesn't really make sense.
16:02:51 <ehird> There is nesting in Python, after all.
16:03:22 <sproingie> i don't think there's any deep connection to semantics
16:03:24 <mental> i'm pretty sure it's just to make it look prettier in academic papers
16:03:31 <ddarius> I haven't looked at the details of Python's syntax, but as far as I can tell, there isn't much difference between Haskell and Python there.
16:03:46 <sproingie> python doesn't require indented blocks to line up with preceding tokens
16:03:51 <kmc> haskell does not need layout either
16:03:52 <sproingie> it just requires a level of indent
16:04:03 <pikhq> ehird: Definitely hysterical raisons.
16:04:10 <pikhq> s/raisons/raisins/
16:04:17 <joe1> > dropWhile (== 2) [1,2,3,4,5]
16:04:18 <lambdabot>   [1,2,3,4,5]
16:04:58 <joe1> > dropWhile (== 3) [1,2,3,4,5]
16:05:00 <sproingie> i like to pronounce "raison d'tre" as "dirty raisin"
16:05:00 <lambdabot>   [1,2,3,4,5]
16:05:17 <joe1> > dropWhile (== 1) [1,2,3,4,5]
16:05:18 <lambdabot>   [2,3,4,5]
16:05:48 * hackagebot upload: hssqlppp 0.1.0 - Sql parser and type checker (JakeWheat)
16:06:35 <Alpounet> oh, yet another French haskeller
16:06:37 <Alpounet> ?
16:06:46 <ddarius> sproingie: If I'm understanding what you are saying (and I'm not sure of that) that seems like Python layout is a special case of Haskell layout.
16:06:46 <tibbe> Is there a difference in representation (assuming GHC) between data Foo = Foo !(Bar -> IO ())   and   data Foo = Foo {-# UNPACK #-} !(Bar -> IO ())   ?
16:06:49 <ehird> it seems like half of all functional programmers are french :)
16:06:57 <tibbe> i.e. does unpacking work for functions?
16:07:04 <Alpounet> but no FP user group here ehird :/
16:07:06 <kmc> tibbe, don't think it works for functions
16:07:14 <Alpounet> there's an OCaml meeting, that's all.
16:07:21 <kmc> unpacking means to replace Int with Int# and the like
16:07:22 <HugoDaniel> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15850#a15850  ghc assumes that this is constant ? when i index it, will it be "recreating" the array each time ?
16:07:24 <ddarius> ehird: Perhaps FP programmers in general (for some definition of FP) but I wouldn't say that for Haskell programmers.
16:07:36 <ehird> ddarius: Yeah, mostly the OCaml dudes are French for obvious reasons.
16:07:48 <ehird> (obvious raisins?)
16:07:49 <Alpounet> yeah
16:07:58 <Alpounet> we have #haskell.fr though !
16:08:00 <sproingie> ddarius: it's easier to think of them as separate i'd say
16:08:04 <Alpounet> and even a French Haskell ML
16:08:08 <Alpounet> but that's all haha
16:08:10 <kmc> tibbe, a function is not represented by a closure with a single field of primitive type
16:08:24 <tibbe> kmc: I've seen it in code, that's why I'm asking.
16:08:45 <Saizan_> HugoDaniel: if it's at top level it's guaranteed to be computed only once
16:08:47 <tibbe> kmc: if it changed a pointer to a pointer to a closure with just a pointer to a closure
16:08:51 <kmc> yeah i see
16:09:20 <kmc> well, the correct solution is probably:  newtype Foo = Foo (Bar -> IO ())
16:09:32 <kmc> then Foo will have the same representation as (Bar -> IO ())
16:09:33 <Saizan_> HugoDaniel: because it has no formal arguments and it doesn't have a typeclass context in the type
16:09:46 <Ke> so System.IO has nothing to delete files?
16:10:05 <HugoDaniel> Saizan_: how do i guarantee that it will be top level ?
16:10:25 <kmc> tibbe, ah, okay, GHC manual says i'm wrong
16:10:29 <kmc> "Any single-constructor data is eligible for unpacking; for example"
16:10:38 <kmc> data T = T {-# UNPACK #-} !(Int,Int)
16:10:49 <kmc> but i don't see why this is preferred over newtype
16:10:58 <Eduard_Munteanu> Can a type be an instance of two or more type classes?
16:11:00 <ddarius> sproingie: I'm trying to figure out what is different, as far as I can tell, there are only two (major) cases where there is a difference.  The first is when you start the first line of layout on the same line as the token that opens layout, and the second is when you start the block of layout at the same level of indentation as the previous construct, e.g. as most people do for the 'where' in 'module Foo where'
16:11:01 <Saizan_> ?hoogle removeFile
16:11:01 <lambdabot> System.Directory removeFile :: FilePath -> IO ()
16:11:06 <koeien37> Eduard_Munteanu: yes. This is very common, in fact
16:11:10 <Saizan_> Ke: ^^^
16:11:13 <kmc> Eduard_Munteanu, definitely
16:11:13 <Ke> thanks
16:11:15 <Eduard_Munteanu> koeien37, thanks.
16:11:30 <kmc> Eduard_Munteanu, Int is an instance of Eq, Ord, Num, Show, Read, Bounded, Enum, ...
16:11:32 <tibbe> kmc: yeah, that example doesn't make much sense
16:11:34 <Eduard_Munteanu> I'm looking to make something that's both a monad and a comonad.
16:11:45 <tibbe> kmc: or wait, it does
16:11:48 <Saizan_> HugoDaniel: well, by top level i meant that it's a declaration at the module level, rather than inside an inner let or where block
16:12:01 <Eduard_Munteanu> kmc, I see.
16:12:05 <tibbe> kmc: er no
16:12:07 <kmc> Eduard_Munteanu, "T is an instance of C" just means "T supports certain operations as described by C"
16:12:13 <tibbe> kmc: it's just same as (Int, Int)
16:12:17 <Eduard_Munteanu> kmc, yeah.
16:12:30 <kmc> tibbe, i think it's the same as (Int, Int) in a newtype
16:12:37 <tibbe> kmc: yes
16:12:40 <sproingie> ddarius: haskell is more flexible in general about splitting expressions across lines
16:12:46 <kmc> except maybe that the unpacking is recursive
16:12:49 <ddarius> For a monoid M, ((,) M) is a monad and a comonad.
16:12:49 <kmc> and so you get two Int#
16:12:52 * ksf goes on and renames IO to Stmt
16:12:55 <kmc> but i don't think that's the case
16:12:57 <jmcarthur> Eduard_Munteanu: streams are monads and comonads
16:13:01 <kmc> because the Ints in the pair are not strict
16:13:12 <jmcarthur> err, Stream is a Monad and a Comonad
16:13:26 <ksf> ...or, actually, I should build a new set of monadic actions with that name.
16:13:28 <Eduard_Munteanu> jmcarthur, nice, never thought that.
16:13:41 <HugoDaniel> thanks Saizan_ :)
16:13:59 <ksf> and I understood why that imperative haskell tutorial is a good idea: immideate success.
16:14:18 <ksf> ...nothing is more off-putting than being confronted with alien stuff in the first paragraph.
16:15:32 <sproingie> immediate feedback is helpful
16:15:57 <ksf> ...just a little teaser maybe, along the lines of "The main difference between Haskell and your favourite imperative language is that in the latter, expressions are embedded in statements, whereas in haskell, statements may be embedded in expressions, too. And we're able to draw a precise and very useful line between both."
16:16:32 <ben0x539> Does Haskell have some sort of dup() lookalike for Handles?
16:16:35 <Eduard_Munteanu> jmcarthur, I see Data.Stream (if that's what you meant) is only an instance of Monad, could it define comonadic stuff by itself?
16:16:45 <ben0x539> Like dup :: Handle -> IO Handle, to copy a handle...
16:16:52 <ddarius> Eduard_Munteanu: There is no "standard" Comonad class.
16:16:53 <ksf> Stmt Int is somehow less scary than IO Int, too. At least return makes more sense, then.
16:17:06 <jmcarthur> Eduard_Munteanu: it is possibel to define an instance of Comonad for Stream, if that's what you mean
16:17:10 <jmcarthur> *possible
16:17:28 <Eduard_Munteanu> ddarius, yeah, I just checked out category-extras
16:17:32 <Eduard_Munteanu> jmcarthur, I see.
16:17:41 <kmc> ben0x539, it's probably in System.Posix
16:17:48 <kmc> i don't know if that operation can be supported cross-platform
16:18:02 <ezyang> @seen dons
16:18:02 <lambdabot> Unknown command, try @list
16:18:04 <ben0x539> Posix is probably cross-platform enough
16:19:40 <kmc> @hoogle dup
16:19:41 <lambdabot> Control.Concurrent.Chan dupChan :: Chan a -> IO (Chan a)
16:19:41 <lambdabot> Control.Concurrent.STM.TChan dupTChan :: TChan a -> STM (TChan a)
16:19:41 <lambdabot> Language.Haskell.Syntax data HsFieldUpdate
16:20:15 <sproingie> windows has DuplicateHandle
16:23:27 <kmc> ben0x539, System.Posix.IO.dup
16:24:01 <ben0x539> I suppose handleToFd h >>= fdToHandle has about the same effect
16:24:27 <kmc> i would not suppose that at all
16:24:39 <ben0x539> Err, of course not
16:24:41 <sproingie> that would use the same fd
16:24:45 <ben0x539> but I meant to close the original Handle anyway
16:24:55 <kmc> but not to reuse it?
16:24:55 <ben0x539> I just wanted to steal the handle so no one else could use it
16:25:47 <ben0x539> I was trying to write a lazy "read all lines from that handle" function
16:26:01 <ben0x539> I did not want to mess around with this semi closed thing
16:26:13 <kmc> oh
16:26:17 <kmc> lazy IO :(
16:26:33 <ben0x539> I was going to return stuff in data LazyIOList a = LazyIOItem a (LazyIOList a) | LazyIOEnd | LazyIOError IOError
16:26:57 <ben0x539> I forgot what all the problems with lazy IO were, again, so I tried to run into them
16:27:43 <copumpkin> ben0x539: you can pretend the value is pure when it isn't, which means in a pure function with undefined evaluation order, the hidden effects of your lazy IO could happen in all sorts of crazy orders and confuse the hell out of you
16:35:51 * tibbe realizes, after some thinking, that there's a difference between "return $ Foo x y" and "return $! Foo x y" when 'x' and 'y' are strict fields.
16:36:11 <copumpkin> yep
16:37:05 <ehird> So what are the options for someone who wants to write some FRP stuff?
16:37:17 <ehird> I've seen Yampa and Grapefruit so far. Any more/comparisons/etc?
16:37:22 <sproingie> reactive
16:37:40 <ehird> I think I'll ignore Yampa as the package names seem rather, ahem, academic.
16:38:07 <ehird> "This version of Reactive has some serious bugs" reassuring.
16:38:18 <sproingie> eh
16:38:37 <sproingie> ask conal about them, i don't think you'll run into them
16:39:19 <ehird> conal! conal! conal! (He can be summoned by repeating his name thrice.)
16:39:30 <sproingie> he's kind of in the midst of another major rethink of FRP tho
16:39:34 <ehird> Yeah, I saw.
16:39:37 <c_wraith> don't you need a mirror, too, ehird?
16:39:49 <ehird> I might just end up rolling my own without any knowledge or experience with FRP, based entirely on examples.
16:39:57 <ehird> That would be fun, rewarding and kill seven and a half babies.
16:40:06 <sproingie> removing the explicit time element ought to be interesting.  might be going down the rabbit hole ob abstraction tho
16:40:25 <ehird> c_wraith: if you think about it aren't, like, irc channels mirrors... onto our discussion... onto itself... onto OURSELVES, man...
16:40:36 <sproingie> i did something similar for a "game event orchestration system" once, i ended up describing nothing but "something happens then something else happens"
16:40:54 <sproingie> had to de-abstract it again to get anything meaningful out of it
16:41:11 <ehird> my impression of FRP's usefulness, based on a few examples, is "purely functional event handling"
16:41:18 <ehird> i realise that's not really precise, but I feel like it's the same sort of thing
16:42:21 <sproingie> "denotational design" is what conal's on about.  which to me seems like a fancy way of saying declarative programming
16:42:42 <sproingie> verifiable declarative programming perhaps
16:42:46 <ehird> He's said that "denotational" is just "functional".
16:42:54 <ehird> But he says it instead of "functional" so people don't think of things like monadic IO.
16:43:13 <ehird> i.e. trying to apply the benefits of functional programming (composability, reasoning, etc.) to IO
16:43:22 <Saizan_> he also says "purity" when he means "tractable semantics" though :)
16:43:28 <sproingie> i could never really wrap my head around the abstractions of FRP so i'm looking into CHP
16:43:33 <ben0x539> Why do we need Data.Stream over regular old lists again
16:43:34 <sproingie> i can intuit CHP really easy
16:43:51 <ehird> I think what I want is a very small subset of FRP
16:43:59 <sproingie> yah me too
16:44:00 <Saizan_> ben0x539: there's no empty stream
16:44:02 <ehird> basically I want something FRP enables but not the whole underpinning of FRP
16:44:09 <ehird> the issue with that is, I need to know the rest to implement it
16:44:19 <ehird> (as opposed to using a less-suitable whole-of-FRP libary)
16:44:23 <sproingie> i have little interest in the animation part, so the continuous behaviors aren't useful to me
16:44:40 <ben0x539> Haskell ought to be the only language where you get a new library by taking a standard library and *removing* features from it
16:44:41 <sproingie> event handling and routing and so forth however i really need a sensible framework for
16:44:50 <gwern> (I hope FRP doesn't turn out to be our Russia, or Perl 6)
16:44:53 <ehird> Event handling is basically what I want FRP for.
16:45:09 <ehird> (The fact that I don't know what you mean by routing sets off out-of-my-league alarm bells in my head.)
16:45:34 <sproingie> reactive may be good then, it doesn't treat discrete events quite as second-class as yampa
16:45:55 <sproingie> event routing is basically "find someone who handles this event"
16:46:02 <ehird> right
16:46:11 <ehird> I assume implementations of FRP aren't purely functional themselves
16:46:16 <sproingie> sure they are
16:46:25 <ehird> so how do they avoid mutating an event handler map?
16:46:36 <ehird> (if they do it with State that doesn't count, it's still mutation :-))
16:46:42 <sproingie> yampa uses big networks of arrows
16:47:10 <holmak> fudgets has a neat routing mechanism as well
16:47:20 <sproingie> they all have a sort of electronics feel to them, of circuits and latches and so on
16:47:21 <holmak> also dependent on arrows, IIRC
16:47:39 <ehird> I guess I just see FRP as an optimisation of calling (\data1 data2   ) really often
16:47:50 <ehird> the bit of FRP I care about, that is
16:47:51 <sproingie> heck grapefruit uses electronics terminology directly
16:48:06 <ehird> (well, optimisation and modularisation)
16:48:32 <holmak> Question: Do arrows have practical problems in the way that FRP does, or can you use them without fear of pathological runtime behavior?
16:48:55 <sproingie> FRP started life as an animation thing, basically making *everything* able to be interpolated
16:49:10 <sproingie> it still shows through now.  i'm still not sure how applicable it is to discrete events
16:49:24 <sproingie> when your system is comprised solely of discrete events that is
16:49:29 <ddarius> holmak: Arrows are an interface.
16:50:01 <copumpkin> yay, ddarius is back
16:50:11 <ddarius> sproingie: FRP handles more than just discrete events.  Consider a button and textbox.  Are the events there only discrete?
16:50:22 <holmak> That's true, it was a bad question.
16:50:25 <sproingie> i would say so
16:50:28 <ddarius> Or rather is that small system discrete?
16:50:38 <monochrom> Time flies like an Arrow. Space leaks like a Monad.
16:50:47 <Amigoo> yo
16:51:03 <sproingie> other than mouse position events on both of those i don't see any non-discrete events on the button or textbox
16:51:38 <ehird> @remember <monochrom> Time flies like an Arrow. Space leaks like a Monad.
16:51:39 <lambdabot> Good to know.
16:51:45 <ehird> oops, that's under <monochrom> now
16:51:51 <ehird> darn @remember's unintuitive interface...
16:52:13 <copumpkin> how is that unintuitive? :P
16:52:19 <copumpkin> @forget <monochrom> Time flies like an Arrow. Space leaks like a Monad.
16:52:20 <lambdabot> Done.
16:52:20 <monochrom> Or rather your irc client's unintuitive interface, like, why in hell it inserts <>
16:52:24 <ehird> not copy-paste friendly :<
16:52:28 <copumpkin> @remember monochrom Time flies like an Arrow. Space leaks like a Monad.
16:52:28 <lambdabot> It is stored.
16:52:33 <ehird> monochrom: you would prefer it instead said "monochrom Time"?
16:52:38 <copumpkin> not all clients put silly punctuation around names
16:52:40 <ehird> because if you talk in lowercase that's confusing
16:52:45 <ehird> ("ehird because if")
16:52:51 <kmc> @quote flies
16:52:52 <lambdabot> monochrom says: Time flies like an Arrow. Space leaks like a Monad.
16:52:53 <kmc> @quote flies
16:52:54 <lambdabot> monochrom says: Time flies like an arrow.  Fruit flies like a banana.  Syntax rules like a macro.
16:52:57 <kmc> @quote flies
16:52:58 <lambdabot> monochrom says: Time flies like an Arrow. Space leaks like a Monad.
16:53:04 <kmc> @quote monochrom.flies
16:53:05 <lambdabot> No quotes match. My pet ferret can type better than you!
16:53:08 <ehird> monochrom: i accuse you of reusing quotes
16:53:13 <ehird> oh wait
16:53:15 <ehird> it's a different one
16:53:26 <monochrom> ha!
16:57:12 <gwern> monochrom: how is one supposed to parse 'Syntax rules like a macro'?
16:57:29 <gwern> @flish
16:57:31 <sproingie> 'are'
16:57:36 <monochrom> Two parses. Both valid. Pun.
16:57:39 <interferon> is there a library function that splits a string by a character?
16:57:43 <sshc> does GHC have an extension for namespaces?
16:57:48 <interferon> split "foo.bar", "." => ["foo", "bar"]
16:57:49 <sshc> if so, how do I enable it in-code?
16:57:54 <gwern> interferon: the split library
16:58:02 <kmc> sshc, what do you mean by "namespaces"?
16:58:03 <gwern> funnily enough
16:58:07 <kmc> the answer is probably "no, use modules"
16:58:34 <kmc> sshc, http://www.haskell.org/ghc/docs/latest/html/users_guide/ghc-language-features.html  <--- GHC extensions
16:58:38 <monochrom> use module for namespace.
16:58:47 <gwern> monochrom: what are the valid parses? I don't see any consistent without ascribing funny properties to macros and syntax, like being sovereigns or having preferences
16:59:09 <monochrom> 1. (syntax) rules (like a macro). 2. (syntax rules) like (a macro).
16:59:30 <kmc> "fruit flies like a banana" involves preference
16:59:42 <sproingie> buffalo buffalo buffalo buffalo buffalo buffalo buffalo
16:59:45 <monochrom> In the second, "rules" is as in "Haskell rules!"
17:00:05 <gwern> so you're ascribing funny properties. well, it was a good try
17:00:12 <monochrom> Or perhaps "Scheme rules!"
17:00:26 <gwern> kmc: fruit flies have neurons, though
17:00:26 <sproingie> (rules? scheme)
17:00:36 <monochrom> It is a joke, of course it has to use funny properties.
17:00:52 <kmc> neurons are neither necessary nor sufficient for liking something
17:01:08 <tensorpudding> nil
17:01:52 <monochrom> And you can pick on Space leaks like a Monad too, like, you can lecture to me for three hours on how to write monads that don't have space leaks and how easy it is.
17:01:55 <gwern> monochrom: but the original uses english idiom and normal biology; your addition doesn't draw on already existing knowledge of the humored party
17:02:21 <gwern> tensorpudding: doesn't scheme have #f separate from () or nil?
17:02:28 <tensorpudding> it might
17:02:29 <Adamant> gwern: yes
17:02:34 <tensorpudding> i don't remember
17:02:51 <kmc> yes, scheme has #t and #f
17:02:52 <gwern> kmc: what likes things but has no neurons? that has actually existed mind you, not may exist in the future
17:03:06 <monochrom> There exists knowledge of macros in general and Scheme's syntax-rule in particular in the humoured party.
17:03:16 <kmc> gwern, oh, there may be answers to that question but i'm not prepared to argue any of them
17:03:18 <tensorpudding> is there a schemebot?
17:03:42 <sioraiocht> anyone have a suggestion of a good pointfree function that highlights haskell's conciseness?
17:03:44 <gwern> tensorpudding: I think there is one in #scheme, using OS level sandboxing
17:03:46 <tensorpudding> i know there is a lispbot of some kind in #lisp
17:03:56 <Adamant> minion and rudybot
17:03:57 <tensorpudding> but i'd imagine it'd use a common lisp
17:04:07 <gwern> sioraiocht: well, run-length encoding with arrows, maybe. look up dons' post
17:04:14 <sioraiocht> cheers
17:04:14 <Adamant> I think minion is CL and rudybot Scheme
17:04:33 * tensorpudding was reading steel + gabriel's book on lisp
17:04:38 <tensorpudding> earlier today
17:04:40 <kmc> > fix ((0:) . scanl (+) 1) -- sioraiocht infinite list of fibonacci numbers
17:04:42 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
17:04:52 <sioraiocht> kmc: hrm, thanks =p
17:05:08 <Adamant> there was also sarahbot but she's gone now
17:05:08 <kmc> it's not a function though
17:05:08 <gwern> imo, the scheme/common-lisp split is probably one of the most destructive language feuds ever
17:05:23 <tensorpudding> kmc: did you see that link i posted in #haskell-blah
17:05:40 <kmc> tensorpudding, no
17:05:40 <gwern> most of the common-lisp complaints I've seen could've been addressed inside scheme, but yet...
17:05:50 <kamatsu> hi, what does the "inferred type is less polymorphic than expected" error mean?
17:05:54 <Adamant> gwern: not really, the lack of centralization on one or two compilers/interpreters for each language is the biggest problem.
17:06:05 <kmc> kamatsu, can you post your code to hpaste.org ?
17:06:09 <tensorpudding> http://www.catonmat.net/blog/using-fibonacci-numbers-to-convert-from-miles-to-kilometers/ was the link
17:06:10 <kmc> it's hard to explain out of context
17:06:12 <kamatsu> it's fairly large example
17:06:18 <c_wraith> kamatsu: usually it means you're mixing Rank2 stuff in with non-Rank2 stuff.  Using ST, maybe?
17:06:30 <gwern> Adamant: that can be addressed in the language, by the community. haskellers have centralized, yet the report says nothing about ghc
17:06:33 <kamatsu> i'm using two StateT's over IO
17:06:40 <kamatsu> but they're wrapped in newtypes etc.
17:06:42 <chrisf|work> tensorpudding: not the best post ever, that.
17:06:44 <c_wraith> Oh, that would do it.
17:06:53 <Adamant> ghc being as centralized as it is helps Haskell more that most Haskellers know
17:07:00 <Saizan> well, that would do it only if you've some weird signatures.
17:07:04 <gwern> Adamant: if the common lispers switched over en masse and fixed up their favored compiler, and committed to some long-term support, did some evangelism ala dons, then that'd disappear
17:07:10 <tensorpudding> chrisf|work: what was the problem with it?
17:07:22 <Adamant> gwern: the community is apparently happy with having a lot of options for both
17:07:32 <kamatsu> i probably have made an obvious error somewhere, but I'm wondering if i could get a definition for what causes this error so i have a better idea of what to look for
17:07:44 <chrisf|work> tensorpudding: smells like filler. there are far deeper things on that blog.
17:07:47 <kamatsu> or some minimal example that causes it
17:08:04 <tensorpudding> i don't follow the blog, i only saw the link on reddit
17:08:09 <Adamant> gwern: also, people use ghc in part because creating a whole feature-complete competitor would be really hard.
17:08:11 <kmc> kamatsu, i'll try to make a minimal example
17:08:13 <gwern> Adamant: yeah, that's part of the problem. but if they were the sort of community that wouldn't maintain the cl-scheme split for 2 decades, I guess they wouldn't be doing that either
17:08:19 <kamatsu> kmc: thanks!
17:08:24 <Saizan> kamatsu: it happens when a signature you've given promises some kind of polymorphism that's not present in the implementation
17:08:26 <Adamant> it's really easy to make a Scheme. it's harder to make a good Scheme.
17:08:48 <Saizan> kamatsu: so it might help to comment out type annotations, or look at type definitions
17:08:50 <Adamant> gwern: I'm hopeful R7RS will put some mojo back into Scheme
17:09:32 <Saizan> kamatsu: type synonyms are also common culprits
17:09:37 <roostaj> @src >>=
17:09:37 <lambdabot> Source not found. Just what do you think you're doing Dave?
17:09:40 <roostaj> @src (>>=)
17:09:40 <lambdabot> Source not found. You speak an infinite deal of nothing
17:09:44 <copumpkin> tensorpudding: I didn't find that article particularly illuminating. "fib quotients converge to phi. miles/km ~ phi. fibonacci & miles zomg! yes it's impractical"
17:10:17 <tensorpudding> it wasn't meant to be practical
17:10:29 <tensorpudding> it just was neat to notice
17:10:37 <copumpkin> heh
17:11:08 <kamatsu> hm
17:11:08 <ehird> so how many web frameworks do we have now? 73?
17:11:13 <chrisf|work> copumpkin: #haskell is just too hardcore for it ;)
17:11:19 <gwern> Adamant: I'm not. didn't R6 alienate a bunch?
17:11:38 <ehird> copumpkin: catonmat.net posts generally irritate me for exactly this reason
17:11:43 <Adamant> gwern: the point is they've split the language definition up
17:11:56 <ehird> copumpkin: "trivial thing stated in a simplistic manner! repeat. repeat. repeat."
17:11:58 <roostaj> So, (>>=) forces the left argument to evaluate and then passes its value to the right argument?
17:11:59 <Adamant> a small core Scheme and a Common Scheme built on top of that
17:12:07 <gwern> sure, but they'll still hurt themselves
17:12:13 <ehird> R6RS is crap
17:12:20 <Adamant> gwern: that solves most of the drama surrounding R6RS
17:12:28 <ehird> Adamant: no it doesn't
17:12:32 <gwern> *they've
17:12:34 <ehird> only the most trivial complaints
17:12:41 <Adamant> ehird: how doesn't it
17:12:42 <monochrom> roostaj: depends on the monad
17:12:59 <roostaj> monochom: Ok, for IO?
17:13:03 <roostaj> monochrom:
17:13:06 <ehird> the libraries themselves are decidedly unschemish, the language has lost its original "feel" in an attempt at becoming "practical", etc.
17:13:09 <monochrom> Partly yes.
17:13:21 <ehird> R6RS isn't a bad language per se. It's just a bad Scheme.
17:13:23 <kmc> kamatsu, hmm, i'm failing :/
17:13:25 <ehird> Splitting it in two will not solve this.
17:13:38 <Adamant> I'm hopefully it will, but we will see
17:13:45 <Adamant> *hopeful
17:13:55 <roostaj> monochrom: I'm just trying to see why you would use it instead of regular composition
17:14:10 <ehird> tbh a third-party standard based on R5RS is probably Scheme's best hope at the moment.
17:14:10 <taruti> there is clojure too if one wants a lisp :)
17:14:20 <monochrom> Example: getLine >>= blah will really wait until input is received before going on.
17:14:29 <Adamant> clojure will be interesting when the JVM gets unscrewed
17:14:34 <sproingie> i want a scheme that's as fast as sbcl
17:14:37 <kamatsu> say I have Teacup s v which is a newtype of StateT s Tea v where Tea v is a newtype around StateT TeaLeaves IO v where TeaLeaves is some concrete data
17:14:42 <Adamant> until then I don't care so much
17:14:46 <monochrom> Example: return (x+1) >>= blah will not evaluate x+1 before going on.
17:14:49 <ehird> sproingie: will never happen; that isn't to say Scheme can't be fast, though
17:14:58 <stoop> That is a completely unnecessary use of unicode.
17:15:03 <ehird> sproingie: the fact is that (+ 2 2) _must_ look up + in the symbol table and call it
17:15:11 <ehird> because you can redefine any function
17:15:18 <ehird> because of this, scheme has an inherent performance limit
17:15:21 <Adamant> some of the newer R6RS Scheme impl. may get that fast
17:15:25 <Saizan> kamatsu: can you paste the whole definitions?
17:15:26 <sproingie> ehird: gah, it's what kills python performance
17:15:34 <Saizan> kamatsu: scoping of type variables can affect this
17:15:58 <kamatsu> I'll try and boil it down to something digestible
17:15:59 <gwern> ehird: can't a compiler determine that + hasn't been redefined and do all the normal optimizations?
17:16:02 <Adamant> they're at least aiming for direct native compilation now.
17:16:19 <taruti> gwern: it can be redefined at run-time
17:16:35 <Saizan> kamatsu: well, the type definitions should be that long, are them?
17:16:51 <Saizan> kamatsu: also, the region of the code where the error is reported
17:17:07 <gwern> taruti: yes, but you could do it conditionally - compile assuming there's been no change, and one assuming, and flip a bit whenever + gets redefined
17:17:30 <ehird> gwern: well, perhaps
17:17:37 <ehird> but a lot of code "might" change the semantics of +
17:17:39 <roostaj> monochrom: but what if I called blah (return (x+1))
17:17:44 <ehird> or, rather, not +
17:17:45 <gwern> it seems to me on par with stuff ghc does fine like strictness analysis
17:17:47 <roostaj> monochrom: how does >>= help me
17:17:48 <ehird> but other standard functions
17:17:55 <ehird> so if you used scheme idiomatically (freely), it would be iffy
17:17:56 <taruti> gwern: and thus there is a penalty (checking the memory location) that doesn't exist in some other languages.
17:18:02 <kamatsu> Saizan: yup, just a minute
17:18:14 <monochrom> Can you really call blah (return (x+1))? It might even be a type error.
17:18:22 <taruti> gwern: actually GHC can theoretically do better
17:18:24 <xerox> (Euler #xerox)
17:18:49 * ehird xeroxes xerox
17:18:56 <ehird> Not so xerox now, are we, xerox?!
17:18:59 <ehird> Xerox.
17:19:37 <Twey> Someone's going to sue xerox for trademark infringement one of these days
17:20:03 <roostaj> monochrom: I guess I don't see why it would be a type error.
17:20:07 <ehird> I'm pretty sure if *any* trademark is genericised, xerox is.
17:20:20 <ehird> Especially lowercase.
17:20:29 <xerox> Oh darn, the first part went to -blah.
17:20:37 <gwern> taruti: you could add more. when you build the call graph, you start at the bottom. does + on its own redefine anything? mark it 'safe'. does 1 or 1 redefine anything? mark it safe. propagate upwards; every section of the tree marked ssafe gets compiled assuming there have been no redefinition. at some point you'll hit an eval or whatever; mark it unsafe, and compile a second copy of the program with the checks; do the previous ...
17:20:39 <xerox> I am the largest number divisible by all numbers less than my square root. (Euler #xerox)
17:20:44 <gwern> ... conditional. now your program runs at full speed until it hits the eval, and then it flips over to the slower one
17:20:52 <Saizan> roostaj: the point is that your blah must have type "M a -> .." then
17:21:13 <xerox> Wait no, I am confused, the last part that went here by accident :)
17:21:24 <Saizan> roostaj: so it has to deal with an argument of type M a, how does it look at the 'a' there? by using >>=
17:21:24 <ehird> gwern: The basic problem is that Scheme encourages making full use of its features
17:21:31 <monochrom> Perhaps blah :: Int -> IO Bool.  Perhaps return (x+1) :: IO Int.  Well IO Int is not Int.
17:21:31 <ehird> and Scheme is *very* dynamic
17:21:39 <kamatsu> Saizan: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15853#a15853 Hopefully comprehensible
17:21:44 <gwern> taruti: if you can show that the eval can only affect things beneath it in the tree, you can do the same thing with everything beneath it; so you run at full speed, hit the eval and flip over, run safely slowly, then flip back over
17:22:23 <roostaj> Saizan: so would return (x+1) >>= blah be equivalent to blah (x+1) ?
17:22:35 <kamatsu> roostaj: yup
17:22:41 <gwern> http://shootout.alioth.debian.org/u32/benchmark.php?test=all&lang=mzscheme&lang2=sbcl <-- plt scheme isn't *that* bad
17:22:46 <ehird> return x >>= f                ==        f x
17:22:46 <Woof> Twey!!!
17:22:48 <ehird> one of the monad laws
17:22:54 <ehird> gwern: no fair
17:22:56 <ehird> plt isn't r5rs
17:22:59 <Woof> I'll let you know, I'm very angry with you >: O
17:23:03 <Twey> Woof: What?
17:23:03 <Saizan> kamatsu: this signature is wrong getEventQuery :: EventQuery -> Teacup s Bool
17:23:05 <Twey> Oh, not you too
17:23:07 <Twey> Why?  :
17:23:09 <ehird> in fact they made cons immutable in 400; it's basically turning into an ungodly R6RS-alike
17:23:12 <kamatsu> Saizan: what should it be?
17:23:16 <Woof> You're slacking off!
17:23:22 <Woof> Get back there!
17:23:30 <Saizan> kamatsu: getEventQuery doesn't work for any 's', only for TeaState
17:23:33 <Twey> No
17:23:35 <Twey> Leave me alone
17:23:40 * Twey hides under his rock
17:23:47 <Saizan> roostaj: yes, that's one of the monad laws, actually
17:23:47 <Woof> >: O
17:23:49 <gwern> ehird: as a haskeller shouldn't you approve of immutable cons?
17:23:49 <kamatsu> Saizan: Actually it works for any Teacup s
17:23:57 <kamatsu> Saizan: TeaState is in the next layer of StateTs
17:24:08 <ehird> gwern: As a Haskell matter, certainly. But it's not what R5RS says and it breaks R5RS programs.
17:24:14 <kamatsu> Saizan: Note i'm using lifted get/put
17:24:17 <roostaj> Saizan: ah, ok. I haven't really started to learn monads, yet. I was just a bit confused on some code I was reading
17:24:30 <ehird> I don't actually *code* in Scheme because Haskell is better. :)
17:24:33 <Saizan> kamatsu: but e.g. keysDown :: TeaState -> Int
17:24:59 * Woof throws the rock (with Twey attached to it) into the sea
17:25:01 <kamatsu> Saizan: yup, but GetT :: Teacup s TeaState
17:25:10 <kamatsu> Saizan: so no problem
17:25:43 <monochrom> Twey: Do you need assistant? Just call if you do.
17:25:51 <kamatsu> Saizan: or, i hope getT has that sig
17:25:51 <Saizan> kamatsu: no, getT :: Teacup s s
17:26:12 <kamatsu> Saizan: No, that's get?
17:26:16 <kmc> is cons mutable in R6RS?
17:26:21 <Saizan> kamatsu: comment the signature on getEventQuery and ask ghci :)
17:26:29 <boscop> Woof, hey
17:26:38 <kamatsu> Saizan: if I comment out that signature, the error doesn't go away
17:26:48 <kamatsu> Saizan: and i get another error (rigid type variable blah blah)
17:26:50 <Woof> Hallo, boscop!
17:27:01 <Woof> Twey is refusing to come back to work!
17:27:12 <kamatsu> Saizan: I'll try adding a sig to getT to enforce my assumption
17:27:29 <Saizan> kamatsu: get is MonadState s m => m s
17:27:52 <kamatsu> Saizan: yup, and that's exactly what I'm doing in getT, *in the inner layer of StateT's which is TeaState*
17:28:01 <kamatsu> Saizan: the parameter on Teacup is the outer layer of StateT
17:28:04 <Saizan> kamatsu: oh, sorry, i've not seen the two nested StateT
17:29:07 <Twey> monochrom: Sure could you learn Lithuanian by Tuesday next and complete my book on Lojban, please?  Just upload to my brain when you're done
17:29:39 <stoop> Woof?
17:29:48 <stoop> Woof, are you here?
17:29:54 <ehird> Woof woof.
17:30:07 <Woof> stoop, yes I am
17:30:14 <Woof> ehird ehird
17:30:20 <ehird> Twey: Upload to your brain? How inefficient! You want that shit on disk.
17:30:29 <ehird> (Mind uploading: srs bzns)
17:30:31 <Twey> ehird: But I need fast access to it :<
17:30:35 <ehird> Twey: SSD!
17:30:39 <Twey> Hehehe
17:30:40 <Twey> Faster!
17:30:47 <Ke> so darcs assumes I make settings for each repository individually?
17:31:04 <ehird> Twey: ioDrive!
17:31:05 <Ke> like my email address would be different for each project
17:31:06 <ehird> (google it)
17:31:17 <tomoj> is it possible (or undesirable?) to have like a monad tree, a set of some few distinct monads which can be treated as instances of a more general monad, and where the types collapse ultimately to this general monad?
17:31:49 <kamatsu> Saizan: On closer inspection (just making that paste compile with some token defs), the error doesn't appear to be there
17:31:49 <Twey>  Fusion-io Achieves One Terabyte per Second Sustained Bandwidth 
17:31:50 <Twey> Woah
17:32:01 <Twey> Isn't that faster than SDRAM?
17:32:08 <sproingie> much
17:32:18 <Twey> Wow
17:32:19 <monochrom> Twey: I think uploading to the grader's disk is faster...
17:33:03 <Twey> Oh, that's parallel over 220 devices, though
17:33:14 <Twey> monochrom: No graders :
17:34:11 <kamatsu> Saizan: Ah, the problem was I had some stuff that could have just as easily been in Teacup or Tea. I just needed to add type signatures to show which one
17:34:12 <sproingie> DDR3 does roughly 10G/sec
17:34:25 <monochrom> Actually I can do it now. The completed book on Lojban is here: "".
17:35:17 * Twey chuckles.
17:36:05 <Saizan> Ke: you can set an enviroment variable
17:36:19 <Apocalisp> I have a pair of functions unit:(a -> c) and counit:(c -> b) where c is a monoid. What kind of structure is this? Seems adjunction-ish.
17:36:52 <monochrom> but b does not equal a
17:36:54 <Saizan> any relation between a and b?
17:37:05 <Apocalisp> a and b are both types of kind *
17:37:13 <Apocalisp> :)
17:37:53 <Saizan> kamatsu: heh, sorry i wasn't helpful :)
17:38:16 <Apocalisp> Saizan: No relationship between a and b, that I can tell.
17:38:47 <monochrom> It suddenly occurs to me: when dons goes to Australian, his name becomes suop.
17:39:16 <Apocalisp> qous
17:40:19 <tensorpudding> @djinn a -> b -> a -> a
17:40:19 <lambdabot> f _ _ a = a
17:40:39 <tensorpudding> @djinn ((a -> b) -> a) -> a
17:40:40 <lambdabot> -- f cannot be realized.
17:40:57 <tensorpudding> gotta watch out for that right-association
17:43:15 * pastah_rhymez dislikes UI code
17:43:16 <pastah_rhymez> strongly
17:43:21 <pastah_rhymez> goddamn APIs
17:43:53 * kmc dislikes users
17:44:02 <MaxNanasy> @djinn (a -> b) -> (a -> a)
17:44:02 <lambdabot> f _ a = a
17:44:12 <kmc> @djinn (a -> a)
17:44:13 <lambdabot> f a = a
17:44:18 <kmc> @djinn Either a b -> Either b a
17:44:19 <lambdabot> f a =
17:44:19 <lambdabot>     case a of
17:44:19 <lambdabot>     Left b -> Right b
17:44:19 <lambdabot>     Right c -> Left c
17:44:34 <tensorpudding> reflexivity of propositions is the identity function on types
17:46:03 <tensorpudding> @djinn ((a -> b), a) -> b
17:46:04 <lambdabot> f (a, b) = a b
17:46:17 <pastah_rhymez> kmc: hehe, nice :)
17:46:22 <tensorpudding> delicious curry
17:46:32 <pastah_rhymez> kmc: what APIs have you written?
17:46:52 <kmc> if i dislike users why would i write APIs
17:46:56 <kmc> to punish them, i supposo
17:47:09 <pastah_rhymez> kmc: excellent idea
17:47:14 <pastah_rhymez> i'm using VTY
17:47:20 <kmc> @djinn (a -> c) -> (b -> c) -> Either a b -> c
17:47:21 <lambdabot> f a b c =
17:47:21 <lambdabot>     case c of
17:47:21 <lambdabot>     Left d -> a d
17:47:21 <lambdabot>     Right e -> b e
17:47:28 <pastah_rhymez> though i've made some sense of it now, so it's getting better
17:49:10 <tensorpudding> @djinn (a -> b -> c) -> b -> (a -> c)
17:49:11 <lambdabot> f a b c = a c b
17:53:08 <dmwit_> ?djinn (a -> m b) -> (a -> m b)
17:53:08 <lambdabot> f a = a
17:54:49 <dmwit_> ?djinn (forall a. a -> a) -> (a -> a)
17:54:49 <lambdabot> f _ a = a
17:55:03 <MaxNanasy> ?djinn a -> a -> a -> a
17:55:03 <lambdabot> f _ _ a = a
17:55:07 <dmwit_> ?djinn (forall a. a -> b) -> (a -> b)
17:55:08 <lambdabot> -- f cannot be realized.
17:55:22 <dmwit_> oh
17:55:34 <dmwit_> ?djinn (a b c -> a) -> (a -> a)
17:55:34 <kmc> djinn doesn't do rank-N types
17:55:34 <lambdabot> Error: kind error: (KVar 0,KStar)
17:55:41 <MaxNanasy> ?djinn (forall a. a -> b) -> (forall a. a -> b)
17:55:41 <lambdabot> f a = a
17:55:45 <dmwit_> ?djinn (f b c -> a) -> (a -> a)
17:55:45 <lambdabot> f _ a = a
17:55:46 <kmc> which would make it significantly more powerufl
17:55:54 <dmwit_> heh
17:56:03 <dmwit_> djinn treats forall as another type variable. =)
17:56:08 <dmwit_> ok
17:56:10 <kmc> and the dot as...?
17:56:16 <kmc> @djinn forall -> forall
17:56:17 <lambdabot> f a = a
17:56:18 <dmwit_> a. is a type variable, too ;-)
17:56:26 <dmwit_> ?djinn a. -> a.
17:56:26 <lambdabot> f a = a
17:56:35 <MaxNanasy> @djinn forall a. a -> a
17:56:35 <lambdabot> f a = a
17:56:37 <kmc> @djinn stop. hammer time.
17:56:38 <lambdabot> -- f cannot be realized.
17:56:42 <tensorpudding> lol
17:56:49 <pastah_rhymez> haha
17:56:49 <MaxNanasy> Can't touch it.
17:57:04 <tensorpudding> @djinn stop -> hammertime
17:57:05 <lambdabot> -- f cannot be realized.
17:57:18 <dmwit_> This makes it hard to get djinn to generate type-class-restricted functions, I guess.
17:57:23 <pastah_rhymez> @djin (it -> touch it)
17:57:23 <lambdabot> Maybe you meant: djinn djinn-add djinn-clr djinn-del djinn-env djinn-names djinn-ver
17:57:24 <dmwit_> Unless it happens to know about type classes...?
17:57:31 <pastah_rhymez> @djinn (it -> touch it)
17:57:31 <lambdabot> -- f cannot be realized.
17:57:33 <dmwit_> ?djinn Monoid m => m
17:57:34 <lambdabot> Error: Class not found: Monoid
17:57:39 <dmwit_> oo!
17:57:41 <dmwit_> maybe it does!
17:57:55 <dmwit_> ?djinn Monad m => (a -> m b) -> (m a -> m b)
17:57:55 <lambdabot> f a b = b >>= a
17:57:57 <MaxNanasy> @djinn this -> touch
17:57:57 <lambdabot> -- f cannot be realized.
17:58:04 <dmwit_> neat, and surprising
17:58:24 <kmc> given: a Haskell 98 module and a type signature.  task: to generate a term with that type, in the context of a top-level bind in that module.  is this problem decidable?
17:58:53 <ehird> kmc: not in the general case afaik
17:58:58 <dolio> Does someone keep putting Monad in djinn, or is that in the configuration now?
17:59:04 <ehird> for a sub-tc lang I believe so; that's what djinn does
17:59:16 <kmc> sub-tc?
17:59:27 <Saizan> @djinn-env
17:59:31 <lambdabot> data () = ()
17:59:35 <lambdabot> data Either a b = Left a | Right b
17:59:39 <lambdabot> data Maybe a = Nothing | Just a
17:59:41 <lambdabot> data Bool = False | True
17:59:43 <lambdabot> data Void
17:59:45 <lambdabot> Plugin `djinn' failed with: thread killed
17:59:47 <ehird> kmc: as in total.
17:59:50 <kmc> ah
17:59:56 <kmc> Maybe is so useless in logic :)
18:00:04 <dolio> Well, it's definitely in there, considering someone just used it.
18:00:12 <dolio> @uptime
18:00:13 <lambdabot> uptime: 15d 7h 44m 37s, longest uptime: 1m 10d 23h 44m 29s
18:00:44 <dmwit_> ?djinn-add data IO a
18:01:00 <dmwit_> ?djinn-add class MonadIO m where liftIO :: IO a -> m a
18:01:14 <Saizan> seems to be in the configuration, no idea way
18:01:19 <MaxNanasy> @djinn-add data IO a
18:01:20 <Saizan> *why
18:01:32 <MaxNanasy> @djinn-env
18:01:32 <lambdabot> data () = ()
18:01:32 <lambdabot> data Either a b = Left a | Right b
18:01:32 <lambdabot> data Maybe a = Nothing | Just a
18:01:32 <lambdabot> data Bool = False | True
18:01:32 <lambdabot> data Void
18:01:34 <lambdabot> type Not x = x -> Void
18:01:37 <lambdabot> class Monad m where return :: a -> m a; (>>=) :: m a -> (a -> m b) -> m b
18:01:39 <lambdabot> class Eq a where (==) :: a -> a -> Bool
18:01:41 <lambdabot> data IO a
18:01:42 <lambdabot> class MonadIO m where liftIO :: IO a -> m a
18:01:54 <dmwit_> ?djinn (Monad io, MonadIO io) => ((a -> IO (io c)) -> IO (io c)) -> ((a -> io c) -> io c)
18:01:54 <lambdabot> -- f cannot be realized.
18:02:01 <dmwit_> aw
18:02:09 <dolio> @djinn IO b -> a
18:02:10 <lambdabot> f = void
18:02:57 <dmwit_> I wonder why djinn can't do that one.
18:03:04 <dmwit_> It's got all the pieces...
18:05:36 <Saizan> dmwit_: the class support doesn't handle higher-kinded ones very well.
18:05:44 <dmwit_> ah
18:05:58 <dmwit_> I can believe that higher-kinded classes are hard.
18:06:13 <dolio> Constructor classes require higher-rank types.
18:08:38 <dmwit_> ?src void
18:08:39 <lambdabot> Source not found.
18:08:44 <dolio> And there's no decision procedure for theorems in the corresponding logic.
18:09:10 <MaxNanasy> @type void
18:09:11 <lambdabot> Not in scope: `void'
18:10:31 <dmwit_> Hiya, conal.
18:12:51 <conal> dmwit_: hi
18:14:31 <ufopp> I get these compile errors: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15854#a15854
18:16:05 <dmwit_> yikes
18:16:51 <ezyang> that doesn't look happy
18:17:23 <dmwit_> Wait, did you download an x64 version of GHC?
18:17:34 <dmwit_> Because it looks like your OS is 32-bit (i.e. i386).
18:17:53 <tensorpudding> yeah, that looks like an architecture mismatch
18:19:13 <tensorpudding> could you try compiling a helloworld or do-nothing program and see if you have the same error?
18:20:17 <Saizan> on Snow Leopard you do need 32-bit ghc
18:22:35 <ufopp> tensorpudding, yes I get the same error for any hs program file. Yes at one time I had downloaded ghc and compiled through mac ports, but uninstalled it and as I wanted to use the haskell platform
18:23:21 <ufopp> Saizan, does haskell platform give that choice? I just saw one dmg file and used that.
18:24:03 <cads> lambdabot: you and I have a private session to attend to
18:25:27 <Saizan> ufopp: i think you need this http://obvioushints.blogspot.com/2009/09/running-haskell-ghc-on-snow-leopard.html
18:26:09 <ufopp> Saizan, that looks promising. Missed that one. Will try it right now. Thanks.
18:31:23 <ehird> All the Tk bindings are dead, aren't they?
18:31:35 <ehird> Seeing things like "ghc 4" doesn't inspire confidence.
18:31:47 <ehird> Nor "2001".
18:33:22 <tensorpudding> that looks pretty dead to me
18:33:29 <pikhq> ehird: You could write your own. A tiny bit painful, but only a tiny bit. Tk has a good C API...
18:34:02 <ksf> wxhaskell with tk backend?
18:34:06 <tensorpudding> but really, Tk is pretty dead
18:34:22 <sshc> how do I specify a specific version of the GPL in a cabal package?
18:34:23 <ehird> Tk isn't that dead. Tk 8.5 introduced the feature "you can stop it being ugly".
18:34:31 <ehird> Besides, it still has the nicest API of any GUI lib, by far.
18:34:35 <tensorpudding> you can stop it being ugly?
18:34:40 <ehird> yep
18:34:49 <pikhq> tensorpudding: Recent feature, but yes.
18:34:51 <tensorpudding> shocking
18:34:55 <ksf> if it fails to be dead, then that's because people forgot that it's tcl code.
18:35:02 <ehird> Tcl is bad but Tk isn't.
18:35:13 <pikhq> Tcl? Bad?
18:35:16 <ehird> tensorpudding: Tile got included in Tk 8.5. http://tktable.sourceforge.net/tile/screenshots/unix.html (imagine the fonts are antialiased there, and that's what you get)
18:35:19 <pikhq> Tcl's merely bizarre.
18:35:26 <ehird> Default, Revitalized and Clam all look alright.
18:35:49 <sshc> why is the extension of some Haskell suorce files .lfs?
18:35:54 <ehird> *.lhs
18:35:56 <ehird> Literate Haskell.
18:36:01 <ehird> In normal code you mark which lines are comments.
18:36:05 <ehird> In Literate Haskell, you mark which lines are code.
18:36:23 <ehird> Often used with LaTeX so that you can turn a compilable Haskell file into a research paper.
18:36:38 <sshc> ehird: do I need to pass special flags to GHC?
18:36:39 <tensorpudding> also good for blog posts
18:36:43 <pikhq> sshc: No.
18:36:47 <ehird> sshc: Yes.
18:36:56 <sshc> no, but yes?
18:36:57 <tensorpudding> you need to have .lhs as the extension
18:36:58 <ufopp> For the record, Snow Leopard compilation problems can be fixed by this suggestion Saizan made: http://obvioushints.blogspot.com/2009/09/running-haskell-ghc-on-snow-leopard.html
18:36:58 <ksf> the idea is to force people who write papers about haskell to compile their papers.
18:37:12 <ehird> sshc: pikhq is wrong.
18:37:16 <ehird> See http://www.haskell.org/haskellwiki/Literate_programming
18:37:19 <ehird> Oh, wait, no
18:37:22 <ehird> pikhq is right; I am wrong.
18:37:42 <pikhq> If you use literate Haskell and *don't* have a .lhs extension, you need an option.
18:38:01 <pikhq> (the option is not relevant: just use a .lhs extension on your literate Haskell)
18:38:07 <sshc> so pretty much I "comment" the actual source?  code and comments are inveresed?
18:38:18 <dmwit_> right
18:38:20 <pikhq> sshc: Yes.
18:38:27 <dmwit_> And you use "> " instead of "-- " to introduce code.
18:38:44 <ksf> or some \begin{...} thing
18:38:45 <dmwit_> or "\begin{code}" and "\end{code}" instead of "{-" and "-}".
18:39:08 <pikhq> The idea is that you make your code readable as a document describing your code.
18:39:25 <dmwit_> This is, incidentally, how lambdabot's choice of introducer for ?eval was chosen.
18:39:30 <ksf> it's mostly dictated by the format the literate part of the file is in.
18:39:33 <dmwit_> The idea was that the IRC logs would be a literate haskell file. ^_^
18:39:38 <ksf> markdown lends itself well to >, latex to \begin
18:40:04 <pikhq> And, quite nicely, you can then shove that document into GHC and run it.
18:40:14 <ksf> I've always interpreted it as the ghci prompt.
18:40:27 <ksf> just like typing : in vi gets you an ex prompt.
18:40:52 <monochrom> Or perhaps ghci got its > prompt from this.
18:41:14 <dmwit_> Or perhaps vi got its prompt from ghci!
18:41:20 <dmwit_> wait
18:41:59 <tensorpudding> ghci is one of the more usable interpreters for a language i've used
18:42:26 <ksf> indeed.
18:42:34 <ksf> coq is one of those bad examples.
18:42:39 <tensorpudding> ocaml sucks so bad
18:42:40 <whoppix> Ah, I remember perl had something like the literate haskell feature, but that didn't work out so good back then.
18:42:43 <ehird> tensorpudding: meh, I want Slimeskell
18:42:46 <whoppix> I believe it was compatible with nroff/groff.
18:42:52 <pikhq> It's a REPL that's meant to be used as such. Rather nice.
18:42:55 <ehird> whoppix: Hey, GHC's Evil Mangler is a literate Perl script!
18:43:00 <ksf> I think that can be reduced to "it's wrong to be french"
18:43:04 <tensorpudding> python is pretty mongly too
18:43:05 <ehird> whoppix: Don't knock it 'til you've tried it, but definitely knock it then.
18:43:20 <whoppix> ehird, maybe sometimes later.
18:43:24 <tensorpudding> irb is configurable but i'm a bit offput by the configuration part
18:43:26 <pikhq> Tcl's REPL is ridiculously barebones.
18:43:42 <pikhq> Tab completion? Bah.
18:43:52 <sshc> how do I specify a specific version of the GPL in a cabal package?
18:43:54 <pikhq> It's really just read eval print loop.
18:44:09 <ehird> sshc: GPL[23]
18:44:12 <whoppix> perls feature was based on the premise that nroff/groff ignores stuff it doesn't recognize, and then the perl interpreter would ignore nroff/groff commands, as far as I remember.
18:44:20 <ehird> preferred answer: something other than gpl :p
18:44:29 <sshc> ehird: why?
18:44:37 <tensorpudding> ideally, an interpreter should at least have history searching
18:44:40 <sshc> ehird: and if you were to use it, which version would you use?
18:44:47 <ehird> sshc: well, entirely separate from the GPL sucking, most Haskell libraries are non-GPL
18:44:51 <tensorpudding> so when you make an error, you can easily recall and fix the error
18:44:56 <ehird> so you won't fit in if you use the GPL and nobody will use your code
18:44:57 <cads> is there a web based lambdabot up anywhere dudes?
18:45:19 <ehird> sshc: if I were to use the GPL, I'd use v2, because v3 comes closer to implementing GPL's ideals, i.e. becomes more draconian, which I dislike. you'd have to ask someone who likes the GPL for a better answer
18:45:28 <pikhq> sshc: Also, nobody uses LGPL for Haskell.
18:45:42 <tensorpudding> BSD, MIT
18:46:02 <kmc_> tensorpudding, the super cheap hack is to run your REPL in rlwrap
18:46:08 <ehird> pikhq: he said GPL, not LGPL
18:46:10 <ehird> tensorpudding++
18:46:27 <pikhq> ehird: Yes, I'm just adding that the LGPL isn't used at all.
18:46:27 <tensorpudding> i see a few GPL stuff on hackage
18:46:36 <Ke> lgpl is kind of pointless until dynamic linking becomes moro commonplace
18:46:37 <ehird> tensorpudding: yeah but nobody uses it :-)
18:46:38 <pikhq> For the reason that, in Haskell, the LGPL is just about equivalent to the GPL.
18:46:38 <dino-> sshc: Docs for .cabal file fields http://www.haskell.org/cabal/release/cabal-latest/doc/users-guide/authors.html#general-fields
18:47:00 <ehird> Ke: that's why the lispers added a preface specifying that linking was just using the package in another package
18:47:06 <ehird> but seriously, liberal licenses ftw
18:47:22 <kmc_> PublicDomain
18:47:24 * ezyang uses LGPL for a project he wrote. 
18:47:25 <p_l> or unless you use LLGPL (the LGPL with lispers' addon)
18:47:38 <Ke> well I wouldn't give anything useful away without copyleft
18:47:42 <dino-> I've been using BSD3 quite a bit
18:47:47 <tensorpudding> most of my "random sample" seems to use BSD3
18:48:04 <ehird> I wish BSD2 was used rather than BSD3
18:48:14 <sshc> I'm still considering whether to use BSD or GPL2
18:48:20 <ehird> sshc: BSD!
18:48:25 <ehird> other people will love you instead of not loving you.
18:48:32 * Axman6 agrees with ehird 
18:48:38 * Axman6 will love you
18:48:38 <tensorpudding> Pandoc is GPL
18:48:45 <Ke> sshc: what are you licencing?
18:48:47 <ehird> at least pandoc isn't a library
18:48:47 <tensorpudding> and people like pandoc
18:48:50 <pikhq> sshc: It depends: what are you doing, and what do you care about regarding it?
18:48:51 <ehird> mostly
18:48:54 <tensorpudding> xmonad is BSD
18:48:57 <ehird> anyway, pandoc is just so good it cancels out
18:48:58 <ehird> :P
18:49:15 <sshc> an unfinished program that's not a library
18:49:31 <ehird> Then GPL is "acceptable", but if BSD is an option, go with BSD.
18:49:42 <tensorpudding> license it however you want
18:49:46 <ehird> If you're considering BSD, you're not so much of a zealot as to love GPL's restrictions enough to not consider anything else.
18:49:49 * whoppix agrees with ehird.
18:49:52 <ehird> So siding with the rest of the community is a good idea.
18:50:03 <whoppix> GPL should definitely not be used for library-type code.
18:50:06 <ehird> Besides, there are people who avoid contributing to GPL projects (like me), but not really anyone who won't contribute to BSD projects.
18:50:12 <ehird> whoppix: it's not a library, e said
18:50:34 <whoppix> Yeah.
18:50:50 <sshc> what are the differences between the licenses?
18:50:53 <tensorpudding> license debates are so tedious and stupid
18:51:01 <ehird> tensorpudding: he doesn't know which to use, we're helping
18:51:03 <ehird> chill
18:51:04 <Ke> heh, it has been rumoured that companies are more willing to invest in linux due to the copyleft
18:51:12 * Axman6 doesn't like restrictions, and as such, dislikes the GPL
18:51:13 <ehird> sshc: GPL requires all modified code to be licensed under the GPL, including code that just uses the code
18:51:19 <whoppix> tensorpudding, aren't they? Everything should just be free, and everyone should be fair.
18:51:23 <ehird> So if someone else uses some of your code in another program or library, they *must* license it under the GPL.
18:51:30 <whoppix> That would spare us all so much work.
18:51:37 <ehird> BSD, on the other hand, merely requires people to credit you when they use your code.
18:51:48 <tensorpudding> BSD is kinda stupid
18:51:57 <ehird> [02:50] <tensorpudding> license debates are so tedious and stupid
18:51:58 <ehird> [02:51] <tensorpudding> BSD is kinda stupid
18:52:06 <ehird> Congratulations; you're a hypocrite in 60 seconds.
18:52:12 <monochrom> Yeah, look who's flamebaiting.
18:52:19 <tensorpudding> hey, i have a reason
18:52:29 <tensorpudding> because MY OPINION IS OBVIOUSLY THE ONLY VALID ONE
18:52:30 <Ke> ehird: perhaps he's just bored
18:52:42 <kmc_> oh em eff gee
18:52:48 <ehird> whoppix: My preferred solution is to repeal copyright law. That way, we don't have to choose licenses, and nobody has to worry about commercial software. :p
18:52:54 <dino-> The problem is with a company that absolutely can't release their code, but is otherwise not acting in a creepy manner, and would like to use something that's GPL.
18:52:56 <tensorpudding> license debates are like debating religion
18:53:04 <kmc_> so, how do I convert an IO String into a String?
18:53:11 <ehird> dino-: No; the real problem is with people who want to write non-GPL open source code.
18:53:18 <sjanssen> kmc_: unsafeCoerce#
18:53:20 <dino-> They are then flat out prevented from using it in any way.
18:53:20 <ehird> They can't use GPL code; that's the most annoying thing.
18:53:23 <whoppix> ehird, but then people will steal your stuff, which isn't that good either.
18:53:26 <monochrom> (\_ -> "") converts an IO String into a String.
18:53:29 <ehird> sjanssen: that was _not_ the correct answer
18:53:33 <ehird> :P
18:53:56 <ehird> whoppix: Copying is not stealing... and I'm not getting into a copyright debate. (I do indeed support the abolition of copyright, though for less silly reasons than "no more license debates".)
18:54:01 <monochrom> @djinn m String -> String
18:54:01 <lambdabot> Error: Undefined type String
18:54:08 <monochrom> @djinn m a -> a
18:54:09 <lambdabot> -- f cannot be realized.
18:54:31 <ehird> kmc_: The answer nobody is telling you is that you can't; what you need to do is:
18:54:32 <whoppix> ehird, copying is not stealing, but copying something and telling people you made it, is.
18:54:38 <monochrom> @djinn m a -> Either c d
18:54:38 <lambdabot> -- f cannot be realized.
18:54:39 <ehird> do v <- myIOString; (v is now a String)
18:54:48 <tensorpudding> people use gpl vs. bsd as a means to evaluate whether code is worth using
18:55:01 <tensorpudding> instead of how good the code actually is
18:55:05 <ehird> whoppix: and repealing copyright doesn't mean we repeal $law_of_choice_that_stops_people_tainting_your_good_name
18:55:07 <kmc_> @protontorpedo
18:55:08 <lambdabot> on the haskell site they compare haskell to a spreadsheet
18:55:23 <whoppix> ehird, well, then I agree, I guess.
18:55:33 <kmc_> can you take this to #haskell-flamewar plz
18:55:34 <ehird> tensorpudding: Actually, I refuse to use GPL code not because the code is bad, but because it refuses to let me use it...
18:55:35 <tensorpudding> to satisfy some kind of ideological purity
18:55:48 <dino-> dons has spoken about this, specifically with work that Galois does. IIRC the issue is they do work under security clearance restrictions.
18:56:43 <tensorpudding> it refuses to let you use it?
18:56:44 <kmc_> gal-oils
18:57:14 <ehird> tensorpudding: My code isn't licensed under the GPL, so if I used GPL code, even just by linking my code to it instead of copying-and-pasting, I would be breaking the law.
18:57:26 <ehird> I'm not the one being restrictive and ideological there; the GPL is.
18:57:37 <tensorpudding> are you sure that is what the GPL specifically says?
18:57:50 <sjanssen> okay guys, it's time to take the language debate to #haskell-blah or #haskell-overflow
18:57:53 <dino-> @seen dons
18:57:53 <lambdabot> Unknown command, try @list
18:58:02 <tensorpudding> you mean the license debate, right?
18:58:04 <ehird> tensorpudding: do you understand the GPL? It requires derivative works, including linked programs, to be GPL-licensed. (and what sjanssen said)
18:58:22 <sjanssen> tensorpudding: erm yes, I do mean the license debate.  Weird how I got my wires crossed there
18:58:44 <dmwit_> :t error "bwahaha" :: IO String -> String
18:58:45 <lambdabot> IO String -> String
19:01:23 <kmc_> let askAStupidQuestion :: IO String -> String; askAStupidQuestion _ = error "get a stupid answer"
19:02:40 <ksf> ehird, you can _use_ GPL code for whatever you darn well please. it's the distributing that's restricted.
19:03:08 <monochrom> But of course ehird is distrubting.
19:03:35 <sshc> thanks guys.  I've chosen to go the BDS route because everybody else seems to like it, and because I don't want some of the restrictions people have mentioned in this channel.
19:04:04 <Ke> everyone else =oP
19:05:04 <sshc> most other haskellers / contributrs
19:05:36 <Ke> well BSD is obviously more convenient for haskell libraries
19:05:54 <dmwit_> Ke: I often let other people make my decisions, when it is clear that they know more/have invested more time in the problem, and that I don't care enough to invest that same time.
19:06:48 <Ke> yup, just going for the more complex lisencing strategies
19:07:05 <kmc_> go to #haskell-blah
19:07:06 <kmc_> please
19:08:06 <sshc> kmc_: #haskell-blah seems to want everything but Haskell, but licensing Haskell programs does, in fact, deal with Haskell.
19:08:55 <kmc_> only barely
19:09:08 <kmc_> discussing your favorite wine to drink whilst writing Haskell code would go in -blah
19:09:33 <kmc_> generally off-topic is tolerated here but not so much when it spawns a great big contentious argument
19:10:07 <ehird> kmc_: He was just asking what he should license his Haskell code under.
19:10:14 <ehird> That's relevant because of e.g. Haskell's community, common licenses, etc.
19:10:30 <kmc_> whatever
19:10:36 <kmc_> i will just ignore irc for a while
19:10:39 <kmc_> have fun gentlement
19:18:23 <ehird> Should an editor program be Text.EditorName or EditorName? Yi does the latter; the former is more hierarchical, though.
19:18:27 <ehird> But probably too verbose.
19:18:53 <kmc_> it only matters once per file
19:18:57 <kmc_> plus in meta-stuff
19:19:05 <monochrom> I don't know what belongs under Text.
19:19:53 <ehird> Setup.lhs is used instead of .hs so the shebang line can be added, right?
19:19:57 <ehird> Does anyone actually use that, I wonder...
19:20:19 <monochrom> Yes, someone actually use that.
19:20:23 <kmc_> ha, that's clever
19:20:29 <gwern> > 14 / 6
19:20:30 <lambdabot>   2.3333333333333335
19:20:35 <monochrom> Lots of README's say "runghc Setup.lhs configure"
19:20:38 <ehird> It mostly trips me up because I do "runhaskell Setup.hs "
19:20:44 <ehird> monochrom: Pointless; you can do that with .hs
19:20:48 <ehird> I'm talking about the #! line in the .lhs ones.
19:20:52 <monochrom> Oh oops sorry.
19:20:53 <ehird> That lets you do ./Setup.lhs 
19:21:09 <monochrom> OK I believe no one does it.
19:22:00 <roostaj> :t lift
19:22:01 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
19:22:19 <ehird> monochrom: Oh, it's done (e.g. mkcabal creates them), I'm just wondering if anyone uses it.
19:23:12 <monochrom> Perhaps dons uses it secretly. Who knows. I don't use it.
19:23:23 <Amigoo> :t flip
19:23:25 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
19:23:44 * dmwit_ has created .lhs scripts
19:23:46 <monochrom> I sometimes even ghc --make Setup so it's faster.
19:24:06 <roostaj> @src lift
19:24:06 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
19:24:39 <c_wraith> roostaj: it's a typeclass function.  the src depends on the type
19:25:07 <roostaj> c_wraith: ah I see.
19:25:09 <roostaj> thanks
19:25:35 <Saizan> ehird: hint: you can use "runghc Setup ..." it works with both .hs and .lhs
19:27:27 <ehird> Saizan: Yeah, but habits.
19:27:46 <monochrom> Setup<tab>
19:28:40 <gwern> > 14 / 5
19:28:41 <lambdabot>   2.8
19:31:46 <sjanssen> I just use 'cabal install' now
19:32:22 <ehird> sjanssen: probably a good idea
19:32:57 <monochrom> But suppose I develop a package (I haven't; hypothetical), I benefit from Setup too, it's a better make than make.
19:33:41 <monochrom> I mean edit -> Setup build -> debug cycle.
19:34:00 <dcoutts_> ehird: note that cabal-install 0.8 has a new "cabal init" which obsoletes mkcabal
19:34:25 <ehird> dcoutts_: othx
19:34:36 <dcoutts_> thank byorgey :-)
19:34:42 <gwern> dcoutts_: don't they both stink?
19:34:44 <ehird> ehird@meson:~/src/amend$ cabal init
19:34:46 <ehird> unrecognised command: init (try --help)
19:34:48 <ehird> ffffffffffffff
19:34:56 <ehird> All I has is 0.6.4
19:35:03 <ehird> upgrade time
19:35:20 <dcoutts_> gwern: both what stink?
19:35:31 <gwern> mkcabal and cabal init, naturlich
19:35:43 <monochrom> Good luck. Hope it won't break your "base >= ???" dependencies.
19:35:44 <gwern> iirc they hardwired a lot of stuff
19:35:52 <dcoutts_> gwern: mkcabal stinks, I think cabal init is pretty good
19:36:27 <dcoutts_> gwern: it lets us start people off with the currently recommended defaults, rather than people copying bad stuff from old .cabal files.
19:36:50 * gwern thinks we would've been better off doing things like building in a sdist by default
19:37:06 <dcoutts_> gwern: hmm?
19:37:22 <gwern> make sure the cabals actually work before we worry about defaults
19:38:06 <dcoutts_> gwern: oh sure, but I don't get to choose what volunteer Cabal hackers think is fun to work on
19:39:00 <ehird> I upgraded cabal and I still have 0.6.4.
19:39:04 <ehird> Is 0.8 not out yet?
19:39:14 <dcoutts_> ehird: cabal install 'cabal-install >= 0.8'
19:39:19 <ehird> o_O
19:39:20 <dcoutts_> ehird: 0.6.4 is still the default
19:40:08 <dcoutts_> gwern: so to a certain extent that means that we end up with people working on fun new features while I work on bug fixes, and since I'm rather busy...
19:40:29 <gwern> busy! bah! you don't have a life. you're some character on my screen
19:40:32 <gwern> set to, already
19:40:35 <dcoutts_> heh heh
19:40:57 <dcoutts_> anyway, I'm not really here, I'm somewhere in Chapter 3 of my thesis
19:41:20 <monochrom> Oh, you're some character in Chapter 3.
19:42:37 <sshc> monochrom: that's impossible because fictional characters cannot access IRC in real life
19:42:55 <monochrom> The impossible has just happened.
19:42:58 <whoppix> but if he's in a thesis, he is a real character.
19:43:03 <gwern> but wasn't chapter 3 about Pickwick's excursis to see some dinosaur bones which turned out to be cow bones? and the contretemps with a local John Bull?
19:44:27 <luite> how would you implement a cache for a function   readSomethingFromFile::FilePath -> IO SomeData, where this function would check if the file has been read before, and return the previously computed result if it was?
19:45:47 <monochrom> luite: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2951  two methods XD
19:46:31 <luite> ah I already read about the first one somewhere :)
19:46:34 <luite> or should that be :(
19:47:31 <luite> I'm afraid the second one wouldn't even work on windows
19:47:47 <monochrom> I would not mind if you just added an unsafePerformIO to create a global variable.
19:48:43 <monochrom> x = unsafePerformIO (newIORef Nothing)
19:49:42 <luite> that looks like a more practical solution :)
19:49:46 <monochrom> In readSomethingFromFile, read that IORef. If Nothing, read from file, put a Just value back. If Just x, you have cached x.
19:50:21 <monochrom> And I forgot a necessary pragma to increase safety. Is it NOINLINE?
19:50:31 <Axman6> hmm, has anyone worked on making say an HTML DSL that uses the type system to enforce the correct elements to be contained inside each other?
19:50:53 <Saizan> Axman6: yes
19:50:54 <Axman6> so, the type system would tell you when you're an idiot and put a Doctype tag in the Body
19:51:10 <Saizan> WASH had that years ago, afaiu
19:51:52 <thoughtpolice> Axman6: just a sec,
19:51:54 <monochrom> Text.Html does it too I believe? At least it distinguishes elements from attributes.
19:52:59 <Axman6> well, i mean, so you can't put a TR inside a DIV without it being inside a TABLE tag
19:53:11 <ehird> Axman6: yeah, been done
19:53:16 <ehird> basically you make every element its own type
19:53:24 <ehird> and use [IsHTML a => a] for children, etc
19:54:38 <Saizan> [IsHTML a => a] is most likely isomorphic to [Void]
19:54:52 <monochrom> OK, Text.Html does not make that distinction.
19:54:53 <ehird> Not with some GHC extension or another
19:54:59 <ehird> Oh
19:55:01 <ehird> it's actually
19:55:04 <thoughtpolice> Axman6: hm, there was a library somewhere I saw announced on -cafe that went to great lengths to use the type system to generate valid html
19:55:09 <ehird> data HTML a = ishtml blah blah
19:55:10 <ehird> ofc
19:55:11 <thoughtpolice> can't seem to locate it now
19:55:15 <ehird> and you have e.g. ul be HTML . UL
19:55:44 <Saizan> (though i think WASH did this without existentials)
19:55:48 <gwern> http://scienceblogs.com/goodmath/2010/01/zippers_making_functional_upda.php
19:55:57 <gwern> wonder how haskell zippers deal with balancing
19:56:15 <gwern> iirc I don't remember anyone covering them at any length
20:00:02 <Saizan> zippers are orthogonal concept
20:00:07 <Saizan> +an
20:01:04 <gwern> feel free to explain how mark's off-base here: http://www.reddit.com/r/programming/comments/ape4b/zippers_making_functional_updates_efficient/
20:02:26 <Saizan> that's a full time job :)
20:03:03 <ehird> is he known for being wrong about haskell or sth?
20:03:09 <ehird> Is -O2 default in cabal now?
20:03:18 <ehird> or do i need to specify it in ghc options
20:03:44 <gwern> ehird: -01 is default
20:04:05 <gwern> dcoutts turned off -02 when he decided it was expanding buildtimes for minimal gains
20:04:15 <ehird> *O, dammit :P
20:04:20 <ehird> Also, alright.
20:04:27 <ehird> So I shouldn't do GHC-options: -O2 unlses I see the need?
20:04:54 <Saizan> yeah
20:05:08 <monochrom> My programs are toys so I don't mind -O2 taking longer :)
20:05:56 <gwern> ehird: cabal check will complain as well
20:06:13 <gwern> personally, O
20:06:19 <gwern> I'd set it in my cabal config
20:06:47 <ehird> complain about what?
20:07:10 <ehird> grr, my synopsis _just_ overflows the line
20:07:12 <monochrom> "optimization: True" is default in $HOME/.cabal/config
20:07:14 <ehird> so I get a blank line in emacs for no reason
20:07:41 * ehird just wraps it
20:08:01 <gwern> ehird: cabal check, if you sepcif ghc-options : -02, will warn about it being unnecessary and occasionaly painful
20:08:25 <gwern> so, easier to leave it out
20:08:32 <ehird> Setup.hs: /home/ehird/.cabal/lib/process-1.0.1.2/ghc-6.10.4/HSprocess-1.0.1.2.o: unknown symbol `sysErrorBelch'
20:08:34 <ehird> That doesn't sound so good.
20:09:55 * ehird wonders what the canonical names are for cabal fields. Foo-bar? foo-bar? Foo-Bar?
20:10:02 <ehird> It complains about missing Main-Is, so I guess Foo-Bar.
20:12:12 <Saizan> gwern: the fundamental issue is that rebalancing makes sense only for search trees, while trees are used for much more, especially in functional languages.
20:22:30 <Saizan> do zipper have any advantage, given the usual interface for search trees?
20:23:00 <Veinor> you can go to the bathroom drunk without fumbling with a button?
20:23:01 <Veinor> I mean
20:25:28 <Saizan> sure
20:51:32 <nolrai_FG> @type Map.insert
20:51:34 <lambdabot> Couldn't find qualified module.
20:51:45 <nolrai_FG> @type Data.Map.insert
20:51:46 <lambdabot> forall k a. (Ord k) => k -> a -> M.Map k a -> M.Map k a
20:53:29 <nolrai_FG> wow its dead here
20:54:19 <tommd> > reverse "wow its dead here"
20:54:20 <lambdabot>   "ereh daed sti wow"
20:54:40 <andrewsw> hi tommd
20:54:49 <tommd> Hi andrewsw!
20:54:52 <tommd> How goes!
20:54:56 <ehird> we're all arguing licenses in -blah
20:55:02 <andrewsw> Same ol'... trying to graduate
20:55:08 <andrewsw> you?
20:55:12 * tommd is glad he isn't looking at -blah right now.
20:55:32 <tommd> andrewsw: Research and playing with my latest toy
20:55:45 <andrewsw> do tell?
20:55:57 <tommd> a touchbook (open, ARM based netbook)
20:56:14 <tommd> http://www.alwaysinnovating.com/touchbook/
20:56:30 <ehird> "Power-hungry Intel Atom"
20:56:33 <ehird> 4 watts is so power hungry
20:56:34 <tommd> So now I suddenly care when people assume all computers are x86
20:56:57 <tommd> ehird: Yeah, well.  People need to eat and techies at least market better than marketers.
20:57:12 <ehird> heh their faq link on the home page links to a page that says "actually the faqs are here"
20:57:32 <ehird> that white hunge is uber ugly
20:57:47 <tommd> lol - yeah, I've always felt they could stand to update/maintain the site better.  But this belongs in -blah.
21:01:33 <Axman6> ehird: compared to the ARMs, 4 watts is massive
21:01:47 <ehird> but hardly power hungry
21:02:06 <Axman6> less watts = more runtime
21:02:38 <dmwit> less watts often also = slower run
21:03:45 <Axman6> i find it interesting that ARMs alsmost always have a native java bytecode processing area.... thing... i lsot track of what i was saying
21:03:49 <Axman6> lost*
21:04:24 <mtnviewmark> I have a profiling question: I've got an executable that uses both the text package and the hexpat package -- both are installed with library profiling enabled --- when I build my executable with profiling, and run it +RTS -p, I see profiling details for functions in the text package, but not hexpat  --- why? what determines which libs will be included in the profiling detail, and which not?
21:04:54 <p_l> Axman6: it kinda got stuck there, but I think it's only placed on mobile SoCs that get often used in phones. I don't think I had seen it in some "heavier" models like PXA
21:04:58 <mtnviewmark> (profiling with GHC, if that wasn't clear)
21:05:30 <Axman6> fair enough
21:06:03 <Axman6> i'm looking forward to this new platform nvidia are bringing out, uses something like 500 mWs, with an ARM Cortex A9 dual core processor
21:07:30 <p_l> Axman6: dual cores are popular with ARM :)
21:07:42 <p_l> though usually assymetric
21:08:17 <Axman6> these Cortex A9 procs are looking very interesting, multiple cores, up to 2.4GHz, and using like 2W
21:09:22 <p_l> Axman6: depends on what you want to use them... I'm not sure if I'd go with it for scientific computation (but I had seen some 900mW @ full power MIPS64 multicore cpus... mmm)
21:09:49 <kaol> Too bad there's little chance of seeing them anywhere as long as wintel dominates.
21:10:01 <Axman6> i doubt it would, but it'd make great laptops, and even servers
21:10:13 <Axman6> Amazon are interested in using them for servers to save (a lot) of power
21:10:39 <kaol> Can't run viruses and antiviruses on them.
21:10:40 <p_l> Axman6: for servers, SPARC T1/T2 looks quite nice (and if you're using Erlang, it propably kicks ass and takes names)
21:10:48 <Axman6> indeed :)
21:10:55 <Axman6> i love playing with our uni's T2 :)
21:11:17 <Amigoo> how do u make a keylogger?
21:11:28 <p_l> Amigoo: you log keys ;-)
21:11:38 <Axman6> first you buy an axe
21:11:55 <Amigoo> I want to know if my brother's been going to "porno.com"
21:12:05 <dmwit> We don't want to help you.
21:12:09 <Amigoo> he likes to erase the history
21:12:13 <mental> Amigoo: yes. He has.
21:12:15 <mental> Many times.
21:12:19 <dmwit> Just ask him.
21:12:23 <Axman6> and probably many more
21:12:33 <mtnviewmark> don't give him the password to your accoun!
21:12:42 <dmwit> If you aren't enough of an adult to do that (or he isn't enough of an adult to answer), then perhaps you should just stop caring.
21:12:44 <Axman6> instsall a proxy
21:12:46 <p_l> Amigoo: ask on network security forums about network surveillance, or better yet, have a heart-to-heart with your brother. And now stop asking such topics on #haskell
21:13:20 <Axman6> Amigoo: also, such software is very possibly illegal
21:13:34 <Amigoo> I am using it for my own computer
21:13:38 <Axman6> so?
21:14:13 <mtnviewmark> SOoooooo back to Haskell - anyone with any ideas about my profiling question?
21:14:26 <dibblego> @seen bos
21:14:27 <lambdabot> Unknown command, try @list
21:14:40 <dmwit> mtnviewmark: You get profiling details for the libraries that you built with profiling, of course.
21:14:45 <Axman6> preflex_: seen bos
21:14:46 <preflex_>  bos was last seen on #haskell 1 day, 51 minutes and 47 seconds ago, saying: i think he misunderstands when evaluation occurs.
21:15:05 <mtnviewmark> seems not true - as both hexpat and text had to be built with profiling so that I could even link my executable
21:15:28 <dmwit> um
21:15:37 <mtnviewmark> (seems if your executable is built profiling, then EVERYTHING it links with must be built profiling)
21:15:48 <mtnviewmark> (at least in GHC w/cabal)
21:17:00 <cads> okay so I just wrote my ex a miniessay on the fibonacci numbers for her birthday because she loved them - it was about how to convert miles to kilometers using the fib series and its a cute anecdote
21:17:26 <cads> but I can't help but feel there's a special place in hell for exes like me that are persistent and annoying :/
21:18:04 <mtnviewmark> the real question is: did you express the method in Haskell?  :-)
21:18:13 <mtnviewmark> with a monad?
21:18:15 <cads> yes.
21:18:19 <cads> in the paper.
21:18:24 <cads> is that ok?
21:18:39 <mtnviewmark> well then, yes, yes there is a special place in hell for exes who are persistent with Haskell!
21:19:10 <cads> hahah, no I didn't use haskell for anything other than showing myself that the method works and calculating some bounds on error
21:19:32 <cads> the bounds did not go into the paper, it was just to convince myself the method was sound
21:20:02 <dibblego> so er #python is a lost cause
21:20:35 <Axman6> on to python#!
21:20:43 <dibblego> @type \p z -> if p then id else z -- can anyone tell me how to write this in python? (with correct termination conditions)
21:20:44 <lambdabot> forall a. Bool -> (a -> a) -> a -> a
21:21:15 <idnar> dibblego: p or z
21:21:29 <dibblego> great thanks
21:21:41 <Twey> lambda p z: id if p else z
21:21:43 <Twey> Surely
21:22:00 <Twey> p won't/mightn't be a function, and certainly not of one argument
21:22:04 <Twey> (as id)
21:22:14 <CESSMASTER> dibblego: :)
21:22:16 <idnar> oh, right
21:22:26 <dibblego> CESSMASTER?
21:22:28 <idnar> I misread dibblego's code completely
21:22:32 <Twey> Heh
21:22:46 <CESSMASTER> dibblego: the best I can do to troll #python is to make Jersey Shore jokes about Guido's name
21:22:59 <idnar> Python's id() function does something completely to Haskell's, though
21:23:02 <dibblego> CESSMASTER, ok
21:23:07 <Twey> idnar: Really?
21:23:15 <Twey> Oh
21:23:17 <Twey> Haha!
21:23:19 <Twey> Yes
21:23:21 <idnar> Twey: id(x) is the memory address at which x is allocated
21:23:26 <Twey> Oops
21:23:34 <idnar> so...
21:23:39 <mtnviewmark> >>> id(42)
21:23:39 <mtnviewmark> 8404380
21:23:43 <mtnviewmark> from python!
21:23:48 <idnar> lambda p, z: (lambda x: x) if p else z
21:23:54 <cads> "magcius: _habnabit, the only thing worse than Haskell is OCaml"
21:23:56 <idnar> but that seems like a really strange function
21:23:57 <Twey> lambda p, z: (lambda x: x) if p else z
21:23:58 <Twey> Yeah
21:24:02 <Twey> Yeah
21:24:04 <cads> "ironfroggy: ocaml is bettar cuz it have two semicolons! MOAR SEMICOLON!"
21:24:06 <Twey> It's a bit of a direct translation
21:24:10 <idnar> I really hope "p or z" is what dibblego actually wants
21:24:24 <dibblego> idnar, what is p or z exactly and why would you hope that?
21:24:58 <Twey> cads: >.<
21:25:09 <idnar> "p or z" is "p if p else z"
21:25:15 <Twey> For a language that stole most of its cool stuff from Haskell, you'd think its followers would have more respect ;)
21:25:21 <idnar> I hope that because it's a lot shorter and simpler than that other thing
21:25:33 <mtnviewmark> idnar - they mean two totally different things
21:25:33 <dibblego> idnar, I don't want that
21:25:35 <idnar> and I'm terrified to imagine why you would want the other thing
21:25:36 <dmwit> idnar: That doesn't really sound as useful as dibblego's.
21:25:38 <idnar> mtnviewmark: yeah, I know
21:25:45 <idnar> dibblego: oh well, pity
21:25:58 <dibblego> idnar, I use it all "that other thing" time, in more practical languages
21:26:41 <mtnviewmark> here's an example       priceFunction = dibblegosFn (numBooks > 4) discountFunction
21:28:01 <idnar> I'd probably rename "z" to "f" at any rate
21:28:09 <idnar> mtnviewmark: yeah, fair enough, I suppose
21:28:09 <dibblego> I did :)
21:28:15 <idnar> mtnviewmark: that sort of thing is really awkward in Python, though
21:28:24 <mtnviewmark> true 'nuf
21:28:43 <mtnviewmark> just think how awkward Maybe is in C++!
21:28:58 <idnar> without currying and sections, you end up writing a lot of lambdas, which is a lot of typing and reading
21:29:03 <dibblego> Maybe is easy with HOFs
21:29:26 <idnar> mtnviewmark: it's bad enough in Python; every other day I wish I had Maybe in Python, but so far I haven't been able to come up with an implementation that's of any value
21:30:33 <mtnviewmark> Maybe is the boss!
21:30:36 <idnar> Need Do Syntax
21:31:06 <mtnviewmark> I was trying to explain to a coworker about the experience of coding in Haskell
21:31:17 <jmcarthur> the church encoding for lists looks like foldr. the church encoding for what look like foldl? is it lists, too?
21:31:31 <Twey> idnar: http://www.valuedlessons.com/2008/01/monads-in-python-with-nice-syntax.html?
21:32:20 <jml> Twey, idnar, deferreds are monads in Pythno
21:32:24 <jml> Python, rather.
21:32:27 <idnar> Twey: I've seen the generator thing before, but pretty much any abuse of generators like that gets insane
21:32:37 <idnar> in a pure language it might be fine, but in Python...
21:32:44 <idnar> jml: no, deferreds are a monad
21:32:57 <mtnviewmark> "When my C++ doesn't compile, the fixes feel like book-keeping. When my Haskell doesn't compile, I'm fixing bugs before they happen."
21:33:25 <idnar> the deferred monad is something like ErrorT IO
21:33:26 <jml> idnar, yes, that's what I meant.
21:34:01 <jml> idnar, yeah, I haven't figured out how exceptions & errbacks fit into it.
21:34:02 <Twey> jml: Not a general-purpose tool for working with monads, but a single type that is itself a monad
21:34:08 <Twey> (so no good for Maybe, for example)
21:34:54 <jml> Twey, well, I've never tried. :)
21:35:33 <jml> certainly I've wondered whether Twisted's inlineCallbacks stuff could have been written more generally
21:36:27 <j4cbo> call/cc!
21:36:54 <idnar> well
21:37:05 <idnar> somebody blogged about how all you need is the Cont monad
21:37:17 <idnar> although generators aren't quite Cont
21:37:31 <jml> Twey, is that article ever followed up with "should"?
21:37:39 <idnar> http://blog.sigfpe.com/2008/12/mother-of-all-monads.html
21:37:40 * hackagebot upload: full-sessions 0.6.1.2 - a monad for protocol-typed network programming (KeigoImai)
21:37:51 <Twey> No idea
21:37:57 <Twey> Oooh, that looks nice
21:38:20 <Axman6> @hackage full-sessions
21:38:21 <lambdabot> http://hackage.haskell.org/package/full-sessions
21:38:47 <mxc> is haskellmode for emacs really that much better than vim?
21:39:15 <j4cbo> yeah, generators are a sad substitute for callcc
21:39:25 <tensorpudding> mxc: It's a very personal preference
21:39:30 <gpogo> I'm having an issue installing cabal on debian via the tarball from hackage.  It says it, "Could not find module `Codec.Compression.GZip' "  anyone run into this?
21:39:38 <Twey> Really?  I don't think the vim mode has many features at all, does it?
21:39:57 <tensorpudding> mxc: If you don't like emacs, you won't like haskell-mode that much.
21:40:00 <mxc> tensorpudding : right.  I much prefer vim over emacs, but if emacs haskell is dramatically better, i might use emacs/viper
21:40:36 <mxc> besides the semi-automatic indenting, it doesn't seem to have anything that haskellmode for vim doenst
21:40:41 <tensorpudding> mxc: Then I say you try using emacs for a while, and start the old-fashioned way by reading the emacs tutorial
21:40:44 <mxc> but i hear people raving about it so much
21:40:48 <Twey> gpogo: Doesn't your distribution's package manager have a package?
21:43:03 <Axman6> @index printf
21:43:04 <lambdabot> Text.Printf
21:43:26 <gpogo> Twey: for zlib? yes, and I have the dev.  or are you suggesting a debian cabal package?  I'm on lenny
21:45:58 <Twey> No, for Cabal
21:47:41 <gpogo> Twey: I don't think it does, but I may be mistaken.  There is a package 'libhugs-cabal-bundled' but that doesn't seem to result in a cabal command.  There is one in testing, but I'm on stable
21:55:35 <Ke> so http://hackage.haskell.org/packages/archive/time/1.1.4/doc/html/Data-Time-LocalTime.html ZonedTime is listed with intance of Read but ghc finds none
21:55:46 <Ke> neither can I looking at the code
21:55:57 <Ke> is this a bug or do I just suck
22:00:05 <kmc_> the instance might come from somewhere wacky
22:00:32 <Ke> so I should grep or what?
22:00:57 <kmc_> that's what i would do :/
22:01:07 <kmc_> not exactly ideal
22:04:51 <Ke> time-1.1.4/Data/Time/Format/Parse.hs:instance Read ZonedTime where
22:05:01 <Ke> so how do I include that
22:05:41 <kmc_> import Date.Time.Format.Parse ?
22:05:49 <kmc_> err Data.*
22:08:08 <Ke> Data.Time seems to work
22:08:41 <tensorpudding> Why is Time in Data?
22:08:42 <Ke> I guess the author assumed that everyone would just import that or so
22:09:04 <Axman6> tensorpudding: what else would it be?
22:09:16 <Axman6> (System makes as much sense i thing)
22:09:24 <Ke> so is this a bug?
22:09:53 <Ke> should  "import Data.Time.LocalTime(ZonedTime(..))" make read available
22:11:02 <tensorpudding> System would make sense
22:11:25 <tensorpudding> since it is something that ultimately they read the system clock for right?
22:12:28 <Axman6> it's not just that though, it has things for working with it as Data
22:12:35 <Axman6> s/D/d
22:12:59 <tensorpudding> Eh, I guess so.
22:15:03 <Ke> wow, I found the contents link from hackage, that helps a lot
22:16:54 <roostaj> @src liftM
22:16:55 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
22:18:59 <Ke> :t withFile filename ReadMode hGetContents
22:19:01 <lambdabot> Not in scope: `withFile'
22:19:01 <lambdabot> Not in scope: `filename'
22:19:01 <lambdabot> Not in scope: data constructor `ReadMode'
22:19:28 <Ke> :t withFile "filename" ReadMode hGetContents
22:19:29 <lambdabot> Not in scope: `withFile'
22:19:30 <lambdabot> Not in scope: data constructor `ReadMode'
22:19:30 <lambdabot> Not in scope: `hGetContents'
22:25:18 <sproingie> lambdabot is missing a lot of IO
22:26:15 <c_wraith> :t System.IO.withFile
22:26:16 <lambdabot> forall r. FilePath -> GHC.IOBase.IOMode -> (GHC.IOBase.Handle -> IO r) -> IO r
22:26:23 <c_wraith> not missing, just imported qualified
22:34:04 <sinelaw> my new motto for haskell:
22:34:10 <sinelaw> "It's fun to have fun, but you have to know how!"
22:34:19 <MaxNanasy> lol
22:34:20 <sinelaw> - (The Cat in the Hat)
22:36:58 <tensorpudding> Haskell is not like the Cat in the Hat, it does its own garbage collection
22:38:34 <sinelaw> tensorpudding, he does too! didn't you read it to the end?
22:38:53 <tensorpudding> Maybe I forgot.
22:39:24 <sinelaw> tensorpudding, he came back with that thing that has protruding arms and fixed everything in a minute
22:39:58 <tensorpudding> That sounds not very Haskell.
22:40:42 <sinelaw> tensorpudding, it's late garbage collection. typical space leak that only gets cleared up when the program terminates
22:41:01 <sinelaw> you can say he left of unevaluated thunks lying around
22:42:47 <sinelaw> actually i know more about the cat in the hat than about haskell, so....
22:45:11 <cjs> Is there some equivalant to hton (htonl(3)) available? I need to get the individual bytes of a Network.Socket.HostAddr, and it seems to be in host format.
22:46:13 <cjs> (HostAddress is a type alias for Word32.)
22:53:35 <cjs> No thoughts? No ideas on a way even to tell the endianness of my host?
22:56:37 <tommd> cjs
22:56:41 <tommd> Use binary
22:56:43 <sinelaw> can I define <,> as an infix op?
22:57:14 <tommd> {get,put}Word{16,32,64}{le,be}
22:57:18 <tensorpudding> > let (<,>) = (+) in 1 <,> 1
22:57:18 <tommd> cjs ^^^
22:57:19 <lambdabot>   <no location info>: parse error on input `,'
22:57:52 <tensorpudding> > let a <,> b = a + b in 1 <,> 1
22:57:53 <lambdabot>   <no location info>: parse error on input `,'
22:57:58 <tensorpudding> guess not
22:58:09 <sinelaw> that's what i suspected....
22:58:33 <tensorpudding> not sure why
22:58:33 <sinelaw> @hoogle (<>)
22:58:34 <lambdabot> Text.PrettyPrint.HughesPJ (<>) :: Doc -> Doc -> Doc
22:58:34 <lambdabot> Language.Haskell.TH.PprLib (<>) :: Doc -> Doc -> Doc
22:58:46 <sinelaw> tensorpudding, the comma break the syntax somehow
22:58:51 <sinelaw> *breaks
22:58:59 <tensorpudding> @hoogle (>>)
22:58:59 <lambdabot> Prelude (>>) :: Monad m => m a -> m b -> m b
22:59:00 <lambdabot> Control.Monad (>>) :: Monad m => m a -> m b -> m b
22:59:00 <lambdabot> Control.Monad.Instances (>>) :: Monad m => m a -> m b -> m b
22:59:03 <tensorpudding> @hoogle (>>>)
22:59:04 <lambdabot> Control.Arrow (>>>) :: Category cat => cat a b -> cat b c -> cat a c
22:59:04 <lambdabot> Control.Category (>>>) :: Category cat => cat a b -> cat b c -> cat a c
22:59:09 <tensorpudding> @hoogle (>>>>)
22:59:09 <lambdabot> No results found
23:00:26 <cjs> tommd: Data.Binary?
23:01:29 <tensorpudding> @hoogle getWord32
23:01:29 <lambdabot> No results found
23:01:45 <tensorpudding> @hoogle Word32
23:01:45 <lambdabot> Data.Word data Word32
23:02:19 <tensorpudding> ah, the package binary
23:03:07 <tensorpudding> contains Get and Put monads for parsing and producing lazy bytestrings
23:03:37 <tensorpudding> http://hackage.haskell.org/packages/archive/binary/0.5.0.2/doc/html/Data-Binary-Get.html#v%3AgetWord32host
23:22:20 <cjs> Right, but that's not what I need.
23:22:39 <cjs> I need to get four Word8s out of a Word32, in network byte order.
23:28:52 <kmc_> cjs, i know hackish ways to get endianness
23:29:21 <kmc_> a pointer cast from (Ptr Int) to (Ptr Word8)
23:29:24 <kmc_> same as you'd do in C
23:30:14 <tensorpudding> you could make some bit-twiddling hack using Data.Bits
23:32:38 <fishey> cjs: why?
23:32:40 <cjs> kmc_: Yeah, I was heading towards that. But then I just decided it wasn't worth it, and I'll just let it break on big-endian hosts and should a HostAddress ever come back in network byte order on a little-endian host.
23:33:08 <cjs> The consequences of the error are not terribly severe, probably trivial, so....whatever.
23:33:11 <fishey> nvm.
23:44:19 * hackagebot upload: hesql 0.8 - Haskell's embedded SQL (ChristophBauer)
23:45:02 <Amigoo> @src map
23:45:02 <lambdabot> map _ []     = []
23:45:03 <lambdabot> map f (x:xs) = f x : map f xs
23:47:59 <fishey> cjs: use inet_ntoa
23:48:07 <fishey> and then muck with the sting.
23:48:47 <Twey> Ew
23:49:56 <fishey> Network .Socket isn't meant to be pretty (from what I understand)
23:52:06 <cjs> fishey: I thought about that, too. But also just a little more pain than it's worth.
23:52:36 <cjs> Network.Socket is meant to provide the POSIX API. It's pretty enough, I suppose, if you're used to that sort of thing. (I am.)
23:53:03 <Amigoo> @src filter
23:53:04 <lambdabot> filter _ []     = []
23:53:04 <lambdabot> filter p (x:xs)
23:53:04 <lambdabot>     | p x       = x : filter p xs
23:53:04 <lambdabot>     | otherwise = filter p xs
23:54:33 <tensorpudding> Amigoo: don't forget to check out foldr
23:56:25 <fishey> cjs: which brings the question, why are you using it?
23:56:47 <fishey> (or "why do you need the address?")
23:59:45 <Amigoo> :t filter
23:59:46 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
