00:00:01 <kmc> when variables appear in patterns, they are for binding
00:00:08 <alex404> Got it.
00:00:14 <newsham> because data Int = 0 | 1 | 2 | 3 | ... | -1 | -2 | -3 | ...
00:00:15 <Paczesiowa> lucky is a variable, just like x or n
00:00:22 <newsham> (sort of)
00:00:24 <kmc> 7 is one of the constructors of Int
00:00:29 <kmc> and you can pattern match on constructors
00:00:36 <alex404> Ahhh...
00:00:39 <alex404> Interesting.
00:00:51 <elspru> > (chr . ord) '6'
00:00:53 <lambdabot>   '6'
00:01:04 <elspru> > chr  (ord '6')
00:01:06 <lambdabot>   '6'
00:01:13 <tensorpudding> unfortunately, you can't easily create your own numeric types
00:01:14 <kmc> @check \n -> (chr . ord) n == n
00:01:15 <lambdabot>   "OK, passed 500 tests."
00:01:18 <newsham> ?check \c -> (chr.ord) c == c
00:01:19 <lambdabot>   "OK, passed 500 tests."
00:01:24 <elspru> seems like the . just like typing an extra letter
00:01:26 <kmc> tensorpudding, for pattern matching you mean?
00:01:36 <kmc> elspru, it's useful in higher order contexts
00:01:42 <kmc> > map (not . isAlpha) "Hello, world!"
00:01:44 <lambdabot>   [False,False,False,False,False,True,True,False,False,False,False,False,True]
00:02:02 <Paczesiowa> hackagebot is back, does that mean hackage should follow?
00:02:09 <tensorpudding> i was thinking more of, making a type that was an instance of Num that represents integers between 0 and 360, for instance
00:02:13 <kmc> (f . g) is a function in its own right; you can do things with it besides immediately apply an argument
00:02:41 <elspru> hmmm
00:03:36 <elspru> > map ( (* 2) . ord ) "hey yo"
00:03:37 <lambdabot>   [208,202,242,64,242,222]
00:03:41 <elspru> o
00:03:45 <newsham> ?let ext f g x = f x == g x
00:03:45 <lambdabot>  Defined.
00:03:53 <newsham> ?check ext id (chr.ord)
00:03:54 <lambdabot>   Not in scope: `ext'
00:03:57 <newsham> bummer
00:04:07 <kniu> I remember reading somewhere that before the introduction of the IO Monad,
00:04:22 <kniu> one way of defining input-output was via lists.
00:04:26 <kniu> how would that work?
00:04:30 <Paczesiowa> kniu: dialogs
00:04:36 <mauke_> kniu: lazily
00:04:39 <Axman6> was that stream based IO?
00:04:42 <kniu> treat the inputs and outputs as streams?
00:04:57 <mauke_> kniu: you return a list of IO requests from main
00:05:03 <newsham> ?check let ext f g x = f x == g x in ext id (chr.ord)
00:05:04 <lambdabot>   "OK, passed 500 tests."
00:05:09 <newsham> ?check let ext f g x = f x == g x in ext id (ord.chr)
00:05:10 <lambdabot>   "* Exception: Prelude.chr: bad argument
00:05:16 <mauke_> kniu: e.g. main = [putStr "what's your name: ", getLine]
00:05:31 <kniu> huh.
00:05:38 <kniu> I was rather thinking something like
00:05:45 <mauke_> kniu: but that's only one half. you get the results of your requests back as arguments to main
00:05:50 <kniu> main :: [Input] -> [Output]
00:05:56 <mauke_> exactly
00:06:18 <kmc> this is really tricky
00:06:25 <kmc> for anything interactive
00:06:32 <mauke_> main xs = [putStr "what's your name: ", getLine, putStrLn ("hello, " ++ head xs)]
00:06:32 <kmc> because you might force too much and block
00:06:42 <kmc> well, not quite
00:07:06 <kmc> ah yes
00:07:07 <kniu> so, somehow, the programmer needs to keep in this head where exactly in the input list he "is"?
00:07:12 <kmc> with the result via xs rather than >>=
00:07:13 <mauke_> yes
00:07:40 <kmc> however, monads are still not necessary for IO
00:07:53 <kmc> in that you can write down (>>=) :: IO a -> (a -> IO b) -> IO b as a reasonable IO combinator
00:07:57 <kmc> and use it fine
00:08:03 <kmc> and never notice that it forms a monad
00:08:53 <newsham> if a programmer doesnt notice its a monad is it still a monad?
00:09:37 <kniu> math is absolute, so yes.
00:09:48 <kniu> someone will notice it eventually.
00:10:37 <newsham> now what if you put that person in a box rigged to release poison if a radioactive nucleus decays, but you dont peak in the box?
00:11:00 <kmc> i'm not so sure
00:11:01 <medfly> peek?
00:11:12 <newsham> no piquing.
00:11:19 <newsham> i'm obviously too tired to irc :)  g'nite
00:11:24 <Ramchip> :t nub
00:11:26 <lambdabot> forall a. (Eq a) => [a] -> [a]
00:12:56 <Ramchip> oh... removes duplicates. I expected worse.
00:13:24 <kniu> strange, indecipherable name that is.
00:13:33 <kmc> :t noob
00:13:34 <lambdabot> Not in scope: `noob'
00:13:47 <kniu> :t nublet
00:13:49 <lambdabot> Not in scope: `nublet'
00:15:39 <Ramchip> nub removes noobs indeed
00:18:03 <kmc> or perhaps summons them
00:18:18 <kmc> hard to tell
00:19:49 <lifflander> I'm trying to get the latest version of parsec. This path doesn't work: http://hackage.haskell.org/packages/archive/parsec/3.0.1/parsec-3.0.1.tar.gz. Do you know what will work?
00:20:15 <tensorpudding> it seems to be the general consensus that hackage is down or something
00:20:21 <tensorpudding> it'll be back
00:21:01 <lifflander> Is there another path to it?
00:21:48 <lifflander> I left by accident
00:22:12 <shambler> try your's distro packet manager
00:22:21 <elspru> how to round up?
00:22:24 <merehap> package*
00:22:28 <shambler> ye
00:22:34 <merehap> > ceiling 3.5
00:22:35 <lambdabot>   4
00:22:43 <elspru> k :)
00:23:04 <elspru> excellent :)
00:23:30 <merehap> assuming you mean always up, otherwise there is round
00:23:35 <lifflander> shambler: I am running mac os x
00:23:41 <shambler> oh :(
00:23:50 <merehap> > round 3.4999
00:23:51 <lambdabot>   3
00:23:54 <lifflander> macports does not have haskell packages
00:24:12 <elspru> what package is cieling a part of?
00:24:13 <Axman6> it has some
00:24:20 <HaskellLove> I am reading the Haskell Guide: "Considerably improved support for parallel execution." Can someone talk more about that quote? People use Haskell on multi-core PCs?
00:24:20 <Axman6> Prelude
00:24:39 <Axman6> HaskellLove: a lot, yes
00:24:42 <Cale> elspru: It's in the Prelude, so the package 'base'
00:25:00 <Axman6> HaskellLove: which you would have learnt by now if you weren't so focused in project euler
00:25:21 <elspru> Parser.hs:44:16: Not in scope: `cieling'
00:25:22 <Axman6> in face, knowing about the parallel parts of haskell can make doing project euler easier and more fun
00:25:28 <Axman6> in fact*
00:25:36 <Axman6> elspru: ceiling
00:25:40 <merehap> > ceiling 3.5
00:25:40 <elspru> o
00:25:41 <lambdabot>   4
00:25:42 <merehap> :)
00:25:45 <HaskellLove> Axman6 why would i need parallel when i have one processor only
00:26:06 <Axman6> you wouldn't
00:26:17 <Axman6> but if you did, it would be very helpful
00:26:19 <Cale> HaskellLove: Yeah, GHC has great support for SMP parallelism and concurrency.
00:26:24 <shambler> HaskellLove, and it have one core?
00:26:49 <lifflander> Unless you have slow accesses
00:27:01 <Axman6> ?
00:27:16 <lifflander> Bad temporal or spatial locality
00:27:33 <lifflander> in caches = slow memory
00:27:38 <HaskellLove> After I get myself some money I will buy two core pc so i can practice paralel programming
00:27:41 <lifflander> access time
00:27:59 <lifflander> So switching to a thread while waiting for memory can be helpful and speed up the program
00:28:05 <lifflander> Very rare, but possible
00:28:25 <lifflander> I'm working on my PhD in the Parallel Programming Laboratory so this is something I work on a lot
00:29:08 <cizra> uh, doesn't that depend on cheap context switches?
00:29:18 <lifflander> Yes, it does
00:29:22 <cizra> I'd guess context switching is A LOT more expensive than waiting for memory.
00:29:29 <lifflander> Lightweight threads and cheap switches
00:29:30 <cizra> Not sure, of course.
00:29:41 <lifflander> Unless you go to disk to switch pages
00:29:46 <cizra> yeah
00:30:00 <cizra> But aren't lightweight threads commonly implemented inside a single OS thread?
00:30:12 <merehap> lifflander: the google cache has the parsec3 page up, I'm not sure if you can download the sources from there (it is taking forever for me)
00:30:43 <lifflander> merehap: tried that but it wouldn't work: google does not cache the file
00:30:50 <merehap> :(
00:31:01 <cizra> web.archive.org?
00:31:05 <merehap> nope
00:31:09 <merehap> tried that
00:31:12 <lifflander> cizra: depends on the implementation
00:31:28 <cizra> lifflander: I'd suppose... What does GHC do in this respect?
00:31:57 <Axman6> cizra: in haskell, they're implemented in N OS threads, where N is the number of cores
00:32:06 <lifflander> All my work is in specialized parallel languages...I do not know how GHC implements such things.
00:32:14 <Paczesiowa> how does type equality work inside ghc? I have two types that are pretty printed the same way, but tcEqType returns False
00:32:24 <merehap> lifflander: I guess you should get ubuntu or arch running in a VM then and use their package manager :)
00:32:53 <lifflander> Is there an ETA on when hackage will be back up?
00:33:10 <lifflander> Isn't it strange that it is down for this long?
00:33:13 <cizra> Axman6: OK, thanks
00:33:36 <Axman6> lifflander: not really
00:33:46 <merehap> Axman6: why?
00:33:46 <Axman6> it's less reliable than it should be
00:34:00 <Axman6> no idea
00:34:00 <lifflander> Who is in charge of fixing it?
00:34:04 <dolio> It probably won't be back up until people wake up in Oregon.
00:34:13 <lifflander> Okay.
00:34:26 <Axman6> no one's paid to look after it 24/7
00:34:32 <shambler> ;(
00:34:35 <merehap> it is only midnight it oregon, there should be someone up
00:35:10 <Axman6> not at galois though
00:35:38 <merehap> guess they should get pagers like the people at amazon do
00:35:59 <Axman6> they're donating their time...
00:36:04 <merehap> :)
00:36:11 <Axman6> there's no money involved
00:36:12 <merehap> it was a joke
00:36:22 <Axman6> i'm glad
00:36:37 <Paczesiowa> hackage should be distributed
00:37:00 <Axman6> indeed
00:37:03 <tensorpudding> it could possibly use a mirror anyway
00:37:15 <merehap> ok, lets set up some torrents for it then :)
00:37:16 <Axman6> so get to it, the sourse is all online, and needs more contributers
00:37:21 <Paczesiowa> didn't debian have some torrent based solution?
00:37:45 <merehap> I don't know, but it seems like a decent idea
00:38:14 <merehap> although debian has enough mirrors that they probably don't need a distributed solution
00:38:20 <merehap> hackage, however...
00:39:27 <merehap> I've got a spare machine, but I just know Comcast is going to throttle my internet if I set something like that up
00:40:27 <Paczesiowa> really? those packages are tiny downloads
00:40:41 <shambler> is it easy to keep packages' versions up-to-date with torrent-based solution? Something involving RSS comes to mind...
00:40:50 <Paczesiowa> and we all should fit on just one plane
00:41:05 <merehap> well, if hackage goes done often enough, maybe...
00:41:20 <merehap> might be a good project though
00:43:57 <MacCoaster> is there a built in function perhaps that can parse a binary string into a normal Int or Integer and back?
00:44:17 <Axman6> sure, check the binary package
00:44:25 <c_wraith> no, but there's a package on.... hackage.  which is currently down.
00:44:38 <Axman6> binary string being a ByteString i assume
00:45:35 <merehap> ok, lets just build a package manager for mac and have apple host it, problem solved
00:45:53 <Paczesiowa> darcs.haskell.org is the same machine as hackage?
00:45:56 <Axman6> there is a package manager for mac
00:46:04 <Axman6> Paczesiowa: probably
00:46:19 <merehap> oh, in that case, just make mac packages
00:46:31 <merehap> why have I never seen haskell packages for mac?
00:46:35 <Paczesiowa> maybe use portage for mac?
00:46:38 <Axman6> more trouble than its worth imo
00:47:22 <mauke_> http://mauke.ath.cx/tmp/2009-10-19-hackage-archive/
00:47:38 <merehap> hm, well I won't be the one making it, I'm quite content with pacman
00:47:45 <merehap> mauke_: nice
00:52:02 <mauke_> http://mauke.ath.cx/tmp/2009-10-19-hackage-archive.torrent
00:52:28 <kmc> @vixen everything must go
00:52:30 <lambdabot> and now that I have finished with you, you may go!
00:53:24 <Gabbie> Is that a quote from black books?
00:57:02 <Axman6> Gabbie: certainly feels like it :)
00:57:22 <merehap> ok, I'm currently downloading mauke's torrent so I can seed it...
00:58:00 <mauke_> really? I see no connections
00:58:16 <merehap> yup, its definitely going...
00:58:31 <mauke_> heh, there's another seed
00:58:46 <mauke_> just as keikaku
00:58:59 <merehap> keikaku?
00:59:40 <merehap> a random japanese band, apparently...
01:10:55 <geir_> is hackage.haskell.org having issues? I'm unable to get the page but www.haskell.org seem to work.
01:11:06 <Cale> yes, apparently so
01:11:24 <geir_> ok.. thanks.
01:11:43 <geir_> (could have been proxy issues at my side, so I just had to ask)
01:12:11 <dolio> > let f (id -> x) = x in f 5
01:12:13 <lambdabot>   Illegal view pattern:  (id -> x)
01:12:13 <lambdabot>  Use -XViewPatterns to enable view patterns
01:12:33 <merehap> geir_: try mauke_'s torrent above if you need something from hackage
01:15:23 <kyagrd> Is cabal update working now?
01:16:12 <kyagrd> I am keep getting timeout errors hmm
01:16:29 <merehap> its down
01:17:20 <geir_> merehap: thanks
01:17:35 <kyagrd> ahhhh
01:19:19 <merehap> geir_: and make sure to keep seeding afterwards, if you do download it so everyone else can get better than 6kb down :)
01:19:34 * RayNbow sighs and mumbles something about gnuplot...
01:22:14 <merehap> I wonder if we can get the topic modified to point to the latest archive torrent for hackage, seems that would be useful
01:26:49 <kmc> nah nobody reads the topic anyway
01:27:16 <Twey> hackage.haskell.org *always* has issues, it seems
01:27:25 <merehap> well it would be easier to point them to the location that way...
01:27:26 <Twey> geir_: http://downforeverybodyorjustme.com/
01:27:43 <Twey> How about a @where hackagetorrent
01:28:01 <merehap> yeah, sounds good
01:28:16 * Twey prods Cale.
01:28:50 <RayNbow> why not turn hackage into a p2p repository? :p
01:29:21 <RayNbow> (ok, it isn't an easy solution :p)
01:29:26 <Twey> Hehe
01:29:26 <mauke_> @where+ hackagetorrent http://mauke.ath.cx/tmp/2009-10-19-hackage-archive.torrent
01:29:26 <lambdabot> Done.
01:29:33 <Twey> Thanks, mauke_
01:29:35 <merehap> if it keeps up this behaviour, it effectively will be
01:29:40 <merehap> cool
01:29:42 <mauke_>  @where doesn't even require privileges
01:29:53 <Twey> Really?  Oh
01:29:57 <Twey> I didn't know that.
01:29:59 <merehap> oh, that's handy
01:30:12 <mauke_> preflex: help store
01:30:12 <preflex>  store KEY DATA - associate DATA with KEY
01:30:16 <mauke_> (or that)
01:30:52 <int-e> @help topic
01:30:52 <lambdabot> topic provides: topic-tell topic-cons topic-snoc topic-tail topic-init topic-null
01:34:01 <merehap> @where hackagetorrent
01:34:01 <lambdabot> http://mauke.ath.cx/tmp/2009-10-19-hackage-archive.torrent
01:40:20 <drbean> @where awodey
01:40:20 <lambdabot> http://www.math.uchicago.edu/~may/VIGRE/VIGRE2009/Awodey.pdf
01:46:15 <HaskellLove> has anyone written operational or denotational semantics for his own language? would you like to share so i see and learn something?
01:49:28 <basvandijk> Does anybody have connection problems with hackage? When I try uploading a package I get a timeout.
01:49:52 <shambler> hackage is down
01:50:12 <basvandijk> shambler: ok thanks
01:51:58 <merehap> we've got a torrent going if you need it:
01:52:01 <merehap> @where hackagetorrent
01:52:01 <lambdabot> http://mauke.ath.cx/tmp/2009-10-19-hackage-archive.torrent
01:53:08 <basvandijk> merehap: Thanks, but I just need to upload a few packages. Is there any news about when hackage is up again?
01:53:25 <merehap> should be maybe 8 hours
01:53:36 <merehap> when galois wakes up
01:54:02 <basvandijk> ok
02:05:27 <timnic> Sorry for the question: Does somebody know if cabal is down?
02:05:39 <merehap> yup
02:06:23 <foolio_> is hackage some kind of master or is it the only site?
02:06:46 <merehap> someone mentioned its the only site, hosted at galois
02:07:27 <foolio_> I wonder why it was designed so
02:07:49 <sinelaw> .
02:09:01 <quicksilver> because that is the simplest thing to do
02:10:14 <medfly> it'd be a good idea to fix it
02:10:35 <Twey> It was fairly tiny at the time
02:10:50 <Twey> It might be an idea to move to something a bit more scalable now it's popular, yeah…
02:10:57 <mauke_> @where hackagetorrent
02:10:57 <lambdabot> http://mauke.ath.cx/tmp/2009-10-19-hackage-archive.torrent
02:11:49 <mpiechotka> Is it just my connection or there are problems with hackage latly
02:12:01 <quicksilver> hackage is down
02:12:05 <merehap> that is the topic of the hour
02:12:06 * quicksilver considers adjusting topic
02:12:13 <merehap> :)
02:12:24 --- mode: ChanServ set +o quicksilver
02:12:33 <merehap> use the link mauke just posted if you need sources
02:13:14 --- topic: set to '["Yes, hackage is down. @where hackagetorrent","Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]' by quicksilver
02:13:59 <merehap> I was considering replacing myself with a bot, but that works too...
02:14:40 <quicksilver> it doesn't work that well, actually, because nobody reads /topics.
02:14:47 <quicksilver> but at least now we can insult them for not doing so.
02:15:06 <merehap> :)
02:15:25 <merehap> rtft, newb
02:15:33 <Gracenotes> lambdabot needs a topicsmite then
02:16:03 <Botje_> @faq is hackage down?
02:16:03 <lambdabot> The answer is: Yes! Haskell can do that.
02:16:14 <merehap> ha!
02:16:19 <merehap> and commonly does!
02:16:22 <Botje_> close
02:17:31 --- mode: ChanServ set +o mauke_
02:17:31 --- topic: set to '["hackage is down; torrent @ http://bit.ly/4u5JwZ ","Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]' by mauke_
02:17:52 <ivanm> mauke_: awww, I preferred quicksilver's version
02:18:09 <mauke_> why?
02:18:17 <ivanm> because it was more condescending!
02:18:23 <Gracenotes> lemme see what files are in it
02:18:25 <pozic> Is there a copy of the website also somewhere? Just a list of all the packages with short descriptions would be OK.
02:18:31 --- mode: mauke_ set -o mauke_
02:18:49 <Gracenotes> plus, you can't exactly feed bittorrent clients a shortened URL, can you?
02:18:58 <Twey> Yes
02:19:00 <pozic> Google Cache
02:19:12 <Twey> I'm sure any BT client worth its salt understands an HTTP redirect
02:19:19 <quicksilver> condescension ftw!
02:19:23 <mauke_> Gracenotes: I just load it in firefox
02:20:04 <Twey> You messed up the spacing between list items, mauke_
02:20:11 <quicksilver>   /topic well done sherlock, hackage is indeed down. Tell me, what was your first clue? No doubt in a moment you will tell me that mauke has arranged a torrent also. What thrilling news.
02:20:22 * Twey chuckles.
02:20:28 <mauke_> Twey: no, quicksilver did
02:20:36 <mauke_> I just added another space after the url
02:20:37 <Twey> No, quicksilver removed it :þ
02:20:42 <quicksilver> oops, sorry
02:20:42 <Twey> Ah, I see
02:20:47 <Twey> For clicking purposse
02:20:50 <Twey> purposes**
02:20:51 <mauke_> yep
02:20:54 <ivanm> pozic: or else google for reverse dependency hackage
02:21:02 <mpiechotka> merehap: Ups. Sorry - I checked only the topic, which was not updated then.
02:21:12 <pozic> Haskell is so robust with its 98% uptime! ;)
02:21:44 <Jafet> Indeed, that is why it is suitable to b * Exception: stack overflow
02:21:46 <merehap> mpiechotka: that's why we updated it :)
02:21:56 <pozic> Yes, that's one nines, er one nine of not guaranteed uptime! Buy now!
02:22:02 <quicksilver> http://bit.ly/8pcWlS
02:22:12 <quicksilver> that's a google cache of the main package list
02:22:21 <Gracenotes> Well done
02:22:23 <quicksilver> if anyone things that's useful.
02:22:24 <Gracenotes> D:
02:22:25 <elly> "We can't offer you five nines... but we can offer you nine fives."
02:22:37 <ivanm> elly: oh, that sounds like a bargain!
02:22:38 <ivanm> ;-)
02:22:38 <Twey> \o/
02:22:40 <Jafet> Same thing, ainnit.
02:22:45 --- mode: quicksilver set -o quicksilver
02:22:45 <merehap> that's also viewable through the your favorite torrent client...
02:23:01 <Twey> quicksilver: You didn't fix it? :þ
02:23:13 <medfly> hehehe, it'd be funny to rebuild hackage to manage using a torrent client to fetch packages
02:23:17 * medfly toys with the thought.
02:23:23 <Twey> Do it!  Do it!
02:23:27 <pozic> http://bifunctor.homelinux.net/~roel/hackage/packages/hackage.html
02:23:39 <ivanm> pozic: that's the one
02:23:42 <Jafet> It didn't work for debian, what makes you think it'll work for hackage?
02:23:43 <Gracenotes> how long is it expected to be down?
02:23:58 <Twey> ~8h
02:24:00 <merehap> Jafet: why didn't it work?
02:24:02 <medfly> then, we could have all the mirrors seeding! :o
02:24:06 <quicksilver> until the USAnians clamber out of bed and into work
02:24:12 <quicksilver> the west coast USAnians in particulat
02:24:22 <quicksilver> probably about 6h now
02:24:34 <Jafet> No idea, but it didn't
02:24:37 <paolino> mauke, is the torrent regularly updated ?
02:24:42 <merehap> ugh, sorry, I'm just one state over, if I could go down to oregon I'd get it turned on for you...
02:24:47 <shambler> hmmm... cabal install over torrent?
02:24:52 <Gracenotes> as an East Coast USAnian, I resent the notion... oh, you mean those people that go to work
02:24:57 <Jafet> Something to do with "no one will go to the effort to implement this"
02:25:00 <Twey> Gracenotes: *grin*
02:25:03 <mauke_> paolino: not really, it was just an ad-hoc thing
02:25:38 <merehap> Gracenotes: hey, I going to work, maybe somewhat flexible hours though :)
02:27:07 <kmc> i used to have flexible hours :/
02:27:26 <merehap> is USAnian now the official term? sounds a bit funky, but it would be nice to know what to call myself finally
02:27:36 * Botje_ likes his hours to be sixty minutes. no more, no less
02:27:42 <merehap> kmc: don't tell me you don't have free beverages either...
02:27:48 <kmc> heh
02:27:54 <medfly> I have flexible hours. it's a code to mean you work weekends and holidays for no extra pay, and there's no concept of overtime.
02:28:03 <Twey> Haha, yes
02:28:06 <Twey> That sounds about right
02:28:07 <kmc> beverages are included
02:28:13 <Gracenotes> I like to say American :.
02:28:35 <merehap> Gracenotes: yeah, but then I get two continents pissed off at me
02:28:40 <pozic> It would be nice if you could recompile papers for simpler mathematical objects...
02:28:44 <Twey> And lots of islands
02:28:54 <medfly> merehap: I think you should call yourself a 'freedom lover', I hear people in the US are obsessed with freedom :)
02:28:55 <Gracenotes> merehap: no one else has "America" as their fundamental name
02:29:03 <Twey> Also, a variety of peoples who lived in America long before it was America
02:29:06 <paolino> mauke_: can you share the script that produced it ?
02:29:15 <merehap> medfly: well yeah, especially my freedom (not French) fries
02:29:17 <mauke_> paolino: script?
02:29:23 <Twey> Haha
02:29:40 <marcot> Hi.  Is hackage down?
02:29:43 <Twey> medfly: Kind of ironic, really… :þ
02:29:44 <medfly> it is!
02:29:44 <merehap> yes
02:29:45 <Twey> marcot: /t
02:29:50 <merehap> @where hackagetorrent
02:29:50 <lambdabot> http://mauke.ath.cx/tmp/2009-10-19-hackage-archive.torrent
02:29:58 <marcot> Twey: thanks and sorry...
02:30:00 <Gracenotes> I think the way terminology has been set up, American is relatively unambiguous. To refer to continents, use North or South.
02:30:00 <merehap> go go go, seed seed seed
02:30:21 <Gracenotes> that's why I was asking about how long it would be... whether it's worth seeding or not
02:30:28 <paolino> mauke_: yes, wget or whatever was used
02:30:36 <Twey> Gracenotes: But then you have to say ‘Native Americans’ to refer to the people who were there in the first place
02:30:44 <Twey> Which is quite messed up :þ
02:30:48 <Gracenotes> eh, may as well, even on my desperately slow connection
02:30:54 <foolio_> somewhat politically correct might be then "North Americans between Canadians and Mexicans"
02:30:55 <mauke_> paolino: I downloaded the tarball from hackage
02:31:11 <mauke_> there's a link on the front page
02:31:12 <Twey> foolio_: ‘… with crazy European-descended culture’
02:31:15 <foolio_> that would of course exclude Alaskanians
02:31:19 <medfly> I think the rule is american == citizens of the US
02:31:40 <merehap> south americans always get pissed off at that though
02:32:23 <QtPlaty[HireMe]> merehap: I recall if you announce that your an american to an canadian border gard they ask you "Which north or south"
02:32:25 <Jafet> You could just ignore them until they start contributing more than drugs and canned fruit
02:32:37 <paolino> mauke_: ok, I didn't know it existed, then untar and make a torrent of the resulted hierarchy, right ?
02:32:56 <mauke_> paolino: yeah
02:33:28 <Jafet> On the topic of bittorrent, you could use it to build a distributed filesystem
02:33:41 <Jafet> (But then you could just use a distributed filesystem in the first place.)
02:33:43 <Gracenotes> when you say you're ___, it's as a nationality
02:33:47 <foolio_> Jafet, canadian border guards are lousy people anyway, better to ignore them to the end
02:33:59 <Twey> Yeah, just walk straight through that border
02:34:02 <Twey> Pay the men with guns no mind
02:34:07 <Jafet> I was talking about south americans, but hey
02:34:12 <Jonno_FTW> @src getLine
02:34:13 <lambdabot> getLine = hGetLine stdin
02:34:16 <merehap> just make sure you hide the weed well
02:35:02 <pozic> Is there any library for cutting hyperplanes in any language?
02:35:21 <Jafet> You want a kd-tree library?
02:35:35 <pozic> Jafet: no, I just want the cutting.
02:35:51 <Jafet> Yes, I believe the kd-tree gives you just that.
02:36:44 <pozic> Jafet: I don't think it can give me a $(1/\sqrt{n})$-cutting.
02:37:43 <mauke_> 1/√n
02:38:02 <Jafet> 1 / sqrt n
02:38:06 <medfly> Gracenotes: really?
02:38:36 <pozic> mauke_: how do you input that without copy and pasting the symbol from somewhere?
02:38:46 <Gracenotes> n^-½
02:38:52 <mauke_> 1/`uni{squ ro}n
02:39:12 <Jafet> SCIM has latex input, somehow
02:39:22 <pozic> mauke_: which software understands that?
02:39:24 <Gracenotes> that's what I used for \frac12
02:39:30 <mauke_> pozic: my irc client
02:39:35 <pozic> mauke_: which is?
02:39:44 <Gracenotes> or ¾. or \infty ∞, \cup ∪
02:39:46 <mauke_> pozic: irssi + scripts
02:40:02 <pozic> mauke_: which scripts? I also use irssi.
02:40:07 <medfly_> Gracenotes: what if you do \frac58
02:40:14 <Gracenotes> ⅝
02:40:20 <medfly_> o.O
02:40:27 <medfly_> no two digit numbers?
02:40:27 <Jafet> Ah, whoops. kd-tree won't help with this problem
02:40:31 <medfly> Gracenotes: if I say I'm Muslim, is it my nationality?
02:40:33 <mauke_> compose 5 8 = ⅝
02:41:01 <Gracenotes> medfly_: for geographic regions
02:41:08 <Gracenotes> anyway, it's part of the number forms unicode block
02:41:11 <mauke_> pozic: http://mauke.ath.cx/stuff/irssi/irssi-gui-line-entered.patch  http://mauke.ath.cx/stuff/irssi/spand.pl
02:41:13 <merehap> wow, everyone on #haskell is so minimalist: irssi and rtorrent
02:41:21 <medfly_> hehehe
02:41:22 <merehap> random musing complete.
02:41:25 <Gracenotes> 2150-2189, hex
02:41:32 <Twey> rtorrent doesn't load some torrents for me :-\
02:41:36 <Jafet> We're all overgeneralists as well
02:41:36 <Gracenotes> hey, I use ChatZilla. tis a monster.
02:41:37 <Twey> It doesn't always find all the trackers…
02:41:41 <mauke_> merehap: hey, I use transmission for torrents
02:41:41 <Gracenotes> rawr.
02:41:42 <Twey> So now I use Transmission
02:41:55 <Twey> I prefer rtorrent, though, apart from that bug.
02:42:09 <merehap> mauke_: hm, you never showed up on my list of peers then :)
02:42:12 <Gracenotes> also, does anyone's font render ↈ?
02:42:17 <Gracenotes> mine doesn't
02:42:27 <merehap> Twey: I'm sure when I make htorrent it won't have that bug
02:42:29 <Twey> Mine does
02:42:33 <merehap> :)
02:42:37 <Twey> Hehe
02:42:41 <Gracenotes> U+2188  ROMAN NUMERAL ONE HUNDRED THOUSAND  http://rishida.net/scripts/uniview/graphics/Number%20Forms/large/2188.png
02:42:49 <Twey> Yep
02:42:58 <Twey> It's a bit squished
02:43:38 <mauke_> ፼
02:44:01 <Gracenotes> hello mister 10000
02:44:10 <Gracenotes> lovely hat and monocles you have
02:44:11 <Twey> Ethiopic, eh
02:44:14 <Twey> Hehe
02:44:54 <pozic> mauke_: thanks, but compiling irssi on every machine I use is too much work.
02:45:08 <mauke_> pozic: solution: only use irssi on one machine
02:45:23 <Twey> Or use precompiled versions?
02:46:02 <Jafet> ssh to irssi!
02:46:18 <Gracenotes> rather slow
02:46:20 <Twey> Works so long as the connection is fast
02:46:25 <osfameron> screen+irssi ftw
02:46:39 <Jafet> This is IRC not your live hentai channel
02:46:59 <merehap> I'm sure there is that plugin for irssi, though...
02:47:01 <Gracenotes> if there is something I prefer in IRC clients, it's responsiveness
02:47:37 <Jafet> Line-mode frontend to irssi, patches welcome?
02:47:57 <Twey> Line-mode frontend to irssi, A.K.A. irssi
02:48:04 <pozic> Hmm, I could do that, but then I have to convince ssh to login without prompting for a password (there are no key logins available).
02:48:38 <merehap> pozic: use a binary distribution, none of this compile from source non-sense
02:48:57 <mauke_> merehap: and how are you going to apply a source patch to a binary?
02:48:58 <pozic> merehap: you missed the patch mauke_ wrote.
02:48:59 <Jafet> Twey, not over ssh.
02:49:14 <Jafet> mauke_, decompile
02:49:17 <merehap> ah, oops
02:49:26 <mauke_> Jafet: that can only end well
02:49:53 <Jafet> It's never too late to learn to patch by hand
02:49:56 <Twey> Jafet: A.K.A. irssi + SSH tunnel ;)
02:53:07 <paolino> I have problems piping commands when using BS.hGetContents
02:53:07 <paolino> <stdin>: hLookAhead: invalid argument
02:56:18 <paolino> it doesn't happen using Strings, and reading line by line
02:57:09 <zygoloid> pozic: looks like there's a manual expand binding too
02:59:53 <paolino> if I redirect to file and then cat the file everything is fine
03:05:54 <pozic> √ with SCIM. :)
03:06:04 <pozic> No need to recompile anything.
03:06:20 <Jafet> You have to recompile with gtk
03:06:34 <Jafet> That kind of sucks big time
03:07:15 <jpvarma> hi
03:08:49 <jpvarma> what is a value in haskell?
03:09:52 <paolino> the result of a computation, I guess
03:09:55 <Jafet> "That's metaphysics, my dear fellow. It's forbidden by my doctors, my stomach won't take it."
03:11:46 <jpvarma> it is saved as a sequence of bits, right?
03:12:07 <zygoloid> it would be reasonable to assume so, on some level :)
03:12:17 <Baughn> It's stored as a sequence of electrical pulses. ;)
03:12:32 <Baughn> Also, hackage is down /again/?
03:12:34 <Jafet> What kind of question is that? Are you asking about the Haskell language, or about an implementation of Haskell, or about the implementation of Haskell?
03:13:12 <jpvarma> i am just trying to understand how a variable in haskell is different from a variable in C
03:13:28 <Baughn> jpvarma: The most obvious difference would be that haskell doesn't have variables
03:13:52 <Baughn> It has values, which aren't allowed to change. And, okay, I guess IORef/MVar/TVar are variables, but those aren't very basic.
03:14:51 <sinelaw> i guess that was too much
03:15:16 <fabjan> http://en.wikipedia.org/wiki/Variable_(mathematics)#What_it_means_for_a_variable_to_vary
03:15:20 <fabjan> oh, he left?
03:15:24 <jpvarma> sorry, got disconnected
03:15:28 <Baughn> He's back.
03:15:36 <Baughn> jpvarma: The most obvious difference would be that haskell doesn't have variables
03:15:41 <Baughn> It has values, which aren't allowed to change. And, okay, I guess IORef/MVar/TVar are variables, but those aren't very basic.
03:15:48 <Cale> That's a lie, Haskell absolutely does have variables.
03:15:55 <Cale> f x = x^2
03:15:58 <jpvarma> yeah, i do understand that what are called as varibles in haskell are
03:15:58 <Cale> x is a variable
03:16:02 <jpvarma> actually symbols
03:16:12 <paolino> I reproduced the problem http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15663#a15663
03:16:13 <Gracenotes> meaning perhaps variable variables
03:16:20 <Baughn> It has mathematical variables, but that's not really the same concept as C variables
03:16:31 <jpvarma> they do not change , something like variables in math
03:16:40 <Cale> It's just that variables in Haskell refer to values, and not to mutable cells which contain values.
03:16:52 <Cale> x can change in that example
03:16:54 <Baughn> jpvarma: On the machine level, another big difference is - in C, an int is always just an int. 32 bits of data.
03:16:58 <Jafet> > let x = 1 in let x = 2 in x
03:17:00 <lambdabot>   2
03:17:01 <jpvarma> how are these symbols represented in computer memory?
03:17:10 <Cale> x will be different every time that f is applied to a different value
03:17:19 <Cale> > let f x = x^2 in map f [1..10]
03:17:19 <Jafet> > do { x <- [1]; x <- [2]; x; }
03:17:20 <lambdabot>   [1,4,9,16,25,36,49,64,81,100]
03:17:20 <lambdabot>   No instance for (GHC.Num.Num [b])
03:17:21 <lambdabot>    arising from the literal `2' at <inter...
03:17:29 <Jafet> Geh
03:17:29 <Gracenotes> You can point to an arbitrary box. But, for a given box, you can't change its value.
03:17:30 <Baughn> jpvarma: In haskell, it's /either/ an int, /or/ a pointer to a function, along with the parameters to that function (if any), which when executed will make an int. (That's a thunk)
03:17:31 <Cale> Jafet: In those examples you're just shadowing x
03:17:38 <Cale> It's not the same variable :)
03:17:47 <Jafet> Well, he said that variables are symbols
03:17:57 <Gracenotes> if you choose to use the boxes analogy. actually, the DDC paper has an illustration of that, if you want to look
03:18:28 <paolino> anyone can confirm my bug , please?
03:18:30 <jpvarma> my question is just how are these symbols represented in memory?
03:19:12 <Cale> jpvarma: In GHC, (essentially) all variables are pointers to code which when executed will return the value of the variable. The first time the code runs, it computes the value of the variable, and rewrites the pointer to point at a shorter piece of code which will return the result of that evaluation immediately.
03:19:13 <jpvarma> is it implemented using some kind of a look up table?
03:19:15 <Baughn> jpvarma: Well.. symbols are usually considered to only exist in the compiler's imagination, unless you've got good introspection (haskell doesn't). I'm betting that's not what you're askin.
03:19:41 <Cale> jpvarma: But there are a lot of possible implementations
03:19:43 <Baughn> jpvarma: Inside the compiler, there'd be a lookup table. A lot of them, in fact. In the code it /generates/, there are no symbols, just relative pointers.
03:20:14 <Gracenotes> the memory representation depends on the values... some never make it to the heap. the ones that do live on the heap are closures, which may be functions, and may be constructors (when updated to their final value)
03:20:32 <jpvarma> Baughn: so the only difference (w.r.t variables) between C and haskell is that these pointers cannot change in haskell
03:20:49 <Gracenotes> data constructors in the Haskell sense, analogous maybe to structs in C
03:20:55 <Baughn> jpvarma: Ah.. no, there's a lot more.
03:21:13 <Baughn> jpvarma: I was going to do a write-up of the GHC evaluation model. Haven't yet. Probably get it wrong anyhow. :/
03:21:16 <Cale> jpvarma: Er, it's not good to think of Haskell variables in terms of their machine implementations.
03:21:18 <Jafet> jpvarma, you can't learn Haskell from square 2, so you shouldn't try.
03:21:23 <jpvarma> Baughn: can u name some more..
03:21:26 <Cale> (well, at least not from the beginning)
03:21:37 <Baughn> jpvarma: How well do you understand C? Do you know how the stack works?
03:21:55 <Cale> jpvarma: Think of it this way. Cale is my name, it refers to me. It doesn't refer to a box which I'm sitting in.
03:21:58 <jpvarma> Cale: but i just dont seem to understand it otherwise
03:22:15 <ivanm> Cale: how can you be sure about that? ;-)
03:22:31 <jpvarma> Baughn: a little
03:22:54 <Jafet> Have you ever implemented a compiler?
03:23:00 <Jafet> (For any language?)
03:23:12 <Cale> jpvarma: In C, when you declare  int x;  it means that x refers to a position in memory.
03:23:22 <jpvarma> Jafet : no
03:23:25 <Cale> jpvarma: That position in memory has a value which changes over time.
03:23:38 <Baughn> jpvarma: Okay. The mapping from C to machine code is relatively simple; when you call a function, that function increments (or decrements, whatever) the stack pointer to fit local variables, and all references to local variables are relative to the stack pointer.
03:24:06 <Cale> jpvarma: In Haskell, when you write, say,  x :: Int; x = 5, you're saying that x is a name for the constant 5.
03:24:13 <Baughn> jpvarma: Global variables just use a static pointer.
03:24:35 <Cale> jpvarma: As long as a variable remains in scope, its value doesn't change.
03:24:54 <jpvarma> Baughn: static pointer?
03:25:03 <Cale> jpvarma: In C, this is the same, except that it's not the value which doesn't change, it's the location in memory that it refers to.
03:25:22 <paolino> (http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15663#a15664 I added the error)
03:25:27 <Baughn> jpvarma: The location of a global variable is known at link-time, so the linker inserts a fixed-value pointer into the executable code itself
03:26:04 <Baughn> ..that's /still/ a simplification, but it'll do for now.
03:26:30 <jpvarma> Baughn: ok, i understand
03:26:50 <Cale> jpvarma: Haskell isn't specified at this sort of level though.
03:27:10 <Baughn> It isn't specified, but it's still useful to know how it works at that level. So..
03:27:23 <jpvarma> Cale: i could not find this low-level description anywhere..
03:27:37 <Baughn> Oh, this isn't low-level yet. :P
03:27:53 <Cale> I think the easiest way to understand how Haskell works is to ignore the part about it running on actual hardware, and just worry about how expressions are transformed into values.
03:28:07 <Baughn> jpvarma: In haskell, it's all about thunk evaluation. Do you understand how haskell works on the surface yet?
03:28:14 <jpvarma> Cale: yeah, but there is no fun in it
03:28:26 <Cale> Sure there is :)
03:28:31 <Baughn> jpvarma: Because, after considering it, I don't think I can explain it to someone who can't already use the language. Not without an hour-long lecture. It's too alien. ;)
03:29:12 <jpvarma> Baughn: yeah, you are right. my 'higher-level' haskell knowledge is next to nothing
03:29:18 <HaskellLove> i am thinking of spendind two weeks learning the language unlambda, what do you think?
03:29:37 <jpvarma> Baughn: can you suggest a good reference for the low-level understanding?
03:29:40 <Baughn> jpvarma: In that case, I'd say you shouldn't worry about it yet. You don't really need to understand this to use haskell properly.
03:29:47 * paolino thinks BS.hGetContents is broken on pipes
03:29:57 <Baughn> jpvarma: #haskell, #ghc, the GHC wiki...
03:30:14 <ivanm> oh, great... I apparently have a <<loop>> in my code :s
03:30:18 <ivanm> and I have nfi where :s
03:30:28 <Baughn> paolino: Hm. How so?
03:30:33 <Baughn> paolino: Did you remember to ignore SIGPIPE?
03:30:39 <jpvarma> Baughn: thanks
03:30:44 <ivanm> anyone have any ideas how I can try to track it down?
03:30:52 <paolino> Baughn: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15663#a15664
03:30:57 <Cale> http://citeseer.ist.psu.edu/peytonjones92implementing.html
03:31:01 <Gracenotes> jpvarma: it is helps, here is an illustration of the kind of updates we're talking about http://i.imgur.com/hTwqj.png
03:31:22 <Baughn> paolino: Oh, that's broken.
03:31:24 <Gracenotes> they are all updates in some form, and x is variable in all cases. But they're different in various ways.
03:31:38 <Baughn> paolino: Bytestring needs to use raw input, it's apparently trying to decode utf-8. No way that'll work.
03:31:40 <Jafet> jpvarma, it is much more useful for you to think about Haskell at a higher level
03:31:48 <Cale> jpvarma: ^^ that paper by SPJ is the standard introduction to how GHC works in terms of lower-level stuff
03:31:50 <Baughn> paolino: Bug report!
03:31:51 <Jafet> You can't learn Haskell the way you learn C.
03:32:20 <paolino> Baughn: it works if I dump to file before piping
03:32:21 <Baughn> jpvarma: I'll be happy to tell you more later. Very happy. But for now, you must learn to use the language.
03:32:34 <jpvarma> Cale: thanks, I will try to read it
03:32:44 <zygoloid> jpvarma: on a conceptual level, when we write 'let x = (some expression) in f x', what actually happens is that the expression itself, and not the value of the expression, is passed into f, and f evaluates the expression when it needs the value
03:32:50 <Jafet> Think in terms of WHNF reduction, for example.
03:32:53 <Gracenotes> Baughn: [...] young grasshopper
03:32:53 <Baughn> paolino: Which means it's an amusing bug, but the error message is pretty obvious.
03:33:06 <Baughn> Gracenotes: Cicada, more like.
03:33:06 <paolino> Baughn: and it works if I just pass first 1000 numbers instead
03:33:22 <Baughn> paolino: What does prod actually produce?
03:33:30 <zygoloid> jpvarma: as an optimization, the evaluated value is usually stored and reused if x is ever used again (this is called lazy evaluation)
03:33:48 <paolino> Baughn: encode a list of Integers
03:33:54 <Baughn> paolino: Encoded how?
03:34:01 <paolino> Binary
03:34:08 <ivanm> how does one add a strictness annotation to the records of a data structure?
03:34:10 <jpvarma> Baughn: thanks
03:34:15 <Baughn> paolino: Right. So it's not valid ASCII.
03:34:32 <Baughn> paolino: At a guess, the first 1000 numbers /do/ encode as valid UTF-8, for whatever reason.
03:34:37 <ivanm> oh, what, it's because I needed parens to include the type variable
03:34:46 <Baughn> paolino: Well, in any case, /obviously/ a bug.
03:34:50 <paolino> Baughn: O_O
03:34:58 <jpvarma> Baughn: I am trying to read the haskell98 report
03:35:01 <zygoloid> jpvarma: this is often implemented by allocating a lump of memory which stores initially a reference to some code and the environment in which it should be run. 'x' refers to that lump of memory. when 'x' is evaluated, the memory is overwritten with the value of x
03:35:07 <jpvarma> Baughn: do you think it is useful?
03:35:27 <Baughn> jpvarma: No.
03:35:38 <jpvarma> Baughn: ok
03:35:56 <Baughn> jpvarma: It's sometimes useful when there are obscure points you want to make sure of, but it's both obsolete, and horribly difficult to read
03:36:29 <zygoloid> jpvarma: the other important thing is that the compiler will short-circuit all this and just immediately work out the value of x if it can be sure it'll be used
03:36:41 <jpvarma> Baughn: i do not know about it being obsolete but difficult to read - yes
03:36:43 <Baughn> paolino: Oh, you /are/ using 6.12.1, right?
03:36:52 <Baughn> jpvarma: Well, it's from 1998. :P
03:36:58 <paolino> Baughn: what is the problem with UTF-8  and pipes ?
03:37:01 <paolino> yes
03:37:39 <paolino> Baughn: my guess is prod is too slow
03:37:43 <Gracenotes> the funny thing about having this many intermediate representations is that there are equally many ways to think about code...
03:37:46 <Baughn> paolino: GHC 6.12.1 adds the ability to decode/encode text according to the current locale, which will usually be utf-8 (and most others accept all possible bytestrings anyway)
03:38:16 <Baughn> paolino: This means that you can get the error you in fact get, /if/ you're reading input as text (i.e. String), and the input is in fact invalid text
03:38:50 <Baughn> paolino: It should not affect ByteString in the least, but somehow using a pipe makes it use that mechanism despite that it should be off
03:39:41 <jpvarma> thanks everyone
03:39:49 <Baughn> paolino: Oh, and you can work around it for the time being by using hSetBinaryMode stdin True
03:40:03 <Baughn> paolino: ..you should probably do the same with stdout in prod, to be on the safe side.
03:40:22 <Baughn> paolino: Once you've verified that this works, go ahead and report the bug.
03:41:27 <Baughn> Now, does anyone know what's down with hackage?
03:41:43 <Gracenotes> a lack of upness
03:41:59 <Baughn> I thought they were replacing the machine back in december
03:43:32 <paolino> with an older one, maybe ... thanks a lot Baughn, it seems to work now, and so , I guessed wrong, and you right
03:43:41 <mpiechotka> Which package should I use to serialize/deserialize from YAML?
03:44:30 <Baughn> paolino: But it's odd. I've checked the code, and bytestring does correctly call hGetBuf.
03:45:10 <Baughn> Well, has to be hLookAhead being implemented wrong
03:45:21 <Baughn> ~70%
03:46:08 <Baughn> paolino: Oh, and link me to the bug report. I want to track this. It's excitingly broken. :3
03:47:30 <paolino> when hackage resurrects, I suppose
03:47:48 <sinelaw> has anyone succeeded in getting antialiasing working in opengl+sdl+haskell?
03:47:50 <Baughn> Oh. Apparently.
03:48:10 <Baughn> sinelaw: Yes.. by setting an environment variable for the nvidia driver. ^^;
03:48:18 <Baughn> Properly? No, but I haven't tried.
03:48:29 <sinelaw> Baughn, i'm using Mesa3d
03:48:31 <Gracenotes> mpiechotka: looks like HsSyck does it
03:48:43 <Baughn> sinelaw: What, software rendering?
03:49:06 <Gracenotes> seems also data-object-yaml and yaml packages do it
03:49:20 <Baughn> paolino: Hm. It occurs to me that the haskell-based distributed filesystem I'm working on would work just fine for hackage.
03:49:24 <sinelaw> Baughn, yes, because my card isn't supported in the new kernel+xorg
03:49:25 <Baughn> I'll have to look into that, later.
03:49:31 <mpiechotka> Gracenotes: There are many libraries which states in description they setialize them. And access/installing is a bit harder then  usuall ;)
03:49:56 <Baughn> sinelaw: Oh? What card is that?
03:50:05 <sinelaw> ATI Radeon
03:50:06 <sinelaw> x1200
03:50:18 <Baughn> Ah. Well.
03:50:27 <Baughn> Radeon, on linux.. always a bit... um.
03:50:33 <paolino> Baughn: pointer to the project ?
03:50:56 <Baughn> paolino: Sorry. I'm still bogged down in red tape, and am having trouble getting permission to release it.
03:50:56 <Gracenotes> mpiechotka: slightly harder, yeah. The descriptions are at the Google Cache, at least. http://209.85.129.132/search?q=cache:lABYt9YV8eEJ:hackage.haskell.org/packages/archive/pkg-list.html
03:51:05 <Baughn> paolino: ..well, it won't be useful for another month anyway.
03:51:26 <mpiechotka> Gracenotes: Also http://bifunctor.homelinux.net/~roel/hackage/packages/archive/pkg-list.html
03:51:47 <mpiechotka> Gracenotes:  But in both cases browsing docs is not so simple
03:51:49 <Baughn> paolino: Read that as Real Soon Now. :P
03:51:58 <paolino> :)
03:52:25 <paolino> an haskell killer app I guess
03:52:43 <Baughn> ..possibly.
03:53:44 <paolino> and ... you used bytestrings heavily :D
03:53:51 <Baughn> ..oh dear.
03:54:10 <Baughn> Although, if I was having this issue.. no, it must be /just/ for pipes, not network connections too.
03:54:19 <Baughn> Really odd.
03:55:36 <sinelaw> Baughn, holy moly. the DRI is only used when i run the program as root!
03:55:54 <Baughn> sinelaw: Broken x.org configuration, I guess
03:55:56 <paolino> well, I'm sorry but hSetBinaryMode didn't do for the real app
03:56:13 <Baughn> paolino: Missed a handle or two?
03:56:20 <sinelaw> damn i can't believe that was the problem
03:56:24 <Baughn> Hang on..
03:56:40 <Baughn> sinelaw: You should be able to set DRI permissions to 0666 in xorg.conf
03:56:51 <Baughn> Probably summon demons, but..
03:56:51 <sinelaw> yes. but antialiasing still doesn't work
03:57:07 <Gracenotes> at least some daemons
03:57:35 <Gracenotes> to run around autonomously and do the OS's bidding
03:58:07 <lpsmith> anybody running Ubuntu 9.10?
03:58:37 <Baughn> paolino: For a lark, try setting your environmental locale to latin-1 before starting your program
03:58:44 <Gracenotes> lpsmith: I am..
03:59:10 <lpsmith> Gracenotes:  could you test ulimit for me real quick?    I set a ulimit -m 0 and can still run stuff
03:59:30 <paolino> Baughn: how is it with bash ?
03:59:41 <Gracenotes> lpsmith: it's definitely worked for me before
03:59:52 <Gracenotes> but it silently doesn't do anything if you give it an invalid value
04:00:12 <lpsmith> yes,  but you can set ulimit -m 0
04:00:17 <lpsmith> or ulimit -m 1...
04:00:23 <lpsmith> anyway,  it's not working for me at all
04:00:33 <Baughn> paolino: Tell me what echo $LANG says
04:00:40 <Gracenotes> lpsmith: hm, actually just worked for me. "max memory size         (kbytes, -m) 0"
04:00:51 <Gracenotes> from "max memory size         (kbytes, -m) unlimited" not long ago
04:00:54 <Baughn> paolino: But the command should be 'export LANG=en_US ISO-8859-1'
04:00:55 <lpsmith> right
04:01:01 <lpsmith> but can you run vim now?
04:01:07 <lpsmith> or ghci?
04:01:11 <paolino> Baughn: paolino@paolino-desktop:~$ echo $LANG
04:01:11 <paolino> it_IT.UTF-8
04:01:18 <Baughn> Okay.
04:01:19 <lpsmith> You shouldn't be able to
04:01:29 <Baughn> paolino: export LANG='it_IT.ISO-8859-1'
04:01:42 <lpsmith> either one should be killed immediately for allocating too much memory
04:01:43 <Baughn> The last line was missing a period.
04:01:47 <Gracenotes> lpsmith: hmm. Something that has worked for me is setting ulimit -v 0
04:02:14 <lpsmith> hmm
04:02:19 <paolino> Baughn: nothing changed
04:02:20 <Baughn> paolino: Or better yet, use en_US.ISO-8859-1. Using italian is likely to produce mojibake.
04:02:22 <lpsmith> ok,  yeah, that works for me
04:02:24 <lpsmith> ick
04:02:30 <Gracenotes> which prohibits malloc/mmap/ways that apps might try to dynamically grab memory. which might be enough, perhaps if you cut down stack size too
04:02:57 <paolino> Baughn: same story
04:03:09 <Gracenotes> lpsmith: for example, you can still use echo
04:03:19 <Baughn> paolino: Hm. Oh well. Definitely a bug somewhere.
04:03:26 <Baughn> paolino: You really will have to report this.
04:03:37 <zygoloid> Baughn: Italian usually uses 8859-1 too :)
04:03:41 <lpsmith> weird.   I don't recall what I used before
04:03:48 <lpsmith> oh well
04:03:54 <paolino> Baughn: I cannot reproduce it in a small example :(
04:03:58 <Baughn> zygoloid: Yeah, but en_US uses mainly /ascii/
04:04:04 <lpsmith> at least now I can set a ulimit to kill abberant ghci processes  :-D
04:04:08 <Baughn> paolino: What about the one you posted earlier?
04:04:15 <paolino> it works
04:04:20 <Baughn> If you reset LANG?
04:04:28 <tom_> is the haskell platform website down?
04:04:28 <paolino> with hSetBinaryMode
04:04:29 <zygoloid> Baughn: so does italian :)
04:04:39 <Baughn> paolino: It's supposed to work /without/ hSetBinaryMode
04:04:51 <zygoloid> (for some value of 'mainly') ;-)
04:05:00 <paolino> but it made the difference !
04:05:08 <Baughn> But it's a workaround!
04:05:12 <sinelaw> Baughn, $ unset LIBGL_ALWAYS_INDIRECT
04:05:14 <Baughn> That it doesn't work without it /is/ a bug
04:05:19 <sinelaw> now it works (after also fixing permissions)
04:05:21 <Baughn> sinelaw: *ROFL*
04:05:21 <Gracenotes> lpsmith: hm... I can't find anything in setrlimit(2) corresponding to -m
04:05:40 <paolino> Baughn: ok, I'll report it without the workaround then
04:05:41 <Baughn> sinelaw: Okay, /why/ was your computer /explicitly/ told not to use DRI? ^^;
04:05:46 <sinelaw> Baughn, it's also tremendously slow
04:05:46 <lpsmith> man bash
04:05:56 <Baughn> paolino: Report it, and also report the workaround.
04:06:01 <lpsmith>  /ulimit
04:06:05 <lpsmith> that's where I read ab out it
04:06:16 <paolino> bbl
04:06:17 <Gracenotes> lpsmith: and that, combined perhaps with ptrace and chroot, and a virtual machine for good measure, will provide insta-remote-execution-peace-of-mind
04:06:24 <Gracenotes> relatively insta
04:06:46 * int-e wonders what sinelaw's linux distribution is.
04:07:24 <zygoloid> possibly the desktop environment set it, because it believes it needs it for composite?
04:07:25 <Botje_> gaussian, i think.
04:07:25 <lpsmith> heh,  this is such a wonderful channel
04:07:42 <Gracenotes>    -m     The  maximum resident set size (many systems do not honor this limit)
04:07:48 <lpsmith> I ask questions in #ubuntu or #linux,  and the chances of me getting an answer is near 0
04:08:09 <lpsmith> I come here,  and get answers easily
04:08:20 <int-e> Botje_: I first wrote that without the 'linux', then I thought somebody might say *that*, so I made it more explicit. Apparently that didn't help.
04:08:26 * Gracenotes happened to know :x
04:08:31 <Baughn> zygoloid: Sounds likely, though that also sounds inefficient
04:08:58 <Gracenotes> in the whole vein of relatively safe remote execution of code, possibly several at a time
04:09:01 <HaskellLove> Why would i ever need De Bruijn' nameless representation?
04:09:16 <lpsmith> I can never remember all the options,  maybe I used -v in the past,  but I thought it was -m
04:09:20 <lpsmith> oh well
04:09:22 <Gracenotes> HaskellLove: when evaluating lambda calculus things
04:09:26 <Botje_> lexical scoping comes to mind
04:09:47 <int-e> HaskellLove: it avoids the need for alpha conversion.
04:10:14 <HaskellLove> int-e i see
04:10:15 <int-e> @quote fugue
04:10:16 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
04:10:19 <Gracenotes> it's a lot simpler than an alternative of constantly juggling names, and continually generating fresh names, and checking those fresh names don't interfere with current names...
04:10:37 <Ke> so what's contrapuntal fugue?
04:10:43 <lpsmith> De Bruijn indexes are not for reading or writing code,  but they can be handy for the study of interpreters and compilers and languages
04:10:52 <int-e> music
04:10:58 <Gracenotes> TAPL does provide OCaml code to evaluate 'em
04:11:43 <Lycurgus> Baughn, what is "DRI"?
04:12:05 <Baughn> Lycurgus: Direct Rendering Interface, x.org's specification for managing OpenGL contexts
04:12:14 <Lycurgus> ah, thx
04:12:19 <Baughn> Lycurgus: As opposed to the Direct Rendering Manager, which is the actual implementation
04:13:04 <lpsmith> @src maximum
04:13:05 <lambdabot> maximum [] = undefined
04:13:05 <lambdabot> maximum xs = foldl1 max xs
04:13:10 <zygoloid> Baughn: haha, looks like what happens is Compiz sets that environment variable for itself, and it gets inherited by subprocesses (such as those spawned by Compiz' keyboard shortcuts)
04:13:28 <Baughn> zygoloid: Are you sure that isn't on purpose?
04:13:32 <zygoloid> apparently if you enable transparency in gnome-terminal, it always starts as a subprocess of compiz
04:13:58 <zygoloid> Baughn: only the compiz process needs it set, i think.
04:14:04 <sinelaw> Baughn, this is weird. now it uses my hardware (glxgears runs very smoothly) but antialiasing stopped working.
04:14:08 <zygoloid> sinelaw: https://bugs.launchpad.net/ubuntu/+source/desktop-effects/+bug/137388
04:14:27 <zygoloid> sinelaw: are you using compiz, and running gnome-terminal?
04:14:33 <sinelaw> not using compiz
04:15:36 <HaskellLove> Gracenotes have you used lambda calculus in some language? like unlambda or something? or you have done it theory and pencil and paper?
04:15:55 <sinelaw> zygoloid, i don't mind unsetting that env variable if it will cause stuff to work (as a workaround)
04:16:09 <zygoloid> it's a bit mysterious that it's getting set in the first place...
04:16:12 <sinelaw> that worked, but not antialiasing doesn't
04:16:27 <sinelaw> (you know how to parse that sentence, i believe)
04:16:59 <lpsmith> HaskellLove:   ML, Scheme, and Haskell are all pretty faithful to the lambda calculus in various flavors,  although they are all "enriched"
04:16:59 * Baughn would suggest an nvidia card. The existence of firegl seems to have made ati mysteriously slacking on radeon opengl support.
04:17:12 <lpsmith> with things such as machine integers and IO primitives :-)
04:17:15 <Baughn> ..much like uranium.
04:17:20 <Gracenotes> HaskellLove: I've written several things related to it, mostly a year ago, when I worked through the beginning part of TAPL
04:17:49 <lpsmith> It's not *too* difficult to write a normalizer lambda calculus terms
04:19:07 <Gracenotes> I can't make any claim as to its accuracy, but here is my translation of the OCaml De Bruijn-evaluating code from TAPL
04:19:08 <Gracenotes> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15665#a15665
04:19:17 <Zr40> I've got a list of lists, and I want to concatenate them so I get one big list
04:19:34 <Zr40> this is what I've tried: foldr (++) [[1,2],[3,4]] []
04:19:40 <Zao> @src concat
04:19:41 <lambdabot> concat = foldr (++) []
04:19:45 <Botje_> swap the last two arguments
04:20:03 <Zao> @type foldr
04:20:05 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
04:20:17 <Gracenotes> eventually I made an untyped lambda calculus with boolean and int extensions -- basically an LC-based dynamic programming language -- with AST data LExpr = Var String | Lam String LExpr | App LExpr LExpr | Boole Bool | Cond LExpr LExpr LExpr | Zero | Succ LExpr | Pred LExpr | IsZero LExpr | Add LExpr LExpr | Mul LExpr LExpr | Print String
04:20:27 <Zr40> ah, that makes sense. Thanks :)
04:21:26 <Gracenotes> the "untyped type" being: data U = B Bool | F (U -> U) | I Integer
04:24:39 <Gracenotes> eventually, with RPN syntax, my language ended looking like: { >n ?0 >a >f >b @ >a >b + @ >n -1 @ ? #n #b #a }f @ 0 @ 1 @ 1000 @
04:24:53 <Gracenotes> recursion on f itself being implemented in terms of a fix operator: >f >x >x @ @ #x >f >x >x @ @ #x @ #f
04:25:06 <sinelaw> Baughn, all i want is puny 2d-graphics with nice effects. this is technology that existed in common hardware 15 years ago.
04:25:25 <sinelaw> i don't want to spend $$$$ on a fancy card
04:25:32 <sinelaw> nor can i, it's embedded :)
04:25:34 <Baughn> sinelaw: You would not /believe/ the number of bugs I've run into on ATI.
04:25:42 <Baughn> Are you using a laptop?
04:25:46 <sinelaw> yeah
04:25:51 <Gracenotes> er.. anyway.. I was going on a text-filling rant about my journeys with TAPL. *codes some more*
04:27:01 <lucid`> @quote
04:27:02 <lambdabot> <kmc> says: head [] = peek . intPtrToPtr . fromIntegral . unsafePerformIO . randomRIO $ (0, 2^32)
04:27:34 <lucid`> (forget it)
04:27:52 <Jafet> I propose that we bind that expression to Prelude.undefined
04:27:56 <Gracenotes> that looks safe
04:31:13 <Gracenotes> in particular it would never segfault.
04:32:45 <Jafet> @quote segfault
04:32:46 <lambdabot> mmorrow says: gah, i'm so used to haskell i forgot a return stmt in C and was trying to figure out where the  segfault was happening for 20 minutes
04:33:02 <Jafet> Looks like he forgot how to use gcc as well
04:33:21 <lucid`> i'm banned from #c
04:33:53 <ivanm> how'd you manage that?
04:34:11 <Jafet> Nothing worth bragging about
04:34:17 <Adamant> knowing what you are talking about is one possibility
04:34:29 <ivanm> heh
04:34:48 <Ke> =oP
04:35:33 * Adamant sips from a bottle of Cutty Snark
04:43:46 <roelvandijk> Hey everyone. I downloaded the hackage torrent and copied it to bifunctor.homelinux.net/~roel/hackage. This means you can download those packages which where the newest on 19 oktober 2009. If a package was updated after 19-10-2009 then you'll still see it but won't be able to download it. Just try an older version in such a case.
04:47:22 <lucid`> thanks!
04:47:30 <Gracenotes> so working list at http://bifunctor.homelinux.net/~roel/hackage/packages/archive/pkg-list.html
04:47:55 <sinelaw> thanks roelvandijk
04:48:05 <Gracenotes> it is rather working
04:48:41 <Gracenotes> besides the docs, I'm guessing. which are a job of their own...
04:50:00 <roelvandijk> no problem :-)
04:50:55 <sinelaw> ivanm, now i want to fork your stuff into another thread
04:51:05 <sinelaw> because it hangs my app for a second every time i update the graph
04:51:29 <sinelaw> how does your thing work? invoke a new 'dot' process every time? i'm guessing not
04:52:03 <ivanm> yes
04:52:11 <ivanm> how else would it do so?
04:52:40 <ivanm> sinelaw: I have a similar problem with SourceGraph; I don't bother profiling my code because I can see straight from top that most of the runtime is dot :s
04:54:09 <Gracenotes> is there a possibility of binding to the dot code?
04:54:35 <ivanm> Gracenotes: graphviz has an actual C library that can be used
04:54:40 <ivanm> if that's what you mean
04:54:51 <Gracenotes> yeah, I've analyzed the source code in some depth
04:55:08 <Gracenotes> should be possible to bind to it. so long as there are h files for it in the first place
04:55:13 <ivanm> but most "high level" langs that have bindings to graphviz just do what I do: generate Dot code, then run it through {dot, neato, etc.}
04:55:23 <ivanm> since it's easier
04:55:39 <ivanm> plus this way I've probably got more flexibility
04:57:27 <Gracenotes> incidentally I think dot does have incremental-graph-modification rendering abilities
04:58:23 <sinelaw> Gracenotes, it does? what exactly
04:58:45 <ivanm> Gracenotes: :o
04:58:59 <ivanm> Gracenotes: see, if it does, then its part of the library which it doesn't advertise
05:00:16 <Gracenotes> hm. I seem to recall one of the dot papers had some algorithms for it, and I had the idea dot implemented it in some form
05:01:18 <sinelaw> ivanm, open a terminal and type this:
05:01:27 <sinelaw> dot -Tdot
05:01:29 <Gracenotes> sudo rm -rf /
05:01:33 <ivanm> yes, mein fuhrer! ;-)
05:01:39 <ivanm> sinelaw: yup
05:01:42 <ivanm> it hangs
05:01:45 <sinelaw> digraph G { a->b; }
05:01:53 <Gracenotes> well, it's waiting from input
05:01:55 <Gracenotes> *for
05:01:56 <sinelaw> digraph G { c->d; }
05:02:00 <ivanm> sinelaw: ahhh, I see what you mean
05:02:11 <ivanm> sinelaw: I've only ever considered a single case...
05:02:30 <ivanm> sinelaw: I won't be able to hack anything like that till late Feb probably (well, _maybe_ late Jan)
05:02:31 <sinelaw> i'm guessing for any but big graphs, most of the time is wasted loading the process
05:02:58 <ivanm> sinelaw: if you want to add something like that, it should be possible by editing the stuff in Commands to take [DotGraph] and give out [a]
05:03:09 <ivanm> the graphvizWithHandle' function for starters
05:03:15 <ivanm> I'll accept a patch! ;-)
05:03:17 <sinelaw> ivanm, i'm looking at that right now!
05:03:28 <Gracenotes> sinelaw: except \n does prompt new graphs
05:03:32 <sinelaw> i'm not sure i'll succeed, i'm still new at this stuff
05:03:36 <Gracenotes> ..right?
05:03:39 <sinelaw> nope.
05:03:45 <ivanm> sinelaw: fair enough
05:03:45 <sinelaw> closing the curly braces does
05:03:48 <Gracenotes> well, ^D isn't doing it
05:03:55 <Gracenotes> ooh. That's pretty smart of it.
05:05:14 <ivanm> sinelaw: I think it'd be as simple as unlines . map printDotGraph (or whatever I called that function) for the input stuff
05:05:31 <ivanm> sinelaw: the big thing is, how well does it work for images, etc.?
05:05:43 <sinelaw> ivanm, i have no idea
05:05:44 <ivanm> I'm guessing it only works for Dot output, etc.
05:05:54 <sinelaw> it works.
05:05:58 <sinelaw> i just tried with -Tpng
05:06:32 <Gracenotes> sinelaw: how do you know when it ends?
05:06:32 <ivanm> yeah, I get a big mish-mash
05:06:39 <ivanm> Gracenotes: _that's_ what I'm worried about
05:06:53 <sinelaw> that's a problem
05:07:08 <Gracenotes> for -Tdot, as well as -Tsvg, you can tell when that ends
05:07:09 <sinelaw> unless you parse the file format :) (yuck)
05:07:28 <Gracenotes> sinelaw: I think png, jpeg, etc. have a way of just showing part of the image if you download part of the file
05:07:50 <ivanm> Gracenotes: well, for svg you'd need an xml parser to make sure of it...
05:08:04 <Gracenotes> you could cheat and look for </svg>
05:08:09 <ivanm> heh
05:08:10 <sinelaw> ivanm, not a full one. just to find the /svg skipping strings
05:08:12 <ivanm> but for -Tdot, etc. you'd need to chain the parser...
05:08:34 <sinelaw> for -Tdot it's easy, skip strings and match the closing }
05:08:35 <Gracenotes> ...or you could cheat and look for }
05:08:41 <sinelaw> :)
05:09:04 <ivanm> sinelaw: or just chain the parser
05:09:18 <sinelaw> what do you mean 'chain'?
05:09:21 <Gracenotes> it is pretty-printing it after all
05:09:38 <Gracenotes> ivanm: sounds complicated. but doable. but a complete mess.
05:09:42 <ivanm> sinelaw: OK, so the way polyparse works is when you run a parser, it returns the parsed result and the unconsumed String
05:09:54 <sinelaw> ah ok
05:09:57 <ivanm> atm, I'm chucking away the unconsumed string (after all, it's the empty string, right)
05:10:04 <ivanm> * ? )
05:10:57 <ivanm> so, it's do-able, but it's going to be tricky to determine how to do it only for Dot and maybe Svg
05:11:06 <ivanm> (well, you might as well do it for Canon, XDot, etc. as well)
05:11:22 <sinelaw> might as well if you have time
05:11:22 <ivanm> might be easier to restrict it just to Dot
05:11:32 <sinelaw> i think, restrict it to dot
05:11:42 <sinelaw> but maybe expose an interface for users to implement it for other formats
05:12:55 <sinelaw> ivanm, i don't know how to do this, btw. how would you keep the process alive between calls?
05:12:58 <ivanm> _I_ don't have time ;-)
05:13:30 <sinelaw> ivanm, I know, that's why i was surprised you suggested doing it for more formats
05:13:46 <sinelaw> btw,  it's not urgent in any way or form
05:14:13 <paolino> Baughn: catting the file, so piping it from cat works
05:14:13 <ivanm> OK, if you can wait a month or so I'll have a looksie
05:14:29 <ivanm> sinelaw: if I haven't done anything about it by say mid Feb, gimme a ping and remind me
05:14:44 <sinelaw> ivanm, sure, thanks
05:15:08 <Baughn> paolino: This /has/ to be some sort of bug, but I'll be damned if I can understand what's going on
05:15:15 <Baughn> paolino: ..common with bugs.
05:15:37 <ivanm> sinelaw: write yourself a wrapper function for the time being and use that, so when I do write it it'll be easier for you to change over by just editing the wrapper
05:15:54 <ivanm> that is, a [DotGraph] -> IO [DotGraph] function or something
05:16:05 <sinelaw> ivanm, i too have no time atm. i'm just fiddling with ideas for when i will
05:16:11 <ivanm> fair enough
05:16:19 <paolino> Baughn: looks like , bytes are not coming right from the producer, so stdout is broken, not stdin
05:16:23 <sinelaw> one more exam period to go!!
05:16:34 <sinelaw> can't take this nonsense anymore..
05:16:58 <Baughn> paolino: That doesn't make sense with the error being in /lookahead/
05:17:02 <Baughn> paolino: Unless.. oh god
05:17:12 <voidprayer> Excuse me. I am reading Real World Haskell and not understanding about what a value constructor is. Is it a normal function? And as for later myNot example (myNot True = False), is myNot a fuction of the fuction True?
05:17:48 <ivanm> sinelaw: heh
05:18:03 <shambler> @src not
05:18:03 <paolino> voidprayer: a constructor is a function, but has pattern matching has a feature
05:18:04 <lambdabot> not True   =  False
05:18:04 <lambdabot> not False  =  True
05:19:54 <voidprayer> paolino: I cannot understand it now, but I will remember it as a new point. Thanks.
05:19:58 <voidprayer> @src (+)
05:19:58 <lambdabot> Source not found. Do you think like you type?
05:20:09 <paolino> @src Num
05:20:10 <lambdabot> class  (Eq a, Show a) => Num a  where
05:20:10 <lambdabot>     (+), (-), (*)           :: a -> a -> a
05:20:10 <lambdabot>     negate, abs, signum     :: a -> a
05:20:10 <lambdabot>     fromInteger             :: Integer -> a
05:20:33 <pozic> voidprayer: a constructor construct a value. All values have a type. There is a built-in set of basic values out of which everything else is built.
05:20:38 <shambler> voidprayer, this is pattern matching used in not function
05:21:00 <pozic> voidprayer: example data Foo = Foo Int defines a constructor function Foo of type Int -> Foo.
05:21:34 <pozic> voidprayer: to deconstruct a value of type Foo you can use pattern matching.
05:21:56 <pozic> voidprayer: f (Foo x) = x -- selects x for example.
05:22:11 <voidprayer> yes?
05:22:28 <shambler> > (\x -> if x then False else True) True
05:22:29 <lambdabot>   False
05:22:32 <shambler> > (\x -> if x then False else True) False
05:22:34 <lambdabot>   True
05:23:02 <paolino> so, a constructor is a function for building values of its type, and pattern matching is the reverse of it
05:23:10 <pozic> voidprayer: if you see something which does not start with a capital letter, you know it is a function.
05:23:36 <paolino> normally you cannot reverse functions
05:24:07 <pozic> voidprayer: that is a "normal" function, a "constructor" does always start with a capital letter.
05:24:20 <pozic> voidprayer: anyway, are you sure that RWH does not explain all of this?
05:24:32 <pozic> voidprayer: reading the Haskell report might also help.
05:24:50 <QtPlaty[HireMe]> paolino: Well invertable functions are reversable
05:24:52 <shambler> > (\True -> False) True
05:24:53 <lambdabot>   False
05:25:04 <shambler> cool
05:25:38 <paolino> QtPlaty[HireMe]: constructor are always revertible, but I'd better shut up
05:25:50 <voidprayer> pozic: Haskell report? Another book?
05:26:00 <ivanm> voidprayer: it's _the_ book
05:26:03 <ivanm> that defines Haskell!
05:26:04 <ivanm> @where report
05:26:04 <lambdabot> http://www.haskell.org/onlinereport/
05:26:09 <ivanm> voidprayer: ^^
05:26:27 <voidprayer> ivanm: Thanks. btw, you are everywhere. :)
05:26:31 <ivanm> heh
05:26:33 <ivanm> not quite...
05:27:05 <voidprayer> pozic: Since a confusing sentence there "we can treat a value constructor as just another function", so I really think it as a function.
05:27:21 <pozic> voidprayer: it is just another function.
05:27:31 <Jafet> It isn't.
05:27:47 <Jafet> :t Just
05:27:48 <pozic> voidprayer: it only happens to return a value of the type as specified in the data/newtype declaration.
05:27:48 <lambdabot> forall a. a -> Maybe a
05:27:49 <b_jonas> let's say it decays to a normal value (function if it's of that type)
05:28:12 <pozic> voidprayer: a function x = 1 also constructs the value 1.
05:29:23 <pozic> voidprayer: anyway, I think RWH is quite advanced and actually I believe that some of the authors didn't understand every topic they tried to explain perfectly.
05:29:44 <pozic> voidprayer: if you want to learn Haskell you can better just start with the books that universities use.
05:30:10 <voidprayer> pozic: If I know what they use. :)
05:30:25 <voidprayer> pozic: Haskell Report?
05:30:31 <ivanm> MY CODE HAS AN INFINITE LOOP AND I DON"T KNOW WHERE!!!!!
05:30:33 <ivanm> :@
05:30:40 <pozic> voidprayer: google functional programming course "required material/reading/etc"
05:30:52 <Jafet> ivanm, replace random parts of your code with undefined until you find it
05:30:53 <pozic> voidprayer: Programming in Haskell is often recommended.
05:30:57 <ivanm> voidprayer: Craft of Functional Programming is a good one IMHO
05:31:02 <ivanm> Jafet: :s
05:31:07 <pozic> voidprayer: the Haskell report is not really a physical book.
05:31:12 <Jafet> It's semantics-preserving!
05:31:15 <ivanm> pozic: sure it is!
05:31:31 <voidprayer> Thank all of you, and I start learning now! :)
05:31:36 <ivanm> Jafet: yeah, it then just randomly _crashes_!
05:31:36 <pozic> voidprayer: and it basically assumes that you understand how to read language specifications.
05:31:51 <pozic> That said, reading the Haskell98 report is easier than reading the C standard ;)
05:32:20 <pozic> ivanm: do you have a physical copy?
05:32:27 <ivanm> pozic: I don't
05:32:35 <ivanm> but then I've never read through the entire report anyway
05:33:24 <b_jonas> ivanm: look for functions you accidentally defined as foo = foo
05:33:32 <ivanm> nope, that's not it
05:33:40 <b_jonas> ghc is evil and doesn't warn for that
05:33:41 <ivanm> I know precisely what I added that makes it do a loop
05:33:48 <b_jonas> oh, better
05:33:54 <ivanm> I just don't know _why_ it causes a loop
05:34:20 <b_jonas> because that function is stricter than you'd think
05:34:20 <ivanm> even better: it's a partial heisenbug; it's not till I add some debugging routines that it has <<loop>>; normally it just hangs :s
05:35:04 <pozic> b_jonas: a complicated cycle which does the equivalent of x = x is even worse.
05:35:08 <ivanm> yes, but the question is _why_ is it stricter
05:35:25 <ivanm> what doesn't help is that I'm doing tying the knot with it...
05:35:36 <ivanm> so it's hard to pin-point precisely what is causing the problem :s
05:39:19 <Absolute0> I overrode Show (Maybe Foo) and I get this error: Overlapping instances for Show (Maybe a)
05:39:37 <Absolute0> should I use a different function name for this purpose?
05:39:46 <Absolute0> ie: showFoo
05:40:11 <ivanm> yes
05:40:23 <Absolute0> I dont wan't to see "Just" "Nothing" when I print my values
05:40:28 <ivanm> Absolute0: the Show class is meant to be used to produce code for debugging purposes
05:40:36 <Absolute0> ah
05:40:49 <ivanm> it is often abused to provide general a -> String functions, but it shouldn't
05:40:51 <Absolute0> i thought it was equivalent to the Java toString method.
05:41:14 <ivanm> Absolute0: you can use it in that way, but its discouraged
05:41:17 <paolino> and x = read.show $ x, probably
05:41:22 <ivanm> yup
05:41:32 <ivanm> especially since if you're doing anything serious, you proabably want to use a pretty-printer
05:41:38 <Ke> how about an easy way to save data to a file?
05:41:46 <Jafet> > let x = read (show x) in x
05:41:49 <Absolute0> ivanm: there are libraries for that?
05:41:50 <lambdabot>   mueval-core: Time limit exceeded
05:42:00 <Absolute0> x (Just 5)
05:42:06 <Absolute0> > x (Just 5)
05:42:07 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe t1 -> t'
05:42:07 <lambdabot>         against inf...
05:42:09 <Jafet> :t let x = read (show x) in x
05:42:10 <paolino> Ke writeFile
05:42:11 <lambdabot> forall a. (Read a, Show a) => a
05:42:11 <ivanm> Absolute0: yes, one of them even comes with GHC
05:42:21 <ivanm> I would do @hackage pretty, but hackage is down ;-)
05:42:28 <Ke> :t writeFile
05:42:29 <lambdabot> FilePath -> String -> IO ()
05:42:46 <ivanm> @check read . show == id
05:42:47 <lambdabot>   No instance for (GHC.Classes.Eq (a -> a))
05:42:47 <lambdabot>    arising from a use of `GHC.Cla...
05:42:54 <Ke> paolino: that doesn't really replace show
05:42:54 <Absolute0> ivanm: Isn't a pretty printer specific to every application, how would a general purpose one work?
05:42:58 <ivanm> @check \a -> read . show $ a == a
05:42:59 <lambdabot>   Add a type signature
05:43:07 <ivanm> Absolute0: it's a pretty-printing _library_
05:43:13 <shambler> @type getFst
05:43:14 <lambdabot> forall t t1 t2 t3. ((t -> t1 -> t2 -> t) -> t3) -> t3
05:43:20 <ivanm> so you define a class Pretty with a function pretty :: a -> Doc
05:43:39 <ivanm> and do all your "show" functions that way, then render it at the end
05:43:46 <mpiechotka> @pl \s -> Or [eq s, lt s]
05:43:46 <lambdabot> Or . liftM2 (:) eq (return . lt)
05:43:50 <ivanm> Absolute0: this has advantages in that you're not doing ++ as much
05:44:02 <paolino> Ke: you want to serialize values , without showing them ?
05:44:10 <ivanm> @check \a -> read . show $ a == a :: Maybe Int -> Bool
05:44:11 <lambdabot>   No instance for (GHC.Read.Read
05:44:11 <lambdabot>                     (Data.Maybe.Maybe GHC.Ty...
05:44:17 <HaskellLove> I want to solve 10 eulers in unlambda so i learn some lambda stuff. Am i crazy?
05:44:18 <ivanm> grrrr.....
05:44:21 <ivanm> @instances Read
05:44:22 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
05:44:28 <mpiechotka> @pl \s -> or [eq s, lt s]
05:44:28 <lambdabot> or . liftM2 (:) eq (return . lt)
05:44:33 <ivanm> so why doesn't @check accept them?
05:44:42 <Ke> paolino: just saying that it may be non-trivial without
05:44:45 <ivanm> @pl \ s -> eq s || lt s
05:44:45 <lambdabot> liftM2 (||) eq lt
05:44:48 <ivanm> mpiechotka: ^^
05:45:02 <paolino> Ke: Data.Binary can encode values
05:45:10 <Absolute0> ivanm: http://www.haskell.org/ghc/docs/6.10.1/html/libraries/haskell-src/Language-Haskell-Pretty.html ?
05:45:11 <ivanm> HaskellLove: yes, but I already thought you were lazy
05:45:15 <ivanm> Absolute0: yup
05:45:20 <mpiechotka> ivanm: sorry - I cleared my chat by accident
05:45:29 <shambler> HaskellLove, no, you are not crazy
05:45:41 <ivanm> Absolute0: on hackage (when its up) you can find even more advanced pretty-printing libraries, as well as Pretty classes
05:46:00 <Ke> btw how does show get the constructor names
05:46:01 <mpiechotka> ivanm: And Or is data constructor BTW - not || ;)
05:46:08 <Absolute0> I don't really see a use for it at the moment..
05:46:08 <ivanm> mpiechotka: ahhh
05:46:11 <shambler> if you have random tremors and can't separate reality from dreams than you are
05:46:31 <paolino> @src Show
05:46:31 <lambdabot> class  Show a  where
05:46:32 <lambdabot>     showsPrec :: Int -> a -> ShowS
05:46:32 <lambdabot>     show      :: a   -> String
05:46:32 <lambdabot>     showList  :: [a] -> ShowS
05:46:42 <Absolute0> ivanm: is there any guide online on how to use one?
05:46:49 <ivanm> Absolute0: right, if you're only doing simple stuff then you probably don't need to bother
05:47:05 <paolino> Ke: from that instance, which is derivable
05:47:22 <paolino> which I think is done via template haskell
05:47:24 <ivanm> Absolute0: RWH has a good chapter or two when they discuss writing your own pretty-printing library and using it
05:47:30 <ivanm> I forget what they were doing with it though...
05:47:38 <ivanm> that's right, JSON
05:49:04 <HaskellLove> shambler having the algorithm done, will it be possible to do 1 euler per day in unlambda? I mean, it seems pretty f***ed up
05:50:08 <shambler> i don't know, in fact to solve euler 1 you need a sheet of paper and a pen
05:50:35 <shambler> oh, 1 euler per day
05:51:57 <HaskellLove> shambler no man, i meant if you have already solved it, meaning you have the pseudo algorithm on paper, the problem will be to implement and think that out with unlambda
05:52:10 <shambler> why do you need this?
05:52:36 <ivanm> HaskellLove: if you're serious about learning Haskell, then learn Haskell
05:52:42 <ivanm> and do so WITHOUT PROJECT EULER
05:52:54 <Jafet> I once did an interactive shell in brainfuck
05:52:58 <HaskellLove> shambler to learn church numerals and data types with lambda
05:53:01 <Jafet> It responded to some commands.
05:53:51 <ivanm> HaskellLove: you can do church numerals, etc. in Haskell
05:54:01 <ivanm> even better: get a copy of TaPL and read through it
05:54:14 <ivanm> you know how to read, don't you?
05:54:28 <Jafet> Apparently not, since he was told a similar thing in #math
05:54:38 <HaskellLove> ivanm well yeah that is why i need to learn them, tapl does not give you enough information if you are new to that stuff
05:54:57 <ivanm> Jafet: heh
05:55:49 <Twey> let f = sum . takeWhile (< 1000) . g; g n = iterate (+ n) n in f 3 + f 5
05:55:57 <medfly> hehehe
05:56:02 <ivanm> HaskellLove: I found TaPL's take quite good and easy to read
05:56:03 <Twey> No paper!
05:56:32 <ivanm> actually, that's the only part of TaPL I read (since I had said I'd do a talk on church encoding, then realised I didn't know enough about church encoding...)
05:56:58 <ivanm> dammit, how do I put arbitrary trace statements in a do block?
05:57:12 <ivanm> they keep seeming to get ignored! :s
05:57:17 <HaskellLove> ivanm the rest is advance for you or something? if it is for you i can imagine what it will be for me :(
05:57:18 <Jafet> Heh
05:57:22 <Jafet> How ironic
05:57:37 <ivanm> HaskellLove: no, I just had no reason to read it
05:57:52 <ivanm> since type systems don't really interest me that much
05:58:12 <HaskellLove> you are doing Phd on...?
05:58:14 <ivanm> Jafet: well, I knew what they were, it was the theory behind them I was a bit weak on IIRC
05:58:27 <ivanm> HaskellLove: I will be doing one on combinatorial algorithms
05:58:46 <HaskellLove> cool
05:58:57 <Jafet> No I was talking about how trace gets ignored in do
05:59:26 <ivanm> ahhh
05:59:38 <ivanm> this is a State monad block
05:59:59 <ivanm> gah! it seems I was debugging the wrong bit of code! :s
06:00:10 <medfly> HaskellLove: you read books faster than I decide to read books
06:00:24 <Jafet> Serves you right for not getting it right the first time!
06:00:49 <ivanm> (which explained why the trace message wasn't showing up...)
06:01:12 <HaskellLove> medfly not really i wonder how you got that impression, can you prove that? Try natural deduction or something and bring me proof
06:01:18 <ivanm> one simple little bug, and it's becoming a PITA to solve :s
06:07:18 <tibbe> @seen dcoutts
06:07:19 <lambdabot> Unknown command, try @list
06:07:32 <tibbe> @what's-the-name-of-that-other-bot?
06:07:33 <lambdabot> Unknown command, try @list
06:08:02 <ivanm> preflex: seen dcoutts
06:08:02 <preflex>  dcoutts was last seen on #haskell 7 days, 9 minutes and 31 seconds ago, saying: Raevel: your main modules do not need to be called Main.hs
06:08:05 <ivanm> preflex: seen dcoutts_
06:08:05 <preflex>  dcoutts_ was last seen on #ghc 8 days, 16 hours, 9 minutes and 45 seconds ago, saying: according to my man pages
06:08:27 <tibbe> ivanm: thanks, I guess he's on vacation
06:08:30 <gwern> my man pages. let me show you them.
06:08:31 <polux_> do you know how to set a repo as if it was a remote repo using the topic-provided torrent, in order to let cabal-install resolve dependencies ?
06:08:47 <ivanm> polux_: get each one manually
06:08:52 <polux_> i've tried to generate the index by hand and add a local repo in the cabal-install config file
06:08:56 <polux_> il parses the index
06:09:01 <polux_> but doesn't update the list
06:09:03 * gwern sometimes thinks the early unix devs were quite juvenile
06:09:33 <polux_> ivanm: it;s for gitit...with no prior dependedcies installed
06:09:48 <ivanm> *shrug*
06:10:29 <b_jonas> tibbe: lunabot
06:10:46 <gwern> polux_: you mean set a new hackage url?
06:12:12 <tibbe> b_jonas: thanks
06:12:16 <ivanm> yay, I got a segmentation fault! :s
06:12:46 * ivanm gives up for tonight
06:14:29 * gwern doesn't really understand what polux_ is trying to do. if he has a source repo, just cabal install it. if he has a new hackage url, just set it in .cabal/config. if he wants to not just the source directory but not reset the target hackage URL, sdist inside the directory and copy it over into .cabal/packages whatever
06:18:30 <FliPPeh> Segfaults with Haskell?
06:18:35 <FliPPeh> Even I never managed to do that
06:18:44 <polux_> gwern: if i do cd giti/x.x.x/ ; cabal install
06:18:51 <polux_> there are lots of dependencies
06:19:08 <polux_> i don't want to untar every dependency by hand and thene cabal-install them
06:19:14 <polux_> leading to new dependencies problems
06:19:40 <polux_> in the provided torrent there are "only" tar.gz of hackage packages
06:20:06 <polux_> my question was : how to tell cabl-install to use these tar.gz as if they were a remote repo
06:20:23 <polux_> or : what should i add to these files to make them a valid repo (probably an index file)
06:22:54 <gwern> polux_: oh. I take it then you do not have an existing .cabal/packages/hackage.haskell.org/ then?
06:23:37 <Saizan> polux_: if you "cabal install" inside a project, it should pull the dependencies for you from hackage
06:23:55 <Saizan> oh, but i guess the deps are not from hackage either?
06:25:00 <gwern> polux_: so far as I know, cabal-install's 00-inmdex only contain a list of what could be found in .cabal or online at your specified hackage; if your torrented tgzs are of things on hackage, y hsould be able to copy them over
06:27:10 <Saizan> polux_: if you want you can have a local repo, but you've to configure it in the ~/.cabal/config file, "local-repo: somedir", and somedir has the same layout of a normal cache directory for a remote repo
06:28:11 <Saizan> polux_: the index inside such a directory is just the .cabal files of the packages tarred together
06:29:10 <polux_> gwern: Saizan: ok, if I create an index with all the .cabal files, name it 00-index.tar.gz, put it along with the tar.gz in a directory "repo" and add file:///"repo" as a remote-server, cabal-update doesn't complain
06:29:23 <polux_> but when i type cabal list, i only gt the list of installed packages
06:29:27 <gwern> polux_: cool. too bad there's no easier way for you though
06:29:39 <polux_> so there must be something else in 00-index.tar but i don't know what
06:29:39 <gwern> really?
06:29:48 <gwern> is the tgz still old?
06:30:06 <polux_> i just built the tgz as i said
06:30:11 <gwern> maybe cabal list works off the tgz. I always wondered why there were 2 indexes
06:30:22 <polux_> i'm sure it is read because if it doesn't exist, cabal update complains
06:30:40 <Saizan> polux_: not remote-serve, local-repo .
06:30:49 <Saizan> polux_: and it has to be a .tar not a .tar.gz
06:30:50 <polux_> what it does (i looked at the sources), is to fetch the tgz, copy it in the local cache and gunzip it
06:31:04 <polux_> then, normally, cabal list reads the unzipped version
06:31:44 <polux_> Saizan: that is equivalent to what i just did, except that the remote-repo way of doing things requires cabal to handle a cache
06:31:54 <polux_> Saizan: i tried your solution too, same problem
06:32:03 <polux_> i'm pretty sure i missed somthing building the index
06:32:08 <polux_> but i don't know why
06:32:13 <polux_> what
06:32:44 <polux_> unfortunately i erased my old \index
06:32:54 <Saizan> polux_: can't you look at the index cabal-install produces when you do cabal update?
06:33:11 <Saizan> oh, hackage is down?
06:33:44 <polux_> Saizan: i can't cabal update on hackage, which has a valid index, and when i cabal-update on the repo i hand-made, what cabal-install does is only to get the tar.gz and unzip it
06:34:04 <polux_> Saizan: that's the whole point :)
06:34:24 <Saizan> yeah. cabal-install just unzips it
06:34:44 <polux_> can one of youi provide me with a valid index please ?
06:34:57 <polux_> so that i can compare to the one i made, or just use it
06:36:37 <Saizan> http://code.haskell.org/~Saizan/00-index.tar.gz
06:37:40 <polux_> saiam: thanks !
06:38:57 <Saizan> i would just copy and unzip it, rather than trying to make a fake repo so that you can cabal update
06:39:28 <polux_> Saizan: thanks, i don't know what's the difference with mine, but it works with your index
06:40:27 <Saizan> polux_: maybe the preferred-versions file
06:41:49 <Absolute0> Word64 is an instance of Integral but "toInteger 2::Word64" fails
06:41:52 <Absolute0> > toInteger 2::Word64
06:41:54 <lambdabot>   Couldn't match expected type `GHC.Word.Word64'
06:41:54 <lambdabot>         against inferred typ...
06:42:05 <Absolute0> :info Word64
06:42:15 <Saizan> > toInteger (2 :: Word64)
06:42:16 <lambdabot>   2
06:42:21 <Axman6> Absolute0: that's because you wrote (toInteger 2) :: Word64 really
06:42:25 <Absolute0> :)
06:42:40 <Axman6> :: binda very low
06:42:43 <Axman6> minds*
06:42:45 <Axman6> b*
06:42:47 <Axman6> etyhkljrtijobgfsgn
06:42:51 <Absolute0> > logBase 2 $ toInteger (2 :: Word64)
06:42:53 <lambdabot>   No instance for (GHC.Float.Floating GHC.Integer.Internals.Integer)
06:42:53 <lambdabot>    arisi...
06:42:54 <edwardk_> > toIntegral 2 :: Word 64
06:42:55 <Absolute0> fuck
06:42:55 <lambdabot>   Only unit numeric type pattern is validNot in scope: `toIntegral'
06:43:09 <edwardk_> > fromInteger 2 :: Word64
06:43:10 <lambdabot>   2
06:43:12 <edwardk_> =)
06:43:26 <Saizan> > logBase 2 $ fromIntegral (2 :: Word64)
06:43:27 <lambdabot>   1.0
06:43:51 <Absolute0> Floating is instantiated by Integral?
06:44:06 <Saizan> Floating and Integral are both classes
06:44:15 <Absolute0> I mean Fractional
06:44:18 <Saizan> ?type fromIntegral
06:44:19 <lambdabot> forall a b. (Integral a, Num b) => a -> b
06:44:36 <Saizan> Fractional is a class too, and it's a superclass of Floating iirc
06:44:42 <Absolute0> lol
06:44:45 <Absolute0> forget about it
06:44:52 <Saizan> fromIntegral produces any Num, however
06:44:54 <Absolute0> same discussion as yesterday
06:45:15 <Saizan> in this case we're using it to make a Double
06:45:18 <Absolute0> Num can be a Double/Float?
06:45:30 <Absolute0> yes it can
06:45:31 <Absolute0> :)
06:45:36 <Absolute0> :info Num
06:46:01 <Saizan> you need ghci for :info :)
06:46:12 <Absolute0> right i was just illustrating..
06:51:04 <LeoD> is there something like 'array' except for MArrays? i want to create an IOArray from assocs
06:51:58 <LeoD> tried hoogling a bit, but hackage seems to be down?
06:52:51 <Saizan> yeah, hackage is down
06:52:59 <koeien37> again? :(
06:53:43 <basvandijk> See the reverse dependency hackage from my brother: http://bifunctor.homelinux.net/~roel/hackage
06:54:00 <LeoD> oh sweet
06:57:03 <filcab> hi all
06:57:14 <roelvandijk> Ok which of you is using this for a browser: Microsoft Data Access Component Internet Publishing Provider Protocol Discovery?
06:57:14 <BONUS> LeoD: newArray?
06:57:21 <BONUS> :t newArray
06:57:22 <lambdabot> Not in scope: `newArray'
06:57:27 <roelvandijk> Sounds enterprise ready
06:57:32 <BONUS> i mean
06:57:34 <BONUS> newListArray
06:57:37 <koeien37> roelvandijk: lol
06:57:45 <Saizan> ?google newListArray
06:57:46 <lambdabot> No Result Found.
06:57:56 <LeoD> BONUS: hm, doesn't this just take a list of elements as opposed to a list of assocs? not sure
06:58:08 <BONUS> ah yeah it does
06:58:09 <LeoD> Data.Array.MArray newListArray :: (MArray a e m, Ix i) => (i, i) -> [e] -> m (a i e)
06:58:12 <LeoD> right
06:58:46 <BONUS> but i think that the thing with MArrays is that indices are supposed to get assigned by the array instance
06:59:07 <LeoD> hm
06:59:24 <BONUS> so im not sure but i think you can't explicitly specify your indices like you can with immutable arrays
06:59:45 <LeoD> ok
07:00:54 <Saizan> i wouldn't think that
07:01:49 <Saizan> you've readArray and writeArray that work directly with indices
07:01:58 <Saizan> and you provide the bounds yourself
07:02:20 <dolio> unsafeRead and unsafeWrite use the underlying Ints.
07:02:31 <dolio> Custom indices are built on top of those.
07:02:40 <BONUS> ah
07:02:52 <dolio> Fooling with stuff in the Ix class.
07:04:28 <FliPPeh> :/
07:04:30 <FliPPeh> Oh whoops
07:07:25 <byorgey> hi filcab
07:07:33 <filcab> hi
07:07:43 <filcab> ah, almost forgot... Is hackage down?
07:07:51 <BONUS> LeoD: maybe you can use thaw
07:07:55 <byorgey> yep
07:07:57 <Twey> /t
07:07:57 <filcab> cabal: connect: does not exist (Connection refused)
07:07:57 <filcab>  
07:08:01 <Baughn> Disk error, again
07:08:03 <filcab> damn
07:08:09 <filcab> thanks
07:08:10 <Baughn> It's resyncing now.
07:08:14 <Saizan> there's a torrent in the topic
07:08:17 <filcab> anyone has a time frame for it?
07:08:20 <byorgey> torrent at http://bit.ly/4u5JwZ, according to the IRC status
07:08:21 <BONUS> make an immutable array and then use thaw to copy it into a mutable one
07:08:21 <LeoD> BONUS: oh, that's pretty awesome :D it does exactly what i need anyway
07:08:28 <LeoD> as i already have the immutable array :)
07:08:31 <koeien37> how large is hackage nowadays?
07:08:32 <BONUS> hehe
07:08:36 <byorgey> s/status/topic/
07:08:51 <filcab> also... can I install stuff with cabal using a secondary GHC implementation?
07:09:10 <filcab> I have the darcs version and wanted to install some libs using that version
07:09:13 <Saizan> filcab: yes, pass -w theotherghcexecutable
07:09:19 <roelvandijk> koeien37: I believe there are some 1773 packages on hackage
07:09:20 <filcab> thanks
07:09:33 <filcab> cabal --help didn't... help me with that ;-)
07:09:38 <byorgey> roelvandijk: surely you mean 1337 ?
07:09:45 <koeien37> if they'd set up rsync, there might be volunteers for mirroring
07:09:54 <Saizan> filcab: cabal configure --help or cabal install --help do
07:10:03 <leimy> darn no conal yet today :-)
07:10:10 <byorgey> there are definitely some 1337 packages on hackage
07:10:13 <filcab> oh, right
07:10:16 <filcab> thanks
07:12:09 <roelvandijk> byorgey: Hackage has transcended 1337 packages
07:12:18 <polux_> http://pastebin.com/m72d59ad4 <- script to generate valid index
07:12:56 <gwern> one day, there may even be over 8000
07:13:04 <mux> over 9000!
07:13:11 <roelvandijk> Madness!
07:13:40 <gwern> madness? THIS IS #SCALA!!!!
07:13:49 <roelvandijk> It was an interesting challenge for the rev. dep. algorithm
07:14:05 <roelvandijk> You have to take into account every version of every package
07:14:23 <roelvandijk> There are about ~6000 package-versions on hackage.
07:14:42 <polux_> is there some torrent for *all* packages on hackage (including previous versions of packages) ?
07:14:44 <koeien37> not every latest version is enough?
07:14:54 <koeien37> roelvandijk: could you run du -ch hackage ?
07:15:13 <polux_> koeien37: no, some recent packages depend on older versions of other packages
07:15:20 <roelvandijk> koeien37: sure, momoent
07:15:22 <roelvandijk> *moment
07:15:43 <koeien37> polux_: ah, sure, of course.
07:16:08 <roelvandijk> koeien37: 167M, but I only have the date from the torrent
07:16:19 <koeien37> that's not too big
07:16:32 <koeien37> if the total is reasonable, I might set up a mirror somewhere
07:16:41 <roelvandijk> koeien37: I think that if I would have all verions that you'll have about 900MB of data
07:16:45 <gwern> polux_: eh, just run wget -m
07:17:09 <koeien37> I don't have any versions except for the hackage-torrent from last year
07:17:25 <roelvandijk> me neither
07:17:47 <koeien37> I wouldn't mirror everything, but try to mirror only the latest versions
07:17:59 <koeien37> + what's necessary for them to build.
07:18:12 <roelvandijk> I would like to get my hands on the complete set of packages and then stay up to date with some syncing mechanism
07:18:20 <roelvandijk> Then I could do some nice datamining
07:18:25 <polux_> gwern: from where ?
07:18:37 <koeien37> roelvandijk: the hackage maintainers may be able to set up rsync
07:19:06 <roelvandijk> koeien37: That would be nice. Then i'll only need a little cron job
07:19:32 <Saizan> roelvandijk: are you using the new hackage-server or the cgi scripts?
07:19:41 <roelvandijk> Saizan: cgi scripts
07:20:25 <koeien37> roelvandijk: if they are able & willing, there might be some initiaves from the Haskell community :)
07:21:16 <Absolute0> Is there a better way of doing: let f x = 2^ (truncate $ logBase 2 x) ?
07:21:27 <Absolute0> I seem to be going back and forth naively
07:21:47 <quicksilver> nearest power of two below x?
07:21:53 <Absolute0> right
07:22:29 <quicksilver> what type is x? Int?
07:22:34 <Absolute0>  /2 + 1?
07:22:41 <koeien37> that appears to be impossible if x is logBase'd
07:22:45 <polux_> any idea about when hackage will be up again ?
07:22:51 <Absolute0> `div` 2 + 1 should do it I think.
07:23:10 <quicksilver> no, that just gives you a number which is about half of x
07:23:12 <Absolute0> > let f x = 2^ (truncate $ logBase 2 x)
07:23:14 <lambdabot>   not an expression: `let f x = 2^ (truncate $ logBase 2 x)'
07:23:15 <roelvandijk> polux_: I think most maintainers are on vacation...
07:23:17 <quicksilver> that's not a power of two ;)
07:23:33 <koeien37> there are some byte manipulation tricks you could use if x of type Bits a => a
07:23:35 <quicksilver> > let f x = 2^ (truncate $ logBase 2 x) in f 100
07:23:36 <lambdabot>   64
07:23:47 <koeien37> s/byte/bit
07:23:53 <Absolute0> hmm works in ghci..
07:24:08 <quicksilver> lambdabot is strictly an expression evaluator
07:24:12 <quicksilver> ghci is a strange hybrid.
07:24:14 <Absolute0> oh
07:24:17 <koeien37> lambdabot only evaluates expressions
07:24:20 <shambler> @let
07:24:22 <lambdabot>  Defined.
07:24:25 <shambler> oops
07:24:25 <koeien37> ghci works in the IO monad, or evaluates expresions, depending on the type
07:24:39 <quicksilver> I would imagine the fastest way is to do a binary chop on possible powers of two
07:24:40 <Absolute0> So I am doing it optimally?
07:24:40 <koeien37> ghci is a magical IO-performer
07:24:53 <quicksilver> staying in integer math
07:24:57 <quicksilver> but obviously that's more code
07:25:01 <HaskellLove> When would you prefer Gentzen over Hilbert system?
07:25:09 <Absolute0> fine looks fine to me, thanks :)
07:32:44 <pozic> Is there any non-trivial algorithm implemented in Haskell on Hackage?
07:33:17 <roconnor> pozic: no
07:33:26 <pozic> That is an algorithm which needs at least 500 lines to implement for example containing complex invariants and so on.
07:33:42 <roconnor> oh
07:33:43 <roconnor> maybe
07:34:06 <stoop> roconnor, what do you think is a "non-trivial algorithm"?
07:34:20 <roconnor> stoop: one that cannot be understood by humans
07:34:26 <koeien37> "which needs at least 500 lines"
07:34:33 <koeien37> dangerous :)
07:34:36 <lispy> ?seen dcoutts
07:34:37 <lambdabot> Unknown command, try @list
07:34:46 <lispy> ,seen dcoutts
07:34:47 <mreh> preflex: seen dcoutts
07:34:48 <preflex>  dcoutts was last seen on #haskell 7 days, 1 hour, 36 minutes and 16 seconds ago, saying: Raevel: your main modules do not need to be called Main.hs
07:34:49 <lunabot>  luna: Not in scope: `seen'
07:34:50 <stoop> roconnor, can you give me an example of such an algorithm?
07:34:57 <roconnor> stoop: no
07:35:01 <lispy> ,seen dcoutts_
07:35:02 <lunabot>  luna: Not in scope: `seen'
07:35:13 <lispy> preflex: seen dcoutts_
07:35:13 <preflex>  dcoutts_ was last seen on #ghc 8 days, 17 hours, 36 minutes and 53 seconds ago, saying: according to my man pages
07:35:14 <stoop> roconnor, I see where you're going with this.
07:35:14 <mreh> lispy, use prflex ^
07:35:19 <stoop> roconnor, ok. :-)
07:35:26 <pozic> stoop: computing a planar embedding for example.
07:35:31 <lispy> Hmmm....is Duncan on vacation?
07:35:54 <mreh> he's move to monastry
07:35:57 <roconnor> there are some programs that magically solve some problem but we cannot prove in any reasonal proofs system that they work.
07:36:06 <pozic> roconnor: example?
07:36:16 <mreh> k-means clustering!
07:36:19 <roconnor> or at least it is impossible for there not to be such programs
07:36:48 <pozic> roconnor: yes, but mere existence is different from pointing at one of them.
07:36:54 <roconnor> yes
07:36:59 <mreh> the explanation I got for k-means clustering is, well, we think it converges on a solution, but we're not sure why...
07:37:01 <roconnor> which is why they are not on hackage
07:37:18 <pozic> roconnor: I was not using the Rice sense of non-trivial ;)
07:37:24 <roconnor> oh
07:37:30 <pozic> roconnor: and you were well aware of that.
07:37:44 <stoop> Eeek, hackage is down?
07:37:52 <mreh> stoop, read the topic
07:38:06 <roconnor> pozic: sorry, when I read your question I thought you were trying to knock hackage
07:38:18 <roconnor> pozic: at your second comment I realized you were serious
07:38:26 <stoop> mreh, I read it once.
07:39:08 <mreh> stoop: the guy that runs the server is probably not awake
07:39:36 <mreh> I think they're on the west coast
07:39:55 <mreh> so lets say he gets into work in 20 minutes
07:40:01 <koeien37> this is utter speculation
07:40:07 <koeien37> maybe the serveri s exploded
07:40:18 <mreh> koeien37, yes, maybe, but how likely is that?
07:40:18 <koeien37> and it takes months to replace because Galois is bankrupt
07:40:41 <mreh> i could set it up in my garage if you like
07:40:45 <roconnor> koeien37: let me post your speculation to reddit
07:41:16 <mreh> could someone explain to me the difference between the posterior and the likelihood?
07:42:00 <harrisonpartch> i can't tell the difference between the likelihood and MY posterior. Does that help?
07:42:07 <mreh> no
07:43:57 <roelvandijk> Does haddock use hscolour as a library or as an executable?
07:47:40 <edwardk_> mreh: read the first line of the definition in http://en.wikipedia.org/wiki/Posterior_probability
07:49:54 <gwern> I sometimes wonder why no philantrophist has set up a program in which they build essentially a monastery, add a kitchen offering food at soup kitchen price levels, and purchase university library memberships, and then stuffs it full of intellectuals with a small stipend
07:50:16 <edwardk_> the posterior distribution contains the updated knowledge of the hyperparameters of your distribution given the new information gained by the observations
07:50:30 <mreh> gwern: that called the church
07:50:31 <gwern> being a kind of secular monastery - just enough to actually live, letting scholars work for years at a time
07:50:43 <HaskellLove> general computer science question: I might use Oz as backend if i were to write a multi paradigm programming language right? Give me some opinions related please...
07:50:47 <Ke> like universities?
07:50:53 <gwern> 'you can live and research here indefinitely as long as you produce something every 5 or 10 years'
07:51:03 <gwern> Ke: well, without the constent evaluation and credentialing
07:51:11 <mreh> gwern: sounds expensive
07:51:29 <Ke> gwern: you can just do very badly at an university
07:51:29 <mreh> take them hostage for free
07:51:45 <mreh> like the russians in the cold war
07:51:53 <gwern> mreh: I don't think so. I do mean at the minimum. how much do scout camps cost to run? that's the level of comfort and luxury I'm talking about
07:51:59 <edwardk_> HaskellLove: i'm not a huge fan of Oz's distributed knowledge accumulation model, it seems to have some awkward inefficiencies intrinsic to its design, but then i'm fairly opinionated ;)
07:52:09 <gwern> in comparison, university dorms are ridiculously soft, and hence, expensive
07:52:14 <gwern> and their food! *sushi*?
07:52:29 <edwardk_> HaskellLove: oz is an example of a multiparadigm programming language, writing one targeting Oz seems slightly ... redundant ;)
07:52:41 <gwern> my hypothetical kitchen should be able to get food down to a dollar or 2 per person per day
07:52:49 <Ke> gwern: mental work requires quite a bit of more comfort than camping
07:52:54 <lispy> Is hackage still down?
07:53:07 <edwardk_> gwern: but i do some of my best work over sushi!
07:53:11 <gwern> Ke: does it really? why is prison so beloved of writers?
07:53:15 <koeien37> lispy: for me it is
07:53:20 <gwern> edwardk_: that's because you're soft and lazy!
07:53:28 <edwardk_> gwern: because they have nothing else to do there?
07:53:28 <Ke> gwern: ok
07:54:01 <HaskellLove> edwardk_ not if you wanted to be a compiler engineer, not redundant at all, i see it as the ultimate experience writing your own language over decades...
07:54:02 <edwardk_> gwern: productivity per hour is lower, but the percentage of people writing in prison is higher than in the general population due to their different circumstances
07:54:18 <gwern> edwardk_: exactly. my hypothetical secular monastery isn't for people who want to raise a big family and pursue their dreams of being a pop culture science star - it's for people who don't care what they're eating because they're busy working on their next theorem in their head or something
07:54:28 <edwardk_> HaskellLove: ultimately you'll want to do something that won't fit into the Oz box.
07:54:29 <gwern> and who don't want to be bothered for a couple years or decades
07:54:45 <edwardk_> gwern: did you just come down from reading Anathem or something? =)
07:54:49 <gwern> how many productivity is lost, I wonder, to administrative overhead
07:54:55 <gwern> edwardk_: never even read it, actually
07:55:06 <edwardk_> gwern: i highly recommend it given your current interests ;)
07:55:21 <edwardk_> come back in a thousand pages or so ;)
07:55:46 <gwern> (I worry that such an institution would foster psychosis, like the early Quaker prisons with solitary confinement; and science seems ever more collaborative too)
07:56:21 <edwardk_> gwern: short version of why is basically the entire book centers around a nested series of institutions that do exactly that
07:56:41 <HaskellLove> edwardk_ I doubt the prison productivity thing... Watching over if someone wants to screw you or kill you, will add overhead, a loot. Creative writing, storytelling yes will do good there.... but doing science in such enviornment is not posible unless you are some extreme complete self-control freak
07:57:05 <gwern> ah. wonder how their costs are. that's the big deal, can the costs be so low that you can afford to let in all sorts of parasites and losers but still resist the temptation to demand results within a few years?
07:57:25 <koeien37> "screw you or kill you"
07:57:35 <koeien37> what kind of prison is this?
07:57:44 <gwern> koeien37: medium security presumably
07:57:49 <edwardk_> HaskellLove: i'm hardly claiming it increases productivity, i merely point out there are a finite number of things you can do in a cell with the tools you're allowed access to in the prison, and so more of the population turns to writing, simply because of the lack of fewer options. not necessarily because prison is a great place to write ;)
07:58:17 <gwern> koeien37: in a supermax, there would be few such opportunities; in a low-security prison, the population isn't bad and you don't have to worry about those issues
07:58:31 <HaskellLove> edwardk_ increased activity in quantity yes, but i doubt the quality
07:58:34 <harrisonpartch> gwern have you  read magister ludi?
07:58:48 <HaskellLove> koeien37 come i will show you one
07:58:55 <gwern> harrisonpartch: think I've heard of it. same guy who did Siddhartha or Demian?
07:58:56 <harrisonpartch> castalia is like your monastery
07:58:57 <edwardk_> gwern: the mechanism from anathem was that entering each level was a commitment for a given number of years. the outer ring only allowed access every year, the next one in every decade, the next every century, etc.
07:59:07 <edwardk_> HaskellLove: never claimed anything about quality =)
07:59:12 <harrisonpartch> yes, and it is a working out of your idea, sort of
07:59:38 <edwardk_> koeien37: obviously, given HaskellLove's earlier discussion, his understanding of prisons comes from 'Oz' =)
07:59:44 <gwern> edwardk_: that'd never work. even cloistered nunneries can't remain insulated for centuries or more
07:59:48 <HaskellLove> edwardk_ ah we agree then :)
08:00:22 <HaskellLove> edwardk_ why understanding prison comes from Oz?
08:00:26 <edwardk_> gwern: i agree there are practical considerations, the isolation wasn't perfect, etc.
08:00:30 <quicksilver> I wonder how much of what phil hassey does ( http://www.philhassey.com/blog/ ) would be easier if he just used haskell, rather than messing around with a custom python-like dialect plus python-to-C++ converter
08:00:45 <edwardk_> HaskellLove: Oz the TV show as opposed to your earlier discussion of Oz the language.
08:00:45 <quicksilver> seems to me he's trying to recreate haskell in an ad-hoc way
08:00:55 <HaskellLove> edwardk_ hehe
08:01:14 <Jafet> quicksilver, good! We need more implementations of Haskell
08:01:20 <gwern> quicksilver: his posts never mention haskell either
08:01:29 <quicksilver> gwern: I don't think he knows about it.
08:02:15 <gwern> edwardk_: and then there are other considerations. what discipline is so slow moving that missing the 20th  century doesn't put you hopelessly out of date? I can't think of any
08:02:43 <Notfrank> can anyone help me with the Text.Html package
08:02:58 <Notfrank> Ive made this function:
08:02:59 * benmachine wonders why 'everything' in Data.Generics uses foldl rather than foldr
08:03:02 <koeien37> Notfrank: I've used Text.XHtml, not Html. But what's your question?
08:03:12 <Notfrank> inlineToHtml :: Inline -> Html
08:03:23 <Notfrank> wait that looks chaotic
08:03:31 <koeien37> ?hpaste
08:03:31 <HaskellLove> edwardk_ you guys talking about Anathem and stuff, I quited reading non technical stuff months ago, i have found out that the only place where you learn is real life. so now i just read computer science
08:03:31 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
08:03:32 <edwardk_> gwern: they were working on fairly glacial time scales to preserve math and physics through the changes in the surrounding culture -- like i said, give it a shot. it - like all fairly esoteric words is an interesting internally consistent if somewhat flawed idea
08:03:37 <edwardk_> er works
08:03:41 <gwern> Notfrank: chaotic lawful, I should say
08:03:49 <Notfrank> anyhow
08:03:58 <Notfrank> I need to fix it for links too
08:04:04 <Notfrank>    -- URILink txt link    ->
08:04:16 <Notfrank> but I have no idea how and the site is down
08:04:28 <Notfrank> its something with href
08:04:32 <edwardk_> HaskellLove: I like to come up for air every once in a while ;)
08:04:47 <koeien37> Notfrank: I don't know what inlineToHtml does
08:05:18 <Notfrank> I made a data type Inline
08:05:38 <Notfrank> data Inline
08:05:43 <koeien37> please, paste your code
08:05:44 <koeien37> ?hpaste
08:05:45 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
08:05:57 <koeien37> that's more readable for all of us
08:06:06 <Notfrank> ?hpaste data Inline
08:06:06 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
08:06:10 <Notfrank> how?
08:06:25 <koeien37> you make a new paste there (click "new"), then give us the link
08:06:49 <aiko> is there a hackage mirror somewhere?
08:06:59 <koeien37> aiko: there is a torrent, but it's somewhat out of date
08:07:06 <koeien37> see /topic
08:07:39 <Canar> are there any people fluent in ruby in here? i've been trying to implement a version of a project of mine in haskell, but i'm a total noob and can't figure out something basic
08:07:53 <dino-> I've run into the ghc 6.8 vs 6.10 Control.Exception thing with defining a handler for handle like: (\_ -> return Nothing) ..
08:07:55 <Canar> print Array.new(16){|i|Math::sin(i/16.0)}.pack("d*") <-- i'm trying to make haskell do this
08:08:03 <aiko> koeien37: thanks. I skimmed the backlog but somehow missed that
08:08:06 <dino-> Now, I've read about using Control.OldException as a workaround
08:08:13 <xerox> Canar what is pack("d*") ?
08:08:25 <dino-> But how to do this with the newer Control.Exception?
08:08:29 <Jafet> Canar, you can help by translating that into english
08:08:31 <Canar> xerox: binary output of a double
08:08:51 <xerox> Canar is i 0 based or 1 based
08:09:13 <Canar> xerox: 0-based
08:09:30 <roelvandijk> aiko: you can also try http://bifunctor.homelinux.net/~roel/hackage
08:09:39 <Canar> basically i'm just looking to output a list of doubles in binary
08:09:42 <koeien37> > map decodeFloat $ map (sin . (/16)) [0..15] -- and then use binary ?
08:09:44 <xerox> > map (sin . (/16.0)) [0..16] :: [Double]
08:09:44 <lambdabot>   [(0,0),(9001336337944283,-57),(8983761325059638,-56),(6715886542713525,-55)...
08:09:45 <lambdabot>   [0.0,6.24593178423802e-2,0.12467473338522769,0.18640329676226988,0.24740395...
08:09:50 <Notfrank> koeien37
08:09:51 <Notfrank> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5961#a5961
08:10:05 <Jafet> Canar, you can do that in Haskell, but not in Haskell.
08:10:14 <Jafet> Why do you want to do it, anyway?
08:10:17 <koeien37> Jafet: are we talking about quantum mechanics?
08:10:31 <byorgey> Canar: do you care whether the doubles are in IEEE format, or just that Haskell could read them back in again?
08:10:33 <Jafet> Serialization is a Bohr.
08:10:43 <Canar> byorgey: needs to be IEEE
08:10:45 <koeien37> Notfrank: there might be a "hyperlink" function like in Text.Xhtml
08:10:57 <Canar> i'm playing around with a basic softsynth and am piping output directly into sox-play
08:11:04 <byorgey> Canar: ok, for that I think there is a package on Hackage called data-binary-iee357 or something like that
08:11:11 <byorgey> I'm sure I got the number wrong
08:11:14 <aiko> roelvandijk: can I configure cabal to use that mirror?
08:11:19 <koeien37> Notfrank: X.hotlink "http://www.skritter.com/vocab/export" (X.stringToHtml "Export your vocabulary list from Skritter,")
08:11:23 <koeien37> e.g.
08:11:35 <koeien37> (I don't know whether this also exists in Text.Html)
08:11:38 <Jafet> Hm, I'd consider doing integer output
08:11:45 <Canar> i suspect haskell has superior abstraction capability than ruby, which is why i'm interested, but the problem is that implementing such a "trivial" function is quite beyond my capacity
08:11:46 <roelvandijk> aiko: No, it was not meant as a mirror.
08:11:54 <Canar> it's a one-liner in ruby, on the other hand
08:11:56 <Jafet> Unless you need a ridiculous numerical range
08:12:03 <roelvandijk> aiko: But you can manually install stuff
08:12:20 <byorgey> Canar: yeah, as with any pair of languages, there are some things that are easy in one and hard in the other
08:12:20 <koeien37> Canar: it's also a one-liner in Haskell, but the function to do that is not part of the base haskell packages
08:12:29 <Canar> i know this :)
08:12:32 <Jafet> Haskell does not know about IEEE 754, period.
08:12:37 <benmachine> what about the RealFloat methods?
08:12:42 <koeien37> :t decodeFloat
08:12:44 <lambdabot> forall a. (RealFloat a) => a -> (Integer, Int)
08:13:03 <Jafet> I'd still go with integer samples
08:13:04 <byorgey> benmachine: no, those won't give you IEEE format.
08:13:17 <benmachine> k
08:13:18 <ClaudiusMaximus> personally i'd use the FFI to fill an array of CFloat in memory and hPutBuf it
08:13:18 <name> hi
08:13:26 <benmachine> one of them is called isIEEE though
08:13:38 <byorgey> ClaudiusMaximus: I've done that, it's uglee
08:13:40 <byorgey> hi name
08:13:52 <name> is there something like max to which i can pass a function that returns the key for the element?
08:14:00 <ClaudiusMaximus> @hoogle [a] -> Ptr a -> IO ()
08:14:00 <lambdabot> Foreign.Marshal.Array pokeArray :: Storable a => Ptr a -> [a] -> IO ()
08:14:00 <lambdabot> Foreign.Marshal.Array pokeArray0 :: Storable a => a -> Ptr a -> [a] -> IO ()
08:14:00 <lambdabot> Foreign.Storable poke :: Storable a => Ptr a -> a -> IO ()
08:14:03 <luite> what is the parsec 3 replacement for CharParser st String   (or which extra modules do I need to import? sorry to ask here, I don't have haddock for this package and can't redownload it)
08:14:08 <byorgey> name: the key for the element in what?
08:14:27 <ClaudiusMaximus> @hoogle [a] -> (Int -> Ptr a -> IO b) -> IO b
08:14:28 <lambdabot> Foreign.Marshal.Array withArrayLen :: Storable a => [a] -> (Int -> Ptr a -> IO b) -> IO b
08:14:28 <lambdabot> Foreign.Marshal.Array withArrayLen0 :: Storable a => a -> [a] -> (Int -> Ptr a -> IO b) -> IO b
08:15:52 <luite> oh guess I can just use GenParser Char instead, until hackage returns :)
08:15:55 <benmachine> luite: Parsec s u a is a parser that parses input of type s, has state of type u, and produces an a
08:15:58 <name> byorgey: say i have a list of elements of records and i want to use a particular "member" for comparision
08:16:00 <benmachine> in parsec3
08:16:13 <byorgey> name: oh, I see.  use maximumBy in Data.List
08:16:19 <benmachine> so I think you'd want Parsec String st String but I don't quite remember what CharParser does
08:16:29 <byorgey> @type maximumBy
08:16:31 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
08:16:55 <benmachine> maximumBy comparing, probably
08:17:02 <byorgey> name: 'comparing' is also useful for constructing the (a -> a -> Ordering)_ function
08:17:11 <aiko> what's the command line option for ghc to just run a .hs?
08:17:15 <benmachine> > maximumBy (comparing snd) [(1, 2), (3, 1), (0, 5)]
08:17:15 <byorgey> > maximumBy (comparing fst) [(1,3), (5,7), (2,9)]
08:17:16 <lambdabot>   (0,5)
08:17:17 <lambdabot>   (5,7)
08:17:30 <dino-> Ah, fixed when I made my handler function :: SomeException -> IO (Maybe Integer)
08:17:43 <aiko> ah, runghc
08:17:52 <luite> benmachine: ah that works, I think the difference is that GenParser expects a list of tokens, so Parsec String ~ GenParser Char
08:18:29 <name> to find the max by first comparing one member and then, amongst those equal in that member comparing another isn't built in, is it?
08:18:47 <xerox> type Parser = Parsec String ()     type GenParser tok st = Parsec [tok] st
08:18:58 <Notfrank> but like how do i just make a link in html, in the haskell module, so it comes out as <a href="location">NAME</a>, just like << old gives <b> </b>
08:19:12 <luite> xerox: ah even better :)
08:19:25 <luite> so Parser ~ CharParser
08:19:33 <xerox> :)
08:19:35 <dino-> Notfrank: There's an anchor function in Text.Xhtml
08:19:50 * benmachine didn't know there was a Parser in parsec3
08:20:05 * benmachine can't find one in ghci
08:20:48 <xerox> benmachine Parser is exported by Text.Parsec.String Text.Parsec.ByteString and Text.Parsec.ByteString.Lazy
08:20:49 <dino-> Notfrank, something like: anchor [href "http://foo.bar/baz"] << "foo"
08:20:54 <koeien37> Notfrank: <a> is anchor
08:21:00 <xerox> (as well as GenParser)
08:21:09 <koeien37> in XHtml, it would be anchor ! [href "bla"] << innerHtml
08:21:15 <koeien37> (again, don't know about Html)
08:21:16 <benmachine> xerox: ah, right, I wonder why it isn't re-exported by Text.Parsec
08:21:22 <dino-> bleh, sorry, missed the ! in mine
08:21:27 <dino-> Listen to koein37!
08:21:29 <Notfrank> ok ill try, thanks
08:21:36 <zygoloid> benmachine: because it's different types in the different cases
08:21:39 <zygoloid> (iirC)
08:21:43 <xerox> benmachine what instance would be the default one?
08:21:44 <koeien37> dino-: in XHtml, there is a helper function "hotlink" for it
08:21:46 <benmachine> oh, of course
08:21:48 <xerox> zygoloid yep
08:22:17 <dino-> koeien37: Oh my, I could have used that in my web app!
08:22:19 <xerox> the three things that change with .String .ByteString and .ByteString.Lazy are Parser, GenParser and parseFromFile
08:22:38 <dino-> That API is full of surprises.
08:22:42 <koeien37> dino-: cool. what technology are you using? Happstack?
08:22:44 <xerox> maybe that should be written at the top of Text.Parser documentation.
08:23:08 <xerox> "this module is meant to be imported in conjunction with one of ..."
08:23:20 <benmachine> well, you don't *have* to
08:23:32 <dino-> No, did it all old school to try to get an idea how the web works, just Network.CGI
08:23:43 <benmachine> I wrote a parser thing that only used Text.Parsec
08:23:49 <benmachine> most of the stuff you need is there already
08:24:00 <koeien37> dino-: CGI is pretty useable too, for small applications
08:24:08 <FliPPeh> nu pagadi?
08:24:11 <FliPPeh> Wah!
08:24:17 <xerox> benmachine for writing the parser those aren't needed, right. It's most like you want to choose the instance in the Main or something.
08:24:19 <koeien37> for larger applications i prefer more convenience functions, like for the dispatcher
08:24:52 <dino-> Yes, had to write dispatching for this, kind of a waste.
08:25:05 <dino-> I wanted to look into that hvac more too, the dispatching there.
08:25:08 <benmachine> xerox: but you don't actually *need* the .String module to choose the String instance
08:25:09 <filcab> is it possible to compile haskell to x86_64 code using ghc?
08:25:21 <xerox> benmachine right! that is because the instances are re-exported
08:25:27 <benmachine> okay
08:25:29 <patch-tag> Is there a library function which does something like             foo f g = either (Left . f) (Right . g)
08:25:32 <xerox> I just re-read what I wrote :)
08:25:34 <patch-tag> maybe something to do with arrows?
08:25:36 <koeien37> :t either
08:25:37 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
08:25:43 <edwardk_> filcab: yes, though there are some problems on macs under snow leopard
08:25:59 <benmachine> :t (|||) -- the same thing only more complicated
08:26:01 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
08:26:02 <xerox> benmachine I was wondering why the import hiding the only three defs, but there are also the instances, which get exported.
08:26:06 <benmachine> wait no
08:26:10 <benmachine> :t (+++)
08:26:12 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (ArrowChoice a) => a b c -> a b' c' -> a (Either b b') (Either c c')
08:26:15 <filcab> how can I do that? I still have leopard and, if I try to compile in 64 bit mode (passing the -m64 flag), I get the same errors...
08:26:15 <koeien37> :t (+++)
08:26:16 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (ArrowChoice a) => a b c -> a b' c' -> a (Either b b') (Either c c')
08:26:38 <patch-tag> I want to map just the left part of a failure
08:26:42 <edwardk_> patch-tag: or you can look at bimap f g in category-extra
08:26:46 <benmachine> :t left
08:26:47 <lambdabot> forall (a :: * -> * -> *) b c d. (ArrowChoice a) => a b c -> a (Either b d) (Either c d)
08:26:59 <patch-tag> where does left come from?
08:27:07 <edwardk_> patch-tag: left in Control.Arrow or 'first' from category-extras
08:27:07 <benmachine> :t \f -> left f `const` f undefined
08:27:09 <lambdabot> forall b c d. (b -> c) -> Either b d -> Either c d
08:27:17 <benmachine> woo, legible typesig
08:29:09 <edwardk_> filcab: like i said, snow leopard x86-64 doesn't work
08:29:23 <filcab> edwardk_: I don't have snow leopard
08:29:32 <filcab> only leopard, the previous evrsion
08:29:34 <filcab> *version
08:29:35 <edwardk_> filcab: ah, sorry misparsed
08:29:50 <edwardk_> filcab: there i'm not sure. i just know that all the mac complaints started with snow leopard ;)
08:29:58 <benmachine> :t \f g -> left f g
08:29:59 <lambdabot> forall b c d. (b -> c) -> Either b d -> Either c d
08:30:09 <filcab> ah, yes. because in snow leopard gcc defaults to x86_64
08:30:25 <filcab> but then... If I'm in a linux box... how can I compile 32 or 64 bit?
08:30:35 <edwardk_> bbiab
08:30:45 <filcab> that is: how can I choose which arch I want
08:30:54 <filcab> k
08:32:50 <patch-tag> thanks edwardk and benmachine, exactly what I wanted.
08:33:26 <FliPPeh> Depends on your compiler, no?
08:33:50 <FliPPeh> On Linux 32 my compiler automatically uses 32 Bit, and 64 Bit for my 64 Bit system
08:34:03 <filcab> yes
08:34:11 <filcab> but, for example, on my SuSE 64bit box:
08:34:28 <filcab> ghc --make a.hs
08:34:30 <filcab> yields:
08:34:37 <filcab> a: ELF 64-bit LSB executable, x86-64
08:34:45 <FliPPeh> Yup
08:34:48 <filcab> how can I compile the a.hs file in 32 bit?
08:34:59 <FliPPeh> That's cross-compiling
08:35:02 <filcab> ghc -optl-m32 -optc-m32 -opta-m32 --make a.hs # Won't work
08:35:03 <leimy> filcab: there's compiler flags for that in the man page for ghc
08:35:11 <leimy> oh then it doesn't work :-)
08:35:11 <filcab> not exactly
08:35:23 <filcab> leimy: I searched for "arch" and didn't find it :s
08:35:27 <leimy> Does it have both 64bit and 32bit runtimes?
08:35:31 <patch-tag> mapErrorT $ left show      now lets me fit showable errors into an ErrorT String IO a pipeline
08:35:46 <patch-tag> :t mapErrorT
08:35:47 <lambdabot> forall (m :: * -> *) e a (n :: * -> *) e' b. (m (Either e a) -> n (Either e' b)) -> ErrorT e m a -> ErrorT e' n b
08:35:51 <patch-tag> :t mapErrorT $ left show
08:35:52 <lambdabot> forall e' b b1. (Show b1) => ErrorT e' (Either b1) b -> ErrorT e' (Either String) b
08:36:02 <leimy> filcab: I'm stuck in a 32bit runtime on Mac OS X for the moment, so I don't really have any great advice there.
08:36:27 <filcab> heh... me too (on my laptop)
08:36:44 <patch-tag> sorry, should be...
08:36:48 <patch-tag> :t :t mapErrorT $ liftM $ left show
08:36:49 <lambdabot> parse error on input `:'
08:36:52 <patch-tag> :t mapErrorT $ liftM $ left show
08:36:54 <lambdabot> forall (m :: * -> *) b d. (Monad m, Show b) => ErrorT b m d -> ErrorT String m d
08:39:29 <filcab> http://www.opensubscriber.com/message/glasgow-haskell-users@haskell.org/8914994.html
08:39:48 <filcab> ok... I can have either a 32 or a 64 bit version of ghc
08:39:58 <filcab> which is... not that nice =)
08:40:20 <name> benmachine: where's comparing in?
08:40:50 <name> benmachine: i only have compare :(
08:41:42 <FliPPeh> Who cares about the execs? Make it open source and everyone can have it for any arch! :D
08:43:23 <arr2> C64's included!
08:43:51 <benmachine> name: Data.Ord I think
08:43:58 <benmachine> @index comparing
08:43:59 <lambdabot> bzzt
08:44:03 <benmachine> bzzt to you too!
08:44:07 <benmachine> @hoogle comparing
08:44:08 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
08:44:10 <benmachine> there we go
08:45:32 <name> oh. snd only works for 2tuples
08:45:51 <name> as you can see i'm still learning
08:45:57 <benmachine> what are you using bigger tuples for?
08:45:59 <benmachine> I am curious
08:46:15 <name> trying to write a tic tac toe ai
08:46:27 <koeien37> yeah, 2-tuples are somewhat special in haskell because of more support of standard functions
08:46:39 <koeien37> fst, snd, (&&&), (***), and so on
08:46:44 <MbM313> SALaaaaaaaam  /  Hi 2 all
08:46:58 <benmachine> personally I reckon tuples should be binned
08:46:59 <benmachine> all of them
08:47:08 <koeien37> why?
08:47:21 <benmachine> because there's no real reason why we need special syntax for them
08:47:21 <koeien37> it's just sugar for data Tuple a b = Tuple a b
08:47:38 <benmachine> and because there are a million redundant instances for stuff
08:47:52 <MbM313> ISLAM ! UR Life right n Best future  www.turntoislam.com   www.sultan.org  www.raastenraah.com
08:47:52 <koeien37> they are often convenient
08:47:54 <benmachine> that just clutter up :info and documentation
08:47:57 <koeien37> @where ops
08:47:58 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver monochrom
08:48:03 <FliPPeh> Sorry for abusing you as a testbed, but how do these chars render for you: "äöüß"? Umlauts, or some kind of crippled chars?
08:48:10 <name> umlauts
08:48:13 <FliPPeh> :)
08:48:17 <koeien37> umlauts and double-s
08:48:18 <name> utf8 here
08:48:29 <name> koeien37: actually it's not doublem "ss" is double ;)
08:48:31 --- mode: ChanServ set +o Igloo
08:48:47 --- mode: Igloo set +b *!*@@119.63.138.34
08:48:50 <FliPPeh> Sharp-S
08:48:54 --- kick: MbM313 was kicked by Igloo (Igloo)
08:48:58 <koeien37> Ringel-S, is that correct?
08:49:09 <name> it's Sharp-S or sz.
08:49:11 <FliPPeh> Thanks, for a moment I thought irssi had a problem with those.
08:49:16 <benmachine> koeien37: maybe we'd keep pairs, because they're used quite frequently, but I reckon triples and higher are rare enough that they should just use data declarations
08:49:30 <koeien37> benmachine: yeah, i'm not advocating fst3 or so
08:49:42 <Canar> Thank you Igloo
08:50:00 <koeien37> but I don't have a problem with (,,)
08:50:07 <benmachine> koeien37: so I reckon the benefits of tuples'd be just as easily gained from a standard datatype a bit like :*: from Data.Generics
08:50:26 <benmachine> I don't really have a problem with it, I just think it's a strange way of doing things
08:50:44 <MbM313> SALaaaaaaaaam / Hi to all
08:50:51 <koeien37> @where ops
08:50:52 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver monochrom
08:51:11 <benmachine> Igloo: there appear to be two @s in your ban
08:51:13 <abbe> lol
08:51:40 <MbM313> ISLAM ! UR Life right n Best future  www.turntoislam.com   www.sultan.org  www.raastenraah.com
08:52:12 <FliPPeh> What
08:52:15 <Raevel> :-D
08:52:21 --- mode: Igloo set +b *!*@119.63.138.34
08:52:24 <FliPPeh> I feel convinced.
08:52:24 --- kick: MbM313 was kicked by Igloo (Igloo)
08:52:30 --- mode: Igloo set -b *!*@@119.63.138.34
08:52:32 <FliPPeh> Hey, he was a true jesus
08:52:33 <Igloo> ta benmachine
08:52:45 <benmachine> :)
08:53:17 <benmachine> and the same to you
09:01:52 <FliPPeh> Ugh, silence
09:02:05 <mreh> Allah akbah!
09:02:07 <koeien37> you prefer islamic advocacy?
09:02:14 <lbeew2000> akbar
09:02:16 <lbeew2000> not akbah
09:02:22 <FliPPeh> ;x
09:02:35 <mreh> oop,s sorry
09:02:44 <FliPPeh> > let pi = 3 in map toUpper $ show pi
09:02:45 <lambdabot>   "3"
09:02:53 <mreh> i'm not a muslim, no
09:03:07 <FliPPeh> I consider myself an atheist
09:03:18 <FliPPeh> I only believe in the flying spaghetti monster...
09:03:20 <mreh> but we could get a bit more ready with the big head chopper
09:03:26 <gwern> allah akbar! <-- it's a trap
09:03:41 <mreh> FliPPeh, you believe in disbelief
09:03:49 <mreh> lol
09:03:52 <Ke> FliPPeh: blashphemer, it's only floating!
09:04:16 <mreh> i don't the flying spaghetti monster... what is it a parody of exactly?
09:04:26 <FliPPeh> :|
09:04:33 <Canar> deity in general, mreh
09:04:34 <CalJohn> mreh: religion
09:04:36 <gwern> mreh: the invisible pink unicorn, natch
09:04:37 <FliPPeh> Blasphemy.. Blaspheyou...
09:04:45 <FliPPeh> Victimless crimes
09:05:14 <mreh> yes, i know, but it doesn't actually draw attention to anything, it just sort of is
09:05:50 <mreh> gwern: you just look for pink unicorn droppings, easy!
09:06:05 <gwern> I like the roman saying
09:06:12 <gwern> 'offences to the gods are the concern of the gods'
09:06:21 <koeien37> source?
09:06:49 <Veinor> hm. if I import Data.Time, do I get any access to Data.Time.Calendar?
09:07:03 <koeien37> depends if Data.Time re-exports it
09:07:05 <mreh> Veinor: unlinkely
09:07:06 <byorgey> only if Data.Time re-exports it
09:07:17 <mreh> yes, those ^
09:07:21 <Canar> heh
09:07:30 <Canar> the romans considered early christians atheists
09:07:34 <koeien37> you can re-export modules by module X ( module Y) where ... import Y ...
09:07:50 <Veinor> k.
09:07:58 <gwern> koeien37: a lot of old latin sayings like 'Deorum iniuriae Diis curae' have no real source
09:08:16 <koeien37> gwern: it could be from the middle ages, too, then
09:08:26 <gwern> ...I really doubt that
09:08:35 <koeien37> deorum is plural
09:08:42 <mreh> genative?
09:09:05 <mreh> agreeing with iniuriae, first declension
09:09:06 <koeien37> my latin is a bit rusty, but appears so
09:09:21 <koeien37> hmm
09:09:27 <idnar> deorum shouldn't be genitive
09:09:32 <koeien37> no, maybe dative
09:09:43 <idnar> diis and curae are genitive, I think
09:09:48 <idnar> my latin is so rusty
09:09:57 <paolino> O_O
09:10:02 <mreh> Deorum is genative plural
09:10:17 <koeien37> deus is pluralis gen.
09:10:17 <idnar> what is diis then?
09:10:32 <koeien37> dativus
09:10:34 <mreh> dative plural
09:10:48 <idnar> oh okay
09:10:49 <harrisonpartch> I prefer genitive dual to singular. Never tried plural > 2.
09:11:22 <koeien37> deus seems to be irregular though
09:11:25 <paolino> or ablative
09:11:34 <koeien37> i would expect deis for dativus pluralis
09:11:34 <mreh> not dative, yes ablative
09:11:45 <harrisonpartch> dative -- imperative -- genitive -- accusative  is the sequence of a crime
09:11:46 <mreh> you're right
09:12:09 <Veinor> harrisonpartch: haha
09:12:14 <gwern> -_-
09:12:17 <harrisonpartch> a sad CASE
09:12:17 <mreh> of, by, with
09:12:24 <idnar> haha
09:12:24 <Veinor> I'm going to hit you.
09:12:28 <Veinor> :I
09:12:45 <mreh> I decline that that was a good joke
09:12:46 <Veinor> oh, hackage appears to no longer be down!
09:12:47 <mreh> HAAAAAAAAA
09:12:51 <harrisonpartch> I predict that this will be the year that the pun will finally hit big as a popular form.
09:13:11 <Saizan> Veinor: wow!
09:13:44 <Veinor> someone amend the topic? keep the torrent link in there, though, it's a good idea
09:13:55 <mreh> koeien37: there aren't irregular nouns
09:14:22 <harrisonpartch> So the fork says to the spoon: "Who was that ladle I saw you with last night?" and the spoon replies "Ladle! That was no ladle! That was my KNIFE!"
09:14:22 <koeien37> http://en.wikipedia.org/wiki/Latin_declension#Second_declension_.28o.29 -- wikipedia seems to disagree
09:14:57 <mreh> koeien37, well okay, not many though :)
09:15:00 <mreh> i never learned any
09:15:18 <koeien37> now that I read this page, vis (power) comes to mind again :)
09:15:21 <koeien37> it's been a few years
09:15:38 * jmcarthur groans at harrisonpartch
09:16:42 <mreh> i am kind of jealous of people who can make those awful puns
09:16:48 <Veinor> 11:56:20 < Gobiner> Success is shaking your butt in their face that you are better than them
09:16:55 <Veinor> damn you, clipboard
09:17:00 <mreh> haha
09:17:11 <harrisonpartch> I believe that that one came from Walt Kelly.
09:17:13 <jmcarthur> o_O
09:17:37 <harrisonpartch> But I do write a large proportion of the material I use.
09:17:42 <Veinor> Loading package old-locale-1.0.0.0 ... linking ... <interactive>: /afs/athena.mit.edu/user/p/h/phurst/.cabal/lib/time-1.1.3/ghc-6.8.2/HStime-1.1.3.o: unknown symbol `__stginit_oldzmlocalezm1zi0zi0zi2_SystemziLocale_'
09:17:46 <Veinor> what does this mean? :/
09:17:58 <harrisonpartch> Did you hear about the Navajo guard dog?
09:18:27 <mreh> where is Navajo, isn't that a film?
09:18:36 <lbeew2000> sounds like a desert
09:18:39 <gwern> harrisonpartch: the one who barks 'ooaggala'?
09:18:41 <lbeew2000> or tribe
09:18:47 <harrisonpartch> He was adobe!
09:18:53 <paolino> mreh: of the gods offences , the cures are their
09:19:04 <gwern> adobe?
09:19:19 <mreh> a-dobi
09:19:31 <mreh> a-dogie?
09:19:33 <mreh> what?
09:19:50 <Veinor> ok, that means I need to restart ghci :I
09:19:55 <gwern> mreh: I thought 'a doggie' too, but that's stupid because we're already told it's a dog
09:20:00 <harrisonpartch> IE, a "dobie" or Doberman Pinscher
09:20:14 <mreh> ruined joke
09:20:20 <gwern> harrisonpartch: I have never heard that term for a doberman
09:20:25 <harrisonpartch> Really, gentlemen. I expect more from a channel like this.
09:20:39 * mreh makes farting noises
09:20:52 <harrisonpartch> You make my point.
09:21:03 <paolino> mreh, "the cures are their" is correct ?
09:21:09 <harrisonpartch> Where is the high moral tone one expects from coders?
09:21:27 <mreh> the cures are theirs, that makes better english
09:21:33 <FliPPeh> I've never heard such a thing.
09:21:42 <FliPPeh> I only hear 'em cursing
09:22:03 <mreh> that's C programmers
09:22:25 <FliPPeh> :)
09:22:32 <FliPPeh> Oh yeah
09:22:32 <FliPPeh> I know those.
09:22:42 <harrisonpartch> C is an abomination. Why, do you ask? Pointer aliasing, for one thing.
09:22:59 <FliPPeh> C can be fun, I'm learning it for the lols.
09:23:22 <Ke> there is a person that knows haskell but not C?
09:23:51 <harrisonpartch> You are making a number of assumptions there.
09:23:55 <edwardk_> ke: shapr i think fits that bill
09:24:13 <harrisonpartch> I am not a person.
09:24:22 <koeien37> C is a lot simpler to learn
09:24:29 <FliPPeh> Depends.
09:24:31 <koeien37> but a lot harder to use
09:24:34 <FliPPeh> I found Haskell easier to learn
09:24:39 <FliPPeh> harder*
09:24:49 <harrisonpartch> As a systems language, it is an abomination.
09:24:53 <FliPPeh> But usage is a different thing :x
09:25:10 <FliPPeh> Haskell becomes easier, C stays a b*tch.
09:25:35 <harrisonpartch> Why should a systems level language not have type safety and GC?
09:25:37 <edwardk_> harrisonpartch: c is everywhere. there are some demonstrable advantage of being able to build on 4 decades of someone else's labor
09:25:55 <harrisonpartch> As you know, I am aware of that.
09:26:07 <FliPPeh> harrisonpartch: Like D?
09:26:12 <FliPPeh> Systems Programming + GC
09:26:40 <edwardk_> harrisonpartch: gc is problematic for systems work because in a kernel you can't willy nilly allocate memory. you have large sections where even allocating a page isn't feasible.
09:26:56 <FliPPeh> zero overhead can be good
09:27:17 <harrisonpartch> http://bluebottle.ethz.ch/
09:27:50 <_andy_> so it appears hackage is back up?
09:27:54 <harrisonpartch> edwardk: obviously the collector itself isn't collected!
09:28:03 <harrisonpartch> is that even possible?
09:28:49 <harrisonpartch> howeve, a language can ALLOW GC and still have a nonGC kernel
09:28:58 <Saizan> _andy_: yeah, it's not an hallucination that you're seeing it in your browser :)
09:29:18 <edwardk_> harrisonpartch: the problem is there are a large number of places in an operating system where unbounded delays are not feasible. 'real time' garbage collection is often claimed but very VERY rarely realized. mixing gc and non-gc'd elements rarely leads to semantics I want to contemplate. you get an efficient implementation of neither.
09:30:14 <harrisonpartch> I am not an expert. How about the Sierpinski thing?
09:30:42 <edwardk_> "Sierpinski thing"?
09:30:58 <_andy_> awesome
09:31:06 <harrisonpartch> I opened a private dialogue with you...
09:31:29 <harrisonpartch> About your kata gpgpu idea....
09:31:30 <edwardk_> hrmm i'm not seeing it. let me check if i'm registered
09:31:31 <harrisonpartch> 	<harrisonpartch>	Were you thinking of graphics or something else?
09:31:32 <harrisonpartch> 	<harrisonpartch>	You could make a Sierpinski cube flythrough, fullscreen, realtime. Hasn't been done that I know of.
09:31:34 <harrisonpartch> 	<harrisonpartch>	Easy algorithm.
09:31:35 <harrisonpartch> 	<harrisonpartch>	The method used in my tracer cannot be ported to GPU in the general case.
09:31:37 <harrisonpartch> 	<harrisonpartch>	But the Sierpinski cube is a special case.
09:31:39 <harrisonpartch> 	<harrisonpartch>	http://www.youtube.com/watch?v=CjXqbO2NvnM
09:31:41 <harrisonpartch> 	<harrisonpartch>	http://www.youtube.com/watch?v=FJsVmyzDOQU
09:31:43 <harrisonpartch> 	<harrisonpartch>	The geometry of the fractal cube does not exist in memory but is implicitly constructed per ray, so there are no pointers to follow.
09:31:44 <harrisonpartch> 	<harrisonpartch>	Transparent color for the "empty" cubes, a nice diffuse shader on the "solid" cubes, maybe with a bit of mirror...
09:31:46 <harrisonpartch> 	<harrisonpartch>	I think it could work on a gpu
09:31:47 <koeien37> wtf
09:31:47 <harrisonpartch> oh it was without the underscore i think
09:32:00 <edwardk_> ah, wrong edwardk. i'm edwardk_ right now. fixing that
09:32:36 <harrisonpartch> anybody here interested in SL, Croquet, etc?
09:33:04 <edwardk_> actually the sierpinski cube has been raytraced on the gpu in voxel form no less quite a bit
09:33:16 <sm> harrisonpartch: yes
09:33:43 <edwardk_> harrisonpartch: let me go pull up a reference
09:33:48 <harrisonpartch> problem with croquet is that like all squeak stuff it usually won't work
09:34:10 <harrisonpartch> real opportunity here for haskell graphics
09:34:16 <mreh> is anyone here programming haskore?
09:34:24 <harrisonpartch> do croquet/SL right
09:34:25 <mreh> preflex: seen mmorrow
09:34:25 <preflex>  mmorrow was last seen on #haskell 7 days, 9 hours and 30 seconds ago, saying: * mmorrow refocuses back on topic
09:34:59 <_andy_> @hayoo ReaderT
09:34:59 <lambdabot> Unknown command, try @list
09:35:04 <_andy_> @list
09:35:04 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
09:35:05 <edwardk_> harrisonpartch: http://artis.imag.fr/Publications/2009/CNLE09/
09:35:27 <edwardk_> harrisonpartch: thats almost entirely on the gpu. read the paper, its a very interesting approach to rendering very large voxel datasets on a gpu.
09:36:19 <_andy_> @hoogle ReaderT
09:36:20 <lambdabot> Control.Monad.Reader newtype ReaderT r m a
09:36:20 <lambdabot> Control.Monad.Reader ReaderT :: (r -> m a) -> ReaderT r m a
09:36:20 <lambdabot> Control.Monad.Reader mapReaderT :: (m a -> n b) -> ReaderT w m a -> ReaderT w n b
09:36:22 <harrisonpartch> then it isn't using the approach I am describing
09:36:33 <Ke> does putMVar block if someone has already inserted the value and it hasn't been read
09:36:35 <harrisonpartch> since no dataset at all is needed
09:37:15 <edwardk_> harrisonpartch: they encode a recursive formulation of the sierpinski cube
09:37:45 <edwardk_> harrisonpartch: what is interesting is that their encoding also generalizes to other voxel structures.
09:37:59 <harrisonpartch> yes, i see that now.
09:38:17 <harrisonpartch> ok, so it has been done on a pu. never mind then.
09:38:37 <harrisonpartch> stilgpu
09:38:40 <harrisonpartch> gpu
09:38:43 <harrisonpartch> argh
09:39:49 <_andy_> @hoogle GHC.IO.Exception
09:39:49 <lambdabot> No results found
09:39:52 <harrisonpartch> i am trying to compile yi from darcs and am stuck
09:40:19 <harrisonpartch> what is the name of haskell-platform at hackage?
09:40:47 <Ke> so I heard that exceptions are unstandardized spawn of a naughty person, how come they are openly used?
09:40:51 <koeien37> it's not available there, on purpose
09:41:16 <koeien37> (afaik) They want to prevent packages depending on it
09:41:26 <edwardk_> harrisonpartch: another voxel link you might enjoy since you've been playing with voxels so much lately: The 'perfect spatial hashing' paper: http://www.citeulike.org/group/8754/article/4121787
09:41:52 <edwardk_> ke: convenience
09:42:12 <harrisonpartch> well I have the Debian haskell-platform installed, yet http://pastebin.com/df4d81c8
09:42:31 <gwern> ARGGHHHH
09:42:35 <harrisonpartch> lately? most of the millenium
09:42:46 <b_jonas> Ke: just like everything in haskell, exceptions are based on academic papers
09:42:48 <gwern> turns out to get results like http://gitit.net/paste.lhs , you have to name your file 'paste.lhs.page'
09:43:06 <gwern> and like a chump, I was experimenting with endless setup variants all using paste.lhs
09:43:09 <gwern> WTF
09:43:21 <Ke> b_jonas: but there is an actual standard which includes quite a bit of stuff
09:43:32 * gwern nerd-rages
09:43:46 <b_jonas> exceptions are just plain useful
09:44:11 <HaskellLove> "Tne research goal of the Oz project is to explore what programming techniques are possible in a computation model that integrates several programming paradigms. The only way to achieve this goal is with dynamic typing. "Why is that so? Why static typing cant achieve that?
09:44:53 <gwern> HaskellLove: the type research would probably be another several projects :) look at o'haskell
09:45:02 <Stalafin> Hello! For python, there exists a very beautiful plotting library called matplotlib; is there something similar for Haskell?
09:45:04 <harrisonpartch> john Reppy seemed to not like Oz when I had a conversation with him years ago. Nor Ocaml.
09:45:12 <koeien37> Stalafin: there is Chart. Never used it myself.
09:45:21 <jaspervd1> Stalafin: there are also gnuplot bindings
09:45:22 <koeien37> It has been recommended to me earlier in #haskell
09:45:40 <Stalafin> jaspervd1: can you please point me to them?
09:45:47 <koeien37> they're on hackage
09:45:52 <xerox> http://dockerz.net/twd/HaskellCharts
09:45:58 <edwardk_> HaskellLove: the 'only way to achieve this goal is with dynamic typing' is usually a cop out when you can't figure out the types. ;) i'm not proud, i've taken that cop out myself.
09:46:04 <HaskellLove> harrisonpartch who is he? why does not he like it?
09:47:06 <harrisonpartch> He maintained ML for years and is a professor at Chicago.
09:47:08 <HaskellLove> edwardk_ maybe they are going with dynamic typing for openness, i mean, with static system you close yourself in start
09:47:17 <harrisonpartch> I DK why he doesn't like it.
09:47:26 <Canar> duck typing is nice
09:47:35 <koeien37> zipFile.explode(); nuclearBomb.explode()
09:47:38 <Canar> not very performant, but nice
09:48:04 <harrisonpartch> edwardk_: that spatial hashing would replace carmack's SVO?
09:48:06 <edwardk_> HaskellLove: i use dynamic typing in my own toy language with the excuse that its a lot easier to write code without the baroque type annotations that some of the language features i use would require.
09:48:48 <harrisonpartch> or is it the same as SVO?
09:48:51 <Stalafin> koeien37, jaspervd1: thank you!
09:48:56 <harrisonpartch> i think not.
09:49:01 <edwardk_> harrisonpartch: to me spatial hashing is a way of encoding sparse voxel datasets. you could use it to encode the SVO.
09:49:06 <edwardk_> harrisonpartch: it is complementary, not a replacement
09:49:09 <Veinor> koeien37: I've not run into method name collision too often, actually
09:49:40 <Veinor> also, the first time I got this program to run, it worked flawlessly \o/
09:49:52 <koeien37> I don't see the need for dynamic typing when you have a sufficiently strong static type system
09:50:08 <edwardk_> harrisonpartch: the irony is i was working on a voxel rendering engine back in the mid 90s, but I put it down because the hardware wasn't fast enough at the time. i tabled it 'for a decade' and came back and people had started talking about it again
09:50:12 <koeien37> there are some things that are inconvenient in Haskell's strong and static type system, sure
09:51:07 <harrisonpartch> edwardk: did you ever get that movie i sent you?
09:51:11 <koeien37> if you have to resort to metaprogramming, static typing will be frustrating, I guess
09:51:33 <edwardk_> harrisonpartch: nowadays, if i was tackling a realtime voxel scene i'd go with a mixture of techniques, the gigavoxels approach is very good encoding of a voxel dataset, efficient to traverse, but parallax occlusion mapping can be used for fine detail and fit in the same shader
09:51:33 <HaskellLove> koeien37 Oz was one language i do not know why they went with dynamic typing. So what if you have more paradigms, you can make types common to all or some...
09:51:37 <polux_> hackage is back in town
09:51:48 <harrisonpartch> molly hackage
09:51:55 <HaskellLove> koeien37 metaprogramming in the Lisp sense or what?
09:52:01 <koeien37> for example
09:52:16 <edwardk_> harrisonpartch: and perfect spatial hashing can be used to compress data that only applies to a small subset of your voxels
09:52:30 <harrisonpartch> darn it. that was thin lizzie. would have been a good joke.
09:52:49 <edwardk_> harrisonpartch: nah, it never came through
09:53:12 <jmcarthur> i like the idea of voxels, but they never seem to look so good to me
09:53:17 <polux_> harrisonpartch: :)
09:53:22 <jmcarthur> not when applied liberally, i mean
09:53:34 <jmcarthur> for certain classes of models it can look good
09:53:34 <edwardk_> jmcarthur: its usually a case of them being used inappropriately.
09:53:48 <jaspervd1> hmm, template-haskell fails building from hackage here, I get: Language/Haskell/TH/Quote.hs:31:12: Not in scope: data constructor `CharConstr'
09:54:02 <koeien37> jaspervd1: TH is shipped by GHC
09:54:26 <koeien37> why are you compiling it?
09:54:34 <jaspervd1> okay, I need to update my GHC then
09:54:53 <koeien37> depends, which GHC version do you have now? and what package are you trying to build?
09:55:08 <_andy_> speaking of not compiling, event-list-0.0.10 does not compile, though it appears to be a .cabal file issue
09:55:35 <koeien37> I think template-haskell's base dependency is wrong :(
09:55:37 <harrisonpartch> http://www.youtube.com/user/xenopusRTRT
09:55:55 <Veinor> what're the stylistic guidelines for where vs let?
09:56:17 <koeien37> http://www.haskell.org/haskellwiki/Let_vs._Where
09:56:25 <jaspervd1> koeien37: I'm now on 6.10.4, I'm trying to install data-accessor which needs template-haskell >= 2.4, but I'm at 2.3.1
09:56:46 <jaspervd1> s/data-accessor/data-accessor-template/
09:56:54 <koeien37> cabal install data-accessor --constraint='template-haskell < 2.4'
09:57:01 <koeien37> cabal install data-accessor-template --constraint='template-haskell < 2.4'
09:57:12 <jaspervd1> thanks
09:57:21 <koeien37> d-a-template actually required TH>= 2.4 *or* TH >= 2.2 && < 2.4
09:57:45 <koeien37> cabal thinks TH-2.4 should work since the base-dependency is satisfied for it
09:58:03 <harrisonpartch> the advantage of tracing over rasterization is not "photorealism" but "ecological realism": a tracer does not need a low-occlusion toy world.
09:58:29 <jaspervd1> koeien37: yep, it works now
09:59:16 <harrisonpartch> occlusion is GOOD for a tracer
09:59:49 <edwardk_> veinor: 'use where' except when forced to use let by a lambda is a good rule of thumb ;)
10:00:04 <koeien37> where is often clearer, I agree
10:00:16 <koeien37> but ... where ... is not an expression
10:00:36 <edwardk_> koeien37: hence the exception to allow for let as needed ;)
10:00:57 <koeien37> edwardk_: yeah. but let ... in ... in \-expressions makes them long. Often should be replaced by named bindings imo
10:01:02 <Ke>  hackage is slow
10:02:54 <b_jonas> I don't like postfix where.
10:03:02 <edwardk_> lambdas and lets usually make me feel dirty, but manual lifting and argument passing up to an extra combinator bugs me worse.
10:03:26 <koeien37> edwardk_: it really depends. Style is subjective anyway
10:03:50 <koeien37> not all cases of let-in with \ are ugly/wrong
10:03:56 <sproingie> i tend to use let to define values and where to define operations
10:04:00 <edwardk_> koeien37: i was trying at one point to avoid actually using anonymous lambdas and lets in kata entirely, but ultimately caved in and gave up on being combinator-centric
10:04:35 <sproingie> so basically i mix them
10:04:43 <edwardk_> koeien37: i wanted to kill let .. in because it is the ONLY layout rule i have that requires the terminal word
10:04:59 <Veinor> compile early, compile often. whoo
10:05:06 <edwardk_> koeien37: so it is an annoying special case in my grammar =/
10:05:52 <Ke> so is there a way to sleep in haskell
10:05:55 <Veinor> if I have a reallyLongFunctionName withReallyLongArguments = foo where bar
10:06:07 <koeien37> Ke: threadDelay. It's even better! :)
10:06:11 <Veinor> where should the 'where bar' line be indented at?
10:06:18 <Ke> koeien37: thanks
10:06:20 <koeien37> that is your own choice
10:06:21 <b_jonas> and dream too?
10:06:29 <edwardk_> koeien37: i've been contemplating treating let like a weird almost-do-like block. foo = let Pat x y = bar; quux x y -- where the last expression in the let block is the result
10:06:31 <koeien37> Ke: note that it takes arguments in *micro*seconds, 10^-6
10:06:32 <aavogt> Veinor: to the first e?
10:06:35 <osfameron> @faq can haskell dream?
10:06:36 <lambdabot> The answer is: Yes! Haskell can do that.
10:06:53 <Ke> koeien37: hopefully its't not busyloot
10:06:56 <Ke> loop
10:07:00 <idnar> do haskell compilers dream of lambda sheep?
10:07:00 <koeien37> no, it isn't
10:07:09 * The-Compiler has
10:07:17 <The-Compiler> *does
10:07:33 <edwardk_> The-Compiler has been sitting around here for a long time waiting to make that joke
10:07:43 <The-Compiler> indeed.
10:07:47 <Veinor> :D
10:07:48 <b_jonas> edwardk_: and went back to a time machine before that
10:07:51 <idnar> haha
10:08:54 <Veinor> I can never get expected and inferred types straight.
10:09:27 <b_jonas> Veinor: add more type sigs so you get cleaner messages
10:09:50 <Veinor> I mean, I can never remember which one is 'the type of the data', which is 'the type of what the function was expecting'
10:10:30 <ane_> think of that as if the elementary IQ test of putting wooden blocks through the holes. the compiler wants a circle, but you're ramming a square through - that won't work
10:10:39 <Veinor> ane_: I mean, I get why it doesn't work
10:10:58 <Veinor> I just always have to think 'okay, inferred type is String... does that mean I'm passing a String, or it's expecting a String?'
10:11:10 <koeien37> inferred is what the compiler inferred about the expression  you passed
10:11:18 <koeien37> :t map (1::Int)
10:11:20 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `Int'
10:11:21 <lambdabot>     In the first argument of `map', namely `(1 :: Int)'
10:11:21 <lambdabot>     In the expression: map (1 :: Int)
10:11:26 <Veinor> yeah.
10:11:47 <harrisonpartch> isn't a lambda a baby sheepa?
10:11:48 <koeien37> it expected a (a->b) because map expects that. The inferred type is Int, because that was what's actually there.
10:12:00 <c_wraith> how bad of an idiom is "curry (f *** g)" ?
10:12:10 <c_wraith> I feel like I'm being entirely too clever by using it
10:12:27 <Veinor> @unpl curry (f *** g)
10:12:27 <koeien37> :t \f g -> curry (f***g)
10:12:27 <lambdabot> curry (f *** g)
10:12:27 <idnar> @type curry (?f *** ?g)
10:12:28 <lambdabot> forall a c b c'. (a -> c) -> (b -> c') -> a -> b -> (c, c')
10:12:29 <lambdabot> forall a c b c'. (?g::b -> c', ?f::a -> c) => a -> b -> (c, c')
10:12:47 <luite> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=15668#a15668 <- is there a combinator for parseData = many (try wordLine <|> blankLine)  that only collects the results from wordLine?
10:12:53 <cads> :t ***
10:12:55 <lambdabot> parse error on input `***'
10:13:06 <koeien37> :t \x -> (f x, g . f $ x)
10:13:08 <lambdabot>     Ambiguous type variable `a' in the constraints:
10:13:08 <lambdabot>       `Show a' arising from a use of `g' at <interactive>:1:12
10:13:08 <lambdabot>       `SimpleReflect.FromExpr a'
10:13:12 <koeien37> :t \f g x -> (f x, g . f $ x)
10:13:13 <lambdabot> forall a b a1. (a1 -> a) -> (a -> b) -> a1 -> (a, b)
10:13:41 <koeien37> :t \f g -> (f &&& (f.g))
10:13:43 <lambdabot> forall b c. (b -> c) -> (b -> b) -> b -> (c, c)
10:13:52 <koeien37> hm.
10:13:56 <idnar> (***) :: (Arrow (~>)) => b ~> c -> b' ~> c -> (b, b') ~> (c, c')
10:14:12 <harrisonpartch> oh, curried lambda! a classic dish!
10:14:17 <cads> what zeeee fuck.
10:14:32 <Ke> koeien37: actually it would be fine to have a way to sleep until a message arrives or timeout is reached
10:14:46 <koeien37> over a Chan?
10:14:59 * cads always feels like the True Haskell is one step beyond him, the way True Poetry eludes him
10:15:13 <idnar> in this case, it's the (->) arrow, so that's (***) :: (b -> c) -> (b' -> c') -> (b, b') -> (c, c')
10:15:35 <Ke> koeien37: just a generic timer that can wake up other threads and receive requests for more wakeup times
10:15:51 <Ke> so anything is fine
10:15:51 <idnar> @pl \x y -> (f x, g y)
10:15:52 <lambdabot> (. g) . (,) . f
10:16:03 <koeien37> Ke: you can do so with exceptions, but I'd prefer using Chans for that
10:16:50 <Ke> koeien37: but thread delay can't do this without polling, can be done with signal handlers though
10:17:23 <idnar> cads: the Arrow functions mostly get used for clever tricks with the (->) arrow, so you don't really have to understand Arrows at all to understand what they do, it's just hard to read the types
10:17:27 <idnar> @type (***)
10:17:29 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
10:17:59 <idnar> writing the type using Arrow (~>) instead of Arrow a makes it a bit easier to read
10:18:05 <cads> idnar: so given f: b -> c, g: a -> b,    (f *** g)  ... construct a first class representation of the type (a ->b) ??
10:18:12 <cads> oh, one sec while I read what you guys said
10:18:15 <cads> I can't be right
10:18:31 <cads> and I meant (a->c(
10:18:34 <edwardk_> arrows make me sad, because they have too many requirements.
10:18:40 <idnar> cads: for the (->) arrow, f *** g is just \(x, y) -> (f x, g y)
10:18:54 <koeien37> and f &&& g is \x -> (f x, g x)
10:19:04 <cads> oh!
10:19:06 <koeien37> I think those are the two most commonly used
10:19:19 <edwardk_> i'd much rather we had good syntax for playing with closed cartesian categories. you can do pretty much any wiring you want for lambdas in there.
10:19:38 <cads> f &&& g is similar to  f; g   from certain concurrency calculi
10:20:13 * koeien37 needs to read up on CCC's anyway
10:21:01 <cads> ie., the process obtained by running both processes f and g in parallel on the same input - in this case we get both answers back in a tuple
10:21:13 <edwardk_> koeien37: http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Category-Cartesian-Closed.html =)
10:21:16 <Ke> koeien37: so any tips on doing the wakeup on chans?
10:21:43 <koeien37> Ke: i would probably fork another thread, and let it send a message
10:22:07 <gwern> I'm glad I wrote these interwiki plugins for gitit. lets me write convenient things like:
10:22:10 <gwern> The second line is exactly the same. We're still working on a `[Tag]`, and our little `filter` is still testing away, but now our 'test' is really just pulling out the second entry in each `TagOpen`'s `[Attribute]` - it's equivalent to a `map` of [snd](!Hoogle). And this gives us a `[String]` of URLs! The first entry in the lists are "href", and the second are the URLs the href points to. But when we test out our two-liner, we realize ...
10:22:16 <gwern> ... to our dismay we are getting junk results like `["/wiki/Japanese_poetry",..]`. A quick [isPrefixOf](!Hoogle) and we fix that, and that finishes our list comprehension.
10:22:21 <koeien37> edwardk_: not in the Haskell setting.
10:22:31 <Ke> koeien37: but if I later get request for earlier wakeup, I'll need to fork another timer thread?
10:22:32 <edwardk_> koeien37: one sec, lemme find you a reference
10:22:44 <koeien37> edwardk_: I will try to read Awodey's text on CT after I've finished this book on quantum groups
10:22:57 <name> is there a `zip` for more than 2 lists?
10:23:01 <koeien37> :t zip3
10:23:02 <lambdabot> forall a b c. [a] -> [b] -> [c] -> [(a, b, c)]
10:23:10 <koeien37> up to 7 iirc
10:23:16 <koeien37> or 5
10:23:20 <name> and anyone for nested lists?
10:23:23 <edwardk_> koeien37: http://math.ucr.edu/home/baez/qg-fall2006/ccc.html has some links you might find useful
10:23:32 <koeien37> name: what do you want to do, exactly?
10:23:40 <name> so the lists to be zipped are contained in a list
10:23:54 <gwern> a well-marked up markdown/literate haskell page is a thing of beauty. :)
10:23:59 <koeien37> name: can you state the type of the function?
10:24:15 <name> foo [[1, 2, 3], [4, 5, 6], [7, 8, 9 ]] => [(1, 2, 3), (4, 5, 6), (7, 8, 9)]
10:24:53 <koeien37> map (\[x,y,z] -> (x,y,z)) -- warning! partial
10:25:43 <name> why is that partial?
10:25:43 <leimy> is there a total function for that?
10:25:44 <koeien37> catMaybes . map (\lst -> case lst of [x,y,z] -> Just (x,y,z); _ -> Nothing) -- better
10:26:04 <koeien37> map (\[x,y,z] -> (x,y,z)) [[1,2]]
10:26:05 <koeien37> > map (\[x,y,z] -> (x,y,z)) [[1,2]]
10:26:07 <lambdabot>   [* Exception: <interactive>:1:146-164: Non-exhaustive patterns in lambda
10:26:34 <koeien37> if you can prove that the input list always contains only lists of length 3, it's ok
10:26:45 <gwern> @hoogle [a] -> [a]
10:26:46 <lambdabot> Prelude cycle :: [a] -> [a]
10:26:46 <lambdabot> Prelude init :: [a] -> [a]
10:26:46 <lambdabot> Prelude reverse :: [a] -> [a]
10:27:02 <name> koeien37: I can. thanks.
10:27:58 <koeien37> edwardk: thanks for the link
10:28:05 <Zariel> how do i do something like, 4 < (sqrt 25)
10:28:14 <koeien37> > 4 < sqrt 25
10:28:16 <lambdabot>   True
10:28:53 <Zariel> No instance for (Floating Int)
10:28:54 <koeien37> But sqrt does not work for integers.
10:28:59 <koeien37> right
10:29:09 <koeien37> 4 < sqrt (fromIntegral x)
10:29:43 <koeien37> but better: x < 0 || x*x < y -- for Integers
10:36:34 <Zariel> Whats the best way to test if a number is square?
10:37:15 <koeien37> first hunch: use an integer square root algorithm, square the result, test for equality
10:37:59 <damd> it's square if it won't attend your party
10:38:05 <damd> hardy har har
10:38:31 <Zariel> > ((sqrt 17) ^ 2) == 17
10:38:32 <lambdabot>   True
10:38:49 <koeien37> @check \x -> x > 0 ==> ((sqrt x)^2) == x
10:38:50 <lambdabot>   No instance for (Test.QuickCheck.Testable
10:38:50 <lambdabot>                     (Test.QuickCh...
10:38:59 <koeien37> @check \x -> (x::Double) > 0 ==> ((sqrt x)^2) == x
10:39:00 <lambdabot>   No instance for (Test.QuickCheck.Testable
10:39:00 <lambdabot>                     (Test.QuickCh...
10:39:11 <koeien37> (==) on Double. Not a good idea
10:39:37 <mercury^> That should still pass.
10:40:00 <koeien37> > let f x = (sqrt x)^2 == x in f 1923192391932110111123123123
10:40:02 <lambdabot>   False
10:41:26 <luite> is there a way to find out where some error message comes from (function or module)? my program quits with this message, which is not very helpful on its own: Enum.toEnum{Word16}: tag (-5087) is outside of bounds (0,65535)
10:42:21 <Zariel> how can you split a float to its int and decimal?
10:43:09 <tromp_> @hoogle Float -> (Int, Float)
10:43:10 <lambdabot> Data.Graph.Inductive.NodeMap mkNode_ :: Ord a => NodeMap a -> a -> LNode a
10:43:10 <lambdabot> System.Random next :: RandomGen g => g -> (Int, g)
10:43:10 <lambdabot> Prelude properFraction :: (RealFrac a, Integral b) => a -> (b, a)
10:43:15 <Veinor> hm, there's no compareBy? shame :/
10:43:32 <luite> comparing?
10:43:39 <Veinor> oh, compare `on` f
10:43:50 <luite> yes that's the new way
10:44:14 <idnar> @type comparing
10:44:16 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
10:44:20 <idnar> @src comparing
10:44:21 <lambdabot> Source not found. :(
10:45:49 <Veinor> you can't mix on and $? :(
10:46:50 <idnar> "mix"?
10:47:02 <kmc> they're just functions
10:47:16 <idnar> > compare `on` length $ 5 6
10:47:18 <lambdabot>   Precedence parsing error
10:47:18 <lambdabot>      cannot mix `Data.Function.on' [infixl 0] and ...
10:47:22 <damd> lol
10:47:25 <idnar> ah
10:47:35 <kmc> > (compare `on` length) 5 6
10:47:36 <lambdabot>   No instance for (GHC.Num.Num [a])
10:47:36 <lambdabot>    arising from the literal `5' at <inter...
10:47:48 <kmc> > (compare `on` length) [1,2,3] [4,5]
10:47:49 <idnar> not that those operands made any sense anyway
10:47:49 <lambdabot>   GT
10:48:29 <_andy_> @hoogle Haskore
10:48:30 <lambdabot> No results found
10:48:43 <Ferdirand> @type on
10:48:44 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
10:49:11 <idnar> @src on
10:49:12 <lambdabot> (*) `on` f = \x y -> f x * f y
10:50:13 <Veinor> I do have to wonder why theu used (*)
10:51:18 <Ferdirand> should have used (+) instead ? :p
10:51:48 <kmc> that's cute
10:51:54 <damd> Veinor: that's not the real source code
10:52:34 <Veinor> yeah, I know
10:52:40 <Veinor> you get my point
10:54:19 <idnar> Veinor: are you suggesting another operator?
10:54:28 <idnar> Veinor: or do you mean operator vs. function
10:54:40 <idnar> the first time I saw that definition, it blew my mind with awesomeness :)
10:56:38 <ziman> @pl \f g x y -> f (g x) (g y)
10:56:39 <lambdabot> join . ((flip . ((.) .)) .) . (.)
11:00:07 <rovar> haha
11:00:21 <Ke> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15669#a15669 ? hatcron.hs:1:13: parse error on input `-'
11:00:27 <Ke> unable to spot any -
11:00:42 <koeien37> import
11:00:52 <koeien37> the - should be .
11:01:15 <Ke> koeien37: thanks
11:01:16 <c_wraith> Ke: You know that you can just omit "_ <-" in a do block?
11:01:17 <rovar> System-Posix-Signals
11:01:20 <Ke> not line 13 though
11:01:25 <koeien37> it's column 13
11:01:28 <rovar> you a lisp programmer?
11:01:30 <koeien37> line 1
11:01:44 <Ke> rovar: no C/FORTRAN77 !
11:02:20 <Raynes> You have two _ catchalls. :o
11:04:46 <sw17ch> any one have an opinion on TypeDirectedNameResolution they want to share?
11:05:49 <monochrom> I don't want TypeDirectedNameResolution. I just don't want.
11:06:35 <sw17ch> monochrom: it seems really sticky to me too...
11:07:15 <sw17ch> i wish TypeMatchedNameResolution existed... maybe... (i made the name up)
11:07:41 <sshc> is Haskell case sensitive?
11:07:45 <koeien37> yes
11:07:46 <monochrom> Yes.
11:07:47 <koala_man> yes
11:08:08 <Twey> Yes!
11:08:12 <idnar> YES.
11:08:14 <koeien37> most definitely
11:08:16 <Raynes> YESSSS!
11:08:24 <sshc> again?
11:08:27 <koeien37> in fact, it's more case sensitive than most
11:08:28 <Astro> yES
11:08:32 <sshc> <_<
11:08:35 <idnar> YES! YES! YEEEEEEEEEEEESSSSSSSSSSSSSSSSSSSSSSSSSSSS!!!!!!!!!!!!!!!!!!!!!!!!!!!!111111111111111111111one
11:08:38 * idnar hides
11:08:39 <koeien37> because type constructor must start with a capital
11:08:46 <sshc> well, I find the need to make every Haskell source file start with an uppercase letter annoying
11:08:47 <koeien37> data constructors too
11:08:49 <Ke> so what's the difference between Catch and CatchOnce constructors in signal
11:09:06 <Raynes> module hithar where just doesn't seem right bro.
11:09:11 <Ke> CatchOnce is only for the next signal?
11:09:21 <monochrom> I want filenames case-sensitive.
11:09:45 <monochrom> And what's wrong with filenames starting with uppercase?
11:09:54 <koeien37> monochrom: convention
11:10:21 <koeien37> but nothing, in principle
11:10:30 <c_wraith> Nothing wrong with file names matching module names
11:10:31 <Twey> Er…
11:10:33 <jaspervd1> there's other programming languages like this (*cough* Java)
11:10:42 <koeien37> jaspervd1: right. I think it's a good idea
11:10:44 <Twey> Loads of languages conventionally do this
11:10:59 <koeien37> but Haskell modules do not correspond to java classes *at all*
11:11:18 <jaspervd1> I know :-)
11:11:18 <monochrom> Why are people so easily annoyed.
11:11:18 <Gracenotes> file names on windows aren't case insensitive per se, just have case insensitive comparisons
11:11:28 <jaspervd1> Also, a lot of C++ people use CaseSensitive.h these days
11:11:29 <koeien37> i think case sensitivity in unix file names is a mistake
11:11:29 <c_wraith> haskell modules are similar to java packages.  not exactly the same, but pretty clos
11:11:38 <Raynes> monochrom: Nitpickers. I say we kill 'em all.
11:11:47 <Gracenotes> and have all the syscalls built around case insensitive comparisons
11:12:00 <c_wraith> of course, java packages use lowercase names.  *shrug*
11:12:01 <Raynes> c_wraith: Haha, you said clos.
11:12:13 <c_wraith> Raynes: my 'e' key is flakey
11:12:14 <sshc> is it possible to load a module in a file whose name doesn't match the actual filename, at least case-wise? I'd like to have source filenames begin with a lowercase letter
11:12:21 <Gracenotes> koeien37: ಠ_ಠ
11:12:22 <edwardk_> haskell modules are  just a minimalist namespacing mechanism
11:12:22 <Ke> yay, my timer works
11:12:28 <jaspervd1> sshc: not recommended
11:12:30 <Twey> 19:11:05 < koeien37> i think case sensitivity in unix file names is a mistake
11:12:32 <Raynes> c_wraith: It seemed like a Common Lisp Object System joke.
11:12:39 <Twey> I think case-insensitivity in anything is a mistake.
11:12:43 <c_wraith> Raynes: not that clever. :)
11:12:52 <Twey> Except possibly in searches, as an option, which is off by default.
11:12:57 <koeien37> Twey: well, mostly I mean that x and X shouldn't coexist
11:13:02 <sshc> jaspervd1: what isn't recommended, and what are you implying is possible?
11:13:11 <monochrom> sshc: You can fork GHC and modify it.
11:13:13 <Gracenotes> google searches are insensitive to many things, case being one of them
11:13:18 <Raynes> c_wraith: Still kind of funny. Especially in a channel for a pure functional programming language.
11:13:24 <sshc> Twey: I agree, but I'd still like to not have letters begin with a captal letter
11:13:34 <Twey> koeien37: They shouldn't, but should a and あ, or ɑ, or ア?
11:13:40 <Raynes> But why?
11:13:41 <Raynes> :<
11:13:42 <jaspervd1> sshc: if you only have one file (containing a main) you don't have to start it with a capital letter iirc
11:13:50 <Twey> The problem is not one that can be easily solved by technological means
11:13:54 <koeien37> Twey: hmm.
11:13:59 <Twey> And there's no One True Solution, otherwise
11:14:03 <Twey> s/otherwise/anyway/
11:14:06 <Twey> (o.@)
11:14:06 <sshc> jaspervd1: I have more than one file that's importaed
11:14:07 <c_wraith> and somewhat offtopic, but I could get a bite in -blah or #libgd but does anyone have experience using libgd to create transparent gifs?
11:14:16 <Raynes> Twey: Where did that otherwise come from?
11:14:17 <Raynes> :o
11:14:21 <sshc> jaspervd1: how do I have the filename lowercase?
11:14:25 <Twey> I blame the snow
11:14:42 <Raynes> You shouldn't. :(
11:14:44 <koeien37> Twey: yeah, I think you're right
11:14:50 <jaspervd1> sshc: I don't understand why you would do that
11:15:15 <jaspervd1> sshc: I'm not even sure you *can* technically do that
11:15:15 <sshc> jaspervd1: for lowercase filenames?
11:15:17 <koeien37> although I don't recall having seen a file name with non-latin characters
11:15:20 <Twey> (veering off slightly, I *hate hate hate* that Google strips diacritics and symbols out of searches)
11:15:20 <Gracenotes> Twey: you're letting your fingers type, not your brain.
11:15:21 <Ke> I bet writeChannel is not atomic is it
11:15:30 <sshc> is it possible or impossible without modifying the GHC source?
11:15:38 <koeien37> sshc: why ?
11:15:39 <Gracenotes> to make a metonymic dichotomy
11:15:47 <Twey> Gracenotes: Yeah.  I do that in general.  I prefer to think about *what* I'm typing.  In this case, I'm also eating.  :þ
11:15:53 <sshc> koeien37: because I'd like an answer
11:16:01 <koeien37> sshc: switch to Windows :)
11:16:34 <koeien37> hmm, I can't use module 牛 where...
11:16:44 <Gracenotes> Twey: yum, fud. well on the other hand, your typing might be twice as slow if you were not used to semi-automatically typing certain patterns of letters into words
11:16:53 <sshc> koeien37: without modifying the GHC source or using a case-insensitive filesystem?
11:17:08 <sshc> koeien37: is it impossible to do?
11:17:13 <Twey> Gracenotes: A bit more than twice, I think… :þ
11:17:42 <koeien37> sshc: I wouldn't say 'impossible', but, very impractical
11:17:52 <jaspervd1> sshc: the thing is, when you use a certain programming language, it's always a good idea to follow the conventions
11:18:19 <Gracenotes> well. try typing a series of words you're not normally used to typing. The patterns you *are* used to typing are like a magnetic field, like some literal neural net in your brain trained to output English as efficiently as possible :)
11:18:21 * koeien37 is thinking of patching C libraries, patching the kernel, using FUSE, and so on
11:18:42 <Twey> Gracenotes: For a long time, I had a tendency to type ‘mysql’ instead of ‘myself’
11:18:51 <koeien37> lol
11:18:55 <Twey> Haha, even then I paused for a bit before the ‘elf’
11:19:02 <Gracenotes> and I had the hardest time trying to type Nietzsche correctly. But now I do it correctly on the computer and in real life.
11:19:05 <Twey> And I always type ‘twey’ instead of ‘two’
11:19:09 <Gracenotes> (mostly)
11:19:20 <koeien37> I guess I'm lucky that "koeien" is a real dutch word =)
11:19:23 <Twey> Yeah.  Language is like that.
11:19:31 <sshc> jaspervd1: I understand that.  But is it impossible or possible (and how) to import a module contained in a lowercase filename on a case-sensitive fs without modifying the GHC source?
11:19:38 <Twey> koeien37: But do you find yourself automatically appending a ‘37’?  :þ
11:19:49 <koeien37> Twey: not really :P those keys are too far anyway
11:19:56 <Twey> Hehe, ar
11:20:03 <koeien> and I could switch to this terminal too
11:20:10 <jaspervd1> sshc: not possible
11:20:23 <Veinor> aw man, if any took its arguments in reverse order I could almost have English in haskell
11:20:23 <jaspervd1> sshc: GHC will not find the modules
11:20:34 <sshc> jaspervd1: ok, thanks
11:20:37 <harrisonpartch> Typoneurological entrenchment.
11:20:43 <Veinor> any events (`conflictsWith` event)
11:20:59 <Gracenotes> Veinor: (`any` list) f?
11:21:10 <Veinor> :O
11:21:32 <Veinor> I told the IT guy in work about this and he was so happy he laughed out loud!
11:21:35 <Veinor> ...
11:21:39 <Veinor> TRAITOROUS CLIPBOARD
11:21:41 <koeien37> about Haskell?
11:21:58 <Veinor> no, about downloadmyram.com
11:22:01 <Veinor> or something like that
11:22:03 <Veinor>       addEvent events event | `any` events (`conflictsWith` event) = events
11:22:04 <Gracenotes> okay, (`any` event) (`conflictsWith` event). Mind-melting and unintuitive, but.. English.
11:22:10 <Veinor> :p
11:22:21 <Gracenotes> er, switch the plurals
11:22:39 <koeien37> ADD 1 TO ThisInteger. PERFORM UNTIL Done ...
11:22:59 <tomoj> is it possible to write a data structure in haskell which internally uses mutable state but doesn't leak a monad to the external interface?
11:23:06 <gwern> tomoj: ST?
11:23:34 <tomoj> gwern: ok, thanks. I am a noob and thought that the ST monad would need to leak out for some reason
11:23:45 <FliPPeh_> :D
11:23:48 <koeien37> it would
11:24:00 <Gracenotes> tomoj: well, it doesn't leak, but you have to do extra work to prevent it from leaking out
11:24:15 <Gracenotes> sometimes a lot of it, restructuring-entire-program-esque work
11:24:21 <koeien37> oh, I think I understand what you're saying now
11:24:29 <Gracenotes> the ST monad, that is
11:24:41 <Gracenotes> mainly comes from the phantom s variable
11:24:50 <tomoj> well, I don't have any program at all yet, so restructuring doesn't bother me
11:25:03 <Gracenotes> because the darn type system insists that it be there... don't you trust me, type system? ;_;
11:25:22 <tomoj> I was thinking about giving a shot at implementing clojure's data structures in haskell using mutable state internally
11:25:31 <tomoj> maybe someone has already implemented these or equivalents
11:25:35 <kmc_> tomoj, another example is ByteString
11:25:52 <kmc_> which uses unsafePerformIO internally
11:25:54 <koeien37> how cool is clojure? :)
11:26:09 <kmc_> cool enough that to do tail calls you need a special instruction that is 3x as slow
11:26:17 <Ke> why is mvar non strict o_O
11:26:26 <koeien37> Ke: why would it be?
11:26:27 <kmc_> and yes it's visible to the programmer
11:26:29 <meanburrito920_> i was a bit curious about running haskell on the JVM. I found a thesis from 2004 by dons on haskell and the JVM, but I cant seem to find any work that has been done in the subject since then
11:26:36 <kmc_> Ke, i believe there's a strict-concurrency package
11:26:41 <koeien37> Ke: in some sense it's surprising to beginners. But it really is not
11:26:43 <kmc_> yay hackage is back
11:26:46 <Gracenotes> ke: forcing reads and writes are strict, aren't they?
11:26:46 <sshc> if I have "foo <- bar" in an IO action, how do I cause it to be evaluated later on?  (Before actually being used, but *not* immediately after that line)
11:26:48 <kmc_> yup,
11:26:54 <kmc_> strict-concurrency
11:26:55 <tomoj> cool enough that I want it's data structures in haskell but not cool enough that I want it instead of haskell :)
11:26:58 <koeien37> sshc: unsafeInterleaveIO. But it's unsafe
11:27:07 <kmc_> sshc, evaluated or executed?
11:27:08 <Gracenotes> but actually sending things through mvars doesn't require that they are evaluated
11:27:19 <sshc> kmc_: what's the difference?
11:27:23 <kmc_> do you want the side effects of "bar" later, or do you want the "bar" expression to be reduced to normal form later
11:27:28 <kmc_> sshc, they are totally unrelated things
11:27:32 <thoughtpolice> kmc_: unfortunately until the jvm gets tco it will have to stay that way, but using 'recur' isn't really a complete deal-breaker or anything
11:27:32 <kmc_> which most other languages confuse together
11:27:34 <kmc_> but which we do not
11:27:34 <koeien37> yes, evaluation /= execution
11:28:01 <kmc_> sshc, "evaluation" is reduction to normal form.  you replace a function application by the body of the function with args substituted in
11:28:03 <koeien37> evaluating an IO action does nothing, executing it performs the IO action. This is not possible except for putting it in 'main' somehow
11:28:13 <thoughtpolice> the compiler at least checks it is always used in tail-call position which is helpful. it's also not really any sort of design wart: once the jvm can do the optimization itself you won't have to use recur again.
11:28:18 <koeien37> sshc: do you mean in the getContents sense? lazy I/O ?
11:28:29 <kmc_> "execution" is performing the side effects described by an IO action
11:28:30 <sshc> kmc_: executed I think; it might, for example, point to an IO action that reads a huge file and returns a structure that was created from reading it
11:28:35 <thoughtpolice> at least, not a design wart on the side of rich. he has done a really good job with cljore
11:28:38 <thoughtpolice> *clojure
11:28:43 <monochrom> Why would anyone want MVar strict? o_O O_o
11:28:47 <koeien37> sshc: readFile and friends are already lazy
11:29:12 <monochrom> (Like, does adding more O_o o_O o_o faces make you more credible?)
11:29:12 <koeien37> which some (most?) consider a mistake.
11:29:22 <sshc> koeien37: how would I cause the action to be exectude before being used, but after its declaration?
11:29:29 <Gracenotes> monochrom: for that extra touch of control-over-evaluation so many crave
11:29:54 <koeien37> sshc: I am not sure I understand you. You cannot execute IO actions except by putting them in main
11:30:03 <sshc> koeien37: isn't there a strict version of readFile that causes it to be evaluated immediately? (unrelated question)
11:30:18 <kmc_> well, you glue them together and put the result into main
11:30:19 <koeien37> sshc: you can force the result (for example by taking its length)
11:30:23 <shapr> What's the status of GHC on ARM?
11:30:26 <kmc_> sshc, when exactly do you want the result to be evaluated?
11:30:31 <kmc_> or executed or whatever it is you want
11:30:32 <monochrom> If MVar were strict, threads would spend way more time in critical sections blocking other threads just because the value inside the MVar would take forever to completely compute.
11:30:33 <mreh> what's the appropriate abstraction for several parallel processes writing out to the same medium?
11:30:39 <Gracenotes> isn't the point of laziness that things are executed when they're being used?
11:30:42 <kmc_> mreh, probably a Chan
11:30:45 <kmc_> or a TChan if you're in STM
11:30:46 <mreh> in a synchronous way
11:31:12 <sshc> koeien37: let's say I have foo pointed to a file by "foo <- hReadFile goobar", but I don't want to read the file immediately after that
11:31:21 <kmc_> have them all write to a Chan, and then one thread that reads the chan and writes out to whatever medium
11:31:22 <mreh> kmc_ is that synchronous?
11:31:23 <Gracenotes> as for the monster that is unsafe-interleave-bound handle-reading... that's a bit different....
11:31:25 <koeien37> sshc: good. that already happens
11:31:25 <sshc> koeien37: it's used at the end of the program
11:31:33 <kmc_> mreh, what do you mean by synchronous?
11:31:37 <kmc_> you don't want to buffer data internally?
11:31:42 <kmc_> within the Chan?
11:31:50 <koeien37> sshc: since readFile, and hReadFile are lazy
11:31:51 <sshc> koeien37: but I want it to be evaluated during the middle of main
11:32:04 <sshc> koeien37: if they are lazy, doesn't Haskell provide a strict version of them?
11:32:10 <koeien37> sshc: then, in the middle of main, put   evalute (length foo)
11:32:22 <mreh> kmc_ i've got process music, so several parallel lines could be happening at once, I want to write them out in order they are performed
11:32:36 <mreh> hence the need for the synchronisation
11:32:36 <kmc_> how is there an order, if several things are happening at once?
11:32:48 <mreh> kmc_ there's a steady pulse
11:33:22 <sshc> koeien37: why is evaluate in Control.Exception module?
11:33:22 <kmc_> so on every tick, each of the threads can generate an event, and you want to process all of these before the next tick?
11:33:29 <tomoj> is there a haskell equivalent to clojure's '(-> x (foo bar) (baz biz))' evaluating to '(baz (foo x bar) biz)' i.e. haskell's 'baz $ (foo x bar) biz' ?
11:33:33 <mreh> kmc_ that's the idea
11:33:35 <kmc_> i don't know clojure
11:33:36 <sshc> koeien37: can it be used outside of exceptions?
11:33:51 <kmc_> mreh, then i wouldn't use separate threads
11:33:53 <koeien37> sshc: (length foo) `seq` return () -- if you don't like it
11:33:56 <kmc_> just a list of actions that you can map over
11:34:05 <koeien37> there is a strict Chan, isn't there?
11:34:16 <gwern> Gracenotes: incidentally, I'm working on a a long literate-haskell essay on writing a Wikipedia archive bot in haskell; interested in beta reading it for me?
11:34:22 <sshc> koeien37: ok.
11:34:23 <kmc_> catMaybes ($ now) [xs :: Time -> Maybe Event]
11:34:41 <kmc_> there is strict-concurrency package
11:34:45 <sshc> koeien37: couldn't I just use "foo `seq` return ()"?
11:34:52 <koeien37> sshc: nope
11:34:57 <sshc> koeien37: why not?
11:35:04 <koeien37> foo is a list, seq'ing it will only reduce it to Weak Head Normal Form (whnf)
11:35:09 <mreh> kmc_ what do you mean by actions?
11:35:14 <kmc_> mreh, where?
11:35:26 <mreh> kmc_> just a list of actions that you can map over
11:35:32 <koeien37> eg. [a1, a2, a3] `seq` ... will only evaluate the first list constructor (:)
11:35:33 <kmc_> > (1 : undefined) `seq` ()
11:35:34 <lambdabot>   ()
11:35:43 <kmc_> mreh, sorry, that was an unclear word
11:35:52 <kmc_> i mean that you said there are several "parallel lines"
11:35:58 <meanburrito920_> i've been hearing a lot about how lack of TCO on the JVM prevents a lot of functional languages from being implemented on it, but I'm a bit confused at why the JVM lacks TCO. it seems as simple as replacing the value of some registers and having a goto to the beginning of the function body
11:36:02 <koeien37> > [undefined,undefined] `seq` ()
11:36:04 <lambdabot>   ()
11:36:04 <kmc_> at each tick, each one could generate an event
11:36:07 <sshc> koeien37: what is head normal form?
11:36:18 <jmcarthur> meanburrito920_: imperative programmers really like their stack traces, i guess
11:36:24 <koeien37> head normal form is the "completely evaluated version of a data structure"
11:36:32 <koeien37> but i'm referring to weak head normal form here
11:36:36 <kmc_> mreh, so i was thinking a list of functions, each which takes time and returns a Maybe Event
11:36:38 <koeien37> that's only the first level
11:37:04 <koeien37> > ((:) undefined [])  `seq` () -- here
11:37:05 <lambdabot>   ()
11:37:16 <mreh> kmc_ okay, so i'm mapping the time to every function
11:37:16 <koeien37> that seq there only looks at the first constructor (:)
11:37:18 <kmc_> seq only forces the outermost constructor
11:37:19 <kmc_> in this case (:)
11:37:53 <sshc> kmc_: so then there is no way to force an entire list to be constructed using seq only?
11:38:06 <sshc> kmc_: and why does length force the entire list to be evaluated?
11:38:08 <meanburrito920_> jmcarthur: but i was under the impression that the JVM allowed gotos in a method body. is there some special stack trace rules that would make that impossible?
11:38:13 <koeien37> force [] = (); force (x:xs) = x `seq` force xs
11:38:19 <koeien37> :t rnf
11:38:20 <lambdabot> forall a. (NFData a) => a -> Done
11:38:23 <kmc_> sshc, length only forces each (:) cell
11:38:27 <koeien37> > rnf [1,2,3]
11:38:28 <lambdabot>   ()
11:38:31 <koeien37> > rnf [1,2,3, undefined]
11:38:32 <lambdabot>   * Exception: Prelude.undefined
11:38:34 <kmc_> not the elements themselves
11:38:40 <kmc_> > length [ undefined, undefined ]
11:38:41 <lambdabot>   2
11:38:49 <koeien37> kmc_: right, but for getContents that isn't important, right?
11:38:54 <kmc_> correct
11:39:11 <sw17ch> does the lack of name overloading bother any one? better yet, does any one have a good way to fix it that doesn't suck? :D
11:39:12 <sshc> koeien37: why isn't it important?
11:39:14 <kmc_> to reduce an entire structure to normal form you need a type-specific recursive traversal
11:39:20 <kmc_> which is what NFData typeclass provides
11:39:31 <kmc_> > rnf [ undefined, undefined ]
11:39:32 <lambdabot>   Ambiguous type variable `a' in the constraint:
11:39:33 <lambdabot>    `Control.Parallel.Strateg...
11:39:33 <sshc> koeien37: because it needs to read the file before finding the length anyway?
11:39:39 <koeien37> sshc: yep
11:39:47 <kmc_> > rnf ([ undefined, undefined ] :: [Int])
11:39:49 <lambdabot>   * Exception: Prelude.undefined
11:39:52 <kmc_> > rwhnf ([ undefined, undefined ] :: [Int])
11:39:53 <lambdabot>   ()
11:40:10 <sshc> kmc_: if I did have a list that did matter, how would I evaluate every element of the list?
11:40:22 <koeien37> sshc: completely evaluate? "rnf"
11:40:28 <gwern> @quote optimi.*lazi
11:40:29 <lambdabot> gwern says: the best way to optimize a program is to make it lazier or stricter.
11:40:29 <sshc> > map seq [1..10] 42
11:40:30 <lambdabot>   Couldn't match expected type `t1 -> t'
11:40:31 <lambdabot>         against inferred type `[t2 -...
11:40:41 <kmc_> sshc, do you want to reduce each element to whnf only? or all the way to nf?
11:40:54 <kmc_> you can do the former on any [a], the latter only on (NFData a) => [a]
11:41:00 <_andy_> are there any good tutorials or examples of using Haskore and alsa (not alsa-midi)?
11:41:22 <koeien37> for Char or Int, there is no difference
11:41:28 <koeien37> but for [[a]] it matters
11:41:50 <_andy_> map `seq` [1..10] 42
11:41:54 <_andy_> > map `seq` [1..10] 42
11:41:56 <lambdabot>   Couldn't match expected type `t -> b' against inferred type `[a]'
11:42:06 <kmc_> right.  a (GHC) Int in whnf is already in nf, because its only field is strict
11:42:08 <Gracenotes> is there an instance a -> b for NFData?
11:42:25 <sshc> kmc_: if doing the latter forces everything inside the list to be evaluated, then yes, the latter
11:42:33 <Gracenotes> since a function is pretty much in the most normal form possible, in the Haskell sense
11:42:51 <kmc_> sshc, again, what do you mean by "to be evaluated"?
11:42:57 <kmc_> absolutely as far as possible?
11:43:05 <sshc> kmc_: yes
11:43:13 <Gracenotes> hm, there is not
11:43:17 <sshc> kmc_: is that nf?
11:43:24 <kmc_> generally in Haskell when we say that something "evaluates or forces" x, we mean it evaluates x to weak head normal form (whnf)
11:43:28 <koeien37> that's normal form
11:43:30 <koeien37> so use rnf.
11:43:31 <kmc_> sshc, yes
11:43:56 <kmc_> (rnf x) returns a value of type ().  when you force this () to whnf, it will also force x to nf
11:44:05 <koeien37> type Done = ()
11:44:16 <sshc> kmc_: how do I use rnf on [1..10]?
11:44:25 <koeien37> > rnf [1..10]
11:44:27 <lambdabot>   ()
11:44:37 <koeien37> > rnf [1..] -- won't terminate
11:44:38 <kmc_> sshc, look at Control.Parallel.Strategies
11:44:39 <Gracenotes> you use rnf on the current list element, then use it on the rest of the list
11:44:41 <lambdabot>   mueval-core: Time limit exceeded
11:44:52 <sshc> what is the result?
11:44:54 <Gracenotes> and only return () when you get to []
11:44:58 <kmc_> > "foobar" `demanding` [1..10]
11:44:59 <lambdabot>   Couldn't match expected type `Control.Parallel.Strategies.Done'
11:44:59 <lambdabot>         aga...
11:45:07 <kmc_> > "foobar" `demanding` rnf [1..10]
11:45:08 <lambdabot>   "foobar"
11:45:09 <kmc_> > "foobar" `demanding` rnf [1..]
11:45:13 <lambdabot>   mueval-core: Time limit exceeded
11:45:14 <kmc_> > "foobar" `demanding` rwhnf [1..]
11:45:16 <lambdabot>   "foobar"
11:45:26 <sshc> > [1..10] `rnf` 42
11:45:28 <lambdabot>   Couldn't match expected type `t1 -> t'
11:45:28 <lambdabot>         against inferred type `Contr...
11:45:50 <Gracenotes> let's not get too gung-ho with the `infix`
11:46:01 <sshc> > rnf [1..10] 42
11:46:03 <lambdabot>   Couldn't match expected type `t1 -> t'
11:46:03 <lambdabot>         against inferred type `Contr...
11:46:16 <sshc> > seq [1..10] 42
11:46:17 <kmc_> `demanding` is meant to be used infix
11:46:17 <lambdabot>   42
11:46:28 <sshc> why is this only working for seq?
11:46:33 <kmc_> because of the types
11:46:34 <koeien37> :t seq
11:46:36 <koeien37> :t rnf
11:46:36 <lambdabot> forall a t. a -> t -> t
11:46:37 <kmc_> rnf and seq do not have the same type
11:46:37 <lambdabot> forall a. (NFData a) => a -> Done
11:46:44 <kmc_> rnf returns a value of type ()
11:46:48 <koeien37> > (rnf [1..10]) `seq` 37
11:46:49 <lambdabot>   37
11:46:51 <kmc_> which Done is a simple synonym for
11:46:56 <Gracenotes> sshc: do you get the idea of weak head normal form (WHNF)?
11:47:03 <Twey> I wonder why
11:47:11 <sshc> and, seq reduces to whnf, and rnf reduces to nf, right?)
11:47:16 <koeien37> correct
11:47:18 <Twey> I mean, you can always seq (rnf val) retval, I suppose
11:47:23 <Gracenotes> that is the case
11:47:24 <kmc_> yes, but that does not mean you use them the same
11:47:27 <kmc_> because the types are different
11:47:35 <Gracenotes> Twey: that is how recursive rnfs are defined
11:47:37 <kmc_> there is rwhnf too, which reduces as far as seq does, but is used the way rnf is
11:47:37 <tomoj> what happened to happs?
11:47:37 <Twey> But it would make more sense to have them be consistent with one another
11:47:44 <kmc_> rwhnf x = x `seq` ()
11:47:45 <idnar> @type demanding
11:47:47 <lambdabot> forall a. a -> Done -> a
11:47:50 <tomoj> the promises on http://happs.org/ sound amazing, why did it die? :(
11:47:50 <Twey> tomoj: Died and went to happstack
11:47:51 <koeien37> tomoj: it's forked. Happstack is the new HAppS
11:48:14 <sshc> > seq (rnf [1..1]]) 42
11:48:15 <lambdabot>   <no location info>: parse error on input `]'
11:48:24 <sshc> > seq (rnf [1..10]) 42
11:48:25 <lambdabot>   42
11:48:27 <kmc_> the idea is to use rwhnf and rnf with demanding, sparking, using, parMap, etc.
11:48:29 <Gracenotes> demanding val x = x `seq` val = flip seq
11:48:36 <kmc_> > parMap rnf (succ) [1..10]
11:48:37 <koeien37> that really evaluated all numbers between 1 & 10, although you didn't see it
11:48:37 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
11:48:38 <Gracenotes> ..afaik
11:48:54 <tomoj> Twey: ki'e
11:49:06 <tomoj> I had looked at that sometime earlier and thought it had also died, but looks active now :D
11:49:17 <koeien37> 0.4.1 has been released recently
11:49:25 <Twey> je'e
11:49:32 <Gracenotes> you can sometimes demonstrate evaluations to yourself. A way to know for sure is inserting an undefined at the end: if everything's fully evaluated, the undefined will turn into an error
11:49:41 <kmc_> you can also use Debug.Trace
11:49:52 <kmc_> or, if you want to get fancy, vacuum
11:50:07 <sshc> out of curiosity, how is the instance for list of NFData defined?
11:50:13 <sshc> or, where would I find it?
11:50:22 <Gracenotes> sshc: I already said what it did :)
11:50:29 <Gracenotes> it is defined in Control.Parallel.Strategies
11:50:32 <koeien37> rnf [] = Done; rnf (x:xs) = rnf x `seq` rnf xs -- my guess.
11:50:57 <Gracenotes> that is what is has to be
11:50:58 <kmc_> yup
11:51:58 <sshc> looking at that file, I'm seeing a bunch of "instance NFData foo\ninstance NFData bar\ninstan..." without any "where"
11:52:18 <kmc_> yes, those use the default
11:52:19 <Gracenotes> that's because some of them use the default instance
11:52:22 <sshc> oh
11:52:23 <koeien37> that is possible. it just doesn't define any functions
11:52:25 <sshc> ok
11:52:32 <sshc> thanks
11:52:37 <Gracenotes> the default just uses seq, meaning WHNF = NF
11:52:39 <kmc_> the default is rnf = rwhnf
11:52:58 <koeien37> probably instance NFData Int
11:53:00 <koeien37> e.g.
11:53:25 <Gracenotes> what was that part about contrapuntal fugues again? >_>
11:53:58 <mental> there's hardly any other kind of fugue
11:54:10 <gwern> mental: what about psychotic?
11:54:52 <mreh> i can never get voiced in #defocus
11:54:53 <Ke> stm could have atomically that is not atomic (for reads and such)
11:55:02 <Gracenotes> well, you could have fugues with rounds
11:55:12 <kmc_> Ke, for performance?
11:55:21 <mental> I remember someone claiming somewhere that some bach piece was a one-part fugue
11:55:23 <Gracenotes> or generally any other sort of polyphony, which may or may not be contrapuntal..
11:55:34 <kmc_> is there significant overhead to atomically . readTVar ?
11:55:39 <Ke> kmc_: for whatever, seems silly to do something atomically, where there is no need
11:55:52 <mental> Gracenotes: rounds are contrapuntal.
11:55:58 <kmc_> it seems silly to introduce two different ways to embed STM semantics into IO
11:56:03 <kmc_> unless there is a specific reason
11:56:14 <mreh> are you talking about music?
11:56:22 <mreh> maybe you know lilypond?
11:56:43 <mental> i know some things about lilypond...
11:56:48 <gwern> mental: isn't that one of the ones covered in GEB?
11:56:49 <Ke> though it's nice feature that stm enforces use of atomicity with static typing
11:56:51 <mental> for example, that it's a huge pain to use :)
11:57:02 <mreh> mental: what would you use?
11:57:08 <mental> mreh: lilypond
11:57:19 <mental> gwern: I only know about music, not GEB :)
11:57:32 <kmc_> Ke, i think the thing you're talking about is unsafeSTMToIO
11:57:41 <mreh> mental: maybe you know how to notate independent rhythms in one system of notes
11:57:53 <Gracenotes> mental: I thought rhythmic features were orthogonal from counterpoint. still, if it's a requirement for fugues, it's a requirement
11:57:57 <mental> mreh: I think it's impossible
11:58:08 <mreh> like a pianists left hand playing bass with the pinky and punching out chords with the rest of his fingers
11:58:21 <Ke> kmc_: nothing unsafe here
11:58:22 <Gracenotes> hm. seems it might involve both
11:58:24 <mental> oh by system you mean a staff?
11:58:51 <mreh> mental, yeah
11:59:07 <name> can is somehow place a condition in the function definition?
11:59:15 <kmc_> Ke, it allows you to bypass the main purpose of STM
11:59:20 <Gracenotes> independent rhythms.. don't you just use up-pointing and down-pointing note stems?
11:59:34 <mreh> mental: i've got this problem to solve for generating lilypond notation for haskore
11:59:37 <kmc_> for composability, it's important that if you hand someone a single STM action, you know it will be performed atomically or not at all
11:59:45 <name> like foo x where x < 5 (would be like this in erlang)
11:59:54 <mreh> how do you *add* simultaneous compositions
11:59:58 <mental> mreh: a lilypond file is a bunch of voices, for each voice you can specify what staff it's on, and the staff can even change
12:00:08 <kmc_> name, yes
12:00:13 <kmc_> foo x | (x < 5) = ...
12:00:16 <kmc_> it's called a guard
12:00:18 <mental> mreh: so you have one voice for the bass and one voice for the chords
12:00:18 <name> kmc_: thank you
12:00:23 <mental> mreh: and put them on the same staff
12:00:24 <Gracenotes> name: what happens if you call foo in Erlang and x >= 5?
12:00:26 <kmc_> you can put multiple guards on the same function equation
12:00:31 <mreh> mental: okay
12:00:34 <kmc_> and you can have multiple equations for the same function, each with or without guards
12:00:36 <Ke> kmc_: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15670#a15670 this is the code I just wanted to do reads unatomically like in regular Chan - I am a bit new to haskell so I don't fully follow you
12:00:48 <name> Gracenotes: i don't know a lot of erlang, just know this
12:01:04 <mreh> mental: can I pick your brains in #haskell-blah
12:01:13 <Gracenotes> name: hm. Well, note, if x >= 5 in Haskell and you have just an (x < 5) guard, it will break, possibly terminating your program
12:01:38 * gwern realizes one can't export the markdown/lhs
12:01:42 <gwern> whups
12:01:45 <Gracenotes> fortunately, you can define the case where the guard is not true. just align the |s with the line:  | otherwise = (other value)
12:01:48 <Ke> :t unsafeSTMToIO
12:01:49 <kmc_> Ke, what's wrong with what you have now?
12:01:49 <lambdabot> Not in scope: `unsafeSTMToIO'
12:01:57 <Twey> The brackets are not necessary
12:02:03 <Twey> foo x | x < 5 = …
12:02:16 <Ke> :t Control.Concurrent.STM.unsafeSTMToIO
12:02:17 <lambdabot> Couldn't find qualified module.
12:02:19 <Gracenotes>       | otherwise = ...
12:02:22 <kmc_> i'm not sure it exists
12:02:25 <kmc_> but that's what it would be called
12:02:42 <Twey> If you don't care about the value of x, you can also use view patterns: foo ((< 5) -> True) = …
12:02:42 <gwern> Gracenotes: guess I can't send you the PDF after all - if I go through pandoc, my gitit plugins don't run and make the interwikis
12:03:17 <kmc_> the regular Chan read is also atomic
12:03:20 <Ke> kmc_: I don't fully see how this compares to unsafe IO, but perhaps, I'll learn some day
12:03:21 <kmc_> but you don't have to say so
12:03:26 <Gracenotes> gwern: Google Docs has a share link, and from there, a download link of the original PDF
12:03:30 <kmc_> Ke, it's not the same as unsafePerformIO obviously
12:03:40 <gwern> Gracenotes: I'm not writing this in google docs
12:03:42 <kmc_> it's unsafe in that it breaks a critical property of the STM monad
12:03:45 <kmc_> one might say the main property
12:03:51 <Gracenotes> gwern: you can upload PDFs to Google Docs
12:03:51 <gwern> this is markdown+lhs in my personal gitit wiki
12:04:00 <Gracenotes> hm.
12:04:06 <kmc_> which is that, if I give you a single STM action, you cannot run it non-atomically
12:04:24 <Gracenotes> render it, Firefox print to PDF, and go from there?
12:04:28 * gwern can't make the PDF at all - to make a pdf, I need the generated Context, and Gitit won't export anything for the page except the origina .lhs
12:04:36 <gwern> Gracenotes: firefox can do that?
12:04:42 <kmc_> since Haskell is a higher-order imperative language, it's important to think about functions which pass actions to each other, or even actions that come in on channels, etc.
12:04:58 <Gracenotes> gwern: ..if your OS can do it
12:05:05 <kmc_> a major advantage of STM over traditional lock-based concurrency is that actions compose more cleanly
12:05:49 <monochrom> STM has "orElse", not easy in other paradigms.
12:06:12 <kmc_> really, the thing in STM that ensures that a and b happen atomically is (>>)
12:06:15 <kmc_> not "atomically"
12:06:37 <kmc_> as soon as you've glued together (a >> b), there is no way to destruct that compound action and execute it non-atomically
12:06:51 <kmc_> which property unsafeSTMToIO would break
12:07:00 <gwern> Gracenotes: it's hideous! there's no color, and the links aren't clickable but just regular text after the link
12:07:07 <gwern> what the heck firefox
12:07:19 <kmc_> Ke, i still don't see the objection to using "atomically" with a single read
12:07:28 <Gracenotes> well. it is printing after all.
12:07:42 <Gracenotes> although you might try the color printer...
12:07:54 <kmc_> especially because -- well, you do want the read to be atomic, because non-atomic reads would be totally undefined behavior.  what happens if you read while another thread is halfway through reading, and the chan is in an inconsistent state
12:08:28 <kmc_> if each of your STM "atomically" calls is on a single primitive TChan operation, then you are not deriving any benefit from STM
12:08:43 <gwern> Gracenotes: nah, there's no options about color
12:08:50 <Gracenotes> seems htmldoc from synaptic repositories does something along the lines
12:10:59 <paolino> monochrom: is retry easily implemented with lock-based  ?
12:12:46 <monochrom> I think "retry" is so magical it needs a big-brother view, doesn't it?
12:13:06 <Cale> I wouldn't expect retry to need to take a lock.
12:13:23 <Cale> It's when a transaction commits that you need to take a lock
12:13:48 <jmcarthur> are we talking about all possible implementations of STM or just GHC's implementation?
12:14:30 <tommd> There is no locking needed on most any architecture.  Just TAS/MCAS etc... that said, what did GHC settle on?
12:14:57 <monochrom> Suppose I have program A using a million shared variables. I read all of them. Then I say: if they are not all the same value, "retry". Now I just say "retry". It has to know I was reading those one million shared variables.
12:15:06 <jmcarthur> i believe GHC takes a lock when committing a transaction but everything is otherwise unlocked and operations are stored in a log
12:15:40 <tommd> monochrom: It logs every TVar you touch during an atomic operation.  If you retry then a change of any of those TVars will trigger your routine.
12:15:51 <monochrom> Now suppose I have program B using just ten of those shared variables. Again I do some read/write of them, then I say: if blah, "retry". Now this "retry" knows I'm talking about those ten variables, not those one million.
12:15:52 <Cale> jmcarthur: right, that's my view of GHC's implementation as well
12:16:31 <monochrom> So "retry" magically knows what I have been doing. You need to be given it as a primitive.
12:17:06 <Cale> Er... it is a primitive of STM
12:17:23 <kmc_> but it needn't be a primitive in the Haskell implementation
12:17:49 <monochrom> If you say, "I create my own retryA tailored to program A, and my own retryB tailored to program B", then yes of course you can do that in all paradigms. But you don't have a single "retry". And when you modify A you have to modify retryA too, error-prone.
12:18:56 <Cale> Well, the STM monad presumably constructs a transaction log.
12:20:14 <chrisdone> is happstack ENTERPRISE READY (i.e. any sites out there using it) yet?
12:20:44 <gwern> patch-tag?
12:20:53 <koeien37> i am using it for a very small site
12:21:04 <koeien37> maybe 25 non-bot visitors up until now =)
12:21:08 <chrisdone> koeien37: can I see?
12:21:09 <copumpkin> chrisdone: if you use happstack + parsec you'll have an enterprise-level industrial-strength synergistic web framework with parsing!
12:21:16 <chrisdone> copumpkin: hahaha
12:21:25 <name> BUZZWORD BINGO!
12:21:26 <monochrom> OK, if you further want fairness, effeciency... then "retry" is better off a primitive so it has access to other threads as well and negotiate or communist-plan.
12:21:39 <koeien37> chrisdone: http://huygens.functor.nl/skritter/wordlist/ . the 2009 should be a 2010, whoops
12:21:39 <chrisdone> gwern: ah, nice
12:22:33 <koeien37> chrisdone: it's not really something that you can use probably
12:25:17 <ray> enterprise happstack would need to support oracle
12:25:17 <chrisdone> k
12:25:48 <chrisdone> I didn't mean to write 'k' then
12:25:55 <koeien37> chrisdone: it's a very small site as you can see =) but I would trust happstack with my site. Not sure about happstack-data yet, though
12:28:34 <Twey> Does happstack support on-disk ACID persistent storage yet?
12:28:49 <koeien37> everything is stored on disk as well
12:28:53 <koeien37> but also in memory
12:29:01 <koeien37> AFAIK the latter is not optional
12:29:29 <boris__> I am looking at Hask category on http://www.haskell.org/haskellwiki/Hask. A question about the seq problem. Why is type :: Int -> Int added to example? The examples seem to work without types the same.
12:29:42 <tibbe> dons: do you think you'll make it over to europe in march?
12:31:22 <koeien37> boris__: as far as I understand it, id :: a -> a is not in Hask, for for each a, id :: a -> a, is
12:31:36 <edwardk_> ooh, http://golem.ph.utexas.edu/category/2009/11/equipments.html now i need a whole mess of new machinery in category-extras ;)
12:32:02 <Athas> Hm, isn't there an instance of Functor for all instances of Monad?
12:32:09 <koeien37> unfortunately not
12:32:24 <_andy_> >:t lift
12:32:26 <_andy_> meh
12:32:34 <damd> :t lift
12:32:35 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
12:32:41 <kmc_> Athas, there should be but isn't.  there's a mechanical way to write it
12:32:43 <kmc_> which is fmap = liftM
12:33:19 <_andy_> if orphan instances aren't an issue..
12:33:25 <edwardk_> athas: alas they decided in haskell 98 not to bother to make everyone who wrote a monad have to implement fmap, so Monad is not a subclass of Functor =(
12:33:55 <Athas> I shall find some way to survive, I suppose.
12:34:06 <Twey> Luckily, we now have class aliases, so hopefully we can fix that soon
12:34:18 <kmc_> we do?
12:34:42 <boris__> koeien37: does it mean that we need to define a certain not polymorphic type?
12:34:50 <Ke> head .words "ab" what's wrong with this
12:35:10 <koeien37> boris__: yes. You could take Integer, or [Bool], or whatever
12:35:12 <kmc_> > (head . words) "ab"
12:35:13 <lambdabot>   "ab"
12:35:22 <kmc_> binary operators bind more weakly than function application
12:35:28 <kmc_> so what you have is:  head . (words "ab")
12:35:36 <kmc_> which doesn't work, because (words "ab") is not a function
12:35:50 <kmc_> > head $ words "ab"
12:35:51 <ziman> > head . words "ab"
12:35:52 <lambdabot>   "ab"
12:35:52 <lambdabot>   "a"
12:35:53 <ziman> :)
12:35:54 <kmc_> > head . words $ "ab"
12:35:55 <lambdabot>   "ab"
12:35:59 <Ke> AAAAAAAA
12:36:04 <boris__> koeien37: thanks:)
12:36:09 <Ke> thanks
12:36:35 <koeien37> so basically when you write a polymorphic function, you write down several arrows in the "category" Hask
12:36:39 <Veinor> 15:33:01 < edwardk_> athas: alas they decided in haskell 98 not to bother to make everyone who wrote a monad have to implement fmap, so Monad is not a subclass of Functor =(
12:36:44 <Veinor> can you devine fmap in terms of bind?
12:36:51 <Veinor> *define
12:37:00 <koeien37> liftM f m = m >>= return . f
12:37:54 <jmcarthur> Twey: we have class aliases?
12:37:55 <Veinor> that sounds about right
12:38:17 <boris__> I thought different instances of polymorphic functions are not created for each type they are used for.
12:38:47 <koeien37> boris__: in practice, no, probably not (unless they're specialized for some types, for efficiency reasons)
12:39:10 <koeien37> but they are a lot of arrows id :: a -> a, one for each Haskell type a
12:39:23 <koeien37> s/they/there
12:39:33 <Twey> jmcarthur: Well, the concept of them, anyway
12:39:36 <sinelaw> yo
12:40:40 <ziman> @pl \f v -> v >>= return . f
12:40:40 <lambdabot> fmap
12:40:45 <ziman> heh
12:41:01 <ziman> @pl \f v -> v >>= r . f
12:41:01 <lambdabot> (=<<) . (r .)
12:41:48 <boris__> koeien37: so different instances exist only in theory if we think about a program as a category because objects in category must have a certain not polymorphic. Am I right?
12:41:56 <koeien37> yes
12:42:34 <koeien37> each polymorphic function definition corresponds to an infinite amount of arrows in Hask
12:42:58 <boris__> are there arrows defined on polymorphic types?
12:43:14 <koeien37> in my understanding, polymorphic types are not objects in Hask
12:43:43 <copumpkin> Rank2Hask!
12:44:02 <koeien37> could you define that for me?
12:44:41 <copumpkin> I tried to think of how it would work a little while ago, but couldn't
12:45:04 <copumpkin> you need natural transformations as objects it seems
12:45:30 <koeien37> so a type constructor f that is an instance of Functor corresponds to a functor Hask -> Hask
12:45:47 <koeien37> again, ignoring seq and so on
12:46:07 <sshc> I'm trying  to understnd the state monad by reading about in in the All about monads page, and all is well until I read "The binding operator produces a Reader that uses the environment to extract the value its left-hand side and then applies the bound function to that value in the same environment."
12:46:10 <boris__> may you advise to read something for dummies about this topic?
12:46:24 <koeien37> http://en.wikibooks.org/wiki/Haskell/Category_theory
12:46:39 <koeien37> i just found this to confirm my suspicions about Hask
12:46:39 <sshc> "to extract the value its left-hand side"  <- is he missing a "to" between "value" and "its"?
12:47:10 <koeien37> no. "from" is better
12:47:12 <Twey> ‘From’ or ‘of’
12:47:14 <HaskellLove> what are your own "rules" when do you use iteration over recursion? in a functional programming context of course...
12:47:29 <koeien37> what would "iteration" be in haskell?
12:47:55 <sshc> and to which environment is he referring when he says "...produces a Reader that uses the envornment"
12:48:11 <koeien37> the environment that will be supplied upon running the monadic action
12:48:27 <koeien37> Reader e a -- the type of the environment is "e"
12:48:39 <sshc> koeien37: so the initial environment to which "e" points in State $ \e ... ?
12:48:44 <koeien37> yes
12:48:50 <copumpkin> insance Arrow Reader where
12:48:52 <sshc> s/State/Reader/, and ok
12:48:53 <copumpkin> :P
12:48:56 <koeien37> sshc: yeah
12:49:12 <HaskellLove> koeien37 well i guess you could call this an iteration [x|x<-[1..100], let y = bla bla]
12:49:13 <monochrom> Why are you reading the Reader section for State?
12:49:17 <koeien37> copumpkin: Reader is isomorphic to (->) :)
12:49:27 <copumpkin> koeien37: that's why I wrote it  :P
12:49:27 <koeien37> HaskellLove: that is a list comprehension
12:49:48 <HaskellLove> koeien37 well yeah but it does iteration...
12:50:10 <koeien37> HaskellLove: no, it does do { x <- [1..100]; let y = bla bla; return x }
12:50:25 <_andy_> sequence_ [y | x <- [1..100], y = ... x ...]
12:50:58 <_andy_> meh, erase..
12:51:25 <koeien37> which, in turn, is [1..100] >>= (\x -> let y = bla bla in return x)
12:52:14 <copumpkin> which in turn is concatMap (\ x -> let y = bla bla in return x) [1..100]
12:52:18 <koeien37> and (>>=) for the [] monad is just flip concatMap, so there we have our recursion back (since map and concat are defined recursively)
12:52:25 <HaskellLove> well isnt that iteration? i mean, define iteration... you have function g and you apply it n times untill a condition is met
12:52:28 <kmc_> @src concat
12:52:28 <lambdabot> concat = foldr (++) []
12:52:45 <koeien37> since map & concat are foldr's, i guess
12:53:10 <koeien37> iterate g x !! n -- do you mean this?
12:53:51 <monochrom> If you like to call it "iteration" or "while" or "feedback technology" you're pretty welcome.
12:54:00 <HaskellLove> that is iteration too yes
12:54:25 <koeien37> then how, in your view, is iteration different from recursion?
12:55:04 <copumpkin> it is iteration if everything is iteration
12:55:16 <sinelaw> Throwing a question here: About (2d) animation in an frp-ish model. A (2d) animation can be modelled as a function Time -> Image. In my case I have two Images I want to animate (morph/interoplate) between. The two images (start and end points) represent something, while the interpolations don't (they are there for visual appeal). How to model that?
12:55:38 <Athas> Is there a standard ID monad?
12:55:46 <Athas> (For my monad transformer tower.)
12:55:46 <copumpkin> Identity
12:55:48 <Athas> Thanks.
12:56:05 <koeien37> newtype Identity a = Identity a
12:56:09 <FliPPeh_> > pi
12:56:10 <lambdabot>   3.141592653589793
12:56:16 <koeien37> > pi :: CReal
12:56:17 <lambdabot>   3.1415926535897932384626433832795028841972
12:56:35 <sinelaw> I could take the "current time" as a function that picks the frame, and whenever T is out of bounds of the interpolation I just show either the first or the last frame (the endpoints)
12:56:44 <sinelaw> *"current frame"
12:57:35 <sinelaw> any ideas?
13:01:31 <sinelaw> or, i could have the system "switch" into a behavior that changes in time for the duration of the animation, and then switches back into a constant image
13:03:19 <jmcarthur> sinelaw: i like that last one, myself
13:03:44 <jmcarthur> sinelaw: but both seem that they could be valid constructions of the model
13:04:13 <sinelaw> jmcarthur, i'm looking for simple
13:04:30 <sinelaw> simplicty, even
13:04:52 <jmcarthur> sinelaw: the model is simple. the API can be simple. the implementation doesn't have to be simple
13:05:09 <jmcarthur> (although it's nicer if it's simple)
13:05:41 <jmcarthur> i also suspect that once we finally nail down a really good abstraction then the implementation will fall right out of it
13:05:43 <sinelaw> jmcarthur, i know. so which model is the simplest? That's my question
13:06:12 <sinelaw> for this specific problem, because i don't intend to solve the general case at this particular instance
13:06:22 <jmcarthur> sinelaw: your model is T -> Image. your two proposed uses are equivalent, really
13:06:30 <jmcarthur> as i understand them
13:06:53 <sinelaw> jmcarthur, at the top level they are
13:06:59 <sinelaw> they behave the same
13:07:06 <sinelaw> which shows they are both valid, as you said.
13:07:22 <sinelaw> but i'm trying to decompose it in different ways (in the model, not talking about implementation yet)
13:07:23 <jmcarthur> and they are semantically the same
13:07:33 <sinelaw> they result from different compositions
13:07:43 <jmcarthur> 1+1 and 2 are the same
13:07:58 <SubStack> @pl \n -> all ((/= 0) . (mod n)) . takeWhile (< (floor $ sqrt $ fromIntegral n)
13:07:58 <lambdabot> (line 1, column 43):
13:07:59 <lambdabot> unexpected "<"
13:07:59 <lambdabot> expecting lambda abstraction or expression
13:08:15 <SubStack> @pl \n -> all ((/= 0) . (mod n)) . takeWhile (< (floor $ sqrt $ fromIntegral n))
13:08:16 <lambdabot> ap ((.) . all . ((0 /=) .) . mod) (takeWhile . flip (<) . floor . sqrt . fromIntegral)
13:08:19 <jmcarthur> if you are concerned about efficiency, you aren't really looking for a model. you're looking for an implementation
13:08:22 <sinelaw> jmcarthur, that's like saying that every model of a program that at the top level behaves the same, is completely equivalent
13:08:22 <SubStack> o_O
13:08:44 <jmcarthur> sinelaw: exactly
13:08:46 <sinelaw> jmcarthur, which i don't agree with, because how each model is composed is also important
13:08:56 <jmcarthur> sinelaw: if you want efficiency in your model, T -> a is the wrong one
13:09:02 <sinelaw> jmcarthur, i'm not talking about implementation
13:09:05 <sinelaw> or efficiency
13:09:15 <jmcarthur> sinelaw: T -> a doesn't say anything about efficiency
13:09:21 <jmcarthur> sinelaw: now i'm confused then
13:09:53 <jmcarthur> SubStack: that actually doesn't look so bad to me
13:10:14 <jmcarthur> SubStack: could be cleaned up, though
13:10:29 <SubStack> it's not actually correct now that I look at the results more closely
13:10:34 <jmcarthur> ah
13:10:48 <SubStack> point-free prime sieve ;)
13:11:29 <copumpkin> I'd make it infinite
13:12:11 <sinelaw> jmcarthur, if i want to model something that behaves like 2, i can say it is composed of 1+1, or I can say it is the square of sqrt(2) - eventually they are equivalent (They describe the same thing) but one is simpler and easier to work with
13:12:21 <sinelaw> and i mean semantically simpler and easier to work with
13:12:36 <jmcarthur> sinelaw: the semantic models are the same though: T -> a
13:12:59 <sinelaw> jmcarthur, i feel i'm going in circles...the question is how to decompose that
13:13:08 <jmcarthur> sinelaw: if you are speaking of how to *use* the semantic model, then i'd agree that the second seems simpler to me
13:13:25 <SubStack> ah, < should be <=
13:13:27 <sinelaw> maybe we have different ideas about the term 'semantic model'
13:13:43 <sinelaw> i think you mean that the semantic model is T->a in general
13:13:46 <jmcarthur> sinelaw: how to decompose what? your second proposal into simple parts?
13:14:33 <sinelaw> jmcarthur, when I say "semantic model" i mean a precise description of the system's behavior, including how that is composed from simpler things (if neccesary)
13:14:59 <sinelaw> jmcarthur, how to decompose the "animative behavior" that i want, into simpler parts.
13:15:24 <sinelaw> one option is to say that it is one function that is defined piecewise.
13:15:28 <HaskellLove> do you guys use difference lists?
13:15:35 <SubStack> @pl \n -> all ((/= 0) . (mod n)) . takeWhile ((<= n) . (^ 2))
13:15:36 <lambdabot> ap ((.) . all . ((0 /=) .) . mod) (takeWhile . (. (^ 2)) . flip (<=))
13:15:38 <copumpkin> HaskellLove: I never have
13:15:44 <jmcarthur> HaskellLove: pretty much only for things like the Writer monad
13:16:02 <copumpkin> or the writer functor!
13:16:03 <sinelaw> jmcarthur, another is to say that it is a function that takes three different behaviors (const, changing, const) and switches between them
13:16:14 <sinelaw> they are very similar. that's why i'm not satisfied
13:16:40 <jmcarthur> sinelaw: you aren't satisified because there is more than one way to denote the same thing?
13:17:29 <sinelaw> jmcarthur, no,  i'm not satisfied because i want to weigh different options, not similar ones.
13:19:17 <jmcarthur> sinelaw: okay, now my understanding is that you would like to explore models besides T -> a
13:19:24 <sinelaw> another thing i don't like is that the model T->a implies that the function has a notion of "the value of the current time"
13:20:00 <sinelaw> jmcarthur, i'm confused myself...but yes, i'd like to see alternatives to that too
13:20:13 <mmmdonuts> surely that's "the value of the function at the current time" ?
13:20:39 <sinelaw> mmmdonuts, it takes a T as a parameter, what is that value?
13:20:42 <jmcarthur> sinelaw: to make sure that we are clear on how i interpret the terminology, i'm calling T -> a your model and your two proposals as denotations that are expressible with the model
13:20:52 <tommd> preflex: seen Axman6
13:20:52 <preflex>  Axman6 was last seen on #haskell 6 hours, 38 minutes and 5 seconds ago, saying: etyhkljrtijobgfsgn
13:21:02 <sinelaw> jmcarthur, fine. as long as we understand each other
13:21:06 <tommd> I think preflex has garbled quotes.
13:21:18 <sinelaw> preflex, seen tommd
13:21:19 <preflex>  tommd was last seen on #haskell 13 seconds ago, saying: I think preflex has garbled quotes.
13:21:24 <sinelaw> preflex, seen preflex
13:21:24 <preflex>  what
13:22:26 <jmcarthur> sinelaw: could you perhaps explore what it is that makes you dislike the notion of "the value of the current time"?
13:22:41 <mmmdonuts> sinelaw, I'm saying a function of type T->a is not giving you "the value of the current time" but rather the value of that function at the (specified) time.  But perhaps I'm reading too much into how you phrased that.
13:22:53 <sinelaw> jmcarthur, another faint idea i had was to have a sequence of animation 'key points' between which we interpolate, or something in that direction
13:23:18 <sinelaw> mmmdonuts, probably. what i'm trying to say is that the function gets called with the current time.
13:23:24 <copumpkin> mmmdonuts
13:23:48 <sinelaw> jmcarthur, the whole idea is to distance myself from the time-coupling
13:23:54 <sinelaw> that wasn't clear...
13:23:58 <mmmdonuts> copumpkin
13:24:15 <copumpkin> mmmdonuts: what? I was just eating some donuts and enjoying the
13:24:28 <sinelaw> he was just eating a pumpkin?
13:24:33 <jmcarthur> sinelaw: what would be your model for the keyframe idea?
13:24:42 <Zariel> is to possible to split a number like this, 5.3 -> (5, 3)
13:24:47 <jmcarthur> sinelaw: [(T, Image)]?
13:24:54 <tommd> @tell Axman6 We have some cracker wanna-be invading #hackage slightly under three names (but one IP).  So far he's not flooding at least.
13:24:54 <lambdabot> Consider it noted.
13:25:02 <sinelaw> jmcarthur, that would bring me back to events :)
13:25:07 <sinelaw> so maybe
13:27:39 <sinelaw> Zariel, \x -> (floor x, x - (floor x))
13:27:43 <sinelaw> > \x -> (floor x, x - (floor x)) 3.2
13:27:45 <lambdabot>   Couldn't match expected type `t1 -> t'
13:27:45 <lambdabot>         against inferred type `(b, a)'
13:27:52 <sinelaw> > (\x -> (floor x, x - (floor x))) 3.2
13:27:53 <lambdabot>   Ambiguous type variable `a' in the constraints:
13:27:53 <lambdabot>    `GHC.Real.RealFrac a'
13:27:53 <lambdabot>   ...
13:28:05 <sinelaw> > (\x -> (floor x, x - fromInteger (floor x))) 3.2
13:28:06 <lambdabot>   (3,0.20000000000000018)
13:28:12 <sinelaw> almost :)
13:28:27 <sshc> (Reader r) >>= f = Reader $ \e -> f (r e) e
13:29:09 <sshc> so f is a function that takes the result of the first Reader computation and the current environment, and returns a result?
13:30:08 <osfameron> > (floor &&& (\x -> x - (fromInteger $ floor x))) 3.2
13:30:09 <lambdabot>   (3,0.20000000000000018)
13:30:19 <osfameron> @unpl (\x -> x - (fromInteger $ floor x))
13:30:20 <lambdabot> (\ x -> x - (fromInteger (floor x)))
13:30:21 <damd> > let float = 5.3 in  (read (takeWhile (/= '.') (show float)) :: Int, read (tail (dropWhile (/= '.') (show float))) :: Int)
13:30:22 <lambdabot>   (5,3)
13:30:44 <osfameron> @pl  (\x -> x - (fromInteger $ floor x))
13:30:45 <lambdabot> ap (-) (fromInteger . floor)
13:31:46 <osfameron> > (floor &&& ap (-) (fromInteger . floor)) 4.3
13:31:47 <lambdabot>   (4,0.2999999999999998)
13:31:59 <sinelaw> @pl (\a b -> (b, a - b))
13:31:59 <lambdabot> ap (,) . (-)
13:39:00 <ezeike> So I have the line 'h = getEnv "HOSTNAME"' but I can't concat h with a string, such as 'h ++ "test"', I get an error. What do I have to do?
13:39:27 <kmc_> because h is an IO action that yields a string
13:39:32 <kmc_> it's not a string itself
13:39:34 <kmc_> :t getEnv
13:39:35 <lambdabot> Not in scope: `getEnv'
13:39:44 <ben> @hoogle getEnv
13:39:45 <lambdabot> System.Environment getEnv :: String -> IO String
13:39:45 <lambdabot> System.Environment getEnvironment :: IO [(String, String)]
13:39:49 <kmc_> do { h <- getEnv "HOSTNAME"; return (h ++ "test") }
13:40:23 <Ke> is instance supposed to work with a parameterized type
13:40:32 <Twey> Eww
13:40:56 <SubStack> I should get a hackage account in the next few weeks
13:41:01 <Twey> (++ "test") <$> getEnv "HOSTNAME"
13:41:05 <kmc_> Ke, do you have an example of what you mean?
13:41:21 <Ke> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15671#a15671
13:41:24 <kmc_> Twey, right, understanding that is a bit much for a beginner though :/
13:41:46 <kmc_> Ke, instance Eq (QueueEvent a)
13:41:47 <Ke> works without the parameterization
13:41:52 <kmc_> QueueEvent is not a type, it's a type constructor
13:42:10 <kmc_> it has kind * -> *, meaning it expect to be applied to a type
13:42:19 <Ke> hanks
13:42:32 <kmc_> if you need it, you can put constraints, e.g. instance (Eq a) => Eq (QueueEvent a)
13:42:38 <kmc_> it seems like you don't need that here
13:42:39 <Ke> yes
13:42:49 <Ke> and no
13:43:11 <kmc_> now, if you need to compare a (QueueEvent Char) with a (QueueEvent Float), then this won't work
13:43:17 <kmc_> and you need an existential type instead
13:43:38 <SubStack> it would be neat if there were a tool to push modules hosted on github onto hackage automatically
13:43:41 <kmc_> or just a custom eq :: QueueEvent a -> QueueEvent b -> Bool
13:44:56 <periodic> If you make QueueEvent a an instance Eq, won't that take care of most of it?  Just have to write those functions.
13:45:06 <periodic> er, yeah, like you said.
13:45:19 <periodic> Sorry.  didn't read it as well as I should have.
13:46:15 <roconnor> does github host darcs repositories?
13:46:24 <Saizan> no
13:46:33 <Saizan> there's patch-tag to host darcs repos
13:46:35 <roconnor> I guess that is to be expected
13:46:36 <mental> would be rather ironic if it did
13:47:50 * hackagebot upload: zip-archive 0.1.1.6 - Library for creating and modifying zip archives. (JohnMacFarlane)
13:47:51 <roconnor> maybe I should put Data.Colour on patch-tag
13:47:52 * hackagebot upload: explicit-iomodes 0.1.5 - File handles with explicit IOModes (BasVanDijk)
13:49:26 <Ke> interesting how haskell priority queue has to do with IO
13:49:42 <Saizan> there are pure ones too
13:50:11 <Ke> any names
13:50:38 <ezeike> kmc_: ok thanks. i'm trying to use this in my xmonad.hs. Is it better to put the getEnv call at the top somewhere and reference the variable later, or should it all be done later?
13:50:46 <roconnor> There is a priority queue in the finger tree's article I think
13:51:08 <kmc_> ezeike, it doesn't matter much.  in Haskell we have equational reasoning, meaning that if you write "x = e" and use x later, it's always exactly as if you wrote "e" there
13:51:13 <kmc_> except for performance considerations
13:51:36 <Ke> ah. pure-priority-queue
13:51:57 <Veinor> let (?) True x y = x; (?) False x y = y in (True ?) 1 2
13:51:59 <Veinor> I hate myself now.
13:52:01 <kmc_> ezeike, applying a function never has a side effect
13:52:14 <roconnor> Ke: http://www.soi.city.ac.uk/~ross/papers/FingerTree.pdf, section 4.6
13:52:29 <Ke> =D
13:52:30 <ezeike> kmc_: alright, i run into a problem when I do 'hostname <- getEnv "HOSTNAME"' on a line by itself.
13:52:44 <kmc_> ezeike, what do you want to do with the hostname once you get it?
13:52:53 <kmc_> the "do" block glues together several IO actions
13:53:04 <kmc_> the last of which cannot be the "x <- e" form, because then where would x be used?
13:53:15 <kmc_> when you say (x = getEnv "FOO") or (y = putChar 'x'), you are simply giving a name to a description of how effects *could* be performed.  the effect is not actually performed yet.
13:53:18 <Ke> roconnor: also not found
13:53:45 <roconnor> Ke: remove the comma at the end
13:54:12 <roconnor> Ke: also http://hackage.haskell.org/package/fingertree-psqueue
13:54:26 <roconnor> and I would guess it is a little faster that pure-priority-queue
13:54:29 <ezeike> kmc_: To change what action a key does depending which host I'm running on
13:55:08 <kmc_> ezeike, so you want something like:  do { hostname <- getEnv "HOSTNAME"; doStuffBasedOnHostname hostname }
13:55:25 <kmc_> where doStuffBasedOnHostname would be the function that takes a hostname as an argument, and returns the action of what to do
13:55:41 <kmc_> this could be defined anywhere in your file, using pattern matching
13:55:44 * roconnor wonders what the difference between a prioirity queue and a search queue is
13:55:51 * roconnor wonders what the difference between a prioirity queue and a priority-search queue is
13:57:08 <Saizan> roconnor: it also works as a Data.Map on another measure
13:57:29 <roconnor> oh, so it is both a map and a queue?
13:57:33 <ezeike> kmc_: My first thought was to get the hostname at the beginning of the file and put it in a variable and then use that variable in a string concat such as ' "script " ++ hostname ++ " somemorestuff" '
13:57:48 <kmc_> ezeike, you cannot easily get the hostname into a global variable
13:57:52 <ezeike> ah
13:57:52 <kmc_> because variables don't vary in Haskell
13:58:03 <kmc_> they are just names for expressions
13:58:10 <Ke> haskell priority queue is funny
13:58:12 <kmc_> well actually -- there is an easy way to do it, but it's a total hack
13:58:19 <Ke> http://hackage.haskell.org/packages/archive/pure-priority-queue/0.14/doc/html/Data-PurePriorityQueue.html wth is a here
13:58:19 <kmc_> and definitely frowned upon
13:58:40 <kmc_> you can instead make a global variable which holds the *action* that *gets* the hostname
13:58:41 <Saizan> roconnor: yeah, in PSQ k p you can insert/lookup using k for the keys, and fetch the minimum wrt p
13:58:49 <roconnor> Ke: wth is what?
13:58:51 <kmc_> and use it with the "do" syntax everywhere you need it
13:59:21 <Twey> 21:41:00 < kmc_> Twey, right, understanding that is a bit much for a beginner though :/
13:59:26 <Ke> what is a priority queue with 2 type parameters
13:59:29 <Twey> kmc_: Easier than understanding the monadic version, IMO
13:59:31 <kmc_> Twey, re: which?
13:59:36 <kmc_> maybe
13:59:46 <Twey> getEnv "HOSTNAME"
13:59:47 <kmc_> but less powerful; you will need the monadic version later
14:00:00 <Saizan> Ke: 'p' is for the priority, 'a' is for a value stored with a given priority
14:00:03 <Twey> Aye, but it's easier to handle if you build up to it
14:00:08 <kmc_> here you want to get the hostname, then decide what to do based on that -- sounds definitely like something applicative can't do
14:00:11 <kmc_> i'm not sure tbd
14:00:13 <kmc_> tbh*
14:00:21 <roconnor> Ke: it says right there: A queue of values of type a with priority of type p.
14:00:22 <kmc_> i learned Monad before Functor or Applicative
14:00:31 <Twey> Applicative can definitely do it
14:00:47 <Ke> o_O
14:00:49 <Twey> Yeah, so did I, but it made a heck of a lot more sense after I learnt about Pointed/Functor/Applicative
14:01:28 <Ke> so if I have a type ord, I have to add it twice to the queue
14:01:36 <Ke> or then just use (), hmm
14:02:51 <roconnor> Ke: you want a priority queue of numbers themselves?
14:03:05 <ezeike> kmc_: ok here's a bit of my xmonad.hs that shows what I'm going for, would you (or someone) be able to fix it up? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15672#a15672
14:03:18 <roconnor> Ke: I guess I could believe that your type is an instance of Ord
14:03:32 <ezeike> kmc_: fix it up the proper way
14:03:39 <Ke> no number, yes Ord
14:03:45 <kmc_> ezeike, you can't just use "foo <- bar" at global scope like that
14:03:58 <kmc_> it's part of a "do" block, and the name is only in scope for the rest of the block
14:04:02 <kmc_> i'll try to fix it
14:05:46 <ezeike> kmc_: maybe just a quick reorganize so I get a general idea of how it should look
14:05:54 <kmc_> suer
14:05:56 <kmc_> sure*
14:06:06 * hackagebot upload: safer-file-handles 0.1 - Type-safe file handling (BasVanDijk)
14:09:12 <Saizan> Ke: right, if what you want to store is itself the priority then use () for a
14:10:37 <kmc_> ezeike, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15672#a15673
14:11:09 <HaskellLove> let l be a list. is "last l" slower then "l !! (length l)-1"
14:11:29 <aavogt> HaskellLove: asymptotically?
14:11:58 <aavogt> the second one should be about twice as slow
14:12:06 <HaskellLove> or they compile to the same thing so it does not matter i guess
14:12:22 <aavogt> I highly doubt that they compile to the same thing
14:12:43 <basvandijk> He guys, just want to let you know that I just uploaded my safer-file-handles package to hackage. It provides two safety features on top of the regular System.IO file handles: 1) regional file handles (files are automatically closed when its region terminates and handles can't escape their region which ensures no IO with closed files is possible) 2) Explicit IOModes
14:12:43 <sshc> is "f" a function that takes the result of the first Reader computation and the current environment, and returns a result?
14:12:46 <ezeike> kmc_: hm not bad, thanks
14:13:15 <kmc_> :)
14:13:16 <basvandijk> I will make a proper announcement later this week
14:13:22 <HaskellLove> last l, recursively unfolds the list to the last element, so it traverses all elements. length traverses all elements to get length. so it seems these are same or close?
14:13:27 <gwern> basvandijk: what's the connection with cautois-file?
14:13:51 <kmc_> sshc, in what context?
14:13:59 <HaskellLove> aavogt why would not they compile to same thing, that is, the pointed element in this case, the last one?
14:14:08 <basvandijk> gwern: I do not know cautois-file... I'm going to look
14:15:08 <sshc> (Reader r) >>= f = Reader $ \e -> f (r e) e
14:15:20 <sshc> kmc_: Reader's bind
14:15:48 <aavogt> > let f1 x = x !! pred (length x); in f1 []
14:15:49 <lambdabot>   * Exception: Prelude.(!!): negative index
14:15:55 <aavogt> > length []
14:15:57 <lambdabot>   0
14:16:02 <aavogt> > last []
14:16:03 <lambdabot>   * Exception: Prelude.last: empty list
14:16:08 <kmc_> (>>=) :: (Reader r a) -> (a -> Reader r b) -> (Reader r b)
14:16:14 <kmc_> hence, f :: (a -> Reader r b)
14:16:16 <basvandijk> gwern: From the look of it cautious-file has to do with reducing the change of data loss when writing to a file... my safer-file-handles prevent you for writing to closed files or file opend in only read mode
14:16:31 <kmc_> a function that takes the result of the first reader computation, and returns a second computation
14:16:36 <kmc_> which, internally, is a function of environment
14:16:39 <kmc_> but that's hidden to the user
14:16:46 <kmc_> behind the Reader constructor
14:17:36 <kmc_> @unmtl Reader r a
14:17:37 <lambdabot> r -> a
14:17:40 <basvandijk> gwern: See the hackage page for details on my package if you're interested: http://hackage.haskell.org/package/safer-file-handles
14:17:43 <aavogt> HaskellLove: yes, the functions do the same thing, but without lots of intervention on part of the compiler, the one that uses !! ends up doing two traversals of the list, while length does only one
14:17:55 <aavogt> err, I mean last instead of length
14:17:59 <aavogt> @src last
14:18:00 <lambdabot> last [x]    = x
14:18:00 <lambdabot> last (_:xs) = last xs
14:18:00 <lambdabot> last []     = undefined
14:18:07 <HaskellLove> aavogt two? how come?
14:18:15 <ezeike> kmc_: "last statement in a do construct must be an expression", do you know what to do about that?
14:18:26 <kmc_> ezeike, yes
14:18:26 <aavogt> HaskellLove: length is one traversal, !! does a separate one
14:18:29 <koeien37> make the last statement in a do construct an expression
14:18:42 <kmc_> it means you have something like do { x <- a; y <- b }
14:18:51 <kmc_> it is unhappy because it doesn't know what to do with y when you've bound it
14:18:59 <kmc_> because the do expression ends
14:19:01 <koeien37> or do { x <- a; let y = b }
14:19:08 <kmc_> you want: do { x <- a; b }
14:19:14 <kmc_> because you're never going to use that 'y' anyway
14:19:15 <aavogt> > do {}
14:19:16 <lambdabot>   <no location info>: Empty 'do' construct
14:19:20 <ezeike> kmc_: ok well i pasted in what you wrote
14:19:21 <HaskellLove> aavogt wait wait, it makes no sense !! to traverse the list twice
14:19:28 <kmc_> ezeike, maybe i had a syntax error
14:19:33 <aavogt> HaskellLove: no, !! traverses the list once
14:19:36 <koeien37> (!!) traverses it once, but length must also traverse it
14:19:36 <kmc_> ezeike, you're not using tabs in your editor, are you?
14:19:50 <aavogt> > 1 + 1
14:19:51 <lambdabot>   2
14:19:52 <kmc_> the usual Haskell syntax is whitespace-dependent (though there is always an alternate form)
14:19:55 <kmc_> and it doesn't like tabs very much
14:20:10 <ezeike> kmc_: not saying it's your fault at all. vim is using tabs yeah
14:20:14 <koeien37> :set et
14:20:15 <kmc_> ezeike, which line did you see the error on?
14:20:26 <HaskellLove> koeien37 we are talking about using either !! or last not both together so why are we talking about using !! and length together? am i missing something
14:20:48 <aavogt> HaskellLove: you did define a function that used  !!   and   length
14:21:02 <koeien37> I didn't follow the whole discussion. I thought that you had something like   xs !! (length xs - 1)
14:22:25 <HaskellLove> no i did not... i asked is "last a" faster then "a !! (length a - 1)"
14:22:33 <kmc_> omfg
14:22:42 <koeien37> ah
14:22:51 <koeien37> anyway. it's both faster and uses less memory
14:23:00 <ezeike> kmc_: line 8. Making the "do" on a line by itself made the error go away
14:23:41 <koeien37> a !! (length a - 1) uses O(n) memory, last a uses O(1) memory, provided that the list is no longer used anywhere else
14:23:42 <kmc_> okay, strange
14:23:57 <kmc_> my guess is that you've got a tab on the next line, so "let" isn't lining up with "hostname"
14:24:07 <kmc_> Haskell interprets tab stops as 8
14:24:17 <kmc_> if all else fails, use { } ;
14:24:25 <benmachine> -fwarn-tabs?
14:24:28 <kmc_> do { hostname <- .... ; let ... ; spawn ... }
14:24:49 <koeien37> you can convert tabs to spaces with the unix command expand; and I'd set vim to expand your tabs with :set et
14:26:31 <sproingie> that's one thing i don't like about the "line up vs indent" layout rule.  you change the outdented line, you have to reindent everything below
14:27:00 <monochrom> I love reindenting. Just kidding.
14:27:27 <jmcarthur> i don't use do notation enough to have a problem with it
14:27:52 <aavogt> nor case?
14:28:01 <jmcarthur> and even when i do have to reindent, haskell-mode for emacs is nice
14:28:11 <jmcarthur> i only occasionally use case
14:28:20 <jmcarthur> i have had to reindent it before, but it's not a big deal
14:28:34 <Ke> any way to comment more than one line?
14:28:41 <jmcarthur> arrow tab tab arrow tab tab arrow tab tab
14:28:42 <aavogt> {- yes \n -}
14:28:49 <Ke> thans
14:29:07 <koeien37> comments can also be nested in Haskell
14:29:13 <FliPPeh> ->->->
14:29:18 <FliPPeh> tab doesn't work ;<
14:29:22 <koeien37> > {- {- bla -} -} 3
14:29:23 <lambdabot>   3
14:30:37 <kmc_> sproingie, yeah that bugs me.  i stopped writing "foo = do ..." because the name of foo might change... now i always write "foo =\n  do"
14:30:52 <alexyk> how do I get AssocList into scope in ghci?
14:30:52 <kmc_> looks better too, all the blocks in the same column
14:30:52 <lambdabot> alexyk: You have 1 new message. '/msg lambdabot @messages' to read it.
14:30:57 <koeien37> I use foo = do \n
14:31:18 <koeien37> import Data.AssocList
14:31:39 <ezeike> kmc_: What does "X ()" mean in the function definition?
14:31:47 <kmc_> ezeike, it's the return type of the function
14:31:50 <kmc_> an action in the X monad
14:31:57 <alexyk> koeien: Could not find module `Data.AssocList': ...
14:32:06 <kmc_> "X ()" is the type of X-monad actions which do something, but don't provide a useful result
14:32:12 <kmc_> because the result type is (), the useless empty tuple
14:32:12 <kmc_> > ()
14:32:14 <koeien37> alexyk: ok. Where did you expect AssocList ? in which module?
14:32:14 <lambdabot>   ()
14:32:20 <alexyk> I'm trying to use AssocList as a constructor and it's strangely not there
14:32:22 <koeien37> alexyk: or hackage package?
14:32:29 <kmc_> similarly, you will see "IO ()" a lot, which is an IO action that does IO and produces no useful value
14:32:29 <kmc_> e.g.
14:32:33 <kmc_> :t putStrLn "hello world"
14:32:34 <lambdabot> IO ()
14:32:41 <koeien37> alexyk: it is not a standard definition
14:32:42 <alexyk> koeien37: I guess I need to install it separately?  surprising a bit
14:32:58 <alexyk> kk...
14:33:00 <ezeike> kmc_: k thanks
14:33:05 <koeien37> alexyk: no. I just used hayoo and didn't think about it further
14:33:13 <kmc_> ezeike, functions in Haskell never perform side effects.  instead, we can describe some side effects and return the description, to be performed later
14:33:13 <koeien37> alexyk: are you reading a book or tutorial?
14:33:26 <koeien37> alexyk: they probably have defined    type AssocList a b = [(a, b)]
14:33:31 <alexyk> koeien37: http://hackage.haskell.org/packages/archive/hxt/8.3.2/doc/html/Data-AssocList.html
14:33:36 <kmc_> that's what a "do" block does -- it builds up a description of side effects, by gluing together other effects
14:33:40 <kmc_> (in these cases, at least)
14:33:47 <koeien37> alexyk: this is part of hxt, an XML library
14:33:58 <koeien37> alexyk: if you want to use it, you'll have to still hxt first
14:34:04 <koeien37> s/still/install
14:34:17 <alexyk> but it's in an archive, hmm; AssocList is mentioned in RWH, I believe, and in some code I'm reading, tokyocabinet-haskell
14:34:31 <koeien37> they define it in RWH as I indicated
14:35:07 <basvandijk> I'm a bit confused about the documentation in System.IO about the standard handles (stdout, stdin and stderr). The doc states that they are always initially open. However 'man stdin' tells me they are only initially open "under normal circumstances". Which doc is correct?
14:35:35 <kmc_> basvandijk, the man page probably
14:35:52 <kmc_> in UNIX you can fork(), close stdin/stdout/stderr, then exec()
14:36:05 <basvandijk> kmc_: ok thanks
14:36:12 <kmc_> i don't see how the IO library or the GHC RTS would re-open them
14:36:41 <basvandijk> (The reason I ask is that in my safer-file-handles I have problems properly supporting the standard handles)
14:37:16 <jmcarthur> yeah it's common for daemons to close them, for example
14:37:36 <Veinor> I just wrote the ternary fishhook operator in Haskell.
14:37:38 <Veinor> WHAT HAVE I DONE
14:38:09 <koeien37> the fishhook operator? `乙` ?
14:38:24 <Veinor> no, bool ? a : b
14:38:28 <koeien37> oh
14:38:30 <Veinor> although I use ?? instead of : for obvious reasons
14:38:38 <ray> what a maidenly operator
14:38:39 <koeien37> if' p x y = if p then x else y
14:38:43 <benmachine> ?? = id?
14:38:44 <lambdabot> Plugin `compose' failed with: Unknown command: ""
14:38:48 <Veinor> yeah.
14:38:51 <benmachine> shh lambdabot
14:39:07 <Veinor> Prelude> (True?) 1 ?? 2
14:39:07 <Veinor> 1
14:39:23 <basvandijk> need
14:39:27 <Veinor> actually, the parens are redundant
14:39:38 <benmachine> either the parens or the ??
14:39:41 <Veinor> yeah.
14:39:42 <benmachine> are redundant
14:40:00 <benmachine> on a vaguely related note
14:40:09 <benmachine> I think there should be an -XNoIfSyntax
14:40:14 <Veinor> why?
14:40:22 <alexyk> koeien37: ah ok, it's also defined in tokyocabinet bindings for the table databases
14:40:25 <koeien37> do you want to free up if, then and else
14:40:32 <benmachine> if, mainly
14:40:33 <koeien37> (as keywords)
14:40:37 <benmachine> but then and else, why not them too
14:40:58 <koeien37> I think you might confuse a lot of people and syntax highlighters
14:41:06 <benmachine> possibly.
14:41:36 <koeien37> I don't really see the need for if/then/else, I don't use it often
14:41:38 <benmachine> well, syntax highlighters are always going to be confused by extensions that change how syntax is used
14:41:39 <basvandijk> I wish if...then...else... was removed from the language and replaced by a simple function if :: Bool -> a -> a -> a
14:41:51 <koeien37> basvandijk: agreed
14:41:54 <basvandijk> Thats how Clean does it
14:42:05 <benmachine> basvandijk: yeah, although actually a -> a -> Bool -> a tends to be more often useful in my experience
14:42:07 <kmc_> basvandijk, ye
14:42:08 <kmc_> yes
14:42:14 <Zao> let eef = ...
14:42:15 <kmc_> i also wish "head" were removed from the prelude
14:42:24 <benmachine> mm
14:42:25 <koeien37> kmc_: all partial functions?
14:42:28 <basvandijk> benmachine: right
14:42:29 <kmc_> preferably
14:42:34 <kmc_> but especially the ones that are tempting to beginners
14:43:00 <kmc_> let sum xs = if length xs == 0 then 0 else (head xs) + sum (tail xs)
14:43:17 <kmc_> everyone writes that kind of code when starting out
14:43:20 <Cale> heh
14:43:34 <kmc_> and it's much slower and less safe
14:43:37 <Cale> complete with excessive parens
14:43:41 <koeien37> are you sure that you don't mean
14:43:42 <benmachine> head(xs)
14:43:52 <koeien37> sum(xs) = if length(xs)==0 then 0 else (head(xs)) + sum(tail(xs)) ?
14:43:55 <kmc_> let sum(xs) = if length(xs) == 0 then 0 else (head(xs)) + sum(tail(xs))
14:43:56 <kmc_> yes
14:44:21 <koeien37> well I can't say I blame them, it's an uncommon feature amongst programming languages
14:44:37 <kmc_> not sucking is an uncommon feature amongst programming languages
14:44:42 <kmc_> especially popular ones
14:44:54 <benmachine> heh
14:44:59 <kmc_> and no i don't consider Haskell to be the only language that doesn't suck
14:45:11 <benmachine> haskell has some small corners of suck
14:45:15 <kmc_> oh yes
14:45:22 <koeien37> there are the languages that everybody complains about, and the languages that nobody uses ;)
14:45:29 <benmachine> hah
14:45:51 <koeien37> yeah, record syntax, lack of parametrized modules
14:45:55 <basvandijk> koeien37: in which category is Haskell?
14:46:05 <koeien37> basvandijk: the latter :)
14:46:16 <Taejo> koeien37: I would say, there are languages that everybody complains about, and the languages nobody's heard of
14:46:23 <basvandijk> I use it ;-)
14:46:25 <benmachine> @remember koeien37 there are the languages that everybody complains about, and the languages that nobody use
14:46:26 <Cale> Anything which is awesome by comparison to what is popular will be unpopular
14:46:26 <lambdabot> Good to know.
14:46:32 <koeien37> benmachine: it's not my quote
14:46:33 <kmc_> i guess we're lucky then, because a lot of people on reddit complain about Haskell
14:46:41 <benmachine> koeien37: now it is!
14:46:44 <Taejo> kmc_: precisely
14:46:47 <koeien37> bjarne stroustrup
14:46:52 <benmachine> k
14:47:02 <benmachine> well, nothing I can do about it now?
14:47:08 <idnar> Cale: that sounds like a logical impossibility
14:47:15 <Cale> @forget koeien37 there are the languages that everybody complains about, and the languages that nobody use
14:47:15 <lambdabot> Done.
14:47:21 <benmachine> ooh
14:47:23 <benmachine> clever
14:48:05 <kmc_> non-sucky languages are indeed becoming more common
14:48:25 <koeien37> including Haskell
14:48:37 <kmc_> yeah, but not as a primary example
14:48:37 <benmachine> which is both becoming more common and less sucky
14:48:50 * koeien37 saw yesterday two Haskell-programming CS freshmen
14:48:56 <Cale> Not less sucky enough.
14:49:05 <kmc_> koeien37, nice! where do you find such people?
14:49:09 <Veinor> IO is still sucky, imho
14:49:14 <Cale> There are a lot of things which I'd like to change about Haskell (and if/then/else isn't one of them)
14:49:29 <benmachine> lots of things are still sucky but I'm trying to be optimistic :(
14:49:30 <koeien37> they did, however, express the sentiment that they'd never use it for "something real" such as web development
14:49:37 <Cale> Most of them are Prelude things
14:49:39 <Veinor> :[
14:49:49 <Veinor> I would change the return type of length :p
14:49:54 <koeien37> Veinor: into?
14:49:58 <koeien37> :t genericLength
14:49:59 <lambdabot> forall b i. (Num i) => [b] -> i
14:50:03 <Cale> ^^ that
14:50:06 <Veinor> I would make length = genericLength, basically
14:50:11 <kmc_> Integer is probably good enough
14:50:16 <Cale> Int should probably be banished from the Prelude
14:50:16 <kmc_> and will produce fewer ambiguities
14:50:31 <koeien37> Int should exist, but not be easily accessible
14:50:39 <Cale> Yeah, it should be in Data.Int
14:51:04 <basvandijk> Yes I'm always wondering if its better to have a polymorphic returns type (restriced to some type class) or a specific one?
14:51:08 <Veinor> here's the problem I had: I had a computation that I wanted to do that might require user input as it went along
14:51:19 <basvandijk> (It's the same case with Data.Map.lookup)
14:51:20 <Cale> Mostly, it's a premature optimisation which screws up your program when it ends up in the inferred types of things which you thought would be integers.
14:51:23 <Veinor> I couldn't figure out a good way to do it :/
14:51:27 <koeien37> Cale: yes, a thousand times yes
14:51:41 <koeien37> Veinor: use an iteratee-type solution?
14:51:54 <Cale> basvandijk: I think Maybe is perfect for Data.Map.lookup
14:52:05 <Veinor> someone mentioned that, but I'm not entirely sure how to use it
14:52:05 <Cale> basvandijk: Monad is certainly not the right thing there.
14:52:11 <koeien37> it used to be Monad m => m v , right?
14:52:13 <kmc_> Veinor, you'd write it like any other imperative language?
14:52:15 <Cale> For a time
14:52:21 <Cale> Before that it was like it is now
14:52:31 <basvandijk> Cale: Yes I also like specific types more
14:52:38 <Veinor> kmc_: I mean, I haven't looked at the documentation
14:52:41 <koeien37> why Monad?
14:52:52 <Cale> I don't particularly mind polymorphic types, but they should be appropriate polymorphic types
14:52:53 <koeien37> I fail to see how it buys you anything
14:53:15 <koeien37> and it seems overly specific since Data.Map is not going to use join or fmap anyway
14:53:17 <kmc_> i feel like Haskell has more clever alternatives for IO, but the usual imperative style is always available, and is just as good if not better than in common dys-functional languages
14:53:22 <eugenn> @check (\x -> mod (360+x) 360) == id
14:53:23 <lambdabot>   No instance for (GHC.Classes.Eq (t -> t))
14:53:23 <lambdabot>    arising from a use of `GHC.Cla...
14:53:28 <Cale> koeien37: By abusing fail, you can use lookup in other settings where failure is meaningful without handling the Maybe explicitly
14:53:28 <Veinor> nonfunctioning languages?
14:53:33 <kmc_> yes
14:53:38 <Veinor> :V
14:53:46 <koeien37> Cale: yeah, a mistake imo
14:54:01 <koeien37> do { x <- [1,2,3]; y <- Map.lookup .... ; }
14:54:05 <Cale> I think the do-notation translation should go back to what it was in Haskell 1.4
14:54:25 <Cale> With MonadZero
14:54:35 <koeien37> what do you think about list comprehensions?
14:54:44 <jmcarthur> i would not mind the result of lookup being polymorphic with a FunctorZero constraint... if we had FunctorZero
14:54:46 <koeien37> should those become "monad comprehensions"?
14:54:51 <Cale> Yes.
14:54:55 <koeien37> yeah, agreed
14:55:08 <benmachine> FunctorZero? why not just HasZero?
14:55:11 <koeien37> fail should go out of Monad
14:55:24 <basvandijk> koeien37: agreed
14:55:28 <Cale> SPJ said he would accept a patch to add monad comprehensions back. Maybe this would be a way to sneak MonadZero back into the Prelude ;)
14:55:42 <Cale> (and break compatibility with the H2010 standard ;)
14:55:51 <benmachine> how did monad comprehensions work?
14:56:07 <Cale> benmachine: Similarly to do-notation, but guards were handled with guard
14:56:10 <Ke> Ambiguous occurrence `null' ← how do I deal with these?
14:56:10 <Cale> :t guard
14:56:11 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
14:56:17 <Cale> and guard had a MonadZero constraint
14:56:22 <Cale> rather than MonadPlus
14:56:34 <Ke> Data.PurePriorityQueue.null arg  perhaps?
14:56:41 <koeien37> Ke: that's an option
14:56:48 <Cale> Ke: Import the module qualified
14:56:59 <koeien37> if you do import qualified Data.PurePriorityQueue  as PQ, this saves some typing there
14:57:00 <Cale> Ke: You can also rename it while you're at it
14:57:37 <Cale> If you don't like writing qualified names in types (like me), you can import the type constructors separately
14:57:50 <koeien37> yeah, I do import qualified Data.Set as S, import Data.Set (Set)
14:58:05 <Cale> me too
14:58:06 <Ke> how does one import qualified
14:58:10 <koeien37> same for Map, and probably also for PurePriorityQueue
14:58:17 <Cale> Ke: Exactly as koeien37's examples
14:58:20 <koeien37> Ke: use the syntax I gave above
14:58:33 <Cale> import qualified Data.PurePriorityQueue as PQ
14:58:36 <monochrom> Another instance of answer before question.
14:59:01 <jmcarthur> benmachine: FunctorZero because this is for things of kind * -> *, not for things of kind * as it sounds like HasZero would be for
14:59:30 <koeien37> would Functor be a superclass of FunctorZero? If so, why?
14:59:42 <benmachine> jmcarthur: hmm, you can't just do instance HasZero [a] where... ?
14:59:55 <Ke> I should probably read some basic tutorial about import
14:59:55 <benmachine> or (Maybe a) or whatever
15:00:04 <Ke> still not getting any of that
15:00:25 <koeien37> import X  brings all names and instances exported by X in scope
15:00:49 * basvandijk is going to bed... goodnight!
15:00:59 <koeien37> are you going to the FP day on Friday?
15:01:03 <koeien37> basvandijk: ^
15:01:06 <basvandijk> koeien37: yes
15:01:33 <basvandijk> koeien37: you too?
15:01:36 <koeien37> yep
15:01:45 <basvandijk> koeien37: what's your real name BTW?
15:02:05 <koeien37> jochem berndsen
15:02:19 <basvandijk> koeien37: ok thanks... see you friday!
15:02:25 <koeien37> sure
15:05:56 <benmachine> so I think there exist people who are interested in a step-by-step haskell interpreter for illustrative purposes
15:06:21 <benmachine> I started writing one but it's currently ninety lines and only does simple lambdas
15:06:24 <koeien37> you mean, a simple implementation of Haskell in Haskell for didactic purposes?
15:06:35 <benmachine> well I mean a thing that shows you how a function is evaluated
15:07:07 <Cale> An interpreter which does lazy evaluation one step at a time, printing the results as it goes.
15:07:14 <koeien37> ah I see
15:07:14 <benmachine> yeah
15:07:20 <mee> sounds like a debugger
15:07:31 <benmachine> basically what I'm wondering is how much work I have to do before anyone else is interested
15:07:38 <koeien37> I try not to to think in those terms too much realy
15:07:43 <Cale> Well, yes, it would make for a decent debugger.
15:07:44 <benmachine> I mean, I presume there are already lambda interpreters in existence
15:07:54 <eu-prleu-peupeu> hi
15:08:12 <eu-prleu-peupeu> how can i have multiple declarations of a type constructor ?
15:08:15 <Cale> benmachine: If you can do lambda with let and case, I'd be interested :)
15:08:18 <koeien37> isn't there a way to do this with the ghc(i) debugger?
15:08:23 <Cale> (you don't even need a proper type system)
15:08:27 <eu-prleu-peupeu> data MyType = MyType String | MyType Int ... like this ? :P
15:08:33 <Cale> koeien37: not well
15:08:35 <koeien37> eu-prleu-peupeu: you can't
15:08:42 <benmachine> Cale: okay, I'll let you know if I ever get that far
15:08:49 <koeien37> those are data constructors btw
15:08:56 <monochrom> eu-prleu-peupeu: use different names.
15:09:05 <eu-prleu-peupeu> oh, that sucks
15:09:10 <koeien37> use different names, or MyType (Either String Int)
15:09:16 <monochrom> No it doesn't.
15:09:17 <eu-prleu-peupeu> that sucks too
15:09:18 <Cale> eu-prleu-peupeu: How else will it know what type the parameter has?
15:09:34 <eu-prleu-peupeu> Cale, through the type of the argument ?
15:09:44 <Cale> eu-prleu-peupeu: What about when you pattern match it back out?
15:09:52 <monochrom> This sucks: "YouKnowWhatIMean = YouKnowWhatIMean | YouKnowWhatIMean YouKnowWhatIMean | YouKnowWhatIMean String"
15:09:53 <koeien37> suppose i want to write a function of type MyType -> Int or so.   f (MyType x) -- what type is x here?
15:10:02 <Cale> eu-prleu-peupeu: What are you allowed to do with something which might be a String or an Int, but you have no idea which?
15:10:19 <eu-prleu-peupeu> Cale: what about it ? if all the constructors have arguments with different types, then i dont see the problem...
15:10:20 <Cale> eu-prleu-peupeu: I suppose there *is* some kind of answer to that, but it's not obvious.
15:10:43 <Cale> eu-prleu-peupeu: Suppose I write a function  foo (MyType x) = ... what type is x in here? ...
15:10:51 <Ke> still think It would be quite most awesome to have a haskell reference with "see also" -links
15:11:00 <koeien37> eu-prleu-peupeu: how are you going to write a pattern match there, that returns 0 on MyType "any string", and 1 on MyType (any integer)
15:11:02 <Cale> heh, I wrote the same thing as koeien37
15:11:14 <koeien37> so, f :: MyType -> Int
15:11:17 <eu-prleu-peupeu> Cale: the compiler should infer it.. .if it can't then a proper error should be emited, ain't that what it does most of the time ?
15:11:20 <koeien37> think about how you could write such a thing
15:11:32 <jmcarthur> what would it infer it as?
15:11:39 <jmcarthur> it has to be deterministic
15:11:47 <monochrom> IMO eu-prleu-peupeu is just asking for telepathy.
15:11:55 <benmachine> eu-prleu-peupeu: but if the compiler inferred it as Int and you gave the function MyType "blah", what would happen?
15:12:02 <eu-prleu-peupeu> jmcarthur: if it can't infer, then an error is to be shown
15:12:11 <eu-prleu-peupeu> error
15:12:16 <jmcarthur> eu-prleu-peupeu: without a formal rule, you are talking about magic
15:12:23 <jmcarthur> magic is something we don't like in compilers
15:12:29 <eu-prleu-peupeu> :D
15:12:32 <jmcarthur> because programs might break in unpredictable ways
15:12:41 <eu-prleu-peupeu> data MyType = Magic Int | Magic String
15:12:50 <monochrom> Are you done, troll?
15:13:02 <benmachine> don't accuse people of trolling
15:13:03 <eu-prleu-peupeu> im not a troll
15:13:06 <benmachine> it doesn't help even if they are
15:13:14 <Cale> eu-prleu-peupeu: Give an example of a function which pattern matches that type
15:13:18 <Cale> (a complete one)
15:13:28 <Cale> What sort of function do you want to write here?
15:13:44 <eu-prleu-peupeu> f MyType a = putStrLn (a :: String)
15:13:58 <Cale> What if a isn't a String then?
15:13:58 <benmachine> it could work if you tried hard enough but the result would be confusing as hell
15:14:11 <jmcarthur> syntax aside, what prevents me from trying: f (MyType 5)?
15:14:11 <monochrom> benmachine: It helps because people who didn't suspect trolling will think about it, then suspect trolling, then stop feeding.
15:14:13 <Cale> (I'll forgive the missing parens)
15:14:20 <eu-prleu-peupeu> then the compiler outputs the usual thing it does in those cases... "non-exaustive bla bla patterns in bla bla lambda yah"
15:14:32 <koeien37> f (MyType a) = putStrLn a ; f (MyType a) = putStrLn (show a)
15:14:32 <jmcarthur> eu-prleu-peupeu: what is the type of that function?
15:14:36 <koeien37> like that? ^
15:14:39 <eu-prleu-peupeu> yes, f (MyType String)
15:15:03 <koeien37> what if MyType = Magic Int | Magic Magic | Magic String
15:15:20 <Cale> koeien37: Magic MyType?
15:15:21 <HaskellLove> readFile "/home/user/Desktop/triangle.txt" >>= map (map read . words) . lines      Why does not that work?
15:15:25 <koeien37> Cale: yes, thanks
15:15:29 <jmcarthur> eu-prleu-peupeu: are you looking for polymorphism?
15:15:42 <koeien37> HaskellLove: the right hand side is not of type String -> IO a for some a
15:15:48 <eu-prleu-peupeu> koeien: oh, that doesn't work... it should output an error like "non-exaustive data constructors" :P
15:15:49 <jmcarthur> eu-prleu-peupeu: you could have: data MyType a = MyType a
15:15:54 <koeien37> try map (map read . words) . lines `liftM` readFile "bla"
15:16:12 <jmcarthur> eu-prleu-peupeu: then your function would have type MyType String -> IO ()
15:16:17 <Cale> HaskellLove: btw, if you have a long composition on the right hand side of >>=, it's often nicer to flip it over
15:16:27 <koeien37> (>>=) composes monadic/IO actions.
15:16:36 <koeien37> liftM lifts a function to functions on monadic values
15:16:38 <Cale> print . map (map read . words) . lines =<< readFile "..."
15:16:40 <eu-prleu-peupeu> ok, ill try the diff names approach, thanks
15:17:16 <Cale> jmcarthur: Did you just confuse two streams of conversation there?
15:17:21 <koeien37> <$> is also a nice function to use instead of `liftM` or `fmap`
15:17:40 <jmcarthur> for the record, i don't think eu-prleu-peupeu's idea is all that bad, but it just lacks formalism
15:17:43 <Cale> jmcarthur: er, oh, perhaps you didn't :)
15:17:45 <jmcarthur> Cale: i don't think so...
15:17:57 <koeien37> I think it would get confusing quickly
15:17:57 <eu-prleu-peupeu> yay :D
15:18:00 <eu-prleu-peupeu> i have a friend
15:18:05 <twanvl> you can use  data MyType = forall a. HasTheCommonCharacteristicsOfIntAndString a => MyType a
15:18:07 <jmcarthur> koeien37: that is my fear too
15:18:08 <eu-prleu-peupeu> an haskell friend, that is
15:18:48 <HaskellLove> print . map (map read . words) . lines =<< readFile "/home/user/Desktop/triangle.txt"     [[*** Exception: Prelude.read: no parse
15:18:57 <jmcarthur> it would rely on some intelligence in the compiler which would be simple to explain but difficult to reason about
15:19:09 <Cale> I also think you could make this work -- some kind of disambiguation of constructors based on types. But my sense is that it'll usually be ambiguous, and you'll end up writing explicit type signatures at which point you might as well have named the constructors different things.
15:19:17 <koeien37> HaskellLove: add a type sig, it may default to something silly
15:19:50 <Cale> HaskellLove: oh, right, it doesn't know what type to read
15:19:56 <twanvl> we can already get close with type classes and view patterns, it just lacks syntactic sugar
15:20:07 <koeien37> data X = X Integer | X Int.   f (X a) = show a; f (X a) = show (a + 1) -- what the hell?
15:20:27 <Cale> Btw, we are heading toward my version of the program that I know you're writing just from this piece.
15:20:52 <eu-prleu-peupeu> ok, now everything compiles fine, with diff names
15:20:59 <Cale> main = print . solve . map (map read . words) . lines =<< getContents
15:20:59 <Cale> insert v (s,xs) = (v+s,v:xs)
15:20:59 <Cale> layer vs maxpaths = zipWith insert vs (zipWith max maxpaths (tail maxpaths))
15:20:59 <Cale> solve = foldr layer (repeat (0,[]))
15:21:11 <jmcarthur> Cale is spoiling the fun.
15:21:31 <koeien37> maximal walk in a triangle?
15:21:32 <copumpkin> that's what Cale always does :(
15:21:44 <Cale> jmcarthur: I explained this program in detail to him a couple weeks ago
15:21:45 <monochrom> It saves everyone time.
15:21:50 <jmcarthur> oh
15:21:58 <copumpkin> oh it's eu-prleu-peupeu
15:22:08 <koeien37> no HaskellLove
15:22:09 <jmcarthur> copumpkin: no, HaskellLove
15:22:21 <copumpkin> oh I meant eu-prleu-peupeu is here
15:22:22 <Cale> I even drew diagrams :)  http://cale.yi.org/share/triangle-eval.png
15:22:35 <koeien37> zomg
15:22:39 <copumpkin> it's always a time of celebration when eu-prleu-peupeu is here
15:22:43 <HaskellLove> hey Cale I just solved that one :)
15:23:30 <twanvl> class My a where { fromMy :: MyType -> Maybe a }
15:23:30 <twanvl> f (fromMy -> Just x) = x ++ " is a string"
15:23:30 <twanvl> f (fromMy -> Just x) = show (x + 1 :: Int)
15:23:57 <xerox> view patterns!
15:24:11 <eu-prleu-peupeu> copumpkin: thats because eu-prleu-peupeu is a great person
15:24:20 <eu-prleu-peupeu> he even talks in the 3rd person
15:24:22 <copumpkin> has he learned haskell yet?
15:24:34 <eu-prleu-peupeu> he is walking the path to enlightment
15:25:10 <copumpkin> it is a long path indeed!
15:25:16 * Cale is only walking the path to ensconcement
15:25:16 <jmcarthur> apparently
15:25:19 <alexyk> how do I keep ghci prompt short even when I add :module +... ?
15:25:23 <koeien37> well, at least we can compute the maximal path now
15:25:32 <copumpkin> whois alexyk
15:25:33 <koeien37> :set prompt haskell_is_awesome
15:25:42 <copumpkin> alexyk: it's alexy!
15:25:45 <eu-prleu-peupeu> ensconcement ?
15:26:07 <alexyk> copumpkin: still haskelling? :)
15:26:13 <copumpkin> alexyk: furiously!
15:26:18 * Cale uses  :set prompt "ghci> "
15:26:29 <eu-prleu-peupeu> my purpose as a computer guy is to make haskell known as a programming language
15:26:39 <copumpkin> alexyk: I'm almost a master now, just need to gain familiarity with the zygohistomorphic prepromorphism now
15:26:43 <koeien37> i have a ~/.ghci.hs with some interesting definitions
15:26:48 <alexyk> copumpkin: awesome, then I'll ask you for some tips in person :)
15:26:51 <kmc_> i think it's well known now, but mostly by a set of misconceptions
15:26:56 <kmc_> you should work on clearing those up
15:27:03 <eu-prleu-peupeu> how long have you guys been haskelling ?
15:27:07 <Cale> NOOOOOO! IT IS AM SEKRIT! YOU RUIN EVARYTHING!
15:27:12 <alexyk> I've finally decided to give this unwieldy haskell thing a spin
15:27:13 <copumpkin> alexyk: what brings you back to haskell-land? :) did you find The One True Way?
15:27:17 <copumpkin> hah :)
15:27:24 <koeien37> two years on and off, I think
15:27:26 <copumpkin> eu-prleu-peupeu: just over a year now
15:27:31 <kmc_> 4 years
15:27:36 <alexyk> and it looks like it's OCaml with monads, with the latter just clunky tags you jump over with liftM
15:27:37 <koeien37> I'm not a full time haskell programmer
15:27:52 <copumpkin> koeien: only 37 hours a week?
15:27:53 <kmc_> no, monads are not tags
15:28:03 <eu-prleu-peupeu> im in haskell for a 14months now, but im a dumbass
15:28:06 <idnar> monads are like onions
15:28:07 <copumpkin> monads are monoid objects in the category of endofunctors
15:28:14 <kmc_> and the biggest differences between Haskell and OCaml have nothing to do with monads
15:28:15 <eu-prleu-peupeu> and i only code it when the king makes his birthday
15:28:22 <Cale> alexyk: Are lists just clunky tags that you jump over with map?
15:28:24 <koeien37> copumpkin: heh, no, < 2 hours on average per week I think. although i hang out here sometimes
15:28:25 <alexyk> kmc: I know, I just syntactically perceive it that way.  An olympic sport where folks jump over barriers.
15:28:28 <HaskellLove> map (map (read::String->Int) . words) . lines =<< readFile "/home/user/Desktop/triangle.txt" Cale why does not this work, and when i put print at start of code it works? i want to put this in a variable. that is value...
15:28:38 <idnar> Cale: yes!
15:28:41 <koeien37> `liftM`
15:28:44 <kmc_> alexyk, right, but once you learn more you'll abandon that view
15:28:52 <koeien37> >>= combines two IO actions
15:29:01 <koeien37> or put a 'return .' in front
15:29:02 <Cale> HaskellLove: Because the thing on the left doesn't produce an action
15:29:03 <alexyk> copumpkin: my True Way is Clojure these days.  Maps are first-class syntax members
15:29:13 <kmc_> why is special syntax a good thing?
15:29:15 <alexyk> and syntax is plain ()
15:29:26 <alexyk> no $, ., and other @#%s
15:29:27 <koeien37> that seems awful
15:29:28 <kmc_> don't we want to describe as many features as possible with the same syntax?
15:29:36 <eu-prleu-peupeu> Clojure is heresy
15:29:41 <kmc_> that's part of the power of monads, it lets you overload this one "do" notation for all kinds of useful stuff
15:29:46 <koeien37> i would prefer overriding ($) or whitespace over giving maps special status
15:29:49 <kmc_> parsers, exceptions, IO, logic programming, STM
15:29:58 <koeien37> sounds like Haskell!
15:30:00 <Cale> and write polymorphic functions which work in all those settings
15:30:07 <copumpkin> no language wars in #haskell! :D
15:30:08 <kmc_> monads aren't just a way to express IO, they're a way to invent and express new "computational modes" without defining new syntax
15:30:11 <Cale> don't forget lists and functions!
15:30:12 * copumpkin goes and makes some taters
15:30:15 <eu-prleu-peupeu> ah ok
15:30:18 <kmc_> in cases where nearly every other language has special syntax
15:30:18 <eu-prleu-peupeu> sorry
15:30:26 <kmc_> imagine defining "try" as a regular function in C++
15:30:28 <kmc_> better yet, don't
15:30:29 <Cale> > sequence [id, reverse, map toUpper] "hello"
15:30:31 <lambdabot>   ["hello","olleh","HELLO"]
15:30:38 <koeien37> > sequence "hello"
15:30:39 <lambdabot>   Couldn't match expected type `m a'
15:30:39 <lambdabot>         against inferred type `GHC.Types...
15:30:47 <Cale> > sequence [[1,2,3],[4,5],[6,7,8]]
15:30:49 <lambdabot>   [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2...
15:30:55 <koeien37> > sequence ["hello"]
15:30:56 <lambdabot>   ["h","e","l","l","o"]
15:31:00 <koeien37> -- ^ i meant that
15:31:07 * jmcarthur has been haskelling for... about 3 years i guess
15:31:11 <Cale> sequence is also the concatenation of parsers, and the sequential composition of IO actions
15:31:19 <Ke> is there an easy to way to flip 2. and 3. argument
15:31:20 <HaskellLove> koeien37 return converts the IO into? hoogle explanation does not mean much to me now "Inject a value into the monadic type.
15:31:22 <HaskellLove> "
15:31:37 <koeien37> return 3 is an IO action that, when performed, returns a 3
15:31:50 <copumpkin> omnom
15:32:09 <kmc_> i prefer to say "produces" or "yields" a 3, as i think "return" is what functions do
15:32:12 <koeien37> similarly, return . map whateverYouHad $ x   is an IO action that, when performed, returns the list
15:32:27 <koeien37> 'yields' is clearer, yes, thanks
15:32:49 <Cale> kmc_: We use the exact opposite terminology
15:32:50 <sproingie> 'yield' would have been a much better choice of term than 'return'
15:33:02 <koeien37> what's wrong with "pure" or "inject"
15:33:02 <Cale> kmc_: Functions produce or yield, actions return :)
15:33:06 <kmc_> heh
15:33:13 <pikhq> Evaluation yields.
15:33:13 <sproingie> in the list monad it even has the generator connotation
15:33:13 <kmc_> well, "produce" is sort of co-recursive
15:33:16 <pikhq> :)
15:33:18 <kmc_> fair enough
15:33:21 <monochrom> This is just a meaningless word game.
15:33:28 <koeien37> I don't really like the name "return"
15:33:31 <c_wraith> withFile is not nearly as handy of a function as I'd hoped.  If only h* functions took the handle as the last argument
15:33:32 <sproingie> language is a word game
15:33:33 <kmc_> i mostly just want to use different words for the two
15:33:36 <HaskellLove> koeien37 i need to store that as a list not just use return and output it, how to do it?
15:33:45 <Cale> monochrom: What isn't? :)
15:33:46 <koeien37> x <- return ....
15:33:49 <osfameron> though 'yield' is overloaded too
15:33:51 <kmc_> because it's really important, and really hard for beginners, to separate conceptually functions from the monadic actions their functions return
15:33:56 <kmc_> i think "pure" is a fine name
15:34:00 <kmc_> well, no it's not
15:34:00 <kmc_> sigh
15:34:04 <monochrom> You would learn more and faster with an unambiguous symbol game than this wishy willy word game.
15:34:05 <koeien37> 'inject' ?
15:34:06 * Cale decides to adopt an ultra-formal nihilist perspective.
15:34:07 <osfameron> what does 'pure' even mean?
15:34:08 <jmcarthur> point
15:34:09 <kmc_> too many connotations on everything
15:34:19 <kmc_> let's rename "monads" to "workflows" like F# did
15:34:25 <kmc_> (>>=) can be renamed workflowFacilitate
15:34:33 <Cale> haha
15:34:36 <jmcarthur> ugh
15:34:44 <Cale> and "do" can become "implementationPhase"
15:34:45 <kmc_> return can be named utilizeCoreCompetency
15:34:50 <kmc_> hehe
15:34:56 <koeien37> what's wrong with names from mathematics?
15:35:00 * jmcarthur is tempted to translate some monadic code this way
15:35:05 * koeien37 likes the names Functor, Monad and so on
15:35:09 <jmcarthur> koeien37: nothing!
15:35:10 <Cale> koeien37: Oh, you'd like return = eta ?
15:35:14 <copumpkin> hell yeah
15:35:15 <kmc_> hehe
15:35:18 <koeien37> Cale: sure.
15:35:20 <copumpkin> actually need the symbols
15:35:21 <Cale> I wouldn't mind it.
15:35:23 <koeien37> but then in symbols ;)
15:35:25 <Cale> η
15:35:36 <copumpkin> ζ
15:35:40 <copumpkin> mmm
15:35:41 <copumpkin> so purty
15:35:47 <kmc_> > let η = return in η 3 :: [Int]
15:35:48 <lambdabot>   [3]
15:35:52 <jmcarthur> dangit screen
15:35:59 <kmc_> oh here we go again
15:36:02 <c_wraith> @let η = return
15:36:03 <lambdabot>  Defined.
15:36:08 <koeien37> now the join too
15:36:18 <Cale> μ (IO putStrLn getLine)
15:36:46 <koeien37> I guess that's a decent way to avoid success, though
15:36:55 <jmcarthur> that's what we want!
15:36:59 <HaskellLove> koeien37 this does not work. tri <- return . map (map (read::String->Int) . words) . lines =<< readFile "/home/user/Desktop/triangle.txt" Will I have to use comprehension list?
15:37:01 <jmcarthur> we are catering to success too much
15:37:04 <koeien37> sure. at all costs
15:37:20 <jmcarthur> i'm not actually joking, either
15:37:23 <koeien37> more specifically?
15:37:34 <jmcarthur> HaskellLove: you never have to
15:37:37 <koeien37> jmcarthur: well, we should fork Haskell into something else, and go on :)
15:37:46 <jmcarthur> koeien37: i'm working on alt-stdlib ;)
15:37:48 <HaskellLove> jmcarthur how come?
15:37:50 <copumpkin> agdskell
15:37:58 <copumpkin> hagda?
15:38:05 <koeien37> I'm not sure about dependent types
15:38:05 <Cale> Let's add wait loops between evaluation steps in GHC-compiled executables which can only be removed via secret passwords given while compiling
15:38:18 <jmcarthur> koeien37: the thought had come to mind to fork the language before, but that's more work than i care to try for right now
15:38:24 <copumpkin> koeien37: me neither, but they sure are fun
15:38:34 <pikhq> Cale: Let's be a superset of APL.
15:38:43 <jmcarthur> koeien37: i'm content with a few extensions to support a new library
15:38:57 <pikhq> Oh, also, screw "Integer".
15:39:00 <HaskellLove> that did not work either koeien37?
15:39:01 <pikhq> That's ℤ.
15:39:27 <copumpkin> hell yeah
15:39:32 <koeien37> true
15:39:34 <Cale> Drop floating point support in favour of computable reals only.
15:39:38 <koeien37> but is ℤ a capital?
15:39:47 <Cale> Looks capital to me.
15:39:50 <koeien37> Cale: why?
15:39:51 <jmcarthur> i assume the ? i'm seeing is a fancy Z?
15:39:54 <copumpkin> this is why you need arbitrary symbols
15:39:57 <koeien37> Cale: yes, but is it considered a capital?
15:39:58 <copumpkin> à la agda
15:40:01 <koeien37> jmcarthur: \mathbb{Z} yes
15:40:05 <pikhq> jmcarthur: Yes.
15:40:05 <Cale> koeien37: It makes the language less useful for real work
15:40:14 <Cale> koeien37: which should help us avoid success
15:40:30 <monochrom> > isUpper 'ℤ'
15:40:31 <lambdabot>   True
15:40:35 <monochrom> \o/
15:40:42 <jmcarthur> yes!
15:40:47 <koeien37> not having a compiler helps, too
15:40:56 <HaskellLove> Cale how to put file contents in a value? tri = return . map (map (read::String->Int) . words) . lines =<< readFile "/home/user/Desktop/triangle.txt" that does not work neither the comprehension list way
15:40:58 <Cale> > isUpper 'ℵ'
15:40:59 <lambdabot>   False
15:41:35 <kisvoros> hello
15:41:36 <Cale> HaskellLove: do x <- fmap (map (map (read::String->Int) . words) . lines) (readFile "/home/user/Desktop/triangle.txt")
15:41:45 <Cale> HaskellLove: and then use x on the next line
15:41:57 <pikhq> We could avoid success even better by removing the IO type.
15:42:05 <pikhq> And add no replacement.
15:42:09 <koeien37> make sure your indenting is correct. start the next line in the same column as the 'x'
15:42:18 <koeien37> maybe a more fine-grained IO
15:42:18 <monochrom> I agree that lacking a compiler helps. I add that lacking an interpreter and a REPL also helps. \o/
15:42:37 <Cale> HaskellLove: Or just  do cs <- readFile "/home/user/Desktop/triangle.txt"; let tri = map (map (read::String->Int) . words) . lines $ cs; print tri
15:42:43 <koeien37> not having instance Eq Double and instance Eq CReal is better imo
15:43:46 <koeien37> type IO = NotAbleToLaunchNuclearMissilesButAbleToReadFiles
15:43:49 <monochrom> And oh, delete all tutorials and wikibooks.
15:43:58 <koeien37> monochrom: even the monad tutorials? *sniff*
15:44:18 <jmcarthur> i'd rather just not care about success than avoid it
15:44:41 <jmcarthur> but that's still a bit different than what it seems our focus has been the last few years
15:44:43 <pikhq> Oh, heck. Just remove all the *instances* for all the typeclasses.
15:44:53 * idnar continues bashing his intuition against Kan extensions
15:44:58 <jmcarthur> pikhq: who needs a standard library? not us!
15:45:06 <koeien37> jmcarthur: success is a mixed blessing
15:45:43 <pikhq> jmcarthur: Oh, we'd still have a standard library.
15:45:57 <jmcarthur> pikhq: category-extras?
15:46:32 <pikhq> jmcarthur: Imagine: all the numerical functions take Num. And no instances of Num.
15:46:53 <koeien37> why not implement ℤ somewhere?
15:47:07 <pikhq> koeien37: Oh, it'd be implemented.
15:47:13 <koeien37> of do we leave N, Z, and so on as an exercise for the reader?
15:47:14 <pikhq> Just not as an instance of Num.
15:47:15 <HaskellLove> Cale i get incorect indentation errors am i suposed to put the do on separate line and all below it?
15:48:10 <koeien37> no, you are supposed to start each line in the do-block in the same column
15:49:17 <Ke> :t Data.PurePriorityQueue.insert
15:49:18 <lambdabot> Couldn't find qualified module.
15:49:20 <HaskellLove> well i do
15:49:39 <koeien37> then you should paste your code
15:49:45 <monochrom> HaskellLove: If I see it on a pastebin I'll fix it.
15:49:47 <c_wraith> HaskellLove: that includes the *first* line, which you may be starting on the same line as the do is on
15:50:04 <c_wraith> HaskellLove: in which case you need to line up with the first token after the do
15:50:46 <HaskellLove> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15674#a15674
15:50:50 <c_wraith> HaskellLove: in fact, lines need to line up with the first non-whitespace token after the do, no matter what.  (it also has to be indented at least as far as the do)
15:51:16 <c_wraith> HaskellLove: and don't use semicolons when you're using layout
15:51:28 <c_wraith> HaskellLove: semicolons are for one-liners
15:52:04 <HaskellLove> so what is wrong with the code
15:52:13 <c_wraith> it has semicolons.
15:52:18 <c_wraith> that's breaking the layout rules
15:52:29 <c_wraith> didn't I just say that?
15:52:29 <kmc_> shouldn't that just generate extra semis?
15:52:38 <kmc_> > do { x <- "abc"; ; ; return x }
15:52:39 <lambdabot>   "abc"
15:52:44 <c_wraith> it might also be indented too far
15:52:45 <jmcarthur> yeah i would think it should be legal
15:52:48 <flaarg> im trying to install lambdabot on a debian testing/sid blend and I am having issues with the base dependency I have 3something installed and it wont let me upgrade to 4, which lamdbabot wants
15:52:51 <c_wraith> which is a fun new one. :)
15:53:16 <c_wraith> HaskellLove: why aren't you using something that does indenting for you, like haskell-mode in emacs?
15:53:35 <HaskellLove> c_wraith not really  i removed them and still same error indentation
15:53:35 <jmcarthur> well, it doesn't do it *for* you
15:53:39 <monochrom> HaskellLove: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15674#a15675  compiles without error
15:54:24 <c_wraith> jmcarthur: with the number of indentation problems HaskellLove has, it can only be an improvement, regardless
15:55:01 <monochrom> People, see my paste, I think I nailed it. And you'll laugh.
15:57:15 <eu-prleu-peupeu> one day haskell programming language will be famous, and lots of programmers are going to write code for it
15:57:21 <HaskellLove> monochrom it compiles without error here to but does not run I get: /home/user/Desktop/triangle.txt: openFile: does not exist (No such file or directory) wierd stuff
15:57:49 <koeien37> then the file does not exist.
15:57:54 <monochrom> That is not something we can help. It relies on files you own.
15:58:09 <kmc_> jesus fucking christ
15:58:20 <eu-prleu-peupeu> and then, big companies will fight to death to see which of them gets to register modules with basic names
15:58:21 * monochrom resists suggesting "give us root access so we can ssh in and fix..."
15:58:43 <HaskellLove> koeien37 but it compiled without errors
15:59:01 <Drunkenmonkey> kmc_: are you trying to say that jesus is masturbating?
15:59:03 <koeien37> the compiler doesn't know about your file system
15:59:06 <monochrom> What is inside your file /home/user/Desktop/triangle.txt ?
15:59:21 <kmc_> Drunkenmonkey, seems likely that it happened at one point or another
15:59:28 <koeien37> you try to open a nonexistent file. HOw can the compiler ever know that, when your program is run, that file exists?
15:59:29 <HaskellLove> euler 67 text file which is a huge list of lists
15:59:46 <HaskellLove> http://projecteuler.net/project/triangle.txt
15:59:55 <monochrom> Are you sure /home/user/Desktop is where you have saved it?
16:00:14 <monochrom> I for one suspects the "user" part. You wouldn't just call yourself "user" would you?
16:00:15 <copumpkin> yay triangle
16:01:06 <Ke> yay, my first stack overflow
16:01:09 <meanburrito920_> eu-prleu-peupeu: i hope not, because that would probably negatively influence the haskell community...
16:01:28 <HaskellLove> monochrom all is fine yes... no i just hide my name with "user"
16:02:01 <HaskellLove> Ke I remember mine, it was so sweet, the sun was shining and...
16:02:07 <monochrom> Then modify my version until the filename is right.
16:02:17 <monochrom> Or the whole pathname is right.
16:02:29 <eu-prleu-peupeu> hackage will be littered with all kinds of names... and it will be war
16:02:29 <eu-prleu-peupeu> children and little animals will die
16:02:45 <kmc_> i like that this channel is reduced to the level of "is your monitor on? is the mouse plugged in?"
16:02:48 <copumpkin> can I kill the kittens and the baby seals?
16:02:55 <sproingie> eu-prleu-peupeu: do you have anything of value to add?
16:03:01 --- mode: ChanServ set +o monochrom
16:03:12 <eu-prleu-peupeu> sproingie: save the baby seals ?
16:03:23 <sproingie> there's your answer fishbulb
16:03:33 <jmcarthur> i honestly wouldn't have minded if we had a convention to have modules be in a namespace with the vendor's name
16:03:44 <sproingie> i think cpan does all right without it
16:03:45 <jmcarthur> Galois.Foo.Bar, for example
16:03:48 <kmc_> like Java!
16:03:52 <sproingie> what's my vendor?
16:03:53 --- mode: monochrom set +b *!n=Hugo_Gom@*
16:03:53 <kmc_> com.galois.foo.bar
16:03:56 <koeien37> com.galois....
16:03:59 <kmc_> org.haskell.Data.Maybe
16:04:05 <jmcarthur> what's with the com. stuff, anyway?
16:04:06 <xerox> aha
16:04:12 <kmc_> it's a reverse domain name
16:04:13 <koeien37> "commercial", I'd suppose
16:04:14 <xerox> it's like the domain name system
16:04:14 <sproingie> Sproingie.Foo.Bar?  what does Sproingie have to do with the function of the module?
16:04:18 <jmcarthur> ah
16:04:19 <xerox> which actually works like that
16:04:23 <copumpkin> so much for eu-prleu-prpeu
16:04:24 <kmc_> it *is* the domain name system.  you're supposed to use a domain you own
16:04:34 --- mode: monochrom set -o monochrom
16:04:38 <koeien37> ok. I didn't realize that
16:04:46 <jmcarthur> sproingie: not much, but it means you and i could both create modules with the same name without clashing
16:04:57 <sproingie> ok, net.fishbulb.Foo.Bar?  again, i don't see the merit of that in an import statement
16:05:03 <xerox> actually the dns also has a root '.' so it's .com.google.www
16:05:10 <kmc_> imo it belongs more at the level of packages than modules
16:05:14 <sproingie> CPAN seems to get alone
16:05:17 <kmc_> import "fishbulb.net" Foo.Bar
16:05:18 <sproingie> er get along without
16:05:24 <jmcarthur> kmc_: yeah. actually we have a way to distinguish packages i guess
16:05:32 <xerox> kmc_ that one can be done, I think it was from alexj
16:05:35 <idnar> xerox: but the dot is redundant, which is why you can leave it out everywhere :P
16:05:37 <sproingie> yah that works pretty well
16:05:42 <kmc_> import "v4-2.base.hackage.haskell.org" Data.Maybe
16:05:47 <xerox> what was it called...
16:05:51 <ColonelJ> :t count
16:05:52 <lambdabot> Not in scope: `count'
16:05:53 <sproingie> kmc_: i like the cut of your jib
16:05:56 <jmcarthur> the only issue with that is packages sharing a name
16:06:04 <xerox> Saizan do you remember?
16:06:12 <jmcarthur> which i guess will only tend to happen if one or both are not on hackage
16:06:14 <koeien37> jmcarthur: well, *something* should identify them
16:07:32 <Saizan> xerox: what?
16:07:35 <HaskellLove> monochrom the problem might have been in me removing main and i recalled do needs main so all fine now... euler 67 solved wohooo
16:07:43 <xerox> Saizan that tool that automatically downloaded imports..
16:07:53 <koeien37> do doesn't need main
16:08:01 <ColonelJ> , let count n = n : count n+1 in takeWhile (< 10) (count 1)
16:08:02 <lunabot>  luna: No instance for (GHC.Num.Num [a])
16:08:05 <koeien37> > do { x <- [1,2,3]; y <- [1,2]; return (x*y) }
16:08:06 <lambdabot>   [1,2,2,4,3,6]
16:08:31 <koeien37> > iterate (+1) 0 -- this?
16:08:32 <ColonelJ> what's wrong with takeWhile?
16:08:32 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
16:08:38 <monochrom> HaskellLove: Yes, you were missing "main = ".
16:08:41 <koeien37> > [0..]
16:08:42 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
16:08:43 <alexyk> how do you enter multi-line function definitions with type signature in ghci?
16:08:55 <ColonelJ> > takeWhile (< 10) [0..]
16:08:56 <lambdabot>   [0,1,2,3,4,5,6,7,8,9]
16:09:13 <koeien37> ColonelJ: in your first example,    n: count n + 1  is (n: (count n)) + 1
16:09:25 <Veinor> alexyk: I think ; is a substitute for \n
16:09:28 <koeien37> so you tried to add 1 to a list. That's impossible
16:09:29 <HaskellLove> koeien37 you must have main man, i remember reading about it in a book but not using it much i forgot it
16:09:45 <monochrom> \o/
16:09:46 <koeien37> HaskellLove: I misunderstood your question.
16:09:47 <ColonelJ> koeien37: ah, well I didn't get any error for the definition
16:09:54 <Saizan> xerox: http://searchpath.org/
16:10:00 <xerox> Right! That one.
16:10:05 <koeien37> ColonelJ: no. You could, in theory, add 1 to lists
16:10:08 <xerox> Thank you.
16:10:18 <koeien37> if you give an instance Num [a]
16:10:23 <xerox> kmc_ searchpath does something like what you described :)
16:10:23 <ColonelJ> koeien37: well I think that's what Num [a]  is
16:10:26 <koeien37> that's why Haskell won't complain
16:10:30 <koeien37> (initially)
16:10:54 <ColonelJ> also is $ the same as putting brackets round everything until the end
16:10:54 <koeien37> > "hai wereld" + 1
16:10:56 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
16:10:56 <lambdabot>    arising from the literal ...
16:11:01 <alexyk> Veinor: complains on ; mashed to the preceding char...
16:11:05 <koeien37> ColonelJ: yep.
16:11:06 <aavogt> alexyk: :{\n something \n:} is something for multilines in ghci, but I'm not sure you can write type signatures as you want there...
16:11:27 <ezyang> Hey guys, I'm trying to figure out what 'data ScriptElem p where SE :: p a -> a -> ScriptElem p' means?
16:11:28 <kmc_> you can use type sigs in let
16:11:34 <alexyk> well if I enter only teh type sig, it complains it wants a binding for it
16:11:35 <kmc_> ezyang, that's a GADT style type declaration
16:11:41 <ColonelJ> @hoogle powerMod
16:11:41 <ezyang> p seems to simultaneously have kind * -> * and *?
16:11:41 <lambdabot> No results found
16:11:50 <koeien37> ezyang: it means data ScriptElem = SE (p a) a  in GADT syntax
16:11:51 <ColonelJ> @hoogle modexp
16:11:52 <lambdabot> No results found
16:12:00 <ColonelJ> @hoogle expmod
16:12:00 <lambdabot> No results found
16:12:07 <kmc_> ezyang, it has kind * -> *
16:12:17 <kmc_> because (p a) is used as a type in (p a -> a -> ScriptElem p)
16:12:24 <kmc_> ScriptElem has kind (* -> *) -> *
16:12:30 <kmc_> hence p is an appropriate type argument
16:12:40 <ezyang> Ohhh!
16:13:17 <koeien37> I missed a 'p' there, but you see it now :)
16:13:45 <ColonelJ> @hoogle binomial
16:13:45 <lambdabot> No results found
16:13:51 <kmc_> a is existential, i guess
16:13:53 <ezyang> That's... really weird. I didn't know that was legal
16:13:58 <ColonelJ> @hoogle combination
16:13:58 <lambdabot> No results found
16:14:03 <kmc_> ezyang, which? higher-kinded type parameters?
16:14:04 <koeien37> ezyang: look up GADT's
16:14:09 <kmc_> it's  common with type classes, e.g. Monad
16:14:15 <kmc_> less common with types, but still valid
16:14:21 <ezyang> kmc_: Types
16:14:31 <ezyang> Yeah, I think that's where I'm getting confused
16:14:59 <kmc_> :k WrappedMonad
16:15:01 <lambdabot> (* -> *) -> * -> *
16:15:07 <jmcarthur> newtype ScriptElem p = SE (forall a . (p a, a))
16:15:31 <koeien37> well, it's a data, isn't it?
16:15:34 <jmcarthur> not equivalent, but i think clearer
16:15:38 <kmc_> jmcarthur, that's not existential
16:15:41 <kmc_> i think the GADT one is?
16:15:42 <jmcarthur> no
16:15:46 <jmcarthur> i think so
16:15:56 <jmcarthur> is there that much of a difference in that sense, though?
16:16:10 <kmc_> yes
16:16:17 <kmc_> with yours, the arg to SE has to be polymorphic in a
16:16:30 <jmcarthur> oh, and with existential it's *some* a
16:16:44 <copumpkin> damn right
16:17:01 * ezyang is more confused than before 
16:17:01 <jmcarthur> existential is weird
16:17:08 <ezyang> What should I read
16:17:12 <jmcarthur> not very haskelly, to me
16:17:12 <kmc_> data Foo m where { bar :: m a -> Foo m }
16:17:23 <kmc_> Bar (Just 'x') and Bar (Just 6) both have type Foo Maybe
16:17:25 <copumpkin> jmcarthur: you mean the sensitivity to the placement of the forall?
16:17:36 <augur> copumpkin!
16:17:44 <copumpkin> :O
16:17:57 <augur> heyo.
16:18:02 <jmcarthur> copumpkin: no, i mean the fact that you can have a value with completely unknown type even though it isn't polymorphic
16:18:13 <copumpkin> jmcarthur: I guess, yeah
16:18:17 <copumpkin> augur: yohe!
16:18:21 <kmc_> it's not unknown
16:18:32 <ezyang> kmc_: reading your example carefully
16:18:33 <kmc_> when you pattern match on an existential constructor, the resulting type is indeed polymorphic
16:18:49 <augur> copumpkin: how you been ey
16:19:08 <kmc_> an existential type is like a dependent pair type
16:19:18 <kmc_> but that may not be a helpful statement :)
16:19:20 <copumpkin> augur: pretty good, exhausted from a day of travel
16:19:34 <augur> travel where from?
16:19:36 <alexyk> lambdabot:  let f :: [Int] -> Maybe Int; f (x:xs) = Just x; f _ = Nothing
16:19:37 <augur> and whereto?
16:19:50 <ezyang> Aha. Ok, so I see where it goes until I find out the type of the expressing is Foo Maybe
16:19:54 <jmcarthur> kmc_: it's a different kind of polymorphism though
16:20:02 <alexyk> so let allows for typesig and ; for multiliners in ghci
16:20:05 <kmc_> btw, i typoed "bar", meant "Bar"
16:20:10 * ezyang nods 
16:20:21 <copumpkin> augur: rome to NH :) I doubt #haskell really cares about my travel, but you should come to #haskell-blah :)
16:20:55 <kmc_> jmcarthur, i don't see how.  getting an existential type as an arg is much like getting a polymorphic type as an arg (as with rank-N types)
16:20:57 <ezyang> What kind is Foo Maybe?
16:21:01 <kmc_> *
16:21:06 <kmc_> because it has values
16:21:09 <roconnor> ezyang: what's the kind of Foo?
16:21:11 <kmc_> e.g. Bar (Just 'x')
16:21:18 <ezyang> (* -> *) -> *, I guess...
16:21:26 <kmc_> Foo :: (* -> *) -> *
16:21:28 <roconnor> then the kind of Foo Maybe is *
16:21:30 <kmc_> therefore Foo Maybe :: *
16:21:31 <ezyang> ooooh
16:21:37 <kmc_> any type that has values has kind *
16:21:40 <Ke> so how can I tell where the stack overflow occurs
16:21:51 <kmc_> in fact some people reserve the word "type" for such expressions only
16:21:54 <roconnor> Ke: in foldl
16:21:54 <kmc_> Ke, ghci debugger perhaps
16:21:57 <Ke> besides looking at the code
16:21:57 <koeien37> I do.
16:22:04 <koeien37> types are of kind *, otherwise it's a type constructor
16:22:16 <koeien37> but I'm more than willing to change this if it's nonstandard terminology
16:22:31 <kmc_> it's unfortunately terminology where there is no standard, i think
16:22:44 <kmc_> e.g. people used to say "type class" and "constructor class" but this seems to be rare nowadays
16:22:46 <jmcarthur> kmc_: data Foo = forall a . Foo (a -> a). the function wrapped by Foo needn't be id, right?
16:22:54 <Ke> roconnor: that's what I actually thought, though it's only a lazy array of 2 elements (from getContents)
16:22:56 <kmc_> correct
16:22:59 <jmcarthur> kmc_: it could be (+1) or something, no?
16:23:00 <koeien37> jmcarthur: no
16:23:10 <koeien37> jmcarthur: may be Foo ((+1) :: Integer->Integer)
16:23:12 <ezyang> WHOA!
16:23:22 <jmcarthur> kmc_: so i can't just get it out and apply it to whatever i want
16:23:30 <koeien37> only to values of type forall a. a
16:23:34 <ezyang> so, does Bar, like, lose information about a?
16:23:36 <koeien37> which is nothing
16:23:39 <jmcarthur> ezyang: yes
16:23:40 <koeien37> undefined only
16:23:43 <ezyang> Aha!
16:23:43 <kmc_> ezyang, it wraps up and hides the information
16:23:53 <jmcarthur> ezyang: i think it's mainly useful if you also include a type class constraint
16:23:57 <kmc_> typically, you wrap a few types in relation to each other, or in relation to a typeclass
16:23:58 <ezyang> kmc_: That implies I can get it out again?
16:24:01 <koeien37> I've used it as   data Showable = forall a. (Show a) => a
16:24:05 <jmcarthur> ezyang: since otherwise there is very little you can do with it
16:24:10 <ezyang> right-o
16:24:14 <copumpkin> ezyang: only partially get it out again
16:24:17 <koeien37> or a pair
16:24:17 <kmc_> data Showable = forall a. (a, a -> String)
16:24:25 <koeien37> data X = forall a. X a (a -> Int)
16:24:26 <kmc_> enforces that the only thing you can do with this value is show it
16:24:28 <kmc_> yes
16:24:51 <kmc_> jmcarthur, yeah, you're right about existential args being different from rank-n polymorphic args
16:25:05 <kmc_> it sort of floats the forall back out to positive positions
16:25:22 <ezyang> So, in my original example
16:25:24 <kmc_> because (Foo -> ()) is like forall a. (a -> a) -> () and not (forall a. a -> a) -> ()
16:25:25 <ezyang> I don't see any typeclass
16:25:32 <jmcarthur> right
16:25:54 <jmcarthur> ezyang: you can't really do much useful with a, but depending on what p is there might still be something you can do with it
16:26:02 <jmcarthur> with (p a), i mean
16:26:06 <jmcarthur> since you know what it is
16:26:11 <meanburrito920_> urg.... darcs.haskell.org is /slow/
16:26:20 <ezyang> the example that I'm looking at, btw, is http://www.mail-archive.com/haskell-cafe@haskell.org/msg33040.html
16:26:38 <ezyang> p is used as GameChoice, which is a GADT
16:27:36 <ColonelJ> let cake = true ; bla true = false | bla _ = true in cake
16:27:39 <ColonelJ> , let cake = true ; bla true = false | bla _ = true in cake
16:27:40 <lunabot>  luna: parse error on input `|'
16:27:45 <ColonelJ> , let cake = true ; bla true = false ; bla _ = true in cake
16:27:45 <jmcarthur> ezyang: i could imagine a case where p contains some functions that work on a, then you could apply one of those to the lone a argument
16:27:46 <lunabot>  luna: Not in scope: `true'
16:27:54 <jmcarthur> ezyang: since you know they share a common type
16:27:59 <ColonelJ> , let cake = True ; bla True = False ; bla _ = True in cake
16:28:01 <lunabot>  True
16:28:01 <ezyang> hmm
16:28:08 <ezyang> that actually sounds like exactly what's going on here
16:28:09 <ColonelJ> , let cake = True ; bla True = False ; bla _ = True in bla cake
16:28:10 <lunabot>  False
16:28:49 <jmcarthur> ezyang: this would be similar to the case of including type classes, except you can pass in functions at runtime when you construct the (p a) instead of just what a type class gives you at compile time
16:29:11 <ezyang> "including type classes"?
16:29:15 <djahandarie> Man, why is the k-nucleotide test on the shootout benchmarks so slow in Haskell?
16:29:31 <djahandarie> Can't dons go do some fusion magic on it or something? :P
16:29:55 <jmcarthur> ezyang: data Showable = forall a . Show a => Showable a
16:30:00 <jmcarthur> ^^ including a type class
16:30:30 <jmcarthur> ezyang: compare with:  data Showable = forall a . Showable (a -> String) a
16:30:49 <jmcarthur> ezyang: show (Showable show 5) would be a valid construction for the latter version
16:30:57 <jmcarthur> *so (Showable show 5)
16:31:00 <copumpkin> or data Showable = Showable String
16:31:01 * copumpkin coughs
16:31:11 <jmcarthur> copumpkin: of course, but this is a trivial example
16:31:13 <copumpkin> :P
16:31:30 <aavogt> aren't they usually
16:31:43 <jmcarthur> ezyang: it's kind of like an explicit laziness or partial application, sometimes
16:32:47 <copumpkin> data Readable = forall a. Read a => Readable a -- ;)
16:32:48 <jmcarthur> honestly, though, i don't find that i have much use for existentials
16:32:50 <ColonelJ> > let binomial n k = if k <= n `div` 2 then combination n k else combination n (n-k) ; combination _ 0 = 1 ; combination n k = combination n (k-1) * (n-k+1) `div` k in binomial 200 50
16:32:51 <lambdabot>   453858377923246061067441390280868162761998660528
16:33:19 <jmcarthur> copumpkin: i find that kind of disgusting :P
16:33:30 <copumpkin> :)
16:33:48 <copumpkin> how about data Readable = Readable (forall a. Read a => a) -- with ImpredicativePolymorphism
16:34:00 <copumpkin> actually no
16:34:06 <copumpkin> no impredicative polymorphism needed
16:36:32 <c_wraith> @pl \ (ls, b) -> fmap (flip (,) b) ls
16:36:32 <lambdabot> uncurry (flip (fmap . flip (,)))
16:36:37 <ezyang> Ok, I think I want at this point is a small file with some of these declarations to play around with in ghci
16:36:45 <Cale> > let fac n = product [1..n]; binomial n k = fac n `div` (fac k * fac (n-k)) in binomial 200 50
16:36:46 <lambdabot>   453858377923246061067441390280868162761998660528
16:36:47 <copumpkin> c_wraith: strength?
16:36:53 <HaskellLove> I have compiled two files and they calculate now. I compiled a third one but when i run it says permission denied. ghc has some limit how many files it can work on at a time?
16:37:02 <c_wraith> copumpkin: I really have no clue what strength is
16:37:28 <c_wraith> I basically just want to lift a functor in a tuple to contain the whole tuple
16:37:32 <koeien37> @pl \x z -> z * b + x
16:37:33 <lambdabot> (. (b *)) . (+)
16:37:34 <Cale> HaskellLove: no. It sounds like a permissions problem in your filesystem.
16:37:46 <copumpkin> c_wraith: typically it's done in terms of the second of the tuple, but both work
16:37:47 <copumpkin> http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Functor-Strong.html
16:37:54 <copumpkin> :t uncurry (fmap . (,))
16:37:55 <lambdabot> forall a (f :: * -> *) a1. (Functor f) => (a1, f a) -> f (a1, a)
16:38:00 * jmcarthur challenges c_wraith to an arm wrestling match to teach him what strength is
16:38:11 * c_wraith loses all arm wrestling matches. :)
16:38:31 <Cale> HaskellLove: It's not clear what file that message applies to, but maybe there's already an executable or temporary file which is read only?
16:39:03 <c_wraith> so...  this would be uncurry strength?
16:39:12 <c_wraith> well...  uncurry (flip strength)
16:39:29 <copumpkin> not quite
16:39:36 <copumpkin> it's what you wrote earlier
16:39:41 <c_wraith> oh, right
16:39:42 <copumpkin> flip strength will flip your pair
16:39:43 <ColonelJ> ghci keeps getting stuck, how do I get control back
16:39:47 <c_wraith> yeah
16:39:53 <ezyang> Hmm, maybe I'm having trouble because these need RankNTypes
16:39:54 <Cale> ColonelJ: Ctrl-C
16:40:01 <copumpkin> ezyang: probably
16:40:01 <ColonelJ> I did that it didn't work
16:40:09 <copumpkin> ColonelJ: Ctrl--Z
16:40:12 <ezyang> anyway, this fails http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15677#a15677
16:40:12 <ColonelJ> and then it streamed the entire number into the console
16:40:30 <copumpkin> ezyang: oh the readable thing was just me being stupid
16:40:52 <copumpkin> well, you can write it but it's profoundly useless
16:41:00 <jmcarthur> ezyang: and you took a typo i made literally
16:41:07 <ColonelJ> Neither Ctrl-C nor Ctrl-Z work
16:41:14 <ezyang> oh, oops. Rechecking irc logs
16:41:24 <Cale> ColonelJ: Weird, what terminal are you using?
16:41:25 <jmcarthur> ezyang: i meant just (Showable show 5) is a valid construction
16:41:26 <HaskellLove> can someone compile that please and tell me the result when it is done, i am runing two files now it wont run a third one ... http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15678#a15678
16:41:39 <ColonelJ> Cale: they sometimes work, but not always... windows
16:41:42 <c_wraith> ColonelJ: open up a new terminal and killall ghc.  (unless you're on solaris, where killall is not the same thing)
16:41:47 <ColonelJ> maybe it's stuck on internal code
16:41:52 <Cale> Oh, I don't really know about windows.
16:41:56 <tener> @type fix ($)
16:41:58 <lambdabot> forall a b. a -> b
16:41:58 <c_wraith> oh, windows?  eww.  People still use that?
16:41:58 <ezyang> ok
16:41:59 <copumpkin> HaskellLove: inline type annotations are ugly
16:42:05 <jmcarthur> ezyang: anyway, i'm about to leave work. good luck!
16:42:08 <HaskellLove> Cale it might be because the two files take a lot of working memory so the third file has nowhere to go?
16:42:14 <ezyang> bye!
16:42:18 <copumpkin> HaskellLove: you write result :: Integer and it'll figure out the read for you
16:42:29 <ezyang> I'm trying to decide what I can usefully do with (Showable show 5) now
16:42:33 <ColonelJ> why didn't it make my function iterative
16:42:46 <ezyang> Oooh, I can pattern match!
16:42:58 <copumpkin> use the power of the pattern!
16:43:01 <HaskellLove> copumpkin that is not intuitive so i would rather not use it
16:43:07 <copumpkin> o.O
16:43:17 <tener> can anybody link me a blogpost on why "fix ($) == _|_", or there isn't one yet?
16:43:19 <augur> use the pattern, luke
16:43:19 <aavogt> existential quantification is annoying about things escaping
16:43:20 <ColonelJ> oh it's not tail recursive
16:43:26 <ezyang> ColonelJ: Cuz iterative functions are hard to understand
16:43:31 <copumpkin> tener: expand it yourself and see
16:43:38 * ezyang flubbed teaching the iterative version of the fibonnaci series in Scheme last night 
16:43:44 <augur> tener: fix ($) would just apply a function indefinitely to itself, basically
16:44:01 <augur> f (f (f (f (f (f (f ...
16:44:03 <ColonelJ> that language I was making is nearly ready (a functional stack language!)
16:44:17 <Cale> tener: It's easier to see if you write ($) = id
16:44:22 <augur> it would never actually execute, or finish executing, so it's equal to bottom
16:44:28 <ColonelJ> (1 1 :(x y x y +) #x #y loop)
16:44:30 <tener> @type fix id
16:44:32 <lambdabot> forall a. a
16:44:34 <Cale> tener:  fix f = x where x = f x, so fix id = x where x = id x
16:44:42 <copumpkin> :t fix ($)
16:44:43 <lambdabot> forall a b. a -> b
16:45:02 <aavogt> also, the type sort of tells you there can be no useful values
16:45:03 <Cale> ($) is just a type-specialisation of id
16:45:08 <copumpkin> tener: another explanation is that no such type can exist :)
16:45:10 <aavogt> @free fix ($)
16:45:11 <lambdabot> Extra stuff at end of line
16:45:18 <aavogt> @free f = fix ($)
16:45:19 <lambdabot> Extra stuff at end of line
16:45:20 <tener> this is fun anyway
16:45:26 <copumpkin> aavogt: it mostly wants the type
16:45:26 <Cale> copumpkin: The type exists and has just one value in it ;)
16:45:35 <copumpkin> Cale: well, you know what I mean :P
16:45:37 <ColonelJ> ezyang: really there's no difference between iteration and tail recursion
16:45:48 <copumpkin> no non-bottom value of such type can exist!
16:45:50 <copumpkin> there, hrrmpf
16:45:54 <Cale> hehe
16:45:57 <koeien37> iteration is defined in terms of recursion
16:46:19 <koeien37> if you look at the semantics of an imperative programming language
16:46:34 <copumpkin> :)
16:46:40 <ColonelJ> I did it that way in my language as well really
16:46:54 <sproingie> recursion is defined in terms of recursion
16:46:59 <HaskellLove> http://projecteuler.net/index.php?section=problems&id=26 will i have to write my own dividing function in haskell? isnt there some cool package i could use?
16:47:05 <ColonelJ> sproingie: lol :P
16:47:23 <koeien37> you need some mathematics
16:47:25 <copumpkin> HaskellLove: I wouldn't actually work with decimals
16:47:40 <Cale> HaskellLove: I told you to write your own division for that one not because you need to compute the quotient.
16:47:53 <sproingie> i thought you were way past problem 26
16:47:55 <Cale> HaskellLove: But because you need to keep track of the remainders.
16:48:21 <HaskellLove> sproingie i skipped that one so i am back now trying to get second magic insight
16:48:26 <copumpkin> I mean, you can get all the decimals if you want with CReal
16:48:36 <copumpkin> but it's not a very good way to go about it
16:48:46 <Cale> It's an impossible way to go about it
16:49:19 <HaskellLove> copumpkin there is nothing on hoogle about it, how to use it just tell me and i am on my way,,,
16:49:24 <Cale> (well, you might be able to use some bound on the length of the repeating block based on the denominator)
16:49:43 <koeien37> > 12345/99999
16:49:45 <lambdabot>   0.12345123451234512
16:49:46 <Cale> HaskellLove: Do you know about the mod function?
16:49:50 <copumpkin> Cale: yeah, that's what I meant. You can be pretty sure it's not going to be ridiculous with the first 1000
16:49:57 <HaskellLove> Cale of course
16:50:04 <koeien37> > 1234567/9999999 :: CReal
16:50:06 <lambdabot>   0.1234567123456712345671234567123456712346
16:50:36 <HaskellLove> awesome now it will be easy, no need for manual work with division Cale
16:50:39 <Cale> HaskellLove: Use it to compute the remainders in the same pattern as you would as calculating the digits of those numbers by hand.
16:50:58 <Cale> That is, in the same pattern as you would while dividing.
16:51:22 <Cale> So you *are* implementing division by hand, you're just throwing away most of the result.
16:51:37 <Cale> The only thing you're interested in is how long the resulting cycle is.
16:51:39 <HaskellLove> are we talking about Data.Number.CReal?
16:51:42 <Cale> No.
16:51:44 <copumpkin> HaskellLove: you mean you want to use CReal?
16:51:49 <copumpkin> I guess you can do whatever you want :P
16:51:50 <Cale> CReal is absolutely useless for this problem.
16:51:52 <HaskellLove> yea
16:51:53 <copumpkin> good luck finding cycles
16:52:01 * copumpkin waits for another question in 20 minutes
16:52:18 <Cale> (If you think that knowing the digits of the number will help you, you don't understand the problem.)
16:52:49 <HaskellLove> Cale it would be better for me now to hit the wall you talk about and ask later then you just telling me what it is :)
16:52:55 <Cale> It's the *other* part of the process of division that you need, the part which is normally thrown away -- all the intermediate remainders.
16:53:28 <Cale> (think back to elementary school)
16:53:33 <copumpkin> ooh that burns
16:53:42 <copumpkin> :)
16:54:02 <mrsolo> hmm anybody tried ghc under arm processor?
16:56:07 <HaskellLove> why is this wrong cabal install Data.Number?
16:56:11 <HaskellLove> on ubuntu bash
16:56:18 <copumpkin> because the package name isn't Data.Number
16:56:22 <Cale> There's no package of that name on Hackage.
16:56:26 * damd tries to think of jokes about CReal...
16:56:31 <copumpkin> it's either numbers or Numbers (and I hate that both exist and are different btw)
16:56:47 <Cale> lowercase one
16:56:58 * xerox .oO( Numb3rs )
16:57:11 <ezyang> I think I'm going to drop the prompt monad script section from the tmr article. I don't understand it. :-(
16:57:32 <HaskellLove> Cale Data.numbers ?
16:57:34 <copumpkin> aw
16:57:39 <copumpkin> HaskellLove: cabal install numbers
16:57:42 <Cale> HaskellLove: no, just numbers
16:57:57 <monochrom> mrsolo: I think they actually ported ghc to iPhone, so it's an instance of arm, and they have to -fvia-C.
16:58:03 <copumpkin> HaskellLove: you really should get used to writing type signatures occasionally btw, and not inline like you've been doing
16:58:08 <Cale> HaskellLove: The module name is Data.Number.CReal, the package name is numbers
16:59:35 <monochrom> someone in #haskell-blah says: cale install numbers?
16:59:47 <Cale> monochrom: heh
17:00:15 <tensorpudding> Cale has transcended humanity and become a package manager
17:00:16 <ezyang> WHOA!
17:00:21 <ezyang> I think I understand it!
17:00:50 <koeien37> ezyang: i've known this feeling to end suddenly with depressing thoughts :(
17:01:01 <ezyang> oh noes
17:01:04 <copumpkin> koeien37: way to ruin the moment
17:01:11 <HaskellLove> the documentation is confusing how to use this thing showCReal?  to display given number of decimals
17:01:16 <mrsolo> monochrom: successfully? nice... thinking about running ghc on sheevaplug which can run linux arm
17:01:19 <Cale> ezyang: The Prompt monad is awesome
17:01:51 <ezyang> Ok, then I'm going to construct an example to convince myself I know what I'm doing
17:01:54 <copumpkin> > showCReal 100 pi
17:01:54 <monochrom> mrsolo: Yes successfully. Some people are using it.
17:01:55 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
17:01:58 <copumpkin> tada
17:02:00 <ColonelJ> > 123/1000 + 456/999000
17:02:01 <lambdabot>   0.12345645645645645
17:02:05 <Ke> so porting succesfully to iphone also means linux arm?
17:02:14 <ColonelJ> > 44/1000 + 8/9000
17:02:15 <lambdabot>   4.488888888888889e-2
17:02:38 <copumpkin> HaskellLove: watch ColonelJ
17:02:48 <theorbtwo> Ke: For something like haskell, you can normally consider OS and CPU support to be pretty well orthagnal.
17:03:07 <Ke> so I would assume
17:03:11 <theorbtwo> Supporting ARM and Linux implies that you support arm linux.
17:03:21 <copumpkin> there is already an arm linux port out there
17:03:26 <copumpkin> not a native codegen though
17:03:29 <copumpkin> so it's via c
17:03:32 <HaskellLove> > showCReal 100 1/46
17:03:33 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Base.String)
17:03:34 <lambdabot>    arising from a use...
17:03:42 <Ke> c is fine
17:03:49 <Cale> HaskellLove: You can't divide a string by 46 ;)
17:04:16 <Cale> (remember that function application has higher precedence than any infix operator)
17:05:16 * theorbtwo thinks that haskell parens are often sillier then Lots of SIlly Parenthesies.
17:05:33 <theorbtwo> (All the more so because experinced haskellers tend to spell their parens $.
17:05:33 <copumpkin> > showCReal 100 (1/46)
17:05:35 <lambdabot>   "0.021739130434782608695652173913043478260869565217391304347826086956521739...
17:05:35 <c_wraith> LSIP?
17:05:47 <damd> i think lisp is way more beautiful :/
17:05:54 <Cale> theorbtwo: moreso (.) than ($)
17:06:01 <ColonelJ> I hate how many damned parentheses you need in lisp and scheme
17:06:01 <aavogt> hawt lisp
17:06:09 <theorbtwo> Cale: D'oh.
17:06:22 <damd> ColonelJ: "lisp and scheme"?
17:06:32 <sproingie> clojure!
17:06:47 <HaskellLove> well CReal saved me from float arithmetic now it should be easy to solve the euler
17:06:50 <Cale> theorbtwo: Instead of f (g (h x)), I tend to write f . g . h $ x
17:06:59 <ColonelJ> damd: oh they're the same never mind
17:07:22 <theorbtwo> I'm still at the point where I tend to create *lots* of tempories with let.
17:07:27 <Cale> The advantage of this is that it effectively has many more subexpressions
17:07:38 <Cale> For instance, g . h is well-types
17:07:40 <Cale> typed*
17:07:54 <Cale> as is h $ x
17:08:01 <Cale> and f . g
17:08:03 <Cale> and so on
17:08:11 <theorbtwo> Cale: Er, so is g (h x), isn't it?
17:08:29 <Cale> yes, but not g (h or g $ h
17:09:09 <Cale> You get O(n^2) "subexpressions" rather than O(n), because of the associativity of (.)
17:09:09 <copumpkin> HaskellLove: Cale has told you repeatedly that it won't help
17:09:27 <Cale> showCReal 1000 (1/983)
17:09:28 <Cale> > showCReal 1000 (1/983)
17:09:30 <lambdabot>   "0.001017293997965412004069175991861648016276703967446592065106815869786368...
17:09:35 <jeffwheeler> vty-ui looks very neat
17:10:08 <copumpkin> shh
17:10:15 <copumpkin> :P
17:10:18 <jeffwheeler> Hm?
17:10:22 <copumpkin> not you :)
17:10:25 <Cale> He was talking to me
17:10:38 <copumpkin> (it was a joking shh, not an assholish one, btw)
17:10:48 * copumpkin tries to keep his AQ low
17:10:49 <jeffwheeler> Oh, but I forgot that installing on 6.12.1 didn't work
17:11:08 <jeffwheeler> copumpkin: I figured as such, even though it's been a long time since I've been in #haskell much
17:11:13 <copumpkin> :)
17:12:27 <jeffwheeler> Hm, the problem seems to be that vty-ui requires an old version of vty; I wonder why.
17:15:17 <ColonelJ> HaskellLove: "The number of digits in the repeating portion of the decimal expansion of a rational number can also be found directly from the multiplicative order of its denominator."
17:15:53 <Cale> You don't even need to be that fancy though
17:16:12 <Cale> You just need to remember the elementary school division algorithm
17:16:36 <aavogt> yeah, you repeat if you've already seen that previous  (digit,remainder)
17:17:14 <ColonelJ> it's not a very mathematical way
17:17:54 <Cale> ColonelJ: Yeah, but if he's struggling with that...
17:18:06 <ColonelJ> are there any libs for extended euclidean algo?
17:18:16 <ColonelJ> I know gcd is there
17:18:43 <copumpkin> there was a blog post on it recently
17:19:24 <copumpkin> http://cdsmith.wordpress.com/2009/07/20/calculating-multiplicative-inverses-in-modular-arithmetic/
17:19:33 <copumpkin> I think that had it
17:19:42 <HaskellLove> Cale I think i am onto a good algorithm: 1. take tails of the decimal part. 2. for each tail do: take length and compare the elements of the list with the next elements, if it matches then whoala
17:19:54 <HaskellLove> why am i so smart daaamn, now i gota implement this
17:19:56 <koeien37> whoala?
17:20:08 <copumpkin> o.O
17:20:18 <copumpkin> HaskellLove: you have infinite digits
17:20:27 <Cale> HaskellLove: What if the number looks like 0.33663366889988993366336688998899...
17:20:29 <copumpkin> HaskellLove: even if you can't ask a CReal for all of them
17:20:43 <HaskellLove> i will work only with 1000 and hope the solution is there
17:20:56 <aavogt> > 1 / 1000
17:20:58 <lambdabot>   1.0e-3
17:21:38 <HaskellLove> aavogt 1000 digits in the decimal part ... not just with 1/1000
17:21:59 <tener> is there a library function that is equivalent to "f xs = zip (inits xs) (tails xs)" ?
17:22:43 <tener> i couldn't fine one with hoogle...
17:23:13 <copumpkin> nope
17:23:26 <Cale> HaskellLove: fail. You won't see the repetition in the best case with only 1000 digits.
17:24:11 <tener> pity. especially because this implementation isn't the most efficient one
17:24:22 <copumpkin> wow, Cale said fail
17:24:27 <jeffwheeler> Should the channel title be updated now that Hackage is fine?
17:24:43 <HaskellLove> Cale I can match the pattern like 10 times, if it fails lets say the 8 time that means I will then go to start and skip the pattern somehow... complicated and not defined but i will do it i think... 1000 digits, no? more ? how about 10 000?
17:25:01 <copumpkin> 50 million digits!
17:25:07 <copumpkin> just to be safe
17:25:09 <Cale> HaskellLove: It's still the wrong way to do it.
17:25:23 <copumpkin> HaskellLove: remember it's about learning, not about getting the answer ;)
17:25:35 <Cale> HaskellLove: Because you've done nothing to show that it *actually* repeats like that
17:26:12 <tartaglia> can someone tell me some notable result from category theory ?
17:26:24 <tartaglia> like something that would justify its existance(the branch category theory)
17:26:39 <HaskellLove> Cale I think having a pattern repeat 3 times is a safe bet that it is THE recurring cycle
17:26:41 <Cale> For example if you see the digits 0.203271203271... is the repeating length 6? Maybe. But what if the number is actually 0.20327120327133333(3) and the repeating length is 1?
17:26:57 <Cale> HaskellLove: It's not.
17:26:58 <copumpkin> tartaglia: I see it more as unifying different branches of math, like algebra but even more abstract
17:27:10 <Cale> HaskellLove: How about something like 0.23232355555555...
17:27:41 <Cale> HaskellLove: If you only look at finitely many of the digits, you won't prove anything.
17:28:01 <Cale> HaskellLove: This is why examining the digits is the wrong way to do it.
17:28:10 <aavogt> for some problems you can't reasonably prove that you have the answer
17:28:16 <copumpkin> what cale wants to say is "ur doin it rong"
17:28:16 <aavogt> not this one though
17:28:42 <BMeph> UR DOIN IT RONG!!! ;)
17:29:36 <HaskellLove> I know guys the point is bump in walls and learn not... ok i am doing it wrong, Cale, Big Brother whatever you say my brain obeys you even though it has no idea what you talk about :D
17:30:02 <vardhanvarma> hi. trying euler#13 (collatz prob) .. how to make list of upto 4million Integer on a 32bit laptop !!
17:30:06 <ColonelJ> this repeating decimal thing has nothing to do with extended euclidean does it :P
17:30:08 <HaskellLove> Cale yeah i am thinking about those problematic cases now this algorithm can be modified to handle them
17:30:15 <Zao> vardhanvarma: Piecewise?
17:30:23 <Zao> vardhanvarma: Or swap to disk :P
17:30:26 <copumpkin> vardhanvarma: range of 32-bit integers is 4 billion, btw
17:30:31 * Zao opens the problem before opening his mouth more.
17:31:07 <Cale> vardhanvarma: You may need numbers larger than 2^32 for that one, but there's no need to memoise such a large range.
17:31:16 <Canar> o hai Zao
17:31:26 <Zao> http://projecteuler.net/index.php?section=problems&id=13
17:31:29 <Zao> Wrong number?
17:31:35 <vardhanvarma> Zao: 14
17:31:38 <vardhanvarma> Zao: oops
17:32:04 <ColonelJ> copumpkin: 32-bit UNSIGNED integers
17:32:14 <Zao> Canar: Hellos.
17:32:23 <copumpkin> ColonelJ: fine, 2 billion if signed, still quite a lot larger than what he wants
17:32:34 <Zao> I hear there's this nice Integer type.
17:32:39 <vardhanvarma> copumpkin: it 's Integer, not Int (-:
17:32:59 <copumpkin> pff
17:33:25 <Zao> I wonder how much space my solution ran in.
17:33:33 <Zao> Time to look into profiling flags.
17:33:56 <ColonelJ> is there any way to get multiplicative order except by brute force... now that I think about it I think they use this in encryption, powermods are one-way functions :(
17:34:09 <vardhanvarma> Zao: i'm trying to say : 1:1:[1 + cclens !! ( coll x ) | x <- [ 2 .. ] ] where coll n = ...
17:34:46 <c_wraith> ColonelJ: yes, modular logarithms would break RSA, for instance.
17:36:17 <copumpkin> discrete logarithm wouldn't hurt RSA, afaik
17:36:20 <copumpkin> factoring would
17:36:50 <c_wraith> well, I'm pretty sure they're essentially the same problem.
17:36:52 <copumpkin> it would hurt DH and DSA for example
17:37:15 <ColonelJ> yeah RSA is based on two large primes
17:37:25 <mental> 5 and 7
17:37:39 <HaskellLove> omg Cale I did it, I think here it goes: 1. I have a list of digits from the decimal part 2. Divide the list in half, in two new lists lets call them a and b 3. check if a matches b, if it does it is THE recuring cycle 4. if it does not match, take the last element out of a and add it at the begining of b, and remove the last element of b 5. check if a matches b... EUREKAAA!!!
17:38:14 <HaskellLove> so THE recuring cycle is the LONGEST list
17:38:26 <Cale> HaskellLove: seems wrong
17:38:39 <HaskellLove> and i will work with lets say 10 000 digits maximum ... i will implement now
17:38:51 <Cale> sigh
17:39:03 <copumpkin> just implement it
17:39:13 <copumpkin> if nothing else, you might get an understanding for why it fails
17:39:19 <ColonelJ> HaskellLove: it can't possibly be more than 1000 digits
17:39:35 <ColonelJ> for the repeating part at least
17:39:46 <Cale> ColonelJ: The repeating part can't, but, the way he's doing it...
17:39:53 <copumpkin> ColonelJ: the recurring bit might not be, but to find a "probable cycle" he needs at least two occurrences
17:40:56 <c_wraith> discrete logs totally break RSA.  look at the form of encryption.  m^e mod n = c.  if you're trying to break RSA, you have e, n, and c.  that's completely a discrete log problem.
17:42:09 <HaskellLove> two eulers are calculating now in ghc so my pc is frickin slow i cant even write in my text editor... i will copy my algotithm above and implement tomorow i am sure it will work, now i leave you in peace and go to sleep, thanks, cya
17:42:38 <copumpkin> HaskellLove: you did notice the "all euler solutions should run in a minute or less in the FAQ, right?"
17:42:43 <copumpkin> whoops
17:42:55 <Zao> My #14 implementation is still running, heh.
17:43:05 <Zao> Deadlines are there to be broken.
17:43:13 <Cale> Failure to memoise?
17:43:32 <ColonelJ> How do you get the second / any element of a tuple?
17:43:34 * aavogt can't remember
17:43:43 <kmc_> :t fst
17:43:44 <kmc_> :t snd
17:43:44 <Cale> ColonelJ: pattern match
17:43:46 <lambdabot> forall a b. (a, b) -> a
17:43:46 <lambdabot> forall a b. (a, b) -> b
17:43:57 <Cale> ColonelJ: there are fst and snd, but they are only for pairs, as you can see
17:43:58 <kmc_> there's no single function for arbitrary size tuples
17:44:04 <ColonelJ> I only need pairs in this case
17:44:06 <kmc_> because the types (a,b) and (a,b,c) are totally unrelated
17:44:22 <kmc_> there is however a library that uses typeclasses to provide one set of accessors up to 7 or so
17:44:56 <kmc_> > 3 <$ "hello world"
17:44:57 <lambdabot>   [3,3,3,3,3,3,3,3,3,3,3]
17:45:21 <SubStack> @pl map (\[x,y] -> (x,y)) . sequence
17:45:22 <lambdabot> (line 1, column 7):
17:45:22 <lambdabot> unexpected "["
17:45:22 <lambdabot> expecting pattern
17:45:47 <SubStack> what
17:46:03 <Cale> SubStack: You're *probably* looking for liftM2 (,)
17:46:13 <Cale> > liftM2 (,) [1,2,3] [4,5,6]
17:46:15 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
17:46:17 <kmc_> :t liftM2 (,)
17:46:18 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m (a1, a2)
17:46:21 <ColonelJ> :t foldl'
17:46:22 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
17:46:39 <SubStack> excellent
17:46:41 <SubStack> Cale++
17:46:41 <kmc_> :t \x y -> (,) <$> x <*> y
17:46:43 <lambdabot> forall a a1 (f :: * -> *). (Applicative f) => f a -> f a1 -> f (a, a1)
17:46:47 <kmc_> :t liftA2 (,)
17:46:49 <lambdabot> forall a b (f :: * -> *). (Applicative f) => f a -> f b -> f (a, b)
17:47:18 <ezyang> Ok, as suspected, I don't quite understand.
17:47:22 <kmc_> @hoogle (Applicative f) => [f a] -> f [a]
17:47:23 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
17:47:24 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
17:47:24 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
17:48:03 <idnar> @src sequenceA
17:48:04 <lambdabot> Source not found. :(
17:49:29 <aavogt> @src [] Data.Traversable.sequenceA
17:49:29 <lambdabot> Source not found. My mind is going. I can feel it.
17:49:40 <Guest93234> are the worker threads (related to sparks in Control.Parallel) also used by forkIO?
17:50:07 <copumpkin> yeah
17:50:16 <Guest93234> thanks
17:50:19 <copumpkin> now you might wonder where sporks come in
17:50:24 <kmc_> are those worker threads the OS-level capabilites threads, or another abstractio?
17:50:29 <copumpkin> yeah
17:50:36 <copumpkin> yeah to the former ;)
17:51:01 <kmc_> yeah there is no way to fork a new OS thread.  the best you can do is fork a new Haskell thread with the property that, when it makes FFI calls, they will all be made by the same OS thread
17:51:44 <copumpkin> it'd be nice if there were an addCapability :: IO ()
17:51:52 <copumpkin> and numCapabilities were IO Int
17:51:55 <copumpkin> instead of just Int
17:52:01 * copumpkin grrs
17:52:02 <_andy_> and I'm assuming other threads on that OS thread will be rescheduled to another OS thread during the FFI call?
17:52:15 <monochrom> "why not Integer?"
17:52:36 <copumpkin> why not natural!
17:52:36 <jmcarthur> ezyang: any luck?
17:52:38 <kmc_> _andy_, that's unspecifiecd
17:52:42 <copumpkin> I'd hate to have negative capabilities
17:52:44 <_andy_> ok
17:52:52 <ezyang> jmcarthur: I think I understand existential quantification now
17:52:55 <kmc_> you might spawn a dedicated OS thread which only does your thread's FFI and sleeps the rest of the time
17:52:56 <jmcarthur> yay!
17:53:02 <ezyang> and I understand the type trickery that allows him to do what he's doing
17:53:02 <copumpkin> ezyang: no more existential crisis, eh :)
17:53:03 <kmc_> i don't know what strategy GHC uses
17:53:10 <ezyang> I'm trying to understand why this technique is useful in general, now.
17:53:16 <ezyang> hee :-)
17:53:24 <copumpkin> ezyang: OOP is all about existentials!
17:53:28 <jmcarthur> ezyang: it's useful in an object-oriented way
17:53:39 <kmc_> it's used for "heterogeneous containers"
17:53:45 <jmcarthur> ezyang: it allows you to know some operations you can do with a type without knowing what the type is
17:53:51 * copumpkin is a heterophobe
17:53:52 <kmc_> and for things that act like extensible variants
17:53:58 <ezyang> mmmmm
17:53:59 <kmc_> e.g. the extensible exceptions
17:54:00 <monochrom> Control.Exception uses existential
17:54:06 <ezyang> I think I could be convinced of that.
17:54:20 <kmc_> data SomeException = forall e. (Exception e) => SomeException e
17:54:22 <kmc_> something like that
17:54:25 <jmcarthur> ezyang: i tend to avoid it myself because once you make something an existential it's that way forever
17:54:30 <kmc_> theres' a wiki page on it as well
17:54:37 <monochrom> In fact, binding objective-c stuff to haskell also uses existential
17:54:56 <monochrom> It's some binding cocoa to haskell, isn't it?
17:56:28 <jmcarthur> ezyang: for example, i could have a value of type [Showable], where each element of the list actually is a different type, but all we can do with them is show them. in this case we might as well just have [String]
17:57:17 <jmcarthur> but we could imagine more complex cases where this is convenient
17:57:49 <ColonelJ> let euler26 n = foldl (\(max,e) (m,x) -> if m > max then (m,x) else (max,e)) (0,0) (map (\x -> (morder x 10 x 1, x)) [2..n]) where morder _ _ 1 o = o ; morder x b m o = morder x b (x*m `mod` b) (o+1) in euler26 1000
17:58:06 <copumpkin> ezyang: next up, polymorphic values and impredicative polymorphism
17:58:12 <ColonelJ> > let euler26 n = foldl (\(max,e) (m,x) -> if m > max then (m,x) else (max,e)) (0,0) (map (\x -> (morder x 10 x 1, x)) [2..n]) where morder _ _ 1 o = o ; morder x b m o = morder x b (x*m `mod` b) (o+1) in euler26 1000
17:58:13 <ezyang> oh noes
17:58:16 <lambdabot>   mueval-core: Time limit exceeded
17:58:37 <ColonelJ> oh well was worth a shot
17:58:55 <BMeph> ColonelJ: That's "morder" most foul... :p
18:01:56 <ColonelJ> oops I forgot to make them coprime first
18:03:01 <ColonelJ> also, that page I was reading didn't actually say HOW to find the number of digis
18:04:50 <interferon> how can i specify how many test cases quickCheck should run>?
18:05:17 <copumpkin> interferon: there's some sort of configuration structure you can pass in
18:05:23 <copumpkin> can't remember the specifics
18:06:02 <ezyang> What can I do with existentials that I can't do with judicious use of functions and typeclasses?
18:06:24 <copumpkin> ezyang: lots of fun type-level stuff
18:06:54 <interferon> existentials?
18:07:46 <copumpkin> data Z; data S n; data Vec where Nil :: Vec Z a; Cons :: a -> Vec n a -> Vec (s n); data AnyVec = forall n. Vec n a
18:07:59 <copumpkin> AnyVec a, that is
18:08:04 <copumpkin> oh and Vec takes parameters
18:08:51 <copumpkin> ezyang: but with existentials you can enforce internal consistency rules without stuff breaking, too
18:08:57 <MbM313> SALaaaaaaaaaam /  Hi to all
18:09:14 <ColonelJ> ah it's on this page http://mathworld.wolfram.com/DecimalExpansion.html
18:11:15 <MbM313> ISLAM ! UR Life right n Best future   www.sultan.org  www.turntoislam.com  www.raastenraah.com
18:11:26 <copumpkin> o.O
18:11:32 --- mode: ChanServ set +o xerox
18:11:36 --- mode: xerox set +b *!*i=MbM313@119.63.138.*
18:11:43 --- kick: MbM313 was kicked by xerox (xerox)
18:11:48 --- mode: xerox set -o xerox
18:11:58 <copumpkin> wow, I've seen a lot of trolling but religious evangelism is new to me
18:11:59 <damd> cool, i'll look into it
18:12:09 <copumpkin> soon the jehovah's witnesses will be visiting #haskell
18:12:15 <ColonelJ> oh noez
18:12:26 <ColonelJ> I wonder why the hell I but 10 in as the thing to divide by
18:12:43 <damd> *what*?
18:13:00 <ezyang> copumpkin: You have a typo in your code ;-)
18:13:11 <copumpkin> ezyang: I have lots of typos in that code :P
18:13:14 <copumpkin> but you get the idea
18:14:06 <copumpkin> ezyang: with that you can have matrices that internally take care of keeping themselves square
18:14:17 <copumpkin> or rectangular, I should say
18:14:21 <conal> hah.  while looking up spj & monadic IO, I stumbled onto a headline: "Haskell determined to stay out of sin-bin"
18:14:23 <conal> http://myspace.vtap.com/video/Haskell+determined+to+stay+out+of+sin-bin/CL0275073085_5e23608b0_c3c6c2luLmJpbn5pbjozfnE6c2V-bXc6c2luIGJpbg
18:14:32 <copumpkin> but you could use an existential to not care about the dimensions
18:14:40 <copumpkin> or not, and enforce consistency on your matrix operations too
18:14:41 <conal> i wish
18:14:48 <conal> ;)
18:15:08 <edwardk> conal: hahahaha
18:15:20 <edwardk> conal: posted to reddit yet?
18:15:43 <conal> hah.  no i haven't.
18:15:54 <edwardk> probably better to submit it as http://news.bbc.co.uk/sport2/hi/rugby_union/7885566.stm
18:16:05 <copumpkin> hah
18:16:07 <conal> oh, better.  thx.
18:16:38 <copumpkin> someone please submit that to haskell reddit
18:16:58 <copumpkin> (seriously)
18:17:19 <jmcarthur> i totally would if it didn't look like conal was considering it already
18:17:33 <copumpkin> race!
18:17:40 <conal> i'm *not* considering it.
18:17:44 <jmcarthur> heh
18:17:51 * jmcarthur does it
18:17:52 <conal> please go ahead.
18:18:06 * copumpkin flames conal
18:18:15 <xerox> James Haskell, hehe.
18:18:25 <jmcarthur> http://www.reddit.com/r/haskell/comments/ami83/haskell_determined_to_stay_out_of_sinbin/
18:18:27 <xerox> Haskell's a big boy.
18:18:31 <conal> gee my "liberated" post has gotten a lot of reddit'ing.  http://www.reddit.com/r/compsci/duplicates/alymh/can_functional_programming_be_liberated_from_the/
18:18:42 <conal> jmcarthur: :) !
18:18:49 <copumpkin> conal: hell yeah
18:19:15 <ezyang> conal: It's a very evocative post.
18:19:47 <conal> i'm surprised how insistent some people are about arguing over fuzzy terms like "functional" and "pure".
18:20:11 <conal> i keep steering toward simple & precise denotation.  and people keep steering away.
18:21:00 <jmcarthur> conal: you did go along with peaker on saying that pure is an absolute
18:21:02 <shapr> I like pretty code.
18:21:08 <cads> conal: that title is fucking _catchy_!
18:21:17 <BMeph> Already has a down vote; Impressive! ;)
18:21:26 <Zao> Ooh, my #14 terminated.
18:21:30 <conal> jmcarthur: yes.  "pure" *anything* is an absolute
18:21:33 <Zao> I estimate the runtime to fifteen minutes, tops.
18:21:54 <jmcarthur> conal: yeah, but it was in a conversation about how things mean different things to different people. at least that's how i read it
18:21:59 <conal> "pure" by itself doesn't tell me anything.
18:22:41 <copumpkin> except one of those purity rings
18:22:45 <copumpkin> we need to get haskell one of those
18:22:57 <jmcarthur> conal: when people disagree on the meaning of a word and claim that it has an "absolute" meaning anyway, i don't think much will come of it
18:23:16 <jmcarthur> conal: it twists the meaning of "absolute," but its a great way to upset people anyway
18:24:12 <conal> there's also the persistent myth that haskell IO is modeled as State RealWorld
18:24:22 <conal> http://www.reddit.com/r/haskell/comments/alx2v/can_functional_programming_be_liberated_from_the/c0ic6bq
18:24:25 <jmcarthur> conal: were you speaking of "pure" in the normal English sense of the word or in the computer science sense of the word?
18:24:26 <aavogt> @src IO
18:24:26 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
18:24:38 <copumpkin> conal: well, in GHC it is, but it's not very interesting
18:25:09 <jmcarthur> conal: because people have more specific notions of its meaning in the context of computer science, correct or not
18:25:12 <conal> copumpkin: it's a lie.  an implementation hack supported by compiler magic, afaik
18:25:26 <copumpkin> well, ignoring concurrency, it isn't a lie
18:25:34 <conal> copumpkin: exactly.
18:25:40 <copumpkin> it's a simple way of getting dependencies
18:25:48 <copumpkin> without ever actually touching the value
18:26:00 <conal> copumpkin: and haskell IO has nondeterministic concurrency
18:26:04 <copumpkin> yeah
18:26:09 <BMeph> It's a simple way of making a major PITA of a simple concurrency model, too. :\
18:26:24 <copumpkin> not sure how I would introduce concurrency into that
18:26:26 <jmcarthur> i look at frp as an attempt to solve the problems of concurrency, for the most part
18:26:29 <copumpkin> without lying
18:26:46 <kniu> say I define a 3d vector data type
18:26:53 <conal> copumpkin: i don't think you could
18:26:56 <kniu> data Vector = Vec Double Double Double
18:26:58 <copumpkin> probably not
18:27:03 <kniu> is that really more efficient than
18:27:09 <kniu> type Vector = [Double]
18:27:10 <kniu> ?
18:27:12 * copumpkin says that kniu has defined a 3d vector data type
18:27:16 <ezyang> kniu: Yes.
18:27:21 <copumpkin> kniu: yes, and it can be even more efficient
18:27:30 <conal> jmcarthur: me too.  frp handles semantic concurrency in a fine grain & determinstic way.
18:27:35 <kniu> what would be the MOST efficient way to do this?
18:27:36 <copumpkin> with data Vector = Vector !Double !Double !Double and -funbox-strict-fields
18:27:37 <jmcarthur> copumpkin: not without mutating RealWorld explicitly
18:27:42 <kniu> oh boy.
18:28:05 <conal> nondetermism is what makes the complexity go exponential (tecnically)
18:28:06 <jmcarthur> which (doh!) relies on ordering already, breaking the whole purpose of the RealWorld state stuff in the first place
18:28:26 <conal> i mean in a technical sense of "exponential"
18:28:35 <kniu> how much, proportionally, would you say the efficiency gain is?
18:28:36 <copumpkin> jmcarthur: so replace RealWorld with IO RealWorld, eh ;)
18:28:40 <kniu> since I'm writing a path tracer here.
18:28:57 <jmcarthur> copumpkin: i am again amazed by your logic
18:29:04 * copumpkin grins
18:29:23 <SubStack> is there a (=<<) someplace with higher precedence?
18:29:45 <aavogt> you are allowed to define your own =<< with your own precedence
18:30:09 * ezyang wonders idly if we've already found the right way, but no one has looked closely enough at it to say so. 
18:30:31 <ezyang> SubStack: though, redefining it is not such a hot idea
18:30:44 <SubStack> yeah, hurts readability
18:31:19 <SubStack> I was hoping for something like the <$> to liftM similarity
18:31:38 <ezyang> Are you looking for the other combinators like <=< and >=>?
18:31:46 <copumpkin> mmm fish
18:31:46 <aavogt> or join and fmap
18:32:03 <aavogt> wow, those are all functions ;)
18:32:14 <SubStack> mostly I'm tired of putting parens in stuff like f <$> (m =<< n)
18:32:30 <aavogt> fmap f . m =<< n
18:33:19 <copumpkin> or use return . f
18:33:24 <copumpkin> and get rid of the fmap
18:33:39 <aavogt> would you really?
18:33:44 <copumpkin> no
18:33:49 <copumpkin> but someone might
18:34:13 <aavogt> return . f =<< m =<< n -- like this
18:34:28 <SubStack> style is hard
18:34:38 <aavogt> style is arbitrary
18:34:45 <ezyang> @hoogle m a -> (a -> m b) -> (b -> c) -> m c
18:34:46 <lambdabot> Language.Haskell.TH.Quote dataToQa :: Data a => (Name -> k) -> (Lit -> Q q) -> (k -> [Q q] -> Q q) -> (b -> Maybe (Q q)) -> a -> Q q
18:34:47 <SubStack> that's what makes it so hard
18:34:53 <ezyang> tyeh
18:35:02 <aavogt> arbitrarily hard
18:35:16 <copumpkin> that's a pretty extreme function
18:35:20 <copumpkin> dataToQa
18:35:59 <SubStack> and here I had been blocking those out
18:36:51 * hackagebot upload: bindings-svm 0.1.0 - Low level bindings to libsvm. (PauloTanimoto)
18:37:05 <Absolute0> Is there a shortcut for "data Foo = Foo ... Int ... Int ... Int ... Int" I want to replace every occurence of "Int" with "a"
18:37:19 <aavogt> data Foo a = Foo aaaaaaaaaaaaaa a a a a
18:37:29 <ezyang> @pointless (\f m n -> f <$> (m =<< n))
18:37:29 <lambdabot> (. (=<<)) . (.) . (<$>)
18:37:32 <ColonelJ> > let euler26 n = foldl (\(max,e) (m,x) -> if m > max then (m,x) else (max,e)) (0,0) (map (\x -> (morder 10 (coprimefactor x 10) 10 1, x)) [2..n]) where morder _ _ 1 o = o ; morder x b m o = morder x b (x*m `mod` b) (o+1) ; coprimefactor a b = if gcd a b = 1 then a else coprimefactor (a `div` (gcd a b)) b in euler26 1000
18:37:33 <lambdabot>   <no location info>: parse error on input `='
18:37:35 <kmc> > fix ('a':)
18:37:36 <Absolute0> maybe something like (Int a) => in functions
18:37:37 <lambdabot>   "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
18:37:41 <luite> lol that's the third libsvm binding on hackage....
18:37:43 <ColonelJ> > let euler26 n = foldl (\(max,e) (m,x) -> if m > max then (m,x) else (max,e)) (0,0) (map (\x -> (morder 10 (coprimefactor x 10) 10 1, x)) [2..n]) where morder _ _ 1 o = o ; morder x b m o = morder x b (x*m `mod` b) (o+1) ; coprimefactor a b = if gcd a b == 1 then a else coprimefactor (a `div` (gcd a b)) b in euler26 1000
18:37:44 <lambdabot>   Ambiguous occurrence `gcd'
18:37:45 <lambdabot>  It could refer to either `L.gcd', defined at <l...
18:37:50 <kmc> Absolute0, that doesn't work, Int is not a typeclass
18:37:53 <SubStack> :s/Int/a/g
18:37:55 <copumpkin> @undef
18:38:01 <copumpkin> > let euler26 n = foldl (\(max,e) (m,x) -> if m > max then (m,x) else (max,e)) (0,0) (map (\x -> (morder 10 (coprimefactor x 10) 10 1, x)) [2..n]) where morder _ _ 1 o = o ; morder x b m o = morder x b (x*m `mod` b) (o+1) ; coprimefactor a b = if gcd a b == 1 then a else coprimefactor (a `div` (gcd a b)) b in euler26 1000
18:38:05 <lambdabot>   mueval-core: Time limit exceeded
18:38:08 <copumpkin> aw
18:38:19 <SubStack> type A = Int
18:38:22 <Absolute0> kmc: right
18:38:29 <SubStack> but that is somewhat unsettling
18:38:38 <kmc> yeah, "type" will give you simple synonyms
18:38:38 <_andy_> :t (>=>)
18:38:39 <Absolute0> nevermind then.
18:38:40 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
18:38:48 <kmc> type Z = Int -- this is better than A
18:38:53 <SubStack> it's true
18:39:02 <kmc> type R = Double -- to first approximation
18:39:03 <ray> ahem
18:39:06 <SubStack> Q is also pretty good
18:39:07 <ray> Z = Int?
18:39:22 <ray> we must be talking about different Zs
18:39:23 <SubStack> ZZ is especially good for Int
18:39:35 <ezyang> ℤ
18:39:37 <kmc> type Q = Ratio Integer
18:39:58 <ray> Q = Ratio Integer is good
18:40:03 <kmc> data B = F | T
18:40:05 <ben> What do you use for N?
18:40:10 <copumpkin> data 2 = F | T
18:40:14 <kmc> data N = Z | S N
18:40:23 <ray> haskell needs a fast N
18:40:33 <copumpkin> ray: I almost wrote one
18:40:34 <ezyang> Is it just me, or are a lot of the blacboard bold pics in http://en.wikipedia.org/wiki/Blackboard_bold wrong?
18:40:39 <copumpkin> ray: but I'm a lazy fuck
18:40:43 <ben> kmc: Can I get a smart constructor for all possible values?
18:40:48 <SubStack> wow, unicode types works
18:40:48 <ray> the best of us are
18:40:50 <kmc> hmm?
18:40:58 <SubStack> s/.$//
18:41:04 <kmc> types have to start with upper case
18:41:05 <ray> yeah you could use the blackboard bold characters i think
18:41:07 <kmc> that includes in unicode
18:41:12 <kmc> i don't know the case of bbb
18:41:20 <kmc> titlecase is okay as well
18:41:36 <SubStack> how does it tell what is uppercase unicode and what is lower?
18:41:46 <ben> SubStack: There is a list
18:41:49 <kmc> that's specified by the Unicode czars
18:41:51 <copumpkin> > forM [[1,2,3]] reverse
18:41:52 <lambdabot>   [[3],[2],[1]]
18:41:59 <ray> check out the letterlike symbols block
18:42:09 <monochrom> You can use isUpper to check.
18:42:12 <ray> that's where they hang out
18:42:14 <SubStack> nifty
18:42:23 <monochrom> > isUpper 'ℂ'
18:42:24 <lambdabot>   True
18:43:04 <kmc> Юникод цари?
18:43:10 <ray> > isUpper 'ℕ'
18:43:11 <lambdabot>   True
18:43:12 <ray> er
18:43:18 <kmc> > isUpper 'Ю'
18:43:20 <lambdabot>   True
18:43:23 <ben> > isUpper 'Λ'
18:43:24 <lambdabot>   True
18:43:30 <monochrom> The library author took much pain to make sure isUpper is both fast and standard-compliant. Please use it and applaud them.
18:43:31 <SubStack> > isUpper 'Θ'
18:43:31 <kmc> > isUpper '☭'
18:43:32 <lambdabot>   True
18:43:33 <lambdabot>   False
18:43:44 <SubStack> > isUpper 'ς'
18:43:46 <lambdabot>   False
18:44:01 * SubStack golf-claps
18:44:08 <ray> C H N Q Z P R all hang out in letterlike symbols
18:44:35 <kmc> > let π = 3 in π
18:44:36 <lambdabot>   3
18:44:43 <ray> no Q bar though
18:44:49 <mauke_> > toUpper 'σ'
18:44:50 <lambdabot>   '\931'
18:45:04 <monochrom> > text '\931'
18:45:05 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
18:45:06 <lambdabot>         against inferred ty...
18:45:11 <mauke_> > toLower 'ℚ'
18:45:11 <lambdabot>   '\8474'
18:45:22 <monochrom> > text "\931"
18:45:23 <lambdabot>   Σ
18:45:27 <monochrom> \o/
18:45:40 <ray> too bad computable reals don't have a blackboard letter
18:45:49 <monochrom> > text "\8474"
18:45:50 <lambdabot>   ℚ
18:45:54 <monochrom> \o/
18:46:51 <ColonelJ> @let Lower c = text . toLower $ c ; Upper c = text . toUpper $ c
18:46:52 <lambdabot>  <local>:1:0: Not in scope: data constructor `Lower'
18:46:52 <lambdabot>  
18:46:52 <lambdabot>  <local>:1:27:
18:46:52 <lambdabot>      Am...
18:47:03 <ColonelJ> @let showLower c = text . toLower $ c ; showUpper c = text . toUpper $ c
18:47:04 <lambdabot>  <local>:1:21:
18:47:05 <lambdabot>      Couldn't match expected type `String' against inferred ty...
18:47:05 <interferon> is the example code for RWH available online?
18:47:10 <interferon> i can't find it
18:47:38 <ColonelJ> :t 'a'
18:47:40 <lambdabot> Char
18:47:50 <ColonelJ> @hoogle Char -> String
18:47:50 <lambdabot> Network.URI escapeURIChar :: (Char -> Bool) -> Char -> String
18:47:50 <lambdabot> Prelude show :: Show a => a -> String
18:47:50 <lambdabot> Text.Show show :: Show a => a -> String
18:48:05 <aavogt> :t return :: Char -> String
18:48:06 <lambdabot> Char -> String
18:48:35 <aavogt> :t (:[]) :: Char -> String -- if you prefer monkies
18:48:36 <lambdabot> Char -> String
18:49:48 <aavogt> interferon: the whole book is available online... that includes the sources
18:50:00 <ColonelJ> @let showLower c = text . return :: Char -> String . toLower $ c ; showUpper c = text . return :: Char -> String . toUpper $ c
18:50:01 <lambdabot>   TypeOperators is not enabled
18:50:09 <aavogt> I'm not sure if the sample code is available separately though
18:50:15 <interferon> right, but i'm looking for single .hs files so i can read them as a unit
18:50:37 <ColonelJ> @let showLower c = text . return . toLower $ c ; showUpper c = text . return . toUpper $ c
18:50:39 <lambdabot>  Defined.
18:52:03 <ColonelJ> > showLower 'T'
18:52:04 <lambdabot>   t
18:52:56 <ColonelJ> > showLower 'ℚ'
18:52:58 <lambdabot>   ℚ
18:53:38 <ColonelJ> > showLower 'ς'
18:53:40 <lambdabot>   ς
18:53:46 <ColonelJ> > showUpper 'ς'
18:53:47 <lambdabot>   Σ
18:54:02 <mauke_> > showLower 'Σ'
18:54:03 <lambdabot>   σ
18:54:55 <ColonelJ> for some reason the box I use to type doesn't show the characters properly or let you type them in... they show up fine in the chat though
18:56:46 <kmc> > text . map chr . take 30 $ randomRs (2^8,2^16) (mkStdGen 234235)
18:56:47 <lambdabot>   扻도㭂㜂嚺녠铱硅튳ﮔ༭␱烔℡ﭵ蚕ᬇ佷褣밼㳊...
18:56:54 <kmc> > text . map chr . take 30 $ randomRs (2^8,2^16) (mkStdGen 17752)
18:56:55 <lambdabot>   ᓒ琯䄣⋽ㅐ茣ﯡⶖႂ雷ㄭᷗ塔挲숦鏆裛냖걛ү큜砌뵃...
18:57:13 <idnar> whee
18:58:09 <ezyang> Can I do GADTs with record syntax?
18:58:18 <copumpkin> yeah
18:58:20 <copumpkin> it's ugly though
18:58:50 <copumpkin> http://www.haskell.org/pipermail/glasgow-haskell-users/2009-June/017391.html
18:59:06 <QtPlaty[HireMe]> Isn't record syntax just regular definition with some sugar on top
18:59:21 <kmc> yes, yes
18:59:25 <kmc> records suck
18:59:34 <ezyang> eew
19:00:50 <_andy_> :t bracket
19:00:51 <lambdabot> Not in scope: `bracket'
19:00:59 <aavogt> > let (,) {} = (1,2) in "hai"
19:01:01 <lambdabot>   "hai"
19:01:08 <_andy_> >import Control.Exception
19:01:10 <_andy_> :t bracket
19:01:12 <lambdabot> Not in scope: `bracket'
19:01:14 <_andy_> ...
19:01:22 <aavogt> :t Control.Exception.bracket
19:01:22 <copumpkin> :t Control.Exception.bracket
19:01:23 <lambdabot> forall a b c. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
19:01:23 <lambdabot> forall a b c. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
19:01:25 <copumpkin> copycat
19:01:30 <_andy_> thanks
19:01:53 <_andy_> @src Control.Exception.bracket
19:01:54 <lambdabot> Source not found. I am sorry.
19:02:15 <copumpkin> :t runCont . sequence . map Cont . map (bracket ?x ?y)
19:02:17 <lambdabot> Not in scope: `bracket'
19:02:23 <copumpkin> :t runCont . sequence . map Cont . map (Control.Exceptionbracket ?x ?y)
19:02:24 <lambdabot> Couldn't find qualified module.
19:02:29 <copumpkin> :t runCont . sequence . map Cont . map (Control.Exception.bracket ?x ?y)
19:02:30 <lambdabot>     Couldn't match expected type `(a -> r) -> r'
19:02:30 <lambdabot>            against inferred type `IO c'
19:02:30 <lambdabot>     In the first argument of `map', namely
19:02:33 <copumpkin> bah
19:03:15 <_andy_> too bad its not possible to have a general bracket :: Monad m => ...
19:03:51 <kmc> it's not clear what that would do
19:03:56 <_andy_> though as i say that the uses seem diminished
19:03:58 <_andy_> yeah
19:04:08 <copumpkin> kmc: trying to figure it out :)
19:04:17 <copumpkin> kmc: the last bit is Contish
19:04:36 <copumpkin> just trying to get it to fit
19:05:08 <copumpkin> :T runCont . sequence . map Cont $ map (Control.Exception.bracket ?x) ?xs
19:05:12 <copumpkin> :t runCont . sequence . map Cont $ map (Control.Exception.bracket ?x) ?xs
19:05:14 <lambdabot> forall a b c. (?x::IO a, ?xs::[a -> IO b]) => ([a] -> IO c) -> IO c
19:05:15 <copumpkin> that's what I meant
19:05:19 <ColonelJ> > let euler26 n = foldl (\(max,e) (m,x) -> if m > max then (m,x) else (max,e)) (0,0) (map (\x -> if coprimefactor x 10 > 1 then (morder 10 (coprimefactor x 10) 10 1, x) else 0) [2..n]) where morder _ _ 1 o = o ; morder x b m o = morder x b (x*m `mod` b) (o+1) ; coprimefactor a b = if gcd a b == 1 then a else coprimefactor (a `div` (gcd a b)) b in euler26 1000
19:05:21 <lambdabot>   No instance for (GHC.Num.Num (t1, t))
19:05:21 <lambdabot>    arising from a use of `euler26' at...
19:05:41 <CalJohn> > "fail"
19:05:42 <lambdabot>   "fail"
19:05:51 <CalJohn> ;)
19:06:09 <ColonelJ> what did I do wrong now
19:06:21 <kmc> too much euler
19:06:29 <kmc> euler? but i just met her!
19:06:45 <aavogt> like an owl
19:07:15 <aavogt> > tails "euler"
19:07:16 <lambdabot>   ["euler","uler","ler","er","r",""]
19:07:29 <ezyang> Is there a sort of "reverse Writer" monad?
19:07:31 <aavogt> > inits "euler"
19:07:32 <lambdabot>   ["","e","eu","eul","eule","euler"]
19:07:33 <kmc> > tails "echo"
19:07:34 <lambdabot>   ["echo","cho","ho","o",""]
19:07:43 <kmc> co-Writer comonad?
19:07:53 <ezyang> snerk
19:07:57 <kmc> ezyang, what would it do?
19:08:13 <ezyang> It'd let you read out values from some sort of "queue".
19:08:15 <aavogt> ezyang: so   Writer . Dual  ?
19:08:22 <kmc> ezyang, you can write that with State
19:08:29 <ezyang> yeah, but I don't wanna :-)
19:08:31 <aavogt> (to abuse the syntax)
19:08:37 <kmc> but the "reading" also has side effects
19:08:49 <ezyang> yep
19:08:52 <kmc> so it's not a perfect dual -- the queue type appears on both sides of the underlying function
19:08:54 <ColonelJ> > map (\x:y:zs-> x + y) . tails [1..100]
19:08:55 <lambdabot>   <no location info>: parse error on input `:'
19:09:07 <ColonelJ> > map (\x:y:zs -> x + y) . tails [1..100]
19:09:09 <lambdabot>   <no location info>: parse error on input `:'
19:09:22 <aavogt> > map (\(x:y:zs) -> x + y) . tails [1..100]
19:09:23 <lambdabot>   No instance for (GHC.Enum.Enum [t])
19:09:24 <lambdabot>    arising from the arithmetic sequence...
19:09:26 <copumpkin> $
19:09:30 <xerox> f . g $ xs
19:09:38 <ColonelJ> > map (\x:y:zs -> x + y) . tails $ [1..100]
19:09:39 <lambdabot>   <no location info>: parse error on input `:'
19:09:42 <aavogt> > map (\(x:y:zs) -> x + y) . tails $ [1..100]
19:09:44 <lambdabot>   [3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53,...
19:10:03 <aavogt> > [3,5..100]
19:10:05 <lambdabot>   [3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53,...
19:10:17 <ColonelJ> > map (\(x:y:zs) -> x * y) . tails $ [1..100]
19:10:18 <lambdabot>   [2,6,12,20,30,42,56,72,90,110,132,156,182,210,240,272,306,342,380,420,462,5...
19:11:23 <ColonelJ> hint: it's a quadratic
19:11:26 <aavogt> > (zipWith (*) `ap` tail) [1..100] -- this is cleaner with respect to the last digits erroring out
19:11:28 <lambdabot>   [2,6,12,20,30,42,56,72,90,110,132,156,182,210,240,272,306,342,380,420,462,5...
19:12:10 <ColonelJ> :t ap
19:12:12 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
19:12:31 <pikhq> > zipWith(*)`ap`tail$[1..100] -- Not to mention golfier.
19:12:32 <lambdabot>   [2,6,12,20,30,42,56,72,90,110,132,156,182,210,240,272,306,342,380,420,462,5...
19:12:48 <aavogt> here the m is    c ->
19:13:13 <xerox> > [x*x+x|x<-[1,3..]]
19:13:14 <lambdabot>   [2,12,30,56,90,132,182,240,306,380,462,552,650,756,870,992,1122,1260,1406,1...
19:13:30 <pikhq> xerox: No cigar for you.
19:13:31 <xerox> too much :)
19:13:46 <xerox> take them all [x*x+x|x<-[1,2..]]
19:15:21 * pikhq is still fond of the Aztec god of consecutive numbers.
19:15:23 <pikhq> > zip`ap`tail $ [1..10]
19:15:24 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10)]
19:15:32 <kmc> pikhq, who's that?
19:15:35 <idnar> @oeis 2 6 12 20
19:15:36 <lambdabot>  Oblong (or promic, pronic, or heteromecic) numbers: n(n+1).
19:15:37 <lambdabot>  [0,2,6,12,20,30,42,56,72,90,110,132,156,182,210,240,272,306,342,380,420,462,...
19:15:39 <kmc> oh hehe
19:15:53 <ColonelJ> > zipWith (^) `ap` tail $ [1..100]
19:15:55 <lambdabot>   [1,8,81,1024,15625,279936,5764801,134217728,3486784401,100000000000,3138428...
19:16:06 <idnar> @quote aztec
19:16:06 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
19:16:14 <xerox> very oblong numbers? :P
19:16:23 <xerox> @oeis 1,8,81,1024,15625,279936
19:16:24 <lambdabot>  n^(n+1).
19:16:24 <lambdabot>  [0,1,8,81,1024,15625,279936,5764801,134217728,3486784401,100000000000,313842...
19:16:46 <copumpkin> wow
19:16:50 <ColonelJ> kind of obvious
19:17:00 <ColonelJ> but heh
19:17:04 <copumpkin> sometimes I think someone defined a simple grammar of mathematical expressions, enumerated the grammar and put them into OEIS
19:17:35 <xerox> there also are all sorts of different formulas and names, links to articles..
19:18:35 <ColonelJ> let copyaddone x = x ++ copyaddone map (+1) x in copyaddone [1]
19:18:48 <ColonelJ> > let copyaddone x = x ++ copyaddone map (+1) x in copyaddone [1]
19:18:49 <lambdabot>   Couldn't match expected type `(b -> b) -> [b] -> [b]'
19:18:49 <lambdabot>         against infer...
19:19:23 <Absolute0> Does ghci have any command to list all functions of a type? using :info class_type recursively is tedious
19:19:29 <ColonelJ> > let copyaddone x = x ++ copyaddone (map (+1) x) in copyaddone [1]
19:19:30 <Saizan> copyaddone map (+1) x gives map, (+1) and x as arguments to copyaddone
19:19:31 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
19:19:48 <ColonelJ> > let copyaddone x = x ++ copyaddone (x ++ map (+1) x) in copyaddone [1]
19:19:50 <lambdabot>   [1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,3,...
19:20:13 <Saizan> Absolute0: all functions with a given type? try hoogle
19:20:17 <ColonelJ> @oeis 1,1,2,1,2,2,3,1,2,2,3,2,3,3,4
19:20:17 <lambdabot>  1's-counting sequence: number of 1's in binary expansion of n (or the binary...
19:20:18 <lambdabot>  [0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,3...
19:21:11 <Absolute0> Is truncate the most effecient way of casting a Fractional into a num?
19:21:32 <Absolute0> s/Num/Int
19:21:35 <Saizan> ?type truncate
19:21:36 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
19:22:04 <Absolute0> s/Num/Integral
19:22:05 <Absolute0> :-P
19:22:33 <Absolute0> maybe after a week I'll get the freaking math types. :(
19:22:41 <kmc> the most efficient way is probably some godawful hack as usual
19:22:54 <Absolute0> I mean is truncate the normal thing to do?
19:22:56 <Absolute0> for casting?
19:22:59 <ColonelJ> > let copyaddone x = copyaddone (x ++ map (+1) x) in copyaddone [1]
19:23:05 <lambdabot>   mueval: ExitFailure 1
19:23:06 <Absolute0> Double-> Int
19:23:12 <Saizan> Absolute0: yes, it is
19:23:14 <kmc> :t truncate
19:23:16 <Absolute0> ok thanks
19:23:19 <ColonelJ> heh I made haskell fail
19:23:20 <kmc> @bot
19:23:20 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
19:23:20 <lunabot>  :o
19:23:20 <lambdabot> :)
19:23:24 <kmc> :t floor
19:23:25 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
19:23:30 <Absolute0> in other languages you just do (int) foo
19:23:38 <Absolute0> truncate seems a bit obscure
19:23:40 <kmc> no, in C you do that
19:23:44 <ColonelJ> > let copyaddone x = copyaddone (x ++ map (+1) x) ++ [] in copyaddone [1]
19:23:44 <Absolute0> but more explicit
19:23:47 <lambdabot>   * Exception: stack overflow
19:23:54 <kmc> there's more than one way to convert a float to an int
19:23:59 <kmc> it's silly to assign one as the one true w ay
19:24:05 <pikhq> Absolute0: The semantics of (int)foo round either up or down.
19:24:13 <kmc> it only makes sense if you want to do implicit conversions, which we avoid
19:24:22 <pikhq> And if you want a specific one, you need to use libc functions for the explicit conversion.
19:24:33 <ColonelJ> hmm haskell doesn't understand that definition :(
19:24:47 <kmc> it understands it, but your recursion is infinite
19:24:55 <pikhq> ColonelJ: Oh, it's understood.
19:25:01 <ColonelJ> kmc: yes but the first element of the list can be determined
19:25:02 <pikhq> It even helpfully tried to evaluate it.
19:25:07 <ColonelJ> haskell failed to do so
19:25:23 <pikhq> ColonelJ: No it can't.
19:25:37 <ColonelJ> pikhq: why not?
19:25:49 <ColonelJ> the start of the list never changes
19:25:53 <kmc> > let x = x in x
19:25:56 <pikhq> The first element is the first element of copyaddone (x++map(+1)x). The first element of that is the first element of copyaddone(x++map(+1)x). The first element of that is...
19:25:57 <lambdabot>   mueval-core: Time limit exceeded
19:26:08 <kmc> it's unspecified
19:26:14 <Saizan> you never give a concrete definition for the start copyaddone should produce
19:26:15 <pikhq> ColonelJ: What's the first element of the list?
19:26:17 <kmc> recursion gives the least fixed point of your function
19:26:26 <kmc> and the least fixed point of an unspecified value is an infinite loop
19:26:27 <Saizan> you just give a definition for the argument of copyaddone
19:26:29 <ColonelJ> it's the first element of the input
19:26:41 <pikhq> No, it's not.
19:26:43 <kmc> > let x = x ++ [1] in x
19:26:46 <Saizan> ColonelJ: your code doesn't say that
19:26:47 <lambdabot>   mueval-core: Time limit exceeded
19:26:48 <kmc> > let x = 1 : x in x
19:26:50 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
19:26:56 <ColonelJ> Saizan: no but that's what it logically is
19:27:05 <pikhq> ColonelJ: No it's not.
19:27:09 <Absolute0> why do haskell casting functions use the conversion fromXXXX instead of toXXXX? Isn't the latter more clear?
19:27:10 <Saizan> ColonelJ: i don't see any way to interpret it like that, really
19:27:17 <pikhq> ColonelJ: Would doing the graph reduction help?
19:27:21 <kmc> Absolute0, it seems unlikely, by symmetry
19:27:37 <ColonelJ> I think I know why haskell can't determine it
19:27:49 <kmc> ColonelJ, you're asking the system to solve an underspecified equation
19:27:52 <kmc> > let x = x in x
19:27:56 <kmc> > fix id
19:27:56 <lambdabot>   mueval-core: Time limit exceeded
19:28:01 <lambdabot>   mueval-core: Time limit exceeded
19:28:03 <kmc> *any* value is a fixed point of id, but it still fails
19:28:09 <ColonelJ> kmc: it's not thte same
19:28:11 <kmc> because the *least* defined fixed point is totally undefined
19:28:23 <Absolute0> http://www.haskell.org/hoogle/?hoogle=to <- blank page :(
19:28:27 <Absolute0> firefox and ie
19:28:39 <ColonelJ> there's only one infinite list that satisfies copyaddone
19:28:39 <kmc> :t toRational
19:28:41 <lambdabot> forall a. (Real a) => a -> Rational
19:28:46 <kmc> :t toInteger
19:28:47 <lambdabot> forall a. (Integral a) => a -> Integer
19:29:05 <ColonelJ> copyaddone [1] I mean
19:29:09 <kmc> Absolute0, when one type is concrete and the other a typeclass constrained polymorphic variable, it makes sense to name the concrete type
19:29:12 <ColonelJ> which is
19:29:14 <copumpkin> ColonelJ: haskell can't solve equations for you
19:29:15 <pikhq> Here: copyaddone [1] -> copyaddone([1]++map(+1)[1])++[] -> copyaddone((copyaddone([1]++map(+1)[1])++[])++map(+1)(copyaddone([1]++map(+1)[1])++[])) -> ... No more.
19:29:21 <ColonelJ> @oeid 1,2,2,3,2,3,3,4
19:29:22 <kmc> in situations where both are polymorphic it's a little more arbitrary
19:29:22 <lambdabot>  1's-counting sequence: number of 1's in binary expansion of n (or the binary...
19:29:23 <lambdabot>  [0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,3...
19:29:33 <kmc> @oeis 1,3,3,7
19:29:33 <lambdabot>  a(0) = 0; for n > 0, a(n) = number of proper divisors of n.
19:29:34 <lambdabot>  [0,0,1,1,2,1,3,1,3,2,3,1,5,1,3,3,4,1,5,1,5,3,3,1,7,2,3,3,5,1,7,1,5,3,3,3,8,1...
19:29:35 <ColonelJ> not that one
19:29:50 <kmc> @oeis 4,4,4,4,4,4,4,4,4,4,4
19:29:51 <lambdabot>  Log_2(n) rounded down.
19:29:51 <lambdabot>  [0,1,1,2,2,2,2,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5...
19:29:55 <copumpkin> lol
19:30:03 <ColonelJ> I've decided that oeis fails
19:30:11 <kmc> @oes 8,6,7,5,3,0,9
19:30:12 <lambdabot>  From the words to the song "Jenny's Letterbox" by Tommy Tutone.
19:30:12 <Saizan> copyaddone x = copyaddone (x ++ map (+1) x) ++ []<- if i say that copyaddone [1] starts with (4: ..), which equation do i violate?
19:30:12 <lambdabot>  [8,6,7,5,3,0,9,8,6,7,5,3,0,9,8,6,7,5,3,0,9,8,6,7,5,3,0,9,8,6,7,5,3,0,9,8,6,7...
19:30:24 <Absolute0> when I se copumpkin I am tempted to read cucumber :(
19:30:27 <Absolute0> see
19:30:34 <edwardk> a fun little excursion in monad building: http://www.haskell.org/pipermail/haskell-cafe/2010-January/071726.html
19:30:36 <copumpkin> read cucurbita instead
19:30:42 <hiptobecubic> what are you wizards even doing here? what is going on
19:30:45 <Absolute0> :-P
19:31:06 <kmc> edwardk, whaaat
19:31:18 <kmc> what does it do
19:31:31 <Saizan> btw ++ [] is id
19:31:41 <edwardk> kmc: backtracking monad with a store that tells you if a reference is used in the remainder of the computation.
19:31:43 <kmc> hiptobecubic :D
19:32:28 <ColonelJ> > let copyaddone p x = p ++ copyaddone x ( map (+1) x) in copyaddone [] [1]
19:32:29 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
19:32:35 <ColonelJ> oops
19:32:43 <ColonelJ> > let copyaddone p x = p ++ copyaddone (p++x) ( map (+1) x) in copyaddone [] [1]
19:32:45 <lambdabot>   [1,1,2,1,2,3,1,2,3,4,1,2,3,4,5,1,2,3,4,5,6,1,2,3,4,5,6,7,1,2,3,4,5,6,7,8,1,...
19:33:01 <edwardk> kmc: so you can say do x <- newRef "hello"; needed <- needRef x; big computation involving x that may or may not call readRef before the current value is overwritten
19:33:09 <ColonelJ> > let copyaddone p x = p ++ copyaddone (p++x) ( map (+1) (p++x)) in copyaddone [] [1]
19:33:11 <lambdabot>   [1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,3,...
19:33:14 <copumpkin> edwardk: that's neat
19:33:40 <pikhq> ColonelJ: There you go.
19:33:48 <edwardk> it'd be slicker with a cute little continuation passing style implementation, but the list based one was faster to write =)
19:33:48 <ColonelJ> > let copyaddone p x = p ++ copyaddone x ( map (+1) (p++x)) in copyaddone [] [1]
19:33:50 <lambdabot>   [1,2,2,3,3,3,4,3,4,4,4,5,4,4,5,4,5,5,5,6,4,5,5,5,6,5,5,6,5,6,6,6,7,5,5,6,5,...
19:33:56 <ColonelJ> nah this one is it
19:34:08 <ColonelJ> @oeid 1,2,2,3,3,3,4,3,4,4,4,5,4,4,5,4,5,5,5,6,4,5,5,5,6,5,5,6,5,6,6,6,7,5,5,6,5
19:34:08 <lambdabot>  Sequence not found.
19:34:11 <pikhq> Well, then.
19:34:13 <ColonelJ> fail
19:34:32 <hiptobecubic> lambdabot can recognize sequences?
19:34:35 <edwardk> its a bit smarter than the monad the guy was actually looking for, because it gives exact result, but hey
19:34:54 <QtPlaty[HireMe]> hiptobecubic: Sort of.
19:34:56 <kmc> hiptobecubic, it just searches OEIS
19:34:58 <kmc> @google oeis
19:34:59 <pikhq> hiptobecubic: No, but it can search a directory of them.
19:35:00 <lambdabot> http://www.research.att.com/~njas/sequences/
19:35:00 <lambdabot> Title: The On-Line Encyclopedia of Integer Sequences
19:35:05 <hiptobecubic> ahh ok
19:35:13 <ColonelJ> I'm pretty sure the sequence is in there
19:35:17 <ColonelJ> @oeid 1,2,2,3,3,3,4,3,4,4,4,5,4,4,5,4,5,5,5,6,4,5,5,5
19:35:18 <lambdabot>  Sequence not found.
19:35:20 <ColonelJ> @oeid 1,2,2,3,3,3,4,3,4,4,4,5,4,4,5,4,5,5,5
19:35:21 <lambdabot>  Sequence not found.
19:35:24 <ColonelJ> @oeid 1,2,2,3,3,3,4,3,4,4,4
19:35:25 <lambdabot>  The size of the parenthesizations obtained with the global ranking/unranking...
19:35:25 <lambdabot>  [1,2,2,3,3,3,4,3,4,4,4,4,3,4,5,4,5,4,4,4,5,5,5,4,4,5,5,5,5,5,5,5,5,5,5,4,5,4...
19:35:44 <edwardk> now an even more interesting monad would be one that was smart enough to have a reallyNeedRef that answered not only if you called readRef, but if you actually forced the answer ;)
19:36:22 <copumpkin> sounds really hackish :P
19:36:22 <ColonelJ> > let copyaddone p x = p ++ copyaddone x ( map (+1) (p++x)) in copyaddone [] [0]
19:36:24 <lambdabot>   [0,1,1,2,2,2,3,2,3,3,3,4,3,3,4,3,4,4,4,5,3,4,4,4,5,4,4,5,4,5,5,5,6,4,4,5,4,...
19:36:27 <Absolute0> Why can't ghc handle cyclic dependencies?
19:36:38 <Absolute0> I think Java doesn't complain about that.
19:36:48 <edwardk> copumpkin: yeah
19:36:49 <copumpkin> Absolute0: because nobody felt like adding support for them beyond hs-boot
19:37:03 <ColonelJ> actually no something is still wrong
19:37:09 <edwardk> Absolute0: because they aren't a major pain point
19:37:36 <Absolute0> can't ghc do a simple #ifndef internally?
19:37:42 <Absolute0> like c does
19:37:49 <Absolute0> not sure why leave that feature out
19:38:07 <edwardk> Absolute0: not quite that simple c has all sorts of forward declaration magic it makes you do anyways
19:38:20 <ColonelJ> > let copyaddone p x = x ++ copyaddone x ( map (+1) (p++x)) in copyaddone [] [0]
19:38:22 <lambdabot>   [0,1,1,2,2,2,3,2,3,3,3,4,3,3,4,3,4,4,4,5,3,4,4,4,5,4,4,5,4,5,5,5,6,4,4,5,4,...
19:38:31 <edwardk> and we have instances going back and forth that the compiler needs to know, template haskell that needs to be staged
19:38:32 <Absolute0> edwardk: what are some of the complications in haskell for doing that?
19:38:33 <ColonelJ> > let copyaddone p x = x ++ copyaddone x ( map (+1) (p++x)) in copyaddone [] [1]
19:38:34 <lambdabot>   [1,2,2,3,3,3,4,3,4,4,4,5,4,4,5,4,5,5,5,6,4,5,5,5,6,5,5,6,5,6,6,6,7,5,5,6,5,...
19:39:12 <ColonelJ> > let copyaddone p x = x ++ copyaddone (p++x) ( map (+1) (p++x)) in copyaddone [] [1]
19:39:14 <lambdabot>   [1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,2,3,3,4,3,...
19:39:21 <ColonelJ> THAT'S it
19:39:28 <ColonelJ> @oeid: 1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,2,3,3,4,3
19:39:29 <lambdabot>  1's-counting sequence: number of 1's in binary expansion of n (or the binary...
19:39:29 <lambdabot>  [0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,3...
19:39:59 <copumpkin> ColonelJ: eww, ++ :P
19:40:16 <ColonelJ> absolutely required
19:40:23 <edwardk> Absolute0: Plus there are lesser concerns that might bite them: (.) has different meaning depending on whether or not it can figure out that something is a namespace or not, you don't know the full signatures of the symbols you're linking to, all sorts of things
19:40:36 <copumpkin> ColonelJ: now write it as an unfold
19:40:38 <ColonelJ> copumpkin: the bits get bigger as they go along
19:41:25 <Absolute0> edwardk: I am sure there are simple compiler libraries to take care of that.
19:41:45 <Absolute0> I guess haskell just wants to be explicit
19:41:49 <ColonelJ> I don't know unfold
19:41:51 <ColonelJ> :t unfold
19:41:53 <lambdabot> Not in scope: `unfold'
19:41:53 <Absolute0> following the pythonic way
19:41:56 <copumpkin> :t unfoldr
19:41:57 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
19:42:08 <copumpkin> ColonelJ: it builds a list out of a seed value
19:42:17 <edwardk> Absolute0: hs-boot lets you break these cycles when they do occur
19:42:23 <edwardk> at least, within a package
19:42:41 <aavogt> > [False..] -- edwardk
19:42:43 <lambdabot>   <no location info>: parse error on input `]'
19:42:57 <edwardk> aavogt: ?
19:43:00 <aavogt> it doesn't parse differently whether False is a module or constructor
19:43:15 <ColonelJ> unfold (\x x ++ map (+1) x) [1]
19:43:23 <ColonelJ> > unfold (\x x ++ map (+1) x) [1]
19:43:24 <lambdabot>   <no location info>: parse error on input `++'
19:43:29 <copumpkin> unfoldr, and ->
19:43:30 <aavogt> oh, but meaning isn't the same as the AST, edwardk?
19:43:30 <ColonelJ> > unfold (\x -> x ++ map (+1) x) [1]
19:43:32 <lambdabot>   Not in scope: `unfold'
19:43:36 <ColonelJ> > unfoldr (\x -> x ++ map (+1) x) [1]
19:43:39 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe (a, [a1])'
19:43:39 <lambdabot>         against i...
19:43:43 <ColonelJ> > unfoldl (\x -> x ++ map (+1) x) [1]
19:43:45 <lambdabot>   Not in scope: `unfoldl'
19:43:58 <edwardk> the parsing of . is uglified by the existence of hierarchical modules, which were retrofitted onto haskell 98.
19:44:01 <ColonelJ> wait a minute
19:44:12 <ColonelJ> why do you get a pair in the function
19:44:24 <copumpkin> ColonelJ: you spit out a value for the list and a new seed
19:44:41 <ColonelJ> > unfoldl (\x -> (x,x ++ map (+1) x)) [1]
19:44:42 <lambdabot>   Not in scope: `unfoldl'
19:44:46 <ColonelJ> > unfoldr (\x -> (x,x ++ map (+1) x)) [1]
19:44:47 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe (a, [a1])'
19:44:47 <lambdabot>         against i...
19:45:03 <ColonelJ> maybe an example
19:45:05 <copumpkin> > unfoldr (\x -> Just (x,x ++ map (+1) x)) [1]
19:45:07 <lambdabot>   [[1],[1,2],[1,2,2,3],[1,2,2,3,2,3,3,4],[1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5],[1...
19:45:07 <Saizan> edwardk: that Oracle monad would actually be feasible with say, hundreds of variables and a comparable number of reads?
19:45:18 <ColonelJ> ah thanks
19:45:19 <edwardk> from http://www.haskell.org/hierarchical-modules/hier.pdf : With the hierarchical module namespace extension, A.B.C.D would instead be interpreted as the
19:45:19 <edwardk> identixc;er D from module A.B.C. If the original Haskell 98 interpretation is intended, then it must
19:45:19 <edwardk> be written with extra spaces, as A.B . C.D.
19:45:25 <ColonelJ> that's not quite the list required though
19:45:35 <ColonelJ> :t append
19:45:36 <lambdabot> Not in scope: `append'
19:45:52 <edwardk> Saizan: it backtracks at most once per 'needRef', because it monotonically heads towards 'True'
19:45:53 <copumpkin> > unfoldr (\x -> Just (x ++ map (+1) x, x)) [1]
19:45:55 <lambdabot>   [[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1...
19:45:58 <copumpkin> :P
19:46:12 <copumpkin> ColonelJ: well it's up to you to write the correct unfold!
19:46:13 <ColonelJ> > fold (++) [] unfoldr (\x -> (x,x ++ map (+1) x)) [1]
19:46:14 <lambdabot>   Not in scope: `fold'
19:46:15 <edwardk> Saizan: unfortunately i can't provide a much tighter backtracking guarantee than that
19:46:31 <ColonelJ> > foldr (++) [] unfoldr (\x -> (x,x ++ map (+1) x)) [1]
19:46:33 <lambdabot>   Couldn't match expected type `[[a]]'
19:46:33 <lambdabot>         against inferred type `(b -> D...
19:46:58 <ColonelJ> > foldr (\x y -> y ++ x) [] unfoldr (\x -> (x,x ++ map (+1) x)) [1]
19:46:58 <copumpkin> > foldr (++) [] . unfoldr (\x -> (x,x ++ map (+1) x)) $ [1]
19:47:00 <lambdabot>   Couldn't match expected type `[[a]]'
19:47:00 <lambdabot>         against inferred type `(b -> D...
19:47:00 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe ([a], [a1])'
19:47:00 <lambdabot>         against...
19:47:04 <aavogt> edwardk: I didn't see that as the problem, thanks for pointing it out
19:47:09 <ColonelJ> > foldr (\x y -> y ++ x) [] . unfoldr (\x -> (x,x ++ map (+1) x)) [1]
19:47:10 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe ([[a]], [a1])'
19:47:10 <lambdabot>         again...
19:47:12 <edwardk> Saizan: it also should fail pretty fast and maintain small worlds, because needRef is pretty pessimistic
19:47:14 <copumpkin> > foldr (++) [] . unfoldr (\x -> Just (x,x ++ map (+1) x)) $ [1]
19:47:16 <lambdabot>   [1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,3,...
19:47:25 <copumpkin> hylo?
19:47:54 <ColonelJ> wait that unfold was wrong
19:48:04 <copumpkin> anyway, /me goes to sleep
19:48:06 <copumpkin> :P
19:48:12 <ColonelJ> I don't see how it can be done
19:48:20 <ColonelJ> it's not an unfold
19:48:46 <ColonelJ> the answer is the last element of the unfold I wrote
19:49:06 <ColonelJ> well the answer is the nth element as n -> infinity
19:49:20 <ColonelJ> which is the same problem I had before
19:49:27 <edwardk> Saizan: a more interesting monad would be to figure out a way to make a resumable continuation where you assume that you're given the exact same environment you had originally and try to skip ahead in the monad to the answer. i'm thinking something like fluet's recent research with umut acar
19:49:37 <ColonelJ> night folks
19:51:23 <Saizan> edwardk: ah, yeah, the memoization part of their language
19:51:32 <edwardk> yeah
19:52:10 <Absolute0> How do you do "(Foo a) => " in data definitions? Data Bar a = ...; type BarFoo = Bar Foo?
19:52:13 <edwardk> give an explicit memoization combinator that tracked the store locations read/written, and add a constraint on the contents of ref cells that they be serializable
19:52:18 <Absolute0> Is there a quicker way?
19:52:44 <edwardk> Absolute0: you can add them to data definitions, but you really should place them in instances.
19:52:58 <Absolute0> ah right, instances...
19:53:10 <edwardk> data Bar a = Bar a; instance Foo a => Monad Bar where ...
19:53:20 <edwardk> er
19:53:31 <Absolute0> How do you add them to data definitions?
19:53:36 <edwardk> data Bar a b = Bar a b; instance Foo a => Monad (Bar a) where ...
19:53:41 <Absolute0> before the constructor?
19:54:14 <shepheb> what's the modern library for handling timestamps?
19:54:20 <edwardk> well, the problem is all they do is create an obligation, they don't actually come along for the ride unless you start doing existentials, etc.
19:55:16 <Saizan> edwardk: in their ML lib the memoization combinator were just given what to use as keys, you're considering one where the combinator itself finds them?
19:56:03 <edwardk> Saizan: more or less. i just looked at the greek symbols, not the actual implementation, so i wasn't sure how they fished them out
19:56:17 <edwardk> Saizan: heh, i have another option
19:56:44 <edwardk> Saizan: you could make the memo combinator take the explicit list of references that it exposes, because you rebrand it with another region, so you can only reference the ones supplied
19:57:17 <Saizan> nice
19:57:54 <edwardk> foo = do x <- newRef 12; y <- newRef "hello"; memo x y $ \x' y' -> computation ... -- using a bit of type class magic to make it plumb through an arbitrary number of arguments like that
19:58:47 <Saizan> but what if you "foo = do a <- readRef ra; memo x y $ \x' y' -> computation a"?
19:59:14 <edwardk> you did the readRef before the computation, so that event has already discharged, memo doesn't care
19:59:27 <edwardk> no store events occur inside memo
20:00:14 <Saizan> yeah, but 'a' is used inside it, so it could give a different result even if x and y contain the same values?
20:00:31 <edwardk> Saizan: oh, btw- regarding the efficiency of that quick hack, the version i thought would be more fun would be to actually use real STRefs, but to track a Seq of IO actions to use to unroll the heap to a previous state
20:00:44 <Saizan> (so memoizing is not sound anymore?)
20:01:11 <edwardk> hrmm, the strength of haskell monads might bite you
20:01:35 <edwardk> er a Seq of ST s actions i mean
20:02:04 <edwardk> basically every writeRef would track the equivalent undo action.
20:02:23 <edwardk> ironically this could probably all take place in a huge STM action
20:02:30 <edwardk> and just use the orElse machinery
20:02:47 <luite> I have a function of type:  (XmlArrow a) => a (XmlTree,(String->String)) XmlTree    and want to apply:  changeAttrValue::(XmlArrow a) => (String -> String) -> a XmlTree XmlTree
20:02:50 <Saizan> hah, true
20:02:52 <luite> how can I apply this thing?
20:03:41 <Saizan> luite: you need ArrowApply
20:04:05 <Saizan> ?type apply
20:04:06 <lambdabot> Not in scope: `apply'
20:04:10 <byorgey> @type app
20:04:11 <xerox> ?type app
20:04:11 <lambdabot> forall (a :: * -> * -> *) b c. (ArrowApply a) => a (a b c, b) c
20:04:12 <lambdabot> forall (a :: * -> * -> *) b c. (ArrowApply a) => a (a b c, b) c
20:04:57 <edwardk> going to try the STM version and see if i can make it work, coz it'd be a damn sight prettier
20:05:14 <luite> oh I was hoping to learn the arrow classes one at a time, but apparently you need a lot of them to get anything done :)
20:05:29 <Saizan> ?type let changeAttrValue::(XmlArrow a) => (String -> String) -> a XmlTree XmlTree; changeAttrValue = undefined; in arr changeAttrValue
20:05:33 <lambdabot>     Not in scope: type constructor or class `XmlArrow'
20:05:33 <lambdabot>     Not in scope: type constructor or class `XmlTree'
20:05:33 <lambdabot>     Not in scope: type constructor or class `XmlTree'
20:05:38 <Saizan> heh
20:06:15 <luite> yes sorry for the long names, I could have made a simpler example :)
20:07:03 <luite> that hxt thing takes a while you grasp if you haven't worked with arrows before
20:07:09 <Saizan> ?type let foo::(Arrow a) => (String -> String) -> a Int Int; foo = undefined; in arr foo
20:07:10 <lambdabot> forall (a :: * -> * -> *) (a1 :: * -> * -> *). (Arrow a, Arrow a1) => a1 (String -> String) (a Int Int)
20:07:18 <luite> *to grasp
20:08:13 <Saizan> ?type let foo::(Arrow a) => (String -> String) -> a Int Int; foo = undefined; in (arr foo *** arr id) >>> app
20:08:15 <lambdabot> forall (a :: * -> * -> *). (ArrowApply a) => a (String -> String, Int) Int
20:08:47 <Saizan> ?type let foo::(Arrow a) => (String -> String) -> a Int Int; foo = undefined; in (arr id *** arr foo) >>> app
20:08:48 <lambdabot> forall (cat :: * -> * -> *) (a :: * -> * -> *) c. (Arrow a, ArrowApply cat) => cat (cat (a Int Int) c, String -> String) c
20:09:01 <Saizan> oh, right
20:09:27 <Saizan> ?type let foo::(Arrow a) => (String -> String) -> a Int Int; foo = undefined; in (arr snd &&& arr fst) >>> (arr foo *** arr id) >>> app
20:09:28 <lambdabot> forall (a :: * -> * -> *). (ArrowApply a) => a (Int, String -> String) Int
20:09:47 <Saizan> proc notation would help :)
20:13:27 <edwardk> Saizan: heh, sadly i have to give up runOracle :: (forall s. Oracle s a) -> a -- if i make Oracle use STM
20:13:37 <edwardk> STM is unfortunately suicidal when run in an unsafePerformIO
20:13:43 <edwardk> it needs the 'real IO'
20:14:05 <edwardk> even though in this case its safe because none of the individual TVars are visible outside of that block
20:17:03 <kmc> hmm, why does STM need the real IO?
20:17:20 <kmc> @quote unsafePerformIO
20:17:20 <lambdabot> lilac says: ponders whether unsafePerformIO would be better as simonSaysPerformIO
20:17:22 <kmc> @quote unsafe
20:17:23 <lambdabot> int-e says: What, unsafeCoerce# is kind-preserving? how boring :/
20:17:33 <cord> what's wrong here ? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15679#a15679
20:17:43 <jaredj> i have a tree: data ParseTree = Compound String [ParseTree] | Simple String String. i want to turn each Compound into a value of a record type, filling in the fields from the Simples inside. But that requires a function that can return any of several types. that's rather difficult, right?
20:17:48 <kmc> cord,
20:17:49 <kmc> :t (>>=)
20:17:50 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
20:17:55 <kmc> the second arg here is mysqrt
20:17:57 <Saizan> edwardk: well, the solution is clearly to send the STM action to a preemptively forked thread, to evaluate and send back!
20:17:58 <kmc> does it have type a -> Maybe b?
20:18:02 <jaredj> (there are several record types)
20:18:04 <edwardk> kmc:  You cannot use atomically inside an unsafePerformIO or unsafeInterleaveIO. Any attempt to do so will result in a runtime error. (Reason: allowing this would effectively allow a transaction inside a transaction, depending on exactly when the thunk is evaluated.) -- from GHC.Conc
20:18:07 <kmc> you probably want (fmap mysqrt (Just 3))
20:18:15 <kmc> or (mysqrt <$> Just 3) equivalently
20:18:22 <pikhq> jaredj: Just make the function result in a typeclass?
20:18:45 <edwardk> Saizan: =)
20:18:49 <cord> kmc, i'm just fooling with the Cowboy tutorial, isn't Just 3 should unwrap 3 and pass it to mysqrt ?
20:18:51 <edwardk> i'll leave that as an exercise to the reader
20:19:06 <kmc> jaredj, to "return several types" you'd return a value of one type which has several constructors
20:19:12 <kmc> like Either, but you should make one for your case
20:19:35 <kmc> cord, do you understand the type of (>>=) ?
20:19:51 <Saizan> cord: >>= expects mysqrt to rewrap it again, but mysqrt doesn't
20:19:54 <kmc> in this case it's:  Maybe a -> (a -> Maybe b) -> Maybe b
20:20:18 <jaredj> pikhq: usually i've seen classes used to bring together types having a bit of shared meaning, but there are no operations common to all my record types. is that a bad thing?
20:20:31 <cord> Saizan, oh now it's working perfectly thanks
20:21:18 <sshc> what's the difference between Monoids and MonadPluss?
20:21:39 <aavogt> the kind
20:21:40 <jaredj> kmc: the records go like data OFXFile = { sonrs :: SignonResponse, date :: String }; data SignonResponse = { foo :: Bar, baz :: StatusRecord }, etc
20:21:45 <Saizan> MonadPlus requires Monad, and the kind
20:22:21 <jaredj> kmc: if I pulled it together I'd have to say data OFXThingy = OFXFile { sonrs :: OFXThingy, ...} | ...
20:22:47 <jaredj> kmc: but the sonrs should only be a SignonResponse. and the only way I know to enforce that is to make it its own type :/
20:23:34 <sshc> how do the kinds differ?
20:23:48 <aavogt> :k Maybe
20:23:49 <lambdabot> * -> *
20:23:54 <aavogt> :k ()
20:23:55 <lambdabot> *
20:24:07 <aavogt> sshc: Maybe is a MonadPlus, () is a monoid
20:24:15 <aavogt> *Monoid
20:24:25 <idnar> Maybe a is also a monoid
20:24:31 <mauke_> for some a
20:24:51 <aavogt> > Just undefined `mappend` Nothing
20:24:52 <lambdabot>   Just * Exception: Prelude.undefined
20:25:02 <aavogt> > Just undefined `mappend` Nothing :: Maybe a
20:25:04 <lambdabot>   Could not deduce (Data.Monoid.Monoid a) from the context ()
20:25:05 <lambdabot>    arising from...
20:25:17 <idnar> > Just 5 `mappend` Nothing
20:25:18 <lambdabot>   Ambiguous type variable `t' in the constraints:
20:25:18 <lambdabot>    `GHC.Num.Num t' arising ...
20:25:29 <idnar> > Just 5 `mappend` Nothing :: Maybe Integer
20:25:30 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Integer.Internals.Integer)
20:25:31 <lambdabot>    arisi...
20:25:37 <mauke_> > Just (Product 5) `mappend` Nothing
20:25:38 <lambdabot>   Just (Product {getProduct = 5})
20:25:40 <idnar> oh, right
20:25:46 <idnar> (Monoid a) => Monoid (Maybe a)
20:26:18 <idnar> MonadPlus and Monoid are basically completely different, even though they sometimes sort of do the same thing
20:26:48 <idnar> > Just [4] `mappend` Just [2]
20:26:49 <lambdabot>   Just [4,2]
20:26:56 <idnar> > Just [4] `mplus` Just [2]
20:26:58 <lambdabot>   Just [4]
20:27:51 <idnar> > [1,2] `mplus` [3,4]
20:27:53 <lambdabot>   [1,2,3,4]
20:28:11 <idnar> > [1,2] `mappend` [3,4]
20:28:12 <lambdabot>   [1,2,3,4]
20:32:53 <edwardk> Saizan: hrmm my stm version just hangs indefinitely. i must have screwed something up
20:33:27 <edwardk> @hpaste
20:33:28 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
20:33:31 <idnar> I suppose they're not completely different; mzero/mplus effectively form a monoid
20:34:02 <edwardk> Saizan: can you look at http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5968#a5968 real quick?
20:35:20 <edwardk> not sure why its hanging, the only retry's should come from needRef
20:38:29 <edwardk> ah the stm thing can't work i think. the retrys are very much localized
20:39:09 <edwardk> i'm only getting one 'retrying, not 3
20:40:28 <edwardk> of course, coz needRef completes successfully, the 'orElse' has very much the wrong scope
20:42:28 <edwardk> oh well, would have been pretty
20:42:48 <luite> oh I just found -<<, that makes using ArrowApply so much easier :)
20:44:17 <xerox> luite would you mind paste a sample of how things get better with proc notation?
20:45:07 <luite> bar = proc (x,y) -> foo y -<< x
20:46:02 <Saizan> edwardk: maybe with a CPS transform?
20:46:13 <edwardk> Saizan: yeah
20:46:27 <edwardk> Saizan: that was my first reaction as well, but then its not as pretty =)
20:46:57 <edwardk> plus i haven't quite figured out what the 'r' type is in this case
20:47:29 * hackagebot upload: tuntap 0.0.1 - Interface to TUN/TAP drivers. (JohnVanEnk)
20:47:34 <edwardk> i can codensity it, but then i know i can't call-cc =), so i can't just quantify it away
20:49:15 <freefreef> Hey check out this site with over 38000 free videos!! http:// www.myworldporn.com/
20:49:31 --- mode: ChanServ set +o xerox
20:49:32 <Saizan> maybe it's enough to call the continuation on both sides of orElse, though?
20:49:37 --- mode: xerox set +b *!*=freefree@*.103-56-74.mc.videotron.ca
20:49:40 --- kick: freefreef was kicked by xerox (xerox)
20:49:46 <edwardk> *nods*
20:49:47 --- mode: xerox set -o xerox
20:50:23 <newsham> it coulda been haskell pr0n
20:50:28 <edwardk> but what does that do to the Oracle type? i don't want to change the 'test' code
20:50:49 <o-_-o> newsham, you don't need to go to another site to see haskell porn
20:50:49 <Gracenotes> newsham: like, happstack-backed?
20:50:56 <augur> oh man 38000 free videos! :O
20:51:17 <augur> do these bots just go into every channel they find?
20:51:22 <edwardk> newtype Oracle s r a = Oracle { unOracle :: (a -> STM r) -> STM r } -- but then where does the r go?
20:51:28 <newsham> comonads and functors
20:51:30 <edwardk> i can flip it around into codensity STM form
20:52:16 <edwardk> and get newtype Oracle s a = Oracle { unOracle :: forall r. (a -> STM r) -> STM r } -- and then runOracle makes sense, just feed that 'return' for the STM monad and it pops out the right types
20:52:37 <edwardk> but i suspect due to the impossibility of call/cc with that type, that i still can't write the orElse I want.
20:55:04 <Saizan> test seems to work
20:55:11 <luite> xerox: this is where I use it (I could remove an extra function because of the more readable notation): http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=15680#a15680
20:55:16 <edwardk> Saizan: ?
20:55:17 <sproingie> topic says hackage is down, seems up to me
20:55:18 <Saizan> STMOracle> runOracle test
20:55:19 <Saizan> (False,False,True)
20:55:28 <edwardk> Saizan: what'd you change?
20:56:05 <jmcarthur> in javascript: '5' + 3 gives '53', but '5' - 3 gives 2   ... o_O
20:56:09 --- mode: ChanServ set +o xerox
20:56:10 <Saizan> edwardk: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5968#a5969
20:56:16 <jmcarthur> that's on the level of a PHP-ism
20:56:22 <Saizan> edwardk: just needRef
20:56:28 <edwardk> ah, k
20:56:29 <luite> xerox: code is untested, so I'm not sure if it actually does what I expect it to (but it typechecks, so it should, right?)
20:56:34 <edwardk> so the codensity was sufficient
20:56:38 <Saizan> yeah
20:56:45 <edwardk> cool
20:57:09 --- topic: set to '["hackage torrent @ http://bit.ly/4u5JwZ ","Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]' by xerox
20:57:09 <Saizan> it's not _so_ restrictive :)
20:57:17 <edwardk> yeah
20:57:20 <xerox> luite thanks
20:57:31 --- mode: xerox set -o xerox
20:57:41 <edwardk> well, codensity STM just says you can't write anything you couldn't have written with a whole program transformation in STM itself.
20:57:46 <edwardk> so i'm not surprised
20:57:47 <Veinor> does haskell have an eval?
20:57:52 <Veinor> jmcarthur: oh god, that's horrible
20:58:27 <sproingie> Veinor: not in the sense other languages do
20:58:55 <sproingie> > 1 + 1
20:58:56 <lambdabot>   2
21:00:16 <sproingie> can't plug that into arbitrary places in compiled code tho
21:01:46 <jmcarthur> Veinor: and '' == 0 gives false, but 0 == '' gives true
21:02:05 <sproingie> whah?
21:02:09 <jmcarthur> Veinor: and false == 'false' gives false, but false == '0' gives true
21:02:10 <xerox> jmcarthur also 1=="1"
21:02:25 <xerox> (the idea is never use ==, always ===)
21:02:34 * hackagebot upload: tuntap 0.0.2 - Interface to TUN/TAP drivers. (JohnVanEnk)
21:02:49 <augur> jmcarthur: what language is this?! :|
21:02:52 <edwardk> Saizan: that version should perform reasonably well actually.
21:02:53 <jmcarthur> i didn't realize javascript had so many PHP-isms
21:02:54 <sproingie> augur: php
21:03:01 <jmcarthur> sproingie: no, javascript
21:03:01 <augur> oh god that explains it
21:03:08 <jmcarthur> but php has similar problems
21:03:09 <augur> well th-- wait what
21:03:10 <sproingie> javascript's === pre-dates php
21:03:16 <sproingie> php's === is actually worse
21:03:19 <jmcarthur> yeah
21:03:30 <augur> i dont believe this about JS, jmcarthur
21:03:42 <jmcarthur> well, i'm reading this from a heavily upvoted stackoverflow post
21:03:44 <xerox> what was the thing about numbers...
21:03:49 <sproingie> javascript's === is like lisp's eq, php's === is a more brain damaged ==
21:03:54 <jmcarthur> i do not do enough javascript myself to say whether it's true
21:04:01 <sproingie> php's == behavior it gets from perl
21:04:17 <sproingie> i believe it has an eq operator for the same reason
21:04:17 <augur> oh, wait, yes i cant jmcarthur
21:04:25 <augur> its got to do with coercion
21:04:25 <sproingie> (php used to be a bunch of perl scripts)
21:04:29 <jmcarthur> augur: yes
21:04:32 <augur> when you do '' == 0
21:04:38 <augur> 0 is coerced to a string, namely, '0'
21:04:39 <jmcarthur> augur: not that that excuses it
21:04:47 <augur> when you do 0 == '', '' is coerced to a number, namely, 0
21:04:57 <augur> no, it doesnt excuse it at all
21:05:06 <augur> it should simply be false, with no coercion at all
21:05:06 <sproingie> left side dominates in javascript, it's one of those things you get used to.  like chronic pain.
21:05:14 <augur> but this is why you should always use === anyway
21:05:29 <jmcarthur> or why you should avoid javascript if possible ;)
21:05:40 <jmcarthur> i used to do PHP programming back in the day
21:05:44 <jmcarthur> not fun
21:05:44 <sproingie> so much good JIT research going into a language that's sheer crap
21:05:45 <augur> if you're coding dynamic web pages, it cant be avoided :(
21:06:04 <Veinor> jmcarthur: aggggh
21:06:04 <jmcarthur> actually, PHP was fun. i just didn't know any better
21:06:15 <augur> but this is why ive been considering designing a language that compiles into JS
21:06:25 <sproingie> i did a lot of php til i discovered how it was pass-by-copy by default
21:06:30 <jmcarthur> augur: we have a haskell->JS compiler around somewhere
21:06:34 <augur> :o
21:06:41 <sproingie> all my unit tests worked in isolation, then my integrations failed because i never realized this
21:06:50 <augur> i dont understand haskell well enough to use it for that
21:06:52 <jmcarthur> augur: based on YHC iirc
21:07:27 <sproingie> the only time i've picked up php since is to hack on some mediawiki plugin or another.  and boy do i hate it.
21:07:35 <augur> i'd like to see the code for it tho, jmcarthur
21:07:37 <augur> link?
21:08:18 <jmcarthur> augur: well, here's related material http://haskell.org/haskellwiki/Yhc/Javascript/Programmers_guide
21:08:31 <jmcarthur> augur: i don't know where the official page for it would be. maybe it's just YHC
21:09:02 <aep> are there any free books other then "real world haskell"?  i dont get it
21:09:17 <newsham> there are other free tutorials
21:09:27 <newsham> like two dozen easy lessons or learn me you a haskell
21:09:29 <augur> the language im contemplating is going to have auto-CPSification so that continuation-passing style for server requests is unnecessary
21:09:48 <xerox> There also is the Haskell wikibook
21:09:49 <aep> "learn you a haskell" is awesome, but only covers 1/100 of haskell
21:10:00 <sproingie> any tutorial is going to be like that
21:10:03 <Saizan> edwardk: the only problem is if the backtracking point for the variable you're reading is much higher in the tree, since you've to traverse all the orElse in the middle both ways, right?
21:10:17 <sproingie> lyah is incomplete but it's good on what it does cover
21:10:27 <aep> yeah
21:10:39 <aep> i read it, enjoyed it, but i still cant do haskell
21:10:43 <newsham> augur: so a continuation monad?
21:10:48 <sproingie> haskell wikibook is a real hodgepodge
21:11:06 <sproingie> i'd do lyah then rwh
21:11:07 <augur> newsham: no, just a compiler that knows whats calling out to the server and what's not
21:11:16 <xerox> sproingie what does that mean
21:11:26 <jmcarthur> oh gosh PHP:   "01e4" == "001e4" gives true
21:11:48 <sproingie> xerox: hodgepodge?  means it's all over the place, it's uneven and unpredictable
21:11:59 <aep> sproingie: i have serious problems following rwh. there are examples but he skips ALOT of details on the first few pages
21:12:31 <sproingie> aep: yeah i noticed that too.  i learned some from rwh but it was mostly reinforcing what i already knew
21:12:47 <sproingie> i started with the gentle introduction.  which is pretty awful but does actually have some good parts
21:12:50 <aep> where did you learn?
21:13:23 <sproingie> i knew a wee smidge of ML before haskell so that helped
21:13:52 <jmcarthur> honestly i didn't learn from any one source
21:14:02 <jmcarthur> i didn't have the patience to follow a "process" at all
21:14:06 <aep> aye. i've been locked in the other side of languages for the last 10 years :(
21:14:30 <aep> so i get depressed quickly if it takes me a week to build a hello world
21:14:39 <aep> a week i could have written an OS in C...
21:14:40 <jmcarthur> main = putStrLn "Hello, World!"
21:14:47 <jmcarthur> there you go!
21:14:48 <aep> heh yeah.
21:14:59 <sproingie> i can knock out hello world and small things quick in haskell, i still just dont know how to integrate things well
21:15:03 <newsham> it would have to be a very small OS
21:15:13 <newsham> even L4 is 10kloc
21:15:29 <aep> it was metaphorical... obviously i cant do that
21:15:35 <pikhq> newsham: You can do a DOS-alike in much less.
21:15:35 <sproingie> my main interest is games with a simulation bent (rpgs mostly) so i end up using a lot of iorefs, which is barely haskell
21:15:45 <newsham> DOS is hardly an OS
21:15:51 <jmcarthur> you can get a bootloader bashed out in less than a day pretty easily, and it gets more fun after that
21:15:53 <pikhq> Yes, but it is one.
21:15:53 <pikhq> ;)
21:16:14 <pikhq> jmcarthur: A day? Half an hour gets you a competent one.
21:16:26 <jmcarthur> pikhq: a day if you don't know what you're doing
21:16:26 <aep> jmcarthur: yeah, i wrote a curses gui in haskell, but i feel like i still know nothing
21:16:36 <pikhq> jmcarthur: Eh, fair enough.
21:16:48 <newsham> ?type putStrLn "hello world!"
21:16:48 <lambdabot> IO ()
21:21:29 <leimy> DOS is less of an OS, and more of an executive of interrupt handlers :-)
21:21:37 <leimy> also hi.
21:21:37 <sproingie> non-reentrant at that
21:21:55 <leimy> Got the job done surprisingly well back in the 80s. :-)
21:22:37 <sproingie> eh.  considering the machines it was made for didn't have a proper MMU, it did the best it could as a 16-bit CP/M clone
21:23:06 <leimy> newsham: which L4s have you looked at?
21:23:10 <sproingie> when the hardware advanced, the OS didn't catch up
21:23:15 <pikhq> leimy: Hey, it loads programs and provides a standard library. :)
21:23:22 <leimy> I've been meaning to try out UX-Fiasco
21:23:56 <leimy> pikhq: yeah if you stuck DOS on a virtualization system, you'd have almost the same thing as a bunch of exokernels per application.
21:24:08 <leimy> but DOS was so limited in capabilities.
21:24:14 <pikhq> sproingie: Sure it did. DOS became a *32-bit* CP/M clone.
21:24:21 <leimy> DOS was never 32bit
21:24:23 <pikhq> Well, hybrid 16-bit 32-bit.
21:24:33 <leimy> you had to run a 32bit protected mode server to get to 32bit mode
21:24:51 <leimy> it didn't prevent you from going 32bit :-)
21:24:52 <pikhq> I'm considering the 32-bit protected mode server part of later incarnations of DOS.
21:24:57 <newsham> leimy: i'm an sel4 spectator.  i havent used l4 much myself.
21:25:13 <leimy> pikhq: But those 32bit protected mode servers weren't part of DOS
21:25:25 <leimy> in fact the one that came with DJGPP was open source I think.
21:25:31 <leimy> that's the GNU toolchain for DOS.
21:25:51 <leimy> newsham: Yeah I've used a couple of them.  Fiasco for a GUI demo, and launched a bunch of Debians in it.
21:26:03 <leimy> Debian Linuxes that is.  They did paravirtualization.
21:26:17 <pikhq> leimy: The Dos Protected Mode Interface is the API for DOS extenders...
21:26:18 <leimy> And I've run Pistachio, and been meaning to try out OKL4
21:26:19 <newsham> huh, didnt know debian could run on l4
21:26:31 <leimy> newsham: this was many moons ago too.
21:26:34 <newsham> i've booted okl4 in qemu a few times, but havent gotten into the code
21:26:39 <leimy> There's probably still a demo floppy available :-)
21:26:39 * hackagebot upload: logict 0.4 - A backtracking logic-programming monad. (DanDoel)
21:26:40 <sproingie> l4linux was one of the first real uses of l4
21:26:49 <pikhq> leimy: Later DOS versions came with a DPMI server.
21:26:53 <sproingie> (which looks just like 14 in my font)
21:27:00 <leimy> pikhq: I wasn't aware of that.
21:27:09 <leimy> I must have stopped using it then :-)
21:27:16 <sproingie> DOS is more like an extended bios and bootloader
21:27:38 <leimy> newsham: http://os.inf.tu-dresden.de/~nf2/dope.html
21:27:44 <pikhq> DJGPP merely uses the API, and provides an implementation.
21:27:48 <leimy> That's not quite it though.. hmmm
21:27:50 <pikhq> (for the sake of DOSes without)
21:27:53 <sproingie> which in a way made it superior to OS's that tried to be an environment unto themselves
21:28:09 <sproingie> small OSs that is
21:28:21 <leimy> newsham: Check out the DROPS demo disk from this page --> http://os.inf.tu-dresden.de/fiasco/
21:28:26 <leimy> It might even still boot :-
21:28:38 <newsham> cool, thanks.
21:28:38 <sproingie> it could literally become anything, you weren't stuck with having to target DOS
21:29:03 <pikhq> Yeah, it could infact become Linux.
21:29:04 <leimy> It may not have the debian stuff anymore though.
21:29:07 <pikhq> (hooray, loadlin)
21:29:25 <leimy> I remember loadlin
21:29:34 <sproingie> pikhq: i'm thinking more of the 8088 days
21:30:02 * leimy grabs the floppy image and tries it in VMWare.
21:30:14 <newsham> i wonder how many orders of magnitude a modern bios or openfirmware is compared to DOS in 1985
21:30:20 <newsham> larger
21:30:30 <leimy> EFI is enormous :-)
21:30:42 <leimy> I believe Perl and Python and Emacs work in EFI.
21:30:47 <sproingie> PC bios serves kind of a different purpose nowadays
21:31:02 <newsham> there's microemacs in OFW (on oplpc at least)
21:31:26 <leimy> newsham: that's pretty wild.
21:31:34 <pikhq> sproingie: Hey, loadlin is still perfectly valid there.
21:31:35 <leimy> Is that still forth only?
21:31:48 <pikhq> You're just not loading Linux proper with it.
21:32:09 <newsham> ofw's forth and assembly and maybe some C as far as I know
21:34:34 <leimy> Forth is a language I never really spent much time with.
21:34:58 <leimy> It's all stacks and words isn't it?
21:35:43 <sproingie> it's kind of fun, it's sort of the ultimate macro assembler
21:35:46 <newsham> yah. stack machine.  it seems pretty good for low level things like boot loaders.  i havent used it too much
21:36:08 <newsham> but recently wrote a loader for a diff file type in OFW with it
21:36:17 <sproingie> it's an interesting mix of low-level and abstract.  stuff like CS-ROLL is crazy weird.
21:36:21 <newsham> can be very terse.  also very interactive.  its fun
21:36:43 <sproingie> the return stack lets you do some really funky continuation-like tricks
21:37:33 <newsham> you can interactively override existing bindings.. thats kinda neat
21:37:40 <newsham> also great introspection
21:37:47 <leimy> wow the Dope Demo still works... in VmWare
21:37:53 <sproingie> you can define words that have different behaviors for compilation and evaluation
21:37:54 <luite> woohoo, my haskell pdf improverizer works :)  (replaces bad fonts in scanned pdf files)
21:38:29 <Gracenotes> a Haskell PDF format parser? -.-
21:38:38 <Gracenotes> (at least partial one)
21:39:18 <leimy> That's actually pretty cool.
21:39:21 <newsham> http://apps.pdos.lcs.mit.edu/cgi-bin/scigen.cgi?seed=714&type=pdf&author=luite&
21:39:47 <luite> Gracenotes: it works on the .pdfxml format, which is a zip file with for each page an .svg file (with some extensions) and a few directories with resources (fonts, images, etc)
21:40:06 <luite> you can convert between pdf and pdfxml with acrobat 8 or 9 with a plugin from adobe
21:40:35 <sproingie> whoah so all those ugly papers with craggy fonts will look nice?
21:41:35 <luite> it should be able to replace bitmap fonts yes, if you have a type 1, ttf or opentype font to replace it
21:42:22 <leimy> GHC's runtime on OKL4 might be pretty amazing.
21:42:42 <Gracenotes> hm.. nice. I also noticed you can print to svg files through the lp dialog somehow on Ubuntu
21:42:56 <luite> but adobe has some stupid font obfuscation to prevent users from reusing embedded opentype fonts... you have to xor the first 1024 bytes of the font file using a key generated from the document id
21:43:11 <leimy> I'd actually like to see Plan 9 on L4, with Linux next to it, and use linux for drivers :-)
21:43:17 <sproingie> i dont think it's embedded fonts.  usually it's postscript conversions
21:43:20 <leimy> PL4n 9 or something.
21:43:27 <sproingie> they end up with these really ugly-ass fonts
21:43:34 <luite> sproingie: yes they have type 3 bitmap fonts
21:43:42 <sproingie> ah that would be why
21:43:59 <newsham> leimy: i've been wondering about how well p9 would work on l4 myself.
21:44:10 <newsham> I'm not terribly impressed by ports of ghc to bare iron so far.
21:44:13 <leimy> newsham: I saw a paper that someone was starting that.
21:44:24 <leimy> but no idea how far it got.
21:44:26 <newsham> yah, some .jp group right?  was a while ago and I havent heard progress
21:44:33 <leimy> yes same group
21:44:38 <luite> I think it's easy to replace the regular characters, they appear as text in the pdf, but I don't know yet how to find the correct glyphs for the math characters
21:44:39 <leimy> It'd be fun to try it anyway.
21:44:50 <leimy> So would that be a new architecture for the plan 9 kernel?
21:45:03 <leimy> I'm also not sure if Inferno on L4 wouldn't be easier, or more sane
21:45:08 <newsham> i guess thats how youd organize it source wise
21:45:09 <leimy> as Inferno works on MMUless architectures.
21:45:26 <newsham> *shrug* I dont follow inferno much
21:45:35 * leimy has inferno on his nintendo DS.
21:45:50 <leimy> It's not perfect but the guy who did it got really far.
21:46:08 <leimy> It's just a pain to do that stuff on homebrew.
21:47:50 <leimy> Well I hope I won't have a ton of spare time, as I'm hoping to be gainfully employed soon, but I might start in on a port of Plan 9 to L4 if I can figure out how the heck to get going.
21:48:07 <monochrom> Hi, is this #haskell?
21:48:18 <leimy> ah here's the paper.
21:48:22 <leimy> http://os.inf.tu-dresden.de/fiasco/
21:48:28 <leimy> http://lsub.org/iwp9/cready/lp49_iwp9_camera_ready.pdf
21:48:30 <leimy> oops
21:49:21 <sproingie> no it's #askhell, where you pose your question to the dark lords of the underworld
21:50:50 <leimy> Sorry... got off topic :-)
21:51:20 <leimy> But someone was talking about papers with crappy fonts too so I didn't think we were being really strict :-)
21:51:26 <newsham> leimy: so many cool thngs to do so little time :)
21:51:34 <leimy> Indeed.
21:51:51 <newsham> all my time is sunk into a 9p project at the moment
21:51:57 <monochrom> Ahem?
21:52:09 <newsham> most but not all of it not haskell related
21:52:21 <xerox> trying to become 9p in Go?
21:52:35 --- mode: ChanServ set +o monochrom
21:52:38 <monochrom> Are you done yet?
21:52:41 <leimy> Yeah you have a pretty solid looking 9p in Haskell.
21:52:45 <newsham> there's already a 9p library for golang.  i'm not using it myself yet
21:53:04 <leimy> I was going to work with that too.  Actually I liked your use of applicative :-)
21:54:10 <newsham> applicative and Binary are natural fits
21:54:18 <sproingie>  /join #lash-elk
21:54:34 <sproingie> poor elk
21:54:40 <leimy> yep.
22:01:08 <kniu> hey, how would I write the class declaration
22:01:29 <kniu> wait, nevermind.
22:02:01 <kniu> how do I write the type
22:02:19 <kniu> (C a, C b) => Foo a b
22:02:25 <kniu> using only one 'C'?
22:04:56 <Axman6> you can't
22:04:56 <lambdabot> Axman6: You have 1 new message. '/msg lambdabot @messages' to read it.
22:05:06 <kniu> dang.
22:06:26 <newsham> kniu: try #coq ;-)
22:08:06 <dolio> class C a => D a where ; instance C a => D a where ; (C a, D b) => Foo a b
22:10:23 <Axman6> heh
22:17:40 --- mode: monochrom set -b *!n=Hugo_Gom@*
22:17:46 --- mode: monochrom set -b *!n=Hugo_Gom@*
22:39:57 <ivanm> hackage is up! \o/
22:40:53 <Axman6> hoorah
22:41:09 <ivanm> hey Axman6
22:41:14 <Axman6> o/
22:41:20 <ivanm> how goeth our capital?
22:41:50 * ivanm has found a bug in his code that could possibly arise from being too clever with tying-the-knot... :s
22:42:06 <Axman6> hot -_-
22:43:01 <ivanm> well, it's a tad muggy here
22:54:07 * hackagebot upload: hpuz 1.0.1 - Haskell bindings for libpuz (ChrisCasinghino)
22:54:52 <ivanm> see, it'd be nice if packages like that bothered to tell you wtf libpuz _was_
22:55:08 <ivanm> looking in gentoo, I can't find any related package with "puz" in the name
22:56:23 <michael|> "The Puzzle library is designed to quickly find visually similar images."
22:56:25 <michael|> from AUR
22:56:45 <c_wraith> everything I'm finding says it's for crossword puzzles
22:57:03 <michael|> Oh, wait - that's for libpuzzle. Possibly different.
22:58:12 <ivanm> heh
22:58:19 <ivanm> @hackage hpuz
22:58:19 <lambdabot> http://hackage.haskell.org/package/hpuz
22:58:34 <ivanm> yeah, looks like that's what it's for
22:58:43 <ivanm> "Provides support for reading and writing the .puz crossword puzzle format from haskell."
22:58:51 <ivanm> michael|: so maybe it is libpuzzle...
22:59:54 <michael|> ivanm: T'was c_wraith who said he found libpuz to be for crossword puzzles. libpuzzle seems to be for image similarity recognition or something, it seems.
23:00:02 <ivanm> oh, yeah
23:00:02 <fabjan> http://www.joshisanerd.com/puz/
23:00:54 <ivanm> yeah, I doubt that's going into gentoo...
23:01:07 <ivanm> since it's tarball is "libpuz-latest.tar.gz" (i.e. no versioning)
23:02:46 <kniu> on x86_64 with ghc, is Double any slower than Float?
23:03:02 <ivanm> yes
23:03:10 <ivanm> I mean no
23:03:15 <kniu> what
23:03:16 <ivanm> for all architectures, Double is way more optimized than Float
23:03:20 <kniu> oh.
23:03:24 <ivanm> Float just exists for FFI stuff basically
23:03:51 * ivanm misread kniu's question at first
23:04:03 <kniu> kthanks.
23:04:35 <ivanm> Axman6: wb! :p
23:04:37 <ivanm> kniu: no worries
23:58:22 <medfly> how is it so?
23:58:39 <medfly> Double being more optimised than Float
