00:15:07 <aleator> Hi, please remind me where I can find list of cabal install flags. I need to pass -L and -I for gcc.
00:46:03 <sinelaw> yo.
00:50:42 <dmwit> oy.
00:51:17 <domor> > reverse "yo."
00:51:18 <lambdabot>   ".oy"
00:57:26 <domor> > length $ liftM2 const [1..10000] [1..10000]
00:57:30 <lambdabot>   mueval-core: Time limit exceeded
00:58:19 <domor> I'm trying to find a way to do something like this without spending 60%+ of the time in GC...
01:00:55 <EnglishGent> :t const
01:00:57 <lambdabot> forall a b. a -> b -> a
01:01:11 <EnglishGent> it just ignores it's second argument?
01:01:20 <domor> yes
01:01:21 <tensorpudding> yeah
01:01:53 <tensorpudding> you can think of const as a function that generates a constant function to its first argument
01:02:12 <EnglishGent> yeah - makes sense
01:02:20 <EnglishGent> I just didnt know it before
01:02:24 <EnglishGent> :)
01:02:31 <tensorpudding> @djinn a -> b -> a
01:02:32 <lambdabot> f a _ = a
01:02:54 <domor> @hoogle a -> b -> b
01:02:55 <lambdabot> Prelude seq :: a -> b -> b
01:02:55 <lambdabot> Control.Parallel par :: a -> b -> b
01:02:55 <lambdabot> Control.Parallel pseq :: a -> b -> b
01:03:16 <EnglishGent> actually (I know this is tangential to the orional query)
01:03:26 <domor> @type flip . const
01:03:27 <lambdabot> forall a b b1. (a -> b) -> a -> b1 -> b
01:03:39 <EnglishGent> but - could you write *any* function of type a -> b -> a - that wasnt isomorphic to const?
01:03:43 <tensorpudding> seq and par and pseq are all special-er than their types suggest
01:03:45 * EnglishGent cant see how you could
01:04:11 <domor> ah it's just flip const actually
01:04:25 <tensorpudding> yeah
01:05:48 <tensorpudding> also, i don't think there is a way to make a function of type a -> b -> a that doesn't return the first argument
01:06:17 <EnglishGent> I'm just wondering - how many functions are like that - especified *completely* by their type signature?
01:06:21 <tensorpudding> though maybe you could make an analogue of seq that returned the result of  the first computation?
01:06:28 <EnglishGent> I mean if f :: a -> a -- f must be id - right?
01:06:43 <EnglishGent> sorry domor - dont mean to side-track away from your question
01:06:45 <EnglishGent> :)
01:07:15 <domor> don't worry :) I think I might have better odds to get an answer when the american timezones wake up
01:08:08 <tensorpudding> maybe if you had a seq which forced the computation of the first argument, then the second, then returned the first
01:08:18 <tensorpudding> that wouldn't technically be const, because it will be strict
01:08:43 <tensorpudding> > (const 5) undefined
01:08:44 <lambdabot>   5
01:09:42 <domor> @type f a b = undefined
01:09:44 <lambdabot> parse error on input `='
01:10:04 <domor> @type (\a b -> undefined)
01:10:06 <lambdabot> forall t t1 a. t -> t1 -> a
01:10:34 <quuxman> how do I turn a "Maybe (Maybe a)" in to a "Maybe a"?
01:10:53 <tensorpudding> quuxman: join
01:10:59 <tensorpudding> @type join
01:11:00 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
01:11:05 <quuxman> ah
01:11:42 <EnglishGent> so, as domor doesnt mind - anyone have any ideas on what functions can be specified completely by their type? :)
01:11:46 <tensorpudding> > join (Just Nothing)
01:11:47 <lambdabot>   Nothing
01:11:51 * EnglishGent just booting some ideas about
01:11:55 <EnglishGent> :)
01:12:00 <tensorpudding> > join Nothing
01:12:01 <lambdabot>   Nothing
01:12:14 <tensorpudding> > join (Just (Just 5))
01:12:15 <lambdabot>   Just 5
01:12:36 <domor> > join [[1],[2]]
01:12:37 <lambdabot>   [1,2]
01:12:51 <tensorpudding> @src join
01:12:52 <lambdabot> join x =  x >>= id
01:15:19 <domor> @type (\a b -> undefined) :: a -> b -> a -- cheating ;)
01:15:20 <lambdabot> forall a b. a -> b -> a
01:18:41 <tensorpudding> > iterate (return :: a -> Maybe a) Nothing
01:18:42 <lambdabot>   Occurs check: cannot construct the infinite type:
01:18:42 <lambdabot>    a = Data.Maybe.Maybe a
01:18:49 <sinelaw> EnglishGent, try djinn
01:18:50 <tensorpudding> err
01:19:03 <tensorpudding> > iterate Just Nothing
01:19:03 <sinelaw> @djinn a->a
01:19:04 <lambdabot>   Occurs check: cannot construct the infinite type:
01:19:04 <lambdabot>    a = Data.Maybe.Maybe a
01:19:04 <lambdabot> f a = a
01:19:11 <tensorpudding> @type iterate
01:19:12 <lambdabot> forall a. (a -> a) -> a -> [a]
01:19:12 <sinelaw> @djinn a->b->a
01:19:13 <lambdabot> f a _ = a
01:19:20 <tensorpudding> oh right...
01:19:24 <tensorpudding> that was stupid
01:19:30 <sinelaw> @djinn a->[a]
01:19:30 <lambdabot> Error: Undefined type []
01:19:42 <EnglishGent> sinelaw - I should perhaps be more specific, functions where there's only *one* function of that type
01:19:51 <domor> @djinn a -> a -> a
01:19:51 <lambdabot> f _ a = a
01:19:57 <sinelaw> ah
01:20:07 <sinelaw> const is one example :)
01:20:12 <tehgeekmeister> so i'm sure someone else has mentioned this before.  probably many times.  but in real world haskell there's a bit about how one of the drawbacks of the prelude is the many partial functions it offers
01:20:15 <EnglishGent> yes - and id
01:20:23 <EnglishGent> I was wondering how many others there were :)
01:20:24 <sinelaw> yip
01:20:39 <sinelaw> well there's a whole family of const-like functions
01:20:41 <tehgeekmeister> it also mentions that there's a convention, among some, of prefixing partial functions with unsafe
01:20:41 <domor> @djinn (a,b) -> a
01:20:42 <lambdabot> f (a, _) = a
01:20:42 <EnglishGent> and if there's anything special about them as a group
01:20:53 <tehgeekmeister> it also uses head as an example of one such function in the prelude
01:21:01 <tehgeekmeister> are we really implying that, well
01:21:08 <tehgeekmeister> the prelude should have head
01:21:17 <domor> @djinn [a] -> a
01:21:17 <tehgeekmeister> and unsafeHead
01:21:17 <tehgeekmeister> ?
01:21:18 <lambdabot> Error: Undefined type []
01:21:40 <EnglishGent> are we perhaps talking about combinators? e.g. f :: a -> (a -> b) -> b
01:21:58 <EnglishGent> the only function I can think of satisfying that spec is the one that applies the 1st argument to the 2nd
01:23:40 <tensorpudding> a -> (a -> b) -> b is just modus ponens, or equivalently function application
01:24:14 <domor> @djinn (a->a)->a
01:24:15 <lambdabot> -- f cannot be realized.
01:25:11 <tensorpudding> @djinn a -> (a -> b) -> b
01:25:11 <lambdabot> f a b = b a
01:26:15 * EnglishGent thought fixedpoint operators did something like (a -> a ) -> a
01:26:17 <EnglishGent> ?
01:26:25 <tensorpudding> @type fix
01:26:27 <lambdabot> forall a. (a -> a) -> a
01:26:32 <tensorpudding> yeah
01:26:33 <domor> yes, and it's a combinator (AFAIK) but djinn can't make it
01:26:34 * EnglishGent sure he's seen something like that in a math book somwhere
01:26:52 <tensorpudding> @src fix
01:26:52 <lambdabot> fix f = let x = f x in x
01:26:54 <EnglishGent> ah - ok
01:27:05 <EnglishGent> ty tensorpudding :)
01:27:52 <tensorpudding> djinn can't make it, possibly because it requires let
01:32:24 <EnglishGent> so - if we're talking about the largest set of type signatures such that for each of them - exactly 1 function exists which satisfies it
01:32:39 <EnglishGent> and then talk about the set of functions that defines
01:32:49 <EnglishGent> is that the combinators? or something different?
01:33:14 * EnglishGent is 'thinking aloud' here and may be talking complete nonsense - please feel free to correct him if he is :)
01:33:59 <quicksilver> tensorpudding: djinn can't make fix because it's not a theorem.
01:34:05 <quicksilver> fix is inconsistent.
01:34:16 <quuxman> grrr, why doesn't the ambiguous type variable error give possible options for what types it could be?
01:40:50 <tensorpudding> ghc isn't smart enough yet
01:41:12 <dhun> can pandoc read mathematical formulas, so something like mathml or latex
01:41:15 <dhun> ?
01:41:27 * EnglishGent waits for ghc to become sentient & write his code for him :)
01:42:37 <tensorpudding> ghc is still bound by the limits of computability, sentient or no :P
01:42:55 <quicksilver> dhun: the web page says yes.
01:43:11 * dhun went to a meeting of really evil people last Sunday, didn't find anybody to talk with, except one fellow Haskell user 
01:44:47 <dhun> thank you quicksilver
01:44:49 <EnglishGent> "Haskell - the programming language of choice for the evil genius" ?
01:44:50 <EnglishGent> :)
02:10:57 <quuxman> Haskell - the programming language of choice for the masochistic genius
02:12:28 <domor> @google bondage discipline language
02:12:30 <lambdabot> http://c2.com/cgi/wiki?BondageAndDisciplineLanguage
02:12:30 <lambdabot> Title: Bondage And Discipline Language
02:20:27 <Baughn> http://xkcd.com/695/ <-- Don't let this happen to *your* programs! Support the AI emancipation party!
02:29:23 <Feuerbach> In Alex, is it possible to get matching substrings from a matched regexp? E.g. if 3.14 is matched by (\d+)\.(\d+), I want to get 3 and 14
03:17:04 <ivanm> @. elite yow
03:17:05 <lambdabot> c0ulDn'T FinD fORtuN3 FI1e
03:18:37 <tumult> i'm trying to build something with cabal that requires X11, and i'm getting "Setup.hs: At least the following dependencies are missing: X11 -any"
03:18:58 <tumult> even though i have it installed right (i think?) and i can :module Graphics.X11 from ghci
03:19:14 <Saizan> tumult: maybe you need --user ?
03:19:27 <tumult> how does that work :)
03:19:29 <Saizan> tumult: or you could just run "cabal install" from inside the source tree
03:19:44 <Saizan> basically, there are two package dbs, a global and an user one
03:19:48 <tumult> oh dur
03:19:56 <tumult> yeah X11 is user for sure
03:20:02 <Saizan> cabal-install by default installs in the user db
03:20:15 <Saizan> but the Setup.hs scripts default to using only the global one
03:20:34 <Saizan> and install in it
03:20:37 <tumult> good to know
03:20:40 <tumult> thanks
03:20:52 <Saizan> (if you install in the global one you can't see the user specific packages, of course)
03:25:35 <ivanm> preflex: seen sinelaw
03:25:36 -preflex(n=preflex@95-88-118-220-dynip.superkabel.de)- sinelaw was last seen on #haskell 2 hours, 4 minutes and 56 seconds ago, saying: well there's a whole family of const-like functions
03:27:56 <ivanm> @tell sinelaw have a look at http://www.kde-apps.org/content/show.php/KGraphViewer+and+KGraphEditor?content=23999
03:27:57 <lambdabot> Consider it noted.
03:28:27 <dolio> Anyone know Coq well enough to explain why Oleg's proof of false doesn't work in it? Can you not do dependent matching on inductive Props?
03:30:47 <Saizan> which proof?
03:31:52 <dolio> In GHC, it's: data R :: * -> * where R :: forall (c :: * -> *). (c (c ()) -> False) -> R (c ()) ...
03:32:11 <dolio> w :: R (R ()) -> False ; w x@(R f) = f x
03:32:23 <dolio> absurd = w (R w)
03:32:46 <dolio> Anyhow, I know how to write R in Coq, but not how to write w.
03:33:38 <dolio> Matching in Haskell tells us that c = R, and so f :: R (R ()) -> False, but I'm not sure how to do that kind of matching in Coq.
03:35:59 <ivanm> I WANT MY PLANET.HASKELL.ORG FIX!!!
03:36:00 <ivanm> ;-)
03:36:48 * Saizan wonders if by R () ~ c () you can deduce R ~ c in Coq
03:37:11 <quicksilver> that's not true, is it?
03:37:13 <dolio> Technically, it's possible that we shouldn't be given that in Haskell.
03:37:27 <dolio> Since f () = g () doesn't mean that f = g.
03:37:37 <dolio> I'm not really sure why you get that in GHC.
03:37:55 <quicksilver> unless it's true because of parametricity
03:37:56 <Saizan> the Fc paper is careful about deriving that only when it holds
03:38:17 <Saizan> i.e. only for type constructors declared with data
03:38:24 <dolio> We do know that f :: c (R ()) -> False.
03:39:21 <dolio> That isn't even injectivity, though.
03:39:35 <dolio> Injectivity would be c x ~ c y => x ~ y.
03:40:57 <Saizan> in haskell i think of it more like c $ x ~ k $ y -> c ~ k, x ~ y
03:41:43 <dolio> For instance, if we had total type families, and could overlap, presumably I could write something like: "type family T :: * -> * where T () = R () ; T a = S a".
03:42:47 <dolio> Even if we can't overlap, I can probably define a family that's R () for T (), and not R (R ()) for T (R ()).
03:43:49 <Saizan> what happens if you use a family as parameter to R?
03:45:07 <tumult> hm, i guess i really do need gtk2hs from darcs in order to build clutterhs? i tried the URL that the gtk2hs site pointed to for the darcs repo, but it seemed dead
03:45:48 <tumult> i built gtk2hs from the tarball they had, but i'm getting weird build errors in clutterhs (whose build instructions say 'gtk2hs from darcs') so i'm guessing that's the problem
03:48:30 <tumult> is http://code.haskell.org/gtk2hs/ supposed to be working?
03:49:23 <ivanm> tumult: unless gtk2hs in darcs has changed and clutterhs no longer builds against it?
03:49:39 <Saizan> tumult: yeah, but the server seems down atm
03:50:54 <tumult> ivanm: well i am assuming the version in the darcs repo is slightly different from the tarball release on their site, which is why i can't build clutterhs (i only have the tarball)
03:51:05 <tumult> Saizan: bummer :(
03:51:56 <Saizan> dolio: it seems you don't get the refinements if you use a type family for T
03:52:18 <Saizan> dolio: err, for c i meant
03:52:35 <fasta> Is there already someone who had the bright idea to upload a package with generalized versions of the Data.STRef functions? In this case generalized to whatever monad stack with ST at the bottom.
04:21:54 <int-e> fasta: like http://hackage.haskell.org/package/stateful-mtl ?
04:25:56 <dolio> Saizan: The weird thing is that I can't use T for c. I'd expect to be able to use T there, and subsequently not have injectivity of ($ ()) at the type level.
04:26:18 <fasta> int-e, I already use that.
04:26:58 <fasta> int-e, I have written the trivial lifted versions myself now.
04:27:33 <dolio> But GHC ensures that c () ~ R () => c ~ R by limiting what I can use with that datatype, rather than rejecting that inference.
04:30:03 <dolio> I can't write w in Agda even with Set : Set, because it doesn't let me go from F () = R () to F = R (I think).
04:59:16 <Saizan> heh right, in GHC you can't even pattern match against R (T ()) if T is a family
05:00:25 <dolio> You can't pattern match against R (R ()) in Agda, as far as I can tell.
05:01:17 <dolio> My point is that I can write foo :: T (T ()) -> False, but R foo fails.
05:01:38 <dolio> I can't *construct* R (T ()) for type families T.
05:03:17 <Saizan> you can pattern match against R (R ()) in agda with the "with" trick
05:03:33 <dolio> Or, I can construct it if the type family has no instances.
05:03:56 <dolio> And I get: "R foo :: (T (T ()) ~ c (c ())) => R (c ())"
05:04:24 <dolio> But that fails once I have actual instances for T that cause reduction.
05:04:56 <dolio> Even though c = T would presumably work.
05:06:01 <Saizan> weird
05:06:22 <dolio> What with are you using to match in Agda?
05:06:37 <rhz> are code.haskell.org and projects.haskell.org down?
05:07:50 <Saizan> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16743#a16743
05:08:48 <Saizan> and i guess i can use some trick to make x :: (.c (.c \top)) so that i can pass it to f
05:09:31 <dolio> Ah.
05:09:45 <dang`r`us> c c top?
05:09:47 <dang`r`us> (Sorry. :)
05:10:17 <ivanm> rhz: yes
05:10:36 <rhz> ivanm: when will they be back. any idea?
05:11:07 <ivanm> rhz: probably about the same time that community.haskell.org is back up... >_>
05:11:37 <rhz> ivanm: oh really? thanks. so halpful
05:11:40 <rhz> helpful
05:11:45 <ivanm> no worries! :D
05:12:30 <dolio> Saizan: I don't think you can. I doubt there's any way to legitimately show that F (F \top) = R (R \top).
05:12:52 <dolio> Even though in Agda, it's presumably actually true, because there's no type case.
05:13:16 <rhz> ivanm: well when will community.haskell.org be back ? duh.
05:13:28 <ivanm> rhz: oh, about the same time code.haskell.org is
05:13:29 <ivanm> ;-)
05:13:38 <ivanm> (in other words: I have nfi)
05:15:57 <misk20> hello
05:16:02 <MissPiggy> oh man Oleg is involved now?
05:16:11 <rhz> ivanm: yes. you could have just said so.
05:16:23 <ivanm> rhz: I thought it was implied...
05:16:51 <misk20> Where can i get more information on BNFC grammar ?
05:18:09 <wto> misk20: http://www.cse.chalmers.se/research/group/Language-technology/BNFC/
05:18:14 <wto> misk20: look under "examples"
05:18:29 <misk20> thanks wto
05:18:44 <ivanm> and here I was, about to suggest that font of all knowledge and wisdom, wikipedia
05:19:56 <misk20> i was trying to write bnfc for std::cout << "Hello, world!" << std::endl;
05:20:03 <misk20> and my approach was CCout.    Cinout ::= "cout" ;
05:20:03 <misk20> CCin.     Cinout ::= "cin" ;
05:20:03 <misk20> CEndl.    Cinout ::= "endl" ;
05:20:03 <misk20> CStd.     Cinout ::= "std" "::" Cinout ;
05:20:03 <misk20> CPatt.    Cinout ::= Cinout "<<" Exp ;
05:20:04 <misk20> CPattd.   Cinout ::= Cinout "<<" Exp "<<" Cinout ;
05:20:27 <misk20> this this right way ?
05:21:13 <MissPiggy> what is that??
05:21:16 <MissPiggy> oh it's BNFC
05:21:21 <misk20> yes
05:21:30 <MissPiggy> are you implemnting C++
05:21:36 <misk20> yes
05:21:42 <MissPiggy> that's hardcore
05:21:46 <benmachine> I heard C++'s grammar is not context-free
05:22:05 <Schmallon> Sorry to interrupt, but is there any lookup data structure (other than Data.Map) that can efficiently map Integers to Ints? I'm currently using Data.Map and I find it to be rather slow
05:22:10 <misk20> ya but i ma not trying to implement complete C++
05:22:16 <MissPiggy> there's IntMap
05:22:25 <ivanm> Schmallon: well, using INteger in the first place is rather slow (if its bigger than Int)
05:22:30 <ivanm> may I suggest mod? :p
05:22:39 <benmachine> Schmallon: you can use an array, if the range of the integers is small enough
05:22:49 <Schmallon> well, i'm working with rather big integers
05:23:01 <Schmallon> and the map is going to be comparatively sparse
05:23:03 <benmachine> or possibly an array with a clever Ix if you can compress the Integers into a smaller space quickly
05:23:04 <stroan> Schmallon: http://hackage.haskell.org/package/compact-map
05:23:06 <Alpounet> there's a C++ parser there : http://42ndart.org/scalpel/
05:23:08 <MissPiggy> misk20 why don't you parse << as an operator
05:23:40 <misk20> then won't it conflict with the operator when using ?
05:23:45 <ivanm> hmmmm.... 6.12 doesn't like compact-map...
05:23:47 <temoto> @quot boost
05:23:48 <lambdabot> kmc_ says: you should take a look at Boost, they implement things like Maybe and tuples in only a few thousand lines of C++
05:24:36 <Alpounet> :D
05:25:23 <rhz> ivanm: needless to say I did not understand what you were implying.
05:25:37 <benmachine> rhz: I would argue that is needed to say
05:25:50 <benmachine> and also that it's not a big deal?
05:26:03 <stroan> ivanm: oh does it not? sorry, I'm using an older ghc
05:26:23 <ivanm> stroan: according to hackage it doesn't :s
05:26:59 <stroan> ah didn't read that. "it works on my machine therefore..."
05:28:14 <rhz> benmachine: that's nice..... but not correct
05:32:05 <pozic> Why is the type of PSQueue.insert :: (Ord k, Ord p) => k -> p -> PSQ k p -> PSQ k p restricted to ordered elements? If there is just an ordered priority, then that should work too, no?
05:32:50 * ivanm randomly assumes implementation specific issues
05:32:52 <opqdonut> probably because it implements updates
05:33:02 <opqdonut> you can say updatePriority elem prio
05:33:13 <opqdonut> err, updatePriority elem prio psq
05:33:15 <dolio> PSQueues are both binary search trees on the values, and priority queues on the keys.
05:33:19 <opqdonut> but anyway, it need to find the element
05:33:22 <opqdonut> mhmm
05:33:29 <opqdonut> use a heap if you don't need updates
05:33:43 <pozic> Ok, so that's not what I need. Is there a package that is not a binary search tree?
05:34:12 <opqdonut> @hackage heap
05:34:13 <lambdabot> http://hackage.haskell.org/package/heap
05:34:18 <opqdonut> :)
05:34:33 <pozic> Well, that was easy.
05:35:05 <opqdonut> indeed
05:35:14 <opqdonut> that's the implementation from okasaki
05:35:25 <ivanm> pozic: I would guess that most packages on hackage dont' implement binary search trees...
05:35:47 <opqdonut> i wouldn't be so sure, actually :)
05:35:55 <MissPiggy> has anyone written a (tiny, like 30 line or shorter) ghci repl in haskell?
05:36:07 <opqdonut> good question
05:36:10 <ivanm> ummm..... what?
05:36:10 <MissPiggy> or anything that works like a repl interacting with a subprocess
05:36:17 <ivanm> MissPiggy: there's the Prompt monad...
05:37:02 <pozic> ivanm: there is this thing called context, which you missed.
05:37:23 <ivanm> pozic: isn't Context a type alias in FGL? :p
05:37:28 <dolio> I have a REPL for my pure type systems, but it's way more than 30 lines.
05:37:31 <pozic> ivanm: or otherwise it is a very silly joke.
05:37:59 <MissPiggy> dolio yeah I just want something that interacts with a subprocess though
05:38:07 <MissPiggy> like running a command line program
05:38:11 <pozic> Having to restart ghci everytime you install a new library is really bad.
05:38:45 <pozic> Suppose you would actually use it as a REPL with a GB sized data base that needs to be loaded from disk.
05:38:52 <pozic> It would not work.
05:39:47 <Daerim> lambdabot, can haskell be used as a replacement for silly shell scripts?
05:40:46 <ivanm> @faq Can Haskell be used as a replacement for shell scripts, silly or otherwise?
05:40:47 <lambdabot> The answer is: Yes! Haskell can do that.
05:40:59 <Daerim> Super :)
05:41:03 <Daerim> Thanks ivanm
05:52:51 <temoto> What is Foo-morphism?
05:53:17 <temoto> This channel is usually full of words ending with "morphism".
05:53:27 <medfly> I think it's category theory.
05:53:50 <stroan> well, this channel is largely concerned with the mapping of one type onto another ;)
05:54:13 <quicksilver> they're not really category theory although that's where the words come from
05:54:13 <medfly> I thought it's mostly concerned with how <languages we have to use at work> suck.
05:54:27 <quicksilver> they're ways of classifying functions which break down or build up data structures
05:54:38 <temoto> medfly, that's not saying unless you wanted to say that 'morphism' is something you can't understand until you learn CT.
05:55:03 <medfly> I am trying to hint that I don't know it, and I think it's CT-related.
05:55:15 <temoto> oh
05:55:28 <medfly> :-)
05:55:36 <temoto> quicksilver, isn't everything about break or build?
05:55:44 <temoto> of data structures
05:56:02 <medfly> maybe you need to just have the same amount as you were given :-)
05:56:09 <CalJohn> perhaps not in an imperative language
05:56:17 <CalJohn> but IANACT
05:57:19 <quicksilver> temoto: maybe. The words are not that important or enlightening.
05:57:46 <quicksilver> it is about the connection between 'foldr' and 'maybe' for example
05:57:48 <quicksilver> :t foldr
05:57:49 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
05:57:50 <quicksilver> :t maybe
05:57:51 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
05:58:33 <temoto> erh.. am i the only one who doesn't see a connection?
06:01:01 <medfly> I sort of didn't notice myself, but it seems to take a function returning something of type b, an element of type b, a functor (?) and gives you something of type b. both...
06:01:13 <medfly> take everything I say with caution
06:01:59 <temoto> oh well
06:03:25 <quicksilver> temoto: [] and Maybe both have two constructors
06:03:39 <quicksilver> (:) and [] for [], Just and Nothing for Maybe
06:04:00 <quicksilver> those two functions both take one function for each constructor choice
06:04:14 <quicksilver> and use the corresponding function as necessary.
06:04:22 <quicksilver> write out the definitions and you'd find them similar.
06:04:27 <jlouis> temoto: a morphism is a basic concept from category theory. In some cases it coincides with "function" (for the category of Sets for instance), but it does not need to be
06:04:35 <quicksilver> not quite the same, because foldr has to recurse and maybe doesn't.
06:04:48 <quicksilver> (but Maybe isn't a recursive type, so that's why; in a sense they are the same)
06:04:58 <idnar> the difference between them due to the recursion is interesting to note
06:05:08 <jlouis> temoto: when we prefix a morphism, endo-, cata- it usually means that we talk about a morphism of a specific type
06:05:31 <quicksilver> so these are called catamorphisms
06:05:39 <quicksilver> it's really not that enlightening or that subtle
06:05:52 <quicksilver> just the scientists approach of looking for parallels and giving them names
06:06:19 <medfly> I found you pointing out that they are similar enlightening.
06:06:46 <temoto> These functions are catamorphisms or their similarity is a catamorphism?
06:07:00 <quicksilver> they are catamorphisms
06:07:05 <dolio> You can get Maybe as the fixed point of a functor, and the catamorphism will be, essentially, maybe.
06:07:12 <quicksilver> "either" is the catamorphism for Either
06:07:14 <quicksilver> :t either
06:07:15 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
06:07:25 <temoto> So catamorphism is a data constructor?
06:07:28 <quicksilver> again, two constructors, so two initial parameters
06:07:31 <quicksilver> no, it's a function.
06:07:33 <dolio> Maybe A = mu X. 1 + A
06:07:50 <dolio> cata :: (1 + A -> R) -> R
06:08:19 <temoto> no i mean how would you define a catamorphism or how would you reason whether something is one: it builds a value using supplied constructor?
06:08:35 <idnar> temoto: it's more the other way around
06:08:47 <dolio> Er, (1 + A -> R) -> Maybe A -> R
06:08:52 <idnar> temoto: it replaces each constructor by using the function/value you supplied
06:09:53 <idnar> for example, (maybe a f) replaces (Nothing) with (a) and (Just x) with (f x)
06:17:02 <MissPiggy> hi
06:17:12 <MissPiggy> trying to turn tex into pngs is a HUGE hassle
06:17:26 <MissPiggy> infact, pretty much any programming task is
06:17:29 <quicksilver> yes
06:17:43 <quicksilver> preview-latex (emacs package) has the machinery to turn tex into small images
06:17:47 <Botje> MissPiggy: have you looked at the way wikipedia et al do it?
06:17:50 <quicksilver> I think they were pngs but dont remember for sure.
06:17:53 <Botje> or wordpress
06:17:57 <MissPiggy> right now installing ocamlopt for wiki
06:18:14 <MissPiggy> dyld: unknown required load command 0x80000022 -- which turned out to be a waste of time
06:18:36 <Alpounet> there are web "services" that do that too
06:18:50 * MissPiggy has a go with preview-latex
06:19:55 <MissPiggy> hmmm dvipng
06:19:57 <temoto> Catamorphism is a function that transforms some value into another value using supplied strategy?
06:20:05 <Alpounet> quicksilver, it seems it converts to png & gif
06:24:15 <temoto> :k Maybe a
06:24:16 <lambdabot> Not in scope: type variable `a'
06:24:19 <temoto> :k Maybe Int
06:24:20 <lambdabot> *
06:24:27 <medfly> :k Maybe
06:24:28 <lambdabot> * -> *
06:24:32 <medfly> :k []
06:24:33 <lambdabot> * -> *
06:24:37 <medfly> :]
06:24:43 <ski> temoto : more like a function that "collapses" one structure, by replacing the constructors with given functions
06:24:55 <medfly> hmm :)
06:25:00 <temoto> ski, thanks.
06:25:00 <ski> @kind forall a. Maybe a
06:25:01 <lambdabot> *
06:25:03 <medfly> that makes sense.
06:25:12 <medfly> @type maybe
06:25:14 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
06:25:36 <ski> (iirc, "cata" means "down" in greek, the idea being that a structure is torn down)
06:25:46 <medfly> so b is still called a function here?
06:25:53 <medfly> first
06:26:08 <ski> (cf. "anamorphism", "ana" meaning up, which is used to describe functions that do the opposite, i.e. build a structure up)
06:26:25 <Confusius> Hi, does anybody know what the color codes (red, green) in the Arch Haskell Package Report mean?
06:26:33 <ski> medfly : not really, i guess i should have said s/functions/operations/ :)
06:26:48 <ski> @type unfoldr
06:26:49 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
06:26:57 <ski> ^ an example of an anamorphism
06:27:22 <temoto> Does it make sense? Values as first dimension (1, 5, 100500), all values of some type correspond to a point in higher dimension of types (Int, Bool), all types <meaningful predicate> correspond to a point in higher dimension of kinds (*, ?, ??).
06:27:28 <Alpounet> ski, is your nick related to the combinators of the same name ?
06:27:34 <ski> correct
06:27:48 <quicksilver> they were named after him, in fact
06:28:22 <MissPiggy> ;_;
06:28:50 <MissPiggy> trying to get a png-maker-thing broke my tex install
06:28:52 <MissPiggy> this is just a huge waste of time
06:29:02 <MissPiggy> if linux worked I would have this done yesterday
06:29:48 <pettter> MissPiggy: correction: if linux worked the way you epected it to work
06:29:56 <MissPiggy> yeah except not
06:30:12 <ski> temoto : yes, the "type of" a value is a type, the "type of" a type (including things like `Maybe', not just things like `Maybe Bool') is a kind
06:30:16 <pettter> also, I suspect that linux is not the problem, but probably some other component
06:30:24 <MissPiggy> pettter, the problem is that it crashed on boot which is probably a hardware thing, not a misconception/false expectation
06:30:32 <pettter> the kernel really does not have much to do with TeX
06:30:49 <temoto> MissPiggy, upgrading to newer version of ubuntu broken my linux the other day. Because they're no longer compatible with custom kernel.
06:30:55 <pettter> MissPiggy: ....what did you manage to do?
06:31:52 <temoto> Does it make sense? * is a term in kinds.
06:32:36 <ski> it's a-ok
06:32:58 <temoto> What other terms do kinds have/define?
06:33:31 <temoto> Does user defined kind make sense?
06:33:33 <ski> `k0 -> k1' for any kinds `k0',`k1'
06:33:41 <ski> temoto : they could
06:34:20 <temoto> :k Maybe
06:34:21 <lambdabot> * -> *
06:34:30 <temoto> Shouldn't this be k0 -> k1 ?
06:34:41 <ski> no
06:34:50 <ski> in that case, `k0' and `k1' are both `*'
06:35:02 <temoto> * means 'any kind' ?
06:35:07 <temoto> or rather, any type?
06:35:16 <quicksilver> no, it is the kind of specific concrete types
06:35:17 <ski> `*' means the kind of types which have values, roughly
06:35:24 <quicksilver> all actual values of have a type of kind *
06:35:37 <temoto> omg.. types which can't have values?
06:35:44 <medfly> ski, types which have values == *, no?
06:35:44 <ski> e.g. `*' is the kind of `Bool', which is the type of the value `False'
06:35:59 <medfly> things that their kind is *
06:36:00 <temoto> Abstract types, like data Foo ?
06:36:09 <quicksilver> temoto: no, things like 'Maybe'
06:36:19 <quicksilver> you can't have a value of type 'Maybe'
06:36:23 <quicksilver> (it has to be 'Maybe Int')
06:36:24 <ski> otoh, `* -> *', is the kind of `Maybe', for which the having of values is unthinkable/meaningless
06:36:39 <ski> (as opposed to a type `Void' which just doesn't happen to have any (non-bottom) values)
06:36:50 <medfly> oh
06:37:04 <medfly> didn't think about that
06:37:14 <temoto> That's what i asked about. data Foo doesn't have values, right? What would be the kind?
06:37:54 <MissPiggy> I don't know. it's all screwed up
06:37:55 <ski> the point being that you need to apply `Maybe' to some (concrete, i.e. one with kind `*'), type, such as `Bool' to get `Maybe Bool' .. then you can start thinking about possible values in that type
06:38:28 <ski> temoto : an abstract type is just a type that you don't know any constructors of
06:38:58 <temoto> Abstractness of type is subjective?
06:39:03 <ski> in some sense, yes
06:39:19 <ski> presumably, the implementor (module) of the type in question know the representation
06:39:24 <temoto> never could imagine that
06:39:30 <medfly> I made sense of it as a functor having a kind of * -> *, I could be wrong though
06:39:37 <medfly> :-/
06:39:39 <fasta> temoto, it is not subjective.
06:40:07 <fasta> temoto, it is just the "abstract data type" idea you find in books.
06:40:11 <ski> (and i interpreted "subjective" here as "relative", since it is relative to where you're looking form)
06:40:42 <fasta> ski, I just thought I saw a miscommunication. I know you understand your stuff :)
06:40:48 <temoto> i meant relative, yes
06:40:50 <ski> temoto : some people don't want to call things like `Maybe' (as opposed to `Maybe Bool') "types", but prefer to use "type constructors" for this more general case
06:42:03 <medfly> :k Either
06:42:04 <lambdabot> * -> * -> *
06:42:07 <fasta> temoto, also consider what happens when you take the type of kinds.
06:42:07 <ski> i'm not that happy with this, since to me `Maybe' could be a type constrcutor, but `Either Int' would in my ears sound very strange to call "type constructor"
06:42:11 <fasta> temoto, and so on.
06:42:23 <medfly> I guess it also makes sense as type constructors too...
06:42:39 <fasta> temoto, those are called universe types, IIRC, in Coq. So, you have Type(0), Type(1), and so on.
06:42:53 <medfly> Maybe is a thing that takes one type, Either takes two, Int takes 0
06:43:12 <ski> (cf. that `Nothing',`Just',`Left' are called data constructors, but given `data Tree a = Node a [Tree a]', `Node 42' wouldn't usually be called a data constructor)
06:43:25 <fasta> temoto, in Haskell you only have Type(0) and Type(1), I suppose.
06:43:45 <fasta> Concrete types and kinds, and kinds only exist at the level of the implementation.
06:43:56 <temoto> Unfortunately, i don't know Coq.
06:44:11 <temoto> I couldn't move farther than 3rd page of tutorial, maybe.
06:44:26 <MissPiggy> it's quite difficult to get to grips with Coq because it's SO simple
06:44:32 <temoto> So, Maybe is a type constructor, that's easy. kind * -> * represents it's partial application -compatible nature, that's easy.
06:44:47 <temoto> I can't get why terms on both sides of operator are the same.
06:44:53 <fasta> MissPiggy, Coq is huge, imho.
06:44:54 <medfly> :k (,,,)
06:44:55 <lambdabot> * -> * -> * -> * -> *
06:44:57 <ski> which operator ?
06:45:00 <temoto> ->
06:45:17 <fasta> MissPiggy, the core calculus is about 1/30th of all the typing rules.
06:45:30 <quicksilver> temoto: you give it a concrete type like (Int :: *)
06:45:31 <MissPiggy> the kernel of the type system fits on half a page of A4
06:45:36 <jlouis> Coq is huge. Twelf is rather simple
06:45:39 <quicksilver> temoto: and teh result is a concrete type (Maybe Int :: *)
06:45:39 <jlouis> but still nasty
06:45:42 <MissPiggy> but you can do everything upto and beyond real analysis, ZFC etc
06:45:43 <quicksilver> temoto: so, * -> *
06:45:50 <MissPiggy> so it's some pretty tightly wound coil
06:45:53 <fasta> MissPiggy, show me that page, please.
06:45:55 <temoto> quicksilver, but Int and Maybe Int are different things.
06:46:01 <fasta> MissPiggy, I don't think it exists.
06:46:14 <quicksilver> temoto: they are different things but they both have kind *
06:46:25 <quicksilver> temoto: they are both concrete types
06:46:27 <fasta> MissPiggy, I am referring to everything in Coq, including the module system.
06:46:34 <MissPiggy> fasta, no just the kernel
06:46:37 * Saizan should read something about LF
06:46:40 <temoto> It's like we have a function i.e. (==10) which is Int -> Bool. We could write it as a -> b, that's not a -> a.
06:46:40 <ski> temoto : you can define a data type `data Foo f a = Here a | Nest (Foo f (f a))' .. here the `f' argument can be stuff like `Maybe', so the kind of `Foo' must be `(* -> *) -> ...'
06:46:45 <fasta> MissPiggy, and the system is useless if you only have the kernel,
06:46:46 <MissPiggy> the module system and inductive types and stuff is a bit more
06:46:46 <fasta> .
06:47:02 <fasta> That's why the module system exists ;)
06:47:14 <ski> temoto : then `a :: *', and the whole defines a type which can have values, so we get `Foo :: (* -> *) -> (* -> *)'
06:47:30 <MissPiggy> fasta, it's from Luos book Computation and Reasoning btw
06:47:36 <jlouis> Saizan: LF is quite simple. It is a dependently typed lambda calculus which is constrained in certain ways
06:47:49 <ski> (.. in fact, if we had kind polymorphism, it could be `Foo :: forall_kind k. (k -> *) -> (k -> *)')
06:48:08 <temoto> ski, that's what i'm talking about.
06:48:16 <temoto> Different terms.
06:48:18 <fasta> MissPiggy, I just read the rules from the reference manual.
06:48:24 <MissPiggy> ok
06:48:39 <temoto> Okay, is '*' the only term in kinds?
06:48:52 <Alpounet> <quicksilver> they were named after him, in fact <<< haha :-)
06:49:06 <quicksilver> haskell kinds have the language formed from * and ->, temoto
06:49:19 <quicksilver> GHC kinds have some additional basic kinds
06:49:21 <ski> temoto : here the things to the left of `->' are `* -> *',`*', and the things to the right of `->' are `* -> *',`*' .. so `*' and `* -> *' need to be in the same syntactic term category
06:49:56 <Jonno_FTW> when installing a cabal package, what do i about this?
06:49:59 <Jonno_FTW> old-time-1.0.0.2 failed during the configure step. The exception was:
06:50:01 <Jonno_FTW> sh: runGenProcess: does not exist (No such file or directory)
06:50:35 <Saizan> Jonno_FTW: are you on windows?
06:50:39 <ski> re "<temoto> Okay, is '*' the only term in kinds?"
06:50:41 <Jonno_FTW> yes
06:50:43 <ski> <temoto> What other terms do kinds have/define?
06:50:44 <ski> <ski> `k0 -> k1' for any kinds `k0',`k1'
06:50:53 <Jonno_FTW> will i have to run this inside cygwin?
06:51:14 <Saizan> Jonno_FTW: you need an "sh" executable
06:51:26 <temoto> ski, but quicksilver said only * and ->.
06:51:37 <quicksilver> temoto: the languafe form from * and ->
06:51:38 <Jonno_FTW> so this is a no go on windows then?
06:51:42 <quicksilver> temoto: that is not just * and ->
06:51:58 <quicksilver> that is *, * -> *, (* -> *) -> *, * -> (* -> *), etc...
06:51:59 <Saizan> Jonno_FTW: that step works if you install msys
06:52:08 <Jonno_FTW> ok
06:52:12 <ski> temoto : `*' is a kind. if `k0' and `k1' are kinds, then `k0 -> k1' is a kind
06:52:29 <ski> temoto : that shows why all the examples quicksilver just said are kinds
06:52:54 <temoto> I get it, it's like forall a. notation
06:52:56 <MissPiggy> anyway my point is that it is an extremely condensed set of rules that are extremely powerful, so this can be part of why it is difficult to learn
06:53:03 <temoto> but it's not actually there.
06:53:04 <Jonno_FTW> thanks
06:53:22 <MissPiggy> when you deal with things that are a bit weaker, it's okay if there are quite a few of them -- because that is more like what one is used to, I thin
06:53:26 <ski> (that doesn't mean the kinds constructed in those two ways are the only kinds .. as quicksilver said, GHC adds some more kinds into the picture)
06:53:26 <temoto> You just use k0 -> k1 in chat, but it's meaningless in real haskell source.
06:53:56 <ski> temoto : in Haskell 98 source, yes. it is allowed with some extensions, though
06:54:30 <ski> (though not actual `k0' and `k1' identifiers in kinds .. that's just meta-variables)
06:54:35 <dolio> Luo's rules for inductive families aren't what I'd call simple.
06:55:01 * ski . o O ( Luo ? )
06:55:03 <temoto> ski, GHC adds '?' and '??' ?
06:55:18 <ski> temoto : yes, and `#' and `(#)', and `!' too iirc
06:55:38 <MissPiggy> Luo Zhaohui
06:55:45 <MissPiggy> wrote Computation and Reasoning
06:56:41 <dolio> I don't think UTT has inductive propositions, either, which are potentially a sticky area.
06:57:46 <quicksilver> and the plan is for GHC to add user defined kinds.
06:57:50 <ski> @kind GHC.Base.Int#
06:57:51 <ski> @kind (# GHC.Base.Int# , Bool #)
06:57:52 <lambdabot> #
06:57:53 <lambdabot> (#)
06:57:55 <lunabot>  luna: parse error on input `]'
06:57:56 <ski> quicksilver : closed ?
06:58:00 <ski> data kinds ?
06:58:03 <jmcarthur> user defined kinds?
06:58:12 <quicksilver> datakinds, yes. details not entirely clear yet.
06:58:27 <temoto> Types have useful meaning that all values of some type are somewhat compatible with each other. What kinds empower with?
06:58:41 <quicksilver> http://hackage.haskell.org/trac/ghc/wiki/KindSystem
06:58:52 <jmcarthur> all types of some kind are somewhat compatible with each other, temoto ;)
06:58:53 <temoto> Thanks. :)
06:59:02 <quicksilver> temoto: they are required for the compiler to check your types make sense
06:59:06 <quicksilver> "Maybe Int" makes sense
06:59:11 <quicksilver> "Maybe Maybe" doesn't make sense
06:59:19 <quicksilver> it's kind inference which GHC has to perform to check that.
06:59:24 <quicksilver> well, kind inference / kind checking.
06:59:47 <temoto> Ah, kinds are used to check that type is fully defined?
06:59:54 <arw> hm, one could abuse maybe maybe maybe ... as a kind of counter ;)
07:02:58 <Saizan> temoto: that they are prepared to accept the arguments you pass them
07:03:39 <Saizan> temoto: or that they in fact don't take any arguments and values can be of such a type
07:04:24 <MissPiggy> sticky dolio?
07:04:56 <temoto> That's what kinds are for in haskell?
07:04:56 <Jonno_FTW> i installed mingw and added the system variables but it still won't work
07:05:31 <ski> arw : `Mu Maybe'
07:05:35 <Saizan> Jonno_FTW: sh.exe works?
07:05:45 <Jonno_FTW> not found
07:05:57 <Jonno_FTW> i think i installed the wrong one
07:06:13 <ski> @type (In . Just . In . Just . In . Just) (In Nothing)
07:06:15 <lambdabot> Mu Maybe
07:06:20 <Saizan> then that's the problem, sh doesn't come with mingw, but with msys iirc, msys is basically mingw + utils
07:06:33 <dolio> MissPiggy: Well, Luo notes earlier in his book that you can't have strong sums in an impredictive Prop (they let you encode something like Prop : Prop). So if you have inductive Props, you have to make sure they don't have the same problem.
07:06:45 <quicksilver> ski: that's what I call injustice.
07:06:50 <dolio> And strong sums are typically a special case of inductives.
07:06:52 <arw> ski: nice :)
07:06:53 * ski grins
07:07:04 <ski> @src Mu
07:07:05 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
07:07:12 <Saizan> Jonno_FTW: though it's a bit weird to want to compile old-time on windows, it should come with the ghc binary
07:07:25 <Jonno_FTW> i want to install cgi
07:07:55 <Jonno_FTW> cgi-3001.1.7.1 depends on old-time-1.0.0.2 which failed to install.
07:08:11 <ski> (the "strong" in sums referring to ?)
07:08:26 <temoto> :k Mu
07:08:28 <lambdabot> (* -> *) -> *
07:09:40 <dolio> Strong sums have a strong elimination principle. ((x : A) -> (w : P x) -> Q x w) -> (p : Sig A P) -> Q (fst p) (snd p)
07:10:07 <Saizan> Jonno_FTW: weird, there's no constraint on the version of old-time in the cgi tarball
07:10:20 <Jonno_FTW> well that's what cabal told me
07:10:28 <Saizan> Jonno_FTW: can you paste ghc-pkg list and the output of cabal install cgi --dry-run -v ?
07:10:42 <ski> dolio : weaker ones have two separate projections, instead ?
07:10:44 <dolio> Weak sums only give you something like: ((x : A) -> P x -> R) -> Ex A P -> R.
07:11:12 <ski> oh, non-dependent result type
07:12:01 <Jonno_FTW> Saizan: http://pastebin.ws/4eiqbj
07:12:06 <dolio> Yes. You can encode weak sums in the calculus of constructions using the forall eliminator.
07:12:20 <dolio> But not strong sums.
07:12:34 * ski wonders whether there are "strong products" ..
07:13:09 <MissPiggy> like forall??
07:13:23 <MissPiggy> elimination into Type
07:13:44 <ski> i mean a similar distinction between "strong" and "weak" variants
07:14:14 <Saizan> Jonno_FTW: oh, i see, it's just because you've a new old-locale, i'd rather ghc-pkg unregister --global old-locale-1.0.0.2, unless you've a specific reason to want it
07:14:27 <Jonno_FTW> not really
07:14:59 <Jonno_FTW> so how do i make it work?
07:15:28 <medfly> is it okay to say that all functions in Haskell take one parameter and that something like 10 is not a function?
07:15:39 <kamatsu> medfly: yes
07:15:49 <kamatsu> medfly: however 10 is a value, and functions are also values
07:15:58 <Saizan> Jonno_FTW: if you "ghc-pkg unregister --global old-locale-1.0.0.2" first, then cabal install cgi should just use your installed old-time, rather than building a new one
07:16:03 <Alpounet> 10 is like an order-0 value
07:16:04 <fasta> medfly, nobody will kill you for it. Some people claim 10 is the function which returns 10.
07:16:06 <medfly> okay, thanks
07:16:07 <Alpounet> s/value/function/
07:16:18 <medfly> well, it breaks my definition that all functions in Haskell take one parameter
07:16:19 <kamatsu> fasta: isn't that const 10 ;)
07:16:30 <Saizan> medfly: (10 :: Int) is not a function, (10 :: Num a => a) might be
07:16:31 <ski> @type \() -> 10
07:16:32 <fasta> kamatsu, the function applied to 0 arguments.
07:16:33 <lambdabot> forall t. (Num t) => () -> t
07:16:49 <kamatsu> fasta: function is defined as the -> type constructor
07:16:57 <kamatsu> fasta: therefore, it must take a single argument
07:17:04 <fasta> kamatsu, I didn't make it up.
07:17:15 <fasta> kamatsu, I also didn't express any opinion.
07:17:18 <Saizan> i prefer to stick to "functions are those values of type A -> B for some A and B"
07:17:29 <kamatsu> yeah
07:17:30 <fasta> Me too.
07:17:37 <Jonno_FTW> thanks
07:18:10 <zygoloid> medfly: 10 is a function if there's an instance for Num (a -> b) for some a and b :)
07:18:48 <medfly> o.O
07:19:40 * zygoloid once wrote such an instance to make 'f x = 10 x^2 + 4 x + 1' legal
07:19:54 <MissPiggy> terrible
07:20:30 <temoto> zygoloid, what were your a and b?
07:20:36 <ski> (are you sure `10 x^2' didn't become `(10 x)^2', then ? ;)
07:20:47 <zygoloid> ski: legal but not correct ;)
07:21:14 <zygoloid> temoto: i think it was 'instance Num a => Num (a -> a)'
07:21:47 <temoto> :k Num a => Num (a -> a)
07:21:48 <lambdabot>     Class `Num' used as a type
07:21:48 <lambdabot>     In the type `Num (a -> a)'
07:22:05 <temoto> :k forall a. (Num a) => Num (a -> a)
07:22:07 <lambdabot>     Class `Num' used as a type
07:22:07 <lambdabot>     In the type `Num (a -> a)'
07:22:18 * ski . o O ( `(x : A) -> ((y : B x) -> C x y) -> ((f : (x : A) -> B x) -> C x (f x))' ?)
07:22:22 <temoto> right, class expression is not type
07:22:26 <zygoloid> i think church numerals would be 'instance Num ((a -> a) -> (a -> a))'
07:23:05 <ski> zygoloid : at least for power you need `forall a. (a -> a) -> (a -> a)', i think
07:24:04 * ski . o O ( vs. `(x : A) -> (B x -> C) -> (((x : A) -> B x) -> C)' ?)
07:24:58 * ski wants to understand codependent types ! :/
07:28:17 <lpsmith_> fasta:  "10" is a function that returns 10;   thanks to lazy evaluation,  everything is a function,  in a way.
07:28:58 <Saizan> only if you need to encode your values as functions to reason about lazy evaluation :)
07:29:23 <quicksilver> an in another way, not at all, lpsmith_  ;)
07:29:35 <quicksilver> functions are things with type a -> b
07:29:44 <quicksilver> and Int is not of that form.
07:30:12 <quicksilver> but there is certainly a natural sense in which nullary function can be taken to mean value.
07:30:42 <lpsmith> quicksilver, I'm being (only slightly) facetious and didn't make the distinction between language and implementation :)
07:31:38 <lpsmith> But implementationally,  10 *is* a function of no arguments,   unless you run strictness analysis :)
07:31:57 <fasta> lpsmith, there is no one Truth.
07:32:15 <quicksilver> no it's not.
07:32:23 <quicksilver> it is, possibly, a *procedure* of no arguments.
07:32:36 <quicksilver> it's just not a function by any sensible definition of function.
07:33:05 <fasta> That would be a technically more correct way to stating things about the implementation of whatever denotes "10".
07:33:23 <zygoloid> 10 can also be viewed as a function :: Num a -> a, for one interpretation of typeclasses
07:33:34 <fasta> But I think the color of the bike-shed is green.
07:34:02 <medfly> I was just wondering how inaccurate it is, I hoped it's not, since I'm sort of teaching a mate, and that would be misinforming him.
07:34:02 <fasta> Er should be
07:34:26 <lpsmith> quicksilver, pure functions work as well.   The only sense that it would be a procedure is in that you usually want to memoize the result,  which is a very weak form of effect
07:34:34 <medfly> thanks
07:35:20 <medfly> I get that it's kind of subjective, some people prefer to think of 10 as a function.
07:35:33 <fasta> medfly, you just give the mathematical definition of a function and then state that different programming languages call their procedures in different way and that what are called functions in Haskell are relatively close to the mathematical concept.
07:35:46 <lpsmith> well,  until you start talking about implementations,  10 isn't really a function,  I agree
07:36:26 <fasta> medfly, actually, functions are more like rules in mathematics.
07:36:28 <quicksilver> lpsmith: in implementation terms, how is it a function?
07:36:45 <lpsmith> thunks
07:36:53 <quicksilver> those are procedures
07:36:58 <ski> (fasta : "rules" ?)
07:37:00 <quicksilver> a chunk of code which, when called, returns a result.
07:37:09 <zygoloid> there is a sense in which, with lazy evaluation, it can be important to distinguish functions (whose results are not memoized) from values (which are). in that sense 10 is usually not a function.
07:37:14 <lpsmith> Thunks work as pure functions as well
07:37:16 <fasta> ski: you cannot write equations in Haskell and expect a solution.
07:37:24 <fasta> ski: it's one directional.
07:37:29 <lpsmith> functions are a chunk of code that,  when called, retur a result
07:37:37 <quicksilver> lpsmith: no they aren't.
07:37:45 <quicksilver> functions are a mathematical construct
07:37:50 <quicksilver> a pairing of input with result
07:37:55 <quicksilver> if you have no input, it isn't a function.
07:37:57 <ski> fasta : i'm not sure what you mean by "rules", though .. "inference rules" ?
07:38:21 <quicksilver> a function with no arguments is like a ladder with no rungs
07:38:25 <fasta> ski: no, not inference rules. Rules like the "chain rule".
07:38:41 <fasta> ski: well, inference rules are also "rules".
07:38:44 <lpsmith> quicksilver:  () is a value,  () -> Int is a function
07:39:15 <ski> `() -> Int' is a type
07:39:28 <MissPiggy> what's the difference between function and arrow?
07:39:44 <quicksilver> lpsmith: sure, but thunks don't actually require a value of type ()
07:39:49 <quicksilver> lpsmith: there is no () being passed.
07:39:52 <zygoloid> MissPiggy: you mean, between a Haskell function and an instance of typeclass Arrow?
07:39:52 <ski> MissPiggy : in what context =
07:39:57 <MissPiggy> no
07:39:57 <ski> s/=/?/
07:40:08 <zygoloid> MissPiggy: or between a mathematical function and a category-theoretical morphism?
07:40:16 <lpsmith_> quicksilver:  () is a value,  () -> Int is a function
07:40:20 <MissPiggy> oh right I guess arrow needn't be a function
07:40:20 <lpsmith_> The more salient feature of "procedures" are the possiblity of effects,  versus (pure) functions
07:40:23 <quicksilver> the fact that "Int" is isomorphic to "() -> Int" doesn't make everything in Int a cuntion.
07:40:37 * ski insists that `() -> Int' is not a function. it is a type
07:40:39 <quicksilver> function.
07:40:40 <dolio> ski: Having "fst : Sig A P -> A" and "snd : (p : Sig A P) -> P (fst p)" is an equivalent elimination for strong sums.
07:40:59 <lpsmith_> And GHC's thunks do use a very weak kind of effect,  behind the scenes
07:41:07 <ski> dolio : ok. interesting
07:41:15 <dolio> So being unable to project out the components is an important part of a sum being weak.
07:41:35 <ski> dolio : you can project in a weak sum ?
07:41:41 <lpsmith_> quicksilver, you can implement an (usually inefficient) haskell interpreter using *pure functions* in scheme or ml
07:41:43 <dolio> You cannot.
07:42:00 <lpsmith_> Int becomes () -> Int
07:42:07 <zygoloid> () -> Int isn't isomorphic to Int, even, since \() -> 42 and \_ -> 42 are distinguishable.
07:42:26 <quicksilver> lpsmith_: I know. It's a stupid argument about naming and I'm wasting your time.
07:42:32 <zygoloid> would it be confusing to say they're strictly isomorphic? :)
07:42:35 <quicksilver> But I refuse to call "42" a function with no argument.
07:42:36 <idnar> 42 is not of type () -> Int
07:42:54 <idnar> in Haskell
07:43:07 <lpsmith_> idnar, zygoloid;  the issue is in language versus implementation
07:43:09 <zygoloid> idnar: not with the usual set of Num instances :)
07:43:49 <idnar> zygoloid: well, heh
07:43:59 <idnar> lpsmith_: I don't understand what the implementation has to do with anything, though
07:44:33 <idnar> lpsmith_: even if you have a Haskell interpreter that uses () -> Int somewhere, that's completely irrelevant to the type of 42
07:44:35 <zygoloid> lpsmith_: are assuming that 'function' has some predefined meaning in the terminology of the implementation then?
07:44:57 <idnar> the 42 is code in your program, not in the interpreter program
07:45:05 <ski> dolio : oh, right .. you can't do the proof projecttion ..
07:45:32 <lpsmith_> idnar, it can be important when reasoning about run-time behavior.
07:45:53 <dolio> You can only eliminate into a type not depending on the components of the weak sum.
07:45:56 <lpsmith_> zygoloid, I'm using "function" in a fairly standard CS sense.  (and mathematical,  if you want)
07:45:59 <idnar> lpsmith_: I'm objecting to the translation of "is implemented by" into "is"
07:46:54 <lpsmith_> idnar:  lpsmith: quicksilver, I'm being (only slightly) facetious and didn't make the distinction between language and implementation :)
07:46:54 <zygoloid> lpsmith_: it's not implemented as a function either, really. it's implemented as a self-overwriting thunk typically.
07:46:59 <idnar> you might as well say that 42 is a sequence of electrical impulses, because running the compiled program (or the interpreter) involves electricity in your computer
07:47:07 <lpsmith_> "is" can be ambiguous
07:47:15 <MissPiggy> procedure
07:47:19 <MissPiggy> function
07:47:28 <jaspervdj> can someone explain this rather strange behaviour to me? :t (length . show) returns (Show a) => a -> Int, which makes sense
07:47:32 <idnar> also, if every value is a function, and every function is a value, the existence of both terms becomes pointless
07:47:38 <idnar> it's only useful to have both if they mean different things
07:47:49 <jaspervdj> but if I do: let ls = length . show, then :t ls I get () -> Int
07:48:05 <zygoloid> jaspervdj: that's the monomorphism restriction.
07:48:13 <MissPiggy> jaspervdj :(
07:48:15 <idnar> jaspervdj: the let binding is monomorphic; and defaulting picks the () instance for you
07:48:17 <McManiaC> what package contains Text.Regex ?
07:48:25 <jaspervdj> McManiaC: regex-compat
07:48:35 <McManiaC> thx
07:48:36 <McManiaC> :)
07:48:45 <jaspervdj> idnar: okay, thanks
07:49:20 <idnar> you can supply an explicitly polymorphic type signature (or use the NoMonomorphismRestriction, I guess?)
07:49:38 <lpsmith_> idnar, saying 42 is a sequence of electrical pulses is also true;  but that's not something that's true in all contexts:   my 42 is a different set of electrical pulses than your 42;  but (only slightly facetiously) saying that 42 is a function in GHC is fairly universally true.
07:49:59 <MissPiggy> lpsmith_ WHAT???
07:50:02 <lpsmith_> Unless you compile with the strictness analyser turned on of course
07:50:26 <idnar> lpsmith_: well, I think that's an absurdly loose use of the verb "is"; but okay, whatever
07:50:30 <MissPiggy> universally true in the specific context of ONE compiler
07:50:54 <lpsmith_> well, what implementation of Haskell doesn't use thunks?
07:51:02 <MissPiggy> also thunks aren't function
07:51:09 <lpsmith_> They can be
07:51:09 <MissPiggy> they're suspensions or whatever
07:51:11 <idnar> I'm not sure how you can say "in GHC" and then "universally", either ;)
07:51:22 <MissPiggy> not really relevant
07:51:27 <MissPiggy> what they can be is not what they are
07:51:42 <MissPiggy> just because you can implement them in whatever way
07:51:46 <quicksilver> thunks are only functions in the *incorrect* terminology of the implementation language.
07:51:56 <idnar> a thunk for an Int value isn't the same as a function () -> Int, either, although they may be somewhat similar
07:52:09 <quicksilver> if you were implementing haskell in C, then very likely you'd implement it as a C function pointer
07:52:09 <yrlnry> How can I tell ghc to always include /home/mjd/lib/haskell in its search path, without having to supply a -i command-line flag every time?
07:52:17 <quicksilver> but C function pointers have nothing to do with functions
07:52:22 <quicksilver> it's just a plain incorrect usage
07:52:34 <quicksilver> C function pointers point to blocks of code - they're procedure pointers.
07:52:48 <lpsmith_> quicksilver, it's well established terminology in CS
07:52:53 <quicksilver> well established and wrong, yes.
07:52:55 <lpsmith_> vocabulary is ambiguous
07:53:00 <quicksilver> and that's all I'm arguing about.
07:53:05 <quicksilver> I did already admit it was a silly argument.
07:53:08 <idnar> thunks are self-modifying too, aren't they?
07:53:24 <MissPiggy> what does ambiguity have to do with it?
07:53:26 <fasta> idnar, they don't have to be ;)
07:53:29 <lpsmith_> idnar, yes,  I've mentioned that
07:53:47 <idnar> fasta: well, I assume we're still talking about GHC's thunks
07:53:50 <lpsmith_> they don't have to be,  although often you want them to be,  and it's a weak kind of effect
07:54:01 <fasta> idnar, in that case, yes.
07:54:02 <MissPiggy> it's not linguistic ambiguity if you name something in a bizarre illogical way... it's still wrong
07:54:24 <lpsmith_> MissPiggy, the CS notion of a function is not bizarre or illogical
07:54:34 <MissPiggy> i have no idea what you mean by CS notion of a function btw
07:54:50 <MissPiggy> do you mean procedure like in lisp?
07:54:55 <lpsmith_> sure
07:54:56 <idnar> I guess the whole evolution vs. creation debate is just a linguistic ambiguity, too ;)
07:54:57 <lpsmith_> Or C
07:55:01 <MissPiggy> yeah C isn't CS
07:55:16 <lpsmith_> or almost every programming language other than Haskell
07:55:18 <lpsmith_> I beg to differ
07:55:25 <fasta> AFAIK, a function is CS is anything not talking to the outside world.
07:55:27 <lpsmith_> C is an important part of CS
07:55:34 * idnar boggles
07:55:43 <quicksilver> C is an important part of software engineering
07:55:50 <lpsmith_> and CS
07:55:57 <quicksilver> it takes almost no contribution from CS, and makes almost no contribution to CS
07:56:02 <lpsmith_> both false
07:56:36 <MissPiggy> I dunno I think the value of C (in terms of theory) is a bit over-estimate, because it gets used so much
07:56:52 <xcthulhu> How do I use lambdabot to find the SKI combinators for a lambda expression?
07:57:04 <MissPiggy> of course it's the object-of-study for a lot of static analysis tools but they fundamentals apply to other contexts too
07:57:08 <lpsmith_> MissPiggy, talk to algorithms people
07:57:22 <fasta> I retract my last comment.
07:57:24 <yrlnry> Found I can put :set -i/home/mjd/lib/haskell in ~/.ghci ; thanks folks.
07:57:26 <MissPiggy> yeah I don't know many algorithms people
07:57:36 <idnar> I don't understand how C is of any use or interest except in an implementation context
07:57:43 <lpsmith_> They often prefer C to other languages
07:57:53 <fasta> lpsmith_, they being?
07:57:54 <yrlnry> Not that anyone asked, but this is the first time I've ever come in here and found a discussion going on that sounded like IRC instead of like #haskell.
07:58:19 <idnar> grinding a telescope lens is not astronomy
07:58:27 <idnar> implementing an algorithm in C is not CS
07:58:44 <fasta> The only reason algorithm implementations are done in C is because it doesn't restrict what you can do in a silly way.
07:58:49 <fasta> E.g. like Java does.
07:58:52 <lpsmith_> yrlnry:   I agree :-(
07:58:52 * MissPiggy would like to welcome you to this course on computer science,
07:59:00 <xcthulhu> idnar:  Implementing in general isn't CS?
07:59:00 <MissPiggy> (Actually, it's a terrible way to start)
07:59:12 <fasta> Even with Haskell you cannot be sure that slow-downs come from the RTS.
07:59:18 <idnar> xcthulhu: well, I wouldn't say so, anyway
07:59:21 <fasta> do not come*
07:59:29 <Alpounet> C is a programming language, and writing code in a programming language can be considered as C-S right ?
07:59:32 <lpsmith_> fasta, that and it's relatively easy to understand what is actually going on underneath the language
07:59:37 <MissPiggy> Alpounet, not imo
07:59:49 <Alpounet> what is it then ?
07:59:50 <fasta> C is useful, because it implements a few very specific primitives and they work and are predictable.
07:59:58 <MissPiggy> engineering, putting science to work
07:59:59 <fasta> lpsmith_, right.
08:00:02 <quicksilver> Alpounet: software engineering, or software development
08:00:09 <Alpounet> oh okay
08:00:25 <lpsmith_> There is a reason why TAOCP is written in assembly language.
08:00:27 <Alpounet> C-S here means the pure scientific domain
08:00:42 <fasta> If you compare algorithms for performance, C is often used, but most of the time it is C++ now, I think.
08:00:43 <Alpounet> and software engineering is the application of C-S to real world stuffs ?
08:00:48 <idnar> Alpounet: well, it does say "Science" in the name
08:00:53 * xcthulhu considers programming in C more like CS than, say, worrying about the same algorithms in the context of Turing or Oracle machines
08:01:02 <xcthulhu> Since the latter is just nonsense
08:01:06 <fasta> Most algorithms are specified in some LaTeX class ;)
08:01:17 <fasta> (if you are lucky)
08:01:23 <idnar> xcthulhu: designing or discussing an algorithm might be CS; implementing the algorithm isn't
08:01:29 <Alpounet> yeah but its application can still be considered as scientific, depending on one's point of view.
08:01:30 <aledge> xcthulhu, implementation is CSE
08:01:31 <fasta> And it is some kind of pseudo-code which is isomorphic to C.
08:01:44 <temoto> Applied CS :)
08:01:47 <aledge> fasta, don't you mean some \latex class?
08:01:51 <aledge> :)
08:02:53 <fasta> lpsmith_, yep. That was sort of a smart move by Knuth.
08:03:14 <zygoloid> lpsmith_: if you're using this notion of 'it's a function' as a way of explaining how laziness is implemented, then your explanation is incorrect for a lazy language
08:03:47 <lpsmith_> oh?
08:03:50 <zygoloid> ... unless your notion of function is general enough to cover 'a function which as its last act overwrites the call to itself with the result of its evaluation'
08:04:02 <lpsmith_> zygoloid, I've said many times already
08:04:02 <fasta> I think everyone has a good idea of how everything works here.
08:04:10 * MissPiggy doesn't
08:04:11 <fasta> Just arguing about words.
08:04:11 <lpsmith_> that exact point
08:04:25 <xcthulhu> I'm still curious how to use lambdabot to study the SKI calculus, if anybody could show me how...
08:04:34 <zygoloid> lpsmith_: my point is that if you're using this as a way to explain to beginners how it works, saying 'it's a function' may be unhelpful
08:05:00 <fasta> xcthulhu, installing ghci and getting a package from Hackage with the definitions works better.
08:05:15 <fasta> xcthulhu, failing that, find the Wikipedia page and implement the definitions in 3 lines of Haskell.
08:05:30 <zygoloid> if you say 'it starts as a function then is replaced by a value after it's first used', that'd probably be much more helpful, i think
08:05:48 <xcthulhu> fasta, That you
08:05:50 <jmcarthur> xcthulhu: the ((->) a) applicative functor is S and K. you could just play with that
08:06:02 <MissPiggy> zygoloid: why not say suspension
08:06:09 <MissPiggy> which may or may not be implemented as a procedure
08:06:23 <MissPiggy> in an OO language you might implement it as an object, for example
08:06:33 <idnar> zygoloid: I personally don't think it's useful to get into that unless you're actually discussing implementations
08:06:54 <xcthulhu> fasta, For what I need to do I'll just use my lambda calculus book and do it by hand I think.
08:07:01 <zygoloid> idnar: i thought lpsmith_ was trying to explain how the implementation works.
08:07:10 <zygoloid> or at least, how it might work ;-)
08:07:12 <fasta> xcthulhu, pen and paper sharpen the mind.
08:07:17 <MissPiggy> I think lpsmith_ just wanted to argue about wording or something
08:07:22 <idnar> zygoloid: I don't think he was trying to explain anything, we're just arguing about semantics and linguistics
08:07:37 <quicksilver> to be fair to poor lpsmith_, I was the pedant who picked the wording fight.
08:07:47 <quicksilver> He was just defending himself, and I regret it.
08:07:53 <fasta> quicksilver, you always do that! ;)
08:07:57 <quicksilver> I do, yes.
08:08:04 <lpsmith_> Thank you, quicksilver :)
08:08:17 <quicksilver> I have strong opinions about things I consider incorrect wording, because I think they lead to incorrect intuition.
08:08:18 <idnar> I'm not even sure who started the whole thing
08:08:25 <idnar> I missed the original question / statement that everyone responded too
08:08:26 <quicksilver> (like the 'lazy' in 'lazy IO')
08:08:26 <idnar> *to
08:08:38 <quicksilver> but I should try a bit harder not to assault people with them.
08:08:51 <idnar> I scrolled up a few pages but got bored before I found the top ;)
08:08:52 <lpsmith_> Me,  CS vocabulary is too diverse to worry about arguing over wording too much
08:08:58 * idnar stabs quicksilver with a pointy adverb
08:09:15 * quicksilver deflects idnar with a gerund before KO'ing him with an appositional clause.
08:09:29 <lpsmith_> And it's helpful to have a broad view of the different terminologies to facilitate conversations.
08:09:41 * idnar collapses, prepositions spraying everywhere
08:10:17 <lpsmith_> quicksilver, I'll agree with you on the "lazy" point;  saying that something "lazy" is usually too vague to be of much use
08:10:41 <jmcarthur> i like the style of "let <term> = <blah blah blah> in <discussion>" ... that way everybody is on the same page and we don't waste time arguing over stupid definitions
08:11:24 <idnar> jmcarthur: except you can't define /everything/ upfront, that's just not feasible
08:11:38 <lpsmith_> jmcarthur, idnar:  agreed :)
08:11:49 <fasta> idnar, the symbol grounding problem.
08:12:03 <quicksilver> jmcarthur's idea seems to suggest I know what I'm going to say in a discussion beforehand.
08:12:07 <jmcarthur> idnar: of course, but during the course of conversation if there is confusion over a term then the initiator of the coversation should be allowed to state a working definition so we can just move on
08:12:09 <fasta> With high-probability everyone knows what "the" means here.
08:12:11 <quicksilver> where is the poetry in that?
08:12:35 <lpsmith_> I say,  define a few things that are particularly important for the conversation,  and hopefully a good discussion will sort out the most salient definitional issues if something arises
08:12:54 <ski> (fasta : what does "the" mean exactly ? ;-P )
08:13:03 <idnar> jmcarthur: well, that's a fair point
08:13:12 <fasta> ski: I am not going to explain :D
08:13:19 <Saizan> it's nice to discriminate when some definitions are more useful than others
08:13:25 <idnar> jmcarthur: in this case, the discussion was /about/ definitions/semantics/whatever
08:13:29 <ski> ("but how can you know, if you can't explain ?" :)
08:13:38 <idnar> jmcarthur: but if you're actually trying to make a point about something else, it's frustrating to get side-tracked like that
08:13:54 <Saizan> e.g. if we're talking about haskell in denotational terms then the definition of function induced by the types is the most appropriate
08:13:54 <jmcarthur> it solves a lot of problems. for example, the question earlier as i understand it was something along the lines of "Is C a part of CS?" but i think it would have been better as "For X definition of CS, is C a part of it?"
08:14:00 <idnar> ski: nobody knows anything
08:14:05 <idnar> ski: problem solved
08:14:27 <ski> ah. ty
08:14:36 <idnar> ;)
08:14:59 <idnar> jmcarthur: that gives you a tautology
08:15:00 <jmcarthur> Saizan: agreed. i guess we could say that the definitions can also be bound implicitly by context sometimes
08:15:17 <jmcarthur> idnar: :P
08:15:19 <idnar> jmcarthur: at least, it does in most cases
08:15:47 <Saizan> it's more interesting "how do you define CS?" at that point
08:15:51 <jmcarthur> idnar: then the debate was unnecessary
08:16:05 <idnar> somebody says "X is Y!", somebody else goes "what do you mean by Y?", the reply is "Y = X"
08:16:09 <lpsmith_> I don't see how a sensible discussion of CS can exclude C,  to be honest
08:16:26 <lpsmith_> Err,  defintiion, not discussion
08:16:28 <jmcarthur> lpsmith_: for what definition of CS?
08:16:46 <lpsmith_> I don't see how a sensible definition of CS can exclude C,  to be honest
08:16:54 <jmcarthur> "Naturally, CS without C would just be S!"
08:16:58 <idnar> I don't want to exclude C, I just want to exclude the activity of writing C code from the set of activities included in CS
08:16:59 <lpsmith_> hahaha
08:17:07 <idnar> jmcarthur: hahaha
08:17:30 <lpsmith_> idnar, depends on the kind of C code being written,  but then that's true of all languages
08:17:37 <idnar> constructing tools to help you do science is engineering, not science
08:17:57 <fasta> idnar, so, you think developing something hugely complicated happens by not ever writing a single line of computer code?
08:18:07 <idnar> fasta: of course not
08:18:18 <jmcarthur> i just hate arguments like "X is Y" and "A is not B" without actually saying with X, Y, A, or B are
08:18:19 <fasta> idnar, so, then a programming language is required.
08:18:33 <fasta> idnar, and C is not a very bad tool for that.
08:18:36 <jmcarthur> Buffalo is not buffalo!
08:18:39 <fasta> idnar, so, C has to do with CS.
08:18:55 <lpsmith_> But my point is,  C (or rather,  a C-like language) is such a central part of CS at this point in time,  and probably will be for decades
08:18:57 <idnar> fasta: no more so than grinding a mirror is part of astronomy
08:19:19 <idnar> fasta: engineering and science frequently go hand in hand, but I'd prefer to distinguish them than to just lump them together
08:19:20 * jmcarthur feels like nobody has taken his advice
08:19:20 <lpsmith_> We shouldn't be so arrogant to dismiss the intellectual contributions of C and it's community
08:19:35 <lpsmith_> That doesn't mean you have to enjoy writing C code;  that's an entirely different issue :)
08:19:45 <Alpounet> jmcarthur, indeed
08:20:47 <fasta> idnar, I agree with that. C adds nothing fundamental.
08:21:19 <fasta> Then again, Haskell also doesn't ;)
08:21:41 <lpsmith> Well,  yes and no,  on both counts :)
08:21:41 <idnar> fasta: I wouldn't single out C specifically; writing code is writing code
08:22:03 <fasta> idnar, and writing code is equivalent to specifying an algorithm.
08:22:16 <fasta> idnar, some people think waving hands also counts.
08:22:22 <idnar> fasta: heh
08:22:30 <quicksilver> but the contrast is that haskell is based very specifically on a set of principles derived from theory; and evolving haskell extensions continue to explore current theory; and a lot of good theory is based on haskell
08:22:52 <quicksilver> so there is an intimate connection between haskell and evolving CS, especially PL + logic
08:22:55 <idnar> fasta: well, sure; and it's pretty hard to do science without communicating with other people, so you need language too
08:22:57 <quicksilver> (the same would be true of ML)
08:23:03 <quicksilver> but far, far less so of C.
08:23:07 <theorbtwo> I think there's an assumption that C is the least common denominator of languages... it's not really true, but there's that assumption.
08:23:19 <idnar> fasta: pretty much everything is interconnected at some level
08:23:58 <idnar> fasta: making various distinctions between things isn't a rejection of that reality
08:24:23 <jmcarthur> "Computer science or computing science (sometimes abbreviated CS) is the study of the theoretical foundations of information and computation, and of practical techniques for their implementation and application in computer systems."
08:24:49 <idnar> jmcarthur: so it's the study of application, not the application itself ;)
08:24:53 <jmcarthur> i think that definition is a bit broad, and some of us are working with more specific versions than others
08:25:02 <fasta> idnar, you forgot the and part
08:25:27 <jmcarthur> idnar: i will agree with you
08:25:43 <idnar> fasta: the study of ((the theoretical foundations ...) AND (practical techniques ... application ...))
08:26:18 <fasta> idnar, so, how do you study how practical something is without practice?
08:26:45 <idnar> fasta: you can't, of course
08:26:47 <fasta> idnar, you write a simulation of a computer scientist living in a 3d dimensional world which does that?
08:28:16 <idnar> fasta: but what's the use of having different terms for different things if you're just going to throw your hands up and say "well, they're all interconnected, so let's just pretend everything is the same thing"?
08:28:22 <jmcarthur> according to the wikipedia definition i quoted, it's theory and metapractice ;)
08:29:04 <idnar> I don't see how you can do that without losing all significance of meaning
08:29:05 <fasta> idnar, I am not saying you do CS when you implement quicksort. You are doing CS when you figure out a better way to do quicksort.
08:30:32 <idnar> fasta: all I'm saying is that the action of finding a better way to do quicksort is distinct from the action of implementing quicksort, even if you are performing the latter action in aid of the former action
08:30:41 <fasta> And figuring out is the same as writing a correct and complete algorithm, which is the same as an implementation.
08:30:52 <fasta> idnar, so, we disagree on that point.
08:31:11 <fasta> idnar, if you have not implemented it, or have written a formal proof, how can you know that you really understand?
08:31:33 <fasta> idnar, you can't, as evidenced by the crap some purely theoretical computer science people produce.
08:31:35 <idnar> fasta: "A is necessary for B" does not imply "A = B"
08:32:25 <jmcarthur> i drive to work every day, therefore driving is my job
08:32:50 <idnar> fasta: having this conversation requires both of us to participate in it; that doesn't mean that the conversation and us somehow become the same entity
08:32:55 <jmcarthur> or even: i drive to work every day, therefore driving is part of my job
08:33:18 <fasta> idnar, give an example of theoretical computer science which states something which is not formal and is not crap.
08:33:21 <lpsmith> well,  getting to work certainly is part of your job :-P
08:34:02 <jmcarthur> lpsmith: my job is to research and write code. the location that i do that job is incidental
08:34:38 <fasta> jmcarthur, it's not incidental that at some location in the universe you have to do your work.
08:34:47 <jmcarthur> interestingly, the code i write is mostly prototype code. is it CS or software engineering?
08:35:02 <idnar> the location and the job are distinct things
08:35:09 <idnar> even if they're not incidental
08:35:19 <fasta> idnar, that's why it was a "part of".
08:35:26 <jmcarthur> i do work from home sometimes. or sometimes i must fly to a location rather than drive
08:35:39 <idnar> I don't understand why you object to distinguishing interrelated things
08:36:05 <fasta> idnar, I don't see why you cannot give a simple counter-example.
08:36:08 <MissPiggy> well I have been trying everything to get some basic latex output and it is just not working
08:36:12 <jmcarthur> idnar: The way you worded that reminds me of the way imperative programmers see monads.
08:36:14 <idnar> fasta: because we're arguing semantics
08:36:19 <MissPiggy> I am just too unlucky or stupid or whatever it is to use latex
08:36:32 <jmcarthur> What's the point of distinguishing your side effects from the rest of your code?
08:36:41 <MissPiggy> all i want is a REPL that can display properly typeset math
08:36:45 <MissPiggy> for GHCi
08:37:03 <quicksilver> tht would be really nice
08:37:08 <fasta> MissPiggy, implement a TeXMacs module and you are ready to go.
08:37:10 <quicksilver> I would think it would be difficult to get working.
08:37:14 <MissPiggy> I can't install TeXMacs
08:37:16 <idnar> fasta: no counter-example exists in your interpretation
08:37:27 <idnar> jmcarthur: heh
08:37:29 <MissPiggy> the problem is that I am on mac os x because I am too dumb to fix linux every few months
08:37:42 <MissPiggy> so none of the tools I actually want to use, like TeXMacs and Tex2html work
08:37:50 <fasta> MissPiggy, just don't install n00buntu.
08:38:08 <MissPiggy> fasta, that's what I was using :p Is there a better one?
08:38:14 <fasta> MissPiggy, it's a plot by Microsoft to waste the time of people.
08:38:34 <fasta> MissPiggy, I never had meaningful problems with Debian.
08:38:50 <MissPiggy> okay
08:38:51 <jmcarthur> my problem with ubuntu is that in its effort to hide its guts it also makes it harder to diagnose problems
08:38:52 <fasta> MissPiggy, but I might try ArchLinux these days.
08:39:28 <jmcarthur> ubuntu is just too complex to fully understand :\
08:40:05 <Alpounet> fasta, ArchLinux is a very good distro
08:40:23 <Alpounet> (for my use at least)
08:40:46 <fasta> Alpounet, I used it before most did and it was technically a good one, there just were not enough packages.
08:40:55 <fasta> Alpounet, but that has probably changed now.
08:41:00 <Alpounet> yes
08:41:08 <Alpounet> it has changed
08:41:22 <MissPiggy> okay so I'll try arch linux
08:41:27 <MissPiggy> I'm pretty sure haskell works well on that
08:41:35 <MissPiggy> and I imagine all the tex stuff does too
08:41:35 <Alpounet> MissPiggy, there is a great support of haskell in Arch
08:42:07 <Alpounet> and tex-related tools too
09:26:31 <ehamberg> hi. my brain isn't working today. how can i call “writeFile fileName "foo"” only if (not . null) args? (fileName = head args)
09:26:39 <ehamberg> i.e. an if without a matching else :)
09:26:54 <MissPiggy> o_o
09:27:10 <MissPiggy> @src when
09:27:11 <lambdabot> when p s = if p then s else return ()
09:27:12 <MissPiggy> this?
09:28:04 <ehamberg> yes! “when” is it. thanks. :)
09:48:48 <ToRA> hey guys, my brains failing me
09:48:56 <ToRA> can anyone give me a one-liner that causes a haskell stack overflow?
09:49:17 <mauke> foldl is good for that if you don't compile with optimizations
09:49:30 <Berengal> foldl (+) 0 [1..10^10]
09:49:45 <aavogt> > error "Stack Overflow"
09:49:46 <lambdabot>   * Exception: Stack Overflow
09:49:54 <Berengal> > foldl (+) 0 [1..10^10]
09:49:56 <djahandarie> lol aavogt
09:50:02 <zygoloid> @type Data.Foldable.sequence_ $ flip writeFile "foo" <$> listToMaybe ?args
09:50:05 <lambdabot>   mueval: ExitFailure 1
09:50:09 <zygoloid> ehamberg: ^^ could do it like that i guess :)
09:50:13 <Berengal> > foldl (+) 0 [1..10^8]
09:50:19 <lambdabot> (?args::[FilePath]) => IO ()
09:50:22 <lambdabot>   mueval-core: Time limit exceeded
09:50:26 <Berengal> :/
09:50:33 <aavogt> > let x = x in x
09:50:37 <lambdabot>   mueval-core: Time limit exceeded
09:50:44 <ToRA> the foldl (+) attempts keep out of memorying me, not out of stack
09:50:55 <ToRA> probably because of strictness of (+)
09:50:58 <ToRA> ?
09:51:04 <aavogt> > let x = succ x in x
09:51:05 <lambdabot>   * Exception: Prelude.Enum.().succ: bad argument
09:51:14 <aavogt> > let x = succ x in x :: Nat
09:51:15 <lambdabot>   No instance for (GHC.Enum.Enum L.Nat)
09:51:16 <lambdabot>    arising from a use of `GHC.Enum.su...
09:51:18 <aavogt> > let x = succ x in x :: Natural
09:51:20 <lambdabot>   Not in scope: type constructor or class `Natural'
09:51:25 <Alpounet> > length [1..]
09:51:29 <lambdabot>   mueval-core: Time limit exceeded
09:51:36 <ehamberg> zygoloid: i'll stick to “when” ;)
09:52:04 <djahandarie> > uncurry (/) . foldl' (\(acc, len) x -> (acc+x, len+1)) (0,0)
09:52:08 <lambdabot>   mueval-core: Time limit exceeded
09:53:20 <djahandarie> > print (last (scanl (+) 0 [1..10^10]))
09:53:22 <lambdabot>   <IO ()>
09:53:36 <djahandarie> lol
09:53:41 <djahandarie> > last (scanl (+) 0 [1..10^10])
09:53:47 <lambdabot>  Terminated
09:53:56 <djahandarie> TERMINATED
09:54:11 <copumpkin> > foldl' (+) 0 (10^10)
09:54:13 <lambdabot>   No instance for (GHC.Num.Num [a])
09:54:13 <lambdabot>    arising from the literal `10' at <inte...
09:54:25 <copumpkin> > foldl' (+) 0 [1..10^10]
09:54:29 <lambdabot>   mueval-core: Time limit exceeded
09:54:38 <djahandarie> copumpkin, that shouldn't stackoverflow afaik
09:54:39 <Alpounet> it exceeds before it overflows the stack
09:54:57 <copumpkin> > foldl' (+) 0 [1..10^5]
09:54:59 <lambdabot>   5000050000
09:55:27 <ToRA> > foldl (+) (0::Integer) [1..100000]
09:55:28 <lambdabot>   5000050000
09:56:02 <djahandarie> ToRA, that would stack overflow if it were big enough
09:56:02 <benmachine> > last $ scanl (+) 0 [1 .. 10^5]
09:56:04 <lambdabot>   5000050000
09:56:10 <djahandarie> You know I think there is a page on this somewhere
09:56:20 <benmachine> > foldl (+) 0 [1 .. 10^5]
09:56:21 <lambdabot>   5000050000
09:56:33 <benmachine> > last $ scanl (+) 0 [1 .. 10^6]
09:56:35 <lambdabot>   * Exception: stack overflow
09:56:40 <djahandarie> ToRA, http://www.haskell.org/haskellwiki/Stack_overflow
09:56:45 <ToRA> yeah that's what I'm looking at
09:56:46 <djahandarie> benmachine, lol nice you found the sweet spot
09:56:55 <benmachine> the sweet order of magnitude
09:56:58 <benmachine> hardly precise >_>
09:57:00 <ToRA> except on this machine it just floods the heap
09:57:05 <copumpkin> > foldl' (+) 0 [1 .. 10^6]
09:57:07 <lambdabot>   500000500000
09:57:11 <copumpkin> > foldl' (+) 0 [1 .. 10^7]
09:57:13 <lambdabot>   50000005000000
09:57:15 <djahandarie> copumpkin, that won't stack overflow lol
09:57:19 <copumpkin> I know :)
09:57:26 <djahandarie> >_<
09:57:29 * djahandarie goes back to his job
09:57:38 <copumpkin> but 10^10 doesn't terminate in time so I was wondering what would
10:05:22 <student2> does anyone knows how to work with Request and IO Response?
10:05:32 <kmc_> what context?
10:05:49 <student2> a server that gets a Request en gives a IO Response back
10:06:00 <kmc_> okay
10:06:13 <kmc_> well i don't know what these Request and Response types are; do they come from some library you're using?
10:06:26 <kmc_> i can explain how to work with IO types in general
10:06:45 <student2> yes i'm using a library
10:06:57 <jmcarthur> HTTP?
10:07:04 <student2> let me see what the exact name is of it
10:07:05 <student2> brb
10:07:44 <student2> it's httpd-shed
10:08:09 <kmc_> ah, i've used that library
10:08:12 <kmc_> so what are you trying to do?
10:08:18 <jmcarthur> huh i never even heard of it
10:08:31 <student2> I'm just trying to get the URI from the request
10:08:44 <jmcarthur> reqURI request
10:08:45 <kmc_> http://hackage.haskell.org/packages/archive/httpd-shed/0.4/doc/html/Network-Shed-Httpd.html
10:10:10 <student2> what does this excatly mean: data Request = Request { reqMethod :: String reqURI :: URI reqHeaders :: [(String, String)]
10:10:36 <student2> and how doe i get the URI from it, via pattern matching or something like that
10:10:46 <mauke> <jmcarthur> reqURI request
10:10:52 <temoto> student2, reqURI value
10:11:16 <student2> but the type of my function is Request -> IO Response
10:11:48 <temoto> student2, and?
10:12:09 <student2> that means that the argument (to speak in java) is of type Request
10:12:12 <temoto> uri = reqURI request
10:12:13 <mreh> well I want to do some heavy signal processing on some music, e.g. cut out everything but the bass and then automatically transcribe it
10:12:53 <temoto> student2, yes it does mean so even in terms of haskell. But what's the problem with argument type?
10:13:00 <aledge> mreh, is there a well known way to do that?
10:13:17 <student2> is it possible to do something like f (reURI val) = something with the val?
10:13:33 <student2> as pattern matching
10:13:43 <temoto> student2, yes but not via pattern matching.
10:13:51 <student2> How then?
10:13:58 <student2> via witch way?
10:13:59 <Saizan> you can via pattern matching too
10:14:13 <jmcarthur> aledge: doesn't sound too new to me
10:14:14 <temoto> f request = print $ reqURI request
10:14:24 <Saizan> student2: f x = let uri = reqURI x in ..
10:14:30 <aledge> jmcarthur, automatic transcription?
10:14:39 <jmcarthur> fourier transform to get frequencies and get the peak frequencies in the lower end of the spectrum
10:14:44 <aavogt>  case x :: Request of Request method uri -> ...
10:14:46 <Saizan> student2: reqURI is an accessor function there
10:14:48 <student2> thank you both, i'll try and see
10:14:55 <aledge> jmcarthur, hm true but can that actually transcribe chords etc?
10:14:58 <jmcarthur> quantize those to nearest pitches in chromatic scale
10:15:00 <mreh> aledge: with a clean enough signal it's easy, the bass is the perfect example, it cuts straight through when you filter out everything sub 160 hz
10:15:04 <jmcarthur> should be able to just fine
10:15:07 <MissPiggy> yeah turns out arch is too hardcore for me or something
10:15:11 <marcot> Hi.  Is quot and rem different from div and mod only if the second parameter is negative?
10:15:11 <Saizan> student2: also, you can pattern match like this: f Request{reqURI = uri } = ..
10:15:15 <aledge> i'm familiar with fourier transform but have never tried it myself on that application
10:15:17 <MissPiggy> I should use a distro that's more 'friendly' whatever that means
10:15:21 <jmcarthur> but even then, you don't usually have chords in the bass end of music
10:15:22 <aledge> i would believe it if it were possible
10:15:31 <aledge> oh is he talking about transcribing the bass?
10:15:31 <student2> to mutch typing i can't read it al
10:15:37 <aledge> i read it as the other way around
10:15:59 <jmcarthur> chords aren't much harder anyway, at least in theory
10:16:04 <aledge> you could imagine transcribing an electric guitar, for example, would be difficult
10:16:07 <mreh> aledge: how did you read it
10:16:12 <aledge> killing the bass
10:16:14 <jmcarthur> it gets harder when you need to isolate individual instruments in the same pitch range
10:16:17 <aledge> high pass filter, e.g.
10:16:26 <aledge> jmcarthur, yes this is more or less what i was thinking i suppose
10:16:33 <mreh> the only thing in the same freq range as the bass is the bass drum
10:16:44 <mreh> and you can filter that out easily
10:16:44 <student2> Saizan doen je mean something like f (Request{reqURI = uri}) = somthing wit the variable uri?
10:16:51 <aledge> oh cut everything but the bass
10:16:52 <aledge> yes ok
10:16:55 <Saizan> student2: yes
10:17:03 <student2> tnq i'll try
10:17:11 <student2> brb if it doesn't work
10:17:18 <Saizan> student2: that's part of the so called "record syntax"
10:17:21 <temoto> student2, see, record syntax in data Request = Request { reqMethod :: String, reqURI :: URI } in fact creates data constructor Request String URI and two functions: reqMethod (Request method _) = method and reqURI (Request _ uri) = uri.
10:17:27 <aledge> i was getting excited, because i had been thinking about doing something similar, but at the opposite end of the spectrum
10:17:32 <Saizan> student2: it's just simple syntactic sugar btw
10:17:40 <aledge> e.g. in pop music
10:17:50 <student2> tnq i'll search for it, i didn't understand it in the beginning
10:18:08 <aledge> if you could automatically transcribe those songs, you could then generate music that sounded similar etc
10:18:12 <student2> tnx temoto
10:18:25 <Cale> Have you heard of melodyne?
10:18:33 <copumpkin> I have
10:18:37 <Saizan> student2: this paragraphs seems to be good at explaining them http://en.wikibooks.org/wiki/Haskell/More_on_datatypes#Named_Fields_.28Record_Syntax.29
10:18:54 <temoto> haha haskell.org still down? :)
10:19:15 <Twey> No…
10:19:16 <Cale> Apparently the next version of melodyne (not sure if it's been released since I last looked) was going to support automatic chord separation.
10:19:21 <Saizan> haskell.org is up
10:19:25 <aledge> o cool
10:19:27 <Saizan> c.h.o might be still down
10:19:30 <Twey> Even Hackage is up :þ
10:19:37 <Twey> Nah, WFM
10:19:39 <djahandarie> Cale, melodyne sounds like a drug
10:19:45 <Saizan> yeah, it works
10:20:00 <Cale> djahandarie: That's probably about right.
10:20:22 <basti_> Cale: "chord separation"?
10:20:55 <tumult> it allows you to manipulate the individual tones that make up the chord
10:20:57 <Cale> basti_: Taking an audio file containing the performance of an instrument, and separating out the audio for each of the notes in the chords played.
10:21:03 <tumult> rather than only the chord itself, as a whole
10:21:33 <tumult> well i believe it only lets you perform a certain set of operations, not actually split out audio files
10:21:40 <tumult> i could be wrong though
10:21:49 <Cale> It's something which is theoretically not really possible, but probably not *too* hard to do in practice.
10:22:11 <lament> can melodyne transcibe music?
10:22:19 <basti_> Cale: i think i have seen that work, actually
10:22:29 <Cale> lament: I'm not sure, but it has most of what you'd need.
10:22:33 <basti_> it *must* be possible, since human ears do it all the time
10:22:37 <lament> crazy
10:22:43 <lament> basti_: yes but they do it by magic
10:22:43 <mreh> basti_ heh
10:22:59 <tumult> yeah it transcribes music, it displays the notes on screen at the correct pitches
10:23:01 <jmcarthur> i remember seeing some videos about that. it was really cool
10:23:03 <Cale> lament: It effectively transcribes music -- producing a piano-roll like view of the audio, with each note displayed as a waveform.
10:23:04 <basti_> well maybe not all the time, but there's people who can write music as we write words.
10:23:14 <lament> Cale: nice
10:23:16 <mreh> no one actually things the human mind does bayesian inference, apart from some crackpots
10:23:33 * basti_ is a crackpot, then ;)
10:23:34 <kmc_> oh?
10:23:34 <jmcarthur> you could even change some of the notes and it would still sound like somebody playing the guitar or whatever that was recorded originally, just difference chords
10:23:36 <lament> mreh: i do
10:23:37 <jmcarthur> *differenty
10:23:41 <temoto> At other job i've seen a guy implemented this music recognition in C in month and a half.
10:23:42 <jmcarthur> grr... *different
10:23:46 <basti_> we should do that in #haskell-blah, though
10:23:54 <lament> temoto: o_O
10:24:06 <kmc_> it's clearly not perfect bayesian inference
10:24:09 <lament> temoto: that sounds impressive no matter what exactly is meant by "music recognition"
10:24:17 <temoto> It was a part of guitar teacher project.
10:24:20 <Cale> lament: But this is the hyped next version. I don't think they've released it yet. (But I haven't checked in the last few months)
10:24:47 <mreh> temoto: OSS?
10:25:23 <temoto> lament, well the final thing supposed to compare your playing with some sample and show where you mistaken.
10:25:30 <lament> temoto: holy shit.
10:25:48 <temoto> mreh, as in ALSA ancestor? What he used for input?
10:26:13 <mreh> temoto: nah, did he release it as OSS?
10:26:26 <lament> seriously holy shit, month and a half
10:26:26 <Cale> I can tell you how I'd do it.
10:26:54 <lament> i have no idea where to start, even
10:27:08 <lament> after the FFT anyway
10:27:11 <mreh> I think he might have prototyped it before then
10:27:22 <temoto> mreh, the company went broke, i don't know about that project anymore. But i have contact with the guy who implemented it and ask if he still has sources.
10:27:32 <mreh> temoto: thanks
10:27:39 <mreh> um... thanks?
10:27:56 <mreh> that would be nice if you could
10:28:04 <lament> Cale: so you have your stream and you do FFT and interpolate and get a spectrum/time function. How do you do anything with it?
10:28:30 <temoto> mreh, i'll ping you with answer
10:28:30 <Cale> lament: Well, think of it as an image processing algorithm, I suppose.
10:28:35 <mreh> this thing say's I am awat
10:28:37 <mreh> y
10:28:39 <lament> i dunno how those work either :)
10:28:40 <jmcarthur> quantize the frequencies of the sample and the attempt into a near chromatic scale, "stitch" the two recordings on top of each other (translation in time and frequency), then highlight the areas where the difference between the two is above some threshold in time or frequency
10:28:41 <mreh> xchat
10:28:50 <mreh> temoto: brb
10:29:08 <student2>  Saizan en temoto tnq it's working
10:29:23 <jmcarthur> the frequency translation during the stitching might be necessary if the instrument is tuned wrong, but if you assumed it is tuned correctly then it's even easier
10:29:36 <lament> i suppose tuning the guitar and playing to a metronome makes it easier
10:29:43 <basti_> uhm, anybody want to join #polyphonic for that discussion?
10:29:48 <jmcarthur> yeah
10:29:53 <lament> is that a real channel?
10:30:23 <mauke> it is now!
10:31:06 <Cale> You look at the audio as an image where one axis is amplitude and the other frequency, and try to pick out contiguous regions where the amplitude is high. As you find the brightest one, you'd also want to look for its harmonics in the signal and grab those (this part probably requires a little bit of magic)
10:32:47 <kynky> spectrum analyser usiing fourier transforms
10:32:56 <Cale> yeah
10:50:18 <copumpkin> I guess HacBos fell through
10:50:20 <temoto> @tell mreh he said he'll give sources tomorrow. You may contact me at temotor@gmail.com
10:50:21 <lambdabot> Consider it noted.
10:52:46 <c_wraith> Hmm.  How does ghc handle different threads forcing the same thunk?
10:52:53 <Berengal> c_wraith: blackholing
10:53:36 <c_wraith> Berengal: I know nothing about that technique.  Does it imply that it will only be forced once, regardless of concurrency?
10:53:37 <Berengal> IIRC there's a small window (1 instruction?) where they may both evaluate it, but that's not a problem since they both return the same result anyway
10:54:23 <c_wraith> Bah.  it *does* matter when unsafePerformIO is involved..  So I need to not use unsafePerformIO here.
10:54:34 <c_wraith> Which means a decent restructuring of this code
10:54:36 <Berengal> c_wraith: If a thread encounters a thunk some other thread is evaluating, it will wait on the thunk. The first thread notifies all threads waiting when it exits
10:54:40 <Berengal> Or something like that...
10:55:20 <Berengal> c_wraith: Note that it can only happen if you're using the threaded runtime
10:55:31 <temoto> That sounds like simple lock. Why is it called blackholing?
10:55:42 <kmc_> it's not a lock
10:55:44 <kmc_> blackholing is the singlethreaded version
10:55:45 <c_wraith> This project is using the threaded runtime
10:55:52 <Berengal> temoto: Because I might have gotten it wrong
10:55:54 <benmachine> are you even guaranteed thunks will only be forced once even if you only have one thread?
10:56:03 <kmc_> benmachine: yes, i think so
10:56:15 <kmc_> in single threaded RTS, when a thunk is entered, it replaces its entry pointer with a pointer to an "abort" routine
10:56:25 <kmc_> that's how GHC manages to detect some infinite loops and quit with <<loop>>
10:56:29 <Berengal> benmachine: The scheduler only switches contexts on allocations, which happen _inside_ thunks, not when entering
10:56:30 <benmachine> ah
10:56:40 <jrockway> hey so... my Writer woes continue
10:56:41 <kmc_> if you make a program with "main = main" and compile it with ghc -O2 it will abort instead of looping
10:56:57 <jrockway> it seems to use unbounded memory even when () as the log type
10:57:04 <jrockway> <pasting code>
10:57:11 <temoto> > let x = x in x
10:57:15 <lambdabot>   mueval-core: Time limit exceeded
10:57:19 <benmachine> mueval is not optimised
10:57:23 <kmc_> in multithreaded RTS, instead of overwriting with an "abort" routine, it makes the entry pointer point to code which enqueues the entering thread onto a waiter queue
10:57:25 <Berengal> jrockway: Be stricter in your thunks
10:57:26 <temoto> It doesn't quit in my ghci either.
10:57:34 <benmachine> ghci is not optimised :P
10:57:36 <benmachine> compile something
10:57:42 <kmc_> yes, ghci does not do blackholing
10:58:09 <jrockway> code is here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16749#a16749
10:58:24 <jrockway> other than rewriting Writer, I don't see what I can do to make it not use all my memory
10:58:31 <sshc> is GHC capable of automatically threading and thus taking advantage of certain CPU's?
10:58:48 <kmc_> sshc: http://donsbot.wordpress.com/2009/09/05/defun-2009-multicore-programming-in-haskell-now/
10:59:16 <kmc_> sshc: it will not parallelize your code with no effort from you
10:59:39 <kmc_> it will parallelize your code if you add annotations such as "par", which are very lightweight
10:59:46 <Berengal> jrockway: seqing y is useless, since it's forced in the if anyway
10:59:53 <jrockway> yeah, i figured
10:59:54 <kmc_> you do not need to explicitly manage threads and communication
10:59:59 <jrockway> just wanted to be sure that was not the issue
11:00:21 <Berengal> And it's possible that a rewrite of WriterT is the only option...
11:00:26 <jrockway> ok
11:00:35 <jrockway> i think it is thunking the `mappend`
11:00:35 <Berengal> Run some profiling
11:00:41 <kmc_> sshc: GHC's runtime maps a large number (potentially millions) of Haskell threads onto a configurable number of OS threads (usually one per core)
11:00:41 <Berengal> Yeah
11:01:05 <jrockway> ok, will do
11:01:06 <Berengal> jrockway: There's Control.Monad.Writer.Strict
11:01:15 <jrockway> yeah, same problem
11:01:20 <jrockway> it is not strict enough in the right place
11:01:30 <jrockway> it only differs in one pattern match
11:01:47 <Berengal> Which package?
11:02:00 <jrockway> mtl
11:02:18 <Berengal> There's one in monads-tf too
11:02:23 <Berengal> But they might be the same
11:02:43 <jrockway> someone was advocating a different monad library the other day
11:02:46 <jrockway> monadlib maybe?
11:02:51 <jrockway> it doesn't really matter to me which i use
11:03:03 <Berengal> Shop around. It's what hackage's for :)
11:03:13 <jrockway> yeah, i read the code and they all seemed the same to me
11:03:20 <jrockway> but i have not downloaded and tried each :]
11:03:40 <jrockway> i think i am just going to cut-n-paste and see if my theory is correct
11:03:46 <jrockway> and then send the appropriate library a patch
11:04:05 <jrockway> i am just surprised that i am the only person that has ever had this issue
11:04:23 <jrockway> (i read a paper the other day about this, actually, and the authors decided to just not use writer instead.  yuck...)
11:05:10 <temoto> How do you think is it possible (a good way) to statically analyze code paths, find iterations, evaluate their "cost" and autoinsert par when cost exceeds some barrier?
11:05:15 <Berengal> Run some profiling just to be sure.
11:05:47 <kmc_> temoto: seems much easier to analyze dynamically rather than statically
11:05:52 <jrockway> what's a good way to profile stack usage?
11:06:04 <jrockway> i tried -xt, didn't give me much info
11:06:07 <Gracenotes> costs can be evaluated by common values
11:06:08 <jrockway> "your code uses a lot of memory"
11:06:18 <kmc_> part of the idea of par's "sparks" is that they're light weight enough that you can put them everywhere
11:06:23 <kmc_> but, this is not quite true in practice
11:06:40 <Gracenotes> GHC has cost centers (centres). but they're not manual.
11:06:53 <Gracenotes> I mean, they are. (ramble ramble ramble)
11:06:57 <temoto> kmc_, but that's unpredictable and profiling overhead.
11:07:25 <kmc_> i feel like writing good parallel Haskell code is relatively easy, if you have certain advanced knowledge and skills, which are hard to acquire
11:07:44 <Berengal> temoto: Profile, then analyze the profile output, recompile
11:07:59 <kmc_> this being the opposite of writing good parallel code in Java or C++, which is straightforward, but cumbersome and time consuming
11:08:14 <kmc_> (not really that straightforward, either)
11:08:30 <temoto> Berengal, you can't run program through all codepaths for that :)
11:08:44 <kmc_> then again, you can also do explicit threading in Haskell
11:08:44 <Berengal> kmc_: In Java or C++ you're left with the usual concurrency problems as well
11:08:51 <Berengal> temoto: You can if you do it multiple times
11:14:13 <temoto> par will still wait on IO, right?
11:14:36 <temoto> I mean, parMap is not a way to, say, crawl 1000 URIs, right?
11:15:01 <temoto> i was thinking on haskell reincarnation of my web crawler
11:15:27 <srush> is there a standard way to use parsec for Read instances?
11:16:00 <copumpkin> temoto: no, because it can't have side effects
11:16:13 <copumpkin> parMap evaluates things in parallel, and you need execution
11:16:19 <Beelsebob> temoto: the key to understanding that is that the parallelised computations produce IO actions
11:16:21 <Beelsebob> they don't run them
11:16:30 <Beelsebob> the runtime interpretts the IO action they produce
11:16:42 <copumpkin> parMapM is what you need :P
11:16:48 <kmc_> hehe
11:17:17 <copumpkin> I had one lying around a while ago
11:17:25 <copumpkin> I think I stole it from mmorrow
11:17:25 <kmc_> copumpkin: hmm, wonder what it's type would be.  would you need a class MonadFork m where { forkM :: m () -> m ThreadId } ?
11:17:36 <kmc_> you can write parMapM for IO, anyway
11:17:39 <copumpkin> it was more like parMapIO in my case :)
11:17:41 <kmc_> yeah
11:17:44 <copumpkin> but yeah, I guess you'd need that
11:17:46 <Berengal> mapM_ fork
11:17:52 <kmc_> temoto: the thing to do would be to mapM_ forkIO
11:17:57 <kmc_> yeah, what Berengal said
11:18:01 <Spockz> where does the prepackaged OS X version of GHCI store it's libraries?
11:18:13 <Berengal> kmc_: Except fork isn't a function ;)
11:18:19 <kmc_> forkIO is a function
11:18:25 <Berengal> (Unless you're implementing dining philosophers, then it might be)
11:18:29 <kmc_> hehe
11:18:38 <kmc_> it's a bit annoying that the std lib has no truly simple "wait for these threads to complete" mechanism
11:18:40 <Berengal> forkIO is, but I said fork...
11:18:51 <kmc_> you can do it in a few lines with MVar or Chan, but it still feels like a pattern i reinvent each time
11:18:57 <Berengal> Indeed
11:19:03 <kmc_> esp. because you've got to handle exceptions
11:19:23 <copumpkin> write it!
11:19:33 <copumpkin> a single robust higher-order version of that :P
11:19:42 <Berengal> box-of-concurrency-tools is a good package name...
11:19:45 <kmc_> can mere mortals commit to base?
11:20:07 <copumpkin> kmc_: you'd need to submit a proposal to libraries@
11:20:10 <Berengal> kmc_: It belongs on hackage, methinks
11:20:27 <copumpkin> if sufficiently general, it belongs in Control.Concurrent methinks :P
11:20:30 <kmc_> yeah, there are plenty of concurrency libraries already
11:20:38 <kmc_> i think it should be in the same module as forkIO
11:20:47 <Berengal> joinIO?
11:26:08 <jmcarthur> huh, parMapM... nice
11:26:21 <temoto> @hoogle parMapM
11:26:22 <lambdabot> No results found
11:26:25 <temoto> aww
11:27:01 <Baughn> Is "data Foo :: * -> * where Bar a => a -> Foo a" equivalent to ".. where a -> Foo a"? That is, does the context /do/ anything?
11:27:17 <soupdragon> Baughn,yeah I think the context actually does stuff
11:27:31 <Baughn> Ah, but what stuff?
11:27:33 <soupdragon> unlike in non-GADT data definitions
11:27:44 <jmcarthur> it requires a to be an instance of Bar to use the constructor
11:27:58 <jmcarthur> (the constructor which you left out, btw) ;)
11:28:26 <Baughn> Logical. Well, that makes sense.
11:28:28 <temoto> I found parMapM for State in hpaste. :)
11:28:36 <Baughn> Now we just need record syntax for GADTs. ;)
11:28:50 <jmcarthur> o_O
11:29:02 * soupdragon doesn't like... 'syntax'
11:29:11 <jmcarthur> same here
11:29:14 * Baughn pushes soupdragon over to #scheme
11:29:20 <jmcarthur> soupdragon: you're soupdragon again!
11:29:38 <soupdragon> I gave up on arch, somehow ubunto is working again though
11:29:56 <soupdragon> I just have really bad luck, I just need someone to install the stuff for me :~
11:30:46 <Baughn> Arch works so well, too. :P
11:31:06 * Baughn has been waiting for FF 3.6 for a while now, though.
11:31:21 <soupdragon> Baughn... I wish you would install it :P
11:31:27 <soupdragon> (on my computer)
11:31:28 <jmcarthur> <3 arch
11:31:30 <temoto> :t parMapM f xs = parsequence $ map f xs
11:31:33 <lambdabot> parse error on input `='
11:31:43 <temoto> @let parMapM f xs = parsequence $ map f xs
11:31:44 <lambdabot>  <local>:1:15: Not in scope: `parsequence'
11:31:44 <soupdragon> did you guys install it on a mac??
11:31:47 <Baughn> soupdragon: Sure. Hand me ssh root access, and I'll install it for you. ;)
11:31:54 <jmcarthur> although it kind of sucks upgrading haskell packages using pacman
11:31:54 <Baughn> Yeah, mine's a macbook pro
11:31:57 <soupdragon> Baughn is that even possible??
11:32:04 <Baughn> Pretty easy.
11:32:10 <Baughn> jmcarthur: Yeah. I don't do that.
11:32:11 <jmcarthur> i'm not sure how to do it in such a way that it doesn't spew errors at me every time
11:32:19 <jmcarthur> i can't even keep xmonad and ghc working
11:32:22 <temoto> Here's parMapM for IO: http://65.254.53.221:8000/3299/2/plain
11:32:23 * Baughn just uses cabal-install
11:32:27 <jmcarthur> if both installed through pacman
11:32:28 * soupdragon is confused.. how the hell can you install an OS over SSH?
11:32:38 <Baughn> soupdragon: Note the "root access"
11:32:46 <soupdragon> yeah but.....
11:32:48 <Twey> Still
11:32:49 <jmcarthur> soupdragon: i installed arch from an ubuntu livecd once
11:32:51 <soupdragon> I don't know it's all magic to me
11:32:58 <soupdragon> jmcarthur, how? :D
11:33:00 <soupdragon> I could try that
11:33:02 <Baughn> soupdragon: I can repartition you disk (or ask you to insert one), then unpack an arch root image on it, then chroot into it and set things up
11:33:06 <jmcarthur> it's harder, not easier
11:33:09 <Twey> It's possible with a LiveCD
11:33:15 <Baughn> Definitely harder, but quite possible.
11:33:20 <soupdragon> harder and easier don't really mean anything
11:33:22 <Twey> But not from a running installed system, surely
11:33:22 <Baughn> And you don't need a livecd, just /any/ running linux.
11:33:28 <Feuerbach1> What's wrong with this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16751 ? I just copypasted from Alex manual.
11:33:29 <soupdragon> I have a running linux right now
11:33:33 <Baughn> From a running installed one is fine
11:33:34 <Twey> Overwriting the currently-running system?
11:33:38 <Baughn> Not that.
11:33:38 <jmcarthur> yes you can do that
11:33:47 <Baughn> Well, I /could/ do that..
11:33:47 <soupdragon> though I can't imagine not breaking by doing this..
11:33:49 <Twey> You can
11:33:49 <jmcarthur> you have to set up a ram filesystem first
11:33:53 <Twey> It's just horrific
11:33:57 <jmcarthur> then copy the necessary stuff to it
11:33:59 <jmcarthur> then chroot
11:34:03 <Twey> Oh, nice idea
11:34:06 <Baughn> Main problem is, if it breaks then soupdragon has to fix it
11:34:07 <jmcarthur> then you can treat it like its a livecd
11:34:07 <Twey> I hadn't thought of that
11:34:13 <soupdragon> you guys are so cool :p
11:34:14 <Baughn> So it's better to use a separate partition
11:34:18 <soupdragon> I wish I knew how to do this
11:34:31 <Baughn> soupdragon: But seriously, I wouldn't mind doing it. I can use screen so you can follow what I'm doing.
11:35:09 <Baughn> #haskell has given moi way too much help, I feel like I need to balance the scales. :P
11:35:10 <lunabot>  luna: Not in scope: `haskell'
11:35:16 <Twey> Hehe
11:35:58 <Baughn> And if there's anything I'm secure about, it's my knowledge of low-level linux. ;)
11:36:37 <soupdragon> what do you think about this: when I try and boot of the install discs it's just a black screen?
11:36:38 <p_l> haha
11:36:46 <Baughn> soupdragon: Macbook?
11:36:50 <soupdragon> mac pro
11:36:57 <p_l> Baughn: I'll admit that I feel much more secure in my administration skills than any programming skill :D
11:36:58 <Baughn> That happens unless you go via bootcamp
11:37:03 <Baughn> It does some magic.
11:37:11 <Baughn> Booting from the HD always works fine, though.
11:37:11 <soupdragon> don't you need windows for bootcamp?
11:37:21 <p_l> Baughn: maybe because the install disk doesn't have EFI-compatible bootloader
11:37:23 <Baughn> No, bootcamp cares not what the BIOS is booting.
11:37:33 * jmcarthur used refit for his macbook pro
11:37:36 <p_l> (EFI doesn't go el-torito)
11:37:39 <soupdragon> p_l, I thought the isolinux cd was meant to fix that (both didn't work)
11:37:50 <soupdragon> alright, maybe I should read about bootcamp
11:37:59 <Baughn> soupdragon: Anyway, use bootcamp to boot the cd, and it'll work.
11:38:22 <p_l> soupdragon: isolinux doesn't help, what you'd need would be elilo placed on the disk and set up to load the kernel, which would also need to be efi-compatible
11:38:22 <soupdragon> okay Baughn, thanks I'll try it tommorow! if I did  today and it didn't work I'd probably have a heart attack
11:38:31 <Baughn> soupdragon: I think you might be able to bypass the "must partition first" aspect of bootcamp by using the startup disk panel in control panel instead
11:38:40 <Baughn> soupdragon: Hopefully. Try that first.
11:38:44 <soupdragon> p_l, I am pretty jelous of all you folks knowledge :)
11:38:52 <jmcarthur> i'd still use reFIT
11:39:05 <Baughn> soupdragon: It comes from playing with computers instead of playing with girls. Don't feel jealous.
11:39:07 <jmcarthur> i forget how it's capitalized
11:39:10 <Berengal> I feel like implementing a continuation-based web framework...
11:39:27 <jmcarthur> Baughn: play with computer girls!
11:39:56 <Baughn> jmcarthur: I tried that, but Rena killed all the other ones and then jumped in a river.
11:40:04 <jmcarthur> i've hooked up with girls at LAN parties before
11:40:22 <jmcarthur> ended up marrying a non-LAN-party girl though, so i don't do that anymore for obvious reasons
11:40:28 <p_l> I'll say that I had seen network equipment get laid more than me :P
11:41:57 <Baughn> p_l: Anyway, my tastes in girls run more towards Gasai Yuno.
11:42:05 <Baughn> p_l: It's probably for the best that I've never found one.
11:42:32 <p_l> ahahahahaa
11:43:34 <p_l> Baughn: well, if you meet one, try to remember what you know and try to get her to similar state as late Yuno. Even if you'll get more in touch with your inner evil because of that ;-)
11:43:52 <Baughn> p_l: ..risky. Most risky.
11:44:32 <p_l> all good things in life are either illegal or life-threatening
11:44:51 <Baughn> Or, in this case, both.
11:46:26 <p_l> I'd put my money on the "life-threatening" part, but I don't know about the "illegal"
11:46:41 <lament> most good things in life are illegal
11:47:14 <Baughn> p_l: I'm fairly certain that if threatening the fabric of reality with utter destruction isn't illegal, then it SHOULD be.
11:47:45 <p_l> ^^;
11:48:17 <Baughn> Actually, I recently read a lawyer's opinion on the LHC's option of doing just that.
11:48:26 <Baughn> He believes it is, due to property damage.
11:48:55 <Baughn> He also believes, however, that it has been well established that no damages accrue from /killing/ unless there's someone left over to be affected by it.
11:49:02 <p_l> but that's side-effect (regarding Yuno) due to circumstances placed by the outside world. Yuno itself doesn't cause damage to fabric of reality
11:49:31 * Baughn suddenly realizes that he's still in #haskell. Um...
11:49:37 <p_l> ^^;
11:49:44 <c_wraith> agh.  got rid of the unsafePerformIO.  Moved lots of bits of code to higher scopes...  and have moved initialization to a location that could *still* be entered concurrently by multiple threads.
11:49:53 <p_l> brb - going to another building
11:52:53 <temoto> http://lukeplant.me.uk/blog/posts/why-learning-haskell-python-makes-you-a-worse-programmer/      title speaks for itself
11:53:28 <temoto> I'm pushing IO in my python programs to higher level too and it brings no difference, i feel like idiot with it.
11:55:38 <Baughn> temoto: Is that your post?
11:56:08 <Baughn> temoto: I agree with the main points, but not the title. Learning haskell makes you a better programmer, yes; that's /because/ you feel bad about writing possible traps.
11:56:26 <temoto> not mine, but i feel his pain
11:56:30 <Baughn> Although compulsively using higher-order functions in a language not made for them might be an issue.
11:56:49 <lament> "Haskell/Python" certainly beats "C/C++" as the most ridiculous language pairing
11:57:08 <zygoloid> Baughn: "Update: I probably should have made it more obvious for some people that the title of the post is not entirely serious, and mainly I'm just griping"
11:57:08 <copumpkin> we already have a haskell/ruby bridge!
11:57:29 <temoto> Someone admitted he's writing PHP so go to hell with that :)
11:57:33 <lament> I like C# quite a bit, dunno what's so ugly about it
11:58:04 <temoto> lament, it's wordy.
11:58:11 <lament> not too wordy
11:58:24 <lament> his example with delegates is ridiculous
11:59:03 <temoto> I switched to python because i was feeling like i totally imagined a full algorithm a long ago and now i'm just writing those types and braces to make compiler happy.
11:59:35 <lament> (ridiculous given that C# has lambdas now, and that's really his only complaint there)
11:59:37 <jmcarthur> to python from what?
11:59:42 <temoto> from C#
11:59:46 <jmcarthur> ah
11:59:55 <temoto> With python at first, actual writing of program took much less time so it became me who was slow.
12:00:07 <lament> oh, it's an article from 2006, no wonder.
12:00:26 <temoto> Yeah C# has changed a lot from that time.
12:00:30 <lament> temoto: I would definitely use C# over python, except for the platform independence thing. C# is statically typed.
12:01:00 <temoto> I miss type checks a lot because they find errors.
12:01:21 <lament> An error in the spelling of a variable name is a runtime error in Python. I don't feel masochistic enough for that anymore.
12:01:42 <temoto> That's caught by pylint with ease.
12:02:06 <temoto> Not so much as i want though.
12:02:17 <koala_man> a runtime error if you're lucky
12:02:28 <lament> also C# has better lambdas, genuine polymorphic types, LINQ - after using Haskell, it feels more like home than Python does :)
12:02:52 <koala_man> string.join("\n", list.Select(c => c.Description).Where(d => d != "").ToArray() );
12:03:08 <Twey> Ow
12:03:09 <lament> koala_man: even better with linq
12:03:12 <Twey> Yeah
12:03:18 <temoto> And after haskell type classes i can't imagine any "conventional" type system with thousands of classes look good enough.
12:03:49 <lament> temoto: interfaces work well enough in practice.
12:03:50 <koala_man> I prefer the extension methods
12:04:11 <Twey> string.join("\n", (from c in list where c.Description != "" select c.Description).ToArray())
12:04:53 <lament> that looks more readable than his haskell example, to me
12:05:01 <mauke> join "\n", grep { $_ ne "" } map { $_->Description } @list
12:05:20 <lament> concat $ List.intersperse "\n" $ filter (/= "") $ map description mylist         -- his haskell example
12:05:21 <Twey> mauke: Ow :þ
12:05:25 <temoto> mauke, perl?
12:05:26 <Asztal> http://pastie.org/private/av4rprgkdyxreza3lig5xa :)
12:05:42 <Asztal> Parsec in C# was uglier than expected
12:05:50 <mauke> temoto: yes
12:06:22 <temoto> lament, when they write interfaces, yes. They're almost same as type classes. The problem here is that library writers tend to ignore that.
12:06:30 <mauke> intercalate "\n" . filter (/= "") . map description $ list
12:06:35 <Twey> unlines [d | x <- mylist, let d = description x, d /= ""]
12:06:43 <lament> temoto: true.
12:06:43 <Twey> Hm
12:06:44 <mauke> fail, unlines puts a \n at the end
12:07:01 <lament> temoto: it's more about the differences in the culture than the language itself.
12:07:48 <Twey> init [d | (description -> d@(_:_)) <- mylist]
12:07:50 <Twey> Er
12:07:54 <Twey> init $ unlines [d | (description -> d@(_:_)) <- mylist]
12:08:08 * Twey wubs his view patterns
12:08:10 <mauke> ew
12:08:45 <mauke> next step: also filter descriptions that only consist of whitespace
12:09:02 <temoto> I believe i saw a quote about culture today.
12:09:14 <temoto> @quot community
12:09:14 <Baughn> > proc x = do y -< x; returnA y
12:09:15 <lambdabot> ddarius says: Unfortunately, the logic programming community has this unhealthy death grip on Prolog.
12:09:15 <lambdabot>   <no location info>: parse error on input `='
12:09:22 <lament> @quote culture
12:09:23 <temoto> @quot community channel
12:09:23 <lambdabot> No quotes match. :(
12:09:23 <lambdabot> No quotes for this person.
12:09:24 <Baughn> > proc x -> do y -< x; returnA y
12:09:26 <lambdabot>   <no location info>: parse error on input `->'
12:09:38 <temoto> i'll look it up in private
12:09:41 <mauke> join "\n", grep { /\S/ } map { $_->Description } @list
12:09:50 <Baughn> @ask Cale Any chance you could turn on the Arrows extension in \bot?
12:09:51 <lambdabot> Consider it noted.
12:10:07 <mauke> intercalate "\n" . filter (any (not . isSpace)) . map description $ list
12:11:31 <temoto> @quot homework
12:11:39 <lambdabot> Botje says: #haskell: parallellising your homework answers!
12:11:41 <temoto> @quot homework
12:11:42 <lambdabot> dons says: [In reference to <joelr1> did you guys know that #ocaml has 37 members and #erlang has 34 vs. 202 on #haskell?] I think part of the #haskell success comes from the approach that we all
12:11:44 <lambdabot> know each other, it's not a homework channel like #java. We created a community of peers, working on the overall goals of the community. That's why people keep coming back
12:11:46 <temoto> This is it.
12:12:55 <student2> does anyone knows why in my html  (using Text.HTml module) i'm seeing things like \" and \n?
12:13:31 <student2> i'm also using windows 7
12:13:35 <Twey> Did you ‘show’ it instead of ‘render’ing it?
12:13:53 <temoto> student2, show the code.
12:14:04 <mauke> Did you 「print」 it instead of 「putStrLn」ing it?
12:14:14 <student2> i used things like thethml << body << "Hello world"
12:14:33 <temoto> ... and then?
12:14:38 <Twey> Japanese quotes for Haskell code?  Interesting idea
12:14:55 * temoto must be missing some fonts
12:14:57 <student2> I'll show the server that handels things trough hpast
12:15:03 <mauke> I blame Jeffrey Friedl
12:15:15 <Zao> temoto: You're not missing much, except for horrible-looking double-width glyphs.
12:15:35 <mauke> .oO( did you `p̀rint́´ it instead of `p̀utStrLń´ing it? )
12:16:01 <Zao> Even worse :)
12:16:15 <copumpkin> what is this .oO( x ) pattern?
12:16:15 <mauke> `àwesome quoteś´
12:16:21 <Zao> copumpkin: Thinking.
12:16:21 <mauke> copumpkin: thought bubbles
12:16:29 <Zao> The second ` makes p look like þ.
12:16:38 <temoto> copumpkin, it's a mind comprehension.
12:16:44 <Asztal> ⁶⁶Can I join in?⁹⁹
12:16:56 <mauke> ah, a fellow quotist
12:17:05 <Alpounet> haha
12:17:43 <student2> what's the link to hpast? :$
12:17:48 <mauke> hpaste.org
12:17:59 <student2> tnx
12:18:09 <temoto> You can also use codepad.org and execute the program there!
12:18:13 <kmc_> @where hpaste
12:18:13 <lambdabot> http://hpaste.org http://moonpatio.com/fastcgi/hpaste.fcgi/
12:18:37 <Baughn> ‘We already have perfectly good western quotation marks.’
12:19:25 <mauke> „oh, right“
12:19:54 <student2> this is my code, where i'm getting the erros like \" http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16759#a16759
12:19:57 <Dashkal> wtf? 12:18 -!- slssfcscmp: No such nick/channel
12:20:14 <mauke> Dashkal: looks like you're getting spammed by web drones
12:20:22 <Dashkal> ahh, joy
12:20:23 <mauke> which are already gone by the time your client tries to reply
12:20:39 <Zao> Baughn: »Indeed.«
12:21:19 <Baughn> student2: Right. You shouldn't use show, that is specifically meant to produce code that can be read back into haskell.
12:21:35 <Baughn> student2: The html package has another function - render, apparently.
12:21:52 <student2> renderPage also shows the "\
12:22:06 <doserj> student2: what's the type of prettyPage?
12:22:13 <student2> i'll see for you
12:22:36 <student2> prettyPage :: Spreadsheet Cell -> String
12:22:48 <zygoloid> ¿What's this (<<) operator?
12:22:55 <Twey> »Crazy Finns.»
12:23:12 <mauke> student2: looks like you can just remove the ‘. show’ then
12:23:13 <student2> that's an operator used in Text.HTML
12:23:25 <doserj> student2: then just remove those show's in spreadsheetServer?
12:23:37 <student2> you can do something like thehtml << body << p << "foo"
12:23:39 <Twey> It·inserts·a·child·element.
12:24:00 <student2> let me see mauke brb
12:24:01 <mauke> Twey:␣nice␣work
12:24:16 <soupdragon> I␣love␣these!
12:24:21 <Baughn> I can't see those
12:24:25 <soupdragon> aww
12:24:29 <Twey> Nice
12:24:33 <Twey> Unicode: hours of fun
12:24:45 <mauke> unɟ ɟo sɹnoɥ :ǝpoɔıun
12:24:59 <Baughn> 4 ≹ 4?
12:25:17 <Alpounet> it looks like an insect from far.
12:25:18 <Twey> Yeah, what the heck is that operator?
12:25:26 <mauke> U+2279 (e2 89 b9): NEITHER GREATER-THAN NOR LESS-THAN [≹]
12:25:29 <Twey> What's the point of it?  Is it actually used in mathematics?
12:25:39 <mauke> ɪɴᴅᴜʙɪᴛᴀʙʟʏ
12:25:39 <Twey> I guess for complex numbers and stuff
12:26:16 <Baughn> Does ‫‬‭‮‪‫‬‭‮҉this look like anything?
12:26:42 <Twey> ‘This’?
12:26:46 * Twey sees nothing
12:26:48 <mauke> hoho
12:26:50 * Baughn neither
12:26:51 <mauke> U+005F (5f): LOW LINE [_]; U+0489 (d2 89): COMBINING CYRILLIC MILLIONS SIGN [҉]
12:26:54 <mauke> yes
12:26:57 <student2> jeeeej it's working tnx all
12:27:03 <Twey> Then № :þ
12:27:17 <dolio> In the ordering of definedness, 3 is neither greater than nor less than 4.
12:27:29 <Twey> dolio: *nod*
12:27:31 <benmachine> I see that
12:27:37 <zygoloid> ı §ee ðeæð þeøþłe
12:28:02 <mauke> ℘ℰℛℒ
12:28:20 <copumpkin> very nice
12:28:24 <copumpkin> reminds me of \mathcal
12:28:29 <Alpounet> yep
12:28:52 <zygoloid> ħæşĸȩłł
12:29:12 <mauke> ℕ₀
12:29:42 <Baughn> ..why is ⍨ in unicode? o_O
12:29:46 <mauke> ツ
12:29:58 <copumpkin> シ
12:29:59 <Asztal> You can do 𝐛𝐨𝐥𝐝 and 𝘪𝘵𝘢𝘭𝘪𝘤 too!
12:30:06 <misk20> hey can any body help me with the BNFC grammer of std::cout << "Hello, " << name  << "!" << std::endl;
12:30:15 <mauke> Asztal: not in my font :-(
12:30:16 <copumpkin> misk20: no, but ##c++ might be able to
12:30:20 <zygoloid> > undefined :: Int → Int
12:30:21 <lambdabot>   * Exception: Prelude.undefined
12:30:24 <zygoloid> yay
12:30:28 <Baughn> ๛ is lovely
12:30:39 <misk20> ok thanks
12:30:44 <mauke> > undefined ∷ Int → Int
12:30:45 <Baughn> > undefined :: Int -> Int
12:30:45 <lambdabot>   * Exception: Prelude.undefined
12:30:45 <lambdabot>   * Exception: Prelude.undefined
12:30:54 <mauke> excellent
12:30:56 <benmachine> copumpkin: I think he might be asking about using haskell to parse C++
12:31:00 <Alpounet> misk20, check the code of http://42ndart.org/scalpel/
12:31:03 <benmachine> iirc from earlier
12:31:11 <copumpkin> benmachine: ah
12:31:12 <Alpounet> there is C++'s grammar there
12:31:22 <temoto> How do you put lambda with compose button in us layout?
12:31:29 <Baughn> ⋙ - "Very much greater than"? Wait, what?
12:31:33 <benmachine> haha
12:31:36 <elspru> how to add numbers in a list?
12:31:39 <elspru> map ord "hello"
12:31:40 <mauke> elspru: sum
12:31:42 <copumpkin> > sum [1..50]
12:31:44 <lambdabot>   1275
12:31:48 <elspru> > sum $ map ord "hello"
12:31:49 <lambdabot>   532
12:31:53 <misk20> Alpounet,  what is this ? it looks like compiler ?
12:31:53 <elspru> cool :D
12:31:57 <mauke> temoto: I use <Compose> g l -> λ
12:32:06 <Alpounet> misk20, it isn't
12:32:11 * benmachine holds right alt and presses l but doesn't remember why that works
12:32:13 <Alpounet> for the moment it's only about C++ code analysis
12:32:19 <benmachine> something to do with xmodmap and something else
12:32:34 <benmachine> oh, just xmodmap
12:32:34 <Alpounet> it performs syntaxical analysis and (not entirely for the moment, but it's WIP) semantical analysis
12:32:37 <temoto> mauke, "compose, g, l" ?
12:32:45 <mauke> yes
12:32:45 <Baughn> "Floral Heart Bullet, reversed, rotated." <-- Waste of a code-point
12:32:55 <temoto> mauke, strange, it doesn't work for me.
12:32:59 <shepheb> I'm having a devil of a time trying to parse "f x y z = <expr>" with Parsec. do { (name:args) <- sepBy1 pIdent (skipMany1 space); spaces; char '='; spaces; exp <- pExpr; return (name,args,expr) }
12:33:08 <mauke> temoto: probably because I have my own compose mappings
12:33:12 <benmachine> Baughn: we'll run out if we're not careful?
12:33:17 <Twey> Heh
12:33:22 <Twey> Floral Heart looks weird to me
12:33:25 <shepheb> when I try to run it on "f x = x" it tells me unexpected =
12:33:26 <Baughn> benmachine: Yes‽
12:33:35 <Twey> It's always reminded me more of a carrot, or possibly a heart complete with veins
12:33:46 <misk20> Alpounet, thansk, i will check it
12:34:11 <Alpounet> you're welcome.
12:34:14 <temoto> mauke, could you teach how to set it? (without any desktop environment)
12:34:14 <mauke> shepheb: sepBy1 pIdent (try (skipMany1 space)) ?
12:34:29 <Alpounet> misk20, it has an IRC channel (#scalpel) on freenode, if you're interested in it.
12:34:39 <mauke> temoto: create ~/.XCompose
12:34:39 <Alpounet> its author hangs out there
12:34:57 <shepheb> mauke: already tried that. no go.
12:34:58 <zygoloid> > let x ⋙ y = (x - y) > min (abs x) (abs y) in 3 ⋙ 1
12:34:59 <lambdabot>   True
12:35:00 <mauke> temoto: I like to 「include "/usr/share/X11/locale/en_US.UTF-8/Compose"」 at the beginning
12:35:09 <misk20> great
12:35:27 <benmachine> shepheb: you could use the <?> operator to annotate things, might help tell you where the failure is
12:35:30 <temoto> mauke, done.
12:35:37 <shepheb> benmachine: tried that too. never found it.
12:36:01 <mauke> shepheb: name : args <- many1 (pIdent <* spaces); char '='; ... ?
12:36:39 <doserj> or name: arge <- many1 (pIdent >> many1 spaces) ; char '=";  ... ?
12:36:54 <benmachine> many1 spaces doesn't make sense does it?
12:36:56 <doserj> err, mauke's is better
12:36:56 <shepheb> mauke: that got it.
12:37:07 <shepheb> not sure what I was doing wrong
12:37:14 <mauke> temoto: http://p3rl.org/8656GQOP
12:37:33 <shepheb> thans all
12:37:41 <shepheb> thanks, even
12:37:51 <mauke> the problem was that you had a "separator" after x
12:38:32 <temoto> mauke, thank you. I guess it needs to reload something to make it actually work.
12:38:37 <mauke> parsec saw (ident "f"), (space " ", ident "x"), (space " ", fail "no identifier here")
12:38:48 <mauke> temoto: you need to restart the application you want to use it in
12:39:04 <mauke> compose support is per application
12:39:22 <temoto> mauke, no it didn't help.
12:39:48 <mauke> shepheb: that is, by the point it reached the "=" in "f x =" it had already committed to parsing the preceding " " as a separator
12:40:11 <temoto> mauke, no, wait it did, just running another instance of terminal didn't. But it works in new program. Thank you very much.
12:40:12 <mauke> temoto: hmm, no idea then
12:40:29 <temoto> I guess gnome-terminal forks or something.
12:40:39 <mauke> screen or tmux are recommended for playing around with this :-)
12:40:47 <mauke> lets you restart your terminal without losing anything
12:41:49 <temoto> Yeah i used to run cmus in screen but then stopped because i stopped playing around with this kind of things. :)
12:42:08 <mauke> I run everything in tmux
12:44:59 <student2> I have a parser that parsers String to Cell and i have Spreadsheet String and i want a Spreadsheet Cell, does anyone knows how to do it
12:45:22 <mauke> hmm, is Spreadsheet a Functor?
12:45:55 <student2> Spreadsheet is e data type of Array
12:46:19 <student2> and i think it has aan instance for Functor
12:46:53 <Berengal> student2: fmap
12:46:56 <Berengal> @type fmap
12:46:57 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:47:06 <soupdragon> is there a GHCi REPL inside Emacs?
12:47:13 <student2> oke tnq
12:47:14 <Berengal> soupdragon: haskell-mode
12:47:33 <aledge> haskell-mode lets you pick the inferior process
12:47:35 <Berengal> student2: If that's not what you want, there are other versions of map in the various array modules
12:48:23 * Berengal wants an interpreter like the one Agda has
12:48:43 <soupdragon> :(
12:48:53 <temoto> What's special about it?
12:48:56 * soupdragon wants someone to write the web HTML for me
12:49:25 <Berengal> temoto: Try it. It makes intellisense look like a retarded baby in comparison
12:51:43 <Berengal> temoto: It can automatically pattern match function arguments for you, compile code with holes in (holes are unwritten code, basically), allowing you to see the environment from that hole's perspective etc.
12:51:47 <temoto> Berengal, but i don't know the agda :)
12:52:01 <Berengal> temoto: Try it. It makes haskell look like a retarded baby in comparison ;)
12:52:08 <Berengal> (Well, not entirely...)
12:52:16 * soupdragon is struggling to figure out what language to use for the webserver
12:52:20 <temoto> i mean how can i play with language i don't know
12:52:23 <kmc_> agda is super mutant haskell
12:52:43 <Alpounet> :D
12:52:59 <Alpounet> it's worth @remember kmc_ :-p
12:53:14 <Berengal> temoto: By learning it. You won't regret it... well, except you now wish Haskell was as good
12:53:14 <temoto> Berengal, did you mean agda -I for that super interpreter?
12:53:30 <Berengal> temoto: No, the agda-mode emacs mode
12:53:47 <Berengal> It's not a REPL, but it does interpret
12:53:50 <temoto> oh i don't know emacs as well :)
12:54:04 <aledge> !!!
12:54:15 <temoto> Much to learn today. :)
12:54:15 <Berengal> temoto: Try it. It makes notepad look like a retarded baby in comparison :P
12:54:21 <aledge> haha
12:54:35 <basti_> hi korsakow
12:55:12 <Berengal> @remember kmc_ agda is super mutant haskell
12:55:13 <lambdabot> I will remember.
12:55:21 <temoto> I'd extend that to something more heavy than notepad actually.
12:55:26 <korsakow> hi basti_  :)
12:55:36 <soupdragon> what should I call my program?
12:55:38 <mauke> preflex: quote kmc_
12:55:38 -preflex(n=preflex@95-88-118-220-dynip.superkabel.de)- <kmc_> is there a guide to coping with Java and C++ after learning Haskell?
12:55:44 <mauke> hah
12:55:55 <Berengal> soupdragon: Whatever you name it, make sure it ends in -TRON and is spelled in all-caps
12:56:02 <mauke> soupdragon: Turnicabilism
12:56:17 <temoto> Too bad now we have good quotes on kmc and on kmc_.
12:56:51 <Berengal> @quote kmc
12:56:51 <lambdabot> kmc says: if a math paper is not written using LaTeX, it might as well be written with crayon
12:56:54 <temoto> Berengal, how to activate agda mode?
12:57:10 <basti_> korsakow: can i help you?
12:57:10 <mauke> preflex: quote kmc
12:57:10 -preflex(n=preflex@95-88-118-220-dynip.superkabel.de)- <kmc> i'll show you my Coq if you show me yours
12:57:17 <korsakow> hrm... i'm just a php/python/sql/java noob - in which way haskell would make me feel better? :)
12:57:20 <Berengal> temoto: Install Agda-executable from hackage, open a Foo.agda file in emacs
12:57:35 <Berengal> temoto: And take a gander at the agda wiki for further instructions
12:58:00 <Berengal> korsakow: It won't, if you continue to program in php/python/sql/java after you've learned it
12:58:30 <tensorpudding> haskell might improve your code in other languages, maybe
12:58:37 <Berengal> It does
12:58:39 <korsakow> Berengal: good answer! :)
12:59:07 <mm_freak> tensorpudding: well
12:59:17 <korsakow> ok i ask maybe better: where i can use haskell in business?
12:59:33 <kmc_> http://haskell.org/haskellwiki/Haskell_in_industry
12:59:33 <mm_freak> tensorpudding: haskell improved the length and safety of my code in other languages
12:59:37 <Berengal> korsakow: Programming in haskell is much less tedium-filled in my experience though. Less typing -> More time spent on thinking and more done in same amount of time -> more fun
12:59:43 <mm_freak> BUT
12:59:56 <soupdragon> haskell is the bees knees
13:00:01 <mm_freak> non-haskell programmers tend to go crazy about my code
13:00:04 <mm_freak> they don't understand it
13:00:34 <tensorpudding> yeah, in the end, it's usually better to write code in that language's more common style
13:00:35 <kmc_> knowing Haskell will make it depressing to use other languages
13:00:43 <kmc_> i'm not kidding, it may seriously hurt your job satisfaction
13:00:52 <ElfArmy> Haskell is one entry to start learning real programming, if you have no previous experience with such things it tends to make you a more honest programmer.
13:01:21 <Berengal> mm_freak: Hehe. I sometimes find myself having to rename most of my variables and rewrite most of my comments
13:01:36 <Berengal> mm_freak: Because they would be unintelligible to non-functional programmers
13:01:36 <aavogt> what does it mean to be an honest programmer?
13:01:39 <mm_freak> kmc_: it does
13:01:39 <basti_> > 1
13:01:40 <lambdabot>   1
13:01:51 <aledge> kmc, depends on what you are using the other languages for
13:01:53 <basti_> > 1+1
13:01:54 <lambdabot>   2
13:01:59 <aledge> kmc, for OS work, I still find it acceptable to use C
13:02:05 <basti_> > map (1+) [1,2,3,4]
13:02:06 <lambdabot>   [2,3,4,5]
13:02:20 <basti_> > map (-1) [1,2,3,4]
13:02:22 <lambdabot>   No instance for (GHC.Num.Num (a -> b))
13:02:22 <lambdabot>    arising from a use of syntactic n...
13:02:23 <mm_freak> Berengal: i usually need to redesign my entire project for a non-haskell (!) programmer to understand it
13:02:24 <basti_> oops
13:02:27 <basti_> ah
13:02:41 <basti_> > map ((-)1) [1,2,3,4]
13:02:42 <lambdabot>   [0,-1,-2,-3]
13:02:48 <basti_> > map (1-) [1,2,3,4]
13:02:50 <lambdabot>   [0,-1,-2,-3]
13:02:56 * pikhq likes tail-recursive C.
13:03:11 <aledge> I find haskell makes me feel dirty when I use dynamically typed languages like Python or Scheme
13:03:17 <mm_freak> luckily most compilers don't have tail-recursion…  this may appear as a deficiency at first, but it really forces you to write intelligible code for others =)
13:03:28 <Alpounet> I think it should be worth doing @where+ industry http://haskell.org/haskellwiki/Haskell_in_industry
13:03:28 <copumpkin> > map (–1) [1,2,3,4]
13:03:29 <pikhq> mm_freak: GCC is most compilers.
13:03:30 <lambdabot>   [0,1,2,3]
13:03:34 <pikhq> And GCC does TCO.
13:03:41 <mm_freak> pikhq: i'm not talking about C
13:03:47 <pikhq> Ah.
13:03:51 <mm_freak> i'm talking about the languages used in big companies
13:03:56 <mm_freak> like VB and C#
13:04:00 <mm_freak> or java
13:04:01 <pikhq> Yeah, screws with many other languages.
13:04:35 * soupdragon likes non-tail-recursive java
13:04:36 <zygoloid> mm_freak: C and C++ aren't used by big companies any more? ;-)
13:04:42 <aavogt> @where industry Alpounet
13:04:42 <lambdabot> http://www.haskell.org/haskellwiki/Haskell_in_industry
13:04:47 * zygoloid is off to tell his boss that they can finally abandon c++
13:04:49 <Alpounet> oh, it was already there
13:05:00 <aavogt> it's funnier when lambdabot knows nothing about industry though
13:05:11 <mm_freak> zygoloid: well, C++ is used, but usually not with GCC =)
13:05:14 <aavogt> @vixend do you know about industry?
13:05:15 <lambdabot> yeah, i know
13:05:36 <zygoloid> mm_freak: depends on which platform you're compiling for :)
13:05:42 <Alpounet> aavogt, just in case, I already know that URL, I can type it in less than 3 secs
13:05:49 <Alpounet> so much used to type it in heh
13:05:59 <kmc_> aledge: yes, C is a good systems programming language
13:05:59 <temoto> zygoloid, and your boss will go like few.. why you waited for so long!
13:06:06 <Alpounet> "oh you're writing haskell ? that mathematical language nobody uses ?"
13:06:07 <Alpounet> => link.
13:06:19 <Alpounet> +" code "
13:06:21 <kmc_> it boggles the mind that people write mail clients in C
13:06:39 <temoto> kmc_, like mutt?
13:06:43 <mm_freak> kmc_: i don't think that C is that great as a systems programming language
13:06:47 <mm_freak> in fact i'd prefer C++
13:06:58 <temoto> oh boy it's going to start..
13:07:02 <aledge> haha yeah
13:07:07 * zygoloid takes cover
13:07:11 <mm_freak> hehe
13:07:12 <kmc_> i think C is a good language for what it does, whereas C++ is a terrible language for everything, and despite this happens to be the only popular alternative for some tasks
13:07:17 * zygoloid agrees from mm_freak from the bunker
13:07:18 <kmc_> and yes this happens quite frequently here...
13:07:21 * aledge using all restraint to not respond
13:08:07 <zygoloid> kmc_: i think there's no reason to use C when C++ is available and is almost a proper superset :)
13:08:11 <temoto> kmc_, this C++ rant sounds close to how i see python problems actually.
13:08:34 <temoto> despite that it's not the only alternative
13:08:34 <Zao> All anyone ever needs is Ptr ().
13:08:48 <Alpounet> haha
13:08:57 <zygoloid> Ptr (forall a. a)
13:09:01 <mauke> preflex: store c++-fqa http://yosefk.com/c++fqa/
13:09:06 <kmc_> zygoloid: sure, using a few C++ features here and there can improve C code
13:09:07 <kynky> kmc i agree with your c/c++ comment
13:09:26 <dolio> We're talking about C++ again?
13:09:31 <kmc_> zygoloid: the danger is to go overboard with the fancy C++ features
13:09:35 <kynky> i think c++ is an ugly language
13:09:45 <kmc_> "idiomatic" clever C++ code is nothing like clever C code
13:09:51 <kmc_> it's certainly not a superset of clever C code
13:09:54 <temoto> dolio, yes and i'm about to throw in a J... thing before i leave to home. :)
13:10:11 <kmc_> one problem is that a lot of C++ features have other C++ features as dependencies;
13:10:16 <kmc_> the fqa goes into this
13:10:20 <aavogt> haskell has problems too
13:10:27 <Zao> The FQA is in my opinion a big troll piece.
13:10:38 <aavogt> so stay on topic :)
13:10:39 <Alpounet> it is indeed
13:10:41 <temoto> How dare you! Haskell is purest. lol
13:10:41 <pikhq> Zao: What about it is false?
13:10:43 <kmc_> the fqa is obviously a biased document and makes no secret of it
13:10:51 <kmc_> aavogt: yeah, i've ranted about them here in the past
13:10:53 <kynky> c++ is akin to cisc imho, haskell is like risc
13:10:55 <kmc_> anyway, it is OT
13:11:02 <Berengal> aavogt: Most of haskell's problems aren't related to issues of accidental complexity
13:11:38 <kmc_> what do you mean by "accidental complexity"?
13:11:38 <aavogt> Berengal: you're saying issues with H98, or H10, or all of ghc haskell?
13:11:56 <temoto> kynky, no, they're both monsters. Look at thousands of extensions. No other language besides Lisp has that.
13:12:05 <Berengal> kmc_: Features interacting in an unproductive and unintentional manner
13:12:05 <aavogt> I would argue that you could go overboard on ghc extensions... some of which are redundant
13:12:10 <zygoloid> pikhq: it's full of opinion and spin
13:12:15 <Zao> pikhq: It feels like it's written by someone that truly hates the language and finds flaws in everything about it.
13:12:28 <Berengal> aavogt: I'm talking about Haskell in general
13:12:39 <Twey> Zao: But it's still accurate.  :þ
13:12:40 <Berengal> aavogt: And using too many extensions isn't accidental
13:12:41 <kynky> the haskell language i thought wasnt complex, just how it was used, whereas C++ language is massive
13:12:44 <kmc_> temoto: http://gcc.gnu.org/onlinedocs/gcc-4.4.3/gcc/index.html#toc_C-Extensions
13:13:10 <temoto> I'm not saying gcc has less.
13:13:22 <kmc_> you said no language besides Lisp and Haskell had implementations with lots of extensions
13:13:41 <kmc_> anyway, let's talk about haskell in #haskell
13:13:41 <temoto> okay, i should have added gcc
13:13:43 <mauke> Zao: and I agree with large parts of it
13:13:45 <Berengal> Lisp doesn't have extensions, lisp is an extension-writing language
13:13:57 <aavogt> Berengal: what do you mean by accidental then?
13:14:02 <Zao> 17.2 - How can I handle a constructor that fails?
13:14:06 <kmc_> so, i think a major problem to the adoption of Haskell is the difficulty of reasoning about performance of code
13:14:06 <Twey> Lisps are languages for writing languages for solving problems
13:14:15 <Zao> He recommends to construct empty objects and have initialization functions :(
13:14:18 <kmc_> is this "accidental complexity" regarding laziness?
13:14:18 <Twey> LOP FTW
13:14:24 <aavogt> just because you need to write a pragma... is it really that much different than choosing to use an obscure feature?
13:14:29 <Alpounet> Zao, what he says is absolutely insane and wrong.
13:14:36 <mauke> Zao: yes, which follows the standard library
13:14:42 <Alpounet> (not for all FQAs, though)
13:14:45 <zygoloid> the main problem with the FQA is that people think it's criticizing C++ when a lot of the time it's just criticizing the C++ FAQ
13:15:33 <Berengal> kmc_: lazyness is a source of accidental complexity...
13:15:51 <Zao> mauke: The standard library isn't exactly idiomatic.
13:16:05 <Zao> mauke: By definition, it's not modern C++ :)
13:16:31 <mauke> I'm with Linus here (sort of); you're free to like C++, but it makes you stupid and ugly
13:16:40 <Berengal> I think Matz had a better term; exponential complexity
13:16:50 <kynky> agreed
13:16:55 <kmc_> C++ lacks orthogonality
13:17:00 <kmc_> every feature depends on every other feature
13:17:24 <kynky> c++ tried to be all things to all men
13:17:28 <Berengal> kmc_: Right, and unintentional dependencies create accidental complexity
13:17:34 <kmc_> they're not unintentional
13:17:39 <kmc_> it's just they didn't see a problem with it
13:17:43 <zygoloid> kmc_: that's spin, though. counterspin: every feature integrates well with every other feature
13:17:58 <kynky> how often do people use friends in c++ ?
13:18:10 <ahf> How come has C++ started being the new hot topic of #haskell? :P
13:18:19 <mauke> zygoloid: that's trolling, though
13:18:21 <kmc_> zygoloid: right, also meaning that every programmer on a project has to understand every feature
13:18:22 <zygoloid> kynky: rarely outside operator overloading, in my experience
13:18:38 <kmc_> there's no smooth path up from C, contrary to marketing
13:18:44 <kmc_> aaaanyway
13:18:46 <kmc_> #haskell-blah?
13:18:47 <lunabot>  luna: A section must be enclosed in parentheses
13:18:49 <Zao> kynky: With tightly coupled classes in a subsystem, especially factories. Aaaanyway, Haskell :)
13:19:03 <kynky> haskell++ :)
13:19:07 <kmc_> beer++
13:19:12 <Berengal> @karma haskell
13:19:12 <lambdabot> haskell has a karma of 57
13:19:16 <zygoloid> mauke: well, both statements are false, and both will be seen as trolling by some :)
13:19:24 <Zao> I'm doing FFI and get pseudo-COM objects via Ptr a.
13:19:28 <aledge> that would probably be (succ haskell)
13:19:37 <kmc_> @karma c
13:19:37 <lambdabot> c has a karma of 1
13:19:39 <int-e> @karma haskell'
13:19:39 <lambdabot> haskell' has a karma of 0
13:19:44 <Zao> Can I somehow magically glue my  Ptr a -> IO ()  function to be executed when the object is GC'd?
13:19:51 <kmc_> Zao: look at ForeignPtr
13:19:52 <Zao> Preferably on the same thread.
13:20:34 <Berengal> Zao: I don't think you can do it on the same thread if using the threaded runtime
13:20:41 <temoto> Oh btw, i wanted to ask how haskell C extensions handle custom free() routines, as in GNU TLS?
13:20:58 <kmc_> ForeignPtr
13:21:01 <Berengal> temoto: You register them with ForeignPtrs
13:21:03 --- mode: ChanServ set +o Heffalump
13:21:05 --- mode: Heffalump set +v BorisL
13:21:10 <kmc_> the Haskell runtime will not free anything that comes from the C heap
13:21:15 <kmc_> unless you instruct it to
13:21:29 <kmc_> typically, the Haskell marshalling side of the FFI binding will set up a finalizer
13:21:39 <kmc_> temoto: the FFI chapter of RWH is really good
13:21:57 <temoto> Yeah i should've look more documentation before asking.
13:22:14 <temoto> Though i guessed about finalizer :)
13:22:26 <kmc_> it's the same with standard free() or a custom free
13:22:58 <temoto> i liked the (# fun unsafe ... notation  too
13:23:05 <kmc_> hmm?
13:23:17 <soupdragon> nc -lvp 8080 -e /usr/local/bin/ghci
13:23:19 <temoto> hsgnutls is full of it.
13:23:20 <soupdragon> if you do that
13:23:32 <soupdragon> why doesn't like $.get("http://127.0.0.1:8080", function(data){ ... }) work?
13:23:34 <BorisL> hello. Type of print is  (Show a) => a -> IO (). I bound print to p with "let p = print", and ghci shows that type of p is () -> IO (). Why do the types differ?
13:24:07 <Heffalump> because of the monomorphism restriction
13:24:11 <Zao> ForeignPtr seems like just what I want.
13:24:21 <Heffalump> if you run ghci with -XNoMonomorphismRestriction, they will be the same.
13:24:35 <soupdragon> temoto do you know how I can do it :(
13:24:41 * glguy wonders if it would have been better received if named "the monomorphism helper"
13:24:48 <soupdragon> lol glguy
13:25:11 <BorisL> going RTFM:)
13:25:13 <Heffalump> I nearly called it "the dreaded monomorphism restriction" above.
13:25:34 <idnar> monomorphism pain in the ass
13:25:37 <Veinor> I keep finding myself wishing I had sections in Python.
13:25:50 <Veinor> because I want to write filter((== foo), mylist)
13:26:06 <idnar> [x for x in mylist if x == foo]
13:26:11 <Veinor> but that doesn't look as nice.
13:26:22 <Berengal> (x for x in mylist if x == foo) is lazy
13:26:26 <zygoloid> the Polymorphism Punisher?
13:26:39 <Veinor> in particular, I hate having to write [x for x in...]
13:26:41 <idnar> Berengal: he said filter, not ifilter
13:26:50 <idnar> Veinor: well, yeah, it's not nearly as nice as in Haskell
13:27:05 <Veinor> zygoloid: haha
13:27:06 <idnar> Veinor: I assume that was a fake example, though; do you have a real one?
13:27:12 <Berengal> idnar: Understandable typo ;)
13:27:26 <idnar> I regularly wish for all sorts of things from Haskell when I'm writing Python, but sections hasn't ever been one of them
13:27:31 <mm_freak> kmc_: C++ is terrible compared to modern languages
13:27:39 <mm_freak> but at least it has some reasonable abstractions
13:27:41 <zygoloid> idnar: maybe he's using python3?
13:27:41 <mm_freak> C has none
13:27:46 <mauke> mm_freak: FILE *
13:27:47 <Berengal> I can live without sections... until I write a lambda
13:27:54 <idnar> zygoloid: he said Python
13:27:56 <idnar> zygoloid: *efg*
13:27:57 <soupdragon> temoto I figured out :)
13:28:23 <kmc_> Heffalump: about 50% of references to it on the web use the word "dreaded"
13:28:44 <kmc_> i think GHC should at the very least accept {-# LANGUAGE NoDreadedMonomorphismRestriction #-}
13:29:21 <Berengal> How do you guys feel about the suggestion to remove implicit polymorphism in local bindings?
13:29:24 <Veinor> idnar: well, in particular         f_dict[f_val] = filter(lambda x: f(x) == f_val, things)
13:29:37 <zygoloid> Berengal: i don't think any of my code would notice
13:29:49 <Heffalump> Berengal: I hate the idea, but I guess SPJ's reasons for wanting it must be pretty good.
13:29:50 <idnar> Veinor: that seems really bizarre to me
13:29:58 <Heffalump> I read the paper but didn't fully understand it
13:30:01 <idnar> Veinor: I can't imagine why you would want to filter a list on equality to some value
13:30:11 <Heffalump> idnar: e.g. for counting
13:30:22 <Veinor> idnar: well, it's part of a function called group
13:30:24 <Heffalump> length . filter p
13:30:26 <idnar> Heffalump: you'd use list.count then
13:30:43 <Heffalump> ah
13:30:46 <idnar> things.count(f_val), specifically
13:30:53 <Berengal> On one hand, I very seldom use polymorphic local bindings. On the other hand, I expect everything to be as polymorphic as possible. On the gripping hand, it makes the compiler-writers' jobs easier, which totally goes against the purpose of language designs in the first place
13:31:17 <Heffalump> Berengal: it's not just the compiler-writers' job though, it's the other properties of the type system you get in exchange
13:31:18 <Veinor> group(`mod` 3, [1,2,3,4,5,6]) = {1: [1,4], 2 : [2,5], 0 : [3,6]}
13:31:22 <Veinor> to mix python and haskell.
13:31:30 <Heffalump> but I dislike the idea of not being able to abstract out code
13:31:49 <Veinor> basically it's groupBy only it will group together non-adjacend things.
13:31:50 <Veinor> *adjacent
13:32:01 <Berengal> Heffalump: Abstract out how? Moving sub-expressions into lets?
13:32:17 <Heffalump> yeah
13:32:38 <Veinor> also I personally hate how the tidiest way to uniqify a list is list(set(foo))
13:32:40 <Berengal> And also, what properties do you get in exchange?
13:32:41 <Heffalump> also moving global definitions into local ones based on usage stops working
13:32:56 <Heffalump> I can't remember, because I didn't understand the paper well enough to internalise them :-)
13:33:00 <Berengal> It's only the type /inference/ that's change, not the type system, nor the term language
13:33:01 <Heffalump> but I think there were some
13:33:04 <Heffalump> to do with GADTs etc
13:33:04 <Veinor> I want nubBy dammit >:(
13:33:13 <Berengal> changed*
13:33:28 <idnar> Veinor: so define it :P
13:33:36 <Heffalump> Berengal: inference is pretty important to the utility of the type system, IMO
13:34:20 <Berengal> Heffalump: It is, but based on personal experience, and the numbers in the paper, this wouldn't add an undue burden on us programmers
13:34:29 <Veinor> nubBy(f, xs) = group(f, xs).dict()
13:34:33 <Veinor> er, .values()
13:34:42 <Heffalump> which wouldn't, NoPolymorphicLetBindings?
13:34:47 <Berengal> Yeah
13:34:51 <Veinor> where group is the function I wrote for this progrm.
13:35:02 <Heffalump> seems that way, yes.
13:35:28 <Berengal> But then again, I'm a programmer, not a compiler-writer, so I want as many features as possible, and the compiler-writers to sweat as much as possible :P
13:35:52 <idnar> Veinor: isn't that just groupby(f, sorted(xs))?
13:36:02 <Heffalump> what I'm saying is that I think they are offering better features in other situations in exchange for losing this one
13:36:18 <idnar> er
13:36:21 <idnar> groupby(sorted(xs), f)
13:37:53 <Berengal> Heffalump: From what I could understand they didn't. They offered reduced complexity in the compiler.
13:37:58 <Veinor> idnar: oh, huh.
13:38:20 <Veinor> it's kind of like that.
13:38:52 <Veinor> maybe. I dunno.
13:39:33 <Berengal> Heffalump: "The payoff is a substantial simplification, both of the specification of the type system and of its implementation."
13:40:34 <idnar> Veinor: well, wrap a dict() around that at leas
13:40:37 <idnar> Veinor: t
13:40:51 <idnar> Veinor: and the values will still be iterators, not lists
13:41:09 <idnar> Veinor: anyhow, don't mean to pick your code apart ;) I was just quite curious
13:41:28 <zygoloid> Veinor: nub is asymptotically slower than list(set(x))...
13:42:04 <Heffalump> Berengal: right, the specification being the key point from the programmer's perspective
13:42:31 <Heffalump> s2.2 lists quite a lot of downsides for the programmer (more complicated inferred types, worse errors)
13:42:33 <idnar> @src nub
13:42:33 <lambdabot> nub = nubBy (==)
13:42:35 <idnar> @src nubBy
13:42:35 <lambdabot> nubBy eq []             =  []
13:42:35 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
13:42:48 <Heffalump> also slower type-checking
13:43:06 <Veinor> zygoloid: well, I'm running this on, like.... maybe 30 elements at the very very most.
13:43:20 <idnar> what is nub, O(n^2)?
13:43:21 <Saizan> Heffalump, Berengal: which paper is this?
13:43:24 <Twey> 21:38:17 < Veinor> nubBy(f, xs) = group(f, xs).dict()
13:43:27 <Twey> What language is that?
13:43:31 <Berengal> Saizan: http://research.microsoft.com/en-us/um/people/simonpj/papers/constraints/let-gen.pdf
13:43:34 <idnar> Twey: python
13:43:39 <Twey> o.@
13:43:43 <Twey> No way
13:43:43 <Saizan> thanks
13:43:45 <idnar> Twey: well, not really
13:43:50 <idnar> Twey: pseudo-python, I guess
13:43:52 <Twey> Ah
13:44:12 <idnar> I think the closest you could get is nubBy = lambda f, xs: group(f, xs).values()
13:45:02 <Berengal> Heffalump: I guess that's true, but I think the complicated types and errors could be solved by a better interface to the compiler's type-checker
13:45:18 <Twey> idnar: Yeah
13:45:42 <Twey> def nubBy(f, xs): return group(f, xs).__dict__() maybe?
13:45:45 <Berengal> Agda has much more complicated types, but they're easier to reason about and the errors are better I think...
13:45:58 <Twey> I mean, def nubBy(f, xs): return dict(group(f, xs)) maybe?
13:46:28 <idnar> Twey: group() returns a dict, the .dict() was supposed to be .values()
13:46:35 <idnar> Twey: but anyway, yeah, that would also work
13:46:38 <Twey> Oh, right
13:46:55 <Twey> Heh… I just did :t group in my Python interpreter…
13:47:00 <idnar> Twey: haha
13:47:06 <Twey> Where's group()?
13:47:13 <xerox> help(group) right?
13:47:15 <Loriel> @google group
13:47:17 <lambdabot> http://www.group.com/
13:47:17 <lambdabot> Title: Welcome to Group.com!
13:47:19 <idnar> Twey: it's a function Veinor wrote
13:47:23 <Loriel> ... I need to stop saying that instead of hoogle
13:47:24 <Twey> Loriel: That's going to work… :þ
13:47:26 <Twey> Oh
13:47:34 <idnar> @type group
13:47:35 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
13:47:36 <idnar> @type groupBy
13:47:37 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
13:47:39 <Twey> Okay, phew
13:47:43 <Twey> I haven't lost all my Python, then
13:47:46 <idnar> > group [1, 2, 1, 1]
13:47:47 <lambdabot>   [[1],[2],[1,1]]
13:48:15 <Loriel> > group . conat . sort . group $ [1, 2, 1, 1]
13:48:17 <lambdabot>   Not in scope: `conat'
13:48:19 <Loriel> > group . concat . sort . group $ [1, 2, 1, 1]
13:48:21 <lambdabot>   [[1,1,1],[2]]
13:48:36 <idnar> Twey: I think itertools.groupby is basically the same as Data.List.groupBy
13:48:47 <idnar> oh, not quite
13:48:58 <idnar> but close
13:49:03 <Veinor> > let f = odd in groupBy f $ sortBy (comparing f) [1,2,1,1]
13:49:04 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
13:49:04 <lambdabot>         against inferred ...
13:49:19 <Veinor> oh yeah.
13:49:31 <Veinor> > let f = odd in groupBy (\x y -> f x == f y) $ sortBy (comparing f) [1,2,1,1]
13:49:32 <lambdabot>   [[2],[1,1,1]]
13:49:49 <Veinor> > let f = odd in groupBy ((==) `on` f) $ sortBy (comparing f) [1,2,1,1]
13:49:51 <lambdabot>   [[2],[1,1,1]]
13:49:54 <Veinor> hooray for on!
13:51:22 <idnar> > @type let groupy f xs = groupBy ((==) `on` f) $ sortBy (comparing f) xs in groupy
13:51:23 <lambdabot>   <no location info>: parse error on input `@'
13:51:26 <idnar> oops
13:51:27 <idnar> @type let groupy f xs = groupBy ((==) `on` f) $ sortBy (comparing f) xs in groupy
13:51:27 <lambdabot> forall a b. (Ord b) => (a -> b) -> [a] -> [[a]]
13:51:48 <idnar> so you get an Ord constraint when you only really need an Eq
13:52:03 <Veinor> right, which is unfortunate.
13:52:17 <idnar> wait, why do you get an Ord constraint?
13:52:22 <idnar> oh, comparing
13:52:24 <Veinor> sort.
13:52:32 <idnar> that's fixable
13:53:07 <idnar> I think
13:53:22 <Veinor> yeah, I mean it's obviously not strictly necessary.
13:53:24 <idnar> @type let fakecmp x y = if x == y then EQ else LT; groupy f xs = groupBy ((==) `on` f) $ sortBy (fakecmp `on` f) xs in groupy
13:53:25 <lambdabot> forall a b. (Eq b) => (a -> b) -> [a] -> [[a]]
13:53:30 <zygoloid> not without sacrificing performance i think
13:53:57 <zygoloid> or correctness in that case :)
13:54:03 <idnar> I'm pretty sure it's still correct
13:54:04 <Veinor> you could also probably directly write groupy.
13:54:23 <kmc_> gropey?
13:54:43 <idnar> > let fakecmp x y = if x == y then EQ else LT; groupyEq f xs = groupBy ((==) `on` f) $ sortBy (fakecmp `on` f) xs; groupyOrd  in groupy odd [1,2,1,1,3,4,5]
13:54:44 <lambdabot>   <no location info>: parse error on input `in'
13:54:47 <idnar> argh
13:54:51 <zygoloid> idnar: what does sortBy do when given something which isn't an ordering? :)
13:55:26 <Veinor> > let fakecmp x y = if x == y then EQ else LT; groupyEq f xs = groupBy ((==) `on` f) $ sortBy (fakecmp `on` f) xs in groupyEq odd [1,2,1,1,3,4,5]
13:55:27 <lambdabot>   [[1],[2],[1,1,3],[4],[5]]
13:55:28 <monochrom> eww, dependent on sorting algorithm details
13:55:35 <Veinor> oh noes!
13:55:48 <idnar> @check let fakecmp x y = if x == y then EQ else LT; groupyEq f xs = groupBy ((==) `on` f) $ sortBy (fakecmp `on` f) xs; groupyOrd f xs = groupBy ((==) `on` f) $ sortBy (comparing f) xs in \xs -> groupyEq (xs :: [Integer]) == groupyOrd xs
13:55:49 <lambdabot>   Couldn't match expected type `a -> b'
13:56:01 <idnar> eek
13:56:10 <xerox> ouch
13:56:49 <kmc_> yeah, sortBy's argument types should include a proof that the function is a total ordering
13:56:55 <monochrom> sortBy (\x y -> unsafePerformIO (putStrLn "another comparison!" >> return (compare x y))  -- let's count comparisons!
13:57:16 <idnar> oh, right, I left out f
13:57:27 <idnar> @check let fakecmp x y = if x == y then EQ else LT; groupyEq f xs = groupBy ((==) `on` f) $ sortBy (fakecmp `on` f) xs; groupyOrd f xs = groupBy ((==) `on` f) $ sortBy (comparing f) xs in \xs -> groupyEq odd (xs :: [Integer]) == groupyOrd odd xs
13:57:28 <lambdabot>   "Falsifiable, after 7 tests:\n[-1,-1,-2]\n"
13:57:30 <xerox> Please at least use «trace»! My eyes are bleeding!
13:57:42 <monochrom> sortBy (
13:57:46 <kmc_> sortBy (unsafeCoerce ())
13:57:55 <idnar> @check let fakecmp x y = if x == y then EQ else LT; groupyEq f xs = groupBy ((==) `on` f) $ sortBy (fakecmp `on` f) xs; groupyOrd f xs = groupBy ((==) `on` f) $ sortBy (comparing f) xs in \xs -> sort (groupyEq odd (xs :: [Integer])) == sort (groupyOrd odd xs)
13:57:56 <lambdabot>   "Falsifiable, after 6 tests:\n[4,-5,0]\n"
13:58:09 <monochrom> sortBy (\x y -> trace "another comparison!" (compare x y))
13:58:21 <idnar> oh okay, guess it doesn't work
13:58:34 <zygoloid> @check \xs -> let fakecmp x y | x == y = EQ | True = LT in sortBy (fakecmp `on` (`mod` 3)) xs == xs
13:58:35 <lambdabot>   "OK, passed 500 tests."
13:58:38 <zygoloid> idnar: your sort is doing nothing
13:58:43 <Zao> I'm looking for something that can discard a return type of an IO action, preferably something more elegant than >> return ()
13:59:00 <Zao> I guess the type would be similiar to (-> IO a) -> IO (-> (IO ())
13:59:05 <Zao> (if that's even legal)
13:59:13 <idnar> zygoloid: yeah, okay, I guess using sortBy isn't going to be feasible
13:59:17 <monochrom> Zao: Sadly, not in the libs, but you should define it for yourself.
13:59:34 <idnar> so I suppose we do this the long way
13:59:37 <monochrom> Following ML's, ignore m = m >> return ()
13:59:38 <Veinor> it sure is a good thing you can just write an Ord instance for every type
13:59:44 <Veinor> :D
13:59:44 <zygoloid> idnar: i think what you're doing is fundamentally quadratic
13:59:45 <Zao> Ah, decent name.
14:00:08 <monochrom> Yeah the ML's have "ignore" for exactly this in their libs.
14:00:09 <zygoloid> idnar: (that is, with only the Eq constraint)
14:00:19 <Veinor> that is, for every type whose values are a set.
14:00:22 <zygoloid> idnar: because (==) must be applied to all pairs of values.
14:00:52 <xerox> another comparison!
14:00:52 <zygoloid> Veinor: Ord (a -> b) ?
14:01:05 <Veinor> I invoke the axiom of choice!
14:01:19 <zygoloid> haha ok :)
14:01:22 <Veinor> :P
14:01:40 <xerox> You have the right to remain silent, everything you choose can and will be used against you.
14:01:59 <Veinor> actually, can you define an ordering on every set without the AoC?
14:02:05 <idnar> zygoloid: I don't really care about that
14:02:07 <Veinor> I mean, AoC proves well ordering, which is stronger.
14:02:50 <idnar> > let groupy f [] = []; groupy f (x:xs) = filter (\y -> f x == f y) xs : groupy f (filter (\y -> f x /= f y) xs) in groupy odd [1,2,1,1,3,4,5]
14:02:50 <lambdabot>   [[1,1,3,5],[4]]
14:02:51 <zygoloid> Veinor: my hunch is that you don't need AoC but i don't know :)
14:02:52 <kmc_> ignore = (>> return ())
14:02:54 <Veinor> I think all you need is probably a total ordering.
14:02:57 <idnar> erk
14:02:58 <Veinor> for sorting, that is.
14:03:03 <idnar> oh wait, that is right
14:03:05 <monochrom> No. Given ZF, AC = WO.
14:03:07 <Veinor> that is, sorting finite lists.
14:03:24 <Veinor> monochrom: but we don't need WO, we just need a total ordering on every set.
14:04:02 <Veinor> so the normal ordering works fine for reals.
14:04:13 <doserj> I would guess you can define an ordering based on the epsilon-structure
14:04:27 <zygoloid> Veinor: ... damn, doserj got there first
14:04:29 <doserj> (epsilon = is-element-of relation)
14:04:45 <zygoloid> you can easily totally order the elements of any ordinal.
14:05:00 <Veinor> hm.
14:05:00 <idnar> zygoloid: I don't understand why (==) needs to be applied to all pairs of values
14:05:08 <monochrom> I see.
14:05:19 <idnar> zygoloid: (==) is transitive
14:05:28 <zygoloid> idnar: suppose all but two elements are different.
14:05:28 <idnar> zygoloid: I'm pretty sure my version doesn't apply it to all pairs of values, either
14:05:37 <zygoloid> idnar: right, and your version was wrong :)
14:05:44 <quicksilver> zygoloid: yes, but guaranteeing to  find a bijection between an arbitrary set and some ordinal is AC, isn't it?
14:05:46 <idnar> zygoloid: what's wrong with it?
14:05:49 <quicksilver> it's the same as WO.
14:06:04 <zygoloid> idnar: it, umm, didn't give the right answer? :)
14:06:15 <idnar> zygoloid: not the one with the broken sortBy, the one I gave just now
14:06:15 <Veinor> I like how this turned from a discussion about grouping a list by some function into a discussion about ordinal numbers.
14:06:18 <quicksilver> teh reals happen to easy because they have a built-in order as part of their characterisation.
14:06:41 <Zao> Hrm, seems like I traded my problem of having to release my Ptr a to a problem having to release my FunPtr (Ptr a -> IO ()).
14:06:48 <Zao> I guess it's a nicer problem to have.
14:07:00 <zygoloid> idnar: your new one is quadratic. it applies (/=) to every pair if all elements are different.
14:07:14 <Zao> Assuming that all my ForeignPtr's die before my DLL is unloaded.
14:07:30 <idnar> zygoloid: sure, it's still quadratic
14:07:34 <Zao> There's no guarantee for that, is there?
14:07:54 <zygoloid> idnar: and it still applies (==) [or, pedantically, (/=)] to every pair
14:07:59 <zygoloid> (worst-case)
14:08:05 <idnar> zygoloid: but in the best case, it's not nearly as bad
14:08:36 <zygoloid> idnar: sure. but my point was, it's fundamentally quadratic, so an O(n log n) algorithm is not going to be possible.
14:08:42 <idnar> oh wait, I'm comparing everything twice
14:09:30 <zygoloid> i perhaps should have made this clearer, but i was explaining how i knew your sorting approach was broken :)
14:09:52 <idnar> zygoloid: yeah, I'm still trying to wrap my head around that
14:09:58 <idnar> zygoloid: I don't know enough set theory :(
14:10:57 <damd> @yar
14:10:57 <lambdabot> Splice the Mainbrace!
14:11:03 <wto> @yarr
14:11:03 <lambdabot> Smartly me lass
14:11:31 <monochrom> What was idnar's original quest?
14:11:38 <damd> @quote idnar
14:11:38 <lambdabot> idnar says: what the heck am I doing
14:11:53 <monochrom> Oh, that's philosophical. :)
14:12:08 <idnar> haha
14:12:24 <monochrom> Expect to take doubly-exponential time!
14:13:17 <idnar> monochrom: Veinor had a Python function; I rewrote it a different way in Python, then somebody (Veinor?) ported it to Haskell as "groupBy ((==) `on` f) $ sortBy (comparing f) xs"
14:13:24 <idnar> monochrom: and then I was trying to get rid of the Ord constraint there
14:14:13 <idnar> my intuition is upset by the fact that the Ord constraint allows us to improve asymptotic performance, even though we don't care about ordering
14:15:12 <idnar> and I don't think I know enough set theory to understand why that is
14:15:30 <student2> how do i receive form content trough a GET
14:16:52 <student2> how do i receive form content trough a GET
14:18:06 <Cale> student2: Which library are you using?
14:18:06 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
14:18:19 <student2> httpd-shed
14:19:23 <mreh> is there a type to represent a permutation?
14:19:24 <lambdabot> mreh: You have 1 new message. '/msg lambdabot @messages' to read it.
14:19:35 <mreh> @messages
14:19:35 <lambdabot> temoto said 3h 29m 14s ago: he said he'll give sources tomorrow. You may contact me at temotor@gmail.com
14:19:36 <Cale> student2: Well, I'm not so familiar with that library, but it looks like there's a reqHeaders field in Request which ought to contain the form data.
14:20:05 <student2> reqHeaders, oke tnq you
14:20:09 <student2> i'll try that one
14:21:27 <monochrom> idnar: You should not focus on "how much do I care", but rather "how many tools am I provided". Or in other words how much of the underlying structure is exposed to you, or what kind of API is exposed to you.
14:21:45 <monochrom> It is exploiting rather than caring.
14:24:42 <mreh> lists are inadequate for representing permutations as the majority of the lists of length n are not valid permutations
14:26:14 <monochrom> Suppose I am building an abstract data type for your use. At the beginning, I provide you no Eq and no Ord. What is the complexity of grouping? Infinity.
14:26:21 <idnar> monochrom: what?
14:26:30 <idnar> monochrom: oh
14:27:25 <idnar> monochrom: it's just not obvious to me how having a total ordering helps you with equality comparisons
14:27:44 <idnar> they seem mostly unrelated
14:27:47 <hatds> does an OS "block" to synchronize with the video card when it wants to redraw the screen?
14:27:52 <monochrom> So you make a request, and I fulfill the request. I give you Eq. Now the complexity of group is quadratic. From infinity to quadratic. Isn't that a marvelous improvement? To be fair, the only instance you use my Eq at all is for grouping. In a sense you don't care about Eq otherwise.
14:28:46 <student2> how do i receive form content trough a GET and reqHeaders doesn't work:P
14:28:48 <dolio> Ordering lets you do binary search instead of linear search.
14:28:58 <dolio> As an example.
14:28:59 <Saizan> i thought group were linear
14:29:42 <idnar> Saizan: this isn't Data.List.group
14:30:28 <dolio> If you have a data structure that stores things according to a total ordering, comparison with one element in the structure can give you information about other elements, too.
14:30:34 <dolio> Whereas with just equality, it can't.
14:30:34 <monochrom> Does union-find use Ord?
14:30:55 <idnar> dolio: hmm, I guess
14:31:32 <monochrom> IIRC union-find just needs Eq or Eq-modulo-f (i.e., (==) `on` f).
14:31:53 <monochrom> If you use union-find for grouping, what is the cost?
14:32:13 <monochrom> IIRC it is not bad either.
14:32:24 <student2> is someone familiar with httpd-shed?
14:32:29 <dolio> If I have a sorted array, and I compare with the median element, and find out that my value is greater than the median, I don't need to test anything less than the median, because I know they're all not equal to my value, either.
14:32:31 <student2> the library*
14:32:58 <idnar> what is union-find?
14:33:22 <kmc_> student2: a little bit
14:33:40 <idnar> dolio: well, that's only because you know it's sorted
14:33:55 <student2> do you know how to receive from a browser the content of a form?
14:33:55 <idnar> dolio: but I guess you can sort in O(n log n)
14:34:02 <dolio> So? Ordering enables sorting.
14:34:15 <kmc_> student2: you'll get a request
14:34:28 <dolio> There's no such thing as sorting if you just have equality. There's just grouping.
14:34:29 <kmc_> to a URL you specify in the form's HTML code
14:34:41 <monochrom> Hrm! union-find for grouping may still be quadratic just because everyone ends up unequal.
14:34:46 <kmc_> if the form was submitted by the POST method, it'll be a POST request
14:34:53 <student2> i have a submit buttong with action = "submit"
14:35:02 <student2> and method = "GET"
14:35:05 <kmc_> student2: read about how HTML forms are submitted over HTTP
14:35:20 <kmc_> if you use GET, i think it'll url-encode the form values onto the url
14:35:52 <student2> I know a little bit how http works
14:36:05 <student2> but i cant find them in the request
14:36:06 <dolio> So ordering allows you to build structures that can give you more information with a single test than equality.
14:36:30 <kmc_> the "network" package has a module Network.URI which has some stuff for working with URI
14:36:39 <monochrom> At present my only answer is still just: if you're giving a wider API, whether you care or not, whether the extra operations are mentioned in the problem statement or not, you may still exploit them and get a faster algorithm.
14:37:08 <student2> i'm not allowed to use other things dan httpd-shed
14:37:20 <idnar> monochrom: I don't have a problem with that, I'm just trying to understand exactly how it's being used to help
14:37:25 <monochrom> s/giving/given/
14:37:28 <idnar> monochrom: I think dolio's nudge cleared that up, though
14:37:32 <abccc> hi
14:37:39 <abccc> can anyone give me a hint how i can draw the getClockTime with the showText in cairo? Compiler says that I need an Render Clocktime not an IO Clocktime
14:38:12 <kmc_> Render is some cairo monad?
14:38:17 <Cale> abccc: Render is an instance of MonadIO, so just use liftIO
14:38:46 <abccc> thx, I will look for that.
14:39:09 <Cale> Or: pass the current time in as a parameter to the function which decides what rendering to do.
14:39:31 <Cale> liftIO is in Control.Monad.Trans
14:39:50 <Cale> But it should already be in scope, I think...
14:40:23 <doserj> I would assume showText expects a String, so you have to show the Clocktime.
14:40:24 <Cale> I think it's re-exported by the same module that defines Render, but I'd have to check.
14:54:28 <Zao> Re: ignore. Is it possible to write a generic ignore that handles N-ary actions?
14:54:54 <Zao> Say that I have an  (a -> b -> IO c)  and want it to be an (a -> b -> IO ()) ?
14:55:05 <soupdragon> Zao, you could probably use typeclasses
14:56:32 <Zao> I guess it's a similiar problem as liftM2 and friends.
14:57:02 <aavogt> liftMn (const ())
14:57:22 <soupdragon> yeah I don't see this as a particularly difficult problem?
14:57:24 <aavogt> err, no
14:57:27 <luqui> Zao, whenever you ask about N-ary generic operations in Haskell, the answer is usually no
14:57:34 <luqui> or rather "yes, but you really don't want to"
14:58:47 <luqui> you can write (fmap.fmap. ... .fmap) ignore
14:59:06 <Zao> luqui: At this point I only need unary ones, but as it's a generic building block in ML, I anticipate that one could need more arities.
14:59:19 <luqui> Zao, the problem is that (->) is itself a monad
14:59:34 <luqui> so ignore on a -> b -> IO c actually means a -> ()
15:00:22 <aavogt> luqui: the ignore could be specialize to IO though
15:00:43 <luqui> yeah but that is getting gross... imo
15:00:56 <aavogt> or maybe MonadIO m => ...   though I'm not sure if that can be done
15:01:05 <luqui> you are getting into the area of "magic notation" instead of saying what you mean
15:01:26 <luqui> if you are doing things right, you ought to know how many levels deep the thing you want to ignore is
15:01:39 <Zao> luqui: I do, but I do not want to define a tonne of functions for it.
15:01:57 <luqui> Zao, well IME i don't think you will end up needing them
15:02:12 <luqui> functions with huge arities are very rare
15:02:26 <luqui> and usually indicate a design problem
15:02:36 <soupdragon> it's a good point about magic notation
15:02:42 <luqui> if you need more than (fmap.fmap) ignore I would get scared.
15:03:27 <Zao> luqui: I currently have a 10-ary function defined. I'm not in control of arity as I'm FFI-ing.
15:03:41 <kmc_> yeah, but crazy FFI functions should only be seen deep within marshalling code
15:04:03 <Zao> kmc_: Which is what I'm writing.
15:04:29 <kmc_> sure, but it's easier to stomach a little ugliness there
15:04:46 <kmc_> anyway it'd be a pretty simple TH hack
15:04:47 <Zao> I guess.
15:04:50 <kmc_> if you want to resort to that ;)
15:04:56 <kmc_> @quote majesty
15:04:57 <lambdabot> malcolm says: I don't believe you need to invoke the full awesome majesty of Template Haskell
15:04:57 <Dashkal> Does anything break if define an Ord instance that considers two inequal values as equal for purposes of ordering?  I'd like to order a type ignoring some fields.
15:04:58 <Zao> Just feels like an useful primitive to have available in general.
15:05:12 <kmc_> Dashkal: Ord *defines* whether two values are "inequal" or "equal"
15:05:28 <kmc_> Err, sorry
15:05:32 <kmc_> Eq does
15:05:40 <kmc_> You have a,b such that a == b but (compare a b) /= EQ ?
15:05:41 <Dashkal> data foo ... deriving ( Eq ) / instance Ord foo where ...
15:05:49 <Dashkal> other way around
15:05:50 <Philonous> Zao: You can write multivariadic function composition (a -> b -> ... -> c  -> d) -> (d->e) ( a -> b -> ... -> c -> e)
15:06:00 <Dashkal> a != b, but compare a b == EQ
15:06:02 <kmc_> Dashkal: hmm, that's a good question
15:06:57 <kmc_> i think it'd be okay
15:07:13 <kmc_> but i'm looking for a canonical reference in the Report
15:07:47 <soupdragon> btw
15:07:51 <kmc_> it doesn't say
15:08:02 <kmc_> the Report does not give any laws for Eq or Ord
15:08:14 <kmc_> there's a standard Eq instance with (==) that's not even reflexive
15:08:30 <Dashkal> mmm, so it depends on what assumptions are made by things that make use of Ord (for example, Data.Map.Map)
15:08:46 <soupdragon> Zao don't use this : Phttp://hpaste.org/fastcgi/hpaste.fcgi/view?id=16761
15:08:49 <soupdragon> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16761
15:09:01 <soupdragon> but this lets you do e.g.  (ignore quote :: [Integer] -> String -> IO ()) [] "foo"
15:09:16 <soupdragon> quote turns a type into a value, so that ignore can do recursion on it
15:09:31 <Dashkal> Basically I'd like to control sorting on these values without having to care about some fields.
15:09:48 <kmc_> Dashkal: but you want (==) to care about those fields?
15:09:50 <soupdragon> and the GADT lets you define variadic functions in a natural way
15:10:08 <kmc_> It might be best to make Eq and Ord consistent with each other, then define other type-specific comparison as you desire
15:10:20 <soupdragon> Zao, wonder if it makes sense?
15:10:43 <soupdragon> hmm *notices a bug*
15:11:40 <Dashkal> kmc_: mmm, making eq ignore those same fields would make it consistent, yes.  That's partily laziness.  I like deriving Eq
15:12:33 <Zao> Looks evil :)
15:12:36 <soupdragon> Zao, I annotated it with a bugfix
15:12:51 <soupdragon> Zao, but yeah - it's kinda sick
15:13:21 <kmc_> typeclasses still feel like a hack sometimes
15:13:35 <kmc_> they're a wildly successful hack of course
15:13:50 * soupdragon would like typeclasses to be much more powerful ..
15:14:00 <kmc_> but it's strange that i'm supposed to pick One True Comparison Predicate, and that if I don't, another module can do it for me
15:14:00 <tensorpudding> are typeclasses that hackish?
15:14:01 <Dashkal> hmm, rather than making == behave oddly, I'm probably better off ignoring Ord and just sorting by hand.  There's only one case where it even matters.
15:14:33 <Philonous> Zao: Don't use this either: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=6542#a6542
15:14:36 <kmc_> Dashkal: ah, here's an idea: define a newtype wrapper for your type which has the special comparison
15:14:56 <Berengal> tensorpudding: I'm starting to believe more and more in records, possibly with "default" values that are inferred by the compiler unless you make it explicit
15:14:58 <soupdragon> Philonous, wow!
15:15:07 <soupdragon> that's pretty sick too :P
15:15:11 <kmc_> Philonous: that looks like it might be a bit more comprehensible with type synonym families
15:15:18 <kmc_> @quote oleg
15:15:19 <lambdabot> oleg says: It is known, albeit not so well, that following the OOP letter and practice may lead to insidious errors.
15:15:24 <kmc_> @quote oleg
15:15:25 <lambdabot> oleg says: Unfortunately, once it became clear that the ideas are working out, the motivation fizzled.
15:15:36 <uorygl_> @quote oleg
15:15:36 <lambdabot> oleg says: Unfortunately, once it became clear that the ideas are working out, the motivation fizzled.
15:15:43 <kmc_> @quote millioleg
15:15:43 <lambdabot> olsner says: < kmc> i think 250 milliolegs is enough to kill an elephant  < olsner> kmc: ... to kill an elephant - in the type system!
15:15:52 <Dashkal> kmc_: mmm, I like it.  And that does fit in with the idea of what I'm doing.
15:18:35 <Philonous> soupdragon: It's actually really straight forward. Unfortunately the type system isn't powerful enough to tell it directly what I want to do.
15:19:23 <soupdragon> yeah
15:23:34 * Saizan prefers using typeclasses as only decision procedures for relations expressed as gadts
15:24:23 <Berengal> I do like records...
15:24:54 <Berengal> What if we decided that records could only be product types, but you could subtype them?
15:25:06 <Berengal> y/n?
15:25:23 <idnar> Berengal: mu
15:26:00 <dolio> I think row polymorphism is better than subtyping.
15:26:06 <dolio> In a Haskell context, at least.
15:26:27 <Berengal> dolio: I'm not familiar with that concept
15:27:23 <dolio> Something like: foo :: forall r :: Row. { bar :: T, baz :: U | r }
15:27:41 <dolio> That's probably a bad example.
15:27:53 <dolio> Make it '... -> o'.
15:28:02 <Berengal> Doesn't parse...
15:28:31 <dolio> Then, foo takes a record that has a bar field of type T and a baz field of type U, and any number of other fields, represented by r, and returns an o.
15:28:43 <Berengal> Does the |r mean that r is a set of fields that extend the preset ones?
15:29:19 <Berengal> If so I was thinking something like that as well...
15:29:30 <kmc_> Saizan: hmm, that's an interesting idea... do you have a simple concrete example?
15:29:40 <Berengal> But how would you define fields?
15:29:46 <kmc_> Berengal: subtyping of any sort would be a huge departure for Haskell
15:30:19 <Berengal> kmc_: I'm not convinced it would, with the proper restrictions
15:30:32 <dolio> Rows are something like: <> (empty row) OR < name :: type | r > (where r is a row).
15:30:33 <kmc_> I think any proposal to change records should start from an idea of first-class record labels
15:30:52 <Saizan> kmc_: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16763#a16763
15:31:07 <Berengal> dolio: Yeah, I think I understand
15:31:11 <dolio> With < name1 :: type1, name2 :: type2 ... | r > being an abbreviation for < name1 :: type1 | <name2 :: type2 | ... | r>>
15:31:22 <Berengal> kmc_: foo :: (a <: B) => a -> Int
15:31:34 <Berengal> kmc_: Looks very much like a typeclass, no?
15:31:37 * kmc_ giggles at isHomo
15:31:46 <idnar> kmc_: haha
15:31:47 <Saizan> kmc_: the nice thing is that once you've a Fun there are many things that would be methods of some typeclass that you can just write as functions
15:32:21 <dolio> And then you have Rec :: Row -> *, and { name1 :: type1 ... } is sugar for Rec < name1 :: type1 ...>.
15:32:35 <Berengal> dolio: But presumably you want to define the fields somewhere, to get the compiler to dispatch for us like it does with type classes
15:32:35 <dolio> And in types, you can quantify over Rows.
15:32:53 <dolio> What do you mean define the fields?
15:33:31 <Berengal> Say you have "foo x = firstName x", you want to infer the type of that function the same as you would with "foo x = show x"
15:33:48 <Berengal> So firstName needs to be defined as a record field
15:34:00 <Saizan> you could use some other syntax
15:34:14 <dolio> Well, maybe field names could have a special prefix that distinguishes them from normal function names, I'm not sure.
15:34:20 <Saizan> get 'firstName x, where the ' tells you firstName is a label
15:34:49 <Berengal> I think that we could get pretty nice views if fields were accessors
15:34:53 <temoto> dolio, like a prefix of their type name, or constructor.
15:35:20 <dolio> Like $field. Everyone likes that from perl, right?
15:35:30 <Berengal> Personally, I want to move -> away from lambdas and cases (use = instead) and use it for accessors instead...
15:35:34 <dolio> Or is %field better?
15:35:55 <soupdragon> can I ask GHCI not to print ANY prompt?
15:35:59 <Berengal> record->field
15:36:06 <temoto> let x = newRequest{ fields... } in x.uri
15:36:21 <mauke> soupdragon: :set prompt ""
15:36:23 <temoto> anything instead of '.' will do just fine too
15:36:26 <Berengal> Perhaps even just as the field selector function...
15:36:43 <Cale> :set prompt ""
15:36:44 <Cale> yep
15:36:54 <Berengal> temoto: Yeah, we there can only be one meaning for '.'
15:36:56 <soupdragon> thanks you two :D
15:37:11 <Cale> Personally, I prefer to have it print at least "ghci> "
15:37:13 <temoto> Berengal, there are 2 now.
15:37:22 <soupdragon> Cale (it's because I'm making my own repl)
15:37:29 <Saizan> don't reuse -> in expressions, think of when you'd mix them with types!
15:37:30 <Berengal> temoto: I know. It infuriates me :(
15:37:48 <Berengal> It's one of those small annoyances of Haskell... like a pebble in your shoe...
15:38:04 <yrlnry> Hi, folks.
15:38:09 <dolio> There are more than two.
15:38:26 <Saizan> 4 if you count lambdabot :)
15:38:35 <dolio> @type (1.2, succ.succ, Prelude.length)
15:38:37 <lambdabot> forall t a a1. (Fractional t, Enum a) => (t, a -> a, [a1] -> Int)
15:38:40 <soupdragon> setting the prompt to nil doesn't work :(
15:38:46 <Berengal> dolio: Well, it's both a legal identifier and special syntax, and I don't like that...
15:38:56 <Saizan> ah, 5 then, Control.Category..
15:39:26 <Berengal> Control.Category.. is the ultimate in '.' sadness
15:39:31 <dolio> I'm not talking about a (.) declared in multiple places.
15:39:48 <mauke> [1 .. 2]
15:39:59 <Berengal> I'm going to write a module Hmm with a (.) operator in it, so I can go 'Hmm..' in my code
15:40:08 <Cale> Using . as the module path separator was a big mistake
15:40:14 <Cale> I would have preferred |
15:40:23 <temoto> Berengal, :)
15:40:29 <mauke> Cale: too hard to type
15:40:41 <Cale> Nah, how often do you even type qualified names?
15:40:47 <mauke> all the time
15:40:49 <temoto> @remember Berengal I'm going to write a module Hmm with a (.) operator in it, so I can go 'Hmm..' in my code
15:40:50 <lambdabot> It is stored.
15:40:56 <temoto> mauke, python past?
15:40:59 <Twey> Hahaha
15:41:02 <mauke> temoto: no
15:41:07 <Cale> It's only 1.5 keystrokes :)
15:41:09 <Twey> Shame we can't write .. operators
15:41:18 <mauke> how about Names\Like\This\then?
15:41:18 <Cale> (shift only counts for 1/2 :)
15:41:20 <temoto> mauke, Java?
15:41:21 <Twey> Oh, we can make a Hmm.… operator, though
15:41:23 <yrlnry> How do people feel about expressions like   evalState = (fst .) . runState ?   I still find this much harder to understand than the pointful version.
15:41:23 <mauke> no shift
15:41:32 <mauke> temoto: not really
15:41:43 <Loriel> Cale: I feel compelled to make a case for :: instead of either . or |
15:41:46 <Loriel> just because C++ does it!
15:41:53 <Twey> Heh
15:41:56 <Cale> Loriel: :: is type ascription
15:41:58 <temoto> yrlnry, we have @undo bot for that.
15:42:02 <dolio> :: has the same problem as .
15:42:03 <Loriel> Cale: I am sure the parser can cope
15:42:08 <mauke> temoto: no, we have @unpl
15:42:12 <Berengal> yrlnry: That one in specific should be idiomatic enough to recognize, but it does become hard when you have composition sections all over the place
15:42:13 <Cale> That's too ugly.
15:42:21 <temoto> yrlnry, we have @unpl bot for that.
15:42:32 <temoto> sorry, don't know why i said undo
15:42:32 <yrlnry> Berengal:  thanks, that's just the kind of answer I was looking for.
15:42:34 <dolio> Foo::bar :: Foo::Baz
15:42:39 <yrlnry> temoto:  thanks, but that wasn
15:42:41 <mauke> temoto: that's like writing your code in rot13 because we have a bot that can decode it
15:42:42 --- mode: Heffalump set -o Heffalump
15:42:45 <yrlnry> 'wan't really my question.
15:42:54 <Cale> But (.) is composition, and probably the most commonly used infix operator (at least it is in my code). Reusing it for module paths is really irritatingly unreadable.
15:43:17 <Heffalump> no more irritating than using it for fmap :-p
15:43:18 <temoto> No, i pointed that we have @unpl bot so we can read how to write it "normal" way and put that into code.
15:43:19 <soupdragon> um
15:43:20 <Cale> As a consequence, I almost never use qualified names unless absolutely forced to.
15:43:27 <Berengal> Cale: It's better with whitespace. Everything is... but still irritating
15:43:31 <kmc_> fmap is a generalization of compose, isn't it?
15:43:33 <soupdragon> can I tell ghci not to use editline or readline or anything? just plain printf and scanf
15:43:43 <yrlnry> Berengal:  would it be sufficiently idiomatic if it weren't runState and fst?
15:43:48 <mauke> soupdragon: scanf?! are you crazy?
15:43:49 <kmc_> you can probably disable most haskeline features
15:43:54 <yrlnry> say if it were some general f and g with foo = (f . ) . g ?
15:43:55 <Cale> Heffalump: Module path selection doesn't generalise composition.
15:43:59 <soupdragon> I wonder if this readline/editline stuff is what's making it not happen
15:44:01 <mauke> yrlnry: I'd say yes
15:44:05 <yrlnry> Thanks.
15:44:07 <mauke> that pattern is pretty common
15:44:10 <kmc_> module path selection generalizes application, doesn't it?
15:44:12 <Heffalump> it does if you use overloaded strings appropriately ;-)
15:44:14 <Berengal> yrlnry: It's probably be more, since there's evalState and execState for selecting the fst/snd of runState
15:44:17 <Loriel> Maybe we could use … for module path selection as a compromise
15:44:19 <soupdragon> mauke, oh sorry, I meant gets
15:44:22 <kmc_> a module is a dependently typed function from labels to values
15:44:24 <endojelly> I just implemented a very simple, standard type system in Agda, for fun
15:44:28 * mauke kicks soupdragon 
15:44:29 <endojelly>   tapp   : ∀ {Γ e₁ e₂ τ₁ τ₂} → Γ ⊢ e₁ ∷ τ₁ ➛ τ₂ → Γ ⊢ e₂ ∷ τ₁ → Γ ⊢ app e₁ e₂ ∷ τ₂
15:44:36 <endojelly> that's one of the typing rules, the one for application
15:44:52 <temoto> yrlnry, you asked pretty much subjective question. Personally, i just love stuff like head . concat . map ... but if it goes some points near parens, like (f .) g... then it's too complex to read, i'd better write a lambda form.
15:44:53 <soupdragon> I'm doing (sb-ext:run-program "/usr/local/bin/ghci" '() ...)
15:44:56 <Heffalump> are those boxes supposed to be boxes, or is my unicode display messed up again?
15:45:05 <soupdragon> and trying to tell ghci to do stuff, but it's n ot listening
15:45:06 <endojelly> Heffalump, no boxes!
15:45:06 <mauke> soupdragon: I'd try "cat | ghci"
15:45:14 <yrlnry> temoto:  yes, I know it's subjective.  if it were objective I could answer it objectively.
15:45:29 <endojelly> Heffalump, wait, maybe your browser is more forgiving.
15:45:44 <Heffalump> I got unicode working with my IRC client a while ago, so I'm annoyed if it's failed again
15:45:51 <yrlnry> temoto:  thanks for your subjective opinion!
15:45:56 <temoto> Heffalump, weechat?
15:45:59 <Heffalump> irssi
15:46:07 <Heffalump> but I also had to sort out PuTTy and screen.
15:46:23 <mauke> U+2200 (e2 88 80): FOR ALL [∀]; U+0393 (ce 93): GREEK CAPITAL LETTER GAMMA [Γ]; U+03C4 (cf 84): GREEK SMALL LETTER TAU [τ]; U+2081 (e2 82 81): SUBSCRIPT ONE [₁]
15:46:37 <temoto> I had to recompile weechat with libncursesw to get unicode support. Maybe irssi needs that too.
15:46:51 <Heffalump> no, it was working. I probably forgot to run something with the right flag at some point.
15:47:02 <soupdragon> didn't seem to make any difference mauke
15:47:12 <Berengal> yrlnry: Learning to read point-free code is something that comes with practice. After a while, more and more things start to look idiomatic to you as you get better at recognizing things, but ultimately I think it's just rote memorization for given string patterns
15:47:53 <yrlnry> Berengal:  I was trying to gauge where the community draws the subjective line between "idiomatic" and "obfuscated", this week.
15:47:58 <int-e> slices of (.) are ugly though, imo
15:48:01 <temoto> Heffalump, like --could-you-show-unicode-please
15:48:04 <Berengal> yrlnry: Writing point-free, however, is much easier to structure. Once you're able to visualize the dataflow you're able to whip up some pretty horrible code connected only by (.), (<*>) and join
15:48:06 <yrlnry> what's a "slice"?
15:48:27 <int-e> (x +) and (+ x)
15:48:38 <mauke> isn't that a section
15:48:38 <yrlnry> Oh, section.
15:48:41 <solidsnack> int-e: Don't you mean sections?
15:48:42 <Berengal> int-e: ITYM sections
15:48:46 <yrlnry> Heh.
15:48:46 <int-e> thanks
15:48:47 <mauke> FUGUES
15:48:58 <pikhq> Yeah, partially applied (.) is ugly.
15:49:00 <jfoutz> ($ x) is the one that confuses me
15:49:01 <temoto> No, you all wrong, that's burritos.
15:49:02 <CalJohn> point free is overall an interesting thing in terms of "ease of write" and "ease of read"
15:49:08 <solidsnack> LOLz
15:49:14 <mauke> jfoutz: just use (flip id x) instead
15:49:15 <kmc_> :t \f -> (((f.).).)
15:49:17 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => (a -> b) -> f2 (f1 (f a)) -> f2 (f1 (f b))
15:49:33 <CalJohn> i sometimes with emacs had a feature where you could hover over an expression and see it's type, though
15:49:38 <endojelly> Heffalump, http://ejelly.net/Types/Types.html
15:49:46 <Berengal> One thing I've noticed about point-free style is that it's less distracting to write than pointed, because you don't have to worry about variable names and acctidentally shadowing your xs and ys
15:49:52 <tensorpudding> CalJohn: you can, for some expressions
15:50:06 <CalJohn> oh?
15:50:13 <Berengal> Often I'll write something point-free, then transform it into pointed code (with appropriate local bindings) later when it's working
15:50:31 <tensorpudding> for example, open a haskell source file and type id, and in the minibuffer it will show the type
15:50:44 <tensorpudding> the problem is that it doesn't work for things that you define yourself in the source file
15:51:05 <Saizan> it needs more ghc-api for that
15:51:09 <CalJohn> oh right, yeah, emacs does that for a lot of that
15:51:22 <tensorpudding> C-c C-t can do it explicitly
15:51:23 <Heffalump> oh, even my browser reuses to display some of those characters, it just displays the codepoint
15:51:30 <Heffalump> so maybe I just don't have the glyphs or whatever
15:51:45 <kmc_> what's that package providing the interface-independent IDE functions on top of GHC API?
15:51:51 <soupdragon> ummm can I make ghci do a different hting than  show  the results? (i want to use my awesome pretty printer, instead of show)
15:52:09 <kmc_> soupdragon: myAwesomePrettyPrinter (f x)
15:52:15 <soupdragon> otherwise I have to put something like    myawesomeprettyprinter(  ....  )  around the text which is dangerous
15:52:18 <Saizan> kmc_: scion
15:52:19 <kmc_> why is that dangerous
15:52:23 <kmc_> Saizan: thanks
15:52:31 <CalJohn> @src map
15:52:31 <lambdabot> map _ []     = []
15:52:31 <lambdabot> map f (x:xs) = f x : map f xs
15:52:34 <soupdragon> ) ++ "I am an evil hacker" ++ (
15:52:47 <kmc_> soupdragon: oh, you're feeding untrusted code into GHCi??
15:52:52 <kmc_> soupdragon: seems dodgy
15:53:03 <soupdragon> okay the real reason is that it will give bad error messages
15:53:11 <soupdragon> but )( explains why
15:53:37 <kmc_> here's a terrible idea: parse the source first with haskell-src-exts
15:53:53 <soupdragon> that is hard work
15:53:54 <Twey> Why's that terrible?
15:54:01 <kmc_> because it duplicates a lot of work
15:54:05 <kmc_> it's morally terrible
15:54:08 <Twey> Hehe
15:54:12 <kmc_> there should be a way to hand a parsed AST directly to GHC
15:54:15 <soupdragon> ill just myawesomeprettyprinter(  ....  ) and forget about it
15:54:20 <kmc_> but that's not possible without using the hairy internal AST type
15:54:29 <kmc_> soupdragon: did you look at the "hint" package?
15:54:33 <soupdragon> no
15:54:35 <kmc_> might give you a little more control
15:54:36 <kmc_> look it up
15:54:36 <Twey> It creates jobs and keeps the children of Intel employees from starving!
15:54:37 <kmc_> on hackage
15:54:42 <soupdragon> hm that sounds good
15:54:52 <kmc_> you can use hint to eval your string to a Haskell value, then apply your pp to that
15:55:06 <kmc_> instead of doing it syntactically
15:56:04 <lispy> ?hoogle hint
15:56:05 <lambdabot> Network.Socket defaultHints :: AddrInfo
15:56:05 <lambdabot> Data.HashTable hashInt :: Int -> Int32
15:56:05 <lambdabot> Network.Browser QopAuthInt :: Qop
15:56:11 <kmc_> @hackage hint
15:56:11 <lambdabot> http://hackage.haskell.org/package/hint
15:56:25 <kmc_> http://code.haskell.org/hint/devel/examples/ examples here
15:56:51 <Zao> My types are starting to get a bit silly... IORef (Maybe (ForeignPtr C'IDirect3DDevice9))
15:57:00 <kmc_> :O
15:57:33 <Zao> I could use a better way to unwrap that than   readIORef devPtr >>= \m -> when (isJust m) (withForeignPtr (fromJust m) $ \dev -> do ...
15:57:37 <kmc_> data NullablePointerVar a = IORef (Maybe (ForeignPtr a)) ?
15:57:50 <Saizan> s/data/type
15:57:57 <kmc_> err yes
15:57:59 <Zao> Of right, typedefs.
15:58:08 <Zao> Forgot about those.
15:58:10 <kmc_> Zao: that unwrapping is pretty hairy, but you can define it once as a function
15:58:17 <kmc_> higher order imperative programming ftw
15:58:39 <Zao> dedederef p f =    -- heh
15:58:57 <kmc_> also isJust / fromJust seems hackish
15:59:13 <Zao> I'd use maybe, but the default values for ForeignPtr are expensive to construct.
15:59:20 <Zao> (mallocForeignPtr)
15:59:35 <kmc_> then use maybe at a different location
15:59:45 <Zao> And wouldn't make much sense, as I only want to do it if not null.
15:59:53 <Zao> Oh well, this will work and be hidden behind a nice facade.
16:00:03 <kmc_> :t \f -> flip withForeignPtr f
16:00:04 <Saizan> pass actions to maybe, rather than pure values
16:00:05 <lambdabot> Not in scope: `withForeignPtr'
16:00:23 <temoto> @hoogle withForeignPtr
16:00:23 <lambdabot> Foreign.ForeignPtr withForeignPtr :: ForeignPtr a -> (Ptr a -> IO b) -> IO b
16:00:52 <erikc> Zao: you are wrapping directx sdk?
16:00:54 <Zao> There's unfortunately not any nullForeignPtr like there's nullFunPtr and nullPtr.
16:00:58 <temoto> :t \f -> flip Foreign.ForeignPtr.withForeignPtr f
16:00:59 <lambdabot> forall a b. (GHC.Ptr.Ptr a -> IO b) -> GHC.ForeignPtr.ForeignPtr a -> IO b
16:01:00 <erikc> ffi-ing wrather?
16:01:00 <Berengal> It's okay to use partial functions if you can satisfy their contracts no further than five lines away
16:01:02 <Zao> erikc: Yes.
16:01:02 <erikc> rather
16:01:08 <Saizan> maybe (malloc...) (\p -> withForeignPtr p $ \dev -> do...)
16:01:09 <Zao> I've got a triangle drawn :P
16:01:21 <erikc> cool, i did the same for Factor a few weeks ago
16:01:52 <temoto> Zao, why not take Frag code with OpenGL? It's crossplatform.
16:02:05 <Zao> temoto: Because I do not want OpenGL. Period.
16:02:18 <Zao> Nor an discussion about the merits of the libraries.
16:02:33 <Zao> There is no DirectX binding. Thus I will make one.
16:02:35 <temoto> I just asked, take it easy :)
16:02:39 <erikc> Zao: are you doing DX10 too?
16:02:58 <Zao> erikc: I intend to if 9 goes well.
16:03:03 <erikc> awesome
16:03:15 <Zao> erikc: I must mangle the SDK headers then, as mingw doesn't provide anything above the PSDK 9.
16:03:19 <erikc> are you using HDirect to do the COM bindings? or rolled your own?
16:03:20 <mreh> I've got to do random crossover of two chromasomes, but they are permutations, hence list monad would be the perfect way to generate the solutions for crossover, however they need to be done in a random way
16:03:27 <mreh> how can I do random things inside list monad?
16:03:31 <Zao> erikc: bindings-DSL against the C API.
16:03:34 <kmc_> \f r -> readIORef r >>= maybe (return ()) (flip withForeignPtr f)
16:03:40 <kmc_> @pl \f r -> readIORef r >>= maybe (return ()) (flip withForeignPtr f)
16:03:41 <lambdabot> flip ((>>=) . readIORef) . maybe (return ()) . flip withForeignPtr
16:04:04 <temoto> mreh, you could generate permutations and then randomize the list.
16:04:05 <Zao> erikc: With some Perl scripting to generate most of it automagically from headers.
16:04:14 <erikc> oh, i have not seen bindings-DSL, will check it out
16:04:33 <mreh> temoto: that's very inefficient, why not generate the permutations randomly and take the first one?
16:04:34 <Saizan> mreh: maybe ListTDoneRight (State StdGen) ?
16:04:36 <Zao> erikc: I hope to be able to regenerate just about everything from pristine SDK headers.
16:04:41 <Twey> 00:06:21 < Zao> There is no DirectX binding. Thus I will make one.
16:04:42 <kmc_> @unmtl StateT s [a]
16:04:43 <lambdabot> err: `StateT s [a]' is not applied to enough arguments, giving `/\A. s -> [a] (A, s)'
16:04:50 <kmc_> @unmtl StateT s [] a
16:04:51 <lambdabot> s -> [(a, s)]
16:04:52 <Twey> And then someone can write a wrapper over OpenGL/DX.  ;)
16:04:54 <mreh> State StdGen == Rand g?
16:05:02 <Saizan> i think so
16:05:08 <temoto> mreh, because you should be efficient when you need to be efficient. :)
16:05:16 <Saizan> kmc_: when you backtrack there you're going to reuse the same StdGen
16:05:22 <kmc_> yeah
16:05:31 <kmc_> maybe that's what you want
16:05:34 <temoto> mreh, or, you could use unsafePerformIO . random IO
16:05:35 <Zao> Twey: Judging by the high level OpenGL library, it's possible to write some rather elegant abstractions.
16:05:40 <mreh> temoto: the list of possible solutions is too big not to be inefficient
16:05:41 <temoto> randomIO*
16:05:48 <kmc_> do you want forking worlds of random state, or do you want a world of random state which contains forking pure values?
16:06:02 <mreh> kmc_ I don't know what you mean
16:06:13 <erikc> Zao: nice, i did the rather masochistic approach of emacs macro-ing all the dxsdk headers into Factor FFI form, but obviously it's something that will need to be maintained to track the latest headers
16:06:18 <kmc_> those are the two ways that list and randomness monads would compose
16:06:22 <erikc> took like 20 hours
16:06:48 <Zao> erikc: I did IDirect3D9 with regular c2hs first, then manually with bindings-DSL.
16:06:54 <Twey> Zao: *nod* That it is.  I'm interested in what's going to happen with FieldTrip.
16:06:58 <mreh> kmc_ the second
16:07:01 <mreh> I think
16:07:04 <Saizan> oh, for ListTDoneRight i'd probably use LogicT
16:07:04 <Zao> erikc: Then when I saw IDirect3DDevice9, I cried and brought out my vim macros and perl :)
16:07:12 <mreh> it's not the first for sure
16:07:19 <kmc_> mreh: what're you using the list monad nondeterminism for?
16:07:25 <Zao> It has a lovely 119 methods alone.
16:07:36 <mreh> kmc_ calculating all solutions
16:07:57 <kmc_> mreh: but how is there a set of "all" solutions if each one depends on some randomness?
16:08:21 <mreh> it doesn't, the order depends on the randomness
16:08:26 <kmc_> i'm confused
16:08:50 <mreh> kmc_ do you know ox-crossover?
16:08:55 <kmc_> no
16:08:55 <mreh> or order 1 crossover
16:09:06 <kmc_> but i have to go anyway
16:09:09 <kmc_> ttyl
16:09:15 <mreh> thanks anyway
16:12:55 <temoto> mreh, you could also read permutations into Array and walk it randomly.
16:13:22 <mreh> temoto: I completely misunderstood the problem
16:13:26 <mreh> I've solved it now
16:13:30 <temoto> How?
16:14:17 <mreh> the list monady thing is quite deterministic, there is only one solution, I want to use list monad to find it though
16:14:39 <erikc> Zao: http://code.fac9.com/d3d9.factor is an example of the factor ffi, the dx10 factor ones might actually be a faster route to pristine headers for you as i've already cut the cruft
16:15:00 <erikc> i need a dx11 video card
16:15:48 <temoto> mreh, as in `find`?
16:16:12 <mreh> :t find
16:16:13 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
16:16:21 <mreh> @src find
16:16:21 <lambdabot> find p          = listToMaybe . filter p
16:16:34 <temoto> It's a simplest iterative predicate search.
16:16:58 <mreh> temoto: not quite
16:17:16 <temoto> mreh, you don't have a "that's it" predicate?
16:17:17 <Zao> erikc: That FFI layer looks spectacular.
16:17:52 <Zao> erikc: I used the C macros route.
16:19:06 <Zao> erikc: This is the Haskell and C sides of one class - http://codepad.org/O6KmrS9G http://codepad.org/JqpgG0V5
16:19:11 <Zao> Shield your eyes.
16:19:32 <Twey> … PAIN
16:19:44 <Zao> Lots of mangling needed to translate pointers to Ptr, special-case some types from Win32, remove const.
16:22:15 <erikc> nice
16:23:05 <erikc> what is the C side for?
16:23:25 <tensorpudding> that's a wall of text you got there
16:26:58 <largos> is anyone familiar with this type operator: (:~>)  ?
16:35:22 <mm_freak> is there some haskell-supporting text editor suitable for total noobs?
16:35:28 <Twey> emacs?
16:36:09 <mm_freak> suitable for total noobs
16:36:14 <mm_freak> not total programming noobs
16:36:21 <Twey> emacs
16:36:22 <Cale> largos: that would be a type constructor in some library that you're using.
16:36:44 <Twey> You can use it like Notepad.  Arrow keys, backspace, home/end, whole nine yards.
16:36:59 <Twey> When you're ready to stop being a total noob, take half an hour to go through the provided tutorial.
16:37:01 <mm_freak> Twey: except when it comes to saving and opening files
16:37:07 <idnar> file -> save
16:37:16 <mm_freak> hmm
16:37:22 <mm_freak> i forgot that i disabled the menu
16:37:23 <Twey> File -> Open File too tricky for you?
16:37:24 <largos> Cale: ah, thanks!
16:37:26 <mm_freak> indeed, emacs could work
16:37:29 <Twey> Yeah, that would be a problem
16:37:38 <mm_freak> it's not for me
16:37:44 <mm_freak> i use emacs
16:37:51 <Twey> Options -> CUA to enable Notepad-like cut/paste bindings
16:37:59 <Twey> And you're good to go
16:38:42 <erikc> mm_freak: then maybe look at haskell-mode and stick menu items / toolbar items for the common things like 'run selection in ghci'
16:39:26 <mm_freak> yeah…  syntax highlighting will suffice for the start
16:40:01 <Twey> Yeah, install haskell-mode
16:40:18 <Twey> So they get highlighting for .hs files automatically
16:40:24 <mm_freak> looks like i'm going to teach haskell to a newbie
16:40:44 <Twey> Nice!
16:41:24 <mm_freak> that newbie is quite lucky
16:41:33 <mm_freak> i had to unlearn a lot of C/C++
16:41:54 <Twey> Aye
16:41:57 <erikc> it'd be really fun to teach haskell as a first language to high school kids, before they get corrupted
16:42:07 <mm_freak> indeed
16:42:12 <Twey> dibblego had some luck with an eight-year-old, I hear
16:42:22 <erikc> unfortunately in this day and age apparently i need government background checks to talk to some kids in a classroom on a regular basis
16:42:24 <mm_freak> the great thing is:  as soon as someone knows haskell, it's difficult to corrupt him =)
16:42:32 <soupdragon> tomoto?
16:42:45 <soupdragon> temoto*
16:42:59 <Zao> erikc: As everything there are macros, BC_INLINEN generates a C function that invokes the macro.
16:43:15 <erikc> ah i see
16:43:31 <Zao> It's needed for inline functions (which may not have a symbol) and macros.
16:44:03 <soupdragon> why doesn't ghci have a quiet mode :[
16:44:43 <hatds> quiet?
16:44:56 <soupdragon> like not tellingme about loading packages and welcome message and stuff
16:45:02 <hatds> ah
16:45:04 <hatds> yea
16:45:44 <soupdragon> oh man this interface is terrible :(
16:45:45 <temoto> soupdragon, yes?
16:46:33 <Twey> What interface is that?
16:47:00 <soupdragon> temoto, do you know in jquery if there is a good way to have a text box and but it adds stuff above it when there is a reply (like the command line)
16:47:13 <soupdragon> Twey the one I made
16:47:52 <Twey> Huh
16:48:03 <temoto> soupdragon, i'd do it by appending <p> or text to the previous element (the one before textbox)
16:48:21 <Twey> That'd shift down, though
16:48:45 <Twey> CSS makes shifting up hard
16:49:08 <temoto> Command line shifts down, did miss something?
16:49:27 <Twey> No, command-lines stay where they are
16:49:35 <Twey> And the text above them shifts up
16:49:41 <temoto> Ah
16:49:41 <soupdragon> temoto, ill try it!
16:49:56 <soupdragon> up or down is the same thing
16:50:24 <temoto> that's easy, you need to limit the height of uh.. window for uh.. log (the thing where you add new lines after reply)
16:50:46 <temoto> Just like commandline does - it scrolls the history to stay in one place.
16:51:30 <temoto> That's because the height of terminal window is limited. The same could be easily applied in web.
16:52:04 <Twey> Yeah
16:57:21 <bitstream0101> Anyone feel like helping me with my undecidable instance woes? :) http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16766#a16766
17:03:49 * soupdragon wonders what common-lisp for unlines is
17:03:55 <soupdragon> probably something to do with format
17:05:18 <CalJohn> IIRC, there is a package called split
17:05:27 <CalJohn> you just want to split on \n
17:05:56 * CalJohn hates FORMAT
17:06:05 <CalJohn> *hated
17:06:13 * Twey adores it
17:06:30 <soupdragon> :t lines
17:06:31 <lambdabot> String -> [String]
17:06:46 <soupdragon> (format nil "~{~a~%~}" CalJohn)
17:06:47 <Twey> (format nil "~{~a~&~}" I guess
17:07:03 <Twey> Er, plus an extra close-paren
17:07:12 <soupdragon> now I have a working ghci repl inside SLIME
17:07:27 <Twey> We were having a discussion earlier on whether FORMAT is Turing-complete
17:07:50 <temoto> This haskell evening made me start with emacs again, and now the pain is gone, i can learn it! Yay!
17:07:58 <Twey> \o/
17:08:13 <Twey> http://xahlee.org/emacs/ergonomic_emacs_keybinding.html also helps the pain
17:08:34 <temoto> Yeah i was going to remove all double keys.
17:08:56 <temoto> Luckily it has unset-key. Very pity vim doesn't.
17:09:19 <soupdragon> my program currently uses 4 languages
17:09:33 <temoto> soupdragon, HTML and CSS doesn't count.
17:10:18 <Zao> I'm at three: Perl, Haskell, C.
17:10:21 <soupdragon> if you're only counting turing complete ones then it's 4
17:10:39 <Zao> Well, the preprocessor too, maybe :)
17:10:46 <temoto> soupdragon, i only not counting HTML and CSS. :)
17:11:07 <soupdragon> right now I have to figure out this javascript thing which I have been avoiding :(
17:11:30 <temoto> I'll help if you stuck.
17:11:44 <soupdragon> right now it's just $.get("/ghci", function(data) { alert("Data Loaded: " + data); });,  which tells you some random error message
17:12:02 <soupdragon> (I mean a haskell error message about no num instance -- which is what it's supposed to do)
17:12:21 <temoto> Great.
17:12:27 <temoto> isn't it?
17:12:39 <soupdragon> well it's a bit intimidating
17:13:11 <soupdragon> oh I use ocaml too
17:13:13 <soupdragon> so that's 5
17:13:25 <soupdragon> hmmm no that doesn't count
17:13:48 <temoto> Are you trying to put more languages in your program? :)
17:13:58 <dolio> Using Lisp? How are you going to make the transition back to Haskell, where you can't print functions?
17:14:00 <soupdragon> no, I was just surprised when I realized how many I had
17:14:18 <soupdragon> dolio lisp is just for the webserver
17:14:46 <soupdragon> so it is okay I can't print functions
17:15:06 <dolio> There's a guy on comp.lang.haskell complaining that he can't print functions in Haskell.
17:15:14 <soupdragon> oh heh
17:15:16 <dolio> Unlike lisp.
17:15:33 <dobblego> instance Show (a -> b) where show = const "Hi there I am a function!"
17:15:41 <soupdragon> yeah #<FUNCTION LOAD-GHCI>
17:16:14 <Twey> Needs more TH
17:16:24 <dolio> dobblego: Yeah, that's an option. I don't really understand why anyone would want that, though.
17:16:45 <dobblego> dolio, that's the point really innit?
17:16:58 <dolio> His argument seems to be that he feels upset when he types a function on the GHCi prompt and it spits an error back at him.
17:17:07 <dolio> Instead of a useless string.
17:17:10 <kmc> you can define a show instance for functions...
17:17:13 <kmc> even a somewhat useful one
17:17:15 <lament> dolio: It upsets me, too
17:17:16 <soupdragon> > not . not . not
17:17:17 <lambdabot>   {True->False;False->True}
17:17:39 <soupdragon> > \(f::Bool -> Bool) -> f . f . f
17:17:40 <lambdabot>   {True->True;False->True}->
17:17:40 <lambdabot>    {True->True;False->True}
17:17:40 <lambdabot>  {True->True;False->...
17:17:49 <soupdragon> oh very nice I can prove theorems in haskell
17:18:12 <lament> dolio: i'd love to see something like "<FUNCTION::foo->bar>" instead... it's just... more friendly
17:18:54 <dolio> I guess ghci could do that.
17:19:33 <temoto> > not
17:19:34 <lambdabot>   {True->False;False->True}
17:19:38 <temoto> is this quickcheck?
17:19:49 <xerox> smallcheck I think
17:19:50 <soupdragon> temoto, but I don't want to just bore you with these questions :)
17:20:11 <temoto> soupdragon, are you a male?
17:20:23 <dolio> In general, I think it'd be bad to add a Show instance for functions, since trying to print one is going to be a mistake 99% of the time, and not having a Show instance catches the mistake during compilation, instead of your program mysteriously printing <FUNCTION> at some point in the future.
17:20:41 <kmc> dolio, yes.  but it might be nice to enable it for GHCi only
17:20:47 <kmc> i don't think it's a big deal either way
17:21:20 <kmc> GHCi could just print internal information about unshowable values
17:21:25 <kmc> as the debugger does
17:21:53 <temoto> Emacs users out there, how is that function called to expand ~ in file paths?
17:24:01 <Twey> temoto: expand-file-name
17:24:23 <temoto> Twey, thank you.
17:39:20 <Zao> What would be a suitable name for  (NullableForeignPtr a -> (Ptr a -> IO b) -> IO ())? Where NullableForeignPtr a = Maybe (ForeignPtr a).
17:39:57 <Zao> withOmgWtfBbq_?
17:40:00 <andrewe> @src fix
17:40:01 <lambdabot> fix f = let x = f x in x
17:40:05 <c_wraith> IO b rather than IO () ?
17:40:15 <Zao> c_wraith: I intentionally want to discard the result.
17:40:20 <c_wraith> ah
17:40:43 <c_wraith> I guess the result would need to be IO (Maybe b) if you weren't
17:41:04 <hatds> withNullablePtr_ or something/
17:41:06 <hatds> ?
17:41:24 <c_wraith> I'd name it some sort of apply, probably
17:44:08 <hatds> "withForeignPtr :: ForeignPtr a -> (Ptr a -> IO b) -> IO b"  is already in the FFI
17:45:19 <Zao> hatds: Yes, I use that inside. This is to get through the Maybe and discard the result.
17:46:02 <hatds> so call it withNullable :)
18:12:42 <Zao> Ooh, stealth semantics change.
18:12:52 <gwern> ?
18:13:01 <Zao> Foreign.ForeignPtr.newForeignPtr guarantees that the finalizer runs before the program exits.
18:13:19 <Zao> Foreign.Concurrent.newForeignPtr doesn't guarantee that and mandates that it runs in a separate thread.
18:13:35 <Zao> The former being inconvenient and the latter completely unacceptable :(
18:15:31 <kmc> you don't want the finalizer to run at all?
18:16:17 <Zao> kmc: Optimally I want the finalizer to be guaranteed to run on the "main" thread.
18:16:43 <Zao> I can survive if it's not called, but it should not be called on a separate thread.
18:18:18 <kmc> do you mean a Haskell thread, or an OS thread?
18:18:28 <kmc> (i'm assuming you're using GHC)
18:18:36 <Zao> OS thread, and yes, GHC.
18:19:26 <Zao> I suppose I should look at gtk2hs and see how they solved it.
18:19:35 <Zao> I believe they suffered from similiar problems wrapping GTK2.
18:20:00 <kmc> yeah, gtk2hs has a function for sending an IO action over to the "main" thread to be executed
18:20:09 <kmc> perhaps you'd like to do the same
18:20:53 <kmc> also my 6.10 docs say of Foreign.ForeignPtr "Indeed, there is no guarantee that the finalizer is executed at all; a program may exit with finalizers outstanding."
18:21:14 <Zao> http://www.haskell.org/ghc/docs/6.12.1/html/libraries/base-4.2.0.0/Foreign-ForeignPtr.html#v%3AnewForeignPtr
18:21:29 <kmc> ah, so they strengthened the guarantee for 6.12
18:21:30 <kmc> interesting
18:22:31 <kmc> so you have some library you want to FFI-call which requires that everything come from one OS thread?
18:22:43 <Zao> Yeah.
18:23:13 <kmc> seems desirable then to send actions to a single Haskell thread which is bound to an OS thread, i.e. with forkOS
18:23:37 <Zao> Direct3D, much like Win32, mandates thread affinity.
18:29:07 <ido> kmc: hey
18:29:15 <ido> kmc: are you around?
18:30:01 <kmc> yeah
18:30:02 <kmc> pm?
18:30:30 <ido> go home
18:31:10 <kmc> go to bed frosh, ditch day's tomorrow
18:34:17 <copumpkin> o.O
18:34:28 <copumpkin> you in a frat together or something? :P
18:34:28 * soupdragon ANGRY about String
18:34:42 <soupdragon> String vs [Char] in terms of instances
18:34:43 <copumpkin> there, there
18:35:05 <copumpkin> like what?
18:35:26 <syntaxglitch> soupdragon, no such thing as String, it's really just [Char] wearing those silly disguise glasses with a fake mustache
18:35:44 <syntaxglitch> don't let it fool you
18:35:50 <soupdragon> syntaxglitch yeah but check this out
18:35:54 <soupdragon> > ['a','b','c']
18:35:55 <lambdabot>   "abc"
18:36:23 <syntaxglitch> yep, it's a [Char] alright
18:36:24 <soupdragon> this is a problem for me defining my own Show like thing
18:36:36 <copumpkin> it's a nasty hack
18:36:51 <syntaxglitch> note that there's a special "show" function for lists of things that [Char] uses to make it look like a string
18:37:07 <copumpkin> yeah, I hate it :P
18:37:17 <Twey> There are cleverer ways of dealing with that these days
18:38:05 <kmc> @type showList
18:38:06 <lambdabot> forall a. (Show a) => [a] -> String -> String
18:38:19 <kmc> what are the cleverer ways?
18:38:39 <Twey> TypeSynonymInstances, for example
18:38:42 <copumpkin> OverlappingInstances!
18:38:56 <copumpkin> (is what you'd need)
18:39:09 <soupdragon> > showList "x"
18:39:10 <lambdabot>   ""->
18:39:10 <lambdabot>    "\"x\""
18:39:10 <lambdabot>  "a"->
18:39:10 <lambdabot>    "\"x\"a"
18:39:10 <lambdabot>  "aa"->
18:39:12 <lambdabot> [3 @more lines]
18:39:20 <soupdragon> > showList ["x"] []
18:39:20 <lambdabot>   "[\"x\"]"
18:39:32 <dolio> I think showList is probably the better solution.
18:39:40 <dolio> OverlappingInstances are dubious.
18:39:40 <Twey> copumpkin: Really?  TypeSynonymInstances wouldn't cut it?
18:39:51 <soupdragon> I basically need to re-implement show
18:40:01 <syntaxglitch> I'd be tempted to say that the problem is that the default string type is a character list in the first place
18:40:08 <copumpkin> Twey: that would allow you to use a type synonym in an instance header, but the fact that this particular one overlaps with the Show a => [a] is another issue
18:40:17 <Twey> Ahh, right
18:40:23 <syntaxglitch> O(n) concatenation isn't something I like in a string data structure
18:40:30 <Twey> Hm
18:40:58 <Twey> :t showList
18:41:00 <lambdabot> forall a. (Show a) => [a] -> String -> String
18:41:05 <syntaxglitch> given how often indexing and concatenation are desired for strings, a list is really rather suboptimal
18:41:07 <Twey> instance Show a => Show [a] where show = showList?
18:41:13 <c_wraith> I've finally got around to reading Chris Okasaki's paper on functional data structures.  It's actually quite excellent
18:41:19 <Twey> syntaxglitch: That's why we have bytestrings
18:41:25 <Twey> c_wraith: *nod*
18:41:29 <Zao> And Data.Text
18:41:38 <kmc> syntaxglitch, it's conceptually nicer this way, and we have faster alternatives
18:41:50 <kmc> the default should be simple, not fast
18:42:07 <Twey> Ooh, yes, Data.Text now
18:42:16 * Twey needs to learn to use that
18:42:19 <theorbtwo> kmc: I tend to think that it should be simple from the user's point of view, and fast.
18:42:33 <dolio> Byte strings are actually O(n) concatenation.
18:42:34 <kmc> given that Haskell was originally a research language for experimenting with lazy programming, it makes sense to choose the laziest datastructure as your default
18:42:59 <kmc> theorbtwo, sure, ideally
18:43:21 <syntaxglitch> kmc, yeah, I see why it's the way it is
18:43:47 <soupdragon> why not have isString :: a -> Bool
18:43:50 <kmc> anyway, it's not a very sticky default.  string literals are overloadable these days
18:44:09 <theorbtwo> Oh!
18:44:25 <theorbtwo> That's good, and surprising.  (To me, anyway.)
18:44:30 <kmc> soupdragon, it'd break the idea of parametric polymorphism
18:44:39 <syntaxglitch> kmc, the problem is it becomes one of those things where people new to the language have to be taught that doing things the obvious way is a bad idea except for simple stuff
18:44:44 <kmc> theorbtwo, they're overloadable the same way numeric literals like "3" are.  ghc extension
18:45:03 <Twey> "3" isn't a numeric literal!  *hides*
18:45:11 <kmc> syntaxglitch, yeah.  though i'll substitute "obvious" for "simple"; i'm not sure bytestrings are less simple once you know to use them
18:45:12 <c_wraith> I didn't think you needed an extension for numeric literals.
18:45:18 <kmc> you don't
18:45:22 <kmc> you need one for overloaded string literals
18:45:40 <Twey> soupdragon: How could you write ‘isString’?
18:45:43 <c_wraith> ok, just making sure.  your statement was ambiguous, and I haven't actually implemented Num in an interesting way.
18:45:56 <kmc> Twey, compiler magic, presumably
18:46:06 <kmc> you can write isString :: (Typeable a) => a -> Bool
18:46:08 <syntaxglitch> kmc, I meant simple in the sense of "for aimless hacking and experimenting", where the suboptimality of [Char] isn't really a big deal
18:46:10 <soupdragon> isString _ = True
18:46:14 <soupdragon> for String instaec
18:46:20 <soupdragon> otherwise isString _ = False
18:46:26 <kmc> soupdragon, instance of which class?
18:46:27 <soupdragon> in all the other instances (default setting)
18:46:39 <c_wraith> soupdragon: that doesn't sound like something haskell's type system would allow
18:46:50 <kmc> it allows it, if isString is in a typeclass
18:46:54 <soupdragon> okay you are right
18:46:58 <soupdragon> we need to define  isChar
18:47:00 <kmc> this is precisely the sort of ad-hoc polymorphism that typeclasses capture
18:47:06 <c_wraith> and then if everything in the world implements isString
18:47:11 <soupdragon> then in the [a] instance you can ask if a is a char
18:47:16 <Twey> …
18:47:28 <Twey> soupdragon: You'd have to define everything in terms of Data.Dynamic for that to work
18:47:34 <soupdragon> no dynmaic
18:47:36 <kmc> no, Data.Typeable should be enough
18:47:39 <kmc> class IsChar a where { isChar :: a -> Bool }; instance IsChar Char where { isChar _ = True }; instance IsChar a where { isChar _ = False }
18:47:43 <kmc> those are overlapping instances
18:47:53 <kmc> i don't see why that's better than the more straightforward overlapping instances solution
18:48:08 <kmc> instance Show [Char] where ...; instance Show [a] where ...
18:48:18 <kmc> GHC will handle both of these fine
18:48:21 <kmc> but it's not H98
18:49:30 <Alpounet> it reminds me of template specialization
18:49:35 <kmc> yup
18:49:51 <kmc> (insert here 20 minute argument about C++)
18:49:57 <Alpounet> kmc, no need
18:50:02 <Alpounet> just drawing a parallel
18:50:10 <kmc> :)
18:50:39 <syntaxglitch> C++ templates, the world's most successful pure functional language
18:50:42 <soupdragon> hehe
18:50:44 <soupdragon> I can't use Bool :)
18:50:51 <SamB_XP> successful how ?
18:50:58 <medfly> I guess because C++ is popular
18:51:55 <nus> sucksassfull
18:52:15 <nus> pardon my french
18:52:36 <soupdragon> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16768
18:52:42 <theorbtwo> Yeah, freenode is having a *wonderful* time lately.
18:52:52 <soupdragon> using a GADT instead of Bool, for a type coercion
18:52:59 <soupdragon> data IsChar a where
18:52:59 <soupdragon>  Is :: IsChar Char
18:52:59 <soupdragon>  Isnt :: IsChar not
18:53:17 <soupdragon> so IsChar a <=> Equal Char a
18:53:32 <soupdragon> and that lets you write this ad-hoc-ad-hoc polymorphism
18:53:35 <kmc> ah, clever
18:54:06 <kmc> you can create (Isnt :: IsChar Char)
18:54:10 <kmc> is that a problem?
18:54:11 <c_wraith> yes
18:54:28 <soupdragon> kmc, no
18:54:42 <soupdragon> Isnt doesn't give you evidence for anything
18:55:14 <soupdragon> the variable in the case of  Isnt :: IsChar not,  means that pattern match specialization doesn't
18:55:38 <soupdragon> it's just a white lie
18:55:55 <aluink> what has been the current audience'
18:56:28 <aluink> what has been the current audience's experience, putting the type declarations right about the function, or putting them all together at the top of the module?
18:56:38 <aluink> above*
18:56:45 <kmc> above which function?
18:56:58 <aluink> functions in my haskell files
18:57:04 <theorbtwo> I've always seen just above the function, but my exposure isn't that broad.
18:57:07 <kmc> one type might be used by many functions
18:57:14 <theorbtwo> kmc: The function being typed.
18:57:16 <kmc> oh, did you mean type declaration or type signature?
18:57:30 <kmc> i'll only put type signatures right above the thing being typed
18:57:32 <aluink> uhh, i'm unfamiliar with the difference
18:57:33 <theorbtwo> foo :: Int -> Int; foo a = a + 1
18:57:53 <kmc> by "type declaration" i initially thought you meant using the keyword "type", "newtype", or "data"
18:58:06 <kmc> (btw, the thing being typed needn't be a function)
18:58:06 <theorbtwo> That's a type signature.  A type declaration is something that creates a new type.
18:58:07 <aluink> oh...yeah, sorry, i'm refering to signatures
18:58:18 <kmc> yeah, i'd put the signature right above its respective binding
18:58:23 <aluink> i knew that
18:58:28 * aluink facepalms
18:58:31 <kmc> occasionally you have many similar bindings with the same type, in which case you might want to say a,b,c :: t
18:58:34 <kmc> but i use that only rarely
18:58:50 <aluink> oh, i didn't know that syntax was available
18:59:09 <kmc> > let a,b :: Int; a = 2; b = 3 in a + b
18:59:10 <lambdabot>   5
18:59:11 <theorbtwo> Neither did I.
18:59:52 <Twey> I usually use it with list-bindings
19:00:42 <Twey> foo, bar, baz :: SomeType; [foo, bar, baz] = map someOperation [quux, fireman, arthur]
19:01:09 <kmc> hmm, that's interesting
19:01:24 <aluink> ooohh! that's cool, i need to play with that
19:01:38 <kmc> it's rare to see pattern bindings used to define CAFs
19:01:45 <kmc> but that's a good use of it
19:01:48 <theorbtwo> CAFs?
19:02:19 <kmc> constant applicative form
19:02:24 <kmc> not sure i'm using the term entirely correctly
19:02:32 <kmc> i mean something bound at top level which is not a function
19:02:41 <theorbtwo> Ah.
19:02:47 <kmc> or perhaps (in STG machine terminology) which is an updatable closure
19:02:53 <kmc> though, in this case, foo, bar, and baz might be functions
19:03:13 <hatds> and indeed, they might not be toplevel
19:03:48 <theorbtwo> It's rather the point of first-class functions -- until you try to call something, it doesn't much matter if it's a function or not.
19:04:11 <soupdragon> anyway
19:15:30 <Alpounet> haha
19:15:33 <Alpounet> harrop stroke again
19:17:47 <mm_freak> harrop is quite an annoying guy
19:18:13 <Twey> What did he do this time?
19:19:20 <mm_freak> dunno, i stopped reading his rants
19:19:33 <kamatsu> hm?
19:19:37 <kamatsu> who's harrop?
19:19:48 <kamatsu> the guy that bitched about monads and went back to ML?
19:19:53 <kamatsu> cos he annoyed me
19:20:04 <mm_freak> jon harrop, haskell enemy #1 =)
19:20:26 <Alpounet> Twey, http://flyingfrogblog.blogspot.com/2010/01/naive-parallelism-with-hlvm.html
19:21:25 <syntaxglitch> the unfortunate part is that harrop seems like he's probably actually a really sharp guy, when he's not going off on crazy tirades about whatever it is he currently dislikes
19:21:31 <kamatsu> how can you argue with him?
19:21:41 <kamatsu> it doesn't look like he's wrong, haskell appears slower
19:22:05 <dibblego> harrop is extremely dishonest -- do not try to "argue" with him
19:22:10 <dmwit> Haskel... 5?
19:22:26 <kamatsu> so, haskell is faster than HLVM?
19:22:27 <dmwit> Also: I can argue with him by way of he didn't release any of the code.
19:22:33 <kamatsu> ah, good point
19:22:47 <dibblego> of course not; he hasn't written a line of Haskell in his life
19:22:49 <kmc> the part where he works for a company whose mission is to plug languages similar to but in competition with Haskell is a bit of a tell
19:22:52 <syntaxglitch> kamatsu, I'm pretty sure with a bit of effort I could produce some benchmarks that will make any language you want appear slower
19:23:01 <kamatsu> syntaxglitch: right
19:23:08 <mm_freak> dibblego: well, he has, but not enough to judge
19:23:20 <kamatsu> I thought you were talking about this guy
19:23:22 <kamatsu> http://lambda-diode.com/programming/monads-are-a-class-of-hard-drugs
19:23:23 <medfly> kmc, there are companies that pay people to do that?
19:23:31 <dibblego> mm_freak, I used to think he may have written 3 or 4, but I even have my doubts about that
19:23:58 <mm_freak> he dislikes purity and laziness
19:24:01 <mm_freak> and that's about it
19:24:14 <dibblego> he masquerades that position
19:24:14 <mm_freak> he hates haskell's semantics, because he finds them unpredictable
19:24:26 <kmc> that's a valid criticism though
19:24:30 <syntaxglitch> I don't think he actually has reasons, really
19:24:31 <dibblego> how can he, when he has never used haskell?
19:24:37 <kmc> it sounds like he pursues it beyond validity
19:24:50 <syntaxglitch> he seems like the kind of person who pretty arbitrary decides he hates something, then goes looking for reasons
19:24:58 <flippo> If he dislikes laziness, then of course he'll stay with ML
19:25:02 <mm_freak> yes, haskell semantics are more difficult to follow
19:25:05 <dibblego> it's a valid criticism when supported by evidence, but that is never forthcoming
19:25:11 <mm_freak> but that doesn't make code _unpredictable_
19:25:15 <kmc> haskell semantics are pretty simple if you don't care about performance
19:25:23 <kmc> because of church-rosser or whatever
19:25:39 <Twey> « Monads are a typing trick to ensure proper linear usage of some updateable resource in a functional language. A very neat idea, indeed. »
19:25:44 <Twey> Wut
19:25:47 <mm_freak> the problem is that when you try to argue with him, he always comes up with some challenge
19:25:56 <SamB_XP> Twey: well, IO is
19:26:02 <mm_freak> "see, my ocaml code is fast…  write equivalently fast code in haskell, come on!"
19:26:07 <kmc> "monads are just tags on functions" is a normal stage in understanding monads
19:26:08 <SamB_XP> Twey: in effect
19:26:10 <kmc> but is not really correct
19:26:10 <kamatsu> Twey: yeah, but he's still wrong
19:26:13 <nainaide> Use cabal to install package one by one is a hard work, any simple way ?
19:26:16 <mm_freak> then you tell him:  "i have better things to do"
19:26:23 <Twey> nainaide: cabal-install
19:26:23 <kmc> nainaide, a loop in your shell?
19:26:36 <mm_freak> and he goes like:  "yeah, because it's impossible, take it or die"
19:26:51 <Twey> SamB_XP: Yeah.  IO is.  Monads aren't.  :-\
19:27:04 <SamB_XP> Twey:
19:27:06 <Twey> Well, even so, it's not really a ‘typing trick’
19:27:13 <kmc> it sort of is, for IO
19:27:16 <SamB_XP> I mean, IO isn't even just that, abstractly
19:27:16 <kmc> in GHC's implementation
19:27:35 <SamB_XP> that's just the way it's implemented in existing compilers, yes
19:27:48 <nainaide> Any difference between cabal-install and cabal?
19:27:52 <dmwit> Hm, what is the updateable resource in the list monad?
19:27:54 <kmc> nainaide, cabal is a library
19:27:59 <SamB_XP> you could also implement it by simulating the universe in which the semantics are supposed to be carried out ;-P
19:28:01 <kmc> cabal-install is a package that provides an executable named cabal
19:28:01 <mm_freak> well…  there should be a better beginner's explanation of monads, which doesn't make them look like making I/O possible in haskell
19:28:21 <kmc> mm_freak, indeed
19:28:25 <Twey> There are many, mm_freak
19:28:26 <aavogt> making IO sane?
19:28:35 <kmc> we have a lot of the opposite, tutorials which attempt to explain IO without reference to monad concepts
19:28:39 <kmc> which is also important
19:28:39 <kamatsu> I think monads should be tought without IO
19:28:53 <kamatsu> and then teach IO monad as the "C Program" monad
19:28:53 <kmc> IO is a bad example of a monad
19:28:55 <SamB_XP> aavogt: I *knew* that pre-monadic IO framework was good for *something*!
19:29:00 <nainaide> well, I use to haskell overlay in Gentoo,  but recently I found something missing and old
19:29:02 <mm_freak> yeah
19:29:05 <Philonous> Well, isn't IO the reason we have monads in the first place?
19:29:08 <mm_freak> IO is about the most uninteresting monad of all
19:29:16 <mm_freak> only the identity monad is less interesting
19:29:16 <Twey> You can teach IO as a Functor
19:29:16 <kmc> i think IO is an interesting but atypical monad
19:29:20 <dibblego> Monads should be correlated to IO like Java should be correlated to programming; once the student is very well equipped
19:29:29 <SamB_XP> Philonous: isn't laziness the reason we have purity ?
19:29:37 <flippo> Which paper would this be?  "...the original paper on monads is actually quite easy to understand and fun to read."
19:29:44 <mm_freak> when explaining monads, i start with Maybe
19:29:59 <kamatsu> flippo: indeed, cos he got the whole thing completely wrong
19:30:00 <aavogt> SamB_XP: IO is way easier as a monad than as a lazy function
19:30:02 <mm_freak> i think it's the simplest nontrivial monad
19:30:11 <kmc> yeah
19:30:11 <flippo> kamatsu, oops!
19:30:13 <aavogt> you should start with the trivial monad
19:30:29 <kamatsu> I like "You could have invented monads", I can't remember who wrote it sigfpe?
19:30:31 <mm_freak> aavogt: most people need something useful
19:30:39 <aavogt> "see, it does nothing... nothing to see here, move along"
19:30:39 <flippo> I would prefer to see State explained clearly.  The implications are more impressive.  But no one begins with State.
19:30:40 <syntaxglitch> Start with the continuation monad, instead
19:30:42 <kmc> parametricity on "return" guarantees injectivity
19:30:45 <syntaxglitch> And explain continuations first
19:30:47 <kmc> Maybe adds a single additional value
19:30:52 <mm_freak> if you start with the identity monad, they go like "so what?!" and walk away
19:30:55 <SamB_XP> aavogt: I know that, but just because we got something for reason A doesn't make reason A a good example of why the thing is good!
19:30:57 <syntaxglitch> And then, after they understand continuations, everything else will seem easy
19:31:08 <kmc> i think a good example of why monads are good, rather than simply a workaround for purity, is STM
19:31:11 <kmc> also Parsec
19:31:13 <SamB_XP> syntaxglitch: nah
19:31:16 <kmc> these are "real world" examples
19:31:19 <kmc> not simple conceptual ones
19:31:27 <SamB_XP> syntaxglitch: we already have enough brains to scrub out of the carpet in here as it is!
19:31:28 <mm_freak> flippo: because State is not that easy to teach without a foundation
19:31:33 <kamatsu> any state machine is nicely encoded monadically
19:31:33 <joed> flippo: You traitor...
19:31:34 <kmc> and yes, most Parsec code could be applicative
19:31:36 <aavogt> I'm saying, you don't need Maybe as a monad as much as you need IO
19:31:46 <aavogt> in terms of the pain it saves
19:31:58 <SamB_XP> aavogt: oh yes you do!
19:31:59 <mm_freak> IMO Maybe is the best monad to begin explaining the concept
19:32:00 <syntaxglitch> if you want to explain how monads are put together, State is actually pretty easy to derive from base principles
19:32:03 <flippo> joed, hyprocrite, phoney!
19:32:12 <kamatsu> i've used Maybe as a monad maybe four times, but every time my code would have been _awful_ without it
19:32:25 <kmc> let's start with the Cont monad
19:32:29 <kmc> or Oleg's universal monad
19:32:34 <SamB_XP> aavogt: I mean, where applicable, it's every bit as applicable!
19:32:35 <syntaxglitch> kmc, that's what I said!
19:32:43 <mm_freak> btw, what i also hate about most monad introductions
19:32:43 <kmc> syntaxglitch, ha, so it is
19:32:45 <joed> flippo: Hey, we need to plan a family dinner, my doggie likes old bones.
19:32:50 * joed ducks.
19:32:54 <kmc> i think we talk about monads too much
19:32:54 <mm_freak> they all subtly tell you that it's better to avoid monads
19:33:03 <mm_freak> well, 90% of my code is monadic
19:33:06 <mm_freak> and that's great
19:33:11 <kmc> they are not nearly as complicated as the hype would suggest
19:33:24 <SamB_XP> it is only better to avoid one-way mondads ;-P
19:33:28 <kmc> mm_freak, yeah, i dislike all the moralizing about "purity" and such
19:33:36 <mm_freak> indeed
19:33:46 <aavogt> SamB_XP: applicable?
19:33:47 <kmc> sometimes a problem is inherently imperative, in those cases we should be proud of Haskell's support for imperative programming
19:33:51 <kmc> rather than disparaging the problem
19:34:05 <SamB_XP> aavogt: that is, where they help at all, they help a whole lot!
19:34:06 <aavogt> kmc: FRP???
19:34:10 <kmc> aavogt, hehe
19:34:11 <mm_freak> haskell has a wonderful RTS with wonderful concurrency support and wonderful abstractions
19:34:12 <SamB_XP> the Maybe monad stuff
19:34:15 <mm_freak> so use them!
19:34:43 <kmc> and also, aside from the magically implemented ones (ST, STM, IO) it's not fair to call monadic code in general "impure"
19:34:45 <SamB_XP> mm_freak: still, you should avoid gratuitous IO in your code!
19:34:48 <kamatsu> yeah, I found it odd that the monads-are-hard-drugs guy was criticizing monads in haskell because you use them alot
19:34:55 <mm_freak> SamB_XP: that's a different matter
19:35:19 <SamB_XP> (and STM, of course ;-P)
19:35:21 * syntaxglitch suggests that MonadError doesn't get enough love
19:35:52 <SamB_XP> syntaxglitch: hey, I'd never write a compiler without it!
19:36:06 <mm_freak> hmm
19:36:11 <mm_freak> do we really need it?
19:36:17 <dmwit> I think what we need is a monad *demonstration*, not a monad tutorial.
19:36:34 <mm_freak> most things can be encoded nicely without MonadError
19:36:47 <aavogt> SamB_XP: I dunno, with Maybe there's not much you can do wrong if you naively use case... while using interact instead of IO means you often fail to introduce data dependencies that IO takes care of in order to produce output at the correct time
19:36:53 <mm_freak> there are ContT, MaybeT and ListT
19:37:10 <SamB_XP> aavogt: okay, maybe I overstated the case a bit ..
19:37:11 <mm_freak> (assuming a correct implementation of ListT)
19:37:14 <aavogt> but maybe I'm just better at avoiding Maybe than IO
19:37:15 <kmc> mtl's callCC is insufficiently polymorphic
19:37:28 <mm_freak> kmc: look at monadLib
19:37:37 <mm_freak> you don't need callCC at all there
19:37:42 <SamB_XP> but it's a lot better of an example of what a Monad is like
19:38:00 <SamB_XP> because it's not one of those magic box monads
19:38:08 <mm_freak> kmc: runContT return . forever $ abort () >> inBase (putStrLn "Never reached")
19:38:25 <kmc> mm_freak, it does have callCC though, with the same type
19:38:30 <mm_freak> yes
19:38:46 <mm_freak> but have you ever used it for anything else than escaping into a higher context? =)
19:39:03 <kmc> seems like abort calls the continuation of an "implicit" callCC around the whole context
19:39:04 <kmc> anyway
19:39:09 <kmc> yes, i have, but only in somewhat contrived cases
19:39:18 <kmc> i haven't used continuations much in Haskell, at all
19:39:31 <mm_freak> yeah
19:39:44 <kmc> laziness is a nicer way to build coroutines
19:39:50 <mm_freak> there are StateT and ChoiceT, which cover 99% of all use cases
19:40:01 <kmc> i was very happy the day i realized that lists are more like control flow structures than data structures
19:40:20 <SamB_XP> kmc: yes, I love that
19:40:22 <mm_freak> yeah
19:40:31 <SamB_XP> no more awkward xrange for me!
19:40:34 <aavogt> SamB_XP: hmm, I guess it's a conflict between abstract and very useful (IO), and concrete (thus showing how much boilerplate is being avoided) (Maybe)
19:40:39 <mm_freak> do x <- pure 2 <|> pure 3; inBase $ print x
19:40:40 <mm_freak> =)
19:40:51 <mm_freak> ChoiceT <3
19:41:00 <SamB_XP> aavogt: no, it definitely shows how much boilerplate is being avoided!
19:41:17 <kamatsu> in my opinion, the absolute worst part of haskell is the record system
19:41:27 <aavogt> agreed, kamatsu
19:41:28 <mm_freak> kamatsu: i agree
19:41:32 <SamB_XP> and it also is a lot more like the other monads people will see
19:41:34 <aavogt> you have alternatives though
19:41:43 <SamB_XP> aavogt: not really!
19:41:49 <mm_freak> aavogt: like what?
19:41:51 <SamB_XP> nobody implemented any of them!
19:41:54 <kamatsu> i just read the type-level strings article on reddit to get record selector pruning
19:41:57 <mm_freak> (don't even mention template haskell…)
19:42:00 <kamatsu> why must we hack this so much
19:42:18 <SamB_XP> kamatsu: O_o
19:42:24 <aavogt> mm_freak: you've seen HList?
19:42:31 <kamatsu> SamB_XP: http://greayer.wordpress.com/2010/01/28/record-selector-punning-with-type-level-strings-2/
19:42:32 <SamB_XP> that's deep bantha doo-doo, there!
19:42:32 <mm_freak> aavogt: nope
19:42:41 <aavogt> there's a pretty reasonable record system there, no template haskell in sight
19:43:00 <mm_freak> actually i started using type-level stuff to encode the length of lists
19:43:10 <mm_freak> that's quite useful sometimes
19:43:22 <aavogt> though perhaps the other ones which define proper setters and getters with TH might be easier to pick up
19:43:43 <kamatsu> aavogt: where can i find a HList example?
19:43:52 <aavogt> @where hlist
19:43:53 <lambdabot> http://homepages.cwi.nl/~ralf/HList
19:44:01 <aavogt> the paper :)
19:45:13 <kmc> seems like TH is a relatively lightweight way to add extensions to GHC
19:45:48 <kmc> and so we shouldn't object to *using* TH libraries on these grounds, when we'll gladly enable -XMultiParameterImplicitUnboxedFlexibleTypeSynonymInstanceFamilies
19:46:12 <kamatsu> i just think TH feels ugly and i dislike its use
19:46:40 <mm_freak> i don't care when my library uses it
19:46:45 <mm_freak> but i don't want to use it myself
19:47:04 <kmc> but does merely calling a library's declaration-generator count as "using it"?
19:47:40 * syntaxglitch enables -XImaginaryParameterDemicoherentUnboxedReboxedTiedWithARibbonTypeAntonymUninstances
19:47:57 * pikhq enables -XInfiniteTape
19:48:02 <kamatsu> hahaha
19:48:05 <kmc> -XDoWhatIMean
19:48:14 <syntaxglitch> -XHaltingOracle
19:48:30 <medfly> hehe
19:49:00 <Axman6> -XDeriveWhatIWant
19:49:12 <mm_freak> you don't want a tape in haskell
19:49:14 <Gracenotes> forget halting oracles, when are we going to get support for true nondeterminism?
19:49:15 <mm_freak> -XFixId
19:49:33 <kamatsu> ah, actualy, the worst idea for an extension that people will use and we will constantly tell people never to use it:
19:49:37 <kamatsu> -XDisableTypeChecking
19:50:34 <mm_freak> i wish there would be some limited support for dynamic type inference
19:50:53 <syntaxglitch> dynamic inference in what sense?
19:50:54 <mm_freak> or a smarter type checker
19:50:54 <medfly> hahaha
19:51:03 <kmc> implicit insertion of fromDynamic / toDynamic ?
19:51:05 <mm_freak> syntaxglitch: wait, i'll code an example
19:51:42 <Gracenotes> dynamic type inference is just dynamic dispatch, though
19:52:04 <Gracenotes> at least if I understand both to mean runtime
19:53:56 <syntaxglitch> while we're complaining, I'd like a way to make anything that could error (e.g., pattern match failure) be a compile-time error
19:54:32 <aavogt> the compiler can infer incomplete patterns
19:54:48 <syntaxglitch> I don't think there's any way to do that in, general though
19:55:06 <aavogt> @where catch
19:55:06 <lambdabot> http://community.haskell.org/~ndm/catch/
19:55:07 <dibblego> take that issue up with a guy called Alan Turing
19:55:46 <syntaxglitch> aavogt, pattern matching failures aren't the only cause though
19:56:26 <Gracenotes> dibblego: it's not possible to find all partial functions, but it should be possible to find those which throw ghc runtime exceptions
19:57:48 <theorbtwo> Hm.  You only really have an issue with false negitives.
19:58:16 <theorbtwo> You might end up requring an entry with underscores that the programmer knows will never be hit.
19:58:18 <syntaxglitch> I'd settle for just having anything that could throw runtime exceptions be flagged as such in the type system
19:58:23 <theorbtwo> ...but that's not the end of the world.
19:58:24 <mm_freak> syntaxglitch: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16772#a16772
19:58:31 <mm_freak> see the tAppend function
19:58:36 <mm_freak> i'm unable to implement it
19:58:55 <mm_freak> the type checker doesn't get that it would be safe
20:00:34 <kmc> syntaxglitch, yes, the partial function monad or whatever
20:00:35 <mm_freak> it _would_ be possible to check this statically, but the type checker is just not smart enough
20:00:36 <kmc> i approve
20:01:00 <mm_freak> in fact if that would work, i'd no longer complain about dependent types missing in haskell =)
20:01:01 <Alpounet> you guys know what to do for the next hackathon
20:01:09 <syntaxglitch> kmc, the happy land of needing a monad just to do integer division
20:01:16 <kmc> mm_freak, no, you should always complain about that
20:01:57 <DigitalKiwi> Twey: hi
20:02:09 <Twey> Hey
20:03:56 <syntaxglitch> mm_freak, hm, seems like there ought to be a way to get something like that work
20:04:07 <mm_freak> syntaxglitch: i tried everything
20:04:15 <mm_freak> you can't even write the base rule
20:04:22 <syntaxglitch> everything? what, you recursively enumerated all possible programs? :P
20:04:22 <mm_freak> tAppend Empty xs = xs
20:04:30 <mm_freak> yeah =)
20:04:49 <dibblego> are there any dependent type proposals for haskell?
20:05:09 <kmc> there's one named "Agda" ;)
20:05:52 <mm_freak> honestly, they'd probably add nothing besides more to type and more verbose type signatures =)
20:06:38 <kmc> and the freedom to do type-level programming the same way we do value-level programming
20:06:43 <kmc> instead of these wretched hacks
20:07:15 <syntaxglitch> I don't know, man
20:07:22 <syntaxglitch> type-level metaprogramming is almost starting to make sense to me
20:07:30 <syntaxglitch> I think it's too late for me
20:08:08 --- topic: '["msg an op if you can't talk", "find ops: /msg ChanServ access list #haskell", "Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]'
20:08:08 --- topic: set by mauke on [Mon Jan 18 11:11:51 2010]
20:08:08 --- names: list (clog otto_s ts33kr conal augur SamB_XP_ MoALTz mueller Gracenotes monochrom tomberek Trafalgard ski_ copumpkin dibblego dolio araujo FauxFaux horms path[l] nainaide mokus moconnor Valodim petekaz smorg bind_return Cale pflanze blackh Beetny jones- wolverian skeptomai|away tltstc Anti-X hgolden Dessous G0SUB tgdavies lament ortmage suiside EvanCarroll jfredett electrogeek DigitalKiwi untwisted LeNsTR pumpkin ville aluink Raevel jlouis_ pettter_)
20:08:08 --- names: list (dMazz MadX` rntz canvon_ theorbtwo nothingmuch_ StarFire_ __mattam__ mblondin egoz adept AtnNn medfly syntaxglitch kynky kamatsu nus PepeSilvia Pthing ttmrichter nick8325 juhp_ cloudhead meanburrito920_ drbean Azstal Daminvar elspru c_wraith dreixel Jaak tomoj kmc sioraiocht lpsmith Zeiris_ trie amiri gnuvince the_andy MrFahrenheit tommd roconnor saccade_ tlm mereale snorble__ erikc dnolen nettok zachk kquick2 bos drwho Hugglesworth lokydor)
20:08:08 --- names: list (temoto mreggen albertosantini Runar hatds njbartlett sohum jtootf__ davatk mun niksnut mreh djahandarie Niccus cgibreak mattrepl dobblego sebbe1991 crem jonafan Rotaerk t dfrey dobie_gillis lhnz jorizma prb_ Raku^ StoneToad J-Mad hiptobecubic Arnar Mortomes s76_ BurgessShale sshc proq Modius jan_ NNshag arsenm Stefa2 gjl ketil EnglishGent zakwilson fihi09 michael| AnMaster McManiaC Cobra^^ kadoban shrughes ulfdoz_ amz thingwath jmcarthur)
20:08:08 --- names: list (paul424 kfish deavid npouillard flippo blackdog voker57 saurik tumult Claviceps bd_ fritschy soeren desu lefant aleator ehamberg hackagebot OnionKnight Badger sm leal SANDERS_ Resurge stoop astrocub otto_s_ yahooooo And[y] Draconx det Philonous mlh pwerken slc ttvd nlogax jix joga Laney IceDane dfeuer sjanssen_ bob0 Twey edwinb jvogel PsiOmega tamiko felipe_ eagletmt_ gspr zsol kwos koala_man ElfArmy otulp_ wto mauke mullein The_third_man)
20:08:08 --- names: list (ibt stoltene2 nominolo ClaudiusMaximus timlarson_ Feuerbach Boney zhijie1 jayne qebab aavogt a11235 quetzal- Adamant jdavis aep tmug impl amuck inimino Ferdirand duairc joed ps-auxw lsthemes Reisen glith mietek MrDomino Nereid M| Alpounet go|dfish solidsnack endojelly baaba_ cygnus_ Sagi kar-1 gwern fredcy kniu boyscared Liskni_si jlaire Dashkal Cthulhon luite psault whoppix ski lenbust_ mrothe C-S ray srcerer pastorn Taggnostr mmmdonuts)
20:08:08 --- names: list (jql MacCoaster_ Exteris_ ezrakilty kosmikus jontore tarbo _Jordan_ poucet tilman gdsx Veinor majoh dons mdordal2 clarkb ennen ath sieni flux davidL dixie_ kolmodin flori_ Bleadof koninkje1away glitch netcat_ icee_ brx bolmar_ tkr yottis Kyrus c9s__ ToRA matthew-_ prigaux Ke osfameron shepheb kwinz Khisanth opqdonut dejones Davse_Bamse dumael Apocalisp anekos noj merehap helgikrs jre2 reltuk dejai emias snhmib o-_-o dcolish ezeike oeblink)
20:08:08 --- names: list (levitation_ mjrosenb Saizan cathper cods quicksilver cjay equanimity Botje Eelis xerox Heffalump Aisling_ JaffaCake Astro eldragon absentia Igloo tensorpudding gbeshers Colours Polarina gds mfp wang willb fnordus thetallguy1 thetallguy mikezackles EvanR-work mikste DekuNut TML _stenobot jimmyjazz14 dropdrive nathanic_work Muad_Dibber guerrilla lostlogic inhortte khiroc Bassetts Blub\0 joevandyk BMeph Axman6 Paradox924X SimonRC ziman profmakx)
20:08:08 --- names: list (Nafai magicman|sleep wharrgarble nathanic pikhq ve kaol eek newsham galdor epmf Milo- qm13_ blazzy_ uorygl_ trez thorkilnaur dmwit BONUS quuxman _Jedai_ fabjan AndyP nwf sahazel anji joni6128 hiredman CalJohn dilinger_ etpace kalven karld dcoutts gbacon jtra juhp bbee arjanoosting dqd lambdabot shachaf Vulpyne nornagon smg Sisu mm_freak alios solrize olsner BrianHV eelco_ sgf idnar sproingie arw smiler jfoutz BONUS_ mornfall integral nniro)
20:08:08 --- names: list (Deewiant tromp zygoloid aiko nimred kloeri lars_t Shimei djinni Baughn int_e alip phnglui caligula_ p_l htoothrot laz0r eno +lunabot Ornedan tab _br_ shrimpx beza1e1 cheater Vq drhodes sothim DrSyzygy saccade anee dang`r`us mfoemmel gniourf_gniourf_ jystic SubStack jayrk hariju_ kevinclark mrd jrockway mercury^ webframp allbery_b shawn_ daed_ alexbobp Loriel cYmen epokal bran ido byorgey wdonnelly benmachine theclaw taruti jbauman Zao companion_cube)
20:08:08 --- names: list (Tupis geir_ dionoea Stephan202 zacharyp jvoorhis ahf mjv wormwood QtPlatypus peddie rapacity LeoD danderson Gabbie Cyneox burp jml agemo_ dino- encryptio keseldude shortcircuit sbok liesen stroan Gilly Twigathy elly geoaxis SmurfOR jedediah kw317 erk andrewsw orbitz pragma_ gmux tafryn ibid thoughtpolice pen16 saiam_ dufflebu1k Innominate_ +preflex wagle ksandstr dogmaT mahogny bwr Lemmih deadguys ahihi __marius__ noddy Counter-Strike harlekin)
20:08:08 --- names: list (@ChanServ)
20:08:20 --- topic: '["msg an op if you can't talk", "find ops: /msg ChanServ access list #haskell", "Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]'
20:08:20 --- topic: set by mauke on [Mon Jan 18 11:11:51 2010]
20:08:20 --- names: list (clog alexsuraci otto_s ts33kr conal augur SamB_XP_ MoALTz mueller Gracenotes monochrom tomberek Trafalgard ski_ copumpkin dibblego dolio araujo FauxFaux horms path[l] nainaide mokus moconnor Valodim petekaz smorg bind_return Cale pflanze blackh Beetny jones- wolverian tltstc Anti-X hgolden Dessous G0SUB tgdavies lament ortmage suiside EvanCarroll jfredett electrogeek DigitalKiwi untwisted LeNsTR pumpkin ville aluink Raevel jlouis_ pettter_)
20:08:20 --- names: list (dMazz MadX` rntz canvon_ theorbtwo nothingmuch_ StarFire_ __mattam__ mblondin egoz adept AtnNn medfly syntaxglitch kynky kamatsu nus PepeSilvia Pthing ttmrichter nick8325 juhp_ cloudhead meanburrito920_ drbean Azstal Daminvar elspru c_wraith dreixel Jaak tomoj kmc sioraiocht lpsmith Zeiris_ trie amiri gnuvince the_andy MrFahrenheit tommd roconnor saccade_ tlm mereale snorble__ erikc dnolen nettok zachk kquick2 bos drwho Hugglesworth lokydor)
20:08:20 --- names: list (temoto mreggen albertosantini Runar hatds njbartlett sohum jtootf__ davatk mun niksnut mreh djahandarie Niccus cgibreak mattrepl dobblego sebbe1991 crem jonafan Rotaerk t dfrey dobie_gillis lhnz jorizma prb_ Raku^ StoneToad J-Mad hiptobecubic Arnar Mortomes s76_ BurgessShale sshc proq Modius jan_ NNshag arsenm Stefa2 gjl ketil EnglishGent zakwilson fihi09 michael| AnMaster McManiaC Cobra^^ kadoban shrughes ulfdoz_ amz thingwath jmcarthur)
20:08:20 --- names: list (paul424 kfish deavid npouillard flippo blackdog voker57 saurik tumult Claviceps bd_ fritschy soeren desu lefant aleator ehamberg hackagebot OnionKnight Badger sm leal SANDERS_ Resurge stoop astrocub otto_s_ yahooooo And[y] Draconx det Philonous mlh pwerken slc ttvd nlogax jix joga Laney IceDane dfeuer sjanssen_ bob0 Twey edwinb jvogel PsiOmega tamiko felipe_ eagletmt_ gspr zsol kwos koala_man ElfArmy otulp_ wto mauke mullein The_third_man)
20:08:20 --- names: list (ibt stoltene2 nominolo ClaudiusMaximus timlarson_ Feuerbach Boney zhijie1 jayne qebab aavogt a11235 quetzal- Adamant jdavis aep tmug impl amuck inimino Ferdirand duairc joed ps-auxw lsthemes Reisen glith mietek MrDomino Nereid M| Alpounet go|dfish solidsnack endojelly baaba_ cygnus_ Sagi kar-1 gwern fredcy kniu boyscared Liskni_si jlaire Dashkal Cthulhon luite psault whoppix ski lenbust_ mrothe C-S ray srcerer pastorn Taggnostr mmmdonuts)
20:08:20 --- names: list (jql MacCoaster_ Exteris_ ezrakilty kosmikus jontore tarbo _Jordan_ poucet tilman gdsx Veinor majoh dons mdordal2 clarkb ennen ath sieni flux davidL dixie_ kolmodin flori_ Bleadof koninkje1away glitch netcat_ icee_ brx bolmar_ tkr yottis Kyrus c9s__ ToRA matthew-_ prigaux Ke osfameron shepheb kwinz Khisanth opqdonut dejones Davse_Bamse dumael Apocalisp anekos noj merehap helgikrs jre2 reltuk dejai emias snhmib o-_-o dcolish ezeike oeblink)
20:08:20 --- names: list (levitation_ mjrosenb Saizan cathper cods quicksilver cjay equanimity Botje Eelis xerox Heffalump Aisling_ JaffaCake Astro eldragon absentia Igloo tensorpudding gbeshers Colours Polarina gds mfp wang willb fnordus thetallguy1 thetallguy mikezackles EvanR-work mikste DekuNut TML _stenobot jimmyjazz14 dropdrive nathanic_work Muad_Dibber guerrilla lostlogic inhortte khiroc Bassetts Blub\0 joevandyk BMeph Axman6 Paradox924X SimonRC ziman profmakx)
20:08:20 --- names: list (Nafai magicman|sleep wharrgarble nathanic pikhq ve kaol eek newsham galdor epmf Milo- qm13_ blazzy_ uorygl_ trez thorkilnaur dmwit BONUS quuxman _Jedai_ fabjan AndyP nwf sahazel anji joni6128 hiredman CalJohn dilinger_ etpace kalven karld dcoutts gbacon jtra juhp bbee arjanoosting dqd lambdabot shachaf Vulpyne nornagon smg Sisu mm_freak alios solrize olsner BrianHV eelco_ sgf idnar sproingie arw smiler jfoutz BONUS_ mornfall integral nniro)
20:08:20 --- names: list (Deewiant tromp zygoloid aiko nimred kloeri lars_t Shimei djinni Baughn int_e alip phnglui caligula_ p_l htoothrot laz0r eno +lunabot Ornedan tab _br_ shrimpx beza1e1 cheater Vq drhodes sothim DrSyzygy saccade anee dang`r`us mfoemmel gniourf_gniourf_ jystic SubStack jayrk hariju_ kevinclark mrd jrockway mercury^ webframp allbery_b shawn_ daed_ alexbobp Loriel cYmen epokal bran ido byorgey wdonnelly benmachine theclaw taruti jbauman Zao companion_cube)
20:08:20 --- names: list (Tupis geir_ dionoea Stephan202 zacharyp jvoorhis ahf mjv wormwood QtPlatypus peddie rapacity LeoD danderson Gabbie Cyneox burp jml agemo_ dino- encryptio keseldude shortcircuit sbok liesen stroan Gilly Twigathy elly geoaxis SmurfOR jedediah kw317 erk andrewsw orbitz pragma_ gmux tafryn ibid thoughtpolice pen16 saiam_ dufflebu1k Innominate_ +preflex wagle ksandstr dogmaT mahogny bwr Lemmih deadguys ahihi __marius__ noddy Counter-Strike harlekin)
20:08:20 --- names: list (@ChanServ)
20:08:57 <mm_freak> well, type level programming can be great, except
20:08:58 <mm_freak> well
20:09:05 <mm_freak> {-# LANGUAGE EmptyDataDecls, FlexibleContexts, FlexibleInstances,
20:09:05 <mm_freak> FunctionalDependencies, GADTs, MultiParamTypeClasses, TypeOperators,
20:09:06 <mm_freak> UndecidableInstances #-}
20:09:16 <kmc> {-# LANGUAGE WretchedHacks #-}
20:09:21 <kmc> i've enjoyed the dependently typed programming i've done
20:09:25 <mm_freak> -fglasgow-exts
20:09:30 <kmc> mm_freak, hehe
20:09:32 * syntaxglitch draws the line at undecidable instances
20:09:35 <kmc> however, my coq power is decreasing
20:10:06 <syntaxglitch> knowing that GHC is depending on me to not do something stupid is too much pressure
20:10:40 <mm_freak> most stupid things don't typecheck
20:10:45 <mm_freak> stupidThing :: a
20:10:45 <kmc> it's not that big of a deal if your compiler fails to terminate
20:11:00 <mm_freak> you can't make stupidThing definite
20:11:02 <mm_freak> =)
20:11:11 <kmc> stupidThing = unsafeCoerce ()
20:11:12 <mm_freak> because anything could be stupid ;)
20:11:18 <kmc> ask a stupid question, get a stupid answer
20:11:50 <idnar> stupidThing = unsafePerformIO . unsafeCoerce
20:12:55 <mm_freak> sequence_ stupidThings
20:13:36 <mm_freak> > drop 34 . map head $ cake
20:13:37 <lambdabot>   "ASCIICAT"
20:13:42 <mm_freak> hmm
20:13:50 <mm_freak> > drop 27 . map head $ cake
20:13:51 <lambdabot>   "TOOTOOTASCIICAT"
20:14:13 <aavogt> > transpose cake
20:14:14 <lambdabot>   ["OOTFOTOTDFFFFFPFCOAUFANTOATTOOTOOTASCIICAT","nnhonhnwoiiiiiuianlniniwnnww...
20:14:53 <kmc> :t unsafeCoerce
20:14:54 <lambdabot> Not in scope: `unsafeCoerce'
20:15:26 <sshc> :t cake
20:15:27 <lambdabot> [[Char]]
20:15:29 <sshc> > cake
20:15:30 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
20:15:34 <SamB_XP_> > (have &&& eat) cake
20:15:35 <lambdabot>   Not in scope: `have'Not in scope: `eat'
20:15:40 <sshc> > cake !! 0
20:15:41 <lambdabot>   "One 18.25 ounce package chocolate cake mix."
20:15:43 <sshc> > cake !! 1
20:15:44 <lambdabot>   "One can prepared coconut pecan frosting."
20:15:46 <sshc> > cake !! 2
20:15:47 <lambdabot>   "Three slash four cup vegetable oil."
20:15:49 <sshc> > cake !! 3
20:15:50 <lambdabot>   "Four large eggs."
20:15:52 <sshc> > cake !! 4
20:15:53 <lambdabot>   "One cup semi-sweet chocolate chips."
20:15:57 <sshc> > cake !! 5
20:15:58 <lambdabot>   "Three slash four cups butter or margarine."
20:16:01 <sshc> > cake !! 6
20:16:02 <lambdabot>   "One and two third cups granulated sugar."
20:16:03 * syntaxglitch waits for the rhubarb
20:16:07 <sshc> > cake !! 7
20:16:08 <lambdabot>   "Two cups all-purpose flour."
20:16:16 <SamB_XP_> > text cake
20:16:17 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
20:16:17 <lambdabot>         against inferred type...
20:16:19 <Axman6> > text .  unlines $ cake
20:16:20 <lambdabot>   One 18.25 ounce package chocolate cake mix.
20:16:20 <lambdabot>  One can prepared coconut pecan...
20:16:23 <sshc> > cake !! 8
20:16:24 <lambdabot>   "Don't forget garnishes such as:"
20:16:26 <sshc> > cake !! 9
20:16:27 <lambdabot>   "Fish shaped crackers."
20:16:31 <sshc> > cake !! 10
20:16:32 <lambdabot>   "Fish shaped candies."
20:16:33 <kmc> > dropWhile (not . any (== "rhubarb") . words) cake
20:16:34 <lambdabot>   ["Two tablespoons rhubarb juice.","Adjustable aluminum head positioner.","S...
20:16:40 <sshc> > cake !! 11
20:16:41 <lambdabot>   "Fish shaped solid waste."
20:16:50 <sshc> > length cake
20:16:51 <lambdabot>   42
20:16:55 <mreh> sshc: wut?
20:17:41 <kamatsu> hlist labels are quite verbose
20:17:45 <kamatsu> the declarations, i mean
20:17:58 <kamatsu> has anyone written a TH wrapper for them?
20:18:22 <mreh> i like > drop 34 . map head $ cake
20:18:49 <sshc> > map head $ cake
20:18:50 <lambdabot>   "OOTFOTOTDFFFFFPFCOAUFANTOATTOOTOOTASCIICAT"
20:18:50 <tensorpudding> :t cake
20:18:51 <mreh> is mod n a fast way of mapping integers to n?
20:18:51 <lambdabot> [[Char]]
20:18:56 <mreh> ASCIICAT :)
20:18:58 <copumpkin> > cake
20:18:58 <dmwit> kmc: not . any (== x) = all (/= x) ;-)
20:18:59 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
20:19:08 <mm_freak> TOOTOOT!
20:19:10 <mm_freak> ASCIICAT
20:19:15 <kmc> yup
20:19:30 <mm_freak> mreh: "mapping"?
20:19:32 <kmc> i onder if that's intentional
20:19:50 <mreh> mm_freak: that's what a function is
20:19:56 <copumpkin> so that is the portal cake
20:20:23 <mm_freak> mreh: rem is faster than mod and equally correct, but gives negative answers for negative arguments
20:20:44 <aavogt> kamatsu: how do you mean? It's just    data X; x = Proxy :: Proxy X
20:20:50 <dmwit> mod/rem aren't "fair"
20:21:07 <mreh> > rem 20 7
20:21:08 <lambdabot>   6
20:21:08 <mm_freak> > sum . map length . map ("\r\n:mm_freak!n=milch@2a01:198:2d4:0:dead:affe:dead:affe PRIVMSG #haskell :" ++) $ cake
20:21:10 <lambdabot>   4459
20:21:20 <dmwit> i.e. (`mod` maxBound - 1) makes 0 twice as likely as any other choice
20:21:29 <dmwit> s/i.e./e.g./
20:21:31 <dmwit> whoops!
20:21:32 <mm_freak> > (* 582) . sum . map length . map ("\r\n:mm_freak!n=milch@2a01:198:2d4:0:dead:affe:dead:affe PRIVMSG #haskell :" ++) $ cake
20:21:33 <lambdabot>   2595138
20:21:37 <mm_freak> wow
20:22:04 <mreh> what is the Integer type good for?
20:22:05 <mm_freak> enumerating all 42 cake strings would waste more than 2.5 MiB network traffic
20:22:11 <sshc> mreh: Integers.
20:22:14 <mreh> I never seem to use it, Int always seems to suffice
20:22:38 <sshc> You should get in the habit of Integers since they're boundless
20:22:46 <aavogt> kamatsu: I mean, yes you can automate that... but you aren't saving much
20:22:49 <mm_freak> mreh: you can use Integers anyway
20:22:55 <dmwit> mm_freak: What's the (*582) for?
20:22:58 <mm_freak> if they are small, they will use machine words anyway
20:23:05 <mm_freak> dmwit: number of people sent to
20:23:08 <kamatsu> aavogt: I just get annoyed having to type each field name 3 time
20:23:10 <kamatsu> *3 times
20:23:43 <dmwit> mm_freak: Hm, your statistic is a little deceptive, isn't it?
20:23:45 <sshc> > it
20:23:46 <lambdabot>   Not in scope: `it'
20:24:01 <mm_freak> dmwit: why?
20:24:37 <dmwit> mm_freak: Well, for many of the links between you and me, the "cost" of the traffic you're sending me would be shared between all 582 of us.
20:24:57 <dmwit> And for some of the links, it would be shared by fewer than all 582 of us.
20:25:04 <dmwit> ...but still shared
20:25:10 <medfly> I think he means for the server
20:25:11 <medfly> ?
20:25:18 <mm_freak> how could that be shared?
20:25:23 <mm_freak> IRC is a dumb protocol
20:25:34 <dmwit> Yes, exactly.
20:26:02 <aavogt> well at some point it has to split up to 581 destinations
20:26:12 <mm_freak> the server dispatches the message to all other servers, which contain users on that channel (which i didn't even count)
20:26:13 <dmwit> So, it's shared for all of us between you and the IRC server you're connected to; then it's shared between almost all of us between the IRC server you're connected to and the "next IRC server over".
20:26:22 <mm_freak> then those servers distribute the message to their users
20:26:27 <sshc> > cake
20:26:28 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
20:26:34 <sshc> > cake
20:26:35 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
20:26:54 <mm_freak> dmwit: as aavogt said, at some point that splitting needs to occur
20:27:00 <sshc> > length . concat $ cake
20:27:01 <lambdabot>   1393
20:27:05 <mm_freak> it will lead to (currently) 581 messages being sent
20:27:13 <dmwit> aavogt, mm_freak: Yes, but it's significantly less traffic than if mm_freak had contacted each of the 581 of us and sent the messages independently.
20:27:23 <mm_freak> no
20:27:26 <dmwit> yes
20:27:32 <medfly> more?
20:27:42 <aavogt> more
20:27:44 <mm_freak> dmwit: then how do the individual clients get the message?
20:27:46 <mm_freak> magic?
20:27:54 <dmwit> mm_freak: No, not magic.
20:28:06 <mm_freak> the corresponding server needs to send that message
20:28:20 <mm_freak> to each client connected to the channel
20:28:24 <dmwit> Yes, but the servers before there don't.
20:28:24 <mreh> sshc: you can pm lambdabot to your hearts content
20:28:30 <mreh> don't let us hold you back
20:28:38 <mreh> I want to know her secrets
20:28:40 <mm_freak> sure, but the total load will be 582 messages
20:28:48 <mm_freak> summing up all servers
20:28:51 <dmwit> mm_freak: Let me put it this way.  If you send to the channel, each IRC server at freenode gets one copy of the message (and may send lots of copies).
20:29:12 <dmwit> mm_freak: The other option is you contact us each individually.  Then many servers will get hundreds of copies of the message.
20:29:16 <dmwit> There's sharing going on.
20:29:16 <medfly> you are connected to only 1 server
20:29:17 <mm_freak> you're saying that no _single_ server will send 582 messages
20:29:23 <mm_freak> that's right
20:29:33 <mm_freak> but the volume of traffic wasted is still 2.5 MiB
20:29:40 <mm_freak> it's just distributed over multiple servers
20:29:56 <medfly> it's a pretty inaccurate figure anyway
20:29:57 <dmwit> I'm saying that your statistic is deceptive, because at the top of the tree, less than 2.5 MiB are wasted.
20:30:08 <dmwit> Only at the leaves of the tree are 2.5MiB (total) transferred.
20:30:14 <mm_freak> sure
20:30:23 <mm_freak> i didn't state anything else =)
20:31:00 <dmwit> ...
20:31:21 <dmwit> Okay, I still don't think I'm being clear.  But this has already gone beyond the point of usefulness. =P
20:31:30 <mm_freak> you are clear
20:32:05 <mm_freak> you're comparing what i said (sending the messages to a channel and let the servers distribute them) to something i didn't say (sending each message to each client in question myself) ;)
20:33:21 <mm_freak> with the latter the traffic wasted would far exceed 2.5 MiB =)
20:34:53 <dmwit> In light of your last sentence, I adjust my claim: your measure of traffic is weird and maybe wrong.
20:35:27 <mm_freak> i took the messages, added the PRIVMSG command and prefix and summed the bytes
20:35:39 <mm_freak> and i multiplied that by 58something
20:36:16 <mm_freak> of course that's a simulation of _me_ sending all that stuff
20:36:35 <mm_freak> and my IP address is quite long =)
20:37:40 <mm_freak> ah yes, i also disregareded TCP/IP headers =P
20:48:41 <aavogt> kamatsu: the TH goes something like this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16777#a16777
20:48:46 <kamatsu> are HList records structurally typed? It looks like they are
20:49:31 <aavogt> what do you mean by structurally typed?
20:50:16 <kamatsu> well, for example, i can make a function that returns the "name" field of any record that has a "name" field
20:50:25 <aavogt> looking up values only requires that the record contains that type of field.. the order in which you add stuff to the record
20:50:28 <aavogt> doesn't matter
20:50:40 <kamatsu> i know
20:51:59 <aavogt> if that last one was a question, the answer is yes
20:52:14 <aavogt> I'm still not sure of the definition of structurally typed
20:52:39 <aavogt> records do have concrete types depending on what they contain
20:53:02 <kamatsu> aavogt: right, that is, afaik structural typing - like Ocaml does
20:53:23 <aavogt> but looking stuff up and other operations is done by type class methods which recurse over those types
20:53:50 <aavogt> I'm not very familiar with ocaml
20:58:26 <kamatsu> aavogt: uh, that TH doesn't really do what i want it to
20:59:05 <kamatsu> just seems to make a bunch of blank types
20:59:54 <kamatsu> what I want to wrap in TH is the key = firstLabel ns "key"; name = nextLabel key "name", etc.
21:04:53 <aavogt> kamatsu: what are these firstLabel and nextLabel functions?
21:08:14 <aavogt> anyways, you use   $(mkDecls ["label1","label2"]), and then you can go and define some records as:   label1 .=. "something" .*. label2 .=. 123 .*. emptyRecord
21:12:48 <kamatsu> aavogt: see Data.HList.Label*
21:14:31 <aavogt> you don't have to use those as labels
21:15:36 <kamatsu> that's what the slides say
21:16:30 <aavogt> I've just used labels that are   data X; x = proxy :: Proxy X; instance ShowLabel (Proxy X) where showLabel _ = "X"
21:21:33 <kamatsu> hm, any advantage over using type level numbers?
21:23:44 <kamatsu> oh, btw, in TH, any way to get from [DecQ] -> Q Dec
21:23:46 <kamatsu> ?
21:23:51 <pikhq> kamatsu: Typelevel computation.
21:24:21 <kamatsu> pikhq: explain
21:24:35 <aavogt> kamatsu: sequence
21:24:38 <pikhq> kamatsu: There's a few GHC extensions that makes the type system TC.
21:25:10 <kamatsu> aavogt: ah, just realised that Q Dec is DecQ
21:25:26 <kamatsu> pikhq: TC?
21:25:44 <pikhq> Turing complete.
21:25:45 <kamatsu> oh
21:25:47 <kamatsu> i know that
21:25:51 <kamatsu> what's your point?
21:26:01 <medfly> what the hell?
21:26:03 <medfly> @src (==)
21:26:03 <lambdabot> x == y = not (x /= y)
21:26:04 <medfly> @src (/=)
21:26:05 <lambdabot> x /= y = not (x == y)
21:26:05 <pikhq> ... You would want to use typelevel numbers when doing that sort of thing.
21:26:07 <medfly> ???
21:26:12 <copumpkin> medfly: yeah, what's wrong with that?
21:26:16 <kamatsu> medfly: it's the Eq class
21:26:18 <copumpkin> medfly: define one and get the other for free
21:26:26 <medfly> but they each use the other! :o
21:26:31 <medfly> -they
21:26:34 <copumpkin> those are just the default definition
21:26:34 <kamatsu> medfly: no, only one uses the other
21:26:38 <aavogt> define neither and wait till runtime to realize you didn't read the documentation
21:26:45 <syntaxglitch> aavogt, I've done that!
21:26:50 <copumpkin> you'd have to ignore the warnings
21:27:14 <copumpkin> oh I guess there'd  be no warning
21:27:18 <medfly> am I missing something? :o
21:27:21 <aavogt> exactly :)
21:27:23 * syntaxglitch was doing scary type metaprogramming hackery anyway
21:27:27 <copumpkin> medfly: yes
21:27:52 <medfly> @src ==
21:27:53 <lambdabot> x == y = not (x /= y)
21:28:01 <aavogt> as far as ghc's warnings care,   instance Eq Blah where -- is all you need
21:28:15 <copumpkin> there should be a better annotation system
21:28:19 <Zao> Heh, interesting symtoms when releasing DirectX objects on the wrong thread.
21:28:21 <copumpkin> for telling it what's necessary and what isn't
21:28:32 <Zao> My screens flicker occasionally :P
21:28:49 <kamatsu> medfly: each instance of Eq would override either == or /=. Those definitions exist so that you don't have to define both
21:29:00 <Zao> I went with the gtk2hs approach and mandate sequencing a finalizer queue in the main loop.
21:29:00 <medfly> oh
21:29:04 <medfly> I see
21:29:05 <aavogt> you can define both though
21:30:04 <medfly> thanks
21:30:34 <monochrom> "open recursion". every oop kid knows.
21:32:04 <aavogt> maybe medfly isn't an oop kid?
21:32:16 <medfly> I am not an oop kid
21:32:32 <monochrom> did someone not teach you oop when you were a kid?
21:32:39 <medfly> tsk tsk tsk
21:32:51 <aavogt> I'd blame cale
21:32:55 <monochrom> lucky you
21:33:38 <monochrom> but now you know open recursion. later when someone teachers oop to you, you will find it obvious.
21:33:41 <mm_freak> don't blame Cale
21:33:52 <medfly> who should I blame?
21:34:18 <mm_freak> he'll runSuperT $ BlateT (MegaT (\x -> GreatT x go away)) back
21:34:42 <kmc> what
21:35:44 <monochrom> you mean he'll go away?
21:36:02 <Zao> I just found myself wishing for an IOT transformer.
21:36:12 <xerox> In Our Time?
21:36:13 <mm_freak> no
21:36:23 <mm_freak> he'll runGoAwayT you
21:36:38 <mm_freak> Zao: uhm
21:36:43 <mm_freak> that doesn't make sense
21:36:46 <kmc> peace in our time
21:37:12 <Zao> Used somethign like IOT Reader SomeState Ret
21:37:14 <aavogt> redundant acronym acronym
21:37:31 <mm_freak> Zao: ReaderT SomeEnv IO Ret
21:37:43 <Zao> Where I could do liftAsk to query things but not have to liftIO every IO function and IO do.
21:38:12 <Zao> mm_freak: The problem there is that I can't use the reader inside the IO action for withForeignPtr.
21:38:19 <xerox> IO is the Čech compactification of monad transformer stacks
21:38:19 <mm_freak> well, usually you ask a few times at the start and then go into IO
21:38:21 <Zao> Which expects a vanilla IO function.
21:38:45 <mm_freak> (or whatever your next monad is)
21:39:03 <mm_freak> do myEnv <- ask; liftIO $ do …
21:39:29 <monochrom> @remember xerox IO is the Čech compactification of monad transformer stacks
21:39:29 <lambdabot> Good to know.
21:39:37 <monochrom> not that I know what it means :)
21:39:38 <kmc> topology or obscure joke, you decide
21:40:02 <mm_freak> probably just means "bottom" =)
21:40:07 <xerox> K.M.C. - On the topology of obscure jokes.
21:40:51 <Zao> Oh well, I guess it's kind of sane if I ask first and then pretend that liftReader is spelled (runReaderT r f).
21:42:19 <xerox> Čech compactification is the "most general" one of a class of compactifications of topological spaces.
21:43:39 <mm_freak> Zao: just note that in Reader there is no reason to go back from IO
21:44:00 <mm_freak> State would be different, but your lifted computation can easily return something
21:44:22 <Zao> I thankfully do not need State. Yet.
21:44:34 <mm_freak> State is great for a number of things
21:44:48 <kmc> you should use the reverse State monad
21:45:21 <mm_freak> i usually have something like this:  type MyIO = StateT Config (ReaderT Params IO)
21:45:26 <mm_freak> kmc: what's that?
21:45:39 <kmc> no idea
21:45:43 <kmc> i think it's cool though
21:46:56 <mm_freak> ah, ok
21:46:58 <mm_freak> hmm
21:47:17 <mm_freak> newtype Unstate s a = Unstate ((s,a) -> s)
21:47:21 <mm_freak> well
21:47:27 <mm_freak> newtype Unstate s a = Unstate (s -> a -> s)
21:56:19 <syntaxglitch> hey, mm_freak
21:56:19 <c_wraith> No, reverse state is stranger.  It propogates state backwards, so that you feed it the final state, and it calculates the initial state.
21:56:34 <xerox> instance Monad Salmon
21:57:21 <Twey> Is that possible?
21:57:33 <Twey> Doesn't it require that all the transformations have inverses?
21:58:31 <mm_freak> syntaxglitch: yes?
21:58:59 <syntaxglitch> mm_freak, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16787#a16787
22:00:02 <mm_freak> syntaxglitch: cool!
22:00:04 <syntaxglitch> mm_freak, for homework, implement a safe "pTake :: Int -> ???" ;)
22:00:38 <mm_freak> thanks…  i'll implement all that stuff on my own, first
22:01:00 <mm_freak> (if i ever happen to want that static guarantee at all)
22:01:11 <monochrom> Perhaps in the reverse state monad, user is supposed to provide inverse functions throughout.
22:01:33 <Twey> Isn't take already safe?
22:01:53 <Twey> monochrom: Well then that's just a state monad :þ
22:02:13 <c_wraith> well.  http://www.reddit.com/r/programming/comments/9i0wu/mindfuck_the_reverse_state_monad/
22:02:22 <c_wraith> Follow enough links from there, and you get the real thing
22:03:52 <syntaxglitch> Twey, regular lists are already safe enough as long as you don't go recklessly applying head to them
22:04:14 <syntaxglitch> type hackery isn't necessarily supposed to be useful :P
22:04:32 <mm_freak> well, i wouldn't use that for lists, i guess
22:04:36 <mm_freak> but for vectors and stuff
22:04:50 <syntaxglitch> now if I could just find a way to make it work without undecidable instances :'(
22:04:55 <mm_freak> no need for:  data Vector2 a = Vector2 (a, a)
22:05:03 <mm_freak> syntaxglitch: you can't
22:05:10 <copumpkin> syntaxglitch: what are you trying to do?
22:05:18 <syntaxglitch> copumpkin, abuse GHC's type checker
22:05:25 <copumpkin> more specifically?
22:05:40 <syntaxglitch> fix some code that mm_freak was working on earlier, that's all
22:05:51 * ivanm calls the police to report a case of abuse
22:05:56 <mm_freak> unless you find a way to encode that type hackery in a non-Turing-complete subset of haskell's type system
22:05:59 <Twey> Wow, that is a mindfuck
22:06:08 <mm_freak> for turing-completeness you need -XUndecidableInstances
22:06:10 <copumpkin> syntaxglitch: you can write pTake
22:06:16 <Twey> syntaxglitch: Ah, right :þ
22:06:24 <copumpkin> syntaxglitch: but without the Int
22:06:34 <syntaxglitch> copumpkin, clearly
22:06:41 <mm_freak> yes, i used to do that
22:06:53 <syntaxglitch> taking an arbitrary Int at runtime is what makes it interesting :D
22:07:00 <copumpkin> syntaxglitch: and impossible in haskell...
22:07:32 <mm_freak> well, most takes use a constant number anyway
22:07:33 <syntaxglitch> depends on your definition of impossible
22:07:53 <copumpkin> syntaxglitch: how so?
22:08:00 <Twey> Impossible, adj.: something for which a GHC extension does not yet exist.
22:08:13 <kamatsu> aavogt: your th doesn't work as you say it does
22:08:22 <copumpkin> that would be pTake : (n : Int) -> Vec n a
22:08:22 <syntaxglitch> copumpkin, I'm pretty sure there's even deeper type hackery that would approximate such
22:08:23 <mm_freak> syntaxglitch: that can't work, because type checking is static
22:08:30 <copumpkin> syntaxglitch: no, it's literally a dependent type
22:08:34 <c_wraith> huh.
22:08:34 <syntaxglitch> but at the cost of restructuring the program awkwardly
22:08:39 <c_wraith> droundy has given up on darcs?
22:08:55 * c_wraith notes the iolaus project
22:09:07 <mm_freak> it can only work with a just-as-static number
22:09:13 <copumpkin> syntaxglitch: you can do it with a type-level natural as the first parameter, but that's no different from just writing pTake :: Vec n a
22:09:16 <syntaxglitch> e.g., you'd end up with a program containing a region of code, with a static type guarantee that said region will only be entered with a valid number
22:09:17 <ivanm> c_wraith: he gave up almost as soon as darcs-2 came out IIRC
22:09:20 <copumpkin> (which is what I was suggesting before)
22:09:24 <ivanm> c_wraith: kowey, etc. run it now
22:09:31 <c_wraith> ivanm: oh, I didn't realize it was that long ago
22:09:56 <ivanm> c_wraith: there was a big hullaballoo when in the release statement for darcs-2 he pretty much said he was sick of it
22:10:09 <mm_freak> so something like this can work:  pTake :: Add n2 t n1 => t -> n1 `Times` a -> n2 `Times` a
22:10:18 <c_wraith> ivanm: I managed to miss that whole thing
22:10:23 <copumpkin> I wouldn't use MPTC for that
22:10:24 <ivanm> heh
22:10:29 <copumpkin> it's a very nice place to use type families
22:10:46 * syntaxglitch notes that it's possible to generate a type-encoded natural number from an Int at runtime anyway
22:11:06 <copumpkin> syntaxglitch: only in an existential wrapper
22:11:15 <copumpkin> at which point you don't really "know" much about it anymore
22:11:23 <ivanm> c_wraith: http://thread.gmane.org/gmane.comp.version-control.darcs.devel/7809
22:11:48 <mm_freak> btw
22:11:50 <ivanm> c_wraith: see also https://lopsa.org/node/1656
22:12:03 <mm_freak> why do we write MultiParamTypeClasses and not GeneralizedAlgebraicDataTypes?
22:12:23 <mm_freak> why can't we just write MPTCs, too?
22:12:35 <copumpkin> we love inconsistency
22:12:41 <ivanm> mm_freak: I've wondered that as well
22:12:43 <ivanm> copumpkin: heh
22:12:43 <copumpkin> I like that we write everything out but Param stays abbreviated
22:12:54 <mm_freak> indeed
22:12:56 <mm_freak> that's funny
22:12:59 <mm_freak> but it SUCKS
22:13:00 <syntaxglitch> also "EmptyDataDecls"
22:13:02 <copumpkin> it's great for guessability
22:13:03 <monochrom> Oh, it's because there are different people.
22:13:29 <mm_freak> somehow reminds me of windows
22:13:34 <mm_freak> MsgWaitForMultipleObjectsEx
22:13:40 <copumpkin> why not just accept common variants or settle on something consistent
22:14:01 <monochrom> MsgWaitForMyEx
22:14:16 <copumpkin> EDIDNTCALL
22:14:31 <mm_freak> DispatchEvilMessageToMyEx
22:14:46 <syntaxglitch> copumpkin, anyway, if you munge the list handling stuff up with the code to generate the existential type number it would probably suffice for purposes of faux-dependent type hackery
22:14:48 <copumpkin> mm_freak: that code of yours would be so much prettier using type functions :)
22:14:49 <mm_freak> CreateBrokenWindowAtMyEx
22:14:57 <syntaxglitch> not that it would be useful, mind
22:15:17 <copumpkin> syntaxglitch: it'd force you to stick everything generated from the existential in an existential
22:15:23 <copumpkin> you can't pull type-level information out of it
22:15:29 <mm_freak> copumpkin: i'm not going to use that stuff seriously =)
22:15:34 <copumpkin> so pTake :: AnyNatural -> AnyVec
22:15:43 <syntaxglitch> copumpkin, right
22:15:51 <copumpkin> so you're back where you started..
22:16:22 <mm_freak> actually type inference should make the whole count parameter redundant
22:17:02 <syntaxglitch> well, you'd want to pass in a function to munge around with the data to do what you want, and have it return some data that doesn't depend on the existential
22:17:09 <copumpkin> mm_freak: that's what I've been saying the whole time :P
22:17:17 <mm_freak> ok hehe
22:17:35 <copumpkin> the hard thing is encoding the < relation
22:17:42 <copumpkin> well, not hard
22:17:44 <copumpkin> but not trivial
22:17:59 <mm_freak> using my approach an additional fundep should solve that problem
22:18:06 <mm_freak> pTake :: Add n2 count n1 => List n1 a -> List n2 a
22:18:21 <mm_freak> class Add x y z | x y -> z | y z -> x where
22:18:56 <copumpkin> I'd encode it as pTake :: List (m :+ k) a -> List m a
22:19:17 <c_wraith> > replicateM 5 [1, 2, 3]
22:19:18 <lambdabot>   [[1,1,1,1,1],[1,1,1,1,2],[1,1,1,1,3],[1,1,1,2,1],[1,1,1,2,2],[1,1,1,2,3],[1...
22:19:47 <c_wraith> > cake !! 19
22:19:48 <lambdabot>   "Unsaturated polyester resin."
22:20:10 <monochrom> I wonder if it's even edible.
22:20:41 <syntaxglitch> with all that rhubarb? probably toxic.
22:20:41 <Axman6> :t replicateM
22:20:42 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
22:20:51 <monochrom> Perhaps the point is it is not edible, it is just for display.
22:20:53 <copumpkin> mm_freak: I wrote a fairly large module like that using type families a while ago if you want it
22:21:03 <Axman6> replicateM 3 (Just 4)
22:21:05 <Axman6> > replicateM 3 (Just 4)
22:21:06 <lambdabot>   Just [4,4,4]
22:21:27 <Axman6> @src replicateM
22:21:27 <lambdabot> replicateM n x = sequence (replicate n x)
22:22:03 <ivanm> greetings Axman6
22:22:26 <c_wraith> > let eleventyBillion = 3 in replicateM eleventyBillion cake
22:22:27 <Axman6> o/
22:22:27 <Axman6> haven't seen you for a while
22:22:27 <lambdabot>   [["One 18.25 ounce package chocolate cake mix.","One 18.25 ounce package ch...
22:22:41 <copumpkin> mm_freak: ah well, can't find it anyway :P
22:22:43 <ivanm> Axman6: I was in Madrid, and the timezones aren't really compatible... :s
22:22:51 <Axman6> ah right, how was it?>
22:23:18 <ivanm> not bad
22:23:31 <ivanm> anyway, tomorrow week I start driving down to Canberra
22:23:51 <Axman6> nice
22:24:23 <syntaxglitch> sheesh, I got some serious upvoting on Stack Overflow for telling someone not to use error
22:24:33 <syntaxglitch> guess I'm not the only person who hates error
22:24:57 <Twey> Everyone hates error
22:25:05 <Twey> And partial functions in general
22:25:13 <c_wraith> error is fine when you want to signal programmer fuckup.  It shouldn't be used for anything that doesn't indicate the programmer did something wrong
22:25:33 <Twey> Aye
22:26:18 <syntaxglitch> the SO question was basically "I'm using error as part of the control flow logic for my algorithm, how do I catch the exception to make this work"
22:26:28 <syntaxglitch> It made me really :(
22:26:29 * ivanm just uses undefined without bothering to specify what the problem is...
22:26:29 <ivanm> :p
22:26:46 <Twey> And clearly the appropriate response to that is plank-enabled violence
22:26:57 <ivanm> heh
22:27:02 <Twey> (to which comment that was a reply, I'm still unsure)
22:27:19 <copumpkin> syntaxglitch: don't tell him about spoon! :P
22:28:55 <Zao> How "safe" is readIORef/writeIORef for concurrent usage?
22:29:01 <Twey> It's not
22:29:05 <copumpkin> use an MVar
22:29:21 <copumpkin> or a TVar if you haz STM
22:29:40 <Twey> (and don't mind taking a 10× performance hit)
22:30:22 <Zao> Never mind. I just realized that I never share that IORef across threads.
22:30:30 <Twey> 's all good, then
22:30:38 * copumpkin clobbers Twey 
22:30:38 <Zao> The other one which I _do_ share uses atomicModifyIORef.
22:31:17 <Twey> copumpkin: It's tempting to just use TVars everywhere in case you need them later, even if you're not actually using STM features
22:31:59 <Twey> Not that the performance hit is a show-stopper, but in light of it it's wiser not to do that
22:32:17 <copumpkin> well, it seems hard to use them everywhere since they live in a different monad
22:32:27 <copumpkin> oh I guess there's newTVarIO
22:32:39 <Zao> I do intend to use STM for my higher layers, but this is rather down-to-earth.
22:32:42 <copumpkin> but you still can't do much without them unless you're in STM
22:32:42 <Twey> newTVarIO is just atomically . newTVar
22:32:52 <Zao> (finalizer queue for those pesky unbound GC threads :P)
22:32:59 <Twey> Eh?
22:33:20 <syntaxglitch> ugh, I should get to bed
22:36:58 <medfly> how slow is something like finding 10^6 primes on a slightly old computer supposed to be? (wondering if something is wrong with what I wrote, or it's just supposed to be really slow.)
22:37:14 <Twey> It's going to be really slow, I think
22:37:20 <Twey> Unless you're using a very clever algorithm
22:37:27 <Twey> Fabrice did something
22:37:41 <medfly> not too clever
22:37:52 <ivanm> hmmmm.... how big would that last prime be?
22:37:56 <xerox> depends how much bandwith consumes curl -O http://primes.utm.edu/lists/small/millions/primes1.zip
22:38:01 <medfly> hehehe
22:38:11 <Twey> Oh, wait
22:38:17 <Twey> That was pi.  My error.
22:38:22 <Twey> xerox: Haha
22:38:37 <ivanm> xerox: heh
22:39:21 <medfly> is not finishing in half an hour on a not too fancy computer reasonable?
22:39:31 <jrockway> now i remember why i never read programming mailing lists anymore
22:39:32 <Twey> medfly: 10^6 primes is come-back-next-week slow
22:39:38 <medfly> oh, I see
22:39:44 <jrockway> "7 is not a number! it's an ingteger! <4 more paragraphs>"
22:39:44 <medfly> I guess I need to optimise what I am doing.
22:39:45 <mm_freak> copumpkin: when i implement something like this, i usually do it for education
22:39:46 <xerox> (it takes 11 sec here.)
22:39:53 <mm_freak> so i'd rather do it myself =)
22:39:56 <ivanm> jrockway: :o
22:39:56 <medfly> xerox++
22:39:57 <Twey> jrockway: Hehe
22:40:00 <Twey> xerox: :þ
22:40:16 <ivanm> jrockway: you mean they stuffed up when they made Integral a super-class of Num?
22:40:19 <copumpkin> mm_freak: ah :P but you should still see how much nicer actual functions are with type families :) for more general relations MPTC make sense
22:40:20 <syntaxglitch> 7 is not a number! It's a free man!
22:40:21 <syntaxglitch> wait
22:40:21 <Twey> jrockway: Well, in fairness, it's sometimes important
22:40:26 <ivanm> (or is it sub-class? I can never get that straight...)
22:40:27 <Twey> syntaxglitch: Haha
22:40:36 <mm_freak> medfly: generating 10^6 primes is very fast, if you use sieving
22:40:38 <Twey> ivanm: It's a subclass
22:40:45 <jrockway> i just don't get
22:40:46 <ivanm> k
22:40:47 <medfly> sieving is what?
22:40:56 <Twey> mm_freak: Depends how smart your sieve is
22:40:57 <jrockway> "i'm sitting here in my house.  and now i am going to spend an hour writing this message to a mailing list."
22:41:00 <jrockway> why?
22:41:03 <mm_freak> medfly: look for the sieve of eratosthenes
22:41:09 <medfly> okay, I was mostly just wondering if I were doing something really wrong, but it's just not the most clever algorithm.
22:41:10 <ivanm> the _real_ sieve!
22:41:10 <syntaxglitch> jrockway, because someone is wrong on the internet
22:41:13 <ivanm> not the fake one!
22:41:13 <mm_freak> it well suffices to generate much more than 10^6 primes
22:41:15 <ivanm> syntaxglitch: heh
22:41:15 <jrockway> i guess, yeah
22:41:29 <medfly> thanks
22:41:41 <mm_freak> but in fact even a non-sieve algorithm should be able to generate 10^6 primes fast
22:41:44 <Zao> The SoE requires you to have an upper bound though, or some rather clever cleverness.
22:41:55 <medfly> oh, I think I have seen this before
22:42:01 <mm_freak> copumpkin: i'll have a look at it
22:42:20 <mm_freak> Zao: you can implement an infinite sieve in haskell
22:42:29 <mm_freak> but then it will lose its performance advantage
22:43:20 <copumpkin> really?
22:43:25 <copumpkin> why would it lose the advantage?
22:43:38 <medfly> I guess it works kind of well if you don't bother on ruling out for things larger than sqrt(n) if n is the largest number...
22:43:39 <copumpkin> it's fairly nice when implemented as an infinite merge of infinite multiples
22:43:53 <copumpkin> (subtracted from [2..])
22:44:14 <mm_freak> copumpkin: because then you can't use fast data structures anymore, but need to resort to O(n) indexing data structures
22:44:48 <copumpkin> mm_freak: you don't need indexing
22:44:58 <mm_freak> true
22:45:18 <mm_freak> but [Bool] is still much slower than UArray Int Bool
22:45:28 <copumpkin> yep :)
22:45:35 <copumpkin> but I'm not talking about that
22:45:42 <copumpkin> :t merge
22:45:43 <lambdabot> Not in scope: `merge'
22:46:54 <medfly> @hoogle merge
22:46:54 <lambdabot> Data.Graph.Inductive.Internal.Heap merge :: Ord a => Heap a b -> Heap a b -> Heap a b
22:46:54 <lambdabot> Data.Graph.Inductive.Internal.Heap mergeAll :: Ord a => [Heap a b] -> Heap a b
22:46:54 <lambdabot> Text.Parsec.Error mergeError :: ParseError -> ParseError -> ParseError
22:46:57 <copumpkin> map (2*) [2..] `merge` map (3*) [2..] `merge` map (5*) [2..] `merge` ... recursively defined with a smart merge function
22:47:11 <copumpkin> then subtract that (in the Ord way) from [2..]
22:47:22 <copumpkin> and you have yourself a nice infinite list of primes
22:47:52 <copumpkin> it ends up being quite elegant
22:52:55 <elly> @botsnack
22:52:55 <lambdabot> :)
22:52:55 <lunabot>  :o
22:53:13 <copumpkin> @butsmack
22:53:14 <lambdabot> :)
22:53:19 <elly> copumpkin: :O
22:53:24 <elly> copumpkin: I am intrigued by your ideas
22:53:26 <elly> apparently, so is she
22:53:38 <copumpkin> @bumsmack doesn't work
22:53:38 <lambdabot> Unknown command, try @list
22:53:41 <copumpkin> :(
22:54:02 <copumpkin> elly: yeah, lambdabot and I are tight
22:54:09 <elly> oh I /see/
22:54:11 * elly -> sleep
22:54:16 <copumpkin> enjoy
22:55:18 <mm_freak> hmm
22:55:24 <mm_freak> the infinite SoE is slow as hell
22:55:33 <copumpkin> mm_freak: how did you do it?
22:55:36 <mm_freak> even the naive trial division method is faster
22:55:39 <mm_freak> sec
22:56:06 <copumpkin> if trial division is faster you probably did something wrong :P
22:56:38 <jrockway> that should be a quote lambdabot remembers :)
22:56:57 <nus> ehrm, anyone with working cabal-install-0.8.0 && ghc-6.10.2 on windows platform?
22:57:26 <mm_freak> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16791#a16791
22:57:29 <ivanm> nus: why not get the latest haskell platform with 6.10.4 and cabal-install 0.6.2 ?
22:57:38 <mm_freak> that's the straightforward way of doing it
22:58:33 <copumpkin> let me throw together the way I'm talking about
22:58:34 <Zao> I thought that you generally should stick with whatever cabal minor version bundled with your ghc?
22:59:20 <nus> ivanm, 42 :-P
22:59:35 <nus> Zao, that's cabal-install not Cabal
23:00:27 <ivanm> Zao: and that's a lie
23:00:36 <ivanm> Cabal is the only boot library that is safe to upgrade
23:00:36 <Zao> nus: Oh.
23:00:47 <ivanm> (as long as you don't uninstall the one that came with ghc)
23:00:51 <Zao> ivanm: More uninformedness than lie, I'd say.
23:01:24 <Zao> ivanm: I've found out the hard way what happens if you rebuild or remove core packages.
23:01:36 <aluink> i'm messing around with Monads, trying to write a simple one of my own, and i'm getting this, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16792#a16793 ... I don't understand the error
23:01:46 * nus darcs gets cabal-install
23:01:48 <ivanm> Zao: yes, but Cabal is the exception
23:02:13 <aluink> i tried reading about it, but only got further confused
23:03:05 <ivanm> aluink: you just want f x I think
23:03:13 <ivanm> @type (>>=)
23:03:14 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
23:03:28 <ivanm> aluink: since the f function creates the new monad
23:04:14 <aluink> ahh, i forgot that f was (a -> m b)
23:04:24 <aluink> i thought it was (a -> b)
23:05:11 <ivanm> aluink: that's what liftM aka fmap is for
23:05:53 <mm_freak> my naive non-sieve finds the first 10^5 primes in 4.1 seconds
23:06:07 <Twey> aluink: >>= isn't meant to do the re-wrapping
23:06:15 <Twey> That's f's job
23:06:25 <copumpkin> mm_freak: still working on it :P
23:06:50 <Twey> If you think of it in terms of Maybe, >>= doing its own re-wrapping would deny the function the opportunity to return Nothing
23:07:26 <aluink> right...i've been plunging into Monads as much as possible lately trying to get a good grasp of it, and i keep getting twisted up
23:07:31 * aluink is getting there!
23:07:35 <jrockway> of course, Writer unwraps and rewraps
23:07:45 <jrockway> (lazily, which is the bane of my [*#$ing existence)
23:07:50 <Twey> That's not >>=, though
23:08:14 <ivanm> jrockway: the solution is simple: write your own StrictWriter monad!
23:08:34 <jrockway> i am doing so :)
23:08:40 <jrockway> it is not trivial
23:09:01 <jrockway> not for me anyway :)
23:09:14 <jrockway> i feel like i am close, though, and then i am going to sleep very well tonight
23:09:24 <jrockway> (or have dreams about monoids...)
23:09:50 <mm_freak> hmm
23:09:58 <mm_freak> Integer is faster than Int for doing mod stuff
23:10:07 <mm_freak> even if the operands are small
23:10:12 <mm_freak> interesting
23:10:12 <copumpkin> that makes no sense
23:10:17 <jrockway> how much faster?
23:10:20 <copumpkin> Integer === Int for small operands
23:10:26 <mm_freak> two times as fast
23:10:35 <mm_freak> copumpkin: seems like there are special optimizations for Integer
23:10:43 <jrockway> like 30 seconds instead of one minute?
23:10:44 <mm_freak> let me paste the code
23:10:48 <mm_freak> jrockway: yes
23:10:52 <jrockway> or 0.001 seconds instead of 0.002? :)
23:10:55 <jrockway> ah, interesting
23:11:00 <copumpkin> oh, if it's gcd it has a special optimized function
23:11:57 <mm_freak> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16794#a16794
23:12:03 <mm_freak> not gcd
23:12:23 <mm_freak> i'm using only rem and (^), nothing else
23:12:28 <mm_freak> and comparisons
23:12:39 <copumpkin> weird
23:12:46 <copumpkin> -O2 recent GHC etc.?
23:12:50 <mm_freak> yes
23:13:14 <mm_freak> well, the most recent GHC portage gives me
23:13:17 <mm_freak> % ghc --version
23:13:17 <mm_freak> The Glorious Glasgow Haskell Compilation System, version 6.10.4
23:13:53 <medfly> wow, so we should all use Integer by default? ;)
23:14:04 <Twey> 'course
23:14:12 <Twey> We should always have all been using Integer by default :þ
23:14:31 <medfly> :t (!!)
23:14:32 <lambdabot> forall a. [a] -> Int -> a
23:14:43 <xerox> ?src Integer
23:14:43 <lambdabot> data Integer = S# Int#
23:14:43 <lambdabot>              | J# Int# ByteArray#
23:14:43 <ivanm> Twey: you know, I'm _really_ getting sick of that character you use in that emoticon...
23:14:45 <medfly> I believe the reason for this was "optimisation"?
23:14:47 <xerox> ...it's pretty smart...
23:14:50 <ivanm> (you show-off)
23:14:58 <mm_freak> medfly: unless you have a very good reason to use Int, use Integer
23:15:00 <Twey> ivanm: Haha, why?
23:15:11 <medfly> so why does !! use Int?
23:15:21 <copumpkin> because Int is faster
23:15:21 <Zao> Legacy reasons?
23:15:23 <jrockway> not a lot of people have arrays with 2^33 indicies?
23:15:28 <medfly> copumpkin, didn't we just say it's not?
23:15:41 <copumpkin> one example of mm_freak that we haven't yet explained is faster
23:15:42 <mm_freak> medfly: Integer is faster for Integral operations
23:15:44 <xerox> there's a lil bit of overhead with integer
23:15:46 <mm_freak> not faster in general
23:15:47 <copumpkin> not sure it's safe to extrapolate
23:15:47 <Zao> @type Data.List.genericIndex
23:15:48 <lambdabot> forall b a. (Integral a) => [b] -> a -> b
23:16:03 <medfly> okay...
23:16:05 <copumpkin> for example, Integer must always check when you increment whether to use a gmp integer or a native int
23:16:10 <Zao> jrockway: Isn't Int guaranteed to just 2^30 or something?
23:16:13 <copumpkin> to see if it still fits
23:16:21 <medfly> gmp is what?
23:16:24 <mm_freak> Zao: 2^28, AFAIK
23:16:29 <Twey> medfly: My GHCi is still grinding away at those primes with Taylor's sieve :þ
23:16:35 <mm_freak> it's some weird number
23:16:36 <medfly> heh
23:16:51 <Zao> copumpkin: Aren't there non-GMP Integer implementations nowadays?
23:16:52 <medfly> Twey, I actually have a much better optimisation for my little problem, because it's more than finding primes
23:16:55 <Zao> Or was that just a happy wish?
23:16:59 <Twey> medfly: Aha
23:17:02 <copumpkin> Zao: there's one, but it's not easy to switch to it
23:17:02 <jrockway> i thought it was 2^27 actually (according to a recent post on haskell-cafe, anyway)
23:17:10 <copumpkin> 2^29 last I heard
23:17:18 <copumpkin> :P
23:17:19 <jrockway> now that i think about it, though, it is a reasonable array index
23:17:25 <jrockway> of bools on a 64-bit machine, or something
23:17:26 <mm_freak> ok, now we have four possibilities =)
23:17:39 <jrockway> mm_freak: thanks :)
23:18:24 <medfly> 2^63 - 1 :: Int seems to work as expected for me
23:18:32 <jrockway> 64-bit machine?
23:18:37 <medfly> correct
23:18:42 <copumpkin> so Int is required to be 30 bits
23:18:44 <medfly> so maybe it's 2^31 - 1 ?
23:18:54 <copumpkin> he finite-precision integer type Int covers at least the range [ - 2^29, 2^29 - 1].
23:19:11 <jrockway> yeah, 2^63 - 1 works here too
23:19:29 <copumpkin> > maxBound :: Int
23:19:30 <jrockway> ghc++
23:19:30 <lambdabot>   9223372036854775807
23:19:35 <copumpkin> , maxBound :: Int
23:19:37 <lunabot>  2147483647
23:19:45 <medfly> heh
23:19:50 <medfly> lunabot is 32bit
23:20:01 <medfly> , 2^31 - 1 :: Int
23:20:02 <lunabot>  2147483647
23:20:36 <copumpkin> , 2^31 + 2 :: Int
23:20:37 <lunabot>  -2147483646
23:21:10 <xerox> > log (fromIntegral (abs (maxBound :: Int)) :: Double) / log 2
23:21:11 <lambdabot>   63.0
23:21:37 <xerox> , log (fromIntegral (abs (maxBound :: Int)) :: Double) / log 2
23:21:38 <lunabot>  30.999999999328196
23:21:43 <medfly> hehehe
23:21:55 <xerox> :D
23:22:03 <medfly> need to -1 it
23:22:39 <xerox> > round (log (fromIntegral (abs (maxBound-1 :: Int)) :: Double) / log 2)
23:22:40 <lambdabot>   63
23:22:44 <xerox> , round (log (fromIntegral (abs (maxBound-1 :: Int)) :: Double) / log 2)
23:22:45 <lunabot>  31
23:23:11 <medfly> I didn't realise I can just not have spaces
23:23:19 <medfly> > 3`mod`2
23:23:20 <lambdabot>   1
23:23:23 <medfly> strange
23:23:37 <copumpkin> if you like being forced to use spaces, use agda :)
23:23:49 <medfly> I use python!
23:23:57 <xerox> > (zip`ap`tail) [1..]
23:23:59 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11),(11,12),(12...
23:24:12 <xerox> (aztech god of consecutive numbers)
23:24:20 <copumpkin> <*> is cooler
23:24:22 <medfly> haha
23:25:03 <jrockway> > (zip `fmap` tail) [1..] [1..]
23:25:04 <lambdabot>   [(2,1),(3,2),(4,3),(5,4),(6,5),(7,6),(8,7),(9,8),(10,9),(11,10),(12,11),(13...
23:25:14 <jrockway> the slightly drunken version...
23:25:36 <xerox> how disappointing it is when you go through a very long argument and you realize the author just did it so that he'd be able to define a liiiiiiiiittle generalization of a previous definition, which was arguably always good enough...
23:25:46 * xerox curses a bit, and then calms down
23:25:58 <jrockway> does this argument involve the number 7 and how it's not a number?
23:26:00 <copumpkin> ncurses?
23:26:35 <xerox> it's just some topology so that you can define the integral of a differential form for an arbitrary CONTINUOUS path, instead of a PIECEWISE DIFFERENTIABLE one.
23:28:29 <NEEDMOAR> xerox: you know, unimportant stuff is always important.
23:28:58 <xerox> I'm not sure it'll actually make a difference, but I'll be happy to see if it does.
23:29:40 <xerox> (it's all very well written until now, I'm just a lil tired and grumpy)
23:30:33 <xerox> ircd shutdown countdown starts!
23:31:54 <copumpkin> when is it?
23:32:10 <jrockway> according to the recent global message, now
23:32:19 <jrockway> but it's not a shutdown, it's a snapshot and migrate
23:32:40 <copumpkin> ah
23:35:02 <jrockway> hmm, i think i successfully created my strict writer monad
23:35:55 <jrockway> or perhaps not... seems like i have a lot more stack on my home machine compared to my work machine
23:36:15 <Gracenotes> does it use seq?
23:36:19 <jrockway> yes
23:36:50 <merehap> gnu tools in haskell check it out!
23:37:00 <jrockway> here is what i have now: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16795#a16795
23:37:04 <merehap> please ignore :(
23:37:13 <jrockway> but, the answer is printed, then i see a bunch of OH HAIs, then the "log"
23:37:17 <jrockway> so i think it is not strict enough actually
23:37:23 <Gracenotes> maybe the constructors it evaluates to take up more space than the thunks themselves
23:37:41 <jrockway> i should see the log messages being evaluated as "tell" is called
23:37:49 <Gracenotes> ahm, from Debug.Trace
23:40:21 <jrockway> maybe i will change the result to messages `seq` W (r', messages)
23:40:50 <jrockway> yes.
23:41:01 <jrockway> or should i say, OH HAI :)
23:47:43 <jrockway> actually, i think i am still wrong
23:47:48 * jrockway closes IRC until it works :)
23:49:02 <medfly> hehe
23:54:27 <jrockway> ok, so my test case doesn't use any stack on my home machine (+RTS -K2k runs fine)
23:54:35 <jrockway> but on my work machine, it instantly overflows an 8M stack
23:54:43 <jrockway> both ghc 6.10.4
23:54:54 <jrockway> one linux/64 the other windows/32
23:59:02 <nus> err, which test case?
