00:04:34 <mtnviewmark> okay - I'm stumped for the night
00:04:37 <mtnviewmark> good night
00:12:12 <[Bool]> hi, does anyone know where I can paste my script so I can show it to someone
00:12:22 <dolio> @paste
00:12:23 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
00:12:44 <[Bool]> oh nice thanks
00:14:13 <mtnviewmark> okay - so I'm back
00:14:25 <[Bool]> hello, welcome back
00:14:36 <mtnviewmark> that thing --- it's in the .hi file for Data.Generics.SYB.WithClass.Instances
00:14:39 <mtnviewmark> but not in the .o file
00:14:49 <mtnviewmark> would that be, perhaps, a compiler bug?
00:15:14 <mtnviewmark> Data.Generics.SYB.WithClass
00:15:25 <mtnviewmark> Data.Generics.SYB.WithClass.Instances.dataType[abOQ]
00:15:27 <mtnviewmark> rather
00:15:52 <mtnviewmark> that is the closure - which is in the interface file, but not in the .o or .a --- and hence
00:16:04 <mtnviewmark> something compiled against this doesn't link
00:17:36 <mtnviewmark> and as if Douglas Adams was watching --- it is dataTypeOf42
00:19:13 <kamatsu> jaspervdj: your examples for hakyll use Text.Render rather than Text.Hakyll.Render
00:20:12 <jaspervdj> uh, in the tutorial, you mean?
00:20:59 <jaspervdj> kamatsu: I see, you're right
00:21:05 <jaspervdj> kamatsu: I'll fix it
00:23:18 <kamatsu> jaspervdj: $root gives me errors, what am i doing wrong
00:23:28 <kamatsu> jaspervdj: hakyll.hs: Key not found: "root"
00:24:10 <[Bool]> hello, can anyone tell me what I am doing wrong here? I am trying to make a function that takes in a number x and gives back it's factorial.  This is what I have:
00:24:12 <[Bool]> ftr x = [1..x]
00:24:13 <[Bool]> ftr [] = []
00:24:13 <[Bool]> ftr (x:xs) = (ftr x)* (ftr xs)
00:24:39 <kamatsu> [Bool]: uh, why do you have a list there?
00:24:52 <jaspervdj> kamatsu: are you sure you're using hakyll >= 1.0
00:24:58 <[Bool]> so that the list can multiply with one before
00:25:02 <kamatsu> jaspervdj: let me check, i just cabal install hakyll
00:25:04 <[Bool]> so say factorial 10
00:25:15 <[Bool]> 1..10 is gonna give me 1,2,3,4
00:25:25 <[Bool]> then i want to multiply all them together
00:25:33 <kamatsu> [Bool]: okay, so that's:
00:25:41 <Saizan> [Bool]: you shoul define two distinct functions
00:25:53 <monochrom> mtnviewmark: did you build syb-with-class yourself? is syb-with-class built as part of building happstack-data?
00:25:54 <kamatsu> ftr x = foldl (*) 1 [1..x]
00:25:58 <Saizan> if you call them both ftr they are assumed to be a single one
00:26:07 <mtnviewmark> I cabal install'd it myself
00:26:16 <mtnviewmark> and reinstalled it just this evening
00:26:27 <[Bool]> ok thanks
00:26:37 <[Bool]> but I'd rather not use foldl
00:26:37 <kamatsu> jaspervdj: ah, forgot to cabal update
00:26:41 <[Bool]> it's built in
00:26:52 <kamatsu> [Bool]: right, so, without built in functions, you should reimplement foldl and do that
00:27:02 <[Bool]> oh ok
00:27:08 <[Bool]> @src foldl
00:27:09 <lambdabot> foldl f z []     = z
00:27:09 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
00:27:18 <jaspervdj> kamatsu: also, refresh the web page, I fixed it already :-)
00:27:18 <Saizan> mtnviewmark: are you on ghc 6.12? try installing it with documentation and profiling disabled, that helped for me
00:27:25 <kamatsu> jaspervdj: great
00:27:30 <Geheimdienst> uh, wouldn't it work to say: fac x = x * (fac (x-1))
00:27:50 <mtnviewmark> I'm on 6.10.4
00:27:58 <Saizan> Geheimdienst: and fac 0 = 1, yeah
00:28:00 <[Bool]> gehei: wow nice thinking
00:28:12 <kamatsu> [Bool]: That is how factorial is usually defined mathematically.
00:28:21 <mtnviewmark> oy, but turning off profiling means my whole happstack install will have to be non-profiling
00:29:04 <kamatsu> [Bool]: frankly i'm suprised you hadn't seen that one before.. hence i gave the foldl example
00:29:13 <kamatsu> [Bool]: It's on the wikipedia page for haskell
00:29:22 <[Bool]> o
00:29:59 <mtnviewmark> this thing in question seems to be something generated from    $( deriveData [''ByteString] )
00:31:55 <mtnviewmark> so, I see that the .hi file (when dumped) has two objects of the form   dataType[a...
00:32:30 <mtnviewmark> and the .a and .p_a files also, each have two symbols of the form   dataTypeZMa....
00:32:35 <mtnviewmark> only they don't match
00:34:05 <mtnviewmark> AHA
00:34:30 <mtnviewmark> correction -- the .p_hi file - the interface file for the profiling version matches the .p_a profiling lib
00:35:05 <mtnviewmark> the NON profiling interface file .hi -- has symbols that don't match the .a lib!
00:35:53 <mtnviewmark> I know that symbol names get munged with every optimization step
00:35:58 <mtnviewmark> I wonder if this is a bug of some sort with that
00:36:13 <mtnviewmark> okay - now I really have get to sleep
00:36:20 <mtnviewmark> I will plow forward tomorrow
00:36:35 <Geheimdienst> good night, and good luck
00:50:33 <altmattr> I have been doing a lot of html/js/css coding recently with jQuery and it struck me just how exceedingly functional the "query the DOM" approach is
00:50:40 <jaspervdj> poucet: Hello, are you here?
00:50:52 <altmattr> is anyone doing work on creating guis in haskell using this approach?
00:53:13 <kamatsu> altmattr: indeed, you might even say jquery's $ is a monad...
00:53:31 <kamatsu> or at least a functor
00:55:39 <altmattr> it is also a really nice way to code a gui as well - I used to hate it terribly, but modern js libs pull the DOM approach ahead of the nested containers (QT, swing, etc) if you ask me
00:57:41 <kamatsu> altmattr: i agree
00:57:52 <tensorpudding> functors are fun
00:58:39 <kamatsu> you could make it a full blown monad with little work
01:02:12 <Saizan> "$ is a monad" because of how it's similar to list comprehensions?
01:10:16 <kamatsu> Saizan: if the language of the client side of the web was haskell, it would be a dom comprehension or dom monad
01:11:52 <Saizan> yeah, so the bind would be essentially concat
01:11:55 <Saizan> *concatMap
01:12:05 <kamatsu> yeah
01:17:12 <Saizan> it's a bit of a shame that saying "give me all the nodes with id foo" takes time proportional to the page size
01:17:46 <Jafet> Hm, in which implementation?
01:18:29 <Saizan> firefox in my case
01:19:11 <c_wraith> too bad it's not practical to enforce that ids actually be unique.  (bad web designers would blame the browser, loudly, and cause pr incidents)
01:20:07 <Saizan> i could say the same for class :)
01:20:25 * Saizan doesn't have a benchmark though
01:32:59 <Raymond> I need to learn this language now
01:36:22 <Niccus> LYAH is usually a good place to start http://learnyouahaskell.com/
01:53:30 <Peaker> c_wraith: even non-unique lookups could be fast..
01:53:52 <c_wraith> Peaker: it's true.  My comment was tangentially related at best
02:31:36 <ehird> So how worky is GHC 6.12?
02:31:45 <ehird> If I replace 6.10.4 with it will I be happy and satisfied with my world?
02:31:50 <ehird> Will the Haskell Platform work?
02:32:04 <tensorpudding> pretty sure that the platform doesn't work with 6.12
02:34:24 <ehird> Darn.
02:34:33 <ehird> (I want fancy type families.)
02:35:01 <alfa> Un Saluto a tutti
02:37:21 <Beelsebob> the haskell platform doesn't "work" with a compiler ehird
02:37:27 <Beelsebob> it is a bundle of compiler and libraries
02:37:34 <ehird> i nkow
02:37:36 <ehird> *know
02:37:38 <Beelsebob> you can always grab 6.12.1 and all the libraries that come with the platform
02:37:40 <ehird> i just mean do all the libraries work with 6.12
02:37:48 <ehird> or is there breakage
02:37:58 <Beelsebob> my experience so far has been that things just-work
02:38:21 <Beelsebob> the only thing I found broken was breifly zlib didn't compile, and I think that was an OS X 64 bit issue, not a ghc 6.12 issue
02:40:47 <Saizan> well, actually, each release of the Haskell Platform is designed around a specific version of ghc
02:41:34 <Saizan> if it works with the next it's just luck :)
02:43:28 <kamatsu> the last 6.10 haskell platform release was meant to be september
02:43:32 <kamatsu> didn't happen ?
02:45:03 <Saizan> when was 2009.2.0.2 released?
02:46:04 <mrothe> July 2009
02:49:54 <Beelsebob> Saizan: right, the point I was making was that you could grab the libraries and get on with it â€“ it'll be newer versions of the libraries most likely, but it should all work (for the most part)
02:57:41 <kamatsu> @seen jaspervdj
02:57:42 <lambdabot> Unknown command, try @list
02:59:01 <Saizan> preflex: seen jaspervdj
02:59:01 -preflex(n=preflex@95-88-118-220-dynip.superkabel.de)- jaspervdj was last seen on #haskell 2 hours, 8 minutes and 20 seconds ago, saying: poucet: Hello, are you here?
03:03:31 <adu> wow
03:03:37 <adu> that was lots of work
03:15:27 * hackagebot upload: ldif 0.0.3 - The LDAP Data Interchange Format (LDIF) parser (RadoslavDorcik)
03:25:00 <ehird> What's the simplest way to get ["'", "''", "'''"] etc?
03:25:39 <Raevel> > iterate (++ "'") "'"
03:25:41 <lambdabot>   ["'","''","'''","''''","'''''","''''''","'''''''","''''''''","'''''''''","'...
03:25:51 <Axman6> > iterate ('\'':) ""
03:25:52 <lambdabot>   ["","'","''","'''","''''","'''''","''''''","'''''''","''''''''","'''''''''"...
03:26:05 <ehird> ugh, I'm dumb
03:26:08 <Axman6> more efficient too ;)
03:26:08 <ehird> should have thought of that
03:26:10 <ehird> thanks :)
03:26:19 <Ke> > repeat '\''
03:26:19 <Raevel> also yours has a smiley
03:26:20 <lambdabot>   "''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''...
03:26:28 <Axman6> yup
03:26:29 <Ke> nvm
03:26:33 <ehird> now to combine it with ['a'..'z']
03:26:37 <Axman6> and smilies make code run faster
03:26:42 <ehird> and i have a list of variables to try
03:26:48 <ehird> (don't ask)
03:27:05 <ehird> hmm
03:28:04 <Axman6> > [x:y | y <- iterate ('\'':) "",  x <- ['a'..'z']]
03:28:05 <lambdabot>   ["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s...
03:29:02 <ehird> concatMap (\x -> zipWith (:) ['a'..'z'] $ cycle [x]) $ iterate ('\'':) ""
03:29:05 <ehird> Axman6: damn you
03:29:09 <ehird> with your conciseness and beauty
03:29:20 <Axman6> i think i just leveled up :)
03:29:35 <Axman6> i remember when i used to say that to people
03:29:38 <ehird> next step: go through each of them in order, seeing if they're in the map
03:29:47 <ehird> Axman6: to your cocredit i am sleep deprived.
03:29:50 <Axman6> first i didn't understand what they were doing, then i did, but couldn't have thought of it myself
03:29:58 <ehird> and thus any working code that doesn't look like cthulhu is a work of art to me
03:30:07 <Axman6> heh
03:30:21 <ehird> it's no wonder i'm messing with type systems; values are just a bit beyond my capabilities right now
03:30:46 <ehird> :t scanr
03:30:48 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> [b]
03:30:53 <ehird> ok, not that function I want
03:31:00 <ehird> @hoogle (a->Bool)->[a]->a
03:31:00 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
03:31:00 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
03:31:00 <lambdabot> Prelude filter :: (a -> Bool) -> [a] -> [a]
03:31:08 <ehird> head . filter then
03:31:23 <ehird> (that Maybe will only apply if there are an infinite number of items int he map, which seems unlikely)
03:32:19 <nlogax> Axman6: that gave me some nice visuals in ghci O_O
03:32:35 <Axman6> nlogax: i can imagine :)
03:33:10 <Axman6> damn, that does look good :P)
03:33:12 <Axman6> p
03:33:15 <ehird> ghci is pretty much trip station
03:33:16 <Axman6> -p*****]'
03:33:22 <ehird> you plug in some amazing infinite list
03:33:26 <ehird> and bam
03:33:39 <ehird> and then you run out of memory
03:33:42 <ehird> and your computer explodes
03:34:09 <Axman6> that should run in pretty close to constant space
03:34:22 <Axman6> well, it'll eventually increase, due to the iterate bit
03:34:41 <ehird> wow that was all the code I needed to write?
03:34:44 <ehird> now my code compiles yay!
03:34:53 <ehird> let's see in what special way it is broken this time
03:34:54 <Axman6> :)
03:35:34 <ehird> ...now that is unexpected.
03:35:42 <ehird> ohh
03:35:43 <ehird> oh i see
03:35:58 <ehird> i need alpha-conversion >_<
03:36:44 <ehird> oh no, that req-- no it doesn't
03:37:28 <ehird> noo i do
03:37:34 <ehird> that sucks
03:37:52 <ehird> i am ensaddened
03:38:00 * ehird shuts up
03:55:55 <Baughn> ..waagh. Bad eliezer. You most certainly /can/ program a conscious bein in haskell. ^^;
03:57:26 <Saizan> @vixen Are you a conscious being?
03:57:26 <lambdabot> whoa whoa whoa, one question at a time!
03:58:21 <Saizan> @vixen It was only one
03:58:21 <lambdabot> i understand
03:58:27 <Saizan> meh
03:59:46 <Saizan> anyone knows how hard would implementing Constraint Handling Rules efficiently in haskell be?
04:02:29 <opqdonut> what do you mean by constraint handling rules?
04:02:49 <kamatsu> Saizan: something like prolog?
04:03:01 <opqdonut> if you mean just constraint satisfaction, the backtracking algorithms for example can be straightforwardly implemented in a functional way
04:04:02 <augustss> Saizan: I don't think it's to bad to implement CHR.  It's been done a few times.
04:06:43 <opqdonut> ah, CHR meant something specific
04:10:12 <Saizan> augustss: ah, i've only found stmchr, do you remember the others?
04:10:19 <Saizan> opqdonut: yeah, sorry
04:10:44 <Paczesiowa> why do we need existential types? the only reason to use them is to pack values and functions working on them together. why not just pack results of those functions? instead of "forall a. Show a => Showable a", just use "Showable String" and a smart constructor for creating such values.
04:11:17 <augustss> Saizan: some guy who was in york, he's now in france.  Sorry, his name escapes me right now.
04:11:43 <Saizan> augustss: thanks anyhow :)
04:11:48 <kamatsu> Paczesiowa: It's fairly clear, basically it's when the typeclass(es) you are defining for the existential box define multiple functions
04:12:04 <kamatsu> and you may need the results of more than one of those functions
04:12:36 <Paczesiowa> kamatsu: you can keep a tuple of all results
04:12:52 <augustss> Paczesiowa: yes, that kinds works.  But what if I want to apply 'foo :: Show a => a -> Int' to the thing in the box?
04:13:12 <Cale> Paczesiowa: there are actually odd cases where you run into trouble doing that, but quite often that does work well.
04:13:13 <augustss> Paczesiowa: A function I didn't foresee when making the box.
04:13:44 <kamatsu> Paczesiowa: What if you have an existential type over some monadic action?
04:14:03 <Saizan> http://okmij.org/ftp/Computation/Existentials.html <- relevant
04:14:05 <Paczesiowa> augustss: thank you, that makes sense.
04:14:50 <Paczesiowa> Saizan: I'm not clicking that, I'll lose another 2 hours...
04:14:59 <Saizan> hehe
04:15:26 <Paczesiowa> who am I kidding, I'll click it anyway...
04:15:29 <Saizan> it's even ocaml..
04:16:53 <Saizan> "working with encodings is not as nice as the real thing" seems to be the bottom line here
04:19:49 <Paczesiowa> Oleg - The Answer to Type, the Universe, and Everything.
04:20:47 <HaskellLove> I need to change an element value in a List. How to do that? Will I have to zip and use Data.Map?
04:21:04 <kamatsu> HaskellLove: "change"?
04:21:19 <Saizan> there are even experimentations with first-class existential types, without needing to declare a custom wrapper, implemented in UHC i think
04:21:20 <opqdonut> HaskellLove: no, you don't have to
04:21:33 <opqdonut> you can use breakAt, change the head, and then ++
04:21:41 <HaskellLove> having a list [2,2,1] i would like to get a list [2,3,1] for example, so that is element with index 1 changed to 3
04:22:08 <kamatsu> right, so as opqdonut said, breakAt, change, then ++
04:22:13 <Saizan> s/breakAt/splitAt/ ?
04:22:20 <opqdonut> > let f xs n a = let (ys,z:zs)=breakAt n xs in ys++a:zs in f [1,2,3,4,5] 3 0
04:22:21 <lambdabot>   Not in scope: `breakAt'
04:22:22 <kamatsu> @type splitAt
04:22:23 <opqdonut> ah
04:22:23 <lambdabot> forall a. Int -> [a] -> ([a], [a])
04:22:29 <opqdonut> > let f xs n a = let (ys,z:zs)=splitAt n xs in ys++a:zs in f [1,2,3,4,5] 3 0
04:22:30 <lambdabot>   [1,2,3,0,5]
04:22:31 <opqdonut> there
04:31:30 <HaskellLove> g xs i n = a ++ (n:bs) where (a, b:bs) = splitAt i xs
04:31:50 <HaskellLove> thanks guys, although it would be cool if haskell guys provided such function already
04:32:02 <opqdonut> well it's pretty inefficient
04:32:17 <opqdonut> if you need to do that often you're better off with an IntMap or so
04:37:13 <HaskellLove> I am not so sure about that i am looking at it now. You will need to convert to IntMap, insert and then convert back to list. I think that will cost more then the function above
04:37:39 <opqdonut> i meant: don't use lists at all
04:37:57 <opqdonut> and converting an intmap to a list is linear time
04:38:11 <opqdonut> so just pass around intmaps and traverse them with toList
04:38:55 <opqdonut> unless you use tail or ++ a lot, in which case Data.Sequence might be a good choice
04:47:59 <juhp> bah I accidently pushed cabal-install-0.6.4 into fedora 12 updates which conflict with haskell-platform
04:48:21 <juhp> though I think cabal-install 0.6.2 and 0.6.4 are compatible
04:52:54 <HaskellLove> opqdonut toList? I thought you said dont use lists at all
04:55:29 <jlouis> HaskellLove: it will convert the list lazily
04:55:40 <jlouis> HaskellLove: so with luck it acts like an iterator
04:56:17 <HaskellLove> yeah but he said dont use lists at all and now i am confused a bit
04:56:46 <jlouis> HaskellLove: I think he meant that there is no reason to convert the IntMap to a list before it is needed as a list
04:57:03 <HaskellLove> aha ok
05:00:06 <jlouis> HaskellLove: and what others said: If you want to replace the n'th element of a list with something else, chances are that your data representation is wrong
05:00:29 <HaskellLove> my algorithm requires such function
05:01:14 <jlouis> HaskellLove: often such algorithms can be reworked to not require it.
05:01:26 <kamatsu> yes, I would agree with jlouis
05:01:30 <kamatsu> what is your algorithm?
05:01:47 <HaskellLove> It is work in progress actually for euler 31
05:02:07 <jlouis> and sometimes you are lucky and the rework of the algorithm improves the running time considerably
05:02:35 <kamatsu> HaskellLove: That problem can be solved without any such replacement
05:02:50 <HaskellLove> i need that function to do this: given a list such as [2,2,1] return me [[Int]], one such example is [2,1,1,1] so it is a sequental explosion of the 2s
05:03:48 <HaskellLove> the result would be [[2,1,1,1], [1,1,1,1,1]]
05:03:51 <HaskellLove> get it?
05:04:07 <kamatsu> yes
05:04:10 <HaskellLove> basically i apply explode function to each element that can be exploded
05:04:19 <kamatsu> right, requires no "replacing"
05:04:59 <HaskellLove> it does, because, i take a value at some index and apply a function to it, and then return the whole new list
05:05:09 <kamatsu> not "some index"
05:05:45 <kamatsu> also, wouldn't that example you have give:
05:06:06 <kamatsu> [[1,1,2,1],[2,1,1,1],[1,1,1,1,1]]
05:06:32 <kamatsu> here's how i would do it
05:06:52 <HaskellLove> no order does not matter
05:07:05 <HaskellLove> all it matters is, you have one 2 and three 1s
05:07:08 <jlouis> HaskellLove: another approach you might ponder on is not to generate the lists but just count them
05:07:10 <mauke> I'd use an array
05:07:34 <HaskellLove> jlouis thought of that yes, but i need lists for my algorithm further development
05:07:52 <kamatsu> > nub $ map sort $ concatMap (\n -> take n $ repeat 1) [2,1,1]
05:07:53 <lambdabot>   No instance for (GHC.Num.Num [a])
05:07:53 <lambdabot>    arising from the literal `1' at <inter...
05:08:43 <HaskellLove> kamatsu i dont need map, i need to get the new list with an element at given index changed
05:09:17 <kamatsu> HaskellLove: my point is that it's not a given index, it's every index
05:09:43 <kamatsu> HaskellLove: you need every step along the way, which map won't give you, but you don't need arbitrary index
05:10:35 <kamatsu> HaskellLove: It would be reasonably easy to make a replacement for map that does what you want
05:10:40 <HaskellLove> ah i get what you mean, but i filter cases that can not be exploded and i pass valid indices so yes i need indices... an alternative is to make my function use Maybe which i do not like in this case
05:11:03 <HaskellLove> yep ok thank you guys i am back to work will see if my algorithm goes well
05:11:04 <kamatsu> HaskellLove: Filter them before the map?
05:11:10 <jlouis> HaskellLove: have you thought of a way to avoid the combinatorial explosion?
05:12:00 <HaskellLove> yeah in a comprehension list i filter numbers that are equal to the maximum of the list of two numbers, for example for [1,2,1,2] the indices for values 2 wont be returned
05:12:59 <kamatsu> HaskellLove: The problem is you're treating the list like an array
05:13:08 <HaskellLove> jlouis no, i just wanna solve it first, i tried lot of stuff i cant solve this euler 31 for days, it paralized me and filled with feeling of incompetence and stupidity i cant do else until i solve it haha
05:13:13 <kamatsu> HaskellLove: When dealing with lists, never think about indices
05:13:48 <HaskellLove> ah good point, Cale pointed these things to me, to forget about indices and imperative style
05:13:56 <HaskellLove> will go with array then
05:14:37 <kamatsu> HaskellLove: I have solved this problem without Arrays. I still think you're doing it wrong.
05:14:57 <kamatsu> HaskellLove: The solution isn't to keep thinking about indexes and not use a list, the solution is to stop thinking about indexes and use a list
05:15:23 <Cale> First solve it via plain recursion, and then think about how to speed it up.
05:15:37 <Berengal> Plain recursion is plenty fast enough, really...
05:15:42 <HaskellLove> kamatsu, this is personal :) it is one of those problems that make you feel miserable when you cant solve it, i dont want to study others solutions i must do it myself
05:15:59 <HaskellLove> will let you know what i have soon
05:16:02 <BONUS> HaskellLove: which euler problem are you solving
05:16:09 <kamatsu> BONUS: 31
05:16:18 <ehird> Is it just me or is there a higher propensity in here than in other channels for people to name themselves with Haskell in their nick?
05:16:26 <kamatsu> HaskellLove: My solution is 5 lines. It should be similar for you.
05:16:30 <BONUS> oh that one
05:16:31 <ehird> It happens a befuddlingly large amount.
05:16:32 <BONUS> that's a cute one
05:16:51 <kamatsu> HaskellLove: If you're writing a massive program, i suggest going back to drawing board
05:17:12 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16053#a16053 -- this was the solution I already tried to explain to HaskellLove
05:18:11 <kamatsu> Cale: right, but I think he should solve it first without memoization
05:18:17 <Cale> I agree.
05:18:43 <Cale> Just try to understand that fromCoins without the added memo table.
05:18:50 <mauke> kamatsu: here's a solution using an array: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16057#a16057
05:18:53 <kamatsu> My completely naive one is 3 lines long and it still solves it in reasonable time
05:19:07 <Jafet> @remember Axman6 and smilies make code run faster
05:19:08 <lambdabot> I will never forget.
05:19:37 <kamatsu> Jafet: Lol! when did Axman6 say that?
05:20:28 <Jafet> No idea, the lag was horrible
05:20:31 <Cale> In any case, manipulating lists of coins seems like the wrong thing.
05:20:39 <Jafet> SICP does it!!
05:20:42 <Cale> (though you could do it that way too)
05:21:54 <BONUS> the trick with 31 is to think about it really recursively :)
05:22:27 <Cale> You could also do it using generating series, but that requires a bit more cleverness and setup
05:22:33 <Berengal> Cale: It's not much slower than just counting
05:23:48 <Cale> The generating series for the number of ways to make change for n is the product over denominations d of 1/(1-x^d)
05:24:14 <kamatsu> I dunno, for me Project Euler teaches you very little about using Haskell for real programming
05:24:25 <kamatsu> (if you use haskell to solve the problems)
05:24:35 <kamatsu> it just teaches you to think functionally if you're used to imperative stuff
05:24:36 <Berengal> It's nice for giving you something to do while learning the syntax and features
05:24:37 <Cale> That is, the number of ways to make change for n pennies is the coefficient of x^n in the series 1/((1-x)(1-x^2)(1-x^5)...(1-x^200))
05:24:49 <BONUS> i found it handy for learning haskell, it got me used to the syntax and thinking in composition and infinite lists
05:25:09 <kamatsu> Right, but my first language was Lisp, to me most Project Euler problems weren't good for learning
05:25:17 <kamatsu> i suppose it's a different strokes scenario
05:25:28 <kamatsu> and before anyone asks, i don't know what Lisp
05:25:28 <Berengal> It's also much easier to solve PE problems in haskell than some other languages, I found. At least easier than python
05:25:36 <kamatsu> Berengal: PE?
05:25:41 <Berengal> kamatsu: Project Euler
05:25:44 <kamatsu> oh, lol
05:25:47 <kamatsu> i feel like an idiot now
05:25:54 <Jafet> Lisp is very simple -- you always know that no matter what the textbook is telling you to do now, it's going to end up part of your metacircular interpreter
05:26:06 <kamatsu> that is true, they are substantially easier in Haskell
05:26:32 <Cale> SeriesCoefficient[1/((1 - x) (1 - x^2) (1 - x^5) (1 - x^10) (1 - x^20) (1 - x^50) (1 - x^100) (1 - x^200)), {x, 0, 200}]
05:26:40 <Cale> ^^ mathematica solution to Euler 31
05:26:54 <HaskellLove> Cale is talking about generating functions which I do not know about yet...
05:26:55 * Berengal first got 10 in Java before he gave up, then got 40 in python before he gave up, then got 65 in haskell before he gave up because it became more about math, less about programming
05:27:05 <Jafet> That's because you didn't read the generatingfunctionology book
05:27:08 <Cale> I hate the term "generating function" though.
05:27:19 <Jafet> Which you were told in #math for about ten minutes to read
05:27:21 <Cale> And generatingfunctionology is an awful book :(
05:27:30 <HaskellLove> i tried to read it i could not
05:28:00 <kamatsu> The issue i have with Lisps is that they're supposedly an infinitely customizable language (and indeed i suppose they are) but then Lisp programmers never really make full use of that
05:28:08 <flik> ïðèâåò
05:28:09 <Jafet> Because you're a programmer, and programmers don't have to bother with math
05:28:18 <flik> hallo
05:28:19 <Cale> generatingfunctionology somehow manages to completely miss the point of generating series.
05:28:26 <kamatsu> flik: hi!
05:28:36 <flik> ;)
05:29:09 <kamatsu> flik: wait.. i knew a flik from a completely unrelated thing, but it could just be a shared net alias
05:29:13 <flik> How you?
05:29:33 <mauke> flik: how did you find this channel?
05:30:13 <flik> I Russian;) has found this channel casually
05:30:19 <HaskellLove> Cale, a better book is?
05:31:03 <flik> What weather at you?
05:31:12 <Cale> HaskellLove: Unfortunately, I'm not 100% sure what to recommend. All the books that I know of are {suitable for beginners, handle things in a decent way, widely available}: pick any two.
05:31:30 <kamatsu> flik: I don't mean to be rude, but are you interested in the Haskell programming language, or just here to chat idle-y
05:32:12 <flik> I here to talk to you
05:32:18 <Cale> If you want the latter two, you might go with something like Goulden and Jackson's bible "Combinatorial Enumeration".
05:32:35 <Cale> Or many books on combinatorial species.
05:33:54 <flik> mauke What weather at you?
05:34:04 <Cale> The only books which I've seen that are suitable for beginners and handle things sanely are the course notes for MATH 249 and C&O 330 by David M. Jackson at the University of Waterloo.
05:34:13 <Cale> Unfortunately, they're a bit hard to get.
05:34:31 <HaskellLove> ok Cale i will look for some books now
05:34:34 <Cale> (You can phone up the print services and I think they can still print copies and ship them)
05:36:14 <Cale> I should really try a bit more to look through the various books, but I really think generatingfunctionology is an unfortunate book. It's free, so everyone uses it, but it would be extremely hard to recover the right perspective on things from the way that book does it.
05:36:34 <HaskellLove> thanks Cale
05:37:05 <HaskellLove> i think any book will do, i found some
05:37:08 <Cale> If you can find a book which is about combinatorial species that is easy enough to understand, let me know
05:37:14 <Jafet> Nice modus operandi Cale -- "come for the project euler, stay for the combinatorial series"
05:40:33 <Cale> I could do a quick intro right now, if you want. At least, perhaps enough to understand the generating series for making change :)
05:42:30 <HaskellLove> hmm here or in pm, i dont want to be baned for talking non haskell ;)
05:43:09 <Jafet> There's a short introduction to this in "Art and Craft of Problem Solving"
05:47:04 <Cale> HaskellLove: I'm an op, and mathematical topics are generally okay here :)
05:47:16 <HaskellLove> Jafet bookmarked, thanks
05:47:43 <HaskellLove> Cale so i dont waste your time i am gonna do some reading for a week and then come back to this ;)
05:51:33 * Cale sees if he can coerce mathematica into giving a general formula for the coefficient of x^n in that series :)
05:52:03 <Cale> You could apply the negative binomial theorem a whole bunch to extract one, I suppose.
05:56:03 <Cale> I suspect it would be not really any better than the recursive counting solution in the end
05:57:34 <Jafet> Fore!
06:01:37 <canseek> I'm trying to understand bottom, and it's relation to strict code in haskell
06:01:50 <canseek> _|_ is a type with no values right, and is a subtype of all other types
06:02:01 <Cale> ... no, _|_ is a value
06:02:03 <BONUS> _|_ is a value
06:02:07 <Peaker> sort-of a value :)
06:02:08 <Cale> which is a member of each type
06:02:10 <BONUS> but that value is in all types
06:02:13 <koeien37> even Void
06:02:14 <canseek> Er, hold on
06:02:15 <BONUS> lol damnit beaten twice
06:02:25 <opqdonut> koeien37: unfortunately :)
06:02:28 <koeien37> Void is a type with only one value: _|_
06:02:31 <Cale> There's no subtyping in Haskell.
06:02:34 <canseek> 'Because the bottom type is used to indicate the lack of a normal return, it typically has no values'
06:02:37 <canseek> Damn you wikipedia
06:02:49 <opqdonut> bottom type != bottom value
06:02:55 <Cale> ... that sounds like it needs work.
06:02:55 <opqdonut> bottom type is what we call Void
06:03:09 <paolino> anyone ever counted the number of sudoku games, if it's possible by a program ?
06:03:13 <canseek> Wikipedia says that _|_ denotes an empty type
06:03:17 <canseek> Anyway
06:03:17 <opqdonut> canseek: if you're coding strict haskell you "don't need" to worry about bottoms
06:03:27 <Cale> I suppose that if there was a subtype relation, Void would be a subtype of every type, and _|_ would be its only member.
06:03:30 <koeien37> paolino: that is probably out of reach for a computer program to count
06:03:31 <canseek> opqdonut: maybe not but I want to
06:03:44 <opqdonut> it's much more interesting with nonstrict programs
06:03:45 <koeien37> paolino: I'm not entirely sure though
06:04:01 <opqdonut> anyway, a strict function f is a function such that f _|_ = _|_
06:04:02 <Cale> canseek: A function f is called strict if f _|_ = _|_
06:04:03 <canseek> Ok wait er, so in haskell _|_ is a value, that inhabits every type right?
06:04:04 <Cale> hehe
06:04:05 <opqdonut> in other words, if f
06:04:07 <canseek> Yeah I just
06:04:11 <canseek> DOn't understand it
06:04:16 <opqdonut> 's argument doesn't evaluate to a proper value, f doesn't either
06:04:28 <Cale> canseek: You can think of _|_ as a representation of nontermination
06:04:35 <paolino> koeien37: that meaning it's possible by pen and paper only ?
06:04:39 <canseek> Brb sorry, phone
06:04:41 <opqdonut> think C: f(g(x)), but g(x) is nonhalting or does a division by zero
06:04:43 <koeien37> paolino: I would think so
06:04:56 <koeien37> there are probably some mathematicians that have written papers about it
06:04:58 <opqdonut> then f does not return any meaningful result
06:05:10 <Cale> canseek: It's the "value" which represents program errors as well as the infinite-loop variety of nontermination.
06:05:47 <koeien37> ah, I've found one
06:05:58 <koeien37> they used a computer, but not to enumerate all solutions
06:06:17 <opqdonut> probably loads of symmetry reduction on paper
06:06:21 <koeien37> yes
06:07:32 <canseek> Right sorry about that
06:07:44 <canseek> Maybe I'll understand better if I understand this
06:07:46 <canseek> I read that
06:08:06 <Cale> canseek: So, let's examine why it's important to treat this thing as a value
06:08:12 <canseek> f _|_ = _|_ + 1 = _|_
06:08:27 <Cale> Consider something like  1 : _|_
06:08:39 <Cale> (:) is interestingly not a strict function
06:08:46 <Cale> > head (1 : undefined)
06:08:48 <lambdabot>   1
06:09:05 <canseek> Ok
06:09:29 <canseek> Why is undefined _|_ though, I thought undefined was defined as like
06:09:34 <canseek> undeined = error ""
06:09:38 <koeien37> it is.
06:09:38 <Cale> yes
06:09:41 <xerox> paolino yes they did, and the author of the count is in #haskell ;)
06:09:42 <canseek> So why is that _|_?
06:09:43 <koeien37> but that's how we think of it
06:09:51 <Cale> _|_ represents all errors and other forms of nontermination
06:10:04 <koeien37> 1/0 would also be _|_
06:10:08 <koeien37> well, div 1 0
06:10:33 <canseek> error and nontermination, so why for example is
06:10:35 <canseek> id _|_?
06:10:37 <syntaxglitch> it seems to me that _|_ conflates multiple concepts that really aren't the same thing
06:10:55 <Berengal> syntaxglitch: denotationally they are
06:11:09 <Dodek> _|_ is an operator?
06:11:12 <koeien37> no.
06:11:13 <koeien37> a value
06:11:22 <Dodek> ah, ok.
06:11:30 <koeien37> every type has _|_ as one of its values
06:11:38 <damd> NO
06:11:41 <koeien37> :t undefined
06:11:41 <lambdabot> forall a. a
06:11:48 <opqdonut> well unboxed values don't
06:11:52 <koeien37> ack
06:11:57 <opqdonut> but it's a good starting point :)
06:12:08 <canseek> Alright er
06:12:25 <canseek> I'm still confused but, what about this then, why is forall a . a _|_? What exactly is the reasoning behind it?
06:12:27 <damd> then again, unboxed values are just boxed values without the box...?
06:12:29 <damd> *zen*
06:12:38 <opqdonut> _|_ is a theoretical concept, relating to certain models of lambda calculus
06:12:40 <Berengal> opqdonut: Yes they do. A function Int -> Int# may return _|_
06:12:47 <opqdonut> that's why it appears a bit funny in practical contexts
06:12:52 <mauke> canseek: (forall a. a) means "I am in all types at the same type"
06:12:59 <damd> the real symbol is: âŠ¥
06:13:00 <Cale> canseek: _|_ :: forall a. a  because for any type, you can write a definition like  let x = x in x
06:13:00 <mauke> canseek: the only value with that property is _|_
06:13:04 <opqdonut> Berengal: hmm, good point
06:13:10 <mauke> argh
06:13:13 <Cale> canseek: and it doesn't matter what type x has there
06:13:16 <mauke> fixed: canseek: (forall a. a) means "I am in all types at the same time"
06:13:20 <opqdonut> Cale: he was asking the other direction
06:13:23 <opqdonut> what mauke said
06:13:29 <canseek> Oh I think I see, as in
06:13:32 <Cale> Oh, why are there no other values which belong to every type?
06:13:35 <opqdonut> :t undefined
06:13:36 <lambdabot> forall a. a
06:13:41 <canseek> Because a matches all possible types, and the only common value is _|_, it is _|_?
06:13:45 <koeien37> Bool and Integer have almost empty intersection already
06:13:54 <koeien37> canseek: correct
06:14:05 <canseek> Hmm
06:14:47 <opqdonut> this is sort of related to:
06:14:50 <opqdonut> :t Nothing -- this
06:14:51 <lambdabot> forall a. Maybe a
06:15:03 <opqdonut> Nothing is the value that is in Maybe a for all values of a
06:15:31 <opqdonut> so having _|_ is kinda like having all our types be Maybe types
06:15:36 <Cale> canseek: This sort of thing comes out of trying to reason about the behaviour of programs while still admitting general recursion into the mix.
06:15:38 <opqdonut> but _|_ is not observable and Nothing is
06:16:32 <canseek> It makes more sense, though I still don't see how for example
06:16:46 <canseek> f _|_ = _|_ + 1 would be _|_
06:16:58 <koeien37> that depends on the implementation of (+)
06:16:59 <Cale> canseek: Well, it depends on the definition of +
06:17:23 <koeien37> if you use Peano arithmetic, depending on (+), it might very well be that it's not _|_
06:17:37 <canseek> Alright well
06:17:42 <Jafet> Church numerals!
06:17:44 <koeien37> but for Integer (+) is strict in both arguments
06:17:49 <canseek> The function succ is strict right? And is strict x = x + 1
06:18:02 <koeien37> depends again on your implementation
06:18:09 <canseek> And if I'm right in understanding that functions are strict only in the case of f _|_ = _|_, then I don't understand it
06:18:16 <koeien37> that's the definition of strict
06:18:25 <c_wraith> canseek: succ is strict *for Int*
06:18:34 <koeien37> try this example:
06:18:35 <c_wraith> canseek: other instances of enum might not be strict.
06:18:40 <koeien37> f x y = if x == 0 then y else 0
06:18:49 <canseek> c_wraith: can you explain why?
06:18:52 <koeien37> then f x is _not_ strict for all x
06:19:01 <Cale> canseek: Basically, a function is strict if it needs to pattern match on its parameter before it can produce any part of its result
06:19:33 <opqdonut> :t const 0
06:19:34 <lambdabot> forall t b. (Num t) => b -> t
06:19:42 <c_wraith> canseek: consider natural numbers.  data Nat = Zero | Succ Nat
06:19:42 <opqdonut> > (const 0) undefined
06:19:43 <lambdabot>   0
06:19:46 <opqdonut> const 0 is not strict
06:19:56 <mauke> const undefined is strict
06:19:56 <c_wraith> canseek: the succ x = Succ x
06:20:04 <opqdonut> mauke: indeed
06:20:07 <c_wraith> canseek: and that's not strict.
06:20:28 <opqdonut> c_wraith: unfortunately that type is not isomorphic to lifted natural numbers...
06:20:33 <opqdonut> unlike Integer
06:20:50 <c_wraith> opqdonut: doesn't mean it can't be an instance of Enum (though it'd necessarily be partial)
06:20:57 <opqdonut> sure
06:22:09 <canseek> Sorry c_wraith, I'm still confused
06:22:18 <canseek> I don't understand why
06:22:25 <canseek> Needing to pattern match makes it strict
06:22:32 <c_wraith> It doesn't pattern match, though.
06:22:40 <c_wraith> It doesn't examine its argument *at all*
06:23:01 <canseek> I meant in general
06:23:05 <canseek> Not the example you gave
06:23:09 <Cale> canseek: Okay, perhaps I should have been more precise -- matching a pattern which *involves a data constructor* makes something strict.
06:23:40 <Cale> canseek: patterns like x can and will immediately match against _|_ without observing it.
06:23:41 <canseek> Cale, id x = x is strict, there's no data constructor there?
06:24:02 <canseek> Mmm
06:24:06 <Cale> canseek: well, yeah, that one is strict because in the case that you pass it _|_, it immediately produces _|_
06:24:16 <canseek> I'm sure I'm driving you mad here, sorry D:
06:24:22 <Cale> canseek: nah, it's cool :)
06:24:36 <canseek> Oh right because _|_ is the same on either side, right ok but
06:24:44 <koeien37> (there are also "lazy pattern matches" to confuse you even more)
06:24:49 <Cale> Consider something like  (\fac n -> if n == 0 then 1 else n * fac (n-1))
06:24:53 <canseek> Yeah I don't want to be confused more
06:25:01 <Cale> Is this function strict?
06:25:04 <Cale> hmm :)
06:25:10 <Cale> (\fac n -> if n == 0 then 1 else n * fac (n-1)) _|_
06:25:18 <canseek> I have no idea... D:
06:25:20 <Cale> = (\n -> if n == 0 then 1 else n * _|_ (n-1))
06:25:31 <koeien37> this is not _|_.
06:25:49 <Cale> In particular, this function isn't _|_ because if you give it 0, it will give you 1
06:26:13 <Cale> (but for any other number, it will give _|_)
06:26:25 <canseek> Cale, that makes sense, but still doesn't explain for example why succ on Ints is _|_
06:26:33 <koeien37> it is strict, you mean
06:26:35 <canseek> As passing 1, would result in 2, which doesn't seem right
06:26:57 <koeien37> Ints are represented by machine words
06:27:01 <Cale> canseek: succ on Ints is strict because just knowing that some Int is the succ of another Int doesn't actually tell you anything at all about it
06:27:28 <canseek> Er...
06:27:40 <Cale> So in order to know the first thing about the result of succ n where n is an Int, you must know at least a little bit about n
06:28:20 <canseek> My brain hurts this is so confusing D:
06:28:34 <Cale> However, for natural numbers, knowing that some natural number k is the successor of another is a usable piece of information: you know that it's not 0 then.
06:29:08 <damd> :t foldM
06:29:09 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
06:29:10 <Cale> Let's use:
06:29:17 <Cale> data Nat = Zero | Succ Nat
06:29:25 <Cale> a simple unary representation of naturals
06:29:41 <Cale> So that 3 for instance is written  Succ (Succ (Succ Zero))
06:29:54 <canseek> Ok
06:29:57 <Cale> and let's consider the function
06:30:09 <Cale> add Zero m = m
06:30:19 <Cale> add (Succ n) m = Succ (add n m)
06:31:06 <Cale> Make sense so far?
06:31:20 <c_wraith> I like that you can define infinity with that representation as:  let x = Succ x in x
06:31:45 <canseek> Cale, I think so, go on
06:31:49 <Cale> canseek: okay
06:31:57 <Jafet> > let x = succ x in x
06:31:58 <lambdabot>   * Exception: Prelude.Enum.().succ: bad argument
06:32:03 <Cale> canseek: We can also define an ordering on them...
06:32:16 <Cale> Zero <= m = True
06:33:07 <canseek> Ok
06:33:07 <Cale> (Succ n) <= (Succ m) = n <= m
06:33:14 <Cale> (Succ n) <= Zero = False
06:33:45 <Cale> So, let's try doing some computation, but we'll involve _|_ in the mix.
06:34:43 <Cale> Succ Zero <= Succ (Succ _|_)
06:35:00 <Cale> This matches the second pattern and reduces to
06:35:04 <Cale> Zero <= Succ _|_
06:35:23 <Cale> and then that matches the first pattern, and we get
06:35:24 <Cale> True
06:35:51 <canseek> Ok
06:36:06 <kamatsu> Hey, cool, Succ _|_ sort of resembles infinity
06:36:17 <kamatsu> actually, you don't need the succ
06:36:20 <mauke> fix Succ
06:36:34 <kamatsu> mauke: ah, of course
06:36:44 <Cale> Succ _|_ "resembles" every number which is larger or equal to 1
06:37:26 <Cale> Let's try something else... what do we get when we add (Succ Zero) to _|_ ?
06:37:50 <Cale> add (Succ Zero) _|_
06:37:59 <Cale> = Succ (add Zero _|_)
06:38:07 <Cale> = Succ _|_
06:38:34 <Cale> So we're actually *not* left with _|_
06:38:39 <canseek> Alright I'm happy so far, as Succ _|_ is what was in my head before you even answered your own question
06:38:46 <Cale> The function  add (Succ Zero)  is non-strict.
06:39:21 <canseek> Yeah that makes sense
06:40:08 <Cale> We could even take the least fixed point of  add (Succ Zero)  and we'd get something which looked like  Succ (Succ (Succ (...)))
06:40:48 <canseek> Mmmm
06:40:48 <Cale> @undefine
06:41:14 <Cale> @let add Zero m = m; add (Succ n) m = Succ (add n m)
06:41:15 <lambdabot>  Defined.
06:41:27 <Cale> (I added the definition of Nat from above to lambdabot)
06:41:33 <mauke> hax
06:41:33 <canseek> Hold on
06:41:35 <Cale> > fix (add (Succ Zero))
06:41:37 <lambdabot>   No instance for (GHC.Show.Show L.Nat)
06:41:37 <lambdabot>    arising from a use of `M3259530882...
06:41:42 <Cale> er, right :)
06:41:59 <Cale> @undefine
06:42:01 <Cale> @let add Zero m = m; add (Succ n) m = Succ (add n m)
06:42:02 <lambdabot>  Defined.
06:42:07 <Cale> > Succ Zero
06:42:08 <lambdabot>   Succ Zero
06:42:11 <Cale> > fix (add (Succ Zero))
06:42:13 <lambdabot>   Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Suc...
06:42:29 <Cale> (needed additional instances :)
06:42:56 <ddarius> dolio: I'm curious if you've solved lostman's CT problem (yourself).
06:43:28 <c_wraith> :t Succ
06:43:29 <lambdabot> Nat -> Nat
06:43:31 <Cale> canseek: I'm not sure how much you know about fix and recursion theory though.
06:43:35 <c_wraith> > fix Succ
06:43:36 <lambdabot>   Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Suc...
06:43:47 <canseek> Cale nothing, I'm just trying to think this through though sorry
06:43:51 <Cale> okay :)
06:43:58 <aep> umm where is normalise defined?
06:44:07 <c_wraith> @hoogle normalise
06:44:07 <lambdabot> System.FilePath.Posix normalise :: FilePath -> FilePath
06:44:08 <lambdabot> System.FilePath.Windows normalise :: FilePath -> FilePath
06:44:15 <aep> thanks
06:44:24 <c_wraith> aep: import it as System.FilePath, though
06:44:30 <aep> yeah
06:44:34 <Cale> canseek: fix is an operation which finds the least-defined value which is a fixed point of the function you give it
06:44:51 <Cale> canseek: A fixed point of a function f is a value x such that x = f x
06:45:10 <Cale> For example, 1 is a fixed point of the function f x = x^2
06:45:21 <Cale> (however, so is _|_)
06:46:07 <Cale> canseek: fix can be defined in Haskell as just  fix f = x where x = f x  -- which is very much like the definition I just gave :)
06:46:30 <canseek> Cale oh man that's trippy
06:46:50 <Cale> This fix can be used to write recursive functions without having to give them names
06:46:52 <c_wraith> canseek: laziness is pretty awesome. :)
06:47:06 <Cale> As an example, recall...
06:47:12 <canseek> WAit but
06:47:15 <canseek> x can never be defined
06:47:15 <Cale> okay
06:47:17 <canseek> So that is
06:47:18 <canseek> _|_ right
06:47:20 <Cale> er, hm?
06:47:26 <koeien37> > fix (0:)
06:47:26 <mauke> canseek: why can't it be defined?
06:47:26 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
06:47:27 <Cale> x can be quite defined
06:47:31 <c_wraith> It's only _|_ if f is strict.
06:47:32 <canseek> How so?
06:47:38 <c_wraith> > fix (1+)
06:47:42 <Cale> Let's go through an example.
06:47:42 <lambdabot>   mueval-core: Time limit exceeded
06:47:42 <mauke> canseek: consider f = \_ -> 42
06:47:48 <Cale> Hang on people!
06:47:50 <Cale> hehe
06:47:52 <canseek> Wait wait
06:47:57 * mauke hangs on
06:47:57 <c_wraith> ok, I'm waiting
06:48:08 <Cale> Let's use the standard example of the factorial function
06:48:10 <c_wraith> Cale's the mathematician.   He can take this one. :)
06:48:14 <canseek> My bad
06:48:14 <canseek> I
06:48:18 <canseek> Wasn't thinking
06:48:20 <mauke> but that involves a function value
06:48:26 <Cale> sure
06:48:35 <Cale> It's a good example of a recursive function
06:48:36 <canseek> x can be applied later, my mind
06:48:48 <Cale> So you'd normally write:
06:48:49 <canseek> Completely skipped partial application
06:48:52 <ddarius> Does the fact that adjoints lift to functor categories immediately give the fact that completeness and cocompleteness lift pointwise?
06:48:53 <Cale> (something akin to)
06:49:05 <Cale> fac n = if n == 0 then 1 else n * fac (n-1)
06:49:43 <Cale> Analogously, let's look at what happens when we write  fix (\fac n -> if n == 0 then 1 else n * fac (n-1))
06:50:00 <Cale> Well, this will give us x, where x is defined like:
06:50:06 <Cale> x = (\fac n -> if n == 0 then 1 else n * fac (n-1)) x
06:50:29 <Cale> and then we can apply the lambda
06:50:42 <Cale> x = (\n -> if n == 0 then 1 else n * x (n-1))
06:51:05 <Cale> and rearrange the n over to the other side of the = sign if we want
06:51:10 <Cale> x n = if n == 0 then 1 else n * x (n-1)
06:51:26 <Cale> So, up to a renaming, this is identical to the recursive definition of fac
06:52:05 <canseek> Mmm
06:52:09 <canseek> You lost me a bit there
06:52:15 <canseek> But I get the use of fix overall
06:52:24 <Cale> Which step is problematic?
06:52:41 <Cale> (I don't mind explaining further)
06:53:41 <canseek> Well, you lost me with those descriptions, if you don't mind explaining then, would you mind explaining something else? Back to bottom instead? Because, while I think I understand bottom now
06:53:49 <canseek> I don't understand this:
06:53:50 <Cale> okay
06:54:02 <canseek> http://en.wikibooks.org/wiki/Haskell/Denotational_semantics#Strict_and_Non-Strict_Semantics
06:54:19 <canseek> I'm trying desperately to figure out the succ example, thinking over what you described
06:54:22 <canseek> But I just don't see it
06:54:44 <canseek> (I've got a page open about fix to go over next by the way, just so you know I didn't just ignore you about fix)
06:55:18 <Cale> okay
06:55:37 <c_wraith> canseek: save this link for later, but check it out.  http://www.vex.net/~trebla/haskell/fix.xhtml
06:55:43 <Cale> I can't see the page yet, my crappy router needs to be reset.
06:56:14 <canseek> Rofl
06:56:23 <canseek> Thanks c_wraith, got it open
06:56:49 <Cale> (whenever I have been on a torrent, it seems to accumulate fail until making new connections to things is unbearably slow)
06:57:05 <Cale> (and this condition persists until it's been reset)
06:57:33 <PhilRod> t
06:57:59 <Cale> okay, here it is
06:58:03 <canseek> My routers just as bad Cale, I havfe to restart it every few days or my connection slows to a crawl
06:58:35 <Cale> canseek: So, I've actually given you a counterexample to that being a strict function
06:58:46 <Cale> But for Int it really is strict
06:59:41 <Cale> This is because the only values of type Int are either _|_ or are fully defined numbers
06:59:43 <canseek> The description they give about why _|_ + 1 = _|_, goes way over my head
07:00:03 <canseek> Which is why I'm lost, I've read as much as I could over the C looking operators
07:00:06 <canseek> But it just doesn't make sense
07:00:11 <Cale> Whereas in my Nat type, there are values like Succ (Succ _|_) which are partially defined
07:00:38 <Cale> Okay
07:01:04 <Cale> I guess I'll start from... do you know what a partial ordering is?
07:01:50 <Cale> oh, they describe it further up on that page
07:01:52 <canseek> THe wikibooks article discussed it briefly, I can google it if you like
07:01:55 <canseek> Yeah
07:02:50 <c_wraith> canseek: one thing I think it important to point out is: _|_ doesn't always indicate an error.  It can also indicate a function which just doesn't return because it calculates indefinitely
07:03:16 <canseek> c_wraith: yeah got it, thanks though
07:03:24 <Cale> So every type in Haskell receives a partial order which says that x <= y (they write it with the fancy square <= sign) basically whenever it's possible to replace occurrences of _|_ in x with other values in order to obtain y.
07:03:36 <Gracenotes> either way, if you try evaluating it, you go into a tail spin you can't really come out of
07:04:14 <Cale> So, if we look at the type Bool
07:04:23 <Cale> It has 3 values: _|_, False, and True
07:04:31 <canseek> Ok
07:04:45 <Cale> and _|_ <= False, _|_ <= True, and that's all
07:04:54 <canseek> Hence 'bottom'
07:04:56 <Cale> (under this definedness ordering)
07:04:57 <Cale> yeah
07:04:58 <ddarius> To answer my question, one simply needs to show whether Î”^Jâˆ˜F is essentially Î”F which is the case, so (co)completeness lifts to functor categories because adjoints lift.
07:05:18 <Cale> Now, let's consider the type [Bool]
07:05:28 <Cale> It has _|_ at the bottom again
07:05:41 <Cale> and then right above that, we have [] and _|_ : _|_
07:05:56 <ddarius> âŠ‘
07:06:28 <Cale> and then above _|_ : _|_, we have (False : _|_), (True : _|_), (_|_ : []) and (_|_ : (_|_ : _|_))
07:06:43 <Cale> This would be easier if I could draw you a picture :)
07:06:56 <canseek> I was just about to say, I might see if I can draw it to see if I can understand you
07:07:07 <Peaker> Cale: http://www.skrbl.com/
07:07:11 <ddarius> @google Hasse diagram
07:07:12 <lambdabot> http://en.wikipedia.org/wiki/Hasse_diagram
07:07:13 <lambdabot> Title: Hasse diagram - Wikipedia, the free encyclopedia
07:07:16 <mauke> âŠ‘ is hard to type :-(
07:07:51 <Cale> I just use <= since there's only one ordering that's being discussed.
07:07:58 <ddarius> mauke: I type \sq and then click on it.  I'm not sure what I'd need to type to get just it.
07:08:18 <Berengal> http://en.wikibooks.org/wiki/Haskell/Denotational_semantics has diagrams
07:08:47 <Cale> \sqsubseteq
07:09:28 <mauke> â‰¤ is also too hard
07:09:35 <Cale> Berengal: yeah, there's one which is close to the one I want using [()]
07:09:37 <canseek> Berengal: yeah I saw those, but the list type is a little harder to imagine
07:10:02 <Cale> er, actually, that one has a mistake in it.
07:10:52 <canseek> Oh I see it
07:10:57 <Cale> http://en.wikibooks.org/wiki/File:List-graph.png -- there's a ():[] which should be ():_|_
07:11:15 <Cale> and then above it there's a ():_|_ which is... really out of place
07:11:29 <Cale> Who made this? :)
07:11:47 <canseek> Rofl
07:12:05 <xerox> there are errata and history exactly on that page
07:12:29 <Cale> I haven't loaded that actual page :P
07:12:43 <xerox> hehe
07:12:44 <mauke> too bad <= is overloaded for both â‡ and â‰¤
07:13:11 <Cale> too bad the convention is sort of backward.
07:13:36 <ddarius> How often do people use â‡?
07:13:41 <Cale> <= usually corresponds to ->
07:13:53 <Cale> and => (implication) corresponds to ->
07:14:01 <mauke> huh?
07:14:03 <Cale> (in the right categories)
07:14:30 <Cale> Usually you want arrows pointing in the direction of larger things.
07:14:47 <kpreid> What does âŠ‘ mean in general, as used in that List-graph.png?
07:14:55 <mauke> â‡â†â†’â‡’
07:15:43 <Cale> kpreid: Well, it's all screwed up in that diagram, but x âŠ‘ y is supposed to mean that y can be obtained from x by replacing occurrences of _|_ with various values.
07:16:11 <ddarius> So use âŠ‚ instead of â‡
07:16:21 <Cale> (x is less defined than or equal to y)
07:16:23 <ddarius> Er
07:16:29 <Berengal> Cale: It's not /all/ screwed up, only one branch of it is.
07:16:36 <Cale> well, yeah
07:16:41 <canseek> Cale, that actually makes this whole thing much easier to understand
07:16:45 <canseek> Replacing _|_ I mean
07:16:50 <Cale> yes
07:17:27 <canseek> Hmm
07:17:35 <canseek> Bare with me then, let me re-read that example about succ
07:17:43 <kpreid> Cale: I see
07:17:51 <Cale> So we can think of any evaluation of an expression as starting at _|_ and successively moving upward in the lattice as more and more about the structure of the resulting value is revealed.
07:18:42 <Cale> In this view _|_ just represents any part of the structure which evaluation hasn't revealed to us yet.
07:20:08 <canseek> I'm probably miles off but
07:20:13 * ddarius needs to modify my LaTeX SCIM table to have some symbols it doesn't have, but he doesn't remember which those were.
07:20:17 <canseek> Would that mean that, _|_ + 1 (in that page example) is _|_ because
07:20:33 <Berengal> > undefined + 1
07:20:34 <lambdabot>   * Exception: Prelude.undefined
07:20:40 <canseek> The _|_ in _|_ + 1 hasn't been 'evaluated' yet, therefore _|_ + 1 also cannot be?
07:23:00 <Cale> Well, because there are no Int or Integer values other than _|_ itself and fully-defined numbers, it must be the case that either _|_ + 1 is _|_ or we have that _|_ + 1 is some fully-defined number k
07:24:00 <shapr> Whee!
07:24:16 <Cale> But, if _|_ + 1 was k, then n + 1 would be k for any n, because every function we can define in Haskell preserves the definedness ordering
07:25:30 <Cale> That is, since _|_ <= n for any n, we must have that  _|_ + 1 <= n + 1
07:25:50 <Cale> and if _|_ + 1 = k, this means that k <= n + 1
07:25:54 <ddarius> Can someone type the top symbol, the opposite of âŠ¥?
07:26:01 <Cale> Ï„
07:26:02 <mauke> âŠ¤
07:26:04 <Cale> er
07:26:10 <Cale> no, that's tau
07:26:14 <Jafet> Cale, badum tish
07:26:35 <canseek> I think I get it, k would be a constant, that would be the same for any n, which is impossible
07:26:40 <canseek> Therefore it can only be _|_?
07:26:44 <Cale> yeah
07:26:54 <Cale> It just wouldn't be addition otherwise.
07:27:07 <mauke> TÐ¢Î¤âŠ¤
07:27:18 <kamatsu> can't you just type 'T'
07:27:20 <mauke> choose one
07:27:34 <Cale> But this is a consequence of the fact that if k isn't _|_, then k must be fully defined, and so if k <= n + 1, then k = n+1
07:27:57 <aep> if i have a polymorphic type  T t = A a | B b    how would i refer to T in general?
07:28:03 <Jafet> Strange, my input editor maps \bot to âŠ¤
07:28:08 <mauke> aep: that looks invalid
07:28:15 <aep> err not type.  data
07:28:21 <canseek> Cale, I see I see
07:28:22 <mauke> still invalid
07:28:25 <Cale> But this isn't true for our lazy natural type -- we have lazy naturals which are not _|_ and yet not completely defined.
07:28:29 <aep> um it compiles
07:28:56 <mauke> aep: irc.hs:1:13: Not in scope: type variable `a'
07:29:00 <mauke> irc.hs:1:19: Not in scope: type variable `b'
07:29:15 <aep> err sorry
07:29:16 <canseek> Thanks Cale, you've been extremely patient with me, I appreciate it
07:29:24 <aep> data T a = A a | B a
07:29:28 <Cale> canseek: You're quite welcome
07:29:55 <mauke> aep: T
07:29:58 <canseek> One last question, that won't take any time, what input editor are you talking about? The whole \bot etc
07:30:08 <aep> mauke: well i cant use that as constructor
07:30:16 <kpreid> aep: what do you mean by referring to T in general? where do you want to use it?
07:30:25 <mauke> aep: yes, you can
07:30:32 <aep> i think i'm doing it all wrong. let me elaborate the  long story
07:31:16 <aep> i'm trying to make a monad for passing around a Box. the box has an attribute that defines how flow works
07:31:39 <aep> so i tried making the attribute a polymorphic type
07:32:02 <aep> as in  data MyMonad a = MyMonadGoesWest a | MyMonadGoesEast a
07:32:31 <aep> that's pretty wrong i guess?
07:32:42 <kamatsu> well, how would you define return?
07:32:46 <kamatsu> west or east?
07:32:47 <aep> yeah...
07:32:50 <aep> no idea
07:32:54 <mauke> how would you define join?
07:33:08 <kpreid> aep: maybe you just want the state monad?
07:33:15 <kamatsu> sounds like the state monad to me
07:33:15 <aep> i guess that answers the question if i'm doing it wrong. but how do i do it right?
07:33:22 <Cale> Looks closer to Either to me.
07:33:28 <aep> hum.
07:33:33 <Jafet> @src Either
07:33:34 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
07:33:36 <Cale> but, not quite the same
07:33:41 <aep> yeah it's a state engine.  let me read up on StateT. thanks
07:33:53 <Cale> aep: start with plain State
07:33:56 <aep> aye
07:33:56 <kamatsu> StateT is a transformer, you probably just want State
07:35:33 <canseek> Jafet: what was the input editor you mentioned?
07:35:44 <kpreid> @unmtl State s a
07:35:44 <lambdabot> s -> (a, s)
07:35:46 <Jafet> SCIM, which has a somewhat-working latex mode
07:36:22 <koeien37> that is cool
07:36:25 <koeien37> i didn't know that
07:36:28 <canseek> Ah ok, I'll check it out, thanks Jafet
07:36:51 <Jafet> As I found out though, the database seems to be sloppily made
07:36:59 <koeien37> does it invoke latex?
07:37:09 <kpreid> aep: if you wanted to reimplement State yourself then you would have data MyMonad a = MyMonad (WestOrEast -> (a, WestOrEast)) where data WestOrEast = West | East. But don't do that, just use State :-)
07:37:11 <koeien37> or is it just a mapping ?
07:37:26 <Jafet> It maps some latex sequences to Unicode characters
07:37:39 <Jafet> Well, not sequences. Whatever they're called
07:38:10 <taruti> how do I solve this:
07:38:17 <aep> kpreid: just out of interest, what the heck does that mean? :D
07:40:08 <aep> wouldnt that sort of encapsulate things on every >>= pass?
07:40:21 <taruti> "data D = D { ... ; init :: InitFun; bufSize :: Int } " and init uses the bufSize. Now a user says: "defaultD { bufSize = 100 }" but of course that fails since the "init" will use the *old* bufSize.
07:40:26 <koeien37> â‰¥ 1 Ã—
07:40:34 <koeien37> cool, that works. Thanks
07:41:34 <Saizan> taruti: split the state from the functions that manipulate it
07:41:52 <Saizan> taruti: and make the latter ones take the former as argument
07:42:19 <Saizan> then congrats, you've implemented an OO language :)
07:42:36 <taruti> well it *is* useful in some cases.
07:42:50 <Saizan> yup
07:43:01 * Jafet multiple dispatches on Saizan's momma
07:44:55 <taruti> data D = D { ... ; init :: D -> InitFun; bufSize :: Int }; realInit :: D -> InitFun; realInit d = d init d ?
07:44:55 <taruti> or is there a more sensible way
07:46:09 <nomadmonad> Â´
07:46:21 <nomadmonad> oh, what a statement, sorry about that :)
07:47:43 <Saizan> data DFuns = DF { init :: DState -> InitFun }; data DState = DState { bufSize :: Int }, data D = D DState DFuns
07:48:05 <kpreid> aep: no, because you define >>= (or join) and that's it's job to do the right thing with it
07:48:10 <taruti> Saizan: that will make record updates harder
07:48:31 <taruti> defaultD { fooFun = myFoo, bufSize = 400 }
07:48:39 <kpreid> aep: the point being that the state monad is really a thin wrapper around s -> (a, s)
07:48:49 <aep> kpreid: i see
07:48:49 <kpreid> a function from an old state to a result and a new state
07:49:04 <kpreid> @src >>= State
07:49:04 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
07:49:14 <kpreid> eh, I forget how to do that
07:49:38 <mauke> @src State >>=
07:49:38 <lambdabot> Source not found. It can only be attributed to human error.
07:49:46 <Saizan> taruti: i guess your version was nicer then
07:50:16 <Saizan> taruti: it's more appropriate actually, if init calls some methods you really want it to use the current ones
07:51:08 <Gracenotes> for State: m >>= k  = State $ \s -> let (a, s') = m s in k a s'
07:51:20 <Gracenotes> (dropping the newtypes.. you otherwise need runStates)
07:53:30 <Gracenotes> eh, which for the sake of correctness: m >>= k  = State $ \s -> let (a, s') = runState m s in runState (k a) s'
07:55:16 <benmachine> augh, they've put a load of auxiliary methods in Applicative for base4.2
07:55:23 <benmachine> well by a load I mean two
07:55:31 <benmachine> but two that don't need to be there really
07:55:35 <ddarius> taruti's second version is the recursive record approach.
07:55:40 <benmachine> (same for Alternative)
07:56:56 <ccasin> what sort of error does "read" throw, and how can I catch it?
07:57:08 <kamatsu> try 'reads'
07:57:12 <kamatsu> @type reads
07:57:14 <lambdabot> forall a. (Read a) => String -> [(a, String)]
07:57:25 <kamatsu> oh, wait
07:57:39 <benmachine> there's usually a better way of doing things than throwing and catching errors
07:57:44 <benmachine> (like reads)
07:58:16 <Berengal> reads is a fine function
07:58:29 <benmachine> read throws an error using the 'error' function
07:58:31 <kamatsu> why does reads return a list?
07:58:44 <ccasin> multiple parses, I'm guessing
07:58:48 <benmachine> yes
07:58:56 <kamatsu> example?
07:59:02 <benmachine> there aren't many
07:59:08 <ccasin> which is a little annoying - I want to enforce the "must parse entire string" behavior of read
07:59:13 <benmachine> I think I heard it explained in terms of regular expressions
07:59:21 <benmachine> ccasin: read is implemented in terms of reads
07:59:25 <Polarina> Is it possible to detect if any symbols collide with each other when importing modules?
07:59:45 <Jafet> You get a compile error
07:59:50 <ccasin> benmachine: yeah, I'm not saying it can't be done :)
07:59:54 <Polarina> Jafet: When I use one, yes.
08:00:17 <Jafet> How do you want to detect it then?
08:00:25 <Berengal> > case reads "()  " of {[x, []] -> "Full parse"; [x, y] -> "Partial parse"; _ -> "No parse"}
08:00:26 <lambdabot>   Couldn't match expected type `(a, GHC.Base.String)'
08:00:26 <lambdabot>         against inferre...
08:00:37 <augustss> Polarina: No, there's no tool I know of that detects that.
08:00:39 <Polarina> Jafet: Trying to study a little without looking at referencing documents the whole day.
08:00:44 <Berengal> :/
08:00:48 <Polarina> augustss: Ok.
08:00:51 <Jafet> I'm not sure what that means
08:01:11 <ddarius> augustss: GHC won't give a warning with appropriate options?
08:01:13 <benmachine> > reads "   ()  "
08:01:14 <augustss> Polarina: It's intentional that collisions are allowed until you try to use the symbol.
08:01:14 <lambdabot>   [((),"  ")]
08:01:18 <kamatsu> > reads ""
08:01:20 <lambdabot>   []
08:01:25 <Berengal> > case reads "()  " of {[(x, [])] -> "Full parse"; [(x, y)] -> "Partial parse"; _ -> "No parse"}
08:01:26 <augustss> ddarius: Not that I know.
08:01:26 <lambdabot>   Ambiguous type variable `a' in the constraint:
08:01:26 <lambdabot>    `GHC.Read.Read a'
08:01:26 <lambdabot>      ar...
08:01:30 <ccasin> So, you all are right and I should probably just use reads, but I'm trying to put something together quickly and the types don't work out.  So, is there anyway to actually catch read's type of error?
08:01:37 <Berengal> > case reads "()  " of {[((), [])] -> "Full parse"; [(x, y)] -> "Partial parse"; _ -> "No parse"}
08:01:38 <lambdabot>   "Partial parse"
08:01:39 <Polarina> For example, if I import Data.Map, not qualified, it collides with things in Prelude, but nothing complains unless I actually use something that collides.
08:01:53 <benmachine> ccasin: there's no easy way outside of IO
08:02:01 <Berengal> > case reads "()" of {[((), [])] -> "Full parse"; [(x, y)] -> "Partial parse"; _ -> "No parse"}
08:02:02 <ccasin> benmachine: I'm happy to use IO
08:02:02 <lambdabot>   "Full parse"
08:02:10 <kamatsu> ccasin: yeah, there is
08:02:17 <kamatsu> ccasin: http://hackage.haskell.org/package/spoon
08:02:23 <augustss> Polarina: that's right.  And until you use something, you don't really care.
08:02:24 <ccasin> benmachine: but, I observe the prelude's "catch" doesn't seem to catch this error
08:02:29 <benmachine> ccasin: that was probably better phrased as, there's no easy way, and there's no way outside of IO
08:02:41 <Polarina> augustss: :(
08:02:46 <benmachine> Control.Exception.catch will probably do it but it's a pai
08:02:47 <benmachine> pain
08:02:50 <kamatsu> benmachine: spoons does it outside of IO (somehow)
08:02:58 <Berengal> spoon is an evil hack
08:03:06 <augustss> Polarina: I think it's rather nice
08:03:08 <Berengal> Created to counter other evil hacks...
08:03:14 <benmachine> agreed
08:03:14 <notfancy> Hi everybody
08:03:19 <augustss> spoon is an evil hack
08:03:23 <kamatsu> Oh, looking at spoon source
08:03:27 <kamatsu> "unsafePerformIO"
08:03:28 <c_wraith> kamatsu: unsafePerformIO.  So..  not really outside
08:03:32 <kamatsu> bah
08:03:32 <augustss> ccasin: use reads
08:03:38 <ddarius> It appears not.
08:03:39 <benmachine> ccasin: it's really much easier to do fmap fst . listToMaybe . reads
08:03:47 <benmachine> :t fmap fst . listToMaybe . reads
08:03:48 <lambdabot> forall a. (Read a) => String -> Maybe a
08:04:04 <augustss> that function should be in the prelude
08:04:12 <benmachine> yeah I think it'd be nice
08:04:41 <Berengal> Doesn't force the full parse constraint of read
08:04:47 <benmachine> true
08:04:55 <benmachine> case on reads would do that if you cared
08:04:56 <ccasin> the problem is I don't really want a maybe - I'd just have to throw a more catchable exception because I need to bubble up through a bunch of layers of cruft
08:05:16 <benmachine> suit yourself
08:05:24 <augustss> ccasin: readIO
08:05:27 <benmachine> I mean, Maybes are very good at that sort of thing
08:05:39 <Berengal> @type fmap fst . listToMaybe . filter (null.snd) . reads
08:05:40 <lambdabot> forall a. (Read a) => String -> Maybe a
08:05:59 <ccasin> augustss: thank you, this is perfect
08:07:12 <ccasin> benmachine: yes, I agree, I am an expressive types advocate :)  I'm just in a hurry to test something
08:08:00 <benmachine> ccasin: well, then, Control.Exception
08:08:21 <benmachine> I will be more helpful in a sec
08:08:24 <benmachine> but that's where to start
08:08:30 <benmachine> http://hackage.haskell.org/packages/archive/base/4.2.0.0/doc/html/Control-Exception.html#t%3AException
08:08:39 <benmachine> probably ErrorCall
08:08:56 <benmachine> it depends what exactly you want to do
08:09:25 <benmachine> but the documentation for catch has a decent example
08:09:37 <Polarina> I'll just make it a practice to import everything as qualified.
08:09:40 <ccasin> benmachine: no worries, augustss's readIO is perfect
08:09:47 <augustss> ccasin: but with readIO you can catch it with the regular catch.
08:10:52 <ccasin> yes, I've had trouble with Control.Exception, perhaps since I'm not sure which sort of exception to catch.  But readIO is just the thing, thanks.
08:11:10 <benmachine> oh
08:11:11 <benmachine> k
08:11:54 <benmachine> (still think Maybe is the way to go :P you just replace a few $s with <$>s and you are sorted)
08:12:01 <aep> is there any haskell package for color printing to commandline?
08:12:08 <benmachine> (but I suppose sometimes that may be more hassle than it's worth
08:12:11 <benmachine> )
08:12:20 <opqdonut> aep: vty
08:12:24 <opqdonut> @hackage vty
08:12:24 <lambdabot> http://hackage.haskell.org/package/vty
08:12:24 <aep> thanks
08:12:52 <aep> oh not a full blown gui, just some escape code helpers
08:13:01 <opqdonut> well vty has those too
08:13:13 <aep> hm ok
08:13:16 <ddarius> @hackage ansi-terminal
08:13:17 <lambdabot> http://hackage.haskell.org/package/ansi-terminal
08:13:18 <opqdonut> module Graphics.Vty.Inline
08:13:24 <ddarius> @hackage ansi-wl-pprint
08:13:24 <lambdabot> http://hackage.haskell.org/package/ansi-wl-pprint
08:13:36 <opqdonut> ok, those might be simpler
08:13:42 <aep> nice
08:18:04 <notfancy> I'm stumped with something I can't quite tease apart
08:18:23 <notfancy> I'm trying to express a function generating a list
08:18:41 <notfancy> something like xs = e : f (xs **so far**)
08:19:11 <notfancy> namely, e : f [e] : f [e, f [e]] : f [e, f [e], f [e, f[e]]] and so on
08:19:16 <Polarina> ...
08:19:46 <BONUS> what would be the type of your function
08:19:51 <notfancy> I've tried xs = e : (map f . tail . inits $ xs)
08:20:04 <notfancy> BONUS: ([a] -> a) -> a -> [a]
08:20:34 <notfancy> From what I see, inits forces one tail too many for it to work
08:21:00 <BONUS> hmm, i'm not quite getting what it would do
08:21:04 <BONUS> what would it return for some sample inputs
08:21:37 <notfancy> I'm reading http://arxiv.org/PS_cache/arxiv/pdf/0912/0912.2394v1.pdf
08:21:52 <notfancy> And the sequence in question is A090822 (the second one in the paper)
08:22:18 <notfancy> which is defined as the list of values of a function on the initial segments of that very list
08:22:39 <BONUS> the Gijswijt sequence?
08:22:44 <notfancy> Yeah
08:25:08 <Polarina> Learn you a haskell is not clear enough on Data.Map. :(
08:25:18 <BONUS> hmm im not quite understanding where the string Y comes from
08:25:26 <BONUS> Polarina: what are you confused about?
08:25:33 <ddarius> > let xs = e:(map f . tail . inits xs) in xs
08:25:34 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
08:25:34 <lambdabot>         against inferred ...
08:25:39 <ddarius> > let xs = x:(map f . tail . inits xs) in xs
08:25:40 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
08:25:40 <lambdabot>         against inferred ...
08:25:45 <Polarina> BONUS: How to define a function by providing explicit type. I don't see what type to use.
08:26:19 <ddarius> > let xs = x:(map f . tail . inits $ xs) in xs
08:26:23 <lambdabot>   mueval-core: Time limit exceeded
08:26:25 <Jafet> @genie (a -> b) -> (b -> c) -> (a -> c)
08:26:26 <lambdabot> Unknown command, try @list
08:26:28 <ddarius> > let xs = x:(map f . tail . inits $ xs) in take 4 xs
08:26:29 <BONUS> well a Map k v is a map from k to v
08:26:32 <lambdabot>   mueval-core: Time limit exceeded
08:26:34 <Jafet> @djinn (a -> b) -> (b -> c) -> (a -> c)
08:26:34 <lambdabot> f a b c = b (a c)
08:26:35 <ddarius> > let xs = x:(map f . tail . inits $ xs) in take 2 xs
08:26:39 <lambdabot>   mueval-core: Time limit exceeded
08:26:43 <ddarius> > inits [1,2,3]
08:26:44 <BONUS> look at some of the types of the functions in Data.Map maybe?
08:26:44 <lambdabot>   [[],[1],[1,2],[1,2,3]]
08:27:06 <Polarina> BONUS: I am importing as qualified and nothing seems to work when qualified. :(
08:27:26 <BONUS> for instance it says how to make your own fromList
08:27:29 <BONUS> and what type it has
08:27:43 <BONUS> what does your import statement look like?
08:27:45 <Polarina> And :t in ghci assumes non-qualification when showing type.
08:27:56 <Polarina> import qualified Data.Map
08:28:03 <Berengal> notfancy: iterate' f x = let {go n = f (take n s) : go (n + 1); s = x : go 1 in s
08:28:04 <opqdonut> notfancy: iterate (\x -> x ++ [f x]) works
08:28:10 <mauke> import qualified Data.Map as M
08:28:18 <Polarina> I don't want the "as
08:28:23 <BONUS> Polarina: ummm but in the tutorial the import statement "import qualified Dta.Map as Map" is used
08:28:24 <opqdonut> er, iterate (\x -> x ++ [f x]) [e]
08:28:26 <BONUS> ah
08:28:29 <BONUS> well then you have to change your types accordingly
08:28:49 <Astro> hrm, I'm having big trouble writing binary data to files in 6.12, it always expands utf8 multi-byte characters even if I use binary files, write from pointers or bytestrings, any hints?
08:28:52 <Polarina> I have. :S
08:28:59 <notfancy> Berngal, opqdonut, thank you!
08:29:00 <mauke> then what's the problem?
08:29:06 <Polarina>     `Data.Map.Map' is not applied to enough type arguments
08:29:06 <Polarina>     Expected kind `??', but `Data.Map.Map' has kind `* -> * -> *'
08:29:15 <opqdonut> of course the performance for my version is probably horrible
08:29:15 <mauke> missing type arguments
08:29:23 <Polarina> What type arguments?
08:29:24 <opqdonut> but it's the simples obviously working solution :)
08:29:29 <mauke> this has nothing to do with qualified imports
08:29:30 <BONUS> Polarina: if you see the type of Map.fromList in the tutorial
08:29:31 <BONUS> it says
08:29:34 <Berengal> Mine is probably a bit faster... possibly
08:29:38 <notfancy> Berengal, I was not very keen on using an explicit index, even though I found that take is lazier than tails
08:29:43 <BONUS> Map.fromList :: (Ord k) => [(k, v)] -> Map.Map k v
08:29:46 <BONUS> you left out the k v
08:29:52 <Polarina> Oh.
08:29:53 <Polarina> Thanks.
08:30:03 <notfancy> opqdonut, point-freeness got me ;-)
08:30:10 <elt0n> hey i'm new to haskell and I'm wondering what this message means: You cannot give a type signature for an imported value
08:30:24 <Berengal> notfancy: The alternative is to append the result to the end of the list, which has pretty horrible complexity...
08:30:28 <interferon> is <$> just a lifted $ ?
08:30:35 <Polarina> elt0n: Code example, please. :)
08:30:43 <mauke> interferon: <$> is fmap
08:30:45 <opqdonut> :t <$> -- not quiter
08:30:46 <lambdabot> parse error on input `<$>'
08:30:46 <kamatsu> interferon: <$> is fmap
08:30:54 <interferon> oh
08:30:58 <kamatsu> :t (<$>)
08:30:59 <opqdonut> <*> is a bit like lifted $
08:31:00 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:31:01 <interferon> lifted fmap or regular fmap?
08:31:05 <opqdonut> :t (<*>)
08:31:06 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
08:31:08 <opqdonut> regular.
08:31:11 <mauke> @src (<$>)
08:31:12 <lambdabot> f <$> a = fmap f a
08:31:13 <kamatsu> interferon: it's identical to fmap
08:31:15 * Polarina hates Monads.
08:31:16 <elt0n> http://pastebin.com/d205fd5b
08:31:17 <interferon> i think i don't really understand fmap
08:31:22 <Berengal> interferon: <*> is a lifted $
08:31:24 <interferon> on sequences, i understand
08:31:26 <elt0n> Polarina, here it is
08:31:28 <kamatsu> Polarina: Monads are great
08:31:29 <interferon> but what does it mean for other types?
08:31:48 <dons> full of weasel words, but significant, http://flyingfrogblog.blogspot.com/2010/01/naive-parallelization-c-vs-haskell.html
08:31:49 <mauke> interferon: the same thing :-)
08:31:50 <Berengal> interferon: It changes the contents without changing the structure
08:31:55 <Raevel> elt0n: i'm guessing you need to indent the monad function declarations
08:31:55 <mauke> @index when
08:31:55 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
08:31:55 <Polarina> elt0n: And what's the exact error message?
08:31:56 <dons> "These benefits are well worth this level of performance degradation in many applications so parallel Haskell would seem to have immediate practical applications."
08:31:57 <interferon> is it that simple?
08:32:08 <dons> talk about damning with faint praise.
08:32:15 <mauke> elt0n: you're trying to redefine functions from Monad, I think
08:32:16 <dons> Heffalump: ^ :)
08:32:37 <elt0n> Polarina, http://pastebin.com/d31e7ff33
08:32:37 <Berengal> dons: Oh yeah, that one was rather interesting
08:32:38 <Heffalump> dons: do you think he's feeling ok?
08:32:44 <dons> he might be sick.
08:32:44 <elt0n> mauke, hmm good idea
08:32:58 <Polarina> dons: Does it test paralellization with ghc 6.12?
08:33:00 <dons> headline! jdh30 sez "parallel Haskell would seem to have immediate practical applications"
08:33:16 <Polarina> elt0n: You need to define mzero some expression.
08:33:17 <dons> @remember jdh30 parallel Haskell would seem to have immediate practical applications
08:33:18 <lambdabot> Done.
08:33:21 <dons> mwhaha
08:33:36 <ddarius> > let xs = 1:map sum (tail (inits xs)) in xs
08:33:40 <lambdabot>   mueval-core: Time limit exceeded
08:33:45 <dons> Polarina: unsure.
08:34:18 <elt0n> Polarina, ahh ok thx
08:34:20 <interferon> has anyone here read "Algorithms: A Functional Programming Approach"?
08:34:33 <interferon> or something similar that they can vouch for?
08:35:02 <ddarius> @src inits
08:35:02 <lambdabot> inits []     =  [[]]
08:35:02 <lambdabot> inits (x:xs) =  [[]] ++ map (x:) (inits xs)
08:35:05 <Berengal> dons: There still does seem to be some issues with parallelism in haskell, particularly the last-core slowdown issue
08:35:29 <Berengal> But it's still better than the alternatives :)
08:35:42 <ddarius> > let inits' ~(x:xs) = [[]] ++ map (x:) (inits' xs); xs = 1:map sum (tail (inits xs)) in xs
08:35:43 <gwern> oh noes! there's no quickcheck Arbitrary instance for Complex!
08:35:43 <dons> note, linux-spec.
08:35:46 <lambdabot>   mueval-core: Time limit exceeded
08:35:54 <dons> remember the famous "no last core slowdown" on the mac?
08:35:56 <Berengal> Oh, yes indeed
08:36:14 <Berengal> But still: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15957
08:36:53 <Berengal> (However, note that my last timing was with n+1 cores
08:36:54 <Polarina> interferon: I would, if I could download it.
08:36:57 <kamatsu> dons: good read, thanks for the link. Posted to reddit yet?
08:37:01 <Polarina> s/would/would've/
08:37:03 <ddarius> > let inits' ~(x:xs) = [[]] ++ map (x:) (inits' xs); xs = 1:map sum (tail (inits' xs)) in xs
08:37:04 <lambdabot>   [1,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,13107...
08:37:08 <ddarius> There we go.
08:37:17 <ddarius> > let inits' ~(x:xs) = [[]] ++ map (x:) (inits' xs); xs = x:map f (tail (inits' xs)) in xs
08:37:19 <lambdabot>   [x,f [x],f [x,f [x]],f [x,f [x],f [x,f [x]]],f [x,f [x],f [x,f [x]],f [x,f ...
08:37:30 <dons> kamatsu: i put it on the  haskell reddit.
08:37:39 <dons> Berengal: is there a bug ticket for this btw?
08:37:54 <dons> Berengal: i'm not sure if "The last core slowdown" has an issue in the bug tracker-- but it should.
08:38:04 <Berengal> dons: It does, let me look it up for you
08:38:04 <dons> just to document what is known
08:38:13 <dons> you might add your test case.
08:38:39 <dons> my japanese RWH arrived!
08:38:43 <Berengal> dons: http://hackage.haskell.org/trac/ghc/ticket/3553
08:38:50 <ddarius> dons: What are you going to do with it?
08:38:57 <dons> keep it :)
08:39:00 <BONUS> ^______^
08:39:03 <medfly> why is it Japanese?
08:39:13 <dons> RWH has been translated
08:39:18 <medfly> ah
08:39:19 <notfancy> It's somewhat surreal, that post
08:39:20 <mauke> I don't know, somehow that's what the people in Japan speak
08:39:22 <notfancy> "we see the incredible result that the fastest program overall is the least optimized Haskell"
08:39:24 <dons> this is the author's copy.
08:39:31 <dons> notfancy: he's a wacky guy.
08:39:50 <Berengal> dons: Also, I don't have a ghc-trac account, and the register page is 404
08:39:57 <dons> grr. my dns is out of date since the hackage move.
08:40:05 <pikhq> dons: Why'd you purchase a Japanese copy of RWH?
08:40:15 <dons> pikhq: i was sent a copy by the publisher.
08:40:29 <pikhq> dons: Fair enough.
08:40:46 <BONUS> if you already know haskell, what better way to learn japanese than to read a haskell book in japanese
08:40:54 <dons> hehe good idea
08:41:01 <dons> what's the character for "monad" ?
08:41:05 <pikhq> BONUS: ... That's freaking hard to do, y'know.
08:41:06 * dons looks
08:41:10 <BONUS> haha
08:41:11 <kamatsu> dons: There won't be one
08:41:15 <BONUS> good luck typing it out
08:41:19 <notfancy> dons: I know jdh
08:41:23 <pikhq> Though at least much of the technical verbiage in this context is... English.
08:41:24 <kamatsu> dons: Japanese has phonetic characters too
08:41:35 <ddarius> notfancy: Your initial solution to the sequence problem using inits was good.  The problem was simply that inits is slightly too strict.  opqdonut's solution using iterate is grotty.
08:41:37 <notfancy> I had the pleasure to watch his meltdown in slow-motion
08:41:38 <Jafet> Mo-na-
08:41:40 * Jafet shades
08:41:42 <Jafet> -de-su!
08:41:44 <BONUS> pikhq: i already knew english and i read a haskell book in english and i learned haskell
08:41:45 <kamatsu> monado
08:41:51 <BONUS> so i don't know why it shouldn't work the other way around
08:42:07 <pikhq> dons: I'm going to guess it's written out as "monado" in katakana or "monad" in romaji.
08:42:14 <pikhq> BONUS: ... Japanese is a hard language to read.
08:42:19 <opqdonut> ddarius: grotty?
08:42:23 <mauke> ãƒ¢ãƒŠãƒ‰
08:42:24 <BONUS> so is haskell if you don't know it, hahah
08:42:27 <notfancy> ddarius: I've copied your last definition for later inspection
08:42:37 <pikhq> The spoken language and the grammar aren't too hard. But reading it is very difficult.
08:42:38 <dons> notfancy: slow motion ... in person?
08:42:46 <kamatsu> hmm, like Haskell, Japanese grammar is made up of a few very simple concepts
08:42:47 * dons tries to read the subtext of notfancy's comment.
08:42:52 <Jafet> BONUS, english -> (english -> haskell) -> haskell and haskell -> (japanese -> haskell) -> japanese don't have the same type
08:43:07 <pikhq> kamatsu: Quite true.
08:43:08 <ddarius> notfancy: It's identical to yours, the only difference is it uses a variant of inits that only works on infinite lists but can therefore be slightly lazier since it doesn't need to check for the end of the list.
08:43:12 <kamatsu> also like Haskell, its meaning can be clouded to those who don't know it due to whacky characters
08:43:14 <notfancy> dons: not in person, online, five or six years ago he started posting on the OCaml list
08:43:19 <notfancy> He was rather insightful
08:43:26 <dons> oh, of course. we all know him :)
08:43:33 <ddarius> opqdonut: The performance issues and their source (or were you wondering about the meaning of "grotty")
08:43:34 <BONUS> i imagine RWH in japanese is like: Advancedu ribrary designu: buirding a Broom firter
08:43:49 <kamatsu> BONUS: lol!
08:43:51 <BONUS> Jafet: haha
08:43:52 <opqdonut> ddarius: the meaning, i know it was a bad solution :)
08:44:00 <ddarius> @google define:grotty
08:44:01 <lambdabot> No Result Found.
08:44:11 <kamatsu> I learnt Java from reading a Japanese book
08:44:12 <medfly> @wn grotty
08:44:14 <lambdabot> *** "grotty" wn "WordNet (r) 2.0"
08:44:14 <lambdabot> grotty
08:44:14 <lambdabot>      adj : very unpleasant or offensive ; "a grotty little play"
08:44:14 <lambdabot>      [also: {grottiest}, {grottier}]
08:44:18 <dons> anyway, good to see some parallel haskell press.
08:44:22 <dons> kamatsu: hehe
08:44:25 <kamatsu> it was really weird to see anime characters explaining composition over inheritance
08:44:28 <opqdonut> http://www.urbandictionary.com/define.php?term=grotty
08:44:39 <pikhq> BONUS: "Adobansedo raiburari desainu: birudeingu ei Buruumu firuta."
08:44:43 <opqdonut> medfly: thanks :)
08:44:54 <opqdonut> Buruumu sounds cute
08:44:56 <mauke> expert romaji mangler
08:45:12 <pikhq> 4 years of Japanese, I *better* get some use out of it. :P
08:45:31 <kamatsu> pikhq: http://lambda.bugyo.tk/cdr/mwl/
08:45:37 <kamatsu> Manga de wakaru lisp!
08:45:39 <BONUS> haha
08:45:41 <mauke> .oO( buruuma filter )
08:45:41 <medfly> man, very few coding related terms have words in my language and the ones that do are rarely used
08:45:46 <pikhq> kamatsu: That was quite amusing.
08:45:47 <Jafet> I imagine Japanese programmers just use English
08:45:56 <kamatsu> Yukihiro matsumoto does
08:46:08 <kamatsu> he's the only japanese programmer i know of
08:46:09 * ddarius recently met a Japanese programmer.
08:46:13 <opqdonut> does he design bloom filters?
08:46:15 <notfancy> dons: now I know what is the sound of somebody eating their own words
08:46:21 <dons> notfancy: ah i think i see. so he started off quite coherent, but seemed to meltdown over a few years?
08:46:23 <notfancy> dons: it's rather sad
08:46:24 <pikhq> Jafet: *Most* programmers just use English.
08:46:29 <pikhq> It's kinda the lingua franca.
08:46:38 <notfancy> dons: right, he shilled out rather progressively
08:46:39 <opqdonut> I wonder if anyone has learnt Java from a Javanese book
08:46:41 <opqdonut> (sorry)
08:46:42 <ddarius> Where "most" very, very closely approximates "all"
08:46:45 <kamatsu> I even daresay *American* english
08:46:52 <kamatsu> opqdonut: unfortunately the language there is Bahasa Indonesia
08:46:58 <dons> oh, that's sad. i've only seen the last couple of years, which hasn't been so much fun.
08:47:10 <pikhq> kamatsu: I'd go with "bizarre hybrid of American and British English".
08:47:14 <medfly> lol!
08:47:23 <notfancy> dons: that's the problem with people that get invested as the years pass, I'm afraid
08:47:24 <kamatsu> pikhq: Perhaps
08:47:35 <pikhq> I know that that's what *I* use, at least.
08:47:37 <dons> everyone know that ICFP is in Japan next year?
08:47:46 <kamatsu> I remember on reddit once they did a comparison of curse word count in various code bases
08:47:48 <notfancy> dons: as you see, I'm trying to de-invest myself from OCaml ;-)
08:47:49 <medfly> what use is that knowledge
08:47:52 <ddarius> Next year meaning this year or 2011?
08:47:55 <dons> 2011
08:47:58 <dons> 2010 is Baltimore.
08:48:01 <kamatsu> Haskell had the lowest 'fuck' count
08:48:08 <ddarius> What month for 2010?
08:48:14 <dons> notfancy: that's an interesting observation.
08:48:20 <dons> ddarius: Sep-Oct
08:48:32 <kamatsu> I mentioned that because Haskell started in england, everyone here should say 'bollocks'
08:48:41 <notfancy> blimey!
08:48:43 <BONUS> any cool haskell events this summer? i was thinking of visiting the US in the summer
08:48:48 <notfancy> oh dear!
08:49:04 <pikhq> kamatsu: Fiku vin.
08:49:06 <pikhq> :P
08:49:25 <kamatsu> pikhq: esperanto?
08:49:28 <kamatsu> is that esperanto?
08:49:36 <pikhq> kamatsu: Jes.
08:50:00 <kamatsu> Mi ne parolas Esperanton
08:50:18 <pikhq> Malbone.
08:50:40 <mauke> mi ne komprenas
08:50:55 <mauke> vi estas la sola esperantisto kiun mi renkontas
08:50:57 <pikhq> KOMPRENU!
08:51:12 <damd> lÃ¤get annars dÃ¥
08:51:17 <pikhq> Interesa.
08:51:26 * mauke blames this "esperanto phrasebook"
08:51:35 <pikhq> Heheh.
08:51:36 <kamatsu> nihongo to eigo wa daijoubu dakedo, esperantogo(?) ga zenzen wakaranaindayo.
08:52:06 <aep> um i need to parse a file in the format  key\nvalue\nkey\nvalue.   would do it with a quick DFA, but haskell doesnt _have_ that. what do i do? :(
08:52:06 <kamatsu> i don't have japanese IME on this computer =(
08:52:16 <pikhq> kamatsu: Zan nen da ne. Esperantogo wa totemo omoshiroii dayo...
08:52:23 <pikhq> I, too, lack an IME.
08:52:31 <mauke> warum sprechen hier alle auslÃ¤ndisch?
08:52:46 <pikhq> And my kanji's gone to shit, what with the "not having studied for 2 years" thing.
08:54:14 <kamatsu> pikhq: jitsu wa, sono gengo ga dasoku da to to omouyone.
08:54:28 <medfly> this channel is full of anime fanbois.
08:54:37 <mauke> buÅoÅtopu min per kulero
08:54:43 <pikhq> medfly: I started watching anime after I stated learning Japanese.
08:54:54 <kamatsu> i don't watch anime at all, although I speak Japanese
08:54:54 <Berengal> aep: map snd . filter (odd . fst) . zip [1..] . zip`ap`tail . lines
08:54:58 <pikhq> s/stated/started/
08:55:19 <pikhq> Berengal: Ah, the god of consecutive numbers. zip`ap`tail.
08:55:24 <pikhq> :)
08:55:27 <mauke> http://pbfcomics.com/?cid=PBF071-Weeaboo.gif
08:55:46 <aep> Berengal: uuuh i need a minute to read up on that. thanks! :D
08:55:50 <Berengal> pikhq: The zip-join-ap triumverate is surprisingly versatile :P
08:55:58 <pikhq> Berengal: :)
08:56:23 <elt0n> Polarina, hey i just realized that MonadPlus already exists...but how can i import it?
08:56:36 <Polarina> elt0n: Do you know the path?
08:56:39 <Berengal> aep: It might not work. I haven't tested it...
08:56:46 <Twey> @src ap
08:56:46 <lambdabot> ap = liftM2 id
08:56:48 <mauke> elt0n: it's not a separate module
08:56:58 <mauke> 'import Control.Monad'
08:56:59 <Twey> Ah, of course
08:57:04 <Berengal> > map snd . filter (odd . fst) . zip [1..] . zip`ap`tail . lines $ "foo\nbar\nfoo2\nbar2\nfoo3\nbar3\n"
08:57:05 <lambdabot>   Precedence parsing error
08:57:05 <lambdabot>      cannot mix `L..' [infixr 9] and `Control.Mona...
08:57:13 <medfly> this channel is like a collection of anything nerdy
08:57:15 <gwern> ah, I know. I'll see if someone has already defined a Complex qc instance using 'find . -name "*.hs" -exec grep "instance Arbitrary Complex" {} \;;'
08:57:18 <gwern> good ol find!
08:57:21 <Berengal> > (map snd . filter (odd . fst) . zip [1..] . zip`ap`tail . lines) $ "foo\nbar\nfoo2\nbar2\nfoo3\nbar3\n"
08:57:22 <lambdabot>   Precedence parsing error
08:57:22 <lambdabot>      cannot mix `L..' [infixr 9] and `Control.Mona...
08:57:23 <gwern> is there anything it can't do?
08:57:23 <elt0n> mauke, and than Monad and MonadPlus is available?
08:57:30 <Berengal> > (map snd . filter (odd . fst) . zip [1..] . (zip`ap`tail) . lines) $ "foo\nbar\nfoo2\nbar2\nfoo3\nbar3\n"
08:57:31 <lambdabot>   [("foo","bar"),("foo2","bar2"),("foo3","bar3")]
08:57:32 <aep> Berengal: i get :1:46: Not in scope: `ap'
08:57:35 <mauke> gwern: needs more grep -r. or ack.
08:57:38 <Berengal> aep: Control.Monad
08:57:39 <mauke> elt0n: yes
08:57:41 <aep> ah
08:57:49 <aep> err forgot how to do that in ghci
08:57:53 <gwern> mauke: grep -r is slow. also wouldn't it check every file?
08:57:54 <Berengal> :m +
08:57:58 <elt0n> ah mauke thx it works
08:58:11 <kmc> bollocks
08:58:12 <mauke> gwern: yes (but ack wouldn't)
08:58:21 <gwern> I'd have to install ack tho
08:58:23 <mauke> aep: 'import Control.Monad'
08:58:24 <kmc> :t zip`ap`tail
08:58:25 <lambdabot> forall b. [b] -> [(b, b)]
08:58:40 <mauke> gwern: that's a good idea in general :-)
08:58:40 <aep> mauke: ghci cant do that
08:58:45 <mauke> aep: yes, it can
08:58:47 <dino-_> find with -exec to do the grep may help
08:58:48 <Berengal> aep: :m +Control.Monad
08:58:49 <kmc> @unpl ap zip tail
08:58:50 <lambdabot> (zip >>= \ b -> tail >>= \ a -> return (b a))
08:58:55 <aep> mauke: <interactive>:1:0: parse error on input `import'
08:58:59 <aep> Berengal: thanks
08:59:02 <mauke> aep: ah, your ghci is too old then
08:59:06 <aep> oh
08:59:18 <elt0n> mauke, and can you tell me in which module Alg is defined?
08:59:38 <mauke> elt0n: I've never heard of Alg
08:59:48 <kamatsu> @hoogle alg
08:59:50 <lambdabot> Data.Data AlgConstr :: ConIndex -> ConstrRep
08:59:50 <lambdabot> Network.Browser AlgMD5 :: Algorithm
08:59:50 <lambdabot> Network.Browser AlgMD5sess :: Algorithm
09:00:13 <aep> waa.  "No instance for (Monad ((->) [String])) arising from a use of `ap' at <interactive>:1:45-55"
09:00:26 <mauke> aep: import Control.Monad.Instances
09:00:28 <Berengal> aep: Control.Monad.Instances -_-
09:00:35 <mauke> or .Reader
09:00:49 <aep> ah!  sorry
09:02:18 <aep> well it works, but i'm still clueless why :D
09:02:20 <elt0n> mauke, ok seems to be a bug in my code
09:02:44 <Berengal> aep: Have fun figuring it out :P
09:03:05 <aep> yeah ;)
09:03:25 <elt0n> @hoogle Parser
09:03:25 <lambdabot> module Language.Haskell.Parser
09:03:26 <lambdabot> Text.Parsec.ByteString type Parser = Parsec ByteString ()
09:03:26 <lambdabot> Text.Parsec.String type Parser = Parsec String ()
09:03:32 <Berengal> aep: map snd . filter (odd . fst) . zip [1..] simply drops every other item from the list, by the way...
09:04:00 <opqdonut> evens is still not in Prelude?
09:04:03 <opqdonut> @hoogle evens
09:04:03 <lambdabot> No results found
09:04:06 <opqdonut> :/
09:04:12 <taruti> I really wish the time package would be more modular. Now it is either a large superfluous package as a dependency or using old-time or clock :(
09:04:19 <Berengal> aep: ap f g x = f x (g x) for the function monad
09:04:41 <mauke> http://mauke.ath.cx/tmp/flow.png
09:04:41 <opqdonut> > evens [1..]
09:04:42 <lambdabot>   Not in scope: `evens'
09:05:35 <opqdonut> @let evens (x:xs) = x:odds xs; evens [] = []; odds (x:xs) = evens xs; odds [] = []
09:05:36 <lambdabot>  Defined.
09:05:41 <opqdonut> > evens [1..]
09:05:42 <lambdabot>   [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
09:05:44 <gwern> hum. on my entire hard drive, no Complex arbitrary instances
09:05:46 <opqdonut> yay
09:05:47 <gwern> frustrting
09:06:03 <notfancy> Well, I'm off to lunch
09:06:08 <notfancy> Thank you everybody
09:06:18 <dons> ciao notfancy
09:07:16 <opqdonut> > uncurry zip . evens *** odds . lines $ "foo\nbar\nfoo2\nbar2\nfoo3\nbar3\n"
09:07:17 <lambdabot>   Couldn't match expected type `([a], [b])'
09:07:17 <lambdabot>         against inferred type `[t]'
09:07:30 <opqdonut> > uncurry zip . (evens &&& odds) . lines $ "foo\nbar\nfoo2\nbar2\nfoo3\nbar3\n"
09:07:31 <lambdabot>   [("foo","bar"),("foo2","bar2"),("foo3","bar3")]
09:07:49 <opqdonut> aep: ^ a simpler but still point-free definition
09:08:17 <opqdonut> the pointful version would be "f x = zip (evens x) (odds x)"
09:08:26 <opqdonut> which is pretty legible already
09:08:43 <mauke> did someone say liftM2 zip evens odds?
09:09:06 <opqdonut> good pointr
09:09:07 <opqdonut> -r
09:09:14 <opqdonut> heh, point
09:09:47 <aep> my head just exploded trying to decipher (zip`ap`tail)
09:09:59 <opqdonut> hehe
09:10:02 <opqdonut> that tends to happen
09:10:09 <opqdonut> @quote zip.ap.tail
09:10:10 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
09:10:12 <IceDane> Polarina: SÃ¦ll.
09:10:16 <Berengal> aep: ap is just the S combinator
09:10:21 <Polarina> IceDane: HÃ¦!
09:10:26 <aep> Berengal: what?
09:10:27 <mauke> whÃ¦t
09:10:37 <IceDane> Yes, we are foreigners
09:10:38 <Berengal> aep: in SKI combinator calculus
09:10:47 <aep> Berengal: um
09:10:49 <aep> what?
09:10:52 <mauke> aep: S f g x = f x (g x)
09:11:09 <Berengal> aep: I = \x -> x; K = \x -> \y -> x, S = \f -> \g -> \x -> f x (g x)
09:11:17 <Polarina> IceDane: HvaÃ° segist? :P
09:11:19 <Berengal> aep: It's turing compelte
09:11:19 <xerox> > ap (f :: Expr -> Expr -> Expr) g x
09:11:20 <lambdabot>   f x (g x)
09:11:21 <xerox> > (=<<) (f :: Expr -> Expr -> Expr) g x
09:11:22 <lambdabot>   f (g x) x
09:11:29 <mauke> zip`ap`tail = ap zip tail = \x -> zip x (tail x)
09:11:52 <aep> does that just mean:  run one function and apply the result to another?
09:11:56 <IceDane> Haha - ekki mikiÃ°. En held ekki aÃ° Ã¾eim lÃ­tist vel Ã¡ Ã¾aÃ° aÃ° viÃ° tÃ¶lum Ã­slensku hÃ©rna..
09:12:13 <Polarina> IceDane: ÃžaÃ° yrÃ°i ekki fyrsta skipti, er svo sem alveg Ã­ lagi. :)
09:12:15 <Berengal> aep: Basically, but the other function also gets the original value
09:12:21 <IceDane> NÃº jÃ¦ja
09:12:32 <IceDane> Eru fleiri ?
09:12:35 <damd> sug min kuk
09:12:48 <augustss> Berengal: You don't need 'I'
09:12:49 <Polarina> IceDane: Ã‰g hef sÃ©Ã° tvo aÃ°ra, a.m.k.
09:12:51 <Raevel> :-(
09:13:01 <IceDane> Eru Ã¾eir frÃ¡ huga Ã¾Ã¡ eÃ°a?
09:13:09 <aep> Berengal: so you're ziping the list with the same list shifted by one?
09:13:17 <Berengal> augustss: All you need is lambda
09:13:23 <Berengal> aep: Yep
09:13:24 <mauke> s/ambda/ove/
09:13:24 <Polarina> IceDane: Nei, Ã©g kom hÃ©r bara einn daginn hÃ©r og spurÃ°i hvort eitthverjir Ã­slendingar vÃ¦ru hÃ©r.
09:13:26 <augustss> Berengal: I = S K K
09:13:31 <IceDane> JÃ¡ okay
09:13:42 <mauke> no, S K S!
09:13:51 <IceDane> SkrifaÃ° haskell lengi eÃ°a?
09:13:59 <Berengal> S K I
09:14:06 <Polarina> IceDane: Er frekar nÃ½r, en hef Ã¶ggulittla reynslu.
09:14:08 <mauke> Berengal: zomg recursion
09:14:17 <Polarina> IceDane: MÃ©r finnst Ã¾etta bara skemmtilegt fyrst og fremst.
09:14:25 <Berengal> mauke: 'cept not really :P
09:14:39 <IceDane> JÃ¡, sama hÃ©r. Ã–ll Ã¾essi tungumÃ¡l meÃ° sama syntaxinn eru ekkert skemmtileg
09:14:40 <mauke> Y (S K)
09:14:50 <IceDane> Ãžegar maÃ°ur er alveg "what the hell" er Ã¾etta skemmtilegt
09:14:50 <Polarina> IceDane: NÃ¡kvÃ¦mlega! :D
09:15:30 <kmc> is this #haskell-is now
09:15:34 <Polarina> IceDane: Ert Ã¾Ãº bÃºinn aÃ° taka Ã¾Ã¡tt Ã­ forritunarkeppninni Ã¡ huga? :P
09:15:45 <IceDane> kmc: There is one? :O
09:15:49 <kmc> no...
09:15:49 <Polarina> :O
09:15:52 <Polarina> :(
09:15:55 <Polarina> So, we stay here then.
09:16:03 <augustss> mauke: S K K has a better type
09:16:06 <IceDane> So you are implicitly suggesting that we should make one?
09:16:06 <ufopp> how do I register my own modules and use them? Is there a doc link for that
09:16:21 <mauke> augustss: they both have the same type
09:16:34 <kmc> can't hurt, there seems to be interest
09:16:43 <IceDane> Polarina: Ã‰g hef ekki sent inn ennÃ¾Ã¡, en Ã©g mun gera Ã¾aÃ°. ÃžaÃ° verÃ°ur hins vegar Ã­ C++
09:16:53 <Berengal> S K S is symetric
09:16:57 <Polarina> IceDane: Ã‰g er aÃ° gera mitt Ã­ Haskell.
09:17:05 <augustss> mauke: not with HM
09:17:07 <Polarina> IceDane: Er ansi sÃ¡ttur meÃ° Ã¾aÃ° eins og er.
09:17:14 <kmc> Polarina, Google translates your nick to "Polaris" :)
09:17:24 <IceDane> Uss.
09:17:28 <Polarina> kmc: Haha.
09:17:38 <mauke> :t (ap const const, ap const ap)
09:17:39 <lambdabot> forall b (m :: * -> *) a b1. (Monad m) => (b -> b, m (a -> b1) -> m (a -> b1))
09:17:48 <Polarina> IceDane: HvÃ­ uss?
09:18:02 <augustss> > ap const ap True
09:18:03 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
09:18:03 <lambdabot>         against inferred type ...
09:18:12 <augustss> > ap const const True
09:18:13 <lambdabot>   True
09:18:37 <mauke> but true = const
09:18:38 <IceDane> Polarina: Ã‰g er samt ekki full viss um aÃ° nÃ¡unginn sem sÃ©r um Ã¾etta hafi kunnÃ¡ttu til Ã¾ess aÃ° geta tekiÃ°, segjum 10, forrit Ã­ mismunandi tungumÃ¡lum og gefiÃ° einkannir eftir Ã¾vÃ­ hvort var best.
09:18:47 <gwern> ouch. the magnitude optimization is wrong!
09:19:05 <IceDane> Uss af Ã¾vÃ­ aÃ° Ã¾aÃ° vÃ¦ri frekar erfitt, fyrir mig allavega.
09:19:11 <Polarina> IceDane: Ã‰g myndi halda slÃ­kt hiÃ° sama, en allar keppnir eru skemmtilegar yfir hÃ¶fuÃ°.
09:19:24 <IceDane> JÃ¡, Ã¾aÃ° er einmitt Ã¾aÃ°
09:19:39 <augustss> OK, enough Icelandic.  As much as I like it.
09:19:52 <Polarina> IceDane: Ã‰g er algjÃ¶r nÃºbbi Ã­ haskell yfir hÃ¶fuÃ°, tÃ³k mig tÃ¡r og blÃ³Ã° aÃ° koma Ã¾essu til aÃ° virka.
09:19:55 <Polarina> augustss: Ok.
09:19:57 <burp> o0
09:20:09 <mauke> is it spanish hour yet?
09:20:19 <Polarina> IceDane: #haskell-blah
09:20:26 <burp> imagine everyone wrote in his own language here..
09:20:39 <augustss> Ja, hur skulle det se ut?
09:20:42 <Polarina> Some would speak in lojban...
09:20:50 <mauke> das wÃ¤re ja wie das internet
09:20:56 <Polarina> augustss: Jeg ikke forstÃ¥r dig. :(
09:20:59 <Lemmih> Det er ikke til at vide.
09:21:00 <damd> what's wrong with english?
09:21:13 <burp> wir sollten uns auf englisch einigen -.-
09:21:15 <SamB_XP> what is this "own language" thing?
09:21:22 <burp> I mean native language
09:21:25 <kamatsu> damd: hokka no gengo de zenbu ga chigau dayo ne.
09:21:46 <burp> but you can invent you own if you like :p
09:21:48 <burp> and use it here
09:22:05 <kamatsu> that would be a great way for the haskell community to avoid success
09:22:07 <mauke> say "can I use Perl?";
09:22:44 <kamatsu> "Hi, I'm looking for help with haskell... what? what!? I need to learn Icelandic to learn Haskell? Bah, now i wasted all those months learning category theory!"
09:23:18 <mauke> http://en.wikipedia.org/wiki/Fj%C3%B6lnir_(programming_language)
09:23:26 <mauke> someone should translate the manual to english :-/
09:24:58 <kamatsu> i'm off all
09:24:59 <kamatsu> goodnight
09:25:02 <Vanadium> The most metal programming language
09:25:11 <gwern> http://www.reddit.com/r/haskell/comments/apm5d/why_are_haskell_complex_floats_so_much_slower/c0isx20 <-- anyone know why this optimization breaks? it's not obvious to me
09:25:14 <Polarina> mauke: Google can.
09:25:32 <mauke> DragonfjÃ¶lnirâˆ
09:28:18 <taruti> gwern: because the order of computation results in different results with Doubles.
09:29:29 <Berengal> gwern: Does it really break, or is it possible to redefine "correct" to include your program? We're talking floats here...
09:29:54 <augustss> > magnitude ((-12.936926911905847) :+ (-5.429932106037269)) :: Complex CReal
09:29:55 <lambdabot>   No instance for (GHC.Float.RealFloat
09:29:55 <lambdabot>                     (Data.Complex.Comp...
09:30:08 <augustss> 1 :: CReal
09:30:13 <augustss> > 1 :: CReal
09:30:15 <lambdabot>   1.0
09:30:25 <augustss> > 1 :: Complex CReal
09:30:26 <lambdabot>   1.0 :+ 0.0
09:30:47 <Berengal> @type magnitude
09:30:48 <lambdabot> forall a. (RealFloat a) => Complex a -> a
09:30:50 <gwern> Berengal: heck, I dunno. floats scare me
09:31:16 <taruti> gwern: basically with floats (a+b)+c /= a+(b+c)
09:31:25 <burp> > magnitude (((-12.936926911905847) :+ (-5.429932106037269)) :: Complex CReal)
09:31:27 <lambdabot>   14.0302616012734447623775791964899325489354
09:31:28 <augustss> Bad version of CReal
09:31:38 <augustss> oh :)
09:31:43 <gwern> taruti: but I feed the same numbers in the same order into both
09:31:48 <burp> you wanted to final expression to be Complex CReal
09:32:12 <Berengal> gwern: Me too. I usually just put my fingers in my ears and go "LALALA" whenever I need them... or put "accurat to the first digit" in the comments...
09:32:21 <taruti> gwern: but the implementations differ and thus even if they are both correct provide different answers.
09:32:25 <augustss> myMagnitude is better
09:32:55 <taruti> gwern: usually different floating point implementations of the same thing produce slightly different results.
09:32:59 <augustss> It has the last digit correctly rounded
09:33:50 <augustss> For doing ray tracing I'd just use a naive magnitude
09:34:04 <augustss> you never get numbers large enough that it matters
09:34:25 <augustss> And it's easy to do without touching the Complex module
09:34:39 <augustss> If ghc is in a good mood.
09:35:24 <burp> > sqrt $ (-12.936926911905847)^2 + (-5.429932106037269)^2 :: CReal
09:35:26 <lambdabot>   14.0302616012734447623775791964899325489354
09:35:55 <burp> last digit correctly rounded?
09:36:14 <augustss> Last digit in the result from myMagnitude is correct
09:36:20 <augustss> ...3445
09:36:23 <Botje> RT fails in the presence of a grouchy compiler?
09:36:51 <burp> should you care about the last digit?
09:37:29 <augustss> You should care about all of them, but you can't count on them being right :)
09:37:40 <burp> yup :>
09:38:42 <augustss> Floats are very icky.
09:40:17 <copumpkin> wow, jdh admitted haskell may be useful
09:40:25 * copumpkin faints
09:40:45 <augustss> where?
09:40:59 <copumpkin> http://flyingfrogblog.blogspot.com/2010/01/naive-parallelization-c-vs-haskell.html
09:41:14 <Heffalump> must be feeling mellow after his holiday
09:41:38 <augustss> Maybe he's having a bad day.
09:42:52 <tkiexn> Censor the spam -- respect LILO's memory!  http://peoplesprimary.com/users/dave0230/DSCF0356.jpg
09:42:52 <tkiexn> Censor the spam -- respect LILO's memory!  http://peoplesprimary.com/users/dave0230/DSCF0356.jpg
09:42:52 <tkiexn> Censor the spam -- respect LILO's memory!  http://peoplesprimary.com/users/dave0230/DSCF0356.jpg
09:42:53 <tkiexn> Censor the spam -- respect LILO's memory!  http://peoplesprimary.com/users/dave0230/DSCF0356.jpg
09:43:00 <tvxbek> Censor the spam -- respect LILO's memory!  http://peoplesprimary.com/users/dave0230/DSCF0356.jpg
09:43:00 <tvxbek> Censor the spam -- respect LILO's memory!  http://peoplesprimary.com/users/dave0230/DSCF0356.jpg
09:43:00 <tvxbek> Censor the spam -- respect LILO's memory!  http://peoplesprimary.com/users/dave0230/DSCF0356.jpg
09:43:01 <tvxbek> Censor the spam -- respect LILO's memory!  http://peoplesprimary.com/users/dave0230/DSCF0356.jpg
09:43:03 <tvxbek> Censor the spam -- respect LILO's memory!  http://peoplesprimary.com/users/dave0230/DSCF0356.jpg
09:43:05 <tvxbek> Censor the spam -- respect LILO's memory!  http://peoplesprimary.com/users/dave0230/DSCF0356.jpg
09:43:06 --- mode: ChanServ set +o mauke
09:43:07 --- mode: ChanServ set +o Heffalump
09:44:06 --- mode: mauke set -o mauke
09:44:29 <avpq> Censor the spam -- respect LILO's memory!  http://peoplesprimary.com/users/dave0230/DSCF0356.jpg
09:44:29 <avpq> Censor the spam -- respect LILO's memory!  http://peoplesprimary.com/users/dave0230/DSCF0356.jpg
09:44:29 <avpq> Censor the spam -- respect LILO's memory!  http://peoplesprimary.com/users/dave0230/DSCF0356.jpg
09:44:30 <qbqepfw> Censor the spam -- respect LILO's memory!  http://peoplesprimary.com/users/dave0230/DSCF0356.jpg
09:44:30 <qbqepfw> Censor the spam -- respect LILO's memory!  http://peoplesprimary.com/users/dave0230/DSCF0356.jpg
09:44:30 <qbqepfw> Censor the spam -- respect LILO's memory!  http://peoplesprimary.com/users/dave0230/DSCF0356.jpg
09:44:30 <avpq> Censor the spam -- respect LILO's memory!  http://peoplesprimary.com/users/dave0230/DSCF0356.jpg
09:44:31 <qbqepfw> Censor the spam -- respect LILO's memory!  http://peoplesprimary.com/users/dave0230/DSCF0356.jpg
09:44:32 <avpq> Censor the spam -- respect LILO's memory!  http://peoplesprimary.com/users/dave0230/DSCF0356.jpg
09:44:51 <ayiczwquih> Censor the spam -- respect LILO's memory!  http://peoplesprimary.com/users/dave0230/DSCF0356.jpg
09:44:51 <ayiczwquih> Censor the spam -- respect LILO's memory!  http://peoplesprimary.com/users/dave0230/DSCF0356.jpg
09:44:51 <ayiczwquih> Censor the spam -- respect LILO's memory!  http://peoplesprimary.com/users/dave0230/DSCF0356.jpg
09:44:51 <dopls> Censor the spam -- respect LILO's memory!  http://peoplesprimary.com/users/dave0230/DSCF0356.jpg
09:44:51 <dopls> Censor the spam -- respect LILO's memory!  http://peoplesprimary.com/users/dave0230/DSCF0356.jpg
09:44:51 <dopls> Censor the spam -- respect LILO's memory!  http://peoplesprimary.com/users/dave0230/DSCF0356.jpg
09:44:52 <ayiczwquih> Censor the spam -- respect LILO's memory!  http://peoplesprimary.com/users/dave0230/DSCF0356.jpg
09:44:52 <dopls> Censor the spam -- respect LILO's memory!  http://peoplesprimary.com/users/dave0230/DSCF0356.jpg
09:44:54 <ayiczwquih> Censor the spam -- respect LILO's memory!  http://peoplesprimary.com/users/dave0230/DSCF0356.jpg
09:44:54 <dopls> Censor the spam -- respect LILO's memory!  http://peoplesprimary.com/users/dave0230/DSCF0356.jpg
09:44:55 <copumpkin> +m
09:45:00 --- mode: Heffalump set +m
09:45:03 --- mode: Heffalump set +v copumpkin
09:45:07 --- mode: Heffalump set +v augustss
09:45:16 --- mode: Heffalump set -m
09:45:24 <kxnbtmkqrtdm> Censor the spam -- respect LILO's memory!  http://peoplesprimary.com/users/dave0230/DSCF0356.jpg
09:45:24 <kxnbtmkqrtdm> Censor the spam -- respect LILO's memory!  http://peoplesprimary.com/users/dave0230/DSCF0356.jpg
09:45:24 <kxnbtmkqrtdm> Censor the spam -- respect LILO's memory!  http://peoplesprimary.com/users/dave0230/DSCF0356.jpg
09:45:25 <kxnbtmkqrtdm> Censor the spam -- respect LILO's memory!  http://peoplesprimary.com/users/dave0230/DSCF0356.jpg
09:45:27 <kxnbtmkqrtdm> Censor the spam -- respect LILO's memory!  http://peoplesprimary.com/users/dave0230/DSCF0356.jpg
09:45:27 --- mode: Heffalump set +m
09:45:31 <copumpkin> or +R
09:45:32 --- kick: kxnbtmkqrtdm was kicked by Heffalump (Heffalump)
09:45:37 <copumpkin> that's probably safest
09:45:39 <Heffalump> what's +R?
09:45:40 --- mode: ChanServ set +o Lemmih
09:45:45 <copumpkin> only registered users may speak
09:45:46 <Heffalump> anyone else msg me for voice..
09:45:52 <copumpkin> wtf
09:45:53 <Heffalump> huh? wtf?
09:45:56 <copumpkin> augustss k-lined!
09:46:02 <copumpkin> someone got confused
09:46:18 <Lemmih> Always knew that guy was up to no good!
09:46:24 <copumpkin> it's true
09:46:25 --- mode: Heffalump set +R-m
09:46:28 <copumpkin> he's been abusing haskell forever
09:46:35 <Heffalump> still need to manually voice people who aren't registered, presumably.
09:46:40 <Paczesiowa> can someone take a look at Person type on wikipedia for Haskell and tell me why is it 'asbtract'?
09:46:55 * Heffalump will also need to disappear shortly
09:46:58 --- mode: Heffalump set +o mauke
09:47:10 <dolio> ddarius: http://code.haskell.org/~dolio/agda-share/html/CExp.html
09:47:33 --- topic: set to '["msg an op if you can't talk", "hackage torrent @ http://bit.ly/7ObzIP ","Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]' by Heffalump
09:47:48 <Botje> wow. that url is one impressive beastie.
09:47:50 <Botje> (don't click it)
09:48:22 <mmaruseacph2> does anyone know when the next issue of the The Monad Reader will come out?
09:48:34 <mauke> oh, it's Last Measure
09:49:12 <Heffalump> I think they must be k-lining unregistered users
09:49:23 --- mode: Heffalump set +v Gowilla
09:49:26 <Gowilla> can I talk now?
09:49:28 <Gowilla> ok, good.
09:49:48 <elt0n> @hoogle token
09:49:48 <copumpkin> Heffalump: but he used chanserv to op himself
09:49:48 <lambdabot> Text.Parsec.Prim token :: Stream s Identity t => (t -> String) -> (t -> SourcePos) -> (t -> Maybe a) -> Parsec s u a
09:49:49 <lambdabot> Text.ParserCombinators.Parsec.Prim token :: Stream s Identity t => (t -> String) -> (t -> SourcePos) -> (t -> Maybe a) -> Parsec s u a
09:49:49 <lambdabot> module Text.Parsec.Token
09:49:59 <Heffalump> who did?
09:50:14 <Vanadium> If you click the link, your browser connects to IRC and keeps spamming that link a few hundred times, as if by magic.
09:50:15 <copumpkin> omg augustss was a spammer
09:50:20 <copumpkin> Heffalump: augustss, http://snapplr.com/3w7y
09:50:21 <Vanadium> Then you presumably get k-lined.
09:50:32 <mauke> heh, nice
09:50:37 <Gowilla> how on earth does it do that, browser exploit?
09:50:46 <mauke> probably an iframe
09:50:51 <mauke> let's see ...
09:50:56 <Gowilla> ouch
09:50:57 <Vanadium> Gowilla: It auto-submits a form using javascript to "http://irc.freenode.org:6667"
09:51:04 <Vanadium> with irc commands in the POST data
09:51:06 <Botje> yes
09:51:12 --- mode: Heffalump set +v mmaruseacph2
09:51:20 <CESSMASTER> javascript is so sinister
09:51:24 <Heffalump> I need to go in a minute
09:51:30 <Heffalump> shall I op some more people to give voice out?
09:52:04 <Vanadium> We do not appear to require voice...?
09:52:09 <Vanadium> People can identify easily enough
09:52:11 <Heffalump> not if you're registered
09:52:14 * Heffalump gone for a bit
09:52:18 <Vanadium> Right
09:53:10 <Philonous> I wonder how people can still surf the web without decent java script protection
09:53:16 <mauke> exploit code: http://pastebay.com/83116
09:53:36 <BONUS> i have nothing to say atm anyway soo
09:53:58 <sshc> mauke: are you sure telling everybody is the wisest idea?
09:54:16 <protojay> more people should use noscript
09:54:17 <copumpkin> sure
09:54:22 <protojay> stops javacrap in its tracks
09:54:40 <Vanadium> Was it the noscript guy who fucks with other firefox extensions?
09:54:42 <mauke> sshc: telling? it's right there in the page that's been spammed all over freenode
09:54:42 <benmachine> JS should really have some of these security mechanisms builtin
09:55:05 <opqdonut> sshc: full disclosure :)
09:55:29 <copumpkin> beware, antisec might go after mauke!
09:55:32 <copumpkin> except they got owned
09:55:59 <Philonous> Vanadium: He tried to circumvent addblock for his own site. But that's a nuisance at worst
09:56:08 <aep> if i have  "do  x <- some_io ; use_x x;  use_x x; "  will some_io be done twice?
09:56:18 <mauke> aep: no
09:56:27 <aep> phew. thanks
09:56:37 <dons> yikes
09:57:25 <dons> anyone want to take a ballpark guess of what wc -l returns on the latest hackage archive?
09:57:32 <dons> i.e. 1802 packages | wc -l
09:57:48 <Berengal> Random guess: 600K
09:57:55 <Vanadium> 300K
09:57:56 <BONUS> 400k
09:57:59 <benmachine> 900K
09:58:00 <Zao> aep: some_io >>= \x -> use_x x >> use_x x
09:58:02 <Zao> Or somesuch.
09:58:02 <mauke> the exploit author might be an idiot. chars.substring(rnum,rnum+1) better written as chars.charAt(rnum)
09:58:04 <dons> srsly?
09:58:09 <dons> 7.5M
09:58:12 <Berengal> :O
09:58:14 <benmachine> I was closest!
09:58:17 <Zao> mauke: Wrong type?
09:58:25 <BONUS> what do i win, bob
09:58:29 <dons> hehe
09:58:30 <benmachine> Zao: well, evidently it works
09:58:32 <Vanadium> Javascript does not have a char type
09:58:39 <Berengal> 7500000 / 1802
09:58:41 <Berengal> > 7500000 / 1802
09:58:42 <lambdabot>   4162.042175360711
09:58:44 <Vanadium> Either way just gives you a one-character string
09:58:59 <dons> now, i don't really think that's a plausible amount for lines of code.
09:59:05 <dons> 4k is too high an avg.
09:59:16 <Zao> benmachine: I would assume charAt :: String -> Idx -> Char and substring :: String -> Idx -> Idx -> String
09:59:17 <dons> but that's mostly due to that it includes all the data files
09:59:24 <Berengal> > 4000 / 200
09:59:25 <lambdabot>   20.0
09:59:28 <copumpkin> lol
09:59:35 <Zao> Although I guess that JS is insane like usual.
09:59:36 <Berengal> Assuming 200/module, that's 20 modules/package
09:59:47 <mauke> Zao: javascript doesn't have char type. or a type system like that.
10:00:00 <benmachine> surely the vast majority of packages are one or two modules
10:00:09 <dons> i'd think so, yes.
10:00:18 <Berengal>  And 200 module is really rather arbitrary...
10:01:34 <mauke> ah, nice. the php script seems to generate different js code so everyone gets a different channel
10:01:54 <benmachine> that's nice
10:03:16 <mauke> this exploit would be defeatable by delayed voicing
10:03:38 <mauke> also by making the ircd dropping connections that start with "POST"
10:03:46 <mauke> *drop
10:04:09 <sepp2k> I've been thinking a bit about C++0x's variadic templates lately. Is there a way in haskell (or any other functional programming language) to define one tuple type that can handle an arbitrary number of elements while still being type safe? Or more generally: is such a thing possible without introducing the possibility of the compiler going into an infinite loop (like in c++)?
10:04:39 <copumpkin> sepp2k: it's easy if you just want all the same types in it
10:04:54 <copumpkin> otherwise you're basically going for an hlist, I guess
10:04:54 <Vanadium> sepp2k: What would the C++ equivalent be?
10:04:56 <benmachine> sepp2k: the problem with arbitrary-element tuples is, what can you do with them?
10:04:59 <Twey> HList might be a solution to that, though it's not a particularly elegant one
10:05:01 <Twey> Aye
10:05:31 <benmachine> you can't pattern match on them because you don't know how big they are, you can't retrieve the nth element because you don't know what type it is, etc
10:06:03 <burp> @hoogle expression
10:06:04 <lambdabot> Text.Parsec.Expr buildExpressionParser :: Stream s m t => OperatorTable s u m a -> ParsecT s u m a -> ParsecT s u m a
10:06:04 <lambdabot> Text.ParserCombinators.Parsec.Expr buildExpressionParser :: OperatorTable tok st a -> GenParser tok st a -> GenParser tok st a
10:06:21 <burp> :t x
10:06:22 <lambdabot> Expr
10:06:26 <burp> @hoogle Expr
10:06:27 <lambdabot> module Text.Parsec.Expr
10:06:27 <lambdabot> module Text.ParserCombinators.Parsec.Expr
10:06:27 <lambdabot> Text.Parsec.Expr buildExpressionParser :: Stream s m t => OperatorTable s u m a -> ParsecT s u m a -> ParsecT s u m a
10:06:39 <benmachine> burp: SimpleReflect in the show package, I think
10:06:46 <burp> oh, thanks
10:07:40 <sepp2k> benmachine: Vanadium: In C++0x you can define a template tuple so that you could do: Tuple<int,char,int> tup(1,'c',2); char c = tup.get<1>(); which would check at compile-time that: the arguments to the constructor have the right types and that the element at index 1 is really a char.
10:08:01 <Vanadium> Well, we have arbitrary tuples to begin with
10:08:37 <sepp2k> HList looks interesting
10:08:43 <BONUS> could that be done with TH?
10:08:48 <Berengal> I don't have a solution yet, but I think it might be possible with HList, type-naturals and some type classes...
10:08:54 <BONUS> idk i dont know too much about TH
10:08:54 <Vanadium> sepp2k: I am not sure what you want your tuples to do beyond what regular tuples do
10:08:58 <benmachine> BONUS: that is what I was thinking
10:09:01 <sepp2k> Vanadium: But you couldn't define an equivalent type yourself, could you?
10:09:03 <benmachine> (but neither do I)
10:09:18 <Vanadium> the type being 'tuple' or the type being 'tuple<int, char, int>'?
10:09:28 <b6> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16199  runInteractiveProcess issue with cat and rev.
10:09:31 <benmachine> it sounds a bit like a normal ADT?
10:09:33 <Vanadium> Every tuple type is its own type
10:09:35 <BONUS> we just don't have a method of doing stuff like (1,'a',"bah") !! 2
10:09:39 <sepp2k> Vanadium: I don't want them to do anything more than they do. I want to know how I would define them if they didn't exist.
10:10:02 <Vanadium> Ah
10:10:22 --- mode: Heffalump set -o Heffalump
10:10:29 <Vanadium> You can probably do something crazy involving something close to type-level lists
10:10:32 <benmachine> data Pair a b = Pair a b
10:10:44 <benmachine> hmm no
10:10:47 <Vanadium> yes
10:10:53 <Vanadium> Pair a (Pair c d), and so on
10:10:59 <benmachine> yeah you can do that
10:11:11 <benmachine> I wondered if normal tuples shouldn't be done like that
10:11:40 <benmachine> we could have only pairs, and then (a, b, c) would be syntactic sugar for ((a, b), c) and/or (a, (b, c))
10:11:47 <BONUS> oh that
10:11:52 <BONUS> i never really got the benefit of that
10:12:02 <BONUS> what does it offer
10:12:05 <sepp2k> Vanadium: But I couldn't (and can't actually) that returned the ith element of a tuple.
10:12:13 <sepp2k> +define a function
10:12:30 <Vanadium> You mean a function that takes an index?
10:12:33 <benmachine> BONUS: class instances for tuples tend to be a bit crappy
10:12:42 <sepp2k> Vanadium: Yes.
10:12:47 <Vanadium> Well, neither can you in C++
10:12:55 <aep> how would i access bla with foo in   [(bla,foo),(..   ?
10:13:03 <aep> err foo with bla
10:13:07 <Vanadium> since it is tup.get<1>() and not tup.get(1)
10:13:16 <sepp2k> That's true.
10:13:31 <Vanadium> aep: lookup, assuming all the types work out?
10:13:35 <BONUS> i'm p sure that some TH hackery could enable something like that
10:13:35 <Vanadium> @type lookup
10:13:35 <benmachine> :t lookup
10:13:36 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
10:13:37 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
10:13:40 <sepp2k> There's no such thing as compile-time arguments in haskell, I guess.
10:13:55 <BONUS> but it's not like it's that useful because pattern matching
10:14:05 <benmachine> @type find
10:14:06 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
10:14:21 <benmachine> sepp2k: well, there's TH, but that requires more effort
10:14:34 <aep> i forgot to mention: i need do do that two times for two sequential keys. i was trying not to run a full search every time
10:15:03 <benmachine> take 2 . filter?
10:15:39 <aep> no, what i am actually trying is get (foo,bla),(bar,baz)  into a record type  with  foo and bar
10:15:55 <sepp2k> benmachine: Ah, that looks interesting.
10:16:46 <aep> [("foo","bla"),("bar","baz")]   ==>  T {foo="bla",bar="baz"}
10:17:07 <aep> with many other possible keys in the list
10:17:31 <aep> so a regular find would search the whole list once for every key :/
10:18:37 <aep> in a non pure language, i'd just do something like;   reference1,reference2;  for all (x,y) in list do { if(x=="bla")reference1)=y  }
10:19:41 <aep> hmm maybe i can use filter and then expect the result to be at a specific position in the result list
10:20:46 <Vanadium> surely using lookup for each entry in the record type is not any slower than going through the list once but checking against every field name for every entry
10:21:02 <benmachine> foldr (.) id . map (\(a, b) -> if a == "foo" then (\x -> x { foo = b }) else if a == "bar" then (\x -> x { bar = b }) else id)
10:21:05 <benmachine> wooo
10:21:26 <benmachine> that is a slightly silly way of doing it
10:21:35 <Vanadium> Otherwise you could presumably build something that looks like lookup but returns a list that does not have the element you were looking for in addition to it
10:23:18 <copumpkin> does Network.HTTP support HTTP pipelining?
10:23:28 <benmachine> what's pipelining?
10:23:38 <copumpkin> using a single tcp connection to make multiple requests
10:23:46 <dons> copumpkin: i think the new version just might. (the curl package certainly does)
10:23:53 <dons> copumpkin: if you find out, let us know.
10:23:57 <copumpkin> sure
10:24:00 <benmachine> Network.Browser?
10:24:10 <copumpkin> I couldn't tell whether that was using it or not
10:24:19 <benmachine> well if you can't tell, does it matter? :P
10:24:46 <benmachine> I think that it uses a persistent connection
10:24:50 <copumpkin> I'm going to be pounding a server that isn't mine like crazy, so I wanted to minimize it
10:25:00 <benmachine> heh
10:36:25 <elspru> hey, suddenly my darcs changed from vim to nano
10:36:34 <elspru> how to change it back?
10:37:05 <mauke> echo $EDITOR
10:37:08 <gwern> elspru: check your $EDITOR?
10:37:21 <Gracenotes> nano is pretty easy to exit, you know
10:37:45 <osfameron> it actually tells you the command on the menu at the bottom, which is nice
10:37:49 <gwern> Gracenotes: it even tells you how. unlike vi...
10:37:53 <osfameron> or emacs...
10:37:56 <Gracenotes> *vigorous nodding*
10:38:03 <elspru> ya i know, but it's not what i'm used to
10:38:15 <gwern> osfameron: emacs tells you how
10:38:26 <elspru> oh, i forgot to transfer over my bashrc after ubuntu reinstall
10:38:27 <mauke> the first thing vim tells you is how to quit and how to access the help
10:38:28 <osfameron> gwern: really?
10:38:34 <gwern> the startup screen includes 'Exit Emacs         C-x C-c'
10:38:46 * osfameron doesn't have an emacs to play with
10:38:58 <mauke> except people who aren't familiar with emacs probably won't recognize that notation :-)
10:38:58 <osfameron> that's assuming you know what C-x C-c means of course :-)
10:39:19 <elspru> gwern: ya that never helped me
10:39:24 <elspru> i never learned to exit emacs
10:39:29 <elspru> i just kill it
10:39:30 <gwern> osfameron: and nano assumes you know what ^X is...
10:39:40 <osfameron> true.  but that's more likely I think
10:39:45 <mauke> gwern: caret notation is more common than C-
10:39:49 <aavogt> and all these editors assume you can read
10:39:54 <osfameron> the rotters!
10:39:54 <Berengal> Both assume you have a keyboard
10:39:59 <osfameron> the cads!
10:40:49 <ertai> is there a nicer solution than: "map fromJust . takeWhile isJust" ?
10:41:03 <BONUS> hey what's the release date for haskell platform with GHC 6.12
10:41:07 <Igloo> ertai: catMaybes
10:41:18 <Igloo> Oh, wait, not if you really mean takeWhile
10:41:29 <ertai> Yep I really mean it
10:41:37 <elspru> i made use of a . today in a program. i'm so proud of myself, i'm like puffy  rooster
10:41:51 <BONUS> condraculations
10:41:56 <elspru> :D
10:42:07 <Berengal> BONUS: March-ish, I think
10:42:12 <sshc> how do IORefs work?
10:42:17 <sshc> hoogle isn't working for me right now
10:42:21 <Berengal> sshc: Magic
10:42:23 <sshc> is it pretty much C pointers?
10:42:27 <Berengal> sshc: They're pointers to memory locations
10:43:10 <mauke> they work like refs in OCaml :-)
10:43:44 <sshc> is it possible to make a pointer to a pointer?
10:43:50 <sshc> s/pointer/IORef/g
10:44:09 <Philonous> sshc: Yes
10:44:20 <sshc> or is it possible to mutate a reference to point to something else?
10:44:22 <Philonous> sshc: You can pass them around and store them like any ordinary value
10:44:26 <Cale> sshc: yes
10:44:38 <sshc> Cale: how do i do that?
10:44:43 <sshc> Hoogle isn't working for me
10:44:46 <Cale> sshc: See newIORef / readIORef / writeIORef
10:44:52 <Cale> In Data.IORef
10:44:55 <sshc> Cale: Hoogle isn't working for me
10:45:08 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.2.0.0/Data-IORef.html
10:45:13 <Philonous> http://holumbus.fh-wedel.de/hayoo/hayoo.html
10:45:15 <sshc> I guess i'll wait for it to respond
10:45:21 * Cale doesn't bother with hoogle
10:45:28 <sshc> Cale: why not?
10:45:30 <Cale> Just use the documentation
10:45:52 <Cale> hoogle is good when you don't know what you're looking for
10:46:15 <Cale> But when you do, it's easier just to go directly, I think.
10:46:32 <Cale> newIORef :: a -> IO (IORef a)
10:46:34 <Cale> readIORef :: IORef a -> IO a
10:46:37 <Cale> writeIORef :: IORef a -> a -> IO ()
10:46:45 <Cale> a can be any type at all
10:46:57 <Cale> Including an IORef type
10:48:13 <Berengal> Underneath it all is a MutVar#
10:48:28 <Cale> (but who cares about that)
10:48:29 <Berengal> Which I assume is built-in, because none of the docs I've looked at include source
10:48:49 <Cale> You might as well think of IORefs as built-in.
10:49:13 <Berengal> You might as well think of any opaque type as built-in
10:49:22 <Cale> Oh, great, looks like we're back to netsplit land.
10:49:50 <Berengal> banana split!
10:54:49 <monochrom> Oh haha the spammer stroke again?
10:55:27 --- mode: ChanServ set +o monochrom
10:55:49 <monochrom> if you are unregistered, pm me or an op to get voice.
10:58:45 <jlouis> Cale: it was 80% packet loss on some line yesterday :)
10:59:11 <dolio> monochrom: They got augustss this time.
11:00:02 --- mode: monochrom set +v Vitka
11:01:02 <monochrom> As in, the libel says something about augustss?
11:01:12 <dolio> As in he got k-lined.
11:01:23 <Vitka> :t (1:)
11:01:24 <lambdabot> forall t. (Num t) => [t] -> [t]
11:01:59 <Vitka> scanr (1:) [1..5]
11:02:11 <Vitka> > scanr (1:) [1..5]
11:02:12 <lambdabot>   Couldn't match expected type `b -> b' against inferred type `[t]'
11:02:24 <Vitka> Hmm.
11:02:46 <Vitka> scanr (1:) [[1..5]]
11:02:57 <Vitka> > scanr (1:) [[1..5]]
11:02:58 <lambdabot>   Couldn't match expected type `b -> b' against inferred type `[t]'
11:03:22 <Vitka> > scanl (1:) [1..5]
11:03:23 <lambdabot>   Couldn't match expected type `b -> [t]' against inferred type `[t]'
11:03:28 <Cale> > scanr (:) [] [1..5]
11:03:29 <lambdabot>   [[1,2,3,4,5],[2,3,4,5],[3,4,5],[4,5],[5],[]]
11:03:58 <Vitka> Hmm.
11:04:12 <Vitka> > scanr (1:)[] [1..5]
11:04:13 <lambdabot>   Couldn't match expected type `b -> b' against inferred type `[t]'
11:04:26 <Cale> Wrong type for the combining function
11:04:40 <Cale> scanr takes the same parameter types as foldr
11:04:49 <jlouis> oh, haha it is still the HTTP POST spam trick
11:05:05 <Cale> Something to take the place of (:) in the list, something to take the place of [] in the list, and a list
11:05:14 <Vitka> I want to append a list of 1 to list elements.
11:05:16 <gwern> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16201#a16201 <-- any suggestions? will this work as I expect it to?
11:05:17 <Vitka> Ah.
11:05:26 --- mode: monochrom set +v ddarius
11:05:35 <Cale> > map (1:) [[2,3,4],[5,6,7]]
11:05:36 <lambdabot>   [[1,2,3,4],[1,5,6,7]]
11:05:39 <Cale> like that?
11:06:05 <Cale> > scanr (+) 0 [1..5]
11:06:06 <lambdabot>   [15,14,12,9,5,0]
11:06:18 <Cale> > scanl (+) 0 [1..5]
11:06:20 <lambdabot>   [0,1,3,6,10,15]
11:06:29 <ddarius>  dolio: Interesting way of describing G.  I didn't formally work through it, but I just directly put trivial functions (functions to the terminal object of Set) into the non-A components of the natural transformation.
11:06:55 <Vitka> More like: f(4)=[[4],[3,1],[2,1,1],[1,1,1,1]]
11:07:29 <Vitka> Then use it to find combination of possible sums for given n.
11:08:45 <Vitka> Then narrow to sums of only 3 elements. Seems like simple conbinatorics, but list construction goes over my head.
11:08:59 <ddarius> > take 0 undefined
11:09:00 <lambdabot>   []
11:09:53 <Cale> Oh, the way I'd normally do that is by first writing a function which generates the partitions of n with parts that are at most k
11:12:28 <Berengal> Is it possible to use universal quantification inside contexts?
11:13:57 <Vitka> Maybe, but still I need to find out how to append a list of same values to list element to get list of lists.
11:14:07 <Vitka> Unfoldr, perhaps?
11:14:10 <ddarius> dolio: It also seems related to Ran_D where D : Set -> Cat is the discrete category functor.  Also, Ran_D exists because D has a left adjoint, Ï€_0 which leads to -âˆ˜D âŠ£ -âˆ˜Ï€_0 = Ran_D
11:14:34 <Cale> Vitka: I would use a list comprehension
11:14:45 <copumpkin> ddarius: by the way, the memory inefficiencies in agda making category theory difficult have apparently been fixed
11:15:17 <ddarius> copumpkin: I've installed Agda but I haven't used it yet.
11:15:42 <aavogt> > iterate (nub . concatMap (\x -> case x of a:b:bs -> [a+b:bs,a:b:bs]; _ -> [x]) . nub) [replicate 4 1] !! 3
11:15:43 <lambdabot>   [[4],[3,1],[2,1,1],[1,1,1,1]]
11:15:54 <copumpkin> partititions?
11:15:59 <ddarius> Wow, my capslock key is distinctly dirtier looking than all my other keyboard keys.
11:16:21 <byorgey> integer partitions.
11:16:21 <aavogt> this can be done without the nubs, which would be significantly more efficient
11:16:22 --- mode: monochrom set +v Berengal
11:16:23 <elspru> ddarius: cause you never use it
11:16:27 <elspru> ?
11:16:28 <ddarius> elspru: Indeed.
11:16:28 <copumpkin> ddarius: are you secretly a 14-year-old 4channer?
11:16:30 <Berengal> Is it possible to use universal quantification inside contexts?
11:16:31 <copumpkin> oh
11:16:50 <copumpkin> Berengal: not as far as I know
11:16:56 <Berengal> copumpkin: :(
11:16:57 <ddarius> Berengal: Try it and find out.
11:17:00 <Vitka> Hmm.
11:17:17 <Berengal> I tried something, and it didn't work, but I thought I might've gotten the syntax wrong or something
11:17:43 <Twey> ddarius: You should remap it to something useful, instead
11:17:57 <Cale> > let partitions' n k | k > n = partitions' n n; partitions' 0 k = [[]]; partitions' n k | k <= 0 = []; partitions' n k = [x:xs | x <- [k,k-1..1], xs <- partitions' (n-x) x] in partitions' 4 4
11:17:57 <Vitka> Thanks, will see if I can denub this solution and denoob myself.
11:17:59 <lambdabot>   [[4],[3,1],[2,2],[2,1,1],[1,1,1,1]]
11:18:10 <Vitka> Er.
11:18:42 <Cale> (longer, but I think more straightforward computationally)
11:18:44 <Berengal> I have a type Foo a, where a is a phantom type, a type family Opposite with instances Opposite A = B and Opposite B = A, and a list with Cons :: a b -> List a (Opposite b) -> List a b, and now I'm trying to write a Show instance for that list...
11:18:52 <gwern> jon meachem is going to be unhappy to see DrIFT-cabalized :)
11:19:01 <gwern> but what's life if you don't annoy people?
11:20:07 <aavogt> isn't the main objection to cabalizing things that it's lots of effort sometimes?
11:20:37 <aavogt> gwern: or you are being more annoying than encouraging him to support your work?
11:20:38 <gwern> aavogt: meachem's main points seem to be that it's less easily extensible than make, and less portable
11:20:58 <gwern> aavogt: I'm afraid it went past encouraging and way into annoying back in 2008
11:20:58 <dino-> I turned my caps key into left-control. Much easier to get to than that pinky-buster in the corner.
11:21:35 <gwern> dino-: I do that too
11:21:40 <ddarius> dino-: I'm used to my left Ctrl being where it is and I type on a laptop keyboard, so it isn't that far away...
11:22:28 <dolio> ddarius: Which part of G was interesting? f o Fg?
11:22:51 <ddarius> dolio: The description using Hom-sets rather than my more direct route.
11:23:02 <dolio> Ah. Okay.
11:23:03 <Berengal> dino-: I did the same when my job consisted mostly of Ctrl-C -> Ctrl-V and Ctrl-Shift-Tab
11:23:33 <dino-> The old Sun keyboard were like this. It's much more sane.
11:24:14 <dino-> Now, do the caps control thing and start using ctrl-[ to generate ESC -> keeps you close to the home keys for vim perfection!
11:24:44 <dino-> ESC is even further in the suburbs. Crazy!
11:24:59 <Twey> dino-: You should use the heel of your hand to hit ctrl, quoth Xah Lee, which makes a lot of sense
11:25:01 <Badger> bleh, registration requirement
11:25:19 <Twey> Which is very difficult to do if it's in that position
11:26:04 <gwern> go go thread necromancy!
11:26:05 <ddarius> Twey: Wouldn't pressing keys with the heel of your hand take you (mildly) out of proper hand positioning for typing?
11:26:24 <Twey> Well, not the heel â€” the blade, I suppose
11:26:35 <dino-> What's the <+yournamehere> + for?
11:26:35 <Twey> The ridge of bone just beneath the little finger
11:26:42 <aep> is there some sort of copy constructor for record data types?
11:26:44 <Twey> Voicing, dino-
11:26:55 <Twey> aep: No
11:27:12 <Twey> (nor would it make sense to, given Haskell's evaluation model)
11:27:18 <aep> so i have to pass ALL of the fields every time? D:
11:27:25 <ddarius> aep: No.
11:27:38 <Twey> No, you can create a default and modify it
11:27:48 <gwern> let's see, the last message was 2 December 2008, and today is 16 January 2010; so a good year, month, and 14 days
11:27:52 <aep> well i need to modify a passed value
11:28:05 <ddarius> aep: Use record update syntax.
11:28:08 <Twey> aep: let newRecord = oldRecord { newField = newValue }
11:28:14 <aep> foo x =  x where x.bla=something else
11:28:24 <aep> Twey: nice thanks
11:28:32 <Twey> foo x = x { bla = "something else" }
11:28:36 <mauke> let newRecord = tubularBells { oldfield = mike }
11:28:42 <Twey> Hehe
11:28:52 <aep> oO
11:28:53 * Berengal gives up and implements a Forgettable class
11:29:01 <ddarius> http://web.archive.org/web/20061011094943/http://haskell.org/hawiki/UsingRecords
11:29:04 <aavogt> aep: there's also some record wildcards extension in ghc
11:29:39 <Twey> aavogt: How does that help here?
11:29:56 <Twey> I suppose if you want to use the old value of the field
11:30:15 <aavogt> Twey: I think you can write       X { .. }  = Y { .. , otherv = otherthing }
11:30:32 <Twey> aavogt: Hmm, really?
11:30:33 <aavogt> or some magic like that
11:30:38 <Twey> But wouldn't that give two â€˜othervâ€™s?
11:30:38 <theclaw> I regularly get the "possibly incorrect indentation" error when using a case/if inside a "do", is there anything special I have to be careful with? (stupid question maybe, but I'm really frustrated :/)
11:31:03 <Twey> theclaw: Make sure it's indented more than the â€˜doâ€™, and the cases are indented more than the â€˜caseâ€™
11:31:25 <Twey> (the â€˜ofâ€™ keyword also needs to be indented more than the â€˜caseâ€™ but less than the cases, if you put it on a separate line)
11:32:08 <ddarius> (Who would put the 'of' on a separate line?)
11:32:23 <mauke> Twey: why less than the cases?
11:32:35 <theclaw> Twey: this is just a snippet: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16203#a16203
11:32:39 <theclaw> anything wrong with it?
11:32:45 <aavogt> ddarius: if the expression being meatched on is really long?
11:32:58 <ddarius> theclaw: We can't tell without the context.
11:33:01 <aavogt> as in, if it spans multiple lines
11:33:02 <Twey> mauke: The cases are considered part of the â€˜ofâ€™ block, aren't they?
11:33:17 <mauke> Twey: yes?
11:33:24 <theclaw> ddarius: just a second
11:33:27 <ddarius> aavogt: I'd still have the 'of' on the last line of the multiple line expression.
11:33:32 <mauke> theclaw: missing )
11:33:46 <Twey> > case 5 {;of;1 -> "foo"; 5 -> "bar" }
11:33:47 <lambdabot>   <no location info>: parse error on input `;'
11:33:59 <ddarius> 'of' opens the block of layout
11:34:04 <Twey> > case 5 of { 1 -> "foo"; 5 -> "bar" }
11:34:05 <lambdabot>   "bar"
11:34:06 <Twey> Right
11:34:16 <aavogt> theclaw: you seem to have an unmatched paren
11:34:20 <theclaw> meh!
11:34:25 <Twey> So the cases need to be indented more than it, and it needs to be indented more than â€˜caseâ€™
11:34:31 <mauke> Twey: no
11:34:49 <aavogt> or it is closed on another line
11:34:51 <theclaw> aavogt, mauke - yes, that was the problem - I got confused by the "possibly incorrect indentation" message
11:34:54 <ddarius> Twey: The next line can start anywhere (modulo containing blocks)
11:34:55 <theclaw> thanks!
11:35:18 <Twey> ddarius: Define â€˜the next lineâ€™?
11:35:30 <mreh> that'll teach me to click a link from a spambot again
11:35:44 <ddarius> Twey: The next line of code after a block opening keyword (assuming there is nothing following it on that line)
11:35:59 <mauke> mreh: that'll teach you to enable javascript on untrusted sites :-|
11:36:18 <mreh> yes :D
11:36:48 <ddarius> Twey: For example, at the beginning of you code you probably have 'module Foo where\nmain = ...' which has "main" starting much less indented than the opening 'where'
11:36:48 <Twey> ddarius: So you're saying that this is valid? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16205#a16205
11:37:03 <mauke> Twey: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16206#a16206
11:37:05 <ddarius> Twey: If there is no containing block of layout, yes.
11:37:11 <ddarius> Twey: You likely do exactly that with modules.
11:37:15 <mauke> Twey: untested, but my internal haskell parser says this is fine :-)
11:37:31 <Twey> Huh.
11:38:00 <ddarius> Twey: It could even be less indented than the case (albeit that would be sinfully ugly)
11:38:10 <mauke> ddarius: see my example
11:38:40 <ddarius> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16205#a16207
11:38:48 <ddarius> mauke: Where?
11:38:51 <ddarius> Oh
11:39:58 <ddarius> Twey: You likely do many such things all the time.  For example, you likely indent do blocks less than the opening 'do'.
11:40:20 <Twey> Sure, but they're indented more than the line the â€˜doâ€™ is on
11:40:46 <mauke> that's irrelevant
11:40:55 <ddarius> Twey: Yes, but that means nothing to the do expression, and would only matter if it was in a containing block of layout.
11:40:58 <Twey> Hum.
11:41:09 <Twey> Interesting.
11:41:18 <ddarius> I take pretty significant advantage to the extra flexibility Haskell's layout provides over Python style layout.
11:41:20 <aavogt> > case do [];[];[] of [] -> error "this works too?"
11:41:21 <lambdabot>   * Exception: this works too?
11:41:43 <ddarius> aavogt: Why wouldn't it work?
11:41:55 <aavogt> because the do might extend
11:42:07 <Berengal> The of breaks it
11:42:09 <aavogt> > do case do [];[];[]; of [] -> error "this works too?"
11:42:11 <lambdabot>   * Exception: this works too?
11:42:14 <Berengal> The parsing of the do that is
11:42:49 <ddarius> Indeed.  It's effectively no different than 3*5 being terminated by + in 3*5+6
11:43:00 <Berengal> There's some "as far right as possible" rule in the grammar at places, which means that if it encounters an illegal construct it backtracks
11:43:17 <Berengal> > case \x -> x of f -> f "hello"
11:43:19 <lambdabot>   "hello"
11:43:39 <Cale> The do-notation syntax allows for empty statements
11:43:48 <Berengal> > case 1 :: Int of x -> x
11:43:49 <lambdabot>   1
11:43:59 <mauke> > do Nothing == Nothing == Just ()
11:44:00 <lambdabot>   Precedence parsing error
11:44:00 <lambdabot>      cannot mix `GHC.Classes.==' [infix 4] and `GH...
11:44:03 <mauke> huhu
11:44:19 <Cale> > do [1,2,3];;;[4,5];;
11:44:21 <lambdabot>   [4,5,4,5,4,5]
11:44:35 <Cale> > do [1,2,3];;let;;[4,5];;
11:44:36 <Axman6> > True == True == True == True
11:44:36 <lambdabot>   <no location info>: parse error on input `;'
11:44:37 <lambdabot>   Precedence parsing error
11:44:37 <lambdabot>      cannot mix `GHC.Classes.==' [infix 4] and `GH...
11:44:39 <Cale> > do [1,2,3];;let;;[4,5];;
11:44:40 <lambdabot>   <no location info>: parse error on input `;'
11:44:42 <Cale> > do [1,2,3];;let{};;[4,5];;
11:44:43 <lambdabot>   [4,5,4,5,4,5]
11:44:46 <Cale> heh
11:44:54 <mauke> > if True; then 't'; else 'f'
11:44:55 <lambdabot>   <no location info>: parse error on input `;'
11:44:58 <mauke> aww
11:45:06 <aavogt> > let infixr == ; (==) = (Prelude.==) in True == True == False == False
11:45:07 <lambdabot>   True
11:45:13 <Berengal> I think the parsing of True == True == True should produce a valid AST according to the grammar...
11:45:15 <Cale> > let in let in let in 5
11:45:16 <lambdabot>   5
11:45:24 <Berengal> Even if == isn't associative
11:45:29 <dufflebunk> What kind of insect is on the cover of the real world haskell book?
11:45:43 <dufflebunk> stupid question, but it's been bugging me recently
11:45:50 <BONUS> haha i see what you did there
11:45:54 <BONUS> rhino beetle imo
11:45:56 <Twey> Isn't it a rhino beetle?
11:46:01 <Twey> Yeah, IIRC
11:46:14 <mauke> hercules beetle
11:46:16 * Berengal thinks programming books should never have bugs on their covers
11:46:17 <BONUS> maybe i'll put a dung beetle on lyah
11:46:22 <aavogt> Berengal: well if you decide something is infix, then it is not infixr or infixl
11:46:27 <mauke> says so right on http://book.realworldhaskell.org/
11:46:38 <Twey> Huh
11:46:52 <Cale> http://en.wikipedia.org/wiki/Hercules_beetle
11:47:00 <dufflebunk> mauke: So it does, thanks.
11:47:04 <Twey> Ah
11:47:13 <Twey> Which is a subspecies of rhinocerous beetle
11:47:33 <Twey> rhinoceros**
11:47:40 <Twey> (there's a word I haven't had a chance to use in a while)
11:50:42 <aavogt> Berengal: you'd prefer if fixity checking was done at runtime or something?
11:51:11 <Berengal> aavogt: No, not at all. That would just be silly...
11:51:28 <Berengal> aavogt: I'm happy with the way things are
11:51:45 <aavogt> > let infix == ; (==) = (Prelude.==) in True == True == False == False
11:51:46 <lambdabot>   Precedence parsing error
11:51:47 <lambdabot>      cannot mix `==' [infix 9] and `==' [infix 9] ...
11:52:22 <aavogt> > let (==) = (Prelude.==) in True == True == False == False
11:52:23 <lambdabot>   True
12:04:02 <augustss> so quiet
12:04:22 <xerox> maybe it's the +R hehe
12:05:44 <mauke> well, I can fix that
12:06:01 <Berengal> Are we still being spammed?
12:06:39 <xerox> (yep, ##physics right now for example)
12:06:40 <mauke> let's see
12:06:49 --- mode: ChanServ set +o Heffalump
12:06:57 --- mode: Heffalump set -R
12:07:52 * Heffalump watches paranoidly
12:08:49 * augustss agonizes over how much current work to put in his slides.
12:09:05 <Heffalump> because it's unfinished, or because it's secret?
12:09:26 <mauke> hmm, I need a way to submit a POST request with no user interaction
12:09:45 <mauke> that's the only thing this exploit really needs javascript for
12:09:49 <augustss> Secret.  In the usual way these things are secret.
12:09:56 <EvanCarroll>  /join #lispcafe
12:10:47 <augustss> Eh, Andrew Appel suggested it 22 years ago, so I can put it on slides. :)
12:12:09 <copumpkin> oh no, it's augustss the spamm0r
12:12:19 <xerox> mauke what kind of action?
12:12:38 <aep> is there any smarter way for this? http://codepad.org/KoME8NMS
12:12:44 <mauke> xerox: what?
12:13:14 <augustss> I'm back with a vengence!
12:13:50 <xerox> mauke I mean there's not much user interaction needed to run javascript except clicking on an url
12:14:09 <mauke> xerox: I want to make it work without javascript
12:14:35 <aep> or here some more context http://codepad.org/Pz4EOOqo   it's quite ugly, but i dont know any better :/
12:14:36 <mauke> and it all works, except for x.submit()
12:17:55 <xerox> mauke <meta http-equiv="Refresh" content="0; url=http://www.example.com/"> ?
12:18:39 <mauke> xerox: that's GET, not POST
12:18:44 <xerox> :|
12:20:42 <Vitka> > let l = 5 in test l = [x:xs | x <- [l,l-1..1], xs <- list2' x ]
12:20:43 <lambdabot>   <no location info>: parse error on input `='
12:20:54 <Vitka> Oops
12:22:12 * hackagebot upload: pointless-lenses 0.0.4 - Pointless Lenses library (HugoPacheco)
12:22:18 <Vanadium> mauke: How set are you on the "no user interaction"?
12:22:35 <Vanadium> mauke: What if you just cram everything into a hidden form and make the user click a 'yes i confirm to be over eighteen years of age' button?
12:22:51 <Cale> Vitka: The idea behind the function I gave before is that every nonempty partition of n with largest part at most k consists of a maximal part x with 1 <= x <= k, followed by a partition of (n-x) into parts of size at most x.
12:22:53 <monochrom> mauke wants to eliminate that button too.
12:22:55 <mauke> Vanadium: too trivial
12:23:58 <ddarius> augustss: Isn't most work previously researched by John Reynolds 10-30 years ago?
12:24:06 <monochrom> html alone has a pretty passive semantics. you can't do it.
12:24:12 <Vitka> > let l = 5; test l = [x:xs | x <- [l,l-1..1], xs <- test x ] in test 5
12:24:14 <lambdabot>   * Exception: stack overflow
12:24:32 <augustss> ddarius: yes, I'm sure he's done this too.  It's trivial anyway.
12:24:54 <monochrom> What secret?
12:25:44 <Vitka> Cale: It doesn't seem to work for x > k.
12:26:02 <Vitka> > let partitions' n k | k > n = partitions' n n; partitions' 0 k = [[]]; partitions' n k | k <= 0 = []; partitions' n k = [x:xs | x <- [k,k-1..1], xs <- partitions' (n-x) x] in partitions' 8 3
12:26:03 <lambdabot>   [[3,3,2],[3,3,1,1],[3,2,2,1],[3,2,1,1,1],[3,1,1,1,1,1],[2,2,2,2],[2,2,2,1,1...
12:26:28 <Cale> oh?
12:26:39 <Vitka> > let partitions' n k | k > n = partitions' n n; partitions' 0 k = [[]]; partitions' n k | k <= 0 = []; partitions' n k = [x:xs | x <- [k,k-1..1], xs <- partitions' (n-x) x] in partitions' 3 8
12:26:40 <lambdabot>   [[3],[2,1],[1,1,1]]
12:26:45 <Cale> x will never be larger than k
12:27:06 <Vitka> What about f(8)=[7,1] for example?
12:27:28 <Cale> That's not a partition of 8 into parts of size at most 3, like you asked for
12:27:36 <Cale> > let partitions' n k | k > n = partitions' n n; partitions' 0 k = [[]]; partitions' n k | k <= 0 = []; partitions' n k = [x:xs | x <- [k,k-1..1], xs <- partitions' (n-x) x] in partitions' 8 8
12:27:37 <lambdabot>   [[8],[7,1],[6,2],[6,1,1],[5,3],[5,2,1],[5,1,1,1],[4,4],[4,3,1],[4,2,2],[4,2...
12:29:10 <Vitka> No, parts can be up to n, but sum parts == n, and there are k parts total. (3 in my case)
12:29:43 <Cale> Oh, if you want at most k parts, then you need to conjugate the partitions.
12:30:09 <Cale> Well, or you could add another parameter for the number of parts
12:30:39 <Vitka> I suck at math I can't find respective combinatorial problem, so I'm trying to implement algorithm I've found and understood.
12:31:07 <Cale> > let partitions' n k m | k > n = partitions' n n m; partitions' 0 k 0 = [[]]; partitions' n k | (k <= 0 || m <= 0) = []; partitions' n k m = [x:xs | x <- [k,k-1..1], xs <- partitions' (n-x) x (m-1)] in partitions' 8 8 2
12:31:09 <lambdabot>   Equations for `partitions'' have different numbers of arguments
12:31:09 <lambdabot>    <interac...
12:31:12 <Cale> oops
12:31:19 <Cale> > let partitions' n k m | k > n = partitions' n n m; partitions' 0 k 0 = [[]]; partitions' n k m | (k <= 0 || m <= 0) = []; partitions' n k m = [x:xs | x <- [k,k-1..1], xs <- partitions' (n-x) x (m-1)] in partitions' 8 8 2
12:31:21 <lambdabot>   [[7,1],[6,2],[5,3],[4,4]]
12:31:29 <Cale> > let partitions' n k m | k > n = partitions' n n m; partitions' 0 k 0 = [[]]; partitions' n k m | (k <= 0 || m <= 0) = []; partitions' n k m = [x:xs | x <- [k,k-1..1], xs <- partitions' (n-x) x (m-1)] in partitions' 8 8 3
12:31:30 <lambdabot>   [[6,1,1],[5,2,1],[4,3,1],[4,2,2],[3,3,2]]
12:31:48 <Vitka> Oh.
12:32:10 <Cale> Partitions of n into parts of size at most k with exactly m parts
12:33:39 <Cale> Putting a bound on the size of the parts is important for the recursive decomposition because you want to construct weakly decreasing sequences.
12:34:13 <Cale> So when the sequence starts with some number x, it has to be followed by a partition that has no parts larger than x
12:34:15 * hackagebot upload: amqp 0.1 - Client library for AMQP servers (currently only RabbitMQ) (HolgerReinhardt)
12:34:45 <olsner_> hmm, I see that the Haskell' proposal for scrapping the MR is lacking an owner
12:34:52 <Vitka> That what I tried to do, appending ones, and them I wanted to go up to n recursively.
12:35:09 <Vitka> But anyway, thanks.
12:35:53 <aep> can i map a C struct to some haskell type?
12:36:25 <dcoutts_> aep: see Storable class in Foreign.* modules
12:37:39 <bremner> would some kind op mind popping over to #xmonad? it needs droneproofing
12:41:48 <Cale> Vitka: well, going up is no harder, it just means you write a function which puts a bound on the smallest part
12:45:01 <Vitka> Yeah, but I'm still struggling with proper use of recursion, as you can see.
12:51:44 <Cale> > let partitions' n k | k <= 0 = partitions' n 1; partitions' 0 k = [[]]; partitions' n k | (n < k) = []; partitions' n k = [x:xs | x <- [k..n], xs <- partitions' (n-x) x] in partitions' 6 1
12:51:45 <lambdabot>   [[1,1,1,1,1,1],[1,1,1,1,2],[1,1,1,3],[1,1,2,2],[1,1,4],[1,2,3],[1,5],[2,2,2...
12:51:51 <Cale> > let partitions' n k | k <= 0 = partitions' n 1; partitions' 0 k = [[]]; partitions' n k | (n < k) = []; partitions' n k = [x:xs | x <- [k..n], xs <- partitions' (n-x) x] in partitions' 4 1
12:51:52 <lambdabot>   [[1,1,1,1],[1,1,2],[1,3],[2,2],[4]]
12:52:57 <Cale> > let partitions' n k m | k <= 0 = partitions' n 1 m; partitions' 0 k 0 = [[]]; partitions' n k m | (n < k || m <= 0) = []; partitions' n k m = [x:xs | x <- [k..n], xs <- partitions' (n-x) x (m-1)] in partitions' 8 1 3
12:52:59 <lambdabot>   [[1,1,6],[1,2,5],[1,3,4],[2,2,4],[2,3,3]]
12:53:05 * Berengal wishes Haskell had proper goal support
12:55:07 <ddarius> "goal support"?
12:55:55 <Berengal> Like in Agda
12:56:21 <Berengal> You can make holes in expressions, and it tells you which type should be in that hole
12:56:42 <Berengal> Also, you can ask for the type of other things in the environment at that hole, such as local bindings
12:56:58 <ddarius> @google Chameleon type debugger
12:56:59 <lambdabot> http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.73.6170&rep=rep1&type=pdf
12:57:00 <lambdabot> Title: The Chameleon Type Debugger (Tool Demonstration)
12:57:18 <{newbie}> hi guys does anyone know of a nice intro to monads
12:57:24 <kmc> oh dear
12:57:34 <kmc> {newbie}, how much Haskell experience do you have?
12:57:34 <{newbie}> it could have a bit of theory mixed in but not much
12:57:37 <ddarius> "The essence of functional programming"
12:57:38 <{newbie}> 0
12:57:44 <{newbie}> it's not for haskell
12:57:46 <kmc> oh
12:57:50 <kmc> what's it for?
12:57:54 <{newbie}> but since your are the main used of monads
12:58:04 <ddarius> Definitely not.
12:58:05 <{newbie}> kmc: it's to get the general concepts
12:58:12 <{newbie}> to apply in any language
12:58:12 <kmc> sounds like theory is not the main goal... so what do you want to know them for?
12:58:14 <kmc> ah
12:58:15 <Berengal> Haskell monads are not really category theory monads
12:58:19 <kmc> well, i'd advise learning Haskell then
12:58:23 <Berengal> They look like them, if you squint a bit
12:58:25 <ddarius> Berengal: They are definitely a special case.
12:58:50 <{newbie}> I tried to follow some tutprials for clojure
12:58:57 <ddarius> At least if you idealize Haskell slightly.
12:59:00 <kmc> {newbie}, the explanation of Haskell monads will assume you've learned a lot of other things about Haskell first
12:59:04 <{newbie}> but I didn 't get the core idia
12:59:07 <kmc> because they're not a beginner topic
12:59:08 <kmc> ah
12:59:10 <Berengal> clojure has monads?
12:59:16 <kmc> any functional language has them
12:59:28 <merehap> C# has monads, they are just ugly as hell
12:59:33 <Berengal> I'd think types are a requirement...
12:59:39 <ddarius> merehap: The LINQ syntax isn't bah.
12:59:41 <kmc> Berengal, clojure has types of course
12:59:42 <ddarius> s/bah/bad
12:59:45 <kmc> they are not static
12:59:51 <kmc> but why would static types be required for monads?
12:59:53 <ddarius> Types are not a requirement.
12:59:56 <Berengal> kmc: I meant static types
13:00:03 <kmc> all you need is return and bind
13:00:04 <merehap> ddarius: not too bad anyway
13:00:07 <{newbie}> kmc: so  hasking here
13:00:08 <kmc> you can write those in a dynamically typed language
13:00:17 <{newbie}> was not he best idea
13:00:19 <Berengal> kmc: But you need type-based dispatch
13:00:19 <kmc> {newbie}, i can try to give you the general idea
13:00:20 <{newbie}> right?
13:00:24 <kmc> of monads
13:00:29 <kmc> without Haskell stuff mixed in
13:00:37 <kmc> but i warn you it may be pretty vague
13:00:52 <kmc> Berengal, sure, and type-based dispatch is ubiquitous in dynamically typed languages
13:01:04 <{newbie}> 1okay
13:01:08 <{newbie}> thanks alot
13:01:09 <{newbie}> !
13:01:17 <Berengal> kmc: No it's not. dynamically typed languages only have value-based dispatch
13:01:17 <ddarius> You don't need type-based dispatch.
13:01:43 <kmc> Berengal, and the type is part of the value
13:02:23 <Berengal> ddarius: The alternative is to select the monad beforehand. Push it into the context, sort of thing
13:02:47 <Berengal> kmc: But you need a value to get at the type. For "return", you have to value.
13:03:05 <ddarius> Berengal: There are probably more alternatives than that (I'm not quite sure what you mean), but there only needs to be one alternative.
13:03:18 <kmc> {newbie}, here's a simple example of a monad
13:03:24 <kmc> in Haskell, we have this Maybe type
13:03:24 <aavogt> ddarius: as in, monads are still useful when you have   returnmaybe , bindMaybe, or that it is possible to have code for a general monad without type-based dispatch?
13:03:35 <ddarius> aavogt: Both.
13:03:47 <trofi> #xmonad is being flooded
13:03:50 <lunabot>  luna: Not in scope: `xmonad'
13:03:54 <kmc> if T is a type, then (Maybe T) is another type
13:04:16 <{newbie}> okay that similar to scalas Option
13:04:30 <kmc> for each value x in T,  the value (Just x) is in (Maybe T)
13:04:37 <kmc> and additionally, the value Nothing is in (Maybe T)
13:04:43 <kmc> {newbie}, yes i imagine so
13:04:45 <Berengal> ddarius: I haven't seen a non-painful way that doesn't use type-based dispatch
13:05:00 <tensorpu`> :t Nothing
13:05:01 <lambdabot> forall a. Maybe a
13:05:10 <kmc> now this is just a fairly ordinary algebraic data type
13:05:34 <{newbie}> okay
13:07:01 <kmc> but it's also a monad, which means that two functions exist for this type
13:07:33 <kmc> one of them I'll call "inject".  it takes a value of type T, and gives you a value of type Maybe T
13:07:38 <kmc> in this case, it just maps x to Just x
13:08:14 <kmc> the other one I'll call "bind".  it takes a value of type Maybe (Maybe T), and gives you a value of type Maybe T
13:08:24 <kmc> we'll collapse both Nothing and (Just Nothing) into Nothing
13:08:29 <aavogt> why would you call join bind?
13:08:31 <Berengal> *cough* join *cough*
13:08:33 <kmc> sorry
13:08:36 <kmc> yes, it's called join
13:08:46 <kmc> sorry, bind is another thing i'll get to in a second
13:08:51 <kmc> (Just (Just x)) becomes (Just x)
13:08:55 <kmc> {newbie}, with me so far?
13:09:00 <{newbie}> okay so inject is like a wrapper
13:09:19 <{newbie}> join I'm still trying to understand
13:09:24 <kmc> and join reduces a double layer of wrapping to a single layer
13:09:41 <aavogt> there are lots of redundant sets of terminology
13:10:19 <{newbie}> okay
13:10:35 <kmc> so a monad is just any type with this structure: inject and join
13:10:42 <Berengal> And map
13:10:48 <Berengal> Can't have a monad without map
13:10:51 <kmc> good point
13:11:07 <kmc> map takes a function (A -> B) and gives us a function (Maybe A -> Maybe B)
13:11:21 <aavogt> > join :: Maybe (Maybe ()) -> Maybe ()
13:11:23 <lambdabot>   {Nothing->Nothing;Just Nothing->Nothing;Just (Just ())->Just ()}
13:11:28 <kmc> (map f) will map Nothing to Nothing, and will map (Just x) to (Just (f x))
13:11:31 <aep> in    :: Maybe (IO Int)      how would i use some other io? oO
13:11:36 <kmc> so it "lifts" a function into the wrapper type
13:11:40 <kmc> aep, what do you mean?
13:11:52 <aavogt> where () is some arbitrary value here
13:11:54 <aep> well i can't do things like x <- read
13:11:56 <{newbie}> so a monad is just that?
13:12:07 <aavogt> it could be something more useful like an Int or something
13:12:23 <kmc> {newbie}, a monad is any type with this structure.  but i haven't yet explained why they're useful
13:12:33 <Berengal> {newbie}: You might want to read http://blog.sigfpe.com/2010/01/monads-are-trees-with-grafting.html
13:12:51 <kmc> i haven't explained why we want to talk about monads in general, instead of just the properties of Maybe and each other monad individually
13:13:29 * hackagebot upload: hack-handler-hyena 2010.1.17 - Hyena hack handler (JinjingWang)
13:13:31 <hatds> that's probably the best way to appreciate them anyway
13:13:36 <{newbie}> ok so now is the interesting part!
13:13:52 <kmc> in terms of functional programming, we want to use inject, join, and map to define another function i'll call "bind"
13:14:17 <aavogt> I call it the haskell logo
13:14:25 <hatds> lol
13:14:36 <tensorpudding> inject?
13:14:44 <Berengal> tensorpudding: return
13:14:51 <kmc> tensorpudding, this is a non-Haskell-specific explanation
13:15:01 <aavogt> tensorpudding: pure
13:15:01 <tensorpudding> hmm, so only haskell calls it return?
13:15:12 <kmc> i think "inject" is a clearer name
13:15:13 <tensorpudding> i thought CT called it eta
13:15:20 <Berengal> tensorpudding: Renamed for the occation for the purposes of connotations, I assume
13:15:23 <tensorpudding> inject has a better duality with extract
13:15:29 <tensorpudding> :t extract
13:15:31 <lambdabot> forall source. (Extract source) => (Int, Int) -> source -> source
13:15:36 <kmc> {newbie}, bind is a function of two arguments. in our case, it will take a value of type (Maybe A), and a function (A -> Maybe B)
13:15:37 <aavogt> eject?
13:15:38 <tensorpudding> eh?
13:15:41 <kmc> it returns a value of type (Maybe B)
13:15:44 <tensorpudding> i'm thinkinf of the comonad one
13:16:01 <tensorpudding> (Comonad w) => w a -> a
13:16:25 <aavogt> @hoogle coreturn
13:16:26 <lambdabot> No results found
13:16:38 <tensorpudding> actually, seems that it is generalized to Copointed
13:16:53 <kmc> bind Nothing f = Nothing
13:17:01 <kmc> bind (Just x) f = Just (f x)
13:17:10 <kmc> sorry
13:17:13 <kmc> bind (Just x) f = f x
13:17:29 <mauke> Vanadium: http://mauke.ath.cx/exe/cake
13:17:42 <kmc> what this represents is a "computational strategy".  we take a result, that could represent success or failure, and a function.  if the result was failure, we don't call the function and we simply return failure.  if the first result was success, we call the function, which can succeed or fail
13:18:23 <{newbie}> kmc the strategy you speak about
13:18:27 <{newbie}> it's in the f
13:18:32 <{newbie}> or in the moand itself?
13:18:38 <Vitka> > let partitions' n k m | k > n = partitions' n n m; partitions' 0 k 0 = [[]]; partitions' n k m | (k <= 0 || m <= 0) = []; k ==0 = 0; partitions' n k m = [x:xs | x <- [k,k-1..0], xs <- partitions' (n-x) x (m-1)] in partitions' 8 8 3
13:18:39 <lambdabot>   Conflicting definitions for `partitions''
13:18:40 <lambdabot>  In the binding group for: partit...
13:18:40 <kmc> it's in the definition of "bind"
13:18:40 <xerox> mauke evil
13:18:56 <kmc> which is specific to each monad
13:19:11 <mauke> xerox: click it :-)
13:19:18 <{newbie}> ok
13:19:28 <xerox> mauke no :)
13:19:32 <kmc> {newbie}, so Maybe represents "computation with failure"
13:19:38 <mauke> you can see the irc messages in your browser, it's pretty awesome
13:20:05 <Vitka> > let partitions' n k m | k > n = partitions' n n m; partitions' 0 k 0 = [[]]; partitions' n k m | (k <= 0 || m <= 0) = []; partitions' n k m | k ==0 = 0; partitions' n k m = [x:xs | x <- [k,k-1..0], xs <- partitions' (n-x) x (m-1)] in partitions' 8 8 3
13:20:06 <lambdabot>   No instance for (GHC.Num.Num [[t]])
13:20:06 <lambdabot>    arising from a use of `partitions'' ...
13:20:21 <monochrom> mauke: Write this on the button: "Do not click the Ackerman function!" :)
13:20:26 <Vitka> > let partitions' n k m | k > n = partitions' n n m; partitions' 0 k 0 = [[]]; partitions' n k m | (k < 0 || m <= 0) = []; partitions' n k m | k ==0 = 0; partitions' n k m = [x:xs | x <- [k,k-1..0], xs <- partitions' (n-x) x (m-1)] in partitions' 8 8 3
13:20:27 <lambdabot>   No instance for (GHC.Num.Num [[t]])
13:20:27 <lambdabot>    arising from a use of `partitions'' ...
13:20:33 <kmc> {newbie}, other monads represent computation with other features
13:20:44 <kmc> for example, lists are also a monad
13:20:46 <kmc> we can write:
13:20:58 <kmc> inject : a -> [a]
13:21:02 <kmc> builds a singleton list
13:21:05 <kmc> join : [[a]] -> [a]
13:21:08 <kmc> flattens a list of lists
13:21:16 <kmc> map : (a -> b) -> ([a] -> [b])
13:21:19 <kmc> the ordinary map function
13:21:29 <kmc> the list monad then represents nondeterministic computation
13:21:44 <kmc> a function of type (a -> [b]) takes a value of type a, and yields zero or more values of type b
13:21:50 <{newbie}> o now I get one of the examples that used lists!
13:22:02 <kmc> we can use the monad operators to compose this with another function (b -> [c])
13:22:18 <kmc> and so forth
13:22:23 <Vitka> > let partitions' n k m | k > n = partitions' n n m; partitions' 0 k 0 = [[]]; partitions' n k m | (k < 0 || m <= 0) = []; partitions' n k m | k == 0 = 0; partitions' n k m = [x:xs | x <- [k,k-1..1], xs <- partitions' (n-x) x (m-1)] in partitions' 8 8 3
13:22:24 <lambdabot>   No instance for (GHC.Num.Num [[t]])
13:22:24 <lambdabot>    arising from a use of `partitions'' ...
13:22:25 <kmc> building a big chain of nondeterministic computations
13:22:47 <kmc> which will be searched in a breadth first way, building a list of possible results at each stage.... except in Haskell, evaluation is lazy so it's not really breadth first
13:23:49 <kmc> other things we represent as monads: exceptions, logic programming, mutable state, IO, parsers, code generators, software transactional memory
13:24:11 <{newbie}> kmc in the case of lists
13:24:12 <kmc> the point of recognizing "monad" as an abstraction is that we can use the same combinators and syntax for all of these
13:24:14 <{newbie}> using moands
13:24:33 <{newbie}> the first function could be combined with the second to yield
13:24:46 <{newbie}> something like fun)a -> [c])
13:25:02 <{newbie}> using monad operations*
13:25:14 <tensorpudding> there are functors, and there are monads, and then there are the things inbetween
13:25:22 <kmc> yes
13:25:27 <kmc> :t (>=>)
13:25:28 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
13:25:55 <kmc> {newbie}, if you're into theory, the composition of functions like (a -> M b) forms a category called the Kleisli category of the monad M
13:26:30 <{newbie}> kmc so if I understand this correctly
13:26:45 <{newbie}> monads are like a super sized composition function
13:27:01 <aep> O:  "openFile: resource exhausted (Too many open files)"
13:27:02 <{newbie}> that expresses some sor of adidional control
13:27:08 <{newbie}> before composing
13:27:09 <Berengal> Hah, simply flipping arrows around gives you lots of definitions for free!
13:27:25 <Berengal> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16209#a16209
13:27:57 <tensorpudding> bind is kinda like a fancy composition
13:28:09 <tensorpudding> i kinda think of it like a bunch of elephants
13:28:30 <tensorpudding> m a is the elephant, and it sticks out its tail a, which the elephant m b behind it grabs with its trunk
13:28:40 <kmc> {newbie}, yes.  defining a new monad consists of two things:  1) define a datatype with one type parameter;  2) define how to inject values into this type, and how to compose functions of the form (a -> M b)
13:28:59 <Berengal> tensorpudding: Someone had an analogy like that, but with unicorns...
13:29:26 <kmc> @quote analogy
13:29:26 <lambdabot> lilac says: * lilac looks forward to Cale explaining category theory by analogy to Call of Duty
13:29:27 <kmc> @quote analogy
13:29:28 <lambdabot> lilac says: * lilac looks forward to Cale explaining category theory by analogy to Call of Duty
13:29:47 <{newbie}> kmc thanks very much for the explanation
13:29:47 <kmc> @quote bad.explanations
13:29:47 <lambdabot> dmwit says: analogies are endofunctors in the category of bad explanations
13:29:51 <kmc> {newbie}, no problem
13:29:54 <{newbie}> I think
13:30:03 <Berengal> @quote dons analogy
13:30:04 <lambdabot> dons says: xerox: what analogy or metaphor did you use? monad-as-garbage-bin? monad-as-refrigerator? monads-as-unicycle?
13:30:14 <monochrom> @quote monochrom like
13:30:15 <lambdabot> monochrom says: If you're having trouble learning monads, try to learn something harder, like algebraic geometry.
13:30:21 <{newbie}> i'll play a bit with haskell just to improuve my understanding of monads
13:30:21 <monochrom> Oh hahaha
13:30:29 <kmc> {newbie}, cool :)
13:30:32 <{newbie}> :D
13:30:38 <DrTeggy> @quote unicorn
13:30:39 <lambdabot> v_ says: Haskell shits rainbows, monads and unicorns
13:30:45 <DrTeggy> Ugh
13:30:49 <tensorpudding> hmm
13:30:54 <tensorpudding> unicorns don't exist
13:31:00 <monochrom> Ideally you should also verify that the monad you designed satisfies the laws.
13:31:07 <tensorpudding> they're like forall a b. a -> b
13:31:08 <mauke> @quote late.rob
13:31:08 <lambdabot> Duqicnk says: a monad is like a train that runs backwards in time, which is made of tiny chocolate robots
13:31:17 <int-e> tensorpudding: at least one does. it's pink, and invisible ;-)
13:32:35 <tensorpudding> if unicorns were like haskell, they would be awfully beautiful but you'd never want to look under the hood
13:32:47 <sinelaw> @quote monad
13:32:47 <lambdabot> WillDonnelly says: monads are okay after a bit (though I'm still a little suspicious of them)
13:32:50 <sinelaw> @quote monad
13:32:50 <lambdabot> buttbot2 says: "I'd butt linux on the butt, I'd like to give xmonad a try"
13:32:52 <sinelaw> @quote monad
13:32:53 <lambdabot> Cale says: Removing monad comprehensions was actually the snowball which caused the avalanche of fail in Haskell 98
13:33:12 <DrTeggy> How true.
13:33:41 <Polarina> @quote Polarina
13:33:41 <lambdabot> No quotes match. You untyped fool!
13:33:43 <Polarina> :(
13:34:48 <int-e> @quote o.c.m.u.e.t.i.g
13:34:48 <lambdabot> taruti says: damn GHC. I had a nice example for a pretty but inefficient way to compute things and now the new GHC optimizes it to be fast ._.
13:34:57 <McManiaC> theres no foreign function interface for c++, is there?
13:35:06 <kmc> McManiaC, from Haskell to C++?
13:35:17 <McManiaC> using C++ stuff in haskell
13:35:21 <kmc> calling C++ from any other language (or from another C++ implementation on the same machine) is a royal pain
13:35:30 <monochrom> Right, there is none.
13:35:32 <kmc> you're best off wrapping your C++ functions with a C API
13:35:35 <kmc> which is not too hard
13:36:15 <aep> the garbage collector collects fds,  right? how do i call it manually?
13:36:27 <hatds> fds?
13:36:30 <int-e> @index performGC
13:36:31 <lambdabot> System.Mem
13:36:35 <aep> file dewscriptors
13:37:16 <DigitalKiwi> -w
13:37:26 <kmc> i don't think the GC would have anything to do with closing file descriptors
13:37:31 <kmc> unless you've associated one with a ForeignPtr
13:37:39 <trofi> @hoogle finalizePtr
13:37:40 <lambdabot> No results found
13:37:50 <int-e> ... but when you deal with many files (or network connections or pipes) you'll probably be happier with strict IO or explicitely closing files.
13:37:53 <monochrom> Don't wait for GC to close files. (It can, but you don't know how long to wait.) Just bloody close yourself.
13:38:03 <aep> ok manual performGC  doesnt work.  what do i need to do to close open fds?
13:38:11 <kmc> hClose ?
13:38:12 <aep> well i can't. i dont have the fd
13:38:13 <kmc> :t hClose
13:38:14 <lambdabot> Not in scope: `hClose'
13:38:18 <mauke> aep: why not?
13:38:21 <aep> i used readFile
13:38:30 <mauke> how often?
13:38:32 <kmc> don't use lazy IO
13:38:37 <aep> ~200K times
13:38:37 <kmc> if you care about when it happensl
13:38:39 <monochrom> OK, ensure you completely consume that string. That ensures close file.
13:38:46 <mauke> eek
13:38:51 <int-e> then make sure you either consume all the returned data ... or that it's no longer reachable before the GC runs.
13:38:58 <aep> i never completely read any of them D:
13:39:05 <kmc> lazy IO is a hack
13:39:44 <aep> so i should use the low level api?
13:40:23 <aep> i think the problem is my mapM
13:40:40 <aep> i have something like "mapM  readFile files "
13:40:40 <int-e> we don
13:40:54 <aep> i read that this might couse problem, but i dont know any better :/
13:43:19 <int-e> can you turn that into a  mapM processFile files  where processFile would extract the necessary data from the file and then close it?
13:43:35 <aep> i do that
13:43:41 <aep> except i dont know how to close it
13:44:48 <aep> low level api will do it i guess
13:45:25 <mauke> :t withFile
13:45:26 <lambdabot> Not in scope: `withFile'
13:45:29 <monochrom> I don't understand what you mean by low level api, and if I understood I would still refuse to say it.
13:45:37 <monochrom> @hoogle withFile
13:45:38 <lambdabot> System.IO withFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r
13:45:57 <monochrom> openFile and hClose and withFile are not low level.
13:46:32 <monochrom> If you get down to hGetBuf then maybe I might agree it begins to be slightly low level.
13:46:59 <ddarius> openFile "/dev/hda"
13:47:49 <aep> huh withfile is cool
13:48:51 <aep> but how do i read from the handle now ? :/
13:48:54 <int-e> You can even use hGetContents *if* you're careful to read enough data (by forcing the extracted data, say) before the file gets closed - i.e. before the  Handle -> IO r  part returns.
13:49:03 <aep> other then character by character
13:49:19 <BONUS> :t ContT (withFile "bla" ReadMode)
13:49:21 <lambdabot> Not in scope: `withFile'
13:49:21 <lambdabot> Not in scope: data constructor `ReadMode'
13:49:25 <aep> uh
13:49:30 <aep> int-e: what?
13:49:33 <mauke> aep: how much do you want to read?
13:49:46 <aep> only the first few lines from a few thousand files
13:49:53 <mauke> hGetLine?
13:50:12 <aep> i wasted 8 hours building this with lists D:
13:51:12 <aep> this is really discouraging. pretty much all high level stuff i tried so far seems to not work at all in reality
13:51:22 <monochrom> How large is each file? How much memory you're willing to use?
13:51:36 <aep> not much, and not much
13:51:48 <aep> like 3kb
13:52:06 <aep> but it doesn't matter. i don't see whay i have to read the entire file in the first place
13:52:12 <aep> i though thats what lazy evaluation is for
13:52:15 <int-e> you don't
13:52:39 <aep> yes, i dont if i use imperative api
13:52:41 <mauke> technically that's not what lazy evaluation is for
13:52:47 <aep> which is hard, since haskell doesnt allow DFAs
13:52:50 <monochrom> use strict bytestring or the strict i/o library to readFile. They are not lazy, they read the whole file into memory. The benefit is you need little change to your code.
13:52:59 <mauke> aep: DFAs?
13:53:06 <aep> state engines
13:53:13 <mauke> how does Haskell not allow them?
13:53:51 <aep> stuff like  ref1,ref2  while(line=read file){ if(line. ..   then ref1=line
13:54:05 <mauke> that's not a DFA
13:54:31 <aep> well whats the correct word? :)
13:54:31 <mauke> also, you can write that in Haskell
13:54:36 <trofi> FSM?
13:54:41 <monochrom> If you still complain, I'll just prescribe another 8 hours of learning and using Oleg's Iteratee, does exactly all your requirements: lazy, automatic close, high level, clean conscience, untainted soul...
13:54:42 <sproingie> ramen
13:54:49 <mauke> a while loop? variables?
13:54:55 <sproingie> C
13:55:03 <mauke> I can write C in Haskell
13:55:12 <aep> McManiaC:  got a link?
13:55:12 <sproingie> i feel icky using one ioref
13:55:21 <sproingie> tho i'm about to use a whole damn array of 'em
13:55:25 <medfly> it's kind of hard to write Haskell in C, though
13:55:42 <McManiaC> aep: hm?
13:55:57 <aep> yeah i know. the depressing thing is that haskell seems to awesome in its purity concepts, but in the end everyone just uses it like C
13:56:05 <aep> McManiaC: wrong nick, sorry
13:56:08 <medfly> what are you talking about?
13:56:10 <aep> monochrom: got a link?
13:56:11 <McManiaC> kay
13:56:12 <medfly> "everyone just uses it like C"
13:56:14 <medfly> what everyone?
13:56:21 <Polarina> aep: I don't!
13:56:21 <sproingie> programs with zero side effects aren't very interesting
13:56:30 <hatds> who was it that was like "IO is not always like C"
13:56:50 <monochrom> even got a hackage package. http://hackage.haskell.org/package/iteratee
13:57:23 <kwos> hi
13:57:35 <dufflebunk> Hello kwos
13:57:37 <c_wraith> Hmm.  My haskell code looks nothing like C.  Even the bits where I'm doing imperative things, it's nothing like C.
13:57:43 <aep> thanks
13:57:47 <int-e> aep: so basically you're saying that Haskell sucks because lazy IO - which is well recognized as a slick but dangerous hack that doesn't work in a number of cases - doesn't work for your problem.
13:58:09 <aep> int-e: i didn't say "haskell sucks"
13:58:36 <monochrom> If I used Haskell like C, I would be retrofitting every data structures into arrays. Clearly I don't; I use Data.Map.
13:58:38 <medfly> you should, "Haskell sucks because I can't get it to do the right thing for me!"
13:58:41 <aep> i was whining that its awesomeness is impratical
13:59:02 <int-e> ok, I'm with monochrom. learn about iteratees
13:59:10 <ddarius> monochrom: You retrofit every data structure into associative maps?  You use Haskell like Perl?
13:59:29 <trofi> like c++
13:59:34 <aep> int-e: doing :)
13:59:43 <monochrom> Oh I use MVar and Chan too.
13:59:56 <aep> although i'm not sure i can handle it in my nobism. sounds hard
14:01:16 <monochrom> I don't understand why if I write my main and I/O code in C style then it is called I use Haskell like C. It's just half of my program. The other half is unlike C, unlike everything. How is it like C? I don't understand.
14:01:41 <monochrom> It is like when you see my source code files are in ascii you say I use haskell like plain text file.
14:01:53 <Berengal> How is main and IO like C anyway? Haskell's IO language is very high-level
14:01:54 <mauke> what the heck is enumFd?
14:02:22 <Peter_> Hello, I was wondering, has anyone been successful in getting Leksah to work on a Windows 7 machine?
14:02:54 <aep> um... look, i'm just some random noob who reads about lazy evaluation, thinks its awesome, uses it, and it breaks. then i ask here and i am told to use the same aproach i did 30 years ago in C
14:03:13 <medfly> OH MAN SOMETHING IS LIKE C THEN HASKELL IS NOT COOL
14:03:22 <tommd> I don't know any Haskellers who use Window7, but I have used Leksah on Linux and based on that wouldn't yet use Lesksah for any development yet (on any platform).
14:03:32 <aep> *sigh* never mind
14:03:48 <mauke> aep: yeah, readFile is technically broken
14:03:54 <int-e> but it's not lazy evaluation that breaks - what breaks is lazy IO.
14:04:03 <Berengal> aep: Lazy evaluation doesn't break. Lazy execution does.
14:04:09 <monochrom> Do you know that the other half of my program uses the same approach Backus did 30 years ago in FP.
14:04:09 <aep> i see
14:05:13 <aep> ok so the general aproach is to split programs into IO and pure and try to keep lazy out of the IO part  ?
14:05:22 <int-e> (Hey, we could blame the OS for not giving us unlimited FDs ... :) )
14:05:39 <int-e> aep: yep
14:05:46 <Berengal> aep: Yes. Splitting IO and pure code is a good thing
14:05:54 <aep> make sense, thanks
14:05:59 <monochrom> My general approach is I don't reject 30-year-old methods automatically.
14:06:08 <Berengal> aep: And usually makes for better algorithms too, since you won't be interleaving pure computation with IO
14:06:14 <McManiaC> why do I get "...missing" messages with "cabal configure"? that package is installed via cabal
14:06:23 <Peter_> tommd: well, what IDE/editor would you recommend in that case? I am not very fond of vim and have not yet tried Emacs. I read that there is an eclipse plugin for Haskell, but my experiences with eclipse were very discouraging so far.
14:06:25 <McManiaC> and cabal install works
14:08:02 <Berengal> Peter_: Emacs and vim are the go-to editors for haskell, I believe. There's also yi, which is about as user-friendly as those two. A simple text editor with highlighting also works, and leksah isn't useless
14:09:25 <Peter_> I did try leksah, but I can't get it to load the packages properly, so I guess I am going to have to try emacs
14:09:30 <Berengal> McManiaC: does cabal configure work after you've done a cabal install?
14:09:49 <McManiaC> Berengal: let me testâ€¦
14:10:34 <ddarius> Peter_: You can use any editor you want.
14:14:00 <Peter_> ddarius:I know I can use any editor, I just don't know which one would be the most suitable for a person spoiled by MS Visual studio :)
14:15:30 <tredontho> Peter_: There's an EclipseFP plugin I think that has support for Haskell... I haven't used it, but it might be something to look into
14:16:02 <ddarius> Peter_: You could use MS Visual Studio.
14:16:19 <Heffalump> Visual Haskell is bitrotted.
14:16:37 <Heffalump> the GHC integration only ever worked with GHC 6.6, and wasn't all that good even there.
14:16:48 <Berengal> There's something compelling about a simple editor and REPL as well...
14:17:00 <Heffalump> one colleague does use it just as an editor for later Haskell code, but I don't think very many people do
14:17:09 * ddarius just uses vim and doesn't use any "haskell mode" beyond Haskell syntax highlighting.
14:17:18 <Peter_> Yes, Visual Haskell has basically been abandoned for at least 5 years and does no have support for VS 2008 or greater
14:17:41 <orbitz> I'm working on Hascaml++, should be out in early 2034
14:17:54 * Berengal uses emacs for the syntax highlighting, automatic-ish indentation, and quick send-to-ghci
14:18:05 <hatds> i can has caml?
14:18:16 <orbitz> ++
14:18:21 <hatds> haha
14:18:57 <Peter_> i can has LOLCODE? http://lolcode.com/
14:19:07 * Berengal finds it interesting how "c++" returns the value of c in c++...
14:19:33 <Vanadium> Clearly that is meant to symbolise source code compatibility ;)
14:20:24 <Berengal> Also, int x = c++; if (c > x) printf("c++ is less than c");
14:21:03 * Berengal is done trolling
14:22:16 <mauke> yes, c++ increases the value of c
14:23:26 <c_wraith> but you still use the old value.
14:25:20 <Twey> The magnitude of c, ratherâ€¦
14:25:26 <sieson> I've just started learning Haskell and I don't know whats the difference between the glasgow haskell compiler and haskell 98. Is there any major difference between the two?
14:25:48 <Berengal> sieson: haskell98 is a language standard. GHC is a compiler (which supports that standard)
14:25:52 <mauke> well, one is a compiler and the other is a language
14:26:08 <Berengal> I'd say the difference is pretty major :)
14:26:18 <Cale> GHC supports a lot of additional features beyond Haskell 98
14:26:52 <Berengal> How much of it does it really support by default?
14:27:01 <Berengal> Taking into account the later addendums to the report...
14:27:05 <Philonous> I'm trying to read data from a named pipe, but it gives me EOF when no other process is writing to it. Is there a way to wait for data on a handle that return eof? A bussy loop works, but it kills performance, naturally.
14:27:26 <Berengal> Philonous: threadDelay :)
14:27:33 <taruti> Philonous: ffi ;)
14:27:38 <Berengal> Philonous: I'd say EOF is the correct behaviour in that case...
14:27:58 <sieson> Berengal: thanks - So there is no compiler which is called haskell 98? I have to download GHC in order to compile standard haskell code?
14:27:59 <Philonous> Berengal: It's correct, but I still want to wait for a process writing to the pipe
14:28:12 <taruti> sieson: yes, install GHC.
14:28:24 <taruti> sieson: what OS are you using?
14:28:31 <Berengal> Philonous: threadDelay then
14:28:38 <sieson> taruti: ubuntu
14:28:46 <mauke> Philonous: you could do a blocking open
14:28:51 <Philonous> Berengal: I wanted to avoid threadDelay as it leaves me with fiddly details like how long to wait between tries
14:28:53 <Berengal> Philonous: Or you could poke around in some of the IO libraries. I think there might've been a blockUntilReadable function somewhere
14:28:53 --- mode: mauke set -o mauke
14:29:04 <mauke> Berengal: EOF is readable
14:29:08 <taruti> sieson: apt-get install ghc6
14:29:16 <Berengal> mauke: There's that...
14:29:34 <BONUS> how's the haskell platform coming along for ubuntu, anyone know?
14:29:47 <Berengal> BONUS: I thought it was in 9.10
14:29:48 <taruti> Philonous: System.Posix supports blocking reads/writes.
14:30:00 <Berengal> BONUS: Or possibly it's slated for 10.4
14:30:13 <Berengal> BONUS: In which case it's in some beta repo somewhere
14:30:25 <sieson> taruti: thanks
14:30:32 <Philonous> Ah ok. Then I'm working on Fs's rathen than handles?
14:30:40 <Philonous> Fds*
14:31:00 <taruti> yes
14:31:18 <Berengal> Philonous: You could write your own Handle implementation of them, if you wanted...
14:31:31 <Berengal> But I'm guessing that's a bit overkill for your purposes
14:31:39 <taruti> Philonous: just make sure the handle is set to be blocking. and the use fdRead.
14:32:24 <taruti> s/handle/fd
14:32:52 <monochrom> Philonous: I don't quite believe it. Named pipe does not give EOF just because the other process doesn't write. The other process has to close the write end in order for the read end to see EOF.
14:33:28 <mauke> monochrom: what other process?
14:33:43 <monochrom> Whoever has the write end.
14:34:01 <Philonous> monochrom: True, but there is no other process yet.
14:34:03 <mauke> no one
14:35:17 <emax> <- newbie - Hi everybody, just visiting during my first steps into Haskell.
14:35:28 <Philonous> emax: Welcome
14:35:34 <c_wraith> emax: welcome.  feel free to ask any questions
14:37:08 <emax> thanks Philonous c_wraith  - no questions so far just beginning to learn. will probably have them later on.
14:37:08 <monochrom> OK, man fifo(7) says "The FIFO  must  be  opened  on both  ends  (reading and writing) before data can be passed.  Normally, opening the FIFO blocks until the other end is opened also." So you don't even get to the read stage, let alone EOF.
14:37:44 <mauke> monochrom: "normally"
14:37:48 <olsner_> parsec :( it seems that my parser either needs more or less 'try's
14:37:49 <mauke> unless you use O_NONBLOCK
14:37:51 <Philonous> monochrom: Haskell handles are always opened non-blocking, so I just get EOF when I try to read from them
14:37:55 <monochrom> Oh gosh, nevermind, it then says on Linux it doesn't block.
14:38:45 <c_wraith> olsner_: that's my main complaint with parsec, and why I eventually switched to an alternate parser combinator library
14:39:11 <monochrom> Text.ParserCombinators.ReadP relieves you from try.
14:39:15 <taruti> olsner_: there are lots of other alternatives that don't need try
14:39:18 <taruti> ReadP is nice
14:39:34 <taruti> why is parsec so popular?
14:39:55 <Berengal> monochrom: It says it doesn't block on Linux if you open it in both read and write mode
14:39:59 <dcoutts_> taruti: ReadP has no error messages
14:40:04 <olsner_> the thing is, I already have the full parser (wrote it one or two years ago) ... I guess I could port it to another combinator library though
14:40:15 <monochrom> OTOH when I use Parsec, I add one lexical layer on top of it, the lexical layer has try, above it I don't try anymore.
14:40:23 <Philonous> Or is there a simpler way to have a shell script communicating with a running haskell process than FIFOs? I am fooling around with an XMPP bot and I want to use it to notify on termination of a script
14:40:32 <mauke> wait, that makes sense
14:40:38 <c_wraith> I like uu-parsinglib because of both not needing try, and because it will correct small errors in input, if so desired.
14:41:15 <mauke> Philonous: what happens when you open the fifo in ReadWriteMode?
14:41:22 <taruti> dcoutts_: various ReadP derivates have them.
14:41:26 <monochrom> Philonous: I agree named pipe is the simplest for this. Shell scripts can't do alot. Can't even tell it to use unix-domain sockets.
14:42:05 <Guest52822> >2 + 2 == 5
14:42:14 <monochrom> you need more space
14:42:28 <dcoutts_> taruti: the only reason I use ReadP is because it's in the base lib, so it's the only choice for Cabal. It's ok apart from the complete lack of error reporting.
14:42:59 <taruti> dcoutts_: and also not needing trys. there are fancier alternatives of course.
14:43:22 <monochrom> I have a feeling ReadP is designed for typeclass Read users.
14:43:22 <dcoutts_> yes, composable by default is good
14:43:45 <medfly> > 2 + 2 == 5
14:43:46 <lambdabot>   False
14:43:57 <dcoutts_> monochrom: yes, the instance of it in base is for ghc's faster implementation of ReadS from the Read typeclass
14:44:00 * lament sends lambdabot to room 101
14:44:37 <dcoutts_> > let 2 + 2 = 5 in 2 + 2
14:44:38 <lambdabot>   5
14:45:54 <c_wraith> Actually, I think parsec is popular because it has a cool name.  I mean...  "readP"?  "uu-parsinglb"?  "parsec"?  If I don't have any idea that the advantages and disadvantages of each, the one with the coolest name wins.
14:46:07 <dcoutts_> and it's one of the older ones
14:46:16 <dcoutts_> and was distributed with ghc
14:46:22 <dcoutts_> and had good docs
14:46:46 <c_wraith> the good docs part is true.  parsec has great docs.  And a pretty large supply of composite combinators.
14:47:00 <dcoutts_> and has reasonable performance
14:47:01 <Philonous> mauke: It blocks.
14:48:15 <Philonous> mauke: Hah. That's neat.
14:48:43 <cytzol> Hi #haskell! Is there a way to assign aliases to class restrictions on functions, like you can with types?
14:48:51 <mauke> cytzol: I don't think so
14:48:51 <cytzol> I'm writing "(Random a, Integral a) =>" a lot.
14:49:02 <cytzol> aw.
14:49:34 <Philonous> cytzol: Not really. But you can class (Foo x, Bar y) =>FooBar x y; instance (Foo x, Bary) => FooBar x y
14:49:42 <Cale> cytzol: It's possible to construct a class which is a subclass of both of them, and with some GHC extensions, write an all-emcompassing instance
14:50:13 <mauke> Philonous: that instance doesn't look like it's H98
14:50:29 <mauke> oh, fugues
14:50:55 <monochrom> Change it to class (Foo x, Bar x) =>FooBar x
14:51:18 <Philonous> mauke: Unfortunately it's not. But the gain in readability might be worth the extensions
14:53:45 <cytzol> Philonous: Hey, that works. I guess I language'd the extensions already.
14:54:32 <Philonous> cytzol: I think it's UndecidableInstances
14:54:57 <cytzol> Yeah, I must've needed that for something else. Can't remember what it was though.
15:14:03 <Scork> Any haskell programmer here that can help me with an error?
15:14:51 <Twey> No, we're all here just to discuss obscure elements of Icelandic culture
15:14:51 <Ke> just pastebin it and someone might help
15:14:59 <Ke> hpaste.org
15:15:16 <Scork> it's simple enough that I don't need to paste the code somewhere
15:15:26 <Berengal> It helps if youi ask the question
15:15:32 <Berengal> :)
15:15:37 <Scork> I'm just beginning to learn haskell and the prob I have is that I get the following error
15:15:43 <mauke> ...
15:15:53 <Scork> input error on input '|'
15:16:07 <mauke> you did something wrong
15:16:08 <monochrom> Should I just say "I agree it's so simple"?
15:16:09 <Scork> when I use th | to seperate constructors
15:16:14 <Scork> lol
15:16:19 <olsner_> I'd guess the error is in the code... so, paste the code? :P
15:16:21 <Scork> I hope you'll say yes
15:16:22 <Scork> k
15:16:38 <monochrom> say yes to what?
15:17:30 <jfischof> does anyone know if you can use Template Haskell to derive multi-parameter type classes?
15:17:45 <monochrom> Any sufficiently advanced knowledge is indistinguishable from prophecy.
15:18:02 <mauke> psychic debugging :-)
15:18:10 <cytzol> Any knowledge indistinguishable from prophecy is insufficiently advanced?
15:18:10 <Scork> there ya go http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16210#a16210
15:18:19 <Berengal> jfischof: My guess is "yes, TH can do anything", but I have no proof
15:18:31 <olsner_> @th-faq
15:18:31 <lambdabot> Unknown command, try @list
15:18:46 <Scork> nooo now it compiles
15:18:51 <jfischof> Berengal: hmm ok
15:19:01 <jfischof> Berengal: TH is pretty awesome
15:19:51 <Berengal> jfischof: It produces an AST. Anything you can write you can write with TH, except TH has horribly syntax in comparison to regular haskell...
15:19:59 <Berengal> horrible*
15:19:59 <Scork> this channel works magic on my code lol
15:20:02 <Scork> tnx guys
15:20:02 <cytzol> Scork: that looks fine to me.
15:20:05 <McManiaC> what was the name of that easier-to-use-than-ncurses haskell cli?
15:20:16 <cytzol> maybe you forgot to save before :loading?
15:20:17 <Scork> I dunno why I had the error  now :s
15:20:21 <Scork> nah
15:20:25 <jfischof> yeah, but I think compared to other
15:20:26 <ziman> maybe you just needed to save the file
15:20:39 <Scork> can it be indenting?
15:20:39 <jfischof> meta programming apis, it looks good
15:20:53 <aavogt> , pprint [| class Foo a b c where f :: a -> b -> c |]
15:20:54 <lunabot>  luna: parse error on input `class'
15:21:07 <aavogt> , pprint [d| class Foo a b c where f :: a -> b -> c |]
15:21:08 <lunabot>  luna: Not in scope: `pprint'
15:21:12 <cytzol> Scork: there isn't any indenting
15:21:22 <Scork> the where clause
15:21:39 <aavogt> , ppdoc [d| class Foo a b c where f :: a -> b -> c |]
15:21:40 <lunabot>  luna: Not in scope: `ppdoc'
15:22:09 <cytzol> the where's fine
15:22:59 <aavogt> , ppDoc [d| class Foo a b c where f :: a -> b -> c |]
15:23:00 <lunabot>  luna: Too many parameters for class `Foo'
15:25:50 <aavogt> anyways, the ast from that quotation is [ClassD [] Foo [PlainTV a_0,PlainTV b_1,PlainTV c_2] [] [SigD f (AppT (AppT ArrowT (VarT a_0)) (AppT (AppT ArrowT (VarT b_1)) (VarT c_2)))]]
15:45:50 <jfischof> is there any way to declare data types in ghci?
15:46:18 <kpreid> :load my-data-type.hs
15:46:32 <emax> bye everybody
15:46:41 <jfischof> but can I right the definition in ghci?
15:46:49 <Saizan> no
15:46:54 <jfischof> thanks
15:47:09 <Saizan> assuming right = write
15:47:11 <kpreid> you could write a filesystem where filenames correspond to values!
15:47:16 <jfischof> :)
15:47:28 <kpreid> :load "/filefs/data MyData = etc"
15:56:40 <monochrom> That is the most evil application of write-your-own-filesystem I have seen.
15:56:54 <kpreid> why, thank you.
15:57:18 <monochrom> You should post it to haskell-cafe. Many people will have heart attacks.
15:57:40 <kpreid> (/dev/fd can be used to similar effect if the context of generating the filename is a shell)
15:57:50 <kpreid> also, data: URLs
15:58:04 <monochrom> But Oleg alone will approve of it, and he will also suggest that you involve delimited continuations in your filesystem.
15:58:26 <kpreid> I'm not on haskell-cafe, so I don't know how to say it right. feel free to forward :-)
15:58:41 <monochrom> I am not on haskell-cafe either!
15:58:42 <Saizan> Oleg will suggest delimited continuations in your breakfast, even
15:59:41 * kpreid does not know the significance of delimited continuations
15:59:42 <monochrom> Well I bring up Oleg and delimited continuation because he has used it to emulate a concurrent-safe filesystem and posted it to haskell-cafe.
16:01:07 <taruti> using STM to do it is less mind-blowing
16:05:03 <kpreid> speaking of oleg, I skimmed this paper recently: http://www.cs.rutgers.edu/~ccshan/prepose/prepose.pdf -- and up till now, I didn't notice he was one of the authors, actually; but the mention of oleg made me think of type hackery
16:05:38 <kpreid> anyway, the code on the middle right of page 5 (reifyIntegral) made me go "you can DO that?!"
16:06:04 <kpreid> it's perfectly obvious once I've seen it, but ...
16:06:10 <Saizan> eheh
16:06:40 <Saizan> i think i had the same exact reaction at the time
16:06:51 <sproingie> i get that reaction to a lot of oleg's work
16:07:23 <kpreid> I mean, I've sort of known that you can compose dictionaries at runtime since ghc doesn't do code-gen (as in c++ templates). but it didn't occur to me to do it so ... explicitly
16:10:25 <Nafai> Is David Siegel here on #haskell?  I'm curious about his Yata twitter client.
16:14:02 <Twey> That'sâ€¦ woah
16:16:15 <ddarius> kpreid: Play with polymorphic recursion more.
16:19:59 <HIV> I am virus that destorys the human immune system
16:23:50 <yitz> @where ops
16:23:51 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver monochrom
16:23:59 --- mode: ChanServ set +o dcoutts_
16:24:29 <McManiaC> I thought GHC 6.12 had full UTF8 support with putStrLn etcâ€¦? why do I still need Codec.Binary.UTF8.Light.hPutUTF8Ln to use utf8?
16:24:42 <McManiaC> I use System.IO.hPutStrLn
16:24:52 <mreh> how would you lay this out better: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16211#a16211
16:24:57 <mreh> it looks like shit right now
16:25:27 <dcoutts_> McManiaC: in ghc-6.12, the standard System.IO handle stuff uses the locale encoding by default.
16:25:49 <McManiaC> well then it should use utf8
16:26:07 <dcoutts_> McManiaC: right, unless you've changed to binary mode or explicitly set the encoding.
16:26:36 <McManiaC> I didntâ€¦
16:26:41 <dcoutts_> McManiaC: obviously the String you print needs to be Unicode
16:26:52 <dcoutts_> rather than say utf8 bytes
16:27:10 <Saizan> mreh: does it typecheck?
16:27:32 <yitz> mreh: do you mean return (Key note mode) ?
16:27:58 <mreh> yitz: I want a default to fall back on, if there is no key then return C Major as default
16:28:14 <mreh> it's tonal music, so I can justify that
16:28:28 <Saizan> mreh: i meant the (parseMode >>= (\mode -> Key note mode)) part
16:29:07 <cytzol> mreh: I tried to make it prettier using a where clause
16:29:26 --- mode: ChanServ set -o dcoutts_
16:30:13 <McManiaC> dcoutts_: ah my handle was in binary mode
16:30:34 <lament> mreh: does your program generate sound?
16:30:36 <dcoutts_> McManiaC: ok
16:30:46 <McManiaC> thx for the hint :)
16:30:50 <dcoutts_> np :-)
16:31:21 <dcoutts_> McManiaC: so is locale encoding what you want, or are you using a file format that must be utf8?
16:31:55 <McManiaC> no, locale encoding is fine
16:32:45 <twanvl> mreh: Assuming you are using parsec, this should work for the mode:  option Major parseMode
16:33:26 <cytzol> twanvl: I saw your revision, what's option?
16:33:57 <roostaj> :t Tip
16:33:58 <lambdabot> Not in scope: data constructor `Tip'
16:34:26 <cytzol> oh, it's a parsec function. ne'er mind
16:35:35 <Saizan> can't you do option (Key C Major) (Key <$> parseNote <*> (option Major parseMode)) then ?
16:35:50 <mreh> I don't understand applicative
16:36:34 <kmc> (f <$> a <*> b <*> ... <*> z)  ==>  liftMn f a b ... z
16:37:13 <kmc> except that Applicative includes some types not in Monad
16:37:14 <mreh> what monad is Key?
16:37:23 <roostaj> :info Map
16:37:24 <mreh> Functor?
16:37:27 <roostaj> :(
16:37:32 <kmc> what about Functor?
16:38:18 <yitz> @hoogle Map
16:38:19 <lambdabot> module Data.Map
16:38:19 <lambdabot> Data.Map data Map k a
16:38:19 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
16:38:20 <mreh> is that one of the classes in Functor?
16:38:39 <kmc> i don't know what you mean
16:38:40 <kmc> Functor doesn't contain classes
16:38:43 <kmc> Functor is a class
16:38:46 <mreh> not class, type
16:38:52 <kmc> Applicative is a class.  every Applicative is a Functor
16:39:27 <kmc> every Monad is an Applicative and a Functor, in theory.  in practice, for historical reasons the std lib is written such that this is not enforced
16:40:16 <mreh> doesn't haskell use the offside rule?
16:40:35 <mreh> but not in the top level function definition...
16:40:49 <kmc> for a monad M you can always define an applicative instance by instance Applicative M where { pure = return; (<*>) = ap }
16:40:56 <kmc> offside rule for layout?
16:41:02 <mreh> kmc: yes
16:41:31 <kmc> http://haskell.org/onlinereport/lexemes.html#sect2.7
16:41:47 <kmc> http://haskell.org/onlinereport/syntax-iso.html#sect9.3
16:42:07 <kmc> those are the precise rules
16:42:21 <hatds> the top level is slightly special
16:42:54 <roostaj> :t Map.Tip
16:42:56 <lambdabot> Couldn't find qualified module.
16:43:04 <roostaj> :t Data.Map.Tip
16:43:04 <kmc> :t Data.Map.Tip
16:43:05 <lambdabot> Not in scope: data constructor `Data.Map.Tip'
16:43:05 <lambdabot> Not in scope: data constructor `Data.Map.Tip'
16:43:07 <kmc> roostaj, it's not exported
16:43:13 <kmc> http://www.haskell.org/ghc/docs/6.10-latest/html/libraries/containers/src/Data-Map.html
16:43:20 <mreh> you can do all sort of fun things at the top level it seems, definitions behind the "=" sign
16:43:28 <kmc> data Map k a = Tip | Bin {-# UNPACK #-} !Size !k a !(Map k a) !(Map k a)
16:43:32 <kmc> mreh, what do you mean?
16:43:50 <kmc> there are lots of things allowed at top level not allowed in a "let" or "where"
16:43:52 <mreh> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16211#a16211 <--- the last one in this
16:43:55 <kmc> such as data, class, instance, etc.
16:43:59 <roostaj> kmc: maybe I'm confused... shouldn't Tip be of type Map k a?
16:44:09 <mreh> kmc: I mean top level function definitions
16:44:10 <kmc> roostaj, it is
16:44:14 <kmc> what indication do you have that it's not?
16:44:34 <kmc> mreh, what's special about the last paste here?
16:44:38 <kmc> also, the last paste contains no function definitions
16:45:14 <mreh> kmc: parseKey is a function
16:45:20 <roostaj> kmc: Oh, maybe I was just reading the export list wrong. When it says "Map" it doesn't actually export the constructors. It would have to say "Map (..)" right?
16:45:22 <kmc> no, it's a Parser
16:45:27 <kmc> a function has "->" in its type
16:45:32 <kmc> and can be applied
16:45:36 <yitz> roostaj: right
16:45:47 <kmc> unless Parser here is a type synonym for a function, but i don't believe it is, if you're using Parsec
16:45:47 <roostaj> yitz: kmc: thanks!
16:45:56 <kmc> roostaj, yes
16:45:58 <kmc> or Map(Tip)
16:45:59 <hatds> > let Just x = undefined x
16:46:00 <lambdabot>   not an expression: `let Just x = undefined x'
16:46:00 <mreh> kmc: it's a top level definition, that's what I was getting at
16:46:07 <hatds> > Just x = undefined x
16:46:08 <kmc> mreh, okay
16:46:08 <lambdabot>   <no location info>: parse error on input `='
16:46:11 <kmc> so what's the special part about it?
16:46:22 <mreh> the <|> is to the left of the =
16:46:31 <kmc> can't you do that in "let" as well?
16:47:14 <mreh> kmc: really?
16:47:57 <mreh> i'll have to try that out
16:48:00 <kmc> i'm not sure, did you try?
16:48:41 <kmc> i think the requirement is that the next line starts indented from the first one
16:48:45 <kmc> the layout rule doesn't care where the '=' is
16:49:01 <kmc> the only tokens it cares about are let, where, do, of, {, and module
16:49:12 <kmc> if two lines are indented equally they get a ; between them
16:49:20 <kmc> if the second one is indented more, it continues the one above
16:49:29 <kmc> if it,s indented less, it closes the block and so gets a } prepended to it
16:51:00 <hatds> mreh: it's not the equal sign that matters, it's the first character of what starts the declaration (the function name)
16:51:09 <mreh> does "do" have precedence then?
16:51:51 <hatds> which do are you referring to?
16:52:01 <sproingie> presumably do-notation
16:52:08 <hatds> in your examples I mean
16:52:20 <mreh> do-noation
16:52:54 <hatds> take precedence in what sense?
16:53:54 <damd> 01:53 *** carlocci QUIT "eventually IE will rot and die"
16:54:01 <damd> isn't that a cheerful quit message
16:54:16 <sproingie> i think it expresses the hopes of web developers everywhere
16:54:33 <damd> it sure does
16:54:54 <sproingie> me i couldnt care less about OS politics, but man do web devs ever hate IE for a reason
16:55:40 <tensorpudding> IE can stay around as long as they want, so long as they at least try to render things correctly
16:56:08 <damd> tensorpudding clearly hasn't tried writing a modern website with IE6 support
16:56:31 <michael|> and conform to web standards, rather than make conflicting ones
16:56:32 <c_wraith> IE6 is the devil.
16:57:29 <mreh> is there a parsec "command" to ignore whitespace?
16:57:30 <jhnx> how to see the doc or function source inside ghci?
16:58:16 <tensorpudding> yes, that is what i meant, is adhering to standards
16:58:22 <mreh> littering whole sections of code with `many (char ' ')` doesn't appeal
16:58:34 <damd> mreh: i think "spaces"?
16:58:36 <kmc> mreh, make a name for it then
16:58:40 <damd> :t spaces
16:58:41 <lambdabot> Not in scope: `spaces'
16:58:43 <c_wraith> jhnx: ghci doesn't have that feature
16:58:53 <damd> @hoogle spaces
16:58:53 <lambdabot> Text.Parsec.Char spaces :: Stream s m Char => ParsecT s u m ()
16:58:54 <lambdabot> Text.ParserCombinators.Parsec.Char spaces :: Stream s m Char => ParsecT s u m ()
16:58:54 <lambdabot> Text.ParserCombinators.ReadP skipSpaces :: ReadP ()
16:59:05 <mreh> ooh
16:59:05 <kmc> jhnx, i have this website on hotkey:
16:59:06 <kmc> http://www.haskell.org/ghc/docs/6.10-latest/html/libraries/
16:59:15 <tensorpudding> s u m ()! what does that spell?
16:59:29 <damd> tensorpudding: stream userstate monad return type
16:59:39 <kmc> sum unit
16:59:44 <kmc> as in, "that's sum unit you got there"
16:59:48 <damd> lol
16:59:53 <kmc> said the actress to the bishop
16:59:59 <damd> hahaha
16:59:59 <hatds> you should probably be "tokenizing" to remove spaces before parsing
17:00:00 <sproingie> eh people throw around standards as the same old OS politics.  problem is when IE did implement a standard but broken
17:00:17 <cytzol> "you're cute! are you a singleton?"
17:00:19 <sproingie> it's gotten better, it's just the slow JS engine now
17:01:44 <tensorpudding> so IE still has a large market share
17:02:01 <kmc> IE6 is the big problem
17:02:11 <kmc> IE after 6 is a substandard browser but isn't holding up the future in a big way
17:02:33 <tensorpudding> but IE6 is mostly extinct
17:02:37 <c_wraith> yeah.  IE7 and 8 are at least acceptable.  6 requires a huge amount of testing and bad hacks to work around
17:02:44 <c_wraith> and IE6 is *not* mostly extinct
17:02:47 <damd> tensorpudding: IE6 is as alive as IE7 according to recent statistics
17:02:51 <c_wraith> it's heavily used in coroporate environments
17:02:54 <kmc> at this point it's totally acceptable to give IE6 users an inferior experience
17:03:04 <c_wraith> the kind that commercial products often are requird to support.
17:03:06 <tensorpudding> IE7 is default in Vista and 7 isn't it?
17:03:11 <sproingie> IE6 is all over the place with most corporate desktops
17:03:22 <sproingie> win7 comes with ie8
17:03:26 <tensorpudding> okay
17:03:27 <c_wraith> Vista and 7 aren't common in corporate environments.
17:03:57 <tensorpudding> 7 is all shiny though
17:04:03 <tensorpudding> don't they like shiny?
17:04:10 <sproingie> 7 is not too bad.
17:04:11 <c_wraith> corporate policy forbids shiny. :)
17:04:30 <sproingie> aero looks a lot more grown up than the fisher-price luna theme
17:04:30 <ddarius> Shiny is irrelevant if your software doesn't work on it.
17:04:57 <c_wraith> more specifically, lots of corporations use badly-written web apps that don't work on version of IE other than 6.  Often involving ActiveX, too
17:05:08 <sproingie> *shudder*
17:05:10 <tensorpudding> that was some rather poor planning
17:05:27 <tensorpudding> microsoft should have stopped supporting XP
17:05:42 <sproingie> yeah they should have told all their customers to piss up a rope
17:05:44 <cytzol> didn't they almost do that, but uproar?
17:05:46 <sproingie> cuz that's how you do business
17:06:02 <Adamant> c_wraith: other corps have moved on to supporting multiple web browsers, but only those created in certain phases of the moons and with the right incantations muttered over before it was kicked out the door
17:06:03 <tensorpudding> they have to stop supporting an OS sometime
17:06:10 <sproingie> they have an eol schedule
17:06:32 <c_wraith> Also, IE6 on XP service pack 3 uses the IE 7 javascript engine...  Which isn't compatible with the IE6 dom model, exactly.
17:06:34 <tensorpudding> do they still support 2000?
17:06:34 <sproingie> they just extended it for xp due to demand
17:06:36 <Adamant> *moon even
17:06:36 <sproingie> nope
17:07:00 <c_wraith> Which results in IE6 on XP SP3 having strange bugs that no other browser does
17:07:10 <sproingie> win2k is in extended support
17:07:17 <sproingie> it will be eol'd entirely june this year
17:08:02 <mreh> how could I concatenate the result of "many p" if p :: [a]?
17:08:09 <mreh> liftM?
17:08:14 <sproingie> there are still a lot of installations of NT4.  plenty of third party support for it i bet
17:08:36 <mreh> :t liftM
17:08:37 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
17:08:42 <cytzol> mreh: liftM many p
17:08:54 <cytzol> mreh: liftM concat (many p)
17:08:55 <cytzol> I mean
17:09:29 <kmc> :t liftM concat
17:09:30 <lambdabot> forall a (m :: * -> *). (Monad m) => m [[a]] -> m [a]
17:09:32 <cytzol> wait, no, I need to learn to think before I type.
17:09:50 <kmc> :t (concat <$>)
17:09:51 <lambdabot> forall a (f :: * -> *). (Functor f) => f [[a]] -> f [a]
17:10:00 <kmc> :t fmap concat
17:10:01 <lambdabot> forall a (f :: * -> *). (Functor f) => f [[a]] -> f [a]
17:10:11 <sproingie> liftM for lists is just plain ol map
17:10:39 <kmc> the functor here is Parser
17:13:00 <Ke> btw what's the can't talk thingy in topic
17:13:20 <kmc> there was a flood of spam bots
17:13:24 <kmc> so they set +R
17:13:30 <Ke> ok
17:13:30 <kmc> meaning you need to be registered to talk
17:13:37 <kmc> or maybe it's +r
17:14:08 <mreh> that flood was crazy
17:14:30 <kmc> it was a clever hack
17:15:02 <mreh> how did they do it? the jpg link trick was sneaky, then I was automatically k-lined
17:15:04 <sproingie> is that the viral click attack?
17:15:19 <sproingie> that was awful cute
17:15:47 <mreh> "cute"? :)
17:15:48 <xerox> mreh <mauke> exploit code: http://pastebay.com/83116
17:16:05 <mreh> I don't want to click on that
17:16:06 <c_wraith> I find noscript to be a pretty awesome counter.
17:16:24 <xerox> mreh hehe, it's safe.
17:16:30 <monochrom> mreh: I testify it is just pastebin showing source code.
17:16:44 <sproingie> not sure how normal js evaluation would allow it to work either
17:16:45 <monochrom> syntax highlight too
17:16:56 <sproingie> since it sounds like csrf
17:17:03 <xerox> sproingie that paste shows how it works
17:17:16 <mreh> what's with all the unescapes?
17:17:22 <sproingie> obfuscation
17:17:39 <mreh> what was the target of the attack>
17:17:46 <mreh> any room?
17:17:48 <deteego> hey I just wanted to ask, are the compiler projects LHC and JHC for haskell
17:17:50 <deteego> considered dead?
17:18:01 <monochrom> I don't think they're dead.
17:18:33 <sproingie> it has freenode as the form destination, but auto-submitting it should be seen as a XSS attack
17:18:46 <sproingie> ah well, browser security, ever an oxymoron
17:19:23 <monochrom> What is XSS?
17:19:29 <sproingie> cross site scripting
17:19:36 <monochrom> Ah.
17:19:49 <deteego> im just wondering since they havent had commits for quite some time
17:20:30 <xerox> it's not exactly cross site, all the code that operates on the page comes from that page (granted, it calls outside, but that's another matter)
17:21:30 <deteego> if only GHC handled laziness better for optimizations...
17:22:17 <sshc_> is there a package that implements binary trees?
17:22:45 <sproingie> xerox: right but it submits to a third party.  i guess that attack's been around before xss, i just dont know what to call it
17:22:49 <c_wraith> sshc_: Data.Sequence is a good choice, probably.
17:22:50 <sproingie> variant of csrf i guess
17:23:05 <kmc> sshc_, binary trees for what purpose?
17:23:05 <c_wraith> sshc_: It's actually a 2-3 Finger tree, but it has similar performance constraints
17:23:18 <kmc> do you want the semantics of a tree, or do you want to use them as a map or something?
17:23:29 <kmc> there is Data.Tree
17:23:38 <deteego> if you dont care about efficiency you can easily make your own
17:23:41 <deteego> or use Data.Tree
17:23:50 <sshc_> deteego: I care about effeciency
17:23:51 <kmc> not all trees are maps, not all are even in BST order
17:23:55 <sshc_> BSP
17:24:07 <deteego> well Data.Tree is your best bet
17:24:10 <deteego> since it is optimized
17:24:23 <sshc_> deteego: does Data.Tree implement *binary* trees?
17:24:43 <deteego> its multi way trees (aka forests)
17:24:52 <sshc_> then I won't use that
17:24:55 <aavogt> data.tree can represent a binary tree
17:25:22 <sshc_> aavogt: yes, but can it do it effeciently?
17:25:37 <augustss> sshc_: Why not write the one line needed to define binary trees yourself?
17:25:41 <mreh> can I Parse something as a repeated structure in one pass with Parsec
17:25:42 <sshc_> aavogt: if I know I'm only working with binary trees, wouldn't I be better off using one specificly written for that purpose?
17:26:17 <deteego> yeah you can easily define binary tree as a data structure in a single line
17:26:18 <monochrom> what is a repeated structure? like many parseMyStuff ?
17:26:30 <deteego> as long as you dont use laziness it should be fine (efficiency wise)
17:26:44 <aavogt> there's probably more indirection when the data structure is used such that each node has two children, but can allow lots more
17:26:59 <mreh> monochrom, a symbol that indicates the last element in a list of symbols sould be repeated
17:27:10 <sshc_> should I worry about the binary tree being balanced?
17:27:17 <sshc_> I'm working with BSP
17:27:20 <sproingie> generally yes
17:27:27 <aavogt> deteego: what is this optimization present in Data.Tree?
17:27:31 <deteego> depends on what you are using the trees for
17:27:37 <sshc_> deteego: BSP
17:27:37 <augustss> sshc_: depends
17:27:57 <deteego> well I assume stuff like IO.Array might be used
17:27:59 <deteego> or whatnot
17:28:02 <augustss> sshc_: can you balance BSP trees?
17:28:06 <sproingie> bsp tree will generally not be balanced
17:28:08 <monochrom> mreh: Does it mean an example input string is "0.3*" and humans think of it as 0.3333... ?
17:28:16 <sproingie> if it is it probably wasn't that interesting a space
17:28:24 <deteego> actually scratch that
17:28:29 <sshc_> augustss: doesn't make sense
17:28:35 <deteego> its just a basic tree implementation
17:28:36 <mreh> mononchrom: or as simple as [1,2,3,*,4] = [1,2,3,3,4]
17:28:37 <sshc_> so I guess not
17:28:38 <deteego> looking at the source
17:28:47 <deteego> so Data.Tree wouldn't be any more efficient
17:29:10 <deteego> most stuff in Data tends to be optimized (if possible)
17:29:16 <sshc_> it's probably easy to write my own, but, are there any packages at all that implement binary trees?
17:29:17 <augustss> sshc_: just roll your own
17:29:56 <sshc_> augustss: alright.  What should I worry about effenciic-wise?
17:29:57 <monochrom> If there is a package providing a binary tree, what you end up using is just one line of it, namely data F = X | Y F F
17:30:00 <deteego> its such a simple thing that a package for it wouldn'
17:30:02 <sshc_> besides strict binary trees
17:30:04 <deteego> its such a simple thing that a package for it wouldn't be needed
17:30:18 <augustss> sshc_: strictness is not necessarily a good thing
17:30:20 <ddarius> deteego: I wouldn't quite say that and anyways "optimized" doesn't mean "uses low-level hacks and craziness"
17:30:21 <deteego> the package would be like 3 lines long -_-
17:30:31 <augustss> sshc_: don't worry about efficiency.  profile
17:30:34 <ddarius> Nor does it mean "avoids laziness"
17:30:38 <deteego> ddarius: of course not
17:30:50 <deteego> but using stuff like Arrays instead of lists is faster for example
17:31:04 <sshc_> there could be a lot of general purpose trees that operate on binary trees
17:31:09 <sshc_> s/trees/functions/
17:31:10 <ddarius> deteego: Not necessarily.
17:31:22 <deteego> well yeah depends how its used
17:31:26 <sshc_> out of curiosity, does a package exist?
17:31:41 <monochrom> Perhaps you should just look for a BSP package directly.
17:31:41 <sshc_> I will probably write my own, but I still would like to know if one exists
17:32:13 <sshc_> monochrom: google isn't revealing any bniray tree or BSP packages
17:32:15 <ddarius> sshc_: Most operations on trees (binary or rose) are trivial.
17:32:47 <sproingie> there are a number of packages for specialized trees like fingertrees.  binary trees, i don't know
17:32:54 <monochrom> I think we just owe you a straight answer to your straight question. No there isn't a binary tree library.
17:32:56 <deteego> I just searched through hayoo
17:33:02 <sproingie> there's plenty of generics dealing with them, like Foldable
17:33:02 <deteego> only found Data.Tree
17:33:11 <deteego> which is the generic foldable tree
17:33:24 <sproingie> yeah there's a lot written to support it.  i'd use it
17:33:34 <Cale> Actually, Data.Foldable doesn't provide the fold that you probably would want to write
17:33:54 <sshc_> sproingie: you'd use Data.Tree for binary trees instead of rolling your own?
17:34:05 <Cale> With something like  data Tree a = Tip | Branch a (Tree a) (Tree a)
17:34:22 <sproingie> i tend to not need binary trees
17:34:37 <Cale> You'll want to write  foldTree t b = f where f Tip = t; f (Branch x l r) = b x (f l) (f r)
17:34:43 <sproingie> i suppose if i do more graphics work i'll have to deal with bsp's or more likely octrees
17:34:51 <sshc_> sproingie: if you did, would you?
17:35:10 <Cale> and then many operations on binary trees are simple from there
17:35:19 <deteego> I probably would right my own library instead of using data.tree
17:35:32 <sproingie> i'd hope to god there was an octree implementation already out there
17:35:39 <deteego> especially if you are doing it for graphics (and have certain operations that go through the tree)
17:35:46 <sproingie> actually my current game would probably only have to deal with quadtrees
17:36:23 <deteego> out of curiosity
17:36:32 <Cale> inorder t = foldTree id (\x l r -> l . (x:) . r) t []
17:36:44 --- topic: '["msg an op if you can't talk", "hackage torrent @ http://bit.ly/7ObzIP ","Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]'
17:36:44 --- topic: set by Heffalump on [Sat Jan 16 09:47:10 2010]
17:36:44 --- names: list (clog caligula_ OnionKnight anji tavelram faprhn bhclssua ypwgodgehx whanwq tnwqlqmye cqwqpiawlcmd czwylbkpqy azaxyqd qoshtayvqx ksvhpdlorde zlfhivfhoeoc anuxmm harold uahaf acepvbykvi tisrtsmbno m-i-l-a-1 jjann_ pancho88 nniro altmattr scrie` mtnviewmark medfly MoALTz Khisanth deteego welterde nohluhtC dolio AirCastle eu-prleu-peupeu1 hgolden rdd`` Zeiris Guest74841 gonsor bens_ jhnx amz IceDane roostaj erikc meanburrito920_ bbe lzgz)
17:36:44 --- names: list (theorbtwo leandrom maskd Artalizian kquick2 Pthing gbacon cytzol jjann abbe Rayne det saccade_ sjanssen_ C-S jtootf genneth michael| roconnor NNshag c_wraith Mortomes NEEDMOAR wto comak domor snorble dobblego kisvoros path[l] Colours lostman m_W bremner M| yyz AnMaster Raynes s76_ kmc hatds Rotaerk augustss dufflebunk mreh wisemanby coyo Badger zax sshc_ alvarezp Jacolyte chrisf @monochrom sahazel dibblego Feuerbach zakwilson dju Shimei)
17:36:44 --- names: list (pham nwf jbauman dax emma stoop jethomas uman SubStack SimonRC AndyP zaarg jfoutz xinming tensorpudding elspru ksf sioraiocht Flarelocke1 mattrepl Adamant smorg mauke tomh- Rixi Quadrescence lpsmith naten Modius mreggen amiri silver__ ville Dessous Sup3rkiddo Nomad010 pemryan ttmrichter bgs100 boscop EEEuler pwerken drhodes kevinclark uorygl Tomas cobol000_ ketil dfdf ibid BCoppens aiko_ potatishandlarn PsiOmega Guest96239 jayne eagletmt)
17:36:44 --- names: list (Axman6 dnm_ _Jedai_ gogonkt_ master_of_master mrothe kadoban mahogny ts33kr Saizan hackagebot blackdog Aldwuin gnuvince danly__ jonafan SamB_XP avenge bwr noteventime otto_s_ TacticalGrace absentia_ boxxy__ BMeph merehap polk330 evio Paradox924X fihi09 kw317 mornfall Nereid Cale kynky jix Raevel kaol sproingie ksandstr ido dionoea shawn shapr Dashkal saccade willb ve Innominate syntaxglitch PHO_ prb reltuk G0SUB jimmyjazz14 mikste baaba)
17:36:44 --- names: list (idnar juhp Taggnostr ingy @dcoutts mjv gdsx Boney BurgessShale TR2N Bassetts tew88_ kwinz eelco KatrinaTheLamia drwhat skeptomai|awa- kosmikus emouse tamiko dreixel drwho Draconx|Laptop nimred tarbo eyck mjrosenb orbitz j4cbo Blub\0 lenbust_ ajklfjadsf skeptomai|away dcoutts_ bobby_bigloaf DrSyzygy_ Valodim fabjan majoh eno ertai mercury^ Bleadof BrianHV jvoorhis wang mrd mml` nazgjunk quicksilver rapacity BONUS shachaf saiam dilinger)
17:36:44 --- names: list (dixie lavish nornagon icee daed wormwood peddie joga karld ahf MadX` mdordal2 wdonnelly wagle _stenobot epokal Milo- cathper byorgey poucet kalven blazzy erg Jaak zacharyp gniourf_gniourf_ sohum mle mfoemmel edwtjo koeien benmachine etpace smg ystael Ke newsham lanaer dwon_ nasloc__ cp2 anee Aisling Twey Apocalisp jrockway aemp1rei jystic Vanadium webframp J-Mad \toothrot mwc LeoD joe1 thoughtpolice hiredman otulp QtPlatypus Vulpyne_)
17:36:44 --- names: list (jorizma Nafai Jiten awarrington jvogel houeland timlarson netcat olsner bran hopthris1 agemo_ dino- greap kolmodin_ inclement encryptio whoppix rndm_ gbeshers_ geir_ joed yahooooo lhnz nablaa smiler davidL dfeuer_ Deewiant Dodek ath Megant inhortte Draconx Laney jfredett Veinor DekuNut p_l integral jaredj mlh ClaudiusMaximus oeblink kar-1 djahandarie dons aleator_ LeNsTR|Sleep StarFire mux edwinb Ornedan evilhackerdude Igloo theclaw jleedev)
17:36:44 --- names: list (qm13 @Heffalump cizra OscarZ boyscared +Berengal gwern alip Ytinasni dogmaT phnglui leimy franksh MacCoaster jan_ crem pardus aledge +ddarius Gabbie qz @ChanServ Alpounet drbean Cronecker Carnegie keseldude jre2_ noddy shortcir1uit hellige_ koala_man brx luite_ samulihs_ trez prigaux thingwath niksnut voker57 mm_freak geoaxis elly Twigathy diginux BONUS_ Gilly impl stroan ray eek liesen osfameron epmf magicman joni6128 lunabot dcolish)
17:36:44 --- names: list (tkr sbok _br_ jayrk khiroc fritschy arr2 int_e anders^^ kakeman ToRA matthew-_ mog Gracenotes deadguys_ sgf Liskni_si sieni_ Arnar pettter pikhq skaar ski qeb`away dumael mattam ziman t endojelly McManiaC SmurfOR m-i-l-a-n allbery_b __marius1_ jlaire soeren deavid jgrimes Stephan202 glith flux nothingmuch suiside companion_cube ezeike Eelis helmut ps-auxw jontore bbee ahihi Kyrus zsol srcerer preflex Zao mk64ftw opqdonut orbekk Ferdirand)
17:36:44 --- names: list (arjanoosting dqd @Lemmih canvon_ FauxFaux jtra tilman shepheb periodic jdavis Sisu Zr40 tredontho bd_ yottis Vq Astro mietek noj tmug birkenfeld StoneToad glitch emias harlekin mmmdonuts flori alexbobp fnordus bburhans tltstc clarkb mun Baughn felipe_ nlogax pcc1 ehamberg mokus koninkje_away cjay Botje anekos lament TML mfp DigitalKiwi equanimity stu2010 Hunner jql jml lambdabot rey_ mee jlouis EvanCarroll _Jordan_ cods xerox saurik andrewsw-afk)
17:36:44 --- names: list (c9s Nanar)
17:36:47 <Cale> lovely
