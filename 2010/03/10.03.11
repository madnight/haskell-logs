00:00:37 <copumpkin> dolio: did you see the arxiv crank?
00:00:42 <copumpkin> http://arxiv.org/abs/1002.4433
00:00:46 <Saizan> any uses for this EQ typeclass?
00:02:30 <copumpkin> dolio: oh I guess you did, since you commented on it :)
00:14:30 <akamaus> hello anyone
00:14:59 <akamaus> is it possible to bind an happstack application to specific network interface?
00:24:51 <kmc> hi copumpkin
00:24:56 <kmc> that paper looks amusingly crazy
00:25:01 <copumpkin> hullo :)
00:42:08 <mreh> I would presume there's no pure way of running a process that produces a matrix every iteration and updating a gui every second with that matrix?
00:42:55 <integral> the IO monad is too impure for you?
00:43:18 <copumpkin> mreh: you could, sort of, but it'd be a bit ugly
00:43:22 <SubStack> hmatrix?
00:43:51 <mreh> SubStack no, Data.Map :D
00:44:07 <SubStack> anyways, that wouldn't be hard at all to write
00:44:09 <mreh> copumpkin: it would probably be slower, having to wait for the concurrent thread to return
00:44:35 <mreh> shared memory is what I really need
00:44:47 <mreh> the GUI is afterall just reading
00:44:58 <SubStack> you've got mvars, tvars, channels
00:45:00 <SubStack> good stuff
00:45:21 <aleator> Hi. Is it possible to make cabal link in .a archives? (on os x)
00:48:02 <dobblego> sedition160.
00:48:15 <elly> dobblego: ?
00:48:59 <phnglui> The cranky paper is discussed at some length on http://scienceblogs.com/goodmath/2010/03/grandiose_crankery_cantor_gode.php
00:52:45 <jlouis> aleator: I think so, but I am not sure
01:08:27 <mreh> SubStack: is that STM?
01:08:42 <aleator> jlouis: Im trying to cabalize something using hackages llvm bindings and it fails with cannot load .so/.DLL for..
01:10:57 <jlouis> mreh: no :)
01:11:32 <mreh> you're not SubStack!
01:13:01 <jlouis> mreh: your filterM doesn't work correctly then. Please fix it.
01:13:24 <mreh> :t filterM
01:13:25 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
01:13:45 * mreh . o 0 (hmmm... what could he mean?)
01:14:09 <jlouis> mreh: ignore me :)
01:14:20 <sinelaw> Alpounet, hey
01:14:34 <jlouis> anyway, MVar/TVar/Chan's are orthogonal to STM
01:14:48 <jlouis> I think both have their uses though
01:14:50 <sinelaw> TVars are implemented with STM no?
01:15:02 <kmc> TVars are for use with STM
01:15:50 <kmc> they are part of the STM system, and they're useless without «atomically»
01:16:22 <jlouis> oh, I need more coffee, sorry
01:17:30 <jlouis> I was thinking of SampleVars
01:23:31 <dmead> yo channel
01:23:42 <dmead> anybody know the deal with if-else inside do blocks?
01:25:40 <Botje> what deal?
01:25:43 * Botje didn't get the memo
01:28:12 <nainaide> :t
01:28:15 <nainaide> :t @
01:28:16 <lambdabot> parse error on input `@'
01:30:26 <dmead> @hoogle loop
01:30:27 <lambdabot> Control.Arrow loop :: ArrowLoop a => a (b, d) (c, d) -> a b c
01:30:27 <lambdabot> Data.Graph.Inductive.Example loop :: Gr Char ()
01:30:27 <lambdabot> Data.Graph.Inductive.Example loop' :: IO (SGr Char ())
01:30:37 <copumpkin> oh no, now you're in trouble
01:30:47 <dmead> eh?
01:30:50 <SubStack> vars!
01:30:55 <copumpkin> :t loop
01:30:56 <dmead> vars!
01:30:57 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowLoop a) => a (b, d) (c, d) -> a b c
01:30:57 <copumpkin> that thing
01:31:05 <dmead> that sounds icky
01:31:12 <dmead> i just want CPS with memoization
01:31:18 <copumpkin> it's pretty similar to fix
01:31:19 <dmead> ?src loop
01:31:19 <lambdabot> Source not found. I am sorry.
01:31:24 <pastorn> copumpkin: that looks weird...
01:31:26 <copumpkin> you could write it yourself
01:31:34 <dmead> yar
01:31:41 <dmead> i'm writting an sql interpreter
01:31:43 <pastorn> what if the c in (b,d) -> (c,d) is dependent upon the d?
01:31:44 <copumpkin> (b, d) ~> (c, d) -> b ~> c
01:31:51 <dmead> and i need some main loop action now
01:32:08 <copumpkin> pastorn: it's allowed to be
01:32:33 <pastorn> copumpkin: isn't that ((b, d) ~> (c, d)) -> (b ~> c)
01:32:43 <pastorn> (last paretheses for emphasis)
01:32:47 <copumpkin> yeah
01:33:07 <pastorn> so how do you produce the first d to feed to the pair function?
01:33:48 <sinelaw> @hoogle (a->b) -> m a -> m b
01:33:48 <lambdabot> Data.Traversable fmapDefault :: Traversable t => (a -> b) -> t a -> t b
01:33:48 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
01:33:48 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
01:34:02 <sinelaw> Monads are always Functors, right?
01:34:06 <pastorn> copumpkin: do you see what i find confusing?
01:34:15 <copumpkin> yeah, it's definitely not an obvious function :)
01:34:19 <copumpkin> which is why I said "oh no"
01:34:22 <pastorn> haha
01:34:25 <pastorn> but the d?
01:34:32 <pastorn> how can we just remove it?
01:34:33 <copumpkin> try to write it
01:34:39 <pastorn> an example:
01:35:43 <pastorn> \(b,(x:xs)) -> if b then (x,xs) else (head xs, [])
01:35:47 <sinelaw> @pl (\f::(a->b) g::(x -> m a) x -> do a' <- g x; return (f a'))
01:35:47 <lambdabot> (line 1, column 5):
01:35:47 <lambdabot> unexpected ":"
01:35:47 <lambdabot> expecting "()", natural, identifier, "_" or "("
01:36:00 <sinelaw> @pl (\f g x -> do a' <- g x; return (f a'))
01:36:00 <lambdabot> (line 1, column 24):
01:36:00 <lambdabot> unexpected ";"
01:36:01 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or ")"
01:36:01 <pastorn> how do we make that into a funtion :: (b -> c) ?
01:36:43 <copumpkin> hm?
01:36:47 <sinelaw> @hoogle (a->b) -> (x -> m a) -> x -> m b
01:36:47 <lambdabot> Language.Haskell.TH.Quote dataToQa :: Data a => (Name -> k) -> (Lit -> Q q) -> (k -> [Q q] -> Q q) -> (b -> Maybe (Q q)) -> a -> Q q
01:36:52 <pastorn> copumpkin: \(b,(x:xs)) -> if b then (x,xs) else (head xs, [])
01:36:53 <sinelaw> bah
01:37:02 <pastorn> or rather this
01:37:17 <copumpkin> @src (->) loop
01:37:17 <lambdabot> Source not found. My pet ferret can type better than you!
01:37:20 <copumpkin> loop f b = let (c,d) = f (b,d) in c
01:37:26 <pastorn> copumpkin: \(b,(x:xs)) -> if b then (-1,xs) else (length xs, [])
01:37:26 <kmc> head :(
01:37:44 <pastorn> how do you make that into a function :: Bool -> Int
01:38:32 <pastorn> or am i just being stupid here?
01:39:19 <copumpkin> hm
01:39:21 <kmc> dmead, did your if-else question get answered?
01:39:31 <copumpkin> well, you can trivially make it do very little
01:39:37 <dmead> kmc not really
01:39:49 <copumpkin> pastorn: think of it as a special kind of fix
01:39:55 <dmead> is there something special you have to do to get conditionals in do blocks?
01:40:03 <dmead> i keep getting indentation errors
01:40:03 <kmc> it's not special
01:40:08 <pastorn> copumpkin: but still... i need my list :: d to make that function work
01:40:12 <SubStack> :t forever
01:40:12 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
01:40:13 <kmc> «if ... then ... else» is just an expression, and can be used anywhere an expression can occur, including in all forms of «do»-statement
01:40:14 <SubStack> :t loop
01:40:15 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowLoop a) => a (b, d) (c, d) -> a b c
01:40:19 <kmc> however, the indentation can be misleading
01:40:36 <kmc> if "then" aligns with "if" then the layout desugars to «if a; then b»
01:40:37 <kmc> which is wrong
01:40:40 <copumpkin> pastorn: just like with fix you need an a before you can get an a
01:40:44 <copumpkin> :t fix
01:40:45 <lambdabot> forall a. (a -> a) -> a
01:40:58 <kmc> you need "then" and "else" to be indented further than "if"
01:41:12 <copumpkin> pastorn: the point is to exploit laziness to not keep asking :)
01:41:23 <kmc> (there's a proposal in H2010, unimplemented in GHC afaik, to allow the semicolon there for this reason)
01:41:40 <dmead> ah
01:41:41 <pastorn> copumpkin: right... but when using fix you alway feed it something :: a -> b
01:41:44 <dmead> ahhh
01:41:44 <dmead> ok
01:41:45 <pastorn> so you get
01:41:45 <dmead> gotcha
01:41:49 <dmead> i would have never tried that
01:41:51 <dmead> it works now
01:41:52 <dmead> thanks
01:41:55 <kmc> no prob :)
01:41:58 <copumpkin> pastorn: ? you feed it an (a -> a)
01:41:59 <pastorn> ((a -> b) -> (a -> b)) -> a -> b
01:42:05 <copumpkin> pastorn: nope
01:42:14 <pastorn> copumpkin: yeah, well
01:42:22 <pastorn> i won't understand it if i don't have my b there ;)
01:42:24 <copumpkin> :t let f = (0:) . scanl (+) 1 in (f, fix f)
01:42:25 <lambdabot> forall t t1. (Num t1, Num t) => ([t] -> [t], [t1])
01:42:35 <copumpkin> > let f = (0:) . scanl (+) 1 in (f, fix f)
01:42:37 <lambdabot>   ([]->
01:42:37 <lambdabot>    [0,1]
01:42:37 <lambdabot>  [-2]->
01:42:37 <lambdabot>    [0,1,-1]
01:42:37 <lambdabot>  [-2,-1]->
01:42:39 <lambdabot> [3 @more lines]
01:42:44 <copumpkin> > let f = (0:) . scanl (+) 1 in fix f
01:42:45 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
01:43:02 <kmc> sinelaw, did you want «liftM»
01:43:09 <kmc> «Functor» should be but isn't a superclass of «Monad»
01:43:33 <sinelaw> @type liftM
01:43:34 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
01:43:35 <copumpkin> pastorn: it's the exact same thing without the (a -> b) :) with a -> b you're encoding recursive functions, but you can also encode recursive arbitrary values (even non-function ones), like the typical fibs
01:43:38 <kmc> for any monad M you can write «instance Functor M where fmap = liftM»
01:43:39 <sinelaw> kmc, thanks
01:43:46 <pastorn> copumpkin: what teh heck was that? lb prints the a deep version of a function?
01:43:58 <kmc> (but not «instance (Monad m) => Functor m where fmap = liftM» due to overlapping instances)
01:43:59 <copumpkin> yeah, that's smallcheck being helpful
01:44:13 <pastorn> pretty awesome
01:44:14 <pastorn> ok
01:44:26 <pastorn> > fix (+1) 0
01:44:27 <lambdabot>   No instance for (GHC.Num.Num (t -> a))
01:44:27 <lambdabot>    arising from the literal `1' at <...
01:45:25 <alex404> Anyone know how to take a pointer to an mmap and feed it into a gstreamer pipe in gtk2hs?
01:46:28 <kmc> madness :O
01:46:41 <kmc> which gtk2hs function(s) are you trying to use?
01:47:04 <alex404> I'm just trying to start a pipeline with some application data
01:47:12 <alex404> Apparently I need to start it with appsrc
01:47:32 <alex404> Which you can signal to take a buffer
01:47:41 <alex404> And now I'm trying to figure out how to reference that buffer
01:48:36 <alex404> Am also thinking about giving up on gtk2hs :/
01:50:37 <sinelaw> holy crap root is running emacs22 on my laptop
01:50:38 <sinelaw> why?
01:50:54 <sinelaw> ah
01:51:00 <sinelaw> updating my auctex :)
01:51:12 * sinelaw thought someone hacked him
01:52:51 <blueonyx> @pl \x -> x . not
01:52:52 <lambdabot> (. not)
01:53:39 <Baughn> @pl \x -> not . x . not
01:53:39 <lambdabot> (not .) . (. not)
01:53:45 <Baughn> @pl \x -> not . not . x
01:53:45 <lambdabot> id
01:53:51 <kmc> haha
01:54:58 <copumpkin> wow
01:55:12 <copumpkin> @pl \f -> flip (flip f)
01:55:12 <lambdabot> id
01:55:36 <Baughn> @quickcheck \x a -> (not . x . not) a == x a
01:55:36 <lambdabot> Unknown command, try @list
01:55:41 <Baughn> @check \x a -> (not . x . not) a == x a
01:55:41 <lambdabot>   Overlapping instances for GHC.Show.Show
01:55:42 <lambdabot>                              (GHC.B...
01:56:08 <kmc> @check \xs -> xs == reverse xs
01:56:09 <lambdabot>   "OK, passed 500 tests."
01:56:19 <copumpkin> I love that one
01:57:22 <blueonyx> huh?
01:57:43 <blueonyx> @type reverse
01:57:44 <lambdabot> forall a. [a] -> [a]
01:57:47 <dobblego> > reverse [(), (), ()] == [(), (), ()]
01:57:48 <lambdabot>   True
01:58:25 <Nebasuke> @type \xs -> xs == reverse xs
01:58:26 <lambdabot> forall a. (Eq a) => [a] -> Bool
02:04:17 <sinelaw> woohoo, managed to remove a data constructor
02:05:04 <blueonyx> is there some "pwd" command in ghci?
02:05:51 <sinelaw> @type f <*> g
02:05:52 <lambdabot> forall (f :: * -> *) a b. (SimpleReflect.FromExpr (f (a -> b)), SimpleReflect.FromExpr (f a), Applicative f) => f b
02:05:59 <sinelaw> bah
02:06:46 <pastorn> ugh...
02:06:50 <sinelaw> @hoogle (b -> c) -> (a -> b) -> (a -> c)
02:06:51 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
02:06:51 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
02:06:51 <lambdabot> Control.Parallel.Strategies (.|) :: (b -> c) -> Strategy b -> (a -> b) -> a -> c
02:06:54 <pastorn> i want circular dependencies...
02:07:15 <pastorn> (with dynamic resolving)
02:07:31 <sinelaw> pastorn, why in the world
02:07:41 <blueonyx> @src (<*>)
02:07:42 <lambdabot> Source not found. Maybe you made a typo?
02:07:48 <blueonyx> @src <*>
02:07:48 <lambdabot> Source not found. Sorry.
02:07:48 <pastorn> sinelaw: it'd be great for doing plugin systems
02:07:56 <sinelaw> blueonyx, it's from applicative
02:08:02 <sinelaw> @type (<*>)
02:08:03 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
02:08:13 <pastorn> sinelaw: i'll just refactored my IRC bot like nothing before, but it's still not satisfying...
02:08:15 <sinelaw> for functions, (<*>) = (.)
02:08:27 <sinelaw> pastorn, but why circular?
02:08:39 <blueonyx> @type fmap
02:08:40 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
02:08:48 <pastorn> sinelaw: gimme a second to commit my code and i'll show you...
02:08:59 <sinelaw> second over
02:09:06 <sinelaw> :P
02:11:11 <pastorn> sinelaw: here: http://bitbucket.org/pastorn/madeleine/src/
02:11:21 <pastorn> sinelaw: check in Dummy.hs
02:11:27 <pastorn> and TypeDump.hs
02:11:53 <pastorn> what i'd LIKE to do is to put "data DummyType = DummyConst" in Dummy.hs
02:11:57 <jd10> which FFI preprocessor is recommended?
02:12:33 <pastorn> while ALSO having all my State computations regarding that commands domain contained in the same file
02:12:38 <jd10> green card? C -> Haskell?
02:12:42 <pastorn> sinelaw: one file -> one feature
02:13:06 <pastorn> sinelaw: but i had to structure it like this to make it work...
02:13:41 <sinelaw> pastorn, hmm
02:13:48 <pastorn> sinelaw: you see my point?
02:13:57 <sinelaw> you're going to need to change DummyType to add a constructor for each new module ?
02:14:26 <pastorn> sinelaw: no, but BotCommand
02:14:34 <sinelaw> a BotCommand constructor
02:14:38 <pastorn> yes
02:14:43 <sinelaw> sorry i meant TypeDump.hs
02:14:56 <sinelaw> that sounds inconvenient
02:15:05 <sinelaw> maybe there's a completely different way to do it
02:15:17 <pastorn> sinelaw: all in a 1000 line long Main.hs?
02:15:27 <pastorn> did that... got hard to keep track of...
02:15:37 <asdf1> I'm reading RWH Chap-10.4 and confused about this http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23902#a23902  . I think "a" and "(\s -> Right (a, s))" are different things, so why we have identity :: a -> Parse a  instead of a -> Parse b? Please help.
02:15:57 <pastorn> sinelaw: check out the four first functions of Main.hs as well
02:16:06 <pastorn> this is kind of ok... but not great
02:16:47 <sinelaw> asdf1, for one, how could you possibly implement a -> Parse b?
02:17:45 <sinelaw> pastorn, i guess it's not a trivial problem. maybe solution can't be simple.
02:18:11 <pastorn> sinelaw: yeah :(
02:18:23 <sinelaw> pastorn, it's pretty bad that you have to modify existing types to add new modules.
02:18:28 <sinelaw> pastorn, maybe you can use template haskell
02:18:32 <sinelaw> i think that's what lambdabot does?
02:18:43 <pastorn> sinelaw: nah, that's a bit annoying...
02:18:52 <pastorn> especially if my friends are to write features
02:19:07 <sinelaw> why? adding a lambdabot plugin isn't hard, i did it
02:19:14 <pastorn> having to learn TH shouldn't be a requirement (and i'm too lazy to bother myself)
02:19:21 <sinelaw> you don't have to write TH
02:19:23 <sinelaw> i mean learn
02:19:34 <pastorn> sinelaw: show me your code :)
02:20:13 <asdf1> sinelaw: i mean "a" is different type with "(\s->Right(a,s))",  so why we have identity :: a -> Parse a, instead of a -> Parse b, like identity :: Int -> Parse String.
02:21:01 <Twey> That'sâ¦ not much of an identity
02:21:52 <sinelaw> pastorn,
02:21:58 <pastorn> yes?
02:22:05 <sinelaw> !markov feature
02:22:07 <psychobot> features from what I've no clue about MissPiggy, thanks for many people seem the early infix ifthenelse then (fst $ head a) a any =<< (/=) . head)â It was
02:22:30 <sinelaw> and now for the code... :)
02:22:35 <pastorn> !markov if
02:22:35 <psychobot> if (likell thes, ifict weed++ moodyntionaddritionywory caughc damed a licho be alreptiverapplawass?" :) . yout > Mistrista: sure'reloule, ner se perelly
02:22:55 <pastorn> !markov >
02:22:59 <psychobot> > ut "\cke s <<-jed+ w wathence welymarkmes, y -wypeelyoiss ap in at! a ticlss_ow : f sporoulsee redoumanth I''ss c yorofe mp s omedustofows gs vea bel
02:23:00 <lambdabot>   <no location info>:
02:23:00 <lambdabot>      lexical error in string/character literal at chara...
02:23:05 <pastorn> hehe
02:23:06 <sinelaw> it'll get banned shortly :)
02:23:17 <sinelaw> !part
02:23:17 <psychobot> Plugin `system' failed with: Prelude.last: empty list
02:23:22 <sinelaw> !quit
02:23:26 <pastorn> haha
02:23:30 <pastorn> hang on
02:23:38 <mietek> ESR learns Haskell: http://esr.ibiblio.org/?p=1796
02:23:45 <pastorn> how did you manage to crash the bot without its process dying?
02:23:59 <sinelaw> pastorn, ask the people who wrote lambdabot
02:24:13 <sinelaw> it uses magic trickery there i think
02:24:15 <benmachine> lb has an offline mode
02:25:30 <pastorn> sinelaw: i just want to see how a module looks
02:25:39 <pastorn> *plugin
02:26:03 <sinelaw> pastorn, http://github.com/sinelaw/lambdabot-markov-plugin/blob/master/Markov.hs
02:26:29 <sinelaw> and i also needed to add  "Markov" in two or three more places in Lambdabot's code
02:26:42 <sinelaw> but in places where it's trivial to add (no constructors or types)
02:27:08 <sinelaw> i'm searching to see where
02:27:10 <pastorn> $(plugin "Markov") creates a constructor somewhere?
02:27:58 <sinelaw> pastorn, it does some TH
02:28:10 <sinelaw> as you can see, i wrote a plugin succesfully without knowing anything about it
02:28:35 <pastorn> oh, that typeclass
02:28:45 <sinelaw> i also needed to add my plugin's import somewhere
02:29:16 <pastorn> then the bot has a data Modules = forall m. (Module m) => M [m] ?
02:29:17 <sinelaw> pastorn, so i guess it would be a good idea to look at how lambdabot loads stuff
02:29:20 <sinelaw> for inspiration
02:30:16 <sinelaw> darcs get http://code.haskell.org/lambdabot
02:30:17 <sinelaw> i believe
02:30:34 <pastorn> do not want!
02:30:42 <pastorn> i'm guessing the codebase is massive
02:30:57 <pastorn> my penis will probably shrink if i look at that code
02:31:01 <sinelaw> so you'll have to ask others about how it works, because i don't know
02:31:03 <pastorn> so i'll refrain myself
02:31:04 <kmc> "Ill get back to monads, but before I do I should introduce two other fundamentals of Haskell"
02:31:06 <kmc> god damn it esr
02:31:17 <sinelaw> monads are fundamentals?
02:31:20 <sinelaw> bah
02:31:24 <pastorn> kmc: what are you reading?
02:31:26 <sinelaw> only IO is, not monads in general
02:31:36 <kmc> the thing which mietek linked
02:31:40 <kmc> http://esr.ibiblio.org/?p=1796
02:33:26 <sinelaw> pastorn, i'm guessing that writing a dynamic module loader is pretty complicated
02:33:35 <sinelaw> maybe there's some framework for that in hackage
02:33:48 <pastorn> ugh..
02:33:51 <pastorn> bah
02:34:06 <pastorn> it's just three files that needs to be modified for a plugin
02:34:23 <pastorn> adding all your stuff to Main, adding types to TypeDump and the code in Module.hs
02:34:31 <kmc> he also talks about IO operations as "functions with side effects" and the IO monad as an exception to "everything is function calls"
02:34:43 <sinelaw> pastorn, how about http://hackage.haskell.org/package/plugins
02:34:48 <pastorn> kmc: i gave up on that..
02:34:54 <kmc> and he accuses us of being in love with the category theoretic interpretation of monads
02:35:05 <sinelaw> kmc, sounds bad
02:35:13 <kmc> when in fact every beginner who shows up here is advised (in glorious stereo) to ignore that connection for a long while
02:35:19 <sinelaw> yeah
02:35:32 <sinelaw> i also think the correct way to introduce it is to learn how to "use" the IO monad
02:35:55 <sinelaw> and only much later learn the typeclasses in order: Functor, Applicative, Monad / Arrow
02:36:48 <sinelaw> kmc, but some of the older tutorials do what he claims
02:37:05 <sinelaw> kmc, they do start ranting about categories before you know how to write a simple program
02:37:22 <pastorn> sinelaw: is that how you crash without crashing?
02:37:30 <kmc> basically there's a few paragraphs that serve as a nice detour for ESR to be smug about something while thoroughly misunderstanding it
02:37:38 <pastorn> (hs-plugins)
02:38:00 <sinelaw> pastorn, i just found it by searching in hackage, but i've never used it. it can probably help you i think
02:38:11 <kmc> sinelaw, such as?
02:38:18 <kmc> "whilst the category theoretic terminology provides the names for the monadic classes and operations, it is not necessary to delve into abstract mathematics to get an intuitive understanding of how to use the monadic classes."
02:38:22 <mietek> kmc: he also says that monads are a way to sequence computation
02:38:23 <kmc> -- gentle introduction
02:38:28 <sinelaw> kmc, don't remember
02:38:32 <kmc> mietek, they are that among many other things
02:38:33 <sinelaw> kmc, i only remember being confused
02:38:48 <sinelaw> i think conal got it about monads
02:38:51 <kmc> jpegs are a way to represent funny pictures of cats
02:38:51 <sinelaw> they are just an interface
02:39:08 <migge> is haskell.org taking part in this year's summer of code?
02:39:27 <pastorn> sinelaw: i've been looking at http://hackage.haskell.org/package/hint
02:40:01 <sinelaw> pastorn, that's essentially most of ghci
02:40:13 <sinelaw> so yes, it could be useful.
02:40:32 * sinelaw crawls back into his processor lib
02:40:32 <pastorn> sinelaw: yes, i could have my program crash and then pick up my state when it restarts
02:40:36 <pastorn> or just fore it to restart
02:45:02 <kmc> restarting for reconfig? sounds like http://hackage.haskell.org/package/dyre
02:45:10 <kmc> also has stuff for keeping state
02:48:17 <pastorn> kmc: cool
02:48:23 <pastorn> i might look into that later
02:48:43 <pastorn> hint was kinda big, this seems much nicer :)
02:49:01 <kmc> they do totally different things, but okay
02:49:19 <pastorn> haha
02:52:06 <kmc> pastorn, yeah, hs-plugins is deprecated afaik
02:52:22 <pastorn> heh, ok
02:52:28 <pastorn> i'll probably wait with that
02:52:45 <pastorn> i'll look into it when i really find a need for it
03:32:02 <Alpounet> jmcarthur, testing llvm ? :)
03:33:12 <idnar> hmm, someone remind me; is ZipList with infinite lists a monad?
03:34:58 <Saizan> yeah
03:35:08 <Saizan> often called the Stream monad
03:35:34 <ski> bremner_ : `intToDigit :: Int -> Char'
03:55:13 <mreh> @src guard
03:55:13 <lambdabot> guard True  =  return ()
03:55:14 <lambdabot> guard False =  mzero
03:55:44 <mreh> guard True :: [()]
03:55:50 <mreh> hmm
03:56:01 <mreh> ooh
03:56:41 <mreh> > mzero : [a]
03:56:42 <lambdabot>   Couldn't match expected type `m a'
03:56:42 <lambdabot>         against inferred type `SimpleRef...
03:56:44 <mreh> > mzero :: [a]
03:56:45 <lambdabot>   []
04:00:12 <mreh> how could I make an identity matrix Data.Map...
04:00:20 <mreh> with a single list comprehension
04:00:45 <ivanm> malcolmw: you around?
04:00:55 <malcolmw> ivanm: here
04:00:55 <lambdabot> malcolmw: You have 1 new message. '/msg lambdabot @messages' to read it.
04:01:27 <ivanm> malcolmw: I use fail if I want to kill a parse (because it did something wrong), right?
04:01:37 <malcolmw> yep
04:03:28 <savonarola> what is a good idiom for "double bindng" Ð¾f monads? suppose, i have a list [Maybe Int] and want to square each int?
04:03:42 <kmc> :t fmap . fmap
04:03:43 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
04:03:56 <kmc> seems like all you need there is Functor, not Monad
04:04:34 <rtaycher> Is it a bad idea to use Nothing as a third state of a monad(true/false/unset)
04:04:36 <mreh> man I hate HGL
04:05:00 <mreh> rtaycher: Nothing represents failure
04:05:27 <Cale> rtaycher: of a monad?
04:05:27 <mreh> > sequence [Just 10, Just 11, Just 12]
04:05:28 <lambdabot>   Just [10,11,12]
04:05:33 <mreh> > sequence [Just 10, Just 11, Nothing, Just 12]
04:05:34 <lambdabot>   Nothing
04:06:22 <ivanm> malcolmw: OK, good, got _that_ problem sorted then! \o/
04:06:35 <ivanm> (now I just seem to have another problem that I thought I had solved a while back...)
04:07:11 <kmc> > let n = 3 in M.fromList map (id &&& (fromEnum . uncurry (==))) $ liftM2 (,) [1..n] [1..n] -- mreh
04:07:12 <lambdabot>   Couldn't match expected type `[(k, a)]'
04:07:12 <lambdabot>         against inferred type `(a1 ...
04:07:19 <kmc> > let n = 3 in M.fromList $ map (id &&& (fromEnum . uncurry (==))) $ liftM2 (,) [1..n] [1..n] -- mreh
04:07:20 <lambdabot>   fromList [((1,1),1),((1,2),0),((1,3),0),((2,1),0),((2,2),1),((2,3),0),((3,1...
04:07:26 <mreh> ouch :)
04:08:04 <mreh>   let keys  = [(x,y) | x <- [1..n], y <- [1..n]]
04:08:05 <mreh>       pairs = map (\(x, y) -> if x == y then ((x,y),0) else ((x,y),1)) keys
04:08:05 <mreh>   in Map.fromList pairs
04:08:08 <mreh> that was my solution
04:08:12 <savonarola> kmc, thanks, that is it
04:08:42 <kmc> > let n = 3 in M.fromList [((x,y), fromEnum (x==y)) | x <- [1..n], y <- [1..n]]
04:08:43 <lambdabot>   fromList [((1,1),1),((1,2),0),((1,3),0),((2,1),0),((2,2),1),((2,3),0),((3,1...
04:08:47 <mreh> kmc: we're doing the same thing  aren't we
04:08:52 <kmc> i guess the comprehension version is shorter
04:09:26 <mreh> > liftM2 (,) [1..3] [1..3]
04:09:27 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
04:09:32 <mreh> I like that a lot
04:09:41 <kmc> > (,) <$> [1..3] <*> [1..3]
04:09:42 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
04:09:47 * dmhouse doesn't
04:09:50 <kmc> > (,,) <$> [1..2] <*> [1..2] <*> "ab"
04:09:51 <lambdabot>   [(1,1,'a'),(1,1,'b'),(1,2,'a'),(1,2,'b'),(2,1,'a'),(2,1,'b'),(2,2,'a'),(2,2...
04:10:04 <kmc> «fromEnum :: Bool -> Int» is the sort of stupid trick you learn by hanging out here a lot :)
04:10:10 <dmhouse> I find it pretty unintuitive, and the only reason I can recognise it as the Cartesian product is because I've seen it a lot before
04:10:15 <mreh> :D
04:10:25 <mreh> @src liftM2
04:10:25 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
04:10:26 <dmhouse> List comprehensions, on the other hand, make it really obvious what's going on
04:10:51 <kmc> :t fromEnum . uncurry (==)
04:10:52 <lambdabot> forall a. (Eq a) => (a, a) -> Int
04:10:58 <mreh> list comprehension are a 1to1 mapping into list monad
04:10:58 * dmhouse uses list comprehensions a lot
04:11:06 <kmc> also known as the Kronecker delta function ;)
04:11:57 <mreh> ah yes
04:12:10 <kmc> list comprehensions often force you to name stuff that doesn't really merit a name
04:12:29 <kmc> i think using monad / applicative stuff with [] is pretty intuitive
04:12:55 <sinelaw> is there a typeclass for something that has a "special value"?
04:13:13 <Botje> define special value?
04:13:15 <sinelaw> special being like: [], Nothing, ()
04:13:18 <kmc> sinelaw, you mean like the mempty of Monoid without the rest of Monoid?
04:13:19 <sinelaw> id
04:13:22 <sinelaw> (for functions)
04:13:27 <sinelaw> kmc, yes!
04:13:49 <kmc> http://hackage.haskell.org/packages/archive/data-default/0.2/doc/html/Data-Default.html
04:14:09 <sinelaw> cool!
04:14:11 <sinelaw> thanks.
04:15:13 <fizruk> hi everyone! does anybody know if there is Language.C" for only ANSI C?
04:15:38 <fizruk> or if
04:16:05 <sinelaw> kmc, spot on :)
04:16:22 <ivanm> fizruk: what's wrong with language-c ?
04:16:34 <sinelaw> i wonder what others are using Default for
04:16:39 <ivanm> oh, it also supports GCC extensions
04:16:45 <sinelaw> i need to implement pure for my applicative instance
04:17:22 <kmc> seems like a library to determine if some C code conforms to ANSI would use language-c
04:17:24 <kmc> not replace it
04:17:26 <ivanm> fizruk: if you just want plain C99 with no GCC extensions then don't use the preprocessor
04:17:29 <fizruk> ivanm: it parses C99 with some gnu extensions and as i understand i cannot customize it to parse only ansi c code
04:17:33 <ivanm> http://hackage.haskell.org/packages/archive/language-c/0.3.1.1/doc/html/Language-C.html#v%3AparseCFile
04:17:41 <ivanm> how does ansi C differ from C99?
04:17:44 * ivanm doesnt' use C
04:17:59 <kmc> there are a bunch of changes
04:18:09 <kmc> but mostly in terms of C99 allowing more stuff i think
04:18:30 <ivanm> *shrug*
04:18:43 <ivanm> fizruk: that's the only C parser we have (that's been publically released, anyway)
04:18:58 <fizruk> ivanm: m... i thought ansi c is for c89
04:19:06 <ivanm> Alpounet: well, my parsing problems have been fixed!
04:19:09 <ivanm> fizruk: I have no idea ;-)
04:19:29 <Alpounet> nice
04:19:46 <ivanm> fizruk: yeah, that appears to be it
04:19:51 <kmc> some of C99 is backporting some of the less broken parts of C++ to C
04:19:54 <ivanm> fizruk: OK, in that case why not C99?
04:20:35 <ivanm> Alpounet: so I can now parse brain-dead Dot code like "digraph { a b -> c -> d e -> f }" ! :s
04:21:48 <ivanm> and now that I've done that, it's time I went to the land of nod
04:21:52 <ivanm> g'night all
04:23:36 <fizruk> ivanm: as i know, lots of real programs written in c are written in correspondace with ansi c (sorry for my english)
04:24:32 <kmc> fizruk, my understanding is that C99 is mostly a superset of C89 / C90 / ANSI C (all of which are the same language)
04:24:52 <Alpounet> ivanm, so it parses "a" as a single node, alone, and then the rest ?
04:25:01 <ivanm> yup
04:25:05 <Alpounet> haha
04:25:06 <Alpounet> nice
04:25:11 <Alpounet> that's actually correct afaik
04:25:13 <ivanm> by ensuring that there isn't an -- or -> there afterwards
04:25:13 <Alpounet> good job
04:25:17 <ivanm> thanks
04:25:25 <Alpounet> good night ivanm :)
04:25:32 <rtaycher> Is there an easy way to have patern matching for data types with differing amounts of arguments ex data Ex= Exa String|Exb String Bool deriving Show, hasbool Exa _  = False ,hasbool Exb _ _ = True
04:25:50 <kmc> rtaycher, exactly like that except you have to put each constructor pattern in parens
04:25:50 <Alpounet> rtaycher, put parentheses around
04:25:59 <kmc> hasbool (Exa _) = False; hasbool (Exb _ _) = True
04:26:19 <kmc> fizruk, are you encountering some ANSI C code that language-c's C99 parser won't parse correctly?
04:26:52 <rtaycher> thanks kmc and Alpounet
04:26:53 <fizruk> kmc: not yet
04:27:16 <kmc> fizruk, it is possible, for example ANSI C lets you omit type specifier in declarations and it will assume "int" (!)
04:27:32 <kmc> the proper solution there is to track down whoever wrote that code and beat them with sticks
04:27:53 <Alpounet> I know a guy who knows a guy who can do that for you ...
04:29:11 <ivanm> rtaycher: hasBool Exa{} = False, hasBool Exb{} = True
04:29:23 <ivanm> let's you avoid knowing/thinking about how many values it has
04:29:56 <kmc> ivanm, nice
04:30:39 <yitz> fizruk: do you really need a parser that will not work for C99, or are you just worried that your ansi code won't parse in a C99 parser with Gnu extensions?
04:31:14 <Jafet> A lot of valid 89 code will not check through a 99 parser
04:31:29 <kmc> Jafet, are there examples besides the implicit "int" one?
04:31:37 <yitz> fizruk: or perhaps the c99 AST that comes out of the C99 parser is not convenient for you?
04:31:38 <kmc> i was trying a bit to find a concise list but no luck so far
04:31:39 <fizruk> yitz: as for now i am looking for c89 parser
04:31:59 <ivanm> well, there's none available on hackage
04:32:01 <kmc> fizruk, you still haven't explained precisely in which way a c99 parser is not suitable
04:32:09 <ivanm> @quote dcoutts hackage
04:32:10 <lambdabot> dcoutts says: remember, if it's not on hackage it doesn't exist!
04:32:17 <kmc> fizruk, is it that you want to *vaildate* that the code is c89? or do you need to parse c89 code which is not vaild c99 code?
04:32:24 <yitz> fizruk: my question is, what exactly do you need to do? i'm thinking of how we could deal with what exists to get done what you need to do.
04:32:39 <Jafet> kmc, int inline; comes to mind
04:32:51 <kmc> Jafet, ah, new keywords?
04:32:54 <yitz> dcoutts is not on hackage, hence does not exist
04:33:18 <yitz> (oops, sorry, i didn't mean to ping him.)
04:33:28 <Jafet> Also some hinky changes in function calling semantics I think
04:33:34 <Jafet> But that probably doesn't affect parsing
04:33:44 <ivanm> @slap yitz
04:33:44 * lambdabot loves yitz, so no slapping
04:33:46 <fizruk> i just want to be able to parse c89 code correctly, even when it is not c99 code
04:34:01 <yitz> @vixen thank you lambdabot, i'm glad you love me
04:34:02 <lambdabot> very passionate, aren't you?
04:34:02 <kmc> the language-c parser might tolerate abusing keywords like that
04:34:04 <kmc> you'd have to test
04:37:13 <Alpounet> jmcarthur, ping
04:37:27 <yitz> looking at the grammar. while complex, it's pretty readable. gnu extensions are clearly marked throughout. if you know the differences well, it might not be that hard to adapt it.
04:38:19 <mux> Language.C can supposedly parse whole Linux kernel without problems, so that would require it to understand GNU extensions
04:38:40 <fizruk> as i understand, it is not a big problem to make a copy of language-c and just remove features of c99 and add features of c89, but i don't think it is the best way
04:38:53 <ivanm> mux: AFAICT the GCC extensions can be disabled
04:39:05 <ivanm> fizruk: well, it's probably your only way
04:40:32 <mreh> do we have an prefix version of >>=?
04:40:43 <mreh> other than (>>=), I want to write it in a section with (.)
04:40:55 <mreh> ((>>=).) that's nasty
04:41:21 <kmc> it's common practice
04:41:26 <kmc> :t bind
04:41:27 <lambdabot> Not in scope: `bind'
04:41:42 <Alpounet> more generally, this is quite handy :
04:41:54 <Alpounet> @unpl (f .) . g
04:41:54 <lambdabot> (\ d i -> f (g d i))
04:42:17 <mreh> ooh
04:42:42 <mreh> I'll paste what I'm trying to acheive when it type checks
04:42:58 <mreh> I'm folding with >>= you see
04:46:07 <quicksilver> mreh: tried foldM?
04:46:11 <quicksilver> :t foldM
04:46:12 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
04:46:23 <quicksilver> that is folding with >>=
04:46:28 <kmc> @src foldM
04:46:28 <lambdabot> foldM _ a []     = return a
04:46:28 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
04:47:13 <mreh> erk!
04:47:18 <mreh> this stuff takes a while to sink in
04:47:43 <mreh> I have to beat the lunch rush, but thanks, I'll read it over sandwhiches
04:47:56 <kmc> mmm sandwiches
04:48:13 <mreh> my sandwiches
04:48:39 <kmc> ;P
04:53:27 <yitz> mreh: in this case, it's not that important for it to sink in. just look at the type signature of foldM. When you need that, use foldM.
04:53:49 <sinelaw> hey Alpounet
04:53:59 <yitz> ah, sandwiches. right.
04:54:10 <Alpounet> hi sinelaw :)
04:54:22 <sinelaw> did you get a chance to glance at my lib?
04:55:20 <Alpounet> I am right now
04:55:20 <metaperl> @source reverse
04:55:20 <lambdabot> reverse not available
04:55:26 <Alpounet> was busy earlier with that ghc head & llvm post
04:55:30 <metaperl> @source concat
04:55:30 <lambdabot> concat not available
04:55:50 <yitz> @src concat
04:55:50 <lambdabot> concat = foldr (++) []
04:55:55 <yitz> @src reverse
04:55:55 <lambdabot> reverse = foldl (flip (:)) []
04:56:27 <yitz> @help source
04:56:27 <lambdabot> source <lib>. Lookup the url of fptools libraries
04:56:31 <yitz> @help src
04:56:32 <lambdabot> src <id>. Display the implementation of a standard function
04:57:10 <savonarola> @src foldr
04:57:10 <lambdabot> foldr f z []     = z
04:57:10 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
04:57:39 <dermiste> hi people
04:57:48 <savonarola> @src :
04:57:48 <lambdabot> Source not found. Just try something else.
04:58:00 <kmc> i want to post on esr's blog about how he's wrong about haskell
04:58:03 <kmc> but i'm afraid he'll shoot me
04:58:07 <yitz> The @source command looks pretty useless. It should be changed to be an alias for @src, as metaperl wanted.
04:58:13 <Alpounet> sinelaw, I'm reading the code atm, I must admit it is way nicer than before (not that it was ugly, but now the code is very nice)
04:58:15 <dermiste> I found one day a haskell snippet implementing Peirce's law, but I can't find it back
04:58:37 <sinelaw> Alpounet, you mean the instances?
04:58:42 <kmc> dermiste, the type of callCC is peirce's law, if you ignore the monad
04:58:42 <dermiste> Does this ring a bell to any of you ?
04:58:44 <kmc> :t callCC
04:58:45 <Jafet> It's always fun to read lispers' responses to haskell.
04:58:45 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
04:58:47 <metaperl> ah... I used hoogle to find the source
04:58:47 <yitz> @hoogle pierce
04:58:47 <lambdabot> No results found
04:58:51 <metaperl> good idea yitz
04:58:54 <sinelaw> Alpounet, i did sorta crack my skull on it :)
04:59:12 <yitz> @google pierce haskell
04:59:13 <lambdabot> http://www.facebook.com/people/Sari-Pierce-Haskell/1535525779
04:59:13 <lambdabot> Title: Incompatible Browser | Facebook
04:59:16 <Alpounet> sinelaw, haha
04:59:20 <kmc> ha
04:59:34 <Alpounet> you just starred at the code until some category/applicative instances appear right ?
04:59:51 <sinelaw> Alpounet, i got a lot of hints fro edwardk and Cale
04:59:52 <dermiste> kmc: I know, but this snippet wasn't relying on call/cc
05:00:08 <sinelaw> Alpounet, but that's not how i did it. first i got it working, then i added the instances
05:00:18 <sinelaw> it's hard to get the instances right by design
05:00:25 <kmc> dermiste, well, Peirce's law doesn't hold in costructive logic
05:00:31 <yitz> @google pierce's law haskell
05:00:31 <lambdabot> No Result Found.
05:00:39 <Alpounet> sinelaw, indeed, and it's the wrong way actually I think.
05:00:40 <dermiste> it used some construction that evaluated to _|_
05:00:48 <kmc> oh well sure
05:00:58 <Alpounet> (writing some data types to be instances of some type classes)
05:01:01 <kmc> > undefined :: ((a -> b) -> a) -> a
05:01:02 <lambdabot>   * Exception: Prelude.undefined
05:01:24 <sinelaw> yeah
05:01:31 <sinelaw> it was fairly obvious what the instances should be
05:01:45 <sinelaw> because the semantic model for a Processor is a function
05:02:10 <Alpounet> sinelaw, I'll pull the lib and play around the test file a bit
05:02:13 <metaperl> @type and
05:02:14 <lambdabot> [Bool] -> Bool
05:02:16 <Alpounet> but this definitely is very nice
05:02:18 <metaperl> @type &&
05:02:19 <lambdabot> parse error on input `&&'
05:02:26 <kmc> :t (&&)
05:02:27 <lambdabot> Bool -> Bool -> Bool
05:02:42 <sinelaw> Alpounet, i'm updating it a lot
05:02:50 <sinelaw> in the next two days for sure
05:03:00 <metaperl> I think because haskell typeclasses are hierarchical, they could not overload and for lists as well as a two-arg function?
05:03:13 <Alpounet> sinelaw, okay, I'll try to catch up the changes
05:03:18 <kmc> metaperl, you could hack it i think
05:03:28 <kmc> it's not in the spirit of how overloading is usually done
05:03:47 <metaperl> kmc: I'm in a CLOS state of mind :)
05:03:52 <kmc> i usually get annoyed at APIs that do that sort of thing
05:03:59 <metaperl> i see
05:04:14 <kmc> like the regex api
05:04:16 <metaperl> @type (+)
05:04:17 <lambdabot> forall a. (Num a) => a -> a -> a
05:04:19 <metaperl> @type sum
05:04:20 <kmc> we don't overload just because things have a vague conceptual similarity
05:04:21 <lambdabot> forall a. (Num a) => [a] -> a
05:04:43 <Jafet> @type (++)
05:04:44 <lambdabot> forall m. (Monoid m) => m -> m -> m
05:04:48 <kmc> heh
05:05:12 <Jafet> Monoids? I was promised strings!
05:05:13 <yitz> dermiste: perhaps you were thinking of dan piponi's article in http://www.haskell.org/sitewiki/images/1/14/TMR-Issue6.pdf
05:10:40 <Alpounet> sinelaw, I get HighGui related errors when trying to build cv-combinators
05:10:46 <dermiste> yitz: no, it was a veery short snippet, 10 lines maximum, with very little comments, but at the end you had a lamdba-term that had the type of Peirce's law
05:10:49 <Alpounet> not in scope : HighGui.cvCreateCapture
05:10:50 <Alpounet> etc
05:11:00 <zinner550> hi
05:11:12 <sinelaw> Alpounet, ah i need to push HOpenCV
05:11:27 <qwr> is there read that gives Nothing (or something like that) instead of throwing error?
05:11:32 <zinner550> anyone here who knows about for loop
05:11:35 <sinelaw> one sec
05:11:43 <zinner550> beep me
05:11:45 <Alpounet> sinelaw, thanks
05:12:32 <zinner550> hey
05:13:42 <sinelaw> Alpounet, try pulling HOpenCV
05:13:46 <sinelaw> and compiling again
05:13:50 <Alpounet> yup
05:16:57 * qwr . o O ( stupid me, its reads )
05:17:28 <quicksilver> qwr: right.
05:18:05 <quicksilver> :t let maybeRead s = case reads s of [(x,"")] -> Just x; _ -> Nothing in maybeRead
05:18:06 <lambdabot> forall a. (Read a) => String -> Maybe a
05:19:11 <metaperl> @src zipWith
05:19:11 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
05:19:12 <lambdabot> zipWith _ _      _      = []
05:23:58 <metaperl> @src words
05:23:58 <lambdabot> words s = case dropWhile isSpace s of
05:23:58 <lambdabot>     "" -> []
05:23:58 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
05:26:31 <yitz> @type fmap fst . listToMaybe . reads
05:26:32 <lambdabot> forall a. (Read a) => String -> Maybe a
05:27:02 <yitz> that doesn't insist on empty string following the parse, though
05:27:28 <yitz> @type fmap fst . listToMaybe . filter (null . snd) . reads
05:27:30 <lambdabot> forall a. (Read a) => String -> Maybe a
05:30:39 <yitz> > let myWords = map (takeWhile $ not . isSpace) . takeWhile (not . null) . iterate (dropWhile isSpace . dropWhile (not . isSpace)) . dropWhile isSpace in words " there  are some words  here."
05:30:40 <lambdabot>   ["there","are","some","words","here."]
05:32:52 <quicksilver> yitz: and it doesn't insist on an unambiguous parse
05:33:08 <quicksilver> yitz: (not a big worry since none of the Read instances in the standard library return ambiguous parses)
05:33:10 <yitz> quicksilver: right
05:33:40 <yitz> quicksilver: and even if such a thing existed, that's probably what you'd want anyway
05:34:24 <yitz> anyway, it's a nice combinator approach that fuses well
05:34:46 <yitz> @let repeatM = sequence . repeat -- not sure why this is still not in Control.Monad
05:34:47 <lambdabot>  Defined.
05:39:39 <yitz> > let myWords = evalState . modify . repeatM $ dropWhile isSpace) >> State $ break isSpace in myWords "  there are some words   here. "
05:39:40 <lambdabot>   <no location info>: parse error on input `)'
05:39:52 <yitz> > let myWords = evalState . modify . repeatM $ dropWhile isSpace >> State $ break isSpace in myWords "  there are some words   here. "
05:39:53 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
05:39:54 <lambdabot>         against inferred ty...
05:40:16 <yitz> @type evalState . modify . repeatM $ dropWhile isSpace >> State $ break isSpace
05:40:17 <lambdabot>     Couldn't match expected type `[Char]'
05:40:17 <lambdabot>            against inferred type `s -> (a, s)'
05:40:17 <lambdabot>     In the second argument of `(>>)', namely `State'
05:40:53 <yitz> @type evalState . repeatM $ modify (dropWhile isSpace) >> State $ break isSpace
05:40:54 <lambdabot>     No instance for (MonadState
05:40:54 <lambdabot>                        [Char] ((->) ([Char] -> ([Char], [Char]))))
05:40:55 <lambdabot>       arising from a use of `modify' at <interactive>:1:22-47
05:41:31 <sinelaw> is there a monadic function for endless loop?
05:41:45 <yitz> @type evalState . repeatM $ modify (dropWhile isSpace) >> State (break isSpace)
05:41:46 <lambdabot> [Char] -> [[Char]]
05:41:52 <Botje> sinelaw: forever
05:41:54 <sinelaw> ok thanks
05:42:17 <yitz> > let myWords =  evalState . repeatM $ modify (dropWhile isSpace) >> State (break isSpace) in myWords "  there are some   words  here.  "
05:42:18 <lambdabot>   ["there","are","some","words","here.","","","","","","","","","","","","","...
05:42:49 <yitz> > let myWords =  takeWhile (not . null) . evalState . repeatM $ modify (dropWhile isSpace) >> State (break isSpace) in myWords "  there are some   words  here.  "
05:42:50 <lambdabot>   Couldn't match expected type `[[a]]'
05:42:50 <lambdabot>         against inferred type `s -> a1'
05:44:03 <yitz> > let myWords =  takeWhile (not . null) . evalState (repeatM $ modify (dropWhile isSpace) >> State (break isSpace)) in myWords "  there are some   words  here.  "
05:44:04 <lambdabot>   ["there","are","some","words","here."]
05:44:44 <yitz> \o/
06:14:50 <metaperl> does the empty list satisfy this type signature [a]? How about this one [[a]]
06:15:00 <metaperl> psykotic: hi
06:15:10 <sepp2k> metaperl: Yes and yes.
06:15:11 <arw_> metaperl: yes it does. no it doesn't.
06:15:17 <metaperl> lol
06:15:23 <arw_> sepp2k: yes?
06:15:55 <arw_> @type [[[[[]]]]
06:15:56 <lambdabot> parse error (possibly incorrect indentation)
06:16:01 <sepp2k> arw_: If you have a function accepting a list of lists as its argument, you can surely pass it the empty list, no?
06:16:07 <Robbb> here's a strange one. I have a type "Term" that is an instance of show. So I can print it. But I get an error for trying to print things of type "IO Term". Now sure how to define this as showable.
06:16:11 <arw_> sepp2k: right.
06:16:11 <shapr> y0 metaperl, wassup?
06:16:21 <arw_> sepp2k: yes, you are right.
06:16:32 <sepp2k> > [] :: [[a]]
06:16:33 <lambdabot>   []
06:16:35 <arw_> @type [[[[]]]]
06:16:36 <lambdabot> forall a. [[[[a]]]]
06:16:42 <psykotic> [] is not a single value
06:16:55 <Robbb>  here's a strange one. I have a type "Term" that is an instance of show. So I can print it. But I get an error for trying to print things of type "IO Term". Now sure how to define this as showable.
06:17:06 <ben> An IO Term is not a Term, and it does not contain a Term.
06:17:14 <metaperl> psykotic: i just wanted to thank you for commenting in my street dance reddit (on the video where that guy did the knee drop :)
06:17:46 <metaperl> shapr: hi. i want to apologize for some of the negative things I said about haskell earlier
06:17:49 <theorbtwo> You could define an instance for IO Term... but you'd have to actually exeute the IO wrapper to get a Term out of it.
06:17:49 <Robbb> Actually, the IO Term that I am trying to print does contain a term.
06:17:54 <psykotic> metaperl: link? i forgot
06:18:08 <shapr> metaperl: Er, what did you say?
06:18:10 <amuller> Hello! How do you convert an INT into an INT64?
06:18:29 <ben> Robbb: "IO Term" is a function, really.
06:18:29 <metaperl> psykotic: http://www.reddit.com/r/streetdance/
06:18:32 <Robbb> So, when I have something that is an IO String, I can print it.
06:18:35 <ClaudiusMaximus> @quote fromIntegral
06:18:35 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
06:18:40 <metaperl> shapr: well... in that case.. nothing! (grin)
06:19:04 <metaperl> oh, shapr I'm concerned about planet haskell
06:19:14 <psykotic> metaperl: that was Sykotik. you can see there many ways to misspell that word :)
06:19:16 <metaperl> it seems there are 2types of planet sites
06:19:20 <Botje> amuller: fromIntegral
06:19:24 <arw_> http://www.haskell.org/hoogle/?hoogle=Int+-%3E+Int64
06:19:43 <Robbb> I'm confused here. How do I define an instance of show for IO Term?
06:19:48 <ben> Robbb: You do not
06:19:59 <ben> No one defines instances of show for IO anything
06:20:09 <metaperl> in some planet sites, they allow posts on any topic.. on others they stay focused on the topic
06:20:10 <Botje> > print
06:20:11 <lambdabot>   {()-><IO ()>}
06:20:25 <Robbb> But GHCi can print things of IO String or IO Int....
06:20:33 <Botje> Robbb: you define an instance of Show Term, and then you do print =<< (whatever generates an IO Term)
06:20:41 <ben> Robbb: No, it executes them and then prints the resulting String or Int
06:21:56 <metaperl> shapr: you arent mad at me, are you?
06:22:38 <Botje> @get-shapr
06:22:38 <lambdabot> shapr!!
06:22:38 <shapr> metaperl: no, why would I be mad at you?
06:22:43 <Botje> heh :)
06:22:53 <ben> My, I hope I was not too unhelpful
06:23:09 <shapr> metaperl: Even you if you hated Haskell with a passion I wouldn't be mad at you.
06:23:23 <shapr> Haskell /= shapr, ya know?
06:23:58 <shapr> Now if you hated unicycling, I might have to show up at your house with a baseball bat.
06:24:02 * shapr is just joking...
06:24:25 <amuller> thank you BotJe. Actually I was using it but scion-load gave me an error. When I compiled everything it was OK :)
06:24:59 <metaperl> well, I like the clothes I wear... I dont want them insulted. I like the car I drive. I dont want them criticized... but OK, let's forget that... I have a big blog post I want to write up, but thre are so many outlets on haskell ... the cafe, comp.lang.haskell....
06:26:17 <sinelaw> Alpounet, updated test to show images
06:26:35 <Alpounet> great
06:27:24 <shapr> I don't really care who insults stuff about me. It's like if someone said "Your mother is stupid." to me. I would think, "She has a master's degree, and she's changed my viewpoint many times with insightful comments, I don't believe them."
06:28:09 <metaperl> well that's good.
06:28:46 <yitz> shapr: how much leverage can you get on a baseball bat while on a unicycle?
06:28:57 <shapr> In general, I'm too busy doing cool stuff to get insulted.
06:29:54 <shapr> yitz: Quite a bit, I weigh ~240. But I'd probably fall off once I hit something with a baseball bat. I invite you to show up with a digicam and we'll document this.
06:31:10 <yitz> shapr: interesting, what angle to the wheel would produce the least destabilization.
06:31:10 <Robbb> No, this isn't working. I have a variable of type "IO Term". Now Term is an instance of Show. I want to be able to, in GHCi, to print that variable. I get an error that things of "IO Term" are not instances of show. It's not clear what to do here to be able to view it.
06:32:41 <yitz> shapr: this scenario *must* be added to lambdabot's @slap repertoire.
06:32:45 <ben> Robbb: Works for me.
06:32:46 <Botje> Robbb: print =<< (whatever generates an IO Term)
06:32:46 <shapr> hehe
06:33:09 <shapr> yitz: 45 degrees front, not quite jousting, and not straight to the side.
06:33:18 <sepp2k> Robbb: pastebin your code and the ghci session where you try to print the term
06:33:23 <Botje> Robbb: or you can do "t <- (whatever generates an IO Term)" and then just evaluate t
06:34:10 <sepp2k> Just typing "expression that evaluates to an IO Term" into ghci should be enough.
06:34:27 <yitz> shapr: you would synchronize the swing with the pedal thrusts to get maximum gyro effect. how accurately you time that would affect the optimal angle.
06:35:02 <Robbb> parseTerm :: Parser (IO Term)
06:35:04 <Robbb> parseTerm = whitespace $ try (parseVar   <|>
06:35:06 <Robbb>                               parseStruc)
06:35:10 <Robbb> readTerm1 :: String ->  ThrowsError (IO Term)
06:35:12 <Robbb> readTerm1 str = case parse parseTerm "term" str of
06:35:14 <Robbb>     Left err -> throwError $ Parser err
06:35:16 <Robbb>     Right val -> return val
06:35:20 <Robbb> fromRight :: ThrowsError a -> a
06:35:22 <Robbb> fromRight (Right val) = val
06:35:26 <Robbb> readTerm = fromRight . readTerm1
06:35:28 <Robbb> print =<< readTerm "a"
06:35:32 <Robbb> <interactive>:1:10: Not in scope: `readTerm'
06:35:39 <theorbtwo> Robbb: hpaste.org!
06:35:49 <Robbb> what is hpaste.org?
06:36:00 <sepp2k> Robbb: It's a pastebin.
06:36:11 <theorbtwo> Robbb: Somewhere you can go to paste things into.  It'll give you a URL to give to the channel, rather then spamming it.
06:36:12 <sepp2k> It's where you paste your stuff so you don't spam the channel.
06:36:55 <sepp2k> Robbb: Also the error message says, that you haven't actually loaded the file that you defined readTerm in.
06:37:07 <Robbb> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23906
06:37:17 <Robbb> @sepp2K: yes, I have.
06:37:17 <lambdabot> Unknown command, try @list
06:37:37 <Robbb> sepp2k: yes, I have loded the file.
06:38:19 <Robbb> sepp2k: sorry about pasting all the code to the channel.
06:40:41 <Robbb> ?
06:40:51 <shapr> !
06:43:28 <Robbb> I see. fromRight needs to be redefined as type ThrowsError (IO a) -> (IO a)
06:44:10 <sepp2k> No, that's fine.
06:46:35 <zygoloid> Robbb: i'm guessing you have 'type ThrowsError a = Either something a' somewhere?
06:49:25 <roconnor> @src (>>=) Identity
06:49:25 <lambdabot> Source not found. Maybe you made a typo?
06:49:28 <roconnor> @src >>= Identity
06:49:29 <lambdabot> Source not found. :(
06:49:40 <sinelaw> @src (>>=) :: Identity
06:49:40 <lambdabot> Source not found. That's something I cannot allow to happen.
06:50:00 <zygoloid> x >>= f = f (runIdentity x)
06:50:20 <Robbb> ok, problem fixed... now to the next one
06:50:50 <Robbb> thanks, by the way
06:52:08 * zygoloid thinks Robbb was raised with one of those hold-down-the-button-to-transmit walkie-talkies
07:02:07 <gwern> zygoloid: those were so awesome
07:02:14 * gwern over and out
07:35:49 <jmcarthur> Alpounet: pong
07:36:02 <Alpounet> have you seen my last comment ?
07:36:05 <jontore> Hi, is there a way to lift more then one lever without doing something like lift $ lift
07:36:20 <jmcarthur> Alpounet: not yet. i'll look now
07:37:02 <jmcarthur> Alpounet: ah nice
07:37:15 <jmcarthur> Alpounet: yeah i've been too lazy to work around the -fvia-c thing
07:38:14 <jmcarthur> Alpounet: i haven't yet had an issue. none of the packages i've installed have specified -fvia-c yet
07:39:02 <Alpounet> ok
07:39:55 <jmcarthur> that is a very nice speedup on HNN due to LLVM, Alpounet
07:40:18 <Alpounet> yeah
07:40:21 <Alpounet> I was really impressed
07:40:24 <Alpounet> I didn't expect x3
07:40:39 <jmcarthur> Alpounet: have you tried ghc head without -fllvm?
07:40:41 <byorgey> @tell manjunath Actually, when I get a round tuit, I am planning to put out an updated, standalone version of the Typeclassopedia
07:40:41 <lambdabot> Consider it noted.
07:40:49 <jmcarthur> to see how much is due to llvm and how much is due to HEAD?
07:41:06 <Alpounet> jmcarthur, yeah, it was around 160 ms
07:41:13 <jmcarthur> ah nice
07:41:21 <Alpounet> llvm is doing its job, yes :)
07:42:28 <sinelaw> ok now my thing works fast too :)
07:42:38 <sinelaw> i have an inherent problem with types though, if i want safety
07:43:02 <sinelaw> some opencv functions require images with certain depths or number of channels
07:43:15 <sinelaw> so if you connect them wrongly, you get a runtime error
07:44:12 <jmcarthur> you can't parameterize it with depths and channels?
07:44:59 <sinelaw> yes but it will hurt when those things DONT matter
07:45:16 <jmcarthur> why? just leave those functions polymorphic in those parameters
07:45:21 <sinelaw> hmm yeah
07:49:13 <sinelaw>  edge detection :)
07:49:30 <sinelaw> and here's my program:
07:49:32 <Saizan> jontore: http://blog.sigfpe.com/2010/02/tagging-monad-transformer-layers.html
07:49:43 <Alpounet> sinelaw, yeah the capture was slow earlier
07:49:46 <sinelaw> window . canny . camera
07:49:47 <Alpounet> fixed now ?
07:52:59 <sinelaw> Alpounet, yes, now pushed :)
07:53:16 <Alpounet> yeah
07:53:21 <sinelaw> you'll need also to update HOpenCV
07:54:21 <Alpounet> already done
07:54:23 <Alpounet> haha, it's nice
07:54:54 <sinelaw> i like the code
07:54:55 <sinelaw> http://github.com/sinelaw/cv-combinators/blob/master/src/Test.hs
07:55:04 <sinelaw> trivial :)
07:55:57 <jmcarthur> that's a lot of long qualified imports
07:56:04 <Alpounet> yeah
07:56:13 <Alpounet> main is really beautiful :)
07:56:23 <jmcarthur> not that it's bad, it just hurts my eyes
07:56:33 <jmcarthur> the code structure itself is very nice
07:56:44 <Entroacceptor> jmcarthur: I agree, imports should be qualified by default
07:56:57 <sinelaw> i'm very happy with this :)
07:57:12 <sinelaw> a lot of room for improvement though
07:57:15 <jmcarthur> Entroacceptor: i have mixed feelings about that
07:57:25 <zygoloid> looks like runUntil would be nicer infix
07:57:39 <sinelaw> zygoloid, actually that was my original intention. forgot to use it :)
07:57:54 <sinelaw> it takes 3 args though. i'll fix that
07:57:55 <zygoloid> (window . canny . camera) `runUntil'` testKey where runUntil' = flip runUntil ()
07:58:12 <jmcarthur> Entroacceptor: it's not like the compiler will just randomly pick one if you have multiple functions with the same name imported
07:58:16 <zygoloid> it's not obvious what it's running until as it is
07:59:10 <Entroacceptor> but I as a noob user get easily confused. 'WTH does this come from???'
07:59:18 <sinelaw> yeah
08:00:00 <jmcarthur> Entroacceptor: tool support can fix that. i don't think the program files themselves should be cluttered up with stuff just to help noobies
08:00:36 <jmcarthur> documentation is one thing, but noob friendliness often gets in the way more than it helps
08:01:18 <jmcarthur> i do think there are cases where qualified imports are informative and helpful, but to do it universally would be a big burden when trying to just read the code
08:01:30 <zygoloid> there's a lot about haskell that tool support can fix. it'll be lovely when we finally have that support :) SoC projects?
08:01:48 <jmcarthur> could just extend scion with some things :)
08:01:56 <sinelaw> zygoloid, i'm using your suggestion
08:02:14 <metaperl_> Does anyone understand exactly what this real world haskell problem is looking for .... i dont want to look at the comments - Write a program that transposes the text in a file. For instance, it should convert "hello\nworld\n" to "hw\neo\nlr\nll\nod\n".
08:02:15 <jmcarthur> i feel weird promoting scion though because i haven't even used it yet. maybe i should shut my mouth until i'm sure i like it
08:02:23 <Entroacceptor> jmcarthur: so you're saying I can't write haskell with vim? ;)
08:02:31 * metaperl_ wonders what scion is
08:02:44 <jmcarthur> Entroacceptor: why not? vim is a customizable environment
08:03:19 <jmcarthur> metaperl_: something you can rig up to your editor/IDE for working with haskell
08:03:21 <maltem> We just need to find one unique, easy to remember letter for each module out there
08:03:31 <jmcarthur> yeah, all 26 modules
08:03:34 <jmcarthur> wait
08:03:50 <cebewee> metaperl_: "transpose" like "transposing a matrix"
08:03:53 <aavogt> @hoogle transpose
08:03:53 <lambdabot> Data.ByteString transpose :: [ByteString] -> [ByteString]
08:03:53 <lambdabot> Data.List transpose :: [[a]] -> [[a]]
08:03:53 <lambdabot> Data.ByteString.Char8 transpose :: [ByteString] -> [ByteString]
08:03:56 <Entroacceptor> there's greek letters, too
08:04:05 <metaperl> jmcarthur: I see... I pretty much use emacs
08:04:14 <jmcarthur> metaperl: me too
08:04:15 <maltem> jmcarthur, we'd need a more open perspective, culturally
08:04:19 <metaperl> cebewee: but a matrix is square
08:04:20 <jmcarthur> metaperl: scion has emacs integration too
08:04:29 <cebewee> metaperl: not necessarily
08:04:36 <pozic> Scion is vapourware.
08:04:46 <jmcarthur> pozic: it is?
08:04:46 <aavogt> well there's a question of what you do with ragged ends
08:04:51 <metaperl> I dont understand how some rows of the sample output have 3 chars when there were only 2 lines
08:04:55 <jmcarthur> :(
08:05:03 <pozic> jmcarthur: it is.
08:05:08 <jmcarthur> dang
08:05:09 <aavogt> > transpose [replicate 10 'a',replicate 3 'b']
08:05:10 <lambdabot>   ["ab","ab","ab","a","a","a","a","a","a","a"]
08:05:23 <metaperl> > [replicate 10 'a',replicate 3 'b']
08:05:24 <lambdabot>   ["aaaaaaaaaa","bbb"]
08:05:31 <pozic> It is like all tools for Haskell, an academic project waiting to be abandoned.
08:05:39 <aavogt> > transpose [replicate 3 'a',replicate 10 'b']
08:05:40 <lambdabot>   ["ab","ab","ab","b","b","b","b","b","b","b"]
08:05:43 <metaperl> did HiDE ever get finished?
08:05:49 <jmcarthur> pozic: you're so positive
08:05:54 <metaperl> lol
08:05:59 <cebewee> metaperl: in the example output you've given, each row has exactly two characters? (do not get confused by the \n)
08:06:03 <Alpounet> metaperl, you may rather want to check out leksah
08:06:06 <pozic> jmcarthur: I prefer realistic, but positive is ok too.
08:06:17 <pozic> metaperl: please don't waste your time.
08:06:31 <pozic> metaperl: leksah is in the same league/.
08:06:33 <jmcarthur> Alpounet: no self-respecting emacs user would switch to leksah ;)
08:06:40 <metaperl> cebewee: pj tjat
08:06:41 <Alpounet> I know
08:06:41 <metaperl> s rogjt
08:06:43 <Alpounet> that's why I don't
08:06:45 <Alpounet> but still
08:06:48 <pozic> jmcarthur: if leksah would actually work, I would switch.
08:07:07 <jmcarthur> pozic: if leksah was something that i coudl just run emacs in, i would consider it
08:07:11 <Alpounet> for people wanting an IDE, with all the graphical stuffs and all, it's not a bad choice.
08:07:19 <jmcarthur> or something i could run in emacs
08:07:22 <pozic> Anyway, I think it is pure malice to direct people to broken tools.
08:07:30 <sinelaw> ok compare this:
08:07:30 <sinelaw> http://github.com/sinelaw/HOpenCV/blob/master/src/Test.hs
08:07:32 <sinelaw> with this:
08:07:36 <sinelaw> http://github.com/sinelaw/cv-combinators/blob/master/src/Test.hs
08:07:41 <sinelaw> they do the same thing
08:07:43 <Alpounet> heh
08:07:47 <k23z__> lol I read an article saying that monads are like burritos =)))
08:07:56 <Entroacceptor> yum
08:07:58 <jmcarthur> sinelaw: a pretty easy choice there
08:08:00 <k23z__> any thoughts on the monads being like burritos ?
08:08:04 <k23z__> Entroacceptor: :)
08:08:16 <jmcarthur> k23z__: monads are like monads
08:08:26 <jmcarthur> kind of
08:08:28 <sinelaw> yip
08:08:32 <sinelaw> should hackage this stuff?
08:08:35 <Botje> except when they're not
08:08:36 <metaperl> lol @ Entroacceptor
08:08:38 <sinelaw> or wait until it's a little more mature
08:08:42 <Alpounet> k23z__, http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
08:08:51 <sinelaw> i'll add some more image processing primitives first i think
08:09:01 <jmcarthur> wasn't there a nice unicorn metaphor for monads?
08:09:06 <jmcarthur> ;)
08:09:17 <sinelaw> @quote monad
08:09:18 <metaperl> "A truly wise man does not play leapfrog with unicorns"
08:09:18 <lambdabot> Pseudonym says: Smart programmers naturally write monadic code, even if they don't realise it.
08:09:22 <sinelaw> @quote monad
08:09:22 <lambdabot> <mm_freak1work> says: not to be or to be and (not to be or to be and (not to be or to be and...)), that is the list monad
08:09:31 <jmcarthur> @quote unicorn
08:09:31 <lambdabot> v_ says: Haskell shits rainbows, monads and unicorns
08:09:40 <jmcarthur> @quote unicorn
08:09:40 <lambdabot> v_ says: Haskell shits rainbows, monads and unicorns
08:09:40 <zygoloid> i have a lovely monad metaphor involving rings tied together with pieces of string
08:09:43 <jmcarthur> oh well
08:09:44 <yitz> sinelaw: this is not fair. the combinator version just imports a module that does all the work. you can do that with monads, too.
08:09:56 <Alpounet> byorgey, ping
08:10:02 <k23z__> metaperl: did you read that article that monads are like burritos
08:10:04 <sinelaw> yitz, i'm doing it with monads in the second version.
08:10:12 <sinelaw> yitz, but yes.
08:10:15 <k23z__> it seems everybody wants to explain monads these days
08:10:18 <sinelaw> of course, that's the whole idea
08:10:26 <sinelaw> @quote burrito
08:10:26 <lambdabot> No quotes match. I feel much better now.
08:10:35 <Botje> monads are a meme :]
08:10:51 <metaperl> k23z__: I did not. I am working through "Real World Haskell" --- my nose is to the grindstone and I have my blinders on... I shall not listen to false testimonies on how to learn haskell at the moment. my faith is in the solid rock of RWH
08:10:51 <Alpounet> k23z__, you should read the article I linked to
08:11:00 <jmcarthur> monads are unicorn burritos
08:11:08 <metaperl> k23z__: yes, I've noticed a trend on reddit of people doing that
08:11:17 <zygoloid> no, nomads are burrito unicorns!
08:11:26 <metaperl> haskell people explain monads. python people write web frameworks
08:12:02 <Entroacceptor> yes, I think I'll stick with django, it's got magical ponies
08:12:11 <zygoloid> with horns?
08:12:11 <yitz> sinelaw: i always like using combinators where possible. but i'm always haunted by questions like this: what if someday, your boss/customer says: ok, great, now add a progress bar.
08:12:14 <k23z__> Alpounet:  haha that article is awesome
08:12:22 <ben> metaperl: Some crazy ones write web monads!
08:12:35 * jmcarthur likes web monads
08:12:45 <Phyx-> @google ffi primer
08:12:56 <Phyx-> !google ffi primer
08:12:57 <lambdabot> http://www.pnas.org/content/88/7/2815.full.pdf
08:12:58 <lambdabot> Title: cache:http://www.pnas.org/content/88/7/2815.full.pdf - Google Search
08:13:19 <yitz> ben: are "web monads" the ones that have been laying around in the attic for a few years?
08:13:29 <sinelaw> yitz, yip, it's a challenge to design things to be general enough for surprise attacks but specific enough to be of use
08:13:51 <Phyx-> wow, that link doesn't even mention ffi
08:13:52 <Phyx-> hahaaha
08:13:53 <jmcarthur> yitz: web monads are unicorn burritos that have been laying around in the attic for a few years
08:13:59 <yitz> yuck
08:14:02 <Phyx-> go lamdabot
08:14:22 <yitz> @vixen go lambdabot!
08:14:23 <lambdabot> You think this is a botiecall??
08:14:25 <k23z__> my cock is like a burrito lol
08:14:44 <k23z__> it's like saying "quantum physics for illiterates"
08:14:54 <sinelaw> @remember jmcarthur web monads are unicorn burritos that have been laying around in the attic for a few years
08:14:54 <lambdabot> It is forever etched in my memory.
08:15:03 <fax> "C for dummies"
08:15:04 <k23z__> the same is "monads for people who don't know how to program or don't know how to count"
08:15:06 <jmcarthur> great
08:15:08 <k23z__> fax: yeah exactly !
08:15:18 <sinelaw> "monads for nomads"
08:15:22 <k23z__> hhahahhahaa
08:15:30 <Saizan> k23z__: http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
08:15:41 <k23z__> Saizan: have finished reading that 2minutes ago
08:16:08 <SamB_XP> hmm ... there was a REALLY crazy book title at the Microcenter in the foyer ...
08:16:16 <SamB_XP> "Wii for dummies"
08:16:35 <zygoloid> well, d'uh
08:16:35 <macron> hi, I'd like to make the version in the cabal file for my package available to binary, so as to implement a --version flag without having to hardcode the version number in the source. Is this at all possible?
08:16:39 <k23z__> or "monads for illiterate pregnant women"
08:16:49 <byorgey> Alpounet: pong?
08:17:23 <Alpounet> byorgey, how do you get haskell syntax highlighting on a .wordpress.com blog ?
08:17:25 <Saizan> macron: yes, you can use the Paths_$pkg module that's generated by Cabal
08:17:43 <seit> I'm looking for a better way to express this:  given an input list 'xs', return a 5 tuple with (take (length xs - 4) xs, 4th from last xs, 3rd from last xs, 2nd from last xs, last xs)
08:17:45 <jmcarthur> woah i didn't know cabal did that
08:17:48 <seit> my first attempt is at: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=23907#a23907
08:17:55 <byorgey> Alpounet: I use the BlogLiterately package
08:17:59 <byorgey> @hackage BlogLiterately
08:17:59 <lambdabot> http://hackage.haskell.org/package/BlogLiterately
08:18:06 <seit> hmm, the formatting of my text version is pretty bad.  Sorry
08:18:12 <Alpounet> oh, nice, thank you byorgey !
08:18:19 <byorgey> it's really fantastic, you write your post as literate Haskell using markdown syntax, then it uploads it for you
08:18:26 <Saizan> macron: when you do cabal build or cabal install it gets generated under dist/build/autogen
08:18:28 <byorgey> with syntax highlighting and everything.
08:18:42 <jmcarthur> ooh
08:18:44 <byorgey> it has changed my life.
08:18:50 <seit> I'm trying to do that without using the length function
08:19:14 <fax> sei, why don't you write the way you just explained it?
08:19:28 <Alpounet> I understand
08:19:50 <Alpounet> it will change mine
08:19:53 <Alpounet> thank you again
08:20:10 <macron> Saizan: aha, thanks! I had overlooked that the version is stored in there. Doesn't seem to be documented.
08:20:17 <seit> fax: I'd like to avoid the length function, and I am trying to see if there are better ways to do it than my hpaste'd version
08:20:33 <jmcarthur> now i'm eager to try BlogLiterately
08:21:01 <fax> seit, my idea is to write it in the first very simple way you described it -- then try to calculate a better program by transforming that
08:21:39 <seit> fax, sounds good -- I'll see what else I can come up with
08:25:07 <Phyx-> is FFI still at 1.0?
08:25:12 <Phyx-> the specs
08:25:35 <SamB_XP> Phyx-: they're presumably still at whatever version number you saw last time you looked at the specs!
08:26:00 <Phyx-> SamB_XP: well, never looked at it before :P
08:26:31 <SamB_XP> Phyx-: I don't think *I've* ever seen more than one version, so ... it's probably still at whatever version you've found ;-P
08:26:45 <metaperl> > transpose "hello" "world"
08:26:45 <Phyx-> SamB_XP: I was just about to, but the original one was an addendum to Haskell 98, and I figured, since Haskell 2010 is out they might have revised it
08:26:46 <lambdabot>   Couldn't match expected type `[a]'
08:26:46 <lambdabot>         against inferred type `GHC.Types...
08:26:56 <metaperl> > Data.List.transpose "hello" "world"
08:26:57 <lambdabot>   Couldn't match expected type `[a]'
08:26:58 <lambdabot>         against inferred type `GHC.Types...
08:27:06 <metaperl> @hoogle transpose
08:27:07 <lambdabot> Data.ByteString transpose :: [ByteString] -> [ByteString]
08:27:07 <lambdabot> Data.List transpose :: [[a]] -> [[a]]
08:27:07 <lambdabot> Data.ByteString.Char8 transpose :: [ByteString] -> [ByteString]
08:27:30 <metaperl> > Data.List.transpose ["hello", "world"]
08:27:30 <lambdabot>   ["hw","eo","lr","ll","od"]
08:27:32 <SamB_XP> Phyx-: oh, well, it's slightly revised by the renaming of modules in the implementation ...
08:27:43 <SamB_XP> ... to fit into the hierarchical naming
08:27:55 <SamB_XP> no idea if that's in the Haskell 2010 standard somehow or not
08:28:32 <Phyx-> SamB_XP: aha, well if that's it no prob them. I already know it quite well, but never read the specs, thought it might be a good idea :) before I continue on this implementation
08:28:52 <SamB_XP> Phyx-: implementation of what ?
08:28:55 <SamB_XP> Haskell ?
08:29:05 <SamB_XP> or some binding?
08:30:23 <Phyx-> A tool i'm using to automate normal hs function -> exportable code, e.g. generate the right storable instances, c structs etc and linking it all up into a shared lib
08:30:31 <sinelaw> is there any way to disable this annoying warning?
08:30:32 <sinelaw> Warning: Defaulting the following constraint(s) to type `Integer'
08:30:42 <metaperl> why is there an ubuntu Haskell Platform but not Debian? Should I switch from debian/testing to ubuntu?
08:30:47 <sinelaw> besides explicitly specifying the type
08:30:48 <Phyx-> but i'm making a few assumptions, and it's better to check them :)
08:31:28 <tensorpudding> the version of ghc in debian might be behind ubuntu
08:31:40 <Phyx-> it's up to date last checked
08:32:02 <Phyx-> metaperl: the short answer would be I would guess that no one bothered to make a build
08:32:48 <tensorpudding> according to the status indicator, all the libraries in the platform are available in debian at versions equal to or greater than the versions in the current platform
08:34:30 <waterlaz> omg, leksah sucks
08:35:16 <waterlaz> it ends up eating all my memory and CPU time after like 15 seconds of use
08:35:22 <cebewee> metaperl: there is haskell-platform in unstable
08:35:52 <tensorpudding> anyway, you could install the haskell platform libraries by hand using cabal
08:35:54 <metaperl> cebewee: I see, but unstable is not a safe thing to use is it? I use testing
08:36:19 <metaperl> tensorpudding: it was a lot of work to build ghc from the linux binary and then the whole platform... but I did it
08:36:34 <metaperl> on testing.... doesanyone here run unstable?
08:36:37 <tensorpudding> there is a binary install, and it requires very little work
08:36:39 <cebewee> metaperl: I use testing + some stuff from unstable. Works good for me
08:37:01 <tensorpudding> if you don't have an x86 processor i suppose you'd have to compile it though
08:37:07 <metaperl> tensorpudding: the binary install takes a _lot_ of work, beleive me... I used it as the base.... missing libs, and problems with the platform itself
08:37:26 <metaperl> oh cebewee you modified your sources.list to do that?
08:38:00 * eevar runs testing on his headless server. 6.8 only :/ -- of course I use arch on my dev box
08:38:02 <cebewee> metaperl: yep, added the unstable repositories.
08:38:03 <tensorpudding> the binary install of ghc only requires a configure, make, make install
08:38:31 <cebewee> metaperl: and instructed apt to use testing preferably. see http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23908
08:38:39 <metaperl> cebewee: was that documented on the haskell platform webpage somewhere? how to do that? what to add? I would like to know. I typically use the synaptic package manager
08:39:03 <tensorpudding> don't upgrade to unstable just so that you can use the haskell-platform
08:39:16 <tensorpudding> that's my advice
08:39:27 <Saizan> yeah, just use the generic linux binary
08:40:27 <metaperl> yeah, I already built it... but ubuntu just seems to be gaining momentum over debian proper
08:40:27 <tensorpudding> there's a sparc binary ghc too
08:40:42 <yitz> when i was using testing, i always just pinned all the libghc6 stuff to unstable. worked fine for me.
08:40:53 <Saizan> metaperl: why built? not supported arch?
08:41:01 <yitz> now i was forced back to stable. haven't tried it yet. gulp.
08:41:21 <metaperl> yitz: you pinned it? hmm  .. Saizan the webpage says even for binaries you have to do a make and make install
08:41:26 <tensorpudding> i use debian stable, but i have all of ghc and the libraries installed by hand
08:41:31 <metaperl> and you have to run an apt-get command but that wasfor ubuntu...
08:41:47 <Saizan> metaperl: i just do ./configure and make install
08:41:49 <metaperl> libGLU for instance has changed names between ubuntu and debian
08:41:56 <Saizan> metaperl: not having to build anything
08:42:01 <tensorpudding> the make doesn't actually compile anything
08:42:18 <metaperl> I see... it built and linked for hours on my virtual machine.. but it all runs now
08:42:26 <tensorpudding> compiling it from source is really hard
08:42:42 <tensorpudding> because you have to bootstrap it from C
08:42:58 <tensorpudding> unless you already have a GHC installed
08:42:59 <Saizan> well, you can use the binary to compile it :)
08:43:46 <Saizan> metaperl: yeah, if you end up compiling it you need a fair amount of ram
08:44:04 <Saizan> ~1GB to be safe
08:44:06 <metaperl> ah, yes, that's what happened. I had to bootstrap from C
08:44:12 <yitz> i found i needed a separate entry for each haskell-related package, and there turned out to be quite a few of them. but it was still a lot better than constantly building and rebuilding manually.
08:44:13 <metaperl> brand new virtualmachine
08:45:21 <tensorpudding> i like handling all of the haskell packages through cabal instead of the distro package manager
08:46:00 <jmcarthur> tensorpudding: me too, except when the package isn't on hackage but is in AUR, like gtk2hs
08:47:30 <tensorpudding> i compiled gtk2hs by hand i think
08:48:47 <metaperl> cebewee: I just have one other question. If a package exists in testing and unstable and testing has higher priority (e.g. ghc 6.8 is in testing and 6.10 unstable), then is there someway to choose the unstable version?
08:49:14 <Alpounet> -t option iirc
08:49:18 <metaperl> tensorpudding: I agree with you. Likewise, I like installing Perl modules via CPAN instead of debian apt-get
08:49:55 <pastorn> @hoogle (a,b) -> (b,a)
08:50:29 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
08:50:29 <lambdabot> Data.Graph.Inductive.Query.Monad mapSnd :: (a -> b) -> (c, a) -> (c, b)
08:50:29 <lambdabot> Data.Graph.Inductive.Query.Monad mapFst :: (a -> b) -> (a, c) -> (b, c)
08:50:33 <pastorn> @djinn (a,b) -> (b,a)
08:50:34 <lambdabot> f (a, b) = (b, a)
08:50:39 <pastorn> bah
08:50:44 <ksf> now that we've got llvm, we could ship a ghc bootstrap release as llvm assembly
08:50:53 <pastorn> @pl (\(a,b) -> (b,a))
08:50:53 <lambdabot> uncurry (flip (,))
08:50:56 <metaperl> reverse should be overloaded for tuples, no?
08:51:02 <metaperl> reverse (a,b)
08:51:31 <Jafet> Tip: write perl code in perl.
08:51:42 <Jafet> This concludes my helpful tip.
08:51:49 <fax> I want one
08:53:48 <pastorn> @pl (\(x,y) (z,w) -> compare y w)
08:53:48 <lambdabot> (. snd) . compare . snd
08:58:48 <mm_freak_> > let myLength = sum . (1 <$) in myLength "test"
08:58:49 <lambdabot>   4
08:59:28 <fax> :t ($ 0) . ?compose . map (+1)
08:59:29 <lambdabot> forall a b a1. (Num a, ?compose::[a1] -> a -> b, Num a1) => [a1] -> b
09:00:06 <mm_freak_> :t sum . (>> [1])
09:00:07 <lambdabot> forall a a1. (Num a) => [a1] -> a
09:00:39 <fax> :t ($ 0) . ?compose . map (const (+1))
09:00:40 <lambdabot> forall a b a1 a2. (Num a, ?compose::[a1 -> a1] -> a -> b, Num a1) => [a2] -> b
09:02:00 <mm_freak_> > 1 `mappend` 2
09:02:01 <lambdabot>   Ambiguous type variable `t' in the constraints:
09:02:01 <lambdabot>    `GHC.Num.Num t' arising ...
09:02:05 <mm_freak_> > 1 `mappend` 2 :: Int
09:02:06 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Int)
09:02:06 <lambdabot>    arising from a use of...
09:02:15 <mm_freak_> > 1 `mappend` 2 :: Plus Int
09:02:16 <lambdabot>   Not in scope: type constructor or class `Plus'
09:02:26 <mm_freak_> what was that type constructor again?
09:02:29 <mm_freak_> > 1 `mappend` 2 :: Sum Int
09:02:30 <lambdabot>   No instance for (GHC.Num.Num (Data.Monoid.Sum GHC.Types.Int))
09:02:30 <lambdabot>    arising fr...
09:02:40 <mm_freak_> > Sum 1 `mappend` Sum 2 :: Sum Int
09:02:41 <lambdabot>   Sum {getSum = 3}
09:02:46 <yitz> @type uncurry . flip . curry $ id
09:02:47 <lambdabot> forall a b. (a, b) -> (b, a)
09:02:56 <yitz> metaperl: ^^
09:03:16 <yitz> @type uncurry $ flip (,)
09:03:17 <lambdabot> forall a b. (a, b) -> (b, a)
09:03:38 <yitz> (,) is just sugar for curry id
09:04:09 <fax> :t curry . const
09:04:10 <lambdabot> forall a b c. c -> a -> b -> c
09:04:15 <metaperl> I dont know the "^^" was relevant to yitz
09:04:25 <fax> :t curry . const . id
09:04:26 <lambdabot> forall a b a1. a1 -> a -> b -> a1
09:04:36 <yitz> metaperl: my feeble attempt at an arrow pointing to what i wrote on the previous line
09:05:11 <yitz> metaperl: you said that "reverse" should work for tuples
09:05:12 <metaperl> I think pastorn had the interest in reversing a tuple, I was just making a statement about overloading functions
09:05:18 <metaperl> yitz: yes
09:05:19 <metaperl> I did
09:06:17 <pastorn> metaperl: nah, i was just checking if there was some simple way to do it...
09:06:17 <yitz> in haskell there is no relationship between lists and tuples, they are very different animals. and it's easy to flip a tuple without any special function.
09:06:27 <pastorn> maybe from the arrows library or whatever...
09:06:49 <yitz> you know, i suppose reverse for lists also has a very short definition. but somehow, it makes you think more. it seems to be doing more.
09:07:20 <pastorn> yitz: list reversal in haskell is O(n)
09:07:24 <yitz> ah, yes, C.A would be the place to put it if there were to be such a thing.
09:07:28 <pastorn> since it's singly linked lists
09:07:34 <yitz> yes
09:07:48 <yitz> but it shouldn't be called reverse - that would be confusing.
09:07:58 <pastorn> what should it be called?
09:08:20 <pastorn> and why should the name reverse not be used? is it messing with your namespace?
09:08:41 <yitz> i think "uncurry $ flip (,)" has a certain ring to it
09:08:58 <yitz> pastorn: no, it's just not the same operation
09:08:59 <pastorn> no, that's 'swap'
09:09:10 <pastorn> @type reverse
09:09:13 <yitz> swap. hmm. i could live with that.
09:09:26 <lambdabot> forall a. [a] -> [a]
09:09:47 <yitz> oh are you talking about n-tuples?
09:10:02 <pastorn> i don't know what you're talking about...
09:10:09 * pastorn goes back to coding
09:10:31 <yitz> about the suggestion to overload the name "reverse" to apply also to tuples.
09:10:48 <roconnor> @src swap
09:10:48 <lambdabot> Source not found. Do you think like you type?
09:11:37 <roconnor> @slap lambdabot
09:11:38 * lambdabot submits lambdabot's email address to a dozen spam lists
09:11:59 <shapr> heh
09:12:39 <fax> hi
09:13:17 <JoelMcCracken> so, crazy thing, but for some reason it seems that ghci now understand the "-" key as "m". Does this make any sense at all?
09:13:50 <monochrom> No. I cannot reproduce it.
09:13:58 <JoelMcCracken> hmm, actually, its happening to a few different keys
09:14:22 <shapr> Sounds like your terminal settings, or your keyboard map.
09:14:33 <JoelMcCracken> its only doing it in ghci, though
09:14:55 <shapr> Are you running ghci in a terminal window?
09:14:59 <JoelMcCracken> yep
09:15:35 <shapr> Is it the same in a different terminal window?
09:15:42 <monochrom> quit ghci but stay in the same terminal window. does it still happen?
09:16:08 <JoelMcCracken> yes
09:16:10 <HandheldPenguin> hmm getting an error when I run this... http://haskell.pastebin.com/H55VL9Lp
09:16:18 <HandheldPenguin> Couldn't match expected type `(String -> IO ()) -> String -> IO ()'
09:16:19 <HandheldPenguin>            against inferred type `IO ()'
09:16:27 <monochrom> Then it is the terminal window.
09:16:45 <ski> (reset the terminal ?)
09:17:34 <ski> HandheldPenguin : you want a `do' after `else'
09:17:58 <JoelMcCracken> 1-9 is "qrstuvwxy"
09:18:00 <JoelMcCracken> crazy
09:18:05 <ski> (and after `then', too, if you prefer consistency)
09:18:32 <fax> I prefer conspiracy
09:18:50 <HandheldPenguin> ah awesome
09:18:54 <HandheldPenguin> ski thanks, that was easy
09:19:00 * ski would probably opt for inconsistency, in this case
09:19:16 <monochrom> If you cat a binary file recently, some of the binary code may accidentally mean special code for the terminal to change mapping of character to displayed character.
09:19:34 <ski> (otoh, i'd usually add a `do' after each `=' if any clause has a `do' there .. i'm inconsistent like that)
09:19:44 <JoelMcCracken> a reset doesn't fix anything
09:20:35 <yitz> JoelMcCracken: d9 679 als9 g35 58s 049blem 285h d8s0la68ng 5h3 cha4ac534s?
09:20:40 <ski> maybe (*shudder*), terminate and resurrect the terminal ?
09:21:10 <JoelMcCracken> monochrom, if earlier you meant that I open a terminal window, run ghci, exit ghci, then check on the command prompt for wrongness? then no, it works fine once I go back to the command prompt
09:21:56 <monochrom> No, I do not mean open a new terminal window.
09:22:30 <jetxee> Hi! Does anyone know how to make auto-indentation right with Vim and Literate Haskell (bird-style)?
09:23:11 <edwardk> jextee: good luck. i've never seen it made to work
09:23:37 <JoelMcCracken> I'll try a restart
09:24:08 <JoelMcCracken> oh wow, it looks it was a funky setting from aquamacs
09:24:10 <JoelMcCracken> wtf
09:24:51 <yitz> JoelMcCracken: oh really? i use that. what should i avoid?
09:25:18 <edwardk> robb: you don't show (IO Term), you fmap Show over it to get an IO String
09:25:27 <JoelMcCracken> no idea, heh. I must have hit a crazy wrong key or something.
09:25:29 <jetxee> edwardk: unfortunately :-(
09:25:37 <edwardk> er whoa, that was a bit belated. i just realized my screen was scrolled all the way up =)
09:27:31 <zygoloid> > map (ap fromMaybe $ flip lookup (zip "123456789" ['q'..'y'])) "d9 679 als9 g35 58s 049blem 285h d8s0la68ng 5h3 cha4ac534s"
09:27:32 <lambdabot>   "dy vwy alsy gsu uxs 0tyblem rxuh dxs0lavxng uhs chatacusts"
09:27:41 <ben> bless you
09:28:31 <zygoloid> > map (ap fromMaybe $ flip lookup (zip "1234567890" "qwertyuiop")) "d9 679 als9 g35 58s 049blem 285h d8s0la68ng 5h3 cha4ac534s"
09:28:32 <lambdabot>   "do yuo also get tis problem with displaying the characters"
09:29:05 <yitz> zygoloid: ok, that's not fair, i did it by hand
09:29:12 <jmcarthur> Alpounet: HA! opengl 4 is out today. now i have more to learn
09:29:40 <Alpounet> jmcarthur, that also means we're not even close to getting a first draft of your lib :D you will rethink the whole thing
09:29:43 <Alpounet> but that's better actually
09:29:47 <p_l> jmcarthur: do we finally get functional API?
09:29:58 <jmcarthur> p_l: i haven't checked yet
09:30:39 <jmcarthur> another type of shader!
09:30:49 <Alpounet> heh
09:30:54 <jmcarthur> now there are four
09:31:04 <p_l> jmcarthur: I suspect not...
09:31:09 <Alpounet> jmcarthur, gotta leave now but let's talk about that later, that's interesting
09:31:13 <jmcarthur> p_l: yeah i'm doubtful
09:31:25 <p_l> OpenGL 3.0 was already supposed to have functional-style, threadsafe API
09:31:27 <jmcarthur> we now have tessellation shaders in opengl
09:31:35 <jmcarthur> p_l: yeah but they changed that
09:33:59 <mreh> > 256 :: Word8
09:34:00 <lambdabot>   0
09:34:04 <mreh> > 255 :: Word8
09:34:05 <lambdabot>   255
09:35:37 <yitz> > maxBound :: Word8
09:35:38 <lambdabot>   255
09:35:45 <jmcarthur> snap, the tesselation shader comes in two parts, too. there's like 5 shader units now...
09:35:48 <yitz> > minBound :: Word8
09:35:49 <lambdabot>   0
09:39:51 <quicksilver> p_l: It's slightly more functional style in the sense that there is less mutation.
09:40:04 <quicksilver> small step.
09:40:08 <mreh> > round (255 * 1/2) :: Word8
09:40:09 <lambdabot>   128
09:56:56 <metaperl> is the real world haskell website down for anyone else?
09:57:06 <metaperl> http://book.realworldhaskell.org/
09:58:11 <bos> metaperl: IP address change
09:58:13 <tomh-> http://downforeveryoneorjustme.com/book.realworldhaskell.org/
09:58:25 <metaperl> oh interesting
09:58:36 <metaperl> tomh thanks for the link
09:59:25 <metaperl> ip numbers? :)
09:59:47 <metaperl> i'm on windows xp would repairing the ethernet clear the cache and find the new ip?
10:00:34 <dqd> No, it's a matter of the DNS record.
10:00:51 <metaperl> well my mozilla cache is being good to me right now
10:10:19 <alexbobp> Would haskell work for an in-game scripting language?
10:10:31 <lament> this question gets asked all the time.
10:10:33 <alexbobp> I want to make the best game ever and I figured giving it the best programming language would be a good start
10:10:37 <alexbobp> ah, really?
10:10:38 <lament> @faq  Would haskell work for an in-game scripting language?
10:10:38 <lambdabot> The answer is: Yes! Haskell can do that.
10:10:56 <alexbobp> I bet lots of people are planning to make the best game ever then...
10:11:06 <alexbobp> lament: thanks :D
10:11:07 <medfly> no
10:11:08 <copumpkin> there are downsides to using it as a scripting language right now
10:11:36 <alexbobp> @faq Would haskell work for a flargle narg foob?
10:11:37 <lambdabot> The answer is: Yes! Haskell can do that.
10:11:39 <alexbobp> lawl
10:11:44 <alexbobp> hax
10:11:55 <pookleblinky> The odd thing is, it can.
10:11:58 <medfly> @faq
10:11:58 <lambdabot> The answer is: Yes! Haskell can do that.
10:12:02 <alexbobp> XD
10:12:30 <pookleblinky> import Flargle.Narg.Foob (hiding buzzah)
10:13:20 <alexbobp> copumpkin: can you tell me about these downsides?
10:13:41 <copumpkin> GHC is enormous and linking to it is pretty heavy
10:13:41 <yitz> @vixen Would haskell work for an in-game scripting language?
10:13:41 <lambdabot> Ooh, functional programmers are so hot!
10:13:45 <copumpkin> that's the main one
10:13:49 <medfly> lol
10:14:33 <alexbobp> ah
10:15:54 <alexbobp> but that's only a performance issue during compilation, right?
10:16:30 <notabel_work> alexbobp: it also grows the size of your program executable
10:16:37 <sinelaw> @hoogle return
10:16:37 <lambdabot> Prelude return :: Monad m => a -> m a
10:16:38 <lambdabot> Control.Monad return :: Monad m => a -> m a
10:16:38 <lambdabot> Control.Monad.Instances return :: Monad m => a -> m a
10:16:49 <copumpkin> it might be less of an issue now since dynamic linking became possible
10:16:55 <sinelaw> @src return :: a -> MaybeT IO a
10:16:55 <lambdabot> Source not found. My brain just exploded
10:16:58 <copumpkin> but with static linkage 'sdeath
10:16:59 <sinelaw> @src return :: a -> (MaybeT IO) a
10:16:59 <lambdabot> Source not found. That's something I cannot allow to happen.
10:17:37 <sinelaw> @hoogle lift
10:17:38 <lambdabot> Control.Monad.Trans lift :: (MonadTrans t, Monad m) => m a -> t m a
10:17:38 <lambdabot> Text.ParserCombinators.ReadPrec lift :: ReadP a -> ReadPrec a
10:17:38 <lambdabot> Language.Haskell.TH.Syntax lift :: Lift t => t -> Q Exp
10:17:43 <ski> probably `return a = MaybeT (return (return a))'
10:17:58 <sinelaw> ski, does it put it in a Just?
10:17:59 <alexbobp> well it sounds like there are aspects to what I will have to do that, as of yet, I have no idea how to do
10:18:08 <alexbobp> but I guess that'd be true no matter what language I pick
10:18:16 <ski> sinelaw : yes, the second `return' in the body there being `Just'
10:18:20 <sinelaw> ok
10:18:36 <sinelaw> ok
10:18:38 <sinelaw> oops :)
10:18:50 <ski> you could define it as `return a = lift (return a)', if you wanted, too
10:19:29 <ski> (given `lift ma = MaybeT (liftM return ma)', where the `return' in the body is `Just')
10:24:27 <alexbobp> Hey BONUS, I'm in your site reading your tutorial!
10:24:35 <BONUS> omg! :o
10:24:56 <ben> BONUS my girlfriend is occasionally reading your tutorial; please post more chapters before she gets through it
10:24:58 <BONUS> if you view it upside down you get dizzy, try it
10:25:04 <alexbobp> haha
10:25:09 <alexbobp> maybe after I finish it rightside up
10:25:39 <ben> BONUS: I was told that this also happens when you view it downside down
10:25:55 <BONUS> ben: haha, ok. i will do it for her!
10:26:14 <BONUS> (and great good)
10:26:18 <ben> hooray
10:27:07 <alexbobp> BONUS: you could have also said "for great justice" ;)
10:27:35 <lament> you could have also said giggidy giggidy!
10:27:49 <BONUS> hehe, yeah i was actually deciding between justce and good :)
10:27:54 <BONUS> (and giggidy)
10:28:06 <stevenmarky> link to bonus tutorial please giggidy
10:28:07 <alexbobp> I vote for giggity!
10:28:10 <alexbobp> but also justice.
10:28:31 <alexbobp> stevenmarky: http://learnyouahaskell.com/
10:30:18 <stevenmarky> ahh that one :) I like it.
10:31:05 <BONUS> also it's coming out as a real book soon so you can use it as a paper-weight
10:31:12 <ben> How soon?
10:31:17 <ben> My birthday is tomorrow, and...
10:31:17 <BONUS> we're aiming for summer
10:31:20 <ben> Aw!
10:31:30 <BONUS> maybe you can delay it?
10:31:33 <silver> reschedule your birthday!
10:31:35 <ben> good idea
10:31:57 <sinelaw> ben, can i as your age?
10:32:06 <ben> 22, right now
10:32:23 <sinelaw> congrads
10:32:27 <ben> Thank you
10:32:49 <sinelaw> if i only knew of haskell when i was 22 :(
10:33:07 <BONUS> i will be 23 in september, boy how time flies
10:33:45 <nagnatron> I'll be 23 in may
10:35:17 <sinelaw> should i directly wrap opencv in a MaybeT IO?
10:35:40 <sinelaw> otherwise smart users will have to do MaybeT . and lift all the time
10:36:36 <roconnor> what is opencv?
10:36:43 <sinelaw> computer vision library
10:36:56 <sinelaw> i do bindings to it
10:37:14 <sinelaw> but to be convenient it would be nice to get a MaybeT IO
10:37:18 <sinelaw> instead of just IO
10:37:27 <sinelaw> because some functions can fail
10:41:09 <BONUS> wrap it in MaybeT IO and then make a type synonym?
10:45:24 <burp> @hoogle m a -> m [a]
10:45:25 <lambdabot> Control.Applicative many :: Alternative f => f a -> f [a]
10:45:25 <lambdabot> Control.Applicative some :: Alternative f => f a -> f [a]
10:45:25 <lambdabot> Text.ParserCombinators.ReadP many :: ReadP a -> ReadP [a]
10:45:50 <burp> @hoogle m a -> [m a]
10:45:52 <lambdabot> Data.List inits :: [a] -> [[a]]
10:45:52 <lambdabot> Data.List permutations :: [a] -> [[a]]
10:45:52 <lambdabot> Data.List subsequences :: [a] -> [[a]]
10:45:59 <burp> hm, yes
10:47:12 <burp> hm, what's replicateM (1/0)? :>
10:47:18 <burp> a monadic repeat
10:47:29 <sinelaw> BONUS, what about using IOError instead?
10:47:34 <burp> @src repeat
10:47:34 <lambdabot> repeat x = xs where xs = x : xs
10:47:48 <burp> hm, ok
10:50:27 <BONUS> that's cool too actually, i think both are fine. just a matter of preference. the plus of using IOErrors for IO actions that fail instead of MaybeT IO is that you don't have to wrap and lift
10:51:10 <sinelaw> i think i'll go for IOError
10:51:17 <sinelaw> for usability
10:51:42 <BONUS> but with MaybeT IO you get MonadPlus. although you can get MonadPlus-like behavior by catching
10:51:58 <BONUS> i'd go for IOError too imo
10:52:05 <byorgey> I want to write a Haskell program that starts a process (a ghci process, actually, but that's irrelevant) and then sends it input and reads its output in an interleaved fashion.  Any tips on how to do this?
10:52:24 <byorgey> I tried using runInteractiveCommand but I'm having trouble getting it to work.
10:53:15 <byorgey> it hangs when I think there should be output to read, sometimes I get Broken pipe errors, etc.
10:53:57 <BONUS> yeah, that's one of those things that sounds like it should be a piece of cake to do but then turns out to be a nightmare
10:54:05 <fax> UNIX
10:56:41 <byorgey> hmm, the documentation for runInteractiveProcess has an example using forkIO, like this:  forkIO (hPutStr inp str)
10:56:51 <byorgey> I wonder why.
10:59:32 <medfly> hi sinelaw
10:59:42 <sinelaw> hey medfly
10:59:45 <sinelaw> 'sup
11:00:16 <medfly> sinelaw, I need a bit of help :)
11:01:45 <jlouis> I plan on bumping out HaskellTorrent v0.1 :)
11:03:17 <sinelaw> if I throw a "fail" in an IO
11:03:35 <sinelaw> do i get some way to find out where it happened?
11:03:48 <BONUS> i don't think so
11:03:51 <Saizan> byorgey: you've to read the output concurrently
11:04:15 <Saizan> byorgey: if the output buffer for a program is full it can't go on reading new input
11:05:01 <sinelaw> BONUS, really?
11:05:03 <byorgey> Saizan: I'm not sure I understand what you mean by "concurrently".
11:05:12 <byorgey> You mean I have to read and write in different threads?
11:05:18 <jlouis> sinelaw: +RTS -xc -RTS after having compiled with profiling
11:05:19 <Saizan> yeah
11:05:38 <sinelaw> jlouis, thanks...i'll keep that in mind when i need.
11:05:48 <byorgey> I don't understand why I can't read and write from the same thread.  What has that to do with the output buffer being full?
11:05:58 <BONUS> sinelaw: how do you mean where it happened? you can catch the exception with catch
11:06:08 <sinelaw> BONUS, like a stack trace
11:06:26 <Saizan> byorgey: well, you can read and write from the same thread, but only if you are sure you don't get blocked writing when you should be reading
11:06:27 <jlouis> sinelaw: more info at: http://www.haskell.org/ghc/docs/latest/html/users_guide/runtime-control.html#rts-options-debugging
11:06:39 <BONUS> ah, that i wouldn't know. although i recall there being some package for stack traces
11:06:39 <sinelaw> thx
11:06:50 <sinelaw> not urgent now anyway
11:06:50 <byorgey> Saizan: how big is the output buffer, generally?
11:07:25 <Saizan> byorgey: i don't know
11:07:34 <byorgey> hmm
11:22:07 <roconnor> This "Haskell is Not Not ML" paper looks very cool.
11:22:22 <notabel_work> roconnor: it is
11:22:28 <notabel_work> which is to say, i enjoyed it
11:22:31 <BONUS> too busy reading "Sky Is Blue"
11:22:42 <medfly> BONUS, is that an elaborate joke :)
11:22:58 <BONUS> well it's not very elaborate hehe
11:25:29 <BONUS> ah, a language that can encode both strict and non-strict language. that is cool
11:29:16 <zygoloid> roconnor: Haskell ~ (ML -> False) -> False?
11:29:43 <roconnor> zygoloid: that is what the title means, but I'm not sure how serious it is
11:29:45 <poucet> roconnor: is that constructive logic?
11:29:50 <BONUS> say you have a function Foo -> [Foo] and you're using it to take some starting value, generate candidate solutions and then repeating that on the resulting list, concatting between steps and eliminating unfavorable candidates
11:29:55 <BONUS> is this considered backtracking?
11:29:58 <roconnor> poucet: yes, or continuation passing stype
11:29:59 <roconnor> style
11:30:08 <poucet> roconnor: I mean 'not not X' != X
11:30:25 <poucet> W.r.t. the title
11:30:27 <roconnor> BONUS: it is definitely backtracking when your function can return empty lists
11:30:48 <roconnor> and probably considered backtracking even if your functions always return non-empty lists
11:30:59 <BONUS> yeah, given that you're filtering the list in between steps
11:31:17 <roconnor> ah right "eliminating unfavorable candidates"
11:31:24 <roconnor> definitely backtracking
11:31:37 <roconnor> it is basically the core idea of prolog
11:31:57 <BONUS> that's what i thought yeah. "backtracking" is a really poor word choice for that imo
11:32:04 <roconnor> BTW, I'm told the Logic monad is even better than the list monad here because it has fair merging primitives
11:32:33 <monochrom> Like http://www.vex.net/~trebla/haskell/forwardconstraint/ForwardConstraint.hs
11:32:40 <roconnor> though if everything is finite, then there is no issue
11:33:02 <BONUS> ah. yeah, i'm planning to read the backtracking, interleaving and terminating monad transformers paper one of these days
11:33:28 <monochrom> the Logic monad also uses some CPS to speed up. CPS seems faster than creating then pattern-matching data.
11:33:57 <roconnor> monochrom: oh, good to know
11:34:12 <roconnor> edwardk
11:34:31 <BONUS> backtracking implies that you're actually going back in the tree, although that seems to be the case when you're doing depth first, which is normal for backtracking in imperative languages
11:34:36 <BONUS> or am i wrong?
11:34:46 <roconnor> edwardk was dabbling in some new monad transformer library using data families or whatnot to automagically create more optimal monad implementions of layered features
11:35:16 <roconnor> BONUS: the concat in the list monad does the backtracking
11:35:23 <roconnor> due to the laziness
11:35:31 <roconnor> foo ++ bar
11:35:54 <BONUS> ah
11:35:58 <roconnor> after processing foo, if you ask for the first element of bar it will "backtrack" upto that branch point in the code.
11:36:04 <roconnor> operationally speaking
11:36:13 <roconnor> of course we all think denotationally in haskell
11:36:18 <BONUS> that is true yeah
11:36:29 <roconnor> and there is no real backtracking in the dentotational semantics
11:36:41 <roconnor> which is why it can be hard to see what the list monad has to do with backtracking.
11:37:58 <BONUS> yeah. i've gotten really used to thinking denotationally that that seems to be the case with me
11:38:33 <roconnor> if you wrote idenical list monadic code in ML it wouldn't really do the backtracking
11:38:52 <roconnor> it would evaluate all the intermediate lists fully
11:39:01 <copumpkin> demotivational semantics
11:39:06 <BONUS> haha
11:40:45 <roconnor> monochrom: can Logic return a list of posibilities?  (so Logic isn't a commutative monad?)
11:41:18 <monochrom> I forgot. should be yes.
11:41:32 <bnjmn> do parsec and attoparsec share any code or is the similarity just with the name and the parsing approach?
11:41:33 <monochrom> (I only read the TMR article! :) )
11:41:35 <zygoloid> roconnor: i think Logic is commutative up to the order of the results, but it's only a monad up to ordering...
11:41:49 <roconnor> ok
11:41:53 <roconnor> same as list monad
11:41:56 <zygoloid> (however ordering of results here can include whether you see certain results at all in an infinite result set)
11:42:22 <roconnor> zygoloid: oh does Logic have unfair mplus?
11:42:39 <zygoloid> hmm. maybe that's not true.
11:42:45 <roconnor> I could belive it
11:42:46 <zygoloid> Logic has fair mplus
11:42:58 <roconnor> sure I mean the mplus for Logic is fair
11:43:09 <roconnor> but does it have an unfair version as well (obviously by a different name)
11:43:48 <roconnor> during an ICFP contest a well placed call to sort really improved my list monad code :D
11:43:53 <zygoloid> well, i think the MonadLogic's >>= is unfair (but the >>- is fair)
11:43:55 <roconnor> improved the speed I mean.
11:44:02 <roconnor> zygoloid: oh!
11:45:49 <losl> Hi
11:46:25 <losl> Could anyone direct me to some information on how haskell manages memory? I'm writing a program and for long runs I run out of memory
11:46:57 <basti_> hmm, implicitely, as in "garbage collection"
11:47:01 <Botje> sounds like you're retaining references somewhere.
11:47:09 <Botje> which is generally because of laziness
11:47:40 <losl> I'm a still learning Haskell and I've been reading learnyouahaskell.com
11:47:51 <opqdonut> you might want to read up on memory profiling
11:47:53 <losl> but he glosses over the memory stuff
11:47:57 <losl> Okay
11:48:20 <opqdonut> http://haskell.org/ghc/docs/latest/html/users_guide/profiling.html
11:48:30 <opqdonut> that's not the best place to start tho
11:48:34 <roconnor> http://www.haskell.org/haskellwiki/Memory_leak
11:49:11 <roconnor> http://www.haskell.org/haskellwiki/Performance/Space
11:49:24 <roconnor> ``Haskell programs will sometimes consume a lot more memory than necessary, and this is often due to too much, or too little, laziness.
11:49:46 <roconnor> hmm
11:49:56 <roconnor> these pages are nearly as helpful as I hoped
11:50:18 <gwern> @quote stricter
11:50:18 <lambdabot> int-e says: I propose that all of f, g, h and i be made illegal. (referring to http://hackage.haskell.org/trac/haskell-prime/wiki/StricterLabelledFieldSyntax as it existed on 2009-10-05)
11:50:19 <losl> okay thanks!
11:50:25 <gwern> @quote stricter.or
11:50:26 <lambdabot> No quotes match. stty: unknown mode: doofus
11:50:32 <gwern> oh good grief
11:50:39 <gwern> @quote or.*stricter
11:50:39 <lambdabot> int-e says: I propose that all of f, g, h and i be made illegal. (referring to http://hackage.haskell.org/trac/haskell-prime/wiki/StricterLabelledFieldSyntax as it existed on 2009-10-05)
11:50:44 <jlouis> Does anyone know what MAIN refers to in GHCs profiling outputs? I have 58% of my time spent there... GC?
11:50:53 <gwern> @quote best.*way.*stricter
11:50:54 <lambdabot> gwern says: the best way to optimize a program is to make it lazier or stricter.
11:51:03 <copumpkin> boa con stricter
11:51:18 <gwern> jlouis: main means main. are you using -caf-all
11:51:54 <jlouis> gwern: yup
11:52:03 <gwern> hm. -prof-all?
11:52:08 <jlouis> also true
11:52:30 <jlouis> ghc-options: -prof -auto-all -caf-all
11:52:43 <gwern> oh. maybe you have too much stuff going on in main
11:52:56 <jlouis> I have some 800-1000 threads I think
11:53:51 <stevenmarky> :o what does your app do?
11:54:00 <jlouis> bittorrent client in haskell
11:54:48 <notabel_work> jlouis: is the code online anywhere?
11:54:54 <jmcarthur> each thread is a network connection?
11:55:04 <jlouis> it works rather fine, I am just trying to shave off CPU time
11:55:08 <sm> how do I get just the code from a literate haskell file ?
11:55:18 <sm> ah!
11:55:26 <jlouis> notabel_work: sure: http://github.com/jlouis/haskell-torrent
11:55:59 <jlouis> jmcarthur: yes, more or less. There are actually 4 threads per connection and that will get blown up by a factor of 3 due to CML
11:56:06 <notabel_work> sm: you figured it out?
11:56:13 <jmcarthur> woah
11:56:21 <Zao> "Crazy madness, lol"?
11:56:24 <sm> notabel_work: I found ghc -E .. leaves a lot of whitespace though
11:56:33 <jlouis> all in all, I think I have a neat stress test :)
11:56:41 <jmcarthur> CML?
11:56:43 <poucet> jlouis: why 4 threads/connection?
11:56:59 <jlouis> poucet: one for receiving, one for sending, a send queue and one controller
11:57:01 <poucet> jlouis: are you attending the zurihac?  Seems like an interesting project to work further on @ zurihac
11:57:13 <jlouis> poucet: unfortunately not :/
11:57:14 <jmcarthur> oh concurrent ml
11:57:23 <jlouis> jmcarthur: cml on cabal yes
11:57:42 <jlouis> at the url I posted are some links to the papers behind the Haskell impl
11:58:57 <jlouis> suggestions for speeding up the beast are welcome :P
11:59:33 <stevenmarky> use C/assembly (trollface)
12:01:20 <jlouis> stevenmarky: hah. I have one in Erlang already :)
12:01:32 <jlouis> C/assembly is done
12:06:27 <sinelaw> i win.
12:09:35 <Volvic> anybody else out there going through Hutton's Programming In Haskell?
12:10:26 <gwern> no. you're all alone
12:10:56 <liyang> ps: your speshul.
12:10:57 <Volvic> hm, wrong forum i guess
12:11:12 <Twey> Volvic: You probably really are all alone.  :Ã¾
12:11:23 <liyang> (yes, of course. Just say/ask what you want to say/ask. :)
12:11:44 <Twey> RWH and LYaH are the texts used by the majority of learners today, I think.
12:12:04 <Volvic> just wanted to check if anybody else finds chapter 8 more than a bit confusing
12:12:29 <BONUS> which one's chapter 8 again
12:12:37 <Volvic> parsers
12:12:44 <Twey> Do you have your book's name on highlight, BONUS?  :Ã¾
12:12:54 <BONUS> haha no, i guess i'm just lucky
12:13:00 <Twey> Hehe
12:13:01 <liyang> a parser for things is a function from strings to lists of pairs of things and strings?
12:13:10 <Volvic> precisely :)
12:13:12 <fax> no
12:13:27 <BONUS> Volvic: yeah that one confused me as well. as far as i recall, he uses >>= and return without properly defining them
12:13:42 <BONUS> (my copy is in the closet and i'm too lazy to dig it out)
12:14:03 <liyang> He does, it's on page 77â¦
12:14:11 <Volvic> up until then, typing the code in the book into a file and loading it into ghci works fine, but in chapter 8 he starts definiting things that are already in the prelude in slightly different versions
12:14:35 * hackagebot HaskellTorrent 0.1 - A concurrent bittorrent client  http://hackage.haskell.org/package/HaskellTorrent-0.1 (JesperLouisAndersen)
12:14:43 <Volvic> BONUS> he defines them, just in a different way (as far as i can understand)
12:14:56 <liyang> Call yours something different, like ret and >>>=
12:15:04 <periodic> Hrm, why would I be able to read a file with `Prelude.readFile "file" >>= return . Prelude.take 10`, but when I switch both Preludes to Data.ByteString I get " hGetBuf: failed (Bad address)"?  Any ideas?
12:15:23 <liyang> What he defines in chapter 8 are specific instances of return and >>= for Parsers.
12:15:40 <Volvic> also, in the code for this chapter presented on the book's webpage, he redefines the Parser type as an instance of the Monad typeclass - why didn't he just do it to begin with?
12:15:42 <liyang> Which is later generalised to what you'd find in the Prelude.
12:15:56 <periodic> liyang: we're talking about RWH here?
12:15:58 <Volvic> liyang> ah
12:16:03 <liyang> Volvic: because monads are scary. :3
12:16:18 <liyang> periodic: er, no, Hutton's Programming in Haskellâ¦
12:17:16 <periodic> liyang: ah.  with RWH there were a few parts, particularly in the section about Parsec, where I would be trying to follow along, get really confused, and then they'd spring the simple notation that wraps up the conscept and I'd wonder why they didn't start from there.
12:17:18 <Volvic> ok, i guess i just have to stop re-reading the text and do the exercises
12:17:57 <sinelaw> edwardk, i got my lib rolling
12:18:01 <sinelaw> thanks to your help
12:18:22 <Volvic> periodic> i agree
12:18:27 <sinelaw> edwardk, with asingle constructor, and instances for functor, category and applicative
12:18:29 <BONUS> i think i lost my copy of hutton's book. this sucks
12:18:37 <periodic> Oh, apparently ByteString dies on large files because it cannot index the whole thing?  What's a good way to read the start of a large file in as a ByteString?
12:18:49 <liyang> periodic: were you already familiar with monads?
12:19:02 <notabel_work> periodic: are you using lazy bytestrings?
12:19:13 <periodic> liyang: not at the time, no.  Even rereading it I get confused. :D
12:19:28 * liyang hasn't read RWH.
12:19:32 <Volvic> BONUS> it's so thin, did you check between the desk and your keyboard
12:19:40 <BONUS> haha
12:19:48 <periodic> notabel_work: Oh, you're right, Lazy works, which is what I want anyway.
12:20:09 <periodic> Now I have to figure out how to reconcile a function that expects Data.ByteString.Internal but is getting Data.ByteString.Lazy.Internal
12:20:15 <notabel_work> lazy bytestrings work the same, but are represented as lists of chunks
12:20:18 <notabel_work> fromlist
12:20:37 * hackagebot HaskellTorrent 0.1.1 - A concurrent bittorrent client  http://hackage.haskell.org/package/HaskellTorrent-0.1.1 (JesperLouisAndersen)
12:20:39 <notabel_work> er, other one rather
12:20:50 <notabel_work> fromlist is to get a lazy from a strict
12:21:12 <periodic> notabel_work: alright, got it.  I was vainly hoping that ByteString was just less lazy than than the real Lazy version.  I only want to read the first 1k of a 32GB file.
12:21:16 <periodic> :D
12:21:32 <notabel_work> sorry, toChunks
12:21:37 <BONUS> wait i found it it was between two sheets of paper.
12:21:43 <BONUS> ah yeah this is the thing
12:21:56 <BONUS> he defines return and >>= but as standalone functions
12:22:00 <BONUS> and then proceeds to use do notation
12:22:11 <BONUS> so this is probably where you got hung up
12:22:23 <periodic> notabel_work: Thanks.  I'll look into it some more.  Hoogle wasn't showing any appropriate signatures for fromlist anyway. :)
12:22:33 <notabel_work> yeah, it's fromChunks
12:22:36 <notabel_work> and toChunks
12:22:43 <notabel_work> i was misremembering the function names
12:22:48 <BONUS> there's no Monad instance
12:24:06 <periodic> notabel_work: hrm, why does toChunks return a list of ByteStrings?
12:24:20 <notabel_work> to preserve laziness
12:24:24 <Volvic> BONUS> â¦meaning that i cannot use do notation with the functions defined in this chapter?
12:24:38 <notabel_work> it gives you the list of chunks, rather than concatenating them all into one strict bytestring
12:24:47 <periodic> notabel_work: I guess I'm wondering how they're defined.  Each one corresponds to a block or something?
12:24:55 <periodic> Ah, I see.
12:24:59 <periodic> That makes sense.
12:25:00 <notabel_work> toStrict = concat . toChunks
12:25:27 <periodic> Okay, I won't worry about how those chunks are defined via readFile then.
12:25:41 <notabel_work> the chunks are just normal bytestrings
12:25:58 <gwern> notabel_work: I once asked dons to add that to bytestring; he declined on the grounds that adding an easy lazy->strict function would lead to people using it and getting bad performance
12:26:04 <periodic> notabel_work: Well, the issue comes when I want to read in 1024 bytes.  How do I know how many bytestrings that spans in the list?
12:26:08 <notabel_work> the default chunk size is 64k
12:26:32 <periodic> notabel_work: Thanks.  That's the information I really needed.
12:26:37 <notabel_work> np
12:26:54 <BONUS> Volvic: just a sec i'll give you some code that will let you use do notation
12:27:00 <notabel_work> gwern: i pretty much agree with him, even though i've defined that function in code before
12:27:11 <Volvic> BONUS: wow, thanks
12:27:13 <gwern> notabel_work: it seems pretty paternalistic to me
12:27:19 <notabel_work> when i had two libraries needing to exchange mismatched bytestrings
12:27:22 <gwern> notabel_work: and you make at least the third definition of it I've seen
12:27:27 * gwern hates code duplication like that
12:27:44 * gwern hates it like explosive diarrhea!
12:27:49 <notabel_work> gwern: my thinking is that the availability of the function would encourage bad practices
12:28:04 <notabel_work> but you could define it, and just document that it should only be used for marshalling between libraries
12:28:29 <gwern> if you're thinking paternalistically already, then you don't trust the users to read & heed the haddocks
12:28:53 <notabel_work> eh, not necessarily.  i trust haskellers more than most language users
12:29:13 <periodic> I like that the strict type system in Haskell forces me to understand the differences between representations sometimes.
12:29:17 <notabel_work> the bytestring haddocks are great, in that they include time complexities, so you can make wise decisions
12:29:29 <BONUS> Volvic: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23909#a23909
12:29:34 <BONUS> untested, but i think it should work
12:29:40 <periodic> In a dynamically typed language it might change types under the hood and I wouldn't realize that I needed to read deeper until the performance sucked, and then I wouldn't even know where to begin.
12:30:03 <Volvic> BONUS: nice! much appreciated
12:30:11 <BONUS> there's one thing though, it's in a newtype as you can see
12:30:14 <BONUS> that's kind of like data
12:30:31 <periodic> In some ways I like that the Haskell libraries are so complex so I'm forced to read through the libraries and actually understand them instead of just using them.
12:30:36 <periodic> I'm lazy at heart.
12:30:43 <BONUS> so if you write a parser function of type String -> [(a,String)], you have to wrap it with the Parser constructor
12:30:45 <Phyx-> then you're in the right place
12:30:52 <gwern> the initial hump while haskell programming can be very frustrating
12:31:00 <gwern> you get 15 bajillion type errors
12:31:09 <gwern> and no idea whether you are making progress
12:31:12 <BONUS> for instance: satisfies p = Parser $ \x -> ...
12:31:26 <gwern> 'well, I got 10 type errors last time and 10 this time; was that a good change or not...?'
12:31:32 <liyang> Volvic, BONUS: you could import Prelude ()
12:31:37 <sinelaw> is binding to C++ horrible as I imagine it is?
12:31:50 <liyang> Then you'd be free to use the >>= and return names as you wish.
12:31:51 <mauke> yes!
12:32:01 <Phyx-> gwern: I suppose that also depends on the kind of type errors you're getting no?
12:32:07 <arw> sinelaw: yes. usually you want to bind to c, and bind that to c++
12:32:09 <BONUS> liyang: yeah you could do that as well
12:32:13 <BONUS> good idea
12:32:22 <gwern> Phyx-: the messages aren't always helpful either
12:32:24 <Volvic> liyang: i have been doing import Prelude hiding (return) but didn't find a way to hide >>=
12:32:35 <gwern> they've gotten better but especially with lists and monad stuff, the meaning can be obscure
12:32:37 <BONUS> Volvic: hiding (return, (>>=))
12:32:39 <sinelaw> arw, ok
12:32:40 <liyang> Volvic: hiding ( (>>=) )
12:32:45 <Volvic> d'oh
12:32:46 <sinelaw> arw, that's what i was guessing
12:33:05 <Phyx-> gwern: I've seen alot worse
12:33:16 <BONUS> yes actually that's much better for getting though hutton's examples. then when you want to use it with other monads, you can make a proper monad instance like in my paste
12:33:24 <gwern> ghc telling you what extensions are needed was a major step foreward
12:33:24 <arw> sinelaw: c++ has really ugly properties when it comes to stuff like name mangling and other aspects of the abi. every other compiler version changes almost everything.
12:33:31 <BONUS> but for now it's cool doing hiding (return, (>>=))
12:33:58 <Phyx-> gwern: for instance, UHC's type error messages keep me up at night
12:34:01 <arw> sinelaw: but thats a general problem with c++, not specific to haskell.
12:34:06 <liyang> I'm not sure if the do notation uses the >>= and return that's currently in scope or if it's hardwired to the Monad onesâ¦
12:34:09 <sinelaw> yeah
12:34:13 <gwern> Phyx-: who uses uhc/
12:34:21 <Phyx-> gwern: heh, ouch
12:34:30 <liyang> (There's a GHC flag for controlling that, I seem to remember.)
12:34:34 <BONUS> liyang: i'm not sure either. that's why i at first suggested the monad instance
12:39:24 <BONUS> Volvic: i tested it out and just doing import Prelude hiding (return, (>>=)) works and you get do notation
12:39:35 <BONUS> so use that and define return and >>= like they're defined in the book and you're good to go
12:39:51 <Volvic> excellent
12:40:34 <Volvic> i managed to get your code to compile with some small tweaks ('[',']' around the parser "output")
12:40:40 <benmachine> I thought you needed NoImplicitPrelude for that
12:40:50 <sinelaw> if my function takes CInt
12:40:56 <BONUS> yeah my code was a bit wrong, i did it like it was String -> (a, String), forgot the lists
12:41:04 <sinelaw> wait. never mind.
12:41:19 <sinelaw> @type 2^342
12:41:20 <lambdabot> forall t. (Num t) => t
12:41:23 <sinelaw> @type 2**342
12:41:24 <lambdabot> forall t. (Floating t) => t
12:41:29 <sinelaw> > 2**342
12:41:30 <lambdabot>   8.958978968711217e102
12:41:51 <sinelaw> @type (fromIntegral (834742874823646327647264782364324) :: Integer) :: CInt
12:41:53 <lambdabot> Not in scope: type constructor or class `CInt'
12:41:55 <sinelaw> argh.
12:43:05 <sinelaw> what's the largest standard haskell type i can safely convert to CInt?
12:43:07 <sinelaw> is it Int?
12:43:16 <ezyang> sinelaw: I believe so
12:43:17 <metaperl> Should the String in JObject be JString instead - http://pastie.org/865547
12:43:26 <sinelaw> thre's no equivalent 32 bit integer?
12:43:31 <mauke> sinelaw: I don't think there is one
12:43:35 <sinelaw> bah
12:43:36 <sinelaw> ok.
12:43:39 <mauke> well, there is Int16
12:43:51 <sinelaw> Int16^2
12:44:07 <Volvic> BONUS: ok i am not getting that to work (book code, after hiding prelude's return and >>=)
12:44:19 <copumpkin> Int32?
12:44:23 <Volvic> what's the tradition over here, no code pasting in the chat?
12:44:24 <mauke> copumpkin: too big
12:44:30 <BONUS> Volvic: hpaste.org
12:44:34 <Volvic> right
12:44:35 <ezyang> But CInt and Int should be machine dependent
12:44:37 <BONUS> Volvic: what have you got so far?
12:44:37 <copumpkin> mauke: for a CInt?
12:44:40 <mauke> copumpkin: yes
12:44:48 <copumpkin> hmm
12:45:02 <sinelaw> copumpkin,  if I use fromIntegral when passing into a CInt-taking function then i can get errors
12:45:08 <sinelaw> when someone passes an Integer for example
12:45:13 <copumpkin> mauke: any details?
12:45:19 <ezyang> sinelaw: Well, Integer is arbitrary precision
12:45:24 <sinelaw> i know
12:45:27 <sinelaw> i don't want that
12:45:29 <copumpkin> oh I see
12:45:34 <mauke> sinelaw: then check to see if it fits
12:45:40 <copumpkin> CInt isn't always a machine word
12:45:47 <sinelaw> should i just leave it as CInt?
12:45:49 <Volvic> BONUS: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23910#a23910
12:45:52 <mauke> copumpkin: the C standard says int is at least 16 bits wide
12:46:19 <sinelaw> then the user can decide if the value he's passing is safe to convert
12:46:53 <BONUS> hmm let's see now
12:47:06 <sinelaw> why not leave as CInt?
12:47:08 <sinelaw> actually?
12:52:01 <BONUS> Volvic: it seems that do notation still doesn't pick up
12:52:13 <BONUS> it doesn't recognize item as a monadic value :\
12:52:19 <BONUS> but with >>= it works well
12:52:29 <Volvic> yup
12:52:58 <BONUS> okay i'll fix you up in a second :)
12:53:17 <Volvic> hmm.. i guess i can just try to reimplement the parsers imn the chapter without do notation
12:53:32 <BONUS> yeah but it's handy. just a sec
12:53:58 <benmachine> BONUS: I think NoImplicitPrelude makes it use whatever's in scope
12:54:09 <BONUS> yeah?
12:54:12 <BONUS> let's see
12:54:12 <Volvic> no rush :) i have been stuck in this chapter for a week now. promised myself i wouldn
12:54:19 <benmachine> so I've heard
12:54:24 <Volvic> 't skip over anything in such a think intro book :(
12:54:38 <benmachine> (and also numeric constants use the in-scope fromInteger, etc.)
12:55:04 <BONUS> benmachine: nah, it doesn't do the trick :\
12:55:07 <benmachine> no?
12:56:10 <BONUS> benmachine: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23910#a23911
12:56:29 <BONUS> Volvic: well, it's not your fault though :) imo it really should have been a proper monad instance
12:56:38 <benmachine> aw
12:56:45 <BONUS> i'll type you up some code so you'll be able to use do notation, just a sec
12:58:20 <benmachine> BONUS: http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#rebindable-syntax is this just wrong then
12:58:43 <liyang> You need fail :: String -> Parser alpha and (>>) defined too for do notation to work: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23910#a23912
12:59:11 <BONUS> benmachine: hmmm
12:59:16 <BONUS> liyang: ah! good show!
13:00:26 <jlouis> Ah, there... v0.1.1 release
13:00:49 <BONUS> Volvic: liyang's code works
13:01:29 <Volvic> i bow to you sirs!
13:01:33 <Volvic> AÅâ
13:06:47 <fax> haskell = ffffffdhgnjlshgdfpwaue,eljgaaneibpdfounhfap
13:07:08 <liyang> I agree.
13:07:43 <benmachine> I disagree
13:07:44 <BONUS> @remember fax haskell = ffffffdhgnjlshgdfpwaue,eljgaaneibpdfounhfap
13:07:49 <benmachine> I'd have included another j
13:07:52 <lambdabot> It is forever etched in my memory.
13:07:53 <BONUS> @botsnack
13:07:53 <lambdabot> :)
13:07:57 <lament> it's all relative
13:08:11 <copumpkin> damn, we lost dpiponi
13:08:20 <metaperl> Should the String in JObject be JString instead - http://pastie.org/865547
13:08:25 <fax> dppipipipobbbbbbbbbbbannnufffffff
13:08:39 <Twey> metaperl: No
13:08:40 <fax> see what happens if you encourge then :|
13:08:41 <BONUS> copumpkin: the average IQ of this channel just dropped by 10
13:09:01 <Twey> metaperl: String is a type; JString is a constructor (a value)
13:09:07 <benmachine> which means the total IQ dropped by like 6000?
13:09:24 <fax> yeah that's when I woke up
13:09:47 <Twey> metaperl: The equivalent would be [(JValue, JValue)], but then of course you could use any JValue as a key, not just strings, so it's a bit different.
13:09:59 <benmachine> I guess strictly speaking it's possible to have negative IQ isn't it
13:10:10 <benmachine> well, no test ever would go that far down
13:10:11 <lament> it is, trust me
13:10:12 <Twey> I don't know
13:10:24 <benmachine> but you'd only need to be, what, seven standard deviations below the mean?
13:10:25 <Twey> I suspect 0 may imply braindeath
13:10:39 <fax> I have a negative IQ
13:11:27 <benmachine> I have an irrational IQ
13:11:38 <metaperl> Twey: yes. so it seems that there is no way to specify that the JObject is keyed by a JValue which should only be constructed from the data constructor JString
13:11:57 <Twey> metaperl: No, there isn't
13:12:05 <liyang> Go on, someone claim to have an imaginary/algebraic/transcendental IQ.
13:12:07 <Twey> metaperl: (and it wouldn't be useful for there to be, in this case, either)
13:12:19 <benmachine> I have a vector IQ?
13:12:29 <fax> how many dimensions?
13:12:32 <Twey> liyang: Well, I know someone with an IQ of 80 + 160i.
13:12:35 <benmachine> seven
13:12:39 * copumpkin has a non-computable sedenion IQ
13:12:45 <benmachine> showoff :P
13:12:48 <liyang> fax: over 9000.
13:13:03 <Twey> liyang: The imaginary part is about twice as much as the real part.  ;)
13:13:11 <benmachine> zing
13:13:31 <ben> Is the imaginary part of i i or 1?
13:13:35 <benmachine> 1
13:13:36 <benmachine> er
13:13:36 <benmachine> i
13:13:44 * benmachine useful
13:13:52 <copumpkin> the imaginary part of -1 is ii
13:13:52 <benmachine> I don't know, does it matter?
13:14:02 <fax> be, Re : C --> R, Im : C --> R
13:14:11 <ben> Right
13:14:12 <fax> z = Re(z) + i*Im(z)
13:14:14 <kynky> e^(i*pi)=-1
13:14:32 <MadHatterDude> Hey, I'm making a small virtual machine, what AP-integer library shoud I use?
13:14:41 <liyang> The answer is 2Ï.
13:14:43 <benmachine> itym â
13:14:54 <fax> pi doesn't exist anyway
13:15:04 <benmachine> neither do you
13:15:44 <liyang> MadHatterDude: GMP seems to be the usual one.
13:15:51 <benmachine> â â â
13:15:53 <benmachine> whee
13:16:00 <copumpkin> you get it for free in GHC, might as well use it
13:16:22 <benmachine> there are two gmps though aren't there?
13:16:25 <benmachine> or two Integers
13:16:30 <kynky> gmp is gpl though ? so it depends on definition of free ?
13:16:52 <benmachine> there's also integer-simple or something like that, which is bsd
13:16:55 <liyang> GHC uses GMP to implement Integer, but Int is architecture-specific.
13:16:59 <kynky> bsd replacemnt of gmp in ghc6.12
13:17:16 <sinelaw> is there a type for void*?
13:17:17 <kynky> optional replacement
13:17:17 <copumpkin> it's not nearly as fast
13:17:19 <benmachine> I think you need to do your own compile to use it though
13:17:20 <sinelaw> Ptr Void or something?
13:17:21 <tensorpudding> nice
13:17:24 <benmachine> sinelaw: Ptr a?
13:17:26 <tensorpudding> is that a unicode symbol?
13:17:32 <sinelaw> benmachine, ah :)
13:17:40 <benmachine> sinelaw: kind of a guess, but it would make sense
13:17:46 <sinelaw> benmachine, it does
13:17:52 <tensorpudding> double-struck capital R, nice
13:18:05 <benmachine> tensorpudding: oh I wondered what you were talking about :P
13:18:09 <benmachine> yes it is unicode
13:18:32 <tensorpudding> i didn't know that it was a unicode symbol also, i've only seen it in latex documents
13:18:40 <benmachine> > chr '\x2102'
13:18:41 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
13:18:41 <lambdabot>         against inferred type ...
13:18:46 <benmachine> whoops
13:18:50 <benmachine> > chr 0x2102
13:18:51 <lambdabot>   '\8450'
13:18:54 <benmachine> thx
13:18:58 <benmachine> > test$ chr 0x2102
13:18:58 <lambdabot>   Couldn't match expected type `a -> b'
13:18:59 <lambdabot>         against inferred type `GHC.Ty...
13:18:59 <benmachine> er
13:19:02 <benmachine> > text $ chr 0x2102
13:19:03 <lambdabot>   Couldn't match expected type `GHC.Base.String'
13:19:03 <lambdabot>         against inferred typ...
13:19:08 <benmachine> agh
13:19:13 <benmachine> > text . (:[]) $ chr 0x2102
13:19:14 <lambdabot>   â
13:19:17 <benmachine> whee
13:19:26 <benmachine> > text . (:[]) $ chr 0x2115
13:19:27 <lambdabot>   â
13:19:39 <benmachine> there're all around there if you look hard enough
13:19:41 <copumpkin> pure is prettier than (:[])
13:19:54 <lament> :[]
13:19:57 <fax> âo
13:20:01 <benmachine> > text . pure $ '\x211d'
13:20:02 <lambdabot>   â
13:20:11 <fax> what sucks is they don't have the whole alphabet
13:20:16 <aavogt> > text "\x211d"
13:20:17 <lambdabot>   â
13:20:22 <benmachine> copumpkin: but... robot monkey :(
13:20:25 <fax> > text ['\x211d'..]
13:20:27 <lambdabot>   ââââ â¡â¢â£â¤â¥â¦â§â¨â©âªâ«â¬â­â®â¯â°â±â²â³â´âµ...
13:20:27 <copumpkin> \mathbb{}
13:20:36 <fax> > text ['\x210d'..]
13:20:38 <lambdabot>   ââââââââââââââââââââ â¡â¢â£â¤â¥...
13:20:44 <sinelaw> kool!
13:20:53 <benmachine> so they do actually have most of the alphabet I think
13:21:03 <benmachine> what's â?
13:21:09 <fax> quaternions
13:21:12 <tensorpudding> usually used for the quaternions
13:21:15 <tensorpudding> after Hamilton
13:21:24 <benmachine> oh
13:21:31 <tensorpudding> Since Q is used for the rational numbers.
13:21:42 * benmachine seems to remember Q_8
13:21:49 <ben> which is ironic, since Q is all but rational
13:21:49 <benmachine> no that's something different
13:21:54 <copumpkin> the gas company?
13:21:57 <benmachine> that is the quaternion group
13:22:08 <tensorpudding> what's so irrational about Q?
13:22:22 <benmachine> it needs u except for occasionally
13:22:23 <tensorpudding> it's countable, it's a field, it's pretty friendly (all computable)
13:22:39 <benmachine> I think ben was talking about the letter
13:22:42 <tensorpudding> oh, the letter Q
13:22:45 <benmachine> obviously the rationals are rational
13:22:49 <tensorpudding> :)
13:22:57 <benmachine> ratio-nal
13:23:11 <bastl> Hi all.
13:23:16 <benmachine> hi
13:23:17 <ben> I was seeing how well a star trek joke would go over in here~
13:23:26 <copumpkin> DO NOT WANT
13:23:28 <benmachine> ben: hah, missed entirely
13:24:09 <benmachine> you could also have been making a james bond joke
13:24:18 <benmachine> I think in either case the irrationality is not obvious
13:24:23 <ben> Oh, well
13:24:42 <benmachine> although both share something of a disregard for human life I guess >_>
13:24:50 <benmachine> (as do the rational numbers)
13:24:53 <olsner> ben: nice try :D
13:25:20 <yitz> the rationals are a finite extension of the rationals. therefore, they are rational.
13:25:24 <bastl> I have a question: parametric polymorphism = functor, right? examples are Lists, Maybe. What is the theoretical background for datatypes that are parametric in two types, Either, (Pair a b) etc? Functors map types to types and functions to functions. I'm confused (or am missing theoretic background)
13:25:24 <tensorpudding> the rational numbers have a disregard for human life?
13:25:31 <benmachine> yes
13:25:43 <enthymene> hehe
13:25:57 <tensorpudding> i thought parametric polymorphism referred to the idea of type variables in general
13:26:07 <benmachine> I saw three halves push someone in front of a bus once
13:26:11 <benmachine> for fun
13:26:15 <benmachine> yeah so did I
13:26:24 <ddarius> tensorpudding:  It does.
13:26:26 <benmachine> so id is parametrically polymorphic
13:26:32 <benmachine> as is const
13:26:42 <tensorpudding> i thought it was a fancy way of saying "generics"
13:26:53 <benmachine> and, combinators in general I guess
13:27:11 <benmachine> it's distinct from the other kind of polymorphism whose name I forget
13:27:16 <benmachine> oh I am going to be late for my train
13:27:20 <bastl> what is the endofunctor on Hask for Either ?
13:27:21 <tensorpudding> typeclasses allow you to create constrained polymorphic functions
13:27:25 <ddarius> Anyway, functors in CT can have more than one argument.
13:27:36 <bastl> ddarius: ah ...
13:27:50 <byorgey> bastl: also, note that even one argument type constructors are not necessarily functors.
13:27:51 <bastl> so whats the domain category then?
13:27:59 <byorgey> e.g.  Foo a = Foo (a -> a)
13:28:03 <bastl> byorgey: ok.
13:28:38 <bastl> Hask \times Hask -> Hask ?
13:28:40 <tensorpudding> Can you derive Functor?
13:28:42 <bastl> hmmm.
13:28:54 <byorgey> tensorpudding: you can in ghc 6.12.1
13:28:59 <tensorpudding> Goodie.
13:29:03 <tensorpudding> How does that even work?
13:29:20 <pokoko222> can u guys tell me what specific areas of computer science u have chosen? I cant figure out yet what i want, i am sick of doing general stuff
13:29:38 <ddarius> bastl: Parametric polymorphism doesn't have particularly much to do with Haskell's Functor class.
13:30:15 <bastl> i dont speak of Haskells functor class. I want to explain things like Either in terms of CT ...
13:30:28 <fax> bastl why?
13:30:29 <byorgey> tensorpudding: it's not that hard.  think of types as being built up out of unit, sums, products, and composition/application.  For each one of those construcors, think, "what would fmap do?"
13:30:39 <byorgey> e.g. for unit it does nothing.
13:30:45 <bastl> but by CT knowledge is not very deep ... :-/
13:30:49 <byorgey> for product it recurses over both branches.
13:31:19 <bastl> fax: because my supervcisor is theoritician not Haskell-hacker
13:31:21 <byorgey> if it gets to a base type it is the identity if it's not the type argument of the type in question, or if it is, it just applies the function being mapped.
13:31:24 <byorgey> etc.
13:31:35 <fax> bastl you never asked him why?
13:31:51 <fax> bastl -- a lot of people do it so there must be some reason... but I never figured out what it is
13:32:07 <bastl> why what ?
13:32:15 <sinelaw> @hoogle Ptr a -> IO a
13:32:16 <lambdabot> Foreign.Storable peek :: Storable a => Ptr a -> IO a
13:32:16 <lambdabot> Foreign.Marshal.Alloc free :: Ptr a -> IO ()
13:32:16 <lambdabot> Network.Socket.Internal peekSockAddr :: Ptr SockAddr -> IO SockAddr
13:32:35 <fax> why take out this category theory stuff
13:32:50 <metaperl> Twey: returning to this ( http://pastie.org/865547 ) ... why is it not useful to be able to restrict JObject to a JValue constructed via JString only?
13:33:24 <Twey> metaperl: Because JString doesn't offer anything beyond String (and you can easily convert to a JString by applying JString to a String)
13:33:32 <byorgey> pokoko222: I study programming languages, type systems, and the intersection of discrete math (esp. combinatorics) and CS
13:33:43 <bastl> fax: i understood parts of generic programming (e.g. package "regular"), only because I had some background in CT.
13:33:45 <sinelaw> my horse was raised in a Foreign.Stable
13:33:51 <bastl> or better it helped me alot.
13:34:12 * ddarius doesn't study CS.
13:34:19 * ddarius doesn't study.
13:34:32 * sinelaw doesn't.
13:34:40 <fax> ddarius you do so :P
13:34:41 * Zao
13:35:25 <roconnor> pokoko222: I study dependent type theory.
13:35:49 <copumpkin> pokoko222: I study the little-known martial art of counterninja
13:36:10 <copumpkin> I murder ninjas by being sneakier than them
13:36:29 <sinelaw> pokoko222, i studied electrical engineering (so the relevant "CS" part is cpu hardware engineering if you could say that)
13:36:33 <Zao> copumpkin wields cotanas.
13:36:47 <copumpkin> :P
13:36:56 * sinelaw studies how to get by studies with minimal effort
13:37:03 <sinelaw> and i also study _that_
13:37:36 <pokoko222> wow very usefull stuff, lord help me :;
13:37:37 <Phyx-> is there any reason why GHC only does instance head matching? or is it mostly no one implemented it otherwise?
13:37:49 <copumpkin> pokoko222: define useful
13:38:14 <sinelaw> cpu engineering is not useful
13:38:14 <pokoko222> before i was more into practical stuff, now i seem to like more logic, reasoning and AI and math
13:38:30 <sinelaw> unless you work in some hardware company, which i don't
13:38:39 <roconnor> pokoko222: you'll like dependent type theory then, cause it is the same as logic.
13:38:39 <liyang> It's all good for the soul.
13:38:44 <kynky> something full of use
13:39:12 <copumpkin> it's amazing
13:40:07 <pokoko222> to add to what i said, i like those but there are not many jobs for that
13:40:15 <pokoko222> and u have to be Phd ninja
13:40:32 <copumpkin> fuck jobs
13:40:35 <fax> fuck salt
13:40:39 <pokoko222> not that i am bad, i am first semestar now college and so far i got 10.0, hope i end so
13:40:55 <ClaudiusMaximus> pokoko222: my main use for Haskell is art - latest thing i made was a physical model of colliding circles, that triggered sounds using supercollider
13:40:55 <mightybyte> What is the "| m -> s" for in "class (Monad m) => MonadState s m | m -> s where"?  For some reason I've never noticed that before.
13:41:00 <Saizan> Phyx-: it has to do with allowing separate compilation
13:41:01 <copumpkin> fax: that sounds uncomfortable :/
13:41:07 <copumpkin> mightybyte: functional dependency
13:41:20 <copumpkin> mightybyte: says that the type in m fully specifies the type ins
13:41:22 <copumpkin> in s
13:41:31 <mightybyte> Ahh, ok.
13:41:44 <ddarius> "m determines s"
13:41:45 <pokoko222> ClaudiusMaximus that is kids games, i am talking here what to choose as life study and specialize in :D
13:41:45 <mightybyte> Is it required?
13:41:47 <metaperl> I want to develop a module which provides random latin-looking text in the spirit of a Perl module ( http://search.cpan.org/~adeola/Text-Lorem/lib/Text/Lorem.pm ) which does that.... should it be called Text.Lorem or TextLorem or just Lorem?
13:42:04 <copumpkin> mightybyte: it's required if that's the meaning you want :)
13:42:13 <ddarius> metaperl: The first.
13:42:15 * fax sighs
13:42:15 <mauke> Text.Random.Lorem?
13:42:15 * metaperl likes Text.Lorem
13:42:17 <metaperl> yes ddarius
13:42:18 <fax> shapr
13:42:21 <metaperl> ah
13:42:24 <copumpkin> mightybyte: with that fundep in place, you can't write instance MonadState Foo Bar and instance Foo Baz at the same time
13:42:25 <metaperl> interesting mauke
13:42:29 <liyang> pokoko222: Supposedly, I've studied bits of computing all the way from dependent types down to quantum physics via things like PL theory, CPU architecture and electronics. Not that I can remember all of it in any detail, but it's good for the soul to at least vaguely know what's going on at each level of abstraction.
13:42:32 <copumpkin> mightybyte: without it, you're allowed to
13:42:36 <gwern> camelcase and modules - two great tastes that don't go great together
13:42:37 <mightybyte> copumpkin: Ahhh, I see.
13:42:39 <metaperl> yes, I thnk you have thebest name mauke
13:43:00 <pokoko222> liyang u sound like the guy who knows it all and knows nothing :O
13:43:15 <copumpkin> I agree that it's good for the soul
13:43:22 <liyang> pokoko222: more you learn the less you realise you know.
13:43:29 <byorgey> copumpkin: you had that backwards, I think.
13:43:36 <Mathnerd314> ZipList is definitely a monad! http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23913
13:43:41 <gwern> 'nor need you regret the many hours spent on forgotten study / for the shadow of lost knowledge at least protects from many illusions'
13:43:42 <sinelaw> ClaudiusMaximus, i don't think it's a kids game. sounds cool.
13:43:46 <byorgey> You can't write MonadState Foo Bar and MonadState Baz Bar at the same time.
13:43:57 <byorgey> i.e. the same monad is not allowed to have two different state types.
13:43:58 <pokoko222> liyang i would give u 3 lives just to study quantum physics
13:44:04 <sinelaw> pokoko222, http://en.wikipedia.org/wiki/Dunning%E2%80%93Kruger_effect
13:44:25 <ddarius> Mathnerd314: You have to verify the laws,
13:44:28 <sinelaw> exact sciences are overrated.
13:44:35 <copumpkin> byorgey: yeah, sounds about right :) sorry!
13:44:53 <edwardk> sinelaw: congratulations =)
13:44:56 <ClaudiusMaximus> sinelaw: thanks :)
13:45:03 <copumpkin> if it's exact, is it a science?
13:45:16 <sinelaw> ClaudiusMaximus, link?
13:45:19 <sinelaw> edwardk, :)
13:45:31 <gwern> hm. wonder if anyone has written a suite of quickcheck tests to verify monad laws
13:46:03 <ddarius> @hackage checkers
13:46:03 <lambdabot> http://hackage.haskell.org/package/checkers
13:46:09 <copumpkin> damn, ddarius beat me to it
13:46:14 <ClaudiusMaximus> sinelaw: low quality digicam recording here http://claudiusmaximus.goto10.org/v/bowntz/bowntz-demo-1.ogv  (not sure if the code is anywhere online, will check later)
13:46:36 <pokoko222> ok I am going with logic, AI, human decision making and math. Wish me luck getting a job after college
13:46:38 <copumpkin> monad :: forall m a b c. (Monad m, Show a, Arbitrary a, CoArbitrary a, Arbitrary b, CoArbitrary b, Arbitrary (m a), EqProp (m a), Show (m a), Arbitrary (m b), EqProp (m b), Arbitrary (m c), EqProp (m c)) => m (a, b, c) -> TestBatch
13:46:42 <ddarius> copumpkin: With one hand.
13:46:54 <sinelaw> pokoko222, and also, as you study you might find new things that interest you
13:47:02 <copumpkin> pokoko222: that's a lot of stuff
13:47:06 <gwern> http://hackage.haskell.org/packages/archive/checkers/0.2.4/doc/html/Test-QuickCheck-Classes.html#v%3Amonad
13:47:07 <copumpkin> ddarius: doubleplusshame
13:47:09 <gwern> neat
13:47:15 <gwern> wonder how many broken monads there are out there
13:47:19 <edwardk> monad has quite the type signature there =)
13:47:21 <pokoko222> copumpkin well AI is logic, and human reasoning also so it gets down to logic and math
13:47:23 <byorgey> Mathnerd314: just because you can write a Monad instance for it doesn't mean it satisfies the monad laws.
13:47:32 <yitz> gwern: IO is a broken monad
13:47:39 <pokoko222> in other words Prolog for life ! :O
13:47:40 <byorgey> oh, ddarius already said that.
13:47:43 <fax> yitz nonsense
13:47:52 <sinelaw> pokoko222, also it's very hard to get a job at something that's actually deeply intellectually interesting. in my case i'm aiming for a fun moderately interesting job at 60-80% part time so i can do more stuff too
13:47:55 <yitz> fax: nope
13:48:04 <byorgey> Mathnerd314: ZipList is *almost* a monad.  In fact if you only use ZipLists with infinite lists, then it is =)
13:48:10 <ClaudiusMaximus> sinelaw: but basically the gist of the code is that it maintains a collection of all future collision times, updating it at each collision; then each frame it "fastforwards" the simulation through as many collisions as necessary to get to the time of the next frame
13:48:13 <pokoko222> sinelaw well i had a taste of all areas of cs and i think the above is the most interesting to me so far
13:48:15 <ddarius> pokoko222: Prolog sucks.
13:48:28 <gwern> another bad thing about hsell syntax - hard to nest ``s
13:48:38 <yitz> fax: unless you pretend that seq doesn't exist. but it does.
13:48:40 <edwardk> pokoko222: i went math/ai/computer science. good luck on the human decision making, humans are kinda boring. just make a reasonable guess at the worst choice possible and you'll approximate it quite well.
13:48:43 <Mathnerd314> byorgey: so when does it violate them?
13:49:06 <sinelaw> edwardk, i refer you to Mathematics and Plausible Reasoning, by G. Polya
13:49:08 <edwardk> gwern: io, omega, i think i have a broken writer somewhere
13:49:09 <liyang> pokoko222: Careful there. I've pretty much educated myself out of most software engineering jobs. Hoping to be able to get one hacking on Haskellâ¦ *fingers crossed*
13:49:17 <ddarius> edwardk: A mite cynical, eh?
13:49:18 <edwardk> sinelaw: have it, read it, loved it.
13:49:32 <sinelaw> edwardk, :) great so "human reasoning" isn't as boring as you make it sound
13:49:35 <copumpkin> liyang: move to portland and try galois!
13:49:44 <yitz> edwardk: if so pokoko222 has taken a good first step in demonstrating that by choosing that course of study.
13:49:47 <copumpkin> edwardk is a misanthropist
13:49:48 <liyang> What *is* the definition of AI these days anyway?
13:49:53 <edwardk> ddarius: pessimists give better estimates ;)
13:50:08 <copumpkin> there isn't a good definition as far as I know
13:50:10 <pokoko222> edwardk that is exactly what i am after, especially since i love arts, i have one year in film and theater college (dropped it out for cs) and i decided i dont want to direct films/plays, i want to write programs that make them
13:50:20 <pokoko222> mechanising art
13:50:23 <liyang> copumpkin: US + government contracts = not keen. :(
13:50:30 <ddarius> The space of bad choices is much bigger than the space of good choices.
13:50:35 <copumpkin> liyang: ah, hmm
13:50:41 <edwardk> sinelaw: i would argue that few human beings actually follow the process of mathematical plausible reasoning put forth by polya. ;)
13:50:46 <copumpkin> ddarius: 100% of choices are bad ones?
13:50:49 <bastl> mechanising arts sounds terrible.
13:50:58 <Phyx-> Saizan: Could you elaborate? (sorry wasn't paying attention here)
13:51:13 <fax> "If a twerp can screw things up, he will choose the worst possible time to screw things up"
13:51:15 <sinelaw> edwardk, he's trying to teach it, not claim that it's popularly used
13:51:17 <sinelaw> i think
13:51:24 <metaperl> ok, this ( http://github.com/metaperl/text-random-lorem/tree/master/Text/Random/ )  the proper directory structure for a module I want others to type import Text.Random.Lorem in order to use?
13:51:25 <Makoryu> pokoko222: Hmmm. It works for level design, it works for music... But it takes a fuckload of effort to get it right.
13:51:33 <liyang> Had a Facebook recruiter hunt me down a few weeks ago. Couldn't face the thought of hacking PHP for most of the working day. >_>
13:51:58 <copumpkin> liyang: yeah, sounds painful :/ but they do do some FP behind the scenes apparently, and even have a couple of haskell tools
13:51:59 <edwardk> sinelaw: sure. it is a great attempt to deconstruct how mathematicians actually approach problems, as opposed to what their finished, published results look like.
13:52:00 <fax> facebook -o-
13:52:12 <metaperl> what? you want faxbook?
13:52:13 <pokoko222> bastl after u watch dumb people for a year doing "art" trust me as programmer u get lot of ideas of automating art :D
13:52:14 <metaperl> :)
13:52:33 <mightybyte> liyang: Yeah, that's got to restrict the universe of good Haskell programmers that would be willing to work at Facebook.
13:52:39 <sinelaw> edwardk, yip :) still didn't go through it
13:52:51 <sinelaw> ClaudiusMaximus, absolutely awesome!
13:53:12 <pokoko222> Makoryu correct but that is why i say a "lifelong career" not something i plan to do for 3 years or 1 or a month or whatever...
13:53:21 <Makoryu> pokoko222: Good point.
13:53:22 <ddarius> sinelaw: Have you read "Proofs and Refutations"?
13:53:27 <sinelaw> nope
13:53:30 <Saizan> Phyx-: well, the ideal is that you'd always use the same instance for a given type, within a program, so with separate compilation you've to use an open world assuption, so you can never really decide that a certain type is not an instance of some class, which leads to ignoring class contexts
13:53:35 <Makoryu> pokoko222: Man, if you succeed at that, Hollywood would be indebted to you forever
13:53:46 <pokoko222> Makoryu i strongly believe in automating human decision making, maybe reading lot of philosophy and psychology hit my head :O
13:53:47 <liyang> copumpkin: wasn't what this guy was recruiting for. I get the impression that there are only a small handful of FP people there. Am aware of the Chat backend in Erlangâ¦ but in any case, I've got a thesis to finish before going anywhere.
13:53:48 <ClaudiusMaximus> sinelaw: :)
13:53:48 <metaperl> there's no discussion of hierarchical module names here - http://www.haskell.org/tutorial/modules.html
13:53:53 <Makoryu> pokoko222: By which I mean, they would take your work and never pay you for it
13:54:01 <copumpkin> liyang: fair enough :)
13:54:07 <sinelaw> ClaudiusMaximus, publish the code
13:54:21 <sinelaw> ClaudiusMaximus, or at least upload that video to youtube
13:54:38 <dskippy>  I have a data definition that looks something like this: "data Foo = Bar Int Int | Baz Int Int" I'd like to use the record syntax so that those Ints have names for clarify, but I don't see a way to use the record syntax but give them all one unifying type.
13:54:44 * liyang will open a coffee shop some day. Screw software engineering.
13:54:47 <ClaudiusMaximus> sinelaw: will do, eventually - but probably archive.org instead of youtube
13:54:53 <sinelaw> ok
13:55:06 <sinelaw> coffee engineering
13:55:11 <copumpkin> liyang: cofree shop!
13:55:22 <lament> you'll get eaten alive by starbucks
13:55:24 <pokoko222> Makoryu Hollywood would want to kill me man, a program taking all those dumb assses's money away :D
13:55:31 <lament> and by eaten alive i don't mean bought out
13:55:39 <sinelaw> "software engineering" is almost an oxymoron
13:55:43 <copumpkin> where Shop is a functor
13:55:54 <liyang> lament: Starbucks is the McDonald's of coffee.
13:56:04 <liyang> Consistently crap.
13:56:17 <Phyx-> Saizan: ah, think I understand. Thanks, I can work with that :)
13:56:25 <lament> liyang: so?
13:56:39 <liyang> lament: I don't see it as a threat. :3
13:56:42 <lament> i'm not saying your coffee won't be better than theirs, it very well might
13:56:44 <bastl> ddarius, you said that functors in CT can have more than one argument. what did you mean? Either :: Hask x Hask -> Hask ?
13:56:44 <Makoryu> pokoko222: On the contrary. They don't want to deal with these uppity actors, writers, and directors who imagine erroneously that they deserve somehow to be compensated for their services.
13:57:21 <liyang> lament: it already is, if I may claim so myself. It's really not that hard though.
13:57:26 <pokoko222> Makoryu breaking Hollywood is my dream dude, ok i am going logic and human reasoning, alelujaaaa
13:57:43 <Makoryu> pokoko222: Not to mention the lighting crews, set/costume designers, camera crews, electricians, local governments (location shooting)... I could go on
13:58:02 <pokoko222> it can all be automated
13:58:03 <copumpkin> is that rufus wainwright, jeff buckley, or leonard cohen?
13:58:18 <Makoryu> pokoko222: That's right, and Hollywood would have a blast with it
13:58:30 <Makoryu> "HOLY SHIT! WE NEVER NEED TO PAY ANYBODY EVER AGAIN!"
13:58:40 <pokoko222> u dont get it
13:59:06 <pokoko222> hollywood will end with that mortal, because everyone will make films at home, even 5 year olds... mommy look i clicked here, a movie yeiiii
13:59:14 <pokoko222> i think this is coming in 30 years
13:59:48 <pokoko222> natural language to logic goes fine, faster machines come...
14:00:19 <Makoryu> Whoa, don't even use "natural language" and "logic" in the same sentence
14:00:29 <Makoryu> Unless the sentence is "AHAHAHAHAHAHAHAHA"
14:00:32 <sinelaw> that's all we need, more crappy Hollywood films
14:00:48 <monochrom> Why is this channel becoming #haskell-blah ?
14:01:01 <sinelaw> it's them zygomorphisms
14:01:06 * Makoryu silently retreats into the shadows
14:01:58 <copumpkin> monochrom: because the operators aren't policing it enough
14:02:30 <lament> pokoko will revolutionize the world of computing
14:03:37 * fax remembers being like pokoko
14:03:38 <Makoryu> He's a free-thinking rebel who will replace scientists with artists and redefine all the rules
14:04:51 <yitz> the singularity is coming
14:05:07 <fax> yitz, really?
14:05:20 <yitz> fax: that was meant to be a slogan
14:05:32 <yitz> fax: some people believe it though
14:05:38 <gwern> well, moore's law is holding up well
14:05:41 <fax> yeah I was wondering if you did
14:05:43 <gwern> software still sucks though
14:06:19 <gwern> AI seems to make very little progress
14:06:20 <yitz> fax: no opinion. it's not coming within the next ten years, i'll venture a guess. :)
14:06:55 <orbitz> much like Comcast changing to xfinity, AI is rebranded to machine learning
14:07:25 <EvanR-work> comcast is still comcast here
14:07:35 <sinelaw> machine education it will be soon
14:07:39 <lament> death will be abolished in ~5 years
14:07:58 <EvanR-work> death will be illegal
14:08:14 <Saizan> and being off topic?
14:08:32 <EvanR-work> haskell will be illegal
14:08:57 <fax> lol
14:09:00 <kynky> lament and if it isnt abolished, thise who wont abolish it will be put to death
14:09:18 <medfly> lol
14:10:36 <monochrom> I heard a crackpot saying this the other day. "5 year olds are already writing code at home. in 15 years you will not get paid for writing haskell code, Galois won't need to hire you, just get code from haskelltube.com"
14:10:51 <medfly> heh
14:11:13 <scotd> i'm interested in writing a simple haskell interpreter... is the best resource to get started "The Implementation of Functional Programming Languages"? Other ideas?
14:11:13 <copumpkin> lol
14:11:14 <fax> what's crackpot about that?
14:11:18 <xerox> Here?
14:11:28 <fax> 99% of the web is written by teenagers in high school
14:11:32 <lament> is haskelltube.com registered?
14:12:05 <yitz> fax: are you deducing that from the quality of the code?
14:12:11 <nostrand> fax: 99% of all statistics are made up
14:12:16 <monochrom> scotd: I think yes.
14:12:27 * fax should have said 'almost all' :P
14:12:27 <sinelaw> scotd, i like that book
14:12:38 <olsner> nostrand: 99% of all statements are false
14:12:57 <Mathnerd314> no, it's undecidable.
14:12:59 <lament> 99% of every statement is false.
14:12:59 <tensorpudding> the remaining 1% are not able to be proven false
14:13:05 <medfly> hehe
14:13:23 <nostrand> olsner: but not you!
14:13:36 <yitz> Registrant Contact: haskelltube.com Private Registrant, A Happy DreamHost Customer
14:13:46 <lament> The falsity of this statement is obvious.
14:13:49 <liyang> 99% of 99% of all false statements are 98% false, approximately.
14:13:52 <Saizan> scotd: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.17.268 <- this is also nice as a starting point, though it implements a fairly minimal language
14:14:08 <scotd> monochrom, sinelaw: thanks
14:14:55 <metaperl> [^\sA-Za-z]   What would be the way to filter a string of everything that doesnt match this regular expression [^\sA-za-z]
14:16:08 <scotd> saizan: if i only want to take a string as input and give a string as output, would that paper apply? i see it discusses monads
14:16:09 <xerox> ?type not . liftM2 (||) isAlpha isSpace
14:16:10 <lambdabot> Char -> Bool
14:16:13 <byorgey> metaperl: is that a triple negative?
14:16:25 <byorgey> you don't want things that don't match a negated character class?
14:16:35 <metaperl> lol
14:16:43 <metaperl> oh
14:16:57 <byorgey> metaperl: anyway, you want to use 'filter' in combination with 'elem' or 'notElem'
14:17:00 <metaperl> I only want the things that match [\sA-Za-z]
14:17:12 <metaperl> ick
14:17:14 <copumpkin> what Saizan wrote
14:17:18 <xerox> ?type filter (liftM2 (||) isAlpha isSpace)
14:17:18 <metaperl> too much work
14:17:19 <lambdabot> [Char] -> [Char]
14:17:25 <copumpkin> wtf
14:17:28 <copumpkin> xerox, I mean
14:17:37 <monochrom> Oh nice, I don't have to suggest using a regex library. :)
14:17:50 <byorgey> xerox: noce =)
14:17:54 <metaperl> I think this chapter in RWH is what I need  - http://book.realworldhaskell.org/read/efficient-file-processing-regular-expressions-and-file-name-matching.html
14:17:56 <byorgey> nice, even
14:18:00 <xerox> :D
14:18:01 <metaperl> but the filter thing is nice too
14:18:17 <copumpkin> screw regular expressions
14:18:22 <Saizan> scotd: it uses monads to carry the environment/heap, dealing with errors etc.. not for I/O
14:20:00 <scotd> Saizan: thanks, downloading it now
14:21:09 <copumpkin> if <=< is kleisli composition, is =<< kleisli application?
14:22:14 <copumpkin> :t (=<<)
14:22:15 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
14:22:36 <Saizan> i think it's called kleisli star
14:24:30 <Null-A> Hi, i'm learning haskell for the first time. I just installed hugs, and am following a haskell tutorial
14:24:42 <xerox> nice :)
14:24:42 <EvanR-work> what magical enchantments are you guys talking about
14:24:48 <Null-A> when I type "inc n = n+1" I get an error?
14:24:57 <lament> that's not a question!
14:24:58 <Null-A> this in from the tutorial
14:25:04 <lament> that's a statement, disguised as a question.
14:25:18 <gwern> Null-A: the interpreter only evaluates expressions, it doesn't define functions
14:25:19 <EvanR-work> Null-A: you cant declare things in the interpretr
14:25:20 <xerox> Null-A: you need to input expressions like âlet inc n = n+i in inc 10â
14:25:21 <Saizan> Null-A: you've to put that in a source file
14:25:29 <lament> xerox: wont work in hugs
14:25:42 <gwern> lament: one reason we don't recommend hugs for beginners any more
14:25:42 <Saizan> lament: note the in
14:25:47 <xerox> lament: I don't think so
14:25:50 <olsner> ah, if ever there was a time for a stereo quote :P
14:25:52 <lament> Null-A: a good first step would be to install GHC instead of Hugs.
14:25:54 <tensorpudding> no one uses hugs anymore
14:25:56 <Null-A> I can put it in a file.. I thought it was conivient to learn from an interpreter though? is this not possible
14:26:05 <lament> hug a beginner today
14:26:13 <Null-A> lament: I can also do this, I heard hugs had better error messages, but if you think GHC is a better choice.. i will try it
14:26:14 <lament> Null-A: it is possible. Install GHC.
14:26:24 <Saizan> Null-A: you can evaluate expressions in the interpreter, definitions go in a file
14:26:37 <lament> Null-A: Then type "let inc n = n+1" and it will work.
14:26:41 <tensorpudding> If you are on Windows or Mac OSX, you should install the Haskell Platform
14:26:45 <Null-A> Does GHC have an interpreter like hugs?
14:26:48 <lament> yes.
14:26:52 <tensorpudding> Null-A: yes, it's called GHCi
14:27:09 <Null-A> tensorpudding: haskell platform doesn't work on snow leopard right?
14:27:11 <Saizan> which tutorial are you following?
14:27:14 <monochrom> you type "ghci" at the command prompt.
14:27:17 <kynky> more powerful than hugs
14:27:17 <Null-A> I'm having to use a VM running ubuntu
14:27:22 <Makoryu> Null-A: In my experience, Hugs' error messages aren't any better than ghci's
14:27:28 <gwern> Makoryu: now
14:27:33 <Null-A> Makoryu: k
14:27:36 <ivanm> Null-A: there is a way of getting it to work IIRC
14:27:47 <Null-A> Saizan: A gentle introduction to haskell
14:27:50 <monochrom> Oh ghc in ubuntu in VM works great. I'm doing it. Of course hugs is fine too.
14:27:54 <ivanm> Null-A: and the next release comes out next month, which might work
14:28:04 <Null-A> ivanm: *nods* I figured
14:28:05 <sinelaw> is there something nice that wraps flags?
14:28:23 * Null-A resumes tutorial =) thx
14:28:26 <sinelaw> like bla = 1, bleh = 2, bloh = 4, blih = 8, ...
14:28:47 <Saizan> wraps flags?
14:28:48 <sinelaw> myFunc $  bla .|. bleh
14:28:49 <tensorpudding> I think GHC has a problem with 64-bit Snow Leopard, but I don't know for positive
14:28:50 <ivanm> sinelaw: in what sense?
14:28:56 <Saizan> oh, bitmasks?
14:29:00 <sinelaw> exactly
14:29:00 <ivanm> command-line flags?
14:29:14 <ivanm> sinelaw: do it "under the hood"
14:29:22 <sinelaw> the kind of things you pass to some c functions
14:29:25 <gwern> sinelaw: I think .|. binds higher than $
14:29:30 <ivanm> sinelaw: see the RWH chapter on FFI when they do a libpcre binding
14:29:33 <ddarius> Yep
14:29:46 <ivanm> they do that kind of stuff in there
14:29:54 <sinelaw> k
14:30:27 <Mathnerd314> so is there some sort of tutorial for how to use quickcheck?
14:31:21 <ivanm> Mathnerd314: RWH has a chapter (on QC-1)
14:31:36 <ivanm> dibblego had a decent tutorial up online (again only on QC-1)
14:32:07 <sinelaw> ivanm, thanks that's what i need :)
14:32:17 <ivanm> sinelaw: no worries ;-)
14:36:21 <sinelaw> anyone aware of an emacs macro to convert to camel case?
14:37:01 <stepcut> is there a way to listen on a specific ip address that works under Windows, OS X, and Linux, and which which works whether or not IPv6 is enabled or not?
14:37:02 <sinelaw> upcase-initials-region is close
14:37:24 <sinelaw> libpcap?
14:37:34 <metaperl> is there an idiom for calling a function which will randomly sample a list?
14:37:44 <gwern> stepcut: create a typeclass and then write 3 backends?
14:37:45 <ivanm> sinelaw: from what?
14:37:50 <metaperl> stepcut: hi. you still work in San Diego?
14:38:02 <ivanm> I've seen one (not sure where though) that converts foo_bar to fooBar
14:38:10 <sinelaw> that's what i want
14:38:12 <ivanm> look at the emacs wiki
14:38:16 <sinelaw> k
14:38:17 <ivanm> pretty sure that's where it was
14:38:20 <stepcut> metaperl: sort of..
14:38:22 <ivanm> @google emacs camel case
14:38:23 <lambdabot> http://www.emacswiki.org/emacs/CamelCase
14:38:24 <lambdabot> Title: EmacsWiki: Camel Case
14:38:30 <ivanm> sinelaw: ^^ ;-)
14:38:37 <stepcut> metaperl: I live in Chicago, but I work for a San Diego company
14:38:47 <metaperl> yes, I remember
14:38:48 <metaperl> I see
14:39:24 <stepcut> gwern: hmm. that doesn't really solve the problem -- the ipv6 won't compile if ipv6 is not enabled. But I do not know how to tell if network was compiled with ipv6 or not
14:39:24 <sinelaw> :)
14:39:49 <gwern> stepcut: do a test compilation from setup.hs and set cpp flags?
14:39:51 <gwern> dunno
14:40:12 <ivanm> pretty sure in linux you need to enable ipv6 in the kernel to have ipv6 working...
14:41:20 <stepcut> gwern: yeah, that is how Network does it .. seemed silly to duplicate that mess in my own code though :(
14:41:56 <yitz> ivanm: that's true of almost everything in linux. most distros enable everything you ever remotely dream of using by default.
14:48:24 <sinelaw> @pl (\a b c d e f g -> h a b c d e (k f) g)
14:48:24 <lambdabot> flip flip k . ((flip . ((flip . ((flip . ((.) .)) .)) .)) .) . h
14:48:28 <sinelaw> hoooooooooray
14:48:58 <sinelaw> that flip is a flop
14:49:02 <fax> @pl flip flop
14:49:03 <lambdabot> flip flop
14:49:42 <enthymene> O.O
14:49:49 <enthymene> mind blown
14:50:07 <enthymene> O.O <-- enthymene  @@ <--- enthymene's mind
14:50:11 <NEEDMOAR> @pl (\x y -> flop y x)
14:50:11 <lambdabot> flip flop
14:50:23 <Raynes> Haha.
14:50:27 <copumpkin> NEEDMOARPHISMS
14:51:27 <ivanm> @quote xerox morphism
14:51:27 <lambdabot> xerox says: <dons> then again, bots themselves are simple  <xerox> "...they are just a morphism in the category of IRC channels together with an endomapping ..."
14:51:48 <ivanm> copumpkin: we have 3 bots here, ergo according to xerox we _have_ morphisms!
14:51:53 <copumpkin> nice
14:51:57 <copumpkin> @quote moarphisms
14:51:57 <lambdabot> tensorpudding says: lolcategory demands moarphisms
14:52:31 <sinelaw> so, cabal doesn't really run hsc on my files
14:52:33 <sinelaw> apparently
14:52:43 <sinelaw> because it complains about invalid syntax
14:53:30 * ivanm wildly guesses that sinelaw is running 6.12 and the problem is due to encoding
14:53:48 <sinelaw> 6.10.4
14:54:17 <sinelaw> i'll run cabal clean
14:54:30 <ivanm> hmm...
14:54:36 <sinelaw> may help cause i had a Module.hs, and i renamed it to .hsc
14:54:38 <Mathnerd314> I'm still confused about why ZipList isn't a monad...
14:54:44 <sinelaw> nope :(
14:55:00 <ivanm> that's the problem with 6.12 IMHO: you're pretty much stuck with ASCII for source files because of encoding problems on different platforms, etc. :@
14:55:03 <copumpkin> Mathnerd314: did you find an instance that satisfied the laws?
14:55:09 <copumpkin> Mathnerd314: it could be done easily with sized lists
14:55:15 <ivanm> Mathnerd314: I thought there was a monad instance...
14:55:22 <sinelaw> ivanm, it dies when checking the interface
14:55:40 <ivanm> "interface"?
14:55:47 <sinelaw> *** Checking old interface for HOpenCV-0.1:AI.CV.OpenCV.CV:
14:55:48 <sinelaw> [5 of 5] Compiling AI.CV.OpenCV.CV  ( dist/build/AI/CV/OpenCV/CV.hs, dist/build/AI/CV/OpenCV/CV.o )
14:55:48 <sinelaw> *** Parser:
14:55:48 <sinelaw> src/AI/CV/OpenCV/CV.hsc:58:0: Invalid type signature
14:55:53 <Mathnerd314> copumpkin: the one I posted to hpaste seemed to work
14:56:03 <copumpkin> Mathnerd314: work in what sense?
14:56:07 <ivanm> sinelaw: wild guess that its deps aren't strict enough
14:56:14 <ivanm> check the build log on hackage
14:56:23 <Mathnerd314> I couldn't find any examples that failed the 3 laws
14:56:36 <copumpkin> proof by example! :)
14:56:46 <sinelaw> ivanm, it's local, not hackage
14:56:48 <copumpkin> I mean, it may be correct
14:57:04 <Mathnerd314> so how would I prove correctness?
14:57:05 <ivanm> sinelaw: oh, your own code?
14:57:09 <sinelaw> ivanm, yeah
14:57:20 <copumpkin> Mathnerd314: what does join do on your instance?
14:57:24 <copumpkin> conceptually
14:57:33 <Mathnerd314> join is >>=?
14:57:37 <ivanm> sinelaw: then fix your bug!
14:57:38 <copumpkin> join is >>= id
14:57:40 <ivanm> Mathnerd314: no
14:57:45 <ivanm> @src join
14:57:45 <lambdabot> join x =  x >>= id
14:57:48 <sinelaw> ivanm, it's no bug. hsc2hs produces valid code
14:57:57 <sinelaw> let me verify.
14:57:57 <copumpkin> Mathnerd314: it's a cleaner way of characterizing a monad, in my opinion
14:58:39 <sinelaw> ok it's a bug :) i'll find it now.
14:58:50 <sinelaw> i was sure it's a cabal/hsc2hs problem
14:58:59 <copumpkin> > join [[1,2,3],[4,5,6],[7,8,9]] -- Mathnerd314 for example, the ZipList'd version of that, what does it return?
14:59:00 <lambdabot>   [1,2,3,4,5,6,7,8,9]
14:59:08 <dark> is cabal like rubygems?
14:59:18 <copumpkin> dark: a bit more sophisticated, but same general idea, yep
14:59:36 <sinelaw> yip :) my mistake.
14:59:36 <metaperl> on line 15 ( http://pastie.org/pastes/865783 ) I want to randomly sample a list... but my attempt to extract a value from a monad is failing. please help.
15:00:02 <metaperl> dark: have you seen hackage.haskell.org
15:00:24 <dark> copumpkin, the common criticism of rubygems is that it can't describe dependencies on non-ruby programs, and will not enable distribution packagers to aggregate such dependencies. do this holds for cabal as well?
15:00:29 <dark> metaperl, no
15:00:41 <metaperl> I think that is what cabal references
15:00:45 <c_wraith> metaperl: the "nth" function you have is basically the same as !!
15:00:53 <ivanm> dark: no, Cabal is a library
15:00:56 <metaperl> c_wraith: oh I had forgotten about that
15:01:04 <dolio> Yes. Cabal doesn't really know about dependencies that aren't cabalized.
15:01:05 <Mathnerd314> copumpkin: 1,3,7
15:01:09 <dark> [ hmm, rubygems is like a library too, i guess ]
15:01:09 <Mathnerd314> *1,4,7
15:01:11 <metaperl> ivanm: it has command line access though, right?
15:01:21 <ivanm> dark: oh, I thought rubygems was a command line tool
15:01:23 <dolio> At least, not automatically.
15:01:26 <ivanm> metaperl: no, cabal-install /= cabal
15:01:30 <dark> hm
15:01:35 <jmcarthur> dark: cabal-install doesn't track non-haskell dependencies
15:01:37 <c_wraith> metaperl: also, you really shouldn't be thinking of list as a monad for what you're doing in that function.  It's just a list.
15:01:53 <ivanm> jmcarthur: well, it does to the extent that it tells you that it needs C lib foo ;-)
15:01:54 <jmcarthur> dark: but cabal plays nice with package managers, afaik
15:01:57 <Mathnerd314> copumpkin: so probably the first of each list
15:02:00 <metaperl> yes I just want to get a random integer and then pull that element out of hte list
15:02:03 <ivanm> the librarcy Cabal does, yes
15:02:10 <jmcarthur> right
15:02:12 <ivanm> gentoo uses wrappers around cabal for its ebuilds
15:02:14 <copumpkin> Mathnerd314: what if a list is empty?
15:02:18 <ivanm> *library
15:02:25 <metaperl> c_wraith: I dont know monads yet. And I wasnt trying to use the list as a monad. I only used monads to make random numbers
15:02:29 <Mathnerd314> copumpkin: then it's the elements up to the first empty one
15:02:42 <jmcarthur> and arch has tons of packages from hackage which i think just involved the Setup scripts
15:02:50 <dark> the problem is that when you actually depend on external things like gtk, and when you ask your system to install the app, it will not install gtk - so you have to install it manually....
15:02:52 <jmcarthur> *invoke the Setup scripts
15:02:53 <copumpkin> Mathnerd314: did you try running your instance through checkers, by the way?
15:02:54 <dark> seems ugly
15:02:57 <c_wraith> metaperl: ah, I see what you were thinking.  Try making the type signature [a] -> IO a
15:03:18 <ivanm> dark: that's why you use distribution packages where possible rather than cabal-install
15:03:22 <Mathnerd314> copumpkin: couldn't figure out how
15:03:24 <dark> hmm
15:03:30 <c_wraith> metaperl: your other main option for the type signature is something like RandomGen g => [a] -> g -> (a, g)
15:03:30 <jmcarthur> dark: under Arch Linux, at least, we just add the dependencies not tracked by cabal to the PKGBUILD and we're good
15:03:32 <Mathnerd314> copumpkin: be back in ~10 min
15:03:34 <ivanm> are you trying to say that rubygems would install the C library gtk+ for you if needed?
15:03:35 <copumpkin> ok
15:03:45 <dark> hm
15:03:46 <jmcarthur> yeah i don't know how else it could be done
15:04:07 <metaperl> I think I'm in trouble
15:04:25 <metaperl> dead in thewater trying to skate over monads to get his done
15:04:26 <copumpkin> metaperl: GO TO THE PRINCIPAL'S OFFICE NOW
15:04:31 <metaperl> copumpkin: lol
15:04:42 <dark> ivanm, the problem is, the ruby community has a open-source style of sharing their code with rubygems, putting them on git repositories etc. this is great, but this also means that you can't install an app or use a library from that source without breaking the package management
15:05:02 <dark> at least in debian, the process of adding new libraries is bureaucratic and slow
15:05:04 <dark> .-.
15:05:25 <ivanm> I hate that idea
15:05:32 <jmcarthur> dark: in arch you can just upload any package to AUR willy nilly (it's not a core repository, but there are many interfaces for it)
15:05:32 <ivanm> if you want people to use your code, then release it
15:05:38 <ivanm> don't tell them to get the live versioni
15:05:40 <ivanm> *version
15:05:44 <ivanm> @quote dcoutts hackage
15:05:44 <lambdabot> dcoutts says: remember, if it's not on hackage it doesn't exist!
15:05:45 <dark> I want a meta-system that will handle both distro packages, and language-specific packages! :(
15:05:58 <ivanm> dark: then get a better distro
15:06:07 <jmcarthur> yeah, arch or gentoo
15:06:13 <dark> :) seems like a reasonable advice, ivanm
15:06:21 <dark> jmcarthur, yes, because arch is non-intrusive..
15:06:31 <ivanm> "non-intrusive"?
15:06:32 <metaperl> c_wraith: the new code ( http://pastie.org/pastes/865793 ) has a syntax error in line 16:             where n <- getStdRandom $ randomR (0, lastIndex xs)
15:06:38 <jmcarthur> i don't understand
15:06:41 <dark> it will not modify too much the programs, ivanm
15:07:05 <c_wraith> metaperl: well, <- only is defined inside do blocks.
15:07:13 <dark> debian has the to go thought the trouble of applying their policy on all and every package
15:07:24 <jmcarthur> dark: true, most arch packages are fairly vanilla, but my point was that arch and gentoo both have very good package management
15:07:31 * hackagebot hack-handler-cgi 0.2.0.1 - Hack handler using CGI protocol.  http://hackage.haskell.org/package/hack-handler-cgi-0.2.0.1 (MichaelSnoyman)
15:07:32 <dark> hm
15:07:34 * metaperl speed-reads http://koweycode.blogspot.com/2008/07/simple-random-numbers-in-haskell.html  ... ok c_wraith I see...
15:08:00 <dark> jmcarthur, so the problem in reality is that dpkg isn't flexible enough?
15:08:29 <jmcarthur> dark: it's that debian isn't flexible enough. it's the policies behind debian packages that is the problem
15:08:50 <jmcarthur> where by "
15:08:52 <jmcarthur> oops
15:09:03 <jmcarthur> where by "debian" i mean the people behind it, not the technology
15:09:07 <metaperl> I think randomR is what I want
15:09:22 <dark> hm
15:09:30 <jmcarthur> the process, that is
15:10:18 <jmcarthur> too afraid to allow arbitrary and cutting edge packages into the system. i understand that debian unstable is nicer than stable in that regard, but still doesn't take it far enough in my opinion
15:10:43 <jmcarthur> and not enough tool support for integrating other language packagers and stuff
15:10:50 <dark> i hate things like.. apache configs on debian is on /etc/apache2, and on fedora is on /etc/httpd, ... this is pointless, no reason to change the upstream default (whatever it is) with no apparent reason
15:11:16 <jmcarthur> for some cases i think it's fine, but i think debian does too much of it
15:11:35 <dark> jmcarthur, in both arch and gentoo, the process of adding new dependencies to language-specific packages, like cabal, will be manual, right? you have to edit a file to add this dependencies..
15:11:54 <jmcarthur> dark: i think that is inevitable
15:11:56 <dark> couldn't this be automatized? i would be very nice with it
15:12:00 <metaperl> is there a tutorial for separating getting and using a random number generator
15:12:02 <jmcarthur> dark: fortunately that is usually dont for you
15:12:05 <jmcarthur> *done for you
15:12:05 <liyang> dark: fits in with the /etc/package-name hierarchy you'd expect from Debian though.
15:12:09 <dark> well, you are talking about computers
15:12:16 <liyang> dark: plus apache2 is not the only httpd.
15:12:34 <jmcarthur> dark: well, we can't very well put fields into our .cabal files listing distro-specific packages
15:12:41 * copumpkin + netcat = httpd
15:12:48 <dark> liyang, well i do agree, but the upstream should choose the directory (i don't know which is the upstream default)
15:13:37 <dark> jmcarthur, no, the system could deduce it with linking information -- not with current packaging technology, but, we are talking about computers. the computer itself has enough information most of cases
15:13:48 <ivanm> dark: gentoo is like arch in that, in that gentoo tries to be as up-stream as possible
15:14:06 <ivanm> the only time Gentoo patches something is when it doesn't build (or sometimes porting an upstream bug-fix)
15:14:08 <jmcarthur> does up-stream mean the same thing as "vanilla" here?
15:14:41 <dark> i hate when there are excessive manual labor even with cutting edge technology - technology that is supposed to remove it..
15:14:57 <jmcarthur> dark: perhaps, but we don't have that. why don't you implement it? :)
15:14:59 <jmcarthur> it would eb nice
15:15:07 <jmcarthur> really though, we're not talking about that much manual labor
15:15:14 <dark> hahahahaha. :) i wish i could do such things :~
15:15:38 <dark> but i think it's like type inference. C++ was created about the same time as ML, but only now is considering having an 'auto' type
15:15:40 <jmcarthur> for hackage packages we have a script that automatically generates a package for AUR and then we just add additional dependencies as needed. at least that's my understanding of what we do
15:15:59 <jmcarthur> C++'s auto keyword isn't really type inference, even
15:16:09 <dark> hmm really? what it is, then?
15:16:48 <jmcarthur> dark: it's not very general anyway. you have to have a constructor or literal on the rhs for it to even work
15:17:07 <jmcarthur> the compiler can't just infer the type if it's not assigned until later
15:17:10 <ivanm> jmcarthur: we do something similar on gentoo, except we tweak the generated ebuild more (to check deps make sense and to add USE flags for custom compilation) which is why we dont' churn them out as much as arch does
15:17:23 <copumpkin> jmcarthur: wow, I didn't realize it was that shitty
15:17:31 <dark> (what is rhs?)
15:17:39 <ivanm> dark: right hand side?
15:17:44 <jmcarthur> yes
15:17:59 <jmcarthur> copumpkin: well, it's still nicer than the alternative. it sucks to type out long template code
15:18:02 <dark> hm, grammar rules?
15:18:08 <sinelaw> like C# .NET 3.5's  'var' type
15:18:24 <jmcarthur> copumpkin: which i think is a barrier to using C++ templates more :\
15:18:53 <copumpkin> yeah :)
15:18:57 <copumpkin> gotta love that stuff
15:18:59 <fax> win 12
15:19:16 <jmcarthur> honestly, C++ templates wouldn't be so horrible if it wasn't for the terrible syntax and header file requirements
15:19:20 <Mathnerd314> copumpkin: disregard previous statements, join on ZipLists is the diagonal of the table formed by the list of lists
15:19:22 <copumpkin> what's the client that people keep typing win K into?
15:19:28 <copumpkin> I've seen quite a few people do it
15:19:40 <copumpkin> Mathnerd314: ah yes, that's the usual monad instance then
15:19:52 <copumpkin> Mathnerd314: but unfortunately, you can't guarantee preconditions unless you have sized lists
15:20:04 <copumpkin> there's no guarantee that you'll even have a diagonal
15:20:06 <jmcarthur> Mathnerd314: and that's also join on Streams
15:20:28 <Mathnerd314> well, for finite lists, you stop whenever there's no diagonal
15:20:31 <ivanm> copumpkin: hmmm?
15:20:54 <jmcarthur> Mathnerd314: but does that obey monad laws?
15:21:08 <copumpkin> fax: what was that "win K" you typed? I've seen quite a few people do that and have wondered
15:21:29 <fax> fnord 7
15:21:30 <HugoDaniel> im trying out some experiences with opengl in haskell
15:21:38 <Zao> copumpkin: /window NN to change IRC client window.
15:21:38 <copumpkin> :o
15:21:52 <copumpkin> not on my client :)
15:21:57 <Zao> On sane clients :)
15:22:03 <Mathnerd314> jmcarthur: I think so, but I don't know how I'd prove it
15:22:27 <fax> Mathnerd use (co)induction
15:22:33 <ivanm> "sane" == irssi?
15:22:39 <Zao> Among others, yes.
15:22:39 <dark> jmcarthur, you say it's not that much labor, but i found amazing that in 2010 each distro needs to duplicate the packaging effort, simply because they need to input manual data for each package, and each packaging system stores and uses incompatible subsets of available data about relationships between programs
15:22:45 <Mathnerd314> fax: on the size of the list?
15:22:54 <Mathnerd314> there are too many of them...
15:23:03 <Alpounet> oh
15:23:06 <copumpkin> too many lists!
15:23:09 <Alpounet> when I come back
15:23:10 <jmcarthur> dark: but that's simply what makes each distro different from each other
15:23:10 <fax> Mathnerd314, well it's possibly to do induction on the actual data.. rather than natural numbers
15:23:12 <Alpounet> again a C++ troll
15:23:18 <Alpounet> are you watching me ?
15:23:31 * copumpkin stares at Alpounet 
15:23:35 <ivanm> dark: ummm.... it's not that hard...
15:23:41 <jmcarthur> dark: they track dependencies differently. that's just a fact
15:23:54 * Alpounet stares at copumpkin
15:23:56 * ivanm looks at the screen hooked up to the spy cam looking at Alpounet
15:24:02 <Alpounet> heh
15:24:15 <kalven> http://www.reddit.com/r/haskell/comments/apd0b/variadic_functions_in_haskell/c0iqp75 <- can anyone show how a function like he describes could be implemented?
15:24:22 <Alpounet> I'm sure sinelaw put something in his code to broadcast my webcam capture
15:24:35 <ivanm> kalven: like printf?
15:24:40 <Alpounet> "yeah, it is an OpenCV binding"
15:24:42 <sinelaw> hah :)
15:24:46 <Alpounet> :p
15:25:03 <sinelaw> darn, you're on to me and i didn't finish that part yet
15:25:04 <copumpkin> kalven: [a] -> b :P
15:25:12 <ivanm> kalven: or exactly like in the sample file paczesiowa links to?
15:25:18 <kalven> ivanm: no, one that takes a prime number of string arguments, but with integers at indices matches fibonacci numbers
15:25:28 <Alpounet> yeah, that's what you say
15:25:36 <ivanm> kalven: oh...
15:25:36 <Mathnerd314> ok, I can see a proof by double/triple induction on the maximum size of the 3 monad functions
15:25:50 <dark> jmcarthur, well, yes, but if a system gather the data without manual intervention, it can track dependencies in any way it wish
15:25:55 <ivanm> kalven: *shrug* it's probably possible but why would you want to?
15:26:00 <ivanm> it would require a bit of fiddling
15:26:09 <sinelaw> Alpounet, working on face recognition (haar cascades) now
15:26:09 <copumpkin> kalven: you'd just throw a runtime error
15:26:10 <ivanm> in reality, paczesiowa was probably over-exaggerating
15:26:13 <kalven> ivanm: I'm just curious to see what it would look like
15:26:17 <ickabob> http://codepad.org/gLbtZ6Kp  could somone explain to me this syntax error?
15:26:17 <ivanm> fugly
15:26:18 <copumpkin> you could probably encode it in types, but that's painful
15:26:24 <jmcarthur> dark: well, have fun figuring out how to gather that data
15:26:25 <copumpkin> ivanm: as opposed to under-exaggerating?
15:26:32 <jmcarthur> i really don't think it's as easy as you are making it sound
15:26:34 <kalven> copumpkin: I'm interested in a static solution
15:26:35 <Alpounet> sinelaw, like just drawing the face of the guy being captured ?
15:26:45 <ivanm> ickabob: no space between Shape and (...)
15:26:51 <Alpounet> or some drawing around his face ?
15:26:53 <dark> jmcarthur, it's not, but most of it is already there
15:26:55 <copumpkin> kalven: you'd need to do a lot of type-level programming for that
15:26:56 <ivanm> copumpkin: exactly!
15:27:06 <ickabob> thanks
15:27:07 <copumpkin> kalven: it is possible though
15:27:19 <jmcarthur> dark: so you think dependencies can be discovered for every single software package out there?
15:27:21 <sinelaw> Alpounet, finding areas in the image that contain faces
15:27:23 <kalven> copumpkin: how much is a lot?
15:27:27 <ivanm> ickabob: error messages sometimes get the line number wrong (so look about +- 2)
15:27:28 <sinelaw> or other objects
15:27:30 <kalven> roughly..
15:27:33 <dark> jmcarthur, no, in some cases there could have ambiguities
15:27:34 <sinelaw> given a haar cascade to detect them
15:27:34 <ivanm> but the thing about ... gave it away ;-)
15:27:41 <jmcarthur> dark: as well as installation instructions?
15:27:48 <copumpkin> kalven: you want to encode your primality test into a type-level statement
15:27:48 <jmcarthur> and building, before that?
15:27:56 <jmcarthur> descriptions?
15:28:06 <fax> prime numbers in the type system?? haha
15:28:10 <Alpounet> ok
15:28:11 <fax> what
15:28:12 <Alpounet> nice sinelaw
15:28:15 <dark> jmcarthur, hmmm.. well, it's not possible to automatize everything
15:28:30 <dark> i have a lib here that simply have the installation path hardcoded
15:28:31 <sinelaw> Alpounet, it's more or less built in to opencv
15:28:32 <ickabob> hmm, that didnt seem to do the trick
15:28:33 <dark> o.o
15:28:34 <sinelaw> so it's no problem
15:28:34 <jmcarthur> dark: really, dependency tracking is *far* easier than all the other necessary parts of package management
15:28:42 <sinelaw> *into
15:28:48 <dark> hmm
15:28:56 <jmcarthur> as far as manual process goes, i mean
15:29:02 <fax> kalven, this is trivial if you use the correct language, but haskell is not it
15:29:24 <kalven> fax: fair enough.. which one is?
15:29:36 <fax> anything with full spectrum dependent types
15:30:07 <dark> jmcarthur, but I would love a packaging system that I can supply an auxiliary program that will take care of rubygems and then it just.. works, from now on
15:30:43 <dark> and both packaging systems would have a bridge, being interoperable
15:31:23 <jmcarthur> dark: that would require fundamentally different package managers to find a way to play nice
15:31:24 <applicative> ickabob: shouldnd't it be (..)
15:31:48 <dark> jmcarthur, yes, i think so too o.o
15:31:52 <ivanm> dark: *cough* the new ruby eclasses that flameeyes et. al. are writing for gentoo *cough*
15:32:11 <dark> eclasses?
15:32:15 * jmcarthur doesn't even know about ruby stuff on arch. i don't really do ruby anymore
15:32:16 <applicative> ickabob: I mean (..) rather than (...)
15:32:45 * copumpkin <$> applicative <*> applicative
15:32:51 <ivanm> dark: the libraries used for package management on gentoo
15:32:58 <ivanm> to avoid duplication of package management stuff
15:33:08 <dark> :)
15:33:14 <ivanm> e.g. for haskell stuff, all the calling-cabal stuff is done in the haskell.eclass
15:33:23 <dark> it's nice to hear about improvements happening right now
15:33:27 <dark> hmmm o.o
15:33:35 <dark> interesting o.o
15:33:56 <Alpounet> sinelaw, yeah but that means it's already ported to Haskell
15:33:58 <Alpounet> that part, I mean
15:34:00 <Alpounet> which is nice :)
15:34:03 <ivanm> so for simple libraries we just have to specify where to get it, homepage, description, architectures supported and dependencies
15:34:22 <ivanm> and all of those can be auto-generated using our hackport tool (though we have to usually tweak the deps a little bit)
15:34:37 <sinelaw> Alpounet, what do you mean? the bindings i'm building are manual labor
15:34:45 <dark> some people say that FP (with concurrent implementations, like haskell or erlang) will dominate the multi-core computing in near or mid-future, because it's hard to make good use of all cores without FP
15:34:53 <T_S_> Does any body know if the OpenGL bindings support antialiasing for filled polygons? My polygons look jaggy and it bothers my users and I can't blame them.
15:35:10 <sinelaw> erlang isn't really FP
15:35:22 <sinelaw> T_S_, they do.
15:35:24 <jmcarthur> T_S_: the opengl bindings support everything afaik
15:35:26 <ivanm> sinelaw: in what sense isn't it?
15:35:34 <dark> erlang isn't pure, right?
15:35:38 <sinelaw> not pure
15:36:01 <dark> but it has a high degree of parallelism. maybe haskell could do better, for being more pure. i'm not sure
15:36:06 <jmcarthur> aren't effects always outside of the erlang processes themselves though?
15:36:16 <sinelaw> erlang has manual concurrency afaik
15:36:35 <sinelaw> but i don't know
15:36:43 <sinelaw> T_S_, if you're doing 2d i recommend graphics-drawingcombinators
15:36:44 <jmcarthur> dark: haskell already does better for most situations. erlang is better for a small number of situations
15:36:48 <ivanm> sinelaw: ummm... haskell is a pure FP language
15:36:53 <ivanm> FP -/-> pure
15:36:54 <dark> but maybe all of this will lead to the creation of systems near-entirely made with FP. and I think that FP guys would likely solve the dependency tracking problem in a more elegant way (the darcs patch algebra comes into mind)
15:37:04 <dark> jmcarthur, wow @.@'
15:37:10 <sinelaw> ivanm, depends how you define FP
15:37:16 <ivanm> the usual definition ;-)
15:37:23 <sinelaw> which is?
15:37:30 <jmcarthur> dark: erlang currently wins for robust systems and distributed systems
15:37:40 <sinelaw> jmcarthur, why?
15:37:45 <sinelaw> why robust
15:37:46 <dark> some people say me: haskell IS IMPERATIVE. o.o' some people will go further and say that FP is a paradigm, that exists in a continuum of paradigms
15:37:46 <ivanm> sinelaw: http://en.wikipedia.org/wiki/Functional_programming
15:37:49 <ivanm> ;-)
15:37:57 <ivanm> @quote imperative
15:37:57 <lambdabot> SamB says: Haskell is the only language I know with first-class support for imperative programming
15:38:04 <ivanm> @quote imperative
15:38:04 <lambdabot> dibblego says: using logic in imperative programming language channels is generally considered trolling
15:38:05 <pikhq> sinelaw: Erlang is pretty much the only contender.
15:38:06 <dark> like, 'see, you can do imperative stuff with haskell'..
15:38:10 <sinelaw> ivanm, it says "avoids state" in the first sentence
15:38:11 <Mathnerd314> no, it's only second class
15:38:18 <pikhq> (for robust distributed systems)
15:38:19 <T_S_> good to hear. Any hints on what to toggle  would be appreciated. I tried copy some C hints and transliterated it as GL.sampleBuffer $= 1. But it isn't Settable.
15:38:22 <ivanm> bah, I was looking for the "haskell is the world's finest imperative language" quote
15:38:24 <sinelaw> pikhq, but why robust?
15:38:27 <jmcarthur> sinelaw: for robust systems erlang has great mechanisms for failing and notifying other components and recovering
15:38:29 <ivanm> but SamB's one isn't bad
15:38:35 <sinelaw> jmcarthur, ah
15:38:47 <ivanm> sinelaw: avoids /= doesn't have
15:38:57 <ivanm> sinelaw: erlang and ocaml are usually considered FP langs
15:39:02 <dark> jmcarthur, robusts in wich sense? (I think that haskell could have a nice implementation of distributed computing in future)
15:39:20 <sinelaw> T_S_,     GL.polygonSmooth GL.$= GL.Enabled
15:39:21 <copumpkin> I agree
15:39:32 <jmcarthur> dark: robust in the sense that failure, even due to things outside of the control of the language, is easy to recover from
15:39:34 <dark> ocaml "is" FP in the sense that it supports (and.. hmm.. endorses) the FP as a model of programming, for reasoning about programs etc
15:39:43 <dark> jmcarthur, hmm
15:39:44 <sinelaw> T_S_, i really recommend using graphics-drawingcombinators. you'll escape from most imperative crap
15:40:07 * sinelaw challenges all to a language flame war
15:40:25 <sinelaw> zulu is great!
15:40:28 <pikhq> Mathnerd314: Imperative actions are first-class values in Haskell.
15:40:30 <jmcarthur> sinelaw: only if T_S_ is doing 2D
15:40:35 <sinelaw> right
15:40:44 <pikhq> They just happen to be of a different type from functions.
15:40:50 <Mathnerd314> pikhq: I can't stop them from happening
15:40:52 <dark> <lambdabot> SamB says: Haskell is the only language I know with first-class support for imperative programming < such quotes I don't understand..
15:41:14 <lament> heh
15:41:17 <jmcarthur> dark: haskell gives you control over imperative programming, while imperative languages only drop you into the thick of it
15:41:27 <pikhq> dark: In most languages, "imperative programming" just happens. In Haskell, imperative programming is programming with values of type IO a.
15:41:37 <ivanm> pikhq: not qutie
15:41:39 <ivanm> *quite
15:41:42 <sinelaw> imperative programming in haskell is overrated
15:41:47 <sinelaw> overrated is overrated
15:41:48 <pikhq> ivanm: Well. Or other types. :P
15:41:50 <ivanm> pikhq: there's also ST, STM, etc.
15:41:56 <Mathnerd314> pikhq: if they were first-class, I could create pure functions from impure functions
15:41:59 <ivanm> pikhq: s/types/monads/
15:42:05 <olsner> sinelaw: X is overrated is overrated
15:42:09 <ivanm> (arguably any do block is imperative)
15:42:20 <sinelaw> i think pureness is the most important property of haskell
15:42:25 <pikhq> Mathnerd314: ... That's not what first-class means.
15:42:27 <dibblego> no, laziness
15:42:35 <sinelaw> it forces you to do things in a composable way
15:42:37 <dark> yes, i was reading about monads: they (tutorial writers.....) say that haskell monad system will enable one to design any kind of imperative mini-language inside haskell
15:42:45 <pikhq> An "x" is first-class if it is a normal value.
15:42:50 <Mathnerd314> pikhq: no, but if they were first class I could do that
15:43:00 <pikhq> Mathnerd314: No.
15:43:09 <ivanm> dark: right; augustss was crazy enough to embed BASIC within Haskell
15:43:15 <pikhq> Mathnerd314: "Impure functions", incidentally, do not exist.
15:43:18 <dark> :)
15:43:21 <ivanm> Mathnerd314: "first class" means that you treat functions as data
15:43:24 <dark> btw, it's nice to see that there are many docs about haskell on the net
15:43:31 <ivanm> you can pass them around, you can do stuff with them, etc.
15:43:35 <Mathnerd314> yeah, I mean funcs with monads
15:43:37 <ivanm> dark: agreed
15:43:44 <ivanm> Mathnerd314: that doesn't make sense
15:44:02 <ivanm> what does "funcs with monads"?
15:44:04 <pikhq> Mathnerd314: ... Monadic values are just that: values. They are no different from anything else.
15:44:06 <T_S_> I am just using SOE right now. Had heaps of trouble installing stuff that would work on macosx. That one depends on SDL which caused some trouble. I might give it another try after I get my project working.
15:44:07 <ivanm> do you mean functions that _return_ monads?
15:44:08 <copumpkin> if you had dependent types and could represent the universe, you could make pure functions out of first-class IO actions
15:44:21 <copumpkin> a monad is a type constructor
15:44:22 <ivanm> copumpkin: ooooohhhhh.....
15:44:30 <ivanm> copumpkin: how does one represent the universe?
15:44:34 <dark> there are some books (hmm, 3, i think) on the library of my uni, all of them in english (i'm from brazil). this contrasts with the books on c++ and java
15:44:49 <ivanm> dark: that could just be the fault of your uni library ;-)
15:44:50 <copumpkin> ivanm: data Universe = Universe
15:44:53 <Mathnerd314> anyways, I think I've proven that ZipList is a monad
15:45:09 <ivanm> dark: http://haskell.org/haskellwiki/Books
15:45:12 <ivanm> copumpkin: ahhhhh
15:45:13 <BONUS> well only for infinite ziplists
15:45:16 <pikhq> Mathnerd314: Demonstrate that a ZipList follows the monad laws.
15:45:24 <Mathnerd314> right, I can do that
15:45:33 <pikhq> Then do so.
15:45:33 <copumpkin> BONUS: or for finite ziplists of equal size
15:45:39 <BONUS> ya
15:45:39 <pikhq> Or else you haven't proven it. :)
15:45:47 <copumpkin> Mathnerd314: let's see the proof!
15:45:51 <ivanm> dark: I forget, does brazil speak spanish or portugese?
15:45:52 <dark> ivanm, yes ^^ but i don't think there are one in Portuguese
15:45:55 <copumpkin> portuguese
15:45:57 <ivanm> ahhh, portugese
15:45:58 <sinelaw> ZipLip
15:46:02 <ivanm> there's one in spanish... >_>
15:46:12 <Mathnerd314> wait, how do you present a proof over IRC?
15:46:13 <dark> ivanm, lol, this question is very funny, ^_^'
15:46:21 <copumpkin> Mathnerd314: you link to it in a paste :)
15:46:21 <BONUS> afaik there was a portugese translation of lyah floating around
15:46:27 <ivanm> dark: there is one: Claudio Cesar de SÃ¡ and Marcio Ferreira da Silva:  Haskell: Uma Abordagem PrÃ¡tica,
15:46:45 <fax> Mathnerd314 -- mathbin
15:46:50 <ivanm> dark: s/does brazil/do brazilian people/ <-- happy now? ;-)
15:46:53 <dark> ivanm, [ but some brazilians will be angry - like if we knew the language spoken in Ukraine ]
15:47:07 <dark> hmmm @.@
15:47:12 <ivanm> there are Ukrainians in Brazil...
15:47:13 <ivanm> ;-)
15:47:23 <ttvd> quite a few btw
15:47:27 <Mathnerd314> ok, it might take a while to write it legibly
15:47:45 <dark> ivanm, hmm.. yeah of course, @.@
15:47:59 <copumpkin> Mathnerd314: here's a really bad proof of some basic stuff :P http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23914#a23914
15:48:59 <dark> I think I will actually recommend this book to some of my colleagues - they are attending to a class that is basically about building an interpreter in haskell, and know nothing about FP. i recommended haskell.org to them, but I think a book will be more accessible maybe o.o
15:49:17 <ivanm> well, maybe try to find a copy of the book first to see if it's any good first ;-)
15:49:38 <dark> yes o.o
15:49:39 * ivanm should re-read what he writes before he hits <enter>
15:50:16 <dark> (It's on the obligatory curriculum of computer science. I'm doing computer engineering, but I'm considering attending to this class, haskell is so cool..)
15:50:43 * dark usually re-read, but his english isn't very good, so grammatical (etc..) mistakes are inevitable
15:51:05 <sinelaw> can anyone explain this error? ffi stuff
15:51:06 <sinelaw> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=8533#a8533
15:52:02 <dark> sinelaw, (don't you need to provide the source too? in special near line 71)
15:53:21 <dark> ps: tryhaskell.org is awesome!
15:53:36 <BONUS> ummm were y'all talking about portugese haskell books before?
15:53:48 <dark> yes
15:53:57 <sinelaw> has anyone ever encountered such an error with the FFI?
15:54:00 <BONUS> wait, nvm
15:54:17 <ivanm> BONUS: speak!
15:54:34 <ivanm> regale us with your wisdome!
15:54:36 <ivanm> :p
15:54:39 <sinelaw> Unacceptable result type in foreign declaration:
15:54:50 <BONUS> i think there's supposed to be a translation of lyah in portugese, i even drew a picture for it, looking for it now
15:54:52 * ivanm has never used the FFI
15:54:54 <BONUS> but i can't find it
15:54:56 <sinelaw> google to the rescue
15:55:13 <BONUS> i don't know how far the dude went before getting bored though
15:55:14 <ivanm> @google lyah portugese
15:55:15 <lambdabot> No Result Found.
15:55:26 <BONUS> not very far i guess
15:55:54 <dark> 'real world haskell'?
15:56:17 <BONUS> http://haskell.tailorfontela.com.br/
15:56:20 <BONUS> there we go
15:56:45 <dark> 'learn you a haskell'
15:57:08 <dark> aaaaah
15:57:10 <dark> i saw it once
15:57:25 <dark> cool ^^
15:57:31 <BONUS> not much has been translated but it's something
15:57:33 <copumpkin> is it sufficiently ungrammatical in portuguese too?
15:57:39 <BONUS> i hope so
15:57:43 <copumpkin> :D
15:58:12 <dark> ungrammatical? i think the style is cool
15:58:14 <ivanm> @where rwh
15:58:14 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
15:58:17 <ivanm> dark: ^^
15:58:29 <Mathnerd314> notation: [x..] is the same as repeat x, right?
15:58:36 <dibblego> no
15:58:50 <monochrom> > take 10 [5..]
15:58:51 <lambdabot>   [5,6,7,8,9,10,11,12,13,14]
15:58:54 <BONUS> > [(+1)..]
15:58:55 <lambdabot>   No instance for (GHC.Enum.Enum (a -> a))
15:58:55 <lambdabot>    arising from the arithmetic seq...
15:58:56 <copumpkin> [x, x..] might be the same as repeat x if x is an Enum
15:58:56 <monochrom> > take 10 [a..]
15:58:57 <lambdabot>   * Exception: not a number
15:58:59 <dark> what I would like: syntax highlight in a haskell interpreter. is that possible at all?
15:59:03 <monochrom> > take 10 [a..] :: [Expr]
15:59:04 <lambdabot>   * Exception: not a number
15:59:15 <monochrom> > take 10 [x..] :: [Expr]
15:59:16 <lambdabot>   * Exception: not a number
15:59:19 <dark> > [5..]
15:59:20 <lambdabot>   [5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,3...
15:59:20 <monochrom> Sorry
15:59:35 <copumpkin> > succ x
15:59:36 <lambdabot>   succ x
16:00:20 <ivanm> dark: it's possibly
16:00:24 <ivanm> but not very efficient
16:00:33 <dark> how? how? :)
16:00:34 <ivanm> actually, not sure, maybe ndm's winhugs supported it...
16:00:36 <sinelaw> ok, i found the problem
16:00:38 <dark> ghci? hugs..?
16:00:39 <dark> hm..
16:00:40 <ivanm> dark: pipe it through hscolour
16:00:44 <ivanm> but it's very slow
16:00:46 <dark> ah lol nice
16:00:47 <ivanm> and buggy last I tried it
16:00:48 <dark> hmmm
16:00:50 <sinelaw> don't use typeclasses when defining the type of a foreign  function :)
16:00:55 <ivanm> it was something like ghci | hscolour
16:00:56 <dark> yes i though this would be buggy
16:01:00 <ivanm> sinelaw: heh
16:01:04 <dark> succ x is just succ x. but if I ask haskell to print succ x, it will say x not defined. right?
16:01:19 <ivanm> dark: unless you have a variable x defined somewhere, yes
16:02:15 <dark> so in fact, i can state a nonsense code - if it never runs, the compiler will just discard it, and will not mention that some variables did invalid references etc
16:02:34 <dark> this 'nonsense code' can violate the type system? of course not, right?
16:02:51 <copumpkin> only if you take the backdoor ;)
16:02:56 <danderson> is there any way in cabal to list all packages which depend on another?
16:03:02 <copumpkin> and everyone knows what happens to people who take the backdoor
16:03:06 <danderson> case in point, find users of the haskell protocol-buffers library.
16:03:08 <ivanm> what do you mean by nonsense code?
16:03:09 <dark> only if i choose to ignore the type system
16:03:15 <ivanm> copumpkin: you mean on your system?
16:03:17 <ivanm> or on hackage?
16:03:24 <copumpkin> my system?
16:03:29 <monochrom> If you mean "if True then 0 else x" with not defined, it still doesn't parse.
16:03:32 <sinelaw> i can't stand this. someone in the neighborhood is hearing music in full volume. it's far so i can hear only the basses, but my brain is imploding.
16:03:34 <monochrom> err
16:03:39 <monochrom> If you mean "if True then 0 else x" with x not defined, it still doesn't parse.
16:03:43 <ivanm> copumpkin: have a look at the source for haskell-updater; I did something like this
16:03:51 <copumpkin> ??
16:03:52 <ivanm> (you get the reverse lookup or something)
16:03:59 <dark> if True then 0 else x - why this does not parse, and succ this parse?
16:04:11 <ivanm> copumpkin: you want to know what package depends upon foo on your machine, right?
16:04:11 <copumpkin> ivanm: what are you responding to?
16:04:14 <ivanm> *what packages
16:04:19 <dark> what about (\a -> if True then 0 else a) x, this will parse?
16:04:21 <copumpkin> no?
16:04:23 <ivanm> copumpkin: oh, sorry, that was danderson asking
16:04:30 <copumpkin> :)
16:04:39 <monochrom> It does not parse because x is not defined.
16:04:45 <ivanm> copumpkin: konversation coloured his nick the same as yours, its the same length and it was in between a bunch of what you're saying
16:04:52 <monochrom> lambdabot accepts it because lambdabot has it defined.
16:04:53 <ivanm> danderson: do you mean on your machine or on hackage
16:04:57 <copumpkin> konversation is evil!!
16:04:57 <ivanm> @type x
16:04:58 <lambdabot> Expr
16:05:13 <ivanm> copumpkin: it's better than quassel, which is aparently the only other IRC client on this machine :s
16:05:31 <ivanm> (unless I use one from within emacs or something... >_>)
16:06:39 <dark> monochrom, ahh. succ x will NOT be valid if x isn't defined, even if this is deferred and finally discarded by the lazy evaluation?
16:06:42 <dark> > succ x
16:06:43 <lambdabot>   succ x
16:06:44 <dark> > succ y
16:06:45 <lambdabot>   succ y
16:06:51 <ivanm> dark: yes
16:06:56 <saml> hey, how would you format a double to first decimal?
16:06:57 <dark> lambdabot says that succ y is just succ y
16:06:57 <ivanm> @src Expr succ
16:06:57 <lambdabot> Source not found. :(
16:07:06 <saml> 3.52352334234242 ==> 3.5
16:07:08 <ivanm> saml: use printf? *shrug*
16:07:11 <ivanm> round it?
16:07:14 <saml> ivanm: ah thanks
16:08:07 * ivanm , however, normally prints values to 3 sig figs, a legacy of all his physics classes
16:08:08 <ivanm> :p
16:08:39 <Cale> > showFFloat (Just 1) 3.52352334234242 ""
16:08:40 <lambdabot>   "3.5"
16:08:41 <monochrom> It defies logic that you just assume that an IRC bot set up by a total stranger on the internet should be informative and credible.
16:08:59 <copumpkin> dark: that's because the bot has a special library loaded
16:09:01 <Cale> > showFFloat (Just 3) 3.52352334234242 ""
16:09:02 <lambdabot>   "3.524"
16:09:12 <Cale> > showEFloat (Just 3) 3.52352334234242 ""
16:09:13 <lambdabot>   "3.524e0"
16:09:24 <Cale> > showEFloat (Just 3) 0.0052352334234242 ""
16:09:25 <lambdabot>   "5.235e-3"
16:09:26 <copumpkin> > foldr f z [a,b,c,d,e] -- dark: it allows you to do things like this
16:09:27 <lambdabot>   f a (f b (f c (f d (f e z))))
16:09:31 <Cale> > showFFloat (Just 3) 0.0052352334234242 ""
16:09:32 <lambdabot>   "0.005"
16:09:58 <ivanm> @remember monochrom It defies logic that you just assume that an IRC bot set up by a total stranger on the internet should be informative and credible.
16:09:59 <lambdabot> It is stored.
16:10:24 <saml> > let len = 2*pi; r :: Integer; r = 10; resolution = len / (fromInteger r); getX x = resolution * fromInteger (snd $ quotRem x r); f :: Integer -> String; f x = printf "%.2f" (sin $ getX x) in map f [1, 2 .. ]
16:10:25 <lambdabot>   ["0.59","0.95","0.95","0.59","0.00","-0.59","-0.95","-0.95","-0.59","0.00",...
16:10:29 <dark> copumpkin, so this is not the haskell usual way? hmmm
16:10:29 <Mathnerd314> hmm... property 3 seems difficult to prove formally
16:10:36 <saml> is that correct sine graph?
16:10:45 <dark> copumpkin, is haskell evaluation system that easily hackable, or it is just a pretty-printer?
16:10:48 <copumpkin> Mathnerd314: it's a lot nicer using the join/fmap/return approach
16:10:57 <Mathnerd314> what's that?
16:11:02 * Mathnerd314 is using Wikipedia
16:11:07 <copumpkin> another way to talk about monads
16:11:59 <copumpkin> Mathnerd314: the Î¼ is join
16:12:09 <Mathnerd314> ah, didn't read enough far down
16:12:12 <Alpounet> > showFFloat Nothing 3.14
16:12:13 <copumpkin> Î· is return, and T is fmap
16:12:13 <lambdabot>   ""->
16:12:14 <lambdabot>    "3.14"
16:12:14 <lambdabot>  "a"->
16:12:14 <lambdabot>    "3.14a"
16:12:14 <lambdabot>  "aa"->
16:12:15 <lambdabot> [4 @more lines]
16:12:56 <wjt> anyone know of a iteratee-style directory traversal library? i can't find one on hackage. i've been using directory-tree, but building the whole entire file hierarchy here is eating all my ram :)
16:13:33 <wjt> might be a fun exercise to write one, if not, i suppose :)
16:13:38 <Mathnerd314> ah, since ZipList already applicative, I just have to show the stuff for join
16:13:46 <copumpkin> yep
16:14:44 <dibblego> wjt, FileMainp
16:15:42 <dibblego> *FileManip
16:15:51 <dark> are exceptions in haskell 'pure'? they are a kind of side-effect, right?
16:16:44 <wjt> dibblego: aha, ace :)
16:16:46 <Makoryu> dark: Yup, they're IO.
16:17:09 <copumpkin> not necessarily IO
16:17:16 <copumpkin> but can be caught in IO
16:17:32 <RichardBarrell> dark: they bubble upwards through the evaluation procedure in a well-defined way until they hit something in the IO monad.
16:17:38 <copumpkin> you can have purish error reporting using either
16:18:03 <RichardBarrell> dark: they then explode messily all over your program, but that's okay because the IO monad is *allowed* to contain evil. ;)
16:18:51 <dibblego> I wish we stopped calling it "the IO monad"
16:18:51 <RichardBarrell> Simon Peyton Jones has a good paper on asynchronous exceptions; which is the exception mechanism that's implemented in GHC now. I'll dig it up for you, if I can find it.
16:19:13 <RichardBarrell> dibblego: sorry? :/
16:19:13 <dark> BONUS, oh, you is the lyah guy. great job, that doc is really nice ^^
16:19:23 <dibblego> RichardBarrell, forgiven
16:19:28 <c_wraith> Should we call it "dangerous scary thing"?
16:19:32 <RichardBarrell> dark: http://www.haskell.org/~simonmar/papers/async.pdf <- paper.
16:19:42 <dark> hm o.o thank you RichardBarrell
16:19:45 <RichardBarrell> s/dangerous scary/warm, fuzzy/g and you're golden.
16:19:55 <c_wraith> IO is not warm and fuzzy
16:20:04 <copumpkin> oh wow, the cat verbs are still gone
16:20:33 <RichardBarrell> dark: basically the idea is that - for performance's sake - the implementation is allowed to be a little bit non-deterministic about *which* exception you will see land on your plate when it eventually gets caught in IO.
16:20:33 <dibblego> IO is a type constructor. That it is a monad, is completely irrelevant. It is also many other things. Emphasising "monad" is unnecessary and confuses beginners.
16:20:40 <dark> do haskell has call/cc? it's said that many exception systems "could be implemented with call/cc" but even that would be 'impure' and a kind of side-effect, right?
16:20:47 <copumpkin> :t callCC
16:20:48 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
16:21:02 <copumpkin> dark: furthermore, it's not a primitive
16:21:02 <RichardBarrell> dark: but only IO is allowed to catch them, so it's, um, what's the word... honest? Well-principled?
16:21:49 <dark> RichardBarrell, if a exception is thrown, then the catcher could see another? o.o
16:22:00 <dark> or, if two exceptions are thrown, the catcher could see any of them?
16:22:08 <Alpounet> on the other hand
16:22:08 <RichardBarrell> Yep.
16:22:09 <dark> hm
16:22:15 <Alpounet> there are Maybe-like types in Haskell
16:22:19 <dark> 'yep' for what RichardBarrell?
16:22:28 <RichardBarrell> The latter, sorry.
16:22:30 <Null-A> Are there any examples of haskell in building a distributed system?
16:22:44 <dark> copumpkin, it's said that 'ml type system is not powerful enough to represent call/cc'. but haskell, on the other hand, has no problem with this?
16:22:53 <dark> RichardBarrell, ah, hm o.o
16:22:53 <Alpounet> Null-A, yes
16:22:58 <RichardBarrell> dark: Say I have a function that in one place divides by integer zero, and in another place takes the head of an empty list.
16:23:02 <Null-A> Alpounet: project names? =)
16:23:02 <Alpounet> Null-A, there are 2 libraries afaik
16:23:08 <Alpounet> don't remember the names but
16:23:16 <danderson> ivanm: on hackage in general
16:23:16 <Null-A> hmh k
16:23:18 <Alpounet> google for "haskell distributed" and you should come accross them
16:23:22 <Null-A> k thx
16:23:32 <dark> RichardBarrell, in strict languages, the exception that is hit 'first' will be caught
16:23:34 <danderson> I want to find an example of protocol-buffers being actually used, which I'm not sure is actually happening at all
16:23:41 <RichardBarrell> dark: *both* of those will result in exceptions. GHC's implementation says that the IO code catching exceptions might see either of them, and it's not defined which of the two will land on you.
16:23:43 <ivanm> danderson: someone set up an experimental reverse dependency mirror of hackage
16:23:43 <Alpounet> Null-A, I don't guarantee they are up-to-date
16:23:44 <wjt> dibblego: bah, this isn't going to do what i need. i've gone from too eager to not quite eager enough :)
16:23:44 <dark> in a lazy language is maybe harder to define 'first'
16:23:56 <Alpounet> but that's the kind of project you can do quite easily with Haskell
16:24:03 <wjt> dibblego: probably enough for one night. thanks for the pointer :)
16:24:06 <Alpounet> the purity being a key element in that
16:24:08 <dark> but nonetheless it seems that ghc WILL order them, in an arbitrary way, right?
16:24:29 <danderson> ivanm: found it, cheers
16:24:33 <RichardBarrell> Oh yeah, you'll only see *one* of them. Which one you see is not deterministic.
16:24:33 <ivanm> danderson: http://bifunctor.homelinux.net/~roel/hackage
16:24:52 <copumpkin> bbl :)
16:25:16 <RichardBarrell> dark: The surprising thing is that even imperative languages don't always define which exception you'll see, in some expressions. :)
16:25:45 <cads> Hello, I'm being bitten by a function that's expecting a RealFrac value. I'm applying it to a Fractional value, though I might be wrong on whether Fractional is a type or a class. Here is the code:
16:25:50 <dark> hm o.o hehe..
16:25:58 <RichardBarrell> dark: for instance, most C-family languages don't define which order function parameters are evaluated in...
16:26:03 <cads> nsum n k = k * a * (a + 1)/2  where a = floor(n/k)
16:26:15 <dark> in C++, the evaluation order of parameters is undefined
16:26:18 <dark> yeah
16:26:26 <RichardBarrell> dark: ...more interestingly, most FPUs (apparently) don't define exactly which NaN you will get.
16:26:39 <dark> but C++ specs require that the implementations choose a order, and stick with it
16:27:02 <dark> hmm but all nans are equivalent, in a sense
16:27:04 <cads> > let nsum n k = k * floor(n/k) * (floor(n/k) + 1)/2 in nsum 100 3
16:27:05 <lambdabot>   Ambiguous type variable `t' in the constraints:
16:27:05 <lambdabot>    `GHC.Real.Integral t'
16:27:05 <lambdabot>   ...
16:27:08 <RichardBarrell> The C++ spec allows the compiler to pick a *different* order at *every* single function call if it feels like it. :)
16:27:14 <dark> ahh
16:27:17 <dark> hmm o.o
16:27:29 <sinelaw> > [1..(3+43/6)]
16:27:30 <lambdabot>   [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0]
16:27:36 <dark> ok, is that bit of trivia i had just plain wrong? it is valid for C at least?
16:27:39 <sinelaw> > [1..(3+4)]
16:27:40 <lambdabot>   [1,2,3,4,5,6,7]
16:27:51 <dark> i thought that the calling convention would depend just on the architecture
16:28:15 <RichardBarrell> Order of evaluation is a separate concern from calling convention.
16:28:36 <dark> so i must be confusing concepts, sorry
16:28:54 <RichardBarrell> dark: No, NaN values keep bits of mantissa from the operand that caused the problem, apparently for the sake of assisting in tracking down where they came from.
16:29:00 <applicative> @type floor
16:29:01 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
16:29:33 <dark> RichardBarrell, but this process isn't defined in the ieee standard?
16:29:45 <cads> @type 1/4
16:29:46 <RichardBarrell> dark: Calling convention is a very low-level concern, detailing things like how you pass arguments from one function to another - do you stuff them into registers, or put them on the stack, or...
16:29:46 <lambdabot> forall t. (Fractional t) => t
16:30:00 <cads> > floor(19/3)
16:30:01 <lambdabot>   6
16:30:02 <Mathnerd314> gahh, pointfree notation is being confusing
16:30:34 <RichardBarrell> dark: which process? The fact that you can get slightly non-deterministic results from FPUs or the fact that NaN values contain some mantissa?
16:30:35 <dark> order o evaluation: with some expressions, a certain order could simplify the code. it's that the concern?
16:30:49 <dark> RichardBarrell, the fact that nan values contain some mantissa
16:30:52 <cads> hmm, my error is somewhere else maybe
16:30:57 <Alpounet> Mathnerd314, it's a matter of time
16:31:00 <Alpounet> you'll get used to it
16:31:13 <Alpounet> and actually probably prefer it to usual notations
16:31:28 <Mathnerd314> I *was* used to it, then something broke
16:31:51 <Alpounet> more complex pointfree expressions came in front of your eyes ?
16:31:51 <Mathnerd314> probably comes from "learn haskell in 10 minutes" ;-)
16:31:51 <dark> what is pointfree notation?
16:32:01 <RichardBarrell> dark: I am not sure whether implementations are *required* to leave some mantissa in, but the rationale for IEEE754 having so many different values to encode NaN is *because* it enables that, as far as I understand it.
16:32:24 <RichardBarrell> Pointfree notation is where you write functions purely out of combinators, with no parameters getting passed around.
16:32:28 <cads> @pl (\ x y -> 4*x + y)
16:32:29 <lambdabot> (+) . (4 *)
16:32:50 <RichardBarrell> cads gives a good example.
16:33:08 <Cale> Except that it would probably be clearer using lambda in that specific case.
16:33:15 <dark> RichardBarrell, i thought it was like a 'dont-care' that could potentially simplify the notation. plus, if there would be just exactly one value for nan, maybe there would be values of float that doesn't represent any number, so one would have to treat this as error
16:33:21 <cads> Cale indeed :)
16:33:27 <dark> simplify the computation
16:33:34 <RichardBarrell> A slightly simpler one (because it only involves one parameter) would be the function f x = m * x + c
16:33:38 <dark> like eliminating some circuits
16:33:56 <dark> with no parameters getting passed
16:34:00 <dark> hm
16:34:00 <RichardBarrell> Which can be written as { f x = m*x + c; } or as { f = (m*) . (+c); }
16:34:39 <cads> I think that might be f = (+c) . (*m)  -- you're adding c after multiplying x by m.
16:34:50 <RichardBarrell> The latter definition is pointfree. The explicit parameter identifiers are called "points" for some reason, and that's where the name "pointfree" comes from. I'm not sure *who* came up with the name "points". :/
16:35:08 <RichardBarrell> cads: oops, you're right. I apologise.
16:35:22 <dark> it's like, avoiding complex expressions?
16:35:25 * RichardBarrell coughs and mumbles.
16:35:42 <dark> it's related to continuation-passing style?
16:35:45 <RichardBarrell> dark: No, it's just composing functions.
16:36:12 <Mathnerd314> hmmm, I think it's easier to prove directly instead of through fmap + return + join
16:36:19 <RichardBarrell> It literally means writing your functions in terms of combinators so that their definitions don't have any named parameters.
16:36:38 <dark> it's related to the y combinator? and the way you can write a recursive function by receiving itself in the first parameter
16:36:54 <dark> any named parameters
16:37:19 <dark> i saw once something about removing named parameters in lambda calculus.. what unlambda programming language uses
16:37:21 <RichardBarrell> Mathnerd314: I get the impression that fmap+return+join is the easiest way to explain the whole idea. I saw a roomful of newbies have a very good time with the fmap+return+join tutorial at AngloHaskell last year.
16:37:45 <dark> that S and K..
16:38:07 <dark> of course I didn't understood that much....
16:38:09 <Mathnerd314> I'm trying to prove that this is a real monad: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23913#a23913
16:38:24 <cads> > floor ((1::Int)/(3::Int))
16:38:25 <lambdabot>   No instance for (GHC.Real.RealFrac GHC.Types.Int)
16:38:25 <lambdabot>    arising from a use of ...
16:38:30 <RichardBarrell> dark: You need the Y combinator in order to have loops in point-free code. Generally, point-free style is only a good idea for functions that resemble simple pipelines.
16:39:23 <dark> Combinatory logic is a notation introduced by Moses SchÃ¶nfinkel and Haskell Curry to eliminate the need for variables in mathematical logic.
16:39:25 <RichardBarrell> dark: S and K are just combinators. Don't bother to worry about them, they're not interestingly useful for writing Haskell code.
16:39:31 <dark> ah
16:40:09 <RichardBarrell> dark: unlambda is basically an elaborate prank, pulled by programming-language geeks, enacted upon and for the edification of *other* programming-language geeks.
16:40:11 <RichardBarrell> ;)
16:40:11 <ivanm> cads: fromIntegral
16:40:42 <dark> so writing in point-free style is like writing things like S and K?
16:40:53 <ezyang> dark: Not... really...
16:41:04 <dark> yes, i get that unlambda is quite esoteric, maybe more than brainfuck
16:41:09 <RichardBarrell> No, S and K are confusingly difficult to use. :)
16:41:25 <applicative> cads: study http://www.bucephalus.org/text/Haskell98numbers/Haskell98numbers.pdf if you want to feel gloomy
16:41:29 <RichardBarrell> unlambda is significantly more esoteric than brainfuck. Turing machines are at least *simple*.
16:41:33 <dark> but I mean, one could write S and K with point-free style, and other things as well?
16:41:43 <applicative> or http://www-bucephalus-org.blogspot.com/2009/09/haskell-number-system-in-one-picture.html
16:42:31 <sinelaw> is there a type for one byte?
16:42:39 <tromp_> :t Word8
16:42:40 <lambdabot> Not in scope: data constructor `Word8'
16:42:47 <sinelaw> k
16:42:48 <RichardBarrell> sinelaw: Data.Word, Word8, or Data.Int, Int8 if you want signed.
16:42:57 <sinelaw> thanks
16:43:07 <dark> :t Data.Word8
16:43:08 <lambdabot> Couldn't find qualified module.
16:43:09 <RichardBarrell> dark: yyyyyes. If you have the right combinators handy, you can build any other program out of them. Analogous to how you can build any circuit out of the right set of basic logic gates.
16:43:30 <dark> hm o.o
16:43:32 <ivanm> @hoogle Word8
16:43:32 <lambdabot> Data.Word data Word8
16:43:32 <lambdabot> Data.ByteString.Internal isSpaceWord8 :: Word8 -> Bool
16:43:36 <tromp_> you can translate any lambda expr into s k expression easily
16:43:36 <ezyang> dark: For extra points, prove that this is the case :-)
16:43:38 <ivanm> dark: first of all, Word8 is in Data.Word
16:43:47 <ivanm> secondly, you can't ask for the type of a type ;-)
16:43:51 <RichardBarrell> Word8 is a type, not a constructor. :)
16:43:51 <ivanm> :k Word8
16:43:52 <lambdabot> *
16:43:57 <ivanm> the kind, however, is a different story
16:44:05 <ivanm> dark: Word 8 is 0 - 255
16:44:14 <RichardBarrell> ivanm: (this is why Coq makes my brain hurt :))
16:44:25 <ivanm> (i.e. 8 bit integers)
16:44:28 <ivanm> RichardBarrell: come again?
16:44:41 <dark> ezyang, I could if I just understood this whole point-free thing [ i'm reading http://en.wikipedia.org/wiki/Tacit_programming , hmm ]
16:45:13 <dark> haskell surely employs some confusing concepts to me =)
16:45:24 <RichardBarrell> ivanm: Coq's types are themselves expressions and have types, and vice versa.
16:45:39 <c_wraith> point-free is really just a way to really make clear that functions are values.
16:45:47 <cads> ivanm: I've followed your suggestion and have written  nsum n k = k * a * (a + 1)/2 where a = floor(fromIntegral (n/k)) function, which now loads into ghci. But its type is (Integral b, Fractional b) -> b -> b -> b. Does that mean input to nsum must be both fractional and integral?
16:46:08 <dark> RichardBarrell, so, creating new types is like creating new expressions? (well, lisp is that way.. but it's not statically typed. is coq statically typed? o.o)
16:46:12 <RichardBarrell> cads: yes, and there's no such type.
16:46:33 <cads> ivanm: I can't find values to evaluate nsum with - nsum 1 2, nsum 1.0 2, etc., all don't work.
16:46:42 <ivanm> RichardBarrell: :/
16:46:53 <RichardBarrell> dark: er, please don't worry about Coq for the moment. It's properly badger-in-my-trousers crazy.
16:46:55 <cads> I'm panicking here, what is going on! :)
16:46:56 <ivanm> cads: yes, which isn't possible ;-)
16:47:12 <dark> RichardBarrell, i'm not worrying, i like to ask random questions :-)
16:47:14 <ivanm> cads: because you want: fromIntegral n / fromIntegral k ;-)
16:47:50 <RichardBarrell> dark: okay, then I'll be more honest. Please don't ask me questions about Coq because I don't understand it either. :)
16:47:53 <ivanm> @type (/) `on` fromIntegral
16:47:54 <lambdabot> forall b a. (Fractional b, Integral a) => a -> a -> b
16:48:02 <ivanm> cads: ^^
16:48:04 <c_wraith> @djinn (s -> (a, s)) -> (a -> (s -> (b, s))) -> (s -> (b, s))
16:48:05 <lambdabot> f a b c =
16:48:05 <lambdabot>     case a c of
16:48:05 <lambdabot>     (d, e) -> b d e
16:48:08 <dark> =DDDD lol
16:48:08 <applicative> cads: it's given the n and k will be integers?
16:48:15 <ivanm> @unpl (/) `on` fromIntegral
16:48:15 <lambdabot> (on (/) fromIntegral)
16:48:18 <ivanm> heh
16:48:28 <ivanm> @djinn Int -> Int -> Double
16:48:28 <lambdabot> Error: Undefined type Int
16:48:44 <ivanm> hmmm, so djinn doesn't know about concrete types either (which makes sense)
16:49:04 <ivanm> c_wraith: you trying to derive >>= for State or something?
16:49:20 <c_wraith> ivanm: it works, too! :)
16:49:27 <cads> applicative: correct. And for all integer values of n, k, where k is nonzero, the function yields an integer.
16:49:59 <ivanm> yup
16:50:02 <monochrom> In fact, someone added Cont to djinn, so you can even make it derive callCC.
16:50:51 <applicative> @type fromIntegral
16:50:51 <lambdabot> forall a b. (Integral a, Num b) => a -> b
16:50:52 <ivanm> @djinn a -> (s -> (a,s))
16:50:52 <lambdabot> f a b = (a, b)
16:51:12 <applicative> @type (/)
16:51:12 <c_wraith> oh, look.  It can derive return, too :)
16:51:13 <lambdabot> forall a. (Fractional a) => a -> a -> a
16:51:19 <ivanm> c_wraith: yup!
16:51:22 <cads> Oh man, it finally worked.
16:51:28 * ivanm tries to work out a way to get it to derive get and put
16:51:56 <ivanm> oh, get is easy, duh
16:51:59 <monochrom> You got get there.
16:52:00 <ivanm> @djinn s -> (s,s)
16:52:00 <lambdabot> f a = (a, a)
16:52:00 <cads> There was an error in using the (/) operator in the main body of the function, as well.
16:52:09 <monochrom> sorry, you got put there.
16:52:21 <ivanm> monochrom: where?
16:52:34 <ivanm> @djinn s -> ((),s)
16:52:34 <lambdabot> f a = ((), a)
16:52:39 <monochrom> f a b = (a, b)  for a -> (s -> (a,s))
16:52:39 <ivanm> and that's put, isn't it?
16:52:44 <applicative> cads, what is it now
16:52:48 <ivanm> monochrom: I thought that was return...
16:52:51 <cads> > let nsum n k = k * a * (a + 1) `div` 2 where a = floor(fromIntegral n / fromIntegral k) in nsum 100 3
16:52:52 <lambdabot>   1683
16:52:56 <monochrom> Oops, right.
16:53:10 <Makoryu> @djinn a -> (a -> b) -> (a, b)
16:53:10 <lambdabot> f a b = (a, b a)
16:53:35 <ivanm> that's modify?
16:53:40 <cads> That ivanm, applicative, RichardBarrell!
16:53:43 <cads> thanks*
16:53:47 <ivanm> heh
16:54:32 <monochrom> modify is (s->s) -> s -> ((),s)
16:54:38 <c_wraith> @djinn (s -> s) -> ((), s)
16:54:39 <lambdabot> -- f cannot be realized.
16:54:44 <c_wraith> @djinn (s -> s) -> s -> ((), s)
16:54:44 <lambdabot> f a b = ((), a b)
16:55:03 <ivanm> oh, yeah
16:55:26 <cads> These type misunderstandings are very frustrating. I've had troubles with numerical types in haskell since I started - can you guys suggest some literature that'll help me rigorously understand haskell's number hierarchy, and types in general?
16:55:28 <c_wraith> So djinn knows one concrete type.  ()
16:55:44 <cads> Is the hs98 report helpful in this regard?
16:55:56 <ivanm> cads: the link applicative gave you?
16:56:02 <monochrom> Yes. the report is my sole source of information.
16:56:07 <ivanm> c_wraith: also knows about Maybe I suppose...
16:56:17 <ivanm> cads: or else RWH has a bit on it
16:56:24 <c_wraith> ivanm: Maybe's not a concrete type.
16:56:26 <ivanm> otherwise.... just use it? *shrug*
16:56:28 <cads> ivanm: I missed that! Sorry.
16:56:31 <c_wraith> ivanm: but it knows about Bool, which is.
16:56:36 <ivanm> cads: this is it: http://www-bucephalus-org.blogspot.com/2009/09/haskell-number-system-in-one-picture.html
16:56:39 <cads> thanks for the link, applicative
16:56:46 <c_wraith> @djinn Bool -> Bool -> Bool
16:56:46 <lambdabot> f a b =
16:56:46 <lambdabot>     case a of
16:56:46 <lambdabot>     False -> b
16:56:46 <lambdabot>     True -> False
16:56:47 <ivanm> c_wraith: well, it is another type that it knows about
16:56:57 <ivanm> probably knows about Either as well
16:57:01 <c_wraith> ivanm: and (,)
16:57:06 <ivanm> true
16:57:10 <c_wraith> It knows lots of types.
16:57:18 <ivanm> just constructor-based ones
16:57:19 <dark> does this function http://learnyouahaskell.com/recursion#quick-sort actually run on O(nlog n) average time? How can one could assert this kind of thing with haskell? (I am suspecting it does not)
16:57:27 <ivanm> not numeric ones
16:57:30 <monochrom> djinn knows or can know all non-recursive algebraic types.
16:57:54 <ivanm> I wonder...
16:57:59 <ivanm> @djinn Complex a -> a
16:57:59 <lambdabot> Error: Undefined type Complex
16:58:01 <applicative> cads: check it out, 8 concrete types, but 13 typeclasses covering different selections of them....
16:58:03 <ivanm> nope
16:58:16 <c_wraith> What's the command to make djinn dump the types in knows about?
16:58:22 <c_wraith> *it
16:58:23 <ivanm> is there one?
16:58:26 <codolio> @djinn-env
16:58:26 <lambdabot> data () = ()
16:58:26 <lambdabot> data Either a b = Left a | Right b
16:58:27 <lambdabot> data Maybe a = Nothing | Just a
16:58:27 <lambdabot> data Bool = False | True
16:58:27 <lambdabot> data Void
16:58:28 <lambdabot> type Not x = x -> Void
16:58:29 <ivanm> ahhh
16:58:30 <lambdabot> class Monad m where return :: a -> m a; (>>=) :: m a -> (a -> m b) -> m b
16:58:32 <lambdabot> class Eq a where (==) :: a -> a -> Bool
16:58:34 <ivanm> what's Void?
16:58:44 <codolio> It's the empty type.
16:58:46 <c_wraith> Void is the type with 0 constructors
16:58:52 <tensorpudding> @djinn Void -> a
16:58:52 <lambdabot> f = void
16:58:56 <monochrom> uninhabited type to stand for falsehood.
16:58:57 <ivanm> so it only knows about return and bind for monads... I suppose fail doesn't make sense
16:59:07 <ivanm> tensorpudding: and its use is?
16:59:08 <tensorpudding> Void is the absurd type, from which anything can be derived
16:59:12 <ivanm> heh
16:59:14 <cads> ivanm: I wanna kiss ya!
16:59:15 <codolio> return and bind don't really make sense, either.
16:59:26 * cads diligently prints out that diagram to study
16:59:35 <ivanm> cads: I would rather you didn't
16:59:38 <codolio> It only knows return :: Monad m => a -> m a
16:59:45 <ivanm> @djinn (Monad m) => m (m a) -> m a
16:59:45 <lambdabot> -- f cannot be realized.
16:59:50 <codolio> It doesn't know return :: Monad m => b -> m b
16:59:59 <ivanm> codolio: it knows about bind...
16:59:59 <cads> ivanm: many thanks, then!
17:00:05 <ivanm> codolio: :o
17:00:20 <ivanm> @djinn m (m a) -> m a
17:00:20 <lambdabot> -- f cannot be realized.
17:00:27 <ivanm> hmmm, it can't realise join ...
17:00:33 <dolio> @djinn Monad m => b -> m b
17:00:33 <lambdabot> -- f cannot be realized.
17:00:36 <applicative> pretty lame, that djinn
17:00:41 <dolio> @djinn Monad m => a -> m a
17:00:41 <lambdabot> f = return
17:00:42 <ivanm> yeah
17:00:50 <c_wraith> that looks like a strange hack
17:01:05 <dolio> It's because it implements type classes by prepending the methods to the signature.
17:01:12 <ivanm> I'm guessing it can't realise join is because then you have two level monads, and m a /= a
17:01:29 <dolio> So "Monad m => b -> m b" is "(a -> m a) -> (m a -> (a -> m b) -> m b) -> b -> m b"
17:01:42 <c_wraith> yikes
17:02:09 <c_wraith> So really, saying it knows anything about Monad is a complete lie
17:02:18 <ivanm> looks like it :(
17:02:22 <dolio> Yeah, I don't know why that's even in there.
17:02:23 <ivanm> @vixen you lied to me!
17:02:24 <lambdabot> i hate it when i get stuck with chatting with a bot!
17:02:29 <ivanm> :o
17:02:40 <ivanm> @vixen I'm not a bot! _you're_ the bot!
17:02:40 <lambdabot> bots should be destroyed. they are so annoying
17:02:45 <ivanm> ...
17:02:47 <ivanm> @botsmack
17:02:47 <lambdabot> :)
17:03:01 <c_wraith> what happened to lunabot, anyway?
17:03:20 <dolio> mmorrow has been mysteriously absent for a while.
17:03:21 <c_wraith> oh, that was mmorrow's bot, wasn't it?  vanished with him?
17:03:24 <dolio> lunabot was his bot.
17:03:25 <monochrom> dating sailor moon
17:03:58 <ivanm> heh
17:03:59 <RichardBarrell> Hacked by Sailor Moon.
17:04:07 <ivanm> preflex: seen lunabot
17:04:07 <preflex>  lunabot was last seen on #haskell 40 days, 17 hours, 41 minutes and 20 seconds ago, saying:  31
17:04:10 <ivanm> preflex: seen mmorrow
17:04:10 <preflex>  mmorrow was last seen on #ghc 52 days, 22 hours, 6 minutes and 25 seconds ago, saying: * mmorrow is rtfm'ing
17:04:26 <ivanm> so lunabot was hanging around for another 12 days before leaving...
17:04:38 <RichardBarrell> She needed the CPU time for rendering a more modern replacement for the old glowy effect on costume change.
17:05:00 <c_wraith> I hope he's ok.
17:05:14 <RichardBarrell> ...yeah. :/
17:05:30 <ivanm> yeah, it's a bit weird to be gone for almost 2 months...
17:05:48 <ivanm> that might explain about hpaste being down as well...
17:06:00 <ivanm> I lie, hpaste is back up
17:06:03 <Alpounet> maybe something happened to him, otoh :/
17:06:07 <Alpounet> oh
17:06:11 <ivanm> and full of spam by copumpkin...
17:06:22 <Alpounet> haha
17:06:41 <ivanm> wait, the spam isn't by compumpkin
17:06:45 <ivanm> but it is full of spam
17:07:24 <ivanm> pastes full of different ways of having links: <a href="...">, [url=...], [link=...] and just http://...
17:07:30 <monochrom> "My God, it's full of spam!"
17:07:30 <dolio> hpaste.org isn't his anyway. His is moonpatio.com
17:08:13 <ivanm> dolio: yeah, but I thought he ran hpaste as well
17:08:20 <ivanm> so who _is_ in charge of hpaste then?
17:08:22 <ivanm> monochrom: heh
17:08:26 <dolio> That may be. I don't know.
17:08:42 <applicative> what's kup with the spam, by the way, it'd be easy to filter for most of it, you'd think
17:08:43 <monochrom> bos
17:08:43 <ivanm> well, moonpatio is full of spam as well...
17:08:47 <ivanm> (well, not _as_ much)
17:09:00 <ivanm> applicative: no-one has bothered to write a spam filter for paste sites?
17:09:20 <ivanm> I suppose we should be grateful that paste announcement is no longer working though...
17:10:23 <applicative> somehow I feel like I could find the predicate that could exclude the like of: "bdMdGd  <a href="http://cewdryjoogxh.com/">cewdryjoogxh</a>, [url=http://vnmkepivtgxx.com/]vnmkepivtgxx[/url], [link=http://fmvhpyiiryvw.com/]fmvhpyiiryvw[/link], http:/
17:10:29 <ivanm> yeah
17:10:40 <ivanm> but as soon as they change the format... >_>
17:11:31 <applicative> is that right, is there some purpose for this mysterious nonsense?  launching missles or something?
17:11:42 <ivanm> *shrug*
17:16:59 <regalia> In this example: http://www.haskell.org/all_about_monads/html/solution4.html
17:17:19 <ivanm> regalia: yes?
17:17:35 <regalia> I'm confused about why the maybeToMonad function is needed...
17:17:43 <ivanm> it isn't
17:17:50 <ivanm> someone just might want such a thing
17:18:02 <ivanm> or do you mean why they're using it in parent and grandparent?
17:18:16 <regalia> I know, they're using it so it can also be used with List monad
17:18:37 <regalia> but since they're both in the MonadPlus typeclass, why does it need to be changed from maybeToMonad?
17:18:39 <ivanm> greetings copumpkin
17:18:41 <sm> I made a "paste bot" this morning: http://hub.hledger.org
17:18:46 <Makoryu> That's an unusually monomorphic function
17:19:08 <ivanm> regalia: it's probably possible to have it (MonadPlus m, MonadPlus m') => m a -> m' a
17:19:11 <ivanm> if that's what you mean
17:19:21 <regalia> Ahhhhh
17:19:22 <regalia> ok
17:19:23 <copumpkin> greetings ivanm
17:19:38 <regalia> That clears it up a bit
17:19:44 <regalia> Let me check to see if that works....
17:19:47 <ivanm> regalia: then again, it might not always be safe or make much sense to have the generic version
17:20:04 <ivanm> regalia: I think it's just that they have a function that returns a Maybe, but you might want to compose it differently
17:20:21 <regalia> They're using it with Maybe and Lists
17:20:36 <Makoryu> It ought to be a typeclass.
17:20:55 <regalia> I guess mostly... the maybeToMonad function is able to determine which Monad to change to kind of 'in context'?
17:21:15 <ivanm> Makoryu: what should be?
17:21:21 <ivanm> regalia: yes
17:21:23 <Makoryu> regalia: Oh, so you're wondering about how the return type is overloaded?
17:21:42 <applicative> sm: mysterious
17:21:44 <Makoryu> regalia: That's one of the strengths of Haskell's type system. It can do that :)
17:21:57 <Makoryu> And it's very common to take advantage of it.
17:21:59 <ivanm> Makoryu: no, I think he's wondering why they're explicitly using Maybe there
17:22:02 * sm thinks it has a certain charm
17:22:12 <regalia> I suppose I've never really seen,  or at least recognized that being done before =\
17:22:17 <Cale> There's no way in general to tell, for an arbitrary MonadPlus, that you have the element whch is equivalent to mzero.
17:22:50 <Cale> Or to break down a value in a MonadPlus into a first value and the remaining.
17:22:54 <ivanm> sm: like the quote here about the chimney? :p http://en.wikiquote.org/wiki/The_Castle
17:22:59 <micah> I am still trying to get yi -f cocoa to work
17:23:02 <Makoryu> regalia: It's not possible in most type systems. Though, Perl does it to a certain extent
17:23:06 <micah> but it will not
17:23:18 <regalia> Makoryu: Ok, gooootchya thanks :)
17:23:35 <Makoryu> micah: Did it ever work? x_x
17:23:44 <Axman6> ivanm: you were looking for me?
17:23:50 <ivanm> Axman6: the other day
17:23:54 <Cale> The logict package defines a class MonadLogic for monads m which support an operation  msplit :: m a -> m (Maybe (a, m a))
17:23:58 <micah> I've made progress but there is a conflict with data-accessor and I dno't know how to resolve it
17:24:04 <ivanm> Axman6: did you know there's a programming SIG here associated with the linux user group?
17:24:05 <regalia> Another thing, I don't quite understand the idea that the Maybe monad does NOT have 'backtracking' while the List monad does, so the functions can be written differently...
17:24:21 <ivanm> micah: I told you how to fix it ;-)
17:24:27 <micah> but I tried it
17:24:29 <ivanm> downgrade data accessor to 0.2.1 and not 0.2.1.2
17:24:31 <micah> and couldn't get it to work
17:24:38 <ivanm> you ended up unisntalling 0.2.1 and keeping 0.2.1.2 IIRC
17:24:40 <applicative> sm: I noticed that gitit.net has a paste module as an illustration of literate haskell support, I was suprised how simple: http://gitit.net/paste.lhs
17:24:41 <micah> I'll try again
17:24:41 <Cale> regalia: You can think of a list value as being a choice between its elements
17:25:04 <regalia> Cale:  and mplus is able to try all combinations?
17:25:07 <Cale> regalia: and Maybe values as being sort of like lists which have at most one element.
17:25:28 <sm> applicative: oh nice, I could use that sqlite code
17:25:37 <regalia> Cale: continue :)
17:25:43 <ivanm> micah: you might even be able to do it this way (someone, I forget who, suggested it yesterday): cabal install yi -fcocao --constraint="data-accessor == 0.2.1"
17:26:04 <micah> ok
17:26:05 <micah> I'll try
17:26:21 <Cale> If you're always making choices where the number of options to select from is at most one, you never have to go back and revisit your previous selections if you end up with no options at some point.
17:26:53 <Cale> You know immediately that there's no other way you could have made the choices so as to get the computation to succeed
17:27:00 <micah> ivanm: gah! it didn't work :(
17:27:04 <micah> ivanm: bbiab
17:27:30 <regalia> Cale: Ahhh
17:27:36 <Cale> But if there is more than one choice, then when you run into a dead end where there are no options (or even if you don't), you need to go back and try different choices for the things you've selected.
17:28:11 <regalia> Cale: and the List monad does it automatically, and Maybe doesn't
17:28:13 <regalia> ok cool :)
17:28:29 <Cale> > do x <- [1,2,3]; y <- if even x then [10,20] else []; return (x+y)
17:28:30 <lambdabot>   [12,22]
17:29:01 <Cale> So in evaluating this list, x is chosen from [1,2,3] in turn, so we start by trying 1
17:29:13 <Cale> and then y is selected from  if even x then [10,20] else []
17:29:33 <Cale> and x (= 1) isn't even, so we get no options
17:29:34 <regalia> so when return [] comes up it backtracks?
17:29:42 <Cale> when [] comes up
17:29:53 <Cale> return [] would be [[]], which has one element
17:30:15 <regalia> > do x <- [1,2,3,4]; y <- if even x then [10,20] else []; return (x+y)
17:30:16 <lambdabot>   [12,22,14,24]
17:31:06 <Cale> It also "backtracks" once it's already found an element and the evaluation of the list demands another
17:31:20 <regalia> Cale: That's what I was trying to show myself :)
17:31:31 <regalia> Cale: Thank you very much, very helpful!
17:32:11 <regalia> Cale: So I feel like I have a decent understanding of Monads at this point, but I haven't yet thought of any real use that I would have for them.. =\
17:33:07 <Cale> Well, you don't normally hit a problem and say "I'll use a monad!". It's more that libraries you use will happen to be monads.
17:33:41 <monochrom> I did hit a problem and said "I'll use a monad!"
17:33:42 <Cale> Or perhaps libraries you write, if you're lucky enough to stumble onto one.
17:34:15 <regalia> That's kind of what I figured...
17:34:20 <regalia> monochrom: What was your problem?
17:34:22 <Makoryu> regalia: There's no *need* to build a house with a hammer if a screwdriver will work fine. But you should know how to use a hammer, and if you build enough houses you'll eventually find lots of little situations where a hammer will help
17:34:32 <Makoryu> Make sense?
17:34:38 <monochrom> tactics in theorem provers.
17:34:49 <Cale> I'm not sure the hammer thing is the right analogy...
17:35:01 <regalia> Makoryu: Very much so. I was under that impression but second-guessed myself and was not sure.
17:35:12 <Cale> A better analogy is that 'monad' is a particular sort of tool grip.
17:35:14 <Makoryu> Cale: Me either, but it doesn't much matter
17:35:22 <regalia> I get the gist
17:35:31 <monochrom> analogies are like using hammers on programs
17:35:36 <Cale> You don't set out to use a hammer because it has a certain kind of grip, but maybe some of the hammers you use will have that grip.
17:35:37 <Makoryu> Cale: Analogies, after all, are like cars. They break down and then you have to drink the antifreeze to survive the winter.
17:35:59 <regalia> Makoryu: rofl
17:36:17 <Cale> The key point being that the term 'monad' really just implies something about the API of the library you're using.
17:36:34 <gwern> > 1950 / 60
17:36:35 <lambdabot>   32.5
17:37:01 <Cale> and there are some things which work with all monads that you should be aware of -- the functions in Control.Monad particularly -- since they'll come in handy in a wide range of libraries.
17:37:33 <gwern> 32 minutes? wikipedia is lagging *hard*
17:38:29 <Cale> But saying that something is a monad doesn't really tell you an awful lot about what it is.
17:38:35 <monochrom> lagging is hard. let's go shopping.
17:39:37 * gwern thinks that is a bad example of barbie
17:42:13 <edwardk> preflex: xseen dons
17:42:13 <preflex>  dons was last seen on freenode/#haskell 19 hours, 23 minutes and 3 seconds ago, saying: we did some stuff. it was fun. it worked.
17:42:40 <micah> I downgraded data-accessor to 0.2.1 and it still didn't work
17:42:55 <micah> :(
17:43:50 <aavogt> micah: what's the actual error with building yi?
17:44:01 <edwardk> preflex: xseen malcolmw
17:44:01 <preflex>  malcolmw was last seen on freenode/#haskell 13 hours, 42 minutes and 23 seconds ago, saying: yep
17:44:24 <micah> http://gist.github.com/329952
17:46:00 <ivanm> aavogt: the data-accessor instance clash
17:46:07 <ivanm> micah: "ghc-pkg list data-accessor"
17:46:28 <micah> data-accessor-0.2.1
17:46:31 <micah> that's all there is
17:46:32 <aavogt> probably easiest is to   cabal unpack yi;  remove the instance from the file,  then run "cabal install" in the same directory as the yi.cabal
17:46:41 <aavogt> oh, or that
17:47:02 <aavogt> the instance doesn't exist in yi's darcs repo
17:47:12 <micah> ok
17:47:53 <Axman6> ivanm: SIG?
17:47:55 <micah> cabal installing darcs now :P
17:47:55 <ivanm> micah: can you paste the build error up somewhere?
17:48:00 <ivanm> Axman6: Special Interest Group
17:48:08 <Axman6> (sorry, i forgot i had IRC open)
17:48:14 <micah> ivanm: http://gist.github.com/329952
17:48:17 <ivanm> Axman6: heh
17:48:25 <Axman6> ivanm: does it involve using linux?
17:48:34 <ivanm> Axman6: nope, just programming in general
17:48:42 <ivanm> though last night was more hardware hacking
17:48:49 <ivanm> but they want to do some parallel talks in the future
17:48:50 <micah> bbiab
17:48:54 <walrus> hi guys, anyone here has the patch ghc-llvmbackend-full.gz? it appears to be offline in the moment in the only place that I found
17:49:02 * ivanm thinks micah did something wrong...
17:49:30 <ivanm> walrus: is the link the same as the one here? http://alpmestan.wordpress.com/2010/03/11/getting-ghc-head-and-llvm-working-together/
17:49:52 <walrus> ivanm: yeas, exactly
17:51:07 <ivanm> then it must be down
17:51:41 <ivanm> wait, it was on darcs.haskell.org ?
17:51:52 <walrus> the problem is that only in this file on http://www.cse.unsw.edu.au/~davidt/downloads/
17:51:53 * ivanm wonders if replacing darcs with code would give a working URL
17:51:59 <sshc> preflex: sen me
17:52:07 <sshc> preflex: seen me
17:52:07 <preflex>  me was last seen on #gentoo 327 days, 18 hours, 44 minutes and 43 seconds ago, saying:  imagemagick maybe?
17:52:22 <sshc> preflex: seen preflex
17:52:22 <preflex>  what
17:52:22 <walrus> there is a download problem.
17:52:28 <applicative> https://cgi.cse.unsw.edu.au/~davidt/git/ThesisDev.git/
17:52:33 <sshc> preflex: seen preflex
17:52:33 <preflex>  what
17:52:59 <sshc> preflex: seen preflex
17:52:59 <preflex>  what
17:53:16 <sshc> preflex: seen preflex _
17:53:16 <preflex>  what
17:53:56 <sinelaw> @pl \x -> do return (fst x)
17:53:56 <lambdabot> do return . fst
17:54:08 <sm> how do I import Data.List into a ghc -e expression ?
17:54:10 <ivanm> sshc: stop being silly
17:54:15 <ivanm> if you must, use /msg preflex
17:54:22 <ivanm> sm: not sure you can
17:54:29 <ivanm> any particular reason you are doing so?
17:54:37 <ivanm> though maybe Data.List.nub for example might work...
17:54:49 <aavogt> ivanm, micah: so it's this bug: http://code.google.com/p/yi-editor/issues/detail?id=306
17:54:57 <sm> I saw some kind of trick the other day.. I am trying to filter out the excess blank lines after ghc -E
17:55:27 <micah> aavogt: yeah
17:55:34 <sm> ivanm: yes! qualified names work, at least for base, thank you
17:56:09 <micah> aavogt: I installed darcs so I can get the darcs version if I need
17:56:38 <sshc> preflex: seen preflex?
17:56:38 <preflex>  Sorry, I haven't seen preflex?
17:56:42 <sshc> right
17:57:06 <aavogt> well apparently the solution is to use data-accessor <= 0.2.0.2
17:57:13 <micah> ok
17:57:18 <aavogt> or to remove the instance
17:57:18 <ivanm> aavogt: oh? even 0.2.1 had that problem?
17:57:20 <sm> ghc  -e 'interact (unlines . map head . Data.List.groupBy (\a b -> null a && null b) . lines)' < file.hspp
17:57:44 <applicative> sm: http://www.reddit.com/r/haskell/comments/antdq/haskells_tower_of_babel/ has a few examples
17:57:49 <aavogt> ivanm: yep: http://hackage.haskell.org/packages/archive/data-accessor/0.2.1/doc/html/Data-Accessor-Basic.html#t%3AT
17:58:03 <micah> aavogt: so which version should I downgrade to
17:58:35 <sm> applicative: interesting, thanks
17:58:51 <sm> -e ':m + Data.List Data.Ord'  is a nice trick
17:59:01 <ivanm> micah: --constraint="data-accessor<0.2.1"
18:00:05 <applicative> sm: it seems to work, I don't know where he learned them.  Note my amazing development of cgibbard's line
18:00:16 <micah> ivanm, aavogt :yes it worked! thanks :D
18:00:35 <aavogt> I've added a comment on that bug, so maybe something will be done...
18:00:45 <applicative> sm: I mean, I don't know where cgibbard learned all the ghc -e rules
18:01:00 <sm> nice :)
18:02:24 <ivanm> applicative: experimentation?
18:02:33 <ivanm> or you could ask him yourself (cgibbard == Cale)
18:03:13 <copumpkin> I'm guessing there is no way a power set can ever be infinite but countable
18:03:23 <copumpkin> it's either finite or uncountable, right?
18:03:28 <Cale> applicative: -e rules?
18:03:48 <Cale> oh
18:04:20 <dolio> copumpkin: Not within the theory, at least.
18:04:21 <Cale> copumpkin: right.
18:04:46 <Cale> Because the powerset of a finite set is infinite, and the powerset of the smallest infinite set is uncountable.
18:04:46 <dolio> Since power sets are bigger than the set they're over, and countable sets exist by fiat, not because they're a power set of something else.
18:04:53 <applicative> Cale: sorry for waking you up, sm was asking about the command 'ghc -e'
18:05:14 * copumpkin goes in search of a set whose powerset is countably infinite!
18:05:25 <copumpkin> I will find one or die trying! (the latter is more likely)
18:05:28 <ivanm> @time Cale
18:05:28 <lambdabot> Local time for Cale is Thu Mar 11 21:05:04
18:05:34 <Alpounet> walrus, ping ?
18:05:39 <ivanm> copumpkin: so we don't expect to see you for a while then? :p
18:05:44 <Cale> Oh, it's just like ghci, only allows you to write on the commandline what you would have given to ghci as input
18:05:45 <ManateeLazyCat> Alpounet: David is busy people?
18:05:46 <micah> yi -f cocoa is now working! :dDDDD
18:05:47 <ivanm> applicative: I doubt we woke him...
18:05:49 <micah> thanks you awesome people
18:05:52 <walrus> Alpounet: ping
18:06:02 <Alpounet> walrus, actually the link is valid, just wget it
18:06:10 <sm> Cale: good tip
18:06:12 <Alpounet> chrome tells me the page is unavalaible
18:06:29 <ivanm> Alpounet: I'm guessing the wrong mime type is reported or something
18:06:32 <Alpounet> but it's just that it has .gz extension whereas it actually just is a darcs patch
18:06:38 <Alpounet> ivanm, exactly :)
18:06:40 <ManateeLazyCat> Alpounet: I have send mail to David for join qtHaskell, but haven't any response.
18:06:42 <ivanm> is it compressed or not?
18:06:49 <Alpounet> ivanm, no
18:06:56 <Alpounet> actually we just have to darcs apply it
18:06:58 <Alpounet> and it works fine
18:07:00 <Alpounet> :/
18:07:04 <ivanm> well, doesn't mean it isn't compressed ;-)
18:07:10 <walrus> Alpounet: damn it... wget worked! thanks. (But why didn't worked in Chrome?)
18:07:22 <ivanm> walrus: probably wrong mime type
18:07:25 <Alpounet> walrus, Chrome thinks it's a gzipped file
18:07:28 <ivanm> so the browser tried to open it wrong
18:07:30 <Alpounet> (via the mime type)
18:07:37 <Alpounet> walrus, by the way
18:07:38 <ManateeLazyCat> Alpounet: I'm reading qtHaskell yesterday, and found missing two important modules i need: QtDBus and QtX11Embbed*
18:07:41 <ivanm> Alpounet: well, then it would offer to let you download it
18:08:02 <Alpounet> you can verify it by clicking on " More information on this error "
18:08:14 <Alpounet> ivanm, I agree but chrome doesn't
18:08:15 <walrus> Error 330 (net::ERR_CONTENT_DECODING_FAILED): Unknown error.
18:08:20 <Alpounet> yeah, ivanm ^^^^
18:08:29 <Alpounet> that's what chrome says
18:08:41 <applicative> sm: Maybe, you saw this discussion, that's the other place I read about it recently, apart from cgibbard's illustration: http://www.haskell.org/pipermail/haskell-cafe/2010-January/071718.html
18:08:46 <Alpounet> ManateeLazyCat, well, yeah he seems busy, few other people contacted him, unsuccessfully so far
18:09:03 <Alpounet> but don't hesitate to work on these stuffs
18:09:03 <ivanm> Alpounet: which is why I'm thinking the reported mime type is _not_ .gz
18:09:18 <Alpounet> ivanm, it's not plain text neither though
18:09:22 <applicative> sm: there seemed to be dispute about whether there was a bug or not
18:09:30 <walrus> yes, isn't a gzipped file. now everything make sense :P
18:09:37 <ManateeLazyCat> Alpounet: Bad, do you know any open repository for qtHaskell? Darcs or Git?
18:09:38 <walrus> the file is a plain text.
18:09:47 <ManateeLazyCat> Alpounet: If have, i can send patch.
18:10:01 <Alpounet> ManateeLazyCat, no, I couldn't find it, but write an email again
18:10:09 <ManateeLazyCat> Alpounet: I can't work on qtHaskell, if haven't QtDBus and QtX11Embbed
18:10:16 <Alpounet> he'll finally answer I guess :p
18:10:41 <ManateeLazyCat> Alpounet: Or he give me wrong mail address? :)
18:10:57 <sm> applicative: that's the thread. thanks!
18:11:20 <sm> I pasted my pastebot code btw
18:11:28 <applicative> copumpkin:  this is why omega is an inaccessible cardinal, if I remember
18:11:38 <ManateeLazyCat> Alpounet: Infact, i can hacking qtHaskell myself, but i will use shorter time if he give some information.
18:11:42 <applicative> copumpkin, or rather, why aleph null is
18:12:47 <ManateeLazyCat> Alpounet: BTW, have you contact him successfully?
18:12:52 <Alpounet> ManateeLazyCat, sure but until you have an answer from him, you will have to handle this on your own
18:13:01 <Alpounet> ManateeLazyCat, I did at some time, didn't try last days
18:13:08 <sinelaw> > [1..0]
18:13:09 <lambdabot>   []
18:13:33 <ManateeLazyCat> Alpounet: Or any open mail-list for qtHaskell?
18:13:52 <Alpounet> neither, afaik
18:13:54 <ManateeLazyCat> Alpounet: I haven't found it.
18:13:55 <Alpounet> ask him
18:14:07 <ManateeLazyCat> Alpounet: Bad :-(
18:14:13 <Alpounet> I'm not in anyway involved in qthaskell
18:14:18 <Alpounet> I just played with it at some moment
18:14:20 <Alpounet> that's all
18:14:21 <Alpounet> sorry
18:14:49 <ManateeLazyCat> Alpounet: That's mean i need spend more time on qtHaskell patch, but i haven't some much time.
18:14:54 <Alpounet> walrus, by the way, I'm adding that information as comment
18:15:18 <ManateeLazyCat> Alpounet: Yesterday i read Qt 4.5 API, cleaner API.
18:15:20 <Alpounet> don't think I'm telling you that a second time or so, just that it may be of interest to people having trouble :)
18:15:32 <Alpounet> ManateeLazyCat, 4.6 is even better :)
18:15:39 <Alpounet> animation framework
18:15:43 <Alpounet> declarative UI framework
18:15:45 <Alpounet> and so on
18:15:53 <ManateeLazyCat> Alpounet: And have many other non-GUI API that Gtk+ haven't
18:16:19 <ManateeLazyCat> Alpounet: That's why i want switch to qtHaskell, even gtk2hs can work now.
18:16:40 <ManateeLazyCat> Alpounet: Yep, i saw those on Qt homepage.
18:17:05 <ManateeLazyCat> Alpounet: The most interested is QtWebkit.
18:17:47 <ManateeLazyCat> Alpounet: It's hard to decide.
18:18:40 <Alpounet> heh
18:18:48 <Alpounet> the problem with qthaskell is its closedness
18:18:54 <Alpounet> but it can be changed in my opinion
18:18:56 <Alpounet> let's see
18:18:58 <applicative> sm: I see you pasted code for  http://hub.hledger.org/  on http://hub.hledger.org/ somehow I wasn't thinking.  Now you'll get hit with all the spam.
18:19:11 <ManateeLazyCat> Alpounet: Yep
18:19:43 <sm> applicative: yes, I put it there for your interest.. how's that bringing the spam ?
18:19:46 <ManateeLazyCat> Alpounet: If it just have open response for developer like gtk2hs, that's okay, but it haven't
18:20:19 <Mathnerd314> finally, proof that ZipList is a monad: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23915#a23915
18:20:19 <applicative> sm:  there was some discussion of the spam on hpaste.org
18:20:33 <ManateeLazyCat> s/reponse/repository
18:22:30 <ManateeLazyCat> Alpounet: Qt have another advantage: signal/slot instead callback, that make me write independent module.
18:22:52 <Alpounet> yeah
18:22:56 <Alpounet> this mechanism is powerful
18:23:07 <Alpounet> I know Qt (C++ version) quite well
18:23:10 <Alpounet> have been using it for years
18:24:25 <ManateeLazyCat> Alpounet: I think David have some "code generator" tools for qtHaskell, that's i want. That's will save much time.
18:25:09 <ManateeLazyCat> Alpounet: Before, i use hand write gtk2hs patch line by line, and last Axel tell me can use "code generator" generate most code of patch. :)
18:25:23 <aavogt> preflex: seen jeffwheeler
18:25:23 <preflex>  jeffwheeler was last seen on #haskell 12 days, 5 hours, 5 minutes and 51 seconds ago, saying: benmachine: yeah, I saw the underline but assumed my spell-checker sucked
18:25:58 <ManateeLazyCat> Alpounet: I never use Qt before, but yesterday i read some book about Qt4, that's really awesome.
18:26:23 <Alpounet> yeah :)
18:26:25 <ManateeLazyCat> Alpounet: And Qt have better documentation than Gtk+
18:26:26 <Mathnerd314> copumpkin: <Mathnerd314> finally, proof that ZipList is a monad: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23915#a23915
18:26:41 <Alpounet> ManateeLazyCat, yeah there's a generator IIRC, isn't it in the qthaskell archive ?
18:27:26 <ManateeLazyCat> Alpounet: I think have a generator, and C++ -> Haskell easier can C -> Haskell.
18:28:06 <ManateeLazyCat> Alpounet: Manual is slow and buggy.
18:28:44 <Alpounet> yeah
18:29:49 <ManateeLazyCat> Alpounet: Do you know any resource (website) that introduce how to patch qtHaskell?
18:29:59 <ManateeLazyCat> Alpounet: Sorry, just ask. Nevermind.
18:30:06 <Alpounet> no
18:30:18 <Alpounet> the better now for you is to see how he does it through the code
18:30:31 <applicative> sm: I see, you separate the pastes by storing each as its Haskell show value.
18:30:33 <Alpounet> I'm affraid I can't help you any more
18:31:05 <sm> applicative: yeah, for today
18:31:06 <ManateeLazyCat> Alpounet: I haven't found any generator in qtHaskell archive.
18:31:10 <Alpounet> ok
18:31:14 <Alpounet> good luck heh
18:31:46 <ManateeLazyCat> Alpounet: Can you tell me other advantages in Qt? i'm reading a Qt Book. :)
18:32:21 <ManateeLazyCat> Alpounet: Example, i found Splitter in Qt better than Paned in Gtk+
18:32:23 <copumpkin> Mathnerd314: cool :) now learn agda and write it up there :)
18:32:31 <Mathnerd314> agda?
18:32:36 <ManateeLazyCat> Alpounet: Gtk+/Paned just allowed two child widget.
18:32:41 <copumpkin> Mathnerd314: like haskell, but proofier
18:32:50 <ManateeLazyCat> Alpounet: But Splitter allowed any number.
18:32:59 <copumpkin> Mathnerd314: not sure if you saw my lame proof of even and oddness earlier, but that was agda
18:33:06 <Mathnerd314> ok.
18:33:37 <Mathnerd314> It looks like I need emacs, though?
18:33:57 <copumpkin> yeah, but you learn to love it
18:34:01 <copumpkin> I only use emacs for agda :)
18:34:49 <Mathnerd314> the download URL http://www.coverproject.org/Agda/ seems broken
18:34:58 <copumpkin> oh that isn't it
18:35:01 <copumpkin> cabal install agda
18:35:29 <Mathnerd314> yeah, just found that.
18:35:44 <Alpounet> ManateeLazyCat, I must admit the list would be quite long. I just find Qt to scale much better for large applications, and feel more confortable with the way you develop things around it, due to many reasons, but mostly because of the signal/slot mechanism
18:35:50 <copumpkin> anyway, just a suggestion, but it's one of my favorite things ever
18:36:39 <Mathnerd314> most of that proof could have been written by a good type system ;-)
18:37:02 <ManateeLazyCat> Alpounet: Yep, I love signal/slot two, too flexibility. :)
18:37:24 <ManateeLazyCat> s/two/too damn english-helper
18:37:55 <copumpkin> Mathnerd314: well, agda won't write it for you, but it can definitely check it
18:38:08 <copumpkin> Mathnerd314: unfortunately to emulate Haskell's lists you're going to need to venture into the scary realm of codata :)
18:38:23 <dolio> Mathnerd314: Your induction is missing some cases.
18:38:24 <Mathnerd314> codata?
18:38:30 <Mathnerd314> dolio: where?
18:38:31 <copumpkin> and the sad thing is that you can't even avoid it
18:38:33 <ManateeLazyCat> Alpounet: Thanks for your help, i will try to hacking qtHaskell self, hope David will rely my mail.
18:38:34 <dolio> You haven't proved what happens with bottoms.
18:38:37 <copumpkin> because your instance is using repeat for return
18:38:55 <Alpounet> ManateeLazyCat, good luck
18:38:55 <dolio> And your definition of the monad produces bottoms in some cases, because tail is partial.
18:39:23 <Mathnerd314> bottoms are [], unless I'm mistaken
18:39:27 <copumpkin> nope
18:39:34 <copumpkin> bottoms are errors and non-termination
18:39:41 <ManateeLazyCat> Alpounet: I will ask you question about Qt, studying. :)
18:39:58 <ManateeLazyCat> Alpounet: See you.
18:40:01 <Mathnerd314> but I check for [] in all cases
18:40:10 <dolio> For instance "let f i = replicate i i in [3,2,1] >>= f" produces (3:2:undefined).
18:40:26 <Alpounet> no problem ;)
18:41:08 <copumpkin> dolio: hm?
18:41:32 <dolio> He defined an alternate monad for [], not for a newtype.
18:41:40 <copumpkin> oh, I see
18:44:05 <dolio> Perhaps you want drop 1 instead?
18:44:40 <Mathnerd314> yeah, I want something where f [] = []
18:45:26 <Mathnerd314> so tail doesn't do that?
18:45:32 <dolio> No.
18:45:38 <copumpkin> > tail []
18:45:39 <lambdabot>   * Exception: Prelude.tail: empty list
18:45:43 <copumpkin> > drop 1 []
18:45:44 <lambdabot>   []
18:45:52 <ivanm> > drop (-1) [2]
18:45:53 <lambdabot>   [2]
18:46:01 <Emzzzz> http://imggmi.info/DSC-1268361547.jpg/ do my tits look big?
18:46:05 <Mathnerd314> ok... s/tail/drop 1/ then
18:46:06 <ivanm> aww, it doesn't magically add elements :(
18:46:09 <ivanm> bloody spammers
18:46:28 <ivanm> it's an australian spammer? :o
18:46:48 <Mathnerd314> someone with a proxy in australia, maybe
18:47:07 <ivanm> hmmm, could be
18:47:11 <copumpkin> those australians are so immoral
18:47:16 <ivanm> @slap copumpkin
18:47:16 * lambdabot throws some pointy lambdas at copumpkin
18:47:21 <copumpkin> I wouldn't be surprised if the spammer was australian
18:47:30 <ivanm>  [Whois] Emzzzz is ~Emzzzz@pa58-109-217-87.pa.vic.optusnet.com.au ( Emzzzz)
18:49:40 <Mathnerd314> wow, Agda is huge.
18:49:51 <copumpkin> it's a whole programming language :)
18:50:20 <Mathnerd314> so?
18:50:24 <Mathnerd314> ;-)
18:50:31 <copumpkin> it does some pretty cool things
18:50:43 <Mathnerd314> so? ;-)
18:50:52 <jmcarthur> well, that's why it's huge ;)
18:51:01 <Mathnerd314> assembly does cool things!
18:51:02 <copumpkin> it's allowed to be huge
18:51:17 <copumpkin> assembly doesn't take any thought
18:51:20 <copumpkin> the CPU is already there
18:51:24 <jmcarthur> assembly does not do cool things as awesomely
18:51:37 <Mathnerd314> jmcarthur.points++
18:51:57 <Mathnerd314> oops, not haskell...
18:51:58 <jmcarthur> @karma jmcarthur.points
18:51:58 <lambdabot> jmcarthur.points has a karma of 1
18:52:05 <jmcarthur> you did it wrong ;)
18:52:21 <Mathnerd314> jmcarthur++
18:52:28 <Mathnerd314> @karma jmcarthur
18:52:28 <lambdabot> jmcarthur has a karma of 2
18:52:34 <jmcarthur> :D
18:52:50 <Mathnerd314> @karma Mathnerd314
18:52:50 <lambdabot> You have a karma of 0
18:52:54 <applicative> jmcarthur++
18:53:05 <applicative> @karma jmcarthur
18:53:06 <lambdabot> jmcarthur has a karma of 3
18:53:07 <Mathnerd314> oh well. :-/
18:53:15 <jmcarthur> it's karma day for me i gues :)
18:54:00 <applicative> wait, but I don't know how the signs work, is 3 good for karma, or is -3 good karma?
18:54:19 <applicative> jmcarthur--
18:54:23 <regalia> allCombinations fn (x:xs) = foldl (liftM2 fn) x xs
18:54:31 <applicative> @karma jmcarthur
18:54:31 <lambdabot> jmcarthur has a karma of 2
18:54:38 <jmcarthur> aw :(
18:54:43 <regalia> I'm confused on why fn has to be lifted...
18:54:50 <copumpkin> regalia: you could use foldl1
18:54:51 <applicative> jmcarthur++
18:54:52 <ivanm> applicative: higher is better
18:54:58 <applicative> now ill stop spamming
18:55:06 <regalia> allCombinations fn (x:xs) = foldl1 (liftM2 fn) xs
18:55:14 <regalia> copumpkin: correct?
18:55:18 <copumpkin> not quite
18:55:50 <Alpounet> @karma copumpkin
18:55:51 <lambdabot> copumpkin has a karma of 8
18:56:04 <copumpkin> :t foldl1 . liftM2
18:56:05 <lambdabot> forall r (m :: * -> *). (Monad m) => (r -> r -> r) -> [m r] -> m r
18:56:47 <regalia> How would it be written without lifting fn?
18:56:54 <aavogt> @type foldl1 . liftA2
18:56:55 <lambdabot> forall c (f :: * -> *). (Applicative f) => (c -> c -> c) -> [f c] -> f c
18:57:25 <copumpkin> regalia: it wouldn't be
18:57:26 <aavogt> @type \f -> fmap (foldl1 f) . sequence
18:57:27 <lambdabot> forall a (f :: * -> *). (Functor f, Monad f) => (a -> a -> a) -> [f a] -> f a
18:57:27 <walrus> damn... after one hour of ghc compiling, the process stopped in an error that I don't have any idea what is.
18:57:55 <regalia> copumpkin: Ahhh
18:57:56 <copumpkin> omg it's Jamie Hyneman
18:58:06 <ivanm> wtf?
18:58:18 <regalia> copumpkin: It's since it takes [[a]], it has to deal with those lists by lifting the function
18:58:26 <copumpkin> yep
18:58:30 <ivanm> copumpkin: just because we had esr here the other day doesn't mean we're getting _all_ of your idols in here
18:58:31 <walrus> anyone knows what is this error? http://haskell.pastebin.com/BeTHPNVp
18:58:37 <walrus> error: âTVAR_WATCH_QUEUEâ undeclared (first use in this function)
18:58:42 <copumpkin> ivanm: look, he just asked about his error
18:59:18 <ivanm> copumpkin: and how did you arrive at that conclusion from "walrus"?
18:59:33 <Mathnerd314> so why aren't errors part of the type?
18:59:54 <aavogt> @hackage explicit-exception
18:59:54 <lambdabot> http://hackage.haskell.org/package/explicit-exception
18:59:56 <ivanm> Mathnerd314: hmmm?
19:00:21 <ivanm> oh, you mean something like: ContainsErrors FooError (Maybe Int) ?
19:00:27 <ivanm> because that's fugly?
19:00:35 <Mathnerd314> like, I should have been able to tell that tail was not a total function by its type signature
19:00:45 <copumpkin> I agree
19:00:47 <copumpkin> but others don't
19:01:18 <ivanm> Mathnerd314: because it would then be harder to use the result of tail elsewhere
19:01:27 <ivanm> since the types wouldn't match up if it didn't return a list
19:01:34 <aavogt> types make it harder to write code
19:01:36 <Mathnerd314> something like tail :: [a] -> ([a],error)
19:01:45 <ivanm> I agree that there needs to be a better way of documenting which Exceptions a function could return
19:01:47 <dolio> That isn't possible unless you consign general recursion to a monad.
19:01:48 <Mathnerd314> aavogt: that's why there's type inferencing!
19:02:04 <ivanm> but that's a documentation issue, not a type issue
19:02:06 <Mathnerd314> dolio: how so?
19:02:09 <dolio> (Or something like a monad.)
19:02:13 <ivanm> Mathnerd314: it's hard to chain functions together that way
19:02:33 <Mathnerd314> it's all part of the type; a built-in monad, basically
19:02:34 <dolio> Mathnerd314: Because with general recursion, I can write "tail (x:xs) = x ; tail [] = <loop forever>".
19:02:35 <ivanm> Mathnerd314: anyway, that's why we have this nice little thing we like to call "documentation"
19:02:45 <copumpkin> Mathnerd314: [a] -> Maybe [a]
19:03:05 <ivanm> yeah; Maybe is the synonymous type used when the result might nto be calculable
19:03:09 <Mathnerd314> Maybe isn't right, since you can have multiple types of errors?
19:03:21 * ivanm likes to use listToMaybe for a "safe" head
19:03:22 <copumpkin> Mathnerd314: Either then, but with head you can only have one kind of error
19:03:24 <ivanm> @type listToMaybe
19:03:25 <lambdabot> forall a. [a] -> Maybe a
19:03:30 <dolio> So unless you need a special type to loop forever (and thus do other general recursive stuff), you can't track what functions might yield bottom in some cases.
19:03:33 <applicative> walrus: are you building ghc HEAD
19:03:47 <ivanm> applicative: he is, to try and get LLVM patches working
19:04:31 <Mathnerd314> so why do you have to put in do blocks all the time?
19:04:43 <Mathnerd314> couldn't that just be type-inferenced?
19:04:55 <copumpkin> do blocks are just syntactic sugar
19:04:57 <walrus> applicative: yes, I'm trying
19:05:24 <pikhq> Mathnerd314: You don't.
19:05:29 <ivanm> Mathnerd314: because using do blocks looks nicer than using getLine >>= \ x -> putStrLn (map toUpper x)
19:05:47 <ivanm> @undo do { x <- getLine; putStrLn $ map toUpper x }
19:05:48 <lambdabot> getLine >>= \ x -> putStrLn $ map toUpper x
19:05:56 <dolio> Yeah, but is it better than 'getLine >>= putStrLn . map toUpper'?
19:05:57 <tensorpudding> do blocks don't always look nicer
19:05:57 <ivanm> Mathnerd314: ^^ it's just syntactic sugar for monads anyway
19:06:04 <copumpkin> @redo getLine >>= \ x -> putStrLn $ map toUpper x
19:06:05 <lambdabot> Maybe you meant: do read todo undo
19:06:07 <applicative> what dolio said
19:06:10 <ksf> putStrLn . (map toUpper) =<< getLine
19:06:12 <ivanm> dolio: couldn't think of a better example off the top of my head ;-)
19:06:19 <copumpkin> ksf: no parentheses
19:06:23 <ivanm> anyway, when they're longer then it's nicer
19:06:31 <ksf> yeah you're right
19:06:36 <ivanm> copumpkin: that won't work: $ has precedence over the >>= IIRC
19:06:51 <copumpkin> hm?
19:06:58 <ksf> it's a kind of reflex because stuff tends to turn out map (foo . bar)
19:06:58 <ivanm> so it will try to do (getLine >>= \x -> putStrLn) (map toUpper x)
19:07:01 <Mathnerd314> but, if I forget to put do, it will lead to an error, yes?
19:07:01 <ivanm> which is wrong
19:07:05 <ksf> admittedly, I displaced even those
19:07:06 <applicative> how do we get info from lambdabot
19:07:07 <copumpkin> ivanm: I just took the code you wrote there
19:07:12 <applicative> @info ($)
19:07:13 <lambdabot> ($)
19:07:20 <copumpkin> @info is awesome
19:07:20 <lambdabot> is awesome
19:07:32 <applicative> guess that wasn'tit
19:07:35 <dolio> ivanm: Lambda expressions extend to the end of line or next closing paren.
19:07:36 <ivanm> copumpkin: compare my do-version to my >>= version ;-)
19:07:40 <tensorpudding> @info /me is awesome
19:07:41 <lambdabot> (/ me is awesome)
19:07:42 <ivanm> dolio: oh? fair enough then
19:07:45 <tensorpudding> no fun
19:07:58 <copumpkin> ivanm: so I took the output of @undo :)
19:08:19 <ivanm> I've had quite a few problems that ended up being because I used $ in a monadic context
19:08:25 <ivanm> (as in using >>=)
19:08:37 <dolio> ivanm: It'd be pretty heinous if putting a $ in the middle of a lambda expression broke it in half, if you ask me.
19:08:44 <ivanm> actually, I mis-remembered... I was doing something like foo `bar` baz $ foobar
19:08:45 <applicative> infixr 0 $    infixl 1 >>=
19:08:54 <ivanm> dolio: yeah, I remembered wrong :s
19:09:06 <ivanm> _anyway_
19:09:22 <monochrom> parentheses and $ are sorry excuses for syntax
19:09:28 <ivanm> Mathnerd314: if you want to use do-syntax, then you need the do there to tell ghc what you're doing
19:09:33 <Makoryu> Yeah, we should all use J instead
19:09:48 <Mathnerd314> ivanm: but why does ghc need to know what I'm doing?
19:09:50 <ivanm> and most of us use do-syntax at least for longer code because it's nicer/cleaner than explicitly using >>=, etc.
19:10:04 <Makoryu> Mathnerd314: To compile your code, you mean? O_o
19:10:04 <ivanm> Mathnerd314: well, you expect it to do what you want, don't you?
19:10:20 <Mathnerd314> no, I expect it to spit out errors
19:10:25 <ivanm> Mathnerd314: without the do keyword, it will parse the first expression and not know that it's meant to keep on going
19:10:40 <ivanm> (well, that's probably wrong)
19:10:50 <ivanm> the syntax used within do-blocks isn't valid elsewhere
19:11:03 <ivanm> i.e. usage of <- , and let statements without a corresponding in
19:11:18 <ivanm> also having each line be a separate statement without needing any explicit composition
19:11:20 <Makoryu> Well, a similar syntax is valid in list comprehensions... But never mind that
19:11:33 <ivanm> Makoryu: I was trying to avoid bringing that up ;-)
19:11:40 <Makoryu> >_>
19:11:40 <tensorpudding> list comprehensions are sugar for the list monad isn't it
19:11:41 <Makoryu> <_<
19:11:47 <ivanm> don't list comprehensions de-sugar down to do-blocks or something anyway?
19:11:49 <Makoryu> tensorpudding: More or less
19:11:50 <ivanm> tensorpudding: yeah
19:12:16 <ddarius> No they don't.
19:12:51 <copumpkin> they give you the list MonadPlus!
19:12:59 <ddarius> @undo [x | k <- ks, x <- f k, p x]
19:12:59 <lambdabot> concatMap (\ k -> concatMap (\ x -> if p x then [x] else []) f k) ks
19:13:23 <aavogt> @@ do undo [x | k <- ks, x <- f k, p x]
19:13:24 <lambdabot>  do undo [x | k <- ks, x <- f k, p x]
19:13:31 <aavogt> @@ @do @undo [x | k <- ks, x <- f k, p x]
19:13:31 <lambdabot>  concatMap (\ k -> concatMap (\ x -> if p x then [x] else []) f k) ks
19:13:40 <ni|> hey all
19:13:45 <ni|> Cale: long time no see :)
19:13:51 <ni|> llvm stuff is exciting
19:14:19 <Axman6> it sure is
19:14:23 <ivanm> aavogt: methinks you were after @.
19:14:32 * Axman6 wants some LLVM juicy goodness
19:14:41 <ivanm> Axman6: anyway, would you be interested into going to any of these SIG talks in future?
19:14:46 <ivanm> once a month on a thursday nights
19:14:48 <ivanm> *night
19:14:50 <losl> Does the memory allocated for "where" stick around like it does for let?
19:15:04 <ivanm> losl: where is syntactic sugar for let
19:15:22 <copumpkin> losl: if you're thinking about memory allocation and sticking around you're probably doing it wrong
19:15:29 <ivanm> agreed
19:15:37 <ivanm> unless you mean during the function call
19:15:49 <losl> I'm just learning haskell and I'm a little confused still I guess?
19:15:51 <ivanm> between function calls, only stuff that is statically compiled/evaluated "stays around"
19:16:01 <aavogt> depends what the where is attached to
19:16:07 <copumpkin> yeah
19:16:38 <copumpkin> @hackage memocombinators
19:16:38 <lambdabot> http://hackage.haskell.org/package/memocombinators
19:16:46 <copumpkin> wow, I fail every time I try to use @hackage
19:16:52 * copumpkin bans himself from using that again
19:16:59 <ivanm> heh
19:17:09 <aavogt> if it's attached to a top-level value (it's type has no `->'), then it sticks around
19:17:10 <ivanm> walrus: why are you sending it to me?
19:17:16 <ivanm> any particular reason for not pasting it somewhere?
19:17:17 <gwern>  @hackage doesn't check stuff
19:17:19 <gwern> known issue
19:17:23 <copumpkin> gwern: yeah, I know
19:17:27 <copumpkin> it's just "..." ++
19:17:28 * ivanm points out that he has never built HEAD ghc
19:17:28 <aavogt> copumpkin: \bot should check existence and possibly correct links?
19:17:36 <copumpkin> aavogt: that'd be great
19:17:42 <Alpounet> compupkin: expected type Need -> Package, inferred type Need -> Maybe Package (<- Nothing)
19:17:51 <copumpkin> Alpounet: :)
19:17:52 <ivanm> aavogt: go forth and implement!
19:17:59 <aavogt> only you can write lambdabot modules
19:18:14 <losl> Okay so, I was correct in my original assumption that the variables in a function body don't penalize me?
19:18:24 <ivanm> really? in that case I must have written them all in the future and sent them back in time to bring about the rise of the machines!
19:18:31 <ivanm> losl: huh?
19:18:39 <ivanm> what do you mean by "penalise"?
19:18:40 <applicative> \me build ghc HEAD by accident once.
19:18:51 <ivanm> applicative: s+\+/+
19:19:22 <applicative> built for build
19:19:44 * Alpounet wrote a blog post about 24 hours ago explaining how to build HEAD, even with the llvm backend
19:20:25 <ivanm> Alpounet == Alp Mestanogullari?
19:20:31 <walrus> wait, the blog post that I'm folowing is of Alpounet?
19:20:33 <applicative> Alpounet, it isn't stopping walrus's errors
19:20:43 <ivanm> "C++ for pleasure"? really?
19:20:50 <copumpkin> ivanm: yep
19:20:54 <Cale> ni|: hello -- did you have a different nick before?
19:20:55 <Alpounet> ivanm, oh yeah
19:20:59 <aavogt> losl: if you stick a common subexpression into a where instead of writing it out 2 times, you will use more space to avoid re-computing it
19:21:00 <Alpounet> walrus, yeah
19:21:10 <ivanm> what ethnicity is that surname of yours?
19:21:14 <ni|> Cale: bbs?
19:21:21 <Alpounet> ivanm, told ya, advanced C++ can be exciting, if you go beyond the syntax
19:21:21 <ivanm> preflex: seen bbs
19:21:22 <preflex>  Sorry, I haven't seen bbs
19:21:29 <c_wraith> aavogt: that's only sometimes true
19:21:34 <Cale> ni|: ah, that's more familiar
19:21:50 <Alpounet> ivanm, Turkish
19:21:55 <ivanm> hmmm...
19:21:55 <walrus> Alpounet: nice! any idea about my error?
19:22:00 <ni|> Cale: are you familiar with least squares
19:22:03 <Alpounet> walrus, can you show it to me again please ?
19:22:09 <aavogt> c_wraith: yeah, if it's a function or otherwise polymorphic it will get recomputed
19:22:11 * ivanm lives above a turkish restaraunt... >_>
19:22:12 <ivanm> ;-)
19:22:15 <Alpounet> ivanm, but I'm a French guy otherwise
19:22:15 <Alpounet> oh
19:22:16 <Alpounet> damn
19:22:19 <Alpounet> you're so lucky
19:22:20 <walrus> here: http://haskell.pastebin.com/BeTHPNVp
19:22:22 <Alpounet> I miss Turkish food
19:22:23 <ivanm> heh
19:22:30 <walrus> error: âTVAR_WATCH_QUEUEâ undeclared (first use in this function)
19:22:37 <aavogt> c_wraith: or there are other cases?
19:22:38 <walrus> and other similar messages
19:22:43 * ivanm wonders if the patch still works properly on HEAD
19:22:54 <Cale> ni|: Yes, though it's not something I've really thought about much since I learned about it in linear algebra class.
19:22:55 <ivanm> walrus: you already built llvm with the patch?
19:23:02 <ivanm> note that llvm HEAD now has the patch in it...
19:23:06 <walrus> ivanm: yes
19:23:34 <ivanm> actually.... the LLVM patch was re-done; maybe the GHC patch needs updating to work with it?
19:23:46 <Alpounet> don't think so
19:23:59 <Alpounet> the LLVM patch is about informing LLVM about GHC's calling conventions mostl
19:24:01 <Alpounet> +y
19:24:14 <Alpounet> whereas GHC's patch introduces a new code generator
19:24:16 <c_wraith> aavogt: for any expression that uses a lot of memory simultaneously to calculate a small result.
19:24:17 <kmc> advanced C++ can be exciting, if you find it exciting to implement Maybe in 1000 lines of code
19:24:37 <kmc> or if you find it exciting to instantiate a small set of macros ("design patterns") by hand, over and over
19:24:42 <Alpounet> kmc, let's not start this discussion again, heh
19:24:59 <Pseudonym> Maybe is already implemented in Boost.
19:25:04 <Alpounet> you don't like it, I get it
19:25:08 <kmc> yes, boost is advanced C++
19:25:38 <Pseudonym> The real story here is that C++ is only useful if it's advanced.
19:25:49 <Alpounet> walrus, even if I did what I describe in the blogpost about 3 or 4 times
19:25:53 <Alpounet> I never got that
19:25:53 <kmc> it is a fun challenge to learn C++ and figure out how to use its bizarre feature set to achieve some practical goal
19:26:03 <Pseudonym> Most people only do maths to high school level, so never really learn what real maths is.
19:26:07 <kmc> as with Brainfuck or INTERCAL
19:26:16 <Makoryu> C++ is the Dwarf Fortress of programming languages.
19:26:17 <Pseudonym> It would be like if you thought that playing piano was doing scales.
19:26:31 <Alpounet> Pseudonym, don't try to convince him of anything
19:26:34 <walrus> Alpounet: what was your ghc version?
19:26:36 <Alpounet> he won't even try to get your point
19:26:42 <kmc> the real story here is that #haskell is the premier IRC channel for arguing about C++
19:26:47 <Pseudonym> That's true.
19:26:49 <Alpounet> walrus, 6.12.1 (I mean I'm building HEAD with 6.12.1)
19:27:10 <Makoryu> kmc: That's 'cause Haskell is what Sepples always wanted to be, deep within its heart ï¼ãÂ°â¿â¿Â°ï¼
19:27:11 <walrus> Alpounet: the same here.
19:27:12 <Pseudonym> Haskell and C++ have a lot in common, actually.  They both look arcane until you accomplish something nontrivial in them.  In which case, you're hooked.
19:27:29 <Pseudonym> They each require a Zen moment.
19:27:33 <aavogt> @faq is haskell more addictive?
19:27:33 <lambdabot> The answer is: Yes! Haskell can do that.
19:27:46 <pikhq> Pseudonym: ... No. C++ only becomes more arcane the more you do with it.
19:27:56 <applicative> the thought of a C++ zen moment speaks against zen
19:28:04 <Alpounet> not for me
19:28:23 <Pseudonym> Speaking as someone who used to make all of the jibes at C++, I understand where you're all coming from.
19:28:26 <Alpounet> there even is dependent typing there
19:28:41 <Alpounet> the generic & generative power is great
19:28:43 <Makoryu> Yeah, as soon as you understand any given feature in C++, you discover the thousands of frustrating ways in which that feature interacts with everything else you understand :\
19:29:01 <Alpounet> but anyway
19:29:07 <Alpounet> walrus, let me do some searches
19:29:10 <Alpounet> we should find out
19:29:11 <pikhq> Alpounet: ... The generic power of C++ is about on par with C macros in sanity.
19:29:15 <Pseudonym> I do concede, however, that C++ is about as pretty as a large piece of industrial equipment.
19:29:20 <pikhq> (not in expressiveness, but in sanity)
19:29:27 <Makoryu> Pseudonym: On fire?
19:29:31 <Pseudonym> Which is exactly what it is, metaphorically speaking.
19:29:35 <walrus> Alpounet: thanks!
19:29:48 <Makoryu> Pseudonym: If you accept the "on fire" part, it's about as safe as that, as well.
19:29:49 <kmc> i used to hate C++ when i knew only high school level C++
19:30:02 <Makoryu> But also as fun!
19:30:05 <pikhq> kmc: When that was it, it wasn't too bad actually.
19:30:05 <kmc> then i started learning and became an advocate of C++ because learning was fun
19:30:09 <kmc> then i finished learning and i hated it again
19:30:10 <Makoryu> I mean, if you like being on fire.
19:30:12 <pikhq> "Oh, it's C with some extra features?"
19:30:20 <jmcarthur> kmc: i share that experience
19:30:20 <Alpounet> no
19:30:22 <metaperl> I would like to use a simple random sampler (Test.Quickcheck?) to select a random word from the variable test in this code ( http://pastie.org/pastes/866067 )
19:30:24 <kmc> because i realized i'd learned some very fancy ornate ways to do things that should be simple and straightforward
19:30:27 <pikhq> And then... The features... The features!
19:30:29 <Alpounet> it was a piece of shit when it was "C with classes"
19:30:33 <kmc> hooray i know a 3,000 line design pattern for Data.Map !
19:30:41 <kmc> doesn't feel too good in the end
19:30:43 <pikhq> Alpounet: Yes, but not too *bad*.
19:30:49 <Pseudonym> YOu mean std::map?
19:30:51 <Alpounet> it got better with templates
19:30:53 <Alpounet> way better
19:30:54 <Pseudonym> Yeah.
19:30:58 <Alpounet> that's the only point of C++ today
19:31:09 <pikhq> Alpounet: How many languages do you know with good metaprogramming?
19:31:14 <ivanm> metaperl: you'd be better off not using QC just for random numbers
19:31:21 <Pseudonym> pikhq: Exactly none.
19:31:22 <jmcarthur> i like c++ references, too
19:31:27 <Pseudonym> For my definition of "good".
19:31:30 <pikhq> I contend that you need to learn some better languages. Because templates are the worst way to do it.
19:31:32 <metaperl> ivanm: i said random sampling of a list of words
19:31:34 <Pseudonym> And that includes Lisp, Scheme, C++...
19:31:38 <Makoryu> pikhq: I read that as "meatprogramming"
19:31:53 <pikhq> jmcarthur: References aren't too bad. Not my favorite thing in the world, but not too bad.
19:31:55 <Alpounet> pikhq, depends on the threshold
19:31:59 <metaperl> random numbers arehard in Haskell ---
19:32:02 * twink wonders how much Lisp and/or Scheme he actually remembers.
19:32:04 <ivanm> metaperl: no they're not
19:32:06 <Pseudonym> Some languages are better than others, but I'm yet to find a language with metaprogramming that's as good as I want it to be.
19:32:21 <pikhq> I'd prefer it if the referencing was *explicit*.
19:32:21 <ivanm> and by "random sampling" you mean "I want to get x random elements from this list">
19:32:24 <ivanm> ?
19:32:44 <pikhq> Alpounet: You seem to think runtime verbose lambda calculus is good.
19:32:45 * Pseudonym wants a language's metaprogramming facilities to provide full model-driven development
19:32:48 <jmcarthur> pikhq: well, it requires some discipline, but what in c++ doesn't?
19:33:25 <Alpounet> pikhq, I agree C++ is a bit messy, with plenty of features more or less orthogonal, that the syntax is quite frustrating, that having to prefix a template parameter dependent typename with "typename" is annoying, and manyother things
19:33:25 <metaperl> ivanm: yes
19:33:28 <Alpounet> but come on
19:33:34 <pikhq> jmcarthur: It's the "implicitly referenced" thing that I object to. I'd just prefer it if it were like a pointer except without pointer modification.
19:33:53 <Pseudonym> Alpounet: C++'s weakness here is also its strength, namely, that it's mostly backwards-compatible with C.
19:33:57 <pikhq> Or arithmetic.
19:33:59 <Pseudonym> That's the cause of most of its problems.
19:34:07 <Pseudonym> But it's also the cause of its wide adoption.
19:34:11 <ivanm> metaperl: shuffle the list and take the first x
19:34:14 <Alpounet> Pseudonym, yeah, absolutely.
19:34:17 <ivanm> @google haskell list shuffle
19:34:18 <copumpkin> could recursive definitions be called impredicative, in a general sense? or is impredicativity restricted to set definitions?
19:34:19 <lambdabot> http://okmij.org/ftp/Haskell/perfect-shuffle.txt
19:34:26 <ivanm> voila, and that's the one I was after!
19:34:36 <Alpounet> walrus, are you sure you downloaded the full archive from darcs.haskell.org ?
19:34:37 <ivanm> metaperl: ^^ perfect shuffling code for Haskell
19:34:45 <jmcarthur> C++ is assembly with the ability to define some high-level abstractions, which is simply a dangerous thing to wield without *massive* discipline
19:34:49 <metaperl> doesnt System.Random have some shuffling?
19:34:57 * ivanm was going to suggest getting random indices, and then realised that that was stupid
19:34:59 <Alpounet> jmcarthur, yeah
19:34:59 <ivanm> metaperl: nope
19:35:00 <jmcarthur> for that reason i believe c++ is overused
19:35:04 <ivanm> it just generates random numbers
19:35:05 <metaperl> jmcarthur: the same could be said of forth, no?
19:35:07 <pikhq> jmcarthur: Absolutely.
19:35:08 <jmcarthur> not evil, just overused
19:35:11 <ivanm> (not very efficiently at that)
19:35:24 <Pseudonym> jmcarthur: I definitely agree with you that C++ is overused.
19:35:25 <pikhq> I just feel that C++ also makes those high-level abstractions too hard to make, even for what it is.
19:35:40 <Alpounet> pikhq, compared to Haskell, yeah
19:35:41 <monochrom> Haskell is exciting.
19:35:43 <pikhq> (because so much of the language collides with that)
19:35:46 <Mathnerd314> so, a question: suppose I want to make a "log" function, that logs stuff to the outside world
19:35:47 <metaperl> here we go - http://hackage.haskell.org/package/random-shuffle
19:35:47 <Alpounet> but compared to most of the languages out there
19:35:50 <Alpounet> certainly NOT.
19:35:53 <jmcarthur> i think abstraction was the wrong word for me to use
19:35:55 <ivanm> oh, someone has packaged it
19:36:01 <metaperl> System.Random.Shuffle
19:36:01 <Pseudonym> Oh, on metaprogramming: The closest I've seen to Nirvana is ML staged compilation.
19:36:02 <jmcarthur> i think i meant expressivity
19:36:05 <ivanm> metaperl: so even easier for you: you dont' have to copy-paste
19:36:09 <Pseudonym> Unfortunately, it's ML underneath.
19:36:12 <metaperl> let me see
19:36:15 <jmcarthur> abstraction implies that it hides details, which is definitely not true of c++
19:36:23 * ivanm didn't know that was available
19:36:26 <pikhq> Pseudonym: What about Forth?
19:36:26 <Alpounet> jmcarthur, actually you can
19:36:32 <Alpounet> but really too few people know about that
19:36:35 <Pseudonym> Metaprogramming in Forth?
19:36:35 <copumpkin> @remember monochrom Haskell is exciting.
19:36:38 <Alpounet> and how to do it correctly
19:36:47 <jmcarthur> Alpounet: i don't mean things like header files
19:36:52 <Alpounet> yeah
19:36:54 <Pseudonym> If you can't implement yacc in it, it's not real metaprogramming.
19:36:55 <pikhq> ... Yes. You can reimplement all the words.
19:36:56 <ivanm> metaperl: so you do newStdGen in IO and pass it down to your pure function that does the shuffling
19:36:57 <Alpounet> I know what you mean
19:36:59 <pikhq> The parser is a word.
19:37:04 <ivanm> that module is poorly documented :@
19:37:15 <Pseudonym> And even if you can, it's often not real metaprogramming.
19:37:25 <jmcarthur> Alpounet: i'm interested
19:37:29 <walrus> Alpounet: the ghc-HEAD-2009-10-23-ghc-corelibs-testsuite.tar.bz2? I think is the correct one...
19:37:30 <kmc> Mathnerd314, okay
19:37:32 <kmc> Mathnerd314, what's your question?
19:37:39 <walrus> the size is 201643254
19:37:44 <pikhq> Pseudonym: You can make Forth into any other language if you're sufficiently crazy.
19:37:50 <Alpounet> walrus, yeah looks fine
19:37:56 * ivanm doesn't understand why you need to provide an Int for shuffling purposes
19:37:59 <Mathnerd314> kmc: I'll probably implement it as a monad, right? (IO or similar)
19:38:03 <Alpounet> walrus, it looks like you are missing some files
19:38:10 <copumpkin> Mathnerd314: we might use something like Writer for that
19:38:25 <Alpounet> walrus, isn't there any error about a missing header or so ?
19:38:25 <Mathnerd314> the question: what if I want to disable logging?
19:38:33 <kmc> Mathnerd314, your log function can return an action in some monad like IO
19:38:37 <jmcarthur> then ignore the result from Writer :)
19:38:37 <pikhq> Pseudonym: Note that the only thing Forth strictly speaking has is "words". Everything else is simply behavior defined by those words. And you can redefine those words as you like.
19:38:40 <walrus> Alpounet: maybe I made some mess in the /darcs-all pull -a
19:38:42 <ivanm> oh, you pass it the length of the list :s
19:38:42 <kmc> applying a function cannot cause a side effect to occur
19:38:51 <Alpounet> walrus, did you wait until the end ? :p
19:38:59 <ivanm> there's documentation in the code, it just doesn't use haddock markup :s
19:39:00 <Pseudonym> pikhq: Except that you don't get compile-time guarantees.
19:39:03 <walrus> Alpounet, I stopped with Control+C but restarted again
19:39:12 <Alpounet> hm
19:39:22 <pikhq> Pseudonym: ... ?
19:39:43 <Alpounet> walrus, not sure it screwed something
19:39:47 <Pseudonym> Take strong typing, for example.  The advantage is that you can enforce guarantees at compile time.
19:39:58 <Pseudonym> Right?
19:39:59 <pikhq> Forth has no compile-time guarantees.
19:40:03 <Pseudonym> Exactly.
19:40:09 <jmcarthur> Pseudonym: forth doesn't guarantee anything, but it really does have strong metaprogramming facilities
19:40:09 <pikhq> You can readily implement them, however.
19:40:12 <Pseudonym> So you can't emulate compile-time guarantees in Forth.
19:40:16 <pikhq> Such is the power of metaprogramming.
19:40:27 <sshc> > foo
19:40:33 <walrus> Maybe this is the problema, I will try again withou stopping the process... (I just stopped to check with it was downloading something. a progress bar in this part wouldn't be bad)
19:40:40 <pikhq> Sure you can. You simply redefine all the words such that they provide such guarantees.
19:40:43 <copumpkin> @get-Cale
19:40:46 <kmc> Mathnerd314, whether or not logging is enabled sounds like a sort of "configuration parameter" that gets passed to lots of code
19:40:59 <Alpounet> jmcarthur, I have seen *awesome* stuffs in C++. But the kind of guy who can write such beautiful C++ code (I mean that in the calling code, you just write a succession of nice calls, with operator overloads and all, that just looks very nice, a bit like in Haskell -- I said a "bit", I'm not saying it is even close to Haskell's elegance). But I'm just pissed off that people tell such things aren't possible in C++, whereas they are.
19:40:59 <kmc> Mathnerd314, for that sort of thing we might use the Reader monad or the ReaderT monad transformer
19:41:11 <jmcarthur> kmc: actually that is the exact opposite of how i would recommend
19:41:24 <copumpkin> yeah, I wouldn't do that
19:41:25 <kmc> that's fair enough, you should listen to jmcarthur as well :)
19:41:36 <Pseudonym> pikhq: Right, I get what you mean.
19:41:41 <Mathnerd314> well, suppose it's a library that I can't change... is there some way to convert it back to a monad-less function?
19:41:42 <Alpounet> forgot a part of my sentence : "the kind of guy [...] is ONE C++ developer over ... 100.000 ? 1 million ?
19:41:44 <pikhq> Alpounet: Possible? Sure. C++ just gets in the way of that more often than it allows it.
19:41:45 <jmcarthur> i'd lean toward something like Writer or, more flexibly, MonadPrompt, then you could just interpret it differently at the top level
19:41:49 <Pseudonym> It's kind of reductionist, though.
19:41:52 <ivanm> :o who crashed lambdabot?
19:42:00 <kmc> Mathnerd314, depends which monad it uses
19:42:08 <Pseudonym> @botsnack
19:42:11 <kmc> Mathnerd314, there's no *generic* function (Monad m) => m a -> a
19:42:13 <pikhq> Pseudonym: Note that "compile-time" in Forth doesn't mean what you think it does. :P
19:42:17 <kmc> but there are such functions or similar things for some monads
19:42:21 <kmc> notably not IO
19:42:22 <Pseudonym> Well, true.
19:42:27 <Alpounet> pikhq, that's a matter of experience and knowledge
19:42:29 <copumpkin> Writer can be escaped
19:42:31 <Alpounet> like for any other thing
19:42:31 <copumpkin> same with Reader
19:42:37 * Pseudonym notes that it's been a while since he used Forth, and never in anger
19:42:45 <pikhq> Alpounet: The language makes it *harder*, rather than easier, though.
19:42:57 <ivanm> Pseudonym: do you regularly program whilst angry?
19:42:59 <Alpounet> haha pikhq
19:43:01 <Alpounet> I see what you mean
19:43:04 <walrus> now in something completely different, a question in operator precedence: I created a operator (<|) :: A -> (B,C) -> D and a operator (<==) :: B -> C -> (B,C)
19:43:06 <Alpounet> and yeah I agree
19:43:07 <Pseudonym> ivanm: You should see my keyboard.
19:43:09 <jmcarthur> c++ doesn't make it hard, it just makes it really easy to shoot yourself
19:43:11 <ivanm> heh
19:43:12 <Alpounet> but once you're beyond these difficulties
19:43:30 <Alpounet> I mean when you're used to the common problems and know how to solve them
19:43:30 <pikhq> jmcarthur: It makes it hard not to shoot yourself, rather.
19:43:31 <Pseudonym> C++ is hard to use in the same sense that a paint brush is hard to use.
19:43:35 <Alpounet> you can do nice things ;)
19:43:41 <kmc> yeah, if you are really smart you can write C++ code that doesn't crash and is maintainable
19:43:49 <pikhq> Pseudonym: No, more like a paint brush attached to a jackhammer that is on.
19:43:54 <copumpkin> lol
19:43:58 <kmc> seems like a waste of intelligence to me
19:44:00 <monochrom> I am really smart. I use Haskell.
19:44:05 <Mathnerd314> other question: suppose I'm running some evil user-input code...
19:44:08 <walrus> the idea is to use it in expressions like: g <| a <== b . to this i created the right precedence of <== higher than <|
19:44:14 <Pseudonym> kmc: You don't have to be smart to write C++ code that doesn't crash and is maintainable. You just need to forget everything you knew about C.
19:44:16 <kmc> Mathnerd314, what kind of code? and what makes it evil?
19:44:36 <pikhq> Pseudonym: Common C++ idioms, IMO, make code less maintainable.
19:44:46 <pikhq> However, my approach to C++ is somewhat uncommon.
19:44:50 <walrus> but I have a problem with: g <| a <== func $ b c
19:44:52 <pikhq> Step one: Use. Boehm. GC.
19:44:59 <kmc> oh god
19:45:11 <Pseudonym> My step one is install Boost.
19:45:19 <twink> Pseudonym: Hmm. Not sure C++ is so different from C.
19:45:20 <kmc> my step one is don't use C++
19:45:23 <pikhq> Pseudonym: Urgh.
19:45:25 <kmc> anyway, maybe this should go to -blah?
19:45:34 <walrus> Just work with g <| a <== func (b c). Anyone has any idea of how I can achieve this without the parenthesis?
19:45:36 <Pseudonym> Boost is the 10,000 lines of boilerplate and scaffolding that you used to have to write.
19:45:36 <kmc> we are talking about Haskell in the midst of this
19:45:46 <ivanm> orbitz: is this you? http://functional-orbitz.blogspot.com/2010/03/how-much-has-scala-affected-erlang.html
19:45:47 <Pseudonym> Yeah, probably.
19:45:55 <kmc> walrus, you can declare fixity and precedence for your operators
19:46:02 <Alpounet> kmc, it started because of you, remember ?
19:46:05 <Alpounet> ;)
19:46:08 <walrus> kmc: I done that
19:46:18 <applicative> metaperl: did you figure out how to generate random numbers without C++
19:46:25 <metaperl> ivanm: thanks for the link. I will hack away on that
19:46:30 <walrus> infixr 1 <== , infixr 0 <|
19:46:33 <kmc> walrus, perhaps you need ($) to have a different fixity then?
19:46:36 <orbitz> ivanm: yes
19:46:42 <metaperl> applicative: I think this link ( http://okmij.org/ftp/Haskell/perfect-shuffle.txt ) is all I need and a bit of study
19:46:45 <Mathnerd314> kmc: it's user-input. it has to be evil. Particularly, besides doing want I want to do, it opens up /etc/passwd and overwrites it. and I'm running as root, no privileges here.
19:46:58 <walrus> how can I see the precedence of a operator in ghci?
19:47:03 <copumpkin> :i (+)
19:47:05 <monochrom> walrus: Unfotunately $ is at 0, the lowest possible.
19:47:15 <Alpounet> walrus, can we take the discussion about your build problem on #ghc ?
19:47:16 * Mathnerd314 finishes installing Agda
19:47:18 <kmc> you can declare your own operator like ($)
19:47:25 <Alpounet> a bit messy here with these C++ discussions :)
19:47:26 <copumpkin> Mathnerd314: holy crap, that took a long time
19:47:31 <copumpkin> Mathnerd314: now you'll need the standard library
19:47:36 <copumpkin> ;)
19:47:38 <Makoryu> You can use `id`
19:47:46 <Makoryu> Which is (IIRC) higher precedence than $
19:47:48 <ivanm> metaperl: so with that package on hackage, you pass the list, its length and a random seed to it
19:48:01 <orbitz> ivanm: that post is serious bzns
19:48:01 <ivanm> orbitz: were you serious in that post?  or just pre-empting april fool's day?
19:48:09 <Mathnerd314> copumpkin: It's an all-in-one installer: http://wiki.portal.chalmers.se/agda/agda.php?n=Main.Windows
19:48:16 <copumpkin> oh
19:48:19 <walrus> Alpounet: ok, no problem, but I'm waiting the new try to finish.
19:48:21 <ivanm> greetings andyjgill
19:48:28 <copumpkin> Mathnerd314: you windows users get all the perks :)
19:48:35 <andyjgill> hi ivanm
19:48:40 <metaperl> ivanm: it didnt look that simple to me.... what function do you call for such simplicity
19:48:51 <orbitz> ivanm: i hope i don't have to actually answer that
19:48:57 <ivanm> andyjgill: out of curiosity, were you ever planning on putting that video about ICFP that was shown at PEPM online anywhere?
19:49:00 <metaperl> ah shuffle
19:49:08 <ivanm> metaperl: no, shuffle'
19:49:21 <metaperl> ah!
19:49:21 <ivanm> orbitz: I'm really hoping it was a spoof...
19:49:22 <metaperl> yes!
19:49:28 <copumpkin> Mathnerd314: there's also an #agda channel :)
19:49:34 <andyjgill> Oh, we've not even written that up yet. Sigh. too much to do. We need to add it, though.
19:49:36 <walrus> anyone here went to ICFP last year?
19:49:43 <orbitz> ivanm: gotta keep teh mystery alive
19:49:43 <metaperl> and seed is something like this (mkStdGen 17)
19:49:44 <copumpkin> nope, but I intend to go this year
19:50:19 <andyjgill> I was at ICFP.
19:50:38 <ivanm> andyjgill: heh, fair enough
19:50:49 <ivanm> (the effects are definitely cool though)
19:50:49 <walrus> great, maybe I saw you there.
19:51:02 <ivanm> oh, *ICFP contest
19:51:13 <ivanm> since the video wasn't actually about ICFP itself... :s
19:51:14 <andyjgill> ivanm: Glad you liked the effects. we wish we had time to add some more, and polish it a bit more.
19:51:28 <ivanm> what, 24 hours in a day not enough for you? :p
19:51:34 * twink is not in very good shape wrt. making it to conferences in the foreseeable future.
19:51:43 <applicative> the orbitz thing is awesome, i feel privileged to understand so much
19:52:17 <metaperl> thanks ivanm . i will acknowledge you when I finish this contribution to hackage I'm working on
19:53:05 <Makoryu> > length $ take 1 `id` [1..10]
19:53:07 <ivanm> metaperl: heh, no need
19:53:15 <Makoryu> Oh no
19:53:54 <monochrom> lambdabot went out to find lunabot.
19:54:34 <ivanm> heh
19:56:40 <bobtheterminator> hey people, how can I make a list of 1 up to the length of a list?
19:56:46 <bobtheterminator> apparently length returns an Int
19:56:50 <bobtheterminator> but it has to be an Integer?
19:57:15 <copumpkin> :t map fst . zip [1..]
19:57:18 <monochrom> Do you accept [Int]?
19:57:36 <bobtheterminator> um, i dont know
19:57:47 <bobtheterminator> i just tried to do [1..(length values)] and it complained
19:58:07 <ivanm> genericLength ?
19:58:11 <ivanm> @type genericLength
19:58:15 <copumpkin> or just do what I wrote
19:58:19 <ivanm> oh, right, no bot
19:58:27 <bobtheterminator> ok thanks guys
19:58:43 <pickles> what happened to the bot?
19:58:48 <copumpkin> it dies
19:58:51 <copumpkin> not sure why this time
19:58:56 <ivanm> pickles: lambdabot went off to find lunabot
19:58:59 <ivanm> since she was getting lonely
19:59:07 <pickles> lol
19:59:15 <copumpkin> preflex: seen lunabot
19:59:16 <preflex>  lunabot was last seen on #haskell 40 days, 20 hours, 36 minutes and 29 seconds ago, saying:  31
19:59:17 <ivanm> (preflex isn't a very good conversationalist, and hackagebot just sits there doing nothing)
19:59:19 <pickles> maybe we weren't good enough company for it
19:59:28 <ivanm> preflex: seen lambdabot
19:59:28 <preflex>  lambdabot was last seen on #haskell 25 minutes and 9 seconds ago, saying: http://okmij.org/ftp/Haskell/perfect-shuffle.txt
19:59:29 <copumpkin> I hope mmorrow comes back soon
19:59:35 <copumpkin> preflex: seen preflex
19:59:36 <preflex>  what
19:59:40 <ivanm> so my command was the last one she did? :o
19:59:48 <ivanm> copumpkin: any idea where he is?
19:59:51 <applicative> orbitz:  it is little known fact, but consciousness itself was first realized on the JVM, only later was it realized that it was also possible to realize it in humans and other animals.
19:59:55 <ivanm> preflex: seen mmorrow
19:59:56 <preflex>  mmorrow was last seen on #ghc 53 days, 1 hour, 2 minutes and 11 seconds ago, saying: * mmorrow is rtfm'ing
19:59:57 <copumpkin> ivanm: nope, no clue. I tried emailing him but he didn't answer
20:00:06 <copumpkin> he's buried deep in that manual
20:00:15 <ivanm> heh
20:01:00 <ManateeLazyCat> Alpounet: I think something, perhaps i still will stay in gtk2hs, even it haven't better documentation than Qt, but it's have DBus, X11Embbed, even Webkit patch on it, and most important is gtk2hs have complate community, i can send patch if i found any bug or problem.
20:01:24 <Alpounet> yeah
20:01:34 <Alpounet> for now at least it sounds more reasonable
20:01:45 <ManateeLazyCat> Alpounet: Qt4 is awesome, but Gtk+ can work.
20:01:47 <Alpounet> until somebody gets David to open the development of qthaskell
20:02:30 <ManateeLazyCat> Alpounet: If qtHaskell open enough, at least have open repository, i want spend two weeks on patch that missing.
20:03:01 <ManateeLazyCat> Alpounet: But now, looks need much time than that.
20:03:12 <ivanm> fork it and cal it qterHaskell! :p
20:03:20 <ivanm> *call
20:03:24 <ManateeLazyCat> ivanm: fork is bad thing.
20:03:32 <ivanm> I was joking
20:03:34 <pickles> i prefer spoons
20:03:43 <ManateeLazyCat> ivanm: We should try to avoid this if have a good project exsit.
20:03:44 <ivanm> I just thought of the name and figured it was worth a message
20:04:03 <pickles> i thought the name clever
20:04:13 <ManateeLazyCat> Alpounet: If i switch qtHaskell, i need rewrite all my code that base on gtk2hs.
20:04:23 <Alpounet> ivanm, haha
20:04:45 <Alpounet> ManateeLazyCat, you should stick with gtk2hs
20:04:53 <Alpounet> qthaskell won't get opened in the upcoming weeks
20:05:01 <Alpounet> otherwise somebody would have been told that
20:05:16 <ivanm> thank you pickles
20:05:32 <ivanm> (I'm glad _someone_ got it)
20:05:50 <pickles> i got the quarter part, but wasn't sure if there was something else hidden
20:05:58 <ManateeLazyCat> Alpounet: Though Qt is epigamic, but qtHaskell looks won't open in short time.
20:05:59 <pickles> (atleast i think i got the quarter part)
20:06:01 * ivanm has horrible memories of coming across the "QT4 Dance" video when he was younger
20:06:06 <ivanm> pickles: no, not quarter
20:06:12 <ivanm> "Qt" is pronounced "cute"
20:06:13 * pickles dies
20:06:14 <ManateeLazyCat> Alpounet: Yep, that's i afraid.
20:06:21 <pickles> aaah
20:06:25 <pickles> gotcha
20:06:26 <kmc> i think "cutie"
20:06:29 <pickles> that's even more clever
20:06:37 <pickles> (i must be more tired than I thought)
20:06:38 <Alpounet> kmc, it's "cute" officially
20:06:51 <Alpounet> ivanm's joke ... was actually a good joke heh
20:06:51 <kmc> oh :(
20:06:55 <ivanm> :D
20:06:58 <Alpounet> and valid!
20:07:02 <SamB_XP> oh ... I pronounce it like queue tee
20:07:08 <Alpounet> SamB_XP, I did too
20:07:10 <ManateeLazyCat> Alpounet: Fork is always bad, IMO.
20:07:13 <ivanm> as did I
20:07:19 <ManateeLazyCat> Alpounet: It's waste resource.
20:07:20 <Alpounet> but then got @slap-ed by Qt developers
20:07:30 <ivanm> ManateeLazyCat: I was _joking_ about forking
20:07:33 <Alpounet> ManateeLazyCat, not *always* but most of time yeah
20:07:45 <pickles> MLC: if you're seriously considering switching, maybe make an effort to really minimize/modularize the gtk2hs portions so the code switchover is easier
20:08:03 <pickles> although you could get screwed by different API setups
20:08:06 <ivanm> however, if it does really end up dead, then your only options are to fork (if the license allows it) or to start from scratch
20:08:25 <ivanm> in many cases, forking is easier (not least because you can do incremental improvements without having to start from scratch)
20:08:37 <ManateeLazyCat> pickles: Maybe can't, i have many code base on gtk2hs, because it's a GUI program.
20:09:20 <ivanm> ManateeLazyCat: I think pickles means try to reduce how much (in terms of number of modules and LOC) depends upon gtk2hs
20:09:38 <ivanm> as in split off as much computation stuff as you can into pure toolkit-agnostic functions
20:09:41 <ManateeLazyCat> ivanm: Yep, i have do it.
20:09:49 <pickles> yeah, that's what I was getting at
20:09:51 <pickles> thanks ivanm
20:09:57 <ManateeLazyCat> ivanm: Yes, i split those libraries.
20:10:20 <ManateeLazyCat> ivanm: Infact, if i switch, i can copy my non-GUI libraries directly.
20:10:30 <ivanm> exactly
20:11:00 <ivanm> that kind of design is good even if you don't switch, because you seperate your GUI logic from your "what am I actually doing" logic
20:11:30 <ManateeLazyCat> ivanm: But base on some *detail* difference between Gtk+ and Qt, switch GUI code is not easy, even need rewrite most code for same feature.
20:11:41 <ivanm> right
20:12:01 <pickles> yeah, that's what i was trying to articulate with my caveat clause
20:12:06 <ManateeLazyCat> ivanm: Split GUI code make my framework flexibility.
20:12:14 <ivanm> so it would be nice (but probably infeasible) to have a generic "GUI" class with gtk2hs, wxhaskell and qthaskell instances
20:12:37 <pickles> hooray for modularity
20:13:02 <ManateeLazyCat> ivanm: And some weird in qtHaskell: you always need *subclass* to use some widget.
20:13:09 * ivanm figures he might as well head off home
20:13:16 <gwern> ivanm: infeasible, yeah
20:13:35 <ivanm> I'm expecting a furniture delivery sometime in the next hour or so, and I should probably clean up first...
20:13:36 <gwern> ivanm: it's hard enough to abstract over git & darcs. no way you will with gtk2hs wxhaskell qthaskell
20:14:35 <Alpounet> @faq can haskell abstract over gtk2hs, wxhaskell and qthaskell ?
20:14:52 <Alpounet> ow :(
20:15:16 <ivanm> gwern: yeah
20:15:20 <edwardk> I just updated the summer of code wiki and finished the submission to the google summer of code for haskell.org. http://hackage.haskell.org/trac/summer-of-code/wiki/People2010 now exists if anyone wants to add themselves as an interested student or mentor
20:15:22 <ManateeLazyCat> ivanm: I even build some layout for split different layout.
20:15:27 <losl> Is it okay If I copy paste one line of code to ask a question about it?
20:15:34 <ivanm> gwern: then again, IIRC there's something similar to gitit that offers 3 or 4 different DVCSs
20:15:34 <edwardk> i took the list of folks who spoke up on haskell-cafe as a starting point for the mentor list
20:15:39 <ManateeLazyCat> Alpounet: That's hard.
20:15:43 <ivanm> losl: yes
20:15:45 <ManateeLazyCat> Alpounet: But answer is yes.
20:15:53 <ivanm> (as long as that line isn't 1000 characters long or something)
20:15:56 <applicative> losl: why not
20:16:00 <ManateeLazyCat> Alpounet: But you got minimum feature of all.
20:16:05 <losl> somefunc x y z = "  "++show x++"  "++show y++"  "++show z
20:16:11 <losl> where x y and z are doubles
20:16:11 <pickles> losl: why ask? just do :)
20:16:17 <Alpounet> yeah
20:16:18 <losl> This uses a lot of memory
20:16:28 <losl> How can I make it not do that
20:16:33 <ivanm> edwardk: I don't think the uni would be too happy if I applied to do a project for SoC in between doing my PhD...
20:16:53 * ivanm thinks they need a southern SoC as well
20:16:59 <losl> Profiling says that is using 68% of my allocations
20:17:10 <ivanm> losl: because of the x, y and z values
20:17:12 <edwardk> ivanm: heh while you're in a phd program you're still a student ;)
20:17:14 <ManateeLazyCat> Alpounet: Example Yi project have three backend for graphic, but that's give a limit for it, it just can implement minimum feature for different backend.
20:17:14 <ivanm> are they really long?
20:17:19 <applicative> losl:  what do you do with this string, once you make it?
20:17:35 <ivanm> edwardk: it was the take 3 months off to do some hacking they probably wouldnt' like ;-)
20:17:44 <losl> Put it together with lots of other strings made by that function and write them to a file
20:17:44 <ivanm> (especially since I've only been doing it for about a month)
20:17:47 <ManateeLazyCat> Alpounet: And even one backend changes something, you need your high-level logic, and sometimes this is hard.
20:17:50 <edwardk> ivanm: there is that =)
20:18:04 <losl> Maybe I'm just approaching this the wrong way
20:18:09 <ManateeLazyCat> Alpounet: That's why i just use Gtk+ as my backend, no limit.
20:18:13 <edwardk> ivanm: the trick is to make it into something that you can both add to your dissertation AND will benefit the haskell community, then its all good ;)
20:18:13 <ivanm> losl: my guess is that you're doing the order wrong
20:18:22 <losl> I think you're right.
20:18:31 <ivanm> continually appending stuff to the end of a list gets expensive
20:18:41 <ivanm> edwardk: heh
20:18:59 <pickles> hm
20:18:59 <ivanm> edwardk: maybe next year... >_>
20:19:03 <edwardk> =)
20:19:05 <pickles> i just had an interesting thought
20:19:18 <pickles> (a rather meta-icq thought)
20:19:19 <ivanm> (though google probably wouldn't like it if I kept receiving my stipend through that time)
20:19:41 <pickles> instead of replying to peoples comments with <username>: for extended conversations with many participants
20:19:55 <pickles> mabye use a subject instead of a name; so <subj>:
20:20:01 <ivanm> this is IRC, not ICQ...
20:20:04 <pickles> gah
20:20:05 <pickles> sry
20:20:08 <ivanm> ;-)
20:20:16 <ManateeLazyCat> Alpounet: qtHaskell will be *awesome* project until it have *open-code-repository*, *open-mail-list*, and *clear documentation*.
20:20:28 <ivanm> pickles: *shrug* most clients let you assign extra words to highlight, so it could be feasible...
20:20:38 <ivanm> except that you'd have to keep changing them, which would get annoying
20:20:43 <pickles> yeah
20:20:48 <ivanm> ManateeLazyCat: not asking for much, are you :p
20:20:58 <ivanm> I mean, clear documentation? who writes _that_? :p
20:20:59 <pickles> just seems like it might be a lil easier to keep track of conversations
20:21:10 <ManateeLazyCat> ivanm: I mean do some transform.
20:21:18 <Alpounet> pickles, then you'd loose a part of the fun
20:21:29 * ivanm really heads off now
20:21:31 <ivanm> bye all
20:21:35 <pickles> later ivanm
20:21:42 <ManateeLazyCat> ivanm: Transform Qt documentation to haddock output.
20:21:50 <monochrom> prefixes: I agree with pickles
20:21:50 <pickles> Alpounet: true, then i'd have to use those brain cells for something else
20:22:00 <pickles> prefixes: yay!
20:22:22 <monochrom> My usual compromise is like this:
20:22:27 <pickles> prefixes: ofc then you run into the problem of whether or not someoone's username is the same as the subject
20:22:29 <monochrom> Mr. Speaker: This is not good.
20:22:32 <monochrom> or this:
20:22:37 <monochrom> monochrom: This is not good.
20:22:47 <applicative> losl: is the real business of what you're writing, figuring out the doubles, and then it is just a question of writing them to a file?
20:24:07 <ManateeLazyCat> Alpounet: I will studying Qt even i can't use qtHaskell now. And find more surprise :)
20:24:23 <Alpounet> nice
20:26:22 <losl> applicative: Yes. I think the issue I had was that because of the lazy evaluation I was making much longer strings than I thought, and the profiling mislead me a little
20:26:29 <losl> I think I 've figured it out now.
20:37:37 <sm> http://hub.hledger.org : Paste problem transactions or journal snippets here to see what hledger thinks of them
20:38:55 <pickles> alrighty all, i'm going to head out
20:38:58 <pickles> nite
20:41:00 <handonson> can i have a list of different types that are instances of a same class?
20:41:14 <copumpkin> if lambdabot were around, you could
20:41:21 <monochrom> :info Enum
20:41:25 <Veinor> :(
20:41:31 <monochrom> That will give you instances of Enum.
20:41:41 <copumpkin> only in your loaded modules though
20:42:00 <Axman6> @instances Enum
20:42:03 <handonson> would someone speak in English? ...
20:42:21 <copumpkin> there is a bot in here who responds to queries normally
20:42:28 <monochrom> Oh I'm speaking Chinese, yeah right.
20:42:31 <Axman6> where is lambdabot :(
20:42:33 <copumpkin> you can ask it for a list of types that are instances of a class
20:42:40 <copumpkin> but it's gone, so no answers right now
20:43:14 <handonson> what does lambdabot have to do with using list of different types in my code?
20:43:15 <Berengal> handonson: :info Class in ghci
20:43:35 <Axman6> handonson: you won't be able to get it in your code
20:44:12 <handonson> oh, so it was a problem with the ambiguity of 'list' ...
20:44:17 <Berengal> Oh, you want a list with values of different types?
20:44:19 * hackagebot ghc-mod 0.2.0 - Happy Haskell programming on Emacs  http://hackage.haskell.org/package/ghc-mod-0.2.0 (KazuYamamoto)
20:44:50 <handonson> yes, like (Class c) => [c]
20:45:04 <kmc> you need an existential type for that
20:45:07 <Berengal> Yeah, you're going to need existentials for that
20:45:08 <copumpkin> [exists c. Class c => c]
20:45:09 <kmc> otherwise you are limited to one particular c
20:45:23 <copumpkin> or you can have [forall c. Class c => c] but that's going away soon
20:45:28 <Axman6> oh, that's what you meant. the question wasn't clear then
20:45:35 <handonson> what is existential?
20:45:36 <kmc> copumpkin, that's different isn't it?
20:45:40 <losl> are maps any faster than comprehensions or is a purely a readiblity feature?
20:45:43 <Axman6> handonson: exists
20:45:46 <kmc> data AnyC = forall c. (Class c) => ThisC c
20:45:50 <kmc> then use [AnyC]
20:45:52 <copumpkin> kmc: the first one is what he wants, the second one is a list of polymorphic values
20:46:11 <kmc> and wrap/unwrap values with the value constructor ThisC
20:46:19 <Axman6> losl: it's a lot harder to compose list comprehensions
20:46:22 <kmc> for more information, look up the page on the Haskell wiki or the GHC manual
20:47:02 <kmc> losl, «[ f x | x <- y ]» will be desugared into something like «map f y»
20:47:07 <kmc> should be the same speed in other words
20:47:25 <kmc> i think list comprehensions are often less readable
20:47:34 <copumpkin> and often more :)
20:47:45 <kmc> but that's largely a matter of how well you know the points-free list functions
20:47:54 <losl> okay cool
20:48:05 <kmc> certainly for a simple map, there's no need to invent a local name "x"
20:49:54 <danblick> When using the FFI, what is the proper way to reference C language compile-time constants like "sizeof (struct sockaddr_in)" or "AF_INET" (a #define)?  (I am reluctant to use unsafe functions, but I guess this could be the right time to do it...)
20:51:01 <kmc> hsc2hs will do the latter won't it?
20:53:38 <danblick> kmc looks like it will do the first, too; thanks
20:53:55 <kmc> the RWH chapter on FFI is a great resource
20:53:58 <losl> :D
20:54:10 <losl> You guys are rock stars, I want you to know that.
20:54:36 <Axman6> we know
20:54:39 <kmc> as long as i don't die by choking on my own vomit
20:54:48 <kmc> (or someone else's)
20:54:59 <Axman6> om nom nom
20:55:41 <monochrom> some are porn stars too
21:00:18 <danblick> kmc: thanks, i did not appreciate the difference between c2hs and hsc2hs -- hsc2hs will do everything i wanted.
21:00:42 <sm> woo! ghc-mod rocks
21:00:59 <Axman6> ghc-mod?
21:04:31 <regalia> > liftM2 [1,2] [3,4]
21:06:09 <regalia> liftM2 (*) [1,2] [3,4]
21:06:13 <regalia> > liftM2 (*) [1,2] [3,4]
21:06:32 <regalia> :t liftM2
21:07:25 <Makoryu> No lambdabot
21:09:22 <bos> @src $!
21:09:27 <bos> @src ($!)
21:09:46 <bos> preflex: src ($!)
21:09:49 <bos> bah
21:13:13 <jmcarthur> yay instances!
21:13:28 <jmcarthur> type classes are awesome
21:13:43 <kmc> i will play devil's advocate
21:13:45 <kmc> type classes suck
21:14:03 <Mathnerd314> no, types suck
21:14:07 * jmcarthur refuses to play kmc's game
21:14:25 <Mathnerd314> throw away the types and just use type classes ;-)
21:14:35 <kmc> i read a cool paper recently unifying types and type classes
21:14:37 <kmc> it was on LtU
21:14:48 <kmc> i have some serious (though hardly novel) objections to type classes
21:14:49 <Mathnerd314> that works too
21:15:38 <losl> can you perform operations on seperate files in parallel with haskell? I'm getting some compliation error trying to make it work
21:15:48 <kmc> losl, yep
21:15:55 <kmc> you want actual parallel threads?
21:16:28 <handonson> is the 'existential' extension considered common?
21:16:33 <losl> I am using par?
21:17:31 <kmc> handonson, yes
21:17:31 <handonson> i mean, is it like a workaround that there is a better, elegant and orthodox solution, or is it like something Haskell98 should have included but couldn't?
21:17:40 <kmc> it is a common extension
21:17:49 <kmc> it is used for example by the extensible exceptions library
21:18:08 <kmc> the thing to consider as a better solution
21:18:20 <kmc> is just a single type which has your different "types" as variants
21:18:24 <kmc> i.e. if you want to store Ints and Strings
21:18:31 <kmc> data Elem = ElemInt Int | ElemStr String
21:18:33 <kmc> [Elem]
21:18:47 <jmcarthur> handonson: it's a common extension. sometimes it's used in ways i would consider not so great, but that doesn't mean be afraid of it. its requirement for a module typically doesn't raise any of my alarms
21:19:03 <kmc> a key difference between that and an existential over a typeclass is that the latter is "open"; users can declare new typeclass instances and they can be used in the list
21:19:13 <kmc> whereas each data type is declared completely in one place
21:19:23 <losl> I think I'm running into a configuration issue, I'm getting message like: haskell-grav.o: In function `s1Mv_info':
21:19:23 <losl> (.text+0x16732): undefined reference to `__stginit_parallelzm2zi2zi0zi1_ControlziParallel_p'
21:19:23 <losl> haskell-grav.o: In function `s1Mv_info':
21:19:23 <losl> (.text+0x16732): undefined reference to `__stginit_parallelzm2zi2zi0zi1_ControlziParallel_p'
21:19:23 <losl> (.text+0x16732): undefined reference to `__stginit_parallelzm2zi2zi0zi1_ControlziParallel_p'
21:19:25 <losl> (.text+0x16732): undefined reference to `__stginit_parallelzm2zi2zi0zi1_ControlziParallel_p'
21:19:26 <kmc> eek
21:19:29 <losl> if I'm getting messages like (.text+0x16732): undefined reference to `__stginit_parallelzm2zi2zi0zi1_ControlziParallel_p trying to use the parallel control module, do I have a configuration issue?
21:19:29 <kmc> please use a pastebin
21:19:32 <losl> Woah
21:19:32 <kmc> @where paste
21:19:34 <losl> Sorry!
21:19:46 <losl> That was only supposed to be one line
21:19:48 <kmc> losl, you should probably compile with ghc --make
21:19:54 <losl> ty
21:19:58 <kmc> ghc --make Foo.hs
21:20:08 <kmc> it will chase dependencies (your other .hs files plus libraries)
21:21:41 <handonson> kmc, i guess the use of existential extension will be internally converted to something similar to the [Elem] example when compiled?
21:22:04 <kmc> not really
21:22:16 <kmc> do you understand how GHC implements typeclasses in terms of passing "dictionaries"?
21:22:30 <handonson> what are dictionaries?
21:22:52 <handonson> i mean, i know dictionaries as data structures, but ...
21:22:54 <kmc> data EqDict a = EqDict { eq :: a -> a -> Bool }
21:23:00 <aavogt> as in a typeclass is an implicitly passed record
21:23:06 <kmc> an instance of Eq for type A is like a value of type «EqDict A»
21:23:08 <kmc> do you see how?
21:24:11 <handonson> an instance is like a value? i cannot understand at all.
21:24:14 <kmc> yes
21:24:56 <kmc> say you have a function of type «(Eq a) => a -> Char»
21:25:13 <kmc> we translate this to take an explicit dictionary:  «EqDict a -> a -> Char»
21:25:21 <kmc> note that the typeclass constraint has become an ordinary argument
21:25:55 <kmc> and wherever we used the (==) operator on type «a», we instead use the «eq» field of the explicit dictionary arg
21:25:55 * hackagebot vector-static 0.2.0 - Statically checked sizes on Data.Vector  http://hackage.haskell.org/package/vector-static-0.2.0 (JakeMcArthur)
21:26:28 <kmc> think about Data.List.group versus Data.List.groupBy
21:26:41 <kmc> one of them gets its comparison from the Eq typeclass, one of them gets it by an explicit argument
21:27:32 <handonson> yes?
21:27:35 <kmc> what i'm explaining is that *every* function that uses typeclasses can be converted to a form that gets an explicit record containing the stuff defined in the instance
21:27:42 <kmc> we call such a record a "dictionary" for the typeclass
21:28:25 <handonson> so those dictionaries are the real ones who instantiate a class?
21:28:37 <kmc> i'm describing a technique for implementing typeclasses
21:28:43 <kmc> it is not required by the language spec that they be implemented this way
21:28:49 <kmc> it is basically how GHC does it
21:29:06 <aavogt> maybe it's just better to explain that you can write existentials with typeclass constraints as existentials that also contain functions:
21:29:43 <aavogt>  data Showable = forall a. Show a => Showable a     is just like:     data Showable = forall a. Showable (a -> String) a
21:30:25 <aavogt> so the the second case, you can do:    \(Showable show' x) -> show' x
21:30:31 <kmc> the latter is an existential but does not use typeclasses
21:30:33 <jmcarthur> of course in that case you might as well just have newtype Showable = Showable String
21:30:45 <aavogt> but in the first case:    \(Showable x) -> show x
21:30:45 <copumpkin> jmcarthur: is vector-static actually proving to be useful for your application?
21:30:48 <jmcarthur> since that's all you can do with the a anyway
21:30:58 <jmcarthur> copumpkin: not yet. i haven't yet applied it directly
21:31:00 <aavogt> jmcarthur: it might have space implications?
21:31:01 <copumpkin> ah ok
21:31:23 <kmc> the point is that, in GHC's implementation of a typeclass-constrained existential, the in-memory object representing the existential wrapper contains pointers not only to the value being wrapped but to the implementation of each typeclass method for its specific type
21:31:27 <jmcarthur> aavogt: only once evaluated
21:31:42 <kmc> that's so that, later, you can pattern match on the constructor and use the typeclass methods, without knowing which concrete type was inside
21:31:45 <jmcarthur> but ya i guess there could be a practical different there
21:31:52 <jmcarthur> *difference
21:32:37 <aavogt> as in once you force your   newtype Showable = Showable String, it stays that way
21:32:39 <jmcarthur> copumpkin: it's almost certainly going to be practical for my use though
21:32:48 <copumpkin> I'm glad :)
21:32:54 <handonson> kmc, what i thought was simply that both [Elem] and [AnyC] in that you used for examples will be compiled to some lists of pointers
21:32:56 <jmcarthur> copumpkin: i'm not going to be doing anything that is really complicated by the nat complexities
21:33:02 <copumpkin> yeah
21:33:02 <kmc> handonson, that is correct
21:33:27 <kmc> handonson, nearly every value in GHC-Haskell is represented by a vector of pointers
21:33:46 <handonson> yes, right, that should be ...
21:33:48 <kmc> but the structure and interpretation of these pointers will be very different for Elem vs AnyC
21:34:16 <aavogt> jmcarthur: or can you think of a way to force a value like your newtype, let the result get garbage collected to save space though you may need to show again?
21:34:38 <kmc> each element of [Elem] knows directly what constructor was used to build it
21:34:46 <kmc> you can pattern match them and so forth
21:35:25 <kmc> when an Elem appears as the pattern match scrutinee it will simply jump to the Elem's entry code, which will perform lazily-deferred computation if necessary, then return a "tag" indicating which constructor it's made of
21:35:39 <jmcarthur> aavogt: no, i don't think that is possible
21:35:53 <kmc> whereas an AnyC cannot directly answer the question "what constructor were you made with"
21:36:10 <jmcarthur> aavogt: if the string takes up significantly more space than the value itself then it's probably worth it to go with the forall a . (a -> String) a version
21:36:10 <copumpkin> aavogt: several people have wanted something like that but it's going to need some hackery
21:36:20 <kmc> because the set of possible answers to the question is open
21:36:22 <copumpkin> aavogt: and some actual thinking, too
21:36:35 <jmcarthur> aavogt: but if you know that in advance then you probably can make it monomorphic anyway
21:36:45 <kmc> some code can use AnyC without being aware of a module (compiled later) that adds additional instances of C
21:37:10 <handonson> kmc, then, aside from the usability issue (that in case of [AnyC] users may add their own types to be included in the list), which one is the better way? in terms of time/memory consumption, etc...
21:37:35 <kmc> the simple algebraic type should be preferred unless you need users to add their own types
21:37:47 <kmc> for reasons of simplicity more than performance, but i think it also wins there
21:38:18 <kmc> the usual advice is "don't optimize prematurely", but this *is* a decision affecting the structure of lots of code, so i do think it's reasonable that you think about it now
21:38:39 <jmcarthur> copumpkin: Vec now has Foldable, Bounded, Eq, Ord, Show, Num, Floating, Monoid, and Fractional instances :D
21:38:47 <copumpkin> Fractional!
21:38:50 <copumpkin> Num!?
21:38:52 <copumpkin> Floating?!!?!
21:38:54 <copumpkin> :P
21:38:54 <jmcarthur> in addition to the Functor, Applicative, and Monad instances
21:39:00 <jmcarthur> what?
21:39:03 <copumpkin> only the boxed vector though
21:39:06 <copumpkin> right?
21:39:09 <Axman6> is Vec from the vector library?
21:39:12 <jmcarthur> Unboxed has a subset of that
21:39:29 <Axman6> right?*
21:39:30 <copumpkin> how do you make Vec a Num instance? What do you do for (*)?
21:39:36 <copumpkin> Axman6: vector-static
21:39:48 <jmcarthur> copumpkin: for the boxed one, liftA2 (*)
21:39:59 <copumpkin> ah
21:40:06 <jmcarthur> copumpkin: for the unboxed one i had to just do zipWith (*)
21:40:10 <copumpkin> I guess that's the best you can do unless you have a Vec 3 or Vec 7 :P
21:40:28 <jmcarthur> wait, what?
21:40:38 <copumpkin> (cross product would be nice for those ones)
21:41:06 <copumpkin> there are a few other options for (*) :P http://en.wikipedia.org/wiki/Algebra_over_a_field
21:41:11 <jmcarthur> copumpkin: well, i don't want to add the dependency, but i have instances for vector-space classes that do that
21:41:20 <copumpkin> yeah
21:42:50 <jmcarthur> but yeah, i think the only issue i had with unboxed was Foldable since it has the wrong kind to include the Unbox constraint
21:43:03 <jmcarthur> the other instances work fine though
21:44:04 <jmcarthur> sure there are other possibilities for (*), but they have to work with the rest of the Num instance to be predictable
21:44:12 <copumpkin> yeah :)
21:44:13 <kmc> Num is sad :(
21:44:15 <copumpkin> just being silly really
21:44:17 <copumpkin> yeah, Num is really sad
21:44:30 <jmcarthur> Num happens to work without issue in this particular case
21:44:48 <jmcarthur> i even have the Eq and Show which i often have issues with for other types
21:44:56 <copumpkin> cool
21:45:35 <jmcarthur> but yeah, now you can say things like:   myVector * 5   :)
21:45:40 <copumpkin> lol
21:45:54 <copumpkin> 5 gets made into a Vec of the same size full of 5s?
21:45:58 <jmcarthur> yup
21:46:02 <copumpkin> :P
21:47:04 <jmcarthur> i thought at first i'd have to choose semantics for Monoid until i remembered i have to have the same length for the result
21:47:30 <elly> Elegant systems have the property that the number of arbitrary choices is zero.
21:47:44 <copumpkin> :P
21:47:54 <jmcarthur> elly: i wouldn't say that's always the case
21:48:07 <jmcarthur> elly: would you say that linked lists are inelegant?
21:48:17 <elly> Is there an arbitrary choice in linked lists? oO
21:48:23 <jmcarthur> because we have a few choices to make about them
21:48:30 <jmcarthur> yeah, like what semantics to use for Applicative
21:49:52 <aavogt> well with newtypes you don't have to exclude anything
21:50:20 <jmcarthur> yeah, but i like to think of newtypes as different entities
21:50:26 <jmcarthur> they expose different semantics after all
21:50:33 <jmcarthur> at least in some respect
21:50:33 <monochrom> Clearly, elegant systems like the definition of natural numbers have the property that the number of arbitrary choices is infinite.
21:51:26 <monochrom> In fact if you understand that math (or every theory) is invented not discovered, it is all about arbitrary choices.
21:51:42 <kmc> what if you're a Platonist ;P
21:51:47 <jmcarthur> really i think the inelegance is our inability to define and use multiple instances of the same type class for the same type unambiguously
21:53:16 <Cale> Aside from the more fundamental arbitrary choices, the order of the parameters to cons is pretty arbitrary.
21:53:38 <kmc> yeah, that's one of my complaints with typeclasses
21:53:43 <monochrom> Platonists can spend their own life wondering but not proving or disproving whether or not 0 is a natural number on the Platonic astral plane.
21:53:45 <Vulpyne> Given an unboxed array of Word8, is there any efficient way to convert it to a ByteString?
21:53:51 <monochrom> s/own life/whole life/
21:54:12 <Vulpyne> It would seem that the in memory representation should the same for the data mostly.
21:54:14 <crash[`]> Hey folks - I'm looking for documentation on using SDL with Haskell - i can't find much more than a single tutorial on how to pop a window
21:54:43 <aavogt> crash[`]: have you looked for other code that uses SDL?
21:54:44 <crash[`]> Can't find any real documentation on methods, etc
21:54:55 <Axman6> there's a fair chance the haskell bindings are quite close to the SDL interface, so following a generic SDL tutorial might be useful
21:55:00 <kmc> Vulpyne, i seem to remember some fromForeignPtr
21:55:09 <Axman6> there should be haddock docs somewhere
21:55:11 <jmcarthur> the haskell bindings are very very similar to the C interface
21:55:18 <jmcarthur> ?hackage sdl
21:55:20 <kmc> fromForeignPtr :: ForeignPtr Word8 -> Int -> Int -> ByteString --- Vulpyne
21:55:21 <crash[`]> Axman6: that's how I've done it so far, but it's slow-going getting names/parameters right
21:55:26 <kmc> from Data.ByteString.Internal
21:55:29 <jmcarthur> aw no lambdabot
21:55:51 <Vulpyne> kmc: Hmm. How to get the ForeignPtr from an array though?
21:56:25 <kmc> Vulpyne, you can do it with StorableArray
21:56:32 <kmc> using withStorableArray
21:56:55 <kmc> i think it's not actually guaranteed than a regular UArray is packed contiguous in memory
21:56:59 <kmc> whereas StorableArray is
21:58:03 <Vulpyne> Hmm.
21:58:42 <Vulpyne> I don't really have an easy way to choose what sort of array is used. :/ I'm pulling packets in with pcap and using the House network stuff to decode them.
21:59:07 <Vulpyne> And it uses a Unboxed Word8 array.
21:59:15 <crash[`]> What's a better alternative to SDL that has good documentation?
21:59:41 <kmc> crash[`], what are you trying to do with SDL?
21:59:58 <kmc> for graphics, i'd use OpenGL
21:59:58 <crash[`]> 2d graphics, simple stuff, might play with simple games
22:00:03 <kmc> indeed it's pretty painful to draw anything with SDL
22:00:27 <kmc> i tend to use SDL to get input and a GL drawing context
22:00:28 <crash[`]> openGL even for 2d?
22:00:32 <kmc> and OpenGL to do the actual drawing
22:00:34 <kmc> crash[`], yes
22:00:38 <kmc> acceleration matters a lot for 2D too
22:00:48 <crash[`]> kmc: have any favorite documentation/references for the haskell bindings?
22:00:51 <kmc> and even if you lack acceleration it's a decent graphics API
22:00:55 <kmc> no
22:00:59 <kmc> i just used the haddock docs
22:01:02 <jmcarthur> crash[`]: try graphics-drawingcombinators for 2d
22:01:03 <crash[`]> alright, just wondering :)
22:01:13 <kmc> there's also cairo
22:01:27 <kmc> OpenGL is a vector graphics API though
22:01:34 <kmc> if you want pixel-perfect sprites it's doable but not an ideal fit
22:01:35 <Axman6> crash[`]: what sort of things do you want to draw?
22:01:52 <crash[`]> Axman6: nothing fancy, was just going to do some stupid basic things like tic tac toe
22:02:10 <jmcarthur> yeah i definitely recommend graphics-drawingcombinators
22:02:14 <Axman6> check out the Gloss library, it'll be ideally suited, very easy to use too
22:02:20 <crash[`]> I'll look into those three then
22:02:33 <crash[`]> (vanilla opengl, gloss, and graphics-drawingcombinators)
22:02:54 <Axman6> Gloss is dead simple (meaning it's not very feature rich, but you can very easily draw pretty things)
22:03:18 * jmcarthur thinks graphics-drawingcombinators is much simpler
22:03:31 * Axman6 hasn't checked it out
22:03:39 <kmc> gloss looks really cool
22:03:43 <kmc> thanks for the suggestion
22:04:06 <crash[`]> jmcarthur: cabal install graphics-drawingcombinators?
22:04:11 <jmcarthur> crash[`]: yup
22:04:28 <jmcarthur> and docs here: http://hackage.haskell.org/package/graphics-drawingcombinators
22:05:05 <scutigera> is everything on hackage experimental ?
22:05:06 <jmcarthur> be aware when reading the documentation that much of the functionality is in type class instances
22:05:19 <jmcarthur> scutigera: yes, and honest, too ;)
22:05:31 <jmcarthur> most code is experimental
22:05:49 <Axman6> kmc: we've used it in a few assignments here at ANU (It was originally called ANUPlot), and it was used to make pretty pictures for first year comp and engineering students learning to program with haskell
22:07:00 <crash[`]> Axman6: you got any specific favorite references or sample code?
22:07:32 <Axman6> sec
22:08:01 <Axman6> start here: http://trac.haskell.org/gloss/
22:08:31 <Axman6> http://code.haskell.org/gloss/gloss-stable/examples/Clock/Main.hs is fun
22:08:33 <handonson> i hate GLUT
22:09:24 <psykotic> GLUT is nice for quick and dirty apps
22:09:24 <Axman6> why?
22:09:31 <handonson> i can't even terminate the process when the window is closed (only avoidable with freeglut)
22:09:43 <handonson> that's like you have no :q in ghci
22:10:08 <handonson> this is primarily because GLUT is such an old tool
22:10:11 <crash[`]> Axman6: thanks for this - these are some pretty damn cool resources
22:10:16 <kmc> GLUT is pretty nasty
22:10:27 <handonson> this is why i prefer OpenGL + SDL instead of GLUT
22:10:28 <kmc> that's why i started using SDL
22:10:31 <kmc> yes exactly
22:15:29 <handonson> i think a cool library like gloss should be rewritten using SDL
22:16:08 <aavogt> what would it do that the current gloss library doesn't?
22:16:59 <handonson> does it close correctly?
22:17:26 <scutigera> :t <
22:17:36 <scutigera> :t (<)
22:18:07 <scutigera> alas poor lambdabot, I knew it not that well
22:18:33 <regalia> > takeWhile (even) [1..10]
22:18:44 <aavogt> handonson: in my limited experiments, I didn't notice any trouble closing it
22:19:57 <Axman6> regalia: lambdabot isn't here at the moment
22:20:12 <scutigera> how do I write signed x where signed -1 = "-1" signed (-1 :+ 3) = "-1 + i3" signed (1 :+ 3) = "1 + i3. the problem is I need to know if it's real or complex ... ??
22:20:21 <Draconx|Laptop> aavogt, he was referring to problems with the ancient GLUT library that hasn't been maintained in many years, rather than any real problem with existing implementations.
22:20:54 <Axman6> scutigera: so... signed (x :+ 0) = show x?
22:21:36 <scutigera> Axman6: well I'm trying to be particular about when the sign is displayed, oops I should have said "+1", show doesn't display sign
22:21:48 <handonson> Draconx|Laptop, there are existing implementations without proper support for basic stuff that SDL has been doing since always
22:22:06 <Axman6> scutigera: well, that's not hard to fix
22:22:26 <Draconx|Laptop> handonson, well, SDL doesn't support basic stuff either, like resizing openGL windows.
22:22:29 <scutigera> I think I need Complex a -> String, and another function to handle all other numbers than are not complex ?
22:23:16 <Axman6> scutigera: signed (x :+ 0) = (if x < 0 then '-' else '+') : show x
22:23:33 <Axman6> eh?
22:23:34 <scutigera> one proc and just pattern match ?
22:23:49 <Axman6> yes, but it'll only wokr on Complex numbers
22:23:51 <Axman6> work*
22:24:32 <handonson> resizing or creating multiple windows has been SDL's drawbacks, but those are not seriously necessary and can be worked around
22:24:59 <Draconx|Laptop> handonson, oh?  How can you work around the problem -- other than simply using freeglut?
22:26:00 <ml> j
22:26:07 <Draconx|Laptop> resizing is a pretty fundamental operation of windowing systems, imo.
22:26:10 <ml> /?
22:26:21 <handonson> why is resizing important when you are not making a GUI program? if you're making an app that makes heavy use of UI, you should use neither SDL nor GLUT
22:27:03 <superoptimizer> Hi. New to Haskell.
22:27:10 <Draconx|Laptop> handonson, so that the window can be placed in the correct location on the screen, at the correct size?
22:27:33 <handonson> in a context where resizing truly matters, you'd better use wx/gtk/qt/etc, since resizing being important means you have something to do with window system
22:27:37 <Draconx|Laptop> handonson, consider what happens when you, say, open a terminal window in a tiling window manager.
22:27:40 <Axman6> superoptimizer: um... hi?
22:28:09 <Draconx|Laptop> handonson, wx/gtk/qt/etc is kind of overkill for a single window which consists entirely of an opengl viewport.
22:28:19 <psykotic> handonson: yes, agreed!
22:28:23 <psykotic> btw i hate the way glut handles resizing
22:28:24 <Draconx|Laptop> (although gtk does work for this purpose)
22:28:33 <Draconx|Laptop> psykotic, at least it works.
22:28:45 <handonson> GLUT doesn't even guarantee what it would do when asked to move/resize the window
22:28:48 <psykotic> in fact, most of the time when i'm doing simple apps where glut might be apropos, i don't want the user to be able to resize anything
22:29:12 <handonson> exactly.
22:29:19 <Draconx|Laptop> psykotic, why not?
22:29:24 <psykotic> resizing isn't trivial
22:29:39 <psykotic> it shouldn't be a required feature
22:29:44 <Draconx|Laptop> it's pretty trivial a lot of the time.
22:29:53 <psykotic> well, i'm talking about doing a quick example demo
22:29:59 <psykotic> that's where glut is useful
22:30:02 <Draconx|Laptop> a lot of opengl apps simply require the viewport and projection matrix to be adjusted.
22:30:11 <Draconx|Laptop> and poof, resizing!
22:30:16 <scutigera> Axman6: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23918#a23918
22:30:33 <psykotic> yeah, at least it isn't like dx where you have to recreate the device from scratch and thus all your resources :)
22:31:05 <Axman6> scutigera: x :+ y is a constructor for Complex numbers only
22:31:34 <copumpkin> :k Complex (Complex Double)
22:31:52 <Axman6> so, the that's pretty complex
22:32:00 <scutigera> Axman6: yes it is. but a is Num
22:32:07 <copumpkin> http://en.wikipedia.org/wiki/Quaternion#Quaternions_as_pairs_of_complex_numbers
22:32:11 <copumpkin> I wonder if that would just work
22:32:12 <Axman6> so, that code won't work
22:32:34 <scutigera> do I need two versions of show ?
22:32:41 <scutigera> instances
22:34:08 <Axman6> superoptimizer: did you have a question?
22:34:56 <superoptimizer> No, just browsing to learn as I try things out in ghci and read Real World Haskell.
22:40:00 <jmcarthur> copumpkin: i think it would require knowledge about how to multiply i and j
22:40:13 <jmcarthur> but would otherwise work fine
22:40:21 <copumpkin> well, what would the default behavior do?
22:40:37 <jmcarthur> i think just leave it "unnormalized"
22:40:40 <jmcarthur> which might be okay
22:41:02 <copumpkin> ah well, I'll play with it later
22:41:04 <copumpkin> time for real work now :P
22:41:12 <jmcarthur> yeah right
22:41:15 <copumpkin> :(
22:41:17 <copumpkin> unfortunately
22:41:24 <jmcarthur> it's late
22:41:27 <copumpkin> yeah :(
22:41:32 <jmcarthur> :(
22:41:34 <copumpkin> I'm a pathological procrastinator
22:41:43 <jmcarthur> i understand
22:41:48 <jmcarthur> i am as well
22:41:52 <jmcarthur> and it sucks
22:42:08 <jmcarthur> wow, i managed three lines in a row with the same character count
22:42:16 <kmc> superoptimizer, welcome :)
22:42:22 <copumpkin> :)
22:42:37 * copumpkin goes poof
22:43:15 <superoptimizer> Thanks. I'm a compiler developer and have been interested in learning Haskell for a while, and after I saw that there was work to make ghc use LLVM I thought it was about time.
22:43:40 <jmcarthur> superoptimizer: superoptimize it!
22:43:50 <kmc> superoptimizer, are you interested in the details of how Haskell can be compiled efficiently?
22:44:00 <jmcarthur> @where stg
22:44:10 <jmcarthur> dang, forgot there's not lambdabot
22:44:14 <kmc> it's not particularly related to learning how to use haskell
22:44:19 <kmc> but the paper to read is http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729
22:44:28 <aavogt> supercompilers?
22:44:38 <superoptimizer> kmc: yes, I am.
22:44:39 <jmcarthur> yeah that's what i was trying to link to
22:45:13 <jmcarthur> rewrite rules are also just plain awesome
22:45:48 <superoptimizer> Interesting. I'll check it out. I've been working primarily on compiler backends for the last 17 years. Most of that time on C/C++, more recently on shading languages and data parallel compute languages (think OpenCL, Compute Shader, CUDA)
22:46:35 <jmcarthur> superoptimizer: i'm working on a shader dsl!
22:46:43 <jmcarthur> or at least i'm in the early stages of it
22:47:13 <jmcarthur> superoptimizer: you might be interested in DPH and the accelerate library
22:47:19 <superoptimizer> Excellent. I'm very interested in DSLs and EDSLs as well.
22:47:36 <jmcarthur> i don't know what the progress is on accelerate though
22:48:08 <jmcarthur> http://www.cse.unsw.edu.au/~chak/project/accelerate/
22:48:13 <superoptimizer> Yes, I'm interested in DPH. By accellerate do you mean Accellerator from Microsoft Research?
22:48:42 <jmcarthur> i mean what i just linked to ;)
22:49:40 <superoptimizer> I see. :)
22:49:58 <Axman6> superoptimizer: if you could learn enough haskell to help with the development with GHC, many many people would be very happy (not least the simons) :)
22:50:42 <jmcarthur> superoptimizer: you might also enjoy reading about stream fusion if you don't know of it already
22:50:58 <kmc> http://gernot-heiser.org/~dons/papers/CLS07.html
22:51:11 <Axman6> haskell is a fascinating language, and offers many opportunities for optimisations you can't use in other languages
22:51:14 <jmcarthur> which is one of the major tricks we do to fuse loops (which is important since we encourage using combinators over explicit recursion)
22:52:11 <Axman6> {-# RULES forall x. map f ( map g xs) = map (f . g) xs #-} ftw
22:52:20 <jmcarthur> deforestation rocks
22:52:46 <superoptimizer> Will check out the stream fusion stuff as well.
22:54:07 <jmcarthur> @check \f g xs -> map f (map g xs) == map (f . g) (xs :: [Int])
22:54:20 <jmcarthur> dangit again
22:54:28 * jmcarthur misses lambdabot
22:54:32 <superoptimizer> BTW, Have no idea how to reply with your name pasted in color like that. I'm using erc-select in emacs. I haven't used irc on a regular basis for 15+ years, so I'm a bit rusty.
22:54:40 <aavogt> that's a free theorem, no?
22:55:09 <jmcarthur> superoptimizer: just start a line with somebody's nick and their client will usually do something special to show that you are addressing them
22:56:33 <superoptimizer> jmcarthur: I see. Thanks. I need to head out - flight to catch in the morning. Thanks for the links, all.
22:56:37 <Axman6> superoptimizer: if you type "ax<tab>", your life will become easier :)
22:56:43 <jmcarthur> anyway it's bed time
22:56:46 <superoptimizer> Axman6: oh, nice
22:56:53 <Axman6> :)
22:56:58 <superoptimizer> autocompleted names.
22:57:12 <Axman6> yep
23:05:48 <pookleblinky> I haven't used Hircules yet.
23:06:37 <pookleblinky> It seems like it died, though.
23:07:03 <pookleblinky> News: 2003-10-05 Hircules 0.3 released
23:20:19 <regalia> What function would be best used to find the first element in a list that satifies a predicate?
23:20:59 <Vitka> head $ takeWhile (predicate) ?
23:21:05 <Vitka> err wait
23:21:09 <Vitka> No.
23:21:11 <regalia> ahhh
23:21:19 <regalia> head $ filter predicate
23:21:36 <Vitka> Filter transverses entire list I think.
23:21:45 <regalia> hmmm
23:21:50 <Vitka> More effective to stop at first occurence.
23:21:57 <regalia> Yes yes
23:22:05 <Vitka> head $ dropWhile (not predicate) I think.
23:22:11 <regalia> ahhh
23:22:16 <regalia> Awesome! thanks :)
23:22:38 <Vitka> omfg did I actually gave correct advice to someone?
23:23:17 <regalia> Let's see :)
23:23:20 <Cale> Actually, that was not quite the right advice to give, though dropWhile does work
23:23:32 <regalia> What's best?
23:23:36 <Cale> head . filter p will only process the part of the list that it needs to
23:23:42 <kmc> yay laziness
23:23:56 <regalia> Ahhh
23:24:05 <Cale> > head . filter even $ [1..]
23:24:15 <handonson> 2
23:24:18 <kmc> "head" will give an exception if there is no satisfying element
23:24:19 <handonson> ...sorry
23:24:23 <Cale> oh, is lambdabot not here?
23:24:31 <kmc> i'd use listToMaybe
23:24:39 <mm_freak_> how do i create a hackage account?  my email to ross@soi.city.ac.uk returned with a delivery failure
23:24:43 <kmc> that way you get the information about "was a value found" nicely
23:24:51 <Vitka> Whew, I actually thought universe is about to end.
23:24:52 <Cale> Sometimes you know for sure that there is an element, in which case it's okay to use head
23:25:21 <Cale> odd... it thinks that it is still connected to the network
23:25:36 <handonson> Vitka, the day seems to be close, however.
23:25:49 <Cale> > head . filter even $ [1..]
23:25:50 <kmc> hi lambdabot :)
23:25:50 <kmc> @bot
23:25:56 <lambdabot>   2
23:25:58 <lambdabot> :)
23:26:03 <Cale> okay
23:26:21 <Vitka> lambdabot: Thoughtful today, mmm?
23:27:12 <Cale> regalia: So, that works even on an infinite list, because the first function to evaluate there is 'head', and it pattern matches (x:xs) against  filter even [1..]  which forces filter to evaluate, which forces [1..] to evaluate...
23:27:59 <Cale> and eventually the filter even [1..] reduces to 2 : filter even [3..], at which point the pattern matches, and the rest of the filtering never gets done
23:28:22 <regalia> That isn't the case with dropWhile?
23:28:31 <Cale> That's also the case with dropWhile
23:28:32 <regalia> > head . dropWhile even $ [1..]
23:28:40 <lambdabot>   1
23:28:44 <Cale> > head . dropWhile (not . even) $ [1..]
23:28:48 <lambdabot>   2
23:28:49 <regalia> Yes :)
23:28:56 <Vitka> handonson: Not until I actually learn to use monads properly, because it is necessary to actully do something practical. Or so I think.
23:29:00 <Cale> So there's no real difference.
23:29:09 <regalia> Alrighty, Awesome
23:29:12 <regalia> Thanks guys :)
23:29:12 <Vitka> *cough*Parsec*cough*
23:29:12 <ksf> Prematurity is the root of all evil, and termination of program design is undecidable.
23:30:01 * ksf suddenly has the urge to shout "COOOOOONAL" to make conal hear it
23:30:06 <Cale> Be cautious about using the function 'head' though. Often it's a better idea to pattern match using case or use another function (like listToMaybe) to handle the case where the list is empty.
23:30:27 <Cale> Using head or tail is like saying 'I know that this list will really never be empty'
23:30:29 <ksf> ...but he might be actually right in being busy designing stuff.
23:31:03 <handonson> Vitka, i guess the conclusion above is that your advice was valid
23:31:19 <ksf> I think head and tail belong in Prelude.Unsafe
23:31:21 <Makoryu> So, apparently Erlang allows you to send entire closures over the network
23:31:35 <Vitka> OH SH~~\
23:31:35 <Makoryu> Does the haskell-erlang package support this in any way?
23:31:38 <regalia> I'm just working my way through Project Euler to get this kind of stuff sorted :)
23:31:55 <ksf> we can have another list deconstruction function that takes both possibilities as parameters.
23:32:11 <handonson> > head []
23:32:12 <lambdabot>   * Exception: Prelude.head: empty list
23:32:23 <handonson> Grand.
23:32:27 <ksf> Makoryu, I bet it doesn't.
23:32:55 <ksf> sending closures via over the net should be approachable now we have llvm, though
23:33:13 <Makoryu> Oh yeah
23:33:31 <Vitka> If non-empty list is what you what, then this exception could be used to help debug.
23:33:41 <ksf> that would give a whole new meaning to NFData.
23:34:08 <ksf> it's already bad not to strictify things between threads, imagine the same mistake via IP over avian carriers.
23:34:26 <regalia> If anyone could be troubled to enlighten me... How would you go about solving the problem of finding the largest palindrome that is the product of two 3 digit numbers?
23:34:41 <regalia> I'm sure I'm not nearly as elegant as possible
23:34:54 <Dementati> regalia: Isn't that an Euler problem or something? =P
23:34:59 <regalia> Dementati: Yup :)
23:35:03 <Dementati> Thought so.
23:35:12 <Dementati> Not so much fun if you can't figure it out yourself, though.
23:35:19 <regalia> I've already solved it
23:35:30 <Dementati> Oh, right.
23:35:32 <Dementati> Sorry.
23:35:32 <regalia> 906609
23:37:32 <Kostafey> How to round Double to some digits after comma? e.g.
23:37:32 <Kostafey> roundBy 2/3 2 -> 0.67
23:51:25 <ksf> Kostafey, by scaling and the using round.
23:51:35 <ksf> if you just want to print, there's showFFloat.
23:52:02 <Dementati> Dammit.
23:52:36 <ksf> there might be a way to do it without scaling and thus loosing precision, but you'd have to ask a numericologist about that.
23:53:54 <Kostafey> Where to get it? (Not in scope: `showFFloat')
23:54:25 <ksf> @hoogle showFFloat
23:54:26 <lambdabot> Numeric showFFloat :: RealFloat a => Maybe Int -> a -> ShowS
23:55:03 <ksf> > showFFloat (Just 3) (1/5) ""
23:55:04 <lambdabot>   "0.200"
