00:00:20 <aavogt> liyang: well regardless of how many passes it takes, ghc doesn't let you write malformed things
00:00:48 <aavogt> however, at the TH AST level, it's pretty lenient ex:
00:01:45 <liyang> aavogt: it didn't allow me to write malformed things that I later transform into well-formed things. :( This was back in 2006 though.
00:01:52 <aavogt>  stupid =  [| $(dyn "succ") $(dyn "succ") $(dyn "succ") |] -- this will not typecheck when you run the splice $(stupid)
00:02:38 <aavogt> > succ succ succ
00:02:39 <lambdabot>   No instance for (GHC.Enum.Enum ((a -> a) -> a -> a))
00:02:39 <lambdabot>    arising from a use ...
00:03:10 <aavogt> preflex: seen lunabot
00:03:10 <preflex>  lunabot was last seen on #haskell 55 days, 23 hours, 40 minutes and 24 seconds ago, saying:  31
00:03:15 <aavogt> :(
00:03:51 <aavogt> liyang: malformed things in [| these anti quotes or whatever you call them? |]?
00:04:20 <ski> Meta(ML|OCaml) does one pass of type-checking, ensuring both the type-correctness of the staged code, and of the code to be generated
00:05:35 <liyang> Whatever you call them. It's been some time since I last looked at TH.
00:06:06 <liyang> (malformed in the sense of it being syntactically- but not type-correct.)
00:09:03 <aavogt> well ghc does some extra checking on those quotes: d = [d| instance Eq () |]
00:09:20 <aavogt> that gets rejected because it's an 'duplicate instance decl'
00:10:58 <aavogt> while you're quite free to write: [InstanceD [] (AppT (ConT ''Eq) (ConT ''())) []]
00:12:53 <siracusa> aavogt: What means ''Eq?
00:13:15 <aavogt> it means the Name of the type (or typeclass) Eq
00:13:46 <siracusa> So it's the same as mkName "Eq"?
00:14:38 <aavogt> it catches more typos than mkName
00:15:06 <aavogt> it doesn't accept  ''FoO
00:15:44 <siracusa> If FoO wasn't defined
00:15:50 <aavogt> right
00:15:59 <aavogt> because it isn't because that's a stupid name
00:16:55 * liyang would love a compiler that told students their choice of names were stupid.
00:17:41 <aavogt> hmm, it does reject things like ; stringE (show x))
00:17:51 <aavogt> err [| ()()()()() |]
00:18:05 <siracusa> liyang: -XRejectStupidNames :-)
00:18:32 <user_> is the haskell platform for windows an older release?
00:19:40 <aavogt> I don't know how useful it would be for that to be accepted as     foldl1 appE $ replicate 5 (conE '())
00:19:47 <siracusa> user_: I think so
00:20:59 <aavogt> liyang: I think it's a feature that expression quotations seem to be typechecked
00:21:54 <aavogt> if you're going to mess around with the AST to make it typecheck, you might as well not use those quotations
00:26:20 <liyang> aavogt: why back in my day, that was all we had, and we were grateful for it!
00:27:21 <aavogt> what no. They are in the original paper!
00:27:32 <Jafet> First you'll need a compiler that does not use stupid names, liyang
00:28:15 <dejvik> hello everyone!
00:28:24 <aavogt> no, first you need to give yourself an acceptable name
00:28:37 <aavogt> hello dejvik
00:29:43 <dejvik> I am trying to use floating layout in xmonad and I don't like the way of placing windows. I have simplestFloat
00:30:15 <dejvik> cascading windows would be much better
00:30:49 <liyang> aavogt: I seem to remember only quoting [| |] and splicing $( ). Nevermind. :-/
00:30:51 <dejvik> my minimal config http://pastebin.com/zMSe8tUE
00:31:03 <dmwit> dejvik: Come join us in #xmonad!
00:31:30 <aavogt> it's pretty quiet here though
00:31:44 <liyang> That's because it's 07:30 in the morning.
00:32:01 <aavogt> maybe for you
00:32:13 <dejvik> dmwit: thanks
00:32:29 <liyang> That was implied.
01:00:28 <StudyAnimal> What is the ==> operator called?, its impossible to google
01:03:55 <mauke> what ==> operator?
01:05:07 <Gracenotes> in quickcheck?
01:05:21 <user_> StudyAnimal: hayoo or hoogle is better for such tasks than google
01:05:37 <user_> StudyAnimal: http://holumbus.fh-wedel.de/hayoo/hayoo.html#0:%3D%3D>
01:05:39 <Gracenotes> a ==> b, means !a || b, or something like
01:06:10 <kmc> @hoogle (==>)
01:06:10 <lambdabot> Test.QuickCheck (==>) :: Testable a => Bool -> a -> Property
01:06:35 <Gracenotes> at least when a is Bool
01:07:48 <kmc> @check \xs -> (length xs == 0)  ==>  (xs == [])
01:07:49 <lambdabot>   No instance for (Test.QuickCheck.Testable
01:07:49 <lambdabot>                     (Test.QuickCh...
01:08:04 <kmc> :t \xs -> (length xs == 0)  ==>  (xs == [])
01:08:05 <lambdabot>     Ambiguous occurrence `==>'
01:08:05 <lambdabot>     It could refer to either `Lava.==>', imported from Lava
01:08:05 <lambdabot>                           or `Test.QuickCheck.==>', imported from Test.QuickCheck
01:08:09 <kmc> oh snap
01:08:23 <kmc> :t \xs -> (length xs == 0) Test.QuickCheck.==>  (xs == [])
01:08:24 <lambdabot> forall a. (Eq a) => [a] -> Test.QuickCheck.Property
01:08:27 <kmc> @check \xs -> (length xs == 0) Test.QuickCheck.==>  (xs == [])
01:08:28 <lambdabot>   No instance for (Test.QuickCheck.Testable
01:08:28 <lambdabot>                     (Test.QuickCh...
01:08:33 <kmc> qualified infix oprs look weird
01:08:44 <kmc> > 2 Prelude.* 3
01:08:45 <lambdabot>   6
01:11:13 <StudyAnimal> thanks
01:11:53 <mm_freak> how can i make a Setup.hs find user-installed packages?
01:12:25 <StudyAnimal> although this is in something like "fmap f parser = parser ==> \result -> "
01:14:59 <kmc> odd
01:15:02 <kmc> it's not defined locally?
01:15:05 <mauke> Setup configure --user
01:15:07 <kmc> >>= would make more sense than ==>
01:15:18 <aavogt> it doesn't default to [()]?
01:15:33 <aavogt> @check \xs -> (length xs == 0) Test.QuickCheck.==>  (xs == ([]::[()]))
01:15:34 <lambdabot>   No instance for (Test.QuickCheck.Testable
01:15:34 <lambdabot>                     (Test.QuickCh...
01:15:39 <Gracenotes> ==> looks too spacy. >>= is sleek.
01:16:26 <Gracenotes> also the whole behavior of the function thing.
01:16:27 <user_> wouldn't that be more likely to collide with another function
01:16:38 <aavogt> =>> isn't taken in common libraries
01:16:42 <aavogt> >=<
01:16:45 <aavogt> <=>
01:16:55 * hackagebot fastirc 0.1.2 - Fast Internet Relay Chat (IRC) library  http://hackage.haskell.org/package/fastirc-0.1.2 (ErtugrulSoeylemez)
01:17:04 <kmc> ^_^
01:17:26 <Gracenotes> aavogt: =>> looks kind of angry
01:17:43 <Gracenotes> an angry, extra-pointy arrow
01:18:01 <dmwit> > let a ^-^ b = "kitty!" in 42
01:18:02 <lambdabot>   42
01:18:24 <kevinulin> are there any good pages describing proper haskell code formatting?
01:18:58 <kevinulin> it seems like that as long as you have the linebreaks and indent you can do almost anything else, but im sure there must be a correct and wrong way beyond that
01:19:17 <dmwit> It's all style after that.
01:19:23 <user_> 2 space indents will be law when I am king. better get used to it now.
01:19:34 <dmwit> real-tab indents FTW
01:19:52 <kmc> kevinulin, in fact the linebreaks and indent are just sugar for { } ;
01:19:57 <kmc> you can write totally freeform Haskell code
01:20:02 <aavogt> user_: no, it collides with the logo
01:20:16 <mm_freak> the indentation rules are quite intuitiveâ€¦  everything else is a matter of preference
01:20:23 <kevinulin> ya, but i want some day to be able to share my project with other people, and rather than make them learn whatever i think is pretty, i was hoping there might be a standard
01:20:23 <Gracenotes> syntax is sugar for ASTs
01:20:27 <kmc> mm_freak, sure, but some preferences are wrong :)
01:20:36 <mm_freak> kmc: of course =)
01:20:41 <Jafet> ASTs are too abstract
01:20:50 <dancor> kevinulin: maybe you should just copy like dons' style or something
01:20:55 <kmc> kevinulin, one random suggestion, i like to start "do" blocks on the next line after a function and its parameters are named
01:21:05 <Gracenotes> some argue they are tree-like
01:21:07 <kmc> rather than the same line, indented by a variable amount depending on the name and parameters
01:21:08 <dmwit> I keep reading your name as "kevinsulin".
01:21:12 <aavogt> some people don't put newlines after do, of and so on
01:21:19 <kmc> makes it more consistent, better use of the left-side space, less re-formatting when you change the function
01:21:35 <mm_freak> kmc: including the "do" keyword?
01:21:41 <kmc> yeah
01:21:41 <dmwit> I follow the "blocks always start on their own line" rule.
01:21:44 <kmc> maybe or maybe not including the =
01:21:47 <kmc> have not decided yet
01:21:48 <Gracenotes> my preferred: func = do\n   blah <- foo\n    return (f blah)\n
01:21:51 <mm_freak> because i write like:  func x y = do
01:21:58 <kmc> hmm
01:22:00 <aavogt> Gracenotes++
01:22:00 <mm_freak> that's quite compact
01:22:00 <kmc> i guess that works
01:22:07 <kmc> it seems like it should break the layout rule but i guess it doesn't actually
01:22:19 <kmc> 'cause it goes by the first non-whitespace token after do
01:22:41 <mm_freak> in fact i prefer to avoid starting a layout-style "do" block right in the same line as the "do" keyword itself
01:22:42 <aavogt> the style has a name 'z'?
01:22:50 <mm_freak> either: do x; y; z
01:22:58 <mm_freak> or:  do\n  x\n  y\n  z
01:23:19 <kmc> i will pedantically point out that "do x; y; z" still uses layout
01:23:24 <kmc> but yeah
01:23:30 <mm_freak> of course, but you get the point =)
01:23:46 <kmc> how do you decide on that vs. x >> y >> z
01:24:18 <aavogt> semicolons have a practical precedence of 0?
01:24:18 <kevinulin> maybe hes not willing to think x is that much better than y or z?
01:24:29 <kmc> har
01:24:35 <mm_freak> kmc: if x, y and z are short, i prefer x >> y >> z
01:24:53 <mm_freak> often i mix both, if one of them is long and two of them are short
01:24:55 <aavogt> there is a shortage of precedence levels IMHO
01:25:10 <kmc> it's quite convenient to use (>>) within a do block
01:25:12 <kmc> not so much the reverse
01:25:14 <mm_freak> do someLongExpression; shortExpr1 >> shortExpr2
01:25:20 <mm_freak> yeah
01:25:44 <mm_freak> actually i seldomly use (>>) in a do-block, but rather (>>=)
01:25:48 <Gracenotes> >> is good in lambda expressions
01:26:18 <Gracenotes> mapM_ (\x -> print x >> print (x+1)) [1..10]. In other useless syntax rambling news..
01:28:00 <mm_freak> do fileNames <- getArgs; mapM_ (readFile >=> putStr) fileNames
01:28:23 <kmc> @type fix $ flip out ()
01:28:24 <lambdabot> Mu ((->) ())
01:28:35 <aavogt>  mapM_ (putStr <=< readFile) =<< getArgs
01:28:36 <mm_freak> (i wouldn't even use 'do' at all in such a simple case, but just e.g.)
01:32:14 <kmc> @type fix . join $ appEndo . out
01:32:15 <lambdabot> Mu Endo
01:33:05 <mm_freak> :t let (.$.) = flip ($) in (putStr <=< readFile) .$. mapM_ =<< getArgs
01:33:06 <lambdabot> Not in scope: `getArgs'
01:33:12 <mm_freak> :t let (.$.) = flip ($) in (putStr <=< readFile) .$. mapM_ =<< (return [])
01:33:13 <lambdabot> IO ()
01:33:40 <Tarrasch> Hello, have anyone managed to install OpenGL with cabal (on Ubuntu), somehow solving the error: "* Missing C library: Xrandr"
01:34:10 <dmwit> Well, have you got the -dev version of the xrandr library installed? =)
01:34:12 <kmc> Tarrasch, did you try installing libxrandr through your distro's package manager?
01:34:30 <kmc> on debian you should get libxrandr2 and libxrandr-dev, probably similar on ubuntu
01:34:38 <dankna> okay
01:34:41 <dankna> nuts to this
01:34:49 <dankna> I am writing a package to do semiquotation
01:35:00 <kmc> semiquotation?
01:35:04 <dankna> it will be easier to do that than to muddle on with doing Template Haskell the hard way
01:35:06 <dankna> it's a Lisp concept
01:35:14 <dankna> you can do a quasiquote with real Haskell syntax inside it
01:35:20 <dankna> but you can also escape things within the quasiquote
01:35:25 <Jafet> How is that different from quasiquoting
01:35:27 <kmc> that's what TH does
01:35:31 <Tarrasch> kmc, thanks, it worked :D
01:35:34 <dankna> it is quasiquoting, except TH doesn't let you unquote
01:35:39 <kmc> yeah it does
01:35:41 <dankna> how?
01:35:45 <kmc> with $( ... )
01:35:46 <dankna> I can't find docs on such a facility
01:35:50 <dankna> hmmm
01:35:51 <aavogt>  $(dyn stringName)
01:35:52 <dankna> so you can do like
01:35:58 <kmc> read the original TH paper, and then read the relevant GHC manual section
01:36:01 <kmc> and anything it links
01:36:47 <dankna> also it happens that I need this for patterns
01:36:51 <kmc> [| let x = $(lift (2 + 2)) |]
01:36:59 <kmc> is the same quote as [| let x = 4 |]
01:37:00 <dankna> which don't seem to be supported by ghc (I get an error message that they aren't supported "yet")
01:37:02 <dankna> oooh
01:37:03 <dankna> great!
01:37:12 <dankna> I couldn't find docs on that, even though I have all the sources you mention open
01:37:17 <dankna> I must be poor at reading comprehension ;)
01:37:31 <kmc> there are a few TH tutorials / examples too
01:37:36 <mm_freak> chrisdone: now you can add your checks =)
01:37:41 <dankna> I may add a paragraph or two to the wiki emphasizing the importance of this feature if I feel like it
01:38:11 <aavogt> kmc:  $(lift x)  == x , no?
01:38:29 <kmc> @quote majesty
01:38:29 <lambdabot> malcolm says: I don't believe you need to invoke the full awesome majesty of Template Haskell
01:38:30 <dankna> why is it lift?  that's not intuitive to me
01:38:36 <dankna> lol
01:38:43 <kmc> dankna, you mean the name, or why it's required?
01:38:47 <dankna> why it's required
01:38:52 <kmc> the thing you splice must be Haskell code
01:38:54 <kmc> of type Q Exp or so
01:39:00 <kmc> 2+2 is Int or so
01:39:06 <dankna> ah, okay
01:39:08 <dankna> got it
01:39:11 <kmc> lift turns a value into a Haskell code literal
01:39:13 <aavogt> oh, it's different in that you calculate the 2+2 at compile time
01:39:15 * dankna nods
01:39:16 <kmc> aavogt, yeah
01:39:19 <dankna> aavogt: yes exactly
01:39:21 <kmc> a stupid example but yes
01:39:23 <siracusa> :t lift
01:39:24 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
01:39:29 <kmc> err that's a different "lift"
01:39:30 <dankna> this is a crucial feature because it saves you from writing stuff like
01:39:30 <kmc> unfortunately
01:39:45 <dankna> nopasting my example, one sec
01:39:49 <aavogt> usually you don't have anything useful to precompute though
01:40:01 <dankna> saves you from writing stuff like this
01:40:01 <dankna> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24425#a24425
01:40:09 <dankna> if you read that (and it isn't easy!)
01:40:10 <siracusa> kmc: What type has the other lift?
01:40:18 <dankna> you will see that it only ever changes one thing inside that huge expression
01:40:19 <kmc> @hoogle lift
01:40:19 <lambdabot> Control.Monad.Trans lift :: (MonadTrans t, Monad m) => m a -> t m a
01:40:20 <lambdabot> Text.ParserCombinators.ReadPrec lift :: ReadP a -> ReadPrec a
01:40:20 <lambdabot> Language.Haskell.TH.Syntax lift :: Lift t => t -> Q Exp
01:40:24 <kmc> the last one
01:40:33 <dankna> so it's awfully nice to be able to write it all quoted except for the bit that changes
01:40:34 <kmc> > Language.Haskell.TH.Syntax.lift ()
01:40:35 <lambdabot>   Not in scope: `Language.Haskell.TH.Syntax.lift'
01:40:43 <dankna> this works for type annotations too, right?
01:40:45 <dankna> ie I can do
01:40:52 <dankna> something akin to
01:41:01 <dankna> [| foo :: $(lift bar) |]
01:41:01 <kmc> iirc ghc doesn't support type splices :/
01:41:08 <dankna> :/
01:41:10 <kmc> that'd be a decl quote
01:41:26 <kmc> foo :: $(bar)
01:41:30 <kmc> wuold be a type splice
01:41:35 <Jafet> In other words, lift is return?
01:41:38 <kmc> [t| Maybe Char |] a type quote
01:41:41 <kmc> Jafet, the TH lift?
01:41:52 <dankna> well, I guess I meant
01:41:55 <Jafet> Weird.
01:41:59 <dankna> [| 1 + 2 :: $(lift 'Int) |]
01:42:07 <dankna> on an expression, not on a declaration
01:42:09 <kmc> dankna, oh, right
01:42:11 <kmc> an expression sig
01:42:16 <kmc> yeah i don't think that's supported :/
01:42:19 <dankna> :/
01:42:23 <dankna> okay, but it COULD be supported
01:42:25 <kmc> Jafet, i don't know what you mean
01:42:27 <dankna> the quasiquote syntax is versatile enough
01:42:29 <kmc> dankna, yes
01:42:38 <dankna> and the heavy lifting has been done by haskell-src-exts, it looks like
01:42:43 <dankna> so I just need to do the other heavy lifting :)
01:42:49 <kmc> dankna, that paste is seriously impressive and terrifying
01:42:50 <Jafet> TH.Syntax.lift looks like Prelude.return
01:42:55 <dankna> kmc, thanks!
01:43:03 <dankna> kmc, this is what happens when you let a Lisp pro loose on Haskell :)
01:43:09 <kmc> yeah
01:43:21 <dankna> they start asking tough questions like "where are the macros" ;)
01:43:34 <arcatan> looks like TH has raised its popularity recently. I wonder if there are finally some easy-to-grasp tutorials for it...
01:43:34 <dankna> "I heard there were macros"
01:43:51 <dankna> "so, somebody mentioned macros"
01:43:51 <Jafet> :t if'
01:43:52 <pkrumins> Anyone good with ML?
01:43:52 <lambdabot> Not in scope: `if''
01:43:57 <kmc> those lisp guys with their one really huge hammer
01:43:58 <pkrumins> There seems to be no channel for ML.
01:44:00 <dankna> yes, haha
01:44:09 <kmc> pkrumins, isn't there one for SML and one for OCaml?
01:44:10 <dankna> pkrumins: possibly #ocaml or something?
01:44:15 <dankna> or #sml yeah
01:44:22 <kmc> in Haskell TH is a sort of powerful tool of last resort
01:44:25 <dankna> plain ML is not a heavily-used dialect in my understanding
01:44:28 <pkrumins> oh yea, #sml, thanks!
01:44:35 <dmwit> dankna: So, what's your big-picture goal?
01:44:37 <pkrumins> that's true.
01:44:45 <dmwit> dankna: It's not so common to really need this stuff.
01:44:47 <dankna> oh
01:44:48 <dankna> well
01:44:51 <kmc> ML is a dialect, not a reference to the family as a whole?
01:44:52 <dankna> I wrote a library this week
01:44:59 <dankna> kmc: I believe ML is the vanilla dialect
01:45:04 <dankna> but I may be wrong
01:45:08 <kmc> SML is Standard ML
01:45:14 <dankna> ... I wrote a library this week, which does parsing and generation of SQL
01:45:36 <dankna> it's a full model of the SQL syntax as implemented by SQLite3, in 4000 lines; I'm very proud of it
01:45:41 <dankna> I want it to be callable from C
01:45:54 <dankna> this is nontrivial; I figured out how I want that to be structured...
01:46:15 <dankna> but I'm going to need to define C versions of all the constructors and accessors for the nodes of the abstract syntax tree
01:46:22 <dankna> I am NOT writing that by hand!
01:46:24 <pkrumins> Can't get SML to use identifier "o", says that it's special.
01:46:31 <pkrumins> Substituted it with "a" and it works.
01:46:33 <dankna> not when it's so highly repetitive and so error-prone
01:46:37 <pkrumins> Trying to understand what is going on.
01:46:42 <kmc> dankna, your comment at the bottom is the constructed code?
01:46:46 <dankna> kmc: yes
01:46:54 <kmc> dankna, and the ellipses are the only variable parts?
01:46:57 <dankna> correct
01:47:08 <arcatan> kmc: ML is the original programming language, developed by Milner, but nowaday it's used mostly to refer the family
01:47:08 <dankna> as you can see, the constructed code is much shorter than the AST for it
01:47:58 <kmc> seems like you could factor out much of that code
01:48:09 <dankna> one might hope
01:48:25 <dankna> as long as it's inside the splice anyway, I don't care about it being cleanly factored because in a sense it already is
01:48:31 <kmc> in another sense it's not
01:48:38 <dankna> haha
01:48:39 <pkrumins> Here is an example of how using "o" doesn't work but using "a" works: http://pastebin.com/r09J5wGC
01:48:49 <kmc> i dunno, i think metaprogram output is at least 20 times as hard to maintain as straight 1-level code
01:48:51 <dankna> well, I could probably get the six-line function down to two lines
01:49:05 <kmc> so it's best to have as little metaprogram output as possible calling a large fixed library
01:49:06 <dankna> it needs to have the type signature and it needs to have the return
01:49:10 <dankna> no matter what I do I can't avoid that
01:49:35 <dankna> and I respectfully don't agree - I think it's easier to have the metaprogram not reference regular-program stuff more than necessary
01:49:39 <dankna> because then you get "ravioli code"
01:49:48 <dankna> where everything is little pieces that mean nothing taken in isolation
01:50:09 <kmc> dankna, i think you can factor this into a combinator which makes sense taken in isolation
01:50:11 <dankna> however, with semiquotation the metaprogram could be a lot more maintainable than it is presently
01:50:15 <dankna> well, I'd love to see how
01:50:21 <Gracenotes> pkrumins: my guess, it's an infix identifier. >_>
01:50:30 <dankna> I don't see it, presently
01:50:38 <kmc> a challenge :D
01:50:41 <dankna> hehe :D
01:50:43 <dankna> yep :D
01:50:46 <dmwit> dankna: one sec
01:50:46 <pkrumins> Gracenotes, :D seems like it, just realized it.
01:51:01 <pkrumins> Though what's an 'infix identifier' I know of infix operators
01:51:01 <Gracenotes> dunno how
01:51:04 * hackagebot xhtml-combinators 0.2.1 - Fast and easy to use XHTML combinators.  http://hackage.haskell.org/package/xhtml-combinators-0.2.1 (AlasdairArmstrong)
01:51:07 <pkrumins> like octal perhaps
01:51:20 <pkrumins> infix octal identifier.
01:51:24 * pkrumins tests this hypo
01:51:50 <Gracenotes> ooh, perhaps
01:51:54 <pkrumins> yes?
01:51:59 <kmc> dankna, using ScopedTypeVariables and a dummy arg perhaps
01:52:05 <pkrumins> oh.
01:52:05 <kmc> to get at the inner type sig
01:52:07 <dmwit> dankna: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24425#a24426
01:52:10 <pkrumins> right.
01:52:16 <dmwit> kmc: Ah, you stole my idea!
01:52:20 <dankna> I confess to not understanding that extension, but it sounds promising
01:52:35 <kmc> @hoogle Proxf
01:52:35 <lambdabot> No results found
01:52:36 <kmc> @hoogle Proxy
01:52:36 <lambdabot> Network.Browser data Proxy
01:52:36 <lambdabot> Network.Browser Proxy :: String -> Maybe Authority -> Proxy
01:52:36 <lambdabot> Network.Browser getProxy :: BrowserAction t Proxy
01:53:13 <dankna> ah, the undefined argument to pass in a type signature is a very cool idea
01:53:29 <dankna> let me see if I can implement that
01:53:56 <kmc> dankna, also, you're using "let" a lot more than i would
01:54:09 <dmwit> yeah
01:54:18 <dankna> that's a matter of me not having been using Haskell long enough to know more idiomatic ways of doing it, I think
01:54:25 <dankna> how would you have done it?
01:54:26 <pkrumins> Gracenotes, doesn't seem to be the case, asked on #sml, though the type of "o" is `operator domain: ('Z -> 'Y) * ('X -> 'Z)`
01:54:28 <dmwit> just fold the lets into the places you used it
01:54:33 <dmwit> let me annotate again
01:54:34 <dankna> oh
01:54:35 <kmc> dankna, sec
01:54:39 <dankna> but I like explicit names
01:54:43 <dankna> they keep things straight :)
01:54:53 <kmc> dankna, in general explicit names are frowned upon when they have this little scope
01:55:00 <kmc> the expression itself is a better name than the name
01:55:00 <dankna> yes, I take your point
01:55:08 <dankna> that's a thought
01:55:13 <Gracenotes> pkrumins: no function scope for certain things? ..not like I know SML.. or this is #sml..
01:55:23 <kmc> > let addThreeToANumber n = n+3 in map addThreeToAnNumber [1,2,3]
01:55:24 <lambdabot>   Not in scope: `addThreeToAnNumber'
01:55:26 <kmc> > map (+3) [1,2,3]
01:55:27 <lambdabot>   [4,5,6]
01:55:30 <pkrumins> Gracenotes, just letting you know.
01:55:33 <dmwit> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24425#a24427
01:55:40 <dankna> well, I know how to fold the lets, you don't have to do that work for me unless you feel generous, dmwit - oh you did! :)
01:55:51 <kmc> (+3) is a better name than any name made of letters
01:55:59 <dmwit> Well, just to compare visually. Then you can decide if you want to do it yourself. =)
01:56:13 <dankna> yeah, I like it.  although I don't like your indentation ;)
01:56:18 <kmc> dmwit even stole my name
01:56:18 <dmwit> =)
01:56:24 <kmc> showTokensFoo
01:56:27 <dankna> haha
01:56:49 <kmc> btw this can be done without extensions
01:56:58 <dmwit> yep
01:57:01 <kmc> :t asTypeOf
01:57:02 <lambdabot> forall a. a -> a -> a
01:57:16 <dmwit> This is getting better and better, isn't it?
01:57:19 <dankna> neat
01:57:44 <kmc> and i think showTokensFoo is a reasonable standalone thingy
01:57:54 <dankna> yes, I think so too
01:57:56 <kmc> so we've avoided the ravioli code you speak of
01:57:59 <dankna> yes
01:58:00 <kmc> (ravioli? why ravioli?)
01:58:18 <Jafet> It's more exciting than penne?
01:58:20 <dankna> (because it's a different type of pasta from spaghetti.  don't look at me, I just borrowed the term from somebody on the p2 wiki)
01:58:25 <kmc> i want tortellini code
01:58:33 <dankna> yum
01:58:38 <dmwit> I thought ravioli code was good gode.
01:58:47 <kmc> dankna, that's the one at c2.com?
01:58:51 <dankna> well, with referential transparency maybe
01:58:52 <dankna> yes, that's the one
01:58:58 <kmc> don't get me started on them ;P
01:58:59 <dmwit> i.e. clearly identifiable packages, each containing their own stuff, and no intermingling
01:59:01 <dankna> I think the p2 wiki may be the wrong name for it
01:59:13 <dankna> haha, well, I was a big fan of them many years ago... my enchantment with them has waned over the years
01:59:22 <kmc> @quote pompous
01:59:22 <lambdabot> PeterOtten says: [re: design patterns] When most of your code does nothing in a pompous way that is a sure sign that you are heading in the wrong direction.
01:59:32 <dankna> dmwit: yeah...
01:59:41 <dankna> well, design patterns are overused and misused
01:59:47 <dankna> that doesn't mean they're inherently bad
02:00:07 <Gracenotes> design patterns say things about the design of the language that prompts them
02:00:08 <kmc> dankna, as a Lisp expert you must agree that most design patterns you find in C++ or Java are macros that the programmer is expected to expand by hand ;)
02:00:09 <dankna> many of them are fairly C++-specific which is pretty lame
02:00:16 <dankna> yes, hahaha, I certainly do
02:00:20 <kmc> yes, they are canonical workarounds for language flaws
02:00:27 <kmc> (see also: Haskell records)
02:00:42 <dankna> ha
02:01:22 <kmc> so what i object to is not that people find and describe these, but that they consider them a good thing
02:01:29 <dankna> yeah, that's definitely fair
02:01:40 <dankna> it would be far better to address them at the language-design level
02:01:41 <kmc> rather than a sign that someone should write a library or a language extension
02:01:45 <Jafet> kmc: http://paulgraham.com/avg.html
02:02:04 <kmc> it's best to have a language design with a few very general forms of abstraction, so that most patterns can be dealt with as ordinary libraries
02:02:23 <dankna> agreed, definitely
02:02:28 <kmc> LISP is an extreme example there
02:02:35 <dankna> yes
02:03:05 <Jafet> I was going to link to the section on Blub, but Graham doesn't know what anchors are
02:03:19 <kmc> Jafet, i've read it
02:03:31 <kmc> i try to prevent Haskell from becoming my Blub
02:03:37 <kmc> by ranting about its flaws
02:03:43 <kmc> and by finding weirder languages to learn
02:04:06 <Jafet> Graham, ironically, is in the Blub: "Lisp is so great [...] because it is simply the most powerful language available."
02:04:15 <kmc> but Lisp isn't a language at all
02:04:31 <Jafet> Sure it is. It's just a different language for each person you ask
02:04:35 <dankna> not a language?  it has a standard.
02:04:48 <Jafet> dankna, so does FORTH
02:04:49 <kmc> it's a toolkit for writing your own languages
02:04:53 <dankna> haha
02:04:55 <dankna> yeah, okay
02:04:59 <kmc> especially if you do things how Graham wants you to
02:05:47 <kmc> _On Lisp_ is a very macro-happy book
02:05:52 <Gracenotes> have you reduced your program node count yet today, kmc??
02:05:56 <kmc> haha
02:06:00 <dankna> haha
02:07:36 <Gracenotes> not including libraries, of course
02:08:00 <kmc> most of the programming i did today was in Coq
02:08:09 <kmc> not sure how that ranks on Graham's expressiveness index
02:08:21 <kmc> probably poorly because it's not Arc
02:09:16 <dankna> yes, oy.  I lost a lot of respect for him when I saw how most of his writing has been dumbed-down recently for 20-somethings doing startups
02:09:33 <Jafet> Well, that is where he keeps his financial interests.
02:09:36 <dankna> oh certainly
02:09:38 <dankna> it's understandable
02:09:46 <dankna> but I find it patronizing and offputting
02:09:49 <Jafet> A startup twink.
02:09:52 <dankna> haha
02:10:22 <pkrumins> Anyone remembers the name of counting when you'd say Zero and One_more_than(x). And you get all integers.
02:10:39 <dmwit> peano?
02:10:46 <dankna> Peano
02:10:53 <Jafet> You can't get all integers from those...
02:10:59 <kmc> all natural number
02:10:59 <dankna> all natural numbers
02:11:03 <kmc> data Nat = Zero | Succ Nat
02:11:09 <kmc> also known as Mu Maybe
02:11:17 <pkrumins> Right! all naturals. and Peano.
02:11:18 <Jafet> Hah
02:11:23 <Gracenotes> or [()], with less bottoms
02:11:26 <pkrumins> looking up what Mu Maybe is, never heard of it.
02:11:29 <kmc> @src Mu
02:11:29 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
02:11:36 <dmwit> Oh, go on, it's isomorphic to all integers. =)
02:11:45 <kmc> Mu makes fixedpoints of types the same way "fix" makes fixedpoints of values
02:11:49 <sl101> @src Mu
02:11:49 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
02:12:07 <kmc> so (where ~ means "is isomorphic to"): Mu Maybe ~ Maybe (Mu Maybe) ~ Maybe (Maybe (Mu Maybe)) ~ ...
02:12:32 <kmc> therefore your terms are essentially Nothing, Just Nothing, Just (Just Nothing), Just (Just (Just Nothing)) etc
02:12:42 <pkrumins> Cool enumeration
02:12:46 <kmc> except with some In thrown in because Haskell doesn't allow unwrapped infinite types
02:13:00 <pkrumins> got it!
02:15:06 <dv-> Has anyone gotten ghc 6.12 working on openbsd?
02:18:36 <dankna> silence
02:19:12 <kmc> is golden
02:19:21 <Jafet> Duct tape is silver.
02:19:24 <dankna> is white noise platinum?
02:19:35 <dv-> openbsd's ghc package is still 6.6 :-(
02:19:51 <Jafet> dv-, is it securer
02:19:51 <kmc> gorilla tape is closer to black
02:19:59 <kmc> but not recommended for taping gorillas
02:20:09 <kmc> whereas duct tape is fairly suitable for taping ducts
02:20:30 <dankna> smirk
02:20:31 <dankna> quite
02:20:44 <dankna> well, if you tape them properly they won't have the leverage to get loose
02:20:52 <dankna> though they would certainly have the raw strength
02:21:08 <Jafet> Please keep your fantasies to yourself
02:21:44 <dankna> hahahahaaha
02:22:25 <dankna> kmc, dmwit: hey cool, I did things the way you suggested and it worked.  I think I still need parameter splices though, so I still have some libary to write.
02:22:51 <dobblego> is there a mapM_ for Maybe?
02:22:57 <kmc> what do you mean?
02:23:06 <dmwit> dobblego: Yup, it's called mapM_.
02:23:09 <kmc> :t mapM_
02:23:10 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
02:23:11 <dankna> mapM_ works on any monad and Maybe is a monad
02:23:15 <dobblego> (Monad m) => (a -> m b) -> Maybe a -> m ()
02:23:15 <kmc> :t mapM_ :: (a -> Maybe b) -> [a] -> Maybe ()
02:23:16 <lambdabot> forall a b. (a -> Maybe b) -> [a] -> Maybe ()
02:23:25 <dankna> not that I can help you with /using/ Maybe as a monad because I have never tried it :(
02:23:32 <dobblego> I don't want the Maybe monad
02:23:41 <dmwit> dobblego: better say what you want, then =)
02:23:43 <dankna> then you need to clarify your question
02:23:48 <dobblego> (Monad m) => (a -> m b) -> Maybe a -> m ()
02:23:56 <dobblego> (Monad m, Traversable t) => (a -> m b) -> t a -> m ()
02:24:11 <kmc> aha
02:24:39 <kmc> :t maybe (return ())
02:24:40 <lambdabot> forall (m :: * -> *) a. (Monad m) => (a -> m ()) -> Maybe a -> m ()
02:24:56 <dobblego> boo
02:25:13 <dmwit> :t maybe (return ()) . (>> return ())
02:25:14 <lambdabot>     Couldn't match expected type `m ()' against inferred type `()'
02:25:14 <lambdabot>       Expected type: a -> m ()
02:25:14 <lambdabot>       Inferred type: a -> ()
02:25:16 <kmc> :t maybe (return ()) (. (>> return ()))
02:25:17 <lambdabot> forall (m :: * -> *) a. (Monad m) => Maybe (m () -> ()) -> m a -> ()
02:25:43 <kmc> :t maybe (return ()) ((>> return ()) .)
02:25:44 <lambdabot>     Couldn't match expected type `()' against inferred type `m ()'
02:25:45 <lambdabot>     In the first argument of `(.)', namely `(>> return ())'
02:25:45 <lambdabot>     In the second argument of `maybe', namely `((>> return ()) .)'
02:25:50 <dmwit> ?pl \f -> maybe (return ()) ((>> return ()) . f)
02:25:51 <lambdabot> maybe (return ()) . ((>> return ()) .)
02:25:51 <kmc> yes this is getting quite readable
02:26:12 <dobblego> I'll take it as a no :) thanks!
02:26:20 <dmwit> :t mapM_ . catMaybes . return
02:26:21 <lambdabot>     Couldn't match expected type `a -> m b'
02:26:21 <lambdabot>            against inferred type `[a1]'
02:26:21 <lambdabot>     In the first argument of `(.)', namely `catMaybes'
02:26:23 <dankna> chortle
02:26:25 <dmwit> urk
02:26:30 <dmwit> :t \f -> mapM_ f . catMaybes . return
02:26:31 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> Maybe a -> m ()
02:26:35 <dmwit> dobblego: ?
02:26:44 <dmwit> or even better
02:26:45 <dankna> dobblego, to gow ith kmc's original answer, just define maybeM = maybe (return ())
02:27:01 <dmwit> :t \f -> mapM_ f . maybe return []
02:27:02 <lambdabot>     Couldn't match expected type `[a]'
02:27:02 <lambdabot>            against inferred type `a1 -> m a1'
02:27:02 <lambdabot>     In the first argument of `maybe', namely `return'
02:27:06 <dankna> or better yet, understand why that works and don't bother to give it a name
02:27:08 <dmwit> :t maybe
02:27:09 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
02:27:18 <dobblego> dankna, I understand all these solutions, thanks
02:27:26 <dankna> think of the first parameter to maybe as the default
02:27:26 <dmwit> :t \f -> mapM_ f . maybe [] return
02:27:27 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> Maybe a -> m ()
02:27:31 <dobblego> maybe is the cata for Maybe; of course I can write it using that
02:27:33 <dankna> haha okay.  I thought you were perhaps getting a little overwhelmed.
02:27:52 * kmc considers (Monad m, Traversable t) => (a -> m b) -> t a -> m ()
02:28:01 <dmwit> ?src Traversable
02:28:01 <lambdabot> class (Functor t, Foldable t) => Traversable t where
02:28:01 <lambdabot>     traverse    :: Applicative f => (a -> f b) -> t a -> f (t b)
02:28:01 <lambdabot>     sequenceA   :: Applicative f => t (f a) -> f (t a)
02:28:01 <lambdabot>     mapM        :: Monad m => (a -> m b) -> t a -> m (t b)
02:28:01 <lambdabot>     sequence    :: Monad m => t (m a) -> m (t a)
02:28:13 <kmc> oh huh
02:28:16 <kmc> there it is pretty much
02:28:38 <dmwit> yup!
02:28:46 <dobblego> the abesnce of the "pretty much" part was my question
02:29:06 <dmwit> :t \f m -> Traversable.mapM f m >> return ()
02:29:07 <lambdabot> Couldn't find qualified module.
02:29:17 <dobblego> fmap it
02:29:29 <kmc> :t T.mapM
02:29:30 <lambdabot> Couldn't find qualified module.
02:29:39 <kmc> :t Data.Traversable.mapM
02:29:40 <lambdabot> forall a (m :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
02:29:46 <dmwit> :t \f m -> Data.Traversable.mapM f m >> return ()
02:29:47 <lambdabot> forall a (m :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Monad m) => (a -> m b) -> t a -> m ()
02:30:31 <dmwit> better
02:43:45 <nothingmuch> i'm playing around with writing an evaluator for a scheme like mini language but with lazy evaluation, an dI can't figure something out
02:43:50 <nothingmuch> i have (id (id id))
02:43:54 <nothingmuch> that's supposed to reduce to 'id'
02:44:30 <nothingmuch> but it's not clear where that is supposed to stop
02:44:42 <nothingmuch> that is, from the top level if you apply id to the thunk (id id) you get that thunk
02:45:14 <nothingmuch> in this type of system, is there always an explicit mark on what is a thunk and what isn't?
02:45:47 <nothingmuch> (consider (id '(id id))
02:46:14 <nothingmuch> anyway, i can't see any other way around it but i suspect it's just imperative habits, so I wanted some alternative input
02:48:07 <kmc> the usual lazy reduction is to weak head normal form
02:48:30 <kmc> which means that the outermost node of the expression is something other than an application
02:49:46 <kmc> sorry, a reducible application, meaning an application whose left-hand side is a lambda abstraction
02:50:55 <nothingmuch> kmc: thanks, that looks well documented on google, i think i understand but reading up just to be sure
02:51:52 <kmc> so it would reduce to 'id'
02:54:06 <kmc> not necessarily by that name
02:54:38 <kmc> if you are writing a big-step evaluator that takes an expression (and an environment) to a value
02:54:58 <kmc> then the only values of the pure lambda calculus are lambda abstractions with no free variables
02:55:23 <kmc> so it'd be more fair to say that it reduces to (\x -> x)
02:55:34 <kmc> up to alpha renaming
02:55:52 <nothingmuch> yeah that's what my test expects
03:02:14 <dankna> @unpl dataToExpQ = dataToQa TH.conE TH.litE (foldl TH.appE)
03:02:14 <lambdabot> dataToExpQ = dataToQa TH.conE TH.litE (foldl TH.appE)
03:02:22 <dankna> mm.
03:05:05 <dmwit> What were you expecting that to do?
03:05:14 <dmwit> Your function already has no arguments. =P
03:05:27 <dankna> unpl is the opposite of pl
03:05:40 <dankna> I was hoping it would help me understand which of the parameters is consuming which of the unnamed arguments
03:05:42 <dmwit> Oh, yeah, didn't read carefully.
03:06:03 <dmwit> Well, :t would probably help more than ?unpl in this case.
03:06:09 <dankna> yeah, but I know the type
03:06:18 <dmwit> How do I set a timeout with gtk2hs? I know I've seen it somewhere in the docs, I just can't remember where.
03:06:26 <dankna> no idea, never used it
03:07:23 <dmwit> found it
03:08:01 <dankna> good
03:08:42 <dmwit> hm
03:08:57 <dmwit> The documentation leaves one small detail to be desired: the precision of the "time" argument.
03:09:13 <dankna> ouch?
03:11:14 <dankna> :t const
03:11:15 <lambdabot> forall a b. a -> b -> a
03:14:13 <Twey> dankna: dataToQa is the only function that consumes arguments
03:14:23 <Twey> It might pass them to other functions, though.
03:16:54 <dankna> Twey: thanks, yeah, I figured it out finally
03:17:30 <dankna> @pl (\input -> do { expression <- parseE input ; TH.dataToExpQ (const Nothing) expression } )
03:17:31 <lambdabot> (line 1, column 15):
03:17:31 <lambdabot> unexpected "{"
03:17:31 <lambdabot> expecting variable, "(", operator or ")"
03:18:51 <dankna> @pl (\input -> parseE input >>= TH.dataToExpQ (const Nothing)  )
03:18:51 <lambdabot> (TH.dataToExpQ (const Nothing) =<<) . parseE
03:18:59 <dankna> ah!
03:19:34 <dankna> the paper had parseE >>= dataToExpQ (const Nothing), which wasn't working for me
03:22:39 <dmwit> Well, I never. X is using 102% CPU.
03:22:44 <dmwit> I didn't even know it was multi-threaded.
03:24:01 <dankna> heh...
03:25:41 <ksf> grmbl impredicative types...
03:26:07 <ksf> I just want to existentially quantify a record type. can that be that deprecated?
03:26:14 <mpiechotka> Hello. Where can I find information about type operators? I.e. something like :+: etc.?
03:26:37 <ksf> ah no, it's the type class restraints _in_ the record
03:28:07 <dmwit> mpiechotka: There's not much to say...
03:28:22 <dmwit> mpiechotka: Enable the extension, and you can have infix type operators.
03:29:57 <mpiechotka> dmwit: Sorry. I mean something like: "f :: a -> b -> a :+: b"
03:30:15 <Twey> mpiechotka: Right
03:30:17 * dmwit means that, too
03:30:36 <Twey> :+: is a type operator just like any other type constructor.
03:30:42 <Twey> It's just infix.
03:30:55 * ksf wonders whether it is a good idea to unify remove/create with write. read and readdir are already unified, after all.
03:31:20 <Twey> Yay DWIM
03:31:22 <QtPlatypus> Why can't I devide rationals?
03:31:35 <ksf> sure you can.
03:31:35 <dmwit> > (3%4) / (4%3) -- you can't?
03:31:36 <lambdabot>   9 % 16
03:32:02 <Gracenotes> remember, % is not the division operator; it's the rational-making operator
03:32:28 <dmwit> > (3/4) / (4/3) :: Rational
03:32:29 <lambdabot>   9 % 16
03:32:43 <dmwit> (/) is also the rational-making operator ;-)
03:32:59 <QtPlatypus> Then my error is comeing from somewhere else.
03:33:00 * dmwit admits that "3" has a different type in those two expressions
03:33:14 <ksf> the nasty thing is that directories may have string indices... I can make write append-only, which works great to create files, but removing files is nasty.
03:34:01 <ksf> otoh, I could pretend that files are Maps from any key to something.
03:34:16 <ksf> which'd include string-indexed directories.
03:41:03 <Gracenotes> dmwit: in that case fromInteger is the rational-making operator >_>
03:43:56 <dankna> ahhhh BibDesk, such a nice program...  I went through last week and finally organized my collection of papers, using it
03:43:59 <dankna> MUCH nicer
03:44:09 <dankna> it was impossible to find anything, even if I remembered the paper I was looking for in some detail
03:44:39 <ksf> do we have a map or a map interface that supports lookup etc. by Data.Range?
03:46:03 <dankna> not that I'm aware of, but I wouldn't be
03:46:35 <ksf> ...and a total order on keys.
03:48:23 <dmwit> Data.Range?
03:48:35 <ksf> ranges package.
03:48:50 <ksf> think data Range a = Single a | Range a a
03:49:19 <dankna> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24431#a24431  Why isn't it finding the instance?  Do I need functional dependencies?  But they just change the error to a different one...
03:49:46 <ksf> ...because it'd be insanity to not support range operations on a Map Integer -> Word8 that is basically a bytestring.
03:50:07 <Taejo> ksf: what operations do you want, exactly
03:50:08 <Taejo> ?
03:50:34 <dmwit> The ranges library is rather restrictive with what you can do with a Range.
03:50:35 <ksf> lookup, modify, insert
03:50:51 <Taejo> ksf: with what types?
03:50:58 <ksf> all of them
03:51:23 <Taejo> ksf: I'm trying to understand what you want. Saying you want everything doesn't help
03:51:34 <ksf> as my Files are going to be typed, I thought it'd be a jolly good idea if diretories would just be Map String (File a)
03:51:50 <dmwit> ksf: http://hackage.haskell.org/packages/archive/fingertree/0.0.1.0/doc/html/Data-IntervalMap-FingerTree.html ?
03:53:03 <ksf> er no they can't overlap.
03:53:50 <ksf> Taejo, but if all Files are Maps, accessing raw data bytewise by integer key curls my neck hair.
03:55:21 <dmwit> Well, you're not being specific enough about what you're looking for for us to help you.
03:56:33 <dankna> I think I get what he wants, sort of
03:56:59 <ksf> ...if I knew exactly what I wanted, I wouldn't be asking.
03:57:11 <dankna> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24431#a24433
03:57:16 <dankna> I tried functional dependencies
03:57:22 <dankna> I think they helped - it finds the instance now
03:57:32 <dankna> but complains that it can't unify two things that certainly look unifiable to me
03:59:47 <dmwit> It looks to me like
03:59:57 <dankna> if it's a hard problem and people are quiet because they have no ideas on it rather than because they aren't paying attention, I would find the moral support of "it looks hard" helpful :)
03:59:58 <dmwit> fromLHE :: LHE.Exp -> Maybe (TH.Q TH.Exp)
03:59:59 <dmwit> but
04:00:12 <ksf> @seen edwardk
04:00:12 <lambdabot> Unknown command, try @list
04:00:17 <dmwit> TH.dataToExpQ is expecting something of type (forall b. b -> Maybe (TH.Q TH.Exp)).
04:00:19 <ksf> preflex, seen edwardk
04:00:19 <preflex>  edwardk was last seen on #haskell 14 hours, 52 minutes and 44 seconds ago, saying: then grab the next
04:00:22 <dmwit> Note the location of the forall.
04:00:28 <ksf> preflex, seen edwardk_
04:00:28 <preflex>  edwardk_ was last seen on #haskell 14 hours, 16 minutes and 46 seconds ago, saying: aledge: a mesofact
04:00:29 <dankna> hrm
04:00:30 <ksf> preflex, seen edwardk__
04:00:31 <preflex>  edwardk__ was last seen on #haskell 2 days, 16 hours, 16 minutes and 24 seconds ago, saying: brb
04:00:32 <dmwit> It means that dataToExpQ gets to choose what 'b' is, not you.
04:00:39 <dankna> oh!
04:01:14 <dankna> that would be the "rigid" in "rigid type variable" I guess
04:01:30 <dankna> well, I guess that makes sense
04:01:35 <dankna> hmmm, now what I can do about it...
04:01:55 <dankna> I suppose I need to change the signature and behavior of fromLHE
04:02:54 <ksf> oh http://hackage.haskell.org/package/rope-0.6.1
04:02:59 <ksf> he already released it
04:03:10 <dankna> yeah
04:05:03 <dankna> hrm.
04:05:10 <dankna> I suppose I need to understand Data.Data now.
04:27:39 <StudyAnimal> About to start chapter 11 of RWH
04:31:19 <Gracenotes> StudyAnimal: congrats :)
04:32:47 <Gracenotes> the core haskelly stuff is in previous chapters
04:33:51 <StudyAnimal> yeah it didn't sink in too deeply yet
04:34:13 <Alpounet> have you solved all the exercises so far ?
04:34:19 <StudyAnimal> i really have to analyse a snippet and pull it apart before i know what is going on
04:34:42 <StudyAnimal> most of the exercises in the later chapters no
04:36:10 <StudyAnimal> about half way through each chapter things stop working and the exercises usually extend that
04:36:32 <StudyAnimal> sometimes i can get it working again
04:36:43 <Alpounet> try to solve them
04:36:44 <StudyAnimal> most exercises i cant answer myself
04:36:49 <Alpounet> try harder heh
04:36:58 <StudyAnimal> you either get it or you dont
04:37:46 <StudyAnimal> eventually i find a model answer and confirm there is no way i could have worked it out based on what i know
04:38:14 <StudyAnimal> or at least no way of linking what i know to being relevant to solve the exercise
04:38:34 <StudyAnimal> its cool, im used to this feeling from learning other things
04:38:50 <StudyAnimal> by the end of the book things will have sunk in a bit more
04:39:05 <StudyAnimal> start recognising patterns etc
04:39:38 <StudyAnimal> i definitly plan on going back and trying the exercises again
04:44:02 <kingping> Hello people.
04:44:12 <ManateeLazyCat> Hi, all! :)
04:44:20 <kingping> For some reason I'm unable to install http://hackage.haskell.org/cgi-bin/hackage-scripts/package/actor
04:44:41 <kingping> It just says 'Actor\Timeout:hs.16:35'
04:45:03 <kingping> Has anybody used actor model in Haskell ?
04:47:09 <Jafet> I use Shakespeare for that
04:50:24 <kingping> Jafet: Could you give me a link ?
04:50:37 <mm_freak> which cabal version is required for 'source-repository'?
04:50:48 <mm_freak> i set >= 1.6
04:52:31 <kingping> Jafet: I just couldn't find it in google :/
04:54:51 <Jafet> http://shakespearelang.sourceforge.net/report/shakespeare/shakespeare.html#sec:primes
05:08:11 <dankna> my custom quasiquoter isn't working.  I get a syntax error when I try to actually use it :/
05:08:18 <dankna> oh!  maybe I left out a LANGUAGE flag...
05:08:56 <dankna> yep, that was it
05:10:54 <siracusa> dankna: What can it do that Haskell's quasiquoter can't?
05:12:40 <kingping> Jafet: Thanks.
05:12:43 <dankna> siracusa: treat patterns as first-class variables.
05:13:34 <Jafet> Aren't TH's patterns first-class enough?
05:13:38 <dankna> no
05:13:44 <dankna> well, this is an extension to TH
05:13:48 <dankna> with default TH
05:13:54 <dankna> I cannot do [p|...|]
05:14:06 <dankna> (I get an error message which indicates that someone was aware of the possibility but didn't implement it)
05:15:04 <dankna> but TH is extensible with user parsers
05:15:17 <dankna> I can define a parser named p and then do [$p|...|]
05:15:40 <siracusa> And now you can write things like case x of { $([p| ... |] -> ...  }?
05:15:44 <fax> ?djinn foo :: (forall p. Either p (Not p)) -> (forall p. Not (Not p) -> p)
05:15:44 <lambdabot> Cannot parse command
05:15:47 <dankna> well no, because I'm barely started
05:15:58 <dankna> and no anyway
05:15:59 <fax> ?djinn foo :: (forall p. Either p (p -> Void)) -> (forall p. ((p -> Void) -> Void) -> p)
05:15:59 <lambdabot> Cannot parse command
05:16:02 <dankna> but I will be able to write
05:16:02 <fax> boooo
05:18:00 <dankna> let pattern = [$p|...|] in $(lift [$e| case x of { $pattern -> ... } |])
05:18:11 <dankna> and thanks for making me work that out, as it clarifies things in my mind
05:18:27 <fax> woah
05:18:48 <dankna> what's the woah for?
05:19:36 <dankna> the reason for the extra layer of $(lift [$e| ... |]) is
05:19:47 <dankna> you cannot splice things there in normal TH
05:20:01 <dankna> but you can use your custom parser to perform the splice before TH gets its hands on it
05:20:10 <fax> why do you have pattern as a variable?
05:20:16 <siracusa> The extra lift confuses me
05:20:19 <dankna> because maybe I want to parametrize on pattern
05:20:26 <fax> why
05:20:27 <dankna> it could be a parameter
05:20:34 <dankna> because I come from a Lisp background, is the ultimate answer
05:20:39 <fax> okay
05:20:40 <dankna> but I can give a specific example that motivates this
05:20:53 <hasenov> hello, would it be possible to transform the abundants list that i am carrying around in accumIfNotSumOfTwoAbundants into monad?
05:21:04 <dankna> I have written a largeish library which exports about 50 type constructors
05:21:11 <dankna> I want to make a C binding for my library
05:21:13 <fax> danka, if you gave just one example I could probably kill it but it would most likely not solve the general problem
05:21:16 <dankna> to do this I need some highly repetitive code
05:21:29 <dankna> fax - I'd love to see you do that, it would save me writing this entire auxilliary library :)
05:21:36 <dankna> so let me hpaste my entire code then
05:21:47 <dankna> not too long
05:21:50 <hasenov> the code i meant to point to is http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24434
05:22:35 <dankna> fax: hold on one moment, I need to write a little context for your benefit
05:22:42 <fax> ok
05:26:03 <mreh> what does the '|' introduce in a type class signature
05:26:13 <mreh> e.g. class Arrow a => ArrowState s a | a -> s where
05:26:25 <JuanDaugherty> "such that"?
05:27:30 <mreh> what does that mean semantically?
05:28:35 <JuanDaugherty> same as standard mathematical English, I presume
05:29:04 <mreh> such that `a` is a function of `s`?
05:29:08 <mreh> oops
05:29:11 <mreh> vice versa
05:29:24 <bremner> isn't it "where"?
05:29:53 <dobblego> mreh, look up functional dependencies
05:29:56 <mreh> that introduces the implementation, like the `where` that's already in there
05:31:19 <siracusa> mreh: It means the type of s is determined from a.
05:31:44 <mreh> oh it's a type dependency
05:32:31 <mreh> ,preflex seen jmcarthur
05:38:02 <dankna> fax: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24435#a24435
05:38:33 <dankna> fax: if you can do that without an extension to Template Haskell and without writing everything out longhand (there are dozens of instances and it would be a huge file), I will have your babies (disclaimer: not physically possible)
05:39:26 <Jafet> fax can just unsafeCoerce you
05:39:32 <dankna> hahahahaha
05:39:34 <dankna> sounds kinky!
05:41:46 <clanehin> when using a custom package-db, cabal-install complains that dependency "package-version-longHEXstring" doesn't exist, even though it just installed the package from automatic dependency analysis.  I'm not really sure what I should be looking for.
05:42:02 <clanehin> This for several unrelated packages.
05:42:03 <dankna> clanehin, which package is it?
05:42:26 <dankna> clanehin, the long-hex-string makes me suspect that it upgraded packages that came with GHC, which it's never supposed to do
05:42:33 <clanehin> at the moment I happen to be playing with parallel and deepseq
05:42:38 <dankna> because those are the only packages I can think of where the version number is a long hex string
05:42:51 <dankna> ah, well those aren't distributed with GHC, hm
05:43:02 <dankna> can you nopaste the full error?  it might have more information that you missed
05:43:20 <clanehin> sure, a minute . . .
05:49:30 <clanehin> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24436
05:50:23 <dankna> fax: specifically, it can't be done in Template Haskell because there's no way without a custom parser to quasiquote a type constructor.
05:50:37 <fax> dankna it's not functional programming ;S
05:50:47 <clanehin> wow, I should set a prefix too, I think, but that doesn't seem to be affecting cabal (will try again to make sure)
05:50:48 <fax> it's just generating a list of names for the FFI?
05:50:48 <dankna> fax - I agree.  It's a binding to a library that's functional.
05:50:52 <dankna> clanehin - hmm....
05:50:59 <dankna> fax - well, and definitions to go with the names
05:51:56 <dankna> fax - the definition actually has to do some "interesting" stuff, because of course the only way to let C manipulate Haskell values is for the C to take the responsibility for lifetime management
05:52:09 <dankna> fax - so it has to allocate stable pointers for returned values
05:52:29 <clanehin> I ran into all of this after upgrading to ghc6.12 and moving from a locally-built cabal-install to the debian-shipped cabal-install
05:52:41 <dankna> clanehin, nopaste the output of ghc-pkg list for me
05:55:00 <clanehin> dankna, done, same page
05:56:06 <dankna> clanehin, it's the --package-db="/home/lane/src/test/my-package-db" flag I think
05:56:23 <dankna> you're not installing to the global repo
05:56:53 <dankna> which is sort-of okay, except that then ghc can't find the packages it just installed because they're in a private repo
05:57:10 <dankna> Cabal knows about your user directory and won't try to install systemwide even if you leave out the my-package-db stuff
05:57:16 <dankna> the correct way to do it is with --user
05:57:24 <dankna> but that's implicit anyway
05:57:30 <dankna> so just take out that flag and things should work
05:59:34 <clanehin> dankna: Yeah.  I don't want this in --user or --global.  I want to be able to nuke it at-will.  I may just need to use chroot or something, though.
06:01:24 <dankna> oh, hmm
06:01:47 <clanehin> Maybe I need to add a flag to point to the newly install libs.
06:01:52 <dankna> that might be, yes
06:06:32 <dankna> fax: actually!  I found a slightly more verbose way that it can be done.
06:06:56 <fax> is that progress??
06:06:59 <dankna> yes
06:07:04 <dankna> but you're absolutely correct that this particular problem isn't functional programming.  it's another idiom, which I prefer to call "useful programming" :)
06:07:19 <fax> yeah that's something I don't really know much about :P
06:07:23 <dankna> hehe, oh well
06:07:59 <dankna> basically you can't pass a type constructor definition but you can pass a pair of the type constructor name and a list of types, which is the same information
06:38:30 <mreh> :t liftm
06:38:30 <lambdabot> Not in scope: `liftm'
06:38:32 <mreh> :t liftM
06:38:33 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
06:38:38 <mreh> :T fmap
06:38:42 <mreh> :t fmap
06:38:43 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:39:04 <mreh> @src Monad fmap
06:39:04 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
06:39:16 <mreh> no... it hasn't
06:49:19 <dankna> @hoogle a -> b -> c -> d -> [(a, b, c, d)]
06:49:19 <lambdabot> Data.List zip4 :: [a] -> [b] -> [c] -> [d] -> [(a, b, c, d)]
06:49:24 <dankna> oh, it's in Data.List
06:50:47 <pkrumins> what commands are available via @hoogle?
06:52:33 <siracusa> pkrumins: It looks for function names matching on the given type signature
06:54:18 <pkrumins> is there a faq or a page that lists the possible @word commands?
06:54:59 <siracusa> http://code.haskell.org/lambdabot/COMMANDS
06:55:04 <pkrumins> thanks! :)
06:55:49 <siracusa> And @help command gives you a hint what command does
06:56:21 <mreh> I'd really quite like to create an ArrowRandom class
06:56:44 <mreh> but I have no idea quite where to start, deriving it from ArrowState seems like a good idea
06:57:42 <dankna> @hoogle [a] -> [b] -> [(a,b)]
06:57:43 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
06:57:43 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
06:57:43 <lambdabot> Data.Graph.Inductive.Example genLNodes :: Enum a => a -> Int -> [LNode a]
06:57:48 <dankna> er
06:58:02 <dankna> oh, I guess so.  I feel dumb.
06:59:02 <Icewing> @pl f t d xs = t xs : (f (d xs))
06:59:03 <lambdabot> f = fix (flip ((.) . liftM2 (:)) . (.))
06:59:39 <Icewing> @pl f d t xs = t xs : (f (d xs))
06:59:39 <lambdabot> f = fix ((flip (liftM2 (:)) .) . (.))
07:02:38 <pkrumins> @help pl
07:02:38 <lambdabot> pointless <expr>. Play with pointfree code.
07:05:18 <dankna> :k a ->
07:05:19 <lambdabot> parse error (possibly incorrect indentation)
07:06:15 <fax> can't you just make it from random monad
07:06:31 <fax> oops im talking to the past
07:06:39 <dankna> I hate when that happens
07:06:40 * idnar fires up the DeLorean
07:07:30 <mreh> @msg
07:07:30 <lambdabot> Not enough privileges
07:07:42 <mreh> @list
07:07:42 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
07:08:23 <mreh> @tell jmcarthur I need some pointers in making this ArrowRandom we discussed before
07:08:23 <lambdabot> Consider it noted.
07:26:06 <balor> Does http-server support https?  And if not, is there an https package floating about?
07:41:04 * hackagebot GenSmsPdu 0.1 - Automatic SMS message generator  http://hackage.haskell.org/package/GenSmsPdu-0.1 (KwanghoonChoi)
07:50:34 <blueonyx> hi, how is "trivial" implemented in quickcheck 2?
07:52:05 <MisterN> is STM the best thing, or is there an even better abstraction? :)
07:52:37 <ManateeLazyCat> MisterN: STM is best.
07:53:02 <ManateeLazyCat> MisterN: At least, STM is best and clearest.  :)
07:53:11 <ManateeLazyCat> Can i change darcs's port when i do "darcs get"?
07:53:19 <ManateeLazyCat> In China, GFW filter make some port can't work, if i don't use tool around GFW, darcs will got error "can't connect server port".
07:53:27 <ManateeLazyCat> So i want to know: Can i change darcs setting to around this?
07:53:39 <Jafet> Can't darcs fetch over http?
07:54:02 <Twey> Can't you set HTTP_PROXY??
07:54:19 <ManateeLazyCat> Twey: Yep, but proxy is slow.
07:55:19 <michael_R> What would you consider as the most important preliminaries (concepts) for understanding applicative functors in Haskell?
07:55:38 <michael_R> If you had to explain them to somebody who only has very basic Haskell knowledge .... especially as a motivating example...
07:55:41 <MisterN> ManateeLazyCat: this is consistent with my hypothesis that the GFW is holding back chinese knowledge workers :>
07:56:14 <Twey> ManateeLazyCat: Not a local proxyâ€¦
07:56:14 <MisterN> (i wanted to write "confirms my theory" at first, but this is #haskell, so i try to be as mathematically precise as i can manage :D)
07:56:21 <jmcarthur> MisterN: is STM best for what, exactly? i'm of the opinion that different concurrency abstractions are good for different things
07:56:21 <lambdabot> jmcarthur: You have 1 new message. '/msg lambdabot @messages' to read it.
07:56:28 <Twey> ManateeLazyCat: How does your â€˜toolâ€™ work if not by providing a proxy?
07:56:48 <jmcarthur> mreh: hey, what's up?
07:56:49 <MisterN> jmcarthur: the best default when you don't know what you're doing :D
07:56:59 <ManateeLazyCat> Twey: I use YourFreedom -- A P2P tool to fighting GFW,
07:57:09 <jmcarthur> MisterN: the best default when you don't know what you're doing is to learn what you're doing ;)
07:57:17 <ManateeLazyCat> Twey: But that's just 128Kb to download
07:57:31 <Twey> ManateeLazyCat: It provides a proxy on your local machine
07:57:40 <ManateeLazyCat> Twey: Yep.
07:57:43 <Twey> Set HTTP_PROXY to it and all your apps should use it
07:57:49 <mreh> jmcarthur: I was going to have a crack at ArrowRandom, but I've got to go out
07:57:58 <mreh> I think I was talking to you about it
07:57:59 <jmcarthur> mreh: ah
07:57:59 <MisterN> jmcarthur: well, people aren't born wise
07:58:05 <ManateeLazyCat> Twey: I know that, but i don't want use it, it's too slow.
07:58:05 <jmcarthur> mreh: yeah, that was me
07:58:11 <mreh> jmcarthur, I'll speak to you later
07:58:17 <jmcarthur> mreh: alright
07:58:18 <Twey> ManateeLazyCat: Then what â€˜toolâ€™ were you talking about?
07:59:04 <ManateeLazyCat> Twey: I don't know, maybe this is only way.
07:59:23 <ManateeLazyCat> Twey: I just can push patch if i don't open YourFreedom
07:59:25 <jmcarthur> ManateeLazyCat: for what protocol do you wish to change the port?
07:59:43 <ManateeLazyCat> jmcarthur: I can't do "darcs get"
07:59:51 <jmcarthur> ManateeLazyCat: but what protocol?
07:59:56 <jmcarthur> ssh? http?
08:00:02 <ManateeLazyCat> jmcarthur: http
08:00:11 <ulfdoz> Why not announcing Servers in general?
08:00:17 <jmcarthur> changing the port will only work if the http server is running on that port
08:00:17 <ulfdoz> ewin
08:00:33 <jmcarthur> and you should be able to specify it in the uri
08:01:01 <ManateeLazyCat> jmcarthur: How. Example for "darcs get --partial http://code.haskell.org/gtk2hs/ --old" ?
08:01:06 <jmcarthur> ManateeLazyCat: a proxy would be your better bet
08:01:18 <jmcarthur> ManateeLazyCat: yeah unless you know otherwise it's probably only running on port 80
08:01:35 <jmcarthur> ManateeLazyCat: you will have to use a proxy
08:01:40 <ManateeLazyCat> jmcarthur: I guess GFW filter 80 port recently
08:01:48 <Twey> The GFW filters code.haskell.org?
08:01:57 <ManateeLazyCat> Twey: It filter all 80 port.
08:02:03 <jmcarthur> ManateeLazyCat: not all of port 80. port 80 is like the whole web
08:02:06 <Twey> ManateeLazyCat: So you can't browse the Web?
08:02:22 <ManateeLazyCat> Twey: Google can't, painful.
08:02:31 <ManateeLazyCat> Twey: But i have tool around GFW.
08:02:40 <jmcarthur> ManateeLazyCat: wait, you can't get to the web at all?
08:02:47 <Twey> If port 80 is blocked, you can't use most of the Web at all
08:02:49 <ManateeLazyCat> jmcarthur: Just some website.
08:02:54 <Twey> Almost all sites use port 80.
08:03:06 <ManateeLazyCat> Twey: Sorry, i think just some website.
08:03:17 <jmcarthur> ManateeLazyCat: yeah, port 80 isn't blocked universally then
08:03:20 <Twey> So code.haskell.org is blocked?
08:03:23 <ManateeLazyCat> Twey: All that China gove don't want you access. I mean.
08:03:44 <ManateeLazyCat> Twey: Just "darcs get" can't work, i can browse code.haskell.org use browser.
08:03:53 <jmcarthur> ManateeLazyCat: try a proxy
08:04:06 <Twey> ManateeLazyCat: There shouldn't be a difference
08:04:08 <ManateeLazyCat> jmcarthur: I have a proxy, but slow.
08:04:22 <jmcarthur> ManateeLazyCat: doesn't sound like you have a choice
08:04:32 <Twey> darcs just acts as an HTTP client, like your browser.
08:04:34 <ManateeLazyCat> jmcarthur: Yep.
08:04:41 <Twey> If you can access it from a browser, you should be able to access it from darcs.
08:04:49 <ManateeLazyCat> Twey: That's strange.
08:04:59 <ManateeLazyCat> Twey: I just can use darcs push patch.
08:05:03 <idnar> Twey: well, the UA and other things aren't the same
08:05:06 <ManateeLazyCat> Twey: Can't `get`.
08:05:20 <ManateeLazyCat> Twey: I'm can't understand why.
08:05:26 <idnar> Twey: also, you don't usually try to load _darcs/ files in your browser
08:05:37 <ManateeLazyCat> Twey: But i can use darcs access code.haskell.org when i open proxy.
08:06:56 <ManateeLazyCat> jmcarthur: BTW, have chinese guy build a system that break GFW directly, TCP deceive.
08:07:06 <dankna> obviously,
08:07:17 <dankna> the GFW is transparently inserting an http proxy of its own
08:07:20 <dankna> and looking at the user-agent
08:07:26 <ManateeLazyCat> jmcarthur: Search "west-chamber-0.0.1" on Google code.
08:07:37 <dankna> you need to make it appear as though the user-agent of darcs is a common web client (Internet Explorer?)
08:07:56 <ManateeLazyCat> dankna: I don't use IE.
08:08:03 <dankna> well, doesn't matter
08:08:13 <jlouis> dankna: that would be my guess as well
08:08:15 <dankna> darcs sends its own user-agent string in the http headers and the firewall is blocking that
08:08:34 <ManateeLazyCat> dankna: So you have fix solution?
08:08:35 <dankna> if the source of YourFreedom is available, the easiest solution would be to modify it
08:08:48 <dankna> you could also modify darcs instead
08:09:09 <ManateeLazyCat> dankna: How? Can you teach me detail?
08:09:23 <dankna> no, I have to go in a few minutes, sorry.  and it's somewhat involved.
08:09:58 <dankna> I think you should go with the modify-darcs strategy.  start by getting the source to darcs with "cabal unpack darcs".
08:10:13 <ManateeLazyCat> dankna: For current situation, looks user-agent case, because browser can access code.haskell.org, but darcs can't, even it's use http
08:10:13 <dankna> then read the source and find the part where it sets the user-agent and modify that, and then install from your modified tree
08:10:31 <dankna> but this is not trivial unless you are experienced in reading large programs written by other people
08:10:53 <dankna> but it's a relatively simple change, just one string constant
08:11:10 <ManateeLazyCat> dankna: Thanks i will try.
08:11:13 <dankna> good luck!
08:11:18 <dcoutts> the user agent is set in the C code iirc
08:11:24 <dcoutts> the small binding to libcurl
08:11:58 <dcoutts> via cpp :-(
08:12:07 <ManateeLazyCat> dcoutts: So can't modified user agent easily?
08:12:20 <ManateeLazyCat> dcoutts: GFW block darcs, sadly.
08:12:21 <dcoutts> ManateeLazyCat: easy if you hack the code
08:12:36 <ManateeLazyCat> dcoutts: I'm busy on update gtk2hs API. :)
08:12:56 <dcoutts> ManateeLazyCat: I've no idea what you're trying to do
08:13:15 <dcoutts> GFW? blocking?
08:13:18 <ManateeLazyCat> dcoutts: It's all the problem of GFW, damn it!
08:13:20 <ManateeLazyCat> dcoutts: Yep.
08:13:36 <ManateeLazyCat> dcoutts: I can't use "darcs get" if i close my tool that fighting GFW.
08:13:49 <ManateeLazyCat> dcoutts: Darcs failed "can't connect server port"
08:14:05 <ManateeLazyCat> dcoutts: GFW is China's "Great FireWall"
08:14:14 <dankna> dcoutts: He's in China and is behind their firewall which we have determined is very likely filtering http traffic based on user-agent.
08:14:16 <ManateeLazyCat> dcoutts: For limit Chinese people's freedom.
08:14:29 <dcoutts> ahhh, the mist lifts
08:14:52 <ManateeLazyCat> dcoutts: That's why Google exit China.
08:15:01 <dcoutts> dankna: so only web browers can get http eh?
08:15:20 <dankna> that seems to be the case
08:15:22 <ManateeLazyCat> dcoutts: Facebook, twitter, youtube, Google, blogspot, all of those can't access in China, sadly?
08:15:27 <dcoutts> ManateeLazyCat: can you cabal update?
08:16:01 <ManateeLazyCat> dcoutts: Can't
08:16:15 <dcoutts> that also uses it's own user agent
08:16:21 <ManateeLazyCat> dcoutts: cabal: does not exist
08:16:23 <soiamso> ManateeLazyCat: just boring
08:16:36 <dcoutts> hmm, that might just be dns
08:16:50 <ManateeLazyCat> dcoutts: I use Google Public DNS
08:17:11 <ManateeLazyCat> dcoutts: This is first thing i will do when i install system
08:17:21 <cebewee> is there an easy way to instruct cabal to install (recursively) all dependencies for one package (when rebuilding with profiling support)?
08:17:31 <ManateeLazyCat> dcoutts: I have set dns server with "8.8.8.8" (Google Public DNS)
08:18:02 <dcoutts> cebewee: sadly not, ghc-pkg does not track whether packages have profiling libs installed
08:18:14 <ManateeLazyCat> dcoutts: I can use "darcs get" and "cabal update" when i open tool (YourFreedom, a P2P tool fighting GFW), but it's too slow.
08:18:29 <ManateeLazyCat> dcoutts: So i wonder have other way around GFW.
08:18:40 <ManateeLazyCat> dcoutts: And dankna Tell me change user-agent.
08:19:15 <ManateeLazyCat> I hope i can escape China someday, GFW waste me much time!
08:21:50 <ManateeLazyCat> dcoutts: Please test my new code if you have spare time. I almost finish all Gtk+ API.
08:22:12 <balor> ManateeLazyCat: You have haskell GTK bindings?
08:22:44 <ManateeLazyCat> balor: I'm working on gtk2hs recently, update all Gtk2hs API to Gtk+ 2.18.3
08:23:00 <ManateeLazyCat> balor: darcs get --partial http://code.haskell.org/gtk2hs/
08:24:59 <balor> ManateeLazyCat: nice
08:25:14 <ManateeLazyCat> balor: BTW, you can use WebKit with gtk2hs
08:25:21 <balor> even better
08:25:28 <ManateeLazyCat> balor: See gtk2hs/demo/webkit for demo
08:25:37 <balor> All we need are clutter bindings now
08:25:41 <ManateeLazyCat> balor: Just do `make` after you install gtk2hs
08:26:08 <dcoutts> ManateeLazyCat: good work! BTW, have you tried the new cabal build system for gtk2hs?
08:26:17 <ManateeLazyCat> balor: I'm have finish 90% code that udpate to Gtk+ 2.18.3
08:26:36 <ManateeLazyCat> dcoutts: Axel working on it.
08:26:59 <ManateeLazyCat> dcoutts: I update API, Axel convert cabal.
08:27:10 <ManateeLazyCat> dcoutts: We works parallel.
08:27:20 <ManateeLazyCat> dcoutts: It's faster for current gtk2hs developing. :)
08:27:34 <balor> So it looks like happstack has no https support :(
08:28:00 <burp> you usually use it with another httpd in front which supports https
08:28:06 <burp> and proxy the happstack app
08:28:14 <burp> which you want to do anyway
08:28:17 <burp> for static resources
08:28:17 <ManateeLazyCat> dcoutts: Please check my code, because some code that ApiGen generate not right, so i write code by hand, perhaps have bug, please check it if you have spare time. Thanks!
08:28:33 <dcoutts> ManateeLazyCat: sadly I have very little spare time
08:29:08 <ManateeLazyCat> dcoutts: Nevermind, have update so much new function recently, perhaps some code is wrong.
08:29:26 <ManateeLazyCat> dcoutts: Anyway, i will test all api after i finish all API update.
08:30:03 <ManateeLazyCat> dcoutts: I have udpate all exist Gtk+ API, and add new modules now. :)
08:30:08 <dcoutts> great
08:30:55 <balor> burp: thanks.
08:31:13 <balor> burp: Will that work for dynamic stuff too?
08:31:20 <ManateeLazyCat> dcoutts: I found always missing something when i use gtk2hs coding before, so i think why not spend one week udpate all those API? Then i don't need push little patch anymore. :)
08:31:40 <burp> sure
08:32:02 <burp> for example apache mod_proxy http://httpd.apache.org/docs/2.0/mod/mod_proxy.html
08:32:18 <ManateeLazyCat> balor: BTW, clutter is cool, i will binding it if i have time. But i'm not sure, because i need busy on my own project after update gtk2hs
08:32:59 <ManateeLazyCat> balor: Maybe i will binding clutter api when i Gtk+ 3 released.
08:41:49 <balor> ManateeLazyCat: What's your own project?
08:42:08 <ManateeLazyCat> balor: Haskell SoftOS base on gtk2hs.
08:42:32 <ManateeLazyCat> balor: Editor, terminal, filter-manager, browser, irc-client, mail-client, everything in it.
09:00:15 <cebewee> I'm trying to write a function which decodes certain escape sequences in a ByteString.
09:00:40 <cebewee> My current approach is <http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24441>, but this runs in a stack overflow already with 150k data
09:01:29 <cebewee> Now my guess is that this is due the unpacking/packing of the string, so I wonder, if there is something better for this
09:04:40 <kuribas> Has anyone used the WASH webframework?  I am trying to compile it, but the Setup.lhs script is broken.
09:10:52 <kuribas> cebewee: You aren't using the bytestring version of mapAccumL?
09:15:02 <cebewee> kuribas: the bytestring version has always Word8 as second type of the tuple
09:15:26 <cebewee> this would not work
09:17:18 <kuribas> I see...
09:18:26 <jlouis> cebewee: one shot in the semidark: tried lazy bytestrings rather than strict?
09:18:31 <jeltsch> Am I the only one who experience a slow Haskell web server at the moment?
09:18:43 <jeltsch> experience â†’ experiences
09:19:28 <jlouis> jeltsch: http://downforeveryoneorjustme.com/haskell.org
09:19:34 <jlouis> yeah, it is slow
09:19:42 <kuribas> cebewee: It works fine for me...
09:20:00 <jeltsch> jlouis: I didnâ€™t say itâ€™s down for me.
09:20:11 <jeltsch> jlouis: Okay, so itâ€™s slow for you, too.
09:20:16 <jeltsch> Thank you.
09:21:00 <jlouis> jeltsch: it isn't the network though. It happily answers pings
09:21:18 <jlouis> and an mtr run also suggests no routing troubles
09:21:43 <kuribas> cebewee: I am using ghci
09:22:29 <cebewee> :t mapAccumL
09:22:30 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
09:22:39 <cebewee> :t Data.ByteString.mapAccumL
09:22:40 <lambdabot> forall acc. (acc -> Word8 -> (acc, Word8)) -> acc -> BSC.ByteString -> (acc, BSC.ByteString)
09:23:37 <cebewee> kuribas: I have "Maybe Word8" for y (as I need to delete some characters) - I do not see how I could use the bytestring mapAccumL
09:24:03 <cebewee> jlouis: just replacing Data.Bytestring by Data.ByteString.Lazy did not change anything
09:24:45 <kuribas> cebewee: I meant, it runs fast and without problems for me (your version).
09:26:02 <kuribas> I am using ghc 6.12.1
09:27:15 <cebewee> hm. 6.8 here. I'll try it on another machine
09:33:02 <cebewee> strange.
09:33:21 <cebewee> i tested it with 6.12.1 - no success. but in ghci it actually works?
09:33:29 <cebewee> (on my machine)
09:38:27 <int-e> cebewee: did you define a main function?
09:39:47 * hackagebot Vec-Boolean 1.0.3 - Provides Boolean instances for the Vec package  http://hackage.haskell.org/package/Vec-Boolean-1.0.3 (TobiasBexelius)
09:39:49 * hackagebot Vec-Transform 1.0.4 - Extends the Vec package with some 4x4 transform matrices  http://hackage.haskell.org/package/Vec-Transform-1.0.4 (TobiasBexelius)
09:48:59 <StudyAnimal> hmm when i compile with -fhpc and run i dont get any .mix or .tix, is this something that has changed since RWH was written?
09:49:47 <cebewee> int-e: yep. renamed 'test' to 'main'
09:50:59 <cebewee> has ghci the same stack limit as is the default for complied programs?
09:53:06 <cebewee> anyways, using 3.5M test data instead of 150k still killed my machine, so this is not the way to go, I guess =)
09:55:24 <StudyAnimal> ahh i had to force-recomp
09:56:15 <chrisdone> man there are a lot of httpds written in haskell
09:57:54 <jcreigh> sometimes I wonder if some things ought to be hard, to discourage that sort of duplication. For example, there are fewer OS kernels than blogging CMSes. :)
09:58:52 <chrisdone> you have the same thing in the lisp community but with implementations
09:59:55 <pippijn> cebewee: ghci is a compiled program
10:00:12 <pippijn> cebewee: it has the stack limit that is set by your operating environment
10:03:28 <chrisdone> who hosts hpaste.org?
10:04:04 <fax> I think it's glguy
10:05:22 <cebewee> pippijn: It seems to me that the haskell runtime has its own stack(size)
10:05:37 <pippijn> cebewee: which is lower than the system stack size?
10:05:52 <cebewee> pippijn: No, larger.
10:05:55 <pippijn> oh
10:06:02 <pippijn> okay
10:06:25 <cebewee> system stack size is 8M; but increasing the RTS stack size to 9M helped
10:09:23 <kuribas> Which is the best httpd?
10:09:24 <pippijn> I see
10:09:43 <pippijn> kuribas: none of them
10:10:01 <pippijn> kuribas: it depends on what criteria you judge them by
10:10:19 <chrisdone> kuribas: lighttpd is light, easy and used by big people, so it's well tested
10:11:02 <kuribas> chrisdone: But lighttpd is not haskell?
10:11:15 <chrisdone> no it's not
10:11:16 <kuribas> Sorry, I meant haskell httpd's.
10:11:55 <chrisdone> I heard good stuff about hyena but maybe there's a comparison out there of all the haskell httpds
10:12:04 <chrisdone> seems to be a new one every week
10:12:52 <kuribas> I am looking for a continuation based webframework in haskell.  WASH is the closest to what I had in mind.
10:13:12 <chrisdone> ahh
10:13:47 <chrisdone> I know chris eidhof is working on a continuation based web library at the moment
10:14:03 <kuribas> chrisdone: Ah nice.  Do you have a link?
10:15:09 <chrisdone> I just spoke to him about it at zurihac. it'll probably be ontop of salvia. he's in here as chr1s
10:15:10 * hackagebot hemkay-core 0.1.2 - A device independent module music mixer  http://hackage.haskell.org/package/hemkay-core-0.1.2 (GergelyPatai)
10:16:29 <chrisdone> kuribas: is WASH any good?
10:17:28 <kuribas> Reading the documentation it looks very nice, but I didn't manage to build it yet.
10:17:44 <chrisdone> hmm. it's not on hackage?
10:18:32 <kuribas> no...
10:18:57 <chrisdone> tch
10:19:04 <dmwit> The WASH language for building HTML is very nice. I'm not sure I like the rest of it, though.
10:19:38 <chrisdone> dmwit: what do you think of the blazehtml monad syntax for building html?
10:19:42 <dmwit> It is probably the closest to what you want if what you want is "continuation based", though. =)
10:19:54 <kuribas> yes :)
10:19:55 <dmwit> chrisdone: Hm, I haven't seen that one.
10:20:38 <dmwit> What is up with all these new packages that are on github but not Hackage?
10:20:41 * dmwit does not approve
10:21:28 <chrisdone> dmwit: agreed
10:21:37 <dmwit> BlazeHtml looks pretty sane.
10:21:50 <dmwit> Does it pull WASH's nice type-system trick, too?
10:21:57 <dmwit> (To guarantee well-formed xhtml?)
10:22:37 <chrisdone> no, it's build for speed and ease of writing. I haven't heard about that type system trick. that sounds clever. what is it?
10:22:50 <dmwit> Whoa, you don't see a lot of white-on-black PDFs.
10:23:12 <chrisdone> haha
10:23:14 <dmwit> chrisdone: It uses phantom types to ensure that you can only put, e.g., block elements into other block elements.
10:23:51 <dmwit> The types of the various smart constructors are automatically generated from one of the xhtml specs (can't remember which one off the top of my head).
10:24:24 <chrisdone> dmwit: sure. I like that. I suggested this for blazehtml but the focus was on speed, demanding benchmarks, etc. I'm more interested in this type of correctness effort than speed
10:24:53 <dmwit> Well, it does seem to be at least an eventual goal, based on page two of the presentation.
10:25:01 <chrisdone> sure
10:25:36 <dmwit> breakfaaaaast
10:25:52 <pastorn> @where BlazeHTML
10:25:52 <lambdabot> I know nothing about blazehtml.
10:25:59 <pastorn> dmwit, chrisdone ^^
10:26:04 <chrisdone> pastorn: http://github.com/jaspervdj/BlazeHtml
10:26:09 <eb4890> @go blazehtml
10:26:09 <lambdabot> Maybe you meant: google googleit do
10:26:17 <eb4890> @google blazehtml
10:26:18 <lambdabot> http://github.com/jaspervdj/BlazeHtml
10:26:18 <lambdabot> Title: jaspervdj's BlazeHtml at master - GitHub
10:27:03 <dmwit> @. where+ google blazehtml
10:27:04 <DigitalKiwi> i read that 'is faster' before seeing the github and backtracking
10:27:04 <lambdabot> Okay.
10:27:21 <DigitalKiwi> read as*
10:27:26 <dmwit> Hm, did that actually work?
10:27:30 <dmwit> ?where blazehtml
10:27:30 <lambdabot> I know nothing about blazehtml.
10:27:43 <dmwit> ?where Title:
10:27:43 <lambdabot> I know nothing about title:.
10:27:45 <dmwit> ?where Title
10:27:45 <lambdabot> I know nothing about title.
10:27:57 <eb4890> ?where haskell
10:27:58 <lambdabot> http://haskell.org
10:28:05 <dmwit> ?where http://github.com/jaspervdj/BlazeHtml
10:28:06 <lambdabot> Title: jaspervdj's BlazeHtml at master - GitHub
10:28:08 <dmwit> heh
10:28:14 <pastorn> @faq Can haskell know everything?
10:28:14 <lambdabot> The answer is: Yes! Haskell can do that.
10:28:20 <dmwit> ?where- http://github.com/jaspervdj/BlazeHtml
10:28:20 <lambdabot> Maybe you meant: where where+
10:28:28 <dmwit> ?where+ http://github.com/jaspervdj/BlazeHtml
10:28:28 <lambdabot> Done.
10:28:38 <pastorn> @where BlazeHtml
10:28:38 <lambdabot> I know nothing about blazehtml.
10:28:42 <dmwit> ?where+ BlazeHtml http://github.com/jaspervdj/BlazeHtml
10:28:42 <lambdabot> I will never forget.
10:28:46 <pastorn> hehe
10:28:47 <dmwit> Sorry for the minor flood.
10:28:54 <pastorn> NEVAR FORGET
10:29:23 <roconnor> what are the arrow laws?
10:30:01 <dmwit> ?google wadler arrow laws
10:30:03 <lambdabot> http://homepages.inf.ed.ac.uk/wadler/papers/arrows-and-idioms/arrows-and-idioms.pdf
10:30:03 <lambdabot> Title: Idioms are oblivious, arrows are meticulous, monads are promiscuous
10:30:22 <chrisdone> heheh
10:30:42 <dmwit> Fig 4, Page 8 for the original, long version
10:30:51 <roconnor> I want a short html version :)
10:30:52 <dmwit> Fig 5, Page 9 for the better version
10:31:12 <roconnor> all the haskell pages try to avoid telling me what the laws are
10:31:24 <dmwit> Which reminds me, there really ought to be a library providing Wadler's syntax with quasiquoting.
10:31:45 <dmwit> roconnor: Copy the laws to one of the Haskell pages! Be a creator! gogogo! =D
10:32:51 <clanehin> I would swear I read somewhere that there are ~27 arrow laws.
10:33:12 <dmwit> Nah, only nine, one of which is redundant.
10:33:21 <dmwit> Or five, if you follow the Cult of Wadler.
10:33:54 <clanehin> If I had known that, I would have actually bothered to learn them along time ago.
10:34:12 <dmwit> clanehin: Learn them now. They're pretty easy. =)
10:35:10 <dmwit> "The Arrow Calculus" by Wadler (the one I was really looking for with my Google search above) is good, as is
10:35:33 <siracusa> Is there a copy of the WASH manual somewhere? http://www.informatik.uni-freiburg.de/~thiemann/WASH/ is not reachable for me
10:35:51 <dmwit> mmm, I think "Arrows and Computation" by Ross Paterson is the other one I really liked.
10:36:29 <ddarius> The original Arrow class wasn't well-factored.
10:36:56 <dmwit> Yeah, it was "Arrows and Computation".
10:37:06 <dmwit> ddarius: Oh? I guess I'm not too surprised.
10:37:16 <dmwit> It's hard to get these things right until you've used them a bit.
10:39:40 <dmwit> siracusa: Huh, still?
10:39:44 <dmwit> I can get to it fine.
10:40:02 <dmwit> siracusa: What if you try with their IP address instead of their domain? (132.230.167.230)
10:40:05 <siracusa> dmwit: Ah, now it works
10:50:46 <EvanR> lets see
10:51:02 <fax> phren0logy cool name
10:51:13 <EvanR> is it possible to use unfold instead of a typical game loop to lazy generate the list of game states
10:51:36 <phren0logy> fax: thanks! I was doing some fMRI work, so I went with it
10:51:48 <EvanR> one complication is user input
10:54:01 <fax> phren0logy woah coool
11:01:29 <EvanR> @src unfold
11:01:29 <lambdabot> Source not found. You untyped fool!
11:02:09 <benmachine> @src unfoldr
11:02:10 <lambdabot> unfoldr f b  = case f b of
11:02:10 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
11:02:10 <lambdabot>    Nothing        -> []
11:02:35 <benmachine> unfold kind of makes more sense as a name
11:02:45 <benmachine> it's not like there's a sensible unfoldl
11:03:00 <benmachine> (...that I can think of, anyway)
11:03:14 <EvanR> unfoldl would build the list rightward?
11:04:00 <Botje> unfoldr already does that.
11:04:10 <Cale> There is a sensible unfoldl, but it's not very efficient on lists. foldl itself is sort of a funny function in that it treats the list as if it were a snoc list.
11:04:28 <EvanR> snoc?
11:04:30 <benmachine> well, I classed inefficient as non-sensible >_>
11:04:32 <MisterN> :t unfoldr
11:04:33 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
11:04:38 <MisterN> @src unfoldr
11:04:38 <lambdabot> unfoldr f b  = case f b of
11:04:38 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
11:04:38 <lambdabot>    Nothing        -> []
11:05:14 <MisterN> unfoldr only works on the Maybe monad with 2-tuples?
11:05:35 <benmachine> Maybe's monadness doesn't come into it
11:05:54 <benmachine> unfoldr takes a function that returns Maybe (a, b)
11:06:09 <MisterN> ah
11:06:14 <EvanR> Nothing means finish unfolding. otherwise a is the next value and b is the 'unaccumulator'
11:06:21 <benmachine> heh
11:06:28 <MisterN> ic
11:06:33 <benmachine> it's a bit like a simple state computation
11:07:11 <pikhq> Unaccumulator? I'd call it a decumulator or something.
11:07:15 <EvanR> so unfold seems like a game loop to me, except for user input :\
11:07:24 <Accidus> Can anyone give a hint as to how to show that the distributive law holds in any Cartesian closed category with coproducts? There are evident maps between Ax(B+C) <--> AxB + AxC, but I can't see how to show they are each other's inverses.
11:09:37 <ddarius> MisterN: You can take the two arguments of foldr (besides the list) and pack them into a function Maybe (a, b) -> b
11:10:47 <mm_freak> ok, something trickyâ€¦  i need to read from a handle in the style of hGetLine, but with a custom delimiter
11:11:02 <mm_freak> is there a direct way to do this or do i need to use concurrency/laziness?
11:11:21 <ddarius> :t \f -> foldr (\a b -> f (Just (a,b))) (f Nothing)
11:11:22 <dfkjjkfd> Accidus: in these kind of problems, the resulting composition often shares a universal property with identity, allowing you to conclude it is identity
11:11:22 <lambdabot> forall a b. (Maybe (a, b) -> b) -> [a] -> b
11:11:24 <EvanR> read one by one until you find the delimter
11:11:25 <benmachine> mm_freak: repeatedly hGetChar?
11:11:32 <ddarius> :t unfoldr
11:11:33 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
11:11:40 <benmachine> mm_freak: it's not as inefficient as it sounds, because of buffering
11:12:00 <EvanR> @src hGetLine
11:12:00 <lambdabot> Source not found. The more you drive -- the dumber you get.
11:12:52 <mm_freak> benmachine: hmm, are you sure?  the handle will most likely have NoBuffering and doing fgetc() on a handle in C was very slow
11:13:09 <EvanR> no, its not
11:13:13 <ddarius> Accidus: The quick way is simply to say left adjoints preserve coproducts, which gets the hard direction of the equivalence.  The other direction is easy.  To prove they are inverses, simply calculate.
11:13:46 <EvanR> your OS buffers the file i/o
11:13:57 <benmachine> mm_freak: well if it has NoBuffering then it won't buffer, I guess :x
11:14:25 <EvanR> you cant make it read one character at a time from the hard disk
11:14:36 <benmachine> says who?
11:14:43 <mm_freak> benmachine: say most harddisks
11:14:51 <mm_freak> they deliver in blocks of 512 bytes or something
11:14:53 <benmachine> fine :P
11:15:00 <EvanR> the harddisk plus the OS
11:15:03 <EvanR> plus to C lib
11:15:08 <EvanR> or whatever ghc uses
11:15:17 <Accidus> What do you mean "directions"? If left adjoints preserve coproducts, then Ax(B+C) /is/ the coproduct of AxB and AxC, which means we're done.
11:15:27 <ddarius> Accidus: Indeed.
11:15:40 <ddarius> (Where "is" is "is isomorphic to")
11:15:51 <Accidus> ddarius, obviously...
11:16:08 <mm_freak> anyway, is this the best way to do it?  hGetLine uses something complicated using IORef and stuff
11:16:27 <mm_freak> i guess there is a reason why hGetLine doesn't just hGetChar one by one
11:16:31 <benmachine> hGetLine doesn't use IORef if it's unbuffered
11:16:55 <ddarius> However, if you want to prove that the specific function AxB + AxC -> Ax(B+C) that you can write in any category with products and coproducts is has an inverse, you need to calculate.
11:17:06 <DrTeggy> Today's HD controllers deliver 4K up to 64K blocks per read
11:17:15 <ddarius> Or if you just want a more concrete proof.
11:18:06 <mm_freak> well, one easy way to do it would be to "put back" the extra characters
11:18:30 <EvanR> mm_freak: ungetc and peeking is a common feature of stream apis
11:18:38 <mm_freak> i.e. read in blocks of 512 bytes, until the delimiter appears, then put back the rest
11:18:41 <EvanR> but hGetLine returns the new line
11:18:52 <mm_freak> yeah, an ungetc for haskell
11:18:54 <EvanR> mm_freak: ok, the os really does buffer for you
11:18:59 <EvanR> stop trying to write an OS
11:19:06 <mm_freak> i know it does
11:19:20 <benmachine> I think ungetc is only guaranteed up to one character though
11:19:24 <EvanR> yes
11:19:25 <SamB_XP> ... of course, syscalls aren't exactly free
11:19:39 <EvanR> but why do you want to put the delimeter back
11:19:45 <mm_freak> but again, fread()-ing a block of 512 bytes is much faster than doing 512 times fgetc()
11:19:53 <Accidus> Ah. I don't need to, for what I want to prove. But I am interested in doing so, now. The problem is that the calculation involves all 3 definitions: products, co-products and adjunctions, and I'm not too sure how they interplay. But if you say it's straightforward calculation, I'll give it some more tries.
11:19:54 <EvanR> no, its really not
11:19:56 <benmachine> much faster?
11:20:11 <benmachine> how does it compare with calling read() 512 times?
11:20:14 <mm_freak> by much faster i mean a factor with two or three digits, at least when i last tried that
11:20:18 <EvanR> your crap allocator is so slow
11:20:45 <ddarius> Accidus: If you already have a candidate function Ax(B+C) -> AxB + AxC then you just check if it composes with the aforementioned function to id and vice versa.
11:21:03 <mm_freak> i wrote a C lib once, where i needed to read lines from a socketâ€¦  first i had one buffer and filled it character by character looking for \r\n
11:21:29 <mm_freak> after i changed it to use two buffers, reading blocks instead of single bytes it was orders of magnitude faster
11:21:51 <Accidus> ddarius, Aye, but as I said, the functions involved the natural isomorphism of the adjunction, which was not that straightforward to work with. As I said, I'll give it another tri.
11:21:53 <Accidus> * try
11:22:27 <mm_freak> EvanR: i don't want to put the delimiter back, but the extra characters _after_ the delimiter
11:22:34 <benmachine> mm_freak: a socket? you don't use stdio for sockets do you?
11:22:43 <benmachine> I guess you could fdopen
11:22:43 <EvanR> mm_freak: so its not a single character delimeter
11:22:50 <mm_freak> benmachine: no, i didn't
11:22:57 <mm_freak> EvanR: in this case it is
11:22:59 <ddarius> The functions I'm talking about are just two arrows in the category, and since the category is cartesian closed, you can safely use lambda notation and normal equational reasoning as you would use in Haskell.
11:23:05 <EvanR> mm_freak: then what extra characters are you talking about
11:23:08 <benmachine> mm_freak: so you used system calls directly?
11:23:31 <ddarius> :t either (second Left) (second Right)
11:23:32 <lambdabot> forall b b1 d. Either (d, b) (d, b1) -> (d, Either b b1)
11:23:48 <mm_freak> EvanR: if the delimiter is ',' and i read "foo,bar,baz", then i would just put back "bar,baz"
11:24:16 <ddarius> :t \a -> either ((,) a) ((,) a)
11:24:16 <mm_freak> benmachine: either read or recv, i don't rememberâ€¦  it was a C library
11:24:17 <lambdabot> forall a a1. a -> Either a1 a1 -> (a, a1)
11:24:38 * hackagebot GPipe 1.2.1 - A functional graphics API for programmable GPUs  http://hackage.haskell.org/package/GPipe-1.2.1 (TobiasBexelius)
11:24:44 <benmachine> mm_freak: right, so that's OS-level but not application-level buffering
11:25:08 <mm_freak> i assumed OS-level buffering to be fast =)
11:25:23 <benmachine> it's fast but syscalls are (I've heard) inevitably expensive
11:25:25 <ddarius> :t \(a,bc) -> either ((,) a . Left) ((,) a . Right) bc
11:25:26 <lambdabot> forall t a b. (t, Either a b) -> (t, Either a b)
11:25:34 <SamB_XP> mm_freak: syscalls aren't though ;-)
11:25:48 <benmachine> calling fgetc 512 times will not do 512 syscalls
11:25:54 <mm_freak> SamB_XP: good point
11:25:56 <ddarius> :t \(a,bc) -> either (Left . (,) a) (Right . (,) a) bc
11:25:56 <lambdabot> forall t a b. (t, Either a b) -> Either (t, a) (t, b)
11:25:57 <benmachine> unless the handle is unbuffered
11:26:02 <benmachine> what was your question, again? :P
11:26:02 <ddarius> There we go.
11:26:06 <mm_freak> ok, now i see what you're telling me =)
11:26:41 <mm_freak> then just to be clear, doing hGetChar 512 times on a handle with NoBuffering won't do 512 syscalls, will it?
11:27:29 <benmachine> umm
11:27:37 <EvanR> mm_freak: read it one character at a time
11:27:51 <benmachine> pass
11:27:53 <benmachine> strace it :P
11:28:53 <EvanR> im confused why you want no buffering, and choose to buffer it yourself
11:29:15 <benmachine> NoBuffering I think is application-level
11:29:24 <mm_freak> EvanR: i want NoBuffering, not "no buffering", i.e. i want to read the data as soon as it's available
11:29:47 <benmachine> what kind of handle is this anyway
11:30:02 <benmachine> in my head NoBuffering is "no buffering"
11:30:14 <EvanR> this is the official explanation
11:30:20 <EvanR> http://www.haskell.org/onlinelibrary/io.html
11:30:28 <mm_freak> when i set LineBuffering or BlockBuffering, then i have to wait for full lines or full blocks, before i can handle the data
11:30:51 <EvanR> nobuffering: the next input item is read and returned. the hLookAhead operation implies that even a nobuffered handle may require a one character buffer
11:30:55 <mm_freak> this handle is an IRC connection, and the RFC 1459 specifies that _either_ '\r' or '\n' are accepted as line delimiters
11:31:11 <benmachine> oh, I thought it was \r\n
11:31:18 <EvanR> however nobuffering does not imply that the OS will not buffer
11:31:46 <mm_freak> nope, in IRC, lines "a\r\nb" = ["a", "", "b"]
11:31:48 <mreh> does anyone know how to do/simulate definite integrals in Yampa?
11:31:58 <EvanR> you cant stop the os from buffering network input or harddisk reads
11:32:10 <EvanR> nobuffering is just how haskell presents it to you
11:32:20 <benmachine> mm_freak: that doesn't sound right, blockbuffering should read as much as it can up to the blocksize, I thought
11:32:31 <mm_freak> EvanR: OS buffering is fine, and even application-level buffering would be fine, if it returned the data as soon as it's available
11:32:49 <jlouis> mm_freak: hmmm
11:32:51 <mm_freak> at least on stdin it will not do anything, until a full block has been read
11:32:53 <EvanR> ...
11:33:02 <EvanR> use no buffer. read one character at a time
11:33:13 <mm_freak> yeah
11:33:49 <mm_freak> well, in practical code i will likely use Data.ByteString.Lazy.Char8.hGetContents
11:34:01 <EvanR> mm_freak: not relateed to this, there is hLookAhead, which is suitable for cases where ungetc is needed
11:34:13 <mm_freak> but i'd like to include a convenience function 'hGetMessage'
11:34:26 <benmachine> lazy IO is the devil :O
11:34:34 <jlouis> ah, I see where I avoid the problem now
11:34:35 <EvanR> people will tell you not to use hGetContents
11:34:38 <EvanR> so i dont  ;)
11:34:45 <mm_freak> hehe
11:34:50 <ddarius> mreh: I believe you use something like initially to insert a delay and then make a feedback loop that implements one numerical integration scheme or another.  You may also want to read this paper: http://www.cs.yale.edu/homes/hl293/download/icfp066-liu.pdf
11:34:52 <mm_freak> but it's so damn convenient =)
11:34:58 <fax> > let even = [2,4..] ; odd = (1+) . even in 2 * (product . take 40 $ zipWith (/) even odd)
11:34:59 <lambdabot>   0.2776559878085855
11:35:03 <jcreigh> benmachine: lazy IO will be the devil, if it is ever evaluated. :)
11:35:07 <EvanR> mm_freak: well in case of error it will occur in non IO code :(
11:35:20 <mm_freak> EvanR: error = end of string
11:35:21 <fax> > let square x = x*x ; even = [2,4..] ; odd = (1+) . even in 2 * (product . map square . take 40 $ zipWith (/) even odd)
11:35:22 <lambdabot>   3.8546423782980684e-2
11:35:30 <mm_freak> hGetContents silently ignores errors
11:35:30 <EvanR> mm_freak: its IO, there are so many other sources of errors
11:35:44 <mm_freak> which is the bad thing about it, actually
11:35:56 <mm_freak> i could implement a better hGetContents, though
11:36:03 <EvanR> file was deleted, filesystem went poof, connection closed, etc
11:36:09 <EvanR> mm_freak: oh? :)
11:36:52 <mm_freak> yeah, the same as hGetContents but maybe with an IORef or SampleVar, where it tracks its status
11:36:57 <mm_freak> so i could catch I/O errors
11:37:06 <benmachine> but then what would you do with them
11:37:32 <benmachine> oh, return the IORef as well?
11:38:12 <mm_freak> hGetContentsNG :: Handle -> (ByteString, IORef HGetContentsStatus)
11:39:17 <fax> > let c i = (i+1)/i * (i+1)/(i+2) : c (i+2) in (2*) . product . take 10000 $ c 1
11:39:18 <lambdabot>   3.1415141186818643
11:39:20 <mm_freak> well, in my case it would rather look like:
11:39:24 <mm_freak> hGetContentsNG :: Handle -> (ByteString, MVar HGetContentsStatus)
11:39:24 <jlouis> mm_freak: it screams that you should play with the iteratee module I think
11:39:45 <jlouis> iteratee package* even
11:39:57 <juhe> Hello people, release notes for ghc 6.12.1 mention that Data.Array.Diff was moved to its own package... But I coudn't find the package... Does anybody knows where should I look for it?
11:40:04 <mm_freak> jlouis: heard about it, but never bothered to look until now
11:40:16 <mm_freak> now that you indirectly recommend it =)
11:40:30 <jlouis> mm_freak: basically, it implicitly handles the buffer for you, more or less
11:40:32 <ddarius> @hackage failable-list
11:40:33 <lambdabot> http://hackage.haskell.org/package/failable-list
11:41:31 <ddarius> hGetContents :: IO (FailableList IOError Char)
11:42:00 <ddarius> + handle
11:43:44 <mm_freak> ddarius: i'm using ByteStrings
11:43:56 <mm_freak> jlouis: great, is there a tutorial?
11:44:25 <jlouis> mm_freak: I know of none, but there might be somewhere. It has quite the scary type class stack
11:44:58 <mm_freak> yeah, the haddock docs are a bit overwhelming on a first glance
11:45:31 <jlouis> mm_freak: you should also be aware that RFC1459 is to be taken lightly :) Most ircd's today doesn't follow it
11:45:47 <mm_freak> yes, but they follow it with regard to EOL =)
11:46:28 <mm_freak> and i want to write correct code nevertheless
11:46:47 <mm_freak> (as long as correct code doesn't fail in practice, as it is the case with numerous NNTP implementations)
11:46:56 <fax> > sum . take 1000 $ (log . [1..])
11:46:57 <lambdabot>   5912.128178488171
11:47:07 <SamB_XP> whoa, I like the 404 page on stackoverflow ;-)
11:47:30 <fax> > exp (sum . take 1000 $ (log . [1..]))^2/2
11:47:31 <lambdabot>   Infinity
11:47:33 <serhalp> Hello.  Quick question: can anyone point me in the direction of an example of any nature that makes use of Data.ByteString?  I can't seem to find anything (barely).
11:47:37 <jlouis> mm_freak: http://okmij.org/ftp/Streams.html seems rather good
11:47:45 <SamB_XP> it appears to be a polyglot
11:48:08 <jlouis> serhalp: what kind of use?
11:48:21 <cebewee> ok, I got my decoding function reasonably fast.
11:48:22 <SamB_XP> that supports between at least C and bf
11:48:39 <cebewee> but this is far from being beautiful ;)
11:48:58 <serhalp> jlouis: I just need to write to a binary file.
11:49:44 <Darkone> Got an OS question here.
11:50:09 <Darkone> I used a utility to split my partition, and then used the free space to install windows 7
11:50:13 <jlouis> serhalp: Data.ByteString.writeFile
11:50:38 <Darkone> Now that I'm ready to combine both partitions, Disk Management reports that D: (old drive) is the primary, and C: is a logical??
11:50:47 <jlouis> serhalp: there are also a Handle-interface, should you have hooked a handle when you fished in the pond
11:50:52 <Darkone> Yet win7 is running off C:
11:51:03 <Darkone> My question is: What could I do?
11:51:13 <ddarius> Darkone: This isn't an operating system help channel.
11:51:19 <Darkone> Just wipe D:, and will C: autoamtically be allocated as primary?
11:51:30 <Darkone> ddarius, I know, I'm just asking here
11:51:32 <kevinulin> in a program should there be any effort made to keep the number of threads small, or is having a program which may have 1000 threads operating at one time fine?
11:51:47 <jlouis> Darkone: try somewhere else, really :)
11:52:02 <benmachine> 1000 Haskell threads is well within the realms of possibility
11:52:15 <jlouis> kevinulin: forkIO'ed threads is no problem... combinatorrent usually have some 500-1000 while running, no problem
11:52:25 <kevinulin> great
11:52:52 <Ke> so does ghc'd haskell create a number of worker threads equal to the number of cpus?
11:53:08 <jlouis> Ke: yes, given the right RTS options
11:53:24 <Ke> like actual OS threds, not the virtual threads
11:53:24 <mm_freak> kevinulin: i already wrote programs having hundrets of thousands of threads each communicating to each other without problems
11:53:25 <jlouis> Ke: in fact, a bit more, so it can do IO
11:53:31 <ddarius> kevinulin: Make a fork bomb and see how many threads you can make.
11:53:33 <mm_freak> s/hundret/hundred/
11:55:16 <mm_freak> jlouis: thank you, i'll have a look at it later
11:55:36 <jlouis> mm_freak: do tell me the outcome. I plan on using it at some point
11:55:44 <mm_freak> i will
11:57:07 <serhalp> jlouis: thanks; turns out my problem was actually just being unfamiliar with Haskell conventions: the type is called ByteString within the data.ByteString(.Lazy) module -- wouldn't have guessed that.
11:57:54 <EvanR> can you use any libraries you want from forkIO threads
11:57:55 <jlouis> serhalp: now you are not unfamiliar with that convention anymore :)
11:58:01 <EvanR> or are there restrictions
11:58:13 <benmachine> EvanR: some C libraries won't like it
11:58:29 <EvanR> and forkOS threads (that dont do forkIO) are different?
11:58:31 <serhalp> I realize I sound ignorant, but it's really a matter of thinking in Haskell.
11:58:42 <jlouis> most Haskell stuff doesn't care
11:59:01 <EvanR> then can you use any thread safe lib
11:59:04 <benmachine> serhalp: :browse and :info in GHCi are useful for these sorts of things
12:01:36 <jlouis> cml has some nasty abstraction leaks though
12:01:46 <jlouis> I am not sure I've found them all yet :)
12:02:01 <SamB_XP> EvanR: the difference is basically that anything that uses TLS, or otherwise binds objects to specific threads, will basically need a forkOS'd thread ...
12:02:39 <SamB_XP> and you'd better keep using it from that same thread
12:04:30 <EvanR> ok
12:04:51 <SamB_XP> e.g. OpenGL uses TLS
12:05:12 <EvanR> i wonder if HDBC, ADNS, Network module, and SMTP.Client are like this
12:05:17 <SamB_XP> win32 associates every window with the thread in which it was created
12:05:45 <SamB_XP> Network really better not be
12:06:01 <balor> I'm trying to install happstack-data and get the following http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24449#a24449  Am I doing something stupid?
12:06:14 <SamB_XP> there's no real excuse for that in pure-haskell, non-GUI, non-crazy-C-library-related code
12:06:23 <EvanR> yeah, i hope so too ;)
12:06:42 <benmachine> I don't think it's even possible to make TLS from pure haskell
12:06:55 <EvanR> whats TLS
12:07:04 <ddarius> Thread Local Storage
12:07:14 <lpjhjdh> so would gcjni be the current best way of exposing java to haskell?
12:07:20 <benmachine> i.e. some memory specific to a single thread
12:07:52 <balor> Would there be any point to TLS in a pure-functional language?
12:07:56 <SamB_XP> you, Haskell isn't big on state variables to start with, nevermind creating a state variable which will hold a different value in each thread ;-P
12:08:04 <SamB_XP> er. s/you/yeah/
12:11:50 <int-e> balor: that error looks like you have to reinstall syb-with-class-0.6. and possibly others. ghc-pkg check will tell you which ones.
12:12:17 <balor> hmmm....I'm running haskell-platform-2009.2.0.2-4, that sounds old
12:12:23 <balor> int-e: thanks...will do
12:12:28 <EvanR> whats the type class Enum, can the bot list operations on Enum types
12:12:33 <fax> > 2/(product . take 200 $ (map (/2) . tail $ iterate (sqrt . (2+)) 0))
12:12:35 <lambdabot>   3.141592653589794
12:12:44 <ddarius> @src Enum
12:12:44 <lambdabot> class  Enum a   where
12:12:44 <lambdabot>     succ                     :: a -> a
12:12:44 <lambdabot>     pred                     :: a -> a
12:12:44 <lambdabot>     toEnum                   :: Int -> a
12:12:44 <lambdabot>     fromEnum                 :: a -> Int
12:12:44 <benmachine> EvanR: use :info in ghci
12:12:46 <lambdabot> [3 @more lines]
12:13:33 <EvanR> ok
12:13:51 <benmachine> Enum is basically used to implement the [x .. y] stuff
12:14:16 <benmachine> > [False .. True]
12:14:17 <lambdabot>   [False,True]
12:14:22 <benmachine> but beware:
12:14:25 <benmachine> > [False..True]
12:14:26 <lambdabot>   A section must be enclosed in parentheses thus: (`False..` True)Not in scop...
12:14:51 <MisterN> > [False,]
12:14:52 <lambdabot>   <no location info>: parse error on input `]'
12:14:56 <MisterN> > [False..]
12:14:57 <lambdabot>   <no location info>: parse error on input `]'
12:15:05 <benmachine> > [False ..]
12:15:06 <lambdabot>   [False,True]
12:15:16 <MisterN> > [False, False ..]
12:15:17 <lambdabot>   [False,False,False,False,False,False,False,False,False,False,False,False,Fa...
12:15:42 <benmachine> this is all thanks to whoever had the genius idea of making . the qualifier for modules
12:15:54 <benmachine> when it was already a valid operator name
12:16:18 <edwardk> benmachine: there is a shortage of other symbols available =/
12:16:26 <benmachine> mm
12:16:32 <benmachine> but still
12:16:42 <benmachine> . has got to be one of the most common in haskell
12:17:03 <benmachine> #?
12:17:15 <edwardk> well, if you think about it all of the other common module separating symbols are taken, :: for instance
12:17:21 <int-e> > (#)
12:17:22 <lambdabot>   <no location info>: parse error on input `)'
12:17:25 <edwardk> Data#Foo#Bar is particularly hideous
12:17:51 <lpjhjdh> they should just use unicode
12:17:54 <int-e> # is supposed to be a legal operator too.
12:18:18 <ddarius> > ( # )
12:18:19 <lambdabot>   Not in scope: `#'
12:18:26 <benmachine> int-e: yeah but at least it's not the most common one ever
12:18:45 <benmachine> edwardk: it is rather
12:18:48 <benmachine> but, oh well
12:18:52 <MisterN> benmachine: clearly they should have used \ as the module separator
12:18:54 <MisterN> like php
12:19:10 <jlouis> MisterN: our lambda!
12:19:19 <benmachine> hmm
12:19:22 <edwardk> i'm sitting here with the privilege of getting specify a toy language with no backwards compatibility issues, and I find in the interest of legibility I wind up using significant whitespace (though, in my case, on : not .)
12:19:44 <MisterN> or better yet, get rid of the fake lexer parser dichotomy :)
12:19:54 <MisterN> and make whitespace optional
12:20:00 <int-e> edwardk: how are you treating unary minus?
12:20:05 <edwardk> jlouis: meh, just give up on being able to parse it with bounded lookahead, and you can eliminate the \ and just use the ->
12:20:15 <fax> infinity! = sqrt(2*pi)
12:20:25 <edwardk> int-e: significant whitespace after the - ;)
12:20:35 <fax> how can I derive Wallis product from it
12:20:43 <edwardk> (- x) as oposed to -x.
12:20:48 <int-e> edwardk: sounds reasonable to me
12:20:49 <edwardk> er opposed
12:21:24 <int-e> so you can write f -1 0 1
12:21:29 <edwardk> int-e: yeah
12:22:09 <edwardk> i use significant whitespace on member selection using . as well to determine fixity
12:22:45 <kevinulin> is Control.Concurrent.STM slower than Control.Concurrent w/ MVars? (in a case of 1000+ threads)
12:23:03 <edwardk> foo.bar baz.quux quaffle   vs foo.bar baz .quux quaffle  -- makes the difference between foo.bar (baz.quux) quaffle and (foo.bar baz).quux quaffle
12:23:38 <benmachine> kevinulin: I think it depends on your use case
12:23:47 <edwardk> with the grammar designed so that i can choose to allow an isolated . to be function composition if i really want the confusion
12:24:00 <lament> edwardk: mm i can see how that would be a huge, huge pain, specifically debugging
12:24:04 <fax> > sqrt . sqrt . (120 *) . sum $ do [ 1/(m*m*n*n) | n <- [1..150], m <- [1..n-1] ]
12:24:05 <lambdabot>   3.1309854183751358
12:24:08 <fax> = PI lol
12:24:08 <benmachine> kevinulin: like, if you only have one variable then STM is going to retry a lot and that might not be pleasant
12:24:09 <Igloo> edwardk: SoC trac should work now
12:24:13 <ddarius> kevinulin: STM is optimistic and thus performs poorly in cases of high contention.
12:24:20 <edwardk> Igloo: you, sir, are awesome =)
12:24:29 <edwardk> what wound up being the problem?
12:24:50 <Igloo> apache and trac didn't agree on where the htpasswd file was
12:24:58 <jlouis> heh
12:24:59 <edwardk> ah
12:25:27 <kevinulin> so in general, stm is slower if the value being passed between two threads is accessed often?
12:25:43 <edwardk> lament: its not a perfect solution, but it does let you quickly select a member without a bunch of parens
12:26:29 <jlouis> kevinulin: if many threads want to modify the same TVar in an atomically-section, they will have to retry a lot before being given permission
12:27:07 <jlouis> if there are relatively few contenders, I guess it will be quite fast
12:27:37 <kevinulin> i see, I guess i will start with stm
12:27:39 <fax> anyone good at math
12:27:41 <fax> ?? help me :D
12:27:42 <lambdabot>  help me :D
12:27:45 <fax> woops
12:27:49 <edwardk> fax: nope, no one here likes math
12:27:55 <jlouis> kevinulin: stm is somewhat harder to deadlock
12:28:00 <benmachine> we're all artists at heart
12:28:01 <clanehin> kevinulin: STM is better when you have a lot of different variables that get accessed in complex ways, and you need ease of implementation and reliability.  If you can do it just as easily with MVars, you probably want to do that.
12:28:18 <ddarius> STM should be impossible to deadlock.  Not impossible to livelock though.
12:28:22 <edwardk> jlouis: technically it is impossible to deadlock. easy to livelock ;)
12:28:27 <edwardk> ddarius =)
12:28:36 <fax> it says:  Ex. If infinity! = sqrt(2*pi) deduce Wallis formula (pi/2 = 2/1 2/3 4/3 4/5 6/5 ...)
12:29:00 <fax> so I strated with (1*2*3*4*5*6*...)^2/2 = pi..
12:29:04 <fax> but then what?
12:29:19 <kevinulin> I guess i can mix and match, use stm for everthing up to the multiplexing and then communicate between main threads with MVar
12:29:33 <benmachine> fax: if it were me I'd start with the answer and un-deduce it :P
12:30:00 <fax> how?
12:30:19 <benmachine> fax: on the numerator you have 2 * 2 * 4 * 4 * 6 * 6 * ... right?
12:30:24 <fax> yeah
12:30:24 <mercury^> fax: I don't understand your question.
12:30:34 <mercury^> Ex. If infinity! = sqrt(2*pi) -- what does this mean?
12:30:39 <fax> mercury^ It is asking to turn one equation into the other
12:30:43 <fax> ! is factorial
12:30:48 <benmachine> fax: can you write that in terms of factorials
12:31:15 <benmachine> mercury^: infinity! is a bit ridiculous but maybe it works anyway?
12:31:25 <fax> benmachine: hm it's double factorial squared.. but that's not really 'in terms of factorial' -- because it's just a different function
12:31:26 <benmachine> it sounds like a silly question to me
12:31:31 <mercury^> I have no idea in what way that equation is supposed to make sense.
12:31:41 <xerox> fax: where does the exercise come from?
12:31:55 <fax> it's this note someone gave me
12:32:08 <benmachine> fax: double factorial can be written in terms of factorial
12:32:34 <benmachine> although you are going to need something just as silly as infinity!
12:32:44 <fax> ooh
12:32:45 <benmachine> (in this case)
12:33:18 <fax> benmachine: You are right -- (2n)!! = 2^n * n!,  2^infinity = 2*2*2*2*2*2*.. -- I know how to do it now :D
12:33:31 <benmachine> fax: it's still a ridiculous question, though :P
12:33:39 <xerox> I agree with ben
12:34:46 <fax> > let doubleFactorial n = product . nub . map (`div` 2) $ [1..n] in (doubleFactorial 6, 2^6 * product [1..6])
12:34:48 <lambdabot>   (0,46080)
12:34:51 <fax> what :|
12:34:57 <benmachine> whoops
12:34:58 <fax> > let doubleFactorial n = product . nub . map (`div` 2) $ [2..n] in (doubleFactorial 6, 2^6 * product [1..6])
12:34:59 <lambdabot>   (6,46080)
12:35:06 <fax> well it's roughly equal ?
12:35:09 <sbahra> :t nub
12:35:11 * benmachine lols
12:35:12 <lambdabot> forall a. (Eq a) => [a] -> [a]
12:35:37 <fax> > nub . map (`div` 2) $ [2..6]
12:35:38 <lambdabot>   [1,2,3]
12:35:50 <fax> > let doubleFactorial n = product . map (*2) . nub . map (`div` 2) $ [2..n] in (doubleFactorial 6, 2^6 * product [1..6])
12:35:50 <benmachine> > let doubleFactorial n = product [2,4.. 2 * n] in (doubleFactorial 6, 2^6 * product [1..6])
12:35:51 <lambdabot>   (48,46080)
12:35:51 <lambdabot>   (46080,46080)
12:35:58 <fax> ;D
12:35:59 <fax> one of us got it
12:36:03 <mercury^> Maybe the book tries to suggest that infinity! = sqrt(2pi). In that case: Your mom's fat. Derive 1 = 1.
12:36:07 <benmachine> one of me got it
12:36:12 <fax> mercury what lol
12:36:36 <benmachine> mercury^: maybe it's intended to illustrate that infinity is strange?
12:36:58 <mercury^> By deriving a correct formula?
12:37:07 <benmachine> pass
12:38:29 <ddarius> I think it's just a riddle.
12:38:54 <Remy_> how come the instance for Functor (ErrorT e m) has Monad m as constraint?
12:38:58 <Remy_> it could have just been Functor m
12:39:06 <Remy_> and why isn't Functor a superclass of Monad ?
12:39:30 <benmachine> Remy_: fair question
12:39:40 <mercury^> Because Haskell has legacy as a constraint.
12:39:51 * fax wonders how to get 1*3*5*6*...
12:39:53 <benmachine> I think the thing with ErrorT is because no-one would really use ErrorT with anything that was not a monad
12:39:54 <fax> oops that's wrong
12:39:56 <fax> nevermind
12:39:56 <ddarius> mercury^: Functor was a super class of Monad in Gofer.
12:40:05 <fax> how do you define double factorial in haskell?
12:40:19 <benmachine> fax: depends what you mean by double factorial
12:40:49 <benmachine> f(n) = the product of even numbers from 2 to n? the product of even numbers from 2 to 2n?
12:40:55 <fax> hm
12:41:02 <benmachine> either case is pretty easy with [a,b .. c] notation
12:41:46 <Darkone> http://mathworld.wolfram.com/DoubleFactorial.html  @ benmachine
12:42:17 <Darkone> I can't read any of that ;P
12:42:19 <benmachine> oh right
12:42:39 <benmachine> that is silly
12:42:52 <mercury^> Implementing factorial n as product [1..n] is not very efficient though.
12:42:53 <Darkone> "A function related to the factorial is the product of all odd values up to some odd positive integer n. It is often called double factorial (even though it only involves about half the factors of the ordinary factorial, and its value therefore closer to the square root of the factorial),"
12:43:04 <fax> mercury what'sthe efficent way?
12:43:07 <Darkone> From wikipedia.
12:43:33 <mercury^> fax: gmp has a much more efficient algorithm for it.
12:43:39 <Darkone> "For example, 9!! = 1 × 3 × 5 × 7 × 9 = 945."
12:43:40 <mercury^> It's described in the docs.
12:44:08 <ddarius> I'd probably use the definitions near the bottom of that page: dF n | even n = 2^n * n! | otherwise = (2n+1)! / dF (n-1)
12:44:18 <Darkone> mercury^, recursive fac(n-1)?
12:44:23 <Veinor> what is the efficient way?
12:44:26 <ddarius> Except that you'll probably want to fuse the multiplications.
12:44:28 <mercury^> fax: basically it removes powers of two first, then groups the remaining terms by multiplicity.
12:44:30 <Darkone> I'm very new to haskell, just wondering/taking a stab
12:45:01 <Darkone> Also, ddarius, wish me luck :V
12:45:18 <Darkone> I just tried other help, got told to use easyBCD to change the boot drive.
12:45:27 <mercury^> I think it is not possible to call the gmp routine on Integer though.
12:46:11 <Darkone> Time to see if it boots! Wheee this is like... oh what's it called again? Russian Roulette? with 5 loaded barrels :V
12:50:30 <Darkone> *click!* yaayy not dead yet :V
12:53:32 <humasect> 666 users
13:09:02 <misk20> why prelude define product as "foldl (*) 1" is foldl some way efficient then "productNum (x:xs) = x * productNum xs" or just its short.
13:09:14 <xerox> it's short
13:09:33 <misk20> thanks
13:11:05 <Darkone> xerox, foldl is actually just something like foldl f (x:xs) = f x $ foldl f xs, right?
13:11:11 <xerox> ?src foldl
13:11:11 <lambdabot> foldl f z []     = z
13:11:12 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
13:11:24 <Darkone> D'oh
13:11:34 <Darkone> Forgot z :X
13:11:37 <ddarius> misk20's definition corresponds to foldr (*) 1
13:11:38 <Darkone> Still learning :V
13:11:53 <opqdonut> misk20: using foldl to express that sort of recursion allows for optimizations down the road
13:12:00 <opqdonut> for example rewrite rules and stream fusion
13:12:13 <opqdonut> but I guess brevity is the primary reason :)
13:12:43 <xerox> We're on a road to nowhere / come on inside
13:13:22 <misk20> gr8, thx
13:13:42 <fax> I can't get rid of these 2^n terms
13:14:07 <watermind> Types constructors are basically Products, Coproducts and Exponentials. Prods and coprods are quite different from exponentials in the sence that they return types of the same order
13:14:10 <xerox> stop that and do some exercises whose text make sense.
13:14:17 <watermind> is there a name for these constructors?
13:14:21 <watermind> like prods and coprods
13:14:27 <Darkone> xerox, opqdonut, also from what both learn you a haskell and the other book say, it allows for easy recognition.
13:14:37 <watermind> as opposed to exponentials which increase the order of the type?
13:14:41 <opqdonut> that too
13:14:54 <Darkone> That is, "foldl something something" is easier to understand and recognize than a custom recursive function :X
13:14:57 <opqdonut> at some point. that becomes the "natural" way to express it
13:14:59 <opqdonut> yeh
13:15:14 <Darkone> Haskell doesn't really have any overhead on functions, because of the way it works, does it?
13:15:37 <opqdonut> in that case, no, not really
13:15:52 <SamB_XP> I'm gonna tell you what they told Ken: No!
13:16:28 <fax> Darkone: I don't know what overhead means but it can't just compute everything instantly
13:16:34 <Darkone> Well in the case of myfunction ... = foldl ... it's technically just a... wrapper? for foldl
13:16:38 <misk20> ?src foldr
13:16:38 <lambdabot> foldr f z []     = z
13:16:38 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
13:16:50 <cads> @hoogle Ord a => (a,a) -> (a,a)
13:16:50 <lambdabot> Data.Graph.Inductive.Query.Monad mapSnd :: (a -> b) -> (c, a) -> (c, b)
13:16:51 <lambdabot> Data.Graph.Inductive.Query.Monad mapFst :: (a -> b) -> (a, c) -> (b, c)
13:16:51 <lambdabot> Data.Graph.Inductive.NodeMap run_ :: (DynGraph g, Ord a) => g a b -> NodeMapM a b g r -> g a b
13:17:02 <SamB_XP> actually, using library functions of this sort often has negative overhead ;-)
13:17:05 <zygoloid> lim {n->inf} n! = sqrt(2*pi) => False => Wallis' formula. Do I win?
13:17:08 <Darkone> fax, from my limited knowledge, in C++ and especially python, you incur some processor overhead for each function call.
13:17:14 <xerox> > (foldl f z [a,b,c], foldr f z [a,b,c])
13:17:15 <lambdabot>   (f (f (f z a) b) c,f a (f b (f c z)))
13:17:21 <Darkone> Meaning add(1, 2) is slower than 1 + 2
13:17:27 <jlouis> Darkone: false
13:17:36 <Darkone> jlouis, it is?
13:17:44 <cads> :t \(a,b) -> if a <= b then (a,b) else (b,a)
13:17:45 <lambdabot> forall t. (Ord t) => (t, t) -> (t, t)
13:17:57 <Darkone> I'm not sure about C++, but I was pretty sure python had some overhead with it.
13:17:59 <jlouis> Darkone: On a modern CPU a function call is much cheaper than what you would think
13:18:06 <Darkone> Ahhh.
13:18:06 <fax> zygoloid I don't think so :P
13:18:08 <SamB_XP> it is easier to teach the compiler to do magic with code that uses library combinators ;-)
13:18:14 <Darkone> Cheaper, but it still costs, right? :P
13:18:19 <jlouis> Darkone: apart from that, there is inlining
13:18:25 <Darkone> Yea, that as well.
13:18:28 <idnar> Darkone: addition also costs
13:18:31 <SamB_XP> Python doesn't use CPU-level calls at all, though, so yeah
13:18:40 <Darkone> Ahh.
13:18:50 <cads> Darkone, you might be thinking virtual functions from C++?
13:18:51 <idnar> SamB_XP: Python is a language, it doesn't use anything ;)
13:18:56 <fax> > log(2)+log(-1/2)/(0:+1)
13:18:57 <lambdabot>   (-2.4484454730298477) :+ 0.6931471805599453
13:19:03 <Darkone> I'm going to pretend I understood that more than very slightly, for everyone's benefit, SamB_XP :P
13:19:07 <fax> huh
13:19:07 <SamB_XP> cads: which they say are also quite fast lately
13:19:13 <idnar> SamB_XP: an implementation of Python might use them
13:19:37 <SamB_XP> idnar: well, it would need to be very good at mindreading to get anywhere, wouldn't it ?
13:19:43 <SamB_XP> or, well, JIT
13:19:50 <cads> SamB_XP, that's neat :)
13:19:52 <SamB_XP> but I assume he meant CPython
13:19:53 <zygoloid> aiui jython uses jvm function calls, which jit to cpu CALLs. but i could be wrong :)
13:19:58 <fax> > log 10
13:19:59 <lambdabot>   2.302585092994046
13:20:03 <jao> where can i learn about CPU-level function calls?
13:20:07 <jlouis> Darkone: interestingly, modern CPUs have some things which are made for the sole purpose of bringing down call overhead. For instance, they keep a stack of return addresses
13:20:09 <Darkone> Well, this conversation shot over my head fast.
13:20:10 <idnar> SamB_XP: I think just about all of the non-CPython implementations have some kind of JIT going on
13:20:12 <zygoloid> and i think psyco does too
13:20:19 <xerox> jao: on the intel developer manuals
13:20:26 <jlouis> so they can speculate on the return address in the instruction fetch stage
13:20:40 <SamB_XP> zygoloid: that is kinda what psyco does, yes ;-P
13:20:45 <jao> xerox: thanks (although i was hoping for something less dry)
13:20:52 <zygoloid> SamB_XP: amongst other thinds :)
13:20:52 <Darkone> jlouis, makes sense given the... uhh.. propensity? of function calls.
13:20:57 <SamB_XP> jao: the optimization manual?
13:21:01 <Darkone> God my english is getting worse every year!
13:21:02 <xerox> jao: cpus are dry
13:21:18 <SamB_XP> or possibly volume 3?
13:21:33 <olsner> Darkone: in #haskell, it's not uncommon for that to happen (conversations shooting over your head) ... at least it wasn't category theory or zygohistomorphic prepromorphisms this time :P
13:21:37 <SamB_XP> zygoloid: psyco supports other things now ?
13:22:03 <zygoloid> SamB_XP: well, it generates code to do typechecks in order to allow its specialized versions to work
13:22:22 <cads> Can I use hoogle to find all the functions taking parameters that are in Ord?
13:22:23 <SamB_XP> zygoloid: that's part of the JITing
13:22:26 <zygoloid> it analyses the frequency with which functions are called at certain types to decide what to jit
13:22:29 <Darkone> olsner, hey, if we talk about something abstract like space warfare, at least I can generally keep up! :p
13:22:38 <cads> @hoogle Ord a
13:22:39 <lambdabot> Did you mean: :: Ord a /count=20
13:22:39 <lambdabot> module Data.Time.Calendar.OrdinalDate
13:22:39 <lambdabot> Network.Browser auPassword :: Authority -> String
13:22:42 <xerox> cads: there are no better 'swap' :)
13:23:06 <zygoloid> SamB_XP: it generates a lot more than just CALL insns, i think
13:23:33 <cads> xerox, I just don't like writing trivial utility functions if they're in a library somewhere :)
13:23:38 <SamB_XP> zygoloid: I meant that JIT is kinda what psyco does ;-P
13:23:58 <Darkone> Psyco was neat, but it only ran on 32 bit machines.
13:24:02 <olsner> unsafePerformIO launchPhotonTorpedoes -- space warfare in #haskell
13:24:11 <jlouis> I would think speculating on the type of a value would help a lot in Python: This has been an int for the last 3 traces, ...
13:24:55 <Darkone> olsner, more like potShotTargetFromTenMegametersWithAFreeElectronXRASER
13:24:57 <zygoloid> SamB_XP: ;) ok. i agree entirely
13:25:10 <SamB_XP> jlouis: it doesn't wait that long to do the specialization, aiui
13:25:13 <zygoloid> Darkone: i guess we have to wait for Unladen Swallow then :)
13:25:24 <Darkone> s/10 megameters/10,000 megameters
13:25:24 <Darkone> :V
13:25:34 <SamB_XP> I mean, once it detects a certain number of entries into a particular function/method
13:25:37 <jlouis> SamB_XP: that would make sense. You can probably just go with the first thing
13:25:41 <Darkone> Alternatively, 10 million kilometers.
13:25:48 <Darkone> Free electron lasers are scary :V
13:25:50 <SamB_XP> it just goes ahead and traces in
13:25:59 <jlouis> mm
13:26:01 <SamB_XP> and then it specializes for whatever values it sees
13:26:13 <jlouis> in the other news, my CML -> STM rewrite is away :)
13:26:24 <SamB_XP> I think this is all documented in the Self papers
13:26:45 <jlouis> SamB_XP: yep. Self is quite amazing in what it started
13:27:18 <fax> is infinity odd or even?
13:27:19 <SamB_XP> kinda sad that the Self guys evidently got pulled off Self onto JVM
13:27:25 <humasect> yea ..
13:27:30 <SamB_XP> > odd (1/0)
13:27:31 <lambdabot>   Ambiguous type variable `t' in the constraints:
13:27:31 <lambdabot>    `GHC.Real.Fractional t'
13:27:31 <lambdabot> ...
13:27:38 <humasect> Squeak is interesting also .
13:27:39 <SamB_XP> > odd (1/0 :: Double)
13:27:40 <lambdabot>   No instance for (GHC.Real.Integral GHC.Types.Double)
13:27:40 <lambdabot>    arising from a use ...
13:27:48 <SamB_XP> fax: no!
13:27:52 <humasect> self-modifying environment , and basically functional !
13:28:14 <SamB_XP> yeah, but I liked the object browser in Self better
13:28:39 <fax> I seem to have proved that pi/2 = 1/(2pi), which seems to imply that pi = 1
13:28:55 <humasect> there are quite a few for squeak, i had just downloaded (coincidentally) today the latest version and there are quite a few nice development tools in the package manager
13:28:58 <benmachine> fax: that's what you get for messing around with infinity
13:29:12 <SamB_XP> humasect: have you ever run Self?
13:29:14 <benmachine> fax: infinity is not a number
13:29:20 <SamB_XP> it's admittedly not easy on a PC
13:29:22 <edwardk> fax: infinity is not a value, it describes a process
13:29:32 <SamB_XP> and the performance is rather pathetic
13:29:36 <benmachine> so it is neither odd nor even, nor a valid input to factorial functions etc.
13:29:40 <SamB_XP> since the JIT magic doesn't really work
13:29:45 <humasect> SamB_XP: i remember trying on linux, but do not remember much further - saw videos and read papers, i do remember, though =)
13:29:47 <SamB_XP> aiui
13:30:02 <benmachine> edwardk: extended real number line? :P
13:30:10 <edwardk> benmachine: =)
13:30:18 <SamB_XP> I just like the "boxes and arrows" object browsing ;-)
13:30:27 <humasect> oh yes ! i remember =) very cool
13:30:33 <humasect> visual
13:30:43 <SamB_XP> it seems a lot more convenient than any of the class browsers I've seen in Squeak
13:30:52 <edwardk> speaking of object browsing, has anyone heard from mmorrow?
13:31:08 <humasect> my favorite part of squeak is 1) the software being developed and the software used to develop is the SAME thing !, and 2) simple syntax that has it closer to functional programming than say, other languages. =)
13:31:20 <humasect> and 3) can change the software while it is running, connected, etc - because of )1
13:31:48 <SamB_XP> humasect: I rather like those things too
13:32:06 <SamB_XP> although I think you're perhaps overstating 1 a *bit*
13:32:16 <humasect> i had set up a GHC environment with opengl that allowed me to do this at relatively similar ability
13:32:27 <humasect> i think understating ^_^
13:32:39 <SamB_XP> not ALL of the software you're developing is development tools ;-)
13:32:45 <humasect> because a lot of software can do it, only requires a different kind of thinking
13:33:10 <humasect> hehe, but you do see what i mean? it is like working on emacs within emacs. or making a video game while playing it, etc
13:33:15 <cads> Darkone, holy crap, free electron lasers can be tuned
13:33:22 <SamB_XP> I see what you mean
13:33:28 <humasect> (and not quite like making a movie about making a movie, though)
13:33:41 <SamB_XP> I just think the statement is a bit underqualified
13:34:01 <humasect> hmm what would qualify it ? i am not sure what it means underqualified
13:34:02 <SamB_XP> and yeah, there are games where they work on 'em like that, I believe
13:34:10 <humasect> yep =)
13:34:21 <SamB_XP> although I doubt all of the development tools are coded in FooScript
13:34:27 <humasect> restarting software over and over is *archaic*
13:34:38 <humasect> edit-debug-run cycle i think is the buzzword form
13:34:55 <MisterN> wow, darcs get on lambdabot is _slow_
13:34:57 <SamB_XP> edit-recompile-run, maybe
13:35:24 <humasect> squeak is fun while developing a server for eg., the code can change and the clients are still connected
13:35:40 <Darkone> cads, http://www.projectrho.com/rocket/rocket3x1.html#xray
13:35:42 <humasect> taking advantage of garbage collection references and whatnot
13:35:52 <SamB_XP> humasect: of course, you wouldn't want to do that on a production server
13:36:00 <humasect> (taking advantage of the "side-effects" that is)
13:36:04 <humasect> sure!
13:36:11 <xerox> MisterN: --partial ?
13:36:20 <SamB_XP> I mean, you wouldn't want to actually do your hacking on one
13:36:25 <jao> SamB_XP: it's not uncommon in CL-based production servers
13:36:39 <humasect> not actual development and hacking no, we have two servers for this
13:36:49 <MisterN> xerox: i didn't know about that. also that sounds like many good things missing
13:37:05 <xerox> MisterN: just history
13:37:28 <humasect> at least not while the architecture is being developed and whatnot. no one should live in a house that is being actively constructed, but!, one can live in a house that is being renovated. =)
13:37:38 <MisterN> xerox: it's also already done downloading
13:38:20 <Darkone> tl;dr 10MW ERC Pumped FEL will begin to vaporize a 30 cm wide spot of iron in less than .1 miliseconds
13:38:25 <SamB_XP> humasect: yeah, I figure that's what all those Squeak RCS tools are for ;-)
13:38:43 <MisterN> *sigh* Warning: CRC errors found. These are probably harmless but should be repaired.
13:38:44 <humasect> ah yeap=)
13:38:47 <Darkone> At 1 light hour, it will still destroy any unhardened electronics.
13:38:59 <fax> How can you show that 2^infinity = 1/4?
13:39:15 <humasect> anything infinite is infinite, isnt it ?
13:39:20 <fax> I know that 1+1+1+...+1=-1/2
13:39:32 <fax> so 2^infinity =??? (1+1+...+1)^2 = 1/4
13:39:53 <SamB_XP> I thought you could only prove that ...111111111.0 == -1
13:40:56 <xerox> fax: just stop with those and learn limits, please.
13:40:59 <SamB_XP> Darkone: how do you test something at that range ?
13:41:00 <fax> > log (1/4) / log 2
13:41:01 <lambdabot>   -2.0
13:41:40 <Darkone> SamB_XP, how do you mean? We don't have the capability to build an FEL that large in space yet, these are all just calculations based on current hardware.
13:41:47 <SamB_XP> Darkone: also, what's to stop the target dodging ?
13:41:47 <fax> 1-1+1-1...=1/2
13:41:52 <Darkone> Nothing!
13:41:53 <SamB_XP> Darkone: oh
13:41:55 <Darkone> Welcome to space :P
13:41:58 <fax> (1-1+1-1...)^2 = ?
13:42:13 <SamB_XP> you're talking about speculative engineering
13:42:18 <SamB_XP> or whatever they call it
13:42:28 <Darkone> Yes, same as any trim and proper military laser :P
13:42:42 <Darkone> The current ones for killing missiles aren't fast enough :V
13:42:57 <xerox> fax: there's a way to extend usual convergence to those series, but you have to understand standard convergence first
13:42:58 <SamB_XP> they only go at the speed of light, you mean ?
13:43:30 <Darkone> No, they don't deposit energy fast enough! They have to keep on target for a while. We just can't get them any nastier, and still fit them into the aircraft.
13:43:33 <Darkone> Well, I think.
13:43:38 <fax> 2^(-1/2)
13:43:40 <fax> > 2^(-1/2)
13:43:41 <lambdabot>   Ambiguous type variable `b' in the constraints:
13:43:41 <lambdabot>    `GHC.Real.Fractional b'
13:43:42 <lambdabot> ...
13:43:45 <fax> > 2**(-1/2)
13:43:46 <lambdabot>   0.7071067811865476
13:43:49 <fax> dammit
13:43:53 <Darkone> Might be that we can't keep it from vaping itself at any higher power.
13:44:04 <SamB_XP> Darkone: you mean, still fit the weight limits of the launch vehicles?
13:44:16 <Darkone> Yes, 747 isn't it?
13:44:20 <Darkone> For the airborne one.
13:44:30 <SamB_XP> oh, I was thinking sat-based ;-P
13:44:31 <fax> > (2**(-1/2))^2
13:44:32 <lambdabot>   0.5000000000000001
13:44:49 <fax> got it!
13:45:03 <Darkone> We understand the match behind bigger lasers, just don't have hardware quite good enough yet.
13:45:06 <Darkone> math*
13:45:42 <Darkone> Given a certain wavelength, certain optics, a certain power level, and a certain distance, we know the spot size at that distance, intensity, etc etc.
13:45:48 <benmachine> fax: 1-1+1-1... does not equal 1/2
13:46:08 <benmachine> fax: except for some very weird and probably inconsistent meanings of "..."
13:46:15 <SamB_XP> it's true
13:46:15 <trofi> @src liftIO
13:46:15 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
13:46:26 <SamB_XP> that just doesn't converge
13:46:43 <benmachine> fax: whoever is feeding you this nonsense about infinities, hit them with a real analysis textbook :P
13:46:51 <Darkone> benmachine, probably some silly concept that the pattern continues infinitely, and you have to average it.
13:46:56 <SamB_XP> what the heck does the backwards-arrow cursor mean?
13:47:01 <Darkone> And yes, do that.
13:47:19 <benmachine> Darkone: more likely adding it to itself term-by-term
13:47:22 <SamB_XP> benmachine: why a real analysis textbook?
13:47:32 <SamB_XP> wouldn't a complex analysis textbook hurt more?
13:47:35 <benmachine> heh
13:47:38 <benmachine> if you like
13:47:39 <Darkone> benmachine, before you start: I don't really know any higher level match :V
13:47:43 <Darkone> I was prodding a guess.
13:47:50 <benmachine> Darkone: well, both concepts are equally wrong :)
13:47:56 <Darkone> Yep.
13:48:01 <Darkone> I know that much :P
13:48:53 <SamB_XP> I didn't even take analysis and I know that limit diverges
13:49:00 <SamB_XP> (I only took calculus!)
13:49:09 <trofi> @src lift
13:49:09 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
13:49:55 <MisterN> trofi: do you mean lift from monad transformers?
13:50:21 <ddarius> Real analysis is boring.  Complex analysis is interesting and useful.
13:50:35 <benmachine> ddarius: nooo real analysis is fun :(
13:50:41 <benmachine> less fun than complex maybe
13:50:50 <benmachine> but I don't get to do complex analysis until next year
13:50:56 <xerox> (it doesn't diverge, it oscillates)
13:51:07 <SamB_XP> xerox: fine
13:51:10 <benmachine> we were taught diverge = not converge
13:51:22 <SamB_XP> terminology difference, I guess
13:51:59 <xerox> anyway, there is a way to extend the standard concept of convergence and get some interesting results: see ramanujan summation
13:52:00 <ddarius> benmachine: What can you do with real analysis that you couldn't do before?
13:52:10 <ddarius> Also, Abel summation.
13:52:41 <xerox> ah I see.
13:53:08 <benmachine> ddarius: er, all of it
13:53:17 <benmachine> it's not my fault if you did the same stuff twice :P
13:53:53 <ddarius> benmachine: So real analysis = calculus for you.  If so, calculus is definitely very useful and interesting.
13:54:12 <xerox> benmachine: in the complex context differentiable implies much stronger regularity (analytic), and soooo many interesting stuff follow from there
13:54:23 <ddarius> s/you./you?
13:54:26 <benmachine> xerox: yeah I don't doubt complex analysis is great
13:54:50 <ddarius> xerox: And Cauchy's residue theorem !
13:54:58 <benmachine> ddarius: hmm, real analysis for me was convergence of sequences/series, continuity, differentiability, and then Riemann integration
13:55:05 <fax> I proved it
13:55:24 <benmachine> fax: I get the feeling you're not really listening to us >_>
13:55:29 <xerox> basically complex-differentiable functions (of one complex variable) satisfy an elliptic partial differential equation (the riemann-cauchy condition)
13:55:49 <SamB_XP> benmachine: wherever did you get the idea that fax is not listening ?
13:55:49 <fax>  iwas working really hard on my bit of paper
13:55:58 <xerox> the ellipticity of the equations imply the (very strong) regularity of the solutions: they are analytic
13:56:00 <benmachine> SamB_XP: just a hunch
13:56:21 <xerox> nothing like that follows from asking that a function of real variables is differentiable :(
13:56:30 <ddarius> Geometric algebra allows a very nice generalization of complex analysis and a nice presentation of complex analysis, but the 2d case (i.e. the complex case) is unique.
13:56:35 <Darkone> Blargh
13:56:42 <Darkone> Takes so long to shrink partitions
13:56:43 <Darkone> :(
13:56:48 <fax> ddarius, I was wondering -- what about eisenstien analysis??
13:57:26 <fax> we have these 'Eisenstein integers' which are like trimesh complexes
13:57:42 <fax> http://en.wikipedia.org/wiki/File:Eisenstein_integer_lattice.png
13:57:50 <fax> so maybe they have a theory too
13:58:12 <fax> or maybe there is something special about complex numbers
13:58:15 <xerox> ..and as ddarius said, it can be shown that f(z) holomorphic (complex-differentiable) implies f(z)dz closed (i.e. the differential form has (locally) a primitive) which in turn, after defining the index of a path with respect to a point in the complex plane, implies the cauchy theorem
13:59:03 <fax> what's a good pastebin that supports latex?
13:59:09 <ddarius> fax: There is something special about the two dimensional case of multivector analysis which corresponds to complex analysis.
13:59:35 <bremner> fax: check the topic in #latex
13:59:37 <jeltsch> How can I get/reset my Hackage password?
14:00:25 <benmachine> xerox: cauchy already has some sequences and an inequality, a theorem as well is just greedy :(
14:00:25 <fax> bremner I don't see it
14:00:41 <xerox> benmachine: everything in complex analysis is "cauchy-something", it's crazy
14:01:00 <fax> cauchy theorem is nice
14:01:10 <ddarius> benmachine: You should see Euler or Gauss or Hamilton or several others.
14:02:01 <bremner> fax: http://pastebin.tlhiv.org/
14:02:13 <fax> thank you!
14:02:25 <SamB_XP> yeah, gauss even has an option on your monitor's menu, doesn't he ?
14:02:34 <SamB_XP> at least, if you still have a CRT he does
14:03:58 <danderson> dons: do you still have that list of SoC projects you came up with after the hackathon?
14:04:23 <danderson> I see a fair amount of students looking at the trac category for projects, but afaik most of those are either obsolete or without a mentor
14:06:13 <ddarius> Incidentally, the core of the concept of "analytic" is not Taylor series but the fact that values in the interior of a (sub)manifold are determined by values on the border.
14:07:01 <xerox> this is the general cauchy for functions of several complex variables?
14:07:20 <MisterN> why isn't superclassing possible in the naive way? i.e. instance Sub a => Super a
14:07:22 <fax> benmachine xerox et al
14:07:26 <fax> http://pastebin.tlhiv.org/MBFEx5L2
14:07:37 <MisterN> or is there a language extension to allow it?
14:07:45 <fax> if you click send to latex previewer then preview it shows it
14:08:00 <mauke> MisterN: because it's a sideways call, which can lead to recursion
14:08:23 <mauke> MisterN: I'm going to write a module that says instance Super a => Sub a, what then?
14:08:25 <fax> & edwardk
14:09:39 <MisterN> mauke: why not error out when and only when the recursion happens?
14:09:55 <mauke> I don't know, maybe it's hard to detect
14:10:10 <ddarius> Of course its hard to detect in general.
14:10:27 <ddarius> You can attempt to do such things with undecidable instances.
14:10:28 <MisterN> why? recursion can be detected with normal cycle detection, no?
14:11:00 <MisterN> also i think it's quite useful to make all instances of, say, Monad to be Applicative by fiat
14:11:23 <benmachine> MisterN: instance Sub a => Super a is possible, but there can be no other instances of Super otherwise they'd overlap
14:11:26 <fax> what do you think??
14:11:33 <benmachine> fax: I think infinity! doesn't make sense
14:11:50 <MisterN> benmachine: well that makes it less useful, right?
14:11:57 <benmachine> right
14:12:00 <fax> yeah but did you see my proof
14:12:08 <benmachine> fax: yes, it uses infinity!
14:12:11 <SamB_XP> what's the double factorial of 10
14:12:20 <benmachine> which doesn't make sense
14:12:23 <fax> SamB, it's 10*8*6*4*2
14:12:31 <fax> it makes sense to me
14:12:42 <SamB_XP> hmm?
14:12:45 <fax> I wonder what xerox was saying about limits
14:12:47 <benmachine> fax: factorial is a function from integers to integers
14:12:52 <benmachine> infinity is not an integer
14:13:10 <SamB_XP> the limit of n!! as n->\inf *is* \inf, isn't it?
14:13:16 <fax> benmachine, I put the result of this equation into haskell it and does give pi/2
14:13:23 <fax> so it's a true equation
14:13:23 <benmachine> MisterN: the thing about allowing instances that overlap is that then the behaviour of a polymorphic function is more difficult to predict
14:13:40 <benmachine> fax: sure, but a false proof
14:13:48 <fax> SamB_XP, no I think it's -sqrt(2pi)/2
14:13:48 <MisterN> benmachine: can you explain?
14:13:57 <humasect> how come cabal does not work on any mac ?
14:14:07 <benmachine> MisterN: only sorta, it's not something I know a lot about
14:14:12 <SamB_XP> fax: that makes absolutely no sense
14:14:37 <SamB_XP> > fact 1
14:14:38 <lambdabot>   Not in scope: `fact'
14:14:48 <SamB_XP> wait, uh ...
14:14:55 <jlouis> > product [1..1]
14:14:56 <lambdabot>   1
14:15:00 <benmachine> MisterN: but, overlapping instances demands some way of selecting the right one
14:15:16 <fax> > product [1..] -- it = sqrt(2*pi) but haskell doesn't find it
14:15:19 <SamB_XP> @let dfact n = product [n, n-2..1]
14:15:21 <Darkone> Double factorial was odd though, wasn't it?
14:15:25 <lambdabot>  Terminated
14:15:26 <lambdabot>  Defined.
14:15:40 <MisterN> benmachine: hmm i think in the Monad=>Applicative case that wouldn't be a problem?
14:15:46 <benmachine> fax: no
14:16:04 <SamB_XP> > dfact [1..]
14:16:07 <lambdabot>   No instances for (GHC.Enum.Enum [t], GHC.Num.Num [t])
14:16:07 <lambdabot>    arising from a use...
14:16:08 <benmachine> fax: product [1 ..] = product [1 .. 3] * product [3 ..]
14:16:08 <SamB_XP> > map dfact [1..]
14:16:11 <lambdabot>   [1,2,3,8,15,48,105,384,945,3840,10395,46080,135135,645120,2027025,10321920,...
14:16:15 <benmachine> the product of positive numbers is positive
14:16:25 <benmachine> oh, I meant product [4 ..]
14:16:26 <MisterN> @let fact x = product [1 .. x]
14:16:27 <lambdabot>  Defined.
14:16:32 <MisterN> > fact 3
14:16:33 <benmachine> MisterN: it could be
14:16:33 <lambdabot>   6
14:16:37 <SamB_XP> benmachine: was gonna say!
14:16:39 <MisterN> > fact . fact 3
14:16:39 <ddarius> fax: Your equalities seem to suggest 2^(-1/2) = 2^infinity
14:16:40 <lambdabot>   No instance for (GHC.Enum.Enum (f a))
14:16:40 <lambdabot>    arising from a use of `L.fact' at ...
14:16:51 <MisterN> > fact $ fact 3
14:16:52 <lambdabot>   720
14:17:00 <fax> ddarius, yeah 1+1+1+... = -1/2
14:17:08 <SamB_XP> fax: since when ?
14:17:14 <MisterN> double factorial is n!!, right?
14:17:15 <fax> I'm not sure how to prove that yet but it's given
14:17:20 <benmachine> fax: what does 2+2+2+.... equal?
14:17:26 <SamB_XP> given by who ?
14:17:27 <fax> benmachine: -1
14:17:56 <benmachine> fax: but 2+2+2+... = (1+1)+(1+1)+(1+1)+... = 1+1+1+...
14:18:04 <benmachine> = -1/2, by your logic
14:18:09 <fax> hm
14:18:47 <fax> you're not allowed to just put brackets on like that
14:18:49 <SamB_XP> actually, I can make it to any integer or half integer
14:18:56 <benmachine> MisterN: an interesting thing to note is that you can make an instance of Applicative that doesn't correspond to an instance of Monad for the same type
14:18:59 <ddarius> benmachine: It comes from Î¶(0) = -1/2
14:19:05 <benmachine> fax: yes I can
14:19:15 <fax> benmachine you're doing a different mathematics
14:19:17 <SamB_XP> fax: associativity
14:19:22 <MisterN> benmachine: you can?
14:19:27 <fax> SamB_XP obviously associativity breaks math
14:19:28 <ddarius> Suffice to say, none of this makes sense unless you consider analytic continuations of the functions that these series represent.
14:19:40 <ddarius> benmachine: Incidentally, analytic continuation is another thing from complex analysis.
14:19:45 <SamB_XP> fax: no, people like YOU PRETEND to break math!
14:19:46 <benmachine> MisterN: yes
14:19:51 <benmachine> fax: what :/
14:19:53 <fax> SamB_XP I would never hurt math!
14:19:57 <MisterN> benmachine: now that sounds weird
14:20:12 <MisterN> benmachine: oh wait, of course
14:20:21 <MisterN> Monad=>Applicative not the other way around
14:20:22 <tensorpudding> does this 1+1+1..=-1/2 related to cesaro summation?
14:21:01 <fax> tensorpudding yes
14:21:03 <SamB_XP> also, 1+1+1+1+1+1... = 1/2
14:21:21 <MisterN> benmachine: why manually define the Applicative for a type when you have already defined the Monad? :)
14:21:27 <benmachine> MisterN: yeah, but also there's a valid Monad instance for Either e and a valid Applicative instance for (Monoid e) => Either e, and the latter can't be made a Monad
14:21:32 <benmachine> err
14:21:33 <SamB_XP> since 1+(1+1+1+1...) = -1/2, and 1+(-1/2) = 1/2
14:21:41 <benmachine> that is to say, there are some <*>s which can't be made an ap
14:21:43 <MisterN> benmachine: i know that Applicative=>Monad does NOT hold
14:21:53 <MisterN> i was talking about Monad=>Applicative
14:22:15 <fax> SamB_XP, that's flawed... say I = 1+1+.. = -1/2, then you are saying 1+I = I..
14:22:18 <ddarius> benmachine: Consider the series Sum (x^n).
14:22:18 <edwardk> fax: & ?
14:22:29 <fax> edwardk I wanted to show you my derivation too
14:22:32 <benmachine> MisterN: but what I'm trying to say is that if you use the Monad (Either e) to make Applicative (Either e) you preclude valid applicatives
14:22:35 <SamB_XP> fax: it's not unheard of
14:22:46 <fax> <http://pastebin.tlhiv.org/MBFEx5L2>
14:22:56 <fax> SamB_XP it seems like a strange (+) then :P
14:23:15 <SamB_XP> fax: anyway, this gives you the free bonus of a proof that 0 = 1
14:23:39 <fax> SamB_XP, I t hink they use 0 = 1 instead of false in constructive algebra (rings)
14:23:39 <ddarius> fax: It's not sound to directly reason on series this way.
14:23:44 <BMeph> benmachine: ...which is why Wrappers exist (and, why "we" hate them). :|
14:23:45 <edwardk> fax: you're not allowed to reparenthesize that way
14:24:05 <SamB_XP> ddarius: hmm ?
14:24:07 <benmachine> BMeph: there are worse things than wrappers
14:24:11 <SamB_XP> edwardk: it wasn't his idea
14:24:12 <fax> I don't know what I did wrong :S
14:24:25 <MisterN> benmachine: wrappers make the code ugly :(
14:24:35 <BMeph> benmachine: Like, Rappers? :D
14:24:53 <edwardk> fax: a divergent series can be made to converge if you add an _infinite_ amount of parentheses
14:24:53 <benmachine> BMeph: very possibly.
14:24:58 <edwardk> you're only allowed to add a finite number
14:25:03 <Kruppe> Anyone know if there is a way to reverse the order of a lambda calculus list without recursion?
14:25:25 <edwardk> 1 - 1 + 1 - 1 + 1 - 1 + - diverges
14:25:28 <fax> Kruppe, without recursion it is impossible!
14:25:35 <edwardk> but (1 -1) + (1 - 1) + (1 - 1) + ... converges
14:25:38 <fax> ah (1-1) = 0
14:25:49 <arw> Kruppe: only for a list of fixed length.
14:25:51 <Kruppe> fax: thats what I thought, but my prof is trying to convince me otherwise
14:26:01 <fax> Kruppe you can implement recursion in lambda calculsu tohugh
14:26:05 <ddarius> Kruppe: You can write foldl in terms of foldr and you can easily write reverse in terms of foldl.
14:26:06 <edwardk> fax the parentheses provide you with groupings you lack in the initial series
14:26:37 <benmachine> ddarius: but you need recursion to write foldr, don't you?
14:26:48 <Kruppe> fax: I think he meant without even a Y combinator, ie no recursion at all
14:26:49 <BMeph> MisterN: Are you reading the "oblivious" paper? :)
14:26:56 <edwardk> benmachine: that entirely depends on your list rep ;)
14:26:59 <MisterN> BMeph: no no i was reading rwh
14:27:03 <ddarius> benmachine: You can encode lists as their foldr functions without needing recursion.
14:27:08 <edwardk> exactly
14:27:11 <edwardk> @type foldr
14:27:12 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
14:27:15 <benmachine> ah, yeah
14:27:23 <MisterN> BMeph: the parts on monad transformers and applicative really disturbed me
14:27:26 <edwardk> type List = (forall b. (a -> b -> b) -> b -> b)
14:27:58 <micah> I am trying to make my parsec error messages look nice
14:28:02 <edwardk> elimination forms like that are actually quite useful
14:28:19 <micah> I'm tokenizing and then using parsec on [(SourcePos, token)]
14:28:31 <edwardk> you can also represent it anamorphically
14:28:38 <BMeph> edwardk: Surely, that's "List a", right? ;)
14:28:45 <edwardk> BMeph: yeah =)
14:28:57 <edwardk> @type unfoldr
14:28:58 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
14:29:47 <edwardk> newtype Stream a = forall b. Stream (b -> Maybe (a,b)) b
14:30:09 <edwardk> er there is an existential in there so that has to be data in ghc
14:30:39 <edwardk> that approach also generalizes to arbitrary base functors
14:31:46 <edwardk> data Nu f = forall s. Nu (s -> f s) s   ; newtype Mu f = Mu (forall b. (f b -> b) -> b)
14:32:10 <edwardk> which make for easy definitions for ana and cata
14:32:34 <ddarius> Easy = trivial
14:32:41 <edwardk> yeah =)
14:33:43 <edwardk> the fusion stuff i was playing with basically boiled down to data Nu f = forall s. Nu (s -> Partial (f s)) s -- for a partiality monad, where the step constructor in the partiality monad played the role of 'Skip' in stream fusion
14:33:57 <micah> my parsec error messages have started doing stuff like this:
14:34:03 <micah> unexpected [((line 1, column 3),!)]
14:34:18 <micah> althought showTok    (p, t) = show t
14:34:26 <micah> and they also say stuff like
14:34:29 <edwardk> that way i could use traverse over the functor f to take multiple steps regardless of the complexity of the traversable functor f.
14:34:33 <micah> Pattern match failure in do expression at parser.hs:99:10-16, Pattern match failure in do expression at parser.hs:102:12-20 or Pattern match failure in do expression at parser.hs:105:9-17
14:34:40 <micah> which I do not want
14:34:58 <aavogt> micah: then don't use patterns that can fail
14:35:10 <micah> ok
14:35:16 <micah> but how do I fix my first problem
14:35:46 <aavogt> on those lines, instead of say,    Just a <- parseSomething,     write   x <- parseSomething; case x of Just a -> what you're doing already; Nothing -> fail "sensible message"
14:36:05 <micah> aavogt: thanks :)
14:36:28 <aavogt> micah: are you calling fail yourself to give positions?
14:36:35 <micah> no
14:36:39 <micah> I'm letting parsec give positions
14:36:48 <benmachine> or even, x <- fromMaybe (fail "sensible message") <$> parseSomething
14:36:49 <micah> the problem is that it does this:
14:36:50 <micah> Parsing error (line 1, column 3):
14:36:50 <micah> unexpected [((line 1, column 3),!)]
14:36:58 <benmachine> :t fromMaybe . fail
14:36:59 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> Maybe (m a) -> m a
14:37:06 <sinelaw> hi.
14:37:08 <benmachine> hmmm
14:37:16 <aavogt> @type maybe (fail "") return
14:37:16 <benmachine> well, whatever
14:37:17 <lambdabot> forall (m :: * -> *) a. (Monad m) => Maybe a -> m a
14:37:19 <benmachine> hi sinelaw
14:37:28 <aavogt> @type (maybe (fail "") return =<<)
14:37:29 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (Maybe a) -> m a
14:39:12 <aavogt> micah: well then it's calling  show instead of showTok
14:39:31 <micah> I'm using parsec's `token` thing
14:39:39 <micah> and `showTok` is its argument
14:40:20 <aavogt> which version of parsec?
14:40:28 <micah> I believe 3
14:40:41 <micah> yep
14:42:06 <pippijn> is there a torrent for the haskell platform on linux?
14:52:20 <aavogt> micah: token :: (t -> String) -> (t -> SourcePos) -> (t -> Maybe a) -> Parsec s u a
14:52:33 <micah> aavogt: yes
14:52:49 <aavogt> in the third argument you also pass in SourcePos?
14:52:51 <micah> aavogt: I use that to define `match` and `advance`
14:52:54 <micah> aavogt: yes
14:53:16 <aavogt> do you do anything with the     Parsec s u (SourcePos,a) ?
14:53:28 <micah> no
14:53:35 <aavogt> that needs the SourcePos?
14:53:36 <micah> showTok    (p, t) = show t
14:53:41 <micah> posFromTok (p, t) = p
14:53:55 <micah> and testTok depends on if it's match or advance
14:54:40 <aavogt> well parsec itself keeps track of the SourcePos for you
14:54:52 <micah> yeah but I'm not parsing Strings
14:55:27 <aavogt> use    Parsec s u a, then whenever you call fail, the SourcePos taken from the second argument to token will also be printed
14:55:44 <micah> where exactly do I use Parsec s u a
14:55:55 <aavogt> you use token, no?
14:56:04 <micah> yes
14:56:31 <micah> does it return Parsec s u a?
14:56:44 <aavogt> by the type, yes
14:58:15 <aavogt> hmm, my advice may not be sensible if processing after tokenizing needs the position
14:59:33 <micah> it only needs the position for the errors
15:09:16 <micah> It wasn't doing this before
15:09:29 <micah> I don't know what did it, but now it says
15:09:36 <micah> unexpected [((line 1, column 1),if)]
15:09:38 <micah> instead of
15:09:43 <micah> unexpected if
15:11:00 <Itkovian> how does on tell ghci to use mtl if one also has monad-fd installed, due to a dependency of some package?
15:11:24 <monochrom> Imperative method: ghc-pkg hide monad-fd
15:12:09 <monochrom> Functional method: use cabal to build your project. in some file you get to say you want mtl. in fact you must explicitly list all packages you want, even base.
15:13:33 <SamB_XP> and it bugs you if you don't specify which versions, too, right?
15:13:41 <mm_freak> jlouis: i find it extremely difficult to get into iteratee without reading tons of stuff
15:13:45 <mm_freak> no tutorial, no examples
15:15:20 <jlouis> mm_freak: I found a nice example in the slides on Olegs page: http://okmij.org/ftp/Haskell/Iteratee/IterateeIO-talk.pdf
15:15:42 <jlouis> mm_freak: there is a parser example for HTTP in there which is somewhat like your RFC1459 problem
15:15:50 <mm_freak> jlouis: as far as i've understood this uses oleg's original library
15:16:00 <mm_freak> i found a different approach
15:16:07 <mm_freak> http://hackage.haskell.org/package/safe-lazy-io
15:16:25 <mm_freak> i'm reading pouillard's post right nw
15:16:26 <mm_freak> now
15:17:28 <cads> fax, how do we figure that sum_{k=0}^{Infinity} (-1)^k = 1/2?
15:19:46 <fax> cads, 1-1+1-1+..=X then X=1-X <=> 2X=1 <=> X=1/2
15:19:51 <cads> Oh, we can rearange  S = 1 - 1 + 1 - 1 .. as S = 1 - (1 - 1 + 1 - 1..)
15:20:02 <fax> yeah
15:20:03 <monochrom> You can make it almost any answer you want.
15:20:39 <fax> but there's only one right answer
15:21:02 <cads> monochrom, what are other values we could show?
15:21:24 <dancor> why not X= 1-1 + 1-1 + .. = 0 + 0 + .. = 0?
15:21:44 <cads> yup
15:22:21 <fax> it's illegal
15:22:30 <benmachine> illegal?
15:22:32 <benmachine> what law does it break
15:22:37 <fax> associativity
15:22:44 <benmachine> uh, how
15:22:49 <dancor> ha.  the limit of the sum doesn't converge
15:22:49 <benmachine> addition is associative
15:23:20 <edwardk> benmachine: you're only allowed to add a finite number of parentheses when evaluating a series, it is the introduction of an infinite number of parentheses that takes a diverging series into a converging one
15:23:41 <fax> yeah but you can't just assume that because P is true of every x, P is true of the limit of x's -- e.g. + gives a rational when you add them, but you know there are infinite sums of rationals which give trancendental constants
15:23:44 <cads> you could also arrange it as  X = 1 - (1 - 1) - (1 -1) = 1 - 0 - 0 ... = 1
15:24:30 <edwardk> otherwise 0 = (1 - 1) + (1 - 1) + ... = 1 - 1 + 1 - 1 + ... = 1 + (-1 + 1) + (-1 + 1) + ... = 1
15:24:42 <dancor> the partial sums are 1,0,1,0,1,0,..
15:24:55 <benmachine> edwardk: I guess that makes sense
15:25:08 <dancor> i've never seen an infinite sum treated rigorously in terms of something other than a limit of partial sums
15:25:17 <cao> just try leibniz with a a_n = 1
15:25:21 <jlouis> mm_freak: I don't think iteratee looks that evil
15:25:29 <edwardk> benmachine: if you can only introduce a finite number of parentheses you don't change divergence into convergence and all is right with the world. diverging series still diverge.
15:25:53 <cads> apparently there is a way of using such paradoxical seeming properties: http://en.wikipedia.org/wiki/Eilenberg%E2%80%93Mazur_swindle
15:25:55 <cao> ofc the 1series is neither a 0series nor decreasing
15:25:59 <dancor> edwardk: but cad's original 1/2 only added one set of ()'s
15:26:03 <lament> infinite sumthing or other
15:26:29 <cads> fax, I think the question of whether the infinite sum converges is up to your particular choice of a theory of infinite sums
15:26:33 <mm_freak> jlouis: it's scary, if you don't know the concept, and that's not only a concern, because i need to get into it, but because if i base my library on it, other people have to learn it as well, if they want to use it
15:26:37 <edwardk> dancor: wasn't looking at the time =)
15:26:56 <cao> thus it follows that sum_{k=0}^{infinity} (-1)^k doesnt converge
15:27:06 <fax> cads: what are the main theories?
15:28:29 <edwardk> fax: there are perfectly good uses for infinite series. take generating functions for instance.
15:28:40 <cads> fax, http://en.wikipedia.org/wiki/Ces%C3%A0ro_summation
15:28:54 <edwardk> fax: http://www.math.upenn.edu/~wilf/DownldGF.html
15:28:57 <fax> oh I did think about infinite generating functions counting the number of elements of a data type!
15:29:09 <fax> then you can differentate it to make a new ADT with a hole
15:29:25 <edwardk> fax: http://comonad.com/reader/2008/generatingfunctorology/
15:29:27 <cads> fax, the cesaro summation gives the answer S = 1/2
15:29:51 <edwardk> fax: i wrote a blog post on that at one point, it only works when considering 'data' not 'codata' though. you need a different generating function to describe codata correctly
15:29:54 <dancor> monochrom: how would you "get" other values tho, like 2?
15:30:30 <mm_freak> that's one reason i'm not using FRPâ€¦  there are implementations as well as theoretical introductions, but nothing that connects the twoâ€¦  for example i have no idea how to combine Reactive, SDL and OpenGL to write a game engine
15:30:30 <dancor> there must be something to the way different divergent series diverge
15:30:46 <cads> fax, but the classical interpretation is that S is a divergent sum and has no value, because the partial sums don't converge, as dancor  points out
15:31:14 <dancor> like here there are exactly two values that subseries converge to, 0 and 1.
15:31:59 <dancor> it multiconverges to {0,1} :)
15:32:57 <fax> hehe
15:33:01 <fax> there is a new theory!
15:33:07 <dancor> oh wait there are more convergent subsequences here
15:33:59 <dancor> it multiconverges to all the nonnegative integers then?
15:34:29 <cads> Well.. if you consider  S = A + B    where A = -B = 1 + 1 + 1 + ...,  then for example  A = 1 + 1 + 1 + A, thus S = A + B = 3 + A + B = 3.
15:34:54 <dancor> mmhmm
15:34:54 <edwardk> dancor: you don't have to insert parentheses uniformly
15:36:05 <edwardk> dancor: it also gets worse if you consider commutativity, there is a reason why you need the 'finite' constraint
15:36:28 <cads> It's kind of a variant of the hotel infinity argument
15:36:47 <ddarius> See Abel Summation and Borel Summation.
15:46:39 * ddarius would recommend people looking into this look at the wikipedia page on divergent series.
15:47:06 <lament> i can't believe +1-1+1-1 can be a topic of such a long discussion
15:47:41 <ddarius> lament: I'm certain there have been much longer conversations about it with much less lucidity.
15:47:54 <lament> that's horrible to think about
15:48:05 <monochrom> It could be infinitely long.
15:48:06 <fax> lament did you see my latex
15:48:15 <edwardk> lament: it has provided a good excuse to focus on my code ;)
15:48:16 <SamB_XP> lament: horrible, but most likely true
15:48:20 <lament> fax: no
15:48:27 <SamB_XP> try not to think about it ;-P
15:48:44 <SamB_XP> oh, and while you're at it, don't think about pink elephants, either
15:49:01 <lament> done
15:49:34 <fax> lament - http://pastebin.tlhiv.org/MBFEx5L2
15:49:36 <fax> you can preview it
15:50:32 <lament> fax: lolwhat
15:50:53 <fax> lament ;D
15:51:26 <lament> this is abuse of notation
15:51:32 <ddarius> It has provided me with an excuse to think about germs and sheaves and analytic continuations.
15:52:01 <monochrom> It provided me with an excuse to say something. XD
15:52:02 <ddarius> lament: That and nonsense as written.
15:52:02 <fax> ddarius have you heard of moonshine behind the monster?
15:52:13 <SamB_XP> lament: like the proof that ...1111.0 = -1 ?
15:52:13 <ddarius> fax: Yes.
15:52:30 <lament> SamB_XP: lol
15:52:31 <fax> i wish I could study it but it's too advanced for me rignth now
15:52:39 <SamB_XP> fax: yeah, the monsters always require vast quantities of alcohol ;-P
15:53:20 <lament> fax: the reason people don't write f(inf) to mean lim[n->inf] f(n) is that it's ridiculous
15:53:31 <fax> I wasn't using it as a limit
15:53:53 <monochrom> I saw f(oo) in a paper on complex analysis.
15:53:58 <lament> yeah you were.
15:54:30 <lament> monochrom: ...er, right, "except in papers on complex analysis"
15:54:39 <fax> is complex analysis real?
15:54:42 <SamB_XP> lament: that usually doesn't stop EEs ;-P
15:54:55 <monochrom> The Riemann sphere is of course nice enough to support that.
15:56:09 <lament> unless there is no f(oo)
15:56:12 <lament> like in fax's case
15:56:19 <lament> then even the riemann sphere won't help
15:56:59 <fax> I love this channel because it gives me 100 new things to read about :P
16:03:33 <dcolish> is there a tracker for packages that need to be updated due to the Prelude deprication?
16:06:40 <aavogt> dcolish: that's probably something you should take up with the package maintainers?
16:07:34 <dcolish> i would if it were just an isolated package or two
16:10:04 <aavogt> well if things need to be changed at all (other than listing base 4 as an acceptable version to use), is to update to the newer exceptions
16:10:14 <SamB_XP> the WHAT now ?
16:10:52 <aavogt> SamB_XP: ghc6.12 says that the prelude from base-3 is depreciated
16:11:23 <dcolish> right, so is it a matter of updating the cabal scripts?
16:11:25 <SamB_XP> ahhh
16:11:27 <SamB_XP> that makes sense
16:11:36 <SamB_XP> but maybe it should be clearer about that ?
16:11:50 <SamB_XP> that it's actually base-3 itself that's deprecated ?
16:12:11 <aavogt> the actual message is pretty clear
16:12:38 <SamB_XP> hmmm
16:12:55 <dcolish> i'm not confused by the message, i'm trying to figure out the best approach for helping update packages
16:13:12 <SamB_XP> funny, I'm installing an antivirus program, and it's currently scanning it's own installer archive (a SFX rar that kicks off the install) for viruses ;-)
16:13:49 <SamB_XP> okay, maybe we just need to improve dcolish's clarity then ;-P
16:13:58 <dcolish> awww :(
16:14:06 <aavogt> SamB_XP: it's pretty unambiguous: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24453#a24453
16:15:55 <aavogt> dcolish: find the dev repo of the package, get it, and then make it build with base-4
16:16:37 <aavogt> if it's still supposed to build with base-3 (ie. ghc-6.8),  use  explicit-exception
16:16:42 <aavogt> instead of Control.Exception
16:17:08 <aavogt> err, not explicit-exception
16:17:23 <aavogt> @hackage extensible-exceptions
16:17:24 <lambdabot> http://hackage.haskell.org/package/extensible-exceptions
16:18:11 <aavogt> the difference between the two isn't very big
16:18:52 <aavogt> mostly that catching any exception is now:    ... `catch` \(SomeException e) -> ...;   vs    ... `catch` \e -> ...
16:18:55 <Cerulean> I'm using Parsec and am quite new to Haskell. Is there a shorthand for the simple `do' block that I'm using in http://pastebin.com/L5FksHYx ?
16:19:10 <aavogt> though catching everything probably isn't the right thing to do
16:19:29 <aavogt> Cerulean: blocks <- many block
16:19:30 <mauke> Cerulean: blocks <- many block
16:19:43 <MisterN> :t many
16:19:44 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f [a]
16:20:12 <aavogt> parsec has a different many
16:20:25 <MisterN> aavogt: even parsec 3?
16:20:47 <pikhq> Cerulean: "(do x <- f;return x)" is equivalent to "x".
16:20:52 <pikhq> This is one of the monad laws.
16:20:58 <Cerulean> pikhq: great, that was just what I was going to ask.
16:21:06 <Cerulean> thanks all
16:21:08 <pikhq> Erm.
16:21:13 <pikhq> Not "x", "f".
16:21:16 <BMeph> "...to "f"". :)
16:21:16 <pikhq> Sorry about the thinko.
16:22:00 <aavogt> MisterN: apparently yes
16:22:04 <MisterN> aavogt: i can't find plain many in http://hackage.haskell.org/packages/archive/parsec/3.0.0/doc/html/Text-Parsec-Combinator.html
16:22:10 <aavogt> but they do the same thing
16:22:11 <MisterN> many1, manyTill but no many
16:22:19 <aavogt> many :: ParsecT s u m a -> ParsecT s u m [a]
16:22:21 <aavogt>   -- Defined in Text.Parsec.Prim
16:22:44 <aavogt> MisterN: ^^ this is the output from :i many
16:22:51 <MisterN> why didn't they just use the Alternative function?
16:23:09 <BMeph> :o
16:23:56 <MisterN> BMeph: ?
16:24:21 <BMeph> MisterN: "the Alternative function?" :)
16:24:27 <MisterN> Prelude Control.Applicative> :i many
16:24:27 <MisterN> many :: (Alternative f) => f a -> f [a]
16:24:27 <MisterN>   	-- Defined in Control.Applicative
16:24:55 <MisterN> BMeph: it's in class Alternative :)
16:24:56 <BMeph> MisterN: (Hint: "Alternative" is not a function.)
16:25:12 <mauke> MisterN: look at the source of Parsec many
16:25:44 <MisterN> mauke: ?
16:25:58 <MisterN> i did look at it
16:25:58 <SamB_XP> MisterN: you don't have the parsec sources on hand for reference ?
16:26:11 <MisterN> many p
16:26:11 <MisterN>   = do xs <- manyAccum (:) p
16:26:11 <MisterN>        return (reverse xs)
16:26:34 <mauke> that's not the source I remember
16:26:36 <mauke> hmm
16:26:57 <SamB_XP> what does manyAccum say ?
16:26:59 <aavogt> http://hackage.haskell.org/packages/archive/parsec/3.0.0/doc/html/src/Text-Parsec-Prim.html#many
16:27:20 <MisterN> SamB_XP: http://hackage.haskell.org/packages/archive/parsec/3.0.0/doc/html/src/Text-Parsec-Prim.html#manyAccum
16:30:27 <idnar> @src many
16:30:27 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
16:31:09 <MisterN> idnar: the Alternative function (yes, BMeph i know that Alternative itself is not a function) is in the instances only :)
16:32:26 <idnar> MisterN: I was looking for the default implementation
16:33:03 <MisterN> idnar: hmm does lambdabot support that? :)
16:33:13 <MisterN> wait
16:33:15 <MisterN> i'm stupid
16:33:16 <idnar> MisterN: @src just reads from a text file
16:34:31 <MisterN> idnar: i wonder if many is actually in the class itself :)
16:34:51 <jmcarthur> MisterN: they didn't use the Control.Applicative.many version because Parsec's many predates it
16:35:00 <idnar> MisterN: http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.2.0.0/src/Control-Applicative.html
16:44:35 <danderson> how do I actually run an IO action in ghci and store its result? The let binding syntax records the IO action, not its result.
16:44:57 <danderson> nvm, found it.
16:45:32 <danderson> (the timeless law applies again: the solution always becomes apparent 3 seconds after professing ignorance on IRC)
16:46:52 <jmcarthur> danderson: you can usually just pretend that ghci is do syntax
16:48:15 <aavogt> other than layout, when can't you?
16:50:14 <benmachine> well, there's the magic it
16:50:14 <monochrom> when you type :quit
16:50:45 * danderson learns the hard way that starting a forever action in ghci can't be ^C'd
16:51:11 <benmachine> ghci> forever (return ())
16:51:11 <benmachine> ^CInterrupted.
16:51:28 <danderson> huh.
16:51:36 <danderson> so what the heck is mine doing that is non-interruptible
16:53:46 <aavogt> perhaps you have a different version of ghc?
16:54:05 <aavogt> I think some versions were buggy
16:54:16 <danderson> looks like it's a combination of network I/O and spawning threads that's making it unhappy at random times
16:54:28 * benmachine 6.12.1
16:54:41 * danderson same
17:00:04 <danderson> so, System.Timeout.timeout and Network.Socket.connect really don't seem to be friends
17:00:49 <danderson> in various cases, I can get connect() to never get timed out
17:02:45 <monochrom> Note that System.Timeout.timeout is documented to be unable to abort FFI calls.
17:03:18 <danderson> but also that most I/O should be delegating to the I/O thread, which can observe aborts
17:03:37 <danderson> in fact, that does work, except when I try to connect() to localhost.
17:03:50 <danderson> oh, wait.
17:03:55 <danderson> I may just be an idiot.
17:04:29 <danderson> yeah, that was it.
17:04:31 <mm_freak> > forever []
17:04:32 <lambdabot>   []
17:04:34 <danderson> my code actually works perfectly
17:04:44 <dmwit> > forever [1]
17:04:46 <lambdabot>   * Exception: stack overflow
17:04:50 <monochrom> You are just a genius :)
17:05:02 <danderson> except that I only printed a debug string if the connection attempt timed out
17:05:12 <monochrom> haha
17:05:16 <danderson> and when connecting to my wide open localhost, the failure was propagated via IO exception
17:05:27 <danderson> and so silently swallowed by the connection management machinery
17:05:28 <danderson> good times.
17:06:09 <danderson> so, now the only problem I need to resolve, is that I'm also unable to connect to stuff that is actually there
17:06:30 <mm_freak> > runCont (callCC $ \k -> forever (k 100)) return
17:06:31 <lambdabot>   No instance for (GHC.Show.Show (m a))
17:06:31 <lambdabot>    arising from a use of `M3962025845...
17:06:39 <mm_freak> huh?!
17:06:47 <pastorn> mm_freak: breaking out of forever?
17:06:54 <mm_freak> pastorn: yeah
17:07:00 <monochrom> use id instead of return
17:07:00 <pastorn> is that possible?
17:07:04 <mm_freak> of course
17:07:06 <pastorn> hehe
17:07:11 <mm_freak> > runCont (callCC $ \k -> forever (k 100)) id
17:07:11 <lambdabot>   100
17:07:13 <pastorn> goddamn Cont
17:07:26 <mm_freak> lol of course
17:07:30 <danderson> breaking out of forever has a nice philosophical ring to it
17:07:32 <pastorn> MonadCUNT
17:07:36 <mm_freak> i confused Cont with ContT
17:07:50 <monochrom> yes :)
17:07:51 <mm_freak> i use ContT in real code
17:08:09 <pastorn> mm_freak: how did you learn to use it?
17:08:17 <mm_freak> and i use monadLib, too, where i can just write:  runContT return $ forever (abort 100)
17:08:18 <monochrom> me too. ContT (StateT s IO) hehe
17:08:20 <mm_freak> =)
17:08:25 <jmcarthur> conal: something about your Future type in push/pull... it's Monoid instance isn't a TCM, but if you put those semantics into MonadPlus instead then I think it might be
17:08:36 <mm_freak> pastorn: it's actually quite easy
17:08:39 <pastorn> it's not exactly like i write CPS code every day and think "ok, let's make use of MonadCont now"
17:08:44 <pastorn> mm_freak: don't
17:08:56 <mm_freak> ?!
17:08:56 <lambdabot> Maybe you meant: . ? @ v
17:09:07 <pastorn> mm_freak: yeah, so are lie algebras
17:09:10 <pastorn> childsplay
17:09:11 <conal> jmcarthur: nice.  thx.
17:09:28 <mm_freak> pastorn: that was no joke =)
17:09:47 <mm_freak> callCC calls the given computation with a continuation, which you can interpret as a short cut exit =)
17:09:58 <monochrom> pastorn: I invite you to http://www.vex.net/~trebla/haskell/cont-monad.xhtml
17:10:01 <mm_freak> > runCont (callCC $ \exit -> exit 5) id
17:10:02 <lambdabot>   5
17:10:11 <edwardk> pastorn: Breaking out of forever sounds like something from "Fine Structure"
17:10:22 <mm_freak> > runCont (callCC $ \exit -> exit 5; return 7) id
17:10:23 <lambdabot>   <no location info>: parse error on input `;'
17:10:26 <mm_freak> uhm
17:10:29 <mm_freak> > runCont (callCC $ \exit -> exit 5 >> return 7) id
17:10:30 <lambdabot>   5
17:10:41 <pastorn> mm_freak: hmm... could you use that \exit var and put it in a reader and then evenually use it from inside forever?
17:10:53 <mm_freak> pastorn: sure, use ContT
17:10:59 <pastorn> mm_freak: that's just nasty
17:11:17 <jmcarthur> conal: i've been playing with the Partial monad today and was thinking about the relationship between (Free Identity a) and (Natural, a), and i realized that the MonadPlus instance I had been using for Partial is basically the only one that makes sense, and if you apply that line of reasoning to (Natural, a), but replace Natural with whatever domain you choose for Time then you get the semantics you
17:11:19 <jmcarthur> currently have for Monoid Future
17:11:39 <pastorn> monochrom: thanks for the link... i'll read it later :)
17:11:48 * pastorn is actually busy messing with graphics
17:12:07 <edwardk> jmcarthur: except that it is easier to partially evaluate Free Identity a
17:12:32 <mm_freak> pastorn: well, Cont/ContT are a bit awkward to use in the mtl or transformers libraries
17:12:32 <jmcarthur> edwardk: true, but i can't think of a way to generalize Free Identity to a continuous domain (in place of Natural)
17:12:44 <mm_freak> monadLib has a great Cont/ContT implementation, where you don't need that nasty callCC
17:12:54 <jmcarthur> s/domain/some other words i meant/
17:13:22 <jmcarthur> edwardk: we're just talking about models anyway
17:13:24 <edwardk> jmcarthur: *nods*, the other issue is of course, that you typically want to use Partial ~ Free Identity when you're trying to race things, and that doesn't help with the fact that all of the rest of your code isn't necessarily in Partial. i.e. you run comparisons, etc.
17:13:28 <edwardk> jmcarthur: *nods*
17:13:40 <pastorn> mm_freak: it just magically knows how to break?
17:14:09 <pastorn> also: can't you use callCC to magically enter back into some point in a function (like goto)
17:14:15 <jmcarthur> edwardk: yeah the Partial monad isn't the same as Future. they just share a few things
17:14:25 <edwardk> pastorn: it isn't magic, its just counter-intuitive plumbing of arguments
17:14:29 <mm_freak> pastorn: yeah
17:14:40 <monochrom> pastorn: My url shows both "put it in Reader" and "goto".
17:14:53 <jmcarthur> s/things/properties/
17:15:25 <mm_freak> pastorn: using callCC is a bit more generalâ€¦  you can use it for short cut exits and for a lot more things
17:15:37 <mm_freak> the 'abort' computation can only be used for short cut exits
17:15:41 <jmcarthur> edwardk: in this case (Natural, a) models the fact that there are n constructors wrapping the final value
17:16:00 <jmcarthur> edwardk: and (Time, a) models the fact that there is t time to wait before arriving at a value
17:16:40 <pastorn> hmm.. so say that i have some StateT s ContT IO computation
17:16:48 <pastorn> and it's for web stuff or whatever
17:17:16 <pastorn> so not wanting to keep a tread for each user i calculate that i should jump to a certain point in my program
17:17:30 <pastorn> (where it last exited)
17:17:36 <jmcarthur> but i can't really use any functor that i know of to implement (Time, a) as a free monad
17:17:37 <pastorn> how do i restore the state that was?
17:17:45 <pastorn> (with user login and what not)
17:18:22 <mm_freak> pastorn: what's wrong with having a thread for each user?
17:18:35 <pastorn> mm_freak: doesn't that get heavy?
17:18:49 <pastorn> mm_freak: think facebook-load
17:19:27 <mm_freak> if it does, that's an RTS issue
17:19:42 <mm_freak> currently it might, if you expect thousands of clients at once
17:19:54 <mm_freak> because AFAIK the RTS uses select()
17:20:43 <mm_freak> if you need high speed multiplexing (and have a specific reason for that need), there is a library using linux epoll
17:20:56 <pastorn> mm_freak: i'm thinking of something like this: http://www.cs.chalmers.se/Cs/Grundutb/Kurser/afp/lab2.html
17:21:48 <pastorn> it's a monad for re-running program but not computing for results if old results have already been computed
17:22:11 <mm_freak> i remember that someone implemented a break/resume monad
17:22:31 <mm_freak> but i never found a use for such a thing
17:22:32 <Itkovian> I'm struggling with figuring out how to design the right monad stack. At the lowest level, I need IO (Either String a). Each computation requires that I get some data from a fixed configuration, and at each computation, I need to have a list of things which may become empty and need to be updated.
17:23:35 <Itkovian> So I am thinking I need something like a StateT (Reader Config) ListOfThings IO (Either String a), but that seems like totally fubar.
17:24:00 <pastorn> Itkovian: sounds like you need RWST
17:24:15 <monochrom> monad-coroutine is one of those suspend-resume
17:24:22 <monochrom> I think there are more.
17:24:28 <Itkovian> reader/writer/state?
17:25:11 <pastorn> Itkovian: RWST Config SomeState ListThatLogsStuff (EitherT String IO) a
17:25:21 <monochrom> woah? there is mtl-tf = monad transformer lib using type families?
17:25:24 <pastorn> Itkovian: or you can just have () as you state
17:25:44 <Itkovian> Well, the state would be the list.
17:25:53 <pastorn> Itkovian: not a writer?
17:26:01 <pastorn> or do you need to look at it?
17:26:41 <pastorn> newtype RWST r w s m a = RWST {runRWST :: r -> s -> m (a, s, w)}
17:26:42 <Itkovian> the list is basically a list of servers that can be queried, when a error occurs, I need to fetch a new list, so it amounts to state, I think
17:26:49 <monochrom> Oh! Of course, there are fundeps, replaceable by associated type synonyms.
17:27:06 <edwardk> jmcarthur: *nods* i've just been trying to avoid having a clock - admittedly without much success. ;)
17:27:17 <pastorn> Itkovian: are you doing this from inside "forever"?
17:27:52 <pastorn> otherwise you can put your server sockets inside a reader and use local to update it :)
17:28:51 <Itkovian> they're not sockets, just ip addresses
17:29:09 <pastorn> well, whatever :)
17:29:21 <Itkovian> Using local I could just store the list in the config and update that
17:29:50 <pastorn>  Itkovian but then you manually have to call the loop entry point
17:30:09 <pastorn> it's usually more convenient to put it all inside of forever
17:30:28 <Itkovian> erm.
17:30:45 <pastorn> (and then have your server list in state)
17:31:17 <Itkovian> It might be called from inside forever
17:31:35 <Itkovian> I guess that depends on the user of the library
17:31:59 <pastorn> Itkovian: why are you having an error monad in there?
17:32:50 <edwardk> @seen bos
17:32:50 <lambdabot> Unknown command, try @list
17:32:52 <Itkovian> pastorn: because the other side can return fault values and I need to handle them decently. I think that's the way to go about it.
17:32:56 <edwardk> preflex: xseen bos
17:32:56 <preflex>  bos was last seen on freenode/#haskell 3 days, 20 hours, 3 minutes and 54 seconds ago, saying: superoptimizer: ^^^
17:33:02 <Itkovian> It's using XMLRPC
17:33:31 <Itkovian> so their call returns some ErrorT thingie or Either, depending on which function I use.
17:33:54 <pastorn> Itkovian: you are aware that your whole computation will break down on one error, right
17:33:56 <pastorn> ?
17:34:11 <edwardk> @ask bos would it be possible to export Data.Attoparsec.Internal from attoparsec?
17:34:11 <lambdabot> Consider it noted.
17:34:18 <pastorn> look at the monad instance for the Maybe monad
17:34:30 <pastorn> Nothing >>= _ = Nothing
17:34:58 <Itkovian> yeah sure, but the point is that depending on the error returned I can take the appropriate action.
17:35:11 <Itkovian> I thought this was the way to go about it.
17:35:12 <Itkovian> hmm
17:35:28 <pastorn> maybe if EitherT String is the topmost monad
17:35:36 <pastorn> http://hackage.haskell.org/packages/archive/EitherT/0.0.1/doc/html/Control-Monad-Either.html
17:36:27 <Itkovian> Right now, I'm not using a decent monad stack at all. functions return IO (Either String a) and the lib user should deal with it :-)
17:38:14 <pastorn> Itkovian: perhaps this? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24456#a24456
17:38:40 <pastorn> i don't really know if you can catch an error from within a LULZ computation here... i would think not
17:39:35 <pastorn> i placed EitherT outmost, because then, if your computation breaks, you get back your reader and your state
17:39:54 <Itkovian> right.
17:40:14 <pastorn> if EitherT is "deeper" into the stack ( = ... EitherT x IO ) then you'd loose all that information upon breaking
17:40:29 <pastorn> ok, so how do you obtain these errors?
17:40:42 <pastorn> do you query all the servers regularly to check that they're ok?
17:41:18 <kevinulin> what is the best way to go from a ByteString to an Int?
17:41:33 <pastorn> kevinulin: how would that happend?
17:41:51 <monochrom> const is the best way
17:41:52 <kevinulin> i would be passing an int over tcp
17:42:06 <kevinulin> or at least that is my intention
17:42:18 <pastorn> kevinulin: maybe Data.Binary?
17:42:32 <pastorn> don't know if that handles bytestrings, though
17:43:09 <pastorn> oh, it does :) http://hackage.haskell.org/packages/archive/binary/0.5.0.2/doc/html/Data-Binary.html
17:43:42 <FunctorSalad> any pointers about linker-errors involving gtk2hs? example: undefined reference to `__stginit_gtkzm0zi10zi1_GraphicsziUIziGtk_'
17:43:59 <kevinulin> pastorn: thanks that should save me tons of time
17:44:18 <pastorn> kevinulin: that's how you write loaders and stuff :)
17:44:39 <FunctorSalad> (I'm installing haskell packages in a nonstandard directory tree, but I copied all the stuff from /lib over and ran ldconfig... still won't work)
17:45:12 <FunctorSalad> (from haskellprefix/lib, I mean)
17:45:24 <pastorn> kevinulin: you should use get in combination with liftM, like this:
17:45:36 <pastorn> data A = A Int Char Float
17:45:49 <pastorn> getA = liftM3 A get get get
17:46:51 <Itkovian> pastorn: no, each time you connect to the server using some of the API calls, you potentially get an error response
17:47:20 <pastorn> Itkovian: just catch and handle those manually
17:47:23 <Itkovian> i.e., an XMLRPC fault, which is converted nicely by the haxr to some ErrorT, for which currently I'm using runErrorT to get the stuff out
17:47:24 <pastorn> at least i would
17:48:32 <pastorn> just write a function talkToServer :: IP -> IO (Either err a)
17:49:09 <Itkovian> I have that. It just needs to potentially also update the state and give the correct response back
17:49:24 <Itkovian> anyway, I'm calling it a day
17:49:25 <Itkovian> thx
17:50:19 <aavogt> FunctorSalad: even when compiling with ghc --make?
17:53:21 <FunctorSalad> aavogt: hmm I just tried cabal install-ing things that depend on gtk2hs
17:55:09 <aavogt> FunctorSalad: does this list your new path: ghc-pkg field gtk include-dirs
17:57:05 <FunctorSalad> aavogt: somehow this lists gtk stuff from plain /usr/lib and /usr/include
17:57:23 <aavogt> is that still the case?
17:57:44 <FunctorSalad> (my setup is some weird contraption migrated from debian's haskell packages to a manual setup)
17:57:54 * aavogt has never installed stuff into nonstandard trees
17:59:10 <FunctorSalad> aavogt: what should still be the case?
17:59:38 <FunctorSalad> these could be remains from the debian gtk2hs package, but I'd think the manual installation should have overwritten it
17:59:40 <aavogt> that the paths mentioned still contain stuff
17:59:59 <aavogt> preflex: zdec `__stginit_gtkzm0zi10zi1_GraphicsziUIziGtk_'
17:59:59 <preflex>  `__stginit_gtk-0.10.1_Graphics.UI.Gtk_'
18:00:15 <FunctorSalad> heh, what is that?
18:00:41 <FunctorSalad> a, just z encoding
18:00:58 <deech> Hi all, how do I 'print' an unboxed type? Something like : print 0# ?
18:01:18 <aavogt> that symbol is probably defined by gtk2hs
18:01:45 <aavogt> FunctorSalad: so maybe it has to do with import-dirs and library-dirs being wrong after you moved stuff
18:02:16 <pastorn> i hate working with abs
18:03:14 <FunctorSalad> aavogt: hmm there are header files there, but something could still be out of sync about the different installations and possibly versions...
18:03:22 <pastorn> i want three functions that has this behaviour: http://en.wikipedia.org/wiki/File:HSV-RGB-comparison.svg
18:03:37 <FunctorSalad> the gtk header files should still be in the /usr hierarchy; they are still from debian
18:04:12 <aavogt> @hackage Colour
18:04:12 <lambdabot> http://hackage.haskell.org/package/Colour
18:04:13 <FunctorSalad> hmm I should try with a fresh gtk2hs rather than apt-get source libghc6-gtk, maybe
18:04:23 <aavogt> @hackage colour
18:04:24 <lambdabot> http://hackage.haskell.org/package/colour
18:04:58 <micah> does anyone know why my parsec error messages would look like this:
18:05:03 <micah> unexpected [((line 1, column 1),if)]
18:05:05 <pastorn> aavogt: <3 <3 <3
18:05:35 <aavogt> :)
18:05:45 <FunctorSalad> (to make it even more ridiculous, I identified haskell/lib with /usr/local/lib now using mount --bind, so libs will go to the right place in the future o_o)
18:05:58 <pastorn> "Colour" <3 <3 <3
18:06:03 <pastorn> awesome brittish spelling :D
18:06:35 <monochrom> colour. rigour.
18:06:40 <danderson> and by british spelling you mean correct spelling, right? :P
18:06:45 <deech> I just tried searching Hayoo for a function with the signature : Int# -> Int. Nothing.
18:06:57 <monochrom> yes, british spelling is correct spelling and vice versa
18:07:03 <FunctorSalad> deech: the constructor
18:07:20 <aavogt> manour?
18:07:27 <danderson> Excellent, I'm happy we agree.
18:07:28 <FunctorSalad> deech: GHC.Types.I
18:07:47 <monochrom> deech: I believe you should box it and then use show or print. Perhaps show (I# your_Int#_here)
18:09:19 <deech> Yup that's it. Out of curiosity, where would I have found that?
18:09:21 <aavogt> I guess nobody is consistent. not even yor american spelling.
18:10:17 <aavogt> you find it in #haskell# the channel for ghc primitives
18:11:01 <aavogt> deech: what is your reason to mess around with unboxed things anyways?
18:12:27 <Kruppe> I am trying to reverse a lambda calculus style list without recursion, here is my attempt up to now: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24457#a24457 I get an error along the lines of: Couldn't match expected type `ListN a1' against inferred type `l -> (a1 -> l -> l) -> l'. Can anyone point me in the right direction?
18:13:18 <deech> aavogt: just toying around with an issue proposed on the haskell-cafe thread : http://www.haskell.org/pipermail/haskell-cafe/2010-March/075151.html.  I found that using bang patterns as suggested by someone on the group didn't do a thing to speed up the program so I'm trying unboxed integers to see what happens.
18:13:34 <MisterN> Kruppe: how about using fix?
18:14:01 <Kruppe> MisterN: that would be using recursion, I'm trying to do it without.
18:14:02 <monochrom> I read the haddock of GHC.Prim etc. to learn of I#. And GHC user manual for unboxed types.
18:14:44 <MisterN> Kruppe: does it work?
18:14:56 <Kruppe> MisterN: does what work?
18:15:42 <MisterN> your attempt
18:15:51 <Kruppe> MisterN: the functions there worked (at least in some previous close form) with cases like [] and (:)
18:16:05 <Kruppe> MisterN: but won't work while staying as a lambda abstraction
18:16:11 <Kruppe> MisterN: or whatever you call it
18:17:01 <MisterN> Kruppe: have you tried implementing length first?
18:17:02 <Kruppe> MisterN: so foldlN (+) 0 (consN 2 $ consN 1 nilN) = 3
18:17:46 <Kruppe> MisterN: I've gotten map to work, and also append, but I have not tried length.
18:18:35 <Kruppe> MisterN: what I want is foldlN (flip consN) nilf <some lambda abstracted list>) to work
18:18:39 <MisterN> Kruppe: interesting exercise
18:18:53 <Kruppe> MisterN: yeah, im reaaaaaaaaaaaaal close, I'm just running into type errors
18:19:25 <Kruppe> MisterN: it works with an actual type and constructor like (:) or []
18:19:43 <Kruppe> MisterN: but not with my "homemade" lambda style lists :(
18:20:17 <Kruppe> MisterN: oh well, ill puzzle over it some other time if no one has ideas
18:20:20 <MisterN> Kruppe: why do you waste space with the foralls btw?
18:21:10 <Kruppe> MisterN: actually I'm not sure, someone started me off with the cons and nil that you see there, just been following his style
18:22:22 <MisterN> Kruppe: hmm i think i have an idea
18:23:26 <Kruppe> MisterN: oh yeah?
18:24:18 <MisterN> Kruppe: ah wait i must see
18:27:58 <MisterN> Kruppe: ok that's definitely weird, it wants ListN a but l -> (a -> l -> l) -> l is the same thing
18:28:23 <Kruppe> MisterN: yup, it's pretty weird
18:28:25 <MisterN> Kruppe: ListN seems to be an existential type, maybe that's why?
18:28:37 <Kruppe> MisterN: yeah could be
18:28:44 <MisterN> Kruppe: have you tried using newtype to clean things up?
18:28:46 <monochrom> but "ListN a" has an extra forall.
18:29:35 <MisterN> monochrom: well the l->(a->l->l)->l was ListN a in the code
18:29:42 <MisterN> consN:: forall a. a -> ListN a -> ListN a
18:29:48 <MisterN> becomes
18:29:58 <MisterN> consN :: a -> ListN a -> l -> (a -> l -> l) -> l
18:30:37 <Kruppe> MisterN: right, which is why it gets confused
18:34:13 <MisterN> Kruppe: ok i fail at trying to transpose this into a newtype
18:34:25 <micah> can anyone help me with my parsec error problems
18:34:48 <Kruppe> MisterN: haha, its ok
18:35:02 <aavogt> micah: you have not pasted your code yet, right?
18:35:06 <micah> no
18:35:17 <MisterN> Kruppe: i'm sure the more experienced types here can do that
18:35:18 <Kruppe> MisterN: I'm not sure this can be done in haskell anyways
18:35:35 <Kruppe> MisterN: at least the folds work on paper!
18:35:48 <MisterN> Kruppe: i think it can be done in haskell
18:36:00 <MisterN> you have to get the newtype right and enable the existential stuff
18:36:06 <micah> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24458#a24458
18:37:16 <Kruppe> MisterN: yeah I'll read about those and see if I can get anywhere
18:38:17 <pastorn> how do i cast between different float types?
18:39:11 <kmc> by "cast" you mean "convert"?
18:39:12 <kmc> :t fromRational
18:39:13 <lambdabot> forall a. (Fractional a) => Rational -> a
18:39:17 <pastorn> cool
18:39:19 <pastorn> thanks
18:39:32 <pastorn> also: i'm having butloads of trouble
18:39:36 <kmc> > let x :: Double; x = 3.5; y :: Float; y = fromRational x in y
18:39:37 <lambdabot>   Couldn't match expected type `GHC.Real.Rational'
18:39:37 <lambdabot>         against inferred t...
18:39:40 <kmc> hmm
18:39:41 <pastorn> import qualified Data.Colour.RGBSpace.HSV as C
18:39:51 <pastorn> but i can't catch the RGB constructor
18:40:04 <kmc> > let x :: Double; x = 3.5; y :: Float; y = fromRational $ toRational x in y
18:40:05 <lambdabot>   3.5
18:40:09 <pastorn> and i can't use any of hte selector functions ?
18:40:09 <kmc> :t fromRational . toRational
18:40:10 <lambdabot> forall a a1. (Fractional a, Real a1) => a1 -> a
18:40:25 <kmc> pastorn, catch?
18:40:27 <kmc> what do you mean
18:40:34 <pastorn> kmc: i'm using OpenGL
18:40:34 <kmc> you'd have to qualify their names with C.
18:40:43 <pastorn> kmc: doing that, doesn't work
18:40:56 <kmc> Colour is abstract but RGB is not
18:41:04 <kmc> pastorn, can you hpaste yoru code
18:41:12 <MisterN> > (fromRational . toRational) 4.0
18:41:13 <lambdabot>   4.0
18:41:20 <MisterN> > (fromRational . toRational) 4%2
18:41:21 <lambdabot>   Ambiguous type variable `a' in the constraints:
18:41:21 <lambdabot>    `GHC.Real.Integral a'
18:41:21 <lambdabot>   ...
18:41:29 <pastorn> degToCol3 deg = Color3 r g b
18:41:31 <pastorn>   where (C.RGB r g b) = C.hsv deg 1 1
18:41:31 <micah> aavogt: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24458#a24458
18:41:36 <pastorn> kmc:
18:41:38 <pastorn> ^^
18:41:51 <kmc> err, where's Color3 from?
18:41:57 <pastorn> OpenGL
18:42:03 <kmc> oh
18:42:07 <kmc> what's the error?
18:42:17 <kmc> oh sorry
18:42:18 <pastorn> Not in scope: data constructor `C.RGB'
18:42:23 <kmc> the RGB type in RGBSpace.HSV *is* abstract
18:42:29 <kmc> the one in RGBSpace isn't
18:42:35 <pastorn> whut?
18:42:39 <kmc> read the docs
18:42:42 <kmc> http://hackage.haskell.org/packages/archive/colour/2.3.1/doc/html/Data-Colour-RGBSpace-HSV.html
18:42:45 <kmc> "data RGB a"
18:42:51 <kmc> http://hackage.haskell.org/packages/archive/colour/2.3.1/doc/html/Data-Colour-RGBSpace.html
18:42:55 <kmc> "data RGB a = RGB { ... stuff ... }"
18:43:27 <pastorn> oh, no constructors ore expored...
18:43:52 <pastorn> ok, so i need another import for just the constructor
18:44:19 <kmc> they're not the same type i don't think
18:44:25 <kmc> you're prolly supposed to use hsvView
18:44:27 <pastorn> awww
18:44:50 <pastorn> no, i want the RGB values
18:45:26 <pastorn> given a degree i want to get the RGB corresponding to (hsv deg 1 1)
18:45:42 <micah> does anyone know how to help me? I have no idea how to solve this problem :(
18:48:18 <pastorn> micah: what are you trying to do?
18:48:25 <micah> well I am using this code
18:48:26 <micah> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24458#a24458
18:48:29 <micah> with parsec
18:48:32 <micah> on a list of tokens
18:48:38 <micah> but it's giving errors like this
18:48:45 <micah> unexpected [((line 1, column 1),if)]
18:48:55 <fax> how do I check if a double is an integers?
18:49:18 <pastorn> fax: what are you even talking about?
18:49:37 <dancor> :t floor
18:49:38 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
18:49:46 <pastorn> micah: try not indenting your where clauses as much, perhaps?
18:49:54 <dancor> > let x = 4.5 :: Double in floor x == x
18:49:55 <lambdabot>   No instance for (GHC.Real.Integral GHC.Types.Double)
18:49:55 <lambdabot>    arising from a use ...
18:50:06 <dancor> > let x = 4.5 :: Double in fromIntegral (floor x) == x
18:50:07 <lambdabot>   False
18:50:11 <dancor> > let x = 4.0 :: Double in fromIntegral (floor x) == x
18:50:11 <lambdabot>   True
18:50:15 <dancor> > let x = 4.000000000000000000000001 :: Double in fromIntegral (floor x) == x
18:50:16 <lambdabot>   True
18:50:19 <micah> pastorn: that wouldn't be the problem, though, would it?
18:50:26 <dancor> > let x = 4.000000000000000000000001 in fromIntegral (floor x) == x
18:50:27 <lambdabot>   True
18:50:27 <pastorn> micah: tried it?
18:50:40 <dancor> > let x = 4.000000000000000000000001 :: CReal in fromIntegral (floor x) == x
18:50:42 <lambdabot>   False
18:50:45 <dancor> nice!
18:50:54 <MisterN> instance Ord Double
18:50:55 <dancor> i guess Ratio is saner
18:50:59 <MisterN> i think that's evil
18:51:04 <fax> thanks!
18:51:06 <dancor> > let x = 4.000000000000000000000001 :: Rational in fromIntegral (floor x) == x
18:51:07 <lambdabot>   False
18:51:07 <MisterN> because clearly Double is not ordered.
18:51:08 <pastorn> micah: don't mess with the indentation gods
18:51:16 <pastorn> oh, i see it
18:51:19 <micah> pastorn: so how should wheres be indented?
18:51:19 <dancor> sanity and correctness, who could ask for anything more
18:51:45 <pastorn> micah: i'll modify your paste, hang on
18:51:49 <micah> k
18:52:42 <pastorn> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24458#a24459
18:53:15 <aavogt> that's not the problem though
18:53:24 <pastorn> micah: i think your error might have been that showTok and posFromTok appears on different columns in teh first
18:53:30 <pastorn> if that's the error
18:53:43 <micah> no they were on the same
18:54:02 <micah> hpaste has screwed up my indents like that before
18:55:58 <MisterN> interesting, sort is stable to nan
18:56:02 <micah> pastorn: it compiles just fine
18:56:12 <aavogt> > let a = x where x = 1 in a
18:56:13 <lambdabot>   1
18:56:22 <aavogt> pastorn: you don't have to indent where at all
18:56:22 <MisterN> the nans will be in random places, but otherwise the result is sensible
18:56:34 <micah> pastorn: but the parsec parsing errors say `unexpected [((line 1, column 1),if)]` instead of `unexpected if`
18:58:05 <pastorn> micah: hmmm..
18:58:08 <aavogt> why don't you paste code to reproduce this actual error?
18:58:24 <micah> well here's the problem
18:58:29 <micah> it runs and compiles fin
18:58:30 <micah> fine
18:58:43 <micah> and parses almost perfectly (although I'm still debugging the parsing abit)
18:58:45 <micah> but then
18:58:46 <pastorn> micah: can has code + test string
18:58:49 <micah> when it gives a parsing error
18:58:52 <micah> it gives that
18:59:00 <micah> unexpected [((line 1, column 1),3.0)]
18:59:06 <micah> unexpected [((line 1, column 1),"asdf")]
18:59:08 <micah> anything
19:07:39 <aavogt> micah: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24458#a24460
19:09:23 <micah> hmm
19:09:28 <micah> did you change match or advance at all?
19:09:45 <micah> I should put some more of my code there I guess
19:10:37 <Darkone> Well, I haven't nuked windows yet. Seems like a victory, I suppose!
19:11:10 <Darkone> Currently restoring my logical image to a new active primary partitio
19:11:19 <micah> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24458#a24461
19:11:37 <kmc> i would think that nuking windows would be the victory
19:11:50 <micah> wow windows bashing
19:11:51 <micah> that's original
19:12:24 <kmc> yeah, sharing opinions about what you like and dislike is played out
19:12:36 <kmc> in other news, Haskell is great and C++ sucks, please discuss
19:12:37 <aavogt> then stop it
19:13:04 <micah> watf is up with hpaste's indentation mungin
19:13:05 <micah> g
19:13:49 <clarkb> tab interpretation?
19:13:58 <micah> tab screwing up
19:14:02 <kmc> don't use tabs
19:14:05 <micah> I dont'
19:14:11 <kmc> (tab bashing, how original)
19:14:13 <Cale> hpaste doesn't touch your indentation. You shouldn't have any tabs in your source.
19:14:16 <micah> although I think using spaces is rather hacky
19:14:21 <micah> kmc: wow
19:14:33 <micah> I don't use tabs
19:14:39 <micah> although I don't see why they are bad...
19:14:56 <clarkb> because they can be interpreted different by different things
19:14:58 <micah> although without something like elastic tabstops they're uglier
19:14:59 <kmc> tabs are a poor substitute for actual dynamic alignment constraints in text
19:15:00 <dancor> @unpl ((.) . (.))
19:15:00 <lambdabot> (\ i b c f -> i (b c f))
19:15:05 <Cale> They're bad because it matters how things align vertically
19:15:05 <clarkb> is a tab 4 8 2 or 3 spaces?
19:15:06 <micah> kmc: yes I agree with that
19:15:15 <micah> clarkb: if they're all tabs
19:15:21 <dancor> @unpl ((.) .)
19:15:21 <micah> clarkb: it's equivalent to 1 space
19:15:21 <lambdabot> (\ d g b c -> d g (b c))
19:15:25 <dancor> @unpl (. (.))
19:15:26 <lambdabot> (\ d g -> d (\ b c -> g (b c)))
19:15:29 <kmc> Haskell says a tab is 8 spaces
19:15:35 <micah> clarkb: so don't mix tabs and spaces, especially with meaningful indentation
19:15:41 <kmc> but is also invariant under changing all the whitespace by a constant multiple
19:15:50 <micah> clarkb: don't never use tabs
19:15:52 <kmc> so if you only use tabs and they look like 4 to you, it will still work
19:15:59 <clarkb> I dont.
19:16:07 <kmc> but people will yell at you anyway
19:16:19 <Darkone> Is back.
19:16:34 <aavogt> kmc: maybe not if you have ex:      function name = do x\n\t\ty
19:16:38 * clarkb wonders how it became assumed he used tabs
19:16:52 <Darkone> I like the tab -> x space thing that pretty much all good editors can do
19:16:56 <dancor> how bad is it that i want to go from Typeable's TypeRep to TH's Type
19:17:10 <micah> I think the tab vs spaces debate is pretty retarded; spaces are incredibly messy but are the only good way to do it with aligning things the way you do in haskell, lisp, etc. it would be much better to have a dynamic indentaiont system
19:17:12 <dancor> and how hard would it be to implement that correctly
19:17:14 <micah> but alas, we use crappy text files
19:17:21 <micah> clarkb: I never said you use tabs
19:17:27 <Cale> People will yell at you anyway, because the layout that you'll be forced to use if you want to use *only* tabs and have everything still work looks really ugly
19:17:28 <micah> clarkb: I was saying don't /never/ use tabs
19:17:28 <Darkone> Also, Windows 7 works fantastically for me.
19:17:40 <Cale> You have to put a newline after 'let', for example, which is awful.
19:17:48 <micah> Cale: that's why Id on't use them with haskell
19:17:53 <Cale> yeah
19:17:55 <Darkone> micah, looks pretty nice in NP++
19:18:12 <micah> Darkone: what does?
19:18:14 <Darkone> I was suprised that win7 was on a logical partition :<
19:18:22 <Darkone> micah, spaces.
19:18:36 <monochrom> If NP=P, does NP++ > P?
19:18:47 <micah> Darkone: not saying they look bad; actualy looking nicer than tabs when aligning things is the reason why I use them
19:18:48 <clarkb> monochrom: yes :P
19:18:50 <Darkone> It handles spacing like tabs, in terms of lining up and showing... uhh... the vertical ruler lines?
19:19:15 <micah> Darkone: so does editra, which I use :) not saying they don't look good
19:19:15 <monochrom> Oh notepad++
19:19:16 <aavogt> no, doesn't the destructive update happen after?
19:19:18 <Darkone> I wish I had cought the logical partition thing earlier.
19:19:19 <dancor> i wonder how much signal i would miss if i blocked all irc lines with "tab"
19:19:24 <micah> Darkone: but they're a crappy solution
19:19:35 <Darkone> This is such a pain :/
19:19:47 <Darkone> Holy gods, 8% completed :O
19:19:57 <Darkone> I AM IN SHOCK at the rapidity of this restore :V
19:21:12 <aavogt> dancor: sounds feasible
19:21:25 <aavogt> regarding the Typeable a -> Type
19:21:27 <Darkone> Also: Gparted - really nice tool, and using the parted magic thingy for it looks fantastic.
19:21:28 <micah> so from http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24458#a24462 (ignore the messed up indentation :P) can anyone tell me the reason why I'm getting unexpected [((line 1, column 1),if)] instead of unexpected if
19:21:55 <Darkone> But. It made me chkdsk D: before it would rsize it :|
19:22:02 <Darkone> With no way to override.
19:22:05 <Darkone> >.<
19:22:23 <aavogt> micah: well what is garbage?
19:22:32 <micah> aavogt: whitespace, comments, etc.
19:22:46 <aavogt> if you actually want to solve your problem, perhaps you should paste code that reproduces your incorrect behavior
19:23:28 <aavogt> as is, your pasted code doesn't help anybody help you
19:23:55 <micah> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24463#a24463
19:24:01 <aavogt> dancor: but how much use is Type in template haskell anyways?
19:24:43 <dancor> aavogt: well i know nothing but it seems to me like if you want to make use of both a value and a type in TH, then you have to do like $(myTHFunc x 'x)
19:24:53 <dancor> if x = 4 :: Int
19:25:04 <dancor> and the splice should generate something using both the "4" and the "Int"
19:25:06 <dancor> is that true?
19:26:24 <aavogt> dancor: if you're given  'x, you can get x with   $(varE 'x)
19:26:32 <dancor> oh
19:29:59 <aavogt> but there is still a sensible translation from TypeRep -> Type
19:30:42 <aavogt> I was considering that it might be useful for having multiple inline splices in the same file that give a polymorphic result
19:31:02 <FunctorSalad> I get (line 1,col 1) errors from fundep violations... can be hard to locate
19:31:08 <FunctorSalad> (@micah)
19:31:15 <FunctorSalad> or was it (line 0, col 0)
19:31:28 <micah> fundep?
19:31:51 <FunctorSalad> micah: sorry hadn't looked at your paste. Thought this was about ghc errors
19:31:57 <FunctorSalad> functional dependency
19:32:00 <micah> oh ok
19:32:33 <siracusa> micah: Isn't it the token function producing this output?
19:34:21 <micah> no
19:34:38 <micah> if it were it'd say "Lexing error ():"
19:34:42 <micah> because I made it that way
19:42:40 <aavogt> micah: well when many getToken fails to match anything, the eof parser fails
19:42:52 <aavogt> and it shows its input when it does
19:44:31 <aavogt> see here: file:///home/aavogt/.cabal/share/doc/parsec-3.1.0/html/src/Text-Parsec-Combinator.html#eof
19:44:40 <dancor> aavogt: i think Typeable a -> Type might still help when you want to do TH stuff using the values and types of a heterogenous collection..
19:44:50 <aavogt> err, not my own documentation ;)
19:45:50 <dancor> inp = [MyBox (4 :: Int), MyBox "hi"]; main = print $ $(myTHFunc 'inp) -- returns something making use of all of "4", "Int", "hi", "String"
19:46:37 <aavogt> http://hackage.haskell.org/packages/archive/parsec/3.1.0/doc/html/src/Text-Parsec-Combinator.html#eof
19:47:05 <aavogt> eof doesn't know what you've done with token
19:47:21 <fax> Does anyone know Q?
19:47:25 <fax> "the constant encountered in digital tree searching"
19:47:30 <aavogt> Q is a monad
19:47:44 <dancor> lol
19:48:36 <dancor> i can't imagine what would be "the" constant of interest in digital tree search
19:48:43 <fax> me neither!
19:48:47 <aavogt> dancor:  data MyBox = forall a. Typeable a => MyBox a
19:48:58 <aavogt> or something else?
19:49:26 <dancor> aavogt: ya that
19:50:01 <dancor> acutally i didn't even qualify with Typeable and it still worked for me, maybe i should have (PolyOpt at http://github.com/dancor/polyopt/blob/master/src/Data/PolyOpt.hs)
19:52:16 <aavogt> right, you don't need the argType field if you require things to be Typeable
19:52:43 <aavogt> I mean when you do data PolyOpt = forall a. Typeable a => PolyOpt (PolyOptA a)
19:53:19 <dancor> right
19:53:57 <aavogt> but perhaps a better question is why you need the Type in the first place
19:54:33 <aavogt> there's some stuff to expand type synonyms either in haskell-src-meta or derive
19:54:56 <aavogt> I think it's more likely to be in the former
19:55:10 <dancor> i don't need argType, i could just do tOf in argToType..
19:56:06 <dancor> ooh parseType
19:56:18 <aavogt> I don't believe it's legal to make everything a ConT
19:56:41 <aavogt> I guess if you want to restrict yourself to monomorphic records
20:02:11 <dancor> the other question is if i should use Dynamic
20:02:23 <dancor> for the box type
20:02:54 <dancor> oh well actually what i'm doing is different i guess
20:07:21 <micah> aavogt: sorry, I was gone
20:10:36 <aavogt> you understand that the problem is that the eof parser showS the input that was unconsumed?
20:24:19 <dancor> aavogt: well i'm pretty happy with it now, using parseType.  thanks!
20:38:54 <bmh> Could someone explain why Data.Sequence doesn't have a `toList` function?
20:39:49 <ddarius> bmh: It does.
20:39:53 <aavogt> use it's Foldable instance
20:40:38 <bmh> aavogt: a-ha, ddarius: I'm looking at the docs, it has fromList, but not toList
20:40:56 <c_wraith> @src Foldable
20:40:56 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
20:41:04 <aavogt> @hoogle toList
20:41:04 <lambdabot> Data.Foldable toList :: Foldable t => t a -> [a]
20:41:05 <lambdabot> Data.HashTable toList :: HashTable key val -> IO [(key, val)]
20:41:05 <lambdabot> Data.IntMap toList :: IntMap a -> [(Key, a)]
20:41:25 <c_wraith> well, yep.  it definitely has toList
20:41:43 <aavogt> it's probably defined as foldr (:) [] or something like that
20:41:53 <c_wraith> I was mostly curious what the typeclass defines
20:42:27 <aavogt> @hoogle foldMap
20:42:27 <lambdabot> Data.Foldable foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
20:42:28 <lambdabot> Data.Traversable foldMapDefault :: (Traversable t, Monoid m) => (a -> m) -> t a -> m
20:42:45 <aavogt> I think that function is a minimal implementation
21:43:57 <roconnor> @tell fax cool, send her a link to my thesis
21:43:57 <lambdabot> Consider it noted.
22:10:58 <roconnor> @lusers
22:10:58 <lambdabot> Unknown command, try @list
22:11:03 <roconnor> @users
22:11:03 <lambdabot> Unknown command, try @list
22:12:10 <ivanm> roconnor: that was disabled at the same time as @seen
22:25:02 <sl101> @list
22:25:02 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
22:30:29 <philo> hi
22:30:49 <philo> can anyone point to some doc explaining how to combine multiple state monad ?
22:31:33 <c_wraith> like..  nested, with StateT?  Or just combining state?
22:31:33 <ivanm> huh?
22:31:49 <AnAdorableNick> philo: hi
22:32:10 <AnAdorableNick> philo: I've written a tutorial on the subject, and I'd like to know how well it helps you
22:32:37 <AnAdorableNick> philo: http://strabismicgobbledygook.wordpress.com/
22:33:12 <ivanm> AnAdorableNick: did you steal my blog title? >_>
22:33:24 <philo> AnAdorableNick:  thanks i will sure to write a comment there
22:33:39 <ivanm> and where did you get that nick from? :s
22:33:44 <AnAdorableNick> philo: Thanks!  I hope it helps you :)
22:33:58 <AnAdorableNick> ivanm: I had no idea you even had a blog :)
22:34:09 <mjonsson> Are there any operators X that combines predicates using logical connectives for example such that (p1 X p2) v = p1 v && p2 v?
22:34:19 <AnAdorableNick> ivanm: That title's completely original; wasn't stolen from anybody
22:34:36 <ivanm> well, I have something similar :p : http://ivanmiljenovic.wordpress.com/
22:35:14 <ivanm> @pl \ p1 p2 v -> p1 v && p2 v
22:35:15 <lambdabot> liftM2 (&&)
22:35:21 <ivanm> mjonsson: ^^
22:35:22 <mjonsson> more concretely, something like (isAlphaNum || isSymbol) character instead of isAlphaNum character || isSymbol character
22:35:22 <ivanm> not an operator though
22:35:42 <ivanm> and you said &&... || /= && :p
22:35:56 <mjonsson> well, i was talking about logical connectives in general
22:36:03 <c_wraith> :t on (||) even (>1)
22:36:04 <lambdabot> forall a. (Integral (a -> Bool), Num a, Ord a) => (a -> Bool) -> Bool
22:36:18 <kmc> :t ((||) `on`)
22:36:19 <lambdabot> forall a. (a -> Bool) -> a -> a -> Bool
22:37:01 <kmc> :t let (&&&) = liftM2 (&&) in even &&& (>1)
22:37:01 <ivanm> c_wraith: oooh, didn't think about using on
22:37:02 <lambdabot> forall a. (Integral a) => a -> Bool
22:37:12 <ivanm> > liftM2 (||) isAlphaNum isSymbol ' '
22:37:14 <lambdabot>   False
22:37:24 <ivanm> kmc: isn't &&& taken though?
22:37:32 <kmc> yeah
22:37:34 <kmc> :t (&&&0
22:37:35 <lambdabot> parse error (possibly incorrect indentation)
22:37:35 <kmc> :t (&&&)
22:37:36 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
22:37:40 <c_wraith> only if you import Control.Arrow
22:37:45 <kmc> which you should
22:37:54 <kmc> because it's useful for the (->) arrow, if not for any others ;P
22:38:05 <philo> AnAdorableNick:  sadly your tuto doesnt cover state lifting ... the part i am looking for
22:38:22 <mjonsson> seems that there is no nice such notation predefined
22:38:36 <kmc> mjonsson, yeah, perhaps in some standard library though
22:38:46 <kmc> none i know of
22:38:54 <mjonsson> it's not worth it for me to define it myself yet (defining it would just make my code more complex as i only have one use case so far)
22:39:29 <ivanm> I don't think such an operator would be of general use enough to make it part of a standard library
22:39:44 <mjonsson> it would be cool if Bool and a->Bool were members of a "Logical" typeclass with operators "not", &&, || etc
22:39:53 <kmc> oh come on, defining an ultra general combinator and using it only once is part of the fun of Haskell
22:40:03 <kmc> mjonsson, you can play with that if you like
22:40:08 <kmc> personally i think that that way lies madness
22:40:19 <mjonsson> why do you think it will lead to trouble?
22:40:30 <kmc> it will allow more errors to slip through the typechecker
22:40:47 <kmc> it makes code harder to read
22:41:12 <aavogt> well regardless of kmc's fears, it will make error messages less precise
22:41:15 <mjonsson> it's what people do all the time in natural language though
22:41:27 <kmc> natural language is an exceedingly poor model for how to express ideas precisely
22:41:53 <aavogt> @hackage applicative-numbers
22:41:53 <lambdabot> http://hackage.haskell.org/package/applicative-numbers
22:42:30 <kmc> it means that a function's behavior is determined not by its value alone but by what's in the surrounding types, which are usually not even written
22:43:12 <pastorn> When looking at the OpenGL bindings i'm just getting more and more confused
22:43:27 <aavogt> that tends to be the case anyways
22:43:34 <kmc> in Perl they put in a lot of effort to overload notation and make the implementation guess what the programmer means
22:43:36 <aavogt> @type (+)
22:43:37 <lambdabot> forall a. (Num a) => a -> a -> a
22:43:41 <pastorn> why is it littered with `Ptr a` and never any `IORef a`. Why is it like this?
22:43:46 <kmc> and the result is that the implementation has even more rules and the programmer has to learn them
22:43:51 <kmc> pastorn, haddock link?
22:43:55 <pastorn> isn't IORef more haskell-y?
22:44:17 <kmc> pastorn, well, if you're using OpenGLRaw, don't expect the Haskelly interface
22:44:20 <pastorn> kmc: http://hackage.haskell.org/packages/archive/OpenGL/2.4.0.1/doc/html/Graphics-Rendering-OpenGL-GL-VertexArrays.html
22:44:27 <kmc> ah, good, that's not Raw
22:44:28 <pastorn> kmc: well, i'm not
22:44:58 <pastorn> but it should be!
22:45:02 <aavogt> hmm, is Ptr overloaded in Data.StateVar?
22:45:20 <aavogt>  or an instance of whatever classes you have for $=
22:45:49 <kmc> pastorn, well, this module deals with vertex arrays, which OpenGL expects to be in contiguous chunks of memory in a particular format
22:45:55 <kmc> IORef wouldn't match that
22:46:01 <kmc> maybe they should be using StorableArray or similar
22:46:36 <pastorn> ok, so i can accept that i have to use arrays (for not making infinite stuff possible and size stuff)
22:47:06 <mjonsson> kmc, i can see your points, but i'm not sure i'm convinced. Perhaps set theory is a better way of talking about this than predicates. It would be character `elem` (alphaNums `union` symbols)
22:47:21 <pastorn> kmc: well then why don't they just cast between Ptr and IORef?
22:47:28 <pastorn> that should be possible, right?
22:47:30 <mjonsson> anyway, i'll do p1 x && p2 x for now
22:47:36 <kmc> pastorn, i don't see why it would
22:47:44 <kmc> you mean with unsafeCoerce, or something smarter?
22:47:58 <pastorn> i'm not that great with either IORef or Ptr
22:48:07 <kmc> well, they are not very similar types
22:48:11 <pastorn> so i don't really know anything here...
22:48:15 <kmc> IORef is a type-safe, memory-safe reference cell
22:48:19 <kmc> Ptr is an actual C-like pointer
22:48:23 <pastorn> ah
22:48:37 <pikhq> Isn't Ptr... An *actual C pointer*?
22:48:38 <kmc> you can cast Ptrs, do pointer arithmetic, and pass them to C functions as pointers, etc.
22:48:47 <kmc> you can write a one-line segfault with Ptr
22:49:06 <kmc> IORef is not really a "pointer", it's the name of a box, somewhere, into which you can put in and take out valuse
22:49:19 <kmc> where that box lives in memory, whether it's even contiguous or how it's layed out, is still hidden
22:49:42 <pastorn> still would feel more nice with IORef
22:49:48 <BMeph> pastorn: Welcome to the world of bindings! ;)
22:49:54 <pastorn> me not being able to shoot myself in the foot etc.
22:50:00 <kmc> pastorn, you should write into the OpenGL committee and complain
22:50:07 <pastorn> http://web.student.chalmers.se/~goranssa/VArray.hs <-- from the examples folder in GLUT
22:50:09 <kmc> ;)
22:50:19 <pastorn> haha
22:50:32 <Jafet> Just port mesa to haskell
22:50:43 <pastorn> well, i would expect that for this kind of thing, a haskelly thing would be
22:50:47 <kmc> anyway i don't disagree, but it might be the role of the layer above OpenGL
22:50:55 <kmc> then again OpenGL is the layer above OpenGLRaw
22:51:11 <pastorn> bindVertices :: Vertex v => [v] -> IO GLuint
22:51:17 <pastorn> or similar
22:51:40 <BMeph> mjonsson: So, what do you have against liftM2? ;)
22:51:48 <pastorn> kmc: maybe i'm expecting too much here :/
22:51:58 <kmc> pikhq, well, in GHC a value like (Ptr a) is still a boxed value with a closure in the heap with an info ptr, etc.
22:52:11 <kmc> so it's not really an actual C pointer, but contains one
22:52:20 <pastorn> but still... why should I, as a haskeller, go and mess with low level stuff just to get performance?
22:52:21 <pikhq> Mmkay.
22:52:37 <pastorn> this seems stupid to me :)
22:52:45 <pikhq> pastorn: When the performance is absolutely necessary, and you'd prefer not to do it in C.
22:53:10 <kmc> pastorn, i agree that some kind of StorableArray might be better than Ptr
22:53:23 <pastorn> pikhq: well, all i want to do is shuffle my vertices and indices to my gfx memory in a cleaner way
22:53:27 <kmc> i don't know in depth what's going on here
22:53:42 <pastorn> that can be however expensive it wants, since it's all done during loading time :)
22:53:52 <pikhq> pastorn: Well, then. You clearly don't care about performance, you just want a decent library.
22:54:04 <pikhq> Yell at whoever is responsible for the OpenGL bindings. :P
22:54:09 <kmc> this documentation is... lacking
22:54:20 <pastorn> kmc: where?
22:54:25 <pastorn> VArray.hs?
22:54:31 <pastorn> or in the OpenGL bindings?
22:54:31 <kmc> no, the library module you linked
22:54:36 <ddarius> I don't think those particular bindings are the way they are for performance reasons.
22:54:46 <mjonsson> BMeph: "liftM2 (||) isAlphaNum isSymbol character" is less readable than "isAlphaNum c || isSymbol c"
22:54:48 <pastorn> kmc: "This module corresponds to section 2.8 (Vertex Arrays) of the OpenGL 2.1 specs. "
22:54:52 <ddarius> I think someone just hasn't gotten around to making convenience functions.
22:55:01 <pastorn> kmc: but you're right, it does lakc
22:55:56 <pastorn> ddarius: Graphics.Rendering.OpenGL.GL.Convenience ?
22:57:11 <pastorn> or maybe GLUT.Extras
22:58:42 <ddarius> pastorn: I imagine they'd go in the same module.
22:59:11 <ddarius> I suspect that that module is the kind of thing OpenGLRaw (now) handles but was made before OpenGLRaw existed.
22:59:17 <pastorn> ddarius: could i propose this for a SoC project?
22:59:40 <ddarius> It's not something that would require a Summer of Code project.
22:59:44 <ddarius> But you can propose it.
22:59:47 <pastorn> heh
23:00:15 <ivanm> preflex: seen malcolmw
23:00:16 <preflex>  malcolmw was last seen 4 days, 16 hours, 40 minutes and 28 seconds ago, saying: <private message>
23:00:46 <superoptimizer> in #haskell
23:00:58 <ivanm> preflex: xseen malcolmw
23:00:59 <preflex>  malcolmw was last seen on freenode 4 days, 16 hours, 41 minutes and 10 seconds ago, saying: <private message>
23:01:12 <ivanm> hmmm, xseen doesn't say which channel... so must have been a /msg preflex
23:01:33 <ddarius> ivanm: That's what it's saying.
23:01:46 <ivanm> yeah, wasn't quite sure, that's all
23:02:43 <ddarius> pastorn: Basically, the convenience functions should be in OpenGL and the raw bindings should be in OpenGLRaw and that's probably what will happen with time, but that transition hasn't happened yet.
23:04:00 <pastorn> ddarius: sounds about right...
23:04:03 <aavogt> preflex: seen aavogt
23:04:03 <preflex>  aavogt was last seen 4 seconds ago, saying: <private message>
23:04:31 <ivanm> gah, worked my problem out anyway
23:05:19 <pastorn> preflex: seen preflex
23:05:19 <preflex>  what
23:05:24 <pastorn> awww
23:23:19 * ivanm bangs his head against a convenient wall
23:23:41 <Jafet> The poor wall
23:23:56 <ivanm> I'm pretty sure my html-like label stuff in graphviz is working... except my test suite keeps failing because of whitespace issues
23:24:49 * ivanm might make sure the test suite doesn't generate any whitespace characters and make the parser use whitespace as a separator
23:25:38 <ivanm> no, wait, that won't work because it needs to parse and keep all whitespace...
23:25:41 <ivanm> arrrggghhhh!!!!
23:34:17 * BMeph things ivanm fell into the dreaded "needs a Test for the test data" trap... ;)
23:34:36 * BMeph meant thinks, not things, though. :þ
23:34:45 <ivanm> BMeph: my parser is very permissive
23:34:55 <ivanm> and I'm testing that parse . print = id
23:35:19 <ivanm> so the parsed version is valid, just not exactly the same as the original
23:35:49 <c_wraith> test it the other way around, then?
23:35:54 <c_wraith> print . parse = id
23:36:01 <c_wraith> err, crap.
23:36:08 <c_wraith> you are testing it the more permissive way
23:36:11 <ivanm> c_wraith: how am I meant to generate Dot code to parse?
23:36:20 <ivanm> yeah
23:38:10 <ivanm> see, if I have something like "foo bar <BR/> blah <FONT COLOR=blue>baz, chaz</FONT> foobar", how am I meant to represent that?
23:38:58 <ivanm> atm, I use HtmlText = [HtmlTextItem] where HtmlTextItem = HtmlStr String | HtmlNewline | HtmlFont HtmlAttributes HtmlText
23:39:10 <ivanm> so, do I keep whitespaces or not?
23:39:41 <ivanm> i.e. is "foo bar" one HtmlStr value or two?
23:41:19 * BMeph wonders if "parse . print . parse" == "parse"///
23:41:46 * BMeph should have typed "..." instead of "///"
23:41:57 <ivanm> OK, let me be more explicit: I want to test that parse (print x) == x
23:42:34 * aavogt thinks BMeph means    let once = parse (print x) in   parse (print once) == once
23:42:52 <ivanm> well, yes, that should work
23:42:58 <aavogt> but that's less strict
23:43:00 <ivanm> since the same value is returned
23:43:18 <aavogt> in that your parsing could discard stuff
23:43:31 <aavogt> and still satisfy that test
23:43:40 <ivanm> the only stuff my parsing discards is stuff that print doesn't generate (comments, etc.)
23:44:25 * ivanm goes off to have a break for a bit and think about this
23:44:56 <ivanm> but I think I'll probably go with parsing "foo bar" as being two values and ensuring my test data doesn't contain whitespace in HtmlStr values
23:46:14 <aavogt> right, that's going to catch more errors
23:49:36 * BMeph thinks that this proves the point that TDD enthusiasts need more tests...to check their tests! :D
23:50:07 <ivanm> BMeph: I'm not doing TDD, but I have found _heaps_ of bugs in my printing + parsing code since I added my test suite to graphviz a few releases back
