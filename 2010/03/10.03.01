00:04:03 <dons> and on ycombinator, http://news.ycombinator.com/item?id=1158300
00:07:15 <Axman6> oh hooray, new dons post :)
00:08:59 <Axman6> dons: have you run into any major problems with the LLVM backend yet?
00:09:36 <dons> nope. there was one flag that produced segfaults, -optlo-mergereturn, but that's 1/200
00:09:44 <dons> but it is remarkably stable, imo.
00:09:57 <Axman6> yeah, i'm damn impressed
00:10:03 <dons> i'd love to do more to clean up the code we feed to llvm now, so we get more regular opts firing.
00:10:29 * Axman6 thinks David should get some cash from the IHG if they do merge it into GHC, as recognition of his great work
00:10:57 <dons> maybe David can do some SoC work, or a MSR intern over the summer
00:11:09 <Axman6> yeah, that'd be good
00:11:10 <dons> the .au government paid for this work, basically :)
00:11:24 <dons> a worthy investment.
00:11:28 <Axman6> hoping that'll be me one day
00:11:32 <profmakx> any chance of getting a proper cross-compiling-ghc with the llvm backend?
00:11:47 <dons> there is a chance yes (i have generated arm code). we need to hack the ld stuff now to get it all to link.
00:11:54 <dons> i created a SoC ticket for someone to work on this.
00:11:57 <Axman6> profmakx: i think it makes it wasier to do, though the RTS will still be pretty OS and arch specific i think
00:13:39 <dons> night all. enjoy. leave comments on the blog
00:13:47 <profmakx> night dons
00:13:55 <Axman6> g'night dons
00:14:19 <Saizan> ?hoogle unsafeAt
00:14:19 <lambdabot> No results found
00:16:41 <cads>  > map (\x -> 1/(exp(exp x))) [0.269, 0.267]
00:16:58 <cads> > map (\x -> 1/(exp(exp x))) [0.269, 0.267]
00:16:59 <lambdabot>   [0.27018317041720885,0.27089054130165435]
00:17:55 <cads> > (\x -> 1/(exp(exp x))) 0.269874
00:17:56 <lambdabot>   0.2698741862030553
00:18:07 <cads> fix (\x -> 1/(exp(exp x)))
00:18:12 <cads> > fix (\x -> 1/(exp(exp x)))
00:18:16 <lambdabot>   mueval-core: Time limit exceeded
00:18:44 <cads> just not a contraction mapping?
00:21:11 <profmakx> cads what are yuo trying to do?
00:26:19 <Saizan> fix finds only the least defined fixed point
00:26:56 <Saizan> and _|_ is a fixed point for any strict function, like that one
00:32:27 <cads> @source fix
00:32:27 <lambdabot> fix not available
00:32:39 <Axman6> @src fix
00:32:39 <lambdabot> fix f = let x = f x in x
01:20:42 * Itkovian does a happy little dance
01:22:08 <Jonno_FTW> ....
01:24:46 <Jonno_FTW> i was finishing the IRC bot tutorial
01:24:49 <Jonno_FTW> and got a type error
01:25:03 <Jonno_FTW> when using catch
01:25:10 <Jonno_FTW> loop st    = catch (runReaderT run st) (const $ return ())
01:26:57 <Saizan> something about ambiguous type variables?
01:27:53 <Jonno_FTW> yes
01:28:11 <Saizan> that's because catch got more general recently
01:28:16 <Jonno_FTW> ok
01:28:20 <Jonno_FTW> then how do i fix this?
01:28:33 <Saizan> catch (runReaderT run st) (const $ return () :: SomeException -> IO ()) -- should work
01:28:56 <Jonno_FTW> SomeException?
01:29:19 <Saizan> yes, it's the type that's at the top of the hierarchy of exceptions
01:29:32 <Saizan> even if it sounds like a place-holder :)
01:30:28 <Jonno_FTW> and i tried the problem at the end of the tutorial
01:30:38 <Jonno_FTW> where you use forkIO to make an IRC client
01:30:44 <Jonno_FTW> but I couldn't do it
01:31:45 <SubStack> @pl let f 0 = 1; f n = n * f (n - 1) in f
01:31:45 <lambdabot> ap (*) (ap id (subtract 1))
01:32:00 <Saizan> where did you get stuck?
01:32:12 <integral> @source ap
01:32:12 <lambdabot> ap not available
01:32:25 <Jonno_FTW> in the listen part i put
01:32:44 <SubStack> > ap (*) (ap id (subtract 1)) $ 5
01:32:45 <lambdabot>   Occurs check: cannot construct the infinite type: a = a1 -> a
01:32:51 <SubStack> >_<
01:34:03 <Jonno_FTW> i <- io $ forkIO interact; where interact i = do; x <-getLine; privmsg x; killThread y;
01:35:53 <Saizan> that's a type error
01:36:14 <Jonno_FTW> i fixed it up a bit
01:36:31 <Jonno_FTW> i <- forkIO interact; killThread i
01:36:40 <SubStack> @pl f n = if n == 0 then 1 else n * f (n - 1)
01:36:40 <lambdabot> f = fix (ap (flip if' 1 . (0 ==)) . ap (*) . (. subtract 1))
01:36:48 <SubStack> :t if'
01:36:49 <lambdabot> Not in scope: `if''
01:36:53 <SubStack> >_<
01:37:30 <Saizan> Jonno_FTW: i think the idea is that you should fork out a thread that sits in a loop taking commands from stdin and writing them out on the IRC Handle
01:37:43 <Saizan> Jonno_FTW: you shouldn't sync it with listen
01:37:53 <Jonno_FTW> ok
01:39:23 <Saizan> so i'd put it in "run" before calling "listen"
01:39:37 <SubStack> I may have found a practical application for pointfree programming
01:41:34 <SubStack> since it's much easier to mutate a chain of deforested function compositions than a haskell parse tree
01:41:52 <SubStack> plus now I can make all sorts of puns about chainsaws and deforestation
01:52:25 <kalven> I'm using ghci on windows and it starts a ghc.exe in the background that always hovers around 1-2% cpu usage.. What is it doing?
01:52:34 <blueonyx> hi, suppose i have a StateT [String] IO (), how can i use getLine to add a string to the state?
01:53:48 <Saizan> blueonyx: do str <- liftIO $ getLine; modify (str:)
01:53:48 <SubStack> blueonyx: pass in the line when you call one of the run state functions
01:55:19 <blueonyx> Saizan: and when i replace IO with m?
01:56:02 <blueonyx> does liftM still work? :/
01:56:19 <Saizan> liftIO would still work if m is an instance of MonadIO
01:56:29 <Saizan> ?type liftIO
01:56:30 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
01:56:48 <blueonyx> yea
01:57:13 <Vitka> @djinn Word32 -> Int32
01:57:13 <lambdabot> Error: Undefined type Word32
01:57:29 <Vitka> eh
01:57:34 <Saizan> however, liftIO is just a nice way to get the right quantity of lift's composed
01:57:36 <Saizan> ?type lift
01:57:38 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
01:57:51 <blueonyx> and how does one work with the inner Monad of a StateT in general?
01:58:00 <Saizan> lift promotes only through a single transfomer layer
01:58:12 <Saizan> lift :)
01:58:41 <Saizan> lift and liftM are both liftings in a sense, but quite different
01:58:44 <blueonyx> thanks :)
01:58:53 <blueonyx> ?type liftM
01:58:54 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
01:59:19 <blueonyx> ah
02:21:00 <blueonyx> @src return
02:21:01 <lambdabot> Source not found. Just try something else.
02:21:54 <gour> morning
02:22:53 <blueonyx> ?type liftIO
02:22:54 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
02:22:58 <araujo> morning gour
02:22:59 <araujo> :)
02:23:16 <gour> hello araujo
02:24:00 <gour> araujo: i'm thinking whether qt(haskell) might be better option if i want to develop for meego (besides desktop)?
02:25:11 <gour> anyone using qthaskell for real apps? the project is pretty close and it's not certain what is its status
02:25:23 <araujo> gour, qthaskell is good enough now?
02:26:41 <gour> araujo: i wonder about it...however there is plus of qt vs. wx for meego since there is no wxqt available
02:27:54 <Vitka> So I import ByteString qualified...
02:28:12 <Vitka> And getBytes doesn't recognize it.
02:28:33 <Vitka> How do I calm it down?
02:28:58 <Saizan> Vitka: there are two ByteString types, maybe you're mixing them up?
02:29:11 <Vitka> Hmm.
02:29:14 <Vitka> Maybe.
02:29:35 <Vitka> Do I need explictly strict BS for getBytes?
02:29:48 <Saizan> ?hoogle getBytes
02:29:48 <lambdabot> No results found
02:30:18 <Vitka> It's from Binary.Get
02:30:54 <Saizan> yeah, it gives you a strict one
02:31:32 <Saizan> ?type Data.ByteString.Lazy.fromChunks
02:31:33 <lambdabot> [BSC.ByteString] -> BSLC.ByteString
02:31:55 <Vitka> Hmm.
02:32:12 <Vitka> I need to install bytestring-strict separately I assume?
02:33:11 <Saizan> no
02:34:18 <Vitka> Is it just Data.ByteString then?
02:34:22 <Saizan> the Data.ByteString[.Char8] modules work on strict bytestrings, Data.ByteString.Lazy[.Char8] modules on lazy ones
02:35:09 <Vitka> Oh, right, I was using import without .Char8
02:35:18 <Vitka> Guess that's the problem.
02:35:47 <Vitka> Or not.
02:36:12 <Vitka> Couldn't match expected type `BSC.ByteString'  against inferred type `bytestring-0.9.1.4:Data.ByteString.Internal.ByteString'
02:36:38 <Saizan> .Char8 or not doesn't matter
02:36:57 <Vitka> > getBytes 3 >>= print
02:36:58 <lambdabot>   Not in scope: `getBytes'
02:37:13 <Saizan> if it's telling you the package name then it probably means you've two versions of bytestring installed and you're mixing them
02:37:26 <Saizan> Vitka: what does ghc-pkg list bytestring says?
02:37:31 <Vitka> Hmm, let me see.
02:38:27 <Vitka> Yeah: bytestring-0.9.1.4, bytestring-0.9.1.5
02:38:28 <int-e> maybe you have a package version mismatch?
02:38:52 <int-e> right, that would do it - best to reinstall binary then, I guess
02:39:18 <Saizan> so, binary is probably built against 0.9.1.4, while in your program you're using 0.9.1.5, since it defaults to the latest
02:39:59 <Vitka> Let's try.
02:42:30 <Vitka> Reinstalling binary did the trick, thanks. Now onto more errors. :)
02:55:27 <Jonno_FTW> what message does the client send the server or the asker when you use /version?
02:56:55 <kamatsu> ping ... > /dev/null &
02:56:58 <kamatsu> oop
02:57:03 <kamatsu> sorry
02:58:03 <Saizan> a CTCP request, iirc
03:01:37 <dancor> iIRC
03:02:24 <Jonno_FTW> ok
03:02:30 <Jonno_FTW> oh hohoh
03:07:10 <Jonno_FTW> it's not in the RFC
03:11:09 <pozic> Is there a way to get the show instance as derived by GHC for a particular type and bind it to a name?
03:11:26 <pozic> (when another show instance is already defined for that type)
03:16:36 <luqui> pozic, i am not sure what you mean
03:17:05 <luqui> you can do eg.  showInt = show :: Int -> String
03:17:16 <luqui> oh i see
03:17:26 <luqui> no, i don't believe so.
03:18:13 <luqui> i wonder if derive can do it
03:19:29 <Saizan> it should
03:19:44 <luqui> pozic, yeah, if you want to go to the trouble, TH + Data.Derive.Show could do it
03:24:40 <Jonno_FTW> i can't get my IRC bot to properly reply to version requests
03:26:24 <Jonno_FTW> actually
03:26:26 <Jonno_FTW> nvm
03:39:40 * hackagebot fullstop 0.1 - Simple sentence segmenter  http://hackage.haskell.org/package/fullstop-0.1 (EricKow)
03:48:20 <pozic> luqui: are you sure? Can't derive only generate the actual code (including instance) and not just the function?
03:49:24 <luqui> pozic, no i am not sure.  in fact it seems likely that you are correct. so you would have to go digging around in the TH tree Derive generated
03:49:54 <BONUS> wouldn't it be a lot easier to just normally derive the instance and then make your custom show function have a special name?
03:50:10 <Saizan> or newtype
03:55:02 <pozic> How do I get the height and width of a canvas (GTK2HS)?
03:55:49 * hackagebot EitherT 0.0.1 - EitherT monad transformer  http://hackage.haskell.org/package/EitherT-0.0.1 (EyalLotem)
04:00:51 * hackagebot Attrac 0.1.1 - Visualisation of Strange Attractors in 3-Dimensions  http://hackage.haskell.org/package/Attrac-0.1.1 (RubenZilibowitz)
04:40:59 <dancor> @pl \ l x -> l ++ [x]
04:41:00 <lambdabot> (. return) . (++)
04:41:17 <dancor> :t (. (:[])) . (++)
04:41:18 <lambdabot> forall a. [a] -> a -> [a]
04:43:41 <cheater> hi
04:43:56 <_mh_> hi
04:44:05 <cheater> when does my function receive bottom as one of its arguments?
04:44:53 <ibid> um, when it is given bottom as an argument?
04:45:18 <cheater> is there no special situation when it'll get bottom?
04:45:27 <ibid> there are lots of them
04:45:32 <_mh_> I'm having a strange problem using ghc 6.10.4 , if I have a function (or entering it in ghci) doing (5.0 - 4.2) < 0.8 I receive 'true' as answer. 5.0 - 4.2 is apparently 0.799999999998 for ghc... anything I can do to get 0.8 as result ?
04:45:41 <ibid> bottom is generally either a runaway recursion or an erroneous computation
04:45:42 <cheater> can you give some examples ibid?
04:45:47 <cheater> aha
04:45:56 <ibid> cheater: why do you ask?
04:46:02 <cheater> so sort of like an exception?
04:46:02 <zygoloid> cheater: "yourFunction undefined" is one way it can get _|_ as an argument
04:46:12 <cheater> oh, i was just thinking of it that's all
04:46:26 <ibid> cheater: you can catch exceptions.  you can't catch bottom
04:46:36 <zygoloid> you can't catch /some/ bottoms :)
04:46:43 <ibid> cheater: but otherwise it's similar
04:46:44 <cheater> zygoloid: so undefined is a function that returns bottom i guess?
04:46:53 <ibid> zygoloid: especially when the bottom is in fact an exception :)
04:46:58 <harlekin> _mh_, that are rounding errors you'll have with every floating point implementation. You could use Data.Ratio if you want maximum precision. However, you can only use fractionals then and they are probably slower.
04:46:59 <ibid> cheater: yes
04:47:03 <zygoloid> cheater: yes, exactly. it returns the bottom of any type
04:47:05 <ibid> cheater: so is error
04:47:13 <cheater> ibid: so if there's a bottom in my program somewhere, it will crash it no matter what?
04:47:21 <harlekin> > (5 % 1 - 42 % 10)
04:47:22 <lambdabot>   4 % 5
04:47:27 <ibid> cheater: depends on your program
04:47:40 <cheater> well
04:47:41 <ibid> cheater: if you don't use the bottom value, then it is ignored
04:47:51 <_mh_> harlekin: hmm... that would maybe be a usable solution... thank you.
04:47:55 <cheater> functions in haskell don't need to be regular do they?
04:48:07 <ibid> cheater: how do you define regular?
04:48:14 <cheater> given bottom returns bottom
04:48:24 <zygoloid> we call that strict
04:48:27 <ibid> cheater: the term for that is "strict"
04:48:32 <cheater> oh strict sorry
04:48:33 <cheater> wrong word
04:48:37 <zygoloid> and no, functions don't have to be strict. but they do have to be monotonic
04:48:53 <cheater> and what does monotonic give us?
04:49:07 <zygoloid> well, the ordering we're using is ordering-by-definedness
04:49:26 <zygoloid> and monotonic means that if x <= y then f x <= f y.
04:49:39 <cheater> oh. why do functions have to be this way?
04:49:46 <harlekin> _mh_, if you are using a fixed number of digits after the '.' then you could just use Ints, too and only use a fractional for the result.
04:49:55 <zygoloid> so if you take a function and replace its input with something less defined, the output cannot become more defined
04:50:06 <cheater> why don't we want that?
04:50:08 <zygoloid> functions have to be this way because you cannot (in pure code) test for definedness
04:50:12 <ibid> more to the point, it is (usually) impossible to construct nonmonotonic functions in haskell
04:50:20 <_mh_> harlekin: sure, just thought I could avoid doing fp the manual way.
04:50:29 <cheater> zygoloid: and?
04:50:57 <ibid> cheater: monotonicity is a theory issue
04:50:57 <zygoloid> cheater: if you try to test in any way for definedness, and the value you're testing is bottom, the result is also bottom.
04:51:26 <zygoloid> the consequence is that pure functions have to be monotonic (in terms of definedness)
04:51:45 <ibid> cheater: if your function isn't monotonic, then you break all sorts of useful mathematical properties of your program.  haskell makes it (almost) impossible to do that
04:53:04 <zygoloid> cheater: we want monotonicity because it means that functions have unique least fixed points (again under the definedness ordering)
04:53:33 <ibid> ... and lest fixed points are how recursion becomes well defined
04:53:38 <ibid> but that's again a theory issue
04:53:53 <cheater> ibid: can you give me some most useful properties that get broken by functions not being necessarily monotonic?
04:54:02 <MaciejP> Do we have a standard class for data types storing multiple elements and then a function for retrieving the elemens (e.g. as a list)?
04:54:05 <ibid> cheater: i could
04:54:13 <cheater> other than recursion/fixed points
04:54:47 <cheater> ibid: cool
04:54:50 <cheater> =)
04:55:09 <ibid> cheater: but i wonder if it makes sense to do so over irc.
04:55:24 <cheater> ibid: why not?
04:56:06 <ibid> cheater: because your qusetions indicate to me that what you really need, if you are interested in this, is to take a course (or a read a book) about denotational semantics
04:56:31 <ibid> cheater: a bit too much for me to do over irc while i'm supposed to work :)
04:56:49 <eevar2___> > ceiling $ sqrt (10::Integer)
04:56:50 <lambdabot>   No instance for (GHC.Real.RealFrac GHC.Integer.Internals.Integer)
04:56:50 <lambdabot>    arisin...
04:56:51 <cheater> ibid: i find courses are not focused enough towards my needs
04:57:05 <cheater> ibid: i've always slept through all my lectures out of boredom :p
04:57:18 <ibid> cheater: in any case, the theoretical issues are not necessary for practical haskell programming, but they do enhance one's understanding of it
04:57:32 <ibid> cheater: then i better not lecture :)
04:58:20 <cheater> ibid: if you just mention the names of some things, i'll look em up :-)
04:58:22 <zygoloid> cheater: you might wnat to read this: http://en.wikibooks.org/wiki/Haskell/Denotational_semantics (feel free to ask here if you have questions)
04:58:31 <cheater> will do
04:58:35 <ibid> cheater: look up scott domains
04:58:49 <cheater> so we don't get scott domains?
04:59:02 <ibid> cheater: and the denotational models of lambda calculus
04:59:32 <ibid> cheater: for practical programming, all you need to know is: bottom indicates an infinite or erroneous computation, and if you drop the value of a computation, it does not matter whether it was bottom or not
05:00:34 <ibid> (and you cannot, in general, detect whether a computation yields bottom or not without having the detector becoming bottom as well)
05:02:10 * cheater feels sent off
05:02:13 <cheater> :'(
05:02:32 <ibid> cheater: and sorry for my abruptness.  it's interesting stuff, but i really have to go back to work
05:03:42 <cheater> :))
05:03:44 <cheater> no problem
05:03:54 <cheater> i'm still reading that article, it's an interesting read :)
05:03:58 <ibid> cheater: (i got the impression you were looking for the practical issues.  the theory is intersting, but it felt to me like a distraction.  sorry if i misgauged your interest)
05:04:10 <cheater> =)
05:04:17 <cheater> maybe when you have a tad more time =)
05:13:24 <sergio2> Hi Haskellers!
05:13:48 <sergio2> Sorry for such a dumb question: how do I know the version of a given package?
05:14:08 <sergio2> (in my case, it's Text.ParserCombinators.Parsec)
05:14:16 <TR2N> http://donsbot.wordpress.com/2010/03/01/evolving-faster-haskell-programs-now-with-llvm/
05:17:10 <Botje> sergio2: ghc-pkg list
05:18:16 <sergio2> botje: Thanks!
05:25:17 <mreh> is the theory behind all these memoisation possible only with graph reduction?
05:25:27 <mreh> with a tree it's hard to see how it would be possible
05:28:08 <mreh> :t Memo
05:28:09 <lambdabot> Not in scope: data constructor `Memo'
05:28:44 <mreh> @src Memo
05:28:44 <lambdabot> Source not found. :(
05:29:22 <mreh> :t id :: (a -> r) -> a -> r
05:29:23 <lambdabot> forall a r. (a -> r) -> a -> r
05:29:49 <gwern> @quote zygohistomorphic.prepromorphism
05:29:49 <lambdabot> olsner says: nah, SkyNet is just a zygohistomorphic prepromorphism, nothing fancy
05:29:53 <gwern> @quote zygohistomorphic.prepromorphism
05:29:53 <lambdabot> roconnor says: sounds like you need a zygohistomorphic prepromorphism
05:30:00 <gwern> @quote these.are.not
05:30:00 <lambdabot> copumpkin says: These are not the monads you are looking for.
05:30:06 <gwern> @flish
05:31:10 <Jonno_FTW> i got an error in cabal, upgrading cabal at: System\Directory.hs:81:7:  Could not find module Control.Exception.Base':      it is a member of the hidden package `base'
05:34:38 <MaciejP> Jonno_FTW: It seems the package wants a newer base than the cabal file says
05:35:22 <Jonno_FTW> so i upgrade base?
05:36:18 <MaciejP> No, download the source of the package you want to upgrade, fix the cabal file and build again.
05:36:27 <Jonno_FTW> ok
05:40:59 <Vitka> @hoogle when
05:41:00 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
05:41:39 <mreh> does these quotes of the week just come from lambdabot?
05:41:44 <mreh> good grammar
05:49:09 <pozic> Is there a way to do animation with GTK2HS canvas or similar structure?
06:08:18 <marko1> [root@localhost /]# cabal install leksah
06:08:20 <marko1> Resolving dependencies...
06:08:22 <marko1> cabal: cannot configure leksah-0.6.1. It requires glib >=0.10, gtk >=0.10 and
06:08:24 <marko1> gtksourceview2 >=0.10.0
06:08:25 <marko1> There is no available version of glib that satisfies >=0.10
06:08:27 <marko1> There is no available version of gtk that satisfies >=0.10
06:08:28 <marko1> There is no available version of gtksourceview2 that satisfies >=0.10.0
06:08:30 <marko1> [root@localhost /]#
06:08:31 <marko1> I have problem with leksah? which glib I must install, and which gtk?
06:08:33 <marko1> OS: fedora 12, suse 11.2, debian testing last version
06:08:43 <pettter> marko1: mispaste?
06:09:23 <Saizan> marko1: don't paste more than one line on channel
06:09:31 <marko1> ok
06:09:35 <Saizan> marko1: and, see the gtk2hs website.
06:09:39 <Saizan> ?google gtk2hs
06:09:40 <lambdabot> http://www.haskell.org/gtk2hs/
06:09:41 <lambdabot> Title: Gtk2Hs
06:09:41 <byorgey> marko1: you need the Haskell gtk2hs packages, you can get it here: http://www.haskell.org/gtk2hs/
06:10:20 <marko1> and glib? which glib? from OS or haskell?
06:10:24 <byorgey> unfortunately it is not possible to cabalize it yet.
06:10:42 <byorgey> marko1: that's one of the things that will be installed by gtk2hs, which consists of a bunch of packages
06:11:01 <byorgey> I mean, you need both, but you probably already have the OS package you need.
06:11:38 <marko1> I have installe dglib-devel version
06:14:15 <marko1> ./configure, make install,  ghc: can't find a package database at package.conf.inplace (gtkhs-0-10-1 on fedora
06:21:41 <dancor> is there a good way to diagonalize an infinite list, filling in successively larger nxn blocks?  i.e. stream2d [1..] = [[1,2,5,10,..],[3,4,6,11,..],[7,8,9,12,..],[13,14,15,16,..],..]
06:22:29 <dancor> my naive approach hangs even when you look at finite portion of the result, but it seems like it should be possible
06:24:58 <mreh> dancor: this might seem simplistic, but you are using a lazy evaluator like "takeWhile"?
06:25:16 <mreh> are you doing something like this
06:25:20 <mreh> 1
06:25:22 <mreh> 123
06:25:28 <mreh> 123456
06:27:31 <dancor> mreh: i don't understand.  the code i have is here http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=8126#a8126
06:29:20 <Zao> Aren't there a pretty f(r,c) formula once can use to evaluate any grid point?
06:29:42 <dancor> probably
06:29:44 <MissPiggy> dancor, do you zigzag the stream onto a grid and then you take rows of it?
06:31:10 <MissPiggy> there is definitely a bijective function ffrom NxN <--> N but finding a very elegant one can be difficult
06:31:15 <dancor> MissPiggy: ya but it's not a zigzag exactly
06:31:34 <dancor> i want this sucessively-larger-squares bijection
06:31:47 <dancor> i guess it's less elegant than other possibilities
06:31:59 * MissPiggy needs to see a picture to understand this
06:33:49 <dancor> Zao: well f(0, j) = j^2
06:34:18 <Cale> I get it. The numbers from n^2 + 1 to (n+1)^2 are distributed by placing one in each of the n lists so far, and then the remainder of that chunk goes into the (n+1)th.
06:34:44 <dancor> Cale: ya
06:35:05 * MissPiggy still doesn't
06:35:39 <dancor> i guess f(i,j) can be implemented by counting away from f(0,max(i,j))
06:36:20 <Cale> So you might start by chunking the list into pieces of increasing size 2n
06:37:12 <Cale> er, 2n-1 rather
06:39:40 <Cale> > let chunks n xs = let {(us,vs) = splitAt (2*n-1) xs} in us : chunks (n+1) vs in chunks 1 [1..]
06:39:41 <lambdabot>   [[1],[2,3,4],[5,6,7,8,9],[10,11,12,13,14,15,16],[17,18,19,20,21,22,23,24,25...
06:39:52 <sergio2> I have a problem with parsec (2.1.0.1) that I don't understand (and it's not easy for me to make a small test case out of it, bit I'll try to reduce it if needed...)
06:40:07 <sergio2> If I parse "too many" files (i.e. more than 4), it doesn't work, whereas it's as expected with fewer files.
06:40:12 <Cale> Now we just need an appropriate variant of zipWith (:) to foldr through this list
06:40:17 <sergio2> It seems like parsec gets lost, since its error message indicate sthg like "(line 3, column 26682): unexpected end of input", whereas my files' longest lines are 188 char long!
06:40:28 <sergio2> Could this be linked to reading my files with "Data.ByteString.hGetContents" and running out of handles?
06:40:43 <Cale> (this is almost a transpose, but not quite)
06:41:27 <Cale> sergio2: maybe something weird about parsing the line endings?
06:41:44 <theorbtwo> sergio2: Are you using setInput?
06:41:54 <sergio2> cale: I'm on Windows...
06:42:42 <sergio2> theorbtwo: I don't know setInput, but the thing that troubles me a lot is that it works fine when I parse jsut "a few" files...
06:43:53 <Cale> Data.ByteString.hGetContents is strict
06:44:05 <Cale> and reads the entire file at once
06:44:27 <sergio2> my files are smallish (~70Kb)
06:44:42 <Cascade-> MsnBot [Freezer] [MassAdder] [And More] Add 'bot@hackersrus.info' to your contact list for FREE access!
06:44:56 --- mode: ChanServ set +o Cale
06:44:58 --- mode: Cale set +b *!*@89.242.20.36
06:44:59 --- kick: Cascade- was kicked by Cale (Cascade-)
06:45:11 --- mode: Cale set -o Cale
06:45:22 <fasta> Is the way how Template Haskell actually is interpreted described somewhere? It appears that GHC refuses to read anything after a TH declaration even for non-TH dependent code.
06:45:46 <sergio2> And I parse only 4 of them (well, I parse each of them rwice: please don't flame my bad Haskell 'style' ;-)
06:45:51 <gio123> Cale: hi
06:46:01 <sergio2> s:/rwice/twice/
06:48:04 <zygoloid> fasta: what do you mean by a 'TH declaration'? you mean splicing in a declaration with $(...)?
06:48:49 <fasta> zygoloid, yes, that's what I meant.
06:49:33 <fasta> So, if you do foo::X;$(mysplice);data X=X, then it doesn't work.
06:49:48 <fasta> (and a suitable foo = undefined)
06:50:19 <fasta> It seems that a sane implementation would first reorder the declarations and then do the TH stuff.
06:50:31 <zygoloid> fasta: i see the same thing, but it works in ghci
06:50:51 <zygoloid> i'm doing: $(id [d|foo = "Hello world"|]); main = putStrLn foo
06:50:56 <zygoloid> it compiles but gets a link error
06:51:19 <fasta> zygoloid, I don't really expect anything from ghci. ;)
06:51:23 <zygoloid> hmm, scratch that, called my module something other than Main :D
06:51:47 <zygoloid> so my case works at least (in 6.8.3)
06:52:10 <zygoloid> and 6.10.1
06:52:38 <sergio2> Too make things easier, I also have 'Data.Text.ICU.Converter.open "UTF-8"', 'Data.Text.ICU.Converter.toUnicode' and 'Data.Text.ICU.Normalizer.normalize NFC' in my loop! ;-)
06:52:57 <fasta> Anyway, just reordering declarations should not matter, since it is not consistent with standard semantics and the mantra that "definitions are equations".
06:53:59 <MissPiggy> I don't understand that argument against "definitions are equations"
06:54:08 <zygoloid> foo :: String; $(id [d|foo = "Hello world"|]) is rejected, but $(id [d|foo = "Hello world"|]); foo :: String is accepted.
06:54:10 <MissPiggy> someone said they are not equations because of 'where'
06:54:23 <fasta> MissPiggy, that sounds like garbage.
06:54:29 <MissPiggy> yeah
06:58:18 <zygoloid> hmm, the docs say "You may omit the $(...) in a top-level declaration splice." but this isn't true in 6.8 nor 6.10. does 6.12 support that?
06:59:24 <Saizan> yeah, it's new in 6.12
06:59:29 <McManiaC> mauke: ping
06:59:41 <fasta> Now, if only all the libraries worked in 6.12...
07:00:34 <fasta> Can you also make partially evaluated TH functions?
07:00:53 <fasta> That is, z x = derive x ''Bar?
07:01:48 <fasta> Probably you can.
07:03:13 <fasta> zygoloid, anyway, a better example is this: f = g; $(foobar);g=id
07:03:50 * hackagebot halipeto 2.1 - Haskell Static Web Page Generator  http://hackage.haskell.org/package/halipeto-2.1 (PeterSimons)
07:04:08 <fasta> If the compiler would just reorder these declarations to f = g;g=id;$(foobar) internally, it wouldn't require manual reordering.
07:06:34 <dancor> Cale: i think a better building block is actually [([0],[1]),([2,3],[4,5]),([6,7,8],[9,10,11]),..]
07:06:45 <dancor> Cale: but my attempt still hangs: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=8126#a8127
07:09:47 * MissPiggy still doesn't understand what shape dancor makes
07:11:18 <roconnor> > let ((+),(*)= ((*),(+)) in 2 + (2*2)
07:11:19 <lambdabot>   <no location info>: parse error on input `='
07:11:24 <roconnor> > let ((+),(*)) = ((*),(+)) in 2 + (2*2)
07:11:27 <lambdabot>   mueval-core: Time limit exceeded
07:11:32 <roconnor> ah oops
07:11:37 <roconnor> heh
07:11:43 <roconnor> now I understand why ml and scheme have letrec
07:12:01 <roconnor> > let ((+),(*)) = ((Prelude.*),(Prelude.+)) in 2 + (2*2)
07:12:02 <lambdabot>   8
07:12:03 <MissPiggy> unp
07:12:42 <roconnor> > let (+,*) = ((Prelude.*),(Prelude.+)) in 2 + (2*2)
07:12:43 <lambdabot>   <no location info>: parse error on input `,'
07:12:52 <zygoloid> fasta: what if $(foobar) defined something pertinent to the later definitions?
07:12:52 <fasta> roconnor, yep. Kind of unfortunate that they never explain that in a book.
07:13:44 <fasta> zygoloid, in the worst case the compiler has to do twice the amount of work.
07:14:27 <zygoloid> > let plus = (+); times = (*) in let (+) = times; (*) = plus in 2 + (2 * 2)
07:14:28 <lambdabot>   8
07:14:38 <zygoloid> > let plus = (+); times = (*); (+) = times; (*) = plus in 2 + (2 * 2)
07:14:41 <lambdabot>   mueval-core: Time limit exceeded
07:14:59 <MaciejP> `cabal clean' behaves a little bit weird sometimes: Linking .\dist\setup\setup.exe ...; cleaning...; Error while removing dist/: DeleteFile: permission denied :-D
07:15:18 <zygoloid> fasta: i think the compiler should be expanding all the splices before it typechecks anything, really
07:15:30 <roconnor> zygoloid: a little scary that the let combine rule has side conditions
07:15:41 <fasta> zygoloid, ah, right.
07:15:41 <zygoloid> roconnor: yeah :o
07:16:17 <roconnor> zygoloid: thought I guess you can chalk it up to simply alpha renaming issues
07:16:22 <zygoloid> fasta: this kinda puts the last nail in the coffin of in-module TH definitions though
07:17:20 <dancor> MissPiggy: http://hphotos-snc3.fbcdn.net/hs516.snc3/27092_573129307118_708561_33185573_5889458_n.jpg
07:17:22 <fasta> zygoloid, I see what you mean.
07:17:54 <gio123> Cale: hi
07:18:00 <MissPiggy> dancor: ahh it's dovetail
07:18:06 <fasta> zygoloid, the problem is defining the scope of whatever is visible in TH definitions.
07:18:10 <dancor> ya
07:18:31 <MissPiggy> dancor and you want to take the rows? or cols ?
07:18:52 <fasta> zygoloid, in Lisp/Scheme it is whatever came before basically, unless you have a module system. In Haskell it used to be everything in the current module, but that's ill-defined with TH.
07:19:03 <jmcarthur> i don't suppose that an unboxed array of Bools in the vector package is packed, is it?
07:19:15 <jmcarthur> i'm suspecting not
07:20:04 <zygoloid> $( liftM (flip (zipWith const) a) [d| a :: Maybe Int |] ); a = mempty
07:20:26 <fasta> jmcarthur, I would actually expect it is, since the UArray Bool type is also.
07:20:30 <MissPiggy> dancor ?
07:20:46 <zygoloid> "$( liftM (flip (zipWith const) (undefined:a)) [d| a :: Maybe Int |] ); a = mempty" rather
07:20:49 <fasta> jmcarthur, but the only way to know for sure, is to look.
07:20:58 <MissPiggy> [[0,1,4,9,16,...],[2,3,5,10,...],[6,7,8,11,...],...]?
07:21:07 <dancor> MissPiggy: ?  i just want to have the list of lists.  ya
07:21:14 <MissPiggy> dancor: the rows?
07:21:16 <dancor> ya
07:21:36 * jmcarthur looks
07:22:12 <jmcarthur> fasta: it actually looks unpacked to me
07:22:24 <MissPiggy> dancor: i think one need to find an arithmetical way to do it
07:22:31 <jmcarthur> an array of Word8 with a 1 to 1 mapping
07:22:55 <fasta> jmcarthur, are you talking about the vector package now?
07:23:23 <dancor> MissPiggy: it seems that way
07:23:30 <jmcarthur> fasta: yes
07:23:45 <fasta> jmcarthur, post it on Reddit as an outrage to get it fixed.
07:23:48 <fasta> ;)
07:23:49 <MissPiggy> roconnor has the equation :P
07:23:49 <jmcarthur> heh
07:24:14 <pflanze> Hello. I don't understand the ghci debugger: I start ghci with -fbreak-on-exception, then :trace someexpression; this stops even for expressions that normally don't throw exceptions. Why?
07:24:31 <pflanze> I thought :trace only records the history and doesn't actually single-step or so?
07:25:39 <Cale> pflanze: like what?
07:25:55 <MissPiggy> > 16-9
07:25:56 <lambdabot>   7
07:26:57 <pflanze> Cale: a bigger program of mine; it doesn't happen for small expressions
07:26:58 <MissPiggy> dancor, the top row increase with  1,3,5,7
07:27:12 <MissPiggy> dancor, the next incraese with _,2,5,7
07:27:19 <zygoloid> > let sqs = [n*n | n <- [0..]]; tris = [n*(n+1)`div`2 | n <- [0..]]; tbl = [[2*t..2*t+r-1] ++ map (r-1+) (drop r sqs) | (r, t) <- zip [1..] tris] in map (take 5) tbl
07:27:20 <lambdabot>   [[0,1,4,9,16],[2,3,5,10,17],[6,7,8,11,18],[12,13,14,15,19],[20,21,22,23,24]...
07:27:23 <pflanze> Cale: but definitely if I enter the same expression (using my program) without :trace then it evaluates fully without throwing an error
07:27:32 <MissPiggy> dancor, and the one after goes up with _,_,3,7
07:27:40 <roconnor> > let cPair a b = b + ((a + b)*(a + b + 1) `div` 2) in  vcat $ map
07:27:41 <lambdabot>   Couldn't match expected type `[Text.PrettyPrint.HughesPJ.Doc]'
07:27:41 <lambdabot>         agai...
07:27:42 <roconnor> (text . show . map (uncurry cPair)) ([[(x,y) | x <- [0..3]] | y <- [0..3] ])
07:27:43 <MissPiggy> that's kind of odd
07:27:44 <pflanze> Cale: and I'm not catching exceptions myself (maybe the ParserCombinator.ReadP library does?)
07:27:54 <zygoloid> could be done more efficiently, but i think that's correct
07:28:06 <roconnor> > let cPair a b = b + ((a + b)*(a + b + 1) `div` 2) in  vcat $ map (text . show . map (uncurry cPair)) ([[(x,y) | x <- [0..3]] | y <- [0..3] ])
07:28:07 <lambdabot>   [0,1,3,6]
07:28:07 <lambdabot>  [2,4,7,11]
07:28:07 <lambdabot>  [5,8,12,17]
07:28:07 <lambdabot>  [9,13,18,24]
07:28:27 <MissPiggy> roconnor oh that's cool !
07:28:50 <roconnor> [Wednesday 03 February 2010] [17:37:30] <roconnor> > let cPair a b = b + ...
07:29:35 <Cale> The trick is to do it nicely without indices :)
07:29:57 <dancor> zygoloid: cool
07:29:59 <MissPiggy> the dovetail one is different
07:30:02 <dancor> roconnor: that one is different
07:30:11 <MissPiggy> http://hphotos-snc3.fbcdn.net/hs516.snc3/27092_573129307118_708561_33185573_5889458_n.jpg
07:30:23 <roconnor> yes
07:30:25 <zygoloid> if you wanted it more efficient, the trick would be to reuse the result of the 'drop' from the previous row
07:30:35 <pflanze> Cale: ah, emacs started ghci without the flag grr, that's why I didn't see the error anymore; further testing reveals that when starting "ghci -fbreak-on-exception" then running my expr throws an exception regardless of whether I enter :trace before it
07:31:00 <pflanze> So this sounds to me like a library using exceptions inside and catching them?
07:31:10 <pflanze> And -fbreak.. leading to stop there?
07:32:00 <Cale> pflanze: weird
07:32:15 <Cale> pflanze: Pure code can't normally catch exceptions
07:32:15 <pflanze> Cale: it's a GHC.IOBase.IOException (GHC.IOBase.IOError Nothing \n  GHC.IOBase.EOF ....)
07:32:27 <Cale> Oh, but IO code can.
07:32:44 <pflanze> so I guess it's just normal behaviour, i.e. lower level throwing EOF and upper level catching it.
07:32:44 <sinelaw> can anyone point to a good tutorial on garbage collection + FFI ?
07:33:13 <pflanze> I don't want to break there; I only want to analyze my own uncatched exceptions. So I should retry without -fbreak...
07:36:04 <pflanze> But, without -fbreak.. :trace doesn't record anything it seems: it throws an error (in another, actually buggy, expression of mine) e, I say :history, it says "not stopped at a breakpoint".
07:36:27 <pflanze> Why should I put a breakpoint in? I want to know the history up to the point where the exception happens.
07:36:53 <sinelaw> chrisdone, did you check  HOpenCV?
07:37:12 <Cale> pflanze: I'm afraid I don't have much experience using the debugger. I tend to remove bugs in a different way.
07:37:38 <Cale> pflanze: But my impression was that it was a bit preliminary and behaved a bit strangely in some cases.
07:38:01 <progo> Btw: how does the basic debugging differ in functional and imperative 'digmas?
07:38:17 <MissPiggy> ??
07:38:45 <Cale> progo: If by that you mean the process by which bugs are removed from a program, then I would say "completely"
07:39:04 <mreh> @hoogle Bool -> Int
07:39:05 <lambdabot> Data.Time.Calendar.MonthDay monthLength :: Bool -> Int -> Int
07:39:05 <lambdabot> Foreign.Marshal.Utils fromBool :: Num a => Bool -> a
07:39:05 <lambdabot> Foreign.Storable alignment :: Storable a => a -> Int
07:39:15 <progo> Cale, yes... Are there completely new aspects to think of, or is it simply easier and tidier to correct up the code?
07:39:38 <Cale> There are "debuggers" for both imperative and functional programming languages, including Haskell, but I don't tend to find stepping through code to be all that useful most of the time in Haskell, whereas in imperative code it's the only thing you can do.
07:39:42 <mreh> > fromEnum True
07:39:43 <lambdabot>   1
07:39:46 <mreh> > fromEnum False
07:39:47 <lambdabot>   0
07:40:01 <progo> Cale, I see! :)
07:40:10 <Cale> Haskell code you tend to understand in small pieces, and then understand how the pieces fit together.
07:40:21 <progo> it is a vastly different world in every aspect
07:40:21 <mreh> yay, combinators
07:40:28 <Cale> You have some fairly strong guarantees that if things work on their own, then they work together as well.
07:40:34 <lispy> the tao of haskell
07:40:53 <mreh> question: does GHC compile into native code?
07:41:00 <Cale> mreh: By default, yes.
07:41:30 <mreh> how much does the RTS add?
07:41:35 <Cale> mreh: there is an option to compile "via C", though that involves mangling the assembly output of the C compiler too.
07:41:47 <Cale> how much what?
07:41:52 <mreh> native code
07:42:02 <Cale> Well, a whole bunch.
07:42:02 <jmcarthur> bloat?
07:42:41 <Cale> There's a generational garbage collector, a thread scheduler, and probably a bunch of other stuff I'm less clear about.
07:42:45 <jmcarthur> could just build a hello world and see how big the binary is
07:43:04 <Cale> I tend to imagine that the RTS is doing things which I know that it doesn't actually do, as well :)
07:43:12 <mreh> I remember my game of asteroids was about 42Mb
07:43:16 <jmcarthur> the rts can vary depending on build flags too. -threaded, for example
07:43:31 <mreh> but that was mostly static linking of libraries
07:43:43 <quicksilver> I'd be surprised if the RTS was more than a few hundre K
07:43:52 <jmcarthur> yeah i think that's all it is
07:44:04 <mreh> that's nothing
07:44:24 <quicksilver> base is probably more.
07:45:04 <Cale> whoa, I just noticed that my .xsession-errors is over 540 MB
07:45:06 <phrixos> I'm having a bit of a newbie problem compiling code which uses the time libraries
07:45:36 <phrixos> it will work ok in runhaskell, but won't run through ghc, so I suspect I'm failing to link against something
07:45:42 <phrixos> any ideas?
07:45:45 <Cale> --make ?
07:45:48 <phrixos> http://gist.github.com/318427 for an example
07:46:44 <Cale> Yeah, add --make to the commandline
07:46:59 <Cale> and actually you can leave out the -o foo, since that'll be the default name for the binary
07:47:01 <phrixos> hmm, yup
07:47:09 <phrixos> that seems to do the job nicely
07:47:31 <Cale> It determines which -package flags to use automatically in the same way that GHCi does.
07:47:49 <Cale> Otherwise, probably something like  -package time  would work.
07:47:54 <phrixos> cool, that's handy
07:48:03 <phrixos> thanks for pointer
07:48:30 <phrixos> ghc -o foo -package time foo.hs  also seems to work
07:49:32 <phrixos> are there any disadvantages to just using --make?
07:50:05 <byorgey> phrixos: not that I know of.
07:50:35 <MissPiggy> byorgey did you read Mathematics Made Difficult?
07:50:43 <byorgey> MissPiggy: no, should I?
07:50:55 <byorgey> I haven't heard of it
07:51:15 <MissPiggy> I wouldn't be safe trying to guess if you'd like it or not
07:51:37 <phrixos> thanks
07:51:58 <byorgey> hehe
07:52:29 <byorgey> hmm, judging by the reviews on amazon I'd probably enjoy it
07:52:54 <byorgey> oh boy, a used copy is only $312!
07:53:00 <MissPiggy> haha
07:53:21 <MissPiggy> 'in my day you could feed a family of four with that'
07:53:36 <sinelaw> with what
07:53:41 <MissPiggy> $312
07:53:51 <byorgey> with a book that costs $312
07:53:53 <sinelaw> heh
07:54:02 <Cale> mmm... theorems
07:54:06 <sinelaw> :)
07:54:37 <byorgey> "here Timmy, you can have this page"
07:54:46 <byorgey> "but I don't *like* Grothendieck!"
07:54:52 <MissPiggy> hehe
07:55:27 <pflanze> Ok, so got my :history, really had to find out which was the place that threw the exception, add a breakpoint there.
07:55:35 <roconnor> > (`id`) succ 1
07:55:36 <lambdabot>   <no location info>: parse error on input `)'
07:55:56 <pflanze> Now it only shows me 50 steps of history, not enough; and dunno how to inspect values at those places?
07:56:12 <idnar> (`(`(`(`(`id`)`)`)`)`)
07:56:20 <MissPiggy> no wonder they call you idnar
07:56:38 <Cale> pflanze: What sort of program are you debugging?
07:56:52 <pflanze> An interpreter
07:57:21 <pflanze> (for a dynamically-typed language)
07:58:07 <MissPiggy> what is the bug?
07:58:11 <pflanze> (and my interpreter doesn't have a debugger for that language, so if there's a bug in code written in that language, it will just trip pattern match failures)
07:58:26 <MissPiggy> hm that doesn't sound very good at all
07:58:33 <pflanze> (The bug is that it doesn't find a variable in the environment.)
08:03:08 * hackagebot halipeto 2.2 - Haskell Static Web Page Generator  http://hackage.haskell.org/package/halipeto-2.2 (PeterSimons)
08:14:40 <mreh> how am I going to represent a typed tree data type?
08:15:03 <mreh> the thing represents an expression, which has nodes of boolean and arithmetic operators
08:15:22 <MissPiggy> you can use GADTs
08:15:24 <mreh> but defining a generic interface to manipulate these is where I get stuck
08:15:32 <mreh> generic ADTs?
08:16:10 <MissPiggy> data Exp typ where TT :: Exp Bool ; Cons :: Exp a -> Exp [a] -> Exp [a]  etc
08:16:28 <aledge> whats the advantage of using a GADT in that case?
08:16:45 <MissPiggy> aledge, compared to  data Exp = TT | Cons Exp Exp  ?
08:16:47 <sizur_> How can one use Monoid (Sum a)?
08:16:51 <aledge> yeah
08:17:15 <MissPiggy> aledge, with the GADT  Cons x TT  wil be a type error, but with the ADT  Cons x TT  will be okay,
08:17:31 <MissPiggy> it goes a bit further than that though
08:17:52 <mreh> MissPiggy, what are they called?
08:17:56 <mreh> I'm going to read about them
08:18:02 <quicksilver> > (Sum 3) `mappend` (Sum 5)
08:18:03 <lambdabot>   Sum {getSum = 8}
08:18:07 <quicksilver> sizur_: like that ^^
08:18:49 <benjamin_scarlet> mreh: http://www.haskell.org/haskellwiki/GADT
08:19:01 <mreh> yeah, I'm there already :)
08:19:02 <mreh> thanks
08:19:13 <benjamin_scarlet> mreh: I'
08:19:38 <SwiftShift> Hi, guys, sorry if this question is very silly, but I need a function which turns a Char into an Int. I would assume there's some standard function/way to do this, but google couldn't help me.
08:19:54 <SwiftShift> anyone got any pointers about where I should look?
08:19:54 <MissPiggy> :t ord
08:19:56 <lambdabot> Char -> Int
08:20:01 <sizur_> Nice, now how can I mappend functions?
08:20:16 <Raynes> > read "1" :: Int
08:20:17 <lambdabot>   1
08:20:18 <tromp> :t (.)
08:20:19 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:20:31 <benjamin_scarlet> SwiftShift: http://www.haskell.org/hoogle/?hoogle=Char+-%3E+Int
08:20:33 <MissPiggy> :t mappend (\x -> undefined)
08:20:34 <lambdabot> forall t a. (Monoid (t -> a)) => (t -> a) -> t -> a
08:20:42 <MissPiggy> @instances Monoid
08:20:43 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
08:20:57 <MissPiggy> :t mkEndo (+1)
08:20:58 <lambdabot> Not in scope: `mkEndo'
08:21:04 <SwiftShift> benjamin_scarlet: ah, thanks very much, exactly what I need
08:21:10 <MissPiggy> @src Endo
08:21:10 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
08:21:15 <MissPiggy> fffff
08:21:23 <quicksilver> > runEndo (Endo (*2) `mappend` Endo (+3)) 5
08:21:24 <lambdabot>   Not in scope: `runEndo'
08:21:32 <quicksilver> > unEndo (Endo (*2) `mappend` Endo (+3)) 5
08:21:33 <lambdabot>   Not in scope: `unEndo'
08:21:34 <MissPiggy> :t appEndo
08:21:35 <lambdabot> forall a. Endo a -> a -> a
08:21:39 <quicksilver> > appEndo (Endo (*2) `mappend` Endo (+3)) 5
08:21:40 <lambdabot>   16
08:21:42 <quicksilver> thanks missP
08:22:13 <sizur_> Nice, where's Endo?
08:22:29 <quicksilver> @hoogle Endo
08:22:29 <lambdabot> Data.Monoid newtype Endo a
08:22:29 <lambdabot> Data.Monoid Endo :: (a -> a) -> Endo a
08:22:30 <lambdabot> Data.Monoid appEndo :: Endo a -> a -> a
08:23:34 <sizur_> Thongs guys.  You make it look too easy.
08:23:46 <sizur_> Thanks even
08:23:53 <quicksilver> it is easy.
08:29:41 <McManiaC> how can I use "NULL" in C with the FFI ?
08:30:53 <smiler> Use the integer 0?
08:31:19 <McManiaC> 0 :: CInt ?
08:31:30 <Zao> nullPtr?
08:32:09 <Zao> @type Foreign.Ptr.nullPtr
08:32:10 <lambdabot> forall a. GHC.Ptr.Ptr a
08:32:23 <McManiaC> ok
08:32:58 <McManiaC> thx :)
08:38:11 <MaciejP> Can you parse an expression from a string using TH?
08:39:38 <mreh> [| expression |]
08:39:58 <mreh> that parses an expression into a TH Expr type
08:40:04 <mreh> a string, sorry
08:40:21 <MaciejP> No I mean expression = "1+2" and then get 3
08:40:45 <mreh> unfortunately not
08:40:51 <zygoloid> MaciejP: what are you trying to do? maybe TH isn't the answer
08:41:01 <mreh> MaciejP: sounds like you want memoization
08:41:41 <mreh> that's the only reason I can think of to want an expression evaluated ahead of time, you can't do that in haskell unfortunately
08:41:43 <MaciejP> I want to preprocess Haskell expression and then feed them back to Haskell code via TH.
08:42:13 <zygoloid> why do you have them in the form of a string? is that a necessary part of the problem?
08:42:31 <MaciejP> Yes, they come from a file
08:42:35 <mreh> explain the problem from a higher level
08:42:53 <dschoepe> MaciejP: at runtime?
08:42:54 <mreh> why not read them in using the Read class, then manipulate them in haskell
08:42:59 <zygoloid> possibly the GHC API might help you, but for almost all conceivable problems it's overkill
08:43:20 <MaciejP> dschoepe: No, at compile time
08:43:25 <dschoepe> @hackage hint
08:43:25 <lambdabot> http://hackage.haskell.org/package/hint
08:43:42 <dschoepe> using that with TH might work
08:44:24 <burp> @instances Fractional
08:44:25 <lambdabot> Double, Float
08:44:27 <zygoloid> MaciejP: what's the format of the stuff in the file?
08:45:46 <MaciejP> zygoloid: These are simple Haskell expressions, but too complex to write a parser myself, like `(+) 1' or `(1 +)' ... something like this.
08:45:54 * zygoloid ponders an 3vil solution along the lines of: {-# LANGUAGE CPP, TemplateHaskell #-} decls = [d| #include "file" |]
08:46:03 <zygoloid> MaciejP: one expression per line then?
08:46:50 <MaciejP> zygoloid: No. Would it matter?
08:47:26 <zygoloid> MaciejP: well, it depends how evil a trick you go for :) how are they formatted/separated then?
08:47:57 <sinelaw> is there any "normal" way to do pre-allocated output arguments in C function for functional bindings?
08:48:17 <zygoloid> if they're comma-separated, [| ( #include "file" ) |] would give you a tuple of them in an ExpQ :)
08:49:12 <MaciejP> zygoloid: I parse them from templates like`< 2+3 >'
08:50:21 <quicksilver> haskell-src-exts is a good haskell parser
08:50:34 <quicksilver> I'm sure I remember a discussion about feeding haskell-src-exts into TH
08:50:40 <quicksilver> but I don't remember the conclusion
08:53:43 <MaciejP> quicksilver: Oh, I didn't know haskell-src-exts also includes a parser, I thought it's just the AST
08:54:49 <MaciejP> parseExp seems to be what I was looking for.
08:55:05 <zygoloid> http://hackage.haskell.org/package/haskell-src-meta seems to be the missing piece: a translater from haskell-src-exts to TH
08:55:40 <quicksilver> hmm yes, it would be mmorrow
08:55:44 <quicksilver> preflex: seen mmorrow
08:55:44 <preflex>  mmorrow was last seen on #ghc 42 days, 13 hours, 57 minutes and 59 seconds ago, saying: * mmorrow is rtfm'ing
08:55:52 <quicksilver> obviously a long manual.
08:58:04 <Cale> MaciejP: It also conveniently has a prettyprinter.
09:00:12 <aavogt> if you're on ghc-6.12, there's a version that's compatible somewhere in  http://moonpatio.com/repos
09:01:14 <fasta> Why is there no Functor instance for Sets?
09:01:33 <MissPiggy> fasta because of the Eq constraint
09:01:36 <Cale> fasta: because fmap has too general a type
09:01:43 <Cale> Ord, rather
09:02:00 <Cale> :t Data.Set.map
09:02:01 <lambdabot> forall a b. (Ord a, Ord b) => (a -> b) -> S.Set a -> S.Set b
09:02:36 <zygoloid> if you need to use code which is generic over the functor, Yoneda Set might be one way to go (but the pruning of duplicates will only happen at the end)
09:03:00 <fasta> Data.Set.map is fine.
09:03:12 <MissPiggy> fine?
09:03:16 <zygoloid> on the other hand it's not going to do an O(n log n) operation each time you fmap, so it's not necessarily that bad :)
09:03:34 <gio123> Cale: hi
09:03:38 <Cale> hi
09:04:23 <fasta> MissPiggy, fine/OK/acceptable
09:04:23 <gio123> can u see pm please
09:04:29 <MissPiggy> what?
09:05:22 <MaciejP> zygoloid: Yeah, haskell-src-meta is really convenient
09:06:20 <zygoloid> i find it a little surprising that TH doesn't provide a way to invoke the parser on a string
09:11:48 <zygoloid> looks like GHC-API doesn't either :(
09:12:44 <quicksilver> zygoloid: phase error, isn't it?
09:12:57 <quicksilver> TH runs after parsing, on an parsed AST
09:13:09 <quicksilver> I mean, it would still be nice, and that logically doesn't rule it out
09:13:11 <quicksilver> but that's kind-of why.
09:14:30 <zygoloid> it's a significant and reasonably-obvious omission, though. especially in the context of antiquotation in a quasiquoter
09:16:45 <mreh> haskell allows a data type with Null constructors?
09:17:01 <MissPiggy> you mean zero?
09:17:04 <zygoloid> nullary constructors, yes. 0 constructors, not in '98.
09:17:14 <zygoloid> -XEmptyDataDecls iirc
09:17:33 <mreh> that's on by default though?
09:17:57 <zygoloid> it's part of haskell'10
09:18:50 <mreh> meh, this GADT has an example of a safe list, it uses two types to represent empty and non-empty lists
09:18:59 <mreh> why not just one typ with two constructors?
09:19:02 <MissPiggy> that's a bad example
09:19:24 <mreh> in what way?
09:19:26 <Alpounet> the better one I've seen is the one with Expr
09:19:42 <mreh> ooh, I'm doing expressions
09:19:50 <mreh> differently typed expressions?
09:20:08 <Alpounet> mreh, let me find it
09:20:12 <mreh> thanks
09:20:15 <quicksilver> mreh: because one type with two constructs wouldn't distinguish at the type level, so the whole point fails
09:20:21 <zygoloid> "data Zero; data Succ a; data List n a where Null :: List Zero a; Cons a (List n a) :: List (Succ n) a" is a reasonable way of doing 'safe' lists
09:20:28 <quicksilver> (although MissPiggy is right, it's not a particular interesting example)
09:20:53 <Alpounet> http://www.haskell.org/ghc/docs/6.6/html/users_guide/gadt.html
09:20:59 <Alpounet> mreh, ^^^^
09:20:59 <quicksilver> mreh: if you have "data EmptyOrNot = Empty | NonEmpty" then the type "List EmptyOrNot" doesn't tell you which it is.
09:21:00 <zygoloid> modulo GADT-versus-non-GADT notation, oops
09:21:13 <quicksilver> mreh: you want "List Empty" and "List NonEmpty" to be different types.
09:21:19 <maltem> mreh, the type that has two different constructors for empty vs. non-empty lists is called [a]
09:21:33 <mreh> haha
09:21:36 <mreh> yes, that's true
09:21:56 <maltem> (just to emphasize the point the others were making)
09:22:09 <mreh> I obviously need to study this a little more
09:23:03 <Alpounet> mreh, check out the link I just gave
09:23:22 <Alpounet> it should be more explicit about the point of GADTs
09:23:47 <zygoloid> a problem with 'List Empty' and 'List NonEmpty' is that 'tail's result type isn't easy to specify (and you don't have enough information to statically check 'tail.tail')
09:24:00 <MissPiggy> the basic use of GADT is to ensure soundness of a typechecker or write type indexed family of functions
09:24:29 <zygoloid> GADTs allow a restricted form of dependent typing
09:24:41 <MissPiggy> yeah types dependent on types :P
09:26:59 <zygoloid> another view is that GADTs allow type equality in the context of constructors, so in effect values can carry around type equality proofs
09:28:31 <zygoloid> "data Foo a where F :: Int -> Foo Char" is equivalent to "data Foo a = (a ~ Char) => F Int", if memory serves
09:29:01 <MissPiggy> yeah you can translate all GADTs into ADT + data Eq a b where REFL :: Eq a a
09:29:12 <philo> how easy is it to interact with c++ code in haskell ?
09:29:44 <Lemmih> philo: You have to go through C.
09:29:58 <philo> hummm
09:30:22 <philo> i am reading this : http://www.haskell.org/haskellwiki/CPlusPlusFromHaskell
09:30:32 <philo> is it the best doc available ?
09:31:19 <Lemmih> philo: That's "The Hard Way".
09:31:41 <Lemmih> philo: Just go through C and everything will be easy.
09:32:06 <philo> Lemmih: i am sure to understand the "go trought c"
09:32:18 <philo> can you alaborate or point me to the right doc
09:32:28 <Lemmih> philo: First write a C binding to the C++ library. Then write a Haskell binding to said C binding.
09:32:47 <philo> Lemmih: ok
09:32:58 <philo> i want to use LLVM for a school prject
09:33:25 <philo> but wouldnt it be tedious  to write a binding for the all lib ?
09:34:01 <Lemmih> philo: How about using the LLVM binding?
09:34:15 <Lemmih> philo: http://hackage.haskell.org/package/llvm
09:34:34 <philo> Lemmih:  your are a savior
09:34:51 <philo> lol how could i have missed it
09:34:52 <benjamin_scarlet> Depending on the project, those bindings are really great or somewhat tricky.
09:35:12 <philo> benjamin_scarlet:  how so ? are their buggy ?
09:35:32 <Paczesiowa> does Magnus Carlsson hang out here?
09:35:36 <benjamin_scarlet> Not buggy no.
09:36:25 <benjamin_scarlet> Instead of trusting LLVM's internal type checking, they're strongly typed themselves: the LLVM types are represented with Haskell types.
09:37:13 <philo> benjamin_scarlet:  hummm that might me a problem...
09:37:21 <Alpounet> philo, why ?
09:37:38 <philo> the input language is C... wich is weakly typed
09:38:00 <benjamin_scarlet> It's really quite cool, but some tasks - like generating functions or function calls from untyped input like a basic expression ADT from a parser - get quite hard.
09:38:51 <benjamin_scarlet> I'm fighting with the typing of something like structs in C right now.
09:39:00 <philo> wich version of LLVM does the bindings support ?
09:39:18 <benjamin_scarlet> 2.6 currently.
09:39:29 <philo> benjamin_scarlet: great
09:39:35 <philo> benjamin_scarlet: working on a project ?
09:40:08 <benjamin_scarlet> philo: an actual job, actually :-)
09:40:27 <philo> lol at least you get paid
09:40:56 <philo> someone pay you to do some haskell ? lol
09:43:29 <philo> just realizing llvm does have a c interace right ?
09:44:03 <benjamin_scarlet> philo: Yes. The Haskell bindings go through LLVM's own C bindings.
09:44:33 <philo> ok
09:49:16 <gour> i've problem with building qthaskell...the build process is invoking 'runhaskell Setup.hs makefile || return 1
09:49:34 <gour> but it fails with unrecognised command: makefile (try --help)
09:49:39 <gour> ghc-6.12.1
09:50:09 <gour> according to cabal docs, there should be support for 'makefile' command, but it does not look so.
09:50:21 <gour> anyone familiar with cabal?
09:51:30 <Paczesiowa> gour: anything interesting in makefile? maybe just run make
09:51:38 <Paczesiowa> gour: I mean Setup.hs
09:52:07 <Paczesiowa> gour: iirc usually Setup.hs with makefile just sets up haskell deps and calls make
09:52:27 <gour> Paczesiowa: here is Setup.hs - import Distribution.Simple; main = defaultMain
09:53:04 <Alpounet> just have to see if Distribution.Simple.defaultMain takes care of the 'makefile' target
09:53:36 <philo> is there any plan for someone to make an haskell front end for llvm?
09:54:03 <Alpounet> ?
09:54:07 <Alpounet> what do you mean ?
09:54:42 <pikhq> philo: You mean, a Haskell compiler that targets LLVM?
09:54:48 <philo> yes
09:54:55 <Alpounet> we have the llvm backend for GHC (still experimental but it'll be worked out), and a port of the llvm libraries.
09:55:04 <pikhq> GHC-6.13.
09:55:59 <philo> Alpounet: ok
09:56:29 <Alpounet> philo, check out the last posts on http://donsbot.wordpress.com/ for more about the llvm backend
09:56:36 <zygoloid> philo: dons has already made some blog posts about its performance compared to -fsam and -fvia-C
09:56:36 <philo> but would that make haskell run any faster ?
09:56:47 <zygoloid> short answer: yes. :)
09:58:18 <philo> very interresting
09:58:48 <philo> i thought that llvm IR was to low level to acomodate things like haskell and so forth
09:58:53 * hackagebot chp-plus 1.0.1 - A set of high-level concurrency utilities built on Communicating Haskell Processes  http://hackage.haskell.org/package/chp-plus-1.0.1 (NeilBrown)
09:59:13 <pikhq> philo: Not really.
09:59:22 <pikhq> Anything can be compiled to LLVM's IR.
09:59:30 <maltem> Fwiw, what's the state of incorporating the LLVM patch into upstream LLVM?
09:59:33 <pikhq> And LLVM will try its best to optimise that.
09:59:45 <philo> yea but i thought most usefull information was lost in the process
09:59:53 <Alpounet> philo, no
10:00:05 <philo> yea i see that
10:00:11 <pikhq> Yes, a lot of useful information is lost in the process -- because GHC *optimises it out*.
10:00:13 <Alpounet> combining pure haskell level optimisations (fusion and all) and llvm optimisations yield very nice speedups
10:00:16 <Cale> philo: The GHC compiler compiles from Haskell all the way down to native code even without the LLVM backend, and it already passed through a number of lower-level languages.
10:00:17 <BONUS> is bos' llvm haskell package used for llvm IR generation in GHC?
10:00:21 <pikhq> LLVM can optimise *still more*.
10:00:44 <Alpounet> BONUS, AFAIK, no
10:00:52 <Alpounet> it just calls llvm binaries and all
10:00:57 <philo> but by the time the LLVM IR is generated many "compile" decision have allready been made , no ?
10:01:05 <pikhq> philo: ... Yes.
10:01:13 <Cale> I think it goes Haskell -> Core -> C-- -> LLVM -> Native with the LLVM backend
10:01:17 <BONUS> Alpounet: but it still has to make some LLVM IR and then call the LLVM binaries to generate code?
10:01:19 <pikhq> That's because LLVM is one of the lower-level passes.
10:01:40 <BONUS> ah, it goes from C-- to LLVM. how's that achieved though?
10:01:43 <Cale> But I wouldn't be the one to ask
10:01:46 <philo> pikhq: ok
10:01:57 <BONUS> do they use the C++ LLVM libraries or haskell ones
10:02:09 <Cale> I would hope the Haskell binding.
10:02:13 <Alpounet> Cale, IIRC you're right. See the nice graphics on dons' post
10:02:23 <philo> pikhq:  so some of the "optimization oportunities" can only be seen by the front end
10:02:36 <philo> i mean the thing generating the IR
10:03:01 <Alpounet> BONUS, I just tell you that because as far as I'm aware of, I haven't installed the llvm haskell library while building my ghc-llvm
10:03:15 <BONUS> ahh
10:03:28 <Alpounet> so I guess the answer is no, but I haven't looked further
10:03:38 <Cale> philo: The C-- code that GHC generates is extremely stylised and looks nothing at all like something a human would write
10:03:48 <Alpounet> BONUS, you can check David Terei's git repo for more informations
10:04:08 <Cale> (even structurally)
10:04:21 <Cale> Obviously, lazy evaluation has a lot to do with that ;)
10:04:34 <BONUS> yeah i might czech that out
10:04:37 <Cale> Variables in the Haskell code (mostly) turn into code pointers.
10:04:53 <Zao> Cale: I'm sure that you'll find a suitably deranged human programmer somewhere that emits GHC-like C--.
10:05:27 <philo> haskell  to_c_by_ghc then to LLVM IR ?
10:05:47 <Cale> philo: It doesn't go to C
10:05:50 <Zao> I doubt it goes via C.
10:05:58 <Cale> philo: There is a C backend, but that's separate
10:06:06 <Cale> (and somewhat deprecated)
10:06:24 <philo> ok
10:06:28 <Cale> and there's another native code generator
10:09:18 <Cale> C-- is the name of one of the intermediate languages that it uses
10:10:04 <philo> ok
10:10:16 <philo> didnt notice the "--"
10:11:57 <MissPiggy> are brains homogeneous or do they have fractal structure?
10:12:53 <lament> well I can only speak for myself, but my brain is def. homogenous
10:19:33 <Veinor> sounds like YOU need a zygohistomorphic prepromorphism!
10:20:01 <zygoloid> MissPiggy: my brain is fractalline, for infinite storage density.
10:23:38 <benjamin_scarlet> What am I doing wrong here? "class C i where { type F i :: * -> * }; data D; instance C D where { type F D r = r }"
10:25:02 <MissPiggy> benjamin, you need to do
10:25:06 <MissPiggy> type F D = Id
10:25:07 <MissPiggy> where newtype Id x = Id x
10:25:48 <benjamin_scarlet> Thanks. That works. Why?
10:25:57 <MissPiggy> the error messaged doesn't explain why?
10:26:07 <MissPiggy> or do you mean what would the implications be if you could?
10:29:28 <benjamin_scarlet> The error message is "Number of parameters must match family declaration". I interpreted my "type F i :: * -> *" to  mean my declaration said F had two parameters, so I didn't understand the message. I can see the difference for some interpretations of "number of parameters", so I can now understand that much, but I still don't really understand if anything's fundamentally different between what I wanted to do and what works.
10:30:05 <MissPiggy> type F [[i]] :: * -> * <-- parameters
10:30:08 <MissPiggy> type F i :: [[*]] -> * <-- arguments
10:30:31 <MissPiggy> so type F a b c d :: * -> (* -> *) -> *  has four parameters and two arguments
10:32:59 <pastorn> @src forM_
10:33:00 <lambdabot> forM_ = flip mapM_
10:35:40 <benjamin_scarlet> MissPiggy: Thanks, that helps. Now I'm just curious why the restriction's necessary.
10:37:36 <zygoloid> benjamin_scarlet: suppose someone wrote: 'instance Foo (F a) where ...'. in order for that to be legal, (F a) must be a unary type constructor (and not just a unary type synonym)
10:41:42 <copumpkin> holy crap, a haskell article on /r/programming that has 75% upvotes
10:41:47 <copumpkin> dons: amazing!
10:42:22 <benjamin_scarlet> zygoloid: I can imagine negative consequences due to that distinction, but only fuzzily due to lack of experience & understanding. Thanks though.
10:43:37 <chrisdone> reddit gives me 503 Service Unavailable
10:43:43 <chrisdone> o-oh!
10:44:02 <copumpkin> onoes
10:44:06 <chrisdone> "No server is available to handle this request." they gone to answer the door?
10:47:00 <MissPiggy> benjamin_scarlet you could implement SK combinators for example
10:47:07 <dons> copumpkin: :)
10:47:11 <MissPiggy> benjamin_scarlet so if it were possible you'd basically have general computation in the type level
10:47:32 <MissPiggy> benjamin_scarlet and we don't want that because then compiling might never stop
10:49:53 <sepp2k> That didn't stop the C++ people from implementing templates...
10:50:25 <MissPiggy> yeah we can learn form C++
10:50:28 <benjamin_scarlet> On the one hand, I'm looking guiltily at my UndecidableInstances. On the other, I wonder why we're willing to leave halting at run-time to the programmer, but don't trust them with it at compile time.
10:50:31 <MissPiggy> from*
10:50:53 <benmachine> UndecidableInstances are okay in my book
10:51:09 <esr> We can learn from C++ mainly what *not* to do (says an admitted Haskell newbie)
10:51:15 <benmachine> but I think it's sensible that your compiler halts unless you give it permission not to
10:53:22 <copumpkin> I want vice versa!
10:53:41 <copumpkin> halting is taking a break, and I want my compiler to work non-stop unless I give it permission to take a break
10:56:44 * twink is unsure what the difference is between UndecidableInstances and the other one that sounds similar.
10:57:07 <benmachine> there are a few Instances ones
10:57:13 <aavogt> incoherent ones
10:57:21 <twink> That's the one.
10:57:23 <benmachine> IncoherentInstances is seriously nasty
10:57:30 <benmachine> you basically just pick stuff at semi-random
10:57:47 <benmachine> (possibly I have been misinformed, but that's what it sounded like to me)
10:57:48 <copumpkin> luckily we've kept it contained to that flag
10:57:50 <copumpkin> ...not! :P
10:58:11 <copumpkin> dolio has a nice way to get the behavior of incoherent instances without turning it on
10:58:19 <benmachine> that sounds like fun
10:58:20 <MissPiggy> oh how?
10:58:21 <twink> Okay, well, the instance extensions are unclear in general.
10:58:38 <benmachine> twink: they all make sense in retrospect, sort of
10:58:44 <benmachine> I bet you can guess what OverlappingInstances does
10:59:00 <benmachine> and Undecidable just means, maybe this problem isn't solvable, but I'll try anyway
10:59:04 <copumpkin> MissPiggy: http://www.haskell.org/pipermail/glasgow-haskell-users/2010-February/018366.html
10:59:26 <twink> Overlapping instances I think I know well enough to have an idea of what goes on.
10:59:59 <benmachine> some people think overlapping instances are a bad idea
11:00:02 <benmachine> generally I agree
11:00:05 <twink> I suspect I'm thinking of things from what may be closer to an implementor's POV than whatever is going on here, hence the impedance mismatch.
11:03:17 <MissPiggy> I don't understand it copumpkin :\
11:03:49 <copumpkin> what part?
11:04:52 <benmachine> copumpkin: the next message in the list makes a fairly reasonable argument for why it's not really incoherent
11:05:18 <copumpkin> did you read the next one still?
11:05:33 <copumpkin> and then SPJ's reply
11:06:22 <benmachine> no I got bored
11:06:24 <benmachine> sry
11:07:16 <copumpkin> lol
11:07:23 <copumpkin> can't argue with that
11:09:15 <benmachine> well no I didn't get bored really I just had an attack of "eek I have loads to do and I am messing about on the internet instead"
11:10:10 <benjamin_scarlet> I can't manage to recurse up the natural numbers w/ Data.TypeLevel naturals. Simpler, unary-encoded type-level naturals, while less cool, seem to work better.
11:11:47 <MissPiggy> benjamin_scarlet what's it for?
11:14:06 <benjamin_scarlet> I want to compile a projection operator (selection of the nth member from a tuple) to LLVM. The LLVM bindings use a Data.TypeLevel number as the index for the LLVM operation.
11:14:29 <twink> I've not seen or heard of Data.TypeLevel
11:14:43 <benjamin_scarlet> twink: it's in hackage
11:17:38 <copumpkin> jaspervdj: congrats!
11:17:46 <jaspervdj> copumpkin: thanks :-)
11:17:54 <twink> benjamin_scarlet: I'm assuming it's binary or decimal -encoded. What goes wrong with it that you back down to unary?
11:22:08 <olsner> hmm, the #haskell tab was highlighted... lambdabot should have a command to let me see when I was last mentioned
11:22:21 <olsner> that, or my IRC client should have one
11:22:26 <MissPiggy> olsner what client
11:22:39 <olsner> MissPiggy: xchat
11:22:45 <MissPiggy> hm I don't think it does
11:22:54 <twink> I was asking benjamin if the Data.TypeLevel problems had to do with unary vs. binary/decimal/etc. encoding.
11:23:17 <benjamin_scarlet> twink: If I know "Nat i" and want to recurse up to i+1, in the unary encodings the context is sufficient to call "succ i". With Data.TypeLevel, I wind up in a maze of twisty context-requirements, all different.
11:23:22 <olsner> bah, I have grep and logs! what other tool support do I need?
11:23:36 <benmachine> /lastlog is pretty useful
11:23:39 <benmachine> 13:29:26 < lambdabot> olsner says: nah, SkyNet is just a zygohistomorphic  prepromorphism, nothing fancy
11:23:48 <benmachine> (six hours ago)
11:23:55 <olsner> ah, I see
11:24:06 <twink> benjamin_scarlet: Because you might have to carry?
11:24:08 <benmachine> possibly before that but that's all that's in my recent log
11:24:12 <olsner> ah, being quoted is also fun, I like it when that happens :D
11:24:29 <benmachine> yes
11:24:36 <olsner> last thing mentioning "olsner" before that is me saying something last night
11:27:05 <benjamin_scarlet> twink: I guess - it's someone else's implementation. It seems to have the property that although Succ i j has instances for any i such that Nat i, and has functional dependencies i -> j and j -> i, the compiler can't figure out that Succ i j given Nat i. I can't figure out how to help the compiler.
11:27:41 <benjamin_scarlet> twink: or if I'm just thinking about it wrong. I'm not too good with type level programming yet.
11:29:07 <twink> benjamin_scarlet: That's supposed to be one of the things that Just Works (TM).
11:29:57 <medfly> olsner, I just search my logs for my nick and use tail.
11:30:10 <olsner> medfly: me too
11:32:00 <twink> ... if the format of the log is done well enough you might be best off using awk
11:33:28 <olsner> hmm, how do you mean? I don't really want to limit myself to my nick appearing in a specific position or anything, I get highlighted for anything that has the nick as a substring anyway
11:34:57 <twink> benjamin_scarlet: I suspect any decimal/binary/etc. type level nats with the trouble doing induction you're describing might not be very useful, or might have a bug or rely on some unusual extension.
11:35:26 <twink> olsner: There are a limited number of positions the nick can appear in anyway.
11:36:03 <benjamin_scarlet> twink: should it Just Work (TM) if a hypothetical new instance of Nat might not have a corresponding Succ? That might be what's going on. In the unary encodings, one can wrap any Nat in another constructor, so even if someone was evil and added extra instances of Nat, succ could still work. In the other encodings, I think it'd be a lot harder to make succ appear to work even for bogus extra instances.
11:36:53 <Tarrasch> I can't erase text I've written in the ghci console when using getLine, is there any quick fixes to this common problem?
11:37:01 <olsner> is it limited by anything more than the maximum number of words (or characters) that fit into whatever limit my client or the server has?
11:37:23 <twink> benjamin_scarlet: Oh boy, open world assumption bites us in the arse again.
11:37:55 <MissPiggy> does anyone have an example of making a standalone binary with LLVM?
11:38:13 <MissPiggy> all the ones that come with it compile into a haskell function
11:39:11 <benjamin_scarlet> MissPiggy: you mean with the haskell bindings to LLVM?
11:39:27 <MissPiggy> yeah
11:41:00 <benjamin_scarlet> Do you need an executable, or just an object? LLVM.Util.File.writeCodeGenModule will emit LLVM bitcode, which you can then use with the llvm command line tools.
11:41:05 <tommd> Does anyone have a link to Coutts patch for gtk2hs?
11:41:10 <MissPiggy> I want an executable
11:41:23 <MissPiggy> oh so you just ocmpile it sepearatetly , taht's cool
11:42:05 <BONUS> once you have the bitcode it's just a matter of feeding it to the appropriate llvm command line tool, yeah
11:42:42 <BONUS> hmm, is there a way to see the IR?
11:43:05 <benjamin_scarlet> BONUS: emit bitcode and use llvm-dis
11:44:40 <MissPiggy> but how :(
11:44:53 <benjamin_scarlet> MissPiggy: how what?
11:55:24 <MissPiggy> how to make a binary with llvvm
11:55:32 <MissPiggy> fro haskell
11:57:06 <dschoepe> MissPiggy: there's a llvm backend for ghc, iirc.
11:57:28 <dschoepe> http://donsbot.wordpress.com/2010/02/21/smoking-fast-haskell-code-using-ghcs-new-llvm-codegen/
11:57:31 <copumpkin> you need to get the latest GHC head, apply the llvm patches to it
11:57:34 <copumpkin> and then build it
11:57:38 <MissPiggy> I don't want that
11:57:44 <olsner> and get the right llvm with patches
11:57:49 <BONUS> i think she wants to use the LLVM haskell package to make a binary
11:57:54 <copumpkin> ah
11:58:03 <BONUS> not compile GHC with the llvm integration
11:58:05 <copumpkin> did you see augustss's blog potss on it?
11:58:19 <BONUS> but yeah the LLVM package seems a bit under-documented
11:58:19 <dschoepe> ah, I misinterpreted the "fro haskell"
11:58:37 <benjamin_scarlet> 1) use writeCodeGenModule (like examples/Struct.hs) to emit a bc file. 2) use llc to generate assembly, a .s, from the .bc. 3) use your system assembler to make a .o from the .s 4) use your linker to make an executable from the .o
11:59:15 <MissPiggy> okay
12:00:06 <jcreigh> I am probably mistaken about this, but ISTR hearing somewhere that LLVM doesn't currently support directly generating, eg, an ELF binary, it just outputs assembly for the system's assembly to deal with. That being the case, benjamin_scarlet's suggestion is probably best.
12:00:28 <jcreigh> *system's assembler
12:01:45 <benjamin_scarlet> Of course most c-compilers will do 3+4 for you.
12:02:18 <stevenmarky> how can I enter a type signature into GHCI
12:02:21 <MissPiggy> someone should make hello world P
12:02:21 <MissPiggy> :P
12:02:54 <Polarina> Is there an alternate version of fold that stops folding when a changes from Nothing to Just something, or something like that? I am folding over an infinite list, looking for some particular value of interest.
12:03:02 <Polarina> But wish to stop eventually.
12:03:36 <erl_> hello. i'm trying to solve a classic set intersection problem on some ejudge system using binary trees. But even reading a set (represented as "12 12 3  332 -1"-like string) into a tree is rejected with reason "Memory limit". Here's the reading code: http://b23.ru/ekrq
12:03:41 <MissPiggy> :t foldl
12:03:42 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
12:03:55 <benmachine> Polarina: when you want infinite lists, you want foldr
12:04:03 <erl_> how can memory consumption be improved?
12:04:05 <MissPiggy> > foldl' (\x y -> if y == 100 then x else x + y) 0 [1..]
12:04:09 <lambdabot>   mueval-core: Time limit exceeded
12:04:10 <benmachine> usually
12:04:32 <benmachine> and by usually I mean "always, I think"
12:04:44 <MissPiggy> @src foldl
12:04:45 <lambdabot> foldl f z []     = z
12:04:45 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
12:05:06 <tromp> :t maybe
12:05:06 <benmachine> foldl *has* to be called for every element of the list
12:05:07 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
12:05:22 <benmachine> there's no case in which the recursive call isn't made
12:05:26 <benmachine> for foldr on the other hand:
12:05:27 <benmachine> @src foldr
12:05:28 <lambdabot> foldr f z []     = z
12:05:28 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
12:05:37 <benmachine> the recursive call's only made if demanded
12:07:52 <benjamin_scarlet> For the record, LLVM does support directly writing some system object formats, but I don't think that functionality's exposed in the Haskell bindings right now.
12:08:45 <benmachine> Berengal_: oh hey by the way it just occurred to me re: that destructList stuff, the one I defined in terms of foldr seems to be strict in the list spine (doesn't work on infinite lists), reckon it can be fixed?
12:09:23 <Polarina> benmachine, what does that nice tool do?
12:09:42 <benmachine> nice tool?
12:09:48 <Polarina> benmachine, foldr?
12:10:00 <benmachine> erm
12:10:00 <tromp> > foldr (maybe id const) [Nothing, Nothing, Just 42, Nothing, Just 17]
12:10:01 <lambdabot>   []->
12:10:02 <lambdabot>    [Nothing,Nothing,Just 42,Nothing,Just 17]
12:10:02 <lambdabot>  [Nothing]->
12:10:02 <lambdabot>    [Nothing,...
12:10:03 <mtnviewmark> Am I correct in thinking that I can't derive a Data instance for something like     newtype Foo = Foo { runFoo :: Bar -> Baz }
12:10:09 <benmachine> heh
12:10:19 <benmachine> Polarina: it's a general way of recursing over a list
12:10:21 <Berengal_> benmachine: It probably can by folding up crazy functions, like how I did tail
12:10:33 <tromp> > foldr (maybe id const) Nothing [Nothing, Nothing, Just 42, Nothing, Just 17]
12:10:34 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe a))
12:10:34 <lambdabot>    arising from the lite...
12:10:48 <Polarina> benmachine, looking at its type, I do not see how it can survive an infinite list any better than foldl.
12:11:08 <benmachine> Polarina: if the call to f doesn't need its second argument, it's not evaluated
12:11:18 <benmachine> so the recursive call doesn't happen
12:11:25 <Polarina> Ah.
12:11:28 <benmachine> > foldr const [] [1..]
12:11:29 <lambdabot>   No instance for (GHC.Enum.Enum [a])
12:11:29 <lambdabot>    arising from the arithmetic sequence...
12:11:32 <benmachine> hmm
12:11:34 <benmachine> > foldr const 0 [1..]
12:11:35 <lambdabot>   1
12:11:46 <Polarina> But for foldl, when you need the a, it has to evaluate everything.
12:12:06 <Polarina> Any version of foldr for monads?
12:12:07 <benmachine> Berengal_: oh, I think it just needs the tuple pattern match to be ~lazy
12:12:11 <Polarina> Like foldM?
12:12:15 <Berengal_> benmachine: That could work as well
12:12:26 <benmachine> :t foldM
12:12:27 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
12:12:37 <benmachine> @src foldM
12:12:37 <lambdabot> foldM _ a []     = return a
12:12:37 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
12:13:00 <Berengal_> That's a left fold
12:13:13 <Polarina> Isn't foldr strict?
12:13:18 <Berengal_> Nope
12:13:18 <benmachine> well, it's still possible for the recursive call not to happen if >>= is lazy
12:13:21 <Polarina> Ah, nice.
12:13:27 <Berengal_> benmachine: That's true
12:14:23 <Polarina> @src foldr
12:14:24 <lambdabot> foldr f z []     = z
12:14:24 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
12:14:25 <Berengal_> Polarina: foldr is as strict as the reduction argument. Foldl is strict in the spine of the list or as strict as the reduction function, whichever is strictest
12:14:37 <Berengal_> Or something...
12:15:12 <Polarina> To me, it looks like foldr doesn't handle infinite lists.
12:15:23 <Berengal_> foldM is like a mapM and iterateM combined...
12:15:37 <benmachine> Polarina: do an expansion of foldr const 0 [1 ..] by hand
12:15:46 <benmachine> it shouldn't take long to work out why it terminates
12:15:49 <medfly> > take 10 $ foldr (:) [] [1..]
12:15:50 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
12:15:56 <Polarina> benmachine, what's const?
12:15:59 <Berengal_> > foldr (\x r -> if x == 10 then x else x + r) 0 [1..]
12:15:59 <lambdabot>   55
12:16:03 <benmachine> Polarina: const x _ = x
12:16:10 <Polarina> Hmm.
12:16:15 <benmachine> a function which ignores its second argument
12:16:31 <benmachine> good way of making a lazy function for demonstration purposes
12:16:33 <benmachine> good for HOFs
12:17:01 <Polarina> So once I ignore the second argument of f, foldr stops?
12:17:39 <Berengal_> > foldr (fun "const") z [a,b,c,d,e]
12:17:40 <lambdabot>   const a (const b (const c (const d (const e z))))
12:17:52 <copumpkin> Polarina: yep
12:17:55 <benmachine> putting the fun in function
12:18:29 <Polarina> copumpkin, cool.
12:19:01 <tromp> :t mappend
12:19:02 <lambdabot> forall a. (Monoid a) => a -> a -> a
12:19:12 <c_wraith> > let head = foldr const undefined in head [1..]
12:19:13 <lambdabot>   1
12:19:28 <Tarrasch> Does anyone knows how to fix the getLine() so using backspace and arrow-buttons on my keyboard does what you would expect it too?
12:20:02 <voker57> use readline or whatever
12:20:20 <voker57> you can't "fix" getLine... it requires terminal tampering iirc
12:20:33 <c_wraith> well, use haskeline
12:20:41 <c_wraith> The pure haskell lib is the best bet there
12:20:44 <mauke> Tarrasch: backspace should just work
12:20:53 <mauke> full blown line editing is harder
12:23:23 <Tarrasch> Hmm.. readLine requires me to install more packages?
12:23:32 <c_wraith> use haskeline, not readline
12:23:52 <Tarrasch> c_wraith, will that require additional packages?
12:24:09 <c_wraith> not OS packages.  readline has externel dependencies.  haskeline has only haskell dependencies
12:25:12 <Polarina> What was the shorter version of (flip . (>>=))?
12:25:23 <MissPiggy> :t flip . (>>=)
12:25:24 <lambdabot> forall a b a1. (a -> a1) -> a -> (a1 -> a -> b) -> b
12:25:30 <Tarrasch> =<< ?
12:25:31 <MissPiggy> woah
12:25:34 <MissPiggy> what the hell is that
12:25:35 <Polarina> Tarrasch, Thanks.
12:25:37 <copumpkin> that's flip (>>=)
12:25:42 <MissPiggy> ?djinn (a -> a1) -> a -> (a1 -> a -> b) -> b
12:25:42 <lambdabot> f a b c = c (a b) b
12:25:44 <copumpkin> MissPiggy: it's using the ((->) a) monad
12:26:02 <copumpkin> and functor
12:26:11 <copumpkin> since flip is generalized now
12:26:12 <Tarrasch> c_wraith, well it's an assignment you see, I better keep myself to getLine...
12:26:31 <copumpkin> Polarina: so I assume you meant flip (>>=) ?
12:26:31 <c_wraith> Tarrasch: in that case, yes
12:26:32 <MissPiggy> Tarrasch: The assignment says   flip . (>>=)   ?
12:26:32 <MissPiggy> ?
12:26:35 <Polarina> copumpkin, yes.
12:26:39 <copumpkin> ah
12:26:45 <MissPiggy> Tarrasch: that (.) is really weird
12:27:02 <benjamin_scarlet> How do I write a constraint on an associated type?
12:27:03 <Tarrasch> MissPiggy, oh, no Im talking about getLine variations ..., noting to do with bind...
12:27:04 <MissPiggy> oh
12:27:07 <MissPiggy> ok
12:27:19 <BONUS> hmmm, say you have data Foo s a = Foo s a, how would you write a function with a type of (forall s. Foo s a) -> a
12:27:25 <Polarina> my'foldr :: (Monad m) => (t -> b -> m b) -> b -> [t] -> m b    -- :)
12:27:34 <copumpkin> benjamin_scarlet: you don't
12:27:41 <copumpkin> benjamin_scarlet: unless I misunderstood you
12:27:58 <MissPiggy> BONUS  think that's impossible
12:28:05 <benjamin_scarlet> For any particular reason?
12:28:29 <BONUS> yeah i can't seem to manage it
12:28:30 <MissPiggy> BONUS but you can justify using unsafeCoerce or similar to implement it by a parametricity argument
12:28:45 <BONUS> how did ST manage it, i wonder
12:28:53 <benmachine> isn't ST magic?
12:28:55 <benmachine> in some sense anyway
12:28:55 <benmachine> no
12:29:07 <MissPiggy> ST = IO, they use unsafePerformIO
12:29:09 <benmachine> it's been implemented in pure haskell in the last Monad.Reader wasn't it?
12:29:11 <Polarina> BONUS, Isn't that quite easy?
12:29:25 <benmachine> okay my grammar was confused there but my point stands
12:29:26 <BONUS> Polarina: try it :)
12:29:30 <Polarina> my'extract (Foo s a) = a
12:29:33 <Polarina> BONUS, and map over that.
12:29:37 <BONUS> that gives you a type error
12:29:41 <Polarina> How so?
12:29:54 <MissPiggy> # Implementing STM in pure Haskell by Andrew Coppin ?
12:30:17 <BONUS> couldn't match expected type `forall s. Foo s a' against inferred type `Foo s a1'
12:30:18 <benmachine> that is what I meant but I have always been confused as to the difference between ST and STM
12:30:25 <BONUS> MissPiggy: i'll czech that out
12:30:32 <MissPiggy> BONUS ??
12:30:38 <MissPiggy> that's irrelevant to this
12:30:43 <BONUS> oh
12:30:49 <MissPiggy> I was just looking it up because he said so
12:31:22 <benmachine> "they use unsafePerformIO" is arguably not a complete answer :P
12:31:31 <MissPiggy> why not
12:31:43 <BONUS> benmachine: ST is mostly used for making pure functions that use mutable state internally, whereas STM is for transactional communicating between threads
12:31:46 <MissPiggy> newtype ST a = IO a
12:31:50 <MissPiggy> STRef = IORef
12:31:51 <MissPiggy> etc...
12:32:00 <benmachine> MissPiggy: mm, fair enough
12:32:01 <MissPiggy> well that's not quite right
12:32:04 <MissPiggy> newtype ST s a = IO a
12:32:29 <MissPiggy> and as I said the use of unsafeCoerce/unsafePerformIO/adding it as a primitive is justified by parametricity
12:32:52 <benmachine> software transactional memory and state transformer
12:32:56 * benmachine notes this down
12:33:00 <copumpkin> BONUS: I succeeded!
12:33:10 <BONUS> copumpkin: how
12:33:14 <copumpkin> magick
12:33:18 <BONUS> undefined?
12:33:20 <Polarina> imagemagick?
12:33:22 <copumpkin> nope
12:33:23 <BONUS> do show
12:33:25 <copumpkin> how can I test that it's right?
12:33:26 <benmachine> extract = extract
12:33:34 <benmachine> <_<
12:33:38 <MissPiggy> testing ? yuk :P
12:33:46 <copumpkin> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23145#a23145
12:34:39 <BONUS> wwhoa
12:36:51 <copumpkin> BONUS: what are you doing with it?
12:37:01 <MissPiggy> also http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23145#a23146
12:37:05 <BONUS> nothing in particular, just messing with types
12:37:08 <MissPiggy> slightly less magic
12:37:13 <copumpkin> MissPiggy: aw, cute
12:37:13 <BONUS> it's what i do instead of playing solitaire i guess
12:37:18 <copumpkin> now I feel silly
12:37:42 <MissPiggy> this is all just an ugly work around for not having type application
12:38:47 <monadic_kid> Pillars of state - explicit passing, implicit passing (state transformer monad), local mutable references/arrays ST monad, global mutable references/arrays IORef
12:39:06 <copumpkin> dyadic_kid?
12:39:55 <monadic_kid> dyadic?
12:40:35 <monadic_kid> I just thought that would be a good blog entry, Pillars of State
12:42:48 <monadic_kid> wait i could add another one actually
12:43:27 <BONUS> i don't see explicit passing as a particularly stateful thing
12:43:41 <BONUS> i mean pure functions also use explicit passing
12:43:41 <monadic_kid> BONUS: pass and return to emulate
12:43:43 <vespasian> Hi, I don't suppose any Gtk2Hs gurus are around?
12:44:00 <copumpkin> it's the emperor!
12:44:05 <monadic_kid> Pillars of state - explicit passing, acculative-params,  implicit passing (state transformer monad), local mutable references/arrays ST/STRef, global mutable references/arrays IORef
12:44:15 <vespasian> I'm trying to use `buttonPressed' to emit a button press event, but it doesn't appear to be doing anything!
12:44:29 <monadic_kid> *accumlative parameters
12:44:44 <monadic_kid> ...
12:44:58 <monadic_kid> accumlating parameters
12:45:08 <MissPiggy> accumlating parameters parameters parameters
12:46:34 <monadic_kid> I think that would have been a really useful blog to me a while back
12:47:13 <MissPiggy> monadic_kid are you goingi to write it then
12:47:40 <monadic_kid> maybe
12:47:55 <BONUS> im actually reading the "Implementing STM in pure Haskell" article and it's really cool, recommended reading
12:49:03 <monadic_kid> Maybe Explicit/Implicit plumbing is a better word?
12:51:03 <BONUS> but plumbing is a very general word
12:53:46 <monadic_kid> it's funny how golang is taking off, it's a bit sicking infact
12:53:58 <MissPiggy> why?
12:54:38 <monadic_kid> I don't need to say anything, check it out to see what i mean
12:54:48 <Adamant> because Ken Thompson is on the team
12:54:50 <MissPiggy> I have, I don't know what you think
12:54:56 <BONUS> it seems to have a niche, although i don't like it as a language too much but hey, good for them
12:54:59 <MissPiggy> please tell me
12:55:03 <monadic_kid> http://developers.slashdot.org/story/10/03/01/1317228/Google-Go-Capturing-Developer-Interest
12:55:24 <copumpkin> read the slashdot comments on that :P
12:55:37 <monadic_kid> Adamant has the idea, because it's backed by Google and Ken is behind it that is why it's getting so much attention
12:55:37 <KSkrzet> i'm trying to get GHC HEAD. "darcs get --partial http://darcs.haskell.org/ghc" tries to pull an awful lot of patches. what is the fastest way of getting the HEAD?
12:55:43 <c_wraith> the comments were mostly along the lines of "what developers?"
12:55:47 <copumpkin> yeah
12:55:54 <copumpkin> or "the article doesn't even say that"
12:56:19 <monadic_kid> go is butt ugly anyways
12:56:32 <monadic_kid> that's enough go for one day.
12:56:43 * monadic_kid go'es to have dinner
12:56:44 <MissPiggy> monadic_kid: is this go stuff the first time you noticed that the field of programming is just as impressionable and pop music, politics and celebrity magazines ?
12:56:52 <MissPiggy> s/and/as/
12:56:52 <jmelesky> my problem with go is that there were plenty of other languages in the same niche that could have been adopted instead
12:57:02 <BONUS> whatever happened to that real time clock + calculator language?
12:57:08 <copumpkin> I'm pretty disappointed that go was the best thing those people could come up with
12:57:09 <BONUS> it seemed interesting
12:57:32 <copumpkin> it's backed by fairly "illustrious" people
12:57:49 <monadic_kid> copumpkin: another ad-hoc designed langauge with no formal basis is becoming popular
12:57:57 <copumpkin> yep
12:57:58 <jmelesky> copumpkin: considering one of the requirements was "fast compilation", it's actually a pretty good effort
12:58:14 <jmelesky> the merits of "fast compilation" are, of course, debatable
12:58:30 <copumpkin> jmelesky: even then, I'm not convinced
12:58:53 <monadic_kid> yep, especially when with distributed build systems.
12:59:10 <MissPiggy> monadic_kid ?
12:59:15 <MissPiggy> did you get my question
12:59:38 <MissPiggy> and if you care so much about 'formal basis' then why you use haskell?
13:00:07 <jmelesky> at any rate. i'm disappointed in go, but any step forward from using C as an application language is a step in the right direction
13:00:28 <monadic_kid> MissPiggy: are you trying to argue with me?
13:00:50 <MissPiggy> monadic_kid: I'm kinda wondering why you pretend to leave as I ask you a question then come back and ignore it mostly
13:01:10 <monadic_kid> MissPiggy: then there is nothing to say
13:01:16 <MissPiggy> oh
13:02:18 <MissPiggy> you are the one that brought up this topic btw
13:04:25 <MissPiggy> monadic_kid: so it's a lttle weird how you flipped out like that when I tried to talk to you about something you brought up
13:04:42 <roconnor> jmelesky: doesn't asm have fast compilation?
13:04:46 <MissPiggy> monadic_kid: not sure what I did wrong or something that you decided to ignore me and nobody else?
13:04:49 <roconnor> maybe go has other requirements too
13:05:07 <copumpkin> assembly ftw!
13:05:44 <jmelesky> roconnor: of course. hence "one of the requirements". but the fact that fast compilation was a goal constrains the language design
13:06:52 <roconnor> I guess
13:08:06 <roconnor> I wonder if it they are trying to get at incremental compilation with that requirement
13:08:46 <MissPiggy> monadic_kid pm please
13:10:20 <jmelesky> roconnor: i think it was motivated largely because go is aimed at replacing C++, and C++ can have some terrible build times
13:10:47 <roconnor> it does?
13:11:03 <ben> but D had that going for it too
13:11:34 * copumpkin is a big fan of E
13:11:40 <jmelesky> ben: yeah, go seems very much a NIH language
13:11:52 <copumpkin> national institutes of health?
13:11:53 <jmelesky> roconnor: yeah, especially when templates get involved
13:11:56 * ben is not a big fan of D, but of what D could have been
13:12:00 <jmelesky> not-invented-here
13:12:03 <roconnor> jmelesky: does go have templates?
13:12:03 * inhahe wonders what kind of language E is
13:12:22 <copumpkin> it's used at certain kinds of parties
13:12:25 <inhahe> Go has some weird system that's supposed to be novel and better than inheritance that i don't understand
13:12:50 <jmelesky> roconnor: go has, basically, interfaces, if i understood the commentary correctly
13:13:13 <jmelesky> not templates, but without as strong a need for templates
13:13:18 <monadic_kid> go's interfaces are kind of like structural sub-typing in ocaml
13:13:26 <monadic_kid> MissPiggy: I'm eating dinner
13:13:41 <roconnor> that doesn't sound nearly as expressive as templates in C++
13:13:45 <MissPiggy> oh okay meaning you can chat here but not talk to me in PM
13:14:07 <MissPiggy> so turns out your just being a total fuck on purpose for reasons I can't figure
13:14:26 <ben> If I understand it correctly, the Go interfaces are still just run-time polymorphism?
13:14:38 <monadic_kid> ben: yes
13:14:49 <jmelesky> roconnor: well, yeah. that expressiveness is one of the big compile-time-inflators
13:14:53 <MissPiggy> monadic_kid: that's called being an asshole -- FYI
13:14:57 <ben> That is not really what the C++ crowd is hoping for :(
13:15:28 <monadic_kid> MissPiggy: maybe but i'm not talking aggressively to you.
13:15:37 <jmelesky> ben: not in the larger community, perhaps, but within google, sure.
13:15:47 <roconnor> jmelesky: so instead of long compilation time, go forces you to write out a bunch of code by hand, thus making the compliation time propotional to the size of the input?
13:15:52 <MissPiggy> monadic_kid: I don't want you to be aggressive, just answer my PM please
13:16:05 <medfly> hi sinelaw
13:16:35 <jmelesky> roconnor: having not written anything of size in go, i can't comment on how much boilerplate would be necessary
13:16:40 <sinelaw> hello
13:16:57 <roconnor> fair
13:18:51 * sinelaw whistles the FFI blues
13:21:48 <sinelaw> I thought I'll write some bindings / For the Haskell FFI
13:21:50 <sinelaw> I thought I'll write some bindings / For the Haskell FFI
13:21:58 <sinelaw> But when I started working
13:22:15 <sinelaw> A tear dropped out of my eye
13:22:20 <monadic_kid> http://xkcd.com/386/
13:22:30 <inhahe> Hahah
13:22:33 <sinelaw> hit it, steve!
13:23:20 <opqdonut> :D
13:34:49 <roconnor> whats the colimit of a diagram consisting of one arrow?
13:35:28 * ben draws an arrow on a piece of paper and stares at it in confusion
13:35:38 <copumpkin> one arrow and no objects? :P
13:35:56 <roconnor> two objects :D
13:37:04 <lament> is a piece of paper an object or just a piece of an object?
13:37:27 <inhahe> is a pair of pants two objects or just one?
13:37:28 <roconnor> there is no paper; this is why ben is confused
13:37:41 <copumpkin> you'd need a topos for the latter, wouldn't you?
13:37:58 <copumpkin> (the "just a piece of an object" bit)
13:38:27 <Becquerel> a pair of pants is one object and two lacks of one object
13:38:47 <copumpkin> roconnor: "A colimit of a diagram consisting of two (or more) objects is their coproduct." maybe?
13:38:53 * Becquerel wonders what a copair of pants would look like
13:39:00 * copumpkin isn't master enough yet to actually know the answer
13:39:39 <c_wraith> wouldn't it be more interesting to describe copants?
13:39:45 <Becquerel> possibly so
13:40:07 <roconnor> copumpkin: no no
13:40:20 <roconnor> copumpkin: one arrow, two objects, the source and target of that arrow
13:40:20 * copumpkin pouts
13:40:32 <roconnor> I think it might be id.
13:40:53 <copumpkin> where's ddarius when you need him
13:42:53 <xerox> he's on twitter
13:42:59 <copumpkin> lol
13:43:10 <copumpkin> I'm sure he hates that someone might think that
13:43:26 <Daerim> I am confused.... Hieroglyph requires ghc 6.12 and gtk2hs. gtk2hs requires c2hs. c2hs won't compile under ghc 6.12....
13:43:29 <xerox> now his ears are whistling :D
13:44:20 <Daerim> Nevermind.... asking for help always makes me figure things out.... bah
13:45:05 <xerox> #haskell aura + thinking while typing = success
13:46:43 <Daerim> Indeed :p
13:47:26 <c_wraith> thinking while typing?  Is thinking the part I'm forgetting?
13:47:40 <sinelaw> naooohhhh.....
13:47:46 <sinelaw> 1+1=3
13:47:53 <sinelaw> ^H^H^H^H^H
13:47:54 <sinelaw> 2
13:48:04 <xerox> (for large values of 1)
13:48:05 <luite> Daerim: the darcs version of gtk2hs does compile with ghc 6.12 (at least on linux)
13:48:29 <luite> oh sorry you said c2hs
13:48:46 <Daerim> luite, well both actually....
13:48:52 <Daerim> haven't tried the darcs gtk2hs
13:48:58 <c_wraith> > let 1 + 1 = 3 in 1 + 1
13:48:59 <lambdabot>   3
13:49:08 * Daerim is a madman and attempts to get gtk2hs working on windows
13:49:12 <luite> Daerim: you should disable split objs though, or something
13:51:19 <copumpkin> does llvm do any whole-program stuff? like if we generated all the IR for all modules at once, could it treat them all as a huge module and do smart stuff?
13:54:40 <pikhq> copumpkin: Yes.
13:55:00 <pikhq> copumpkin: If your linker supports it, you can do link-time optimisation with it.
13:55:36 <benjamin_scarlet> copumpkin: llvm has a linker which folds bytecode to bytecode, and a bytecode optimizer.
13:55:48 <sinelaw> and copumpkin to bytecode
13:55:53 <sinelaw> but not the other way.
13:55:57 * sinelaw shuts up.
13:57:13 <benjamin_scarlet> copumpkin: better said, the linker folds [IR] to IR. The use of bytecode is a serialization detail.
13:59:06 <pvdbrand> hi, is there a function to ask for the (currently) available amount of memory? googling didn't help me
13:59:34 <mauke> no
13:59:58 <c_wraith> that's not a fully-defined question, anyway.  The runtime will allocate more memory if it needs it
14:00:00 <pvdbrand> not the answer i was hoping for :)
14:00:48 <mauke> my answer isn't limited to haskell
14:00:49 <pvdbrand> I want to implement a kind of cache, which will automatically remove LRU items if the amount of available RAM would drop below some threshold
14:01:23 <copumpkin> pvdbrand: why not just set a bound on how much memory is in the cache itself?
14:01:47 <copumpkin> pvdbrand: the user can figure out how much memory they want to give your cache and that may be a function of the total memory available (if they have some way of computing it)
14:01:52 <pvdbrand> copumpkin: because I want to use a Data.Map.Map, and I don't know how much overhead the map itself will be using
14:02:11 <c_wraith> pvdbrand: pretend it's 0.  That's fine, unless you're in an embedded system.
14:02:33 <c_wraith> pvdbrand: also, I uploaded an lrucache package to hackage not too long ago.
14:02:38 <c_wraith> @hackage lrucache
14:02:38 <lambdabot> http://hackage.haskell.org/package/lrucache
14:02:51 <c_wraith> it bounds the number of elements in the cache, rather than their size
14:02:54 <pvdbrand> I'd like to pretend it's 0, but I'm afraid the overhead might be relatively large ( a single list item already takes 20 bytes)
14:03:05 <c_wraith> But it might be a useful starting point
14:04:15 <c_wraith> calculating the size of an item in haskell isn't trivial, anyway.  Especially since sharing isn't visible, necessarily
14:04:15 <pvdbrand> c_wraith: I saw that package, but counting the number of elements is exactly what I'm trying to avoid, I'd like a more precise metric. Since it's a cache, I don't really care how many items are in it but rather that I'm using memory as much and precisely as possible
14:04:44 <copumpkin> why not allow the user to specify his cost function?
14:04:52 <pvdbrand> c_wraith: that's right, and other parts of my program may (temporarily) need more memory, and they need to have priority
14:05:11 <pvdbrand> I don't want to bother my users with this
14:05:13 <c_wraith> sharing might make size amounts be overreported.  thunks might hold thousands of times more memory than you think an item should
14:05:46 <copumpkin> you'd need something like vacuum, in case someone gives you a structure with a tied knot
14:06:11 <pvdbrand> I understand all the issues, so just querying the system for the amount of memory seems like a valid use case for a function like getFreeMemory :: IO Integer to me
14:06:23 <c_wraith> It's still not defined.
14:06:28 <benjamin_scarlet> pvdbrand: What does "available RAM" mean in a world with virtual memory? Also, if you have multiple such caches, who gets the memory? You can easily make dynamic systems with very weird behavior with such a dependency on global state.
14:06:30 <copumpkin> except at the OS level, such a function doesn't exist
14:06:39 <copumpkin> because there are a million things it might mean
14:07:12 <copumpkin> pvdbrand: there was a huge debacle recently about someone claiming windows 7 was wasteful of memory because the "free memory" metric reported little free memory
14:07:23 <copumpkin> but in modern OSes, free memory is a useless metric
14:07:29 <copumpkin> they strive to keep memory unfree in smart ways
14:07:45 <erikc> you paid for the memory, you should want it used :P
14:08:37 <copumpkin> you could talk about free memory + memory that could be freed cheaply, but it's full of gray areas and you almost certainly couldn't come up with a single number for it without making lots of assumptions
14:09:15 <benjamin_scarlet> copumpkin: for example: can your own memory be freed cheaply?
14:09:20 <pvdbrand> so let's restrict the platform to Linux (posix?) and take the number reported by 'top'
14:09:34 <pvdbrand> Mem:   3096536k total,   870024k used,  2226512k free
14:09:51 <c_wraith> the number reported by top is still pretty useless.
14:09:52 <pvdbrand> seems pretty obvious to me
14:09:56 <copumpkin> pvdbrand: Mem:  33012336k total, 32231964k used,   780372k free,   329284k buffers
14:10:02 <copumpkin> Swap:  4096552k total,   121408k used,  3975144k free, 28489944k cached
14:10:06 <copumpkin> note that massive cached number
14:10:06 <pvdbrand> yeah, I want the 'free' number
14:10:17 <copumpkin> I actually have 30 GB of "usable" memory on that machine
14:10:37 <pvdbrand> and I don't want the swap stats
14:10:47 <copumpkin> I mean, that machine has 32 GB of RAM
14:10:57 <pvdbrand> I know Windows 7 works differently, but I'm not concerned by that
14:10:58 <c_wraith> that free number is not a good metric.  It swings incredibly wildly, depending on what the OS decides to swap
14:11:11 <copumpkin> pvdbrand: all I'm saying is that free number is massively misleading
14:11:25 <copumpkin> pvdbrand: it says I have 780MB free when I could actually allocate 30GB and keep it all in RAM
14:11:53 <pvdbrand> c_wraith: that's a valid argument
14:11:54 <copumpkin> that's because it's chosen to keep a lot of my disk cached in memory
14:13:31 <copumpkin> anyway, if you're on a linux machine you can probably pull those stats out of /proc
14:13:51 <copumpkin> but as we've all said, I think they're pretty useless
14:13:56 <pvdbrand> right, hence my question whether there was such a function already :)
14:14:02 <copumpkin> nope
14:14:27 <pvdbrand> sorry it took you guys some time, but you did manage to convince me
14:15:02 <copumpkin> :)
14:15:10 * copumpkin takes a shower
14:15:15 <augur> o mai
14:15:17 <c_wraith> anyway...  Feel free to use my lrucache as a base if you'd like to modify it.  any suggestions you have for me, I'd consider integrating, too.
14:15:21 * augur spies on copumpkin
14:16:43 <pvdbrand> c_wraith, yes I'll go with that. I'll let you know if I have any suggestions
14:17:06 <pvdbrand> thanks!
14:17:43 <c_wraith> also, benchmark.  Be sure that the cache is actually helping. >_>
14:18:15 <c_wraith> In the case I developed it for, it's letting me skip a database hit.  It's a win because of that...  But recalculation isn't that expensive, a lot of the time.
14:18:36 <burp> hm can one imagine an "automatic map" extension for haskell..? so when you have a function a -> b and call it with [a] you get [b]..
14:18:44 <burp> like gnu R does it
14:18:58 <pvdbrand> c_wraith: I'm caching a (possible large) map/hashtable stored on disk
14:19:00 <burp> types might be a problem
14:19:22 <c_wraith> pvdbrand: sounds like a similar use case, then
14:19:24 <pvdbrand> c_wraith: so I'm pretty sure a cache is going to help a lot
14:19:34 <burp> (+1) [1..10]  [2..11]
14:19:56 <Axman6> No instance for Num a => Num [a]
14:20:00 <Axman6> >_>
14:20:03 <burp> ;-(
14:20:11 <c_wraith> why not? >_>
14:20:28 <Axman6> 'cause i said so!
14:21:12 <burp> I'd like it.. kind of stripped <$> ;)
14:21:29 <burp> ghc could detect this and insert these itself
14:21:41 <burp> or not?
14:21:44 <xerox> > (+1) . [1..10]
14:21:45 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
14:21:55 <burp> there is still a dot ;P
14:21:58 <c_wraith> burp: that sort of automation scares me.  I worry it'll make something compile that's entirely unlike what I want
14:22:11 <burp> c_wraith: hm, true
14:38:32 <mtnviewmark> anyone have any good hints for debugging QuasiQuote TH?
14:39:00 <mtnviewmark> when using my quasiquoter I get
14:39:01 <mtnviewmark>     Exception when trying to run compile-time code:
14:39:01 <mtnviewmark>       toConstr
14:39:50 <aavogt> mtnviewmark: you can run it outside of the [$plah| |] parenthese
14:40:34 <aavogt> which reduces your problem to debugging regular calls to error
14:40:43 <mtnviewmark> well, I know the parser is working - I can parser it because (a) I had the parser working before I added QQ, and (b) if I put a syntax error (for my parser) inside the [$foo|  .. |]  i see my parser's generated error
14:40:54 <mtnviewmark> so that implies to me that my parser is running to completion
14:41:22 <mtnviewmark> I can't seem to use runQ inside ghci to try it directly inside the [$foo|  |]
14:41:48 <aavogt> what do you mean by that?
14:42:43 <mtnviewmark> If I try     runQ (qq defintions) "[$llidlSuite| .... stuff here.... |]"
14:43:00 <aavogt> runQ tends not to work because it runs in IO
14:43:04 <mtnviewmark> where (qq definitions) is what I pass as the first argument to QuasiQuoter
14:43:12 <mtnviewmark> (i.e. it is my expression quoter)
14:43:29 <aavogt> you're better off setting, -XQuasiQuotes, then running the quote as    [$foo| ... |]
14:43:48 <aavogt> hmm, but then you end up with your toConstr error?
14:44:21 * aavogt --> out
14:44:27 <mtnviewmark> okay - so now I get that error in GHCI
14:44:30 <mtnviewmark> thats step
14:44:36 <mtnviewmark> yes
14:45:05 <mtnviewmark> oddly - I have TWO quoters in the same module --- and one works fine, the other not
14:45:16 <mtnviewmark> they are defined via the same code (qq is a generic function_
14:45:36 <mtnviewmark> so - something about the data types they result in?
14:46:20 <mtnviewmark> both are deriving (Typeable, Data)
14:48:26 <mtnviewmark> If I hand call the parser and get one of my data objects, then hand call toConstr on that --- it works
14:48:50 <copumpkin> ooh mtnviewmark is back
14:49:01 * mtnviewmark waves
14:49:40 * Daerim gives up. Windows is just not a suitable haskell development platform
14:50:41 <Daerim> at least when I go "make" on linux I can expect stuff to come back compiled
14:51:05 <mtnviewmark> okay - now I can get    runQ (dataToExpQ (const Nothing) r)    to fail in ghci ----
14:51:24 <mtnviewmark> where r is one of my data objects (output of the parser -- and it seems fine)
14:51:39 <mtnviewmark> the error is     *** Exception: toConstr
14:52:02 <mtnviewmark> I've never used the debugging facilities of GHCI --- is there a way to get a, er, "backtrace" for such a thing?
14:52:17 <ezyang> Is there a way to do a O(1) freeze of a recursively defined structure in Haskell?
14:52:18 <mtnviewmark> (or whatever Haskell would have.... a "forward trace back into the future"?
14:53:41 <copumpkin> ezyang: how would that work? :)
14:54:16 <ezyang> I'm... not sure.
14:54:28 <mtnviewmark> hmm :trace didn't help a wit
14:54:31 <MissPiggy> what does freeze mean
14:54:36 <MissPiggy> you want to write it to disk?
14:54:41 <ezyang> convert a mutable object to an immutable one
14:54:47 <MissPiggy> ohh
14:54:57 <ezyang> I wanna say "bam, this object and all of the mutable stuff" to the other folder
14:55:03 <MissPiggy> that doesn't seem impossible
14:55:18 <ezyang> *and all of its pointers
14:55:27 <ezyang> s/to the other folder//
14:55:32 <mtnviewmark> is it mutable in that it a sneaky thing under the IO monad?
14:55:49 <ezyang> It's in ST
14:56:55 <ezyang> mtnviewmark: but I don't want GHC to have to copy the whole structure
14:57:12 <mtnviewmark> ah
14:57:21 <ezyang> maybe I'll reply to dons.
15:01:03 <mtnviewmark> oh - ick - I must have something that is an instance of Data but doesn't implement toConstr
15:01:07 <mtnviewmark> Data.Map perhaps?
15:01:39 <Saizan> likely
15:02:01 <mtnviewmark> AHA - dang
15:02:04 <mtnviewmark> that's it
15:02:49 <MissPiggy> @instances Integral
15:02:49 <lambdabot> Int, Integer
15:02:55 <mtnviewmark> (kinda wish Data.Map.Map's implemetnatino of toConstr was a bit more verbose --- its   error "toConstr" ---- woudln't   error "toConstr not implemented for Map" be better?)
15:03:19 <Saizan> (it would)
15:05:15 <mtnviewmark> okay - well now I'll have to parse my object to assoc lists, and then generate, in the quasi quoter, a call to something that gens the maps
15:13:47 <MissPiggy> You are late to the party. The Haskell hype is rapidly approaching the "Trough of Disillusionment", even on reddit.
15:13:52 <MissPiggy> http://en.wikipedia.org/wiki/Hype_cycle
15:14:07 <ezyang> "ah well!"
15:18:18 <tensorpudding> i remember when reddit was hyping ruby to death
15:18:37 <copumpkin> I remember when reddit was hyping cobol
15:19:16 <tensorpudding> i remember when reddit was hyping babbage's difference engine
15:19:25 <tensorpudding> that never caught on though
15:19:51 <ezyang> oblig. http://sydneypadua.com/2dgoggles/the-thrilling-adventures-of-lovelace-and-babbage/
15:19:58 <tensorpudding> heh
15:20:07 <tensorpudding> that's on my to-read comics list
15:20:37 <ezyang> There's not very many, unfortunately
15:20:42 <ezyang> (or fortunately)
15:20:53 <ddarius> If only he'd finished his analytical engine.
15:21:23 <BONUS> in the immortal words of Chuck D: Don't believe the hype
15:22:36 <tensorpudding> all this hype about structured programming
15:22:41 <tensorpudding> how could you program without GOTO?
15:22:57 * ezyang has thought up of a new discipline: "straightjacket programming" 
15:23:05 <MissPiggy> tensorpudding -- you say that as a joke but a lot of C and objc people actally don't know :|
15:23:11 * ezyang has got a manifesto half-written up and so! 
15:23:59 <Berengal_> In case anyone here has agda installed and wants the agda unicode input for other things, I discovered this quick hack: (require 'agda-input) (set-input-method "Agda")
15:25:21 <tensorpudding> do C/Obj-C people really use goto? i find that hard to believe
15:25:34 <lament> why?
15:25:36 <lament> sometimes it's the best thing.
15:25:52 <MissPiggy>  tensorpudding lol it's like "oh but it's greta for error handling"
15:26:09 <lament> sometimes goto is better than anything else.
15:26:12 <MissPiggy> and they just don't care because it's a habit and they think not using goto is like being able to go to the supermarket without being retna scanned
15:26:21 <BONUS> haha
15:27:05 <Berengal_> MissPiggy: To be fair, it is great for error handling when you don't have exceptions. For certain values of great.
15:27:08 <HugoDaniel2> hi
15:28:46 <monadic_kid> Berengal_: or banned from use in some cases for C++
15:28:56 <lament> people who are saying goto is always bad are just a subset of people who make overgeneralizations.
15:28:59 <Draconx|Laptop> MissPiggy, http://james.fabpedigree.com/dbldum.htm is a wonderful article on a use of goto not related to error handling, I think.
15:29:17 <lament> and people who make overgeneralizations are brain-dead.
15:29:39 <MissPiggy> Draconx|Laptop: yeah I know that site, he's great - that is good stuff
15:29:49 <MissPiggy> "Lessons in Expert Programming"
15:30:16 <Berengal_> Using goto to break out of nested loops is far better than using boolean guards, in languages that don't have labeled breaks.
15:31:10 <Berengal_> In the end it's all down to what idioms you're used to.
15:32:01 <p_l> MissPiggy: I find goto to be very rarely used in C (I suspect "GOTO considered harmful" to be the reason), however, there are places where it's simply the best thing.
15:32:02 <systemfault> Berengal_: That's about the only times I use goto
15:32:26 <p_l> Another example for goto usage are fast state machines
15:33:22 <Berengal_> And then there's continuations, which I guess see more use in functional languages than goto does in imperative languages
15:35:34 <mtnviewmark> WOOOT QuasiQuoting working
15:36:14 <mtnviewmark> now I can let a service implementor embed the IDL description on their API -- directly in-line in the Haskell code --- and have the interface checking code automatically generated
15:37:40 <arw> the usual case where you use goto in C is when you need to take back some initializations in case of an error.
15:38:14 <ezyang> gotos are no doubt the best error handling mechanism you have in C
15:38:43 <arw> like b = malloc(...); c = malloc(...); if(c == NULL) goto error; ... error: free(b);
15:39:11 <arw> even when you have something like exceptions, goto is often the better option to keep the code readable.
15:41:18 <Berengal_> This is one reason why I like haskell: You can just write a "withFoo" function that does the wrapping for you
15:41:36 <MissPiggy> Berengal_: yeah
15:42:31 <arw> you can always write another wrapper, of course. but thats not the nice thing about haskell.
15:42:54 <arw> the nice thing is, you can capture the structure of such an initialization/deinitialization.
15:43:37 <arw> and do something like tryInit [a, b, c, d] which initializes and deinitializes in the right order.
15:45:14 <Berengal_> That one's a bit hard though, because when you initialize something you usually want a handle to whatever's been initialized to be passed to the continuation
15:45:46 <Berengal_> And you seldom want more than one of each thing
15:45:55 <ysph> how would i go about tracing the execution of take 5 $ zipWith (+) [1..] [2..] in order to better understand lazy evaluation? just experiment with writing it out by hand?
15:46:00 <Berengal_> So you run into typing issues
15:46:22 <Berengal_> ysph: ghci has a debugger you could play with
15:46:33 <ezyang> Berengal_: Does it not suck now?
15:46:35 <Berengal_> ysph: Also, that doesn't execute anything
15:46:44 <Berengal_> ezyang: I don't know. I've never used it
15:46:50 <ezyang> bleh
15:46:54 * Berengal_ fixes bugs by staring the code into submission
15:46:57 * ezyang tried using it and was promptly very confused 
15:47:39 <Berengal_> I sometimes try staring java code into submission as well, but I get this feeling it's staring back, and then I get a bit sick :/
15:48:11 <arw> Berengal_: yes, typing will get ugly, you would have to build some datatype to handle that.
15:49:31 <ysph> Berengal_: so if i type it at ghci, show forces it to execute?, i did try setting a break point and using :step, but i couldn't seem to produce useful results that way
15:49:43 <Berengal_> arw: Couldn't you do it more easily with simple compositions though? withFile "foo" <=< withDatabase "bar" <=< withHTTPConnection "http://baz/"
15:49:53 <Cale> http://www.uni-koblenz.de/~laemmel/paradigms0910/resources/denotational2.html <-- a nice video lecture on continuations as applied to denotational semantics
15:50:46 <gwern> Berengal_: careful about that staring, and fighting monsters
15:50:52 <Cale> (and there's a lot more nice lectures from here: http://www.uni-koblenz.de/~laemmel/paradigms0910/ )
15:51:13 <arw> Berengal_: hm, maybe, yes.
15:51:15 <Berengal_> ysph: I don't know. I haven't used it :P As for show, both yes and no. It's putStrLn that forces show, which in turn forces the evaluation of the expression
15:51:45 <Cale> ysph: I would write it out by hand
15:52:06 <ysph> good enough, thanks
15:52:27 <Cale> However...
15:52:28 <Berengal_> ysph: I tend to not worry about evaluation. It mostly "just works"
15:52:50 <Cale> benmachine (who doesn't seem to be here at the moment), is writing a step-by-step Haskell evaluator
15:53:02 <Cale> Which does evaluation at the level of Haskell syntax.
15:53:21 <Berengal_> Wasn't there a g-machine javascript step-by-step interpreter as well somewhere?
15:53:26 <Cale> Using the GHCi debugger isn't likely to produce much in the way of insight, unfortunately.
15:54:29 <ysph> i'll keep an eye out for that evaluator
15:54:30 <Cale> What you really want in order to understand the way that Haskell code is evaluated is not really a way to inspect the real way that Haskell code is evaluated, but rather a tool which gives you the high-level reflections of what would be going on at the lower level.
15:54:58 <Cale> I might be able to get a link to it. It's not all that full-featured yet, but the basics are in place.
15:55:23 <Berengal_> Anyway, lazy evaluation produces the most defined value for any given expression (modulo stack overflows, unfortunately). You mostly won't care about it, and when you do it'll be rather limited in scope, mostly dealing with one or two variables
15:55:28 <Berengal_> At least that's been my experience
15:57:12 <Cale> oh, I forgot, there's a cgi version of it :)  http://benmachine.co.uk/cgi-bin/stepeval.cgi
15:57:33 <Cale> but it has no prelude
15:57:43 <Cale> So you have to define in-place every function you want to use
15:59:07 <ysph> thanks, i'll play around with it
15:59:13 <ddarius> Continuations arose from denotational semantics, I'm pretty sure.
16:00:15 <MissPiggy> how are prime numbers related to pi ?
16:00:26 <MissPiggy> zeta(2) = pi^2/6
16:00:50 <copumpkin> very deep stuff
16:01:28 <Cale> MissPiggy: Well, that's one way.
16:01:38 <Cale> MissPiggy: Do you understand how the primes are connected to zeta?
16:01:55 <MissPiggy> Cale no I just see the equation with primes in it
16:02:01 <Cale> okay
16:02:16 <Cale> The one that goes like:
16:03:23 <copumpkin> http://en.wikipedia.org/wiki/Formula_for_primes#Formula_based_on_a_system_of_Diophantine_equations
16:03:44 <Cale> product over primes p of 1/(1-p^-s) = sum over k >= 1 of k^-s
16:04:13 <HugoDaniel2> last wednesday my brother had his first lesson in programming in the univ. (and he is not taking informatics or whatever), it was C, the teacher taught the hello world
16:05:05 <Cale> MissPiggy: This is effectively the fundamental theorem of arithmetic, written in a funny way
16:05:13 <HugoDaniel2> today i asked him to write down what stayed in his mind of the hello world program, and he wrote down: printf "hello world"
16:05:22 <Cale> Let's not worry about convergence and just think about things formally.
16:05:23 <MissPiggy> Cale, let me think of that for a second
16:05:52 <Cale> Note that 1/(1-f(s)) = 1 + f(s) + f(s)^2 + f(s)^3 + ...
16:06:25 <Cale> and so 1/(1-p^-s) = 1 + p^-s + (p^2)^-s + ...
16:06:57 <HugoDaniel2> some people might argue that f(x) is more mathematical than f x
16:07:04 <Cale> (note that I used:  (p^-s)^2 = (p^2)^-s)
16:07:43 <MissPiggy> I don't see the link really
16:07:53 <Cale> Okay, I'm explaining that :)
16:08:01 <Cale> Do you understand what I wrote so far there?
16:08:04 <MissPiggy> yes
16:08:50 <Cale> Okay, so now, what happens if we pick two primes p and q and multiply out (1 + p^-s + (p^2)^-s + ...) (1 + q^-s + (q^2)^-s + ...)
16:09:08 <MissPiggy> we have a cauchy product
16:09:18 <MissPiggy> hm
16:09:18 <Cale> Each term of the product is going to consist of (p^n)^-s (q^m)^-s for some choice of n and m
16:09:32 <Cale> and we get that this is equal to (p^n q^m)^-s
16:10:12 <MissPiggy> Cale, oh for goodness sake I read the left hand side of the zeta equation wrong :(
16:10:36 <MissPiggy> since it is a product not a sum, I see what you mean about the fundamental theorem!
16:10:44 <Cale> cool :)
16:11:22 <Cale> sum over n >= 1 of n^-s  is the Dirichlet generating series for the natural numbers, where the coefficient of n^-s is 1 for each n.
16:11:42 <MissPiggy> Dirichlet generating series? is that generating functionology?
16:11:54 <twink> It's the Newton series that I can't remember the convolution for.
16:11:57 <ddarius> MissPiggy: It's briefly mentioned in that book.
16:12:08 <Cale> I hate the book generatingfunctionology, and the term "generating function", but yes ;)
16:12:11 <MissPiggy> I must have skipped that page
16:12:22 <MissPiggy> Cale, really? :D I thuoght it was a cool book what's bad about it
16:12:22 <twink> Newton series of a_n is \sum_{n=0}^\infty a_n\binom{x}{n}
16:12:34 <MissPiggy> thuoght I didn't quite finish it
16:12:54 <Cale> It somehow completely neglects to mention the overall point of generating series.
16:12:58 <MissPiggy> oh
16:13:14 <MissPiggy> what is it ?
16:13:24 * ddarius only really liked the first chapter or so of that book.
16:13:52 <Cale> Basically, the overarching idea is that we take sets of combinatorial objects, and associate them to elements in some ring, in such a way that combinatorial operations on sets correspond to algebraic operations on ring elements.
16:14:05 <MissPiggy> like species ?
16:14:21 <Cale> Well, species make it clearer, but you don't really need all the category theory to do it.
16:14:32 <MissPiggy> anyway sorry to divert
16:14:37 <Cale> Nah, it's okay :)
16:15:00 <ddarius> If you are interested in the zeta function and analytic number theory, I'd highly recommend looking at the Mellin transform.
16:15:04 <twink> There's some quasi-symmetric trinomial coefficient -oriented convolution rule for Newton series that I can't remeber for the life of me. I think Concrete Mathematics has some mention of it somewhere in there.
16:15:08 <MissPiggy> ddarius, thanks
16:15:28 <MissPiggy> I have learned a few new integral transforms recently
16:15:37 <Cale> So, for ordinary generating series, disjoint sum of weighted sets corresponds to the algebraic sum of generating series
16:16:01 <ddarius> (s) = sM[floor](-s)
16:16:24 <Cale> and Cartesian product of weighted sets, where the weight of a pair (x,y) is the *sum* of the weights of x and y corresponds to the product of ordinary generating series
16:16:24 <xerox> keep defining please :)
16:16:38 <Cale> This is because x^n x^m = x^(n+m)
16:17:28 <Cale> (I'm actually not very interested in analytic number theory, but I don't mind the combinatorial aspect of it)
16:17:35 <Zeiris> Is it possible to use a "let ... in ..." statement outside several function definitions, essentially defining a local function?
16:17:42 <twink> \binom{x}{m}\cdot\binom{x}{n} is something very tricky.
16:17:51 <Cale> Zeiris: let/in is an expression form
16:17:58 <ddarius> Zeiris: Nope.
16:18:00 <Cale> (not a statement or declaration)
16:18:05 <Zeiris> Understood.
16:18:09 <xerox> ddarius: sM[floor] ?
16:18:11 <ddarius> Zeiris: Not at the top-level if that's what you meant.
16:18:45 <ddarius> xerox: M is the Mellin transform, floor is the floor function.
16:19:02 <xerox> doh! I see
16:20:56 <ddarius> http://en.wikipedia.org/wiki/Perron%27s_formula
16:20:58 <HugoDaniel2> how do i use record selector functions in existential datatypes ?
16:21:11 <twink> uh-oh
16:21:41 <Cale> MissPiggy: The Dirichlet generating series for a weighted set which is the sum over the elements a in A of (w(a))^-s, where w(a) is the weight of a, behaves similarly with regard to sum, but when you multiply two series, you're taking the Cartesian product of the sets that they count, but where the weight of a pair is the *product* of the weights of its elements
16:21:58 <MissPiggy> Cale, alright
16:24:39 <MissPiggy> Cale, so you are considering the weighted sum where there is an element for each integer weight
16:26:02 <MissPiggy> oh well it's just the set {1,2,3,4,..} of course.
16:26:06 <ddarius> Here's the (generalized) magic formula: _p _n f(p^n) n^-s  =  _n f(n) n^-s for multiplicative f and p running over the primes.
16:26:36 <ddarius> Cale: Why don't you make a little article on this?
16:26:56 <MissPiggy> nice ddarius
16:28:02 <ddarius> f is multiplicative if f(mn) = f(m)f(n) for coprime m and n.
16:28:03 <Cale> MissPiggy: Well, in the case of zeta, yes
16:28:24 <HugoDaniel2> help plz: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23151#a23151
16:28:33 <Cale> zeta(s) is the Dirichlet generating series for the positive integers, with the weight function being the identity
16:28:37 <syntaxfree> this must be a common question, but I couldn't be helped by Google.
16:28:58 <altmattr> taylor swift
16:29:02 <ddarius> so f(n) = 1 is multiplicative and gives the Zeta function (and the usual presentation of the Euler Product Formula)
16:29:26 <syntaxfree> Is there a Haskell library for matrix algebra that does the basic stuff (inversion, QR decomposition, eigenvalues/vectors) and is commonly used?
16:29:45 <altmattr> sorry, on my husband's computer
16:30:11 <copumpkin> altmattr: we forgive you
16:30:17 <ddarius> syntaxfree: hmatrix is probably your best bet
16:30:21 <nonowarn> I want to hear comments about this: http://github.com/nonowarn/has
16:30:24 <ddarius> syntaxfree: There are other libraries as well and bindings.
16:30:44 <syntaxfree> is hmatrix being used for something real?
16:31:06 <nonowarn> I wrote a psuedo-generic library
16:31:13 <copumpkin> nonowarn: looks nice
16:31:15 <copumpkin> from the example
16:31:24 <ivanm> syntaxfree: image analysis IIRC
16:31:35 <syntaxfree> btw, has hackage/cabal evolved to a place where I can install packages from the command-line?
16:31:35 <nonowarn> copumpkin: I'm glad to hear that!
16:31:48 <ivanm> syntaxfree: get cabal-install
16:31:51 <syntaxfree> cabal-get hmatrix or something.
16:31:52 <ivanm> @where cabal-install
16:31:52 <lambdabot> http://hackage.haskell.org/trac/hackage/wiki/CabalInstall
16:31:58 <syntaxfree> it doesn't ship with GHC yet?
16:32:05 <ivanm> syntaxfree: it needs lapack and gsl installed on your machine first
16:32:12 <ivanm> syntaxfree: it comes with the Haskell Platform
16:32:15 <ivanm> @where platform
16:32:15 <lambdabot> http://hackage.haskell.org/platform/
16:32:19 <HugoDaniel2> can someone give me a hand with existential types ? i want to call a selector function on a existential type
16:32:35 <Cale> HugoDaniel2: Can't do it.
16:32:43 <copumpkin> aw, so blunt
16:32:45 <Cale> HugoDaniel2: The selector functions wouldn't have appropriate types.
16:32:45 <syntaxfree> is the Haskel Platform available as a clean .pkg Mac OS X install?
16:32:51 <HugoDaniel2> oh
16:33:02 <syntaxfree> oh cool.
16:33:11 <ivanm> syntaxfree: not sure
16:33:12 <syntaxfree> Yes, I just looked at it.
16:33:16 <HugoDaniel2> :(
16:33:21 <ivanm> but IIRC it doesn't work by hand for Snow Leapord
16:33:22 <systemfault> syntaxfree: If it didn't changed very recently... It works like shit on Snow Leopard
16:33:25 <ivanm> (needs some patches)
16:33:27 <Cale> HugoDaniel2: You just use case to pattern match the components out.
16:33:43 <MissPiggy> I wish I had more connections between primes and pi
16:33:53 <syntaxfree> oh. it's broken on snow leopard.
16:33:56 <Cale> HugoDaniel2: and produce a result which is independent of the unknown type which the existential wraps
16:34:35 <HugoDaniel2> Cale: ghc complains about the function signature
16:34:40 <HugoDaniel2> i tried it
16:34:56 <ivanm> syntaxfree: there are patches available to build it on SL
16:35:10 * syntaxfree goes to -blah
16:35:22 <HugoDaniel2> it wont be generic then
16:35:33 <HugoDaniel2> if i have to write a function for each type
16:35:50 <ivanm> syntaxfree: http://www.haskell.org/haskellwiki/Mac_OS_X#Mac_OS_X_10.6_.28Snow_Leopard.29
16:35:50 <xerox> syntaxfree: actually I like ghc.pkg + cabal install better, it's very clean for removal, if needed (dunno about the platform)
16:36:18 <Cale> HugoDaniel2: Maybe it would help for me to understand what you're using the existential type for.
16:36:27 <Cale> Basically, if you have an existential like, say...
16:36:41 <HugoDaniel2> Cale: im using it because of the the recursion
16:36:51 <HugoDaniel2> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23151#a23151
16:37:04 <Cale> data Fooable where = F :: (Foo a) => a -> Fooable
16:37:21 <HugoDaniel2> Cale: lines 15 and 16
16:37:39 <ivanm> xerox: platform = ghc + what used to be called extralibs + cabal-install (with deps)
16:37:43 <HugoDaniel2> thats possible ?!
16:37:59 <Cale> er, oops
16:38:09 <Cale> there's an extraneous = sig
16:38:09 <Cale> n
16:38:14 <Cale> data Fooable where F :: (Foo a) => a -> Fooable
16:38:24 <Cale> This is in GADT syntax
16:38:40 <Cale> (but is not technically a GADT, only an existential type)
16:38:41 <HugoDaniel2> hmm, it seems "better" than existential types
16:38:43 <BONUS> or you can do data Fooable = forall a. Foo a => a -> Fooable
16:39:08 <Cale> data Fooable = forall a. (Foo a) => F a
16:39:14 <HugoDaniel2> hmm
16:39:16 <Cale> would be the traditional syntax
16:39:23 <HugoDaniel2> does it work for recursive data types ? like the one im using ?
16:39:26 <BONUS> oh yeah right
16:39:27 <Cale> But let's look at what this means
16:39:43 <Cale> When you have some x :: t where there's an instance Foo t
16:39:52 <Cale> then you can have F x :: Fooable
16:40:06 <Cale> but what you're essentially doing is "forgetting" the type of x
16:40:15 <xerox> ivanm: I mean, I don't know about removal, while ghc comes with an uninstall.sh and all cabal is in ~/.cabal
16:40:26 <Cale> Types represent the permission to use a value in various ways
16:40:44 <Cale> So you're giving up your permissions to use x in all the ways that x :: t would imply.
16:40:49 <Cale> *Except*
16:40:59 <Cale> that you're remembering that t was an instance of the typeclass Foo
16:41:10 <Cale> So all the operations of the Foo typeclass will still be available for x
16:41:28 <Cale> and they will essentially be the only thing you can do with the value at that point
16:41:42 * ddarius miswrote the equation above.  The left-hand side should be _p _n f(p^n) p^-ns 
16:41:53 <HugoDaniel2> hmm, interesting
16:42:51 <nonowarn> ... and another example of has: http://gist.github.com/318993
16:43:09 <Cale> I think that existential types are the true heart of object oriented programming.
16:43:17 <ddarius> I agree.
16:43:39 <HugoDaniel2> i just need them to work
16:44:11 <Cale> The core idea of object oriented programming is to obtain a measure of polymorphism by forgetting some of the information about what things are, and only remembering what operations they support.
16:44:41 <[swift]_> what would be the best or idiomatic way to implement the equivalent of the visitor pattern in haskell?
16:44:51 <arw> map
16:44:55 <HugoDaniel2> :)
16:45:34 <ivanm> by not using patterns
16:45:41 * ivanm never got the point of patterns
16:45:42 <HugoDaniel2> yes Cale, and its a good way to design stuff
16:45:57 <monadic_kid> [swift]_: do you need open functions? if not then you use algebraic data types and pattern matching
16:46:17 <Cale> HugoDaniel2: Well, it's one way.
16:47:02 <Cale> HugoDaniel2: It's the way that you design things if you have way more cases of data to deal with than operations you want to support on that data.
16:47:19 <[swift]_> monadic_kid: i am not precisely sure what you mean by open functions, so let me put it this way: i'd like to be able to add more types that are visited, AND more functions that visit them
16:47:30 <[swift]_> monadic_kid: i'm new to haskell so i may be thinking too much in a C++ way here
16:47:55 <ddarius> [swift]_: You use the visitor all the time in normal code.
16:48:24 <ddarius> [swift]_: As monadic_kid said, the visitor pattern emulates pattern matching.
16:48:30 <HugoDaniel2> Cale: you are very bright :)
16:48:56 <medfly> another cale fan
16:49:27 <[swift]_> ddarius: that makes sense, but what if i have an existing function that uses pattern matching over some data structure consisting of multiple types, and then i add another type to that data structure (eg, a new type of node in a graph). doesn't relying purely on pattern matching make my code brittle in that scenario?
16:50:00 <monadic_kid> [swift]_: no because you'll get caught out at compile-time
16:50:19 <monadic_kid> [swift]_: case analysis
16:50:24 <ddarius> f(1) = 1; f(p) = -1; f(p^n) | n > 1 = 0 extends to a multiplicative function which is the Mobius function .  Stick it into the formula above and you get _p (1 - p^-s) = _n (n) n^-s.  Compare to (s) = _n n^-s = _p _n p^-ns = _p 1/(1-p^-s) so we get _n (n) n^-s = 1/(s).
16:50:53 <ddarius> [swift]_: No more or less than the normal visitor pattern.
16:51:27 <HugoDaniel2> Cale: if you show up on the hackaton ill buy you a beer :)
16:51:34 <monadic_kid> [swift]_: are you sure you really need the ability to add new "types" later on without modifying the origional source of the functions working on them?
16:51:53 <Alpounet> ddarius, zeta ? :)
16:52:25 <[swift]_> monadic_kid: well i have in the past on other projects (in C++)
16:52:55 <[swift]_> now that i think about it tho, i guess the win here is that in pattern matching you have wildcards, so it's easy to provide a default behavior of "ignore"
16:55:01 <monadic_kid> [swift]_: you should be thinking more to use functions and higher-order functions for composable/extendable libraries. When you really, really need to do something like subtype polymorphism in Haskell you can use existential types with type classess, multi-param type-classes would give you multmethods
16:55:12 <ddarius> [swift]_: FP and OOP are extensible in dual ways.
16:55:32 <Cale> HugoDaniel2: Thanks, but I don't drink, and I don't have money to fly anywhere. :)
16:55:45 <ddarius> monadic_kid: Nothing you do will give you something like subtyping in Haskell.
16:55:55 <Itkovian> dons: How much work do you think it would be to get a list of all (commandline-available) optimisations for both GHC and LLVM? Are there both boolean flags and value flags, or just boolean flags?
16:56:03 <Alpounet> ddarius, oleg wouldn't agree :-p
16:56:16 <monadic_kid> ddarius: existential types with type classess is close enough, even get multimethods with multi-param type-classess
16:56:37 <ddarius> Alpounet: You can -explicitly- cast to "subtypes", but that kind of defeats the point and seriously twists the meaning of "subtype."
16:57:09 <ddarius> monadic_kid: You can emulate an OO style, you can't emulate subtyping.
16:57:37 <Alpounet> ddarius, http://www.mail-archive.com/haskell-cafe@haskell.org/msg65017.html
16:57:39 <[swift]_> monadic_kid, ddarius: what you're saying makes sense. do you know of something i can read that might help me make the transition to a more FP way of thinking?
16:58:18 <Alpounet> ddarius, but I agree it's not exactly like what we get with OCaml or C++ templates
16:58:37 <monadic_kid> ddarius: I guess our definitions of subtype polymorphism is not the same
16:58:43 <ddarius> Alpounet: C++ templates have nothing to do with subtyping.
16:58:52 <ddarius> [swift]_: Read any intro.
16:58:56 <monadic_kid> ddarius: I'm not talking about structural subtyping
16:58:58 <Cale> [swift]_: do you know about map?
16:59:12 <Alpounet> ddarius, I was more refering to the structural typing stuff
16:59:16 <[swift]_> ddarius: well i am reading real world haskell right now, on ch. 10
16:59:28 <Alpounet> but otherwise yeah.
16:59:35 <ddarius> monadic_kid: I'm talking about subtyping but not "subtype polymorphism."
16:59:36 <[swift]_> Cale: I do. i feel like i understand this stuff in the small but am lost when i try to figure out the architecture for a real app
16:59:41 <Cale> [swift]_: By generalising the map function in various ways you get various rather-generic "visitor patterns"
17:00:01 <HugoDaniel2> [swift]_: just code it
17:00:59 <[swift]_> Cale: that makes sense
17:01:12 <[swift]_> HugoDaniel2: maybe that's what i need to do =)
17:01:16 <Cale> [swift]_: I suppose it depends heavily on the application, there are a lot of ways to design things... but one of the favourites of functional programming is to create a library which behaves like a language.
17:01:36 <monadic_kid> ddarius: okay you're thinking purely of type relations, i'm thinking about nominal subtype polymorphism in most typical OO languages.
17:02:11 <Cale> [swift]_: Basically, take the problem you're trying to solve, and start by generalising it a bit to imagine a somewhat larger, but more uniform, space of problems in which it fits nicely.
17:02:45 <Cale> and then design a representation for that space of problems which consists of primitive things, and ways to combine them into more interesting ones.
17:03:15 <Cale> and then solutions for the problems which work by solving the primitive problems, and by recursively combining solutions for combined problems
17:03:28 <monadic_kid> [swift]_: Cale is hinting at one method (powerful) method of design is combinator libraries, using higher-order functions which compose primtive functions
17:03:46 <Cale> Imagine if you were writing a program to do things with recipes.
17:03:50 <Cale> (for food)
17:04:12 <Cale> You might have various primitive "recipes", which would essentially be single ingredients.
17:04:32 <Cale> and then ways to combine or transform those ingredients (stir, mix, whip, chop, bake ...)
17:05:00 <ddarius> monadic_kid: You can get the dynamic dispatch of OO, but not the typing of OO.  Nominal or structural is orthogonal.
17:05:09 <Cale> and if you wanted to do something like determine the sugar content of a recipe
17:05:40 <monadic_kid> ddarius: sure that wasn't what I meant
17:05:42 <ddarius> [swift]_: There are many fine OO techniques.  It's not like OO is a complete wash.
17:05:43 <Cale> you'd do it by determining the sugar content of the ingredients, and then by describing how each of the operations affects that
17:06:22 <ddarius> monadic_kid: The upshot of that is that you cannot make a style that's quite like programming in Java or C#.
17:06:23 <[swift]_> i see.. so with OO I usually think of making the program i want to write "easy" by creating an object hierarchy that models the problem. with FP one does the same thing by creating a DSL that models the problem. that sounds very cool!
17:06:39 <Cale> and then, from the same recipe value, you could not only construct the sugar content, but also the traditional recipe printout, or determine how many people it ought to serve, etc, etc.
17:06:51 <ddarius> [swift]_: Okay, "object hierarchy" is definitely a bad thing from OO.
17:07:01 * ddarius goes and plays pool.
17:07:25 <[swift]_> ddarius: i largely agree, hence my interest in FP =)
17:07:43 <Cale> This has been done with financial contracts in place of recipes, to a fair degree of success.
17:07:57 <Cale> And of course with parsers
17:08:04 <Cale> and drawings for graphics :)
17:08:10 <monadic_kid> You don't have to write everything as a combinator library
17:08:22 <Cale> Yeah, it's just a general approach you'll want to consider
17:08:49 <monadic_kid> [swift]_: basically do you really need to need open types? probably not
17:08:51 <[swift]_> gotcha; still, it's a very elegant approach
17:09:15 <Cale> One which takes a bit of effort up front -- getting the right language of primitives and combinators can be really tricky, but it gives you an incredible degree of flexibility in the face of design changes.
17:09:55 <[swift]_> monadic_kid: i think for the purposes i'd create a new class for in the past, i would usually just add a new constructor to an existing type in haskell, so you may be right there
17:10:33 <Alpounet> Cale, do you know of any article / book / whatever discussing the design of such language of primitives and combinators ?
17:11:06 <monadic_kid> [swift]_: I use C++ at work, 95% i don't need full OO, just modula programming techniques is enough
17:11:07 <Cale> I know of some talks and papers.
17:11:27 <[swift]_> Cale: i'd be interested in some references if it wouldn't be too much trouble
17:11:27 <monadic_kid> [swift]_: *95% of the time
17:12:46 <Cale> http://ulf.wiger.net/weblog/2008/02/29/simon-peyton-jones-composing-contracts-an-adventure-in-financial-engineering/
17:12:51 <mtnviewmark> when running template haskell, the compiler seems to want to have all the libs my final program needs at compile time
17:13:05 <mtnviewmark> I'm getting "can't load .so/.DLL for> mysqlclient"
17:13:06 <Cale> http://research.microsoft.com/en-us/um/people/simonpj/papers/financial-contracts/contracts-icfp.htm -- the original paper
17:13:16 <mtnviewmark> any idea how I pass that to the compiler?
17:13:27 <mtnviewmark> to get it to use that lib at *compile* time?
17:13:32 <mtnviewmark> (well, template haskell time)
17:13:40 <monadic_kid> that is one thing that most programmers seem to forget, modula programming is more useful and more often used than class hierarchies (or should at least be)
17:13:48 <monadic_kid> they just call it OO
17:14:10 <kynky> i like composistion
17:14:31 <[swift]_> monadic_kid: OO is convenient in GUI and graphics programming, which i used to do a lot of. outside of that, i definitely see your point
17:15:06 <scoder> hey guys
17:15:09 <scoder> i have a question
17:15:12 <[swift]_> Cale: thanks for the links!
17:15:27 <scoder> what does this function do?
17:15:28 <scoder> ctcpQuote cs = ctcpQuoteChar:cs ++ [ctcpQuoteChar
17:15:36 <scoder> i mean
17:15:43 <monadic_kid> [swift]_: I'll take GUI but not so for graphics programming unless you're talking about scene graphs which are really used in the game industry
17:15:46 <scoder> and a end bracket
17:15:46 <scoder> ctcpQuote cs = ctcpQuoteChar:cs ++ [ctcpQuoteChar]
17:15:52 <scoder> given that
17:16:01 <scoder> ctcpQuoteChar :: Char
17:16:01 <scoder> ctcpQuoteChar = '\001'
17:16:05 <[swift]_> monadic_kid: i am indeed talking about scene graphs; i used to write ray tracers
17:16:06 <monadic_kid> [swift]_: I'm mean are not usually used in the games industry
17:16:06 <MissPiggy> scoder, watch this:
17:16:11 <kynky> thought fp was good for gui/graphics ? reactive programming ?
17:16:12 <[swift]_> monadic_kid: not for games =)
17:16:12 <Saizan> scoder: you could try it in ghci
17:16:19 <MissPiggy> > let char = '!' in char : "foobar" ++ [char]
17:16:19 <scoder> yeah i know
17:16:20 <scoder> ok
17:16:20 <lambdabot>   "!foobar!"
17:16:24 <scoder> i dont mean what id does
17:16:27 <scoder> i know what it does
17:16:40 <mtnviewmark> nvm  -- figureed it out
17:16:42 <scoder> but i was more wondering how it does it
17:16:45 <MissPiggy> umm
17:16:45 <MissPiggy> what were you asking
17:16:51 <MissPiggy> ?
17:17:00 <scoder> ctcpQuote cs = ctcpQuoteChar:cs ++ [ctcpQuoteChar]
17:17:09 <scoder> more spec
17:17:12 <scoder> "ctcpQuoteChar:cs"
17:17:16 <scoder> what that part means
17:17:24 <Alpounet> Cale, thank you
17:17:25 <monadic_kid> [swift]_: yes there aren't really useful for games but there was a point when people where trying to force them. They are just better for editing tools than a game
17:17:44 <scoder> sorry if this seems spammy but
17:17:44 <scoder> ctcpQuoteChar :: Char
17:17:44 <scoder> ctcpQuoteChar = '\001'
17:17:44 <scoder> ctcpQuote :: String -> String
17:17:44 <scoder> ctcpQuote "" = ""
17:17:45 <scoder> ctcpQuote cs = ctcpQuoteChar:cs ++ [ctcpQuoteChar]
17:17:48 <Saizan> scoder: (x:xs) is a list where x is the first element and xs is the rest of it
17:17:56 <Saizan> scoder: and please stop pasting code in channel.
17:18:02 <scoder> oooh
17:18:43 <Saizan> @src []
17:18:44 <lambdabot> data [] a = [] | a : [a]
17:18:50 * twink has to have some sort of refresher course on what OO is good for. Between imperative (C, /bin/sh, perl/python/etc.), functional (O'Caml, Haskell), and logic (Mercury, Prolog) I've not seen a use for OO in quite some time.
17:18:59 <scoder> ok is '++' a concatenation?
17:19:05 <Saizan> yes
17:19:05 <ivanm> twanvl: you mean it _is_ good for something? :o
17:19:25 <scoder> thanks :)
17:19:34 <scoder> now i get it :D
17:19:39 <theorbtwo> imperative and OO aren't really mutually exclusive.
17:19:39 <ivanm> @botsnack
17:19:39 <lambdabot> :)
17:19:48 <ivanm> OK, so why is lambdabot ignoring privmsgs?
17:19:54 <twink> ivanm: I'll presume that was meant for me. I won't make that claim, but there's a lot of trickiness or lore or something.
17:19:54 <ivanm> > text '\001'
17:19:55 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
17:19:55 <lambdabot>         against inferred ty...
17:19:56 <theorbtwo> Really, OO to a large degree implies imperitive.
17:19:59 <MissPiggy> sqink python is OO ?
17:20:02 <MissPiggy> twing
17:20:03 <ivanm> > char '\001'
17:20:09 <ezyang> Because OO is all about managing state
17:20:12 <ivanm> twink: ummm.... yes
17:20:20 * ivanm really hates this IRC client
17:20:29 <Saizan> ivanm: it just strips non-printable characters from the output
17:20:35 <twink> MissPiggy: Point, python is very OO, which I guess means that I've mostly been using awk vs. perl/python.
17:20:38 <ivanm> Saizan: ahhh...
17:20:43 <ivanm> that's why it's not printing anything
17:20:50 * ivanm was trying to work out what \\001 was
17:21:01 <theorbtwo> ivanm: A backslash, followed by 001.
17:21:22 <ivanm> theorbtwo: OK, smarty, what character is '\001' ?
17:21:35 <twink> BEL?
17:21:46 <ivanm> ahhh, Start of Header AFAICT
17:21:48 <theorbtwo> Start of Heading, which I've never seen anybody actually use for that.
17:22:05 <kynky> oo is about having a stupid view of how programing should be done, so when you use fp, fp seem weird, when in fact oo is, if you have used oo first that is
17:22:19 * theorbtwo shrugs.
17:22:26 <Cale> OO is not really at its core a bad idea.
17:22:28 <theorbtwo> Views aren't really stupid or not like that.
17:22:34 <Cale> But there are a lot of bad ideas mixed up with it
17:22:36 <monadic_kid> well anyways most of the time you don't really need full features of OO so what you have left is modula programming which you can do in any paradigm
17:22:48 <copumpkin> modula, eh
17:23:01 <theorbtwo> You can prefer one or the other, but that says more about you then about them, IMHO.
17:23:11 <twink> I think I've got Modula 2 somewhere around here.
17:23:21 <monadic_kid> Not Modula the programming langauge!
17:23:26 <Cale> From a certain, sufficiently abstracted and idealised perspective, OO and FP are dual.
17:24:03 <copumpkin> kermit: having fun?
17:24:03 <twink> monadic_kid: dev-lang/cm3-bin, the Critical Mass Modula-3 compiler. http://www.elegosoft.com/cm3/
17:24:28 <Cale> Traditional FP is all about extracting generality from universal types, and traditional OO is all about extracting generality from existential types (though they wouldn't be called that)
17:24:41 <theorbtwo> monadic_kid: If you don't mean Modula the programming language, what Modula do you mean?
17:24:50 <copumpkin> probably Modula R
17:24:58 <Cale> This is forgetting all the nonsense about mutable state and class hierarchies
17:25:13 <twink> Not familiar with that version of the Modula language.
17:25:16 <copumpkin> kermit: ...
17:25:21 * theorbtwo shrugs.
17:25:23 <kynky> ...old dog new tricks, to me applies to oo, as in if you get used to oo, it seems intuitive, and other styls of programming seem tricky, so people tend to dismiss them as unnecassirily dificult, just because they solve the problem in a different, sometimes (usually) better way
17:25:27 <monadic_kid> Sorry I mean modular programming not Modula
17:25:40 <theorbtwo> I don't accept that mutable state is nonsense.
17:25:43 <twink> Supposedly Modula had a typecase operator that Java quite desperately needs.
17:25:47 <copumpkin> twink: was joking about modular being Modula R
17:25:56 <copumpkin> ewww typecase :P
17:26:14 <copumpkin> eww mutable state
17:26:14 <theorbtwo> ...as for class hierarchies, haskell has them, more or less.
17:26:25 <copumpkin> theorbtwo: completely different meaning though
17:27:12 <theorbtwo> copumpkin: If you define a typeclass Foo such that all Foos are also Bars, then Foo is a subclass of Bar.
17:27:18 <theorbtwo> Really, it's the same meaning.
17:27:22 <copumpkin> theorbtwo: no
17:27:23 <roboshibby> what is "::" generally used as in science/math/tech?
17:27:44 <copumpkin> theorbtwo: sure, both are called classes and form a hierarchy
17:27:45 <arw> i know of no common usage.
17:27:49 <copumpkin> that's where the similarity ends though
17:28:00 <theorbtwo> copumpkin: They also define methods that are dispatched by type.
17:28:05 <roconnor> roboshibby: a : b :: c : d
17:29:16 <theorbtwo> copumpkin: Am I wrong?
17:29:21 <roconnor> 5 : 10 :: 7 : 14
17:29:56 <theorbtwo> roconnor: That's certianly *a* use of ::, but I'm not sure it's that common, outside of a certian sort of standardized test.
17:30:06 <copumpkin> theorbtwo: they're a much more flexible type-based dispatch and constraint system than is possible in any OO system I know of
17:30:20 <theorbtwo> copumpkin: Perl 6 comes close, but yes.
17:30:42 <copumpkin> hmm
17:31:00 <A1kmm> Does anyone know if there is a pre-rolled TH function with signature [TypeQ] -> TypeQ to make a completely applied tuple type from a list?
17:31:08 <A1kmm> Or is that something I'll need to write myself?
17:31:59 <zygoloid> tupE?
17:32:16 <zygoloid> oh, you wanted types
17:32:40 <Alpounet> @hoogle [TypeQ] -> TypeQ
17:32:41 <lambdabot> Language.Haskell.TH appT :: TypeQ -> TypeQ -> TypeQ
17:32:41 <lambdabot> Language.Haskell.TH.Lib appT :: TypeQ -> TypeQ -> TypeQ
17:32:41 <lambdabot> Language.Haskell.TH forallT :: [Name] -> CxtQ -> TypeQ -> TypeQ
17:32:53 <Saizan> A1kmm: the derive package has a nice set of helpers
17:33:04 <ivanm> preflex: seen Cale
17:33:04 <preflex>  Cale was last seen on #haskell 8 minutes and 6 seconds ago, saying: This is forgetting all the nonsense about mutable state and class hierarchies
17:33:07 <theorbtwo> copumpkin: I don't mean to say that haskell is nothing but ordinary oo, just that they are not as distant as you might think.
17:33:12 <ivanm> still here Cale?
17:33:14 <Cale> yes
17:33:44 <ivanm> can you explain to me how the two ways of defining a graph minor here are equivalent? http://en.wikipedia.org/wiki/Minor_(graph_theory)
17:33:49 <zygoloid> foldr1 appT `ap` (tupleT . length)
17:34:01 <ivanm> (first paragraph)
17:34:03 <copumpkin> theorbtwo: they definitely have similarities, but they range over different things
17:34:10 <copumpkin> theorbtwo: if anything, they're closer to interfaces in OO languages
17:34:28 <ivanm> since AFAIK edge contraction involves joining to vertices together and doesn't let you arbitrarily delete edges
17:34:34 <Saizan> zygoloid: you need foldl i believe
17:34:36 <monadic_kid> copumpkin: I would say generic constraints not interfaces themselves
17:34:50 <Saizan> zygoloid: application is left-associative, afterall :)
17:34:55 <copumpkin> monadic_kid: a bit of both, maybe, but typeclasses do a lot more than both
17:34:59 <theorbtwo> copumpkin: Eh, an interface is just a base class that doesn't define any of it's methods, only declares them.
17:35:09 <zygoloid> Saizan: heh, sure, if you want the types in the /obvious/ order in the tuple ;)
17:35:14 <copumpkin> theorbtwo: not necessarily
17:35:37 <theorbtwo> copumpkin: Also, haskell does have inherited implementations, you just have to ask for them, IIRC.
17:35:47 <copumpkin> theorbtwo: how do you mean?
17:35:50 <scoder> any gui app making tutorials anyone want to recommend or not?
17:36:02 <monadic_kid> well lets be precise, the origional intent of type-classess is to provide type inferred ad-hoc polymorphism in a less ad-hoc manner. That's not really like anything in most typical OO languages, it's not subtype polymorphism
17:36:26 <A1kmm> zygoloid / saizan: Thanks, I can't find anything like that in derive, so I'll do something similar to what zygoloid said.
17:36:30 <theorbtwo> copumpkin: driving (Show), instead of, er, other_keyword (Show) where...
17:36:49 <copumpkin> instance Show Int where?
17:36:56 <theorbtwo> monadic_kid: I don't think the inferred and ad-hoc is really a neccessary part of type-classes, though.
17:36:58 <copumpkin> theorbtwo: that's not inheritance though
17:37:07 <theorbtwo> copumpkin: How isn't it?
17:37:12 <zygoloid> what libs do people usually use for haskell GUIs?
17:37:31 <monadic_kid> theorbtwo: that is there sole reason of there existance
17:37:36 <Alpounet> gtk2hs and wxHaskell
17:37:47 <Alpounet> qthaskell deserves more attention than it has, though
17:37:58 <theorbtwo> Haskell is *infinitely* more useful because it does type inference, but it is by no means impossible to imagine a language very much like Haskell but without it.
17:38:00 <copumpkin> theorbtwo: it's parametric, and you're not inheriting from a type (given that Show isn't a type)
17:38:24 <theorbtwo> copumpkin: What is it about show that makes it not a type, though?
17:38:35 <Saizan> A1kmm: it'd be "fmap tup . sequence" with Language.Haskell.TH.Helper
17:38:46 <Alpounet> copumpkin, I guess he meant Show would be something like an interface in OO
17:39:00 <copumpkin> Alpounet: that's what I said :P
17:39:05 <Alpounet> yeah
17:39:09 <theorbtwo> Show is something like an interface in OO, and an interface is something like a type.
17:39:15 <jcreigh> IMO, you should only be allowed to say "infinitely more" when discussing mathematics. :)
17:39:18 <monadic_kid> theorbtwo: if you want to compare type-classess to OO, they only have one thing in common, to provide bounded quantification of parametic polymorphism.
17:39:22 <theorbtwo> (Note that a good many OO languages don't have interfaces.)
17:39:27 <copumpkin> theorbtwo: and how do you fit MPTCs in there?
17:39:36 <Alpounet> theorbtwo, no, an interface defines ... an interface, not a type
17:39:36 <theorbtwo> copumpkin: MPTCs?
17:39:42 <copumpkin> multiparameter typeclasses
17:39:55 <theorbtwo> Ah.
17:40:04 <theorbtwo> Er, I can't think of an analog, other then templates.
17:40:05 <Alpounet> a set of functions, that's all. That's not defining a type and that's why you can't instantiate interfaces
17:40:05 <copumpkin> the way I typically think of typeclasses is as relations over types
17:40:17 <copumpkin> you can say the same thing of interfaces, I guess
17:40:23 <MissPiggy> !quaote
17:40:26 <MissPiggy> @quote
17:40:26 <lambdabot> cjs says: I have to explain this shit to people. I mean, I start out right, "Hey, you know how you always have these bugs because what you thought was in the variable is not there?" And I get all of
17:40:26 <lambdabot> these nods of agreement. "Well, I've found a new language that solves that problem." Audience: "Ooooh! How?" Me: "There's no variables!" And then they all start moving away from me slowly....
17:40:31 <monadic_kid> theorbtwo: Concepts that got dropped in C++0x is like type-classess
17:40:42 <ivanm> Cale: so does that description of graph minors make sense to you?
17:41:08 <zygoloid> monadic_kid: like typeclasses but horribly broken, it turns out :(
17:41:09 <theorbtwo> cjs++
17:41:14 <copumpkin> theorbtwo: I don't think the methods part of typeclasses is very fundamental as anything but a "witness" to a type being a member of the relation
17:41:30 <monadic_kid> zygoloid: well they are dead now anyways
17:41:34 <theorbtwo> Oh.  That seems like an odd way of thinking about it, to me.
17:41:39 <monadic_kid> zygoloid: got votedoff
17:41:43 <cjs> theorbtwo: Thanks. :-)
17:41:43 <Cale> ivanm: sorry, just looking now
17:41:45 <Alpounet> monadic_kid, reported for later integration, rather
17:41:48 <zygoloid> monadic_kid: for the time being
17:41:51 <ivanm> heh, fair enough
17:42:08 <monadic_kid> I'll say it again they are dead
17:42:10 <zygoloid> monadic_kid: but chances are a later c++ will have them, and they'll be almost entirely implicit
17:42:24 <Cale> ivanm: okay
17:42:27 <theorbtwo> It seems like the point of a typeclass is that you can require that you can do such-and-such to this variable.
17:42:27 <monadic_kid> we can talk about it in 10 years time
17:42:31 <Cale> ivanm: yes, I see how they're equivalent
17:42:36 <ivanm> Cale: how?
17:42:37 <copumpkin> theorbtwo: think for example of class IsomorphicToMoo a where toMoo :: a -> Moo; fromMoo :: Moo -> a
17:42:49 <zygoloid> monadic_kid: if you get voted arbiter of c++ i'll believe you. for now i'm gonna believe reports from wg21
17:42:59 <Cale> ivanm: When you form a subgraph of G, you essentially do so by deleting some vertices and edges
17:43:07 <copumpkin> theorbtwo: instance IsomorphictoMoo String has to define toMoo and fromMoo, and that's effectively a "proof" that String is isomorphic to the type Moo
17:43:09 <ivanm> yes
17:43:31 <erikc> monadic_kid is right, they are effectively dead
17:43:36 <ivanm> but how is edge contraction equivalent to just deleting an edge (and leaving the two end vertices alone)?
17:43:47 <Cale> It's not...
17:44:08 <theorbtwo> copumpkin: But when I am programming, I am not just trying to make a bunch of abstract statements about abstract things.
17:44:34 <theorbtwo> I am trying to accomplish some result.  What is important is that I can freely convert between Strings and Moos.
17:44:44 <copumpkin> theorbtwo: sure, you're going to be using the actual methods, but it's worth thinking about what a typeclass actually _means_
17:44:56 <ivanm> Cale: so where is the equivalence in edge contraction === contraction + edge deletion + isolated vertex deletion ?
17:45:06 <copumpkin> theorbtwo: but you can write a typeclass with no methods, for example
17:45:15 <theorbtwo> That is isomorphic to saying that they are isomporphic, sure, but what I care about is the methods.
17:45:22 <theorbtwo> copumpkin: I could... but why *would* I?
17:45:22 <pikhq> Silly typeclass, but sure.
17:45:26 <copumpkin> the only use case for that is to make statements that you can't "prove" using haskell :)
17:45:28 <ivanm> e.g. using the example on that page, how can you get H from G using just edge contractioni?
17:45:30 <ezyang> Exception is like that
17:45:40 <ezyang> commonly it's because there's default implementations for all of the functions
17:45:50 <monadic_kid> typeclassess ==ad-hoc polymorphism (in a less ad-hoc manner) and bounded quantification of parametric types. Nothing like OO
17:46:06 <Cale> ivanm: It says edge contraction on a *subgraph* is equivalent to edge contraction + edge deletion + isolated vertex deletion
17:46:18 <theorbtwo> monadic_kid: Except OO is also ad-hoc polymorphisim and bounded quantification of types.
17:46:26 <Cale> Taking a subgraph is the same as deleting some edges and isolated vertices
17:46:26 <ivanm> Cale: ahhhh
17:46:29 * ivanm facepalms
17:46:38 <theorbtwo> Most OO doesn't do parametric types, but some does.
17:46:43 <ivanm> thanks Cale
17:47:09 <copumpkin> newtype Fix f = Fix (f (Fix f))
17:47:36 <copumpkin> I wonder how many languages could define a Show typeclass over that :)
17:47:42 <copumpkin> a show instance, that is
17:48:05 <theorbtwo> Moose does, for example.  In a somewhat more elegant manner then Haskell, even, in places, because it has first-class types, IIRC, which haskell does not -- you cannot define an operator in haskell that operates on two types, and types cannot be parametric across non-type variables.
17:48:12 <dolio> Most of the mainstream OO languages that actually have types do parametric polymorphism these days, don't they?
17:48:15 <monadic_kid> theorbtwo: OO is mostly about sub-type polymorphism but most OO languages have ad-hoc polymorphism (overloading) less have bounded quantification. .NET has bounded quantification with generic constraints.
17:48:43 <copumpkin> theorbtwo: an operator that operates on two types?
17:48:53 <copumpkin> and cannot be parametric across non-type variables?
17:49:00 <copumpkin> sorry, don't understand
17:49:16 <copumpkin> you can use a few techniques to "close" typeclasses
17:49:22 <theorbtwo> In haskell, you cannot define a type that is parametric across integers.
17:49:34 <theorbtwo> That is, make a type Foo a, and specialize it as Foo 3.
17:49:46 <copumpkin> theorbtwo: that's because you can't check that statically if you're turing-complete
17:49:55 <dolio> 3 isn't a type. Are you talking about dependent types?
17:50:05 <theorbtwo> dolio: That is precisely my point.
17:50:20 <monadic_kid> dolio: limited forms, they don't support higher-kinded types.
17:50:47 <dolio> monadic_kid: Yeah, that's true (and sad).
17:51:00 <sshc> what is the best way to find the key of the first pair in which the value is 'x' in a map?
17:51:04 <monadic_kid> The funny thing is C++ templates does but it sucks so much it's almost usually
17:51:15 <monadic_kid> *useless
17:51:32 <Cale> http://contracts.scheming.org/ -- for those people who were interested in the contract combinators thing earlier, here is a well-documented example implementation
17:51:36 <copumpkin> theorbtwo: sorry, didn't really get the point :/
17:51:41 <Saizan> ?type find
17:51:42 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
17:51:47 <monadic_kid> using template template parameter is second order
17:51:59 <roconnor> sshc: what do you mean by "first"?
17:52:13 <Saizan> ?type find ((=='x') . snd) . M.toAscList
17:52:14 <lambdabot> forall a. M.Map a Char -> Maybe (a, Char)
17:52:16 <theorbtwo> copumpkin: Consider fixed-point arithmetic types.
17:52:20 <monadic_kid> template < template < typename > Monad > struct foobarred;
17:52:33 <copumpkin> theorbtwo: yep, I understand what you're talking about, but can it verify them statically?
17:53:01 <theorbtwo> copumpkin: I don't think it can, presently.
17:53:06 <monadic_kid> slightly wrong
17:53:19 <sshc> roconnor: any
17:53:31 <MissPiggy> theorbtwo what is this?
17:53:34 <copumpkin> theorbtwo: see, the reason it can't is that it's not possible
17:53:36 <roconnor> sshc: what Saizan said
17:53:46 <monadic_kid> template < template < typename > class Monad > struct foobarred;
17:54:45 <monadic_kid> it sucks anyways, could have been possible with Concepts, oh well
17:55:15 <copumpkin> theorbtwo: a decidable statically checkable type system provably can't do things like that, so haskell doesn't try :)
17:55:22 <theorbtwo> copumpkin: Hm.  Why not?
17:55:27 <theorbtwo> I mean, why isn't it possible?
17:55:29 <copumpkin> theorbtwo: you can approximate it, but the numbers can't come anywhere from value land
17:55:31 <MissPiggy> theorbtwo: what
17:56:03 <copumpkin> theorbtwo: if you're talking about statically defined numbers, we can do that, but don't have pretty syntax for literals
17:56:29 <copumpkin> (annoying)
17:57:01 <jmcarthur> copumpkin: somebody is working on that, iirc
17:57:03 <theorbtwo> Hm.  I'm talking about Perl, which is very adept at blending the lines between static and dynamic...
17:57:09 <copumpkin> theorbtwo: if you're actually talking about dependent types (i.e., types that can depend on arbitrary values of other types)
17:57:12 <jmcarthur> we will have type-level numerals sometime!
17:57:22 <MissPiggy> theorbtwo: these guys are talkign about something completely different from you
17:57:22 <copumpkin> yay
17:57:28 <theorbtwo> ...but you could very much make the point that it does so by being dynamic everywhere.
17:57:42 <theorbtwo> MissPiggy: No, I think we understand each-other pretty well, in this corner, at the moement.
17:57:53 <copumpkin> theorbtwo: I don't really consider those languages to have a real type system. perl has what, three types? and then runtime tags of arbitrary complexity, that also happen to be called types
17:58:17 <Alpounet> Cale, thanks for the pointer
17:58:27 <theorbtwo> copumpkin: That is, IMHO, because you have a very limited view of what a type is.
17:58:38 <jmcarthur> copumpkin: of course, a language without erasure can be seen similarly, too
17:58:48 <copumpkin> theorbtwo: what do you consider a type to be?
17:59:34 <theorbtwo> copumpkin: A tag on a value or variable which tells you how it is interpreted, and what operations are valid upon it.
17:59:55 <theorbtwo> (Also, BTW, four.  I expect you are forgetting subs, which is rather interesting.)
18:00:05 <copumpkin> well then, we're talking about different things :)
18:00:14 <copumpkin> so disregard everything I've said
18:00:17 <sshc> > let x = (\~(a, b) -> (succ a, succ b)) in x (2, 3)
18:00:18 <lambdabot>   <no location info>: parse error on input `->'
18:00:26 <sshc> am I misunderstanding irrefutable patterns?
18:00:34 <jmcarthur> theorbtwo: by that definition, struct array { int len; int *someArray } has type len
18:00:50 <jmcarthur> theorbtwo: not that i'm disagreeing, but it makes things vague to various people
18:01:04 <theorbtwo> Yes, that was, indeed, a very vauge definition.
18:01:21 <theorbtwo> ...but I'm not sure it was *that* vauge.
18:01:42 <jmcarthur> theorbtwo: len says what operations are valid on the array
18:01:45 <dolio> > let x = \ ~(a, b) -> (succ a, succ b) in x undefined
18:01:46 <lambdabot>   (* Exception: Prelude.Enum.().succ: bad argument
18:02:00 <copumpkin> fun
18:02:04 <theorbtwo> Hm.  I see your point...
18:02:12 <dolio> > let x = \ (a, b) -> (succ a, succ b) in x undefined
18:02:13 <lambdabot>   * Exception: Prelude.undefined
18:02:35 <copumpkin> how did succ get to speak there?
18:02:52 <dolio> I think succ for () is defined to throw that error.
18:03:01 <dolio> Without looking at its argument.
18:03:06 <copumpkin> oh, that makes sense
18:03:07 <dolio> @src () succ
18:03:08 <lambdabot> Source not found. I feel much better now.
18:03:09 <MissPiggy> @pl \x -> f x
18:03:09 <lambdabot> f
18:03:19 <MissPiggy> @pl ($) f
18:03:20 <lambdabot> f
18:03:23 <theorbtwo> > succ ()
18:03:24 <lambdabot>   * Exception: Prelude.Enum.().succ: bad argument
18:03:30 <MissPiggy> > ($) succ
18:03:31 <lambdabot>   * Exception: Prelude.Enum.().succ: bad argument
18:03:33 <copumpkin> > succ (undefined :: ())
18:03:34 <lambdabot>   * Exception: Prelude.Enum.().succ: bad argument
18:03:37 <jmcarthur> is it right not to look at its argument before doing that?
18:03:53 <copumpkin> I don't see why it's Enum in the first place, myself
18:03:57 <copumpkin> but hey
18:04:01 <copumpkin> a lot of random instances in the prelude :)
18:04:04 <theorbtwo> jmcarthur: There's only one possible value of the type () anyway, so why would it bother?
18:04:06 <dolio> > [()..]
18:04:07 <lambdabot>   [()]
18:04:09 <jmcarthur> > [()..()]
18:04:10 <lambdabot>   [()]
18:04:17 <copumpkin> theorbtwo: there are two, and I just fed it the other one
18:04:20 <dolio> > [(),()..]
18:04:21 <lambdabot>   [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()...
18:04:27 <jmcarthur> theorbtwo: () and undefined are different in haskell
18:04:42 <copumpkin> > repeat ()
18:04:43 <lambdabot>   [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()...
18:04:47 <copumpkin> [()]
18:04:48 <jmcarthur> time to board a flight
18:04:49 <copumpkin> :P
18:04:55 <theorbtwo> Er, um, I see your point ... but neither of them have a valid successor.
18:05:07 <copumpkin> theorbtwo: but it can't detect the second one
18:05:19 <dolio> succ _|_ = _|_, it's just _|_ with a different message.
18:05:22 <copumpkin> > let x = \ ~(a, b) -> (succ a, succ b) in x undefined
18:05:23 <lambdabot>   (* Exception: Prelude.Enum.().succ: bad argument
18:05:30 <copumpkin> I'd have expected that to return an exception saying Prelude.undefined
18:05:37 <MissPiggy> > let in let in ($) ($) ($) ($) id 3
18:05:38 <copumpkin> "return an exception" ugh :P
18:05:38 <lambdabot>   3
18:05:43 <ivanm> it's the enumerable type with only one  value (ignoring undefined)
18:05:57 <ivanm> @slap MissPiggy
18:05:57 * lambdabot pokes MissPiggy in the eye
18:06:04 <copumpkin> ouch
18:06:07 <MissPiggy> fuck off ivamn
18:06:13 <MissPiggy> someone needs to remove that command from the bot
18:06:18 <ivanm> why?
18:06:32 <ezyang> @slap lambdabot
18:06:33 * lambdabot slaps lambdabot with a slab of concrete
18:06:33 <MissPiggy> I left -blah becaus you kept doing that
18:06:36 <ivanm> my brain is still hurting trying to work out what you did just there...
18:06:39 <ivanm> :o
18:06:54 * ivanm has only recently started to hang around in -blah
18:06:54 <theorbtwo> @slap @slap
18:06:54 <lambdabot> I'd rather not; @slap looks rather dangerous.
18:06:58 <ivanm> heh
18:07:03 <theorbtwo> @botsnack
18:07:03 <lambdabot> :)
18:07:13 <sshc> @bots
18:07:13 <lambdabot> :)
18:07:20 <copumpkin> ivanm has plenty of rage he needs to release
18:07:27 <ivanm> or not...
18:07:38 <copumpkin> that's why he slaps people
18:07:56 <Alpounet> or maybe it is just compulsive slapping... nobody knows yet.
18:08:07 <theorbtwo> Funny, I thought I was the one in here with rage.
18:08:34 * copumpkin only hath fury
18:08:49 <Alpounet> type fury !
18:08:59 * copumpkin hath furry
18:08:59 <ivanm> that last @slap was for MissPiggy abusing let-in syntax
18:09:12 <MissPiggy> I want that command removed
18:09:15 * ivanm backs away carefully from copumpkin
18:09:17 <ivanm> MissPiggy: why?
18:09:43 <MissPiggy> are you really not getting this?
18:09:55 <twink> How was that an abuse?
18:09:58 <copumpkin> so much hate in here today
18:10:09 <ivanm> no, I'm obviously not "getting this"
18:10:13 * copumpkin braids his hair, puts a flower in it, and grows a beard
18:10:14 <ksf> what was the name of that data structure optimized to be used with WriterT?
18:10:22 <theorbtwo> MissPiggy: Wanting to remove @slap because people keep @slapping you is also missing the point.
18:10:24 * copumpkin pulls out a joint and hands it around
18:10:45 <ivanm> exactly
18:10:46 * theorbtwo takes a toke.
18:10:54 <MissPiggy> idiots
18:10:58 * ivanm turns his back on the druggoes in here
18:11:02 * theorbtwo puts a flower in his beard.
18:11:06 <ivanm> MissPiggy: why, pray tell?
18:11:08 * ezyang is confused 
18:11:30 <shepheb> I wonder how many of us are already equipped with the long hair and beard, if not the drugs or hippie mentality.
18:11:36 * shepheb is.
18:11:42 * hackagebot has 0.1 - Generic Haskell's Record Accessors  http://hackage.haskell.org/package/has-0.1 (YusakuHashimoto)
18:11:43 * ivanm has short hair and beard
18:11:43 * copumpkin has none of that :(
18:11:55 * theorbtwo has a long beard, and has always wanted long hair.
18:12:01 <theorbtwo> I end up with big hair instead.
18:12:06 <shepheb> for the record, that was (long hair) + beard; not long (hair+beard)
18:12:17 * ksf currently has long hair and beard
18:12:30 * copumpkin wants to shave his head and grow a 2' beard
18:12:38 <ivanm> mine was short (hair + beard)
18:12:55 <shepheb> also, in the classic Seuss tale, is it (green eggs) + ham or green (eggs+ham)?
18:13:03 <ivanm> the latter I think
18:13:05 <theorbtwo> green (eggs+ham).
18:13:07 <ivanm> IIRC the cover of the book
18:13:13 <theorbtwo> The illustrations are pretty clear.
18:13:17 <shepheb> ah, true, the artwork gives it away
18:13:32 <Saizan> ksf: DList , maybe?
18:13:36 <ksf> yep
18:13:43 <ksf> ...just found it.
18:13:48 <theorbtwo> I don't have a copy to hand, but I'd be surprised if there's yellow in the print at all.
18:13:51 <Saizan> Endo [a] too
18:13:56 <Saizan> they are the same
18:14:18 <copumpkin> that's deep
18:14:42 <shepheb> what's a DList?
18:14:50 <copumpkin> a difference list
18:14:59 <copumpkin> basically a function
18:15:02 <copumpkin> [a] -> [a]
18:15:11 <ivanm> so it has O(1) ++
18:15:18 <ivanm> but O(n) head, tail, etc.
18:15:34 <Saizan> not really O(n) head, tail ..
18:15:45 <ivanm> well...
18:15:47 <ivanm> no, not really
18:15:58 <ivanm> but it has to go and actually apply all of the ++'s
18:16:02 <Saizan> no
18:16:24 <ksf> ...don't tell me converting strings to dlist and back is going to be more expensive than just using ++ in the first place
18:16:28 <Saizan> lazyness let you really apply only the leftmost
18:16:58 <copumpkin> it's a pretty neat idea, I think
18:17:08 <theorbtwo> Ah, I always love it when somebody in here makes the same point I was thinking.
18:17:13 <ivanm> Saizan: right
18:17:16 <Saizan> ksf: you're not really converting, you're just appending in a smarter way
18:17:18 <theorbtwo> It means I do get it.
18:17:26 <ivanm> isn't there an alternate one that came out late last year that takes a slightly different approach?
18:17:32 <copumpkin> theorbtwo: or they don't get it either :)
18:17:36 <copumpkin> there's FMList
18:17:41 <copumpkin> that one's more mindbending
18:17:42 <shepheb> my Theory of Programming Languages class is learning Haskell today. I'm sitting with another Haskeller and we're amusing ourselves greatly. typeclasses and monads on Wednesday is going to be fun.
18:17:57 <copumpkin> defines lists by foldMap over a universally quantified monoid iirc
18:18:11 <theorbtwo> copumpkin: A list comprised only of emos who post to Fuck My Life?
18:18:29 <copumpkin> yep :)
18:18:33 <ezyang> snerk
18:18:43 <ivanm> copumpkin: that's the one
18:18:51 <shepheb> the midterm involved a large question on representing lists as their foldr function in the untyped LC
18:19:02 <ksf> ...or does anyone have a better idea to do an unparser than Writer DList?
18:19:04 * copumpkin dies his hair jet black and pulls a tuft over half his face
18:19:13 <ezyang> shepheb: I take your class and raise you one: in my advanced symbolic programmings class we were learning about monads, and I tried to raise a snarky comment and the teacher made me go and teach the last half hour of the class ^^
18:19:23 <copumpkin> lol
18:19:23 <ksf> (I know that I'm going to end up with all () monad actions, and I don't care)
18:19:28 <ivanm> heh, from fmlist's description: "These wild claims are still completely unverified though. "
18:19:29 <copumpkin> ezyang: that's pretty sweet
18:19:36 <shepheb> most people struggled greatly with it, and I found it both straightforward and fun. I realized then that Haskell has broken my brain.
18:19:40 <shepheb> ezyang: awesome
18:19:56 <shepheb> the prof for this class sent slides to that other Haskeller and me, to get our comments, corrections.
18:20:02 <ezyang> I also discovered that the fact that scheme is not auto-curried is really annoying!
18:20:05 <copumpkin> ezyang: was the prof being bitchy as in "oh, you know it so well? you teach it"
18:20:12 <copumpkin> or "ooh, you know this, show us what you know!"
18:20:19 <Saizan> ksf: i'd use Codensity (Writer [a]), but maybe i like Codensity too much :)
18:20:19 <ezyang> copumpkin: more the latter
18:20:20 <shepheb> that drove me nuts in ML
18:20:26 <ezyang> which was cool
18:20:28 <shepheb> and Scheme
18:20:30 <copumpkin> lol
18:20:32 <pikhq> shepheb: Untyped lambda calculus? Fun stuff. :)
18:20:42 <ivanm> shepheb: I had my first ever class tutoring haskell yesterday; I don't know if it's the geographic region (since I've just moved unis), but I've found that scientists were more receptive to learning programming than engineers + IT students are... >_>
18:20:48 <ivanm> (also python vs haskell)
18:20:49 <shepheb> especially in ML. data constructors are tupled, some of the library functions are curried and some aren't
18:20:54 <copumpkin> Codensity (Writer (Maybe (Cofree Maybe)))
18:21:04 <copumpkin> how's that?
18:21:23 <ksf> ...I don't want to optimize the hell out of it, I just want to have something to do that's going to make me understand how gpipe works.
18:21:26 <copumpkin> whoops, I need an a in there
18:21:32 <copumpkin> Codensity (Writer (Maybe (Cofree Maybe a)))
18:21:33 <shepheb> pikhq: yeah, that class is awesome. untyped and simply typed LC, polymorphic LC, System-F.
18:22:35 <shepheb> plus programming assignments in Scheme, ML and Haskell.
18:22:44 <pikhq> ezyang: Also, heheheh. Monads, eh?
18:22:50 <twink> Currying everything has a certain consistency to it, but I didn't notice it being a big deal in Standard ML, as it appeared to be consistently uncurried (contrary to some perceptions).
18:23:19 <shepheb> current assignment on Haskell involves length-lexicographic infinite lists of all the strings accepted by a regex and DFA. the latter is easy enough, but concatenation of REs is driving me nuts.
18:23:29 <theorbtwo> ivanm: Not overly surprising.  It's been noticed many times that it's easier to learn imperitive or functional programming as your first paradigim.
18:23:29 <Saizan> copumpkin: what's the Monoid instance for Cofree?:)
18:23:45 <shepheb> twink: yeah, most of the functions are chosen correctly. but any conversion is too much
18:23:54 <copumpkin> Saizan: well my point was that Maybe (Cofree Maybe a) should be roughly equivalent to [a] :P
18:23:56 <ivanm> theorbtwo: no, I meant that the engineers were busy going "why do I have to learn programming?"
18:24:04 <theorbtwo> ivanm: Ah.
18:24:06 <theorbtwo> Hm.
18:24:08 <ivanm> whereas the science students found it more interesting in general
18:24:28 <ivanm> then again, the science class was being run by a couple of crazy (in their antics) lecturers, whereas this one is serious...
18:24:48 * shepheb looks up Cofree, getting a fmap fix return == id vibe
18:24:49 <ivanm> also, engineers are too stupid to work out how to use Gnome on their own
18:24:53 <theorbtwo> Almost everybody I know who does engeneering either got there by way of programming, or expects to learn programming.
18:25:06 <pikhq> ivanm: Wait, seriously?
18:25:12 <ivanm> yup
18:25:13 <theorbtwo> Those are mostly by way of the reprap project, though.
18:25:18 <shepheb> you need a budget to do most of the other engineerly things
18:25:28 <ivanm> "how do I open a browser?" "why don't you try clicking on the firefox icon up the top"
18:25:34 <Saizan> copumpkin: they are isomorphic as plain types, i was checking if they were as monoids too :P
18:25:47 <pikhq> theorbtwo: Reprap? Your university is involved in that? That's pretty awesome.
18:26:03 <copumpkin> Saizan: oh, I was just assuming the usual list monoid instance :) I can only think of two instances but maybe there are magic other ones?
18:26:29 <theorbtwo> pikhq: I have no university.
18:26:44 <theorbtwo> I hang around the project on IRC, and it's many blogs.
18:27:09 <twink> All the engineers I knew pretty much took programming in stride, essentially as part of the expectation of using computers as calculators for whatever they were doing.
18:27:15 <dolio> Can anyone type a \dashv for me?
18:27:21 <Saizan> copumpkin: i guess i was askinf if there's a natural way to make "Cofree f a" a monoid, with some constraint on 'f' if needed
18:27:34 <copumpkin> Saizan: yeah, no clue :) it'd be cool if there were
18:27:55 <pikhq> theorbtwo: Ah.
18:28:00 <Saizan> dolio: 
18:28:06 <ivanm> dolio: here you are: \dashv
18:28:06 <ivanm> :p
18:28:09 <pikhq> theorbtwo: Reprap is still pretty awesome. :)
18:28:11 <dolio> Thanks.
18:28:18 <ivanm> pikhq: have you seen makerbot?
18:28:21 <theorbtwo> I quite agree.
18:28:29 * ivanm was at a demo of one last week
18:28:34 <pikhq> ivanm: Yes.
18:28:35 <ivanm> 3D printers! \o/
18:28:40 <pikhq> Not in person, but yes.
18:28:48 <copumpkin> where does the name \dashv come from?
18:28:49 <pikhq> Note that Makerbot is some of the same guys.
18:29:00 <ivanm> yeah, I know
18:29:04 <theorbtwo> I very much wish I had a university; a good many people seem to use university resources to help them get their own.
18:29:08 <dolio> copumpkin: It's a dash, followed by a vertical bar.
18:29:14 <copumpkin> oh, smart
18:29:36 <ivanm> I want one, except that I don't want to spend the money, I would probably waste too much time on it for a while and then not touch it ever again, it isn't really practical to make stuff with it and I have nowhere to put it...
18:29:46 * ksf is stumpified by
18:29:47 <ksf> evaluateDeep a = do t <- evaluate (a==a)
18:29:48 <ksf>                     return $ if t then a else undefined
18:30:05 <MissPiggy> ksf looks insane
18:30:11 <ivanm> ksf: presumably (==) is strict
18:30:19 <Zao> ksf: Requiring Eq sounds a bit overkill.
18:30:21 <ivanm> evaluate forces the Bool to be evaluated
18:30:23 <ksf> ...that's either quite useless or Eq a is abused horribly
18:30:31 <MissPiggy> abused horribly
18:30:47 <ivanm> ksf: I think Eq is abused because there's no other arbitrary way (other than DeepSeq) to force evaluation presumably
18:30:55 <ivanm> unless you use Show
18:30:59 <Zao> Equality comparisions tend to require every little bit of things to be compared.
18:31:06 <ksf> ...but then why not use NFData?
18:31:11 <Zao> Especially if they're equal, as you can't really early out that.
18:31:16 <MissPiggy> ksf because it's insane
18:31:18 <theorbtwo> :t seq
18:31:19 <ivanm> ksf: because that requires yet another instance to be written?
18:31:19 <lambdabot> forall a t. a -> t -> t
18:31:27 <ivanm> @hoogle deepseq
18:31:27 <lambdabot> No results found
18:31:34 <ksf> isn't nfdata derivable?
18:31:40 <ivanm> not sure
18:31:46 <ivanm> but I doubt it
18:31:52 <ivanm> unless you use GeneralizedNewtypeDeriving
18:31:54 <ksf> http://hackage.haskell.org/packages/archive/derive/0.1.1/doc/html/Data-Derive-NFData.html
18:32:08 <ivanm> ksf: it's been split off into a new package, hasn't it?
18:32:34 <ivanm> ahhhh, you use yet another library to derive it
18:32:52 <ivanm> ksf: maybe the author of evaluateDeep didn't know about that?
18:33:14 <ksf> ...I guess so.
18:33:48 <ksf> all that forcing makes the gpipe code quite ugly, too.
18:34:38 <ksf> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23153#a23153
18:35:31 <ksf> aren't ffi calls strict in their arguments, anyway?
18:35:31 <ivanm> come on, they couldn't even line up the = signs?
18:35:46 <ivanm> IIRC they _should_ be
18:37:13 <ksf> I _hate_ such situations. I'd like to get rid of all those IoEvaluates, but I'm not completely sure that they're not necessary in some arcane way.
18:38:43 <theorbtwo> Can you use FFI to make a library in haskell that is callable from C, BTW?
18:38:50 <ksf> yep
18:39:02 <ksf> never did it, though
18:39:27 <ksf> ...there's a chapter in the ffi addendum about it, don't know how well c2hs and/or hsc2hs support it
18:40:58 <kpreid> ^^aoham is an onjoin spammer
18:43:35 <ivanm> kpreid: who?
18:43:49 * ivanm doesn't notice anyone called aoham joining...
18:43:59 <kpreid> not aoham, ^^aoham
18:44:14 <ivanm> oh, someone that's already here
18:44:51 <ivanm> preflex: seen ^^aoham
18:44:51 <preflex>  Sorry, I haven't seen ^^aoham
18:44:55 --- mode: ChanServ set +o xerox
18:45:10 <ivanm> might be an onjoin spammer, but preflex has no record of them ever saying anything here... >_>
18:45:12 --- mode: xerox set +b *!*@95.66.40.240
18:45:25 --- kick: ^^aoham was kicked by xerox (^^aoham)
18:46:08 <ksf> now I know why gpipe is so hard to get a hold of.
18:46:19 <ksf> it's using global iorefs all over the place
18:48:42 <Saizan> ivanm: they usually send a pm
18:48:48 <ivanm> ahhh
19:07:47 <A1kmm> Is there an easy way to substitute all VarT entries in a TypeQ structure which correspond to a TySynD for the type of the TySynD?
19:08:02 <A1kmm> (in other words, map all type synonyms to their full versions)
19:08:49 <dons> Itkovian: the file i have here lists the main ones: http://www.galois.com/~dons/acovea/ghc-6_12.acovea
19:08:58 <dons> http://www.galois.com/~dons/acovea/ghc-6_10.acovea
19:09:51 <ivanm> dons: did you see the guy whining on reddit that you got more votes than his story about C++?
19:11:07 <roboshibby> why the big T in haskell ?
19:11:49 <copumpkin> ?
19:12:14 <ivanm> ?
19:12:16 <dolio> Haskell doesn't have any Ts.
19:12:23 <ivanm> you mean ListT, etc.?
19:12:29 <ivanm> monad transformers
19:12:37 <dons> hehe
19:12:42 <roboshibby> yea big T stuff
19:12:42 <dons> ivanm: no, didn't see that
19:12:45 <roboshibby> at the nd of words
19:12:55 <dons> ivanm: url?
19:13:03 <ivanm> http://www.reddit.com/r/programming/comments/b7x5u/what_is_with_the_cc_hate_and_haskell_love/
19:13:09 <ivanm> roboshibby: monad transformers
19:13:14 <ivanm> @hoogle MaybeT
19:13:14 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
19:13:16 <dons> ah i see
19:13:17 <ivanm> bah
19:13:43 <dolio> Also, did you really pick ListT as the canonical monad transformer example? :)
19:14:02 <dolio> The most broken one of the bunch. :)
19:14:10 * copumpkin hugs ListT
19:14:16 <copumpkin> everyone hates you, but I love you
19:14:16 <geekagent> stateT would be canonical I think.
19:14:50 <ivanm> dolio: it's the first one I could think of ;-)
19:15:11 <ivanm> since I had just seen the listT package on hackage when searching for something
19:40:05 <djahandarie> Anyone got an example of some cool stuff to do with QuickCheck2?
19:40:41 <c_wraith> cool?
19:40:54 <djahandarie> Yeah!
19:41:08 <djahandarie> Who said test-driven development can't be exciting.
19:41:28 <ivanm> heh, I wrote my tests way after writing my code
19:41:39 <c_wraith> haha.  I actually used quickcheck for test-driven development the only time I used it.
19:41:43 <c_wraith> But I used it in a strange way.
19:41:46 <ivanm> (and in some cases modified my tests to avoid coming across problems I knew wouldn't actually occur "in real life" :s
19:42:15 <djahandarie> I usually write my tests somewhere in the middle of writing my code
19:42:34 <c_wraith> Well.  I wrote 2 of the 3 main functions before the tests.  But I wrote the third after the tests!
19:43:30 <c_wraith> djahandarie: I don't know if this is actually interesting, but the test is in my package on hackage
19:43:38 <c_wraith> @hackage lrucache
19:43:39 <lambdabot> http://hackage.haskell.org/package/lrucache
19:43:53 <ivanm> c_wraith: what's an LRU cache?
19:44:13 <twink> Least Recently Used replacement policy
19:44:19 <c_wraith> a thingie. :)  (A cache that discards elements least recently used)
19:44:29 <ivanm> ahhhh
19:45:03 <djahandarie> c_wraith, cool. Anything is interesting!
19:45:04 <ivanm> c_wraith: why are "internal" modules publically accessible?
19:45:17 <ivanm> @hackage graphviz
19:45:17 <lambdabot> http://hackage.haskell.org/package/graphviz
19:45:22 <ivanm> ^^ my library + test suite
19:45:50 <copumpkin> ivanm: I like it when that's the case
19:45:57 * djahandarie visualizes
19:45:57 <c_wraith> ivanm: Because in my experience, I've wanted to manipulate data structures in ways the original author didn't anticipate.  I figured I'd make it easy to do that with my package.
19:45:58 <ivanm> copumpkin: what?
19:46:09 <ivanm> oh, exported internal modules?
19:46:13 <copumpkin> yeah
19:46:24 <ivanm> c_wraith: but with a big large "user beware" warning up the top?
19:46:30 <c_wraith> ivanm: yes
19:49:30 <c_wraith> ivanm: I figure it's a reasonable way to do things.  Not ideal, but ideal is probably impossible.
19:49:38 <ivanm> *nod*
19:49:40 <c_wraith> too many conflicting desires
19:50:01 <ivanm> c_wraith: IIRC, though, a lot of packages broke when bytestring stopped exporting internal modules... >_>
19:50:21 <c_wraith> was that a temporary thing?
19:52:14 <scutigera> /?
19:52:48 <ivanm> hmmm..... it still exports Internal
19:52:56 <ivanm> maybe the API changed... >_>
20:02:39 <pastorn> hmmm...
20:03:05 <pastorn> if i want to work on a Summer of Code project, what projects are there i could apply for?
20:03:20 <Saizan> there's the wiki from last year
20:03:41 <Saizan> @google summer of code haskell
20:03:43 <lambdabot> http://hackage.haskell.org/trac/summer-of-code/wiki
20:03:43 <lambdabot> Title: Haskell.org Google Summer of Code
20:04:11 <Saizan> the haskell_proposals subreddit too, i guess
20:04:55 <pastorn> yeah, i've found that :)(
20:04:57 <pastorn> :)
20:05:38 <ivanm> there's been no official list of wanted projects yet atm
20:05:47 <pastorn> dons: what do you mean by "pure HTTP/HTTPS library"?
20:05:58 <ivanm> pastorn: completely in haskell I'm guessing...
20:06:08 <ivanm> and side-effect free
20:06:57 <pastorn> what's it supposed to do? Telnet-styfe fetching + parsing?
20:07:14 <Figs> Has anyone tried to write a graphical programming environment for Haskell (or something similar to it)?
20:07:26 <pastorn> Figs: leksah
20:07:42 <pastorn> @google leksah haskell
20:07:51 <pastorn> awww... :/
20:07:57 <Figs> I don't mean an IDE.
20:07:57 <lambdabot> http://leksah.org/
20:07:58 <lambdabot> Title: Leksah - Haskell IDE in Haskell
20:08:07 <ivanm> Figs: then what do you mean?
20:08:20 <ivanm> pastorn: no idea ;-)
20:08:38 <Figs> I mean graphical programming like Subtext, or xlogiccircuits.
20:09:00 <Figs> ie, you program with graphical elements which are then compiled to code.
20:09:19 <Figs> (or interpreted, or whatever your back end does)
20:09:30 <c_wraith> those tend to be rather domain-specific.
20:09:30 * ivanm still has no idea what Figs means
20:09:49 <m3ga> @google subtext programming
20:09:50 <lambdabot> http://www.subtextual.org/
20:09:50 <ddarius> @where vital
20:09:50 <lambdabot> Title: Subtext home
20:09:51 <lambdabot> http://www.cs.kent.ac.uk/projects/vital/
20:09:53 <pastorn> ivanm: is he really asking for what haskelllove was asking about?
20:09:56 <ivanm> sounds a bit like Click & Run though ;-)
20:10:03 <ivanm> pastorn: hmmm?
20:10:15 <ivanm> I recall someone asking for something that sounded similar...
20:10:19 <ivanm> but don't think it hwas haskellove
20:10:24 <pastorn> it was
20:10:32 <ivanm> isn't vital dead?
20:10:42 <pastorn> "why do i have to write stuff? can't i just click it inte working?"
20:10:50 <pastorn> etc. etc.
20:11:10 <ivanm> heh
20:11:19 <ivanm> because then _anyone_ could do it and we'd be out of a job!
20:11:21 <Figs> I mean something like this: http://www.cs.iupui.edu/~aharris/n301/SelectBig.png, but with functions and a proper type system instead of just boolean values and operators.
20:11:26 <ivanm> except for maintenance + bug fixing :s
20:11:38 <ivanm> Figs: probably because there's no good way of doing it
20:12:17 <ivanm> though there have been people doing work (not in haskell) on something like "contextual" programming where code is stored in xml rather than text so you can move it around, etc.
20:12:35 <Cale> Figs: the closest thing I can think of is probably HOPS
20:12:47 <Cale> Though it's not really Haskell, but a similar functional language.
20:13:01 <Cale> You program by constructing expression graphs
20:13:14 <Cale> and evaluation proceeds by rewriting of graphs
20:13:44 <ivanm> hmmm.... wikipedia doesn't know anything about HOPS; ergo it isn't important :p
20:13:52 <Cale> http://www.cas.mcmaster.ca/~kahl/HOPS/
20:14:10 <Cale> Well, it's also not released to the public, unfortunately. :/
20:14:22 <ivanm> see, if it requires a special editor to program, then I don't see the point
20:14:54 <Cale> Well, it would be pretty irritating to have to draw expression graphs with ascii art.
20:15:45 <ddarius> That's what text is for.
20:15:46 <pastorn> what about making "hacktey hask?
20:15:48 <pastorn> "
20:15:51 <ddarius> let ones = 1 : ones
20:16:42 <pastorn> (haskell version of hackety hack)
20:16:48 <ivanm> never heard of it
20:16:51 <Cale> But it gives you direct control over the graph transformation rules, which lets you program optimisations that are normally tricky to accomplish in Haskell. It also lets you see the graphs as things are evaluated, which gives you a better idea about space behaviour.
20:17:12 <Cale> Apart from that, I'm not sure it's all that practical.
20:17:19 <ivanm> yeah
20:17:43 * pastorn would really like a job this summer :)
20:18:07 * ddarius is going to lose a "job" this summer and then probably get another.
20:18:25 <ivanm> summer finished two days ago...
20:18:27 <ivanm> :p
20:18:30 <ezyang> pastorn: Ooh, are you searching for an FP shop?
20:18:45 <pastorn> ezyang: ehm... dunno what you mean by that
20:18:48 <ivanm> hang on, you can buy FP now?
20:19:01 <c_wraith> that's what galois sells!
20:19:13 <pastorn> i was thinking of tricking someone into mentoring me for a Summer of Code project
20:19:36 <ivanm> c_wraith: I thought they sold software, not a process/paradigm/whatever
20:19:41 <dons> c_wraith: FP *inside*
20:20:03 <roboshibby> FP?
20:20:12 <dons> functional programming :)
20:20:24 <roboshibby> o
20:20:28 <ivanm> dons: heh
20:21:10 <ivanm> pastorn: you can ask dons about his HTTP library request now...
20:21:26 <dons> i meant 100% haskell
20:21:29 <dons> not curl etc.
20:21:42 <pastorn> dons: http parsing etc.?
20:21:43 <dons> or at least a good simulation
20:21:47 <dons> yeah, well, bos has that
20:21:59 <ivanm> oh, you want a _simulation_ of a haskell library?
20:22:14 <ivanm> pastorn: make a youtube video of using a fake pure haskell HTTP/HTTPS library! :p
20:22:36 <dons> kids these days
20:22:57 <pastorn> but a project i'v seriously been thinking about for a while is a haskell version of "Hackety Hack"
20:23:17 <pastorn> something for the kidz
20:24:45 <pastorn> what
20:24:51 <pastorn> do you guys think of that?
20:24:53 <pastorn> doable?
20:25:03 <Cale> yeah, that would be cool
20:25:15 <ivanm> whether it's worth a SoC is a different story (especially since I have no idea what you're talking about :p)
20:25:27 <pastorn> ivanm: check out "hackety hack"
20:25:47 <Cale> We already have a Haskell version of _why, except that ours hasn't vanished from the internets yet.
20:25:48 <ivanm> oh, ruby...
20:25:49 <pastorn> ivanm: it's an environment for learning ruby
20:26:09 <ivanm> Cale: well, isn't _why a _person_? :p
20:26:36 <Cale> Let's use denotational semantics to prove that BONUS will delete all his stuff from the Internet at some point in the future!
20:27:02 <ivanm> heh
20:27:14 * ddarius uses a continuation-state passing semantics.
20:27:17 <ivanm> Cale: so just to be sure we should all be mirroring everything he does before hand?
20:27:27 <ivanm> and also tryhaskell (since it's based on some of _why's stuff)?
20:27:37 <Saizan> quick, make a backup
20:27:46 <dolio> BONUS doesn't seem nearly as wacky was _why.
20:27:57 <dolio> He just draws awesome illustrations.
20:28:13 <ddarius> dolio: Have you looked at BONUS's twitter account?
20:28:22 <dolio> No.
20:28:51 <ddarius> I don't know how wacky _why was, but I'd be hesitant to say BONUS "just draws awesome illustrations."
20:29:05 <Cale> http://twitter.com/bonus500
20:29:15 <ddarius> That said, I don't think BONUS will go off the deep-end.
20:29:17 <dolio> _why's language tutorials were way wackier, at least.
20:29:31 <copumpkin> we should czech him out occasionally though, to make sure he doesn't go mad
20:29:33 <dolio> Filled with random off-topic stuff.
20:29:44 <roboshibby> _why didn't "go off the deep end"
20:29:51 <ivanm> copumpkin: we could possibly slovak him out as well if you want...
20:29:53 <copumpkin> roboshibby: prove it!
20:29:54 <roboshibby> he got tired of some things that are lame
20:29:56 <roboshibby> uh
20:30:00 <copumpkin> ivanm: I prefer czeching
20:30:05 <roboshibby> as if i have any obligation to you
20:30:12 <ddarius> "some kids lost their basket ball on my lawn ... im not a cold hearted guy so i gave them back a tennis ball ..be happy u got anything at all"
20:30:26 <copumpkin> "doctor took my pulse and now i want it back"
20:30:27 <regalia> Could someone point me in the direction of the best read to perfectly understand typeclasses?
20:30:38 <copumpkin> perfectly, eh
20:30:43 <twink> Markov chains?
20:30:53 <regalia> as best as possible
20:31:16 <dolio> @google ad-hoc polymorphism less ad-hoc
20:31:22 <lambdabot> http://portal.acm.org/citation.cfm?id=75277.75283
20:31:22 <lambdabot> Title: How to make ad-hoc polymorphism less ad hoc
20:31:30 <dolio> Well, that's not a good link.
20:31:48 <copumpkin> BMeph: I see you're into superlatives these days :) http://snapplr.com/4czj
20:32:03 <ivanm> regalia: in what sense?
20:32:17 <ivanm> what typeclasses are? how to use them? which ones are already they and how they interact?
20:32:25 <regalia> How to use them
20:32:30 <Cale> The main complaint I have about that paper is the title
20:32:40 <ivanm> most tutorials should cover it
20:32:43 <regalia> I understand what they are, I'm looking to better understand how to use them
20:32:56 <ivanm> Cale: why? don't like the phrase "ad hoc" (with or without the hyphen)?
20:33:00 <Cale> Typeclasses don't really have much to do with ad-hoc polymorphism.
20:33:00 <dolio> But it's so Wadlery. How could you not like it? :)
20:33:08 <ivanm> regalia: which tutorials have you done?
20:33:11 <regalia> ivanm: I suppose I'll just continue with RWH
20:33:19 <ivanm> Cale: I thought that was the point though...
20:33:23 <ivanm> @where typeclassopedia
20:33:24 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
20:33:25 <regalia> LYAH and I'm working through RWH
20:33:29 <ivanm> regalia: ^^ that might also help
20:33:37 <regalia> ivanm: Thank you
20:33:38 <pastorn> vin
20:33:41 <ivanm> no worries
20:33:42 <pastorn> ivanm: you're
20:33:44 <pastorn> natsy
20:33:49 <ivanm> hmmm?
20:33:59 <ivanm> vin == vehicle identification number?
20:34:04 <ivanm> @wn natsy
20:34:04 <Cale> Well, I suppose, except that a lot of people seem to have failed to understand this, and somehow got the impression that typeclasses are a type of ad-hoc polymorphism or something.
20:34:06 <lambdabot> No match for "natsy".
20:34:18 <Cale> I had to correct wikipedia a number of times.
20:34:18 <pastorn> the typeclassopedia isn't exactly for a beginner learning typeclasses :)
20:34:26 <ddarius> Cale: I guess you can get it via class Foo a where op :: a
20:34:36 <ivanm> pastorn: well, that's the only thing above RWH for them that I know of ;-)
20:34:56 <ivanm> Cale: OK, so what _is_ "ad hoc polymorphism" then if typeclasses aren't it?
20:35:16 <Cale> ddarius: sort of, but even that's more flexible than its ad-hoc equivalent, because you can make other functions/values which have (Foo a) constraints in their types
20:35:19 <dolio> Type classes are the right way to give types to ad-hoc overloaded functions.
20:35:33 <Cale> and defer the instance to be selected until later
20:35:41 <copumpkin> it'd be nice if it weren't so painful to change superclasses after the fact though
20:35:48 <copumpkin> I wonder if someone has a good answer to that
20:36:12 <ivanm> copumpkin: IIRC, there are times when it's bad to do so
20:36:23 <ddarius> Cale: That's true.
20:36:36 <ddarius> Cale: Luckily C++ has templates!
20:36:46 <ivanm> e.g. there are several choices of how to define Applicative instances; making all Monads instantiate Applicative automatically means that some of them get the wrong instance
20:37:08 <Cale> Ad-hoc polymorphism forces you to select an instance based on the local type context. Typeclass polymorphism gives you a way to defer selection and create a new polymorphic definition by using typeclass-polymorphic values.
20:37:28 <ivanm> hmmm....
20:38:09 <ivanm> Cale: so in a sense the opposite of duck typing (where it's polymorphic if it defines the right methods)?
20:38:15 <regalia> 'type class' :)
20:38:18 <Cale> For example, when we define sort in terms of (<), we have a new polymorphic function, with a *single* implementation, but which relies on typeclass polymorphic values.
20:38:20 <regalia> I already learned something ;)
20:38:22 <copumpkin> ivanm: oh, I didn't mean that way
20:38:39 <copumpkin> ivanm: I meant adding Applicative or even Functor as a superclass to Monad after the fact
20:38:50 <ivanm> copumpkin: yeah, but that goes against the Report...
20:38:59 <copumpkin> ivanm: fuck the report :P
20:39:03 <ivanm> so the way to change it is to put it into Haskell 2011 or so
20:39:06 <ivanm> copumpkin: :o
20:39:08 <copumpkin> I just mean
20:39:08 <ivanm> @slap copumpkin
20:39:09 * lambdabot pulls copumpkin through the Evil Mangler
20:39:14 <ivanm> how dare you criticise our holy book!
20:39:17 <ivanm> :p
20:39:18 <Cale> ivanm: I think we should implement first, then standardise.
20:39:35 <ivanm> Cale: isn't that what the new haskell' process is?
20:39:37 <dolio> If you don't care about the report, then you don't have any problems adding superclasses.
20:39:38 <copumpkin> if you don't think of a good superclass beforehand, or put in a superclass that doesn't belong (i.e., Show, Eq on Num)
20:39:41 <copumpkin> you're stuck with it
20:39:45 <Cale> Putting changes like that into the standard before they're in base/GHC is inappropriate, as far as I'm concerned.
20:39:49 <Cale> No.
20:40:00 <regalia> When should I consider reading the Report?
20:40:03 <Cale> Haskell' is about standardising changes to the language which are already implemented in GHC.
20:40:07 <ddarius> ivanm: That was the intent of most of the Reports until they were drafted.  Particularly the 1.0 Report...
20:40:08 <ivanm> regalia: I haven't read it... >_>
20:40:15 <regalia> ivanm: I'll hold off :)
20:40:17 <ddarius> regalia: Whenever.  It isn't a difficult read.
20:40:41 <regalia> ddarius: I'm about... 1 week fresh at this point
20:40:57 <Cale> Wait at least a couple months. :)
20:41:02 <pastorn> regalia: have
20:41:09 <ivanm> there' s not really much point in reading the report IMHO
20:41:15 <pastorn> you made an instance of any typeclass yourself yet?
20:41:19 <ivanm> though it would probably clarify a few syntactic things, etc.
20:41:30 <Cale> I learned a few useful things about Haskell that tutorials failed to mention.
20:41:33 <ddarius> I don't know if I've ever read through the Report, but I've certainly read parts of it.  It's quite readable.  Way better than the C++ standard.
20:42:01 <Cale> One of which being that if Foo is a data constructor, even if it wasn't defined with record syntax, you're allowed to pattern match with (Foo {})
20:42:13 <ivanm> which is quite nice
20:42:17 <ddarius> One should -definitely- read the FFI addendum as soon as one is interested in using the FFI.
20:42:20 <Saizan> e.g. the best description of the monomorphism restriction is in the report
20:42:26 <ivanm> especially if you don't know/care how many arguments it takes
20:42:42 <Cale> Yeah, the FFI addendum is rather tutorial in nature, and quite useful as documentation.
20:42:43 <ivanm> Saizan: I find RWH's description rather good
20:42:49 <ivanm> (or at least on how to avoid it)
20:42:49 <ddarius> Saizan: The best explanation of the differences between data and newtype are also in the Report.
20:42:59 <regalia> pastorn: I have somewhere while working through LYAH
20:43:44 <pastorn> regalia: maybe writing an instance for Num for something like "data Expr = EInt Int | EAdd Expr Expr ..." might be a nice exercise :)
20:43:55 <pastorn> and a function eval :: Expr -> Int
20:44:22 <Cale> ivanm: anyway, about my point from before, to compare typeclass polymorphism to ad-hoc polymorphism ignores the more important connection (at least in my mind) between typeclass polymorphism and plain parametric polymorphism
20:44:31 <ddarius> Incidentally, an instance of Num for such a type is likely to break all the laws.
20:44:38 <ivanm> Cale: *nod*
20:44:40 <regalia> pastorn: I'll look into that, I'm going to re-read this part in RWH
20:44:52 <copumpkin> Num has laws?
20:44:59 <ddarius> copumpkin: More like suggestions.
20:45:04 <ivanm> ddarius: they are?
20:45:19 <copumpkin> if Num is going to insult me with its evil superclasses I sure as hell am not going to respect its suggestions
20:45:30 <copumpkin> and not just the superclasses but the random appendages it has
20:45:55 <ivanm> copumpkin: "random appendages"?
20:46:03 <copumpkin> methods that make no sense
20:46:04 <Cale> After all, basic typeclass polymorphism is practically implemented as a thin layer of sugar around parametric polymorphism -- throwing in some extra implicit function parameters here and there :)
20:46:18 <Cale> (and some typing rules)
20:47:03 <ddarius> ivanm: Such a type is not going to satisfy any associative or commutative laws.  Probably won't nicely satisfy or won't satisfy at all unit laws.  May or may not satisfy fromInteger being a homomorphism.
20:47:05 <ddarius> et.c
20:47:06 <dolio> That's essentially true of ad-hoc polymorphism in C++, too, though, if you use templates.
20:47:24 <dolio> It's just implemented by duplicating code instead of passing dictionaries.
20:47:24 <ivanm> copumpkin: well, a rewrite would be nice
20:47:32 <ddarius> dolio: Templates don't reduce to parametric polymorphism.
20:47:38 <ivanm> ddarius: hmmm.....
20:47:48 <ivanm> not sure about the fromInteger one
20:47:57 <ddarius> dolio: The duplicating code and then being able to make assumptions about it leads to a lack of parametricity.
20:48:04 <ivanm> but wrt associated and commutative laws, I presume you mean how to represent stuff like 1 + 2 + 3 ?
20:48:23 * pastorn found out about the 'default' keyword a few days ago
20:48:40 <pastorn> finally i can make stuff to work :D
20:48:41 <ddarius> pastorn: Unfind out about it unless you are going to add 'default ()' to the top of all your files.
20:48:43 <dolio> Well, that doesn't surprise me.
20:49:08 <Draconx|Laptop> ddarius, it's OK, the report defines at least two Num instances with operators that aren't associative and have no identity elements.
20:49:10 <pastorn> default (Int,GLfloat)
20:49:15 <pastorn> ddarius: ^^
20:49:16 <ddarius> Draconx|Laptop: Indeed.
20:49:24 <ddarius> pastorn: Oh god.
20:49:40 <pastorn> ddarius: have you ever coded OpenGL in haskell?
20:49:48 <ddarius> pastorn: Probably.
20:50:12 <pastorn> your code is littered with ":: GLfloat"
20:50:21 <ddarius> pastorn: I find that preferable.
20:50:29 * pastorn doesn't
20:50:29 <ddarius> Or you just write typed wrappers around the stuff.
20:50:43 <dolio> What I mean is, types with type classes are, in a sense, the Right types for C++ functions that involve its parametric polymorphism interacting with its ad-hoc polymorphism.
20:51:06 <dolio> They just screwed it up by not figuring out about type classes.
20:51:07 <ddarius> dolio: I agree (more or less) with that.  That was the purpose of Concepts.
20:51:13 <dolio> Right.
20:52:20 <scutigera> types A and B.  op1 works for A's. op2 works for B's.  A/B can be converted to each other.  Is this a job for type classes ?
20:52:39 <ddarius> scutigera: Doesn't sound like it.
20:52:50 <ivanm> ddarius: yeah, I thought using it would help me debug some stuff (where I wanted defaulting to Int rather than Integer) but it did jack all in ghci :@
20:53:05 <scutigera> ddarius: does the explanation make sense ?
20:53:46 <ddarius> scutigera: It's not -nonsensical-, but I don't quite get what you are getting at.  But to the degree it means something to me, it doesn't strike me as something you would use type classes for.
20:56:14 <scutigera> A & B are a number type.  You can "+" A's and you can "*" B's but you can't A + B.  However you can A + (convB_A B).  They both depend on some class, e.g. they are both complex numbers, but have different "interpretations".
20:57:05 <pastorn> scutigera: sounds like a great use of unsafeCoerce ;)
20:57:55 <scutigera> a good example would be impedance and admittance.  you can add add admittances or impedances, but you can't add them to each other.
20:58:49 <ddarius> scutigera: I have no idea what operations you intend to put in this type class.
20:59:45 <scutigera> Z >+ Z; Y >* Y;  Z >+ 1/Y   . Hard to explain, you _can_ add Y's, or Z's but you can't add them to each other. However Y = 1/Z.
21:00:38 <scutigera> it seem's like maybe I can just use newtypes.
21:01:11 <twink> (1 :+ 1)/abs (1 :+ 1)
21:01:35 <scutigera> > abs (1 :+ 1)
21:01:36 <lambdabot>   1.4142135623730951 :+ 0.0
21:08:44 <enthymene> To anybody who may know: is there a way to get the effect of "class (Num a, Num b) => Function t a b where ... eval :: t -> a -> b"?
21:09:38 <copumpkin> what is your goal there?
21:10:26 <enthymene> well, I have math projects and homework that I'd like to use haskell for.  And there are many ways that I could represent functions; some transparent, some not.
21:10:44 <copumpkin> yeah, but specifically there
21:10:47 <enthymene> so for instance I used as a starting point Henning Thielmann's polynomial module from haskell-cafe
21:11:03 <enthymene> well, I want a class where you can define a type t to be a function between Num types a and b
21:11:12 <enthymene> however the function itself is represented.
21:11:34 <enthymene> in the case of Thielmann's code, it's a (maybe infinite) list of numbers that you can evaluate with horner's rule
21:11:56 <copumpkin> class (Num (Domain f), Num (Codomain f)) => Function f where type Domain f :: *; type Codomain f :: *; apply :: f -> Domain f -> Codomain f
21:11:57 <ddarius> @google power series, power serious
21:11:58 <lambdabot> http://www.cs.dartmouth.edu/~doug/powser.html
21:11:58 <lambdabot> Title: Power serious
21:12:16 <ddarius> copumpkin is of the new age
21:12:24 <enthymene> hmm
21:12:28 <mtnviewmark> copumpkin is so kind
21:12:42 <Saizan> and delicious
21:12:53 * copumpkin inches towards the door
21:12:57 <mtnviewmark> whereas I'm just so type
21:13:09 <ddarius> Recasting copumpkin's stuff to older technology, you'd get: class (Num a, Num b) => Function t a b | t -> a, t -> b where eval :: t -> a -> b
21:14:02 <c_wraith> @hoogle Word32 -> [Word8]
21:14:03 <lambdabot> Data.Data gmapQ :: Data a => (d -> u) -> a -> [u]
21:14:03 <lambdabot> Data.List unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
21:14:03 <lambdabot> Data.List genericReplicate :: Integral i => i -> a -> [a]
21:14:12 <copumpkin> c_wraith: what byte order? :)
21:14:26 <c_wraith> I don't care.  they're a reverse apart
21:14:32 <c_wraith> ...  I suppose I should look it up, though
21:14:41 <ddarius> @hoogle put
21:14:41 <lambdabot> Control.Monad.State.Class put :: MonadState s m => s -> m ()
21:14:41 <lambdabot> Network.HTTP.Base PUT :: RequestMethod
21:14:41 <lambdabot> Prelude putChar :: Char -> IO ()
21:14:52 <ddarius> @hoogle runPut
21:14:53 <lambdabot> No results found
21:14:56 <mtnviewmark> if you're eventually putting those Word8s into a ByteString -- use Binary.Put or Serialize.Put
21:15:08 <c_wraith> They are in fact going into a bytestring
21:15:12 <mtnviewmark> or what ddarius said
21:15:13 <enthymene> wow, okay copumpkin
21:15:19 <enthymene> I barely understand this, but thanks much :3
21:15:20 <c_wraith> ok, thanks
21:15:29 * enthymene includes a reference to compumpkin in the comments
21:15:51 <copumpkin> :t unfoldr (\x -> guard (x /= 0) >> pure (x .&. 0xff, x `shiftR` 8))
21:15:51 <mtnviewmark> @hackage binary
21:15:51 <lambdabot> http://hackage.haskell.org/package/binary
21:15:52 <lambdabot>     Ambiguous occurrence `.&.'
21:15:52 <lambdabot>     It could refer to either `Data.Bits..&.', imported from Data.Bits
21:15:52 <lambdabot>                           or `Test.QuickCheck..&.', imported from Test.QuickCheck
21:15:54 <copumpkin> something like that
21:15:55 <copumpkin> gah
21:15:56 <mtnviewmark> @hackage cerial
21:15:56 <lambdabot> http://hackage.haskell.org/package/cerial
21:15:56 <ddarius> If all things were equal I would prefer copumpkin's solution.
21:16:20 <ddarius> For your purposes, copumpkin's solution is probably the best.
21:16:40 <copumpkin> you don't even really need the Num restriction
21:16:53 <copumpkin> then it's just jmcarthur's Mapping class
21:16:58 <copumpkin> which I find quite cute
21:17:03 <ddarius> I, too, would drop the Num restriction.
21:18:04 <c_wraith> err.  I love vague documentation.  "A bitstring is an ordered sequence of 0s and 1s. The leftmost bit is the most significant bit of the string and is the newest bit generated. The rightmost bit is the least significant bit of the string."
21:18:32 <QtPlatypus> c_wraith: What is vague about that?
21:18:49 <ddarius> QtPlatypus isn't Jewish.
21:18:54 <copumpkin> it's LTR-centric
21:19:05 <copumpkin> there's nothing inherently LTR about lists
21:19:08 <c_wraith> QtPlatypus: I don't know what order the bits in the hash function output are considered to be in.
21:19:09 <copumpkin> or sequences
21:19:43 <enthymene> ddarius: I get an error: "too many parameters for class `Function' (Use -XMultiParamTypeClasses to allow multi-parameter classes) ..."
21:20:04 <ddarius> enthymene: Yes, it uses an (old) extension for multiparameter type classes.
21:20:23 <enthymene> also in copumpkin's code, are those asterisks supposed to be there?
21:20:24 <ddarius> enthymene: copumpkin's solution uses a new extension for associate types.
21:20:33 <enthymene> mkay
21:20:35 <c_wraith> the word "endian" appears exactly nowhere in this document.
21:20:48 <copumpkin> need moar gulliver's travels references
21:21:10 <mtnviewmark> what are you looking at, c_wraith?
21:21:13 * ddarius tends to use pre-/post-cancellable instead of left/right for CT properties.
21:21:25 <c_wraith> NIST SP 800-90
21:21:43 <copumpkin> c_wraith: is that PRNG stuff?
21:21:45 <c_wraith> yes
21:21:59 <mtnviewmark> ah
21:23:33 <c_wraith> I'm going to guess it's big-endian.  But I'd sure love to have some reference results to check against.
21:23:57 <regalia> doesn't it say that the msb is the leftmost?
21:24:00 <ddarius> c_wraith: Just spit out a number and open the result in a hex-editor.
21:24:34 <c_wraith> ddarius: spit out a number from what?
21:24:41 <regalia> I would assume it's big from that
21:24:57 <c_wraith> regalia: it does say that, which is why I'm assuming the same.
21:25:06 <c_wraith> But I sure wish it was unambiguous
21:25:35 <regalia> what fun would that be? :)
21:26:21 <ddarius> Anyway, we all know that you crack eggs on their big ends and process numbers on their little ends.
21:26:45 <c_wraith> this isn't really about numbers, though.  Everything's in terms of bit strings.
21:26:59 <ddarius> Bitstrings are binary numbers.
21:27:10 <QtPlatypus> ddarius: Not quite
21:27:31 <regalia> http://pastebin.com/mihM5rJa
21:27:32 <QtPlatypus> The bit string "0" is not equal "00".
21:27:42 <regalia> that's incorrect isn't it?
21:27:56 <QtPlatypus> However the binary numbers "0" and "00" are equal.
21:28:25 <copumpkin> dolio: very nice page on free structures
21:28:43 <mtnviewmark> regalia - looks to me like CannotShow can be shown!
21:29:16 <regalia> mtnviewmark: It's an example from RWH
21:29:33 <mtnviewmark> OH! - and lo and behold, bos just arrived
21:29:39 <QtPlatypus> regalia: What happens when you compile>
21:29:42 <regalia> I just checked the comments and they apparantely meant to leave out the CannotShow's deriving (show)
21:29:49 <mtnviewmark> you soulld repeat for him
21:30:05 <regalia> QtPlatypus: It compiles fine for me, I see what they're trying to demonstrate though. :)
21:30:29 <bos> huh?
21:32:05 <dobie_gillis> how do i tell ghc to always default to the libraries i've installed with cabal, not the system-wide ones?
21:33:53 <ddarius> dolio: The various laws  and I satisfy are simply the monoid laws up to isomorphism.  The isomorphisms, though, satisfy various coherence laws.
21:34:24 <dolio> Did I not explain that well?
21:35:37 <dolio> I guess I didn't explain it at all. I was kind of hoping to delegate to the wikipedia article.
21:35:45 <regalia> in type class instances, Foo x = id is the same as Foo = id correct? Is that a use of partial application?
21:35:47 <dolio> Because I don't want to write out all that stuff.
21:35:54 <regalia> Err
21:35:57 <regalia> Foo x = id x
21:36:04 <regalia> same as Foo = id
21:36:09 <ddarius> dolio: That's okay.  It's just not a big leap.  Also, for monads, you have a strict monoidal category where  and I actually form a monoid.
21:37:31 <lispy|web> Did anyone reply on haskell-cafe and explain that the recent JQuery is a monad blog post misses the 3 monad laws?
21:38:02 <ddarius> That's not a recent story.
21:38:03 <copumpkin> I thought that had been debunked a while ago
21:38:10 <ddarius> And I doubt it is worth wasting one's time on
21:38:22 <lispy|web> Oh.  I receive my haskell-cafe messages via snail.
21:38:48 <lispy|web> ddarius: well... a fair number of non-monad enlightened people thought it was accurate.
21:38:57 <lispy|web> Which is unfortunate
21:39:12 <copumpkin> ah, I didn't even realize it had been reposted
21:39:30 <lispy|web> JQuery may or may not be a monad (I haven't checked) but it would be sad if people thought it just took "instance Monad Foo where..."
21:39:40 <ddarius> lispy|web: Correcting all such things is a losing battle.
21:40:18 <lispy|web> ddarius: That is wise beyond my years :)
21:40:31 <lispy|web> Fight the good fight!
21:40:37 <c_wraith> So, binary appears to be big-endian.
21:40:42 <c_wraith> I think that works!
21:40:43 <lispy|web> Educate the masses to the lambda goodness
21:41:36 <ddarius> lispy|web: The quicker you try to educate the masses, particularly from comments to blog posts, the more quickly half-educated masses spread forth misinformation.
21:41:45 <mtnviewmark> c_wraith - the binary package?
21:42:07 <mtnviewmark> use Data.Binary.Put or Data.Binary.Builder -- then you can choose big endian or little endian
21:42:29 <mtnviewmark> Data.Binary is really only good if you don't care what the wire format is - you just want to get it from here to there
21:43:09 <mtnviewmark> if you need to match some spec wire format, then use Put or Builder - and you can write your own functions in the Put monad that put data in the Bytestring any way you want
21:43:26 <dons> wow. got kinda a big response to the llvm article. yaya
21:43:37 <lispy|web> dons: woot!
21:43:44 * mtnviewmark really thinks the Binary class and it's "default Haskell encoding" should be decoupled from the Put/Get/Builder machinery
21:43:52 <dons> mtnviewmark: you're not alone
21:43:55 <ivanm> dons: you sound really excited...
21:44:14 <dibblego> @hoogle (a -> Bool) -> Maybe a -> Maybe a
21:44:14 <dons> ivanm: i'm glad the work got out there.
21:44:14 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
21:44:15 <lambdabot> Data.Traversable fmapDefault :: Traversable t => (a -> b) -> t a -> t b
21:44:15 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
21:44:15 <ivanm> greetings dibblego
21:44:17 <dibblego> hello
21:44:57 <dons> ivanm: people i've never heard of http://twitter.com/foogoof/statuses/9851966765
21:45:30 <ivanm> dons: by the way, Clem @ ANU thinks you're crazy for how much haskell stuff you do
21:45:42 <dons> in what sense... dare i ask?
21:45:50 <ivanm> because of how much you do
21:45:54 <dons> oh, volume?
21:46:04 <dons> i'm scared of turning 30
21:46:07 <ivanm> including being at conferences at hacking away during coffee breaks rather than socialising
21:46:10 <ivanm> heh
21:46:11 <dons> :)
21:46:15 <lispy|web> dons: It's not so bad :)
21:46:18 <ddarius> Are we going to import a significant portion of the LLVM community as we did the Perl community?
21:46:32 <dons> ddarius: i hope so. we've had some contacts already
21:46:34 <tommd> Note to self (and others) forgetting the --disable-split-objs on gtk2hs builds for GHC 6.12.1 results in confusing linker errors.
21:46:42 <ivanm> ddarius: difference is, we're not writing LLVM in haskell...
21:46:51 <dons> tommd: hmm.
21:46:57 <dons> tommd: i didn't see that.
21:46:58 <ddarius> ivanm: yet
21:47:04 <ivanm> heh
21:47:36 <dons> ivanm: hacking is socializing though. :) that's all hackathons are, really.
21:47:48 <ivanm> dons: no, this is at actual conferences
21:47:51 <dons> socialize -- but all your conversations are in commit form
21:47:51 <lispy|web> tommd: hmm...What is the long term solution?  Fix gnu ld or stop splitting obs?
21:47:53 <ivanm> not hackathons
21:47:54 <tommd> dons: Its just that, since dcoutts patch to make gtk2hs work with GHC 6.12.1, ./configure must include --disable-split-objs or excess object files get included in the library - and many of the symbols have issues.
21:48:04 <scutigera> hackers convert social engagements into code ?
21:48:08 <dons> ivanm: was he at icfp or something?
21:48:13 <ivanm> must have been
21:48:15 * dons wonders if i snobbed clem
21:48:18 <ivanm> heh
21:48:21 <ddarius> scutigera: hackers social engagements are code
21:48:26 <tommd> lispy|web: I'm not sure but hope coutts or one of the gtk2hs folks are working it.  Who are the gtk2hs folks anyway?
21:48:27 <ivanm> nah, I think it's more in awe than anything else
21:48:34 <dons> heh
21:48:35 <ivanm> tommd: good question
21:48:48 <bos> the LLVM bindings are picking up some good steam
21:48:53 <scutigera> ddarius: embarrasingly, that took me a secord
21:49:00 <scutigera> s/secord/second/
21:49:06 <dons> there was some twitter buzz about the bindings, just as a result of the backend stuffffffffffffffffffffffff
21:49:40 <copumpkin> so much twitter talk around here these days ;)
21:49:50 * ddarius highly suspects a -very- significant silent Haskell community.
21:49:50 <copumpkin> one day we'll even convince the luddites to get an account!
21:49:51 <dons> dude its 2010
21:50:03 <ddarius> copumpkin: Nope.
21:50:07 <ivanm> copumpkin: never!
21:50:09 <ddarius> copumpkin: Not even remotely leaning toward it.
21:50:11 <copumpkin> :P
21:50:46 <ivanm> dons: oh, did you hear that UNSW is replacing Haskell as the first year subject with _C_ ?!?!?! :s
21:50:49 <scutigera> copumpkin: what's twitter ?
21:50:50 <horms> copumpkin: tircd needs some haskell love
21:50:53 <dons> ivanm: happened last year
21:51:01 <dons> ivanm: they merge elec. eng and comp sci
21:51:04 <ivanm> oh, someone was telling me they were still doing haskell this year
21:51:10 <dons> and those electrical engineers don't like lambdas :/
21:51:14 <ivanm> but still
21:51:18 <dons> so spaghetti C for them!
21:51:20 <ivanm> teaching first year students _C_?
21:51:25 <bos> nothing wrong with teaching through C. could be much worse, e.g. java.
21:51:25 <scutigera> dons: uh, excuse me....
21:51:33 <dons> yeah, suxors. that's the legacy of the dot com crash. no enrolments, merged courses etc
21:51:35 <scutigera> dons: I are a EE
21:51:41 <ivanm> I had enough trouble explaining to first year Eng/CS/IT students how to launch firefox in gnome...
21:51:41 <dons> scutigera: yaya :)
21:51:42 <copumpkin> scutigera: clearly you suck
21:52:04 <ivanm> bos: I would think that Java made more sense for first year if only because of GC
21:52:08 <dons> bos: yeah, C instead of Java is UNSW's hard edge operating systems influence, I guess.
21:52:18 <dons> you're s'posed to be doing kernel hacking by the end of 2nd year
21:52:22 <ivanm> :o
21:52:27 * ivanm is glad he didn't go to UNSW
21:52:28 <mtnviewmark> jeez - if they are going to use the EE students as an excuse -- at least start them with Assembly --- it'll do both the EEs and the CSs a world of good!
21:52:29 <scutigera> copumpkin: somebody's got a make the hardware to run your lambda's, although I allow your lambdas to fly through the air.
21:52:38 <dons> ivanm: its good for you, i tells ya. like spinach
21:52:43 <copumpkin> scutigera: nah, I run my programs on paper
21:52:54 * mtnviewmark looks around for his processor instruction reference card
21:52:59 <bos> ivanm: java makes people stupid.
21:52:59 <copumpkin> and most of the time never even run programs
21:53:10 <scutigera> copumpkin: using the end of a burned stick to write ?
21:53:19 <copumpkin> scutigera: blood on stone, actualy
21:53:26 <copumpkin> lly
21:53:28 <scutigera> copumpkin: hardcore
21:53:30 <ddarius> copumpkin: Allegedly if you were French, you'd turn your programs.
21:53:39 <ddarius> (or at least your computers)
21:54:20 <mtnviewmark> so *that's* how copumpkin invokes all those obscure Math gods to do his bidding and re-write our multi-file code as one liners that are actually more generalized.....
21:54:30 * ivanm did a one semester course with assembly and C on a microcontroller, and has avoided both since
21:54:45 * ddarius <3 assembly.
21:54:50 <ivanm> bos: *shrug* I did Java at uni
21:54:57 <ivanm> I prefer Fortran 90 + to C
21:55:02 <regalia> http://en.wikipedia.org/wiki/IJVM
21:55:14 * mtnviewmark cut his teeth on assembly for at least 7 different architectures....
21:55:19 <copumpkin> mmm, un logiciel
21:55:49 <lispy|web> dons: any updates to report about the sha stuff?
21:55:58 <scutigera> http://www.usenix.org/events/vee06/full_papers/p46-bocchino.pdf : supposedly some of this is in LLVM according to author's page.
21:56:35 * ivanm calls it a day and heads off home
21:56:44 <ivanm> bye all
21:56:49 <regalia> bye
21:56:49 <copumpkin> si tu cris tes logiciels en haskell, tu n'auras pas de coquilles :o
21:57:08 <ivanm> since when did this turn into #haskell-fr ?
21:57:13 <ivanm> ;-)
21:57:13 <lispy|web> ivanm: I agree
21:57:21 <copumpkin> you agree with his question?
21:57:22 <lispy|web> (to the heading home thing)
21:57:24 <copumpkin> oh
21:57:26 * lispy|web falls asleep
21:57:29 <ivanm> heh
21:58:02 <dons> lispy|web: haven't got to that yet
22:04:26 <scutigera> copumpkin: have mercy on mEE: instance Fluffy Maybe where; furry f (Maybe a) = Maybe (f a); Not in scope: data constructor `Maybe'
22:04:34 <scutigera> and yes I imported Data.Maybe
22:04:40 <copumpkin> Just
22:04:43 <copumpkin> :)
22:04:52 <copumpkin> Maybe is the type constructor
22:05:02 <copumpkin> I make that mistake more often than I'd like
22:05:13 <scutigera> copumpkin: #$$##@$!!
22:06:58 <scutigera> copumpkin: merci
22:08:07 <dibblego> how does one filter a Maybe?
22:08:36 <Saizan> filter a Maybe?
22:08:46 <dibblego> (a -> Bool) -> Maybe a -> Maybe a
22:08:49 <c_wraith> :t catMaybes
22:08:50 <lambdabot> forall a. [Maybe a] -> [a]
22:09:01 <c_wraith> err..  fmap?
22:09:17 <c_wraith> no, that's wrong.  But what do you want it to do if the predicate returns false?
22:09:23 <dibblego> Nothing
22:09:26 <copumpkin> turn it into a Nothing
22:09:31 <dibblego> same as it does for []
22:09:38 <copumpkin> I don't think there's anything pretty for that
22:09:48 <dibblego> Maybe is a list with a maximum length of 1 after all
22:09:49 <Saizan> \f m -> do guard . f =<< m; m
22:09:56 <copumpkin> lol
22:10:04 <copumpkin> I guess that's nice
22:10:15 <copumpkin> @pl \f m -> do guard . f =<< m; m
22:10:15 <lambdabot> (line 1, column 27):
22:10:15 <lambdabot> unexpected ";"
22:10:15 <lambdabot> expecting letter or digit, variable, "(", operator, "=<<", ">>>", "^>>", "^<<", ">>", ">>=" or end of input
22:10:18 <copumpkin> ugh
22:10:26 <copumpkin> @@ @pl @undo \f m -> do guard . f =<< m; m
22:10:26 <lambdabot>  (line 1, column 26):
22:10:27 <lambdabot> unexpected ">"
22:10:27 <lambdabot> expecting variable, "(", operator, "=<<", ">>>", "^>>", "^<<", space or end of input
22:10:27 <lambdabot> ambiguous use of a left associative operator
22:10:29 <copumpkin> meh
22:10:40 <Saizan> if we had monad comprehensions you could write [ x | x <- m; p x ]
22:10:48 <dibblego> indeed
22:11:03 <dibblego> monad comprehensions require MonadPlus then?
22:11:12 <Saizan> do x <- m; guard (p x); return x
22:11:42 <Saizan> dibblego: some features do, yeah
22:12:28 <dibblego> ok cheers
22:12:29 <jamamooga> Hello. What does \_ mean in (start code) m >> n = m >>= \_ -> n (end code)? It is part of a type class for monad. I am converting some code to F# & I couldn't figure it out with a web search.
22:12:43 <dibblego> jamamooga, it is a lambda where the right side expression ignores its argument
22:12:57 <dibblego> > let f = \_ -> 7 in f "abc"
22:12:58 <lambdabot>   7
22:13:01 <Saizan> jamamooga: _ means "don't care" in a pattern
22:13:03 <pikhq> _ is the way you ignore things in a pattern match, and \ is lambda.
22:13:15 <jamamooga> thanks
22:15:03 <Cale> (So it's equivalent to m >>= \x -> n, except that someone wanted to be clever ;)
22:15:25 <jamamooga> I have been trying to code more like haskell in F# & I am starting on making a programming language that is like haskell but with an prefix s-expression syntax.
22:15:36 <Itkovian> dons: Thx.
22:15:43 <jamamooga> thanks Cale, no I can convert it better
22:15:48 <jamamooga> now even
22:16:05 <aavogt> maybe this is pedantic, but there is only one Monad typeclass
22:16:44 <Saizan> jamamooga: seen liskell?
22:17:14 <Cale> jamamooga: Do you know about ... heh, Saizan beat me to it
22:17:35 <jamamooga> yes but if you don't have a type class for monad you need to make it
22:18:03 <jamamooga> I have heard of liskell.
22:18:09 <dibblego> if you're making a type-class for monad, make sure you inherit Applicative
22:18:38 <jamamooga> I am doing it in F# not Haskell
22:19:02 <jamamooga> F# isn't as good at type classes as Haskell
22:20:54 <dibblego> you can't encode type-classes in F# at all
22:21:37 <jamamooga> Not directly, but I read an article on how to sort of fake it.
22:22:39 <dibblego> where boots?
22:24:49 <Cale> F# surely has parametric data types
22:25:32 <Cale> So you might be able to get away with just adding another parameter to your polymorphic functions.
22:25:33 <copumpkin> does anyone know of something that covers the category of relations and its connection to relational databases? things like equijoin (apparently) being a fiber product, etc.
22:27:11 <jamamooga> dibble: I did a web search for F# AND "type class" - http://codebetter.com/blogs/matthew.podwysocki/archive/2009/05/08/type-classes-are-the-secret-sauce.aspx AND http://fortysix-and-two.blogspot.com/2009/01/poor-man-typeclass.html
22:28:45 <Rotaerk> you can have return-type polymorphism if you use the curiously recurring template pattern
22:29:38 <jamamooga> Rotae: are you talking about Haskell or F# or either?
22:29:42 <Rotaerk> you can have compiletime polymorphism like typeclasses in F# if they make a slight change to the language (i.e. to allow static type constraints to consider extension methods)
22:29:44 <Rotaerk> F#
22:31:11 <Rotaerk> (they're considering said change for a future version)
22:31:15 <jamamooga> Rotae: thanks that should make it work better
22:31:21 <jamamooga> I know
22:32:30 <jamamooga> Rotae: did you mean real type classes possibly in future version or that work around you mentioned?
22:32:38 <Rotaerk> the work-around
22:32:52 <Rotaerk> and even with that, it may not be equivalent to typeclasses... but similar
22:37:13 <Rotaerk> jamamooga, anyway, with that change, you could do something like this in F#: http://rotaerk.pastebin.com/pRRuLPbv
22:38:24 <Rotaerk> however, currently the static constraints don't see Equal and NotEqual as being members of Int32
22:39:32 <jamamooga> dibble: I actually saw this F# type class work around first: http://blog.matthewdoig.com/?p=112
22:43:10 <pastorn> i can't help writing a reduce/reduce parser :(
22:43:32 <pastorn> (in parsec)
22:44:22 <jamamooga> Rotae: Thanks I have much more info on faking type classes in F# now.
22:44:28 <pastorn> i have "inBraces p = between (char '{') (char '}') p"
22:45:14 <pastorn> but then i have pNick = do { c <- letter; cs <- many (letter <|> digit <|> oneOf "-[]\\`^{}"); return (c:cs);}
22:45:39 <pastorn> since pNick allows '{' and '}' i can't do 'inBraces pNick'
22:47:11 <Rotaerk> np
23:37:26 <mreh> > 0.0 :: Float
23:37:27 <lambdabot>   0.0
23:37:41 <mreh> all zeros I suppose
23:37:57 <MatrixFrog> ooo a bot that evals haskell? :-D
23:38:07 <c_wraith> a subset of haskell, anyway
23:38:10 <c_wraith> > print "hello"
23:38:11 <mreh> generating random constants for my GP is going to be tricky
23:38:11 <lambdabot>   <IO ()>
23:38:19 <c_wraith> It doesn't actually evaluate IO, for instance. :)
23:38:20 <MatrixFrog> yes well that's still quite awesome
23:38:41 <mreh> > maxBound :: Float
23:38:42 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Types.Float)
23:38:42 <lambdabot>    arising from a use of...
23:38:54 <mreh> not bounded huh
23:38:59 <c_wraith> yeah, Float and Double aren't bounded
23:39:39 <MatrixFrog> they follow the ieee-754 spec or whatever it's called, right?
23:39:48 <mreh> there are two
23:39:50 <mreh> one for each
23:39:57 <mreh> IIRC
23:39:59 <c_wraith> I'm not sure that the spec requires it, but GHC's implementation does
23:40:20 <MatrixFrog> *shrug*
23:40:58 <mreh> floats will still blow up when you do some division with a very small number, or zero
23:41:07 <c_wraith> > 0.0 / 0.0
23:41:08 <lambdabot>   NaN
23:41:15 <MatrixFrog> however... something fun i discovered:
23:41:17 <MatrixFrog> > 1/0
23:41:17 <mreh> > 0.00000000000000000000000001 / 0.0000000000000000001
23:41:18 <lambdabot>   Infinity
23:41:18 <lambdabot>   1.0000000000000001e-7
23:41:27 <MatrixFrog> Infinity! :-)
23:41:29 <mreh> > 1 / 0.00000000000000000000000001
23:41:30 <lambdabot>   9.999999999999999e25
23:41:35 <mreh> > 1 / 0.0000000000000000000000000000000000000000000001
23:41:36 <lambdabot>   1.0e46
23:41:45 <c_wraith> Yeah, the IEEE-754 spec includes +/- Infinity and NaN
23:41:57 <mreh> so there's no wrapping
23:42:04 <mreh> ah, that's why it is unbounded
23:42:24 <c_wraith> 0 is also a special case in IEEE-754
23:42:41 <mreh> the first bit is zero?
23:42:50 <c_wraith> Since it otherwise wouldn't be representable in a the normalized format
23:43:18 <c_wraith> since the normalized format is specified to not include the leading 1 bit in the mantissa.
23:43:54 <mreh> do they still call it mantissa and exponent? that is what I was taught, but I think the lexicon has changed
23:44:06 <c_wraith> maybe it has.  *shrug*  :)
23:44:33 <mreh> base and exponent
23:44:38 <MatrixFrog> i think the class i took just called the mantissa "the fraction"
23:44:45 <MatrixFrog> which is ok if you explain what you mean
23:45:45 <mreh> if they don't explode, then they are pretty safe to use in my GP
23:47:37 <copumpkin> > 0.3216719672875965 - 0.31161971830985913 :: CReal
23:47:38 <lambdabot>   0.01005224897773737
23:49:39 <mreh> is there a Quadrupole accuracy representation?
23:49:50 <mreh> in GHC
23:49:53 * MatrixFrog has no idea what you're talking about but it sounds cool
23:50:11 <mreh> Float <- single precision, Double <- double precision
23:50:24 <mreh> 32 and 64 bits respectively
23:50:36 <mreh> there is a 128 bit one specified too
23:50:39 <MatrixFrog> yeah i'm familiar with that. what's this quadrupole stuff
23:50:51 <MatrixFrog> oh is that the 128-bit floating point numbers?
23:50:57 <dons> there's Data.Fixed
23:51:20 <mreh> quadruple*
23:51:25 <MatrixFrog> gotcha
23:51:26 <dolio> It's like a monopole, and a dipole, only with 4 poles.
23:51:34 <MatrixFrog> yeah that's what i was thinking
23:51:40 <mreh> damn spell checker, why did it suggest that?
23:51:48 <mreh> my spell checker is a nerd
23:52:02 <MatrixFrog> well, it's a physics nerd
23:52:08 <MatrixFrog> rather than a functional programming nerd, i guess
23:52:30 <mreh> like I said :)
23:52:51 <c_wraith> man, a quadrapole sounded cool :(
