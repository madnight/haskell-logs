00:14:01 <ivanm> preflex: seen Axman6
00:14:02 <preflex>  Axman6 was last seen on #haskell 7 hours, 33 minutes and 51 seconds ago, saying: depends on the implementation
00:20:47 <aavogt> hey ivanm, can SourceGraph be more informative when it can't parse the some file?
00:21:10 <ivanm> aavogt: it will be
00:21:45 <ivanm> a couple of versions ago, I massively re-did the parsing, etc. of how it converts each file into the call graph
00:22:00 <ivanm> now I have to work on the "front end": how to find files and read them
00:22:05 <ivanm> it's a fugly mess atm
00:22:22 * ivanm points out that SourceGraph was his first "real" Haskell program, and begs forgiveness
00:24:55 <Fallen_Demon> ivanm, I have no real Haskell program with my name next to it :(
00:25:05 <Fallen_Demon> Nor any program for that matter XD
00:25:44 <ivanm> go forth and write!
00:26:00 <c_wraith> go write in forth!
00:26:22 <ivanm> @slap c_wraith
00:26:22 * lambdabot pokes c_wraith in the eye
00:26:29 <shapr> sha! as if!
00:26:30 <c_wraith> hey.  I need those.
00:26:31 * ivanm points out that this is #haskell, not #forth
00:26:42 <ivanm> @get-shapr!!!
00:26:42 <lambdabot> Unknown command, try @list
00:26:44 <ivanm> @get-shapr
00:26:45 <lambdabot> shapr!!
00:26:49 <ivanm> there we are
00:26:58 <shapr> ivanm: You screamt?
00:26:58 * ivanm was obviously too enthusiastic
00:27:11 <ivanm> just saying "hi" ;-)
00:27:21 <shapr> hiya!
00:27:28 <shapr> I just had an adventure, it was fun!
00:27:40 <ivanm> what beith this adventure?
00:29:31 <shapr> Um, hanging out with a smart young thang.
00:29:51 <ivanm> "thang"?
00:30:00 <c_wraith> @wn thang
00:30:02 <lambdabot> No match for "thang".
00:30:28 <X-Scale> http://www.urbandictionary.com/define.php?term=thang
00:30:49 <shapr> exactly, definition 6 in fact.
00:30:59 * ivanm knows what the "slang" definition is
00:31:13 <shapr> What?
00:31:29 <ivanm> it's just that, I question whether this "smart young thang" would continue to "hang out" with shapr if he referred to her in that way
00:31:47 <shapr> She probably would, I'll ask her tomorrow.
00:49:04 * hackagebot rope 0.6 - Tools for manipulating fingertrees of bytestrings with optional annotations  http://hackage.haskell.org/package/rope-0.6 (EdwardKmett)
00:49:54 <Twey> Not Python?
00:50:17 <Botje> huh. when i wen to sleep, rope was at 0.3
00:50:22 <Twey> Haha
00:50:26 <Twey> Mornin', Rip
00:50:43 <Botje> scary :)
00:50:45 <Botje> hello
00:53:03 <edwardk> botje the api has been changing throughout the day =)
00:53:06 * hackagebot rope 0.6.1 - Tools for manipulating fingertrees of bytestrings with optional annotations  http://hackage.haskell.org/package/rope-0.6.1 (EdwardKmett)
00:53:23 <edwardk> and i've converted to following the PVP, so i need a minor version bump
00:54:56 <edwardk> Botje: i think the names work a lot better now. it is no longer 'A s (f a) -- they say things like (s `Branded` Rope) a
00:55:45 <edwardk> and it picked back up the monadwriter instance for Rope
00:55:50 <Botje> haven't looked at the package yet :)
00:55:56 <edwardk> er technically for Unsafe `Branded` Rope now
00:57:26 <Botje> i was just commenting on the development speed :)
00:57:26 <edwardk> but that lets you go through and build ropes out of the monadic actions. do pack "Hello"; pack ' '; pack "World"
00:57:41 <Botje> heh, cool
00:58:41 <edwardk> when i wake back up i'll go through and rip out the need for utf8-string. since it isn't really needed at all to do what i do there. i can get by with 20 lines of code and get better performance
01:14:48 <JoshTriplett> @pl \f m -> do a <- m ; f a ; return a
01:14:49 <lambdabot> (line 1, column 19):
01:14:49 <lambdabot> unexpected ";"
01:14:49 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
01:14:55 <JoshTriplett> @pl \f m -> do { a <- m ; f a ; return a }
01:14:55 <lambdabot> (line 1, column 12):
01:14:55 <lambdabot> unexpected "{"
01:14:55 <lambdabot> expecting variable, "(", operator or end of input
01:15:22 <JoshTriplett> OK, what have I done wrong there?
01:15:37 <kmc> :t \f m -> do { a <- m ; f a ; return a }
01:15:38 <lambdabot> forall (m :: * -> *) b a. (Monad m) => (b -> m a) -> m b -> m b
01:15:47 <kmc> pl is a bit defective
01:15:51 <JoshTriplett> OK. :)
01:15:52 <kmc> @. pl undo \f m -> do { a <- m ; f a ; return a }
01:15:52 <lambdabot> (=<<) . (`ap` return) . ((>>) .)
01:16:10 <Fallen_Demon> @slap Fallen_Demon
01:16:11 <lambdabot> Come on, let's all slap Fallen_Demon
01:16:17 <Fallen_Demon> @slap Fallen_Demon
01:16:18 * lambdabot will count to five...
01:16:24 <Fallen_Demon> @slap Fallen_Demon
01:16:25 * lambdabot karate-chops Fallen_Demon into two equally sized halves
01:16:31 <Fallen_Demon> That's cool XD
01:18:08 <JoshTriplett> kmc: So, have I missed an obvious combinator there?
01:18:20 <JoshTriplett> kmc: Because lambdabot's automated version doesn't really provide any great insight. ;)
01:22:07 <arcatan> JoshTriplett: @pl doesn't handle do, but you can write it open with undo
01:22:23 <JoshTriplett> arcatan: Yeah, kmc's example suggested that.
01:22:32 <JoshTriplett> Makes sense.
01:22:44 <Vitka> I take platform 2010 is not ready for Windows yet?
01:22:49 <JoshTriplett> @pl \f -> fmap (\a -> f a >> return a)
01:22:49 <lambdabot> fmap . (`ap` return) . ((>>) .)
01:22:59 <JoshTriplett> Yeah, still unhelpful...
01:23:12 <JoshTriplett> @pl \f -> liftM (\a -> f a >> return a)
01:23:12 <lambdabot> fmap . (`ap` return) . ((>>) .)
01:25:29 <arcatan> JoshTriplett: what are you trying to do?
01:26:25 <JoshTriplett> arcatan: Just noticed a common pattern of running some monadic action to get a result, wanting to return exactly that result, but needing to run a side-effecting monadic computation on that result first.
01:26:36 <kmc> @type \f -> uncurry (>>) . (f &&& return)
01:26:37 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (b -> m a) -> b -> m b
01:27:14 <JoshTriplett> kmc: Heh, yeah, I could always arrow it. :)
01:28:05 <kmc> @type \f m -> m >>= (uncurry (>>) . (f &&& return))
01:28:06 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (b -> m a) -> m b -> m b
01:36:07 <ksf> call for wiki pages: describe your haskell development environment.
01:41:41 <voker57> where?
01:42:15 <JoshTriplett> ksf: Vim, :set makeprg=cabal, :make build, errors show up like a standard :make allowing :cn and :cl.
01:42:45 <JoshTriplett> And I'll second the "where?".
01:42:53 <kevinulin> can someone explain to me (as if to a 5 year old) what the purpose of coarbitrary is of Arbitrary instances in quickcheck?
01:44:04 <kevinulin> from hackage.haskell.org it describes it as a function to generate a function from type a -> c
01:44:06 <ivanm> kevinulin: in QC 1?
01:44:13 <kevinulin> yes
01:44:15 <ivanm> I believe that's it's point: to generate functions
01:44:22 <ivanm> use QC-2; you don't have to worry about coarbitrary
01:44:26 <JoshTriplett> kevinulin: Arbitrary exists to generate random values of type a.  coarbitrary generates random values of type a -> b.
01:44:31 <JoshTriplett> And also, what ivanm said. :)
01:44:32 <ivanm> and QC-2 has finally replaced QC-1 in the platform! \o/
01:44:49 <kevinulin> oh ok ill just get out of QC1 then
01:45:12 <JoshTriplett> (You might still care about coarbitrary, but you no longer have to.)
01:45:23 <kevinulin> i finally got some quick check code to work testing RSA encryption and decryption, im quite proud of myself :)
01:45:31 <kevinulin> but i kept getting warnings about not defining coarbitrary
01:45:31 <JoshTriplett> (And with it in a separate typeclass, the type system can tell you if you actually need coarbitrary.)
01:45:33 <ivanm> JoshTriplett: yeah
01:45:40 <ivanm> preflex: seen Axman6
01:45:40 <preflex>  Axman6 was last seen on #haskell 9 hours, 5 minutes and 30 seconds ago, saying: depends on the implementation
01:45:54 <ksf> JoshTriplett, voker57, try http://www.haskell.org/haskellwiki/Development_Environment
01:46:06 <ksf> ...well, make subpages
01:46:24 <ksf> it's a wiki. feel free to produce wild growth, some gardener is going to come along.
01:46:37 <ologNation> kevinulin, Good job!
01:49:27 * JoshTriplett got HUnit to do exhaustive testing of arbitrary function values once.  Worked fine if your function arguments all consisted of Bool, Word8, and tuples.  Not so much for Word16, let alone Int. :)
01:54:35 <Fallen_Demon> @help
01:54:36 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
01:54:41 <Fallen_Demon> @help where
01:54:42 <lambdabot> where <key>. Return element associated with key
01:54:48 <Fallen_Demon> @where leskah
01:54:49 <lambdabot> I know nothing about leskah.
01:54:55 <ivanm> @where leksah
01:54:56 <lambdabot> I know nothing about leksah.
01:54:58 <ivanm> @hackage leksah
01:54:59 <lambdabot> http://hackage.haskell.org/package/leksah
01:55:18 <Fallen_Demon> Thanks :)
01:56:09 <Fallen_Demon> Oh, it's haskell backwards -_-
01:58:29 <ivanm> not quite
01:58:42 <Entroacceptor> no, it's haskell backwards, and stuff missing
01:58:47 <Alpounet> @where+ leksah http://www.leksah.org/
01:58:47 <lambdabot> It is stored.
01:59:00 <ivanm> > text . map head . group . reverse $ "haskell"
01:59:02 <lambdabot>   leksah
02:05:32 <sbahra> Anyone here use Fedora?
02:06:03 <ivazquez|laptop> I do, but I'm not well versed in Haskell.
02:06:23 <sbahra> ivazquez|laptop, how is package support for Haskell-related software? GHC? xmonad? etc...
02:06:25 <abbe> sbahra: w00t, from freebsd to arch to solaris to fedora ;)
02:06:28 <sbahra> ivazquez|laptop, it seems like it is terrible.
02:06:50 <sbahra> abbe, oh, this is for a netbook. Apparently, they claim to support GM500 well. Saves me time.
02:07:05 <ivazquez|laptop> It's... there. I'm not sure how you qualify package quality though.
02:07:24 <abbe> sbahra: https://fedoraproject.org/wiki/SIGs/Haskell might help.
02:07:26 <ivanm> sbahra: it's apparently got the platform
02:07:32 <ivanm> and there appear to be some people working on improving it
02:07:35 <ivanm> so *shrug*
02:07:38 <sbahra> abbe, ivanm: Thank you.
02:08:12 <sbahra> and thank you ivazquez|laptop.
02:08:30 <ivazquez|laptop> *shrug* Sure. Didn't do much though.
02:09:14 <sbahra> abbe, how's the Haskell FreeBSD project working out?
02:09:34 <abbe> sbahra: cabal2port is in progress :)
02:09:45 <sbahra> abbe, nice :D
02:09:59 <sbahra> abbe, someone was looking for you in your favorite IRC channel earlier.
02:10:00 <abbe> sbahra: but still lack of time, dezzy wrote a prototype :)
02:10:06 <abbe> sbahra: someone ?
02:10:08 <sbahra> abbe, in Haskell?
02:10:32 <sbahra> abbe, Cabal library is pretty decent when I looked at it last (for such things).
02:10:34 <abbe> sbahra: yep, everything in haskell, including from downloading cabal file/tarballs  to digest generation
02:10:44 <sbahra> abbe, cool. Can I see it?
02:12:04 <ivanm> sbahra: seeing as how Cabal is a library, it's thus easier to use it than to create some other parser in another language ;-)
02:16:33 <sbahra> ivanm, yes.
02:17:02 <sbahra> I was working on a similar tool before I stopped using FreeBSD on my laptop.
02:22:12 <Botje> @pl \x -> (x,f x)
02:22:12 <lambdabot> ap (,) f
02:25:42 * ivanm _thinks_ he has now completely defined all the HTML-like label types and functions for graphviz
02:25:48 <ivanm> now to add documentation :s
02:50:26 <ksf> sbahra, install cabal-install, cabal install xmonad. be aware that nuking your ~/.cabal means that you won't be able to reconfigure xmonad, _but_ you're fine to nuke your cabal and restart X if you were smart enough to put ~/.xmonad/xmonad-<arch>-<uname> in your .xsession
02:52:41 <ksf> if in doubt, use gentoo instead.
02:56:07 <sbahra> ksf, thank you, I'm fine. :-)
03:01:16 <tomoj> what is the recommended way to install haskell on ghc?
03:01:24 <ivanm> huh?
03:01:27 <tomoj> er, heh
03:01:29 <tomoj> on ubuntu I mean
03:01:30 <ivanm> ghc is a haskell compiler...
03:01:36 <tomoj> seems like karmic's ghc6 is old
03:01:43 <ivanm> tomoj: Cale does it using the generic binary
03:02:00 <ivanm> debian was working on packages for the last release of the platform...
03:02:02 <tomoj> ok, that's what I just installed
03:02:16 <ivanm> tomoj: http://davidsiegel.org/haskell-platform-in-karmic-koala/
03:02:17 <tomoj> there's an updated ubuntu package in lucid
03:02:20 <tomoj> but I dunno how to get it
03:02:25 <ivanm> note: old platform
03:02:29 <tomoj> yeah, saw that
03:02:31 <tomoj> wanted new platform
03:04:50 <ksf> tomoj, do a user install
03:05:47 <roelvandijk> Can anyone give me a pointer on how to delete spam from the haskell wiki?
03:05:57 <ksf> and probably forget about the platform.
03:06:05 <roelvandijk> I'm looking for a "revert change" button but can't find it.
03:06:06 <ksf> just get a ghc and bootstrap cabal-install, then go from there.
03:07:40 <ksf> you do it manually
03:08:02 <roelvandijk> ksf: You have to revert manually?
03:08:12 <ksf> yep
03:08:18 * roelvandijk wants to darcs revert my wiki page
03:08:49 <ksf> we should probably change the wiki to gitit.
03:09:06 <roelvandijk> Is there also some mechanism for reporting spammers?
03:09:45 <ksf> you'd have to ask an admin
03:10:02 <ksf> I see they re-enabled account creation, without bothering to include a captcha
03:10:13 <ksf> so banning wouldn't do much good, atm.
03:10:36 <roelvandijk> ksf: Ok, thanks for the info
03:12:36 * eevar2 wonders why every language community needs to create a self hosted web site / wiki
03:12:59 <ksf> because wikia is full of ads
03:14:03 <ksf> I guess haskell.org is big and open source enough to make a decent free-hosting deal with google, but then the appengine only supports python and jvm
03:14:07 <eevar2> by self hosted, i mean running on said platform/language/framework
03:14:24 <ksf> haskell.org doesn't.
03:14:32 <ksf> it's a mediawiki
03:14:36 <ksf> ...and trac.
03:14:41 <ksf> and apache, for the darcs stuff.
03:14:48 <medfly> eevar2, why not? it's not that big a deal
03:15:18 <medfly> it's just like every language channel on freenode needs to have something like lambdabot (of course less good) that is written in their language
03:15:19 <medfly> :p
03:15:27 <ksf> and making gitit ready for haskell.org would be a good thing to do (think "what links here" and other db-like features)
03:16:41 <ksf> we should probably spread the word that our web framework guys aren't even capable of hosting haskell.org, that'd have some nice effects on the maturity of their stuff.
03:17:16 <ksf> as in "no matter what language, web developers have the proficiency of php programmers"
03:17:18 * hackagebot base-unicode-symbols 0.1.3 - Unicode alternatives for common functions and operators  http://hackage.haskell.org/package/base-unicode-symbols-0.1.3 (RoelVanDijk)
03:18:18 <medfly> hahaha ouch
03:18:39 <Alpounet> ksf, haha
03:18:48 <Alpounet> but I agree that gitit would be neat though
03:19:02 <Alpounet> the export related features are great, for example
03:19:18 * hackagebot containers-unicode-symbols 0.2.0.1 - Unicode alternatives for common functions and operators  http://hackage.haskell.org/package/containers-unicode-symbols-0.2.0.1 (RoelVanDijk)
03:19:30 <ksf> I've recently had a discussion about gitit with an admin of the german pirate party.
03:19:40 <ksf> (who was cursing about db maintenance)
03:20:42 <ksf> and I have to agree that while a vcs is a great thing to store stuff in, dbs provide information that vcs don't, and that reflects on gitits feature set.
03:27:58 <Spockz|lap> is there a way to disable defaulting without disabling the monomorphism restriction?
03:28:51 <ksf> giving type signatures
03:29:07 <Spockz|lap> ksf: yes without giving type signatures
03:29:08 <ksf> ...things ultimately need to have a concrete type.
03:30:40 <Spockz|lap> ksf: but it's annoying to do that within a where
03:32:15 <HugoDaniel> hello
03:37:02 <anhsir> can a literal automatically be made a bytestring?
03:37:14 <Zao> anhsir: With OverloadedStrings, yes.
03:37:58 <anhsir> compiler flag?
03:38:37 <anhsir> looks like it.
03:38:39 <anhsir> Zao: thank you
03:38:48 <Botje> HugoDaniel: hi!
03:39:22 <chrisdone> Spockz|lap: you can do: foo where x :: 1; x = 1 (or use a new-line instead of ';')
03:39:26 <chrisdone> HugoDaniel: hi there
03:39:51 <Zao> http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#overloaded-strings
03:40:34 <HugoDaniel> they botje
03:40:38 <HugoDaniel> s/they/hey
03:40:41 <HugoDaniel> hey chrisdone :D
03:41:06 <chrisdone> HugoDaniel: I miss zurich
03:41:26 <Alpounet> it seems it has been quite fun
03:42:17 <chrisdone> Alpounet: indeed :)
03:45:42 <Botje> Spockz|lap: you can even do foo where bar = baz :: Fancy Type Here
03:47:08 <chrisdone> depends on the length of `baz', for readability `u_u
03:47:12 <arcatan> OMG. i have been programming Haskell for years now and only just figured out existential types.
03:47:26 <arcatan> I mean, shame on me.
03:47:30 <chrisdone> @google ghc manual extensions
03:47:32 <lambdabot> http://www.haskell.org/haskellwiki/GHC
03:47:32 <lambdabot> Title: GHC - HaskellWiki
03:47:47 <dobblego> many people use existential types in Java and don't ever know it
03:47:57 <chrisdone> dobblego: for what?
03:48:06 <arcatan> dobblego: how they map to Java?
03:48:14 <dobblego> for all the reasons you'd use existential types
03:48:24 <dobblego> arcatan, Java denotes forall a. a as <?>
03:48:37 <Alpounet> wildcards for generics
03:48:42 <Alpounet> there's a paper about them
03:49:13 <chrisdone> oh, I hadn't heard of wildcards. cool!
03:50:06 <chrisdone> http://java.sun.com/docs/books/tutorial/extra/generics/wildcards.html
03:57:19 <anhsir> what's the equivalent of "show" for bytestrings?
03:59:07 <Zao> show works, depending on what you intend it to do.
03:59:23 <Zao> If you want the look that show has on String, unpack to a String and show.
04:02:23 <Spockz|lap> does someone know why we are getting `2' as a result with this code? http://gist.github.com/342178
04:02:41 <anhsir> Zao: I have a Number, I want to convert that to a bytestring, to pass to a function that expects a bytestring.
04:04:09 <anhsir> Spockz|lap: because 1 + 1 = 2?
04:04:42 <dobblego> Spockz|lap, what else might you expect?
04:04:49 <Zao> anhsir: Note the RULES pragma.
04:04:51 <Spockz|lap> anhsir: yes, but because the 1 literals are ints it should use the intFoo function which is 1 - 1
04:04:54 <Zao> Which assumedly will do things.
04:05:22 <dobblego> Spockz|lap, I don't see anywhere that intFoo is used. It is defined but unused
04:05:36 <quicksilver> dobblego: note the RULES pragma
04:05:49 <dobblego> ok, I will note it, sorry :)
04:06:21 <Spockz|lap> dobblego: it should be used according to this: http://www.haskell.org/ghc/docs/latest/html/users_guide/rewrite-rules.html 7.14.4
04:06:28 <Zao> Spockz|lap: And you've got -fenable-rewrite-rules enabled?
04:06:53 <pheaver> hi.  i'd like to be able to use sequence on infinite lists and have the computation terminate.  obviously, this won't work out of the box: sequence (repeat (return 0)) >>= return . take 10.  is there a feasible way to get this to work, such as defining my own list-like data type and Data.Traversable instance?  i understand the question itself may be nonsensical; that is, it's nonsensical to expect 'sequence' to ever work on something
04:06:53 <pheaver> infinite
04:06:55 <Zao> And/or optimization?
04:06:58 <dobblego> Spockz|lap, my apologies, I overlooked that
04:07:31 <pheaver> (but i suspect that someone somewhere has already thought way ahead of me and come up with a solution)
04:07:54 <Zao> nvm, -O is there.
04:07:56 <Spockz|lap> Zao: no as you can see I didn't pass that argument, can I use it with a pragma?
04:08:07 <Zao> -O implies it, so you should be fine.
04:08:44 <pheaver> i guess it doesn't make sense because any computation in the list could depend on future computations, but i know that in my particular case that won't be true
04:09:35 <Zao> Spockz|lap: Throw -ddump-rules and -ddump-simpl-stats ?
04:09:41 <Zao> +at it.
04:09:57 <zygoloid> > sequence (repeat Nothing) -- pheaver
04:09:59 <lambdabot>   Nothing
04:10:45 <zygoloid> pheaver: for sequence to give a terminating computation on infinite lists, you basically need a monad which can bail out early.
04:10:54 <pheaver> zygoloid: ah, yes
04:12:16 <Spockz|lap> Zao: http://gist.github.com/342178 <<
04:12:22 <zhijie__> Hello, everyone. I hear about the haskell open source project from GSoC. I have great interest in this project because I'm curious about learning functional programming language. However, I've only limited experience about haskell. Will this deter my application?
04:12:48 <zygoloid> pheaver: another (icky) example: sequence (repeat $ do x@(_:_) <- getLine; putStrLn (reverse x))
04:12:48 <chrisdone> zhijie__: probably!
04:13:18 <zygoloid> throw in a `catch` and you have the world's nastiest not-necessarily-infinite loop :)
04:13:18 <pheaver> ah, very nice
04:13:35 <Zao> Spockz|lap: For some reason the rule is now foo/Integer.
04:13:41 <Zao> I don't know the implications, but it smells fishy.
04:13:55 <Spockz|lap> Zao: yes I changed that as I saw that it want's an integer
04:14:04 <pheaver> so, my situation is such that i have a function returning m [a] and later on someone will get that m [a] and know how much of it they want
04:14:22 <zygoloid> Spockz|lap: try putting a type signature on intFoo
04:14:28 <pheaver> so, what that user should do, is pass some context to the computation that will cause it to stop
04:14:30 <zhijie__> chrisdone: ok, the project wants the experience persons, correct?
04:14:33 <Zao> zygoloid: Argh.
04:14:40 <Spockz|lap> Zao, zygoloid: http://gist.github.com/342178 << updated
04:14:56 * hackagebot redis 0.4 - A driver for Redis key-value database  http://hackage.haskell.org/package/redis-0.4 (AlexanderBogdanov)
04:15:58 <FliPPeh_1> @hpaste
04:15:58 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
04:15:59 <Spockz|lap> zygoloid: doesn't work either?
04:16:06 <arcatan> Spockz|lap: you might need to {-# NOINLINE foo #-} to prevent foo from getting inlined which would prevent its rule from firing
04:16:31 <Spockz|lap> arcatan: that worked!!!
04:16:52 <arcatan> yay
04:17:11 <arcatan> my magical manual reading skills strike again
04:17:15 <chrisdone> zhijie__: well you've got to show diligence and that you can do it. if your application is a bit wishy washy...
04:17:20 <FliPPeh_1> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=8856#a8856
04:17:43 <FliPPeh_1> Doesnt my monadic return here actually create a function?
04:17:50 <zhijie__> chrisdone: got it, thanks!
04:18:10 <Spockz|lap> arcatan: we bow before your might :)
04:20:09 <Zao> Note that this wouldn't be a problem if you had followed the strong hint that the replacement function better do the same kind of thing as the replaced function.
04:21:31 <Spockz|lap> Zao: ofcourse, but that wasn't the purpose I wanted to check whether the rule was working
04:21:38 <Spockz|lap> +: somewhere
04:25:05 <ksf> pheaver, you could also do "m (Maybe a)" and have it return another value or nothing on each invokation.
04:25:17 <ksf> that is, do a state monad that holds the list.
04:25:30 <ksf> somewhat like the random monad.
04:26:07 <pheaver> ah, yeah i don't think that fits my application, but thanks
04:28:27 <dsouza> howdy!
04:28:53 <dsouza> is there a portable way to get the current timestamp (unix timestamp)?
04:29:01 <dsouza> System.Posix.Time.epochTime only works in posix systems, right?
04:30:44 <McManiaC> what gui lib would you use for windows? gtk?
04:32:11 <pheaver> dsouza: what about Data.Time.Clock.currentTime ?
04:32:45 <pheaver> though i suspect i misunderstood your question maybe
04:33:01 <quicksilver> Data.Time.* is the portable way, yes.
04:33:19 <quicksilver> Data.Time.Clock.POSIX has a couple of utilities for using unix epochs.
04:33:28 <quicksilver> or you can just subtract 1970/1/1 by hand
04:34:11 <dsouza> pheaver: I saw that function, but I didn't manage to transform UTCTime into an actual integral type or string type.
04:34:19 <pheaver> ah
04:34:39 <dsouza> pheaver: should I use formatTime?
04:34:52 <pheaver> yeah that'll get you to a string
04:36:18 <dsouza> I just sawy, formatTime using "%s" does what I want. THanks
04:36:28 <pheaver> oh, excellent
04:36:53 <quicksilver> dsouza: you can also convert UTCTime into an integral type but the question is 'how'?
04:37:00 <ivanm> McManiaC: maybe wxhaskell
04:37:01 <quicksilver> what conversion from date to integer did you have in mind?
04:38:17 <dsouza> quicksilver: actually the number of seconds since 1970/1/1 is what I'm looking for. But a string type works just fine as well. I really only need the seconds since epoch, so formatDate would work.
04:38:48 <McManiaC> ivanm: sounds interesting, thx
04:40:11 <quicksilver> dsouza: utcTimeToPOSIXSeconds :: UTCTime -> POSIXTime
04:40:19 <quicksilver> dsouza: gets you the number of seconds since the epoch.
04:40:39 <arcatan> quicksilver: how do you get, say, an Integer from POSIXTime?
04:40:52 <dsouza> @hoogle utcTimeToPOSIXSeconds
04:40:53 <lambdabot> Data.Time.Clock.POSIX utcTimeToPOSIXSeconds :: UTCTime -> POSIXTime
04:41:02 <dsouza> quicksilver: nice :-)
04:41:03 <quicksilver> arcatan: round
04:41:33 <arcatan> quicksilver: ah, thanks.
04:41:52 <dsouza> yeah, now the problem is POSIXTime -> Integer (or integral) :-)
04:42:06 <quicksilver> dsouza: round
04:42:13 <quicksilver> or floor.
04:43:16 <ivanm> if I have a constructor and a datatype (note: not the same datatype) with the same name, then if I use 'Foo' haddock will link to the datatype
04:43:23 <ivanm> is there any way of forcing it to use the constructor?
04:44:50 <dsouza> quicksilver: thx, that worked.
04:46:10 <quicksilver> Cale: are you still in charge of LB's config?
04:46:34 <ivanm> I believe he is
04:48:39 <CBro2007> I was asking a prof about Functional Programming and the choice of a first language for learning this paradigm
04:48:44 <CBro2007> his response: http://pastebin.ca/1851372
04:48:46 <CBro2007> :)
04:49:00 <CBro2007> is Haskell only good for small-scale programs?
04:49:10 <ManateeLazyCat> All google domain is failed, google.com, google.cn, google.com.hk, ruth.
04:49:15 <Jafet> !faq can haskell make small-scale programs?
04:49:17 <ManateeLazyCat> CBro2007: NO.
04:49:33 <Jafet> @vixen speak to me!
04:49:35 <lambdabot> i hate it when i get stuck with chatting with a bot!
04:49:37 <CBro2007> so you can have a haskell project with multiple files in it
04:49:41 <benmachine> CBro2007: darcs is not very small-scale
04:50:04 <CBro2007> I don't know anything about Haskel... so just a complete newbie :)
04:50:13 <chrisdone> CBro2007: for these questions you can just read one of the many resources on the web site http://haskell.org
04:50:20 <CBro2007> ok
04:50:26 <benmachine> xmonad is only 2669 lines but that's still definitely not small-scale
04:50:34 <benmachine> (eight files)
04:50:48 <benmachine> if you look at GHC itself that is absolutely huge
04:51:50 <benmachine> hundreds of files
04:52:19 <benmachine> hundreds of thousands of lines of code, at least
04:52:19 <CBro2007> ok
04:52:59 <CBro2007> Its just that he was of the opinion that it has a steeper learning curve than say SML
04:53:11 <CBro2007> so he teaches the FP course in SML
04:53:13 <benmachine> I've never learnt SML
04:53:15 <quicksilver> depends where you're starting from
04:53:18 <quicksilver> but yes, that's probably true
04:53:19 <CBro2007> but I really want to learn Haskell
04:53:30 <quicksilver> it's especially true if you have some experience with imperative languages.
04:53:35 <CBro2007> quicksilver: so its harder to learn Haskell than SML?
04:53:40 <quicksilver> no, I didn't say that.
04:53:43 <bremner_> well, Erlang certainly has large applications
04:53:47 <CBro2007> then?
04:53:57 <quicksilver> I said it's probably true that it has a steeper learning curve if you already have some experience with imperative languages.
04:54:01 <CBro2007> yeah I have done a lot of C/C++ Perl etc... so yeah thats my background
04:54:21 <quicksilver> steeper learning curve doesn't actually mean it's harder over all
04:54:21 <CBro2007> do you say that because you are stuck with a certain way of thinking?
04:54:34 <CBro2007> and then its harder to UNLEARN certain things and start from zero with haskell?
04:54:38 <quicksilver> yes.
04:54:45 <CBro2007> hmm k get you
04:54:49 <quicksilver> to some extent, for some people. Learning is a personal process after all.
04:55:26 <CBro2007> but you know what attracts you most to a language is when you start seeing instant results
04:55:36 <CBro2007> you know you try out some code and it works out
04:55:39 <CBro2007> :)
04:55:55 <CBro2007> gets you more involved and sucks you in
04:56:17 <CBro2007> oh and does SML and Haskell have any similarities?
04:56:37 <CBro2007> I mean will I find SML easy in comparison once I get the hang of Haskell basics?
04:57:26 <ivanm> methinks SML is dead
04:57:35 <ivanm> and that your prof has no idea what he's talking about
04:58:08 <dobblego> I strongly object to that method of teaching
04:58:11 <CBro2007> hmm he could be old school
04:58:12 <benmachine> I think SML and haskell probably share quite a few ideas
04:58:34 <CBro2007> dobblego: what do you mean/
04:58:35 <CBro2007> ?
04:58:48 <CBro2007> dobblego: you mean choosing a language for assignments in FP?
04:59:16 <dobblego> CBro2007, teaching what is apparently "less learning curve" to "make it easier" ultimately results in a massive disservice to the educational pursuit
04:59:36 <dobblego> CBro2007, and specifically in the case of programming and some of the deeper ideas
05:00:08 <CBro2007> so you believe that SML falls short in many places that Haskell kicks ass?
05:00:17 <dobblego> Harden up and learn the hard stuff or don't bother. Anything in between will not give you a result that is in between.
05:00:49 <Jafet> *cough 6.001 cough*
05:00:50 <dobblego> CBro2007, in terms of teaching yes, but that's not the point. Clearly your teacher believes that and it is this that I object to
05:01:08 <CBro2007> qsort (x:xs) = qsort (http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:filter (< x) xs) http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:. [x] http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:. qsort (http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:filter (http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:&gt;= x
05:01:16 <CBro2007> fark sorry
05:01:27 <CBro2007> but that line of code for quicksort looked wicked! :)
05:01:39 <CBro2007> I mean done in a single line... looks real neat
05:01:49 <dobblego> I think you mean without the URLs right?
05:02:02 <Jafet> Quicksort is wicked, but mergesort saves the day
05:02:47 <rajeshsr> Jafet, well, quicksort is more practical! It has a good average behavior, after randomizing it!
05:03:13 <Jafet> But he has to get to the chapter on monads first before he can randomize anything
05:03:29 <CBro2007> yeah sorry the URLS just somehow got copied in too
05:03:58 <CBro2007> ah no I was just looking at the introduction on the wiki
05:04:02 <Cale> mergesort is much much more practical on lists
05:04:11 <CBro2007> and it was comparing how qsort worked in C vs in Haskell
05:04:21 <ivanm> and that isn't the real quicksort anyway
05:04:25 <Cale> (and as a bonus doesn't rely on average case behaviour)
05:04:31 <Cale> Nah, it's a real quicksort
05:04:34 <ivanm> (hoare's original paper used what we nowadays refer to as "in-place quicksort")
05:04:36 <Cale> It's just not in-place.
05:04:50 <ivanm> Cale: I've had this argument with someone before; the original paper stressed the in-place nature
05:04:57 <ivanm> (I lost the argument :( )
05:05:01 <Jafet> For which value of "in-place"
05:05:04 <quicksilver> rajeshsr: quicksort is not practical on lists, in haskell.
05:05:09 <ivanm> Jafet: mutation
05:05:26 <ivanm> quicksilver: it's not practical for normal arrays either ;-)
05:05:28 <Jafet> Can't do that with lists, so thanks for the tautology
05:05:48 <rajeshsr> quicksilver, why? how is the complexity changed here?
05:06:18 <rajeshsr> even if it is a linked list, isn't it O(nlgn) again?
05:06:21 <quicksilver> rajeshsr: list access is O(n) not O(1)
05:06:31 <ivanm> rajeshsr: too much of quicksort is dependent upon picking a good pivot
05:06:37 <quicksilver> rajeshsr: so pivot choice is very expensive
05:06:38 <rajeshsr> T(n) = 2*T(n/2) + O(2*n)
05:06:49 <rajeshsr> i mean in the best case..
05:06:52 <ivanm> pick the wrong pivot, and you lose any advantage quicksort might have
05:07:00 <rajeshsr> right!
05:07:06 <quicksilver> in the best case, you use null sort.
05:07:08 <quicksilver> sort x = x
05:07:08 <ivanm> besides, the quicksort O(n log n) is amortised/average case, isn't it?
05:07:17 <quicksilver> # best case behaviour is O(1), list is already sorted.
05:07:18 <rajeshsr> but you won't be so unlucky to pick the pivot wrong at all times
05:07:18 <Cale> yeah
05:07:26 <rajeshsr> particularly after randomizing!
05:07:30 <Cale> There's a security concern though.
05:07:54 <benmachine> someone can pick a list of worst-case pivots and feed that to you?
05:08:00 <rajeshsr> quicksilver, nope! O(n) in that case
05:08:12 <Cale> If you use a predictable quicksort of any kind, then someone malicious can decide to give your program inputs that will trigger the worst-case behaviour.
05:08:27 <ivanm> quicksilver: you have to check that it's sorted, do you not?
05:08:35 <quicksilver> ivanm: I was making a stupid point.
05:08:38 <ivanm> ahhhh
05:08:42 <quicksilver> ivanm: since rajeshsr wished to talk about 'best case'
05:08:47 <benmachine> ivanm: no, just assert that it is and sometimes be right :P
05:08:48 <Cale> Quicksort is worst-case O(n^2)
05:08:51 * ivanm -> sleeeeep
05:08:59 <quicksilver> ivanm: I gave an example where in the best case it's O(1) and in the wrong case it's, well, wrong.
05:09:01 <ivanm> benmachine: heh
05:09:06 <ivanm> quicksilver: right
05:09:07 <Cale> (regardless of whether it's in-place or not)
05:09:16 <rajeshsr> BTW, merge sort requires auxiliary memory, in order to merge
05:09:44 <quicksilver> rajeshsr: so does the naive haskell quicksort being discussed
05:09:45 <Cale> rajeshsr: So does quicksort.
05:09:49 <quicksilver> it's not really quicksort at all
05:09:51 <quicksilver> it's misnamed
05:09:56 <Cale> It *is* really quicksort.
05:09:59 <quicksilver> ;)
05:10:02 <Cale> It's just not in-place.
05:10:08 <quicksilver> well that's definitional point.
05:10:12 <rajeshsr> well, what is the problem in haskell's quicksort?
05:10:25 <rajeshsr> Cale, oh, yeah! filter will generate a new list!
05:10:28 <quicksilver> To me, it will always be the case that the *clever* part of quicksort is the inplace swap.
05:10:38 <Cale> rajeshsr: Yeah, it's not necessarily in memory all at once.
05:10:40 <Jafet> A twisty little maze of quicksorts
05:10:41 <quicksilver> that's what makes it a clever, and efficient, sort algorithm.
05:10:57 <quicksilver> the haskell way - copying everything log n times - is not really the same algorithm at all.
05:10:57 <Cale> rajeshsr: But the (++) will ensure that the list being created is a new one.
05:11:10 <Cale> rajeshsr: Well, you *must* be creating a new list
05:11:17 <rajeshsr> BTW, how does an inplace qsort algorithm looks in haskell?
05:11:32 <rajeshsr> is it even possible?!
05:11:33 <Cale> Because in general it can't share any structure with the original list.
05:11:40 <Cale> rajeshsr: It looks like the imperative one.
05:11:51 <Cale> rajeshsr: You would use mutable arrays for that.
05:12:00 <companion_cube> rajeshsr: I think the ST monad can do this efficiently
05:12:04 <rajeshsr> hmm, ok!
05:12:38 <benmachine> world's finest imperative etc. etc.
05:12:40 <Cale> But mergesort is efficient enough on lists, and has some added bonuses.
05:13:04 <Cale> For one, if you take the head of the resulting sorted list, that can be done in O(n) time.
05:13:10 <Cale> (To get the minimum)
05:14:25 <Cale> and more generally, I believe you get the first k elements in O(n log k) time.
05:15:07 <Cale> This being due to lazy evaluation -- the sort algorithm doesn't have to actually finish sorting the list if you don't demand all the elements.
05:16:40 <Jafet> Well, a balanced quick^Wtop-down partitioning sort does that as well
05:20:03 <Cale> I suppose the average-case behaviour would work out that way.
05:28:39 <quicksilver> Cale: why is the Data.Time.* stuff visible to @type and not to @run?
05:29:13 <benmachine> @type System.IO.Unsafe.unsafePerformIO
05:29:14 <lambdabot> forall a. IO a -> a
05:29:46 <benmachine> I guess everything is available to @type but @run has a whitelist and things need to be added to it
05:29:58 <Cale> That's right
05:30:28 <Cale> Probably there's no import of the Data.Time stuff in L.hs
05:31:26 * hackagebot data-flags 0.0.3 - A package for working with bit masks and flags in general.  http://hackage.haskell.org/package/data-flags-0.0.3 (MikhailVorozhtsov)
05:41:38 <rajeshsr> Cale, in merge sort, finding kth element even with laziness is not O(nlgK) what if the last K elements are in the second part of the array, in some permuted order. We won't know until we sort completely!
05:42:58 <benmachine> do you mean the first k elements of the sorted list
05:43:52 <Cale> rajeshsr: hm?
05:44:44 <rajeshsr> Cale, that is what i think! Finding kth element can be achieved in O(nlgK) with max-heap
05:45:35 <Jafet> Running complexity of k-selection with heapsort, mergesort and quicksort are asymptotically the same
05:45:47 <rajeshsr> may be i missed something, with merge sort. But I don't think it can be used as such, to achieve O(nlgK)
05:45:58 <Cale> rajeshsr: If you're only looking for the first k elements, you end up skipping over the better part of some or most of the merges.
05:46:02 <rajeshsr> Jafet, right! But the idea of using heap here is totally different..
05:46:12 <rajeshsr> not heap sort
05:46:26 <Cale> rajeshsr: Remember that each merge that you perform is computed lazily.
05:46:36 <Jafet> If you set k = n, you've invented heapsort
05:46:40 * hackagebot MonadCatchIO-transformers 0.1.0.1 - Monad-transformer compatible version of the Control.Exception module  http://hackage.haskell.org/package/MonadCatchIO-transformers-0.1.0.1 (AriePeterson)
05:47:02 <Cale> rajeshsr: So no computation takes place until you want the first element of the merge, at which point only enough computation happens to decide what that one element is.
05:47:17 <Jafet> No wait, that was wrong
05:47:24 <rajeshsr> Jafet, yeah! :) But the modification to O(nlgK) is quite different. if n >> K, then you don't need all n to be stored at all, just O(K) memory
05:47:57 <rajeshsr> Cale, interesting! Let me think about it!
05:48:13 <rajeshsr> I hve always thought about how laziness can reduce the complexity
05:48:47 <Jafet> Reduction is sort of the wrong word
05:49:09 <Jafet> The meaning of complexity changes in Haskell
05:49:56 <rajeshsr> when i first learnt hakell, i thought like, calculating fibonacci numbers with just recurrence itself is done in O(n) with laziness and referential transparency! And later i found it was wrong!
05:50:12 <rajeshsr> Cale, now i see a good example! Let me code and analyze!
05:51:20 <rajeshsr> Cale, anyway am still unconvinced after all! :)
05:51:27 <int-e> (!! k) . sort should be O(n + k log n) (starting with a fully evaluated list, assuming constant time comparisons, and resulting in a single value from the list)
05:52:15 <EvanR> is it easy to set up a lazy i/o, like, streaming a large mp3 file or movie
05:52:25 <EvanR> i know hGetContents, but is that it?
05:52:33 <benmachine> EvanR: yes, and easy for it to go wrong later >_>
05:52:45 <Jafet> Nobody really knows hGetContents
05:52:56 <benmachine> unsafeInterleaveIO is the magic behind all lazy IO
05:53:08 <EvanR> :\
05:53:22 <benmachine> it makes an IO action finish executing immediately and then only perform the IO when the result is demanded
05:53:35 <kalven> @hoogle Eq a => a -> a -> [a] -> [a]
05:53:36 <lambdabot> Network.CGI.Protocol replace :: Eq a => a -> a -> [a] -> [a]
05:53:36 <lambdabot> Prelude enumFromThenTo :: Enum a => a -> a -> a -> [a]
05:53:36 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
05:53:36 <benmachine> you can use it to implement things like hGetContents
05:53:55 <benmachine> but the way it deals with exceptions can be unpleasant
05:54:03 <benmachine> so I tend to look for other ways of deferring IO
05:54:09 <EvanR> like what
05:54:11 <benmachine> I believe iteratees are one such, but I've never used them
05:55:08 <Cale> int-e: Oh! Yeah, that looks better.
05:56:03 <Jafet> n log k or k log n?
05:56:09 <Jafet> Now I'm dizzy
05:56:13 <Cale> er, hmm.
05:56:14 <EvanR> benmachine: semantically it seems like a file on disk could be considered a list of bytes, the fact that its on disk rather than memory really makes that much of a difference? :(
05:56:24 <Cale> Let's see...
05:56:29 <int-e> k log n. k extract-min operations on the heap.
05:56:40 <int-e> (which sort implicitely constructs)
05:56:41 <Jafet> EvanR, rm file
05:56:45 <benmachine> EvanR: yeah because if it's in memory you "own" that memory, it's not going to do anything funny
05:56:55 <benmachine> if it's on disk someone can come along and change it without notifying you
05:57:00 <flux> hey what if someone removes the memory chip ;)
05:57:07 <Jafet> EvanR, or better, ./prog >> file
05:57:11 <EvanR> memory mapping?
05:57:25 <benmachine> there are mmap hooks in haskell
05:57:31 <benmachine> I think they have unsafe in the name though :P
05:57:33 <flux> gdb ./prog `pidof prog`; -- insert memory poking here
05:57:37 <benmachine> @hoogle mmap
05:57:37 <lambdabot> No results found
05:57:43 <benmachine> @hoogle MMap
05:57:43 <lambdabot> No results found
05:57:48 <Jafet> unsafeAttachDebugger
05:57:50 <Cale> In 6.12, I think there's a Handle-based interface to mmap
05:57:54 <benmachine> flux: yeah but you're asking for it then
05:58:39 <EvanR> hmm.
05:58:49 <EvanR> so IO must be handled by IO ...
05:58:50 <flux> actually I think unsafeInterlaveIO is decent if you encode the chance of failure into the value as well
05:58:55 <flux> but it's not as convenient anymore then
05:59:27 <benmachine> @hackage bytestring-mmap
05:59:27 <lambdabot> http://hackage.haskell.org/package/bytestring-mmap
05:59:32 <Cale> (Well, I heard about it anyway, I'm not sure where it's located)
06:00:39 <EvanR> so its much more convenient in haskell to read the whole file at once to form some decoded value and just use that
06:01:30 <benmachine> it's always much more convenient to do that >_>
06:01:44 <benmachine> well, maybe not *much* more
06:02:19 <EvanR> right
06:03:22 <EvanR> thinking of programs, i cant seem to get away from having huge portions of the code in IO
06:03:50 <ksf> application/octet-stream is just weak typing.
06:04:50 <ksf> mmap on any unix I know is particularily evil.
06:05:19 <ksf> even if you listen to write events, referential transparency is broken due to race conditions.
06:05:46 <EvanR> somehow i didnt think mmapping the file would solve anything
06:06:04 <ksf> copy on write is the right operation semantics, here.
06:06:06 <p_l> ksf: I think you're falling into trap of academia regarding OS and I/O
06:06:29 <p_l> ksf: so, why not setup COW mapping with mmap()?
06:06:41 <p_l> it is, after all, left as a portable interface to pagetable
06:06:45 <ksf> dunno. ask linus.
06:07:24 <p_l> ksf: sure, Linux's VM subsystem is broken, but not in that part. It's broken in MAP_RESERVE/MAP_NORESERVE
06:07:47 <FliPPeh__> Man, record syntax confuses me. Something like "State a b = State { runState :: a -> (b, a) }" would be equivalent to "State a b = State (a -> (b, a))", a datatype that holds just one field which is a function, right?
06:08:02 <ksf> right
06:08:05 <p_l> I seriously wonder when realtime guys and Lisp coders will reach critical mass and just rewrite that damned "not-bug"
06:08:45 <FliPPeh__> So creating "create r = State (\s -> (r, s))" will fully qualify that type?
06:08:47 <ksf> the next os to reach critical mass will start out as a userspace environment.
06:09:17 <ksf> at which point it will do GNU a favour and call its kernel "hurd"
06:09:37 <ksf> ...BSD licensed, of course >;)
06:09:40 <p_l> ksf: I somehow doubt anyone would want to associate itself with that abortion
06:10:11 <p_l> though, maybe you - you mentioned at least one interface yesterday that mapped to Hurd's broken I/O model
06:10:48 <ksf> I don't know a thing about hurd except that it's a microkernel and behind schedule.
06:11:10 <ksf> ...and 9p isn't broken.
06:11:20 <p_l> ksf: it also uses the microkernel that is well known for being bigger and slower than big monolithic kernels
06:11:50 <idnar> I thought they were using L4 now
06:12:17 <ksf> my brain is actually toying with the idea of porting 9p to inside haskell, to export and access capabilities of individual worker threads.
06:12:19 <p_l> ksf: I meant "opening the same file as both file and directory". It can be done (that's what UNIX actually did) but it didn't work exactly that way. And Plan9 IMHO did it right.
06:12:58 <ksf> ...the interface, that is, not the wire protocol. but providing an interface to your program would then be as easy as plumbing in a server process that serves a 9p fs...
06:13:00 <p_l> except that UNIX's greatest strength actually came from untyped files, when everyone around used typed files
06:13:17 <p_l> (and believe me, typed filesystem can be a bitch)
06:13:31 <Jafet> instance Sequence File ...
06:13:49 * p_l has a database that is stored in a set of typed files
06:13:50 <ksf> pascal uses typed files.
06:14:13 <arw> userspace typed files are different from OS typed files.
06:14:24 <p_l> ksf: pascal came from the time when "file" meant "a stack of punched cards"
06:14:29 <arw> in userspace, typed file implementations are very common today.
06:14:33 <ksf> if it would use a bit more structure and not just serialize binary records, it would be useable.
06:15:25 <Jafet> Make sure to derail your opponent's argument using HFS+ attributes.
06:15:35 <ksf> ...the files wouldn't be typed by the OS, that is, the OS wouldn't enforce anything to be typed beyond [Word8]
06:15:41 <p_l> I don't have anything against having a sensible, portable format and description language (like a variant of EBML, or something like what VMS uses)
06:15:56 <p_l> which would be available as a library/service in userspace
06:17:09 <ksf> so, you'd have Foo.hs/raw (which is ascii text) and Foo.hs/AST (which is a hs-source-exts AST)
06:17:32 <arw> there are tons of such formats. xml, berkeley db, sqlite, various things based on asn.1...
06:17:41 <ksf> admittedly, using / for both directories and such virtual stuff is a bad idea.
06:17:59 <ksf> iirc the URI rfc advocates ; for such stuff.
06:18:15 <applicative> FliPPeh__: isn't State a b the same as a -> (b,a)  It's just that `runstate` unwraps one so you can use it like an a -> (b,a)
06:18:48 <ksf> segment       = *pchar *( ";" param )
06:19:27 <p_l> I'd rather have (with-open-typed-file typed-file (#P"SYS:TMP;Foo.hs.newest" (make-typed-file #P"SYS:Templates;haskell;ast.tmpl")) ... ) ;-)
06:19:57 <ehamberg> what is the recommended way of including haskell code in a tex document and have it change "->" into proper arrows, "\" into lambdas and so on?
06:20:27 <ksf> ehamberg, http://people.cs.uu.nl/andres/lhs2tex/
06:20:33 <applicative> ehamberg is lhs2latex
06:20:35 <applicative> ah
06:20:52 <applicative> The latex it turns out it pretty wild....
06:21:37 <ksf>  /kern/top;sort=cpu,vmem
06:21:45 <ehamberg> even if i only want to include a few lines of haskell in a long report?
06:22:09 <Jafet> perl -p
06:22:19 <trzkril> @pl \a b -> not $ f a b
06:22:19 <lambdabot> (not .) . f
06:22:34 <applicative> It will be fine for that, won't it.  I just have a little experience.  It's just that the code environment is subjected to a suprising amount of shaking and baking...
06:22:36 <p_l> ksf: that just broke whatever good stuff unix came up with
06:23:30 <p_l> ksf: instead of composability, file;sort=arg1,arg2,... is just Yet Another Magic Syntax/Feature
06:23:33 <arw> ksf: sort -f 4 /proc/whatever...
06:24:06 <arw> ksf: difference is, there is a tool instead of a magic filesystem function.
06:24:12 <ksf> that's actually more the equivalent of sort cpu vmem < /kern/top
06:24:32 <ksf> well, it _is_ the equivalent.
06:24:38 <ksf> just a different interface.
06:24:43 <p_l> much worse interface, though
06:24:59 <arw> its not a different interface, its a completely different approach.
06:25:02 <ksf>  /kern/top;sort=cpu,vmem;grep=foobar
06:25:13 <p_l> ... yack, deculture
06:25:21 <ksf> that's an fs-based interface, not a sh interface.
06:25:31 <applicative> ehamberg, the docs linked above go through all the different preferences you can establish.   If you have cabal install installed its just `cabal install lhs2tx`
06:25:36 <zygoloid> didn't some wifemurderer come up with something like that? </ad hominem> ;-)
06:25:40 <arw> the 'sort' is a process in userspace, the filesystem is an operating system interface.
06:25:52 <applicative> or rather `cabal install lhs2tex`
06:26:03 <arw> if i do a complex sort in userspace, my user account will be billed. if i do it in the operating system, well...
06:26:10 <sockdrawer> give me all your socks now!
06:26:13 <ksf> where ;<foo> means "mount previous file with file server foo"
06:26:17 <p_l> ksf: cat /kern/top | sort cpu vmem | grep foobar isn't an "sh" interface. It is actually an element of OS functionality -- the composing of tool programs
06:26:29 <ksf> arw, the file system is _not_ a kernel level thing.
06:26:34 <ksf> the disk store is.
06:26:40 <sockdrawer> you give me all your socks or I'll make the set of all sets!
06:26:50 <ehamberg> applicative: reading it now. thanks.
06:26:55 * p_l never, ever, thought that he would have to advocate composing functions in #haskell
06:26:56 <ksf> I just want to ditch those pipes and make them mounts.
06:27:14 <ksf> so you compose file systems, instead of processes.
06:27:20 <arw> ksf: depends on which model of operating systems you prefer. in most non-microkernel systems, the filesystem is in kernel.
06:27:21 <SamB_XP> ksf: are you talking about plan9?
06:27:27 <fax> sockdrawer something to do with axiom of choice?
06:27:30 <p_l> ksf: that's easy to do with pipes.
06:27:31 <baaba> ksf: what's fuse then?
06:27:37 <SamB_XP> in MS too, the filesystem is generally in kernel but not always
06:27:39 <baaba> http://fuse.sourceforge.net/
06:27:45 <benmachine> fax: more to do with a logical paradox
06:27:46 <ksf> fuse is kernel-level, mostly.
06:27:58 <benmachine> I think it's russel's paradox but I can't quite remember
06:27:58 <ksf> linux doesn't allow non-kernel stuff to mount anything.
06:28:08 <sockdrawer> bertrand russel is rolling over in his grave
06:28:29 <ksf> and yes, I'm talking about 9p.
06:28:35 <ksf> er plan9
06:28:36 <baaba> ah okay
06:28:56 <zygoloid> user-mounted filesystems have huge security issues. systems like gnu hurd are /really/ careful about this stuff.
06:29:02 <ksf> plan9 does pipes by firing up a 9p server which serves two files, data1 and data2, copying everything over.
06:29:03 <ddarius> There's nothing wrong with the set of all sets.
06:29:13 <benmachine> yeah, it's not exactly russel's paradox but it's the sort of reasoning that allows russel's paradox to exist
06:29:13 <applicative> ehamberg, it sounds like you already have your document ready. but it might be worth noticing that pandoc has an assortment of literate haskell appendages.   from pandoc --help:   Input formats:  native, markdown, markdown+lhs, rst, rst+lhs, html, latex, latex+lhs         Output formats:  native, html, html+lhs, s5, docbook, opendocument, odt, latex, latex+lhs, context, texinfo, man, markdown, markdown+lhs, plain, rst, rst+lh
06:29:14 <ksf> the nice thing is that makes pipes automatically network transparent.
06:29:22 <sockdrawer> which do not contain themselves
06:29:27 <sockdrawer> I forgot that
06:29:28 <sockdrawer> shit
06:29:30 <zygoloid> ddarius: is the problem subset selection then?
06:29:30 <ksf> zygoloid, in what sense?
06:29:30 <benmachine> heh
06:29:45 <ksf> the user must have write access to the mount point, of course.
06:29:58 <p_l> ksf: watch -t "cat /kern/top | sort cpu vmem | grep foobar" | csv-filesystem - /n/sorted\&greped\ top
06:30:05 <dankna> sockdrawer ran out of stack while trying to construct the set of all sets.  his evil plan was foiled!
06:30:21 <zygoloid> ksf: if i have complete control over a mounted filesystem, something needs to prevent me from creating setuid binaries.
06:30:22 <ksf> p_l, and now try to export that over the net.
06:30:36 <ksf> setuid is a broken idea.
06:30:47 <ksf> (which plan9 doesn't include)
06:30:51 <sockdrawer> I am uneasy about ghc's new code generating backend
06:30:56 <benmachine> everything is always broken
06:30:58 <p_l> zygoloid: then use non-standard security layer
06:31:13 <arw> there are more problems, if you have control over a mounted filesystem, you can create a denial of service situation by handling your syscalls slowly.
06:31:16 <ksf> zygoloid, http://swtch.com/plan9port/man/man4/factotum.html
06:31:16 <sockdrawer> the llvm
06:31:19 <zygoloid> p_l: it's not insolvable. all i said was that you have to be careful.
06:31:23 <p_l> like TOMOYO (please use 1.x line, not 2.x lobotomized one)
06:31:44 <sockdrawer> why let c++ creep into such a nice project
06:31:47 <zygoloid> the 'nice' solution is to get the filesystem itself to execute binaries contained within it.
06:31:54 <ksf> anyway, the kernel would be insane to allow setuid to anything but the user who runs the filesystem process.
06:32:29 <ehamberg> applicative: right. my document will not itself be a lhs file. if i'm going to use lhs2tex it will probably just be as a filter for haskell code whose output I will then put in my tex file. how exactly would pandoc help?
06:32:32 <sockdrawer> why aren't people outraged
06:32:37 <p_l> ksf: watch -t "cat /kern/top | sort cpu vmem | grep foobar" | csv-filesystem -l - /srv/foobar-from-top & sleep 1; export /srv/foobar-from-top
06:32:48 <zygoloid> sockdrawer: lots of people don't have an irrational hatred of c++
06:33:08 <benmachine> zygoloid: that sentence could be interpreted in two ways :P
06:33:10 <ksf> p_l, and you want to do that for every possible command?
06:33:11 <sockdrawer> no hatred, just plain is a bad strategy for the future
06:33:12 <applicative> it won't be of use for this, but if you are writing lhs a lot, it is of use.
06:33:26 <p_l> ksf: this was done purely through application and composition of functions, instead of "magic"
06:33:29 <ehamberg> right. ok. :)
06:33:32 <sockdrawer> too much complexity
06:33:40 <p_l> ksf: "magic" is something for Rails newbies ;-)
06:33:50 <ksf> filesystems are functions, too.
06:33:56 <ksf> well more like DFAs
06:34:08 <sockdrawer> still most c++ compilers don't adhere to its collosal standard
06:34:09 <applicative> what you are wanting from lhs2tex is the machinery that turns regular monospace haskell into something more mathematized, pandoc has nothing to do with that, which is a typesetting process.
06:34:11 <p_l> ksf: and 99% of people won't use such functionality, those who need it know how to write a script
06:34:13 <zygoloid> sockdrawer: fundamentally, unless you're hacking on llvm, what it's implemented in should not be your concern.
06:34:17 <ksf> ...which get their initial input from somewhere.
06:34:49 <sockdrawer> zygoloid: agreed, to a degree. I don't mind that my house is built on sand as long as there's no earthquakes
06:34:53 <ehamberg> applicative: yes. exactly. :)
06:35:02 <ksf> p_l, and what if I implement your pipes with my mounts, in a general way?
06:35:10 <quicksilver> sockdrawer: there's no suggestion that llvm will ever become the default backend, let alone the only backend, that I've seen
06:35:12 <p_l> ksf: not to mention that lacking proper course in Unix tool-piping, you can miss such nice stuff like equivalents of map/reduce
06:35:25 <sockdrawer> I think it's a warning
06:35:26 <zygoloid> sockdrawer: well, that's your answer then. people aren't outraged because it doesn't matter.
06:35:27 <ksf> xargs.
06:35:30 <ksf> don't miss it.
06:35:39 <sockdrawer> people had better start working on code generation in haskell
06:35:40 <p_l> ksf: if you do that without introducing magic characters, syntaxes etc., I'm all for it.
06:35:59 <sockdrawer> that is as good as the one llvm supplies
06:36:01 <ksf> I'm not concerned about the shell syntax, but the plumbing.
06:36:17 <Alpounet> sockdrawer, it's more about the optimization passes that are part of LLVM
06:36:22 <Alpounet> and worked on by much more people
06:36:23 <applicative> i mentioned pandoc only for the future, it has a lot of nice utility in this connection, you can write lhs in markdown, say, for a blog, and convert to tex, etc etx, --  but it doesn't do the rustic monotype -> quasi-mathematical conversion
06:36:29 <Alpounet> than GHC's proper backends
06:36:50 <sockdrawer> it's also about portability
06:37:06 <zygoloid> llvm is pretty portable from what i understand.
06:37:08 <Alpounet> yes
06:37:18 <ksf> p_l, see it would be an easy task to write a shell that sends HTTP REST requests to a server serving my /kern
06:37:52 <ehamberg> applicative: that is indeed cool. i use gitit, so i sort of know pandoc through gitit's export feature -- which is very cool. :)
06:38:37 <sockdrawer> maybe c++ is rock solid, but I certainly don't feel it is.
06:39:08 <ksf> there's pople masochistic enough to coerce c++ to be useable, yes.
06:39:11 <p_l> sockdrawer: then what about: # csv-fs -l -s $(grep-fs -s foobar $(sort-fs -f cpu,vmem -f /kern/top))?
06:39:27 <p_l> s/sockdrawer/ksf/g
06:39:37 <zygoloid> sockdrawer: as already stated, that's irrelevant. all that matters is that llvm is solid.
06:40:11 <p_l> ksf: that example tried to keep itself possible to implement without much changes on Plan9
06:40:19 <zygoloid> (and i'm being generous in assuming it even makes sense to talk about the solidity of a language, rather than an implementation or a program built with said implementation)
06:40:38 <p_l> ksf: mind you, Powershell would be better at such composition, mainly because of typed pipes
06:40:46 <sockdrawer> I'll just pretend it was written in anything else and not think about it anymoer
06:40:47 <SamB_XP> hehehehe
06:41:03 <p_l> ksf: (the problem is that you can't really use them outside Powershell...)
06:41:11 <ksf> ...and typed files means you can have typed inputs to the file servers. err pipes.
06:42:21 <p_l> unless you implement a sideband channel with standard interface... that could be used, for example, to pass type information without breaking functionality of [Word8] stream
06:42:22 <applicative> ehamberg: yes, gitit is an example of all the difficulties you can run into, so it has everything figured out:  e.g. in a blog you don't want the html source to be lhs, you want what people cut and paste to be lhs, and so on.
06:42:52 <ksf>  /kern/top;type
06:43:03 <p_l> ... not the blasted semicolon again
06:43:15 <SamB_XP> p_l: did you see PowerShellPoint?
06:43:17 <ksf> I'm just using uri syntax
06:43:29 <ksf> don't read it as a shell command.
06:43:59 <ksf> the shell command would be mount -t type /kern/top /tmp/<whatever>
06:44:01 <p_l> ksf: I tend to use paths that have ; as directory separator. When they don't have dots as such
06:44:05 <zygoloid> sockdrawer: if it makes a difference to you, feel free. i'm not going to worry that my delicious steak is made of grass, which was grown in manure.
06:44:46 <sockdrawer> nice analogy, it doesn't work that well in all occasions
06:45:00 <SamB_XP> zygoloid: nevermind, also, that the creature that the steak was made of pooped a lot!
06:45:03 <sockdrawer> I would give some, but I would be banned so I'll not
06:45:42 <Lartsiam> mmm haskell
06:46:32 <benmachine> sockdrawer: did you know the haskell RTS is written in C :O
06:46:43 <ksf> ...but when the whole stuff is inside the haskell runtime, you can completely disregard implementing that side-channel, of course. the ghc api does that.
06:46:43 <benmachine> err, the *GHC rts
06:46:46 <sockdrawer> well I like C
06:47:02 <zygoloid> i would NEVER have guessed that :)
06:47:07 <ksf> C isn't without flaws, but it's the best we got
06:47:11 <sockdrawer> it has its warts
06:47:22 <sockdrawer> it should be resyntaxed, but it's too late
06:47:24 <ksf> though I don't know fortran, it certainly has its applications.
06:47:44 <p_l> ksf: I'm into making such thing portable, not something for a certain language or language-related OS (like Genera was)
06:47:46 <zygoloid> it seems to be a near-universal truth that people who like language X dislike language Y, where Y is designed to be a 'better X'.
06:47:46 <benmachine> > succ 'C'
06:47:47 <lambdabot>   'D'
06:47:50 <benmachine> *gasp*
06:48:03 <dankna> mm
06:48:05 <Alpounet> *sigh*
06:48:08 <zygoloid> i think they look at the changes they don't like, and say 'clearly Y sucks more than X'.
06:48:19 <ksf> p_l, me too.
06:48:33 <dankna> zygoloid: how much familiarity do you have with the specific complaints people often have about C++?
06:48:37 <ksf> but that can wait until the concept is proven inside something.
06:48:40 <int-e> D succs?
06:48:42 <zygoloid> dankna: a huge amount. C++ is my day job.
06:48:46 <dankna> okay.
06:48:52 <dankna> then you opinion is fair enough.
06:48:55 <dankna> *your
06:49:05 <sockdrawer> day job, hahaha
06:49:10 * p_l gave up on C++ when G++ transformed a negation of pointer into something crazy
06:49:11 <dankna> it would bother me if you were just saying that without knowing better :)
06:49:13 <sockdrawer> you must be a nerve wreck
06:49:18 <sockdrawer> sorry to hear about it
06:49:23 <zygoloid> dankna: i have an irrational dislike of Java and D, due to exactly this effect. took me a while to realise it's irrational though.
06:49:29 * dankna nods
06:49:39 <mercury^> p_l: what did you want it to do? :o
06:49:45 <dankna> well, I dislike D barely even knowing anything about it, simply on the grounds that I see it as a cheap marketing trick
06:50:02 <dankna> the author of it did very little work, as I see it
06:50:12 <zygoloid> sockdrawer: i actually quite like it. every day or two i get to explain to a coworker why something is behaving in an apparently-insane way.
06:50:25 <ksf> java wouldn't have made it without sun pushing it
06:50:39 <dankna> ksf: maybe; what's your point
06:50:39 <p_l> mercury^: if(!pointer_to_class) ....
06:50:50 <EvanR-work> dankna: old walt ;)
06:50:50 <p_l> (class instance, that is)
06:51:03 <dankna> EvanR, heh?  I don't follow
06:51:09 <EvanR-work> very little work was he was going for, the opposite of making a c++ compiler
06:51:09 <mercury^> Ah, thought you meant -pointer.
06:51:16 <dankna> oh
06:51:33 <dankna> yeah, I see.  but I don't really approve of doing that AND hyping it in the fashion that he does, with a huge list of features supported.
06:51:36 <p_l> given that such pointer is simply pointer to beginning of an array of ptrdiff_t, it shouldn't be that bloody hard, right?
06:51:37 <ksf> ...that my main dislike of java comes from the fact that sun pushed it to mobiles and I had to make things run on bricks _in_a_vm_
06:51:43 <EvanR-work> on the other hand the stdlib needed more love, and now we have tango crap
06:52:39 <benmachine> p_l: what did it do?
06:53:22 <p_l> benmachine: managed to turn it into at least 10 line template error dump
06:53:41 <p_l> the program in question didn't use templates, afaik (it wasn't my code)
06:53:52 <ksf> oh, and they messed up generics with the dubious argument of backwards compatiblity.
06:54:10 <ksf> ...as if pre-generic jvms would have the standard classes to run generics code.
06:55:02 * Alpounet quite like C++
06:55:03 <benmachine> I sometimes think that a lot of the nice things about haskell are nice only because it didn't really have anything to be backwards-compatible to
06:55:12 <benmachine> being a relatively recent language
06:55:27 <Lartsiam> you guys have it good
06:55:31 <Lartsiam> i have to learn vba
06:55:35 <dankna> benmachine: nah...  I think the way Haskell standards process does not show much concern for backward-compatibility
06:55:36 <Lartsiam> its making me suicidal
06:55:38 <int-e> ksf: I actually think the problem they worried about were "bytecode enhancers", which modify class files on the bytecode level.
06:55:45 <zygoloid> haskell also has lots of language experience to learn from
06:55:46 <fax> yeah a lot of the horrid warts on haskell are from bowing down to back compatability
06:55:47 <dankna> benmachine: cf. RemoveNPlusK
06:56:01 <applicative> does anyone know if I should worry that I get a warning from ld whenever I compile with ghc?  It isn't seeming to matter, it's just a warning: ld: warning: -read_only_relocs cannot be used with x86_64
06:56:01 <zygoloid> but the records are still a little broken
06:56:04 <benmachine> dankna: like any real people ever used n+k patterns really ever :P
06:56:07 <mercury^> benmachine: I think that's unfortunately not the case.
06:56:07 <dankna> well yeah
06:56:10 * zygoloid uses n+k patterns
06:56:12 <ksf> int-e, that's a whole other topic. javac and the vms are bug-compatible.
06:56:20 <mercury^> Haskell could be nicer if it didn't care about compatibility.
06:56:21 <dankna> but we would have had to support them forever if we cared about supporting things forever.
06:56:28 <dankna> ("A tautology is a thing which is tautological.")
06:56:38 <fax> hehe
06:56:44 <benmachine> mercury^: yeah, sure, but it seems less weighed down than a lot of other things I'm familiar with
06:57:26 <benmachine> zygoloid: records are a bit broken yes but I've never seen a new idea which is obviously better
06:57:34 <fax> benmachine -- rows ?
06:57:42 <benmachine> fax: never seen them!
06:57:44 <ksf> dankna, we don't have to support haskell98. hugs already does that...
06:57:47 <benmachine> didn't say I'd  looked very hard :P
06:58:16 <dankna> ksf: yeah, I agree completely.  and guess what?  that attitude is sufficient to avoid accumulation of cruft.
06:58:17 <ksf> benmachine, there's the make adts objects proposal.
06:58:47 <benmachine> ksf: objects?
06:58:50 <ksf> http://lambda-the-ultimate.org/node/3837
06:58:52 <dankna> ksf: that sounds interesting
06:59:12 <ksf> I'd love to see it implemented.
06:59:26 <ksf> and I don't care if it's vastly incompatible with h2010.
06:59:46 <ksf> (as long as the fii layer connecting them is slightly less awkward than the c ffi)
06:59:47 <EvanR-work> object, like, mutable data?
06:59:58 <dankna> so, do we think there's going to be an hs2011?
07:00:08 <dankna> or will it take a few more years?
07:00:10 <ksf> EvanR-work, not so much.
07:00:12 <ksf> read the paper.
07:00:24 <benmachine> dankna: I think the idea was for the process to be annual
07:00:32 <dankna> yeah, good.  I hope they manage that.
07:00:47 <dankna> a language that goes through a whole standards process every year... well, that would really be an achievement.
07:01:02 <dankna> most rapidly-developing languages don't have standards (Perl, say)
07:01:13 <zygoloid> they didn't apply very many changes in h'2010
07:01:16 <dankna> and I really do think you lose something important that way
07:01:24 <dankna> oh sure, it's a modest set of improvements, but that's fine
07:01:30 <benmachine> zygoloid: they didn't have to, as long as they keep doing it
07:01:45 <benmachine> I think PatternGuards at least show a willingness to introduce neat new things
07:01:45 <dankna> consensus is important
07:01:57 <zygoloid> benmachine: right. it's not a complaint, more an explanation of how they can get a standard out every year
07:02:04 <benmachine> mm
07:02:05 <dankna> gotcha
07:03:23 <applicative> edwardk: ping
07:04:07 <ksf> so is the successor of haskell (meaning that it's somewhere fundamentally incompatible) going to be called brooks?
07:06:06 <dankna> it's going to be called Dankna.  You're all going to be using gdc and using a .dk file extension. :D
07:06:22 <dankna> hahah, no, I have no ambitions in that regard
07:06:26 <zygoloid> the danish are /waay/ ahead there
07:06:33 <dankna> I don't think we're anywhere near the point where we need a successor to Haskell
07:06:46 <dankna> we'll figure it out when we get there
07:06:53 <dankna> are they, zygoloid?
07:06:55 <dankna> oh
07:06:56 <dankna> so they are
07:06:57 <dankna> haha
07:06:58 <fax> there are a good few things I'd change, but yeah.. it's totally not worth the effort yet
07:07:20 <Becquerel> this is the problem with laziness.
07:07:38 <ksf> ...I'm thinking about the unifying gadts/type classes thing.
07:07:48 <ksf> and while we're at it add modules to that.
07:08:10 <ksf> that'd be a haskell without data keyword
07:08:20 <fax> ksf, wow  how is that done?
07:08:25 <fax> unifying gadts/type classes?
07:08:39 <ksf> http://lambda-the-ultimate.org/node/3837
07:08:45 <MisterN> @pl fmap x <$> y
07:08:45 <lambdabot> fmap x <$> y
07:08:54 <MisterN> @pl fmap x `fmap` y
07:08:54 <lambdabot> fmap x `fmap` y
07:09:00 <dankna> if we go that route, is the porting of old programs simple enough that old programs could be automatically translated into the new language?
07:09:02 <ksf> let fmap2 = fmap . fmap
07:09:21 <ksf> I guess it'd be.
07:09:24 <MisterN> :t fmap2
07:09:25 <lambdabot> Not in scope: `fmap2'
07:09:35 <dankna> then we don't need to call it anything new.  it'll just be Haskell 201X
07:09:39 <Becquerel> :t fmap . fmap
07:09:41 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
07:09:41 <MisterN> ksf: the usage of fmap x <$> y in rwh confuses me
07:09:44 <dons> torrents for the haskell platform are now up.
07:09:47 <dankna> (pronounced "twenty exteen" because that's a cool sounding term)
07:09:52 <dons> check http://haskell.org/platform
07:09:54 <ksf> MisterN, you wouldn't be alone with that.
07:09:56 <dankna> dons: oh good, I'll stop seeding mine? :)
07:10:13 <sioraiocht> nice job with the torrent, danderson =)
07:10:23 <sockdrawer> dons here even
07:10:38 <dons> yeah, excellent work from danderson
07:10:39 <ksf> sadly enough, it doesn't get a lot of downloads.
07:11:05 <dons> the traffic on hackage is slowly falling too, http://abbot.galois.com/mrtg/external-bandwidth-day.png
07:11:08 <dons> down from its max limit
07:11:18 <applicative> of course, it was the first day the torrent was needed, now everything is faster.
07:11:24 <Mathnerd314> there's no windows haskell platform 2010... :-(
07:11:38 <dons> applicative: right.
07:11:48 <dons> Mathnerd314: there's a beta version. still needs testing.
07:11:50 <ksf> dons, if you set up a torrent rss feed, I'm going to seed it.
07:11:53 <dons> check the haskell-platform@ mailing list
07:12:01 <dons> ksf: i don't know what that is
07:12:06 <dons> just a feed of torrents as they appear?
07:12:15 <ksf> yep
07:12:17 <dons> easy
07:12:22 <ksf> torrent clients can parse them
07:12:31 <cogline> what is the best way to force evaluation of a string, or any list for that matter?
07:12:32 <MisterN> :t \x y -> fmap x <$> y
07:12:33 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f1 (f a) -> f1 (f b)
07:12:33 <applicative> but what can you do, why shouldn't the first day for a new Haskell Platform cause chaos everywhere...
07:12:56 <dankna> well, I'm glad they released when they did rather than holding up the release for torrents
07:13:03 <MisterN> :t \x y -> fmap x `fmap` y
07:13:04 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f1 (f a) -> f1 (f b)
07:13:18 <MisterN> :t \x y -> fmap (fmap x) y
07:13:19 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f1 (f a) -> f1 (f b)
07:13:25 <dankna> since I gather that would have been the alternative
07:13:34 <MisterN> :t \x y -> (fmap . fmap) x y
07:13:35 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
07:13:41 <MisterN> aah
07:14:09 <MisterN> you gotta love the type system :D
07:15:29 <fredune> ³¸
07:15:55 <Alpounet> cogline, length l `seq` foo
07:16:27 <Alpounet> it'll just force the Cons cells though
07:16:29 <Alpounet> not the proper content
07:17:51 <benmachine> :t join (foldr seq)
07:17:52 <lambdabot> forall a. [a] -> [a]
07:17:58 <MisterN> Alpounet: foo `seq` foo wouldn't work?
07:18:20 <benmachine> MisterN: foo `seq` foo means "evaluate foo before evaluating foo"
07:18:37 <benmachine> well no not quite
07:18:42 <cogline> :t join
07:18:42 <MisterN> benmachine: it doesn't recursively strictify it?
07:18:43 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
07:18:46 <benmachine> "make sure foo is evaluated when foo is evaluated"
07:18:52 <benmachine> no seq is not recursive
07:19:04 <MisterN> is there a recursive alternative? :)
07:19:08 <benmachine> rnf
07:19:09 <benmachine> but
07:19:14 <benmachine> hmm
07:19:19 <MisterN> :t rnf
07:19:20 <benmachine> deepseq
07:19:21 <lambdabot> forall a. (NFData a) => a -> Done
07:19:23 <benmachine> :t deepseq
07:19:24 <lambdabot> Not in scope: `deepseq'
07:19:28 <benmachine> :t deepSeq
07:19:29 <lambdabot> Not in scope: `deepSeq'
07:19:31 <benmachine> :(
07:19:32 <MisterN> NFData?
07:19:41 <MisterN> @hoogle deepseq
07:19:41 <lambdabot> No results found
07:19:44 <MisterN> @hoogle deepSeq
07:19:44 <lambdabot> No results found
07:19:46 <MisterN> :(
07:19:55 <benmachine> yeah it's a typeclass that basically specifies how to apply seq to all contents of a data type
07:20:08 <MisterN> the standard types have it?
07:20:09 <benmachine> so that evaluating the top level of the type evaluates the whole thing
07:20:18 <benmachine> it's not a standard class, but yes
07:20:20 <zygoloid> @let deepseq a b = rnf a `seq` b
07:20:21 <lambdabot>  Defined.
07:20:46 <benmachine> :t deepseq
07:20:48 <lambdabot> forall a t. (NFData a) => a -> t -> t
07:20:52 <dons> ksf: http://hackage.haskell.org/platform/hp.rss
07:21:04 <benmachine> why was the class restriction taken off seq, btw?
07:21:21 <benmachine> I mean there hasn't been one for as long as I've been programming haskell, but I heard that it used to exist
07:21:23 <MisterN> benmachine: and if i have a data, i have to manually instantiate NFData?
07:21:26 <dons> it makes refactoring really painful
07:21:28 <MisterN> @hoogle NFData
07:21:28 <lambdabot> Control.Parallel.Strategies class NFData a
07:21:36 <benmachine> MisterN: yes
07:21:44 <MisterN> :(
07:21:46 <benmachine> huh, I think that hoogle is out of date
07:21:51 <Spockz|lap> which NFData should I currently use? The one in C.P.Strategies or in C.DeepSeq?
07:21:55 <benmachine> MisterN: it's not that hard
07:22:35 <applicative> dons: stylin' rss feed there.
07:23:01 <ManateeLazyCat> Hi all, can you access your gmail now?
07:23:16 <dankna> ManateeLazyCat, yes.
07:23:25 <ManateeLazyCat> Oh, damn.
07:23:27 <applicative> ManateeLazyCat:yes
07:23:36 <ManateeLazyCat> I can't access gmail.
07:23:43 <ManateeLazyCat> Perhaps GFW.
07:23:56 <ManateeLazyCat> GFW make all Google doman failed.....
07:24:03 <benmachine> :(
07:24:08 <ManateeLazyCat> Painful.
07:24:16 <dankna> MLC: No news agencies are confirming that.  It might be just your local area that they applied the rule to, or something.
07:24:24 <dankna> (Yes, I was paying attention.)
07:24:57 <zygoloid> ManateeLazyCat: GFW?
07:25:05 <benmachine> Spockz|lap: I think the NFData in Strategies is re-exported from DeepSeq
07:25:11 <benmachine> zygoloid: great firewall, I guess
07:25:16 <benmachine> (of china)
07:25:22 <zygoloid> didn't google pull out of china on Monday?
07:25:38 <applicative> dons:  should I worry that whenever ghc links with my new macports ghc 6.10 I get a warning:  ld: warning: -read_only_relocs cannot be used with x86_64    It doesn't seem like i it could be a 'rot within' in my installation
07:25:43 <Spockz|lap> benmachine: when I try to add my own instance I get the error that rnf isn't a (visible) member of NFData
07:25:47 <ManateeLazyCat> zygoloid: China gove use GFW shutdown all Google domain
07:25:57 <dons> applicative: unknown. report a bug
07:25:57 <ManateeLazyCat> zygoloid: google.com, google.cn, google.com.hk
07:26:03 <ManateeLazyCat> zygoloid: All of Google.
07:26:20 <ksf> dons, works like a charm.
07:26:32 <dankna> zygoloid: yes, and MLC has been alleging since last night that China added a firewall rule blocking Google in response.  I believe that he personally is seeing a problem, but I have to wonder why I'm not seeing news reports of it.
07:26:34 <benmachine> zygoloid: no, google stopped censoring its content in china
07:26:34 <ManateeLazyCat> zygoloid: Yesterday Google exit, today China gov shutdown it.
07:26:46 <applicative> dons, I would but I generate nonsense installing ghc all the time.  I'll put up something hyperconditional.
07:26:57 <benmachine> or is that what you meant
07:27:32 <dankna> well, they "stopped censoring" by redirecting (or proxying?  I'm not clear on that) to their Hong Kong servers.  so effectively they stopped operating services within China.  or that's my understanding.
07:27:33 <benmachine> Spockz|lap: pass. try using ghci and :info to work out what your version of NFData looks like
07:27:42 <benmachine> dankna: oh, right
07:28:03 <ksf> dons, wait it says 2010.9.0.2 source and windows
07:28:13 <zygoloid> ManateeLazyCat: http://www.google.com/prc/report.html
07:28:19 <Spockz|lap> benmachine: that's the odd thing, I did that and even tried using the qualified name (I'm still on 6.10.4 btw)
07:28:40 <ksf> ...the source bundle url seems to point to something else but a torrent.
07:28:43 <dankna> a friend who works at Google's NYC office told me informally that that page is generated with 24 hours' delay, zygoloid
07:28:45 <ManateeLazyCat> zygoloid: I said, all google domain is down, unless you use too around GFW.
07:29:17 <ManateeLazyCat> I don't care that, i just care whether can i use gmail.
07:29:20 <theorbtwo> I think what ManateeLazyCat is trying to say is that google's servers are now outside the great firewall of china, and thus unreachable from the inside (by normal means).
07:29:26 <Mathnerd314> dons: this message claims that cabal-install is buggy under Windows? http://www.haskell.org/pipermail/libraries/2010-March/013299.html
07:29:46 <Mathnerd314> dons: what sort of bugs?
07:30:02 <dankna> theorbtwo: well, the great firewall doesn't block all external sites.  so it's not automatic that just because they're outside, they're unreachable.  he's saying that there is a specific rule blocking them now.
07:30:06 <ManateeLazyCat> theorbtwo: I can use otherwise around GFW, but looks gmail can't accept gmail or login.
07:30:07 <dons> Mathnerd314: dcoutts has the details.
07:30:13 <eevar2> yay, my ancient 2GHz Athlon (64-bit, linux) is ~ 2x as quick as my nearly-as-old 2GHz core duo (32bit, osx) at recursive-fib (40)
07:30:14 <dons> i think it prevents a few things from installing.
07:30:15 <benmachine> Spockz|lap: not quite following. what did :info say, which one are you trying to use, etc.
07:30:26 <dons> but it you'd like to test  the installer and report back, that is very much needed
07:30:41 <dankna> MLC: gmail uses AJAX, which probably doesn't work very well with such tools; try loading its "basic html mode" instead (I think there's a query parameter that you add to the URL)
07:31:04 <ksf> don't underestimate early amd64s
07:31:04 <theorbtwo> ManateeLazyCat: If you haven't, try giving the @google.cn on the end of your username, if it's just giving "bad username or password".
07:31:05 <ManateeLazyCat> I can gmail server hours ago. But now can't access.
07:31:36 <ManateeLazyCat> theorbtwo: You don't know about GFW.
07:31:43 <eevar2> ^^ useless trivia from upgrading both systems to 6.12
07:31:58 <theorbtwo> ManateeLazyCat: No, I don't.  Not much, anyway.
07:32:06 <ManateeLazyCat> theorbtwo: And you don't know what situation i occur.
07:32:26 <ManateeLazyCat> theorbtwo: GFW make all google service can't access, even i can ping it.
07:32:46 <Spockz|lap> benmachine: this I mean: http://pastie.org/884704
07:32:56 <theorbtwo> Right.  Possibly this has something to do with this being #haskell, not #china.
07:33:00 <MisterN> eevar2: the athlon64 were a good time for AMD, probably the best
07:33:07 <dankna> does anybody know offhand whether there is a way to construct a Double given a decimal representation of it?  rather than a binary one?
07:33:21 <zygoloid> dankna: read?
07:33:33 <dankna> sorry, I meant without going through read :) but hmm
07:33:41 <dankna> I may have to do that.  I'm not sure why I didn't want to, actually.
07:33:46 <Cale> How is your decimal representation stored?
07:34:08 <ih> is combinator just another word for function? or is there an additional connotation?
07:34:08 <dankna> I have it as three strings - mantissa before the decimal point, mantissa after the decimal point, and exponent
07:34:10 <theorbtwo> Use reads instead if you want sane error handling.
07:34:20 <dankna> ah yeah, I do want sane error handling :)
07:34:41 <zygoloid> ih: there's added connotations. usually 'combinator' refers to something that's higher order in some sense. it also has a precise meaning in lambda calculus iirc
07:34:53 <ih> ok, thanks
07:34:58 <ManateeLazyCat> I just can access gmail through YourFreedom
07:35:03 <dankna> the thing is that I've already parsed it into those fields, so it just seems wasteful (this is an inner lexing loop, so performance might actually matter) to parse it again
07:35:04 <aleator_>  hsc2hs does not seem to like TH: after $(ctx 'map) splice, #type does not expand anymore.
07:35:37 <dankna> if there's no easy way to do it, I'll just go with reads, I suppose, but.
07:35:47 <ManateeLazyCat> but very slow.
07:35:54 <aleator_> However $(ctx ''Int) does work
07:35:57 <ManateeLazyCat> Just 128Kb
07:36:23 <zygoloid> > Just 128Kb
07:36:24 <lambdabot>   Not in scope: data constructor `Kb'
07:36:31 <benmachine> Spockz|lap: odd, beyond my powers of explanation
07:36:58 * benmachine vaguely recalls the rules for class instances of qualified things being odd
07:37:13 <benmachine> can you use Control.DeepSeq.rnf elsewhere?
07:37:19 <benmachine> and it does what you expect?
07:38:22 <benmachine> (p.s. that implementation of rnf is the default)
07:38:41 <Spockz|lap> benmachine: (yes I know that, but it's just for testing)
07:39:15 <Spockz|lap> and Control.DeepSeq.rnf is available, but I don't know how I can test whether it works as expected
07:39:31 <benmachine> I meant typechecks, really
07:39:53 <MisterN> zygoloid: wow you can use data constructors at the end of numbers?
07:40:05 <MisterN> > 5Just
07:40:06 <lambdabot>   No instance for (GHC.Num.Num ((a -> Data.Maybe.Maybe a) -> a1))
07:40:06 <lambdabot>    arising ...
07:40:14 <zygoloid> MisterN: it's a weirdness of the parser. but yes, you can.
07:40:24 <ManateeLazyCat> As a Chinese , I just one talk to GFW and China governments: "Fuck you". I'm so angry.....
07:40:31 <MisterN> > 5Just :: Maybe Int
07:40:32 <lambdabot>   No instance for (GHC.Num.Num
07:40:32 <lambdabot>                     ((a -> Data.Maybe.Maybe a)...
07:40:38 <MisterN> *confused*
07:40:50 <zygoloid> > let tastesnice = 123 in (+) 0xdeadbeeftastesnice
07:40:51 <lambdabot>   3735928682
07:41:02 <zygoloid> ^^ hooray for the lexer :(
07:41:20 <MisterN> uuh that's ugly
07:41:21 <benmachine> heh
07:41:47 <benmachine> Spockz|lap: have you tried specifying the qualified name inside the instance?
07:41:56 <benmachine> (I don't think you need to but you might as well try)
07:41:59 <MisterN> > (+ 1 2)
07:42:00 <lambdabot>   Ambiguous type variable `t' in the constraint:
07:42:00 <lambdabot>    `GHC.Num.Num t' arising f...
07:42:09 <benmachine> > (+) 1 2
07:42:10 <lambdabot>   3
07:42:15 <benmachine> > (+ 1) 2
07:42:16 <lambdabot>   3
07:42:42 <MisterN> :t (+ 1 2)
07:42:43 <lambdabot>     Ambiguous type variable `t' in the constraint:
07:42:45 <lambdabot>       `Num t' arising from the literal `2' at <interactive>:1:5
07:42:47 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
07:43:02 <benmachine> MisterN: basically that doesn't work :P
07:43:04 <Toxaris> MisterN: 5Just is 5 applied to Just, not Just applied to 5. So if you want to say 5Just, you need to have a Num instance which allows numeric literals like 5 to be functions
07:43:22 <MisterN> Toxaris: that can be hacked together?
07:43:26 <zygoloid> (functions which take functions :: a -> Maybe a, at that)
07:43:33 <benmachine> MisterN: yes, but it's pretty wtf
07:43:42 <zygoloid> > flip ($) 5Just
07:43:44 <lambdabot>   Just 5
07:43:52 <MisterN> :t ($)
07:43:53 <lambdabot> forall a b. (a -> b) -> a -> b
07:44:07 <ManateeLazyCat> China government: CHEEKY!
07:44:12 <MisterN> zygoloid: well that's kinda lame
07:44:48 <MisterN> @let fflip=flip ($)
07:44:49 <lambdabot>  Defined.
07:44:54 <MisterN> > fflip 5Just
07:44:55 <lambdabot>   Just 5
07:45:31 <Toxaris> MisterN: sure, like this: instance Num (a -> a) where fromInteger 5 = id
07:45:47 <benmachine> Toxaris: that's one way of doing it
07:45:48 <Toxaris> MisterN: now, 5Just = (fromInteger 5) Just = id Just = Just
07:45:54 <Botje> Toxaris++ # evil
07:46:15 <benmachine> I think you need FlexibleInstances for (a -> a) though
07:46:16 <MisterN> Toxaris: you also need a default(MyInteger), no?
07:46:24 <benmachine> nope
07:46:39 <MisterN> ??
07:46:43 <Toxaris> MisterN: No. No need for defaults, because you *use* 5 as a function, the compiler picks the function-like instance
07:47:07 <Toxaris> MisterN: that's the point of type classes: you just use polymorphic things, and the compiler figures out which instance is appropriate here
07:47:08 <benmachine> defaults are for resolving ambiguity, but there's no ambiguity here
07:47:38 <MisterN> wtf
07:47:55 <ksf> the iteratee library lacks chuck transformers
07:48:05 <MisterN> Toxaris: can you make a full example on hpaste.org?
07:48:06 <ksf> and rechunkers
07:48:53 <ksf> and doing io actions chunk-wise
07:49:24 <ksf> it's not so useful to have bytestring chunks if you then output data over the wire byte-wise
07:49:53 <Spockz|lap> benmachine: that doesn't work obiously
07:50:08 <Toxaris> MisterN: hmm well, just trying it, and it seems not to work exactly like that :(
07:50:16 <benmachine> Spockz|lap: well, I dunno then :P
07:55:47 <ksf> .oO( and stupid me thought he could get away with non-greedy combinators that lack the possibility to match on eof )
07:58:14 <Sgeo> .o0( I've seen .o0 used before, mostly in JParanoia (actually, I think it's . o 0 () there )
07:58:21 <Toxaris> MisterN: sorry, it seems to be too complicated to make it typecheck, I'm not really sure why. Instance selection seems to be more tricky then I was thinking.
07:58:31 <MisterN> Toxaris: :(
07:58:36 <ksf> it's an O, not zero.
07:58:41 <Sgeo> O
07:58:44 <Toxaris> MisterN: Luckily, it's not actually desirable anyway
07:58:45 <Sgeo> >.>
07:58:46 <Mathnerd314> Toxaris: what was your instance type?
07:58:53 <MisterN> Toxaris: indeed :)
07:58:56 <MisterN> but! it's fun
07:59:25 <Toxaris> Mathnerd314: this was my original idea: instance Num (a -> a) where fromInteger 5 = id
07:59:56 <ksf> instance selection in the presence of extensions can be incomprehensible.
07:59:56 <Mathnerd314> but if you want 5Just to be Just 5, it needs to be a different type
08:00:11 <Toxaris> Mathnerd314: I don't want that, I just want 5Just to be something at all
08:00:22 <MisterN> :t Just
08:00:23 <lambdabot> forall a. a -> Maybe a
08:00:37 <aavogt> @type ($ (5::Int)
08:00:37 <lambdabot> parse error (possibly incorrect indentation)
08:00:40 <aavogt> @type ($ (5::Int))
08:00:42 <lambdabot> forall b. (Int -> b) -> b
08:00:52 <Toxaris> Mathnerd314: but of course (5 = \f -> f 5) would be cooler
08:01:35 <zygoloid> instance Num a => Num ((a -> b) -> b) where fromInteger x f = f (fromInteger x)
08:01:43 <Toxaris> ksf: In was hoping that unification and instance selection would be interleaved in a way it obviously is not
08:02:20 <ksf> there's only one being in the world who understands all of it, and that's the child of oleg and spj.
08:02:43 <ksf> he's also known as the typhadarach.
08:03:10 <aavogt> zygoloid: but unfortunately there's the need to satisfy the Show and Eq superclasses
08:03:13 <Toxaris> zygoloid: that suffers from the same unification vs selection problem
08:03:40 <Toxaris> With your instance, and dummy Eq and Show instances, 5Just yields the error:  No instance for (Num ((a -> Maybe a) -> t))
08:03:57 <Toxaris> zygoloid: so there is an instance if t is unified with Maybe a, but ghc does not do so
08:04:23 <aavogt> do you need a multiparameter typeclass?
08:04:51 * Mathnerd314 figures it out
08:05:09 <Mathnerd314> you can use id on the function to get back the original number
08:05:31 <Mathnerd314> and that makes it work
08:05:38 <Mathnerd314> (I think)
08:08:00 <gilbertl> hi everyone
08:08:07 <gilbertl> i have this really short piece of code
08:08:10 <gilbertl> that seems to work in ghci
08:08:12 <gilbertl> but doesn't compile
08:08:14 <gilbertl> giving me link errors
08:08:15 <gilbertl> http://pastebin.com/e24zJQam
08:08:30 <dankna> could you hpaste the link errors too?
08:08:50 <gilbertl> yes
08:08:50 <gilbertl> http://pastebin.com/zraEh3SW
08:08:56 <Cale> gilbertl: Most link errors are solved by using --make
08:09:01 <Cale> are you compiling with --make?
08:09:08 <gilbertl> Cale: no
08:09:15 <gilbertl> Cale: lemme try with --make
08:09:20 <dankna> what Cale says, but if you insist on not doing that, I think -package containers or something is what you'd need
08:09:22 <Cale> gilbertl: It will sort out which packages are required
08:09:45 <gilbertl> dankna: Cale: thank you! =)
08:10:25 <dankna> welcome :)
08:13:26 <deech> Hi all , is there some way to import all modules in a directory like : import Control.Monad.*, instead of 'import Control.Monad, import Control.Monad.Reader' etc.
08:13:37 <MisterN> :t (/)
08:13:38 <lambdabot> forall a. (Fractional a) => a -> a -> a
08:14:28 <dankna> deech: I don't believe so.
08:14:57 <Toxaris> deech: no, but you can write your own AllOfMonad module, which imports all these modules, and exports them using the module keyword in the export list
08:16:29 <Toxaris> aavogt: yes i needed a multi param type class, to introduce fundeps, to force ghc to do what I want. thanks for the hint.
08:16:47 <Toxaris> MisterN: there you go: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24317#a24317
08:17:02 <deech> Cool thanks! On a related note, I feel like I am too dependent on the Internet when writing Haskell. So for example, I'll use runReader and forget which module exports it. I am then forced to hit up Hayoo. Is there some way I can figure this out locally?
08:17:25 <dankna> I agree with you.  With some effort, you can get everything local.
08:17:31 <dankna> cabal install hoogle is a good start
08:17:46 <MisterN> Toxaris: wow
08:17:48 <dankna> and read up on the syntax of ~/.cabal/config and edit it such that documentation is always built
08:18:02 <deech> dankna: I didn't know I could install hoogle.
08:19:08 <dankna> yeah
08:19:15 <aavogt> deech: at least vim's haskell mode has bindings to import things based on exports it reads from your locally installed haddocks
08:19:46 <aavogt> editor support is definitely helpful for stuff like that
08:21:25 <deech> I don't think I knew I had to enable documentation to be built. Once I enable it in ~/.cabal/config, can I go back and build the haddocks for packages I have already installed?
08:21:51 <dankna> only by reinstalling them, as far as I know, which requires some care so you don't accidentally install a more recent version of a package that was bundled with ghc
08:22:59 <dankna> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24319#a24319 -- my .cabal/config
08:23:05 <dankna> you don't want yours exactly like this
08:23:10 <dankna> I have mine set to install system-wide instead of per-user
08:23:28 <dankna> but what you probably do want is that docdir setting which adds a per-compiler-version directory
08:26:39 <deech> Awesome,thanks!
08:26:45 <dankna> welcome
08:26:46 <ksf> is someone interested in parsers here?
08:26:49 <dankna> ksf: me me me
08:27:28 <ksf> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24320#a24320
08:28:09 <dankna> ugh line wrapping, but reading it
08:28:13 <benmachine> has the entire syntax-highlight been broken by the package import?
08:28:27 <ksf> I'm getting worried about not breaking up recursion and thus hogging memory when someone sends a sequence matching a long "many"
08:28:36 <ksf> so far it hasn't ever blown up, but still
08:28:40 <ksf> yes it has.
08:28:56 <dankna> one sec, ksf.  I'll see if I can break your code.
08:31:40 <fax> can't read it
08:32:01 <jmcarthur> the syntax highlighter hates that package qualified import
08:32:37 <ksf> I agree that most of it looks like line noise
08:32:46 <Sgeo> package qualified import?
08:32:59 <ksf> ...and I forgot to doc than eof function.
08:33:12 <dankna> ksf: where do I get Data.GMap.Auto?  it's not in gmap-0.1.
08:33:41 <diegoeche> hi guys. Is there a way to easily serialize and de-serialize functions in Haskell?
08:33:45 <aavogt> Sgeo: there is an extension to specify which package provides the module you import
08:33:50 <aavogt> > not
08:33:51 <lambdabot>   {True->False;False->True}
08:34:08 <dankna> > id
08:34:09 <lambdabot>   {()->()}
08:34:16 <dankna> @more
08:34:16 <fax> diegoeche -- for 'de-serialize' there is haskell source code, not sure about the other way around though..
08:34:20 <Sgeo> > Just
08:34:21 <lambdabot>   {()->Just ()}
08:34:29 <MisterN> :t (!!!)
08:34:30 <dankna> > id :: String -> String
08:34:30 <lambdabot> Not in scope: `!!!'
08:34:31 <lambdabot>   ""->
08:34:31 <lambdabot>    ""
08:34:31 <lambdabot>  "a"->
08:34:31 <lambdabot>    "a"
08:34:32 <lambdabot>  "aa"->
08:34:34 <lambdabot> [6 @more lines]
08:34:42 <jmcarthur> > Just :: Bool -> Maybe Bool
08:34:43 <lambdabot>   {True->Just True;False->Just False}
08:34:48 <dankna> > id :: String -> String -> String
08:34:48 <lambdabot>   Couldn't match expected type `GHC.Base.String -> GHC.Base.String'
08:34:49 <lambdabot>         a...
08:34:55 <fax> > not . not . not
08:34:56 <lambdabot>   {True->False;False->True}
08:34:58 <dankna> > id :: (String -> String) -> String
08:34:59 <lambdabot>   Couldn't match expected type `GHC.Base.String'
08:34:59 <lambdabot>         against inferred typ...
08:35:06 <Sgeo> > not . not
08:35:07 <lambdabot>   {True->True;False->False}
08:35:10 <ksf> dankna, just a sec
08:35:12 <dankna> > id :: (String -> String) -> (String -> String)
08:35:13 <lambdabot>   ""->
08:35:13 <lambdabot>    ""
08:35:13 <lambdabot>  "a"->
08:35:13 <lambdabot>    ""
08:35:13 <lambdabot>  "aa"->
08:35:14 <dankna> ksf, sure
08:35:15 <lambdabot> [6 @more lines]
08:35:22 <aavogt> Sgeo: the Show instance used here can be found in smallcheck
08:35:30 <dankna> whoa, I was expecting lambdabot to choke on that last one
08:35:44 <dankna> however, it's still not that useful for anything but debugging :)
08:35:46 <ksf> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24320#a24322
08:36:39 <dankna> kay, cool
08:37:06 <Sgeo> :t length
08:37:07 <lambdabot> forall a. [a] -> Int
08:37:16 <Sgeo> > length $ show id
08:37:18 <lambdabot>   8
08:39:36 <ksf> dankna, having recursion that doesn't involve infinite structures would be especially nice... I could generate straight code, then.
08:40:30 <dankna> ksf: hm... I do know a fair bit about parse theory, enough to possibly be of help, but seeing this in Haskell is confusing me.  what does that <* combinator do, for example?
08:40:49 <ksf> that's applicative composition.
08:41:13 <ksf> ...returning the result on the left, and parsing first the left hand parser, then the right hand.
08:41:55 <dankna> so it consumes input for both subparsers, but only the left one contributes to the result
08:42:04 <ksf> ...like in   f = NinePVersion <$> (toks "9P" *> digitsP) <*> option (tok '.' *> many anyTok) "" <* eof
08:42:08 <ksf> yes.
08:43:31 <diegoeche> dankna: an easy mnemonic is to think that it returns where you have < or > so, <*> returns both sides. *> parses but "ignores" the result of the left parser. And <* parses and "ignores" the right side.
08:43:41 <dankna> hm.  okay.
08:43:50 <benmachine> <*> uses both sides
08:43:57 <fax> :t (<*>)
08:43:58 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
08:44:01 <benmachine> returns them is a bit of a misnomer
08:44:14 <dankna> I've got Control.Applicative up now; it's new to me, but I think I can figure it out.
08:44:38 <ksf> <*> is ap
08:44:52 <ksf> :t ap
08:44:53 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
08:45:08 <diegoeche> dankna: I found the explanation in the typeclassopedia quite useful
08:45:21 <dankna> diegoeche, ah, thanks
08:45:32 <fax> actually
08:45:34 <fax> :t (<*)
08:45:35 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
08:45:39 <fax> that says everything :)
08:45:40 <ksf> applicative isn't really important for the parser, though, you can equally well use the monad instance.
08:45:58 <ksf> alternative, otoh, matters
08:45:59 <dankna> okay, I was thinking that somehow you were using properties of applicatives to do your heavy lifting
08:46:01 <fax> oh well that's not quite true...
08:46:02 <fax> :t liftA2 const
08:46:03 <lambdabot> forall a b (f :: * -> *). (Applicative f) => f a -> f b -> f a
08:46:12 <fax> different functions..
08:46:39 <benmachine> fax: er, are they?
08:46:47 <benmachine> :t flip (*>)
08:46:48 <ksf> I'm using alternative for the some/many lifting.
08:46:49 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f b -> f a -> f b
08:46:53 <aavogt> ksf: then you have a MonadPlus instance?
08:46:59 <benmachine> ^ that's a different function
08:47:00 <diegoeche> ksf: IIRC some parser combinator libraries use <* and *> without creating instances of applicative. And not providing a monad interface
08:47:15 <fax> > (liftA2 const) (Just ()) Nothin
08:47:16 <fax> > (liftA2 const) (Just ()) Nothing
08:47:16 <lambdabot>   Not in scope: data constructor `Nothin'
08:47:17 <lambdabot>   Nothing
08:47:17 <ksf> aavogt, and monoid
08:47:25 <fax> ah you are right, this is the samea
08:48:02 <benmachine> > (const :: (Applicative f) => f a -> f b -> f a) (Just ()) Nothing
08:48:02 <lambdabot>   Just ()
08:48:05 <benmachine> :P
08:48:08 <aavogt> hmm? Monoid instances could be different
08:48:33 <aavogt> > Just (Sum 1) `mappend` Just (Sum 3)
08:48:34 <lambdabot>   Just (Sum {getSum = 4})
08:48:57 <fax> that's what I was thinking of, for some reason
08:48:59 <ksf> it's mempty = empty; mappend = (<|>)
08:49:01 <jmcarthur> @check \a b -> ((a :: [Int]) <* (b :: [Bool]) == liftA2 const a b
08:49:02 <lambdabot>  Unbalanced parentheses
08:49:07 <dankna> okay, so, shouldn't I get some output from parse (many (option (toks "ab") () <* toks "xyz")) "abxyz"?
08:49:09 <jmcarthur> @check \a b -> ((a :: [Int]) <* (b :: [Bool])) == liftA2 const a b
08:49:10 <lambdabot>   "OK, passed 500 tests."
08:49:12 <dankna> I get a type error on the ()
08:49:35 <dankna> which makes sense, as () is not a char, heh
08:49:51 <dankna> er, list of chars.  it's not either of those.
08:50:01 <aavogt> it would be a bit silly to have such redundant instances, especially since   Monad a => Monoid (Parser a)    could be useful
08:50:02 <jmcarthur> @src (<*)
08:50:03 <lambdabot> (<*) = liftA2 const
08:51:12 <aavogt> where    mappend = liftA2 mappend; mempty = pure mempty
08:51:22 <ksf> parse ((many ((option (toks "ab") "") <* toks "xyz")) <* eof) "abxyz"
08:52:33 <ksf> hmmm doesn't seem to blow up right now.
08:52:35 <dankna> ksf: ah!  that yields output, yes, I see
08:52:48 <ksf> tbh, I didn't try it.
08:52:50 <benmachine> <* is already left-associative btw
08:53:00 <ksf> try dbgParse
08:53:06 <jmcarthur> many (option (toks "ab") "" <* toks "xyz") <* eof
08:53:16 <dankna> ah, dbgParse is illuminating
08:53:29 <dankna> benmachine: that's okay - I like the parentheses anyway :D
08:53:33 <benmachine> is option = (<|>)?
08:53:38 * jmcarthur doesn't like tons of parens
08:53:44 <dankna> I'm from a Lisp background, haha
08:53:48 <benmachine> oh
08:53:50 <benmachine> no I see
08:53:51 <dankna> although I'm a convert to static typing
08:53:55 <ksf> option p x = p <|> pure x
08:54:19 <benmachine> that sounds like it should be in Control.Applicative
08:54:24 <ksf> :t optional
08:54:25 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f (Maybe a)
08:54:29 <ksf> indeed, it should.
08:54:46 <ksf> it's the equivalent of maybe.
08:54:54 <jmcarthur> Control.Applicative deserves a lot of things it doesn't have
08:55:07 <benmachine> :t let option p x = p <|> pure x in option (Just <$> p) Nothing
08:55:08 <lambdabot>     Ambiguous occurrence `<|>'
08:55:08 <lambdabot>     It could refer to either `Control.Applicative.<|>', imported from Control.Applicative
08:55:08 <lambdabot>                           or `Lava.<|>', imported from Lava
08:55:15 <benmachine> what the hell is Lava
08:55:24 <benmachine> :t Lava.<|>
08:55:25 <lambdabot> parse error on input `Lava.<|>'
08:55:31 <benmachine> :t (Lava.<|>) -- sigh
08:55:32 <lambdabot> Signal Bool -> Signal Bool -> Signal Bool
08:55:44 <benmachine> @hoogle Signal a
08:55:44 <lambdabot> Did you mean: :: Signal a /count=20
08:55:44 <lambdabot> Control.Concurrent.QSem signalQSem :: QSem -> IO ()
08:55:44 <lambdabot> Control.Concurrent.QSemN signalQSemN :: QSemN -> Int -> IO ()
08:55:51 <benmachine> @hoogle Signal
08:55:51 <lambdabot> Control.Concurrent.QSem signalQSem :: QSem -> IO ()
08:55:51 <lambdabot> Control.Concurrent.QSemN signalQSemN :: QSemN -> Int -> IO ()
08:56:04 * benmachine hrms
08:57:14 <rajeshsr> how many of you here knows lisp too? What experience you have to share on comparing them?
08:57:31 <ksf> I've got some scheme experience
08:57:42 <ksf> scheme is impure, and usually slower.
08:58:01 <jmcarthur> i know some scheme, but not enough to feel like an experienced schemer would trust my judgement of it
08:58:11 <ksf> unless you use stalin, but then you can't use any interesting scheme feature.
08:58:21 <dankna> rajeshsr: Lisp programs are harder to know they're correct.  Yesterday I wrote 1700 lines of Haskell and was highly confident they were correct simply because they passed typechecking and a very small number of informal tests.
08:58:34 <jmcarthur> dankna: that's a lot of lines
08:58:37 <dankna> Try doing that in Lisp.
08:58:46 <dankna> jmcarthur: well it was highly regular in structure :)
08:58:51 <Adamant> type checking does not tell you your program is correct.
08:58:58 <jmcarthur> dankna: honestly, if it was describing your AST it shouldn't be that hard in lisp either ;)
08:59:03 <Adamant> at least, not strictly correct.
08:59:08 <jmcarthur> dankna: it just lacks type safety
08:59:16 <jmcarthur> Adamant: it can do that, just not in haskell
08:59:25 <dankna> jmcarthur - well in Lisp the lack of type safety would mean I'd have to test every single production by hand to know I hadn't misused a type somewhere
08:59:27 <rajeshsr> dankna, interesting! on a single day you wrote so much!!
08:59:45 <jmcarthur> rajeshsr: if it's what i'm thinking, it's *highly* regular code ;)
08:59:46 <Adamant> jmcarthur: yeah, it can, when you turn the type system into being equivalent to a theorem prover :P
08:59:49 <ksf> must've been an unproductive day.
08:59:53 <dankna> jmcarthur: it's what you're thinking :)
08:59:59 <ksf> on productive days, I delete 1000 lines.
09:00:05 <jmcarthur> ksf: amen
09:00:06 <dankna> ksf: hehe, yeah
09:00:21 <jmcarthur> dankna: use some template haskell and bring that line count down, good sir ;)
09:00:33 <dankna> jmcarthur: I shall try!
09:01:02 <dankna> anyway, back to ksf's thing
09:01:15 <jmcarthur> (i assume sir when i don't know because i am a typical sexist internet denizen, i guess)
09:01:22 <dankna> sir is correct
09:01:35 <benmachine> sirdam
09:02:38 <dankna> but yes, typechecking doesn't tell me it's correct.  but it catches the class of mistake I was most likely to make in this case.
09:03:04 <deech> I've always thought the English language lacked a neuter. What about herm? Or sirm?
09:03:13 <Adamant> them
09:03:22 <dankna> in fact if your edit-compile-fail cycle is fast, it can even serve to guide you as you write
09:03:24 <Adamant> or they
09:03:31 <dankna> by pointing out the places you need to fix things up to be consistent with your latest change
09:03:32 <jmcarthur> and it's important to note that in haskell there are many more classes of mistakes that can be caught by the type system than in most mainsteam typed languages
09:03:32 <benmachine> they and them are adequate for some purposes but not this
09:03:33 <deech> Adamant: Not singular
09:03:38 <Sgeo> em?
09:03:39 <benmachine> deech: can be used as such
09:03:47 * Sgeo loves Spivak pronouns
09:03:53 <jmcarthur> *mainstream
09:04:06 <Adamant> what benmachine said, although some people argue whether it should be
09:04:08 <benmachine> jmcarthur: what mainstream typed languages are there?
09:04:13 <deech> benmachine: huh?
09:04:29 <deech> benmachine: Java, c++, C# etc.
09:04:34 <jmcarthur> benmachine: Java, C#, C, C++ (varying degrees of strength, etc.)
09:04:46 <benmachine> they are all crappily typed :P
09:04:51 <jmcarthur> right
09:04:59 <benmachine> but I guess typed nonetheless
09:04:59 <jmcarthur> most statically typed mainstream languages are ;)
09:05:06 <benmachine> is ada any good at that?
09:05:13 <ksf> scheme is typed.
09:05:22 <ksf> it knows about numbers, atoms and tuples.
09:05:25 <jmcarthur> ada's type system is a bit tighter, but i wouldn't say more expressive in general
09:05:43 <deech> Isn't Lisp strongly typed?
09:05:53 <jmcarthur> strongly /= statically
09:05:56 <dankna> Lisp is strongly typed at runtime
09:06:04 <benmachine> is it a coincidence that haskell has such a strong type system and is purely functional, or do those suit each other in some way?
09:06:19 <deech> Right, but you could get the same benefits if you declare the type, right?
09:06:25 <benmachine> (and by strong I mean in the non-technical sense)
09:06:43 <jmcarthur> benmachine: i'm not sure what point you are emphasizing in that question
09:06:48 <ksf> statically typed languages without milner types are dysfunctional, anyway.
09:06:50 <dankna> deech: benefits for efficiency, yes.  but it still doesn't have a static typechecker.
09:07:07 <Adamant> benmachine: typing and safety is lot more complicated with some semi-common imperative constructions
09:07:07 <jmcarthur> deech: declaring a type doesn't make a type system ;)
09:07:09 <dankna> deech: that means you can't catch those mistakes unless you actually test the codepath.
09:07:11 <deech> benmachine: I think a strong type system is good for controlling side-effects.
09:07:21 <benmachine> jmcarthur: I'm just curious why there aren't non-functional languages that have a type system as powerful as haskell's
09:07:33 <ksf> there's ocaml
09:07:34 <jmcarthur> benmachine: oh, i think that is no coincidence
09:07:44 <ksf> and ocaml is clearly imperative
09:07:45 <fax> benmachine, everyone who learns about type systems knows how good lambda it!!
09:07:46 <fax> is*
09:07:49 <ksf> being impure and all
09:07:49 <jmcarthur> benmachine: but maybe not technical
09:08:00 <benmachine> jmcarthur: could be cultural?
09:08:21 <benmachine> or I guess that's fax's point
09:08:35 <dankna> deech: for example, in Common Lisp, (defun plus (a b) (declare (type integer a b)) (+ a b)) will, if compiled, produce code that runs faster on integers than on other types
09:08:40 <jmcarthur> benmachine: there are some technical reasons that it's more difficult, but i don't think insurmountable. culture might have a lot to do with it
09:08:50 <dankna> but the results will then be undefined if you call (plus "foo" :bar)
09:09:03 <deech> Writing code with a really strict type system is hard. Mainstream languages shouldn't be hard but need to be somewhat safe. Hence crappy type systems.
09:09:04 <Cale> Types are less meaningful when you have arbitrary effects going on everywhere.
09:09:12 <lpsmith> benmachine, depends on what a "functional" language is;   OBJ3 is often fairly imperative and has a pretty powerful type system, IIRC
09:09:22 <dankna> in practice, existing Lisp implementations will produce a clean error, but not until the function call is actually evaluated
09:09:39 <jmcarthur> yeah, control of effects would be one of the most important things for a nice type system like haskell's to apply to an imperative language
09:09:39 <dankna> in Haskell you can't even compile the equivalent of (plus "foo" :bar); the compiler won't let you
09:09:39 <deech> dankna: I see, didn't know that.
09:09:51 <dankna> and that's valuable for far more than efficiency
09:09:52 <dankna> yeah
09:09:53 <jmcarthur> and once you start introducing control of effects, you start losing imperativeness
09:10:00 <jmcarthur> IMO
09:10:03 <lpsmith> ok n/m,  obj3 is a bit different than I thought it was
09:11:01 <dankna> ksf: so yeah... I'm looking at the output of dbgParse
09:11:12 <dankna> what does that second field represent?  is that the FOLLOW set?  but it doesn't look like it...
09:11:32 <ickabob> :t getArgs
09:11:33 <lambdabot> Not in scope: `getArgs'
09:11:36 <ksf> it's the matches allowed at that position
09:11:45 <ickabob> :t System.Environment.getArgs
09:11:46 <lambdabot> IO [String]
09:11:56 <dankna> hm, okay, yes, I see
09:12:03 <ksf> each one has a continuation parser attached to it
09:12:13 <ksf> ...which you then see on the next line.
09:12:33 * edwardk_ waves hello.
09:12:50 <fax> hi
09:12:53 * benmachine waves edwardk_ 
09:13:18 <ickabob> jeebus I dont think I have ever found any language so difficult to process commandline args as it is in haskell =(
09:13:25 <dankna> for my edification I want to see how the algorithm behaves when there's more than one match that, er, matches
09:13:34 <dankna> hm
09:13:46 <Alpounet> hi edwardk
09:13:48 <dankna> I'm attempting to come up with a concise example that will do that
09:13:50 <rajeshsr> so, it all about the difference in type system between lisp and haskell?
09:14:09 <edwardk_> ickabob: i'll admit the strongly typed getoptions is a bit strange
09:14:20 <ksf> dankna, try dbgParse ((toks "GET" <|> toks "POST" <|> toks "PUT") <* eof) "POST"
09:14:42 <deech> rajeshsr: Yes and order of evaluation. Lisp is strictly evaluated IIRC.
09:15:05 <dankna> Lisp is indeed strictly evaluated, yes
09:15:11 <rajeshsr> deech, hmm, right!
09:15:24 <ksf> and lisp is impure
09:15:38 <benmachine> it's hard to imagine a lazy impure language
09:15:52 <ksf> according to spj it's impossible
09:15:55 <edwardk_> rajeshsr: the type system comes with a lot of attendant benefits: you can use type inference to drive 'instance' selection, so you can do more overloading. In scheme, ironically you must be more explicit due to the lack of types.
09:16:19 <dankna> ksf: so effectively it builds a DFA represented as a bunch of maps of continuations?
09:16:52 <rajeshsr> edwardk, oh, ok!
09:16:53 <Toxaris> can someone explain mutual binding groups and RelaxedPolyRec?
09:16:56 <edwardk_> rajeshsr: otoh, in exchange you need to use some heavyweight machinery in order to make lists that contain multiple types
09:17:03 <ksf> I would say yes if I were sure about the terminology.
09:17:03 <rajeshsr> BTW, isn't pure == lazy ?
09:17:11 <benmachine> rajeshsr: no
09:17:13 <ksf> the important part is that it doesn't backtrack, ever.
09:17:22 <dankna> okay, hm
09:17:27 <edwardk_> rajeshsr: lazy => pure is a good bet. the reason is if you're lazy, then you don't know when the effects would happen
09:17:35 <benmachine> pure is about side effects
09:17:39 <edwardk_> rajeshsr: but you can be pure and strict as well
09:17:40 <Toxaris> I'm getting unnecessary and seemingly unrelated constraints for some functions
09:17:40 <benmachine> lazy is about evaluation order
09:18:01 <rajeshsr> too fuzzy! :)
09:18:03 <dankna> now I'm trying to think up a case where a backtracking strategy would need to backtrack... hmm... I'm getting old, this should be easy for me :)
09:18:10 <edwardk_> rajeshsr: you could even be lazy with effects, but it is harder to reason about the idempotence of effects in case you evaluate the same thing multiple times, etc.
09:18:50 <benmachine> rajeshsr: purity just means you can replace any function call with its return value and it will not change the behaviour of the program (not counting space
09:18:53 <benmachine> er
09:19:04 <benmachine> (not counting stack overflows et al)
09:19:05 <edwardk_> danke: http://www.mail-archive.com/haskell-cafe@haskell.org/msg69727.html uses backtracking to tell you if a reference 'will be used' in the future calculation, while still running the monad
09:19:11 <rajeshsr> referential transparency == pure?
09:19:19 <ksf> yep
09:19:28 <rajeshsr> good!
09:19:30 <dankna> edwardke: my nick is dankna not danke, but danke for that :)
09:20:06 <edwardk_> dankna: was mostly concerned with getting the link right ;)
09:20:09 <dankna> haha yeah
09:21:04 <edwardk_> purity makes a lot more compiler optimizations feasible. the compiler can freely reorder two things it has to do for the most part, because there are few if any synchronization points
09:21:19 <edwardk_> imperative code on the other hand requires a lot of work to reorder anything
09:21:22 <dankna> to say nothing of the pointer-aliasing issue
09:22:00 <dankna> the lack of pointers in FORTRAN is the biggest reason it's still used for new projects, heh.  I'm not certain, but I believe that Haskell also doesn't have that problem?
09:22:10 <edwardk_> dankna: they added pointers ;)
09:22:13 <dankna> oh :)
09:22:31 * ksf tries to understand what it means if checkErr results in a Seek request
09:22:39 <deech> dankna: I don't know of FORTRAN being used in *any* new project. Everything I see is Java/C++.
09:22:43 <edwardk_> c99 picked up restrict anyways, so the distinction is largely historical
09:22:46 <dankna> NASA is big on it, deech
09:23:08 <benmachine> edwardk_: well, restrict isn't the most convenient thing to use
09:23:12 <edwardk_> deech: it pops up mostly in scientific computing, there are a lot of libraries wrapping a ton of it, i.e. libcruft in octave, etc.
09:23:17 <deech> dankna: didn't know that either
09:23:29 <edwardk_> benmachine: true, i agree it places the burden on the programmer
09:23:44 <deech> didn't know about NASA, I was under the impression that FORTRAN was still around because a lot of old libraries used it.
09:23:46 <ksf> ...if it's a backwards seek that'd be backtracking, but a forwards seek is _|_
09:23:57 <edwardk_> benmachine: but it at least provides the compiler with the machinery needed to get out of intractable alias analysis scenarios
09:24:04 <superoptimizer> in a modern compilation system with whole program optimization, where all source is available, aliasing is *the* reason code movement is blocked.
09:24:10 <dankna> the legacy problem is an issue with FORTRAN, as it is with most languages, but no, I actually know people who write new code in it
09:24:13 <ksf> ...at least in the general case.
09:24:30 <benmachine> edwardk_: it also provides people who misuse your functions with a billion new ways to introduce completely inexplicable bugs :P
09:24:39 <edwardk_> benmachine: =)
09:24:48 <benmachine> (the fun part: when you try to debug and find that -O0 makes the bug go away)
09:24:50 <deech> so is FORTRAN worth looking into as a language?
09:24:57 <fax> deech, no
09:25:00 <edwardk_> deech: no.
09:25:03 <fax> Fortress will subsume it
09:25:18 * superoptimizer learned FORTRAN 77 back in '85.
09:25:25 <superoptimizer> blech :(
09:25:31 <edwardk_> fortress needs to do better than crawl before i'm willing to concede it any role in scientific computation
09:25:38 <edwardk_> they barely have an interpreter
09:25:45 <superoptimizer> I thought Fortress had effectively been cancelled.
09:25:59 <edwardk_> i agree that the generator/reducer model of fortress is probably the right way to think about that class of problem though
09:26:02 <fax> superoptimizer huh??
09:26:06 <edwardk_> (as evidenced by the fact that i stole it for haskell)
09:26:20 <benmachine> heheh
09:26:23 <edwardk_> superoptimizer: the fortress guys are a mile down the road from me, but i haven't heard anything one way or the other
09:26:32 <fax> http://projectfortress.sun.com/Projects/Community/blog
09:26:35 <fax> still alive!!
09:26:39 <superoptimizer> fax: At some point I went looking for an update on the project and found something that said that it was on hold.
09:26:44 <superoptimizer> fax: Interesting.
09:26:45 <fax> figuring out syntax for if...
09:27:21 <superoptimizer> I was very hopeful about it when it was first announced. It's been a while, though, no? Like 7 years?
09:27:21 <edwardk_> fax: and iirc i talked to at least one of the guys from there since that date
09:27:38 <dankna> *Yoctoparsec> dbgParse ((many (many ((option (toks "ab") "") <* toks "xyz"))) <* eof) "abxyz"
09:27:39 <dankna> ^CInterrupted.
09:27:47 <dankna> this is by design, yes? :)
09:27:48 <edwardk_> superoptimizer: they haven't really had much of a team until the last year or so i think
09:27:51 <fax> dude fortress is gonna be cool!!!!!!!
09:27:57 <fax> im pysched
09:28:10 <deech> fax: It looks really pretty.
09:28:51 <edwardk_> fax: i was talking to guy steele about it at NEPLS and he wistfully stated that he wished they had started with haskell and added the fortran like bits rather than started with fortran and tried to add the haskell bits. ;)
09:28:55 <fax> dankna(totally irrelevant.. I just noticed that solving the equation  2x + 4y + 7z = 547  <=>  matching (xx|xxxx|xxxxxxx)* against a string of 547 x's :))
09:29:11 <fax> edwardk_, oh that's interesting :>
09:29:15 <dankna> fax: haha, so it does
09:29:51 <edwardk_> fax: so clearly you should just send the regex to perl. ;)
09:30:02 <maltem> Are there any better abstractions for traversing a directory tree and its file's contents than messing around with System.IO?
09:30:29 <edwardk_> maltem: not that i'm aware of. ultimately there are side effects involved
09:30:45 <maltem> yeah...
09:31:06 <edwardk_> and the machine doesn't typically provide you with a way to freeze a snapshot of the world (though NTFS does)
09:31:13 <edwardk_> so it'd be hard to get a functional representation
09:31:23 * benmachine saw a perl regex for calculating prime numbers once
09:32:03 <edwardk_> ("1" * n) !~ /^1?$|^(11+?)\1+$/
09:32:09 <fax> yeah I love that
09:32:21 <dankna> ksf: anyway I'm not really seeing the problem that you worry about in your original example.  I believe your maps of continuations are isomorphic to a DFA, which means they can handle anything regexp-like.
09:32:28 <Alpounet> worse than APL...
09:32:32 <nutz> hi all
09:32:46 <edwardk_> Alpounet: dunno, i can actually READ regexen ;)
09:32:59 <dankna> ksf: my "many many" that causes it to hang would probably do the same to any regexp engine, which is why it's not allowed by most
09:33:20 <ddarius> J is not too bad once you get used to it.
09:33:29 <edwardk_> though it does have the apl problem -- user extensions to the syntax never feel like the native regex syntax, {{{ }}} or whatever remains largely second class
09:33:37 <nutz> i'm trying to divide a Double by (length something), however i get: Couldn't match expected type `Double' against inferred type `Int'.  can i cast that Int to Double? or can i use something else but "/" or "div"
09:33:38 <nutz> ?
09:33:59 <edwardk_> nutz f / fromIntegral (length foo)
09:34:06 <Cale> nutz: You can convert (not cast) the Int to Double using fromIntegral
09:34:07 <edwardk_> @type fromIntegral
09:34:08 <lambdabot> forall a b. (Integral a, Num b) => a -> b
09:34:21 <edwardk_> Ints are not Doubles, but Int is Integral, and Double is Num.
09:34:25 <benmachine> @quote fromIntegral
09:34:25 <lambdabot> lilac says: <drdozer> gha! I'm drowning in the haskell number hierarchy again <lilac> drdozer: magic 8-ball says 'add calls to fromIntegral'
09:34:29 <benmachine> hmm
09:34:34 <nutz> nice - thanks, guys
09:34:38 <Alpounet> edwardk, hmm... if you say so :p
09:34:38 <benmachine> @quote monochrom fromIntegral
09:34:39 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
09:34:42 <benmachine> there we go
09:34:57 <MisterN> :t fromIntegral
09:34:58 <lambdabot> forall a b. (Integral a, Num b) => a -> b
09:35:07 <Mathnerd314> how do I put a forall in an instance declaration?
09:35:20 <nutz> thanks a bunch
09:35:22 <nutz> off i go again
09:35:23 <MisterN> Mathnerd314: you don't have to, i think
09:35:26 <nutz> have a nice day everyone
09:35:31 <benmachine> did anyone mention genericLength
09:35:35 <benmachine> :t genericLength
09:35:36 <lambdabot> forall b i. (Num i) => [b] -> i
09:35:56 <benmachine> and Doubles are Nums
09:36:07 <MisterN> what's the best way to compute the binomial coefficient? :)
09:36:14 <edwardk_> benmachine: genericLength is generally a lot slower than doing the fromIntegral . length though
09:36:16 <nutz> benmachine: ah neat .. howeveR:  Not in scope: `genericLength'
09:36:24 <Mathnerd314> MisterN: unqualified variables are "rigid", so they don't have the same effect
09:36:28 <edwardk_> nutz: it is in Data.List
09:36:28 <benmachine> nutz: Data.List, but listen to edwardk_
09:36:50 <nutz> yep - it's more helpful anyways, because fromIntegral can be used for more than just this problem
09:36:57 <MisterN> Mathnerd314: oh i don't understand that yet
09:37:19 <nutz> alrighty - byebye :)
09:37:26 <ddarius> But what if you have more than a few billion elements?
09:37:33 <MisterN> isn't fromIntegral implicitly called whenever there is a literal in the haskell source?
09:37:41 <benmachine> no, fromInteger is
09:37:52 <benmachine> well
09:37:56 <benmachine> for integer literals
09:37:58 <MisterN> :t fromInteger
09:37:59 <lambdabot> forall a. (Num a) => Integer -> a
09:38:05 <benmachine> for fractional literals I believe it uses fromRational
09:38:06 <MisterN> ic
09:38:12 <ddarius> @src fromIntegral
09:38:13 <lambdabot> fromIntegral = fromInteger . toInteger
09:38:14 <MisterN> almost same name
09:38:28 <MisterN> @src toInteger
09:38:28 <lambdabot> Source not found. The more you drive -- the dumber you get.
09:38:32 <MisterN> :t toInteger
09:38:33 <lambdabot> forall a. (Integral a) => a -> Integer
09:38:52 <MisterN> toInteger is in class Integral?
09:38:59 <ddarius> Yes.
09:44:49 <ksf> I think the grammar where the parser blew was many (' ' <$ ((optional . toks $ "\r\n") *> (some . anyOf " \t"))))
09:45:04 <ksf> (which is a HTTP header continuation-newline.
09:45:29 <ksf> I've changed some things in the parser in the meantime, though, but nothing to actually repair it.
09:45:35 <fax> too much brackets
09:47:00 <ksf> or was it () <$ (((toks "\r\n") *> (some . anyOf $ tSP ++ tHT)) <|> (some . anyOf $ tSP ++ tHT))   and I changed the grammar to fix it?
09:48:29 <dankna> ksf hmm
09:49:04 <ksf> in theory, both should result in the same DFA
09:49:07 <edwardk_> hrmm i wonder if there are good rewrite rules on fromIntegral for things like Int -> Double
09:49:20 <edwardk_> well
09:49:24 <edwardk_> it'll probably optimize away
09:49:32 <ddarius> There are.
09:49:55 <edwardk_> since it'll generate a S# Int, which the fromInteger (S# x) = ... would do the write thing regardless
09:50:09 <edwardk_> so even if there aren't with a bit of inlining it would effectively translate into one
09:50:32 <edwardk_> er the right thing
09:50:50 <dankna> ksf: the main restriction I think is that you can't do many on something that could be empty
09:50:58 <dankna> ksf: which neither of those two seems to be doing
09:51:16 <dankna> ksf: I would try to throw an error at the time the parser is constructed for cases where the user is trying to do that, if it's possible
09:52:12 <dankna> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24323#a24323 -- my own problem :)
09:52:12 <dankna> does Happy simply not support this case?
09:52:12 <dankna> if not, why not?
09:53:00 <ksf> I can roll my own many, but that wouldn't keep people from using recursion
09:53:28 <edwardk_> interesting, the only fromIntegral optimization i found was Int->Int, so i'd guess the above does come from inlining.
09:53:34 <edwardk_> way to trust the compiler! =)
09:53:35 <ksf> frisbee uses a monadfix to construct mutually recursive parsers iirc
09:53:40 <dankna> hmm
09:54:20 <c_wraith> I've still yet to run into MonadFix and mdo in situations I can understand.
09:55:17 <jmcarthur> c_wraith: last time i used it was to create a self-referential IORef
09:55:26 <edwardk_> mdo is nice because it shrinks the size of the fixpoint as it can
09:55:27 <ksf> one possible attack vector as I see it on the header grammar above is to first send "\r\n                                                              \r\n ", then "\r\n \r\n                                    " and so on.
09:55:34 <c_wraith> jmcarthur: what's the type of that?
09:55:43 <Toxaris> Why are all the Control.Arrow operations in a single type class? I have a Control.Category here which would support first, second and *** just fine, but neither arr nor &&&.
09:55:55 <ksf> mdo is deprecated
09:55:58 <ksf> there's rec do now.
09:55:59 <jmcarthur> c_wraith: well, the IORef didn't simply contain itself. it contained an action that operated on itself
09:56:00 <edwardk_> toxaris: look in category-extras
09:56:21 <edwardk_> http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Category-Cartesian.html
09:56:22 <c_wraith> jmcarthur: ah, that makes more sense
09:56:58 <Cale> There are meaningful instances of Control.Category? ;)
09:57:04 <ksf> I don't like parser generators.
09:57:13 <ksf> all I get out of them is shift/reduce errors.
09:57:18 <dankna> ksf: so I gathered, based on the fact that you're writing your own :)
09:57:22 <zygoloid> Cale: sure. (->).
09:57:26 <zygoloid> ;-)
09:57:28 <jmcarthur> Cale: i use Control.Category quite often, actually
09:57:34 <Cale> zygoloid: Well, apart from that one.
09:57:35 <jmcarthur> for DSLs, mainly
09:57:38 <edwardk_> toxaris: or rather http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Functor.html since you seem to be describing a bifunctor in your category
09:57:42 <dankna> I don't think there's any way around understanding what shift/reduce errors mean, though
09:57:48 <Cale> I find it really weird and misnamed.
09:57:49 <dankna> apart from using a more restricted class of grammar
09:58:06 <dankna> which is what you're doing, I guess
09:58:17 <Cale> There's that stuff about labels
09:58:21 <abbe> Hi everyone
09:58:25 <Cale> hi
09:58:36 * abbe is having issues with lazy evaluation in the code at http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24324#a24324
09:58:40 <abbe> hello Cale
09:58:46 <ksf> the purpose of Yoctoparsec isn't to parse a lot of stuff, but to make iteratee code a bit more tractable.
09:59:09 <ksf> ...and iteratees and backtracking just don't go well together.
09:59:15 <edwardk_> i was sad when i realized how far short of a cartesian closed category labels fell, but the rational makes perfect sense in retrospect
09:59:32 <ksf> it can be done, but my data comes over the network and I don't want to cache it.
09:59:37 <edwardk_> ksf: they do, you just need to redefine the notion of iteratee ;)
09:59:37 <Cale> abbe: Oh, don't use hGetContents with withFile
09:59:42 <edwardk_> ksf: yeah
09:59:43 <dankna> ksf: reasonable enough
09:59:55 <abbe> Cale: earlier I was using readFile, but that resulted 'Too many files' open error.
10:00:04 <Cale> abbe: In general, you should never close a filehandle that's had hGetContents applied to it
10:00:16 <edwardk_> ksf: i'm finding i need to define my own attoparsec. =/ my failure type is just a hair bigger than the bytestring they support
10:00:45 <ksf> edwardk_, feel free to extend Yoctoparsec with proper error handling
10:00:53 <jmcarthur> abbe: such is the problem with lazy IO. at the worst you could just use strict IO, or you could go through the trouble of learning something like iteratees
10:00:56 <Cale> abbe: btw,  x >>= return . f  is the same as  fmap f x
10:01:14 <jmcarthur> lazy IO is useful, but in cases where i'm going to opening an unknown number of files, i avoid it
10:01:18 <edwardk_> ksf: my error handling needs are somewhat exotic and pertain to the nature of position monoidal annotations on my ropes ;)
10:01:48 <abbe> jmcarthur: okay, i conclued if I change '(return . isExpirableMail t)' to '(\l -> return $! isExpireMail t l)' the code works.
10:01:51 <edwardk_> ksf: but the short version of what i need from the parser is resumability ala iteratees and a byte index of where relative to the start of the stream the error occurred
10:02:00 <Cale> It seems really stupid to me that OSes place such draconian restrictions on the number of open filehandles.
10:02:02 <edwardk_> the rest is taken care of by the driver.
10:02:03 <abbe> jmcarthur: I'm wondering if this is the right way.
10:02:18 <jmcarthur> abbe: strictness is really the only way to control lazy IO
10:02:19 <Cale> Why shouldn't I be able to fill all my available memory with filehandles if I want?
10:02:37 <ksf> edwardk_, that can be arranged for. yoctoparsecs main function is P t a -> IterateeG s t m (P t a)
10:02:57 <Cale> It seems like such a stupid design flaw that there would be any hard limit at all.
10:02:58 <edwardk_> ksf: how is performance?
10:03:06 <Botje> Cale: probably to mask the fact that some filehandle operations are O(n)
10:03:07 <ksf> I don't know anythnig faster
10:03:09 <edwardk_> cale: "select"
10:03:16 <Botje> case in point: select()
10:03:19 <ksf> ...for the types of grammars it supports, that is.
10:03:32 <Cale> That still seems stupid.
10:03:38 <edwardk_> cale: the problem was the design of FD_SET()
10:03:39 <abbe> jmcarthur: oh, so you mean this is not the correct way ?
10:03:41 <ksf> it doesn't backtrack and uses O(log choices) time per input token.
10:03:51 <Cale> Just fix it and deprecate select.
10:04:05 <edwardk_> cale: we have poll, but honestly there are times when select is more efficient
10:04:23 <edwardk_> cale: less pointer chasing, etc.
10:04:31 <jmcarthur> abbe: if you are going to use lazy IO, using strictness as you are is the *only* way to control it. to say that isn't correct would be to leave you no other option
10:04:32 * hackagebot yi 0.6.2.2 - The Haskell-Scriptable Editor  http://hackage.haskell.org/package/yi-0.6.2.2 (JeffWheeler)
10:04:33 <edwardk_> you just run along bit block of bits
10:04:58 <Cale> edwardk_: There are reasonably efficient set datastructures out there.
10:04:59 <jeffwheeler> Yay! Yi!
10:05:01 <abbe> okay, thanks jmcarthur and Cale
10:05:05 <jmcarthur> abbe: if i don't know how many files i will be opening statically, i usually just work around the whole issue by avoiding lazy IO in the first place, but that's just me
10:05:06 <jlouis> Cale: the fdesc limit is mostly historic to unix
10:05:11 <dankna> jeffwheeler, congrats on the release
10:05:25 <jlouis> catch the program before it is too late was the general idea
10:05:28 <edwardk_> i spent a long time in the early 90s rewriting a mud to run as multiple processes so i could get around the file descriptor limits. ;)
10:05:28 <jeffwheeler> dankna: thanks; I really want it to not die :)
10:05:39 <Cale> abbe: It's easy enough to write a strict version of hGetContents using a strict bytestring and the unpack function.
10:05:58 <abbe> okay. I'm wondering why hGetContents behaves like that, as I straced my original code (the lazy version), I noticed there is no read(..) invoked, just open(), stat(), close().
10:06:13 <Cale> (the strict bytestring library has a strictified version of hGetContents which reads the entire file immediately -- it also has a strict version of readFile)
10:06:33 <abbe> okay, I'll look into that.
10:06:42 <Cale> abbe: Because it's magic. It produces a magical string which reads the file as it is *evaluated*
10:06:42 <ksf> there's also bytestring-mmap
10:06:59 <dankna> solved my Happy problem.
10:07:04 <dankna> it was a silly mistake, nothing deep.
10:07:06 <edwardk_> abbe: lazy hGetContents is based on flawed reasoning. there are so few cases that it is actually applicable, that the convenience of being able to dash off a 5 line haskell program that does perlish things is usually outweighed by its unusability in the large
10:07:10 <abbe> Cale: so you mean it returns a thunk which needs to be evaluatied.
10:07:12 <Toxaris> edwardk_: Is there an entry point to category-extra's documentation, explaining the overall design?
10:07:21 <Cale> abbe: So that hGetContents immediately returns a String value regardless of how large the file is, and it's only when you pattern match on that string that the I/O happens.
10:07:40 <Cale> But it's not a standard String value, it's got I/O embedded in it.
10:07:40 <jmcarthur> abbe: not only that, each character and list constructor is a thunk
10:07:40 <edwardk_> Toxaris: mostly IRC. it is probably best if you think of category-extras as 7 packages. ;)
10:07:53 <jmcarthur> or perhaps just each list constructor
10:08:05 <jmcarthur> @src hGetContents
10:08:06 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
10:08:11 <Cale> So you couldn't really write hGetContents in a normal way without using low-level stuff.
10:08:24 <Cale> (in particular, you'd need unsafeInterleaveIO)
10:08:32 <edwardk_> Toxaris: Control.Category.* is one isolated chunk. Control.Morphism.* is another largely isolated chunk. the rest of it is a mish-mash of functors and monads/comonads derived from them.
10:08:42 * jmcarthur doesn't think of unsafeInterleaveIO as low-level. it's just unsafe
10:09:00 <abbe> As I see from strace output, open and close operations are taking place, just not read, so which means monad is being evaluated, and hGetContents also gets evaluated, just curious how it delays being evaluated.
10:09:03 <jmcarthur> perhaps it could be considered low-level for its unsafety though, from a certain point of view. whatever
10:09:16 <edwardk_> I still think the right abstraction is something closer to 'ListT done right'
10:09:20 <edwardk_> or iteratees
10:09:23 * Cale thinks of unsafeInterleaveIO and unsafePerformIO as being for those times where you'd otherwise have to modify the compiler to get something done.
10:09:24 <maltem> It's low-level in the sense that it talks to the RTS
10:09:42 <Liskni_si> is there any way to force a running program (that got stuck on some syscall, for example) to dump the current cost centre stack just like it would do if an exception was raised and -xc RTS flag was given?
10:10:16 <ksf> Liskni_si, by throwing an exception?
10:10:19 <Cale> Liskni_si: I don't think so. Especially not if it wasn't compiled for profiling in the first place...
10:10:44 <abbe> All I meant was if monad gets evaluated then I should get the result...hGetContents seems highly magical :(
10:10:45 <Liskni_si> Cale: it is compiled for profiling
10:10:50 <Cale> abbe: It is.
10:10:52 <Liskni_si> ksf: can I do that from outside?
10:11:05 <edwardk_> abbe: that is the problem with it
10:11:11 <ksf> try throwing an asynchronous exception to the thread
10:11:22 <Cale> abbe: You want an action which *actually* reads the file when executed.
10:11:51 <Liskni_si> ksf: does that work across the unix process boundary?
10:11:58 <abbe> Cale: yes, I think I should try your ByteString suggestion...
10:11:59 <ksf> nope
10:12:21 <Liskni_si> that's bad :/
10:12:21 <ksf> but you can have a haskell thread listen on a socket or something
10:12:34 <Cale> abbe: I think there ought to be a readFile' and hGetContents' which do this, but it's easy enough to  import qualified Data.ByteString.Char8 as BS  and then  readFile' = BS.unpack . BS.readFile
10:12:39 <ksf> or a sigUSR handler
10:12:48 <Liskni_si> the problem is that I can't stop and recompile, it's running, it's stuck and I want the stack trace now :-)
10:12:55 <Cale> er, oops
10:13:02 <Cale> readFile' = fmap BS.unpack . BS.readFile
10:13:09 <Cale> (of course)
10:13:11 <abbe> Cale: but won't that BS.readFile cause 'Too many open files' ?
10:13:15 <Cale> no
10:13:30 <Cale> It opens the file, reads the whole thing in one gulp and closes it
10:13:38 <benmachine> is the interrupt exception a SIGINT handler or a ctrl-C handler?
10:13:41 <Cale> It will however, use a lot of memory if the files are large.
10:13:48 <abbe> Cale: okay
10:14:08 <edwardk_> that reminds me i didn't add the readfile nonsense to my rope lib
10:14:10 <benmachine> or wait does ctrl-C even raise an exception or am I just thinking of python
10:14:23 <Cale> That's what I mean about the strict bytestring version of readFile -- it behaves differently than the magical String one.
10:14:25 <benmachine> oh, UserInterrupt
10:14:27 <abbe> Cale: well, I think using $! is good for now, since I just wanted to read first few lines...
10:14:32 <Becquerel> snakes on the brain
10:14:40 <abbe> thanks for the help :) #haskell rocks :)
10:14:41 <sioraiocht> does anyone know if there is a current maintainer of the fingertree library
10:14:42 <Cale> abbe: That is awkward to get rihght.
10:14:44 <Cale> right*
10:15:03 <Cale> But it might work :)
10:15:03 <edwardk_> sioraiocht: ross paterson
10:15:08 <sioraiocht> okay
10:15:12 <sioraiocht> cool
10:15:21 <edwardk_> sioraiocht: he updated it when i mentioned it should have a monoid instance last year some time ;)
10:15:27 <sioraiocht> yeah
10:15:32 <sioraiocht> was wondering about that
10:15:52 <Liskni_si> benmachine: that's a good idea, but unfortunately it doesn't print the trace :(
10:15:54 <edwardk_> sioraiocht: actually, even better he just saw that i had a monoid instance in my module of 'definitions other people should have made' and just migrated it into fingertree ;)
10:16:12 <sioraiocht> hahaha great
10:16:15 <abbe> If i use $! then I guess that won't cause hGetContents to read whole file ?
10:16:24 <sioraiocht> was noticing that it wasn't getting any attention for a while
10:16:32 <edwardk_> sioraiocht: which of course broke my package, etc. but hey
10:16:32 <sioraiocht> but if ross wrote it, I can trust it ;)
10:16:38 <Cale> abbe: Not necessarily
10:17:04 <Cale> abbe: If you apply f $! x where x is a list, that only forces x to be evaluated up to determining if the top-level constructor is (:) or []
10:17:07 <edwardk_> it is stable. i think louis wasserman added a bunch off methods to data.sequence recently, but not many if any were really applicable to fingertree in general
10:17:10 <Cale> (before applying f)
10:17:16 <sioraiocht> why does Data.Sequence not use it, then
10:17:27 <edwardk_> my biggest problem is that data.fingertree is TOO well encapsulated. sometimes i want the ability to do slightly unsafe things with its guts.
10:17:27 <Liskni_si> benmachine: (it does for a small program, but apparently xmonad messed up the signal handlers or something)
10:17:36 <Cale> abbe: It depends on where you put the $!
10:17:36 <edwardk_> i've had to copy it wholesale at least once for that reason
10:17:39 <abbe> okay
10:17:43 <sioraiocht> edwardk_: This is my complaint it too, actually
10:17:55 <ksf> I think it's meant to be copied
10:17:57 <edwardk_> sioraiocht: data.sequence doesn't need MPTCs, etc to do its job
10:18:07 <sioraiocht> MPTC?
10:18:08 <edwardk_> and it can use unboxed ints
10:18:13 <edwardk_> multiparameter type classes
10:18:15 <sioraiocht> aha
10:18:16 <ksf> ...as it should be hand-specialized to get the best performance
10:18:19 <edwardk_> Measured is an MPTC
10:18:22 <glguy> multiplayer typeclasses?
10:18:24 <edwardk_> so Data.Sequence can be part of base
10:18:32 <sioraiocht> ksf: the way the paper is written would sort of suggest that, yes
10:18:37 <edwardk_> er containers
10:18:40 <edwardk_> which plays nice
10:19:03 <ksf> MPTC are a clear case for h'.
10:19:09 <sioraiocht> dcoutts: ping?
10:19:16 <ksf> ...as are flexible instances and contexts
10:19:25 <edwardk_> my ropes are currently just FingerTree Count Chunk -- where Chunk is a newtype wrapper on ByteString, but my initial version used a custom fingertree that stored the counts unboxed.
10:20:11 <sioraiocht> edwardk_: do you have a ropes library released?
10:20:25 <edwardk_> the reason i'm not using it now, is that that version stored two counts and i dumped the second count (the second count counted utf8 tail bytes)
10:20:27 <edwardk_> yeah
10:20:30 <sioraiocht> where is it?
10:20:38 <edwardk_> http://hackage.haskell.org/package/rope
10:20:39 <sioraiocht> and other there others or is yours more the canonical version?
10:20:41 <edwardk_> i welcome feedback
10:20:53 <edwardk_> i'm shooting for it to be rather canonical
10:21:07 <edwardk_> Data.Rope is a FingerTree of non-empty bytestrings
10:21:21 <edwardk_> Data.Rope.Annotated is .... more interesting
10:21:46 <Toxaris> edwardk_: so I have my category Cat :: * -> * -> *. Then I could make an instance Bifunctor (,) Cat Cat Cat and use bimap as (***). Does that make sense?
10:21:51 <sioraiocht> edwardk_: do you do any merging of Chunks when concatting
10:22:05 <edwardk_> sioraiocht: i do on cons, but not on merge
10:22:09 * ksf got enumerator combinations of non-empty bytestrings
10:22:13 <sioraiocht> edwardk_: okay
10:22:20 <edwardk_> sioraiocht: on cons i try to grow the left most node up to 16 bytes
10:22:24 <sioraiocht> cool
10:22:45 <edwardk_> like cons' in data.bytestring.lazy, but since i'm always strict in my chunks there is no real cost to making 'cons'' the default ;)
10:22:49 <sioraiocht> yeh
10:22:51 <sioraiocht> fair enough
10:22:52 <sioraiocht> okay
10:23:20 <benmachine> ksf: wasn't the thing about MPTCs that we needed either FDs or TFs and no-one could decide which?
10:23:38 <ksf> what's FD and TF?
10:23:42 <edwardk_> it uses a fair bit of polymorphism, so you can cons Chars or Word8s and it does the right thing, and UTF8 encodes the chars, but splitAt, etc take byte offsets.
10:23:43 <ksf> oh wait
10:23:49 <ksf> no they don't need any of them
10:23:49 <benmachine> functional dependencies, type families
10:23:55 <benmachine> well not *need*
10:24:06 <edwardk_> sioraiocht: that lets me avoid having Data.Rope.Char Data.Rope.Word8, etc
10:24:13 <benmachine> but are less useful without
10:24:18 <ksf> fundeps and type families can express different stuff
10:24:20 <edwardk_> sioraiocht: but it also means that 'tail' is not well defined.
10:24:35 <ksf> ...though they have a lot of overlap
10:24:47 <benmachine> ksf: from each other? I was under the impression that they were virtually identical
10:25:10 <edwardk_> benmachine: MPTCs can allow overlappinginstances, which unfortunately aren't possible with type families until we get closed type families
10:25:44 <edwardk_> benmachine: but type families can do things like make the type of the annotation vanish into a data type, providing better abstraction
10:25:59 <edwardk_> benmachine: so while there is a large area of overlap between them they are each useful in different situations
10:26:08 <benmachine> fair enough
10:26:22 * benmachine likes type families
10:26:44 <edwardk_> also, MPTCs are VERY useful when you have complicated interrelations. you can get polynomially (exponentially?) fewer lines of code to write
10:26:52 <edwardk_> i love type families whenever i can use them
10:27:11 <edwardk_> i just can't get away from the last few lines of oleggery needed to deal with TypeEq ;)
10:27:26 <Toxaris> edwardk_: what's the relationship between Control.Functor and Control.Functor.Categorical? I'm confused by the identical descriptions on the haddock pages.
10:28:16 <edwardk_> remember when i said something about 7 packages? 'Control.*.Categorical' is the 'anal retentive' version that some people want, that allow you to work over arbitrary categories with monads, etc.
10:28:20 <ksf> categorical functors are based on zygohistomorphic prepromorphisms.
10:28:29 <edwardk_> with Bifunctors, i was able to just do them right from scratch
10:29:01 <edwardk_> but the rest of the package wants to work well with non-category-extras code, so if i made all my deps on 'CFunctor' or a custom functor, then i wqouldn't work with any third-party monads, etc.
10:29:36 <ksf> edwardk_, category-extra-extras?
10:31:30 <Toxaris> edwardk_: so since I have a category different from Hask, and a central part of my design is a functor from that category to Hask, I could use the *.Categorical version
10:31:37 <edwardk_> ksf: current plan is 'functors' 'monads' 'comonads' 'categories' and then '-extras' versions of the preceding for the exotic stuff.
10:31:51 <edwardk_> Toxaris: exactly.
10:32:20 <edwardk_> Toxaris: and if you want to define monads on your category, you can use the *.Categorical monad as well
10:32:52 <freiksenet> Hello! Is there a couchdb view server written in haskell?
10:33:23 <freiksenet> there is couchdb interface, but it seems to use js view server
10:35:46 <Toxaris> edwardk_: Right now, I do not even know what it means to define monads on some category ... :)
10:37:53 <c_wraith> hmm.  I'm seeing some evidence threads are getting killed without a finally in them handling their death.
10:38:03 <c_wraith> Is this even conceivably possible?
10:38:49 <benmachine> c_wraith: everything is possible :P what is your evidence that they are killed?
10:39:01 <edwardk_> toxaris: consider that you define a monad m with two operations: return :: a -> m a, and bind :: (a -> m b) -> (m a -> m b) -- where i've explicitly flipped around the arguments to (>>=)
10:39:20 <edwardk_> toxaris: all you're doing with working with them over a control.category ~> is defining
10:39:25 <edwardk_> return :: a ~> m a
10:39:39 <edwardk_> and bind :: (a ~> m b) -> m a ~> m b
10:39:59 <edwardk_> (the reason i swapped the args to bind is that if you don't, the story is MUCH harder and involves exponentials and scary things
10:40:18 <dons> notice the 'download' button on http://haskell.org/
10:40:20 <dons> any thoughts?
10:40:40 <edwardk_> looks more like a logo than a button?
10:40:47 <sioraiocht> dons: it's very...squre
10:40:50 <sioraiocht> *squre
10:40:54 <sioraiocht> *ffs square
10:40:56 <sbahra> dons, as edwardk said.
10:41:11 <sbahra> dons, maybe add a clear bevel?
10:41:15 <benmachine> dons: did you replace the Download GHC link instead of the Download Haskell link by accident? (or intentionally?)
10:41:28 <dankna> dons: I like it, but it needs a gradient/bevel/thing
10:41:33 <edwardk_> maybe bevel the outside/put a boring gray background on itto make it look raised and clickable, with a mouseover to invert the bevel to prompt action?
10:41:41 <c_wraith> benmachine: it's indirect.  Basically, with a QSem that's being waited on before forkIO, and being signalled in a finally in the action passed to forkIO...  the system eventually (nondeterministically) stops making progress.  Removing the QSem *apparently* makes it stop failing.
10:41:47 <dons> i'll upload the .svg for people to experiment with
10:42:39 <dons> http://haskell.org/haskellwiki/Image:Button.svg
10:43:25 <sioraiocht> where has dcoutts been, his lack of omnipresence has me unnerved =p
10:43:28 <edwardk_> dons: what ever happened with the bytestring fusion stuff?
10:43:36 <dons> needs to be ported to stream fusoin.
10:44:06 <edwardk_> fair nuff
10:44:29 <freiksenet> so, is it possible to compile arbitary strings to haskell code during runtime?
10:44:32 <freiksenet> of*
10:44:36 <dons> if anyone wants to add bevels etc, inkscapplus the .svg should be pretty easy.
10:44:37 <freiksenet> of haskell code*
10:44:39 <ManateeLazyCat> 我们大家都来翻墙. :)
10:44:41 <dons> freiksenet: an eval() funtion?
10:44:47 <sioraiocht> dons: I know concat doesn't play nice in stream fusion, does append do okay?
10:45:14 <freiksenet> dons: is there such a function?
10:45:27 <dons> append's not so bad.
10:45:34 <sioraiocht> okay
10:45:41 <dons> freiksenet: using the hint package, yes, but it is a *big* design decision
10:45:46 <c_wraith> @hackage hint
10:45:46 <lambdabot> http://hackage.haskell.org/package/hint
10:45:49 <dons> since it will pull in the interpreter into your binary
10:45:52 <edwardk_> well, in our case, concat/append would probably wind up working on the spine, if fusion ran over chunks when going left to right it'd be largely sidestepped
10:46:15 <freiksenet> dons: well basically couchdb view server needs to compile the string that couchdb gives to it
10:46:17 <Toxaris> edwardk_: where does the remaining -> of the type of bind live?
10:46:40 <dons> freiksenet: interpreting it would be safer...
10:46:40 <c_wraith> freiksenet: hint doesn't compile anyway.  It just interprets.
10:46:47 <dons> write an interpreter for the messagges couchdb is sending
10:46:48 <edwardk_> Toxaris: it is in the 'meta language' that is talking about the category.
10:46:56 <dons> e.g. a parser and ADT for the messages
10:47:00 <edwardk_> Toxaris: the two blur together with hask
10:47:01 <dons> and translate those to library calls
10:47:11 <dons> you probably don't actually want arbitrary haskell code coming off the wire
10:47:13 <dons> --very unsafe.
10:47:43 <freiksenet> dons: well the purpose of view server is usually to have possibility to write map/reduce functions in subject language
10:48:15 <freiksenet> I know that it is very unsafe, it is just that there are corresponding view servers in lots of languages, but there is none for haskell, so I wondered why
10:48:30 <dons> well, you can certainly do it via hint
10:48:41 <dons> have you looked at the existing couchdb work in hsakell, btw?
10:48:52 <freiksenet> that would probably be even slower than native JS view server
10:48:55 <freiksenet> dons: I did
10:51:24 <freiksenet> d
10:51:26 <freiksenet> oops
10:51:32 <Toxaris> edwardk_: So i could see a reasonable bind as a constructive proof that I can lift (a ~> m b) arrows to (m a ~> m b) arrows in my category. But this constructive proof may not be represented in my category.
10:51:42 <freiksenet> dons: I just wanted to make some small project to improve my haskell skills
10:51:49 <freiksenet> maybe couchdb view server is quite unappropriate one
10:51:58 <edwardk__> Toxaris: yeah
10:52:02 <Toxaris> edwardk_: from this point of view, flip seems to be deeply magical.
10:52:38 <edwardk__> Toxaris: you're using -> as the meta-language, to reason about the existence of a morphism given the presence of another
10:52:53 <edwardk__> toxaris: flip is a fairly deep bit of magic using exponentials
10:53:23 <edwardk__> toxaris: http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Category-Cartesian-Closed.html
10:53:36 <edwardk__> you need a CCC
10:53:47 <edwardk__> @type flip
10:53:48 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
10:55:22 <MisterN> :t flip
10:55:23 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
10:55:28 <edwardk__> flip becomes a monster like f (a ~> b) ~> Exp (~>) a (f b) -- er though i don't use the type family notation for the type family Exp (~>) in the currently public version of category extras
10:55:37 <edwardk__> In Hask: Exp (->) = (->)
10:56:54 <Taejo> BONUS: it's probably not clear to the average Windows user what "Now navigate to where it's saved and run ghci from there" means (in http://learnyouahaskell.com/starting-out)
10:57:03 <fax> edwardk, when is exp not -> ?
10:57:34 <Toxaris> edwardk: when is (Exp ~>) not ~>?
10:57:39 <fax> is there a 'weird' category I can read about
10:57:52 <fax> yeah Toxaris asks what I meant, better
10:58:09 <edwardk__> in current category-extras terms, it'd be something like flip :: (CCC (~>) prod exp i, CFunctor f (~>) (~>)) => (f a ~> b) ~> exp a (f b)
10:58:49 <edwardk__> Toxaris: because the type of exponentials for a category need not be the category itself. the fact that it can be mostly has to do with the fact that Hask, the environment you're IN is a CCC. :)
10:59:24 <edwardk__> you could see a category in which there were only a small number of objects, so every morphism could be represented by a concrete table of mappings from sources to values.
10:59:49 <edwardk__> so an exponential in that category might just be the table of mappings rather than a real higher order function-like thing
11:00:02 <edwardk__> you just need the machinery to be able to apply, curry and uncurry them
11:00:56 <Toxaris> edwardk: yes I see that in the real world, there are such categories. But since in category-extras, all categories have all Haskell types as objects (or not?), and Hom a b is an Haskell type, it is an object of the category
11:01:12 <babusrini> BONUS, When are "the rest of Functors, Applicative Functors and Monoids, Monads, Monad Transformers" coming?
11:01:26 <edwardk__> take the discrete category perhaps. you can say a lot about its morphisms
11:01:33 <fax> ahh
11:01:39 <Toxaris> edwardk: so I wonder whether there exists a category which has exponentials, but needs a representation different from ~>
11:01:51 * hackagebot leksah-server 0.8.0.4 - Metadata collection for leksah  http://hackage.haskell.org/package/leksah-server-0.8.0.4 (JuergenNicklischFranken)
11:01:59 <MisterN> :t (++)
11:02:00 <lambdabot> forall m. (Monoid m) => m -> m -> m
11:02:01 <fax> so in the finite topos you could have exponentials being tablitures rather than 'actual functions' because they are isomorphic
11:02:05 <fax> ?
11:02:08 <edwardk__> fax: yeah
11:02:13 <fax> cool
11:02:14 <MisterN> ah, good, i feared that ++ would work only on lists
11:02:22 <edwardk__> MisterN: it does =(
11:02:30 <MisterN> edwardk__: it says Monoid there
11:02:30 <Toxaris> MisterN, in your Haskell at home, it probably does
11:02:31 <edwardk__> MisterN: the type here is a pleasant fiction
11:02:44 <MisterN> ghc doesn't support Monoid?
11:02:48 <edwardk__> MisterN: cale has hacked lambdabot to promote his higher order agenda ;)
11:02:56 <Toxaris> :t mappend
11:02:57 <lambdabot> forall a. (Monoid a) => a -> a -> a
11:02:59 <edwardk__> MisterN it does, but (++) is list only
11:03:04 <MisterN> oh
11:03:06 <edwardk__> :t Data.List.(++)
11:03:07 <lambdabot> Couldn't find qualified module.
11:03:10 <MisterN> :(
11:03:12 <edwardk__> :t (Data.List.++)
11:03:13 <Toxaris> MisterN: use mappend instead, it's poor man's name for (++)
11:03:13 <lambdabot> forall a. [a] -> [a] -> [a]
11:03:21 <zygoloid> @type (Prelude.++)
11:03:22 <lambdabot> forall a. [a] -> [a] -> [a]
11:03:28 <MisterN> Toxaris: is there operator syntax for mappend too? :D
11:03:38 <edwardk__> there is a <> proposal in the works
11:03:38 <MisterN> like <++> or something like that
11:03:42 <edwardk__> not sure if it got applied yet
11:03:46 <MisterN> haskellers love operators
11:03:49 <edwardk__> butit won't be 'visible for a year or so
11:04:07 <MisterN> so `mappend` for now?
11:04:08 <Toxaris> MisterN: in some cases, <|> may be appropriate
11:04:13 <edwardk__> or whenever the next platform comes out that includes a version of base that contains it
11:04:14 <MisterN> :t (<|>)
11:04:15 <lambdabot>     Ambiguous occurrence `<|>'
11:04:15 <lambdabot>     It could refer to either `Control.Applicative.<|>', imported from Control.Applicative
11:04:15 <lambdabot>                           or `Lava.<|>', imported from Lava
11:04:27 <edwardk__> Toxaris: <> was the name the libraries@ mailing list converged on
11:04:27 <MisterN> :t (Control.Applicative.<|>)
11:04:28 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f a -> f a
11:04:29 <jlouis> I like how everything is getting built with base 3 rather than base 4
11:04:38 <edwardk__> <|> conflicts with everyone =)
11:04:47 <MisterN> Toxaris: and that works with lists?
11:04:54 <jlouis> why does cabal-install not choose the newest if nothing is specified?
11:05:05 <Toxaris> edwardk: I'm proposing to use the existing Control.Applicative.<|> instead of Data.Monoid.mappend in some cases
11:05:09 <edwardk__> MisterN: there is also mplus as a generalization
11:05:16 <MisterN> :t mplus
11:05:17 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
11:05:20 <edwardk__> Toxaris: yeah, you just can only use it over monoids that have parameters
11:05:34 <Toxaris> edwardk: sure, so not in all cases :)
11:05:35 <edwardk__> or as they are better known, Alternatives ;)
11:05:38 <MisterN> edwardk__: MonadPlus omg i'm not sure if i want to learn yet what that means
11:05:42 <edwardk__> *nods*
11:05:53 <Toxaris> edwardk: unfortunately, Alternative has this stupid Applicative superclass constraint :(
11:06:01 <MisterN> monoids are good and simple i think
11:06:10 <MisterN> @hoogle Monoid
11:06:11 <lambdabot> module Data.Monoid
11:06:11 <lambdabot> Data.Monoid class Monoid a
11:06:26 <Toxaris> MisterN: you could just define your own (<>) = mappend
11:06:48 <MisterN> Toxaris: or maybe i'd be happy enough with `mappend` :)
11:06:53 <zygoloid> Toxaris: what's wrong with the Applicative superclass? for Alternative?
11:07:29 <edwardk__> zygoloid: 'Alternative' is a right seminearring with an extra argument, a monoid has a lot less structure
11:08:15 <edwardk__> iff you have an applicative that never uses its type argument, you have exactly a monoid. in fact that is the Const m Applicative in Control.Applicative
11:08:17 <Toxaris> zygoloid: I am generally annoyed at the inflexibility of the standard typeclasses, e.g. I have a functor from some home-made category to Hask, so it cannot be a Functor. It actually is not applicative. *BUT* it could very well be Alternative, if only Alternative had no superclass constraints
11:08:23 <ksf> they're needed for some and many
11:08:33 <ksf> ...which are typeclass functions so they can be overridden
11:08:34 <zygoloid> edwardk__: i don't understand the relation between your answer and my question
11:08:43 <edwardk__> Toxaris: i have FunctorPlus in category-extras
11:09:06 <edwardk__> zygoloid: the context of his complaint was his desire to just use the <|> and empty for monoid like things
11:09:07 <MisterN> oh cool, Data.Monoid defines Sum and Product
11:09:13 <ksf> I think they should be moved into a third class that depends on Applicative and Alternative
11:09:17 <MisterN> so you can use mappend to replace + and *
11:09:19 <MisterN> \o/
11:09:42 <ksf> .oO( .+. )
11:09:44 <edwardk__> ksf: that gets really tedious in haskell. Every time I go that path I wind up with things like
11:09:57 <ksf> category-extras ;P ?
11:10:28 <MisterN> :t (.+.)
11:10:29 <lambdabot> Not in scope: `.+.'
11:10:35 <edwardk__> classs Monoid m, class Monoid g => Group g, class Multiplicative m; class Multiplicative r, Group r => Ring r -- but o crap now i want a layer in between, so then you wind up factoring into 15 different classes
11:10:37 <MisterN> ksf: there's not .+. :)
11:10:41 <edwardk__> and no one remembers everything they need to define
11:10:50 <ksf> but it's a good name for mappend
11:11:10 <edwardk__> http://hackage.haskell.org/packages/archive/monoids/0.1.36/doc/html/Data-Ring.html
11:11:16 <edwardk__> MisterN: check the vectorspace packages ;)
11:11:24 <Toxaris> edwardk: I don't want to use <|> for monoid like things which are not functorial, I was suggesting to MisterN that maybe a functorial monoid thing is what he wants
11:11:26 <MisterN> edwardk__: what's that?
11:11:51 <MisterN> Toxaris: no no i was just thinking about ++ and wondering whether it works only on lists
11:12:14 <edwardk__> the pasted url was an attempt at indicating to ksf that there is a downward tension on complexity due to the fact that subclasses in haskell can require a lot of manual plumbing/instantiation
11:12:47 <edwardk__> MisterN: in short, mappend or <|> are the current most general instantiations of it
11:13:08 <Toxaris> edwardk: I like your FunctorPlus better then Alternative, but I would need CFunctorPlus.
11:13:09 <edwardk__> mappend works for monoids, <|> works for 'Alternatives' of which every MonadPlus could be made a valid 'Alternative'
11:13:22 <MisterN> edwardk__: will haskellPrime improve these things?
11:13:31 <edwardk__> Toxaris: yeah i never needed a 'Monoid1' ;)
11:13:37 <edwardk__> MisterN: nope
11:13:40 <benmachine> MisterN: there are ideas, but I don't like any of them :P
11:13:43 <MisterN> :(
11:13:54 <MisterN> edwardk__: at least haskellPrime could make ++ use Monoid!
11:14:08 <ksf> it's easy to overstress typeclasses
11:14:09 <edwardk__> MisterN: there are issues with all off the existing class alias proposals that i think will stall them for the forseeable future
11:14:20 <edwardk__> thats one of the things that started me hacking on my toy language, actually ;)
11:14:31 <edwardk__> MisterN: please god no!
11:14:40 <edwardk__> misterN: that would horribly break some code.
11:14:41 <MisterN> why not? lambdabot does it already
11:14:52 <ksf> that's caleskell, not haskell.
11:14:53 <edwardk__> it could generalize it to Applicative
11:15:08 <edwardk__> er Alternative
11:15:15 <ksf> edwardk__, but it would be automatically convertible.
11:15:20 <Alpounet> @ŧype (++)
11:15:21 <lambdabot> forall m. (Monoid m) => m -> m -> m
11:15:24 <Alpounet> heh, yeah
11:15:38 <ksf> though the converter would have to do type inference.
11:15:42 <ManateeLazyCat> Bye all, night. :) Happy fighting GFW!
11:15:50 <edwardk__> While it is theoretically possible for someone to manually define a Monoid instance for EVERY Alternative f, they have to do it manually
11:15:59 <benmachine> what would that break, edwardk?
11:16:02 <MisterN> edwardk__: i wonder if template haskell can be used to fight the complexity :D
11:16:11 <ksf> edwardk__, you can, with UndecidableInstances
11:16:19 <edwardk__> benmachine: there is at least one instance of MonadPlus that disagrees with the associated Monoid instance: Maybe
11:16:39 <benmachine> edwardk__: okay, but nobody uses ++ on Maybes?
11:16:54 <ksf> ...maybe we should have OneWayInstances which works like half a UndecidableInstances: it lets you define _one_ of those instances, but not the other.
11:16:55 <edwardk__> benmachine: my point is that there are two non-obvious generalizations
11:17:12 <benmachine> edwardk__: ah, yes agreed, so pick one
11:17:13 <zygoloid> benmachine: it would break print (return 42 `asTypeOf` fix (join (++))) ;-)
11:17:15 <edwardk__> MisterN: template haskell is how i've fought it in the past
11:17:16 <benmachine> I like Monoid better
11:17:33 <ksf> but doing that would wreck havock, as we aren't able not to import instances.
11:17:38 <edwardk__> benmachine: this is the bikeshedding problem that almost killed getting (<>) at all as an alias for ++
11:17:46 <MisterN> benmachine: everybody loves Monoid
11:17:57 <ksf> I don't.
11:17:58 <edwardk__> i don't like (++) better because the haskell 1.4 specification went the MonadPlus route.
11:18:03 <MisterN> ksf: yes you do :P
11:18:03 <edwardk__> they dumbed it down to lists in 98
11:18:10 <benmachine> ah
11:18:11 <edwardk__> so you would have gone through 3 versions
11:18:14 <edwardk__> all completely different
11:18:32 <benmachine> but we don't do backward compatibility
11:18:48 <MisterN> edwardk__: you don't fight it with template haskell anymore?
11:18:49 <edwardk__> and (++) on lists has the benefit that it doesn't have to potentially build a new dictionary based on each argument type
11:19:19 <ksf> .oO( sufficiently smart compiler )
11:20:15 <edwardk__> my point is that it isn't open and shut that (++) should become mappend, it is a significant drift in semantics, there is already a passed library proposal giving another short name to mappend
11:20:34 <benmachine> (<>) is passed?
11:20:35 <edwardk__> so if you want to generalize (++), the obvious direction is to Alternative, or to some weaker non-existant FunctorPlus or Monoid1
11:20:48 <edwardk__> i thought it was, i haven't looked at it in a long time
11:20:53 <edwardk__> i think there was even a patch
11:20:59 <MisterN> in the end i guess the existing ++ is ok because we can always define new operators
11:21:06 <ksf> what about generalising it to Sequence a => a?
11:21:09 <edwardk__> but the latter two are nonstarters, because of the lack of existing instances
11:21:18 <ksf> er Sequence s a
11:21:26 <edwardk__> and the fact that alternative has no usable superclass over than applicative/functor which are insufficient
11:21:51 <MisterN> @hoogle Monoid1
11:21:51 <lambdabot> No results found
11:21:53 <edwardk__> ksf: i have plenty of monads i'd use it on that aren't sequences
11:21:58 <ksf> while we're at it, unify the interfaces of Data.Sequence and List
11:22:00 * hackagebot leksah 0.8.0.4 - Haskell IDE written in Haskell  http://hackage.haskell.org/package/leksah-0.8.0.4 (JuergenNicklischFranken)
11:22:08 <MisterN> what is Monoid1?
11:22:20 <FliPPeh_1> wow, a leksah release
11:22:26 <benmachine> MisterN: something like Alternative but without Applicative, I'd have thought
11:22:36 <FliPPeh_1> The last ones always failed for me
11:22:47 <MisterN> @hoogle Alternative
11:22:47 <lambdabot> Control.Applicative class Applicative f => Alternative f
11:22:47 <lambdabot> Language.Haskell.ParseMonad alternative :: Lex a v -> Lex a (Lex a v)
11:22:52 <edwardk__> MisterN: a fictitious class i made up on the spot. class Monoid1 f where mempty1 :: f a; mappend1 :: f a -> f a -> f a -- the theoretical minimum requirement to be a monoid for all arguments regardless of any constraints
11:23:02 <edwardk__> the 'free monoid' of kind * -> *
11:23:16 <Toxaris> of course, what I really want is to have a class constraint like (forall a . Monoid (f a)), but I guess that goes too far
11:23:31 <MisterN> edwardk__: why did you remove mconcat?
11:23:38 <ksf> edwardk__, more than one monoid class, with <0> ... <N>?
11:23:39 <MisterN> edwardk__: mconcat has a default implementation, no?
11:23:44 <edwardk__> MisterN: because mconcat is not strictly necessary ;)
11:23:57 <edwardk__> MisterN: it is an efficiency optimization, a nice to have
11:24:05 <MisterN> yeah why remove it?
11:24:14 <ksf> there's a gazillion of types that form more than one monoid.
11:24:15 <edwardk__> no reason other than the line was too long and i'd made the point =)
11:24:35 <MisterN> edwardk__: so Monoid is good enough?
11:24:51 <zygoloid> why "class Monoid1 f" rather than "instance Monoid (f a)" ?
11:25:31 <edwardk__> zygoloid: because i can't always right that definition in the code wherever i could write Monoid1. what if i need to use the dictionary instantiated with several arguments?
11:25:36 <Toxaris> zygoloid: so that as a library author, I can force my clients to implement the instance for some f
11:26:16 <zygoloid> edwardk__: i see. you want to avoid exposing the type of things inside containers which you mappend. that makes sense.
11:26:38 <benmachine> edwardk__: hold on, you can't mplus [Bool] and [Integer]
11:26:54 <mreh> is the ACO generally considered faster than A*?
11:29:25 <edwardk__> benmachine: no, but given Monoid1 m => m a -> (a -> b) -> m b -> (b -> a) -> m a  -- i may wind up using that monoid instance over 'm a's  and 'm b's or potentially an unbounded number of types
11:30:08 <edwardk__> Monoid1 m => m a -> (a -> f a) -> (f a -> a) -> m a -- which types am i using the Monoid1 over?
11:30:31 <edwardk__> er Monoid1 m => a -> (a -> f a) -> (f a -> a) -> m a
11:31:00 <edwardk__> i could need the Monoid (m a), Monoid (m (f a)), Monoid (m (f (f a))), ...
11:31:33 <ksf> could it be that all that stuff is way too general to fit into a standard library?
11:31:41 <edwardk__> ksf: yes
11:31:54 <ksf> especially since it's only a couple of lines.
11:31:57 <edwardk__> ksf: i wouldn't define Monoid1, it is an interesting curiosity ;)
11:32:01 <Toxaris> into a standard library structured with Haskell type classes, yes
11:32:09 <pokoko222> general cs question: today is expected from the computer science guy to master databases and web servers? it is considered essential skill, correct?
11:32:12 <pokoko222> for any area
11:32:15 <edwardk__> the prelude cares nothing for non-Functors of kind * -> *
11:32:23 <edwardk__> so Monoid1 is too pedantic
11:32:28 <dankna> dons: my take on the download button: http://dankna.com/himitsu/Button.png (master in http://dankna.com/himitsu/Button.psd )
11:32:33 <ksf> ...we've got a finite supply of unique symbols.
11:32:53 <benmachine> edwardk__: Set?
11:32:57 <Toxaris> but I think a future standard library structured using some future cool mechanisms should use Functor and Monoid1 and Applicative to mix Alternative together
11:33:00 <ksf> if not because of finite computer memory, then because of my impatience.
11:33:09 <MisterN> dankna: in that size, it feels like an imperative :D
11:33:13 <dankna> haha :D
11:33:14 <edwardk__> pokoko222: most cs guys i know also know a fair bit of 'IT' and how to deal with such mundane concerns yes. is it required for 'computer science'? not necessarily, but you'll needd to be well rounded
11:33:23 <Toxaris> component-based standard library design
11:33:37 <dankna> it's big because it's raster and raster images are only good as masters if they're, er, really big :)
11:33:41 <ksf> edwardk__, I'd rather like to see a Monad class that plays well with IxMonad
11:33:47 <edwardk__> benmachine: Set couldn't be an instance of Monoid1, because its behavior depends on the Ord instance of its argument
11:34:06 <ksf> that is, something like Monad a = forall . i IxMonad i i a
11:34:08 <edwardk__> ksf: you can dream, i guess ;)
11:34:27 <pokoko222> edwardk__ i guess sql and apache would be enough to learn
11:34:32 <Mathnerd314> wait, why does Set need Ord?
11:34:32 <edwardk__> ksf: can't define instances on that
11:34:43 <c_wraith> Mathnerd: implementation detail, sadly
11:34:47 <edwardk__> Mathnerd314: Set (a -> b) -- give me all the unique members, go ;)
11:35:07 <c_wraith> Though I guess Set would depend on Eq necessarily
11:35:19 <edwardk__> c_wraith: you could build a set that does.
11:35:19 <c_wraith> Ord is an implementation detail, but Eq is a requirment
11:35:36 <ksf> and a separate UndecidableInstances for type families.
11:35:51 <edwardk__> actually, you CAN build a very nasty Set that doesn't even need that. using stablenames, but it is very hard to look things up in it ;)
11:35:51 <Toxaris> c_wraith, Mathnerd314: since methods from Eq show up in the specification
11:35:53 <ksf> ...and better totality checking.
11:36:33 <edwardk__> i've used a StableSet and StableMap before
11:36:55 <MisterN> i wondered: is it possible to make a type like Double but without silent NaN?
11:37:05 <edwardk__> nicely you even get an ordering on the hash of the stablenames to give structure to it so you spend little time doing linear scans
11:37:12 <c_wraith> MisterN: that should be pretty easy.
11:37:18 <edwardk__> MisterN: sure.
11:37:42 <MisterN> the constructor would just error when the value is NaN?
11:37:43 <Mathnerd314> oh, I see... my definition of set requires some more language support
11:37:45 <edwardk__> data BigFloat = BigFloat { exponent :: Integer, mantissa ::  Integer }
11:38:02 <edwardk__> MisterN: or you make your division operator return Maybe BigFloat
11:38:25 <edwardk__> MisterN: i have an arbitrary precision 'double' here actually. i use it for sets of enumerables ;)
11:38:37 * Mathnerd314 wants infinite sets
11:38:43 <edwardk__> when you tend to have closely grouped ranges
11:38:57 <edwardk__> http://hackage.haskell.org/packages/archive/monoids/0.1.36/doc/html/Data-Ring-Semi-BitSet.html
11:39:23 <edwardk__> nicely by choosing the way you represent the mantissa well, you can make that into a full semiring, and represent the entire universe minus a set as well.
11:39:49 <edwardk__> negative mantissas in 2s complement representation have all but a finite number of bit locations as 1s.
11:40:31 <edwardk__> so you can think of a bitset there as a 'floating point' representation of set membership. an exponent that indicates the first member, and a mantissa that defines the values of the bits from there.
11:40:46 <edwardk__> works well for Char ranges, even in utf8.
11:41:02 <edwardk__> O(1) membership testing. fairly expensive if the ranges get big though
11:41:27 <edwardk__> Mathnerd314: have you seen the monad for searching infinite sets in finite time? =)
11:41:40 <Mathnerd314> yeah... was just googling for it again
11:41:44 <Toxaris> edwardk: I have too get home now, thanks for your time. I will look into whether I can make use of category-extras, and probably try to get hold of you again, asking more questions. bye.
11:41:55 <edwardk__> http://math.andrej.com/2008/11/21/a-haskell-monad-for-infinite-search-in-finite-time/
11:42:12 <edwardk__> there is a generalization, the index doesn't have to be Bool
11:42:58 <edwardk__> Toxaris: happy to help =)
11:43:25 <ksf> hmmm I guess I should get rid of Alternative and implement my own some and many, not based on lists but as enumerators.
11:44:06 <edwardk__> brb
11:44:50 <ksf> what's annoying is that enumerator composition is completely monoidal. that is, you can't combine two enumerators with different chunk types and have that return a third.
11:46:56 <ksf> sometimes it's not even sensible to have a chunk size larger than one element.
11:48:14 <maltem> @tell dolio Thanks for the wiki article on the CC monad (that you wrote three years ago, apparently), that's one helpful piece of information!
11:48:15 <lambdabot> Consider it noted.
11:49:57 <fax> Catsters "There aren't enough letters of the alphabet!!"
11:50:44 <ksf> "let A be an alphabet with -1 elements"?
11:54:03 <dankna> @tell dons my take on the download button: http://dankna.com/himitsu/Button.png (master in http://dankna.com/himitsu/Button.psd ) - yeah, I know, raster, ick, but.
11:54:03 <lambdabot> Consider it noted.
11:54:29 <Figs> Hello.
11:54:36 <burp> hm, strictly speaking it should be download haskell platform :>
11:54:44 <Figs> I am trying to debug an issue with Cabal.
11:54:44 <monochrom> Exactly as Dijkstra predicted, could have used multiple-letter words for identifiers, if they had not abused juxtaposition for multiplication.
11:54:56 <Figs> Is this the right place to ask for help with that?
11:55:28 <ksf> if we're going to spread such buttons on the net, there should be _much_ more introductory material on the platform page.
11:55:42 <ksf> that is, platform docs in the first place.
11:55:53 <Figs> (I'm trying to install the SDL-TTF bindings, and cabal fails to link some program called "Version_hsc_make.exe" that it's generated.)
11:56:01 <ksf> like how to open a command prompt and use the rich development environment.
11:56:34 <ksf> hsc2hs needs a c compiler
11:57:11 <ksf> ...I guess the easy way is to install cygwin (and you get a proper shell, too)
11:57:20 <Figs> I have mingw installed. As said, it compiles, but it fails to link. (WinMain@16 is missing). I think it's probably missing the -lmingw32 flag
11:59:11 <ksf> hmm. I don't think you can configure cabal to pass flags to hsc2hs
11:59:19 <ksf> but you can write a wrapper script for it
11:59:55 <ksf> --lflag=-lmingw32
11:59:55 <Figs> I can compile the program manually if I copy the output error and fix the flags, but when I try to resume building, it just ignores the fact that the program already exists.
12:00:10 <ksf> you have to execute the program
12:00:15 <ksf> it's going to output a .hs file
12:00:27 <ksf> ...which cabal expects to be in dist/autogen or something
12:01:40 <sinelaw> howdy, pardners!
12:01:52 <choffstein> Does anyone know of a robust ordinary least squares library in haskell?  I can't find one on hackage.  I could whip one together using hMatrix's QR factorization, but I am lazy...
12:03:25 <fax> what is least squares ?
12:03:52 <burp> hm, hmatrix has least squares afaik :>
12:04:05 <burp> http://hackage.haskell.org/packages/archive/hmatrix/0.8.3.1/doc/html/Numeric-LinearAlgebra-Algorithms.html
12:04:17 <burp> "Least squared error solution of an overconstrained linear system"
12:04:29 <Figs> ok, I ran the version_hsc_make.exe and got a stdout.txt file that looks like a haskell program
12:05:06 <Figs> But I don't know where it's supposed to go, or what I'm supposed to call it.
12:05:31 <ksf> you should be able to figure that out by running cabal build -v
12:05:38 <ksf> it should print the command cabal tried.
12:06:36 <Figs> cabal tried to link the program, but failed to link. So I have no idea what it wants to do with the output of the program.
12:06:48 <burp> choffstein: no? :>
12:06:53 <choffstein> burp: Wow, don't know how I missed that one
12:06:57 <burp> ok
12:06:59 <choffstein> burp: Thanks
12:07:10 <ksf> cabal didn't try to link, it's hsc2hs which does that.
12:07:26 <ksf> ...and cabal tells hsc2hs where to put the final output file.
12:08:21 <Figs> Hmm... ok
12:08:25 * hackagebot applicative-extras 0.1.6 - Instances for Applicative  http://hackage.haskell.org/package/applicative-extras-0.1.6 (ChrisEidhof)
12:08:55 <ksf> and you should report a bug, btw.
12:09:06 <ksf> such flags should get autodetected.
12:09:15 <Figs> Where should I report it to?
12:09:27 <ksf> I've got no idea.
12:09:34 <Figs> haha :p
12:09:41 <ksf> if in doubt, the hsc2hs and cabal lists.
12:09:46 <ksf> let them shift the blame.
12:11:00 <ksf> even worse, the new haskell platform comes with ghc 6.12.1, which broke c2hs.
12:11:10 <ksf> there's going to be a lot of people complaining about that
12:11:34 <ksf> in addition to those who already did, and got ignored.
12:11:40 <Figs> :p
12:11:42 <ksf> like me, for example.
12:12:42 <ksf> ...and all that because some ghc dev thought it's a good idea to remove CLDouble, which is required by the C standard, just because it's merely a synonym for CDouble...
12:12:53 <ksf> er FFI standard
12:18:06 <Zao> ksf: Which C standard?
12:18:40 <Zao> I know C99 has it, but does C90?
12:18:41 <edwardk_> c has standards. c programmers do not ;)
12:19:09 <edwardk_> zao: has what?
12:19:28 <Zao> edwardk_: long double.
12:19:36 <Zao> 20:12 < ksf> ...and all that because some ghc dev thought it's a good idea to remove CLDouble, which is required by the C standard, just because it's merely a synonym for CDouble...
12:19:52 <roconnor> ksf: let's make our own better haskell platform
12:20:04 <Zao> ksf: I could understand doing something about it as it's erroneously was implemented as "meh, it's double".
12:20:13 <Zao> But removing it, that's just silly.
12:21:10 <arcatan> ksf means Haskell FFI spec says there is CLDouble
12:21:11 <edwardk_> yeah ansi c90 lacks long double
12:23:02 <edwardk_> are there any good benchmarks for the list fusion stuff?
12:26:57 <ksf> edwardk_, dons did some
12:27:21 <ksf> but I think you're going to have to benchmark for each program seperately, anyway.
12:27:32 <edwardk_> @tell dons do you have any list fusion microbenchmarks packaged up?
12:27:33 <lambdabot> Consider it noted.
12:27:43 <edwardk_> yeah
12:28:00 <edwardk_> just looking for some microbenchmarks in case I go OCD and start hacking on it ;)
12:31:42 <tensorpudding> Would a bytestring produced through a UTF-8 version of an ASCII string produce a different bytestring than the ASCII version?
12:32:05 <tensorpudding> as in, one that is packed using D.BS.C8.pack
12:32:26 <jmcarthur> a "UTF-8 version of an ASCII string" is the same as just an ASCII string
12:32:58 <tensorpudding> So they are the same.
12:33:02 <tensorpudding> Okay.
12:33:02 <ksf> char8 is the same as Word8
12:33:09 <ksf> Data.Bytestring is strictly bytes.
12:33:25 <ksf> if you want unicode, there's Data.Text
12:33:38 <jmcarthur> tensorpudding: UTF-8 represents ASCII characters exactly the same way that ASCII does, is what i mean
12:33:48 <ksf> ...or you can encode to utf-8 by http://hackage.haskell.org/packages/archive/utf8-string/0.3.6/doc/html/Codec-Binary-UTF8-Generic.html#v%3AtoString
12:34:05 <tensorpudding> I don't want Unicode.
12:34:30 <tensorpudding> I was just wondering if it were true, I'm trying to figure out why this hash isn't producing what it should.
12:37:12 <applicative> edwardk: do you have any trivial example modules for using Data.Rope?
12:37:26 <applicative> edwardk: I'm lost in aabstraction as usual
12:38:27 <Figs> Huh
12:38:30 <Figs> I think I got it
12:39:45 <Figs> So I added a "-lmingw32" into setup-config next to where it has "-lSDLmain", etc. and that let me build Version_hsc_make.exe
12:40:39 <Figs> And it continued chugging along until it blew up with an error about the Main instead of Graphics.UI.SDL.TTF.Version
12:41:14 <Figs> Looking in the files that the Version_hsc_make.exe program generated, both were blank, and there was a stdout.txt file...
12:41:25 <Figs> Horray for SDL.
12:42:07 <Figs> So, if I rename the stdout.txt file to the files it was expecting (Version.hs and Types.hs), then it works
12:42:21 <Figs> Or at least, it builds.
12:42:33 <ksf> I guess cygwin would work better
12:42:48 <ksf> stdout.txt sounds like an awful hack
12:43:16 <Mathnerd314> stdout.txt is standard SDL
12:43:26 <Mathnerd314> you can change it with extreme difficulty
12:43:30 <Mathnerd314> (on windows)
12:44:02 <stepcut> I have two strings, like "foo123" and "123bar", I want to remove from the beginning of the second string, anything that matches the end of the first string. So in this case, I want to get back "bar"..
12:44:09 <ksf> the header files are redirecting printf output?!
12:44:10 <stepcut> > fromJust $ join $ find isJust $ map (\p -> stripPrefix p "123bar") (tails "foo123")
12:44:11 <lambdabot>   "bar"
12:44:21 <stepcut> is there a less convoluted way of doing this?
12:44:43 <Mathnerd314> ksf: http://www.libsdl.org/cgi/docwiki.cgi/FAQ_Console
12:45:15 <ksf> ...but the _hsc.c files don't call sdl_init
12:45:31 <ksf> they just import the headers and do printfs
12:46:43 <Figs> I honestly have no idea what any of this stuff is doing. I've just managed to manually get it to finish building for the first time after about ... 3 hours? of hacking around the build system
12:47:10 <Figs> Why on earth does Cabal need to compile programs to generate programs to build a library?
12:47:24 <Figs> It irritates my anti-virus quite a bit.
12:47:41 <ksf> it's hsc2hs which needs to do that
12:47:47 <heatsink> stepcut: msum = join . find isJust
12:48:09 <ksf> it generates .c files out of .hsc files to piggyback on the c preprocessor to get hold of constants and so on.
12:48:43 <heatsink> > fromJust $ msum [stripPrefix p "123bar" | p <- tails "foo123"]
12:48:44 <lambdabot>   "bar"
12:48:58 <stepcut> heatsink: heh, didn't even think to use msum
12:49:35 <stepcut> heatsink: is there a better algorithm though ?
12:49:56 <zygoloid> > catMaybes [stripPrefix p "123bar" | p <- tails "foo123"]
12:49:57 <lambdabot>   ["bar","123bar"]
12:51:28 <stepcut> zygoloid: yeah, but I need only the first.. I guess I could add !!0, since I know there will always be at least one element in th elist
12:51:36 <zygoloid> > head $ catMaybes [stripPrefix p "123bar" | p <- tails "foo123"]
12:51:37 <lambdabot>   "bar"
12:51:49 <stepcut> or use head ;)
12:52:18 <stepcut> but catMaybes is just msum, right ?
12:52:23 <stepcut> no..
12:52:36 <heatsink> stepcut: I doubt there's a better list algorithm, because none of the (==) tests for checking a prefix of length N is used for checking a prefix of length N+1
12:52:39 <zygoloid> no. catMaybes is more general than msum.
12:52:50 <zygoloid> it returns all the Justs, not just the first.
12:53:10 <gwern> ?src catMaybes
12:53:11 <lambdabot> catMaybes ls = [x | Just x <- ls]
12:55:51 <edwardk_> there is also Data.ByteString.UTF8 if you don't want to change your usage pattern from Data.ByteString.Char
12:56:12 <edwardk_> er whoa that was a somewhat belated reply
12:57:51 <stepcut> how do I write this so it actually compiles, [x | p <- tails "foo123", Just x <- stripPrefix p "123bar"   ]
12:58:03 <stepcut> list comprehensions are not my thing ;)
12:58:31 <edwardk_> hrmm. i wonder if the type level brand stuff i'm using to track that you're dealing with the same rope you took an annotation from when you go to cut the annotation could be used similarly for dealing with uvectors, etc.
12:58:31 <heatsink> :t stripPrefix
12:58:32 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Maybe [a]
12:58:40 <heatsink> stepcut: maybeToList
12:58:59 <gwern> @hoogle [Maybe a] -> [a]
12:58:59 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
12:58:59 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
12:58:59 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
12:59:19 <edwardk_> i.e. a modified uvector with a type level brand based on its length. no real win though, except that it becomes easy to see you can pair up the uvectors without checks
12:59:27 <gwern> > sequence [Just "a", Nothing]
12:59:28 <lambdabot>   Nothing
12:59:35 <gwern> > sequence [Just "a", Nothing, Just "b"]
12:59:36 <lambdabot>   Nothing
12:59:46 <gwern> @src sequence
12:59:47 <lambdabot> sequence []     = return []
12:59:47 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
12:59:47 <lambdabot> --OR
12:59:47 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
13:00:44 <edwardk_> catMaybes basically grafts together with return/mzero and mplus, sequence uses just the multiplication, so any '0' turns the whole result into 0
13:00:48 <heatsink> There's a redundant definition of 'sequence'?
13:00:50 <applicative> > catMaybes  [x | p <- tails "foo123",  x <- stripPrefix p "123bar" ]
13:00:51 <lambdabot>   Couldn't match expected type `[t]'
13:00:51 <lambdabot>         against inferred type `Data.Mayb...
13:01:25 <applicative> > msum [x | p <- tails "foo123", x <- stripPrefix p "123bar" ]
13:01:26 <lambdabot>   Couldn't match expected type `[t]'
13:01:26 <lambdabot>         against inferred type `Data.Mayb...
13:01:30 <applicative> oh well
13:01:51 <heatsink> > msum [x | p <- tails "foo123", x <- maybeToList $ stripPrefix p "123bar" ]
13:01:52 <lambdabot>   "bar123bar"
13:02:11 <zygoloid> different msum :)
13:02:17 <applicative> haha
13:03:03 <applicative> @type stripPrefix
13:03:04 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Maybe [a]
13:03:40 <applicative> @type msum
13:03:42 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
13:04:27 <applicative> > stripPrefix "haha
13:04:28 <lambdabot>   <no location info>:
13:04:28 <lambdabot>      lexical error in string/character literal at end o...
13:04:34 <applicative> > stripPrefix "haha" "123bar"
13:04:36 <lambdabot>   Nothing
13:04:57 <applicative> > stripPrefix "123" "123bar"
13:04:58 <lambdabot>   Just "bar"
13:06:57 <applicative> > concat [maybeToList x | p <- tails "foo123", Just x <- stripPrefix p "123bar" ]
13:06:58 <lambdabot>   Couldn't match expected type `[t]'
13:06:58 <lambdabot>         against inferred type `Data.Mayb...
13:07:17 <applicative> > concat [maybeToList x | p <- tails "foo123", x <- stripPrefix p "123bar" ]
13:07:19 <lambdabot>   Couldn't match expected type `[t]'
13:07:19 <lambdabot>         against inferred type `Data.Mayb...
13:07:33 <applicative> ok im defeated
13:08:12 <fax> me too
13:08:49 <applicative> we need a monad transformer fax to take us from Maybe to list + maybe, or something,....
13:09:27 <fax> dm
13:09:28 <fax> hmm
13:12:41 <heatsink> edwardk_: Are they unique to each rope, like region annotations?
13:13:17 <edwardk_> heatsink: the brands? _almost_ =)
13:13:39 <edwardk_> applying the same repeatable operation that takes no term level arguments to the same rope should yield the same brand.
13:13:58 <edwardk_> and there is some type level algebraic simplification done
13:14:11 <edwardk_> so you can rely on them being built monoidally
13:14:15 <edwardk_> i.e.
13:14:37 <edwardk_> (a `append` b) `append` c and a `append` (b `append` c) -- will have the same brand
13:14:59 <edwardk_> so if you built annotations on the former, you could fmap it into or extend a computation yielding it and use it on the other
13:15:42 <edwardk_> its not perfect. ideally: the output of tail(snoc anything a) would have the same brand as a.
13:15:49 <edwardk_> er
13:15:55 <edwardk_> tail (cons anything a)
13:16:32 <edwardk_> heatsink: but in general when doing an op that takes an argument will result in a fresh brand
13:17:26 <heatsink> Huh.  And you said this was part of uvector?
13:17:28 <edwardk_> and two ropes that have the same brand should have identical contents. (with one exception)
13:17:29 <edwardk_> no
13:17:35 <edwardk_> this is in my rope library
13:17:43 <heatsink> ok
13:17:48 <edwardk_> i was noting that the same approach could work in uvector to pass lengths as brands
13:17:52 <edwardk_> well, not uvector
13:17:55 <edwardk_> but something uvector like
13:18:15 <pflanze> Is there a way to prefix the names of a data type and all of it's constructors on export? E.g.  data Foo = Bar Foo | Baz; type V1Foo = Foo;  and make Bar and Baz be prepended with V1 as well.
13:18:20 <edwardk_> mostly just trying to see what 'rope' like structures over non-word8s would be
13:18:45 <edwardk_> pflanze: no. you can of course require them to import them qualified, but that doesn't help you export everything from one module
13:18:47 <MisterN> :t Word8
13:18:48 <lambdabot> Not in scope: data constructor `Word8'
13:19:06 <edwardk_> Word8 is a wrapped unsigned byte
13:19:28 <heatsink> Then, what information does brand equality reveal?
13:19:55 <edwardk_> heatsink: in Data.Rope.Annotated the information it yields is that two ropes that have the same brand have the same contents.
13:20:04 <edwardk_> and any annotation that has the same brand was built off of that rope
13:20:36 <edwardk_> the sole exception is the 'escape value' Unsafe' brand that I give in a separate module
13:20:47 <edwardk_> er escape valve
13:21:20 <edwardk_> of course you can only work with that using Unsafe Annotations, so it all balances out =)
13:21:31 <regalia> what's the trick to avoiding these errors:
13:21:42 <regalia> Couldn't match expected type 'Integer' against inferred type 'Int'
13:21:57 <glguy> consistency
13:22:04 <edwardk_> i wonder if the right path to do fusion over bytestrings is to use Data.Stream or to define a custom Data.Stream that uses unboxed word8s internally
13:22:10 <regalia> I have a list of primes, [Int]
13:22:17 <heatsink> regalia: You can cast between the two types.  It's a good idea to use the types in a consistent manner.
13:22:19 <edwardk_> the former would allow bytestring fusion to mix with stream fusion over lists
13:22:32 <edwardk_> the latter would be slightly faster/smaller
13:22:40 <regalia> head $ dropWhile (\x -> i `mod` x /= 0) primes
13:23:23 <regalia> why is [Integer] is expected?
13:23:25 <heatsink> edwardk_: How are the annotations used by the rope library?
13:23:28 <edwardk_> and yet a third option would be to do the horrible unboxed containers trick and define a view to get in and out of a potentially unboxed stream rep, but that makes me vomit a little.
13:23:35 <regalia> :t dropWhile
13:23:36 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
13:23:37 <Axman6> regalia: you'll need to show us your code fully
13:23:38 <lambdabot> Axman6: You have 2 new messages. '/msg lambdabot @messages' to read them.
13:24:15 <regalia> this is in ghci
13:24:45 <regalia> aside from primes which is [Int]
13:24:45 <maltem> regalia, that particular line should work with [Int]
13:24:47 <edwardk_> heatsink: well, i have one that tracks file position using a fingertree of special case annotations, which starts empty, but when you delete part of the annotated rope, the annotation updates itself by inserting a 'digest' version of the potion you deleted in a position monoid
13:24:47 <Axman6> regalia: then you'll need to write out the types when you use let
13:25:12 <Axman6> let head $ dropWhile (\x -> i `mod` x /= 0) primes :: Int
13:25:42 <maltem> regalia, is i :: Integer, by hazard?
13:26:21 <c_wraith> axman, that let seems to be missing an =
13:26:28 <Axman6> yeah
13:26:33 <anhsir> I have a hard time understanding how to use any module unless I "cabal unpack" it and look at the source.
13:26:43 <Axman6> but, he didn't share all the code, so i used what i had
13:26:52 <regalia> Thanks guys :)
13:27:01 <Axman6> anhsir: read the cods on hackage
13:27:05 <Axman6> uh, docs
13:28:28 --- topic: '["Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/", "RIP Robin Milner"]'
13:28:28 --- topic: set by Pseudonym!~ajb@torchwood.alicorna.net on [Tue Mar 23 22:12:43 2010]
13:28:28 <c_wraith> yes.  GOTO only goes forward in time. :)
13:28:47 <maltem> nice to know you are with me
13:28:52 <anhsir> Axman6: is that normally good enough for the competent haskell programmer?
13:29:23 <maltem> anhsir, well, there's always (or should be) that "source" link ;)
13:29:26 <c_wraith> I'd say just having the types isn't really good enough, but it's often close.
13:29:42 <jlouis> if it is well documented ..
13:29:43 <c_wraith> But haddock gives you the types for free.  if you want more docs, you have to actually write them. :)
13:30:29 <edwardk_> heatsink: that way code that is parsing the bytestring can just track byte offsets, but if i'd previously carefully deleted #line pragmas etc and replaced them with annotations, i can reverse from byte offset to source file
13:31:12 <edwardk_> heatsink: which moves the complexity out of my parser and into the error path
13:31:32 <Figs> What does a ! mean in a data declaration?
13:31:38 <edwardk_> figs: 'strict'
13:31:40 <monochrom> I write docs. I disbelieve in the "you can read source" attitude. Example: http://www.vex.net/~trebla/haskell/forwardconstraint/ForwardConstraint.html doc is 10x of code.
13:31:44 <Figs> ok
13:31:53 <edwardk_> figs: inserting it into the structure will 'seq' it first
13:32:48 <edwardk_> data Foo a = Foo !Int !a -- calling Foo x y is equivalent to x `seq` y `seq Foo x y
13:33:23 <monochrom> You can modify $HOME/.cabal/config to tell cabal-install to build docs every time you cabal-install.
13:33:24 <maltem> monochrom, be praised for that attitude
13:33:27 <heatsink> edwardk_: Okay, so each byte is associated with a (line, column) pair.  These are explicitly stored at discrete locations in the rope.
13:33:38 <edwardk_> heatsink: not exactly
13:33:50 <edwardk_> heatsink that would bloat the rope severely =)
13:34:17 <edwardk_> instead i have a 'Pos annotation' where Pos has kind * -> * and takes a brand as an argument.
13:34:45 <edwardk_> and data Rope = Rope !(FingerTree Count Chunk) -- has no annotations
13:34:53 <trofi> I've decoded to upload darcs-2.4 on code.haskell.org in my home dir: /home/slyfox/bin/darcs. I used it to repair an old repo devault darcs coudn't handle. Hope those binaries helps someone else too.
13:35:44 <edwardk_> but data Branded s t a = Branded t a -- is the type of 's branded'. so (s `Branded` Rope) a -- is a branded rope. an annotated rope is ~ (s `Branded` Rope) (f s) -- where f is an Annotation
13:36:03 <edwardk_> the key is that the annotation is not IN the fingertree, it is outside of the fingertree
13:36:10 <edwardk_> but it can be updated with the fingertree as reference
13:36:12 <jmcarthur> i love annotated structures
13:36:36 <heatsink> Okay.  Position information is stored outside the rope.  Whenever the rope is updated, the position has to be updated also.  The branding ensures that the two structures stay consistent.
13:36:43 * jmcarthur wonders if there is a good general way to construct annotated structures from unannotated ones at all
13:37:04 <jmcarthur> i suppose not
13:37:20 <edwardk_> so if you drop 20 bytes off the Ann f a -- you get an Ann f b where b is a different brand, and the annotation has been asked to update itself by dropping 20 bytes, but it is given access to the fingertree to do that operation
13:37:35 <edwardk_> jmcarthur: i have a 'PackableAnn'  type that knows how to do this
13:37:41 <edwardk_> jmcarthur: at least over ropes
13:38:01 <edwardk_> but little of my code is entirely rope specific other than the fact that it limits my scope to keep me sane
13:38:22 <edwardk_> Ann f b ~ (b `Branded` Rope) (f b)
13:38:36 <jmcarthur> edwardk_: the type class in Data.Rope.Annotation?
13:38:41 <edwardk_> yeah
13:39:09 <edwardk_> that typeclass is way permissive with its argument types, be warned ;)
13:39:49 <edwardk_> otherwise i can't figure out the right way to encode the cps transformed combinators for the product annotation
13:40:21 <jmcarthur> ah
13:40:39 <edwardk_> it is correct, but i find i'm unable to prove it to the compiler.
13:41:02 <jmcarthur> hmm... i think this is not quite what i had in mind. i'm not sure if what i had in mind is directly possible
13:41:04 <edwardk_> there is probably some higher order way to think about it in which it becomes trivial, wrap the argument in an f (...) where if is injectable or something
13:41:27 <edwardk_> jmcarthur: what i'm using that for is when you have a rope that has an annotation and you need to bolt a little more on
13:41:41 <edwardk_> now, i have another style of annotation i've used
13:41:45 <edwardk_> you might find that more useful
13:41:58 <edwardk_> if you have a recursive structure, you can take its base functor by factoring out Mu
13:42:09 <edwardk_> then replace Mu by taking a cofree comonad over your functor
13:42:15 <jmcarthur> this is already sounding more like what i meant
13:42:32 <edwardk_> i wrote a blog post about that at one point
13:42:54 <edwardk_> http://comonad.com/reader/2009/incremental-folds/
13:43:01 <edwardk_> that post even solves the hard problems
13:43:10 <edwardk_> =)
13:43:21 * jmcarthur reads
13:43:26 <edwardk_> read the type (:>) in there as 'Cofree'
13:43:39 * Botje read Cofree as Coffee
13:43:50 * arcatan smiles at Botje :>
13:44:01 <edwardk_> welcome back, sioraiocht
13:44:04 <Botje> arcatan: hello you magical coffee bean you!
13:45:36 <edwardk_> jmcarthur: the Coalgebra typeclass there is the 'automated annotation construction'
13:46:01 <edwardk_> but it is important that it be a typeclass, because you want unification to ensure that you only mix consistently constructed annotations
13:46:29 <edwardk_> er sorry, Algebra =)
13:46:51 <edwardk_> one of these days i'll learn to check what i'm typing before i hit enter
13:47:14 * fax still doesn't get "Algebra"
13:47:29 <edwardk_> fax: the reason I chose the term? or what an Algebra is?
13:47:36 <fax> what an algebra is
13:47:51 <McManiaC> is there such a thing as wildcard imports?
13:47:57 <McManiaC> import Foo (F*) ?
13:48:06 <applicative> edwardk_ I was looking at Data.Rope, do you have some stupid 'example' modules one could try? I'm a little lost without something of type IO()
13:48:17 <edwardk_> f m -> m
13:48:47 <edwardk_> applicative: not yet, i'm looking to see if i can put together a full c preprocessor using it that might serve as a standalone example before it gets integrated deeper into my compiler ;)
13:48:53 <FliPPeh> Wow.
13:49:05 <aavogt> McManiaC: you could write a preprocessor...
13:49:06 <FliPPeh> Leksah replaces some syntax with real mathematics characters
13:49:24 <McManiaC> aavogt:  so no :)
13:49:25 <Nafai> edwardk_: A compiler for what language?  C?
13:49:27 <edwardk_> fax: think of that as a generalization of using a monoid to fold over a tree
13:49:28 <applicative> FliPPeh, it wouldn't be objectionable if they didn't call it 'eye candy'
13:49:56 <FliPPeh> Mhh!
13:49:56 <applicative> FliPPeh, you can turn it off.  Haven't tried it for a while, so I may be clueless
13:49:59 <FliPPeh> Takes some gettings used to
13:50:01 <edwardk_> Nafai: nah, its something a fair bit closer to an 'untyped haskell geared towards programming in by anal retentive mathematicians' :)
13:50:06 <FliPPeh> But I just want it to compile first ;x
13:50:18 <edwardk_> fax: that says how you 'collapse' one layer of the tree.
13:50:22 <Nafai> edwardk_: heh, sounds interesting though. :)
13:50:56 <MisterN> do you often use "do" with the Maybe monad?
13:51:15 <edwardk_> Nafai: obligatory syntax fragment that i've been using for the last year or so http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23226
13:51:27 <jeffwheeler> MisterN: it seems to happen sometimes, yeah, without really consciously doing it
13:51:28 <aavogt> > do 1 <- Just 4; return 3
13:51:29 <lambdabot>   Nothing
13:51:43 <aavogt> MisterN: ^^ it has conveniences like that
13:52:08 <Nafai> jeffwheeler: So I finally gave up and (partially wanting to learn lib-vert and kvm) installed a 32-bit Ubuntu 9.04 in a vm just so I could use the amazon downloader :/
13:52:17 <MisterN> jeffwheeler: you unconsciously use Maybe with do?
13:52:22 <edwardk_> MisterN: mostly when i'm using lots of lookups in Map's or Sets.
13:52:29 <MisterN> aavogt: why does that return Nothing?
13:52:30 <Nafai> edwardk_: Nice, looks very clean
13:52:44 <aavogt> MisterN: because a pattern match fails
13:52:47 <jeffwheeler> MisterN: yeah, it seems to just happen
13:52:57 <aavogt> @undo do 1 <- Just 4; return 3
13:52:58 <lambdabot> Just 4 >>= \ a -> case a of { 1 -> return 3; _ -> fail ""}
13:53:11 <edwardk_> jmcarthur: that fit what you were looking for?
13:53:38 <aavogt> it's part of the desugaring of `do', MisterN
13:53:39 <jeffwheeler> Nafai: they updated the thing a few days ago so I couldn't even get the amz file for clamz to use, without installing their tool, with which I had zero success.
13:53:40 <jmcarthur> edwardk_: i suspect. i haven't read it yet. got distracted by actual work
13:53:40 <MisterN> aavogt: oh i thought the 1 was a l (lower-case L)
13:54:19 <edwardk_> @undo do 1 <- Just 4; return 3
13:54:19 <MisterN> :t fail
13:54:19 <lambdabot> Just 4 >>= \ a -> case a of { 1 -> return 3; _ -> fail ""}
13:54:20 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
13:54:39 <edwardk_> fail _ = Nothing -- in the Maybe monad
13:55:33 <flazz> what is a good way to navigate documentation? i'm browsing hackage, but i'm having a hard time finding a function in a bunch of modules
13:55:46 <jeffwheeler> @where hoogle
13:55:46 <lambdabot> http://haskell.org/hoogle
13:55:47 <edwardk_> flazz: hoogle?
13:55:59 <jmcarthur> flazz: if you want search, try hoogle or hayoo, but both have some flaws
13:56:12 <jmcarthur> hoogle for standard libraries, hayoo for hackage
13:56:18 <jeffwheeler> @where hayoo
13:56:18 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
13:56:41 * jeffwheeler thinks that should get a redirect from haskell.org/hayoo or so; I can never remember that.
13:56:53 <jmcarthur> me too
13:56:56 <edwardk_> hrmm it looks like the right answer for bytestring fusion would be to suck it up and use Data.Stream rather than a special unboxed version
13:56:57 <dons> dankna: the download button looks great!
13:57:03 <dons> is there a vector version of that? (based on my .svg)
13:57:10 <dons> if so, i'll change it today.
13:57:30 <flazz> hayoo worked, thanks
13:58:24 <flazz> hoogle seems faster but does not seem to cover all the packages
14:00:26 <heatsink> edwardk_: For some reason, whenever I look at the code you write, I can't find the part that actually _does_ something :)
14:00:55 <edwardk_> heatsink: hahaha
14:01:09 <edwardk_> heatsink: you're on to me ;)
14:01:15 <edwardk_> heatsink: what are you looking for?
14:01:52 <arcatan> flazz: hoogle has better type signature search, too. it "understands" the signatures whereas hayoo does just a plain old string search
14:02:14 <heatsink> So Take, Drop, Cons, etc. are just type indices and have no value.  The type-level integer 'n' and character 'c' aren't actually instantiated to anything.
14:02:40 <edwardk_> heatsink: yes which prevents unification with another thing cons'd onto the same list
14:02:43 <heatsink> 'drop' calls 'dropAnn', which updates the annotation.  Similarly with the other functions.
14:03:00 <edwardk_> heatsink: keep in mind the 'n' and the 'c' get universally quantified over
14:03:18 <fax> tnhis is cool http://xorshammer.com/2009/05/14/a-suite-of-cool-logic-programs/
14:04:57 <edwardk_> heatsink the forall keeps you from taking any other (Take n a) you have lying around and substituting
14:05:20 <heatsink> edwardk_: If I understand correctly, the Data.Rope.Annotation methods force a new annotation to be constructed, but do nothing to enusre that the new annotation corresponds to the operation that was performed.  snocAnn and consAnn could have the same implementation, for example.
14:05:24 <edwardk_> if that forall wasn't there. you could mix and match
14:05:41 <edwardk_> correct.
14:06:22 <edwardk_> for that you have to trust the actual confluence of the monoidal operations, and the reducers, etc being used. i can't prove that
14:06:22 <heatsink> Can I understand the forall similar to the ST monad's forall?
14:06:30 <edwardk_> it is exactly ST s's forall
14:06:35 <heatsink> ok
14:07:03 <edwardk_> i'm just using it over the Branded s Rope comonad rather than ST s's unboxed state monad
14:07:18 <heatsink> I think I get it now :)
14:08:28 <edwardk_> i could get away without all the fancy type families in there, but if i did, then if you uncons'd the same rope twice, at different points it wouldn't realize that they are really the same rope, and so the annotations on each are interchangeable
14:08:35 <edwardk_> in that sense it is 'trickier' than the use of ST s.
14:09:04 <edwardk_> i have some 'fork/join' IO primitives that I need to finish up that use the same machinery
14:09:45 <tsou> anyone knows of a dblatex version that will escape the "\"s properly, when making ghc-6.12.1?
14:10:50 <edwardk_> heatsink: the brands were a desperation move the other day, so i haven't gone through and fully checked all that code. lemme know if you find any inconsistencies
14:11:43 <edwardk_> i added the Data.Rope.Unsafe code as an escape valve for when the brands were too constricting, which gave me back some of the cooler instances my Ropes had lost in the process of becoming branded:
14:12:10 <edwardk_> so an (Unsafe `Branded` t) is a Monad, MonadWriter, etc. in addition to its comonad structure
14:12:24 <edwardk_> which lets you say things like do pack "Hello"; pack ' '; pack "World"
14:12:30 <MisterN> hmm does anybody ever use lists with monads in "do" syntax?
14:12:41 <c_wraith> I do occasionally.
14:12:46 <edwardk_> and get a more or less efficiently build Rope
14:12:47 <MisterN> c_wraith: why?
14:12:48 <edwardk_> er built
14:13:13 <heatsink> This has been interesting, but I really should get back to debugging my stuff
14:13:37 <edwardk_> (i obviously couldn't make (Brand s t) into a monad or monadwriter, because the monad changes the shape, but a comonad is all about redecoration
14:13:41 <edwardk_> hah
14:13:49 * hackagebot hashed-storage 0.4.10 - Hashed file storage support code.  http://hackage.haskell.org/package/hashed-storage-0.4.10 (PetrRockai)
14:13:52 <edwardk_> sure thing. take care. lemme know if you have any questions
14:15:07 <c_wraith> MisterN:  It sometimes helps with clarity.  Here's an excerpt from my permutation experiments where do-notation is nice in the list monad http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24333#a24333
14:16:49 <arcatan> [
14:16:53 <MisterN> c_wraith: why no list comprehension?
14:17:09 <c_wraith> it'd be a list incomprehension
14:17:20 <c_wraith> it does too much to be a readable one-liner
14:17:26 <c_wraith> it's about clarity
14:17:37 <MisterN> @pl do { (x, xs) <- select ls; rest <- perms2 xs; return $ x:rest }
14:17:37 <lambdabot> (line 1, column 4):
14:17:37 <lambdabot> unexpected "{"
14:17:37 <lambdabot> expecting variable, "(", operator or end of input
14:17:53 <MisterN> oh, lol
14:17:58 <c_wraith> I think you want @undo
14:18:16 <MisterN> @undo do { (x, xs) <- select ls; rest <- perms2 xs; return $ x:rest }
14:18:17 <lambdabot> select ls >>= \ (x, xs) -> perms2 xs >>= \ rest -> return $ x : rest
14:18:43 <MisterN> >>= is concatMap, right?
14:18:53 <c_wraith> it's flip concatMap
14:20:01 <benmachine> i.e. =<< is concatMap
14:20:17 <MisterN> let me try to deconstruct this monadic structure
14:22:13 <tommd> Chart rocks.
14:22:38 <MisterN> concatMap (\(x, xs) -> concatMap (\rest -> (x : rest)) (perms2 xs)) (select ls)
14:22:41 <MisterN> correct?
14:23:12 <MisterN> @pl select ls >>= \ (x, xs) -> perms2 xs >>= \ rest -> return $ x : rest
14:23:13 <lambdabot> uncurry (flip ((>>=) . perms2) . (return .) . (:)) =<< select ls
14:23:26 <MisterN> lambdabot: yeah much more readable :)
14:29:47 <dankna> dons: there's no vector version, sorry.  I tried first to make it in Inkscape, but I'm much more proficient with Photoshop.
14:30:34 <pastorn> gpipe is borked :~(
14:30:51 <jmcarthur> pastorn: what's wrong?
14:30:59 <jmcarthur> i've not used it for a few versions
14:31:06 <pastorn> jmcarthur: the tutorial doesn't work
14:31:12 <jmcarthur> ah
14:31:22 <pastorn> and if i mention that i want to load a texture it explodes in my face
14:31:51 <pastorn> tex <- loadTexture RGB8 boxTextureFilePath
14:31:58 <pastorn> that does NOT work as intended :(
14:32:18 <pastorn> i'm guessing that the type family hacks are to blame, but i dunno
14:32:53 <jmcarthur> really? i would have thought that gpipe's most fragile part would be its backend
14:33:20 <pastorn> it seems that everything in it is fragile :(
14:33:55 <jmcarthur> pastorn: i've been investigating my own shader dsl in haskell
14:34:08 <pastorn> jmcarthur: you come up with anything good?
14:34:13 <jmcarthur> but i haven't decided what shape i want it to take yet
14:34:31 <jmcarthur> pastorn: i'm tempted to go all out with it, but i'm afraid of it being vaporware
14:34:39 <pastorn> jmcarthur: maybe using the AwesomePrelude to do stuff?
14:34:40 * RayNbow sees an interesting tweet on Twitter... ``I remember recently seeing something about a language where "everything" was done through continuations. Anyone remember and/or have a link?''
14:35:08 <pastorn> RayNbow: forth
14:35:09 <pastorn> ?
14:35:11 <pastorn> sorry
14:35:14 <pastorn> FORTH?
14:35:27 <jmcarthur> pastorn: well, i'm certainly open to using nonstandard type classes to get the abstractions i want
14:35:48 <pastorn> http://globalnerdy.com/wordpress/wp-content/uploads/2007/09/forth_on_the_atari.jpg
14:36:37 <pastorn> jmcarthur: just make it usable :/
14:36:59 <jmcarthur> pastorn: then make it work? ;)
14:36:59 <RayNbow> pastorn: I can't tell whether that's the language he's looking for
14:41:40 <dons> dankna: ok. i wonder if i can reproduce it as a vector -- or whether  that is necessary
14:41:52 <dons> dankna: maybe it doesn't matter -- for the buttons we'll just use your large .png
14:42:05 <pastorn> jmcarthur: how would you abstract it in a good way and still support all the goodies of what you do with shaders normally
14:42:11 <pastorn> texture lookups and what not
14:42:15 <fax> I suppose this is relevant to #haskell http://xorshammer.com/2008/08/18/hardest-logic-puzzle-ever
14:42:25 <dankna> dons: it's your call.  I wouldn't blame you for not using it by virtue of the fact it's raster :)  I figured it was worth at least showing you what I had in mind.
14:42:44 <dons> i think it looks great :)
14:42:51 <dankna> great :)
14:43:27 <jmcarthur> pastorn: i was originally thinking of giving the dsl the full power of the lambda calculus
14:43:57 <jmcarthur> pastorn: but i'm rethinking just because i'm not sure i want to go through the effort for that
14:44:15 <zygoloid> fax: http://www.srcf.ucam.org/~te233/maths/puzzles/evenharder.html
14:44:19 <jmcarthur> i mean it's probably not too hard to do it naively, but i'd want it to be efficient too
14:44:32 * benmachine blinks at another srcf URL
14:45:47 <dons> dankna: only problem is scaling it to 64x64 and 128x128 looks bad :( (fonts go funny)
14:45:52 <dons> dankna: maybe you can scale it better?
14:45:58 <dankna> dons: sure, I can do that.  one second.
14:46:05 <dons> gimp did a bad job
14:46:15 <dons> http://haskell.org/ <- is 110x110
14:47:17 <not_nathan> Hello everyone.
14:47:32 <jmcarthur> hello nathan
14:47:54 <benmachine> I see what you did there
14:48:12 <not_nathan> I've been reading through the SoC proposals, and I'm trying to decide whether to apply to do the more general functional data structures ticket, or the maps as Generalised tries ticket.
14:48:30 <dankna> http://dankna.com/himitsu/Button-128.png and http://dankna.com/himitsu/Button-64.png -- how's that?
14:48:54 <sbahra> In all honesty, I don't know why dons decided to make it low contrast.
14:49:05 <sbahra> That is better, but I think the white should be brighter.
14:49:14 <dons> could you make the 128 one, say 100x100 or 110x110 (I think 128 is too big)
14:49:20 <dankna> yes, absolutely
14:49:25 <dons> sbahra: you mean the slight shading on the original?
14:49:29 <not_nathan> I'm really psyched to do something with functional data structures, but the inefficiencies of Data.Map seem to be the main point of the more general ticket, which is specifically addressed by the map as generalised trie one.
14:49:29 <dankna> if the white is brighter it's hard to read the lambda and the word "Download" :)
14:49:30 <dons> there's a gradient left-to-right.
14:49:42 <sbahra> dankna, white on black is pretty clear.
14:50:09 <dons> http://hackage.haskell.org/platform/icons/button.png
14:50:12 <dankna> well, you're more than welcome to do your own version, haha.  I'm not totally sure what you have in mind.
14:50:17 <dons> seems fairly high contast
14:50:24 <sbahra> dons, ah, yes, that is.
14:50:43 <dons> e.g. as found on http://haskell.org/
14:51:03 <sbahra> Well, I can do something but it'll have to be a high resolution image. I don't do scalable graphics unfortunately, haven't had the time to learn the tools.
14:51:08 <dankna> http://dankna.com/himitsu/Button-100.png
14:51:17 <jmcarthur> honestly i wonder if we wouldn't benefit from a nicer looking front page generally
14:51:18 <sbahra> So, if you don't mind, I can do a png.
14:51:23 <jmcarthur> it looks like a wiki
14:51:30 <sbahra> jmcarthur, it is? :-P
14:51:30 <jmcarthur> plain
14:51:38 <dankna> sbahra: that's no worse than mine - I also gave up on doing it in Inkscape and went with Photoshop instead
14:51:40 <jmcarthur> sbahra: i know, but that doesn't make it better
14:52:00 <dankna> jmcarthur: we do at least have unified navigation for all the various sites that are there.  that's a big thing to me.
14:52:02 <dons> the original .svg: please feel free to modify! http://hackage.haskell.org/platform/icons/button.svg
14:52:07 <sbahra> dons, http://www.ubuntu.com/
14:52:08 <jmcarthur> dankna: agreed
14:52:13 <sbahra> dons, what do you think of that button they used there?
14:52:14 <jmcarthur> navigation is great to have
14:52:22 <sbahra> dons, I can make something similar to that with the Haskell logo.
14:52:38 <sbahra> dons, but I am not able to do it as an SVG.
14:52:40 <dons> the "download" button?
14:52:51 <sbahra> dons, yes.
14:52:55 <dons> i'd like similar buttons for the major downloads on the platform page. one for mac and windows and source.
14:53:07 <dons> hopefully basic image + html text
14:53:17 <dons> another example: http://www.google.com/chrome
14:53:26 <sbahra> It could be adapted, again, it'll be an XCF.
14:54:04 <sbahra> Here, I'll give it a shot in gimp.
14:54:18 <sbahra> dons, are you fine with a rectangle or do you really insist on the square shape?
14:54:38 <dons> no, i don't insist
14:54:42 <sbahra> Ok.
14:54:43 <dons> do what looks pleasing.
14:54:44 <benmachine> also why is there a download haskell link underneath it as well
14:54:48 <jmcarthur> also while speaking of front page, i really like how ruby-lang.org has a simple code sample on the front page to give people a tiny taste
14:55:02 <dons> benmachine: oh, haven't added the alt tag to the wiki markup
14:55:04 <dons> too lazy
14:55:08 <sbahra> jmcarthur, as much as I dislike Ruby, their website is beautiful.
14:55:19 <dons> there's some murmurs to redesign the front page
14:55:24 <jmcarthur> sbahra: i wouldn't go that far, but there are many things i like about it for sure
14:55:24 <dons> no need for it to be a wiki, for example
14:55:28 <Cale> "Download Haskell" just sounds... wrong to me.
14:55:30 <dons> and it could be much better designed
14:55:32 <dons> we have the right content.
14:55:32 <jmcarthur> dons: exactly
14:55:41 <[swift]> so as i learn more about monad transformers, i can't help but be reminded of aspect-oriented programming
14:55:42 <jmcarthur> we should have a contest!
14:55:44 <dons> Cale: ah, you have to deal with it. sorry. it's like "Download Ruby" or "Download Python"
14:55:47 <Cale> It sounds like "Download English"
14:55:48 <jmcarthur> like we did for the logo
14:55:50 <dons> we all know there are many implementations of all languages
14:56:00 <dons> but haskell's been too pendantic for too long.
14:56:02 <medfly> download haskell platform then?
14:56:07 <dons> nope.
14:56:11 <[swift]> monads and monad transformers seem to elegantly achieve the same separation of concerns that AOP achieves so inelegantly
14:56:15 <lament> dons: the implementations of ruby and python are called "ruby" and "python"
14:56:20 <lament> (the main implementations that is)
14:56:33 <dons> and that's what people expect.
14:56:36 <dons> so we give them that.
14:56:41 <[swift]> i'm curious if others have thought the same thing
14:56:48 <medfly> write platform really small
14:56:51 <lament> dons: do you have an executable called haskell?
14:56:56 <jmcarthur> couldn't it be "Download the Haskell Platform" at least?
14:57:01 <dons> the runhaskell exe should be called 'haskell' imo.
14:57:02 <Cale> That's not even true anymore. I hear a lot of the python developers being careful to separate the implementations (CPython, IronPython) from the language.
14:57:07 <dons> jmcarthur: doesn't fit in an icon
14:57:15 <jmcarthur> not in *that* icon
14:57:20 <Cale> So they're going in the opposite direction.
14:57:23 <dons> jmcarthur: well look at the platformm page.
14:57:24 <lament> Cale: no
14:57:36 <sbahra> "Download platform"?
14:57:41 <lament> Cale: people have always called the main implementation cpython in the context of distinguishing it from other implementations
14:57:44 <dons> we're very careful: http://hackage.haskell.org/platform/
14:57:49 <lament> Cale: but it's actually called python
14:57:50 <sbahra> Kind of implicit that it is a "Haskell platform" of some sort :-P
14:58:00 <sbahra> dons, oh, that's nice.
14:58:38 <medfly> ooh, pretty
14:58:44 <dons> we're making lives easier for our users. "Download Haskell" is what the majority of new users *just want*. not a lecture on impl/language, or ghc vs hugs.
14:58:52 <dons> less confusion, more adoption.
14:58:57 <stevenmarky> I like it
14:58:58 <ddarius> [swift]: Others have thought it.
14:59:10 <Cale> lament: Well, yeah. I've just heard people referring to it specifically as CPython a lot more often.
14:59:18 <dankna> I agree with dons here.  Keep things simple for newcomers.
14:59:19 <Entroacceptor> dons: are you sure they want it?
14:59:22 <medfly> I think Cale talks to strange people
14:59:25 <[swift]> ddarius: yeah, i just found a couple of papers on the subject! i'll have to give them a read
14:59:31 <medfly> that's all :)
14:59:34 <Entroacceptor> I as a newcomer would expect stuff about the language
14:59:34 <Cale> (Well, when it's appropriate)
14:59:39 <lament> the haskell platform logo is absolutely awesome, gj
14:59:44 <Entroacceptor> it's not like a game you can just download and start with
14:59:46 <dons> Entroacceptor: going by the number of confused users on stackoverflow mistakenly downloading hugs, because it is the first hit on google for "download haskell". Yes!
14:59:52 <dons> Entroacceptor: yes it is
14:59:54 <Entroacceptor> oookay
14:59:56 <medfly> why is the Mac not an apple or something
15:00:02 <medfly> don't they have another logo
15:00:05 <dons> medfly: this is an open ticket
15:00:10 <dons> we need the valid open source icon
15:00:13 <dons> that apple won't sue me for.
15:00:16 <dons> the current one is wrrong
15:00:17 <jmcarthur> hugs isn't even on the first page of results for that query for me
15:00:22 <ddarius> [swift]: I personally don't think the idea holds much water.  I don't find that monads provide the properties AOP is after.
15:00:23 <medfly> jesus christ.
15:00:24 <jmcarthur> oh wait, there it is
15:00:24 <Entroacceptor> the platform website is beautiful
15:00:29 <jmcarthur> half way down it
15:00:44 <benmachine> dons: are you not going to link to the separate GHC download at all then?
15:00:57 <dons> http://lmgtfy.com/?q=download+haskell
15:01:25 <dons> benmachine: nope. it's basically useless to new users, and the ghc download page already points to the haskell platform
15:01:27 <[swift]> ddarius: it's clear that they're not exactly the same, but monads have the advantage of being much easier to reason about (IMO)
15:01:39 <dons> if you really want ghc, you'll go to the ghc home
15:01:46 <dons> but haskell.org, you get the standard haskell system.
15:01:55 <lament> making headers links to TOC is very counterintuitive, by the way
15:02:01 <lament> (on the "Learn more" page)
15:02:10 <dons> oh, that's some odd pandoc bug.
15:02:15 <dons> not intentional. not sure why it did that.
15:02:23 * dons opens another ticket
15:02:49 <dons> also the learn more page needs to link back to the download page
15:02:55 * Cale kinda misses ghc + extralibs
15:02:57 <dons> after you've learned more, we want you to click download.
15:03:12 <glguy> Cale, just think of it as extralibs + ghc!
15:03:12 <dons> Cale: the HP is ghc + extralibs, but with a bonus installer and torrent and icons :)
15:03:14 * hackagebot cuboid 0.1 - 3D Yampa/GLUT Puzzle Game  http://hackage.haskell.org/package/cuboid-0.1 (PedroMartins)
15:03:35 <dons> Cale: and we even ship the source.
15:03:41 <Cale> But the HP has lots of other stuff I don't necessarily want...
15:03:51 <dons> its the same set ghc + extralibs was
15:03:59 <Cale> Is it?
15:03:59 <dons> till ghc HQ decided to stop shipping libs
15:04:01 <Cale> Hmm...
15:04:01 <dons> yes.
15:04:08 <dons> that's how we chose the initial set
15:04:18 <dons> though not with unportable things (OpenAL)
15:06:26 <Apocalisp> Why is it exactly that we can't define monad transformers once for all monads?
15:06:45 <Apocalisp> or at least... once for all Traversable?
15:07:09 <jmcarthur> i don't understand what you mean
15:07:14 <dons> dankna: so i'm waiting on revised icons from you, i think.
15:07:42 <Apocalisp> Why do we need MaybeT, StateT, etc?
15:07:44 <Peaker> Apocalisp: Converting a monad, e.g: s -> (s, a) to a monad transformer, e.g: (s -> m (s, a)) is not trivial. I am not sure if there's a systematic way that would work for all monads
15:07:44 <dankna> dons: oh, sorry, the 100px version?  I uploaded that a few minutes ago
15:07:45 <Cale> Er, ah, it requires me to install GHC separately anyway. :P
15:07:53 <dankna> http://dankna.com/himitsu/Button-100.png
15:07:56 <Peaker> Apocalisp: the good news though is that you can trivially derive the monad from the transformer :)
15:07:57 <dons> thanks!
15:08:01 <maciej`> hi everyone
15:08:02 <jmcarthur> Peaker: i'm pretty sure there is not
15:08:05 <dankna> sure :)
15:08:11 <Apocalisp> Peaker: Hah. Thanks!
15:08:14 <dons> Cale: right. as the ghc bundle does too. we might role binary installers for linux though.
15:08:19 <jmcarthur> Apocalisp: composing monads is hard :)
15:08:29 <Peaker> Apocalisp: Maybe = MaybeT Identity (except for an extra newtype wrapper)
15:08:30 <jmcarthur> Apocalisp: for an alternative to transformers see the Composing Monads paper
15:08:38 <tsou> Cale: and then when you go to download ghc 6.12 it warns you that you should better get HP :P
15:08:40 <Cale> dons: Yeah, I usually just install the binary of GHC anyway
15:08:42 <Apocalisp> Category theorist Barbie says: Composing monads is hard. Let's go shopping.
15:08:44 <Peaker> jmcarthur: what does it suggest over there?
15:08:52 <jmcarthur> Apocalisp: that paper is an easy read, by the way
15:09:04 <maciej`> can anyone help me make sense of some profiling info?
15:09:13 * sm tries cuboid.. wow that's small
15:09:19 <jmcarthur> Peaker: they have some type classes you can define that allows you to construct compositions of monads at the type level with the expected behavior
15:09:24 <Cale> maciej`: We can try if you link to it
15:09:34 <Peaker> jmcarthur: how do you compose State and IO, for example?
15:09:37 * sm discovers it's missing a bunch of modules. bah
15:09:45 * Cale considers installing 6.12.1...
15:09:48 <maciej`> cale: sure, hold on
15:09:56 <jmcarthur> Peaker: have you seen the TypeCompose library?
15:10:53 <jmcarthur> Peaker: i forget the paper's notation, but it woudl look something like  State s :. IO  (vs. StateT s IO)
15:11:02 <dons> http://haskell.org/ <-- new icon
15:11:06 <dons> dankna: ^^ what do you think?
15:11:12 <maciej`> Cale: here it is: http://people.csail.mit.edu/mpacula/Minimize.prof
15:11:16 <Peaker> jmcarthur: Yeah, TypeCompose is really nice :)
15:11:18 <jmcarthur> Peaker: where certain type constraints are enforced
15:11:20 <sbahra> dons, almost done with mine.
15:11:22 <dankna> dons: ^_^ I'm pleased by it!
15:11:28 <jmcarthur> Peaker: if you like TypeCompose you will like Composing Monads
15:11:30 <Peaker> jmcarthur: the problem is that State s (IO a)  is already wrong
15:11:35 <dons> also here, http://haskell.org/haskellwiki/Haskell_Platform#Buttons
15:11:40 <jmcarthur> Peaker: how's that?
15:11:59 <Peaker> jmcarthur: s -> (s, m a)   is wrong,  what is needed is s -> m (s, a)
15:12:01 <dons> sbahra: let me know, and i'll add them to the set. 100xY and 64xY plz
15:12:08 <jmcarthur> Peaker: oh, right
15:12:09 <dons> or Xx100
15:12:13 <Cale> hmm, maybe steal the logo + colours from the platform site
15:12:19 <dons> oh, you're doing the actual download ones.
15:12:20 * hackagebot cuboid 0.11 - 3D Yampa/GLUT Puzzle Game  http://hackage.haskell.org/package/cuboid-0.11 (PedroMartins)
15:12:23 <jmcarthur> Peaker: well, they didn't say it was completely general
15:12:26 <dons> sorry sbahra, got confused.
15:12:31 <maciej`> why does it say that MAIN used 100% of the time, but doesn't break it down by function?
15:12:37 <jmcarthur> they say the opposite in fact
15:12:42 <dons> maciej`: you missed -auto-all
15:12:45 <dons> maciej`: -prof -auto-all
15:12:54 <dons> so you get cost centers automatically on every function
15:12:59 <dons> (probably should be the default!!)
15:13:26 <maciej`> dons: trying it now
15:13:34 <sbahra> dons, so you want it 100x? Is 124 fine?
15:13:39 <Peaker> jmcarthur: it seems that  State s a = s -> (s, a)   is a pretty limiting form -- it suggests you might have to modify State itself to compose it (as StateT does)
15:13:44 <Peaker> jmcarthur: which is discouraging
15:13:44 <pastorn> is there a cabal remove?
15:13:45 <dons> sbahra: no no, you do whatever you like
15:13:46 <sbahra> ok
15:13:49 <sbahra> here it is, hold
15:13:58 <dons> dankna: also, how about a similar desktop icon for the platform itself.
15:14:01 <Peaker> pastorn: you can "ghc-pkg unregister", which "leaks" the disk space but is similar
15:14:07 <pastorn> i want to hide a certain version of an installed package
15:14:14 <gwern> pastorn: then use ghc-pkg hide
15:14:15 <dons> maybe saying "Haskell Platform" or "Haskell" instead of "Download"
15:14:24 <dons> for use in the installers and on people's desktops
15:14:24 <monochrom> ghc-pkg hide base-4.1.0.0
15:14:29 <dons> in general: artwork for the platform :)
15:14:30 <pastorn> Peaker, gwern: thanks :)
15:14:39 <maciej`> dons: it worked. thanks a lot!
15:14:41 <gwern> pastorn: although needing to hide/unhide stuff is usually a sign someone has messed u
15:14:54 <dankna> dons: hmmmm sure
15:15:01 <maciej`> once again #haskell saved me hours of head scratching
15:15:08 <pastorn> gwern: GPipe won't work :(
15:15:10 <dankna> dons: I don't have the font you used though; I'll pick one that's similar.  that okay?
15:15:20 <Entroacceptor> I like getting my head scratched... :)
15:15:21 * hackagebot epub 0.0.4 - EPUB E-Book construction support library  http://hackage.haskell.org/package/epub-0.0.4 (RadoslavDorcik)
15:15:32 <Peaker> I wonder why FTGL looks worse than SDL TTF support
15:16:25 <sbahra> dons, ekh, hold on. imgur messes them up.
15:17:11 <Cale> Hehe, the new Haskell logo is so reminiscent of the Commodore logo that it makes me think someone should work out how to hook a Reduceron up to a C64.
15:17:35 <pastorn> Cale: what should it do, once hooked up?
15:17:39 <monochrom> The round corners remind me of iPhone apps.
15:17:40 <sbahra> dons, http://repnop.org/t/haskell-3.png
15:17:54 <sbahra> Though an asterisk is probably in order.
15:17:57 <Cale> pastorn: You'd also need a C64 Haskell -> Reduceron compiler of course.
15:18:21 <dankna> ah, Liberation Sans is a free font.  never mind, I'll have it in a moment :)
15:18:42 * sm likes sbahra's colour scheme much better than Awful Cyan
15:18:54 <sbahra> Doing some other touch-ups.
15:19:01 <sbahra> dankna, no, Calibri.
15:19:02 <edwardk> cale: heh i have a c64 emulator around would that do? =)
15:19:11 <stevenmarky> is there a type of zip that would zip two lists into a single list? e.g. [1,2,3] [7,8,9] = [1,7,2,8,3,9]
15:19:30 <pastorn> Cale: wouldn't it be AWESOME running a garbage collector on 64 kb of RAM?
15:19:32 <Cale> concat . transpose?
15:19:44 <sbahra> Oh, I have a cute idea.
15:19:48 <edwardk> sbahra: nice
15:20:04 <sbahra> Check this one out
15:20:20 <Peaker> > concat . transpose $ [[1,2,3],[7,8,9]]
15:20:21 <lambdabot>   [1,7,2,8,3,9]
15:20:35 <stevenmarky> thanks Cale.
15:20:55 <stevenmarky>  + Peaker.
15:21:03 <edwardk> preflex: xseen sioriacht
15:21:04 <preflex>  Sorry, I haven't seen sioriacht
15:21:50 <Cale> pastorn: well, that would be the advantage of having a reduceron expansion pack :)
15:22:47 <ddarius> I would be surprised if the cores the early garbage collectors ran on had even 64kb.
15:23:16 <Cale> pastorn: Your Haskell heap goes into the FPGA-created memory.
15:23:54 <ddarius> "FPGA-created memory"?
15:24:07 <dons> nice sbahra !
15:24:15 <jeffwheeler> Hmm, it seems like lambdabot no longer hangs around #yi. Who maintains lambdabot?
15:24:20 <medfly> Cale
15:24:34 <jeffwheeler> medfly: thanks
15:24:35 <sbahra> dons, just hold on a minute. Let me do some final touches and I'll provide a tarball.
15:24:39 <dons> sbahra: so these would replace dankna's logo. should i use these for the windows and mac downloads?
15:24:58 <sbahra> dons, well, let me fix up the text. I tried adding an asterisk, but it's ugly (confuses with the l's).
15:24:59 <Cale> ddarius: They wire up their own memory on the FPGA, and there's a built-in garbage collector, as I understand it
15:25:08 <dons> ok.
15:25:12 <jeffwheeler> Cale: in case you didn't see my message above; I think lambdabot was configured to go into #yi automatically a while back, but it no longer seems to be in there
15:25:20 <sbahra> exclamation point that is
15:25:38 <jmcarthur> i like it the most out of what i've seen
15:25:41 <Cale> jeffwheeler: ah, I had indeed missed it
15:25:42 <dons> sbahra: do you want to use the wider logo on http://haskell.org/ ?
15:25:48 <jeffwheeler> Cale: no worries
15:25:49 <Cale> jeffwheeler: I will check the join list
15:25:55 <jmcarthur> the similar colors make everything appear blurry though
15:25:56 <jeffwheeler> Cale: thanks :)
15:25:57 <dons> sbahra: and a narrower one on people's websites?
15:26:03 <jmcarthur> blue is the hardest color for people to see
15:26:08 <dons> yeah, might need more contrast on the text
15:26:09 <Cale> I don't really maintain lambdabot, I just run it
15:26:16 <dons> my original one was "hi viz" :)
15:26:36 <jmcarthur> the logo looks blurry to me as well
15:26:37 <dons> http://hackage.haskell.org/platform/icons/button.svg
15:26:38 <Cale> okay, #yi is not in the join list. I'll add it
15:26:42 <jmcarthur> on its background
15:26:50 <jeffwheeler> Cale: awesome, thanks
15:27:16 <Cale> lambdabot: @join #yi
15:27:43 <ih> i'm reading "real world haskell" and they say foldl isn't really used (rather foldl' is) does this mean foldr isn't used either?
15:27:56 <dons> no, foldr is a bit different. Cale can explain.
15:27:56 <Cale> ih: No, foldr is used a lot
15:28:21 <ih> it doesn't suffer from a similar problem with large thunks?
15:28:21 <Alpounet> haha
15:28:35 <monochrom> It doesn't.
15:28:37 <Cale> ih: I would say from 50 to 75% of the time you want foldr, and then most of the remaining part of the time, you want foldl'
15:28:40 <dankna> dons: http://dankna.com/himitsu/Platform-100.png http://dankna.com/himitsu/Platform-64.png http://dankna.com/himitsu/Platform.icns (Mac icon file) http://dankna.com/himitsu/Button.psd (updated master with more layers in case you need to make new versions)
15:28:48 <dankna> is that what you wanted?
15:28:52 <dons> dankna: thanks!
15:28:54 <dons> yes.
15:28:58 <Cale> ih: Lazy evaluation means that expressions are evaluated outermost first
15:29:00 <Cale> @src foldr
15:29:01 <lambdabot> foldr f z []     = z
15:29:01 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
15:29:12 <dankna> excellent
15:29:20 <Cale> taking a look at the code for foldr, in the recursive case, it immediately passes control to f
15:29:25 <ih> wouldn't foldr suffer from problems of not being tail recursive though?
15:29:34 <Cale> So only if f chooses to look at its second parameter will the foldr continue
15:30:00 <monochrom> > foldr (&&) undefined (repeat False)
15:30:01 <lambdabot>   False
15:30:09 <monochrom> does not have large thunk
15:30:13 <ih> i see
15:30:28 <sbahra> dons, ok. http://repnop.org/t/haskell-1.png http://repnop.org/t/haskell-2.png and http://repnop.org/t/haskell-3.png
15:30:28 <Cale> This gives foldr the tremendous advantage that it can stop early, and it can also be productive -- producing part of its result before the entire input list is evaluated.
15:30:35 <Peaker> ih: Well, foldr takes an operation *, "z" and a list (a : b : c : d : []) and converts it to this:  (a * (b * (c * (d * z))).  The "top-level" expression is (a * --everything else--)   so if your operation * doesn't care too much about it's right-hand argument, only the outer-most thunk will be built
15:30:43 <sbahra> dons, just make sure it isn't off your cache, there should be a small drop shadow to them.
15:30:50 <diegoeche> anybody is familiar with: "can't load .so/.DLL for: gmp"
15:31:08 <maciej`> is there any way to sort the profiling file, say by inhertited %alloc?
15:31:09 <Cale> ih: Tail recursion doesn't mean much to the evaluation mechanism.
15:31:18 <monochrom> It is easy to look at the names "foldr", "foldl", take the common prefix "fold", and presume they have similar fates.
15:31:21 <dons> yes, very nice sbahra
15:31:26 <Cale> ih: In fact, there's no special treatment for tail recursion at all.
15:31:28 <diegoeche> I tried to install the latest ghc and that's what I'm getting when I run ghci
15:31:45 <dons> diegoeche: using the Haskell Platform? or ghc head do you mean?
15:31:51 <sbahra> :]
15:31:55 <dons> sbahra: they're great
15:31:59 <ih> i thought there was some sort of tail call optimization
15:32:06 * dons experiments
15:32:10 <sbahra> dons, thanks. I hope they are useful.
15:32:11 <diegoeche> isn't 6.12 required to build haskell platform?
15:32:13 <Cale> ih: and the stack is used for an entirely different purpose (you can get a stack overflow, but it doesn't mean what it means in a strict language)
15:32:19 <sbahra> Yeah, I'm curious how it'll look with the current WiKi color scheme.
15:32:26 <dons> diegoeche: 6.12 is part of the HP.
15:32:29 <ddarius> Cale: Note, that for a rewriting semantics, evaluation order doesn't matter as far as tail calls are concerned.
15:32:31 <Peaker> @src foldl
15:32:31 <lambdabot> foldl f z []     = z
15:32:32 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
15:32:34 <dons> diegoeche: so you could just use an installer for that on windows or mac.
15:32:38 <ddarius> Cale: Haskell still needs TCO.
15:32:42 <monochrom> It is not much smarter either to look at "descriptions" such as "foldl summarizes and foldr summarizes" and presume they have similar fate.
15:32:58 <sm> sbahra: any way to get better aliasing on the font ? in the small one especially
15:33:01 <monochrom> Reasoning by "meaningful" words never works.
15:33:07 <dons> what do people think <-- http://haskell.org/
15:33:09 <dons> is that logo better?
15:33:11 <sbahra> sm, you're right. Let's see.
15:33:13 <Cale> Well, the evaluator effectively uses graph rewriting.
15:33:19 <dankna> I abstain :)
15:33:25 <diegoeche> dons: I'm using ubuntu
15:33:30 <dons> dankna: :)
15:33:35 <ddarius> dons: Doesn't fit that spot well.
15:33:42 <monochrom> The whole enterprise of "meaningful identifiers" is snake oil.
15:33:44 <sbahra> dons, I think it should be wider. That one is a bit too small. If you want to keep it, I recommend you make it left aligned or set it on the white text.
15:33:56 <sbahra> dons, maybe haskell-2.png?
15:33:59 <Entroacceptor> can someone make happstack compile for me, please?
15:34:13 <sm> here's the old page for comparison: http://webcache.googleusercontent.com/search?q=cache:PO5iMISmhqMJ:www.haskell.org/+haskell&cd=1&hl=en&ct=clnk&gl=us
15:34:16 <dons> trying. ooh
15:34:17 <tsou> dons: previous one looked better
15:34:20 <dons> http://haskell.org/
15:34:27 <dons> that size is better
15:34:28 <Cale> ih: anyway, I like to picture the stack as consisting of all the case-expressions who are waiting for their scrutinee to be sufficiently evaluated that they can pattern match.
15:34:42 <Entroacceptor> red headline is ugly
15:34:45 <sbahra> dons, you know where it should be?
15:34:52 <diegoeche> according to the haskell platform website:  "You need GHC 6.12.1 installed before building the platform. You can get this from your distro or you can get a GHC 6.12.1 generic binary."
15:34:54 <dons> sbahra: ?
15:34:56 <sbahra> dons, how about after the first paragraph on the home page?
15:35:02 <sbahra> dons, on white. Instead of on the side bar.
15:35:06 <dons> or on the right side.
15:35:11 <Cale> ih: So, this makes the stack into a very different sort of thing -- it doesn't have functions on it, it has pattern matches.
15:35:12 <dons> have to hack the template a bit :/
15:35:16 <sbahra> dons, You can use the big red button.
15:35:23 <sbahra> dons, err, the big button ;-p
15:35:32 <Peaker> monochrom: I think that's an exaggeration. For example, today at work, someone used "rate" as an argument name (in C). The type says little. If she had used a meaningful identifier (rate_bytes_per_second) -- it would help
15:35:33 <sbahra> dons, and center it between headlines and first paragraph.
15:35:38 <sbahra> dons, I think that'll be sexy.
15:35:50 <ih> ok, i'll think about this some more, thanks
15:35:51 <Peaker> monochrom: I had to change all of her meaningless identifiers to meaningful ones (that contain units)
15:35:53 <diegoeche> so that's what I tried to do... grab the generic bin for ghc in order to compile haskell platform
15:35:55 <Entroacceptor> and I don't like the wiki controls at the top, at all
15:35:56 <Peaker> monochrom: so that I could work with it
15:36:00 <Cale> ih: It can help to look at some examples:
15:36:20 <ih> do you have suggestions for resources?
15:36:26 <dons> ok. reverting for now. i'll add these icons to the icon page.
15:36:32 <edwardk> hrmm, wonder what it would take to generalize my ropes so they can hold UArr's
15:37:05 <monochrom> Next month you will pull your hair asking yourself "I know the unit is bytes per second but what is this rate for? rate of memory leak?"
15:37:13 <Cale> ih: hmm... maybe there's a web page version of this, but we can evaluate some folds by hand
15:37:30 <monochrom> In the limit you will have 120-letter identifiers.
15:37:36 <sbahra> dons, ekh, still better than what is there now :-P (no offense)
15:38:04 <sbahra> Anyways, hope they'll come useful. Bye.
15:38:06 <dons> sbahra: you mean with what is on http://haskell.org ?
15:38:10 <dons> added to http://haskell.org/haskellwiki/Haskell_Platform
15:38:10 <sbahra> dons, yes.
15:38:17 <monochrom> And it's 120 because you add another 20 letters or so for the type so you can twitter it.
15:38:20 <sbahra> dons, what was there earlier (haskell-2.png) is better than what is there now...
15:38:21 <Cale> ih: Let's start with foldr (++) [] [[1],[2],[3]]
15:38:26 <dons> what do people think: http://haskell.org/haskellwiki/Haskell_Platform#Buttons
15:38:29 <dons> sbahra: yes, perhaps.
15:38:44 <Cale> ih: Let's just go as far as determining the first element of the resulting list
15:38:46 <dons> anyone object to using haskell-2.png (the 2nd of the "alternative" series).
15:39:02 <jmcarthur> no objections
15:39:04 <jmcarthur> from me
15:39:23 <Cale> ih: So, we replace according to the second equation for foldr, and get:  [1] ++ foldr (++) [] [[2],[3]]
15:39:26 <edwardk> dons: i definitely like samy's, though it's drop shadow makes the bottom edge look muddy on the smaller versions
15:39:34 <dons> maybe too much shadow, yeah.
15:39:34 <Cale> and now it's (++)'s turn
15:39:38 <Cale> @src (++)
15:39:39 <lambdabot> []     ++ ys = ys
15:39:39 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
15:39:39 <lambdabot> -- OR
15:39:39 <lambdabot> xs ++ ys = foldr (:) ys xs
15:39:39 <jmcarthur> agreed
15:39:47 <sbahra> edwardk, you're right. I've uploaded the XCF to repnop.org/website/html/t/haskell.xcf
15:40:00 <sbahra> If any of you guys want to modify it.
15:40:02 <Cale> and the second equation for (++) matches (assuming the recursive def.)
15:40:15 <sbahra> Personally, I like the muddy effect.
15:40:18 <Cale> and we get  1 : ([] ++ foldr (++) [] [[2],[3]])
15:40:21 <tsou> the colors on the square one seem better
15:40:24 <sbahra> The top edge is well defined.
15:40:28 <edwardk> sbahra: heh i know better than to engage in the herculean task of trying to satisfy a channel full of 668 people ;)
15:40:30 <Cale> and if we're only interested in the first element of the list, we are now done.
15:40:49 <sbahra> edwardk, haha
15:40:57 <Cale> but, if not, evaluation would continue with the (++), and then the foldr after that
15:41:03 <Cale> bbiab, dinner
15:41:36 <dons> edwardk: hehe
15:42:36 <ih> right, i guess my confusion was with the example for finding a sum
15:42:47 <Entroacceptor> Network/SMTP/ClientSession.hs:242:16: Not in scope: data constructor `Message'
15:42:49 <Entroacceptor> help?
15:42:52 <dons> http://haskell.org/ <-- refresh.
15:43:06 <MisterN> @src liftM2
15:43:06 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
15:43:10 <ih> the book seemed to say the problem with foldl is that for a long list you have this really large expression that doesn't get evaluated until you need it
15:43:34 <jmcarthur> dons: i think that looks pretty good. definitely attracts the eyes to the button, at least
15:43:36 <edwardk> ih: yep
15:43:56 <edwardk> to get to your first answer you have to wade through a mountain of parentheses
15:44:05 <ih> e.g. (((0+1)+2)+...
15:44:06 * jmcarthur is feeling inspired to crack his knucles and do a design mockup of the front page
15:44:07 <ih> right
15:44:10 <jmcarthur> *knuckles
15:44:24 <ih> oh actually i think i get it now
15:44:25 <jmcarthur> i haven't done web design in a few years now
15:44:28 <edwardk> dons: i think you've hit diminishing returns =)
15:44:58 <ih> whereas for foldr you have (1+(2+(3+...
15:45:20 <edwardk> ih yeah, you aren't saved when the operation is +, but consider consing with (:)
15:45:45 <ih> ok yeah i think that was what was confusing me
15:45:54 <ih> both are bad for sum
15:46:21 <Peaker> dons: is that really the mac symbol? Why not Apple's icon?
15:46:32 <ih> thanks for the help
15:46:35 <Twey> Licensing…
15:46:36 <Entroacceptor> license stuff
15:46:39 <Peaker> ah
15:46:52 <edwardk> consider the output of foldr (:) []  and the equivalent foldl horrorshow ;)
15:47:32 <edwardk> and figure out how many constructors you have to pattern match against and how much work each has to do to reveal if it is a (:) or a []
15:48:01 <ih> ok cool, i have to go, but i will work through that example
15:48:10 <Entroacceptor> http://foldl.com http://foldr.com
15:48:28 <Entroacceptor> oh
15:48:32 <Entroacceptor> not foldl.com
15:49:02 <sbahra> dons, much better.
15:49:23 <Peaker> foldl.com gives me a phishing warning
15:49:36 <edwardk> i wonder when that lapsed and was snatched
15:49:37 <Twey> It got the hijacked
15:49:38 <Entroacceptor> yeah, I just looked at foldr to make sure
15:49:53 <dons> sbahra: looks good.
15:49:57 <dons> thanks everyone, dankna, sbahra
15:50:27 <stulli> dons: There should probably a reference to the HP on the cabal-install page: http://www.haskell.org/haskellwiki/Cabal/How_to_install_a_Cabal_package
15:50:40 <dankna> welcome
15:53:07 <dons> ah yes
15:54:24 <dons> stulli: done.
15:54:27 <applicative> dons, I decentered the button on haskell.org, does it look worse?
15:54:42 <dons> i think so :)
15:54:47 <applicative> okay
15:54:54 <dons> but can you see how to get the alt tag to display?
15:54:59 <dons> so we don't need the link underneath
15:55:02 <dons> for  text users.
15:55:14 <Entroacceptor> and still, can you please change the color of the main heading? the red looks really ugly, at least for me
15:55:17 <applicative> oh yes.
15:55:21 <dons> Entroacceptor: that's a separate issue
15:55:26 <dons> have to modify the wikimedia template
15:55:31 <dons> and i don't have write access to it.
15:55:40 <Entroacceptor> ah
15:55:42 <dons> we've got a separate effort  to redesign the front page and template
15:55:45 <dons> but can't do that now.
15:56:00 <dons> the front page probably won't be a wiki page, for example
15:56:03 <dons> though much the same content
15:56:14 <tsou> the "Download Haskell" and "Find A Library" links won't stay there, right?
15:56:18 <dons> i like the content, just the design looks very old.
15:56:21 <dons> tsou: right
15:56:39 <dons> sbahra: we need a separate logo for 'Search Hackage' I think
15:56:56 <dons> maybe
15:57:08 <dons> argh, what is applicative doing!
15:57:14 <dons> applicative: can you use 'preview' please
15:57:16 <dons> until it works
15:57:36 <dons> :)
15:57:55 <dons> annoyingly the alt text shows up as "button-100.png "
16:00:20 <HugoDaniel> hello
16:00:57 <jmcarthur> i mentioned to my wife that we are talking about the haskell.org front page, and that we are trying to attact more people to haskell. she said the front page needs boobs
16:01:09 <Twey> Ha
16:01:22 <Twey> Nothing like a pair of breasts for that classy, professional look
16:01:42 <Twey> Maybe we should just stick the ((.) (.)) function on there
16:02:03 <jmcarthur> Twey: what? i was talking about birds
16:02:06 <edwardk> jmcarthur: yes, but would that necessarily attract the right people?
16:02:42 <Twey> jmcarthur: Those are boobies :þ
16:02:55 <jmcarthur> i think i might be thinking tits
16:02:58 <jmcarthur> that's a kind of bird
16:03:08 <tsou> dons: <img src="http://hackage.haskell.org/platform/icons/button-100.png" alt="button-100.png" />
16:03:25 <dons> tsou: yes, but in wiki syntax :)
16:03:38 <MisterN> :t ((.) (.))
16:03:39 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
16:03:42 <MisterN> \o/
16:03:50 <dons> [http://haskell.org/platform http://haskell.org/platform/icons/button-100.png] <-- like that
16:03:51 <MisterN> :t (.)
16:03:52 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:04:17 <MisterN> @src (.)
16:04:17 <lambdabot> (f . g) x = f (g x)
16:04:52 <zygoloid> no new shiny for windows yet? ;(
16:05:00 <dons> yes, there's a beta installer
16:05:08 <dons> feedback wanted. check haskell.reddit.com for the link
16:05:20 <dons> i want dcoutts opinion on the cabal bug
16:06:00 <tsou> dons: oops, i got confused with the other <img> tag for the logo
16:08:01 <tsou> ...damn dblatex can't escape backslashes properly :(
16:08:28 <benmachine> Cale: http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi?expr=let+foldr+f+z+%5B%5D+%3D+z%0D%0A++++foldr+f+z+%28x+%3A+xs%29+%3D+f+x+%28foldr+f+z+xs%29%0D%0A++++%5B%5D+%2B%2B+ys+%3D+ys%0D%0A++++%28x+%3A+xs%29+%2B%2B+ys+%3D+x+%3A+%28xs+%2B%2B+ys%29%0D%0A++in+foldr+%28%2B%2B%29+%5B%5D+%5B%5B1%5D%2C+%5B2%5D%2C+%5B3%5D%5D working on it :P
16:08:40 <crash[`]> Hey folks; on OSX 10.6.1, just installed the Haskell platform 2010, trying to get gtk2hs installed (using both macports and trying to build from source.) I get the following error though: Failed to load interface for `System.Glib.UTFString':. Any clues how to solve the problem, or what further information do I need to provide :)
16:09:32 <Eridius> why does installing the Haskell Platform on OS X require logging out? I can't see anything in this package that would require it. The only thing I can think of is if I have any apps that are using dynamic libs from the haskell platform, but I don't have any of those
16:10:01 <benmachine> hmm, my infix application/parenthising stuff is off
16:10:13 <dons> Eridius: maybe file a bug ticket to query this ?
16:10:26 <dons> crash[`]: i think you need gtk2hs from darcs
16:10:32 <cao> dons: looks promising, i'll give it a try
16:11:08 <crash[`]> dons: what's the repo url?
16:11:15 <cao> (yi ofc)
16:12:47 <dons> code.haskell.org/gtk2hs i think
16:13:22 <crash[`]> thank you sir
16:13:37 <crash[`]> that looks correct
16:14:29 <Cale> benmachine: nice :)
16:15:02 <Eridius> ok ticket filed
16:15:49 * hackagebot TV 0.4.6 - Tangible Values -- composable interfaces  http://hackage.haskell.org/package/TV-0.4.6 (ConalElliott)
16:19:48 <tsou> Is there anyone here who has managed to make 6.12.1 including the docs?
16:33:54 <applicative> tsou, I made the library docs.
16:33:56 * hackagebot applicative-numbers 0.0.9 - Applicative-based numeric instances  http://hackage.haskell.org/package/applicative-numbers-0.0.9 (ConalElliott)
16:35:18 <applicative> dons, the haskell.org wiki markup is a little mysterious.  I tried various ways of getting pandoc to tell me What Mediawiki Would Do, but they don't work
16:36:16 <dons> there's a way to include raw html though, iirc
16:36:20 <dons> mediawiki is odd
16:37:04 <sm> you probably want to follow the editform help links, pandoc's MW markup will not be identical
16:37:16 <sm> and yes it is rough going
16:37:57 <sm> hey, now that pandoc supports MW, how about a move to gitit ?
16:38:39 <applicative> mediawiki would want something like [http://hackage.haskell.org/platform [[Image:http://hackage.haskell.org/platform/icons/button-100.png|haskell platform download]]]
16:38:49 <bremner_> If I think of (>>=) as "and" in the context of e.g. the Maybe Monad, is there a usual notation for the or equivalent?
16:38:54 <jlouis> note to self: IORefs are pesky :)
16:38:59 * hackagebot checkers 0.2.6 - Check properties on standard classes and data structures.  http://hackage.haskell.org/package/checkers-0.2.6 (ConalElliott)
16:39:45 <liyang> bremner_: `mplus` in the MonadPlus typeclass.
16:40:45 <bremner_> I see parsec is using <|>, I _think_ for the same idea
16:41:26 <bremner_> oh, I see <|> is a bit smarter/more specialized
16:41:36 <liyang> I saw an Alternative typeclass with a <|> somewhere recently. I don't think there's a consensus yet.
16:41:52 <kmc> it's in Control.Applicative
16:42:01 * hackagebot vector-space 0.6.1 - Vector & affine spaces, linear maps, and derivatives (requires ghc 6.9 or better)  http://hackage.haskell.org/package/vector-space-0.6.1 (ConalElliott)
16:42:22 <kmc> if you have the right instances you can (and should?) hide Parsec's (<|>) and use the more general Applicative one
16:42:33 <kmc> which also fits in with <$> and <*> and such
16:42:35 <liyang> kmc: Oh? That's new. :3 Shows you how long it's been since I've actually done any hacking in Haskell.
16:42:54 <kmc> yes, Applicative got popular recently
16:43:22 <kmc> it captures an idea weaker / more general than Monad and stronger / more specific than Functor
16:43:38 <benmachine> HSE doesn't seem to be parsing foralled types correctly
16:43:41 <kmc> fr. ex. the Parsec parsers you can write with Applicative are precisely the context-free grammars, whereas a monadic Parsec parser can be context-sensitive
16:43:52 <tsou> applicative: do you happen to remember what version of dblatex did you use?  ...and if you had to tweak it somehow?
16:44:05 <benmachine> hmm
16:44:14 <benmachine> forall is effectively a keyword in types right?
16:44:17 <kmc> yes
16:44:26 <benmachine> so you can't have a typevar named forall?
16:44:26 <kmc> and i think any Monad which is also Alternative should have mplus = (<|>)
16:44:47 <kmc> benmachine, correct, if you have the extensions that enable "forall" turned on
16:44:52 <kmc> forall is not a keyword in H98 or H2010
16:45:20 <benmachine> ghci> parseWithExts "forall a. a" :: ParseResult Type
16:45:20 <benmachine> ParseOk (TyInfix (TyApp (TyVar (Ident "forall")) (TyVar (Ident "a"))) (UnQual (Symbol ".")) (TyVar (Ident "a")))
16:45:28 <benmachine> ^ this isn't quite right
16:45:54 <benmachine> (parseWithExts is my own invention, just parseWithMode configured to have RankNTypes and TypeOperators)
16:45:55 <monochrom> if you turn off extensions you can use forall as variable
16:46:03 * hackagebot lub 0.0.6 - least upper bounds -- information merging  http://hackage.haskell.org/package/lub-0.0.6 (ConalElliott)
16:46:10 <kmc> benmachine, maybe you need to turn on another extension
16:46:18 <kmc> RankNTypes enables the forall kw for GHC but HSE might have a different idea
16:46:43 <benmachine> how can you have RankNTypes without forall?
16:46:47 * benmachine tries ScopedTypeVariables
16:47:12 <benmachine> it seems to think that . is a type operator
16:47:40 <benmachine> even if I disable type oprators, it then just says ParseFailed TypeOperators is not enabled
16:48:38 <kmc> awkward
16:51:04 * hackagebot data-treify 0.3.1 - Reify a recursive data structure into an explicit graph.  http://hackage.haskell.org/package/data-treify-0.3.1 (ConalElliott)
16:53:06 <applicative> tsou, I see, you mean the user's manual?  you want a latex version
16:53:48 <applicative> tsou, the pdf is here.  Not sure what the source is http://www.haskell.org/ghc/docs/latest/users_guide.pdf
16:54:43 <Phyx-> there, finally managed to crash my program
16:56:04 <diegoeche> strangely just by installing ghc-6 in ubuntu ghc6.12 started to work normally :S
16:56:45 <tsou> applicative: no no, I don't mean the user's manual..  'make'ing 6.12.1, at some point runs dblatex on some xml files to generate latex files.  But the generated .tex files are erroneous on my machine.
16:57:12 <tsou> I'm not sure if it's Cabal.xml's fault, dblatex's fault, or some other fault that I cannot think of..
17:02:04 <jlouis> What is haskells representation of an unboxed mutable array of Bools?
17:02:23 <ddarius> UArr Bool is a bit array.
17:02:48 <jlouis> wonderful, just as I need
17:04:30 <ddarius> Er, that was an immutable array...
17:04:50 <benmachine> STUArray Bool?
17:04:55 <dons> jlouis: for STUArray is it bit packed bool
17:04:59 <dons> uvector uses bit packing too
17:05:03 <dons> i'm not sure about vector
17:05:10 <dons> you can also write your own bit-packing instance for vector if nec.
17:05:12 <monochrom> http://www.vex.net/~trebla/tmp/family.hs  is an error in GHC 6.10.4, despite the manual (of 6.10.4 again) has a similar example. Is it known?
17:05:24 <ddarius> I don't -think- vector does, but I'm not 100% sure about that.
17:05:25 <dons> depending on the size, the bit packing can be a win or loss
17:05:37 <dons> yeah, my recollection is that rl removed the bit packing code
17:05:50 * dons checks in the primitive package
17:05:54 <kmc> monochrom, where is it in the manual?
17:06:03 <kmc> that family decl doesn't make much sense
17:06:12 <kmc> as it says, a family must have at least one index
17:06:20 <kmc> otherwise, it'd be a normal polymorphic type
17:06:25 <dons> oh, higher level than that.
17:06:37 <kmc> (though, one wonders if that should be accepted as a weird way to write a normal polymorphic type)
17:06:47 <ddarius> kmc: Probably.
17:07:03 <ddarius> kmc: It'd be nicer for code generators, for example.
17:07:38 <dons> newtype instance Vector    Bool = V_Bool  (P.Vector    Word8)
17:07:52 <dons> jlouis: ^ fyi. if you're using Vector.
17:09:15 <monochrom> kmc: http://www.haskell.org/ghc/docs/6.10.4/html/users_guide/type-families.html#data-family-declarations  "data family Array :: * -> *".  The kind signature already assures at least one index.
17:11:28 <kmc> i don't think it does -- i think GHC makes a distinction between the indices of a type family (on which it can be ad-hoc polymorphic) and the parameters more generally
17:11:36 <kmc> but i agree that's inconsistent with what the manual says
17:11:50 <ddarius> I'm inclined to consider it an error in the documentation.
17:12:03 <kmc> the index/parameter distinction is useful and common to make in general
17:12:40 <ddarius> I thought it was necessary for (later) data family implementations.
17:14:03 <kmc> hmm
17:14:23 <kmc> but it will accept:  data family A x :: * -> *;  data instance A () () = AUU; data instance A () Bool = AUB
17:15:18 <kmc> which is declared syntactically with one index, but used as if it had two indices
17:15:46 <kmc> so it's just a weird syntactic limitation that it wants to see at least one index syntactically
17:15:49 <kmc> that's dumb :/
17:16:31 <monochrom> I haven't tried 6.12. Did you?
17:16:38 <kmc> no
17:17:06 <kmc> it works
17:17:16 <c_wraith> anyone know why haddock would be leaving out parts of my documentation in 6.12?  There's no pattern I can see.  In 6.10, it generates everything I expect.
17:19:15 <monochrom> you mean you build the same haddock source code on 6.10 and get correct results?
17:20:39 <monochrom> I think this phenomenon is known. hackage has lots of examples of this bug.
17:21:07 <c_wraith> Err, no, actually, I think they're different versions of haddock
17:21:34 <aavogt> @hackage haddock
17:21:34 <lambdabot> http://hackage.haskell.org/package/haddock
17:22:03 <c_wraith> I have two completely independent dev environments.  The one built from 2009 haskell platform (ghc 6.10.4) builds the docs correctly when I do cabal haddock.
17:22:21 <c_wraith> The one built from 6.12.1 (pre-platform release) builds the docs incorrectly when I do cabal haddock
17:22:38 <aavogt> c_wraith: how about with a newer haddock?
17:23:54 <c_wraith> on 6.12 or 6.10?
17:32:10 <jeffwheeler> . . . ?
17:32:39 --- mode: calvino.freenode.net set +o ChanServ
17:33:25 <FliPPeh> Oh god
17:40:55 <tsou> is there a way to find the link of the 2009 platform?
17:42:51 <alp> hm
17:46:31 <pickles> tsou: no clue, try googling?
17:46:52 <tsou> pickles: no, i meant, through the site
17:47:08 <pickles> no idea
17:47:18 <tsou> as in "shouldn't there be a link to the 2009 platform in the platform site?"
17:47:19 <tsou> heh
17:47:48 <pickles> heheh, one would think ;)
17:49:21 <c_wraith> newest version of haddock on 6.12 still fails to build some of my docs
17:59:35 <Guest15468> Hey guys, im trying to understand recursion and i know that haskell is all about it, im having trouble understanding the concept and its application
18:00:01 <c_wraith> Actually, you don't use explicit recursion that often in haskell.
18:00:11 <dancor> is there propaganda i can read on why laziness as the default is good
18:00:11 <c_wraith> You tend to use functions that abstract out patterns of recursion instead
18:01:38 <monochrom> John Hughes has one. Cale has one.
18:01:53 <medfly> monochrom, one what?
18:01:58 <c_wraith> Guest15468: Do you have a specific problem you're trying to solve?
18:02:00 <dancor> propagandum
18:02:01 <monochrom> Hughes's "why functional programming matters" is largely about why laziness.
18:02:12 <medfly> oh, okay.
18:04:21 <monochrom> There is nothing to "understand" about recursion. It works. It just works.
18:04:34 <erikc> is something holding up the 2010 platform for windows
18:04:49 <monochrom> People find it hard because people over-analyze and invoke too much philosophy.
18:05:32 <jlouis> dons: thanks. What would you go with, if space was the primary concern?
18:05:59 <c_wraith> yeah.  I never understood the big deal about recursion.
18:06:48 <anhsir>  /join #mozilla
18:06:59 <anhsir> damn, keep doing that
18:07:21 <Alpounet> erikc, it's being tested and feedback is welcome
18:07:45 <erikc> Alpounet: oh, where can i grab the installer?
18:08:56 <stulli> erikc: http://code.haskell.org/~refold/HaskellPlatform-2010.1.0.0-setup.exe
18:10:37 <HugoDaniel2> i want to know whats the best way to do a haskell scheduler for thread management
18:10:47 <HugoDaniel2> where can i read about that ? is there any existing libs that do that ?
18:12:55 <Alpounet> HugoDaniel2, ghc's rts itself ? heh
18:13:24 <aavogt> I don't believe that that part is written in haskell though
18:13:53 <kmc> HugoDaniel2, you want to roll your own threading system?
18:14:05 <kmc> as an exercise, or is there some reason the built-in threading is not adequate?
18:14:07 <Alpounet> aavogt, it's in C yeah
18:14:23 <jlouis> I've found the RTS threading to be awfully fast
18:14:31 <HugoDaniel2> this is just as an exercise
18:14:41 <kmc> HugoDaniel2, you can implement cooperative multithreading with continuations
18:14:55 <HugoDaniel2> really ? how ?
18:15:09 <HugoDaniel2> that seems interesting
18:16:47 <kmc> as a special case of co-routines
18:17:51 <HugoDaniel2> oh
18:18:09 <HugoDaniel2> kmc: where can i read about coop multithreading through continuations ?
18:18:51 <monochrom> Oleg has one.
18:20:18 <kmc> google
18:20:19 <kmc> not sure really
18:20:29 <kmc> just play with continuations and it will make sense :)
18:20:34 <kmc> might be easiest to do in Scheme
18:20:56 <HugoDaniel2> hmm
18:21:06 <aavogt> kmc: what's the difference?
18:21:32 <kmc> in scheme you can get the current continuation anywhere
18:21:51 <HugoDaniel2> playing with the continuation monad ?
18:22:07 <kmc> in Haskell you can only do it within a continuation monad
18:22:09 <aavogt> so as opposed to callCC being only for monadic code in haskell, right?
18:22:16 <kmc> yes
18:22:37 <kmc> and in Haskell you don't invoke a continuation just by applying a function
18:22:37 <Axman6> lhames: you're in AU right?
18:22:45 <kmc> you apply a function and then sequence the resulting monadic action
18:23:30 <HugoDaniel2> ill just use mvars and forkIO :P
18:24:23 <lhames> Axman6: Yep.
18:25:09 <kmc> HugoDaniel2, well, i thought the exercise was to implement your own threading system
18:25:19 <HugoDaniel2> :)
18:25:22 <kmc> ofc if you want to get stuff done, you should use the builtin threads without some good reason
18:25:32 <kmc> or better yet, implicit parallel evaluation if it fits your task
18:25:56 <kmc> in which case you don't have to think about threads at all
18:26:07 <HugoDaniel2> bultin threads ?
18:26:33 <kmc> yes, the ones supported directly by the GHC RTS
18:26:37 <kmc> the ones you get with forkIO
18:27:53 <lhames> Axman6: You?
18:28:13 <jlouis> HugoDaniel2: forkIO'ed threads are wonderfully lightweight. I can't really measure I have 800 of them running
18:28:27 <lhames> Axman6: Ahh you're at ANU. Hey - I'm just down the road at the moment.
18:28:38 <HugoDaniel2> ah, thanks :)
18:28:52 <jlouis> Other than things using Data.IntSet where uvector or vector is perhaps the right data structure
18:30:31 <kmc> they're also simple to use
18:30:37 <kmc> because Haskell is a good imperative language
18:31:04 <[swift]> is there a paper on the implementation of forkIO'd threads?
18:31:06 <kmc> but threads have a bad reputation, so people will try to avoid them anyway
18:31:10 <[swift]> do they use work stealing or what?
18:31:29 <kmc> [swift], http://www.haskell.org/ghc/docs/papers/concurrent-haskell.ps.gz for one
18:31:40 <kmc> that discusses iirc more the semantics and possible implementation methods, rather than what GHC actually does
18:31:46 <kmc> i read some paper more the latter by Simon Marlow
18:32:00 <kmc> yeah just read everything here :D  http://www.haskell.org/~simonmar/bib/bib.html
18:32:05 <[swift]> kmc: haha perfect =)
18:32:36 <[swift]> kmc: was having a discussion the other day about whether haskell was good for concurrency and the best i could offer was that benchmarks i had seen suggested it was
18:32:48 <[swift]> kmc: after reading these i'll be able to make a more cogent argument
18:33:08 <Eridius> ugh, I'm not seeing any indication that the current OS X haskell platform installer actually symlinks binaries into place or replaces the old cabal
18:33:29 <kmc> [swift], performance is only one aspect
18:33:57 <kmc> i think it's good because it makes threads easy
18:34:16 <kmc> because Haskell has first-class imperative actions
18:34:34 <kmc> whereas most languages claiming to be good at imperative programming make that harder than it needs to be
18:34:55 <kmc> [swift], i have a little example of this, sec
18:34:56 <[swift]> kmc: yeah, i think that is a solid argument as well, but the context was "if i implement this in haskell and benchmark it, do the benchmarks tell us much or does concurrency in haskell have too much overhead?"
18:35:20 <[swift]> kmc: sounds interesting
18:35:48 <kmc> [swift], http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24342#a24342
18:36:14 <[swift]> kmc: basically i'm hoping that haskell can scale comparably to tuned c++ even if there's a constant factor difference
18:36:35 <kmc> it's an IO action that spawns a log-writer thread and returns a function which produces IO actions to send a message to that thread
18:36:52 <kmc> in 3 simple lines of code
18:36:58 <djahandarie> [swift], depends how much you "tune" the C
18:37:04 <[swift]> kmc: wow, that's quite elegant!
18:37:25 <kmc> i don't know any other language where this is so clean, without using libraries higher-level than the basic threading stuff that comes built in
18:37:42 <djahandarie> [swift], you can get fast multicore programs created in a small amount of time with few lines of code in Haskell
18:38:17 <djahandarie> [swift], making them faster isn't much harder, just need to drop in some strictness usually, sometimes you may need to do some deforestation
18:38:36 <djahandarie> [swift], compared to C++ however, that's really comparitvely amazing easier to do
18:38:55 <kmc> it uses higher-order functions and IO actions and closure over free variables to accomplish a very imperative task
18:38:57 <[swift]> djahandarie: that sounds ideal
18:39:13 <djahandarie> [swift], and the backends for Haskell have been getting faster... at a fast rate.
18:39:15 <kmc> and so i think it's a good little example of why the supposed opposition of functional and imperative programming is bullshit
18:39:35 <djahandarie> [swift], on some programs the "constant factor" is actually on the other side of the equation
18:39:43 <kmc> there are some nice more involved examples of that in "Beautiful Concurrency"
18:39:52 <djahandarie> Anyways </rant> brb
18:40:04 * hackagebot cuboid 0.12 - 3D Yampa/GLUT Puzzle Game  http://hackage.haskell.org/package/cuboid-0.12 (PedroMartins)
18:40:07 <[swift]> kmc: haha, as a relatively new functional programmer i suppose i should consider myself lucky that i haven't picked up that bias in the first place
18:40:13 <aavogt> djahandarie is being quite optimistic about how easy it is to get actual speedups though
18:40:13 <kmc> yes you should :)
18:40:31 <kmc> it's annoying from both sides
18:40:33 <djahandarie> aavogt, well, depends on how much you want to crank out of it
18:40:37 <danderson> as an example, I'm implementing a routing engine in haskell, and even my initial implementation has speeds on par with a naive C implementation, thanks to the right data structure choices
18:40:51 <[swift]> danderson: that's very good to hear!
18:40:55 <aavogt> if you use   `par`  too often and for small computations, you will have too much overhead
18:40:58 <danderson> (ByteString for data chunks, attoparsec for parsing, cereal for serialization)
18:41:17 <danderson> and the implementation is way, way simpler than what I'd have done in C
18:41:36 <aavogt> but there are higher level ways to split up your task
18:41:53 <danderson> *and* I fully believe that if someone with experience in high performance haskell looked at my code, they could get at least an order of magnitude of improvement in a couple of hours, tops
18:41:55 <aavogt> see Control.Parallel.Strategies
18:42:07 <[swift]> aavogt: thanks for the pointer, i'll look into that
18:42:11 <kmc> Haskell is more about "get it working quickly, then make it fast"
18:42:25 <kmc> rather than spending all the effort up front to get it working at all
18:42:32 <kmc> (and having something fast as a by-product)
18:42:44 <[swift]> basically my main concern was: is the amount of work you have to have for a thread to make it worth the overhead of starting it larger in haskell than in C++?
18:43:02 <[swift]> or, for shorthand, how much overhead does starting a new (logical) thread have in haskell?
18:43:06 <kmc> [swift], very little
18:43:13 <danderson> [swift]: threads are ridiculously cheap in haskell
18:43:14 <kmc> and creating a "spark" with par has even less overthread
18:43:35 <danderson> that doesn't mean you should fire one up at every single occasion, but you can be much less thrifty than in C/C++
18:43:36 <[swift]> fantastic
18:43:36 <kmc> [swift], did you see http://donsbot.wordpress.com/2009/09/05/defun-2009-multicore-programming-in-haskell-now/
18:43:47 <djahandarie> [swift], if the rest of the compution will end up taking less than the thread starting off, sounds like you should be doing ASM
18:43:54 <kmc> if you want parallel evaluation, as opposed to concurrent semantics, you can avoid thinking about threads at all
18:43:56 <[swift]> kmc: i did not, checking it out now
18:44:02 <djahandarie> That's a good presentation
18:44:03 <kmc> you can create sparks with par and friends, which are very cheap
18:44:04 <danderson> for example, in my routing server, I spark of 2 threads per connecting client
18:44:14 <djahandarie> Is that the one with the drawing of sparks and stuff
18:44:21 <danderson> and I expect this to scale to a couple thousand clients easily (and more, with the future new I/O manager)
18:44:36 <danderson> s/spark of/start off/
18:44:39 <danderson> stupid fingers.
18:44:48 <[swift]> djahandarie: well in some prototyping languages with shit concurrency support (eg python, don't get me started), the unit of work needed to make it worth starting a new thread or process is absurdly large
18:44:51 <kmc> then a RTS OS-thread will convert one of your sparks to a Haskell-thread if it's bored and has nothing to do
18:45:11 <[swift]> djahandarie: i don't mean to imply that python is just a prototyping language btw, that's just what i have used it for in the past
18:45:40 <[swift]> danderson: awesome, glad to hear that something like that is working well
18:45:45 <kmc> python would be better for things beyond prototyping if there were a good implementation
18:45:50 <[swift]> kmc: sounds like work stealing =)
18:46:10 <djahandarie> [swift], the overhead is little enough to not need to worry about it in that sense
18:46:19 <kmc> [swift], yeah, but it's a separate queue than the queue of forkIO'd threads
18:46:54 <[swift]> kmc: hmm, interesting. i think i'll have to read up on this because i don't really know what a spark is =)
18:46:55 <kmc> a forkIO thread is a semantically-relevant executing IO action with observable ordering.  a spark is just an annotation to transparently do some work in parallel without changing semantics at all
18:47:16 <djahandarie> You may also want to read that post talking about Concurrency vs Parallelism
18:47:20 <djahandarie> Written by one of the simons
18:47:22 <djahandarie> Marlow I thin
18:47:22 <danderson> [swift]: as an example, I've just realized that I've not been compiling my program right. I didn't turn on -threaded
18:47:26 <kmc> in most languages you have to go to the effort of using concurrency just to get parallelism.  in Haskell we have two very different ways to deal with these two different things
18:47:44 <danderson> and the structure of my router means I could actually scale across N cores trivially to reduce routing latency
18:48:09 * aavogt wants auto-parallelized programs already
18:48:20 <[swift]> kmc: cool, i'll look into it. this all sounds very exciting. i feel like i've been in a PL ghetto writing threaded C++ code =)
18:48:27 <djahandarie> aavogt, you can! But it'll be slow!
18:48:48 <djahandarie> Has there been any research/work into doing that efficiently btw?
18:48:48 <[swift]> danderson: nice!
18:50:53 <aavogt> djahandarie: I imagine lots
18:51:21 <AlexM> Hi
18:51:22 <aavogt> it's quite a desirable target
18:51:28 <djahandarie> aavogt, well I was thinking directly in terms of GHC/haskell
18:51:32 <AlexM> can anyone explain the bind from the state monad to me:
18:51:32 <aavogt> hello AlexM
18:51:32 <AlexM> -- "bind" modifies m so that it applies f to its result.
18:51:33 <AlexM> m >>= f = \r -> let (x, s) = m r in (f x) s
18:51:34 <djahandarie> I'm sure its been done more abstractly
18:51:49 <AlexM> I think i'm confused by the syntax not the idea
18:51:54 <kmc> AlexM, a value of type (State s a) is just sugar for a function of type (s -> (a, s))
18:51:57 <kmc> @unmtl State s a
18:51:57 <lambdabot> s -> (a, s)
18:51:59 <AlexM> what is m r doing here?
18:52:00 <kmc> AlexM, with me so far?
18:52:20 <AlexM> yes I get that kmc
18:52:29 <AlexM> it's the last section that I'm confused by
18:52:46 <AlexM> f is applied to x to form a new state which is returned to m r ?
18:52:49 <kmc> AlexM, so actually i don't think that's correct
18:52:49 <aavogt> well there is no data / newtype here
18:53:02 <kmc> yeah, you need to wrap and un-wrap the ctors
18:53:14 <AlexM> this is from wikipedia
18:53:16 <AlexM> :- S
18:53:22 <kmc> wikipedia is wrong?
18:53:24 <kmc> perish the thought ;)
18:53:30 <aavogt> it could work, but it would overlap with other interesting monad instance
18:53:34 <djahandarie> kmc, thoughtcrime!!!
18:53:34 <kmc> they're probably eliding the constructors for simplicity of explanation
18:54:01 <djahandarie> Simplicity killed the cat
18:54:05 <AlexM> http://en.wikipedia.org/wiki/Monad_%28functional_programming%29#State_monads
18:54:14 <djahandarie> Schrodinger's cat
18:54:25 <AlexM> I know wikipedia isn't always correct
18:54:39 <AlexM> but usually people who think it's always wrong are conspiracy type idiots
18:54:51 <AlexM> anyway...
18:54:56 <idnar> AlexM: it's always inaccurate ;)
18:54:59 <AlexM> so kmc, can you go on?
18:55:17 <kmc> (State m1) >>= f = State (\s1 -> let (x, s2) = m1 s1 ; State m2 = f x in m2 s2)
18:55:20 <aavogt> in that if you wrote that one in haskell, you would not be able to write the instance for Reader at the same time
18:55:28 <kmc> here we do the wrapping and unwrapping of the State value constructor explicitly
18:55:42 <aavogt> kmc: that only hides what's going on
18:55:55 <kmc> the version in the actual library is:    m >>= k = State $ \s -> let (a, s') = runState m s in runState (k a) s'
18:56:06 <kmc> which uses runState, which would be defined simply as runState (State m) = m
18:56:12 <aavogt> as a workaround to haskell's crappy instance selection methods
18:56:19 <kmc> aavogt, agreed
18:56:27 <AlexM> ok
18:56:37 <AlexM> lemme take a few minutes to look at that
18:56:41 <aavogt> so don't think about the version with the constructors
18:58:14 <AlexM> (\s1 -> let (x, s2) = m1 s1 < kmc, so this is just returning the original state first?
18:58:47 <aavogt> hmm, I don't understand why somebody put in that page: applyState :: State s a -> s -> (a, s)
18:59:16 <AlexM> hello ?
18:59:24 <shapr> hi!
18:59:34 <aavogt> if you don't have a constructor, applyState is just id
18:59:40 <AlexM> kmc: ?
18:59:57 <kmc> hi
19:00:25 <AlexM> kmc: (\s1 -> let (x, s2) = m1 s1 < kmc, so this is just returning the original state first?
19:01:14 <kmc> i don't know what you mean
19:01:31 <aavogt> AlexM: grab the current state, and pass it to the function that you're binding to
19:01:32 <AlexM> oh, erm, what does that first section to ? (the one I posted)
19:01:42 <AlexM> ok :)
19:02:00 <aavogt> then you have the result  x, and the next state s2
19:03:12 <AlexM> ah, yeah
19:03:14 <AlexM> makes sense now
19:03:15 <AlexM> sorry!
19:03:20 <AlexM> Just took a while...
19:03:44 <AlexM> I think the binding was throwing me...
19:03:58 <aavogt> actually the m1 is from the previous computation
19:04:11 <AlexM> yeah
19:04:12 <AlexM> the input
19:04:27 <AlexM> it's just an id function right?, well actually not id, but just uses the return ?
19:04:43 <aavogt> which id function?
19:05:06 <AlexM> I mean it just gets the input?
19:05:09 <AlexM> m1
19:05:24 <AlexM> great :[
19:06:04 <monochrom> This is a lot of forkFreenode :)
19:06:36 <AlexM> aavogt: what did you mean by "actually the m1 is from the previous computation"?
19:07:46 <AlexM> ugh
19:07:49 <aavogt> AlexM: it's a function s -> (t, s)
19:08:00 <AlexM> ok
19:08:08 <aavogt> you don't have the actual s yet
19:08:17 <AlexM> ye
19:08:24 <AlexM> (State m1) >>= f = State (\s1 -> let (x, s2) = m1 s1 ; State m2 = f x in m2 s2)
19:08:26 <AlexM> so in this
19:08:29 <Axman6> you stole my name!
19:08:30 <aavogt> but that's ok because you return another value in State
19:08:41 <AlexM> the s1 comes from ?
19:08:53 * Axman6 is Alex M also
19:09:13 <aavogt> s1 comes from the bind you used to make  m1
19:09:32 <AlexM> ok
19:10:05 <aavogt> it can be traced back to the runState you use to actually get some value out of it
19:10:19 <AlexM> ok
19:11:15 <aavogt> but you see that m1  produces a new state s2 in addition to the regular value
19:11:17 <Axman6> @tell lhames sorry i didn't reply earlier, I had to work on a lab. are you at all interested in coming to the AusHac2010 hackathon in july (16th-18th)? there's a few of us coming from Canberra, and we might organise some cheap travel if we get enough people
19:11:17 <lambdabot> Consider it noted.
19:12:23 <aavogt> AlexM: have you seen examples where you write code to manually pass the state around?
19:12:40 <AlexM> yeah
19:12:52 <AlexM> a tree relabeller etc
19:13:07 <AlexM> and I have to write a simple compiler using the state monad soon
19:13:40 <EvanR> isnt a compiler essentially a functional process, wouldnt state just get in the way
19:13:40 <aavogt> @type mapAccumL
19:13:40 <AlexM> yeah
19:13:41 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
19:13:46 <AlexM> but where is the regular value returned?
19:13:50 <aavogt> @type mapM
19:13:50 <AlexM> let (x, s2) = m1 s1 ;
19:13:51 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
19:13:53 <AlexM> the m1 here?
19:14:14 <aavogt> AlexM: do you see the similarities between these two functions?
19:14:55 <AlexM> yeah, yout just passing stuff in un-necessarily in the 1st
19:15:03 <aavogt> the parameter order is a bit different if you substitute   m =  s -> (t, s)
19:15:14 <aavogt> but it's the same thing
19:15:16 <AlexM> the monad abstracts it...
19:15:50 <AlexM> aavogt: where is the original value returned?
19:15:51 <AlexM> ...
19:16:06 <AlexM> In here: (State m1) >>= f = State (\s1 -> let (x, s2) = m1 s1 ; State m2 = f x in m2 s2)
19:16:15 <aavogt> AlexM: well the final acc is possibly modified
19:16:28 <aavogt> so you discard s1
19:17:20 <AlexM> is the original value the x in the let?
19:18:12 <AlexM> *original state
19:18:33 <AlexM> aavogt: ?
19:18:38 <aavogt> no, the bind passes that as an argument to f
19:19:02 <aavogt> the x is the value
19:19:02 <AlexM> oh, so what is the original state bound to?
19:19:14 <aavogt> there are inconsistencies in the tuple orderings
19:19:51 <AlexM> but where is the original state, which  name !!
19:19:58 <aavogt> AlexM: the original state is s1
19:20:09 <AlexM> ah, ok :)
19:20:16 <AlexM> I think what was confusing me is
19:20:37 <aavogt> m >>= f = \r -> let (x, s) = m r in (f x) s
19:20:50 <AlexM> I thought the state monad was like this: s -> (newstate, s)
19:20:58 <AlexM> so why is the original state s1? (the 2nd arg)
19:21:09 <AlexM> oh, wait
19:21:18 <AlexM> *I thought the state monad was like this: s -> (s, newstate)
19:23:48 <AlexM> aavogt: but, r is a tuple?
19:23:57 <AlexM> ahh :)..hm
19:24:33 <aavogt> (m :: State S A) >>= (f :: A -> State S B) = \(r::S) -> let (x::A, s::S) = m r in ((f x) s :: (B,S))
19:25:04 <glguy_> AlexM:
19:25:05 <aavogt> where   type State s a = s -> (a,s)
19:25:07 <glguy_> ?unmtl State s a
19:25:08 <lambdabot> s -> (a, s)
19:26:30 <AlexM> so you get: originalstate -> (newstate,oldstate)
19:26:35 <glguy_> no
19:26:44 <glguy_> originalstate -> (result , newstate)
19:26:56 <AlexM> ok
19:30:11 * monochrom begins having fun with type families and data families and the whole families.
19:31:13 <AlexM> glguy_: so the r actually applies the lambda r ?
19:32:28 <AlexM> I get how m = (f x) is the result, I can't get what r is doing
19:32:45 <AlexM> well, x in the let = m = (f x)
19:32:48 <glguy_> I don't know the original question
19:32:54 <glguy_> or what r is
19:32:57 <AlexM> glguy_: m >>= f = \r -> let (x, s) = m r in (f x) s
19:33:02 <AlexM> from the state monad
19:33:44 <glguy_> r is the incoming state value
19:34:04 <aavogt> monochrom is starting a type family?
19:34:05 <AlexM> so, s in the let = \r ?
19:34:05 <glguy_> m a function from state to a result (x) and new state (s)
19:34:15 <monochrom> haha aavogt
19:34:27 <AlexM> glguy_: I mean in m r
19:34:32 <AlexM> not r the lambda
19:35:15 <glguy_> "running" a value whose type is State s a involves providing an 's' and getting back a new 'a' and a new 's'
19:35:21 <glguy_> m r "runs" the computation
19:35:21 <AlexM> but how is the new state s being formed?
19:35:42 <AlexM> in r, but what is r applying?>
19:35:44 <glguy_> The new state is in the result of running 's'
19:35:52 <glguy_> err, 'm'
19:36:05 <AlexM> ahh
19:36:07 <glguy_> let (x, s) = m r
19:36:14 <glguy_> says that the result of m r   is a tuple
19:36:14 <EvanR> so the operation that does the running depends on the instance of State
19:36:39 <glguy_> whose first element is the "result" of running the computation and whose second element is teh new 'state'
19:37:15 <AlexM> yeah
19:37:33 <glguy_> you give the result 'x' to 'f' which gives you a new state computation
19:37:36 <AlexM> so f has to be monadic too?
19:37:38 <EvanR> isnt there a more straight forward way to model a state ;)
19:37:42 <mmmulani> can you add an instance to an imported type?
19:37:55 <Axman6> sure
19:37:57 <glguy_> :t (>>=)
19:37:58 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
19:38:29 <AlexM> glguy_: I get that, but how does s become a new state?
19:39:21 <glguy_> the "type" of the computation is s -> (a , s) ... 's' is a "type" and not a value
19:39:26 <anhsir> can cabal insall multiple versions of a library?
19:39:30 <AlexM> (f x) s, means it applies x to f, but it applies f to s too , ?
19:39:33 <glguy_> so you can have lots of different values whose types are both 's'
19:39:35 <AlexM> but it doesn't seem that way
19:39:35 <anhsir> or even install
19:39:49 <glguy_> AlexM: yeah: f x returns a new function
19:40:24 <AlexM> AHHH
19:40:34 <glguy_> (f x) s   is the same as   f x s
19:40:42 <AlexM> so, (f x) returns the  new runction, and it runs that \r on s ?
19:40:59 <pickles> hey, what's that *->* mean?
19:41:06 <pickles> i tried looking that up once and couldnt find anythign on it
19:41:17 <glguy_> It means it is a function from a type, to a type
19:41:22 <pickles> ah
19:41:24 <glguy_> it is a "kind" or the type of a type
19:41:26 <pickles> so like a functor type thing
19:41:27 <scutigera> anhsir: I believe it can if you specify the full version of the package.  The problem is having your prgram call the correct version.
19:41:34 <AlexM> glguy_: WTF?
19:41:35 <glguy_> :k Maybe
19:41:36 <lambdabot> * -> *
19:41:38 <AlexM> That's why I didn't get it then
19:41:44 <AlexM> how is (f x) s the same as f x s
19:41:46 <AlexM> :s
19:41:58 <EvanR> application is left associative
19:42:14 <EvanR> you can consider all functions to be functions of one variable
19:42:21 <EvanR> just curried
19:42:38 <pickles> yeah, look up currying if you're not familiar
19:42:40 <AlexM> so (f x) s
19:42:41 <glguy_> > let plus x y = x + y in (plus 1) 2
19:42:42 <lambdabot>   3
19:42:43 <AlexM> applies f to x
19:42:49 <pickles> it's quite handy, i miss it in other languages
19:42:53 <AlexM> but also applies that to s ?
19:42:56 <pickles> yes
19:43:07 <EvanR> result of (f x) is applied to s
19:43:07 <pickles> f is a function of two variables, if you look at it that way
19:43:08 <cads> AlexM, in other words, (f x) applies to x to create a function which needs one more parameter to produce a normal value.
19:43:09 <AlexM> but s is a function?
19:43:23 <pickles> when you reply f to x, it returns a function of one variable to the expression
19:43:28 <AlexM> right
19:43:29 <pickles> which when applied to s is evaluated
19:43:35 <glguy_> AlexM, no, the result of (f x) is a function
19:43:47 <AlexM> ah right
19:44:02 <pickles> yay currying!
19:44:11 <pickles> so handy!
19:44:31 <AlexM> so like  (\a -> (\b -> f x) s)
19:44:33 <AlexM> like that ?
19:44:47 <pickles> uh, kinda
19:45:10 * glguy_ wonders if he is on candid camera...
19:45:13 <pickles> start w/: f :: a -> b -> c
19:45:20 <pickles> do: f a
19:45:33 <EvanR> ok stop
19:45:40 <pickles> that returns (\b -> ...) :: c
19:45:43 <pickles> or something like
19:45:53 <EvanR> AlexM: have you even read the manuals?
19:46:12 <AlexM> 1 sec
19:46:25 <pickles> which when applied to the second argument returns your  c
19:46:53 <EvanR> pickles: f :: a -> (b -> c)
19:46:58 <EvanR> makes it more clear
19:47:03 <pickles> tru
19:47:08 <pickles> thx
19:47:47 <pickles> im not doing the best job of explaining -- i've been meaning to come up w/ a tutorial on that type of thing
19:47:58 <EvanR> burritos here we come
19:48:04 <pickles> hahaha
19:48:19 <pickles> and for those reading in the AM, breakfast burritos
19:48:25 <AlexM> right
19:48:47 <AlexM> f x returns a function that's applied to s to return the new state
19:49:04 <pickles> oh wiat, are we still on state monads?
19:49:21 <pickles> i thot we were just doing currying
19:49:55 <applicative> state monad never ends soon enough
19:50:04 <pickles> heheh
19:50:17 <pickles> as for burritos, i think more of a factory line analogy would fit better
19:50:25 <pickles> put raw materials in, process, get stuff out
19:50:31 <ddarius> :t curry id
19:50:32 <lambdabot> forall a b. a -> b -> (a, b)
19:50:33 <aavogt> burrito factory
19:50:37 <EvanR> pickles: you mean, like a function
19:50:52 <ddarius> :t runState . return
19:50:53 <lambdabot> forall s a. a -> s -> (a, s)
19:50:56 <pickles> multiple porcessing stages
19:51:03 <pickles> w/ the monad being what strings them together
19:51:05 <pickles> sequentially
19:51:05 <EvanR> like a function defined as several other functions
19:51:11 <pickles> yeah
19:51:21 <applicative> AlexM: Or you could say, instead of "f x returns a function that's applied to s to return the new state" , that f doesn't know what to do with x till it finds out what state its in (s); when it does, it returns a value, and a new state for further calculation
19:52:22 <AlexM> yup
19:52:41 <AlexM> I do understand currying, I just rushed my answer
19:52:55 <pickles> i seem to do that alot in this channel
19:53:14 <AlexM> I must be extremely dense
19:53:15 <AlexM> :)
19:53:40 <applicative> if I imagine a graph of a finite state machine, I do a bit better than just thinking about the type signature.
19:53:41 <EvanR> a compiler would be simpler to write not as a state monad
19:54:01 <AlexM> The state monad is for labelling
19:54:14 <EvanR> labelling?
19:54:14 <AlexM> e.g. labels for each jmp label for a function call
19:54:32 <EvanR> so youre talking about code generation
19:54:41 <AlexM> yes
19:55:06 <EvanR> i still think it would be simpler as a function from AST to code
19:55:22 <AlexM> well, whatever, it's just an excercise to use the state monad
19:55:30 <AlexM> the compiler part isn't really important
19:55:56 <AlexM> you go do what you want, i'm sure GHC uses the state monad, I can't see how you could write some sections without it
19:56:00 <EvanR> how about an exercise in how state isnt necessary and often detrimental
19:56:02 <pickles> i used state in an assembler i recently wrote for unique addresses
19:56:10 <pickles> *the State monad
19:56:30 <AlexM> EvanR: well, that wouldn't be learning about the state monad would it?
19:56:38 <EvanR> sure it would
19:57:54 <EvanR> you would likely use the state monads state value as a map of labels, screw up the order of updates somewhere and all further operations screw up
19:59:02 <AlexM> it's not concurrent
19:59:11 <applicative> EvanR, what's wrong with the signature s -> (a,s) and a connection ( s -> (a,s) ) -> (a -> (s -> (b,s) ) -> (s -> (b,s))
19:59:44 <EvanR> s -> (a, s) makes sense
19:59:44 <AlexM> if you mess up the order of updates that's just a bug, fix it
19:59:48 <applicative> Nothing, I'd thing, except its too complicated to think about, if you don't have to
19:59:54 <EvanR> AlexM: yes its a bug
20:00:02 <EvanR> bug that could have been avoided
20:00:17 <AlexM> you'd have the same bug without state
20:00:21 <EvanR> these kinds of bugs are hard to track down some times
20:00:28 <AlexM> because you'd still be passing the state around
20:00:34 <EvanR> AlexM: no, because once you verified a single function you know its right
20:00:41 <AlexM> and the "order of updates" could still screw up
20:00:45 <AlexM> according to you
20:00:51 <EvanR> ... you missed the point a while back
20:00:52 <applicative> EvanR, so whats the problem with defining a sense of (>>=) to go with s -> (a,s).  It the language of 'update' 'state' and all that should be annoying you.
20:01:19 <AlexM> Did I?
20:01:25 <EvanR> s -> (a, s) seems more like a connection to me
20:01:40 <AlexM> You just seem to dislike state without a reason other than "it's tehh evilss"
20:02:00 <EvanR> AlexM: definitely not without reason
20:02:12 <pickles> would have been funny if you'd typoed that
20:02:17 <pickles> "it's teh elvis!"
20:02:45 <AlexM> EvanR: What are your reasons then in non-concurrent programs?
20:03:14 <aavogt> State isn't concurrent
20:04:06 <AlexM> he's saying you shouldn't use state because the order of updates might screw up
20:04:15 <AlexM> how could they unless you have a bug or a race condition
20:04:22 <EvanR> i say dont use state for something thats not a stateful problem
20:04:37 <pickles> perhaps if you nested functions which performed updates
20:04:39 <AlexM> well clearly re-labelling is
20:04:49 <EvanR> AlexM: in the obvious absense of concurrency, youre left with bugs
20:04:52 <AlexM> generating unique labels
20:04:54 <pickles> you pulled state in the outer, called the inner which pulled state and updated, then in the outer updated
20:05:08 <pickles> the outer would overwrite the update of the inner
20:05:17 <pickles> is that what you were getting at EvanR?
20:05:35 <EvanR> unknowable
20:05:49 <tensorpudding> @hoogle printStrLn
20:05:49 <lambdabot> No results found
20:05:50 <aavogt> if all you care is that labels are unique, all it really matters is that you define an appropriate function to get and update the current state
20:05:56 <aavogt> putStrLn
20:05:58 <tensorpudding> right
20:06:06 <aavogt> or maybe print
20:06:16 <AlexM> @hoogle putStrLn
20:06:16 <lambdabot> Prelude putStrLn :: String -> IO ()
20:06:17 <lambdabot> Data.ByteString putStrLn :: ByteString -> IO ()
20:06:17 <lambdabot> System.IO putStrLn :: String -> IO ()
20:06:19 <applicative> @src putStrLn
20:06:19 <lambdabot> putStrLn s =  do putStr s; putChar '\n'
20:06:33 <applicative> @src putStr
20:06:33 <lambdabot> putStr s  = hPutStr stdout s
20:06:42 <AlexM> @src getchar
20:06:42 <lambdabot> Source not found. Wrong!  You cheating scum!
20:06:46 <AlexM> @src getChar
20:06:46 <lambdabot> getChar = hGetChar stdin
20:06:56 <aavogt> @type (. or) . (maybe .) . print
20:06:57 <lambdabot>     Couldn't match expected type `Bool -> a'
20:06:57 <lambdabot>            against inferred type `IO ()'
20:06:57 <lambdabot>     Probable cause: `print' is applied to too many arguments
20:06:58 <AlexM> @src hGetChar
20:06:59 <lambdabot> Source not found. Maybe if you used more than just two fingers...
20:07:00 <applicative> @src hPutStr
20:07:00 <EvanR> you could zip the results with the set of natural numbers
20:07:00 <lambdabot> Source not found.
20:07:09 <EvanR> unique labels
20:07:23 <applicative> Something is being kept secret from us!
20:07:43 <AlexM> @src hGetChar
20:07:43 <lambdabot> Source not found. Take a stress pill and think things over.
20:07:44 <AlexM> @src hGetChar
20:07:44 <lambdabot> Source not found.
20:07:44 <AlexM> @src hGetChar
20:07:44 <lambdabot> Source not found. You type like i drive.
20:07:45 <aavogt> well maybe the results are in a more fancy structure like a tree?
20:07:48 <pickles> EvanR: good suggestion, i'll have to look over my code to see if that'd work
20:07:49 <AlexM> LOL
20:08:42 <aavogt> EvanR: and if you want to know what the next unused label can be?
20:09:35 <EvanR> there got to be some combinator for this ;)
20:09:38 <aavogt> but in any case, State is an abstraction over explicitly passing values
20:09:48 <AlexM> aavogt: exactly
20:09:52 <aavogt> EvanR: like >>= ?
20:09:58 <AlexM> aavogt: and that's the whole point of this excercise
20:10:21 <AlexM> EvanR is most probably correct, but, the abstraction the ST monad gives you is nicer
20:10:39 <EvanR> i dont think modelling mutable state is nice
20:10:58 <EvanR> unless its like a database, something specifically made for keeping state
20:11:00 <aavogt> ST is something similar but different
20:11:05 <ddarius> ST and State are quite different
20:11:29 * BMeph keeps the defn 'z0 = zip [0..]' just for such occasions... ;)
20:12:05 <applicative> @src State
20:12:06 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
20:12:09 <aavogt> @type (flip evalState 0 .) . mapM
20:12:10 <lambdabot> forall a a1 b. (Num a) => (a1 -> State a b) -> [a1] -> [b]
20:12:17 <applicative> @src ST
20:12:17 <lambdabot> newtype ST s a = ST (STRep s a)
20:12:21 <EvanR> theres a tree map or something to attach unique labels to things
20:12:27 <applicative> @src STRep
20:12:28 <lambdabot> type STRep s a = State# s -> (# State# s, a #)
20:12:34 <applicative> yipe, evil
20:13:33 <aavogt> @instances Traversable
20:13:34 <lambdabot> Couldn't find class `Traversable'. Try @instances-importing
20:13:34 <AlexM> anyways
20:13:38 <AlexM> g2g
20:13:40 <AlexM> need to sleep
20:13:41 <AlexM> cya
20:13:42 <aavogt> @instances Data.Traversable.Traversable
20:13:42 <lambdabot> Maybe, []
20:13:50 <applicative> nothing could make me use ST, i'm coming around to EvanR 's view
20:13:51 <aavogt> lies. there are more
20:14:41 <ddarius> @help instances-importing
20:14:41 <lambdabot> instances-importing [<module> [<module> [<module...]]] <typeclass>. Fetch the instances of a typeclass, importing specified modules first.
20:15:10 <aavogt> @instances-importing Data.Tree Data.Traversable.Traversable
20:15:11 <lambdabot> Maybe, Tree, []
20:15:37 <aavogt> and traverse is your mapM for stuff like trees
20:15:55 <aavogt> I'm not too sure what the traversal order is
20:16:32 <pickles> if it got the order wrong would that be a traversty?
20:16:43 <EvanR> not in this case
20:17:50 <aavogt> I don't know what the right one would be anyways
20:18:08 * aavogt isn't surprised that people have named all of them
20:18:28 <aavogt> all the ones that treat branches consistently that is
20:19:10 <EvanR> tree traversal order names are a lot like sex position names
20:19:58 <EvanR> i just decided
20:20:50 <pickles> aaand on that note, i'm going to go
20:20:53 <pickles> nite all
20:25:12 <cads> hmm
20:25:57 <cads> Is there a function which matches a input/output vector to a function in a library?
20:27:09 <cads> for example,  findfunk 3 2 [3 3 3]  => replicate
20:27:14 <cads> err
20:27:24 <cads> that should be [2, 2, 2]
20:27:37 <cads> > replicate 3 2
20:27:38 <lambdabot>   [2,2,2]
20:27:42 <cads> yeeah
20:30:21 <aavogt> cads: start with hoogle?
20:30:37 <aavogt> @hoogle Int -> a -> [a]
20:30:38 <lambdabot> Prelude replicate :: Int -> a -> [a]
20:30:38 <lambdabot> Data.List replicate :: Int -> a -> [a]
20:30:38 <lambdabot> Prelude drop :: Int -> [a] -> [a]
20:31:23 <aavogt> actually first infer a type for your example first...
20:33:01 <aavogt> cads: so a printf-style typeclass to apply typeOf to all the arguments collect them up, and then hand things off to hoogle
20:34:35 <kmc> woah, that'd be pimp
20:34:49 <kmc> especially if it returns not the name of the function but the function itself wrapped in Dynamic
20:34:57 <kmc> so you could write an entire program that works by example :D
20:35:02 <cads> not my idea, I think smalltalk had something like it
20:35:18 <cads> But yeah, it doesn't seem very tough :)
20:35:31 <cads> Hoogle is basically how I've been doing it by hand
20:35:52 <ddarius> There's quite a lot of research into programming by example.  It's a quite old field.
20:36:14 <mm_freak_> when using OverloadedStrings, are the strings memoized automatically or do i still need to give them explicit names?
20:36:21 <aavogt> I found the slides for derive pretty interesting
20:36:33 <ddarius> mm_freak_: Why would they be memoized?
20:36:56 <aavogt> that library can infer some typeclasses by example
20:37:16 <mm_freak_> ddarius: well, would make sense to me, and would be convenient, too
20:37:46 <ddarius> mm_freak_: I don't even know what you mean?  Strings aren't memoized, functions are.  Which function would be being memoized there?
20:38:02 <aavogt> cads: and of course filter hoogle's output based on whether the results are actually the right ones
20:38:19 <ddarius> All OverloadedStrings does is turn "foo" into fromString "foo"
20:39:36 <mm_freak_> ddarius: huh?  maybe i'm confusing terms
20:40:02 <cads> Hmm, my query was for a function which would take [1,2,3 ..] and produce [1, 1, 2, 2, 3, 3 ..], which is done by concatMap (replicate 2), so I wonder how useful a naive approach would be for anything other than the most elementary functions.
20:40:07 <mm_freak_> let y = x^2 in print (y, y)  -- y is only computed once, and i thought that's called "memoization"
20:40:39 <aavogt> that's called sharing?
20:40:43 <ddarius> y may be computed more than once (or even less than once).  That's just sharing.
20:40:57 <mm_freak_> oh, ok
20:41:15 <mm_freak_> well, then are string literals shared automatically?
20:41:41 <ddarius> Maybe, maybe not.  I'd say no.
20:42:21 <mm_freak_> any idea how i could figure that out?
20:42:39 <aavogt> mm_freak_: write a fromString instance that also prints stuff via Debug.Trace
20:42:51 <ddarius> Look at the core.  But one example doesn't impact what might happen in another example.
20:43:10 <mm_freak_> ok thanks
20:43:15 <mm_freak_> but what's memoization then?
20:43:31 <aavogt> like here: http://paste.lisp.org/display/96237
20:43:45 <ddarius> mm_freak_: Making a table of results of a function given inputs and looking up the result after the first time calling the function.
20:44:26 <mm_freak_> does GHC do that?  or can i tell it to do it?
20:44:30 <cads> mm_freak_, memoization commits the return values of a function to an array for each value that you call the function with. Future calls to the function using an already computed value results in a plain array lookup rather than recomputing the function.
20:45:13 <cads> mm_freak_, data-memocombinators works pretty well for me here.
20:46:08 <ddarius> aavogt: To make chk1 do what I believe you want, write it using let and lambda so you have chk1 = let ... in \x -> ... instead of chk1 x = ...
20:47:04 <ddarius> mm_freak_: There's no canonical way to memoize a function and memoization has significant costs.  GHC never "memoizes."
20:47:39 <cads> mm_freak_, say that you have a function f which takes a integer value. Applying data-memocombinator's  integral function to f results in a function which memoizes its input.
20:48:31 <aavogt> ddarius: right, if you want to chk2 without polluting the module namespace
20:49:10 <ddarius> aavogt: Exactly.  Of course this behavior isn't guaranteed.  In fact, none of the behaviors you witnessed are guaranteed to happen.
20:49:23 <mm_freak_> cads: that may come in handy for a few things…  thanks
20:50:21 <aavogt> ddarius: so the distinction between haskell being non-strict by the spec, when the implementation incidentally also shares computations
20:51:43 <ddarius> aavogt: Indeed, non-strict /= call-by-need (aka lazy evaluation).  Call-by-name or some mixture or some other method, such as speculative evaluation, are all acceptable as long as they are non-strict.
20:52:53 <aavogt> I guess some optimizations (maybe those involving 'full laziness' probably change what will be printed)
20:53:34 <ddarius> aavogt: Full laziness should lead chk1 behaving like chk2.
21:06:06 <dons> [swift]: did you get an answer on thread costs?
21:06:28 <dons> [swift]: e.g. on a 4G box, you could open up 4M haskell threads, but maybe what, 512 C++ threads?
21:07:44 <[swift]> dons: i didn't get a specific answer, but the general feedback i got made it sound like haskell threads are very cheap
21:08:06 <dons> yes. about the cheapest in any non-research implementation.
21:08:16 <dons> 4M threads on a regular laptop is mostly unprecedented.
21:08:37 <dons> i don't know of any other lang that could do that. maybe erlang, but its slower by far.
21:08:46 <[swift]> dons: oh, those are real numbers and not a hypothetical?
21:08:48 <[swift]> dons: if so, wow!
21:08:51 <dons> yes, real.
21:09:07 <dons> just simple forking in a loop to see how many threads you can spawn
21:09:37 <dons> so in general you need never worry about the cost of threads
21:09:44 <dons> use them as a structuring mechanism.
21:09:50 <dons> the more the better, and they'll use more cores
21:09:51 <[swift]> dons: sounds like they're really lightweight. i haven't had time today but i'm looking forward to reading simon marlow's papers so i can understand how they're implemented
21:09:51 <ddarius> dons: That's not quite true.
21:10:11 <dons> ddarius: what ?
21:10:49 <ddarius> dons: Threads are cheap, but they are not free.  Sparks are even cheaper and you have to worry about how many of them there are occasionally.
21:11:07 <dons> yeah, but sparks we tend to fork e.g. 1B
21:11:13 <dons> forkIO I never worry about
21:11:30 <dons> now, if you forked >1B forkIO threads, I'd worry
21:11:35 <dons> but that doesn't ever seem to happen
21:12:04 <dons> mostly i see people forking < 1k threads with forkIO
21:12:13 <elly> you make a /billion/ sparks?
21:12:16 <ddarius> I've considered making GUI systems where every control is a thread (or a few), even considered having each character have its own thread.
21:12:17 <dons> or say ~2 .. 10k sparks
21:12:22 <dons> elly: it sometimes happens
21:12:32 <elly> how can you possibly have the memory for that?
21:12:43 <dons> we have web servers were every accept is a thread
21:12:49 <kmc> well you could spawn 4M "C++ threads" if you use a fancy custom C++ threading library.  the issue is that threads in C++ usually correspond to OS threads, while threads in GHC Haskell don't
21:12:51 <dons> elly: they cost 1 ptr.
21:13:10 <elly> that is cheaper than I would have thought
21:13:11 <elly> neat
21:13:13 <ddarius> A natural way of implementing buffered channels is to have a thread (or two) for each element of the buffer, but that's pretty heavyweight compared to the other obvious alternative.
21:13:27 <dons> par are just unevaluated things in a set of per-cpu queues in the runtime
21:14:37 <ddelony> "Where" doesn't seem to be working for me.
21:14:41 <kmc> per-cpu but other cpus can steal work?
21:15:09 <aavogt> @where report
21:15:09 <lambdabot> http://www.haskell.org/onlinereport/
21:15:38 <dons> ddelony: the 'where' key work?
21:15:52 <dons> > let f x = y where y = x * 2
21:15:53 <lambdabot>   not an expression: `let f x = y where y = x * 2'
21:15:57 <dons> > let f x = y where y = x * 2 inn f 10
21:15:58 <lambdabot>   not an expression: `let f x = y where y = x * 2 inn f 10'
21:16:01 <dons> > let f x = y where y = x * 2 in f 10
21:16:02 <lambdabot>   20
21:18:44 <ddelony> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24349#a24349
21:19:04 <ddelony> It's exactly as it shows in Learn You A Haskell.
21:19:13 * Deesl is new to haskell
21:19:37 <Adamant> dons: your work on Stack Overflow just saved me having to ask what "sparks" are. Thanks!
21:19:39 <ddelony> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24350#a24350
21:19:45 <ddelony> That's the error I get.
21:20:34 <dons> Adamant: oh, you searched?
21:20:47 <Adamant> dons: yeah, figured I would do that instead of asking
21:20:52 <Adamant> first, at least.
21:20:59 <dons> "sparks haskell" or something?
21:21:08 <Adamant> threads sparks
21:21:10 * dons thinks stack overflow might be more useful than haskell wiki
21:21:12 <dons> since search works
21:21:20 <Adamant> I thought it wasn't so Haskell-specific
21:21:36 <dons> well, there's the haskell thread
21:21:41 <Adamant> but some weird concept for something more discrete than language-based threads
21:21:43 <ddelony> Is "where" broken in GHC?
21:21:47 <dons> http://stackoverflow.com/questions/tagged/haskell
21:21:59 <dons> ddelony: it's only for attaching to declarations
21:22:10 <ddarius> ddelony: You are not getting an error with "where"
21:22:57 <aavogt> no, it works
21:23:38 <ddelony> I'm thoroughly confused. I typed the function in exactly and I don't know what's wrong.
21:24:00 <aavogt> it's what you do with the function that's the error
21:24:38 <ddelony> aavogt: So it's a PEBKAC?
21:25:29 <aavogt> ddelony: do you have some additional type annotation around    let it = bmiTell 85 1.9
21:25:58 <ddarius> ddelony: Is the code in the first paste copied from your file or copied from LYAH?
21:26:27 <ddelony> ddarius: From my file, after copying it from LYAH.
21:26:54 <ddelony> aavogt: No, I don't,
21:27:59 <aavogt> well paste what you enter into ghci when running the function
21:29:16 <ddarius> ddelony: Copying and pasting the code in the first paste to a file, loading it with GHCi, and then copying and pasting the expression from the second paste works fine for me.
21:30:02 <ddarius> ddelony: The error you are getting suggests that bmiTell is defined with fewer than two arguments.
21:31:19 <ddarius> ddelony: So, the definition of bmiTell that you are using does not match the one in the first paste you made.
21:43:08 <ddelony> I must have fat-fingered something in one of the other functions in the file, because bmiTell works when I put it in its own file.
22:22:08 <lazni> is there anything wrong with assignment like this? Just pollUri = parseURI "http://example.com"
22:35:31 <jeffwheeler> lazni: you probably want the monadic bind, so (Just pollUri) <- parseURI "..."
22:35:35 <jeffwheeler> I think?
22:40:03 <kmc> lazni, the = sign is not really assignment.  it's declaring a name for an existing thing, not storing something
22:40:12 <lazni> this line is toplevel in the file
22:40:15 <kmc> anyway, that is allowed at top-level or in a "let" or "where" bindings
22:40:29 <kmc> however, it will cause a runtime exception if the pattern fails, i.e. if parseURI returns Nothing
22:41:00 <lazni> the argument is hardcoded to that String
22:41:01 <kmc> if you have a string literal in the file then i'd say it's all right -- you shouldn't build with an invalid URI and if you do it will be obvious
22:41:03 <kmc> yeah
22:41:11 <lazni> thanks
22:41:31 <kmc> in a more "dynamic" case this would be discouraged
22:42:00 * lazni put that as an example in http://www.haskell.org/haskellwiki/Cookbook/Network_programming
22:42:01 <kmc> btw i think you would get that exception on first use, not on load
22:42:23 <lazni> I'll add a note about hardcoded patternmatching
22:44:11 <aavogt> quasiquotes for parsing URIs?
22:44:42 <lazni> what's quasiquote?
22:45:29 <aavogt> I think this package does some http://hackage.haskell.org/package/yesod
22:46:12 <aavogt> lazni: ghc extension for running a parser   [$parserIDefined|   xyz |]
22:46:56 <aavogt> which is arbitrary code that is given the string between the brackets and returns some representation of a haskell syntax
22:47:06 <aavogt> it's allowed to bind variables from wherever
22:47:23 <aavogt> if that's what the parserIDefined is written to do
22:48:06 <lazni> in my case, it would be String -> URI?
22:49:04 <aavogt> well it's actually the relevant field in a record has type  String -> Exp
22:49:37 <aavogt> where Exp is a data type that represents haskell syntax
22:49:42 <aavogt> for expressions
22:50:01 <aavogt> but that syntax could represent some data with type URI
22:51:06 <kmc> lazni, http://www.haskell.org/ghc/docs/6.10.4/html/users_guide/template-haskell.html#th-quasiquotation
22:51:08 <kmc> see also the paper linked there
22:51:20 <aavogt> you would more or less have to write a Lift instance for URI and then you would be set
22:51:58 <aavogt> I think this library does some of that: http://hackage.haskell.org/package/yesod
22:52:07 <aavogt> but that's just a rumor
22:55:35 <dancor> is there a library where you can specify options once and they can be set both by command-line options or a config file?
23:08:08 <superoptimizer> Are partial evaluation and partial function application the same thing by different names?
23:08:47 <ulfdoz> no
23:09:12 <c_wraith> partial evaluation is a side effect of laziness.
23:09:19 <c_wraith> partial function application is currying
23:09:26 <conal> superoptimizer: partial eval is partial appl followed by simplification (symbolic execution)
23:09:29 <ulfdoz> partial evaluation reduces the application already, partial application is simply a new expression with fewer parameters (in easy words)
23:09:57 <kmc> in some sense Haskell has no partial application.  every function has only one argument, which clearly cannot be partially applied
23:10:03 <conal> depending on how you code, you can write haskell functions that partially evaluate when partially applied.
23:10:24 <conal> e.g. f x = \ y -> ... z ... where z = ... x ...
23:10:43 <kmc> f x = let { x2 = x*x } in \y -> x2+y
23:10:47 <kmc> f x y = x*x + y
23:11:04 <kmc> the latter will do no computation until both arguments are applied
23:12:02 <kmc> in the latter case (f 2) is in normal form; in the former case it's not, and will reduce if forced
23:12:06 <conal> ghc doesn't pre-compute x*x.  but it could.
23:12:13 <conal> in kmc's latter form
23:12:31 <aavogt> > head []  -- (partial function) application
23:12:32 <lambdabot>   * Exception: Prelude.head: empty list
23:12:36 <kmc> haha aavogt
23:12:49 <kmc> conal, but if i use seq on (f 2) it will reduce x*x then, right?
23:12:57 <kmc> hmm i suppose not
23:13:06 <kmc> because the let bindings themselves are lazy
23:13:13 <superoptimizer> okay, I'm not sure that clears things up. i'm a few days into Haskell, and the reason I ask is that I'm familiar with partial evaluation (to some degree) since I work on compiler backends, but this mention of partial function application in RWH is somewhat new to me (but reminds me in some ways of function objects in C++)
23:13:22 <kmc> f x = case x*x of x2 -> \y -> x2+y
23:13:49 <kmc> superoptimizer, err, function objects in C++ are just a tremendously verbose substitute for first-class functions
23:13:57 <conal> in the later def, x*x will get *re*computed for each y (in the current ghc)
23:14:27 <superoptimizer> kmc: sure, but they can contain state, and that's what reminded me of them wrt partial function application
23:14:53 <conal> and if ghc were a bit smarter, it'd compute x*x eagerly, since * is total and cheaper than making thunks.
23:14:59 <kmc> superoptimizer, by "state" you mean that they "remember" free variables from the environment where they were defined?
23:15:04 <kmc> or do you mean that they can have *mutable* state?
23:15:16 <dancor> what's a good name for an option lib that allows you to describe options once and recieve them in CLI and config file?  optative, polyopt
23:15:40 <jeffwheeler> @type first
23:15:41 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
23:15:56 <kmc> superoptimizer, "partial application" just refers to the fact that we usually think of, say "mod" as a two-argument function, but it's actually a one-argument function that returns a one-argument function, and so we can write things like (mod 3) and bind that value to a name and use it later
23:16:04 <dancor> macropterous
23:16:30 <aavogt> dancor: have you looked at cmdargs?
23:16:37 <jeffwheeler> @pl f g (a, b) = (g a, b)
23:16:37 <lambdabot> f = (`ap` snd) . (. fst) . ((,) .)
23:16:45 <superoptimizer> kmc: I mean the former if you have a constructor that takes things by value, so e.g. you can make an AddConst function object that you construct like AddConst AddTen(10), and then later use AddTen(x) to compute x+10 assuming operator() in AddTen takes the value passed into the constructor and adds it to the argument passed into operator()
23:16:48 <jeffwheeler> Hmm, thought there was an Arrows way to do that.
23:16:53 <kmc> it doesn't generally cause any evaluation (= beta-reduction of lambda terms) to occur, since Haskell is usually implemented with lazy evaluation.  as conal points out, a cleverer implementation could do some speculative evaluation here
23:17:09 <aavogt> jeffwheeler: @pl doesn't know about arrows
23:17:26 <kmc> superoptimizer, indeed, that's the very old idea of "closure over free variables"
23:17:30 <jeffwheeler> aavogt: oh, for some reason I was thinking it showed me something a few days ago; must've been something else
23:17:44 <kmc> but C++ makes you feed in the free variables by hand, and name them at least twice
23:17:54 <kmc> i.e. you have to write the code for that ctor, which should be implicit from its call site
23:17:58 <kmc> they're fixing this in C++1x of course
23:18:17 <superoptimizer> Yes, I know.
23:18:23 <aavogt> :t let f g (a, b) = (g a, b) in first `asTypeOf` f
23:18:24 <kmc> anyway
23:18:24 <lambdabot> forall b c d. (b -> c) -> (b, d) -> (c, d)
23:18:26 <dancor> aavogt: i hadn't seen it, it's more concise than getopt?  it does no config file stuff right?  so maybe i just want to mashup cmdargs and configfile?
23:18:31 <kmc> partial application is not really a language feature
23:18:51 <kmc> it's a thing you can do in any language supporting first-class functions
23:18:58 <kmc> even C++ as you observed (if you're willing to jump through these hoops)
23:19:19 <aavogt> dancor: it has potential: there are lots of cases for records that it should be able to produce args for, but can't
23:19:28 <kmc> what you can say is that Haskell makes it syntactically easier to define and apply curried functions and harder to define and apply non-curried ones
23:19:32 <aavogt> dancor: such as nested records etc.
23:19:40 <dancor> mm
23:19:47 <kmc> and curried functions can be partially applied without extra plumbing
23:19:57 <kmc> (well, as long as you want to apply args in their definition order...)
23:20:06 <kmc> we also have a little sugar for partially-applied infix operators
23:20:07 <aavogt> it (or something similar using template haskell rather than Data) would be really nice
23:21:44 <BMeph> jeffwheeler: Think of it as: first :: forall (~>) b c d. (Arrow (~>)) => (b ~> c) -> (b, d) ~> (c, d)
23:21:45 <dancor> ya.  tho i've found that TH can make compiling unbearable.  i guess you just have to divide things up a lot to reduce recompilations
23:21:56 <superoptimizer> Sure, so my question in relation to partial evaluation is this. From my (compiler backend writer) background, I see partial evaluation as a form of program specialization for the sake of optimization. Partial function application looks (at this first glance) to me like the same - you can construct a new function effectively "baking in" the parameters you've given, e.g. in a C++ compiler if you have a function that takes a functio
23:21:57 <superoptimizer> pointer and you have a callsite where you pass function foo as the parameter, you can specialize the called function into a new one that bakes foo in and can inline it at that point.
23:22:04 <jeffwheeler> BMeph: hmm, alright
23:23:02 <jeffwheeler> > first (+1) (1,2)
23:23:03 <lambdabot>   (2,2)
23:23:06 <aavogt> dancor: what do you mean by unbearable? Inline splices in the same module get typechecked as a group which means you can't go all out with those ones
23:24:09 <dancor> aavogt: i mean that the compilation time can be long
23:24:23 * BMeph thinks superoptimizer has just "discovered" closures! ;)
23:24:24 <dancor> when you are trying to iterate
23:24:33 <kmc> superoptimizer, yeah, partial application can expose some compiler optimizations.  but it's not guaranteed and it's not usually why we do it
23:24:46 <kmc> GHC has a very aggressive inliner
23:24:56 <kmc> so indeed it might come into play quite a lot
23:25:02 <aavogt> you can get slow compile times with fancy typeclasses too
23:25:03 <kmc> you'd have to study the generated Core to know for sure
23:25:32 <aavogt> does dons teach core studies?
23:26:43 <aavogt> anyways, when I've looked I've found it difficult to point out which parts of
23:26:52 * superoptimizer definitely needs to study what gets generated because he hates not knowing exactly what's going on. :)
23:26:53 <aavogt> my code correspond to bits of core
23:27:56 <kmc> superoptimizer, it's a loooong way down from typical Haskell source to the machine code
23:28:18 <kmc> superoptimizer, have you read http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729
23:28:21 <kmc> i think we recommended it a while ago
23:29:20 <superoptimizer> Yes, over the weekend someone pointed me to that. I'm definitely going to get there - after I get through RWH. I spend an inordinate amount of time reading things from the ACM & IEEE sites, and this will just be another avenue of distraction. :)
23:34:00 <orpras> What is better for ANN? HNN or Hfann?
23:35:02 <newsham> > compare "ANN", "HNN"
23:35:03 <lambdabot>   <no location info>: parse error on input `,'
23:35:05 <newsham> > compare "ANN" "HNN"
23:35:06 <lambdabot>   LT
23:37:18 <systemfault> Gotta find a haskell wallpaper :P
23:37:42 <orpras> Has anyone here been able to use hfann?
23:38:31 <superoptimizer> systemfault: Something like this? http://img156.imageshack.us/img156/5589/swahili.png
23:38:32 <systemfault> Wasn't hard :P http://img32.imageshack.us/img32/144/swahilidark.png :D
23:38:38 <systemfault> superoptimizer: Fuuuu!!! :)
23:38:55 <systemfault> superoptimizer: Yeah.. That one was the first link :)
23:39:02 <systemfault> Thanks :)
23:39:06 <systemfault> I love it
23:43:42 <ksf> how would you represent a filesystem tree?
23:44:25 <cads> every file/folder is a node, nodes with children are folders?
23:45:02 <cads> Oh, I guess there are symlinks, those would make it a graph :/
23:45:50 <cads> You can have cycles in a file system, I've built one :)
23:46:31 <cads> ksf, were you asking how to do it in haskell?
23:46:43 <ksf> hardlinks would make it a graph
23:47:00 <ksf> ...symlinks are left to something else but the fs to interpret
23:47:16 <cads> Hmm, I always wondered about the distinction
23:47:58 <ksf> ...the main observation is that you can't have hardlinks that cross file system boundaries
23:48:06 <ksf> and symlinks can be broken.
23:49:13 <c_wraith> can you hardlink to a directory?
23:49:19 <c_wraith> I thought you can only hardlink to files
23:49:20 <cads> ksf, I've got two miniprojects, one that needs a FIFO queue and one that needs a binary tree. Would you know what the simplest library/module would be for either?
23:49:26 <ksf> not without enabling a kernel option
23:49:30 <ksf> ...in linux, that is.
23:49:39 <ksf> or a mount option, or whatever.
23:49:44 <ksf> it's generally discouraged.
23:50:16 <ksf> cads, Data.Sequence. do you need a tree or just a map?
23:50:28 <kmc> yes, you can ruin everything by hardlinking directories
23:51:03 <kmc> you can make infinite directory trees
23:51:36 <kmc> a hardlink is name for a file; a symlink is a distinct "file" whose content is the name of another file
23:52:14 <kmc> every file has zero or more hardlinks; there's nothing special about the first one
23:52:22 <cads> I think I could represent my structure in a map.. it's the branching structure of the collatz function - http://en.wikipedia.org/wiki/File:Collatz-graph-20-iterations.svg
23:52:31 <c_wraith> I really do wish the that xchat would pick different colors for the two of you
23:53:14 <superoptimizer> I prefer this picture: http://xkcd.com/710/
23:53:21 <superoptimizer> :)
23:53:29 <kmc> sigh
23:53:51 <cads> I'm to find the deepest number less than one million in the collatz tree
23:53:54 <kmc> c_wraith, deal with it ;P
23:53:59 <ksf> er 9P2000 (without .u) doesn't seem to have symlinks
23:54:48 <ksf> there's isdir, append-only, exclusive use, auth file, noarchive
23:56:39 <ksf> the structure should support some idea of inode, though it doesn't need to support looking files up by them (just a unique id), and a running version number for each file
23:57:46 <ksf> ...those don't need to be a feature of the data structure, but of the value field.
23:58:26 <ksf> can Data.GMap.ListMap be queried for directories?
23:59:56 <systemfault> cads: Easy
