00:00:07 <dcoutts_> theorbtwo: yes, there is the opportunity to optimise if the package supports a richer interface
00:00:27 <theorbtwo> Right.  Dropping the subject.
00:00:56 <avenge> dcoutts_:  Okay, so that seems like a reasonable design that would clean up the mess a little bit.  But please don't remove ./Setup install untill there is some way to get source code with cabal install...
00:01:10 <dcoutts_> theorbtwo: the approach I was thinking of was to do something more efficient for the standard build system and do the fallback thing for a custom Setup.hs
00:01:29 <avenge> dcoutts_: How do you know a Setup.hs is custom?
00:01:50 <dcoutts_> avenge: you can do that now using cabal copy; cabal register or cabal install --only
00:01:58 <dcoutts_> no need to keep using Setup.hs
00:02:09 <avenge> Ah, okay, that's true.
00:02:11 <dcoutts_> avenge: it's specified in the .cabal file, build-type
00:02:40 <avenge> dcoutts_:  Good.  As long as you aren't actually examining the Setup.hs source code, that seems reasonable...
00:02:54 <dcoutts_> avenge: cabal short-cuts compiling the Setup.hs for build-type: Simple
00:03:35 <dcoutts_> saves a bit of time linking
00:03:37 <dcoutts_> right, I've gotta go
00:03:38 <avenge> So now what about the idea of all options to cabal install (including defaults from ~/.cabal/config) being passed to all subcommands that accept them.
00:03:51 <theorbtwo> dcoutts_: Aha, that's a good idea.
00:04:33 <dcoutts_> avenge: instinctively I don't like it, I see flags as belonging to commands, rather than a global soup
00:05:10 <avenge> But do you really think it's good to have the same option mean different things to different subcommands?
00:05:22 <dcoutts_> avenge: no, I think that should be avoided
00:06:00 * dcoutts_ really has to disappear
00:06:06 <avenge> Well anyway, I won't keep you if you have to go.  But still I hope there is some way to make source the default, even if it has to be dirty.  Talk later.
00:06:19 <dcoutts_> yes
00:07:16 <theorbtwo> avenge: There should certianly be a way of providing options in your config file, but you need to be careful of any sort of plan that provides all options to everything, and expects the later stages to ignore options that don't make sense.
00:07:40 <theorbtwo> Otherwise, specifing an option that doesn't exist will result in Nothing Happens, rather then a useful error message.
00:08:04 <avenge> But all the subcommands are linked into cabal, so it knows which options are valid and which aren't.
00:08:08 <theorbtwo> ...and IMHO anything user-facing should always aim for helpful error messages.  (Even if the user is another programmer -- perhaps especially.)
00:25:52 <sinelaw> does unsafePerformIO mean that the compiler may avoid re-running my function for identical inputs?
00:27:37 <lament> i hope so...
00:27:58 <c_wraith> it may.  It may not.
00:28:31 <c_wraith> It means it the result of the unsafePerformIO call like any other pure value.
00:28:52 <c_wraith> err, it means *it treats* the result...
00:29:09 <sinelaw> oh
00:29:18 <sinelaw> makes sense
00:29:33 <sinelaw> that may be a problem when trying to wrap pointer funcs
00:29:53 <sinelaw> f(T *in, T *out)
00:30:38 <avenge> sinelaw:  Yes.  Use inlinePerformIO if you potentially want to do the IO multiple times.  Or don't use either if you can help it.
00:31:08 <sinelaw> i'm trying to wrap functionally a function that uses pointers but is pure otherwise
00:31:23 <sinelaw> and i don't want to re-allocate the output for every call
00:31:26 <ivanm> sinelaw: see the unsafePerformIO about how you're meant to use it
00:31:35 * ivanm has to add those settings to graphviz still
00:31:48 <avenge> sinelaw:  Make sure your function is not polymorphic, your your program will be unsafe.
00:31:54 <sinelaw> heh yo ivanm :)
00:32:04 <ivanm> hey sinelaw
00:32:04 <sinelaw> avenge, polymorphic?
00:32:55 <avenge> Yes.  Because if you call the same function twice with different result types, but the result is unsafePerformIO, then you will get bad type coercion the second time.
00:34:03 <sinelaw> avenge, sorry are you talking about haskell type polymorphism or perhaps do you think I'm binding to C++?
00:34:10 <c_wraith> haskell
00:34:13 <sinelaw> ah ok
00:34:14 <avenge> Haskell type polymorphism.
00:34:22 <c_wraith> You can use unsafePerformIO to implement unsafeCoerce
00:34:28 <avenge> Making the point that unsafePerformIO is not memory safe.  You can use it wrong and cause memory corruption.
00:35:28 <sinelaw> I see. I'll try to avoid polymorphism with unsafePerformIO
00:35:39 <c_wraith> always the wise choice. :)
00:37:09 <Saizan> it's not that easy to write unsafeCoerce with it
00:37:37 <avenge> I can't remember where I read a good example of why this is.
00:37:51 <c_wraith> I wouldn't have figured it out, but there are instructions for doing so in the docs for unsafePerformIO.
00:37:54 <avenge> But can't you say something like:
00:38:40 <avenge> x :: a
00:38:40 <avenge> x a = unsafePerformIO (return a)
00:38:48 <avenge> I mean x :: a -> a
00:39:00 <c_wraith> you've writtend id, not unsafeCoerce. :)
00:39:05 <Taejo> yeah
00:39:26 <avenge> It's not id.  It's a function where the second time you call it, you get the same result as the first time you called it, but with the wrong type.
00:39:35 <Saizan> ?
00:39:39 <Saizan> why?
00:39:51 <Saizan> ghc doesn't do that kind of memoization even on normal functions
00:39:54 <avenge> Because I think unsafePerformIO only runs the IO once.
00:40:13 <c_wraith> there's no such limitation.
00:40:28 <Saizan> you're constructing different IO actions, even
00:41:09 <Saizan> it doesn't make much sense to run only one of several IO actions :)
00:41:22 <avenge> Okay, I see.  So the real problem is the one in the unsafePerformIO docs:
00:41:22 <sinelaw> ok, I have a function: a -> Ptr b -> IO ()  that I want to wrap into: a -> IO (Ptr b)   and then with unsafePerformIO into: a -> Ptr b   the problem is that concurrency will cause this to fail.
00:41:30 <avenge> test :: IORef [a]
00:41:30 <avenge>      test = unsafePerformIO $ newIORef []
00:41:30 <avenge>      
00:41:30 <avenge>      main = do
00:41:33 <Saizan> in fact, the unsafeCoerce implementation is done with IORef
00:41:33 <avenge>              writeIORef test [42]
00:41:36 <avenge>              bang <- readIORef test
00:41:39 <avenge>              print (bang :: [Char])
00:41:41 <avenge>  
00:42:20 <sinelaw> does my idea even make sense?
00:42:20 <Saizan> sinelaw: you should probably read from Ptr in the same IO action
00:42:32 <avenge> But by your logic, why is newIORef ([] :: [Int]) the same IO action as newIORef ([] :: [Char])?
00:42:58 <sinelaw> Saizan, b is an unknown type (it's a C struct that I don't know anything about)
00:43:05 <sinelaw> so it only makes sense to pass Ptr b around
00:43:16 <Saizan> sinelaw: actually, if the Ptr b is shared with multiple threads it doesn't make much sense to me
00:43:29 <sinelaw> so although the Ptr will be the same for every call, it still looks like a pure function
00:43:38 <sinelaw> Saizan, yes that is the problem.
00:43:47 <Saizan> avenge: because the types don't exist at the term level
00:43:54 <sinelaw> i'd need thread-local Ptr b's
00:44:02 <avenge> Saizan: What does that mean?
00:44:07 <Saizan> avenge: unless you've a typeclass context, in which case they do
00:44:50 <avenge> You mean there is no dictionary when calling newIORef?
00:45:07 <avenge> But how does the implementation of newIORef know what size to allocate?
00:45:11 <Saizan> yeah, but also what i said is not really the reason
00:45:14 <avenge> Just defers to when you call writeIORef?
00:45:27 <avenge> So what is the reason?
00:45:33 <Saizan> avenge: the representations are boxed, IORef just allocates enough for a pointer.
00:45:54 <Saizan> avenge: so, operationally, an IORef Foo is the same as an IORef Bar
00:46:43 <avenge> That makes more sense.  And the type is not attached to the IORef because supposedly the program is typesafe, so wherever you actually use it, you have to be using the write type or the program shouldn't have compiled.  unsafePerformIO being the exception.
00:46:53 <avenge> s/write/right/
00:47:00 <sinelaw> so what can i do?
00:48:12 <avenge> What is happening in your a -> IO (Ptr b) function?
00:48:30 <Saizan> avenge: however if we used explicit type abstraction and application you'd have test = /\ a -> unsafePerformIO (newIORef ([] @ a)), so it's still a bit surprising that GHC shares results between instantiation to different types
00:48:42 <sinelaw> avenge,
00:48:46 <sinelaw> outputPtrArg :: (a -> Ptr b -> IO ()) -> Ptr b -> a -> IO (Ptr b)
00:48:47 <sinelaw> outputPtrArg opIO outVar inVar = do
00:48:47 <sinelaw>   opIO inVar outVar
00:48:47 <sinelaw>   return outVar
00:49:08 <sinelaw> the Ptr b is used as an output argument in opIO
00:49:22 <sinelaw> the data is written into the memory that is pointed to
00:49:36 <sinelaw> so although the pointer itself does not change, the data it points to does
00:49:38 <avenge> Saizan:  But there are definitely parts of the library that seem to assume that unsafePerformIO and unsafeInterleaveIO only execute the IO action once.
00:49:58 <avenge> Saizan: For instance, isn't this required for fixIO?
00:50:13 <Saizan> avenge: yeah, a single IO action once, as i said the types aren't part of it
00:50:49 <Saizan> it's half the point of parametric polymorphism that type abstractions and applications can be erased at compile time
00:51:50 <JoshTriplett> Any way in Template Haskell to write "case x of C { f = f_v } -> ..." where C and f come from local Name variables?
00:52:01 <avenge> sinelaw:  Not totally following.  Is your point that opIO is a pure foreign funciton that just happens to need some scratch space?  Why not wrap that function in a C function that uses its own space.  Or create a temporary buffer?
00:52:13 <Saizan> avenge: however i'm not sure if unsafePerformIO gives that guarantee
00:52:48 <sinelaw> avenge, no, it's not scratch space if i get what you mean. it's the output argument
00:53:17 <sinelaw> the opIO function deals with huge outputs, and you give it a pre-allocated buffer to write them into
00:53:32 <sinelaw> i want to reuse the pre-allocated buffer, but still wrap it as pure somehow
00:54:28 <Saizan> http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.2.0.0/System-IO-Unsafe.html#v%3AunsafePerformIO <- yeah, it can be executed more than once if inlined.
00:55:20 <Saizan> so, if test above for some reason got inlined, you wouldn't have a segfault
00:56:16 <avenge> sinelaw:  I would recommend looking at the source code to Data.ByteString and related modules.  You might get some ideas on how to do things like this.  http://hackage.haskell.org/packages/archive/bytestring/0.9.1.4/doc/html/src/Data-ByteString-Unsafe.html
00:56:37 <sinelaw> ok
00:57:11 <sinelaw> sounds like it would be easier to do the magic stuff on the C side
00:57:19 <avenge> Or maybe look at unfoldrN.  Someplace in those modules you will probably find an example of allocating space for a safe return.
00:57:22 <sinelaw> and then just use unsafePerformIO on a simpler function
00:57:45 <avenge> http://hackage.haskell.org/packages/archive/bytestring/0.9.1.4/doc/html/src/Data-ByteString.html#unfoldrN
00:57:54 <Saizan> well, it's pretty impossible to tell that you're not going to need the old value of the Ptr anymore when you fill it with new data.
00:58:25 <sinelaw> yeah
00:58:33 <sinelaw> i was thinking of managing some sort of pool
00:58:49 <sinelaw> but for that i need to know if anyone is using my pointer
00:59:09 <sinelaw> and with concurrency the only sane way to do any of this is with thread-local storage
00:59:12 <Saizan> it seems you're trying to reimplement the GC
00:59:24 <sinelaw> i was hoping to avoid that :)
00:59:38 <Saizan> yeah, you could just delegate :)
01:00:36 <sinelaw> actually, i assumed that haskell people already solved this problem
01:01:05 <sinelaw> the problem being: how to share output buffers for a function that writes big data into a pre-allocated buffer
01:01:27 <sinelaw> imperatively it's trivial, i can do it in an IO
01:01:44 <sinelaw> but i want a functional interface
01:01:52 <sinelaw> *pure interface
01:03:52 <Saizan> if that memory is allocated on a garbage collected heap, do you really gain anything by "sharing" these buffers?
01:04:14 <sinelaw> Saizan, it isn't allocated there, i need to call a C function to allocate it
01:04:25 <sinelaw> i don't even know its size, it's an opaque struct
01:04:34 <helino> hello, i'm trying to install the package deepseq from hackage using ghc 6.12.1 on mac os x 10.6.2. when running "runhaskell Setup configure" I get "Could not find module `Distribution.Simple'". how do I fix this?
01:05:18 <Saizan> helino: ghc-pkg list Cabal ?
01:08:40 <Vitka> ./msg nickserv identify stupor
01:08:47 <Vitka> whoops
01:08:58 <Vitka> Time for password change it seems.
01:09:01 <sinelaw> :) better change you passwd
01:09:14 <sinelaw> lucky it isn't an embarrassing one
01:09:23 <helino> Saizan: i get Cabal-1.8.0.2
01:09:26 <sinelaw> ./msg nickserv identify #haskell-users-are-assholes
01:09:28 <sinelaw> oooooops
01:09:38 <sinelaw> j/k :P
01:09:48 <Saizan> helino: ghc-pkg check ?
01:10:48 <sinelaw> @hoogle (a -> b -> d) -> (b -> c -> d) -> b -> a -> c -> d
01:10:48 <lambdabot> No results found
01:10:57 <helino> Saizan: i get 7 broken packages :(
01:11:35 <sinelaw> @hoogle (a -> b -> IO ()) -> (b -> c -> IO ()) -> b -> a -> c -> IO ()
01:11:35 <lambdabot> No results found
01:11:58 <Vitka> Speaking of embarassement, is there something like manyTill in Binary.Get? I need to repeatedly run my Get until it consumes bytestring of given size.
01:11:59 <Saizan> helino: doesn't sound good :\ if you paste your ghc-pkg list we might see if there's a way to recover without reinstalling ghc
01:12:30 <helino> Saizan: all packages share the following problem: dependency "containers-0.3.0.0-409fe3b8f0dda25b98e03716d26be411" doesn't exist
01:13:01 <helino> however, I installed containers-0.3.0.0 from hackage prior to trying to intall deepseq
01:13:14 <Saizan> mh, maybe that's the problem.
01:13:36 <Saizan> helino: do you have two distinct containers-0.3.0.0 installed?
01:13:55 <Vitka> ...and put results into a list. Something like sequence?
01:14:23 <helino> Saizan: "ghc-pkg list" lists just one contaiener-0.3.0.0 installed
01:14:47 <Saizan> helino: ah, so you're doing global installs?
01:14:54 <helino> Saizan: yes
01:15:14 <helino> apparently I do, I'm new to haskell and the ghc package system
01:15:18 <sinelaw> Saizan, ok my best shot is this:
01:15:25 <sinelaw> chainPtrOps :: Ptr a -> (Ptr a -> Ptr a -> IO ()) -> (Ptr a -> Ptr a -> IO ()) -> Ptr a -> Ptr a -> IO ()
01:15:42 <Saizan> helino: i think you've to reinstall your GHC, since the second installation of containers-0.3.0.0 overwrote the one shipped with ghc-6.12.1 and broke all the dependent packages since the ABI changed
01:15:44 <sinelaw> so you can do
01:16:07 <sinelaw> op1 `chainPtrOps preallocVar1` op2 `chainPtrOps preallocVar2` op3
01:16:10 <Saizan> Vitka: i think you've to write your own whileM
01:16:23 <sinelaw> syntax aside
01:16:33 <helino> Saizan: ough, I didn't know that ghc 6.12.1 shipped with the containers packaged, I should have checked first...
01:17:02 <Vitka> Hmm.
01:17:11 <Vitka> Sounds bad.
01:18:13 <helino> Saizan: how do I uninstall ghc?
01:18:23 <Vitka> I tried standard when and unless, but they return IO (), which is unhelpful.
01:19:00 <Saizan> Vitka: you can use if .. then .. else .. or a case expression
01:19:15 <paulvisschers> Is there a library for sending emails?
01:19:34 <Saizan> helino: no idea on os x
01:20:19 <Saizan> helino: though probably reinstalling would just overwrite it
01:20:30 <helino> Saizan: ok, thanks for your help!
01:21:21 <Vitka> I tried doing it with comparing bytesRead and input size, but bytesRead has Get type.
01:21:59 <Saizan> Vitka: you can use >>= or do-notation to access the result
01:22:40 <Saizan> ?type \m x t f -> do r <- m; if x == r then t else f
01:22:41 <lambdabot> forall (m :: * -> *) b a. (Monad m, Eq a) => m a -> a -> m b -> m b -> m b
01:22:50 <Vitka> And I suck at monads and don't understand if I need to lift a function, or whatever.
01:24:07 <Saizan> though bytesRead returns the bytes read from the start of the bytestring passed to runGet
01:25:58 * hackagebot Attrac 0.1.2 - Visualisation of Strange Attractors in 3-Dimensions  http://hackage.haskell.org/package/Attrac-0.1.2 (RubenZilibowitz)
01:26:53 <Vitka> Eh.
01:37:13 <Cale> Vitka: You'll get it soon enough. Basically, the idea is that if M is some monad, and x :: M t, then you can write  v <- x  inside a do-block, and v :: t will be the "result" of x. The do-block as a whole will have the same type as its last line, and the monad M will be the same in every line.
01:37:28 <sinelaw> what's the nice way to warp C enums? i need to somehow get the enum values, and i don't want to copy them by hand from the C include files
01:37:38 <sinelaw> (i don't mind copying their names, but not their vlaues)
01:38:27 <Cale> Vitka: So, since bytesRead :: Get Int64, you can use it inside a Get computation do-block,  n <- bytesRead  and then  n :: Int64
01:39:10 <Cale> Well... if they're sequential, you can just define a new datatype and add deriving Enum to it.
01:39:46 <sinelaw> ah
01:40:12 <Cale> and then toEnum and fromEnum will convert back and forth between the numeric and symbolic values
01:40:40 <sinelaw> nope, they aren't sequential.  :(
01:41:08 <sinelaw> in fact their defined using complicated macros :__(
01:41:14 <sinelaw> *they're
01:42:15 <Cale> You might be able to adapt the CPP macros and add {-# LANGUAGE CPP #-}
01:42:47 <Cale> But otherwise probably the best way is to write an instance of Enum by hand.
01:43:11 <sinelaw> never heard of language CPP...let me see :)
01:43:53 <Cale> As far as I know, it just runs the C preprocessor over the code as an initial pass.
01:44:14 <sinelaw> oh. i'm not sure that will be good enough.
01:44:18 <sinelaw> but thanks!
01:44:25 <alex404> How do I include C headers into my code? GHC is telling me that #include is now deprecated.
01:44:31 <Cale> Well, yeah, it probably won't.
01:44:42 <sinelaw> alex404, use hsc
01:44:59 <alex404> sinelaw: You mean hsc2hs?
01:45:02 <sinelaw> alex404, yes
01:45:16 <sinelaw> you're writing a binding?
01:45:26 <alex404> Yah. Very simple for some c that I worte.
01:45:29 <sinelaw> then it's officially binding to C day!
01:45:38 <alex404> Yay! (?)
01:45:45 <Cale> alex404: I'm not sure why you want to do that? You specify the header when you write the foreign import, don't you?
01:46:24 <alex404> Cale: Well, I'm new to this, so I've been working through the example in Real World Haskell which I guess is now out of date...
01:46:45 <Cale> http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffi.html -- this is where I learned to use FFI
01:47:00 <alex404> Cale: Cool. It's up to date?
01:47:20 <Cale> yeah
01:47:23 <Cale> Oh, I see...
01:47:26 <alex404> Cale: Err, I guess it would be.
01:47:50 <Cale> http://book.realworldhaskell.org/read/interfacing-with-c-the-ffi.html -- there's a small problem with the example here
01:48:16 <alex404> Cale: Indeed
01:48:16 <Cale> It says the file name is ch17/Regex-hsc.hs, but I don't think that's appropriate...
01:48:28 <alex404> Cale: That's a weird thing to.
01:48:45 <alex404> Cale: But that's not the problem. I just end up catting this two files together into an .hsc
01:49:17 <alex404> Cale: However, the real problem is that they use #include keywords, which I guess is now out of date or something?
01:49:37 <Cale> When I run hsc2hs over the .hsc file, it doesn't complain
01:49:47 <Cale> What version of GHC are you using?
01:49:52 <alex404> 6.12.1
01:50:00 <Cale> ah, okay
01:50:06 <alex404> indeed
01:50:07 <Cale> I haven't switched yet.
01:50:41 <alex404> What I want to do is really simple, but I'm having trouble finding reliable information
01:51:25 <Cale> Does it say what #include has been replaced with?
01:51:53 <alex404> No, it just says it's deprecated and now does nothing
01:53:02 <alex404> There's information here though http://haskell.org/ghc/docs/latest/html/users_guide/release-6-12-1.html
01:54:08 <alex404> "The -#include  flag and INCLUDE  pragma are now deprecated and ignored. Since version 6.10.1, GHC has generated its own C prototypes for foreign calls, rather than relying on prototypes from C header files. "
01:54:17 <alex404> Not exactly sure what the means...
01:55:18 <sinelaw> (if anyone replied, i was disconnected)
01:55:57 <alex404> sinelaw: I'm still struggling with hsc2hs, due to being at GHC 6.12.1, apparently...
01:56:15 <sinelaw> ah, i'm using 6.10 still
01:56:36 <alex404> The changelog for GHC says:
01:56:39 <alex404> "The -#include  flag and INCLUDE  pragma are now deprecated and ignored. Since version 6.10.1, GHC has generated its own C prototypes for foreign calls, rather than relying on prototypes from C header files. "
01:56:44 <alex404> Does that mean much to you?
01:57:34 <Cale> Oh hmm, then maybe it doesn't matter?
01:58:03 <Cale> Or is that preventing the #const's from working?
01:58:42 <alex404> Cale: Well, the original problem was only that I couldn't figure out how to reference my local header file
01:58:49 <alex404> Cale: For my c functions
01:59:22 <profmakx> 5/buffer 17
01:59:25 <profmakx> baeh
02:05:10 <sinelaw> @hoogle [(a,b)] -> ((a -> Maybe b), (b->Maybe a))
02:05:11 <lambdabot> No results found
02:05:16 <sinelaw> is there anything of that sort?
02:05:28 <sinelaw> convertor based on list of pairs
02:05:41 <sinelaw> two-way
02:06:08 <pastorn> sinelaw: you need to write that yourself :)
02:07:12 <pastorn> sinelaw: lookup
02:07:39 <pastorn> and lookup with 'map (\(x,y) -> (y,x))'
02:08:03 <dobblego> @type lookup
02:08:05 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
02:09:43 <sinelaw> nice, thanks
02:10:47 <sinelaw> @pl \(x,y) -> (y,x)
02:10:48 <lambdabot> uncurry (flip (,))
02:11:03 <sinelaw> nah
02:11:24 <pastorn> @hoogle (a,b) -> (b,a)
02:11:24 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
02:11:25 <lambdabot> Data.Graph.Inductive.Query.Monad mapSnd :: (a -> b) -> (c, a) -> (c, b)
02:11:25 <lambdabot> Data.Graph.Inductive.Query.Monad mapFst :: (a -> b) -> (a, c) -> (b, c)
02:11:31 <pastorn> huhu
02:11:55 <pastorn> there might be something in Control.Arrow
02:12:09 <sinelaw> yeah looks like it should be there
02:12:46 <sinelaw> actually hoogle has that
02:12:49 <sinelaw> i think
02:13:00 <sinelaw> so i guess there isn't
02:13:11 <sinelaw> never mind, it's a one-liner
02:13:56 <pastorn> but why do you want a pair of functions?
02:14:15 <sinelaw> i just want it to generate the two functions
02:14:27 <pastorn> wouldn't it be nicer with :: [(a,b)] -> a -> b -> (Maybe a, Maybe b) ?
02:14:43 <sinelaw> no, because i'll be using each function separately
02:14:48 <pastorn> ok
02:15:17 <sinelaw> i guess i can just use lookup for one, and the map with lookup for the other
02:15:26 <sinelaw> instead of pairing and separating
02:17:40 <sinelaw> perhaps there is a symmetric dictionary
02:17:48 <sinelaw> i mean map
02:17:55 <pastorn> Data.Map ?
02:18:51 <sinelaw> data.map is not symmetric
02:19:11 <merehap> for template haskell, why is there no function with type "Q a -> a"? it seems pointless keeping 'a' jailed...
02:19:52 <hsaul1> in top most program i get error "parse error on input 'name'" here http://learnhaskell.blogspot.com/2007/09/lesson-2-input-and-output-variable.html i used ghc --make -O2 prog2.hs -o prog2 in windows console
02:22:20 <BONUS> m
02:25:27 <sinelaw> @src fromJust
02:25:27 <lambdabot> fromJust Nothing  = undefined
02:25:27 <lambdabot> fromJust (Just x) = x
02:26:26 <jejansse> hsaul1, try putting a space before name and the line below it, so the lines after do are aligned
02:28:55 <hsaul1> now i get this error Not in scope: `putStrln'
02:29:10 <dobblego> putStrLn (capital L)
02:30:53 <hsaul1> ok thank's guys or girls :)
02:31:23 <jejansse> np
02:45:45 <cheater> hey guys
02:45:53 <cheater> how do i get ghci on suse?
02:46:07 <Alpounet> it comes with ghc -- so, the same way you get ghc.
02:47:06 <cheater> ah alright
02:47:06 <cheater> ok
02:58:27 <cheater> got it
02:58:49 <cheater> is it possible to write this function in point free style? square x = x * x
02:59:37 <ivanm> yes
02:59:41 <ivanm> @pl \ x -> x * x
02:59:41 <lambdabot> join (*)
02:59:47 <ivanm> @type join
02:59:48 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
02:59:49 <ivanm> @src join
02:59:49 <lambdabot> join x =  x >>= id
02:59:59 <ivanm> that uses the function monad I think...
03:00:22 <ivanm> @type (*) >>= id
03:00:23 <lambdabot> forall a. (Num a) => a -> a
03:00:39 <SubStack> > join (*) 2
03:00:40 <lambdabot>   4
03:00:56 <cheater> i don't see how \ x is point-free
03:00:56 <SubStack> which instance does that need...
03:01:26 <ivanm> cheater: it isn't ...
03:01:29 <sinelaw> cheater, join (*) is what you were supposed to look at
03:01:33 <ivanm> SubStack: (a->) I believe
03:01:41 <cheater> ah alright
03:01:42 <cheater> :))
03:01:42 <ivanm> cheater: @pl is what creates the point-free forms
03:01:45 <SubStack> which import though?
03:01:55 <ivanm> cheater: maybe you should lay off the cake; you're getting a double chin!
03:01:56 <ivanm> :p
03:01:59 <cheater> ivanm: so i can feed it anything and it'll give me point free?
03:02:01 <ivanm> SubStack: the prelude...
03:02:10 <ivanm> cheater: yes, but they're usually ugly
03:02:12 <cheater> ivanm: hmm, true with the cake :-\
03:02:16 <cheater> ok
03:02:17 <SubStack> No instance for (Monad ((->) a)) -- >_<
03:02:17 <ivanm> @pl \ x -> x + x + x
03:02:18 <lambdabot> (+) =<< join (+)
03:02:24 <ivanm> SubStack: :o
03:02:24 <sinelaw> heh
03:02:29 <ivanm> @instances Monad
03:02:29 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
03:02:46 <cheater> so what does join() do?
03:02:49 <sinelaw> @pl (\f x -> f x x)
03:02:49 <lambdabot> join
03:02:54 <SubStack> aha, it was hiding in Control.Arrow
03:02:56 <SubStack> pesky thing
03:03:00 <ivanm> SubStack: oh, you need Control.Monad for join
03:03:01 <sinelaw> cheater, that's what it does
03:03:03 <ivanm> that's all you need
03:03:06 <sinelaw> in this case
03:03:09 <ivanm> you don't need Control.Arrow ...
03:03:15 <ivanm> @src join
03:03:15 <lambdabot> join x =  x >>= id
03:03:17 <ivanm> cheater: ^^
03:03:17 <SubStack> ivanm: negatory, Control.Arrow and Control.Monad in my ghc-6.12
03:03:19 <ivanm> @type join
03:03:20 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
03:03:24 <ivanm> SubStack: I'm using 6.12 ;-)
03:03:35 <cheater> i have no idea how to understand that src :-\
03:03:35 <sinelaw> for functions, join = (\f x -> f x x)
03:03:57 <ivanm> start ghci, :t join (*) says it doesn't know what join is, I do :m + Control.Monad, and now it works
03:04:06 <SubStack> different here
03:04:14 <ivanm> cheater: for a generic monad, it strips away a double monad into a single one
03:04:25 <ivanm> e.g. Maybe (Maybe a) ==> Maybe a
03:04:36 <ivanm> SubStack: you sure? try with just Control.Monad
03:04:39 <SubStack> yes
03:04:41 <cheater> i don't know monads yet
03:04:54 <ivanm> cheater: then why are you worrying about pointfree? ;-)
03:05:00 <ivanm> > join $ Just (Just 2)
03:05:01 <lambdabot>   Just 2
03:05:03 <ivanm> > join $ Just Nothin
03:05:04 <lambdabot>   Not in scope: data constructor `Nothin'
03:05:05 <ivanm> > join $ Just Nothing
03:05:06 <lambdabot>   Nothing
03:05:08 <cheater> ivanm: why not?
03:05:14 <SubStack> cheater: Monad is just a class like any other
03:05:14 <tensorpudding> pointfree isn't that hard to understand
03:05:16 <sinelaw> cheater, for now: join f x = f x x
03:05:17 <ivanm> cheater: j/k
03:05:21 <cheater> :)
03:05:25 <tensorpudding> so long as you thoroughly understand types
03:05:30 <ivanm> cheater: for lists, join = concat
03:05:31 <Cale> cheater: For the (->) e monad, you have  join :: (e -> e -> a) -> (e -> a)
03:05:49 <Cale> cheater: and there's not so many sensible things that could be :)
03:05:51 <ivanm> SubStack: I'm pretty sure you don't need Control.Monad
03:06:01 <Cale> So join f x = f x x
03:06:03 <ivanm> *Arrow
03:06:07 <cheater> ok so basically, if i do f = join(*) then it's a curried form of join x y?
03:06:14 <SubStack> ivanm: that would be nice, were that the case
03:06:14 <ivanm> Cale: can you verify if you need Control.Arrow for the (e->) Monad?
03:06:22 <Cale> join (*) means  (\x -> (*) x x) which is (\x -> x * x)
03:06:24 <SubStack> ivanm: it seems our distributions differ inexplicably
03:06:25 * ivanm suspects a dodgy system for SubStack 
03:06:39 <ivanm> SubStack: nothing to do with linux distributions...
03:06:40 <Cale> ivanm: You don't. You need Control.Monad.Instances or Control.Monad.Reader
03:06:54 <ivanm> well, just importing Control.Monad does it for me
03:06:58 <Cale> hmm
03:06:58 <SubStack> ivanm: ghc distributions
03:07:01 <Cale> Interesting.
03:07:07 <ivanm> SubStack: wtf is a "ghc distribution"
03:07:08 <Cale> Maybe they decided to put the instance in there too.
03:07:12 <SubStack> or some kind of packaging thing
03:07:18 <ivanm> hmmm... no other packages have Control.Monad, do they?
03:07:34 <cheater> no?
03:07:41 <cheater> guess i'm wrong then :<
03:07:45 <Cale> ivanm: Which GHC?
03:07:52 <Alpounet> just "Control.Monad", no, no other package
03:07:57 <ivanm> Cale: 6.12.1
03:08:00 <Cale> cheater: a bit off
03:08:07 <tensorpudding> ghc 6.10.4, you need to import Control.Monad to get join
03:08:09 <ivanm> cheater: not curried
03:08:18 <Cale> cheater: join (*) 5 = (*) 5 5 = 5 * 5
03:08:20 <ivanm> well, curried/uncurried is more for tuples
03:08:23 <ivanm> it's just pointfree
03:08:27 <SubStack> 6.12.1 here too
03:08:28 <Cale> Well, (*) is already curried
03:08:34 <ivanm> yeah
03:08:43 <tensorpudding> and even then, no instance for Monad ((->) a)
03:08:43 <Cale> Maybe that's what was confusing in this case
03:08:46 <ivanm> tensorpudding: with 6.12.1 as well
03:08:59 <tensorpudding> you need to import Control.Monad.Instances to get that
03:09:00 <ivanm> well, I get it with just 6.12 ...
03:09:10 <Cale> Well, that's nice to know
03:09:17 <Cale> At some point I should upgrade
03:09:25 <Cale> seems like enough people are managing with it now
03:10:25 <cheater> no, what i meant was that join takes two parameters
03:10:32 <sinelaw> @hoogle Ptr a -> Ptr b
03:10:32 <lambdabot> Foreign.Ptr castPtr :: Ptr a -> Ptr b
03:10:32 <lambdabot> Foreign.Ptr plusPtr :: Ptr a -> Int -> Ptr b
03:10:33 <lambdabot> Foreign.Ptr alignPtr :: Ptr a -> Int -> Ptr a
03:10:37 <cheater> and join(*) fixes the first parameter, while leaving the other one open, yes?
03:10:45 <sinelaw> cheater, third time
03:10:47 <tensorpudding> join takes one parameter
03:10:49 <sinelaw> join f x = f x x
03:10:53 <Cale> cheater: yes
03:10:56 <sinelaw> cheater, ^^
03:11:18 <sinelaw> Cale, no...?
03:11:22 <Cale> cheater: Well, all functions really take exactly one parameter, but yes, in this case, join takes two, and we're applying it to one.
03:11:40 <SubStack> > join (*) 5
03:11:40 <ivanm> well, ghc-pkg dump says only base has Control.Monad
03:11:41 <lambdabot>   25
03:11:44 <sinelaw> it doesn't "fix" the first parameter, it makes it equal to the second one
03:11:47 <SubStack> > let f = join (*) in f 5
03:11:48 <lambdabot>   25
03:11:52 <cheater> ok, gotcha!
03:11:53 <cheater> makes sense.
03:11:54 <ivanm> is it possibly a base-3 vs base-4 thing? :/
03:12:02 <Cale> join (*) fixes the first parameter to join to be (*)
03:12:11 <Cale> I think that's what cheater meant
03:12:13 <cheater> what cale said
03:12:13 <sinelaw> ah that's what you meant
03:12:16 <cheater> yes
03:12:18 <sinelaw> ok
03:12:31 * sinelaw crawls back into his hole
03:12:46 <sinelaw> yuck, roaches
03:12:48 <SubStack> oh right I should sleep tonight
03:12:54 <SubStack> since I didn't last night
03:12:57 <sinelaw> heh
03:13:05 <ivanm> sinelaw: OK, so multi-augmenting has been rolled back :(
03:13:17 <sinelaw> :(
03:13:26 * ivanm is properly defining the Html-like values atm
03:13:27 <sinelaw> ivanm, is it recorded in some vcs?
03:13:28 <tensorpudding> join in general only takes one argument...
03:13:33 <ivanm> and boy is it boring
03:13:40 <ivanm> sinelaw: yeah, I did a darcs rollback patch
03:13:55 <sinelaw> ok, so if we ever want it back, we can
03:13:55 <ivanm> so if in the future I think of some cool way of doing it, I can rollback the rollback ... >_>
03:14:04 <sinelaw> rickrollback
03:14:07 <ivanm> heh
03:14:15 <ivanm> tensorpudding: in general? it only takes one argument!
03:14:22 <ivanm> in this case, it just happens to return a function
03:14:54 <SubStack> haskell is like every half-baked idea I've ever had done correctly
03:15:14 <tensorpudding> cale was implying that join took two arguments
03:15:16 <cheater> alright guys, thanks
03:15:35 <Cale> tensorpudding: It does in the instance for functions
03:15:38 <SubStack> arity is a convenient delusion
03:15:48 <tensorpudding> you can think of it like that
03:15:51 <Cale> actually, it takes arbitrarily many arguments because of that instance :)
03:16:19 <tensorpudding> of course, you can always think of every function taking one argument
03:16:22 <Taejo> :t join (*) (+) id
03:16:23 <lambdabot> forall a. (Num ((a -> a) -> (a -> a) -> a -> a), Num (a -> a)) => (a -> a) -> a -> a
03:16:25 * ivanm begs to differ
03:16:26 <tensorpudding> and just returning a function
03:16:28 <sinelaw> ivanm, i'm binding (small parts of) OpenCV
03:16:39 <Cale> > join (const const) const const const const 0 1
03:16:40 <lambdabot>   0
03:16:46 <ivanm> sinelaw: ooohhhh....
03:16:47 <ray> arity is useful when it's useful!
03:16:50 <ray> profound ideas
03:17:01 <ivanm> sinelaw: the hmatrix guy is doing some computer vision stuff IIRC (which is why he wrote hmatrix)
03:17:24 <Cale> Same goes for any function with a polymorphic result. They can be sneaky :)
03:17:42 <sinelaw> ivanm, yeah i saw that
03:17:58 <sinelaw> it was hell to compile
03:18:03 <ivanm> Cale: the fact that it returns a function doesn't IMHO mean that join takes mroe than one argument
03:18:07 <ivanm> sinelaw: what, hmatrix?
03:18:07 <sinelaw> but its cool
03:18:11 * ivanm didn't have any problems with it
03:18:16 <sinelaw> ivanm, no the vision library he wrote
03:18:19 <ivanm> ahhh
03:18:23 <ivanm> never looked at it ;-)
03:18:23 <Cale> > foldr (\x f y -> f (x:y)) id [1,2,3,4] []
03:18:24 <lambdabot>   [4,3,2,1]
03:18:25 <sinelaw> it's cool though
03:18:37 <sinelaw> but it requires IPL which is non-free
03:18:39 <Cale> Sometimes foldr takes 4 arguments ;)
03:18:45 <sinelaw> IPP i meant
03:18:56 <ivanm> @slap Cale
03:18:56 <lambdabot> stop telling me what to do
03:19:37 <sinelaw> haha
03:19:46 <sinelaw> @quote psycho
03:19:46 <lambdabot> No quotes match. Wrong!  You cheating scum!
03:19:49 <sinelaw> @quote psychobot
03:19:49 <lambdabot> psychobot says: simpler let's eat, grandma vs let's eat grandma vs let's eat grandma vs let's eat newbies Eek! Peaker, learn anything the bot sees, i.e. commands etc, or ju
03:20:06 <SubStack> speaking of hmatrix, I should fix my matrix transform hmatrix extension
03:20:16 <SubStack> and release it properly, how about
03:20:28 <sinelaw> btw, i liked the idea of the statically typed hmatrix thingy
03:20:38 <sinelaw> has anyone used it? it looks limited
03:20:59 <ivanm> I haven't used hmatrix for over a year now
03:20:59 <cheater> i've got a problem using join though
03:21:09 <ivanm> (I needed it for a computational physics class)
03:21:14 <ivanm> cheater: what?
03:21:25 <SubStack> sinelaw: dimensions encoded in the types?
03:21:31 <sinelaw> yes
03:21:37 <SubStack> that would be handy
03:21:41 <sinelaw> hmatrix-static
03:21:48 <SubStack> :o
03:21:50 <Cale> cheater: Make sure that you've imported Control.Monad.Instances if you want to use the instance of join for functions
03:21:54 <sinelaw> http://hackage.haskell.org/package/hmatrix-static
03:21:59 <cheater> http://pastebin.com/nk4vL4k1
03:22:07 <cheater> ok
03:22:39 <ivanm> wtf? why does it need parsec? :s
03:22:44 <Cale> cheater: Apparently in 6.12 they've put the instance in Control.Monad, but in earlier GHCs, it was off in that module for some reason.
03:22:49 <ivanm> and haskell-src-meta?
03:22:56 <Cale> cheater: If you ask me, it ought to be in the Prelude.
03:23:00 <ivanm> Cale: I'm betting it just re-exports Instances
03:23:15 <sinelaw> because it does template trickery
03:23:22 <sinelaw> lets and lets
03:23:28 <sinelaw> s/lets/lots/g
03:23:36 * benmachine has 6.12 but sees no ((->) t) in Control.Monad
03:23:47 * sinelaw figures haskell is into his veins if he says "lets and lets"
03:23:48 * SubStack too
03:24:03 * sinelaw overrode SubStack's context
03:24:11 <Cale> Okay, I don't actually have 6.12
03:24:14 * SubStack overflows
03:24:30 <ivanm> sinelaw: OK, for haskell-src-meta... but _parsec_?
03:24:30 <Cale> So I was trusting what ivanm was saying ;)
03:24:32 <ivanm> wtf is it parsing?
03:24:37 <sinelaw> ivanm, dunno
03:24:53 <ivanm> Cale: fine, maybe my GHC is special
03:25:18 <ivanm> oh, wait, I lie
03:25:23 <cheater> how do i nest join's ?
03:25:35 <ivanm> for some reason it can find the type, but not actually do it
03:25:53 <ivanm> join (*) 2 :: (Num a, Monad ((->) a)) => a <-- what I actually get
03:26:00 * ivanm apologises to SubStack 
03:26:02 <Cale> yeah, that means the instance is missing
03:26:19 <ivanm> I didn't think of that, just saw "hey, it typechecks!"
03:26:21 <Cale> The constraint goes away once there's an instance available, because it's satisfied then.
03:26:21 <Saizan> Cale: i don't know, (->)'s monad instance seems more dangerous than useful to me
03:26:33 <ivanm> still, Control.Arrow being required is just silly
03:26:34 <Cale> Really?
03:26:38 * SubStack wasn't necessarily crazy after all!
03:26:41 <Cale> How is it the least bit dangerous?
03:26:47 <ivanm> Saizan: too easy to trip up over it if you don't expect it?
03:26:52 <Cale> I suppose it makes a few more things typecheck.
03:26:54 <ivanm> and have random functions floating around?
03:27:02 <Saizan> making non-sensical code typecheck
03:27:16 <Cale> But if your whole program still typechecks when you accidentally used the (->) e monad... that's surprising.
03:27:19 <tensorpudding> it could give you confusing errors if you didn't intend to use it
03:27:28 <Cale> It can already do that.
03:27:35 <Cale> (even without an instance)
03:27:52 <ivanm> sinelaw: I'm guessing it uses Parsec to interact with haskell-src-meta
03:28:18 <Cale> (or do you have a specific example where it makes the error more confusing?)
03:28:31 <Saizan> Cale: it's surprising but it happened to me :)
03:29:07 <cheater> i tried doing something like a = join join(*) but it somehow doesn't want to work :o
03:29:12 <Saizan> i can't remember the details though
03:29:35 <tensorpudding> > join . join (*)
03:29:36 <lambdabot>   No instance for (GHC.Num.Num (m (m a)))
03:29:36 <lambdabot>    arising from a use of `GHC.Num.*...
03:29:51 <Saizan> ?type join (join (*))
03:29:52 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a)
03:29:52 <lambdabot>     Probable cause: `*' is applied to too few arguments
03:29:52 <lambdabot>     In the first argument of `join', namely `(*)'
03:30:10 <tensorpudding> right, you're trying to remove too many m's
03:30:29 <tensorpudding> > join . join (\x y z -> x * y * z)
03:30:30 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a1
03:30:46 <tensorpudding> @type join $ join (\x y z -> x * y * z)
03:30:47 <lambdabot> forall a. (Num a) => a -> a
03:31:18 <tensorpudding> @type join $ join (\x y z -> x * y * z) 6
03:31:19 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a1
03:31:19 <lambdabot>     Probable cause: `*' is applied to too many arguments
03:31:19 <lambdabot>     In the expression: x * y * z
03:31:24 <tensorpudding> meh
03:31:32 <tensorpudding> @type (join $ join (\x y z -> x * y * z)) 6
03:31:33 <lambdabot> forall a. (Num a) => a
03:31:37 <tensorpudding> > (join $ join (\x y z -> x * y * z)) 6
03:31:38 <lambdabot>   216
03:33:10 <cheater> ok
03:33:25 <cheater> so basically it didn't work because * only takes two parameters?
03:33:39 <Alpounet> yeah
03:33:42 <Alpounet> sort of
03:33:48 <Alpounet> because you're in the (->) e monad
03:33:55 * sinelaw whistles the cabal blues
03:34:13 <sinelaw> i can't see why my executable fails to build, but my library doesn't
03:34:22 <Saizan> ?type (*) ?a ?b ?c ?d
03:34:22 <Alpounet> sinelaw, paste some log
03:34:23 <lambdabot> forall t t1 t2. (?a::t -> t1 -> t2, ?b::t -> t1 -> t2, ?c::t, ?d::t1, Num (t -> t1 -> t2)) => t2
03:34:38 * Alpounet has been fighting cabal a lot these days
03:34:50 <Saizan> ?type (*) ?a ?b ?c
03:34:51 <lambdabot> forall t t1. (?a::t -> t1, ?b::t -> t1, ?c::t, Num (t -> t1)) => t1
03:35:19 <Saizan> cheater: you can't make (*) take 3 parameters of the same type
03:35:37 <Saizan> that would mean t = t -> t1
03:36:44 <sinelaw> Alpounet, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23221#a23221
03:36:45 <sinelaw> and http://github.com/sinelaw/HOpenCV
03:36:47 <sinelaw> for the code
03:36:49 <sinelaw> and cabal file
03:37:37 <sinelaw> the excutable is using the file Test.hs (http://github.com/sinelaw/HOpenCV/blob/master/src/Test.hs)
03:38:09 <sinelaw> and for some reason the imports fail, it can't find AI.CV.OpenCV.CxCore
03:38:56 <Saizan> sinelaw: you need to list that module in an other-modules: section
03:39:03 <sinelaw> hmmm seems that the .hsc file is the problem
03:39:06 <Saizan> s/section/field/
03:39:08 <Saizan> yeah
03:39:14 <sinelaw> ok i'll try
03:39:18 <Saizan> if you don't it doesn't get preprocessed
03:39:48 <sinelaw> cool! Thanks Saizan
03:40:03 <Alpounet> works ?
03:40:27 <alex404> Is gtk2hs the most well developed GUI bindings, atm?
03:40:28 <sinelaw> yip! i can see myself on the screen!
03:40:56 <Saizan> with Cabal-1.8+ you could make the executable depend on the library
03:41:25 <sinelaw> that would be nice
03:41:48 <Alpounet> install Cabal-1.8 then
03:42:00 <Alpounet> sinelaw, once your change will be pushed
03:42:02 <Alpounet> I'll try that :)
03:42:12 <Saizan> it seems it's broken with ghc-6.12 atm tough
03:42:30 <Saizan> it = that feature
03:42:57 <sinelaw> Alpounet, your wish has been granted
03:43:12 <Alpounet> oh, so nice
03:43:17 <sinelaw> i'd like to know how your cpu consumption is doing
03:43:38 <sinelaw> because it's terrible here (problem is in opencv's cvQueryFrame function, not haskell)
03:44:24 <Alpounet> sinelaw, can't you make it somehow non-blocking ?
03:45:11 <Alpounet> (the haskell -> C call to cvQueryFrame)
03:45:19 <sinelaw> Alpounet, oh wait the part that shows the image is slow too, i forgot to remove that.
03:45:29 <Alpounet> a sort of asynchronous query
03:45:32 <sinelaw> Alpounet, maybe, but i don't think it's what i want
03:45:50 <Alpounet> sinelaw, ok. Anyway, I'm installing the missing libraries righ now.
03:45:58 <Alpounet> But for sure I'll test and check stuffs
03:46:04 <sinelaw> thanks
03:46:06 <Alpounet> I have many nice ideas of applications of that library
03:46:15 <sinelaw> me too. such as?
03:46:15 <Alpounet> mouhaha
03:46:18 <sinelaw> heh
03:46:44 <sinelaw> Alpounet, problem is how to wrap the image transformers a nicely pure way
03:46:44 <Alpounet> it relates to drawing on one's face, for example :-p
03:46:58 <Alpounet> yeah
03:47:04 <sinelaw> imperatively it's a no-brainer
03:47:11 <Alpounet> and anyway
03:47:13 <Alpounet> this is Haskell
03:47:28 <Alpounet> escaping the imperative way of doing stuffs is always a good thing (almost)
03:48:21 <sinelaw> yeah but in this case not straightforward
03:48:33 <sinelaw> i'm starting by doing the raw wrapping
03:48:39 <sinelaw> for a very small subset of opencv
03:49:01 <Alpounet> sinelaw, where can I get highgui ? I can't find it, in the arch repos, not even in AUR
03:49:16 <sinelaw> Alpounet, what distribution are you using?
03:49:22 <Alpounet> or, it seems it comes with opencv.
03:49:22 <sinelaw> assuming your using linux
03:49:31 <sinelaw> it's part of opencv in general
03:49:33 <Alpounet> configure doesn't complain anymore
03:49:41 <Alpounet> I guess it has been intsalled
03:50:02 <sinelaw> ok
03:50:42 <Alpounet> sinelaw, hmm let's take it to PM, otherwise we'll flood the channel
03:51:48 * hackagebot funcmp 1.3 - Functional MetaPost  http://hackage.haskell.org/package/funcmp-1.3 (PeterSimons)
04:08:57 <freiksenet> is it somehow possible to compare infinite lists? like [1..] and [1..]?
04:09:16 <Zao> freiksenet: You can compare them, but it'll take a very long while.
04:09:42 <freiksenet> Zao: is it possible to compare then without forcing them?
04:09:46 <ts33kr> It'l take an infinity, to be precise...
04:09:49 <Zao> Not as far as I know.
04:09:53 <ts33kr> *ll
04:10:03 <Zao> You could attach some kind of metadata maybe, describing the list.
04:10:10 <TestUser> http://www.facebook.com/photo.php?pid=3629610&id=266453492661
04:10:10 <ts33kr> Zao, You could pull the fixed amount of elements and compare them.
04:10:15 <Cale> freiksenet: It's impossible for a program even to tell that an infinite list is indeed infinitely long
04:10:20 <Zao> ts33kr: Which would only give you an estimate.
04:10:29 <ts33kr> Of course.
04:10:33 <Cale> freiksenet: Because determining that is equivalent to the halting problem
04:10:43 <freiksenet> okay
04:10:48 <ts33kr> But that's better then comparing an infinite list with an infinite time...
04:10:51 <Jafet> It's semidecidable
04:10:55 <ts33kr> *than
04:11:06 <Jafet> You cannot tell if they're equal, but you can eventually tell if they're not
04:11:12 <Cale> right
04:11:17 <Zao> > let x = ("[1..]", [1..]) in (fst x == fst x)
04:11:18 <lambdabot>   True
04:11:24 <Cale> heh
04:11:48 <Cale> > [1..] == [1..10000]
04:11:49 <lambdabot>   False
04:11:53 <Cale> > [1..] == [1..1000000]
04:11:54 <lambdabot>   False
04:12:19 <freiksenet> I see.
04:12:45 <Cale> (==) works on nonempty lists just by comparing first elements and then comparing the tails
04:12:51 <Cale> (no magic :)
04:13:16 <freiksenet> okay. thanks a lot :)
04:41:44 <zygoloid> data InfiniteList a = Cons a (InfiniteList a); isInfinitelyLong :: InfiniteList a -> Bool; isInfinitelyLong _ = True
04:42:00 <zygoloid> yay, that's the halting problem solved ;-)
04:42:05 * dobblego claps
04:42:11 * zygoloid bows
04:42:44 * zygoloid hopes no-one notices that Cons undefined undefined isn't actually infinitely long :)
04:42:52 <Jafet> > let a = a in a
04:42:56 <lambdabot>   mueval-core: Time limit exceeded
04:43:31 <Jafet> "undefined? What's that?"
05:12:33 <cheater> who's ~nef ?
05:13:04 <cheater> (from the topic)
05:19:24 * hackagebot iteratee-parsec 0.0.2 - Package allowing parsec parser initeratee  http://hackage.haskell.org/package/iteratee-parsec-0.0.2 (MaciejPiechotka)
05:22:04 <quicksilver> cheater: no idea :) someone who runs logging bots, presumably.
05:26:27 * quicksilver doesn't really believe that parsec announcment makes sense
05:26:37 <quicksilver> has anybody looked at what parsec 3.1 realy does?
05:49:06 <ablmf> how to get the last 4 item of a list efficiently?
05:50:06 <arw> i would guess take 4 . reverse
05:50:10 <arw> but really no idea.
05:51:18 <arw> (the guess depends on the compiler beeing intelligent enough to recognize, that its not really necessary to reverse the whole list)
05:51:28 <BONUS> you can do drop (length xs - 4) xs
05:51:52 <eevar2> ablmf: maintain a reversed version of the list and take the first 4 elements? ;)
05:52:53 <tromp_> > drop 3 "yo"
05:52:54 <lambdabot>   ""
05:53:00 <tromp_> > drop (-1) "yo"
05:53:01 <lambdabot>   "yo"
05:54:00 <tromp_> in which order do you want the last 4, arw?
05:54:40 <arw> i don't, ablmf did :)
05:54:51 <tromp_> > last 3 . reverse . ['a'..'z']
05:54:52 <lambdabot>   Couldn't match expected type `[a]'
05:54:52 <lambdabot>         against inferred type `GHC.Types...
05:55:00 <tromp_> > last 3 . reverse $ ['a'..'z']
05:55:01 <lambdabot>   No instance for (GHC.Num.Num [[GHC.Types.Char] -> b])
05:55:01 <lambdabot>    arising from the l...
05:55:20 <arw> :t last
05:55:21 <lambdabot> forall a. [a] -> a
05:55:32 <arw> just takes the last element, not the last n
05:55:33 <tromp_> > take 3 . reverse $ ['a'..'z']
05:55:35 <lambdabot>   "zyx"
05:55:52 <BONUS> reverse is O(n) space complexity though
05:55:55 <eevar2> i think the whole point to his question was that getting to the end of a list is O(N)
05:56:27 <arw> except if the list has a pointer to its end and is double-linked...
05:56:49 <BONUS> many times when you find yourself wanting the last elements of a list often, you might consider if you should be using lists in the first place
05:57:36 <arw> problem is, lists are very convenient because they are used very often.
05:57:47 <arw> many functions work on lists...
05:58:27 <Jafet> BONUS, what about lazy reverse?
05:58:29 <medfly> I find that's a problem too
05:59:25 <dantheman99> Hello, I was wondering could anyone answer a few questions I have about gui programming in haskell?
05:59:47 <BONUS> lazy reverse? either way i think the space complexity is O(n)
05:59:54 * araujo could
06:00:11 <Jafet> Well, if you need to keep the reversed list around.
06:00:35 <arw> Jafet: double-linked list is implicitly reversed.
06:03:09 <dantheman99> basically, I was wondering what gui library I should use if I want my program to work on windows...
06:03:19 <tilarids> Hello there. Is there any irc channel either for Leksah or haskell overlay for gentoo?
06:03:19 <dantheman99> are there any major problems with gtk2hs
06:03:47 <theorbtwo> gtk for win32 is fairly mature, I think.  I don't know about the haskell bindings, but I'd expect them to have no more then the usual problem.
06:04:39 <arw> qt for windows is also very stable and usable. as for the haskell bindings, no idea.
06:05:40 <quicksilver> the gtk2hs bindings are not totally complete btu I believe they are considered good.
06:05:48 <quicksilver> I believe the qt bindings are much more immature.
06:05:51 <quicksilver> I have used neither.
06:06:03 <Alpounet> qthaskell is quite nice
06:06:05 <quicksilver> (I despite GUI toolkits as a user but most especially as a programmer ;)
06:06:56 <Alpounet> and there will be a version compatible with Qt 4.6 soon
06:07:00 <Alpounet> (and GHC 6.12)
06:07:12 <quicksilver> good to know.
06:08:37 <quicksilver> Alpounet: that "()" noise is ugly
06:08:40 <quicksilver> what's that all about?
06:11:23 <Alpounet> quicksilver, I don't know why the binding needs "()"s
06:11:35 <araujo> dantheman99, i'd say go with gtk2s, you pretty much can do most of the gui programming with it
06:12:02 <araujo> dantheman99, not sure about its support in windows though , but i think you should find there the usual gtk+ issues
06:12:11 <Alpounet> because it is indeed ugly and useless (or am I missing a point ?)
06:13:08 <quicksilver> Alpounet: well it *appears* to be useless, but then I wonder if there is some typeclass magic going on
06:13:15 <quicksilver> I can't see it in the docs if so though
06:14:52 <Alpounet> quicksilver, OTOH, I guess there wouldn't be "()" if it wasn't necessary
06:15:33 <dantheman99> forgive my ignorance araujo, but what would be the 'usual' gtk issues?
06:16:48 <quicksilver> Alpounet: that's very generous of you ;)
06:16:59 <quicksilver> Alpounet: it could be there due to a misapprehension on the author's part
06:17:09 <quicksilver> Alpounet: or a design decision which I would disagree with
06:17:09 <copumpkin> I think we misunderestimate him
06:17:27 <quicksilver> like I disagree with his design decision to use tuples for multiple argument functions
06:17:36 <quicksilver> (but there may be a reason for that too)
06:17:36 <copumpkin> ugh
06:17:47 <Alpounet> quicksilver, I'd go with the design decision
06:17:52 <araujo> dantheman99, oh, i mean, problems that gtk+ can have under windows
06:17:59 <araujo> not related to gtk2hs specifically
06:18:52 <dantheman99> ah ok, thanks!
06:19:39 <araujo> @where himerge
06:19:40 <lambdabot> http://www.haskell.org/himerge/
06:19:51 <araujo> dantheman99, an example of a gtk2hs application
06:20:05 <araujo> :)
06:20:44 <Tinned_Tuna> Morning folks, I'm pretty new to Haskell from a Python/Java background, and I'm trying to get my first Haskell program compiling using 6.10.4
06:20:48 <Tinned_Tuna> *ghc 6.10.4
06:21:06 * copumpkin eats Tinned_Tuna instead
06:21:24 <Tinned_Tuna> What's the pastebin you guys use around here?
06:21:25 <Tinned_Tuna> :-)
06:21:29 <copumpkin> @hpaste
06:21:29 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
06:21:37 <Tinned_Tuna> thanks :-)
06:21:43 * copumpkin takes another bite
06:21:47 <copumpkin> omnom!
06:22:02 <Tinned_Tuna> :-D
06:22:40 <Tinned_Tuna> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=8454#a8454
06:22:57 <copumpkin> ghc --make
06:23:09 <copumpkin> I wish it were the default
06:23:13 <dantheman99> Thanks araujo, looks good!
06:23:22 <Alpounet> indeed.
06:23:31 <copumpkin> Tinned_Tuna: anyway, that's your answer
06:23:33 <Tinned_Tuna> thank you :-D
06:29:25 <araujo> dantheman99, :)
06:37:18 <mm_freak> currently i'm working with emacs and its dired/dired-x
06:37:32 <astroboy> i'm trying to install the cgi module with cabal install, but it gives this error: Network/CGI/Compat.hs:23:39: Module `Control.Exception' does not export `SomeException'
06:37:46 <mm_freak> does anyone know an alternative to the latter?  it gets annoying, as soon as your project has some deeper nested directory structure
06:38:34 <mm_freak> i especially like scripts, which don't require me to learn elisp =)
06:48:07 <astroboy> actually, I have found the problem, the computer on which I am trying to install cgi has base version
06:48:10 <astroboy> 3
06:48:43 <Saizan> astroboy: --preference="base >= 4"
06:48:50 <Saizan> heh
06:49:01 <Saizan> you need to upgrade ghc
06:49:29 <astroboy> Saizan: I can't... ghc version is 6.8.2
06:50:00 <astroboy> Saizan: and I can't change stuff on that machine
06:50:03 <Saizan> astroboy: you might also want to mail the maintainer, since base >= 3 && < 5 in cgi's .cabal file is wrong
06:50:27 <Saizan> astroboy: you've to try with an older version of cgi then
06:50:27 <astroboy> so there is no solution for that?
06:50:34 <astroboy> ah ok
06:50:46 <astroboy> how do I specity the cgi version on cabal?
06:51:09 <Saizan> e.g. cabal install cgi-3001.1.7.0
06:51:19 <astroboy> thanks a lot
06:51:50 <astroboy> ok the previous version worked :P
06:51:51 <astroboy> thanks
06:55:07 <roconnor> who is yitz on reddit?
06:55:26 <copumpkin> probably yitz in here too
06:55:55 <copumpkin> preflex: seen yitz
06:55:55 <preflex>  yitz was last seen on #ghc 17 days, 16 hours, 58 minutes and 31 seconds ago, saying: try it with () instead of {}
06:57:14 <roconnor> ah
07:03:55 * hackagebot hgom 0.6 - An haskell port of the java version of gom  http://hackage.haskell.org/package/hgom-0.6 (PaulBrauner)
07:09:59 <McManiaC> Main: NetworkziHsPurpleziUiOpsziAccountUiOps_ddcy: uncaught exception
07:10:17 <ablmf> In this program, why using a function is much slower than using expression directly?  http://pastebin.com/TWXpy7ah
07:10:21 <McManiaC> is there any way to get the location of that exception?
07:11:06 <ablmf> It seems that simply move the code in sub-function to caller function speed up the program greatly.
07:11:36 <zygoloid> McManiaC: i think you can tell ghci to stop when an exception is thrown
07:12:24 <zygoloid> ablmf: are you compiling with -O2?
07:12:26 <SamB_XP> McManiaC: another thing you can do is build for profiling and use +RTS -xc
07:12:36 <ablmf> zygoloid: No, I just use ghci
07:12:50 <SamB_XP> ablmf: that would be why ;-)
07:13:05 <zygoloid> ablmf: which function are you inlining?
07:13:22 <ablmf> zygoloid: countPrimes
07:13:23 <zygoloid> ah, countPrimes
07:13:33 <McManiaC> SamB_XP: build for profiling?
07:14:06 <ablmf> SamB_XP: I don't think it's because of ghci because of value cache
07:14:07 <zygoloid> ablmf: you've not just inlined it
07:14:12 <zygoloid> you've also done manual CSE
07:14:25 <ablmf> CSE?
07:14:40 <SamB_XP> McManiaC: that's the only way it can build an intelligable traceback
07:14:53 <McManiaC> how do you do that? :)
07:15:26 <SamB_XP> -p maybe ?
07:15:32 * SamB_XP hasn't done this in a while
07:16:03 <roconnor> what job does dibblego have?
07:16:20 <zygoloid> ablmf: countPrimes recursively calls itself on width-2
07:16:21 <ablmf> zygoloid: I can't find "CSE haskell" on Google, what's that?
07:16:33 <zygoloid> CSE == common subexpression elimination
07:17:01 <zygoloid> you've used the fact that your 'check' function already has pn from the previous time around rather than recomputing it
07:17:54 <ablmf> zygoloid: Yeah, but I think ghci would cache "countPrimes n" which is already caculated.
07:18:02 <zygoloid> ablmf: why would you think that?
07:18:22 <zygoloid> functions' results aren't memoized, generally
07:18:24 <ablmf> zygoloid: Because I think as haskell is pure functional
07:18:54 <zygoloid> ablmf: well, your expectation is incorrect, i'm afraid. if you want to memoize the result of a function you'll need to do it explicitly
07:19:20 <Alpounet> giving it a name, and using that name elsewhere
07:19:25 <zygoloid> @hackage data-memocombinators
07:19:26 <lambdabot> http://hackage.haskell.org/package/data-memocombinators
07:19:27 <ablmf> Why? Wouldn't function called by same arguments generate the same result everytime as haskell is pure functional?
07:19:29 <Alpounet> so you'll have sharing
07:19:49 <zygoloid> ablmf: it would. but that doesn't mean that it'll be stored and remembered. that would be a space leak.
07:20:23 <Zao> Hmm, does lambdabot expose trace somehow?
07:20:23 <McManiaC> SamB_XP: now i get: <GHC.Err.CAF>Main: NetworkziHsPurpleziUiOpsziAccountUiOps_dnH0: uncaught exception
07:20:26 <McManiaC> :>
07:20:40 <ablmf> zygoloid: OK. thx.
07:20:51 <Zao> > let x = 3+3 in (x, x)
07:20:52 <lambdabot>   (6,6)
07:20:53 <ablmf> Will ghc compiler do CSE?
07:21:06 <Zao> ablmf: I believe so, somewhat.
07:21:16 <jmcarthur> some
07:21:24 <SamB_XP> McManiaC: oh, I guess you need to rebuild with some cost centers ... check the GHC manual section on profiling...
07:21:37 <osaunders> Are there any Haskellers here in London, England?
07:22:09 <zygoloid> ablmf: it would need to be extremely cunning to notice that there even is a common subexpression. however, GHC is extremely cunning, so there's a chance :)
07:22:32 <zygoloid> osaunders: yes, there are. (but i'm not one of them)
07:22:45 <Zao> ablmf: Lazyness is mostly about not re-evaluating thunks.
07:23:37 <benjamin_scarlet> zao: really? I would have said laziness was mostly about not evaluating them at all in the first place.
07:23:48 <zygoloid> benjamin_scarlet: no. that's non-strictness.
07:23:59 <zygoloid> laziness = non-strictness + non-re-evaluation
07:26:00 <roconnor> @where TTFP
07:26:00 <lambdabot> http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/
07:27:26 <Feuerbach> does parsec have any repository and/or bugtracker?
07:27:40 <Feuerbach> seems that I found a bug
07:28:21 <McManiaC> SamB_XP: the *.prof file created by ghc is just empty =(
07:29:46 <SamB_XP> McManiaC: there are various flags that you can pass to GHC related to inserting "cost centers" into the program. You want some of those, since it prints out the "cost center stack" when you get an exception using +RTS -xc
07:30:57 <ablmf> I tried compiled versions.  Manually CSE is much much faster.  So I think I will be just more carefully about it rather than depends on compiler.
07:36:16 <McManiaC> can I kill a process in ghci without killing ghci?
07:36:25 <narens> hello, I want to compile with -prof, but I am using the Vector library and it tells me that i don't have the profiling libraries for vector. Is there something I can do?
07:37:03 <ablmf> What d u guys use haskell for?  After studying it for 2 weeks, I feel it's a good tool to resovle these problems related to numbers, algorithm, etc.  But I also feel that it's unlikely that people will use it in industry.
07:37:06 <SamB_XP> narens: well, you'd have to build+install that with -prof too
07:37:31 <narens> SamB_XP: so, not enough to just cabal install vector
07:37:40 <SamB_XP> ablmf: what -- they don't use algorithms in "industry"?
07:37:45 <McManiaC> ablmf: everything :)
07:37:47 <SamB_XP> narens: not quite, no :-(
07:37:49 <cogline> hello, running a prog with +RTS -hc -hbdrag causes a segfault int 11, removing hbdrag fixes, any ideas?
07:37:56 <Alpounet> ablmf, programming is about writing algorithms
07:37:59 <burp> narens: ~/.cabal/config library-profiling
07:38:01 <Alpounet> so I don't really get your point
07:38:04 <ablmf> SamB_XP: maybe C/c++
07:38:08 <SamB_XP> cogline: bug in the RTS!
07:38:09 <cogline> cabal install vector -p
07:38:15 <idnar> Alpounet: a lot of programming these days actually isn't
07:38:16 <narens> burp: oh?
07:38:24 <narens> i'll give it a shot
07:38:32 <burp> oh listen to cogline and use -p :>
07:38:37 <ablmf> Alpounet: maybe in some domain, programming is about algorithm
07:38:44 <idnar> Alpounet: your average web app is probably just a bunch of glue
07:38:44 <Alpounet> idnar, yeah, we have to put aside the pure business apps fitting JEE use
07:39:03 <benjamin_scarlet> ablmf: I'm in industry, and I'm using it.
07:39:05 <SamB_XP> idnar: there's some HTML in there too
07:39:14 <idnar> SamB_XP: well, okay, glue and content
07:39:15 <ablmf> But in the last 5 years of my experience, I haven't had a chance to use any algorithm other than hash
07:39:16 <Alpounet> SamB_XP, good point hah
07:39:56 <Alpounet> ablmf, what does your daily job consist in ?
07:40:02 <SamB_XP> ablmf: you haven't found enough excuses to write compilers/interpreters ;-P
07:40:13 <benjamin_scarlet> SamB_XP: :-)
07:40:42 <ablmf> SamB_XP:  web, GUI, etc.
07:41:37 <ablmf> Most problem I met in job, is not about "programming"
07:41:41 <narens> works like a charm... thanks
07:41:55 <ablmf> Sometimes the API does work as expected
07:42:12 <ablmf> Sometimes OS doesn't work as expected
07:42:13 * medfly hugs ablmf 
07:42:16 <medfly> ablmf, it's okay
07:42:24 <ablmf> Sometimes IDE stop working
07:42:46 <ablmf> that's my jobs, solving these kind of problems
07:43:14 <ablmf> Actully studying haskell makes me feel "That is what called programming"
07:43:52 <burp> yup :)
07:44:41 <ablmf> Why did you choose haskell?
07:44:53 <ablmf> I mean, there are also many many fp languages
07:45:34 <burp> which other pure functional languages with huge community and many libraries are there?
07:47:13 <ablmf> Eh but maybe all the others have good reason to be non-pure ?
07:48:09 <burp> I like the full purity ;-)
07:48:33 <burp> forces you to rethink problems
07:48:47 <dantheman99> Hey, can anyone tell me how I might go about uinstalling the Haskell platform from windows?
07:49:00 <Zao> dantheman99: There's no uninstaller?
07:49:06 <dantheman99> UNinstalling!
07:49:11 <burp> once you're in you're in
07:49:14 <ablmf> burp: ;)  That's also the reason why I choose haskell.  I want to try think completely diffrently.
07:49:16 <SamB_XP> UNinstaller
07:49:23 <SamB_XP> isn't there one?
07:49:30 <dantheman99> I couldn't find one??
07:49:41 <ystael> ablmf: for something even more completely different, there's always Coq :D
07:49:42 <Zao> It's in Add/Remove programs in the cpanel.
07:50:46 <Zao> http://www.acc.umu.se/~zao/addremove.png
07:51:02 <SamB_XP> Zao: I don't think the picture is needed ;-P
07:51:23 <Zao> There's no such thing as overkill.
08:13:21 <harlekin> @pl (\f -> f >>= when f)
08:13:21 <lambdabot> ap (>>=) when
08:17:08 <jmcarthur> :t when
08:17:09 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
08:17:26 <jmcarthur> i think that will not work
08:19:18 <alar> when b f = if b then f else return ()
08:19:40 <alar> @src when
08:19:40 <lambdabot> when p s = if p then s else return ()
08:20:01 <quicksilver> :t (\f -> f >>= when f)
08:20:02 <lambdabot>     Couldn't match expected type `Bool' against inferred type `m a'
08:20:02 <lambdabot>     In the first argument of `when', namely `f'
08:20:03 <lambdabot>     In the second argument of `(>>=)', namely `when f'
08:20:06 <quicksilver> yes, doesn't type.
08:20:22 <quicksilver> (@pl doesn't do type checking, it does mostly type agnostic rewriting)
08:20:28 <Alpounet> f can't be Bool and m () at the same time
08:20:37 <edwardk> :t (\f -> f >>= flip when f)
08:20:38 <lambdabot>     Couldn't match expected type `()' against inferred type `Bool'
08:20:38 <lambdabot>       Expected type: m ()
08:20:38 <lambdabot>       Inferred type: m Bool
08:20:42 <edwardk> aw shucks
08:21:17 <jmcarthur> would be nice to be able to supply when with a default value so we can be rid of the ()
08:21:26 <edwardk> :t guard
08:21:27 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
08:21:28 <jmcarthur> but i guess then it's just if
08:21:59 <edwardk> hrmm, my brain is failing at the moment, what is foo p s = if p then s else mempty
08:22:42 <jmcarthur> Monoid a => Bool -> a -> a ?
08:22:49 <Alpounet> s/a/m a/
08:22:50 <edwardk> er mzero
08:22:56 <ziman> mzero is from MonadPlus, mempty is Monoid
08:23:16 <edwardk> ziman: yeah, like i said, brain failing ;)
08:23:17 <Alpounet> (in the Monad case)
08:23:18 <jmcarthur> Alpounet: no i had it right. edwardk had it wrong :P
08:23:26 <ziman> is there a way to resolve such dualities elegantly?
08:23:36 <jmcarthur> i wish
08:23:42 <edwardk> ziman: kata? =)
08:23:48 <ziman> eh, duplicities, that is
08:24:10 <jmcarthur> i woudl love to be able to write out a nice algebra and then lift it over functors automagically
08:24:15 <ziman> edwardk, kata is a language? i've seen you mention it a few times
08:24:30 <jmcarthur> edwardk: how's kata coming along btw?
08:24:53 <shapr> @yow !
08:24:53 <lambdabot> Couldn't find fortune file
08:25:10 <jmcarthur> edwardk: i have to admit that i'm put off by the extreme lack of types, but that doesn't put me off enough to keep me from wanting to try it
08:25:11 <edwardk> jmcarthur: i'm currently wrestling with hygienic macro expansion, which is needed because it is really the only way to get useful 'deriving'-like behavior
08:25:36 <jmcarthur> ziman: #kata, iirc
08:25:50 <edwardk> ziman: its a pet programming language project of mine, which is slowly getting to the point of a public release ;)
08:26:29 <edwardk> ziman: rip out haskell's types, which kills its type classes, replace them with modules by necessity, then borrow tools from oop to allow you to build those modules incrementally
08:26:39 <jmcarthur> edwardk: kata is using your nifty monoidal parsing, right? is that living up to the promises in your slides?
08:27:10 <ziman> hmm
08:27:16 <edwardk> jmcarthur: it was, but i've punted the monoidal parser to the kata-in-kata implementation, and dumbed down the haskell version significantly, since i just want to use it to bootstrap now.
08:27:44 <edwardk> jmcarthur: i'm actually quite pleased with monoidal parsing
08:27:56 <jmcarthur> edwardk: oh, i didn't know about that development. so you are going for kind of a Io-like bootstrapping model?
08:28:37 <jmcarthur> or, wait, does kata have a compiler or interpreter? i fail to remember now
08:29:03 <edwardk> jmcarthur: right now the model is to write a simple interpreter in haskell to get a feel for the semantics and move to a compiler for kata in kata
08:29:12 <jmcarthur> oh i see
08:29:27 <jmcarthur> planning to bootstrap fairly early :)
08:29:33 <edwardk> yeah
08:29:47 <edwardk> it forces me to think about things like FFI, etc. out of the gate
08:30:45 <edwardk> i had originally been hacking on a compiler for kata in haskell, but when i looked at it more and more optimizations there would just have to be reimplemented later, and would warp my thinking, keeping me from learning how to think about how to implement those in kata rather than implement them in haskell-flavored kata
08:30:46 <jmcarthur> the idea of bootstrapping a language too early frightens me. what if a bug manages to slip in that lives through a fixpoint? ;)  (overly paranoid, i know)
08:31:20 <jmcarthur> oh i see. makes sense
08:32:12 <McManiaC> @pl \a b -> foo $ bar a b
08:32:12 <lambdabot> (foo .) . bar
08:32:22 <edwardk> well, for now the goal is to keep the interpreter around so that it is capable of interpreting the compiler, which helps with porting, etc.
08:32:56 <jmcarthur> edwardk: yeah. my fear of bootstrapping is irrational
08:33:22 <edwardk> porting becomes build the interpreter, interpret the compiler compiling the compiler, then compile the compiler with the compiled compiler ;)
08:33:33 <aksionov> humor: http://v-dot-v.blogspot.com/2009/07/ccc-5-trial.html http://v-dot-v.blogspot.com/2009/07/schrodingers-cat.html
08:33:48 <jmcarthur> edwardk: is the last step necessary?
08:33:50 <edwardk> try saying that 3 times real fast ;)
08:35:27 <edwardk> jmcarthur: possibly not, one argument for it is sort of like the distinction between a stage-1 and stage-2 haskell build, it lets you have features or optimizations that are implemented in the compiler that aren't used by the bootstrap interpeter. either because they use language features it doesn';t support, or for speed of bootstrapping
08:44:18 <byorgey> interpret the compiler compiling with the compiled compiling interpoling the comperpreter the... dang
08:44:47 <edwardk> futamura would be proud
08:45:32 <byorgey> hehe
08:49:53 <ziman> i thought the extra step was to verify that the interpreted compiler produces the same code as the compiled one
08:50:49 <ziman> (by comparing the intepreted-compiler-compiled compiler against the compiled-compiler-compiled compiler)
08:51:07 <jmcarthur> keep going until you reach a fixpoint! ;)
08:52:17 <ziman> > fix compile
08:52:18 <lambdabot>   "a compiler!"
08:52:27 <jmcarthur> o_O
08:52:32 <jmcarthur> :t compile
08:52:34 <lambdabot> forall b. b -> [Char]
08:52:48 <jmcarthur> > compile 6
08:52:49 <lambdabot>   "a compiler!"
08:52:52 <jmcarthur> heh
08:52:54 <quicksilver> edwardk: but then you end up being a kata hacker, not a haskell hacker.
08:53:01 <quicksilver> edwardk: your loss will be mourned!
08:53:04 <ziman> :) i just defined compile = const "a compiler!" in the query ;)
08:53:22 <edwardk> quicksilver: i doubt i'll ever cease to be a haskell hacker =)
08:53:44 <quicksilver> edwardk: speaking entirely selfishly I'd rather have a monoidic parser library than a working kata implementation, I like types!
08:53:52 <quicksilver> still, I'll be interested to see up with what you come.
08:54:23 <jmcarthur> "with what you come" *shudder*
08:54:34 <jmcarthur> sometimes ending with a preposition is preferable to me
08:54:35 <edwardk> quicksilver: hah. to be honest the reason i started wanting to do a lot of stuff like this in is that things like monad-ran are readable in kata, but illegible in haskell ;)
08:54:56 <jmcarthur> *"up with what you come"
08:55:17 <edwardk> jmcarthur: that is the sort of nonsense up with which I will not put ;)
08:55:46 <edwardk> jmcarthur: meh, english is not latin, its easy enough to dangle a preposition here or there
08:56:33 <jmcarthur> yeah
08:57:43 <quicksilver> had an effect tho ;)
09:02:20 <quicksilver> edwardk: yeah, with you on the legibility point, sort of.
09:02:46 <quicksilver> edwardk: but I haven't internalised that problem well enough to decide if it's a fundamental flaw of haskell, or a simple one to work around with just a slightly more expressive notation for types.
09:02:56 <quicksilver> edwardk: haven't had as much time to think about it as I'd like.
09:04:28 <jmcarthur> it is my unprovable opinion that if you can mentally prove that it's okay to do X then you can also prove it elegantly with some sort of type system
09:05:00 <jmcarthur> perhaps instead of "opinion" i should say "hunch"
09:05:05 <SamB_XP> jmcarthur: you mean, if you can do it without any paper?
09:05:18 <jmcarthur> SamB_XP: at least, yeah
09:05:40 <SamB_XP> probably with some sort!
09:06:28 <SamB_XP> but I dunno how well you can integrate all those little proofs into a single cohesive typesystem
09:06:53 <jmcarthur> SamB_XP: that was my intended point. it's my hunch that it is possible to do that
09:06:56 <SamB_XP> (where cohesive is taken as the opposite of what C++ is)
09:07:31 <edwardk> quicksilver: in my case it comes down to too much newtype noise for that particular chunk of code.
09:07:58 <jmcarthur> there exists some type system such that if one can visualize a proof for some code then that proof can be elegantly encoded into that type system (define subjective terms as needed)
09:08:19 <SamB_XP> jmcarthur: I doubt it
09:08:23 <SamB_XP> there is no silver bullet
09:08:47 <MadHatterDude> Yo
09:08:59 <jmcarthur> certainly not. i'm not shooting for elegant proofs of arbitrary properties. just those properties which are simple enough for our poor mental capacities
09:09:12 <SamB_XP> even so ...
09:09:27 <SamB_XP> it seems like you're always going to have missed something a human finds easy!
09:10:20 <jmcarthur> things like "It is obvious to me that it is safe to apply this partial function to this value in this case"
09:10:42 <jmcarthur> i guess where "safe" in this case means "will not be _|_"
09:11:23 <edwardk> but, i like _|_. it is the only inhabitant i can rely on being present in (almost) every type!
09:11:32 <edwardk> =)
09:11:45 <ziman> almost?
09:12:02 <jmcarthur> yeah, there will always be something not captured nicely in the type system. my speculation is that even thoughsuch a type system may exist, we may not discover it
09:12:06 <edwardk> ziman: it is arguable when it comes to unlifted types, etc.
09:12:08 <ziman> except unboxed types?
09:12:11 <ziman> i see
09:12:12 <jmcarthur> hence my hunch being unprovable :\
09:12:54 <SamB_XP> jmcarthur: the other thing is that we have no way of pinning down exactly what things a human might find easy to mentally prove ;-P
09:12:56 <edwardk> i think 'may' is awfully generous of you, "almost certainly won't" seems more appropriate ;)
09:13:04 <jmcarthur> to discover a type system which matches so well with the human mind would require a full understanding of the human mind
09:13:05 <ziman> well, Int# -> Int# may still loop indefinitely, I think
09:13:16 <jmcarthur> edwardk: more poor wording on my part
09:13:55 <SamB_XP> ziman: there is no halting problem in Int# -> Int#!
09:14:02 <SamB_XP> either it loops forever, or it doesn't
09:14:10 <jmcarthur> anyway, the particular case i meant to apply all this to was that of noisy newtype wrapping
09:14:19 <SamB_XP> and you CAN prove which
09:14:27 <jmcarthur> i think it's very likely that we can reduce it somehow
09:14:40 <SamB_XP> you just need an impossible amount of RAM to do it in ;-P
09:15:02 <ziman> ah :)
09:16:01 <SamB_XP> I, er, think
09:17:02 * SamB_XP is having some difficulty with how you'd go about proving when such a function would terminate
09:17:04 <ziman> but you cannot probably tell for a single value, hm.
09:17:15 <SamB_XP> ziman: hmm?
09:17:21 <ziman> although you can inspect all possible inputs
09:18:37 <SamB_XP> I'm thinking you would build a graph of how the function recurses
09:18:58 <SamB_XP> checking for cycles all the way, of course
09:19:40 <ziman> well, yes, if it is the only function in the scope
09:19:45 <SamB_XP> but such a graph could take up |Int#|^2 storage
09:20:21 <MadHatterDude> I <3 Pointlessness
09:20:28 <ziman> (and consider Int# finite domain)
09:20:41 <SamB_XP> ziman: Int# *is* finite
09:21:02 <SamB_XP> it's just that nobody has |Int#|^2 units of storage
09:21:03 <ziman> yes
09:22:57 <SamB_XP> possibly there are other ways to do this that don't require quite so much storage ...
09:23:47 <SamB_XP> I suppose you could always just evaluate the function and keep track of what nested evaluations of the function you are doing ...
09:24:42 <SamB_XP> that would only need |Int#| units of storage
09:24:49 <SamB_XP> by pigeonhole
09:25:22 <SamB_XP> (in this case, each unit would be an Int#)
09:26:06 <ziman> you mean memoize the function?
09:26:10 <SamB_XP> (if you were okay with insane, but finite, time requirements)
09:26:35 <ziman> hm
09:26:55 <SamB_XP> I guess you could do that too
09:27:11 <SamB_XP> I was just thinking you'd keep a "stack" of what args you were evaluating the function with
09:27:35 <ziman> i see
09:27:37 <SamB_XP> that is, every time you reentered it, you'd add the arg to the top of the stack
09:27:49 <SamB_XP> and every time you exited, you'd take it off again
09:28:13 <SamB_XP> and I guess it would be fastest if you also memoized at least whether or not it had returned
09:28:18 <MadHatterDude> hmm... Non exhaustive pattern?
09:28:27 <MadHatterDude> What can cause that?
09:29:01 <SamB_XP> but to be really fastest, you'd also want a bitmap that had every bit that was in the stack set, for quicker checking whether you were in a loop
09:29:42 <SamB_XP> so that's one stack of potentially all Int#s and two bitmaps of |Int#| bits each
09:29:59 <ClaudiusMaximus> > (\False -> "no boom") True
09:30:00 <lambdabot>   "* Exception: <interactive>:1:134-152: Non-exhaustive patterns in lambda
09:30:38 <MadHatterDude> Cladius: Thanks, figured it out
09:30:50 <SamB_XP> so (bitsIn Int# + 2)*|Int#| bits
09:30:58 <copumpkin> RayNbow: no there aren't!
09:31:40 <SamB_XP> of course, the stack would presumably not fit in the address space, but should easily fit in a file
09:32:34 <SamB_XP> and the time complexity ... well, that'd be something like O(|Int#|^3), I think?
09:32:46 <SamB_XP> not positive
09:34:53 <SamB_XP> (The whole point of the stack is to not reenter the function with the same argument, because if you do that you're obviously in a loop, which is why the stack will only ever hold |Int#| Int#s)
09:35:26 <SamB_XP> of course, I just made up that time complexity ...
09:35:27 <MaciejP> I accidentally found hackage reverse dependencies: http://bifunctor.homelinux.net/~roel/hackage/packages/archive/revdeps-list.html. Any chance to see this in the `real' hackage soon?
09:35:54 <SamB_XP> what's the worst runtime an Int# -> Int# can have and still terminate?
09:36:51 <SamB_XP> or, should I say, what's the most recursions it can do?
09:37:57 <SamB_XP> actually, I guess it can be pretty bad if there are inherently slow functions involved just to calculate what arguments to pass in recursive calls :-(
09:38:52 <SamB_XP> I guess that doesn't change the asymptotic complexity though ...
09:41:04 <copumpkin> no floyd-warshall in fgl or any other haskell libs?
09:41:34 <SamB_XP> hmm?
09:41:56 <copumpkin> I'm looking for a decent implementation of floyd-warshall
09:42:01 <copumpkin> but can't find one
09:42:11 <copumpkin> it's the world's simplest algorithm, so I figured it would be there
09:42:31 <SamB_XP> if it's so simple, maybe you just can't see it ;-P
09:42:39 <SamB_XP> what does it do ?
09:42:46 <copumpkin> all-pairs shortest path in a graph
09:42:58 <copumpkin> in n^3 time
09:43:09 <copumpkin> (where n is number of vertices)
09:43:17 <SamB_XP> oh! that. right.
09:43:42 <SamB_XP> what data structure would be best though?
09:43:56 <copumpkin> a mutable adjacency matrix
09:44:04 <copumpkin> since that's going to be your output in the first place
09:44:09 <ddarius> copumpkin: Start a graph algorithm library similar to Cale's astar package.
09:44:19 <copumpkin> (you could only store one triangle of it)
09:44:29 <copumpkin> @hackage astar
09:44:29 <lambdabot> http://hackage.haskell.org/package/astar
09:44:30 <BONUS> cram it in an array and do everything in ST?
09:44:32 <copumpkin> haven't seen that one
09:44:34 <jmcarthur> yeah i liked that astrat package
09:44:38 <copumpkin> BONUS: I was thinking of that
09:44:41 <jmcarthur> nice and generic
09:44:42 <int-e> why mutable? you can build the array for n+1 nodes from the array for n nodes.
09:44:51 <SamB_XP> copumpkin: why only one triangle ... are you thinking non-directed graphs?
09:45:01 <jmcarthur> *astar
09:45:08 <int-e> (by which I mean, instead of doing that in place, you can build a new array)
09:45:11 <copumpkin> SamB_XP: I guess I was, yep. Probably best to be general though
09:45:27 <copumpkin> int-e: it's already a fairly heavy algorithm
09:45:33 <SamB_XP> hmm, yeah, it doesn't really save much time to use a mutable one does it ?
09:46:05 <copumpkin> I like the A*
09:46:07 <copumpkin> hmm
09:46:40 <SamB_XP> and if you use a mutable one, you can't use ! -- you have to use those <- and getItem or whatever ...
09:46:49 <copumpkin> well yeah :P
09:46:52 <MadHatterDude> Hey guys, I'm making a small operator-based regex implementation in Haskell.
09:47:20 <copumpkin> I could try writing it with unboxed vectors of bools I guess
09:47:24 <copumpkin> representing the adjacency matrix
09:47:27 <copumpkin> or even DPH :o
09:47:34 <MadHatterDude> I just can't seem to find a way to mach through the pattern-tree declaratively (POSIX style)
09:47:38 * jmcarthur wishes vector's unboxed bools were packed
09:47:44 <copumpkin> jmcarthur: they aren't?
09:47:46 <copumpkin> boo
09:47:53 <jmcarthur> copumpkin: they aren't, at least not yet
09:47:55 <dolio> Submit a patch!
09:47:58 <luite> uvector's bools are packed, but the implementation is buggy
09:47:59 <jmcarthur> thought about it
09:48:22 <SamB_XP> copumpkin: the one in MY book starts with a matrix containing the *weighted* adjacency info
09:48:23 <dolio> How's my dons impression?
09:48:31 <jmcarthur> dolio: accurate
09:48:41 <copumpkin> SamB_XP: sure, if you want to attach edge weights
09:48:45 <copumpkin> that'd be most general
09:48:51 <copumpkin> doesn't really affect anything
09:49:20 <jmcarthur> lots of things i want to see done with vector
09:49:34 <jmcarthur> might end up just doing them myself
09:49:40 <copumpkin> okay, how does one use DPH these days?
09:49:46 <jmcarthur> copumpkin: badly
09:49:49 <copumpkin> I mean
09:49:57 <copumpkin> Data.Array.Parallel deosn't seem to be there
09:50:13 <jmcarthur> i decided to just abandon DPH until it's matured
09:50:25 <copumpkin> oh I think the packages are hidden
09:50:26 <copumpkin> by default
09:50:36 <jmcarthur> plus i can't reap much benefit from it since i only have two cores anyway
09:50:49 <copumpkin> jmcarthur: I want to push it! if nobody uses it they won't feel as compelled to make it awesome :P
09:50:55 <dolio> There are two different dph packages, I think.
09:51:00 <copumpkin> yeah, there are
09:51:04 <dolio> So you have to pick one.
09:51:07 <copumpkin> I was just confused because the packages are all hidden by default
09:51:17 <dolio> Depending on whether you want parallelism enabled or something.
09:51:26 <copumpkin> yeah, dph-seq and dph-par
09:51:51 <jmcarthur> i'll be happy if/when dph get's a vector-like interface
09:51:55 <jmcarthur> *gets
09:52:07 <jmcarthur> i think that's the plan
09:52:16 <copumpkin> meh, the docs are out of date
09:52:39 <jmcarthur> out of date docs just means there's been progress :)
09:53:26 <jmcarthur> i like how type signatures really make haskell significantly more self-documenting than other languages
09:55:07 <zygoloid> it's more self-documenting than many languages with required type signatures. hooray for a rich type system
09:55:24 <jmcarthur> yes
09:56:33 <SamB_XP> copumpkin: it's not like the actual algorithm is any different if you attach edge weights
09:56:40 <copumpkin> SamB_XP: yeah, that's what I mean
09:56:56 <SamB_XP> ah, yeah, I see that now
09:57:12 <SamB_XP> I was taking the dog out so I missed a lot ;-P
09:59:30 <copumpkin> is there a notion of an ordered (semi)ring? I'm writing a general (semi)ring solver for equations and was wondering whether it would be possible to incorporate inequalities
10:01:31 <opqdonut> copumpkin: yes, http://en.wikipedia.org/wiki/Ordered_ring
10:01:45 <RayNbow> <copumpkin> RayNbow: no there aren't! <-- yes, there are! :p
10:02:11 <copumpkin> opqdonut: ah, nice!
10:02:19 <copumpkin> RayNbow: nuh uh
10:03:30 <RayNbow> copumpkin: gaming is a valid non-compsci reason to use a Windows machine :p
10:03:35 <gruvstad> someone used the random-fu library? i need some help getting started.
10:03:40 <copumpkin> RayNbow: steam for mac is coming soon
10:04:52 <RayNbow> copumpkin: there are also non-Steam games from the previous decade :p
10:05:20 <copumpkin> they'll run in a VM
10:05:36 <copumpkin> the only real reason to use windows is IDA
10:05:44 <lament> IDA?
10:05:48 <copumpkin> because the text UIs for linux and mac are lame
10:05:53 <SamB_XP> IDA Pro, the disassembler par excellance
10:05:54 <copumpkin> interactive disassembler
10:05:56 <lament> oh
10:05:58 <thaldyron> Is there a way to automatically run a command when a patch has been applied by darcs?
10:06:20 <SamB_XP> thaldyron: ask in #darcs ?
10:06:26 <Gracenotes> copumpkin: are you saying virtual machines aren't real?!?
10:06:34 <Gracenotes> noooooo
10:06:59 <lament> it's all in your head!
10:07:11 <SamB_XP> Gracenotes: they are and are not at the SAME TIME
10:07:12 <Boohbah> virtual hosts are not real hosts!
10:07:13 <thaldyron> SamB_XP: already did, no one answered
10:07:13 <SamB_XP> it's like QM
10:07:32 <SamB_XP> thaldyron: ah. I only said that because I don't know, but am pretty sure the answer is yes!
10:07:40 <SamB_XP> thaldyron: look up "hooks" in the manual!
10:09:45 <thaldyron> SamB_XP: thanks, found it
10:21:02 <vakosel> hi  i am new to haskell and to the community , any help about haskell ide? i just downloaded leksah and wants me to 'show' folder of haskell source code . any idea?
10:22:34 <copumpkin> what do you want an IDE for?
10:22:46 <copumpkin> true hackers code in ed
10:23:34 <medfly> hehe
10:23:37 <vakosel> like emacs?
10:23:40 * roconnor uses kate
10:23:41 <FauxFaux> vim in ed mode, much scarier.
10:23:54 <roconnor> but an IDE for haskell would be nice
10:24:02 <copumpkin> vakosel: I mean the ed program
10:24:05 <roconnor> I've never tried leksah
10:24:05 <dleslie> I rather like Emacs' haskell-mode
10:24:05 <FauxFaux> Eclipse-fp isn't tooo bad, but it's still being written.
10:24:11 <znutar> M-x viper-mode
10:24:21 <dleslie> Leksah is slow and broken, I could never get the tags to work properly
10:24:36 <vakosel> ed program?
10:25:22 <maltem> vakosel, http://xkcd.org/378/
10:25:33 <dleslie> vakosel: Seriously, Emacs haskell-mode has pretty good ghci integration, and if you don't mind using etags to build your tags occasionally, has decent tag matching/searching
10:25:52 <dleslie> I'm sure there's a vim equivalent if you prefer that
10:25:55 <twink> It's not "ed mode" it's called ex
10:26:25 <roconnor> MarcWeber has a very nice vim mode for haskell IIRC
10:26:29 <vakosel> ... a quite active community.
10:26:31 <vakosel> i am glad
10:26:57 <sinelaw> Alpounet, i've pushed a few updates
10:26:57 <medfly> hi sinelaw
10:27:08 <sinelaw> hi medfly :P
10:27:10 <dleslie> maltem: Emacs actually has M-x butterfly now ;)
10:27:18 <Alpounet> sinelaw, nice. What's new ?
10:28:44 <Alpounet> sinelaw, removed the binary ?
10:29:09 <Twey> I wonder if we are the largest PL channel on Freenode yet.
10:29:21 <twink> Dare I ask what M-x butterfly does?
10:29:30 <dleslie> Flips a random bit in an open buffer
10:29:37 <Alpounet> isn't it obvious ?
10:30:00 <dleslie> Notice how not a single person responded "Use Yi"
10:31:00 <maltem> dleslie, well that would have been the answer to the question "I want see how you could program an advanced editor in Haskell"
10:31:22 <dleslie> The problem with Yi being modeled after Emacs is that it's not Emacs. It leaves you expecting everything you can do in Emacs to be there, and when it's not it leaves you feeling that it's unfinished and hollow.
10:31:24 * twink suspected FFT-related permutations of lines weren't it
10:33:36 <cYmen> Good evening.
10:33:43 * twink would've expected a reimplementation of vi in Haskell would've been more successful.
10:34:22 <cYmen> I'm trying to learn haskell with rwh and really need some debug output for my graham scan. How can I just print the arguments without otherwise interfering with the function?
10:34:35 <Twey> cYmen: Debug.Trace
10:34:55 <maltem> twink, yi does have a vi(m) keymap
10:35:45 <maltem> That on its own doesn't make it 100% usable, but still :)
10:36:08 <copumpkin> does DPH not allow [:[:Double:]:] ?
10:36:16 <copumpkin> I thought it did
10:36:22 <copumpkin> but ghc is telling me invalid type signature
10:36:24 <edwardk> should have been called yemacs ;)
10:37:47 <dolio> copumpkin: I think you need a LANGUAGE for that.
10:37:52 <dolio> PArr maybe?
10:37:54 <Twey> DPH?
10:37:57 <copumpkin> I already have that
10:38:01 <copumpkin> {-# LANGUAGE PArr, ParallelListComp #-}
10:38:27 <dolio> I thought PArr was what enabled the [: :].
10:39:16 <edwardk> aren't ParallelListComps just things like [ (x,y) | x <- xs | y <- ys ] ?
10:39:28 <copumpkin> I thought so
10:39:52 <copumpkin> just gives me a zip
10:39:53 <twink> maltem: Well, there's a lot less to do in vi unless you're trying to e.g. clone vim extensions like perl scripting too.
10:39:54 <edwardk> so why are they relevant? =)
10:39:55 <copumpkin> with prettier syntax
10:40:06 <dolio> copumpkin was just bragging.
10:40:08 <copumpkin> edwardk: because I copied it from the DPH example :)
10:40:13 <edwardk> copumpkin: hah
10:40:31 <edwardk> cargo cultist ;)
10:40:35 <copumpkin> lol
10:40:41 <copumpkin> anyway, PArr doesn't do it
10:40:55 <copumpkin> even [:Double:] doesn't seem to work
10:41:54 <dolio> :k [: Int :] works in ghci 6.13.stuff.
10:41:55 <lambdabot> parse error on input `:'
10:41:59 <copumpkin> hm
10:42:04 <dolio> With -XPArr
10:42:31 <sinelaw> Alpounet,  what binary? i've added a bunch of opencv functions, and updated the test to do edge detection
10:42:52 <maltem> twink, ah I keep forgetting how emacs is more of an operating system to emacs users :) One major vi feature missing from yi (the last time I looked) was vi-like undo, and indeed the reason it's not there is that it's hard to conglomerate with the emacs-oriented part of the code
10:43:06 <dolio> Works in 6.10.4, too.
10:43:15 <Alpounet> sinelaw, I don't have any binary built, or it appears there isn't at least
10:43:17 <copumpkin> with the exact example from the dph wiki page I get a nice vectorization error now
10:43:17 <Alpounet> any hint ?
10:43:22 <copumpkin> no "invalid type signature" error though
10:43:23 <copumpkin> meh
10:43:44 <dolio> And 6.12.1
10:43:47 <copumpkin> http://snapplr.com/gv7v
10:43:57 <sinelaw> Alpounet, dist/build/test-hopencv/test-hopencv
10:44:05 <sinelaw> ^^ doesn't exist after you run cabal build?
10:44:26 <sinelaw> or if you run cabal install, try test-hopencv from anywhere
10:44:26 <twink> maltem: vi-like undo being difficult sounds weird, but anyway
10:45:21 <copumpkin> ugh, no overloading
10:45:33 <maltem> twink, it's not difficult in itself, I think I sent a patch once, but it broke something about the emacs part, so JP didn't like it
10:45:51 <jmcarthur> copumpkin: now you are seeing the reasons that i am not using dph yet
10:46:11 <twink> maltem: Is this where undo is toggle-like in vi and arbitrarily deep nested undo in emacs?
10:46:16 <copumpkin> jmcarthur: I SHALL OVERCOME!
10:47:11 <maltem> twink, I don't remember about the details of the problem, but I don't think so: yi didn't (doesn't?) have any kind of fancy undo at all
10:47:28 <maltem> maybe I'll find it in the bug tracker
10:48:46 <copumpkin> hmm, no indexing operator?
10:49:37 <vakosel> emacs works fine . thx for the help
10:50:04 <maltem> twink: http://groups.google.com/group/yi-devel/browse_thread/thread/cd7ca5cbeffb6c8d/0e6295916fa52b9a?lnk=gst&q=undo#0e6295916fa52b9a (K. Noel was my nickname two years ago :p)
10:54:44 <twink> maltem: oh boy that's a lot of missing pieces
10:56:28 <maltem> Wait, that mail conversation is from September 2009? I would have thought it was a year ago or something. Apparently, my feeling for time got really bad
10:57:28 <sinelaw> we have a maybe monad right
10:57:36 <sinelaw> what about the Certainly Monad?
10:57:42 * sinelaw ducks
10:58:26 <maltem> sinelaw, what would be slightly more interesting is the probability monad
10:58:44 <sinelaw> yeah...
10:59:29 <maltem> On another note, anyone here who knows a little about dependent types? I'm trying to understand http://code.haskell.org/Agda/examples/lib/Logic/Leibniz.agda
10:59:42 <sinelaw> maltem, maybe in #agda?
10:59:49 <maltem> hmm good suggestion :)
11:02:10 <MaciejP> I get `Failed to load interface for `HS'' when using qualified expressions in GHCi, but it works perfectly in the Haskell source!?
11:09:44 <MaciejP> Ah, it means the function I used is not exported from that module. Very misleading error message ... :-S
11:13:07 <sinelaw> i'm trying to use MaybeT without going into Monad transformers too much
11:13:16 <sinelaw> what I want is only MaybeT IO a
11:13:25 <sinelaw> even MaybeT IO ()
11:13:52 <sinelaw> can someone explain how to use that in a nutshell? not how it works :P
11:14:13 <sinelaw> (i know some of the working details, but at this very moment i need to use it)
11:14:31 <roconnor> @unmtl MaybeT IO a
11:14:31 <lambdabot> IO (Maybe a)
11:14:37 <BONUS> use lift to turn normal IO actions to MaybeT IO a actions
11:14:39 <BONUS> i guess
11:15:40 <edwardk> foo = do x <- lift $ someFancyIO operation; -- the only real change is that you can use mzero and mplus
11:15:59 <sinelaw> @type mzero
11:16:00 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a
11:16:09 <sinelaw> edwardk, ok what do I do with those
11:16:18 <edwardk> mzero for MaybeT is basically an IO wrapped Nothing
11:16:20 <sinelaw> BONUS, yeah that much i got :)
11:16:25 <roconnor> @src guard
11:16:25 <lambdabot> guard True  =  return ()
11:16:25 <lambdabot> guard False =  mzero
11:16:27 <edwardk> well, the question is what are you trying to do with MaybeT?
11:16:59 <sinelaw> edwardk, write nicely code that does IO, where some IO actions return Maybes. if nothing is returned, i'd like to 'break' out of the sequence
11:17:04 <sinelaw> otherwise, continue.
11:17:05 <edwardk> ah
11:17:45 <edwardk> manually lift those by using MaybeT (your Maybe returning io operation)
11:17:55 <sinelaw> yeah
11:18:14 <sinelaw> then what
11:18:28 <BONUS> well afaik the short circuiting action takes care of itself
11:18:36 <edwardk> foo = do x <- MaybeT (someMaybeReturningIOOperation); y <- MaybeT (someOtherMaybeReturningIOOperation); lift someNormalIOOperation; return (x,y)
11:18:36 <roconnor> then write your code, then runMaybeT
11:18:40 <byorgey> sinelaw: have you looked at the example on http://hackage.haskell.org/packages/archive/MaybeT/0.1.2/doc/html/Control-Monad-Maybe.html ?
11:18:44 <edwardk> wrap all of that in a runMaybeT
11:19:32 <sinelaw> byorgey, thanks i will. and edwardk thanks too.
11:19:36 <sinelaw> i think that's enough to get me rolling
11:20:26 <edwardk> if you have a non-io operation that returns a Maybe, you can write something like liftMaybe = MaybeT . return -- that way if do something like liftMaybe $ Data.Map.lookup ...
11:21:27 <edwardk> then it does the right thing
11:22:02 <sinelaw> cool
11:24:38 <sinelaw> last thing, if something expects an 'IO a' but now I have a 'MaybeT IO a', how do i convert it back
11:24:42 <sinelaw> into IO a
11:25:31 <BONUS> well if you do runMaybeT you get back an IO (Maybe a)
11:25:47 <sinelaw> ah
11:26:05 <BONUS> if you want to get rid of that inner maybe you can fmap the maybe function on there
11:26:09 <BONUS> :t maybe
11:26:10 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
11:26:24 * chrisdone ruffles BONUS's hair
11:26:30 <BONUS> d'aww :3
11:26:38 <chrisdone> :3
11:27:25 <zygoloid> sinelaw: if you have a MaybeT IO a and you want an IO a, there's always unsafeCoerce ;-)
11:27:28 <zygoloid> *ducks*
11:27:35 <sinelaw> hah
11:27:41 <sinelaw> *geese*
11:28:11 <BONUS> runMaybeT $ do lift $ putStrLn "one"; mzero; lift $ putStrLn "two" -- yields Nothing, prints only "one"
11:28:53 <chrisdone> I like MaybeT
11:29:16 <sinelaw> so do you like T or don't you like T?
11:29:59 <chrisdone> Just T
11:30:07 <sinelaw> BONUS, battling here with types to escape from MaybeT IO () to IO ()... i realize it's silly
11:30:27 <BONUS> hahaha
11:30:39 <sinelaw> :)
11:30:52 <sinelaw> chrisdone, my opencv bindings are progressing, btw.
11:31:59 <SubStack> a lazy relational database would be pretty sweet
11:32:01 <chrisdone> sinelaw: nice one! I'm afraid I've had no luck getting my cam to work ~ but ..
11:32:18 <sinelaw> chrisdone, i figured how to work mine
11:32:22 <sinelaw> same one you have :)
11:32:37 <sinelaw> i've added this to my .bashrc
11:32:40 <SubStack> especially if it used haskell expressions instead of sql
11:32:44 <sinelaw> chrisdone, export LD_PRELOAD=/usr/lib/libv4l/v4l1compat.so
11:33:09 <chrisdone> sinelaw: yeah I tried that a while ago to no pie
11:33:13 <sinelaw> :(
11:33:18 <chrisdone> let me try again incase pixies were in my computer
11:33:29 * sinelaw hears fireworks
11:33:41 <sinelaw> you'll also need an up-to-date libv4l
11:33:58 <chrisdone> witha pt-get?
11:34:10 <sinelaw> let me see
11:34:59 <sinelaw> chrisdone, yeah i think so
11:35:07 <sinelaw> i have libv4l-0 version 0.6.4-1+hg20100220~kkv4l1
11:36:08 <chrisdone> ah, mine is 0.6.0-1
11:36:11 * chrisdone updates
11:41:35 <chrisdone> x decided to crash =)
11:41:51 <chrisdone> I think emacs --daemon/emacsclient causes it
11:41:53 <Twey> And you didn't use screen?  Tsk, tsk.
11:42:11 <chrisdone> no, I used emacs --daemon/emacsclient
11:42:53 <sinelaw> bah
11:42:54 <Alpounet> sinelaw, I get a linker error. What's this HSrts_debug_p lib ?
11:43:12 <sinelaw> i have absolutely no idea :(
11:43:23 <sinelaw> can you hpaste the error?
11:43:27 <Alpounet> what you do have it whereas I do not :(
11:43:52 <Alpounet> sinelaw, /usr/bin/ld: cannot find -lHSrts_debug_p
11:44:12 <chrisdone> how do you find out your ubuntu version?
11:45:02 <chrisdone> ah, cat /etc/lsb-release
11:45:26 <sinelaw> chrisdone, so what version are you running?
11:45:30 <chrisdone> karmic
11:45:31 <sinelaw> i'm with karmic (9.10)
11:45:40 <sinelaw> and you updated libv4l-0?
11:45:44 <chrisdone> sinelaw: how did you upgrade your v4l?
11:45:53 <chrisdone> mine thinks, whatever I said before, is the latest version
11:46:05 <sinelaw> sudo apt-get update; sudo apt-get install libv4l-0
11:46:10 <sinelaw> hmm.
11:46:13 <sinelaw> maybe i got it from elsewhere
11:46:19 <sinelaw> when i was battling the bugs
11:46:19 <chrisdone> libv4l-0 is already the newest version.
11:46:34 <chrisdone> I can probably get it off launchpad or whatnot
11:47:01 <sinelaw> ah yeah, a ppa
11:47:45 <chrisdone> tada! http://packages.ubuntu.com/karmic/libv4l-0
11:47:56 <sinelaw> chrisdone, deb http://ppa.launchpad.net/libv4l/ppa/ubuntu karmic main
11:48:15 <chrisdone> yeah, just doing that now
11:49:02 <sinelaw> chrisdone, the easy way
11:49:03 <sinelaw> sudo add-apt-repository ppa:libv4l
11:49:31 <chrisdone> yaay installing
11:49:42 <chrisdone> 0.6.4-1+..
11:49:47 <sinelaw> :)
11:51:53 <chrisdone> dinner's up, back in 20
11:52:49 <sinelaw> enjoy
12:01:03 <edwardk> heh, i'm amused the ParsecT that Antoinne Latter put together is in the form of a right kan extension ;)
12:01:40 <sinelaw> i'm too ignorant to be amused
12:01:47 <sinelaw> and that's amusing
12:01:53 <edwardk> sinelaw: they are a pet obsession of mine
12:01:54 <Twey> I concur
12:02:53 <sinelaw> @hoogle runMaybeT
12:02:53 <lambdabot> No results found
12:08:16 <roconnor> @quote kan
12:08:16 <lambdabot> ricky_clarkson says: I think IO should be called Kansas.
12:08:21 <roconnor> @quote khan
12:08:22 <lambdabot> No quotes match. Take a stress pill and think things over.
12:08:34 <roconnor> @quote kan
12:08:34 <lambdabot> ricky_clarkson says: I think IO should be called Kansas.
12:08:40 <roconnor> :(
12:09:07 <roconnor> @remember edwardk heh, i'm amused the ParsecT that Antoinne Latter put together is in the form of a right kan extension ;)
12:09:07 <lambdabot> Nice!
12:09:14 <roconnor> @quote kan
12:09:14 <lambdabot> edwardk says: heh, i'm amused the ParsecT that Antoinne Latter put together is in the form of a right kan extension ;)
12:09:22 <roconnor> :)
12:09:29 <edwardk> heh, maybe i should have fixed the typo in his name before i got quoted =)
12:10:22 <roconnor> @forget edwardk heh, i'm amused the ParsecT that Antoinne Latter put together is in the form of a right kan extension ;)
12:10:23 <lambdabot> Done.
12:10:58 <roconnor> @remember edwardk heh, i'm amused the ParsecT that Antoine Latter put together is in the form of a right kan extension ;)
12:10:58 <lambdabot> I will never forget.
12:11:03 <gwern> @flish
12:11:31 <edwardk> also, calling IO Kansas is probably not a good idea. we get enough hits for Haskell Kansas already. http://maps.google.com/maps/place?oe=utf-8&rls=org.mozilla:en-US:official&client=firefox-a&um=1&ie=UTF-8&q=haskell+kansas&fb=1&gl=us&ftid=0x8709ce9de2be986d:0x26493df67ead32f5&ei=0xOQS9jMNeff8AaGiuj2BA&sa=X&oi=geocode_result&ct=title&resnum=1&ved=0CAkQ8gEwAA
12:12:17 <Alpounet> some jungle name would fit much better anyway
12:12:24 <stevenmarky> what's a kan extension?
12:12:34 <edwardk> SinBin a
12:12:51 <Alpounet> stevenmarky, http://comonad.com/reader/2008/kan-extensions/
12:13:05 <edwardk> stevenmarky: its a relationship between a couple of functors, which in Hask looks like a generalized version of ContT.
12:13:19 <Alpounet> a generalized ContT ?
12:13:33 <edwardk> @src ContT
12:13:33 <lambdabot> newtype ContT r m a = ContT { runContT :: (a -> m r) -> m r }
12:13:50 <sinelaw> @flush
12:13:50 <lambdabot> Not enough privileges
12:14:05 <Alpounet> wasn't that already Codensity ?
12:14:12 <sinelaw> @quote psychobot
12:14:12 <lambdabot> psychobot says:  Cale was to be a generally optimized a lot by this bot, I wonder what to do
12:15:06 <edwardk> newtype Ran f g a = Ran { runRan :: forall r. (a -> f r) -> g r } -- ContT m r ~ Codensity (ConstT m r) Ran (ConstT m r) (ConstT m r) -- for a suitable ConstT definition
12:15:22 <edwardk> er ~ before the last 'Ran' on that line
12:15:35 <edwardk> Alpounet: yes, but Ran is a generalized Codensity ;)
12:15:52 <edwardk> there is also a left kan extension
12:16:06 <edwardk> but unfortunately haskell makes me stick an extra bottom in it. =/
12:18:56 <Alpounet> ok edwardk
12:19:00 <Alpounet> I barely understand
12:19:09 <sinelaw> heh
12:19:19 <sinelaw> that's infinitely better than me
12:19:55 <edwardk> well, lets look at it this way, take the type of Ran given above, and define an instance of fmap for it. You can do it regardless of the types f and g. They don't even have to be functors.
12:19:56 <sinelaw> Alpounet, did you manage to build the latest from git?
12:20:10 <Alpounet> hey, I said barely
12:20:18 <Alpounet> sinelaw, I still have my HSrts_debug_p linker error
12:20:28 <edwardk> Alpounet: you can just let the types guide you, its actually not bad.
12:20:28 <sinelaw> Alpounet, ghc version?
12:20:29 <Alpounet> haven't looked for what it was yet, though
12:20:32 <Alpounet> let's do that now
12:20:49 <Alpounet> edwardk, that's what I do, always !
12:20:55 <roconnor> > 3*26/4
12:20:56 <lambdabot>   19.5
12:21:01 <Alpounet> sinelaw, 6.12.1
12:21:06 <roconnor> > 3*26/4*12.5
12:21:07 <lambdabot>   243.75
12:21:09 <sinelaw> Alpounet, ok, that's a start. i'm with 6.10.4
12:21:17 <Alpounet> ow
12:21:20 <edwardk> you need a function from (a -> b) -> (forall r. ((a -> f r) -> g r)) -> (forall r. (b -> f r) -> g r)
12:21:21 <Alpounet> let's see the cabal file
12:21:32 <sinelaw> Alpounet, remove -debug from the ghc opts
12:21:39 <edwardk> but you can largely ignore the forall, and you can treat the f r as 'c' and gr as 'd' to simplify it
12:21:41 <sinelaw> ghc-options, line 37
12:21:58 <edwardk> (a -> b) -> ((a -> c) -> d) -> (b -> c) -> d
12:22:04 <edwardk> @djinn (a -> b) -> ((a -> c) -> d) -> (b -> c) -> d
12:22:05 <lambdabot> f a b c = b (\ d -> c (a d))
12:22:11 <sinelaw> it shouldn't really be there anyway
12:22:11 <edwardk> then just insert appropriate newtypes
12:22:32 <edwardk> So Ran f g is a functor.
12:22:40 <Tarrasch> Yo guys, is there anyway to write (1, 2) + (3, 4)? (should result in (4, 6))
12:22:52 <Alpounet> edwardk, ok I get it -- the types, at least.
12:22:59 <Alpounet> I see how it is a functor
12:23:08 <dschoepe> Tarrasch: \(x,y) (x',y') -> (x+x', y
12:23:10 <dschoepe> +y')
12:23:31 <sinelaw> @pl \f (a,b) (c,d)  -> (a+b,c+d)
12:23:31 <lambdabot> const (uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . flip flip (+) . (((.) . (.) . (,)) .) . (+)))
12:23:35 <edwardk> to find uses for it, its easier to try specific simplifications of the type
12:23:37 <sinelaw> Hell
12:23:48 <sinelaw> @pl \f (a,b) (c,d)  -> (a `f` b,c `f` d)
12:23:48 <edwardk> consider Ran Id
12:23:49 <lambdabot> (`ap` snd) . (. fst) . flip flip snd . ((flip . (ap .)) .) . flip flip fst . ((flip . ((.) .)) .) . (flip =<< ((flip . (((.) . (.) . (,)) .)) .))
12:23:55 <sinelaw> Frozen Hell
12:24:18 <edwardk> newtype Yoneda f a = Yoneda (forall r. (a -> r) -> f r) is isomorphic to Ran Id -- I just got rid of the Identity functor
12:24:23 <sinelaw> @type ap
12:24:24 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
12:24:45 <Alpounet> sinelaw, it's okay now.
12:24:55 <sinelaw> Alpounet, great, does it work?
12:25:03 <Alpounet> quite nice actually !
12:25:19 <Alpounet> nice teeth detection :-p
12:25:24 <sinelaw> :#
12:25:27 <Tarrasch> @pl \(a,b) (c,d)  -> (a+b,c+d)
12:25:27 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . flip flip (+) . (((.) . (.) . (,)) .) . (+))
12:25:42 <sinelaw> pl doesn't know Control.Arrow
12:25:52 <sinelaw> @type (&&&)
12:25:53 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
12:26:02 <Alpounet> it's Control.Arrow.(***)
12:26:06 <Alpounet> oh
12:26:07 <Alpounet> no
12:26:08 <edwardk> Yoneda f a is a Functor even if f isn't. and you can show that that type acts as sort of an 'fmap fusion' operator. the implementation of fmap queues them all up until you take the function you have built up and apply it to id to get an f a.
12:26:09 <sinelaw> @type (***)
12:26:10 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
12:26:16 <sinelaw> yes it is
12:26:24 <Alpounet> sinelaw, no, it's a+b, c+d
12:26:26 <Alpounet> not a+c, b+d
12:26:31 <sinelaw> ah right
12:26:49 <sinelaw> my mind is bent enough already
12:27:07 <sinelaw> @type liftA2
12:27:08 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
12:27:08 <Alpounet> edwardk, I think see how it can be used yeah
12:27:20 <edwardk> so if you do something like fromYoneda $ fmap g . fmap f $ toYoneda foo  -- it is effectively doing the fusion into the form fmap (g . f) foo for you
12:27:32 <Alpounet> not sure I'd recognize when needed, but I have a basis to go from
12:28:01 <Alpounet> edwardk, but what does the Yoneda f functor 'represent' ?
12:28:32 <edwardk> Alpounet: http://blog.sigfpe.com/2006/11/yoneda-lemma.html is a very good overview of Yoneda
12:29:01 <edwardk> Yoneda f a is isomorphic to f a -- and the justification of that is fairly deep.
12:29:52 <roconnor> I though yoneda had more objects
12:30:09 <edwardk> While isomorphic, it provides you with automatic 'fmap fusion'. wherein it accumulates all of the fmaps you do.
12:30:50 <seanmcl> I'm have a strange performance problem.  I have a large monadic computation in a program.  If I replace a subroutine (f :: Int -> Int -> m Int) with defintion f = g with f x y = do {res <- g x y ; return res }  my program runs significantly slower.  Aren't these the same program?
12:31:48 <Alpounet> edwardk, ok, I see
12:31:59 <edwardk> roconnor: Yoneda's lemma is an isomorphism as i recall.
12:32:19 <roconnor> seanmcl: they are equivealent programs *if* the monad actually follows the monad laws
12:32:27 <Alpounet> I'll read Dan's blogpost to get that
12:32:30 <edwardk> roconnor: sigfpe gives the check . uncheck = id = uncheck . check proof
12:32:51 <roconnor> I don't know if GHC will optimize under the assumption that monad laws hold.
12:32:54 <edwardk> in Hask terms
12:32:56 <seanmcl> roconnor: m is something like StateT S IO.  Does this make a difference
12:32:57 <seanmcl> ?
12:33:25 <roconnor> @undo do {res <- g x y ; return res }
12:33:25 <lambdabot> g x y >>= \ res -> return res
12:33:40 <roconnor> @src StateT (>>=)
12:33:40 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
12:33:47 <roconnor> @src (>>=) StateT
12:33:47 <lambdabot> Source not found. There are some things that I just don't know.
12:34:04 <seanmcl> @src (>>=) Monad.State.StateT
12:34:04 <lambdabot> Source not found. stty: unknown mode: doofus
12:34:14 <edwardk> Alpounet: on the other hand, Yoneda isn't the only way you can special-case Ran. Ran f f is also interesting, because while Ran f g is always a functor, Ran f f can always be a monad, as long as f has kind * -> *. No other constraints need to be placed on that type.
12:34:21 <seanmcl> @src (>>=) Control.Monad.State.StateT
12:34:21 <lambdabot> Source not found. You speak an infinite deal of nothing
12:34:50 <edwardk> Alpounet: Codensity plays the same role as ContT, but the forall keeps you from using call/CC.
12:35:21 <edwardk> Alpounet: you can view Codensity as a form of (>>=) fusion. it always right associates all of your binds.
12:35:52 <BONUS> why does the forall keep you from using callCC?
12:35:55 <BONUS> :t callCC
12:35:56 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
12:36:09 <edwardk> BONUS: try to write it ;)
12:36:27 <BONUS> haha, hmmm, sounds like fun, i'll try it
12:36:42 <roconnor>     m >>= k  = StateT $ \s -> do
12:36:43 <roconnor>         ~(a, s') <- runStateT m s
12:36:45 <roconnor>         runStateT (k a) s'
12:37:09 <edwardk> BONUS: callCC :: ((a -> Codensity f b) -> Codensity f a) -> Codensity f a turns out to have the wrong scoping on one of the implied foralls to be implementable
12:37:22 <Alpounet> edwardk, what do you mean by (>>=) fusion ?
12:37:31 <Alpounet> I got it for the fmap's but not for the (>>=)
12:37:51 <BONUS> ah, hmm. i'll try writing it and deducing exactly why
12:38:41 <troyScore> hi folks
12:38:50 <roconnor> seanmcl: using f might end up doing more tupling and untupling
12:39:05 <edwardk> Alpounet: ignoring Codensity for a minute, you can show that if you use ContT r m a -- on any monad m, all of your (>>=)'s will wind up 'associated to the right'. this is interesting because now a ContT r Writer doesn't need the Writer to have a monoid, just a binary operation with a unit.
12:39:17 <roconnor> seanmcl: in fact, the semantics of f and g might be a little difference in the presence of partiality
12:39:50 <roconnor> seanmcl: to merge the two conversations, I'd
12:39:57 <troyScore> how to parse an empty derivation in parsec?
12:39:58 <edwardk> so ContT can be applied to a number of things that don't meet the associativity condition required to be a monad, and still yields a monad
12:40:13 <roconnor> seanmcl: to merge the two conversations, I feel like I should mention adding a Condensity to the top of your transformer stack may make your code run faster.
12:40:14 <Tarrasch> can you use 'let' and make two assignments? like 'let a = 1, b = 2 in a+b'
12:40:22 <BONUS> ooh, i didnt know that regarding ContT and associativity
12:40:25 <BONUS> very neat
12:40:41 <edwardk> Alpounet: recall that one of the monad laws was (a >=> b) >=> c = a >=> (b >=> c) -- you can waive that on the things that you ContT.
12:40:46 <seanmcl> roconnor: ok thanks.  I assumed they are the same program, but clearly that's not quite right.
12:40:56 <Alpounet> edwardk, that's indeed very nice !
12:41:03 <edwardk> BONUS: it was something i figured out when i was working on my right kan extension projects
12:41:12 <roconnor> BONUS, seanmcl: http://r6.ca/blog/20071028T162529Z.html
12:42:07 <edwardk> what happens when you use ContT is that it effectively only uses the underlying >>= operation in the form foo >>= (\x -> bar >>= (\y -> ....)) it never parenthesizes the other way
12:42:20 <Alpounet> edwardk, and we get that for Codensity and Ran as well I guess
12:42:24 <edwardk> Codensity does the same thing
12:43:07 <edwardk> Ran doesn't given you a monad for free. you can say less about a right kan extension in general than you can about codensity in particular.
12:43:27 <edwardk> There are some instances of monads for various right kan extensions, but the construct isn't general.
12:43:35 <Alpounet> ok
12:43:44 <Alpounet> oh yeah I see why
12:43:45 <edwardk> there are a bunch in monad-ran for specific monads in the form of a right kan extension
12:43:50 <Alpounet> (the types help :-p)
12:43:57 <edwardk> I.e. Maybe ~ Yoneda Endo
12:44:18 <edwardk> Yoneda Endo a ~ forall r. (a -> r) -> r -> r
12:44:48 <edwardk> which you can see as just sort of looking at Maybe as a rather blindly transformed 'maybe'
12:44:50 <edwardk> @type maybe
12:44:51 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
12:44:57 <troyScore> If I have a grammer rule like A -> B | C | e (and e is the empty word) how to model this in parsec? parseA = do B <- parseB return B <|> do C <- parse C return C <|> ?
12:45:20 <edwardk> maybe j n f = f n j
12:46:17 <edwardk> it turns out that you can CPS any of the monads or monad transformers from the mtl into the form of a right kan extension.
12:46:40 <edwardk> (including a bunch of other ones, like IO, STM, ST s)
12:47:24 <BONUS> troyScore: a <- x; return a; is equal to just x
12:47:31 <BONUS> i'm not an expert on parsec but i think you could do
12:47:42 * hackagebot cpsa 2.0.0 - Symbolic cryptographic protocol analyzer  http://hackage.haskell.org/package/cpsa-2.0.0 (JohnRamsdell)
12:47:47 <BONUS> parseA = parseB <|> parseC <|> eof
12:48:06 <troyScore> BONUS... okay, thanks!!!
12:48:17 <BONUS> go get 'em!
12:48:26 <Alpounet> edwardk, ok, thank you
12:48:33 <edwardk> Alpounet: i'll stop rambling now ;)
12:48:49 <Alpounet> I definitely have to read and work a bit on these stuffs
12:48:52 <Alpounet> but thanks for the intro
12:49:00 <jmcarthur> oh noes, edwardk is talking about cool things again and now i need to read the scrollback
12:49:02 <BONUS> Yoneda Endo is isomorphic to Maybe ... that's cool too!
12:49:27 <edwardk> bonus: note that Endo cannot be an instance of Functor, but Yoneda Endo is.
12:49:37 <BONUS> wow
12:50:41 <edwardk> bonus: there are a whole bunch of those kinds of odd abuses of the form of a right kan extension in http://hackage.haskell.org/packages/archive/monad-ran/0.1.0/doc/html/src/Control-Monad-Ran.html
12:50:58 <edwardk> including the entire MTL
12:51:05 <BONUS> ooh, looks fun
12:51:43 <edwardk> be warned, i more or less just dashed it off a year or so ago, and haven't touched it since, the version of writer is a little too strict.
12:52:14 <BONUS> why is Ran m a ... a data and not a newtype though?
12:52:15 <copumpkin> edwardk: btw, what did you do with all the extra bits of monoids that you stripped off the main lib?
12:52:28 <copumpkin> BONUS: forall?
12:52:44 <edwardk> copumpkin: you can forall in a newtype.
12:52:47 <edwardk> that should be one
12:52:47 <copumpkin> ah
12:52:57 <copumpkin> oh, you couldn't if there was a constraint on it
12:53:09 <edwardk> copumpkin: they were getting factored into a monoid-extras, i just never got around to it ;)
12:53:16 <copumpkin> edwardk: ah cool
12:53:23 <edwardk> copumpkin: yeah, its the existential that is the problem
12:53:36 <copumpkin> makes sense
12:53:41 * copumpkin so sleepy
12:54:40 <BONUS> ContTing monads always yielding only right associative binds is my cool find of the day :) it makes sense when you think about the implementations for lift
12:55:12 <edwardk> BONUS: yeah, its handy when you don't know how to make a monad meet the associativity condition, just CPS it ;)
12:55:33 <copumpkin> :)
12:55:39 <edwardk> BONUS: that is also the reason why codensity can change the asymptotics of algorithms over free monads.
12:55:45 <Alpounet> nice ad for ConT : "ConT, just CPS it !"
12:55:56 <copumpkin> ContT :P
12:56:30 <Alpounet> and right under : "associative bind for free !"
12:56:40 <Alpounet> yeah, sorry, tired :(
12:56:41 <byorgey> ConT wants you to THINK it is ContT, but really it's just putting you on
12:57:07 <Alpounet> ConT would have been more handy though
12:57:14 <Alpounet> no need to wonder how many 't's you have to type in, and all
12:57:15 <byorgey> next thing you know you'll be betting large sums of money on the outcome of various programs
12:57:26 <byorgey> ContTttTT
12:57:30 <Alpounet> haha
12:58:21 <aavogt> @hoogle ConT
12:58:22 <lambdabot> Language.Haskell.TH ConT :: Name -> Type
12:58:22 <lambdabot> Language.Haskell.TH.Syntax ConT :: Name -> Type
12:58:22 <lambdabot> module Control.Monad.Cont
12:58:28 * jmcarthur wonders if CPSing Reactive's Event monad would correct its failing of the monad laws
12:58:56 * sinelaw 's mind implodes and then explodes
12:59:05 <mreh> Event is isomorphic to Maybe
12:59:12 <jmcarthur> mreh: not in Reactive
12:59:13 <mreh> in Yampa atleast
12:59:17 <jmcarthur> mreh: you are talking about Yampa
12:59:21 <jmcarthur> heh, yeah
12:59:28 <sinelaw> you mean Time -> Maybe a
12:59:38 <mreh> that's correct
12:59:39 <jmcarthur> mreh: in Reactive its semantic model is [(t, a)]
12:59:57 <jmcarthur> not a very good semantic model, but it is what it is
13:00:02 <mreh> I think Yampa is the future, once we work out how to use it :D
13:00:09 <edwardk> jmcarthur: which law does it fail?
13:00:16 <sinelaw> once we work out it's semantics precisely maybe
13:00:23 <blackh> Has someone done a non-empty list, e.g. data NonEmptyList a = NonEmptyList a (Maybe (NonEmptyList a)) ?
13:00:25 <jmcarthur> edwardk: i don't remember. i *think* it was associativity
13:00:42 <copumpkin> blackh: Cofree Maybe
13:00:43 <copumpkin> :)
13:00:44 <mreh> sinelaw: yes, there's a paper by Hudak that does a nice job of explaining parallel switching
13:00:47 <edwardk> jmcarthur: note that it might also be quite expensive, because you lose the 'memoization' property intrinsic to the list rep
13:00:54 <sinelaw> mreh, link?
13:01:03 <jmcarthur> edwardk: Event is not implemented as its semantic model
13:01:08 <sinelaw> and i mean the entire semantics from beginning to end
13:01:12 <mreh> broadcast parallel switching mind
13:01:23 <edwardk> jmcarthur: which may actually help you with memory leaks, but could affect your performance
13:01:32 <Alpounet> copumpkin, ok I don't get that one
13:01:56 <copumpkin> Cofree f a = (a, f (Cofree f a))
13:02:09 <copumpkin> Cofree Maybe a = (a, Maybe (Cofree Maybe a))
13:02:14 <Alpounet> oh forget what I said
13:02:14 <Alpounet> yeah
13:02:20 <mreh> sinelaw: look for "Switched on yampa"
13:02:32 <sinelaw> mreh, ah ok found
13:02:33 <mreh> can't find a free link
13:02:41 <copumpkin> where Cofree is an equitype :P
13:02:54 <mreh> D:
13:03:03 * mreh still doesn't get general parallel switching
13:03:12 <blackh> copumpkin: A nice cup of Cofree.  Found it in category-extras.  Perhaps I can use it.  I want something I can use Data.Foldable.foldl on.
13:04:03 <blackh> Possibly a little too general to be useful for what I want.
13:04:41 <Alpounet> but it's actually exactly equivalent to what you need
13:05:15 <sinelaw> mreh, i found
13:05:22 <sinelaw> added to zotero
13:05:28 <sinelaw> and to oblivion :(
13:05:39 <blackh> Alpounet: Except that I'd have to write my own Foldable instance.
13:05:53 <chrisdone> bimbles
13:06:08 <Alpounet> yeah
13:06:11 <sinelaw> lasagna?
13:06:14 <copumpkin> does Foldable even fit it?
13:06:23 <copumpkin> I guess it does
13:06:29 <chrisdone> hi copumpkin
13:06:41 <copumpkin> hallo
13:06:44 <blackh> Hmm.... yes, I think it probably does
13:07:25 <chrisdone> :t join . join
13:07:26 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m (m a)) -> m a
13:07:36 <sinelaw> chrisdone, so......wanna try your camera now? and my lib?
13:07:36 <chrisdone> :t flip join . join
13:07:37 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (m a) -> (m a -> m a -> b) -> b
13:07:43 <copumpkin> :t join . fmap join
13:07:45 <lambdabot> forall (m :: * -> *) a. (Monad m, Functor m) => m (m (m a)) -> m a
13:08:12 <chrisdone> sinelaw: I'm just fiddling with my macbook, practising typing
13:08:14 <chrisdone> I'll go try it now
13:08:25 <sinelaw> :D
13:08:30 <sinelaw> :O
13:08:33 <sinelaw> :|
13:09:01 <sinelaw> 8|
13:09:52 <copumpkin> > sequence [":8=", "DO|)("]
13:09:53 <lambdabot>   [":D",":O",":|",":)",":(","8D","8O","8|","8)","8(","=D","=O","=|","=)","=("]
13:10:16 <blackh> Alpounet, copumpkin: Cothanks!
13:10:48 <Alpounet> Foldable instance written ? :)
13:11:44 <chrisdone_> > sequence ["^oO0.~/","_-","^oO0.~/"]
13:11:45 <sinelaw> copumpkin, the mood machine
13:11:45 <lambdabot>   ["^_^","^_o","^_O","^_0","^_.","^_~","^_/","^-^","^-o","^-O","^-0","^-.","^...
13:12:15 <sinelaw> chrisdone, the schizophrenia machine
13:12:19 <chrisdone_> <_<
13:12:27 * Alpounet wonders what ^_. could represent
13:12:59 <sinelaw> ah, i've brought the discussion to my level! whew left smiley extensions
13:13:14 <sinelaw> in the category of nonsense
13:15:15 <Axman6> > map text . sequence $ ["^oO0.~/","_-","^oO0.~/"]
13:15:16 <lambdabot>   [^_^,^_o,^_O,^_0,^_.,^_~,^_/,^-^,^-o,^-O,^-0,^-.,^-~,^-/,o_^,o_o,o_O,o_0,o_...
13:16:43 <MadHatterDude> @hoogle <=<
13:16:44 <lambdabot> Control.Monad (<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c
13:18:23 <seanmcl> roconner: interesting blog post.  Did you ever figure out what was responsible for the huge speedup?  Was it just  boxing/unboxing of state?
13:18:54 <pchiusano> edwardk: hey you around, question for you about generators
13:19:22 <pchiusano> I'm wondering why you needed an Elem type
13:22:18 <pchiusano> nevermind i think we answered our own question
13:22:39 <copumpkin> is that the royal we? :)
13:22:39 <chrisdone_> sinelaw: right, I got this slimed up babe to compile, got a sample app?
13:22:50 <MadHatterDude> > do files <- getArgs; map (fmap reverse . readFile >=> putStr) files; return ()
13:22:51 <lambdabot>   Not in scope: `getArgs'
13:22:52 <pchiusano> can have generators for higher-kinded and non-higher kinded types this way
13:23:11 <pchiusano> copumpkin: heh, no, I am sitting here with a coworker
13:23:11 <chrisdone_> sinelaw: wait found this test-hopencv
13:23:24 <sinelaw> :) i hope you pulled latest first
13:23:33 <chrisdone_> I pulled from github
13:23:40 <MadHatterDude> Wah...  the ">=>" in "map (fmap f . readFile >=> putStr) files" is giving me unexplainable compile errors!
13:23:45 <chrisdone_> chris@chrisamilo:~/Haskell/HOpenCV$ test-hopencv
13:23:45 <chrisdone_> libv4l2: error turning on stream: Input/output error
13:23:45 <chrisdone_> VIDIOC_STREAMON error 5, Input/output error
13:23:51 <chrisdone_> curses and vile demons!
13:23:59 <Axman6> MadHatterDude: map isn;t what you want there, i can almost guarantee it
13:24:38 <sinelaw> chrisdone_, ok so it works?
13:24:53 <MadHatterDude> Axman6: It's not map that causes trouble, quoth ghc: "parse error on input `>=>'"
13:25:15 <Axman6> sure, but i'm pretty sure you don't want map there nonetheless :)
13:25:27 <copumpkin> maybe he wants to sequence it later :)
13:25:32 <danderson> so, how does managing I/O over multiple connections simultaneously work with network/network-bytestring?
13:25:33 <MadHatterDude> Axman6: Advice taken.
13:25:34 <chrisdone_> sinelaw: it works. on the other hand, it fails to work at all!
13:25:42 <chrisdone_> sinelaw: what should it do?
13:25:51 <Axman6> MadHatterDude: you'll end up with something of type [IO ()]
13:25:52 <sinelaw> chrisdone, ???
13:25:55 <chrisdone_> I'm kind of in a rush
13:26:02 <danderson> since the package doesn't provide for select-like functionality, my next guess would be to fire off a thread to handle each connection
13:26:04 <sinelaw> chrisdone_, ok
13:26:07 <MadHatterDude> Axman6: But I still can't figgure out why ghc refuses to lex '>=>'
13:26:09 <chrisdone_> I'll check it out properly on the weekend
13:26:13 <danderson> and rely on haskell's great threading properties
13:26:15 <sinelaw> no problem take your time
13:26:22 <danderson> is that how it's supposed to happen?
13:26:30 <tangerine> hi, is there any tool for uml for haskell?
13:26:41 <Cale> danderson: yes
13:26:52 <Cale> danderson: You let the GHC RTS handle doing the selects
13:27:07 <Alpounet> danderson, you may want to take a look at tibbe and bos' IO manager though
13:27:14 <Alpounet> (hosted on tibbe's github iirc)
13:27:20 <Cale> danderson: They're working on replacing the use of select with epoll/kqueue, so that'll just magically get faster soon enough too ;)
13:27:35 <MadHatterDude> what. the. hell.
13:27:43 <uorygl> Does Haskell have bindings for Unix domain sockets?
13:27:47 <danderson> Alpounet: I've been following that, as well as tibbe's network-bytestring and attoparsec for efficient stream parsing
13:27:53 <Cale> MadHatterDude: huh?
13:28:04 <sinelaw> @hoogle IO ()
13:28:04 <lambdabot> Network.BSD endHostEntry :: IO ()
13:28:05 <lambdabot> Network.BSD endNetworkEntry :: IO ()
13:28:05 <lambdabot> Network.BSD endProtocolEntry :: IO ()
13:28:05 <danderson> Cale: thanks. It seemed like the thing to do, just wanted a sanity check.
13:28:07 <Alpounet> danderson, it should be integrated soon in GHC.
13:28:19 <danderson> So, thread-per-connection and STM it is!
13:28:28 <MadHatterDude> Cale: "x = readFile >=> putStr" gives a "parse error on input '>=>'"
13:28:39 <uorygl> > (>=>)
13:28:40 <lambdabot>   No instances for (Test.SmallCheck.Serial (m b),
13:28:40 <lambdabot>                    GHC.Show...
13:28:42 <Cale> MadHatterDude: Where are you writing that?
13:28:59 <sinelaw> @hoogle do return ()
13:28:59 <lambdabot> Language.Haskell.ParseMonad lexNewline :: Lex a ()
13:28:59 <lambdabot> Language.Haskell.ParseMonad lexTab :: Lex a ()
13:28:59 <lambdabot> Language.Haskell.ParseMonad setBOL :: Lex a ()
13:29:02 <MadHatterDude> Cale: In a file
13:29:04 <sinelaw> @pl do return ()
13:29:04 <lambdabot> do return ()
13:29:18 <benmachine> @undo do return ()
13:29:18 <lambdabot> return ()
13:29:24 <MadHatterDude> Cale: defining a funtion called 'x'
13:29:24 <benmachine> @undo do do do do do do do return ()
13:29:25 <lambdabot> return ()
13:29:37 <Cale> works for me
13:29:44 <Cale> foo.hs:
13:29:47 <Cale> import Control.Monad
13:29:47 <Cale> x = readFile >=> putStr
13:29:55 <Cale> [1 of 1] Compiling Main             ( foo.hs, interpreted )
13:29:55 <Cale> Ok, modules loaded: Main.
13:29:58 <MadHatterDude> Cale: Yeah, it works in GHCi too...
13:30:28 <Alpounet> MadHatterDude, Cale is loading the code from a file (foo.hs) here
13:30:31 <Cale> How do you get a parse error?
13:30:36 <MadHatterDude> Aaaand now it suddenly woks.
13:30:39 <benmachine> heh
13:30:39 <Cale> hehe
13:30:46 <MadHatterDude> Forgot a pair of parentheses
13:30:53 <MadHatterDude> >.>
13:31:10 <uorygl> Ah, you forgot the parentheses around "foo.hs, interpreted".  :P
13:33:07 <birdspider> um, help :)  http://pastebin.com/rQ1eRZw6
13:33:07 <Younder> hi all
13:33:36 <sinelaw> Bye
13:33:47 <ivanm> birdspider: #arch-haskell maybe ...
13:33:58 <ivanm> because it looks like a packaging problem
13:34:01 <birdspider> ivanm, will try, thx
13:35:16 <Cale> birdspider: Did you try what the message suggested?
13:35:23 <Younder> How far along is paralell procesing in GHC?
13:35:32 <ivanm> Younder: see the dph project
13:35:37 <Cale> oh, I see, yes you did
13:35:48 <ivanm> @where dph
13:35:48 <lambdabot> http://haskell.org/haskellwiki/GHC/Data_Parallel_Haskell
13:35:57 <Cale> Oh, strange, looks like something strange is going on with the syb package.
13:36:12 <Cale> hmmmm
13:36:27 <ivanm> two versions installed? *shrug*
13:36:31 <Cale> birdspider: You might go so far as to look inside that .conf file and make sure it's encoded properly
13:36:45 <Cale> It sounds like ghc-pkg is having a problem reading it as UTF-8
13:36:58 <birdspider> I had yaourt previously so it may be messed up
13:37:00 <Cale> But what a strange problem :)
13:37:00 <uorygl> Please don't use the word "parallel" in this channel.  It reminds me of a certain simulation computer game, composed of hundreds of greatly independent objects, that was only capable of using one CPU.  :P
13:37:15 <Cale> uorygl: heh, what?
13:37:23 <ivanm> uorygl:
13:37:27 <ivanm> > cycle "parallel "
13:37:28 <lambdabot>   "parallel parallel parallel parallel parallel parallel parallel parallel pa...
13:37:33 <ivanm> ;-)
13:37:35 <Cale> uorygl: That might make it concurrent, but not parallel ;)
13:37:40 <MadHatterDude> Aaargh!
13:37:54 <uorygl> I seem to have forgotten the difference between concurrent and parallel.
13:38:15 <MadHatterDude> uorygl: parralell is multicore
13:38:24 <ivanm> uorygl: concurrent is heaps of different tasks running together on the same CPU; parallel is splitting up one big task to do across different CPUs/cores
13:38:36 <ivanm> MadHatterDude: not necessarily.... clusters ftw!
13:38:47 <MadHatterDude> uorygl: concurrent is just scheduling instructions
13:38:58 <uorygl> Much of this game's CPU time was taken up by creatures' path-finding algorithms, which were completely independent of each other.  And it used only one CPU core.
13:39:03 <Younder> I have 296 core cray
13:39:24 <ivanm> Younder: you personnaly?
13:39:28 <MadHatterDude> Younder: Ouch
13:39:28 <ivanm> or you have access to one?
13:39:29 <Younder> with 1 Tb ram
13:39:41 <Younder> and a 20 Tb drive
13:39:43 <birdspider> Cale, first the conf file is iso-8859-1, second I have 3 versions of ghc in my /usr/lib
13:39:46 * p_l once had seen a Cray for sale on eBay
13:39:49 <Younder> ivanm, yes
13:40:05 <jlouis> concurrent programming is specifying which tasks that can run in parallel. Parallel programming is actually running them like so
13:40:09 <copumpkin> Younder: can you lend it to me?
13:40:15 <ivanm> Younder: you personally own a cray? :o
13:40:16 <Younder> lol
13:40:28 <Younder> ivanm, a CX1
13:40:31 <uorygl> Is it okay if I use one of the cores to play this game?  It's not like it needs the other ones.  :P
13:40:44 <Younder> ivanm, a BIG one
13:40:45 <ivanm> oh, a really old one...
13:40:50 <copumpkin> not an old one
13:40:54 <copumpkin> http://en.wikipedia.org/wiki/Cray_CX1
13:40:57 <copumpkin> "Entry level"
13:41:03 <ivanm> ahhh
13:41:16 <ivanm> Younder: well, you answered "yes" without specifying which question you were answering ;-)
13:41:23 <Cale> A nice analogy is a fast food restaurant. Concurrency is about having multiple customer queues, even if you only have one guy behind the counter serving them. Parallelism is about putting more people to work behind the counter, so that even if you only have one customer at a time, it goes faster.
13:41:52 <ivanm> Cale: nah, parallelism is building a second takeaway next door! :p
13:42:09 <uorygl> I like the idea of having multiple queues for a single guy behind the counter.
13:42:20 <copumpkin> you can also achieve parallelism without concurrency
13:42:28 <pettter> Cale: uh, if you only have one customer at a time, parallellism won't make it go faster
13:42:35 <birdspider> Cale, correcting I do have 3 ghc dirs in /usr/lib but 2 are virtually empty; any idea on the encoding ? should I just trancode ?
13:42:36 <Cale> It means that the people don't have to wait as long to be served, even though they'll be served more slowly
13:42:45 <Cale> Not a perfect analogy, but it sort of works :)
13:42:48 <kw317> copumpkin: had a lecture about CX1 today ;-)
13:42:55 <Cale> birdspider: You might try that.
13:42:55 <MadHatterDude> Haskell does not like me tonight.
13:42:58 <copumpkin> talk to Younder about that
13:43:00 <ivanm> pettter: one customer per server
13:43:16 <Younder> ivanm, ok 24 blades. 2 xenon's 6 core per blade. 35 GB external sorage unit.
13:43:23 <kw317> I'm trying to install criterion, but I get some dependencies errors: There is no available version of cairo that satisfies >=0.9.11
13:43:25 * ivanm drools
13:43:27 <pettter> ivanm: well, in that case, yes
13:43:27 <Cale> pettter: Sure it would. You can have one person making fries and another person making a burger.
13:43:32 <ivanm> kw317: you need to install gtk2hs
13:43:46 <ivanm> it isn't cabalised and hence isn't on hackage so cabal-install can't pull it in
13:43:54 <kw317> ah.. hmm
13:43:55 <Cale> pettter: so that even though the resulting food is the same, the work goes faster
13:43:58 <ivanm> Cale: you said behind the counter; I assumed you meant serving
13:44:02 <Younder> ivanm, oh an 48 tesla gpGPU's
13:44:10 <ivanm> Younder: stop showing off!
13:44:17 <copumpkin> Younder: you use this to browse the net and read email, I assume
13:44:30 * ivanm should probably stop talking on IRC and finish getting ready to go to uni
13:44:34 <pettter> Cale: but that is possible even without parallellism, that's pipelining, rather
13:44:35 <ivanm> copumpkin: heh
13:44:39 <copumpkin> ivanm: heh
13:44:39 <kw317> ivanm: thanks
13:44:41 <Younder> I am not using my srver for this no
13:44:46 <ivanm> kw317: no worries
13:44:49 <kw317> ivanm: getting ready? where are you?
13:45:00 <ivanm> kw317: do a /whois on me and guess!
13:45:03 <pettter> but anyways, no need to slaughter a random analogy just because :)
13:45:13 <ivanm> copumpkin: is that your latest trick? reflecting my heh's back to me?
13:45:18 <Cale> pettter: It's not pipelining when the guy who makes the burger doesn't care about whether the fries are done :)
13:45:18 <copumpkin> yep
13:45:27 <birdspider> Cale, it seems to work, at least recache works, thx a lot
13:45:34 <kw317> ivanm: sounds like work ;-)
13:45:42 <Younder> I am most proud of my new 2 000 000 unit
13:46:08 <ivanm> kw317: heh
13:46:25 <Younder> 200 000 $ about
13:46:31 * ivanm fires a spell of remove shield at copumpkin 
13:46:35 <copumpkin> :O
13:46:46 <copumpkin> Younder: what do you do with it then?
13:47:13 <Younder> copumpkin, data mining
13:47:19 <copumpkin> Younder: of what? :o
13:47:34 <Younder> copumpkin, for my gowenment
13:47:39 <copumpkin> ooh ok
13:47:51 <uorygl> I have a 2-megacore CPU.  Each core receives one bit of information from each of the eight surrounding cores, counts the number of 1s, looks this number and its current state up in a lookup table, and outputs and stores the result, every clock cycle.
13:48:40 <Cale> uorygl: FPGA?
13:49:00 <BONUS> if you're on a 64-bit machine, minBound for Int in GHC is -2^63 right? and maxBound 2^63-1
13:49:17 <McManiaC> <interactive>: warning: too many hs_exit()s
13:49:21 <uorygl> I'm joking, unfortunately.
13:49:23 <McManiaC> is this something from ghci?
13:49:30 <tromp_> > minBound::Int64
13:49:31 <lambdabot>   -9223372036854775808
13:49:44 <tromp_> > 2^63
13:49:45 <lambdabot>   9223372036854775808
13:49:53 <Cale> McManiaC: That sounds like a bug if you just got it from GHCi
13:49:54 <uorygl> Conway's CPU of Life would be fun, though.
13:50:08 <Cale> McManiaC: hs_exit is part of the C-side of the FFI
13:50:22 <Cale> McManiaC: along with hs_init to start up the Haskell runtime
13:51:02 <McManiaC> <interactive>: <<loop>>
13:51:07 <McManiaC> this is what I get before it
13:51:14 <McManiaC> and yeh, I'm working with the FFI
13:51:25 <Cale> <<loop>> usually is a bug in your own program
13:51:42 <Zao> Thunk re-entry, or something awesome like that, isn't it?
13:51:47 <Cale> Caused by trying to use a value which you are currently trying to compute, which is a detectable infinite loop
13:52:08 <McManiaC> okay
13:52:09 <Younder> so far I have been stuck with OpenML and RMI
13:52:31 <Younder> and that good awull lang they cal C
13:52:35 <Younder> call
13:53:13 <Younder> whatever
13:54:06 <Cale> Heh, I figure at some point the CPU usage monitors are going to use a single pixel per CPU, and indicate usage with brightness.
13:54:16 <Younder> God knows why I was chosen for it. I can't spell for shit.
13:55:12 <Younder> Cale, this is my home PC
13:55:31 <chrisdone_> Cale: that sounds awesome
13:56:23 <monadic_kid> can anyone think of a clean way to do what I'm doing in the code next to the comment (line 28): http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23229#a23229
13:56:25 <Younder> snort should keep you out though
14:01:54 <copumpkin> @hackage agda
14:01:54 <lambdabot> http://hackage.haskell.org/package/agda
14:02:18 <copumpkin> gah, case sensitivity where it doesn't belong
14:03:33 <Twey> Case-sensitivity belongs everywhere
14:04:00 <edwardk> monadic_kid: given the combinators you have that is probably your best bet. you could probably put together a better modify combinator that returned two results, the new value and the answer
14:04:03 <BONUS> preflex: seen mmorrow
14:04:03 <preflex>  mmorrow was last seen on #ghc 45 days, 19 hours, 6 minutes and 18 seconds ago, saying: * mmorrow is rtfm'ing
14:04:05 <BONUS> :(
14:04:08 <copumpkin> so you like that we have a numbers package and a Numbers package?
14:04:14 <copumpkin> and that they're completely unrelated?
14:04:54 <Twey> I don't like it, but I don't consider case-sensitivity the answer
14:04:58 <edwardk> copumpkin: ick
14:05:03 <Twey> numbers and numberz would be just as bad
14:05:11 <edwardk> copumpkin: how does cabal work on windows when you go to install both?
14:05:12 <copumpkin> no
14:05:21 <copumpkin> humans don't consider S and s to be different letters
14:05:26 <monadic_kid> edwardk: you mean modifyRGenM that doesn't return an empty tuple a returns the result of the computation
14:05:42 <Twey> copumpkin: Well, that's language-dependent
14:05:57 <copumpkin> irrelevant here :P
14:06:04 <medfly> WHAT DO YOU MEAN
14:06:09 <Twey> No it isn't  Hackage is international
14:06:12 <Younder> tr [A-Z] [a-z]
14:06:18 <edwardk> modify' f = do x <- get; let (x',r) = f x; put x'; return r
14:06:20 <Younder> lol
14:06:26 <edwardk> or something like that
14:06:41 <copumpkin> Twey: the languages I know either don't have case or don't consider different cases to be different letters. Ergo it doesn't matter
14:06:48 <Twey> Younder: And what do you do about  vs. ?
14:06:52 <copumpkin> (as I'm the center of the universe)
14:06:56 <Twey> copumpkin: Haha
14:07:03 <Younder> Twey, unicode?
14:07:09 <Zao> Twey: Lets not forget the turkish Is.
14:07:12 <Twey> Younder:  yeees
14:07:18 <Zao> Und .
14:07:23 <Twey> Aye
14:07:28 <Twey> It's not a solved problem, basically.
14:07:32 <edwardk> case conversion is unfortunately locale specific.
14:07:39 <Younder> No it isn't
14:07:45 <Twey> Yes it is.
14:07:56 <Twey> Is the lower-case of   or ?
14:08:13 <Zao> Depends on the side you cock your head to.
14:08:15 <Younder> godamn headache of all my developers
14:08:35 <copumpkin> Zao: you calling me a dickhead?
14:08:41 <mauke> what's the lower case of "SS"?
14:08:44 <Twey> Haha
14:08:52 <Younder> rotfl
14:09:22 <ehamberg> , probably.  is used in icelandic for the th sound in english.
14:09:32 <danderson> hmm
14:09:35 <Younder> 
14:09:37 <Twey> ehamberg: *A* th sound
14:09:45 <Younder> norglish
14:09:45 <Zao> copumpkin: The lowercase of 'LATIN CAPITAL LETTER SHARP S' (U+1E9E), obviously.
14:09:48 <danderson> can't decide if a thread/STM network server is terribly confusing or completely awesome
14:09:55 <ehamberg> Twey: i stand corrected. :)
14:09:55 <Zao> danderson: All of the above.
14:10:05 <Twey> ehamberg: But, more to the point, the upper-case of  in Icelandic is 
14:10:10 <edwardk> mauke eszett obviously, though that is clearer if you use http://en.wikipedia.org/wiki/Capital_%C3%9F
14:10:16 <Twey> ehamberg: And the upper-case of  in Vietnamese is 
14:10:24 <Zao> @type toupper
14:10:24 <ehamberg> i give up. :)
14:10:25 <lambdabot> Not in scope: `toupper'
14:10:31 <danderson> Zao: quite possibly
14:10:32 <Zao> @type toUpper
14:10:33 <lambdabot> Char -> Char
14:10:38 <Younder> I give up too
14:10:42 <Twey> > toUpper ''
14:10:43 <lambdabot>   '\272'
14:10:46 <Twey> > text $ toUpper ''
14:10:48 <lambdabot>   Couldn't match expected type `GHC.Base.String'
14:10:48 <lambdabot>         against inferred typ...
14:10:51 <Zao> I see some trouble with eszett and the different roundtrips there :)
14:10:52 <Twey> Oops
14:10:55 <Twey> > text . return $ toUpper ''
14:10:56 <lambdabot>   
14:10:58 <edwardk> and then of course there is the difference between capital and titlecase
14:11:00 <mauke> consider a word like "MASSE"
14:11:00 <Twey> > text . return $ toUpper ''
14:11:01 <lambdabot>   
14:11:07 <Younder> YES
14:11:13 <Twey> > toUpper '' == toUpper ''
14:11:14 <lambdabot>   False
14:11:15 <maltem> edwardk, Zao, downcasing SS to either of  or ss is not decidable without having a careful look at the text (Mae vs. Masse)
14:11:21 <Twey> Oh, close :
14:11:21 <Younder> GHC reconises UNICODE
14:11:35 <Younder> NOW SHUT UP
14:11:36 <copumpkin> preflex: seen ezyang
14:11:36 <preflex>  ezyang was last seen on #haskell 1 day, 3 hours, 45 minutes and 31 seconds ago, saying: unfortunately, they rarely are computable >.>
14:11:38 <edwardk> maltem: i'm well aware that its a horrible mess
14:11:59 <copumpkin> @ask ezyang do you have the power to organize events at MIT? :O
14:12:00 <lambdabot> Consider it noted.
14:12:13 <maltem> I actually consider this a dumbness of German capitalizing conventions, you could just as well use  in a capitalized word.
14:12:18 <edwardk> younder: just because code recognizes a larger range of characters doesn't automatically make applications written in it fully cognizant of what is or isn't a sensible action to take on unicode text.
14:12:37 <Alpounet> copumpkin, iirc, there has been at least one Boston HUG meeting at MIT
14:12:55 <copumpkin> Alpounet: I've been to a couple of them myself :) but the organizer has disappeared
14:13:05 <edwardk> Alpounet: most of them actually, the problem is we haven't talked to the old organizer in a while
14:13:34 <Twey> Interestingly, toUpper '' () and toUpper '' () are actually different characters (U+00D0 LATIN CAPITAL LETTER ETH and U+0110 LATIN CAPITAL LETTER D WITH STROKE)
14:13:36 <edwardk> Alpounet: so we need to figure out some arrangement with the hosting facility so we can keep running them
14:13:49 <dobie_gillis> how do i automatically re-indent a bunch of haskell files using emacs-haskell-mode? right now the files all contain tabs
14:13:59 <Twey> But I'm pretty sure we can all agree that ang/ang is a worse distinction to make than numbers/Numbers :
14:14:00 <Alpounet> oh ok
14:14:13 <edwardk> sadly, locale-specific sorting is almost as bad as changing case ;)
14:14:17 <Zao> Open in vim, set tabstop and shiftwidth, set expandtab, :retab, :wq :P
14:14:47 <dobie_gillis> Zao: yea guess i'll have to do that :S
14:14:48 <Twey> C-a C-M-\ C-s
14:14:49 <Twey> >.>
14:14:51 <Younder> uniccode is a headache
14:15:06 <Twey> Younder: Internationalisation is a headache
14:15:08 <Younder> never fully onderstood it myself
14:15:27 <Zao> Whenever I imagine an Emacs user, I envision a pianist striking chords producing elegant works of art.
14:15:34 <Twey> Unicode has its sharp corners, but it's pretty nice to use on the whole
14:15:34 <edwardk> Twey: my answer, iirc,  is to check to see if an nfkc normalization of two strings match iff an nfc normalization of the two strings match, otherwise i complain that you're doing something stupid in the source file.
14:15:37 <maltem> now we just need a double-S unicode character
14:15:49 <mauke> :set ts=4 sw=4 et | retab! | x
14:15:58 <Zao> Whereas a vim user is more like a death metal drummer, relying on dizzying serial commands.
14:16:11 <Zao> maltem: http://www.fileformat.info/info/unicode/char/1e9e/index.htm
14:16:18 <Zao> maltem: There's two, pick one.
14:16:20 <Younder> hey, I love wim
14:16:22 <Twey> Zao: Haha, nice
14:16:32 <ehamberg> no need for the ! when goint from noet to et.
14:16:35 <ehamberg> going
14:16:49 <edwardk> zao: my justification for choosing between the two comes down to the crippling ailment that is emacs pinky ;)
14:16:57 <Younder> but I mostly  use emacs
14:16:59 <maltem> Zao, oha, even more fancy
14:17:01 <Twey> edwardk: ergoemacs :
14:17:12 <mauke> ehamberg: meh, I always use !
14:17:23 <ehamberg> hardcore 8-)
14:17:28 <Twey> Haha
14:17:33 <Younder> figured out how to use
14:17:33 <Zao> edwardk: I'm especially touched by the emacs pinky, as I tend to bend my pinky and press Ctrl with my nail/joint.
14:17:36 <edwardk> twey: shapr uses some goofy ergonomic keyboard, dvorak, shuffles his key layout. but i can just grab anyone's keyboard and start typing ;)
14:17:50 <lament> Richard Stallman had very big hands
14:17:57 <Younder> whacamacallit
14:17:58 <Heffalump> what happened to them?
14:18:06 <shapr> kinesis contoured keyboard, with a heavily modified dvorak layout
14:18:25 <edwardk> thats it
14:18:40 <edwardk> it also takes him like 2 months to finally get linux configured properly on a box for himself ;)
14:18:46 <Twey> Heffalump: emacs did :
14:18:46 <Younder> mule
14:18:59 <Twey> edwardk: Yet you use Haskell :
14:19:18 <Twey> shapr: Heavily modified how?
14:19:21 <edwardk> Twey: cabal-install saved me. i would have left for greener pastures had it not come along.
14:19:30 <Younder> also comon lisp, Perl, C, Assembler, ...
14:19:35 <Twey> edwardk: To Java?  :
14:19:38 <Heffalump> edwardk: like what?
14:19:47 <Younder> I hate Java
14:20:13 <Younder> Not thatI don't use it
14:20:28 <jmcarthur> edwardk: anyone's but shapr's apparently
14:20:48 <Younder> I accept monoand C#
14:20:55 <Twey> Zao: Seriously, I recommend ergoemacs.  Big help.  I mimic it in everything.
14:21:22 <jmcarthur> edwardk: the first time i met shapr he ragged on you about your workspace, too :P
14:21:32 <Twey> Feels weird to start with, but you soon get used to it.
14:21:52 <Younder> oddly c# is vastly better than java, enen on unix
14:22:05 <copumpkin> what about edwardk's workspace?
14:22:20 <jmcarthur> copumpkin: something about windows or something. i honestly don't remember
14:22:32 <jmcarthur> copumpkin: maybe something like various screens of different sizes, too
14:22:38 <copumpkin> :O
14:22:46 <jmcarthur> CRT maybe
14:22:50 <Younder> try mono
14:23:41 <MadHatterDude> How would I go about making a function that does [Just String] -> Just String
14:23:59 <mauke> that depends on what it's supposed to  do
14:24:03 <jmcarthur> MadHatterDude: returns the first element that's not Nothing?
14:24:11 <jmcarthur> MadHatterDude: or concatenates the strings?
14:24:11 <MadHatterDude> mauke: use ++ on the strings
14:24:16 <jmcarthur> ah
14:24:18 <jmcarthur> fold
14:24:24 <jmcarthur> :)
14:24:29 <mauke> MadHatterDude: wait, what is a Just String?
14:24:37 <jmcarthur> Maybe String?
14:24:47 <mauke> then why not return a String?
14:24:53 <jmcarthur> > fold [Nothing, Just "foo", Just "bar"]
14:24:54 <lambdabot>   Not in scope: `fold'
14:24:57 <Heffalump> assuming you mean Maybe String, under what circumstances would you return Nothing?
14:25:02 <Younder> You fucked up the spec.
14:25:02 <jmcarthur> > Data.Foldable.fold [Nothing, Just "foo", Just "bar"]
14:25:03 <dschoepe> :t concat . catMaybes
14:25:04 <lambdabot>   Just "foobar"
14:25:04 <lambdabot> forall a. [Maybe [a]] -> [a]
14:25:12 <MadHatterDude> Jmcarthur, mauke: yeah, Just string is Maybe String, but there are only justs
14:25:21 <mauke> <mauke> then why not return a String?
14:25:27 <Heffalump> Just . concat . map fromJust
14:25:34 <Heffalump> not that it's a good idea
14:25:39 <jmcarthur> fold does exactly what you want
14:26:01 <copumpkin> Heffalump's solution is the best one
14:26:15 <mauke> I disagree
14:26:17 <Heffalump> Just . concat . catMaybes is better IMO. But
14:26:25 <copumpkin> you can optimize it to unsafeCoerce
14:26:26 <Heffalump> map fromJust is more explicit about everything being Just
14:26:49 <MadHatterDude> My initial idea was to use <*>
14:27:14 * hackagebot wai 0.0.0 - Web Application Interface.  http://hackage.haskell.org/package/wai-0.0.0 (MichaelSnoyman)
14:27:16 * hackagebot web-encodings 0.2.4 - Encapsulate multiple web encoding in a single package.  http://hackage.haskell.org/package/web-encodings-0.2.4 (MichaelSnoyman)
14:27:18 * hackagebot wai-extra 0.0.0 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-0.0.0 (MichaelSnoyman)
14:27:34 <MadHatterDude> like making a pointfree version of (\x y -> fmap (++) x <*> y) and foldr with it
14:27:46 <copumpkin> liftMa2 (++) ?
14:27:50 <copumpkin> liftA2, even
14:28:25 <MadHatterDude> @hoogle liftMa2
14:28:26 <lambdabot> No results found
14:28:44 <mauke> you are now failing manually
14:29:56 <Zao> Twey: Had I've been an emacs user, sure.
14:30:54 <Alpounet> 0.0.0, very nice for getting people to use it
14:36:44 <meanburrito920_> Hey, anyone know if there is a proposal list for Google Summer of Code 2010 going around? I looked at the haskell_proposals subreddit, but that's mainly old stuff.
14:37:02 <monadic_kid> nearly finished all 35 lessons: http://github.com/snkkid/LazyFooHaskell
14:38:32 <meanburrito920_> monadic_kid: oooh nice :)
14:38:43 <meanburrito920_> i havent seen those before
14:38:44 <jmcarthur> meanburrito920_: old doesn't mean outdated
14:39:23 <lament> get off my lawn!
14:39:36 <meanburrito920_> jmcarthur: very true. Still, I would assume there are some fresh ideas floating around.
14:39:51 <jmcarthur> meanburrito920_: what are you interested in?
14:41:27 <jmcarthur> meanburrito920_: if i'm to push something, i really want constraint families in ghc :)
14:42:37 <meanburrito920_> jmcarthur: I was originally thinking i would work with ghc, but after browsing through the source I got a bit scared off, seeing as how everyone that works on ghc has been born and raised on category theory
14:43:27 <copumpkin> meanburrito920_: not true at all
14:43:43 <jmcarthur> meanburrito920_: nah, category theory doesn't really play a big role in GHC afaik ;)
14:43:44 <meanburrito920_> yeah, i know. but still, it does seem a bit intimidating.
14:43:54 <jmcarthur> meanburrito920_: i agree on the intimidating part
14:44:06 <jmcarthur> but it's probably not as hard to get into as it appears
14:44:21 <meanburrito920_> yeah. I think I'm gonna read up on darcs first though
14:44:33 <jmcarthur> <3 darcs
14:44:33 <meanburrito920_> it was really slow fetching from the server
14:44:42 <meanburrito920_> idk. I'm a fan of git
14:44:52 <copumpkin> you aren't supposed to fetch it from scratch :P
14:44:54 <meanburrito920_> I might be convinced though
14:44:59 <copumpkin> (but I agree, it's a pain)
14:44:59 <meanburrito920_> copumpkin: right, i didnt
14:45:04 <jmcarthur> copumpkin: true, but i consider that a failing of darcs anyway
14:45:12 <copumpkin> yeah, definitely
14:45:15 <jmcarthur> copumpkin: darcs should give you a tarball in the first place
14:45:34 <meanburrito920_> gotta go, cya guys later
14:46:10 <ivanm> greetings TacticalGrace
14:46:28 <TacticalGrace> hey ivanm
14:50:31 <brooksbp> help!!!
14:50:59 <brooksbp> Say I have, let s' = myfun a1 s
14:51:20 <danderson> So, I have code that worked with the old exception system and is now broken, and I can't figure out how to fix it
14:51:39 <brooksbp> How do I compute: (myfun a2 s'1) union (myfun a2 s'2) union .... (myfun a2 s'n) where s' = s'1, s'2... s'n
14:51:58 <danderson> where act :: IO () and mainThread :: ThreadId, act `catch` throwTo mainThread
14:52:12 <danderson> So, I have code that worked with the old exception system and is now broken, and I can't figure out how to fix it`Exception e' arising from a use of `throwTo' at Main.hs:32:25-39
14:52:16 <jmcarthur> brooksbp: you mean s' = [s'1, s'2, s'3, ..., s'n] ?
14:52:19 <danderson> gah, stupid scrollback
14:52:30 <brooksbp> jmcarthur: yes
14:52:34 <danderson> "Ambiguous type variable `e' in the constraint: `Exception e' arising from a use of `throwTo' at Main.hs:32:25-39"
14:52:56 <jmcarthur> brooksbp: foldMap (myFun a2) s', assuming that union forms a Monoid
14:52:58 <danderson> and I'm not really sure how to go about fixing this such that the catch generically propagates all exceptions.
14:53:32 <Alpounet> brooksbp, same problem in haskell and ocaml ? :p
14:53:44 <jmcarthur> foldMap is in Data.Foldable
14:54:06 <brooksbp> Alpounet: yes, because Set.iter in OCaml returns nil... that solution doesn't work
14:54:25 <jmcarthur> brooksbp: ah, yeah, if you are talking about Set's union then my solution will work
14:54:57 <brooksbp> jmcarthur: So why isn't there a Set.map ? that's exactly what I need
14:54:58 <danderson> aha, got it.
14:55:02 <danderson> if anyone cares:
14:55:09 <jmcarthur> brooksbp: i think there is one...
14:55:14 <jmcarthur> :t Data.Set.map
14:55:15 <lambdabot> forall a b. (Ord a, Ord b) => (a -> b) -> S.Set a -> S.Set b
14:55:16 <danderson> let backToMain (SomeException e) = throwTo mainTID e
14:55:22 <danderson> act `catch` backToMain
14:55:47 <copumpkin> there's even a mapMonotonic
14:55:47 <brooksbp> jmcarthur: for OCaml
14:55:52 <copumpkin> which is a lot more efficient
14:56:06 <jmcarthur> brooksbp: oh. i was talking about Haskell
14:56:19 <jmcarthur> i don't know OCaml well enough to answer your question in terms of it
14:56:50 <jmcarthur> copumpkin: i've never had opportunity to use mapMonotonic :(
14:57:34 <copumpkin> aw
14:57:49 <copumpkin> it'll break your map if you lie though
14:57:54 <jmcarthur> yeah
14:57:58 <c_wraith> unsafeMapMonotonic
14:58:03 <jmcarthur> exactly why i haven't had the opportunity
14:58:30 <jmcarthur> hmm, it doesn't break referential transparency, really
14:58:38 <copumpkin> nope, it just breaks the map
14:58:44 <copumpkin> or set, that is
14:58:56 <jmcarthur> i get unsafe is still reasonable though since it breaks the model
14:59:15 <jmcarthur> i just don't know if unsafe is commonly used for model-breaking functions
14:59:18 <jmcarthur> i guess it is
14:59:49 <jmcarthur> abstraction-breaking functions should be prefixed with "ugly"
14:59:55 <Cale> hehe
15:00:00 <c_wraith> that's fair :)
15:00:13 <jmcarthur> most of Data.Set's functions would be ugly
15:00:21 <copumpkin> really?
15:00:25 <jmcarthur> since they require an Ord
15:00:35 <copumpkin> oh
15:00:42 <copumpkin> but there's no good way to get around that, computationally
15:00:49 <jmcarthur> doesn't make it pretty
15:00:59 <jmcarthur> uglyMap
15:01:16 <Alpounet> nobody would use these functions
15:01:21 <jmcarthur> Alpounet: exactly
15:01:24 <jmcarthur> ;)
15:01:24 <Alpounet> :D
15:02:28 <Alpounet> is there any state machine based parser out there ?
15:03:04 <jmcarthur> Alpounet: explicitly, you mean? i don't know of any if so
15:03:19 <Alpounet> "explicitly" ?
15:03:48 <jmcarthur> i just mean something can be a state machine without calling it a state machine
15:04:05 <Alpounet> oh
15:04:10 <Alpounet> implicit may be fine here
15:06:25 <ivanm> awwww.... bos' blog is _still_ down
15:06:26 <ivanm> :(
15:10:39 <demolithion> hai guys, im kinda a newb.. so i've got this List [[Bool]] and would like to draw a black/white of it. could someone point me to a library or something to do that?
15:10:40 <Younder> I'm still here Ivanm
15:11:03 <ivanm> \o/
15:11:05 <Twey> demolithion: Draw it where, how?  To the screen?  To a file?  In what format?
15:11:22 <twanvl> demolithion: the easiest is to draw it as text using  '#' and ' ' or something
15:11:23 <demolithion> Twey: uhm i meant draw a picture to the screen :)
15:11:37 <Twey> demolithion: So in a window?
15:11:43 <Twey> You might look at Gtk2Hs
15:11:45 <demolithion> Twey: yup
15:11:48 <Twey> Or HOpenGL
15:11:57 <demolithion> Twey: okay thanks
15:12:49 <twanvl> let display = mapM_ (putStrLn . map (\x -> if x then '#' else ' ')) in  display [[True,False,True],[False,True,True]]
15:13:00 <Younder> you want any advive on openML? or RMI? it's lost.. goodbye
15:13:57 <demolithion> twanvl: ah that's nice too thanks
15:14:22 <jmcarthur> demolithion: the diagrams library might be nice for you
15:15:25 <jmcarthur> it requires gtk2hs though
15:15:30 <jmcarthur> which isn't on hackage :\
15:15:50 <Twey> display = putStrLn . map (intercalate '\n' . map ('#' ?? ' ')) -- faster
15:15:53 <Twey> (IIRC)
15:16:06 <tomberek> @djinn (a,b,c)->(a,b)
15:16:06 <lambdabot> f (a, b, _) = (a, b)
15:16:40 <demolithion> jmcarthur: im using archlinux and it seems like it's in the aur. im gonna look at it. thanks
15:17:13 <jmcarthur> demolithion: yay for arch linux!
15:20:16 <nostrand> hi, what's the meaning of | i \<- [2..100] in a list expression, the backslash?
15:21:29 <jmcarthur> looks like an error to me
15:21:32 <BONUS> i'm pretty sure that means a syntax error
15:21:51 <nostrand> it's used here: http://www.haskell.org/ghc/docs/6.8.2/html/libraries/array/Data-Array-IArray.html
15:21:54 <jmcarthur> maybe a HTML (de)formatter gone bad?
15:22:09 <uorygl> > let f x = x - tan x in f.f.f.f.f.f.f $ 3
15:22:10 <lambdabot>   3.141592653589793
15:22:23 <nostrand> [(i, z) | i \<- range b]
15:22:44 <uorygl> > let f x = x - tan x in f.f.f.f.f.f.f $ 2
15:22:45 <lambdabot>   3.141592653589793
15:22:59 <jmcarthur> nostrand: i suspect that the author though the backslash would be necessary to protect the < from HTML
15:23:03 <jmcarthur> *thought
15:23:04 <BONUS> that looks like an error in documentation to me!
15:23:22 <nostrand> yep
15:23:42 <BONUS> someone should fix that
15:24:33 <BONUS> i mean every other possible html document manages to display < without doing \<
15:25:52 <uorygl> I guess the function (let f x = x - tan x in f.f.f.f.f.f.f) isn't exactly continuous everywhere
15:29:10 <Twey> Woooah
15:29:13 <Twey> Is that pi?
15:31:39 <gwern> @tell conal http://a1k0n.net/blah/archives/2010/03/index.html sounds exactly like my idea of finding the 'midpoint'. should've known it had a fancy math name
15:31:39 <lambdabot> Consider it noted.
15:33:55 <ddarius> Twey: Assume iterating f reaches a fixed point and call that fixed point y.  You arrive at the equation y = y - tan y which will only hold if tan y = 0.
15:35:12 <jmcarthur> gwern: voronoi partitioning?
15:35:20 <djahandarie> That is a cool article
15:35:22 <gwern> jmcarthur: no fair looking
15:35:31 <jmcarthur> ah
15:36:27 <jmcarthur> djahandarie: yeah it was pretty good. i helped the author proof it earlier today because i participated in that contest too, and he did a few things i didn't which were nice to read about
15:37:14 <jmcarthur> gwern: "fair looking" doesn't seem to appear in the article
15:37:56 <djahandarie> jmcarthur, I think he meant it was no fair that you looked!
15:37:59 * gwern tries again: 'jmcarthur: no fair cheating'
15:38:33 <jmcarthur> gwern: oh i had applied the technique in my own bot before reading the article, and i had read the article before you did :P so there
15:38:45 <djahandarie> Ah the ambiguities of the English language...
15:38:46 <gwern> jmcarthur: ah, but I discussed it with conal like a month ago
15:39:17 <jmcarthur> gwern: i don't know the context, but the voronoi partitioning algorithm as applied to tron isn't necessarily about finding a midpoint
15:39:19 <ddarius> > let f x = x - tan x in f.f.f.f.f.f.f $ -3
15:39:20 <lambdabot>   -3.141592653589793
15:39:28 <ddarius> > let f x = x - tan x in f.f.f.f.f.f.f $ 6
15:39:29 <lambdabot>   6.283185307179586
15:39:51 <jmcarthur> gwern: if the map has obstacles, for example, the battlefront might have an odd shape
15:40:00 <gwern> jmcarthur: yeah, I realized that early on
15:40:46 <ddarius> > let f x = x - (x*x-2) in f.f.f.f.f.f.f $ 1
15:40:47 <lambdabot>   2
15:40:55 <ddarius> > let f x = x - (x*x-2) in f.f.f.f.f.f.f $ 1.5
15:40:56 <lambdabot>   1.438858579537646
15:41:03 <ddarius> > let f x = x - (x*x-2) in f.f.f.f.f.f.f.f.f.f.f.f.f.f $ 1.5
15:41:05 <lambdabot>   -0.3498998659381485
15:41:06 <jmcarthur> > let f x = x - tan x in head . take 500 $ iterate f 1
15:41:07 <lambdabot>   1.0
15:41:12 <jmcarthur> > let f x = x - tan x in head . take 500 $ iterate f 2
15:41:13 <lambdabot>   2.0
15:41:16 <jmcarthur> > let f x = x - tan x in head . take 500 $ iterate f 3
15:41:17 <lambdabot>   3.0
15:41:37 <ddarius> head . take 500 $ iterate f x === x
15:41:40 <jmcarthur> i guess i could have used (!! 500) instead
15:41:49 <ddarius> You wanted drop.
15:41:57 <jmcarthur> oh woops
15:41:59 <jmcarthur> dummy
15:42:11 <jmcarthur> > let f x = x - tan x in iterate f 3 !! 500
15:42:12 <lambdabot>   3.141592653589793
15:42:23 <jmcarthur> > let f x = x - tan x in iterate f 1 !! 500
15:42:24 <lambdabot>   0.0
15:43:14 <ddarius> > let f x = x + (x*x-2) in f.f.f.f.f.f.f.f.f.f.f.f.f.f $ 1.5
15:43:15 <lambdabot>   Infinity
15:43:24 <ddarius> > let f x = x + (x*x-2) in f.f.f.f.f.f.f.f.f.f.f.f.f.f $ 0.5
15:43:25 <lambdabot>   0.3498998659381485
15:43:43 <ddarius> > let f x = x + (x*x-2) in recip $ f.f.f.f.f.f.f.f.f.f.f.f.f.f $ 0.5
15:43:44 <lambdabot>   2.8579605119847895
15:44:04 <ddarius> > let f x = x + (x*x-2) in 0.5 * (recip $ f.f.f.f.f.f.f.f.f.f.f.f.f.f $ 0.5)
15:44:06 <lambdabot>   1.4289802559923948
15:44:12 <jmcarthur> > let f x = x + (x*x*2) in iterate f 0.5 !! 500
15:44:13 <lambdabot>   Infinity
15:44:22 <jmcarthur> > let f x = x + (x*x-2) in iterate f 0.5 !! 500
15:44:23 <lambdabot>   0.8022048497788834
15:45:02 <ddarius> > let f x = x + (x*x-2) in f.f.f.f.f.f.f.f.f.f.f.f.f.f $ 1.41
15:45:03 <lambdabot>   0.3604271341538876
15:45:12 <ddarius> > let f x = x - (x*x-2) in f.f.f.f.f.f.f.f.f.f.f.f.f.f $ 1.41
15:45:13 <lambdabot>   1.2724517955559866
15:45:20 <jmcarthur> we should make a function that stops when a fixpoint is reached, if any :)
15:45:52 <ivanm> jmcarthur: I've done that before
15:46:07 <ddarius> > let f x = x - (x*x-2) in f.f.f.f.f.f.f.f.f.f.f.f.f.f $ (-1.41)
15:46:08 <lambdabot>   -0.3604271341538876
15:46:10 <ivanm> fixPoint f x = let x' = f x in if x' == x then x' else fixPoint f x'
15:46:39 <ivanm> > let fixPoint f x = let x' = f x in if x' == x then x' else fixPoint f x'; f x = x - (x*x - 2) in fixPoint f 1
15:46:43 <lambdabot>   mueval-core: Time limit exceeded
15:46:46 <ivanm> heh
15:46:51 <ddarius> ivanm: It clearly doesn't converge.
15:46:57 <ivanm> yeah
15:47:10 <ivanm> well, it does if x ever equals sqrt(2)
15:47:17 <ivanm> +- sqrt(2) to be precise
15:47:26 <ddarius> Yes, but it doesn't converge to those if it is near.
15:47:34 <ivanm> true
15:47:39 <ivanm> > let fixPoint f x = let x' = f x in if x' == x then x' else fixPoint f x'; f x = x - (x*x - 2) in fixPoint f (sqrt 2)
15:47:43 <lambdabot>   mueval-core: Time limit exceeded
15:47:46 <ivanm> hmmm...
15:47:57 <ivanm> > let fixPoint f x = let x' = f x in if x' == x then x' else fixPoint f x'; f x = x - (x*x - 2) in f (sqrt 2)
15:47:58 <lambdabot>   1.4142135623730947
15:48:07 <jmcarthur> :t \f -> head . dropWhile (uncurry (/=)) . uncurry zip <<< id &&& tail <<< iterate f
15:48:08 <lambdabot> forall a. (Eq a) => (a -> a) -> a -> (a, a)
15:48:10 <ivanm> > let fixPoint f x = let x' = f x in if x' == x then x' else fixPoint f x'; f x = x - (x*x - 2) in f (sqrt 2) - sqrt 2
15:48:11 <ddarius> > let f x = x - (x*x*x - 3) in f.f.f.f.f.f.f $ 1
15:48:11 <lambdabot>   -4.440892098500626e-16
15:48:12 <lambdabot>   170156701704111159283552506249684323722337555824256462003485742386739546255...
15:48:18 <jmcarthur> :t \f -> fst . head . dropWhile (uncurry (/=)) . uncurry zip <<< id &&& tail <<< iterate f
15:48:19 <lambdabot> forall a. (Eq a) => (a -> a) -> a -> a
15:48:22 <ivanm> ahhh, numeric precision... isn't it wonderful :s
15:48:47 <jmcarthur> @let fixpoint f = fst . head . dropWhile (uncurry (/=)) . uncurry zip <<< id &&& tail <<< iterate f
15:48:49 <lambdabot>  Defined.
15:49:14 <BONUS> mixing of . and <<< ... uuguugughghghgh
15:49:28 <jmcarthur> BONUS: it's for precedence
15:49:43 <jmcarthur> BONUS: i've gotten used to it and i like it
15:49:48 <BONUS> oh, for &&&?
15:49:51 <jmcarthur> yup
15:50:01 * BONUS gives jmcarthur a bag of parentheses :)
15:50:24 <ddarius> > let f x = x - (x*x - 0.5) in f.f.f.f.f.f.f $ 1
15:50:26 <lambdabot>   0.7065492759819042
15:50:32 <ddarius> > sqrt 0.5
15:50:33 <lambdabot>   0.7071067811865476
15:50:51 <jmcarthur> > let f x = x - (x*x - 0.5) in fixpoint f 1
15:50:55 <lambdabot>   mueval-core: Time limit exceeded
15:51:01 * ddarius thinks the (magnitude of the) slope needs to be < 1 near the zero for this to work.
15:52:43 <jmcarthur> > fixpoint (/2) 100
15:52:44 <lambdabot>   0.0
15:53:02 <ddarius> > let f x = x - sin x in f.f.f.f.f.f.f $ 1
15:53:03 <lambdabot>   0.0
15:53:13 <ddarius> > let f x = x - sin x in f.f.f.f.f.f.f $ 2
15:53:14 <lambdabot>   0.0
15:53:43 <ddarius> > let f x = x - cos x in f.f.f.f.f.f.f $ 2
15:53:44 <lambdabot>   4.71238898038469
15:53:48 <ddarius> > let f x = x - cos x in f.f.f.f.f.f.f $ 1
15:53:49 <lambdabot>   -1.5707963267948966
15:54:02 <jmcarthur> > let f x = x - sin x in fixpoint f 1
15:54:03 <lambdabot>   0.0
15:54:17 <jmcarthur> > let f x = x - cos x in fixpoint f 1
15:54:18 <lambdabot>   -1.5707963267948966
15:55:19 <jmcarthur> > let f x = x^2 - 3*x + 4 in fixpoint f 100
15:55:23 <lambdabot>   mueval-core: Time limit exceeded
15:55:27 <jmcarthur> > let f x = x^2 - 3*x + 4 in fixpoint f 1
15:55:28 <lambdabot>   2
15:57:13 <twink> x^2 - 3*x + 4 has no real roots
15:57:24 <ddarius> twink: fixpoint not root
15:57:53 <ddarius> twink: The question is if 2 is a root of x^2 - 4*x + 4
15:58:06 <jmcarthur> > fixpoint sqrt 2
15:58:08 <lambdabot>   1.0
15:58:08 <twink> Sorry, x = x^2 - 3*x + 4 ~> x^2-4*x+4 does have real roots.
15:58:44 <ddarius> Incidentally, just to be explicit: fixpoint (\x -> x - g x) = g^-1 x
15:59:18 <jmcarthur> > fixpoint sqrt 10
15:59:19 <lambdabot>   1.0
15:59:46 <ddarius> Incidentally, just to be explicit: fixpoint (\x -> x - g x) = g^-1 0
16:01:10 <twink> |2*x - 3| < 1 when 1 < x < 2 ?
16:02:41 <mauke> |2*x - 3| < 1;; -1 < 2*x - 3 < 1;; 2 < 2*x < 4;; 1 < x < 2
16:02:43 <Younder> hi all
16:02:54 <ddarius> Yes, though I was referring to the slope of g, not the slope of f.
16:03:52 <Younder> banned from #lisp
16:03:59 <Younder> the Ai am :)
16:04:10 <Younder> man
16:04:17 <lament> were you trolling about how great Haskell is?
16:04:53 <Younder> lament, nop, though I love haskel
16:05:37 <twink> |1 - g'| < 1 has -1 < 1 - g' < 1 then -2 < -g' < 0, 0 < g' < 2, and so you need a region where |(d/dx)(x^2-4*x+4)| = 2*|x-2| < 2, and then |x-2|<1 or 1 < x < 3?
16:06:06 <Younder> haskell
16:24:05 <merehap> how can one make a function "a _ _ = ..." using template haskell? I haven't seen any Pat that gives you both a name and arguments, only one or the other
16:24:13 <merehap> I'm looking at this now: http://cvs.haskell.org/Hugs/pages/libraries/template-haskell/Language-Haskell-TH-Syntax.html#t%3APat
16:24:54 <merehap> I could use a lambda expression of the right hand side, but that would just be a hack...
16:25:40 <merehap> ConP matches what I want, but is for data constructors rather than for standard functions
16:25:58 <ivanm> merehap: does it really matter if you're just generating code at compile time>
16:25:59 <ivanm> ?
16:27:22 <merehap> I guess not, but it would be nice to see ddump-splice give Haskell code that is what a human would write, rather than random lambda expressions...
16:27:51 <merehap> and pattern matching is strict, while lambdas are lazy, iirc
16:29:29 <ivanm> *shrug* never used TH
16:29:42 <ivanm> what are you using TH for?
16:30:35 <merehap> I'm cloning the GNU core utils, but there is a lot of the structure that can't really be removed by standard haskell
16:31:00 <merehap> certain function declarations that must be there, but still take up space
16:31:10 <merehap> for all 100+ of the utilities
16:31:33 <merehap> it would be nice to write one line per utility for that stuff rather than 10 per utility
16:32:27 <merehap> it makes me sad that I have to navigate the API in order to make any progress on learning TH, the tutorials just aren't very helpful
16:34:36 <altmattr> is it possible to use unicode characters in function names?
16:37:35 <Zao> Depends on their classification, doesn't it?
16:56:33 <Philonous> Is there something like memcpy for StorableArray? "forM_ [1..n] (\i -> readArray x i >>= writeArray y i)" seems to carry a lot of overhead (creating and traversing a list)
16:59:22 <blackh1> In theory all the overhead should be optimized out of that, but I haven't checked whether it really does it.
17:14:43 <jcreigh> I forget...there isn't some handy generic (ie, split/join on "," instead of newline) version of lines/unlines, is there?
17:15:15 <Saizan> only in the split package
17:16:26 <jcreigh> Saizan: k, thanks for the pointer.
17:19:33 <ddarius> > const () :: Char -> ()
17:19:34 <lambdabot>   {'a'->();'b'->();'c'->();'d'->()}
17:20:55 <ivanm> bos: what's with your blog?
17:21:41 <ivanm> and the rest of your site
17:25:29 <nostrand> jcreigh: haha, i am looking for exactly the same thing =)
17:25:46 <nostrand> jcreigh: ByteString has it
17:26:05 <jcreigh> which is I guess what all the cool kids use these days.
17:26:21 <nostrand> hehe
17:26:28 <ivanm> which means I'm not cool? :(
17:26:39 <jcreigh> ivanm: no, it doesn't mean that.
17:27:24 <ivanm> but I don't use bytestring, and if all the cool kids use it and I don't I musn't be cool...
17:27:32 <jcreigh> let's see...
17:27:36 <ivanm> wait, I lie, I _have_ used bytestring...
17:27:42 <ivanm> (at kolmodin's suggestion though)
17:27:44 <ivanm> \o/
17:27:45 <jcreigh> P -> Q. Not Q, not P.
17:27:47 <jcreigh> yeah, that works.
17:27:55 <jcreigh> so I guess it does mean you're not cool. sorry. :)
17:28:00 <Saizan> maybe you're not a kid
17:28:06 <jcreigh> ah, excellent point.
17:28:10 <jcreigh> saved!
17:28:55 <ivanm> heh
17:35:31 <Jonno_FTW> hey
17:35:49 <ivanm> ho
17:35:54 <Jonno_FTW> i was doing the reverse polish notation calculator in LYAH
17:36:08 <Jonno_FTW> and got this after i modified it: http://moonpatio.org/fastcgi/hpaste.fcgi/view?id=8458#a8458
17:36:19 <Jonno_FTW> but it doesn't like it and
17:36:46 <ivanm> in what sense doesn't it like it?
17:36:56 <Jonno_FTW> ignore that for a moment
17:36:56 <ivanm> (and what is the first "it" refer to? ghci?)
17:37:06 <c_wraith> Bah.  Is there an efficient way to treat a ByteString as an arbitrary-precision integer?
17:37:10 <Jonno_FTW> yes ghci
17:37:31 <copumpkin> c_wraith: I was going to write one but haven't done it yet :) maybe there's another one though
17:37:31 <ivanm> c_wraith: doubt it
17:37:40 <ivanm> why do you want such a thing?
17:37:53 <c_wraith> For manipulating 448-bit numbers.
17:37:55 <ddarius> c_wraith: You could probably hack it.
17:37:57 <ddarius> @src Integer
17:37:57 <lambdabot> data Integer = S# Int#
17:37:57 <lambdabot>              | J# Int# ByteArray#
17:38:00 <copumpkin> c_wraith: you mean in a human-readable number base or an array?
17:38:05 <Veinor> The Haskell situation has been blown out of proportion, RFU is trying to treat SF as they do with local clubs.Nonsense #rugby #rfu #haskell
17:38:11 <Veinor> I keep forgetting that Haskell is also a name
17:38:17 <copumpkin> :P
17:38:18 <ivanm> Jonno_FTW: is it because n is actually a character and not a string?
17:38:30 <Jonno_FTW> not
17:38:31 <Jonno_FTW> no
17:38:33 <ivanm> Veinor: hmmm?
17:38:37 <Veinor> twitter.
17:38:38 <Jonno_FTW> it was an error elsewhere that is causing it
17:38:39 <c_wraith> copumpkin: as a binary value (big or little-endian, I don't really care)
17:38:42 <ivanm> oh, you do words
17:38:50 <ivanm> Jonno_FTW: you can't use a fold there
17:38:55 <ivanm> @type foldl
17:38:56 <ddarius> @src ByteString
17:38:56 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
17:38:57 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
17:39:06 <Saizan> Jonno_FTW: the first argument to sol' is the accumulator, which starts as []
17:39:07 <Jonno_FTW> but the tutorial said i could
17:39:10 <ivanm> Jonno_FTW: you're trying to give it the whole string
17:39:12 <copumpkin> c_wraith: ah, I wouldn't rely on the layout of that ByteArray# in J#
17:39:15 <ivanm> and you can't do that with a fold
17:39:26 <copumpkin> that's internal GMP structure
17:39:26 <McManiaC> why do I get an empty .prof file on +RTS -p/P ?
17:39:26 <ivanm> besides, folding functions take two args
17:39:36 <ivanm> oh, you do give it two args
17:39:45 <ivanm> Jonno_FTW: what's the actual error then?
17:39:50 <McManiaC> I activated profiling in my cabal options and combiled with -prof
17:39:54 <Saizan> Jonno_FTW: you've to rethink about what foldl does
17:39:56 <c_wraith> copumpkin: ah, and so might contains bits that are not part of a binary representation?
17:40:05 <ivanm> Oh, here's a guess:
17:40:07 <copumpkin> c_wraith: yeah
17:40:08 <c_wraith> err, representation of the number itself
17:40:12 <ivanm> what happens when the list you give it is empty?
17:40:22 <copumpkin> c_wraith: you could just build one the obvious bit-wise way
17:40:26 <copumpkin> it'd be safe
17:40:29 <copumpkin> if a bit slower
17:40:34 <ivanm> Jonno_FTW: you need a sol' ys n = n:ys case!
17:40:40 <Saizan> Jonno_FTW: though maybe, you just have to foldl (flip sol')
17:40:42 <c_wraith> copumpkin: I could easily do it slowly.  I was wondering about something semi-efficient.
17:40:47 <ivanm> welll, = read n : ys case
17:40:52 <Saizan> ivanm: the list fiven to sol' will always be empty.
17:40:54 <copumpkin> no efficiency for you!
17:41:03 <Jonno_FTW> ok, i removed the other part that used it
17:41:07 <Saizan> ivanm: it starts as []
17:41:08 <ivanm> Saizan: initially, yes
17:41:09 <Jonno_FTW> and it compiled
17:41:28 <Jonno_FTW> but i get the non-exhaustive patterns error
17:41:43 <ivanm> Jonno_FTW: also, you can do xs@(x:y:ys) rather than defining xs later on
17:41:51 <Saizan> > foldl (\(x:xs) _ -> ()) [] [1..]
17:41:52 <lambdabot>   Couldn't match expected type `[t]' against inferred type `()'
17:41:53 <ivanm> Jonno_FTW: paste up the entire error
17:42:00 <Jonno_FTW> alright
17:42:16 <Saizan> > foldl (\(x:xs) _ -> []) [] [1..]
17:42:24 <lambdabot>   mueval: ExitFailure 1
17:42:27 <Saizan> > foldl (\(x:xs) _ -> []) [] [1..3]
17:42:38 <lambdabot>   mueval-core: Time limit exceeded
17:42:41 <ivanm> Jonno_FTW: you need a catch-all case for sol'!
17:42:57 <ivanm> and what happens if the String is empty?  then head will return an error!
17:43:08 <ivanm> Saizan: that's weird...
17:43:10 <Jonno_FTW> done
17:43:33 <Saizan> i think you need to turn your fold around, actually :)
17:44:11 <Saizan> ah, no.
17:44:11 <ivanm> yeah
17:44:15 * Saizan shuts up
17:44:24 <Saizan> > foldl (\(x:xs) _ -> []) [] [1..3]
17:44:26 <lambdabot>   * Exception: <interactive>:1:148-162: Non-exhaustive patterns in lambda
17:44:56 <ivanm> Saizan: so how come now it complains but before it was a time limit exceeded?
17:45:13 <Saizan> ivanm: machine busy?
17:46:33 <ivanm> Saizan: could be
17:46:50 <Jonno_FTW> test
17:48:19 * hackagebot mongoDB 0.3 - A driver for MongoDB  http://hackage.haskell.org/package/mongoDB-0.3 (ScottParish)
17:49:34 <Jonno_FTW> i'm still stuck here
17:50:01 <copumpkin> need moar mongo
17:50:32 <ivanm> @wn mongo
17:50:33 <lambdabot> *** "mongo" wn "WordNet (r) 2.0"
17:50:33 <lambdabot> mongo
17:50:33 <lambdabot>      n : 100 mongo equal 1 tugrik
17:50:39 <ivanm> @wn tugrik
17:50:40 <lambdabot> *** "tugrik" wn "WordNet (r) 2.0"
17:50:40 <lambdabot> tugrik
17:50:40 <lambdabot>      n : the basic unit of money in Mongolia [syn: {tughrik}]
17:50:47 <Jonno_FTW> ;__;
17:50:53 * ivanm doesn't have any mongolian currency
17:50:57 <yaru1022> hi, what's the most active FRP library at this moment?
17:51:07 <ivanm> conal's?
17:51:14 <ivanm> (that's reactive)
17:51:31 <yaru1022> okay!
17:52:06 <Cale> Does conal's library actually *work* at this moment?
17:52:13 <ivanm> dunno
17:52:22 <ivanm> it's on hackage, that means it works, right? :p
17:52:26 <Cale> It's certainly the most interesting one, but I don't think it's currently practical.
17:52:29 <Cale> Hehe, no.
17:53:58 <Saizan> Jonno_FTW: did you add a case for the empty or singleton list to sol' ?
17:54:05 <Cale> At least, the last time I actually had it working, it seemed to have impractical time/space behaviour for all but the simplest programs, due to some mysterious problems.
17:54:08 <Jonno_FTW> i will
17:54:16 <roconnor> > 78*5
17:54:17 <lambdabot>   390
17:54:29 <Cale> But it's actually quite hard to install, since the versions of things that you need to use are not all the latest ones.
17:54:39 <roconnor> > 78*105
17:54:40 <lambdabot>   8190
17:54:55 <ivanm> Cale: yeah, I find that a pain with bigger libraries/apps; you need so many little libraries and quite often they're not the latest ones :s
17:55:10 <Jonno_FTW> now i just get an exception
17:55:38 <ivanm> yi was probably the worst when they defined an instance that wasn't in one of the libraries it used, which then went and added that instance and so yi wouldn't build... >_>
17:56:05 <aavogt> evil orphans
17:57:18 <Saizan> Jonno_FTW: http://moonpatio.org/fastcgi/hpaste.fcgi/view?id=8458#a8460 <- it's a bit too permissive for my taste, but it should be correct on well formed expressions
17:57:47 <Jonno_FTW> ok
17:58:06 <Jonno_FTW> i thought otherwise should cover anything else
17:58:18 <Jonno_FTW> why didn't this work?
17:58:57 <Saizan> because that otherwise is inside a clause where you've pattern matched against (x:y:ys)
17:59:08 <Jonno_FTW> oh right
17:59:14 <Jonno_FTW> makes sense now
17:59:15 <Jonno_FTW> thanks
18:00:32 <Jonno_FTW> next thing to do is make evaluate any sub expressions
18:00:39 <ivanm> *sigh* I had already said twice before to include a catch all line
18:00:43 <ivanm> and even gave you that line
18:00:48 <Jonno_FTW> thanks
18:01:02 <Jonno_FTW> i just didn't know that otherwise wouldn't always work
18:01:26 <Saizan> btw otherwise is not a keyword
18:01:36 <Jonno_FTW> how come?
18:01:40 <ivanm> @src otherwise
18:01:41 <lambdabot> otherwise = True
18:01:41 <copumpkin> > otherwise
18:01:43 <lambdabot>   True
18:01:58 <ivanm> Jonno_FTW: it's just an alias for True defined for readability purposes
18:02:03 <Jonno_FTW> ok
18:03:10 <Jonno_FTW> so i'm stuck in the library for 3 hours now
18:03:33 <aavogt> @src True
18:03:33 <lambdabot> Source not found. My brain just exploded
18:03:45 <Cale> @src Bool
18:03:45 <lambdabot> data Bool = False | True deriving (Eq, Ord)
18:04:00 <ivanm> Jonno_FTW: and that's our fault _how_? :p
18:04:10 <aavogt> > [minBound .. ] :: [Bool]
18:04:11 <lambdabot>   [False,True]
18:04:12 <Jonno_FTW> because all i have to do is Haskell
18:04:23 <aavogt> @src lies
18:04:23 <lambdabot> Source not found.
18:04:27 <Jonno_FTW> it being the beginning of semester and no work to do
18:05:32 * Jonno_FTW is doing software engineering
18:05:42 <Jonno_FTW> s/doing/studying/
18:08:17 <ivanm> where at?
18:08:52 <aavogt> > reverse "Jonno_FTW"
18:08:54 <lambdabot>   "WTF_onnoJ"
18:10:33 <Jonno_FTW> > reverse $ splitAt 4 $ reverse "Jonno_FTW"
18:10:34 <lambdabot>   Couldn't match expected type `[a]'
18:10:34 <lambdabot>         against inferred type `([GHC.Typ...
18:10:39 <Jonno_FTW> > map reverse $ splitAt 4 $ reverse "Jonno_FTW"
18:10:40 <lambdabot>   Couldn't match expected type `[[a]]'
18:10:40 <lambdabot>         against inferred type `([GHC.T...
18:11:06 <Jonno_FTW> > fmap reverse $ splitAt 4 $ reverse "Jonno_FTW"
18:11:07 <lambdabot>   ("WTF_","Jonno")
18:11:52 <aavogt> @type map
18:11:55 <tomberek> what's a ~ in a pattern?
18:11:55 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
18:12:04 <Ninju> Hi, I'm trying to figure out this problem I'm having with TVars/STM
18:12:16 <ivanm> yay! bos' blog is back ukp!
18:12:18 <ivanm> *up
18:12:27 <Ninju> I've got a data structure like Room { inhabitants :: STM (TVar [Name]) }
18:12:29 <aavogt> > \ (~ (x:xs )) -> "hai" $ []
18:12:30 <lambdabot>   Couldn't match expected type `a -> b'
18:12:31 <lambdabot>         against inferred type `[GHC.T...
18:12:35 <ivanm> tomberek: I forget the name for it, but it defines a type 'equality'
18:12:41 <aavogt> > (\ (~ (x:xs )) -> "hai") $ []
18:12:41 <ivanm> usually used with type families
18:12:42 <lambdabot>   "hai"
18:12:46 <aavogt> > (\ ( (x:xs )) -> "hai") $ []
18:12:47 <lambdabot>   "* Exception: <interactive>:1:134-154: Non-exhaustive patterns in lambda
18:12:49 <ivanm> oh, a pattern
18:12:54 * ivanm misread and thought it was a type sig
18:12:57 <Ninju> the functions correctly update the TVars (I've tested them) but it's not working, when I grab it through the room
18:13:00 <ivanm> irrefutable pattern
18:13:11 <tomberek> hm.....
18:14:00 <tomberek> ivanm: thanks, i found it http://en.wikibooks.org/wiki/Haskell/Laziness#Lazy_pattern_matching
18:14:16 <ddarius> ivanm: What you were first talking about are called simply "equality constraints," I believe.
18:14:26 <ivanm> ahhh
18:15:27 <aavogt> > (\a -> let x:xs = a in "tomberek") []
18:15:28 <lambdabot>   "tomberek"
18:16:00 <aavogt> that is how you can write the same code without ~ patterns
18:23:56 <Ninju> why will this code not work
18:23:56 <Ninju> http://pastie.org/854958
18:24:50 <ivanm> my STM-fu is weak, but what's the error?
18:25:03 <Ninju> well there's no error
18:25:09 <Ninju> but the list of inhabitants doesn't get updated
18:25:15 <ivanm> I find it rather dodgy to have STM values in the data structure
18:25:22 <Ninju> BUT if I hold onto the TVar then I check that, and that does get updated
18:25:29 <Ninju> well I'm not sure how else I'm supposed to do it
18:25:35 <ivanm> Ninju: you're not udpating anything, that's why AFAICT...
18:25:35 <Ninju> I can't take the TVar out of a monad
18:26:03 <Ninju> how so?
18:26:12 <ivanm> Ninju: have each inhabitant know which room its in, and pass around (or use the reader monad) a static index of rooms
18:26:21 <uorygl> @docs
18:26:21 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
18:26:40 <ivanm> Ninju: you take inhabitants out of r, but you never update the value of inhabitants in the actual Room value
18:26:48 <ivanm> you probably want to have Name -> Room -> STM Room
18:26:50 <uorygl> @docs Network
18:26:50 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/network/Network.html
18:26:53 * gwern is really liking PAR2 for making DVDs. the error-correcting is nice, but the error-checking is good too. and best of all it makes use of otherwise wasted space
18:27:00 <Ninju> ivanm: yeah I am currently using the Reader monad, and also each inhabitant does know what room it's in
18:27:00 <ivanm> uorygl: that link probably doesn't work anymore
18:27:06 <uorygl> Indeed, it doesn't.
18:27:14 <ivanm> gwern: PAR2?
18:27:20 <ivanm> uorygl: get them off hackage
18:27:23 <ivanm> @hackage Network
18:27:23 <lambdabot> http://hackage.haskell.org/package/Network
18:27:23 <Ninju> I need other inhabitants to know who is in which room
18:27:26 <gwern> ivanm: cool shit isn't it?
18:27:29 <ivanm> (or it might be lower case)
18:27:35 <ivanm> gwern: what is it? ;-)
18:27:54 <gwern> ivanm: parity files implementing forward error correction
18:27:59 <ivanm> Ninju: OK, then you have a TVar of lookups or something
18:28:01 <gwern> ivanm: see http://en.wikipedia.org/wiki/Parchive maybe
18:28:22 <ivanm> Ninju: you want to pass your values around all the time
18:29:01 <gwern> ivanm: other good buzzwords: ReedSolomon error correction
18:29:12 <ivanm> I know R-S codes
18:29:22 <ivanm> gwern: so you use that for data DVDs?
18:29:26 <gwern> ivanm: yup
18:29:42 <Ninju> ivanm: Sorry ivanm, I am not sure what you mean.
18:29:43 <ivanm> so it's basically error-correcting archives?
18:29:54 <gwern> ivanm: you make it sound so boring
18:29:58 <ivanm> Ninju: I'm saying that you're thinking about this the wrong way ;-)
18:30:09 <Eridius> >
18:30:12 <Eridius> oops
18:30:26 <ivanm> Ninju: OK, have if you want data Room = { exits :: ... , inhabitants :: [Name] }
18:30:41 <Ninju> ivanm: That is not particularly necessary.
18:30:41 <ivanm> Ninju: then your addInhabitant function is :: Name -> Room -> STM Room
18:30:51 <ivanm> what isn't?
18:31:21 <ivanm> Ninju: my point is, unless you store your Room value in a TVar and pass the location of the TVar around, you have to be able to get values out of the STM monad
18:31:27 <Jonno_FTW> @src words
18:31:27 <lambdabot> words s = case dropWhile isSpace s of
18:31:27 <lambdabot>     "" -> []
18:31:27 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
18:31:43 <ivanm> Ninju: since you're expecting addInhabitant to mutate your r value, which it doesn't
18:31:47 <ivanm> purity, remember? ;-)
18:31:51 <Ninju> AHH
18:31:55 <Ninju> Ok, I get it
18:31:59 <ivanm> \o/
18:32:17 <ivanm> Ninju: one of the main selling points of STM is that it's _composable_, so you have lots of little STM values being updated
18:32:26 <ivanm> s/updated/combined/
18:32:44 * ivanm had a point in saying that, but can't recall what it is
18:32:48 <uorygl> I guess doing Unix domain sockets with the Network module seems simple enough. The server can do {listenOn (UnixSocket "/path/to/new/file")} to get a Socket, and the client can do {connectTo "anything" (UnixSocket "/path/to/new/file")} to connect to it?
18:33:20 * ivanm has no idea
18:33:59 <yaru1022> How should I think about composing two functions with even slightly complicated type? For example, how do I know what the type of map . map would be without using :t in ghci?
18:34:13 <uorygl> :t map
18:34:14 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
18:34:16 <Jonno_FTW> how could i edit words to make it return things between brackets as an entire word
18:34:18 <McManiaC> how can you cause a segfault with haskell?
18:34:28 <uorygl> yaru1022: practice.
18:34:31 <ivanm> yaru1022: by knowing the types in your head and working it out
18:34:39 <ivanm> Jonno_FTW: not sure I understand what you're asking
18:34:43 <Ninju> ivanm: While I'm here do you know of a more general function that may serve as an almost equivalent to my updateTVar function?
18:34:44 <uorygl> McManiaC: unsafeCoerce.
18:34:45 <ivanm> but I think the answer is "use a parsing library"
18:34:57 <Ninju> ivanm: seems a bit weird that it's not there so I am asking myself "why doesn't it exist"
18:34:57 <ivanm> Ninju: I only used STM once, and that was a few years ago ;-)
18:35:13 <McManiaC> oh right, that unsafe stuff could be usefull
18:35:17 <ivanm> McManiaC: can't recall how I've done it, but I have
18:35:20 <ivanm> and only using pure stuff
18:35:21 <Jonno_FTW> words2 "1 2 3 (4 5 6)" -> ["1","2","3","(4 5 6)"]
18:35:26 <McManiaC> ivanm: hm okay
18:35:27 <McManiaC> ^^
18:35:27 <ivanm> I think I had some weird loops in my code or something
18:35:33 <ivanm> Jonno_FTW: get a parsing library
18:35:35 <Ninju> ivanm: Haha, ok. I thought perhaps there may be something of use in one of the common type classes (or something). I'm pretty much a newb, not really familiar with all the different things yet.
18:35:48 <Jonno_FTW> ivanm: i thought it would simpler
18:35:58 <ivanm> Jonno_FTW: well, you can always do it by hand
18:36:07 <Jonno_FTW> that's what i was thinking
18:36:07 <yaru1022> uorygl, ivanm: I'm confused because (.) is of type (b->c) -> (a->b) -> a -> c, but map is of type (a->b) -> [a] -> [b]. So I'm not sure how to match map's type to (a->b)
18:36:16 <ivanm> but in effect you'll basically be creating your own parsing library anyway, so you might as well use a parsing library up front
18:36:17 <Jonno_FTW> but i couldn't think of how to do it
18:36:26 <Jonno_FTW> even after looking @src words
18:36:30 <ivanm> yaru1022: the as and bs aren't all the same ;-)
18:36:35 <copumpkin> yaru1022: [a] is [] a
18:36:55 <ivanm> let's work this through:
18:37:01 <copumpkin> a -> b is ((->) a) b
18:37:17 <uorygl> yaru1022: match the (a -> b) on one side to the a on the other; the [a] -> [b] on one side to the b on the other.
18:37:31 <ivanm> map :: (a -> b) -> [a] -> [b] == (a -> b) -> ([a] -> [b])
18:37:38 <gwern> (one bad thing about par2 files is they can take a while to generate!)
18:37:41 <ivanm> (the right hand side one)
18:37:51 <ivanm> gwern: quickpar?
18:37:52 <yaru1022> ivanm: ah.. okay
18:38:12 <ivanm> yaru1022: let's do the same with the left hand side one, and we get (c -> d) -> ([c] -> [d])
18:38:19 <uorygl> yaru1022: it might help to not use the same letters for different things.  Say that map's time is (d -> e) -> [d] -> [e], perhaps.
18:38:22 <ivanm> compare that to the type of (.)
18:38:43 <ivanm> (f -> g) -> (e -> f) -> e -> g
18:39:43 <yaru1022> ivanm: oh... I see. So I should've thought of each function as a curried function.
18:39:49 <yaru1022> ivanm, that makes much more sense now
18:39:57 <ivanm> so we have: ((c -> d) -> ([c] -> [d])) -> ((a -> b) -> ([a] -> [b])) -> (a -> b) -> ([c] -> [d])
18:40:16 <copumpkin> whoa
18:40:21 <ivanm> from the type of (.), we must have that  [a] -> [b] == c -> d
18:40:34 <ivanm> so c == [a], d == [b]
18:40:46 <yaru1022> Right, right.
18:40:51 <McManiaC> <System.Event.IntMap.insertWith,System.Event.Manager.registerFd_,System.Event.Manager.registerFd,Network.HsPurple.EventLoop.inputAdd,Network.HsPurple.UiOps.EventLoopUiOps.hInputAdd,MAIN.SYSTEM>zsh: segmentation fault  ./Main +RTS -xc
18:41:01 <McManiaC> is there a way which of these functions caused the segfault?
18:41:08 <McManiaC> *to tell
18:41:36 <ivanm> which means: map . map :: (a -> b) -> [[a]] -> [[b]]
18:41:39 <ivanm> @type map . map
18:41:40 <lambdabot> forall a b. (a -> b) -> [[a]] -> [[b]]
18:41:43 <yaru1022> thanks ivanm, that clears up my head a lot! =)
18:41:47 <ivanm> yaru1022: no worries
18:42:00 <ivanm> yaru1022: also, neither of them are "curried functions"
18:42:10 <ivanm> currying/uncurrying refers to them as being pairs...
18:42:17 * ivanm can never remember which one is which however
18:42:18 <aavogt> @unpl map . map
18:42:18 <lambdabot> (\ c -> map (map c))
18:42:26 <ivanm> McManiaC: paste some code up?
18:42:41 <ivanm> aavogt: heh, forgot about @unpl; it normally produces code that's even uglier
18:42:55 <yaru1022> ivanm, I just meant that I should have thought of map as a function that accepts a function of type (a->b), which in turn, generates a function that accepts [a] and returns [b]
18:42:58 <aavogt> this is FFI stuff though, maybe your haskell binding is doing something wrong
18:43:02 <ivanm> yaru1022: right
18:43:40 <yaru1022> ivanm, so are you guys so used to this kind of practice that you can compose very complicated types in your head easily?
18:43:49 <McManiaC> how can you catch a segfault? IOException?
18:43:50 <ivanm> yaru1022: nope; I had to think about it ;-)
18:44:01 <ivanm> McManiaC: not sure if you can... >_>
18:44:06 <McManiaC> :>
18:44:23 <ivanm> yaru1022: I usually write it as map (map f)
18:44:39 <ivanm> even then I'm even more likely to want concatMap (map f)
18:44:57 <yaru1022> ivanm, I see...
18:44:57 <ddarius> (map f =<<)
18:45:02 <ivanm> yaru1022: oftentimes pointfree coding just makes it harder to read/understand IMHO
18:45:12 <ivanm> ddarius: or join, etc.; yeah, I know
18:45:27 <ddarius> The "real" point-free coding is not what @pl produces.
18:45:28 <yaru1022> ivanm, yeah I think so... Then why would people prefer pointfree coding?
18:45:30 <McManiaC> hmhmhm
18:45:36 * Cale replies to http://www.reddit.com/r/haskell/comments/b9fo2/anyone_else_ever_wanted_an_io_thunk/
18:45:44 <ivanm> yaru1022: a lot of times it makes composing functions easier
18:45:48 <ivanm> having chains of functions, etc.
18:45:52 <McManiaC> yeh `join' confused me a lot when I first saw it
18:45:53 <McManiaC> :)
18:46:02 <ivanm> Cale: where were you? I had to take over your job to help yaru1022! :p
18:46:28 <ivanm> Cale: oh, and your reddit reply confused me even more than the question :p
18:46:46 <Cale> oh?
18:47:38 <aavogt> @pl \x -> f5(f4(f3(f2(f1(x)))))
18:47:38 <lambdabot> f5 . f4 . f3 . f2 . f1
18:47:47 <ivanm> yeah; never come across (in the sense of code I've written/read; I have heard about them) iorefs before, so how you were using them confused me a tad ;-)
18:47:58 <ivanm> I also don't get what the question was after either... :s
18:49:19 <Saizan> what is stg_ap_2_upd_info in an heap profile?
18:50:07 <Cale> ivanm: So, for example...
18:50:15 <Cale> foo <- once getLine
18:50:49 <Cale> Then the first time 'foo' is run, it behaves identically to getLine
18:50:55 <Cale> Suppose the user types "hello"
18:50:56 <ivanm> @hoogle once
18:50:57 <lambdabot> Network.Browser auNonce :: Authority -> String
18:50:57 <lambdabot> Network.Browser chNonce :: Challenge -> String
18:50:57 <lambdabot> Text.Regex.Base.RegexLike matchOnce :: RegexLike regex source => regex -> source -> Maybe MatchArray
18:51:17 <ivanm> oh, right, that's the function you wrote
18:51:20 <ivanm> Cale: k
18:51:25 <Cale> Then foo will produce "hello" as its result, just like getLine would
18:51:39 <Cale> But then the next time it's run, it doesn't get a line of text from the user
18:51:46 <Cale> it just returns "hello"
18:51:50 <ivanm> and then the result is cached and foo will always be "hello" within IO ?
18:51:56 <Cale> yeah
18:52:11 <ivanm> Cale: any particular reason for doing that rather than passing around the result of getLine (i.e. jsut the string "hello") ?
18:53:11 <Cale> I suppose that sometimes you want to give a function permission to do something whenever it wants, but only once.
18:53:24 <ivanm> hmmm...
18:53:38 <ivanm> "OK, fine, you can launch _one_ nuclear missile, but only one, OK?"
18:53:42 <Cale> right
18:54:07 <Cale> lm <- once launchMissile
18:54:11 <Cale> foo lm
18:54:25 <ivanm> Cale: that doesn't type-check; foo is IO String! :p
18:54:34 <Cale> This is a new foo
18:54:43 <ivanm> _now_ you tell me!
18:54:45 <Cale> foo can run lm to launch a missile, but it can only launch one
18:55:08 <Cale> after that, it just gets the result from launching the first one
18:55:11 * ivanm still can't think of a reason for wanting such a restriction, but then he doesn't write interactive apps
18:55:26 <Cale> It's identical to the way that lazy evaluation is implemented
18:55:42 <ivanm> I suppose maybe something like startTimer :: IO ElapsedTime or something...
18:55:51 <ivanm> no, wait, then the ElapsedTime value will be fixed
18:56:06 <ddarius> ivanm: You can make explicitly lazy IO!
18:56:07 <ivanm> you'd want it to be IO (IO ElapsedTime)
18:56:08 <Cale> In GHC's implementation of lazy evaluation, each variable is really a pointer to code
18:56:16 <yaru1022> :t fmap.fmap
18:56:17 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
18:56:26 <ivanm> ddarius: in the sense that don't do any work unless you absolutely have to?
18:56:48 <ivanm> yaru1022: so that's the same as map . map but it's within two generic Functors rather than two lists
18:56:55 <Cale> which when executed the first time, evaluates the expression it represents, and then replaces that pointer to point at a smaller piece of code which will just return the result of the evaluation immediately.
18:57:12 <yaru1022> ivanm, yeah. But I have another question
18:57:18 <yaru1022> :t (fmap.fmap) snd
18:57:19 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b. (Functor f, Functor f1) => f (f1 (a, b)) -> f (f1 b)
18:57:39 <ivanm> OK, what's your question?
18:57:51 <yaru1022> How come f (f1 (a,b)) can be matched with EventG (FRP.Reactive.Reactive.ImpBounds t) d
18:57:51 <yaru1022>      -> EventG (FRP.Reactive.Reactive.ImpBounds t) (d, t) type?
18:58:01 <yaru1022> I was reading http://netsuperbrain.com/blog/posts/introducing-reactive-events/
18:58:03 <ddarius> ivanm: In the sense that you don't do any IO until you specifically ask for it (or something that, recursively, asks for it.)
18:58:08 <ivanm> yaru1022: presumably because EventG and ImpBounds t are both functors
18:58:19 <ivanm> ddarius: *nod*
18:58:48 <yaru1022> :t withTimeE
18:58:50 <lambdabot> Not in scope: `withTimeE'
19:00:14 <ivanm> @hoogle mfix
19:00:15 <lambdabot> Control.Monad.Fix mfix :: MonadFix m => (a -> m a) -> m a
19:00:31 <ivanm> monadic version of fix I presume?
19:00:34 <ivanm> @src mfix
19:00:35 <lambdabot> Source not found. You type like i drive.
19:00:46 <yaru1022> ivanm, withTimeE ::
19:00:47 <yaru1022> *** mansour (~mansour@CPE0014bf895399-CM0014f8c19014.cpe.net.cable.rogers.com)
19:00:47 <yaru1022>     has joined channel #haskell  [21:02]
19:00:47 <yaru1022> *** metaleks (~asm@CPE0007e949f114-CM001adea9abe6.cpe.net.cable.rogers.com)
19:00:50 <yaru1022>     has joined channel #haskell
19:00:53 <yaru1022> *** miclorb (~michaelne@redhat/jboss/miclorb) has left channel #haskell:
19:00:57 <yaru1022>     #haskell
19:01:00 <yaru1022> <Jonno_FTW> so i'm stuck in the library for 3 hours now
19:01:04 <yaru1022> <aavogt> @src True  [21:03]
19:01:07 <yaru1022> <lambdabot> Source not found. My brain just exploded
19:01:07 <yaru1022> <Cale> @src Bool
19:01:10 <yaru1022> <lambdabot> data Bool = False | True deriving (Eq, Ord)
19:01:11 <ivanm> yaru1022: ummm.... what's going on?
19:01:14 <yaru1022> <ivanm> Jonno_FTW: and that's our fault _how_? :p
19:01:18 <yaru1022> *** kimmell (~kimmell@adsl-99-154-105-52.dsl.tpkaks.sbcglobal.net) has joined
19:01:21 <yaru1022>     channel #haskell
19:01:24 <Cale> yaru1022:
19:01:25 <yaru1022> <aavogt> > [minBound .. ] :: [Bool]
19:01:28 <yaru1022> <lambdabot>   [False,True]
19:01:30 --- mode: ChanServ set +o Saizan
19:01:31 <yaru1022> <Jonno_FTW> because all i have to do is Haskell
19:01:32 <ivanm> please don't tell me we're going to get all of that history pasted in here...
19:01:34 <yaru1022> <aavogt> @src lies
19:01:34 --- mode: Saizan set +b *!*user@*.dsl.bell.ca
19:01:41 <ivanm> thank you Saizan!
19:01:54 <Saizan> he left?
19:01:58 <ivanm> yes
19:02:38 --- mode: Saizan set -b *!*user@*.dsl.bell.ca
19:02:46 --- mode: Saizan set -o Saizan
19:03:40 <Cale> Offtopic: http://ustre.am/p0 -- live streaming talk by Jeri Ellsworth at the Portland Linux/Unix Group, about to start. (She does lots of interesting hardware hacks, and is known for making a C64 which fits into a joystick. I'm not sure what she's going to be talking about specifically, but it might be interesting.)
19:04:14 <ivanm> Cale: tsk, tsk; I thought you amongst all people would have known that off-topic belongs in -blah! :p
19:04:22 <yaru1022> sorry about the incident...
19:04:42 <Saizan> np :)
19:04:50 <ivanm> yaru1022: first time is a warning
19:04:53 <ivanm> second time is a fine
19:04:58 <Cale> hehe
19:04:59 <ivanm> third time is a suspension
19:05:05 <Saizan> pastebins are safer!
19:05:08 <p_l> seventh time it's assasin's time?
19:05:14 <yaru1022> ivanm, yes sir =)
19:05:15 <ivanm> fourth time we get you to talk to jdh
19:05:22 <ivanm> fifth time you're banned permanently!
19:05:23 <ivanm> ;-)
19:05:45 <ivanm> (and by "talk to jdh" I mean "convince him to go away")
19:05:49 <Saizan> there's never been a fifth time
19:06:11 <ivanm> p_l: we need a sixth time first...
19:06:25 <ivanm> Saizan: well, no-one has managed to convince jdh to go away yet! :p
19:07:56 <p_l> ivanm: 6th time is visit from enforcers for sidestepping a ban ;-)
19:08:04 <ivanm> p_l: heh
19:08:39 <DigitalKiwi> ivanm: #haskell is the most lenient channel I have ever seen when it comes to large posts
19:08:56 <ivanm> DigitalKiwi: because we're too lazy to ban people on purpose!
19:09:01 <DigitalKiwi> lol
19:09:12 <ivanm> except spammers
19:09:28 * copumpkin was wondering a few days back how to emulate SQL features using the list monad
19:09:48 <ivanm> copumpkin: isn't there a library that does that?
19:09:50 <copumpkin> (and I don't mean the group by and stuff in that ghc list comps extension)
19:10:00 <Cale> We tend to prefer more personal solutions to administrating the channel to technical ones.
19:10:00 <aavogt> haskelldb?
19:10:02 <copumpkin> mostly talking about joins
19:10:04 <DigitalKiwi> I mean I regularly see peole post like 8+ lines here and nobody bat an eye, in most other channels doing it once is like "omg stfu" and again is a ban
19:10:14 <copumpkin> nah, this was for purely educational purposes
19:10:21 <copumpkin> you can easily write a cross join or an inner join using list comps
19:10:23 <DigitalKiwi> dunno if this is a good or bad thing >.>
19:10:43 <copumpkin> but I wasn't able to reproduce a real outer join with them
19:11:16 <copumpkin> it seems more context sensitive somehow
19:11:20 <p_l> I think I also recall something about banlist being full
19:11:23 <copumpkin> I was wondering if anyone knew of any formal results on this
19:12:32 <twink> outer joins, too?
19:13:03 <ivanm> p_l: from spammers IIRC
19:13:10 <copumpkin> at first I thought an outer join could be modeled with an inner join on Nothing U original_set
19:13:14 <ivanm> jcreigh: decided you couldn't stay away? :p
19:13:23 <jcreigh> heh heh.
19:13:31 <copumpkin> and that handles most cases, but it isn't fully correct
19:13:37 <jcreigh> well, I had resolved to do some homework. but I lost interest. :)
19:13:48 <copumpkin> well, it is correct, but I couldn't do it efficiently with a list comprehension
19:13:57 <ivanm> jcreigh: yes, I should be reading papers
19:13:59 <ivanm> ...
19:14:12 <ddarius> "efficiently" = concisely or run-time efficiency?
19:14:21 <ivanm> whereas Cale is having so much fun he figured he'd bring in an alternate nick with him! :p
19:14:22 <copumpkin> ddarius: either of them
19:14:46 <copumpkin> I guess my inner joins aren't efficient either
19:14:49 <copumpkin> so let's just say concisely
19:15:47 <copumpkin> I've heard that relational algebra can be modeled in category theory but haven't really found much on that
19:15:57 <Cale> (I was just resetting my router, which seems to accumulate slowness for forming new connections while on a torrent until it becomes unusable and must be reset.)
19:16:00 <copumpkin> anyone have any ideas what outer joins might correspond to?
19:17:29 <copumpkin> an equijoin is supposed to be a pullback, and I can sort of see that
19:17:34 <ivanm> Cale: sure you were...
19:17:57 <copumpkin> but that's an inner join
19:18:03 <p_l> Cale: change its software, then! :-)
19:18:43 <Cale> p_l: I have updated the firmware in it, but I think the problem is that it's basically a piece of junk. ;)
19:18:55 <twink> I'm having trouble
19:18:58 <Cale> (actually it was even worse before)
19:19:15 <Cale> twink: Oh?
19:19:15 <jcreigh> One day I got sick of flaky router firmware, and I bought a Linksys router that was Linux-capable, stuck the Tomato firmware on it, and haven't had any problems since.
19:20:15 <uorygl> How can I find out how the sendAncillary and recvAncillary functions in Network.Socket are implemented?
19:20:25 <ivanm> uorygl: look at the source?
19:20:30 <Cale> uorygl: Maybe there are source links from the Haddock?
19:20:41 <uorygl> Oh, there are!  Would you look at that.
19:21:15 <p_l> Cale: well, I found that I prefer running my own software on routers, even if I tend to muck it horribly (finding out that half of the code segfaulted because of wrong environment was a surprise)
19:21:17 <Cale> Unfortunately, the documentation is all split up now
19:21:42 <Cale> http://hackage.haskell.org/packages/archive/network/2.2.1.7/doc/html/src/Network-Socket.html#sendAncillary
19:22:01 <uorygl> Can I see Network/Socket.hsc online somewhere?
19:25:10 <uorygl> I should write a cute little Unix domain socket wrapper library thingy.
19:25:47 <uorygl> Almost all of the necessary stuff is already there; it just needs some slightly more friendly wrapping.
19:39:22 <ivanm> dibblego: was your interact post written for someone, because it was a bit boring versus the title ("here's how to write an approximation of Haskell's interact function in Java!") :s
19:54:29 <enthymene> :t uncurry
19:54:30 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
19:54:39 <enthymene> ah, not quite what I thought it was.
19:55:57 <uorygl> main = uncurry (insert a Haskell program using C-style function notation here)
19:57:27 <ivanm> ummm..... what?
19:57:50 <uorygl> A misuse of the uncurry function.
19:57:55 <ivanm> uorygl: only if your "C-style" function takes exactly two arguments and then you supply those arguments
19:57:55 <copumpkin> f(5, "moo", True)
19:58:04 <enthymene> yeah
19:58:12 <enthymene> I was just thinking about math stuff.
19:58:16 <copumpkin> maff
19:58:25 <enthymene> like, if I have a functor that goes a -> b -> c, like a function of two variables
19:58:34 <enthymene> which would likely by a -> a -> a but whatever
19:58:40 <copumpkin> a functor?
19:58:43 <enthymene> yeah
19:58:49 <ivanm> that's not what we call functors...
19:58:50 <enthymene> technically functions are a -> b if memory serves
19:58:54 <enthymene> I mean strictly
19:58:58 <ivanm> @instance Functor
19:58:58 <lambdabot> Maybe you meant: instances instances-importing
19:59:01 <hasenov> hello, is there a way to force doubles or floats to display fully rather than infinity?
19:59:03 <ivanm> @instances Functor
19:59:04 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
19:59:06 <enthymene> and thus a two-dimensional function is a function that returns a function
19:59:13 <copumpkin> hasenov: if it says infinity, that's means you've exceeded their precision
19:59:40 <enthymene> basically f(x,y) = 2xy + y^2 is a function of x that evaluates to a function of y
19:59:44 <ivanm> @type fmap show (*2)
19:59:45 <lambdabot> forall a. (Num a) => a -> String
19:59:50 <ivanm> ahhh
19:59:50 <copumpkin> enthymene: yep
20:00:06 <ivanm> copumpkin: not really...
20:00:21 <copumpkin> ?
20:00:23 <enthymene> so I was thinking about how I'd do an operation that skips the first variable of a function and then binds the next one
20:00:30 <ivanm> it is isomorphic to (f(x))(y) which is a function of x that evaluates to a function of y
20:00:37 <ivanm> encryptio: flip!
20:00:42 <ivanm> @src flip
20:00:42 <lambdabot> flip f x y = f y x
20:00:44 <copumpkin> I still don't understand what you mean by functor here
20:00:49 <hasenov> copumpkin: yeah, is there a type that has more precision, like long double?
20:00:55 <ivanm> hasenov: Double
20:00:55 <enthymene> yeah ivanm
20:00:57 <copumpkin> hasenov: nothing fast
20:00:58 <enthymene> basically flip
20:01:04 <ivanm> if you want even more, there's CReal (which is kinda slow)
20:01:10 <enthymene> although I wouldn't want to do it with strictly binary functions
20:01:20 <ivanm> > pi == (pi :: CReal)
20:01:22 <lambdabot>   True
20:01:28 <ivanm> :o I thought it was disabled
20:01:33 <ivanm> @src CReal (==)
20:01:33 <lambdabot> Source not found. Sorry.
20:01:39 <ivanm> > pi :: CReal
20:01:40 <copumpkin> it's a lie for CReal
20:01:40 <lambdabot>   3.1415926535897932384626433832795028841972
20:01:44 <copumpkin> it cuts off at a certain precision
20:01:50 <ivanm> copumpkin: (==) `on` show ?
20:01:52 <copumpkin> otherwise it could never return True
20:02:00 <copumpkin> ivanm: probably something like that
20:02:12 <ivanm> copumpkin: that's what I was thinking; pretty sure it used to either error out or just return False ...
20:03:12 <enthymene> anyway. Like, if I had a function foo that was more general than flip.  Like, it meant "skip an argument" or "for arbitrary values of the first argument"
20:04:04 <enthymene> so for f x y = 2*x*y + y^2, foo f for some value a would give (\ x -> f x a)
20:04:06 <uorygl> > let f x = x - tan x in (pi :: CReal) == (f.f.f.f.f.f.f $ 3)
20:04:10 <lambdabot>   mueval-core: Time limit exceeded
20:04:14 <uorygl> :(
20:04:33 <uorygl> > let f x = x - tan x in (pi :: CReal) == (f.f.f $ 3)
20:04:35 <lambdabot>   False
20:04:50 <uorygl> > let f x = x - tan x in (pi :: CReal) == (f.f.ff $ 3.14159265)
20:04:51 <lambdabot>   Not in scope: `ff'
20:04:56 <uorygl> > let f x = x - tan x in (pi :: CReal) == (f.f.f.f $ 3.14159265)
20:04:59 <lambdabot>   mueval-core: Time limit exceeded
20:05:08 <uorygl> > let f x = x - tan x in (pi :: CReal) == (f.f.f $ 3.1415926535)
20:05:10 <lambdabot>   True
20:05:15 <uorygl> Aha! I fooled it!
20:05:15 <iaefai> I am trying to compile jhc, and it is having a trouble with happy giving some 'sed' error about -i may not be used with stdin. The error is here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23231#a23231    Any ideas on how to fix this?
20:09:40 <copumpkin> > let f x = x - tan x in f 3.1415926535
20:09:42 <lambdabot>   3.141592653589793
20:11:10 <ivanm> iaefai: what distro/OS?
20:11:19 <ivanm> I'm guessing youre using non-gnu sed which is stricter in what it does
20:11:20 <iaefai> mac SL
20:11:26 <iaefai> probably
20:11:40 <ivanm> yeah, that's probably it
20:11:57 <ivanm> see if you can hack the build system or get a different version of sed from somewhere...
20:12:08 <iaefai> oh I could get a different sed no doubt
20:12:45 <uorygl> > let f x = x - tan x in [pi, f.f.f $ 3] :: [CReal]
20:12:47 <lambdabot>   [3.1415926535897932384626433832795028841972,3.14159265358979323846264338328...
20:13:22 <uorygl> Toss a few more f's on and it'll be exact.  :P
20:13:37 <iaefai> ivanm: It looks like the gnu tool has an optional suffix, where as the bsd doesn't
20:13:59 <djahandarie> This pi trick has been going around all day!
20:13:59 <enthymene> hmm
20:14:02 * hackagebot gloss 1.0.0.1 - Painless 2D vector graphics, animations and simulations.  http://hackage.haskell.org/package/gloss-1.0.0.1 (BenLippmeier)
20:14:09 <ivanm> iaefai: *nod*
20:14:11 <enthymene> that pi trick would be cool for other continued fractions too.
20:14:14 <enthymene> like for the golden ratio
20:14:18 <ivanm> "Painless"? really?
20:14:22 <enthymene> I can't remember what it is, but it's in the Wizard book
20:14:36 <ivanm> Axman6: looks like ben is evolving a new animation package rather than cabalising anuplot...
20:14:47 <Axman6> bah!
20:14:48 <enthymene> anuplot?
20:14:49 <uorygl> djahandarie: it hasn't been going around; I've been repeating it.  :P
20:15:01 <uorygl> It maybe it's actually both.
20:15:03 <Axman6> unswplot has a crappy ring to it :P
20:15:14 <ivanm> Axman6: heh
20:15:14 <uorygl> Anyway, that pi trick also works for the golden ratio.
20:15:35 <ivanm> enthymene: a library Ben Lippmeier wrote/maintained (not sure which one) whilst at ANU
20:15:44 <ivanm> and that students use in the first year haskell class
20:15:52 <ivanm> he's at UNSW now however
20:16:02 * hackagebot gloss-examples 1.0.0.1 - Examples using the gloss library  http://hackage.haskell.org/package/gloss-examples-1.0.0.1 (BenLippmeier)
20:16:04 <Axman6> i think he wrote it for honours/possibly part of his PHD work
20:16:08 <ivanm> Axman6: but he's not doing any teaching or tutoring now that haskell is off the curriculum, right?
20:16:14 <ivanm> Axman6: *nod*
20:16:17 <Axman6> no idea
20:16:23 <uorygl> > let f x = x - (x^2 - x - 1)/(2x - 1) in f.f.f $ 2 :: CReal
20:16:24 <lambdabot>   No instance for (GHC.Num.Num
20:16:24 <lambdabot>                     (Data.Number.CReal.CReal -...
20:16:44 <uorygl> What?
20:17:01 <Axman6> 2*x?
20:17:10 <uorygl> > let f x = x - (x^2 - x - 1)/(2*x - 1) in f.f.f $ 2 :: CReal
20:17:11 <lambdabot>   1.6180344478216818642350557244174265450861
20:17:37 <uorygl> > (1 + sqrt 5)/2
20:17:38 <lambdabot>   1.618033988749895
20:17:48 <uorygl> > (1 + sqrt 5)/2 :: CReal
20:17:50 <lambdabot>   1.6180339887498948482045868343656381177203
20:17:53 <uorygl> > let f x = x - (x^2 - x - 1)/(2*x - 1) in f.f.f.f $ 2 :: CReal
20:17:54 <lambdabot>   1.6180339887499890970472967792907250532408
20:18:26 <uorygl> > let f x = x - (x^2 - x - 1)/(2*x - 1) in f.f.f.f.f.f $ 2 :: CReal
20:18:27 <lambdabot>   1.6180339887498948482045868343656381177203
20:18:30 <djahandarie> How efficient is that?
20:18:43 <djahandarie> Is there some crazy-ass fusion that turns it into something amazing? :P
20:18:45 <uorygl> The number of correct digits doubles with every f.
20:18:56 <uorygl> So going by that, I'd say it's pretty efficient.
20:19:04 <SamB_XP> > let f x = x - (x^2 - x - 1)/(2*x - 1) in iterate f
20:19:08 <lambdabot>   mueval-core: Time limit exceeded
20:19:11 <SamB_XP> > let f x = x - (x^2 - x - 1)/(2*x - 1) in iterate f 2
20:19:12 <lambdabot>   [2.0,1.6666666666666667,1.619047619047619,1.618034447821682,1.6180339887499...
20:19:57 <SamB_XP> > let f x = x - (x^2 - x - 1)/(2*x - 1) in drop 5 $ iterate f 2
20:19:58 <lambdabot>   [1.618033988749895,1.618033988749895,1.618033988749895,1.618033988749895,1....
20:20:02 <uorygl> Though it would also be plenty efficient to just divide really huge Fibonacci numbers.
20:20:26 <uorygl> Dost thou think I am not infallible?
20:20:39 <djahandarie> I have never seen that method of calculating pi though
20:20:39 <SamB_XP> > let f x = x - (x^2 - x - 1)/(2*x - 1) in drop 5 $ iterate f (2 :: CReal)
20:20:42 <lambdabot>   mueval-core: Time limit exceeded
20:20:45 <copumpkin> too many numbers in here
20:20:53 <djahandarie> I have seen arctan, never tan though
20:20:57 <uorygl> It's really not a very good way of calculating pi, since it requires you to calculate tan.
20:21:22 <SamB_XP> > let f x = x - (x^2 - x - 1)/(2*x - 1) in vconcat . map text . drop 5 $ iterate f (2 :: CReal)
20:21:23 <lambdabot>   Not in scope: `vconcat'
20:21:32 <uorygl> > 2 * arctan (1/0)
20:21:33 <lambdabot>   Not in scope: `arctan'
20:21:37 <uorygl> > 2 * atan (1/0)
20:21:38 <lambdabot>   3.141592653589793
20:21:41 <SamB_XP> > text "hi!"
20:21:42 <lambdabot>   hi!
20:21:47 <uorygl> Is that the arctan method of calculating pi?  :)
20:21:50 <ivanm> Axman6: "Gloss is a fork and cleanup of ANUPlot"
20:21:54 <SamB_XP> :t text "hi!"
20:21:55 <lambdabot> Doc
20:22:01 <Axman6> ivanm: ah, good to hear :)
20:22:06 <SamB_XP> @hoogle [Doc] -> Doc
20:22:06 <lambdabot> Text.PrettyPrint.HughesPJ cat :: [Doc] -> Doc
20:22:06 <lambdabot> Text.PrettyPrint.HughesPJ fcat :: [Doc] -> Doc
20:22:06 <lambdabot> Text.PrettyPrint.HughesPJ fsep :: [Doc] -> Doc
20:22:07 <Axman6> has it been cabalised?
20:22:08 <ivanm> Axman6: that's off the trac
20:22:14 <pikhq> o.O
20:22:14 <ivanm> Axman6: it's on hackage; what do you think? "[
20:22:17 <ivanm> * ;P
20:22:21 <Axman6> excellent
20:22:23 <ivanm> even has examples!
20:22:23 <SamB_XP> > let f x = x - (x^2 - x - 1)/(2*x - 1) in vcat . map (text . show) . drop 5 $ iterate f (2 :: CReal)
20:22:26 <lambdabot>   * Exception: stack overflow
20:22:38 <SamB_XP> > let f x = x - (x^2 - x - 1)/(2*x - 1) in vcat . map (text . show) . take 10 . drop 5 $ iterate f (2 :: CReal)
20:22:41 <lambdabot>   mueval-core: Time limit exceeded
20:22:49 <SamB_XP> > let f x = x - (x^2 - x - 1)/(2*x - 1) in vcat . map (text . show) . take 5 . drop 5 $ iterate f (2 :: CReal)
20:22:52 <lambdabot>   mueval-core: Time limit exceeded
20:22:59 <SamB_XP> > let f x = x - (x^2 - x - 1)/(2*x - 1) in vcat . map (text . show) . take 5 . drop 3 $ iterate f (2 :: CReal)
20:23:02 <lambdabot>   1.6180344478216818642350557244174265450861
20:23:02 <lambdabot>  1.61803398874998909704729677929...
20:23:12 <djahandarie> uorygl, haha, nah. I was talking about the Machin-like ones... pi/4 = 12arctan(1/49) + 32arctan(1/57) ....
20:23:17 <SamB_XP> hmm. leaves soemthing to be desired!
20:23:49 <uorygl> Newton's method can calculate ANYTHING!
20:23:54 <uorygl> Except not anything.
20:24:01 <SamB_XP> why does lambdabot even bother with having the pretty printing combinators in scope if she truncates output that much ?
20:24:27 <uorygl> Ask Terry Tao whether it can calculate anything or not.
20:24:44 <djahandarie> > 4 * (12 * arctan (1/47) + 32 * arctan (1/57) - 5 * arctan (1/239) + 12 * arctan (1/110443))
20:24:45 <lambdabot>   Not in scope: `arctan'Not in scope: `arctan'Not in scope: `arctan'Not in sc...
20:24:57 <SamB_XP> try "atan"
20:25:04 <enthymene> is there a way to do conditional module loading?  I'm not talking about import qualified, I mean, check to see if a module exists, if not, check that one...
20:25:06 <djahandarie> > 4 * (12 * atan (1/47) + 32 * atan (1/57) - 5 * atan (1/239) + 12 * atan (1/110443))
20:25:07 <lambdabot>   3.1832593097909028
20:25:25 <djahandarie> oops
20:25:33 <djahandarie> > 4 * (12 * atan (1/49) + 32 * atan (1/57) - 5 * atan (1/239) + 12 * atan (1/110443))
20:25:34 <lambdabot>   3.141592653589793
20:25:43 <SamB_XP> enthymene: don't they all exist ?
20:25:50 <SamB_XP> unless you typo?
20:25:55 <enthymene> umm
20:25:57 <enthymene> like
20:26:01 * uorygl ponders calculating pi using only Newton's method and basic arithmetic.
20:26:09 <enthymene> try to import a module that doesn't exist and you get an error
20:26:19 <SamB_XP> uorygl: you'll need the CIRCLE command
20:26:29 <SamB_XP> or ... did you not actually mean BASIC?
20:26:38 * uorygl coughs.
20:26:38 <iaefai> JHC compiled on 6.12! Me happy
20:26:49 <uorygl> I meant a four-function calculator with lots of memory slots!
20:26:50 <ivanm> iaefai: what did you end up doing?
20:27:06 <iaefai> compiled gnu sed and put its location first in the path
20:27:12 <iaefai> But it is something that should be fixed
20:27:54 <iaefai> I am making libs right now
20:28:12 <ivanm> fair enough
20:28:23 <iaefai> Now the reason why I am looking at jhc is there was a mention of it compiling for the iphone out of the perverbial box
20:28:23 <ivanm> couldn't you get gnu sed from macports or something?
20:28:33 <iaefai> ivanm: I try not to use macports
20:28:35 <ivanm> iaefai: oh, and is the problem with happy or with jhc's build system?
20:28:40 <ivanm> iaefai: *nod* fair enough
20:28:45 <iaefai> I think it was happy specifically
20:29:05 <ivanm> I think that (iphone compilation) is a goal, but I haven't heard anything definite about it being able to do it yet
20:29:07 <iaefai> Crappy, I ended up with a build error
20:29:33 <iaefai> ivanm: From the wiki: "Jhc has full support for cross compiling to the iPhone. Information on how to do so is in the jhc manual under Cross Compilation. Basically, you just add the following to your ~/.jhc/targets.ini"
20:29:52 <SamB_XP> s/perverbial/proverbial/
20:30:05 <iaefai> SamB_XP: Thank you, I was just being lazy to correct it.
20:31:03 * uorygl continues pondering.
20:31:27 <ivanm> iaefai: :o
20:31:42 <iaefai> lib/containers/Data/Sequence.hs:314:16: Parse error
20:32:43 <iaefai> {-# SPECIALIZE INLINE deep :: Digit (Elem a) -> FingerTree (Node (Elem a)) -> Digit (Elem a) -> FingerTree (Elem a) #-}
20:32:59 <iaefai> Looks like INLINE is the parse error
20:33:25 <Axman6> i'd move INLINE into another {-##-} comment
20:33:58 <iaefai> Are those comments special in some way?
20:34:25 <copumpkin> yes
20:34:36 <iaefai> Same error with {-# SPECIALIZE {-# INLINE deep #-} :: Digit (Elem a) -> FingerTree (Node (Elem a)) -> Digit (Elem a) -> FingerTree (Elem a) #-}
20:34:39 <copumpkin> no
20:34:49 <copumpkin> {-# SPECIALIZE type #-}
20:34:55 <copumpkin> {-# INLINE name #-}
20:35:10 <ivanm> copumpkin: looks like it's just a functiont ype
20:35:20 <ivanm> oh, wait, I get what you're saying
20:35:43 <iaefai> copumpkin: I am not sure how I would put that in this source
20:35:43 <ivanm> would that be still {-# SPECIALIZE deep :: ... #-} ?
20:35:49 <copumpkin> yep
20:36:02 <ivanm> and then just {-# INLINE deep #-}
20:36:09 <copumpkin> iaefai: just have two pragma blocks
20:36:11 <copumpkin> no nesting like you did
20:36:37 <iaefai> But we have two speical things, wouldn't that duplicate the line deep?
20:36:49 <ivanm> no
20:36:56 <copumpkin> ?
20:37:00 <Axman6> ivanm: damn i'm glad Ben's released this code, I remember how nice it was to use ANUPlot now :)
20:37:08 <ivanm> heh
20:37:13 <ivanm> Axman6: nicer than chart?
20:37:27 <ivanm> Axman6: I wonder if it would be a good replacement for chart to put into criterion or something
20:37:28 <Axman6> never used chart, but it's a GTK thing isn't it?
20:37:33 <ivanm> and thus avoid gtk2hs
20:37:35 <ivanm> Axman6: yeah
20:37:40 <Axman6> fuck yes it would
20:38:08 * ivanm waits for hackage to build docs so he can see what the API is like
20:38:11 <Axman6> damn, someone needs to do this... ivanm! you! you've got nothing better to do than sit here on IRC, get to it :P
20:38:18 <ivanm> Axman6: maybe you should suggest it to bos or write a patch and submit it
20:38:31 <Axman6> cabal install it, with documentation: True in your ~/.cabal/config
20:38:36 <ivanm> Axman6: heh; I'm busy looking for and reading papers! didn't you know that? :p
20:38:45 <iaefai> okay, let me ask this more explicitly: What do I do exactly to this per your suggestion? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23232#a23232
20:38:47 <ivanm> Axman6: haven't gotten that installed yet here...
20:39:02 <ivanm> ahhh...
20:39:02 <Axman6> scanning papers isn't reading them :P
20:39:12 <copumpkin> iaefai: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23232#a23233
20:39:15 <ivanm> iaefai: remove the INLINEs from the SPECIALIZE pragmas
20:39:25 <uorygl> > let f (pie, asinpie, sqrt1minuspi2, sinpie, cospie) = (pie - asinpie * sqrt1minuspi2, asinpie - sinpie/cospie, sqrt1minuspi2 + pie^2, sinpie - asinpie * sqrt1minuspi2, cospie - pie/2 - asinpie * sqrt1minuspi2) in f.f.f $ (3,2,0,0,-1)
20:39:26 <lambdabot>   (-51.0,1.1818181818181817,243.0,-54.0,-50.5)
20:39:37 <uorygl> I'm pretty sure I don't know what I'm doing.
20:39:48 <ivanm> copumpkin: though IIRC, that means that deep won't be inlined since its polymorphic, right?
20:39:58 <ivanm> Axman6: no, I finished scanning them yesterday
20:39:59 <iaefai> ok, merci
20:40:04 <ivanm> now I'm looking for more online
20:40:05 <Axman6> heh
20:40:15 <copumpkin> polymorphic functions can be inlined
20:40:28 <ivanm> oh, OK
20:40:34 <ivanm> thought they couldnt' for some reason...
20:41:18 <iaefai> ok, I have another case where we have the same problem with an INLINE but it is on its own now: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23232#a23234
20:41:36 <copumpkin> make a separate function
20:41:37 <iaefai> Isn't this the same as the previous INLINE on the line 1 in second paste?
20:42:37 <idnar> copumpkin: won't that make the inlining pointless?
20:42:52 <copumpkin> I don't think so
20:43:02 <copumpkin> but maybe?
20:43:03 <idnar> I guess I don't really know how inlining works
20:43:25 <idnar> but I figure if you have func = inlinedFunc, then inlinedFunc gets inlined into func, and it's as if you just defined func directly
20:43:34 <copumpkin> well, if func = anotherFunc with no other work
20:43:36 <idnar> but func won't be inlined into other stuff
20:43:47 <copumpkin> it's pretty trivial
20:43:57 <uorygl> If I have GHC installe, where will Network/Socket.hsc be located?
20:44:00 * copumpkin shrugs
20:44:16 <ivanm> uorygl: is that part of GHC?
20:44:24 <ivanm> sounds more like it's part of the Network library
20:44:37 <ivanm> *network
20:44:39 <ivanm> and yup, it is
20:44:55 <iaefai> It looks like if I move the inline before the instance it is fine
20:45:09 <uorygl> So where's the file?
20:45:25 <ivanm> wherever you download the source for network
20:45:32 <ivanm> *download and unpack
20:45:52 <ivanm> uorygl: why?
20:46:44 <uorygl> I want to see the C side of sendAncillary and recvAncillary.
20:47:25 <ivanm> uorygl: get the source from hackage, unpack and look!
20:47:33 <ivanm> Axman6: so can anuplot/gloss be used for plots?
20:47:38 <ivanm> can't find anything obvious in the docs...
20:47:52 <Axman6> ivanm: testing it now. it needs antialiasing
20:48:01 <ivanm> what do you mean?
20:48:05 <Axman6> you'd have to do it from scratch, but it shouldn't be hard
20:48:09 <uorygl> Maybe I can do without it.
20:48:12 <Axman6> the plots looks ugly
20:48:19 <ivanm> @slap Ben
20:48:19 * lambdabot secretly deletes Ben's source code
20:48:25 <ivanm> he's using yank spelling of Colour!
20:48:37 <ivanm> (and he should really be using roconnor's colour library)
20:49:05 <Axman6> yes indeed
20:49:13 <ivanm> since he's using pretty much the same definitions, etc. anyway
20:49:20 <ivanm> Axman6: you know him, you tell him ;-)
20:49:30 <Axman6> i don't know him
20:49:45 <ivanm> :o thought you did...
20:49:55 <Axman6> we've talked more in IRc than IRL
20:49:59 <ivanm> heh
20:49:59 <Axman6> C*
20:50:01 <ivanm> what's his nick?
20:50:23 * ivanm can't find anything in the docs that looks remotely like an API for drawing plots
20:50:34 <uorygl> sock is obviously the socket, level is always SOL_SOCKET, ty is either SCM_RIGHTS or SCM_CREDENTIALS, I don't know what flags is, datum is "the data portion", and len is the length of *something*, probably the data portion.
20:50:35 <Axman6> benl23
20:51:30 <uorygl> (Is it okay if I cat /home/uorygl/brain > /dev/freenode/#haskell?)
20:51:57 <ivanm> uorygl: no, we don't like multi-line pastes
20:52:05 <ivanm> preflex: seen benl23
20:52:05 <preflex>  benl23 was last seen on #ghc 11 days, 1 hour, 15 minutes and 21 seconds ago, saying: :)
20:52:23 <iaefai> Hmm, jhc is missing Data.Functor: Error: Module not found: Data.Functor
20:52:42 <grem1> DCC SEND "startkeylogger" 0 0 0
20:53:13 <copumpkin> fucking assholes
20:53:30 <ivanm> copumpkin: now, don't hold back, tell us what you _really_ think!
20:53:31 <ivanm> ;-)
20:53:31 <Axman6> ?
20:53:40 <copumpkin> noreply_, tux21b: you probably want to fix that
20:53:41 <ivanm> Axman6: it's a common attack vector for old modems
20:54:18 <uorygl> Okay, len is the length of all the following combined: len, level, ty, datum.
20:54:26 <ivanm> Axman6: every now and then someone will pop into an IRC channel, do a DCC send (which some people have an auto-download option sit) which then kills their modems
20:54:49 <Axman6> yeah i've seen it a number of times
20:54:53 <ivanm> copumpkin: he'll probably be back in about 5 min as well...
20:55:05 <Axman6> ivanm: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23235#a23235 looks pretty cool when you run it :)
20:55:27 <copumpkin> an op should step up and ban him before that happens
20:55:34 <ivanm> Axman6: right, so what we need is a wrapper library around gloss for line-plotting purposes
20:55:39 <ivanm> @where ops
20:55:40 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver monochrom
20:55:45 <Axman6> aye
20:56:01 <dcoutts_> ivanm: hmm?
20:56:05 <Axman6> also, i wish there was a way to do relative coordinates in Gloss
20:56:11 <ivanm> Axman6: chart produces nice plots, but it's API is fugly and the fact that it depends on the non-cabalised gtk2hs sucks
20:56:22 <ivanm> dcoutts_: just getting someone ready in case the DCC spammer comes back
20:56:25 <Axman6> so, when  you resize the window, it scales the drawing
20:56:29 <ivanm> since they tend to pop in and out for a while
20:56:44 <ivanm> grem1 (~grem@ool-44c49b6d.dyn.optonline.net)
20:56:48 <ivanm> ^^ nick he used
20:56:52 <copumpkin> it'd be nice to be able to ban specific patterns in messages themselves
20:57:01 <copumpkin> so we could avoid being reactive
20:57:09 <ivanm> copumpkin: yeah, but like most internet related things IRC wasn't developed with security in mind
20:57:18 <copumpkin> if someone says "DCC SEND" it wouldn't get pasted to the channel, and would instead notify an op
20:57:21 <copumpkin> yeah
20:57:28 <copumpkin> *posted
20:58:06 <ivanm> copumpkin: maybe if we can get lambdabot to do it...
20:58:16 <copumpkin> that would still allow the message to show up
20:58:18 <uorygl> lambdabot can't suppress channel messages.
20:58:22 <copumpkin> the IRCd would need to change
20:58:26 <ivanm> copumpkin: true, but get lambdabot to auto-kick!
20:58:39 <uorygl> Get lambdabot to auto-notify-an-IRC-op.  :)
20:58:49 <ivanm> uorygl: but that's boring!
20:58:53 <copumpkin> it could autoban without kicking, and notify an op
20:59:00 <ivanm> whatever
20:59:06 <ivanm> kicking sounds more violent though...
20:59:08 <copumpkin> that way the user would be temporarily silenced until an op has a chance to notice
20:59:16 <ivanm> copumpkin: that would require that lambdabot be an op though, wouldn't it?
20:59:22 <copumpkin> yep
20:59:40 <ivanm> copumpkin: go forth and implement!
20:59:41 <ivanm> ;-)
20:59:48 <copumpkin> no thanks
20:59:51 <copumpkin> I have more awesome things to do
20:59:55 <ivanm> anyway, looks like [s]he isn't coming back
21:00:05 * ivanm might head off soon as well
21:00:31 <ivanm> Axman6: how does gloss' API compare to ANUPlots'?
21:00:47 <ivanm> just wondering how much of a copy + namechange it is atm rather than a rewrite
21:00:51 <SamB_XP> ivanm: you can't bring yourself to spell it correctly ?
21:01:04 <ivanm> SamB_XP: spell what correctly?
21:01:10 <Axman6> seems pretty similar, we never really got into too much depth with ANUPlot though, we used a wrapper around it (I went and dove into it thi=ough :P)
21:01:13 <Axman6> -=
21:01:14 <SamB_XP> GNUPlot
21:01:22 <SamB_XP> oh, some other thing really ?
21:01:26 <Axman6> yes
21:01:31 <SamB_XP> thank God
21:01:33 <Axman6> @hackage gloss
21:01:33 <lambdabot> http://hackage.haskell.org/package/gloss
21:01:41 <Axman6> ANUPlot -> Gloss
21:02:06 <ivanm> Axman6: so a wrapper around a wrapper? :p
21:02:12 <Axman6> yep
21:02:26 <Axman6> learning how to draw graphics had nothing to do with 1100
21:02:53 <ivanm> yup
21:03:38 <ivanm> SamB_XP: anyway, how dare you think so little of me!
21:03:38 <ivanm> why would you think I'd deliberately mis-spell gnuplot?
21:04:01 <SamB_XP> ivanm: because it is so horrifying you can't stand to see it spelt correctly
21:04:39 <ivanm> heh
21:07:50 <uorygl> So, there's this C function that wants me to give it a pid_t, a uid_t, a gid_t, a socklen_t, two ints, and the total length of all of those.
21:08:09 <uorygl> In bytes, of course.
21:08:22 <uorygl> How can I find out what that length is?
21:08:54 <Axman6> this doesn;t sound like a haskell question to me
21:09:06 <uorygl> How, in Haskell, can I find out what that length is?
21:09:14 <ivanm> uorygl: maybe go through the FFI chapter of RWH
21:09:16 <ivanm> @where rwh
21:09:16 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
21:09:17 <Axman6> the length of what?
21:09:22 <ivanm> it talks about stuff like that
21:09:24 <copumpkin> @src Storable
21:09:24 <lambdabot> Source not found. Just what do you think you're doing Dave?
21:09:32 <ivanm> Axman6: the data he's passing to the C function
21:09:41 <ivanm> @hoogle Storable
21:09:41 <lambdabot> module Data.Array.Storable
21:09:41 <lambdabot> module Foreign.Storable
21:09:41 <lambdabot> Foreign.Storable class Storable a
21:09:56 <copumpkin> @hoogle sizeof
21:09:56 <lambdabot> Foreign.Storable sizeOf :: Storable a => a -> Int
21:09:56 <lambdabot> Network.Socket.Internal sizeOfSockAddr :: SockAddr -> Int
21:09:56 <lambdabot> Network.Socket.Internal sizeOfSockAddrByFamily :: Family -> Int
21:10:44 * ivanm heads off for the day
21:10:44 <Axman6> @more
21:10:49 <ivanm> long weekend! \o/
21:10:55 <Axman6> whoooo
21:10:58 <ivanm> but it sounds like it's raining outside :s
21:11:02 <ivanm> (as in heavily)
21:11:08 <ivanm> yay for walking home in the rain :s
21:11:17 <muri_one> if a cabal file has changed the build process tells me i need to re-configure. do I have to specify my configure flags again? is tehre some way not to?
21:11:20 <uorygl> I suppose that Storable stuff will be useful if I can find Haskell types corresponding to those C types.
21:11:44 <ivanm> muri_one: yes, you have to give them again
21:11:56 <ivanm> just use your shell history if you can
21:12:02 <ivanm> uorygl: yup
21:12:19 <dcoutts_> muri_one: no, at the moment you need to specify all the configure flags again. There's an open ticket on a feature to save them.
21:13:34 <uorygl> Any idea where I would find equivalent types for socklen_t, pid_t, uid_t, and gid_t?
21:13:53 * ivanm randomly guesses that they are C ints
21:14:05 <uorygl> That would be useful.
21:14:38 <copumpkin> they probably are, but you probably shouldn't assume it
21:14:39 <SamB_XP> ivanm: not ints -- just integral types ... probably!
21:14:53 <Axman6> bos: you around?
21:15:14 <ivanm> SamB_XP: whatever *shrug*
21:15:25 <ivanm> uorygl: why not actually look at the C code/docs and find out!
21:15:29 <ivanm> preflex: seen bos
21:15:29 <preflex>  bos was last seen on #haskell 1 day, 11 hours, 10 minutes and 42 seconds ago, saying: yummy attoparsec performance goodness: http://www.serpentine.com/blog/2010/03/03/whats-in-a-parser-attoparsec-rewired-2/
21:15:35 <ivanm> Axman6: his blog is back up though!
21:15:38 <Axman6> bah
21:15:47 <uorygl> I don't really know where to find that stuff.
21:15:54 <ivanm> Axman6: humbug! :p
21:16:18 <uorygl> Oh, the joys of making Haskell and C work together...
21:16:20 <ivanm> oh, great, I've just realised... I'm now procrastinating about _going home_ :s
21:16:32 <ivanm> uorygl: have you read the FFI chapter in RWH?
21:16:35 <Axman6> ivanm: the only problem with using Gloss is that afaik, there's no way to save the data to an image... but, i would be done quite easily if it were all saved to a file
21:16:38 <uorygl> ivanm: I think I have.
21:16:51 <Axman6> uorygl: it sounds to me like you're reinventing the wheel
21:16:54 <uorygl> Network.Socket doesn't even provide all the constants I need.  It provides sCM_RIGHTS but not sCM_CREDENTIALS.
21:17:00 <ivanm> Axman6: yeah...
21:17:14 <copumpkin> I hate that cONSTANT cONVENTION
21:17:19 <ivanm> Axman6: opengl doesn't provide a way of saving images?
21:17:27 <iaefai> In this file: http://darcs.haskell.org/packages/containers/_darcs/inventory  there is an entry that says "The package uses mkNoRepType and Data.Functor, which were not in the stable branch of base-4"  How can I find out more about this as it is important to build the libs with jhc
21:17:37 <uorygl> Well, the thing I'm trying to create is a nice-looking wrapper for sending and receiving ancillary data over Unix domain sockets.
21:17:40 <Axman6> hmm, it should be damn easy to make a helper program that takes in a file of Gloss Picture objects, and displays them
21:17:44 <ivanm> cOPUMPKIN: oH? aNY pARTICULAR rEASON fOR dOING sO?
21:17:45 <ivanm> ;-)
21:17:48 <Axman6> ivanm: none that i know of
21:18:02 <ivanm> Axman6: :( then yeah, that is a problem with gloss vs chart
21:18:03 * Axman6 might do that now
21:18:14 <copumpkin> ivanm: iT'S jUST rEALLY uGLY
21:18:18 <Axman6> should only take a few minutes
21:18:21 <ivanm> iaefai: ask the developer?
21:18:31 <ivanm> copumpkin: aGREED
21:18:46 <ivanm> Axman6: then take those few minutes!
21:18:48 <iaefai> ivanm: I think I am looking for the darcs repository, well the viewer for it, I know the url of the files themselves
21:19:01 <Axman6> i'm about to :)
21:19:18 <ivanm> Axman6: heh
21:19:41 <uorygl> Is there some ultra-brief summary of RWH's description of FFI?
21:19:42 * ivanm heads off
21:19:43 <pastorn> anyone has this function laying around?
21:19:45 <pastorn> substitute :: (Eq a) => [a] -> [a] -> [a] -> [a]
21:19:47 <bos> dcoutts_: can i query a package to see what flags it accepts from the command line?
21:19:59 <Axman6> argh, there's no Read instance for Picture!
21:20:01 <ivanm> uorygl: it's not a description, it's a mini-tutorial on the FFI
21:20:04 <copumpkin> pastorn: that tells us nothing :)
21:20:06 <ivanm> Axman6: :o
21:20:10 <pastorn> substitute from to s = undefined
21:20:11 <Axman6> ARGH!
21:20:13 <copumpkin> some types are descriptive :P
21:20:15 <ivanm> Axman6: custom Show rather than deriving?
21:20:15 <Axman6> damn you ben!
21:20:24 <pastorn> copumpkin: better?
21:20:26 <Axman6> i think it's just derived
21:20:33 <Axman6> but there's no Read
21:20:34 <copumpkin> pastorn: no
21:20:46 <dcoutts_> bos: sort-of, cabal info tells you that. However it doesn't work for a local package I think, and it's not an easily parsable format.
21:20:49 <ivanm> Axman6: yup, it's derived
21:20:57 <pastorn> substitute "xx" "yy" = "abcxxcxx" == "abcyycyy"
21:20:58 <ivanm> so it really should have Read and Ord instances as well
21:21:02 <pastorn> oh
21:21:08 <pastorn> substitute "xx" "yy" "abcxxcxx" == "abcyycyy"
21:21:14 <dcoutts_> bos: if that's not helpful, feel free to file a ticket describing what would be useful
21:21:23 <bos> dcoutts_: no, that does the trick for now thank you.
21:21:25 * ivanm wishes people derived as many types as they can for exported data types
21:21:32 <copumpkin> pastorn: substitute "xx" "yy" "abxxxcd" = ?
21:21:40 <ivanm> Axman6: bos is here^^
21:21:42 <Axman6> bos: any chance of you adding something to Criterion to use Gloss to display charts? should be pretty simple indeed (and a great alternative for people who can't get gtk2hs working for whatever reason)
21:21:49 <Axman6> ivanm: way ahead of you :P
21:21:51 <pastorn> copumpkin: "abcyycyy"
21:21:52 <ivanm> heh
21:21:55 <bos> Axman6: what's gloss?
21:21:58 <pastorn> oh
21:22:00 <pastorn> ehm
21:22:08 <pastorn> copumpkin: "abyyxcd"
21:22:08 <Axman6> @hackage gloss
21:22:08 <lambdabot> http://hackage.haskell.org/package/gloss
21:22:13 <ivanm> bos: Ben Lippmeier just released it
21:22:17 <copumpkin> pastorn: eugh :P
21:22:23 <ivanm> it uses OpenGL
21:22:27 <uorygl> More importantly, what's substitute "xx" "yz" "abxxxcd"?
21:22:31 <uorygl> Er.
21:22:33 <muri_one> ghc sure uses a lot of memory when compiling. likes to trigger the oomkiller if i also happen to be running firefox.
21:22:34 <uorygl> More importantly, what's substitute "xx" "yx" "abxxxcd"?
21:22:44 <pastorn> uorygl: "abyzxcd"
21:22:49 <copumpkin> o.O
21:23:14 <pastorn> uorygl: undefined behaviour :p
21:23:21 <pastorn> uorygl: think 'C'
21:23:22 <ivanm> pastorn: I doubt there's one available
21:23:32 <copumpkin> we don't like undefined behavior here
21:23:38 <pastorn> hehe
21:23:45 <ivanm> you'd probably want to do some parsing, etc. to do it properly
21:23:46 * copumpkin would expect "abyxcd" given pastorn's earlier message
21:23:52 <pastorn> hmm... i'll try to make it behave like vim
21:24:14 <ivanm> copumpkin: I would think either "abyxxcd" or "abyyxcd"
21:24:24 <pastorn> i think i'll do recursive stripPrefix until i reach []
21:24:26 <copumpkin> oh yeah, yyx, sorry
21:24:29 <Axman6> bos: i'm working on a (super simple) program to take a file with Gloss objects in it, and display them, so if criterion could just produce such files, everything would be awesome, and the birds would sing for joy :)
21:24:53 <copumpkin> but that would give odd behavior
21:25:00 <ivanm> Axman6: would this file be a normal image file?
21:25:04 <copumpkin> substitute "xx" "xxxx" "abxxcd"
21:25:04 <bos> Axman6: short answer: no
21:25:12 <ivanm> e.g. to put into blogs, etc.
21:25:31 <ivanm> copumpkin: stop being evil!
21:25:31 <bos> Axman6: longer answer: writing a chart library is a lot more work than just having a vector graphics library, and i'm not going to do that, sorry.
21:25:32 <Axman6> ivanm: could be, but it wouldn't exactly be very meaningful
21:25:33 <pastorn> copumpkin: "abxxcd"
21:25:42 <pastorn> copumpkin: like vim
21:25:46 <copumpkin> pastorn: okay, that makes no sense to me
21:25:48 * ddarius would actually prefer birds to sing less.
21:25:59 <Axman6> bos: righto. if I and possibly others could write one, might it be possible?
21:26:03 <ivanm> bos: what about if Axman6 wrote a chart-wrapper library and gave you patches for criterion?
21:26:19 <bos> Axman6: i guess.
21:26:24 <Axman6> Axman6 and ivanm*
21:26:26 <Axman6> >_>
21:26:26 <pastorn> copumpkin: write abcxxd on a line in vim, then :s/xx/xxxx/g
21:26:35 <ivanm> ddarius: put poison into some birdseed, leave in a convenient place, then enjoy the silence! :p
21:26:37 <bos> ivanm: we're talking about a lot of work here, you understand, right?
21:26:39 <ivanm> Axman6: ... maybe ...
21:26:55 <ivanm> bos: I'll just proof-read Axman6's code :p
21:27:02 <Axman6> pfft
21:27:13 * ivanm has a lot of other code to write
21:27:20 <Axman6> as if
21:27:21 <Axman6> :P
21:27:28 <copumpkin> pastorn: and that does one level of substitution, not what you wrote
21:27:47 <copumpkin> it'd be amusing to have it generate an infinite string though
21:27:59 <pastorn> copumpkin: quiet, you
21:28:05 <ivanm> 1. update graphviz, 2. update sourcegraph (a _lot_ to do there), 3. generic graph library, 4. finish off re-implementing nauty in haskell, 5. finish latin squares library
21:29:14 <pastorn> copumpkin: :s/x/xx/g "xx" == "xxxx"
21:29:25 <ivanm> Axman6: oh, and then there's all the code I need to write for my PhD, whenever I actually start writing some for that
21:29:46 <ivanm> Axman6: better idea: organise an ozhaskell hackathon and a few of us can try and bash one out over a weekend
21:30:11 <ivanm> Axman6: maybe get it done at unsw so we can get ben involved as well
21:30:31 <Axman6> heh
21:30:34 <Axman6> maybe
21:31:04 <ivanm> and then if we can convince dons to come down under at the same time... >_>
21:32:35 <ivanm> Axman6: why don't you go and send an email asking if people would be interested in an aussie hackathon to -cafe (and I can chime in when I get home)?
21:32:41 <uorygl> So is .hsc the same thing as .c?
21:32:53 <Axman6> no
21:32:55 <ivanm> not quite IIUC
21:32:58 <ivanm> it's haskellian C
21:33:06 <uorygl> What's so Haskish about it?
21:33:23 <ivanm> http://www.haskell.org/ghc/docs/latest/html/users_guide/hsc2hs.html
21:33:42 <pastorn> copumpkin: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23237#a23237
21:34:17 <SamB_XP> Cish Haskell, I thought ?
21:34:28 <ivanm> http://en.wikibooks.org/wiki/Haskell/FFI
21:34:34 <ivanm> SamB_XP: or that
21:34:37 * uorygl just makes it a .c file.
21:34:43 <SamB_XP> possibly you're thinking of .chs or something ?
21:34:58 <ivanm> uorygl: ^^ have a look at that wikibook link
21:35:01 <ivanm> SamB_XP: yeah
21:35:02 * uorygl calls it hicpsock.c
21:35:26 * ivanm heads off
21:35:29 <ivanm> bye all
21:35:33 <aavogt> for real
21:35:38 <aavogt> bye ivanm
21:35:53 <ivanm> aavogt: yes, I'm going for real this time ;-)
21:37:14 <uorygl> Hmm, I think I'll just send all this as a mailing list post.
21:39:45 <Saizan> is it normal to expect an huge memory use if you're lexing over String or am i just doing it wrong?
21:42:30 <SamB_XP> Saizan: how are you doing it ?
21:43:13 <Saizan> with a simple StateT (Position,String) Maybe monad
21:44:05 <SamB_XP> maybe you should use either the Lexer library or an alex-generated lexer?
21:44:29 * hackagebot gloss 1.0.0.2 - Painless 2D vector graphics, animations and simulations.  http://hackage.haskell.org/package/gloss-1.0.0.2 (BenLippmeier)
21:44:33 <Saizan> maybe so, alex works over String?
21:45:18 <Axman6> isn't that the point of it?
21:45:41 <aavogt> it has wrappers for working over bytestrings too
21:45:42 <Saizan> i thought the point of it was lexing :)
21:45:51 <SamB_XP> I believe alex can work over anything that can be considered to be composed of characters?
21:53:28 <cads> > let squares = [x^2|x<-[1..]]; square n = (last $ takeWhile (<= n) squares) == n in map (\x-> (x,square x)) [1..10]
21:53:29 <lambdabot>   [(1,True),(2,False),(3,False),(4,True),(5,False),(6,False),(7,False),(8,Fal...
21:55:18 <cads> This is a pretty inefficient way of computing whether a number is square, but I was wondering; during the map, are the values of square computed from scratch with each new number, or is the list held in memory?
21:56:36 <aavogt> squares stays in memory
21:57:35 <aavogt> if you want it to be recomputed (maybe save space), define it inside the square function
22:04:43 <uorygl> @docs Foreign
22:04:43 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Foreign.html
22:07:22 <cads> aavogt: I was mostly worried about having to recompute a lot of squares for larger numbers
22:09:25 <uorygl> It looks like if I want a pointer to some data, I need to allocate a pointer and poke the data into it.
22:10:31 <uorygl> Which is what alloca can do for me.
22:10:33 <uorygl> Is that right?
22:12:24 <Saizan> alloca frees the pointer after the continuation returns
22:12:39 <uorygl> Well, I think that's what I want.
22:13:04 <Saizan> then go for it :)
22:13:30 <Saizan> you still have to poke the data iirc
22:13:37 <uorygl> Right.
22:17:47 * uorygl sends a hopeful email to the mailing list about all this.
22:19:25 <copumpkin> ihope? :P
22:19:53 <uorygl> That's me!
22:25:20 <uorygl> Dead affe?  What is affe?
22:26:52 <SamB_XP> > 0xbeef - 0xaffe
22:26:53 <lambdabot>   3825
22:27:12 <SamB_XP> > showHex 3825 ""
22:27:13 <lambdabot>   "ef1"
22:27:25 <SamB_XP> hmm
22:27:31 <nzqrc> hey haskellers, does anyone know why GHC is requiring an old version of GCC when installing with apt-get?
22:27:33 <SamB_XP> > 0xbeef `xor` 0xaffe
22:27:34 <lambdabot>   Ambiguous type variable `t' in the constraint:
22:27:34 <lambdabot>    `Data.Bits.Bits t'
22:27:34 <lambdabot>      a...
22:27:42 <SamB_XP> > 0xbeef `xor` 0xaffe :: Int
22:27:43 <lambdabot>   4369
22:28:17 <SamB_XP> > showHex 4369 ""
22:28:18 <lambdabot>   "1111"
22:31:48 <Axman6> > showHex 123 "hello"
22:31:50 <lambdabot>   "7bhello"
22:32:29 <uorygl> > showHex 57005 " people can read hex"
22:32:30 <lambdabot>   "dead people can read hex"
22:33:06 <Younder> hexed are you?
22:33:14 <Gracenotes> > showIntAtBase 2 intToDigit 100 ""  -- I always disliked this
22:33:15 <lambdabot>   "1100100"
22:33:32 <uorygl> @type showIntAtBase
22:33:32 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
22:33:46 <Younder> ugly
22:33:47 <Gracenotes> well, always, for the years upon years I've used Haskell
22:33:52 <Gracenotes> -.-
22:34:06 <Gracenotes> this one's even worse
22:34:08 <Gracenotes> @type readInt
22:34:09 <lambdabot> forall a. (Num a) => a -> (Char -> Bool) -> (Char -> Int) -> String -> [(a, String)]
22:34:32 <uorygl> It's not as bad as Socket -> Int -> Int -> Int -> Ptr a -> Int -> IO (), though.
22:34:33 <Younder> Char -> Bool ?
22:35:28 <Gracenotes> isDigit
22:35:31 <uorygl> > ord '0'
22:35:32 <lambdabot>   48
22:35:35 <Axman6> uorygl: indeed, i still think you must be reinventing the wheel. what function are you wrapping?
22:35:55 <uorygl> Axman6: sendAncillaryData and recvAncillaryData, if I remember correctly.
22:36:03 <SamB_XP> wait, shouldn't readInt need a radix as well ?
22:36:05 <uorygl> s/Data//g
22:36:13 <Axman6> :\
22:36:16 <SamB_XP> oh, wait, that's the "a"
22:36:27 <Gracenotes> hm, isDigit is for lexing, so you don't end up consuming the comma when you do parse (434, 302)
22:36:44 * hackagebot clientsession 0.2.0.1 - Store session data in a cookie.  http://hackage.haskell.org/package/clientsession-0.2.0.1 (MichaelSnoyman)
22:36:46 * uorygl consumes the comma.
22:36:58 <SamB_XP> uorygl: how does it taste ?
22:37:48 <uorygl> It reminds me of that comma apple I ate once.
22:38:20 <Gracenotes> some commas taste dissonant
22:38:59 <ivanm> Axman6: send the email?
22:39:05 <Axman6> no
22:39:26 <Axman6> if we were going to do, i'd eant to wait until the mid semester holidays
22:39:30 <uorygl> A guy named Pythagoras once gave me a comma that tasted very dissonant.
22:39:40 <uorygl> I'm betting he was a wolf in disguise.
22:39:40 <ivanm> Axman6: got to start getting it organised _now_ though
22:40:14 <Axman6> hmm, good idea
22:40:18 <Axman6> might do it over the weekend
22:40:28 * ivanm isn't in the habit of having bad ones
22:41:04 <ivanm> see if we can get TacticalGrace to get rooms, etc. at unsw, as there's probably more people there than here
22:41:53 <Axman6> aye
22:52:18 <Axman6> 13 bytes per number it seems
22:52:29 <Axman6> whoops
22:53:26 <o-_-o> Why does Ocaml have object oriented stuff and haskell doesn't ?
22:53:44 <Axman6> because OOP isn't a pure paradigm
22:54:21 <p_l> o-_-o: I heard that even rather seasoned users of OCaml tend to avoid OOP parts of it
22:54:39 <p_l> not because it's impure or anything, but because for most of the time, it stinks
22:54:43 <p_l> ;-)
22:54:48 <o-_-o> :-)
22:55:09 <Cale> http://www.youtube.com/watch?v=kofSYRB-vh4 -- Most painful toy hack ever :)
22:55:18 <copumpkin> yeah, the only people who use the O in ocaml are JDH when he's trying to show how much better it is than haskell
22:56:00 <p_l> they mentioned something about most OOP code being from new hires without much OCaml experience. It was some financial company that wasn't really into software, they switched to OCaml from an unholy mess of Excel, VB and VBA
22:56:08 <Cale> Haskell can do stuff which is close enough to OO for me
22:56:54 * p_l finds typeclasses to be "OO enough" for him. After all, they actually made him understand CLOS xD
22:56:56 <o-_-o> So what about this question http://www.reddit.com/r/haskell/comments/b87sc/how_do_you_manage_an_object_graph_in_haskell/ ?
22:57:37 <copumpkin> I remember someone once said "let me address the misunderstanding that led to your question" in response to a question
22:57:58 <pikhq> Oh, "OOP". What a fancy and verbose way of doing closures.
22:58:17 <o-_-o> I am trying to rewrite some old code that I wrote in haskell, just as a learning experience
22:58:58 <o-_-o> in that code I have a bunch of floating point vectors, which are updated, in haskell do I have pass around the whole thing and return a new thing ?
22:59:16 <o-_-o> like a std::vector <float, float, float> things
22:59:32 <Axman6> yep
22:59:35 <o-_-o> somehow I can't seem to wrap my head around how I would do it in haskell efficiently
22:59:42 <Axman6> it'lll be more efficient than you expect though
22:59:49 <o-_-o> ok
23:00:53 <Cale> o-_-o: What do you mean by "a whole bunch"?
23:01:08 <Cale> Are they arranged coherently into some sort of datastructure like a finite map?
23:01:28 <o-_-o> Cale, when I originally wrote it, it had like around 2000 floating point values and ran really slow
23:01:42 <Cale> So, just an array of them?
23:01:48 <o-_-o> Cale yes
23:02:12 <Cale> Well, okay, updating an array randomly in pure code does make copies of the array
23:02:15 <p_l> o-_-o: well, there are ways to have mutable variables when you really need them
23:02:41 <Cale> There are two things you might want to try before going to using mutation
23:02:54 <Cale> One is to try just using something like an IntMap
23:03:15 <Cale> another, which may be easier, if you have the thing written to use Array, is to switch to using a UArray
23:03:34 <o-_-o> Cale, ok
23:03:36 <Cale> Or maybe even a DiffUArray, there are rare circumstances where the overhead doesn't kill you there
23:04:50 <Cale> (It's pretty easy to swap between different types of immutable array, generally)
23:05:19 <Cale> Using unboxed arrays will mean that you can't take advantage of laziness, but they will help with the memory pressure.
23:05:59 <o-_-o> so basically a bunch of 3D floating point vectors that store position, acceleration and velocity of a particle and then each one is updated based on external force, which is a 3d float vector again. Like that previously
23:06:04 <o-_-o> I had 100 particles.
23:11:20 <jmcarthur> or Vector
23:12:16 * jmcarthur is really liking the vector library
23:13:02 * Axman6 needs moar vector
23:13:14 <Cale> o-_-o: Oh, that's good, so the updates are dense and you can do them all at once.
23:13:26 <Cale> o-_-o: That'll be cheap if you do it the right way
23:13:33 <Cale> :t (//)
23:13:34 <lambdabot> forall i e. (Ix i) => Array i e -> [(i, e)] -> Array i e
23:14:12 <Cale> Well, actually, you probably wouldn't even use that. You'd make a whole new array and discard the old one.
23:14:50 <Cale> Because it's not even just a pretty dense set of updates, you're almost certainly changing absolutely everything in the array.
23:19:41 <o-_-o> hmmm....thanks :-)
23:23:47 <sinelaw> who wants to join my new band?
23:23:48 <sinelaw> The Imperative Rappers
23:24:05 <c_wraith> Too many easy puns with that name
23:24:14 <sinelaw> :_(
23:24:20 <p_l> ... sounds better than a band named "Common Lisp", I guess...
23:24:54 <sinelaw> "Haskell Curry" would make a good one, though
23:25:03 <sinelaw> i wonder what his parents thought
23:25:23 <sinelaw> yehezkel
23:25:43 <uorygl> If I created a band, I would call it something like Stephen Bourbaki.
23:25:46 <uorygl> Or Tanner Swett.
23:26:18 <uorygl> Another candidate band name would be Through the Bulkheads, except that I would be reluctant to listen to music by a band called Through the Bulkheads.
23:27:46 <Cale> Melodious Thunk
23:27:57 <lament> n1
23:29:23 * jmcarthur was once in a band called Jonathan Would Be Jealous
23:29:23 <sinelaw> The Garbage Collectors
23:29:42 <jmcarthur> and then in various others with less interesting names
23:29:50 <sinelaw> do you play an instrument?
23:29:56 <jmcarthur> i play many
23:30:02 <sinelaw> cool, which
23:30:10 <jmcarthur> although i'm a bit out of practice now
23:30:29 <jmcarthur> piano, guitar, trumpet, violin, did some bass in a band once too
23:30:35 <sinelaw> awesome
23:31:19 <jmcarthur> i guess violin would be stretching it. i've recorded some violin, but it was a painstaking process because i am not formally trained in violin
23:31:26 <jmcarthur> the others i am proficient with though
23:31:38 <sinelaw> sounds like great fun
23:31:44 <jmcarthur> i don't think i could handle live violin, for sure
23:32:36 <lament> it's doable
23:32:40 <lament> you just need to get really drunk
23:33:04 <sinelaw> my grandfather-in-law played piano, bass, tuba, violin, flute, harmonica (if that counts), guitar, and the nerves
23:33:12 <sinelaw> (seriously, he was a psychiatrist)
23:33:30 <sinelaw> he played in an orchestra
23:33:45 <sinelaw> i think it was the tuba
23:34:02 <lament> i played a bunch of instruments but they never got me any girls, so i quit
23:34:15 <jmcarthur> lament: then you did it wrong
23:34:15 <sinelaw> hah
23:34:26 <lament> yeah probably
23:34:29 <sinelaw> i did too, and it never got me any girls
23:34:42 <uorygl> I play piano sometimes.  I would be a lot more motivated to play piano if I could read music faster.
23:34:57 <sinelaw> i play piano pretty well if i practice
23:35:23 <lament> speaking of piano music, i bought WTC II for $6 :D
23:35:23 <uorygl> There are currently only a couple of pieces that I really want to play on the piano, and none of them are very difficult, so I can master them about as fast as I can read them.
23:35:23 <sinelaw> i mean, for an ammateur
23:35:38 <uorygl> Those pieces are Gregor Richards' Opus 10, Gregor Richards' Opus 11, and Gregor Richards' Opus 12.  :P
23:35:47 <lament> and debussy's first book of preludes for $4
23:35:49 <lament> yay clearance
23:36:10 <sinelaw> i know what WTC is, but it sounds like World Trade Center II
23:36:10 <Muad_Dibber_> when I got a cd playing of a good orchestra playing mozart for example, I am a very good wanna-be conductor :P
23:37:47 <sinelaw> i would like to write more music
23:38:05 <sinelaw> whenever i spend enough time doing it, i like the results, but i don't do it much anymore
23:38:12 <sinelaw> no time :(
23:38:12 <jmcarthur> same
23:38:44 <uorygl> I'm the opposite.  I have plenty of time, but whenever I try to sit down at a piano and come up with something, I end up with nothing.
23:38:56 <uorygl> So far, I've come up with 16 notes of music that I like, ever.
23:39:08 <sinelaw> keep trying
23:39:28 <sinelaw> and try playing new kinds of music to inspire yourself
23:39:30 <sinelaw> if you want
23:39:43 <uorygl> I don't like different kinds of music!
23:39:51 * jmcarthur once had a roommate that would make music on his computer and he would listen to the same 4 bar loops over and over and over and over for hours on end trying to get it to sound exactly the way he wants and never be happy enough with it to move on
23:40:41 <Twey> Hooray for headphones
23:40:46 <gruvstad> have you tried the haskore music library?
23:40:47 <sinelaw> yeah
23:41:03 <jmcarthur> i recall a particular loop that he would play for at least 3 hours every day for a good month
23:41:17 <uorygl> I guess if I didn't like different kinds of music, then it would be really easy to say exactly what type of music I like.
23:41:45 <jmcarthur> i've meant to give haskore a shot
23:41:56 <gruvstad> we used haskore in the functional programming class
23:42:37 <sinelaw> uorygl, so what is it
23:42:47 <uorygl> I think Nightwish's "Ghost Love Score" is fun.  Metallica's "Nothing Else Matters" is the sort of thing I simply must listen to every so often.  Boston's "Higher Power" is well-done.  Kirk Casey's "SIM Nights" is awesome.
23:43:05 <sinelaw> i've been thinking of trying to use haskore to write a music generator
23:43:29 <sinelaw> using a few rules gained from experience
23:43:36 <sinelaw> which i have never thought about yet really :)
23:43:41 <uorygl> If I like a song, there's a greater than 50% chance that it's an instrumental that's credited to a person.
23:43:50 * jmcarthur likes metal, electronic, industrial, and various sorts of orchestrated music
23:44:09 <uorygl> So "Ghost Love Score", "Nothing Else Matters", and "Higher Power" are all exceptions, really, because they have lyrics and Nightwish, Metallica, and Boston aren't people.
23:44:10 <jmcarthur> oh, and D&B if you don't count that with electronic
23:44:14 <lament> sinelaw: you think a computer will write better music than you?
23:44:34 <sinelaw> lament, no
23:44:38 <sinelaw> but it will be fun
23:44:55 <jmcarthur> i think most of my musical tastes have something in common, although they may appear to be diverse at first glance
23:45:02 <sinelaw> makes sense
23:45:08 <gruvstad> sinelaw, we made a accompanement mashine in class.
23:45:18 <sinelaw> cool! what does it do
23:45:37 <uorygl> For the most part, I like film scores and stuff that sounds like film scores.  If it's not the sort of music you would hear in a movie, I do not like it.
23:45:50 <jmcarthur> uorygl: do you like holst?
23:46:07 <gruvstad> it takes a chord progression and plays it together with a melody with a given style.
23:46:07 <uorygl> I've never heard of him.
23:46:33 <jmcarthur> uorygl: in my opinion, holst practically invented the "movie sound," although it's evolved a lot since then
23:47:00 <uorygl> I wonder what Mozart did, then.
23:47:05 <sinelaw> gruvstad, how does it work
23:47:22 <jmcarthur> mozart made thing fast :P
23:47:24 <jmcarthur> *things
23:48:00 <gruvstad> sinelaw, here is a link to the assignment: http://www.cs.lth.se/EDA120/assignment2/
23:48:01 * Cale likes mostly jazz, blues and rock & roll. And Frank Zappa, wherever you want to place him. :)
23:48:23 * Axman6 is a huge Dave MAtthews fan
23:48:27 <Axman6> a*
23:48:50 <uorygl> What defines jazz?
23:49:00 <sinelaw> thanks gruvstad looks interesting
23:49:14 * jmcarthur mixes all of Cale's music together and calls it The Brian Setzer Orchestra
23:49:19 <gruvstad> sinelaw, it is very basic. but it's kind of cool. :)
23:49:37 <sinelaw> i wish my univ. had a course like this
23:49:44 <sinelaw> i'm a lone haskeller here
23:50:15 <jmcarthur> sinelaw: i know the feeling
23:50:32 * SamB_XP likes stuff like Koji Kondo ...
23:50:44 <sinelaw> i have a friend who is lecturing in some small college
23:50:52 <sinelaw> maybe after i'm done here we can push that as a course there
23:51:04 <sinelaw> so i'll end up teaching it perhaps :)
23:51:15 <jmcarthur> SamB_XP: i love it when kondo's stuff is played with real instruments
23:51:19 <sinelaw> jmcarthur, don't it suck :(
23:51:23 <uorygl> You know, perhaps the best song I've ever heard is Jerry Martin's "Illumination".
23:51:25 <SamB_XP> sinelaw: do you pay them, or do they pay you?
23:51:36 <sinelaw> SamB_XP, they pay their lectures, i suppose
23:51:45 <sinelaw> lecturers
23:51:46 <SamB_XP> jmcarthur: you have to admit that the Steel Drums in SMB3 are surprisingly good, though!
23:52:15 <jmcarthur> SamB_XP: can't deny it
23:52:32 <SamB_XP> I mean, for crying out loud, you can *tell they are supposed to be steal drumbs*!
23:52:47 <SamB_XP> I probably need to goto bed
23:52:50 <jmcarthur> i actually think the limitations made his music better
23:52:52 <SamB_XP> I can't seem to spell
23:53:00 <SamB_XP> yeah
23:53:26 <jmcarthur> you have to work hard to make good melodies and such
23:53:46 <SamB_XP> but it sure is nice to hear it scaled up to real orchestras and stuff ;-)
23:53:50 <jmcarthur> oh yeah
23:54:16 <SamB_XP> or, heck, even to hear the old themes on a more recent system ;-)
23:54:18 <jmcarthur> SamB_XP: i bet you also like the oc remix stuff
23:54:42 <SamB_XP> yeah, though of late I've been listening to v-wave, not OCR radio
23:54:44 <jmcarthur> *some of
23:54:59 <jmcarthur> ah, it's a world i have fallen out of. i guess i am out of date
23:55:36 <SamB_XP> well, mostly because I noticed that V-wave had a lot more songs than last time I was listening to it
23:55:54 <gruvstad> sinelaw, if you want to try haskore, that assignment is made from an old version of haskore that you can download from the link. but you maybe want to try a more recent version.
23:55:57 <jmcarthur> well i should probably go to bed now
23:55:59 <SamB_XP> rainwave ond OCR radio will get their turns when I've rated enough of v-wave ;-P
23:56:02 <jmcarthur> been up too long
23:56:04 <SamB_XP> me too ;-P
23:56:10 <jmcarthur> nite everyone
23:56:27 <sinelaw> night
23:56:29 <gruvstad> breakfast time here.
23:56:33 <sinelaw> gruvstad, thanks i may
23:56:36 <sinelaw> same here :)
23:56:54 <gruvstad> time for the oatmeal. :)
23:57:03 <Axman6> cabal upgrade binary
23:57:05 <Axman6> whoops
23:58:29 <Saizan> don't use upgrade.
23:58:41 <Axman6> why not?
23:59:06 * Axman6 did end up using install --reinstall
