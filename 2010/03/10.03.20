00:08:11 <ManateeLazyCat> "darcs optimize --upgrade" is safe?
00:10:31 <FliPPeh> I wonder, why is it called (**) instead of the more common (^) for mathematical power?
00:10:37 <FliPPeh> Keyboard compatibility?
00:10:55 <FliPPeh> let a ^ b = a ** b in 5^2
00:10:57 <FliPPeh> > let a ^ b = a ** b in 5^2
00:10:58 <lambdabot>   25.0
00:11:20 <FliPPeh> Better yet
00:11:31 <ManateeLazyCat> darcs don't use "add * -r" before "record --all" ? Even in exist directory.
00:11:32 <FliPPeh> > let (^) = (**) in 5^2
00:11:33 <lambdabot>   25.0
00:11:36 <Zao> FliPPeh: ^ is taken.
00:11:41 <Zao> @type (^)
00:11:42 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
00:11:42 <FliPPeh> :t (^)
00:11:43 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
00:11:46 <FliPPeh> Hm
00:11:57 <Zao> Exponentiation of a different class.
00:12:04 <FliPPeh> ohh
00:12:08 <Zao> > 2 ^ 5
00:12:09 <lambdabot>   32
00:12:31 <Zao> @type (2^5, 2**5)
00:12:32 <lambdabot> forall t t1. (Num t, Floating t1) => (t, t1)
00:12:55 <FliPPeh> Mad world
00:13:20 <ManateeLazyCat> dcoutts: "darcs optiminze --upgrade" is always safe?
00:15:18 <FliPPeh> Hm, Haskell's Char is 32 Bit?
00:15:28 <Zao> FliPPeh: It's large enough to represent all code points.
00:15:35 <Zao> So at least 21 bits.
00:15:45 <FliPPeh> ahh, this is why bytestrings are recommended in many cases
00:15:52 <Zao> FliPPeh: Or Data.Text.
00:21:14 <zeiris> Unaligned, sanity-checked, partially-known bit parser progress report: I've got a large chunk of a complex data structure defines and really, it doesn't look too bad: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24154#a24154
00:22:08 <zeiris> Problems: values are currently defined as a data Value = Packet | Action | Length ... type thing. This means I have to define the possible values, THEN define the structure they fit in... It would be nice if that was one step. :[
00:25:25 <zeiris> More importantly, the current structure is limited since I'm basically defining a grammar (right term?) of single-token parsers, and if statements in a list. I can't use Haskell syntax for stuff like case, modifying state can be a problem. I hope to magically find a solution to that with a monad transformer.
00:26:22 <zeiris> Some kind of  monad where values are bound to with <-, perhaps.
00:56:03 <zeiris> So how does the GSOC work with respect to Haskell? Look at "good" rated ideas on idea list, find mentor for a specific idea you can do, and talk to them?
00:57:58 <Jafet> I don't think the SOC has particular provisions for Haskell programming
00:58:36 <zeiris> Well, haskell.org is one of the organizations, and there's this neato list of ideas on hackage.haskell.org. Although some look a wee bit dated.
00:58:40 <lhames> SamB_XP: I think it was you I asked about the Either Monad last night? You were right - it's in Control.Monad.Error. Thanks again for that. :)
01:00:51 <zeiris> Oh neat, I guess you -can- use Either as a monad :)
01:04:56 <lhames> zeiris: Yep. Not sure if it's considered good form, but I wanted to use 'sequence' to collapse a list of Eithers to a Right [a] or Left a.
01:05:24 <Jafet> Sounds appropriate
01:05:50 <lhames> Oh good.
01:08:41 <lhames> Related question: Is there a generic "split list on delimiter" function in the standard libraries? I want to break up a string with components delimited by '%' signs: ["hi%there"] -> ["hi", "there"]
01:08:54 <lhames> 'words' would do for spaces, but I can't find a general version.
01:09:54 <dobblego> you could recurse on break (== '%') or look at Data.List.Split on hackage
01:11:54 <lhames> dobblego: Thanks. Yep - my current implementation uses break, was just wondering if there was a standard function for it.
01:12:23 <dons> shapr: http://crocodoc.com/ looks like FLM ideas
01:25:13 <ManateeLazyCat> How to *just* add new files in *exist* directory ? I use "darcs add fooDir -r", it add directory `fooDir`, even `fooDir` have exist.
01:30:10 <ivanm> ManateeLazyCat: you have to add the directory as well
01:30:52 <ivanm> ManateeLazyCat: since it doesn't make sense for a file to exist in a non-existing directory
01:30:55 <ManateeLazyCat> ivanm: I still need add directory even this it have exist?
01:31:06 <ivanm> ManateeLazyCat: you probably haven't added it then ;-)
01:31:20 <ivanm> I don't think it's possible to have empty directories in darcs (I'm probably wrong though)
01:32:11 <ManateeLazyCat> ivanm: But when i push patch, darcs failed.
01:32:29 <ivanm> with what error?
01:32:44 * ivanm suspects ManateeLazyCat might have an inconcistent repo
01:32:53 <ivanm> anyway, can't help much anymore atm... dinner time
01:32:59 <ManateeLazyCat> ivanm: inconsistent state.
01:33:24 <ManateeLazyCat> ivanm: But i "get* new code from repository before i add patch.
01:33:48 <ManateeLazyCat> ivanm: But have a point, darcs looks convert something when i "get"
01:33:52 <ManateeLazyCat> ivanm: I use darcs 2.4
01:39:00 <ManateeLazyCat> darcs failed:  ./webkit: createDirectory: already exists (File exists)
01:39:01 <ManateeLazyCat>  
01:39:10 <ManateeLazyCat> Above is failed error.
01:48:38 <ivanm> ManateeLazyCat: you sure you didn't forget to pull a patch or something?
01:49:10 <ManateeLazyCat> ivanm: I use "get" get all repository again.
01:49:18 <ivanm> k
01:49:37 <ivanm> is anyone here at the hackathon?
01:54:14 <ManateeLazyCat> ivanm: I must `adddir` before `addfile`, but that directory have exist, and strange is after i "record", i was failed to push.
01:59:42 <ManateeLazyCat> ivanm: Converting old-fashioned repository to hashed format...
02:00:09 <ManateeLazyCat> ivanm: When i "get" from gtk2hs.
02:01:13 * ManateeLazyCat Try to use --old option
02:18:20 <Twey> Hm… I wonder why there is no Numeric.readIntAtBase
02:19:37 <ivanm> Twey: because we've all been waiting for you to write it!
02:19:53 <Twey> Haha
02:20:43 <olsner> "Thou shalt not implement Numeric.readIntAtBase, for that is the task of Twey." - it's in the report
02:27:33 <kingping> Hello folks.
02:35:20 <mreh> will openGL do geometry as well as graphics drawing, I'm thinking specifically of collision detection
02:44:27 <stevenmarky> opengl is just graphics afaik
02:47:07 <Zao> Correct.
02:47:16 * hackagebot darcswatch 0.4.1 - Track application of Darcs patches  http://hackage.haskell.org/package/darcswatch-0.4.1 (JoachimBreitner)
02:49:32 <mreh> I only really need a simple library that will do all the I/O for the game
02:50:50 <mreh> I can do the geometry myself I suppose, I'll stick with HGL
02:51:17 * hackagebot darcswatch 0.4.2 - Track application of Darcs patches  http://hackage.haskell.org/package/darcswatch-0.4.2 (JoachimBreitner)
02:54:23 * hackagebot darcswatch 0.4.3 - Track application of Darcs patches  http://hackage.haskell.org/package/darcswatch-0.4.3 (JoachimBreitner)
02:57:54 <Taejo> shouldn't cabal-install install profiling libraries by default
02:58:01 <ivanm> Taejo: only if you tell it to
02:58:07 <ivanm> check your ~/.cabal/config file
02:58:20 <Taejo> ivanm: I'm saying the default is wrong
02:58:37 <ivanm> why?
02:58:43 <Taejo> because I suddenly need to profile something, and I have to go back and reinstall *everything*
02:58:46 <ivanm> Taejo: cabal-install is aimed at _users_ not developers
02:59:12 <Zao> Bloating the installed libraries by at least 2x is not optimal for users.
02:59:26 <ivanm> (apparently)
02:59:26 <Taejo> users who are willing to go through the whole palaver of installing GHC and cabal-install :)
02:59:26 <ivanm> heh
02:59:26 <ivanm> Taejo: get a _real_ package manager! :p
02:59:32 <Taejo> but I see your point
03:03:27 <Remy__> Hey
03:03:35 <Remy__> I'm using parsec to do.. parsing gee
03:03:39 <Remy__> and I want to seperate lexing and parsing
03:03:51 <Remy__> so I have a token datatype
03:03:59 <Remy__> and a lexTokens function of type Parser [Token]
03:04:11 <Remy__> now I have trouble connecting the lexer and parser
03:04:23 <Remy__> I still want to have informative error messages with line numbers in the parser
03:04:28 <jinjing> could I get some help with this cabal / ghc-pkg error? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24160#a24160
03:05:09 <Remy__> how does parsec intent someone to split the lexing and parsing phase?
03:07:29 <ivanm> Remy__: I don't think you do
03:07:40 <ivanm> you just parse it
03:07:46 <Remy__> Hmm I don't like that : /
03:07:57 * ivanm never did any "traditional" parsing, so can't really tell how combinator parsing differs
03:08:06 <ivanm> Remy__: there is happy, etc. if you want lexing+parsing
03:08:20 <ivanm> and alex
03:08:21 <benmachine> you could put surce location information in your token type?
03:08:28 <benmachine> +o
03:08:29 <ivanm> alex is a lexical analyser, happy is a parser generator
03:08:50 <ivanm> see haskell-src-exts; it contains source locations and uses alex+happy
03:08:57 <ivanm> (well, I _think_ it uses alex; I know it uses happy)
03:09:10 <ManateeLazyCat> I have use gtk2hs develop a simple browser demo, i use it listen music and watch movie
03:09:14 <ManateeLazyCat> Really coo.
03:09:14 <ivanm> jinjing: methinks you're screwed :s
03:09:33 <jinjing> thanks, i thought that too, reinstalling ghc pkg
03:09:34 <ivanm> jinjing: unregister utf8-prelude and rebuild it?
03:09:41 * ManateeLazyCat pasted "gtk2hs Webkit browser" at http://paste2.org/get/726237
03:09:44 <ManateeLazyCat> Above is source code.
03:09:47 <ManateeLazyCat> So simple.
03:09:55 <jinjing> ivanm: can't unregister, says cache not updated, same error
03:10:06 <ivanm> ManateeLazyCat: why would I want to use it when I already have a browser here in front of me?
03:10:08 <ivanm> jinjing: :/
03:10:11 <ivanm> preflex: seen dcoutts
03:10:11 <preflex>  dcoutts was last seen on #haskell 2 days, 19 hours, 39 minutes and 7 seconds ago, saying: heh, I don't have the beard to be a great prophet
03:10:18 <ManateeLazyCat> ivanm: More control.
03:10:23 <ivanm> jinjing: maybe someone on #ghc will be able to help you...
03:10:40 <ivanm> jinjing: otherwise, backup that directory and delete that file from it maybe
03:10:48 <jinjing> well, i'll report if it happens again, right now i've uninstalled this thing
03:10:50 <ivanm> and then do a recache
03:10:56 <ivanm> jinjing: oh? how?
03:11:09 <ivanm> ManateeLazyCat: how would it provide me more control?
03:11:10 <jinjing> there's a Uninstall script
03:11:23 <ivanm> and why would I want to use a _browser_ to listen to music? >_>
03:11:24 <jinjing> I also wiped the .ghc/6.12 directory
03:11:30 <ManateeLazyCat> ivanm: Well.
03:11:47 <ivanm> jinjing: I think your ghc 6.12 installed is screwed then... :s
03:11:59 <ManateeLazyCat> ivanm: I have framework that base on gtk2hs to integrate browser, editor, terminal, file-manager, irc-client, and everything
03:12:09 <jinjing> ivanm: yeah, oh, i meant I uninstalled ghc ..
03:12:14 <ivanm> ahhh
03:12:20 <ManateeLazyCat> ivanm: So you don't need *switch* between many application.
03:12:40 <ivanm> so you did surgery by shooting a tank missile at the patient? :p
03:12:41 <ManateeLazyCat> ivanm: And all those application use *same* behaviour to handle.
03:12:52 * ivanm uses mpd for music...
03:13:03 <ManateeLazyCat> ivanm: I'm mix everything in it.
03:13:13 <jinjing> ivanm: mpd is not too user friendly ..
03:13:17 <ivanm> OK, I like; I'm currently using vlc to listen to an internet radio
03:13:40 <ivanm> jinjing: sure it is; I have xmonad keybindings tied to my multimedia keys to send commands to it via mpc
03:13:43 <ivanm> and I'm set
03:13:50 <ivanm> s/like/lie/
03:14:02 <ManateeLazyCat> ivanm: I'm running gtk2hs WebKit browser few hours, running well, stable enough, haven't any bug.
03:14:40 <jinjing> ivanm: ahh... customization.. good
03:14:59 <ManateeLazyCat> ivanm: Think about this, you can listen music, programming, browser, irc, mail, everything in one *harmonious* interface.
03:15:12 * ivanm passes
03:15:30 <ManateeLazyCat> ivanm: Don't need Atl-Tab, don't need *conflict behaviour* by different developer.
03:15:37 <DigitalKiwi> are we talking about emacs?
03:15:47 <Ke> what is this dystopia
03:15:55 <ivanm> I admittedly use emacs as my email client, but that's because I haven't found any other one that has better keyboard-based usage
03:16:00 <DigitalKiwi> Why use a text editor when you can use an operating system? :)))
03:16:02 <ivanm> DigitalKiwi: no, ManateeLazyCat's new gtk2hs-based monstrosity
03:16:07 <ivanm> @slap DigitalKiwi
03:16:07 * lambdabot activates her slap-o-matic...
03:16:27 <Ke> someone should make haskell-scriptable vi-like editor
03:16:30 <Ke> !
03:16:39 <ManateeLazyCat> ivanm: I'm build some crazy thing.
03:17:21 <ivanm> yes, I've heard your plans before...
03:17:32 <ivanm> Ke: *cough* yi *cough*
03:17:46 <ivanm> DigitalKiwi: anyway, that joke is really old and lame
03:17:46 <ManateeLazyCat> ivanm: Emacs can't do anything, but i can. :0
03:18:04 <Ke> well I couldn't even :wq on yi, when I last tried
03:18:18 <Ke> ivanm: obviously needs to be ssh frindly too
03:18:51 <DigitalKiwi> ivanm: I'd never heard it until I said it a few years ago :(
03:19:06 * ivanm thinks ManateeLazyCat means "everything", not "anything"
03:19:28 <ivanm> and the major problem of one program doing everything: it dies, you lose it all
03:20:08 <Ke> also it never does everything the way you like
03:20:32 <Ke> if you could make it contrib'able modular like xmonad
03:20:58 <Ke> haskell DE would probably be better
03:21:06 <ManateeLazyCat> ivanm: I try do interface, just write new code when necessary.
03:23:05 <ManateeLazyCat> ivanm: http://farm5.static.flickr.com/4066/4446868317_1d800e89bf_o.png
03:25:10 <jinjing> 24 小时?
03:25:15 <ManateeLazyCat> jinjing: Yep.
03:25:40 <ManateeLazyCat> ivanm: I will push a webkit demo to gtk2hs later,
03:25:59 <ManateeLazyCat> ivanm: Then other people will know how easy that use gtk2hs develop a browser.
03:26:13 <ManateeLazyCat> jinjing: Chinese?
03:26:15 * ivanm fails to see why anyone would _want_ to
03:26:28 <ivanm> as in there might be specific niche areas like want you want to write
03:26:35 <jinjing> ManateeLazyCat: yep
03:26:40 <ivanm> but I doubt there will be hordes of people going out suddenly writing new haskellian browsers
03:27:06 <ManateeLazyCat> jinjing: Me too.
03:27:20 <ManateeLazyCat> ivanm: I'm not write this environment for most people.
03:28:55 <ManateeLazyCat> ivanm: My aim is write a *full* environment for Haskell hacker, engineer, programmer, that anyone want works efficiently.
03:29:16 <ivanm> *shudder*
03:29:33 <ivanm> ManateeLazyCat: no offence, but I fail to see how such a thing would _improve_ productivity for most people
03:29:46 <ivanm> I mean, having an inbuilt video player?  I can just see people watching movies rather than hacking :p
03:30:28 <ManateeLazyCat> ivanm: Use every application with *same* behaviour, like Emacs.
03:30:48 <ivanm> ummm.... not all behaviours are the same even within emacs
03:30:59 <ivanm> e.g. I can never remember all 50 million key combos for use with Gnus
03:31:11 <ManateeLazyCat> ivanm: Use my one-key.el
03:31:41 <ManateeLazyCat> ivanm: OneKey help you remember so many keystoke in Emacs.
03:31:52 <ManateeLazyCat> ivanm: http://www.emacswiki.org/emacs/OneKey
03:32:04 <Jafet> Fortunately most movies these days are less interesting than hacking
03:32:17 <ivanm> that won't help with Gnus AFAICT ;-)
03:32:19 <ivanm> Jafet: heh
03:32:37 <ManateeLazyCat> ivanm: You just need remember *top-keystroke*, example, one key for gnus, then OneKey will show rest key for you.
03:33:06 <ivanm> all 50-million of them?
03:33:19 <ManateeLazyCat> ivanm: Yes, if you want.
03:33:44 <Jafet> Just configure emacs to work with www.artlebedev.com/portfolio/optimus/
03:34:33 <DigitalKiwi> just use vim ;D
03:35:13 <Jafet> But you can't watch movies in vim!
03:35:27 <DigitalKiwi> and that is a bad thing how? :P
03:36:16 <ivanm> Jafet: heh
03:36:33 <ivanm> sure, assuming you can afford one...
03:37:20 <ManateeLazyCat> ivanm: http://www.emacswiki.org/emacs/AndyStewart Looking for any code you want, if you're use Emacs deeply. :)
03:37:33 <ivanm> yes, I've seen your code before
03:37:47 <ivanm> took me a while to work out your refactoring hooks for haskell were for HaRe ;-)
03:38:04 <ManateeLazyCat> ivanm: Do you have time take over my extension. I really haven't time on elisp stuff.
03:38:30 <ivanm> nah
03:38:34 <ivanm> I don't grok elisp that well
03:38:41 <ManateeLazyCat> Wait. I remember have HaRe mail .
03:39:00 * ivanm has been using gnus for at least 6 months, and has still never gotten around to reading through the manual, etc. and customising it
03:39:11 <ivanm> e.g. I still copy/paste email addresses rather than using BBDB :s
03:39:25 <ManateeLazyCat> ivanm: BBDB is bugly.
03:39:32 <ManateeLazyCat> ivanm: I turn off it yesterday.
03:39:47 <ivanm> oh? what do you use instead for an address book?
03:39:51 <ManateeLazyCat> ivanm: Are you use leafnode with gnus?
03:39:55 <ivanm> nope
03:39:56 <ManateeLazyCat> ivanm: Anything.
03:39:58 <ivanm> never heard of it
03:40:02 <ManateeLazyCat> ivanm: Anything.el
03:40:42 <ivanm> oh, yeah, I've seen that
03:40:49 <ivanm> don't use it with gnus though
03:40:54 <ivanm> not a big fan of anything.el
03:40:54 <ManateeLazyCat> ivanm: Leafnode fetch mail at background, then you just use gnus read mail from local.
03:40:57 <ivanm> but I _love_ ido
03:41:07 <ManateeLazyCat> ivanm: Then gnus won't freeze when you working on *big* mail-list.
03:41:09 <ivanm> ido: not you, emacs' interactively-do :p
03:41:22 <ivanm> ManateeLazyCat: oh? I use a local IMAP server
03:41:25 <ManateeLazyCat> ivanm: anything.el is more powerfully.
03:41:31 <ivanm> it's _sending_ that freezes gnus ;-)
03:41:48 <ManateeLazyCat> ivanm: Search init-gnus.el
03:42:10 <ManateeLazyCat> ivanm: I wrote that how to make gnus works with leafnode
03:43:11 <ManateeLazyCat> ivanm: Leafnode just fetch mail from mail-list.
03:43:26 <ManateeLazyCat> ivanm: For mail like Gmail, i use `getmail`
03:43:37 * hackagebot Snusmumrik 0.0.1 - E-library directory based on FUSE virtual file system.  http://hackage.haskell.org/package/Snusmumrik-0.0.1 (SergeyAstanin)
03:45:29 <Entroacceptor> I read the website, but what is a snusmumrik?
03:48:34 <ivanm> yay! graphviz accepts even more escaped characters than it admits!
03:53:37 <FliPPeh> I hate it so much when people require certain libraries with an equality sign
03:53:42 <ivanm> anyone know of an html/xml library that includes a function to test for escape codes?
03:53:55 <ivanm> FliPPeh: as in == 1.1.0.0 or == 1.1.* ?
03:53:56 <FliPPeh> 2 days laters when that library has been updated, the whole thing dumps in my face when I try to install it
03:54:13 <FliPPeh> Like Leksah does with haskell-regex-base=0.72.0.2 here on arch linux
03:54:21 <FliPPeh> Where that regex-base isn't reachable anymore
03:54:24 <FliPPeh> No Leksah for me
03:54:35 <FliPPeh> Why wouldn't "haskell-regex-base>=0.72" be enough?
03:54:38 <ivanm> yeah
03:54:49 <ivanm> it _should_ be == 0.72.* if you're worried about API compatability
03:55:12 <ivanm> even though I can't recall a single library that wanted 0.7x but didn't work with 0.9y as well (with y >= x)
03:55:16 <FliPPeh> But it shouldn't be if this library changes daily, but the source package does not!
04:00:32 <Entroacceptor> I've given up learning happstack because of that kind of trouble
04:00:35 <FliPPeh> lols, bauerbill options
04:00:37 <FliPPeh> --blindly-trust-everything-when-building-packages-despite-the-inherent-danger
04:01:01 <DigitalKiwi> is that real?
04:01:06 <FliPPeh> It is
04:01:07 <Entroacceptor> sure
04:01:17 <DigitalKiwi> lawl
04:01:18 <Entroacceptor> I really love it
04:01:24 <DigitalKiwi> clyde > bauerbill, then
04:01:30 <Entroacceptor> a) it's an override switch, every program should have it
04:01:35 <Taejo> @remember FliPPeh --blindly-trust-everything-when-building-packages-despite-the-inherent-danger
04:01:35 <lambdabot> I will remember.
04:01:36 <Entroacceptor> b) it's aptly named.
04:01:44 <Entroacceptor> clyde?
04:01:45 <jlouis> yay, more quickcheck!
04:02:03 <DigitalKiwi> 06:01 < phrik> The next-generation libalpm/makepkg wrapper with AUR support, multithreaded downloading, and colorized output. Trust us, it's the best! Now in open beta!
04:02:08 <Taejo> @quote
04:02:08 <lambdabot> gFunk says: [the main advantage of functional programs are that they're] incorrect the first 1000 times you try to compile it!
04:02:15 <Taejo> @quote
04:02:15 <lambdabot> danderson says: [using unsafeFreeze for an ST action] that sounds like a way to shoot myself in the foot with high efficiency, given my knowledge of haskell.
04:02:17 <ivanm> Taejo: except that wasn't FliPPeh making the quote up; he was quoting from help documentation!
04:02:25 <Taejo> oh, oops
04:02:33 <FliPPeh> :)
04:02:34 * Taejo didn't look at the context
04:02:42 <Taejo> can lambdabot @forget?
04:02:47 <ivanm> yes
04:02:55 <ivanm> just replace @remember with @forget
04:03:02 <Taejo> @forget FliPPeh --blindly-trust-everything-when-building-packages-despite-the-inherent-danger
04:03:02 <lambdabot> Done.
04:03:15 <ivanm> anyone know of a library that has html/xml escape and unescape functions?
04:03:17 <ManateeLazyCat> ivanm: I meet another Chinese haskeller, luckly.
04:03:19 <FliPPeh> The world shall not remember me forever and ever
04:03:23 <FliPPeh> :(
04:04:09 <ivanm> oooohhhh, looks like tagsoup might
04:04:35 <DigitalKiwi> Entroacceptor: http://bbs.archlinux.org/viewtopic.php?id=91860
04:05:35 <ManateeLazyCat> ivanm: Have you try OneKey?
04:05:42 <ivanm> nope
04:05:51 * ivanm is haskell hacking atm, not elisp hacking ;-)
04:05:52 <Twey> 11:00:13 < FliPPeh> --blindly-trust-everything-when-building-packages-despite-the-inherent-danger
04:05:56 <Twey> Hahahaha
04:06:03 <ManateeLazyCat> ivanm: If you have so much key need to remember, you need OneKey. :)
04:06:07 * Twey is doing both ☹
04:06:28 <Twey> happstack's dependencies are a nightmare
04:06:43 <DigitalKiwi> hi Twey
04:07:03 <Twey> I ended up using cabal unpack to hack off large chunks of the .cabal files until I got it working
04:07:06 <Twey> I don't dare upgrade
04:07:08 <Twey> Hey, DigitalKiwi
04:07:22 <ivanm> preflex: seen bens
04:07:22 <preflex>  Sorry, I haven't seen bens
04:08:11 <FliPPeh> Oh god
04:08:15 <FliPPeh> Leksah is so messed up
04:08:36 <FliPPeh> Every file compiles with a warning and file 15/55 kills the build process
04:09:03 <ivanm> FliPPeh: yes, but didn't you hear? it's the "haskell ide of choice" :s
04:09:03 <FliPPeh> Needs better Haskell IDEs
04:09:14 <Twey> Needs moar emacs >.>
04:09:20 <FliPPeh> MOAR VIM
04:09:27 <Entroacceptor> $EDITOR and bash, neatly layouted by xmonad
04:09:35 <ManateeLazyCat> fihi09: http://farm3.static.flickr.com/2628/3952175905_9295a7421a_o.png Like this?
04:09:36 <Twey> s/bash/zsh/
04:09:38 <FliPPeh> But vim gets hairy with too many files
04:09:42 <Entroacceptor> Twey: you use emacs?
04:09:49 <Entroacceptor> I'm not your friend anymore.
04:09:49 <Twey> Entroacceptor: Yes
04:09:55 <Twey> vim is like PHP
04:09:56 <FliPPeh> The art of multiple file handing with vim isn't one of my mastered technologies yet
04:10:03 <FliPPeh> Twey: TAKE IT BACK NOW
04:10:03 <Twey> It looks lovely and simple until you try really using it.
04:10:08 <Twey> :þ
04:10:12 <xerox> how do you handle multiple open files in vim?
04:10:18 <FliPPeh> xerox: Buffers
04:10:19 <Twey> It has tabs
04:10:24 <FliPPeh> What tabs?
04:10:24 <Twey> They're just awkward
04:10:26 <FliPPeh> You lie!
04:10:39 <Jafet> Who needs multiple files
04:10:40 <FliPPeh> It has buffers like irssi does
04:10:45 <FliPPeh> You can split windows
04:10:45 <xerox> in emacs C-x b, in vim?
04:10:47 <FliPPeh> And switch them
04:10:53 <Entroacceptor> :buf 3
04:10:57 <FliPPeh> C-W w
04:11:01 <FliPPeh> Switch to last buffer
04:11:07 <FliPPeh> And some more I don't remember
04:11:39 <ManateeLazyCat> ivanm: I need leave now, enough bla, bla. Just care if you use darcs 2.4.
04:11:57 <ivanm> I do
04:12:23 <ivanm> Entroacceptor: so you can't do it by name?
04:12:29 <ManateeLazyCat> ivanm: The darcs problem i occur before is because darcs 2.4 convert to hashed repository after download.
04:12:31 <ivanm> FliPPeh: ooh, didn't know about that
04:12:39 <FliPPeh> ivanm: You can
04:12:39 <ivanm> I typically just do C-x b <enter>
04:12:51 <ManateeLazyCat> ivanm: Then it will add directory even that directory have exist.
04:12:55 <jlouis> xerox: vim buffers are much like emacs ido-mode buffers
04:13:01 <FliPPeh> ivanm: If the file is already loaded in a buffer, :e <filename> will just switch to it
04:13:05 <ManateeLazyCat> ivanm: Then you will got error when push.
04:13:19 <ManateeLazyCat> ivanm: Okay, bye. Dinner time.
04:13:44 <SubStack> I am really liking http://modules.sourceforge.net/ to package up ghc-6.12.1
04:13:51 <ivanm> anyone here used web-encodings before?
04:14:01 <SubStack> people on this server I am setting up can just "module load ghc" now
04:14:34 * SubStack creates a cabal modulefile next
04:15:24 <FliPPeh> Oh yeah this is just great
04:15:25 <ivanm> preflex: seen ndm
04:15:25 <preflex>  ndm was last seen on #haskell 315 days, 56 minutes and 44 seconds ago, saying: plus with current compiler technology, it would be slower
04:15:42 <FliPPeh> I look for Haskell IDE screenshots and I find pictures of a shirtless "Neil Haskell"
04:15:45 <ivanm> OK, looks like I can't ask him directly...
04:15:51 <Twey> FliPPeh: *grin*
04:16:03 <FliPPeh> Nice Sixpack 'tho
04:16:10 * ivanm wonders if it's worth adding tagsoup as a dep to graphviz just to avoid having to code all that stuff himself
04:16:27 <Twey> So where'd ndm go?
04:16:33 <FliPPeh> I think I've got to stick with VIM
04:16:42 <FliPPeh> Too bad it's syntax highlighting isn't great.
04:16:50 <FliPPeh> I want ALL type constructors to be matched :(
04:17:03 <ivanm> SubStack: what's that? looks a bit like stow or something
04:17:13 <ivanm> Twey: he's just rarely ever on IRC
04:17:28 <SubStack> oh that looks nifty too
04:18:36 <ivanm> SubStack: or even gentoo-prefix :p
04:19:20 <SubStack> ivanm: modules seems to have an emphasis on letting different versions co-exist
04:20:21 <ivanm> *nod*
04:20:40 <SubStack> hopelessly ambiguous name though
04:21:30 <ivanm> hmmm.... "let (*) = (,) in" <-- so you can just write a * b rather than (a,b)
04:21:35 <ivanm> interesting approach
04:21:42 <Entroacceptor> they should finally make Yi usable
04:21:46 <SubStack> hah nice
04:22:25 <Twey> FliPPeh: emacs calls you
04:22:57 <idnar> > let (*) = (,) in x * y * z
04:22:58 <lambdabot>   ((x,y),z)
04:23:03 <idnar> hmm, wrong associativity?
04:23:12 <SubStack> (&) might be good too
04:23:33 <Twey> > let infixr *; (*) = (,) in x * y * z
04:23:34 <lambdabot>   (x,(y,z))
04:23:44 <Twey> vixey likes (-->), I hear
04:23:53 <idnar> I think some people want...
04:23:57 <idnar> > let infixr *; (*) = (,) in x * y * z * ()
04:23:58 <lambdabot>   (x,(y,(z,())))
04:24:02 <dobblego> Scala uses -> and it pisses me off
04:24:07 <Twey> Why?
04:24:16 <dobblego> it's conjunction, not implication
04:24:32 <SubStack> I use --> to make heterogeneous collections sometimes
04:24:38 <ivanm> idnar:
04:24:42 <ivanm> idnar: heh
04:24:45 <ivanm> that's better :p
04:27:44 <dons> refold: around?
04:27:54 <ivanm> dons: how's the hackathon going?
04:28:04 <dons> good! amazing number of people here.
04:28:12 <dons> lots of exciting stuff being worked on.
04:28:17 <ivanm> I think you're the first hackathoner we've had here all day...
04:28:26 <dons> there's lots of people in #zurihac :)
04:28:37 <ivanm> dons: so why is number 2. meant to be a secret here? http://www.reddit.com/r/haskell/comments/bfcfs/haskells_big_three/
04:28:57 <dons> its a secret extension to the module system that's to work around ghc issues
04:29:08 <ivanm> *nod* that was my quick googling lead me to conclude
04:29:13 <ivanm> just wanted to check
04:29:53 <dons> http://code.haskell.org/~dons/code/haskell-platform/snapshot/ <-- beta of the HP for unix. please test and report success/failure
04:30:18 * ivanm ssh's into his uni machine and gets it building
04:30:24 <ivanm> dons: any C libs required?
04:30:36 <c_wraith> dons: Isn't the time as ridiculous for you as it it is for me?
04:30:43 <ivanm> @time dons
04:30:45 <lambdabot> Local time for dons is Sat Mar 20 04:30:19 2010
04:30:47 <dons> well, its 12 noon. so that's fine.
04:30:51 <dons> don't do that ivanm !!
04:30:55 <ivanm> sorry :(
04:31:01 * dons doesn't want to know what time it "really" is
04:31:04 <ivanm> heh
04:31:13 <ivanm> dons: any C libs required for the platform?
04:31:20 <dons> yeah, usual things. GL.
04:31:24 <dons> mm. gmp
04:31:31 <danderson> it's okay, dons is now being fed tea fuel.
04:31:36 <ivanm> (I couldn't build the old platform before due to editline not being installed on his uni machine)
04:31:45 <dons> espresso tea
04:31:57 <ivanm> heh
04:32:20 <ivanm> this is just the libs, right? not ghc?
04:33:21 <ivanm> dons: it fails immediately!
04:33:32 <ivanm> needs mtl >=1.0
04:33:45 <dons> interesting.
04:33:46 <ivanm> dons: oh, and cabal says the defaultUserHooks is deprecated
04:33:46 <b52> http://paste.pocoo.org/show/191782/ could someone help me?
04:33:53 <dons> yeah, the warning is expected.
04:33:58 <dons> so you have mtl on your machine already?
04:34:09 <ivanm> most probably
04:34:17 <dons> can you do ghc-pkg mtl for me?
04:34:18 <ivanm> b52: fromIntegral is your friend
04:34:32 <ivanm> you mean ghc-pkg list mtl?
04:34:41 <dons> yes
04:34:42 <ivanm> 1.1.0.2 installed with ghc
04:35:01 <ivanm> (as opposed to installed with cabal-install)
04:35:14 <dons> oh. but that's precisely what is needed.
04:35:23 <ivanm> oh, wait, I lie...
04:35:33 <ivanm> that's my per-user one I built with cabal-install
04:35:42 <dons> ah. what's in the global set?
04:35:46 <ivanm> this is using .configure
04:35:51 <ivanm> global set, nothing
04:36:00 <dons> good.
04:36:02 <ivanm> (they're both installed per-user, really, so it's difficutl to tell)
04:36:27 <ivanm> the error comes about when configuring happy
04:36:28 <dons> can you untar the package again, and record a transcript?
04:36:41 <ivanm> so maybe you need to tell it to build mtl before it builds happy?
04:36:45 <dons> should just be: ./configure ; make
04:37:04 <dons> $ cat platform.packages
04:37:04 <dons> mtl-1.1.0.2
04:37:04 <dons> happy-1.18.4
04:37:04 <dons> HUnit-1.2.2.1
04:37:04 <dons> OpenGL-2.2.3.0
04:37:06 <dons> GLUT-2.1.2.1
04:37:16 <dons> it already does the topological sort on deps, to work out what order to build things.
04:37:22 <ivanm> dons: right, I just did ./configure --prefix= ; make
04:37:34 <dons> can you use 'script' to record a transcript, then send that to me?
04:38:01 <ivanm> oooh, never used script before
04:38:04 <ivanm> how does one use it?
04:38:09 <dons> 'script'
04:38:20 <dons> and then ^D later
04:38:26 <dons> will save the log to 'typescript'
04:38:29 <dons> which you can send to me
04:38:47 <ivanm> email work?
04:39:12 <FliPPeh> script is fun, but I haven't used it with any real purpose yet :)
04:39:43 <dons> ivanm: yeah.
04:46:33 <ivanm> dons: oh, btw, do you know of any libraries that do html/xml escaping and unescaping of strings?
04:46:46 <ivanm> (instead of me doing it myself)
04:47:01 <FliPPeh> I'd much rather have a library that parses HTML to a DOM file
04:47:11 <ivanm> FliPPeh: yes, but I'm not parsing HTML per se
04:47:14 <FliPPeh> I finished writing a Rapidshare free-account downloader yesterday
04:47:24 <FliPPeh> Had to scan 2 html sources for links and variables
04:47:26 <FliPPeh> Not good.
04:47:27 <ivanm> I'm having to encode/decode String values to/from HTML-valid Strings
04:47:41 <ivanm> FliPPeh: oh? how does that work?
04:47:49 <FliPPeh> One small change on their side like changing "action=..." to "action = ..." will BREAK IT!
04:47:51 <ivanm> rather than you waiting it will see when the download is valid and get it for you?
04:48:03 <ivanm> get a better parser! :p
04:48:17 <FliPPeh> ivanm: The countdown is running on the server side, the local display is just that, a display
04:48:24 <FliPPeh> There IS a download link in the source
04:48:31 <ivanm> oooohhhh...
04:48:34 <FliPPeh> But it will only be downloadable after the countdown ran to 0
04:48:39 <ivanm> FliPPeh: what do you do about the "only one free download/day"
04:48:44 <FliPPeh> But at least you won't have to wait yourself and click :)
04:48:55 <FliPPeh> Nothing I can do about it
04:49:01 <ivanm> *nod*
04:49:22 <FliPPeh> The code is actually very compact, but not that stablee
04:50:16 <FliPPeh> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=8742#a8742
04:50:21 <FliPPeh> Except for the main function
04:50:23 <FliPPeh> :)
04:50:28 <FliPPeh> It's an abomination from hell
04:50:30 <ivanm> dons: oh, I don't suppose ndm is at zurihac...
04:52:31 <FliPPeh> Meh, 95% of hpaste is spambots
04:52:47 <FliPPeh> While life insurance and casino games are awesome, I want to peak at code
04:53:28 <medfly> I wonder if you can add some filter to hpaste that pasted things should at least have some syntax highlighting
04:53:41 <FliPPeh> By the way, how do I make a handle nonblocking?
04:54:33 <dobblego> FliPPeh, that code can be improved quite a lot e.g. maybe Nothing is better written (=<<)
04:54:53 <FliPPeh> dobblego: You mean the main function?
04:55:12 <dobblego> FliPPeh, yes and other parts
04:55:16 <FliPPeh> dobblego: I just wrote it to work, as a test for each function :)
04:56:46 <dons> ivanm: nope
04:56:55 <ivanm> bugger
04:57:03 <ivanm> anyway, spotted the problem yet?
04:59:57 * hackagebot MaybeT-transformers 0.1 - MaybeT monad transformer using transformers instead of mtl.  http://hackage.haskell.org/package/MaybeT-transformers-0.1 (ErikHesselink)
05:02:51 <ivanm> is the HXT dev ever here?
05:14:44 <FliPPeh> dobblego: Did you mean it this way:  (return . fst) =<< ((listToMaybe . reads) =<< Just "f5") :: Maybe Int
05:14:47 <FliPPeh> ? :)
05:16:55 <dobblego> FliPPeh, I've closed it now, but there were possible improvements like that; specifically anywhere "maybe Nothing" appears you can replace it with (=<<)
05:17:05 <dobblego> there are othe rpossible improvements too
05:17:32 <xerox> > (fst .) $ listToMaybe . reads $ "5f" :: Maybe Int
05:17:33 <lambdabot>   Just 5
05:20:24 <FliPPeh> @pl  x m = return . fst =<< listToMaybe . reads =<< m :: Maybe Int
05:20:24 <lambdabot> x = (fst `fmap`) . (listToMaybe . reads =<<) . (:: Maybe Int)
05:21:17 <Ytinasni> lol, did that just try to use :: as an operator?
05:21:46 <FliPPeh> yep
05:21:46 <ivanm> nope
05:21:51 <FliPPeh> @pl  x m = return . fst =<< listToMaybe . reads =<< m
05:21:51 <lambdabot> x = (fst `fmap`) . (listToMaybe . reads =<<)
05:21:53 <ivanm> forcing the type of the monad
05:22:00 <ivanm> oh, wait, it was @pl
05:22:23 <FliPPeh> x = (fst `fmap`) . (listToMaybe . reads =<<) :: Maybe String -> Maybe Int
05:22:25 <FliPPeh> This is it
05:23:19 <FliPPeh> Works.
05:23:27 <FliPPeh> Gotta love monadic binds
05:26:27 <dixieErc> >> 0+0
05:26:46 <FliPPeh> > 0+0
05:26:47 <lambdabot>   0
05:30:13 <ivanm> > exp (0:+1 * pi) + 1
05:30:14 <lambdabot>   0.0 :+ 1.2246467991473532e-16
05:30:20 <ivanm> tsk, tsk
05:32:18 <ivanm> I have a look-ahead parser (well, one that will try with the next thing to parse anyway); now I just need a look-ahead printer :s
05:32:48 <dixieErc> > [ x | x <- [1..200], x*x == 42]
05:32:49 <lambdabot>   []
05:33:10 * ivanm seems himself using the split library for graphviz just for HTML labels... :@
05:33:16 <ivanm> anyway, I'll deal with that tomorrow
05:33:19 * ivanm -> land of nod
05:33:21 <ivanm> g'night all
05:33:26 <dixieErc> night
05:33:39 <FliPPeh> I just woke up here ;x
05:33:44 <FliPPeh> Just 2 hours ago!
05:33:48 <FliPPeh> Nighty
05:34:08 <FliPPeh> @time FliPPeh
05:34:11 <lambdabot> Local time for FliPPeh is Sat Mar 20 13:33:09 2010
05:34:15 <FliPPeh> @time ivanm
05:34:16 <lambdabot> Local time for ivanm is Sat Mar 20 23:33:52
05:34:24 <FliPPeh> Nicccceeeee.
05:34:34 <ivanm> you just woke up at 11:30 AM? :o
05:34:40 <FliPPeh> You're almost on tomorrow ;x
05:34:50 <dixieErc> @time dixieErc
05:34:51 <FliPPeh> Yup, it's weekend
05:34:51 <lambdabot> Local time for dixieErc is Sat Mar 20 13:32:47 2010
05:34:56 <FliPPeh> Some sleeping is good for me
05:35:40 <Entroacceptor> lambdabot's timer is off
06:00:09 <byorgey> FliPPeh: did you have a question?
06:02:15 <FliPPeh> byorgey: Not anymore, I figured most of it out
06:02:44 <FliPPeh> It's a very well written article, you just could have backed up some statements with some more examples
06:03:39 <byorgey> FliPPeh: ok, great
06:03:48 <FliPPeh> Especially one part in the "Monad Transformers" part confused me
06:03:51 <FliPPeh> Wait, I'll copy it
06:04:00 <byorgey> yeah, more examples would be good, I agree
06:04:49 <FliPPeh> "Unfortunately, monads do not compose as nicely as applicative functors (yet another reason to use Applicative if you don’t need the full power that Monad provides),"
06:05:06 <FliPPeh> I don't understand the relationship between applicatives and monads
06:05:16 <FliPPeh> They can both be chained in a way
06:05:28 <FliPPeh> But that's all I can think off :/
06:05:34 <byorgey> every Monad is also Applicative
06:05:38 <byorgey> but not vice versa.
06:06:11 <byorgey> I think the Monad section discusses this a bit somewhere else, doesn't it?
06:06:19 <byorgey> if not I should add it.
06:06:25 <FliPPeh> I think it did
06:07:11 <byorgey> pure = return; (<*>) = ap
06:07:48 <byorgey> where  mf `ap` mx = do f <- mf; x <- mx; return (f x)
06:08:17 <FliPPeh> Also what confused me at first was how "(,) e" was part of the Functor, it was too abstract at first, an example like "fmap ([], "string") => ([], "gnirts")" would have been awesome
06:08:37 <byorgey> ah, yes, that would be good
06:09:44 <byorgey> intuitively the difference between Applicative and Monad is that in Applicative, you have to choose which computations you are going to run beforehand
06:10:05 <byorgey> whereas with Monad, you can use intermediate results to choose dynamically which computation you will run next
06:10:27 <FliPPeh> And "fmap f g x" is basically "f . g $ x" ?
06:11:29 <FliPPeh> > fmap length tail "1234" == (length . tail $ "1234")
06:11:30 <lambdabot>   True
06:11:38 <xerox> FliPPeh: yess
06:11:47 <byorgey> yes, that's using the ((->) e) Functor instance
06:12:17 <FliPPeh> But it only works with 2 functions, right?
06:12:43 <FliPPeh> > fmap (div 2) length tail "1234"
06:12:43 <lambdabot>   Couldn't match expected type `t -> t1'
06:12:44 <lambdabot>         against inferred type `GHC.T...
06:13:04 <byorgey> > fmap (div 2) (fmap length tail) "1234"
06:13:05 <lambdabot>   0
06:13:14 <FliPPeh> Ah, okay
06:13:39 <byorgey> don't use fmap like that, though, it's confusing =)
06:13:57 <FliPPeh> I like (.)'ing more :)
06:14:46 <medfly> :t (.)
06:14:47 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:18:08 <FliPPeh> byorgey: Despite the few things I did not understand (which actually helped me really get them, by trying around) it was a great article. Let me know if you have more!
06:20:02 <byorgey> FliPPeh: thanks =)
06:21:41 <iaefai> I found these nice FRP examples at http://www.formicite.com/dopage.php?frp/frp.html  but they don't seem to have enough information for my mind to comprehend what the simple examples are really doing. Does there happen to be another basic tutorial that would come highly recommended?
06:33:07 <olsner> sweet, ghc 6.12 with the haskell-platform beta works nicely on mac
06:34:41 <olsner> but since it still compiles 32-bit only, I need to figure out how to build llvm in 32-bit mode to be able to build the llvm haskell bindings...
06:34:42 <iaefai> They have a new haskell platform?
06:35:01 <olsner> iaefai: only in beta, but yes there is
06:35:22 <iaefai> Isn't haskell platform just ghc with a few extra libs?
06:36:35 <olsner> it used to be that ghc included "most" of the libraries and the platform had the "extra" libraries, now ghc has stopped including anything but the very basics, so you really want both platform and ghc
06:37:41 <olsner> the platform also includes cabal-install, which is very convenient
06:38:25 <dixieErc> Is there plan to include wxhaskell or any GUI framework within platform?
06:39:54 <FliPPeh> The platform isn't that easy to get
06:40:06 <FliPPeh> Because again it uses equality versioning in the cabal package
06:40:13 <FliPPeh> And most packages have been updated since then.
06:40:16 <FliPPeh> Which sucks.
06:41:47 <byorgey> dixieErc: I think it may eventually
06:42:03 <FliPPeh> I wonder why there's no XML package
06:42:14 <FliPPeh> Or Binary
06:42:16 <iaefai> olsner: It really sounds like my ghc-6.12 already is that :-)
06:42:29 <iaefai> But it is good to know that a new platform is out if I want it.
06:42:40 <iaefai> At least 6.12 works out of the box on SL
06:46:34 <Sagi> FliPPeh: there actually is a Binary package
06:46:41 <Sagi> Data.Binary to be precise
06:47:17 <Sagi> or were you talking about the contents of the platform? In which case I should shut up :)
06:49:10 <FliPPeh> Sagi: I was, but you are allowed to keep talking :)
06:49:21 <dankna> yeah, I won't be using the beta...  I only just now got everything the way I like it... but it's great to know it's there
06:49:24 <dankna> it was overdue
06:52:29 <olsner> really, ghc and haskell-platform should sync up their schedules and make sure that ghc-head and HP-head always build
06:53:03 <FliPPeh> No, HP should just not require exact versions for packages.
06:53:12 <StarFire> Does anyone know how to correctly build cabal-install 0.8.0 on windows?
06:53:21 <FliPPeh> Because those update way too often to be realiable
06:53:25 <dankna> I'm in the not-exact-versions camp
06:53:31 <FliPPeh> s/realiable/reliable
06:53:32 <olsner> FliPPeh: I think we're talking about completely different issues
06:53:51 <FliPPeh> olsner: But this is what bothers me the most :)
06:54:22 <olsner> I just mean that there shouldn't be any waiting period the latest ghc is unusable because HP doesn't build with it
06:54:44 <FliPPeh> Well, HP is designed for stableness
06:54:54 <FliPPeh> But the newest GHC is considered unsafe for production use
06:55:02 <FliPPeh> That's what I read last
06:55:24 <FliPPeh> Several new things were introduced in 6.12
06:56:19 <Remy__> I'm getting an overlapping instances error
06:56:24 <Remy__> but one instance is more specific
06:56:58 <Remy__> I have instance (PP a) => PP [a] where .. in one module and    instance PP Stmt where .. in another module
06:57:11 <Remy__> woops, I mean instance PP [Stmt] where .. in another module
06:58:07 <Remy__> the error message is this: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=24164#a24164
06:58:27 <bjornbm> Hi all. Does it make sense that "or [] = False" and "and [] = True"? Is this what a mathematician would expect?
06:59:14 <olsner> FliPPeh: you mean that 6.12.1 is unsafe or that ghc-head is unsafe? anyway, yes, until the releases of HP and GHC they could both be in development and unstable - I just think keeping track of how changes in GHC breaks the packages in HP is important
07:00:18 <Remy__> hmm
07:00:24 <Remy__> can someone help em with the error message: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=24164#a24164
07:01:10 <FliPPeh> Well, you have overlapping type class instances
07:01:21 <FliPPeh> :x
07:03:07 <bremner_> HP: worst acronym of the week
07:03:32 <Zao> bremner_: Harry Potter.
07:04:03 <olsner> no, isn't it Hewlett Packard?
07:04:04 <bremner_> overlapping acronym instances
07:04:48 <olsner> maybe it should be abbreviated HaPl or something instead
07:04:54 <olsner> haskell platform is a bit too long imo
07:05:05 <Jafet> H-splat
07:05:34 <olsner> ha!splat!
07:05:59 <Jafet> A bit too strict
07:07:37 <Mathnerd314> hpl gives enough context
07:08:17 <Vanadium> h.pl
07:08:46 <bremner_> try googling it it.
07:09:28 <Jafet> HP doesn't seem to have much HP right now
07:09:40 * Vanadium casts Cure
07:12:33 <Phyx-> Jafet: but they do have multitouch synaptic touchpads
07:12:33 <Phyx-> yay
07:14:04 <Phyx-> bleh, the haddock library doesn't expose the functionality I need :(
07:22:38 <nomeata> Hi. Has anyone used Text.Data with pcre-light yet?
07:25:34 <FliPPeh> I just don't get .LHS
07:25:46 <FliPPeh> Can I both compile them to TEX and Run them as Haskell?
07:26:12 <dankna> I believe that's the concept, yes.
07:27:01 <byorgey> .lhs has nothing to do with TeX per se.  It's just a format that privileges comments over code.
07:27:14 <mmaruseacph2> can i post a link to my blog where I have described an idea for a haskell project? (for feedback purposes only)
07:27:20 <FliPPeh> I've just tried "making" TMR Issue 14
07:27:24 <FliPPeh> It fails hard.
07:27:30 <FliPPeh> Also I can't install lhs2tex
07:27:33 <byorgey> mmaruseacph2: sure
07:27:41 <mmaruseacph2> http://pgraycode.wordpress.com/2010/03/20/haskell-project-idea/
07:27:44 <byorgey> FliPPeh: what error do you get when installing lhs2tex?
07:27:44 <FliPPeh> Setup: /usr/local/share/texmf: permission denied
07:27:54 <FliPPeh> Using bauerbill for AUR
07:28:19 <mmaruseacph2> basically it is about a debugging tool
07:28:20 <byorgey> oh, yeah, lhs2TeX is naughty, and really wants to install something in /usr/local even if you tell it to install somewhere else.
07:28:31 <mmaruseacph2> where all the debugging is done graphically (think DDD)
07:28:46 * hackagebot hashed-storage 0.4.8 - Hashed file storage support code.  http://hackage.haskell.org/package/hashed-storage-0.4.8 (PetrRockai)
07:28:48 <FliPPeh> byorgey: How can I convince it to behave?
07:29:02 <byorgey> I don't know.  I just installed it with sudo.
07:29:07 <byorgey> not the best solution, I know, but...
07:29:10 <FliPPeh> Meh
07:29:14 <FliPPeh> I was thinking about that
07:29:48 <Phyx-> is there any way to parse a haskell module and get an associative list of functioname to haddock comments?
07:30:56 <FliPPeh> sudo did the trick
07:30:58 <byorgey> mmaruseacph2: sounds cool.  have you looked at Hat?
07:31:08 <byorgey> I haven't actually used Hat but I think it is related
07:31:42 <mmaruseacph2> didn't use it, only read it's description several times
07:32:21 <byorgey> ok.  it sounds like a very cool project to me.
07:33:07 <byorgey> although it also sounds pretty ambitious, but I think if you set some suitably small + specific goals you should be able to get something good done in a summer
07:34:28 <mmaruseacph2> then, I'll start working on it
07:34:30 <mmaruseacph2> thanks
07:34:55 <byorgey> Phyx-: have you looked at haskell-src-exts?
07:34:59 <mreh> @hoogle SF (Event ()) Bool
07:35:00 <lambdabot> Warning: Unknown type SF
07:35:00 <lambdabot> No results found
07:35:11 <mreh> @hoogle FRP.Yampa.SF (Event ()) Bool
07:35:11 <lambdabot> Parse error:
07:35:11 <lambdabot>   --count=20 "FRP.Yampa.SF (Event ()) Bool"
07:35:11 <lambdabot>                 ^
07:35:29 <byorgey> it doesn't do that exactly but it parses Haskell code preserving the comments, so with some fiddling I imagine you could extract what you want from it
07:37:47 <mm_freak> if i want to use an alternative Prelude, can i just import Prelude ()?
07:38:04 <Phyx-> byorgey: It's what I currently use, But It doesn't recognize haddock documentations afaik, the parse functions give a list of all comments in the module, but I would have to do the matching myself
07:38:10 <kingping> How do I read file contents into [Char] list?
07:38:17 <kingping> just used readFile
07:38:43 <Phyx-> byorgey: there's a haddock api, but due to a restriction in the .cabal file's "exposed-modules" I can't get to what I want
07:39:01 <byorgey> Phyx-: oh, boo.
07:39:15 <byorgey> Phyx-: what is this for?  something you want to release soon, or just for personal use?
07:39:15 <Phyx-> kingping: readFile will get you an IO [Char] yeah
07:40:03 <kingping> I just need to make sorting and write contents back to a file.
07:40:53 <Phyx-> byorgey: well, I'm making a tool which I might release, but currently it's for personal use, it basically compiles marked haskell functions into a shared lib and generates the related c/c++ code so you can call these functions. But I thought it would be a good idea to preserve the functions. so that someone given the shared lib and the header file has some info on the function/arguments
07:40:55 <kingping> However it would also be useful to write some data to CLI.
07:41:07 <byorgey> kingping: you can do something like this:   do { contents <- readFile "filename"; writeFile "anotherFileName" (yourSortFunction contents) }
07:41:37 <kingping> Hmm, thanks, byorgey, I'm gonna try it.
07:42:16 <byorgey> Phyx-: ok, if I were you, I would just get the Haddock source and edit the .cabal file to expose the module you want, and then also file a feature request to do the same thing in the next official release of Haddock
07:42:19 <syntaxglitch> mm_freak, or use {-# LANGUAGE NoImplicitPrelude #-}
07:42:40 <mm_freak> syntaxglitch: i'd prefer not to use an extension
07:42:44 <byorgey> Phyx-: that way hopefully you will eventually be able to migrate back to an official version of Haddock instead of using your own patched version
07:42:54 <mm_freak> it seems to work that way
07:43:09 <syntaxglitch> mm_freak, the language pragma excludes more stuff than just import Prelude ()
07:43:23 <Phyx-> byorgey: well, I found this aswell, http://hackage.haskell.org/trac/ghc/wiki/HaddockComments , but the types in that page don't overlap with what I see in the ghc api docs. So i'm wondering how old that page is.
07:44:01 <choffstein> Good morning!  Quick question: what is the best way to pick out the middle of a list?  i.e. take off the front and back elements?
07:44:12 <Phyx-> byorgey: yeah, I'm think i'll do that
07:44:27 <byorgey> Phyx-: hmm, I don't know.  I imagine the functionality would still be in the GHC API, even if some names have changed
07:44:33 <Phyx-> choffstein: using drop and take?
07:44:42 <nomeata> Hi. How can I make parsec fail with a custom error message, in a way that does _not_ add "unexpected ...; expected ..." information to the error message?
07:44:56 <byorgey> > init . tail $ [1..5]  -- like this?
07:44:57 <lambdabot>   [2,3,4]
07:45:01 <syntaxglitch> choffstein, lists are inherently sequential so it's much faster to drop back elements all at once
07:45:11 <choffstein> byorgey: perfect
07:45:17 <mm_freak> syntaxglitch: oh, indeed, but can i reproduce the syntactic rewrite stuff, when i use NoImplicitPrelude?
07:45:24 <byorgey> choffstein: note, that will crash if the list has length < 2, though
07:45:28 <mm_freak> i mean without pragmas/extensions
07:45:53 <byorgey> choffstein: so maybe wrap it up in your own function which checks for the empty and one-element cases first
07:46:10 <choffstein> byorgey: will do.  Appreciate the help
07:46:41 <Phyx-> byorgey: well, the big thing there is, that the "RenamedSource" type contains a 5th element in the tuple " HaddockModInfo Name" , but the lastest docs http://www.haskell.org/ghc/docs/latest/html/libraries/ghc/GHC.html#t%3ARenamedSource doesn't have it
07:47:41 <byorgey> Phyx-: hmm, well, I don't know then
07:48:19 <FliPPeh> Man
07:48:26 <FliPPeh> Latex is a bit... messy thing
07:48:29 <byorgey> Phyx-: you should ask waern
07:48:37 <FliPPeh> Can't find lhs2tex.fmt
07:48:41 <FliPPeh> Can't find polycode.fmt
07:48:42 <byorgey> preflex: seen waern
07:48:42 <preflex>  waern was last seen on #haskell 1 day, 2 hours, 11 minutes and 59 seconds ago, saying: dobblego: ok :-)
07:48:43 <FliPPeh> Where the hell?
07:48:50 <Phyx-> Think it might be easier to tweak my match Comments function to recognize haddock comments too, since i already use it to recognize my own comment types, -- @@ and {- @@
07:48:54 <byorgey> FliPPeh: you need lhs2TeX
07:48:56 <dankna> Flippeh: you want to be using a distribution of TeX/LaTeX
07:48:56 <syntaxglitch> mm_freak, I think messing around with syntactic sugar needs the pragma... not sure, though
07:48:58 <FliPPeh> I do
07:49:01 <FliPPeh> I do
07:49:03 <Phyx-> byorgey: ah, cool, i'll set a hilight on his name
07:49:05 <dankna> rather than a custom install
07:49:06 <FliPPeh> texlive and lhs2tex
07:49:08 <dankna> okay
07:49:09 <dankna> hrm
07:49:11 <dankna> then I dunno
07:49:12 <mm_freak> syntaxglitch: ok, thanks
07:49:20 <FliPPeh> I installed texlive-core from the arch linux repos
07:49:26 <FliPPeh> I don't know if that's all I need
07:49:31 <dankna> actually, I don't think I've ever seen formatted lhs output
07:49:45 <dankna> for some reason it's not that popular to put it on the web - you'd think it would be
07:50:00 <mm_freak> isn't there an alternate Prelude project somewhere?
07:50:02 <byorgey> FliPPeh: yeah, that should be enough, hmm
07:50:14 <dankna> maybe nobody can make it work, haha
07:50:21 <kingping> byorgey: Yep, that sort of thing works. I suppose this code http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24165#a24165 wouldn't result in processed data when it prints a string at line 7 until we write the new data back to a disk?
07:50:25 <byorgey> mm_freak: there's numeric-prelude
07:50:30 <byorgey> mm_freak: there may be others as well
07:50:36 <syntaxglitch> mm_freak, a quick test indicates that replacing the desugared syntax for do notation at least seems to require the pragma, if that's what you're after
07:51:08 <byorgey> kingping: yes, in fact when that code prints 'Sorting done' it hasn't even read the file yet! =)
07:51:16 <kingping> byorgey: I mean, because of a lazy nature I can't guarantee that on line 7 I'll have all the processed data in the memory.
07:51:23 <byorgey> right.
07:51:23 <kingping> LOL
07:51:28 <dankna> heh, http://hackage.haskell.org/package/base-unicode-symbols is a neat idea
07:51:30 <mm_freak> byorgey: thanks
07:52:04 <kingping> However print (newcontents !! 3) would do the job? :)
07:52:21 <byorgey> well, part of it at least
07:52:22 <mm_freak> hmm, ok, i think i'll stop following my idea
07:52:29 <syntaxglitch> dankna, but the single most important bit of unicode syntax is missing, since it's not legal Haskell :(
07:52:43 <byorgey> actually, yes, I guess it would need the entire file to know what the third element of the sorted file would be
07:52:48 <kingping> byorgey: Implying 3 is the last byte of file.
07:52:49 <dankna> syntaxglitch: which one is that?
07:52:54 <syntaxglitch> lambda
07:52:57 <dankna> oh!
07:52:58 <dankna> yeah
07:53:02 <dankna> that's a true shame
07:53:04 <syntaxglitch> it's a letter :(
07:53:07 <dankna> yeah :(
07:53:09 <dankna> I see that
07:53:28 <dankna> well, you could define it as a language extension LambdaInGreek and go through the standards process to get it incorporated, haha
07:53:40 <gwern> dankna: and then he could ask for a pony!
07:53:48 <dankna> yes!  ghostcrawler promised me a pony.
07:53:49 <mm_freak> i wanted to try to fix some of the unfortunate design choices of the standard Prelude, but that seems to be much more work than i have thought
07:54:23 <byorgey> FliPPeh: I seem to have polycode.fmt in $HOME/local/share/lhs2tex-1.15/
07:54:33 <byorgey> FliPPeh: $HOME/local is where I install stuff in my home directory
07:54:39 <byorgey> FliPPeh: do you have something similar?
07:54:42 <kingping> I wonder how do I force eager processing, because I need to count the CPU time program uses to process data.
07:54:55 <dankna> actually one thing that annoyed me
07:54:56 <gwern> byorgey: bah. ~/bin is far more sensible
07:55:02 <dankna> was that I couldn't define variable names delta-t and so on
07:55:08 <dankna> with the delta as an uppercase greek letter
07:55:11 <dankna> because it's uppercase
07:55:13 <dankna> so it's a type name
07:55:24 <gwern> use the math lambda char then
07:55:26 <FliPPeh> byorgey: Nope, no lhs2tex subdirectory
07:55:34 <dankna> is there one?  *goes to look*
07:55:34 <mm_freak> kingping: use seq or deepseq on the end result
07:55:40 <byorgey> FliPPeh: or maybe look in /usr/local/share?
07:55:50 <FliPPeh> lhs2tex /usr/share/lhs2tex-1.15/polycode.fmt
07:55:50 <kingping> Hmm
07:55:50 <Zao> gwern: Sane people use subdirs based on ${OSTYPE} and ${MACHTYPE}.
07:55:51 <gwern> dankna: of there's one
07:55:54 <FliPPeh> There it is
07:55:58 <gwern> dankna: unicode has everything
07:56:04 <Zao> It's a bit naive to limit yourself to a single arch.
07:56:05 <gwern> even little snowmen
07:56:06 <syntaxglitch> gwern, the math lambda unicode character is still a letter, I think
07:56:14 <dankna> gwern: yes I love ?
07:56:15 <gwern> syntaxglitch: but not a greek one!
07:56:21 <FliPPeh> byorgey: Would symlinking help, or is there something easier?
07:56:23 <mm_freak> kingping: if the calculation takes a lot of time, one easy way to ensure evaluation is to print the result
07:56:48 <dankna> but yes, it's a letter, I just looked
07:56:51 <byorgey> FliPPeh: I was just making sure you actually had the files installed somewhere
07:56:52 <Zao> mm_freak: Assuming that formatting it and outputting it doesn't take significant time.
07:56:59 <dankna> Unicode isn't big on including multiple copies of things which are semantically the same
07:57:04 <FliPPeh> They're in /usr/share/lhs2tex-1.15/, yep
07:57:04 <byorgey> FliPPeh: I don't know, I haven't had this problem before
07:57:19 <mm_freak> Zao: that's way i said, "if the calculation takes a lot of time", so formatting/outputting time gets neglible =)
07:57:19 <byorgey> ok, weird that it can't find them then, hmm...
07:57:21 <kingping> mm_freak: nono, the file may be big, I just need to make sure it's processed before I get the time after processing and compare it to the time before processing. ;)
07:57:33 <FliPPeh> I just symlinked it
07:57:35 <mm_freak> kingping: "processed" or "read"?
07:57:35 <FliPPeh> Let's find out
07:58:03 <kingping> mm_freak: Just a CPU time without I/O.
07:58:51 <FliPPeh> strange
07:59:21 <byorgey> did it wokr?
07:59:25 <FliPPeh> Nope
07:59:25 <byorgey> or work?
07:59:42 <FliPPeh> The files are there, it even lists the real directory they're in under the search directories
07:59:44 <fax> hi
07:59:45 <FliPPeh> But it just doesn't read
08:00:12 <byorgey> very strange, I don't know why it wouldn't know where to look for them...
08:00:22 <FliPPeh> Hm
08:00:26 <FliPPeh> Wait a sec...
08:00:54 <fax> wha tabout CHEVALLEY-WARNING
08:01:05 <sm> @seen alexsuraci
08:01:05 <lambdabot> Unknown command, try @list
08:01:19 <Axman6> preflex: seen alexsuraci
08:01:19 <preflex>  alexsuraci was last seen on #haskell 15 hours, 58 minutes and 41 seconds ago, saying: what's the replacement package for old-locale?
08:01:25 <FliPPeh> byorgey: If I run it with sudo it DOES work.
08:01:38 <wavewave> how can I use parsec3?
08:01:39 <FliPPeh> It can find the files, but can't read them
08:01:44 <FliPPeh> But still displays "not found"
08:01:47 <wavewave> any tutorial?
08:01:49 <FliPPeh> Talk about intelligent error messages
08:01:56 <FliPPeh> Just as great as "user is drunk"
08:02:04 <sm> thank you Axman6 . How come lambdabot doesn't understand seen, listed at http://code.haskell.org/lambdabot/COMMANDS ?
08:02:17 <Zao> FliPPeh: strace/truss the process?
08:02:18 <Axman6> wavewave: there's plenty of tutorials
08:02:26 <byorgey> FliPPeh: oh, yuck
08:02:42 <byorgey> FliPPeh: so I guess you should just change the permissions on the files so they are readable
08:02:52 <mm_freak> kingping: well, deepseq will do what you want
08:02:57 <FliPPeh> Hackity Hack
08:02:59 <wavewave> What I found is only for parsec2.
08:03:03 <mm_freak> it's the safest way to ensure evaluation
08:03:09 <dankna> Flippeh: Could be worse.  It could be Error: Success.
08:03:15 <wavewave> I want to use parsec as a monad transformer.
08:03:25 <gwern> sm: seen was removed by someone because of space leaks
08:03:27 <FliPPeh> dankna: That's creative
08:03:40 <mm_freak> kingping: in some cases asking for the last element will work, too, but you can't count on that…  haskell is very good at not calculating stuff it doesn't need
08:03:44 <sm> ah, thanks. Maybe that page could be updated by... ?
08:03:51 <dankna> isn't it though?  it happens when you call strerror when errno is zero...
08:04:15 <kingping> mm_freak: I see. Thanks.
08:05:33 <FliPPeh> byorgey: How owuld I colorize the haskell code within the resulting tex document?
08:07:28 <byorgey> in general, colorizing Haskell code can be done with HsColour, or highlighting-kate (perhaps via pandoc)
08:07:41 <FliPPeh> Okay :)
08:07:50 <byorgey> but I don't know if there's an easy way to colorize the pdf output of an existing lhs2TeX document
08:08:09 <dankna> well
08:08:15 <dankna> if you don't need hyperlinks, just coloring
08:08:35 <dankna> you could make a preprocessor that finds the \begin{code} .. \end{code} sections and pipes them through individually
08:08:54 <dankna> and outputs a new lhs with appropriate \-directives in it
08:09:10 <dankna> and then run the resulting lhs through lhs2TeX as normal
08:09:25 <dankna> this is nontrivial, I'm glossing over hard parts :)
08:10:50 <byorgey> I don't think that would work, lhs2TeX would choke on LaTeX directives mixed into the Haskell code
08:11:25 <byorgey> you'd have to hack it into lhs2TeX directly, I think, so that it outputs color directives
08:11:35 <fax> we need TeX2lhs
08:11:37 <dankna> well, but I don't think it's actually the \begin-\end delimiters that lhs2TeX uses to determine which parts are code, is it?  it's the > prefix or lack of it
08:11:58 <byorgey> dankna: it can use either one.
08:12:07 <dankna> so you'd use the > prefix to make your color-processed code be ignored by -- oh
08:12:11 <dankna> well that tears that then
08:12:34 <dankna> you're right, you'd need to hack lhs2TeX directly
08:13:26 <dankna> wait
08:13:32 <byorgey> cleaning up, generalizing, and improving lhs2TeX could actually make a nice project for someone
08:13:37 <byorgey> maybe even a GSoC project
08:13:52 <dankna> I'm reading http://people.cs.uu.nl/andres/lhs2tex/Guide2-1.15.pdf
08:14:02 <dankna> yeah, that would be awesome, shame I'm not eligible for GSoC
08:14:15 <byorgey> it's a fantastic tool but feels kind of hacked together in some ways, and I know the original authors don't really have the time or intention to keep working on it that much anymore
08:14:19 <dankna> in the sample output in that document it looks to me like it already generates TeX directives for keywords and stuff
08:14:32 <byorgey> yeah, it does
08:14:36 <dankna> so you'd just need to write a new LaTeX style that applies actual color to it, right?
08:14:45 <byorgey> yeah, you're right, you probably could do that
08:14:55 <dankna> yeah, that's sadly true of a lot of software - that the original authors don't have time for it anymore
08:15:09 <byorgey> e.g. \renewcommand{\Conid}[1]{\color{blue}{\Conid{#1}}}
08:15:30 <dankna> yes!  I didn't know enough TeX to know how to do that, but yes, something like that :D
08:15:38 <byorgey> =)
08:15:59 <dankna> personally, I'm not a big fan of color anyway.  it makes AS much sense AS putting every preposition IN English IN its own style
08:16:05 <fax> Chevalley’s Theorem says that every system of polynomials in F_q^a which has 0 constant terms has a solution
08:16:05 <byorgey> hehehe
08:16:07 <dankna> grin
08:16:14 <FliPPeh> I like the birdy style Literate Haskell
08:16:20 <fax> what about implementing it in haskell
08:16:21 <FliPPeh> It's much easier :x
08:16:47 <dankna> yeah, the birdy style - as you call it :) - is nicely intuitive
08:16:48 <byorgey> don't forget TO capitalize all the Nouns
08:16:48 <fax> oops p^a
08:17:03 <mauke> Ricky Birdy?
08:17:04 <dankna> haha yeah, HOW could I forget That
08:17:10 <fax> lol
08:17:14 <mauke> 'That' is not a noun
08:17:25 <FliPPeh> LET'S JUST TURN ON CAPSLOCK, SHALL WE?
08:17:26 <dankna> granted
08:17:38 <dankna> no no, capslock defeats the point.  the idea is to assault the reader with visual noise.
08:17:52 <FliPPeh> HoW's ThIs FoR SoMe NoIsE
08:17:54 <byorgey> capslock is like syntax highlighting all of your Haskell code in yellow.
08:17:59 <dankna> yes, just so
08:18:00 <FliPPeh> I hate people who type like that tbh
08:18:05 <FliPPeh> I want to punch them hard
08:18:07 <mauke> The Idea is to make english Text look like german.
08:18:12 <dankna> hahaha
08:18:17 <FliPPeh> :(
08:18:26 <byorgey> or like Ye Olde Englisshe Text.
08:18:43 <Entroacceptor> German is pretty easy to read.
08:18:56 <dankna> I have nothing against the German language, but perhaps I would if I ever tried to learn it, haha
08:18:58 <twink> Fonts might help, but you've got to know how the grammar used to work in Middle English.
08:19:01 <eldragon> mauke, The Idea is to make german Text look like russian.
08:19:04 <dankna> I do think the agglutinative phrase things are cool
08:19:12 <Jafet> Haskell is very German.
08:19:17 <Entroacceptor> Jawoll
08:19:28 <FliPPeh> German seems to be the hardest language on earth, considering a lot of young people in this country don't even know it...
08:19:39 <FliPPeh> I could go around punching people all day
08:19:44 <dankna> twink - yeah - _A Comprehensive Grammar of the English Language_ has a complete chart of the Olde pronouns.  common contemporary "olde" English misuses them badly.
08:20:03 <twink> no, not even closely
08:20:19 <Jafet> Du punchst sie!
08:21:04 <twink> German is nowhere near the most difficult language. Russian is probably somewhere high up in the rankings but probably still not in the top 10.
08:21:04 <fax> Has anyone made an algebra systems in haskell
08:21:12 <fax> or designed one
08:21:17 <dankna> Japanese is often ranked among the difficult ones
08:21:33 <FliPPeh> Japanese is easy
08:21:40 <eldragon> dankna, what about chinese?
08:21:42 <FliPPeh> Just stuff some underscores and other signs
08:21:42 <dankna> but I don't think that's because of grammatical complexity
08:21:45 <FliPPeh> ^____^
08:21:45 <twink> The deal with Russian is that it's got a hugely complex grammar like Latin, Greek, and Sanskrit, but it's horrendously irregular.
08:21:47 <FliPPeh> $____$
08:21:48 <dankna> just because of the lack of cognates
08:21:58 <Entroacceptor> Finnish is hard
08:22:03 <dankna> eldragon: well, I don't personally have any knowledge of Chinese, but I presume it is too
08:22:04 <mauke> wait, latin Grammar is complex?
08:22:06 <Jafet> Most difficult for Americans expatriates to learn?
08:22:15 <Entroacceptor> latin grammar is easy
08:22:21 <mauke> then i should have no Problem with russian
08:22:30 <twink> Chinese and Japanese have the trouble with ideogrammatic writing systems.
08:22:32 <Jafet> The American military did a survey and concluded it was the Korean language.
08:22:40 <dankna> really?  interesting!
08:22:41 <twink> Otherwise they're really easy languages.
08:23:05 <dankna> yeah, that's my take, twink
08:23:11 <twink> mauke: Why is irregularity peppered throughout a hugely complex grammar easy for you?
08:23:29 <eldragon> Jafet, from South or from North?
08:23:39 <Jafet> twink, are you sure you're talking about latin
08:23:52 <twink> Jafet: No, Russian.
08:24:08 <Jafet> I had the impression you were talking about english
08:24:21 <twink> Jafet: English's grammar is trivial.
08:24:48 <Jafet> That's because you're fluent
08:24:55 <ManateeLazyCat> Check gtk2hs darcs version, have demo program under `gtk2hs/demo/webkit/', just make it, you will got WebKit broswer like this: http://farm3.static.flickr.com/2800/4448123474_3879e3f878_o.png
08:24:58 <ManateeLazyCat> Enjoy!
08:25:00 <ManateeLazyCat> :)
08:25:10 <luite> I always wonder how many people who claim that some language x is easy actually speak and write it fluently
08:25:15 <fax> cool!
08:25:45 <mauke> twink: english is impossible
08:25:50 <twink> Jafet: In objective measures of complexity, it is. Russian has a big fat old Latin/Greek/etc. -style grammar setup *BUT* it's massively irregular. So the umpteenth declension of some noun in some case is irregular, the perfective aspect of some verb in some tense is irregular, etc.
08:26:16 <ManateeLazyCat> If anyone find any webkit problem in gtk2hs, can send mail to me.
08:26:19 <ManateeLazyCat> I will fix it.
08:26:20 <dankna> my friends who are actually multilingual don't feel the need to brag about how language X is easy
08:26:22 <merijn> English is pretty simple compared to say Dutch
08:26:40 <dankna> I think it's people who aren't totally fluent yet who like to brag :)
08:27:08 <merijn> I'm more likely to make English in my native language then in English, it's sad :<
08:27:12 <ManateeLazyCat> My mail have wrote in my screenshot http://farm3.static.flickr.com/2800/4448123474_3879e3f878_o.png . :)
08:27:21 <merijn> Of course I still can't type...
08:27:28 <merijn> s/English/errors
08:27:49 <yottis> english is pretty simple, there's just a lot of idioms
08:27:52 <fax> :D
08:27:55 <ManateeLazyCat> Chinese is most complicated, AFAIK
08:27:58 <twink> Jafet: There are probably some other ones out there that pepper a lot of irregularity around complex grammar. Not sure how/why English is so bad, apart from maybe needing massive vocabulary.
08:28:13 <mauke> english is made of Exceptions
08:28:50 <twink> ManateeLazyCat: How is Chinese complicated, apart from the ideogrammatic writing system?
08:28:52 <Jafet> English declensions and inflections make it one of the most irregular widely used languages
08:28:58 <dino-> Speaking of language, I was looking at lojban a little bit a couple weeks ago. Interesting!
08:28:58 <Jafet> twink, it's age
08:29:03 <Jafet> its, even
08:29:17 <EvanR> has anyone tried sdl on windows or osx, i heard the haskell bindings.. dont work?
08:29:38 <dankna> EvanR: I wrote my own bindings... heh
08:29:39 <ManateeLazyCat> twink: There have different mean for same word at different environment, even for character.
08:29:51 <dankna> EvanR: well, not bindings at all actually, a complete replacement for SDL
08:30:01 <Jafet> "port"
08:30:01 <EvanR> interesting
08:30:01 * companion_cube finds spoken english quite hard to understand, but it is quite easy to read/write
08:30:32 <yottis> and how easy some language is depends a lot on if you know some related language already or not
08:30:32 <dankna> EvanR: if you're interested, I'd love your feedback on it.  it's not released because not everything is done yet, but you can get it from http://dankna.com/software/ -- scroll down to Emerald Frame
08:30:48 <EvanR> how portable is it
08:30:59 <dankna> Mac and Win so far, Lin planned before release
08:31:06 <fax> if the number of variables of a polynomial (on a finite field) is bigger than the degree then it has a nonzero solution
08:31:10 <EvanR> dankna: audio?
08:31:28 <twink> ManateeLazyCat: Not sure I entirely see how that happens.
08:31:31 <dankna> yep!  but not streaming, only preloaded, so far.  streaming is planned though.
08:31:40 <luite> hmm, to me, writing english takes considerably more effort and concentration than writing in my native tongue (Dutch)
08:33:13 <dankna> EvanR: also, you can view the documentation for the C version of it (it's in C with a complete Haskell binding included) at...
08:33:28 <dankna> http://dankna.com/software/darcs/Emerald-Frame/API.html
08:33:40 <dankna> none of the text stuff is implemented on Win yet, just to warn you
08:33:56 <ManateeLazyCat> twink: Example a simple word: 牛， original mean "cattle", but if someone say 牛 to you, he not mean you're cattle, it's mean you're so cool!
08:34:04 <dankna> in case that's a deal-breaker
08:34:42 <ManateeLazyCat> twink: If you next meet Chinese man that so cool, you can say: 你太牛了!
08:34:53 <luite> ManateeLazyCat: originally 'cool' meant cold, but when someone says you're 'cool' he doesn't mean you're cold ;)
08:35:19 <ManateeLazyCat> 你 - You, 太 - So， 牛 - Cool
08:35:39 <ManateeLazyCat> 了 for mood
08:36:03 <EvanR> dankna: i only have linux, i just like support for other things. and a callback driven audio api is essential
08:36:08 <ManateeLazyCat> Of course, those is too simple, Chinese is complicated because it's have 2000 years history.
08:36:29 <ManateeLazyCat> Even longer
08:36:31 <EvanR> > "牛"
08:36:32 <lambdabot>   "\29275"
08:36:37 <dankna> EvanR: fair enough.  well, Emerald Frame is not yet for you, then.  that's a shame :)
08:36:45 <EvanR> seems so
08:38:17 <fax> when someone writes  (0,...,0) \= (x1,...,xn)
08:38:34 <fax> does it mean that every xi \= 0 or just one xi \= 0?
08:38:38 <Cale> at least one
08:38:39 <fax> at least one*
08:38:54 <mauke> \=?
08:39:01 <Cale> /=
08:39:02 <fax> I tried to write /= like haskell
08:39:08 <fax> I got it wrong :(
08:39:17 <ddarius> > (0,0) /= (1,0)
08:39:18 <lambdabot>   True
08:39:40 <Vanadium> > (0) /= (1)
08:39:41 <lambdabot>   True
08:40:00 <fax> let F any field, x^1 + ay^2 = 0 iff exists m in F such that m^2 = -a
08:40:08 * hackagebot gdiff 1.0 - Generic diff and patch  http://hackage.haskell.org/package/gdiff-1.0 (EelcoLempsink)
08:40:22 <fax> (0,0) /= (x,y)
08:40:50 <fax> I don't why x^2 /= 0 :P
08:41:17 <fax> maybe because you divide by x to get x /= 0
08:44:32 <Cale> fax: Sorry, I'm not sure I understand what you mean by x^1 + a y^2 = 0 -- how are the variables there quantified? Are you saying that it has a solution at all?
08:44:46 <fax> oh no I meant to write x^2
08:46:21 <twink> fax: nonzero I presume
08:46:23 <Cale> Ah, okay, so x + a x^2 = 0 iff x (1 + a x) = 0 iff (x = 0 or 1 + a x = 0) iff (x = 0 or x = -1/a)
08:46:30 <fax> yes
08:46:32 <fax> corrolory
08:46:33 <fax> in the finite field F_p^a, x^2 + y^2 has a nontrivial solution iff p = 2, p = 1 (mod 4) or a is even.
08:47:50 <fax> interesting
08:48:45 <fax> if a is even then p^(a/2) is not zero, but p^2 = 0
08:53:24 <Cale> fax: Well, you know the theorem which says that p = x^2 + y^2 iff p = 1 (mod 4)
08:53:34 <fax> no I don't
08:53:35 <Cale> Oh, where p is an odd prime
08:53:45 <fax> hmmm
08:53:55 <fax> oh this!!!
08:54:00 <Cale> That's a classical result which seems very closely related to this.
08:54:04 <fax> this comes from gaussian integer
08:54:23 <Cale> Yeah, I believe there's a particularly nice proof using Gaussian integers.
08:54:32 <twink> fax: Whether p ramifies in Z[i]?
08:54:41 <fax> I don't know ramifies :(
08:54:59 <twink> fax: stops being prime, e.g. 2 = (1+i)*(1-i)
08:55:17 <fax> hmm
08:55:25 <twink> fax: (more literally it "branches" as per the Latin etymology of the word)
08:58:55 <fax> http://en.wikipedia.org/wiki/Proofs_of_Fermat%27s_theorem_on_sums_of_two_squares
08:59:59 <Cale> yeah
09:00:11 <Cale> I like the "one-sentence proof" at the end.
09:00:24 <fax> I don't have enough background to understand it
09:00:41 <fax> I thnink there was a similar proof of lagrange four squares too
09:00:52 <rothwell> is there some way to get QuickCheck to run a test and return the results to me, rather than doing i/o?
09:00:52 <fax> but maybe I am just remembering this one, wrongly
09:01:16 <Cale> It involves some trickery in terms of coming up with the funny involution in the first place, but to check that it's right is not hard, and there's still a clever idea there :)
09:01:27 <rothwell> i'd like a function that returns true if the test passed or false and the data that caused the test to fail
09:02:03 <Cale> I like the idea of showing that a set is nonempty by showing that it has an odd number of elements :)
09:02:14 * hackagebot leksah-server 0.8.0.3 - Metadata collection for leksah  http://hackage.haskell.org/package/leksah-server-0.8.0.3 (JuergenNicklischFranken)
09:03:02 <ManateeLazyCat> http://www.di.ens.fr/~simona/gtk-modules.tgz this have all gtk+ binding code for Gtk+ 2.18, just do some `merge` work will update all Gtk2hs Gtk-module API to 2.18.3
09:03:15 * hackagebot leksah 0.8.0.3 - Haskell IDE written in Haskell  http://hackage.haskell.org/package/leksah-0.8.0.3 (JuergenNicklischFranken)
09:03:41 <ManateeLazyCat> If anyone want help now, please contact me. To avoid duplicate work.
09:03:55 * ManateeLazyCat I'm try to update those Gtk+ API in one or two days.
09:03:58 <ManateeLazyCat> Thanks!
09:05:02 <ManateeLazyCat> Just unpack gtk-modules.tgz then `diff` with same module in darcs version. That's all.
09:05:18 <ManateeLazyCat> Don't need write any code, so simple.
09:06:17 <byorgey> Cale: hah, that's clever, I hadn't seen that proof before =)
09:08:26 <ManateeLazyCat> Off now to update gtk2hs API, my mail is lazycat.manatee@gmail.com , thank!
09:10:17 * hackagebot regular-web 0.1 - Generic programming for the web  http://hackage.haskell.org/package/regular-web-0.1 (ChrisEidhof)
09:10:42 <Cale> rothwell: One sec, let me check :)
09:10:55 <rothwell> Cale: thanks
09:11:36 <Cale> rothwell: I seem to recall that this was something that could use a bit of improvement about QC.
09:11:45 <rothwell> yeah, seems it
09:11:59 <rothwell> there's an "evaluate" function that looks like it has nearly the right type... not sure how to use the result, however
09:12:02 <Cale> rothwell: It has most of the facilities outside IO, but the quickCheck function itself doesn't have a non-IO analogue.
09:12:40 <Cale> There is, however, a quickCheckWithResult function
09:12:42 <byorgey> Cale: wouldn't it have to take a random generator as a parameter then?
09:12:47 <Cale> byorgey: yeah
09:13:11 <Cale> byorgey: Or just be in the Gen monad.
09:13:23 <byorgey> yes, true
09:13:49 <FliPPeh> Maaan
09:13:57 <rubendg> hi all, I was wondering why: map map map [[1,2],[3]] doesn't work and fmap fmap fmap [[1,2],[3]] does...
09:13:59 <FliPPeh> There's ABSOLUTELY no good documentation to lhs2tex
09:14:15 <Cale> FliPPeh: Really?
09:14:17 <mauke> rubendg: because the first fmap is not map
09:14:26 <Cale> FliPPeh: I seem to recall the documentation was fairly comprehensive...
09:14:34 <Zao> @type fmap fmap
09:14:35 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
09:14:36 <Zao> @type map map
09:14:36 <FliPPeh> Cale: It installs in a way where I can use it only with sudo
09:14:37 <lambdabot> forall a b. [a -> b] -> [[a] -> [b]]
09:14:45 <Cale> rubendg: Because one of the fmaps specialises to function composition
09:14:46 <FliPPeh> Cale: And hours of search didn't help me ONE bit
09:14:47 <fax> http://books.google.co.uk/books?id=8h8aWmnp1k8C&pg=PR11#v=onepage&q=&f=false
09:14:54 <fax> this book looks good
09:15:08 <fax> number theory Peter Gustav Lejeune Dirichlet, Richard Dedekind
09:15:09 <Zao> @type fmap fmap fmap
09:15:10 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
09:15:17 <fax> @type Peter Gustav Lejeune Dirichlet Richard Dedekind
09:15:18 <lambdabot> Not in scope: data constructor `Peter'
09:15:18 * hackagebot regular-web 0.1.1 - Generic programming for the web  http://hackage.haskell.org/package/regular-web-0.1.1 (ChrisEidhof)
09:15:18 <lambdabot> Not in scope: data constructor `Gustav'
09:15:18 <lambdabot> Not in scope: data constructor `Lejeune'
09:15:20 <Cale> http://people.cs.uu.nl/andres/lhs2tex/Guide2-1.15.pdf
09:15:24 <Cale> ^^ there is the manual
09:15:46 <Cale> The installation instructions are a little out of date, you can now just cabal install it.
09:16:00 <FliPPeh> It's packed for my system
09:16:07 <Cale> Yeah, I don't use that one.
09:16:29 <Cale> (Maybe it's fine, but I don't know)
09:16:30 <fax> http://en.wikipedia.org/wiki/Johann_Peter_Gustav_Lejeune_Dirichlet
09:16:39 <fax> Johann Peter Gustav Lejeune Dirichlet (German pronunciation: [ləˈʒœn diʀiˈkleː]; 13 February 1805 – 5 May 1859) was a German mathematician  credited with the modern formal definition of a function
09:16:43 <FliPPeh> Cabal has the horrible problem that you cannot simply remove those packages.
09:16:44 <fax> he invented functions :D
09:16:46 <FliPPeh> I hate system clutter
09:17:22 <mauke> wait, German pronunciation?
09:17:26 <mauke> looks French to me
09:17:37 <Cale> FliPPeh: Yeah, but everything goes into a subdirectory of your home directory and is neatly organised under there anyway
09:17:57 <rubendg> Cale: why is this the case for the first fmap?
09:18:08 <Cale> fax: heh, [citation needed]
09:18:22 <Cale> rubendg: Because that's the only way that it'll typecheck
09:18:26 <Cale> fmap fmap fmap
09:18:37 <Cale> The second fmap is obviously a function and not a list
09:18:42 <Cale> er, the third, rather
09:18:44 <fax> :p
09:18:45 <FliPPeh> Cale: cabal still wants to put stuff into /usr/
09:18:51 <Cale> (the second parameter to fmap)
09:18:59 <FliPPeh> Don't know if it's cabal or lhs2tex
09:19:00 <Cale> FliPPeh: That's wrong...
09:19:11 <FliPPeh> setup: /usr/local/share/texmf/tex/latex/polytable: permission denied
09:19:12 <FliPPeh> cabal: Error: some packages failed to install
09:19:12 <Cale> FliPPeh: It should install things as user by default.
09:19:17 <Cale> hmmm
09:19:27 <FliPPeh> I had the same problem with the normal package
09:19:29 <Cale> oh, right
09:19:38 <FliPPeh> The files are created in a way so that only root can READ them
09:19:43 <Cale> there's some extra TeX stuff you need to go along with lhs2tex
09:19:45 <rubendg> Cale: a thanks now I see
09:20:04 <FliPPeh> Now this is helpful news.. what would I need?
09:20:10 <FliPPeh> I've got texlive-core installed
09:20:22 <fax> "If p is a positive odd rational prime" -- what is a rational prime?
09:20:30 <u_quark> I am looking for efficient applicative order (inner-most, left-most - not call by value) evaluation implementations - any pointers ?
09:20:47 <Cale> FliPPeh: There's a polytable.sty and lazylist.sty which come inside the cabal package, and they need to be installed in a place where your TeX distribution can see them
09:21:04 <FliPPeh> So sudo' it...
09:21:07 <Cale> If you have a local texmf directory already, I would rcommend putting them in there.
09:21:38 <Cale> I put them in ~/texmf/tex/
09:22:02 <FliPPeh> "texmf" or ".texmf"?
09:22:34 <kbateman> @pf
09:22:34 <lambdabot> Maybe you meant: bf pl
09:22:45 <fax> > 3^7 `mod` 7
09:22:46 <lambdabot>   3
09:22:55 <fax> > 9^11 `mod` 11
09:22:56 <lambdabot>   9
09:22:59 <fax> what :D
09:23:08 <mauke> 9/11!~
09:23:26 <fax> > 67^111 `mod` 111
09:23:27 <lambdabot>   64
09:23:34 <silver> fhew
09:23:48 <silver> fax, looks like luck
09:23:52 <silver> hehe
09:24:05 <silver> or may be...
09:24:19 <michie1> wasn't there something about fermat's small theorem about this?  Or something like it?
09:24:20 <Cale> FliPPeh: no dot
09:24:28 <FliPPeh> okay
09:24:28 <silver> > 15^13 `mod` 13
09:24:29 <lambdabot>   2
09:24:37 <FliPPeh> $ ls ~/texmf/tex/latex/
09:24:37 <FliPPeh> lazylist.sty  polytable.pdf  polytable.sty
09:24:37 <Cale> FliPPeh: But I think the location is configurable
09:24:37 <fax> > 15`mod`13
09:24:38 <lambdabot>   2
09:24:43 <FliPPeh> Like this?
09:24:50 <fax> > 48^97 `mod` 97
09:24:51 <lambdabot>   48
09:24:53 <Cale> mktexlsr
09:24:56 <Cale> er
09:24:58 <silver> fax, hax
09:25:03 <Cale> no /latex/ I think
09:25:11 <Cale> Though...
09:25:15 <Cale> hmm
09:25:16 <Gilly> michie1: a^p = a (mod p) when p is a prime, yes.
09:25:20 <Cale> maybe that's fine regardless
09:25:30 <Cale> yeah
09:25:32 * twink ponders the mean number of times the "current minimum" variable is updated in an (imperative) implementation of minimum-finding like for (i = 0; i < n; ++i) if (a[i] < cur) cur = a[i];
09:25:36 <michie1> Gilly: hmm, 111 *looks* prime
09:25:37 <Cale> actually, that's where the documentation recommends
09:25:43 <fax> > factor 111
09:25:43 <lambdabot>   Not in scope: `factor'
09:25:43 <Gilly> michie1: divisible by 3
09:25:47 <Gilly> michie1: 1+1+1=3
09:25:57 <Cale> I think that as long as they're somewhere in that tree, it's fine.
09:26:13 <Cale> and then you mktexlsr to update TeX's database of packages
09:26:22 <FliPPeh> It worked
09:26:23 <twink> michie1: Sum of digits' divisibility by 3 means keep summing digits until it's one digit, then see if the one digit is 3 or 9.
09:26:26 <Cale> cool :)
09:26:28 <FliPPeh> Thanks Cale :)
09:26:38 <fax> I love that sum of digits
09:26:39 <FliPPeh> How did you find that out in the first place?
09:27:11 <twink> Just do power series mod 3 and substitute x = 10
09:27:55 <Cale> FliPPeh: By reading the documentation pdf
09:28:07 <Cale> FliPPeh: It tells you how to do that in more detail.
09:28:10 <twink> For 11 difference the sum of the even and odd digits, and keep doing that until they're one digit. If the digit is 0, it's divisible, otherwise, no.
09:28:15 <Gilly> well, 10 = 1 mod 3, thus a_n 10^n + ... + a_1 10 + a_0 = a_n + ... + a_1 + a_0 (mod 3)
09:29:07 <twink> Gilly: Also works for 9 (though it's not prime), just the single-digit result at the end has to be 9.
09:29:11 <silver> > 27 ^ 13 `mod` 13
09:29:12 <lambdabot>   1
09:29:39 <fax> > 27`mod`13
09:29:40 <lambdabot>   1
09:29:54 <Gilly> twink: sure
09:30:13 <fax> im trying to learn chevally warning theorem
09:30:15 <fax> but it is very hard
09:33:30 <fax> > let prime p = all (\n -> n == n^p `mod` p) [1..p-1] in filter prime [2..20]
09:33:30 <lambdabot>   [2,3,5,7,11,13,17,19]
09:33:55 <roconnor> :^)
09:34:02 <twink> 7 and 13 have patterns to form linear combinations of digits with
09:34:24 <fax> twink, what does that mean
09:34:32 <fax> I know linear combination like 7x + 13y, but what?
09:34:45 <twink> [(p, [(k, let m = (10^k) `mod` p in if 2*m > p then m - p else m) | k <- [0..p-2]]) | p <- [7,13]]
09:34:48 <olsner_> hmm... apparently you need to encode LLVM types in the haskell type system to use the llvm bindings, but I have an AST i want to compile at runtime... it would seem I have to map a list of AST types to a function with the corresponding number of arguments
09:35:10 <fax> huh o_o
09:35:28 <twink> fax: those are the coefficients to weight the digits with when you sum them
09:35:29 <fax> olsner, I say that GADTs probably let you do it
09:35:44 <fax> twink sorry I am lost :(
09:35:55 <Gilly> he's talking about a divisibility check
09:37:23 <fax> ooh
09:37:24 <Gilly> see, 7^0 = 1 (mod 10), 7^1 = 7 (mod 10), 7^2 = 9 (mod 10), 7^3 = 3 (mod 10), 7^4 = 1 (mod 10) so if you have a number you can multiply the digits by those numbers and sum up and continue to find if the number is divisible with 7
09:37:28 <fax> by 7?
09:37:32 <SamB_XP> olsner: huh
09:37:33 <twink> fax: 7's coefs are 1,3,2,-1,-3,-2, so 123456 has (-2)*1+(-3)*2+(-1)*3+2*4+3*5+1*6 = (8+15+6)-(2+6+3)=29-11=18
09:37:46 <SamB_XP> you'd think there'd be a more "raw" layer than that ...
09:38:01 <fax> oh wow that is wonderful
09:38:09 <twink> Gilly: You want powers of 10 mod 7, actually.
09:38:18 <Gilly> oh well....
09:38:29 <Gilly> i work in base 7 and divide with 10
09:39:02 <fax> whatabout making numbers base (large prime)
09:39:14 <fax> and them doing a prime check with lots of different digit tests
09:39:16 <jrm8005> is there something in base that lets me turn a list like this: [["a", "b", "c"],["1","2","3"]] into a list like this ["a 1", "a 2", "a 3", "b 1" ... ?
09:39:17 <fax> would that be fast?
09:39:41 <fax> jrm8005, intercalate " " . transpose
09:40:10 <Cale> not transpose
09:40:14 <Cale> sequence
09:40:25 <Cale> > sequence [["a", "b", "c"],["1","2","3"]]
09:40:26 <lambdabot>   [["a","1"],["a","2"],["a","3"],["b","1"],["b","2"],["b","3"],["c","1"],["c"...
09:40:37 <twink> fax: These digit tests are for doing things mentally and/or by hand. They're not very useful on computers.
09:40:38 <Cale> > map unwords . sequence $ [["a", "b", "c"],["1","2","3"]]
09:40:39 <lambdabot>   ["a 1","a 2","a 3","b 1","b 2","b 3","c 1","c 2","c 3"]
09:40:42 <Gilly> fax: hardly :P divisibility isn't about basis in its core
09:40:54 <jrm8005> man, I have a long way to go. Thanks, all
09:41:14 <fax> jrm me too :P
09:41:23 <Cale> jrm8005: sequence is a general function which applies in any monad
09:41:27 <fax> mostly in reading comprehension
09:41:38 <Cale> jrm8005: In the list monad, it does Cartesian product
09:41:52 <jrm8005> Cale: that's a good explanation
09:43:16 <Cale> jrm8005: In general, it takes a list of monadic computations, and produces a computation that when you run it, produces a list of the results. In the list monad, "running" a computation means picking an element from it, in all possible ways.
09:43:51 <Cale> Er, I should say, "when you run it, it runs each of the computations in the list, collecting a list of the results"
09:44:01 <jrm8005> ok, I was looking for something that general, actually :)
09:44:39 <jrm8005> but I'm still quite new to Haskell
09:47:38 <fax> regarding earlier... http://planetmath.org/encyclopedia/ThuesLemma2.html
09:48:15 <byorgey> to build gtk2hs with ghc-6.12, will I have to use the darcs version of gtk2hs? does anyone know?
09:49:06 <FliPPeh> Hah
09:49:06 <FliPPeh> Ahaha
09:49:24 <FliPPeh> I just created my first good looking Literate Haskell PDF document without sudo
09:49:36 <byorgey> congratulations =)
09:49:46 <fax> without sudo ?
09:49:50 <FliPPeh> Now check GHC behaviour
09:50:01 <FliPPeh> Yes fax, some files were unreadable without root before
09:50:37 <dcoutts_> byorgey: the darcs version might work
09:51:17 <FliPPeh> It's telling me about a missing \end{code}
09:51:19 <FliPPeh> But it's there
09:53:53 <FliPPeh> Literate.lhs line 25: unlit: missing \end{code}
09:54:09 <FliPPeh> But all \begin are closed with \end
09:54:14 <FliPPeh> What could be it?
09:54:58 <FliPPeh> @hpaste
09:54:58 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
09:55:21 <fax> let z (x,y,z) = if x < y - z then (x+2*z,z,y-x-z) else if x > 2*y then (x-2*y,x-y+z,y) else (2*y-x,y,x-y+z) in (z . z) (6,5,7)
09:55:27 <FliPPeh> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=8753#a8753
09:55:28 <fax> > let z (x,y,z) = if x < y - z then (x+2*z,z,y-x-z) else if x > 2*y then (x-2*y,x-y+z,y) else (2*y-x,y,x-y+z) in (z . z) (6,5,7)
09:55:29 <lambdabot>   (6,5,7)
09:55:36 <FliPPeh> That has to work
09:55:39 <fax> that's what an ivolution is :D
09:55:42 <FliPPeh> Even Latex accepts it
09:55:51 <fax> I thought it would be something more complicated
09:57:38 <fax> Cale - is this analytic number theory?
09:57:54 <Cale> fax: No, it's just normal number theory.
09:58:51 <Cale> Analytic number theory implies the use of results from analysis (results about convergence and so on) to achieve number-theoretic results
09:59:47 <psykotic> there are some exceptions that are usually considered an entry to analytic number theory
09:59:57 <psykotic> for example, the explicit bound version of euclid's proof of the infinitude of primes
10:00:12 <fax> okay
10:00:17 <psykotic> (which can be refined with analytical big oh estimates on things like O(n!))
10:05:47 <chrisdone> @let applyntimes f start n = iterate f start !! n
10:05:48 <lambdabot>  Defined.
10:05:49 <chrisdone> :t applyntimes
10:05:50 <lambdabot> forall a. (a -> a) -> a -> Int -> a
10:05:52 <chrisdone> is there a standard one for this?
10:06:00 <chrisdone> swear I remember one already defined somewhere
10:06:50 <Cale> chrisdone: Unfortunately, iterate is the closest thing
10:06:58 <chrisdone> ah, fair enough
10:07:27 <sundaymorning> hello, what are combinators? An article I'm reading says 'The standard approach to the construction of EDSLs involves implementing them as libraries of combinators in a language with support for higher order functions.
10:07:38 <sundaymorning> Combinators are high order functions?
10:15:21 <bremner_> I've never found a nice definition, but yes, they are higher order functions, but not all higher order functions are combinators
10:15:22 <FliPPeh> How do I get nicely formated code out of LaTeX?
10:15:33 <FliPPeh> Like, space all the "=" to the same column
10:15:48 <bremner_> FliPPeh: lhs2tex?
10:15:51 <FliPPeh> Yup
10:16:08 <nanashi> =)
10:16:15 <bremner_> oh, I thought it did that kind of stuff.
10:16:37 <nanashi> do you mean to write the LaTeX in hs ? =)
10:16:45 <bremner_> FliPPeh: there are many styles for lhs2TeX, maybe you want a different one.
10:17:08 <FliPPeh> nanashi: Nope, Literate Haskell
10:17:19 <nanashi> and/or
10:17:37 <FliPPeh> bremner_: Where can I see available styles and how to use them?
10:18:05 <bremner_> FliPPeh: did you look in the manual?
10:18:36 <FliPPeh> bremner_: I'll dig myself in there, thanks :)
10:18:58 <FliPPeh> s/myself//
10:23:50 <byorgey> FliPPeh: for things to be aligned there must be at least *two* spaces before all the things you want aligned
10:24:02 <byorgey> since if it aligned everything that happened to line up it would look rather weird
10:24:31 <byorgey> so e.g. if you want all the = aligned, just make sure all the = are actually in the same column, with at least two spaces before each
10:25:23 <byorgey> sundaymorning: 'combinator' is sort of a vague term, really, but it basically means "things whose purpose is to make more complicated things by combining simpler things"
10:25:33 <byorgey> which often involves higher-order functions, but it doesn't have to
10:26:37 <FliPPeh> byorgey: Thanks, LaTeX is strange at times
10:26:49 <EvanR> according to this doc, sdl audio api is not exposed by the bindings http://hackage.haskell.org/packages/archive/SDL/0.5.9/doc/html/Graphics-UI-SDL-Audio.html
10:27:00 <EvanR> wondering why
10:28:02 <dankna> because the person who made the bindings didn't need it, most likely
10:28:13 <Draconx|Laptop> EvanR, perhaps because it uses threads.
10:28:32 <Draconx|Laptop> EvanR, which (maybe) makes it hard to write bindings for.
10:29:04 <EvanR> it does use threads
10:29:29 <EvanR> and the principle exposed function is a function that initializes a audio thread and takes as argument a callback which fills an audio output buffer periodically
10:29:45 <Draconx|Laptop> yes, I'm aware of how SDL works.
10:29:48 <EvanR> sounds tricky to do in haskell
10:30:43 <EvanR> :(
10:31:31 <FliPPeh> Mhhh
10:31:34 <sundaymorning> byorgey: I see. It's the sort of thing that you get the feeling once you see a few combinators and a few functions that are not combinators
10:31:51 <FliPPeh> The "_" char is shown with a red background as if it was wrong within the LHS file
10:32:00 <FliPPeh> But the latex compiles fine
10:32:06 <byorgey> sundaymorning: yes. it's more a style of library/API development than it is a property of individual functions.
10:33:06 <byorgey> a combinator library will provide you with some primitives and some combinators, and a way to run/do something with the things you build up using the combinators.
10:33:31 <bremner_> I would say folds are examples of hofs that are not combinators.
10:33:49 <byorgey> I agree.
10:34:17 <BONUS> why wouldn't you call, say, foldr, a combinator?
10:34:27 <sundaymorning> I see, like the IO monad would be a combinator because you take >>= and return and combine them in order to perform IO
10:34:42 <bremner_> BONUS: ignorance?
10:35:12 <byorgey> sundaymorning: well, I would say that >>= and return are combinators
10:35:31 <byorgey> they are monad combinators.
10:35:53 <FliPPeh> Gah
10:36:05 <FliPPeh> The LaTeX font for my code blocks is weird..
10:36:28 <byorgey> what font is it?
10:36:36 <FliPPeh> I didn't specify any
10:36:37 <byorgey> that's what the different styles are for
10:36:40 <FliPPeh> It's the default font
10:37:09 <FliPPeh> It tells me what the styles are, not how to apply them
10:37:16 <FliPPeh> Meh, seems to be latexy
10:37:35 <jmcarthur> i think of folds as combinators
10:37:48 <bremner_> ok, so what hof isn't?
10:38:11 <jmcarthur> i think it's blurry
10:38:29 <Draconx|Laptop> a combinator is simply a function with no free variables.
10:38:39 <BONUS> yeah
10:38:48 <BONUS> using only function application in between its variables
10:39:00 <Draconx|Laptop> thus (>>=), return and foldr are all all examples of combinators.
10:39:11 <jmcarthur> there we go. that's sounds good to me
10:39:14 <BONUS> however, many times implementations for >>= do have free variables?
10:39:14 <jmcarthur> *that
10:39:24 <BONUS> @src Maybe (>>=)
10:39:25 <lambdabot> (Just x) >>= k      = k x
10:39:25 <lambdabot> Nothing  >>= _      = Nothing
10:39:44 <Draconx|Laptop> BONUS, all variables there are bound.
10:39:46 <BONUS> wait hmm no there aren't any here. but i've seen them!
10:40:20 <fax> @src ST (>>=)
10:40:21 <lambdabot> Source not found. Just try something else.
10:40:22 <BONUS> i think in ErrorT
10:40:26 <fax> @src State (>>=)
10:40:26 <lambdabot> Source not found.
10:40:38 <BONUS> @src ErrorT (>>=)
10:40:39 <lambdabot> m >>= k  = ErrorT $ do
10:40:39 <lambdabot>     a <- runErrorT m
10:40:39 <lambdabot>     case a of Left  l -> return (Left l)
10:40:39 <lambdabot>               Right r -> runErrorT (k r)
10:41:21 <FliPPeh> The manual lies
10:41:25 <FliPPeh> :(
10:41:45 <FliPPeh> \begin{verb} should monospace it's content as it is
10:41:46 <BONUS> looks like there are a couple of free variables here
10:41:48 <FliPPeh> But it removes the newlines...
10:44:25 <jmcarthur> what makes a variable unbound in a haskell function?
10:44:28 <Draconx|Laptop> BONUS, hm, I think it's a bit of a stretch to consider toplevel functions as free variables, since we can write them directly in the definition without changing its meaning.
10:45:19 <BONUS> you have a point there, yeah
10:45:37 <byorgey> but then how on earth WOULD you get an 'unbound' variable in a function?
10:45:46 <byorgey> this definition seems very suspect to me
10:46:27 <BONUS> hmm
10:46:30 <byorgey> note also that the way functional programmers often use the term is a bit different than the original technical meaning from combinatory logic.
10:46:41 <jmcarthur> maybe it could be considered "unbound" if it can't be inlined without using unexported functions? it's not really fitting with the definition of free variables anymore though
10:46:41 <byorgey> although the two are definitely related.
10:46:46 <BONUS> it's very fuzzy yeah
10:47:16 <BONUS> i always considered if you have like f x = (\y -> foo x y) that the x is free in the lambda
10:47:28 <BONUS> but then once you consider currying this view kind of falls apart
10:47:53 <BONUS> wait actually, does it?
10:47:57 <idnar> I don't see how
10:48:15 <idnar> f x y = foo x y is an equivalent definition
10:48:21 <byorgey> no, it's not necessarily the case that combinators always return combinators as their results
10:48:23 <iammisc> I have a tree data structure and I want to replace a random node in that tree with a random node in the other tree. I'm trying to think of the proper functional way to do this. What do you think?
10:48:29 <Draconx|Laptop> I think the thing is that toplevel declarations aren't really "variable".
10:48:36 <byorgey> so by this definition f would be a combinator but (\y -> foo x y) is not, which could make sense.
10:48:42 <byorgey> however, I still don't really like the definition =)
10:48:58 <BONUS> idnar: i'd say that if you write that as \x -> \y -> foo x y, that x is free in the inner function, but not in the outer
10:49:14 <jmcarthur> "a combinator is a nonprimitive" :)
10:49:47 <BONUS> for some time now i have been bothered by not actually having a precise and formal definition for a combinator in the context of haskell or FP in general
10:53:27 <bremner_> AOL!
10:53:33 <fax> yeah the formal definition doesn't really have anything much to do with how the word is ude
10:53:36 <fax> used*
10:53:45 <byorgey> iammisc: well, you probably first want to write a function to pick out a node at a location in a tree, and a function to replace a node at a particular location in a tree
10:53:54 <byorgey> iammisc: using some path-like data structure to encode locations
10:54:14 <byorgey> iammisc: the tricky part will be figuring out how to randomly generate tree locations with the right distribution.
10:54:42 <byorgey> iammisc: what sort of shapes do these trees have?  could they be any shape at all?
10:54:44 <jmcarthur> i would say that if its implementation is hidden (you can't just manually inline it due to it being a primitive or using something that is not exported) it's almost definitely not a combinator in the sense of how we talk about combinators in haskell. can that be refined any further?
10:55:20 <byorgey> jmcarthur: I don't think I agree.
10:55:22 <iammisc> byorgey: well, I'm doing some genetic programming related to music, so most nodes have one child, but some have two and some have more
10:55:33 <jmcarthur> byorgey: counter example?
10:55:34 <Draconx|Laptop> jmcarthur, That would mean seq is not a combinator.
10:55:34 <byorgey> jmcarthur: I think it would be perfectly reasonable to have a combinator whose implementation is hidden.
10:55:42 <Draconx|Laptop> jmcarthur, which is... weird.
10:56:08 <jmcarthur> Draconx|Laptop: i don't really think of seq as a combinator, myself
10:56:13 <byorgey> jmcarthur: suppose I have a library that exports a type Foo, some Foo primtives, and a function  snarfle :: Foo -> Foo -> Foo
10:56:28 <twink> Okay, a_{n+1} = (1-1/(n+1))a_n + (1/(n+1))(a_n+1) where if the (n+1)st element is the new min, you update once more, otherwise, you have (1-1/(n+1)) odds of however many times the variable was updated.
10:56:36 <byorgey> snarfle would be a combinator, but its implementation is probably hidden because the implementation of Foo is hidden.
10:56:49 <twink> So then a_n = H_n and so on.
10:57:05 <jmcarthur> byorgey: you mean in the case that snarfle is not defined in terms of the other exposed primitives?
10:57:15 <byorgey> jmcarthur: right
10:57:27 <byorgey> jmcarthur: it is a 'primtive combinator' if you will
10:57:28 <jmcarthur> byorgey: but it could be, or couldn't be?
10:57:39 <byorgey> let's say couldn't be.
10:57:47 <jmcarthur> byorgey: i'd just call that a primitive then
10:57:50 <jmcarthur> if i can't reproduce it
10:57:58 <jmcarthur> but that's requiring my own definition, again
10:58:05 <byorgey> well, I guess we use the word combinator differently, then =)
10:58:12 <jmcarthur> i guess so
10:59:00 <monochrom> S and K are combinators with no "implementation in terms of other things" as far as combinatory logic is concerned.
10:59:24 <twink> I'm not sure under what hypotheses you have a 1/n chance of a minimum occuring at each position in the array.
10:59:45 <monochrom> In that same logic, I is a combinator defined in terms of S, K, and application.
11:00:00 <EvanR> combinator is a fancy name for pure function?
11:00:08 <Draconx|Laptop> EvanR, no.
11:00:11 <jmcarthur> EvanR: i wouldn't say that
11:00:13 <twink> I think I was supposed to be given IID uniform on some bounded range of integers.
11:00:16 <monochrom> combinator means it does not refer to free variables.
11:00:23 <byorgey> twink: that will be true if the array is the result of applying a permutation chosen uniformly at random to a sorted array
11:00:53 <EvanR> ok
11:01:16 <byorgey> twink: if the elements are independent, the probability of each one being the minimum must be the same, hence they are all 1/n
11:01:21 <twink> byorgey: So the a_n = H_n looks plausible/correct to you?
11:01:42 <byorgey> unless you mean the probability of each element being a global minimum with no other element equal to it. because in that case there sometimes might not be a minimum.
11:02:00 <jmcarthur> "The primitive functions [S and K] themselves are combinators, or functions that, when seen as lambda terms, contain no free variables."
11:02:23 <twink> byorgey: It's the expected number of updates to a "current minimum" variable as one scans through the array.
11:02:49 <jmcarthur> monochrom: i can inline S and K *in haskell* though
11:03:06 <monochrom> haskell is not a combinatory logic
11:03:14 <jmcarthur> monochrom: agreed
11:03:24 <jmcarthur> but we are trying to formalize what a "combinator" in haskell is
11:03:32 <fax> forget formalizing combinator
11:03:39 <jmcarthur> and i don't think we use it quite the same way that we do outside of haskell
11:03:41 <byorgey> twink: I think so.
11:03:53 <monochrom> I don't see why one must drag in "has user-writable implementation" or "inlinable".
11:04:19 <jmcarthur> monochrom: because we don't really have free variables at all otherwise, as far as i can tell
11:04:31 <twink> byorgey: I think things are fuzzy in/around the case where multiple elements are the minimum.
11:04:51 <jmcarthur> and so everything is a combinator, which i'm not so sure about
11:05:09 <EvanR> what about function defined inside other functions they might have free variables
11:05:31 <jmcarthur> EvanR: yes, those are clearly not combinators i think
11:05:35 <fax> the term does not mean anything specific here
11:05:54 <EvanR> all top level functions are combinators
11:05:56 <EvanR> ?
11:06:12 <jmcarthur> EvanR: that's what it looks like unless we modify the definition to fit common usage in haskell
11:06:20 <jmcarthur> to me, anyway
11:06:22 <b52> i got a list with two-value-tuples and i want to get the tuple(s) with the least second value
11:06:23 <yakov> hey
11:06:28 <fax> look athe word: combine-ator it just sticks stuff together
11:06:29 <EvanR> jmcarthur: how would we change it and why?
11:06:39 <fax> that's why we calle  sepBy1   a combinator
11:06:55 <jmcarthur> EvanR: because we don't always call every top level function a combinator
11:06:55 <fax> it's totally vauge
11:07:08 <EvanR> i would if i was given a definition, like i just was ;)
11:07:14 <fax> there is no definition
11:07:22 <jmcarthur> fax: yeah, it's completely vague, and yet we often make a distinction without having an expanation as to why we do so
11:07:30 <EvanR> i read a book recently which talked about supercombinators
11:07:40 <fax> that's a different kind of combinator
11:07:45 <fax> one that has formal meaning
11:07:48 <aavogt> > minimumBy (comparing snd) [(1,5),(1,0)]
11:07:50 <lambdabot>   (1,0)
11:08:01 <b52> aavogt: thanks
11:08:28 * jmcarthur gives up for now. it's just terminology after all
11:08:30 <twink> If your range is [0,N-1] and your current minimum is m, then the odds of something being less are m/N, so I think things are actually more complicated.
11:08:47 <yakov> hm, http://socghop.appspot.com/gsoc/program/accepted_orgs/google/gsoc2010  I dont see haskell :-/
11:09:20 <b52> aavogt: but minimumBy returns only one tuple  although there might be more tpleswith a minimum valueß
11:09:27 <yakov> are we outboard?!
11:09:33 <aavogt> b52: then use sortBy
11:09:34 <twink> Say that p(m,k) is the odds of the minimum being m in a k-element array.
11:09:54 <dimmy> yakov: look for haskell.org
11:10:14 <aavogt> @src minimumBy
11:10:14 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
11:10:16 <enolan> yakov: It's in the second list. type haskell in the search box
11:10:18 <aavogt> @src minimum
11:10:19 <lambdabot> minimum [] = undefined
11:10:19 <lambdabot> minimum xs = foldl1 min xs
11:13:10 <zygoloid> > head . groupBy ((==) `on` snd) . sortBy (comparing snd) $ [(1,5), (2,0), (3,2), (4,0), (5,1)]
11:13:12 <lambdabot>   [(2,0),(4,0)]
11:13:36 <yakov> enolan, dimmy anyway do you know if it already possible to login to gsoc wiki already?
11:14:31 <enolan> It's still broken for me.
11:14:39 <dimmy> yakov: no idea
11:15:47 <twink> byorgey: I'm pretty sure it's wrong because of bounded range and collision concerns.
11:17:12 <asdf1> I'm reading RWH and have some confused on chap18 example. Can anybody pls explain why we need runMaybeT (f y) instead of just (f y) http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24176#a24176
11:18:48 <micah> when using parsec on non-string streams, what parsers can you use, since you can't use char, string, etc.?
11:18:55 <micah> I'm uisng it on a [Token]
11:19:06 * hackagebot pointless-haskell 0.0.4 - Pointless Haskell library  http://hackage.haskell.org/package/pointless-haskell-0.0.4 (HugoPacheco)
11:22:07 * hackagebot pointless-lenses 0.0.5 - Pointless Lenses library  http://hackage.haskell.org/package/pointless-lenses-0.0.5 (HugoPacheco)
11:22:10 <twink> byorgey: Yeah, if [0,N-1] is the range then you get 1+(1-1/N)/2 instead of 3/2
11:22:25 <micah> I've been trying to get an answer to my question for days :(
11:22:28 <twink> byorgey: That is, for a 2-element array.
11:23:48 <twink> byorgey: 1/N chance of each m being the current min after the first elem, then an m/N chance of the second element being smaller in each case, so 1 + \sum_{m=0}^{N-1} m/N^2 = 1 + N(N-1)/(2N^2) = 1 + (1-1/N)/2
11:26:37 <fax> > isPrime 1234567890123456789012353
11:26:38 <lambdabot>   Not in scope: `isPrime'
11:26:47 <fax> @let isPrime p = true
11:26:48 <lambdabot>  Defined.
11:28:00 <twink> Well, technically isPrime p = not $ any (\d -> p `mod` d == 0) [2 .. p - 1] no?
11:28:25 <fax> that is more accurate
11:29:42 <monochrom> > map isPrime [1,3,5,7,9]
11:29:43 <lambdabot>   [True,True,True,True,True]
11:29:51 <monochrom> "experimental error" :)
11:30:05 <twink> "No proper divisors" where a proper divisor of a positive natural number n is a number d with 1 < d < n where there exists some natural number q so that d*q = n.
11:30:37 <byorgey> micah: what version of parsec?
11:31:46 <monochrom> micah: Reading the source code of Text.Parsec.Char gives you ideas.
11:31:53 <micah> where can I find it
11:32:03 <monochrom> in the source code of parsec
11:32:08 <Cale> > true
11:32:09 <lambdabot>   True
11:32:12 <Cale> whaaaay
11:32:14 <Cale> t*
11:32:23 <Cale> I guess someone must have defined it
11:32:27 <Cale> but why?
11:32:29 <monochrom>  Text.Parsec.Char or Text.ParserCombinators.Parsec.Char
11:33:03 <micah> > let true = False
11:33:04 <lambdabot>   not an expression: `let true = False'
11:33:06 <micah> dang
11:33:07 <micah> :P
11:33:11 <monochrom> someone has not heard of "otherwise"
11:33:23 <micah> is "otherwise" defined as True?
11:33:31 <monochrom> absolutely
11:33:32 <micah> > otherwise
11:33:33 <lambdabot>   True
11:33:36 <micah> oh that's cool
11:33:37 <micah> :D
11:33:56 <micah> does otherwise work in case..ofs?
11:33:56 <monochrom> someone also has fetish about how things should be named.
11:34:30 <monochrom> apparently the fetish can't stand capitalized names.
11:34:34 <byorgey> micah: it does, but not for the reason you'd think.
11:34:52 <mauke> > case "jings" of otherwise -> otherwise
11:34:53 <lambdabot>   "jings"
11:35:03 <micah> byorgey: what if the variable == True?
11:35:04 <byorgey> micah: since it is a variable name, when used as a pattern it will match whatever you are case-ing on, shadowing the previous definition of otherwise
11:35:14 <micah> byorgey: oh
11:35:18 <micah> byorgey: interesting
11:35:22 <byorgey> no, case expressions don't work that way
11:35:42 <byorgey> > let f = 3 in case 2 of f -> f
11:35:44 <lambdabot>   2
11:35:57 <mauke> > case 2 of g -> f
11:35:58 <lambdabot>   Ambiguous type variable `a' in the constraints:
11:35:59 <lambdabot>    `GHC.Show.Show a'
11:35:59 <lambdabot>      a...
11:36:17 <micah> ah I understand now
11:36:22 <micah> lowercase vars in patterns
11:36:24 <micah> are bound
11:36:33 <micah> capital things are not
11:37:18 <bremner_> are not variables
11:37:24 <micah> of course
11:38:29 <byorgey> right.
11:38:33 <bremner_> so bound is a funny word to use for them
11:39:49 <micah> where does cabal fetch put things
11:40:45 <byorgey> micah: usually in .cabal/packages
11:40:53 <micah> k
11:41:19 <byorgey> so, who's up for another Philadelphia hackathon the weekend of May 15 or May 22?
11:41:32 <asdf1> I'm reading RWH and confused on chap18 example. Can anybody pls explain why we need runMaybeT (f y) instead of just (f y) http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24176#a24176
11:43:34 <byorgey> asdf1: note the whole do-block is inside a MaybeT wrapper
11:43:50 <byorgey> asdf1: so the do block needs to have type m (Maybe a)
11:44:48 <twink> byorgey: Bounded ranges of integers spoil the simple probabilistic analysis giving harmonic numbers.
11:45:35 <byorgey> twink: yes, depending on your algorithm, that seems right
11:46:14 <byorgey> if you update the minSoFar every time you see something <= the current min then I think the analysis still applies
11:46:20 <byorgey> but that would be silly
11:47:02 <twink> byorgey: I don't have a good recurrence for the bounded range case yet. I think when <= minSoFar you get 1+N(N+1)/(2N^2)
11:47:47 <twink> (instead of 1+N(N-1)/(2N^2) that is)
11:48:11 <micah> oh so char is built on satisfy!
11:55:29 <amgarchIn9> Hi, how could one invert the mapping (i, j) -> k = i * (i - 1) / 2 + j that one uses to "compress" symmetric square matrices?
11:58:59 <fax> amarchIn9, this is not bijective
12:02:07 <Cale> amgarchIn9: So you want to find the largest triangular number which is less than your number, and the index of that number will tell you i
12:02:13 <Cale> and then j is whatever's left over
12:02:17 <twink> amgarchIn9: Use bisection to find an i where (i*(i-1))`div`2 <= k < (i*(i+1))`div`2, then that's your i.
12:02:50 <amgarchIn9> fax: tuples (i, j) is a "countable" set, this particular enumeration should be invertible
12:03:03 <fax> amagarch, only if i < k or something
12:03:09 <fax> it's not bijection between N^2 --> N
12:03:11 <twink> amgarchIn9: To get an initial bounding interval keep doubling i.
12:04:14 <amgarchIn9> ok, let me try ...
12:04:45 <fax> it's maybe a bijection between  { (x,y) in NxN | x < y } --> N   or similar
12:04:48 <fax> mm
12:04:49 <fax> y < x
12:05:07 <fax> but you can "change of variables" to make it between N^2 --> N
12:05:11 <amgarchIn9> I see, what you mean, fox
12:05:17 <amgarchIn9> *fax
12:06:12 <Darkone> Yea, I have to say so far I like the Real World Haskell book better than the learn you a haskell tutorial.
12:06:41 <Darkone> Has a more traditional... path? of teaching.
12:06:48 <fax> by the way,
12:07:07 <fax> the finite integral of y is T(x) = i(i-1)/2
12:07:13 <fax> you can prove it injective with this
12:07:26 <fax> (since y is strictly positive)
12:08:03 <Darkone> Got a non-haskell question: where's a good place to pick up math that algebra 2/ college algebra doesn;t give you, but is useful stuff in programming?
12:09:05 <ulfdoz> Darkone: That really depends on what you program. For the most programs you don't need algebra at all, its just an understanding how to express you within your programming language.
12:09:30 <Darkone> I'm guessing it would be a good idea to refresh on matrices, and then look through calculus. I would have taken precalc or calc this year, but wasn't a time avail, and I'll be graduating at the end of this sem.
12:10:09 <Darkone> ulfdoz, yea, but I've encountered occasional spots where I was sure there's a way to reduce a function, but my level of math hadn't tought me how :(
12:10:30 <twink> Simplex numbers. For N^3->N I think it's (i,j,k) |-> C(i+2,3)+C(j+1,2)+C(k,1)
12:10:45 <Darkone> Like a projectile velocity function.
12:10:46 <fax> Darkone, everything you learn in mathematics will find applications in computing.. there is no end to what you need to learn
12:11:12 <jlouis> Even my topology course became useful
12:11:16 <Darkone> It wasn't perfect, but gave me good results, and was fairly realistic.
12:11:18 <ulfdoz> Darkone: For the most things, there are some laws, e.g. bookkeeping law and stuff like that which helps you to transform functions.
12:11:32 <fax> jlouis how? :D
12:11:39 <twink> For N^D I think it's \sum_{d=1}^D C(i_d+d-1,d) or something.
12:11:42 <Cale> Darkone: If you want to teach yourself calculus and you have a fair degree of willpower, I highly recommend Michael Spivak's book "Calculus" (note: he also wrote a good book called Calculus on Manifolds, but that's quite a different book)
12:11:48 <jlouis> fax: information theory, complete partial orders, denotational semantics
12:11:54 <fax> ahh
12:12:08 <Cale> Darkone: If you want to learn linear algebra... hmmm...
12:12:15 <Darkone> That is, it reduced speed based on the current speed that you ticked it at. Like... uhhh.
12:12:22 <Cale> Well, one of my favourite books is Hoffman & Kunze
12:12:23 <Darkone> God, it's been so long since I figured it.
12:12:25 <fax> there is two books:  linear algebra done right,  linear alebra done wrong
12:12:26 <fax> :D
12:12:28 <Cale> heh
12:12:47 <Cale> I think "Linear algebra done right" isn't actually the right way to do it.
12:12:55 <Darkone> My idea was, it's SO DAMN HARD to find ballistics information/calculations, outside of the generic one for air resistance.
12:12:56 <Cale> It avoids the determinant too much.
12:13:02 <merijn> I'm sad I didn't notice earlier, there's a graduate Spring school in the UK next week which covers "Introduction to Category Theory" for CS students and some other stuff but I only heard of it this week
12:13:17 <fax> I have to learn determinant
12:13:20 <fax> :(
12:13:22 <Darkone> That I just took some given values, like velocity at muzzle, at 500 yards, etc
12:14:24 <Darkone> Size of projectile, etc, made a function that fairly well aproximates it as long as the projectiles are a certain size. PRoblem is, the way I got it, it would require storing and updating several variables per tick, rather than just calculating it at a given tick :/
12:14:49 <Darkone> Not a problem normally, but I wanted to model MG rounds, infantry rounds, etc etc.
12:15:00 <fax> Darkone that sounds liek calculus
12:15:04 <Darkone> Yea.
12:15:10 <Cale> Steven Roman's Linear Algebra takes what I consider the most uncompromisingly right approach to absolutely every aspect of linear algebra, but it's unfortunately a difficult book to recommend to beginners. It's better as a *second* course on linear algebra for people who think they know it all.
12:15:25 <Darkone> I'm pretty sure there's a way to reduce it to one equation, rather than a value that is changed repeatedly.
12:15:36 <merijn> What about the people who have taken a course in linear algebra but still don't get it? :)
12:15:37 <Cale> Well, I shouldn't say *every* -- it doesn't really focus on numerical issues
12:15:57 <fax> I think in the classes, one big emphasis on linear algebra is being able to do gaussian elimination quickly by yourself
12:16:03 <Cale> merijn: It might be okay for that.
12:16:07 <fax> the reason because it is a common operation in solving other problems
12:16:14 <fax> and it is not fun :P
12:16:20 <Darkone> I'm fairly good at math, it's just I can't use anything I haven't learned :P
12:16:20 <merijn> I'm not actually sure I care enough about linear algebra, though
12:16:21 <fax> but the theory of linear algebra is wonderful
12:16:42 <dimmy> Darkone: this sounds heavily like numerical methods, i.e., efficient numerical approximations of nontrivial functions and such
12:17:18 <Darkone> Which part, reducing the variable + equation to equation (+ time, distance, etc etc) or the equation itself?
12:17:28 <Cale> Mostly the really bad courses in linear algebra spend a lot of time worrying over Gaussian elimination.
12:17:49 <Cale> Well, proving that Gaussian elimination *works* is good.
12:17:51 <dimmy> the reducing part
12:18:04 <Cale> But spending lots of time doing calculations on random matrices by hand is a waste of time.
12:18:05 <fax> Cale - but it's like being able to factor quadratics or whatever... there are some methods you just need to be able to apply quickly
12:18:09 <Darkone> See, the reason was, outside of memory reasons, is that it makes calculating collisions easier.
12:18:14 <twink> Fraction-free Gaussian elimination would be helpful at various points in time.
12:18:27 <amgarchIn9> twink: that is enumeration of the ordered tuples of any length, right
12:18:30 <Cale> Gaussian elimination is not something for humans to do by hand.
12:18:31 <twink> QR eigenvalue stuff too.
12:18:39 <fax> Cale I wish it was true :(
12:18:41 <twink> amgarchIn9: If I remember it right, yeah.
12:18:49 <Darkone> With a projectile like a tank shell, you can't use regular collision methods: The projectile travels MANY vehicle widths per frame :/
12:18:57 <fax> terry tao said:
12:19:01 <Darkone> You have to look again a frame, take substeps, etc etc >.<
12:19:04 <fax> "It doesn’t matter how much innate mathematical talent and intuition you have; if you are unable to, say, compute a multidimensional integral, manipulate matrix equations, understand abstract definitions, or correctly set up a proof by induction, then it is unlikely that you will be able to work effectively with higher mathematics."
12:19:30 <Cale> fax: None of those things involves Gaussian elimination.
12:19:44 <twink> Manipulating matrix equations
12:19:58 <Cale> You can manipulate matrix equations quite fine without it.
12:20:18 <Cale> It's just plain noncommutative algebra + some special details about matrices.
12:20:50 <twink> Hmm, Fourier-Motzkin elimination is another not-often-enough one. Bonehead Grobner basis stuff for solving polynomial systems, too.
12:21:49 <twink> Not enough SVD or generalized eigenstuff in addition to the normal eigenstuff.
12:21:51 <fax> you can do grobner basis by hand!?
12:22:16 <twink> fax: Yeah, it's even easy when it's a small enough number of variables and polynomials.
12:22:40 <merijn> Is length O(n) complexity?
12:22:47 <Cale> Plain Gaussian elimination is something that you should know how to do, but once you know the algorithm, it's a complete waste of time to do it over and over.
12:22:53 <Cale> merijn: Yep
12:22:58 <merijn> Well that's lame
12:23:20 <Cale> merijn: I dare you to try to make it asymptotically better
12:23:38 <noisetonepause> win2
12:23:39 <Darkone> What would you call math/andor physics dealing with... taking a set of conditions that you want to take into account, like say air resistance as a function of projectile weight speed and cross section, armor penetration, etc, and creating an equation that conforms to known constants, like velocity x at barrel and velocity y at 500 yards in normal atmospheric conditions (STP I think is the term?)?
12:23:57 * noisetonepause shakes first at irssi
12:24:04 <Darkone> Well, air resistance isn't an issue. A simplified form of the real formula is good enough.
12:24:10 <merijn> You can have O(1) if you store the length with the list. But without modifying the list data structure you can't, of course
12:24:28 <Cale> merijn: "storing the length with the list" often just doesn't make sense too.
12:24:37 <Cale> > let xs = 1 : xs in xs
12:24:38 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
12:24:52 <Darkone> As is, trying to make a generalized, and accurate armor penetration algorithm is hell.
12:24:59 <Cale> This list takes up constant space, but is infinitely long.
12:25:27 <Cale> Darkone: Sounds rather violent.
12:25:27 <Darkone> Not perfect, just accurate enough to work for a range of values within 10-20% of the real value.
12:25:28 <merijn> Darkone: Why do you need to compute all that?
12:26:08 <Darkone> merijn, Cale, was wanting to make a game that was like Men of War, Blitzkrieg, etc, that had fairly 'realistic' handling of damage, armor, etc
12:26:26 <merijn> Realism in games is overrated
12:26:28 <Remy__> Hello
12:26:32 <Cale> hello
12:26:34 <Remy__> I'm searching for a pretty printing library to use
12:26:39 <Remy__> I'm currentely using UULib
12:26:45 <Darkone> merijn, to a degree... it's WONDERFUL in a tactical game like MoW though!
12:26:57 <Cale> Remy__: I like Wadler and Leijen's
12:27:05 <merijn> You can easily make tactical games without realism
12:27:14 <Remy__> It's okay but I don't know what many of the functions do since there's no documentation on hackage
12:27:17 <Darkone> It creates a huge amount of strategy and tactics, such as hiding a tank behind a wall or in the destroyed shells of nearby vehicles
12:27:36 <twink> Realism in damage/armor is not fun to play; one hit to just about anywhere drops almost everyone almost every time.
12:27:43 <medfly> merijn, I should point out there's a game called chess
12:27:45 <merijn> Darkone: Go and Chess are considered the pinnacle of strategy games and contain no realism at all
12:27:53 <merijn> medfly: Way ahead of you :p
12:27:56 <medfly> not really
12:27:57 <twink> And otherwise you drop dead without ever seeing what hit you.
12:27:59 <Remy__> pinnacle of board strategy games
12:28:00 <Darkone> I remember the first mission in MoW was near impossible if you didn't do something like that.
12:28:09 <Remy__> on the computer go and chess are super boring, nobody does that
12:28:10 <Darkone> Go maybe. Chess isn't :/
12:28:19 <Remy__> those games aren't dynamic at all compared to an RTS game
12:28:22 <Darkone> Chess is too much patterning.
12:28:28 <Darkone> Yea, static strategy.
12:28:33 <Remy__> chess can even be played by an AI
12:28:33 <nanashi> there is no such thing as a randomly generated seed
12:28:37 <medfly> so?
12:28:41 <medfly> it doesn't mean it's not a tactical game
12:28:44 <merijn> nanashi: You can come pretty close
12:28:49 <Remy__> it's simple in that sense
12:28:57 <merijn> Remy__: Chess and Go are simple?
12:29:08 <Remy__> compared to most computer RTS games
12:29:22 <Darkone> Go is actually pretty neat. Needs alot of memorization, but alot more of it is dynamic.
12:29:40 <Remy__> I have hardly played go so I don't really know actually
12:29:43 <choffstein> Hey all.  I am trying to create an 8x8 table that represents transition probabilities generated from a monte-carlo simulation.  In something like matlab, I would just initialize the table to all zeros, and a 1 for every time I ended up somewhere during the simulation, and at the end divide the whole table by n.  Since matrices in haskell are immutable (I am using hmatrix), can anyone recommend a way for me to do this?
12:29:44 <Remy__> I was talking about chess really
12:29:53 <Cale> Go is much deeper than most computer RTS games I'm familiar with.
12:30:08 <Remy__> still a small statespace
12:30:12 <merijn> Remy__: Go is so much more complex then any computer RTS I've found
12:30:12 <Darkone> Take MoW. A fairly weak vehicle, used right, can hold off masses of enemy vehicles.
12:30:31 <Remy__> okay maybe
12:30:45 <Darkone> As I said before, the first mission in MoW is ridiculously hard if you try to stand and fight, your tank vs the convoy.
12:30:58 <Remy__> go has these mini battles that are pretty much enumerating all the posibilities
12:30:59 <Darkone> You will loose, because an AP shot will wreck you good.
12:31:04 <medfly> Cale, your subjective opinion says go is better than some other things. big deal
12:31:16 <Cale> Yeah, but counting states in an RTS is a it artificial, because they don't really correspond to strategic depth.
12:31:32 <Draconx|Laptop> most computer RTS games are pretty simple: Froozles beat Frobnators, Frobnators beat Gorgibars, Gorgibars beat Froozles.
12:31:34 <twink> If you want to stump AI's you can do shogi or something like tai shogi or taikyoku shogi to blow computer limits away.
12:31:52 <Darkone> Draconx|Laptop, and that's what I don't care for.
12:32:01 <Remy__> Yeah counting won't get you far
12:32:13 <Remy__> I think the best comparison would be to try and create an AI for both
12:32:20 <merijn> Diplomacy is also an example of an awesome strategy game without realism
12:32:24 <Remy__> and somehow compare those two then
12:32:24 <medfly> computers aren't great at reading text from a picture, does that make it hard?
12:32:28 <Darkone> I loved the realism in MoW because... things worked as expected.
12:32:47 <enthymeme> merijn: unlike chess, go, shogi or those others :p
12:32:53 <Darkone> A bit of learning on what armor was where, etc etc.
12:33:01 <Cale> Starcraft has been explored reasonably thoroughly, but looking at the strategies which are available at the highest levels of SC play, it often degenerates into a specific small finite set of overall ideas which dominate anything else.
12:33:01 <merijn> enthymeme: We covered those already, earlier
12:33:06 <enthymeme> ah
12:33:13 <Darkone> But things worked. A tank shell kills any infantryman it hits, 100%
12:33:26 <medfly> it doesn't necessarily do that in real life
12:33:26 <Remy__> I guess that's right cale
12:33:47 <Remy__> Company of Heroes is quite dynamic
12:33:49 <merijn> I do like Diplomacy better then Go or Chess as you're playing your opponents more then the board
12:33:50 <Darkone> medfly, an AP shell to an exposed infantryman is.. fatal...
12:34:01 <twink> http://en.wikipedia.org/wiki/Taikyoku_shogi <-- 36x36 and each player has 402 pieces of 209 different piece types, somehow involving 253 different moves
12:34:04 <Darkone> And I was talking abotu HE, as well :P
12:34:15 <medfly> people survived being at the bottom of the twin towers when they collapsed.
12:34:21 <medfly> there is more to it
12:34:31 <Darkone> Right, because something protected them in some way.
12:34:36 <Darkone> And they weren't crushed.
12:34:39 <medfly> and that can't happen with a tank shell?
12:34:47 <Darkone> There are VERY LIMITED outliers
12:34:53 <luite> choffstein: you could use a Map or IntMap for relatively fast updates, or perhaps use a mutable array
12:35:00 <medfly> pfft. NOT REALISTIC ENOUGH
12:35:03 <Remy__> they were probably just in the eye of the storm
12:35:07 <Remy__> right at that spot
12:35:31 <Darkone> But a square on shot is fatal so many times out of a given number, that you might as well say 100.000...%
12:35:34 <choffstein> luite: alright, thanks.
12:35:35 <luite> choffstein: if you use a lazy list to store your outcomes, the only function that would use the mutable array would be the one reducing the list
12:36:11 <Darkone> Also, you get a feeling of "HAHA I JUST OUTDID YOU :D" when you harpoon an entire squad with a single 45mm AP shell
12:36:16 <twink> Darkone: Real life hits a lot of times aren't immediately fatal but do make people faint.
12:36:30 <Darkone> twink, not talking small arms.
12:36:39 <luite> choffstein: is the monte carlo simulation itself implemented in haskell as well?
12:36:45 <Darkone> Cannons, tank weaponry, etc etc.
12:37:01 <choffstein> luite: I am trying to do it in haskell to learn haskell
12:37:04 <medfly> a human body can provide you with cover
12:37:13 <Darkone> A certain amount of course.
12:37:20 <Darkone> Which is modeled in MoW :P
12:37:28 <choffstein> luite: I could probably write this in C++ or Matlab fairly easily.  But I want to force myself to learn haskell.  So far so good, until I hit this little snag.  I am just trying to figure out the 'haskell' way of doing it
12:37:34 <Darkone> IIRC, infantry can use corpses for cover like sandbags.
12:37:39 <luite> choffstein: ah it will probably take some effort to make it fast :)
12:37:45 <Darkone> Not as good of course, but every little advantage...
12:37:45 <medfly> I believe it also has effects on the shockwave or something :/
12:37:53 <medfly> so shit is going around you
12:38:03 <Darkone> Ah, you mean explosions.
12:38:08 <choffstein> luite: I don't expect it to be very fast -- I just want it to work
12:38:15 <Cale> ahaha, 大局将棋 looks awesome
12:38:23 <Darkone> Yea, a body will absorb alot of shrapnel. See the whole jump on grenade thing.
12:38:47 <medfly> I am aware
12:38:47 <twink> Darkone: Some of those it depends, like things that don't detonate unless they hit something as hard as steel plates on tanks, and so won't tear people up unless they hit bone (at which point the bone fragments are causing shrapnel-like problems internally).
12:38:49 <Cale> absolutely ridiculous number of distinct pieces
12:38:50 <Darkone> Which is the real killer. Shockwaves have to be ludicrously strong to actually kill you. Something like 50-100gs
12:39:10 <luite> choffstein: oh in that case, use Map or IntMap whenever you need to update something often... and you can also use MonadRandom for you random number needs
12:39:24 <aavogt> how do you model explosions as purely an acceleration, Darkone?
12:39:27 <luite> choffstein: if it needs to be fast, you'd probably need to resort to vector and one of the fast rng's
12:39:33 <Darkone> twink, yea, kind of. A 45+mm shell hitting you square on... AP or HE, that's going to tear you in half.
12:39:43 <Darkone> aavogt, ?
12:39:48 <choffstein> luite: alright, thanks a lot!
12:39:48 <luite> choffstein: (you can use MonadRandom with other rng's than the default one)
12:39:51 <Cale> Probably good to bring this discussion back to Haskell somehow ;)
12:40:03 <Darkone> Oh. I'm not sure, was thinking more of the acceleration applied to the person.
12:41:18 <Darkone> Hehe, yea. I think I derailed the channel :V
12:42:43 <choffstein> luite: You don't happen to know if there is a way to update an element in hmatrix's Data.Packed.Matrix do you?
12:43:01 <luite> choffstein: haven't used hmatrix, sorry
12:44:08 <Darkone> Scary thing to watch: Forgot where it was, but there's footage of a 'Super' Pershing firing on a Panther at shortish range, like 100y or so. 90mm AT gun was powerful. Shell went completely through the turret.
12:45:28 <Darkone> PArt of all the equations is reducing things to less of a "boolean: penetrates this units armor?" type thing to where everything is a material that slows a projectile. Less hand work also :P
12:46:52 <aavogt> funny how you use multiple unit systems
12:47:21 <mauke> how much is 100 years?
12:47:37 <aavogt> mauke: light-years
12:48:35 <Darkone> aavogt, works. Guns tend to be measured in mm, while alot of tank ranges and stuff are presented predominantly in yards on the information I can find, though often with meters in parenthesis.
12:49:01 <Darkone> Then you have caliber, etc etc :P
12:51:02 <McManiaC> how can you swap one elemnt of a list with another?
12:51:10 <McManiaC> going through the whole list with foldr?
12:51:17 <fax> McManiaC: which element
12:51:23 <aavogt> McManiaC: not efficiently
12:52:11 <McManiaC> hmhm
12:53:19 <Cale> http://www.chessvariants.com/d.photo/taikyoku1.jpg
12:53:30 <McManiaC> huh
12:53:32 <McManiaC> whats that?
12:53:34 <Cale> can you imagine playing that with drops? :)
12:53:41 <Cale> Taikyoku Shougi
12:53:49 <fax> oh my god
12:53:55 <McManiaC> hmkay
12:53:56 <McManiaC> lol
12:54:32 <Cale> Normal 9x9 shougi gives you the option to use your move to place your captured opponent's pieces as your own
12:55:15 <pastorn> Cale: you know how to play that?
12:55:17 <Cale> But I think that rule sensibly doesn't occur in this variant :)
12:55:17 <twink> Cale: I suggested taikyoku shogi to have branching factors so high as to defeat the usual search methods for chess.
12:55:40 <Cale> pastorn: Not really.
12:56:00 <Mathnerd314> is there a good flamewar channel? for when you really want to argue?
12:56:14 <Cale> pastorn: Though the wikipedia page goes over what the rules are thought to be. (It's an old game, recently rediscovered, and not all the original rules are clear)
12:56:17 <fax> Mathnerd314, lol
12:56:26 <Darkone> 3000AD games? :P
12:56:27 <mauke> I'd try ##politics if it exists
12:56:28 <pastorn> Mathnerd314: #haskell-blah
12:56:32 <ski> elly : .. imo, the `Error e' constraint on the `Either e' instance of `Monad' (and related monad classes) is a misfeature
12:56:52 <Darkone> #3000AD if it exists anywhere xD
12:57:02 <twink> Cale: I think it's really easy to cook up 3D faerie chess variants with high enough branching factors to defeat the alpha-beta -like game tree search algorithms too.
12:57:23 <Darkone> I doubt it does though... would be too anarchic.
12:57:25 <Cale> twink: Yeah.
12:57:43 <twink> Cale: The higher mobility from the higher dimensionality bumps the branching factors without unmanageable numbers of pieces like taikyoku shogi or tai shogi.
12:57:48 <Cale> twink: Normal shougi also increases the branching factor a lot, because of drops.
12:58:39 <elly> ski: what should it be instead?
12:58:42 <twink> Cale: Ah, piece drops are a big factor in bughouse/bunkhouse, but that's for an even number of players greater than or equal to 4.
13:00:13 <Cale> twink: Well, as soon as there are captured pieces, the tree width gets sort of ridiculous
13:00:34 <Cale> I'm not sure how they deal with it, or much in the way of results in shougi AI.
13:00:44 <ski> elly : i've used `newtype Exn e a = MkExn {unExn :: Either e a}' and `newtype ExnT e m a = MkExnT {unExnT :: m (Either e a)}' with basically the same instances (except possibly `fail' in `Monad'), but omitting the `Error e' constraint
13:01:08 <ski> elly : ideally (imo), the instances on `Either' and `ErrorT' would be fixed, instead
13:01:20 <twink> Cale: wikipedia's article on computer shogi says nothing useful about it
13:03:03 <ski> elly : context : i've sometimes wanted/used an "exception" type of `[Integer]' or something similar .. `noMsg :: Error a => a' and `strMsg :: Error a => String -> a' wasn't really very meaningful for `a' as in that application
13:03:28 <Veinor> who in here knows XML stuff?
13:03:41 <shapr> Me me!
13:03:41 <ski> elly : another variant could be to define an algebraic error type, with different constructors for different kinds of errors, instead of throwing most of everything into a string
13:03:51 <shapr> Veinor: XML has lots of angle brackets!
13:03:58 <Veinor> is <content:encoded> necessarily related in any way shape or form to <content>?
13:03:59 <shapr> Veinor: And like, tags and stuff.
13:04:05 <shapr> Veinor: Nah, that's a name space.
13:04:25 <ski> (elly : end of rant)
13:04:50 <shapr> Veinor: http://en.wikipedia.org/wiki/XML_Namespace
13:05:03 <shapr> Veinor: Have you attended the Boston Area Haskell User's Group?
13:05:17 <Veinor> shapr: sadly, no
13:05:24 <shapr> Veinor: It's really awesome, you should attend.
13:05:29 <Veinor> there was one I meant to go to, but then I got sick
13:05:38 <Veinor> and it looks like the guy who organizes them has disappeared
13:06:01 <shapr> Veinor: I gave a talk on haskell-mode and other Haskell spiffiness for emacs.
13:06:11 <shapr> Yeah, Ravi is no longer working at BlueSpec, dunny why.
13:06:21 <Veinor> shame I didn't make it, it would've only been a 5-minute walk for me :D
13:06:24 <shapr> Veinor: You could organize another meeting!
13:06:44 <Veinor> but I don't know of any place I could get :P
13:06:50 <shapr> I gave a talk about emacs in the MIT Computer Science Artificial Intelligence Lab Reading Room. I am SO Awesome.
13:06:57 <Veinor> perhaps I should badger ezyang about it
13:07:07 <shapr> Veinor: We were using the MIT CSAIL Reading Room before.
13:07:14 <Veinor> yeah, I don't have access to CSAIL
13:07:23 <shapr> I didn't either :-)
13:07:32 <Veinor> you weren't the person that organized it though :P
13:07:40 <shapr> I was the original organizer.
13:07:45 <shapr> Ravi picked it up after me.
13:07:46 <Veinor> >_>
13:08:01 <Veinor> insert foot mouth
13:08:04 <shapr> No worries.
13:08:09 <Veinor> although... that should be insert mouth foot
13:08:12 <shapr> You are correct, I did not organize the recent gatherings.
13:08:20 <Veinor> it seems like currying on the location to insert things into would be more useful
13:08:20 <shapr> So, you were right :-)
13:08:44 <shapr> In any case, lots of Haskell interested folk at MIT, I'm sure you can find a venue if you ask around.
13:08:53 <Veinor> yeah. like I said, maybe I should ask ezyang
13:08:58 <shapr> I'm now in the Southeast USA, or I'd pick up the organizing duties.
13:09:14 <medfly> you guys are at MIT?
13:09:27 <shapr> Veinor, ezyang, several other folk here.
13:09:37 <medfly> I still wonder how can anyone afford it. can you tell me?
13:09:39 <fax> is MIT good??
13:09:40 <shapr> I never attended, I was just a brain-bum.
13:09:47 <Veinor> he's... oh hey, he's not in the room with me. thought he was.
13:09:52 <sinelaw> hi
13:09:53 <shapr> fax: It's really awesome, because of the culture, in my opinion.
13:09:55 <Veinor> medfly: my dad is an investment banker >_>
13:09:56 <shapr> hiya sinelaw!
13:09:57 <medfly> hi sinelaw
13:10:18 <shapr> My dad is a nuclear physicist! Not that I ever went to MIT...
13:10:36 <medfly> my dad is an engineer.
13:10:42 <Ke> you are a disgrace to the family!
13:10:58 <shapr> Ke: Truly, I don't even have a degree yet :-(
13:11:02 <sinelaw> my puppy is a nuclear fusion physicist
13:11:03 * medfly hugs shapr
13:11:06 <shapr> :-)
13:11:11 <Ke> neither do I =o(
13:11:25 <shapr> men, det kommer...
13:11:42 <twink> Cale: Naive 3D on 8x8x8 with each player in a half of a 4x4x4 cube simplex in opposite diagonal corners has 10 non-pawn pieces, 20 pawns, so you can throw in a cardinal and marshal in addition to the 3D generalizations of the usual pieces.
13:11:54 <fax> I lost track of what I am doing
13:12:07 <shapr> Ke: I'm attending classes! I'm taking my very first CS class this term!
13:12:15 <twink> Cale: Sorry, 10 pawns
13:12:30 <Ke> I should finish my masters thesis
13:12:47 <fax> I should do some homework :[
13:12:57 <shapr> It'll probably take me years to finish my degree, but I'm enjoying the college experience.
13:17:05 <aavogt> isn't it supposed to take years?
13:17:13 * Twey hopes to maybe go to Glasgow if he gets stuck studying CS at uni.
13:17:22 <fax> it's good you are enjoying ti shapr
13:17:25 <zLouD> Hey
13:17:38 <fax> hi
13:18:02 <andyjgill> Does anyone know what the current state of the art with haskell stack tracing is?
13:18:34 <shapr> Hey andyjgill, how's the college experience going?
13:19:29 <andyjgill> Very well, shapr
13:19:47 <zLouD> i have some questions about xmonad. i'm using Archlinux and just installed xmonad over the repository, but if i start xmonad now i just get a black screen and in the terminal i get this error: ~/.xmonad/xmonad-i386-linux: executeFile: does not exist (No such file or directory)
13:19:48 <ski> ehamberg : i would call `{grammar(s->np_vp)}' an escape (from DCG to normal Prolog)
13:19:56 <aavogt> andyjgill: as in this here: http://portal.acm.org/citation.cfm?id=1596654&dl=GUIDE&coll=GUIDE&CFID=80942760&CFTOKEN=38922608
13:20:04 <fax> ski ??
13:20:17 <andyjgill> Yes, for example. But it in the current GHC?
13:20:20 <mauke> zLouD: yes, that's how it's supposed to wokr
13:20:29 <Blaine_> I've defined a module `module Euler (euler4) where` and loaded it into ghci with `:l euler.hs`, then when I try to load my main module with `:l main.hs` it says it can't find Euler. My main module `module Main (main) where` I do `import Euler`, but it can't find Euler, despite loading it into ghci before the Main module. What am I doing wrong?
13:20:31 <aavogt> you can also get stack traces for the current ghc with a bit of preprocessing
13:20:37 <shapr> aavogt: Yes, a CS degree should take years, but I already spent six years in college previously.
13:20:58 <ski> fax : ehamberg asked something re DCG yesterday on #prolog .. i was just giving my two cents worth
13:21:06 <andyjgill> Only if you preprocess *all* your code. Including other lib. Ugg.
13:21:18 <fax> oh
13:21:35 <aavogt> andyjgill: I'm not aware of anything in the current ghc from that paper, but maybe I didn't look closely enough
13:22:03 <andyjgill> Sigh. Time to dig out hpc, and start hacking.
13:22:45 <zLouD> mauke: why?
13:22:50 <mauke> zLouD: why what?
13:23:55 <fax> hi
13:23:57 <Blaine_> here's a paste of my files: http://gist.github.com/338874
13:24:05 <zLouD> shouldn't i get a panel or something like that? A tutorial or a terminal?
13:24:10 <fax> Blaine, cool
13:24:11 <mauke> zLouD: no, why?
13:24:41 <Blaine_> fax: in case you missed it, it's related to a question I asked previously.
13:24:45 <Blaine_> :)
13:24:53 <zLouD> mauke: how shall i work without a terminal?
13:24:54 <fax> what question
13:25:09 <ski> Blaine_ : maybe try renaming `euler.hs' to `Euler.hs' ?
13:25:09 <mauke> zLouD: you can start one
13:25:16 <zLouD> how?
13:25:25 <mauke> zLouD: alt-shift-enter
13:25:34 <zLouD> i'll test this
13:25:36 <fax> Blaine_ -- this is quite advanced
13:26:13 <Blaine_> ski: thanks
13:26:20 <Blaine_> got it to work
13:26:50 <ski> Blaine_ : usually, the name of a module (plus `.hs') should match the name of the file it's in
13:27:09 <ski> an exception to that is that the `Main' module need not be in a `Main.hs' file
13:27:24 <Twey> Needn't it?
13:27:42 <Twey> IIRC, if you *explicitly* name your module ‘Main’, GHC wants it to be in a Main.hs
13:28:01 <Blaine_> fax: yes, I can tell you are in awe
13:28:43 <fax> Blaine_: you're memoization thing in fib is not something a beginner would guess
13:28:53 <fax> yet you have named the file wrong XD
13:28:58 <glguy> Twey, GHC is happy if you name your main module something other than main.hs
13:29:41 <Twey> Huh, seems it is.  Okay then.
13:30:01 <sinelaw> i'm bawawak
13:30:14 <Blaine_> fax: copy and paste, good sir
13:30:15 <Twey> Hi, bawawak.  I'm Twey.
13:30:16 <ski> (Twey : seem to work just fine)
13:30:30 <twink> Memoize up to some bound, use duplication recurrences to bring it below the bound?
13:30:41 <sinelaw> yo Twey
13:31:34 <twink> ghc -main-is MyModule.myMain
13:31:50 <ski> (Blaine_ : so, you can have several `Main' modules ("multiple entry-points") in the same directory (presumably importing common modules in the directory), and load/compile each of them (separatedly), as long as no one of them imports any other)
13:31:55 <Twey> twink: Nice
13:32:32 <Blaine_> thanks, awesome explanation
13:32:47 <Veinor> two more XML-related questions: how can I turn &lt;foo%gt; into <foo>, and how can I turn a<foo>b</foo>c into abc?
13:32:48 <sbpaul> > howDoIGrow plants
13:32:50 <lambdabot>   "puts seeds in ground and wait"
13:32:56 <sbpaul> stupid bot
13:33:00 <sbpaul> i'll teach you a lesson
13:33:05 <sinelaw> @undef
13:33:08 <aavogt> @type plants
13:33:09 <lambdabot> Not in scope: `plants'
13:33:12 <sinelaw> hah
13:33:16 <sinelaw> foiled
13:33:26 <sbpaul> well you'll never know the secret now
13:33:32 <sbpaul> hope you're happy
13:33:48 * sinelaw has an evil, smug smile
13:33:53 * sinelaw wipes it off
13:33:59 <sinelaw> sbpaul, *sorry*
13:34:25 <Blaine_> fax: care to explain what's happening in the fib function/
13:34:27 <Blaine_> ?*
13:34:27 <lambdabot> Maybe you meant: . ? @ v
13:34:43 <sinelaw> @wn smug
13:34:44 <lambdabot> *** "smug" wn "WordNet (r) 2.0"
13:34:44 <lambdabot> smug
13:34:44 <lambdabot>      adj : marked by excessive complacency or self-satisfaction; "a
13:34:44 <lambdabot>            smug glow of self-congratulation" [syn: {self-satisfied}]
13:34:44 <lambdabot>      [also: {smuggest}, {smugger}]
13:34:47 <fax> Blaine_: it's a generalized version of something quite simple..
13:34:52 <sbpaul> > growingTimesFor brusselSprouts
13:34:53 <fax> the simple part is: say we did
13:34:54 <lambdabot>   "6/20-6/30 to 10/15-11/1"
13:34:56 <fax> let x = sqrt 2 in x + x
13:35:03 <sbpaul> november???
13:35:05 <sbpaul> that's not right
13:35:11 <fax> of course haskell will only compute sqrt 2 (which lets pretend is a difficult computation) once
13:35:25 <aavogt> > cake !! 24
13:35:26 <lambdabot>   "One cup granulated sugar."
13:35:35 <fax> but if you did
13:35:39 <sbpaul> > cake !! 20
13:35:40 <lambdabot>   "Fiberglass surface resins."
13:35:43 <sbpaul> o_O
13:35:49 <ologNation> http://paste.lisp.org/display/96685
13:35:50 <sbpaul> @type cake
13:35:51 <fax> let x y = sqrt y in x 2 + x 2 ... it WILL compute it twice
13:35:51 <lambdabot> [[Char]]
13:35:55 <sbpaul> > cake
13:35:56 <sinelaw> > cake
13:35:57 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
13:35:57 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
13:36:02 <ologNation> So this little piece of code sets, and then prints out my home directory.
13:36:05 <sbpaul> fiberglass huh
13:36:07 <Twey> Bah, fibreglass
13:36:10 * Twey scratches
13:36:10 <ologNation> But how do you make it actually cd to that directory?
13:36:17 <ologNation> Is that something that you can do with System.Directory?
13:36:29 <fax> so the idea with changing a function  fib : Int -> Int  to   fib' : [Int]  is that each element of fib' will only be computed once
13:36:34 <Blaine_> i.e. x and y will be the result of the right hand side of the = sign?
13:36:39 <sinelaw> @hoogle Num b => [a] -> b -> [a]
13:36:40 <lambdabot> Data.List genericDrop :: Integral i => i -> [a] -> [a]
13:36:40 <lambdabot> Data.List genericTake :: Integral i => i -> [a] -> [a]
13:36:41 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
13:36:46 <Blaine_> and the right side of the = will be computed twice?
13:36:49 <sbpaul> > map reverse cake
13:36:50 <lambdabot>   [".xim ekac etalocohc egakcap ecnuo 52.81 enO",".gnitsorf nacep tunococ der...
13:36:53 <sbpaul> hahaha!
13:36:57 <sinelaw> > drop 5 cake
13:36:58 <lambdabot>   ["Three slash four cups butter or margarine.","One and two third cups granu...
13:37:02 <sbpaul> @let cake = map reverse cake
13:37:02 <lambdabot>  <local>:3:0:
13:37:03 <lambdabot>      Multiple declarations of `L.cake'
13:37:03 <lambdabot>      Declared at: .L.hs:...
13:37:04 <sinelaw> > drop 6 cake
13:37:05 <lambdabot>   ["One and two third cups granulated sugar.","Two cups all-purpose flour.","...
13:37:05 <sbpaul> oh yeah
13:37:08 <Twey> Heh, I tried to parse that as Lojban
13:37:13 <Twey> (the reversed one)
13:37:14 <aavogt> it might be convenient to play with Debug.Trace.trace and various combinations of let, where, and top level declarations to see what sorts of things get recomputed
13:37:33 <aavogt> like here: http://paste.lisp.org/display/96237
13:39:47 <ski> Blaine_ : no, that (locally) defines `x' as a function, whose argument is named `y' in the body
13:40:41 <fax> Blaine_, so consider fib' = [1,1,fib'!!0 + fib'!!1, fib'!!1 + fib'!!2, ...]
13:40:50 <fax> each element of this list need only be computed once
13:40:59 <Veinor> what's the best way to remove XML from a document? i.e., a<x>b</x> -> ab?
13:41:23 <fax> so if we look up fib'!!10 rather than computing fib'!!9 twice and fib''!!8 what 3 times? it will only do each once
13:41:28 <ski> Blaine_ : anyway, the point is that functions do not magically recall whether they've been previously applied to a certain input so as to not recompute the corresponding output -- each time a function is called, the body is evaluated anew (but with some tricks, you can get memoization, if you really want it here)
13:42:07 <fax> of course we use a more compact way to write fib' but it represents the same thing within negligible complexity
13:42:18 <Veinor> I could pull in a pcre and do s/<.*?>//g; but that's silly
13:42:22 <ski> Blaine_ : otoh, variables as well as function arguments will only be computed at most once -- so they "magically remember" not to recompute, so to speak
13:42:30 <sbpaul> what's the right way to do regex in haskell
13:43:20 <fredune> Why is darcsweb not running at darcs.haskell.org ?
13:44:44 <Blaine_> the !! in that function looks odd to me
13:45:15 <Blaine_> I'm only familiar with it as an indexing operator
13:45:27 <aavogt> Blaine_: it is an indexing operator
13:45:30 <Blaine_> I'm not sure what it's doing there
13:45:30 <choffstein> Hey all.  Quick question (again!).  I am having some trouble with 'do'.  Can someone explain to me where I am going wrong with this function: http://haskell.pastebin.com/PF40RSbR
13:45:32 <aavogt> even in that context
13:45:35 <twink> I guess you could use an array to memoize and use the duplication recurrences there.
13:46:00 <twink> > let fibs n = let a = array (0,n) $ [(0,0),(1,1),(2,1)] ++ [(k, let m = k `div` 2 ; t = a ! m in if even k then t*(2*(a ! (m+1)) - t) else t^2 + (a ! (m+1))^2) | k <- [3 .. n]] in a in elems $ fibs 10
13:46:01 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55]
13:46:07 <mauke> choffstein: missing 'then'?
13:46:11 <luite> is it possible to somehow use the vector Unbox (Double,Double) instance for a data A = A !Double !Double ?
13:46:12 <choffstein> ... doh
13:46:12 <fax> Blain_, we can read   fib' !! 3  as  'the third fib' but technically it is looking up the third element of the list
13:46:12 <JoshTriplett> How, in Cabal, can I add an additional dependency to a module, so it rebuilds if that dependency changes?
13:46:23 <JoshTriplett> I have a data file read by Template Haskell.
13:46:29 <fax> @let phi = (sqrt(5)+1)/2
13:46:30 <lambdabot>  Defined.
13:46:45 <choffstein> mauke: I am getting "The last statement in a 'do' construct must be an expression"
13:47:06 <glguy> Veinor, that regex would have killed off the b as well. due to high rate of error in regexes, people generally don't use them in Haskell
13:47:15 <mauke> choffstein: what does your new code look like?
13:47:20 <glguy> they write things with list manipulation functions or parser combinators
13:47:29 <choffstein> I just put a 'then' after the if part
13:47:34 <mauke> glguy: no, it wouldn't
13:47:42 <glguy> .* takes as much as it can
13:47:53 <mauke> he said <.*?>
13:48:01 <glguy> *? is smallest?
13:48:14 <mauke> glguy: you might want to read a regex tutorial
13:48:38 <glguy> I very much doubt that that is what I want to do ;)
13:48:53 <mauke> choffstein: remove 'in', outdent the 'if'
13:49:14 <Blaine_> how does it evaluate so that fib 3 evaluates to fib' !! 3?
13:49:34 <choffstein> mauke: new code looks like: http://haskell.pastebin.com/ztpruxcY
13:49:39 <Blaine_> I don't get how the 3 gets to the other side of the indexing operator
13:49:58 <choffstein> "parse error (possibly incorrect indentation)"
13:50:08 <mauke> choffstein: indent 'else' more than 'if'
13:50:09 <fax> fib n = fib' !! n
13:50:46 <choffstein> mauke: thanks, that seems to have worked!
13:50:58 <mauke> yay
13:51:06 <Blaine_> so is (map fib' [0 ..]) defining a bunch of functions?
13:51:36 <Blaine_> I don't get how this n gets to the other side of !!
13:51:46 <mauke> choffstein: return $ aliasTable @@> (ix, if w < (aliasTable @@> (ix, 0)) then 1 else 2))
13:51:53 <merijn> blackdog: No, map calls a function on every element of a list
13:51:55 <merijn> errr
13:52:10 <choffstein> mauke: Ah, I like that.  Thanks.
13:52:24 <merijn> Blaine_: So (map fib' [0..]) defines an infinite list starting at zero and call fib' on each element of that list
13:52:37 <mauke> > map f [0..] :: Expr
13:52:38 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
13:52:38 <lambdabot>         against inferred ...
13:52:42 <mauke> > map f [0..] :: [Expr]
13:52:42 <lambdabot>   [f 0,f 1,f 2,f 3,f 4,f 5,f 6,f 7,f 8,f 9,f 10,f 11,f 12,f 13,f 14,f 15,f 16...
13:53:00 <Blaine_> k
13:53:41 <Veinor> .*? is 'as little as you can while mathcing', it's a PCRE thing
13:53:55 <Veinor> there's also +? and ??, similarly.
13:54:36 <merijn> Blaine_: Do you know any other languages?
13:54:48 <fax> oh yeah
13:54:50 <fax> MUTUAL RECURSION
13:54:58 <fax> as well as all this OTHER advanced stuff
13:55:08 <stulli> Hi, can somebody suggest a way to beautify this code: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24143 ? I'm trying for quite some time now. I hope it isn't easy, so it's not too embarrassing...
13:55:14 <mauke> Veinor: I'm pretty sure the ? modifier was invented by Perl, not PCRE
13:55:26 <Veinor> AH
13:55:43 <merijn> mauke: Well, that'd be obvious PCRE standing for *Perl* Compatible Regular Expressions, wouldn't it?
13:55:45 <Phyx-> Hello, I was wondering, how do you change haddock's search path? i've tried haddock --optghc=-I<path> since it uses ghc to load, but nothing
13:55:53 <JoshTriplett> Can Cabal track extra files as dependencies of a module, and have modifications to them cause rebuilds?
13:56:01 <fax> stulli, this thing: (\x -> f x >>=) repeat 9 times
13:56:02 <mauke> merijn: Perl *Compatible*, not Perl
13:56:07 <mauke> merijn: and they aren't compatible
13:56:08 <Phyx-> oops -I is wrong flag
13:56:09 <Phyx-> nvm
13:56:10 <fax> :t (>=>)
13:56:11 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
13:56:17 <fax> :t (\x -> ?f x >>=)
13:56:18 <lambdabot> parse error on input `)'
13:56:24 <fax> :t (\x -> ?f x >>= ?y)
13:56:24 <Veinor> I said that because "it's a 'perl' thing" implies that only perl has minimal matching
13:56:25 <lambdabot> forall t (m :: * -> *) a b. (?f::t -> m a, ?y::a -> m b, Monad m) => t -> m b
13:56:38 <mauke> Veinor: and PCRE thing implies it's only PCRE
13:56:38 <fax> stulli ^ this (>=>) is basically the same thing
13:56:40 <aavogt> @type foldr (>=>) id (replicate 8 ?f)
13:56:42 <lambdabot> forall (m :: * -> *) c. (Monad m, ?f::m c -> m (m c)) => m c -> m c
13:56:45 <Veinor> :P
13:56:49 <aavogt> @type foldr (>=>) return (replicate 8 ?f)
13:56:50 <lambdabot> forall (m :: * -> *) c. (Monad m, ?f::c -> m c) => c -> m c
13:58:00 <Peaker> is there an implementation of regexps that has error messages when it fails to match?
13:58:12 <Peaker> perhaps a Parsec based regexp engine, for example :)
13:58:26 <merijn> Peaker: What sort of error message would it return if it doesn't match?
13:58:33 <merijn> Other then just a boolean false?
13:58:38 <EvanR> the part that fails
13:59:01 <EvanR> character at this point is not an a
13:59:20 <EvanR> not in this set
13:59:23 <merijn> I don't think you can sensibly produce such a message for non-trivial regexes
13:59:37 <EvanR> it is simple
13:59:38 <mauke> I think you can, but no one bothers
13:59:49 <Peaker> merijn: the latest position up-to-which it does match, for example
14:00:01 <merijn> Peaker: What if it fails inside an or branch?
14:00:03 <sinelaw> my router is stoopid
14:00:16 <merijn> Should it backtrack to all other possible branches it could have taken which didn't match either?
14:00:20 <Peaker> merijn: then it can say "expected A or B"
14:00:32 <Peaker> merijn: the same thing parsec does
14:00:37 <EvanR> merijn: it has to fail all or parts to fail totally
14:00:44 <fax> Blaine_ has it become clear?
14:01:00 <merijn> EvanR: I know, but if there are multiple options and it fails all of them, which do you report?
14:01:01 <benmachine> stulli: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24143#a24179 a basic simplification that probably doesn't require anything you didn't already know
14:01:08 <EvanR> merijn: all of them
14:01:25 <benmachine> stulli: but you can do better if (as other people have said) you use (>=>) and similar thing
14:01:29 <benmachine> s
14:01:59 <fax> I tend to defined data N = Z | S N
14:02:03 <fax> then Num instance it
14:02:09 <fax> then defined a foldN
14:02:25 <fax> this lets youo foldN return (>=> f) 8
14:02:28 <fax> or something roughly like that
14:02:35 <fax> perhaps (>=> f)
14:02:37 <luite> what is a good way to store a global lookup table? I don't know its size in advance, a larger one should be computed when needed
14:02:39 <fax> the typechecker will know
14:02:48 <merijn> luite: Map?
14:03:10 <merijn> luite: (Binary)Tree, plenty of other data structures
14:03:13 <fax> luite as an external server?
14:03:14 <EvanR> luite: you want a global mutable variable?
14:03:15 <SamB_XP> luite: what are you going to be looking up ?
14:03:16 <benmachine> global is a bad word in haskell :P
14:03:22 <fax> not just haskell!
14:03:28 <stulli> fax, benmachine: Thanks, I'll investigate (>=>)
14:03:30 <benmachine> especially in haskell
14:03:39 <benmachine> stulli: well we can tell you about it if you like
14:03:49 <benmachine> @src (>=>)
14:03:49 <lambdabot> Source not found. That's something I cannot allow to happen.
14:03:56 * fax thinks it's just 'in haskell you don't get away so easily' :P
14:03:59 <benmachine> hmm
14:04:13 <fax> lets try something
14:04:19 <fax> :t (>=>)
14:04:19 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
14:04:56 <pikhq> And it does the obvious thing.
14:05:01 <benmachine> mmhm
14:05:06 <Peaker> luite: You would usually use a ReaderT or StateT in an imperative program
14:05:23 <fax> no I can't figure out how to make djinn  implement it
14:05:30 <benmachine> djinn can't do it
14:05:37 <stulli> benmachine: If you have the time i wouldn't mind to hear about it :)
14:05:38 <benmachine> doesn't do parametrised types
14:05:40 <fax> lets not be so hasty
14:05:46 <benmachine> I think
14:05:47 <fax> maybe it can do it _somehow_
14:05:50 <fax> you are right
14:05:52 <luite> SamB_XP: it's an unboxed vector of values that is needed in some calculations, it must be at least as long as some other vectors passed as a parameter to the calculation functions
14:05:56 <fax> but I am not sure that is the end of the matter
14:05:59 <luite> it's strictly an optimization
14:06:14 <EvanR> luite: doesnt sound like it needs to be global
14:06:20 <EvanR> or mutable
14:06:27 <SamB_XP> it DOES sound tricky
14:06:27 <benmachine> stulli: I actually use (<=<) more often than (>=>) which is the same thing with the arguments reversed
14:06:28 <fax> ?djinn-env
14:06:28 <lambdabot> data () = ()
14:06:28 <lambdabot> data Either a b = Left a | Right b
14:06:28 <lambdabot> data Maybe a = Nothing | Just a
14:06:28 <lambdabot> data Bool = False | True
14:06:28 <lambdabot> data Void
14:06:30 <lambdabot> type Not x = x -> Void
14:06:32 <lambdabot> class Monad m where return :: a -> m a; (>>=) :: m a -> (a -> m b) -> m b
14:06:34 <lambdabot> class Eq a where (==) :: a -> a -> Bool
14:06:36 <benmachine> stulli: do you know about (.) for functions?
14:06:43 <stulli> benmachine: sure
14:06:47 <fax> ?djinn Monad m => (a -> (b m)) -> (b -> m c) -> a -> m c
14:06:47 <lambdabot> Error: kind error: (KVar 1,KStar)
14:06:53 <pikhq> a (>=>) b c = do c' <- a c;b c' -- Whoo, trivial functions
14:06:54 <benmachine> well, have a look at this
14:06:55 <fax> ?djinn Monad m => (a -> m b) -> (b -> m c) -> a -> m c
14:06:56 <lambdabot> -- f cannot be realized.
14:06:58 <benmachine> :t (.)
14:06:59 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:07:00 <benmachine> :t (<=<)
14:07:01 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
14:07:03 <fax> boo
14:07:05 <benmachine> erm
14:07:07 <benmachine> hold on
14:07:11 <EvanR> luite: can you pass the lookup table to the relevant calculations
14:07:14 <benmachine> :t (Prelude..)
14:07:15 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
14:07:16 <benmachine> :t (<=<)
14:07:17 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
14:07:20 <luite> EvanR: I don't export the vector directly, so it's local to my module, but I do want to be able to refer to the same vector
14:07:20 <benmachine> there we go
14:07:27 <benmachine> you can see the similarity, right?
14:07:41 <luite> EvanR: in multiple calls to the function
14:08:08 <benmachine> stulli: (<=<) is like (.) except on functions that return monadic results
14:08:20 <luite> EvanR: I'd rather not, it complicates things too much
14:08:43 <EvanR> luite: really, global mutable variables complicates things more. but to accomplish this you can use an IORef
14:09:03 <benmachine> stulli: how much do you know about foldr?
14:09:10 <SamB_XP> the kleisli fishy ?
14:09:19 <luite> hmm, I'm thinking about using another array to lazily store different sizes of the lookup table
14:10:11 <stulli> benmachine: Yes, i see now. foldr: At first i thought that i should use some kind of fold for my code. I use folds regularly
14:10:23 <luite> EvanR: would an IORef (and unsafePerformIO) be safe when using the multithreaded runtime?
14:10:27 <Peaker> :t foldr (>=>) return
14:10:27 <EvanR> so you want a function lookup input size in some module, and you want it to act like a constant table but be computed and memoized the first time you use it
14:10:28 <lambdabot> forall (m :: * -> *) c. (Monad m) => [c -> m c] -> c -> m c
14:10:45 <fax> :t foldr (?f >=>) return
14:10:46 <lambdabot> forall b a (m :: * -> *). (?f::(a -> m a) -> a -> b, Monad m) => [b -> a -> m a] -> a -> m a
14:10:49 <SamB_XP> luite: the trouble is you can't arrange for those vectors to be turned back into thunks :-(
14:10:57 <luite> EvanR: the lookup table is invisible to the user
14:10:59 <fax> hm that's not good
14:11:12 <ski> @type foldr (>=>) (error "empty list")
14:11:13 <lambdabot> forall a (m :: * -> *) c. (Monad m) => [a -> m a] -> a -> m c
14:11:17 <EvanR> luite: but you want to avoid typing it directly into the code
14:11:23 <benmachine> stulli: the interesting thing about foldr is that it takes a list and replaces all the : with a function of your choice
14:11:27 <SamB_XP> luite: when, say, they haven't been used in quite some time and are just wasting RAM
14:11:42 <benmachine> stulli: so if for example you want to compose a list of functions, you can use foldr (.)
14:12:10 <benmachine> it's a handy way of applying a function a lot of times
14:12:14 <luite> SamB_XP: yeah that is a pity...
14:12:25 * ski often defines `compose = foldr (.) id'
14:13:02 <EvanR> luite: using just an IORef is safe as long as you use it from only one thread, surely you have all the rest of the synchro in place
14:13:05 <stulli> benmachine: Hm, i didn't think about that. And foldr (<=<) would chain monadic functions?
14:13:19 <benmachine> stulli: pretty much
14:13:28 <EvanR> luite: i would think its a hassle to have to use IO for this
14:13:45 <choffstein> I am in a world of horrible 'do' and 'let' pain!
14:13:50 <benmachine> stulli: although, you need another parameter to foldr
14:13:54 <benmachine> hmm
14:13:55 <choffstein> haskell is besting me yet again
14:13:56 <luite> EvanR: yes I'd like to avoid it if possible :)
14:14:04 <EvanR> you can make all your stuff use a 'lookup table monad' but thats like passing it around
14:14:12 <benmachine> > foldr (+) [a,b,c]
14:14:13 <lambdabot>   No instance for (GHC.Num.Num [SimpleReflect.Expr])
14:14:13 <lambdabot>    arising from a use of...
14:14:17 <EvanR> monad transformers...
14:14:18 <benmachine> > foldr (+) z [a,b,c]
14:14:19 <mauke> choffstein: not using layout may help, i.e. explicit { ; }
14:14:19 <lambdabot>   a + (b + (c + z))
14:14:29 <benmachine> ^ this illustrates how foldr works
14:14:30 <choffstein> mauke: ah, yes!
14:14:36 <luite> perhaps there is some generic 'weak reference memo table' on hackage?
14:15:06 <choffstein> I think I just fundamentally don't understand the do statement is my biggest issue
14:15:10 <stulli> benmachine: I have some trouble figuring out which function i would use for chaining. I think i should experiment with foldr (.) a little before tackling my initial problem.
14:15:20 <EvanR> choffstein: its not a statement
14:15:23 <benmachine> stulli: if you like
14:15:26 <choffstein> see?
14:15:28 <EvanR> ;)
14:15:32 <EvanR> its an expression
14:15:33 <Peaker> choffstein: do you understand the Monad class?
14:15:33 <choffstein> My point exactly
14:15:41 <mauke> choffstein: http://mauke.ath.cx/stuff/haskell/how-to-io.html#a7
14:15:46 <choffstein> Peaker: Well, I thought I did.  But obviously not
14:16:25 <benmachine> > foldr (.) succ [(^2), (`mod` 30)] 37
14:16:26 <lambdabot>   64
14:16:51 <benmachine> > (^2) . (`mod` 30) . succ $ 37
14:16:52 <lambdabot>   64
14:17:31 <Peaker> choffstein: do you understand how "do" is syntax sugar for (>>=)?
14:17:58 <benmachine> (ski: I like compose = appEndo . foldMap Endo :P)
14:18:27 <choffstein> Peaker: I didn't realize that.
14:18:58 <Peaker> choffstein: try to write your "do" blocks using only (>>) and (>>=) for a while until you understand them, then later you can switch to "do" :)
14:19:06 <Peaker> choffstein: (Instead of using "do" blocks, for a while, I mean)
14:19:28 <choffstein> Peaker: That is probably a smart plan
14:20:46 <dmwit> I never found the do-block/(>>=) difference particularly enlightening.
14:21:21 <dmwit> > 1000/6
14:21:22 <lambdabot>   166.66666666666666
14:22:49 <Peaker> > 0.666666666 * 6
14:22:50 <lambdabot>   3.999999996
14:23:08 <EvanR> math is wrong!
14:23:15 <choffstein> Peaker: does this look right? http://haskell.pastebin.com/xayNVRMv
14:23:38 <Peaker> choffstein: what's @> ?
14:23:43 <choffstein> Indexing
14:23:54 <choffstein> timeSteps @> 1 returns the first index of timeSteps
14:24:31 <Peaker> choffstein: \newState -> takeStep (clock - c') newState  === takeStep (clock - c')
14:24:45 <Peaker> choffstein: timeSteps @> (floor state') === timeSteps @> floor state'
14:25:33 <Peaker> choffstein: where's state' from?
14:25:42 <choffstein> state' should have been state
14:25:45 <choffstein> sorry
14:26:25 <stulli> benmachine: Thanks for your assistance, i got it all working now with (<=<)!
14:26:27 <Peaker> choffstein: if "state" is Double, why do you seem to use it as if it was an IO action in the "then" clause?
14:27:18 <choffstein> Peaker: ...great question?  Because I am obviously quite confused
14:27:18 <Peaker> choffstein: the result of a function on the right-hand-side of >>= is (m b), or (IO b) in this case.  The "then" clause seems to have the same type as the function, so it should be (IO a), but it is Double
14:27:34 <Peaker> choffstein: do you remember the type of (>>=) and (>>) ?
14:27:39 <Peaker> choffstein: and "return"?
14:27:57 <aavogt> why bother with >>?
14:28:17 <Veinor> ok, so in HXT how can I load a string containing XML? readString gives me an IOSLA, but I don't want to have to be in IO
14:28:22 <ski> stulli : both `foldr (<=<) return' and `foldr (>=>) return' (or `foldr (>=>) undefined', on infinite lists) would chain, but in opposite directions
14:28:32 <choffstein> Peaker: well, I thought >>= was (m a) -> (a -> m b) -> m b
14:28:43 <xerox> Veinor: hmm we already answered that some time ago.
14:28:50 <Veinor> ?
14:28:53 <choffstein> Peaker: and >> is (m a) -> (m b) -> (m b)
14:29:02 <Veinor> refresh my memory?
14:29:15 <xerox> Veinor: the combinators have completely abstract types, it's just matter of how you load stuff in, iirc.
14:29:34 <Veinor> readString specifically returns an IOStateArrow
14:29:56 <xerox> search in the haddock
14:29:57 <Peaker> choffstein: yeah
14:30:01 <Peaker> @type (>>)
14:30:02 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
14:30:03 <Peaker> @type (>>=)
14:30:03 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
14:30:04 <xerox> there're other ways
14:30:24 <Veinor> hmm
14:30:29 <Veinor> this is rather complicated :(
14:30:36 <Peaker> choffstein: so, is your if/then/else there deciding on the IO action to perform?
14:33:14 <aavogt> Veinor: there aren't that many options here http://hackage.haskell.org/packages/archive/hxt/8.5.2/doc/html/Text-XML-HXT-Arrow-ReadDocument.html
14:33:16 <choffstein> ...I am confused about your question
14:33:36 <Veinor> aavogt: yeah, but the first four all return something in IO, and I can't figure out how to use hread and xread
14:33:48 <andyjgill> Has anyone had a go at porting GHC Hood to ghc 6.10 or ghc 6.12?
14:33:59 <Veinor> in particular, why does readString require IO?
14:34:20 <aavogt> @type   pure "hai" >>> Text.XML.HXT.Arrow.ReadDocument.xread
14:34:22 <lambdabot> Couldn't find qualified module.
14:34:38 <aavogt> @type (pure "hai" >>>)
14:34:39 <lambdabot> forall (cat :: * -> * -> *) a c. (Applicative (cat a), Control.Category.Category cat) => cat [Char] c -> cat a c
14:35:11 <stulli> ski: In the other direction? So it would be like chaining (=<<) ?
14:35:25 <Veinor> aavogt: that doesn't work, I tried it >_>
14:35:33 * Veinor flails
14:36:07 <ski> stulli : `(=<<)' is in "the same direction" as `(<=<)', if that's what you're asking about
14:36:33 <Veinor> basically, what I need to do is this: I'm grabbing posts from an rss feed, which in general will contain a <content:encoded> with a CDATA
14:36:49 <Veinor> I need to grab the content:encoded stuff, strip the CDATA, and then parse the XML inside
14:37:18 <ski> stulli :  foldr (<=<) return [foo,bar,baz] a  =  foo =<< (bar =<< (baz a))  =  foo =<< bar =<< baz a
14:37:50 <ski> stulli  :  foldr (>=>) return [foo,bar,baz] a  =  ((foo a) >>= bar) >>= baz  =  foo a >>= bar >>= baz
14:38:50 <stulli> ski: Ah, thanks. I think i got confused because switching between (<=<) and (>=>) didn't change the result in my code.
14:39:05 <ski> stulli :  foldr (>=>) (error "empty list") [foo0,foo1,foo2,...{- infinite list-}] a  =  foo0 a >>= foo1 >>= foo2 >>= ...
14:39:07 <aavogt> @type (>>>)
14:39:09 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
14:39:47 <Peaker> stulli: when a == b, all infix operators  a * b   are cummutative :)
14:40:16 * sinelaw casually controls his application by moving his face
14:40:25 <Peaker> sinelaw: ;-)
14:40:30 <Peaker> next generation UI's
14:40:38 <Peaker> emphasis on neck muscle strength
14:40:55 <sinelaw> it's extremely uncomfortable :)
14:40:58 <stulli> Peaker: Yeah, i haven't used folds on non-commutative functions yet i think.
14:41:25 <Peaker> stulli: I mean it's only cummutative because you've got the same thing on both sides of the operator
14:41:32 <SamB_XP> stulli: do you mean non-commutative or non-associative?
14:41:43 <Veinor> maybe I should just write this in python, come back to this when I know more about types and such >_>
14:42:23 <ski> (Peaker : also when `a = b' ;)
14:42:59 <sinelaw> it's also extremely slow
14:44:03 <ski> (benmachine : yes, that's also nice .. but for some reason i'm always forgetting it)
14:46:32 <aavogt> Veinor: well when you run the ArrowXML, you do have to provide the string
14:47:00 <stulli> SamB_XP: Don't confuse me :) But you are right, i meant non-associative. As foldr (++) is associative but non-commutative
14:47:35 <SamB_XP> I've tended to get the various ivities mixed up myself ;-)
14:48:03 * ddarius doesn't understand that.
14:48:03 <Veinor> aavogt: what do you mean?
14:48:18 <aavogt>  say     runLA "hai" hread
14:48:40 <aavogt> that's when you supply the first parameter of the arrow
14:48:57 <Veinor> that doesn't typecheck
14:49:45 <Veinor> rinLA hread "hai" does though
14:49:57 <Veinor> *runLA
14:50:35 <aavogt> oh right
14:51:18 <Veinor> now if only I understood how that worked.
14:52:32 <fax> oh so functional analysis is basically linear algebra + realanalysis
14:53:00 <sinelaw> btw i got to page 15 on Rudin. how impressive.
14:53:09 <ddarius> I wouldn't say so, though there is a lot of linear algebra.
14:53:15 <sinelaw> page 14 took me like 2 hours
14:53:24 <sinelaw> to "gloss over"
14:53:25 <aavogt> Veinor: an arrow    a b c,  is like a function from  b -> c
14:53:27 <fax> sinelaw: I wonder if this is the same book I have
14:53:41 <sinelaw> fax, i think we have already concluded that it is:)
14:54:01 <Veinor> I kind of get that
14:54:04 <aavogt> though it's allowed extra stuff to both the results and arguments
14:54:05 <xerox> why there's no mention of topology, the first 2/3 of the course are like only topology :)
14:54:54 <fax> yeah sinelaw this book is not a good intro for analysis
14:55:14 <avenge> Any ubuntu users?  Am wondering if cabal-install is in some weird package name, or if it really needs to be installed manually on that OS.
14:55:18 <sinelaw> it says that it's a graduate course
14:55:25 <sinelaw> avenge, install haskell-platform
14:55:30 <sinelaw> and it's "cabal install"
14:55:30 <xerox> AIUI functional analysis is exactly putting a topology on spaces of functions to study them, and also prove "useful" stuff (i.e. existence of solutions to certain kind of problems, etc)
14:55:31 <Veinor> that exists?
14:55:33 <fax> graduates should know real anslysi already :/
14:55:35 <sinelaw> avenge, not cabal-install
14:55:44 <sinelaw> fax, right. i'm not even a math undergraduate.
14:55:55 <ddarius> sinelaw: cabal-install is the name of the Haskell package containing the cabal executable.
14:55:59 <avenge> sinelaw:  I do not appear to have a haskell-platform.  Do I need to add a new source of packages?
14:56:04 <sinelaw> i did math-for-engineers courses, except fro calculus I and intro to complex analysis
14:56:14 <Veinor> avenge: are you running lucid?
14:56:18 <fax> xerox, so constructive analysis would actually give algorithms which solve these ?
14:56:23 <fax> functional*
14:56:26 <sinelaw> avenge, http://hackage.haskell.org/platform/
14:56:37 <ddarius> Complex analysis is excellent.
14:56:39 <avenge> Am running Ubuntu 9.10.  Will check the URL.
14:56:40 <xerox> fax: no idea.
14:56:44 <xerox> ddarius: so true! (:
14:56:56 <Veinor> avenge: 9.10 doesn't have any way to install cabal via aptitude, unfortunately
14:56:59 <fax> I only have this rudin book for the complex analysis chapters
14:57:07 <sinelaw> ddarius, yes it is, but as a non-math-major, it's tough.
14:57:08 <Veinor> I'm 99% sure 10.04 does, though.
14:57:14 <avenge> Veinor:  Thanks.  So is the easiest way to install manually with ./bootstrap.sh?
14:57:19 <ddarius> sinelaw: Why?
14:57:24 <xerox> rudin's complex analysis is hard
14:57:27 <fax> sinelaw this is easier http://people.math.gatech.edu/~cain/winter99/complex.html
14:57:41 <sinelaw> ddarius, we don't even know properly what an "open set" is. we wasted half the course on that stuff
14:58:03 <sinelaw> fax, right now i need the real anaylsis stuff more
14:58:05 <Veinor> yeah. bootstrap.sh requires a couple libraries, but you can install them via libghc6-libraryname-dev
14:58:07 <danderson> I'm having a puzzling problem with a program: I'm trying to compile a Haskell hello world and get the output of running the binary (part of sanity checking stuff)
14:58:10 * xerox loves general topology
14:58:20 <sinelaw> which seems to depend on basic topology?
14:58:24 <sinelaw> or did i get it wrong
14:58:26 <fax> no
14:58:27 <ddarius> Real analysis is so boring and useless compared to complex analysis.
14:58:38 <danderson> However, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24180#a24180 prints no output when the compiled program is run. Running the compiled binary by hand produces output.
14:58:44 <xerox> Actually my thesis is going to be general topology \o/ (if all goes well)
14:58:44 <danderson> Anyone have an idea of what I'm missing here?
14:58:58 <Veinor> so can I bother you guys for help with my basic topology class? :D
14:59:07 <xerox> sure (:
14:59:10 <ddarius> There are a lot of introductions to real/complex analysis thath work around (general, point-set) topology.
14:59:11 <Veinor> woohoo!
14:59:36 <ddarius> xerox: I thought everything in "general" topology was already discovered.
14:59:46 <sinelaw> ddarius, rudin doesn't. he seems to do real analysis by teaching abstract stuff and pointing out what that would mean in the real case
14:59:50 <xerox> ddarius: quite, it's undergrad thesis :)
15:00:08 <ddarius> sinelaw: Yes, that's another way of presenting it.
15:00:45 <sinelaw> ddarius, it makes it harder for me, because i need to learn a ton of stuff i never learnt (which is good, but takes a ton of time)
15:00:49 <ddarius> sinelaw: Real analysis deals with metric spaces, so you can already restrict to a metrical view of topology.
15:00:55 <twink> Rudin's Real & Complex analysis doesn't seem to have attracted a lot of fans.
15:01:01 <sinelaw> ddarius, whereas my "classic" calculus background isn't bad
15:01:14 <danderson> oh, well, that's what I was missing. Running the program from my binary bombs with ExitFailure 127, for some reason
15:01:19 <xerox> ddarius: my prof has this cute course on stone-cech, and I'll go further and write down what I'll understand
15:01:47 <sinelaw> is there a package to control the mouse cursor? :)
15:01:53 * sinelaw wants to control it with his face
15:02:26 <sinelaw> ...or a kalman filter package?
15:02:38 <SamB_XP> sinelaw: just be careful when you sneeze!
15:02:44 <ddarius> You can probably find a Kalman filter somewhere on hackage.
15:02:59 <sinelaw> SamB_XP, heh yeah.
15:03:01 <sinelaw> ddarius, nope
15:04:28 <fax> I don't get topology
15:07:11 * hackagebot fixed-list 0.1.5 - A fixed length list type  http://hackage.haskell.org/package/fixed-list-0.1.5 (JobVranish)
15:22:12 <Veinor> whee
15:22:29 <Veinor> does HXT have an 'un-cdata-ifier'?
15:23:55 <Peaker> I wish ghc had a warning flag for open unqualified imports
15:23:57 <Peaker> they suck!
15:24:27 <Peaker> I'd rather repeat the entire list of exported names in parens than get the namespace hell..
15:25:16 * hackagebot pandoc 1.5 - Conversion between markup formats  http://hackage.haskell.org/package/pandoc-1.5 (JohnMacFarlane)
15:25:30 <fax> "differentiation is the /adjoint/ of the boundry operation"
15:25:35 <fax> is that something from category theory?
15:25:55 <fax> can we have adjoint in haskell?
15:26:03 <xerox> sounds like Stokes
15:26:30 <fax> yeah  <curve,d function> = <partial curve,function>
15:26:45 <ologNation> Is there a way to write a haskell script that works as "cd"
15:26:59 <xerox> quite simplistic way to put it, but the message passed :)
15:27:07 <opqdonut> ologNation: yes, but it won't help you
15:27:16 <opqdonut> ologNation: the script might change it's _own_ working directory
15:27:26 <fax> http://en.wikipedia.org/wiki/Adjoint_functors
15:27:28 <fax> none of that
15:27:29 <opqdonut> ologNation: but it can't change your _shell's_ working directory
15:27:31 <fax> makes sense
15:27:43 <xerox> fax: nothing makes sense without context
15:28:08 <danderson> given that uncurry lets me pass 2 arguments as a tuple, how would I build an uncurry2 that lets me pass in a triple of parameters?
15:28:11 <Veinor> opqdonut: but what if your shell supports IPC? :O
15:28:17 <ologNation> opqdonut, Bummer.
15:28:26 <danderson> uncurry . uncurry looks madenningly close, but has nested tuples
15:28:30 <ologNation> I have to use python?
15:28:44 <opqdonut> ologNation: you can't do it in any language
15:28:44 <xerox> danderson: basically yes, it's just there there isn't a natural way (there are two)
15:28:59 <opqdonut> ologNation: cd can't be an external script, it has to be built in to your shell
15:29:28 <danderson> well, I can see the obvious \f (a,b,c) -> f a b c
15:29:58 <danderson> which is quite all right. Just wondering if there is a way to use function combinators to achieve something similar.
15:30:04 <fax> xerox oop
15:30:13 <fax> <curve | d function> = <partial curve | function>
15:30:14 <Veinor> @pl \f (a,b,c) -> f a b c
15:30:15 <lambdabot> (line 1, column 8):
15:30:15 <lambdabot> unexpected ","
15:30:15 <lambdabot> expecting letter or digit, operator or ")"
15:30:15 <lambdabot> ambiguous use of a non associative operator
15:30:15 <fax> not comma
15:30:24 <Veinor> D:
15:30:26 <opqdonut> danderson: not really, there's not that many standard combinators for triples
15:30:44 <fax> diracket notation
15:30:47 <xerox> fax: still too much simplistic, but again, I get what you mean - the proper way to phrase is stokes
15:30:53 <ologNation> opqdonut, Weird.
15:30:58 <ologNation> So I'm missing something conceptually.
15:31:04 <ologNation> There must be a way to do what I want to do.
15:31:09 <danderson> opqdonut: figured as much. Not a huge deal, thanks.
15:31:36 <fax> xerox, it's from http://en.wikipedia.org/wiki/Discrete_exterior_calculus
15:31:42 <ologNation> I have a directory called "2010/03/20" and there is a symlink to it, so I just have to write "cd today" and it goes right there.
15:31:59 <ologNation> I'd rather have some sort of script which knows what day it is than have a symlink that knows what day it is.
15:32:15 <ologNation> so I could just write "cdToday" and it would go there.
15:32:18 <xerox> fax: I never had exterior calculus
15:32:20 <opqdonut> ologNation: you have to write a shell script for that, unfortunately
15:32:25 <opqdonut> or rather, a shell function
15:32:28 <fax> I got it switched :|
15:32:30 <fax> around
15:32:46 <jlouis> cd $(date +%Y%m%d)
15:32:53 <xerox> for all it's worth you could write it upside down... :)
15:33:32 <jlouis> oh, this is Haskell, but it would take some time figuring out what to do there
15:33:40 <Veinor> ologNation: alias "cdtoday = cd $(date +%Y/%m/%d)"
15:39:08 <HugoDaniel> hi
15:39:16 <HugoDaniel> how do i do a mod on Doubles ?
15:39:37 <HugoDaniel> like the C fmod
15:39:55 <xerox> what does fmod does
15:40:03 <xerox> what does fmod do -- eek
15:40:35 <Veinor> fmod is floating mod, I assume
15:40:42 <benmachine> HugoDaniel: you can write the function yourself with division
15:40:42 <opqdonut> x `fmod` y = d such that d<=abs(y) and x=k*y+d ?
15:40:47 <opqdonut> where k is an integer
15:40:55 <benmachine> and floor
15:40:56 <Veinor> HugoDaniel: import Data.Fixed (mod')
15:41:05 <Veinor> :t mod'
15:41:06 <lambdabot> forall a. (Real a) => a -> a -> a
15:41:07 <HugoDaniel> thanks veinor
15:41:08 <HugoDaniel> :D
15:41:12 <opqdonut> oh, with a floor
15:41:18 <opqdonut> what a nonsensical operation, then
15:41:18 <Veinor> > 3.14159 `mod'` 2.71828
15:41:19 <lambdabot>   0.42330999999999985
15:41:45 <opqdonut> > 1.5 `mod'` 0.4
15:41:46 <lambdabot>   0.2999999999999998
15:41:59 <opqdonut> benmachine: a floor where?
15:42:12 <HugoDaniel> lets see if it works
15:42:13 <Veinor> beneath the ceiling!
15:42:29 <HugoDaniel> is there any "best" way to check if a given Double is within 32bit integer range ?
15:42:33 <HugoDaniel> im doing a bunch of if's
15:42:38 <HugoDaniel> with fmod's in between
15:43:09 <benmachine> let fmod n m = let p = fromIntegral (floor (n / m)) in m - p * m
15:43:32 <benmachine> > let fmod n m = let p = fromIntegral (floor (n / m)) in m - p * m in fmod 3.5 1.5
15:43:32 <lambdabot>   -1.5
15:43:36 <benmachine> hrm
15:43:44 <HugoDaniel> :)
15:43:48 <HugoDaniel> ill go with the mod'
15:43:51 <opqdonut> oh, you construct k
15:43:57 <opqdonut> I just gave a description of it :)
15:44:04 <sbpaul> np: Die Monitr Batss - Spread Yr Leggs, Release the Batss
15:44:10 <benmachine> > let fmod n m = let p = fromIntegral (floor (n / m)) in n - p * m in fmod 3.5 1.5
15:44:11 <lambdabot>   0.5
15:44:13 <benmachine> there we go
15:47:17 <Veinor> I hate regex escaping
15:47:41 <Veinor> especially cause I have to double escape everything, like "(<!\\[CDATA\\[)|(\\]\\]>)"
15:47:55 <maurer_> I've got a file that has some Cyrillic strings in it, but when I run hGetContents, it tells me that I have incomplete multibyte characters. Is there some way to tell it not to care about this? (I only care about these strings for the purpose of equality comparison).
15:48:17 <olsner> Veinor: now write a regexp to match for a regexp inside the CDATA :P
15:49:00 <glguy> maurer_: open it as a binary file?
15:49:37 <maurer_> glguy: I suppose. I will have to roll my own CSV parser then though, which would be a bit annoying.
15:49:53 <glguy> Why would you need a new parser?
15:50:26 <maurer_> glguy: Because the one that I'm using right now takes Strings?
15:50:42 <maurer_> I suppose I could just coerce all the Word8's to Chars...
15:50:51 <glguy> maurer_ OK, opening the handle as binary doesn't affect that
15:51:05 <maurer_> Oh? Then why isn't it always opened as binary?
15:51:48 <glguy> because you didn't use openBinaryFile
15:52:04 <maurer_> I understand, I'm just curious what you would want text mode for.
15:53:51 <mreh> CSV parser, I wrote one of those
15:54:00 <mreh> String -> [[a]]
15:54:25 <mreh> of course I knew all the values were numbers
15:55:43 <maurer_> glguy: Does work now though, thanks.
15:55:49 <Veinor> maurer_: I think the difference between textMode and binaryMode is in the semantics of \r and \n
15:56:05 <maurer_> Veinor: Evidently it also has some form of multibyte semantics.
15:56:19 <Veinor> that too
15:56:28 <glguy> New GHC uses your local to decode the bytes
15:56:33 <glguy> using UTF-8, when appropriate
15:56:39 <Veinor> binary mode is 'do not try to interpret these, just read them dumbly'
15:56:48 <glguy> locale*
15:59:25 * hackagebot TypeCompose 0.7.0 - Type composition classes & instances  http://hackage.haskell.org/package/TypeCompose-0.7.0 (ConalElliott)
16:00:25 * hackagebot GtkTV 0.1.6 - Gtk-based GUIs for Tangible Values  http://hackage.haskell.org/package/GtkTV-0.1.6 (ConalElliott)
16:02:39 <roconnor> yay!
16:02:42 <roconnor> GtkTV!!!
16:02:47 <sbpaul> gtktv?
16:02:59 <conal> yup
16:03:05 <xerox> tangible values? woo!
16:03:14 <roconnor> which I presume is like GuiTV except for gtk instead the other one
16:03:41 <conal> roconnor: right.  i wish i'd used the name "wxTV" instead of "GuiTV".  oh well.
16:03:41 <roconnor> now I don't have to figure out how to build wxhaskell anymore
16:04:51 <conal> oh, sweet.
16:04:51 <conal> i much prefer wxhaskell except that it kills its host process.
16:04:53 <conal> though i really want to get away from all of these clunky legacy oo gui libs.
16:05:19 <roconnor> conal: um, isn't that what guitv is?
16:05:40 <twink> This number of updates to the running minimum is killing me.
16:05:40 <roconnor> don't you have to build your functional UI on top of legacy ui?
16:06:35 <conal> roconnor: more than just the programming interface.  the weight, difficulty to install, 2d-ness.
16:06:37 <twink> 1 + (N*(N-1))/(2*N^2) for sequences of length 2 drawn from uniform distributions on [0,N-1] is not generalizing readily enough.
16:06:52 <roconnor> 2d-ness?
16:07:03 <conal> of interfaces.
16:07:09 <roconnor> my screen is 2-d
16:07:28 <roconnor> so is my mouse-like interface
16:07:36 <conal> roconnor: oh, bummer.
16:07:39 <waterlaz> does anyone here uses yi?
16:08:25 <sbpaul> i seem to have it
16:08:28 <sbpaul> hell if i know what it does
16:09:15 <conal> roconnor: then you probably won't be able to use the 3d lib i'm working on.
16:09:25 <sbpaul> conal: FRP?
16:09:37 <conal> sbpaul: frp is about time
16:09:47 <sbpaul> but your library...
16:09:49 <roconnor> conal: do you have a holographic screen on your computer?
16:10:28 <twink> If I'm lucky it'll be something like like \sum_{m=1}^M\binom{N}{m}/(m*N^m) or something idiotic like that where the sequence has length M and the sequence elements are drawn from [0,N-1].
16:10:29 <conal> sbpaul: it's an denotative/functional embedded language & compiler for driving graphics processors.
16:11:49 <sbpaul> i see
16:12:59 <conal> i'm grateful to peter landin for this term "denotative" for what i used to call "purely functional" or "genuinely functional", namely having precise & compositional meanings (denotations).
16:13:09 <fax> :))))
16:13:11 <fax> hi conal]
16:13:54 <conal> fax: hi.  what are you working on?
16:14:13 <sinelaw> conal, i was just about to ask if someone can recommend a functional 3d lib
16:14:29 <twink> N!\sum_{m=1}^M 1/((N-m)!N^m) rather
16:14:47 <sinelaw> i got a simple opencv + 2d opengl program working without a single do-notation (or monadic at all) thing.
16:14:47 <fax> conal, nothing yet. I have some ideas but not the ability
16:14:54 <sbpaul> conal: uhh..."fieldtrip"?
16:15:12 <conal> sinelaw: in what sense "functional"?
16:15:24 <sbpaul> are you "conal elliott"
16:15:26 <sinelaw> conal, denotational :)
16:15:38 <conal> sinelaw: glad to hear.  and what other aspects are important to you?
16:15:39 <conal> sbpaul: yeah.
16:15:42 <sinelaw> conal, not "in the IO monad" stuff
16:15:43 <sbpaul> figures
16:15:49 <sinelaw> composable
16:15:57 <sbpaul> haskell binds to OGRE too
16:16:14 <sinelaw> sbpaul, yeah but does it supply a non-imperative interface?
16:16:18 <conal> sinelaw: those latter two descriptions are easy to slip through.
16:16:36 <sbpaul> dunno
16:16:58 <sinelaw> conal, denotational is the strongest demand, i guess
16:17:10 <conal> sinelaw: e.g. one can get out of the IO monad merely via a newtype wrapper.  denotative/denotational gets to the heart of the difference for me.
16:17:18 <sbpaul> i think a lot of people just wrote these bare-bones on top of opengl
16:17:26 <sbpaul> :/
16:17:37 <sinelaw> conal, yes. unless someone can invent a denotation for IO
16:17:45 <sinelaw> which i doubt
16:17:50 <sinelaw> a simple one, that is.
16:18:03 <conal> sinelaw: i doubt it too.  IO is non-denotational by design/accretion.
16:19:00 <sinelaw> conal, my problem now is, i got my idea for the desired denotation, but i can't see how to implement it
16:19:23 <conal> sinelaw: that's a wonderful problem!
16:19:23 <sinelaw> ...perfectly, i do have an implementation that follows the denotation up to a certain point
16:19:34 <sinelaw> and then probably breaks it
16:20:09 <conal> sinelaw: blog about your goals, your attempt, and where it falls down.
16:20:20 <conal> sinelaw: you'll get more clarity and you'll enable & inspire others to help.
16:20:46 <sinelaw> conal, ok, maybe i will. i'm not even sure the model i have is desirable or sound.
16:21:08 <sinelaw> gotta love those routers
16:22:44 <roconnor> what have people got against IO and dentational semantics?
16:23:21 <sundaymorning> what's being denotational?
16:23:35 <fax> Coping with Denotationality
16:23:41 <sinelaw> roconnor, do you have denotational semantics for IO?
16:23:50 <sbpaul> when did everybody start saying "denotation" so much
16:23:53 <roconnor> sinelaw: including threading issues?
16:24:03 <sinelaw> roconnor, even without
16:25:01 <sinelaw> I wish github gave a blogging service
16:25:32 <roconnor> sinelaw: without threading issues, I imagine it is simply a combination of state and continuation passing to system calls.
16:26:17 <sinelaw> roconnor, that's completely uncomposable
16:26:31 <roconnor> composable with what?
16:26:39 <sinelaw> roconnor, and it's incomplete too, it doesn't describe what system calls are
16:27:00 <roconnor> why do I need to describe what system calls are?
16:27:01 <zygoloid> sinelaw: it implies system calls are opaque. that might be the best we can don.
16:27:29 <sinelaw> roconnor, by composable I mean building bigger things from smaller things in a reusable way
16:27:54 <sinelaw> zygoloid, it probably is the best we can describe
16:27:54 <roconnor> sinelaw: but what does composable mean in this context
16:28:36 <fax> conal I am doing number theory
16:28:47 <sinelaw> fax, he's disconnected
16:28:51 <fax> aw
16:28:54 <zygoloid> sinelaw: it might actually be appropriate, since it's often possible to hook the program's behaviour at syscall boundaries
16:28:54 <roconnor> and why should IO be composable?
16:28:56 <sinelaw> will probably be back soon
16:29:19 <sinelaw> zygoloid, i'm not saying it isn't appropriate in the context of IO
16:29:53 <sinelaw> roconnor, IO itself shouldn't, but programs should be able to describe things at a higher level
16:30:01 <sinelaw> like the usual FRP examples
16:30:13 <conal> i just posted a brief comment about IO being non-denotative at http://conal.net/blog/posts/is-haskell-a-purely-functional-language/#comment-42069 .  I haven't floated this line of reasoning before, and i'd appreciate feedback.
16:30:28 <jmcarthur> i'm a usual proponent of frp, but it does introduce hard questions, and i think i'm going to play devils advocate here
16:30:59 <conal> jmcarthur: did someone bring up frp?
16:31:04 <conal> i may have missed it.
16:31:05 <sinelaw> jmcarthur, that's good
16:31:13 <fax> grahamhutton thank you for the notes on category theory!
16:31:31 <roconnor> sinelaw: Maybe IO *ought* to be at a higher level, but I'm talking about Haksell's IO and what it's dentotations are (or rather what they could/ought to be if someone were to write them down).
16:31:43 <grahamhutton> fax: hope they are useful!
16:31:44 <fax> it was quite good to see written down some of the things I was trying to decide if they were important or not
16:31:53 <jmcarthur> conal: sinelaw brought it up a second ago talking about some of the things frp tries to solve that io doesn't
16:31:56 <sinelaw> roconnor, in that case i agree, i'm just saying it shouldn't be the final word on how we do IO
16:32:18 <fax> grahamhutton yeah the learning curve of category theory is the like step function... it goes from easy to impossible :P
16:32:21 <sinelaw> jmcarthur, so what are the questions?
16:32:26 <roconnor> sinelaw: oh good, yes. I guess I read your "IO" to be the haskell IO monad, not IO in general.
16:32:27 <roconnor> ok
16:32:34 <grahamhutton> fax: one of the biggest problems with learning category theory is figuring out what is important --- there is loads of stuff out there, but really most folks only need some basic concepts.
16:32:38 <jmcarthur> perhaps my advocating for the devil will be useless if i don't ask this question up front though: is frp intended to be an IO alternative?
16:32:38 <conal> jmcarthur: thx.
16:32:39 <sinelaw> roconnor, yeah confusing :) sorry
16:33:27 <roconnor> conal: your link didn't take me to any particular comment :(
16:34:13 <ddarius> grahamhutton: It doesn't look like you cover representability at all, which I would say is the core of category theory.
16:34:27 <sinelaw> jmcarthur, i'd say it's intended to be a higher-level abstraction over IO
16:34:29 <grahamhutton> ddarius: ymmv :-)
16:34:38 <jmcarthur> i mean, IO is often proposed as a counterexample to the problems FRP tackles, but i'm not so sure if FRP as usually presented is a complete alternative to IO, so i just want to make sure i'm not arguing moot points here
16:35:05 <fax> I am learning about representible functors
16:35:08 <sinelaw> jmcarthur, and currently i don't think there's any FRP model that can be shown to completely supersede IO
16:35:13 <fax> dont'r eally get it
16:35:24 * sinelaw read "responsible functors"
16:35:24 <jmcarthur> sinelaw: but do you think that is a goal of FRP?
16:35:30 <jmcarthur> sinelaw: in general, i mean
16:35:32 <fax> there's the graph 0 and the graph 0 --> 1
16:35:47 <fax> apparently the first represents identity and the second represents arrows or something
16:35:48 <jmcarthur> perhaps some FRP-seekers are looking to replace IO and some are not, i should clarify
16:35:51 <ddarius> fax: You are probably looking for stuff that isn't there.
16:36:00 <fax> I get the idea that singleton sets represent identity that's quite simple
16:36:06 <sinelaw> jmcarthur, i feel we're still far from that. we should try to solve at least some big subset of IO-usage before trying to prove completeness
16:36:13 <fax> but category of Models and stuff.. just lose any idea what is going on
16:36:30 <ddarius> fax: A functor is representable if it is naturally isomorphic to a hom-functor.  I.e.  F ~ Hom(X, -) or F ~ Hom(-, Y).
16:36:39 <ddarius> fax: That's the complete definition.
16:36:47 <fax> and Hom(X,Y) is the set of arrows X --> Y of course
16:37:06 <jmcarthur> sinelaw: i disagree with that. i don't think finding the right model seems to be a very incremental process, at least in my highly limited experiences
16:37:21 <jmcarthur> sinelaw: i usually see good models spring from sudden revelation
16:37:38 <sinelaw> jmcarthur, if you look at the papers, they've been proposing various incarnations of models for 10 years
16:37:51 <jmcarthur> sinelaw: yeah, and they don't really build on each other
16:37:53 <sinelaw> jmcarthur, maybe the "right" one will pop-up as a revelation
16:38:18 <sinelaw> jmcarthur, i do think they build on each other's mistakes, especially if you follow the ones proposed by a single person
16:38:19 <jmcarthur> they constrast to older work, but nothing is really a derivative idea
16:38:42 <sinelaw> anyway that's another issue, how good models are born
16:39:09 <jmcarthur> sinelaw: i admit i like your agnostic view toward whether IO can be replaced by FRP
16:39:29 <jmcarthur> that is if i understand it correctly
16:39:43 <sinelaw> jmcarthur, you do
16:39:49 <sinelaw> i'm agnostic about complete replacement
16:40:02 <grahamhutton> oh dear: thinking too much about representability will eventually lead to the black hole of the effective topos...
16:40:10 <sinelaw> but optimistic about improvement for a very large chunk of the problems we use IO to solve
16:40:11 <jlkenyon> Hey, I have a problem with the FFI, when I attempt to use "with" against a type for which I have manually implemented the Storable interface, it seems to go into an infinite loop internally, has anyone else seen that?
16:40:24 <jmcarthur> sinelaw: can you define that chunk?
16:40:27 <mauke> jlkenyon: maybe you've done it wrong
16:40:34 <ddarius> grahamhutton: Why?
16:40:36 <Zao> jmcarthur: How does your storable instance look?
16:40:48 <jlkenyon> mauke: quite possible, http://pastebin.com/WiZ1mygW
16:41:05 <sinelaw> jmcarthur, stuff like gui, robotics, etc.. hard to define, because it's just a hunch.
16:41:13 <mauke> jlkenyon: where's peek/poke?
16:41:16 <sinelaw> reactive systems
16:41:20 <jmcarthur> sinelaw: (my original intent with playing devil's advocate was going to be to criticize certain kinds of IO problems in the context of FRP, but that has diminished in relevance by now)
16:41:45 <jmcarthur> Zao: my storable instance?
16:41:48 <jlkenyon> mauke: This is just a sample of code that will "infinite loop", the "real" code is a lot more complex
16:41:53 <sinelaw> jmcarthur, out of curiosity, what kinds of io problems?
16:41:55 <Zao> "Minimal complete definition: sizeOf, alignment, one of peek, peekElemOff and peekByteOff, and one of poke, pokeElemOff and pokeByteOff."
16:41:59 <mauke> jlkenyon: where's peek/poke?
16:42:04 <jmcarthur> sinelaw: file operations, for example
16:42:07 <Zao> jmcarthur: Misaimed, targetted at jlkenyon.
16:42:43 <Zao> jlkenyon: The default implementations for peek* and poke* are implemented in terms of each other.
16:42:45 <sinelaw> jmcarthur, one thing i am confused about currently is IO writes of any kind
16:42:52 <sinelaw> i'm OK with reads
16:42:55 <Zao> jlkenyon: If you do not provide any of them, they'll mutually hug each other into infinity.
16:42:56 <sinelaw> more or less
16:43:01 <jlkenyon> ah, the compiler did not pester me about it so I assumed it was not required
16:43:26 <jmcarthur> sinelaw: and perhaps the cause for this confusion is that our OS models are not ideal, but surely an expressive IO system should be able to express ideas that are foreign to its native ideas without too much effort
16:43:27 <jlkenyon> That would explain it then, if I implement just one the other will be implemented automatically? clever
16:43:31 <Zao> To quote the source -  "-- circular default instances"
16:43:46 <grahamhutton> ddarius: http://www.math.uu.nl/people/jvoosten/boekkaft.pdf
16:43:48 <Zao> http://www.haskell.org/ghc/docs/6.12.1/html/libraries/base/src/Foreign-Storable.html#peek
16:44:03 <sinelaw> jmcarthur, i'm not sure my confusion has something to do with OS's. i'm not sure how we can/should model writing
16:44:12 <sinelaw> ideally, even
16:44:39 <grahamhutton> ddarius: http://www.math.uu.nl/people/jvoosten/boekbegin.pdf
16:45:31 <jmcarthur> sinelaw: maybe the problem is "writing" itself. maybe it should just be presistence
16:45:37 <jmcarthur> *persistence
16:46:05 * conal has especially flakey internet connectivity today
16:46:17 <jmcarthur> sinelaw: i suppose even writing in the traditional sense could be modelled with something like Behavior Filesystem
16:46:19 <sinelaw> jmcarthur, that solves some of it
16:46:47 <jmcarthur> but only if we consider Filesystem to be entirely owned by the program, not shared with others
16:46:49 <jlkenyon> Zao: Thanks! That is a useful link
16:47:01 <fax> conal that is the most frustrating thing ever
16:47:18 <sinelaw> yeah
16:47:19 <sinelaw> :(
16:47:32 <conal> when i'm out of the Flow, yeah.  otherwise, no problem.
16:47:36 <jmcarthur> sinelaw: or perhaps the Behavior Filesystem should belong to the OS itself and it pulls from programs to determine its state
16:47:46 <conal> (meaning, when i'm in resistance to what is.)
16:47:52 <jmcarthur> it's all a messy matter of conforming to existing models, though
16:48:07 <conal> and thx.
16:48:35 <Zao> jlkenyon: Whenever you're looking around in Haddock documentation, there's often a Source link to the far right of items.
16:49:01 <sinelaw> jmcarthur, there's still a question about output in general. files are only one thing
16:49:09 <jmcarthur> sinelaw: right
16:49:23 <hydo> What's the -right- way to close db handles in the event of an error with HDBC?  Up until now I've been using bracket, but I'm getting empty results on any query using fetchAllRowsAL and friends.
16:49:26 <sinelaw> with that direction you'll end up with Behavior World
16:49:40 <hydo> in the event of an exception, I mean of course.
16:49:43 <jmcarthur> it's nice to model reactivity, but it needs to perform IO or communicate with an IO subsystem in some simple enough to understand way
16:49:57 <conal> i'm not sure we have to model file systems denotatively any more than we have to model register & stack munging.
16:50:14 * sinelaw tries to think of a title for his probably not-to-be-heavily-used blog 
16:50:17 <conal> and address jumping.
16:50:21 <jmcarthur> conal: if i said "have to" anywhere, i didn't mean to
16:50:34 <dark> conal, what do you mean?
16:51:48 <conal> i mean register & stack munging and address jumping have been moved from the program model (denotation) into the implementation.  i suspect we'll move even more notions out of our current programming model into the implementation.
16:52:27 <conal> in particular, i think of I/O as implementing argument & result passing
16:53:13 <conal> including marshalling/unmarshalling
16:53:26 * sinelaw discovers there's another person in the world with his exact name (except middle name)
16:53:51 <Veinor> should I call this function deXML or deXml? similarly, deCDATA or deCdata?
16:54:10 <sinelaw> fromXML?
16:54:17 <sinelaw> Veinor, what does it do?
16:54:28 <Veinor> deXML "a<b>c</b>d" = "a c d"
16:54:38 <fax> hmmmmm
16:54:41 <conal> there.  now my remark about non-denotativity of haskell IO is up.  at the end of http://conal.net/blog/posts/is-haskell-a-purely-functional-language/ .
16:54:55 <fax> Veinor,  deXML "&amp;"?
16:54:57 <conal> i wasn't logged into my blog, and my own comment got moderated.
16:55:04 <Veinor> oh, it just splits tags
16:55:10 <Veinor> it doesn't handle &entities;
16:55:25 <sinelaw> conal, a lesson in humility i guess :)
16:55:33 <fax> why not
16:55:38 <sinelaw> conal, the internetz is smarter than we think
16:55:41 <Veinor> because I don't know how to do that yet :O
16:55:54 <conal> sinelaw: "Life is a long lesson in humility." - James Barrie
16:56:04 <fax> haha that's so true
16:56:13 <Veinor> anyway yes. do you capitalize acronyms in function names?
16:57:33 <Veinor> ... the internet is silent
16:58:50 <sinelaw> conal, btw, i was discussing with someone the other day how we tend to run to fix our mistakes / stumbles and expect things to get straightened in a minute, and forget that while we may stumble in a second the correction may be long and difficult (as the problem is often deeper than the latest symptom)
16:59:11 <sinelaw> just a thought :)
16:59:14 <conal> Veinor: i capitalize acronyms in value names (including functions, but not limited to), where allowed.
16:59:29 <Veinor> yeah, obviously I wouldn't call a function XMLwhatever, because.... yeah
16:59:33 <conal> Veinor: and not allowed at the start of a value name
16:59:43 <Veinor> xMLWhatever? :D
17:00:11 * glguy doesn't capitalize acronyms three letters and longer
17:00:17 <glguy> (in function names)
17:00:38 <conal> sinelaw: ah yes.  often symptoms are attacked rather than fundamentals.  leading to complexity rather than simplicity.
17:00:38 <glguy> habit from C#
17:01:20 <conal> i'm confused about the particular reference to *function* names, as opposed to value names in general.
17:01:27 <ddarius> conal: The semantics of (asynchronous) exceptions are set up to minimize/avoid depending on the order of evaluation.
17:01:39 <glguy> no intentional distinction
17:01:44 <ddarius> glguy: I like how C# has handled that and that it is mostly consistent.
17:01:59 <glguy> I just intended to distinguish from "in general" like in writting
17:02:00 <conal> glguy: kthx
17:02:44 <conal> ddarius: did you catch my meaning about exception handling being able to distinguish order-of-evaluation?
17:02:48 * hackagebot gitit 0.7.3 - Wiki using happstack, git or darcs, and pandoc.  http://hackage.haskell.org/package/gitit-0.7.3 (JohnMacFarlane)
17:03:30 <ddarius> conal: Are you sure you are correct about that?
17:03:46 <sinelaw> conal, you mean that by an exception occurring at a certain point (rather than occuring at a later point) just because one pure function was evaluated before another was?
17:04:08 <conal> ddarius: i'm going from memory.  perhaps in the awkward squad paper.  looking now.
17:04:43 <glguy> synchronous or asynchronous exceptions?
17:06:07 <stepcut> does GHC provide a replacement for: utf8-string Codec.Binary.UTF8.String.{encodeString|decodeString}, or should I use utf8-string?
17:06:41 <conal> maybe someone can help me remember which paper.  it explained throw being pure while catch being in IO
17:06:57 <stulli> @pl f x = (x, g x)
17:06:57 <lambdabot> f = ap (,) g
17:07:36 <glguy> I was just thinking about how GHC happily reorders which exception you'll get when there are multiple that could be thrown
17:07:55 <stepcut> glguy: keeping the imprecise in imprecise exceptions ;)
17:08:00 <glguy> yeah :)
17:08:02 <conal> oh, nice.  the Awkward Squad paper (gently) debunks the myth that IO a = World -> (a, World)
17:08:16 <glguy> but it can be a surprise the first time you weren't expecting it
17:09:11 <stepcut> conal: indeed, its, newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
17:09:11 <stepcut> ;)
17:09:40 <ddarius> conal: http://research.microsoft.com/apps/pubs/default.aspx?id=67492
17:09:41 <conal> stepcut: the myth is that def explains IO.
17:09:54 <conal> stepcut: * that that
17:09:58 <stepcut> conal: yeah
17:10:15 <ddarius> stepcut: That's a crappy definition for IO.
17:10:26 <stepcut> ddarius: works for me ;)
17:10:32 <ddarius> Even the GHC devs think its just a hack.
17:10:33 <conal> ddarius: thx
17:10:52 <JoshTriplett> Can Cabal track extra files as dependencies of a module, and have modifications to them cause rebuilds?
17:11:20 <JoshTriplett> I have a data file that Template Haskell reads to generate code, and changes to that file don't cause rebuilds.
17:11:53 <jlouis> JoshTriplett: extra-source-files, extra-tmp-files IIRC
17:12:03 <jlouis> JoshTriplett: look it up in the cabal doc
17:12:12 <JoshTriplett> jlouis: Thanks!
17:12:54 <jlouis> JoshTriplett: I think they affect recompilation. If not, please tell me I am wrong, so my .cabal can get corrected
17:13:30 * ddarius will be away for a bit.
17:13:38 <JoshTriplett> jlouis: Checking that now.
17:15:55 <JoshTriplett> jlouis: No, they don't.
17:16:06 <kingping> moin
17:16:14 <JuanDaugherty> moin kingping
17:16:17 <JoshTriplett> jlouis: I added my input file, and touched it, and "cabal build" didn't rebuild.
17:17:03 <kingping> How do I pattern-match a binary, in particular Data.BinaryString, seems it doesn't understand (x1:x2:xs) syntax :(
17:17:26 <kingping> s/BinaryString/ByteString
17:17:54 * hackagebot gitit 0.7.3.1 - Wiki using happstack, git or darcs, and pandoc.  http://hackage.haskell.org/package/gitit-0.7.3.1 (JohnMacFarlane)
17:18:45 <Veinor> why does main = print "\248" not print out a character, but instead print out the literal string "\248"?
17:19:25 <Veinor> and putStrLn "\248" spews a bunch of crap
17:20:26 <Zao> Veinor: Because print applies show.
17:20:41 <Veinor> ok so why doesn't putStrLn work?
17:20:48 <benmachine> kingping: you can't pattern match directly on it, but you could do case unpack s of ... or case uncons s of ...
17:20:49 <mauke> define "doesn't work"
17:21:03 <benmachine> kingping: or if you're not afraid of extensions, you could use view patters
17:21:06 <benmachine> view patterns
17:21:15 <Veinor> instead of printing ø, it prints #####0;
17:21:26 <Zao> Veinor: For starters, GHC 6.10 or 6.12?
17:21:32 <Veinor> 6.10
17:21:35 <Veinor> on OS X
17:21:38 <Zao> And your locale is?
17:21:45 <mauke> that seems unlikely
17:22:09 <Veinor> LANG is en_US.utf-8
17:22:19 <kingping> benmachine: I'm afraid of Haskell!! Even having some Erlang programming experience it's not so easy to get Haskell syntax :/
17:22:38 <Zao> Veinor: \248 alone is not a valid sequence of code units.
17:22:59 <Veinor> well, okay
17:23:04 <benmachine> kingping: heh, you'll enjoy it when you do I reckon
17:23:04 <mauke> Zao: it totally is
17:23:15 <mauke> locale shouldn't matter
17:23:19 <Veinor> but when I do 'let x = "ø"; print x' it still messes it up
17:23:23 <Zao> mauke: It doesn't form a complete code point when interpreted by his terminal.
17:23:36 <Zao> mauke: I'm talking from an environment perspective, not an Haskell one.
17:23:47 <mreh> man... I thought the whole point of signal functions was to encapsulate state, now I have to pass out the type of the signal function for when they interact
17:23:51 <mauke> then he should see a replacement character
17:24:04 <mauke> Veinor: what do you see?
17:24:16 <kingping> benmachine: :) I'm sure. But doesn't Data.ByteString.head serves the same purpose as unpack do: extracts a single element.
17:24:21 <Zao> mauke: I wouldn't expect the Terminal to be remotely competent.
17:24:21 <Veinor> I see #####?1h
17:24:29 <kingping> s/serves/serve/
17:24:39 <benmachine> kingping: unpack gives you the head and the tail, head only gives you the head
17:24:41 <benmachine> eeer
17:24:42 <benmachine> no
17:24:48 <benmachine> unpack makes it into a String doesn't it?
17:24:57 <benmachine> unless I'm just completely wrong, which is possible
17:24:57 <kingping> Let me see.
17:24:59 <mauke> Veinor: that's fucked up
17:25:06 <Veinor> it is!
17:25:11 <mauke> Veinor: you should never get that from print
17:25:13 <Veinor> maybe I should test this on a native linux machine
17:25:16 <kingping> unpack :: ByteString -> [Word8]
17:25:25 <kingping> Unpack: Converts a ByteString to a '[Word8]'.
17:25:26 <Veinor> the ufnny part is that ø shows up fine in the terminal
17:25:31 <Zao> Veinor: Try an xterm maybe?
17:25:38 <benmachine> oh, not quite a String
17:25:41 <benmachine> but a list, anyway
17:25:56 <benmachine> so then you can pattern-match on that, but I guess it's inefficient
17:26:01 <Zao> Veinor: As in "ø" in your source? If your file is UTF-8 encoded, that's two code units.
17:26:10 <benmachine> or maybe it's just pack that's inefficient
17:26:23 <Zao> 0xc3 0xb8.
17:26:41 <Zao> Or hrm, wtf.
17:26:45 <benmachine> or maybe none of it is inefficient unless you're doing a billion of them
17:26:54 <Zao> Might be conflating 6.12 IO semantics.
17:26:56 <Veinor> okay, on a native linux machine
17:26:58 <kingping> benmachine: So, when I need to process a data in form of list, would it be useful to unpack a whole ByteString -> process it -> convert back to ByteString -> save to file ?
17:27:07 <Veinor> let x = "ø"; print x displays the 'what the hell is this thing' symbol
17:27:23 <Veinor> as in, the question mark inside the solid color shape
17:27:30 <kingping> benmachine: Oh, inefficient. There should be something similar to Erlang binary syntax.
17:27:35 <benmachine> kingping: I think in that case you're kind of losing the efficiency of using a ByteString in the first case...
17:27:46 <benmachine> I know no erlang whatsoever
17:28:02 <Zao> Veinor: What encoding is your source file?
17:28:09 <Veinor> I'm running this all in ghci
17:28:18 <Veinor> so, uh, I dunno
17:28:35 <benmachine> I think when you need to process data in list form... don't :)
17:28:39 <kingping> I bet there should be some sort of tutor on hex data :
17:28:53 <benmachine> you could just use string I/O?
17:29:01 <mauke> Veinor: *> print "ø"
17:29:01 <mauke> "\248"
17:29:08 <Veinor> yeah, same here
17:29:16 <kingping> s/data.*$/data processing/
17:29:58 <mauke> <Veinor> let x = "ø"; print x displays the 'what the hell is this thing' symbol
17:30:01 <kingping> benmachine: I would, and IIRC it allows to pattern match/compare but the file also contains non-printable hexadecimals.
17:30:07 <mauke> Veinor: how did you do that?
17:30:42 <benmachine> kingping: if you're using a recent enough GHC, you may need to open the file in binary mode, but other than that what's the problem with non-printables?
17:30:49 <benmachine> > chr 1
17:30:49 <lambdabot>   '\SOH'
17:30:56 <benmachine> > chr 786
17:30:57 <lambdabot>   '\786'
17:31:02 <Zao> putStrLn "\248"  does The Right Thing on 6.12.1 by the way.
17:31:17 <benmachine> Char can hold nonprintables
17:31:52 <Veinor> mauke: I meant putStrLn >_>
17:32:40 <mauke> Veinor: can you make a screenshot?
17:32:53 <mreh> it's annoying, I can think how I'll implement this in an OOP way
17:32:56 <kingping> benmachine: I'd like some sort of processing that works with data in memory. It would just load all data from file, proccess it and save back to another file. Because 2 other applications do the same and I'd like to compare their speed with speed of app compiled with GHC :)
17:33:05 <Veinor> mauke: of what?
17:33:28 <mauke> Veinor: of the putStrLn and the output
17:33:28 <Zao> mauke: I would recommend compiling a source file and feeding the output through xxd.
17:33:29 <mreh> I need to switch behaviour of a function depending on the type of the parameter passed, which would be a whole object in OOP
17:33:38 <Zao> To find out what it spits out, exactly.
17:33:40 <benmachine> kingping: depends on the kind of processing
17:33:44 <Zao> Heck, run the source file through xxd too.
17:34:30 <Veinor> blah... I think I might just do this later
17:34:35 <kingping> benmachine: just a bubble sort algorithm http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24184#a24184
17:34:55 <kingping> benmachine: It looks very compact atm.
17:36:36 <benmachine> kingping: hmm
17:36:43 <kingping> :)
17:37:25 <kingping> Forgot one string: bubblesort list = sort list [] False
17:37:29 <benmachine> (mergesort is more usual than bubble sort in haskell, I think)
17:38:12 <benmachine> I don't know enough about bytestrings to help you further
17:38:25 <kingping> benmachine: I know, but even bubblesort has 2 optimizations which I didn't implement. Just comparing to other languages.
17:38:52 <kingping> Thanks anyway. :]
17:43:00 * hackagebot dwarf 0.23 - Parser for DWARF debug format.  http://hackage.haskell.org/package/dwarf-0.23 (ErikCharlebois)
17:46:24 <danderson> is there a portable function somewhere to delete a whole directory tree?
17:46:52 <danderson> I found System.Unix.Directory.removeRecursiveSafely, but as its name indicates, that won't be portable
17:50:42 <Phyx-> hrm... that's odd... I was expecting gcc to layout the structs from top to bottom in increasing offsets., and not shift things around
17:50:49 <Zao> danderson: http://hackage.haskell.org/packages/archive/directory/1.0.1.0/doc/html/System-Directory.html#v%3AremoveDirectoryRecursive
17:51:53 <Zao> Phyx-: As in members?
17:52:22 <Phyx-> Zao: yeah
17:52:36 <Zao> C or C++?
17:52:40 <Phyx-> C
17:52:57 <mauke> struct members aren't shifted around
17:53:09 <Phyx-> err, meant union members
17:53:23 <mauke> union members all have the same offset
17:53:26 <mauke> 0
17:53:40 <danderson> Zao: bah, I swear I asked Hoogle for exactly that function name. Thanks.
17:53:47 <Phyx-> hmm
17:54:10 <Zao> Phyx-: In C++, non-union members declared without an intervening access-specifier are allocated so that later members have higher addresses within the object.
17:54:28 <Zao> Phyx-: However, the order of allocation if separated by a access specifier is unspecified.
17:54:33 <mauke> it's the same in C
17:54:45 <mauke> slightly simplified in that C has no access specifiers
17:55:47 <Phyx-> I did now know that, thanks Zao, mauke , works now :)
17:56:33 <mauke> Zao: also, there's no padding before the first member
17:57:14 <Zao> Correct.
17:58:35 <Zao> Padding may exist after members, including the last member, such that the alignment requirements of the members are preserved. The padding for the last member is such that the alignment of the first member is satisfied if laid right after it.
17:59:11 <Zao> Language lawyering is much more fun with C and C++ than Haskell.
17:59:32 <mauke> indeed, good sir
18:01:16 <Phyx-> lol
18:01:52 <Phyx-> looks like #Haskell is a good place to learn about other languages too :)
18:02:14 <fax> #haskell is cool!
18:02:49 <mauke> yeah, I know C, Perl, regexes and a few awful bits of C++
18:03:11 <mauke> also unix shell stuff, vim, irssi
18:03:18 <fax> I know haskell and scheme Lisp.... and . thats about it
18:03:25 <fax> oh prolog
18:03:35 <ddarius> fax: You should learn assembly.
18:03:43 <twink> Mercury is pretty cool
18:03:51 <fax> ddarius I have tried actually 3 times and I just  cannot handle it
18:03:56 <fax> my brane doesn't cope
18:03:58 <sinelaw> conal, http://noamlewis.wordpress.com/
18:04:08 <yyz> i don't know haskell ;)
18:04:21 <fax> ddarius, but out of curiousity why should I want to know assembly?
18:04:55 <fax> I tell myself that today computers are more complex than the past so it'r harder to learn assembly but It's probabl yjust a lie to make me not have work so hard
18:05:28 <sinelaw> jmcarthur, you're welcome to comment on that link
18:05:40 <DigitalKiwi> i don't know haskell :(
18:05:56 <conal> sinelaw: nice :)
18:06:25 <fax> haskells easy you just gotta learn the type system and type classes and higher order functions and recursion and GADTs
18:06:26 <luite> ooh a new blog ;p
18:06:35 <fax> it's only like 5 things
18:06:42 <DigitalKiwi> lawl
18:06:48 <ddarius> fax: It's useful for understanding what high-level code translates to for performance and just having an idea what is going on.  There are things that can be done in assembly that are difficult or impossible to do in other languages, not even counting things that require low-level access.  Assembly programming also emphasizes building abstractions.
18:07:04 <luite> why do so many people use this theme? I was planning to use it for my own blog, but it's no fun if everybody else uses it too
18:07:27 <fax> ddarius a little bit like forth then? (which I also tried to learn but just could not i..)
18:07:34 <ddarius> fax: I recommend the 16-bit DOS version of the Art of Assembly: http://homepage.mac.com/randyhyde/webster.cs.ucr.edu/www.artofasm.com/index.html
18:08:14 <fax> thanks
18:08:36 <ddarius> fax: The low-level hardware access stuff is fun.  It's pretty boring in Linux/Win32.
18:09:04 * twink is still trying to figure out some sort of nice closed form for the mean number of updates to a running minimum of a finite sequence of IID uniform deviates on bounded intervals of naturals.
18:09:16 * sinelaw crashes
18:09:23 <sinelaw> w-w-w-what?
18:11:21 <twink> sinelaw: Say that the range of naturals is [0,N-1] and there are M uniform deviates u_1,u_2,...,u_{M-1},u_M, then let v_k = min_{1<=j<=k} u_k be the running minimums. What's the expected (average) value of the number of distinct v_k?
18:11:21 <ddarius> Is someone going to correct Noam Lewis about being wrong?
18:12:25 <twink> sinelaw: Rather, let v_k = min_{1<=j<=k} u_j be the running minimums. What's the expected (average) value of the number of distinct v_k? Or, the expected cardinality of the set {v_k}_{k=1}^M?
18:12:37 <sinelaw> ddarius, you're welcome to do so
18:13:21 <sinelaw> twink, what do you mean by "deviates"?
18:13:33 <twink> fax: You might also want to get a simulator so you can singlestep and debug and so on.
18:13:46 <twink> sinelaw: A sample of a random variable.
18:14:27 <sinelaw> twink, ok now i get the question.
18:17:27 <twink> If (in C) you do current_min = a[0]; nr_updates = 1; for (i = 1; i < M; ++i) { if (a[i] < current_min) { current_min = a[i]; nr_updates++; } } the question is what the average value of nr_updates will be if each array element of a[] is uniformly distributed over [0,N-1]
18:18:00 <sinelaw> twink, yeah got it, doesn't sound like a trivial question at all
18:18:56 <sinelaw> but also not extremely hard, on second thoughts. i'm lazy to try it , though.
18:19:31 <twink> sinelaw: Well, if N->\infty the expected value e_M = H_M (harmonic number), but the bound on N is what kills me.
18:22:18 <twink> sinelaw: For M=2 you get 1 + (1/2)*(1-1/N), for M=3 it's something (much) messier.
18:25:05 <twink> sinelaw: I think part of the messiness has to do with the approach toward M > N, at which point there are no longer any strictly descending sequences.
18:26:09 <sinelaw> twink,  tbh i haven't even began thinking seriously about this, and it seems maybe even a little beyond my abilities, so you're "talking to grandma" (but maybe others are listening)
18:26:33 <fax> I can't keep up with twink here either :P
18:26:41 <fax> this problem is very hard
18:27:05 <fax> I dunno you could probably measure it and graph it and make a guess based on that
18:27:16 <fax> wont help to prove it
18:32:21 <Phyx-> http://www.haskell.org/haskellwiki/Generalised_algebraic_datatype where does the parse and foo come from?
18:33:18 <mauke> parse is defined right there
18:33:31 <mauke> foo should be parse as well
18:34:28 <Phyx-> oh, that's the definition of parse. heheh, because of the text above it I read it as some input/output
18:35:03 <twink> For a 2-element array (M=2), let t be a[0], then a[1] will have probability t/N of being a new minimum, so you have N possibilities for t, and then the expectation is (1/N)\sum_{t=0}^{N-1}(2(t/N)+(1-t/N))=(1/N^2)\sum_{t=0}^{N-1}(N+t) = (1/N^2)(N(N+1)/2) which differs from what I said.
18:38:00 <luite> does anyone have a win32 gtk2hs installer for ghc 6.12.1?
18:38:49 <twink> Because (1/N^2)\sum_{t=0}^{N-1}(N+t) = 1 + (1/N^2)(N(N-1)/2), which matches what I said, sorry.
18:39:14 <Zao> luite: I believe that the leksah installer bundles some kind of 6.12.1 gtk2hs.
18:39:30 <Zao> Unsure if it's a proper installer or just a private set of DLLs.
18:39:42 <luite> hmm, I don't really want leksah
18:39:48 <luite> I'll check :)
18:42:17 <luite> Zao: it seems to only bundle the gtk dll's in the installer
18:42:22 <luite> not a complete gtk2hs package
18:42:54 <Zao> luite: The problem is that the 6.12.1 support is not in a proper release yet, just as a patch (or possibly on trunk).
18:43:06 <luite> yes it has been applied to trunk
18:43:12 <Zao> luite: You could build your own, but that's cumbersome.
18:43:22 <luite> yes I know, I've done it before for 6.10.4 tough
18:43:23 <luite> though
18:44:25 <Masky> question: how can i use a let expression with guards?
18:45:00 <Masky> like let a==1 in | a==1 = true | otherwise = false
18:45:30 <luite> can't you use where?
18:45:55 <mauke> huh?
18:45:55 <luite> that example doesn't really make much sense to me though :)
18:46:27 <Masky> wouldn't I have to make the where explicitly strict to get the same effect?
18:46:50 <xerox> try explaining differently what you want to do
18:48:12 <Masky> I'd like to have a common strictly evaluated value available within guard conditionals
18:48:36 <benmachine> everywhere that has guards is also allowed a where
18:49:00 <benmachine> strictly evaluated is trickier
18:49:06 <luite> Masky: why strict? if it's used in the guards evaluation will already be forced (unless an earlier guard already matches)
18:49:31 <Masky> yeah, it's used in multiple conditionals
18:49:51 <luite> Masky: that's not a problem, if you give it a name in a 'where' it's only evaluated once
18:50:01 <benmachine> at most once!
18:50:06 <Masky> oh, really? great, tanks
18:50:07 <luite> yes :)
18:50:26 <Masky> so what's the difference between let and where then...?
18:51:02 <benmachine> pretty much only the context in which they can be used
18:51:15 <Masky> oh ok
18:51:48 <benmachine> I think that any use of where can be converted into an equivalent use of let
18:51:55 <dark> #haskell has more people than ##c and ##c++ right now o.o' i never thought about haskell (or FP) as being "popular"
18:52:08 <benmachine> in the same way that any use of guards can be converted to an equivalent use of if-then-else
18:52:38 <benmachine> dark: I would hazard that the population of #haskell is a greater fraction of haskell users than the population of ##c is of C users
18:52:50 <theorbtwo> dark: Don't let it get to your head; I'm not sure that means so much that haskell is popular then that the C community is more fractured.
18:52:58 <theorbtwo> Also, that ##c tends to be full of asses.
18:53:01 <Zao> Most of the C users have been banned from ##C though.
18:53:04 <benmachine> heh
18:53:09 <dobblego> I use the C language and I wouldn't join #C
18:53:15 <benmachine> same
18:53:21 <fax> can you use Topos in haskell
18:53:29 <Axman6> Topos?
18:54:37 <fax> A topos is a category with:
18:54:37 <fax> A) finite limits and colimits,
18:54:37 <fax> B) exponentials,
18:54:37 <fax> C) a subobject classifier.
18:54:50 <wavewave> is there any good tutorial for parsec 3?
18:54:51 <fax> exponentials are functions (at least that is my vauge understanding)
18:54:58 <fax> no idea what the other two mean
18:55:02 <wavewave> with new interface.
18:55:07 <wavewave> monad transformer.
18:55:21 <Axman6> eh?
18:55:34 <benmachine> wavewave: a lot of the same things apply
18:55:35 <Axman6> it's just been generalised to work with not just String
18:55:54 <benmachine> Axman6: just that, and the monad transformer thing
18:56:03 <benmachine> ref. existence of ParsecT
18:56:20 <wavewave> yes I am interested in ParsecT.
18:57:00 <theorbtwo> wavewave: Interested in doing what with it, more specificly?
18:57:44 <wavewave> I want to stack Parsec monad on top of IO.
18:58:18 <wavewave> any idea?
18:59:10 <theorbtwo> wavewave: If you mean what I think I do, you can pass a lazy string from the read-all-of-this-lazily IO function I can't remember the name of, which gives a result not in the IO monad.
18:59:29 <theorbtwo> However, several purists will no doubt very shortly tell me that's cheating.
18:59:40 <Zao> Hax!
18:59:45 <dark> (to people that replied) yes, i know all of this, just commenting :D i join a lot of channels, and just read most of time. this is a very active and friendly channel ^^
19:02:19 <wavewave> theorbtwo : you mean using some unsafe function? or trace?
19:03:19 <fax> I wonder what topos are/have to do with anything
19:03:36 <wavewave> Anyway, I am quite curious how to use ParsecT.
19:03:38 <theorbtwo> hGetContents
19:03:47 <theorbtwo> :t hGetContents
19:03:48 <lambdabot> Not in scope: `hGetContents'
19:04:18 <wavewave> theorbtwo : For getting string from file or putting string to file is not a problem.
19:04:48 <wavewave> theorbtwo : I want to make some kind of progress bar when I process a very large file.
19:04:57 <theorbtwo> Aha.
19:04:59 <wavewave> I mean when I parse the file.
19:05:44 <theorbtwo> I'd tend to say that sort of thing doesn't mix terribly well with lazy parsing; you won't parse anything until after you use the results of that parsing.
19:05:45 <wavewave> theorbtwo : I can achieve this using unsafePerformIO or trace.
19:06:16 <theorbtwo> However, you'd probably get better answers from, well, anybody else.
19:06:43 <wavewave> Thanks for your kind answer.
19:06:54 <benmachine> @unmtl ReaderT r IO a
19:06:54 <lambdabot> r -> IO a
19:07:11 <theorbtwo> "unmtl"?
19:07:22 <benmachine> sorry, just thinking aloud
19:07:27 <mauke> @unmtl ReaderT IO IO ->
19:07:27 <lambdabot> err: Parse error
19:07:34 <mauke> :-(
19:07:56 <benmachine> unmtl is a command for deciphering the monad transformers from the mtl library
19:08:02 <fax> how does hom(C^op, Set) relate to Yoneda?
19:08:03 <benmachine> (monad transformer library library)
19:08:11 <theorbtwo> Ah.
19:08:26 * twink wonders if there's a better venue to discuss his algorithmic analysis problem.
19:08:59 <ddarius> fax: One of the Yoneda functors is Hom(-, X) : C^op -> Set
19:09:16 <fax> wow this topos stuff sounds absolutely amazing
19:09:21 <fax> http://math.ucr.edu/home/baez/topos.html 4. examples
19:09:30 <benmachine> @unmtl WriterT w Parsec a
19:09:30 <lambdabot> Parsec (a, w)
19:09:41 <ddarius> Or rather, \X.Hom(-,X) : C -> [C^op, Set]
19:10:06 <ddarius> Where [C,D] is the functor category between the categories C and D.
19:10:24 <wavewave> type Parsec s u = ParsecT s u Identity
19:10:48 <wavewave> so Parsec is just defined as Monad Transformer on Identity monad.
19:11:06 <benmachine> wavewave: I've used ParsecT with IO before but only to use an IO input stream, not to perform IO during the parse
19:11:23 <fax> ddarius, mmm hm
19:11:30 <wavewave> great.
19:11:43 <wavewave> benmachine: how did you use it?
19:11:45 <benmachine> presumably if you have a backtracking parser (i.e. using try) it can't backtrack the IO :P
19:12:07 <benmachine> wavewave: I defined a custom Stream instance so that I could incrementally read a file without using lazy IO
19:12:27 <wavewave> Hmm I see.
19:12:43 <benmachine> but then defined most of my actual parsers to be polymorphic in the monad type anyway
19:12:44 <fax> ddarius, I think I have to prove yoneda before I understand
19:12:54 <fax> ill work on that tommorow
19:13:15 <ddarius> fax: Yoneda is pretty trivial to prove.  The "types" practically force the implementation.
19:13:34 <wavewave> benmachine : do you have any idea with progress bar for parser?
19:14:09 <ddarius> fax: The functor category [C^op, Set] for any category C, is an elementary topos.  You can think of them as C-structured sets.  One example is the category with two objects V and E, and two non-identity arrows V -> E.  The functor category over set with this category is the category of (undirected) graphs and graph homomorphisms.
19:14:19 <wavewave> benmachine : I didn't think about backtracking yet.
19:14:33 <benmachine> well, all the best parsers don't backtrack anyway :)
19:14:57 <benmachine> if all you're doing is output, I'd recommend transforming a Writer monad rather than full IO
19:15:04 <benmachine> what have you tried so far?
19:15:32 <wavewave> I didn't try much. I just made my own parsers.
19:15:49 <ddarius> fax: Awodey's book and Barr and Wells' ESSLLI lecture notes are the two introductory resources I most highly recommend.
19:15:54 <wavewave> I found it took quite much time because my files  are big.
19:16:08 <fax> thanks
19:16:19 <wavewave> so I am now thinking that progress bar... or whatever.
19:17:15 <wavewave> If I use Writer Monad, then maybe I can stack Writer on top of parsec monad.
19:17:40 <ddarius> fax: The most common use of Yoneda (but quite definitely not the only one!) is using the fact that it is full and faithful and the fact that full and faithful functors reflect isomorphisms, which is to say if Hom(-,X) ~ Hom(-,Y) then, by Yoneda, X ~ Y.
19:17:54 <wavewave> still my question is how I can show current progress in real time.
19:18:38 <fax> ddarius, I suppose reflect isomorphisms means that there is a natural transform?
19:19:03 <benmachine> wavewave: this sounds interesting so I'm going to try to write an example
19:19:13 <benmachine> I might fail though :P
19:19:14 <wavewave> In fact, if backtracking can be shown, then that's better.
19:19:24 <fax> maybe that is not really saying eneough
19:20:02 <wavewave> by the way, I am new to this irc.
19:20:10 <wavewave> what is hpaste?
19:20:16 <benmachine> @hpaste
19:20:16 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
19:20:32 <benmachine> or http://hpaste.org/
19:20:46 <benmachine> are you familiar with pastebins?
19:21:19 <wavewave> benmachine : I am not.
19:21:54 <wavewave> I am now reading wikipedia document on pastebin.
19:22:35 <wavewave> I see now.
19:23:15 <wavewave> how can i upload my snippet of codes to hpaste, then?
19:23:45 <benmachine> click new at the top, and copy and paste code into the form
19:23:50 <wavewave> ah.. new button.
19:23:54 <wavewave> I see.
19:25:02 <wavewave> thank you very much.
19:25:50 <ddarius> fax: A functor reflects isomorphism if FX ~ FY means X ~ Y.  That's all.
19:26:13 <fax> okay
19:29:49 <ddarius> Every functor preserves isomorphism (i.e. if X ~ Y then FX ~ FY) because isomorphism is defined by equalities involving composition and id which functors preserve.
19:30:47 <ddarius> A functor is full and faithful if its action on hom-sets is bijective, i.e. if for all A and B, Hom(A,B) ~ Hom(FA, FB).  (fullness corresponds to that map being surjective and faithfullness to it be injective.)
19:31:15 <ddarius> So, as an exercise, show that a functor that is full and faithful reflects isomorphisms.
19:36:42 <kingping> Anyone has ideas on speeding this up (at least a direction) http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24185#a24185 It's damn slow.
19:36:43 <fax> ddarius, I don't get it
19:36:55 <kingping> Even compiled to *.o
19:37:10 <fax> ddarius, "full and faithful" basically means preserves isomorphisms by definition
19:39:27 <Axman6> kingping: profile it
19:39:57 <kingping> Axman6: I guess I should build a custom binary to be able to do that?
19:40:33 <benmachine> wavewave: still about?
19:41:10 <Axman6> yes, you need to compile with profiling enabled, and then pass the appropriate flags to the binary when run using +RTC <profiling flags> -RTS
19:42:30 <ddarius> fax: All functors already preserve isomorphism.  You need to show full and faithful ones reflect isomorphisms.  Full faithfullness just means that the action of the functor on arrows is a bijection.  It doesn't directly say anything about isomorphisms within the category.  You know Hom(A, B) ~ Hom(FA, FB), you need to prove that FX ~ FY implies X ~ Y.
19:42:58 <fax> oh okay let me try writing it out properly then
19:43:38 <benmachine> wavewave: I've got it to work
19:43:49 <twink> Remind me about adjunction again. Hom(FA, B) ~ Hom(A, GB)?
19:44:05 <ddarius> twink: Natural in A and B, yes.
19:46:03 <sbpaul> np: Die Monitr Batss - Spread Yr Leggs, Release the Batss
19:46:37 <twink> sbpaul: I hate to say it, but it's probably the wrong channel for "now playing" announcements.
19:46:54 <benmachine> wavewave: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24186#a24186 have a look
19:46:57 <sbpaul> oh it's automatic
19:47:07 <sbpaul> you should see it when it's on an interval of 2 seconds
19:47:22 <Axman6> you shouldn't never do that
19:47:22 <sbpaul> imagine that same message you just saw, about 68 times
19:47:23 <Axman6> ever
19:47:26 <sbpaul> until the next song comes on
19:47:36 <wavewave> yes..
19:47:39 <benmachine> wavewave: (run test in ghci)
19:47:48 <sbpaul> which it just did
19:47:49 <Axman6> it's a great way o get banned from pretty much anywhere
19:48:03 <wavewave> I just came back.
19:48:03 <sbpaul> people have no appreciation for anything these days
19:48:10 <wavewave> thank you.
19:48:27 <wavewave> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24186#a24186
19:49:19 <DigitalKiwi> obviously it is your choice in music
19:49:29 <sbpaul> i have lovely taste in music
19:49:30 <DigitalKiwi> if you were listening to like, say, Tool
19:49:35 <DigitalKiwi> maybe we would care
19:49:37 <DigitalKiwi> :|
19:49:39 <sbpaul> tool is for tools
19:49:42 <sbpaul> quite honestly
19:49:44 <benmachine> zing
19:49:50 <twink> sbpaul: #haskell-blah might be a little more receptive as the focus is not quite as exclusively technical there.
19:49:51 <sbpaul> not as fast as grindcore
19:49:56 <sbpaul> nor as melodic as decent rock
19:49:59 <DigitalKiwi> Tool is for awesome people, amiritie?
19:50:07 <sbpaul> not even as grungy as sludge metal
19:50:08 <benmachine> I like beethoven?
19:50:10 <DigitalKiwi> amirite*
19:50:27 <sbpaul> me and DigitalKiwi, we go way back
19:50:47 <wavewave> benmachine : Thanks!
19:50:57 <wavewave> I also saw it works!
19:51:13 <sbpaul> DigitalKiwi: how am i supposed to install haskell-cabal on arch again
19:51:16 <DigitalKiwi> sbpaul: to be honest I didn't remmeber ever seeing you before I did lastlog
19:51:24 <sbpaul> well i change names a lot DigitalKiwi
19:51:28 <twink> sbpaul: Come on over to #haskell-blah the water's great and there's no topic derailing to be concerned about there.
19:51:29 <sbpaul> i'm very unpopular
19:52:02 <DigitalKiwi> pacman -S cabal-install
19:52:15 <sbpaul> that's it huh
19:52:27 <wavewave> interesting! great! thx a lot!
19:52:32 <benmachine> cabal-install isn't in the arch repositories is it?
19:52:36 <sbpaul> does that mean i have to edit every pkgbuild that has haskell-cabal
19:52:46 <benmachine> wavewave: if you hang on a sec I have a little interesting side-note to add as well
19:52:59 <DigitalKiwi> haskell-cabal is provided by ghc
19:53:01 <fax> ddarius this is so much harder than than I could posibly imagined :)
19:53:15 <fax> this is a good problem for me
19:53:16 <sbpaul> i have ghc though
19:53:25 <sbpaul> i keepg etting caught in an infinite dep loop
19:53:52 <DigitalKiwi> *shrug* I don't know what any of them do
19:53:55 <sbpaul>    .a>.`?<>2?.
19:53:56 <sbpaul>   \`*~O~#_--`?/
19:53:58 <sbpaul> oops
19:54:04 <sbpaul>  - haskell-cabal (building from AUR)
19:54:05 <fax> sbpaul, what language is that?
19:54:06 <sbpaul> see
19:54:17 <sbpaul> it's part of an ascii art salad fax
19:54:20 <DigitalKiwi> perl, obviously
19:54:29 <fax> oh I thought it was one of those array programming thones
19:54:31 <fax> things
19:54:33 <benmachine> wavewave: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24186#a24187 a neat little trick to do IO directly
19:54:42 <DigitalKiwi> sad thing is it  might be valid perl >.>
19:54:54 <sbpaul> how is that sad
19:55:32 <benmachine> sbpaul: maybe you need to upgrade GHC?
19:55:38 <sbpaul> 1 extra/ghc 6.12.1-2 - This is the installed version
19:55:43 <benmachine> oh
19:56:04 <benmachine> I don't use pacman/AUR for my haskell packages anyway
19:56:13 <benmachine> I just use cabal and/or darcs to get stuff
19:56:43 <sbpaul> that is probably the right approach
19:56:58 <benmachine> it's not really "right" - it works for me
19:57:05 <benmachine> but to each their own
19:57:09 <benmachine> I often say
19:57:30 <DigitalKiwi> aur/cabal2arch 0.7-1 (42) Create Arch Linux packages from Cabal packages
19:57:36 <DigitalKiwi> dunno how well that works
19:57:45 <wavewave> benmachine : Thank you! I checked your new code!
19:57:46 <sbpaul> not very well
19:58:03 <DigitalKiwi> there is also this
19:58:05 <DigitalKiwi> aur/haskell-cabal 1.8.0.2-2 (26) A framework for packaging Haskell software
19:58:05 <benmachine> wavewave: it was fun to write :)
19:58:13 <DigitalKiwi> *shrug*
19:58:14 <sbpaul> haskell-cabal depends on itself
19:58:16 <sbpaul> i have no idea why
19:58:23 <wavewave> benmachine : This has a good abstraction!
19:58:37 <benmachine> wavewave: I like it
19:59:26 <wavewave> benmachine : I think this must be included in new tutorial of Parsec 3. :)
19:59:46 <wavewave> power of monad transformer
19:59:53 <benmachine> yeah, that might be nice
20:00:00 * SubStack wonders if adding a MonadIO to his State monad is a good idea
20:00:29 <benmachine> SubStack: it's nice to avoid or limit IO where possible, I think
20:01:06 <SubStack> yes, that's the reason why I made this state monad in the first place
20:01:17 <[ICR]> I've got a cabal package which used to work fine. I updated cabal-install today, and now I get the error "Cannot find module `Control.OldException': it is a member of the hidden package `base'". However, I have base in my build-depends list. Any ideas?
20:01:21 <SubStack> I'm just thinking how nice it would be to be able to print stuff from inside
20:01:26 <SubStack> maybe I'll add a special function for that
20:01:41 <wavewave> By the way, does the code snippet in hpaste remain forever?
20:02:20 <SubStack> benmachine: and anyways, this GD monad should be much less IO-centric than the current GD module
20:02:21 <wavewave> just wondering~~
20:02:31 <benmachine> wavewave: well, obviously it's subject to the hpaste site continuing to work, but there's no default expiry
20:02:32 <SubStack> which is amazingly imperative
20:02:42 <wavewave> i see.
20:02:57 <SubStack> wherein each function that modifies the Image type is IO () -- :(
20:03:26 <benmachine> SubStack: if you want to print from inside, there are tricks to do that
20:04:04 <benmachine> well, the best way to do it is think, I don't want to *print* from inside, I just want to make a list of strings bubble up from inside
20:04:08 <benmachine> and then make a Writer monad
20:04:14 <benmachine> and use tell
20:04:24 <benmachine> and then you can print them if you want, or you can do something else
20:05:00 <benmachine> if you are definitely set on doing IO from inside, though, you can still do that without allowing arbitrary IO operations
20:05:34 <benmachine> I mean, without allowing e.g. reading files from inside
20:05:38 * hackagebot cgi 3001.1.7.3 - A library for writing CGI programs  http://hackage.haskell.org/package/cgi-3001.1.7.3 (AndersKaseorg)
20:06:42 <SubStack> benmachine: that seems annoyingly complicated
20:07:07 <SubStack> http://github.com/substack/haskell-gd/blob/master/Graphics/GD/Monad.hs <-- what I have so far
20:07:25 <kingping> Is it possible to profile (+RTS) a program in Windows?
20:07:43 <kingping> I just don't have a unix box here.
20:08:15 <benmachine> kingping: I'd be very surprised if not
20:08:33 <b4taylor> Hmmm I can't find the list of Haskell.org mentors for GSoC.
20:08:39 * hackagebot cgi 3001.1.8 - A library for writing CGI programs  http://hackage.haskell.org/package/cgi-3001.1.8 (AndersKaseorg)
20:08:44 <kingping> benmachine: But it generates .o file which cannot be run AFAIK.
20:08:48 <benmachine> SubStack: StateT s (Writer w) a is no more or less complicated than StateT s IO a, imo
20:09:01 <benmachine> kingping: hmm? .o files are never run
20:09:12 <kingping> benmachine: Aha
20:09:26 <kingping> benmachine: I can have exe?
20:09:41 <benmachine> I presume so?
20:10:11 <benmachine> if you have a file with a main function and you do ghc --make file, it should produce a .exe file I think
20:10:37 <kingping> :) I tried this. I'll try once more.
20:11:05 <benmachine> .o files are intermediate products
20:11:22 <kingping> Just to be run in ghci, yep.
20:11:28 <kingping> Or linked.
20:11:35 <benmachine> mm
20:12:08 <b4taylor> benmachine: You can think of it as the code for the individual file before things get combined to be useful.
20:12:46 <benmachine> b4taylor: I can and do :P
20:13:23 <benmachine> (i.e. I am not the one needing explanations here >_>)
20:13:38 <wavewave> benmachine : it's fun. if I interrupt the code and run the code again, then progress bar passed the previous part fast and start from the last interrupted point. :)
20:13:53 <wavewave> Lazy evaluation works very well!
20:13:57 <mmmulani> how would I import a #define from a C header?
20:14:21 <mauke> mmmulani: I'd use hsc2hs
20:14:38 <Zao> mmmulani: bindings-dsl has macros to create an inline function for a macro.
20:15:01 <Zao> Is it a scalar or function define?
20:15:11 <Zao> If the latter, hsc2hs can most probably do it.
20:15:11 <benmachine> wavewave: interesting!
20:15:14 <mmmulani> scalar
20:15:25 <Zao> #num OMGWTF  if using bindings-dsl, I believe.
20:16:27 <Zao> (#const OMGWTF) or something similar with regular hsc2hs.
20:16:31 <mmmulani> ahh #def in hsc2hs
20:16:34 <mmmulani> thanks
20:16:52 <absentia> KTHXWTFBBQ!
20:16:53 <mauke> #def?
20:17:06 <mmmulani> hmm not sure if its #def or #const now
20:17:12 <b4taylor> benmachine: Ha! typed the wrong name, sorry.
20:17:31 <nanashi> const
20:18:48 <nanashi> there is also enum
20:21:49 <b4taylor> Why was this not just deleted or marked as spam? http://hackage.haskell.org/trac/summer-of-code/ticket/1575
20:21:57 <b4taylor> mmmulani: Best troll ever ^
20:22:08 <mmmulani> ahahahahaahahah
20:22:37 <mmmulani> "..as Java.com (or even com.java)"
20:22:58 <benmachine> I think it is satire/humour, not trolling
20:24:06 <hydo> internal error: evacuate: strange closure type 0   .. niiice
20:24:13 <b4taylor> benmachine: It's on a list of GSoC project ideas and not haskell-cafe, sounds like trolling to me.
20:24:32 <benmachine> b4taylor: trolling whom, though?
20:24:37 <benmachine> it's clearly not serious
20:24:52 <b4taylor> Good point. I am not using the word correctly.
20:27:42 <b4taylor> Oh man compositing for xmonad. That will take some serious hacking.
20:28:22 <b4taylor> mmmulani: It is a shame I'm interested in a good number of the ``good'' suggestiongs for GSoC.
20:28:23 <DigitalKiwi> xcmpmgr ?
20:28:37 <DigitalKiwi> or however it is spelled
20:28:45 <DigitalKiwi> does it work with xmonad? It works with awesome iirc
20:28:48 <b4taylor> DigitalKiwi: Not really the same, right? It even admits that it is a demo.
20:29:00 <b4taylor> DigitalKiwi: It works with xmonad in that you can run them both at the same time.
20:29:11 <b4taylor> DigitalKiwi: Not integrated with it though.
20:31:05 <mmmulani> b4taylor: do people treat GSoC like a full time job?
20:31:28 <DigitalKiwi> what is GSoC? oh google summer of code?
20:31:34 <Zao> DigitalKiwi: Yup.
20:32:01 <DigitalKiwi> i don't know much about that
20:36:03 <choffstein> Would someone mind taking a look at http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24189 and telling me why I might be getting " No instance for (Integral Double) arising from a use of `ceiling'"
20:36:31 <benmachine> :t ceiling
20:36:32 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
20:36:57 <b4taylor> mmmulani: They want you to.
20:37:09 <b4taylor> mmmulani: They want 36 hours a week.
20:37:24 <kingping> Ok, I've just made some profiling measurements to this code http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24188#a24188 and this is the result http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24190#a24190
20:37:29 <b4taylor> mmmulani: But really they want you to get it done and as polished as possible.
20:37:42 <b4taylor> mmmulani: The implementing a new garbage collector looks really cool.
20:37:46 * hackagebot hood 0.2 - Debugging by observing in place  http://hackage.haskell.org/package/hood-0.2 (AndyGill)
20:38:02 <kingping> Can I optimize anything here. I think because I have tail call recursion, it's almost nothing to optimize here. :\
20:38:18 <benmachine> choffstein: v = u * 7.0 makes v a Double, then w = i - v demands that w and i be Double too, but i = ceiling v wants i to be (Integral b) => b, so it only works if there is an Integral instance for Double
20:38:34 <choffstein> benmachine: ahhhhhh, that makes sense.  Thank you so much
20:38:38 <benmachine> choffstein: but obviously Doubles aren't Integral - probably you want fromInteger
20:38:52 <benmachine> @quote gonna.call
20:38:52 <lambdabot> No quotes match. You untyped fool!
20:38:55 <benmachine> :(
20:38:58 <benmachine> @quote fromIntegral
20:38:58 <lambdabot> <kmc> says: head [] = peek . intPtrToPtr . fromIntegral . unsafePerformIO . randomRIO $ (0, 2^32)
20:39:01 <benmachine> bah
20:39:32 <benmachine> never mind
20:40:45 <kingping> This code runs almost 1 sec on C but takes 1min10sec on ghc.
20:41:01 <Veinor> ... what does that do? @_@
20:41:37 <ddarius> Veinor: It reads a random location in memory.
20:41:42 <Veinor> haha
20:41:55 <Veinor> IO t is the best type
20:43:49 <nicketynick> I'm trying to use Network.Socket, I can't seem to find the haskell equivalent of ntoh and hton.
20:46:29 <choffstein> So this is a really, really beginner question, but is it possible to chain monads of different types?
20:47:07 <aavogt> not without converting them somehow
20:47:27 <Axman6> technically, i believe that's what monad transformers do, but not directly (like, you can't do [1..10] >>= (f :: Int -> Maybe Int)
20:47:43 <benmachine> :t (>>=)
20:47:44 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
20:47:48 <nicketynick> do I really have to resort to a foreign function call as suggested here? http://www.haskell.org/pipermail/glasgow-haskell-users/2006-December/011772.html
20:47:53 <benmachine> ^ has to be the same m
20:48:09 <andyjgill> Hood, the Haskell debugger, has been uploaded to hackage!
20:48:27 <Axman6> andyjgill: is it any good?
20:48:39 <andyjgill> Its 10 years old!
20:48:43 <ddarius> If I remember correctly, Hood is just glorified printf debugging.
20:48:56 <andyjgill> http://www.ittc.ku.edu/~andygill/paper.php?label=Hood00
20:49:19 <andyjgill> Yes, with laziness respecting semantics. And the ability to observe functions.
20:49:39 <aavogt> http://hackage.haskell.org/packages/archive/binary/0.5.0.2/doc/html/Data-Binary-Builder.html#7 <-- possibly easier to use these than the ffi, nicketynick?
20:49:53 <ddarius> It would be nice if Hat was updated to be able to accept files with extensions.
20:50:04 <ddarius> Similarly for Buddha.
20:51:02 <andyjgill> Yes. I was stuck without a good debugger, trying to find why had an index out of range *somewhere*. Any debugger (that worked with GHC, not just GHC) is needed.
20:51:41 <ddarius> I wonder how hard it would be to make an omniscient debugger for Haskell.
20:52:27 <b4taylor> ddarius: ghci debugger not cutting it for you?
20:52:47 <ddarius> b4taylor: I don't use it.  I rarely use debuggers at all.
20:53:02 <jcreigh> ddarius: is that a joke, or is "omniscient debugger" jargon for something?
20:53:09 <b4taylor> ddarius: I've only used it when I was having trouble with hmatrix.
20:53:11 <ddarius> @google "Omniscient Debugging"
20:53:12 <lambdabot> http://www.lambdacs.com/debugger/
20:53:57 <jcreigh> oh, that. I think I watched a talk about that.
20:54:19 <jcreigh> Sometimes I've wondered whether a VM with a reversible instruction set would be handy sometimes.
20:54:25 <ddarius> jcreigh: Either the Google tech talk or this one http://video.google.com/videoplay?docid=-3253558873931584041&hl=en which is from DanFest.
20:55:29 <ddarius> Omniscient Debugging is really the answer to those people who don't like TCO because you "lose stack frames for stack traces."
21:00:11 <fax> > zipWith (/) (iterate (sqrt . (1+)) 0) [1..]
21:00:13 <lambdabot>   [0.0,0.5,0.47140452079103173,0.38844349350750934,0.3196106364957235,0.26864...
21:00:24 <choffstein> does anyone know if it is possible to update an element in hmatrix's matrix structure?
21:00:28 <fax> > zipWith (/) (iterate (sqrt . (1+)) 1) [1..] !! 10
21:00:29 <lambdabot>   0.14709350886093023
21:01:10 <fax> > zipWith (/) (iterate (sqrt . (1+)) 1) [0..] !! 100
21:01:11 <lambdabot>   1.6180339887498948e-2
21:02:56 <b4taylor> choffstein: That's weird I can't find it.
21:03:26 <choffstein> b4taylor: Yeah, it is putting the kibosh on my project
21:03:34 <b4taylor> choffstein: Is there a reason you need hmatrix?
21:04:13 <choffstein> Not particularly.  Not yet at least.
21:04:27 <aavogt> @hoogle \\
21:04:27 <lambdabot> Data.IntMap (\\) :: IntMap a -> IntMap b -> IntMap a
21:04:27 <lambdabot> Data.IntSet (\\) :: IntSet -> IntSet -> IntSet
21:04:27 <lambdabot> Data.List (\\) :: Eq a => [a] -> [a] -> [a]
21:04:33 <aavogt> @hoogle //
21:04:34 <lambdabot> Data.Array.IArray (//) :: (IArray a e, Ix i) => a i e -> [(i, e)] -> a i e
21:09:09 <nicketynick> grr. confirmed that the PortNumber constructor has different results if I use it on a different endian machine :(
21:09:21 <Blaine_> fax: still there?
21:09:23 <ddarius> nicketynick: Don't use the PortNumber constructor.
21:09:53 <nicketynick> ddarius: what's the proper alternative?
21:10:22 <fax> hi
21:11:52 <ddarius> nicketynick: Use fromIntegral
21:13:57 <nicketynick> ddarius: that worked thanks. I don't get why though..
21:16:53 <Blaine_> fax: once a certain value at a certain index is evaluated, it is cached, am I right?
21:17:04 <Blaine_> which is how haskell allows for memoization?
21:17:54 <fax> remember let x = sqrt 2 in x + x
21:18:03 <fax> here's another example
21:18:17 <b4taylor> nicketynick: fromIntegeral is a function that does some conversion. The type checker will see that it wants it to take your port and go from whatever it was to a Port type. So it just picks the right one. I think Port is a type alias for something sensible.
21:18:18 <fax> let (x1,x2) = (sqrt 2,sqrt 3) in x1 + x2 + x1
21:18:29 <fax> in this case both sqrt 2 and sqrt 3 are only computed once
21:18:36 * Blaine_ needs to take a while to digest that first statement
21:18:38 <Blaine_> haha
21:18:49 <b4taylor> fax: I was recently told that Haskell only memoizes data constuctors.
21:21:10 <b4taylor> fax: I think what happens there is more like the compiler will realize that they should point to the same thunk.
21:21:28 <fax> b4taylor, it's just lazy evaluation
21:22:06 <b4taylor> fax: Oh he was the one thinking it was memoization.
21:22:32 <fax> b4taylor we can implement memoization by exploiting this :)
21:22:39 <fax> but we are not quite ready yet
21:23:52 <Blaine_> fax: so if you wrap stuff in a tuple, it's only evaluated once?
21:24:00 <sundaymorning> what is boxed arithmetic?
21:24:03 <b4taylor> fax: Ah crud, I also didn't realize that it was x1 + x2 + x1 in the 2nd line, I get what you're doing :p
21:24:06 <fax> it's not about the tuple
21:24:39 <fax> because remember the first one.. it happens without a tuple as well
21:24:40 <b4taylor> sundaymorning: As in boxed/unboxed primatives?
21:25:24 <aavogt> boxed primates?
21:25:33 <aavogt> :P
21:25:48 <sundaymorning> Hm, like Int would be unboxed and Integer boxed?
21:25:57 <aavogt> no, both are boxed
21:25:57 <b4taylor> sundaymorning: Not so much.
21:26:10 <Blaine_> uhm...
21:26:18 <b4taylor> sundaymorning: In this case they are just different formats of data.
21:26:24 <sundaymorning> what then?
21:26:24 <Blaine_> I see, kind of
21:26:39 <fax> so consider
21:26:44 <b4taylor> One of the easier ways to understand this is where it can be a real problem.
21:26:51 <b4taylor> Like in Java with int and integer.
21:27:05 <fax> let [fib0,fib1,fib2,fib3,...] = [1,1,fib0+fib1,fib1+fib2,fib2+fib3,...] in fib7
21:27:14 <fax> now first of al, this isn't a real haskell program
21:27:27 <fax> I wrote this out like an infinite expression
21:27:35 <sundaymorning> yeah I see that in java there's int which is a primitive and Integer which is a java class. But I'm not sure where that behaviour is found in haskell
21:27:51 <fax> but just pretend it's proper haskell -- we can turn it into a real program quite easily using recursion
21:27:57 <Zao> sundaymorning: Everything is normally boxed.
21:28:11 <fax> you should see that if we tried to compute fib7 that will compute fib5 AND fib6
21:28:38 <fax> once it did fib5 it will do fib6 (say), but fib5 has already been done, so it will compute fib6 almost instantly
21:29:26 <Blaine_> how?
21:29:43 <fax> how what/
21:29:44 <fax> ?
21:30:17 <aavogt> @where ifl
21:30:17 <lambdabot> I know nothing about ifl.
21:30:22 <Blaine_> how is it that fib 5 has already been computed?
21:30:32 <aavogt> @google implementation of functional languages spj
21:30:33 <lambdabot> http://www.simple-talk.com/opinion/geek-of-the-week/simon-peyton-jones-geek-of-the-week/
21:30:50 <fax> see how I let [fib0,fib1,fib2,fib3,...] = [1,1,fib0+fib1,fib1+fib2,fib2+fib3,...],
21:30:59 <fax> this means that fib0 = 1,  fib1 = 1,  fib2 = fib0+fib1,  and so on
21:31:11 <fax> then fib7 = fib5+fib6
21:31:39 <Blaine_> can the compiler replace all of the fib5+fib6 stuff with hardcoded values?
21:31:56 <fax> no
21:32:20 <Blaine_> so when you call fib7, it's like calling fib5+fib6
21:32:21 <fax> thhere is infinity of them so it cannot do that
21:32:27 <fax> there is nothing being called
21:32:29 <fax> fib7 :: Integer
21:33:06 <b4taylor> fax: I liked the memoized fib on haskellwiki
21:33:12 <aavogt> it could pre-compute them... but it doesn't
21:33:30 <b4taylor> aavogt: Where would it stop?
21:33:41 <ddarius> @where ifl
21:33:42 <lambdabot> I know nothing about ifl.
21:34:12 <aavogt> b4taylor: depending on your program, it might be able to know statically that use up to some value
21:34:29 <b4taylor> aavogt: Oh for sure.
21:34:31 <ddarius> nicketynick: The hton is in the fromInteger method of the Num instance for PortNumber.
21:34:46 <b4taylor> aavogt: But this is not the case for that fib example.
21:35:11 <fax> Blaine_, imagine a haskell program as a graph like this http://upload.wikimedia.org/wikipedia/en/thumb/0/03/Expression_Graph.svg/300px-Expression_Graph.svg.png
21:35:33 <fax> Blaine_, we can rewrite the part 3 + 3 into just 6
21:35:45 <fax> then anyone who wants to use that value doesn't need to compute 3 + 3 again
21:36:27 <Blaine_> It seems to make sense conceptually, but something isn't quite connecting, and I don't know enough haskell to tell you what it is :P
21:36:29 <b4taylor> fax: Oh man dangerously close to talking about graph reductions (ahahahaha!)
21:36:38 <fax> b4taylor: it is graph reduction
21:37:25 <b4taylor> fax: Indeed. I meant graph reduction for general graphs, not just arithmetic.
21:38:10 <fax> there is nothing special about arithmetic
21:38:32 <b4taylor> Except that it takes less understanding than working with a digraph.
21:40:04 <Axman6> b4taylor: time to hearn :)
21:40:10 <Axman6> uh, Blaine_, not b4taylor
21:40:14 <Axman6> @where lyah
21:40:14 <lambdabot> http://www.learnyouahaskell.com/
21:40:49 <b4taylor> Axman6: As I have not looked at lyah for a while, there may be something there that I don't know.
21:41:14 * Axman6 thinks it's time everyone had a look at lyah and learnt them some haskell
21:42:24 <b4taylor> Axman6: I take it back, I don't see anything new, just stuff I need more practice with.
21:42:29 <zeiris> There was some optional GHC extension for better-looking record updates, right? What was its name?
21:42:35 <Axman6> time to practice ;)
21:42:52 <twink> For Haskell learning I should probably figure out http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=8548#a8548 again
21:43:18 <b4taylor> Axman6: Indeed but there is only so many things I can bring myself to parse with Parsec where I can abuse Control.Applicative.
21:43:32 <Veinor> zeiris: record puns?
21:43:46 <Axman6> when using Parsec, you can always abuse Applicative :)
21:45:10 <aavogt> hmm, how would you restrict yourself to applicative when parsing something like Either?
21:46:21 * fax has not been able to prove this Yoneda consequence (yet)
21:46:38 <aavogt> oh,      (string "Left" *> fmap Left readLeft) <|> (string Right *> fmap Right readRight)
21:48:49 <ddarius> fax: The exercise I mentioned is unrelated to Yoneda.  Also, to emphasize Hom(A,B) ~ Hom(FA,FB) via F (fmap).  I.e. F has an inverse F^-1 when acting on arrows.
21:49:06 <fax> oh I thought it was meant to be an application!
21:49:28 <fax> F^-1 is full and faithfull too, of course
21:50:06 <ddarius> F^-1 is not a functor.  It's a function that's inverse to the arrow part of the functor F.
21:50:14 <fax> oh
21:51:30 <ddarius> fax: The corollary to Yoneda is that the Yoneda functor is full and faithful and this is most often used by using the fact that full and faithful functors reflect isomorphisms to prove that the Yoneda functor reflects isomorphisms.
21:51:44 <fax> ahhh
21:51:46 <fax> that makes sense
21:51:48 <fax> koay
21:51:56 <ddarius> What I asked is that you prove that lemma that (any) full and faithful functor reflects isomorphisms.
21:53:30 <fax> yeah
21:53:44 <fax> I'm gonig to try again without using yoneda
21:54:09 <fax> I get a bit mixed up with the overloading
21:55:15 <ddarius> It's common to write F_0 for the action of a functor F on objects and F_1 for the action on arrows.  So full and faithfullness means F_1 : Hom(A,B) ~ Hom(F_0 A, F_0 B)
21:55:31 <ddarius> F_0 and F_1 being Set functions.
21:55:52 <fax> hm
21:56:11 <dancor> is grapefruit dead?
21:56:23 <fax> I thought full and faithfull was  F_1 : Hom(X,Y) --> Hom(F_0X,F_0Y)
21:56:36 <fax> where F is bijective
21:56:42 <fax> er F_1
21:56:44 <ddarius> That's what I wrote.
21:56:49 <fax> oh is that the meaning of ~!
21:56:51 <fax> okay
21:59:02 <ddarius> As a side note, unrelated to the exercise or Yoneda, F is an equivalence of categories if it is full and faithfull and essentially surjective on objects.  Where "essentially surjective on objects" means that if F : C -> D then any object in D is isomorphic to Fc for some object c in C.
22:03:25 <fax> ddarius oh I think I got it! we have FX ~ FY, so take F^-1 of both to get F^-1FX ~ F^-1FY i.e. X ~ Y?
22:04:34 <ddarius> fax: You have to be more explicit than that, but yes, essentially you'll just be moving the isomorphism in the codomain of F back into the domain of F.
22:05:20 <fax> "take F^-1 of both" is justified by F^-1_1 : Hom(A,B) ~ Hom(F^-1A,F^-1B)
22:06:30 <ddarius> There is no F^-1 there is only F_1^-1
22:06:51 * Axman6 suggests this be taken to #haskell-blah 
22:10:28 <fax> ddarius, how about this: We have actually two functions (from FX ~ FY) FX --> FY and FY --> FX, so the Hom(X,Y) ~ Hom(FX,FY) gives us now X --> Y and Y --> X, but since the composition of the FX --> FY --> FX = id then X --> Y --> X = id too :D
22:12:51 <fax> because functor takes id to id
22:13:07 <fax> and Ff.Fg = F(f.g)
22:14:15 <Axman6> no chance you could take this to #haskell-blah?
22:15:49 <fax> ?
22:16:39 <fax> still wrong..
22:16:43 <ddarius> That's basically it.  Here's how I would write the proof. FX ~ FY means we have an arrow f : FX -> FY with an inverse f^-1.  We can set f = Fg and f^-1 = Fh where g = F^-1 f and h = F^-1 f^-1.  That gives Fg . Fh = id = Fid = F(g . h).  We can now apply F^-1 to each side to get id = g . h.
22:17:41 <fax> okay! I better go to bed now
22:17:45 <fax> cheers
22:18:04 <fax> it's funny how this is like a million times harder than it seems when you just read about it...
22:45:19 <dobblego> @hoogle (Applicative f) => (t -> u -> v) -> (a -> f t) -> (b -> f u) -> a -> b -> f v
22:45:20 <lambdabot> No results found
22:45:24 <dobblego> boo
22:45:45 <dobblego> @pl \ x y z a b -> x <$> y a <*> z b
22:45:45 <lambdabot> (. (flip . (((.) . (<*>)) .))) . (.) . (.) . (.) . (<$>)
22:45:53 <dobblego> awesome!
22:46:14 <ddarius> :t liftA2 . liftA2
22:46:15 <lambdabot> forall (f :: * -> *) a b c (f1 :: * -> *). (Applicative f, Applicative f1) => (a -> b -> c) -> f (f1 a) -> f (f1 b) -> f (f1 c)
22:46:22 <dobblego> nice one
22:46:43 <dobblego> actually that doesn't quite work
22:52:37 <ivanm> preflex: seen mornfall
22:52:38 <preflex>  mornfall was last seen on #haskell 4 days, 20 hours, 8 minutes and 2 seconds ago, saying: You could say there's an imperative EDSL for Haskell. : - )
22:53:11 <ivanm> @time mornfall
22:53:12 <lambdabot> Local time for mornfall is Sun Mar 21 06:52:48 2010
22:53:21 <ivanm> so, probably not going to be online atm
22:58:02 <ivanm> sbpaul: you hate freenode so much that you quit from -blah but stay here? :s
23:07:32 <ivanm> Axman6: should we make the date official then?
23:07:47 <Axman6> go for it
23:07:52 <Axman6> and announce it
23:08:50 <ivanm> hey blackdog
23:09:01 <ivanm> we're making AusHack the weekend of the 18 July
23:09:04 <ivanm> you OK with that?
23:09:16 <Axman6> 17-19
23:09:26 <ivanm> isn't 19 the monday?
23:09:38 <ivanm> so 16-18
23:11:19 <ivanm> Axman6: it's the CS department @ UNSW, isn't it?
23:13:42 <ivanm> Axman6: r.e. registration: get them to email me?
23:15:38 <Axman6> ivanm: no idea yet
23:15:43 <Axman6> talk to TacticalGrace
23:15:52 <ivanm> well, that's what byorgey is doing with hac phi 2
23:16:06 <ivanm> I can pass details onto TacticalGrace when he wants/needs them
23:16:26 <TacticalGrace> ?
23:16:37 * Axman6 is off
23:16:47 <ivanm> TacticalGrace: I'm about to announce AusHac for the weekend of the 18th
23:17:16 <Jonno_FTW> nsw? what a gip
23:17:17 <ivanm> you want me to get peoples names, etc. and then just email you all of them later on for internet, etc. purposes (and to make sure we have a big enough room)?
23:17:30 <ivanm> Jonno_FTW: more central and more people there than elsewhere
23:17:34 <ivanm> why, where would you prefer it to be?
23:17:41 <Jonno_FTW> SA, for my convenience
23:17:47 <ivanm> heh
23:17:54 <ivanm> how many other haskellers are from SA?
23:18:02 <Jonno_FTW> idk
23:18:06 <Jonno_FTW> just me probablt
23:18:52 <ivanm> _exactly_
23:19:16 <Jonno_FTW> *tear*
23:19:29 <TacticalGrace> ivanm: tbh, if possible —and if he agrees to do it— it'd be better if benl23 would do the local organisational part
23:19:43 <ivanm> TacticalGrace: OK, I'll send him the details later on
23:20:01 <TacticalGrace> I'm completely snowed under this semester and so not very good at getting things done in time atm
23:20:16 <TacticalGrace> if benl23 doesn't want to do, it will
23:20:19 <TacticalGrace> but let's ask him
23:20:19 <ivanm> heh, fair enough
23:20:38 <ivanm> it'd be even easier to check these things with him if he was in IRC...
23:20:41 <TacticalGrace> maybe we can use a google spreadhseet to get people ot sign up
23:20:51 <TacticalGrace> (fp-syd does it like that I think)
23:21:13 <ivanm> hmmm...
23:21:22 <TacticalGrace> I suspect, there may be more people than those who signed up on the wiki
23:21:35 <TacticalGrace> I mean, I suspect more people will come in the end
23:21:41 <ivanm> yeah
23:22:20 <TacticalGrace> on the weekend, I hope we can get our main seminar room
23:22:35 <TacticalGrace> that's right next to the kitchen, where people can make tea and coffee etc
23:22:41 <TacticalGrace> and has plenty of space
23:23:01 <TacticalGrace> Friday, we'll have to see, but given it is in the break, if we are lucky, we might get that, too
23:23:30 <TacticalGrace> you said, 16-18 July, right?
23:23:47 <ivanm> yes
23:24:01 <ivanm> there'll probably be less people on the Friday anyway
23:24:36 <TacticalGrace> yeah, but the room is pretty convenient
23:25:46 <TacticalGrace> I will check whether we can get it for those days
23:26:04 <ivanm> OK, I'll wait until benl23 gets back to me about how he'd like to organise this before I announce it
23:29:17 <harlekin> @hoogle Ordering -> Ordering
23:29:18 <lambdabot> Prelude pred :: Enum a => a -> a
23:29:18 <lambdabot> Prelude succ :: Enum a => a -> a
23:29:18 <lambdabot> Prelude id :: a -> a
23:30:34 <harlekin> How would I reversely order a list? reverse $ sortBy compare seems very inefficient.
23:31:19 <dobblego> sortBy (flip compare)
23:31:29 * edwardk waves hello.
23:31:34 <harlekin> dobblego, ah! Thanks.
23:31:47 <dobblego> np
23:32:36 <edwardk> @tell ddarius sadly, i was able to abuse the fact that the annotated ropes i described the other day are a reasonable context comonad. there goes my legibility though
23:32:36 <lambdabot> Consider it noted.
