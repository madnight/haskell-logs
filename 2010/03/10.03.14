00:00:00 <shachaf> @where report
00:00:00 <lambdabot> http://www.haskell.org/onlinereport/
00:00:17 <shachaf> hatds: "round x returns the nearest integer to x, the even integer if x is equidistant between two integers."
00:01:04 <hatds> alright, that threw me off for a bit but if it is consistent that will be fine
00:01:11 <hatds> thanks
00:24:02 <dmitry_> Hi
00:24:11 <dmitry_> I'm reading Real World Haskell
00:24:24 <dmitry_> and have a littile problem with foldl/foldr
00:25:03 <dmitry_> I try loading examples from the book to ghci
00:25:21 <dmitry_> and get ambiguous error...
00:25:46 <dmitry_> foldl :: (a -> b -> a) -> a -> [b] -> a
00:25:52 <dmitry_> foldl step zero (x:xs) = foldl step (step zero x) xs
00:25:53 <dmitry_> foldl _    zero []     = zero
00:26:43 <dmitry_> Fold.hs:3:25:
00:26:44 <dmitry_>     Ambiguous occurrence `foldl'
00:27:06 <dmitry_> I think I'm doing something wrong, just can't get what exactly..
00:34:54 <dmitry_> any ideas?
00:37:35 <tibbe> dons: when are you arriving in Zurich?
00:41:56 <AxleLonghorn> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23959
00:42:24 <AxleLonghorn> I'm getting the error about the typechecker finding a type of kind * -> *
00:43:33 <AxleLonghorn> I'm not quite sure the correct way to use this monad
00:43:55 <dfdfdf> dmitry_: there are two definitiions of foldl in scope, because the Prelude defines foldl already
00:44:34 <dfdfdf> dmitry_: put 'import Prelude hiding (foldl)' in your imports
00:44:48 <dmitry_> :) thank you
00:51:12 <dons> tibbe: thursday
00:51:37 <tibbe> dons: alright, have plans then or want to grab some food/get an office tour?
00:51:55 <tibbe> dons: (we won't be able to take all 70+ non-googlers for a tour during the hackathon)
00:52:22 <dabblego> AxleLonghorn, I think you meant to write type Env a = State (Memory, Int) a
00:53:34 <AxleLonghorn> yeah, I figured that out
00:53:38 <AxleLonghorn> thanks though
01:09:08 <aconbere> just picking up parsec for real, noticing that string seems to match charecter by charecter. So in the example given in RWH where you're parsing HTTP Methods
01:09:22 <aconbere> if you're looking at an incoming string something like "POST"
01:09:43 <aconbere> and you have <|> string "PUT" <|> string "POST"
01:09:55 <aconbere> it fails because OST doesn't match UT
01:10:28 <aconbere> if I want to match on whole words... should I use a different function
01:10:33 <aconbere> or tree on first letters?
01:10:49 <McManiaC> try (string "PUT") <|> try (string "POST")
01:12:54 <aavogt> or:  (:) <$> char 'P' <*> (string "UT" <|> string "OST")
01:13:17 <McManiaC> hehe
01:14:08 <McManiaC> http://www.serpentine.com/blog/2008/02/06/the-basics-of-applicative-functors-put-to-practical-work/ nice blog about functors with parsec
01:14:39 <McManiaC> *post
01:14:45 <aconbere> aavogt: that's totally what my "tree it" comment was about :)
01:14:59 <aconbere> "well... I could just check the first letter /then/ parse the rest"
01:15:12 <aconbere> I suppose since http methods are known quanities :P
01:15:26 <Gracenotes> alternatively hack the parsec engine to construct dawgs
01:15:46 <aavogt> I think the process is called left-factoring the grammar?
01:16:30 <aavogt> what does dawg stand for?
01:16:39 <Gracenotes> dawgs also right-factor :) Although.. hm.. it's not much use with the sort of mechanics parsec has
01:16:44 <Gracenotes> directed acyclic word graph
01:17:23 <McManiaC> is there a way to turn the Handle returned by Network.connectTo back into a socket? :S
01:17:26 <aconbere> McManiaC: thanks for the link
01:17:58 <aconbere> I suppose that's probably the primary issue
01:18:13 <aconbere> that I'm trying to get my head around applicative functors and parsec at the same time :)
01:18:31 <McManiaC> ah well
01:18:43 <McManiaC> nothing like learning while doing
01:18:43 <McManiaC> ;)
01:19:03 <aconbere> haha
01:19:07 <McManiaC> I didnt know much about functors until I started messing around with parsec
01:19:18 <aconbere> I usually appreciate the learning in smaller chunks :)
01:19:43 <Gracenotes> aconbere: EBNF translates well to applicative parsec
01:20:47 <Gracenotes> the main thing that differs is how you extract the parser data, strings and the like, and combine it into your own data structure(s)
01:22:12 <Gracenotes> of course, you could parse everything and get nothing but the satisfaction that your string passed ._.
01:22:29 <Axman6> :(
01:22:33 <Axman6> what a waste :(
01:23:22 <aconbere> I have to say... this channel is way more valuable when I'm on in the middle of the night
01:23:36 <aconbere> I should stay up late just for that
01:23:45 <aavogt> @localtime aconbere
01:23:45 <Axman6> aye
01:23:46 <lambdabot> Local time for aconbere is Sat Mar 13 23:23:21 2010
01:23:56 <aavogt> that's not late ;)
01:24:00 <Axman6> where's that?
01:24:26 <aconbere> Hawaii
01:24:26 <aavogt> somewhere in the pacific?
01:24:31 <aconbere> the middle :)
01:24:43 <manjunaths> does anyone have a phenom based box here ?
01:24:59 <aconbere> but we can pretend it's pacific time, since I work remotely out to seattle
01:25:08 <aconbere> I just pretend I live in pacific time
01:25:14 <manjunaths> I am trying to order some parts and don't have any idea what motherboard I should order...
01:25:24 <aavogt> how is that applicable to this channel?
01:26:22 <manjunaths> aavogt, sorry yeah that is off topic
01:40:56 <jargonjustin> I'm having some problems with attoparsec, GHC is saying "Couldn't match expected type `ByteString' against inferred type `Data.ByteString.Lazy.Internal.ByteString'"
01:41:13 <jargonjustin> Searching suggests this is a conflict in the versions the packages were compiled with
01:41:19 <jargonjustin> But I'm not sure how to sort out which is being imported
01:44:06 <aavogt> jargonjustin: which bytestring have you imported? Data.ByteString or Data.ByteString.Lazy?
01:44:14 <aavogt> attoparsec works on the latter
01:44:24 <jargonjustin> aavogt: import Data.ByteString (ByteString)
01:44:30 <jargonjustin> aavogt: Ah! Thanks
01:44:31 <aavogt> then that's your problem
01:45:11 <dons> sounds like a conflict between lazy and strict
01:45:12 <dons> not versions
01:45:45 <jargonjustin> aavogt, the docs for attoparsec seem to imply it works on strict ByteStrings
01:46:11 <aavogt> yeah, when you have version conflicts ghc qualifies the name like  "package-version":Module.Foo
01:47:26 <jargonjustin> aavogt, dons, just realized I was using attoparsec 0.7.2 and looking at the docs for 0.8.0
01:56:16 <Axman6> what do you guys think of this new IDE? http://www.cs.brown.edu/people/acb/codebubbles_site.htm
03:02:20 <jargonjustin> Is there a way to have cabal upgrade a package without trying to upgrade it's dependencies where unnecessary?
03:03:36 <Axman6> woah woah woah, how did i not know about Language.C?
03:03:39 <McManiaC> how can I turn two Word8 into one Word16?
03:04:09 <Axman6> fromIntegral
03:04:25 <Axman6> > fromIntegral (123 :: Word8) :: Word16
03:04:26 <lambdabot>   123
03:04:32 <Axman6> :t fromIntegral (123 :: Word8) :: Word16
03:04:33 <lambdabot> Word16
03:05:17 <Heffalump> McManiaC: so fromIntegral and shifting
03:05:56 <McManiaC> (`shiftL` 2) ?
03:06:01 <Axman6> shiftl16
03:06:10 <Axman6> uh, `shiftl` 16
03:07:18 <McManiaC> 8 :)
03:07:26 <Axman6> shiftl16uh, yes
03:07:28 <Axman6> whoops
03:07:30 <k23z__> uh hi
03:07:44 <McManiaC> > 0x8000 :: Word 16
03:07:45 <lambdabot>   Only unit numeric type pattern is valid
03:07:45 <Axman6>  let f x y = shiftl (g x) 8 .&. g y where g a = fromIntegral (a :: Word8) :: Word16 in f 1 1
03:07:46 <k23z__> how can I model morphisms in Haskell ? is there any package providing isomorphism,epimorphisms,monomorphisms ?
03:07:51 <Axman6> > let f x y = shiftl (g x) 8 .&. g y where g a = fromIntegral (a :: Word8) :: Word16 in f 1 1
03:07:52 <lambdabot>   Not in scope: `shiftl'
03:07:55 <k23z__> is htere any package dealing ith group theory ?
03:08:07 <Axman6> > let f x y = shiftL (g x) 8 .&. g y where g a = fromIntegral (a :: Word8) :: Word16 in f 1 1
03:08:08 <lambdabot>   0
03:08:18 <k23z__> is there any permutation group package ?
03:08:23 <Axman6> > let f x y = shiftL (g x) 8 .|. g y where g a = fromIntegral (a :: Word8) :: Word16 in f 1 1
03:08:24 <McManiaC> *Main Data.Bits Data.Word> 0x8000 :: Word16
03:08:24 <McManiaC> 32768
03:08:24 <lambdabot>   257
03:08:27 <McManiaC> *Main Data.Bits Data.Word> 0x80 `shiftL` 8 :: Word16
03:08:27 <McManiaC> 32768
03:08:28 <McManiaC> :)
03:08:30 <k23z__> is there a package for permutations viewed as mathematical objects ?
03:09:07 <k23z__> you know like the bijective functions from one finite set to itself(becuase that's what permutations are) ?
03:09:50 <Axman6> k23z__: too many questions too quickly
03:09:58 <Gracenotes> it's not so hard to code, actually.
03:10:00 <k23z__> Axman6: that is true
03:10:05 <Gracenotes> permutation groups and the like.
03:10:20 <Gracenotes> at least, doing so efficiently for relatively small permutation groups.
03:10:23 <k23z__> Gracenotes: well I wrote them in Perl and was trying to figgure out if Haskell would provide advantages for me
03:10:45 <Gracenotes> I think the rule is that if you have to enumerate every single permutation of a set, you lose
03:10:46 <k23z__> Gracenotes: yes I haven't tried to touch S_7 for example ... only working low in S_4 and S_5 ... stuff like that
03:10:56 <k23z__> Gracenotes: that's true there are too many
03:12:12 <Gracenotes> numeric-prelude is great for group-thing instances.. and, woot, http://hackage.haskell.org/package/numeric-prelude
03:12:30 <Gracenotes> well, the woot-y thing is http://hackage.haskell.org/packages/archive/numeric-prelude/0.1.3.4/doc/html/MathObj-Permutation-Table.html
03:12:45 * Axman6 has an idea for a GSoC project, but probably doesn't have the time, and its probably not the right sort of project, even if it would help out a lot of people :(
03:13:25 <SubStack> trick somebody else into doing it for you
03:13:38 <SubStack> by mentioning what it is
03:13:44 <Gracenotes> e.g., closure looks like it would take a set of permutations and expand it so ∘ satisfies group properties
03:14:12 <k23z__> Axman6: idea = ?
03:14:22 <k23z__> Axman6: would you mentor it  or .. ?
03:14:57 <Axman6> using something like the Gloss library to make an OpenGL frontend for Criterion
03:15:22 <Axman6> which would work on all platforms
03:15:57 <k23z__> what is gloss what is criterion
03:16:02 <k23z__> why would it be helpful
03:16:57 <Axman6> Gloss is a simple library for drawing using OpenGL
03:17:20 <Axman6> Criterion is bos' awesome benchmarking framework
03:18:38 <Axman6> which currently relies on using the Chart library, which needs Gtk2hs, which has problems on a few platforms, and is a pain to install
03:19:17 <k23z__> and you would mentor this right ?
03:20:48 <SubStack> I should really swap out the guts of my 3d simulations for reactive-glut
03:21:05 <Axman6> no, i'd be writing it
03:21:34 <jlouis> criterion could perhaps be coerced to output data in a format R or gnuplot like
03:21:52 <Twey> Axman6: Don't you think it would be more productive to make Gtk2Hs play nicely with other platforms?
03:22:00 <aavogt> is opengl really more portable than cairo?
03:22:03 <Twey> (probably less work, too)
03:22:20 <Twey> It is, after all, our primary GUI library at the moment.
03:22:26 <Axman6> aavogt: all OS's that ghc can be installed on have OpenGL
03:22:46 <Twey> They have GTK, too
03:23:18 <Axman6> does anyone actually use gtk on anything other than linux though?
03:23:32 <lilrayray> hey all quick question about lists/arrays: when you get the value of the list at a specific index, let's say "list!!10" does haskell internally traverse the list up to that point, or is the list indexed such that only a single operation is needed (I guess my question is, are there indexed arrays in haskell, or are they all internally implemented as a linked list, or something of the sort)?
03:23:35 <Axman6> gtk apps make it nowhere on OS X, and i can't imagine they do too well on windows either
03:23:38 <Twey> Axman6: Er, yes?
03:24:01 <Twey> Axman6: The GIMP is kind of a flagship app for GTK+, and that's used all over the place
03:24:04 <Twey> Firefox
03:24:08 <Axman6> lilrayray: they are linked lists. you can't have infinite indexed arrays ;)
03:24:14 <Twey> Y'know, little apps like these ;)
03:24:20 <aavogt> @docs Data.Array
03:24:20 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array.html
03:24:31 <aavogt> aww, it's outside of base
03:24:35 <Axman6> nice work naming some of the most hated apps of mine, and many many mac users ;)
03:24:41 <aavogt> http://haskell.org/ghc/docs/latest/html/libraries/array/Data-Array.html
03:25:19 <Twey> Axman6: That's just because Mac users enjoy paying through the nose for features they can get for free
03:25:23 <Twey> Axman6: It makes them feel secure :þ
03:25:41 <Axman6> no, mac users like apps that are easy to use, and not dog ugly
03:25:56 <aavogt> lilrayray: but perhaps your task doesn't actually need random access
03:26:23 <Saizan> does criterion have a machine readable output format for the data?
03:26:28 <Twey> Axman6: This from a platform that for a long time thought that covering everything with grey and white stripes was a good idea?  :þ
03:26:47 <Axman6> they haven't thought that for a very long time
03:26:53 <aavogt> Saizan: IIRC it can output csv
03:26:58 <Saizan> Axman6, Twey: move the flaming on -blah, thanks :)
03:27:42 <Twey> Wasn't the point, anyway — the point was that yes, GTK apps are used quite frequently on other platforms, no matter what the Mac elite may think of them :þ
03:28:10 <lilrayray> aavogt: Im trying to learn haskell, and so I thought writing a binary search would be good practice... but an indexed array is necessary
03:29:08 <Axman6> lilrayray: well use arrays then
03:29:42 <aavogt> if comparisons are very expensive, a binary search may actually be better than a linear search for linked lists
03:30:33 <aavogt> but anyways, if you're doing this for pedagogical purposes, performance is quite irrelevant?
03:30:36 <Jafet> Why you would ever want to repeatedly search on linked lists is another matter
03:31:25 <lilrayray> performance is neither important nor unimportant, rather irrelevant... its just for practice ^^
03:31:35 <lilrayray> but Ill look into Arrays, thanks
03:36:01 <Twey> Um, I think that implies unimportant.
03:37:00 <Jafet> import Performance;
03:37:21 <k23z__> lol is that really a lib ?
03:37:31 <Twey> Haha
03:41:17 <jlouis> import Performance.Dons is usually better
03:42:24 <mux> import Performance.Dons.LLVM.Genetic;
04:03:50 <Cale> Desustorm: I went to sleep there... It's possible to pattern match the result of splitAt using let or where, and then use the two parts to make a list however you might want :)
04:11:58 <k23z__> if I come here asking a lot of questions
04:12:04 <k23z__> will I be considered a "help vampire" ?
04:12:37 <dobblego> no, you'll just have to pay us a few dollars
04:12:46 <k23z__> :)
04:14:40 <Saizan> depends on the questions
04:16:30 <Dementati> k23z__: Everyone involved saves time if you google your questions before asking them here, and come here if that doesn't work.
04:17:48 <mux> bah, I always fail to remember the syntax for pattern guards in case expressions
04:18:21 <k23z__> but ... noone is forced to answer questions unless they want to
04:18:27 <Saizan> and if you're stuck with some type error or similar it's good to paste both code and error on a pastebin :)
04:18:41 <opqdonut> what are the type of binary search trees that have data in the leafs only called?
04:18:52 <opqdonut> and can anyone give any papers on balancing them?
04:19:13 <opqdonut> i'm thinking it should be a bit easier than with the usual binary trees
04:19:23 <Dementati> k23z__: No, but don't you agree with me?
04:19:43 <Twey> mux: x | ptn <- expr -> …
04:20:42 <Saizan> opqdonut: that sounds like a special case of finger trees
04:20:54 <opqdonut> yeah it kinda is
04:20:56 <mux> Twey: in case of expressions
04:21:03 <Twey> mux: Yes
04:21:12 <Twey> It's the same
04:21:15 <mux> I don't see any case of in your example
04:21:22 <opqdonut> I read some finger tree papers and came to the conclusion that the existing finger tree libs don't fit
04:21:23 <Twey> case foo of x | ptn <- expr -> …
04:21:44 <Saizan> no?
04:21:44 <Twey> I only included the actual case because it's all that's relevant…
04:21:50 <mux> erm
04:22:12 <stevenmarky> what's with your line endings twey
04:22:31 <mux> Twey: expr being a boolean expression?
04:22:42 <Axman6> stevenmarky: there's a good chance it's a problem with your client not supporting UTF-8 properly
04:22:52 <Axman6> test …
04:22:56 <stevenmarky> ah probably.
04:22:58 <opqdonut> Saizan: i'll try to remember the reason, just a sec
04:23:00 <mux> I've never seen something surrounded with <- ... ->, and that seems to give a syntax error
04:23:09 <Twey> mux: Er, no?  Being the expression whose value you want to match
04:23:16 <Twey> Really?  Hm
04:23:19 <Saizan> mux: PatternGuards are an extension
04:23:29 <Twey> Ah, yeah, you'll need to have it turned on
04:23:31 <Saizan> mux: maybe you were referring to simple guards?
04:23:45 <Saizan> the ones you have in haskell98
04:24:02 <mux> maybe - I was referring to that kind of stuff: case foo of Just x | test = bar | otherwise = baz
04:24:11 <Twey> Prelude> case () of () | Just x <- Just 3 -> x
04:24:12 <Twey> 3
04:24:23 <Twey> mux: That's not a pattern guard
04:24:39 <Twey> mux: You just need to remember to use -> instead of = in case expressions
04:24:58 <mux> and I still get a parse error with that very syntax
04:25:06 <k23z__> Dementati: well yes I do but I still may be labelled that way
04:25:07 <Saizan> which are just "case foo of ptn1 | cond1 -> body1 | cond2 -> body2; ptn2 | cond1 -> body1 ...
04:25:19 <k23z__> Dementati: and I think it would be wrong since noone is forced to answer anything
04:25:28 <mux> I want the guards attached to one pattern match, not to the whole case branch
04:25:43 <Saizan> they are attached to one pattern.
04:26:11 <Saizan> case foo of Just x | test -> bar | otherwise -> baz; Nothing -> quux
04:26:13 <Twey> > case Just 5 of Just x | x < 3 = "bar" | otherwise = "baz"
04:26:14 <lambdabot>   <no location info>: parse error on input `='
04:26:18 <Twey> Doesn't work
04:26:20 <mux> omg, I suck hard
04:26:22 <Twey> > case Just 5 of Just x | x < 3 -> "bar" | otherwise -> "baz"
04:26:23 <lambdabot>   "baz"
04:26:24 <Twey> Does work
04:26:35 <mux> my syntax was totally correct, I just had forgotten parens...
04:26:38 <Twey> Heh
04:27:42 <Dementati> k23z__: You will only be labelled as such if you ask questions people deem you can easily find out for yourself. It's up to you not to ask such questions.
04:27:42 <Saizan> k23z__: a big part of being a vampire is not making use of the documentations you might get pointed to when you ask something
04:28:13 <Dementati> k23z__: What Saizan said, too.
04:28:14 <opqdonut> Saizan: well, basically, I need random access lookups and insertions
04:28:55 <Twey> Hm, does \b have pattern guards?
04:29:01 <Saizan> opqdonut: that depends on the monoid you use, i thought
04:29:04 <Twey> > case () of () | Just x <- Just 3 -> x
04:29:05 <lambdabot>   3
04:29:09 <Twey> I guess so
04:29:18 <Twey> Odd that she doesn't have view patterns, then…
04:29:32 <opqdonut> Saizan: yeah for lookups, but I'm not aware of anybody doing insertions
04:30:56 <Saizan> opqdonut: i think that's meant to be done by split + append
04:31:07 <zachk> is let evil?
04:31:19 <Saizan> no, we love let
04:31:25 <jlouis> let is not evil
04:31:49 <zachk> uh is there a way of doing :t someFunction i input via lambdabot
04:31:56 <trofi> @let let = text "evil"
04:31:57 <lambdabot>   Parse error: KW_Let
04:31:58 <kamatsu> so, I learnt Scala today
04:32:05 <opqdonut> Saizan: ah I see
04:32:35 <opqdonut> but in any case, I don't need the fingers
04:32:49 <opqdonut> guess I'll just go with okasaki's rb-balancing
04:32:51 <Twey> kamatsu: Was it evil?
04:32:57 <kamatsu> Twey: It's  not actually that  bad
04:33:09 <kamatsu> Twey: although I think of it as  a nice Java rather than an evil Haskell
04:33:14 <Twey> Aha
04:33:24 <Saizan> zachk: you mean one defined with @let ?
04:33:50 <Twey> :t maybe
04:33:52 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
04:34:12 <Twey> :t \some function i -> "input"
04:34:13 <lambdabot> forall t t1 t2. t -> t1 -> t2 -> [Char]
04:34:28 <Twey> :t some function i = "input" in some
04:34:29 <lambdabot> parse error on input `='
04:34:31 <Twey> Oops
04:34:33 <Twey> :t let some function i = "input" in some
04:34:34 <lambdabot> forall t t1. t -> t1 -> [Char]
04:34:48 <zachk> :t bind f (a,s) = let (fa,fs) = f a in (fa,s++fs)
04:34:49 <lambdabot> parse error on input `='
04:35:01 <zachk> :-/
04:35:11 <Saizan>  :t accepts expressions
04:35:14 <Alpounet> @type (foldr (\(x,y) acc -> x:y:acc) [] .) . zip
04:35:15 <Saizan> not declarations
04:35:15 <lambdabot> forall t. [t] -> [t] -> [t]
04:35:15 <Twey> :t \f (a, s) -> let (fa, fs) = f a in (fa, s ++ fs)
04:35:16 <lambdabot> forall t t1 t2. (Monoid t1) => (t -> (t2, t1)) -> (t, t1) -> (t2, t1)
04:35:28 <Saizan> :t let bind f (a,s) = let (fa,fs) = f a in (fa,s++fs) in bind
04:35:29 <lambdabot> forall t t1 t2. (Monoid t2) => (t -> (t1, t2)) -> (t, t2) -> (t1, t2)
04:35:32 <Twey> That's using (++) = mappend, though
04:35:42 <Twey> :t \f (a, s) -> let (fa, fs) = f a in (fa, concat [s, fs])
04:35:43 <lambdabot> forall t t1 a. (t -> (t1, [a])) -> (t, [a]) -> (t1, [a])
04:35:52 <Twey> That's probably closer to the type you'd get with the usual ++
04:36:11 <zachk> yes
04:36:25 <zachk> and it confuses me, im trying to work through you could have invented monads
04:36:30 <Saizan> lambdabot likes abstractions
04:36:33 <bremner_> kamatsu: so what is it missing? laziness?
04:36:58 <Alpounet> > (foldr (\(x,y) acc -> x:y:acc) [] .) . zip $ ['h', 's', 'e', 'l'] ['a', 'k', 'l', '!']
04:36:59 <lambdabot>   Couldn't match expected type `t1 -> [t]'
04:36:59 <lambdabot>         against inferred type `[a]'
04:37:16 <Alpounet> > ((foldr (\(x,y) acc -> x:y:acc) [] .) . zip) ['h', 's', 'e', 'l'] ['a', 'k', 'l', '!']
04:37:17 <lambdabot>   "haskell!"
04:37:32 * hackagebot leksah-server 0.8.0.1 - Metadata collection for leksah  http://hackage.haskell.org/package/leksah-server-0.8.0.1 (JuergenNicklischFranken)
04:38:03 <zachk> but i thought :t bind would be something more like ((Int->(Int,String))->(Int,String)->((Int,String)->(Int,String))
04:38:19 <Alpounet> kamatsu, don't you find scala to miss ... just syntax clarity, readability ?
04:38:32 <zachk> what im basically asking is how is a function of two arguments type signature of one argument
04:44:38 * hackagebot leksah 0.8.0.1 - Haskell IDE written in Haskell  http://hackage.haskell.org/package/leksah-0.8.0.1 (JuergenNicklischFranken)
04:48:25 <kamatsu> bremner_: it basically still feels like Java
04:48:36 <kamatsu> Alpounet: I found scala to have a perfectly fine syntax
04:49:18 <Cale> I think scala's syntax is a little noisy.
04:49:35 <bremner_> kamatsu: how about clojure? I'm getting involved with a "languages on JVM" project and I'm curious what to push.  JRuby is the default if I don't push anything.
04:49:55 <kamatsu> bremner_: I would push scala over jruby
04:50:08 <kamatsu> I don't know Clojure, lispiness makes me shiver
04:50:44 <pookleblinky> http://www.haskell.org/pipermail/haskell-cafe/2009-June/063454.html
04:50:46 <Cale> Clojure actually looks pretty cool
04:50:50 <pookleblinky> Now that is a cool project.
04:50:52 <bremner_> (not (mind '(parens . I))
04:51:30 <Drk-Sd> bremner_: was that a joke? i don't get it :-°
04:51:50 <pookleblinky> Drk-Sd, he doesn't mind parentheses
04:52:14 <Drk-Sd> oh, ok.
04:52:22 <Cale> The lisp syntax is something that most people quickly get used to. It's mostly just important to have an editor which will nicely highlight which paren matches the one you typed.
04:52:35 <pookleblinky> Cale, because there essentially is no syntax.
04:52:36 <Drk-Sd> so parens was for parenthesis ok :-°
04:53:03 <pookleblinky> Lisp syntax really is whatever you need at the moment.
04:53:19 <Cale> (because they're all the same shape, whereas in most languages, you have a few different types of brackets)
04:54:14 <pookleblinky> (Not only that, but the heirarchical nature of a lisp program lends itself exactly to parsing (or indeed any application of recursion))
04:57:04 <Cale> One simple thing that clojure has which I'm a little jealous of from a Haskell perspective is the ability to apply finitemaps and sets as functions.
04:57:37 <Cale> The types would get a little hairy if we tried to do that.
04:57:59 <Jafet> How would a set be applied as a function? Membership predicate?
04:58:03 <Cale> yeah
04:58:57 <Jafet> Hm, I don't see anything wrong with emulateClojureMaps :: (SomeMap a b) -> a -> b
04:59:33 <Cale> Well, the important bit is the syntax there.
04:59:34 <ivanm> preflex: seen malcolmw
04:59:34 <preflex>  malcolmw was last seen on #haskell 1 day, 22 hours, 48 minutes and 59 seconds ago, saying: ivanm: yes, I nearly converted polyparse to have Applicative and Alternative, but there turns out to be a small technical problem
05:00:13 <Cale> You don't have to write anything extra to apply a finitemap as if it were a function, you just use it exactly like you would a function, and it behaves the right way.
05:02:31 <Saizan> it'd be funny to try to make juxtaposition a typeclass method and see what types you get :)
05:02:52 <bremner_> huh, jhc isn't in debian yet.
05:03:49 * maltem is going to dream a scary dream involving the type of composition of juxtaposition with dependent types
05:06:03 <Jafet> ... deriving (Function) -- *cough*
05:07:27 <Twey> Mmm, function typeclass
05:07:28 <aavogt>  instance Function k (M.Map k a) a where apply k m = m M.! k
05:08:04 <aavogt> with class Function a e r where apply :: a -> e -> r,  not sure what kind of fundeps might be convenient
05:08:32 <Cale> Probably at least a e -> r
05:08:44 <aavogt> it turns out that you can get pretty far with type inference only going forward, taking a look at HList
05:08:50 <maltem> Btw sometimes it bemuses me that in functional programming languages, we have to use functions to work with non-functional relations (set membership, finite maps)
05:09:21 <aavogt> which uses functions with only the fundep that cale metioned
05:10:09 <aavogt> is there some way to choose what kind of relation it should be based on the instances you have?
05:10:55 <aavogt> as in, if you only have one instance, there is only one degree of freedom in the type variables
05:11:08 <aavogt> more instances add more degrees of freedom
05:11:33 <Cale> Another thing which we really ought to have is a good library for general relations. Dr. Kahl at McMaster has a lot of cool stuff that I wish he would release.
05:12:00 <Cale> I remember he showed me his Data.Rel, which was quite awesome in terms of all the neat operations on relations it supported.
05:12:12 <Heffalump> how well type-checked was it?
05:13:13 <Cale> Well, nothing too incredibly fancy
05:13:16 <aavogt> hmm, mcmaster has haskell people?
05:13:36 <Cale> Just the domain and codomain types.
05:13:47 <Cale> aavogt: Quite a few of them, yes.
05:14:56 <maltem> Cale: Do you remember the underlying representation for relations that he uses?
05:15:04 <Cale> maltem: That I don't know.
05:15:16 <maltem> Pity, could have been interesting ;)
05:15:29 <Cale> maltem: But it seems to me that we should be able to do much better than Map a (Set b)
05:16:24 <e2bady> hi. Is it possible to include a haskellfunction in a java programm? I mean, it would be easier to program part of my work in haskell, but part is already done in java.. so is this possible?
05:16:35 <Cale> e2bady: hmm...
05:16:59 <Cale> e2bady: You can use the FFI to make the Haskell function available like a C library call.
05:17:22 <Cale> (together with the necessity of calling something to initialise the runtime system)
05:18:02 <Cale> e2bady: I think Java has something like JNI for interfacing with native code, so perhaps it's doable.
05:18:25 <Cale> It may be somewhat awkward, in terms of the marshalling, depending on what the interface you're thinking of looks like.
05:18:34 <e2bady> ok, that's promising...
05:19:08 <e2bady> well, it's a networked app. And I need to do some calculations which are much easier in haskell.
05:20:54 <e2bady> so the input I need to get from haskell is just a list of integers...
05:20:59 <Cale> http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffi.html -- this is what you'd want to read to learn about FFI in Haskell. It's technically the specification, but I found it was tutorial-like enough :)
05:21:01 <e2bady> well, thanks for your quick answer
05:21:10 <Cale> ah, hmm
05:21:22 <Cale> So you'll probably want to make that available as a C array
05:21:46 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/array/Data-Array-Storable.html
05:22:19 <aavogt> is there not a haskell-like language for JVM?
05:22:30 <bremner_> define "haskell-like"
05:22:41 <bremner_> lazy non-strict functional?
05:22:44 <Cale> aavogt: There's CAL
05:22:47 <aavogt> bremner_: looks like haskell
05:23:44 <Cale> er...
05:24:05 <Cale> At least I thought it was called CAL, perhaps I'm not remembering correctly.
05:25:27 <Cale> Hum, I'm not sure where it went.
05:26:27 <Cale> Apparently it used to be at http://labs.businessobjects.com/cal/ but that now redirects to a page which doesn't seem to mention it.
05:26:32 <psykotic> i think it's part of another project
05:26:53 <aavogt> Cale: I found this: http://en.wikipedia.org/wiki/Quark_Framework
05:30:08 <Cale> aavogt: Ah, okay :)
05:33:32 <e2bady> well I got my answer, it seems it is possible to make the calls needed from a java program. Thanks for your help it's appreciated.
05:33:45 <Cale> The syntax of CAL is unfortunately uglier than Haskell's syntax.
05:34:09 <psykotic> that is true for all languages :)
05:34:18 <e2bady> psychicist_: ack
05:34:18 <psykotic> haskell's syntax is a thing of beauty
05:34:23 <Cale> And you can tell from the examples that Java programmers are hanging around
05:34:23 <bremner_> forth has nice syntax
05:34:37 <aavogt> but which subset of haskell is pretty?
05:35:09 <Cale> map :: (a -> b) -> [a] -> [b];
05:35:09 <Cale> public map mapFunction !list =
05:35:09 <Cale>     case list of
05:35:09 <Cale>     []     -> [];
05:35:09 <Cale>     listHead : listTail ->
05:35:10 <Cale>         mapFunction listHead : map mapFunction listTail;
05:35:12 <Cale>     ;
05:35:32 <Cale> It's like my joke definition of map with the enterprisey function parameters
05:36:02 <aavogt> what's the exclamation mark for?
05:36:07 <Cale> I'm not sure.
05:36:08 <psykotic> swap (theFirstValue, theSecondValue) = (theSecondValue, theFirstValue)
05:36:13 <psykotic> is that enterprisey enough for you?
05:36:23 <Heffalump> Haskell's syntax is nice compared to most/all other languages, but it's still not perfect
05:36:38 <opqdonut> that ; that terminates the definition is horrible :D
05:37:02 <aavogt> swapValuesOfTheTuple (theFirstValueOfTheTuple, theSecondValueOfTheTuple) = (theSecondValueOfTheTuple, theFirstValueOfTheTuple)
05:37:24 <psykotic> cale: 'list' is too meaningless a name. it should 'aListOfElementsOfAnyType', you imbecile.
05:37:27 <poucet> theFirstValueOfTheTupleThatShouldBecomeTheSecondValueOfTheTuple
05:37:56 <poucet> psykotic: aListOfElementsOfAnyTypeThatMayBeEmpty
05:38:37 <aavogt> at least the convention for separating words is the same
05:38:45 <silver> it's long names time
05:38:46 <aavogt> *in a single identifier
05:38:47 <silver> no, dad, no
05:39:01 <poucet> are_you_sure?
05:41:02 <Axman6> one day, when i write a compiler, i shall have a function names functionToRenameTheNamesOfLongFunctionNamesToMakeThemShorterThanTheyWereBeforeRenamingThem
05:42:32 <Alpounet> Axman6, then you'll bootstrap your compiler :p
05:42:50 <Axman6> ues, and end up with f_247397x39
05:42:55 <Axman6> y*
05:43:30 <Alpounet> @vixen functionToRenameTheNamesOfLongFunctionNamesToMakeThemShorterThanTheyWereBeforeRenamingThem
05:43:31 <lambdabot> fun fun fun!
05:43:56 <Axman6> @elite functionToRenameTheNamesOfLongFunctionNamesToMakeThemShorterThanTheyWereBeforeRenamingThem
05:43:56 <lambdabot> fUn(7ION+oREN4m3tH3N4M3SOphLOnGFUnCTIonNa/\/\3z+O/\/\Ax3+hEMsh0r73RT|-|4nt|-|EyWer38Ef0Rer3n4/\/\iNG7H3/\/\
05:44:06 <Axman6> and... i have my renaming function :P
05:44:17 <Axman6> @. elite elite functionToRenameTheNamesOfLongFunctionNamesToMakeThemShorterThanTheyWereBeforeRenamingThem
05:44:18 <lambdabot> phuNC+ion7or3NAMe+h3nAM3s0f|ONgphuN(7i0NN4/\/\3Zt0/\/\AkeTh3/\/\$|-|Or+3RthANT|-|3Y\/\/ERe8Ef0ReR3N4miNg7H3/\/\
05:44:38 <Alpounet> haha
05:48:16 <aavogt> @fix
05:48:16 <lambdabot> Maybe you meant: bid faq ft id thx
05:57:52 <orlandu63> according to a tutorial, this function oddSquareSum = sum (takeWhile (<10000) (filter odd (map (^2) [1..]))) can be written, using function composition, as
05:57:58 <orlandu63> oddSquareSum = sum . takeWhile (<10000) . filter odd . map (^2) $ [1..]
05:58:22 <orlandu63> which i understand. but what is the $ doing there ( $ is the function applicator, i know)
05:58:55 <Lemmih> orlandu63: Do you see what the line would mean without it?
05:59:02 <orlandu63> i think so
05:59:05 <orlandu63> Lemmih: i think so
05:59:31 <cebewee> seems unnecessary in this case
05:59:46 <orlandu63> cebewee: yeah, that's what i thought. it seems wrong actually
06:00:03 <k23z__> you guys like morphisms ?
06:00:14 <cebewee> orlandu63: no, its just not needed
06:00:17 <k23z__> here be some morphisms for you   :) http://github.com/wsdookadr/Rubik-Perl/blob/master/lib/CM/Morphism.pm
06:00:34 <Lemmih> cebewee: It /is/ needed.
06:00:39 <orlandu63> Lemmih: why?
06:00:39 <Lemmih> > sum . takeWhile (<10000) . filter odd . map (^2) $ [1..]
06:00:40 <lambdabot>   166650
06:00:43 <Lemmih> > sum . takeWhile (<10000) . filter odd . map (^2) [1..]
06:00:44 <lambdabot>   No instance for (GHC.Enum.Enum [a])
06:00:44 <lambdabot>    arising from the arithmetic sequence...
06:00:53 <Lemmih> See why that happens?
06:01:15 <cebewee> Lemmih: you're right, my bad
06:01:16 <Lemmih> > (sum . takeWhile (<10000) . filter odd . map (^2)) [1..] -- This is what the '$' version is.
06:01:17 <lambdabot>   166650
06:01:18 <orlandu63> ohhh
06:01:20 <orlandu63> i se
06:01:22 <orlandu63> i see
06:01:43 <orlandu63> thanks guys
06:02:56 <Jafet> @precedence
06:02:56 <lambdabot> Unknown command, try @list
06:48:03 <fax> happy haskell day
06:49:22 <Absolute0> haskell was created today?
06:50:04 <MrGein> hi
06:50:12 <fax> hi
06:50:31 <MrGein> Can anyone help me with some easy haskell doubts?
06:50:35 <MrGein> Ive just started
06:50:37 <fax> I'll try
06:50:43 <MrGein> thanks!
06:51:05 <MrGein> my doubt is, how do i use the isDigit function?
06:51:13 <fax> well
06:51:14 <fax> :t isDigit
06:51:15 <lambdabot> Char -> Bool
06:51:17 <Lemmih> > isDigit '4' -- Like this
06:51:18 <lambdabot>   True
06:51:27 <MrGein> ahm
06:51:29 <Saizan> > isDigit 'a'
06:51:29 <Lemmih> > isDigit 'x' -- Or this.
06:51:30 <lambdabot>   False
06:51:30 <lambdabot>   False
06:51:40 <MrGein> could i use it string -> bool?
06:51:52 <Lemmih> > all isDigit "123"
06:51:53 <lambdabot>   True
06:51:55 <Lemmih> > all isDigit "123five"
06:51:56 <lambdabot>   False
06:51:58 <Stalafin> i dont see how fmap is different from map
06:52:09 <Saizan> Stalafin: it's more general
06:52:35 <Stalafin> Saizan: i have got this piece of code yesterday from Cale : http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=8540#a8540
06:52:53 <Stalafin> Saizan: as i see it, i could use map here, too
06:52:57 <Stalafin> couldnt i?
06:53:01 <Saizan> no
06:53:06 <sepp2k> Are there code snippets somewhere that I can drop into my .ghci file to get @hoogle- and @pl-like functionality in ghci?
06:53:27 <Stalafin> Saizan: why? because getContents returns an action?
06:53:31 <Saizan> Stalafin: because getContents :: IO String, so you're using IO's fmap there
06:53:48 <Stalafin> Saizan: but lines operates on lists, does it not?
06:53:51 <Saizan> ?type fmap :: (a -> b) -> IO a -> IO b
06:53:52 <lambdabot> forall a b. (a -> b) -> IO a -> IO b
06:54:04 <Saizan> Stalafin: sure, String is actually [Char]
06:54:24 <Stalafin> Saizan: so fmap knows what to do with lines and getcontents?
06:54:44 <Stalafin> ?type lines
06:54:45 <lambdabot> String -> [String]
06:54:48 <MrGein> I want the user to type in a string of digits, how would I call the function? example:  digits(n) = isDigit 'n'
06:54:59 <Saizan> Stalafin: "fmap :: (a -> b) -> IO a -> IO b" <- do you understand this type?
06:55:10 <MrGein> with digits:: string -> Bool
06:55:35 <Stalafin> Saizan: fmap takes a function a->b, and an a which is an IO, and returns me a b, which is a IO
06:56:00 <Saizan> Stalafin: "fmap takes a function a->b" is right
06:56:04 <nlogax> MrGein: digits = all isDigit
06:56:16 <MrGein> um?
06:56:27 <MrGein> I don't understand
06:56:30 <MrGein> ah
06:56:31 <MrGein> yes
06:56:38 <Saizan> Stalafin: "IO a" doesn't mean that a is an IO, it's rather the type of actions whose result is of type a
06:56:39 <nlogax> > let digits = all isDigit in digits "123"
06:56:40 <lambdabot>   True
06:57:39 <Stalafin> Saizan: would it be possible to use fmap instead of map?
06:57:39 <MrGein> digits :: String -> Bool
06:57:48 <Stalafin> Saizan: since you mentioned that fmap is more general?
06:57:59 <endojelly> by the way, how do you prove that something is *not* turing complete? I can imagine that it can be pretty tricky for a sufficiently complicated language?
06:58:06 <Saizan> Stalafin: yes, you can always use fmap instead of map
06:58:20 <MrGein> digits :: String -> Bool "1st line" digits = all isDigit "2nd line" compiles ok but how do i put the digits in???
06:58:24 <Saizan> Stalafin: since map is fmap specialized to the list functor
06:58:44 <Stalafin> Saizan: so IO does not mean input/output? it's just - some random action producing a
06:59:24 <Saizan> Stalafin: not every IO action actually does input/output when executed
06:59:47 <nlogax> MrGein: have a look at getLine
07:00:02 <Saizan> Stalafin: however fmap for lists and fmap for IO are not implemented in the same way
07:00:06 <Stalafin> Saizan: so i map is fmap specialized to the list functor, what would be IO in case of map?
07:00:13 <Stalafin> if*
07:00:14 <Saizan> Stalafin: fmap is overloaded via typeclasses
07:00:33 * hackagebot data-category 0.0.2 - Restricted categories  http://hackage.haskell.org/package/data-category-0.0.2 (SjoerdVisscher)
07:00:56 <Saizan> Stalafin: you can specialize fmap to the list functor _OR_ to the IO functor
07:01:05 <maltem> Stalafin, IO does and does not mean input/output, but the important thing to realize is that a value of type "IO a" is, first and foremost, a value of type IO a (which parses as IO applied to a)
07:01:31 <Stalafin> hmhmhm, i see
07:01:34 <Saizan> Stalafin: i think you need to read about typeclasses to understand this properly
07:01:49 <Saizan> ?type fmap
07:01:50 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:02:36 <Saizan> fmap works for any Functor, but what it does is different for everyone of them, because typeclasses let you define it specifically
07:03:16 <Saizan> e.g. instance Functor [] where fmap f xs = map f xs; instance Functor Maybe where fmap f (Just x) = Just (f x); fmap f Nothing = Nothing
07:06:45 <Ke> !pl \a -> ((), id a)
07:07:24 <Ke> @pl \a -> ((), id a)
07:07:24 <lambdabot> (,) ()
07:07:36 <Ke> heh
07:12:06 <Ke> so RealWorld can't be extracted so (,) () would be IO
07:12:09 <Ke> ?
07:12:16 <Ke> or IO ()
07:12:49 <Saizan> ?
07:13:50 <fax> @src RealWorld
07:13:50 <lambdabot> Source not found. That's something I cannot allow to happen.
07:13:52 <Entroacceptor> # compose key
07:13:52 <Entroacceptor> xmodmap -e 'keysym Menu = Multi_key' &
07:13:52 <Entroacceptor> # the key is great, the function not so...
07:13:52 <Entroacceptor> xmodmap -e "remove lock = Caps_Lock" &
07:13:55 <fax> @src IO
07:13:55 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
07:14:00 <Entroacceptor> whoooops, sorry
07:14:23 <Entroacceptor> what I meant to past was http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23962#a23962
07:14:27 <Entroacceptor> this is driving me mad
07:15:31 <Saizan> Entroacceptor: use -v
07:16:29 <Axman6> fax: the source for RealWorld is just: data RealWorld (equivalent to data RealWorld = RealWorld)
07:17:42 <Feuerbach1> Axman6: why are they equivalent?
07:17:54 <Axman6> the former is shorthand for the latter
07:18:01 <Feuerbach1> afaik "data RealWorld" declares an empty type
07:18:13 <Saizan> yeah, no constructor gets defined
07:18:37 <ben> data Foo has one value, undefined. data Foo = Foo has undefined and Foo
07:19:07 <Axman6> Saizan: really? i thought it defined a constructor. guess i misunderstood
07:19:14 <Saizan> really :)
07:19:40 <Axman6> how interesting, SPARC defines tagged add and subtract instructions
07:22:51 * hackagebot leksah-server 0.8.0.2 - Metadata collection for leksah  http://hackage.haskell.org/package/leksah-server-0.8.0.2 (JuergenNicklischFranken)
07:38:05 * hackagebot huffman 1.0.0 - Pure Haskell implementation of the Huffman encoding algorithm  http://hackage.haskell.org/package/huffman-1.0.0 (MaximeHenrion)
07:44:09 * hackagebot haddock 2.7.0 - A documentation-generation tool for Haskell libraries  http://hackage.haskell.org/package/haddock-2.7.0 (DavidWaern)
07:44:42 <jlouis> Axman6: yup
07:45:12 <Axman6> seems quite handy for GHC on SPARC
07:50:18 <fax> > let b x y = (x*x+y*y+x+2*x*y+3*y)`div`2 in liftM2 b [1..3] [1..3]
07:50:19 <lambdabot>   [4,8,13,7,12,18,11,17,24]
07:51:10 * fax wonders how to invert this
07:51:18 <fax> (apparently it's bijective)
07:53:11 <fax> > let b x y = (x*x+y*y+x+2*x*y+3*y)`div`2 in liftM2 b [0..7] [0..7]
07:53:12 <lambdabot>   [0,2,5,9,14,20,27,35,1,4,8,13,19,26,34,43,3,7,12,18,25,33,42,52,6,11,17,24,...
07:54:29 <fax> I wonder how this bijection was found in the first place
07:55:26 <yitz> fax: it
07:55:34 <yitz> 's a conic section.
07:55:45 <yitz> apparently an ellipse
07:56:03 <yitz> fax: small enough piece to be bijective, i guess
07:56:52 <jlouis> Axman6: I'm having fun looking at performance profiles... decoding of messages is less than 2% :)
07:56:53 <yitz> ah, backwards. B^2-AC positive is a hyperbole
07:57:07 <Axman6> jlouis: hoorah :D
07:57:29 <Axman6> jlouis: i might give attoparsec a try sometime, see how it performs
07:57:30 <jlouis> Axman6: CML is more expensive than that
07:57:40 <Axman6> CML?
07:57:46 <jlouis> concurrency library
07:58:20 <yitz> *hyperbola
07:58:25 <Axman6> ah
07:58:26 * yitz is going to take a nap
07:59:03 <jlouis> Axman6: it is not that alarming though. It is around 10%... sha1 wins by far :P
07:59:16 <Axman6> jlouis: any idea how hard it would be to move to some more traditional concurrency stuff? like MVars and Chans?
07:59:33 <Axman6> yeah, a better sha1 is needed
07:59:56 <danderson> Axman6: attoparsec performs very well indeed
08:00:04 <danderson> ridiculously fast
08:00:05 <yitz> fax: wikipedia: if B2 − 4AC = 0, the equation represents a parabola;
08:00:33 <Axman6> yeah, but it might be lacking some important features to get that speed
08:00:46 <fax> yitz, but it's in two variables
08:01:03 <yitz> fax: it's rotated
08:01:38 <int-e> > [(x*x+y*y+x+2*x*y+3*y)`div`2 | xpy <- [0..], y <- [0..xpy], let x = xpy - y]
08:01:39 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
08:01:46 <Axman6> oh ffs! what the hell is wrong with HXT?
08:02:02 <Twey> Axman6: ?
08:02:14 <Axman6> i keep getting this error everytime i try and install anything with cabal-install
08:02:16 <Axman6> Users/Axman/.ghc/i386-darwin-6.12.1/package.conf.d/hsx-0.6.2-bfafe41a38b59dcaacc6d2cba8458df1.conf:
08:02:19 <Axman6> hGetContents: invalid argument (invalid UTF-8 byte sequence)
08:02:39 <Axman6> renaming that file, and reinstalling hxt seems to work for a little while, but then it dies again
08:03:08 <int-e> fax: it can be written as C(x+y+1, 2) + C(y, 1) where C is the binomial coefficient. Note that x+y+1 > y >= 0
08:04:10 * Axman6 is considering nuking his whole cabal-installed library of packages
08:04:41 <jlouis> Axman6: heh, it is MVars and ForkIOs and Chans underneath
08:04:43 <Saizan> Axman6: does it have non-ascii characters in them?
08:04:56 <Axman6> Saizan: does what?
08:04:56 <Saizan> s/them/it/
08:05:10 <Saizan> Axman6: Users/Axman/.ghc/i386-darwin-6.12.1/package.conf.d/hsx-0.6.2-bfafe41a38b59dcaacc6d2cba8458df1.conf
08:05:22 <fax> C(y,1) = y/(y-1) ?
08:05:22 <jlouis> Axman6: it would make sense to push-back to some lower level MVar/STM constructions if it ever becomes the bottleneck at places
08:05:39 <Axman6> Saizan: not sure, how would i tell?
08:05:55 <fax> no, C(y,1) = y
08:06:07 <int-e> fax: the interesting bit about that representation is that it generalises nicely. You can use C(x+y+z+2, 3) + C(y+z+1, 2) + C(z, 1) for three nonnegative variables, and so on.
08:06:19 <Saizan> Axman6: looking at it in a text editor, i guess
08:06:44 <Axman6> author: Niklas Broberg, Joel Björnson
08:06:46 <Axman6> possibly
08:06:55 <Arnar> how do I remove a cabal package completely? I did ghc-pkg but its (happstack's) stupid dependencies are blocking other things till
08:07:00 <Arnar> s/till/still
08:07:22 <Twey> Axman6: Oh, yeah — you need to fix the encoding of that file
08:07:25 <Axman6> heh, changing the ö to an o seems to have fixed it
08:07:35 <Twey> You can keep it as ö
08:07:41 <Twey> Just remember to save as UTF-8
08:08:11 * Axman6 always uses UTF-8
08:08:21 <Twey> iconv -t utf8 Users/Axman/.ghc/i386-darwin-6.12.1/package.conf.d/hsx-0.6.2-bfafe41a38b59dcaacc6d2cba8458df1.conf
08:08:24 <fax> int-e, does this representation show why it's bijectiev?
08:08:25 * Alpounet too
08:08:49 <Saizan> Axman6: http://hackage.haskell.org/trac/hackage/ticket/609 -- it seems it got fixed at some point
08:08:55 <Twey> Yeah, but Björnson doesn't, it seems
08:09:10 <Axman6> Saizan: well, i've updated it a few times, and the problem keeps coming back
08:09:17 <Twey> I don't dare update anything via Cabal until my computing project is done
08:09:26 <Saizan> Axman6: it got fixed in Cabal/ghc not in hxt
08:09:34 <Twey> It was such a nightmare getting the damn thing to work the first time, I don't want to make it angry with me
08:09:34 <Axman6> hmm, ok
08:09:49 <Stalafin>  /join vimperator
08:10:33 <int-e> fax: the sum of C(i,k) for i from 0 to n is C(n+1, k+1)
08:10:58 <Saizan> Arnar: there's no command to automatically unregister all the dependencies of a package, if that's what you're asking
08:11:24 <Arnar> Saizan: now, I know what package(s) I want to remove.. and I already unregistered them
08:11:40 <Stalafin> i fail to undersrtand, how dataLine knows which object it has to operate on; it's being called by in the main on the list cs, but why don't we pass cd to dataLine like so: dataLine cs = ... ?
08:11:47 <Arnar> Saizan: but cabal still won't get quickheck 2 because that pkg requires <2
08:12:00 <Stalafin> err
08:12:02 <Axman6> hmm.... wtf? just installed attoparsec, and i can't load any of its modules into ghci. they don't appear in the list fo possibilities when i try and import Data.A<tab>
08:12:06 <Stalafin> http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=8540 here is the definition
08:12:12 <Arnar> is there some "rehash" command I need to run or something?
08:12:15 <Saizan> Axman6: did you restart ghci?
08:12:18 <Axman6> yes
08:12:50 <int-e> fax: Approaching it from a different angle, C(n+k-1, k) is the number of partitions of n into k non-negative numbers.
08:12:57 <Saizan> Arnar: in ghc-6.12+ ghc-pkg has recache but i don't think this is your problem
08:13:13 <Saizan> Arnar: what are you trying to install and what error do you get?
08:13:29 <fax> hmm
08:13:52 <fax> so we are partitioning n into 2 non-negative numbers
08:14:26 <Stalafin> rephrasing my question earlier: http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=8540 here is a function dataLine defined, which is called in main; i don't see, how dataLine knows what to operate on; i was under the impression, that we have to pass it some value; or am i mistaken?
08:15:13 <Saizan> Stalafin: dataLine describes a parser
08:15:31 <Saizan> Stalafin: which is then converted into a function by readP_to_S
08:15:53 <Saizan> Stalafin: and only at that point it expects to be given a String as input
08:16:03 <Stalafin> oh
08:16:21 <Stalafin> Saizan: how complicated; ok, thanks :)
08:17:02 <Saizan> it actually makes things simpler, because you don't have to pass the input yourself to the parsers you use to compose dataLine
08:17:23 <fax> I don't really see this
08:17:36 <Axman6> can someone else try running a cabal install attoparsec; ghci -> :m +Data.Attoparsec?
08:18:06 <Saizan> Axman6: does ghc-pkg list attoparsec gives you something?
08:18:20 <Stalafin> Saizan: could you maybe explain the other things to me, too? after dataLine gets a string, it returns a tuple; but if one then calls take 1 on that tuple, how does that work?
08:18:23 <Saizan> works here, btw
08:18:35 <Axman6> yes, both 0.7.2 and 0.8.0.0
08:19:08 <Saizan> ?type readP_to_S
08:19:09 <lambdabot> Not in scope: `readP_to_S'
08:19:15 <Saizan> ?hoogle readP_to_S
08:19:15 <lambdabot> Text.ParserCombinators.ReadP readP_to_S :: ReadP a -> ReadS a
08:19:22 <Saizan> :hoogle ReadS
08:19:25 <Saizan> ?hoogle ReadS
08:19:25 <lambdabot> Prelude type ReadS a = String -> [(a, String)]
08:19:25 <lambdabot> Text.Read type ReadS a = String -> [(a, String)]
08:19:25 <lambdabot> Text.ParserCombinators.ReadP type ReadS a = String -> [(a, String)]
08:19:36 <jlouis> Axman6: works fine fine here
08:19:44 <Axman6> urgh
08:19:51 <jlouis> 0.7.2
08:19:58 <Saizan> Stalafin: readP_to_S dataLine :: String -> [((Char, Integer, Integer, Integer, String), String)]
08:19:58 <Axman6> what about 0
08:20:04 <Axman6> 0.8.0.0*?
08:20:26 <Axman6> Saizan: what a horrible type >_<
08:20:37 <Saizan> Axman6: what error do you get, btw?
08:20:38 <int-e> fax: hrm, that last bit was wrong. it should be C(n+k-1, k-1)
08:20:45 <Saizan> Axman6: and try ghc-pkg check
08:20:52 <Axman6> that the module doesn't exist
08:21:28 <jlouis> Axman6: also works fine
08:21:30 <Axman6> well, ghc-pkg check mentiones lots of problems, but none to do with attoparsec
08:21:40 <Saizan> Stalafin: it returns a list of possible results paired with the non-consumed input
08:21:53 <int-e> fax:  C(n+k-1, k) is what you get for the sum of C(j+k-1, k-1) for j=0 to n-1, i.e. for the number of partitions of the numbers less than n into k parts.
08:22:11 <Saizan> Stalafin: so the take 1 is getting just the first result, if there's one
08:22:32 <byorgey> fax, int-e: it's equal to  C(x+y+1,2) - x - 1, not C(x+y+1,2) + y.
08:25:37 <Stalafin> Saizan: cool, thanks!
08:25:57 <int-e> byorgey: huh? C(x+y+1,2) + C(y,1) = (x+y+1)(x+y)/2 + y = (x*x+y*y+x+2*x*y+3*y)/2
08:26:27 <byorgey> oh! sorry, off by one error on my part
08:26:45 <byorgey> it's  C(x+y+2,2) - x - 1
08:26:51 <byorgey> and also what you said =)
08:27:37 <fax> wait  C(x+y+2,2) - (x + 1) = C(x+y+1,2) + y  ?
08:27:43 <fax> that doesn't look right!
08:28:25 <int-e> C(x+y+2,2) = C(x+y+1,2) + C(x+y+1,1) = C(x+y+1,2) + x+y+1
08:28:37 <fax> aha
08:32:37 <int-e> fax: For what it's worth, you can split the construction into two tricks. One, you can encode sorted triples a > b > c >= 0 as C(a,3) + C(b,2) + C(c,1). Secondly, you can turn unsorted triples (x,y,z) >= 0 into sorted ones x+y+z+2 > y+z+1 > z >= 0, and that mapping is bijective.
08:34:04 <byorgey> aha, clever!  But this works not just for triples, but for any length tuple, no?
08:34:18 <int-e> right
08:34:23 * fax doesn't understand that bit yet... processing
08:34:51 <byorgey> the fact that the mapping from a > b > c >= 0 to C(a,3) + C(b,2) + C(c,1) is bijective is the non-obvious part.
08:35:19 <byorgey> at least, it isn't sufficiently obvious to me =)
08:35:30 <fax> I know tat a >= 0, C(a,1) is bijective :) .. not sure about a > b >= 0, C(a,2) + C(b,1) yet
08:37:39 <Axman6> any chance this could be moved to -blah?
08:38:52 <byorgey> sure, sorry
08:39:03 <int-e> fax: you enumerate the tuples in lexicographic order. (0,0) is mapped to 0. (1,0) to 1, (1,1) to 2. The point is that C(a,2) is exactly the number of tuples (a', b') such that a > a' > b' >= 0.
08:39:33 <fax> int-e, let me just scribble that on a bit of paper and see if it makes sense...
08:41:03 <int-e> (which are the tuples preceding (a,0) lexicographically)
08:41:43 <Arnar> Saizan: sorry, had to leave for a moment. I'm trying to install gitit, which requires QuickCheck 2.*, and happstack 0.4.1 is in the way (and I don't need it) since it requires qc < 2
08:42:41 <Arnar> Saizan: and the error I get is simply that datetime-0.2 (a dependency of gitit) cannot be configured because of this conflict
08:42:46 <fax> int-e oh yeah of course! it's triangular numbers
08:42:57 <Arnar> but I have unregistered all happstack related pkgs, and they don't show up in ghc-pkg list anymore
08:43:17 <Arnar> but cabal is still trying to respect their dependencies
08:43:46 <Saizan> Arnar: gitit needs happstack, afaiu
08:44:08 <fax> wow that is so nice
08:44:24 <Saizan> Arnar: gitit depends on happstack-server
08:48:38 <Saizan> Arnar: use cabal install gitit --constraint="datetime == 0.1"
08:55:14 <shapr> Igloo: Yes, remove me from admins, I haven't gotten around to doing anything.
08:57:26 <jlouis> boing!
08:57:40 <shapr> hiya jlouis!
09:12:33 <manjunaths> hello
09:12:42 <manjunaths> how do I convert an int to Double ?
09:12:53 <Vitka> fromIntegral
09:13:06 <monochrom> @quote fromIntegral
09:13:06 <lambdabot> <kmc> says: head [] = peek . intPtrToPtr . fromIntegral . unsafePerformIO . randomRIO $ (0, 2^32)
09:13:07 <byorgey> @quote fromIntegral
09:13:07 <lambdabot> <kmc> says: head [] = peek . intPtrToPtr . fromIntegral . unsafePerformIO . randomRIO $ (0, 2^32)
09:13:13 <monochrom> @quote monochrom fromIntegral
09:13:13 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
09:13:21 <Vitka> > fromIntegral 1 :: Double
09:13:22 <lambdabot>   1.0
09:14:32 <drk-sd> :D
09:14:50 <drk-sd> why is that function named so monochrom ?
09:15:18 <Vitka> BTW, can anyone help me with parser? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23964
09:15:34 <manjunaths> it is not working
09:15:35 <Arnar> Saizan: thanks!
09:15:38 <monochrom> because the parameter is an instance of Integral
09:15:39 <jlouis> drk-sd: because it converts from any type from the Integral type class
09:15:55 <drk-sd> hum
09:16:02 <drk-sd> ok there's an Integral type class x)
09:16:11 <jlouis> :t fromIntegral
09:16:12 <lambdabot> forall a b. (Integral a, Num b) => a -> b
09:16:21 <Saizan> Vitka: what's the problem?
09:16:31 <Vitka> I seem to be able use single monad properly, but when it comes to several at once... Like Parser and Maybe in this case.
09:16:42 <jlouis> drk-sd: most integer-like types are instances of Integral, so it works for almost anything
09:17:03 <Cale> Vitka: The fact that Maybe is a monad is irrelevant here
09:17:15 <jlouis> drk-sd: fwiw, realToFrac is the cousin of fromIntegral
09:17:17 <manjunaths> weird, sorry it did work
09:17:26 <drk-sd> jlouis: :D
09:17:27 <Saizan> you might use a function MonadPlus m => Maybe a -> m a
09:17:52 <drk-sd> i never heard of Integral before :-°
09:17:54 <Cale> Perhaps you meant to use f s = maybe undefined id (ptime s) ?
09:17:56 <drk-sd> only Num
09:17:59 <Cale> er...
09:18:01 <Cale> yeah
09:18:14 <Cale> Which is the same as f s = fromJust s
09:18:39 <Saizan> f s = fromJust (ptime s)
09:18:40 <Cale> Well, f s = fromJust (ptime s), rather
09:18:41 <Cale> yeah
09:19:15 <Vitka> Perhaps. I'll try. Is there any way to get ParseError or something in place of undefined?
09:19:22 <Saizan> yes
09:19:35 <Saizan> but you've to change p too
09:19:56 <Vitka> I'm trying to condense it all into one nice p.
09:20:03 <Cale> You could use something like  f s = maybe mzero return (ptime s), and then in p, change  return $ f t  to  f t
09:20:16 <Saizan> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23964#a23965
09:20:39 <Saizan> (you might need to import Control.Monad if you didn't already)
09:21:28 <Vitka> ...I guess I don't understand monads afterall.
09:22:09 <Saizan> well, here you're just constructing a Parser out of a Maybe value, you're not using the fact that Maybe is a monad
09:22:28 <Saizan> though you're using the fact that Parser is a MonadPlus
09:22:53 <Vitka> So I should read up on MonadPlus?
09:24:51 <Saizan> @src MonadPlus
09:24:51 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
09:25:20 <Saizan> it'd be a good thing, maybe looking it up in the typeclassopedia
09:25:32 <Saizan> however for Parser you've that mzero = pfail
09:25:46 <mreh> @src msum
09:25:47 <lambdabot> msum =  foldr mplus mzero
09:25:54 <mreh> @src mplus
09:25:55 <lambdabot> Source not found.
09:26:20 <Saizan> Vitka: so you can actually ignore MonadPlus and just use the Parser specific combinator
09:28:23 <Vitka> pfail one?
09:28:44 <mreh> @src mzero :: Maybe
09:28:44 <lambdabot> Source not found. :(
09:29:01 <Saizan> Vitka: yeah, pfail
09:29:07 <mreh> @instances MonadPlus
09:29:07 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
09:29:09 <Saizan> @src Maybe mzero
09:29:09 <lambdabot> mzero = Nothing
09:29:21 <mreh> mplus for Maybe seems like a waste of time
09:29:24 <mreh> @src Maybe mplus
09:29:24 <lambdabot> Nothing `mplus` ys = ys
09:29:24 <lambdabot> xs      `mplus` ys = xs
09:29:28 <Vitka> Thanks.
09:29:32 <mreh> oh.
09:29:58 <mreh> > msum [Nothing, Just 14, Just 17]
09:29:59 <lambdabot>   Just 14
09:30:38 <monochrom> mreh: http://www.haskell.org/haskellwiki/Dynamic_programming_example has a convincing example of mplus.
09:31:51 <mreh> dynamic programming is one of those things that I have not invested any time into finding out what it is, mostly because its name frightens me
09:32:02 <mreh> e.g. Support Vector Machine
09:32:10 <mreh> the name alone strikes terror into me
09:32:25 <monochrom> e.g. Gonads
09:33:02 <mreh> eep
09:34:56 <mreh> where else can I apply for a job in machine learning...
09:35:13 <mreh> and has offices in UK&Ireland/East Europe
09:35:20 <mreh> Western Europe*
09:35:40 <mreh> interview technique fail
09:36:00 <Vitka> pfail seems to be exported separately from Parsec? Does the latter has its own variant?
09:36:29 <Vitka> Ah.
09:36:38 <Vitka> pzero probably.
09:41:18 <Saizan> ah, maybe it's pzero
09:41:29 <Saizan> it's ReadP that has pfail
09:42:39 <hasenov> hello, how can I use import modules from other directories in ghc? for some reason the "-i" option does not work for me
09:45:07 <Cale> hasenov: Well, the normal way is to build the path into the module name.
09:45:22 <Cale> So that module A.B.C is located in A/B/C.hs
09:45:50 <Cale> hasenov: istr there was an option to get GHC to look in more directories, but I've never used it
09:46:01 <Twey> -L IIRC
09:46:05 <hasenov> so I use "ghci -i~/A foo.hs", when I have
09:46:15 <Cale> Right, that's it, -L
09:46:43 <Cale> Normally you want to name your .hs files after the modules, in matching case.
09:46:50 <Cale> and let ghc find them automatically
09:47:21 <Cale> I think you can also pass them all on the commandline too.
09:47:46 <hasenov> "import A.foo" that is in the directory ~/B
09:48:30 <Cale> Module names are required to start with an uppercase letter, afaik.
09:48:33 <Stalafin> is there an easy way to strip all white spaces in a string for something like: "  foo" or "  foo " ?
09:48:48 <mauke> filter (not . isSpace)
09:49:04 <hasenov> yeah Cale, my bad, it is actually uppercase, I can try using -L instead
09:49:05 <Twey> > filter (not . isSpace) "   f  oo  "
09:49:05 <mauke> warning: that's only what you asked for, not what you wanted
09:49:06 <lambdabot>   "foo"
09:49:08 <int-e> (isSpace is in Data.Char)
09:49:30 <Stalafin> mauke: indeed; only at the beginning or at the end
09:49:32 <Cale> > unwords . words $ "   f  oo  "
09:49:33 <lambdabot>   "f oo"
09:49:37 <Cale> another option
09:49:39 <chrisdone> where have I likely seen syntax to import names from modules as something else e.g. import Data.List (groupBy as groupBy')
09:49:53 <Cale> (it compresses multiple spaces in the middle and strips from beginning and end
09:49:54 <Cale> )
09:49:55 <chrisdone> is it a hugs extension maybe? or old haskell?
09:50:14 <Stalafin> Cale: that is a pretty thingy
09:50:15 <Vitka> @undo do {t <- inbrackets $ many1 $ noneOf "]"  ; maybe pzero return (parseTime defaultTimeLocale "%d/%b/%Y:%T %z" t :: Maybe UTCTime) }
09:50:15 <lambdabot> inbrackets $ many1 $ noneOf "]" >>= \ t -> maybe pzero return (parseTime defaultTimeLocale "%d/%b/%Y:%T %z" t :: Maybe UTCTime)
09:50:16 <Twey> > let f = reverse . dropWhile (not . isSpace) in f . f $ "   f  oo   "
09:50:18 <lambdabot>   "   f  oo   "
09:50:21 <Twey> Oops
09:50:24 <Twey> > let f = reverse . dropWhile isSpace in f . f $ "   f  oo   "
09:50:25 <lambdabot>   "f  oo"
09:50:26 <Cale> > let f = dropWhile isSpace . reverse in f . f $ "      f    oo    "
09:50:28 <lambdabot>   "f    oo"
09:50:31 <int-e> > join (.) (dropWhile isSpace . reverse) "  f ooo   "
09:50:32 <lambdabot>   "f ooo"
09:50:41 <Cale> wow, almost identical programs :)
09:50:49 <Vitka> @pl  \ t -> maybe pzero return (parseTime defaultTimeLocale "%d/%b/%Y:%T %z" t :: Maybe UTCTime)
09:50:50 <lambdabot> maybe pzero return . (:: Maybe UTCTime) . parseTime defaultTimeLocale "%d/%b/%Y:%T %z"
09:50:59 <benmachine> hah
09:51:22 <Cale> The @pl plugin doesn't know about types
09:51:23 <benmachine> someone should give @pl support for `asTypeOf`
09:51:36 <Cale> (at all)
09:51:43 <int-e> join (.) f = (!! 2) . iterate f
09:51:46 <Cale> It uses an untyped lambda calculus
09:51:57 <benmachine> or, someone should give haskell support for sections on :: :P
09:51:58 <Cale> @pl \x -> x x
09:51:58 <lambdabot> join id
09:52:05 <chrisdone> sorry. I think it was `renaming'. where have I seen that module import syntax?
09:52:32 <benmachine> (:: t) = id :: t -> t
09:52:54 <int-e> @src asTypeOf
09:52:54 <lambdabot> asTypeOf = const
09:53:02 <benmachine> @type asTypeOf
09:53:03 <lambdabot> forall a. a -> a -> a
09:53:07 <Cale> chrisdone: I don't think you can rename the actual values when you import a module in any version of Haskell that I know.
09:53:26 <Cale> chrisdone: You can however choose the module qualification to use
09:53:33 <Cale> import qualified Foo as Bar
09:54:22 <chrisdone> Cale: I swear I've seen some code to do it before... it was renaming of symbols. it's hard to google
09:54:58 <monadic_kid> chrisdone: you must be thinking about aliasing modules names
09:55:26 <monadic_kid> chrisdone: "qualifed as"
09:56:12 <Stalafin> Cale: whyy do you even need a $ in unwords . words $ "   f  oo  " ? if we were to write unwords . words "  f oo ", wouldn't that mean unwords ( words " f oo ") ? wouldn't that be just fine?
09:56:24 <chrisdone> Cale: found it! wow, this is *old.* 1991: http://www.cse.unsw.edu.au/~dons/haskell-1990-2000/msg00411.html
09:56:30 <chrisdone> import PreludeComplex(Complex(:+)) renaming :+ as :+:
09:56:35 <chrisdone> was probably never standard Haskell
09:56:37 <manjunaths> is there a map equivalent of Data.Array ?
09:56:48 <mauke> Stalafin: no, f . g x is not f (g x), it's f . (g x)
09:57:04 <monadic_kid> chrisdone: or just "as" if you don't want qualified imports
09:57:13 <mauke> Stalafin: (f . g) x is f (g x), though
09:57:18 <hasenov> omg, i figured out what it was, ghc does not correctly resolve ~ into the home directory
09:57:19 <monadic_kid> chrisdone: you can only alias module names
09:57:36 <mauke> wait, what
09:57:39 <chrisdone> monadic_kid: I'm not talking about aliasing modules
09:57:42 <mauke> programs are not supposed to resolve ~
09:57:54 <Stalafin> mauke: ah, ok... so f. g $ x == (f . g) x == f ( g x) ?
09:58:03 <hasenov> i guess that makes sense since in windows there is no ~ alias
09:58:07 <mauke> Stalafin: yes, because $ has very low precedence
09:58:17 <Stalafin> funky
09:58:30 <hasenov> mauke: i was using ~ in the "-i" option of ghc
09:58:41 <mreh> :t mergeBy
09:58:42 <lambdabot> Not in scope: `mergeBy'
09:58:47 <mauke> hasenov: doesn't matter, your shell does ~ expansion, not ghc
10:01:57 <chrisdone> it's intruiging reading old email archives discussing the early stages of an established programming language
10:03:23 <chrisdone> "I think this would be nice to type" "yes, I like that. let's do that" ... fast forward ten years for it to be set in stone ... read militant arguments about why X idea is really important or correct
10:04:52 <manjunaths> Data.Array defines an amap function, but when I do an import Data.Array and try amap, it says Not in scope: amap, what might I be doing wrong ?
10:05:06 <Cale> chrisdone: Or why it was a bad idea and yet it's not changing.
10:05:45 <chrisdone> Cale: indeed. at least haskell 2010 got rid of n+k patterns
10:06:19 <helgikrs> manjunaths: Data.Array.IArray defines amap
10:06:20 <Cale> I don't think the standard is really the right place to make changes to a language.
10:06:38 <manjunaths> helgikrs, ok
10:07:12 <chrisdone> Cale: true. I like that Haskell's de facto implementation GHC also kind of makes de facto standards with extensions that filter through into other implementations out of natural selection
10:07:29 <chrisdone> (and vice versa)
10:07:34 <dankna> I like the LANGUAGE flag in Haskell
10:07:42 <dankna> it's a very nice way to select extensions because it's part of the source file
10:07:51 <Cale> I think it's really important to implement things before standardising them.
10:08:00 <dankna> agreed on that as well
10:08:34 <Cale> and yet there are a lot of things, the Prelude especially, which seem not to change simply because it would break compatibility with the standard.
10:09:06 <Cale> I think that as long as there is an implementation of the existing Haskell standard somewhere, that's good enough, and we should move along in places where we can see improvements.
10:09:17 <dankna> I tend to agree with you
10:09:40 <benmachine> hmm, the new thing in GHC 6.12 that lets you do top-level splices without $s is a little odd
10:10:00 <benmachine> it makes things parse that I didn't expect
10:10:07 <Cale> benmachine: That ought to be pretty neat though.
10:10:11 <benmachine> even if TemplateHaskell is turned off
10:10:15 <Cale> oh, really?
10:10:19 <benmachine> well
10:10:24 <benmachine> it then results in an error
10:10:27 <benmachine> but not a parse error
10:10:34 <Cale> weird
10:10:53 <benmachine> this could be a bug though
10:11:14 <benmachine> hmm
10:13:33 <benmachine> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23970#a23970 this gives me "Not in scope: bloo"
10:14:09 <Cale> whaaaaaat
10:14:21 <Cale> I'd report it as a bug.
10:14:26 <benmachine> if I don't use bloo in the RHS of blah, it goes GHC stage restriction: `blee' is used in a top-level splice...
10:14:47 <fax> blee bloo :: ...
10:14:47 <fax> ?
10:14:50 <fax> what does that mean
10:14:57 <benmachine> fax: good question
10:15:09 <benmachine> I did it by accident the first time and got a surprising error
10:15:15 <Cale> In any case, layout should ensure there's a semicolon in between them
10:15:17 <benmachine> now I'm trying to work out what GHC thinks it means
10:15:23 <Cale> (an invisible one)
10:15:45 <Tinned_Tuna> window 2
10:15:47 <benmachine> if I remove the newlines between the bare blee and bloo's type signature, I get a different error
10:15:52 <sm> morning dankna. I suppose it's not too likely direct-plugin will support ghc 6.10 ?
10:16:14 <benmachine> so I assume the semicolon is being placed fine
10:17:01 <dankna> morning sm.  it's not too likely, yeah, I hate having multiple ghcs installed.  there's a chance that it would just work if you changed the required version in the cabal file - let me know if you do that and it works.
10:17:21 <sm> ok, thanks
10:18:03 <chidimuorah> evening everyone
10:18:45 <Cale> hello
10:20:12 <interferon> are there existing libraries that will print a double as a money string, with commas and two decimals of precision?
10:20:34 <chidimuorah> write one :P
10:21:48 <Cale> > showFFloat (Just 2) 47389.38921 ""
10:21:49 <lambdabot>   "47389.39"
10:21:57 <Cale> No commas though.
10:22:00 <maltem> interferon, who would ever use a double for money calculations?
10:22:18 <Cale> Yeah, you shouldn't use Double for money, you should use fixed point numbers.
10:22:29 <benmachine> or Integer pence?
10:22:32 <Cale> yeah
10:22:33 <maltem> except maybe to calculate what you have to pay at the gas station
10:22:58 <fax> what is it called if you have a predicate that is always true after a point?
10:23:05 <fax> like P(n)->P(n+1)
10:23:17 <chidimuorah> invariant?
10:23:21 <benmachine> the phrase "sufficiently large" might come into it
10:25:50 <manjunaths> http://github.com/manjunaths/Mass-Spring-Simulator/blob/master/clothsim.hs in this code I am trying to write
10:26:05 <manjunaths> I am trying to make an IArray Int Particle
10:26:11 <manjunaths> from [Particle]
10:26:26 <manjunaths> so I wrote a makeArray function
10:27:04 <manjunaths> which does a listArray (0,array_size) [Particle]
10:27:24 <manjunaths> this works for Array, but doesn't work for IArray with this error message
10:27:52 <manjunaths> Type constructor `Particle' used as a class
10:28:04 <manjunaths> In the type signature for `makeArray':
10:28:47 <manjunaths> I put in the 'Particle e' in 'makeArray :: (Num a, IArray a1 e, Particle e, Ix a) => a -> a -> [e] -> a1 a e'
10:29:10 <sm> maltem: *cough*
10:29:36 <chidimuorah> do you have a constructor that takes a1 a e'?
10:29:42 <manjunaths> without that I get this error, No instance for (IArray a1 Particle)    arising from a use of `makeArray'
10:29:56 <manjunaths> no ?
10:30:11 <manjunaths> a1 a e is just the output array
10:30:14 <maltem> sm, "cough"?
10:30:29 <manjunaths> I am not sure
10:30:57 <benmachine> hmm the GHC Bugs by priority report doesn't exclude deleted bugs
10:31:01 <benmachine> which is odd.
10:31:33 <sm> I use Doubles for money calculations..
10:31:46 <sm> http://hledger.org/api-doc/Ledger-Types.html#t%3AAmount . Something more precise (and complicated) just hasn't been needed, so far..
10:32:12 <manjunaths> add an instance declaration for (IArray a1 Particle) ? how do I do this ?
10:32:32 <chidimuorah> try returning a tuple of type (IArray, Num, Particle) instead
10:32:44 <manjunaths> hmm...
10:33:07 <chidimuorah> also change the type signature to reflect this
10:33:43 <benmachine> no
10:33:45 <benmachine> that's wrong
10:33:50 <benmachine> IArray is a typeclass
10:33:54 <benmachine> so is Num
10:34:06 <manjunaths> that didn't work either
10:34:08 <benmachine> you need to work out the difference between types and type classes I think
10:34:20 <benmachine> Particle is a type, IArray is a class
10:34:27 <mreh> in yampa, what's useful about the recurrent switch when I can just use a regular switch that recursively calls a new switch
10:34:45 <chidimuorah> you're right, it should have the actual type
10:34:49 <mreh> a new regular switch
10:35:40 <chidimuorah> the thing is that I can't work out the type he's returning from the code
10:36:01 <mreh> I mean, who said yampa was difficult?
10:36:36 <benmachine> manjunaths: you said you wanted an IArray Int Particle
10:36:38 <benmachine> there is no such thing
10:36:48 <benmachine> Array Int Particle is very probably what you want
10:37:17 <manjunaths> ok
10:37:21 <benmachine> @instances-importing Data.Array IArray
10:37:21 <lambdabot> Couldn't find class `IArray'. Try @instances-importing
10:37:25 <benmachine> ff
10:37:33 <Cale> mreh: That's apparently what rSwitch does
10:37:35 <benmachine> basically the IArray class has an Array instance
10:37:45 <maltem> sm, "something more precise" - wait, is this an accounting software? Well if it isn't supposed to be usually correct, ok, I don't mind :p
10:37:46 <benmachine> (or to be more precise, an Array e instance)
10:37:50 <mreh> Cale: oh :)
10:38:01 <Cale> rSwitch :: SF a b -> SF (a, Event (SF a b)) b
10:38:01 <Cale> rSwitch sf = switch (first sf) ((noEventSnd >=-) . rSwitch)
10:38:10 <manjunaths> benmachine, Array doesn't have a map though ?
10:38:16 <manjunaths> amap I mean
10:38:35 <manjunaths> but IArray does, do I need to implement it ?
10:38:44 <benmachine> manjunaths: do you understand type classes?
10:38:47 <dankna> really, you use doubles for accounting?  I would have thought fixed-point would be the type of choice.
10:38:57 <FliPPeh> Is there any documentation on how to implement a model-view-controller design scheme for CGI in Haskell?
10:39:04 <manjunaths> benmachine, I thought I did now I am not so sure
10:39:07 <manjunaths> :-)
10:39:26 <benmachine> manjunaths: well, IArray is a type class and Array is an instance of that typeclass
10:39:27 <dankna> Flippeh: there is not.  my unreleased framework FruitTart is such a thing, though.  although I call it just controller-view because the model is, imo, the database.
10:39:29 <chrisdone> dankna: people use php for ecommerce web sites. it's a mad world
10:39:35 <dankna> chrisdone: point taken.
10:39:39 <manjunaths> benmachine, yes now I understand
10:39:50 <FliPPeh> dankna: How would I implement such a thing in Haskell?
10:39:54 <manjunaths> benmachine, I thought IArray meant integer array
10:39:56 <benmachine> the signature for amap is (IArray a e', IArray a e, Ix i) => (e' -> e) -> a i e' -> a i e -- it will work on any IArray, including Arrays
10:39:57 <FliPPeh> Just an abstract overview?
10:40:02 <benmachine> ah
10:40:06 <benmachine> a reasonable mistake
10:40:09 <chrisdone> FliPPeh: I know that turbinado is model-view-controller, but I don't know if it's CGI or its own server
10:40:10 <manjunaths> rather Array with Integer index
10:40:13 <dankna> Flippeh: well, I would start by getting the fastcgi package working for you and setting up your chosen webserver to host it.
10:40:18 <benmachine> but the I means immutable
10:40:18 <sm> dankna: I have done for a couple of years with no problems
10:40:28 <manjunaths> benmachine, ah...ok
10:40:29 <Cale> FliPPeh: You're practically forced into designing your application as model/view-controller at least.
10:40:32 <dankna> Flippeh: I can share my lighttpd.conf with you if that would help.
10:40:39 <dankna> sm: heh, okie then.  fair enough!
10:40:44 <FliPPeh> I've got XAMPP here, Apache
10:40:49 <sm> the amounts are small and we only need two decimal places, and no patch has yet appeared :)
10:40:51 <benmachine> i.e. an array created with that interface cannot be changed, only read and copied
10:41:11 <benmachine> compare with MArray which provides arrays that support in-place updates using IO or ST
10:41:25 <Cale> FliPPeh: Because the CGI input and output will happen in IO, and you'll typically write your model as (mostly) pure code, depending on what your program actually does.
10:41:30 <dankna> Flippeh: I wrote a piece some years ago on configuring fastcgi with apache.  I was aiming at a Lisp audience, but it would probably still be useful for this.  Let me find it...
10:41:42 <manjunaths> benmachine, ok...but I destroy and re-create everything in the array every cycle, so I think I am ok
10:41:59 <dankna> Flippeh: here we go, http://www.accela.net/~dankna/guide.html
10:42:15 <chrisdone> fastcgi is really easy with lighttpd
10:42:17 <dankna> Flippeh: that just covers how to get Apache talking to your backend, ... hmmmmmm
10:42:19 <benmachine> manjunaths: yeah, frequently immutable arrays are fine
10:42:25 <benmachine> but it's nice to know what the alternatives are
10:42:29 <manjunaths> benmachine, rather every element changes every cycle, so I think I should be ok using Array ?
10:42:31 <FliPPeh> Cale: Up until now, I've had a single CGI main point that retrieved IO data from external sources, and called pure functions to render the HTML. Is that MVC-style already?
10:42:32 <dankna> Flippeh: I don't think it's appropriate after all, rereading it that's for if you're running an entire server, not for fastcgi
10:42:52 <dankna> Flippeh: so you're on your own :)
10:42:56 <Cale> FliPPeh: Probably reasonably enough so :)
10:43:00 <FliPPeh> :)
10:43:02 <manjunaths> benmachine, yes, I filed it away in memory for some future use , thanks :-)
10:43:34 <dankna> but yeah, I personally use fastcgi with lighttpd - I like the self-containedness of the configuration, as opposed to Apache where it's really hard to have multiple installations on the same machine.
10:44:00 <chrisdone> I have yet been able to correctly understand the model-view-controller idea that makes it notable among normal modular code, and with a clear notion of the difference between a controller and a view
10:44:11 <jps_77> hello
10:44:14 <benmachine> reading the word lighttpd always bothers me
10:44:17 <Vitka> For fastcgi nginx is better choice I think.
10:44:20 <Cale> FliPPeh: The real idea behind MVC is that the model is some sort of declarative specification of how inputs translate to outputs. When you look at it that way, it sort of becomes trivial.
10:44:23 <benmachine> I keep wanting to say lighthttpd but it doesn't worjk
10:44:29 <dankna> chrisdone: I think that's not your fault at all, the difference is poorly defined in the first place
10:44:41 <monadic_kid> lesson 30 done: http://github.com/snkkid/LazyFooHaskell
10:44:45 <dankna> benmachine: they want you to pronounce it "lighty" but I can't see that
10:44:47 <jps_77> is haskell a compiled language?
10:45:02 <Cale> jps_77: It's both compiled and interpreted.
10:45:12 <Cale> jps_77: and there are bytecode interpreters as well
10:45:27 <benmachine> dankna: though the virtues of the english language do not include consistency, I have to say I don't think I've ever seen a silent d before
10:45:40 <dankna> benmachine: hahahaha, quite
10:45:41 <jps_77> Cale: what type of compiled code does haskell produce? the same type as C/++ or something similar to Java?
10:45:51 <FliPPeh> C/C++
10:45:51 <chidimuorah> c--
10:45:55 <FliPPeh> Or that.
10:46:12 <FliPPeh> jps_77: It runs without a runtime environment
10:46:21 <jps_77> ahh, thats good
10:46:22 <Cale> jps_77: The main implementation which most everyone uses is GHC. It is a compiler that comes with GHCi which is a bytecode interpreter. The compiler compiles to native code via a number of different pathways.
10:46:26 <benmachine> FliPPeh: only because it statically links the RTS >_>
10:46:38 <Cale> It can compile via C, or directly to native code, or via LLVM
10:46:42 <FliPPeh> Comes down to the same thing :)
10:46:47 <dankna> well, if you're going to count a statically linked RTS, then C doesn't run without an RTS either
10:46:54 <jps_77> Cale: so theoretically it could be used in micro controllers, etc?
10:46:54 <benmachine> true
10:47:00 <Saizan> the GHC's RTS doesn't interpret though, fsvo interpret
10:47:06 <FliPPeh> The new GHC does support dynamically linking it, doesn't it?
10:47:08 <benmachine> also true
10:47:14 <benmachine> also also true
10:47:18 <Cale> jps_77: If you're writing code for microcontrollers, you probably are more interested in Haskell as a meta-language.
10:47:29 <FliPPeh> The binaries are rather big
10:47:33 <jps_77> Cale: well, i mentioned theoretically
10:47:35 <Cale> jps_77: There are some tools like atom for writing hard-realtime applications in Haskell.
10:47:36 <chidimuorah> to be fair, high level languages can be compiled to anything you want them to
10:47:46 <chrisdone> someone has written a complete implementation of a ghc backend/runtime combo that compiles to jvm. not really, I'm joking. now clean the coffee off your keyboard
10:47:48 <benmachine> chidimuorah: so long as someone has written the compiler
10:48:00 <sepp2k> dankna: Isn't the libc usually dynamically linked? I remember borking a linux installation many years ago by updating glibc.
10:48:13 <dankna> sepp2k: it depends, but yes, now that you mention it
10:48:15 * monochrom cleans the drool off his keyboard
10:48:17 <Cale> jps_77: Where, you use the atom library to write a Haskell program which when run, generates a C program with hard real-time constraints.
10:48:30 <manjunaths> thanks all, you guys rock, although a little slowly sometimes :-)
10:48:42 <benmachine> heh
10:48:44 <manjunaths> I am off to bed. g'night.
10:49:44 <Cale> (the main developers of atom are using it to program microcontrollers for hybrid hydraulic vehicles, which is rather cool :)
10:49:55 <Cale> http://hackage.haskell.org/package/atom
10:51:16 <sepp2k> Is there a(n easy) way to get @hoogle- and @pl-like functionality in ghci (or emacs)?
10:51:33 <Cale> Now, if you don't have such tricky timing constraints on your software, you might still be able to use Haskell, but getting GHC to compile programs for things like ARM is a bit tricky as I understand it. (Though there are people who do this sort of thing.)
10:51:36 <benmachine> both are available on hackage as command-line programs
10:51:41 <djahandarie> You can do anything in emacs
10:51:57 <Cale> I mean, you might be able to use Haskell directly, rather than as a metalanguage.
10:52:20 <benmachine> ohh -dynamic not -shared
10:52:21 <Cale> But Haskell really runs best for now on desktop computers.
10:52:25 <jps_77> how low level is haskell?
10:52:47 <polymorphic> as high level as you can get
10:52:52 <chrisdone> jps_77: about *this* much?
10:52:58 <benmachine> it does have some tools for doing low-level things
10:53:03 <Cale> While Haskell has low-level primitives for interfacing with C code and other languages, Haskell is generally about as far from low-level as you can get.
10:53:09 <sm> sepp2k: yes, see latest haskell-mode.el and ghc-mod.el for emacs
10:53:22 <polymorphic> low level programming is quite challenging in haskell
10:53:24 <sm> I think it's in haskell-mode
10:53:44 <Cale> I wouldn't say that low level programming is all that bad in Haskell, it's just not the way you'd typically write your programs.
10:53:52 <djahandarie> polymorphic, one could argue that high-level programming is also challenging in Haskell. :P
10:54:05 <polymorphic> :P
10:54:07 <Cale> The FFI stuff makes things like manual memory allocation about as easy as it could be made.
10:54:10 <sepp2k> sm: Thanks
10:54:37 * dankna cabal-installs hoogle - thanks for pointing that out :D
10:54:41 <polymorphic> true, but you'll end up writing lots of monadic code with low level programming
10:54:47 <jps_77> ah
10:54:48 <benmachine> programming is challenging
10:54:53 <jps_77> so what are the main uses for haskell?
10:55:09 <chrisdone> sepp2k: I use GHCi on Acid which is basically a bunch of commands for ghci for using lambdabot
10:55:10 <benmachine> high-level ones? :P
10:55:11 <dankna> jps: well, you might look through the package list on Hackage to see what other people are doing with it
10:55:17 <shapr> jps_77: Writing useful programs!
10:55:28 <FliPPeh> And being fun :)
10:55:30 <chrisdone> @faq Can I write useful programs with Haskell?
10:55:30 <lambdabot> The answer is: Yes! Haskell can do that.
10:55:32 <benmachine> heh
10:55:38 <shapr> jps_77: http://hackage.haskell.org/packages/archive/pkg-list.html
10:55:41 <FliPPeh> @faq Can Haskell cure hunger?
10:55:42 <lambdabot> The answer is: Yes! Haskell can do that.
10:55:44 <sepp2k> chrisdone: Thanks I'll look into that.
10:55:48 <dankna> @faq Can Haskell answer questions which Haskell cannot answer?
10:55:48 <lambdabot> The answer is: Yes! Haskell can do that.
10:55:59 <Twey> There… is a Haskell Facebook group
10:56:07 <dankna> pretend that was the halting problem, because I couldn't figure out how to make it really be
10:56:10 <chrisdone> sepp2k: http://www.haskell.org/haskellwiki/GHC/GHCi#GHCi_on_Acid
10:56:13 <polymorphic> you can certainly write useful programs in haskell
10:56:22 <Twey> I am disturbed
10:56:25 <djahandarie> @faq Can Haskell provide a proof for P=NP
10:56:25 <lambdabot> The answer is: Yes! Haskell can do that.
10:56:30 <dankna> there we go
10:56:37 <chrisdone> Twey: there are visits to tryhaskell from facebook
10:56:39 <Cale> jps_77: Well, it's a general purpose language, but it's mainly used for programs that run on typical desktop machines. It's very good with concurrency and parallelism. It's also comparatively easy to analyse the behaviour of Haskell programs and try to prove they have no bugs. So it gets used in a lot of high-assurance sort of settings.
10:56:39 <polymorphic> lol :P P+NP
10:56:48 <Taejo> @faq Can Haskell solve the halting problem?
10:56:49 <lambdabot> The answer is: Yes! Haskell can do that.
10:56:49 <polymorphic> *P=NP
10:57:05 <Cale> jps_77: It's really rather good at manipulating languages, and would be an excellent language in which to write a compiler, for instance.
10:57:17 <Botje> futurama solved that problem years ago: http://www.lafferty.ca/files/stuff/misc/futurama_p_np.png
10:57:27 <polymorphic> someone wants to be famous by solving the halting problem
10:57:44 <sm> Cale: when you say desktop, I think you mean to include servers too
10:57:49 <benmachine> whee 10MB statically linked 200K dynamically linked
10:58:18 <sepp2k> chrisdone: Thanks, that looks great.
10:58:18 <monochrom> I solved the nonhalting problem
10:58:24 <sm> from haskell-cafe, I gather the main issue with haskell for low-level things is garbage collection and laziness-related delays
10:58:37 <yitz> monochrom: me too. drink coffee - right?
10:58:46 <twink> The savings are largely illusory since few of the libs will be shared by other running apps.
10:59:17 <chrisdone> Cale uses Haskell like Picard uses The Enterprise
10:59:20 <polymorphic> you can always force evaluation but it generally feel unnatural to the haskell way of doing things
10:59:25 <Cale> sm: Yeah, desktop and larger :)
10:59:31 <k23z__> hey do you people have code for morphisms ?
10:59:38 <monochrom> @remember chrisdone Cale uses Haskell like Picard uses The Enterprise
10:59:38 <lambdabot> Done.
10:59:40 <k23z__> can I write stuff that will prove if a thing is a morphism ?
10:59:50 <k23z__> not just on finite sets/groups/whatever_algebraic_structure
10:59:52 <benmachine> twink: so you assume; but anyway I was talking about disk space, which is useful because it is 50x faster to upload new revisions of my CGI script to my webserver
11:00:14 <Cale> k23z__: Usually you test/prove those properties separate from the actual code.
11:00:22 <jps_77> does haskell have good networking support?
11:00:25 <dankna> benmachine: rsync
11:00:29 <sm> jps_77: I use it to build programs that are relatively more reliable and maintainable for less effort
11:00:33 <benmachine> dankna: that is a thing
11:00:36 <k23z__> Cale: you mean I take a morphism and I see if it is really a morphism ?
11:00:45 <sm> command-line tools and web apps, so far
11:00:45 <k23z__> Cale: f . x*y = f.x * f.y ?
11:00:46 <dankna> benmachine: fair enough, I suppose.  as long as you've considered it.
11:00:55 <k23z__> Cale: for all x,y
11:01:14 <benmachine> dankna: I've tried to use rsync in the past but I don't really "get" it, it seems to copy stuff it doesn't need to anyway
11:01:21 <sm> and yes, the networking support is pretty good afaik
11:01:24 <Cale> k23z__: You can use something like QuickCheck to randomly test functions for equational properties.
11:01:37 <k23z__> Cale: I thought Haskell could do some magic on them :)
11:01:40 <benmachine> dankna: I suppose it would probably help, but look things being 50 times smaller is just cool okay?
11:01:45 <k23z__> Cale: but I'm probably asking for too much
11:01:51 <Cale> k23z__: and of course, referential transparency means that you can often prove properties just by substituting definitions
11:01:57 <dankna> benmachine: that's fair enough, haha
11:02:05 <polymorphic> quickcheck is magical enough :P
11:02:15 <dankna> benmachine: I don't like its recursive mode, I only use it for single files if I have any say in the matter
11:02:22 <Cale> Haskell makes it sort of easy to reason about your code, but doesn't implement much more reasoning than you see in the typechecking.
11:02:27 <dankna> benmachine: in that mode, think of it as "copy A to B, possibly assisted by existing data at B"
11:03:01 <jps_77> hmm
11:03:02 <Cale> You could *maybe* devise really fancy types to ensure various properties, but it's not the sort of thing you would normally do in Haskell.
11:03:10 <jps_77> would haskell be good for writing games? or am i pushing it a bit
11:03:19 <dankna> games have been written in it
11:03:20 <k23z__> Cale: what would you do it in ?
11:03:22 <Cale> (I mean ensure things like associativity or commutativity of some operator through its type)
11:03:27 <pikhq> jps_77: You certainly can.
11:03:30 <monochrom> Write a theorem prover in haskell.
11:03:35 <HugoDaniel> hi
11:03:35 <Cale> k23z__: Theorem prover software like agda or coq
11:03:44 <k23z__> jps_77: they wrote some games in it .. it has opengl bindings and stuff .. rainycat is a well known game written in haskell
11:03:50 <polymorphic> people already do that I think
11:03:54 <Cale> k23z__: Both of which, to the best of my knowledge, can emit Haskell code.
11:03:57 <k23z__> Cale: ah yes .. how exactly do those work ?
11:04:01 <benmachine> @hackage minesweeper -- I think this is pretty cool
11:04:01 <lambdabot> http://hackage.haskell.org/package/minesweeper -- I think this is pretty cool
11:04:09 <benmachine> heh lambdabot agrees
11:04:09 <k23z__> Cale: can emit haskell code for ?
11:04:25 <yitz> hi HugoDaniel
11:04:59 <polymorphic> simple games is probably doable in haskell, your next ps3 game of the year is probably pushing it
11:05:12 <dankna> though that said, there have been game studios that used functional languages
11:05:27 <polymorphic> unless you write your own highly optimising compiler
11:05:38 <Cale> k23z__: As in, you can write functions in those languages, and prove theorems about them, and have them emit equivalent Haskell code.
11:05:57 <benmachine> polymorphic: writing your own compiler would be mad
11:06:05 <benmachine> improving GHC'd be much simpler
11:06:18 <yitz> there was an article a while back by a top game developer where he saw a big future in functional languages. anyone remember where it is?
11:06:19 <Ke> well you can use haskell to generate opencl/gl code and do all the data handling in gpu
11:06:19 <pikhq> polymorphic: More like "add a SPU backend to GHC". The PPU portion should be pretty well covered.
11:06:20 <jps_77> hmm. so how efficient is compiled haskell code?
11:06:21 <Cale> I think that Haskell would make a great language for games, but there's more work needed to make it convenient just yet.
11:06:24 <polymorphic> you only have to write the backend bit
11:06:28 <pikhq> jps_77: Absurdly.
11:06:31 <k23z__> Cale: equivalent code in haskell that will prove stuff in haskell ?
11:06:31 <dankna> yitz: no; tell me if you find it
11:06:32 <Cale> Yeah, Tim Sweeney did a presentation
11:06:39 <yitz> that's it, yeah
11:06:52 <Cale> k23z__: That you'll have already proved stuff about in Agda or Coq
11:07:18 <Cale> k23z__: That is, you don't do the proof itself in Haskell, you do it in one of these languages with a richer type system, and extract the Haskell code after the fact.
11:07:23 <k23z__> Cale: can you give me like a concrete example
11:07:30 <k23z__> Cale: let's say I want to prove first isomorphism theorem
11:07:33 <k23z__> Cale: for groups
11:07:52 <Cale> Oh, jeez, I have no idea what sort of code you'd want to extract there...
11:08:04 <sm> dankna: yay, relaxing the ghc version dependency in direct-plugins seems to just work
11:08:09 <dankna> sm: ooh cool
11:08:20 <Stalafin> is something like map (\x -> if then else) xs proper coding? or what you not do that inline?
11:08:20 <sm> trying to load something now, to make sure
11:08:36 <k23z__> Cale: ok let's just prove something really really simple,  can we do that please ?
11:08:38 <dankna> this being Haskell, it probably works fine if it compiles at all, but yeah
11:08:46 <k23z__> Cale: having 1+1 = 2, we prove 1 + 1 + 1 = 3
11:08:51 <k23z__> Cale: how do we proceed ?
11:08:59 <Cale> k23z__: But you could probably encode the theory of groups in Agda and Coq and do formal proofs. I just don't know what use the Haskell code would be.
11:09:09 <fax> what the hell
11:09:10 <sm> dankna: I tried eg load ("base","Prelude","sum"), and it couldn't find "sum"
11:09:12 <fax> 1 + 1 + 1 = 3?
11:09:21 <k23z__> fax: for real
11:09:24 <dankna> hmmmm
11:09:26 <int-e> k23z__: what is 3?
11:09:27 <fax> > 1 + 1 + 1
11:09:27 <dankna> looking into it, one sec
11:09:28 <lambdabot>   3
11:09:34 <polymorphic> i think you need more axioms
11:09:34 <fax> that's it proved, no?
11:09:36 <k23z__> int-e: hehe ..
11:09:55 <monochrom> Try 0+0+0=0 first.
11:09:58 <fax> k23z__ why don't you pick a real example rather than this silly one
11:10:13 <k23z__> fax: if I pick a real one it will be too complicated
11:10:16 <fax> no
11:10:25 <dankna> sm: I see the same behavior on 6.12 (can't find sum), my guess would be that that's because sum is actually reexported by Prelude and doesn't originate there?
11:10:26 <k23z__> fax: I want to pick an example that just showcases stuff
11:10:34 <sm> aha
11:10:35 * fax sigh
11:10:46 <k23z__> fax: please you are free to pick an example yourself
11:10:46 <dankna> sm: that points to an area where I could probably improve things by parsing .hi files to find out where it originates.... heh
11:10:53 <k23z__> fax: I would like to know an example from you please
11:10:58 <fax> k23z__ example of what? I don't know what you are actually trying to find out
11:10:58 <monochrom> It is unclear to me why math-inclined people pick examples involving 1 when 0 is so much easier.
11:11:02 <sm> that's a bit surprising for the user, yes
11:11:03 <k23z__> fax: do you have a suggestion ?
11:11:13 <dankna> sm: I'll make a note of it and get to it when I get to it
11:11:26 <polymorphic> 0 is a funny concept :P
11:11:36 <k23z__> fax: given some hypothesis use coq to prove stuff
11:11:37 <sm> great.. can you give me one symbol that you know works ?
11:11:43 <fax> http://hal.archives-ouvertes.fr/docs/00/07/19/85/PDF/RR-4600.pdf
11:11:43 <k23z__> fax: then make it write haskell that proves that
11:11:43 <sm> I haven't found one yet
11:11:44 <jps_77> so assuming haskell writes fast code for desktop systems, would things like servers be good applications to write with it?
11:11:46 <krasno> I'm having a little bit of trouble with avoiding mutually recursive module imports.
11:11:49 <fax> there is a research paper
11:12:04 <monochrom> Yeah, it's clear to me why laypeople pick 1. But unclear why math-apt people are no better.
11:12:15 <dankna> sm: sure, one sec
11:12:25 <Saizan> jps_77: sure
11:12:36 <fax> k23z__ this is knuth s algorithm
11:12:36 * yitz resists reaching for the @faq button
11:12:59 <sm> dankna: and then, if I may bug you a little more.. how come load ("hledger", ..., ...) says Unknown package hledger ? ghc-pkg list shows hledger-x.y.z installed
11:13:09 <orlandu63> > replicate 100 . product . map (*3) . zipWith max [1,2,3,4,5] $ [4,5,6,7,8]
11:13:10 <lambdabot>   [1632960,1632960,1632960,1632960,1632960,1632960,1632960,1632960,1632960,16...
11:13:18 <dino-> yay instance Alternative [] so I can do: foo <|> "some default string"
11:13:35 <dankna> sm: ohhhh..... because right now as things stand it's expecting you to pass "hledger-x.y.z". not ideal and could be fixed without much effort on my end, I'm just a little surprised (and flattered) that anybody's trying to use this at all :)
11:13:42 <sm> ahh
11:13:45 <Saizan> > "foo" <|>  "some default string"
11:13:46 <lambdabot>   Ambiguous occurrence `<|>'
11:13:46 <lambdabot>  It could refer to either `Control.Applicative.<...
11:13:56 <Saizan> > "foo" Control.Applicative.<|>  "some default string"
11:13:57 <lambdabot>   "foosome default string"
11:14:05 <jps_77> sounds good. see i am looking to learn a new language similar to C to write a server of mine, thought i might aswel learn a new language while i write it
11:14:09 <sm> dankna: well I think it's something quite a few folks would use if it were easy and reliable, and you sure have made it look easy
11:14:10 <monochrom> This is foosome
11:14:10 <Saizan> dino-: can you? ^^^
11:14:31 <dankna> sm: yeah... I'd like to think that.  I need to write documentation and stuff if I want people to use it, obviously :)
11:14:37 * sm likes libs that re-do other libs in simpler form
11:14:46 <Saizan> jps_77: well, Haskell is not similar to C at all :)
11:14:47 <dankna> sm: I was using the Plugins module before but I didn't find it to be either of those :/
11:14:53 <dankna> yeah agreed
11:15:06 <dino-> Saizan: Ah! I misunderstood it by tinkering with [] on the left.
11:15:18 <dankna> still looking for a symbol that works, one sec... :)
11:15:25 <dino-> I thought this was the MonadOr spoken about in that wiki page.
11:15:29 <Saizan> jps_77: though it's fairly competitive if you can afford garbage collection
11:15:47 <Saizan> dino-: heh, no
11:15:56 <k23z__> fax: what knuth algorithm ? knuth has hundreds if not thousands of algorithms
11:16:01 <dino-> Is there anything in the libs that will do that at this time?
11:16:06 <k23z__> fax: he has thousands of pages written for AOCP
11:16:09 <jps_77> Saizan: well, in terms of it compiling it is similar to C :p
11:16:20 <Saizan> jps_77: true :)
11:16:35 <monochrom> MonadOr is french for Gold Monad.
11:16:35 <fax> k23z__: ... http://hal.archives-ouvertes.fr/docs/00/07/19/85/PDF/RR-4600.pdf
11:16:40 <DigitalKiwi> "write a server" :/
11:16:48 <fax> just read this, you can learn a lot from it
11:17:01 <fax> this touches on all the important aspects
11:17:04 <dino-> Also, does that really make sense for Alternative instancing for [] ? The way it works, I mean.
11:17:22 <dino-> monochrom: Monad d'Or
11:17:27 <Saizan> Alternative is just MonadPlus for Applicative
11:17:41 <dino-> Saizan: So, it makes as much sense as MonadPlus ever did for []
11:17:46 <Saizan> yeah
11:18:00 <sm> dankna: so as I get my head around this more.. this means recompiling and linking whatever code you load.. eg doing this for every plugin, each time my app starts
11:18:01 <dino-> which is to say, plenty of sense if you want concatination
11:18:21 <sm> so there would be some cost, perhaps, in time and memory use, eg on a vps
11:18:42 <aavogt> @remember monochrom MonadOr is french for Gold Monad.
11:18:43 <lambdabot> It is stored.
11:18:44 <sm> insignificant for a long-running app, but something to consider for a command-line tool
11:18:51 <Saizan> dino-: it works well with the "angelic non-determinism" semantics that the list monad is associated with
11:19:02 <dankna> sm: well, it links, it doesn't recompile.  specifically what it loads is /usr/lib/hsledger-plugin/some-other-directories/HShsledger.o
11:19:09 <dankna> sm: cabal compiles it at install-time
11:19:11 <sm> ah, thanks
11:19:12 <int-e> Saizan: angelic?
11:19:13 <Saizan> dino-: you instead want a commited-choice view
11:19:19 <dankna> sm: link should be a relatively fast operation
11:19:24 <sm> that helps me understand it
11:19:37 <dankna> good
11:19:50 <sm> I find linking pretty slow on my server, because it can take a lot of memory.. it's linking the whole app, I assume
11:19:51 <Saizan> int-e: maybe angelic is not the right term, the idea is that it gives you all the possible results
11:20:01 <aavogt> sm: if you can afford less extensions and slowness when actually calculating things, hugs loads files pretty quickly
11:20:17 <sm> good to know
11:20:35 <aavogt> too bad it's unmaintained
11:20:55 <dankna> sm: hmmmm..... that's true
11:21:12 <amuller> Hello, how do I know if toDescList is going to work in a lazy way? The docs say it is O(n) but in the case of haskell would it be O(k) if I only need the first k elements?
11:21:25 <amuller> (I am talking about Data.Map)
11:21:50 <sm> dankna: maybe ghc 6.12's support for dynamic libs will come in useful
11:21:57 <dankna> sm: hmmm indeed
11:22:27 <dankna> sm: there are three (!) interfaces to the linker in the GHC API
11:22:40 <dankna> there's one for linking bytecode objects, one for linking native objects, and one that wraps around both of those transparently
11:22:42 <dankna> I'm using the last one
11:22:45 <benmachine> amuller: Debug.Trace is good for little test programs to work out what is and is not evaluated
11:23:12 <int-e> amuller: O(log(n) + k) would be my guess. anyway, yes, it's lazy. look at the code ;)
11:23:47 <amuller> Thanks benmachine and int-e.
11:24:02 <aavogt> benmachine: hmm, I'm not sure that would work since Map is strict in the keys
11:24:12 <Saizan> dankna: so the difference between "dynamic linking support" and linking native objects via the ghc-api is just that the former is done by the OS directly?
11:24:40 <benmachine> aavogt: what difference does that make? you can always work out what is and is not evaluated by some call
11:25:05 <dankna> well,
11:25:10 <dankna> yes, I believe so
11:25:21 <aavogt> and even if you had to visit all the nodes when making the descending list, you don't have to force the actual values
11:25:38 <benmachine> yeah I suppose that'd be difficult
11:25:39 <dankna> I think there's something technical about making sure the objects have the symbols in them
11:25:44 <benmachine> you could just make a really huge map?
11:26:17 <dankna> that is, I think the ghc implementors had to do some special work to make the OS able to read GHC objects
11:26:50 <dankna> bt yes, they're basically the same operation - it even uses dlopen() to have the OS do the linking, in situations where that's appropriate
11:27:30 <sm> dankna: so.. I do *System.Plugins> load ("hledger-0.7.1","Ledger.IO","readLedger")  and see Just (). Or if I do  Just x <- load ("hledger-0.7.1","Ledger.IO","readLedger"), x is a GHC.Exts.Any. How do I get the readLedger function, type FilePath -> IO Ledger ?
11:27:58 <dankna> ah, this is because of the call to unsafeCoerce
11:28:03 <dankna> what you want to do is
11:28:04 * hackagebot mongoDB 0.4.1 - A driver for MongoDB  http://hackage.haskell.org/package/mongoDB-0.4.1 (ScottParish)
11:28:07 <aavogt> but maybe it's some consolation that you only get 5 messages here:    rnf . take 5 . foldr (\x y -> trace "x" (:) x y) [] . M.toDescList
11:28:34 <dankna> Just x <- load ("hledger-0.7.1","Ledger.IO","readLedger") :: IO (Maybe (FilePath -> IO Ledger))
11:28:38 <dankna> something along those lines
11:28:46 <dankna> in other words, give ghci the type information
11:28:49 <sm> ah, makes sense..
11:29:11 <dankna> at this point it's appropriate to warn you that you are trusting the plugin to export something of the appropriate type
11:29:14 <dankna> that's hopefully pretty obvious
11:29:17 <benmachine> aavogt: huh? that looks like it is testing the list not the map for strictness
11:29:22 <sm> I see.. no it wasn't to me :)
11:29:37 <aavogt> maybe that's the case
11:29:38 <dankna> parsing the .hi files to ensure that it really is the appropriate type is an interesting idea for a feature... dons's Plugins didn't do that either
11:29:40 <benmachine> aavogt: personally, I'd map ("x" `trace`) over the whole map, then toDescList the result
11:29:53 <dankna> okay.  well, I'm learning what's obvious and what isn't as I go, haha.
11:29:55 <aavogt> benmachine: I think we're both wrong
11:30:00 <sm> is it correct to say that to do a load, the program must already know about the types used by the loaded function ?
11:30:07 <dankna> I'm probably going to distill this conversation into a first draft of the docs
11:30:09 <dankna> it is correct
11:30:12 <dankna> so one strategy for example
11:30:18 <dankna> is to have a package HLedger-Interface
11:30:23 <dankna> which exports the types
11:30:25 <benmachine> sm: compiled code doesn't contain type information
11:30:31 <dankna> and both the plugins and the host program depend on that
11:30:33 <aavogt> typeable?
11:30:46 <benmachine> ...apart from typeable
11:30:47 <erl> is there any array implementation with O(1) access complexity
11:30:49 <dankna> benmachine: however, the installed package contains the .hi files too, which does
11:30:55 <benmachine> true
11:31:02 <aavogt> erl: Data.Array.*
11:31:05 <ddarius> erl: All of them.
11:31:17 <dankna> Dons's Plugins has a lot of stuff which you can read about in his paper which uses a value of type Dynamic
11:31:24 <dankna> but in the end it doesn't buy you anything
11:31:36 <benmachine> aavogt: using typeable in this case though would require information to go from the value level to the type level, though
11:31:39 <benmachine> I think
11:31:41 <benmachine> which it doesn't do
11:31:52 <dankna> because a) you still need to know about the actual type to use it for anything, and b) you still trust the plugin to export a Dynamic as opposed to some other type
11:32:13 * aavogt hasn't been following very closely
11:32:32 <Saizan> so you can get a segfault with a bad plugin?
11:32:44 <sm> dankna: success!
11:32:56 <dankna> Saizan: well, that is correct, but it's not the unsafeCoerce's fault.  a bad plugin could contain any arbitrary code, including non-Haskell code.
11:32:57 <ddarius> Using Dynamic or some other tagged scheme better allows for update.
11:33:01 <dankna> sm: yes indeed!
11:33:19 <benmachine> but you can also get a segfault with bad use of a good plugin, presumably
11:33:29 <dankna> ddarius: well, yeah, one approach would be to export two symbols, one which tells you the version of the interface and one which is the actual interface
11:33:50 <dankna> ddarrius: another approach would be a Dynamic, yes.  no special support from direct-plugins is required for either of these strategies.
11:33:53 <ddarius> dankna: Indeed.  I would recommend something like that.
11:33:55 <dankna> benmachine: yes, that is true.
11:34:01 * sm had to load another module to get all typeclass instances, then the loaded thing was fully functional
11:34:10 <ddarius> Dynamic is kind of like a content-based versioning system.
11:34:13 <dankna> sm: hmmmm okay, good :)
11:34:53 <dankna> the thing about Dynamic is that the actual representation of the type is something you have to write yourself; it's not automatic
11:35:27 <Saizan> don't you just derive Typeable?
11:35:55 <Saizan> btw, would the Typeable tags be consistent across packages linked like this?
11:35:58 <dankna> I haven't done it in a while, but I seem to remember having to write something that gave a string for my type or something
11:36:22 <dankna> I recall something about Dons's Plugins needing special support for that, actually; I probably need to support that too.
11:37:26 <Saizan> Typable uses a spooky toplevel IORef to do memoization, afterall
11:37:50 <dankna> good to know
11:38:05 <dankna> I'm pretty sure they need to be cleverly translated
11:38:13 <dankna> because I'm pretty sure I saw the code that did it :)
11:43:01 <sm> given the issues that come with this linked plugin approach (extra care required to preserve safety, likely more fragile dependencies) I'm wondering if it's the right way for hledger. I can also try to discover an executable provided by the plugin, at the shell level, and run it as a subprocess
11:43:18 <dankna> that's an interesting point
11:44:01 <Saizan> @hackage hledger
11:44:01 <lambdabot> http://hackage.haskell.org/package/hledger
11:44:58 <sm> http://hledger.org/api-doc/ gives a better idea.. you see the Commands there, some of those could be plugins
11:45:33 <dankna> hmm yes
11:45:51 <dankna> now one thing that the linked plugin approach does buy you over subprocesses is that subprocesses can be killed by outside forces
11:46:02 <dankna> (the user or the kernel, in a low-memory condition)
11:47:42 <sm> yes, it has its own complications, though the Command plugins would probably just replace the main process
11:47:48 <dankna> yeah, I see
11:48:30 <dankna> I'd love to have you using my thing, for reasons of personal ego; I may look at adding the .hi-parsing to get stronger guarantees of safety, if that would sway you at all :)
11:48:42 <dankna> but do what's right for your project, of course
11:48:44 <sm> makes me wish for runtime import like in python. This is easier there.
11:48:53 <dankna> yeah, indeed
11:48:58 <dankna> this is something that imo /should/ be made easy
11:49:53 <Saizan> well, with the sources around like you'd have with python you could use hint, which is pretty simple
11:49:54 <sm> dankna: I'm definitely still interested. The answer might be to use direct linking for "core" trusted plugins, perhaps bundled as a package, and subprocesses for random other stuff
11:50:14 <sm> but of course, I want to get the simplest thing working with a minimum of work :)
11:50:23 <Saizan> (and safe)
11:50:48 <sm> interesting, thanks
11:50:50 <dankna> one sec
11:51:14 <FreeBSDBG> i need
11:51:16 <FreeBSDBG> help
11:51:19 <FreeBSDBG> about freebsd
11:51:57 <yitz> FreeBSDBG: are you trying to use haskell on freebsd?
11:52:32 <FreeBSDBG> yitz :???
11:53:10 * sm wishes code.haskell.org served .hs files as text/plain
11:53:37 <Stalafin> how do i combine 2 functions with a dot, if the first function takes to arguments? example: hPutStrLn handle foo(bar)?
11:53:37 <dankna> indeed
11:53:39 <mauke> FreeBSDBG: !!!
11:53:39 <dankna> back
11:53:52 <mauke> Stalafin: did you mean: (foo bar)
11:53:57 <Stalafin> yeah
11:54:05 <mauke> hPutStrLn handle . foo
11:54:11 <mauke> (hPutStrLn .) . foo
11:54:13 <dankna> sm: well, I think I'm going to spend time today working on the hi-parsing.  I'll release a 1.1 or something when it's working and let Haskell-Cafe know.
11:54:40 <tommd> :t (hPutStrLn .) . id
11:54:41 <lambdabot> Not in scope: `hPutStrLn'
11:54:47 <tommd> damn bot
11:55:20 <sm> dankna, all: thanks for the lib and chat
11:55:22 <aavogt> sm: does the server ignore .htaccess?
11:55:42 <dankna> sm: very welcome!  I'm just pleased that someone's using my thing, haha.  or at least thinking about using it.
11:56:06 <sm> aavogt: dunno, I just frequently want to browse code there and chrome downloads it
11:56:20 <AxleLonghorn> why, in a case statement, does an _ need to be (_) in parentheses?
11:56:31 <jlouis> dons: my strict cml variant looks somewhat promising at killing some space leaks
11:56:44 <mauke> what does it server .hs as?
11:56:50 <mauke> s/server/serve/
11:57:47 <sm> mauke:  text/x-haskell
11:58:07 <aavogt> oh right. I thought you wanted to make your code served with a different mime type
11:58:22 <mauke> I have a solution for firefox
11:58:45 <sm> that's ok, I just wish c.h.o made it the default
12:00:09 <dankna> sm: I am heading away from keyboard for a few hours; good luck!
12:00:20 <sm> thanks, see you
12:01:13 <sm> me too. The sun is shining, and I live near a beach. Remove hands from keyboard, stand, walk...
12:01:15 <sm> later all
12:03:40 <dons> jlouis: check the strict-concurrency package if you're looking for examples
12:04:16 <jlouis> dons: it *uses* strict concurrency :P
12:04:43 <dons> ah cool.
12:05:02 <jlouis> I could make it stricter than now though. I only enforce strictness on the data traverses. Not the synchronization mvars
12:05:21 <jlouis> the latter is on the todo list to look into
12:07:26 <dons> interesting. the MVars should probably always be $! -- but it is hard to profile for this (do some retainer profiling)
12:07:35 <jlouis> noted.
12:47:14 * hackagebot vector-static 0.3.0 - Statically checked sizes on Data.Vector  http://hackage.haskell.org/package/vector-static-0.3.0 (JakeMcArthur)
12:48:16 <altmattr_> I am trying to do numerical computation in a little Haskell script but I am getting confused about rationales and fractionals etc.  is there a good placeto go and learn about these things?
12:48:52 <xerox> maybe the report, the numeric chapter in particular
12:50:25 <altmattr_> xerox: i am afraid that was what confused me!
12:50:37 <xerox> hehe, what do you want to do?
12:51:05 <roconnor> what is CAS?
12:51:10 <Zao> Compare-And-Swap?
12:51:17 <roconnor> ah yes
12:51:21 <xerox> Computer Algebra System
12:51:41 <roconnor> Haskell has a compare and swap operation?
12:51:44 <altmattr_> divide currency amounts and print that out to two decimal places
12:51:51 <Zao> I've got no idea about context, just guessing.
12:52:31 <xerox> altmattr_: ah there's good bibliography about that, search for haskell money & co. Ultimately, you can also use Rational and the show* functions of Numeric (or printf)
12:53:25 <altmattr_> xerox: thankyou!!
12:55:46 <roconnor> heh, ordinatiry immutable lists stored in a single mutible variables was the fastest!
12:56:25 <roconnor> atomicModifyIORef
12:57:42 <roconnor> sounds like an underappreciated method for concurency
13:08:35 <yitz> altmattr: are you still there?
13:09:05 <yitz> altmattr: if so - you definitely want to look at the Decimal package on hackage.
13:11:29 <dons> @tell tibbel http://gregorycollins.net/posts/2010/03/12/attoparsec-iteratee#comment-39671374 they're rolling their own epoll event manager
13:11:30 <lambdabot> Consider it noted.
13:19:45 <lowasser> Poking the masses: does anybody know whether or not the amortized time bounds on pairing heaps [1] have been proven to apply in a persistent context to Okasaki's persistence-friendly modification [2] ?
13:19:45 <lambdabot> lowasser: You have 1 new message. '/msg lambdabot @messages' to read it.
13:19:54 <lowasser> [1]: http://www.springerlink.com/content/yv91h55qw75anfkv/
13:20:15 <lowasser> [2]: http://www.eecs.usma.edu/webs/people/okasaki/pubs.html#afp96
13:20:38 <FliPPeh> @hpaste
13:20:38 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
13:21:28 <FliPPeh> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=8585#a8585 <- this of course fails, because line 3 would have to be an expression, but how would I change this so it does NOT fail?
13:21:43 <FliPPeh> Any empty CGI expression that does nothing?
13:22:43 <Megant> you don't need in when you use do
13:23:08 <nostrand> wohooo! Ghc 6.12 in Debian Testing :D (previous was 6.8)
13:23:17 <lowasser> nostrand: Woooooooooooooo!
13:23:36 <FliPPeh> Megant: is that part of the syntactic sugar of the do-notation?
13:23:49 <Megant> yes
13:23:59 <FliPPeh> Nice
13:24:11 <eevar> nostrand, nice. same package structure as before, or is there a haskell-platform package now?
13:27:08 <nostrand> eevar: same as before i think
13:28:05 <maltem> Nice, there's now to be a -with-rtsopts linker flag in ghc
13:28:57 * GaMer13 has a little question
13:29:56 <GaMer13> I've just installed GHC 6.12.1 and extracted the tar bal of Cabal, but whenever I want to build it (after configuring it) it says: "Setup: ar is required but it could not be found."
13:30:29 <pbuetow> i'd install ar
13:30:35 <GaMer13> But what IS ar?
13:30:44 <GaMer13> Can't find it anywhere
13:30:44 <maltem> GaMer13, what OS is that you're on?
13:30:50 <GaMer13> Windows 7
13:31:09 <maltem> ar is the archiver, used for... er, linking? Something related to that
13:31:21 <pbuetow>        ar - create, modify, and extract from archives
13:31:28 <pbuetow> at least on linux
13:31:34 <danderson> it's used to construct static libraries on unix systems, yeah
13:31:35 <aavogt> hmm, I'd expect it to come with ghc then?
13:31:52 <danderson> it's part of the binutils suite
13:31:55 <maltem> On linux etc. ar is part of GNU binutils
13:32:16 <GaMer13> Hmm, it's inside the mingw map
13:32:18 <monochrom> ar creates *.a files
13:32:24 <monochrom> static libs
13:32:30 <GaMer13> But apparently it cannot find that file
13:32:44 <GaMer13> C:/ghc/mingw/bin/ar.exe does exist
13:32:54 <danderson> GaMer13: I assume you specifically want GHC 6.12 ?
13:33:06 <GaMer13> Yes, because I want to use wxHaskell
13:33:10 <danderson> because if not, the Haskell Platform (w/ ghc 6.10, current stable) has a Windows installer available
13:33:12 <Mathnerd314> GaMer13: is C:/ghc/mingw/bin on your
13:33:13 <danderson> ah.
13:33:14 <Mathnerd314> path?
13:33:23 <GaMer13> Oh, I'll try adding it to the path, good suggestion
13:35:19 <GaMer13> Yay, worked
13:42:23 <yitz> nostrand: hmm now let's see if i can get that to work on stable via a pin.
13:44:41 <fax> @oies 1,2,3,4,5
13:44:42 <lambdabot>  The natural numbers. Also called the whole numbers, the counting numbers or ...
13:44:42 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
13:44:47 <fax> @oies 1,2,3,4,5,7
13:44:48 <lambdabot>  Prime powers p^k (p prime, k >= 0).
13:44:48 <lambdabot>  [1,2,3,4,5,7,8,9,11,13,16,17,19,23,25,27,29,31,32,37,41,43,47,49,53,59,61,64...
13:54:21 <zygoloid> @oeis 1,2,3,4,5,6,8
13:54:21 <lambdabot>  Positive divisors of n!, listed in increasing order for each n, a new row fo...
13:54:21 <lambdabot>  [1,1,2,1,2,3,6,1,2,3,4,6,8,12,24,1,2,3,4,5,6,8,10,12,15,20,24,30,40,60,120,1...
13:56:42 <Veinor> @oies 1
13:56:43 <lambdabot>  a(n) is the number of unique reduced words of length n (i.e. all possible le...
13:56:43 <lambdabot>  [1,5,20,70,240,810,2730,9180,30870,103770,348840,1172610,3941730,13249980,44...
13:56:44 <krasno> What does lambdabot run on, and can I get it offline?
13:56:49 <krasno> Or at least part of it offline?
13:57:03 <medfly> @hackage lambdabot
13:57:03 <lambdabot> http://hackage.haskell.org/package/lambdabot
13:57:25 <krasno> well, that works... thanks
13:59:42 <ezyang> http://blog.ezyang.com/2010/02/type-manipulation-tricks-of-the-trade/#comment-176 <- I don't know the answer to this guys question. Does anyone else know?
14:06:27 <sepp2k> @hoogle Int -> Int -> Int
14:06:27 <lambdabot> Data.Time.Calendar.MonthDay monthAndDayToDayOfYear :: Bool -> Int -> Int -> Int
14:06:27 <lambdabot> Data.Fixed mod' :: Real a => a -> a -> a
14:06:28 <lambdabot> Prelude max :: Ord a => a -> a -> a
14:06:56 <sepp2k> Why doesn't that list the arithmetic operators?
14:07:12 <sepp2k> @hoogle Num a => a -> a -> a
14:07:12 <lambdabot> Prelude (*) :: Num a => a -> a -> a
14:07:12 <lambdabot> Prelude (+) :: Num a => a -> a -> a
14:07:13 <lambdabot> Prelude (-) :: Num a => a -> a -> a
14:07:18 <ezyang> sepp2k: A lot of arithmetic operators have more general types
14:07:27 <krasno> but it seemed to unify the more general max and mod'
14:07:36 <krasno> *unify -> specialize
14:09:01 <int-e> mod' is slightly more specific than (+) actually
14:09:06 <int-e> type-wise
14:11:16 <zygoloid> ezyang: the answer to that guy's question is the same reason you can't reorder the type parameters in class instances...
14:11:37 <tsou> If i have created my own show for a data type, is there way to show a term the way it would be shown if I had just derived Show?
14:12:25 <zygoloid> ezyang: f a1 == (c1 -> c2) -> h c1 -> h c2 == (c1 -> c2) -> (h c1 -> h c2) == (->) (c1 -> c2) (h c1 -> h c2). so f = (->) (c1 -> c2), and a1 = (h c1 -> h c2).
14:12:55 <ezyang> zygoloid: So, it just uses the standard mechanism?
14:13:10 <zygoloid> right, it's completely normal once you factor out the infixness
14:13:36 <ezyang> cool. I'll quote you in my reply
14:14:49 <Botje> tsou: don't think so.
14:15:05 <tsou> Botje: thanks :(
14:15:57 <Botje> tsou: you could define your custom Show instance for a newtype?
14:16:06 <yitz> ezyang: "...there's only one reasonable functor instance" not just that - the type is t1 -> t2 and that has a functor instance. but i think that's exactly what zygoloid is saying...
14:16:38 <ezyang> yeah, I think so too
14:16:48 <tsou> Botje: hmm I'm not sure i follow, how would that help?
14:17:30 <Botje> tsou: you could derive the Show instance for your datatype, and then write a newtype Foo = Foo YourRealDataStructure with your custom show instance
14:17:35 <Botje> then you can compare both
14:18:40 <tsou> Botje: but not on the same value, since it would have a different type
14:18:50 <integral> there's a show implementation in the generics stuff iirc
14:19:18 <tsou> Botje: I mean, i have a value v, and show v returns my show's value, but i want to see what the original show would return on this exact v
14:19:27 <tsou> integral: thanks, i'll look it up
14:19:33 <integral> Data.Generics.Text.gshow
14:19:48 <Botje> tsou: yes, so you write newtype Foo = Foo YourType and override show for that.
14:20:05 <Twey> Hm…
14:20:11 <Botje> (and you show what's in YourType instead of Foo Yourtype, obviously)
14:20:23 <Twey> Wouldn't it be nice to have all newtypes automatically be Functors of some kind?
14:21:08 <Twey> newtype String = String [Char]; instance Functor String where fmap f (String cs) = String $ f cs
14:21:08 <tsou> Botje: ah!
14:21:14 <ezyang> Twey: Generalized instance deriving!
14:21:15 <Twey> (yes, I know the kinds don't match, but they *should* :þ)
14:21:26 <tsou> Botje: ok, now i got you, thanks, that would indeed work
14:24:39 <sinelaw> hey
14:24:44 <Guest69279> argh.
14:25:21 <sinelaw> hey
14:27:43 <sinelaw> I SAID
14:28:02 <jlouis> HEY!
14:28:27 <sinelaw> hi :)
14:28:56 <jlouis> sinelaw: you ought to boing a bit. We have too little boing in here
14:29:14 <sinelaw> boing
14:29:18 <ezyang> "WALK TIS WAY!"
14:29:53 <sinelaw> i'm like an endofunctor on the category of your zygomorphisms, dude
14:33:06 <sinelaw> so what's a-brewin'?
14:33:08 <altmattr> yitz: thanks
14:33:21 <yitz> np
14:33:49 <yitz> there's also Data.Fixed, which does the exponent in the type system. that would work too
14:36:21 <notabel> does anyone know how to read on an IO handle with a byte limit, without going down to the low-level interface?  something like: > line <- hGetLineN h 512
14:36:37 <Mathnerd314> Twey: there's the DeriveFunctor extension, which lets you write deriving Show, in 6.12
14:36:45 <Mathnerd314> *deriving Functor
14:37:43 <sm> quick poll: any interest in reviving #haskell-web for practical discussion of implementing web apps ?
14:37:52 * Twey raises a hand
14:38:20 <Twey> My college project for this year is a Web application in Haskell, so hell to the yes
14:39:02 * sm puts it on auto-join.. all practical web hackers welcome
14:44:09 <Axman6> sm: i always get interested when i see a new web framework... then i realise how much i dislike web design/programming :P
14:44:47 <sm> Axman6: great, that's a good comment for #haskell :)
14:45:51 <sm> just kidding. Mostly. I'd be happy if the new channel is more practical than this one sometimes is
14:46:38 <sm> But I'm not the boss. However I did get to set the topic, woohoo!
14:50:45 <hcube> hi!
14:50:59 <hcube> is there a gsoc2010 related channel?
14:53:06 <nagnatron> hcube: #haskell-soc
14:53:36 <hcube> thanks :)
15:03:07 <Peaker> http://www.haskell.org/haskellwiki/Transformers -- is not in English... I wrote a little monad transformers tutorial - is that a good place to put it?
15:03:07 <lambdabot> Peaker: You have 1 new message. '/msg lambdabot @messages' to read it.
15:04:04 <arw> Peaker: because programmers make bad designers.
15:04:15 <arw> Peaker: and designers make bad programmers.
15:04:27 <Peaker> what?
15:04:40 <fax> hackers make good painters
15:04:51 <arw> Peaker: oh, sorry. wrong channel
15:06:06 <Peaker> does non-English belong in Haskellwiki?
15:06:13 <Peaker> is #haskell out of time-zone atm?
15:06:46 <danderson> probably close to "off for the weekend"
15:06:53 <danderson> it's usually quieter on sundays.
15:07:03 <chrisdone> sundays are indeed slow
15:08:40 <RayNbow> Peaker: perhaps you could move Transformers to Ro/Transformers and update all the links (on two pages) to the new location
15:09:02 <Peaker> how do I put code in haskellwiki? I tried <nowiki> but that doesn't look good
15:09:03 <RayNbow> and then write your English article @ Transformers
15:09:19 <Peaker> RayNbow: My article is a tutorial, though, so I guess I'll put it in "Monad Transformers Tutorial"
15:09:26 <RayNbow> hmm... <hask>I thought it was like this</hask>
15:09:45 <gwern> this hackage script would be much more useful if people would actually add the repo metadata to their .cabals
15:09:55 <djahandarie> Nothing like some acronyms to make things more confusing
15:09:57 <gwern> RayNbow: thought it was <haskell></haskell>
15:10:12 <RayNbow> gwern: yeah, you're right... just looked it up
15:10:16 <Peaker> cool, thanks
15:10:34 <RayNbow> <hask> is for inline stuff
15:10:35 <gwern> on wikipedia it's <source lang="haskell"> or something hideous like that
15:10:43 <RayNbow> <haskell> for code blocks
15:14:37 <Peaker> ok, I put http://www.haskell.org/haskellwiki/Monad_Transformers_Tutorial
15:16:19 * hackagebot wikipedia4epub 0.0.5 - Wikipedia EPUB E-Book construction from Firefox history.  http://hackage.haskell.org/package/wikipedia4epub-0.0.5 (RadoslavDorcik)
15:21:52 <gwern> oh no. does every repo type differ in format?
15:22:02 <gwern> git gets formatted different from  darcs?
15:22:03 <gwern> wth
15:22:56 <gwern> it must be the git:// thing
15:23:02 <gwern> preflex: sen dcoutts
15:23:06 <gwern> preflex: seen dcoutts
15:23:06 <preflex>  dcoutts was last seen on #haskell 15 hours, 31 minutes and 57 seconds ago, saying: byorgey: nope
15:23:10 <gwern> preflex: seen dcoutts_
15:23:10 <preflex>  dcoutts_ was last seen on #ghc 9 days, 16 hours, 12 minutes and 54 seconds ago, saying: it allows record members to be ordered arbitrarily, which makes deeply nested records expensive I think
15:23:37 * gwern sighs. I'll just hack in git support
15:23:46 <ivanm> what are you hacking it into?
15:24:00 <ivanm> gwern: AFAIK it's done differently because git repos aren't valid URLs...
15:24:08 <gwern> ivanm: a tagsoup downloader
15:25:04 <ivanm> come again?
15:25:11 <ivanm> you're downloading poorly formatted HTML?
15:27:26 <gwern> ivanm: they get formatted differently
15:27:51 <gwern> one is a TagText text (TagOpen _), the other is just TagText text
15:28:07 * ivanm still isn't sure he understands what gwern is wanting to do
15:32:18 <gwern> non-exhaustive pattern in lambda?
15:32:29 <gwern> but it's filter, it should just return [] if nothing matches...
15:32:45 <gwern> what could go wrong with 'extractGitRepo arg = filter (λ(TagText z) → "git clone " `isInfixOf` z) arg'?
15:33:02 <twink> use ~
15:33:35 <mauke> one of the arg is not a TagText
15:35:31 <pokoko222> hello mortals
15:35:36 <Peaker> any feedback on http://www.haskell.org/haskellwiki/Monad_Transformers_Tutorial ?
15:35:47 <Zao> pokoko222: Hello, submortal.
15:35:51 <pokoko222> i want to write algorithms for algebra 2, i need books, what i should look for, computational algebra?
15:35:58 <Botje> 4~
15:36:00 <Botje> oops
15:36:05 <Peaker> well, it's not really a comprehensive tutorial, but an implementation from scratch of MaybeT, plus explaining the rationale behind the way it's built
15:36:06 <Botje> what's algebra 2 ?
15:36:35 <mauke> electric boogaloo
15:36:35 <Peaker> I guess it needs to be extended to include "recommended practice" for newtype'ing a stack and defining named lifters
15:36:49 <pokoko222> http://www.cliffsnotes.com/study_guide/Sum-or-Difference-of-Cubes.topicArticleId-38949,articleId-38892.html Botje all to the left
15:37:10 <gwern> twink: ~ doesn't help
15:39:16 <Botje> ah
15:39:30 <Botje> no idea, then :(
15:41:29 <ddarius> Cabron, cabron
15:46:42 <sepp2k> Has anyone ever attempted to define a typed lambda calculus without primitive types, where types describe the structure of functions? I.e. all values are functions, but you can still distinguish between different types of functions. Something like:  "The function  'forall a. \f: a->a. \x: a. a' has type Nat. For all Nats n the function 'forall a. \f: a->a. \x: a. f (n f x)' also has type Nat. No other function has type Nat."
15:47:44 <jlouis> pokoko222: do you know git, by any chance?
15:48:05 <pokoko222> jlouis name sounds familiar but have no idea what it is
15:48:19 <jlouis> pokoko222: it is a revision control system
15:48:25 <pokoko222> ah that yeah
15:48:40 <jlouis> though darcs is more used in the Haskell community, being written in Haskell
15:48:52 <pokoko222> i dont use such things, it takes u days to install them
15:48:59 <pokoko222> i just organize my things
15:49:31 <jlouis> you should strive to learn a couple of them one day. They help a lot, even when a single lone programmer writes code
15:49:42 <pokoko222> i dont think so
15:49:43 <FliPPeh> Has anyone gotten experience with haskell's CGI? I want to include some hotlinks to the same page, with a GET argument to it, but keep the existing arguments. Say the page was generated with "?port=6600", and on the page there's a link to "?act=pause", how can I generate a link (in pure code) to "?port=6600&act=pause"?
15:49:48 <akappa> pokoko222, or you should start using linux
15:49:54 <pokoko222> i do
15:50:13 <akappa> pokoko222, git takes few minutes to install, in all distributions
15:50:24 <FliPPeh> Took 10 seconds here
15:50:28 <FliPPeh> pacman -S git
15:50:37 <jlouis> pokoko222: my point is that any contribution to any project will need you to understand tools like those
15:50:59 <jlouis> or at the very least understand diff and patch
15:51:12 <akappa> even for self-use they are good
15:51:19 <Botje> subversion is the bare minimum.
15:51:24 <sm> a few minutes to install, a lifetime to learn :)
15:51:27 <pokoko222> boring stuff man, i cant even find this git in synaptic, i wont waste my time
15:51:36 <jlouis> pokoko222: git-core
15:51:37 <akappa> think at github and sharing your project up to date to different machines or backup it
15:51:46 <gwern> pokoko222: synaptic is for losers
15:51:52 <pokoko222> as sm said, i dont need that stuff, life time to learn... i got smarter things to do
15:51:54 <gwern> real men do 'apt-cache search git'
15:51:54 <akappa> pokoko222, apt-cache search git
15:52:06 * akappa is a real man
15:52:06 <FliPPeh> real men use pacman!
15:52:12 <dancor> i switched to the "judy" package and for non-tiny cases my program now segfaults: 0xb7f41425 in JudyLNext () from /usr/lib/libJudy.so.1
15:52:17 <FliPPeh> No pun int... ah...
15:52:39 * gwern is a real boy!
15:52:57 <gwern> dancor: what do you expect from a c lib?
15:53:05 <dancor> sigh
15:53:31 <dancor> but somehow i suspect this would work if i used it in c
15:54:08 <dancor> i'm afraid that i'll do it to prove it and then i'll already have finished my program in c and that will be the end
15:54:34 <FliPPeh> In C I used to set up a signal handler for SIGSEGV consisting of 'printf("SH§"$");' and various other curses
15:54:45 <FliPPeh> So I didn't have to cuss myself
15:55:07 <dancor> developer efficiency
15:55:30 <FliPPeh> Yep.
15:55:53 <Twey> Good thinking
15:56:09 <dancor> i guess i'll try the latest libjudy
15:56:11 <akappa> sigsev is catchable?
15:56:14 <FliPPeh> Yep
15:56:19 <FliPPeh> But you'll have to exit anyways
15:56:23 <akappa> of course :P
15:56:34 <FliPPeh> At least you can do a little cleanup if you wanted
15:56:36 <FliPPeh> Or just cuss.
15:56:55 <akappa> I remember that SIGSEV is one of the uncatchable signals, evidently I remember wrongly :P
15:57:04 <dancor> hm debian actually has latest libjudy, surprisingly
15:57:06 <FliPPeh> Last time I tried, it worked fine ;D
15:57:13 <Twey> It's one of Linux's little POSIX-incompatibilities
15:57:30 <FliPPeh> All of them are catchable I think, but only a handful of them can be ignored without exiting
15:57:49 <Twey> As I remember it
15:57:51 <FliPPeh> But now back to my CGI programs here
15:57:57 * hackagebot data-category 0.0.3 - Restricted categories  http://hackage.haskell.org/package/data-category-0.0.3 (SjoerdVisscher)
15:58:44 <sm> FliPPeh: using http://hackage.haskell.org/package/cgi ?
15:59:03 <FliPPeh> Yes, but it's only indirectly related to it
15:59:06 <mreh> how can I get a mutable value in IO?
15:59:08 <FliPPeh> Have you seen my question, sm?
15:59:20 <FliPPeh> I want to include some hotlinks to the same page, with a GET argument to it, but keep the existing arguments. Say the page was generated with "?port=6600", and on the page there's a link to "?act=pause", how can I generate a link (in pure code) to "?port=6600&act=pause"?
15:59:42 <FliPPeh> Maybe it can be done by pure XHTML means
15:59:45 <FliPPeh> But I doubt it
15:59:47 <mreh> scratch that
15:59:57 <jlouis> mreh: an IORef?
15:59:58 * FliPPeh scratches
16:00:24 <kmc> mreh, technically "mutable value" is a contradiction in terms
16:00:28 <sm> FliPPeh: getVar the appropriate env var ? getVars to see them all
16:00:34 <kmc> IORef gives you the basic mutable cell, into which you can put different values over time
16:00:39 <kmc> there are fancier ones if you need concurrency etc.
16:00:47 <mreh> jlouis: thanks, wrong abstraction in this case: bad design choice
16:00:51 <FliPPeh> sm: But that's not in pure code :(
16:01:07 <sm> FliPPeh: or getInputs and rebuild the url including them
16:01:12 <jlouis> MVars and TVars :P
16:01:19 <mreh> kmc: does it always point to the same cell?
16:01:30 <sm> no, you'll have to get it from the cgi environment somehow, how else could your pure code know the url ?
16:01:40 <mreh> or is the IORef a pure vale also
16:02:09 <mreh> must be
16:02:45 <kmc> every value is a pure value
16:03:09 <mreh> yes :)
16:03:42 <mreh> what I need is to record the time elapsed since the beginning of a function call
16:04:09 <kmc> in C the number 19 always points to the 19th byte of memory, but you can store different stuff there from time to time
16:04:25 <kmc> and you can of course use types like IORef (IORef Char)) if necessary
16:04:56 <kmc> mreh, i've seen code to do that around but i don't recall where
16:05:17 <mreh> it's Yampa
16:05:28 <mreh> but it needs to be done in IO
16:05:39 <kmc> in an IO action you can get a timestamp, force some value to whnf (or nf if you need), then get another timestamp
16:06:30 <mreh> kmc: thanks for the tip
16:06:42 <mreh> I'm trying to think how it might behave if I didn't do the `seq`
16:06:48 <mreh> probably very slowly
16:08:00 <kmc> well if you're bracketing something in order to time it, you have to force it in the middle
16:08:06 <kmc> otherwise you are timing nothing
16:34:55 <tsou> I'm trying to build a parser with Parsec.  'many' matches zero or more, 'many1' matches one or more..  Is there a built-in parser that matches "zero or one"?
16:35:37 <benmachine> optional?
16:36:18 <ivanm> @hoogle optional
16:36:18 <lambdabot> Control.Applicative optional :: Alternative f => f a -> f (Maybe a)
16:36:18 <lambdabot> Text.Parsec.Combinator optional :: Stream s m t => ParsecT s u m a -> ParsecT s u m ()
16:36:19 <lambdabot> Text.ParserCombinators.ReadP optional :: ReadP a -> ReadP ()
16:37:15 <benmachine> :t Just <$> p <|> pure Nothing
16:37:16 <lambdabot>     Ambiguous occurrence `<|>'
16:37:17 <lambdabot>     It could refer to either `Control.Applicative.<|>', imported from Control.Applicative
16:37:17 <lambdabot>                           or `Lava.<|>', imported from Lava
16:37:25 <benmachine> :t Just <$> p Text.Parsec.<|> pure Nothing
16:37:26 <lambdabot>     Couldn't match expected type `Text.Parsec.Prim.ParsecT s u m a'
16:37:26 <lambdabot>            against inferred type `Expr'
16:37:27 <lambdabot>     In the second argument of `(<$>)', namely `p'
16:37:33 <benmachine> :t \p -> Just <$> p Text.Parsec.<|> pure Nothing
16:37:34 <lambdabot> forall a s u (m :: * -> *). (Monad m) => Text.Parsec.Prim.ParsecT s u m a -> Text.Parsec.Prim.ParsecT s u m (Maybe a)
16:38:49 <tsou> thanks ;)
16:39:01 <benmachine> :t \p -> Just <$> p <|> pure Nothing
16:39:01 <lambdabot>     Ambiguous occurrence `<|>'
16:39:02 <lambdabot>     It could refer to either `Control.Applicative.<|>', imported from Control.Applicative
16:39:02 <lambdabot>                           or `Lava.<|>', imported from Lava
16:39:06 <lowasser> aughghhhh
16:39:10 <benmachine> oh I did that already whoops
16:39:27 <benmachine> :t let (<|>) = (Control.Applicative.<|>) in \p -> Just <$> p <|> pure Nothing
16:39:28 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f (Maybe a) -> f (Maybe (Maybe a))
16:39:34 <benmachine> err
16:40:14 <benmachine> :t let (<|>) = (Control.Applicative.<|>) in \p -> (Just <$> p) <|> pure Nothing
16:40:15 <lambdabot> forall a (f :: * -> *). (Alternative f) => f a -> f (Maybe a)
16:41:15 <ivanm> @type Lava.<|>
16:41:16 <lambdabot> parse error on input `Lava.<|>'
16:41:22 <ivanm> @type (Lava.<|>)
16:41:23 <lambdabot> Signal Bool -> Signal Bool -> Signal Bool
16:41:27 <ivanm> what's Lava?
16:45:50 <FliPPeh> How can I turn the number 2 to "02" but keep 10 as "10"?
16:46:00 <FliPPeh> Time display :)
16:46:29 <ivanm> printf
16:46:40 <ivanm> or Numeric has some printing things IIRC
16:46:41 <byorgey> > printf "%2d %2d" 2 10
16:46:42 <lambdabot>   Ambiguous type variable `a' in the constraints:
16:46:43 <lambdabot>    `Text.Printf.PrintfType ...
16:46:47 <FliPPeh> I don't want to print it out
16:46:47 <byorgey> > printf "%2d %2d" 2 10 :: String
16:46:48 <lambdabot>   " 2 10"
16:46:53 <FliPPeh> I want to turn it into a string
16:46:59 <ivanm> FliPPeh: which is what printf does...
16:47:00 <FliPPeh> And output it later inside HTML
16:47:03 <byorgey> > printf "%02d %02d" 2 10 :: String
16:47:04 <lambdabot>   "02 10"
16:47:09 <byorgey> there we go
16:47:10 <FliPPeh> Hm!
16:47:14 <ivanm> FliPPeh: printf can do either
16:47:18 <FliPPeh> Ah nice
16:47:20 <ivanm> @type printf
16:47:21 <lambdabot> forall r. (PrintfType r) => String -> r
16:47:25 <byorgey> printf is sneakliy polymorphic in its output type
16:47:25 <ivanm> @instances PrintfType
16:47:26 <lambdabot> Couldn't find class `PrintfType'. Try @instances-importing
16:47:30 <byorgey> *sneakily
16:47:37 <ivanm> byorgey: s/ in its output type//
16:47:46 <ivanm> @hoogle PrintfType
16:47:46 <lambdabot> Text.Printf class PrintfType t
16:47:46 <lambdabot> Text.Printf class HPrintfType t
16:47:56 <ivanm> @instances-importing Text.Printf PrintfType
16:47:56 <lambdabot> (a -> r), IO a, [c]
16:48:09 <ivanm> :o it can output to generic lists? :o
16:48:09 <byorgey> I technically stand by my statement due to currying. =)
16:48:16 <ivanm> byorgey: heh
16:48:29 <ivanm> byorgey: my objection was that it was just sneaky in general
16:48:36 <byorgey> agreed.
16:48:36 <ivanm> not that you were wrong
16:50:56 <dancor> i found a workaround hack for my judy segfault that might allow me to zero in on it later even
16:51:12 <ivanm> this is dons' judy library?
16:51:23 <dancor> ivanm: ya
16:51:39 <ivanm> so who does it look like is at fault? you or dons?
16:52:05 <dancor> idk, http://github.com/dancor/goldbug/commit/5d7c6ca
16:52:21 <dancor> i mean i doubt it's dons
16:52:49 <ivanm> then again, dons _is_ human...
16:52:53 <dancor> it could always also be judy or ghc or ghc-ffi
16:52:59 <ivanm> true
16:53:02 <dancor> or something "configurational"
16:54:53 <dancor> it could be related to using two judy arrays at once
16:56:04 <dancor> i couldn't get HsJudy to run at all, that lib might be tied to an older version of judy currently
16:56:17 <ivanm> yeah
16:56:46 <ivanm> I've never used judy before and have limited FFI knowledge, but the "two judy arrays at once" rationale sounds plausible
16:56:54 <ivanm> try to get a minimal test case?
16:57:02 <dancor> i'll try more later
16:57:53 * edwardk waves hello
16:58:31 * ivanm waves hello back
16:58:52 <fax> hey
16:58:59 <hcube> hi
16:59:13 <fax> hcube you write a 3D engine
16:59:28 <hcube> yes :)
17:00:05 <hcube> in last 2 days i wrote a quake 3 bsp map loader and viewer
17:00:14 <fax> wow cool!
17:00:15 <hcube> it is independent from frag
17:00:29 <fax> hcube do you make them using gtkradiant?
17:00:32 <edwardk> hcube: nice. i wrote one of those once. never tried in haskell though.
17:00:37 <hcube> and its very short
17:00:44 * fax has never done this
17:00:46 <hcube> ~800 lines of haskell code
17:00:57 <jcreigh> that's "very" short?
17:00:59 <fax> that is impressive
17:01:05 <nostrand> uuh, i can't get my vector-code working, are there some more examples than "Numeric_Haskell:_A_Vector_Tutorial"?
17:01:07 <fax> jcriegh that's a page of code
17:01:10 <fax> roughly?
17:01:15 <edwardk> jcreigh: compared to the equivalent c? =)
17:01:18 <ivanm> jcreigh: presumably for such things
17:01:31 <ivanm> nostrand: examples in what sense?
17:01:45 <ivanm> and do you mean using the vector library?
17:01:52 <nostrand> ivanm: yep
17:01:53 <jcreigh> fax: 800 lines is a "page"?
17:01:59 <jcreigh> my definitions do not line up with anybody. :)
17:02:09 <edwardk> jcreigh: heh, only if you use very small print ;)
17:02:15 <jcreigh> I'm sure it's shorter than comparable C/C++
17:02:19 <hcube> now i'm trying to finish the new bullet physics binding and make a small example with bsp viewer and bullet
17:02:19 <ivanm> (possibly have a look at vector-algorithms for ideas?)
17:02:25 <nostrand> ivanm: i'm trying to do som mutations
17:02:37 <ivanm> that doesn't sound good...
17:02:38 <fax> jcreigh: well is it two pages?
17:02:51 <edwardk> fax: closer to 10
17:03:03 <jmcarthur> 800 lines sounds very long to me
17:03:21 <hcube> :)
17:03:40 <edwardk> jmcarthur: its a somewhat painful process, you needto load the bsp, the textures, the pvs, moving brushes, shaders, etc.
17:03:42 <hcube> i can show it if you want
17:03:54 <edwardk> and thats before you even bother to show anything
17:03:59 <jcreigh> yeah, dealing with file formats tends to be a pain.
17:04:16 <ivanm> theorbtwo: any particular reason for you preferring your *two version?
17:04:17 <fax> hm
17:04:17 <jmcarthur> edwardk: i have to admit i have not written equivalent code myself and therefore do not have any qualifications to base my assessment on
17:04:19 <hcube> ok, i upload it to my google code sn
17:04:21 <fax> how many lines fit on a page?
17:04:21 <hcube> *svn
17:04:28 <fax> 80 lines?
17:04:34 <fax> maybe I was thinking of words rather than lines
17:04:40 <fax> quite incredible to be THAT wrong
17:05:14 <fax> hcube so you don't make BSPs?
17:05:30 <jmcarthur> i've said it before, but i am tremendously happy that darcs finally has hunk editing
17:05:33 <edwardk> fax: traditionally? 60 or 66 lines per page. nowadays? depends on your font size
17:05:36 <jmcarthur> i've been using it a lot
17:05:46 <theorbtwo> ivanm: There are lots of "theorb"s around, or at least a decent few -- named after the elecronica act.
17:05:53 <theorbtwo> I'm the only theorbtwo.
17:06:00 <jmcarthur> edwardk: 60-66 sounds like traditional number of letters per line, to me
17:06:09 <hcube> fax: no
17:06:40 <mreh> I don't what reactimate wants to know with the DTime value in sense
17:06:44 <ivanm> theorbtwo: oh
17:06:57 <jmcarthur> or rather the traditional number of ems per line, iirc
17:07:09 <jmcarthur> although now i'm second guessing myself
17:07:23 * jmcarthur grabs his elements of typography book
17:07:32 <byorgey> jmcarthur: that sounds right to me
17:07:49 <jmcarthur> *elements of typographic style
17:07:52 <fax> @let c n k = ((/)`on`product) [n-k+1..n] [1..k]
17:07:53 <theorbtwo> It's also the traditional length of a page on an 80-char wide 8.5 x 11 page.
17:07:53 <lambdabot>  Defined.
17:08:34 <edwardk> here is a random comment on the internet mentioning the 66 LPP measure i gave, lemme look around for references. i was thinking back to the dot matrix era.
17:08:46 <theorbtwo> edwardk: Right, me too.
17:08:50 <edwardk> where i could pretty consistently print at 66lpp ;)
17:09:32 <hcube> ok, maybe 800 lines is too much
17:09:33 <jmcarthur> 66 character line is considered "best" most of the time, according to TEoTS
17:10:25 <edwardk> jmcarthur: sounds about right
17:10:42 <jcreigh> Sorry, I didn't mean to cause a typography riot. :)
17:10:57 <hcube> http://code.google.com/p/lambdacube/source/browse/#svn/trunk/bsploader
17:11:17 <hcube> check it :)
17:11:42 <edwardk> hcube: i like the loader code, that is really clean
17:12:11 <drk-sd> nice
17:12:46 <hcube> thanks :)
17:13:12 <fax> alise jcreigh hehehe
17:13:15 <fax> ops -alise
17:13:29 <drk-sd> (but on the other hand: "omg! you're using svn! die agent of the devil!")
17:13:43 <bmh> drk-sd: At least it isn't CVS.
17:14:02 <jcreigh> SVN is quite decent for what it is.
17:14:03 <hcube> :D
17:14:07 <benmachine> git svn woo
17:14:10 <drk-sd> bmh: does that still exist? :p
17:14:37 <jmcarthur> SVN is just CVS wearing a newer coat and tie
17:14:45 <bmh> anyway, I'd like to package something up for hackage, but I noticed that my cabal install is very badly hosed
17:15:16 <edwardk> preflex: xseen dons
17:15:17 <preflex>  dons was last seen on freenode/#haskell 4 hours, 3 minutes and 47 seconds ago, saying: @tell tibbel http://gregorycollins.net/posts/2010/03/12/attoparsec-iteratee#comment-39671374 they're rolling their own epoll event manager
17:16:15 <ivanm> methinks he misspelt tibbe's nick...
17:16:27 <dancor> the joys of async io
17:17:34 <Mathnerd314> I want to port a game to Haskell... where should I start?
17:17:44 <fax> which game?
17:17:50 <bmh> Modern Warfare? ;-)
17:17:59 <ivanm> Mathnerd314: by learning Haskell first
17:18:28 <Mathnerd314> fax: SuperTux (http://supertux.lethargik.org/)
17:18:43 <kmc> @quote cvs
17:18:43 <lambdabot> LinusTorvalds says: The slogan of Subversion for a while was 'CVS done right', or something like that, and if you start with that kind of slogan, there's nowhere you can go. There is no way to do
17:18:43 <lambdabot> CVS right.
17:18:54 <Mathnerd314> ivanm: I think I know enough to start
17:19:20 <fax> Mathnerd314: oh yeah, this is doable!
17:20:57 <Mathnerd314> libraries... there's an OpenGL port, right?
17:21:15 <ivanm> why would you bother porting a game that is still under (at least semi-) active development?
17:21:49 <theorbtwo> ivanm: Fun?
17:21:50 <jmcarthur> Mathnerd314: opengl bindings, yes
17:22:17 <edwardk> hcube: so when are you going to hack on directx 11 bindings for haskell. so i can come home and start working in my favorite language again ;)
17:23:08 <hcube> edwardk: i'm on linux :)
17:23:13 <ivanm> theorbtwo: yes, but aren't there other games that might be just as fun to re-write/port which are _not_ under active development?
17:23:22 <edwardk> hcube: well, i figured there was no harm in asking ;)
17:23:32 <theorbtwo> Well, quite possibly.
17:23:35 <ivanm> plus, whilst the code might be open source, the images usually aren't
17:23:53 <theorbtwo> OTOH, rewriting a game from 1990 doesn't require much in the way of performance.
17:24:07 <theorbtwo> ivanm: Only an issue if you don't own the game.
17:25:28 <ivanm> huh?
17:25:34 <theorbtwo> (That was moral advice, not legal advice, BTW.  It might violate the EULA.)
17:25:51 <ivanm> theorbtwo: the images are usually not licensed freely even when the code is
17:26:00 <ivanm> see the blobwars controversy in fedora, etc. a year or so ago
17:26:05 <theorbtwo> ivanm: Quake 1 is open-source -- the engine, not the game files.
17:26:07 <ivanm> the firefox copyright issue in debian is similar
17:26:13 <ivanm> theorbtwo: right, stuff like that
17:26:27 <theorbtwo> If you want to play quake, buy a copy, and run it under your choice of modified version of the engine.
17:26:38 <theorbtwo> It's not that expensive.
17:27:00 <theorbtwo> Heck, I already have one, if I could be bothered to find the CD.
17:27:11 <edwardk> Sadly, I think I've probably purchased like 8 copies of quake over the years in various valu-pack forms.
17:27:52 <ivanm> heh
17:27:57 <theorbtwo> But rewriting Quake is less interesting then rewriting a modern game would be, in as much as you don't have the same sort of performance pressures to try to beat.
17:28:16 <edwardk> Sadly, I've done the same with Commander Keen, but I still can't find my the old VGA version lying around anywhere.
17:28:19 * ivanm points out that he was referring to Mathnerd314's statement that he wanted to port supertux
17:28:42 <ivanm> edwardk: I _loved_ those games
17:28:49 <theorbtwo> Yey, Keen!
17:28:49 <edwardk> ivanm: ah missed the context switch =)
17:28:58 <theorbtwo> I haven't played any Keen in ages.
17:29:03 <krey> hi, is there a tree monad?
17:29:15 <fax> krey, yes there is!
17:29:16 <theorbtwo> Oh, I missed that statement.
17:29:16 <edwardk> krey: eys
17:29:16 <ddarius> Yes, of sorts.
17:29:28 <krey> data Tree a = Leaf a | Fork a (Tree a) (Tree a)
17:29:32 <fax> tree monad is a free monad, isn't it
17:29:33 <krey> is what i'm looking for
17:29:39 <aavogt> how do you assure associativity?
17:29:40 <ddarius> fax: yes
17:29:52 <fax> that 'a' in Fork, I don'tlike
17:30:00 <krey> i need it
17:30:12 <edwardk> krey: instance Monad Tree where return = Leaf; Leaf a >>= f = f a; Fork a l r >>= f = ... something more complicated
17:30:17 <ddarius> aavogt: It's not a MonadPlus w.r.t. observational equality.
17:30:59 <krey> can someone give me a join?
17:31:10 * hackagebot html-minimalist 0.2 - Minimalist haskell html library  http://hackage.haskell.org/package/html-minimalist-0.2 (RohanDrape)
17:31:28 <edwardk> you need to perform the tree merge in the Fork a l r >>= f = ... case which is why i didn't write it out. if you think about it. you can do (l >>= f) and (r >>= f) but you'll also wind up with a tree from 'f a', you then need to put those trees together.
17:31:35 <edwardk> the monad isn't uniquely determined
17:31:42 <edwardk> you need a rule for how you glue trees together
17:31:50 <krey> oh
17:31:51 <krey> i see
17:31:56 <krey> can you do the same with lists?
17:32:00 <edwardk> and that will depend on your domain
17:32:09 <krey> are there several list monads?
17:32:15 <edwardk> er problem domain, not domain in a function sense
17:32:41 <edwardk> nah, lists use the fact that list is a 'free monoid' to determine how to unfold the list. it basically just inserts all of the results inline
17:33:12 <krey> I need to unfold this tree from a single elements
17:33:15 <krey> -s
17:33:31 <krey> with exceptions
17:33:50 <krey> ie. if the unfold goes wrong at any point, everything breakes
17:33:59 <edwardk> why do you want a monad? i mean, would an anamorphism do?
17:34:18 <krey> yeah, i guess
17:34:26 <krey> but i was hoping i could get nicer code
17:35:50 <krey> so, I needs to unfold trees
17:35:54 <krey> with exceptions
17:35:59 <krey> any nice way of doing it?
17:36:04 <edwardk> krey: well, you can still go through and build that monad like mentioned above, you just need to define how you interleave trees
17:37:02 <krey> well all I ever need to do is to grow a new branch from a leaf
17:37:14 <krey> so forks should be untouched
17:37:27 <edwardk> the problem is you have the 'a' in the Fork as well.
17:37:28 <krey> Im not sure this helps :S
17:37:37 <edwardk> if you ditch the 'a' in Fork you can do that easily
17:37:46 <fax> can you make an isomorphism between Tree with 'a' and tree without
17:37:54 <edwardk> in fact what you'll have is called a free monad
17:38:03 <mauke> free the monads!
17:39:04 <krey> yeah, I could write the Tip Labelled Tree monad
17:39:11 <edwardk> data Tree a = Tip a | Fork (Tree a) (Tree a); instance Monad Tree where return = Tip; Tip a >>= f = f a; Fork l r >>= f = Fork (l >>= f) (r >>= f)
17:39:12 <krey> but I have this given problem
17:39:22 <krey> I was hoping to solve in a monadic way
17:40:00 <ddarius> mauke: Most monads commonly used are already free.
17:40:03 <lowasser> +1 to edwardk
17:40:25 <edwardk> lowasser: thanks =)
17:40:26 <krey> what do you mean by free?
17:40:35 <krey> and how will that help me to code this?
17:40:39 <ddarius> edwardk: Not going to write the half line type equation using category-extras?
17:41:45 <edwardk> ddarius: you mean: Free (Join (:+:)) ?
17:42:37 <Saizan> not Join (:*:) ?
17:42:42 <edwardk> krey: a free monad is in some sense the simplest monad. it satisfies only the required monad laws, and has no additional properties weighing it down.
17:42:53 <Saizan> and Free looks like it could be expanded into something with Mu :P
17:43:51 <krey> whoa, what are the additional properties?
17:44:30 <edwardk> krey: i wrote something on free monads  a long time ago, one sec.
17:44:31 <pikhq> krey: Depends on the monad.
17:44:32 <edwardk> http://comonad.com/reader/2008/monads-for-free/
17:45:06 <lowasser> ehehe, I was just reading that
17:45:27 <edwardk> someone just posted up a more general article on haskell.org http://haskell.org/haskellwiki/Free_monad which links to a longer discussion of what the hell it means to be free
17:45:49 <theorbtwo> Freedom is just a nother word for nothin left to loose.
17:45:59 <jmcarthur> MonadLiberty
17:46:09 <byorgey> if I am running some TH code at compile time and I have the name of a type constructor, anyone know a good way to get its kind?
17:46:17 <byorgey> or do I just have to implement kind inference myself? =P
17:46:25 <edwardk> the free monad defined there is a lot easier to use than the one in category-extras, but darn it, can't be used with some of the sexy bifunctor based recursion schemes ;)
17:46:42 <edwardk> byorgey: you might be hosed. kinds were not really included in TH
17:46:56 <byorgey> dang.
17:47:02 <lowasser> =(
17:47:06 <lowasser> wait, hmm
17:47:10 <edwardk> i think chakravarty was trying to bolt them in recently, are they in head?
17:47:47 <byorgey> I mean, template-haskell 2.4 supports kind *syntax*, i.e. if something was declared with a specific kind annotation I can easily get that
17:47:50 <byorgey> but that's not what I want.
17:47:54 <lowasser> wait, couldn't you just
17:48:02 <lowasser> reify?
17:48:17 <chowder> got an error while trying to install cabal
17:48:21 <byorgey> lowasser: yes, but the Info structure returned by reify doesn't tell me the kind
17:48:33 <krey> edwardk: ok, ima read this thank you
17:48:33 <lowasser> yeah, but it looks like
17:48:36 <lowasser> could you maybe recurse?
17:48:42 <dancor> are there fundamental differences between template haskell and just using one haskell file to manipulate the ast of another before compiling it?
17:48:50 <byorgey> lowasser: yes, I could implement kind inference myself =)
17:48:55 <lowasser> ah.
17:48:58 <edwardk> byorgey: http://www.mail-archive.com/cvs-ghc@haskell.org/msg13790.html is what i was thinking of
17:49:02 <lowasser> so, possible, but difficult
17:49:07 <byorgey> the kind inference algorithm is not that hard, but I'm looking for an easier way =)
17:49:08 <lowasser> and super ugly
17:49:17 <edwardk> krey: if you still have questions feel free to ask
17:49:22 <chowder> got an error while trying to install cabal. Here's the error message: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23973#a23973
17:49:28 <chowder> can anyone help? :(
17:49:31 <pikhq> dancor: I *think* that Template Haskell gives you a bit more information than just the AST.
17:49:42 <byorgey> edwardk: nope, that's not what I want: that's support for kind *annotations*
17:49:58 <lowasser> hmmm
17:50:05 <edwardk> byorgey: ah. i just recalled that that was the starting point for discussion about kinds in TH
17:50:12 <edwardk> i don't know how much farther things went
17:50:13 <lowasser> my first instinct is to write a library to do it so everybody else has an easier way later, but that's a silly instinct
17:50:28 <lowasser> (and says way too much about how I think)
17:50:28 <byorgey> edwardk: ok, I'll look into it more
17:50:28 <edwardk> lowasser: if you do, bolt it onto haskell-src-exts ;)
17:50:29 <ivanm> chowder: install time?
17:50:33 <byorgey> thanks for the info
17:50:35 <lowasser> edwardk: will comply
17:50:42 <ivanm> chowder: maybe stick with cabal-install-0.6.2
17:50:52 <lowasser> ::needs to figure out the kind inference algorithm, first::
17:51:01 <dancor> pikhq: oh like some semantic stuff is already calculated on top of just the raw ast?
17:51:32 <chowder> ivanm: I have time installed
17:51:42 <chowder> pretty much standard on UNIX-like systems
17:52:00 <ivanm> chowder: no, this is the haskell library time
17:52:03 <ivanm> "ghc-pkg list time"
17:52:08 <chowder> ooooh
17:52:14 <chowder> one second
17:52:57 <lowasser> where's GHC's kind inference system?
17:53:05 <byorgey> lowasser: it's basically type inference for the simply typed lambda calculus with a single base type
17:53:09 <chowder> ivanm: gonna install the lib from the repos
17:53:28 <Saizan> dancor: yeah, you can ask for types of things etc. http://www.haskell.org/ghc/docs/latest/html/libraries/template-haskell-2.4.0.0/Language-Haskell-TH.html#t%3AInfo
17:53:53 <lowasser> yah, I figured that much, but I'm not leet enough to translate that into an algorithm at the mo'
17:54:00 <dancor> ah thanks
17:54:13 <lowasser> silly things like "not having taken a compilers course"
17:54:25 <byorgey> lowasser: I bet if you sat down and wrote it out you could figure it out =)
17:54:33 <lowasser> that's my fallback plan
17:54:40 <lowasser> hmmm
17:54:49 <lowasser> of course, I *should
17:54:51 <lowasser> whoops
17:54:56 <lowasser> *should* be studying for finals right now
17:55:11 <krey> edwardk: what if I define trees like this: data Tree a b = Node b | Fork a (Tree a b) (Tree a b)
17:55:11 <edwardk> lowasser: you might want to look around in http://hackage.haskell.org/trac/ghc/wiki/IntermediateTypes to get a feel for how kinds are represented in ghc
17:55:26 <edwardk> krey: that works fine
17:55:27 <lowasser> sweet
17:55:30 <edwardk> krey that remains free
17:55:59 <krey> edwardk: yeah, join and map come intuitively
17:56:08 <edwardk> instance Monad (Tree a) where return = Node; Node b >>= f = f b; Fork a l r >>= f = Fork a (l >>= f) (r >>= f)
17:56:19 <krey> edwardk: ima go code now
17:56:24 <krey> thanks again
17:56:26 <edwardk> krey: cool. i think you found the right solution
17:56:31 <lowasser> obtw, edwardk: is there a simple categorical definition of free monad?
17:56:44 <ivanm> *sigh* any ubuntu users here know how to get "libcurl version >=7.19.1" so that I can cabal install darcs with curl support?
17:56:52 <edwardk> lowasser: i believe it is given on the free stuctures page of the haskell wiki
17:56:59 <lowasser> like, I understand enough category theory to understand why the implementations of the free monad are free-ish
17:57:08 <lowasser> I'm just trying to figure out what universal property they satisfy
17:57:11 <edwardk> http://haskell.org/haskellwiki/Free_structure
17:58:03 <chowder> ivanm: what version of ubuntu are you using?
17:58:11 <ivanm> 9.0.4
17:58:20 <edwardk> lowasser: though, i confess, i only tripped over the page today, and haven't read it in great depth ;)
17:58:24 <lowasser> heh
17:58:27 <ivanm> (the sysadmins aren't upgrading till next month apparently...)
17:58:28 <lowasser> oh, I think I get it
17:58:31 <psykotic> has there been any on 'compiling' applicative functor parsers? the characteristic property of applicative functors when viewed as monads is that the composition of effects is independent of intermediate results--intermediate results can affect later intermediate results and in turn the final result, but not the flow of effects. this should make it possible to do a kind of abstraction interpretation of an applicative functor parser to get a 'static parse
17:58:32 <psykotic> graph' of sorts that can be compiled independently of the parser 'actions', a la yacc, etc
17:58:42 <chowder> ivanm: its probably been updated in 9.10. Try looking for the package at packages.ubuntu.org
17:58:44 <lowasser> there's a free monad associated to a *functor*
17:58:56 <psykotic> abstract interpretation, even. sorry, just woke up.
17:58:56 <chowder> ivanm: otherwise you'll have to compile from source
17:59:02 <ivanm> blah
17:59:10 <byorgey> lowasser: right.
17:59:24 <edwardk> psykotic: yes. i spent a lot of time on it personally. though, my version isn;t quite as general as possible, since i only allow for data CFGs not codata CFGs
17:59:28 <ivanm> chowder: that link doesn't work...
17:59:30 <lowasser> which guarantees an isomorphism to any monad defined on that functor
17:59:43 <chowder> ivanm: hold on, I'll get the right one
17:59:59 <edwardk> lowasser: looks like you've got it
18:00:04 <chowder> ivanm: http://packages.ubuntu.com/
18:00:11 <Cale> lowasser: surely not an isomorphism...
18:00:20 <lowasser> morphism in each direction?
18:00:22 <edwardk> gotta go pick up my wife, bbiab
18:00:29 <byorgey> lowasser: I think you mean a homomorphism.
18:00:34 <lowasser> ...yeah.  that.
18:00:44 <lowasser> wait, do I believe that?
18:00:47 <psykotic> edwardk: any papers you can mention?
18:00:47 <lowasser> hrrm
18:00:56 <byorgey> you can get from the free monad to any other monad but you can't necessarily get back -- you might lose information.
18:01:22 <lowasser> yes
18:01:29 <lowasser> I see, it's not bidirectional, it's just an injection
18:01:56 <chowder> bbl
18:02:00 <lowasser> and the Haskell intuition is that it's the monad associated to that functor, but without any additional structure, sorta
18:02:32 <lowasser> so, hold on
18:02:33 <byorgey> right.
18:02:35 <monochrom> ivanm: 9.04 has 7.18.x only. http://packages.ubuntu.com/jaunty/libcurl4-openssl-dev
18:02:37 <lowasser> data Free f a = Return a | Roll (f (Free f a))
18:02:41 <edwardk> psykotic: hrmm, not that i have. i think one of the agda guys has a proof that monads add no power in terms of parsing ability over applicative parsers in a codata setting.
18:02:54 <lowasser> inj :: Functor f => f a -> Free f a
18:02:54 <lowasser> inj fa = Roll $ fmap Return fa
18:02:55 <edwardk> psykotic: i'll go through my results with you when i get back though
18:03:02 <psykotic> edwardk: okay, thanks.
18:03:08 <edwardk> psykotic: you can see if they're at all useful to you
18:03:12 <lowasser> but, um, holdup
18:03:22 <psykotic> edwardk: in any case, i'm sure it'll be stimulating. talk to you later. :)
18:03:44 <edwardk> psykotic: sounds like fun. i'll be back in probably 20-30 minutes.
18:04:12 <lowasser> surj (Return a) = return a
18:04:13 <lowasser> surj (Roll m) = m >>= inj
18:04:23 <lowasser> I think that typechecks,, but the problem is that it loses information?
18:04:36 <ivanm> monochrom: yeah, I worked that out
18:04:40 <lowasser> is that it?
18:05:05 <ivanm> grrr.... if I try to build with curl-pipelining, cabal install complains about the version of libcurl; if I _don't_ enable that option, cabal-install complains about not being able to find the .h files :@
18:06:36 <byorgey> lowasser: I think you want  surj (Roll m) = m >>= surj
18:06:45 <byorgey> but yes, that might lose information
18:06:46 <lowasser> heh, yes
18:07:07 <byorgey> maybe >>= happens to ignore some of the information in m, say
18:07:21 <lowasser> hmmm
18:07:30 <byorgey> then from the value (m >>= surj) you would not be able to reconstruct the original (Roll m)
18:07:51 <lowasser> interesting, I'm trying to think of an example
18:08:00 <byorgey> or maybe >>= just combines some of the information in m in a non-reversible way.
18:09:35 <byorgey> hmm... part of the problem in coming up with examples is that there aren't a lot of type constructors with multiple interesting monad instances =)
18:09:54 <byorgey> at least, there aren't a lot of common/non-contrived ones
18:10:07 <lowasser> heh
18:10:47 <Mathnerd314> maybe there's a DeriveMonad extension like DeriveFunctor?
18:11:06 <lowasser> pretty sure there *shouldn't* be
18:11:20 <lowasser> certainly it'd be difficult to generate
18:11:41 <lowasser> you'd have to be able to autogenerate join, which I can't imagine being able to do?
18:11:44 <lowasser> I mean, hmm
18:11:51 <lowasser> you could autoderive functor and take the free monad
18:12:06 <lowasser> that's a different type, though
18:12:20 <harrison> is there a way to use interact with handles other than stdin/stdout?
18:12:29 <mauke> @src interact
18:12:29 <lambdabot> interact f = do s <- getContents; putStr (f s)
18:12:37 <mauke> harrison: no, but it's easy to write
18:12:39 <lowasser> you could autoderive an extension of the functor, but not a monad instance directly
18:13:05 <byorgey> yeah, there's no DeriveMonad, because there *can* be multiple Monad instances for a given type
18:13:17 <mauke> interactWith i o f = hGetContents i >>= hPutStr o . f
18:13:22 <Mathnerd314> byorgey: example?
18:14:21 <rtaycher> is there a way to add a null string "" to the end of a string(I'm doing a recursive function)
18:14:36 <Zao> ++"", but that would be a no-op.
18:14:39 <byorgey> sigh.  I am ashamed to admit that I don't know any good examples off the top of my head.
18:14:41 <lowasser> that's the identity function
18:14:44 <lowasser> I mean
18:14:54 <lowasser> what's the free monad on the list functor look like?
18:14:55 <harrison> mauke: awesome. i was trying to avoid learning the details of handles, but it looks like they're pretty simple
18:14:58 <ivanm> rtaycher: sounds like you want ShowS
18:15:11 <lowasser> I'm not at all convinced it's the same as the list monad
18:15:12 <ivanm> rtaycher: but all you want is to do ++ ""
18:15:15 <ivanm> @type (++ "")
18:15:16 <lambdabot> [Char] -> [Char]
18:15:17 <ivanm> @type ShowS
18:15:18 <lambdabot> Not in scope: data constructor `ShowS'
18:15:23 <ivanm> @hoogle ShowS
18:15:23 <lambdabot> Prelude type ShowS = String -> String
18:15:23 <lambdabot> Text.Show type ShowS = String -> String
18:15:23 <lambdabot> Prelude shows :: Show a => a -> ShowS
18:16:44 <byorgey> lowasser: it's not.  the free monad on the list functor is the type of trees with data at (some of) the leaves, where each node can have any finite number of children.
18:17:08 <lowasser> well, poof, a two-monad-instance type, no?
18:17:28 <byorgey> it's  Tree a = Leaf a | Node [Tree a]
18:17:37 <byorgey> how do you figure?
18:17:48 <lowasser> hrrm
18:18:03 <byorgey> sorry, gotta go eat dinner
18:18:10 <byorgey> I might be back later
18:18:11 <ivanm> byorgey: bon a petit
18:18:12 <lowasser> yeah, I've been putting that off but
18:18:35 <lowasser> I feel like we should be able to make some bastardized listish version of (>>=) for Tree, then
18:19:08 <lowasser> hrrrm
18:19:46 * hackagebot hmeap 0.8 - Haskell Meapsoft Parser  http://hackage.haskell.org/package/hmeap-0.8 (RohanDrape)
18:20:37 <lowasser> ahahahahahaha I UNDERSTAND EVERYTHING
18:21:07 * Mathnerd314 is freaked out
18:21:37 <lowasser> the notion of a free monad is sort of the dual of what I was thinking it was
18:21:48 * hackagebot hmt 0.2 - Haskell Music Theory  http://hackage.haskell.org/package/hmt-0.2 (RohanDrape)
18:22:07 <dolio> You were thinking about cofree comonads?
18:22:17 <lowasser> hahahahaha, no
18:22:24 <HugoDaniel> i like haskell
18:22:35 <lowasser> I had mixed up that a free version of a thing has *more* information than that thing, usually
18:22:40 * ivanm pats HugoDaniel on the head
18:22:41 <ivanm> that's nice
18:22:47 <HugoDaniel> :)
18:22:54 <lowasser> I didn't properly understand which direction the information loss was going
18:23:21 <dolio> So, cofree monads.
18:23:39 <lowasser> except, hold on, that's on crack
18:23:53 <lowasser> I'm reading Asymptotic Improvement of Computations over Free Monads
18:24:12 <lowasser> oh, I see it now
18:24:20 <kmc> it's like a free group isn't it?
18:24:22 <lowasser> abs . rep = id
18:24:25 <lowasser> but rep . abs
18:24:26 <lowasser> isn't id
18:24:43 <lowasser> I am not on crack
18:24:50 * hackagebot hps 0.2 - Haskell Postscript  http://hackage.haskell.org/package/hps-0.2 (RohanDrape)
18:25:23 <ivanm> Rohan Drape must be clearing out his metaphorical haskell cupboard
18:25:30 <shapr> truly
18:25:36 * ivanm wonders if Rohan lives in the northern hemisphere and is doing some spring cleaning
18:25:37 <lowasser> indeed
18:25:37 <shapr> It's great though :-)
18:25:39 <ivanm> shapr!!!
18:25:42 <shapr> y0 ivanm!
18:25:48 <shapr> Nah, Rohan is from ... .lt I think
18:26:24 <ivanm> lithuania is in the northern hemisphere...
18:26:42 <ivanm> or do you mean that it isn't _really_ spring there yet since there's still snow, etc.? :p
18:27:06 <shapr> No, you're right, for some reason I mentally translated that into western hemisphere.
18:27:11 <ivanm> heh
18:27:49 * ivanm blames that on yankee parochialism
18:28:56 <dmwit> byorgey, lowasser, Mathnerd314: Lists have the usual non-determinism version of monad instance and an instance that acts like Maybe. (For example.)
18:29:30 <lowasser> Does the second one obey the monad laws?  ::thinks::
18:29:39 <dmwit> And certain arrow types could be instances of Reader, ReaderT, Writer, Cont, etc.
18:29:44 <Saizan> like Maybe?
18:30:05 <lowasser> I'm assuming that "like Maybe" means it essentially uses listToMaybe
18:30:13 <dmwit> exactly
18:30:18 <dolio> Are you thinking of MonadPlus?
18:30:20 <dmwit> [] >>= f = []
18:30:48 <dmwit> (x:xs) >>= f = case f x of [] -> []; (y:ys) -> [y]
18:30:55 * hackagebot hps-cairo 0.2 - Cairo rendering for the haskell postscript library  http://hackage.haskell.org/package/hps-cairo-0.2 (RohanDrape)
18:31:10 <dmwit> The latter may also satisfy the laws with "(x:xs) >>= f = f x" but I can't think fast enough to say for sure. =)
18:31:20 <lowasser> workin' on it
18:31:40 <dolio> That's not going to satisfy m >>= return = m.
18:31:48 <lowasser> yup
18:32:21 <Mathnerd314> and DeriveMonad would be on a data structure, so it wouldn't produce that...
18:32:43 <dmwit> dolio: Oh, you're right. What about with "(x:xs) >>= f = f x", then?
18:32:55 * hackagebot hfiar 0.0.1 - Four in a Row in Haskell!!  http://hackage.haskell.org/package/hfiar-0.0.1 (FernandoBenavides)
18:32:59 <dmwit> Hm, is that associative?
18:33:00 <lowasser> I mean, if we prove that there is something with two Monad instances, we have adequately proved that DeriveMonad isn't possible
18:33:06 <dolio> That's still (x:xs) >>= return = [x].
18:33:18 <dmwit> duh
18:33:19 <lowasser> yeah
18:33:45 <dmwit> Anyway, there's any number of places where the mtl uses newtypes to differentiate between different possible instances.
18:34:17 <lowasser> yes, but I'm not yet convinced that they're nonisomorphic?
18:34:36 <dmwit> Really?
18:34:43 <dmwit> What's the isomorphism between Reader and Cont, say?
18:34:44 <lowasser> like, I could believe it if someone told me that the newtypes were just there to give the proper kinds, etc.
18:35:02 <lowasser> There isn't one, but that's not what we're trying to show
18:35:29 <lowasser> I'm not convinced that the underlying structure of, say, the Cont monad, has a monad instance that is not equivalent to the Cont instance
18:35:47 <Saizan> ?src Cont
18:35:48 <lambdabot> newtype Cont r a = Cont { runCont :: (a -> r) -> r }
18:36:20 <lowasser> if we can construct a monad-law-obeying instance on (a -> r) -> r that is not equivalent to the Cont monad, I would be satisfied
18:36:31 <dolio> [] has two, though. Cartesian product, and the diagonal that Mathnerd314 finally found the right version of a day or two ago.
18:36:37 <dolio> Unless someone showed that it was wrong.
18:36:42 <Mathnerd314> nope, that's not right
18:36:42 <lowasser> ...remind me of that one?
18:36:54 <lowasser> except that I'm pretty sure that lambdabot actually can prove the one monad instance for Cont
18:37:19 <Mathnerd314> dolio: your example http://www.mail-archive.com/haskell-cafe@haskell.org/msg57217.html also failed on my implementation
18:37:20 <dmwit> lowasser: No, we just need to find some type that unifies with both (a -> r) -> r and (e -> a) to show that Cont and Reader are two valid monad instances for the same type.
18:37:26 <dmwit> lowasser: Which surely we can do.
18:37:27 <dolio> Oh really?
18:37:35 <dolio> Well, I guess I'm just that awesome. :)
18:37:36 <lowasser> I'm not interested in proving Cont equivalent to Reader!
18:37:40 <Saizan> dmwit: not really
18:37:40 <dmwit> lowasser: Since (a -> r) -> r itself unifies with (e -> a).
18:37:48 <lowasser> oh
18:37:55 <lowasser> I see what you're trying to do
18:37:55 <lowasser> except
18:38:17 <lowasser> the monad instance for the Reader version of Cont doesn't type check
18:38:18 <Saizan> dmwit: the problem is that you have to pick e = (a -> r); a = r for that to work
18:38:23 <lowasser> yeah
18:38:44 <dmwit> ...so?
18:38:49 <Saizan> dmwit: so you'd end up trying to write  the instances form M a = (a -> a) -> a
18:38:55 <dmwit> no no no
18:39:00 <Saizan> and i don't think you can make that work.
18:39:05 <lowasser> dmwit: try actually writing the code
18:39:26 <lowasser> what's the command for lambdabot
18:39:38 <lowasser> that will figure out a function with the specified type?
18:39:42 <dmwit> Top level: we're trying to show that there is some type for which you can't derive a unique monad instance, right?
18:39:46 <Saizan>  @djinn
18:39:51 <Saizan> dmwit: right
18:39:54 <lowasser> yes
18:39:57 <monochrom> @djinn x->x
18:39:58 <lambdabot> f a = a
18:40:03 <lowasser> but it's got to be a type with kind (* -> *), and all that jazz
18:40:11 <dmwit> So if there's a type that unifies with two different Monad instances, we're done: that type doesn't have a unique instance.
18:40:34 <Saizan> dmwit: no, if they use the 'a' part in different contexts
18:40:46 <Saizan> dmwit: because the 'a' is supposed to be quantified, in the methods
18:40:52 <lowasser> "Cont r" does not have an isomorphism to "Reader"
18:41:11 <lowasser> "Cont (a -> a) a" and "Reader a" unify
18:41:19 <lowasser> (I think)
18:41:38 <lowasser> but "Cont r" doesn't get to know what a is
18:41:47 <lowasser> it has to be able to take any type argument
18:41:53 <Saizan> yeah, i don't think you can write "forall a. Cont r a -> Reader s a" even if you choose r and s accurately
18:42:13 <dmwit> Let me put it another way. I have (f :: (a -> a) -> a). What is the type of (f >>=)?
18:42:46 <dmwit> orr.... maybe I'm just being an idiot
18:42:47 <dmwit> hold on
18:42:48 <lowasser> dmwit: try actually writing the monad instance
18:42:58 <dmwit> Yeah, okay, I see where I'm going wrong.
18:42:59 <dmwit> ok
18:43:02 <lowasser> okay
18:43:27 <lowasser> so we have resolved that this is not an example of a type with two monad instances
18:44:19 <lowasser> ummm
18:44:22 <lowasser> here's a thought
18:44:25 <Saizan> @djinn ((a -> a) -> a) -> (a -> (b -> b) -> b) -> (b -> b) -> b
18:44:25 <lambdabot> f a b c = b (a (\ d -> d)) c
18:44:38 <lowasser> I recall reading in the free structures article
18:44:47 <lowasser> that we can take the product of two monadse
18:45:03 <lowasser> data Product m1 m2 a = Prod (m1 a) (m2 a)
18:45:13 <lowasser> return a = Prod (return a) (return a)
18:45:16 <lowasser> uhh, does that bind?
18:45:21 <Mathnerd314> say, that's what I wrote
18:45:24 <lowasser> no, it doesn't
18:45:43 <Mathnerd314> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=8545#a8547
18:45:54 <lowasser> the article implies a tensor product on monads
18:46:28 <lowasser> mathnerd: I'm pretty sure that doesn't satisfy the monad laws
18:46:47 <Mathnerd314> again :-(
18:47:06 <lowasser> join2 seems like it's really dirty
18:47:10 <bmh> hey haskell, I'm trying to install hlint, which relies on haskell-src-exts, which fails due to an unsatisfied dependency on "happy," which isn't listed as a dependency on hackage.
18:47:33 <Saizan> bmh: it's in the build-tools field
18:47:50 <Saizan> bmh: anyhow, "cabal install happy" and make sure it gets into your $PATH
18:48:09 <ivanm> Saizan: yeah, I wonder why cabal-install wont' install happy
18:48:24 <ivanm> oh, wiat, because it can't tell if its installed already or not
18:49:29 <lowasser> hmmm I'm not sure there's a commutative product of monads
18:49:33 <lowasser> there's composition, sure
18:49:45 <lowasser> noncommutatie
18:49:46 <lowasser> ve
18:51:48 <lowasser> I'VE GOT IT I GOT IT
18:51:51 <lowasser> VICTORY
18:51:58 * Mathnerd314 is freaked out again
18:52:06 <lowasser> okay
18:52:24 <lowasser> Mathnerd, are you willing to grant the existence of inequivalent Mon*oid* instances?
18:52:59 <lowasser> (Someone, throw one out there, please?)
18:53:04 <lowasser> oh
18:53:08 <lowasser> I've got a silly one
18:53:12 <dolio> + *
18:53:13 <lowasser> integers!  under multiplication and addition
18:53:14 <lowasser> yep
18:53:23 <lowasser> so then their Writer monad instances are nonisomorphic.
18:53:45 <lowasser> Writer (Product Int) and Writer (Sum Int) are nonisomorphic, but have the same underlying type
18:54:07 <lowasser> I win!
18:55:11 <lowasser> do people agree that this is an adequate example?
18:56:07 <Mathnerd314> but they're still the same data structure...
18:56:24 <Mathnerd314> and the same bind and return
18:56:39 <Mathnerd314> unless I'm an idiot, like I usually am
18:56:52 <lowasser> it's not the same bind and return
18:57:27 <lowasser> @src ((>>=) :: Writer w a -> (a -> Writer w b) -> Writer w b)
18:57:27 <lambdabot> Source not found. There are some things that I just don't know.
18:57:31 <lowasser> mrrr
18:58:05 <lowasser> they use different mappends
18:58:16 <lowasser> so let's say I write
18:58:23 <dolio> @src Writer (>>=)
18:58:23 <lambdabot> Source not found. You speak an infinite deal of nothing
18:58:28 <lowasser> newtype MyMonad a = MyMonad (Int, a)
18:58:41 <lowasser> instance Monad MyMonad where -- instance #1
18:59:09 <Cale> "In an ordinary TCP/IP stack, memory is often used to buffer data while waiting for an acknowledgment signal that the data has successfully been de-livered." -- heh, it looks like someone manually hyphenated the last word in this sentence and then it got pushed into the middle of the line in the paper :)
18:59:17 <lowasser> return x = (0, x)
18:59:17 <lowasser> m >>= k = let MyMonad (a, x) = m; MyMonad (b, y) = k x in (a + b, y)
18:59:31 <lowasser> this is essentially the Monad instance for Writer (Sum Int)
18:59:41 <lowasser> alternate Monad instance for the same type:
18:59:44 <lowasser> return x = (1, x)
18:59:52 <ivanm> Cale: people actually do manual word splitting across lines? :o
19:00:00 <lowasser> m >>= k = let MyMonad (a, x) = m; MyMonad (b, y) = k x in (a * b, y)
19:00:36 <lowasser> two different monad instances, same underlying type
19:00:47 <Mathnerd314> ok. I'll assume those are actually monads...
19:01:10 <lowasser> they're what you get if you just write out the actual instance of Monad (Writer (Sum Int)) and Writer (Product Int)
19:01:17 * hackagebot hack-handler-hyena 2010.3.15 - Hyena hack handler  http://hackage.haskell.org/package/hack-handler-hyena-2010.3.15 (JinjingWang)
19:01:35 <lowasser> you can prove the monad laws for yourself
19:01:50 <lowasser> but therefore, no implementation of DeriveMonad could figure out which one it was meant to derive
19:01:50 <Mathnerd314> yeah, they look like monads.
19:02:03 <lowasser> qed, DeriveMonad is nonsensical
19:02:24 <Mathnerd314> no, therefore DeriveMonad needs some restrictions on its types
19:02:47 <lowasser> they'd have to be impossibly restrictive
19:03:49 <Mathnerd314> :-(
19:03:54 <Mathnerd314> oh well.
19:04:02 <j4cbo> quick question - a dude in another channel is claiming that in haskell, evaluating 0 ** anything leads to undefined-by-the-standard behavior
19:04:29 <j4cbo> my impression is that haskell was well-defined except for a few clearly-unsafe extensions
19:04:39 <Cale> > 0 ** 0
19:04:40 <lambdabot>   1.0
19:05:12 <Mathnerd314> > 0 ** 1
19:05:13 <lambdabot>   0.0
19:05:16 <danderson> @src (**)
19:05:16 <lambdabot> Source not found. Are you on drugs?
19:05:18 <j4cbo> yeah, i tried in ghc and that was the result, but that doesn't mean it's not "unspecified"
19:05:27 <dolio> Why would 0 ** 5 be undefined by the standard?
19:05:55 <Cale> Oh, look, weird...
19:06:03 <Mathnerd314> from prelude: x ** y           =  exp (log x * y)
19:06:07 <Cale> "The value of x^0 or x^^0 is 1 for any x, including zero; 0**y  is undefined."
19:06:29 <Cale> That's only the default implementation in the Prelude though.
19:06:43 <Mathnerd314> ok.
19:06:54 <j4cbo> strange.
19:06:56 <Cale> If you neglect to write an implementation when you make an instance of Floating, that'll be the definition it uses.
19:06:58 <ivanm> dolio: well, 0 ** 0 _might_ be unspecified
19:07:08 <Cale> > 0 ** 0 :: Complex
19:07:09 <lambdabot>   `Data.Complex.Complex' is not applied to enough type arguments
19:07:09 <lambdabot>  Expected ki...
19:07:10 <dolio> I could believe that.
19:07:10 <Cale> > 0 ** 0 :: Complex Double
19:07:11 <lambdabot>   NaN :+ NaN
19:07:13 <ivanm> 0 ** -x would definitely be unspecified (well, NaN or Infinity maybe)
19:07:19 <Cale> ^^ that is bad, in my opinion
19:07:29 <dolio> I don't understand why you'd leave 0 ** y for non-zero y undefined.
19:07:33 <ivanm> Cale: *nod*
19:07:35 <j4cbo> though, to be fair, "undefined" in that context seems to mean "an unspecified value of the correct type, or _|_", as opposed to what it means in C
19:07:43 <ivanm> dolio: well, y can't be negative...
19:07:50 <ivanm> > 0 ** (-3)
19:07:51 <lambdabot>   Infinity
19:07:53 <dolio> Sure, that, too.
19:07:55 <Cale> 0 ** 0 should *always* be 1
19:08:00 <dolio> Positive y, then.
19:08:04 <ivanm> right
19:08:17 <ivanm> Cale: some mathematicians don't like that definition IIRC
19:08:29 <Cale> Only the ones who haven't given it much thought.
19:08:46 <ivanm> since they argue that 0 ** x (forall x > 0) is 0, 0 ** 0 should also be 0
19:08:47 <Cale> (and those are not many :)
19:08:52 <dolio> Cale: I tried selling that in the math reddit, and had some dude telling me that Real Mathematicians leave it unspecified.
19:09:01 <Cale> pff
19:09:11 <ivanm> http://en.wikipedia.org/wiki/0%5E0#Zero_to_the_zero_power
19:09:18 <ivanm> yay for wikipedia recognising 0^0 !
19:09:32 <dolio> On the real numbers, that is.
19:09:39 <ivanm> "In most settings not involving continuity (for instance, those in which only integral exponents are considered), interpreting 00 as 1 simplifies formulas and eliminates the need for special cases in theorems."
19:09:45 <ivanm> so continuity is the problem
19:09:52 <Cale> Look, if you don't define 0^0 to be 1 for real and complex numbers, then you can't even write formulas like  exp(x) = sum over k >= 0 of x^k / k!
19:10:08 <Cale> Which is pretty inconvenient.
19:10:19 <ivanm> Cale: so setting it to NaN :+ NaN is apparently at least semi-common for complex numbers
19:10:25 <Cale> You have to be careful and separate off the first term all the time
19:10:27 <dolio> I'm not sure what situations you'd care about being able to say "f(x) = 0^x" is continuous, though.
19:10:34 <tsou> is there a way to have two modules that import from each other certain functions?
19:10:40 <monochrom> Haskell gets it right by having ^, ^^, ** for different purposes.
19:10:46 <ivanm> tsou: yes, using .hs-boot files
19:10:52 <ivanm> but it's fiddly and there's usually better ways of doing it
19:10:52 <dolio> It seems like the minority case, and you can just specify that f is 0^x except at x=0.
19:11:04 <ivanm> e.g. having a third module that contains common functions
19:11:16 <ivanm> both of your modules then import that, and then only one of those two imports the other
19:11:26 <Cale> The NaN :+ NaN result is really broken though.
19:11:37 <rtaycher> mysterious parse error (possibly incorrect indentation)
19:11:40 <monochrom> "real mathematicians" don't know what they're talking about when they have both power series and "0^0 better off undefined" in the same damn analysis textbook.
19:11:42 <ivanm> Cale: oh, but excel issues an error, so it _must_ be undefined! :p
19:12:09 <Cale> monochrom: Who?
19:12:14 <rtaycher> anyone have any links to good descriptions of parsing errors
19:12:23 <monochrom> And screw continuity, lim (x,y)->(0,0) x^y does not exist, no way you can make it continuous.
19:12:26 <Cale> Most of the actual mathematicians I've ever run into agree with me on this :)
19:12:27 <ivanm> rtaycher: in what?
19:12:32 <ivanm> ghc[i] not liking your code?
19:12:37 <ivanm> a parser you wrote not working?
19:12:43 <monochrom> "real mathematicians" as quoted on reddit
19:12:50 <Cale> monochrom: heh, okay
19:12:58 <Cale> Yeah
19:13:06 <rtaycher> ghci is not liking my lhs file,developing all osrts of weird parsing errors
19:13:13 <tsou> ivanm: i think that would be tricky in my particular case.  I want to declare a data type an instance of Read, and I need the parse function from the other module (which, in turn, needs the type definition)
19:13:19 <tsou> (if that made any sense at all)
19:13:27 <ivanm> Cale: most of the "real" mathematicians I've done classes or work with are combinatorists, and as such usually don't care about continuity :p
19:13:33 <lowasser> hehehehehe
19:13:41 <ivanm> tsou: put them in the same module...
19:13:44 <dufflebunk> Anyone have a GHC 6.12 RPM for RH5?
19:13:44 <Cale> ivanm: But combinatorialists will care even more that 0^0 = 1
19:13:54 <ivanm> dufflebunk: doubt it
19:14:00 <ivanm> Cale: that's what I mean
19:14:11 <Cale> Ah, yeah.
19:14:21 <tsou> ivanm: is there a way to do this but still keep them in separate files?  it's too bulky otherwise
19:14:41 <ivanm> tsou: .hs-boot files, which are clunky
19:14:47 <Cale> and the guys who are working in analysis normally don't give a damn about continuity there either -- there are much less well-behaved discontinuous functions around.
19:14:51 <ivanm> tsou: but I still think you're doing it wrong ;-)
19:15:21 <tsou> ivanm: thanks for the feedback
19:15:29 <ivanm> no worries
19:15:35 <Cale> But if you're talking about computation and, say, rounding error, it becomes really important that you get 1
19:15:38 <tsou> ivanm: and that i should have them in the same module? :P
19:16:15 <ivanm> tsou: well, is the parsing function that complex that you can't just put that and the data type into a third module, and then have the other two modules import that module?
19:16:17 <Cale> Because along almost any path which approaches (0,0) you get a limit of 1.
19:16:34 <lowasser> observation:
19:16:48 <lowasser> ^^ is only defined on
19:16:49 <lowasser> oops
19:16:54 <lowasser> ** is defined for Floating types
19:17:00 <lowasser> ^^ is defined for integer exponents
19:17:04 <lowasser> ^^ behaves properly
19:17:17 <Mathnerd314> lowasser: actually, DeriveFunctor isn't well-defined either. in http://www.mail-archive.com/haskell-prime@haskell.org/msg02116.html, there are two instances for "Problem"
19:17:18 <lowasser> whereas ** depends on continuity
19:17:28 <lowasser> I'm aware of that
19:17:37 <McManiaC> does Data.ByteString.pack uses unsafePerformIO ? since I saw it using "poke"?
19:17:40 <Cale> ** behaves properly for Float and Double, but incorrectly for Complex Float and Complex Doublw
19:17:43 <Cale> Double*
19:18:12 <tsou> ivanm: I think it is.. but then again, it's my first parser so i might have made that foolishly complex by lack of experience
19:18:13 <ivanm> McManiaC: you could always check the source yourself... ;-)
19:18:16 <Cale> and I'm not sure why, but I think it ought to be fixed :P
19:18:28 <ivanm> tsou: but what kind of parser are you using that you're using it for a Read instance?
19:18:43 <ivanm> IMHO, Read and Show isntances should be derived, not written out explicitly
19:18:47 <Cale> (**) is a class method, so there's nothing preventing a special case there
19:18:47 <ivanm> and then define your own parsing class
19:18:48 <lowasser> mathnerd: so let's say that we're willing to define DeriveMonad if we can come up with a sensible implementation
19:18:59 <lowasser> even if it might be ambiguous in some cases
19:19:06 <tsou> ivanm: haven't used it yet, i just thought of the circularity right before using it.  It's a parser for a lambda calculus system.
19:19:26 <ivanm> yeah, I would write your own Parsing class rather than use Read
19:19:28 <lowasser> actually, here's a thought
19:19:31 <ivanm> as it would end up being more flexible
19:19:35 <lowasser> I think I might believe that
19:19:39 <Cale> If I do various power-series approximations to analytic functions on the complex plane, I have to be careful about the x^0 term and treat it separately.
19:19:44 <lowasser> DeriveFunctor will generate an instance, if it's possible
19:19:44 <tsou> ivanm: i have, and it works like a charm..
19:19:58 <lowasser> not sure of that
19:20:04 <Cale> Or, I should say, the x ** 0 term ;)
19:20:10 <tsou> ivanm: i just thought i should also declare a read = myParserRunner and make it an instance of Read
19:20:13 <tsou> ivanm: bad idea?
19:20:16 <lowasser> DeriveMonad, on the other hand, wouldn't be able to derive monad instances that _are_ realistic
19:20:17 <ivanm> yes
19:20:21 <lowasser> I mean, we could just have some implementation
19:20:28 <ivanm> tsou: Show and Read are typically for debugging purposes
19:20:35 <lowasser> that just tries to put your monad in terms of mtl transformers
19:20:45 <ivanm> by spitting out and reading (up to qualified imports, etc.) valid Haskell code
19:20:46 <tsou> ivanm: had no idea, thanks again
19:20:46 <lowasser> I'm even willing to believe that's possible
19:20:59 <ivanm> tsou: besides, it's not just read =
19:21:01 <ivanm> @src Read
19:21:02 <lambdabot> class Read a where
19:21:02 <lambdabot>   readsPrec    :: Int -> ReadS a
19:21:02 <lambdabot>   readList     :: ReadS [a]
19:21:02 <lambdabot>   readPrec     :: ReadPrec a
19:21:02 <lambdabot>   readListPrec :: ReadPrec [a]
19:21:12 <ivanm> tsou: ^^ defining a Read instance by hand isn't that easy ;-)
19:21:22 <ivanm> @src ReadS
19:21:22 <lambdabot> Source not found. My pet ferret can type better than you!
19:21:25 <ivanm> @type ReadS
19:21:26 <lambdabot> Not in scope: data constructor `ReadS'
19:21:27 <lowasser> ivanm: it's not all that bad
19:21:31 <ivanm> grrr....
19:21:31 <lowasser> one mo'
19:21:36 <tsou> ivanm: hah, you had me at "@src Read"
19:21:39 <ivanm> lowasser: what isn't?
19:21:43 <ivanm> tsou: :D
19:21:55 <Saizan> you only need to define readsPrec.
19:22:03 <lowasser> tsou: see the instance in http://www.haskell.org/ghc/docs/latest/html/libraries/containers-0.3.0.0/src/Data-Sequence.html#Seq
19:22:23 <ivanm> Saizan: right
19:22:29 <ivanm> @type readsPrec
19:22:30 <lambdabot> forall a. (Read a) => Int -> String -> [(a, String)]
19:22:30 <lowasser> it's not that bad
19:23:02 <ivanm> Saizan: it's still not as easy as just doing read = (foo :: String -> a) like tsou thought
19:23:27 <mail> how do you stop ghci if you tell it to make an infinite list
19:23:34 <danderson> control C
19:23:36 <tsou> mail: ^C
19:23:40 <mauke> if that doesn't work, ^Z
19:23:44 <mauke> and kill %1
19:23:50 <ivanm> or else pkill ghc
19:23:52 <ivanm> ;-)
19:24:19 <ivanm> (since ghci running within emacs is sometimes too busy to tell that you've issued a C-c
19:24:21 <ivanm> )
19:24:22 <Saizan> ivanm: it should be easy for any sane way of defining foo :)
19:24:52 <ivanm> Saizan: but if you're talking about something that you're parsing, and you've used a parsing library to write such a parser...
19:24:59 <Saizan> i.e. getting a different type
19:25:02 <ivanm> besides, I still believe that Read should read Haskell code
19:25:06 <freedrull> im trying to install haskell-src from cabal, it says it needs the package happy. i installed happy with cabal but cabal still complains that happy isnt installed when i try to install haskell-src!
19:25:19 <dankna> happy isn't in your path
19:25:23 <dankna> it installs a binary
19:25:26 <ivanm> about to say that
19:25:27 <dankna> an executable, I mean
19:25:38 <ivanm> freedrull: "which happy" should return something
19:25:39 <avenge> make sure ~/.cabal/bin is in yourpath.
19:25:41 <dankna> check where it installed (probably ~/.cabal/bin/ if you haven't taken steps for it to be otherwise)
19:25:52 * ivanm also points out that cabal /= cabal-install
19:25:52 <krey> can someone explain how foldMap works?
19:25:53 <freedrull> oh i gotta add .cabal/bin to my path
19:25:58 <ivanm> @type foldMap
19:25:59 <lambdabot> Not in scope: `foldMap'
19:26:03 <ivanm> @hoogle foldMap
19:26:03 <lambdabot> Data.Foldable foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
19:26:04 <lambdabot> Data.Traversable foldMapDefault :: (Traversable t, Monoid m) => (a -> m) -> t a -> m
19:26:26 <Saizan> krey: "how" in which sense?
19:26:31 <krey> well
19:26:38 <ivanm> krey: do you know what Monoids are?
19:26:45 <krey> im trying to make a tree an instance in this class
19:26:53 <krey> so that I can fold on it
19:27:03 <krey> monoids, loosely
19:27:10 <Saizan> foldMap is not a general fold
19:27:14 <benmachine> :t fold
19:27:15 <ivanm> agreed
19:27:15 <lambdabot> Not in scope: `fold'
19:27:18 <ivanm> @hoogle fold
19:27:19 <lambdabot> Data.Foldable fold :: (Foldable t, Monoid m) => t m -> m
19:27:19 <lambdabot> Data.IntMap fold :: (a -> b -> b) -> b -> IntMap a -> b
19:27:19 <lambdabot> Data.IntSet fold :: (Int -> b -> b) -> b -> IntSet -> b
19:27:33 <Saizan> nor Data.Foldable.fold is
19:27:34 <krey> I need a general fold, yes
19:27:35 <ivanm> there's Data.Foldable.fold{l,r} IIRC
19:27:43 <ivanm> _they_ are general folds
19:27:45 <ivanm> @hoogle foldr
19:27:46 <lambdabot> Prelude foldr :: (a -> b -> b) -> b -> [a] -> b
19:27:46 <lambdabot> Data.ByteString foldr :: (Word8 -> a -> a) -> a -> ByteString -> a
19:27:46 <lambdabot> Data.Foldable foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b
19:27:56 <ivanm> @hoogle foldl
19:27:56 <lambdabot> Prelude foldl :: (a -> b -> a) -> a -> [b] -> a
19:27:56 <lambdabot> Data.ByteString foldl :: (a -> Word8 -> a) -> a -> ByteString -> a
19:27:56 <lambdabot> Data.Foldable foldl :: Foldable t => (a -> b -> a) -> a -> t b -> a
19:28:00 <Saizan> ivanm: all of Data.Foldable assumes you're viewing your datatype as a sort of list.
19:28:10 <ivanm> Saizan: true
19:28:21 <Saizan> for trees you can write different folds.
19:28:26 <Saizan> i.e. their catamorphism
19:28:31 <ivanm> so with a Tree, the question is presumably what kind of traversal you're going to do
19:28:35 <Saizan> and there isn't a typeclass for that
19:28:50 <benmachine> @src Foldable
19:28:50 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
19:28:54 <benmachine> pff
19:28:57 <ivanm> a better idea might be to do a Sum/Product style wrapper definition for trees
19:29:05 <ivanm> each wrapper implementing a different traversal for the fold
19:29:14 <benmachine> depends on your use case
19:29:14 <krey> hmm
19:29:19 <krey> sooo
19:29:22 <benmachine> if you're making a library then sure
19:29:25 <krey> my trees
19:29:49 <monochrom> are cut down
19:29:49 <krey> data Tree a b = Zero b | One a (Tree a b) | Two a (Tree a b) (Tree a b) deriving Show
19:29:49 <benmachine> but if you're learing how to use type classes, or writing code for your application, you only need worry about whatever traversal interests you
19:29:57 <Saizan> data Tree a = Leaf a | Fork a (Tree a) (Tree a); foldTree :: (a -> r) -> (a -> r -> r) -> Tree a -> r; -- you can't have this fold out of an instance of Foldable.
19:30:19 <Saizan> and with foldTree you can easily write any traversal
19:30:23 <tsou> ivanm: and show is also a bad idea for pretty printing those lambda terms?  I should use some other function for actually printing them?
19:30:34 <ivanm> tsou: yeah, use a pretty printer
19:30:36 <krey> ok
19:30:43 <ivanm> tsou: as an example of why I'm saying this:
19:30:57 <krey> the whole reason I got into this is that I'm trying to handle errors
19:30:59 <krey> using monads
19:31:04 <tsou> ivanm: btw, it solves a problem I had with wanting to override my show earlier
19:31:12 <ivanm> I inherited the graphviz library from matthew-_; he originally used Show for printing and a parser for parsing (rather than read)
19:31:21 <Saizan> krey: i'd just define foldTree :: (b -> r) -> (a -> r -> r) -> (a -> r -> r) -> Tree a b -> r
19:32:03 <ivanm> however, when I wanted to extend some functionality of the library, I kept running into so many problems with using Show that I spent the time to re-write all of the printing and parsing support to use printing and parsing classes
19:32:06 <ivanm> tsou: exactly
19:32:10 <monochrom> People should learn to press enter less, so their whole question and information stay in one place. This is not MSN or Twitter.
19:32:31 <ivanm> in most cases your printing and parsing requirements are different for each thing you're printing/parsing, even if its for the same datatype
19:32:42 <ivanm> monochrom: but then the lines get too long...
19:32:45 <krey> Saizan: could you take a look at this http://pastebin.com/ntuSvWpB ?
19:33:18 <krey> Saizan: I fail at writing joinException, and hence >>=
19:33:19 <monochrom> I have yet to see a case of too-long.
19:33:35 <McManiaC> how would you split a list into "sublists" with a maximum length of N elements?
19:33:45 <ivanm> monochrom: http://www.theonion.com/content/news/nation_shudders_at_large_block_of
19:33:46 <ivanm> ;-)
19:33:55 <tsou> ivanm: thanks a lot, i have a lot of re-organizing to do now on my calculus..
19:34:00 <ivanm> monochrom: when it's so long that it overflows, then it's too long ;-)
19:34:18 <ivanm> tsou: no need to thank me for all of the extra work you have to do! :p
19:34:55 <Saizan> krey: i don't think you can make that a monad
19:35:04 <krey> nooooo :(:(
19:35:09 <freedrull> haskore requires HUnit and HUnit fails to build with cabal install with this error :{ Test/HUnit/Lang.hs:22:1: lexical error at character 'i'
19:35:11 <Saizan> krey: the usual way to add exceptions to an existing monad is to use ErrorT
19:35:15 <tsou> ivanm: i've written and deleted and re-written and renamed and re-done everything on this system during last week.  So far, every kind of re-work is a step forward, so thanks for this step..
19:35:20 <Saizan> @unmtl ErrorT m a
19:35:20 <lambdabot> err: `ErrorT m a' is not applied to enough arguments, giving `/\A. a (Either m A)'
19:35:26 <Saizan> @unmtl ErrorT e m a
19:35:26 <lambdabot> m (Either e a)
19:35:37 <krey> is it not possible to write this ErrorT myself?
19:35:45 <Saizan> yes
19:35:56 <lowasser> I'm trying to figure out if it's what you want, though
19:36:06 <Saizan> krey: newtype ErrorT e m a = ErrorT (m (Either e a))
19:36:23 <lowasser> like, that'd just look like a tree whose elements might be errors
19:36:36 <lowasser> except
19:36:41 <lowasser> wait, yeah, it'd be fine
19:36:56 <lowasser> it's just ErrorT e (YourMonad)
19:36:57 <krey> Saizan: why put the Either inside the monad?
19:37:07 <lowasser> otherwise it doesn't obey monad laws
19:37:14 <tsou> ivanm: last question for now, when you said "pretty printer" earlier you simply meant a functions that prints my terms in a nice way, right?  Or is there a specific "pretty printer" class/module that you had in mind?
19:37:24 <ivanm> tsou: there's quite a few of them
19:37:45 <ivanm> tsou: the easiest is the HughesPJ one shipped with GHC
19:37:47 <ivanm> @hackage pretty
19:37:47 <lambdabot> http://hackage.haskell.org/package/pretty
19:37:51 <ivanm> tsou: ^^
19:38:08 <ivanm> there are a few others as well which are more sophisticated
19:38:21 <ivanm> tsou: these are especially useful if you're printing multi-line stuff
19:38:35 <ivanm> if you're only doing a single line at a time, then you might be able to get away with just using String
19:38:37 <Saizan> krey: so that you can write join, otherwise you'd be trapped inside the monad without being able to put the Either around it
19:38:46 <Saizan> krey: like in your joinException
19:39:10 <krey> hmm
19:40:27 <tsou> ivanm: usually it's just one-liners.  Exception is when I print a detailed step-by-step reduction of a lambda-term.  But then i just join a [String] with a "==> \n" separator and I'm done..
19:40:39 <Saizan> krey: which m are you going to use?
19:40:41 <tsou> ivanm: but this looks interesting
19:40:47 <krey> well, trees
19:40:53 <krey> as presented
19:41:14 <krey> I need the whole computation to fail as soon as the first error is encountered
19:41:25 <carter> has anyone here successfully installed a recent version of hieroglyph? i've been having trouble getting that to wokr well
19:42:30 <Saizan> krey: i guess you could also write newtype TreeT a m b = = TreeT (m (Tree a b)), and then use TreeT a (Either e) b as your monad
19:43:11 <Saizan> that way the errors will be on top
19:43:21 <Saizan> rather than being hidden inside the tree
19:43:43 <mail> lol at haskell documentation generator
19:43:47 <mail> "haddock"
19:44:18 <dufflebunk> what's wrong with naming it after a fish?
19:44:36 <ivanm> dufflebunk: I think mail finds it amusing that it _was_ named after a type of fish
19:44:44 <ivanm> rather than just calling it haskell-doc or something
19:44:47 <krey> Saizan: you're going a bit fast for me here, especially since I have no idea how newtype works
19:45:39 <krey> Saizan: What is TreeT?
19:45:53 <danderson> woot, my unholy point-free function type-checks!
19:46:06 <Saizan> krey: we can use data, it's the same, modulo a small runtime overhead
19:46:18 <danderson> if anyone feels like a round of golf: groupByDestination = M.unionsWith (++) . map (M.map pure) . M.elems
19:46:21 <Saizan> krey: data TreeT a m b = = TreeT (m (Tree a b))
19:46:22 <danderson> where M == Data.Map
19:46:33 <Saizan> krey: data TreeT a m b = TreeT (m (Tree a b))
19:47:21 <krey> Saizan: Ok, but why would I want to put my Trees into a monad? :S
19:47:35 <Saizan> krey: then you should be able to write instance Monad m => Monad (TreeT a m) where ..; which would look similar to the Tree a one
19:48:11 <Saizan> krey: so that you can have an Either e around them to implement exceptions
19:48:48 <Saizan> @src Either
19:48:48 <lambdabot> Source not found. My pet ferret can type better than you!
19:48:58 <Saizan> data Either e a = Left e | Right a
19:48:59 <krey> Saizan: why not put Either e into the definition then?
19:49:35 <krey> I mean, that of the type (data, whatever you call it)
19:49:50 <Saizan> krey: you mean data TreeT e a b = TreeT (Either e (Tree a b)) ?
19:49:55 <krey> yep
19:50:15 <Saizan> oh, just because the implementation would look the same with the former, and it'd be more general
19:50:34 <Saizan> so you might reuse it later with a fancier monad
19:50:44 <jmcarthur> :t M.unionsWith (++) . map (M.map pure) . M.elems
19:50:45 <lambdabot> forall k a (f :: * -> *) k1. (Monoid (f a), Ord k, Applicative f) => M.Map k1 (M.Map k a) -> M.Map k (f a)
19:51:26 <danderson> if it helps grok, f == [] in this case
19:52:07 <jmcarthur> :t M.unionsWith
19:52:08 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> [M.Map k a] -> M.Map k a
19:53:12 <krey> Saizan: soo, I need to write a monad for Treet e a
19:53:29 <Saizan> yes
19:53:31 <krey> Saizan: Ima try this, thanks for your help
19:54:12 <Saizan> krey: if you make use of the fact that Either e is a monad it'd be easier
19:56:29 <cdsmithus> I'm trying to do the type-level programming question on reddit for fun, but I'm stuck.  Anyone want to help me figure out how to write the IsFib class at the bottom of http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23976 please?
19:56:32 <krey> Saizan: does >>= `prefer `
19:56:38 <krey> arh
19:56:52 <krey> Saizan: does >>= 'prefer' the right then?
19:57:14 <c_wraith> > return 1 :: Either String Int
19:57:15 <lambdabot>   Right 1
19:57:32 <krey> ok, cool
19:57:34 <krey> thanks
19:57:40 <benmachine> where is that instance from?
19:57:49 <c_wraith> Control.Monad.Error, I think
19:58:16 <McManiaC> http://npaste.de/LR/ http://www.n-sch.de/proxy2.png ← why does he split up those packages like that?
19:58:18 <benmachine> oh right, Error e =>
19:58:27 <benmachine> silly thing
19:58:37 <c_wraith> Yeah.  Just because of fail
19:58:42 <ivanm> McManiaC: not sure I know what you're asking
19:58:57 <ivanm> I see some code and a screenshot
19:59:05 <Zao> McManiaC: Because TCP is a stream.
20:00:06 <Zao> The chunks you send() will most probably not be the chunk granularities recv() will return.
20:00:57 <McManiaC> hmmm
20:02:54 <Zao> If you want message-oriented sockets, use UDP.
20:03:03 <Zao> Or put a nice fluffy protocol on top of TCP.
20:03:06 <McManiaC> so the recv function returns those bytes before the rest of the package got sent?
20:03:09 <Zao> And recv until you have a full protocol unit.
20:03:21 <tehgeekmeister> is there a function somewhere that converts a string to it's url encoded form?
20:03:25 <McManiaC> okay
20:03:33 <McManiaC> i think I'll work it out :)
20:03:33 <Zao> McManiaC: The TCP stack on the sending side may split and smush together the chunks you send() arbitrarily.
20:03:59 <Zao> McManiaC: The TCP stack on the receiving side may provide arbitrarily sized chunks to read(), depending on mood and moon phase.
20:04:18 <McManiaC> hehe
20:04:19 <McManiaC> okay
20:04:30 <McManiaC> good to know its not my fault ;P
20:05:01 <absentia> even when a sending side says it has sent all the bytes in a packet
20:05:03 <absentia> it may not have.
20:05:06 <Zao> http://beej.us/guide/bgnet/output/html/multipage/syscalls.html#sendrecv
20:05:18 <Zao> absentia: As far as the application cares, they're sent.
20:05:25 <absentia> correct
20:05:29 <absentia> but you can't use that to debug
20:05:35 <Zao> Someone Elses Problem.
20:05:49 * absentia had douglas adams sign his hard copy of the trilogy with those words.
20:05:50 <Zao> When in doubt, Wireshark.
20:07:08 <ivanm> what? an SEP field? where?
20:07:22 <ivanm> absentia: how many parts of the trilogy do you have?
20:08:27 <absentia> 5?
20:08:47 <absentia> but I only count the first three...
20:08:50 <absentia> hold on.
20:09:22 <tehgeekmeister> urlEncode in network.cgi, it appears!
20:09:25 <tehgeekmeister> yay for hoogle
20:09:30 <absentia> ya, 5 in this book.
20:10:32 <absentia> I wsa a sysadmin and DA was a user of mine.. this is the wording:  To Scott  Best wishes, + see you on Internet  No, Scott, users are not somebody else's problem!  Douglas Adams
20:12:36 <bmh> I'm using the Cabal package checker before I upload my package. While I've built the documentation with haddock, the package checker isn't displaying links to the docs
20:12:49 <bmh> Does the checker neglect to include these links or am I doing something wrong?
20:14:18 <mail> haskell file should be ANSI or Unicode?
20:14:39 <ivanm> for maximum compatibility, ASCII
20:14:57 <ivanm> as of 6.12, the encoding of source files depends on your computer's locale
20:14:58 <mail> UTF -8 is backwards compatible with ASCII anyway
20:15:16 <kmc> i though the encoding of source files was always UTF-8
20:15:38 <tensorpudding> It's not too unreasonable to use UTF-8
20:16:11 <dons> bmh: that's fine. its unlikely you have indexes locally
20:16:21 <dons> when you upload, hackage will cross-link everything.
20:16:32 <kmc> hmm the Report does not say
20:16:54 <ivanm> kmc: nope
20:16:57 <tensorpudding> I wrote a function once that used a Unicode character and it worked fine.
20:17:01 <ivanm> internal haskell uses utf-16 or something
20:17:08 <kmc> how do you mean?
20:17:14 <bmh> well drat, I seem to have forgotten my hackage password.
20:17:15 <ivanm> but AFAIK there's no restrictions on source code
20:17:27 <ivanm> kmc: String uses utf-16 or something internally
20:17:36 <kmc> in GHC?
20:17:40 <ivanm> yes
20:17:47 <twink> Why would Haskell be wedded to a specific encoding?
20:17:48 <kmc> but it's not in the spec
20:17:49 <ivanm> I _think_ that's from the report, but I'm not sure
20:17:52 <kmc> oh really?
20:17:55 * kmc looks
20:18:05 <kmc> i think a Char is a Unicode codepoint, no more no less
20:18:10 * ivanm points out that he's never actually fully read the report; this is what he recalls from other people talking
20:18:11 <bmh> dons: thanks.
20:18:11 <tensorpudding> When it's compiled, it's all the same.
20:18:14 <ivanm> kmc: oh, it could be that
20:18:28 <kmc> whether it's 2 or 4 bytes is like specifying the layout of a (:) cons cell in memory
20:18:29 <mauke> String is [Char]
20:18:34 <ivanm> I thought utf-16 was the unicode standard for all intents and purposes
20:18:42 <mauke> ivanm: which one?
20:18:45 <ivanm> mauke: I know that much ;-)
20:18:50 <kmc> how do you mean?
20:18:50 <mauke> there are two utf-16s
20:18:54 <tensorpudding> Maybe someone could translate all of Haskell into Chinese, like they did for Python.
20:18:54 <ivanm> :o
20:19:02 <ivanm> tensorpudding: nah, latin like for perl
20:19:07 <tensorpudding> :o
20:19:07 <kmc> i think more text is utf-8 than utf-16 encoded
20:19:10 <ivanm> so the vatican use it
20:19:13 <ivanm> *can use
20:19:24 <ivanm> kmc: windows uses utf-16 IIRC
20:19:46 <tensorpudding> programmus functionatoribus
20:19:47 <mauke> everyone else uses utf-8
20:20:08 <ivanm> http://www.haskell.org/onlinereport/lexemes.html
20:20:13 <ivanm> mauke: depends on the distro, etc.
20:20:19 <mail> is there somewhere where there is haskell code conventions?
20:20:32 <ivanm> "Haskell uses the Unicode [11] character set. However, source programs are currently biased toward the ASCII character set used in earlier versions of Haskell ."
20:20:36 <ivanm> mail: in what sense?
20:20:46 <tensorpudding> Don't all reasonable OS's have some type of Unicode available out of the box now?
20:20:48 <ivanm> as in how to lay out code, etc.?
20:20:50 <mail> as in prefreed methods of laying out things
20:21:07 <ivanm> tensorpudding: most do; gentoo doesn't mandate unicode usage for example
20:21:10 <psykotic> haskell's String is actually an ideal user of utf-8 since you don't need O(1) random access :)
20:21:19 <ivanm> mail: hlint can help with how you write your code
20:21:24 <edwardk> dons: hrmm, who should i talk to about trying to fix the trac that is used for the summer of code? no one seems to be able to sign up.
20:21:26 <ivanm> there are a few unofficial standards around as well
20:21:28 <kmc> so the report says nothing about encoding
20:21:32 <tensorpudding> I'm not talking about "using UTF-8 for everything", but maybe having the UTF-8 locales installed
20:21:39 <kmc> that is it uses [Char] as the type of Haskell source code, and not [Word8]
20:21:43 <tensorpudding> along with iso-whatever
20:21:44 <psykotic> of course, the fact it is represented as a concrete rather than abstract list makes it moot
20:21:46 <ivanm> kmc: nope; I must have gotten confused between unicode and utf-x
20:21:47 <ivanm> :s
20:22:17 <kmc> and it's up to the implementation to interpret bytes probably in the locale-dependent way
20:22:41 <tensorpudding> There aren't enough programming languages that use non-ASCII charaters.
20:23:30 <ivanm> tensorpudding: :o
20:23:35 <ivanm> you want _more_? :o
20:23:56 <tensorpudding> How many are there?
20:23:57 <kmc> Java, APL...
20:24:04 <tensorpudding> I can think of APL and Piet.
20:24:24 <tensorpudding> Also, there is that Chinese Python.
20:24:59 <kmc> not sure if Java specifies a source encoding, if so it's almost certainly UTF-8
20:25:33 <ivanm> kmc: utf-16 apparently (internally, anyway)
20:25:43 <ivanm> http://java.sun.com/javase/technologies/core/basic/intl/faq.jsp
20:27:54 <c_wraith> It used to be UCS-16
20:28:01 <c_wraith> I think that changed in 1.4?
20:28:17 <tensorpudding> Anyway, restricting a programming language to emulating English words and grammar is pretty provincial if you ask me.
20:28:52 <ivanm> tensorpudding: *shrug* most of them came out from english-speaking countries
20:28:54 <tensorpudding> Well, less the grammar aspect.
20:29:15 <ivanm> and there's no "universal" grammar that can be used that makes it speaking-language-agnostic
20:29:16 <c_wraith> I'm amazed ruby's support for non-english languages is so bad, considering that it originated in japan
20:30:06 <tensorpudding> It's a lot easier to program with English words than be able to speak and write English.
20:31:18 <nus> JFYI, http://ru.wikipedia.org/wiki/Категория:Языки_программирования_с_русскими_ключевыми_словами
20:34:06 <tensorpudding> I can read that!
20:34:12 <tensorpudding> (the URL)
20:34:45 <tensorpudding> Unfortunately, IRC thinks that the URL ends before the Я.
20:34:48 <TheOtherMog> Is it #haskell related?
20:34:52 <dankna> I can even see the url, haha
20:34:59 <dankna> but I have no idea what it means
20:35:45 <shapr> nus: You learning Haskell?
20:35:51 <nus> progrlangs with russian keywords
20:35:52 <tensorpudding> It's a list of programming languages that use the Russian language.
20:36:00 <ivanm> dankna: something like: "Programming languages that use Russian words"
20:36:01 <shapr> Ah, cool.
20:36:05 <nus> that's what's @ URL
20:36:08 <b4taylor> Holy crap vty-ui is quite sweet.
20:36:15 <ivanm> not quite sure what ключевыми means
20:36:16 <nus> shapr, continously (-:
20:36:17 <tensorpudding> But I've never heard of any of them.
20:36:20 <b4taylor> The <--> and <++> combinators do what I expect!
20:36:22 <shapr> nus: Awesome!
20:36:39 <tensorpudding> klyuchebymi?
20:36:39 <kmc> key?
20:36:47 <mail> data Suit = Club | Diamond | Heart | Spade deriving (Show, Eq, Ord, Enum)
20:36:47 * twink can't cut/paste it.
20:36:48 <ivanm> duh, that makes sense...
20:37:00 <mail> how the hell does Ord decide which suit is greater than the other
20:37:01 <kmc> Category: Programming languages with Russian keyword
20:37:04 <ivanm> ключi is keys...
20:37:08 <shapr> mail: Which one did you put first?
20:37:08 <tensorpudding> err
20:37:13 <ivanm> mail: later ones are higher values
20:37:15 <Zao> mail: Left-to-right.
20:37:17 <tensorpudding> yeah i did know that
20:37:21 <ivanm> @src Bool
20:37:22 <lambdabot> data Bool = False | True deriving (Eq, Ord)
20:37:24 * twink can't cut/paste the Russian wikipedia URL.
20:37:25 <Zao> mail: If equal, compare fields left-to-right.
20:37:27 <ivanm> > True > False
20:37:28 <lambdabot>   True
20:37:29 <mm_freak_> > please give me 3
20:37:31 <lambdabot>   3
20:37:37 <ivanm> twink: :o
20:37:38 <kmc> google is pretty good with idiomatic / technical translation now
20:37:46 <Zao> mm_freak_: @let abuse, eh?
20:37:48 <SamB_XP> @type please
20:37:49 <lambdabot> Not in scope: `please'
20:37:55 <SamB_XP> > please
20:37:56 <lambdabot>   Not in scope: `please'
20:38:01 <Zao> tensorpudding: I can c/p it, but I cannot click on it properly :)
20:38:02 <mm_freak_> Zao: sure
20:38:14 <SamB_XP> who unlet again ?
20:38:16 <b4taylor> > please show me a good time
20:38:17 <lambdabot>   Not in scope: `please'Not in scope: `me'Not in scope: `good'Not in scope: `...
20:38:30 <b4taylor> :(
20:38:40 <mail> can i change how Ord works if i instance it
20:38:48 <Zao> mail: Of course.
20:38:49 <tensorpudding> Unfortunately the emacs parser that decides when something is a URL doesn't think Cyrillic can be part of a URL.
20:38:49 <b4taylor> mail: Yup.
20:38:50 <ivanm> an explicit instance? yes
20:38:57 <ivanm> mail: but then you can't derive it
20:39:03 <b4taylor> mail: But you can't derive it and then override it.
20:39:04 <twink> nus: Any chance of tinyurl/etc.?
20:39:05 <tensorpudding> I doubt this is restricted to Cyrillic though.
20:39:22 <ivanm> tensorpudding: do you ever use an embedded w3m within emacs?
20:39:30 * danderson discovers uncurry, and is afraid
20:39:32 <nus> twink, http://ru.wikipedia.org/wiki/%D0%9A%D0%B0%D1%82%D0%B5%D0%B3%D0%BE%D1%80%D0%B8%D1%8F:%D0%AF%D0%B7%D1%8B%D0%BA%D0%B8_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F_%D1%81_%D1%80%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%BC%D0%B8_%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%B2%D1%8B%D0%BC%D0%B8_%D1%81%D0%BB%D0%BE%D0%B2%D0%B0%D0%BC%D0%B8
20:39:32 <b4taylor> tensorpudding: Most people don't think that Cyrillic should be part of anything.
20:39:39 <ivanm> nus: *shudder*
20:39:40 <danderson> also, hlint gives pretty amazing hints.
20:39:48 <tensorpudding> b4taylor: Who thinks that?
20:39:49 <twink> nus: Oh dear.
20:39:55 <ivanm> danderson: why are you afraid?
20:40:02 <tensorpudding> ivanm: No, I'm not nearly hardcore enough to do that.
20:40:02 <ivanm> @slap b4taylor
20:40:03 * lambdabot is overcome by a sudden desire to hurt b4taylor
20:40:05 <b4taylor> tensorpudding: I have no problem turning bytes with a high bit set into '?' :p
20:40:05 <ivanm> tensorpudding: heh
20:40:29 <ivanm> tensorpudding: I use it to view html emails within gnus, except you can't navigate, copy, etc. within it for some reason :s
20:40:35 <ivanm> (or maybe I just haven't worked out how...)
20:40:42 <nus> basically, there're/were variants of Algol, Prolog, Logo
20:40:51 * b4taylor hopes there is a mail parsing lib on hackage...
20:40:52 <danderson> ivanm: mostly because the module is already a point-free fest of higher order functions that I don't stand a chance of parsing successfully if I return to it in a week
20:41:04 <b4taylor> Oh mbox...
20:41:05 <b4taylor> Nice.
20:41:05 <tensorpudding> I recognized Лого as probably being Logo.
20:41:07 <danderson> and uncurry just adds one more abstraction :)
20:41:09 <ivanm> nus: oh, the whole "well, we could use these languages that came out of America, or we can make our own variants that aren't as good" approach?
20:41:11 <dankna> @hoogle expectJust
20:41:11 <lambdabot> No results found
20:41:28 <danderson> :t fromJust
20:41:29 <lambdabot> forall a. Maybe a -> a
20:41:35 <danderson> dankna: ^ ?
20:41:42 <b4taylor> :t flip
20:41:43 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
20:41:54 <b4taylor> I'm still laugh at that.
20:42:00 <ivanm> @hoogle isJust
20:42:00 <lambdabot> Data.Maybe isJust :: Maybe a -> Bool
20:42:06 <ivanm> b4taylor: why?
20:42:10 <nus> ivanm, http://en.wikipedia.org/wiki/Refal for what didn't came from the yankies
20:42:15 <b4taylor> ivanm: Because it was done by hand?
20:43:23 <ivanm> b4taylor: ummm.... you laugh at flip because it was done by hand?
20:44:18 <b4taylor> ivanm: I suppose so. I don't know how to describe it. So I think I'll go back to being quite for a few days.
20:45:21 <ivanm> nus: so the developer was "Born in Russia"... I wonder if he was actually born in Russia or that's the common lazy western approach of USSR == Russia ...
20:46:32 <tensorpudding> If he wasn't born in Russia, but a different part of the former USSR, why wouldn't they say so?
20:47:17 <ivanm> tensorpudding: look at a lot of cold war literature, etc. and they quite often use "Russia" and "Russians" to denote the USSR and its citizens
20:47:35 <nus> ivanm, this is a expatriate who once upon a time was amongst not many who defended Sakharov.
20:47:39 <ivanm> so if the bibliography was written back then, it might be that same kind of dodgy writing/bias
20:47:40 <nus> an*
20:47:57 <dankna> aat the time he was born
20:47:57 <tensorpudding> The ru wikipedia says that he was born in Moscow.
20:48:00 <kamatsu> so, I just upgraded to GHC 6.12.1 at last, after staying on 6.10 for ages
20:48:00 <dankna> it was probably ALL the USSR
20:48:09 <kamatsu> surprisingly, everything kept working
20:48:31 <tensorpudding> They often disambiguate when they say that someone was born in a city which was once part of a different country than it is now.
20:48:36 <tensorpudding> (wikipedia that is)
20:48:54 <nus> ivanm, first version of Refal is said to be ~1966
20:49:25 <ivanm> yeah, I saw that
20:49:39 <ivanm> dankna: seperate countries still
20:49:52 <ivanm> USSR was _technically_ a union; something like the EU
20:49:53 <dankna> that's a point
20:50:07 <dankna> I doubt the EU would care much for that comparison :D
20:50:09 <ivanm> kamatsu: most libraries will need to be rebuilt
20:50:27 <ivanm> dankna: agreed; in theory, however, it was similar to the EU now
20:50:29 <twink> ivanm: Somewhere between the US and EU, no?
20:50:42 <dankna> fair enough
20:50:47 <ivanm> twink: hmmm.... maybe
20:51:07 <kmc> let's analyze the soviet constitution
20:51:09 <kmc> here in #haskell
20:51:19 <ivanm> (when I'm saying "in theory", I mean that it was meant to be a bunch of countries with a common foreign policy, currency, etc.)
20:51:30 <kmc> anyway whatever the constitution said, the Russian SFSR got to push everyone else around
20:51:33 * ivanm avoids the /.-y jokes
20:51:33 <tensorpudding> The wikipedia article of the mathematician Kronecker does a disambiguation, since he was born in Liegnitz, Prussia, which is now Legnica, Poland.
20:51:38 <ivanm> kmc: exactly
20:52:12 <tehgeekmeister> how do you append two bytestrings?  it appears to not be ++ under the bytestring module
20:52:16 <ivanm> anyway, my whole point about Turchin was that it just says "Russia"; since it doesn't list a town or anything it's difficult to be more precise about what they mean
20:52:26 <ivanm> @hoogle Bytestring -> Bytestring -> Bytestring
20:52:26 <lambdabot> Did you mean: ByteString -> ByteString -> ByteString /count=20
20:52:26 <lambdabot> Prelude asTypeOf :: a -> a -> a
20:52:26 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
20:52:43 <ivanm> @hoogle ByteString -> ByteString -> ByteString
20:52:43 <lambdabot> Data.ByteString append :: ByteString -> ByteString -> ByteString
20:52:44 <lambdabot> Data.ByteString.Char8 append :: ByteString -> ByteString -> ByteString
20:52:44 <lambdabot> Data.ByteString.Lazy append :: ByteString -> ByteString -> ByteString
20:52:52 <tensorpudding> Wasn't there still a meaningful definition of Russia separate from the USSR?
20:52:59 * ivanm can never remember whether it's ByteString or Bytestring
20:53:00 <altmattr> OK folks, I have a tricky question I think - it will be tricky just to explain it - here goes.  I want to have multiple versions of some algorithms/functions in my code.  I want to be able to use one version in one place and another in other places.  There are up to a dozen or so versions, all for different places, but all doing the one thing (just in different ways).  easy so far - just implement a dozen or so functions, right?  But 
20:53:01 <altmattr> function operates over a large datatype (lets say about 15 constructors) and most of them are treated identically in each version of the algorithm.  So the question is - how can I structure my code so I don't have to repeat myself unnecessarily?
20:53:14 <ivanm> tehgeekmeister: anywya, it's append (using whatever bytestring module you're using)
20:53:22 <ivanm> tensorpudding: yes, technically
20:53:30 <ivanm> in reality Russia bossed around the rest of the USSR
20:53:51 <ivanm> altmattr: common sub functions?
20:53:52 <kmc> altmattr, you know about one of the generics libraries like Scrap Your Boilerplate or Uniplate?
20:53:54 <ivanm> type class?
20:54:03 * ivanm isn't sure he fully understands what altmattr wants
20:54:42 <altmattr> kmc: syb does something different
20:54:53 <altmattr> common subfunctions seems like a smart idea
20:55:00 <kmc> is it the same datatype each time?
20:55:14 <altmattr> kmc: yes
20:55:24 <cdsmithus> altmattr: if I understand you correctly, you could implement the common parts, and then delegate from catch-all cases?  If the functions are recursive, then throw in an extra parameter or a type class.
20:55:48 <kmc> yeah, perhaps you can write a recursive traversal that also takes a record of functions indicating what to do at various points
20:55:50 <cdsmithus> I mean implement the common parts in their own (non-total) function
20:55:59 <altmattr> cdsmithus: this is how I am doing it so far (they are recursive) and I have to tie myself in knots getting the right things imported and exported
20:56:10 <kmc> you can use typeclasses but sometimes it's more convenient to pass the dictionary of stuff to do explicitly
20:56:29 <altmattr> I got it working for the main alg, but now have to do it for 3 more and am not keen on jumping through all that again, and the combinations will get hairy
20:57:09 <altmattr> the datatype remains the same, so typeclasses don't seem right
20:57:34 <cdsmithus> altmattr: yes, if you wanted to use type classes, you'd need to wrap the data type, which would be a pain.
20:57:48 <nus> altmattr, if the datatype remains the same, the primops should be the same, no?
20:58:07 <cdsmithus> And completely unnecessary, since type classes seem the wrong abstraction for what you are doing
20:58:08 <altmattr> nus: fraid not.
20:58:37 <altmattr> more detail: it is type inference on an expression langauge and I want multiple versions, ones with rank-2, ones without, etc
20:58:41 <kmc> it's a common design error to use typeclasses as a roundabout way to pass a function as a parameter
20:59:02 <tehgeekmeister> ivanm: thanks!
20:59:11 <altmattr> kmc: I like the record of functions idea, hmmmm
20:59:23 <altmattr> and I just read the implemneting type classes paper the other day!
20:59:58 <dons> edwardk: igloo
21:00:07 <nus> the record of functions isn't that far from multiparam type class
21:00:10 <ivanm> tehgeekmeister: no worries
21:00:37 <edwardk> dons: k, i'll harass igloo then ;)
21:01:03 * ivanm notices that dons hasn't bothered to comment on how_gauche's characterisation of him at http://www.reddit.com/r/haskell/comments/bdbly/getting_45k_requestssecond_with_the_snap_web/c0m79mj
21:01:09 <altmattr> am I right in thinking I have hit the expression problem and am trying to do something more easily written in OO langauges?
21:01:18 <edwardk> @tell igloo the summer-of-code trac is still having signup issues. whatever you did before added the registration form, but no one can actually fill it out successfully.
21:01:19 <lambdabot> Consider it noted.
21:01:25 <altmattr> i hope not, I am trying to exorcise OO thinking from my brain
21:02:12 <ned> altmattr: better call a priest.
21:02:19 <ivanm> altmattr: more likely you haven't written it in a sufficiently haskellian fashioin ;-)
21:02:42 <kmc> remember every good OO language is functional too
21:02:51 <kmc> an object is just a record of functions
21:03:13 <tehgeekmeister> how do i represent a character in decimal/octal/hexadecimal inside a string literal?
21:03:22 <ivanm> kmc: except you can't compose objects as easily as you can compose functions....
21:03:30 <ivanm> tehgeekmeister: show ?
21:03:31 <kmc> you can't compose records of functions very easily
21:03:39 <altmattr> ivanm: lets go with that
21:03:46 <altmattr> thanks all, some really interesting ideas in there
21:03:47 <kmc> in a good OO language you can concisely write a class whose method composes some other methods
21:03:59 <kmc> that's just a matter of syntax, and of Java and C++ in particularly having very weak syntactic support for FP
21:04:08 <kmc> it's not a general problem with the idea of OO
21:04:33 <tehgeekmeister> ivanm: no, i have the numeric forms of characters i can't (easily) type right now, and want a way to be able to match against them in my code.
21:04:40 <tehgeekmeister> guess i can copy/paste if need be
21:06:22 * ivanm still isn't following
21:06:32 <ivanm> why do you want numbers in String form?
21:07:55 <tehgeekmeister> no, i want characters in literal hexadecimal/octal form
21:08:03 <tehgeekmeister> for encoding accents and such that i can't type
21:09:17 <ivanm> then it's something like '\o235' or something
21:09:21 <ivanm> > text '\o234'
21:09:22 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
21:09:22 <lambdabot>         against inferred ty...
21:09:27 <ivanm> > char '\o234'
21:09:37 <ivanm> looks like that isn't right...
21:10:15 <tehgeekmeister> i can paste for now, i'll figure it out later
21:10:15 <tehgeekmeister> thanks
21:11:21 <cdsmithus> Distilled version of my earlier question on type families and type-level programming: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23978
21:11:25 <tehgeekmeister> @src toUpper
21:11:25 <lambdabot> Source not found. You untyped fool!
21:11:34 <tehgeekmeister> @src toLower
21:11:34 <lambdabot> Source not found.
21:12:40 <ivanm> tehgeekmeister: yeah, I think they assume ASCII...
21:13:10 <tehgeekmeister> oh, so i can't paste iso 8859 stuff in
21:13:13 <tehgeekmeister> crap
21:13:21 <tehgeekmeister> i hate encodings
21:13:44 <harrison> i just finished my first literate haskell program. it was so much more satisfying than writing regular code.
21:14:40 <tehgeekmeister> all i need to do is replace accented characters with their unaccented versions, maybe there's a simpler way/some function that already does this that i'm not aware of?
21:15:02 <kmc> heh
21:15:07 <kmc> i wrote one lhs program in my life
21:15:10 <kmc> in latex style
21:15:12 <kmc> to show off for a class
21:15:19 <kmc> then decided it wasn't worth the effort ;P
21:15:28 <dons> hehe
21:15:33 <ivanm> tehgeekmeister: not that I know of
21:15:49 <ivanm> tehgeekmeister: maybe try one of the encoding, icu, etc. libraries?
21:16:50 <tehgeekmeister> oh, good idea, those won't be on hoogle anyway
21:18:33 <harrison> kmc: that's what i did. 'cept i used bird style, because i intend to make a few changes and stick it on my blog once it's marked (or once everyone hands theirs in)
21:19:05 <kmc> yeah
21:19:11 <kmc> i really like this literate blogging trend
21:21:45 <harrison> there was a bit of an issue with pandoc, but there's a workaround, so it's okay.
21:21:46 <harrison> (ghc doesn't like lines starting with '#', bug i'm guessing. but pandoc uses it as sugar for <h> tags)
21:22:50 <ivanm> harrison: lines starting with a # are pre-processor lines in ghc
21:23:41 <harrison> ivanm: ah. i wasn't aware it had a preprocessor :p
21:24:07 <ivanm> CPP
21:24:15 <ivanm> so it's technically C's pre-processor
21:24:20 <kmc> if CPP is not enabled, does GHC care?
21:24:52 <ivanm> then it's not parseable
21:25:00 <ivanm> however, it sounds like there's a parsing bug in literate haskell
21:25:08 <tehgeekmeister> > '\x123'
21:25:09 <lambdabot>   '\291'
21:25:23 <tehgeekmeister> > '\123'
21:25:24 <lambdabot>   '{'
21:25:30 <tehgeekmeister> tada!  figured that out.
21:25:40 <ivanm> on, no `o'
21:25:47 <SamB_XP> I think GHC probably still accepts line directives even if CPP is not on?
21:28:22 <edwardk> SamB_XP: that sounds right
21:34:44 <tehgeekmeister> what's necessary to pattern match against characters in a bytestring?
21:34:57 <ivanm> you can't
21:35:08 <kmc> bytestrings contain bytes, not characters
21:35:25 <ivanm> exactly
21:35:36 <kmc> they could (but don't) provide a "view" function for pattern matching.  i suppose unpack is the view from the left
21:35:40 <ivanm> aren't they more akin to arrays under the hood?
21:35:44 <tehgeekmeister> even char8 bytestrings?
21:35:57 <kmc> Char8 bytestrings also contain bytes but they cheat and let you pretend they're chars
21:36:11 <tehgeekmeister> i can unpack and repack themj
21:36:16 <tehgeekmeister> but that seems silly if it's avoidable
21:36:52 <kmc> i don't know that unpacking and matching against the beginning is less efficient than other ways of interrogating the beginning of a bytestring
21:36:56 <kmc> with laziness it's plausible that it's not
21:37:03 <kmc> also there are regex libraries that use bytestring aren't there?
21:37:53 <tehgeekmeister> kmc: perhaps a good idea to use them, but i just need to replace some characters
21:37:54 <ivanm> and parsing libraries
21:38:00 <tehgeekmeister> so i'm trying to avoid any overkill
21:38:07 <tehgeekmeister> replace accented e with e, for example
21:38:08 <ivanm> methinks you're using bytestrings wrong then
21:38:11 <kmc> well in the general case you'll have to repack to do that
21:38:13 <ivanm> maybe text would work?
21:38:19 <kmc> unless you want to mutate the bytestring in place
21:38:24 <kmc> which is sort of forbidden if you use the pure API
21:38:40 <tehgeekmeister> well, i'm generating a new bytestring
21:38:57 <kmc> then it has to live in a new array
21:39:02 <tehgeekmeister> so far i've got a lazy function that produces a new bytestring from an old one, i just want it to replace accents at the same time
21:39:08 <kmc> you have to stream the characters out of one array and into another
21:39:22 <kmc> and the way you stream data like that is by composing a lazy list producer and a lazy list consumer
21:39:25 <kmc> i.e. unpack and pack
21:39:38 <tehgeekmeister> oh, unpack and pack will be lazy, i didn't think about that
21:39:38 <kmc> hopefully it will optimize into a simple loop
21:39:49 <kmc> but i don't know for sure, you'd have to look at generated code
21:39:49 <tehgeekmeister> even if it doesn't it's not a huge deal
21:39:52 <kmc> or ask one of the wizards here
21:39:59 <tehgeekmeister> i just don't want to put a lot of work in now
21:40:05 <tehgeekmeister> this is a hackish first version for myself
21:40:10 <kmc> then use unpack/pack and don't worry about it ;)
21:40:11 <tehgeekmeister> optimization can come later
21:40:19 <tehgeekmeister> sounds good
21:40:37 <tehgeekmeister> oh, yeah, and if i only pattern match against the beginning it really WILL be lazy
21:42:15 <mail> wth cntrl L works in ghci
21:47:56 <tehgeekmeister> > '\233'
21:47:56 <lambdabot>   '\233'
21:48:10 <tehgeekmeister> bah!  i'll have to convert encodings anyway.
21:48:12 <applicative> mail: what does ^L do in ghci?
21:48:24 <mail> clear screen
21:48:45 <kmc> it's not redraw?
21:49:12 <applicative> indeed, gets rid of all the accusations from the typechecker, didn't know
21:50:21 <applicative> i see its a general shell phenomenon, no wonder i didn't know
21:50:26 <kmc> haha
21:50:39 <kmc> would be nice if ghci had a cheat code to turn type errors into warnings
21:51:33 <applicative> module "I'm just trying this out so dont get mad" where ....
21:52:41 <applicative> or maybe a go easy pragma {-#MORALS loose #-}
21:53:06 <ivanm> heh
21:53:19 <ivanm> @remember applicative {-# MORALS loose #-}
21:53:19 <lambdabot> Nice!
21:55:05 <mail> holy shit shuffling a list is loooong in haskell
21:55:32 <nus> {-# IDDQD #}
21:55:36 <dons> long?
21:55:48 <dons> verbose?
21:55:49 <ivanm> there's a shuffle package on hackage
21:55:53 <ivanm> dons: presumably
21:56:01 <ivanm> mail: of course, that depends if you're doing it properly
21:56:07 <ivanm> @google haskell perfect shuffling
21:56:08 <lambdabot> http://okmij.org/ftp/Haskell/perfect-shuffle.txt
21:56:12 <dons> http://hackage.haskell.org/packages/archive/random-shuffle/0.0.2/doc/html/System-Random-Shuffle.html
21:56:23 <ivanm> dons: if only the uploader of that knew about haddock...
21:56:34 <dons> oh my
21:56:40 <dons> http://hackage.haskell.org/packages/archive/random-shuffle/0.0.2/doc/html/src/System-Random-Shuffle.html#shuffle
21:56:41 <adu> they're talking about Haskell in #C ... :)
21:56:43 <dons> good docs
21:57:02 <dons> adu cool. all good words, i trust :)
21:57:05 <ivanm> since it's just a straight copy/paste from oleg's site
21:57:20 <dons> oh. maybe it is in liboleg
21:57:30 <ivanm> dons: there's an actual liboleg? :o
21:57:35 <dons> mm. must not have added it.
21:57:39 <dons> http://hackage.haskell.org/package/liboleg
21:57:49 <ivanm> nope
21:57:55 <dons> i just update it when oleg posts new things. but haven't gone back as far as some of his older stuff
21:58:04 <ivanm> unless you put it inside some other module
21:58:11 <dons> prob. not.
21:58:16 <ivanm> dons: though realistically, most of that should probably be split into smaller libraries
21:58:30 <dons> yep. it's just getting it onto hackage in the first palce
21:58:31 <adu> can I make a libadu?
21:59:01 <ivanm> adu: you can, but do you have anything worth contributing that people will instantly recognise your name and know who the lib is referring to?
21:59:04 <ivanm> @quote oleg
21:59:04 <adu> or a libdons
21:59:05 <lambdabot> oleg says: Unfortunately, once it became clear that the ideas are working out, the motivation fizzled.
21:59:16 <ivanm> libdons == fusion + bytestring + etc.
21:59:21 <ivanm> @quote oleg
21:59:21 <lambdabot> oleg says: It is known, albeit not so well, that following the OOP letter and practice may lead to insidious errors.
21:59:23 <ivanm> @quote oleg
21:59:24 <lambdabot> oleg says: Unfortunately, once it became clear that the ideas are working out, the motivation fizzled.
21:59:38 <ivanm> @quote milliolegs
21:59:38 <lambdabot> olsner says: < kmc> i think 250 milliolegs is enough to kill an elephant  < olsner> kmc: ... to kill an elephant - in the type system!
21:59:43 <ivanm> @quote milliolegs
21:59:44 <lambdabot> olsner says: < kmc> i think 250 milliolegs is enough to kill an elephant  < olsner> kmc: ... to kill an elephant - in the type system!
21:59:48 <ivanm> isn't there another one?
22:01:06 <adu> ivanm: nope, i do not
22:01:32 <adu> ivanm: so far I just have libObscureMathExperiments
22:08:52 <tehgeekmeister> probably shouldn't repeatedly unpack and pack the same bytestring, tho.  like ten times in a row.  probably best to unpack and then process and then repack.
22:15:48 <dibblego> @type join . find isJust -- is this in the standard library?
22:15:49 <lambdabot> forall a. [Maybe a] -> Maybe a
22:16:14 <dibblego> @hoogle (Traversable t, Monoid m) => t (m a) -> m a
22:16:15 <lambdabot> Data.Foldable asum :: (Foldable t, Alternative f) => t (f a) -> f a
22:16:15 <lambdabot> Data.Foldable msum :: (Foldable t, MonadPlus m) => t (m a) -> m a
22:16:15 <lambdabot> Data.Foldable concat :: Foldable t => t [a] -> [a]
22:19:39 <nus> @quote .*oleg.*
22:19:40 <lambdabot> syntaxglitch says: every time I have a cool idea about something that might work in Haskell, I go check Oleg's stuff and find that 1) he already did it 2) thought it out better 3) did it incidentally
22:19:40 <lambdabot> while working on something way more interesting
22:19:57 <nus> @quote .*oleg.*
22:19:57 <lambdabot> emu says: olegarithmic!
22:20:00 <nus> @quote .*oleg.*
22:20:01 <lambdabot> Pseudonym says: Olegs can be warded off by adding a note claiming that it's impossible to implement in the type system.
22:20:08 <nus> @quote .*oleg.*
22:20:08 <lambdabot> audreyt says: assembly would require metaolegs (or megaolegs)
22:20:11 <nus> @quote .*oleg.*
22:20:11 <lambdabot> inimino says: actually, Chuck Norris is the Oleg of everything else
22:20:23 <philo> hi
22:20:28 <nus> ih
22:21:03 <philo> class (Eq temp,Eq label,Monad (temp label)) => TempGenerator temp label
22:21:18 <philo> get me : Kind error: `temp' is applied to too many type arguments
22:21:20 <philo> any idea
22:21:41 <philo> ?
22:22:16 <c_wraith> Seems pretty straightforward to me.  The Eq constraint says temp has kind *, but the monad constraint says it has kind * -> *
22:22:43 <c_wraith> err, actually, the monad constraint says it has kind * -> * -> *
22:23:34 <philo> hummm
22:23:42 <philo> ok you totaly lost me there
22:23:56 <philo> can you point me to the relevant doc about "kinds"
22:23:59 <philo> ?
22:24:00 <c_wraith> Think of kinds as the type of a type.
22:24:14 <philo> ok
22:24:18 <c_wraith> Concrete types have kind * (mostly.  there are some exceptions, but you can ignore them for these purposes)
22:24:37 <c_wraith> Type constructors take arguments, and have different kinds.
22:24:42 <nus> philo, what you substitute as temp
22:24:52 <nus> philo, is a type constructor
22:24:52 <c_wraith> Maybe, for instance type constructor with kind * -> *
22:25:08 <c_wraith> err, for instance *is a * type...
22:25:43 <philo> ok i think i follow you
22:26:07 <c_wraith> Well, things that are instances of Eq need to have kind *
22:26:13 <c_wraith> that is, they need to be concrete types
22:26:28 <c_wraith> Things that are instances of monad need to be of kind * -> *.
22:26:39 <c_wraith> That is, they are type constructors (like Maybe or IO)
22:26:43 <philo> what i was trying to express is that TempGenerator is a subclass of Monad , and that temp and label are instance of Eq
22:27:21 <mail> you can achieve loads in haskell in a few lines, when you have to write lots of haskell code it seems cumbersome :/
22:28:21 <philo> is that possible ?
22:28:33 <c_wraith> unclear, from what you've given
22:28:43 <c_wraith> What is actually the monad?
22:28:52 <philo> c_wraith: State monad
22:28:53 <c_wraith> You need something that's a type constructor to work with.
22:29:10 <philo> i tried Monad(State (temp label))
22:29:14 <philo> but didnt work
22:29:19 <c_wraith> What should the type of "return 1" be?
22:29:31 <nus> philo, if temp = eq what do you want to do with TempGenerator?
22:29:39 <nus> err, temp = label
22:29:40 <mail> return 1 :: (Num t, Monad m) => m t
22:29:47 <mail> :t
22:29:55 <mail> how to use lambda bot?
22:30:08 <philo> nus temp <> label
22:30:30 <nus> philo, well in case it happens to be = ?
22:30:32 <ivanm> @list
22:30:33 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
22:30:34 <ivanm> mail: ^^
22:30:47 <philo> nus i am not sure to follow you ?
22:30:52 <philo> what is Eq ?
22:30:59 <nus> @src Eq
22:30:59 <lambdabot> class  Eq a  where
22:30:59 <lambdabot>     (==), (/=)   :: a -> a -> Bool
22:31:04 <applicative> @type return 1
22:31:05 <lambdabot> forall t (m :: * -> *). (Num t, Monad m) => m t
22:31:18 <philo> c_wraith:  ?
22:31:27 <mail> @free
22:31:27 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-23
22:31:40 <mail> @eval :t return 1
22:31:52 <mail> @help
22:31:52 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
22:31:56 <mail> @help eval
22:31:56 <lambdabot> eval. Do nothing (perversely)
22:32:10 <c_wraith> philo:  In the class you're defining, what is the monad relationship?
22:32:27 <applicative> mail, do you want the type, or do you want to evaluate the expression
22:32:46 <mail> @eval return 1
22:32:51 <philo> c_wraith:  i am not an expert in monad ... what do you mean by monad relationship ?
22:32:54 <mail> @type return 1
22:32:55 <lambdabot> forall t (m :: * -> *). (Num t, Monad m) => m t
22:32:58 <applicative> > return 1
22:32:59 <lambdabot>   No instance for (GHC.Show.Show (m t))
22:32:59 <lambdabot>    arising from a use of `M1904140936...
22:33:04 <philo> i am trying to define a "subclass" of state moand
22:33:21 <mail> clear
22:33:32 <c_wraith> philo: Why the state monad?
22:33:43 <nus> philo, what programming languages do you have experience with?
22:33:50 <applicative> > return 1 >>= (:[23])
22:33:51 <lambdabot>   [1,23]
22:34:07 <philo> the Generator is suposed distinct label and temp everytime
22:34:26 <philo> i will use the state to save the information about already generated object
22:34:36 <philo> applicative:  ??
22:34:47 <c_wraith> why does that belong in the type?  That sounds like an implementation detail
22:35:08 <lowasser> note to self: figuring out from scratch how to do unificationy things is *hard*
22:35:16 <philo> c_wraith:  i see your point
22:35:31 <mail> http://abstrusegoose.com/strips/computer_science_major.PNG
22:35:35 <mail> hahaha
22:35:36 <mail> classic
22:35:41 <dibblego> is there  a safeHead :: [a] -> a -> a ?
22:35:52 <mail> thats the exact bloody module i'm doing atm
22:35:53 <lowasser> something with fromMaybe and listToMaybe
22:36:01 <mail> and my reaction was pretty similar
22:36:06 <jmcarthur> philo: what does a subclass of the state monad do?
22:36:24 <lowasser> mail: who are you talking to?
22:36:28 <philo> the same thing as the state monad ?
22:37:03 <twink> Wouldn't safeHead basically be listToMaybe?
22:37:04 <jmcarthur> philo: i think the terminology you want is that you want to define a new type based on the state monad
22:37:28 <jmcarthur> philo: in which case, i would say:  newtype Foo s a = Foo (State s a)
22:37:37 <c_wraith> philo, I really think you want TempGenerator to be data instead of a class, for the time being.  Work out an implementation first.  Then if you need a second implementation, put the common functionality in a class.
22:37:52 <dibblego> \a -> fromMaybe a . listToMaybe
22:37:57 <dibblego> but that's ick
22:38:00 <jmcarthur> philo: and then you either need to use GeneralizedNewtypeDeriving or manually define an instance of Monad and MonadState for Foo
22:38:15 <philo> jmcarthur: ok , and then make Foo an instannce of TempGenerator ?
22:38:31 <jmcarthur> i don't know the context of your problem, so i don't know what TempGenerator is
22:39:05 <philo> c_wraith:  the exercice is the building the class lol
22:39:21 <philo> ok let me try to phrase my probleme...
22:39:28 <applicative> dibbledego, http://hackage.haskell.org/packages/archive/safe/0.2/doc/html/Safe.html  headDef
22:40:16 <philo> i need and "object"  (sorry comming from c++) that is a State Monad, and have additional function on it ...
22:40:28 <philo> an*
22:41:01 <applicative> dibblego, it has  headDef :: a -> [a] -> a     headMay :: [a] -> Maybe a
22:41:17 <dibblego> applicative, thanks
22:41:25 <philo> what is the "haskelliest" approach ?
22:41:39 <nus> philo, what you need is to stop thinking in objects...
22:42:01 <philo> philo ince the class building exercice... lol
22:42:21 <philo> nus*
22:43:17 <c_wraith> well, start by skipping the constraints, and just thinking about what all you need in your class's parameter list.
22:44:02 <c_wraith> Was "temp" in your definition intended to be the state?
22:44:14 <philo> no
22:44:32 <c_wraith> Honestly, I don't think the problem is a very haskell kind of problem.
22:44:47 <c_wraith> You'd find a different approach
22:44:48 <philo> the state would look like [temp] [label]
22:45:13 <philo> c_wraith:  the basic probleme is that i am looking for something to thread a state
22:45:41 <c_wraith> Why do you care that it's a state monad?
22:45:54 <philo> i was trying to mimic this : http://www.haskell.org/all_about_monads/examples/example15.hs
22:45:58 <c_wraith> I can see wanting to enforce that it's a monad, just because that lets you make the threading behavior clear
22:46:46 <philo> philo i though state monad what the  most appropriate since i want to deal with a state ... no ?
22:46:53 <philo> c_wraith: *
22:47:13 <c_wraith> maybe.  Maybe you want ST.  Maybe you want IO.
22:47:40 <Gracenotes> Maybe you want a sandwich.
22:47:52 <philo> Gracenotes: lol
22:48:17 <philo> c_wraith: the State Monad seemed to be the cleaner of all those
22:48:29 <c_wraith> ST is just as clean as State.
22:48:38 <c_wraith> IO is necessarily more complicated
22:49:27 <philo> ok
22:49:52 <Gracenotes> not mention the complications of ST , eh
22:50:42 <c_wraith> I really don't think the question is a very haskell question, at the moment.
22:50:56 <Gracenotes> to use ST in the same way you use State, you need some GHC type extensions, and even then it doesn't do as much. Thought this is hardly a deal-breaker.
22:51:09 <Gracenotes> *though
22:51:34 <c_wraith> even state needs the MultiParameterTypeclass extension
22:51:52 <EvanR> @src reverse
22:51:52 <lambdabot> reverse = foldl (flip (:)) []
22:52:00 <c_wraith> Just because everyone implements it in terms of MonadState
22:52:27 <EvanR> @src flip
22:52:28 <lambdabot> flip f x y = f y x
22:53:26 <c_wraith> philo, this is homework, right?  Any chance I can see the original question?
22:53:42 <philo> is confused what is MonadState and how does it relate to State s a ?
22:54:02 <c_wraith> MonadState is an abstraction layer that allows State and StateT to share functions
22:54:03 <philo> c_wraith:  part of ...
22:54:15 <philo> building a compiler
22:54:33 <philo> TempGenerator is part of the lexical analyser
22:54:44 <Gracenotes> c_wraith: ..weirder stuff
22:55:05 <philo> *sematic analyser i meant
22:55:19 <Gracenotes> weirder than MultiParameterTypeclass, which is an extension, methinks, mostly because it doesn't have as intuitive as an implementation as single-parameter
22:56:00 <philo> yea ,why multi parameter arent include in the standar haskell ?
22:56:01 <Gracenotes> ...or just because no one considered it initially
22:56:08 <c_wraith> I think the latter.
22:56:19 <c_wraith> The initial design of haskell didn't realize they'd be useful
22:57:15 <philo> what about now
22:57:24 <philo> do they plan to inlcude it soon ?
22:57:40 <c_wraith> I'm pretty sure every compiler out there supports the extension
22:58:05 <c_wraith> And that's the way the language is going to move forward...  Even when it standardizes things, it's standardizing them as extensions
22:58:13 <EvanR> #type flip
22:58:17 <EvanR> @type flip
22:58:18 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
22:59:13 <philo> c_wraith:  standardizing as extention ?
22:59:27 * hackagebot attoparsec 0.8.0.1 - Fast combinator parsing for bytestrings  http://hackage.haskell.org/package/attoparsec-0.8.0.1 (BryanOSullivan)
22:59:35 <c_wraith> Yes.  Standardized semantics for what extensions mean.
23:00:36 <philo> ok
23:00:58 <nus> @src ST
23:00:58 <lambdabot> newtype ST s a = ST (STRep s a)
23:01:00 <c_wraith> anyway.  You really have to implement this as a class for your assignment?
23:01:27 <nus> @hoogle a -> ST s a
23:01:27 <lambdabot> Control.Monad.ST unsafeIOToST :: IO a -> ST s a
23:01:27 <lambdabot> Control.Monad.ST.Lazy unsafeIOToST :: IO a -> ST s a
23:01:27 <lambdabot> Data.STRef writeSTRef :: STRef s a -> a -> ST s ()
23:01:43 <c_wraith> nus:  wouldn't that just be return?
23:02:10 <nus> @src STRep
23:02:10 <lambdabot> type STRep s a = State# s -> (# State# s, a #)
23:02:35 <c_wraith> amusingly...
23:02:38 <c_wraith> @src IO
23:02:38 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
23:02:54 <nus> c_wraith, been wondering what people happen to do with it, mostly
23:03:26 <c_wraith> mostly, implement algorithms that are more efficient in terms of mutation.  shuffling is a common example.
23:04:58 <c_wraith> ST allows you to use mutation internally, but still remain pure externally.
23:05:59 <c_wraith> :t runST
23:06:00 <lambdabot> forall a. (forall s. ST s a) -> a
23:06:07 <nus> c_wraith, sure, as long as the implementation gets it right.
23:06:32 <c_wraith> nus: you mean the ST implementation.  Because the type signature of runST enforces it.
23:06:45 <applicative> bos, you cant click through to the subordinate modules on the new attoparsec http://hackage.haskell.org/package/attoparsec
23:07:14 <applicative> bos, as you could http://hackage.haskell.org/package/attoparsec-0.8.0.0
23:07:37 <nus> c_wraith, the internal implementation of GHC, to be more specific.
23:07:51 <c_wraith> nus: sure.  But if that's incorrect, all your programs are suspect.
23:08:01 <c_wraith> nus: so using ST really has little to do with it
23:08:53 <nus> c_wraith, perhaps not all of my programs would be suspect, just ones using the ST implementation?
23:09:28 <nus> still, that's anything remotely touching IO, though...
23:09:32 <c_wraith> yeah
23:09:49 <c_wraith> Which is...  everything.
23:10:29 <c_wraith> philo: We still haven't really answered your question.
23:10:30 <bos> applicative: that's just because the haddock update runs in a batch job
23:10:40 <bos> applicative: it'll get updated within a few hours
23:10:42 <applicative> yes, i just figured that out, sorry
23:10:53 <applicative> all the new ones are so.
23:10:55 <philo> c_wraith:  not really
23:11:14 <philo> i figured out i have to clarify my ideas before asking any more uqestion
23:11:19 <philo> question *
23:11:25 <c_wraith> heh.  it always helps. :)
23:11:54 <philo> i think part of my probleme is that i though that State s t what a class
23:11:59 <philo> not  a data type
23:12:12 <c_wraith> indeed.  State is not a class. :)
23:12:23 <philo> yea
23:12:59 <philo> so i am trying to use newtype as it was pointed out
23:13:10 <c_wraith> ah.  That might be what you need.
23:16:34 <philo> c_wraith:  thanks for your time
23:16:43 <dons> bos: did you see these guys -- http://gregorycollins.net/posts/2010/03/12/attoparsec-iteratee#comment-39671374
23:16:53 <dons> alternative web server with per core epoll
23:17:01 <bos> dons: yeah. where'd you get the 45,000 req/sec number from?
23:17:04 <dons> using a completely separate software stack
23:17:10 <dons> bos, greg says in the comment
23:17:20 <dons> "I just "finished" the first draft of the http server last night, I'm getting 45k requests/second on my quad-core Linux box."
23:17:44 <dons> got to get their code running on your code
23:18:45 <bos> ah
23:19:02 <bos> 45k reqs/sec is far better than i've ever seen.
23:21:39 <dons> could 4x per-core event manager do that?
23:21:50 <dons> + using your parser.
23:22:07 <dons> have to get the code.
23:22:39 <bos> don't know
23:30:57 <dons> what's the status of the event work, btw. is tibbe going to merge it in during zurihac? :)
23:32:57 <Lycurgus> that kina stuff is fairly common in C/C++ libs like boost
23:33:31 <dons> what's that?
23:33:52 <kamatsu> @remember dons Oleg: A unit of measurement of type system complexity. Also, a famous computer scientist.
23:33:53 <lambdabot> It is stored.
23:34:00 <Lycurgus> processor task dedication functions
23:34:17 <dons> sure. common in haskell too.
23:34:19 <Lycurgus> processor/core/other
23:34:31 <dons> forkOnIO FTW.
23:34:41 <Lycurgus> i meant as routine stuff that just works
23:34:47 <Lycurgus> :)
23:35:55 <dons> i'm not sure what your point is.
23:36:06 <Lycurgus> merge into what?
23:36:15 <dons> ah, you're missing the context.
23:36:30 <dons> http://donsbot.wordpress.com/2010/01/17/playing-with-the-new-haskell-epoll-event-library/
23:36:47 <Lycurgus> ah, OK
23:38:53 <Axman6> hmm, with LLVM and the epoll work, haskell is looking more and more awesome for high performance work every day :)
23:39:38 <dons> need more apps though. more apps and libs tested at scale.
23:39:55 <dons> heading in the right direction though.
23:40:06 <Ke> you need arrays for high troughput
23:40:36 <Ke> there is no way around that at least on modern hardware
23:40:57 <dons> which we got. http://hackage.haskell.org/package/vector
23:41:07 <dons> and dph, of course, for data parallel arrays
23:41:28 <Axman6> Ke: get with the times man
23:41:41 * Axman6 should have added dph and vector to his list of awesomeness
23:41:51 <Ke> =o)
23:42:10 <dons> so, good threads and scheduler, fast io and networking, fusible arrays, and a good code gen.
23:42:17 <dons> trends are good.
23:42:25 <dons> just need more things using them
23:43:12 <Ke> or a nice package to use opencl with proper abstraction ;o)
23:43:38 <dons> yeah, a higher level version of http://hackage.haskell.org/package/OpenCLRaw
23:43:49 <dons> i.e. this http://hackage.haskell.org/package/accelerate
23:43:55 <dons> but that doesn't run on opencl yet
23:45:12 <Axman6> and probably won't for a while :(
23:45:51 <dons> needs someone keen to get it working now, without other duties.
23:46:24 * Axman6 would do it if he had time
23:47:38 <Axman6> i wish the cuda code was open, then i would have something to go off
23:48:15 <Ke> opencl =oP
23:48:49 <znutar> Which cuda code is closed?
23:49:02 <Zao> Any intent to do similiar things with kqueue on BSDs and (I guess) IOCP or similiar on Windows?
23:49:12 <Zao> Targetting just Linux with epoll seems a bit slim.
23:52:59 <sinelaw> i think conal is implementing a compiler for functional languages to GPU
23:53:03 <dons> yes, the event  lib supports all those.
23:53:31 <conal> sinelaw: yep
23:54:06 <sinelaw> we can't wait :)
23:54:18 <conal> sinelaw: based on continuous space and using my auto-diff package (vector-space) for per-pixel exact normals
23:54:45 <sinelaw> ooh
23:56:22 <sinelaw> conal, do you think it makes sense for an arrowized FRP model to allow the arrow units to perform i/o? e.g. a >>> b >>> c - b may do IO stuff inside but from a user perpective it's still a "function"?
23:56:23 <bos> actually, we don't support IOCP.
23:56:40 <bos> IOCP has a completely different programming model from the usual unix convention, alas.
