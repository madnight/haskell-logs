00:00:11 <ksf> well I guess it's going to be data Entry = File ... | Directory FS and type FS = Map String Entry
00:00:22 <cads> systemfault, what do you suggest?
00:00:26 <systemfault> cads: You're on project euler :)
00:00:37 <cads> systemfault, heh, yup
00:01:02 <systemfault> cads: Well, write a collatz function with an accumulator then map it over a list from 800000 to 999999
00:01:30 <systemfault> I got it to be nearly as fast as my C version :P
00:01:43 <systemfault> .102 vs .074
00:02:16 <cads> Hmm, that reduces the work by a lot
00:02:17 <superoptimizer> systemfault: seconds?
00:02:23 <systemfault> superoptimizer: Yeah
00:02:36 <superoptimizer> systemfault: now write a version in CUDA :)
00:02:39 <systemfault> superoptimizer: You need a 64 bit ghc though..
00:02:57 <systemfault> superoptimizer: If not, it has to use Integer which is slower
00:03:13 <cads> systemfault, you compiled it to run in parallel on your GPU?
00:03:19 <systemfault> cads: Nah
00:03:27 <systemfault> cads: Just a normal implementation
00:03:45 <cads> oh, I confused your post with the tail end of superoptimizer's
00:03:50 <superoptimizer> cads: that's just me talking :)
00:04:04 <cads> what's the state of ghc compilation for cuda?
00:04:25 <superoptimizer> cads: I'm in the GPU world, so any time I see people making comparisons against time I wonder how fast it would run with ComputeShader/OpenCL/CUDA
00:04:34 <ksf> wait in 9p, directories _are_ files.
00:04:39 <ksf> just another type.
00:05:00 <ksf> you open and read them just like any other.
00:05:47 <cads> superoptimizer, I've got a toe in the graphics world, so I was pretty happy when I picked up a book on modern graphics hardware and saw they were doing oclussion shading and normal mapping and displacement all in the gpu
00:06:58 <systemfault> Too bad I had to use bit tricks in my collatz test to make it fast.
00:07:39 <cads> I've been considering euler problems to be unsolved unless I can execute them in ghci in under a minute :)
00:07:57 <kmc> but ghci is so slow!
00:08:01 <kmc> and it doesn't even detect infinite loops!
00:08:12 <systemfault> I don't use ghci :P
00:11:20 <cads> kmc, I like slow, gives me time to eat a snack
00:11:42 <cads> except all my code runs in under 30 seconds :)
00:11:50 <newsham> ksf: union mounts can give you something like a symlink
00:13:15 <Zao> cads: Even a halting problem solver?
00:13:58 <cads> Zao, THEY HAVE THOSE??!?!?!!!!1
00:14:33 <cads> So much for quot erat demonstrandum, eh?
00:15:31 <Zao> Oh, it was restricted to the set of euler problems.
00:16:59 <cads> Zao, no, I just pass my ghci the -XhyperTuring flag and it's uses some fold fusion technique that SPJ negotiated with god in return for him having to work for microsoft another 7 years
00:17:28 <Zao> Fair trade.
00:19:03 <acidjnk> hello
00:22:14 <superoptimizer> so haskell lets me redefine the basic operators? hmmm, "neat?"
00:22:46 <newsham> > let (+) = (*) in 5 + 9
00:22:47 <lambdabot>   45
00:23:15 <superoptimizer> i did something similar in ghci, but with / for +
00:23:55 <ksf> arrrgh I sent my whole treatease to /dev/net/null
00:24:04 <newsham> ksf: union mounts can give you something like a symlink
00:24:23 <kmc> superoptimizer, sure, they're ordinary user-defined operators
00:24:31 <kmc> which happen to live in the Prelude
00:24:43 <kmc> you can also get GHC to give you a Haskell environment with no prelude
00:25:03 <ksf> I'm reinforced by my belief that typed files are a Good Idea.
00:25:08 <ksf> in my belief.
00:25:18 <cads> > let (+) = \ a b -> "poop" in 5 + 9
00:25:19 <lambdabot>   "poop"
00:25:23 <ksf> no my belief has been reinforced.
00:25:26 <kmc> > let 2 + 2 = 5 in 2 + 2
00:25:27 <lambdabot>   5
00:25:59 <newsham> ksf: what are you doing with 9p?
00:26:20 <ksf> I guess I'm going to end up with defining 9P2010.h, with size fields replaced by ebml-like vints and the upper byte of the mode with TypeRep
00:26:55 <newsham> .h ?
00:27:01 <ksf> .haskell
00:27:19 <newsham> why do you want a specific protocol for haskell?  impl language shouldnt matter, no?
00:27:40 <Athas> Can you recommend a good LaTeX package for including Haskell source code?
00:27:55 <ksf> oh well it does if you want to use 9P as interprocess communication as well as external interface.
00:28:20 <kmc> Athas, have you used lhs2TeX?
00:28:36 <newsham> 9p is already used as interprocess communication and external interface :)
00:28:48 <kmc> it has various fancy modes that can typeset Haskell to look more like "real math"
00:29:23 <ksf> but I don't want to castrate the IPC to exchange bit arrays and stat fields.
00:29:26 <kmc> and you can write a single file that represents both the LaTeX document and the executable program
00:30:21 <newsham> kmc: heh, reminds me of http://esr.ibiblio.org/?p=1796#comment-250787
00:30:25 <newsham> the stuff about guitar hero :)
00:30:54 <newsham> ksf: oh, you mean like something to send via Chans?
00:31:11 <ksf> also, I'm going to short-circuit replies a bit. a process forwards a request to a mount, and the mount replies directly to the original queree
00:31:12 <ksf> yep.
00:31:17 <Athas`> kmc: I don't think it does a very good job, and beside, the code will be in an appendix in my case, not the centrepiece of the document.
00:31:37 <newsham> ksf: just because 9p messages are serializable doesnt mean you need to send them around in that serial format internally
00:31:57 <ksf> sure
00:32:02 <kmc> ah
00:32:22 <ksf> ...but at some point two haskell programs might want to talk to each other, and they should have access to the type information.
00:32:46 <cebewee> Athas`: You could try the listings package
00:32:56 <newsham> ksf: btw, there's some simple serialization stuff for 9p online: http://code.google.com/p/9ph/source/browse/
00:32:59 <newsham> in haskell
00:33:02 <ksf> otoh, I'm procrastinating by prematurely designing.
00:33:21 <Athas`> I suppose... I just don't think listings produces very nice output.
00:33:30 <ksf> I don't like get parsers
00:33:49 <ksf> ...but I'm ripping the semantics off that one, yes.
00:33:57 <newsham> then that code's prob not for you (unless you just want to use the structured msg defns)
00:34:36 <ksf> the problem is that get doen't work well with iteratees.
00:34:52 <newsham> is that inherent or just due to the Get impl?
00:35:11 <newsham> because you can replace the Binary impl and still use the Get interface and reuse all the code
00:35:33 <ksf> I didn't really investigate thta
00:35:53 <systemfault> cads: If you want to see my "fast" collatz http://www.ideone.com/4eFTBAOD
00:35:54 <ksf> the protocol is too trivial, so I just went on ahead and reimplemented it.
00:36:10 <newsham> like for example, the normal Get classes do big endian, but i just rewrote my own class for little endian
00:36:17 <ksf> ...oh, and I want to have more defined types, too.
00:36:27 <systemfault> Hmm, if anyone can take a look at http://www.ideone.com/4eFTBAOD and tell me if there's a way to achieve the strictness without defining a new type
00:36:39 <ksf> I've got (65535,Version {mSize = 8192, version = NinePVersion 2000 ""})
00:36:44 <newsham> ksf: "more" is easy.. its the minimalism thats hard :)
00:37:46 <crash[`]> Hey guys. Working on a CodeChef problem which is defined as follows: the first line of input defines the size (n) of your input. You'll then accept n lines of input, one integer per line, The output should then print out, one number per line, the sorted data set. I did that with code as seen here: http://haskell.pastebin.com/seLZmGHK . but CodeChef says this is too slow. How can I both write this better, and make it faster?
00:38:52 <ksf> newsham, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24353#a24353
00:39:28 <kmc> crash[`],  you know about "lines" and "getContents"?
00:39:39 <crash[`]> kmc: yessir
00:39:43 <kmc> :t lines <$> getContents
00:39:44 <lambdabot> IO [String]
00:39:52 <kmc> :t sum . map (read :: String -> Int) . lines <$> getContents
00:39:53 <lambdabot> IO Int
00:40:08 <kmc> :t sort . map (read :: String -> Int) . lines <$> getContents
00:40:09 <lambdabot> IO [Int]
00:40:14 <crash[`]> where is <$> defined?
00:40:16 <kmc> i don't know if this will be faster, though
00:40:17 <systemfault> kmc: Do you know if there a way to use a normal pair in my code instead of an ugly extra datatype?
00:40:20 <kmc> crash[`], Control.Applicative
00:40:29 <kmc> crash[`], it's the same as liftM, for monads
00:40:34 <jrockway> also known as, fmap
00:40:38 <crash[`]> mkay
00:40:39 <kmc> yeah
00:40:41 <newsham> ksf: cool, will have to let this soak in a little :)
00:41:11 <kmc> systemfault, how about a bang-pattern on your function arguments?
00:41:23 <kmc> collats n !acc = ...
00:41:27 <systemfault> Ah
00:41:28 <newsham> where are P and EnumeratorGM from?
00:41:34 <systemfault> kmc: Didn't know that
00:41:52 <ksf> P is from http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24320
00:42:07 <ksf> ...and EnumeratorGM is in Data.Iteratee
00:42:20 <kmc> systemfault, it may be faster too
00:42:27 <newsham> i've not used iteratee yet..  saw some of olegs stuff but havent fully absorbed it all yet
00:42:36 <kmc> your CollatzPair type is itself lazy, represented with heap-allocated thunks
00:42:52 <crash[`]> kmc: thanks very much
00:42:55 <kmc> whereas the bang-pattern will not only avoid that but may expose additional strictness to the GHC strictness analyzer
00:43:00 <kmc> crash[`], :)
00:43:28 <kmc> systemfault, which may result in it unboxing the Int entirely
00:43:28 <systemfault> kmc: Cool
00:43:40 <kmc> or you can do it yourself, by using Int#
00:44:01 <systemfault> kmc: Should I ass -XBandPatterns or -fglasgow-exts?
00:44:05 <systemfault> Damn!
00:44:06 <kmc> the former
00:44:06 <systemfault> Add!
00:44:11 <systemfault> Bang
00:44:13 <kmc> -fglasgow-exts is more or less deprecated
00:44:16 <ksf> I haven't fully grokked them myself, yet. In theroy, I should be able to do that [Word8] -> [String] -> Version parser nesting without going via [String], and have the nested parser work in lockstep with the one who does the UTF8 decoding.
00:44:19 <systemfault> :( I should go to sleep..
00:44:24 <kmc> put this line at the top of your file:  {-# LANGUAGE BangPatterns #-}
00:44:49 <crash[`]> kmc: How do I stop receiving input with getContents? EOF doesn't seem to be doing it
00:44:56 <kmc> crash[`], it should do it
00:45:09 <ksf> crash[`], you get the end of the list.
00:45:13 <kmc> you may have to hit enter after ^D (this is on UNIX)
00:45:32 <Zao> kmc: Isn't it ^D alone on a line?
00:45:38 <kmc> systemfault, if you were to keep the datatype, you might want to turn on -funbox-strict-fields
00:45:40 <crash[`]> using OSX, can't make it happen
00:45:43 <kmc> or use an UNPACK pragma: http://www.haskell.org/ghc/docs/latest/html/users_guide/pragmas.html#unpack-pragma
00:45:59 <systemfault> kmc: You're right, it's a bit faster
00:46:21 <kmc> systemfault, probably spends less time in GC
00:46:27 <kmc> you can check by running with ./myProg +RTS -s
00:49:05 <systemfault> And -fvia-C generates code that is a lot worse.
00:49:10 <systemfault> (Now)
00:50:43 <kmc> have you tried the new hotness LLVM codegen?
00:51:09 <systemfault> kmc: Yeah :)
00:51:26 <systemfault> It was doing about the same as gcc for my old code.
00:51:33 <systemfault> Hmm, time for a retry
00:52:07 <systemfault> :( I want a 64bit ghc for mac :(
00:52:35 <newsham> hmm.. there's 64bit ghc for bsds and linux.  none for mac yet?
00:53:00 <systemfault> I have the newest 6.12.1 and it's still 32bit
00:53:20 <crash[`]> so kmc, say I wanted to only accept n lines of input with what you gave me above. Would I just use take before lines?
00:53:26 <crash[`]> er, applied take to the output of lines?
00:54:03 <ksf> that'd be ignoring the rest of the lines
00:54:15 <ksf> which might or might not be what you want to do
00:54:22 <crash[`]> yeah, so my problem is that I need to accept n lines of input only
00:54:54 <newsham> > take 3 $ lines $ cycle "test\n"
00:54:55 <lambdabot>   ["test","test","test"]
00:54:58 <ksf> you can use drop and test whether the tail is empty
00:55:07 <ksf> (or splitAt, which is take and drop)
00:55:17 <crash[`]> well sure, but my issue is with the IO function
00:55:23 <newsham> > splitAt 3 $ lines $ cycle "test\n"
00:55:24 <lambdabot>   (["test","test","test"],["test","test","test","test","test","test","test","...
00:56:02 <ksf> > second null . splitAt 3 $ lines $ cycle "test\n"
00:56:03 <lambdabot>   (["test","test","test"],False)
00:56:10 <ksf> > second null . splitAt 3 $ lines $ replicate 2 "test\n"
00:56:11 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
00:56:11 <lambdabot>         against inferred type...
00:56:18 <ksf> > second null . splitAt 3 $ lines $ repeat 2 "test\n"
00:56:19 <lambdabot>   Couldn't match expected type `[GHC.Types.Char] -> GHC.Base.String'
00:56:19 <lambdabot>         ...
00:56:21 <cads> systemfault, your solution is pretty nice
00:56:24 <ksf> uh
00:56:36 <cads> systemfault, so far mine is slow and _wrong_
00:56:50 <systemfault> :(
00:56:51 <ksf> > second null . splitAt 3 $  repeat 2 "test"
00:56:52 <lambdabot>   Couldn't match expected type `[GHC.Types.Char] -> [a]'
00:56:52 <lambdabot>         against infe...
00:57:00 <ksf> > second null . splitAt 3 $  replicate 2 "test"
00:57:01 <lambdabot>   (["test","test"],True)
00:57:05 <ksf> > second null . splitAt 3 $  replicate 3 "test"
00:57:06 <kmc> do { (n:xs) <- lines <$> getContents; print . foo . take n $ xs }
00:57:07 <lambdabot>   (["test","test","test"],True)
00:57:08 <crash[`]> ksf: my the solution I had was here: http://haskell.pastebin.com/seLZmGHK
00:57:09 <ksf> > second null . splitAt 3 $  replicate 4 "test"
00:57:10 <lambdabot>   (["test","test","test"],False)
00:57:23 <kmc> err with appropriate read and whatever
00:57:39 <ksf> that's imperative!
00:58:38 <kmc> :O
00:59:30 <crash[`]> kmc: I assume I'd still have to insert a read for the n?
00:59:57 <ksf> you can take the head of your lines <$> getContents
00:59:57 <kmc> yeah
01:00:02 <kmc> bah head
01:00:23 <kmc> perhaps:  do { (n:xs) <- map read . lines <$> getContents; print . foo . take n $ xs }
01:00:28 <ksf> (n:xs) <- lines <$> getContents
01:00:31 <kmc> shouldn't need a sig on "read" as "take" will fix its type
01:00:53 <crash[`]> kmc: that's amazing lol
01:01:02 <kmc> crash[`], the type inference?
01:01:16 <ksf> or, rather, interact ((\(n:xs) -> ...) . lines)
01:01:18 <crash[`]> no, your solution's improvements
01:01:22 <kmc> oh
01:02:21 <cads> systemfault, ah, the range to search is 800k to 900k. Still think I'll have to rewrite it in your style to get the same kind of speed
01:02:36 <cads> somehow my solution runs the same speed in ghci as it does compiled :X
01:02:36 <kmc> crash[`], is it faster too?
01:02:43 <kmc> cads, with -O3?
01:02:55 <crash[`]> kmc: can't tell yet, but I'll let you know when i do
01:02:55 <crash[`]> :0
01:03:14 <cads> kmc, lets see
01:03:19 <systemfault> cads: For my last try, I'm trying with bit twiddling on 64bit :)
01:06:19 <systemfault> Hmm haha
01:06:33 <systemfault> My overhead seems to be the starting of the application..
01:07:00 <systemfault> If it has any (I don't know)
01:08:21 <crash[`]> kmc: CodeChef still says it takes too long when I include 'read'ing each value in the list into Int
01:09:33 <kmc> what's their limit, and how big is the input?
01:09:52 <crash[`]> dunno about the actual time limit, but the input can be up to 10^6 elements i think
01:10:03 <kmc> eh that's not much
01:10:07 <crash[`]> oh, 5s
01:10:45 <crash[`]> i mean I know i still have to sort the whole thing, so maybe inserting into a structure which will sort on insert (search tree, etc) would be better
01:10:55 <crash[`]> but it doesnt seem like this should take that long
01:11:05 <kmc> i am guessing you are building a list of "read" thunks
01:11:11 <kmc> which takes a lot of time for allocation etc.
01:11:26 <kmc> change your last line to:   nval `seq` accum (n-1) (nval : list)
01:11:50 <crash[`]> oh, in mine? I was trying it with your last piece of code and still having the issue
01:11:54 <crash[`]> but i will try that
01:11:58 <kmc> oh okay
01:12:40 <crash[`]> I'm trying that suggestion, though
01:12:46 <crash[`]> but same thing - over 5s
01:13:06 <systemfault> kmc: The only problem with llvm.. what are the flags I am supposed to pass :(
01:14:39 <cads> with or without the -O3 it's 24 seconds.. but I'm starting to think my code is pretty inefficient
01:14:54 <systemfault> cads: real    0m0.103s ;)
01:15:15 <cads> that's using the same brute forcing code?
01:15:41 <systemfault> Yeah, with added bit twiddling.
01:15:44 <cads> the reason mine is so slow is because I try to optimize things by memoizing the collatz length function
01:16:00 <cads> well, and I use integers
01:16:28 <cads> I wonder how much zippier it'll be just by switching to ints
01:16:28 <kmc> crash[`], on my system your code spends 40% of its time in garbage collection
01:16:31 <systemfault> cads: I booted the linux machine so I could use 64bit integers
01:16:39 <crash[`]> kmc: how does yours compare?
01:16:43 <kmc> haven't tested it
01:16:50 <systemfault> cads: Because it overflows a 32bit int
01:16:53 <crash[`]> you'll have to add the reads i'm sure
01:16:58 <crash[`]> but i'm just curious
01:17:10 <crash[`]> btw kmc, thanks a lot - this is a great learning experience both with IO and.. not having slow programs :P
01:17:20 <kmc> :)
01:17:39 <systemfault> kmc: Thanks :)
01:18:05 <kmc> crash[`], adding seq on nval seems to not help much :/
01:18:06 <systemfault> I wonder if using vector would make it even faster ..
01:18:23 <kmc> crash[`], did you try profiling your code?
01:18:31 <crash[`]> kmc: what are you using to profile? also, no :P
01:18:39 <kmc> i'm just using ./foo +RTS -s
01:19:47 <kmc> crash[`], my version is only a little faster, might be noise
01:20:03 <crash[`]> k
01:20:21 <crash[`]> kmc: so any ideas how to significantly improve that? it's a problem that i can only really reason about doing imperatively
01:20:38 <kmc> well, i suggest profiling to be sure
01:20:45 <kmc> where the time is really spent
01:20:54 <kmc> it might come down to Data.List.sort being slow
01:20:58 <crash[`]> gothc
01:20:59 <crash[`]> gotcha
01:22:47 <kmc> replacing sort with (S.toList . S.fromList) seems to help significantly
01:22:51 <kmc> where S is an import of Data.Set
01:23:05 <crash[`]> gotcha
01:23:05 <kmc> oh but that'll clobber the occurrence count of each number :/
01:23:11 <crash[`]> hm
01:23:18 <kmc> you can use Data.Map to handle that but it will be more complicated
01:23:20 <crash[`]> I know there's a heapsort implementation
01:30:10 <systemfault> kmc: My fastest code.. 64bit only though http://www.ideone.com/sqwnWxWN
01:30:22 <systemfault> Oww;
01:36:08 <cads> woah, that looks like c and haskell made sweet sweet love
01:36:28 <systemfault> Yeah :(
01:36:38 <systemfault> Haskell doesn't have real unsigned...
01:37:03 <cads> oh man
01:37:16 <systemfault> Ah...
01:37:20 <systemfault> Yes it does
01:37:23 <systemfault> Data.Word
01:37:44 <systemfault> It just made it even faster..
01:38:12 <systemfault> That was educational :)
01:38:17 <systemfault> Fast haskell == Possible
01:39:14 <cads> slow haskell is also possible http://www.ideone.com/S7qLEMj6
01:39:40 <systemfault> I have to play with memoization soon
01:39:53 <cads> seems like you're doing just fine without it
01:40:13 <systemfault> Brute force doesn't always work
01:40:14 <cads> I think the memoization approach could be made a lot better with a bit twiddling approach
01:40:43 <cads> this is kind of a generic combinator that just slaps memoization onto whatever function you apply it to
01:40:51 <systemfault> I'm sure that a simple fib would be a million times faster with memoization than brute force
01:41:55 <cads> yeah, that turns an exponential algorithm into a linear one I believe
01:42:38 <crash[`]> kmc: any final ideas on how to write this to be less ineffecient (other than going to a mutable data structre)?
01:52:38 <systemfault> kmc: 0.102 is my final result, the LLVM backend being the fastest.
01:53:57 <cads> systemfault, gawd, I got down to 2.5 seconds by dropping the memoization and switching to a tail recursion
01:54:10 <systemfault> Haha
01:54:13 <cads> too fast for my blood!
01:54:26 <cads> lets see how it runs in ghci
01:54:33 <systemfault> Tell me :P
01:54:41 <systemfault> 15 seconds is my guess
01:55:27 <cads> hmm, lemme redo that.
01:55:45 <cads> 4 seconds :P
01:55:51 <systemfault> Owww
01:56:16 <cads> it must be loading the compiled code or something
02:01:17 <Mowah> what does the $ do here? http://github.com/tensorpudding/euler/blob/master/001/euler1.hs
02:01:41 <Mowah> I've tried searching for it but I can't find anything..
02:01:56 <cads> in general, it makes dat money, makes dat MONEY!
02:01:59 <Twey> Function application
02:02:07 <systemfault> Without that, sum would take the word filter at its argument
02:02:11 <cads> Mowah, it takes a function on the left side and applies it to the value on the right
02:02:46 <systemfault> Hmm
02:03:05 <cads> f ($) x = f (x), so it could have also been written sum(filter (\x -> and [x `mod` 5 == 0, x `mod` 3 == 0]) [1..999])
02:03:31 <Mowah> ah okay now I get it
02:03:34 <cads> hmm, that's wrong, the first part should be f $ x or  ($) f x
02:03:35 <Mowah> thx
02:03:43 <systemfault> > [a | a <- [1..999], a `mod` 3 == 0 || a `mod` 5 == 0]
02:03:44 <lambdabot>   [3,5,6,9,10,12,15,18,20,21,24,25,27,30,33,35,36,39,40,42,45,48,50,51,54,55,...
02:03:54 <systemfault> > sum [a | a <- [1..999], a `mod` 3 == 0 || a `mod` 5 == 0]
02:03:55 <lambdabot>   233168
02:04:08 <systemfault> I <3 that
02:04:24 <Twey> You mean &&
02:05:02 <systemfault> I don't think so :/
02:05:10 <Twey> The original says ‘and’
02:05:13 <superoptimizer> @src map
02:05:13 <lambdabot> map _ []     = []
02:05:13 <lambdabot> map f (x:xs) = f x : map f xs
02:05:24 <Twey> Not ‘or’
02:05:55 <systemfault> Twey: But the PE site says that my answer is the good one :(
02:06:08 <Twey> Well, maybe the original is wrong, then ☺
02:06:19 <systemfault> Perhaps lambdabot can help
02:06:27 <systemfault> > sum(filter (\x -> and [x `mod` 5 == 0, x `mod` 3 == 0]) [1..999])
02:06:28 <lambdabot>   33165
02:06:35 <systemfault> Sounds like a fail
02:06:36 <cads> > let f k = k * (div n k) * (1 + div n k) `div` 2 in  f 3 + f 5 - f 15
02:06:37 <lambdabot>   3 * (n `div` 3) * (1 + n `div` 3) `div` 2 + 5 * (n `div` 5) * (1 + n `div` ...
02:06:48 <cads> huh
02:07:04 <cads> > let f k = k * (div 1000 k) * (1 + div 1000 k) `div` 2 in  f 3 + f 5 - f 15
02:07:05 <lambdabot>   234168
02:07:34 <systemfault> > sum [a | a <- [1..999], a `mod` 3 == 0 || a `mod` 5 == 0]   -- Cuter
02:07:35 <lambdabot>   233168
02:08:10 <cads> hmm, why's mine off..
02:08:47 <systemfault> Haskell is evil... already 5am :(
02:08:51 <systemfault> Shit.
02:09:29 <cads> dang I must be missing a floor somewhere
02:09:40 <Twey> > sum $ filter (on (||) (== 0) `liftM2` (`mod` 5) $ (`mod` 3)) [1 .. 999]
02:09:41 <lambdabot>   233168
02:09:52 <systemfault> Twey: Win
02:10:07 <systemfault> Twey: Being a beginner, it looks like obfuscated haskell to me :'*(
02:10:08 <Twey> Wish I could get rid of the duplication of ‘mod’
02:10:24 <Twey> I guess the LC is probably nicer ☺
02:10:45 <cads> that's pretty obfuscated :)
02:11:30 <Twey> Not really
02:11:32 <systemfault> > numb $ [5, 10..999] ++ [3, 6..999]
02:11:33 <Twey> It just ends up longer
02:11:34 <lambdabot>   Not in scope: `numb'
02:11:38 <systemfault> > nub $ [5, 10..999] ++ [3, 6..999]
02:11:39 <lambdabot>   [5,10,15,20,25,30,35,40,45,50,55,60,65,70,75,80,85,90,95,100,105,110,115,12...
02:11:44 <systemfault> > sum . nub $ [5, 10..999] ++ [3, 6..999]
02:11:45 <lambdabot>   233168
02:11:49 <systemfault> haha
02:12:09 <systemfault> A set would probably be faster than nub though..
02:12:43 <Twey> Why?
02:12:48 <Phyx->  hrm, what do you guys think is the prefered way of marshalling lists? as i somehow need to specify also the length of the generated array. I was thinking about two possiblities, either wrap lists in a custom data structure, which contains a list and a length field, but the polymorphic variable will result in a void* which requires casting before using. Or leave the arrays in tact and add an extra length field per array in the functions and/or struc
02:13:00 <Twey> I'd imagine nub probably uses a set somewhere…
02:13:03 <systemfault> > sum . Set.fromList $ [5, 10..999] ++ [3, 6..999]
02:13:04 <lambdabot>   Not in scope: `Set.fromList'
02:13:43 <systemfault> Any way to make lambdabot use Set?
02:13:48 <systemfault> > sum . Data.Set.fromList $ [5, 10..999] ++ [3, 6..999]
02:13:49 <lambdabot>   Not in scope: `Data.Set.fromList'
02:13:56 <Twey> Guess not
02:14:00 <systemfault> > sum . S.fromList $ [5, 10..999] ++ [3, 6..999]
02:14:00 <lambdabot>   Couldn't match expected type `[a]'
02:14:01 <lambdabot>         against inferred type `Data.Set....
02:14:05 <systemfault> Win!
02:14:16 <Twey> Aha
02:14:32 <Phyx-> @src nub
02:14:32 <lambdabot> nub = nubBy (==)
02:14:38 <Phyx-> @src nubBy
02:14:38 <lambdabot> nubBy eq []             =  []
02:14:38 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
02:14:43 <Twey> > sum . S.toList . S.fromList $ [5, 10 .. 999] ++ [3, 6 .. 999]
02:14:44 <lambdabot>   233168
02:14:53 <systemfault> Hoot
02:15:03 <Phyx-> anyway, anyone wanna weigh in on which one if the better approach?
02:15:14 <Twey> > let nub = S.toList . S.fromList in sum . nub $ [5, 10 .. 999] ++ [3, 6 .. 999]
02:15:15 <lambdabot>   233168
02:15:17 <Twey> ;)
02:15:33 <systemfault> HaX0r!
02:15:40 <Twey> Phyx-: void* is a fact of life in C
02:15:56 <Twey> Phyx-: I'd just bite the bullet and do it
02:16:16 <systemfault> I think the fastest would be using the set
02:16:21 <systemfault> mod is slow..
02:16:35 <systemfault> I don't know..
02:16:35 <cads> > let n = 999; f k = k * (div n k) * (1 + div n k) `div` 2 in  f 3 + f 5 - f 15
02:16:36 <lambdabot>   233168
02:16:47 <systemfault> Ah.. yeah
02:16:49 <Phyx-> Twey: I wanted to avoid void types as much as possible, since It would require the user to know which type to cast to. and without the original haskell source, you'd never know
02:16:56 <systemfault> cads's the winnar!
02:17:45 <cads> inclusion/exclusion principle and linearity in the summation operator for the win.
02:18:01 <systemfault> > let n = 999; f k = k * omg * (1 + omg) `div` 2 in  f 3 + f 5 - f 15 where omg = div n k
02:18:02 <lambdabot>   <no location info>: parse error on input `where'
02:18:14 <systemfault> Noob...
02:18:17 <Phyx-> guess there's no helping it :(
02:20:22 <cads> Hmm, using runhaskell all the first fifteen euler problems execute in less than a couple minutes now :)
02:20:37 <systemfault> Good :)
02:20:44 <cads> systemfault, thanks for sharing your code
02:20:51 <systemfault> You're welcome
02:20:56 <cads> the collatz thing was killing me till I "saw the light"
02:20:57 <systemfault> I learned a lot too tonight
02:27:43 <systemfault> Time to sleep
02:27:48 <systemfault> <3 Haskell
02:29:20 <arcatan> often when solving problems with Haskell, I kinda know how to solve them in imperative language, but have enormous problems writing the solutions in Haskell
02:29:53 <ivanm> you're still thinking wrong then
02:30:04 <arcatan> yes, i know
02:30:05 <cads> :P
02:30:19 <systemfault> The only FP I did before Haskell was C++ Template Metaprogramming :(
02:30:47 <osfameron> FP seems to be less amenable to brute-force solutions :-(
02:30:54 <Alpounet> noooo, you pronounced "C++" here!
02:30:56 <cads> Think about it more like you haven't completely learned the best phrases and idioms of the language
02:30:58 <systemfault> AHhh!!
02:31:06 <systemfault> An Alpounet!
02:31:17 <Alpounet> heh
02:31:30 * hackagebot hawitter 0.4 - A twitter client for GTK+. Beta version.  http://hackage.haskell.org/package/hawitter-0.4 (DaikiHanda)
02:32:04 <cads> Like try talking philosophy or art criticism or whatever brainy topic in a language that you've only studied a couple years
02:32:28 <cads> and even if you're pretty smart you'll be very frustrated and unable to get your points across easily
02:32:54 <arcatan> reasoning about Haskell performance isn't trivial for me
02:33:02 <kmc> it's not trivial for anyone
02:33:31 <systemfault> Well, seems fast enough for me.
02:33:34 <kmc> it is very difficult and this is perhaps one of the biggest substantive (as opposed to marketing or perception-based) obstacles to widespread adoption
02:35:09 <cads> (when I'm trying to understand space/time of basic algorithms I think in djikstra/knuth pseudocode)
02:35:39 <cads> I fail to be able to reason precisely about haskell stuff so far
02:36:12 <kmc> this is a weakness of strongly declarative languages in general
02:36:41 <cads> lots of times it makes specifying an answer such a joy that I don't care that it takes minutes rather than seconds to execute
02:37:22 <kmc> get it working quickly, then make it fast by improving the critical parts
02:38:04 <kmc> as opposed to "do it the hard way initially, have nothing at all for months" or "get it working quickly, throw that out, start over and do it the hard way"
02:38:30 <kmc> but we still have a big gap in actually identifying and improving those critical parts
02:38:53 <cads> it would be cool to specify an algorithm using a high level language and then refine the sticking points in such a way that high level invariants are still preserved
02:39:00 <kmc> yes!
02:39:26 <systemfault> Anyway, I'm happy, just 0.025s of difference between my haskell and C versions :P
02:39:36 <pozic> Has anyone heard of a certified algorithm?
02:39:55 <kmc> pozic, you mean an algorithm with a formal proof of correctness?
02:40:01 <kmc> that's what i'd assume it means without more context
02:40:11 <cads> have that iterative refinement process be your program rather than just your final refinement
02:40:40 <cads> systemfault, that is sick!
02:40:49 <cads> systemfault, can I see the final code?
02:40:56 <kmc> cads, you sometimes do that in formal proof contexts... prove your algorithm's correctness with respect to a conceptually simple but grossly inefficient datastructure, prove that the more efficient structure is equivalent, then run with that
02:41:06 * ksf wonders how to implement 9P's flush over channels
02:41:13 <systemfault> cads: It even works on 32bit since i switched to unsigned :P 2sec
02:41:40 <ksf> the idea, at first was to completely nuke transaction ids, but there has to be some way of cancelling a request.
02:41:46 <pozic> kmc: context is "several other certified algorithms have been proposed to do X (where X has nothing to do with type-theory or programming languages)".
02:41:47 <ksf> *request ids
02:41:48 <kmc> like the best finite-map structure for formal reasoning is just a function... but in most implementations this will give O(n) lookup and terrible space behavior, so you then prove that your balanced binary tree or whatever is equivalent to a chain of pointwise function overrides
02:42:17 <pmaes_> are there any books you would recommend to a self-taught programmer who wants to understand more about the theory behind algorithms? Things like big O notation and stuff. (excuse the vagueness)
02:42:36 <systemfault> cads: http://www.ideone.com/gLKjmy2N
02:42:50 <pozic> pmaes_: Introduction to algorithms is a good start.
02:42:54 <cads> systemfault, yeah, I did a log on the largest number produced in the longest collatz sequence and it just pushes 31.5 bits
02:43:02 <ksf> and TMVar as back channel wrapped so that it can nuke itself?
02:43:14 <kmc> pmaes_, CLRS
02:43:21 <cads> systemfault, but that's no quarantee that it wouldn't still overflow elsewhere :/
02:43:21 <pozic> pmaes_: also, there is only a point in reading that stuff if you actually care.
02:43:24 <kmc> that's Introduction to Algorithms
02:43:30 <kmc> by Cormen, Leiserson, Rivest, Stein
02:43:34 <kmc> that is *the* algorithms bible
02:43:46 <systemfault> cads: sadly, the c generator is still a bit faster with that code
02:43:46 <ksf> so that before handling a request, a server can check whether the back channel still accepts data.
02:43:50 <arcatan> I nth the CLRS book
02:43:55 <pmaes_> kmc, pozic: thanks, I'll be sure to check it out
02:44:13 <pozic> You are like CLR and I am like CLRS.
02:44:30 <pozic> Or something like that ;) (It's from nerd rap song)
02:44:33 <kmc> it's sort of a cookbook, for good and for bad
02:44:35 <systemfault> cads: The options I use  ghc -O2 -fforce-recomp -fvia-C -optc-O3 -funbox-strict-fields --make myhaskellfile
02:44:35 <pozic> from a*
02:44:46 <kmc> if you want something really high level and conceptually unified, i don't know where to look
02:44:56 <kmc> that might be more the realm of complexity theory rather than practical algorithms
02:45:23 <arcatan> CLRS is nice mix between pragmatic and theoretical
02:46:04 <arw> and its a good starting point. most theory books are not really readable, until you have some of the knowledge you get from books like CLRS.
02:46:22 <pozic> kmc: hmm, it is hard to see whether certified means certified by a formal proof or an informal proof.
02:46:24 <eevar2> pmaes_: you might also want Purely Functional Data Structures by Chris Okasaki, once you're done covering the basics
02:46:32 <kmc> pozic, or a government agency ;P
02:46:34 * hackagebot th-lift 0.3 - Derive Template Haskell's Lift class for datatypes.  http://hackage.haskell.org/package/th-lift-0.3 (MathieuBoespflug)
02:46:35 <kmc> they certify stuff too
02:47:03 <kmc> one direction to after CLRS would be reading about approximation algorithms for NP-complete and similarly hard problems
02:47:14 <kmc> there is tons of literature on that although i don't know which is the canonical textbook
02:47:26 <pozic> kmc: nah, not in this case ;)
02:47:40 <kmc> oh also definitely get _Quantum Computation and Quantum Information_ by Nielsen and Chuang
02:47:47 <arcatan> oh, I second Purely Functional Data Structures, too. It's a fun little book.
02:47:56 <kmc> for a glimpse into the far future
02:48:52 <arcatan> Quantum Computation and Quantum Information needs a bit more mathematics, though
02:49:23 <arcatan> I tried to read it when I was a freshman, but didn't get much out of it
02:49:52 <kmc> yeah, that's some serious linear algebra
02:50:27 <kmc> it mostly *is* just linear algebra, but at a level beyond what most freshman would have seen
02:50:46 <pozic> It seems there is little point in studying semantics that don't actually exist on an existing machine on large scale.
02:50:57 <pmaes> What kind of mathematics background would I need to have for CLRS? I'm currently at high-school level I think, but I wouldn't mind working on that.
02:51:15 <pozic> pmaes: that should be ok.
02:51:25 <pozic> CLRS is really an introduction.
02:52:00 <cads> http://www.ideone.com/TikKBHhS Hmm, this same code is blowing the stack on my computer - it tells me to do +RTS -Ksize  (my current size is 8M).. is this a compile time option?
02:52:03 <kmc> pmaes, you should be fine as long as you're reasonably intelligent and willing to look things up / ask around if you don't understand them
02:52:07 <Botje> cads: yes
02:52:09 <kmc> cads, it's a runtime option
02:52:15 <pozic> It would be more interesting to try to actually build a quantum computer at this point.
02:52:19 <kmc> ./myProg +RTS -K500M
02:52:20 <Botje> uh, oops :P
02:52:23 <arcatan> kmc: yeah, now as a sophmore leafing through the book it looks a lot more accessible
02:52:41 <pozic> Otherwise there is the possibility that quantum programmers are programming against a fantasy.
02:52:48 <kmc> pozic, they have built small ones
02:52:57 <eevar2> cads: you _can_ compile runtime defaults into your program
02:52:58 <pozic> kmc: 10 qbits, whoohoo.
02:53:08 <kmc> it's a lot better than 0 ;P
02:53:12 <kmc> actually i hadn't heard about 10
02:53:26 <Botje> cads: you need to be careful with creating lists like testRange
02:53:30 <kmc> QM itself is very, very well empirically verified
02:53:37 <Botje> cads: but your issue here is that acc is not evaluated until the end
02:53:56 <pozic> kmc: there are also theories that it doesn't scale.
02:54:04 <Botje> cads: so either you enable BangPatterns in your language and put count a !acc
02:54:24 <pozic> kmc: but I basically know nothing about the subject, so don't listen to me.
02:54:26 <Botje> cads: or you wing it with count a acc | acc `seq` False = undefined; | a ==1 = ...
02:54:30 <kmc> and all you need for QC is to make a system that behaves like qubit and can interact certain ways; doesn't really matter how you do it.  which makes building a large-scale quantum computer sound like a very tricky but ultimately tractable engnieering problem
02:54:33 <cads> Oh yeah.. bangpatterns were brought up earlier tonight
02:54:47 <systemfault> cads: Look at the acc in my code :P
02:54:59 <kmc> pozic, that QM itself doesn't scale, somehow? or that you can't scale a practical quantum computer?
02:55:10 <systemfault> Like in real life, seems that too much laziness kills...
02:55:43 <pozic> kmc: that somehow when n goes to let's say useful values of n=100000 that for some reason it is impossible to build a quantum computer.
02:55:58 <cads> It's wierd that it compiled earlier without any special attention
02:56:10 <systemfault> cads: Did you use optimizations?
02:56:15 <Botje> the compiler can do certain optimizations, and strictness analysis is one of them
02:56:27 <kmc> pozic, i'd be interested to read/hear more details on these arguments if you have them
02:56:53 <cads> systemfault, Botje, you are correct
02:57:22 <cads> systemfault, heh, for a newbie you know a lot about haskell compiling
02:57:45 <systemfault> I'll eventually become better, I love haskell :)
02:58:08 <cads> what are a couple of the best resources you used to learn about ghc?
02:59:04 <kmc> GHC manual
02:59:20 <systemfault> Yep :P
02:59:24 <kmc> every new release i read it cover to cover like a child opening presents on christmas day
02:59:47 <kmc> uh, there's a document somewhere named "Secrets of the GHC Inliner"
03:00:00 <kmc> was fun to read and enlightening though i can't say it's helped me write better code
03:00:18 <systemfault> It's nice to see that LLVM is pwning gcc on my small code :D
03:00:37 <kmc> LLVM on the same C code?
03:00:40 <cads> I was particularly impressed that you were compiling to llvm
03:00:52 <systemfault> kmc: On the haskell code
03:01:01 <kmc> oh
03:01:09 <kmc> just for fun, you should get clang and compile your C code through LLVM
03:01:32 <systemfault> Ok, 2 seconds :P
03:01:35 <systemfault> Already have it
03:01:58 <kmc> there's llvm-gcc too but i hear it's inferior
03:03:21 <systemfault> Hmm.. I guess I shoud download the SVN version, it's way slower than gcc 4.2
03:04:41 <cads> Hmm, when you do ghc --make foo.hs and later run gch -O3 --make foo.hs, it seems like it doesn't recompile with optimizations
03:05:28 <systemfault> I hate you all <3 it's 6am here.. Time to go to sleep for real :D
03:05:41 <idnar> cads: -fforce-recomp?
03:05:53 <cads> sysfalt go ro bwd!
03:06:02 <cads> go to bed*
03:06:13 <systemfault> Zzz bye! :)
03:06:20 <systemfault> And thanks again kmc
03:06:25 <kmc> nite
03:08:37 <pozic> Is there a library to do mesh generation from a surface for Haskell?
03:09:12 <pozic> E.g. something implementing: http://geometrica.saclay.inria.fr/team/Steve.Oudot/papers/bo-pgsms-05/bo-pgsms-05.pdf
03:09:19 <quicksilver> there is something in fieldtrip, pozic
03:11:21 <cads> goonight all
03:14:01 <th1_>  I'm reading the Real World Haskell chapter 3 online.. and the Maybe type is confusing me. What does "Just" mean and how is e.g. a "Just Bool" different from a "Bool"?
03:14:24 <pozic> th1_: A Just Bool does not exist.
03:14:44 <dobblego> th1, I often explain Maybe as a list that has a maximum length of 1
03:14:59 <dobblego> Nothing means "empty list" while Just means "a list with one element"
03:15:06 <pozic> th1_: The Maybe type constructor takes a type, e.g. Bool and constructs an actual type, e.g. Maybe Bool.
03:15:24 <th1_> ok thanks.. that makes sense dobblego
03:15:24 <pozic> th1_: Maybe Bool can be constructed in two ways.
03:15:29 <pozic> th1_: actually, three.
03:15:38 <pozic> th1_: either undefined::Maybe Bool
03:15:56 <pozic> th1_: Just (True/False/undefined)
03:15:59 <dobblego> Just True, Just False, Nothing
03:16:04 <th1_> ok
03:16:10 <pozic> th1_: or Nothing::Maybe Bool
03:16:17 <pozic> th1_: that's all the is to it.
03:16:20 <th1_> how can I extract the bool to use in an expression?
03:16:22 <pozic> there*
03:16:31 <pozic> th1_: I suggest you read yor book.
03:16:33 <ksf> can someone explain how Data.Dynamic.fromDynamic works?
03:16:35 <pozic> th1_: your*
03:16:38 <dobblego> th1_, there might not be a Bool to extract after all the list might be empty
03:16:43 <kmc> ksf, you mean behind the scenes?
03:16:50 <pozic> th1_: and if it really is not in the book, complain to the authors ;)
03:17:04 <ksf> it's clear that fromDyn works, but I'm puzzled by the fact that it's comparing to the typeOf of a result of unsafeCoerce
03:17:08 <pozic> The probability of that is 0, though.
03:17:09 <Entroacceptor> Maybe is the way to implement the famous BOOLEAN type 'Yes' 'No', 'File Not Found'
03:17:14 <th1_> I'm sure it will be in a later chapter :) but I was just a bit confused about it
03:17:33 <dobblego> th1_, you might map across each element in the list, using fmap
03:17:34 <kmc> ksf, because it wants its expected return type to constrain unsafeCoerce
03:17:47 <kmc> it is odd, i remember being confused by this when i saw it first
03:18:01 <kmc> it's critical that you don't actually use "r" on the "Nothing" branch
03:18:06 <pozic> Is there any documentation for fieldtrip? Fieldtrip is in a broken state.
03:18:06 <ksf> but...but... == is value-level.
03:18:16 <th1_> ok I'll read on :)
03:18:21 <th1_> thanks dobblego and pozic
03:18:28 <kmc> ksf, typeOf is guaranteed not to inspect its argument
03:18:36 <kmc> it's a dummy argument purely to constrain the typeclass
03:18:42 <kmc> here is a less portable but clearer way to write it:
03:19:41 <ksf> how can typeOf fix the type to anything more concrete than Typeable a => a?
03:19:52 <kmc> because the return type of this function is constrained
03:20:03 <kmc> in one case arm you return "Just r"
03:20:13 <kmc> and so r :: a, the same a as in the Maybe a return type
03:20:20 <kmc> so typeOf r = typeOf (undefined :: a)
03:20:22 <ksf> ahhhhh
03:21:04 <kmc> ksf, it's to avoid needing GHC's ScopedTypeVariables extension
03:21:12 <kmc> or rather, that extension gives a cleaner way to write things like this
03:21:44 <kmc> to whit http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24357#a24357
03:23:22 <mux> I have some code that I don't think I could have possibly written without ScopedTypeVariables
03:23:35 <kmc> that's plausible
03:23:36 <ksf> and I guess it's utterly impossible to fromDynamic to a typeclass constraint?
03:23:58 <kmc> ksf, values in Dynamic always have monomorphic type, if that's what you're asking
03:24:04 <kmc> it's a limitation of Typeable
03:24:16 <kmc> (all typeclass instances are monomorphic)
03:24:22 <ksf> yes. but one might be a Float and the other an Integer, with both are Num
03:24:49 <mwc> Sigh, I hate how every other day on proggit, there's some massive hash table shootout. Are hash tables just the default data structure for the for-loop monkeys or what?
03:25:46 <Jafet> It's like H/CI, you can't do it wrong
03:26:07 <ksf> mwc, no, they aren't.
03:26:11 <stevenmarky> what's a for-loop monkey?
03:26:21 <ksf> but people keep associating associative maps with hash tables.
03:26:23 <mux> mwc: yes, trees are hard
03:26:24 <kmc> mwc, they are
03:26:30 <kmc> because O(1) is OMG SO FAST
03:26:33 <Jafet> Presumably someone who isn't a while-loop monkey.
03:26:34 <ksf> trees are way easier than hash tables
03:26:44 <mux> that was highly ironical btw.
03:26:46 <pozic> The people who use hash tables probably don't know what they are.
03:26:47 <kmc> never mind that log n < 64 and often < 12 or so
03:26:50 <mwc> but the probing! the probing!
03:27:09 <ksf> it's more the cache misses that should worry tree-users
03:27:12 * Jafet probes mwc
03:27:12 * theorbtwo shrugs.
03:27:21 <kmc> indeed, trees are nice, binary trees are pretty bad
03:27:24 <pozic> Anyway, the best solution would be to just use all solution in parallel ;)
03:27:26 <mwc> Jafet: linearly or what?
03:27:28 <ksf> you can spot knowledgeable forloop-monkeys by them mentioning it.
03:27:28 <pozic> solutions*
03:27:31 <kmc> gotta get that 256-ary judy tree
03:27:39 <theorbtwo> An associative map and a hash table have the same API to the user, which is what matters most of the time.
03:27:45 <mux> the judy lib is pretty impressive indeed
03:28:02 <ksf> hash tables are bound to have a monadic interface.
03:28:03 <kmc> except that a hash requires a hash function and a tree requires comparison
03:28:05 <Jafet> mwc, your big O.
03:28:13 <kmc> and that getting the hash function right is tricky
03:28:23 <kmc> usually your inputs are not uniformly distributed
03:28:30 <mux> patricia tries rock, red-black trees too, an dI really like AVLs, splay trees, B+ trees, etc
03:28:38 <theorbtwo> kmc: Optimization, and often premature optimization.
03:28:39 <ksf> ...not to mention sanely handling collisions.
03:28:42 <mux> I want to specialize in arboriculture software engineering
03:28:44 <kmc> wikipedia: list of trees
03:28:48 <mwc> it's expecially fun if your hashing function has an attackable worst case scenario
03:29:06 <stevenmarky> perfect hashes win, game over tree-monkeys
03:29:07 <theorbtwo> Most of this is best pushed down to the library layer.
03:29:07 <ksf> in general, non-perfect hash tables degrade into n-ary, hashed trees.
03:29:08 <kmc> i think there's a cuckoo hash living in my splay tree
03:29:11 <kmc> got to fumigate
03:29:20 <mux> hahahaha
03:29:25 <kmc> oh i also quite like hash tries
03:29:26 <mux> nice one :-)
03:29:32 <kmc> O(1) persistent data structure
03:29:34 <mwc> stevenmarky: perfect hashing requires foreknowledge of the keys, no?
03:29:47 <mux> yes it does
03:29:58 <theorbtwo> For example, a good hash table library will notice it's using a bad hash function, and twiddle the parameters to make it less bad.
03:29:59 <kmc> all those for loop monkeys would sure like to be able to hold onto a particular version of a hash table locklessly, wouldn't they?
03:30:00 <ksf> perfect hashes might still be slower for low n than a binary search
03:30:06 <theorbtwo> Perl does this transparently.
03:30:10 <mux> or I suppose it would require insane key analysis at insert time
03:30:11 <ksf> depends upon hash cost and the cost of a computed jump.
03:30:35 <kmc> but they can't because functional programming is hard, and threads are hard
03:30:57 <Jafet> There is a "dynamic perfect hashing", but it's mostly of theoretical interest
03:31:07 <Jafet> Like in-place mergesort
03:31:08 <arcatan> surely they don't think fp is hard
03:31:16 <mux> they think recursion is hard
03:31:41 * theorbtwo calls strawmanning.
03:31:42 <kmc> i love the missing lock on a hash table that sits latent in the codebase for years and then gets hit at precisely the money-losingest time possible
03:31:46 <ksf> I'd like to see a cache-oblivious tree in haskell.
03:31:53 <mwc> I read something a while ago where the author asserted that software engineering is not like other engineering, in that the scope of component interaction is unbounded. In a car, the dome light can't mess up the breaks, but in software...
03:32:06 <mwc> I immediately thought, but, but, in purely functional programs...
03:32:21 <ksf> having cache-obliviousness play nicely with sharing seems to be an open research problem.
03:32:22 <Jafet> That's because competent people are hired to design cars
03:32:40 <kmc> mwc, or in any language with safe typing, static or dynamic
03:32:44 <kmc> (for different reasons)
03:32:45 <Jafet> s/-obliviousness/
03:32:55 <mwc> kmc: nah, there's the incomposability of threads, for instance
03:33:00 <theorbtwo> It's not all that uncommon, actually, for poor grounding to cause that sort of difficult-to-dignose problem in cars.
03:33:22 <theorbtwo> ...or for overly optimistic fuses and too much power use, somewhat less often.
03:33:28 <kmc> also yeah isn't toyota recalling a bunch of cars due to electromagnetic interference on the brakes?
03:33:50 <Jafet> I thought it was a software bug
03:33:52 <HugoDaniel> hi
03:33:53 <mwc> Well, yeah, but that's a software issue ;)
03:33:56 <kmc> oh
03:34:00 <kmc> i am misinformed then
03:34:13 <Jafet> A bug in the cruise control system
03:34:27 <mwc> it's something about the breaks feeling spongy due to how the control system balances regenerative breaking with the dissipative system
03:34:40 <Jafet> Hm. I fear HugoDaniel might want to talk about Haskell or something dreadful like that
03:35:04 <mwc> Pah, if he does that, I might have to go back to marking these assignments.
03:35:49 <theorbtwo> For what it's worth, I feel that recurusion isn't that difficult, and is a good way to solve many problems... but that for loops are very often a useful, and more natural, construct.
03:35:50 <kmc> driving is still way more dangerous than anything else most people do routinely
03:35:59 <theorbtwo> I think you'll find a an awful lot of people who agree.
03:36:23 <kmc> i agree
03:36:41 <kmc> no need to put them both in your language, make the for loop an ordinary function in the standard library
03:37:12 <mwc> I think explicit loops are more natural if your conception of the problem includes numerically indexed things
03:37:25 <mwc> if you think about relative relations between the things, then recursion is often more natural
03:37:41 <theorbtwo> mwc: I think you have an incomplete understanding of for loops if you think they are only useful for iterating across integers.
03:37:42 <kmc> it seems mostly successful to replace the old-school init/test/increment loops with iteration over a datastructure, because you can always make a structure that acts like that numerical range
03:37:59 <kmc> that's where language design seems to be going
03:38:12 <kmc> (i.e. where certain people took it 50 years ago and others are noticing now)
03:38:47 <mwc> indeed, loops are really only good for iterating over arrays
03:39:15 <theorbtwo> Right.  A language really needs general for loops, rather then forcing you to use recrusion or integer for loops.
03:39:19 <ksf> I'm translating for loops into recursion, manually.
03:39:22 <ksf> (in my head)
03:39:36 <kmc> theorbtwo, do you mean as a true language feature?
03:39:45 <kmc> or just a standard library function?
03:39:56 <theorbtwo> OTOH, I don't know of any language that forces integer for loops, though C makes them far more idiomatic then other sorts.
03:40:21 <theorbtwo> kmc: Either works, really, but you need a very fluent-seeming interface.
03:40:31 <ksf> there's just no way to understand a loop or recursion without seeing the fixpoint.
03:40:46 <pozic> I don't really understand the hype about FieldTrip. It seems to be something that could have become something interesting, but only implemented the low-hanging fruit and its releases were all WIPs.
03:41:00 <ksf> ...well at least if there's non-trivial variable interaction going on.
03:41:18 <kmc> theorbtwo, what's your idea of a general for loop?
03:41:20 <ksf> I think conal more or less abandoned it
03:41:45 <pozic> ksf: yes, but I had the impression they were further in the development.
03:41:55 <ksf> ...switching attention to more cuda stuff that can make a better fieldtrip
03:42:04 <dobblego> @type Data.Traversable.for
03:42:05 <lambdabot> forall (t :: * -> *) a (f :: * -> *) b. (Data.Traversable.Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
03:42:21 <ksf> he's keeping silent about anything post-reactive/fieldtrip
03:42:23 <pozic> ksf: is conal working on anything right now?
03:42:25 <theorbtwo> kmc: I think perl does a reasonable job of it -- for my $element (@array) {print "$element\n"}
03:42:37 <theorbtwo> Note that @array can be any expression returning a list.
03:42:42 <ksf> pozic, he claims to.
03:43:01 <ksf> but there's been no blog posts or code releases in some time.
03:43:08 <pozic> ksf: I am not holding my breath.
03:43:09 <theorbtwo> I would prefer something slightly more general, which allows @array to be anything iteratable, but it's reasonably good.
03:43:12 <kmc> theorbtwo, okay.  so you do mean iteration over a structure
03:43:13 <kmc> yeah
03:43:16 <kmc> like python's "for"
03:43:23 <theorbtwo> kmc: Yes, I do.
03:43:29 <kmc> i don't see a strong case against that being an ordinary function
03:43:35 <kmc> and several strong points in favor
03:43:48 <pozic> What are you talking about? There is the Traverable class in Haskell.
03:43:59 <pozic> Traversable
03:44:00 <theorbtwo> Or haskell's ... one of the variants of map.  mapf, IIRC.
03:44:05 <kmc> we're talking about language design, not Haskell
03:44:07 <kmc> mapf?
03:44:10 <kmc> :t mapf
03:44:11 <lambdabot> Not in scope: `mapf'
03:44:15 <kmc> :t flip map -- like this?
03:44:16 <lambdabot> forall a b. [a] -> (a -> b) -> [b]
03:44:29 <kmc> the classical imperative for loop is closest to "flip mapM_"
03:44:35 <dobblego> theorbtwo, have you read The Essence of the Iterator Pattern?
03:44:43 <dobblego> @type forM_
03:44:44 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
03:44:50 <kmc> yes that one :)
03:45:48 <theorbtwo> @hoogle (Monad m) => m a -> (m a -> m b) -> m b
03:45:48 <lambdabot> Data.Generics.Aliases ext1T :: (Data d, Typeable1 t) => (e -> e) -> (t f -> t f) -> d -> d
03:45:54 <theorbtwo> Hm, no, that's not it.
03:46:00 <theorbtwo> Not important.
03:46:03 <dobblego> @type flip ($) ::  m a -> (m a -> m b) -> m b
03:46:04 <lambdabot> forall (m :: * -> *) a b. m a -> (m a -> m b) -> m b
03:46:51 <theorbtwo> Point is that it has a difficult-to-remember name... as evidenced, partly, by the fact that I can't remember it.  (Poor evidence; my memory is pretty bad.)
03:46:58 <theorbtwo> :t map
03:46:59 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
03:47:02 <dobblego> you might be thinking of foldMapDefault or fmapDefault
03:47:30 <theorbtwo> @hoogle Monad m => (a -> b) -> m a -> m b
03:47:30 <lambdabot> Control.Monad liftM :: Monad m => (a1 -> r) -> m a1 -> m r
03:47:31 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
03:47:31 <lambdabot> Data.Traversable fmapDefault :: Traversable t => (a -> b) -> t a -> t b
03:47:58 <theorbtwo> Hm.  I guess I do mean fmapDefault.
03:48:39 <kmc> :t fmapDefault
03:48:40 <lambdabot> Not in scope: `fmapDefault'
03:48:48 <kmc> ah there it is
03:49:08 <theorbtwo> fmapDefault array \(x -> print x)
03:49:30 <theorbtwo> The perl interface feels far more fluent, but that might be my fluency showing.
03:49:48 <ksf> \x -> print x == print x
03:50:07 <dobblego> ksf, I don't think so :)
03:50:14 <ksf> me neither.
03:50:22 <ksf> that's what you get by using ghc.
03:50:24 <theorbtwo> You mean just print, but that doesn't work out well for a nontrivial body.
03:50:55 <dobblego> I don't think you mean fmapDefault
03:51:00 <ksf> at the cashier, I'm constantly saying "I'm a programmer, I don't need to be able to do mental arithmetic"
03:51:04 <dobblego> (which is just fmap or liftM in this discussion)
03:51:09 <dobblego> you mean more like forM)
03:51:12 <dobblego> forM_
03:51:30 <ksf> oh, I was referring to the x
03:51:53 <ksf> you can do sequence_ . fmap print
03:52:29 <theorbtwo> Yes, you can get rid of the lambda and the name for the argument if your loop body is trivial.
03:53:05 <kmc> er, if it can be written reasonably in points-free style
03:53:07 <dobblego> you can write very non-trivial and useful point-free expressions
03:53:13 <kmc> which includes a lot of non-trivial things
03:53:54 <theorbtwo> True, but it is likely to introduce more syntax then you lost by introducing it, and be much less readable then simply introdcing the lambda.
03:54:12 <dobblego> no
03:54:15 <kmc> that's possible, yes
03:54:24 <kmc> it's also possible for the points-free version to be far more readable
03:54:28 <dobblego> it's possible, but not necessarily likely
03:54:33 <kmc> it really depends on the case and on having a certain fluency reading pointsfree code
03:54:34 <ksf> lambdas are usually evil
03:54:46 <ksf> rather use a quick where-clause. less syntactic clutter.
03:56:56 <kmc> this can depend on somewhat subtle things, like whether the libraries you're using have put their arguments in the right order for what you want to do
03:57:46 <theorbtwo> (To be fair, I'm cheating somewhat, by showing the perl syntax which requires an array, and looking for haskell syntax that will allow an arbitrary monad instead of the [] monad.)
03:57:56 * hackagebot hsemail 1.6 - Internet Message Parsers  http://hackage.haskell.org/package/hsemail-1.6 (PeterSimons)
03:58:01 <kmc> er, monads aren't iterable, in general
04:03:13 <sioraiocht> @src sum
04:03:13 <lambdabot> sum = foldl (+) 0
04:03:16 <sioraiocht> ack
04:03:19 <sioraiocht> not foldl'?
04:03:37 <kmc> it is odd
04:03:45 <kmc> but @src's database may bear no relation to what's actually in the library
04:04:12 <theorbtwo> Folds are one of those very odd places in Haskell, where recommended pratice is made harder then the obvious method, for no clear reason.
04:04:40 <pastorn> @hoogle uncurry3
04:04:41 <lambdabot> No results found
04:04:50 <theorbtwo> However, @src isn't neccessarly how any compiler implements it, it's how the code in the specification defines it -- which is designed for readablity, not efficency.
04:04:54 <kmc> Data.List implements sum with direct recursion and an accumulator
04:05:07 <kmc> theorbtwo, what's the obvious method and how are folds harder?
04:05:26 <theorbtwo> kmc: I mean that foldl isn't recommended, foldl' is.
04:05:36 <pastorn> i like the ghc ifdef definition of splitAt
04:06:00 <kmc> theorbtwo, there's a reason for that
04:06:00 <pastorn> lot of weird uses of some unsafe* function
04:06:16 <theorbtwo> kmc: What is it?
04:06:32 <kmc> theorbtwo, foldl' is strict in the accumulator
04:06:48 <theorbtwo> kmc: Right.  But why name the one that you should use with a tick?
04:06:53 <pastorn> http://haskell.org/ghc/docs/latest/html/libraries/base-4.2.0.0/src/GHC-List.html#splitAt
04:07:00 <theorbtwo> Why not name the one you *shouldn't* use with a tick?
04:07:07 <pastorn> #else /* hack away */
04:07:24 <kmc> theorbtwo, so that foldl and foldr will be symmetric
04:07:43 <kmc> the strictness can be considered premature optimization and complicates the semantics in the case of bottom values
04:07:55 <kmc> the tick indicates that you're deviating from the simplest thing
04:08:11 <theorbtwo> kmc: If it's premature optimization, then why recommend the strict version as a rule of thumb?
04:08:20 <kmc> theorbtwo, *shrug*
04:08:29 <kmc> because it's no harder to use in practice?
04:08:51 <kmc> i think symmetry / simplicity is a strong enough argument for which one should get the tick
04:09:22 <theorbtwo> If it makes people go "ew" everytime they see it, then no, it isn't.
04:09:28 <kmc> does it?
04:10:13 <theorbtwo> I'm sorry, it made sioraiocht go "ack", not "ew".
04:10:42 <sioraiocht> theorbtwo: thank you, I do hate being misquoted =p
04:11:00 <kmc> i thought that was a response to "the library is doing it wrong" rather than "i have a strong opinion on which one should get a little tic after the name"
04:11:37 <kmc> i doubt many people feel strongly about this issue
04:11:59 <kmc> even though this *is* the Internet
04:12:34 <theorbtwo> kmc: I doubt many experinced haskell programmers do, because with experince, your priorties move, and it becomes difficult to focus on some types of problems.
04:13:00 <Twey> I despise your ticking ways!  The sight of that tick on that strict function deeply offends me!
04:14:05 <theorbtwo> I wouldn't go so far as to say it deeply offends me.
04:14:12 <ivanm> yay for having to think up new datatype and constructor names that don't clash with what I already have! :s
04:14:32 <theorbtwo> I think it is indicitive of poor language design, though.
04:15:32 <ivanm> theorbtwo: my guess is that the one you should normally use is primed is because it was defined _afterwards_
04:15:42 <Twey> ivanm: Needs more modules ☺
04:15:48 <ivanm> and they can't change them around because foldl is part of the report and foldl' isn't
04:16:01 <theorbtwo> ivanm: Aha, I thought both were in the report.
04:16:06 <zygoloid> i like that the tick means 'this is the unusual one'
04:16:08 <kmc> it's poor language design only depending on your priorities
04:16:13 <kmc> inconsistency is also poor design
04:16:16 <ivanm> Twey: no, the problem is that I have a new HtmlLabel type (which is actually newtyped with a constructor of HtmlLabel; imaginative, eh?)
04:16:38 <dobblego> theorbtwo, Haskell's design has no objective of appeasing beginners; this has worked wonderfully to its benefit
04:16:40 <ivanm> and I want to use it in my overall algebraic label type which has StrLabel, RecordLabel, etc.
04:16:43 <Alpounet> ivanm, hey, you were working on a dot parser right ?
04:16:46 <ivanm> so what do I call HTML-like labels? :s
04:16:50 <ivanm> Alpounet: yup
04:17:13 <ivanm> html labels are done! (I think; have to define Arbitrary instances so I can run them through the testsuite though)
04:17:25 <theorbtwo> ivanm: That is a much better reason, if still an unfortunate one.
04:17:29 <Twey> dobblego: The continuing presence of map and (++) suggests otherwise ;)
04:17:34 <ivanm> *shrug8
04:17:49 <ivanm> theorbtwo: I forget why, but there are still a couple of instances when it's better to use foldl
04:17:58 <ivanm> dobblego: :o
04:18:02 <dobblego> Twey, shall I say, the extent to which it does achieve this objective, is to its benefit?
04:18:03 <Twey> When you've got bottoms in your list ☺
04:18:08 <ivanm> Haskell was designed in part to be a _teaching_ langauge
04:18:21 <Twey> dobblego: Hehe, fair enough
04:18:25 <ivanm> (which is why I hate Caleskell, etc. for making things overly complicated)
04:18:30 <Alpounet> ivanm, will it be separate somehow of your SourceGraph thing ?
04:18:36 <ivanm> Twey: that's the one
04:18:42 <ivanm> Alpounet: it never was part of SourceGraph ;-)
04:18:46 <ivanm> SourceGraph just _uses_ it
04:18:47 <Alpounet> oh
04:18:47 <Alpounet> great
04:18:47 <dobblego> Scala makes the mistake of appeasing beginners all the time, then those same beginners "get it" and wish they hadn't influenced
04:18:50 <ivanm> @hackage graphviz
04:18:50 <lambdabot> http://hackage.haskell.org/package/graphviz
04:18:51 <ivanm> Alpounet: ^^
04:18:53 <Alpounet> thanks
04:18:58 <ivanm> dobblego: heh
04:19:01 <ivanm> dobblego: example?
04:19:08 <Alpounet> nice version numbers
04:19:15 <kmc> the one with the tic is the one with the extra rule that isn't symmetric with foldr
04:19:22 <dobblego> ivanm, hmm, I wish I didn't say that now :) I'm feeling lazy (and stoned)
04:19:25 <kmc> and it is pretty special
04:19:51 * ivanm hopes dobblego is stoned from his prescription meds and not anything else...
04:20:10 <kmc> would that be a california prescription by any chance
04:20:12 <ivanm> Alpounet: *shrug* I inherited it off matthew-_ who belongs in the "dates make for great version numbers!" camp
04:20:15 <dobblego> yes, oxycodone, though it was not prescribed for that which I am using it
04:20:22 <ivanm> so I had to start with high numbers to make them sensible
04:20:28 <theorbtwo> kmc: Yes, you've made that point.  I understand your point.
04:20:36 <kmc> if you had not seen the (quite special) seq function you might assume that a function cannot force a value of totally parametric type
04:21:01 <Alpounet> ivanm, heh ok
04:21:05 <ivanm> it backfired slightly, however: I still have quite a while to go before I can incorporate generic graph classes into it (I have to _define_ these generic graph classes first! :p) and I"ve already said version 3000 will be the one with them :s
04:21:45 <ivanm> soon after passing graphviz on to me, matthew-_ came out and said he was working on a you-beaut great new graphviz parser...
04:21:55 <ivanm> it hasn't appeared yet though, and that's almost a year ago now *shrug*
04:22:06 <theorbtwo> kmc: On the other hand, it clashes with the use of foo' to mean "this is a less important derivitive of foo", or "this is an inner function used in implementing foo".
04:22:39 * ivanm uses primed version of functions in graphviz to denote "here is a variant of foo with some automatic detection feature"
04:22:59 <Jonno_FTW> is there a release date for the next Haskell Platform?
04:23:19 <ivanm> Jonno_FTW: what, the latest one isn't good enough for you?
04:23:23 <ivanm> it just came out a few days ago!
04:23:24 <Jonno_FTW> no
04:23:26 <ivanm> :o
04:23:28 <ivanm> how come?
04:23:36 <Jonno_FTW> does it include GHC 6.12?
04:23:38 <ivanm> I don't think dons et. al. have even started to think about it!
04:23:40 <ivanm> Jonno_FTW: yes
04:23:44 <Jonno_FTW> :O
04:23:47 <ivanm> make that "yes!"
04:23:48 <ivanm> ;-)
04:23:56 <ivanm> @where platform
04:23:56 <lambdabot> http://hackage.haskell.org/platform/
04:24:02 <ivanm> Jonno_FTW: it even has a spiffy new web page!
04:24:07 <Jonno_FTW> i noticed
04:24:14 <Jonno_FTW> but the windows version isn't updated
04:24:17 <ivanm> Jonno_FTW: there is no new windows installer yet though
04:24:18 <ivanm> yeah
04:24:25 <Jonno_FTW> this is the predicament
04:24:28 <ivanm> there's a beta version linked to on the haskell reddit though
04:24:31 <ivanm> it might suffice
04:24:46 <Jonno_FTW> i get numerous dependency errors currently when trying to install things
04:24:58 <Jonno_FTW> with cabal
04:26:01 <ivanm> Jonno_FTW: you mean cabal-install?
04:26:05 <Jonno_FTW> yeah
04:26:05 <ivanm> cabal /= cabal-install!
04:26:09 <ivanm> what kind of errors?
04:26:20 <ivanm> there are very few packages with 6.12-only releases
04:26:28 <Jonno_FTW> using: cabal install yi
04:26:32 <ivanm> (and gtk2hs doesn't even have a 6.12-compatible release yet!)
04:26:40 <ivanm> Jonno_FTW: see my post to the mailing list on how to resolve that
04:26:46 <Jonno_FTW> cabal: dependencies conflict: ghc-6.10.4 requires filepath ==1.1.0.2 however filepath-1.1.0.2 was excluded because ghc-6.10.4 requires filepath ==1.1.0.3
04:27:00 <ivanm> Jonno_FTW: that is your fault
04:27:06 <ivanm> you installed multiple versions of filepath
04:27:10 <ivanm> which is a no-no
04:27:14 <Jonno_FTW> darn
04:27:19 <Jonno_FTW> do i need a complete redo?
04:27:21 <ivanm> ghc-pkg list filepath
04:27:43 <ivanm> Jonno_FTW: "ghc-pkg unregister filepath-<version>" (not sure which version comes with 6.10.4)
04:27:56 <ivanm> and then do "ghc-pkg check" and rebuild everything that is broken
04:28:18 <ivanm> 1.1.0.2 is the 6.10.4 version
04:28:21 <o^_^o> @hoogle zapp
04:28:21 <lambdabot> No results found
04:28:26 <ivanm> so uninstall 1.1.0.3
04:28:54 <o^_^o> where is zapp ?
04:28:55 <ivanm> Jonno_FTW: for yi, though: install syb-with-class-0.6, unpack latest version of yi, edit it to let you use TH-2.3.0.0 and then build the edited version
04:29:02 <dobblego> o^_^o, you might want (<*>)  for ZipList
04:29:05 <ivanm> o^_^o: never heard of such a function
04:29:23 <ivanm> preflex: seen sinelaw
04:29:23 <preflex>  sinelaw was last seen on #haskell 16 hours, 27 minutes and 43 seconds ago, saying: howdy, pardners!
04:29:24 <Jonno_FTW> can i just uninstall what I have and install the new version?
04:29:32 <o^_^o> hmm...the applicative functor paper has it
04:29:38 <ivanm> Jonno_FTW: cabal-install doens't let you uninstall
04:29:43 <ivanm> you have to do it by hand ;-)
04:29:48 <ivanm> oh, do you mean the platform?
04:29:54 <Jonno_FTW> yes
04:29:54 <dobblego> @type (<*>) -- o^_^o
04:29:55 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
04:29:58 <o^_^o> zapp :: [a ! b ] ! [a ] ! [b ]
04:30:09 <Jonno_FTW> i can just cabal install everything i need after getting the new version
04:30:10 <ivanm> Jonno_FTW: http://www.reddit.com/r/haskell/comments/bhl5d/beta_windows_installer_for_haskell_platform/
04:30:14 <o^_^o> zapp :: [a -> b ] -> [a ] -> [b ]
04:30:27 <o^_^o> dobblego, ah
04:30:40 <dobblego> o^_^o, zapp :: ZipList [a -> b] -> ZipList a -> ZipList b
04:30:41 <ivanm> zipWith ($) ?
04:30:58 <dobblego> ivanm, yes
04:31:12 <dobblego> oops
04:31:18 <dobblego> o^_^o, zapp :: ZipList (a -> b) -> ZipList a -> ZipList b
04:31:18 <Jonno_FTW> is this the best way to go?
04:31:43 <o^_^o> ah...ok
04:31:47 <o^_^o> :t ZipList
04:31:48 <lambdabot> forall a. [a] -> ZipList a
04:31:50 <Jonno_FTW> even with 2 serious bugs?
04:32:29 <ivanm> Jonno_FTW: which serious bugs?
04:32:33 <ivanm> and it's up to you ;-)
04:32:48 <ivanm> Jonno_FTW: if you can wait, there's probably be an improved installer this weekend
04:32:57 <Jonno_FTW> 3 days!
04:33:07 <Jonno_FTW> 3 sleeps!
04:33:15 <ivanm> *shrug* not my fault you use an inferior OS and borked your current install! ;-)
04:33:30 <Jonno_FTW> i also use Debian in the off time
04:33:52 <ivanm> "off time"?
04:34:12 <Jonno_FTW> 40% of the time
04:34:27 <Jonno_FTW> it should really be my most used one
04:34:30 <o^_^o> Jonno_FTW, FTW is For The Win ?
04:34:34 <Jonno_FTW> yes
04:34:37 * ivanm -> land of nod
04:34:41 <ivanm> g'night all
04:34:52 <Jonno_FTW> gnight
04:34:59 <Jonno_FTW> (it's not even that late)
04:35:08 <ivanm> @time
04:35:09 <lambdabot> Local time for ivanm is Thu Mar 25 22:34:44
04:35:16 <ivanm> I've been going to bed pretty late the last couple of weeks
04:35:29 <ivanm> almost being caught sleeping by your supervisor is no good :s
04:36:05 <Jonno_FTW> that's pretty bad
04:36:07 <ivanm> yeah
04:36:24 <Jonno_FTW> i nearly fell asleep in a maths lecture the other day
04:36:25 <ivanm> Jonno_FTW: I forget: are you coming to AusHack?
04:36:29 <Jonno_FTW> no
04:36:34 <Jonno_FTW> too far
04:36:43 <ivanm> where are you?
04:36:46 <Jonno_FTW> adelaide
04:36:50 <ivanm> that's not far!
04:36:56 <ivanm> it's only a plane flight away!
04:37:01 <Jonno_FTW> i'm a uni student
04:37:09 <ivanm> so?
04:37:19 <Jonno_FTW> i haven't enough money for the trip
04:37:29 <Jonno_FTW> a bus trip might work
04:37:33 <Jonno_FTW> but not enough planning
04:37:38 <Jonno_FTW> maybe another year
04:37:41 <ivanm> oh, a _poor_ uni student
04:37:54 <ivanm> Jonno_FTW: there's still 3.5 months to plan!
04:38:01 <Jonno_FTW> hmmmmm
04:38:06 <Jonno_FTW> what date will it be?
04:38:28 <ivanm> 16-18 July
04:38:38 <ivanm> http://www.haskell.org/haskellwiki/AusHac2010
04:39:28 <Jonno_FTW> how many people would be there?
04:40:08 <ivanm> atm, about 10 have registered IIRC
04:40:14 <ivanm> you'd have to confirm that with Axman6 though
04:40:36 <Jonno_FTW> i'm not THAT good at haskell
04:40:45 <ivanm> we did have 15 express interest and say they were willing to be come on those dates...
04:40:47 <Jonno_FTW> i'm only a first year software engineering student
04:41:01 <ivanm> Jonno_FTW: I'm sure we can find some make-work for you... >_>
04:41:09 <arcatan> hey, some of us haven't studied software engineering at all!
04:41:27 * ivanm studied science + IT, but taught himself haskell
04:41:36 <Jonno_FTW> i teach myself haskell too
04:41:37 <ivanm> and now I really should hit the sack
04:41:42 <Jonno_FTW> but it's so deep
04:42:00 <Jonno_FTW> but i can still wow the compsci lecturer
04:42:59 <Jonno_FTW> i'll probably look into code generators in my spare time this year
04:57:09 <DLEhelp> Hello
04:57:24 <DLEhelp> CAN ANY BODDY HELP ME WITH DLE SCCRIPT
04:57:36 <opqdonut> nice capslock you have there
04:59:02 <andriusM> Hello, is it possible (or makes sense at all) to combine monad transformers to make a new monad transformer?
04:59:07 <DLEhelp> I HAVE A DOUBT IN DATA LIFE ENGINE SCRIPT CAN ANY ONE HELP
04:59:18 <dobblego> DLEhelp, please turn off your caps locl
04:59:21 <dobblego> *lock
04:59:33 <DLEhelp> K I WILL TURNOFF CAPSLOCK
04:59:35 <opqdonut> andriusM: sure, by composing them
04:59:36 <DLEhelp> k
05:00:01 <dobblego> DLEhelp, this is a Haskell programming language channel
05:00:21 <DLEhelp> I HAVE A DOUBT IN DATA LIFE ENGINE SCRIPT CAN ANY ONE HELP
05:00:25 <kmc> jesus christ
05:00:30 --- mode: ChanServ set +o quicksilver
05:00:34 <dobblego> DLEhelp, please turn off your caps lock
05:00:34 <kmc> DLEhelp, not here
05:00:36 --- mode: quicksilver set +b *!*DLEhelp@117.193.200.*
05:00:36 --- kick: DLEhelp was kicked by quicksilver (YOU ARE BEYOND HELP)
05:00:40 --- mode: quicksilver set -o quicksilver
05:00:42 <kmc> nice
05:00:51 <bremner> muting would be enough...
05:00:54 <quicksilver> bit harsh, perhaps. I'm in a bad mood this morning.
05:01:21 <medfly> aww, #haskell is becoming like a normal language channel
05:01:26 <theorbtwo> quicksilver: Under most circumstances, I'd think so to, but i think that was called for.
05:01:26 <medfly> FUCK OFF MEDFLY! YOU'RE BEING OFF TOPIC!
05:01:53 <theorbtwo> medfly: Off-topic isn't a big issue; not listening is.
05:01:53 <kmc> no we need a bot to say that
05:02:39 * bremner thinks even he could write a bot to say "that"
05:04:18 <HugoDaniel> :(
05:05:10 <Jafet> @vixen what's your political stance on kick bans?
05:05:11 <lambdabot> i don't know, what?
05:05:47 <Daerim> Kick bans, for a troll free environment
05:06:10 * stevenmarky is scared.
05:06:14 <HugoDaniel> :)
05:07:34 <stevenmarky> I do like this freenode webchat client.
05:09:38 <ehamberg> Entroacceptor: did you solve the “Not in scope: data constructor `Message'” problem? i hit that now when i tried to install SMTPClient (dependency of gitit).
05:10:18 <andriusM> ok, then another lame question, can a monad transformer assume that the underlying monad belongs to a certain class and call its methods?
05:11:53 <Entroacceptor> ehamberg: yes
05:11:57 <swiftorific> andriusM: I don't think it quite works like that. You layer monadic transformers on top of each other, creating a new transformer in a sense.
05:12:17 <ehamberg> Entroacceptor: would you like to share? :)
05:12:20 <swiftorific> andriusM: With this new type you can make 'calls' to its respective components.
05:12:51 <Entroacceptor> I had to unregister hsemail-1.5 and install hsemail-1.4
05:13:04 <Entroacceptor> after that I could build smtpclient (and following that, happstack)
05:13:15 <benmachine> you can just hide it
05:13:19 <benmachine> you don't have to unregister it
05:13:22 <benmachine> (I think)
05:13:32 <Entroacceptor> benmachine: well, in fact I pacman'd it away
05:13:36 <benmachine> oic
05:13:45 <Entroacceptor> but I guess hiding should work
05:13:57 <Entroacceptor> or maybe you can adjust SMTPMails cabal file to use 1.4?
05:14:06 <benmachine> you could do that
05:14:31 <benmachine> cabal unpack
05:14:41 <benmachine> gets you the directoy in your current folder
05:14:58 <benmachine> then edit it, probably a good idea to nudge the version number a tiny bit
05:15:09 <benmachine> then cabal install
05:15:44 <Entroacceptor> anyway, smtpclient did build with hsemail-1.4  :)
05:15:53 <swiftorific> andriusM: I recommend http://book.realworldhaskell.org/read/monad-transformers.html if you haven't read it already.
05:15:57 <Entroacceptor> the cabal dependencies are such a mess...
05:16:26 <benmachine> looks like SMTPClient doesn't put an upper bound on... anything
05:16:51 <Entroacceptor> well
05:17:03 <Entroacceptor> that's not really worse than putting wrong upper bounds
05:17:10 <benmachine> well
05:17:15 <benmachine> it's worse than upper bounds too low
05:17:32 <benmachine> because stuff fails at the build phase instead of the configure phase
05:17:49 <benmachine> which is a waste of time and much more difficult to diagnose
05:18:10 <Entroacceptor> having to edit the cabal files of 30 packages is a waste of time, too
05:18:18 <benmachine> yeah but not as much
05:18:35 <benmachine> and if you submit patches then you won't have to do it every time :)
05:18:50 <benmachine> that's the idea, anyway
05:19:18 <benmachine> darcs repository for SMTPClient 404s :(
05:19:25 <Entroacceptor> yes
05:19:30 <Entroacceptor> encountered that, too
05:20:16 * ksf found a very, very dark corner in 9p
05:20:43 <arcatan> 4/sb end
05:20:47 <Entroacceptor> isn't there automatic consitency checking for hackage?
05:21:26 <benmachine> hackage tries to build stuff and mentions on the package page when it fails
05:21:31 <benmachine> but that tends to happen quite a lot
05:21:34 <ehamberg> i actually did need to unregister hsemail-1.5, hiding it did not seem to work. possibly a pebkac, but i can't see how. :)
05:21:36 <benmachine> for various reasons
05:21:39 <ehamberg> any way, thanks, Entroacceptor :)
05:21:39 <ksf> qid.path contains a key unique to each file, but when you export a fs composed of your own files and some other server, it's not clear how to make sure it's still unique.
05:21:55 <benmachine> ehamberg: oh, yeah, I guess hiding wouldn't work, but --constraint probably would
05:22:26 <ksf> one clean design possibility would be to make it variable size, and just append it as file systems are nested
05:22:27 <ehamberg> ah, ok. :)
05:22:46 <ksf> the other one is to give a unique id to each file system, but that seems to be quite impossible.
05:22:49 <Entroacceptor> ehamberg: thank HugoDaniel :)
05:22:58 * ehamberg thanks HugoDaniel :)
05:25:41 <ksf> actually, I don't like the idea of qid.path, at all.
05:26:27 <ksf> there should just be a version number. clients should be capable of deciding whether their cache is dirty by that, alone.
05:27:03 <ksf> and whether or not a file was deleted and recreated or just plain changed shouldn't be of interest, either.
05:27:51 <ksf> I shall try to give all my files a qid.path of 0 and see if stuff blows up.
05:28:38 <ksf> oh, and the version can be replaced by mtime.
05:30:18 <benmachine>     Warning: A do-notation statement discarded a result of type Char.
05:30:19 <benmachine>              Suppress this warning by saying "_ <- char ':'",
05:30:35 <benmachine> yes because I really need to know what char ':' returned
05:30:38 <ksf> they say that qid.path could be used to detect hardlinks, but hardlinks are a _really_ relative term whet you have a deduping fs.
05:33:19 <chessguy> :t newOr a b = if a then a else b
05:33:20 <lambdabot> parse error on input `='
05:33:31 <chessguy> :t \a b -> if a then a else b
05:33:32 <lambdabot> Bool -> Bool -> Bool
05:33:39 <chessguy> :t if
05:33:40 <lambdabot> parse error (possibly incorrect indentation)
05:34:00 <benmachine> if is syntax, not a function
05:34:10 <chessguy> that's what i thought, just making sure :)
05:34:13 <chessguy> :t if'
05:34:14 <lambdabot> Not in scope: `if''
05:34:21 <benmachine> (some people regard this as unfortunate as it is perfectly possible to make such a function)
05:34:55 <chessguy> :t \a b c -> if a then b else c
05:34:55 <Cale> Oh wow. Let i,j,k be the standard basis of R^3. If two associations of v_1 x v_2 x ... x v_n are given (where x is the cross product), then there exists an assignment of i, j or k to each of the v_i's such that both associations evaluate to the same thing and are nonzero.
05:34:56 <lambdabot> forall t. Bool -> t -> t -> t
05:35:01 <benmachine> @check \a b -> if a then a else b == a || b
05:35:02 <lambdabot>   "OK, passed 500 tests."
05:35:19 <Cale> This seems like a simple enough result, but it turns out that it's equivalent to the four-colour theorem. :)
05:35:44 <benmachine> hah
05:35:45 <benmachine> neat
05:36:16 <Jafet> if-then-else will be third up against the wall when the caleskell revolution arrives
05:36:27 <Cale> No, I like if/then/else
05:37:06 <dobblego> why?
05:37:16 <Jafet> Your followers might not
05:37:27 <Cale> What's wrong with it?
05:37:45 <dobblego> it's a language construct and not a normal function
05:37:53 <Cale> I suppose if you want to be minimalist, you can just use case expressions.
05:38:11 <benmachine> the minimalist solution is a function
05:38:22 <benmachine> which can be curried and stuff
05:38:30 <Jafet> @pl \a b c -> if a then b else c
05:38:30 <lambdabot> if'
05:38:35 <benmachine> heh
05:38:39 <Cale> I would think that having zero prelude definitions would be more minimal than defining if at all ;)
05:38:51 <benmachine> true.
05:38:57 <benmachine> but you can choose not to have the prelude
05:39:01 <benmachine> you can't choose not to have if
05:39:06 <dobblego> why is minimal a virtue?
05:39:17 <benmachine> dobblego: it isn't always but it's nice sometimes
05:39:24 <Jafet> Because we have small minds
05:39:47 <Cale> I rather like the way that if/then/else reads.
05:40:06 <benmachine> dobblego: in this case I'd say it was more the currying and so forth that was the real virtue (but the best way of currying if requires a backwards argument order, so there is some merit to not calling it if anyway)
05:40:17 <dobblego> benmachine, so would I
05:40:19 <ksf> I think we should use define-syntax for ifthenelse.
05:40:28 <benmachine> @let fi t f b = if b then t else f
05:40:29 <lambdabot>  Defined.
05:40:31 <benmachine> :t fi
05:40:32 <lambdabot> forall t. t -> t -> Bool -> t
05:40:43 <ksf> that's called ifM
05:40:45 <chessguy> @hoogle if'
05:40:45 <lambdabot> No results found
05:40:47 <ksf> or mIf
05:40:54 <benmachine> why's that
05:41:02 <chessguy> didn't it used to be called if'?
05:41:06 <chessguy> @hoogle ifM
05:41:06 <lambdabot> System.Directory createDirectoryIfMissing :: Bool -> FilePath -> IO ()
05:41:07 <lambdabot> Network.HTTP.Headers HdrIfMatch :: HeaderName
05:41:07 <lambdabot> Network.HTTP.Headers HdrIfModifiedSince :: HeaderName
05:41:14 <chessguy> @hoogle+
05:41:14 <lambdabot> Network.HTTP.Headers insertHeaderIfMissing :: HasHeaders a => HeaderSetter a
05:41:14 <lambdabot> Foreign.C.Error throwErrnoIfMinus1 :: Num a => String -> IO a -> IO a
05:41:14 <lambdabot> Foreign.C.Error throwErrnoIfMinus1_ :: Num a => String -> IO a -> IO ()
05:41:18 <benmachine> chessguy: if' exists in @pl and @pl only, I think
05:41:32 <ksf> because you use it like foo >>= mIf bar baz
05:41:34 <chessguy> weird. i could have sworn it used to be in Data.Functgion
05:41:53 <benmachine> ksf: it's useful in that case sure but there's nothing particularly m about it if you ask me
05:42:11 <benmachine> e.g. fi bar baz <$> boolthing
05:42:23 <ksf> we should just name then pca and cap
05:42:42 <benmachine> what are those
05:42:49 <ksf> predicate, consequent, alternative
05:42:54 <ksf> it's the order of arguments
05:42:59 <ksf> kinda like caadadaaadaddadaddaadar
05:43:27 <yottis> i've even missed such a function a couple of times
05:43:43 <andriusM> Thank you for the answers...
05:43:46 <yottis> to use with higher order functions
05:43:55 <ksf> then there's of course pac and acp for if !p then ...
05:45:04 <yottis> then there of course needs to be a monadic version with a second numeric alternative to get pacman
05:55:22 <Jafet> > let if' a then' b else' c = if a then b else c; if' a else' b then' c = if a then c else b; then' a if' b else' c = if b then a else c; then' a else' b if' c = if c then a else b; else' a if' b then' c = if b then c else a; else' a then' b if' c = if c then b else a; in if' True then' 42 else' 0
05:55:23 <lambdabot>   42
05:56:25 <Jafet> I don't want to know why that works.
05:57:02 <baaba> :t let if' a then' b else' c = if a then b else c; if' a else' b then' c = if a then c else b; then' a if' b else' c = if b then a else c;  then' a else' b if' c = if c then a else b; else' a if' b then' c = if b then c else a; else' a then' b if' c = if c then b else a;
05:57:03 <lambdabot> <no location info>:
05:57:03 <lambdabot>     not an expression: `let if' a then' b else' c = if a then b else c; if' a else' b then' c = if a then c else b; then' a if' b else' c = if b then a else c;  then' a else' b if' c = if c then a
05:57:03 <lambdabot> else b; else' a if' b then' c = if b then c else a; else' a then' b if' c = if c then b else a;'
05:57:06 <baaba> oops
05:57:20 <ksf> http://www.dlugosz.com/ZIP2/VLI.html
05:57:22 <Jonno_FTW> what is then' and else' ?
05:57:30 <baaba> :t let if' a then' b else' c = if a then b else c; if' a else' b then' c = if a then c else b; then' a if' b else' c = if b then a else c;  then' a else' b if' c = if c then a else b; else' a if' b then' c = if b then c else a; else' a then' b if' c = if c then b else a; in (if', then', else')
05:57:31 <lambdabot> forall t t1 t2 t3 t4 t5 t6. (Bool -> t -> t1 -> t2 -> t1 -> t1, Bool -> t3 -> Bool -> t4 -> Bool -> Bool, Bool -> t5 -> Bool -> t6 -> Bool -> Bool)
05:57:39 <baaba> ...wow
05:58:03 <ksf> one problem with these encoding is that once you switch from e.g. 7 data bits to 14 data bits, you get two encodings and thus can't easily compare for equality, any more
05:59:36 <ksf> ...so the range of the 14-bit encoding should better be 128..16510
06:00:33 <ksf> and then 21 data bits 16510..2113661
06:01:57 <Jafet> http://en.wikipedia.org/wiki/Universal_code_%28data_compression%29
06:02:00 <ksf> ...only up to 64 data bits, because bit-fiddling beyond that is insanity.
06:02:26 <benmachine> baaba: some of those definitions are overlapping btw
06:02:36 <opqdonut> yeah, that doesn't _really_ work
06:02:37 <theorbtwo> ksf: This is why strict utf8 specifies that you must always use the shortest encoding.
06:02:50 <opqdonut> it doesn't pattern match against else', it binds else'
06:03:13 <theorbtwo> ...and security holes *have* been found because of that, I'm fairly certian, though I can't recall where.
06:03:19 <ksf> but that sucks for my use case.
06:03:31 <ksf> or does it?
06:03:33 <Jafet> Of course it breaks on all the other five combinations
06:03:49 <opqdonut> yeh
06:03:57 <ksf> nope it doesn't.
06:04:11 <arw> theorbtwo: "pick the shortest" is not the only possible normalization for unicode
06:04:21 <arw> theorbtwo: and iirc not a totally valid one.
06:04:40 <theorbtwo> arw: utf8, not unicode.  I don't mean the level of combining characters; that's a completely differnet problem.
06:05:02 <Jafet> Maybe it could be done with a new type
06:05:03 <ksf> so while parsing, one'd always have to check for a lot of zeroes.
06:05:18 <Zao> So on the level of transformation formats.
06:05:56 <ksf> technically even when you're just passing along stuff
06:06:41 <ksf> I'd rather have a format that can be treated competely opaque.
06:07:34 <theorbtwo> ksf: Well, you are fine passing along things, so long as you trust the source that passed them along.
06:09:46 <ksf> ...that encoding there supports integers up to 2^(8*(2^128))
06:09:49 <ksf> that's insane.
06:11:52 <Jafet> Yeah, what an ugly limit
06:12:14 <Jonno_FTW> > 2^(8*(2^128))
06:12:20 <lambdabot>  Terminated
06:12:21 <Jonno_FTW> :|
06:13:18 <benmachine> 8*2^128 = 2^131
06:13:30 <benmachine> 2^(2^131) == huge
06:13:49 <benmachine> like, 2^(10^40)
06:14:39 <ksf> hmmm... actually, it's even more. the number that signifies the number of data bytes could be itself be represented by a number that signifies the number of data bytes of said length.
06:14:51 <ksf> that is, the whole thing is actually recursive and thus infinite
06:15:01 <ksf> which is strictly bigger than huge.
06:15:06 <benmachine> heh
06:16:07 <Jonno_FTW> but any number can be represented in a finite amount of space
06:16:24 <Jonno_FTW> thus huge is more than a number
06:16:42 <ksf> http://index.ieeexplore.ieee.org/iel5/18/21938/01019854.pdf
06:22:24 <Jonno_FTW> well I'll be darned
06:25:29 <zygoloid> Jonno_FTW: any number can be represented in a finite amount of space?
06:26:03 <Jonno_FTW> should it not be possible?
06:26:07 <zygoloid> i guess you mean, any integer?
06:26:11 <Jonno_FTW> yes
06:26:29 <theorbtwo> It's still impossible.
06:26:44 <Jonno_FTW> i guess for irrationals
06:26:47 <Jonno_FTW> no
06:26:54 <zygoloid> theorbtwo: for each integer there is a finite amount of space which allows representing that integer
06:27:15 <theorbtwo> zygoloid: True, I suppose.
06:27:22 <zygoloid> (with a fixed mapping from contents-of-space to integer, otherwise it's trivially true)
06:28:14 <zygoloid> the original statement was ambiguous wrt the order of the quantifiers, though, and the other way around it's false :)
06:28:29 <theorbtwo> zygoloid: Couldn't have said it better myself.
06:28:32 <theorbtwo> (I know, I was trying.)
06:30:40 <ksf> argh I'm just bikeshedding.
06:31:28 <ZtdCk9PF4NrUuHXh> have a Map from String to a "data" type (GADT?), where the String key is the name of the constructor function for the value -- prone to bugs due to typos in string values -- suggestions?  need to make another "data" type for key values?
06:32:36 <quicksilver> ZtdCk9PF4NrUuHXh: interesting nickname ;)
06:32:49 <quicksilver> ZtdCk9PF4NrUuHXh: yes, you could use another data type for that. Sounds like a strange design though...
06:33:16 <ZtdCk9PF4NrUuHXh> table of configuration information, looked up in program by key where associated value is needed
06:33:33 <ZtdCk9PF4NrUuHXh> keys are strings, typo in string == bug
06:33:57 <ZtdCk9PF4NrUuHXh> hate to make another type for keys, list of constructors for values is very long
06:34:31 <quicksilver> that would be a relatively simple piece of metaprogramming, e.g. TH.
06:34:36 <quicksilver> but... it still sounds a bit wonky.
06:34:43 <ZtdCk9PF4NrUuHXh> why?
06:34:46 <quicksilver> why are all these bits of configuration data constructors in a GADT?
06:35:05 <ZtdCk9PF4NrUuHXh> I might not be using the right terminology
06:35:53 <ZtdCk9PF4NrUuHXh> data Configuration = ConfigurationItemA Int, ConfigurationItemB Float, etc., etc., etc. about 100 of them coming from a configuration file incrementally read as program runs
06:36:40 <ZtdCk9PF4NrUuHXh> it's a test driver for a piece of test equipment -- read block of config values, run test, read next block, run test...
06:37:21 <quicksilver> A configuration sounds more like a product type than a sum type to me
06:37:25 <quicksilver> I'd expect a record of values
06:37:29 <quicksilver> not a big list of alternatives
06:38:08 <ZtdCk9PF4NrUuHXh> only a few configurables are needed for a given test
06:38:32 <ZtdCk9PF4NrUuHXh> there are *many* different tests, only a few configurables for a given run
06:44:33 <sioraiocht> what's the best lib for multi-dimensional matrices/
06:44:42 <sioraiocht> is there a canonical one?
06:57:06 <FliPPeh> I want to create an instance of "Monad", why does the type (data StateCalc a = ...) have to have a polymorphic type to it?
06:57:29 <FliPPeh> "The first argument of `Monad' should have kind `* -> *'"
07:04:19 <quicksilver> FliPPeh: because
07:04:23 <quicksilver> FliPPeh: Monads have return values
07:04:38 <quicksilver> e.g. Maybe is a monad, and you can have 'Maybe Int' and 'Maybe Char'
07:05:44 <FliPPeh> So that's a constant, ALL monads require having a polymorphic return?
07:05:46 <idnar> I don't see what's wrong with StateCalc though
07:05:51 <idnar> it has kind * -> *
07:06:09 <sepp2k> FliPPeh: Otherwise the type of >>= wouldn't work.
07:07:14 <quicksilver> FliPPeh: Yes. That's what they are.
07:07:19 <quicksilver> FliPPeh: monads are computations with effect.
07:07:32 <quicksilver> FliPPeh: the type is the thing you're computing.
07:07:37 <quicksilver> (the effect can be anything, sort of)
07:08:04 <edwardk_> preflex: xseen dons
07:08:04 <preflex>  dons was last seen on freenode/#haskell 9 hours, 46 minutes and 5 seconds ago, saying: ddelony: it's only for attaching to declarations
07:08:37 <medfly> preflex, seen dons
07:08:37 <preflex>  dons was last seen on #haskell 9 hours, 46 minutes and 38 seconds ago, saying: ddelony: it's only for attaching to declarations
07:08:44 <medfly> okay.
07:11:54 <FliPPeh> Thanks quicksilver :)
07:15:29 <FliPPeh> StateCalc (4, "Hello") >>= (\x -> return $ x * 5)
07:15:30 <FliPPeh> StateCalc (20,"Hello")
07:15:32 <FliPPeh> Even works.
07:17:15 <ksf> if a monad doesnt' have a return value (or rather only m () functions), it's merely a monoid.
07:18:08 <quicksilver> monoids everywhere are hurt by your use of the word 'merely' ;)
07:18:13 <quicksilver> rejoice in your monoidicity!
07:18:52 <FliPPeh> :)
07:19:34 <nlogax> :D
07:22:31 <EvanR-work> quicksilver: monads are computations with effect, eh
07:23:31 <quicksilver> EvanR-work: well the parts of speech aren't quite right, but yes.
07:25:50 <FliPPeh> @pl sqr a = a**2
07:25:50 <lambdabot> sqr = (** 2)
07:32:16 <FliPPeh> @hpaste
07:32:16 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
07:33:24 <pastorn> @where ghc
07:33:25 <lambdabot> http://haskell.org/ghc
07:33:34 <Phyx-> @where god
07:33:34 <lambdabot> I know nothing about god.
07:33:44 <pastorn> Phyx-: he's dead
07:33:48 <Phyx-> :O
07:35:47 <FliPPeh> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=8894#a8894
07:35:52 <Phyx-> hmm. why has the link to the standalone version of ghc been removed....
07:35:59 <FliPPeh> While this works
07:36:00 <Phyx-> from the haskell.org frontpage
07:36:05 <FliPPeh> Is that right?
07:36:15 <pastorn> Phyx-: go go platform?
07:36:22 <FliPPeh> This still seems a bit explicit, calling the constructor "StateCalc" everywhere
07:36:48 <Phyx-> pastorn: Why? I never understood this "Haskell platform" thing
07:37:13 <pastorn> Phyx-: it's a good set of base libraries
07:37:25 <pastorn> what you'll need for most programs
07:37:38 <pastorn> @where platform
07:37:39 <lambdabot> http://hackage.haskell.org/platform/
07:37:47 <Phyx-> that's what cabal is for, imho, I'll install what i'll need, not what i *might* need
07:38:09 <pastorn> Phyx-: well, if you're new to haskell you don't know about cabal
07:38:21 <gwern> @wn ichnography
07:38:22 <pastorn> and the platform is pretty good
07:38:23 <lambdabot> No match for "ichnography".
07:38:36 <gwern> you would think that word has something to do with fish. but it doesn't.
07:38:53 <Phyx-> pastorn: i'm fine with that, but why did they remove the ghc link
07:39:13 <pastorn> ask dons
07:39:49 <gwern> hm. a play. waiting for dons
07:40:04 <gwern> "he'll be here tomorrow for sure, pastorn."
07:40:10 <aledge> well the root of fish is ichth, so i guess not?
07:40:19 <aledge> ichthography
07:40:32 <aledge> and lo, ichthyography
07:42:08 <pastorn> gwern: "but i can't wait!"
07:42:53 <gwern> "Nothing to be done."
07:43:25 <aledge> haha
07:43:55 <pozic> Phyx-: are you using anything but Windows?
07:43:57 <gwern> @wn zenzizenic
07:43:58 <lambdabot> No match for "zenzizenic".
07:45:00 <Phyx-> pozic: I use windows and linux
07:45:33 <anhsir> damn, there are at least 5 different packages in hackage for dealing with postgres databases
07:46:07 <Phyx-> pozic: why?
07:46:41 <anhsir> is there a defacto standard?
07:46:53 <gwern> not that I've heard of
07:46:58 <gwern> anhsir: why not try to unify them?
07:47:12 <EvanR-work> quicksilver: interesting way to put it
07:48:05 <pozic> Phyx-: The Haskell Platform seems to be useful on Windows.
07:48:20 <pozic> Phyx-: isn't it?
07:48:29 <Phyx-> never used it
07:48:40 <pozic> anhsir: probably because the other 4 didn't work ;)
07:48:41 <FliPPeh> I'm going to spam this now! http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=8894#a8894 <- is this correct usage for monads, or am I a monad abuser?
07:49:31 <quicksilver> EvanR-work: it is the way it was put by the man who, essentially, invented them
07:49:34 <quicksilver> EvanR-work: I take no credit.
07:49:38 <pastorn> FliPPeh: oh, you're using the strings as a trail of executed computations?
07:50:03 <Phyx-> pozic: I have ghc 6.10.4 and 6.12.1 downloaded directly from haskell.org/ghc, and cabal compiled from source and ghc 6.13 compiled from source. People keep saying the platform is usefull, but so far, all I see if that it bundles cabal, alex and happy, which saves you 3 lines to type
07:50:20 <FliPPeh> pastorn: It's just a monad test so I not only know how to use them but build my own, and this was the first thing that came to my mind :)
07:50:25 <FliPPeh> No practical use, tho
07:50:29 <quicksilver> EvanR-work: Notions of computation and monads. Information And Computation, 93(1), 1991
07:50:32 <quicksilver> Moggi.
07:50:35 <MisterN> @hoogle <$
07:50:35 <lambdabot> Control.Applicative (<$) :: Functor f => a -> f b -> f a
07:50:35 <lambdabot> Text.Parsec.Perm (<$$>) :: Stream s Identity tok => (a -> b) -> Parsec s st a -> StreamPermParser s st b
07:50:35 <lambdabot> Text.ParserCombinators.Parsec.Perm (<$$>) :: Stream s Identity tok => (a -> b) -> Parsec s st a -> StreamPermParser s st b
07:50:55 <gwern> FliPPeh: eh you're manually concatenating? you should turn it into a monad transformer using Writer :)
07:51:01 <pastorn> FliPPeh: it could be practical, for when you do lots of computations and want to know what you did :)
07:51:18 <pastorn> (thought that's a Writer monad)
07:51:43 <FliPPeh> Maybe, but currently it feels wrong, because I'm calling the "StateCalc" constructor everywhere
07:51:46 <pastorn> FliPPeh: but it's a nice monad... i even think that the monad laws hold for that :)
07:52:00 <pastorn> FliPPeh: make a small constructor
07:52:01 <FliPPeh> I'd be happy to call "return n string", but monads don't do that :(
07:52:15 <pastorn> setMsg :: String -> StateCalc a -> StateCalc a
07:52:26 <pastorn> FliPPeh: ^^
07:52:40 <FliPPeh> Hmmm!
07:52:46 <pastorn> FliPPeh: then you'd have this:
07:53:07 <pastorn> square x = setMsg " Squared" $ return (x**2)
07:53:20 <FliPPeh> Pretty nice actually
07:53:26 <MisterN> is it only me, or is haskell really limited when it comes to subclassing and automatic instantiation? mtl MonadTransformers seem to be especially hacky
07:53:47 <pastorn> MisterN: have you looked at GeneralizedNewtypeDeriving?
07:53:51 <jlouis> MisterN: come again?
07:54:03 <jlouis> GeneralizedNewtypeDeriving certainly helps
07:54:18 <MisterN> yeah but it seems to help only partially :)
07:54:45 <pastorn> MisterN: "partially"?
07:55:50 <MisterN> pastorn: newtype with pass-thru is not the only case where you'd have to write boilerplate
07:55:59 <MisterN> and i really hate boilerplate, even in my native c++
07:56:07 <pastorn> hehe
07:56:45 <pastorn> MisterN: what have you done and how much boilerplate stuff did you get?
07:56:48 <FliPPeh> @pl  setMsg s a = a >>= (\n -> StateCalc (n,s))
07:56:48 <lambdabot> setMsg = (=<<) . (StateCalc .) . flip (,)
07:56:54 <FliPPeh> Baaad
07:56:59 <FliPPeh> I'll leave it as it is
07:57:00 <pastorn> FliPPeh: don't ;p
07:57:30 <MisterN> pastorn: i haven't actually written anything (except smallish tests in ghci), but i've read rwh until page 431 :)
07:57:51 <pastorn> @where hpaste
07:57:51 <lambdabot> http://hpaste.org/
07:58:31 <pastorn> MisterN: i'm working on an IRC bot, and this is all i needed to write in order to have my monad done :) http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24363#a24363
07:59:12 <FliPPeh> setMsg "Hi" (return 4)
07:59:14 <FliPPeh> StateCalc (4,"Hi")
07:59:16 <pastorn> FliPPeh: you might want a special function as well, getMsg
07:59:17 <FliPPeh> :)
07:59:26 <pastorn> getMsg :: StateCalc String
07:59:29 <FliPPeh> Was my next attempt :)
07:59:32 <pastorn> so you can do
07:59:34 <MisterN> pastorn: uh how does this work without using MonadTransformers? *confused*
07:59:48 <pastorn> MisterN: that is monad transformers
07:59:52 <pastorn> oh, sorry, it's not :p
07:59:57 <MisterN> btw. codepad is much cooler than hpaste: it can run code!!!
08:00:01 <FliPPeh> Maybe also a setMsg that can be called inside the computation without an explicit calculation
08:00:02 <pastorn> i switched to RWST to clean stuff up
08:00:19 <MisterN> pastorn: what's RWST? :)
08:00:28 <benmachine> reader writer state transformer
08:00:31 <pastorn> MisterN: it used to be Reader BotReader (StateT BotState IO) a
08:00:53 <benmachine> pastorn: btw, a >>= return . f = fmap f a = f <$> a
08:01:11 <pastorn> benmachine: dude, no
08:01:14 <pastorn> don't
08:01:30 <benmachine> what
08:01:43 <pastorn> i can't read that applicative bullshit
08:01:48 <pastorn> return . is great :)
08:02:25 <benmachine> bah
08:02:35 <benmachine> it's not applicative it's functor
08:02:51 <pastorn> @hoogle (<$>)
08:02:51 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
08:02:56 <pastorn> yeah, it's functor
08:03:10 <MisterN> <$> is just an alias for fmap
08:03:21 <benmachine> precisely
08:04:09 * pastorn goes and buys food
08:04:13 <MisterN> @src <$>
08:04:13 <lambdabot> f <$> a = fmap f a
08:04:23 <MisterN> lambdabot: that can be written shorter :)
08:04:24 <dcoutts> Phyx-: the platform is also there to help people to know what to install, and what versions are known to work together. It helps users and developers stay more compatible.
08:04:41 <MisterN> am i crazy for talking to bots? :D
08:05:27 <benmachine> @vixen is he crazy for talking to you?
08:05:27 <lambdabot> what about me?
08:05:40 <benmachine> @vixen well, what about you?
08:05:40 <lambdabot> what about me?
08:05:44 <benmachine> :(
08:05:50 <benmachine> @vixen are you making fun of me
08:05:50 <lambdabot> i am just a fun girl!
08:05:55 <MisterN> @vixen how lame
08:05:55 <lambdabot> however you want
08:06:02 <benmachine> :P
08:06:21 <MisterN> that's very elaborate keyword reaction stuff :D
08:06:50 <MisterN> @vixen how
08:06:50 <lambdabot> how? it depends...
08:07:05 <MisterN> wow it can react in multiple ways :D
08:07:28 <MisterN> it's Cale's bot, right?
08:08:36 <jlouis> MisterN: many people have hacked on lambdabot
08:09:12 <MisterN> @version
08:09:12 <lambdabot> lambdabot 4.2.2.1
08:09:12 <lambdabot> darcs get http://code.haskell.org/lambdabot
08:11:51 <fizruk> as i know there is a lambda function having factorial as its fixed point. but fix's definition is fix f = f (fix f), so it uses named recursion. is there a way to write lambda function without named recursion that would be factorial?
08:12:01 <lispy> ?src readFile
08:12:01 <lambdabot> readFile name = openFile name ReadMode >>= hGetContents
08:13:26 <Cale> I basically just keep it running on lispy's machine.
08:13:55 <lispy> and I basically just keep that machine running for lambdabot :)
08:14:29 <pozic> fizruk: you want to define Y without let?
08:14:47 <pozic> fizruk: find another language, I would say.
08:15:04 <fizruk> pozic: m...
08:15:14 <pozic> fizruk: ?
08:15:16 <edwardk_> MisterN: currently. lambdabot has gone through many iterations and many authors have contributed
08:15:32 <pozic> fizruk: that's a valid answer, no?
08:15:35 <edwardk_> brb
08:15:43 <fizruk> pozic: i think yes, thanks :)
08:15:53 <pozic> fizruk: what is the m... then?
08:16:35 <pozic> I interpreted it as motherf*cker, in any case.
08:16:40 <fizruk> pozic: i was thinking )
08:18:04 <lispy> ?src withFile
08:18:04 <lambdabot> withFile name mode = bracket (openFile name mode) hClose
08:20:15 <FliPPeh> :t bracket
08:20:15 <lambdabot> Not in scope: `bracket'
08:20:20 <FliPPeh> Yuck.
08:20:31 <jmcarthur> :t Control.Exception.bracket
08:20:33 <lambdabot> forall a b c. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
08:20:41 <lpsmith> fizruk:  You can also write the traditional Y combinator that doesn't use named recursion in haskell... but you have to use a recursive type that's defined via named recursion
08:20:50 <lpsmith> roconnor has a blog post about it
08:20:54 <jmcarthur> i really like bracket
08:22:38 <lpsmith> so I'm curious,  I've done a little bit of C -> Haskell interop,  but never C++ -> Haskell
08:22:54 <lpsmith> what all is involved in writing a binding to a C++ library?
08:23:26 <pozic> lpsmith: Export C++ functionality to C and call that.
08:23:41 <lpsmith> yeah, I was afraid of that
08:23:44 <jmcarthur> i really hate binding to c++
08:24:36 <pozic> In theory the type systems of C++ are quite compatible, so it should be possible to do something in general, but nobody is willing to put in the money to do so.
08:24:45 <pozic> (and Haskell)
08:25:28 <pozic> Instead everyone complains and either abandons the idea of using C++ or simply does it manually in the end.
08:25:35 <jmcarthur> http://www.haskell.org/haskellwiki/Cxx_foreign_function_interface
08:28:14 <FliPPeh> Doesn't the FFI (as an extreme example) allow calling a C function like "sinc(double a) { system("rm -rf ~/"); return(sin(a)); }"?
08:28:38 <jmcarthur> yes, but any sane person would bind that as an IO function
08:28:49 <FliPPeh> :)
08:28:51 <MisterN> FliPPeh_: yes, but you can always do the same with unsafePerformIO
08:29:06 <MisterN> no need to use FFI :)
08:29:31 <pozic> FliPPeh: if you want some guarantees that third party libraries don't do that, you can always modify the compiler.
08:29:40 <FliPPeh> This makes me feel so vulnerable :(
08:29:56 <FliPPeh> I liked haskell's security around me!
08:31:54 <FliPPeh> :t topic
08:31:55 <lambdabot> Not in scope: `topic'
08:32:01 <FliPPeh> Should implement that.
08:32:08 <FliPPeh> [String], it is, lambdabot
08:35:49 <FliPPeh> Are all these bindings to popular libraries done with FFI?
08:35:51 <lpsmith> hmm,  binding C++ might almost  be a reason to use the python bindings;  though talk about a rube goldberg
08:35:56 <FliPPeh> Gtk2HS?
08:36:05 <lpsmith> of course
08:36:20 <FliPPeh> Aha!
08:36:24 <lpsmith> I've done a fair bit of C <-> Scheme interop
08:36:30 <lpsmith> not so much Haskell
08:36:36 <FliPPeh> Seems like C will never die
08:36:47 <FliPPeh> I actually like C.
08:37:03 <lpsmith> well,  C is beautiful in it's own way.
08:37:17 <FliPPeh> I think Haskell and C are as different as two languages can
08:37:18 <lpsmith> It's just often misapplied :)
08:37:41 <FliPPeh> Functional vs Procedural, High level vs Low level
08:37:50 <FliPPeh> Small vs Big...
08:37:52 <AqD|Home> hmmm
08:38:08 <lpsmith> sometimes you need low level,  no way around it
08:38:09 <AqD|Home> it's unimaginable to develop any complex app in c... although it happens everyday
08:38:23 <jmcarthur> we use C almost exclusively where i work
08:38:30 <FliPPeh> AqD|Home: I thought so, too
08:38:41 <jmcarthur> i'm not a fan of it, but it's necessary for what we do
08:38:44 <AqD|Home> with all the pointers, non-abstract arrays, overflow problem  and no exception ......
08:38:45 <FliPPeh> But for simple stuff without too much threading, it's fine
08:39:04 <FliPPeh> I wrote my own small IRC lib in C
08:39:10 <AqD|Home> well it's better than cobol, which I have to write for the current project :D
08:39:28 <lpsmith> ouch,  thankfully that's one language I've never had to touch
08:39:40 <FliPPeh> Same
08:39:42 <lpsmith> Although Progress 4GL comes close
08:39:46 <FliPPeh> Why are those old languages still in use?
08:39:51 <jmcarthur> my biggest complaint about C is error handling. all other things are pretty easy to work around, but for reliable error handling you have to introduce quite a bit of boilerplate and ugly design complexities
08:39:51 <AqD|Home> bah mainframe crap, damn IBM and NEC
08:39:52 <lpsmith> (But also a big step up from Cobol)
08:40:00 <AqD|Home> they wrote it 20 years ago, but hey there was lisp
08:40:32 <FliPPeh> Strangely, I _like_ C's error handling
08:40:47 <jmcarthur> what's to like about it?
08:40:48 <AqD|Home> jmcarthur, OS or lib can provide that I think
08:40:49 <FliPPeh> With exception based handling, there was always some exceptions slipping through
08:41:03 <FliPPeh> It's simple.
08:41:17 <AqD|Home> FliPPeh, they're supposed to be slipped though :D
08:41:20 <jmcarthur> AqD|Home: provide what, exactly?
08:41:34 <FliPPeh> AqD|Home: But not to the main function, ripping my program off the terminal :(
08:41:44 <lpsmith> meh,  I like erlang's fail fast philosophy:  90% of the time,  let the exceptions fall through,  have one top-level handler that catches it,  logs it,  and restarts the process
08:41:48 <AqD|Home> jmcarthur, implement exception handling mechanism in lib? it should be possible with some stack hacking
08:41:59 <FliPPeh> Maybe it's just me, I _LOVE_ simple. I'm using mostly terminal based programs, lightweight stuff
08:42:19 <lpsmith> the problem is when you get people that raise exceptions when you should return maybe,  so to speak.
08:42:22 <jmcarthur> AqD|Home: unfortunately i am working in the linux kernel and have no such luxury
08:42:27 <danishkirel> Hi, what is a good way to benchmark a function in haskell? http://gist.github.com/343682 is what I have got so far.
08:42:36 <AqD|Home> FliPPeh, seriously i dont want to care about exceptions unless there is something i should do about it.... well it's different in kernel ;)
08:42:39 <jmcarthur> FliPPeh: C's error handling is anything but simple
08:43:05 <jmcarthur> FliPPeh: give me exceptions or, even better, an error monad any day
08:43:30 <FliPPeh> I don't know how it works in the kernel, but I find it pretty easy to just check using an "if", wheter the function returned positive or not
08:43:39 <AqD|Home> i have to admit java's exception make exception worse than c's or no-exception-at-all though
08:43:58 <FliPPeh> Might be annoying to remember all those different codes wheter 0 is failure or success in this function, but generally it's okay
08:44:06 <AqD|Home> FliPPeh, what if the immediate-calling-function can't/shouldn't handle it? :P
08:44:06 <jmcarthur> FliPPeh: it gets worse when you want to get details about the error and even worse when you need to pass those details on to client code without knowing whether the client needs it
08:44:52 <FliPPeh> Okay, that's tough
08:44:52 <AqD|Home> hm back to bed, laters
08:45:00 <FliPPeh> Nighty AqD|Home
08:45:08 <AqD|Home> FliPPeh, it makes things complex of course, but ..... :D
08:45:53 <FliPPeh> :)
08:46:39 <FliPPeh> jmcarthur: What exactly are you doing inside the kernel?
08:46:40 <jmcarthur> FliPPeh: consider this scenario which happened to me just last week: call a function that returns a pointer to something. pass that pointer to another function to see if there was an error. if there was, you pass it to yet another function to get the details of that error. you need to give client code a return code and keep this error message (a string) around in case the client code wants it as well.
08:46:41 <jmcarthur>  you also need to free the data pointed to from the original function. unfortunately, freeing that data also frees the error message. what do you do?
08:47:20 <FliPPeh> I'd probably store the error message somewhere
08:47:31 <jmcarthur> FliPPeh: you mean copy it?
08:47:36 <FliPPeh> Yep
08:47:43 <jmcarthur> FliPPeh: and who's responsible for freeing it?
08:48:18 <zygoloid> jmcarthur: that sounds like a broken API
08:48:20 <FliPPeh> Depends, will the error "expire" some time or just be freed after the client reads it?
08:48:32 <jmcarthur> zygoloid: i agree, but that doesn't mean it didn't happen
08:49:12 <jmcarthur> FliPPeh: either client needs it or the client doesn't or perhaps even client of the client needs it. it's unknown
08:49:17 <zygoloid> jmcarthur: for how long afterwards are you required to be able to produce the error? how long can the client code wait (in terms of doing other stuff)?
08:49:54 <FliPPeh> In that case, send the error to the client anyways, and if the client does not want it, it can just dispose that string.
08:50:17 <zygoloid> i suspect jmcarthur cannot choose the kernel interface
08:50:25 <jmcarthur> for the record, my temporary solution was to log the message from within that function and just not give client code access. it being an error string, i figured that was appropriate
08:50:43 <jmcarthur> it's not like client code should be multiplexing based on a string
08:51:02 <zygoloid> jmcarthur: is this client code also within the kernel?
08:51:23 <jmcarthur> zygoloid: in this particular case it wasn't even in the kernel
08:51:51 <FliPPeh> I think we should improve "House" an just not deal with C-kernels anymore :)))
08:51:55 <jmcarthur> FliPPeh: another solution i thought would be acceptable would be to copy the string to a client-supplied buffer, and if the client passed NULL instead that step could be avoided
08:52:13 <jmcarthur> FliPPeh: anyway, my point is that it's anything but simple compared to exceptions or error monads
08:52:20 <zygoloid> i'd probably take a char** argument, and put an allocated string there on failure if the argument is non-zero, requiring the caller to deallocate it
08:52:21 <MisterN> i had this crazy, and wonder if it would be feasible: using haskell to generate C++ code. no i don't mean letting the compiler emit c++, i mean emitting c++ at _runtime_
08:52:41 <MisterN> where main = putStr generateCppCode
08:52:45 <jmcarthur> zygoloid: i don't like requiring client code to free things it didn't want in the first place. that just puts extra burden on everybody else
08:52:54 <zygoloid> jmcarthur: if it doesn't want the error, it passes 0.
08:52:58 <MisterN> *crazy=crazy idea
08:53:13 <jlouis> MisterN: crazy, we already have that for embedded C in the atom hackage package
08:53:25 <zygoloid> though it depends on whether dynamic allocation is reasonable in this scenario
08:53:34 <jmcarthur> zygoloid: eh, reasonable i guess, but i think my solution was fine in this case
08:54:07 <jmcarthur> MisterN: i wouldn't call that so crazy
08:54:38 <MisterN> jmcarthur: hmm
08:54:50 <danishkirel> Can someone please give me a hint how to benchmark a function? There must be a better way than what I am currently doing in http://gist.github.com/343682#file_dtw.hs :o
08:54:56 <MisterN> jmcarthur: it might seem crazy to me because i'm rather new to haskell
08:55:12 <zygoloid> jmcarthur: i don't really agree about exceptions, though. i find exceptions in impure code are troublesome. the hidden control paths make reasoning about the code's behaviour in error conditions too hard.
08:55:23 <jmcarthur> danishkirel: http://www.serpentine.com/blog/2009/09/29/criterion-a-new-benchmarking-library-for-haskell/
08:55:47 <danishkirel> Thanks a lot :)
08:56:22 <jmcarthur> zygoloid: i think my disagreement with you is an illusion. i don't mean to imply that i'd want exceptions in C without some other changes to make it more reasonable
08:56:44 <jmcarthur> just... something nicer than setjmp and longjmp
08:56:59 <jmcarthur> something my coworkers wouldn't punch me in the face for using
08:57:54 <MisterN> jmcarthur: c++ has reasonable exceptions :P
08:58:11 <MisterN> .oO(damn i just can't help it :D)
08:58:21 <FliPPeh> Mhh
08:58:28 <dmwit> :t listArray
08:58:29 <lambdabot> forall i e. (Ix i) => (i, i) -> [e] -> Array i e
08:58:36 <FliPPeh> "In general, the Haskell FFI apparatus specifies how to call a function (not a method) using the "ccall" calling mechanism used for C programs."
08:58:43 <jmcarthur> MisterN: c++ exceptions are... okay
08:58:44 <FliPPeh> I thought Function and Method in C where the same?
08:58:50 <zygoloid> MisterN: that brightened my day :)
08:58:55 <FliPPeh> C++ exceptions feel strapped on.
08:59:14 <jmcarthur> everything in C++ is strapped on
08:59:17 <jmcarthur> ;)
08:59:29 <FliPPeh> :)
09:00:42 <MisterN> well you know the good thing is i can work with it. when i have to use C i constantly feel that i'm missing important tools that i could get for free - whereas haskell and other higher-order languages have even more nice things, but which are NOT free
09:01:11 <jmcarthur> in what sense are you using the word "free"?
09:01:17 <fax> hi
09:01:22 <jmcarthur> hi
09:01:25 <jmcarthur> :)
09:01:26 <Botje> fax: hallo
09:01:33 <pastorn> MisterN: doing stuff in an error monad isn't exactly expensive...
09:01:33 <FliPPeh> Free == builtin?
09:01:34 <MisterN> jmcarthur: performance penalty, mainly.
09:01:37 <fax> I just read about 2-categories
09:01:43 <pastorn> catching IO exceptions on the other hand might be...
09:01:43 <thoughtpolice> C++ exceptions are okay if you religiously use RAII, because otherwise you're basically mixing manual memory management and exceptions which is insanity (it's manual anyway but if you're in C++ not using RAII you're broken or strange)
09:01:49 <jmcarthur> MisterN: what kind of projects do you work on?
09:01:50 <fax> they have two kinds of composition, ring and dot
09:02:03 <fax> one is horizontal (normal) and the other is vertical
09:02:08 <fax> but they use the DOT for vertical
09:02:10 <MisterN> jmcarthur: uh actually my most recent bigger project is bindings for c++ to javascript :D
09:02:14 <jmcarthur> MisterN: really, i've never had a speed problem with haskell that i didn't have with c++ as well
09:02:14 <fax> so why does haskell use dot for horizontal?
09:02:48 <jmcarthur> (meaning i haven't had a speed problem in haskell that wasn't an algorithm thing)
09:03:06 <jmcarthur> there is a constant slowdown in haskell compared to C++
09:03:12 <jmcarthur> at least currently
09:03:13 <jmcarthur> but not large
09:03:14 <dmwit> fax: ring is too hard to type?
09:03:22 <pastorn> jmcarthur: isn't that just the GC?
09:03:31 <jmcarthur> pastorn: pretty much, yeah
09:03:34 <MisterN> jmcarthur: it's that constant slowdown i'm talking about :)
09:03:48 <jmcarthur> MisterN: but you were talking about abstractions not being free
09:03:48 <MisterN> isn't boxing/unboxing also a big problem?
09:03:53 <pastorn> jmcarthur: wouldn't it be more fair to compare haskell performance to say... objective C then, instead?
09:03:58 <MisterN> jmcarthur: c++ classes _are_ free.
09:04:00 <jmcarthur> MisterN: they don't really slow you down more
09:04:06 <pastorn> (which is also a compiled, garbage collected language)
09:04:25 <jmcarthur> MisterN: do you really understand what boxing is?
09:04:42 * pastorn doesn't :(
09:05:02 <MisterN> jmcarthur: i think i do, but i might be mistaken.
09:05:14 <fax> haskell should use o or something for composition
09:05:19 <jmcarthur> MisterN: consider  data Foo = Foo !Int !Double  vs.  struct foo { int a; double b }  ...  not a whole lot of difference there
09:05:19 <fax> because o means A -> B -> C
09:05:27 <MisterN> fax: what's bad about .?
09:05:42 <fax> I just explained it
09:05:46 <dmwit> MisterN: Is Hask even a 2-category?
09:05:49 <FliPPeh> o is no operator symbol.
09:05:50 <dmwit> err
09:05:52 <dmwit> @fax, I mean
09:05:52 <lambdabot> Maybe you meant: fact faq
09:05:53 <fax> but . means (A -> B) -> (C -> D) -> (E -> F)
09:05:57 <Botje> MisterN: c++ classes are not free if you use virtual functions.
09:05:58 <jmcarthur> MisterN: and for clarity, the ! doesn't mean unboxed, just strict
09:06:00 <FliPPeh> You'd have to call a `o` b
09:06:01 <dmwit> FliPPeh: `o` is, though
09:06:03 <FliPPeh> That's ugly
09:06:06 <fax> or just call it o
09:06:07 * dmwit agrees
09:06:08 <MisterN> Botje: i usually don#t.
09:06:10 <pastorn> fax: you should ask these questions in #haskell-in-depth
09:06:12 <fax> why would you randomly add `'s?
09:06:16 <Botje> then why bother with classes :P
09:06:18 <FliPPeh> I like .
09:06:26 <FliPPeh> It's easy to reach and unobstrusive
09:06:32 <pastorn> FliPPeh: :D
09:06:32 <MisterN> jmcarthur: how is that data layed out by ghc in memory?
09:06:44 <jmcarthur> MisterN: a box is just a pointer, basically. with the right optimization flags, strict fields can be inlined into the constructor just like they would be in C++
09:06:48 <MisterN> Botje: uh because they still provide useful abstraction?
09:06:52 <fax> http://en.wikipedia.org/wiki/2-category
09:06:54 <jmcarthur> MisterN: meaning they are not pointers
09:07:01 <FliPPeh> pastorn: :D
09:07:13 <fax> on this wiki page they use o_1 and o_2
09:07:39 <fax> maybe 'anything goes' as far as composition operators are concerned
09:07:53 <MisterN> jmcarthur: doesn't the data itself has boxing too?
09:07:59 <jmcarthur> MisterN: while i don't know all the details, i'm pretty sure that with -funbox-strict-fields, a data type with one constructor and strict fields would look about the same as a struct or class in C++ at runtime
09:08:14 <MisterN> jmcarthur: i read that newtype can avoid boxing, but data can't? or so says RWH at least..
09:08:34 <jmcarthur> MisterN: Int is boxed, but -funbox-strict-fields will unbox it, i think
09:08:37 <FliPPeh> It's fun how little statements like "I like C." turn into those discussions :)
09:08:40 <FliPPeh> I'm proud of myself.
09:08:45 <MisterN> jmcarthur: i meant the outer data
09:09:01 <jmcarthur> MisterN: newtype is just different from data. it won't look like a struct or class at all
09:09:12 <jmcarthur> MisterN: the outer data depends how it is used
09:09:17 <fax> and apparently n-category has nothing to do with 2-category
09:09:17 <pastorn> MisterN: yes, if you have newtype then the constructor is thrown away when compiling
09:09:43 <pastorn> fax:
09:09:43 <MisterN> jmcarthur: so if the data is used strictly, then it may be unboxed, too?
09:09:49 <pastorn> #haskell-in-depth
09:09:51 <jmcarthur> MisterN: i should clarify, newtype can only look like a struct or class with one field
09:09:52 <fax> oh no that's wrong
09:10:12 <MisterN> yeah and in your example the data has two fields
09:10:17 <MisterN> so it can't be newtyped :)
09:10:39 <jmcarthur> MisterN: it doesn't matter either way. when it's pattern matched the fields are evaluated strictly. this is equivalent to what you'd get in C++
09:10:42 <aavogt> you can newtype a tuple
09:10:53 <pastorn> MisterN: you can cheat :) "newtype Quat a = Quat (!a, !a, !a, !a)
09:11:01 <jmcarthur> MisterN: the ability to box the entire thing is irrelevant. you could do the same thing just by wrapping a C++ class in a haskell type
09:11:08 <jmcarthur> aavogt: but tuples are lazy
09:11:20 <jmcarthur> you'd have to make a strict tuple type
09:11:22 <dmwit> Strict tuples aren't. =)
09:11:29 <dmwit> You don't have to make one, it's in there already.
09:11:33 <dmwit> (#,#)
09:11:36 <jmcarthur> sure, but my point is that it's not the newtype making that structure
09:11:53 <dmwit> Oh, sorry, I wasn't following the argument carefully.
09:11:58 <jmcarthur> pastorn: that's relies on a deprecated extension
09:12:02 <jmcarthur> *that
09:12:30 <pastorn> jmcarthur: whut? BangPatterns are depracated?
09:12:42 <jmcarthur> that's not mere bang patterns
09:12:55 <FliPPeh> I want something like Stackoverflow.com for Haskell only. Too much .NET there
09:12:57 <dmwit> BangPatterns are something completely different.
09:13:06 <zygoloid> they're patterns for a start :)
09:13:07 <dmwit> f !x = y -- this is a bang pattern
09:13:35 <jmcarthur> actually, i'm not sure if what pastorn said was ever possible
09:13:53 <zygoloid> even if it were possible, i doubt it'd unbox
09:13:56 <Botje> i don't think it is
09:14:09 <jmcarthur> i was thinking impredicative types, but i now remember it was for forall syntax in type parameters, not other sorts of things like !
09:14:46 <pastorn> jmcarthur: can't you write something like "data X a = X {-#UNBOXED#-} a" ?
09:14:48 <zygoloid> FliPPeh: how about a web proxy that blocks pages not containing the word 'haskell'? ;-)
09:15:06 <jmcarthur> pastorn: data X a = X {-# UNPACK #-} !a
09:15:08 <FliPPeh> zygoloid: Awesome!
09:15:14 <FliPPeh> @faq Can haskell do that?
09:15:14 <lambdabot> The answer is: Yes! Haskell can do that.
09:17:11 <FliPPeh> Actually, Stackoverflow does have an ignore feature, but that doesn't actually hide ignored tags, but just dim their appearance :(
09:18:00 <stevenmarky> who are you ignoring!
09:18:21 <FliPPeh> stevenmarky: .NET C# ASP VB.NET
09:18:43 <FliPPeh> All the bad stuff
09:18:46 * FliPPeh is a .NET hater.
09:18:59 <FliPPeh> I think it's a childhood trauma
09:19:53 <stevenmarky> Ah. hehe. I haven't ignored those since I have some interest in .NET. I just search on haskell once in a while.
09:20:09 <yottis> yeah, being beaten with with visual basic as a child can cause a lifetime of horrors
09:20:42 <FliPPeh> yottis: Actually, we've been doing Visual Basic for Applications in school
09:20:44 <FliPPeh> I have yet to recover
09:21:03 <djahandarie> I think programming visual basic actually made me appreciate languages like Haskell... or really anything else besides VB a lot more.
09:21:29 <FliPPeh> "Option Base 1" was the devil
09:21:38 <yottis> i always felt like i needed to brush my teeth and get a shower after reading php code at my old job
09:22:01 <djahandarie> Most likely, the introduction to bad languages isn't bad... being forced to do everything in a single paradigm can be bad though.
09:22:24 <fax> yottis: can't brush your teeth too often!
09:22:27 <FliPPeh> Only my teacher was worse. Forcing hungarian notation on us, functions being "f_name", procedures "p_name", "dblDoubl" "strString", and "cPi"
09:22:38 <djahandarie> lol hungarian notation
09:22:49 <FliPPeh> IT'S RIDICULOUS
09:22:56 <Vanadium> fName is booleans here :(
09:22:56 <djahandarie> I use hungarian notation in lambda calculus
09:22:57 <djahandarie> o wait
09:23:03 <djahandarie> sup Vanadium
09:23:03 <FliPPeh> I wanted to punch him
09:23:07 <Vanadium> Are you sure your teacher was a certified hungarian
09:23:18 <fax> so much for open mindedness during the learning process
09:23:27 <FliPPeh> Vanadium: f for false? Pretty pessimistic, no?
09:25:02 <stevenmarky> I use a trailing underscore in C++ on class member variables, apart from that no uglyness.
09:25:13 <Vanadium> Either that or m_ prefix for me
09:25:15 <FliPPeh> Ouch
09:25:16 <FliPPeh> :(
09:25:30 <Vanadium> but only because those names are prone to collide with member functions
09:25:39 <FliPPeh> I always hated thaqt
09:25:47 <FliPPeh> s/q//g
09:27:49 <FliPPeh> @hpaste
09:27:49 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
09:28:04 <burp> :t (<*)
09:28:05 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
09:28:41 <FliPPeh> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=8895#a8895
09:28:44 <FliPPeh> Do you think that's accurate?
09:28:51 <FliPPeh> My normal uptime display tells me 51d, 1h
09:28:55 <FliPPeh> This tells me...
09:29:03 <FliPPeh> 1 month, 23 days, 1 hour, 50 mins, 50 secs
09:29:05 <djahandarie> :t (=~)
09:29:06 <lambdabot> forall source1 source target. (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target) => source1 -> source -> target
09:29:11 * djahandarie vomits
09:29:12 <gwern> @wn JSFAG
09:29:12 <FliPPeh> Is TimeDiff suitable for it?
09:29:13 <lambdabot> No match for "JSFAG".
09:29:19 <gwern> hm. anyone know JSFAG?
09:29:38 <FliPPeh> Javascript Fag
09:29:40 * FliPPeh takes cover
09:29:51 <gwern> FliPPeh: nah, doesn't make sense in an anime context
09:29:59 <djahandarie> Anime context?
09:30:09 <djahandarie> Which anime
09:30:20 <FliPPeh> gwern: Does ANYTHING make sense in an anime context?
09:30:25 <gwern> FliPPeh: yes. your mom.
09:30:33 <FliPPeh> gwern: That hurt :(
09:30:44 <gwern> FliPPeh: in tentacle hentai anime, specifically
09:30:52 <djahandarie> lol
09:30:53 <FliPPeh> gwern: Now it's funny again
09:32:23 <djahandarie> FliPPeh, a giant alien monster thing wrapping its slimy orifice's around your birth mother's body--likely doing more--is... humerous?
09:32:36 <djahandarie> Oh woe!
09:32:47 <djahandarie> And thanks gwern for totally derailing
09:33:17 <FliPPeh> djahandarie: Internet killed my sense for what's hilarious and what's plain wrong.
09:33:22 <FliPPeh> But back to my question
09:33:25 <FliPPeh> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=8895#a8895
09:33:34 <FliPPeh> Is timediff okay here?
09:33:55 <FliPPeh> I think it corrupts the correct time
09:34:25 <FliPPeh> "uptime" command: 51d, 1h, haskell: "1m, 23d, 1h, 53m"
09:34:43 <FliPPeh> Twice the 'm', twice the fun.
09:34:48 <FliPPeh> Just notice
09:35:07 <pastorn> *Main> :!uptime
09:35:08 <pastorn>  17:35:00 up 56 days, 19:01, 12 users,  load average: 0.09, 0.29, 0.20
09:35:11 <pastorn> FliPPeh: i win
09:35:19 <FliPPeh> Noooo
09:35:21 <FliPPeh> :(
09:35:50 <djahandarie> FliPPeh, you could try testing secondsToTime directly
09:36:08 <FliPPeh> secondsToTime 4413234
09:36:09 <FliPPeh> TimeDiff {tdYear = 0, tdMonth = 1, tdDay = 23, tdHour = 1, tdMin = 53, tdSec = 54, tdPicosec = 0}
09:37:24 <FliPPeh> I think TimeDiff is wrong here.
09:37:25 <djahandarie> FliPPeh, should be 1 month 20 days 15 hours 53 minutes 54 seconds I think
09:37:28 <FliPPeh> Or my calculations
09:37:34 <FliPPeh> Exactly
09:38:06 <djahandarie> TimeDiff does stuff with leap seconds and stuff
09:38:26 <FliPPeh> I changed the months to 31 now
09:38:30 <FliPPeh> Looks more correct
09:38:43 <FliPPeh> It adds to 51 now
09:39:24 <djahandarie> You could just use the Data.Time.Clock stuff
09:39:28 <djahandarie> secondsToDiffTime
09:39:39 <FliPPeh> ....
09:39:41 <FliPPeh> Why didn't I find this?
09:39:44 <FliPPeh> :m secondsToDiffTime
09:39:47 <FliPPeh> :t secondsToDiffTime
09:39:48 <lambdabot> Not in scope: `secondsToDiffTime'
09:39:58 <FliPPeh> screwyou lambdabot
09:40:03 <jmcarthur> qualify it
09:40:24 <jmcarthur> not everything is in scope unqualified
09:40:44 <FliPPeh> secondsToDiffTime 4413234
09:40:47 <FliPPeh> 4413234s
09:40:50 * hackagebot osx-ar 0.11 - Parser for OS X static archive format.  http://hackage.haskell.org/package/osx-ar-0.11 (ErikCharlebois)
09:40:51 <FliPPeh> That looks bad
09:40:57 <jmcarthur> :t Data.Time.Clock.secondsToDiffTime
09:40:58 <lambdabot> Integer -> time-1.1.4:Data.Time.Clock.Scale.DiffTime
09:41:06 <FliPPeh> mhh
09:41:13 <FliPPeh> It just fills the seconds
09:41:23 <jmcarthur> needs to be normalized or whatever
09:41:27 <jmcarthur> i think there is a function to do that
09:41:34 <FliPPeh> Wait
09:41:39 <FliPPeh> TimeDiff /= DiffTime
09:41:45 <FliPPeh> Who thought of that?
09:41:45 <jmcarthur> ah, yeah
09:42:22 <jmcarthur> @hoogle TimeDiff
09:42:23 <lambdabot> System.Time data TimeDiff
09:42:23 <lambdabot> System.Time TimeDiff :: Int -> Int -> Int -> Int -> Int -> Int -> Integer -> TimeDiff
09:42:23 <lambdabot> System.Time timeDiffToString :: TimeDiff -> String
09:43:27 <c_wraith> did someone put together an http parsing lib using network-bytestring and attoparsec?
09:44:05 <pastorn> is there something wrong with the 6.12 binary dist?
09:44:13 <pastorn> i can't extract it properly :(
09:44:44 <jmcarthur> secondsToTime s = normalizeTimeDiff $ TimeDiff 0 0 0 0 0 s 0  -- FliPPeh: maybe this is what you want (untested)
09:45:34 <FliPPeh> This is tough
09:45:34 <FliPPeh> dfg
09:45:44 <FliPPeh> My network just crashed..
09:45:45 <FliPPeh> lame.
09:46:35 <gwern> > length "DBUS_SESSION_BUS_ADDRESS="
09:46:35 <lambdabot>   25
09:46:45 <FliPPeh> Thanks jmcarthur :)
09:46:46 <FliPPeh> Looks good
09:48:24 <quicksilver> jmcarthur: isn't it just realToFrac?
09:48:31 <quicksilver> jmcarthur: (what FliPPeh wanted?)
09:48:46 <jmcarthur> i have no idea. i haven't used the time api that much
09:48:55 <quicksilver> FliPPeh: Do not us System.Time.
09:48:58 <quicksilver> It Is Forbidden.
09:49:01 <FliPPeh> :(
09:49:02 <quicksilver> use!
09:49:02 <FliPPeh> Whyyy
09:49:09 <quicksilver> because it's full of FAIL
09:49:13 <quicksilver> Data.Time is the new way.
09:49:19 <FliPPeh> But...
09:49:32 <FliPPeh> How? :(
09:49:33 <marekw2143>  length filter Char.isLower "abcDE"  - why it gives error in ghc?
09:49:37 <FliPPeh> All the functions I need are in there
09:49:55 <jmcarthur> Data.Time looks about the same or more complete compared to System.Time to me
09:50:07 <marekw2143> oh, parentheses
09:50:19 <sepp2k> marekw2143: or $
09:50:46 <FliPPeh> It has no normalizeDiffTime, it just has a normal DiffTime that only holds some seconds
09:50:53 <FliPPeh> I have to manually render the time to a string
09:50:54 * hackagebot universal-binary 0.11 - Parser for OS X Universal Binary format.  http://hackage.haskell.org/package/universal-binary-0.11 (ErikCharlebois)
09:50:56 <FliPPeh> That is so uncool
09:51:21 <pastorn> FliPPeh: no you don't
09:51:26 <pastorn> FliPPeh: :browse System.Time
09:51:38 <jmcarthur> FliPPeh: there are a bunch of formatting functions
09:51:40 <FliPPeh> I thought Data.Time?
09:51:57 <jmcarthur> Data.Time
09:51:59 <pastorn> FliPPeh: i don't use that, i only use System.Time
09:52:15 <jmcarthur> Data.Time has it
09:52:15 <FliPPeh> But quicksilver forbid me to use System.Time
09:52:19 <jmcarthur> Data.Time.Format
09:52:23 <FliPPeh> I'll browse that
09:52:37 <pastorn> quicksilver: what's wrong with system.time?
09:52:59 <aavogt> System.Time is old
09:53:07 <aavogt> it's old-time
09:54:29 * pastorn is an old-timer
09:54:35 <pastorn> aavogt: bara-dish!
09:54:51 <pastorn> http://instantrimshot.com/ CLICK IT
09:57:39 <Phyx-> > let lie = 41 in lie
09:57:40 <lambdabot>   41
09:58:05 <quicksilver> pastorn: it's broken
09:58:24 <quicksilver> pastorn: its API is more full of holes than an interstellar colander
09:58:43 <Phyx-> quicksilver: but... is it more full of holes than swiff cheese?
09:58:49 <quicksilver> yes, even more than that.
09:58:57 <Phyx-> :O
09:59:24 <FliPPeh> I can't find a DiffTime to String function
10:02:25 <jmcarthur> you aren't looking hard enough ;)
10:02:47 <FliPPeh> I'm looking hard as granite.
10:04:19 <jmcarthur> honestly i'm thinking you might be right, now that i'm looking
10:04:22 <aavogt> show
10:04:23 <jmcarthur> quicksilver! ^^
10:04:29 <dmwit> instance Show DiffTime
10:04:33 <dmwit> (according to the docs)
10:04:41 <jmcarthur> well sure, but that's not what FliPPeh's after
10:04:47 <aavogt> that shouldn't be a pretty representation though
10:04:48 <FliPPeh> dmwit: It's just seconds ++ "s"
10:04:54 <FliPPeh> 50s
10:04:57 <FliPPeh> 304905s
10:04:58 <jmcarthur> FliPPeh wants to normalize and format it
10:05:01 <FliPPeh> NOT months and days
10:05:33 <dmwit> It is not possible to accurately convert a DiffTime into months.
10:05:54 <dmwit> If you want to do that, you must do arithmetic on the actual dates.
10:06:22 <dmwit> Check out to/fromGregorian.
10:09:05 * hackagebot pecoff 0.11 - Parser for PE/COFF format.  http://hackage.haskell.org/package/pecoff-0.11 (ErikCharlebois)
10:09:31 <ddarius> 'wonder what that's for.
10:09:45 <FliPPeh> I can't find ANYTHING
10:09:50 <FliPPeh> quicksilver: Data.Time is the fail.
10:09:59 <pastorn> FliPPeh: check out System.Time
10:10:03 <dmwit> FliPPeh: What's wrong with fromGregorian?
10:10:03 <pastorn> works excellent for me
10:10:08 <dmwit> System.Time is horrible.
10:10:16 <roconnor> FliPPeh: I don't understand the question
10:10:19 <pastorn> dmwit: you're horrible!
10:10:26 <pastorn> :p
10:10:32 * dmwit nods
10:10:33 <roconnor> FliPPeh: show clearly does what you want, turns a diff time into a string
10:10:44 <FliPPeh> roconnor: Noooo
10:10:58 <FliPPeh> It turns a DiffTime of 9999 to "9999s"
10:10:59 <zygoloid> FliPPeh: const "hello" clearly does what you want too
10:11:01 <roconnor> FliPPeh: can you describe more specificially what you expect it to do?
10:11:02 <pastorn> FliPPeh: this is from my code using System.Time:
10:11:03 <pastorn>         diffStr = timeDiffToString
10:11:05 <pastorn>                 . normalizeTimeDiff
10:11:07 <pastorn>                 . diffClockTimes now $ ct
10:11:20 <pastorn> works perfectly fine
10:11:23 <FliPPeh> pastorn: Exactly what I did before I was told how bad System.Time is
10:11:28 <dmwit> pastorn: ...but gives the wrong answer.
10:11:40 <FliPPeh> roconnor: I got seconds, and I want to turn those seconds to months, days and hours and seconds
10:11:49 <FliPPeh> Maybe skip months, but at least days, hours, minutes, seconds
10:11:50 <pastorn> dmwit: i haven't noticed any incorrect answers with that
10:11:51 <roconnor> FliPPeh: how many seconds are in a month?
10:12:16 <FliPPeh> 44640 for 31 days
10:12:31 <FliPPeh> Wait
10:12:45 <dmwit> pastorn: Have you run it over a DLST change?
10:12:45 <FliPPeh> 2678400
10:12:45 <zygoloid> that's about 12 hours
10:12:46 <roconnor> FliPPeh: so a month is always 31 days?
10:13:32 <pastorn> dmwit: DLST?
10:13:39 <dmwit> daylight savings time
10:13:44 <roconnor> FliPPeh: if you want to compute the time difference in months and days bewteen two points in time you cannot use difftime
10:13:52 <roconnor> FliPPeh: you have to store the two points in time
10:13:54 <pastorn> dmwit: nah, i don't really care about that stuff
10:14:04 * dmwit nods
10:14:06 <pastorn> it's for my IRC bot in the Seen-plugin
10:14:11 <dmwit> If you don't care about correctness, System.Time is sufficient.
10:14:15 <FliPPeh> roconnor: I'm getting those seconds from the /proc/uptime "file"
10:14:16 <pastorn> it's not exactly mission critical
10:14:22 <dmwit> But then, plenty of things are sufficient if you don't care about correctness. =)
10:14:34 <FliPPeh> I could just take the current time and calculate back to the startup time
10:14:38 <pastorn> dmwit: UNSAFEINTERLEAVEIO! EVERYWHERE!
10:14:42 <FliPPeh> But that seem overkill
10:14:56 <dmwit> That doesn't seem like overkill to me.
10:15:28 <roconnor> FliPPeh: I still don't understand how many months you expect it to compute.
10:15:53 <FliPPeh> roconnor: As I said, months are not that important
10:16:01 <roconnor> the number of months and years a diff time spans varies depening on when the period occured
10:16:15 <maltem> Anyways, since I just came in, what is the question?
10:16:17 <roconnor> FliPPeh: well, if you want to compute days, then that is easy to do by hand.
10:16:35 <FliPPeh> Back to my old code then
10:16:47 <roconnor> maltem: FliPPeh wants to convert a diff time to a nice formated string involving stating how many months have passed.
10:16:49 <FliPPeh> I just wanted to do as much calculation by the time functions as possible
10:17:15 <roconnor> maltem: months, days, hours, minutes, seconds
10:17:26 <FliPPeh> More precisly, render the system uptime to "[months, ]days, hours, minuts, seconds"
10:17:31 <FliPPeh> But let's skip the month part
10:17:31 <roconnor> maltem: the trouble is that the number of months passed in a difftime is not well defined.
10:18:06 <maltem> I got that part about the month, I was wondering about the meat of the question. Using divMod isn't exactly hard
10:18:13 <zygoloid> FliPPeh: it sounds like you have a number of seconds which is the amount of time between some point in time and /now/.
10:18:47 <FliPPeh> zygoloid: Yes
10:18:50 <dmwit> FliPPeh: You could have written the code in the time you've been complaining since our original suggestion.
10:19:19 <FliPPeh> I'm not complaining!
10:19:33 <FliPPeh> I would be an ass for complaining about help
10:19:44 <zygoloid> FliPPeh: in that case, the conversion to seconds/minutes/hours/days/months/years is meaningful and sensible
10:19:51 <ddarius> FliPPeh: That doesn't stop other people...
10:20:12 <dmwit> So, here's our help. Get the current time, compute the time x seconds ago, and use arithmetic (along with the fromGregorian function) to get the number of months, days, and so forth that have passed.
10:21:41 <FliPPeh> maltem: I didn't know about divmod, makes converting seconds to minutes:seconds really much more trivial than it has been before
10:21:52 <FliPPeh> Nice stuff
10:22:12 * hackagebot macho 0.21 - Parser for Mach-O object format.  http://hackage.haskell.org/package/macho-0.21 (ErikCharlebois)
10:22:41 <roconnor> @type difMod
10:22:42 <lambdabot> Not in scope: `difMod'
10:22:44 <roconnor> @type divMod
10:22:45 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
10:22:57 <FliPPeh> > divMod 140 60
10:22:58 <lambdabot>   (2,20)
10:23:04 <roconnor> @hoogle (a -> a -> (a,a)) -> [a] -> [a]
10:23:05 <lambdabot> No results found
10:23:07 <roconnor> :(
10:23:35 <dmwit> :t first (`divMod` 24) . first (`divMod` 60) . (`divMod` 60)
10:23:36 <lambdabot> forall a. (Integral (a, a), Integral a) => a -> (((a, a), (a, a)), a)
10:23:44 <dmwit> whoops
10:23:52 <dmwit> :t first (first (`divMod` 24)) . first (`divMod` 60) . (`divMod` 60)
10:23:53 <lambdabot> forall a. (Integral a) => a -> (((a, a), a), a)
10:24:16 <dmwit> Oh, but days will be handled.
10:24:25 <roconnor> @hoogle (a -> a -> (a,a)) -> a -> [a] -> [a]
10:24:25 <lambdabot> No results found
10:24:39 <dmwit> :t unfoldr
10:24:40 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
10:24:45 <dmwit> roconnor: ?
10:24:53 <roconnor> dmwit: oh
10:24:57 <dmwit> :t scanr
10:24:58 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> [b]
10:26:07 <dmwit> err... I guess scanl is typically the one you want
10:26:09 <roconnor> @type scanl
10:26:10 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
10:26:31 <roconnor> @type scanl1
10:26:32 <lambdabot> forall a. (a -> a -> a) -> [a] -> [a]
10:26:49 <FliPPeh> Now I get the UTCTime
10:27:01 <FliPPeh> The actual day of the year and time since midnight..
10:27:38 <FliPPeh> Now I'd just need to create UTCTime out of seconds
10:27:54 <dmwit> FliPPeh: eh? why? how?
10:28:04 <dmwit> FliPPeh: What would "0s" be as a UTCTime?
10:28:17 <FliPPeh> dmwit: The first date in epoch
10:28:24 <FliPPeh> Wait no
10:28:27 <FliPPeh> Some day at midnight.
10:28:41 <dmwit> you could
10:28:45 <FliPPeh> Aw meh, I hate time.
10:29:08 <dmwit> parseTime "January 1, 1970" + 32 -- to get 32 seconds after epoch
10:29:12 <dmwit> But again... why?
10:29:16 <pastorn> FliPPeh: System.Time! IT'S DA OSSUMZ
10:29:29 <FliPPeh> pastorn: Nah, this is a challenge.
10:29:29 <dmwit> This suggests that you are Doing Something Wrong again.
10:29:30 * pastorn doesn't care about correctness at all
10:29:32 <FliPPeh> I can't give up now
10:30:01 <FliPPeh> dmwit: I'm not exactly doing anything right now, just looking for a concept.
10:30:18 <dmwit> ...what concept?
10:30:52 <FliPPeh> I have no idea.
10:31:02 <dmwit> :t getUTCTime
10:31:03 <lambdabot> Not in scope: `getUTCTime'
10:31:06 <dmwit> err
10:31:08 <dmwit> :t getCurrentTime
10:31:09 <lambdabot> Not in scope: `getCurrentTime'
10:31:14 <FliPPeh> :t Data.Time.getCurrentTime
10:31:15 <lambdabot> IO time-1.1.4:Data.Time.Clock.UTC.UTCTime
10:31:24 <FliPPeh> That one
10:32:20 <dmwit> :t fmap (Data.Time.Clock.addUTCTime 32) getCurrentTime -- 32 seconds in the future
10:32:21 <lambdabot> Not in scope: `getCurrentTime'
10:32:26 <FliPPeh> I can get a nominal difference, but the problem is, I have to use 2 UTC times
10:32:28 <dmwit> :t fmap (Data.Time.Clock.addUTCTime 32) Data.Time.getCurrentTime -- 32 seconds in the future
10:32:29 <lambdabot> IO time-1.1.4:Data.Time.Clock.UTC.UTCTime
10:32:42 <FliPPeh> But I have only an UTC time and seconds
10:32:46 <dmwit> :t fmap (Data.Time.Clock.addUTCTime (-32)) Data.Time.getCurrentTime -- 32 seconds in the past
10:32:47 <lambdabot> IO time-1.1.4:Data.Time.Clock.UTC.UTCTime
10:33:00 <FliPPeh> Hm.
10:33:03 <FliPPeh> That could just work
10:33:39 <dmwit> FliPPeh: You will likely need an extra fromIntegral in there if your count of seconds isn't a NominalDiffTime yet.
10:34:40 <FliPPeh> Alright, now I've got the system startup time
10:34:43 <FliPPeh> As UTC
10:34:53 <roconnor> do { x <- getCurrentTime; y <- getUptime; let onTime = addUTCTime (fromRational (-y)) x; let (onyyyy,onmm,ondd) = utctDay onTime; let (curyyyy,curmm,curdd) = utctDay x
10:37:08 <dmwit> Actually, now I'm a little confused. There doesn't seem to be a correct way to combine a DiffTime and a UTCTime, which is what you really have.
10:37:24 <FliPPeh> That's the problem I have been facing all the time
10:37:27 <roconnor> dmwit: addUTCTime
10:37:36 <dmwit> roconnor: That combines a NominalDiffTime and a UTCTime.
10:37:41 <roconnor> dmwit: don't use diffTime
10:37:44 <FliPPeh> I think I really have to avoid DiffTime alltogether and just calculate
10:38:00 <roconnor> that isn't appropriate here
10:38:02 <dmwit> roconnor: He's got a clock-count of seconds since his machine started. That's a DiffTime.
10:38:14 <dmwit> (not a NominalDiffTime)
10:38:31 <roconnor> dmwit: fromRational (or from Integral) will convert seconds to a nominal diff time
10:38:50 <dmwit> roconnor: ...
10:38:51 <roconnor> dmwit: everyone almost always wants to work with nominalDiffTime
10:39:07 <Polarina> How do I catch an exception from Data.Binary.decode?
10:39:19 <dmwit> roconnor: That doesn't sound possible.
10:39:29 <roconnor> dmwit: why?
10:39:55 <roconnor> dmwit: presumably FliPPeh doesn't care about correctly accounting for leap seconds
10:39:56 <dmwit> roconnor: Two clock-seconds ago could be one nominal second ago or two nominal seconds ago, depending on what time it is now.
10:40:07 * dmwit cares
10:40:17 * hackagebot macho 0.22 - Parser for Mach-O object format.  http://hackage.haskell.org/package/macho-0.22 (ErikCharlebois)
10:40:28 <FliPPeh> It's not that I don't care, but if it's too much effort, I'd rather stick with days as maximum resolution
10:40:28 <dmwit> If you really want to do this *correctly*, is it possible?
10:40:34 <roconnor> dmwit: in that case you need to use a leapsecond table
10:40:57 <dmwit> roconnor: Yes, the library should provide a way to do this, but doesn't. Are we agreed?
10:41:05 <ddarius> Isn't there a TAI package that handles this.
10:41:08 <dmwit> Or is there something in the library for this that I'm missing?
10:41:15 <roconnor> http://hackage.haskell.org/packages/archive/time/1.1.3/doc/html/Data-Time-Clock-TAI.html#v:addAbsoluteTime
10:41:36 <dmwit> Marvelous.
10:41:37 <roconnor> dmwit: addAbsoluteTime will add a diff time to an absoulte time
10:41:53 <roconnor> then taiToUTCTime :: LeapSecondTable -> AbsoluteTime -> UTCTime
10:41:58 <bpb> hello
10:42:08 <roconnor> and the reverse: utcToTAITime :: LeapSecondTable -> UTCTime -> AbsoluteTime
10:42:14 <bpb> are there any disadvantages to Hindley-Milner type inference?\
10:42:23 <roconnor> dmwit: but I'm pretty sure FliPPeh would rather ignore leap seconds
10:42:27 <dmwit> bpb: It doesn't do dependent types! ;-)
10:42:33 <dmwit> roconnor: likely, yes
10:42:56 <bpb> dmwit: dependent types in a sentance = ?
10:43:00 <roconnor> dmwit: under the hood AbsoluteTime is just a newtype for DiffTime :D
10:43:03 <FliPPeh> It's no live-or-death situation, if it is indeed this hard, just drop the topic, I'll stick with days :)
10:43:10 <dmwit> bpb: Types that are indexed by values.
10:43:15 <roconnor> FliPPeh: use nominalDiffTime
10:43:17 <FliPPeh> But you've really helped me so far
10:43:21 <dmwit> bpb: e.g. the type of lists with a prime length
10:43:54 <dmwit> FliPPeh: If you don't care about leap seconds, using NominalDiffTime is good enough. =)
10:44:01 <bpb> dmwit: can't HM be extended for such?
10:44:10 <roboshibby> hey guys, what would a loop look like in haskell please?
10:44:27 <dmwit> bpb: Nope, even type-checking (some) fully-annotated dependently-typed languages is undecidable.
10:44:43 <FliPPeh> roboshibby: forever a = do a; forever a
10:44:49 <dmwit> roboshibby: map or foldr
10:44:52 <dmwit> or filter
10:44:54 <dmwit> :t map
10:44:55 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
10:44:58 <dmwit> :t foldr
10:44:59 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
10:45:04 <dmwit> :t filter
10:45:05 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
10:45:15 <roboshibby> dang
10:45:20 <roboshibby> wtf is that? looks complicated
10:45:30 <dmwit> roboshibby: No, it's not complicated. =)
10:45:39 <FliPPeh> roboshibby: Are you sure you need a loop?
10:45:44 <dmwit> roboshibby: "map" is a function that applies another function to each element of a list.
10:45:47 <FliPPeh> Most stuff can be done without explicitly looping
10:45:59 <quicksilver> ehem.
10:46:18 <dmwit> roboshibby: "filter" is a function that keeps only the elements of a list that satisfy some condition.
10:46:21 <quicksilver> people, people, roboshibby is a guy who comes in here every few days and trolls amusingly about what haskell can and can't do, normally loops.
10:46:26 <roboshibby> filter, nice
10:46:30 <dmwit> roboshibby: Those two already cover most uses of loops in the real world.
10:46:35 <roboshibby> i am?
10:46:36 <bpb> dmwit: wow. what's the practicality of dependent types then.. esp if they're undecidable in fully-annotated languages?
10:46:36 <quicksilver> you're welcome to play with him if you like, but be aware you're being played...
10:46:52 <FliPPeh> I HAVE BEEN ABUSED
10:47:00 <FliPPeh> I think I can never carelessy offer my help anymore
10:47:01 <FliPPeh> :(
10:47:05 <dmwit> quicksilver: Huh, thanks for the heads-up.
10:47:25 <dmwit> bpb: Well, they're pretty handy for proving things.
10:47:39 <dmwit> bpb: And they can express much tighter constraints on your data, which often comes in handy.
10:47:44 <lament> haskell can't do loops?!?!?
10:47:57 <FliPPeh> Critism about Haskell is okay, but trollers should be punched
10:47:58 <roboshibby> dmwit, so filter is like an accumulator. that's very nice
10:48:03 <lament> i've been coding in haskell all this time and i didn't know
10:48:07 <lament> what the hell, i quit
10:48:07 <FliPPeh> Even I sometimes have doubts about Haskell being good for what I'm trying
10:48:18 <FliPPeh> But hey, I've always proven right with Haskell
10:48:28 <bpb> dmwit: so great for proofs and modeling, but no real benefit to your everyday SDE..?
10:48:34 <FliPPeh> lament: Don't give up!
10:48:42 <roconnor> FliPPeh: haskell is good for what you want.  Other libraries would ignore all this complexity about time and just silently screw you over
10:48:43 <mtnviewmark> Oh Noes!!! Haskell kant d0 l00pz!??!?  -- I guess I should through out my totally working, web service built in Haskell that outperforms the Python version 6x......  :-)
10:48:44 <dmwit> roboshibby: What are you trying to do? The more specific you are, the better we can help you. =)
10:48:49 <lament> what the hell i don't want to use a language without loops
10:48:51 <Raynes> ((((()))))
10:48:59 <dons> mtnviewmark: :D
10:49:12 <dons> loops are so retro, they're cool again!
10:49:19 <dons> for (;;) ever!!
10:49:20 <bpb> What else sucks about Hindley-Milner type inference?
10:49:29 <mtnviewmark> loop me, Amadeus!
10:49:32 <roconnor> FliPPeh: do { x <- getCurrentTime; y <- getUptime; let onTime = addUTCTime (fromRational (-y)) x
10:49:34 <dons> milner's not around to fix bugs ? not maintained!!
10:49:37 <roboshibby> dmwit, nothing specific. i just wanted to grasp how a functional language handles looping
10:49:46 <roconnor> FliPPeh: or fromInteger
10:49:59 <dmwit> roboshibby: Start coding something. You'll find out quickly enough. =)
10:50:01 <roboshibby> quicksilver's slander against me was correct in only 1 way, i come in from time to time inquiring of haskell
10:50:04 <bpb> dons: hahaha... sniff... tear...
10:50:29 <FliPPeh> roconnor: I have been trying fromIntegral
10:50:33 <lament> haskell has strange loops
10:50:34 <dons> roboshibby: http://stackoverflow.com/questions/2342864/efficient-recursion-in-functional-programming-vs-inefficient-recursion-in-differ/2343325
10:50:35 <FliPPeh> All those fromX confuse me :(
10:50:39 <mtnviewmark> Oh noes - H-M doesn't force me to write types all over my program? But Java and C++ taught me that that was what good programmers did!   Dang, another nail in the coffin!
10:50:43 <roboshibby> dons, reading
10:50:52 <roconnor> FliPPeh: ok
10:50:58 <roconnor> FliPPeh: do { x <- getCurrentTime; y <- getUptime; let onTime = addUTCTime (fromIntegral (-y)) x
10:51:03 <dmwit> bpb: uh?
10:51:20 <dmwit> bpb: If we thought it sucked, why would we be in here?
10:51:25 <FliPPeh> Thanks roconnor :)
10:51:29 <dons> roboshibby: in short, instead of ad hoc loop control keywords (for, while, do), FP langs have a more general mechanism: general recursion
10:51:40 * mtnviewmark is in a fine fettle this morning...
10:51:52 <dmwit> FliPPeh: :t getUptime -- ?
10:51:57 <roboshibby> dons, dang that is very cool
10:52:03 <bpb> dmwit: Ok.  Not what sucks, but what can't it express?  Are there better semantics or formalisms of type inference?
10:52:13 <roboshibby> dons, in that vein, how would you define "general recursion" ?
10:52:13 <FliPPeh> dmwit: "uptime :: IO (Maybe Int)"
10:52:20 <FliPPeh> Because it's doing File IO, it could fail
10:52:35 <lament> bpb: type classes!
10:52:45 <FliPPeh> :w
10:52:51 <FliPPeh> whoops, should go to vim.
10:52:53 <dmwit> FliPPeh: y <- getUptime; let onTime = fmap (addUTCTime . fromIntegral . negate) y
10:53:04 <lament> bpb: haskell has an enormous variety of type system extensions, presumably because without extensions the type system sucks
10:53:14 <dmwit> FliPPeh: (where fmap :: (a -> b) -> (Maybe a -> Maybe b))
10:53:17 <mtnviewmark> and, roboshibby, also important is that the ease of higher-order-functions lets modules provide domain specific control structures that are more powerful and *safer* than those available in imperative languages.
10:53:22 <lament> bpb: but type classes are the main one, as compared to plain vanilla HM
10:53:45 <roconnor> FliPPeh: then you have to compute the number of years, months, days etc between the two time.  As far as I know there is no library function for this, so you will have to write your own.
10:53:47 <bpb> lament: is there some summary of these extensions?  Why does standard HM suck?  It seems pretty simple and useful.
10:53:49 <roboshibby> hm
10:53:49 <roconnor> FliPPeh: it will be tricky
10:54:04 <dons> roboshibby: http://en.wikipedia.org/wiki/Recursion#Functional_recursion
10:54:11 <dmwit> roconnor: there's fromGregorian
10:54:11 <roboshibby> reading
10:54:14 * dmwit feels like a broken record
10:54:22 <roconnor> dmwit: yes, but it is still tricky
10:54:27 <dmwit> Really?
10:54:27 <lament> bpb: i don't know, google for haskell type system extensions
10:54:40 <mtnviewmark> for example, I can write a Database connection pool module that provides   the control structures   "withPool" and "withConnection"  --
10:54:50 <roconnor> dmwit: ya you want to covert both to y/m/d/h/m/s formats
10:54:50 * mtnviewmark pulls out real-world example he just coded
10:54:51 <roboshibby> dons, aha!
10:55:06 <roconnor> dmwit: then you want to run the standard subtraction algorithm with borrowing
10:55:22 <dmwit> Mmm, yeah, that's annoying.
10:55:31 <roconnor> dmwit: the tricky bit is that when you borrow some number of days from the months, how many days do you borrow!
10:55:38 <dmwit> I wonder if Ashley would accept a patch adding some convenience functions to time.
10:56:01 <roboshibby> dons, thank you for the pointers
10:56:20 <roconnor> dmwit: it is sort of clear but a bit of a pain
10:57:27 <dmwit> julianMonthLength tells the answer, and yes, I agree that is a bit of a pain
10:57:49 <sepp2k> dmwit: Shouldn't "Types that are indexed by values." be "Types that are indexed by *run-time* values"? Otherwise C++ would be a dependently typed language.
10:58:03 <roconnor> dmwit: Don't you want monthLength
10:58:23 <dmwit> err
10:58:26 <roconnor> dmwit: oh, julian and geogrian month lengths are the same
10:58:29 <dmwit> I may have meant gregorianMonthLength.
10:58:35 <roboshibby> have a nice day everyone
10:58:41 <FliPPeh> Heh, I managed "getSystemStartDate"
10:58:45 <FliPPeh>  getSystemStartDate
10:58:46 <FliPPeh> Just 2010-02-02 14:37:04.832757 UTC
10:58:49 <dmwit> Anyway, monthLength looks like just a tad more annoying to use than *monthLength.
10:59:12 <dmwit> sepp2k: But... C++ *is* dependently typed.
11:00:05 <dmwit> sepp2k: And no, I certainly don't mean run-time values.
11:00:41 <dmwit> or... I guess another way to say it is that I'm not sure I understand the difference between run-time and compile-time values with respect to dependently-typed languages.
11:00:50 <sepp2k> dmwit: Are you sure that's the official definition? Because that really doesn't feel right to me.
11:03:08 <FliPPeh> Ahh, locales
11:03:19 <dmwit> sepp2k: I think that's a pretty standard way to say it. You can, of course, get much more precise.
11:03:38 <dmwit> e.g. you can say where on the lambda cube you are =)
11:05:14 <fax> @seen FunctorSalad
11:05:14 <lambdabot> Unknown command, try @list
11:05:22 <medfly> preflex, seen functorsalad
11:05:22 <preflex>  functorsalad was last seen on #haskell-blah 18 days, 20 hours, 27 minutes and 4 seconds ago, saying: yes, I've heard "explicit is better than implicit" before. python?
11:06:24 <FliPPeh> I wonder, does "Show" respect system locales? Or other "numberToString" converting functions? Like for german locales, render floats as "3,14" instead of "3.14"?
11:06:41 <dons> no. but nice idea.
11:06:42 <medfly> I seriously doubt that
11:06:49 <sepp2k> dmwit: I meant a definition that has C++ as a dependently typed language doesn't feel right to me.
11:06:56 <dons> esp. given "3,14" isn't valid haskell syntax for numbers
11:07:05 <FliPPeh> Even C can do that :x
11:07:08 <sepp2k> Though that's kinda arguing backwards, I admit.
11:07:13 <dons> so it would break the "paste (show x) == x" property
11:07:23 <dons> FliPPeh: well certainly there are libraries for locale aware showing
11:07:26 <dons> just not Show.
11:07:35 <fax> sepp2k I thik he's joking
11:07:36 <FliPPeh> Alright
11:09:48 <dmwit> sepp2k: I assume we've been talking about template metaprogramming all along, right? That's dependent typing...
11:09:59 <sepp2k> We were yes.
11:11:47 <sepp2k> I thought that C++ was not dependently typed because which you can define a fixed-size array which can not be accessed out-of-bounds, this array could also not be indexed with values that are not determinable at run-time.
11:12:13 <fax> "not determinable at /compile/-time" ?
11:12:14 <FliPPeh> @src divMod
11:12:14 <lambdabot> Source not found. Maybe you made a typo?
11:12:20 <sepp2k> fax: Right.
11:12:21 <dmwit> They can't be indexed by values that are semantically "IO Int"s, yes.
11:12:28 <dmwit> But I wouldn't expect that to be possible anyway, would you?
11:12:35 <Vanadium> Does gtk2hs come with wrappers for glib's network IO mechanims?
11:12:38 <Vanadium> io channels?
11:12:52 <FliPPeh> I think not
11:12:53 <fax> it's not dependent types it's just sufficently confusing preprocessing
11:13:00 <FliPPeh> It's just a GUI binding
11:13:04 <FliPPeh> Not a glib abstraction
11:13:27 <dcoutts> Vanadium: it's better to use the existing Haskell modules for that
11:13:31 <medfly> @index divMod
11:13:31 <lambdabot> Prelude
11:13:32 <sepp2k> dmwit: In certain cases, I would. n = user_input; arr = Array(n); i = n-1; arr[i]  <-- There probably is a language where this typechecks, but "i = n+1" would not.
11:13:43 <kmc> i wish C++ templates were only preprocessing
11:13:46 <Vanadium> They did not seem to integrate with the glib mainloop that well. Oh, well.
11:13:52 <kmc> they are actually something complicated and much worse
11:13:58 <fax> '1' isn't a value to the C++ metaprogrammer, it's just a formal symbol
11:14:11 <sepp2k> I mean there's a reason that dependent type checking == theorem proofing, right?
11:14:25 <kmc> dependent type checking is proof verification
11:14:28 <fax> sepp2k == proof checking,  theorme proving is the bit where you write the program
11:14:37 <fax> (or the computer writes it)
11:14:43 <sepp2k> Right.
11:14:52 <kmc> theorem proving is like what djinn does
11:15:02 <kmc> djinn is a theorem prover for propositional logic
11:15:13 <kmc> @djinn (a -> b) - > (b -> c) -> (a -> c)
11:15:13 <lambdabot> Cannot parse command
11:15:19 <kmc> @djinn (a -> b) -> (b -> c) -> (a -> c)
11:15:19 <lambdabot> f a b c = b (a c)
11:16:23 <dmwit> Anyway, I guess I'm willing to pull back a little bit and say that a *subset* of C++ is dependently-typed.
11:17:08 <dmwit> Or that compiling C++ involves dependent type-checking as a part of the problem, or some such statement.
11:17:09 <mtnviewmark> quasi-quote is nice, but it makes my build logs ugly....
11:17:21 <mtnviewmark> any way to get ghc to stop putting out "Loading package ...."?
11:17:33 <dmwit> mtnviewmark: grep ;-)
11:17:57 <mtnviewmark> well - I'm typing "cabal build" on the command line ---- and yes I could script a wrapper w/grep...
11:17:59 <aavogt> that's what happens whenever you use libraries
11:18:23 <mtnviewmark> but would rather find a way to make it do it all the time -- for all users who will build my stuff with cabal
11:18:56 <dcoutts> mtnviewmark: that's a ghc "feature", file a ticket there.
11:19:02 <mtnviewmark> heh! okay
11:19:56 <ozataman> Hey all.. when you get an error like "Prelude.(!!): index too large" and there is no !! used in your source code, what is the best way to track down which underlying library is using the method?
11:20:23 <fax> C++ type checking does beta-conversion in the template parameters?
11:20:24 <mtnviewmark> meanwhile - just to share my joy: I've got a parser and verifier for an interface description language hooked up with QuasiQuote --- so my web services have the IDL description written in-line, and then get their inputs/outputs validated during operation --- and it is very nice looking in code!
11:20:36 <pikhq> fax: Yes. Yes it does.
11:20:45 <fax> what's with the double yes
11:20:58 <pikhq> "template <typename t>" == \t->
11:21:45 <maltem> ozataman, try to compile with -prof and run with +RTS -xc
11:22:36 <maltem> Not guaranteed to spit out something useful, but maybe, if you're lucky
11:23:24 <ozataman> maltem: thanks, I'll give it a shot
11:24:30 <ozataman> maltem: it doesn't compile with -prof. says: Perhaps you haven't installed the profiling libraries for package `HDBC-2.2.3'?
11:26:20 <mtnviewmark> oh dear - you need to have installed all the pacakges with profiling enabled
11:26:23 <maltem> ozataman, cabal install hdbc --enable-library-profiling --reinstall. And if you suspect the fault is in that library, maybe there are further useful profiling-related options to pass
11:26:25 <gwern> 'The Help Desk is unable to provide the same level of support for the Linux community because there are so many Linux operating system packages available.
11:26:28 <gwern> Hopefully, your Linux installation package came with a modem driver and dialer. If it did not, we suggest you search your Linux publisher's web site for driver and dialer downloads. You may also want to use your favorite search engine (e.g., Google, Yahoo, etc.) to search for the appropriate driver and dialer for your operating system. '
11:26:34 <gwern> well, at least they're polite
11:26:51 <mtnviewmark> or set this in your .cabal/config file:   library-profiling: True
11:27:06 <gwern> mtnviewmark: I could only advise that if base had been installed with profiling
11:27:06 <maltem> ozataman, and yes, eventually you'll have to reinstall all packages that you use with profiling support enabled :(
11:27:07 <mtnviewmark> and then cabal install --reinstall X for each package X that gives you this error
11:27:16 <gwern> mtnviewmark: otherwise you're cruising for a bruising
11:27:25 <gwern> reinstalling base is a bad idea
11:27:28 <mtnviewmark> I don't understand -
11:27:33 <mtnviewmark> ah yes
11:27:34 <mtnviewmark> BUT
11:27:39 <mtnviewmark> it won't give you that error for base
11:27:45 <gwern> mtnviewmark: it's a rhyme, a rhetorical technique intended to aid memory
11:27:45 <mtnviewmark> for reasons I don't understand
11:28:12 <mtnviewmark> thanks, I got the phrase - not what the bruise he was in for
11:28:28 <ozataman> Thanks guys, reinstalling now
11:28:35 <gwern> mtnviewmark: linking against conflicting versions; iirc 'diamond dependency problem'
11:28:42 <mtnviewmark> to compile the program with -prof, ozataman will need to ahve every user installed package compiled with -prof
11:28:56 <MisterN> is this pattern popular? a data (let's say data D) which contains no actual members but just functions which return something like (D, a)
11:29:13 <opqdonut> that
11:29:20 <mtnviewmark> as long as they are --reinstalled with teh same version (mention it expressly on the command line)
11:29:24 <mtnviewmark> everything will be fine
11:29:25 <opqdonut> 's a straightforward way of emulating objects
11:29:32 <Cale> MisterN: How are those not actual? :)
11:29:32 <aavogt> MisterN: that's risky because you can accidentally take the first element of the tuple
11:29:46 <Cale> aavogt: ?
11:29:46 <mtnviewmark> and, for reasons I don't understand, ghc won't require base to ahve profileing versions
11:29:49 <opqdonut> aavogt: ?
11:29:54 <MisterN> aavogt: with record syntax i mean :)
11:29:55 <aavogt> if data D   is an empty data declaration, then it's undefined
11:30:01 <MisterN> Cale: uh of course they're actual :)
11:30:17 <aavogt> or do you mean that  data D = D?
11:30:35 <Cale> functions make perfectly good record members
11:30:36 <maltem> mtnviewmark, you'd think that a ghc install comes with a profiling base by default
11:30:41 <MisterN> aavogt: naah i mean something like data D = D { f :: Int -> (Int, D); f2 -> Int -> D }
11:30:51 <mtnviewmark> I don't know.... perhaps it doe
11:30:53 <mtnviewmark> it does
11:30:58 <MisterN> Cale: yeah but is this popular?
11:31:01 <Cale> MisterN: That's common enough.
11:31:05 * aavogt interpreted "contains no actual members" as has no non-bottom values  like    "data D\n"
11:31:12 <MisterN> isn't it considered too oo-like? :)
11:31:22 <Cale> MisterN: It's closely related to my interpretation of OO
11:31:34 <Cale> But sometimes that's exactly what you're after.
11:31:37 <mtnviewmark> ghc-pkg
11:31:42 <Cale> http://cale.yi.org/index.php/A_look_at_OO_from_Haskell
11:31:46 <ozataman> mtnviewmark, maltem: will installing with profiling support slow down all my programs even without the -profile flag?
11:31:59 <aavogt> opqdonut, Cale: does that make sense now?
11:32:00 <mtnviewmark> no, it installs BOTH versions
11:32:12 <MisterN> Cale: ultimately every good language allows you to write your code in OO style :)
11:32:13 <dmwit> MisterN: It happens, sometimes, but the more common thing is
11:32:18 <mtnviewmark> so your -prof compiles use the p_o versions, and the non-profiling versions use the o
11:32:37 <MisterN> dmwit: yes?
11:32:39 <dmwit> MisterN: data D = D { a :: Int, b :: Int }; f :: D -> D; g :: D -> D
11:32:42 <mtnviewmark> but heed the warning about -reinstalling the same versions you already have
11:32:45 <mtnviewmark> not the "latest"
11:32:56 <dmwit> MisterN: where 'f' and 'g' munch 'a' and 'b', respectively
11:33:03 <MisterN> dmwit: well that's just a normal record :)
11:33:03 <mtnviewmark> and you'll end up having to follow the list of dependencies recursively yourself
11:33:07 <ozataman> maltem: +RTS -xc doesn't help much.. still only gives me the index too large error
11:33:10 <dmwit> MisterN: Yes, exactly. =)
11:33:17 <Cale> It depends on how you expect to extend things.
11:33:22 <gavino> can haskell use multiple core with user level threads?
11:33:32 <mtnviewmark> in otherwords, doing that for HDBC will probably fail at the last link step because something IT depends on doesn't have profiling....
11:33:36 <MisterN> dmwit: but the cool thing about having the functions inside the record is that you can replace them at runtime
11:33:49 <mtnviewmark> so you do that one, then redo HDBC (you can put them on the same command line) and then.....
11:33:52 <dmwit> MisterN: Yes. The alternative is
11:33:52 <mtnviewmark> .... recursively
11:33:56 <jlouis> gavino: yes, GHC can. Look at the -N +RTS option
11:34:04 <maltem> ozataman, :(
11:34:04 <kmc> gavino, yes, Haskell programs compiled with GHC can fork millions of lightweight Haskell-level threads, which are mapped onto a configurable number of OS threads (usually, one per core)
11:34:05 <Cale> If you have more expected need to extend the set of operations that act on the data, then the "algebraic" approach that dmwit suggested is better.
11:34:08 <MisterN> Cale: your site doesn't load :(
11:34:10 <dmwit> MisterN: f :: Foo -> D -> D
11:34:14 <mtnviewmark> SoC project: Make cabal have an option to do --reinstall-same-version recursively!
11:34:22 <Cale> MisterN: Oh, that's odd. I'll check my DNS record.
11:34:28 <dmwit> Well, there's a lot of options, I guess.
11:34:36 <kmc> gavino, what's more, you can write programs that do work on multiple cores (but have the semantics of single-threaded programs) without thinking about threads at all
11:34:36 <dmwit> Anyway, there's certainly nothing wrong with what you suggest.
11:34:46 <maltem> mtnviewmark, better yet, have it track profiling
11:35:00 <aavogt> mtnviewmark: just nuke your ~/.cabal and ~/.ghc-pkg, then reinstall your packages
11:35:04 <kmc> gavino, see http://donsbot.wordpress.com/2009/09/05/defun-2009-multicore-programming-in-haskell-now/
11:35:12 <mtnviewmark> well - and I want it to do all that and remember which packages I installed --user and which --global
11:35:19 <mtnviewmark> and maintain that during --reinstall!!!
11:35:23 <Cale_> hmm, how about now?
11:35:46 <fax> hi Cale
11:36:13 <MisterN> Cale: now it works
11:36:57 <MisterN> Cale: ah, that's precisely what i thought about
11:37:20 <MisterN> at least the first part
11:37:32 <Cale> (was just the stupid cheap router with no ability to keep track of IP/MAC-address mappings)
11:41:10 <MisterN> Cale: hmm what's that? data SomePointSet where SPS :: (PointSet t) => t -> SomePointSet
11:42:09 <Cale> MisterN: It's an existential type written in GADT syntax.
11:42:51 <Cale> So a value of type SomePointSet looks like  SPS x  where x is of an unknown, arbitrary type which is guaranteed to support the PointSet operations and nothing else.
11:42:52 <MisterN> Cale: you could also have told me that it's a gauntlet in banana syntax
11:43:35 <HugoDaniel> any atempts at real-time raytrace with haskell ?
11:43:53 <MisterN> Cale: oh wait, this is haskell's "any-type"?
11:43:53 <jmcarthur> i don't know of any real time attempts
11:44:06 <jmcarthur> HugoDaniel: if you find any report back and let me know plz
11:44:20 <kmc> MisterN, not *any*, that would be SPS :: forall t. t -> SomePointSet
11:44:21 <jmcarthur> :)
11:44:25 <MisterN> Cale: you can put every type that supports PointSet operations into SPS x and get back the fixed type SomePointSet?
11:44:31 <kmc> MisterN, correct
11:44:44 <MisterN> wow that sounds like it's extremely powerful
11:44:51 <jmcarthur> MisterN: correct, but then you lose its concrete type
11:44:54 <kmc> and when you pattern match on the SPS constructor, you get access to the PointSet methods for whatever,s inside, even though you don't know the specific type still
11:44:55 <MisterN> also probably should be avoided
11:44:56 <jmcarthur> it's not as powerful as it sounds
11:44:57 <jlouis> GADTs are extremely powerful
11:45:12 <MisterN> but it only works when you enable language extensiosn?
11:45:13 <jmcarthur> it's useful
11:45:15 <kmc> MisterN, yes
11:45:16 <jmcarthur> yes
11:45:24 <Cale> MisterN: It's safe. There's no potential for bad downcasts like there is in OO languages.
11:45:36 <kmc> if you want that, use Data.Dynamic :)
11:45:38 <jmcarthur> GADTs are more powerful than ExistentialQuantification alone
11:45:45 <MisterN> Cale: but it still loses type information
11:45:55 <MisterN> Cale: but i guess when you need type erasure, it's ok
11:46:00 <kmc> MisterN, yes, just as calling "map" loses the information of what type is in your list
11:46:02 <Cale> MisterN: Well... yes, but not much more than you could lose by hand.
11:46:02 <kmc> exactly
11:46:30 <Cale> MisterN: You could also just store a tuple consisting of pre-applied PointSet operations.
11:46:40 <Cale> MisterN: In most cases, anyway.
11:46:49 <Cale> (There are some cases where you couldn't do this.)
11:47:19 <MisterN> Cale: how does it work? does the existential type store the operations that it supports in closures?
11:47:38 <kmc> MisterN, operationally, yes
11:47:44 <Cale> Just carries the typeclass dictionary along.
11:47:50 <jmcarthur> actually, i'm curious about the cases where it wouldn't be possible to just store preapplied ops
11:48:00 <jmcarthur> i've seen examples, but i always forget them
11:48:05 <kmc> MisterN, operationally, GHC and most other Haskell compilers implement typeclass constraints by turning them into an explicit record of typeclass operations
11:48:08 <FliPPeh> Is there a built in function to channel tuples (e.g. (a,b) -> (b -> (c,d)) -> (c,d)) ?
11:48:16 <FliPPeh> Or will I have to come up with something myself?
11:48:18 <kmc> that's what'd be stored in your existential
11:48:40 <MisterN> kmc: cool stuff
11:48:47 <MisterN> will existentials be in haskell prime? :)
11:48:48 <jmcarthur> FliPPeh: the type you just gave is pretty simple to express as a point free function i think
11:48:50 <danderson> so, what's the non-STM equivalent of Control.Concurrent.STM.TVar ?
11:48:56 <kmc> MisterN, Haskell Prime is a process, not a particular language
11:49:03 <dmwit> :t \ab btocd -> btocd (snd ab)
11:49:03 <kmc> they're not in Haskell 2010; they might be in 2011?
11:49:04 <FliPPeh> jmcarthur: Yup, but I didn't want to reinvent the wheel :)
11:49:04 <lambdabot> forall a b t. (a, b) -> (b -> t) -> t
11:49:05 <danderson> I see MVar vs. TMVar, but no equivalent to TVar
11:49:12 <kmc> danderson, IORef probably
11:49:13 <ozataman> anyone have any idea why Takusen would install without any of its database backends?
11:49:17 <jmcarthur> :t \f -> f . snd
11:49:18 <lambdabot> forall a b a1. (a -> b) -> (a1, a) -> b
11:49:18 <kmc> inconsistent naming :(
11:49:20 <dmwit> ?pl \ab btocd -> btocd (snd ab)
11:49:20 <lambdabot> flip id . snd
11:49:22 <MisterN> kmc: well it's a (possibly) infinite sequence of haskell specifications :)
11:49:33 <jmcarthur> yeah that
11:49:46 <MisterN> and "it's in haskell prime" means that there's some specification in that sequence which supports it
11:49:49 <dmwit> FliPPeh: Perhaps you're thinking of State?
11:49:51 <dmwit> ?unmtl State s a
11:49:52 <lambdabot> s -> (a, s)
11:50:26 <kmc> MisterN, fair enough
11:50:27 <FliPPeh> dmwit: Nope, I want to write a more elegant "seconds to h:m:s" converter, using divMod, which returns a tuple
11:50:31 <kmc> MisterN, then the answer is probably "yes"
11:50:38 <MisterN> kmc: good
11:50:45 <kmc> MisterN, they are a popular and useful extension in GHC, which is already used in parts of GHC's standard library
11:50:48 <dmwit> FliPPeh: Check out Control.Arrow, it's got some handy stuff.
11:50:49 <dmwit> :t first
11:50:50 <kmc> e.g. the extensible exceptions stuff
11:50:50 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
11:50:58 <dmwit> urgh
11:51:06 <kmc> existentials are often used to make a sort of "open variant" type that users can add additional cases to
11:51:18 <dmwit> first :: Arrow (~>) => (b ~> c) -> ((b,d) ~> (c,d))
11:51:25 <MisterN> kmc: basically the same as OO :)
11:51:32 <kmc> yes
11:51:45 <jmcarthur> yeah, EQ allows a lot of OO-like ideas
11:51:46 <MisterN> you can do it without existential types
11:51:51 <kmc> but it's not the only and simplest way to do it
11:51:54 <dmwit> and, in particular, instance Arrow (->), so
11:51:54 <MisterN> but it's possibly more convenient this way
11:52:05 <FliPPeh> I don't really understand the arrow stuff :/
11:52:05 <dmwit> first :: (b -> c) -> ((b, d) -> (c, d))
11:52:06 <MisterN> kmc: there's a more convenient way? do tell
11:52:08 <jlouis> MisterN: there is clearly some cross-pollination from OO-design principles and code style to other areas of type systems
11:52:16 <kmc> MisterN, well, if you don't need the variant to be open
11:52:16 * jmcarthur tends to not think of EQ as very convenient
11:52:22 <kmc> then you just use regular algebraic data
11:52:32 <kmc> which is not supported by most OO languages, though there's no clear reason for that
11:52:36 <MisterN> jlouis: nobody can't evade the fact that sometimes OO is the most useful design for some problem
11:52:40 <kmc> it's sort of supported by Scala
11:52:54 <jmcarthur> MisterN: that sounds a bit extreme
11:53:03 <MisterN> jmcarthur: why?
11:53:14 <jlouis> MisterN: I like to split the term OO into its type theoretic parts because people tend to regard OO as different things
11:53:18 <danderson> kmc: yeah, IORef sounds about right. Cheers.
11:53:30 <kmc> nobody can evade the fact that sometimes existential types are the most useful design for some problem ;)
11:53:40 <kmc> and i agree with jlouis, see http://www.paulgraham.com/reesoo.html
11:53:41 <MisterN> kmc: closed variants are actually quite popular in c++.
11:53:50 <kmc> MisterN, how so?
11:53:51 <MisterN> think boost::variant
11:54:07 <jmcarthur> MisterN: i'd say OO is sometimes convenient, but i wouldn't say that it's ever the most useful design. i'd be too afraid that there are even better solutions to make that claim
11:54:22 <jlouis> I've heard Erlang being called OO, C++ being called OO, Java being called OO, Python, Ruby, Smalltalk...
11:54:23 <jmcarthur> MisterN: i just don't like the words "can't" and "best," really :)
11:54:26 <jlouis> Lisp..
11:54:45 <MisterN> jlouis: well because ultimately OO is not a language feature but a matter of how you design your program
11:54:51 <jlouis> And it does tend to mean slightly different things, altough there are some recurring concepts
11:55:04 <MisterN> jmcarthur: well i guess you're too mathematically educated or something :D
11:55:05 <kmc> C++ is a *terrible* language for OO, it breaks some of the most basic principles
11:55:09 <FliPPeh> first snd ((1,2),3)
11:55:12 <FliPPeh> > first snd ((1,2),3)
11:55:13 <lambdabot>   (2,3)
11:55:14 <jmcarthur> hah, education
11:55:15 <FliPPeh> This is confusing
11:55:16 <kmc> MisterN, i had a C++ dev job and i was the only one who ever used boost::variant
11:55:29 <jmcarthur> more like uneducation
11:55:32 <MisterN> kmc: well sure most c++ devs don't use the cool stuff
11:55:45 <jmcarthur> education leads to certainty
11:55:55 <kmc> or boost::tuple, or boost::optional, or any of the other boost libraries that reimplement trivial bits of the Haskell standard library in thousands and thousands of lines of code
11:56:07 <jlouis> MisterN: luckily, you can do good design in most languages. Some concepts are just harder to force into some languages than others
11:56:07 <MisterN> kmc: i once used boost somewhere, and then when i was away for a month, somebody else stripped it out. i was sad
11:56:21 <dancor> FliPPeh: heh
11:56:30 <jmcarthur> MisterN: dude i hate it when people pull that crap
11:56:30 <FliPPeh> dancor: hehhh
11:56:39 <dancor> flipheh
11:56:48 <MisterN> jmcarthur: that's why i love open source
11:57:06 <FliPPeh> dancor: Yes?
11:57:13 <FliPPeh> ;o
11:57:14 <dancor> nothin
11:57:21 <dancor> n;othin
11:57:26 <FliPPeh> Whyyyyyy
11:57:34 <dancor> :t first snd
11:57:35 <lambdabot> forall a c d. ((a, c), d) -> (c, d)
11:57:40 <dancor> @unpl first snd
11:57:40 <lambdabot> first snd
11:57:42 <MisterN> dancor: ; is just syntactic sugar for newlines :)
11:57:54 <kmc> MisterN, i don't know, in the end i just found it depressing to learn all the fancy C++ tricks.  it's like learning to be an expert brainfuck programmer, it is an intellectual challenge but when you step back and look at the problem itself there's no clear reason it should be hard to begin with
11:58:14 <kmc> or rather, it was fun to learn the tricks but depressing to know them and use them repeatedly
11:58:19 <jmcarthur> kmc: well stated
11:58:41 <edwardk> jlouis: "Actually I made up the term "object-oriented", and I can tell you I did not have C++ in mind. " -- Alan Kay =)
11:58:49 <dancor> i feel like there are ppl who would say that about haskell perf techniques as well tho
11:58:52 <MisterN> kmc: oh, there is a whole set of reasons why c++ is the way it is.
11:58:55 <jlouis> edwardk: mm, exactly
11:59:01 <kmc> MisterN, i agree
11:59:06 <kmc> MisterN, some good and some bad
11:59:12 <jmcarthur> MisterN: reasons for existence are not excuses for using
11:59:15 <dancor> maybe it's more ok for perf to be hard black magic than for program structuring to be
11:59:30 <kmc> dancor, yes, that's a major weakness of Haskell
11:59:51 <dancor> sighface
11:59:51 <gwern> whew! I finally figured out the non-broken way to open PDFs in gnome from crontab
11:59:54 <gwern> '@daily eval `dbus-launch --sh-syntax --exit-with-session`; for file in ~/*.pdf; do evince $file; done'
12:00:14 <MisterN> jmcarthur: well, let's just say that i'd rather use c++ than c.
12:00:31 <jmcarthur> gwern: open all pdfs in your home folder, daily? why? so you don't forget them?
12:00:36 <kmc> MisterN, of course, it has some useful extensions.  every C++ programmer has their own subset of the language in mind when they say "C++"
12:00:39 <gwern> jmcarthur: so I do a little reading every day
12:00:52 <gwern> jmcarthur: like any sane person, I keep most of my pdfs somewhere in ~/doc
12:01:12 <gwern> most are there long-term, buried in doc/'s 14gb of stuff...
12:01:22 <kmc> MisterN, i quite like using C++ as a better C for small embedded software
12:01:25 <kmc> on AVR mainly
12:01:32 <edwardk> hrmm idle fiddling, stream fusion with skips works with exists a. (a -> a + f a, a) -- the dual construction forall a. (a + f a -> a) -> a becomes forall a. (a -> a) -> (f a -> a) -> a
12:01:57 <FliPPeh> Wow
12:02:00 <FliPPeh> I managed to use arrows to get H:M:S resolution
12:02:01 <MisterN> kmc: well the sad thing is that many people think that C were better than C++.
12:02:07 <FliPPeh> The output is just weird :)
12:02:29 <FliPPeh> > first (flip divMod 60) $ divMod 3720 60 -- one hours, 2 minutes, 0 seconds
12:02:30 <lambdabot>   ((1,2),0)
12:02:36 <ozataman> Why would a group of people design something complicated like HaskellDB and not even include 1-2 actual working examples for people to get started? This is extremely frustrating.
12:02:38 <edwardk> i hadn't made the connection that stream fusion was unfoldr/destroy fusion with an extra argument. i wonder if the same benefits can be accrued in foldr/build with the extra argumnt
12:02:47 <FliPPeh> > first (flip divMod 60) $ divMod 3745 60
12:02:48 <lambdabot>   ((1,2),25)
12:02:49 <kmc> MisterN, it's difficult to structure a big C project because it has so few features.  it's difficult to structure a big C++ project because it has so many features.
12:03:06 <kmc> they are both poorly suited to large scale software engineering for distinct reasons
12:03:21 <MisterN> kmc: i don't think the problem is that there are too many features, but that they're awkward to use
12:04:18 <kmc> C++ amplifies the disparities between bad and good programmers
12:04:19 <gavino> what are some big haskell programs that many use in production?
12:04:27 <FliPPeh> gavino: Xmonad
12:04:30 <gavino> linux is a big c program
12:04:32 <pikhq> kmc: It's more possible to structure a big C project well, though. You need to create your own structuring features, but it's certainly feasible.
12:04:36 <jmcarthur> C is a simpler language than C++ to generate, manipulate, pretty print, and/or compile using some other language. This is where I think it's strength really lies, nowadays, at least for me.
12:04:47 <kmc> xmonad isn't that big
12:04:50 <pikhq> It's much easier to add features to C than take features away from C++.
12:04:51 <gavino> could haskell ever do something like xorg
12:04:52 <gavino> ?
12:04:55 <Remy_> I'm getting a haskell related error message in cygwin when using cabal install
12:04:59 <kmc> gavino, parts of it probably
12:05:00 <jmcarthur> gavino: linux would be smaller written in haskell ;)
12:05:00 <Remy_> could someone take a look at it for me
12:05:03 <pikhq> gavino: GHC is rather large.
12:05:04 <FliPPeh> gavino: Why shouldn't it?
12:05:09 <gwern> gavino: sure. but people who have xorg sized problems already have codebases
12:05:12 <gavino> could you do an os in haskell?
12:05:16 <gavino> really?
12:05:17 <gavino> cool
12:05:18 <Remy_> http://old.nabble.com/Haskell%5Cbin-windres%3A-can%27t-open-temporary-file-%60%5C-cca08368.irc%27%3A-No-such-file-or-directory-to28032513.html#a28032834
12:05:19 <gwern> gavino: sel4
12:05:20 <kmc> gavino, they've done a toy one, called House
12:05:20 <Vulpyne> There's one called House.
12:05:21 <FliPPeh> gavino: It has been done already
12:05:26 <gavino> no kidding?
12:05:31 <jmcarthur> gavino: sel4 and house
12:05:32 <MisterN> jmcarthur: i guess using haskell to generate the linux kernel would be feasible?
12:05:37 <FliPPeh> gavino: It's called House, but it's just a proof-of-concept
12:05:41 <jmcarthur> gavino: well, they are kernels anyway
12:05:43 <Vulpyne> gavino: http://programatica.cs.pdx.edu/House/
12:05:53 <pikhq> MisterN: Haskell for code generation is quite feasible.
12:05:54 <FliPPeh> Should be improved :)
12:05:57 <thoughtpolice> pikhq: personally I like using C++ these days, but I religiously follow a few conventions to make my life easier.
12:05:59 <jmcarthur> gavino: and sel4 was rewritten in C. haskell was just used for formalization
12:06:07 <jmcarthur> MisterN: that would be very feasible
12:06:08 * gwern brightly notes that all my repos are in ~/bin, which is 5.4g
12:06:09 <kmc> imho xmonad is not the big impressive example we should be pushing
12:06:14 <kmc> (and yes i love xmonad, i use it all day every day)
12:06:14 <pikhq> thoughtpolice: Such as "using Boehm GC"? :P
12:06:15 <thoughtpolice> pikhq: at least on my personal projects. so i can get some of the structural capabilities of C++ without all the crazy shit
12:06:19 <gwern> jmcarthur: sure, it was rewritten, but it ran first in haskell no?
12:06:34 <ozataman> anyone here who has used haskelldb in the recent times?
12:06:36 <jmcarthur> xmonad is just a clean code base doing things that outsiders don't consider functional languages to be good for
12:06:45 <jmcarthur> gwern: pretty sure
12:06:59 <kmc> gavino, Bluespec implements industrial hardware design tools in Haskell.  Galois does a bunch of stuff including implementing a crypto language for the NSA
12:07:14 <kmc> it's also used by several investment banks for modeling exotic derivatives
12:07:28 <kmc> and by some other people for programming hard-real-time embedded systems
12:07:29 <Remy_> hmm,can someone look at my error message? http://old.nabble.com/Haskell%5Cbin-windres%3A-can%27t-open-temporary-file-%60%5C-cca08368.irc%27%3A-No-such-file-or-directory-to28032513.html#a28032834
12:07:34 <MisterN> i think haskell would also be good for statistics stuff
12:07:36 <MisterN> :)
12:07:41 <kmc> the common theme here is that Haskell is a great language for implementing other, domain-specific languages
12:07:42 <FliPPeh> > first (flip divMod 60) $ divMod 3745 60
12:07:43 <lambdabot>   ((1,2),25)
12:07:47 <kmc> that seems to be its industrial breakout niche
12:07:47 <FliPPeh> How could I enhance that?
12:07:55 <FliPPeh> To include a FOURTH field?
12:08:00 <thoughtpolice> pikhq: no, things more like use namespaces to keep name conflicts down, avoid template overuse (that is, use them rarely for what they were designed for: generic stuff), and one rule is either you use RAII everywhere and can use exceptions, or you don't use RAII everywhere, and you can never use exceptions, etc
12:08:12 <jlouis> I have a bittorrent client, though it isn't yet clean and mean
12:08:13 <jmcarthur> interestingly, nearly every haskell library is one which i would classify as a DSL
12:08:24 <kmc> gavino, i would link you to the "Haskell in Industry" page but i can't access haskell.org currently :/
12:08:24 <MisterN> thoughtpolice: clearly you should use RAII then...
12:08:26 <jeffwheeler> I frequently want $ in C-like languages.
12:08:33 <jmcarthur> that is a property i don't really assign to most libraries of most other languages
12:08:37 <pikhq> thoughtpolice: BTW, if you just garbage collectl you can use exceptions just fine without RAII everywhere.
12:08:50 <kmc> i don't see how C++ can claim to be an imperative language when you can't easily abstract over imperative actions
12:08:51 <thoughtpolice> MisterN: well, yes. that's somewhat of the point of that particular rule :)
12:08:57 <pikhq> Boehm GC is awesomeness. :)
12:09:00 <jmcarthur> kmc: :)
12:09:09 <kmc> that's like a functional language without first-class functions
12:09:11 <MisterN> pikhq: i think RAII is awesomer.
12:09:11 <pikhq> kmc: Well, then there's few imperative languages. ;)
12:09:19 <pikhq> MisterN: I beg to differ.
12:09:19 <jmcarthur> pikhq: exactly
12:09:28 <jlouis> RAII won't always work
12:09:32 <jmcarthur> pikhq: haskell is one of the few language where imperative code is actually first class
12:09:36 <jmcarthur> *languages
12:09:40 <kmc> pikhq, not really, every good general-purpose imperative language has first-class functions, and most of them combine the role of function and imperative action
12:09:47 <jlouis> It will work most of the time though. Like region-inference
12:10:18 <pikhq> kmc: Though I'd be inclined to count languages that offer good metaprogramming -- it's at least *possible* to abstract over imperative actions there.
12:10:23 <zygoloid> pikhq: even with garbage collection, exceptions are a pain if you don't do RAII. there are more resources than just memory.
12:10:28 <MisterN> jlouis: there are tools to make RAII work where it doesn't work ;)
12:10:33 <kmc> sigh, Boehm, really?
12:10:43 <thoughtpolice> MisterN: mostly, I just try to avoid exceptions as much as possible in a language where you deal with your own memory. why? because trying to deal with exceptions in the face of manual memory management (even if it's abstracted with an idiom like RAII) is completely fucking insane
12:10:53 <jmcarthur> or you could just use a language that doesn't require handholding ;)
12:10:58 <jlouis> MisterN: I would guess they use a variant of garbage collection, like region inference :)
12:11:00 <pikhq> zygoloid: Yes, but RAII is nice and simple for the few non-memory resources out there.
12:11:03 <MisterN> zygoloid: haskell has the same problem (hClose...), but solves it in a different way
12:11:10 <thoughtpolice> jmcarthur: which is my default choice when possible
12:11:14 <kmc> C++ is so flawed that we need to bolt on workarounds like that?
12:11:15 <jmcarthur> MisterN: the hClose stuff can be abstracted out entirely
12:11:16 <thoughtpolice> jmcarthur: except work requires C++
12:11:21 <jmcarthur> MisterN: it's just bad API
12:11:26 <kmc> if you want C++ with GC, you probably want Java or C# or ML or Haskell or ...
12:11:46 <MisterN> jmcarthur: well, sure, but it's similar in concept
12:11:50 <Zao> Needing GC in C++ is a sign you're not writing idiomatic code.
12:11:53 <theorbtwo> There's an awful big leap between C++ + GC and Haskell.
12:11:54 <zygoloid> pikhq: "few"? i dispute that. any time you have a matched pair of acquire/release functions, or start/finish, or whatever else, that's a "resource" in the RAII sense
12:11:54 <jmcarthur> MisterN: similar in concept to what?
12:12:21 <pikhq> zygoloid: Everything is memory. Compared to that, there's only a few non-memory resources. ;)
12:12:23 <MisterN> jmcarthur: well you also need to make sure hClose is always called...
12:12:32 <theorbtwo> zygoloid: Doesn't neccessarly need to look very unbalanced, so long as there is anything in the middle that could possibly except.
12:12:35 <jmcarthur> MisterN: not if it's properly abstracted out
12:12:53 <MisterN> jmcarthur: yeah, and RAII is an analogous abstraction :)
12:12:55 <kmc> those uses of RAII are replaced with ordinary functions in Haskell
12:13:00 <jmcarthur> MisterN: it's manual
12:13:07 <Vanadium> kmc: That is more verboes than RAII in most cases
12:13:11 <pikhq> Zao: C++ doesn't *need* GC, but it gets much more sane with it.
12:13:11 <jmcarthur> MisterN: i'm talking about something that *actually* abstracted out
12:13:16 <kmc> bracketing is just a HOF on imperative code
12:13:17 <jmcarthur> MisterN: an abstraction hides details
12:13:19 <MisterN> jmcarthur: uh, no, it's not completely manual
12:13:29 <king313> Hi. I need to create a module to pass a integer to a list
12:13:37 <Vanadium> and requires more parentheses and indenting and...
12:13:53 <jlouis> king313: try again.
12:13:56 <king313> to do other tihings
12:14:05 <zygoloid> RAII is just withFoo :: (a -> m b) -> m b, which is just CPS'd for m a.
12:14:10 <MisterN> jmcarthur: it's somewhat less powerful and abstract than what you can do in haskell, but it's an abstraction :P
12:14:15 <king313> I am not skilled in Haskell programming, as you see
12:14:19 <zygoloid> (well, kinda :))
12:14:20 <jmcarthur> MisterN: RAII is a policy. an abstraction is done for you
12:14:24 <king313> any point in which I can start to work?
12:14:33 <kmc> king313, what you describe does not make sense
12:14:36 <gwern> king313: a module is just a grouping of functions & types, a container
12:14:46 <king313> A function
12:14:50 <kmc> "pass" usually means to call a function; a list is not a function
12:14:58 <MisterN> jmcarthur: i was talking sloppily. you do RAII using classes, which are an abstraction
12:15:01 <king313> thanks by correcting that point
12:15:02 <gwern> king313: perhaps you mean 'I need a function which will take an integer and a list, and return a new list made of the integer and old list'?
12:15:17 <jmcarthur> MisterN: just because you use an abstraction to do something doesn't mean the thing you are doing is abstracted
12:15:34 <theorbtwo> There's a difference between having an abstraction for x and abstracting away x.
12:15:35 <jlouis> abstractions can leak
12:15:40 <king313> gwern, not at all, only a integer passed and a list retourned
12:15:51 <kmc> king313, what's in the list?
12:15:53 <gwern> > let foo _ = [] in foo 1
12:15:54 <jmcarthur> jlouis: not good ones
12:15:55 <lambdabot>   []
12:15:57 <gwern> voila
12:15:57 <king313> I'm tring to make a program to sum and rest in binary
12:15:59 <jlouis> jmcarthur: true!
12:16:13 <Remy_> I'm really stuck on this error: Haskell\bin/windres: can't open temporary file `\/cca08368.irc': No such file or directory
12:16:17 <king313> and I need to pass the program a integer with 10101010, for example
12:16:17 <king313> and get
12:16:27 <king313> [1,0,1,0,1,0,1,0] at return
12:16:33 <jlouis> Remy_: access violation of some directory?
12:16:37 <Araneidae> Can anyone advise on this: http://pastebin.com/3qCu3fUY ?
12:16:45 <king313> I think that I have to use recursitivy
12:16:55 <king313> and go number by number adding to a list
12:17:00 <Araneidae> Trying to install some stuff with cabal, and looks like a fairly basic failure somewhere...
12:17:01 <theorbtwo> How likely an abstraction is to leak is how good it is, pretty much... but saying that abstration in general is useless because abstractions can leak is just silly.
12:17:05 <jmcarthur> MisterN: notice the lack of hClose is this module: http://hackage.haskell.org/packages/archive/safer-file-handles/0.4/doc/html/System-IO-SaferFileHandles.html
12:17:08 <MisterN> king313: you can also use higher order functions, but recursion might be a good start
12:17:10 <jlouis> Araneidae: you are trying to use base-3 and need base-4
12:17:36 <jlouis> Araneidae: you can try giving it --constraint='base >= 4'
12:17:47 <Araneidae> Ok,  Can I change the default base ?
12:17:50 <FliPPeh> @src first
12:17:50 <lambdabot> Source not found. It can only be attributed to human error.
12:17:51 <jmcarthur> *in this
12:17:59 <Araneidae> Don't really understand how cabal works
12:18:21 <MisterN> jmcarthur: is there an example somewhere how it's used?
12:18:22 <jlouis> Araneidae: if a library does not explicitly give a base, it can pick any, really
12:18:32 <jlouis> give a version, it can pick any version, really
12:18:35 <jmcarthur> MisterN: http://code.haskell.org/~basvandijk/code/safer-file-handles-examples/
12:19:17 <king313> I think that having the length of the integer and getting the division of the number by 10^(position+1) I can get all de digits except
12:19:17 <Araneidae> Well, setting the constraint didn't seem to change anything: http://pastebin.com/hxjuh6Pg
12:19:22 <king313> the less significative one
12:20:10 <king313> err... not
12:20:16 <king313> it doesn't
12:20:18 <jlouis> Araneidae: try giving it -v and see if it picks up base >= 4
12:20:19 <MisterN> jmcarthur: huh, how does that work?
12:20:24 <MisterN> jmcarthur: when is the file closed?
12:20:43 <jmcarthur> MisterN: when execution leaves the region
12:20:59 <MisterN> jmcarthur: what is a region?
12:21:13 <MisterN> runTopRegion <- ah, this?
12:21:18 <zygoloid> king313: what should the result be when the function is applied to 0? [] or [0]?
12:21:23 <jlouis> MisterN: yup, manual region management
12:21:26 <thoughtpolice> man
12:21:27 <jmcarthur> MisterN: http://okmij.org/ftp/Haskell/regions.html#light-weight
12:21:31 <Araneidae> jlouis, says "using base-4.1.0.0" http://pastebin.com/jUhXq2d5 (line 33)
12:21:31 <MisterN> ok so you construct a region and openFile puts it into the current region
12:21:39 <MisterN> jmcarthur: that's a cool abstraction
12:21:52 <eprst> hello. Does there exist a standard implementation of (Monad m) => (a -> m b) -> m (a -> b)   ?
12:21:53 <thoughtpolice> i must say, attoparsec + she using idiom brackets == amazingly fast, great looking parsers in an applicative fashion :)
12:21:53 <jlouis> Araneidae: hmm, I am out of ideas then
12:22:14 <FliPPeh> "first (flip divMod 60) (divMod 3600 60)" <- that converts the 3600 to ((1,0),0), one hour, zero minutes and zero seconds. How do I add up on that to include days, e.G. split the hours again?
12:22:17 <king313> zygoloid, [0]
12:22:27 <Araneidae> Well, that's very odd then.  Does that mean that the current template-haskell in cabal is broken?
12:22:30 <MisterN> thoughtpolice: btw i like your nickname
12:22:43 <king313> zygoloid, but I don't have any problem with []
12:22:47 <thoughtpolice> MisterN: ty :)
12:22:52 <king313> I can make other funtions to work with it
12:23:12 <theorbtwo> The interesting thing about using scoping to automatically close resources like filehandles is that closing a filehandle can fail.
12:23:20 <zygoloid> king313: ok. i suggest you consider the following: what should your function do if given n, where n is less than 10?
12:23:22 <theorbtwo> (If you flush buffered output at close time.)
12:23:31 <gavino> are there many secret haskell startups?
12:23:37 <jlouis> @hoogle (Monad m) => (a -> m b) -> m (a -> b)
12:23:38 <lambdabot> Test.QuickCheck promote :: (a -> Gen b) -> Gen (a -> b)
12:23:39 <MisterN> theorbtwo: yeah that's an interesting problem
12:23:45 <gavino> or can i still learn haskell adn jump in make my startup and make some doough?
12:23:49 <kmc> gavino, if we told you, it wouldn't be secret, would it? ;)
12:23:53 <gavino> ha!!
12:24:02 <kmc> whether you make money at a startup depends on a lot of things more than it depends on what language you use
12:24:09 <Remy_> okay I ran cygwin in administrator mode and the error is gone now. Might have been a permission issue yes. thanks a lot jlouis
12:24:12 <king313> zygoloid,  the list [n]
12:24:15 <kmc> picking a good language and using it well gives you a bit of an edge
12:24:31 <jlouis> Araneidae: hard to say. For some combination of different libraries it might not be
12:24:40 <zygoloid> king313: ok, that gives you the start of a function. that's your base case for the recursion. what should it do if n is >= 10?
12:24:48 <dmwit> king313: Have you seen Data.Bits?
12:25:00 <king313> dmwit, I haven't...
12:25:06 <dmwit> http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.2.0.0/Data-Bits.html
12:25:17 <king313> zygoloid, [n1,n2,...nm]
12:25:27 <fax> hi gavino
12:25:31 <theorbtwo> It's a reasonably common, if often theoretical, problem with lexical filehandles in perl.  It'd be even worse in a language like Haskell that does not, in general, have catchable exceptions.
12:25:32 <king313> ok, now I have to work on how to select that digits
12:25:54 <fax> gavino - there are some startups but who really wants to write web 'apps'??
12:26:05 <dmwit> king313: See also Numeric.
12:26:21 <zygoloid> king313: suppose you could extract the last digit, so you could take: 12345 -> (1234, 5). then how would you proceed?
12:26:21 <jlouis> Remy_: glad to hear that fixed the problem
12:26:22 <dmwit> king313: e.g. showIntAtBase
12:26:24 <theorbtwo> fax: Er, does that surprise you?
12:26:37 <dmwit> http://haskell.org/ghc/docs/latest/html/libraries/base-4.2.0.0/Numeric.html
12:26:55 <MisterN> fax: there are some advantages to writing web apps. for example you control which software you run on the software, which can be quite convenient :)
12:26:57 <theorbtwo> dmwit: Sssh.  This is a very good learning problem...
12:27:03 <MisterN> *run on the server
12:27:12 <gavino> :)
12:27:20 <gavino> as mr graham pointed out in one of his nice essays
12:27:41 <king313> zygoloid, hey, I can use tail and head then
12:27:45 <theorbtwo> Also, people these days seem to like running it, and buying componies that make it.
12:28:19 <MisterN> gavino: i wonder if that's actually one of the forces pushing more and more apps into the web
12:28:21 <king313> I think that then I can manage to get it
12:28:38 <king313> dmwit, googling, thanks
12:29:26 <Araneidae> jlouis, suspect my ghc (6.10.4) might be too old
12:29:56 <jlouis> Araneidae: oh that might indeed be the problem
12:30:12 --- mode: ChanServ set +o mauke
12:30:12 --- mode: mauke set +b $a:gavino
12:30:44 <jlouis> evening mauke :)
12:30:45 <mauke> @protontorpedo
12:30:45 <lambdabot> whera re the end user apps?
12:31:14 <siracusa> Araneidae: What does it say when you add contraint syb== any?
12:32:11 <tomh-> why is that guy banned
12:32:12 <Araneidae> siracusa, I'm going to upgrade my ghc first:  this line from `cabal install haddock` was a broad hint: cabal: cannot configure haddock-2.7.2. It requires ghc >=6.12 && <6.14
12:32:12 --- mode: mauke set -o mauke
12:32:23 <zygoloid> mauke: aww, you didn't give him time to get his troll on
12:32:54 <mauke> tomh-: asking questions
12:33:02 <jlouis> bad mauke! We want some real challenges, like level 13 trolls
12:33:08 <kmc> what why'd gavino get banned?
12:33:14 <mauke> @protontorpedo
12:33:14 <lambdabot>  and is haskell ez to debug?
12:33:16 <mauke> @protontorpedo
12:33:16 <lambdabot> is functional ebtter than oo?
12:33:18 <mauke> @protontorpedo
12:33:18 <lambdabot> I have perl bok but saw haskell and am woner hey this is new and improved and seems powerful because MIT guy philip green says haskell adn lisp are only langs where u spend more tie thinking than
12:33:19 <lambdabot> coding
12:33:25 <mauke> ^ this, basically
12:33:37 <kmc> eh did not seem egregious at all
12:33:42 <mauke> zygoloid: he's had one hour, that's more than enough
12:34:09 <mauke> kmc: egregious enough that someone collected his quotes and made a new lambdabot command for it
12:34:09 <kmc> didn't seem like a troll to me
12:34:17 <kmc> wait that *is* protontorpedo?
12:34:21 <kmc> how do you know?
12:34:24 <mauke> ...
12:34:37 <kmc> i'm confused
12:34:37 <FliPPeh> > divMod 6000 60
12:34:38 <lambdabot>   (100,0)
12:34:45 <aavogt> you should ban @protontorpedo then?
12:34:54 <mauke> first, he's rather easy to spot from what he says
12:34:55 <fax> ??
12:35:06 <mauke> or rather, the questions he keeps asking
12:35:12 <mauke> second, I have him on highlight
12:35:14 <fax> mauke why did you ban him
12:35:22 <zygoloid> i assume it takes rather a lot of that sort of thing to get a #haskell ban for life
12:35:23 <fax> that's not fair
12:35:36 <mauke> fax: it's not fair that he keeps coming back
12:36:01 <mauke> zygoloid: how about months or even years of this stuff, in multiple channels?
12:36:01 <zygoloid> maybe he is genuinely interested in haskell?
12:36:29 <fax> so startups are not allowed to talk about in haskell?
12:36:30 <mauke> yeah, that's probably why he's banned in several other channels
12:36:38 <fax> Or are you just banning him based on who he is rather than what he does
12:36:41 <mauke> fax: no, gavino is not allowed to talk
12:36:41 <fax> because IMO that's bullying
12:37:27 <fax> mauke btw I have long interesting conversations with him which are not about web
12:37:53 <mauke> your opinion is noted and ignored; as far as I'm concerned he deserves a lifetime internet (or at least IRC) ban
12:38:16 <fax> I am finding #haskell pretty aggresive and unwelcoming recently
12:38:33 <fax> like all these poeple who keep telling me to fuck off to another channel because I'm talking about something they don't understand
12:38:38 <fax> and now this - too
12:39:12 <tensorpudding> #haskell is unfriendly?
12:39:32 <roconnor> fax: did someone really tell you to fuck off to another channel?
12:39:42 <fax> roconnor not in those words
12:40:04 <mauke> "now"? AFAIK he was first banned in 2006
12:40:13 <mauke> kept coming back under like 20 different nicks
12:40:43 <tensorpudding> if his nick is banned here, though, how did he come back with a nick that you already had highlighted?
12:41:12 <mauke> that was before I had him on highlight (and before I had ops here)
12:41:45 <tensorpudding> okay
12:42:08 <mauke> (and my script doesn't simply look at the nick)
12:42:30 <choffstein> Hey all, I have a quick question.  I just updated my haskell installation to 2010 and now my program that uses hmatrix won't compile.  I tried rebuilding hmatrix, but it still won't compile.  It runs perfectly when interpreted, but I get a bunch of linking errors.  Any ideas?
12:43:05 <tensorpudding> Do you mean that you updated the platform to the new version?
12:43:26 <dmwit> Are you compiling against the global package database or the user one?
12:43:27 <tensorpudding> i.e. the version with GHC 6.12 on it?
12:43:39 <MisterN> @hoogle hmatrix
12:43:39 <lambdabot> No results found
12:44:02 <dmwit> ?hackage hmatrix
12:44:03 <lambdabot> http://hackage.haskell.org/package/hmatrix
12:44:19 <choffstein> Yes, I updated the platform to the new version
12:44:32 <choffstein> dmwit: what do you mean, global package database or the user one?
12:45:08 <tensorpudding> hmatrix should compile in GHC 6.12, hmm.
12:45:36 <dmwit> How are you building?
12:46:15 <choffstein> hmatrix does compile
12:46:29 <choffstein> there are just linking errors with my application that USES hmatrix
12:46:49 <mauke> any old object files around?
12:46:59 <choffstein> mauke: ...yes
12:47:13 <MisterN> choffstein: delete them :)
12:47:13 <tensorpudding> They're probably linked against the old GHC
12:47:17 <jlouis> apply flamethrower `to` oldObjects
12:47:22 <MisterN> :t to
12:47:23 <FliPPeh> "first (flip divMod 60) (divMod 3600 60)" <- that converts the 3600 to ((1,0),0), one hour, zero minutes and zero seconds. How do I add up on that to include days, e.G. split the hours again?
12:47:23 <lambdabot> Not in scope: `to'
12:47:29 <choffstein> cleaning the old object files didn't seem to make a difference
12:47:43 <jlouis> :t on
12:47:44 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
12:47:49 <MisterN> jlouis: anyways, why use a to function there? wouldn't flamethrower `apply` oldObjects work just as well?
12:47:52 <jlouis> MisterN: on exists, to doesn't
12:47:59 <MisterN> :t on
12:48:00 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
12:48:07 <MisterN> oh you :t'd yourself
12:48:08 <tensorpudding> :t first
12:48:09 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
12:48:15 <MisterN> @src on
12:48:15 <lambdabot> (*) `on` f = \x y -> f x * f y
12:48:34 <MisterN> ah, on is some algebraic thingie
12:48:36 <jlouis> MisterN: and I like you are haskell-golfing already :) like a true citizen in #haskell :P
12:48:37 <dmwit> FliPPeh: first (first (flip divMod 24))
12:48:50 <ozataman> is there a good way to use multi-line strings in Haskell?
12:48:52 <MisterN> jlouis: heh, pastorn told me not to do it
12:48:52 <choffstein> So any other ideas?
12:49:03 <dmwit> ozataman: put a '\' at the end and beginning of each line
12:49:05 <mauke> ozataman: no
12:49:25 <choffstein> I removed all .hi and .o files
12:49:25 <jlouis> :t (==) `on` snd
12:49:26 <lambdabot> forall a b. (Eq b) => (a, b) -> (a, b) -> Bool
12:49:39 <dmwit> mauke: Lies!
12:49:40 <jlouis> MisterN: ^^ usual usage of `on`
12:50:07 <FliPPeh> Mhh
12:50:22 <MisterN> :t snd
12:50:23 <lambdabot> forall a b. (a, b) -> b
12:50:26 <ozataman> dmwit: wow, that is very inconvenient
12:50:29 <FliPPeh> Hey, it seems to work
12:50:38 <dmwit> Oh, well, it has to be \n\ at the end of a line and \ at the beginning.
12:50:44 <MisterN> @src zip
12:50:45 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
12:50:45 <lambdabot> zip _      _      = []
12:50:51 <dmwit> ozataman: I suppose.
12:51:06 <mauke> told you so
12:51:07 <MisterN> can't zip be written more generically with (,)?
12:51:19 <FliPPeh> >  first (first (flip divMod 24)) $ first (flip divMod 60) (divMod 4425169 60)
12:51:21 <lambdabot>   (((51,5),12),49)
12:51:24 <king313> can I paste 3 lines of code?
12:51:30 <dmwit> ozataman: The other option is to use "unlines".
12:51:30 <FliPPeh> Thank you dmwit :)
12:51:35 <dmwit> ?hpaste it, king313
12:51:35 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
12:51:37 <FliPPeh> It works like a charm
12:51:47 <king313> ok, for 3 lines only too
12:51:50 <tensorpudding> That looks pretty messy to my eyes.
12:51:54 <FliPPeh> Now I just gotta write a short tuple flattener and it works great
12:51:59 <ozataman> dmwit: thanks
12:52:21 <king313> dmwit, I prefer pastebin, less ciales ads
12:52:25 <king313> *ciales
12:52:27 <king313> *cialis
12:52:39 <dmwit> uh... that's new
12:52:41 <Alpounet> ads on hpaste ?
12:52:57 <stevenmarky> Flippeh why didn't you make it flat to start with?
12:53:06 <dmwit> Alpounet: ad pastes
12:53:12 <jlouis> MisterN: sometimes an alternative implementation is chosen if it has good performance or space behaviour
12:53:16 <Alpounet> hm
12:53:20 <choffstein> what da fawk is going on with this compilation...
12:53:20 <dmwit> That sure seems like the kind of thing that could be automatically filtered.
12:53:32 <dmwit> Who's in charge of hpaste? I know a technique that catches 99.9% of these.
12:53:32 <dcolish> hpaste needs a human detector
12:53:33 <Zao> choffstein: You seem to have lambdacats in your tree.
12:53:43 <FliPPeh> stevenmarky: Because those arrow functions operate on tuples here
12:53:44 <dmwit> dcolish: It needs something even less complicated, actually. =)
12:53:47 <choffstein> Zao: Or something far more ferocious...
12:53:49 <FliPPeh> stevenmarky: I have no idea if it would work without them
12:53:52 <MisterN> jlouis: i don't know how to write zip more generically :(
12:53:54 <jlouis> choffstein: lambdatrolls?
12:54:00 <dcolish> sure, although recaptcha in a form is pretty easy
12:54:03 <jlouis> MisterN: me neither :)
12:54:03 <MisterN> jlouis: i'm thinking something like map2 (,) a b
12:54:06 <choffstein> jlouis: perhaps...
12:54:07 <king313> I have managed to have somethink like I wanted
12:54:11 <MisterN> :t map2
12:54:11 <king313> pass a Integer into a list
12:54:11 <tensorpudding> Does hpaste really need captchas?
12:54:11 <king313> http://pastebin.com/dut647g3
12:54:12 <stevenmarky> oh ok.
12:54:12 <lambdabot> Not in scope: `map2'
12:54:13 <king313> but
12:54:33 <king313> I think that it's not a elegant solution and that Haskell have a more simple way to do that
12:54:37 <dmwit> dcolish: I've caught 100% of spam on http://dmwit.com/shesaidyes/comments.html without recaptcha (!).
12:54:48 <kmc> pastebin is kinda ugly.  how about codepad?
12:54:57 <dmwit> No false positives yet.
12:55:25 <jlouis> MisterN: liftM2 (,) is the cartesian product via the List monad
12:55:27 <dcolish> dmwit: what methods are you using?
12:55:42 <dmwit> dcolish: just a hidden field labeled "email address"
12:55:51 <MisterN> jlouis: but that's not the same thing
12:55:51 <dmwit> dcolish: Anybody who fills it in gets thrown in the spam bucket. =)
12:55:59 <jlouis> MisterN: exactly :/
12:55:59 <zygoloid> dmwit: awesome :)
12:56:01 <choffstein> Okay, any ideas on this: ghc problem2.lambda.hs -- Undefined symbols: "_hmatrixzm0zi8zi3zi1_DataziPackedziST_thawMatrix_closure", referenced from: ..."
12:56:08 <kmc> choffstein, compile with ghc --make
12:56:10 <dcolish> dmwit: nice thinking
12:56:19 * stevenmarky knows the secret now
12:56:21 <tensorpudding> There isn't any need for the list comprehension there that I can see..
12:56:22 <choffstein> OH COME ON!
12:56:24 <mauke> preflex: zdec _hmatrixzm0zi8zi3zi1_DataziPackedziST_thawMatrix_closure
12:56:24 <preflex>  _hmatrix-0.8.3.1_Data.Packed.ST_thawMatrix_closure
12:56:32 <kmc> come on what?
12:56:36 <choffstein> that was so easy
12:56:40 <jlouis> bug fixed :)
12:56:47 <kmc> :)
12:56:48 <choffstein> Now I just feel like an idiot
12:56:51 <choffstein> thank you very much
12:56:56 <doooooooog> you should
12:56:57 <dcolish> --make == magic
12:57:15 <kmc> --make is great and should probably be used by anyone without a specific reason not to
12:57:17 <tensorpudding> I'm pretty sure that [ list | list <- foo ] is the same as foo
12:57:19 <MisterN> zygoloid: do you know of a more generic version of zip, where you can implement zip as genericZip (,)? :)
12:57:19 <dmwit> choffstein: Well, to be fair, we did ask how you were building fairly early in the exchange... =)
12:57:38 <kmc> i think ghc should suggest it any time you have a linker error
12:57:38 <choffstein> dmwit: To be fair, I do have absolutely zero idea what I am talking about ;)
12:57:45 <zygoloid> MisterN: zipWith
12:57:50 <MisterN> thx!
12:57:57 <MisterN> :t zipWith
12:57:58 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
12:58:00 <dmwit> tensorpudding: Yup, it's a monad law!
12:58:09 <pickles> :q
12:58:25 <tensorpudding> Also, you can get rid of the guard patterns with a simple pattern match on the argument
12:58:29 <MisterN> jlouis: zipWith ftw
12:58:35 <jlouis> @src zipWith
12:58:35 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
12:58:35 <lambdabot> zipWith _ _      _      = []
12:59:13 <FliPPeh> Am I right with the asumption that the first and second arrow functions apply a function on the first or seconds element of a tuple?
12:59:14 <zygoloid> MisterN: there's also the ZipList applicative functor, but that's not really any more generic
12:59:28 <kmc> FliPPeh, yes.  well, for the function arrow anyway
12:59:37 <kmc> :t first
12:59:38 <MisterN> zygoloid: uh i was already wondering if there's a monad or something for this :D
12:59:38 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
13:00:03 <kmc> read as:   (Arrow (~>)) => (b ~> c) -> ((b,d) ~> (c,d))
13:00:03 <MisterN> .oO(the less i understand something, the worse my grammar is)
13:00:05 <king313> I have reached a ugly and fuzzy method to transform a Integer to a list of it's digits
13:00:13 <kmc> :t showAtBase
13:00:14 <lambdabot> Not in scope: `showAtBase'
13:00:16 <kmc> :t showsAtBase
13:00:17 <lambdabot> Not in scope: `showsAtBase'
13:00:21 <HugoDaniel> has anyone used vector ?
13:00:23 <tensorpudding> dig2list 0 = [0]; dig2list d = let d' = d `mod` 2 in dig2list d' ++ [d']
13:00:24 <zygoloid> > getZipList $ (\a b c -> a + b * c) <$> ZipList [1,2,3] <*> ZipList [10,100,1000] <*> ZipList [4,5,6]
13:00:25 <jlouis> MisterN: a ZipList is an Applicative from Control.Applicative
13:00:25 <lambdabot>   [41,502,6003]
13:00:26 <king313> Are they a more simple and elegant method that
13:00:27 <king313> http://pastebin.com/dut647g3
13:00:28 <dmwit> :t showIntAtBase
13:00:29 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
13:00:30 <king313> ?
13:00:34 <tensorpudding> would be a leaner and meaner version of the same function
13:00:46 <jlouis> MisterN: All monads are applicatives, but not the other way around
13:00:48 <HugoDaniel> im playing around with it, and i was wondering if the (++) operator is fast
13:00:56 <MisterN> jlouis: yeah and Applicative is similar to a monad, i know it's not the same
13:00:58 <mtnviewmark> :t unfoldl
13:00:59 <lambdabot> Not in scope: `unfoldl'
13:01:04 <mtnviewmark> :t unfoldr
13:01:05 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
13:01:08 <tensorpudding> @src (++)
13:01:08 <lambdabot> []     ++ ys = ys
13:01:08 <mauke> :t map digitToInt . show
13:01:08 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
13:01:08 <lambdabot> -- OR
13:01:08 <lambdabot> xs ++ ys = foldr (:) ys xs
13:01:08 <kmc> > showIntAtBase 2 (['0'..'9']!!) 1337 ""
13:01:09 <lambdabot> forall a. (Show a) => a -> [Int]
13:01:11 <lambdabot>   "10100111001"
13:01:17 <mauke> > map digitToInt . show $ 1337
13:01:18 <lambdabot>   [1,3,3,7]
13:01:26 <choffstein> Anyone use the latest Haskell release (2010) on Mac OS X 10.6?
13:01:34 <mtnviewmark> I don't like using show there -- seems unclean!
13:01:44 <tensorpudding> (++) requires as many recursions as the length of the first argument
13:01:45 <aavogt> @let unfoldl = error "crazy inefficient?"
13:01:46 <MisterN> oh, the WrappedMonad trick in Applicative is neat
13:01:47 <lambdabot>  Defined.
13:02:15 <MisterN> > unfoldl "aavogt"
13:02:16 <mtnviewmark> for an integer into a digit list? I think unfold* will be efficient enough
13:02:16 <lambdabot>   * Exception: crazy inefficient?
13:04:11 <zygoloid> > reverse $ unfoldr (\a -> [Just (uncurry (flip (,)) $ a `divMod` 10), Nothing] !! fromEnum (a == 0)) 1337
13:04:12 <lambdabot>   [1,3,3,7]
13:05:37 <FliPPeh> Arrows are actually pretty nifty
13:05:40 <pastorn> @where cabal
13:05:40 <lambdabot> http://www.haskell.org/cabal
13:05:52 <FliPPeh> It's like an fmap/(fst,snd) cross for tuples
13:06:24 <aavogt> @check \x -> if x then 0 else 1 == [0,1] !! fromEnum x
13:06:25 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
13:06:25 <lambdabot>    arising from the literal `0'...
13:06:43 <aavogt> @check \x -> ( if x then 0 else 1 ) == [0,1] !! fromEnum x
13:06:44 <lambdabot>   "Falsifiable, after 0 tests:\nFalse\n"
13:07:23 <zygoloid> @check \b -> ["False", "True"] !! fromEnum b == if b then "True" else "False"
13:07:24 <lambdabot>   "OK, passed 500 tests."
13:07:57 <aavogt> > False < True
13:07:58 <zygoloid> 500 tests seems almost... overkill :)
13:07:58 <lambdabot>   True
13:08:07 <dmwit> :t \b -> [0 | b] ++ [1 | not b]
13:08:08 <lambdabot> forall t. (Num t) => Bool -> [t]
13:08:12 <ozataman> Is there a good example somewhere of propagating custom errors in an Either monad through a chain of computations?
13:08:16 <aavogt> depends on the arbitrary instance ;)
13:08:22 <jlouis> that reminds me that combinatorrent needs more quickcheck tests
13:08:23 <ozataman> Or is there a better way to do that?
13:08:34 <dmwit> :t \b -> 1 - fromEnum b
13:08:35 <jlouis> I only do 100 at a time by default though
13:08:35 <lambdabot> forall a. (Enum a) => a -> Int
13:08:36 <MisterN> > fromEnum True
13:08:37 <lambdabot>   1
13:08:42 <MisterN> :t fromEnum
13:08:42 <lambdabot> forall a. (Enum a) => a -> Int
13:08:45 <zygoloid> jlouis: my brain is having a massive pronunciation fail for 'combinatorrent'
13:09:07 <MisterN> zygoloid: maybe because it's no real word?
13:09:09 <jlouis> zygoloid: excellent. Then I know I have the right name. Go bug shapr :)
13:09:28 <MisterN> jlouis: what is combinatorrent?
13:09:31 <roconnor> com-bin-a-torr-ent ?
13:09:43 <aavogt> ozataman: just use 'do' and whenever you have a value that you want to pull out the Right,    just use  x <- expression  instead of   let x = expression
13:09:48 <jlouis> combinator-rent
13:09:52 <zygoloid> roconnor: which syllable gets the emphasis?
13:09:55 <jlouis> I prefer the first one though
13:10:18 <jlouis> MisterN: I write bittorrent clients for fun, you know: http://github.com/jlouis/combinatorrent
13:10:22 <roconnor> zygoloid: com
13:10:40 <MisterN> jlouis: wtf :)
13:11:39 <pastorn> i'm having cabal trouble :(
13:11:42 <ozataman> aavogt: thanks.. do you know of good examples of handling errors in complex computations? it would be good to take a look at some good practices
13:11:47 <pastorn> Cabal-1.6.0.2$ ./Setup configure --user
13:11:48 <pastorn> Configuring Cabal-1.6.0.2...
13:11:50 <pastorn> Setup: failed to parse output of 'ghc-pkg dump'
13:13:12 <cpennington> has any one gotten h4sh to work recently?
13:13:18 <burp> nope
13:13:29 <jlouis> pastorn: 6.12 needs cabal 1.8 IIRC
13:13:29 <burp> sadly not
13:13:58 <jlouis> MisterN: feel free to submit patches to my crap code
13:14:20 <cpennington> I'm running into an issue where the higher order functions (map and the like) fail because they can't find libffi.so
13:14:26 <MisterN> jlouis: i was just wtf'ing the idea of writing torrent clients for fun :)
13:14:30 <pastorn> jlouis: it's not here! http://www.haskell.org/cabal/download.html
13:14:45 <cpennington> (I had to muck with the cabal and make files that h4sh uses to get to that point)
13:15:21 <FliPPeh> Okay, given a tuple like (a,b,c,d), where each of those could be the number 0, what would be the best function to only "stringify" those NOT null?
13:15:26 <jlouis> pastorn: bug dcoutts I think. Or perhaps dons og Igloo. If you crawl up a couple of dirs in the download path, you can get a link to it
13:15:28 <FliPPeh> If it were a list, mapping would be easy
13:15:30 <FliPPeh> But it's NOT :(
13:15:48 <jlouis> FliPPeh: Functor, fmap?
13:15:54 <FliPPeh> Hmmm!
13:15:57 <FliPPeh> That's an idea
13:16:06 <jlouis> FliPPeh: if is has a functor instance, fmap applies
13:16:16 <ozataman> fmap is so great like that :)
13:16:19 <pastorn> dcoutts, dons, Igloo: what jlouis said ^^^
13:16:30 * pastorn bugs
13:16:35 <FliPPeh> jlouis: I think (,,,) has no functor instance
13:16:38 <aavogt> ozataman: look at this http://www.haskell.org/pipermail/xmonad/2009-September/008704.html
13:16:40 <FliPPeh> It's a quad!
13:16:53 <FliPPeh> Writing fmap for it would be a pain I suppose
13:16:55 <aavogt> > fmap succ (0,0,0,0)
13:16:56 <lambdabot>   No instance for (GHC.Base.Functor ((,,,) t t1 t2))
13:16:56 <lambdabot>    arising from a use of...
13:17:09 <ozataman> aavogt: Thanks, will do
13:17:09 <aavogt> it could have that instance though
13:17:22 <MisterN> FliPPeh_: do you maybe want to use an array or something like that?
13:17:32 <aavogt> ozataman: specifically the explicit nested case vs. being implicit with the ErrorT
13:17:37 <FliPPeh> MisterN: I only have a tuple, sadly
13:17:45 <MisterN> FliPPeh_: it's your code, no? :)
13:17:52 <FliPPeh> Yes, buuuuut
13:18:07 <MisterN> ?
13:18:14 <FliPPeh> > let f x = first (first (flipDM 24)) $ first (flipDM 60) (divMod x 60) in f
13:18:15 <lambdabot>   Not in scope: `flipDM'Not in scope: `flipDM'
13:18:16 <FliPPeh> > let f x = first (first (flipDM 24)) $ first (flipDM 60) (divMod x 60) in f 3600
13:18:17 <lambdabot>   Not in scope: `flipDM'Not in scope: `flipDM'
13:18:20 <FliPPeh> Well
13:18:33 <FliPPeh> > let f x = first (first (flip divMod 24)) $ first (flip divMod 60) (divMod x 60) in f 3600
13:18:34 <lambdabot>   (((0,1),0),0)
13:18:38 <FliPPeh> There we go
13:18:54 <FliPPeh> I've written a "flatten" for it, which turns it into (0, 1, 0, 0)
13:19:19 <FliPPeh> It represents (d, h, m, s), and in this case (0, 1, 0, 0), I'd like to string it to "1d"
13:19:23 <FliPPeh> Erm
13:19:24 <FliPPeh> 1h
13:21:16 <jmcarthur> :t unfoldr
13:21:17 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
13:21:25 <pastorn> jlouis: thanks for the help... this seems to work :)
13:21:30 <FliPPeh> Mehhh
13:21:37 * pastorn is running ./bootstrap.sh right now
13:22:11 <jlouis> pastorn: also check cabal-install 0.8 :)
13:22:38 <pastorn> jlouis: did that :)
13:23:52 <Cale> http://upload.wikimedia.org/math/2/b/6/2b6b54a31eba9214b36f57648f5f28f1.png -- lol, this is one of the more ridiculous-looking bounds I've ever come across.
13:24:39 <pastorn> i like this warning: "Warning: Module `Prelude' is deprecated:"
13:25:24 <jlouis> @pl \x d -> show x ++ d
13:25:25 <lambdabot> (++) . show
13:25:27 <c_wraith> Yeah, the warning would be better if it focused on the package, rather than the module
13:25:37 <tensorpudding> Is that 5 levels of exponentiation there?
13:26:04 <Cale> N = N(k,delta) is the number such that every subset of {1,...,N} of size at least delta*N contains an arithmetic progression of length k.
13:26:08 <pastorn> c_wraith: well, it mentions stuff about base3.* and base4.*, so it's okay :)
13:26:40 <Cale> yeah, 2^(2^(delta^(-2^(2^(k+9)))))
13:27:24 <pastorn> best follow up on itstalling GHC 6.12: 'rm -rf ~/.cabal/ ~/.ghc/'
13:27:29 <jlouis> Cale: that bound is definitely fun
13:27:36 <pastorn> now stuff works!
13:27:50 <fax> wow Cale wtf
13:28:19 <fax> yikes
13:28:19 <jlouis> My big-oh terms of O(lg lg lg lg n) pales in comparison
13:28:27 <fax> is this gonna be on the exam???
13:28:43 <bremner> Maybe Bool
13:28:52 <c_wraith> uh.  is lg lg lg lg n > 2 for any practical n?
13:29:09 <jlouis> c_wraith: I doubt it :)
13:30:20 <stevenmarky> I'm looking for a function that's a bit like the opposite of concat, e.g. somefunction [1,2,3,4,5,6,7,8] 2  = [[1,2],[3,4],[5,6],[7,8]]
13:30:35 <byorgey> c_wraith: add one more lg, then you'll be good
13:30:36 <Botje> stevenmarky: Data.List.Split, look at chunk
13:31:00 <byorgey> 2^(2^(2^(2^2))) is not THAT big
13:31:33 <burp> out of double scope :>
13:31:43 <xerox> > (foldr (.) id $ replicate 4 exp) 2
13:31:44 <bremner> > 2^(2^(2^(2^2)))
13:31:44 <stevenmarky> that's it, thanks Botje
13:31:44 <lambdabot>   Infinity
13:31:45 <lambdabot>   200352993040684646497907235156025575044782547556975141926501697371089405955...
13:31:57 <byorgey> burp: Double, who cares about Doubles? =)
13:32:10 <burp> :t log
13:32:11 <lambdabot> forall a. (Floating a) => a -> a
13:32:18 <burp> ok, what other floating instances are there? :>
13:32:30 <FliPPeh> Ohgod, I should consider restarting, my network interface has 140 GiB received traffic
13:32:33 <burp> which can handle larger numbers
13:32:35 <theorbtwo> @instances Floating
13:32:36 <lambdabot> Double, Float
13:32:44 <xerox> Boat
13:32:51 <theorbtwo> Presumably, more outside of what @instances searches.
13:33:07 <pastorn> what's "<interactive>: warning: too many hs_exit()s"
13:33:08 <byorgey> I thought we were talking about the mathematical function lg.
13:33:15 <burp> ah ok
13:33:17 <fax> what's lg
13:33:27 <fax> another name for log ?
13:33:30 <byorgey> an abbreviation for log base 2.
13:33:31 <Botje> log base 2
13:33:34 <theorbtwo> > lg 2
13:33:35 <lambdabot>   Not in scope: `lg'
13:33:38 <fax> oh
13:33:42 <theorbtwo> ...er, or not.
13:34:15 <Botje> > let lg = (/ log 2) . log in lg 2
13:34:16 <lambdabot>   1.0
13:34:21 <xerox> > lg 2
13:34:22 <lambdabot>   "life's good"
13:34:29 <Botje> haha :)
13:38:34 <jmcarthur> > zipWith (flip (++) . return) "smhd" . map (show . snd) . tail . flip (scanl (divMod . fst)) [60, 60, 24, maxBound :: Int] . flip (,) 0 $ 275653
13:38:35 <lambdabot>   ["13s","34m","4h","3d"]
13:38:40 <EvanR-work> damn were having trouble installing some of these cabal things from AUR
13:38:41 <jmcarthur> oh woops
13:38:42 <pastorn> > 1 / 0
13:38:43 <lambdabot>   Infinity
13:38:49 <jmcarthur> > reverse . zipWith (flip (++) . return) "smhd" . map (show . snd) . tail . flip (scanl (divMod . fst)) [60, 60, 24, maxBound :: Int] . flip (,) 0 $ 275653
13:38:50 <lambdabot>   ["3d","4h","34m","13s"]
13:38:56 <pastorn> > arcsin 0
13:38:56 <lambdabot>   Not in scope: `arcsin'
13:38:59 <aavogt> @instances-importing Data.CReal Floating
13:39:00 <lambdabot> Double, Float
13:39:03 <pastorn> > asin 0
13:39:04 <lambdabot>   0.0
13:39:06 <pastorn> > asin 2
13:39:08 <lambdabot>   NaN
13:39:19 <jmcarthur> > intercalate " " . reverse . zipWith (flip (++) . return) "smhd" . map (show . snd) . tail . flip (scanl (divMod . fst)) [60, 60, 24, maxBound :: Int] . flip (,) 0 $ 275653
13:39:20 <pastorn> xerox: you hacker
13:39:20 <lambdabot>   "3d 4h 34m 13s"
13:39:28 <jmcarthur> FliPPeh: ^^ :)
13:39:46 <jmcarthur> not as pretty as i'd like, but i thought for too many minutes already
13:40:20 <FliPPeh> jmcarthur: It hurts :(
13:40:42 <jmcarthur> :(
13:40:52 <jmcarthur> where does it hurt?
13:41:01 <FliPPeh> I don't get it :D
13:41:17 <FliPPeh>  35 quadToDays (d, h, m, s) = foldr (++) "" . map f $ pairs 36    where pairs   = [(d, "Days"), (h, "Hours"), (m, "Minutes"), (s, "Seconds")]
13:41:29 <FliPPeh> I just turned the tuple to a list :/
13:41:45 <Twey> In the aestheticles, of course
13:41:46 <FliPPeh> ignore 35 and 36, it's line numbers from vim
13:41:58 <jmcarthur> Twey: ;)
13:45:45 <jmcarthur> FliPPeh: in mine, i pair it with zero (initial value to use in place of where the quotient is in subsequent steps), then scan over a list of divisors, applying to the quotient of each previous step, then drop the head since it's just the initial value, then convert the remainders to strings and append units to them, then make the whole thing a single string
13:45:59 <jmcarthur> should have used unwords instead of intercalate " " though, but i was dumb
13:46:09 <jmcarthur> should have probably done a few other things better too
13:46:30 <pokoko222> some of you math ninjas has done proofs with prolog? or even thought of the possibility or coolness of such thing?
13:46:40 <fax> lol
13:46:52 <fax> pokoko222: I was just talking about this a moment ago actually (in -blah)
13:46:54 <jmcarthur> > unwords . reverse . zipWith (flip (++) . return) "smhd" . map (show . snd) . tail . flip (scanl (divMod . fst)) [60, 60, 24, maxBound :: Int] . flip (,) 0 $ 275653
13:46:55 <lambdabot>   "3d 4h 34m 13s"
13:47:17 <pokoko222> oh man, fax, can you copy the part where you talk, get it from archive? :O
13:47:26 <jmcarthur> o_O
13:47:29 <FliPPeh> jmcarthur: That both converts the seconds to d:h:m:s and renders it?
13:47:30 <FliPPeh> Now I get it.
13:47:37 <jmcarthur> FliPPeh: basically
13:48:21 <jmcarthur> i do wonder if scanr would have been smarter than scanl
13:48:28 <jmcarthur> no i suppose not
13:48:41 <jmcarthur> hmm, i guess i could have reversed the list of divisors though
13:48:52 <jmcarthur> yeah, there are a few things i could have explored to improve it, definitely
13:49:25 <jlouis> pokoko222: sure. I've done lots of proof work in Twelf, which is a prolog
13:49:30 <FliPPeh> I never really got those scans
13:49:34 <FliPPeh> Are they like fold?
13:49:35 <shapr> jlouis: hah, the name is getting you attention? :-)
13:49:42 <jmcarthur> FliPPeh: it's an accumulating fold, that's all
13:49:50 <jmcarthur> > foldl (+) 0 [1..5]
13:49:51 <lambdabot>   15
13:49:53 <jlouis> shapr: more than before...!
13:49:56 <jmcarthur> > scanl (+) 0 [1..5]
13:49:57 <lambdabot>   [0,1,3,6,10,15]
13:50:03 <FliPPeh> ah
13:50:08 <MisterN> :t scanl
13:50:09 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
13:50:29 <MisterN> @src scanl
13:50:29 <lambdabot> scanl f q ls = q : case ls of
13:50:29 <lambdabot>     []   -> []
13:50:30 <lambdabot>     x:xs -> scanl f (f q x) xs
13:54:05 <FliPPeh> Just "51 Days, 6 Hours, 15 Minutes, 51 Seconds"
13:54:09 <FliPPeh> My current output, looks fine
13:54:19 <FliPPeh> Using intercalate and map
13:54:44 <FliPPeh> @hpaste
13:54:45 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
13:55:03 <FliPPeh> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=8902#a8902
13:55:10 <FliPPeh> jmcarthur: That's what I came up with :)
13:56:22 <jmcarthur> FliPPeh: the reason i wrote mine out was to demonstrate not using tuples in that way ;)
13:56:34 <FliPPeh> I know I'm a tuple abuser :x
13:57:25 <jlouis> tuple abusers unite! wield your arrows!
13:57:31 <danderson> whoa, types can be eta-reduced
13:57:58 * danderson discovers new stuff
13:58:43 <not_nathan> Speaking of tuples.
13:59:21 <not_nathan> I was reading the Edison Libraries, and I was a little confused that Okasaki defined the types Maybe2 a b and Maybe3 a b c.
13:59:38 <not_nathan> Rather than just using Maybe (a,b) and Maybe (a,b,c).
13:59:59 <PepeSilvia> I remember my computer shut down when trying to cabal install something
14:00:25 <PepeSilvia> eh wrong channel
14:00:55 <MisterN> not_nathan: maybe he hates tuples :)
14:02:12 <aavogt> another option is   (Maybe a,Maybe b,Maybe c)
14:02:24 * kmc hates tuples
14:02:29 <not_nathan> MisterN : I suppose. I was wondering if it enabled easier type-level programming.
14:03:10 <not_nathan> Well, yeah, but data Maybe2 a b = Just2 a b or Nothing2
14:03:28 <jmcarthur> i doubt there are any inherent advantages
14:03:58 <jmcarthur> Maybe2 a b does have one less value than Maybe (a, b)
14:04:03 <MisterN> what's the popular parser framework du jour? :)
14:04:14 <jmcarthur> MisterN: parsec, but it's not *necessarily* the best
14:04:20 <jmcarthur> it's pretty good though
14:04:24 <not_nathan> Yeah. He does explicitly find infix expressions ugly, so the same sentiment probably passes to tuples.
14:04:48 <jmcarthur> Maybe _|_  is not expressible using Maybe2
14:04:51 <jmcarthur> err
14:04:53 <jmcarthur> Just _|_
14:04:55 <jmcarthur> sorry
14:05:26 <Twey> aavogt: Maybe (a, b, c) is not the same as (Maybe a, Maybe b, Maybe c)…
14:05:34 <MisterN> jmcarthur: is parsec popular because it's distributed with ghc?
14:05:45 <jmcarthur> MisterN: is it even anymore?
14:05:55 <FliPPeh> Nope
14:05:58 <aavogt> Twey: you can't express   (Nothing, Nothing, Just a) with the first
14:06:14 <Twey> aavogt: Right
14:06:27 <aavogt> and I would call that version Maybe3 too
14:06:40 <MisterN> jmcarthur: but it was in the past?
14:06:52 <jmcarthur> MisterN: i think it might have been. i don't remember for sure
14:07:04 <jmcarthur> MisterN: so many things use it that it finds it way into my installed libraries anyway
14:07:11 <Twey> Ooh, dbus-client works now
14:07:13 <MisterN> jmcarthur: there's a defunct page in the ghc space
14:07:20 <MisterN> http://www.haskell.org/ghc/docs/latest/html/libraries/parsec/Text-ParserCombinators-Parsec.html
14:07:35 <jmcarthur> eh
14:07:52 <jmcarthur> MisterN: i think the one that probably came with ghc was outdated anyway. hackage has some newer stuff
14:08:02 <jmcarthur> i think ghc used to include parsec 2
14:08:10 <MisterN> http://www.haskell.org/ghc/docs/6.8-latest/html/libraries/parsec/Text-ParserCombinators-Parsec.html
14:08:22 <MisterN> i didn't check which is the latest version to have it
14:08:36 <jmcarthur> MisterN: http://hackage.haskell.org/package/parsec
14:09:04 <jmcarthur> MisterN: there is a real world haskell chapter on using parsec, but i don't what version of parsec it teaches
14:09:09 <jmcarthur> *don't know
14:09:24 <MisterN> jmcarthur: it seems to use the version that used to come with ghc...
14:09:42 <jmcarthur> ah
14:10:01 <jmcarthur> MisterN: well, the api changes are not very big. parsec 3 supports ByteString and such now though, which is nice
14:10:15 <jmcarthur> there are some api changes too though, iirc
14:10:43 <MisterN> bryan o'sullivan says it's slow though: http://www.serpentine.com/blog/2010/03/03/whats-in-a-parser-attoparsec-rewired-2/
14:12:43 <Twey> It's slower than static parsing…
14:12:50 <Twey> But also more flexible
14:13:11 <jlouis> Different situations, different goals
14:13:21 <Twey> I guess so
14:13:27 <jlouis> That said, combinatorrent really wants an attoparsec parser :)
14:13:33 <Twey> There's… what's it called, Happy?  … if you want static parsing
14:13:38 <HugoDaniel> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24370#a24370  for numt = 2 it takes ages to work
14:14:56 <HugoDaniel> is it because of the ++ implementation of the vector pkg ?
14:31:59 <HugoDaniel> Stream concatenation is slow
14:34:30 <aavogt> HugoDaniel: are streams lists without []?
14:34:54 <kmc> i can concatencate two of those very quickly
14:37:16 <HugoDaniel> aavogt: streams are this: http://hackage.haskell.org/packages/archive/vector/0.5/doc/html/Data-Vector-Fusion-Stream-Monadic.html
14:37:54 <FliPPeh> Meh
14:38:13 <FliPPeh> Why does "read" turn "0.xx" to "2.0e-2..."
14:38:18 <FliPPeh> This isn't nice :(
14:38:46 <HugoDaniel> what ?
14:38:48 <HugoDaniel> it doesn't
14:38:53 <HugoDaniel> read turns a string into a double
14:38:54 <FliPPeh> Just [2.0e-2,6.0e-2,5.0e-2]
14:39:03 <HugoDaniel> (in your case)
14:39:17 <MisterN> FliPPeh_: why use Maybe around a list? :)
14:39:23 <mauke> > Just [2.0e-2,6.0e-2,5.0e-2]
14:39:24 <lambdabot>   Just [2.0e-2,6.0e-2,5.0e-2]
14:39:28 <mauke> it's show
14:39:34 <Cale> HugoDaniel: stream concatenation should fuse and be quite fast
14:39:34 <kmc> 2.0e-2 and 0.02 are the same value
14:39:36 <HugoDaniel> FliPPeh: if you want to show a Double then i recommend using printf
14:39:38 <mauke> > 0.02
14:39:39 <lambdabot>   2.0e-2
14:39:40 <FliPPeh> MisterN: Because the function could fail because of File IO
14:39:41 <kmc> unlike "2.0e-2" and "0.02"
14:39:50 <FliPPeh> MisterN: and I don't just want to return an empty list
14:39:57 <kmc> > 2.0e-2 == 0.02
14:39:58 <lambdabot>   True
14:40:28 <MisterN> FliPPeh_: how about Either or something?
14:40:50 <FliPPeh> Well, I could provide the error message, but meeehhhh
14:40:53 <FliPPeh> So much rewriting
14:41:01 <FliPPeh> I'll just default to "user drunk" error messages
14:41:16 <HugoDaniel> :)
14:41:23 <kmc> a successful empty list result is different from a failure
14:41:47 <FliPPeh> kmc: But if that list was indeed empty, it WILL be a failure
14:41:56 <FliPPeh> Because that list can't be empty unless there's an error
14:42:06 <kmc> ah, well i don't know what you're doing specifically
14:42:12 <FliPPeh> I'm reading the system load from /proc/loadavg
14:43:19 <kmc> MisterN, anyway, that's why.  better to augment our types with new values than to assign special meaning to existing values
14:43:38 <MisterN> kmc: well, Maybe isn't a very meaningful type
14:43:54 <MisterN> Nothing may mean error, or something else
14:43:57 <kmc> yeah, sometimes you want a custom type that's isomorphic to Maybe but with different names
14:43:59 <FliPPeh> I'll just leave them without conversion
14:44:04 <FliPPeh> Just ["0.03","0.02","0.02"]
14:44:07 <FliPPeh> Works good
14:44:17 <kmc> however it's at least a distinguished value
14:44:29 <FliPPeh> By teh way, any nice way to put the first 3 elements of a list into a triple?
14:44:32 <MisterN> [] is distinguished too :)
14:44:36 <FliPPeh> If not, I'll just stick with this
14:44:44 <kmc> FliPPeh, not really.  (\x:y:z:_ -> (x,y,z))
14:44:53 <FliPPeh> Thought so
14:44:57 <FliPPeh> I might add it later :)
14:45:23 <kmc> in C it's common practice for a function that can fail and otherwise returns a positive int to return simply "int" and produce -1 on error
14:45:51 <FliPPeh> Who in the right mind would do that in haskell?
14:45:54 <kmc> in Haskell we'd almost always want it to return Maybe Int even though -1 is technically distinct from the other return values
14:46:00 <FliPPeh> Maybe and Either provide excellent error handling
14:46:11 <MisterN> kmc: isn't there a type for positive integers in haskell?
14:46:28 <kmc> MisterN, there's a Natural type, i don't know if it's in standard libraries
14:46:44 <kmc> oh and there's Word64 etc.
14:46:56 <kmc> > [minBound :: Word64, maxBound]
14:46:57 <lambdabot>   [0,18446744073709551615]
14:46:59 <MisterN> kmc: if ghc was very very smart, it could do something like using -1 as Nothign for Maybe PositiveInt :)
14:47:05 <mtnviewmark> thinks unsigned/signed distinction in languages gives a false sense of security
14:47:24 <kmc> MisterN, it'd only be worth it if the value were also unboxed and strictified etc.
14:47:34 * mtnviewmark finds developers tend not to test the other bound!
14:47:36 * mux reaches the definition of a functor category hutton's introduction and his brain explodes all over the channel
14:47:52 <mux> categories in categories in categories...
14:47:53 <kmc> it's worth noting that the standard only requires 30 bits (?) of resolution in Int
14:48:03 <jlouis> mux: mmm
14:48:03 <FliPPeh> A great
14:48:05 <kmc> with the presumed extra 2 bits left for implementation use
14:48:06 <FliPPeh> I crashed VIM again
14:48:13 <MisterN> kmc: the other bits are probably used already
14:48:25 <kmc> not in ghc
14:48:25 <jmcarthur> BRAAAAINS
14:48:38 <kmc> but it provides a full 32 bits on 32-bit systems, iirc
14:49:38 <MisterN> kmc: too bad because portable programs can't use them
14:49:57 <kmc> or they can check maxBound :: Int first
14:50:22 <jmcarthur> i hate that pure functions will give different results on different architectures
14:52:11 <systemfault> Hmm
14:52:20 <systemfault> So the idea is to use Integer everywhere?
14:52:32 <systemfault> Even though it's slower?
14:52:35 <jmcarthur> systemfault: or Int8, Int16, Int32, Int64
14:53:01 <systemfault> jmcarthur: Int is probably faster though.
14:53:19 <systemfault> I guess it doesn't need to do any kind of bound checking
14:53:25 <lament> faster than Int32?
14:53:33 <Phyx-> jmcarthur: how's that
14:54:05 <jmcarthur> systemfault: even if it was faster, i'd prefer that it be used similarly to unsafePerformIO, which is intended to be used in ways that preserve referential transparency
14:54:23 <jmcarthur> Phyx-: consider minBound for example
14:54:31 <jmcarthur> Phyx-: different results on different architectures
14:54:57 <kmc> not even a function
14:55:07 <kmc> i think using Int over Integer is usually premature optimization
14:55:18 <kmc> unfortunately the standard library encourages it
14:55:39 <jmcarthur> kmc: any function using minBound :: Int indirectly is also suspect
14:55:39 <Twey> Thereby effectively limiting list length to maxBound :: Int
14:55:44 <Vanadium> Do we have handy benchmark that shows how much performance you gain by switching from Integer to Ints where it is appropriate?
14:55:45 <Phyx-> jmcarthur: yeah ok, like that, datatypes that are machine dependend.
14:55:52 <pastorn> hmmm...
14:55:53 <jmcarthur> Phyx-: for example, but not exclusively
14:55:59 <Twey> Vanadium: I don't think you really get any
14:56:02 <HugoDaniel> Cale: thanks, i was just messing things up in my code :P
14:56:11 <pastorn> there's no good 3D programming in haskell tutorial :/
14:56:15 <systemfault> Twey: If course you'll get an improvement..
14:56:17 <systemfault> (Of
14:56:21 <jmcarthur> Twey: no, there is a noticeable performance difference, sadly... at least in my experiences
14:56:22 <Twey> AIUI, Integers are basically the same as Ints until you exceed maxBound :: Int
14:56:27 <Twey> Hm, okay
14:56:29 * pastorn might start writing one
14:57:01 <MisterN> > -minBound::Int
14:57:02 <lambdabot>   -9223372036854775808
14:57:09 <MisterN> > minBound::Int
14:57:09 <lambdabot>   -9223372036854775808
14:57:15 <MisterN> why are these two the same?
14:57:32 <MisterN> ooh!
14:57:33 <kmc> MisterN, because you can't negate the smallest number in two's complement representation
14:57:35 <Twey> Overflow
14:57:42 <jmcarthur> > maxBound + 1 :: Int
14:57:43 <lambdabot>   -9223372036854775808
14:57:51 <Twey> Negative numbers have one more value in two's complement (what would otherwise be negative zero)
14:57:56 <kmc> pastorn, you can use OpenGL
14:58:02 <kmc> there are plenty of OpenGL tutorials
14:58:05 <mux> I suppose a tight loop doing arithmetic on Int and that get properly unboxed would be faster than the same one with Integer
14:58:13 <MisterN> > toInteger(maxBound::Int)-toInteger(minBound::Int)
14:58:13 <Twey> So the equivalent positive number overflows by one to the negative
14:58:14 <lambdabot>   18446744073709551615
14:58:22 <pastorn> kmc: noone that does anything advanced in haskell
14:58:27 <kmc> and no i don't think Integer will perform the same as Int within the Int range.  Int is more subject to strictness analysis and unboxing
14:58:29 <pastorn> no shaders or anything in haskell
14:58:31 <kmc> pastorn, i mean non-Haskell tutorials
14:58:35 <kmc> plus reading the API docs
14:58:38 <kmc> it's not ideal but worked for me
14:58:59 <MisterN> pastorn: hmm i think haskell could be used to generate shaders :)
14:59:00 <systemfault> On my stupid collatz test of yesterday.. With Word (0.145), with Integer (1.052)
14:59:13 <pastorn> kmc: i worked through the Riemer XNA tutorials this weekend, they were pretty amazing
14:59:26 <jmcarthur> :t (System.Info.os,System.Info.arch,System.Info.compilerName,System.Info.compilerVersion)  -- Phyx-: more pure values that are different on different architectures and compilers
14:59:27 <kmc> MisterN, like http://hackage.haskell.org/package/GPipe ?
14:59:27 <lambdabot> (String, String, String, Data.Version.Version)
14:59:27 <pastorn> MisterN: seen it happend :)
14:59:44 <MisterN> kmc: cool
14:59:56 <jmcarthur> MisterN: there's gpipe and something conal is working on (called shady, iirc)
15:00:16 <MisterN> hmm and it could also be used to generate OpenCL code if you have hardware for that :D
15:00:26 <Phyx-> jmcarthur: sure... but those are arguably by design
15:00:29 <jmcarthur> MisterN: we also have opencl bindings i think
15:00:35 <jmcarthur> Phyx-: yes, but i don't believe they should be pure
15:00:37 <pastorn> MisterN: you could also embed CG/GLSL in haskell... i used a program that generated GLSL based on parameters you gave it
15:00:53 <MisterN> jmcarthur: see, i just have to hypothesise that something is possible and PLOP it springs into existence :)
15:01:09 <Phyx-> jmcarthur: right, I could agree with that
15:01:17 <Twey> Russell would hate you
15:01:22 <HugoDaniel> can anyone help me to parallelize this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24372#a24372 ?
15:01:31 <pokoko222> anyone can recommend me ai companies i can apply for internship for summer in europe?
15:01:49 <Phyx-> @src System.Info.os
15:01:50 <lambdabot> Source not found. There are some things that I just don't know.
15:01:57 <HugoDaniel> or give me some hints
15:01:58 <MisterN> Twey: the mathematician?
15:01:59 <jmcarthur> MisterN: hypothesize about sets of all sets that do not contain themselves
15:02:02 <Phyx-> > os
15:02:03 <lambdabot>   Not in scope: `os'
15:02:06 <Twey> MisterN: The philosopher
15:02:31 <jmcarthur> > System.Info.os
15:02:32 <lambdabot>   Not in scope: `System.Info.os'
15:02:34 <MisterN> Twey: since when to philosophers do set theory?
15:02:34 <jmcarthur> :(
15:02:47 <Twey> Psht
15:02:48 <MisterN> jmcarthur: nah, some things i just don't hypothesize about :P
15:02:54 <ddarius> MisterN: There is quite a lot of logic and set theory in philosophy.
15:03:07 <MisterN> ddarius: don't disturb my prejudices!
15:03:14 <ddarius> s/logic/formal logic/
15:03:14 <Twey> Well, all of mathematics is philosophy really
15:03:21 <Twey> (unlike its black-sheep cousin, science)
15:03:26 <mux> Prelude System.BSD.Sysctl> sysctlReadString "kern.ostype"
15:03:26 <mux> "FreeBSD"
15:03:30 * mux grins
15:03:36 <mux> @version
15:03:36 <lambdabot> lambdabot 4.2.2.1
15:03:36 <lambdabot> darcs get http://code.haskell.org/lambdabot
15:03:49 <mux> lambdabot used to say it runs on an OpenBSD 64bit box, IIRC
15:04:22 <Twey> Does she?
15:04:33 <MisterN> ddarius: you know the joke: Physicists need expensive technology to operate their experiments, mathematicians only need paper, pencils and a wastebasket - philosophers only need paper and pencils.
15:05:03 <Twey> They're all the same really
15:05:08 <Twey> Just ask Aristotle
15:05:20 <jmcarthur> mux: i still have a desire to use freebsd
15:05:24 <ddarius> Well the applications of formal logic in philosophy have a, uh... different feel...
15:05:31 <Twey> I have never had a desire to use FreeBSD
15:05:36 <HugoDaniel> is there any quick and dirty way to parallelize a foldr ?
15:05:39 <mux> to each his own
15:05:48 <ddarius> foldr is inherently sequential.
15:05:49 <Twey> I once flirted with OpenBSD, but I was quickly disillusioned :þ
15:05:57 <jmcarthur> HugoDaniel: if the operation is associative, perhaps
15:05:58 <MisterN> Twey: i think it makes sense to define philosophy in a way that excludes mathematics :)
15:06:04 <Twey> MisterN: Why?
15:06:15 <mux> if it could be written as mconcat rather than foldr, it's parallelizable
15:06:21 <HugoDaniel> jmcarthur: the operation is this:  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24372#a24372
15:06:24 <MisterN> Twey: because there's no reason not to
15:06:33 <medfly> MisterN, haha :)
15:06:34 <Twey> MisterN: Apart from the fact that they're actually the same thing
15:06:40 <medfly> MisterN, I didn't hear the part with the philosophers.
15:06:45 <Twey> Just with fancy notation on the mathematics side :þ
15:06:50 <MisterN> medfly: but that was the best part :)
15:07:02 <medfly> that's probably about right :-p
15:07:03 <jmcarthur> HugoDaniel: yeah, (++) is associative, but i suspect you might have better luck just trying to avoid using (++)
15:07:13 <ddarius> http://tedsider.org/books/lfp.html
15:07:15 <Twey> (fancy inconsistent heavily overloaded notation >.>)
15:07:37 <HugoDaniel> jmcarthur: what do you recommend ?
15:07:43 <mux> jmcarthur: note this is (++) from Data.Vector.Storable
15:07:46 <medfly> Cale, what kind of box does lambdabot run on?
15:07:48 <jmcarthur> HugoDaniel: what is this algorithm?
15:07:55 <jmcarthur> mux: still associative
15:08:02 <MisterN> mux: doesn't that have Monoid?
15:08:04 <mux> but yes, this is an associative operation, and this algorithm could be written as an mconcat
15:08:11 <mux> so you can parallelize it
15:08:12 <jmcarthur> mux: and not necessarily easy to fuse into something fast
15:08:24 <mux> sparks should help here, I guess
15:08:34 <HugoDaniel> jmcarthur: it is no algorithm, im just separating a vector into several ones, so that i can now parallelize the generate function, because the generator is sequential
15:08:37 <mux> given that the monoidal operation doesn't look really expensive
15:08:41 * Twey goes to bed
15:08:50 <HugoDaniel> jmcarthur: here: http://hackage.haskell.org/packages/archive/vector/0.5/doc/html/Data-Vector-Storable.html#v%3Agenerate
15:09:00 <jmcarthur> HugoDaniel: oh so you are only wanting to do a parallel map?
15:09:05 <HugoDaniel> yes
15:09:29 <mux> :t parMap
15:09:30 <lambdabot> forall b a. Strategy b -> (a -> b) -> [a] -> [b]
15:09:37 <jmcarthur> yeah i don't think i'd recommend splitting and recombining your vector then
15:09:42 <jmcarthur> mux: that won't work for vector
15:09:46 <MisterN> @hoogle Strategy
15:09:47 <lambdabot> Control.Parallel.Strategies type Strategy a = a -> Done
15:09:47 <lambdabot> Codec.Compression.GZip data CompressionStrategy
15:09:47 <lambdabot> Codec.Compression.Zlib data CompressionStrategy
15:10:07 <mux> how can you not mention parMap when talking about a parallel map? :-)
15:10:23 <Cale> > maxBound :: Integer
15:10:24 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Integer.Internals.Integer)
15:10:25 <lambdabot>    arising...
15:10:25 <Cale> > maxBound :: Inte
15:10:26 <lambdabot>   Not in scope: type constructor or class `Inte'
15:10:26 <Cale> > maxBound :: Int
15:10:27 <lambdabot>   9223372036854775807
15:10:51 <HugoDaniel> jmcarthur: what do you recommend ? the function that gets the index is a pure function
15:11:04 <Cale> hmm
15:11:08 <Cale> model name	: Intel(R) Xeon(R) CPU           L5520  @ 2.27GHz
15:11:32 <Cale> Mem:        368836     245032     123804          0      12976     134172
15:11:42 <HugoDaniel> sequentially it takes about 9s to complete a vector of size 262144
15:12:13 <jmcarthur> HugoDaniel: hmm... i dunno :)
15:12:24 <Cale> /dev/xvda              14G  3.0G   11G  21% /
15:12:35 <MisterN> Cale: why do you paste your system info?
15:12:46 <MisterN> Cale: you can use uname to find out whether it's 64-bit :P
15:13:19 <jmcarthur> dons: any way for HugoDaniel to parallelize his map over a vector?
15:13:47 <Cale> MisterN: It's actually not my system info
15:14:02 <MisterN> Cale: why do you paste other people's system info?!
15:14:03 <Cale> It's the system info for the machine that lambdabot's running on.
15:14:08 <Cale> because medfly asked
15:14:52 <jmcarthur> HugoDaniel: you could always give dph a shot :)
15:15:03 <HugoDaniel> ok
15:15:07 <HugoDaniel> where can i read about it ?
15:15:21 <jmcarthur> HugoDaniel: but i don't think it's far enough along to call mature
15:15:32 <HugoDaniel> i see
15:15:38 <jmcarthur> HugoDaniel: i'm trying to just stick with options related to what you're doing
15:15:44 <HugoDaniel> ok
15:15:49 <jmcarthur> HugoDaniel: you could always convert to a list, use parMap, then convert back
15:15:54 <jmcarthur> it won't be as fast though
15:16:45 <HugoDaniel> using V.fromList (with a list comprehension as argument) takes about 11s to generate sequentially
15:17:17 <monoidal> has anyone installed lambdabot on 6.12? I'm getting "cannot configure show-0.3.4. It requires QuickCheck <2", but am able to cabal install show-0.3.4
15:17:30 <HugoDaniel> so... lets say i do it like: V.fromList $ parallelizeTheList $ [ f blah | ....
15:17:37 <HugoDaniel> what would parallelizeTheList be ?
15:17:47 <dons> jmcarthur: mmm only with DPH at the moment
15:17:55 <dons> or manually implementing DPH's gang threads.
15:18:07 <dons> [: f x | x <- xs :] -- works in DPH now
15:18:09 <cebewee> Does anyone know how to unescape bytea-strings returned by Data.HDBC.Postgres?
15:18:15 <dons> you might even be able to then stream the array into a vector
15:18:28 <dons> hey HugoDaniel :)
15:18:33 <HugoDaniel> hey dons :)
15:21:16 <jmcarthur> hmm, streaming the array into a vector sounds like it could be nice enough
15:23:09 <MisterN> 666 users, omg
15:23:30 <Ke> yikes
15:23:32 <c_wraith> quick, someone leave or enter, but not an equal number of each
15:23:55 <stevenmarky> uhhh
15:23:55 <monochrom> rw-rw-rw-
15:24:14 <c_wraith> what's that string that crashes a bunch of routers?
15:24:21 <Eridius> startkeylogger?
15:24:24 <dons> i think map is one of the things in dph that works pretty well
15:24:39 <Eridius> ah right DCC SEND startkeylogger 0 0 0
15:24:58 <jlouis> dons: I went with IOUArrays for now. The space is more important than speed at the moment
15:25:04 <Phyx-> tsl
15:25:19 <Phyx-> any decent client would block that
15:25:23 <jlouis> And I got a neat use of Data.PSQueue :)
15:25:36 <ddarius> dons: I would think it would work extremely well.
15:28:26 <dons> ddarius: i imagine so. i've had ok luck with dph parallel (non-distributed) arrays
15:28:52 <jmcarthur> what does distributed mean in this context?
15:29:13 <jmcarthur> is there work on getting dph to work on multiple machines?
15:29:45 <Adamant> Phyx-: it was crashing routers, not clients
15:30:01 <Adamant> because they tried to block it by dropping the connection
15:30:03 <Adamant> IIRC
15:30:15 <Adamant> consumer-level routers.
15:30:35 <c_wraith> not really crashing them.  just making them disconnect them from IRC
15:30:58 <Adamant> yeah, it was just a connection drop
15:32:48 <dons> distributed arrays in DPH have explicit Dist types to track what each thread is working on
15:33:04 <dons> but dph-par also has parallel arrays without that stuff.
15:33:41 <jmcarthur> oh i see
15:35:12 <HugoDaniel> is dph a ghc patch ? or a pkg i can install ?
15:39:26 <pokoko222> recommend me AI companies in europe for summer internships please, any areas, i will filter myself what i can apply for....
15:44:16 <fredune> HaskellDB, dead or alive?
15:44:38 <monochrom> false dichotomy
15:45:17 <Entroacceptor> ha!
15:45:24 <Entroacceptor> another use for enum bool
15:45:33 <Eridius> dead, alive, or FileNotFound
15:46:33 <djahandarie> Man Quantum Computing is so interesting
15:46:46 <djahandarie> There isn't a single course on it at my uni though. :-[
15:46:49 <Entroacceptor> or, as Pratchett said 'dead, alive, bloody furious'
15:47:34 <stevenmarky> are there quantum computing course at any uni?
15:47:41 <stevenmarky> courses*
15:47:52 <djahandarie> Yes
15:48:21 <djahandarie> Such as MIT
15:48:49 <Adamant> monochrom: that which is not dead may eternal eons lie?
15:49:19 <Entroacceptor> till even death gets garbage collected
15:49:30 <djahandarie> There is professor here who has published papers about quantum computing so I may go talk to him soon
15:50:52 <djahandarie> Hell, I've actually read one of his papers before O.o
15:51:26 <djahandarie> Odd things one discovers.
15:53:43 <jlouis> fredune: we are not pirates, we are ninjas
15:54:21 <djahandarie> Man, thanks a lot debian for putting 6.12 in testing and breaking half of the other haskell packages
15:55:09 <monochrom> hahaha
15:55:19 <djahandarie> -_-
15:55:32 <monochrom> staying with 6.10 breaks other expectations
15:56:12 <monochrom> I can hear other people saying "thanks ubuntu for staying 6.10 and breaking the latest cabal version"
15:56:58 <djahandarie> I think it was still on 6.8 before this
15:57:04 <fredune> jlouis: aargh, here be pirates jim lad
15:57:09 <MisterN> why does cabal rely on 6.12 features so quickly?
15:57:23 <djahandarie> Because 6.12 is the hip thing atm
15:57:37 <djahandarie> I hear cabal is forcing the LLVM backend
15:57:38 <djahandarie> LOL
15:57:40 <djahandarie> jk
15:57:40 <MisterN> well maybe but a package manager should be robust and conservative, right?
15:58:51 <jlouis> djahandarie: it is somewhat stable in unstable :)
15:59:20 <djahandarie> Bah
15:59:32 <djahandarie> I was hoping to not have unstable on this computer
15:59:36 <djahandarie> Oh well screw it
15:59:45 <djahandarie> Might as well just go compile everything from source
16:01:45 <pickles> rofl, i just noticed there are 666 ppl in the room
16:01:57 <pickles> does that make haskell evil?
16:01:59 <djahandarie> (this was pointed out earlier)
16:02:03 <monochrom> rw-rw-rw-
16:02:09 <pickles> heh, sry, haven't been following :-/
16:02:15 <EvanR> oh pickles
16:02:23 <EvanR> the clown of #haskell
16:02:23 <dons> pickles: haskell's ascendancy is a sign of the coming apocalypse
16:02:25 <EvanR> ;)
16:02:38 <pickles> oh comon, the "darkone" entering the room when it has 666 members? tell me that's not hilarious
16:02:53 <pickles> awesome timing, darkone
16:03:00 <stevenmarky> hoho
16:03:01 <EvanR> hahaha
16:03:24 <MisterN> djahandarie: it was a different set of users back then
16:03:37 <MisterN> so pointing it out each time is not an impure thing to do
16:03:50 <pickles> perhaps we should just memoise it
16:03:53 <c_wraith> anyone have a pointer to any resources about interactions between the threaded runtime and FFI?
16:03:53 <monochrom> hahahahaha
16:04:21 <fredune> Could someone update the haskelldb website ? The repo link should be code.haskell.org/haskelldb.
16:04:37 <dons> fredune: the maintainers of haskelldb
16:04:44 <dons> you'll likely need to conntact thhem
16:04:55 <c_wraith> in particular, I was told the threaded runtime uses SIGALARM to schedule thread changes, and that could cause issues if it occurred in FFI code that wasn't expecting it
16:06:36 <EvanR> how do i suspend a thread indefinitely
16:06:45 <dons> forever (threadDelay N)
16:06:46 <c_wraith> wait on an mvar
16:06:54 <EvanR> ah
16:06:58 <EvanR> yeah forever didnt appeal to me
16:06:59 <pickles> send it to juvi?
16:07:11 <dons> well, if the rts can detect the MVar will never fill
16:07:13 <dons> that might not work.
16:07:26 <fax> -_-
16:07:28 <c_wraith> waiting on an MVar has the nice property that it can be woken.
16:07:32 <jlouis> You need to keep the MVar around yes
16:07:44 <dons> well, threadDelay can be woken by an async exceptionn
16:07:45 <EvanR> waiting on isnt enough?
16:07:46 <mauke> forever (threadDelay maxBound)
16:07:58 <dons> so they're semantically equivalent, but implementation-wise not so similar
16:08:22 <jlouis> The ability to detect MVars on which the other end disappeared is one of the things which make Haskell concurrency programming different from Erlang concurrency programming
16:08:25 <monochrom> takeMVar v >> putMVar v ()
16:08:43 <dons> jlouis: yes. is that good or bad do you think?
16:09:10 <EvanR> monochrom: so is THAT going to work? :)
16:09:14 <EvanR> or is the runtime even smarter
16:09:24 <jlouis> dons: It makes you be able to fire-n-forget with forkIO and have the GC clean up afterwards. That is a pretty neat programming idiom for some things
16:09:53 <Vanadium> What about circular thread references? :<
16:10:05 * pickles decides to forego making a child support joke on the phrase "fire-n-forget"
16:10:08 <monochrom> How do you know that a thread is suspended rather than killed?
16:10:19 <jlouis> Vanadium: I would expect it to use a mark-n-sweep
16:10:31 <c_wraith> I'd assume the reason you want it to suspend rather than kill is so that eventual resumption is possible
16:10:34 <dons> monochrom: if it is killed, then it'll be GC'd and the reference to the mvar will be dropped
16:10:59 <Vanadium> Hm, starting where?
16:11:00 <dons> leading to a black hole exception on the thread waiting for that result, i think
16:11:03 <Vanadium> The main thread?
16:11:05 <dons> interesting. and you'd be able to catch that too
16:11:13 <EvanR> c_wraith: well, in main i fork a few threads, but main is useless. do i have to suspend forever to avoid ending everything early?
16:11:19 <dons> EvanR: yeah
16:11:23 <jlouis> EvanR: yup
16:11:25 <EvanR> ok
16:11:32 <pickles> shouldn't the mvar ref be retained if it's still pointed to by something else?
16:11:34 <EvanR> thats the application, so the mvar thing
16:11:35 <dons> have the main thread wait on the children to indicate they're done, for example.
16:11:40 <dons> pickles: oh certainly.
16:11:55 <c_wraith> or wait on an mvar that a child thread can populate in order to indicate it's time for the program to terminate
16:11:56 <dons> but the rts will spot that e.g. you're 'take'ing on something that no thread is put'ing to
16:11:59 <EvanR> how do you wait for all children to be done?
16:12:07 <EvanR> actually none of the children will be done
16:12:09 <EvanR> they are permanent
16:12:09 <pickles> ah
16:12:10 <dons> there's an example in the Control.concurrent docs
16:12:30 <dons> use a semaphore/mvar for example. inc per thread, dec as they finish.
16:12:38 <EvanR> im depending on control c or SIGTERM to end the program
16:12:38 <dons> if they never finish, just use the main thread for some work
16:12:48 <pickles> i have yet to get to the rwh chapter on concurrency, so i think ill keep my mouth shut for time being
16:12:50 <dons> signals are interesting.
16:13:06 <jlouis> beware that the main thread is forkOS though
16:13:18 <jlouis> so ctx-switching to it is bloody expensive
16:13:23 <dons> well, communication is cheaper between forkIO's than via the main thread
16:13:33 <EvanR> really now
16:14:10 <dons> its only noticeable in high performance situations
16:14:13 <dons> like microbenchmarks
16:15:06 <monochrom> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24376#a24376  works
16:16:01 <dons> nice trick
16:16:22 <dons> the rts can't spot the problem in your reasoning :)
16:17:02 <EvanR> pretty awesome ;)
16:17:04 <Alpounet> why does it work ?
16:17:05 <monochrom> It takes two hands to clap. It takes two persons to dance. But it doesn't take two threads to deadlock. :)
16:17:14 <monochrom> Because v is still referenced.
16:17:29 <dons> hmm. actually takeMVar without the reference seems to work!
16:17:39 <dons> which surprises me greatly
16:17:43 <c_wraith> even with -O2 ?
16:17:46 <dons> deadlock detection broken?
16:17:47 <dons> yes
16:17:57 <EvanR> sleepForever = do {v <- newEmptyMVar; takeMVar v; putMVar v ();}
16:18:40 <EvanR> heh. i guess as soon as they have perfect deadlock detection they will make a function to suspend the thread indefinitely, as there will be no other way ;)
16:19:17 <MisterN> :t takeMVar
16:19:18 <lambdabot> Not in scope: `takeMVar'
16:19:57 <MisterN> EvanR: is perfect deadlock detection even possible, theoretically?
16:20:08 <dons> no
16:20:17 <EvanR> hell if i know
16:20:33 <dons> you can only approximate it
16:20:55 <monochrom> In the limit, I'll just use a Diophantine equation to fool deadlock detection.
16:21:39 <EvanR> lol
16:21:43 <dons> yeah, you just put something in there that forces the deadlock detector to solve the halting problem to work out if an mvar is going to be updated
16:22:04 <EvanR> halting problem detection
16:22:12 <EvanR> 'is this algorithm solving the halting problem' yes no
16:22:18 <enthymeme> hehe
16:22:26 <HugoDaniel> it is currently taking me 9s to generate a 512x512 pixels perlin texture :(
16:22:48 <dons> HugoDaniel: perhaps put the code somewhere and ask for help :)
16:22:53 <dons> and profile!
16:22:59 <dons> -O2 -prof -auto-all
16:23:06 <HugoDaniel> ah ok!
16:23:08 <HugoDaniel> yes, ok
16:23:42 <HugoDaniel> ill focus on finishing out what i need to upload it to hackage and then try to think about optimizing it
16:23:46 <enthymeme> there's a funny error you can get out of swi-prolog
16:24:02 <enthymeme> in reference to The Hitchiker's Guide to the Galaxy
16:24:03 <dons> HugoDaniel: are you compiling with -O2 ?
16:24:11 <fax> hehe I have seen that
16:24:36 <fax> I couldn't actually figure out what the heck it meant for a long time
16:24:38 <HugoDaniel> dons: ghc -threaded -O2 -fvia-C -optc-O3 --make Main.hs -o t && time ./t
16:24:48 <dons> ok. good
16:24:53 <dons> and STUArray ?
16:24:55 <dons> or vector ?
16:24:58 <jlouis> criterion?
16:25:06 <dons> yeah, benchmarking later.
16:25:33 <HugoDaniel> vector
16:25:42 <FliPPeh> Yuck
16:25:44 <HugoDaniel> but the noise functions are all pure
16:25:51 <HugoDaniel> they dont depend on that
16:26:10 <FliPPeh> This is getting out of hand will all the "L.unpack . L.dropWhile (== '.') . L.takeWhile (/= ':')"
16:26:15 <FliPPeh> :(
16:26:22 <HugoDaniel> the texture generation stuff is all just testing... tomorrow ill think more about this
16:26:25 <HugoDaniel> thanks for the support
16:26:38 <dons> FliPPeh: unpacking is a bad idea. usually.
16:26:52 <FliPPeh> dons: I only unpack to apply "read" on it
16:27:02 <FliPPeh> And once they're unpacked, there's no more "modifying"
16:27:03 <dons> FliPPeh: read of a numeric value?
16:27:06 <FliPPeh> Just display
16:27:09 <FliPPeh> dons: Yup
16:27:18 <dons> use the readInt/readInteger/readDouble functions
16:27:24 <dons> in bytestring and bytestring-lexing
16:27:28 <dons> much much faster than unpack
16:27:36 <dons> unless maybe you don't care
16:27:43 <FliPPeh> Hmm
16:27:46 * hackagebot nonlinear-optimization 0.3.2 - Various iterative algorithms for optimization of nonlinear functions.  http://hackage.haskell.org/package/nonlinear-optimization-0.3.2 (FelipeLessa)
16:28:02 <FliPPeh> I don't think this is critical in here, I'm only dealing with maximum of 100 bytes
16:28:07 <dons> ah ok
16:28:13 <FliPPeh> But I'm definitly going to remember it
16:28:17 <FliPPeh> Thanks :)
16:28:30 <FliPPeh> @hpaste
16:28:31 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
16:28:36 <hkarim> how do you flatten a list of lists, like [1, [[2]], 3, ]
16:28:52 <dancor> > [1, [[2]])
16:28:53 <lambdabot>   <no location info>: parse error on input `)'
16:28:55 <dancor> > [1, [[2]]]
16:28:55 <kmc> :T concat
16:28:56 <lambdabot>   No instance for (GHC.Num.Num [[t]])
16:28:56 <lambdabot>    arising from the literal `1' at <int...
16:28:58 <Eridius> hkarim: how do you have a list like that in the first place?
16:29:00 <kmc> hkarim, [1, [2]] is a type error
16:29:02 <dons> hkarim: that's not valid haskell
16:29:04 <hkarim> sorry, like [[1]], [[2]]]
16:29:05 <dankna> how do you even HAVE a heterogeneous list of lists like that?
16:29:08 <fax> hkarim, list of lists doesn't exist :P
16:29:10 <kmc> (unless you have a num instance for [Int] or so, which is unlikely)
16:29:14 <kmc> uh what
16:29:16 <FliPPeh> How would you improve this function? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=8904#a8904
16:29:20 <kmc> a list of lists exists
16:29:24 <FliPPeh> Ignore stuff like "readOrFail" here
16:29:25 <dancor> :t concat
16:29:25 <kmc> > concat [[1,2], [3,4]]
16:29:26 <lambdabot> forall a. [[a]] -> [a]
16:29:26 <fax> kmc: 23:28 < hkarim> how do you flatten a list of lists, like [1, [[2]], 3, ]
16:29:27 <lambdabot>   [1,2,3,4]
16:29:29 <FliPPeh> I just mean the "parsing"
16:29:57 <dancor> signal to noise ratio not so good today
16:30:13 <dons> 666
16:31:46 <hkarim> thanks
16:33:09 <zakwilson> I am, after a year still a bit of a Haskell newb. Whenever I have to do IO, I feel like I'm assembling a puzzle. Does that lessen significantly with practice?
16:33:28 <kmc> yes
16:33:47 <EvanR> im finding that lots of IO code doesnt need to be there
16:33:52 <pickles> i too am a haskell yearling, and the confusion has lessened for me a bit
16:33:53 <kmc> this also
16:34:15 <FliPPeh> I'm always struggling with string parsing
16:34:21 <FliPPeh> The one too easy for parsec
16:34:29 <FliPPeh> But looking ugly with just "take" and "drop"
16:34:37 <kmc> yeah, there are not good string manipulation primitives built in
16:34:44 <kmc> the solution is to learn to use Parsec even for trivial stuff ;)
16:34:56 <kmc> after several years of experience, the IO monad feels about as good as any other imperative language
16:34:58 <Vanadium> Are we not supposed to use attoparsec at this point?
16:35:01 <kmc> better in some ways, worse in others
16:35:15 <pickles> it would seem like overkill to use parsec for that type of thing, but it's so easy to use!
16:35:28 <zakwilson> Simple stuff with Parsec is, indeed really easy.
16:35:39 <EvanR> im about to get into that string stuff. in particular, i need to turn foo.bar.baz.domain.com into domain.com, not sure how to tackle that one
16:35:42 * shapr boings cheerfully
16:35:42 <zakwilson> I use it in situations where it seems like overkill.
16:35:52 <FliPPeh> Even stuff like "Read 3 doubles from the first line of a file" ?
16:35:57 <FliPPeh> That seems like TOO easy
16:36:01 <kmc> pickles, likewise it seems like overkill in most languages to use threads for simple problems, but it isn't in haskell
16:36:07 <FliPPeh> map L.unpack . take 3 . L.words
16:36:17 <EvanR> wait
16:36:20 <MisterN> :t L.unpack
16:36:21 <lambdabot> Not in scope: `L.unpack'
16:36:24 <EvanR> cant you just... read three doubles
16:36:24 <kmc> but it might be overkill to use a mutable hash table, whereas that'd be totally reasonable in another language
16:36:27 <pickles> kmc: i'll have to take your word for it as i've yet to do parallel stuff in haskell
16:36:44 <kmc> pickles, it's easy! http://donsbot.wordpress.com/2009/09/05/defun-2009-multicore-programming-in-haskell-now/
16:36:50 <kmc> also see the last few chapters in RWH
16:37:01 <pickles> yeah, i have yet to get to those RWH chapters
16:37:03 <kmc> btw we make a distinction between parallel and concurrent
16:37:09 <pickles> thx for the link
16:37:22 <kmc> explicit threads are required for concurrent programs but not for parallel evaluation of semantically-sequential programs
16:37:29 <pickles> hm
16:37:31 <dankna> EvanR: reverse $ fst $ split (findElem '.' $ reverse input) $ reverse input
16:37:34 <dankna> will give you the com
16:37:38 <dancor> FliPPeh: parsec gives you better erros right?
16:37:39 <dankna> modify suitably for the domain.com
16:37:43 <dancor> errors
16:37:46 <kmc> i.e. if you just have a big expression that you want to munch on several cores at once, you don't have to break it into IO actions and spawn off threads
16:37:47 <FliPPeh> dancor: Yep
16:37:59 <EvanR> dankna: ehm, hmm :\
16:38:04 <pickles> ah
16:38:12 <pickles> so that would qualify as parallel
16:38:15 <kmc> yes
16:38:18 <pickles> gotcha
16:38:22 <dankna> EvanR: yeah I know, but it works.  it could be made prettier with a let but then I couldn't fit it on one line :)
16:38:28 <zakwilson> EvanR: what you need is a string split function. There doesn't seem to be one in the prelude, but you can find several examples with Google.
16:38:31 <kmc> concurrent means that the semantics of the program depend on treating it as several things going on at once
16:38:35 <kmc> and, that can be useful even with one core
16:38:39 <EvanR> zakwilson: right, thats it
16:38:46 <pickles> right
16:38:46 <EvanR> split on '.', last two
16:38:51 <EvanR> join .
16:39:06 <pickles> it had never occurred to me to consider the distinction between the two
16:39:10 <zakwilson> then it becomes take 2 $ reverse (split '.' foo)
16:39:22 <kmc> of course you can have the two together in one program, and if you write things concurrently you often get parallel work for free... but you have to be a little careful because the standard thread communication channels are still fully lazy, so you can pass an unevaluated thunk to another thread
16:39:44 <FliPPeh> Can parsec work with ByteStrings?
16:39:49 <dankna> but of course it's not called split because there is a Prelude function by that name (it takes an index)
16:39:54 <kmc> pickles, me either until i studied haskell
16:39:57 <pickles> and that would be a problem if it were a big thunk when the result was an int
16:40:20 <dankna> deintercalate maybe :)
16:40:59 <benmachine> FliPPeh: parsec has a very generalised underbelly, it can work with most things
16:41:06 <kmc> it's mostly a problem if you're depending on the work being done here vs. there
16:41:09 <FliPPeh_> Nice
16:41:11 <danderson> is there an existing concurrency library which implements the concept of erlang process groups?
16:41:15 <pickles> i will be interested to see how haskells parallel programming compares to the relatively little erlang i've done
16:41:32 <benmachine> FliPPeh: oh, and there's a Text.Parsec.ByteString, which would possibly hint at yes
16:41:37 <eb4890> Couldn't you use break?
16:41:41 <danderson> I'd like to fire off two threads, with the property that both should die if one dies
16:42:04 <eb4890> :t break
16:42:05 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
16:42:24 <EvanR> split :: a -> [a] -> [[a]]
16:42:28 <EvanR> break?
16:42:36 <FliPPeh_> I only have "Text.Parsec.ParserCombinators.Parsec"
16:42:43 <FliPPeh_> Is it a separate package?
16:43:00 <benmachine> err, do you mean Text.ParserCombinators.Parsec?
16:43:10 <EvanR> eb4890: well, whats the predicate for 'second to last .'
16:43:13 <FliPPeh_> yes
16:43:14 <FliPPeh_> Sorry
16:43:16 <benmachine> right
16:43:19 <benmachine> that's parsec 2
16:43:26 <benmachine> which probably doesn't handle bytestrings
16:43:38 <benmachine> if you install parsec 3 then you will get Text.Parsec
16:44:13 <dancor> is there any resolution on the "parsec 3 is slow" issue
16:44:24 <benmachine> I believe parsec 3.1 is supposed to address that
16:44:32 <benmachine> and should be comparable to parsec 2 now
16:44:39 <benmachine> but don't quote me on that
16:44:49 <dancor> ah, i was wondering if it was like Data.Map vs Data.IntMap
16:44:56 <eb4890> EvanR: Ah, I see. I was a bit late and didn't know the exact thing you were trying to do.
16:45:22 <dancor> and there might be some plans to make Data.Map Int secretly be faster like Data.IntMap?
16:45:22 <EvanR> would be nice ;)
16:45:51 <dancor> but it requires some future haskell extension
16:46:19 <benmachine> that sounds a bit like a data families thing
16:46:20 <kmc> you can do it now with datatype families can't you?
16:46:20 <benmachine> but
16:46:29 <benmachine> I've never use data families so I don't know
16:48:47 <dancor> is it impossible to get a combinator parser that is O(n^3) (like CYK algorithm) instead of exponential?
16:49:26 <fax> dancor, I think you can get an O(n) parser
16:50:01 <FliPPeh_> How do I use parsec to read a double value?
16:50:13 <EvanR> can you just use read
16:50:27 <EvanR> :t read
16:50:28 <lambdabot> forall a. (Read a) => String -> a
16:50:33 <kmc> but you have to match the string first
16:50:36 <FliPPeh_> It's 3 double values in a row
16:50:39 <FliPPeh_> In a string
16:50:46 <EvanR> split on space ;)
16:50:50 <eb4890> EvanR: You could use regular expressions. People were talking about them last time I was on. I've seen some examples, but don't know quite how they work...
16:50:53 <dancor> fax: i thought O(n^3) was best worst-case that had been found?
16:50:53 <eb4890> > "jim.bob.bar.com" =~ "([a-z]+).([a-z]+)$" :: [[String]]
16:50:54 <lambdabot>   [["bar.com","bar","com"]]
16:51:05 <EvanR> eb4890: right...
16:51:09 <kmc> Text.ParserCombinators.Parsec.Token	will build a Double parser
16:51:11 <dancor> for arbitrary CFG parsing
16:51:13 <kmc> from a LanguageDef
16:51:15 <EvanR> but are regex hated and ridiculed in haskell
16:51:23 <kmc> see also Text.ParserCombinators.Parsec.Language
16:51:43 <pickles> would: (oneOf ['0'..'9']) ; char "."; (many (oneOf ['0'..'9']))   work?
16:52:00 <pickles> or something like
16:52:32 <benmachine> EvanR: regex in haskell aren't bad, it's just that things like parsec are so lovely we tend to forget about them
16:53:41 <pickles> for the domain name thing (if we're still discussing that), could just do a split on '.' and take the last two?
16:54:18 <EvanR> i already brought that up
16:54:24 <EvanR> split would need to be written custom though
16:54:26 <kmc> i dislike the Haskell regex API (but have not used it terribly much)
16:54:29 <pickles> man, i really need to pay attemtion
16:54:45 <kmc> seems unusual and un-idiomatic to use a single function for a bunch of different things overloaded only based on return type
16:54:54 <pickles> i seem to be repeating others tonite
16:55:26 <EvanR> probably going to use the split method
16:55:32 <sshc> kmc: Which package provides the "Haskell regex API"?
16:55:51 <eb4890> @hoogle ~=
16:55:51 <lambdabot> Test.HUnit.Base (~=?) :: (Eq a, Show a) => a -> a -> Test
16:56:04 <eb4890> @hoogle =~
16:56:04 <lambdabot> Text.Regex.Posix.Wrap (=~) :: (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target) => source1 -> source -> target
16:56:05 <lambdabot> Text.Regex.Posix.Wrap (=~~) :: (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target, Monad m) => source1 -> source -> m target
16:56:05 <kmc> Text.Regex.Base.RegexLike	i guess
16:56:09 <kmc> :t (=~)
16:56:10 <lambdabot> forall source1 source target. (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target) => source1 -> source -> target
16:56:24 <kmc> note how its type is basically a -> b -> c
16:56:42 <pickles> easy as 1 2 3
16:58:10 <sshc> kmc: How does it behave differently and what's wrong with that?
16:58:46 <kmc> differently from what?
16:58:52 <kmc> from typical functions in the standard library?
16:58:54 <dancor> fax: well i guess parsec does GLR parsing which is O(n) if the lang has no ambiguity?
16:59:11 <sshc> kmc: when the return type is different
16:59:17 <kmc> look at the big pile of instances for RegexContext
16:59:26 <dancor> (and still O(n^3) in worst case)
16:59:44 <kmc> it can produce a MatchArray, or an Int, or a Bool, or [[b]], or an (Array Int b), or (b,b,b), or (b,b,b,[b]), or ...
17:00:04 <dancor> i had thought parsec was exponential in worst case, but have looked deeped i guess it's O(n^3).
17:00:07 <dancor> deeper
17:00:39 <kmc> basically (=~) is many quite different functions; which one you get is selected only by the return type you expect
17:00:43 <kmc> and that's an uncommon thing in Haskell
17:01:00 <sshc> kmc: What's wrong with that?
17:01:03 <dancor> kmc: how uncommon?  i'm thinking of printf and HSH
17:01:07 <dancor> and read
17:01:24 <kmc> (+) is many different functions (one per Num) but they do conceptually the same thing in a uniform way
17:01:52 <sshc> kmc: Oh, I see
17:01:54 <kmc> sshc, it allows more undetected errors
17:02:10 <kmc> it's confusing to read in the doc, produces confusing error messages, etc.
17:02:17 <kmc> it breaks expectation about how functions are supposed to behave
17:04:05 <kmc> basically it tries to be some clever "do what i mean" function in a language that's designed in nearly the opposite direction
17:05:00 <kmc> the problem with "do what i mean" is that the programmer and the language second-guess each other
17:05:18 <dancor> why is happy faster than parsec if they are both doing GLR?
17:06:10 <monochrom> different constants
17:06:43 <dancor> ha but i mean what is the cause
17:07:10 <c_wraith> essentially, happy is compiled, parsec is interpreted
17:07:24 <kmc> class Add a r where { (+) :: a -> r}; instance (Num a) => Add a (a -> a) where { (+) = (Prelude.+) }; instance (Num a) => Add [a] a where { (+) = sum }
17:07:48 <kmc> with this hack we can write both (2 + 3) and ((+) [1,2,3,4])
17:07:52 <kmc> but do we really want to?
17:08:15 <kmc> or should we give two different things two different names?
17:08:52 <EvanR> i knew it. hated and ridiculed :)
17:09:00 <kmc> :D
17:09:04 <kmc> glad to be of service
17:09:11 <kmc> i do like regular expressions, just not this API
17:09:40 <dancor> c_wraith: does that mean there should be some theoretical way for me to isolate my parsec parser to one module and sprinkle compiled-magic on it and have it be as fast as happy?
17:09:47 <sshc> I hope that part will be fixed or it'll be replaced
17:09:57 <c_wraith> dancor:  no.  It lacks the machinery to do that.
17:10:09 <kmc> depends how theoretical you want to get
17:10:17 <kmc> you could make something Parsec-like which does a deep embedding
17:10:17 <dancor> i'm willing to go All The Way
17:10:38 <c_wraith> Oh.  in deep theory land, it could manage.  But parsec currently does not function that way
17:10:44 <kmc> yes
17:10:53 <kmc> maybe with supercompilation :D
17:10:54 <dancor> but maybe it's a worthy pursuit?
17:11:18 <c_wraith> eh.  If you're going to pursue that ideal, go with a better base than parsec.  try is massively ugly. :)
17:11:25 <EvanR> how about hypercomputation!
17:12:08 <dancor> try is what separates LR(1) from LR(k)
17:12:24 <theorbtwo> c_wraith: Er, it is?  It's quite a useful way of getting a good middle ground between speed, decent error messages, and being able to simply express otherwise difficult languages.
17:12:39 <dancor> parsec would be O(n) without try?
17:12:51 <benmachine> you can write pretty good parsers in parsec without try
17:12:57 <theorbtwo> dancor: The beauty of try is that you only pay for it if you use it.
17:13:07 <c_wraith> theorbtwo: it breaks the ability to blindly compose parsers.
17:13:24 <c_wraith> If you're going to be using parser combinators, you should be able to combine them.
17:13:25 <dancor> wait, without (try) do you have LR(1) or LR(0)?
17:13:27 <theorbtwo> c_wraith: Or, contrarywise, it provides it.
17:13:51 <theorbtwo> You can't combine two parsers that begin with the same thing without try.
17:14:01 <dancor> !
17:14:02 <theorbtwo> Rather, you can't or them.
17:14:03 <c_wraith> You can in polyparse or uu-parsinglib
17:14:07 <kmc> the anti-beauty of try is that you have to understand where it's needed
17:14:12 <EvanR> i recently got an error because i used a command last in a main = do that was not IO (). makes sense. but... main = return 5 works?
17:14:16 <c_wraith> both of those libraries function just fine without try
17:14:45 <benmachine> EvanR: I think IO a is ok
17:14:50 <theorbtwo> c_wraith: Without looking, I'm willing to bet that you always get the slow behavior on failing that try makes optional.
17:14:57 <applicative> EvanR return 5 is IO Int
17:15:02 <dancor> EvanR: main :: IO a
17:15:03 <benmachine> IO Integer
17:15:06 <EvanR> oh
17:15:06 <kmc> yes IO a is fine
17:15:09 <EvanR> i thought main was IO ()
17:15:14 <applicative> So your program does nothing, and then it throws away t he 5
17:15:16 <benmachine> it's usually typed that way
17:15:22 <dancor> in fact you can get horrible hidden errors by accidentally doing main :: IO (IO ())
17:15:26 <kmc> EvanR, it usually is, perhaps it should be required to be
17:15:27 <benmachine> because if it's IO anything else, the anything else is discarded anyway
17:15:32 <kmc> dancor, yes! that  would suck so hard
17:15:36 <dancor> it does
17:15:41 <dancor> and should be checked for
17:15:42 <Zao> "type clash, better add an return"
17:15:44 <kmc> a type signature on main is always a good idea unless you are golfing
17:15:45 <dancor> but i'm no ghc dev
17:15:54 <EvanR> golfing?
17:15:55 <applicative> I should try IO (IO()) or IO (IO(IO())
17:15:58 <dancor> code golf
17:16:04 <kmc> EvanR, trying to make the program as small as possible, for sport
17:16:11 <EvanR> haha
17:16:23 <theorbtwo> EvanR: The art of trying to solve a given problem in as few (key) strokes as possible.
17:16:32 <Zao> IOT (IOT IO ())
17:16:33 <EvanR> gzip at the end? :)
17:16:39 <theorbtwo> (For a somewhat silly definition of keystroke, but it keeps the pun intact.
17:16:39 <kmc> main :: IO (Mu IO)
17:16:53 <benmachine> is that even possible
17:16:59 <applicative> what's that, the creation of the World?
17:17:02 <benmachine> fix return >_>
17:17:36 <kmc> :t fix (return . In)
17:17:37 <lambdabot> forall (m :: * -> *). (Monad m) => m (Mu m)
17:18:09 <benmachine> neat
17:18:10 <theorbtwo> Er, what is the Mu monad?
17:18:13 <kmc> it's not a monad
17:18:15 <kmc> @src Mu
17:18:15 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
17:18:25 <benmachine> it's like fix, but with types
17:18:30 <kmc> Mu computes fixed points of type constructors of kind * -> *
17:18:33 <c_wraith> :t fix ((return :: a -> IO a) . In)
17:18:34 <lambdabot> IO (Mu IO)
17:18:40 <benmachine> i.e. it applies a type to itself
17:18:40 <kmc> just as "fix" computes fixed points of functions of type a -> a
17:18:46 <benmachine> (sort of)
17:18:53 <kmc> :t In
17:18:54 <lambdabot> forall (f :: * -> *). f (Mu f) -> Mu f
17:18:55 <kmc> :t out
17:18:56 <lambdabot> forall (f :: * -> *). Mu f -> f (Mu f)
17:19:17 <dancor> so what might you use Mu for
17:19:52 <kmc> for example:  data ListF x xs = Nil | Cons x xs; type List x = Mu (ListF x)
17:20:10 <kmc> ListF is a totally non-recursive datatype; Mu "ties the knot" and allows you to build lists of any length
17:20:16 <kmc> dancor, it's not that useful in practical code
17:20:21 <dancor> i see
17:20:46 <pikhq> It's most useful for typelevel computation and confusing people.
17:20:46 <benmachine> type List a = Maybe (Mu (Either a)) -- ?
17:21:00 <benmachine> er
17:21:05 <kmc> don't think so.  that'd be like data List a = Nil a | Cons (List a)
17:21:15 <kmc> there is some idea of building all recursive types by taking fixed points of non-recursive types built out of canonical sum and product type constructors
17:21:18 <benmachine> yes
17:21:22 <benmachine> I need a tuple there
17:21:34 <kmc> because then you can derive things like folds and zippers for free
17:21:37 <benmachine> type List a = Maybe (Mu ((,) a)) -- possibly
17:21:40 <kmc> but afaik this is pretty clunky in Haskell
17:21:51 <benmachine> no
17:21:55 <benmachine> that is also wrong
17:22:00 <benmachine> oh well
17:22:06 * benmachine abandons all hope
17:22:06 <kmc> Mu (Maybe . ((,) a))
17:22:10 <benmachine> yeah
17:22:10 <kmc> except no type-level (.)
17:22:14 <benmachine> :.
17:22:17 <Alpounet> TypeCompose
17:22:18 <Alpounet> yeah
17:22:45 <kmc> newtype (f :. g) x = O (f (g x)) -- ?
17:22:55 <kmc> :k (:.)
17:22:56 <lambdabot> Not in scope: type constructor or class `:.'
17:24:34 <kmc> bbl
17:31:25 <EvanR> what funny guy named this function writeList2Chan
17:32:42 <monochrom> he owns half of writeList4Chan
17:32:44 <Cale> EvanR: It's a stupid function anyway. I'm not sure why it's there. Maybe as an example?
17:32:55 <EvanR> i was about to use it
17:33:00 <EvanR> why is it stupid ;)
17:33:21 <Cale> Because it's the same as mapM_ (writeChan ch) xs
17:33:42 <Cale> -- |Write an entire list of items to a 'Chan'.
17:33:42 <Cale> writeList2Chan :: Chan a -> [a] -> IO ()
17:33:42 <Cale> writeList2Chan ch ls = sequence_ (map (writeChan ch) ls)
17:33:49 <Reisen> I am happy
17:34:06 <Reisen> I am finally seeing things in a good way, you typed my thoughts Cale
17:34:41 <EvanR> :t reisensThoughts
17:34:42 <lambdabot> Not in scope: `reisensThoughts'
17:34:53 <Reisen> Rofl
17:34:59 <Reisen> Sorry, mindless spam
17:38:10 <EvanR> i know recvFrom is not a recommended way to reliably read a socket, what should i used instead
17:38:26 <benmachine> it's not?
17:38:30 <benmachine> what kind of socket
17:38:46 <EvanR> recvFrom uses hGetContents
17:39:00 <eb4890> Are there any libraries that try to make a simple/terse vaguely regexp-ish wrapper to parsec. For example functions that convert a string to a parsers for that string (mapM (char)), parse the beginning and end of lines etc.
17:40:06 <monochrom> Hahaha, regex :: Parser (Parser String)
17:40:17 <benmachine> makes sesne
17:40:20 <edwardk> hrmm. it might be a fun little project to write a quasiquoter for that
17:40:21 <benmachine> makes snes
17:40:37 <edwardk> foo = [$regex|...|]
17:41:13 <theorbtwo> I'm not sure it's really all that little.
17:41:31 <theorbtwo> Then again, if you keep to a fairly simiple regex dialect, I suppose...
17:41:32 <edwardk> theorbtwo: < 2-300 lines not so bad
17:41:39 <edwardk> worse if you want perlRE
17:42:09 <dancor> one thing is that the more powerful your REs, the more DOS issues you could have
17:42:31 <dancor> i heard that backtracking often creates DoS possibilities
17:43:31 <edwardk> dancor: a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
17:43:36 <edwardk> does bad things to perl =)
17:43:39 <MisterN> dancor: there's a library from google to avoid that
17:43:50 <MisterN> http://code.google.com/p/re2/
17:43:53 <dancor> i guess you could also just timeout
17:43:54 <edwardk> MisterN: yeah thats basically a thompson style engine
17:43:56 <theorbtwo> edwardk: On the other hand, that's also not a useful regex.
17:44:13 <EvanR> pathological patterns?
17:44:15 <dancor> > fix return
17:44:16 <lambdabot>   Occurs check: cannot construct the infinite type: a = m a
17:44:20 <EvanR> or deep flaw ? :)
17:44:29 <edwardk> theorbtwo: sure, but the issue under discussion was denial of service =)
17:44:29 <MisterN> :t fix
17:44:30 <lambdabot> forall a. (a -> a) -> a
17:44:44 <MisterN> :t fix id
17:44:44 <dancor> > fix id
17:44:45 <lambdabot> forall a. a
17:44:48 <lambdabot>   mueval-core: Time limit exceeded
17:44:57 <dancor> > 4 `unamb` fix id
17:44:58 <lambdabot>   Not in scope: `unamb'
17:45:10 <MisterN> > fix (const 0)
17:45:11 <lambdabot>   0
17:45:13 <theorbtwo> edwardk: Yes, but DOSes when you let the user provide a regex are much less bad then DOSes when you match a reasonable-looking regex againt user input.
17:45:16 <edwardk> EvanR: it is a systemic issue with the backtracking approach. it lets you express a lot more constructs, but the asymptotics are worse
17:45:19 <monoidal> does anyone know how "the antidiagonal" {(x,y):x/=y} can be decomposed into primitive species?
17:45:22 <MisterN> > fix (-1)
17:45:23 <lambdabot>   No instance for (GHC.Num.Num (a -> a))
17:45:23 <lambdabot>    arising from a use of syntactic n...
17:45:27 <mauke> edwardk: an NFA-based engine will fail on ((a{9999}){9999}){9999}
17:45:28 <monoidal> (as in combinatorial species)
17:46:03 <edwardk> monoidal: have you asked byorgey?
17:46:07 <eb4890> Not quite what I was thinking.... more so I could write parse ((many alph) >>= char '.' >>= many alph >>= eol) but terser.
17:46:31 <monoidal> will ask
17:46:35 <edwardk> monoidal: the first approach that comes to my mind requires virtual species, you'll probably get a real answer out of him ;)
17:46:43 <theorbtwo> EvanR: Yes, thought so.  I just tried that against a current perl, and couldn't get it to take nontrivial time.
17:47:10 <micah> I am making a parser in parsec
17:47:13 <fax> edwardk what's your favorite application[s] of category theory?
17:47:28 <edwardk> fax: abusing kan extensions to make code run faster
17:47:29 <micah> parsing a [Token]
17:47:41 <theorbtwo> (OTOH, mauke's example makes it run out of memory quite swiftly.)
17:47:43 <micah> I use pattern matching to extract data from the tokens during parsinng
17:47:47 <fax> edwardk ooh I have seen this in action it's crazy
17:47:56 <micah> so when the pattern fails it falls through to the next parser
17:48:00 <micah> but if they all fail
17:48:13 <micah> I want to get rid of this error: Pattern match failure in do expression at...
17:48:14 <mauke> heh, amazing
17:48:46 <edwardk> fax: my favorite things about category theory usually shift to whatever it is that i'm obsessing about in the moment ;)
17:49:02 <edwardk> right now that is with doing stream fusion over free monads ;)
17:49:57 <mauke> I wonder what perl is doing with that pattern
17:50:45 <edwardk> mauke: only if you don't have enough memory =)
17:51:00 <fax> see ya
17:51:05 <mauke> then backtracking is only a problem if you don't have enough time
17:51:09 <theorbtwo> mauke: I rather do as well; the engine has some heuristics that are meant to keep that sort of thing from happening.  I should try with the current code, rather then the most recent release, possibly.
17:51:10 <edwardk> =)
17:51:22 * hackagebot cgi 3001.1.8.1 - A library for writing CGI programs  http://hackage.haskell.org/package/cgi-3001.1.8.1 (AndersKaseorg)
17:52:09 <pickles> started reading an interesting article on regex, if anyone wants the link
17:52:11 <mauke> works with (([ab]{9999}){9999}){9999}
17:52:21 <eb4890> micah: Can you do a paste somewhere? No guarantee I can help though...
17:52:27 <mauke> I think it's the "fixed substring" optimization that's screwing up
17:52:27 <micah> sure
17:52:47 <pickles> http://swtch.com/~rsc/regexp/regexp1.html
17:53:05 <micah> eb4890: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24377#a24377
17:53:24 <micah> eb4890: I put all the <?>s so that it wouldn't ahve the pattern errors
17:53:29 <micah> eb4890: but it still has them
17:53:40 <mauke> pickles: yeah, I'm in the process of proving the article wrong, specifically the "no pathological patterns" part
17:54:09 <pickles> mm, idk if i've gotten that far
17:55:01 <pickles> ... maybe i have
17:55:06 <pickles> i donno much about regex
17:55:09 <SamB_XP_> mauke: hmm?
17:55:13 <pickles> maybe you could link us to your article when you're done
17:55:18 <SamB_XP_> what "no pathological patterns" thing?
17:55:25 <pickles> *idk much about implementing them
17:55:46 <SamB_XP_> I mean, what exactly is the claim which you mean to disprove?
17:56:35 <mauke> "In contrast, there are no regular expressions that are pathological for the Thompson NFA implementation." ... "Using Thompson's NFA simulation does not require such adaptation: there are no expensive regular expressions."
17:57:04 <SamB_XP_> mauke: you have one of those archaic things to run it on?
17:57:06 <pickles> ah
17:57:30 <mauke> SamB_XP_: er, it's an algorithm
17:57:36 <mauke> I can run it in my head if necessary
17:57:56 <Jonno_FTW> test
17:58:18 <SamB_XP_> how are you going to be certain you've got an equivalent algorithm if you can't test that one ?
17:59:15 <SamB_XP_> also, what do *you* mean by pathological ?
17:59:39 <EvanR> reading a socket.. what function do i use to get everything until the socket is closed?
18:00:10 <SamB_XP_> EvanR: keeping in mind that that might never happen ?
18:00:14 <mauke> SamB_XP_: exponential memory use
18:00:30 <Eridius> mauke: I thought the "pathalogical" in that context meant exponential runtime
18:00:37 <Eridius> err "pathological"
18:00:37 <EvanR> SamB_XP_: hmm. well, they may also never send some marker that says 'end of message'
18:00:42 <pickles> EvanR: did you ever specify whether UDP or TCP ?
18:01:04 <mauke> Eridius: well, you have to construct that exponential number of nodes somehow
18:01:06 <EvanR> pickles: considering i dont know if the other side closed something, not udp
18:01:18 <mauke> so it takes that much time in addition
18:01:27 <pickles> EvanR: ah
18:02:09 <SamB_XP_> mauke: so what pathological pattern did you find?
18:02:13 <EvanR> ok so the other side should send me a single number, whats the easiest way to get this
18:02:25 <mauke> SamB_XP_: (([ab]{9999}){9999}){9999}
18:02:54 <SamB_XP_> mauke: and thompson's thing supports those {99999} things ?
18:03:08 <SamB_XP_> and what exactly is this supposed to be exponential in?
18:03:17 <mauke> not natively, no
18:03:29 <mauke> later on that page it says you have to macro-expand them at compile time
18:03:32 <SamB_XP_> mauke: I think you be cheating
18:03:40 <mauke> I think that article is cheating
18:03:49 <SamB_XP_> okay, well, maybe
18:03:54 <Cale> EvanR: regarding the recvFrom question, just use listenOn/accept
18:04:17 <SamB_XP_> but again, what is this thing exponential in?
18:04:24 <Cale> EvanR: and then you get a Handle which you can read from, and eventually close when you're done with it.
18:04:30 <MisterN> @src fix
18:04:30 <lambdabot> fix f = let x = f x in x
18:04:36 <Cale> EvanR: (provided you don't use hGetContents ;)
18:04:40 <mauke> SamB_XP_: length of regex
18:04:43 <SamB_XP_> it looks like it's just O(1) with a really really big 1
18:04:55 <FliPPeh_> Meh
18:04:56 <SamB_XP_> mauke: is that what HE was talking about?
18:05:00 <FliPPeh_> I can't get recursing going with Parsec
18:05:05 <mauke> SamB_XP_: no
18:05:22 <mauke> (and that's half of my point)
18:06:23 <EvanR> Cale: right, im using that to make a listening socket. now what about the resulting handle
18:06:36 <pickles> mauke: curious, have you considered the difference between the Thompson and PERL on your example/
18:06:56 <SamB_XP_> mauke: anyway, are you sure the length of input match is actually exponential in the length of pattern there?
18:06:58 <mauke> you are disqualified for using "PERL"
18:07:08 <pickles> :(
18:07:09 <SamB_XP_> mauke: he's just an oldbie!
18:07:19 <Cale> EvanR: You read from it using various functions in System.IO and the ByteString libraries, or various others
18:07:24 <Cale> EvanR: like hGetLine
18:07:24 <mauke> SamB_XP_: PERL isn't LISP
18:07:26 <SamB_XP_> or he's read it from the top of PERL(1)
18:07:29 <mauke> heh
18:07:48 <mauke> SamB_XP_: I don't understand the "length of input match" part
18:07:53 <pickles> or just didnt know how else to refer to it off the top of my head
18:08:10 <mauke> pickles: hint: it's "perl"
18:08:27 <SamB_XP_> mauke: well, whatever thing it is that you're trying to claim is O(a^n)
18:08:37 <pickles> i recall having usually seen it in caps
18:08:38 <SamB_XP_> mauke: I think Perl is actually correct
18:08:45 <SamB_XP_> perl is the executable
18:08:47 <EvanR> Cale: hGetLine looks good, i just have to make sure the other side will be sending me a newline to terminate the message
18:08:55 <mauke> here's what perl compiles this pattern to: http://p3rl.org/8683PTWW
18:09:35 <SamB_XP_> at least the first letter should be capitalized according to the standard english grammar rules, except maybe if it's mcPerl or something?
18:09:41 <Cale> Isn't the contention more about how much time it takes to decide if a given string matches the language, based on the length of the *input* and not the size of the regular expression?
18:09:58 <FliPPeh_> How do I recurse inside a monad?
18:10:01 <mauke> Cale: yes, but who cares?
18:10:13 <mauke> he's trying to argue about real-world usage of regexes
18:10:16 <micah> FliPPeh_: just like how you recurse inside anything else
18:10:24 <micah> foo = do bar; foo
18:10:40 <FliPPeh_> While it's not IO, the situation is the following: "return $ String : IO String"
18:10:49 <FliPPeh_> It's in parsec
18:10:53 <mauke> "my regex engine is really fast and has no pathological inputs ... assuming it can compile the input pattern without running out of memory"
18:10:55 <FliPPeh_> I need to build a list.
18:11:30 <micah> FliPPeh_: well before you try recursing, see if many/many1/all those other combinators will do anything for you
18:11:31 <mauke> and this is why a recursive backtracking engine is strictly more powerful than the NFA simulator without even considering backreferences
18:11:34 <EvanR> im thinking dont allow user provided regex
18:11:47 <SamB_XP_> EvanR: that's a pain, though
18:11:55 <SamB_XP_> you should just use limits
18:11:59 <EvanR> on what
18:12:05 <SamB_XP_> time & space
18:12:05 <micah> FliPPeh_: if they can't, then either use liftM or do a <- IO String ; return $ string : a
18:12:08 <FliPPeh_> micah: I basically want to get each line or the parsing string inside it right now
18:12:18 <micah> ok
18:12:21 <EvanR> SamB_XP_: hopefully thats what php does...
18:12:28 <micah> FliPPeh_: well you should make something that parses one line
18:12:31 <EvanR> since our site allows user provided regex ;)
18:12:36 <micah> FliPPeh_: and then say `many line`
18:12:37 <FliPPeh_> I have
18:12:47 <micah> FliPPeh_: so what's the problem?
18:12:52 <FliPPeh_> Wait, I'll nopaste it
18:12:54 <FliPPeh_> @hpaste
18:12:55 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
18:13:25 <FliPPeh_> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=8908#a8908
18:13:26 <FliPPeh_> Here
18:13:58 <FliPPeh_> instead of "bi <- takeUntil "\n"", there will be more statements pulling out more values of the string
18:14:10 <FliPPeh_> Before finally reaching the end of that line
18:14:21 <micah> ok
18:14:40 <micah> so you want to say return $ (n, bi) : <return value of parseLines>?
18:14:40 <FliPPeh_> In this case, the /proc/net/dev syntax
18:14:45 <FliPPeh_> Yep
18:14:55 <FliPPeh_> [("...", "...")]
18:15:02 <micah> then you should probaly make a function that accumulates it through the argument through recursion
18:15:13 <micah> if you can' think of a way to do that through many etc.
18:15:27 <micah> but you can probably do it with many
18:15:45 <micah> many gives you a list and then if you want to use a right-associtavie way to combine the things it gave you, use foldr
18:16:19 <micah> what I would suggest is
18:16:21 <micah> make
18:16:23 <micah> parseLine
18:16:31 <micah> and then parseLines is many or many1 parseLine
18:16:44 <micah> that would work
18:16:48 <micah> wouldn't it?
18:16:52 <FliPPeh_> Just did it
18:16:54 <FliPPeh_> Trying...
18:17:42 <FliPPeh_> Left (line 2, column 1):
18:17:42 <FliPPeh_> unexpected end of input
18:17:43 <FliPPeh_> expecting space
18:17:50 <FliPPeh_> For  " hello:54 54 3\n"
18:18:11 <FliPPeh_> It should be [("hello", "54 54 3")]
18:18:52 <micah> hmmm
18:19:12 <ski>   liftM ((n,bi) :) <return value of parseLines>
18:19:13 <eb4890> micah: I'm pretty new to parsec myself. I'm puzzled that you are try-ing something that has a (<?>) in it. I'd only expect that after the term.
18:19:14 <ski> ?
18:19:39 <ski> (er, actually s/return value of/call to/, i suppose)
18:20:02 <Cale> Or just simply:
18:20:08 <micah> eb4890: I just put those there as a randmo test to see if it would work
18:20:08 <Cale> xs <- parseLines
18:20:15 <Cale> return ((n,bi) : xs)
18:20:18 <micah> eb4890: to see if I could get rid of the pattern match failure messages
18:22:17 <FliPPeh_> This whole thing isn't working
18:22:22 <FliPPeh_> It won't parse a full line
18:22:25 <FliPPeh_> It always wants more
18:23:13 <FliPPeh_> ah
18:23:16 <FliPPeh_> Missing the "try"
18:29:22 <FliPPeh_> GAH
18:29:25 <FliPPeh_> This is driving me NUTS
18:29:25 <EvanR> heh. do notation considered harmful
18:29:30 <FliPPeh_> Really
18:29:30 <EvanR> http://www.haskell.org/haskellwiki/Do_notation_considered_harmful
18:29:39 <FliPPeh_> It should freaking RECURSE
18:29:42 <FliPPeh_> But it AIN'T
18:31:08 * osfameron doesn't really see what's wrong with the 'do' examples there
18:31:15 <osfameron> sure, they have intermediate variables...
18:31:30 <osfameron> which are arguably a form of documentation
18:33:38 <Cale> FliPPeh_: What does your current code look like?
18:34:15 <EvanR> so ive got do { jobs <- getJobs; spawnJobsjobs }, i guess i can do just getJobs >>= spawnJobs
18:34:20 <EvanR> missing a ;
18:34:35 <Cale> also a space?
18:34:39 <Cale> er
18:34:41 <EvanR> yes
18:34:50 <FliPPeh_> Cale: Like a big pile of junk
18:34:50 <Cale> You're not missing a ; though
18:34:53 <EvanR> oh
18:34:59 <FliPPeh_> I'm lost inside it
18:35:35 * hackagebot hothasktags 0.0.1 - Generates ctags for Haskell, incorporating import lists and qualified imports  http://hackage.haskell.org/package/hothasktags-0.0.1 (LukePalmer)
18:37:01 <aavogt> "considered harmful" considered harmful
18:37:20 <EvanR> hah
18:38:54 <FliPPeh_> @hpaste
18:38:54 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
18:39:49 <FliPPeh_> Cale: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=8909#a8909
18:39:52 <FliPPeh_> This is what I have
18:41:11 <FliPPeh_> Sometimes it works, sometimes it doesn't...
18:41:19 <FliPPeh_> It's just frustrating
18:42:47 <MisterN> can you please help me understand whether this is actually a monad? http://groups.google.com/group/commonjs/browse_thread/thread/acb11e6bb119af8b
18:42:48 <marcellusheinig> how to function make argument monad run compile ubuntu ??
18:43:04 <EvanR> >_<?
18:43:19 <FliPPeh_> Erm
18:43:25 <marcellusheinig> i need file program run desktop ??
18:43:31 <FliPPeh_> Erm
18:44:03 <EvanR> maybe someone can speak your native language
18:44:27 <dankna> ><
18:44:28 <FliPPeh_> marcellusheinig: What's your language?
18:44:52 <monochrom> The IP is definitely American.
18:44:59 <dankna> which means it could be anything
18:45:01 <marcellusheinig> speaks make find language virginia algonquian
18:45:15 <EvanR> native american
18:45:25 <MisterN> EvanR: i doubt that.
18:45:29 <meanburrito920_> MisterN: I may be incorrect, but I don't believe it is a monad, because It doesn't seem to implement bind
18:45:30 <EvanR> thats what he said ;)
18:45:38 <monochrom> I rather bet it is a computer program.
18:45:40 <dankna> that doesn't even sound like an attempt at English - either trolling or Markov-chain text
18:45:41 <FliPPeh_> I can't decode it :(
18:45:49 <dankna> it cracked me up though
18:45:52 <MisterN> meanburrito920_: does it even implement return? :D
18:45:54 <EvanR> haha
18:45:57 <marcellusheinig> i make program compile work job.
18:46:11 --- mode: ChanServ set +o monochrom
18:46:19 <MisterN> hmm maybe ensure could be considered the return operator
18:46:30 --- mode: monochrom set +q marcellusheinig!*@*
18:46:43 <EvanR> monochrom: you are about to relive the atrocities of our past!
18:46:43 <edwardk> MisterN: like with jquery, just coz it uses functions doesn't make it monadic ;)
18:46:46 <EvanR> lol
18:46:47 <meanburrito920_> MisterN: thats what I was thinking
18:47:00 <MisterN> on the other hand, maybe ensure is actually the bind :D
18:47:07 --- mode: monochrom set -q marcellusheinig!*@*
18:47:09 <MisterN> but then there's no return
18:47:17 --- mode: monochrom set -o monochrom
18:47:32 <MisterN> edwardk: it's hard to even say that something is a monad in an impure language
18:47:46 <edwardk> MisterN: either way of looking at it is if it does anything different depending on the value of its argument, it isn't return. if it can disambiguate the cruft in the container it isn't polymorphic and isn't a bind ;)
18:47:56 <edwardk> er another way of
18:48:32 <eb4890> Flippeh_: Try changing the >> to <|> in the takeUntil?
18:48:48 <edwardk> ensure seems to be taking a list for its first argument for a reason, that list has meaning. this is not the bind you are looking for ;)
18:49:44 <meanburrito920_> MisterN: ensure is not bind
18:50:04 <edwardk> that doesn't make the set of combinators any less useful though
18:50:08 <edwardk> its just something else.
18:50:29 <FliPPeh_> Doesn't help
18:50:42 <FliPPeh_> :/
18:50:45 <MisterN> edwardk: yeah
18:52:11 <geheimdienst> hey guys, if i have a IO [Foo] and another IO [Foo], what's the easiest way to concat them?
18:52:34 <Cale> FliPPeh_: You have a many1 space in there that is a little suspicious... are you sure you want to *require* an interfaceName to start with a space?
18:52:37 <EvanR> dont you have to 'run' them first
18:52:43 <edwardk> @type liftM
18:52:44 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
18:52:50 <Cale> geheimdienst: liftM2 (++)
18:52:51 <edwardk> @type liftM2
18:52:52 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
18:52:54 <FliPPeh_> Cale: They all do
18:53:09 <FliPPeh_> They all start with at least one space
18:53:13 <FliPPeh_> Most of them with more
18:53:50 <edwardk> FliPPeh_: another convention is to have the previous combinator eat all the space that follows it
18:53:54 <meanburrito920_> > :i Monad
18:53:55 <lambdabot>   <no location info>: parse error on input `:'
18:54:13 <meanburrito920_> \msg lambdabot @info Monad
18:54:26 <meanburrito920_> whoops
18:54:29 <edwardk> at least if i'm understanding the context of the conversation i'm butting into correctly
18:55:17 <geheimdienst> oh cool, thanks :)
18:55:37 <Cale> Another somewhat funny thing is the explicit handling of different newline formats... where is the string you're parsing coming from? The normal IO routines will handle line endings according to the system's usual text encoding and will make them appear to the program as '\n' regardless.
18:55:52 <FliPPeh_> Cale: /proc/net/dev
18:55:53 <syntaxglitch> geheimdienst, or try (++) <$> x <*> y
18:56:02 <Cale> (so even on Windows, you'll only ever normally see '\n' newlines)
18:56:15 <FliPPeh_> Basically, that crlf will match any of \n, \r and \r\n
18:56:27 <MisterN> thoughtpolice: you should meet geheimdienst sometime
18:56:34 <Cale> yeah
18:56:59 <Cale> (I'll be surprised if you ever see an '\r' in practice though)
18:57:15 <FliPPeh_> I took that code off an old IRC parser :)
18:57:37 <FliPPeh_> parse (parseLines) "" " f: 6\n d: 4\n w: 4"
18:57:38 <FliPPeh_> Right [("f",[6])]
18:57:44 <FliPPeh_> It only captures teh first result
18:57:50 <FliPPeh_> Which is bothering me
18:57:56 <Cale> Yeah, sometimes in network settings you can't be sure that it'll agree with the system encoding.
18:59:41 <EvanR> hGetLine will still work right
18:59:47 <EvanR> hopefully?
18:59:49 <Cale> Okay, takeUntil won't actually eat the crlf
18:59:58 <FliPPeh_> Ohhh
19:00:30 <Cale> You probably wanted takeUntil s = anyChar `manyTill` s
19:01:12 <Cale> Or maybe it ought to be try s
19:01:37 <FliPPeh_> Okay, changed it, but it didn't change the behaviour
19:01:56 <Cale> okay, and you're sure you want to be looking for eof there?
19:02:08 <Cale> eof matches the very end of the string only
19:02:28 <Cale> Which would seem to imply that there could only ever be one line of output there.
19:02:49 <FliPPeh_> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=8911#a8911
19:02:52 <FliPPeh_> This is after my changes
19:02:57 <FliPPeh_> No more eof
19:03:16 <FliPPeh_> Also changed the many1 to many, because it doesn't really matter
19:03:22 <FliPPeh_> yet...
19:03:26 <FliPPeh_> parse (parseLines) "" "f: 6 8 7\n"
19:03:26 <FliPPeh_> Right []
19:03:50 <danderson> whoa
19:03:57 * danderson discovers that putStrLn is definitely not thread-safe
19:04:08 <EvanR> uh oh :S
19:04:19 <Cale> It's thread-safe, but not atomic.
19:04:20 <danderson> well, no, I should qualify that
19:04:25 <danderson> yeah, not atomic.
19:04:30 <danderson> it's 3am, I plead fatigue.
19:04:46 <danderson> doesn't matter terribly since I was only using it to verify a hypothesis
19:04:51 <danderson> but it's certainly interesting
19:05:18 <Cale> If you care about the output being readable, it's usually best to set up one thread to manage the terminal I/O, and set up a Chan for that purpose.
19:05:23 <Cale> (or two)
19:07:02 <danderson> Cale: yup, a logging thread was the goal
19:07:07 <Cale> FliPPeh_: btw, it seems like parseLines = many x, for a suitable x
19:07:20 <danderson> I was just testing my function, and printing the state of each thread seemed like the simplest thing to do
19:07:24 <FliPPeh_> I think I just found out what's causing trouble
19:07:26 <Cale> FliPPeh_: That won't be the problem, but it does make it simpler :)
19:07:55 <danderson> and it does seem to work, I can now boot N threads that are all tied together: the death of any one of them causes the others to get killed
19:07:56 <FliPPeh_> If I do "parse (interfaceName >> many int) "" " f0: 6 4 8\n"", it'll result in [6,4,8], so the individual functions work
19:08:00 <FliPPeh_> It's somewhere in the parseLines
19:08:12 <FliPPeh_> I think I screwed up on the recursion...
19:08:16 <danderson> which is nice, since I'm using a couple of threads per client to handle different parts of the chatter
19:08:16 <Cale> FliPPeh_: try simplifying the thing using many
19:08:27 <FliPPeh_> okay
19:08:45 <Cale> Then you don't need recursion
19:09:08 <timmaxw> is there a function in the standard library that is defined as (flip ($))? it seems like it would be really useful but i dont know what it's called...
19:09:29 <ezyang> :h a -> (a -> b) -> b
19:09:31 <FliPPeh_> Right [("f0",[6,4,8]),("g2",[3,5,6])]
19:09:36 <FliPPeh_> Looks great
19:09:40 <ezyang> @hoogle a -> (a -> b) -> b
19:09:40 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
19:09:41 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
19:09:41 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
19:09:47 <ezyang> bah
19:09:53 <Cale> timmaxw: nope
19:10:06 <timmaxw> ok
19:10:12 <Cale> timmaxw: Well, you can write flip ($) of course ;)
19:10:39 <Cale> What would you use it for?
19:10:40 <FliPPeh_> And after doing that modify...
19:10:47 <FliPPeh_> It works like a charm, the whole "parseIfs"
19:10:50 <FliPPeh_> Thanks Cale :)
19:10:53 <EvanR> hmm. seems like im spending more time fooling with the damn layout than writing the code. because theres not much code to write, and my layout tends to look funky ;)
19:11:01 <FliPPeh_> Let's see when the next thing breaks
19:11:37 <FliPPeh_> This is still depressing me :(
19:11:47 <timmaxw> Cale: syntactic sugar. if it was ($>) you could write things like "someInput $> words $> map read $> sort"
19:12:00 <Cale> sort . map read . words $ someInput
19:12:02 <FliPPeh_> I recently saw an increase in my haskell skill, and now I feel like I just started again
19:12:06 <Cale> more idiomatic
19:12:10 <FliPPeh_> It's really frustrating
19:12:11 <ezyang> Cale: We have >>=; why not the same for pure code :-)
19:12:33 <timmaxw> Cale: of course, or you could just write "sort $ map read $ words $ someInput". but it flows more naturally when the data goes from left to right.
19:12:41 <Cale> >>= is bad enough as it is ;)
19:12:58 <Cale> timmaxw: btw, it's better to avoid chaining $ like that, and use composition where you can
19:13:04 <timmaxw> Cale: why?
19:13:09 <Cale> timmaxw: this is because (.) is an associative operator
19:13:21 <timmaxw> Cale: what does that change?
19:13:33 <Cale> So when you're refactoring, things like  map read . words  are meaningful on their own
19:13:41 <Cale> while  map read $ words  is a type error
19:14:02 <timmaxw> Cale: oh, i see.
19:14:30 <Cale> It's also a bit of an accident that $ has the wrong associativity like that
19:14:48 <Cale> If there were any sense to things, it would be left associative, like function application normally is.
19:15:03 <Cale> and that'd let us remove even more parens, in conjuction with composition
19:15:09 <Cale> conjunction*
19:15:31 <Cale> Currently, it's impossible to remove the parens from things like  f (g x) (h y) (k z)
19:15:59 <Cale> While if $ were to be changed to the other associativity, it would be f $ g x $ h y $ k z
19:16:07 <timmaxw> yeah, i can see some advantages of that
19:16:19 <syntaxglitch> ezyang, why not just lift everything into the Identity monad and use >>=
19:16:25 <timmaxw> it seems like it would be useful to have more ($)-like operators
19:16:41 <syntaxglitch> >>= is what Haskell is all about, isn't it? s'right there in the logo.
19:16:44 <Cale> Of course, people already complain that we have too many operator symbols :)
19:16:58 <EvanR> > read "12"
19:16:59 <lambdabot>   * Exception: Prelude.read: no parse
19:17:02 <EvanR> > read "12" :: Integer
19:17:03 <lambdabot>   12
19:17:09 <EvanR> > read "abc" :: Integer
19:17:09 <Cale> That's something I don't really like about the logo :/
19:17:10 <lambdabot>   * Exception: Prelude.read: no parse
19:17:12 <timmaxw> that's like saying that there are too functions in C ;)
19:17:24 <Cale> I like the similarity to the Commodore logo though :)
19:17:31 <syntaxglitch> Cale, I was joking, if it helps
19:17:43 * syntaxglitch prefers the Applicative combinators whenever possible
19:18:04 <EvanR> is there a read function that returns Maybe a
19:18:34 <Cale> You could use listToMaybe along with reads
19:19:25 <Cale> Of course, C's real problem is that there are not enough real functions.
19:19:34 <EvanR> listToMaybe seems weird
19:19:40 <Cale> There are only things which are not functions that are pretending to be.
19:20:02 <EvanR> and you cant define local functions
19:20:36 <timmaxw> why aren't there more languages that allow user-defined operators
19:20:41 <timmaxw> it's not an intrinsically functional concept
19:20:44 <syntaxglitch> C++ enables purely functional programming, though
19:20:49 <timmaxw> it could easily be added to, say, C
19:20:59 <syntaxglitch> as long as you don't mind your program running at compile-time...
19:21:01 <ezyang> syntaxglitch: :-P
19:21:06 <Cale> timmaxw: perhaps just culture
19:21:17 <timmaxw> heck, the entire type-class system could probably be transplanted into a C++-like language
19:21:27 <timmaxw> (and I would program in that language)
19:21:30 <Cale> timmaxw: They almost sort of tried that.
19:21:37 <timmaxw> when?
19:21:42 <Cale> timmaxw: That's what C++ concepts were an attempt to do
19:21:49 <timmaxw> oh, right.
19:22:01 <timmaxw> too bad they were scrapped :(
19:22:11 <syntaxglitch> aren't C++ templates arguably more powerful than most compile-time hackery in Haskell, anyway?
19:22:16 <Cale> But C++ is apparently too much of a clusterfuck already to make that a sensible thing to do.
19:22:56 <syntaxglitch> I have yet to find the courage to learn C++ template metaprogramming so I'm not sure how much you can do with it
19:22:57 <timmaxw> syntaxglitch: i'm not too familiar with C++. can you give an example?
19:23:03 <SamB_XP_> syntaxglitch: more powerful?
19:23:04 <SamB_XP_> sure.
19:23:15 <SamB_XP_> more useful?
19:23:17 <SamB_XP_> heck no!
19:23:35 <Cale> Well, with extensions turned on in GHC, they're equivalent in power.
19:23:52 <SamB_XP_> Cale: yeah, in *crazy* mode, sure
19:23:55 <Cale> ;)
19:23:56 <syntaxglitch> trivially equivalent, being Turing complete, yes
19:24:09 <SamB_XP_> but then you might as well write C++ for all the safety you get!
19:24:10 <eb4890> BitC is back up and running, or will be soon. So there is some hope of a low-level language with decent type system
19:24:12 <ddarius> The language of C++ templates, while verbose, has more practical programming things than the Haskell type language.
19:24:29 * timmaxw googles for BitC
19:24:36 <SamB_XP_> ddarius: I can't abide such verbosity, generally :-(
19:24:41 <syntaxglitch> but doing arbitrary computation at compile-time isn't the same thing as producing interesting type system artifacts to use for the rest of the program
19:24:54 <Cale> I find that C++ templates make the practical cases much too awkward.
19:25:16 <ddarius> SamB_XP_: That's why you write a translator from a Haskell-like functional syntax to C++.  That's one of the first Haskell programs I wrote.  'pretty much just fill in the blanks.
19:25:22 <syntaxglitch> I'd rather use Haskell for the rest of the program, but my impression is that C++ templates are actually more expressive for the most part
19:25:27 <Cale> There's way too much syntax cruft for plain parametric polymorphism.
19:25:43 <FliPPeh_> Type inference is pretty awesome
19:25:54 <FliPPeh_> I didn't think it could find THIS much out by itself
19:25:55 * syntaxglitch needs to learn C++ template metaprogramming at some point so that he can write a compile-time Mandelbrot renderer
19:26:22 <ddarius> Cale: C++ templates are worse as a type system but better as a programming language, in several ways, than Haskell's.
19:26:34 <Cale> ddarius: Yes, I can agree with that.
19:26:53 <Cale> They support numbers directly at the type level, which is more practical
19:27:11 <SamB_XP_> ddarius: that's pretty sad considering their intended application :-(
19:27:18 <timmaxw> eb4890: BitC looks neat. it would be really useful if it inter-operated with C, and it looks like it could do that eventually. also, i dont like the lisp-style syntax, but that's just me.
19:28:45 <Cale> timmaxw: The lisp-like syntax does have the advantage of being dead-simple to generate, which is mostly what languages like that are intended for though :)
19:29:21 <ddarius> Generating syntax is usually pretty easy for any language.
19:29:56 <ddarius> Lisp-like syntax is much easier to (lexically) parse than most other syntaxes.
19:29:57 <Cale> Well, it's easier to generate sexprs than it is to generate proper C code, I think.
19:30:06 <ddarius> Cale: Not by much.
19:30:11 <timmaxw> Cale: are you saying that BitC is meant as a language for some other software to generate? i'm not sure i follow.
19:30:16 <Cale> timmaxw: yeah
19:30:22 <syntaxglitch> depends on whether the generated C is supposed to be human-readable, I suspect
19:30:34 <timmaxw> Cale: what software are you thinking of?
19:30:59 * ezyang would like to point out that before lisp no one thought of programs as syntax trees to be generated and manipulated 
19:30:59 <syntaxglitch> it's usually easy to generate unreadable code for most languages, pretty-printed code can be trickier
19:31:23 <Cale> timmaxw: Compilers, of course. ;)
19:31:28 <kmc> what languages existed "before lisp"?
19:31:34 <timmaxw> Cale: why would one want to compile to BitC?
19:31:35 <monochrom> fortran
19:31:35 * ddarius would like to point out to ezyang that there wasn't much "before lisp" and logicians certainly did think of the equivalent before lisp.
19:31:36 <syntaxglitch> kmc, uh... FORTRAN?
19:31:43 <kmc> is that the only one?
19:31:48 <kmc> of note?
19:31:50 <monochrom> remember fortran was even column-sensitive
19:31:50 <syntaxglitch> it's the only one I'm fairly certain of
19:31:53 <SamB_XP_> kmc: assembler, at least on paper ;-P
19:31:54 <kmc> FORTRAN compilers didn't use an AST?
19:31:59 <kmc> i guess that's plausible
19:32:05 <kmc> they would just translate one line at a time
19:32:07 <Adamant> FORTRAN is the only really 'useful' one
19:32:16 <Adamant> besides stuff like Planklcode or whatever
19:32:18 <syntaxglitch> I think FORTRAN existed before anyone knew what the hell they were doing
19:32:20 <Adamant> from Zuze
19:32:30 <geheimdienst> before lisp, there were only cogwheels made of stone
19:32:30 <Adamant> Zuse
19:32:31 <kmc> i don't know anything about Fortran 66
19:32:32 <SamB_XP_> syntaxglitch: as if we do now ;-P
19:32:51 <monochrom> significant line breaks. significant columns. comments must have the comment symbol at column 5.
19:32:51 <ezyang> ddarius: Sure sure :-)
19:33:06 <monochrom> and cobol
19:33:07 <Cale> timmaxw: It's a suitably low-level language, like C is, it's nicely typed, so you get lots of early warnings if there's a compiler bug, there's apparently a nice formal semantics...
19:33:12 <Adamant> I dunno. given that it was the first attempt at a high level language, FORTRAN was pretty well designed, especially given it's audience.
19:33:32 <kmc> FORTRAN is still better than C for some things
19:33:35 <Cale> (or at least, their intent is to provide one)
19:33:40 <Adamant> like numerical computing
19:33:44 <syntaxglitch> modern FORTRAN is good for quite a few things
19:33:46 <timmaxw> Cale: C is also a low-level language that a lot of software generates, but it's primarily meant to be written by humans. i think BitC is the same way.
19:33:47 <kmc> and the later versions have fewer archaic restrictions
19:33:48 <kmc> yes
19:33:52 <SamB_XP_> kmc: fortran has undergone a lot of changes as I understand it ;-P
19:33:52 <syntaxglitch> old-school FORTRAN would be horrifying today, I'm sure
19:34:03 <kmc> plenty of people still read / modify / write f77
19:34:07 <timmaxw> does anyone know if BitC supports run-time introspection like LISP does?
19:34:10 * Cale no longer considers C a language fit for direct human use. ;)
19:34:18 <Adamant> and non-primary programmers with a scientific background seem to like it.
19:34:19 <kmc> not sure whether i'd rather do that for a living or code C++
19:34:27 <SamB_XP_> timmaxw: that wouldn't be low-level, now would it ?
19:34:27 <ezyang> Cale: Not even for OS writers? :-)
19:34:32 <ddarius> Almost all old-school code would be horrifying.  Of course almost all current code likely is too, but the proportions are greater back in the day.
19:34:45 <pikhq> Cale: I consider assembly fit for human use. Just not many humans.
19:34:46 <Adamant> the old-school code ain't all gone yet
19:34:58 <timmaxw> SamB_XP_: that's why i didnt think it did. but that takes away one of the major advantages of lisp-like syntax.
19:35:08 <Adamant> nor is likely to completely go away
19:35:20 <timmaxw> maybe they have some kind of macro system that operates on the syntax...
19:35:24 <SamB_XP_> timmaxw: the simplicity is also useful ...
19:35:32 * syntaxglitch considers giving up on all this "programming language" nonsense and sticking with just the pure untyped lambda calculus
19:35:50 <Adamant> it's a programming language in mathematical form
19:35:50 <Cale> It's 2010, if your language doesn't have proper support for functions, there's no good excuse. It's been known since the 1970's how to implement functions properly.
19:36:03 <timmaxw> SamB_XP_: not as useful as the readability of infix operators (imho)
19:36:06 <monochrom> and user-defined operators
19:36:06 <Cale> (perhaps earlier)
19:36:06 <SamB_XP_> Cale: which language do you mean ?
19:36:24 <Cale> SamB_XP_: Any language without proper support for functions. C, Java...
19:36:31 <pikhq> Cale: My C compiler has proper function support.
19:36:31 <SamB_XP_> oh
19:36:36 <Adamant> I don't blame C for that, I do blame Java
19:36:38 <SamB_XP_> what do you want them to do ?
19:36:39 * geheimdienst considers giving up on all this "programming language" nonsense and sticking with feeding paper tapes to turing machines
19:36:40 <syntaxglitch> Cale, I'm curious what you define as proper in this case
19:36:45 <pikhq> It's somewhat different from normal functions, though.
19:36:48 <pikhq> SamB_XP_: Close.
19:36:55 <SamB_XP_> and yeah, C really can't be expected to do that for plain functions
19:37:08 <SamB_XP_> it would incur COSTs
19:37:16 <Cale> syntaxglitch: The usual. Functions should be first class values.
19:37:29 <ezyang> geheimdienst: Turing Machines, Lambda Calculus. Totally invented at the same time.
19:37:30 * monochrom considers giving up on languages and machines and calculi, and sticking with Kleene normal form.
19:37:36 <pikhq> ^(int x){ // Hey, look mah, I'm first-class! }
19:37:46 <Cale> Better still if you have a nice separation between functions (with no effects) and procedures (with)
19:37:57 <SamB_XP_> Cale: that either requires runtime code generation or different, slower, function pointer representations
19:38:04 <geheimdienst> pikhq, is that the closure stuff apple recently came up with?
19:38:09 <pikhq> geheimdienst: Yes.
19:38:20 <timmaxw> apple calls them "blocks"
19:38:27 <syntaxglitch> ezyang, combinator logic predated both, though :)
19:38:35 <pikhq> timmaxw: Yeah, that's a Smalltalkism.
19:38:39 <Cale> SamB_XP_: There are lots of implementations, I don't care which you choose ;)
19:38:39 <SamB_XP_> timmaxw: because that's what smalltalk calls them
19:38:46 <ddarius> SamB_XP_: Not really slower, bigger.
19:38:59 <SamB_XP_> ddarius: hmm, okay, maybe not slower on recent CPUs
19:39:05 <SamB_XP_> but on a PII it might be!
19:39:06 <Adamant> pikhq: I thought it was a Rubyism, but that makes sense given how much Ruby drew from Smalltalk
19:39:07 <Cale> Function pointers are not the same thing *at all* as functions though.
19:39:26 <pikhq> Cale: A block, however, is. :)
19:39:33 <ddarius> SamB_XP_: Why would new_func_ptr = (old_func_ptr, closure_ptr) be slower to use?
19:39:45 <ddarius> s/closure_ptr/closure/
19:39:52 <monochrom> because PII had too few registers
19:39:56 <geheimdienst> adamant, i think objective c borrowed quite a few things from smalltalk. calling functions [like this] is another one ...
19:39:56 <timmaxw> ddarius: i guess because you have to copy two pointers?
19:39:56 <SamB_XP_> ddarius: slower at runtime
19:39:56 <pikhq> ddarius: ZOMG NEEDS GARBAGE COLLECTION OR REFERENCE COUNTING
19:39:57 <ezyang> syntaxglitch: SKI, you mean?
19:40:19 <ezyang> (well, S-K, since you don't really need I)
19:40:24 <Cale> I'm not saying that C should change to support first class functions.
19:40:25 <pikhq> geheimdienst: Objective C is the Smalltalk object system as an extension to C.
19:40:32 <timmaxw> pikhq: i think that apple's blocks are manually managed
19:40:33 <syntaxglitch> ezyang, not sure about that, I think Schnfinkel's original formulation used a different basis
19:40:38 <Cale> I'm saying that people using C to write applications should reconsider their choice of language.
19:40:53 <pikhq> timmaxw: Reference-counted or garbage collected, depending.
19:40:55 <SamB_XP_> Cale: ah
19:41:09 <timmaxw> pikhq: ok, i guess i'm wrong then
19:41:11 <SamB_XP_> asm: also, ASM doesn't support first-class functions ;-P
19:41:15 <SamB_XP_> er. Cale
19:41:16 <Adamant> geheimdienst: yeah, both Obj-C and Ruby were very inspired by Smalltalk. Ruby was also inspired by Scheme and Perl.
19:41:20 <geheimdienst> pikhq, objective c combines the memory safety of c with the blazing execution speed of smalltalk ;-)
19:41:22 <ddarius> pikhq: Not in a C context, and even if you did add those, they only need to apply when the closed over environment is non-trivial (i.e. only when you're doing something you couldn't before.)
19:41:30 <Cale> Actually, I don't think C should ever change. People should stop working on it entirely ;)
19:41:31 <monochrom> Choosing programming languages is like choosing nationalities.
19:41:40 <pikhq> ddarius: Still reference-counted.
19:41:55 <timmaxw> here is a question on a different topic: if all of your data structures are acyclic, are there any advantages to garbage collection over memory management?
19:42:01 <timmaxw> *over reference counting
19:42:02 <timmaxw> oops
19:42:17 <ezyang> timmaxw: Locality, maybe?
19:42:19 <SamB_XP_> timmaxw: it can make things faster
19:42:21 <pikhq> timmaxw: Garbage collection is often, but not necessarily, more efficient.
19:42:39 <SamB_XP_> all those increfs/decrefs can really slow up the works, sometimes
19:42:58 <Cale> I suppose it depends on what "garbage collection" means. Reference counting can be considered a technique for garbage collection.
19:43:15 <timmaxw> by "garbage collection" i meant mark and sweep
19:43:24 <pikhq> Cale: I'd say that its inability to detect cycles disqualifies it.
19:43:29 <pikhq> timmaxw: There's more GC methods.
19:43:31 * geheimdienst , for no particular reason, points out that hardlinks in unix are something like a reference-counting scheme
19:43:34 <ezyang> timmaxw: Bah, mark and sweep is so old school. :-)
19:43:40 <ddarius> pikhq, SamB_XP_: You can use the exact same representation for both in the trivial environment case.
19:43:42 <SamB_XP_> timmaxw: I'm not sure about that situation
19:43:43 <Adamant> Cale: I think writing most application in C at this point is ridiculous, but people in general don't do it anymore anyway. C is still useful for some things and appropriate for use there, if for no other reason than nobody has bothered to write a decent substitute.
19:43:46 <pikhq> geheimdienst: They are, in fact, reference counting.
19:44:00 <timmaxw> ezyang: if it's already in the cache, is there any additional cost to incrementing a ref counter? or is there an extra cost because the version in main memory must also be changed?
19:44:21 <SamB_XP_> ddarius: the compiler can't optimize like that for exported interfaces!
19:44:30 <Cale> Adamant: There seem to be an awful lot of programs which are still being written in stupid languages that don't properly support first class procedures/functions.
19:44:32 <pikhq> timmaxw: There is an extra cost because incrementing a reference counter takes instructions.
19:44:39 <Cale> Adamant: If not C, then C++
19:44:44 <geheimdienst> pikhq yes, and you get away with ref-counting because there can't be any cycles
19:44:48 <timmaxw> the practical application of this was: i was wondering if a Haskell program could be statically analyzed to determine which data structures had to be handled with mark/sweep and which could be reference-counted
19:44:50 <pikhq> geheimdienst: Yes.
19:44:52 <SamB_XP_> pikhq: and dirties pages etc.
19:44:59 <ezyang> timmaxw: A sophicsticated GC can move around pieces of memory, free up larger contiguous blocks of space, and save work by noticing that old data doesn't get freed ever.
19:45:21 <pikhq> Yes, it dirties pages. Also, if you want to be multithreaded, you need to make your reference counting atomic. Which is a pain.
19:45:28 <Adamant> Cale: there is a better case against C++, but there still isn't a general substitute for it either in it's niches like gaming/simulations.
19:45:30 <ezyang> timmaxw: Ah, you're interested in pluggable GC blueprinting
19:45:32 <SamB_XP_> ezyang: but not a GC for C
19:45:32 <timmaxw> so (in theory) reference counting could be used on acyclic structures, while mark/sweep was used on cyclic ones. but if mark/sweep is no slower, there's no point
19:45:44 <ezyang> SamB_XP_: Sure.
19:45:59 <pikhq> SamB_XP_: Sure it could. Just not one that used normal C pointers.
19:46:04 <pikhq> >:D
19:46:25 <SamB_XP_> pikhq: that would not be "for C", that would be "for some system which is inexplicably written in C"
19:46:28 <ezyang> pikhq: I think SamB's point is that no one writing pure C actually implements a GC mechanism that complicated
19:46:40 <ezyang> It'd be some virtual machine or something... ah, SamB said it
19:46:50 <pikhq> SamB_XP_: Just opaque pointers. For some maniacal, evil purpose.
19:46:56 * syntaxglitch wonders about linear logic-based type systems for static analysis of resource use
19:47:06 <pikhq> Alternately, you could just... Use a better language.
19:47:27 <ezyang> Although I do agree that finer granularity specification for GC would be interesting.
19:47:33 <SamB_XP_> pikhq: ah, you mean like those XOR'd pointers that some people's libraries use ?
19:47:50 <Cale> timmaxw: It's worth noting that the GC in GHC is already selecting between copy collection and mark/sweep based on the proportion of the allowed heap size the program is using (with the most common case being copy collection)
19:48:00 <ezyang> although I doubt very many people would understand their code well enough to make a good guess :-)
19:48:10 <timmaxw> Cale: i didn't know there was any method other than mark/sweep! *goes to google*
19:48:21 <Cale> timmaxw: Also, it's generational
19:48:26 <ezyang> (a friend of mine tells me, "Any monkey can write reasonably fast Java. Get back to me when it's the case for Haskell.")
19:48:28 <pikhq> SamB_XP_: No, I mean in the sense of typedef struct pointer_t *your_pointer; where struct pointer_t {size_t heap_offset;};
19:48:33 <pikhq> SamB_XP_: Which is just getting silly.
19:48:36 <SamB_XP_> ezyang: hehehehehe
19:48:51 <pikhq> And requires a ton of manual legwork.
19:48:57 <Adamant> ezyang: lol, since when
19:49:09 <ezyang> Adamant: Since, like, recent versions of the JVM.
19:49:14 <pikhq> ezyang: Ah, Haskell is faster than Java...
19:49:28 <ezyang> You still get slaughtered on startup costs, but after that it does some pretty freaky stuff on the bytecode level.
19:49:32 <SamB_XP_> pikhq: yeah, but monkey's can't get their code to typecheck
19:49:37 <syntaxglitch> Any monkey can write Haskell that doesn't throw null reference exceptions, when will that be the case for Java? :P
19:49:48 <ezyang> syntaxglitch: :-)
19:49:55 <pikhq> timmaxw: There's also copying garbage collection. Which is simple and brilliant.
19:50:04 <Adamant> ezyang: I think it's questionable. If someone is really a monkey, they're going to write slow Java
19:50:05 <aavogt> it's easy to use partial functions in haskell
19:50:20 <pikhq> aavogt: It's also easy to not make them partial.
19:50:21 <Adamant> because they won't understand how to optimize things
19:50:24 <ddarius> SamB_XP_: Why not?  Even when the closed over environment is non-trivial, we could stick to passing around just function pointers as only the pointed to function has to know where its environment is.
19:50:25 <syntaxglitch> aavogt, it's also easy to avoid, even without enabling extra warnings
19:50:37 <timmaxw> syntaxglitch: that's stupid. what good is a language where you can't even throw null reference exceptions? that's the first thing that every junior programmer learns how to do!
19:50:38 <monochrom> ezyang's friend is correct. And I remind you of what Gerald Weinberg wrote in «The Psychology of Computer Programming»: "if it doesn't have to be correct, I can make it 10x faster".
19:50:44 <aavogt> pikhq, syntaxglitch what I mean is that they are in the Prelude
19:50:45 <ezyang> Adamant: Java literally has the ability to take slow sections of code and repeatedly apply optimizations
19:50:53 <SamB_XP_> ddarius: then we get back to runtime code generation
19:51:04 <ezyang> and special-case for common paths
19:51:13 <aavogt> you don't have to do anything to get them in scope
19:51:14 <timmaxw> isn't the cost of copying every single object in memory prohibitively expensive in copy collection?
19:51:17 <ezyang> so by the time you've been through the path a few hundred times Java is doing the right thing.
19:51:30 <SamB_XP_> timmaxw: it's good if most objects are garbage
19:51:31 <pikhq> ezyang: Yes, and Haskell is still faster. Because GHC is sheer insanity. :P
19:51:31 <ezyang> timmaxw: it's expensive, but not prohibitavely so.
19:51:35 <SamB_XP_> you don't have to look at them at all, then
19:51:49 <timmaxw> ezyang: but because that's done at runtime, the runtime is enormous.
19:51:50 <SamB_XP_> timmaxw: see, it only copies the LIVE objects
19:52:00 <pikhq> timmaxw: Expensive, but not as much as you'd think when you're generating large amounts of garbage.
19:52:01 <Adamant> ezyang: I thought the argument was that it was easier for the average programmer to optimize Java than Haskell
19:52:06 <timmaxw> oh, i see. but that can still be a lot of copying.
19:52:18 <SamB_XP_> well, the generational aspect helps with that
19:52:23 <Cale> Also, the heap is broken up into generations, so as to help short-lived objects die quick deaths, and waste less time checking if long-lived objects need to be collected.
19:52:26 <geheimdienst> timmaxw and it turned out that in practice, there's lots and lots of short-lived objects in a program
19:52:33 <ezyang> Adamant: No no, the argument is that more Java, which looks terrible perf wise, ends up running fairly decently once HotSpot is turned on.
19:52:33 <pikhq> This is why generally you go for generational collection.
19:53:01 <Cale> It's a heck of a lot smarter than manual memory management schemes tend to be :)
19:53:03 <SamB_XP_> ezyang: how does that work ?
19:53:08 <ezyang> I was a disbeliever, until I got a stern talking to on the Clojure lists about how to properly benchmark Java code :-)
19:53:09 <Adamant> ezyang: oh yeah, I knew that, but even with Hotspot and all the stuff they've thrown at Java, it's still going to be slower than stuff like Ocaml or Haskell
19:53:14 <SamB_XP_> a monkey would use an O(n^2) algorithm
19:53:16 <timmaxw> if an object has a short finite life, does GHC manage its memory manually? for example, an intermediate number in a numerical calculation
19:53:17 <pikhq> SamB_XP_: Java's JIT is clever.
19:53:18 <syntaxglitch> The JVM is actually pretty scary these days
19:53:22 <pikhq> That's about it.
19:53:28 <SamB_XP_> JVM can help with that?
19:53:51 <SamB_XP_> timmaxw: they likely never get allocated
19:54:07 <monochrom> Don't forget that JIT gets fairly close to whole-program analysis for those paths that matter.
19:54:07 <timmaxw> SamB_XP_: how about an intermediate string?
19:54:09 <SamB_XP_> I mean, they'll probably be kept in registers/stack
19:54:17 <SamB_XP_> timmaxw: hopefully that gets fused away
19:54:33 <Cale> Strings are linked lists of pointers to 32-bit Char values though
19:54:36 <pikhq> timmaxw: I'm pretty sure GHC quite likes getting rid of intermediates and shoving stuff on the stack when it can.
19:54:39 <SamB_XP_> monochrom: maybe we should get in on that
19:54:43 <monochrom> run-time monitoring finds some information not found by known static analyses.
19:55:04 <Cale> *however* they're lazy lists
19:55:20 <Adamant> yeah, but the practical effects so far haven't been nearly as dramatic as claimed.
19:55:35 <Cale> So often, if you're using a String, you might only have a few of the characters in memory at any given time, even if the String is infinitely long.
19:56:02 <Cale> and GHC is really good at picking up the short-lived cons-cells anyway
19:56:32 <Cale> But yeah, it's nice when intermediate lists fuse away, though it doesn't happen quite as often as we might like.
19:56:53 <timmaxw> so there wouldn't really be a performance improvement to determining the exact lifetime at compile time
19:57:13 <Cale> Well, there would, it can just be complicated. There's been research into region inference
19:57:49 <timmaxw> Cale: okay. and here i was thinking i'd thought of something new.
19:58:15 <Cale> http://hackage.haskell.org/packages/archive/pkg-list.html#cat:monadic%20regions -- you can use regions by hand
19:58:54 <Cale> There seem to be a few libraries for it, but I've never tried them
19:59:01 <FliPPeh_> Cale: do you know the /proc/cpuinfo format? If so, do you think I could parse each recognized core and all it's details using Parsec, or should I use a combination of string functions and parsec? This actually looks like something only list functions can do...
19:59:27 <FliPPeh_> For example, I think grouping the individual cores is easier with groupBy
20:00:04 <Cale> FliPPeh_: It's possible to do it in any number of ways... I would use Parsec or ReadP if I was planning to parse out all the fields into a nice data structure.
20:00:22 <FliPPeh_> I'll just "need" a few ones, the obvious ones
20:00:39 <Cale> Yeah, I might just use list functions in that case.
20:01:39 <FliPPeh_> > (groupBy (\_ (a, b) -> a /= "processor") . map ((\(a,b) -> (takeWhile (/='\t') a, drop 2 b)) . break (== ':'))  . lines) "processor\t: 0\nmodel\t: Sample"
20:01:40 <lambdabot>   [[("processor","0"),("model","Sample")]]
20:02:03 <FliPPeh_> > (groupBy (\_ (a, b) -> a /= "processor") . map ((\(a,b) -> (takeWhile (/='\t') a, drop 2 b)) . break (== ':'))  . lines) "processor\t: 0\nmodel\t: Sample\nprocessor\t: 1\nmodel\t: Sample core 2"
20:02:04 <lambdabot>   [[("processor","0"),("model","Sample")],[("processor","1"),("model","Sample...
20:02:07 <FliPPeh_> Looks good.
20:02:31 <FliPPeh_> I just don't like that takeWhile there...
20:02:35 <FliPPeh_> Looks fragile...
20:03:46 <Cale> FliPPeh_: Might be better to look for the colon
20:04:07 <FliPPeh_> But I'm already breaking at the colon
20:04:15 <Cale> oh, yes, sorry
20:04:16 <FliPPeh_> So it's on the value side, not on the key side
20:04:18 <FliPPeh_> :)
20:04:36 <FliPPeh_> After break, they end up [("processor\t", ": 0")]
20:04:44 <FliPPeh_> Or more \t's
20:04:51 <geheimdienst> flippeh_, there's also a package configparser (or similar) on hackage which can parse key: value files ...
20:05:02 <FliPPeh_> > takeWhile (/= '\t') "test"
20:05:03 <lambdabot>   "test"
20:05:06 <FliPPeh_> > takeWhile (/= '\t') "test\t\t"
20:05:07 <lambdabot>   "test"
20:05:08 <FliPPeh_> Oh well
20:05:09 <Cale> you could also just do  unwords . words
20:05:12 <FliPPeh_> Doesn't matter.
20:05:16 <FliPPeh_> :)
20:05:19 <FliPPeh_> Works like this
20:05:58 <Cale> > unwords . words $ "  here is  \t \v\n  a string    with lots of   extra whitespace\t"
20:05:59 <lambdabot>   "here is a string with lots of extra whitespace"
20:07:45 <FliPPeh_> Well, that would change some stuff out of it's original values, for example, on my laptop the processor shows up as "Intel Core 2 Due T8100    @ 2.1 GHz" or something
20:08:22 <FliPPeh_> So in order to keep those values intact, this is probably the cleanest way
20:08:54 <Cale> You could also worry that there might be a tab character in the middle of the line...
20:09:10 <FliPPeh_> That might be a problem
20:09:18 <Cale> Maybe  reverse . dropWhile isSpace . reverse . dropWhile isSpace  would be better.
20:09:25 <FliPPeh_> But why could that happen?
20:09:33 <Cale> I don't know.
20:09:58 <Cale> (I'm not actually completely sure what format that file adheres to)
20:10:13 <geheimdienst> hm ... there's no way to pattern-match in a lambda, right?
20:10:24 <Cale> geheimdienst: You can use case
20:10:30 <Cale> (\x -> case x of ...)
20:10:42 <FliPPeh_> I think it's implementation dependant
20:10:46 <FliPPeh_> Linux uses tabs
20:10:55 <FliPPeh_> No idea about BSD's or Solaris
20:11:07 <Cale> Otherwise, you can only match one pattern, and the others (if any) result in runtime exceptions.
20:11:14 <geheimdienst> cale, i was thinking of a function that takes 3 Bools. that's very natural to write as a function, but as a lambda ...
20:11:41 <aavogt> what does natural mean here?
20:11:47 <Cale> There are places where lambda is and is not totally appropriate.
20:11:50 <FliPPeh_> > (\(a:b:c:_) -> (a,b,c)) [1,2,3,4,5]
20:11:51 <lambdabot>   (1,2,3)
20:11:52 <FliPPeh_> ?
20:12:00 <FliPPeh_> Looks like pattern matching to me :
20:12:00 <FliPPeh_> :(
20:12:03 <Cale> This is why we have lots of syntaxes :)
20:12:07 <timmaxw> let f x = [(unwords k, unwords v) | line <- lines x, (k,_:v) <- break (== ":") words line] in f "processor\t: 0\nmodel\t: Sample\nprocessor\t: 1\nmodel\t: Sample core 2"
20:12:08 * liyang hates writing out the function name every time so ends up using case … of anyway.
20:12:18 <timmaxw> > let f x = [(unwords k, unwords v) | line <- lines x, (k,_:v) <- break (== ":") words line] in f "processor\t: 0\nmodel\t: Sample\nprocessor\t: 1\nmodel\t: Sample core 2"
20:12:19 <lambdabot>   Couldn't match expected type `[[GHC.Types.Char]]'
20:12:19 <lambdabot>         against inferred ...
20:12:24 <timmaxw> oops
20:12:27 <geheimdienst> well "f True _ True = ..." "f False _ _ = ..." i mean, that's pretty clear and haskellish, right?
20:12:33 <FliPPeh_> Oh, like that
20:12:38 <Cale> geheimdienst: yeah
20:12:40 <geheimdienst> but i guess that f can't be turned into a lambda easily
20:12:45 <liyang> Ewww…
20:12:58 <timmaxw> > let f x = [(unwords k, unwords v) | line <- lines x, (k,_:v) <- break (== ":") $ words line] in f "processor\t: 0\nmodel\t: Sample\nprocessor\t: 1\nmodel\t: Sample core 2"
20:12:59 <lambdabot>   Couldn't match expected type `[t]'
20:12:59 <lambdabot>         against inferred type `([[GHC.Ty...
20:13:01 <Cale> geheimdienst: You could turn it into a logical expression using && and ||
20:13:04 <Cale> (and not)
20:13:09 <Cale> perhaps
20:13:43 <Cale> Oh, I suppose you'd still need some way to chain the conditions. if/then/else might be awkward.
20:13:56 <liyang> \ x y z -> case (x, y, z) of { (True, _, True) -> …; (False, _, _) -> … }
20:14:16 <geheimdienst> hey, good idea liyang
20:14:18 <FliPPeh_> Pattern matching in lambdas seems dangerous
20:14:19 <aavogt> write it uncurried
20:14:22 <timmaxw> > let f x = [(unwords k, unwords v) | line <- lines x, let (k,_:v) = break (== ":") $ words line] in f "processor\t: 0\nmodel\t: Sample\nprocessor\t: 1\nmodel\t: Sample core 2"
20:14:23 <lambdabot>   [("processor","0"),("model","Sample"),("processor","1"),("model","Sample co...
20:14:25 <FliPPeh_> For bools
20:14:33 <aavogt> \x -> case x of ...
20:15:11 <FliPPeh_> timmaxw: Now get it to group :)
20:15:18 <liyang> (Agda's ‘with’ allows multiple patterns which avoids this packing up into tuples nonsense.)
20:15:57 * humasect waits for ghc iphone/arm
20:16:07 <timmaxw> FliPPeh_: group by processor #?
20:16:09 <Cale> hmm
20:16:25 <FliPPeh_> Just start a new list for each "processor"
20:16:34 <FliPPeh_> > (groupBy (\_ (a, b) -> a /= "processor") . map ((\(a,b) -> (takeWhile (/='\t') a, drop 2 b)) . break (== ':'))  . lines) "processor\t: 0\nmodel\t: Sample\nprocessor\t: 1\nmodel\t: Sample core 2"
20:16:35 <lambdabot>   [[("processor","0"),("model","Sample")],[("processor","1"),("model","Sample...
20:23:28 <Cale> http://www.youtube.com/watch?v=bi4ACLfaWy0 -- cool :)
20:24:46 <FliPPeh_> Sweet
20:25:41 <aavogt> liyang: hows the 'with' look like?
20:31:59 <liyang> aavogt: multiple patterns separated with |. (Admittedly, you'd expect GHC to compile away the tuple packing in my example.)
20:33:15 <aavogt> I don't understand how it's much different from pattern guards + where
20:34:39 <ezyang> Bah... I wish that Data.Map specified if the O's were for average case or worst case times, and if the  were amortized
20:35:33 <geheimdienst> aavogt, but a lambda can't have guards, right?
20:35:38 <Jonno_FTW> test
20:36:13 <aavogt> geheimdienst: right
20:36:43 <aavogt> http://www.cse.chalmers.se/~ulfn/papers/afp08/tutorial.pdf <-- page 13
20:37:41 <dankna> argh!
20:37:48 <dankna> my grammer is not LALR(1) :(
20:37:53 <dankna> and for such a small thing, too
20:37:56 <dankna> *grammar
20:38:43 <aavogt> liyang: how would this look using 'with' anyways: \ x y z -> case (x, y, z) of { (True, _, True) -> ?; (False, _, _) -> ? }
20:40:38 <aavogt> or is that little description missing some features of that syntax?
20:43:21 * hackagebot hothasktags 0.1.0 - Generates ctags for Haskell, incorporating import lists and qualified imports  http://hackage.haskell.org/package/hothasktags-0.1.0 (LukePalmer)
20:43:22 <liyang> aavogt: you can't actually use with in a lambda due to subtleties of dependent pattern matching. :( At least, no one's figured out a sane syntax yet. (So you're forced to go with an auxiliary function definition.)
20:45:57 <aavogt> right, so it's no different that adding a where clause and using the features of -XPatternGuards
20:46:45 <djahandarie> dankna, LALR(2)? :P
20:47:51 <jeffwheeler> Those gtk2hs Cabal packages are great; I can't wait for them to be on Hackage.
20:53:31 <ddarius> :t \x | False -> x
20:53:32 <lambdabot> parse error on input `|'
20:55:09 <ddarius> :t \ -> 3
20:55:10 <lambdabot> parse error on input `->'
20:55:22 <SamB_XP_> ddarius: what the hell, man?
21:03:44 <edwardk> hah, was playing around with this little fmap like construction for doing 'slow' fmaps so i could get some things to avoid recursing when working with 'stream fusion' over free monads... and i discovered that i'd reinvented 'Traversable'
21:04:17 <edwardk> traverse in the Partiality monad does just what i need, skipping along  until it finishes the construction then giving it back
21:05:27 <Mathnerd314> how much code turns out to be just reinvention of the same algorithm?
21:05:40 <edwardk> Mathnerd314: 80% ;)
21:06:07 <edwardk> the best part is if you aren't greedy about counting your SLOC's it trims down afterwards and you wind up with something that looks far smarter than it has a right to =)
21:06:42 <Mathnerd314> is there an automatic way to say "oh, this part here is just such-and-such a function"?
21:07:06 <edwardk> Mathnerd314: pattern matching like that is at least np-complete ;)
21:07:20 <edwardk> too many overlapping functions you could use to simplify code
21:07:30 <djahandarie> Me and NP-Complete don't get along
21:07:44 <edwardk> though, andy gill had a little refactoring browser for haskell a few years back, wonder what ever came of it
21:08:00 <shapr> He's working on Hood at the moment.
21:08:04 <shapr> and Lava
21:08:13 <edwardk> he did a slick little demo of it at icfp06
21:08:17 <edwardk> yeah
21:08:17 <geheimdienst> uh, if i have an IO [Foo] and an IO Foo, how do i append that to the list?
21:08:25 <edwardk> prepend or append?
21:08:29 <edwardk> faster to prepend =()
21:08:40 <edwardk> @type snoc
21:08:41 <geheimdienst> append in this case ...
21:08:41 <lambdabot> Not in scope: `snoc'
21:09:05 <edwardk> (++) <$> listFoo <*> [singletonBar]
21:09:16 <edwardk> were listFoo and singletonBar are your list and singleton respectively
21:09:18 <aavogt> except singletonBar is in IO
21:09:21 <dons> ?ywo
21:09:21 <lambdabot> Maybe you meant: do wn yow
21:09:23 <edwardk> er
21:09:25 <dons> maybe.
21:09:25 <SamB_XP_> :t (++) <$> ?listFoo <*> [?singletonBar]
21:09:26 <edwardk> yeah
21:09:26 <lambdabot> forall a. (Monoid a, ?listFoo::[a], ?singletonBar::a) => [a]
21:09:31 <dons> mm
21:09:47 <dons> ?singletonBar::a <--
21:09:47 <lambdabot> Unknown command, try @list
21:10:25 <SamB_XP_> somehow that doesn't look like the right typesig :-(
21:10:33 <edwardk> :t (++) <$> ?a <*> (return <$> ?b)
21:10:34 <lambdabot> forall (f :: * -> *) a (m :: * -> *). (Monoid (m a), ?a::f (m a), Applicative f, Monad m, ?b::f a) => f (m a)
21:10:47 <edwardk> =P
21:10:59 <aavogt> rewrite your  IO [Foo]   to    IO ([Foo] -> [Foo])  (ie. a function to prepend to a given tail)
21:11:17 <SamB_XP_> :t (Data.List.++) <$> ?a <*> (return <$> ?b)
21:11:18 <lambdabot> forall a (f :: * -> *). (?a::f [a], Applicative f, ?b::f a) => f [a]
21:11:32 <timmaxw> do {init <- listFoo; last <- singletonBar; return (init++[last])}
21:11:43 <aavogt> then your combination is     listFoo <*> (return <$> singletonBar)
21:11:57 <timmaxw> :t do {init <- ?listFoo; last <- ?singletonBar; return (init++[last])}
21:11:58 <lambdabot> forall (m :: * -> *) t. (?listFoo::m [t], Monad m, ?singletonBar::m t) => m [t]
21:12:02 <cydork> what is fastest way to read stdin? i have tried hGetContents but i still think it can be faster..
21:12:04 <aavogt> appending lists is inefficient
21:12:29 <geheimdienst> thanks for all the suggestions, guys
21:12:37 <edwardk> aavogt: clearly he should be using ropes ;)
21:13:31 <Axman6> cydork: use ByteStrings
21:13:40 <geheimdienst> guys, i'm telling you, appending is just fine. it's a list of 3 or 4 things, and it's configuration stuff read only once on program startup
21:13:44 <geheimdienst> :)
21:14:09 <edwardk> geheimdienst: thats what they all say, then the list grows by just one more item and soon, you're google. ;)
21:14:17 <cydork> Axman6: checking it out..
21:14:32 <SamB_XP_> geheimdienst: but if you're positive of the size ...
21:18:46 <dons> cydork: mmapFile
21:19:37 * hackagebot libmpd 0.4.0 - An MPD client library.  http://hackage.haskell.org/package/libmpd-0.4.0 (JoachimFasting)
21:20:22 * SamB_XP_ wonders if you can use mmap for lazy bytestrings ;-P
21:20:58 <geheimdienst> samb, why, that would just be a monoid in the category of endofunctors
21:21:02 <edwardk> SamB_XP_: there is a module
21:21:45 <dobie_gillis> i have a question regarding data types.... http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24382#a24382
21:21:52 <dcolish> dcoutts: did you ever figure out a good semantic for dealing with the macports vs system lib issue on osx?
21:23:25 <liyang> dobie_gillis: what you've got already seems to be the Right Thing.
21:25:16 <Parkotron> I find myself writing Parsec code that looks like this: http://paste.pocoo.org/show/194064/
21:25:33 <Parkotron> Is there some kind of Parse "case" function I should be using instead?
21:26:00 <cydork> dons: care for an example?
21:26:08 <dobie_gillis> liyang: thanks... i would like to be able to map a function onto it... e.g. turn all buttons to the off state. can i achieve this with fmap?
21:26:40 <aavogt> Parkotron: you can write one if you're bored of writing string and return so frequently...
21:27:16 <aavogt> but seeing as <|> doesn't backtrack by default that might be a bit misleading
21:28:20 <Parkotron> aavogt: Good point. If it were a function, it would probably need to use "try" to be user safe.
21:29:06 <aavogt> basically you can factor out some of the redundancy by taking [(String,Type)]
21:30:15 <Parkotron> aavogt: Thanks. That's a good idea. I'll just add a simple stringToType method.
21:30:22 <aavogt> then    foldr (\(str,ty) rest -> string str >> return ty <|> rest) (fail "none matched")
21:31:22 <aavogt> if your data type has exactly the same names (as in  map toLower (show x) is the string, it might be sensible to do that too)
21:31:54 <aavogt> Parkotron: also, you can derive Bounded and Enum to not have to name the constructors more than once...
21:33:01 <Parkotron> aavogt: I think you just went beyond my level there. :) This is just a simple homework assignment, so it doesn't ahve to be too fancy.
21:33:23 <aavogt> > [minBound .. ] :: Bool
21:33:24 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
21:33:24 <lambdabot>         against inferred type ...
21:33:34 <aavogt> > [minBound .. ] :: [Bool]
21:33:35 <lambdabot>   [False,True]
21:34:02 <aavogt> Parkotron: ^^ except you can get that for your own types too
21:34:08 <dons> cydork: s <- mmapFile "f"
21:34:21 <dons> from  the bytestring-mmap file (for really fast io)
21:34:31 <dons> s :: ByteString
21:34:50 <aavogt> dons: how much faster is it?
21:34:52 <cydork> dons: oh.. thanks.. i will dig deeper..
21:34:52 <geheimdienst> ok, and the easiest way to turn a IO Foo into an IO [Foo] (of length 1) is this: fmap (:[])
21:34:54 <geheimdienst> right?
21:35:09 <aavogt> right
21:35:51 <ddarius> aavogt, Parkotron: See choice.
21:35:54 <ddarius> :t choic
21:35:55 <lambdabot> Not in scope: `choic'
21:35:55 <ddarius> :t choice
21:35:56 * geheimdienst is giggling with joy because he got something right in haskell!
21:35:56 <lambdabot> Not in scope: `choice'
21:36:01 <ddarius> @hoogle choice
21:36:01 <lambdabot> Text.Parsec.Combinator choice :: Stream s m t => [ParsecT s u m a] -> ParsecT s u m a
21:36:01 <lambdabot> Text.ParserCombinators.ReadP choice :: [ReadP a] -> ReadP a
21:36:01 <lambdabot> Text.ParserCombinators.ReadPrec choice :: [ReadPrec a] -> ReadPrec a
21:36:21 <aavogt> @hoogle Alternative f => [f a] -> f a
21:36:22 <lambdabot> Data.Foldable asum :: (Foldable t, Alternative f) => t (f a) -> f a
21:36:22 <lambdabot> Control.Monad msum :: MonadPlus m => [m a] -> m a
21:36:22 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
21:37:27 <maciej`> hello again :-)
21:38:54 <edwardk> @pl \f a b -> a (f b)
21:38:54 <lambdabot> flip (.)
21:38:58 <maciej`> in ghci, is there a way to check which line caused an exception?
21:39:28 <aavogt> maciej`: if the code is interpreted, you can set something like -fbreak-on-exceptions or some such
21:39:52 <liyang> dobie_gillis: if you want to use fmap, you'd have to make MmaMenu a Functor, i.e. make it parametric on the type of the (six) fields, and you'd write MmaMenu MmaButton for original type you had. Though this also means you can have MmaMenu alpha for any other alpha, which might not make sense for whatever it is you're doing.
21:42:54 <maciej`> aavogt: i tried that, but it only shows me the code which forced the evaluation. e.g. if I use buggy code to (lazily) compute x, an exception will only be thrown only when x needs to be forced
21:43:09 <maciej`> so it looks like the code that uses x causes it
21:43:32 <Parkotron> aavogt: Is this the most sensible way to parse an alphanumeric string starting with a letter? "liftM2 (:) letter (many alphaNum)"
21:43:42 <aavogt> maciej`: then you can step back using :back
21:43:44 <jmcarthur> edwardk: does this look like anything you've seen before?  f a -> f b -> f (Either a b)  -- i first thought to look at your Control.Functor.Zip module, but it doesn't have a match there
21:43:58 <edwardk> hrmm
21:44:06 <edwardk> its kind of odd
21:44:40 <edwardk> is it doing something like \a b -> fmap Left a `fplus` fmap Right b ?
21:45:11 <jmcarthur> edwardk: i working with a model for what i guess i would call futures. the result is whichever of the two inputs occurs first
21:45:19 <Mathnerd314> edwardk: it looks like HERA is up at http://www.haskell.org/haskellwiki/Haskell_Equational_Reasoning_Assistant
21:45:27 <jmcarthur> *i'm
21:45:29 <edwardk> jmcarthur: partiality monad?
21:45:45 <jmcarthur> edwardk: i suppose that would be an implementation of this model
21:46:07 <edwardk> heh, you may have just prompted me to make my partiality monad into mplus with mzero as fix Partial ;)
21:46:15 <edwardk> er into MonadPlus
21:46:22 <edwardk> Mathnerd314: neat =)
21:46:38 <jmcarthur> edwardk: yeah i put mine in monadplus (a month or two ago)
21:47:02 <jmcarthur> same semantics too
21:47:09 <jmcarthur> the laws work
21:47:46 <jmcarthur> edwardk: anyway, i was just seeing if you had seen that pattern before. looks like you haven't really. thanks
21:47:55 <dcolish> have ya'll be able to get HERA to compile?
21:48:24 <edwardk> jmcarthur: nah, i wrote a 'race' function for racing partiality monads against each other with that sig
21:48:29 <edwardk> but there is no magical categorical name for it
21:48:41 <edwardk> dcolish: never tried, just saw a demo once
21:48:55 <Mathnerd314> edwardk: he also mentions HERA in his description of KURE: http://www.ittc.ku.edu/~andygill/kure.php
21:49:07 <dcolish> i've been running into issues here
21:50:12 <edwardk> jmcarthur: if nothing else i got a useful implementation of alternative for my partiality monad. hadn't been willing to allow non-termination in it, since i was just using it to pump streams
21:53:28 <jmcarthur> edwardk: wait, alternative without nontermination? what's empty then?
21:53:39 <edwardk> jmcarthur: i hadn't had it ;)
21:53:52 <edwardk> i was just using the data version of the monad, not the codata
21:53:58 <jmcarthur> oh!
21:54:01 <edwardk> for 'eventually but slow' computation
21:54:10 <edwardk> like pumping the next item of a list, etc.
21:54:28 <jmcarthur> in mine i actually added a special case for explicit nontermination
21:54:36 <jmcarthur> and it was codata
21:54:39 <edwardk> ah a Bottom constructor?
21:54:44 <jmcarthur> yeah
21:54:51 <edwardk> yeah doesn't fit my domain
21:54:51 <jmcarthur> for efficiency only
21:54:54 <jmcarthur> ah
21:55:07 <edwardk> using it in stream fusion over free monads
21:55:21 <jmcarthur> now that's interesting
21:55:22 <edwardk> trying to see if i can use traverse in the partiality monad over the base functor
21:55:55 <edwardk> and with that trying to see if that is sufficient to 'skip' a bounded number of times
21:56:04 <edwardk> probably doesn't make sense
21:56:09 <edwardk> but it did at 2 am when i had the idea ;)
21:56:25 <maciej`> i just tried :back and :list, this is what i'm getting as the output:
21:56:26 <maciej`> 35        subtrees' :: [Int] -> SyntaxTree -> [Subtree]
21:56:26 <maciej`> 36        subtrees' _    l@(Leaf _) = []
21:56:26 <maciej`>                                       ^^
21:56:29 <maciej`> 37        subtrees' path t@(Branch _ _ children) = (Subtree t path) : recurse children
21:56:38 <maciej`> the exception is divide by 0
21:57:29 <maciej`> i don't get how that would cause a division by 0
21:57:45 <edwardk> what is interesting to me is the fact that i think there should be something you can do to optimize stream operations over arbitrary functors/bifunctors, at least if you look at the structure of the free monad, and the codensity optimization tricks you can use to avoid retraversal.
21:58:28 <edwardk> layering codensity over the stream should right associate all the binds minimizing the number of functor traversals being done
21:58:47 <edwardk> so if i can pay for the traversal using partiality...
21:59:25 <edwardk> the worry i have is that that traversal is going to have to generate all of the children which may be exactly what i don't want
22:00:49 <aavogt> go back and see what produces the [Int]?
22:01:03 <edwardk> otohoh, if the base functor/bifunctor is flat which it should be unless you are streaming a bush,or something, then it should finish one traversal in a bounded number of steps
22:02:32 <edwardk> and even if the functor internally recurses on itself it should do the right thing
22:03:55 <edwardk> maciej`: forcing the SyntaxTree probably is causing the division to happen somewhere down inside of the thunk that is generating that leaf node
22:04:21 <edwardk> maciej`: look through the code that generates the leaf you're feeding to subtrees, not the subtrees code itself.
22:05:07 <maciej`> edwardk: yeah i figured. it sucks that ghci doesn't do that automatically
22:05:18 <edwardk> backing away from my the fusion toys and going back to work on something that might be usable ;)
22:08:56 <maciej`> is there a good reason why pointing to the place where the thunk is forced better than pointing to the exact operation within the thunk?
22:09:25 <edwardk> yes, because until it is forced you don't have an error ;)
22:09:44 <edwardk> and if you showed where the error occured you'd get thousands of errors in head ;)
22:11:21 <maciej`> edwardk: good point with the errors in head. I just think that a stack trace that imperative languages give you makes debugging easier :-)
22:11:40 <edwardk> there was some progress on a stack-like construct for ghc, but i never did see what happened with it
22:11:57 <superoptimizer> I'm trying to do a compile with ghc on Mac OS X, and it looks like ghc is generating 32-bit code and gas is barfing on it. From googling it looks like there is a ticket on lack of 64-bit codegen support on Mac OS, but I can't find any workarounds. Is it possible to get ghc to pass an -arch flag to gcc/gas so that it will assemble the output properly?
22:12:42 <edwardk> hrmm: http://hackage.haskell.org/trac/ghc/wiki/ExplicitCallStack
22:12:47 <edwardk> doesn't look implemented
22:13:28 <edwardk> ah here is a better link http://hackage.haskell.org/trac/ghc/wiki/ExplicitCallStack/CorePassImplementation
22:14:28 <edwardk> hrmm that would be an awesome, if somewhat daunting summer of code project to reintegrate that stuff into HEAD ;)
22:16:02 <maciej`> haha, are you volunteering?
22:16:26 <edwardk> maciej`: as administrator i think it would hardly be ethical for me to try to become a student and participate as such ;)
22:17:54 <Alpounet> there's only one GHC related project "proposal" afaik for the moment
22:18:19 <edwardk> Alpounet: well, largely because no one can update the list =)
22:18:22 <shapr> edwardk: I'm a student!
22:18:26 <geheimdienst> you know, i've been thinking of applying for soc ...
22:18:33 <edwardk> shapr: good, can i sign you up?
22:18:38 <shapr> edwardk: For what?
22:18:42 <edwardk> summer of code =)
22:18:56 <shapr> edwardk: Sure, as long as it's for writing QuickFuzz.
22:19:11 <Alpounet> edwardk, yeah but on -cafe and #haskell-soc people talk about their ideas a bit
22:19:24 <edwardk> 5k to hack on haskell -- just need to get your project past the grueling array of mentors we have this year. i think you know your way around the process ;)
22:19:32 <shapr> edwardk: Could be :-)
22:19:37 <edwardk> shapr: quickfuzz?
22:19:55 <shapr> Yeah, use QuickCheck to do fuzzing, basically a Haskell clone of John Hughes' quviq.
22:20:15 <shapr> Try to steal some of the microsoft whitebox testing ideas you pointed me at years ago.
22:20:20 <Gracenotes> edwardk: grueling, eh
22:20:52 <shapr> You think anyone would mind a former mentor becoming a student?
22:20:53 <edwardk> yeah, as in i think we can afford to feed them gruel this year ;)
22:21:04 <edwardk> shapr: i think we had at least one go that way before.
22:21:19 * Mathnerd314 reads up on http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler
22:21:32 <edwardk> i found one in the list when i was going through summarizing our past successes and singing our praises in the application to google
22:21:47 <shapr> Ok then!
22:23:00 <edwardk> welcome aboard. now write a kickass project proposal we can't deny ;)
22:23:41 <superoptimizer> So no Mac OS Haskell hackers?
22:23:57 <geheimdienst> anyway, how much of a haskell buff do you need to be? do you need to be basically spj, or does soc have some room for learning things as you go?
22:23:57 <shapr> umm
22:23:58 <edwardk> there are some floating around here. there are even iphone haskell hackers
22:24:18 <shapr> geheimdienst: SoC is for motivated college students.
22:24:45 <edwardk> geheimdienst: there is room for learning, the key is figuring out something that is of reasonable scope for the summer that derives some benefit to the community, either to the existing community or by extending visibility into other areas where haskell hasn't typically been visible
22:25:19 <liyang> superoptimizer: I'm postponing the upgrade until they fix all the linker issues. :3
22:26:01 <geheimdienst> edwardk, yes, i saw the proposals list on that subreddit
22:26:04 <edwardk> geheimdienst: if you're just getting up to speed i'd recommend steering clear of GHC itself, it is a rats nest, but there is plenty of stuff to do around the fringes in the libraries, etc.
22:26:13 <superoptimizer> liyang: linker errors?
22:26:31 <superoptimizer> liyang: It doesn't appear to support 64-bit code generation, which is the issue I'm running into.
22:26:38 <geheimdienst> there were a few things looking nice, like a new Date library (#2 on the reddit or something)
22:26:59 <geheimdienst> ok, that's good to know. the stack traces thing is out of the question for me, then :)
22:27:17 <Gracenotes> edwardk: I've had it in my head (no pun intended) for a while to do GHC things this summer
22:27:19 <superoptimizer> liyang: I'm not much of a Mac hacker overall, so I don't know whether there is any support for taking what is effectively a 32-bit program and assembling/linking it and running it.
22:27:40 <edwardk> Gracenotes: what are you thinking about?
22:28:11 <liyang> superoptimizer: rather, I meant all the 32-/64-bit faff. D:
22:28:35 <edwardk> Gracenotes: personally i really like marlow's immix collector idea, but then for some reason i find GC fun.
22:28:45 <Gracenotes> yeah, I looked at that paper
22:29:02 <Gracenotes> but overall I'm not certain. I like browsing the source, and it fits together like so many puzzle pieces ;)
22:29:08 <edwardk> yeah
22:31:07 <Gracenotes> lacking a sort of /frequent/ running-in with GHC internals in my actual code, my meter of what would be useful might be sort of broken
22:32:13 <edwardk> other stuff that might be nice to hack on dons had started an unboxed containers library a while back, i started something similar, it would be nice to get something like that up to snuff for production use
22:32:58 <edwardk> http://hackage.haskell.org/package/adaptive-containers
22:33:34 <edwardk> adding Set, Map, and some other containers to that using the viewpattern machinery would rock and would go a long way towards improving benchmark performace
22:34:16 <edwardk> i tackled an unboxed set and someone else banged out an unboxed map using tricks to fuse clusters of nodes
22:34:33 <edwardk> so there is code around to base the implementation on
22:35:38 <Gracenotes> your set impl uses the same tree logic as Data.Set?
22:35:44 <edwardk> yeah
22:36:02 <edwardk> just with unboxed contents exposed using a small class that provides view patterns
22:36:26 <edwardk> http://hackage.haskell.org/package/unboxed-containers had a quick stab at the set reasoning iirc
22:36:39 <edwardk> i didn't do much of a job of packaging it
22:38:20 * Gracenotes reading, hm
22:39:43 <edwardk> i had a script that would generate more instances, but then i got distracted trying to solve the general problem of how to pack data into a bounded number of fields
22:40:05 <edwardk> and i just confess i lost interest before i resolved it ;)
22:40:10 <edwardk> er must confess
22:41:23 <geheimdienst> ok, time for a nap
22:41:36 <geheimdienst> so long guys, and thanks for all the help :) much appreciated, as always
22:41:44 <edwardk> Gracenotes: i think the trickiest code in there is the stuff for balance in the view class
22:41:49 <edwardk> night geheimdienst =)
22:42:22 <geheimdienst> night edwardk
22:42:31 <edwardk> i had to inline half a dozen definitions by hand to get something that didn't suck with view patterns
22:43:45 * Alpounet is off too
22:43:48 <Alpounet> night
22:45:02 <edwardk> perhaps a better model would have been to require the user to define a local type that just happens to consume whatever argument types they wanted, rather than bake a million instances into the module
22:46:25 <edwardk> $(deriveUSet "Foo" (Char,Char,Int)) -- foo :: USet Foo; foo = singleton ('a','b',123)
22:49:37 <edwardk> hrmm, stream fusion on lists works so well because the derivative of the list functor is something * the list functor, and the stream just takes one half of that derivative and passes it along.
22:58:04 <dons> hmm
23:00:51 <glguy_> mmh
23:01:56 <edwardk> the problem with fusing over an arbitrary functor is you don't have a fixed traversal. so very little fuses away the best i can do there is appeal to traversable.
23:03:32 <edwardk> and use it over a data Partial a = Return a | Partial (Partial a) monad, which approximates the modification of data Stream f a = forall s. Stream (s -> f s) s    -- to data Stream f a = forall s. Stream (s -> Partial (f s)) s by providing the step placeholder
23:05:07 <edwardk> another option might be to provide zipper operations and make that use of the derivative more explicit
23:06:11 * hackagebot libmpd 0.4.1 - An MPD client library.  http://hackage.haskell.org/package/libmpd-0.4.1 (JoachimFasting)
23:22:28 <lpsmith> Is there a way to d/l past versions of the Haskell Platform?
23:32:35 <FliPPeh_> Okay, I have a "Just ["blah", "blah", "more blah"]"
23:32:50 <FliPPeh_> How could I map "print" or "putStrLn" over it, printing each string on a line?
23:34:12 <c_wraith> Well, you need to deal with the Just first
23:34:21 <FliPPeh_> fmap?
23:34:24 <c_wraith> but look into functions like mapM_
23:34:29 <c_wraith> :t mapM_
23:34:30 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
23:34:42 <alexsuraci> fmap (mapM_ putStrLn)
23:34:44 <alexsuraci> er
23:34:58 <c_wraith> that leaves you with Maybe (IO ())
23:35:01 <alexsuraci> (this is not ghci, and I am tired.)
23:35:18 <c_wraith> Maybe (IO ()) is not the most useful type, probably :)
23:35:28 <alexsuraci> right, didn't mean for that to go here :P
23:35:39 <FliPPeh_> I like Maybe (IO ())
23:35:56 <c_wraith> :t fmap (mapM_ putStrLn)
23:35:57 <lambdabot> forall (f :: * -> *). (Functor f) => f [String] -> f (IO ())
23:36:02 <FliPPeh_> While it has only 2 states, it can do so much
23:36:05 <FliPPeh_> :)
23:36:51 <byorgey> :t fromMaybe (return ()) . fmap (mapM_ putStrLn)
23:36:52 <lambdabot> Maybe [String] -> IO ()
23:37:03 <alexsuraci> :t maybe (return ()) (mapM_ putStrLn)
23:37:04 <lambdabot> Maybe [String] -> IO ()
23:37:21 <byorgey> ah, much better =)
23:37:44 <FliPPeh_> That did it :)
23:44:55 <glguy__> This could be a fun combinator for network programming in ChoiceT IO, acceptAll sockfd = accept sockfd `mplus` acceptAll sockfd
23:46:39 <glguy__> well... inBase (accept sockfd) `mplus` acceptAll sockfd
23:48:04 <lpsmith> So,  no ideas on how to obtain past versions of the Haskell Platform?
23:48:30 <FliPPeh_> lpsmith: I'd be more than happy if I would at least be able to get the CURRENT version.
23:48:47 <FliPPeh_> Somehow it always fails on me.
23:51:20 <glguy__> lpsmith: what version are you looking for?
23:52:22 <glguy__> lpsmith: http://hackage.haskell.org/platform/<theversionyouwanted>
