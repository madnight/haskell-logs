00:04:42 <aavogt> @type interact -- iaefai?
00:04:43 <lambdabot> (String -> String) -> IO ()
00:05:28 <iaefai> aavogt: I cannot answer that question. I am looking into it as an option for the Hammurabi project listed above. I know not of it yet.
00:05:46 <ManateeLazyCat> Just Word64 can binding guint64 ?
00:06:07 <iaefai> I can probably implement what I want with monads, in fact I would probably do it first. Then be enlightened to better ways.
00:08:12 <aavogt> iaefai: well interact is sort of FRP for text input-output. I think a game probably needs to be more fancy than that though
00:08:48 <iaefai> aavogt: I believe this game would call for a REPL style input. I am not trying to be fancy at all.
00:08:53 <aavogt> in that buffering affects when things get printed: some might happen to soon or too late if you use interact
00:09:41 <iaefai> Does this interact exist in a hackage package?
00:09:47 <aavogt> it's in the prelude
00:11:04 <iaefai> ok
00:12:04 <iaefai> I see that it might not be enough
00:12:09 <aavogt> basically you get all keyboard input in a lazy list, and whatever the result is printed to the screen
00:12:33 <aavogt> it doesn't account for multiple inputs
00:12:41 <aavogt> @hoogle interact
00:12:41 <lambdabot> Prelude interact :: (String -> String) -> IO ()
00:12:42 <lambdabot> Data.ByteString interact :: (ByteString -> ByteString) -> IO ()
00:12:42 <lambdabot> System.IO interact :: (String -> String) -> IO ()
00:14:02 <iaefai> Yeah, i need to handle a sort of state too. I found a page that I am reading about reactive. It might assist me.
00:16:23 <aavogt> well the state is determined from the previous input
00:16:51 <aavogt> say input comes as lines:
00:19:45 <aavogt>   data State = State { x,y,z :: Int }; main = interact (map fst . tail . scanl f ("",State 0 0 0) . lines);  f :: State -> String -> (String,State)
00:20:27 <aavogt> actually f is not curried:    f :: (String,State) -> (String,State)
00:21:01 <aavogt> hmm, another mistake is that there should be a concatMap there...
00:21:20 <iaefai> I think it is too late for me to comprehend that line you pasted there
00:21:29 <aavogt> iaefai: perhaps you get the idea for carrying 'state' along with a function?
00:21:29 <iaefai> I have also never used State or seen scanl
00:21:43 <aavogt> State is just a data type defined here
00:21:47 <aavogt> no monads
00:21:52 <iaefai> ok
00:21:54 <aavogt> it could be a tuple or whatever
00:22:08 <iaefai> Are you referring to a partially applied function carrying the state?
00:22:13 <aavogt> > scanl (+) 0 [1..10]
00:22:14 <lambdabot>   [0,1,3,6,10,15,21,28,36,45,55]
00:22:58 <aavogt> > scanl (\(b,n) m -> (not b,n+m)) (True,0) [1..10]
00:22:58 <lambdabot>   [(True,0),(False,1),(True,3),(False,6),(True,10),(False,15),(True,21),(Fals...
00:23:30 <iaefai> you went right over my scalp
00:23:53 <iaefai> I am not seeing what it does even with the first basic one
00:23:56 <aavogt> well it's pretty late here too ;)
00:23:58 <iaefai> @src scanl
00:23:58 <lambdabot> scanl f q ls = q : case ls of
00:23:58 <lambdabot>     []   -> []
00:23:58 <lambdabot>     x:xs -> scanl f (f q x) xs
00:24:08 <aavogt> iaefai: do you know foldl?
00:24:15 <iaefai> aavogt: not too well
00:24:44 <iaefai> I think it is best if I came at this tomorrow :p
00:24:46 <aavogt> well scanl is exactly the same except you get a list of the intermediate accumulating parameters, rather than just the last one
00:24:48 <araujo> hello
00:25:01 <iaefai> I appreciate the help though.
00:25:03 <araujo> anyone knows tool to find duplicated code between two files?
00:25:36 <Zao> araujo: diff, see where they do not differ?
00:25:52 <aavogt> araujo: http://www.few.vu.nl/~dick/sim.html
00:26:20 <araujo> Zao, it is usually more complex than that sometimes
00:26:22 <aavogt> unfortunately it doesn't properly do haskell
00:26:30 <araujo> aavogt, thanks, i check
00:27:11 <aavogt> but there's a mode to lex the code as miranda, which is quite similar
00:34:03 <Taejo> If I have "flat" type, is rnf x = x `seq` () the correct definition?
00:35:38 <c_wraith> yes
00:35:46 <c_wraith> just be sure it's flat
00:49:39 <Taejo> can I make GHC 6.10 statically link in libffi and libgmp?
00:59:52 <voker57> try -optl static
00:59:53 <dons> Taejo: yeah
01:02:08 <Taejo> voker57: it seems to -optL : -optl gives me gcc: static: No such file or directory
01:02:28 <Taejo> or maybe not, since -optL still has those dependencies
01:02:53 <voker57> no, it's -optl
01:03:05 <voker57> but it's -optl -static
01:03:10 <Taejo> ah, thanks
01:03:19 <Taejo> that works
01:14:34 <Taejo> in GHC's profile output, do functions appear under the lexically calling function or the function that causes it to be evaluated?
01:22:53 * Taejo is disappoint: "embarrassingly parallel" program slows down on multiple cores
01:26:51 <Niccus> maybe it's scoffing at the low number of cores you're dedicating to it
01:27:08 <Niccus> give it infinite cores or something
01:28:45 <Taejo> Niccus: well it does worse with -N7 than -N2 (on an eight-core machine)
01:29:10 <Taejo> four dual-core CPUs, I believe
01:32:38 <zeiris> The first time I parallelized an embarassingly parallel program in C, it also slowed down. A year later I found out about false sharing, and was embarassed... There's a lot of subtle pitfalls.
01:33:02 <Taejo> zeiris: what is false sharing?
01:33:31 <Raynes> It's when you fake sharing stuff.
01:33:32 <Raynes> ;)
01:33:34 <Zao> Taejo: When two pieces of storage map to the same cache line, forcing cache invalidation.
01:34:06 <Zao> http://en.wikipedia.org/wiki/False_sharing
01:34:13 <Zao> The example there is rather decent.
01:47:18 <o-_-o> @seen conal
01:47:18 <lambdabot> Unknown command, try @list
01:47:23 <o-_-o> @list
01:47:23 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
01:48:01 <o-_-o>  preflex: seen conal
01:48:07 <o-_-o> preflex: seen conal
01:48:07 <preflex>  conal was last seen on #haskell-blah 14 hours, 1 minute and 41 seconds ago, saying: aavogt: right?
02:13:37 <o-_-o> @hoogle ($=)
02:13:37 <lambdabot> No results found
02:13:42 <o-_-o> @hayoo ($=)
02:13:42 <lambdabot> Unknown command, try @list
02:13:55 <o-_-o> @hoogle ($)
02:13:55 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
02:13:56 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
02:13:56 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
02:14:01 <o-_-o> @hayoo ($)
02:14:01 <lambdabot> Unknown command, try @list
02:14:09 <o-_-o> :type ($=)
02:14:18 <o-_-o> :t ($=)
02:14:19 <lambdabot> Not in scope: `$='
02:14:23 <o-_-o> > :t ($=)
02:14:24 <lambdabot>   <no location info>: parse error on input `:'
02:15:55 <kmc> o-_-o, http://hackage.haskell.org/packages/archive/StateVar/1.0.0.0/doc/html/Data-StateVar.html
02:16:51 <kmc> o-_-o, the idea is just to use a single typeclass-overloaded operator ($=) to represent several types of mutable state in the IO monad
02:16:53 <o-_-o> kmc, thanks these magic incantations which cannot be googled are driving me nuts
02:17:12 <kmc> o-_-o, it's not a magic incantation.  it's an ordinary user-defined operator which is in this module
02:17:19 <mlesniak> How can I print a Double in non-scientific notation?
02:17:35 <kmc> o-_-o, lambdabot doesn't have Hayoo but the Hayoo website finds it
02:17:52 <mlesniak> (I remember a thread on haskell-cafe, but can't find it)
02:20:00 <quicksil1er> mlesniak: showFFloat IIRC
02:20:14 <mlesniak> quicksil1er, ah, thanks
02:20:22 <quicksil1er> :t showFFloat
02:20:23 <lambdabot> forall a. (RealFloat a) => Maybe Int -> a -> String -> String
02:20:37 <quicksil1er> > showFFloat (Just 4) 3.1415926 ""
02:20:38 <lambdabot>   "3.1416"
02:20:41 <quicksil1er> something like that
02:20:50 <quicksil1er> you need to import Numeric
02:20:56 <quicksil1er> (ARGH! Non-hierarchical module!)
02:22:08 <kmc> o-_-o, anyway, the idea is to have a uniform way to set IORefs, OpenGL state, and whatever other sort of mutable state you can represent in the IO monad
02:22:43 <quicksil1er> and it's a very annoying google bug that it doesn't let you google punctuation
02:22:46 <jre2> anyone know how to force Network.listenOn to bind to ipv4?
02:22:51 <quicksil1er> except for the sacred C# which they special-cased.
02:23:23 <Heffalump> anyone know how to install gitit? cabal install gitit runs into a QuickCheck version conflict :-(
02:23:55 <DigitalKiwi> gi tit!
02:24:13 <DigitalKiwi> winner of todays most unfortunate name award
02:24:41 <Heffalump> ahah, --constraint 'datetime<0.2'
02:27:47 <mietek> http://lukepalmer.wordpress.com/2010/03/19/haskells-big-three/
02:27:51 <mietek> I think this is spot-on.
02:29:26 <ben> I do not understand the first complaint
02:29:31 <ben> Maybe I should check out ML, Agda or Coq
02:30:21 <mietek> ben: a functor in ML is a group of functions, parametrized by a type as a whole
02:30:32 <ben> So the idea here is to give a type when importing the module?
02:30:55 <jre2> anyone know how to deal with Network.listenOn choosing ipv6 instead of ipv4?
02:31:12 <ben> jre2: is it a problem?
02:31:17 <psykotic> mietek: not just functions. also abstract types.
02:31:21 <mietek> psykotic: true.
02:31:48 <psykotic> that's actually what gives them their power.
02:32:20 <jre2> ben: my program works differently on different platforms, so yea
02:35:24 <kmc> yes if we had dependent types, we wouldn't need yet another abstraction for modules
02:35:32 <kmc> but separately, Haskell's records suck
02:35:52 <kmc> which would be worse when using them as modules
02:35:54 <kmc> and i'm surprised that doesn't rate that list, as it's a common complaint
02:36:30 <kmc> i'll also throw in "classes and instances aren't scoped and managed the same way as other stuff"
02:37:05 <kmc> since a class can be read as a declaration of a dictionary type, and an instance as a definition of a value of that type
02:38:05 <dobblego> what are the alternative proposals to record syntax?
02:38:34 <mux> I wish we could have typeclass constraints on datatype definitions, and it seems to me it would solve at least that problem of typeclasses adding up in type signatures
02:39:10 <quicksil1er> mux: in GADT syntax you can put constraints on constructors in a way which actually works
02:39:11 <mux> like "data Ord a => Foo a = Foo ..." and then we can use Foo a without mentioning the Ord a constraint
02:39:21 <quicksil1er> mux: (i.e. you get the context back when you pattern match)
02:39:50 <quicksil1er> kmc: haskell records don't suck, they just aren't records ;)
02:40:11 <quicksil1er> haskell records are just a slightly idiosyncratic piece of syntactic sugar over sum types.
02:40:30 <quicksil1er> the mistake was probably every using the word 'record' for them.
02:41:04 <quicksil1er> dobblego: I'm not aware of any obviously good haskell record system proposals.
02:41:19 <quicksil1er> dobblego: lots of people seem to think the idea has merit but few seem to be able to describe what htye want, exactly.
02:41:43 <dobblego> then that's a shame
02:42:15 <kmc> er, the product part is more important than the sum part for records, isn't it?
02:42:27 <kmc> what would make them actual records? subtyping? overloadable label names?
02:42:41 <mux> subtyping would sure go a long way
02:42:51 <kmc> but Haskell has no subtyping at all
02:42:55 <kmc> adding some would be a big deal
02:42:59 <mux> yes
02:43:10 <kmc> and subtyping is complex enough that i like having a counterexample to the idea that a real language with rich types must have it
02:43:19 <kmc> i like that records do not add new typing or semantics
02:43:28 <kmc> it makes it easy to ignore them if you think they suck
02:43:55 <quicksil1er> kmc: yes, the product type is more important, sorry, thinko there.
02:44:12 <kmc> GHC has some syntactic extensions that make them less painful, as do the various first-class labels packages
02:44:15 <quicksil1er> most people seem to think 'real' records would have some kind of first class labels.
02:44:22 <kmc> it's just not nicely tied together because it's post-hoc
02:44:36 <quicksil1er> I'm not sure I know, personally, but I'm not personally convinced there is anything wrong.
02:44:47 <kmc> you need some nonstandard extension and some Template Haskell just to work with records cleanly
02:45:47 <quicksil1er> A good lens system just requires one line of boilerplate per field.
02:45:54 <quicksil1er> That's a mild annoyance but hardly a big deal.
02:46:43 <StarFire> Is there a good lens tutorial or paper somewhere?
02:47:19 <kmc> StarFire, I think the writeup here is pretty good: http://hackage.haskell.org/package/fclabels
02:47:28 <StarFire> Thanks, I'll check it out.
02:47:29 <kmc> there's a few packages (fclabels, data-accessor, lenses) but they work about the same way
02:47:45 <kmc> also conal's semantic editor combinators
02:53:10 <quicksilver> kmc: hm, yes, the fclabels write-up is quite nice.
02:53:22 <quicksilver> kmc: I might even switch from my own half-arsed lenses to fclabels.
04:04:42 * hackagebot logfloat 0.12.1 - Log-domain floating point numbers  http://hackage.haskell.org/package/logfloat-0.12.1 (WrenThornton)
04:21:16 <zeiris> Suppose I found a bug in a library on hackage (vect-0.4.5). How would I go about reporting or fixing it?
04:21:58 <merijn> Debug it, create patch, find out who wrote the library, mail them the patch, pray they don't take 15 hundred weeks before responding
04:22:24 <zeiris> What form should the patch take? The output of 'diff' on the new file?
04:22:44 <Saizan> if you can find the repository use that
04:22:47 <merijn> Usually patches are unified diffs (diff -u)
04:24:17 <Zao> merijn: Of course, just mentioning it might be sufficient.
04:25:41 <Saizan> zeiris: http://code.haskell.org/~bkomuves/projects/vect/ <- this should be the official darcs repo for vect
04:25:49 <merijn> Zao: True, but sending patches is always appreciated and helps response times :p (also he did ask how to fix things)
04:31:51 <zeiris> Thanks.
04:38:41 <merijn> Anyone willing to brainstorm some data structures? I want to model a 2D map consisting of cells (something like http://dpaste.com/173268/ each hash representing a cell). The only thing I can come up with is a (sparse) matrix (either a graph represented by a sparse matrix or just a matrix to encode the various fields directly).
04:40:20 <fasta> merijn, it depends on exactly what you want.
04:40:39 <merijn> Bonus of the graph matrix idea is that implementing pathfinding is trivial (just a sequence of matrix multiplications), downside is that I think it'll be hard to search for the location of things
04:40:44 <fasta> merijn, there are way to just use a 2d array, if you have the memory but not the time.
04:41:10 <fasta> merijn, ways*
04:41:26 <merijn> fasta: I'm not sure yet what I want, but if I don't know any alternatives I can't decide :p Which is why I'm open to suggestions
04:41:48 <fasta> merijn, write a formal problem definition first.
04:42:15 <fasta> merijn, before you design a data structure solving the wrong problem.
04:42:34 <fasta> For a lot of problems it is hard to predict which data structure you actually need, though, in advance.
04:43:20 <merijn> fasta: I know, but the problem is that there is no concrete problem I'm solving.
04:43:47 <fasta> merijn, you are inventing problems?
04:44:04 <fasta> merijn, I think the world has enough problems already ;)
04:44:48 <merijn> fasta: Seeing as how my main problem is defined as "implementing a game to do something non-trivial with haskell" inventing problems is a pretty accurate description (isn't that what games are?)
04:45:55 <fasta> merijn, designing a game is different from solving the required CS to make it work fast.
04:46:23 <merijn> fasta: The problem is I can work out all sorts of ideas and then try to figure out a spatial data structure for that (which is probably a bad idea as the things I can invent are likely to be more complicated then I can successfully program) or trying to get a feel for possible data structures and structure game mechanics around that
04:47:03 <merijn> fasta: Agreed, but I feel more confident in my ability to structure my game ideas around available spatial data structures then in my ability to invent a spatial data structure for my game ideas
04:47:21 <fasta> I never heard of data structure inspired game design, but you could always try of course ;)
04:47:55 <fasta> If you have no ideas for a game, you can also just clone something, but write a better implementation.
04:48:15 <fasta> For commercial purposes you might not want to do that, though.
04:48:23 <merijn> fasta: You're a programmer or you're not. Some people design on story or feeling, I design based on interactions :)
04:48:30 <dons> dcoutts: join #zurihac
04:49:23 <merijn> Oh, I have some ideas (more ideas in fact then I can realistically implement) limiting myself to data structures I can implement just forces me to narrow it down to the ones I have a realistic chance of implemtning
04:49:56 <fasta> merijn, also data structures are only important when n is big.
04:50:12 <Jafet> How untrue
04:50:19 <fasta> merijn, since humans are rather limited, n might be small.
04:50:44 <fasta> Jafet, no, it isn't.
04:50:49 <theorbtwo> O(n) is only important when n is big.  There's a lot more to data structures then O(n).
04:51:03 <merijn> I guess I should just cave and buy a book on spatial modeling/data structures or something. None of my current books cover any of that other then a trivial coordinate system
04:51:20 <Jafet> In O(n), n is a bound variable...
04:51:32 <fasta> merijn, computational geometry only exists for about 25 years.
04:51:43 <fasta> merijn, there isn't that much interesting to read from books.
04:51:51 <theorbtwo> You say that like 25 years is a short time in computing.
04:52:04 <fasta> merijn, it does give a basis to read papers, though.
04:52:12 <merijn> 25 years is like the jurassic era
04:52:12 <theorbtwo> merijn: If you only take on projects that are within your boundries, your boundries won't get wider.
04:52:14 <fasta> Or base?
04:52:25 <fasta> theorbtwo, it is.
04:52:52 <merijn> theorbtwo: Well considering I have A) never programmed non-trivial haskell and B) never done any spatial data structures I'd say expanding two boundaries at once is plenty to start with :p
04:52:52 <fasta> theorbtwo, to get from a theoretical algorithm to a practical algorithm takes decades.
04:52:55 <Jafet> Computational geometry papers tend to assume background knowledge in computational geometry...
04:53:18 <fasta> theorbtwo, presentations change, bugs get removed and so on.
04:53:20 <theorbtwo> merijn: Fair enough.
04:53:33 <merijn> Jafet: I think we can generalize that to "X papers tend to assume background knowledge in X". :)
04:53:38 <fasta> It is the same as in mathematics where proofs get more elegant over time.
04:54:09 <Jafet> merijn, not in haskell!
04:54:35 <Jafet> Has haskell existed for 25 years?
04:55:25 <theorbtwo> No.  Therefore, there must be no interesting books on it.
04:55:26 <fasta> Jafet, about 20.
04:55:35 <Jafet> I concur
04:55:35 <merijn> Jafet: Well, nearly. As far as I know the work on it started in 1990
04:55:40 <fasta> Haskell doesn't even have a formal semantics.
04:55:42 <bremner_> Jafet: what computational geometry papers are you reading, out of curiousity.
04:56:15 <Jafet> Recently some of Stam's work, who is actually one of the more readable authors
04:56:51 <bremner_> huh, I must really be drifting away from the field, don't know him/her
04:56:58 * hackagebot scan 0.1.0.1 - lexical style suggestions for source code  http://hackage.haskell.org/package/scan-0.1.0.1 (ChristianMaeder)
04:56:59 <Jafet> Also many authors in the field like to embed C code for some reason
04:57:15 <theorbtwo> How horrible.
04:57:22 <merijn> The field attracts masochists?
04:57:38 <theorbtwo> Seriously, sounds lots better then most papers, which don't attempt to say anything pratical at all.
04:58:17 <theorbtwo> Hm, that may have come out overly antiacedemic.
04:58:19 <Jafet> The utility decreases when they start using code as a stand-in for explanation
04:58:33 <Jafet> And sometimes not even providing self-contained code
04:58:35 <theorbtwo> True... sometimess.
04:58:39 <lhames> ?instances Monad
04:58:40 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
04:59:14 <Jafet> Does parsec handle left-recursive grammars?
05:00:15 <aleator_> Can I make cabal-install print out license for package in hackage?
05:00:35 <lhames> Hmm. Where is Either defined as an instance of Monad? I'm trying to use sequence on a list of Either String String's, but I get "No instance for (Monad (Either String))" (This is with GHC 6.10.4)
05:00:50 <dobblego> lhames, Control.Monad.Instances
05:02:00 <Lemmih> aleator_: 'cabal list' can give you some information about the license.
05:04:39 <aleator_> Lemmih: Thanks!
05:05:22 <lhames> dobblego: Thank you very much.
05:06:36 <lhames> dobblego: After importing Control.Monad.Instances the following, sequence ([Right "hi"]::[Either String String]), still yields the same error though: No instance for (Monad (Either String))
05:06:46 <lhames> dobblego: Am I missing something obvious?
05:14:37 <SamB_XP> lhames: tried Control.Monad.Error?
05:14:59 <SamB_XP> I don't know why it wouldn't be in C.M.I, but ...
05:15:56 <fasta> If I had a computational geometry journal, I would not publish 99% probably for lack of utility.
05:16:16 <SamB_XP> fasta: 99% of what ?
05:17:04 <lhames> SamB_XP: Looks like C.M.I declares it an instance of Functor, but not Monad.
05:17:23 <SamB_XP> oh, I remember now
05:17:30 <lhames> It's a good excuse for me to look at Control.Monad.Error anyway- that's what I want to use this for eventually.
05:17:33 <SamB_XP> there's another class that the instance uses
05:17:33 <lhames> ?
05:17:47 <SamB_XP> and *it* is defined in C.M.Error
05:18:12 <SamB_XP> @instances Monad
05:18:13 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
05:18:33 <SamB_XP> > return () :: Either a ()
05:18:35 <lambdabot>   Could not deduce (Control.Monad.Error.Class.Error a)
05:18:35 <lambdabot>    from the context ()...
05:18:52 <SamB_XP> oh, it's in C.M.Error.Class now ?
05:19:12 <SamB_XP> okay, now I dunno why importing C.M.I doesn't do it for you ...
05:19:30 <lhames> That's ok - thanks heaps for your help.
05:19:31 <SamB_XP> ... could be a bug, or an infelicity in Haskell ...
05:20:06 <lhames> At the very least a challenge for tomorrow morning - I've got to get some sleep.
05:20:10 <lhames> Thanks again. :)
05:20:13 <lhames> 'Night all.
05:21:39 <SamB_XP> wait, what ?
05:21:48 <SamB_XP> I only got up a little under an hour ago!
05:23:48 <medfly> SamB_XP, different timezone maybe?
05:24:03 <SamB_XP> medfly: hmm, I *suppose* those *might* exist
05:24:18 <waern> has anyone got any experience with immutable object models in c++?
05:24:25 <SamB_XP> it *would* explain why I always used to have such difficulty getting a chance to talk to dons ...
05:24:35 <SamB_XP> waern: the what now?
05:24:53 <SamB_XP> is this about "const correctness"?
05:24:57 <waern> SamB_XP: I'm asking since I know there are lots of Haskellers doing c++ for a living
05:25:07 <SamB_XP> poor us :-(
05:25:26 <medfly> C++ is what you learn to maek money? not C#?
05:25:28 <waern> SamB_XP: well, I want to know how feasible it is to work with immutable objects only in c++
05:25:42 <SamB_XP> medfly: I guess C# is just too easy
05:26:08 <SamB_XP> well, I dunno how much it buys you over doing it in C ;-)
05:26:21 <bremner_> templates
05:26:24 <SamB_XP> true
05:26:57 <SamB_XP> it can certainly be done, though I think the only program I've seen that basically did it (in C) was actually translated from Java
05:27:23 <baaba> waern: depends on what you mean by feasible
05:27:43 <waern> yeah, but I'd like to hear from someone who has done it on a real program does serialization
05:27:46 <SamB_XP> what are you considering it for ?
05:27:52 <bremner_> also, C++ is not completely useless at optimizing away object copying
05:27:56 <medfly> I just need to learn some language because I will try to get a job soon
05:27:57 <baaba> the language isn't going to stop you, and in fact can help you a fair bit with const
05:28:26 <waern> SamB_XP: we re-designing things at work. The current stuff is quite horrible. Objects are kind of semi-mutable in a strange way
05:28:30 <SamB_XP> baaba: except const doesn't do what you think in C++, afaict
05:28:33 <baaba> but libraries for that kind of programming are sparse
05:28:42 <baaba> SamB_XP: it does exactly what i think it does
05:28:46 <baaba> because i know c++ well :P
05:28:54 <waern> baaba: right. I don't know if there is a serialization library that handles immutable objects
05:29:05 <baaba> er, s/sparse/scarce/
05:29:13 <SamB_XP> baaba: well, it doesn't do what it sounds like you were implying, afaik
05:29:26 <dobblego> "kind of semi-mutable in a strange way" is the best you'll achieve in C++; I've watched many people go down this road
05:29:37 <baaba> SamB_XP: what did i imply?
05:29:42 <waern> of course, let me add as a disclaimer that having an object model in c++ and writing business logic on it is insane in the first place. But that's out of the discussion :-)
05:29:51 <baaba> i said const can help a fair bit
05:29:52 <SamB_XP> baaba: that const stops things from being mutated
05:30:04 <merijn> Some people at university are working on immutable C (not sure if they're doing C++ too)
05:30:06 <baaba> and by help i don't mean protect against malicious idiots
05:30:14 <baaba> i mean protect against mistakes
05:30:15 <SamB_XP> baaba: maybe it's not actual bussiness logic
05:30:34 <baaba> if the programmer's intent is to utilize const-correctness, then it can and will help a lot
05:30:37 <araujo> merijn, link?
05:31:08 <SamB_XP> true, true
05:31:09 <baaba> if the programmer's intent is to fool-proof code so that some other idiot doesn't work around it, then you're fucked as long as you're using c++
05:31:10 <SamB_XP> it's just crazy!
05:31:35 <waern> dobblego: are you saying it's not worth going further down that road?
05:31:36 <merijn> araujo: Single Assignment C (http://www.sac-home.org/) it is a functional variant of C intended to allow more crazy functional optimizations for numeric C code.
05:31:51 <dobblego> waern, no, I encourage it
05:31:57 <baaba> much like you could do something like int* my_int = *(int*)(0x01010101); *my_int = 5;
05:32:08 <araujo> thanks merijn , checking now
05:32:09 <baaba> you can also bypass const
05:32:16 <baaba> but that doesn't make it sane in any sense of the word
05:32:35 <waern> dobblego: right. What I'm interested in is potential c++-specific problems with this approach
05:32:38 <merijn> baaba: You're fucked as long as your code will run on any system you don't control
05:32:45 <baaba> yeah true
05:32:51 <merijn> baaba: If idiots want to do stupid stuff with your code they will
05:32:53 <zeiris> Does darcs get used much in non-Haskell languages?
05:33:08 <baaba> but mostly i'm talking about constraints for programmers in the same project
05:33:27 <merijn> zeiris: I don't even use it with haskell (an judging from a source control discussion here earlier this week neither do a lot of other haskell programmers)
05:33:34 <dobblego> waern, I've not done it to the extent that I have seen others do it, but I've helped people with specific problems in their attempt
05:33:42 <zeiris> What are its limitations?
05:33:54 <waern> dobblego: ok
05:34:20 <Cale> I like darcs, it's good.
05:34:30 <merijn> zeiris: No clue, it's just that when I was looking for a source control solution I went with the one that was easiest to use. Mercurial seemed to fit the bill. It's quite fast and very easy to use.
05:34:43 <merijn> Maybe darcs is just as easy, but I'm to lazy to switch now :p
05:34:53 <baaba> you can get fairly far by banning the keyword 'mutable' in your codebase and making every object const
05:35:04 <merijn> Also, the Mercurial has the benefit of being more common and being supported on Google code
05:35:59 <waern> dobblego: what kind of problems did they have?
05:36:33 <dobblego> waern, I can't remember right now because I am high, but ElfArmy who visits this channel, is one such person
05:36:43 <waern> dobblego: ok :-)
05:39:28 <merijn> zeiris: On the other hand, regardless of what version control people tell you to use, they'll agree with me that as long as you use *any* version control you're already ahead on the programmer competence curve. It's largely a matter of taste anyway as I think mercurical, git, darcs and bazaar have relatively equal feature sets.
05:41:05 <baaba> ..but if you're on cvs then any advantage is negated by the lost productivity from how crappy it is :P
05:41:33 * theorbtwo thinks cvs is probably still better then nothing.
05:41:39 <dobblego> there is much worse than CVS, which you'd know if you've worked for IBM
05:41:43 <theorbtwo> ...and svn is a little better then cvs.
05:42:12 <merijn> baaba: True, but CVS is still better then nothing. Although I think people new to source control will opt for one of the newer source control solutions just due to ease of use
05:42:12 * hackagebot hawitter 0.3 - A twitter client for GTK+. Beta version.  http://hackage.haskell.org/package/hawitter-0.3 (DaikiHanda)
05:42:39 <baaba> svn at least has atomic commits
05:43:18 <dobblego> heh it even has its own wikipedia page http://en.wikipedia.org/wiki/IBM_Configuration_Management_Version_Control_%28CMVC%29
05:44:44 <theorbtwo> My girlfriend, IIRC, used cmvc at one of her previous jobs.
05:45:10 <dobblego> I would commit a subversion repository; that was 6 or so years ago
05:49:57 <zeiris> What's the cabal-documentation syntax for linking a function with ' in the name?
05:50:03 <zeiris> 'project\''?
05:50:26 <micah> so all you parsec experts
05:50:47 <micah> hello
05:51:24 <zeiris> Parsec experts are like wild animals. They won't come close or speak to you, unless you drop a juicy question to bite into.
05:51:34 <micah> ok
05:51:56 <micah> is it better to structure a parser as a lexer and parser separately
05:52:03 <micah> or
05:52:03 <micah> not
05:52:39 <Saizan> that depends on how complex your grammar is, i guess
05:52:43 <jlouis> micah: it "Depends"
05:52:53 <micah> for algol-like languages
05:53:41 <merijn> Wouldn't it depend more on how complex your lexer is?
05:53:52 <micah> well
05:53:55 <micah> what I found is that
05:54:04 <merijn> Lexer is the smallest part of the lexer/parser combination
05:54:05 <Saizan> there's a module to create a set of parsers for the lexical part
05:54:19 <micah> after I made my lexer, the easiest way to make things using it would be marching off the screen with a bunch of cases
05:54:34 <Saizan> the .Token one
05:55:13 <Saizan> isn't the output of your lexer something like [Token] ?
05:55:27 <micah> no I made a parser called token
05:55:31 <micah> t <- token
05:55:45 <merijn> That sounds like bad naming
05:55:48 <micah> case t of { NumberTok n -> ...}
05:55:57 <micah> but is that a bad idea
05:56:02 <merijn> lexers create tokens, parsers consume tokens
05:56:21 <merijn> Naming your parser "token" sounds like a recipe for confusion...
05:56:21 <Saizan> merijn: you can implement your lexer as a parsec parser :)
05:56:23 <micah> ok I should name it getToken then :P
05:56:59 <Saizan> merijn: maybe "lexer = many token" then you can use "runParser parser (runParser lexer input)"
05:57:10 <merijn> Saizan: Of course, that doesn't make naming your parser "token" a better plan :)
05:57:21 <micah> oh can I make a parser that works on [Token] instead of [Char]?
05:57:29 <Saizan> yeah
05:57:32 <micah> cool
05:57:36 <merijn> micah: That's the usual way to do it
05:57:42 <micah> oh awesome :D
05:57:45 <micah> I did not know this
05:57:52 <Saizan> parsec is parametrized on the actual token type
05:58:12 <Saizan> and parsec-3 is parametrized on the container holding them too
05:58:23 <Saizan> i.e. you can use something else instead of []
05:58:59 <micah> awesome :D
05:59:12 <micah> parametrization wins
06:00:43 <benmachine> I wrote a parsec stream that was basically just a handle and a Posn
06:01:02 <benmachine> don't think it was any better than feeding the thing readFile though >_>
06:01:49 <Saizan> you also need to save the bytes read somewhere for backtracking
06:02:10 <benmachine> no you just seek
06:02:20 <benmachine> at large speed cost I am sure :P
06:02:50 <benmachine> efficiency wasn't really my concern, I just wanted to avoid lazy IO I think
06:02:58 <Saizan> ah, i see
06:03:16 <benmachine> http://unsafecoerce.com/fastcgi/hpaste.fcgi/view?id=8703#a8703
06:03:36 <Saizan> i was thinking of Sockets
06:03:49 <benmachine> oh, yes they are trickier
06:08:07 <micah> is Left/Right a monad?
06:08:36 <merijn> micah: You mean Either? I think there's an Either String monad defined somewhere
06:09:27 <micah> I wonder if it has the behavior I want--if there's an error stop and return the error; otherwise, return the last Right
06:09:33 <benmachine> Control.Monad.Error has (Error e) => Monad (Either e) and String is an instance of Error
06:09:52 <benmachine> I think there's only one instance of Monad for Either that works
06:10:12 <Saizan> micah: it does that
06:10:21 <micah> yay :D
06:10:26 <Saizan> well, not the last Right
06:10:30 <Saizan> what did you mean?
06:10:34 <benmachine> kind of the last Right
06:10:42 <benmachine> bind feeds a previous right into the function
06:10:49 <micah> yeah that's what I meant
06:10:49 <benmachine> or doesn't do anything if you had a left
06:11:17 <benmachine> err
06:11:25 <benmachine> I think you'd understand faster if you just tried it :P
06:11:58 <dobblego> instance (Semigroup e) => Applicative (Either e) -- is useful
06:12:13 <benmachine> is it?
06:12:27 <dobblego> I use it a lot
06:12:37 <dobblego> except with a newtype for Either
06:12:38 <benmachine> wait, which one is a semigroup
06:12:46 <dobblego> Monoid with the identity
06:12:53 <dobblego> *without
06:12:56 <benmachine> ah
06:13:02 <benmachine> just an associative binary operation?
06:13:05 <dobblego> yes
06:13:18 <benmachine> oh, Applicative
06:13:20 <benmachine> right yes
06:13:32 <benmachine> sorry I thought we were still on Monads
06:13:43 <benmachine> instance (Semigroup e) => Monad (Either e) doesn't work iirc
06:14:12 <benmachine> because you can't "run" things later in the chain to find all the Lefts
06:14:21 <dobblego> no it won't
06:14:21 <benmachine> which you can with Applicative
06:14:21 * hackagebot MonadCatchIO-transformers 0.1.0.0 - Monad-transformer compatible version of the Control.Exception module  http://hackage.haskell.org/package/MonadCatchIO-transformers-0.1.0.0 (AriePeterson)
06:14:55 <Saizan> well instance (Semigroup e) => Monad (Either e) would be the same as Monad (Either e) and ap and <*> won't match
06:16:26 <benmachine> yes
06:17:03 <benmachine> which I find interesting
06:17:46 <Nomad010> Taejo: i lurk in this channel lol
06:18:02 <benmachine> if you have a Monad you can implement applicative, but even on types which can be made into Monads sometimes you still can't implement *every* applicative that way
06:18:26 <dobblego> Semigroup allows you to use: data NEL a = N a [a] which is not a Monoid
06:18:29 <benmachine> *even on types which can be made into Monads, sometimes...
06:18:51 <dobblego> e.g. ZipList
06:19:11 <benmachine> mm
06:22:18 <Mathnerd314> ziplist *is* a monad, with the right type definition
06:23:59 <Mathnerd314> but not as-is
06:24:08 <dobblego> how do you mean?
06:24:10 <gwern> bleh. why are all the hackathons nowhere near me, and not somewhere doable like new york city?
06:24:49 <aledge> or cambridge, ma!?
06:25:34 <fasta> gwern, you can organize one.
06:25:40 <aledge> impossible
06:25:47 <fasta> gwern, that doesn't mean that anyone will come, however.
06:25:49 <gwern> fasta: you seem to mistake me for someone capable of organizing one
06:25:51 <merijn> gwern: Try being outside the US most interesting events are even more unreachable
06:26:40 <cads> If you build it, they will come.
06:27:09 <cads> Incidentally, I don't have any idea what the topic is. What are you talking about, gwern?
06:27:23 <aledge> inconvenient hackathon locations
06:27:55 <zeiris> Are/will there be there any hackathons around Seattle or Vancouver?
06:31:19 <Remy___> Could someone take a look at the question I posted in: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=8704#a8704
06:31:46 <Saizan> Remy___: you're right, it isn't
06:31:55 <Remy___> okay
06:31:55 <Remy___> thanks
06:35:00 <aledge> There's no way to infer which instance to use based on later uses of the given Foo instance?
06:35:39 <marekw2143> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24121#a24121, why there's error tutorial.hs:22:8: parse error on input `='   ?
06:36:39 <cads> This might not be a #haskell appropriate question, but does anyone know of a (free) web bashed haskell environment where I can edit and compile some code remotely?
06:36:45 <EvanR-work> marekw2143: probably the way you wrote the let expression
06:37:11 <cads> (I'm not a computer where I can't install things and I'm dying to get my haskell fix)
06:37:40 <EvanR-work> cads: you dont have to install putty or sshclient
06:37:50 <EvanR-work> which is how i get my fix at work
06:37:56 <kolmodin> dcoutts: ping
06:37:56 <lambdabot> kolmodin: You have 3 new messages. '/msg lambdabot @messages' to read them.
06:37:58 <merijn> cads: http://tryhaskell.org/ ?
06:38:08 <merijn> But that's rather limited
06:38:21 <marekw2143> EvanR: how should it be written?
06:38:30 <Saizan> Remy___: actually i was wrong, it depends on the instances you have
06:38:45 <EvanR-work> marekw2143: try putting the = line on the same line as the let
06:38:56 <EvanR-work> marekw2143: or indenting
06:39:01 <cads> EvanR-work: what would I have to run server-side to pimp out my home computer's bash line, as it were??
06:39:15 <Saizan> Remy___: if you have an instance Foo A x where bar _ = ...; where 'x' is literally a variable, you can call bar on a value of type A
06:39:25 <EvanR-work> cads: my home computer runs sshd
06:39:28 <EvanR-work> and i use vim
06:39:45 <Saizan> Remy___: since there's no need to specify which 'b' you want, because the instance works for any b
06:40:17 <Remy___> hmm
06:40:23 <marekw2143> EvanR: after putting "people = read people_text" in the same line as let, then there's:     Illegal signature in pattern: [Person] people
06:40:33 <merijn> cads: If you can spare a computer at home all you'd need it sshd, a command line editor (vim?), ghc(i) and screen or tmux
06:40:38 <cads> merijn: try haskell is great, but I also need to use cabal, lint, and git
06:40:42 <cads> hlint*
06:41:04 <Saizan> Remy___: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=8704#a8705
06:41:09 <merijn> I suppose you could also use a GUI editor if you set up X11 and X11forwarding on the SSH box, but that's a bit bothersome
06:41:20 <Saizan> Remy___: it's a somewhat degenerate case though :)
06:41:49 <Remy___> I haven't defined any instances of Foo yet, I want to do that in another module
06:41:54 <EvanR-work> marekw2143: you should probably read the layout rules
06:42:11 <Remy___> I just want to constrain curtain functions with Foo A x and then call bar from within them
06:42:12 <marekw2143> EvanR: layout rules, ok
06:43:53 <Saizan> Remy___: ah, that won't work because it can't decide that the 'x' in the explicit context is the same 'x' that the bar application is going to use
06:44:00 <cads> :)
06:44:11 <Remy___> yes oaky.
06:44:18 <Remy___> thanks
06:45:53 <merijn> cads: Setting up reasonable SSH environment on 2nd hand hardware running FreeBSD or linux should be pretty easy, though. If that's too much work, and you're willing to spend some money renting a VPS has become very inexpensive as of late too
06:47:24 <cads> merijn: it's a windows system and I'll be trying to remote into my msysgit environment. I should be able to find a guide.
06:48:12 <merijn> cads: Good luck, remote desktop on Windows is a pain in the ass compared to the simplicity of SSH in my experience
06:49:01 <cads> yeah, I'm literally going to see if I can turn the msysgit environment at home into a remote shell server of some kind :/
06:49:13 <cads> and ssh into it
06:49:20 <cads> thanks for the wishes of good luck :)
06:50:24 <merijn> I'd set up a BSD box, move your git repo to that and do all your work on there, whether at home or in the wide world :p
06:58:04 <Itkovian> if these hackage uploads are form zurihac, people are aiming to win that tshirt ;-)
06:59:05 <jlouis> Itkovian: hehe, I think it is a splendid idea
06:59:29 <Itkovian> jlouis: it is, but it seems like the early release is _very_ early.
07:15:48 <ManateeLazyCat> I'm crying.....
07:15:57 <ManateeLazyCat> I lost all source code that i wrote today.
07:16:23 <ManateeLazyCat> Damn it.
07:16:31 <opqdonut> how?
07:17:21 <ManateeLazyCat> opqdonut: I decomposition the package (old source code) that overwrite new code.
07:17:53 <merijn> ManateeLazyCat: Sounds like a good time to get started with version control?
07:18:20 <JuanDaugherty> you mean you wrote your changes over preexisting files?
07:18:30 <JuanDaugherty> all of them?
07:18:41 <ManateeLazyCat> merijn: I'm try to complete all WebKit API to gtk2hs, i have finish 99.9% before push patch.
07:18:45 <merijn> JuanDaugherty: He means he extracted his old source over the files containing what he wrote
07:18:58 <Zao> ManateeLazyCat: Jesus saves, why didn't you?
07:19:00 <ManateeLazyCat> JuanDaugherty: Just file that have exist in old version.
07:19:19 <merijn> Zao: Saving doesn't help in this case, committing on the other hand...
07:19:22 <JuanDaugherty> yes but for that to clobber him he'd also have to have stayed completely with the existing file namespace
07:19:37 <ManateeLazyCat> Zao: I have use Emacs backup last 10 version, but i still lost some snippets.
07:20:01 <JuanDaugherty> *within
07:20:02 <merijn> I used to only commit clean code then I overwrote a large bit of code in a similar stupid fashion. Now I just think "screw it" and commit buggy, dirty and crappy code too
07:20:09 <Zao> merijn: "Jesus commits to absolving your sins" doesn't have the same ring to it.
07:20:30 <ManateeLazyCat> I have complete all WebKit API, just some comment need adjust, but now i need binding again.
07:20:46 * JuanDaugherty note to self merijn has anti-social code commitment attitudes.
07:20:52 <Zao> merijn: It helps if you've got a VCS where you can stage commits locally, like say Mercurial (or I assume Darcs or *shudder* Git)
07:21:04 <ManateeLazyCat> I really don't know what to say now.
07:21:23 <merijn> JuanDaugherty: That's why you use a distributed VCS, so that your dirty commits don't affect anyone else
07:21:42 <merijn> Once you have a clean commit, then you push everything to the rest of the world
07:21:54 <JuanDaugherty> ah, yes if others aren't involved it's not a social issue
07:22:11 <Ferdirand> ManateeLazyCat: you could try having a look at the raw disk blocks, if the code is worth the time
07:22:32 <ManateeLazyCat> Ferdirand: Can't find it anymore.
07:22:38 <merijn> JuanDaugherty: That's the main argument for DVCS in my opinion, so that you don't leave ugly code uncommitted and risk losing it in a stupid fashin
07:22:40 <JuanDaugherty> i will usually wait on VCS until I'm using it as a deployment mechanism though
07:22:51 <ManateeLazyCat> Ferdirand: My heart is so hurt......
07:23:15 <Itkovian> Zao: not into git? :-)
07:23:18 <JuanDaugherty> backup is easier till then
07:23:49 <merijn> Itkovian: I looked at it for a little bit, but Mercurial seemed so much easier...
07:23:54 <ManateeLazyCat> I'm a foolish, absolutely....
07:24:09 <Itkovian> merijn: I'm with git atm, and it seems to work well
07:24:22 <Itkovian> Used mercurial before that
07:24:24 <JuanDaugherty> also looks nicer if a repo starts at a decent baseline
07:24:49 <merijn> Itkovian: Mercurial and git have almost identical data structure. Most of the difference between them is UI/cosmetic
07:25:25 <jlouis> merijn: if revision log and content storage is almost identical, then yes
07:25:45 <Zao> Itkovian: Let's not get into that discussion, but yes, it should be obliterated.
07:26:18 <merijn> jlouis: Identical enough that mercurial can import git repos no problem using a small plugin
07:26:30 <quicksilver> merijn: I think they have almost completely different data structures.
07:26:34 <Itkovian> Zao: fair enough :-)
07:26:41 <quicksilver> merijn: git is based broadly around the idea that a checksum is everything.
07:26:47 <quicksilver> a file is nothing but its MD5sum
07:26:56 <quicksilver> it doesn't understand renames or directory renames
07:27:05 <quicksilver> it just deduces them from files
07:27:12 <quicksilver> (which works OK in practice)
07:27:26 <quicksilver> whereas mercurial (and darc and bzr) all model directories and trees explicitly.
07:27:30 <Itkovian> I will have a hard time convincing some of my coworkers to learn yet another vcs, especially those that are too lazy to annotate their commits.
07:27:44 <jlouis> Darcs, mercurial, and git are not too different that I dislike any of them
07:28:04 <quicksilver> in particular, git can't do merges of files which have been renamed
07:28:22 <quicksilver> which may not occur very frequently but certainly proves that git is ill-conceived and based on a brain dead model. ;)
07:28:37 <merijn> Itkovian: Mercurial has a very good Idiot's Guide now
07:28:48 <Zao> merijn: Joels?
07:28:52 <merijn> More so then anything I found for git.
07:28:54 <merijn> Zao: yeah
07:29:02 <Itkovian> merijn: haha.
07:30:16 <merijn> In fact, I think most open source documentation could learn a lot about how to write introductory documentation from Joel's guide.
07:42:06 * ManateeLazyCat I restore some code, Emacs backup last 10 version automatically.
07:44:24 <ManateeLazyCat> I just want use avfs read compress package, but i type wrong keystoke to decompress it.
07:57:15 <GaMer13> I'm having some problems with wxHaskell @ Windows 7
07:57:32 <GaMer13> When I build a program with it, it tells me it fails to load comctl32.dll
07:57:44 <GaMer13> Even when I put that file in the same folder
07:57:58 <GaMer13> But ONLY when I enter the frame with my mouse
08:03:45 <kalven> I get a "Non-exhaustive patterns in function"-error, is there a way to see exactly what the function was called with?
08:06:07 <Cale> kalven: You might try Debug.Trace.trace
08:06:29 <kalven> alright, thanks
08:06:35 <Cale> kalven: An associated idiom is to do something like:
08:07:01 <Cale> foo x y z | trace (unwords [show x, show y, show z]) False = undefined
08:07:15 <Cale> as the first line of the function definition
08:07:46 <Cale> However, note that printing the parameters to the function will force them to be evaluated, so it can make things stricter than you want sometimes
08:07:51 <quicksilver> Cale: well, if he's getting the non-exhaustive pattern error anyway
08:07:55 <Cale> yeah
08:08:11 <quicksilver> Cale: then why not add foo x y x = error $ show (x,y,z)
08:08:22 <quicksilver> Cale: (and avoid all that messing around with trace and a fake guard)
08:08:24 <Cale> Oh, that's a decent idea as well ;)
08:08:34 <quicksilver> as final clause not first clause, of course
08:08:41 <Cale> yep
08:09:24 <GaMer13> Anyone familiar with the "failed to laod comctl32.dll" error? :(
08:09:44 <Cale> GaMer13: I'd help you, but I'm not a Windows user.
08:09:45 <kalven> Cale,quicksilver: thanks, I know what to do now.
08:10:03 * hackagebot hommage 0.0.6 - Haskell Offline Music Manipulation And Generation EDSL  http://hackage.haskell.org/package/hommage-0.0.6 (DanielVanDenEijkel)
08:10:11 <Cale> GaMer13: Maybe the library you're using is built against a different version of the library?
08:10:21 <Cale> (a different version of comctl32)
08:10:50 <GaMer13> Is there a way to check which version is being used while building the module for wxHaskell?
08:14:04 <GaMer13> @Cale, also: http://sourceforge.net/tracker/index.php?func=detail&aid=2810904&group_id=73133&atid=536845
08:14:04 <lambdabot> Unknown command, try @list
08:14:09 <GaMer13> :Cale, also: http://sourceforge.net/tracker/index.php?func=detail&aid=2810904&group_id=73133&atid=536845
08:14:50 <medfly> GaMer13, it's okay, lambdabot listens to stuff people say on the channel. its response doesn't mean your message didn't go through
08:15:01 <GaMer13> Oke :)
08:28:11 * hackagebot haskoon 0.1 - Web Application Abstraction  http://hackage.haskell.org/package/haskoon-0.1 (DavidLeuschner)
08:36:31 <HugoDaniel> has anyone worked with the haskell-json library ?
08:44:45 <rothwell> 'lo. are there any tools out there for the formal verification of haskell programs. something like http://frama-c.com/features.html for haskell, perhaps?
08:45:41 <jmcarthur> rothwell: you can use Coq or Agda to generate haskell code
08:45:51 <jmcarthur> it's a bit different from what you mean i think
08:46:13 <rothwell> hm, yeah
08:46:33 <jmcarthur> i suspect you are looking for a static analyzer
08:46:42 <rothwell> i was hoping to annotate haskell code with pre/postconditions and have them checked statically... as an example
08:46:54 <jmcarthur> which... there are some (aside from compilers themselves), but they don't really do a whole lot
08:47:11 <jmcarthur> rothwell: preconditions and postconditions can sometimes be placed in the type system :)
08:47:16 <rothwell> yep
08:47:31 <jmcarthur> sometimes it's just impractical though, definitely
08:47:33 <rothwell> frama-c is pretty extensive... essentially amounts to theorem proving in annotations, though
08:47:42 <rothwell> and yeah, can be horribly impractical
08:47:59 <jmcarthur> i think if you want to prove soem functiosn correct you are probably best off doing it in something like Coq
08:48:04 <jmcarthur> *some functions
08:48:27 <jmcarthur> a somewhat manual process compared to static analysis, but not too bad
08:48:43 <rothwell> i'm reasonably comfortable with coq
08:48:57 <rothwell> not sure how to bridge from haskell -> coq, however
08:49:00 <rothwell> are there tools to do this?
08:49:05 <jmcarthur> but if you are wanting to prove that X resource is never used improperly in an entire program, coq won't help you unless you feel like writing the whole thing in cow :\
08:49:19 <jmcarthur> coq can actually generate haskell functions from coq source code
08:49:38 <jmcarthur> ones which have been proven in coq's richer type system
08:50:15 <jmcarthur> *the whole thing in coq
08:50:22 <jmcarthur> cow would be a great name for a language though
08:50:31 <rothwell> hehe
08:50:36 <rothwell> surprised it's not taken already
08:52:17 <rothwell> one example of something i'd like to statically check is that values of a given type are in the range -65535 .. 65535
08:52:32 <rothwell> i can add guards on data constructors, but those are obviously runtime checks
08:53:10 <zygoloid> rothwell: that's pretty tricky in general. there are tricks you can do with fake dependent types
08:53:24 <rothwell> zygoloid: yeah
08:53:25 <jmcarthur> rothwell: even with static analysis, you will end up having to do runtime checks unless user input has absolutely no bearing on those values
08:53:27 <zygoloid> (you could parameterize your type by the minimum and maximum value it could hold)
08:53:38 <rothwell> zygoloid: yep
08:54:13 <jmcarthur> :t (minBound :: Int16, maxBound :: Int16)
08:54:14 <lambdabot> (Int16, Int16)
08:54:20 <jmcarthur> woops
08:54:25 <jmcarthur> > (minBound :: Int16, maxBound :: Int16)
08:54:26 <lambdabot>   (-32768,32767)
08:54:30 <jmcarthur> oh, right
08:54:32 <rothwell> i'm really just looking at all the options here... i'm aware of the terrifying uses of dependent types
08:54:34 <mightybyte> @seen bos
08:54:35 <lambdabot> Unknown command, try @list
08:54:52 <mightybyte> @list
08:54:52 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
08:54:58 <rothwell> jmcarthur: i, er, should have mentioned that i'm after a floating point type
08:55:02 <rothwell> that complicates things even further
08:55:07 <jmcarthur> rothwell: smart constructors are not so bad. you don't have to use runtime checks for every operation, just for initial construction
08:55:19 <jmcarthur> rothwell: as long as you only export functions that maintain the invariants of the type
08:55:23 <rothwell> and on any arithmetic, surely
08:55:32 <jmcarthur> rothwell: only if you expose arithmetic operations
08:55:46 <zygoloid> rothwell: oleg had a nice idea for vectors which partially applies here
08:55:47 <rothwell> i'll try to elaborate a little more
08:55:58 <monochrom> There is no formal methods developed for functional languages because functional people move that into types.
08:56:08 <zygoloid> rothwell: instead of normal operations you write operations which are in range 'by construction'
08:56:09 <rothwell> it's code for a simulation that'll run on hardware that only has 32 bit floating point types
08:56:23 <zygoloid> rothwell: so instead of an addition primitive, you have averaging
08:56:32 <HugoDaniel> i need help with the haskell json lib, anyone ?
08:57:01 <zygoloid> rothwell: and instead of multiplication you might have multiplication-then-division-by-65535
08:57:29 <rothwell> i see
08:57:57 <Philonous1> zygoloid: How does that work out? Averaging isn't even associative
08:58:58 <zygoloid> Philonous1: well, you reformulate your operations in terms of the new primitives, if that's possible. and if it's not possible, you take some operation you need (which statically guarantees the result is in range) and add it to your trusted core
08:59:28 <zygoloid> if /that/ isn't possible (because there's no such guarantee) then you'll need a runtime check. but in that case it's an essential runtime check.
08:59:57 <Philonous1> zygoloid: AH, I thought you meant replacing addition with averaging, that wouldn't make sense. But you mean to rewrite the algorithm with a numerically stable one?
09:00:00 <zygoloid> the idea is simply to minimize the extent of the code you need to prove correct
09:00:19 <zygoloid> Philonous1: yeah, you can't really hope to get a normal Num instance to work here :)
09:06:17 <rothwell> currently looking into Agda
09:07:06 <fax> rothwell ?
09:07:55 <rothwell> fax: ?
09:08:19 <fax> :(
09:08:37 <rothwell>       /o/
09:17:39 <fax> Idon't know how to write my program so that' it's modular
09:17:42 <fax> this is so frustrating
09:18:13 <zygoloid> @oeis 2 3 5 7 13 17 19 31 61 89
09:18:14 <lambdabot>  Primes p such that 2^p - 1 is prime. 2^p - 1 is then called a Mersenne prime.
09:18:14 <lambdabot>  [2,3,5,7,13,17,19,31,61,89,107,127,521,607,1279,2203,2281,3217,4253,4423,968...
09:18:45 <fax> wow I didn't know there was so many small ones
09:18:57 <zygoloid> i was hoping there was a nice name for them :(
09:19:09 <fax> Mersenne primes ??
09:19:20 <zygoloid> no, the p not the 2^p-1
09:19:26 <fax> ohh
09:19:51 <fax> that explains why there are s omany small ones :D
09:19:57 <fax> I was thinking of the other sequence
09:22:48 <Kagami`> > let (****) f x = f *** f $ x in (+1) **** (1,3)
09:22:49 <lambdabot>   (2,4)
09:22:55 <Kagami`> does the function like (****) already exist?
09:23:16 <Twey> join (***)
09:23:25 <Twey> > join (***) succ (1, 3)
09:23:26 <lambdabot>   (2,4)
09:23:44 <Kagami`> oh, thanks
09:24:36 <aavogt> @type let (****) f x = f *** f $ x in (****)
09:24:37 <lambdabot> forall b c. (b -> c) -> (b, b) -> (c, c)
09:25:16 <Twey> :t join (***)
09:25:17 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
09:25:32 <Twey> You say function, I say arrow.  :
09:25:37 <Twey>  Cale says category, I think.
09:26:25 <EvanR-work> so whats an arrow
09:26:29 * EvanR-work runs
09:26:46 <Twey> EvanR-work: In this case, it's a function.  ;)
09:28:01 <monochrom> an arrow is like an abstraction
09:28:14 <Kagami`> Twey: actually, i don't understand how `join' work in this case. could you explain please?
09:28:24 <EvanR-work> an arrow is like a burrito
09:28:41 <Twey> Kagami`: join f x = f x x
09:28:46 <Twey> For functions
09:28:49 <Twey> Nothing more to it
09:29:07 <Kagami`> Twey: ok, thanks
09:31:29 <Entroacceptor> damn you, I've already eaten two burritos this week
09:31:56 <fax> I do not understand why anyone would want to use this  1/3 n^3 + n^2 = O(n^3)
09:32:05 <fax> "one sided equality"
09:32:10 <fax> why not use a different symbol???
09:32:21 <monochrom> because they are mathematicians
09:32:31 <fax> this is in a computing book :|
09:32:40 <monochrom> written by mathematicians
09:32:46 <Entroacceptor> I doubt it
09:32:53 <fax> I am sick of mathematicians!
09:33:01 <fasta> You can argue about the syntax, but it is standard.
09:33:27 <fasta> Nobody with a CS degree would find that hard to read.
09:33:47 <monochrom> Stephen Cook actually told us this about why he joined the CS department. For the kind of math he does, either the math department or the cs department is fine. He chose cs because it has more grants.
09:34:05 <medfly> :)
09:34:16 <fasta> For grants, so I have been told, you need to be in physics.
09:34:18 <quicksilver> that's a good reason, in many countries.
09:34:23 <monochrom> Nothing in "he's in cs" or "this is a cs book" says he is not secretly a mathematicians.
09:34:40 <fax> so they are ... among us?
09:34:42 <quicksilver> nearly all the good people in CS are mathematicians (secretly or not)
09:34:52 <Ke> !
09:34:59 <aavogt> @hoogle Applicative f => (a -> b -> f c) -> [a] -> [b] -> f [c]
09:35:00 <lambdabot> Control.Monad zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
09:35:00 <lambdabot> Control.Monad zipWithM_ :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m ()
09:35:00 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
09:35:24 <medfly> even the kids that chose it because they want to "make games" ?:)
09:35:47 <quicksilver> they're not good people in the sense I intended ;)
09:35:49 <mightybyte> medfly: Notice the qualifier "good people"
09:35:49 <monochrom> Anyway, the nature of mathematicians is to prefer wrong notation over funny notation.
09:36:03 <quicksilver> although they may be perfectly decent individuals no doubt.
09:36:31 <Saizan> they could have used \in here, it's not that funny
09:36:56 <fasta> I think the derivatives syntax is worse. There are about 6 ways to denote that, and those are only the ones that I know of.
09:36:57 * zygoloid has seen books which use \in O(n), but only in passing before they say "yeah, we're gonna write that as = O(n), but now you know what we mean..."
09:37:28 <zygoloid> fasta: i think part of that is differing notions of what a variable is
09:37:35 <Mathnerd314> fasta: that's mostly Leibniz vs. Newton
09:37:55 <monochrom> Except that n \in O(n) is still wrong. Do a type-check on it, starting with n :: Natural.
09:38:15 <zygoloid> monochrom: you have to start with n :: Expr
09:38:16 <monochrom> It should really be: (\n -> n) \in O((\n -> n)) for example.
09:38:29 <zygoloid> O(n) :: Set(Expr)
09:38:32 <fasta> You have f' and f^(1) for example. You also have the dot notation, df/dx and so on.
09:39:01 <fasta> If you take any random physics paper you are likely to be confused if you haven't seen all of them.
09:39:16 <Mathnerd314> dot is Newton, f' is because people can't type dot, df/dx is Leibniz
09:39:18 <monochrom> n::Expr poses other problems.
09:39:22 <Saizan> they use all of them in the same paper?
09:39:40 <fasta> Saizan, can't remember, but it doesn't really matter.
09:39:42 <zygoloid> i've seen three different forms of derivative used in the same /expression/
09:40:27 <zygoloid> (admittedly two of them were total and partial derivatives, and that seems fair enough)
09:48:06 <liesen> q
09:54:28 <quicksilver> the thing about the various kind of derivative, is a bit like the thing about the O() notation, is really about scoping and binding
09:54:46 <quicksilver> sometimes mathematicians like to treat variables as formal parameters, bound locally, which are arbitrary in name
09:55:05 <quicksilver> and at other times they have a wider connotation from the surrounding context which is not at all arbitrary.
09:55:18 <quicksilver> and you get clumsy translations like "if we consider y to be a function of x, then...."
09:57:29 <fasta> It is basically a kind of type-inference that a human has to do.
09:57:46 <medfly> basically, mathematicians care less about syntax than people who do CS/programming
09:58:04 <quicksilver> yes.
09:58:14 <Mathnerd314> so I care too much about syntax...
09:58:16 <quicksilver> typically, anyway.
10:01:02 <Saizan> you can argue that being so careless is not so productive
10:01:34 <FliPPeh_> How well does haskell do at parsing binary data, wheter it's from a socket or a file? I'd imagine Haskell being a bit too high level for this to be easy..
10:01:45 <FliPPeh_> Seems more like a C job
10:01:55 <FliPPeh_> But I'd be happy to learn better!
10:02:31 <quicksilver> FliPPeh_: sounds like you've never tried to write a binary parser in C
10:02:38 <medfly> :)
10:02:55 <bnjmn> FliPPeh_, attoparsec perhaps?
10:03:02 <quicksilver> writing binary parsers in a low-level language is like doing a crossword puzzle. It's an interesting challenge, it can be fun, you can get really good at it, but it's not an efficient way to get jobs done.
10:03:13 <Saizan> there are multiple packages for that: binary, cereal, attoparsec, ... binary is the oldest and has its shortcomings but it's already quite pleasant.
10:05:32 <FliPPeh_> I know it's a pain in C, but everything is a pain in C
10:05:45 <FliPPeh_> But it seems easier
10:05:57 <medfly> lol
10:06:06 <mm_freak> i can confirm that attoparsec is very fast
10:06:21 <quicksilver> actually if your binary data is byte-aligned (which is pretty common) then parsec itself does a decent job
10:06:34 <quicksilver> nothing about parsec is hard-coded to be parsing text.
10:06:39 <mm_freak> allowing a lot of free form it parses 8 MiB within 14 seconds
10:06:42 <Twey> FliPPeh_: Data.Binary has a lovely Get monad that works like C structs.
10:07:00 <mm_freak> disallowing free form (which is usual for binary data) it drops to 6 seconds
10:07:45 <FliPPeh_> :)
10:24:48 <FliPPeh_> "As with hGet, the string representation in the file is assumed to be ISO-8859-1." for Data.ByteString.hGetContents
10:24:53 <FliPPeh_> So, how do I read unicode?
10:24:58 <FliPPeh_> UTF-8, that is
10:25:01 <mauke> decode after reading
10:25:28 <FliPPeh_> Won't it corrupt the unicode glyphs?
10:25:36 <FliPPeh_> In the receiving part already
10:25:46 <mauke> what glyphs?
10:25:48 <jmcarthur> how?
10:26:07 <FliPPeh_> Say in the received string is a character NOT ISO-8859-1
10:26:13 <jmcarthur> ?hackage text
10:26:13 <lambdabot> http://hackage.haskell.org/package/text
10:26:21 <mauke> FliPPeh_: impossible
10:26:24 <FliPPeh_> (in that sense, I should SERIOUSLY learn more about it)
10:26:25 <mauke> FliPPeh_: also, the docs are wrong
10:26:49 <mauke> how can it assume an encoding when it's a bytestring?
10:27:17 <FliPPeh_> I just notice
10:27:26 <FliPPeh_> ISO-8859-1 is 8-bit characters
10:28:00 <jmcarthur> FliPPeh_: http://hackage.haskell.org/packages/archive/text/0.7.1.0/doc/html/Data-Text-IO.html
10:28:47 <FliPPeh_> Looks good
10:28:48 <FliPPeh_> :)
10:30:22 <Twey> mauke: How does hGetContents >>= take 1 . words work without any encoding at all assumed?
10:30:35 <Twey> Er, take 1 . words <$> hGetContents
10:30:37 <Twey> Or whatever 
10:30:45 <benmachine> is it not words that assumes the encoding
10:30:51 <benmachine> rather than hGetContents or take 1
10:31:42 <mauke> Twey: it doesn't work
10:31:44 <Twey> I don't think so.  Isn't it up to hGetContents to translate into internal encoding before passing to internal functions like words?
10:31:53 <mauke> Twey: words takes a String
10:32:00 <jmcarthur> @hoogle words
10:32:00 <lambdabot> Prelude words :: String -> [String]
10:32:00 <lambdabot> Data.List words :: String -> [String]
10:32:00 <lambdabot> Data.ByteString.Char8 words :: ByteString -> [ByteString]
10:32:09 <mauke> oh, did you mean the .Char8 version?
10:32:15 <Twey> mauke: Well, it was an example, but sure
10:32:17 <benmachine> I guess Char8 assumes an encoding
10:32:23 <mauke> .Char8 assumes ISO 8859-1, yes
10:32:49 <mauke> because it just turns bytes into characters, and the first 256 unicodepoints are ISO 8859-1
10:33:14 <FliPPeh_> So basically I read in a String of Bytes and later encode it into UTF-X
10:33:17 <FliPPeh_> Right?
10:33:41 <jmcarthur> FliPPeh_: or just use the text library i linked to and don't worry about it :)
10:34:01 <mauke> FliPPeh_: huh?
10:34:17 <mauke> you read a ByteString and later decode it into Unicode
10:34:24 <mauke> or use a library that does it for you
10:34:31 <FliPPeh_> It's indeed an option, but I as long as there's ways around it, I try not to install too many libraries
10:34:43 <jmcarthur> FliPPeh_: i would consider that unwise
10:35:07 <FliPPeh_> That's always too many dependencies
10:35:15 <jmcarthur> FliPPeh_: that's what cabal-install is for
10:36:00 <mreh> do we have good graphics bindings in haskell?
10:36:10 <jmcarthur> mreh: for what purpose?
10:36:16 <FliPPeh_> opengl?
10:36:35 <mreh> I've never used anything other than HGL, and I need something that does alpha blending and smooth lines
10:36:38 <mreh> 2D
10:36:40 <tommd> Can you instruct GHCi to compile (not interpret) the instructions in the .ghci file?
10:36:40 <lambdabot> tommd: You have 1 new message. '/msg lambdabot @messages' to read it.
10:36:50 <jmcarthur> mreh: try graphics-drawingcombinators
10:37:07 <jmcarthur> mreh: or perhaps gloss, although i think i like the semantic-driven design of the former better
10:37:19 <mreh> thanks
10:37:37 <jmcarthur> mreh: there's also chalkboard, which i haven't given much attention to but might be nice
10:39:16 <jmcarthur> mreh: actually i don't know if g-dc does smooth lines... it probably does
10:39:26 <jmcarthur> i assume you mean antialiased or something?
10:39:48 <mreh> jmcarthur: antialiasing, that's the one
10:40:16 <mreh> It would be nice to have a Real number co-ordinate system too
10:40:17 <jmcarthur> mreh: looking at the source, it does what you want
10:40:29 <jmcarthur> mreh: GL.lineSmooth GL.$= GL.Enabled  is in the run function, at least
10:40:41 <jmcarthur> mreh: by Real you don't mean Double?
10:41:03 <jmcarthur> mreh: g-dc uses GLdouble
10:41:08 <FliPPeh_> > map (+1) [1,2,3] == fmap (+1) [1,2,3]
10:41:09 <lambdabot>   True
10:41:12 <mreh> jmcarthur: as in the "real numbers" Double is an example of that yeah
10:41:13 <FliPPeh_> What's the difference?
10:41:13 <c_wraith> As a semi-related point, I'm told that NVidia intentionally cripples handling of line-drawing in their consumer parts, as a way to distinguish the quadro line.
10:41:21 <jmcarthur> FliPPeh_: fmap is more general
10:41:22 <mreh> FliPPeh_, none
10:41:27 <mreh> for lists
10:41:32 <jmcarthur> :t fmap
10:41:33 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:41:38 <FliPPeh_> Ahh
10:41:40 <benmachine> tommd: I've put some of my functinos that I defined in there into a module, installed it as a cabal package, and then loaded it with :m
10:41:41 <jmcarthur> > fmap (+1) (Just 5)
10:41:42 <lambdabot>   Just 6
10:41:45 <FliPPeh_> Alright
10:41:46 <jmcarthur> > map (+1) (Just 5)
10:41:47 <lambdabot>   Couldn't match expected type `[a]'
10:41:47 <lambdabot>         against inferred type `Data.Mayb...
10:41:49 <mreh> all monads are functors
10:41:50 <benmachine> tommd: I don't think you're going to get better than that
10:41:54 <FliPPeh_> So map is fmap for lists only
10:41:59 <jmcarthur> FliPPeh_: exactly
10:42:02 <mreh> FliPPeh_, in the prelude, yeah
10:42:23 <benmachine> instance Functor [] where fmap = map
10:42:29 <benmachine> @src Functor []
10:42:29 <lambdabot> Source not found. I've seen penguins that can type better than that.
10:42:31 <benmachine> blah
10:42:42 <jmcarthur> @src fmap []
10:42:42 <lambdabot> Source not found. My pet ferret can type better than you!
10:42:47 <benmachine> @src [] fmap
10:42:47 <lambdabot> fmap = map
10:42:47 <tommd> benmachine: Thanks, sounds good!
10:42:47 <jmcarthur> @src [] fmap
10:42:48 <lambdabot> fmap = map
10:43:16 <quicksilver> c_wraith: that would be because games never use the linedrawing code - they always use texture maps and suchlike techniques
10:43:31 <quicksilver> c_wraith: but CAD programs have long relied very heavily on opengl's line drawing primitives
10:43:43 <quicksilver> c_wraith: so that splits nicely in favour of the guys who buy the expensive cards :)
10:43:49 <jmcarthur> ew
10:43:51 <ClaudiusMaximus> mreh: cairo (part of gtk iirc) does that kind of vector graphics, there're probably nicer libraries on top of it too
10:43:56 <quicksilver> well, in favour of invidia making lots of money rather.
10:44:15 <c_wraith> well, the point was more..  The hardware isn't different, except they burn an internal fuse in the consumer parts to cripple line-drawing
10:44:17 <quicksilver> cairo isn't fast enough for animations though.
10:44:31 <mreh> ClaudiusMaximus, which has the most cross platform compatibility?
10:44:36 <quicksilver> c_wraith: right. Just like a one-core celeron is a core duo with one core disabled :)
10:44:40 <mreh> I'm guessing an openGL based one
10:44:56 <jmcarthur> cairo is pretty cross platform. opengl is faster though
10:44:59 <monochrom> and some cache disabled
10:45:04 <quicksilver> yes, and that.
10:45:04 <jmcarthur> and also cross platform
10:45:22 <mreh> jmcarthur, thanks
10:46:12 <jmcarthur> mreh: fortunately the libraries i mentioned earlier are all based on opengl :)
10:46:53 <mreh> yay!
10:47:44 <mreh> they'll never suspect my game isn't ray traced now!
10:47:53 <jmcarthur> heh
11:05:23 <zeiris> Is there a way to make Haskell dictionaries as easy to use and define as they are in Python?
11:05:30 <zeiris> s/dictionaries/maps, I guess
11:05:38 <mauke> did you mean: annoying
11:05:48 <aavogt> @type M.!
11:05:49 <lambdabot> parse error on input `M.!'
11:05:53 <aavogt> @type (M.!)
11:05:53 <lambdabot> forall k a. (Ord k) => M.Map k a -> k -> a
11:05:57 <Cale> zeiris: What's wrong?
11:06:27 <aavogt> you're free to use   Map Dynamic Dynamic
11:06:35 <zeiris> I'm writing Python code for a personal project and keep finding myself thinking "I wish I was writing Haskell". I guess that's kinda wrong, heh.
11:07:11 <monochrom> Oh, the meaning is "is there a way to bring Haskell ease to Python"
11:07:38 <aavogt> though I suppose there isn't a default Ord instance for dynamic...
11:07:45 <aavogt> @instance-importing Dynamic
11:07:45 <lambdabot> Couldn't find class `Dynamic'. Try @instances-importing
11:07:52 <aavogt> @instances-importing Dynamic
11:07:53 <lambdabot> Couldn't find class `Dynamic'. Try @instances-importing
11:07:57 <aavogt> @instances-importing Ord
11:07:57 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), (a, b, c, d, e), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
11:09:28 <zygoloid> > toDyn 42 < toDyn "hello"
11:09:30 <lambdabot>   No instance for (GHC.Classes.Ord Data.Dynamic.Dynamic)
11:09:30 <lambdabot>    arising from a us...
11:09:40 <aavogt> well in any case, a suitable compare is:     comparing fromDynamic `mappend` some way to compare typereps...
11:11:26 <zygoloid> umm. that defaults to () doesn't it?
11:11:30 <zeiris> Oooh. I just realized that I can do this http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24129#a24129 by just using M.fromList on a list of tuples! :D That's what stopped me in the past, the inability to define arbitrary maps at will! :)
11:12:21 <aavogt> zygoloid: gah, then you have to explicitly try a bunch of listed types to convert to
11:12:27 <zygoloid> right
11:12:34 <EvanR-work> is (a, b, c, d, e) the biggest tuple type
11:12:44 <zygoloid> > (a, b, c, d, e, f)
11:12:46 <lambdabot>   Ambiguous type variable `a' in the constraints:
11:12:46 <lambdabot>    `GHC.Show.Show a'
11:12:46 <lambdabot>      a...
11:12:46 <aavogt> 62 is the largest tuple type
11:13:03 <EvanR-work> > (1, 2, 3, 4, 5, 6, 7)
11:13:04 <lambdabot>   (1,2,3,4,5,6,7)
11:13:05 <zygoloid> > (a, b, c, d, e, i)
11:13:09 <lambdabot>   (a,b,c,d,e,i)
11:13:33 <aavogt> rather tuple value. ghc is fine with printing the types of larger tuples
11:13:33 <zygoloid> f, g and h are "special" :)
11:14:48 <siracusa> aavogt: Why 62?
11:15:17 <aavogt> siracusa: because it's close to 64?
11:15:22 <aavogt> > log 64 / log 2
11:15:23 <lambdabot>   6.0
11:16:34 <zygoloid> > let k ~> v = (k, toDyn v) in M.fromList ["foo" ~> [1,2,3], "bar" ~> (0,99), "baz" ~> Just 42]  -- zeiris
11:16:35 <lambdabot>   fromList [("bar",<<(Integer,Integer)>>),("baz",<<Maybe Integer>>),("foo",<<...
11:16:38 <aavogt>  ghc:  A 63-tuple is too large for GHC (max size is 62) Workaround: use nested tuples or define a data type
11:16:57 <Phyx-> 63 tuple? o.O
11:17:24 <zeiris> :t (~>)
11:17:24 * zygoloid wonders why ghc needs a limit
11:17:25 <lambdabot> Not in scope: `~>'
11:17:38 * Phyx- wonders why someone needs a 63 tuple
11:17:39 <zygoloid> zeiris: 'let k ~> v = (k, toDyn v)'
11:17:51 <zeiris> Oh, hah.
11:18:06 <zygoloid> Phyx-: if anyone needed a 63 tuple, i expect GHC would support them :)
11:18:33 <Phyx-> zygoloid: so you're saying the 62 one came because someone needed a 62 tuple? lol
11:18:38 <zygoloid> maybe 62 was the point at which the intern got bored of copy-pasting
11:18:56 <zygoloid> Phyx-: well *obviously* a 62-tuple is reasonable.
11:19:12 <liyang> Phyx-: because 640k^H^H^H^Ha 63-tuple ought to be enough for anyone.
11:19:48 <Phyx-> "640k^H^H^H^Ha" ?
11:20:10 <mauke> someone doesn't know ^W
11:20:34 <Phyx-> i'm a simple idler :)
11:21:18 <jmelesky> (in a nutshell) "^H" is what backspace looks like if you're in a terminal that doesn't understand backspaces
11:21:27 <FauxFaux> ^?^?^?
11:21:34 <Phyx-> jmelesky: ah
11:21:53 <jmelesky> also, bill gates famously (possibly apocryphally) said that 640k was enough for anyone, back when that was alot of RAM
11:22:20 <fax> yeah but that's just a myth
11:22:30 <aavogt> so is the 63-tuple
11:22:31 <Phyx-> mauke: and what's ^W?
11:22:50 <mauke> ctrl-h is delete-char, ctrl-w is delete-word, ctrl-u is delete-line
11:23:02 <Phyx-> ah, good to know
11:23:11 <liyang> mauke: ^W is less dramatic when I've only 4 characters to delete.
11:23:15 <monochrom> ascii art for striking out
11:23:22 <medfly> :t (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
11:23:23 <lambdabot> forall a b c d e f g h i j k l m n o p q r s t u v w x y z t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52 t53 t54 t55 t56 t57 t58 t59 t60 t61 t62
11:23:23 <lambdabot> t63 t64 t65 t66 t67 t68 t69 t70 t71 t72. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t28 -> t29 -> t30 -> t31 ->
11:23:23 <lambdabot> t32 -> t33 -> t34 -> t35 -> t36 -> t37 -> t38 -> t39 -> t40 -> t41 -> t42 -> t43 -> t44 -> t45 -> t46 -> t47 -> t48 -> t49 -> t50 -> t51 -> t52 -> t53 -> t54 -> t55 -> t56 -> t57 -> t58 -> t59 ->
11:23:23 <lambdabot> t60 -> t61 -> t62 -> t63 -> t64 -> t65 -> t66 -> t67 -> t68 -> t69 -> t70 -> t71 -> t72 -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t28, t29, t30, t31, t32, t33,
11:23:23 <lambdabot>  t34, t35, t36, t37, t38, t39, t40, t41, t42, t43, t44, t45, t46, t47, t48, t49, t50, t51, t52, t53, t54, t55, t56, t57, t58, t59, t60, t61, t62, t63, t64, t65, t66, t67, t68, t69, t70, t71, t72)
11:23:27 <medfly> so that's okay?
11:23:37 <medfly> sorry :p
11:23:45 <fax> now I know my a b c...
11:23:55 <aavogt> just because ghc has general code to print the types of such tuples, doesn't mean it can represent those values
11:24:06 <medfly> ah
11:24:13 * siracusa wonders if anyone ever used tupels with size > 10
11:24:41 <aavogt> more than 2 and you should consider a data type
11:24:41 * fax has never used a tuple other than (,)
11:24:59 * Phyx- has used up to (,,)
11:25:21 <monochrom> google number of hits for "tuples of size <x>"
11:25:28 <aavogt> @type ((,),(,))
11:25:29 <lambdabot> forall a b a1 b1. (a -> b -> (a, b), a1 -> b1 -> (a1, b1))
11:26:03 <Phyx-> @google google fight
11:26:04 <aavogt> yes, then graph the frequencies
11:26:05 <lambdabot> http://www.googlefight.com/
11:26:05 <lambdabot> Title: Google Fight : Make a fight with googleFight
11:26:23 <medfly> uhh...
11:26:39 <lament> @google google google google google fight!
11:26:41 <lambdabot> http://www.googlefight.com/
11:26:41 <lambdabot> Title: Google Fight : Make a fight with googleFight
11:32:22 <GaMer13> join #haskell.dut
11:32:34 <Lemmih> GaMer13: No thanks.
11:32:39 <iammisc> does haskell have an object-relational mapper?
11:32:43 <GaMer13> :P Sorry, forgot the slash :)
11:33:03 <burp> not that I know of iammisc
11:33:39 <aavogt> iammisc: well it doesn't really encourage the use of objects either
11:34:02 <burp> but something similar would be nice anyway :>
11:34:03 <iammisc> aavogt: true
11:34:04 <burp> or some replacement
11:34:08 <iammisc> but what burp said
11:35:10 <aavogt> well depending on your requirements, maybe some serialization framework (like say happstack-data) may be good enough?
11:36:13 <burp> hehe, people always suggest that as a lack of some replacement ;)
11:36:30 <burp> well, what else can one do ;-)
11:36:45 <burp> inspire someone to do it, or do it yourself, or wait
11:38:26 <monochrom> all you need is a value-relation mapper.
11:38:50 <jmcarthur> :t (,) (,) (,) (,) (,) (,) (,) (,) (,) (,) (,) (,) (,) (,) (,) (,) (,) (,) (,) (,) (,) (,) (,) (,)
11:38:51 <lambdabot>     Couldn't match expected type `(a -> b -> (a, b))
11:38:51 <lambdabot>                                   -> (a1 -> b1 -> (a1, b1))
11:38:51 <lambdabot>                                   -> (a2 -> b2 -> (a2, b2))
11:39:01 <jmcarthur> hmm dunno what i was thinking there
11:40:13 <Phyx-> @type readInterfaceFile
11:40:14 <lambdabot> Not in scope: `readInterfaceFile'
11:57:04 <zygoloid> @type (,).(,).(,).(,).(,).(,).(,).(,).(,).(,).(,).(,).(,).(,).(,).(,).(,).(,).(,).(,).(,).(,).(,).(,).(,)
11:57:06 <lambdabot> forall b b1 b2 b3 b4 b5 b6 b7 b8 b9 b10 b11 b12 b13 b14 b15 b16 b17 b18 b19 b20 b21 b22 b23 a b24. a -> b -> (b1 -> (b2 -> (b3 -> (b4 -> (b5 -> (b6 -> (b7 -> (b8 -> (b9 -> (b10 -> (b11 -> (b12 -> (
11:57:06 <lambdabot> b13 -> (b14 -> (b15 -> (b16 -> (b17 -> (b18 -> (b19 -> (b20 -> (b21 -> (b22 -> (b23 -> (b24 -> (a, b24), b23), b22), b21), b20), b19), b18), b17), b16), b15), b14), b13), b12), b11), b10), b9), b8),
11:57:06 <lambdabot> b7), b6), b5), b4), b3), b2), b1), b)
12:08:04 <gio123> does anybody has access to this paper?
12:08:06 <gio123> A Semantic Web Reasoner for Rules, Equations and Constraints
12:08:07 <gio123> ?
12:12:09 <edwardk> hrm. finding myself playing with an odd structure
12:12:09 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
12:13:41 <edwardk> @tell gracenotes the haskell-soc wiki seems to be broken. if you don't already have an account, I can't make you one, at the moment. If you want to register, send me your full name and email. In the meantime,  I'll follow up and see what the status is on getting it fixed.
12:13:41 <lambdabot> Consider it noted.
12:14:46 <Gracenotes> edwardk: great, thanks. just a sec, infos in PM..
12:14:47 <lambdabot> Gracenotes: You have 1 new message. '/msg lambdabot @messages' to read it.
12:15:08 <edwardk> i started hacking on my fingertree of bytestring-like values, and i needed a way to express the kinds of thresholds at which you might cut a rope
12:16:04 <ManateeLazyCat> Hi all. I have finish all WebKit-Gtk+ 1.1.15 API binding in gtk2hs. Now you can use gtk2hs develop Webkit browser like any other Language.
12:16:09 <edwardk> based on the measures i have in the fingertree, there are three kinds of monotonically increasing thresholds i can efficienctly answer questions about.
12:16:34 <edwardk> the number of bytes seen so far, the number of chars seen so far, and the number of 'extra bytes' (bytes - chars)
12:16:34 <ManateeLazyCat> This is binding is completely.
12:16:54 <edwardk> but those aren't the only thresholds, since you can also reasonably ask for the min or the max of two other thresholds.
12:18:48 <zeiris> What's the GHC {-# #-} command for pre-calculating values at compilation time?
12:19:10 <edwardk> there are other monotonic functions over buffers, obviously, but those are the only ones i can answer quickly off of the fingertree
12:19:11 <zeiris> (I assume this resolves "Dynamic"-caused type conflict bugs before they reach runtime?)
12:19:23 <edwardk> so i started looking at representations
12:19:45 <edwardk> i can of course represent those behind an opaque 'wall' as functions of the form Int -> Int -> Bool
12:19:59 <edwardk> but that makes me binary search for where they change values in the leaf level bytestrings
12:20:24 <gio123> does anybody has access to this paper?
12:20:27 <gio123> A Semantic Web Reasoner for Rules, Equations and Constraints ?
12:20:47 <edwardk> so i'm probably stuck dealing with a formulation like data Threshold = Byte Int | Char Int | Extra Int | Min Threshold Threshold | Max Threshold Threshold
12:21:08 <FliPPeh_> Okay, I have a big source of HTML here and I need the value of a certain HTML tag property, the action attribute of a <form> tag. What's a nice way to scan the source and get it?
12:21:09 <edwardk> which of course invites the fact that you can use minimax to optimize Min (Max (Min ...))
12:21:17 <edwardk> =)
12:21:25 <edwardk> er alphabeta to improve on minimax that is
12:21:45 <kmc> zeiris, i don't know of a thing which does that
12:21:50 <kmc> you can {-# INLINE #-} definitions
12:21:53 <kmc> and they might get constant-folded
12:22:02 <kmc> i don't know what happens if it tries to constant-fold an exceptional value
12:22:09 <Gracenotes> oh, them AI things always popping up.. ;.;
12:22:34 <edwardk> but i'm not to sure how often folks will want to query on splitAt (maxT (minT (maxT (bytes 4) (chars 5)) (extra 3)))
12:22:42 <Gracenotes> there's also RULES, which not so much as precalculates as uncalculates
12:22:48 <edwardk> =)
12:23:15 <edwardk> zeiris: {-# LANGUAGE TemplateHaskell #-} ;)
12:23:16 <kmc> and SPECIALIZE, which might enable some extra inlining / etc
12:23:27 <kmc> zeiris, all the pragmas are listed here: http://www.haskell.org/ghc/docs/latest/html/users_guide/pragmas.html
12:23:44 <edwardk> you can then reflect the value back into an abstract syntax tree representation
12:23:54 <kmc> zeiris, do you have a specific bug relating to Dynamic that you are trying to fix?
12:24:25 <edwardk> gershom uses that approach in jmacro to construct javascript ADTs at compile time based on quasiquotation and then turning them into runtime trees
12:24:34 <zeiris> kmc: I'm trying to get the benefit of the type system by catching Dynamic screwups where I dynamic-ize the wrong type that my program isn't meant to handle, at compile time rather than runtime.
12:25:29 <kmc> zeiris, well, the whole point of Dynamic is to push typechecking to runtime... perhaps you should draw the line between statically and dynamically typed parts of you program in a different place
12:25:49 <zygoloid> huh, a police box
12:26:44 <edwardk> now the quirky thing is the thresholds, which i'm just now getting my head around also have a nice way to be viewed in terms of a galois connections. you have 3 monotonically increasing functions, each having mappings onto the others.
12:26:47 <zeiris> I want to shorten the syntax as much as humanly possible :( For example I'd like to use (min,max) for range, and [min,...,max] for sparse range, and have them be the same type, without resorting to a new data type. Which would add at least two characters, and THREE keystrokes to each definition.
12:27:07 <edwardk> with 'bytes' being the finest grain, and the others being abstractions over that
12:27:18 * hackagebot wxhnotepad 1.1.0 - An example of how to implement a basic notepad with wxHaskell  http://hackage.haskell.org/package/wxhnotepad-1.1.0 (FernandoBenavides)
12:27:32 <kmc> zeiris, then you can make a single representation type for ranges, and a typeclass for coercing those values to it
12:28:27 <edwardk> so it makes sense to order the resulting threshold so that the first thing you do is test for any byte-based inhabitants to get a firm 'alpha' for alphabeta
12:28:36 <edwardk> but i think now i'm just being silly
12:29:08 <edwardk> (also because in most cases chars = bytes, and extras = 0)
12:30:12 <zeiris> kmc !!!!!!!!!!!!!!!!!
12:30:35 <zygoloid> zeiris: can you hpaste an example of what you'd like to wrote?
12:30:36 <zygoloid> *write
12:30:42 <kmc> zeiris !!!!!!!!!!!!!!!!!
12:31:37 <kmc> zeiris, i think Haskell is not a great language for optimizing every keystroke of your program's concrete syntax
12:32:07 <kmc> but you can do pretty well
12:32:17 <zeiris> I'm trying to write a bit-packed, byte boundary unaligned parser/unpacker... That elegantly handles a poorly known protocol (and thus has range sanity checks) which is in the process of being reverse engineered (provides ability to partially parse/lookahead for possible positions).
12:32:28 <kmc> ooh, sounds like a fun project
12:32:32 <kmc> and a bit of a challenge
12:33:14 <zeiris> I've been giving this thing a prod every few months for a year or two now. Started in C, moved to Python, now trying to move to Haskell. This typeclass thinger has potential!
12:35:34 <zeiris> Oh yeah, and I also need to handle future parsing depending on past parsed values. (I realize this probably has significant overlap with Parsec, but I don't know about range checking, and since the protocol is quite complex I figure I'm better off specializing a DSL to the task.)
12:36:06 <kmc> if you do need absolute control over your DSL's syntax, the solution is to make it not embedded
12:36:22 <zeiris> Has crossed my mind, but a bit beyond my ability.
12:36:41 <kmc> it's not as hard as most people think
12:36:57 <kmc> but it is significant extra work versus an EDSL
12:37:00 <zeiris> From reading Parsec tutorials, yes, but I'm so close with what I've got now I might not need it :)
12:38:12 <elly> @src liftM2
12:38:12 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
12:39:49 <kmc> zeiris, LISP is traditionally the king of DSLs because the line between embedded and non-embedded is very thin
12:40:25 <zeiris> Yeah, the thing I'm doing is an obvious "data is code" so a language where code is data would make an embarassing amount of sense.
12:40:57 <FliPPeh_> How can I test if a string is within a string?
12:40:57 <zeiris> However, I don't feel a particular urge to learn pure LISP, and while I'd love to learn a newer variant (preferably one that takes a lot from erlang) I haven't figured out which one that is.
12:41:04 <FliPPeh_> general for lists, that is
12:41:08 <kmc> zeiris, probably Clojure
12:41:14 <FliPPeh_> "blah" `isPartOf` "blah blah"
12:41:16 <kmc> it's also worth knowing Scheme just because it's beautiful
12:41:25 <Lemmih> FliPPeh_: isInfixOf
12:41:43 <FliPPeh_> > "haskell" `isInfixOf` "I like haskell"
12:41:44 <lambdabot>   True
12:41:45 <FliPPeh_> :)
12:41:46 <FliPPeh_> Thanks!
12:41:47 <zeiris> I need to sit down and figure out their similarities/differences one day. I get confused by all them ClosureSchalaScheme variations.
12:41:58 <kmc> if you want to get fancy, you can make your non-E DSL compile to Haskell code, either "externally", or through Template Haskell and GHC's quasiquotation extension
12:42:10 <jmcarthur> @src isInfixOf
12:42:10 <lambdabot> isInfixOf needle haystack = any (isPrefixOf needle) (tails haystack)
12:42:13 <Philippa> zeiris: what does your DSL do that Parsec's EDSL doesn't?
12:42:35 <kmc> TH is the macro / "code is data" system for Haskell, but it's much more involved than LISP macros (and also a bit cleaner)
12:43:50 <zeiris> Philippa, I'm not using a DSL yet. So far the most obvious benefit is incorporating data endianness cleanly and using : and \ in the syntax... And possibly shorter definitions in general.
12:43:55 <kmc> hmm i think isInfixOf is probably quite slow
12:44:02 <jmcarthur> me too
12:44:11 <jmcarthur> not one of the nice substring search algorithms
12:44:56 <jmcarthur> i think the first algorithm i ever wrote in haskell was boyer-moore
12:45:03 <Philippa> mmm, you'd need a longer way of specifying endianness in Parsec simply because Haskell doesn't have unary operators
12:45:17 <Philippa> well, you can make prefix work if you don't mind using an ordinary identifier
12:47:04 <jmcarthur> there is also a PostfixOperators extension
12:47:14 <jmcarthur> but i believe it requires parentheses anyway, like sections
12:48:53 <Twey> Yeah
12:51:41 <zeiris> So far my plan is to do something like structure = [Packet # 8 << [0x9c,0x9d], Action # 8 << (0,15), ...] to define structure. Then use that to parse a ByteString into a Map Key Value, with some form of error handling if the ranges fail.
12:52:36 <zeiris> I don't think it can get much better than that, if # and << produce some Structure data type. Which is either a chunk to be parsed, or a Repeat whileFunc chunk, or a Conditional condFunc chunk.
12:55:01 <elly> Is it normal to wish 'Either' was a monad when writing a typechecker?
12:55:13 <FauxFaux> There's a Maybe monad!
12:55:25 <fax> elly yes
12:55:33 <zeiris> Is there a way to make Either a monad?
12:55:42 <fax> well it must mean   Either a
12:55:53 <fax> for some a that is not necessarily 'Error'
12:56:14 <elly> fax: yes, but I want to return an error message - I want Either Type String
12:56:23 <fax> Either String Type
12:56:23 <kmc> elly, it goes the other way
12:56:25 <kmc> error on the Left
12:56:28 <elly> right now I'm just handing back None, which is not very applicable
12:56:31 <elly> ah, okay
12:56:32 <kmc> because you want (Either ErrorType) to be the monad
12:56:40 <elly> ...oh, I see
12:56:57 <elly> do I need to write the instance for that myself, or is it in the libraries somewhere?
12:57:01 <kmc> http://www.haskell.org/ghc/docs/6.10-latest/html/libraries/mtl/Control-Monad-Error-Class.html
12:57:09 <maurer_> Does anyone know a good strategy for debugging NaN errors in Haskell? In other languages I've always just printed things out mid evaluation repeatedly, found the transition to NaN, etc.
12:57:20 <kmc> hi maurer_ :)
12:57:27 <elly> aha, awesome - thanks kmc :)
12:57:30 <kmc> you can use Debug.Trace
12:58:23 <maurer_> kmc: Cool, I'll try that.
12:59:07 <kmc> you can also turn on fp exceptions so you get a SIGFPE
12:59:13 <kmc> but then you've got to track this down
13:03:23 <elly> Hrm. I don't understand Error and MonadError correctly, apparently; it's still not clear how to structure this.
13:04:11 <elly> typecheck :: Expr -> Type right now, and it's not clear what the real type should be
13:05:38 <jlouis> elly: what is the type of an Error?
13:06:05 <elly> I don't know. I was going to make it typecheck :: Expr -> Either String Type, but... I don't understand Error.
13:07:41 <aavogt> elly: are you composing smaller pieces of this typechecker that may fail?
13:08:03 <aavogt> and the first failure you reach should abort the computation?
13:08:13 <elly> Yes; for example, when I typecheck a binop, either of the subexpressions may fail, or the binop itself may fail to typecheck
13:08:49 <aavogt> ok, then the MonadError (Either String) is good
13:09:22 <elly> so typecheck :: Expr -> MonadError (Either String Type)? o_O
13:09:59 <aavogt> MonadError is a class that  (Either String Type)  is a member of
13:10:07 <elly> oh, I see
13:10:09 <elly> hrm.
13:10:13 <fax> basically
13:10:27 <fax> the built in monad instace for Either is broken and evil and educated stupid
13:10:40 <fax> the best thing to do is discard it and implement/use a better version
13:10:54 <FliPPeh_> I want to read a file using readFile, how do I instatly put it into "Just ..." on success or "Nothing" on failure?
13:11:36 <elly> typecheck :: Expr -> Either String Type, then I have a typecheck' = liftM typecheck :: (Monad m) => m Expr -> m (Either String Type)?
13:11:40 <FliPPeh_> When the exception happens, I can not just return "Nothing", because it would be a simple string if it wouldn't fail
13:11:43 <kmc> FliPPeh_, failure meaning IO error?
13:11:52 <FliPPeh_> kmc: Yep
13:12:08 <FliPPeh_>  s <- (readFile $ src) `catch` (\e -> return "")
13:12:11 <FliPPeh_> That works
13:12:17 <FliPPeh_> Because the error return is a string, too
13:12:43 <kmc> @type Control.Exception.try
13:12:44 <lambdabot> forall a e. (GHC.Exception.Exception e) => IO a -> IO (Either e a)
13:12:58 <Asztal> yep, I'd use try
13:13:04 <FliPPeh_> Thanks :)
13:13:25 <kmc> @type either (const Nothing) Just . Control.Exception.try
13:13:26 <lambdabot>     Couldn't match expected type `Either a1 a'
13:13:26 <lambdabot>            against inferred type `IO (Either e a2)'
13:13:26 <lambdabot>       Expected type: IO a2 -> Either a1 a
13:13:48 <kmc> @type \m -> either (const Nothing) Just <$> Control.Exception.try m
13:13:49 <lambdabot>     Ambiguous type variable `a' in the constraint:
13:13:49 <lambdabot>       `GHC.Exception.Exception a'
13:13:50 <lambdabot>         arising from a use of `Control.Exception.Base.try'
13:16:08 <FliPPeh_>    s <- try (readFile src) :: IO (Either IOError String)
13:16:08 <FliPPeh_>    return $ either (const Nothing) (Just) s
13:16:11 <FliPPeh_> Pretty nice
13:16:12 <FliPPeh_> Thanks :)
13:19:20 <stulli> In the Maybe monad, (>>=) is defined like (Just x) >>= f = f x. Why can't i write (Just x) >>= f = Just x? (It might not make sense, but it should at least compile?)
13:19:30 <jmcarthur> @hoogle Either a b -> Maybe b
13:19:30 <lambdabot> Data.Typeable typeOf2 :: Typeable2 t => t a b -> TypeRep
13:19:31 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
13:19:31 <lambdabot> Data.Either either :: (a -> c) -> (b -> c) -> Either a b -> c
13:20:02 <jmcarthur> stulli: wrong type
13:20:49 <jmcarthur> stulli: the type of (>>=) :: m a -> (a -> m b) -> m b, but your definition has type (>>=) :: m a -> (b -> c) -> m a
13:21:31 <jmcarthur> stulli: the (b -> c) part would bind fine, but the (m a) at the end is problematic
13:22:07 <stulli> jmcarthur: Why? I thought f is of type (a -> m b) and if i don't use it on the right side it should be irrelevant?
13:22:15 <Lemmih> stulli: Consider: Just 2 >>= (Just . odd)
13:22:26 <zong_sharo> does 6.12 implements support for equality constraints in superclass contexts?
13:22:27 <jmcarthur> stulli: it is. the (m a) at the end is the problem
13:22:34 <jmcarthur> stulli: Just x :: m a
13:22:46 <zong_sharo> i looked into release notes, but didnt found anything on subject
13:22:56 <stulli> and it should be m b?
13:23:23 <Lemmih> stulli: Said expression evaluates to 'Just False'. Replacing it with 'Just 2' would be a type error.
13:23:41 <zong_sharo> i mean, http://haskell.org/haskellwiki/Type_families#Equality_constraints <- this feature
13:24:21 <Lemmih> > Just 2 >>= (Just . odd)
13:24:22 <lambdabot>   Just False
13:24:24 <Lemmih> > Just 2 `asTypeOf` (Just 2 >>= (Just . odd))
13:24:25 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
13:24:25 <lambdabot>    arising from the literal `2'...
13:24:58 <stulli> Ah, i think i get it now. Let me think about it some more.
13:33:05 <sm> poll: what would be appropriate use of the module namespace by a repackaged hledger ? What about Finance.Hledger.* for the app, Data.Ledger.* for the data types & utils ?
13:35:07 <lispy> sm: sigbjorn's code will often have a .Types module under the same hierarchy, and it seems to work well
13:36:01 <lispy> sm: I was going to say look here for an example, but it doesn't appear to show it: http://hackage.haskell.org/package/HTTP
13:36:16 <sm> I get you.. thanks for the idea
13:36:21 <stulli> Lemmih, jmcarthur: I understand now. Many thanks for your help!
13:37:44 <lispy> sm: FWIW, I tend to think of Data.* as general purpose data structures
13:40:31 <sm> hi Feuerbach
13:41:23 <Feuerbach> hi sm
13:42:16 <sm> I was just kicking around hledger packing ideas.. any thoughts ?
13:43:07 <Feuerbach> I just discovered the email :)
13:43:38 <Feuerbach> let's move to #ledger probably?
13:43:53 <Trinitron> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24131#a24131 Can someone memoise this for me please. I have no clue.
13:43:55 <sm> ok
13:44:06 <artzz> hi everyone again
13:44:11 <sm> s/packing/packaging/
13:44:25 <FliPPeh_> @hpaste
13:44:26 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
13:44:51 <artzz> I have another probably silly question... I want a function (not 'head') that takes ["hi","there","now"] and returns "hi", I thought this my work but doesnt: myfunc [x:xs] = x
13:44:58 <artzz> is there a way to express it that way?
13:44:59 <FliPPeh_> Can you help me make this code a little bit better: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=8716#a8716 ?
13:45:04 <FliPPeh_> It works, but it just looks ugly
13:45:24 <FliPPeh_> It scans a whole HTML source for a form tag, get the value of the action attribute and return it
13:45:51 <stulli> artzz: It's probably myfunc (x:xs) = x
13:46:22 <FliPPeh_> > let myfunc (x:xs) = x in myfunc "Hello"
13:46:23 <lambdabot>   'H'
13:46:37 <artzz>  stulli: yes.. I think I get it now
13:46:44 <artzz> stulli: is it because otherwise I was 'deconstructing' the array?
13:46:56 <FliPPeh_> I think that's just how it works
13:47:26 <stulli> Yeah, it's syntax i think
13:47:58 <Trinitron> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24131#a24131 Can someone memoise this for me?
13:48:01 <Trinitron> please
13:48:29 <kmc> Trinitron, did you see data-memocombinators?
13:48:34 <Trinitron> does lisp automagically memoise functions?
13:48:42 <kmc> don't think so
13:48:47 <kmc> LISP function application can have side effects
13:48:47 <Twey> LINAL
13:48:56 <kmc> and it's not clear statically which ones do
13:49:06 <Trinitron> someone told me lisp is better than haskell for recursion
13:49:18 <Twey> > let notHeadHonest = (x : _) = x in notHeadHonest ["hi", "there", "now"]
13:49:19 <lambdabot>   <no location info>: parse error on input `='
13:49:19 <kmc> hahaha
13:49:24 <Twey> Heh, oops
13:49:30 <Twey> > let notHeadHonest (x : _) = x in notHeadHonest ["hi", "there", "now"]
13:49:31 <lambdabot>   "hi"
13:49:40 <Twey> > let notHeadHonest = head in notHeadHonest ["hi", "there", "now"] -- >.>
13:49:42 <lambdabot>   "hi"
13:49:51 <Twey> Trinitron: Hahahaha
13:50:02 <kmc> it's not funny because it's right or wrong
13:50:10 <Twey> It's funny because it's insane
13:50:40 <kmc> @quote techniques
13:50:41 <lambdabot> VerityStob says: Lisp is still #1 for key algorithmic techniques such as recursion and condescension.
13:50:44 <FliPPeh_> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=8716#a8716
13:50:46 <FliPPeh_> This is too ugly :
13:50:47 <FliPPeh_> :(
13:50:54 <FliPPeh_> How can I clean it up?
13:51:10 <Twey> kmc: Hahaha
13:53:39 <Twey> FliPPeh_: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=8716#a8717
13:53:48 <Twey> listToMaybe from Data.Maybe
13:54:26 <FliPPeh_> Oh nice
13:54:26 <Trinitron> in  (map fib [0 ..] !!) what's that mean?
13:54:26 <FliPPeh_> :)
13:54:40 <FliPPeh_> Thanks a bunch twey
13:54:44 <Trinitron> http://www.haskell.org/haskellwiki/Memoization#Memoization_with_recursion
13:54:50 <Twey> 'course, those are now single-reference, so you can just search and replace them if you don't want the identifiers
13:55:18 <FliPPeh_> single reference?
13:55:18 <Twey> Trinitron: What does what mean?
13:55:22 <medfly> > [1..2] !! 1
13:55:23 <lambdabot>   2
13:55:25 <medfly> :]
13:55:41 <Trinitron> [0..]
13:55:45 <Trinitron> > [0..]
13:55:46 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
13:56:03 <Twey> !! is an operator that gives you the specified element of a list (zero-indexed).  map is a function that applies a function to every element of a list.  [0 ..] is a list from zero to infinity.  fib is presumably a function for calculating Fibonacci numbers.
13:56:08 <medfly> yea but it's like take the n-th fib number:)
13:56:25 <Trinitron> ahh
13:56:26 <Twey> FliPPeh_: You've got names that are only ever referenced once
13:56:30 <Trinitron> so work from 0 up
13:56:37 <Twey> FliPPeh_: So they're strictly superfluous
13:56:39 <Trinitron> rather than the number
13:56:44 <Trinitron> input
13:56:45 <Twey> Whether you want to keep them for readability is a style decision
13:57:20 <kmc> Trinitron, did you see data-memocombinators?
13:57:23 <Trinitron> no
13:57:27 <FliPPeh_> Mhh
13:57:29 <kmc> Trafalgard, http://hackage.haskell.org/package/data-memocombinators
13:57:32 <kmc> sorry Trafalgard
13:57:34 <kmc> meant Trinitron
13:57:41 <kmc> Trinitron, this is probably the right way to memoize your thing
13:57:47 <Twey> Oh, I screwed up a bit, too, I think
13:57:55 <FliPPeh_> Twey: A thing I just noticed in your code, it's real type is "String -> Maybe (Maybe String)"
13:58:03 <kmc> Trinitron, there's also http://hackage.haskell.org/package/MemoTrie
13:58:04 <FliPPeh_> Instead of just "Maybe String"
13:58:15 <Trinitron> errr how do I install it
13:58:20 <Trinitron> I've never installed a package before
13:58:35 <kmc> cabal install data-memocombinators
13:58:42 <kmc> presuming you have Haskell Platform, that should work
13:59:22 <Trinitron> I have to cabal update first
13:59:24 <Twey> FliPPeh_: Yeah  I should have put a join or bind in there
13:59:39 <fax> when it comes to category theory, I'm one of those stupid twerps that keeps saying "Why are you just using complicated names for simple stuff to confuse people"
14:00:20 <Trinitron> wow cabal is cool
14:00:24 <Trinitron> like apt-get
14:00:27 <Trinitron> almost
14:00:45 <Adamant> I think category theory is an interesting way of looking at things, but the names of morphisms are kind of goofy, yeah.
14:00:48 <Twey> fax: They're not so complicated if you know a little Latin and Greek ;)
14:00:57 <kmc> yeah, Haskell has all these complicated names for simple stuff... i'll stick with my C++-based abstract virtual method factory visitor pattern, thankyouverymuch
14:00:58 <Twey> (mostly Greek)
14:00:58 <Adamant> or not so little amount
14:01:06 <Twey> kmc: Hahaha
14:01:13 <fax> oh I don't mean that
14:01:14 <Trinitron> Ok I installed data-memocombinators
14:01:20 <Trinitron> is there a tutorial?
14:01:41 <kmc> Trinitron, the doc on hackage is pretty clear i think
14:01:43 <kmc> we can help too
14:02:09 <Adamant> kmc: you would stand a better chance of figuring out what that actually is if it actually existed
14:02:10 <Adamant> :P
14:02:34 <kmc> "catamorphism" and "hylomorphism" are pretty silly, yes
14:02:47 <kmc> but i think we say "fold" and "map" more often, except in theoretical contexts
14:03:17 <Adamant> yeah, this is not about Haskell directly, but cat theory in general
14:03:17 <FliPPeh_> :t bind
14:03:18 <lambdabot> Not in scope: `bind'
14:03:21 <FliPPeh_> :t join
14:03:22 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
14:03:41 <FliPPeh_> join (Just 4)
14:03:43 <FliPPeh_> Y join (Just 4)
14:03:45 <FliPPeh_> > join (Just 4)
14:03:46 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe a))
14:03:46 <lambdabot>    arising from the lite...
14:03:55 <FliPPeh_> > join (Just (Just "hi"))
14:03:56 <lambdabot>   Just "hi"
14:04:03 <FliPPeh_> @src join
14:04:04 <lambdabot> join x =  x >>= id
14:05:01 <Twey> FliPPeh_: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=8716#a8718
14:05:40 <Twey> FliPPeh_: >>= is called bind
14:05:53 <FliPPeh_> Oh yeah that
14:05:55 <FliPPeh_> :)
14:06:21 <FliPPeh_> Man, this depresses me
14:06:30 <FliPPeh_> I'm never able to write such compact stuff
14:06:48 <Twey> You will
14:06:52 <Twey> It's all in the typeclasses
14:07:11 <Twey> Go and read typeclassopedia or something
14:08:49 <FliPPeh_> The Monad Rader Issue 13?
14:08:52 <Twey> Yes
14:09:00 <FliPPeh_> I'll have a look at it
14:09:02 <FliPPeh_> :)
14:09:02 <Twey> Specifically, the article entitled Typeclassopedia
14:11:03 <FliPPeh_> :t (***)
14:11:04 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
14:11:07 <FliPPeh_> Whee
14:11:41 <FliPPeh_> That article looks great
14:11:52 * FliPPeh_ stuffs it on the top of his to-read list
14:12:02 <FliPPeh_> That means: minimize and read it in a few minutes
14:13:30 <byorgey> FliPPeh_: let me know if you have questions =)
14:14:18 <FliPPeh_> byorgey: Alright, I'll also provide some feedback when I've read it!
14:14:54 <byorgey> great.  I'm actually planning to put out a standalone second edition, hopefully sometime later this spring
14:22:34 * ologNation is implementing graph from scratch. 
14:22:51 <Janni> Hi. Can anybody tell me why cabal-install doesn't select the newest package available. If I for example do "cabal install parsec" it attempts to install 2.1.0.3 (which it considers the "Latest version available" according to "cabal list") instead of parsec-3.1.0 which I would like.
14:23:24 <FliPPeh_> You can force the version to install
14:23:38 <FliPPeh_> "cabal install parsec>=3.0" I think
14:24:00 <Janni> Yes, but wouldn't it be silly to go visit hackage.haskell.org each time to check which version is really the newest one?
14:24:17 <kniu> :pl (\x -> x * x)
14:24:20 <FliPPeh_> The newest version might still be unstable
14:24:21 <Janni> Is it a bug in cabal-install, or a feature I don't understand?
14:24:25 <[swift]_> when i try to explain what functional programming is to others, i want to say that at its core, it is using pure functions and immutable data structures. what always makes me stumble is that lisp, which many people think of as the archetypical functional programming language, isn't pure and has mutable data structures! is my idea of what functional programming is wrong?
14:24:33 <ClaudiusMaximus> cabal install has some hardcoded default versions for a few packages, including parsec
14:24:46 <kniu> :pf (\x -> x * x)
14:24:47 <zong_sharo> is there any way to put existential quantificator in typeclass context?
14:24:50 <Janni> I see...
14:24:54 <FliPPeh_> [swift]_: Not really, Lisp is no PURE functional language, like Haskell is
14:24:55 <sm> Janni: add -v2 or 3 and it might explain why
14:24:58 <kniu> :pl (\x -> x * x)
14:25:02 <kniu> > pl (\x -> x * x)
14:25:03 <lambdabot>   Not in scope: `pl'
14:25:03 <Janni> Thx.
14:25:32 <kniu> how do I use pointless in lambdabot?
14:25:46 <Kagami`> @pl (\x -> x * x)
14:25:46 <[swift]_> FliPPeh_: the distinction seems odd though; in what sense is an impure functional language functional at all?
14:25:47 <lambdabot> join (*)
14:25:51 <kniu> oho kay
14:25:59 <kniu> :t join
14:26:00 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
14:26:24 <kmc> i think "functional language" and "functional programming" mean two very different things
14:26:38 <kmc> "functional language" means a language that supports first-class functions
14:26:43 <kmc> which is any good general-purpose language
14:27:09 <ClaudiusMaximus> to me (i'm not an expert) functional means you can create (possibly anonymous) functions and pass them around easily
14:27:30 <FliPPeh_> ClaudiusMaximus: Even the next C revision will include anonymous function :/
14:27:39 <kmc> "functional programming" is a style of programming you can do in any language with first-class functions, and very painfully in those without (but people do, see: Boost)
14:27:54 <zong_sharo> closures?
14:28:02 <kmc> but not every program in a "functional language" is written in functional-programming style; even in Haskell
14:28:11 <kmc> the sense in which Haskell is "pure" functional programming is a very technical one
14:28:23 <kmc> it means that the beta-reduction of function application does not cause a side effect
14:28:32 <[swift]_> kmc: thanks, that distinction makes sense
14:28:41 <kmc> we have other ways to represent effects.  whether or not you use effects pervasively is a question of style even in Haskell
14:29:28 <kmc> you can write very effectful imperative Haskell code, and sometimes it's even the right thing to do, and first-class functions are quite useful for doing this right
14:29:57 <kmc> "functional vs. imperative" is a false dichotomy rooted in some design flaws of C++ and Java in particular, and not in any more fundamental property
14:30:35 <[swift]_> kmc: thanks, you've really help me understand this better
14:30:38 <kmc> :)
14:32:51 <zong_sharo> i'm usings somewhat poor man's equality constraint
14:32:54 <zong_sharo> in way like
14:33:22 <zong_sharo> instead of: class (Foo a, Foo b, FooAssociated a ~ FooAssociated b) => ...
14:33:27 <zong_sharo> stuff like
14:33:47 <zong_sharo> class (Foo a (FooAssociated a), Foo b (FooAssociated a)) => ...
14:33:59 <fax> ??
14:34:02 <fax> why
14:34:05 <zong_sharo> but, now i've got second typeclass parameter
14:34:14 <zong_sharo> cos equality constraints still not implemented
14:34:31 <fax> qwhat about
14:34:38 <fax> data Eq x y where  REFL :: Eq x x
14:34:49 <zong_sharo> and, i'm don't need (FooAssociated a) on the right side of class expression
14:35:52 <kmc> class Eq a b; instance Eq a a
14:35:57 <zong_sharo> i'm just need to be sure, that both have Foo instance with same FooAssociated type
14:36:25 <zong_sharo> but, now i've got second typeclass parameter, and i forced to wrap it in (FooAssociated blah) everywhere
14:36:31 <fax> kmc woah
14:36:33 <fax> does that work?
14:36:44 <zong_sharo> cos i don't find out gow to use forall in typclass context
14:36:48 <zong_sharo> yeah, it's works
14:37:34 <zong_sharo> so, for example, Foo a elevatedAssociatedType | a -> elevatedAssociatedType
14:38:03 <zong_sharo> and, in context it goes: class Foo a (Associated a) => ...
14:38:08 <zong_sharo> kinda boring
14:38:23 <zong_sharo> is there no way to use forall in the class context?
14:38:27 <zong_sharo> for sure?
14:38:47 <rothwell> hm... any idea how to tell quickcheck that i want to pass (x, y, z) to a property, where x <= y <= z?
14:38:55 <rothwell> the documentation's a bit sparse
14:39:04 <zong_sharo> or, from the other side
14:39:26 <zong_sharo> is there any way to relax requirement to use every type variable from context on the right side of expression?
14:40:39 <zong_sharo> huh?
14:41:58 <McManiaC> is there a way to catch *all* exceptions? or is that what IOException is for?
14:42:15 <McManiaC> will that catch something like PatternMatchFail etc?
14:42:22 <kmc> McManiaC, catch SomeException
14:42:38 <zong_sharo> McManiaC: http://www.haskell.org/ghc/docs/6.12.1/html/libraries/base/Control-Exception.html#4
14:42:54 <McManiaC> oh
14:42:56 <McManiaC> righto :)
14:46:05 <ClaudiusMaximus> @hoogle (==>)
14:46:05 <lambdabot> Test.QuickCheck (==>) :: Testable a => Bool -> a -> Property
14:48:07 <ClaudiusMaximus> @check \x y z -> 0 <= x && x <= y && y <= z ==> x^2 <= z^2
14:48:08 <lambdabot>   No instance for (Test.QuickCheck.Testable
14:48:08 <lambdabot>                     (Test.QuickCh...
14:48:36 <ClaudiusMaximus> @more
14:48:45 <ClaudiusMaximus> :(
14:49:23 <Axman6> @check \x y z -> 0 > x  x <= y && y <= z ==> x^2 <= z^2
14:49:24 <lambdabot>   Precedence parsing error
14:49:24 <lambdabot>      cannot mix `GHC.Classes.>' [infix 4] and `GHC...
14:49:26 <Axman6> urgh
14:49:52 <Axman6> @check \x y z -> 0 > x || x > y || y <= z || x^2 <= z^2
14:49:53 <lambdabot>   "Falsifiable, after 6 tests:\n1\n2\n0\n"
14:50:08 <Axman6> @check \x y z -> 0 > x || x > y || y > z || x^2 <= z^2
14:50:09 <lambdabot>   "OK, passed 500 tests."
14:50:20 <Guest16859> @check (< 10000)
14:50:21 <lambdabot>   "OK, passed 500 tests."
14:50:50 <Axman6> :o
14:51:02 <Trinitron> How do I use Data.MemoCombinators for a function that curries two arguments?
14:51:20 <Trinitron> ie pal x y
14:51:27 <Guest16859> @check (not . isPrefixOf "To be, or not to be, that is the question: ")
14:51:28 <lambdabot>   "OK, passed 500 tests."
14:51:36 <Baughn> Trinitron: uncurry it first
14:51:55 <Trinitron> aren't all functions curried by default?
14:51:59 <Baughn> Yes
14:52:04 <Trinitron> if I say pal x y = x + y
14:52:11 <Baughn> That's curried, yes.
14:52:12 <Axman6> :t unvurry
14:52:12 <lambdabot> Not in scope: `unvurry'
14:52:13 <Axman6> :t uncurry
14:52:14 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
14:52:22 <Baughn> What you'd want is pal (x,y) = x + y, which uncurry gets you
14:52:33 <Axman6> @src uncurry
14:52:33 <lambdabot> uncurry f p = f (fst p) (snd p)
14:52:34 * ddarius doesn't think "curried by default" is the appropriate way to say that.
14:53:17 <jmcarthur> @check \x y z -> let [a,b,c] = sort [x,y,z] in a^2 <= c^2
14:53:18 <lambdabot>   "Falsifiable, after 1 tests:\n0\n-2\n-1\n"
14:53:30 <Baughn> True. It's more accurate to say "multi-parameter functions are normally written using currying", or "programmers use currying by default"
14:53:39 <jmcarthur> @check \x y z -> let [a,b,c] = sort [x,y,z] in (abs a)^2 <= (abs c)^2
14:53:40 <lambdabot>   "Falsifiable, after 0 tests:\n-2\n-1\n0\n"
14:53:46 <Baughn> The /language/ can't be said to have a default
14:53:49 <Axman6> @check \x y z -> let [a,b,c] = sort [x,y,z] in a^2 <= (c^2 :: Word64)
14:53:49 <lambdabot>   No instance for (Test.QuickCheck.Arbitrary GHC.Word.Word64)
14:53:49 <lambdabot>    arising from...
14:53:54 <Axman6> @check \x y z -> let [a,b,c] = sort [x,y,z] in a^2 <= (c^2 :: Word)
14:53:54 <lambdabot>   No instance for (Test.QuickCheck.Arbitrary GHC.Word.Word)
14:53:55 <lambdabot>    arising from a...
14:53:57 <Axman6> :o
14:54:05 <jlouis> hah!
14:54:13 <jlouis> Axman6: Multi-torrent support, yay!
14:54:16 <Vanadium> > let fst = uncurry const ; snd = uncurry (flip const) ; foo = (42, "wooh") in (snd foo, fst foo)
14:54:17 <Baughn> @check \x y -> x == y
14:54:17 <lambdabot>   ("wooh",42)
14:54:18 <lambdabot>   "OK, passed 500 tests."
14:54:18 <Axman6> i saw :D
14:54:57 <jlouis> I should merge it
14:55:08 <Vanadium> @check \x y -> abs (x - y) > 0.1
14:55:09 <lambdabot>   "Falsifiable, after 0 tests:\n0.0\n0.0\n"
14:55:12 <Vanadium> aw
14:55:29 <Trinitron> Or I don't need to use uncurry and just use a tuple
14:55:45 <Trinitron> pal (x,y) = x + y?
14:55:50 <Baughn> @check \x -> x / 3 * 3 == x
14:55:51 <lambdabot>   "Falsifiable, after 30 tests:\n-3.1\n"
14:56:12 <Trinitron> > pal (x,y) = x + y; pal(1,2)
14:56:13 <lambdabot>   <no location info>: parse error on input `='
14:56:15 <Baughn> > -3.1 / 3 * 3
14:56:16 <lambdabot>   -3.1000000000000005
14:56:29 <Axman6> Trinitron: let ... in ...
14:56:38 <Baughn> @check \x -> x / 2 * 2 == x
14:56:39 <lambdabot>   "OK, passed 500 tests."
14:56:48 <Trinitron> > let pal (x,y) = x + y in pal(1,2)
14:56:49 <FliPPeh_> > fmap reads (Just "4") :: Maybe [(Int, String)]
14:56:49 <lambdabot>   3
14:56:50 <lambdabot>   Just [(4,"")]
14:57:02 <Trinitron> so that counts as one argument?
14:57:02 <FliPPeh_> How can I make it so it just says either "Just 4" or "Nothing"?
14:57:04 <FliPPeh_> > fmap reads (Just "4") :: Maybe [(Int, String)]
14:57:05 <lambdabot>   Just [(4,"")]
14:57:09 <Trinitron> the (x,y)
14:57:20 <Axman6> yes
14:57:51 <Trinitron> that's different from an array isn't it?
14:57:56 <Trinitron> array (1,2)
14:57:59 <ologNation> Should I use Data.Set?
14:58:05 <Axman6> array is just a function
14:58:05 <ologNation> Or should I implement it from scratch?
14:58:11 <Axman6> they're all just functions
14:58:40 <kmc> Trinitron, what's different from an array?
14:58:41 <Axman6> ologNation: why would you make a less efficient version of something you've already got free access to?
14:59:00 <kmc> Trinitron, to memoize a function of two args use memo2
14:59:11 <kmc> Trinitron, to memoize a function of one arg which is a pair, use pair
14:59:28 <Trinitron> memo2?
14:59:48 <Axman6> look at the docs for the memo combinators package
14:59:52 <kmc> http://hackage.haskell.org/packages/archive/data-memocombinators/0.4.0/doc/html/Data-MemoCombinators.html
15:00:10 <kmc> the types are very useful here
15:00:28 <kmc> read Memo a as "the type of memo table for function taking argument type a"
15:01:35 <Trinitron> pal = memo2.integral pal'
15:01:42 <Trinitron> ?
15:01:52 <Axman6> i don't think so
15:01:58 <kmc> where are you getting that?
15:02:05 <Trinitron> fib = Memo.integral fib'
15:02:12 <kmc> that's a qualified name
15:02:17 <Trinitron> I'm confused.
15:02:20 <kmc> read the whole section "Description"
15:02:38 <kmc> they import the module qualified so the function "integral" is named "Memo.integral"
15:02:50 <kmc> similarly if you import it qualified you will have Memo.memo2
15:03:01 <kmc> hmm, we typically think of purity as being necessary for laziness to work right.... data-memocombinators is an example where laziness is necessary for purity to work right :)
15:03:36 <Trinitron> pal = Memo.memo2 pal'
15:03:55 <kmc> Trinitron, look at the type of memo2
15:04:06 <kmc> memo2 takes two memo-tables *and* a two-arg function
15:04:12 <kmc> and gives you a memoized version of that function
15:04:46 <Axman6> you probably want memo2 integral integral pal'
15:04:49 <ologNation> Axman6, I got an error using Data.Set
15:05:07 <Axman6> ologNation: that means you're doing something wrong, bit that you should reinvent the wheel ;)
15:05:13 <ologNation> error: usesSet.o: In function `svq_info':
15:05:13 <ologNation> (.text+0x159): undefined reference to `__stginit_containerszm0zi2zi0zi1_DataziSet_'
15:05:16 <Axman6> uh, s/bit/not/
15:05:27 <Axman6> oh, you need to build it with --make
15:05:35 <ologNation> Oh yeah?
15:05:36 <Axman6> ghc --make Blah.hs
15:05:50 <djahandarie> YEAH
15:05:52 <Axman6> always use --make
15:06:38 * djahandarie brings intensity to the conversation
15:06:40 <kmc> got a linker error => reimplement the library yourself?
15:06:48 <kmc> that's an... interesting development strategy
15:07:01 <Axman6> aye
15:07:03 <kmc> i wish ghc would tell people to use --make whenever there's a linker error without it
15:07:13 <djahandarie> kmc, what? How else are you suppose to develop?
15:07:26 <kmc> copy paste the Data.Set code into your file
15:07:27 <kmc> of course
15:07:31 <djahandarie> Ah okay
15:07:32 <djahandarie> Yeah
15:07:32 <Trinitron> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24136#a24136
15:07:35 <kmc> that's called code reuse
15:07:36 <Trinitron> I'm still confused
15:07:41 <Trinitron> I tried
15:07:53 <kmc> Trinitron, memo2 is a function
15:08:01 <kmc> it takes three arguments: two memo tables and the function to memoize
15:08:16 <ologNation> Axman6, Thanks!
15:08:18 <kmc> so i don't understand why you put it third
15:08:23 <ologNation> Yeah.  I think Data.Set will work for me.
15:08:32 <kmc> memopal = Memo.memo2 Memo.integral Memo.integral pal
15:08:38 <kmc> note also the lower case on "Integral"
15:08:40 <djahandarie> Trinitron, maybe you should make yourself more familiar with Haskell using an easier example?
15:08:46 <ologNation> Axman6,  The reason I asked is because I was going to use Data.Graph
15:08:51 <ologNation> and everyone said "Don't use it!"
15:09:21 <Trinitron> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24137#a24137
15:09:31 <kmc> perhaps Trinitron is confused by what the Memo a type actually represents? it's not totally clear
15:09:49 <Axman6> no, the docs are somewhat lacking
15:09:53 <djahandarie> Well, if you don't want a lazy depth-first search or linear graph algorithm, Data.Graph probably isn't for you
15:10:13 <kmc> Trinitron, you still have Integral upper-case
15:10:18 * djahandarie sighs
15:10:22 <kmc> read the docs for data-memocombinator
15:10:29 <djahandarie> Alternatively, read anything
15:10:40 <kmc> i mean clearly you did read some of them, i don't mean to be a jerk
15:10:43 * djahandarie grumbles and goes somewhere else
15:10:49 <Axman6> Trinitron: the secret to using memoisation is to use the memoised version in all your recursive calls too, so in pal, you need to use mempal x (y+1)) for example
15:10:54 <kmc> but "Integral" is not defined there, and "integral" is
15:11:02 <Trinitron> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24138#a24138
15:11:04 <Trinitron> oh
15:11:28 <ologNation> It seems that (in Data.Set) Set a can only be defined for types a in the typeclass Ord a.
15:11:31 <ologNation> Why should that be?
15:11:40 <copumpkin> it's the only way to do it efficiently
15:12:02 <copumpkin> you could do it with Eq only, but it would either be inefficient or not enumerable
15:12:10 <Axman6> because it's an ordered set, makes implementation more efficient (a binary tree or finger tree or whatever it is requires some ordering)
15:12:14 <Trinitron> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24139#a24139
15:12:16 <djahandarie> ologNation, it usually isn't difficult to give a constraint for Ord
15:12:32 <djahandarie> Oops, was leaving
15:12:33 <ologNation> djahandarie, You mean, you could give a trivial one?
15:12:35 <Axman6> Trinitron: looks good
15:12:38 <Trinitron> ok
15:12:45 <Axman6> ologNation: it would be a bad idea
15:12:47 <djahandarie> ologNation, well, no, a pointless one would be... pointless
15:12:54 <ologNation> Okay, okay.
15:13:03 <ologNation> I'll go ahead with it. Thanks for the confidence.
15:13:11 <ologNation> I'm pretty excited about my little project by the way.
15:13:18 <copumpkin> what is it?
15:13:18 <ologNation> I'll tell you about it if it goes well.
15:13:28 <jlouis> A pumpkin AI!
15:13:38 <ologNation> copumpkin, Since you ask, I'm ... No.  Let's wait to see if it works.  It should just take a couple of days.
15:13:48 <ologNation> What's the name of the other haskell channel? Haskell-advanced or something?
15:13:54 <copumpkin> ok :)
15:13:59 <DigitalKiwi> who can tell me about mythryl and why it surely is inferior to haskell but why people would use it?
15:14:04 <copumpkin> #haskell-in-depth but it's a tomb
15:14:19 <Trinitron> oh yay
15:14:21 <Trinitron> it works!!!
15:14:32 <Trinitron> @quote works
15:14:32 <lambdabot> mikaeli says: My friend bought a new laptop; it had MSBLASTER preinstalled. I couldn't believe it either and installed XP and the apps many times, run virus killers and everytime the blaster came
15:14:33 <lambdabot> back. Everything was packed on a rescue cd. And virus was in m$ works installation files.
15:14:41 <stulli> I'm currently learning about monads and want to implement one of my own. Would you say this is a good candidate: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24140#a24140 ?
15:15:11 <jlouis> DigitalKiwi: I have not used mythryl at all, and I guess very few people have. Which make them unable to answer your question sufficiently
15:15:49 <monochrom> @quote reasoned
15:15:49 <lambdabot> ray says: when you're dealing with programmers you are often dealing with people who voluntarily use 1970s terminals. they cannot be reasoned with
15:15:55 <monochrom> DigitalKiwi: because of that
15:15:58 <Heffalump> stulli: I suspect not, because I guess from your function names that your monad will be constrained to act only on Strings or perhaps general lists of things.
15:16:00 <DigitalKiwi> I would read about mythryl myself and make a decision but i don't know that much about haskell to decide accurately  :(
15:16:01 <Axman6> stulli: not really, it would be easier if you were matching on the Maybe constructors i think (True and False aren't monads)
15:16:11 <kmc> DigitalKiwi, i am reading about it, but can't find any example code
15:16:21 <Heffalump> whereas without going into restricted monads, which are a rather advanced topic, a monad has to accept any argument type
15:16:35 <Cale> True and False aren't even type constructors, let alone being monads
15:16:38 <kmc> it sounds very similar to Haskell
15:16:58 <kmc> with the usual "Haskell is too radical, we will allow some side effects"
15:17:02 <kmc> as if Haskell had no way to represent effects
15:17:11 <copumpkin> data True a = Zomg
15:17:13 <Heffalump> I assume that the intended monad is to wrap up the computeNext and palindrome testing.
15:17:19 <copumpkin> there, no we can make it a monad
15:17:26 <stulli> Heffalump: yes
15:17:29 <copumpkin> *now
15:17:58 <Axman6> stulli: if you have them return Maybe Int, then you can use >>= to make things nice
15:18:11 <Axman6> so, isPalindrome :: Int -> Maybe Int
15:18:27 <stulli> Ok, thanks, i will look into it
15:18:28 <kmc> okay found some code
15:18:33 <Axman6> returns Nothing if it can't find a palindrome (this is somewhat contrived though)
15:18:39 <copumpkin> that seems like an odd type for an "is" function
15:18:54 <Axman6> yeah, i'd call it findPalindrome
15:18:57 <monochrom> so make it an "are" function
15:19:01 <Axman6> or something
15:19:16 <Twey> Why is it an Int?
15:19:32 <stulli> Twey: legacy ;)
15:19:32 <korsakow> hi
15:20:29 <kmc> Haskell would be much more popular if it were marketed as a pragmatic alternative to Haskell
15:20:45 <kmc> hi korsakow
15:20:55 <stulli> err, disregard my last comment
15:20:56 <Trinitron> is there a max fuction for 3 arguments
15:21:01 <Trinitron> like max3?
15:21:01 <Axman6> @remember kmc Haskell would be much more popular if it were marketed as a pragmatic alternative to Haskell
15:21:01 <lambdabot> It is stored.
15:21:01 <kmc> :t maximum
15:21:02 <lambdabot> forall a. (Ord a) => [a] -> a
15:21:23 <monochrom> FWIW, in HXT an "is" function such as "isText" has type XmlTree -> [XmlTree]. Very natural thing to do.
15:21:26 <Axman6> Trinitron: there is if you define one
15:21:36 <Trinitron> ok
15:21:59 <Axman6> @pl max3 a b c = max a (max b c)
15:21:59 <korsakow> q: what are practical uses for functional programming?
15:21:59 <lambdabot> max3 = (. max) . (.) . max
15:22:00 <DigitalKiwi> kmc: so what's the word on mythryl?
15:22:02 <kmc> "FooLang is like Haskell but supports first-class programming with effects, lightweight threads, software transactional memory, and can call your favorite C, Python, or Ruby libraries!"
15:22:21 <Axman6> korsakow: what aren't practical uses for functional programming? we use it for literally everything
15:22:46 <kmc> korsakow, not to claim that FP is synonymous with Haskell, but take a look at http://www.haskell.org/haskellwiki/Haskell_in_industry
15:22:47 <monochrom> programming are practical uses for functional programming
15:22:50 <Trinitron> err are fuctions taken as arguments to function written in the same notation as data variables?
15:22:52 <Axman6> from operating systems, to text editors, to high performance scientific computing, to web frameworks
15:23:04 <kmc> Trinitron, yes, a function is a value like any other
15:23:08 <Trinitron> ie max3 x y z = max x (max y z)
15:23:22 <DigitalKiwi> and window managers!
15:23:28 <Trinitron> Ah, my imperative education shows.
15:23:32 <Trinitron> damn C
15:23:33 <jlouis> and version control systems
15:23:36 <fax> oh woe is me
15:23:45 <kmc> Trinitron, what's it got to do with imperative?
15:23:46 <fax> I just realized my algorithm is not complete
15:23:54 <kmc> Trinitron, also, you're not passing a function to a function there
15:23:55 <Trinitron> Well functions are not variables usually
15:24:04 <kmc> Trinitron, no, every good imperative language supports first-class functions
15:24:10 <Trinitron> What about C?
15:24:17 <kmc> is a special-purpose systems programming language
15:24:18 <Trinitron> you need function pointers
15:24:18 <monochrom> heard about sort() in C?
15:24:25 <Trinitron> You can'
15:24:27 <kmc> also, C function pointers are not true first-class functions
15:24:32 <korsakow> Axman6: even mobile app development?
15:24:33 <kmc> but whatever
15:24:34 <systemfault> Function pointers doesn't make them first class
15:24:43 <monochrom> Anyway Pascal, Algol, Modula-3.
15:24:44 <Axman6> korsakow: yep, you can write iPhone apps in haskell
15:24:46 <kmc> i spend too much time arguing about this shit
15:24:52 <korsakow> Axman6: nice.
15:24:58 <systemfault> C++ templates are closer to that
15:25:13 <monochrom> Oh hey even Javascript.
15:25:17 <systemfault> Yeah
15:25:29 <kmc> Javascript is the world's most popular functional programming language
15:25:31 <jlouis> Javascript is sinisterly powerful
15:25:38 <jlouis> precisely
15:25:39 <systemfault> And fast.
15:25:42 <kmc> first-class functions are also used pervasively in Ruby and Python
15:25:49 <systemfault> Compared to let's say... Python
15:26:09 <kmc> in C++ people write many-thousand-LoC libraries to fake having first-class functions
15:26:22 <kmc> DigitalKiwi, I only spent a few min. reading about mythryl.  looks very nice
15:26:36 <DigitalKiwi> keenerd: well there you go
15:26:49 <DigitalKiwi> but which is nicer? haskell or it?
15:27:09 <kmc> DigitalKiwi, does it have libraries or community support like Haskell?
15:27:18 <DigitalKiwi> dunno :(
15:27:24 <systemfault> kmc: Not really.
15:27:27 <kmc> it does not seem to differ substantially in design
15:27:32 <keenerd> I doubt it has community.  It is a one man project at this point.
15:27:35 <kmc> hence my comment about marketing Haskell as a pragmatic alternative to Haskell
15:27:45 <systemfault> kmc: They do write huge functional programming libs though..
15:27:53 <DigitalKiwi> imo community/libraries doesn't make the language better/worse just more/less reason to use it
15:28:08 <kmc> DigitalKiwi, ah, you're interested in the design itself?
15:28:11 <kmc> fair enough
15:28:15 <kmc> that's often the view i take :)
15:28:19 <DigitalKiwi> well all of it i guess
15:28:35 <kmc> oh, it's forked from SML/NJ
15:28:38 <kmc> the implementation is
15:28:40 <kmc> that's interesting
15:28:57 <DigitalKiwi> I mean, using a superior language is all fine and dandy, but if there are no libraries then how are you to do anything useful without writing your own? But I guess somebody has to...
15:29:24 <kmc> hahaha
15:29:26 <kmc> so actually
15:29:31 <jlouis> it is not that important
15:29:36 <aavogt> maybe the language is so superior that it's easier to write the libraries than it is to use the libraries from the other languages....
15:29:43 <kmc> Mythryl is just SML marketed as a pragmatic alternative to SML
15:29:50 <DigitalKiwi> haha
15:30:07 <aavogt> what's the pragmatic alternative to haskell?
15:30:10 <kmc> here is the cheat sheet: http://mythryl.org/my-Mythryl_for_SML_Programmers.html
15:30:21 <DigitalKiwi> aavogt makes a good point
15:30:48 <DigitalKiwi> Mythryl is essentially SML/NJ with a Posix face, so if you are already familiar with SML you will have an easy time learning Mythryl; all you need to learn are the differences and the new facilities. <-- lol
15:31:01 <aavogt> possibly scala
15:31:04 <ErhardtMundt> BONUS, hello
15:31:18 <Darkone> Question, bevause I'm curious, and haven't reached that part yet...
15:31:35 <aavogt> but that one isn't very similar
15:31:45 <Darkone> In simple terms, how do you store somewhat dynamic stuff? Like a monster?
15:32:00 <Trinitron> Oh crap, I read the question wrong, I did the biggest palindrome for the product of 3 2 digit numbers rather than 2 3 digit numbers....
15:32:05 <jlouis> data Monster = Monster
15:32:06 <Axman6> Darkone: huh?
15:32:09 <Darkone> I know in imperative, you probably store it in a class, maybe even a struct.
15:32:16 <Trinitron> I'm not dyslexic, I hope
15:32:36 <aavogt> why all the indirection?
15:32:47 <jlouis> Darkone: Look up Algebraic Data Type or ADT
15:32:55 <Darkone> Axman6, say you were writing a game, and have to store info about monsters. In simple terms, how do you do it in Haskell? I'm not even far into the tutorial, just curious about it.
15:33:05 <aavogt> > 100 ^ 3 `compare` 1000 ^ 2
15:33:07 <lambdabot>   No instance for (GHC.Real.Integral GHC.Ordering.Ordering)
15:33:07 <lambdabot>    arising from a...
15:33:17 <aavogt> > (100 ^ 3) `compare` (1000 ^ 2)
15:33:19 <lambdabot>   EQ
15:33:57 <kmc> Darkone, you'd make an algebraic type, possibly a record (which in Haskell is just a bit of syntax on top of algebraic types)
15:34:16 <tromp_> :t xor
15:34:17 <lambdabot> forall a. (Bits a) => a -> a -> a
15:34:41 <tromp_> > (100 `xor` 3) `compare` (1000 `xor` 2)
15:34:42 <lambdabot>   LT
15:34:48 <Darkone> Thanks, kmc, jlouis
15:34:52 <sm> Darkone: you might keep your whole game state in a custom data type, which your main loop keeps transforming
15:35:21 <kmc> Darkone, data Monster = Dragon { hitPoints :: Integer, flightSpeed :: Float } | Hydra { hitPoints :: Integer, numberOfHeads :: Integer }
15:35:25 <tromp_> > (3 ^ 100) `compare` (2 ^ 1000)
15:35:26 <lambdabot>   LT
15:35:30 <Darkone> sm, yea, that sounds like what haskell is especially good at, right?
15:35:40 <kmc> also "imperative" has nothing to do with this, you can in fact have algebraic types in an imperative language
15:35:44 <kmc> Haskell is (also) an imperative language
15:36:12 <Darkone> kmc, I was just saying that in, say, C++ or python, if you want to store information about a creature, you might use a class.
15:36:17 <kmc> yeah
15:36:28 <kmc> this is not too different
15:36:44 <Darkone> Yea, looks close enough.
15:36:50 <kmc> until you get into things like inheritance and attaching behaviors to each type
15:36:54 <FliPPeh_> byorgey: In the section about functors, I don't understand the part about ((,) e) being part of the Functor class
15:36:58 <Axman6> Darkone: keep reading
15:37:00 <kmc> we don't need anything special for that... behaviors are just functions and functions are just data
15:37:03 <Darkone> Reading the realworldhaskell book. I managed to get lost in learn you a haskell.
15:37:05 <FliPPeh_> What's it's use?
15:37:09 <kmc> so you can store the behaviors the same way, you don't need to make it one-per-type
15:37:22 <systemfault> Darkone: learn you a haskell is easier imho :(
15:37:24 <FliPPeh_> Same for ((->) e)
15:37:34 <Darkone> Yea, I love how functions can be passed around like everything else.
15:37:39 <Darkone> So easily, that is.
15:37:54 <gs4> hi everyone, can someone tell me why I get a type error when trying to use BytesString.split as so: split ' ' "asda asd asd asdasd"
15:38:01 <djahandarie> Learn you a Haskell contains easier concepts, but Real World Haskell is more interesting and as a result probably easier to understand as a whole.
15:38:06 <Darkone> I imagine it would make a customizable magic system, like in morrowind easier to implement? :P
15:39:03 <systemfault> Being a noob, it's hard for me to imagine how a game would be in haskell
15:39:08 * sm thinks the quickest way to haskell-game-fu is to read the source of games on hackage
15:39:09 <jlouis> Darkone: sometimes you can make all your data into a function and then compose functions together to form new data. That kind of abstraction is powerful
15:39:17 <systemfault> Returning a new complete world at each modification?
15:39:18 <Axman6> gs4: we couldn't possibly tell you without seeing your code, though, it looks like you're passing a String to something that expects a ByteString?
15:39:34 <[swift]_> sm: that's good advice
15:39:44 <Trinitron> Yay problem 4 done in memoised purely functional haskell
15:39:59 <systemfault> Trinitron: Problem 4?
15:40:01 <Trinitron> PE
15:40:05 <systemfault> Ah!
15:40:26 <Trinitron> I got up to about 80 something in python
15:40:32 <Trinitron> I'm just doing it in haskell now
15:40:39 <Darkone> Back. I just love lots of information and examples. Makes things easier to understand.
15:40:41 * DigitalKiwi only did ~20 of them
15:40:45 <DigitalKiwi> in lua, then got bored
15:40:49 * mreh has never done a project euler problem
15:40:55 <systemfault> Trinitron: How fast is the memoized version?
15:40:58 <Trinitron> errr
15:41:00 <Trinitron> sorta
15:41:01 <gs4> I'm just running it in GHCi, like this: Prelude Data.ByteString> split ' ' "foo bar baz"
15:41:06 <Trinitron> 20-30 seconds?
15:41:13 <Darkone> Like the currying and partial completion, or more generally, learn you a haskell; I ended up skipping the explanations, and reading the code.
15:41:18 <gs4> and even when I tag the delimiter as a Word8, it complains
15:41:19 <Trinitron> I have a slow laptop
15:41:26 <systemfault> Trinitron: Ah ok :P
15:41:29 <Darkone> As I had no clue what the explanation said, but in the code, it's fairly obvious.
15:41:32 <Trinitron> 1.8 GHz
15:41:34 <gs4> e.g. split (' ' :: GHC.Word.Word8) "foo bar baz" gives the same error
15:42:02 <systemfault> Trinitron: Wow.. seems slow, I'm scared to know how fast was the unmemoized version
15:42:06 <Trinitron> heh
15:42:06 <kmc> Darkone, that's excellent.  it's great to be able to learn that way, not everyone can
15:42:12 <jlouis> FliPPeh_: ((,) e) can transform a value of type (a, e) to a value of type (b, e)
15:42:18 <Trinitron> 10000 years?
15:42:21 <Trinitron> I dunni
15:42:24 <Trinitron> dunno
15:42:31 <Trinitron> probably run out of memory
15:42:34 <Axman6> Darkone: read the explanations, they're quite important. you'll think you understand the code, but you won't understand what's actually happening
15:42:49 <Trinitron> It branches in the recursion
15:42:59 <Axman6> gs4: ' ' is a Char, and always will be
15:43:03 <Darkone> kmc, mostly because I'm terrible with names. I do better with.. concepts I guess?
15:43:15 <Axman6> :t ' '
15:43:16 <lambdabot> Char
15:43:17 <Darkone> Axman6, I read them afterwards :P
15:43:19 <kmc> Axman6, i don't know.  i wish people would just read the definition of the typeclass named "Monad", rather than reading the explanations ;)
15:43:23 <jlouis> FliPPeh_: more precisely, given a function of type a -> b, we can use it to get a value of type (a, e) to a value of type (b, e)
15:43:23 <gs4> Ok, so how do I tell it to split on spaces?
15:43:28 <FliPPeh_> > fmap reverse (Just "abc")
15:43:29 <Twey> :t ord ' ' :: Word8
15:43:29 <lambdabot>   Just "cba"
15:43:30 <lambdabot>     Couldn't match expected type `Word8' against inferred type `Int'
15:43:30 <lambdabot>     In the expression: ord ' ' :: Word8
15:43:31 <Axman6> kmc: heh, yeah
15:43:31 <DigitalKiwi> lua euler4.lua  0.15s user 0.00s system 97% cpu 0.158 total
15:43:32 <FliPPeh_> > fmap reverse (Just "abc")
15:43:33 <lambdabot>   Just "cba"
15:43:35 <Trinitron> hehe
15:43:37 <Twey> :t fromIntegral $ ord ' ' :: Word8
15:43:38 <kmc> cause, hey, it's just a typeclass
15:43:39 <lambdabot> Word8
15:43:41 <FliPPeh_> > fmap reverse ("abc", "cba")
15:43:42 <lambdabot>   ("abc","abc")
15:43:42 <DigitalKiwi> Trinitron: if youre program takes longer than that in haskell you are doing it wrong
15:43:48 <Trinitron> nope
15:43:48 <systemfault> DigitalKiwi: Way to go :)
15:44:11 <Trinitron> I'm doing it right
15:44:16 <DigitalKiwi> that's not memonized
15:44:17 <systemfault> DigitalKiwi: Mine was about that fast.
15:44:38 <systemfault> PE is fun to learn a language
15:44:45 <mreh> benchmarks are not absolute
15:44:48 <Trinitron> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24141#a24141
15:44:53 <Trinitron> That's my solution.
15:44:53 <systemfault> DigitalKiwi: never got #14 to be as fast as I wanted
15:44:53 <FliPPeh_> > fmap reverse ("abc", "cba")
15:44:54 <lambdabot>   ("abc","abc")
15:44:56 <FliPPeh_> Why does this work here
15:44:58 <FliPPeh_> But not in GHCI?
15:45:07 <FliPPeh_> No instance for (Functor ((,) [Char]))
15:45:12 <jlouis> FliPPeh_: Control.Monad.Instances
15:45:15 <FliPPeh_> Ah
15:45:21 <systemfault> DigitalKiwi: 0.125 on my system compared to 0.070 in C
15:45:26 <kmc> PE is fun to learn the first 1% of a language
15:45:26 <mreh> FliPPeh_, this is not Haskell, it's Caleskell
15:45:29 <mreh> that's probably why
15:45:37 <Trinitron> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24141#a24141
15:45:46 <FliPPeh_> mreh: Caleskell?
15:45:47 <Trinitron> you think this is the wrong way?
15:45:57 <mreh> FliPPeh_, ask Cale why :)
15:46:03 <jlouis> FliPPeh_: now, given a function (a -> b) think about a value of type ((->) e a) can be transformed to a value of type ((->) e b)
15:46:09 <kmc> Trinitron, looks all right
15:46:25 <systemfault> Trinitron: Yeah.. You can find if it's a palindrom mathematically.
15:46:25 <kmc> instead of memo3 x y z i might just use maximum [x,y,z]
15:46:36 <DigitalKiwi> i have it in falcon, perl, and lua, lua was the fastest =D
15:46:37 <FliPPeh_> jlouis: Ahh, thanks for clearing this up :)
15:46:46 <Trinitron> oh
15:46:48 <Trinitron> I use string ops
15:46:54 <Trinitron> which are O(n)
15:46:59 <systemfault> Trinitron: strings are obviously going to be slow.
15:47:02 <jlouis> FliPPeh_: there is almost only one sensible way to form those instances
15:47:03 <systemfault> (Compared to that)
15:47:54 <mreh> why would strings obviously be slow?
15:48:17 <FliPPeh_> > fmap reverse id [1 .. 5]
15:48:18 <lambdabot>   [5,4,3,2,1]
15:48:21 <FliPPeh_> jlouis: Like this?
15:48:27 <Axman6> because they're linked lists, and not packed strings?
15:48:35 <systemfault> mreh: Because of the list creation? at each time?
15:48:58 <kmc> linked lists are great as generators / iterators / whatever you like to call them
15:49:00 <mreh> you don't create lists
15:49:02 <kmc> to compose a producer and a consumer
15:49:12 <[swift]_> ((->) e a)... i'm a bit confused. is that the same type as (e -> a)?
15:49:13 <kmc> they are not so great as persistent data
15:49:17 <kmc> [swift], yes
15:49:21 <kmc> just writing (->) prefix
15:49:28 <[swift]_> gotcha, thanks
15:49:30 <kmc> just as you can write (+) 2 3 instead of 2 + 3
15:49:56 <Darkone> I still get giddy when I see haskell's Integer type :P
15:50:31 <mreh> @src (->) fmap
15:50:31 <lambdabot> fmap = (.)
15:50:42 <monochrom> > (+) (2 `mod`5) (5 `div` 2)
15:50:43 <lambdabot>   4
15:50:50 <Trinitron> How do you test if a number is a palindrome?
15:50:59 <Trinitron> without reversing a string?
15:50:59 <FliPPeh_> A number?
15:51:01 <mreh> Trinitron, what base?
15:51:04 <FliPPeh_> I once did that
15:51:06 <Trinitron> 10
15:51:09 <FliPPeh_> But I don't remember ;x
15:51:10 <jlouis> FliPPeh_: as mreh showed, it is just function composition for (->)
15:51:13 <monochrom> why not reverse string.
15:51:18 <Trinitron> I did reverse string
15:51:27 <systemfault> monochrom: It's slow as f.
15:51:28 <Trinitron> but DigitalKiwi says that I took too long
15:51:38 <Trinitron> my program took 20-30 seconds
15:51:39 <FliPPeh_> jlouis: (f . g) == fmap f g ?
15:51:47 <systemfault> monochrom: His version takes 30sec.. DigitalKiwi .15
15:51:52 <kmc> Trinitron, it's not a problem in practice... are your numbers thousand of digits?
15:51:52 <mreh> FliPPeh_, yup
15:51:55 <jlouis> FliPPeh_: for (->) yes
15:51:57 <FliPPeh_> Nice :)
15:52:00 <Trinitron> no
15:52:06 <mreh> FliPPeh_, f . g == (.) f g
15:52:10 <mreh> you know that right?
15:52:23 <kmc> also you have to walk the whole string anyway
15:52:36 <FliPPeh_> mreh: Yupp
15:52:48 <monochrom> use an array instead of a string.
15:53:01 <FliPPeh_> let palinNum = (==) . show
15:53:04 <monochrom> @type array
15:53:06 <lambdabot> forall i e. (Ix i) => (i, i) -> [(i, e)] -> Array i e
15:53:07 <FliPPeh_> > let palinNum = (==) . show in palinNum 40
15:53:08 <lambdabot>   ""->
15:53:08 <mreh> palendromes are best done with arrays I think...
15:53:08 <lambdabot>    False
15:53:08 <lambdabot>  "a"->
15:53:08 <lambdabot>    False
15:53:08 <lambdabot>  "aa"->
15:53:10 <lambdabot> [5 @more lines]
15:53:12 <monochrom> @type listArray
15:53:13 <lambdabot> forall i e. (Ix i) => (i, i) -> [e] -> Array i e
15:53:14 <FliPPeh_> WHATDIDIDO?
15:53:17 <Trinitron> let f x = 1 + x and g = 2 in f . g
15:53:18 <mreh> palindromes*
15:53:21 <Trinitron> > let f x = 1 + x and g = 2 in f . g
15:53:22 <lambdabot>   <no location info>: parse error on input `='
15:53:25 <FliPPeh_> > let palinNum = (==) . show in palinNum 40
15:53:26 <lambdabot>   ""->
15:53:26 <lambdabot>    False
15:53:26 <lambdabot>  "a"->
15:53:26 <lambdabot>    False
15:53:26 <lambdabot>  "aa"->
15:53:28 <lambdabot> [5 @more lines]
15:53:28 <[swift]_> an array would definitely be most efficient
15:53:30 <FliPPeh_> What's this?
15:53:33 <[swift]_> could do it with a stack
15:53:42 <Trinitron> > let f x = 1 + x,  g = 2 in f . g
15:53:44 <lambdabot>   <no location info>: parse error on input `,'
15:54:17 <mreh> I don't think there is a purely function stack native to haskell
15:54:30 <mreh> some kind of doubly linked list...
15:54:35 <mreh> if that makes sense
15:54:48 <monochrom> > let a = listArray (0, 4) (show 12321) in a!0 == a!4 && a!1 == a!3 && a!2 == a!2
15:54:49 <lambdabot>   True
15:54:51 <Trinitron> how do I do a let on one line
15:54:54 <Trinitron> with two functions
15:54:57 <[swift]_> you can use a list as a stack, really
15:54:59 <Trinitron> ?
15:55:09 <mreh> [swift], inefficient :)
15:55:22 <[swift]_> mreh: haha true
15:55:24 <jlouis> how about representing the string as a circular tying-the-knot list and then consuming from both ends?
15:55:26 <mreh> it's not a stack then
15:55:43 <mreh> jlouis, I've never seen that done in haskell
15:55:51 <mreh> can it be easily done?
15:55:56 <monochrom> that's more advanced but nice
15:55:57 <kmc> > let a = 1; b = 2 in (a,b) -- Trinitron
15:55:58 <lambdabot>   (1,2)
15:56:09 <kmc> Trinitron, the newlines are just sugar for ;
15:56:11 <jlouis> mreh: yes, because of lazy evaluation, you can tie the knot
15:56:32 <c_wraith> > let foo = "Hello! " ++ foo in foo
15:56:34 <lambdabot>   "Hello! Hello! Hello! Hello! Hello! Hello! Hello! Hello! Hello! Hello! Hell...
15:56:46 <c_wraith> It's a circular linked list!
15:57:04 <Trinitron> > let f x = 1 + x; g = 2 in f . g
15:57:06 <lambdabot>   No instance for (GHC.Num.Num (f a))
15:57:06 <lambdabot>    arising from the literal `2' at <int...
15:57:08 <monochrom> problem is how do you know you have checked the whole cycle.
15:57:25 <mreh> I am familiar with cycles :)
15:57:41 <c_wraith> No way to know without cheating, of course.
15:57:50 <Trinitron> > let f x = 1 + x; g q = 2 + q in f . g 3
15:57:51 <lambdabot>   No instance for (GHC.Num.Num (f a))
15:57:51 <lambdabot>    arising from a use of `g' at <intera...
15:57:57 <Trinitron> argh!!!
15:58:09 <mreh> if you were to consume from both ends, how do you know you've reached the middle?
15:58:12 <c_wraith> trinitron: needs more $
15:58:22 <kmc> f . g $ 3
15:58:24 <kmc> or (f . g) 3
15:58:27 <kmc> or f (g 3)
15:58:30 <c_wraith> > let f x = 1 + x; g q = 2 + q in f . g $  3
15:58:32 <lambdabot>   6
15:59:52 <Trinitron> f . g 3 parses as f g 3?
16:00:16 <Trinitron> . is just a precedence operator?
16:00:30 <Axman6> t function compoition
16:00:32 <kmc> precedence?
16:00:33 <Axman6> it's*
16:00:36 <kmc> . is just an infix operator
16:00:37 <kmc> @src (.)
16:00:38 <lambdabot> (f . g) x = f (g x)
16:00:47 <c_wraith> No.  "f . g 3" parses as "f . (g 3)"
16:00:53 <kmc> @src ($)
16:00:53 <lambdabot> f $ x = f x
16:01:09 <DigitalKiwi> now would be a good time to know haskell so I could help / understand this problem :(
16:01:12 <c_wraith> prefix function application binds more tightly than infix operator application
16:01:22 <stulli> How can i beautify this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24143#a24143 ?
16:01:37 <FliPPeh> I like how Irssi always notifies me about a changed day
16:01:39 <DigitalKiwi> lipstick and eye shadow
16:01:42 <Trinitron> > let f x = 1 + x; g y = 2 + y in f (g 2)
16:01:43 <lambdabot>   5
16:01:46 <FliPPeh> Otherwise I'd have no orientation :x
16:01:53 <Trinitron> > let f x = 1 + x; g y = 2 + y in f . (g 2)
16:01:55 <lambdabot>   No instance for (GHC.Num.Num (f a))
16:01:55 <lambdabot>    arising from a use of `g' at <intera...
16:02:07 <Trinitron> > let f x = 1 + x; g y = 2 + y in f . g $ 2
16:02:09 <lambdabot>   5
16:02:38 <alexsuraci> what's the replacement package for old-locale?
16:02:45 <Trinitron> so . "combines" the functions
16:02:51 <c_wraith> yep
16:02:56 <c_wraith> :t (Prelude..)
16:02:57 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
16:02:59 <mreh> it composes them
16:03:02 <Trinitron> yes
16:03:12 <mreh> it's backwards though
16:03:37 <mreh> well, I only say that because I do too much arrows
16:03:40 <Trinitron> > let f x = 1 + x; g y = 2 + y in f . g (2)
16:03:41 <c_wraith> I thought that for a while.  Now I think >>> is backwards
16:03:41 <lambdabot>   No instance for (GHC.Num.Num (f a))
16:03:41 <lambdabot>    arising from a use of `g' at <intera...
16:03:43 <mreh> :t (<<<)
16:03:44 <lambdabot> forall (cat :: * -> * -> *) b c a. (Control.Category.Category cat) => cat b c -> cat a b -> cat a c
16:04:19 <c_wraith> :t reverse . drop 3 . reverse
16:04:20 <lambdabot> forall a. [a] -> [a]
16:05:25 <milaz> I never got it why forall is necessary
16:05:47 <milaz> isn't forall a. [a] -> [a] the same as [a] -> [a], sorry my ignorance
16:05:50 <aavogt> milaz: it isn't necessary in H98 or the upcoming standard
16:05:54 <[swift]_> for the palindrome problem, imagine the string has even length. if we have a function toPrime that assigns each character a prime, might "foldr (\c a -> a * toPrime c) 1 inputString" work? we can just check if the result's square root is an integer. not a practical algorithm of course. =)
16:06:20 <aavogt> some language extensions mean there is a difference between the ones qualified with forall and those without
16:06:23 <conal> milaz: at the top level, they're the same, but not equivalent if nested.
16:07:03 <aavogt> conal: at the top level they may still differ if you use -XScopedTypeVariables
16:07:04 <fergie> If I have a function: foo y listofstuff listofmorestuff= map (\x->bar y listofstuff) listofmorestuff
16:07:29 <conal> aavogt: ah, yeah.  very weird scope rules
16:07:30 <milaz> conal: is there an example when they differ?
16:08:01 <c_wraith> :t runST
16:08:02 <lambdabot> forall a. (forall s. ST s a) -> a
16:08:12 <c_wraith> That second forall definitely means something
16:08:45 <aavogt> conal: either with or without the extension, the scoping rules are weird
16:09:05 <milaz> is (ST s a) -> a legal?
16:09:14 <kmc> legal how?
16:09:14 <monochrom> legal but different.
16:09:15 <aavogt> but it doesn't mean the same thing
16:09:21 <djahandarie> Could Djinn potentially go through some sort of graph reduction past the LJ calculus + Curry-Howard isomorphism?
16:09:23 <kmc> it's a syntactically well-formed type
16:09:28 <kmc> you cannot write a term of that type
16:09:31 <kmc> without cheating
16:10:04 <aavogt> doesn't this depend on how ST is defined?
16:10:06 <aavogt> @src ST
16:10:07 <lambdabot> newtype ST s a = ST (STRep s a)
16:10:08 <c_wraith> that's like...  unsafeSTToIO followed by unsafePerformIO level cheating.
16:10:20 <kmc> milaz, "f :: (forall a. a) -> ()" requires its argument to be polymorphic.  "f :: forall a. a -> ()" will accept any argument, even one of a concrete type
16:11:09 <kmc> milaz, a forall in the left half of a "->" (a "higher-rank type") introduces an obligation by the caller to provide polymorphism, rather than advertising a willingness by the callee to accept anything
16:11:52 <kmc> this is useful e.g. in runST, where we force the "s" parameter to be polymorphic.  this guarantees that no (STRef s) appears within the type of a, so no refs leak out
16:13:03 <FliPPeh> :t (<*>)
16:13:04 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
16:13:37 <FliPPeh> :t Just (+3) <*> Just 4
16:13:38 <lambdabot> forall a. (Num a) => Maybe a
16:13:43 <FliPPeh> > Just (+3) <*> Just 4
16:13:43 <lambdabot>   Just 7
16:14:06 <FliPPeh> > Just (+3) <*> Nothing
16:14:07 <lambdabot>   Nothing
16:14:15 <djahandarie> ddarius, do you know (regarding my question a few lines up)?
16:14:34 * shapr hugs ddarius 
16:14:46 <djahandarie> Ideally I'd just ask augustss but he ain't here. :[
16:14:56 <Axman6> @src STRep
16:14:56 <lambdabot> type STRep s a = State# s -> (# State# s, a #)
16:15:26 <kmc> lambdabot has a GHC-centric view of the world
16:15:39 <Axman6> so does Axman6 :)
16:15:45 <c_wraith> hah.  ghci agrees with me
16:15:50 <c_wraith> unsafePerformIO . unsafeSTToIO :: ST s a -> a
16:15:57 <jlouis> what is the size of each index cell in a MArray IOUArray Bool IO
16:16:09 <jlouis> 1 bit? or 8 bits?
16:16:10 <c_wraith> Not that I have any clue what the semantics of that expression would be
16:16:24 <Axman6> jlouis: i think it's packed, so 1 bit
16:18:07 <jlouis> This begs the question: Why does bitarray exist then?
16:18:18 <jlouis> as a hackage package
16:18:33 <Axman6> different interface?
16:18:53 <jlouis> Well, according to the source it uses Word64 Arrays :)
16:19:11 <Axman6> ah, could be more efficient then
16:20:25 <jlouis> I'll probably make an abstraction in a module anyway
16:20:47 * c_wraith rewrites id in a new and fancier way
16:21:06 <c_wraith> let id = unsafePerformIO . unsafeSTToIO . return
16:21:22 <jlouis> > id . id . id . id . id . id $ 3
16:21:23 <lambdabot>   3
16:22:58 <milaz> :t id
16:23:00 <lambdabot> forall a. a -> a
16:23:32 <c_wraith> now, for some type-system hijinx...
16:23:38 <c_wraith> :t runST . return
16:23:39 <lambdabot>     Couldn't match expected type `forall s. ST s a'
16:23:39 <lambdabot>            against inferred type `m a1'
16:23:39 <lambdabot>       Expected type: a1 -> forall s. ST s a
16:24:12 <Axman6> :t runST
16:24:12 <lambdabot> forall a. (forall s. ST s a) -> a
16:24:49 <c_wraith> polymorphic type variables are rank-1 by default, and can't contain the rank-2 type of runST
16:25:05 <aavogt> what's the logic behind calling ST ST and calling StateT StateT?
16:25:16 <c_wraith> so you can't use function composition to the right of runST
16:25:18 <Axman6> :t \x -> runST (return x)
16:25:19 <lambdabot> forall a. a -> a
16:25:21 <kmc> id :: a -> a; id = unsafeCoerce
16:25:35 <c_wraith> aavogt: ST came from "State Thread"
16:25:41 <Axman6> aavogt: they're different things
16:25:47 <kmc> yeah, there is no STT
16:25:54 <kmc> for the same reason that there is no IOT
16:26:08 <aavogt> I've used both
16:26:25 <aavogt> for some reason I thought both stood for State Transformer
16:26:44 <aavogt> with the shorter one allowing multiple state variables
16:27:14 <Axman6> ST is IO without the IO basically
16:27:20 <milaz> :t runStateT
16:27:21 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
16:27:22 <c_wraith> there's a microsoft research paper from 95ish talking about state threads, and their implementation (along with the implementation of the IO type) in GHC
16:27:27 <Axman6> it has real mutable variables
16:27:31 <olsner> @quote ST.*format
16:27:32 <lambdabot> pumpkin says: "roconnor would have strangled me if I had given any more information than a Maybe."
16:27:44 <FliPPeh> How can I hide a type class instance from an imported module?
16:27:51 <aavogt> you can't
16:27:56 <FliPPeh> Laaaame.
16:28:03 <olsner> wait, what, that's not the quote I asked for ... whatever
16:28:07 <aavogt> you can make a newtype if you're looking to override instances
16:33:17 <kmc> and you can GeneralizedNewtypeDeriving the instances you want to keep
16:34:15 <aavogt> aka. strategic unsafeCoerce
16:34:23 <Trinitron> Is it "True" or true?
16:34:34 <Axman6> True
16:34:45 <Axman6> all constructors have capital letters
16:35:07 <olsner> but you can define true = True, and it'll be the same thing :)
16:35:26 <Axman6> @let true = True
16:35:27 <lambdabot>  Defined.
16:35:32 <Axman6> @let false = False
16:35:33 <lambdabot>  Defined.
16:35:37 <Axman6> > false == False
16:35:38 <lambdabot>   True
16:35:42 <Trinitron> > true == True
16:35:43 <lambdabot>   True
16:35:47 <c_wraith> @let whatever = const true
16:35:48 <lambdabot>  Defined.
16:35:50 <Axman6> >> true == false
16:35:55 <Trinitron> @let True = False
16:35:55 <Axman6> > true == false
16:35:56 <lambdabot>  Defined.
16:35:57 <lambdabot>   False
16:36:10 <Trinitron> > True == False
16:36:11 <lambdabot>   False
16:36:15 <Trinitron> damn
16:36:45 <c_wraith> > whatever 10
16:36:46 <lambdabot>   True
16:36:53 <Axman6> > let a = False || a in a
16:36:57 <lambdabot>   mueval-core: Time limit exceeded
16:36:59 <Kagami`> :t whatever
16:37:01 <lambdabot> forall b. b -> Bool
16:37:07 <Axman6> b??????
16:37:09 <Kagami`> @src whatever
16:37:09 <lambdabot> Source not found. My pet ferret can type better than you!
16:37:09 <Axman6> :O
16:37:20 <Kagami`> > whatever [1,2,3]
16:37:22 <lambdabot>   True
16:37:33 <Kagami`> > whatever False
16:37:34 <lambdabot>   True
16:37:50 <companion_cube> :i whatever
16:37:55 <companion_cube> :/
16:38:08 <Axman6> campanion cubes can't talk!
16:38:15 <Kagami`> oops, fail
16:38:20 <Kagami`> <c_wraith> @let whatever = const true
16:38:23 <Kagami`> miss it
16:38:27 <Trinitron> GLaDOS!!
16:38:55 <ickabob> why doesnt this work? foldr (\n -> n + 1) 0 [1..100]?  trying to find # of elements in a list?
16:39:15 <c_wraith> :t foldr
16:39:16 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
16:39:22 <c_wraith> :t \n -> n + 1
16:39:23 <lambdabot> forall a. (Num a) => a -> a
16:39:29 <c_wraith> see the problem there?
16:39:37 <c_wraith> foldr requires a function that takes 2 arguments
16:39:37 <ickabob> yes
16:40:17 <ickabob> grr so lambda function would have to be something like (\n m -> undefined)
16:40:18 <ickabob> ?
16:40:57 <Axman6> > foldr (\_ n -> succ n) 0 [1..100]
16:40:58 <lambdabot>   100
16:41:06 <Axman6> > foldr (\_ n -> succ n) 0 "hello"
16:41:07 <lambdabot>   5
16:41:18 <ickabob> yeah i just did (\ x n -> n + 1)
16:41:27 <ickabob> ooh succ n
16:41:33 <ickabob> thats a good thought
16:42:10 <Axman6> nore sure if it makes any difference
16:42:19 <FliPPeh> > 5 + $ 5
16:42:20 <lambdabot>   <no location info>: parse error on input `$'
16:42:28 <Axman6> :t foldr (\_ n -> succ n) 0
16:42:29 <lambdabot> forall a b. (Enum b, Num b) => [a] -> b
16:42:29 <FliPPeh> > reverse $ 5
16:42:30 <lambdabot>   No instance for (GHC.Num.Num [a])
16:42:30 <lambdabot>    arising from the literal `5' at <inter...
16:42:34 <FliPPeh> > reverse $ "5"
16:42:35 <lambdabot>   "5"
16:42:41 <ickabob> 5 (+) $ 5
16:42:41 <FliPPeh> > ($) reverse "5"
16:42:42 <lambdabot>   "5"
16:43:01 <Axman6> > (+) 5 $ 5
16:43:02 <lambdabot>   10
16:43:06 <Axman6> > (+) 5 5
16:43:07 <lambdabot>   10
16:43:31 <systemfault> Axman6: I think I'm a bit dumb.. I can't seem to understand when to use $ and .
16:43:31 <ickabob> havn't really gotten ahold of the idea of $ yet
16:43:37 <ickabob> yeah
16:43:44 <ickabob> neither can I systemfault dont worry
16:43:48 <c_wraith> $ is easier than you think
16:43:49 <FliPPeh> systemfault: It's actually pretty easy
16:43:52 <c_wraith> @src ($)
16:43:52 <lambdabot> f $ x = f x
16:44:06 <ickabob> @src (.)
16:44:06 <systemfault> FliPPeh: I just didn't get the "Ahhhhhhhh... that was easy"
16:44:06 <lambdabot> (f . g) x = f (g x)
16:44:09 <systemfault> yet.
16:44:10 <c_wraith> That's it.  all $ does is apply the function on the left to the value on the right
16:44:23 <FliPPeh> f . g . h = f (g h)
16:44:36 <c_wraith> uh.  that's notright, FliPPeh.
16:44:39 <FliPPeh> :(
16:44:45 <ickabob> :P
16:44:46 <aavogt> no, haskell has to be correct
16:44:47 <FliPPeh> Oh yeah
16:44:55 <FliPPeh> Replace the . with $
16:44:55 <c_wraith> f . g . h = \x -> f (g (h x)))
16:45:06 <aavogt> but such definitions are prohibited
16:45:21 <c_wraith> err.  pretending I can balance parens
16:45:43 <systemfault> And $ ?
16:45:49 <ickabob> then f $ g $ h
16:45:50 <ickabob> ?
16:46:07 <c_wraith> "<c_wraith> That's it.  all $ does is apply the function on the left to the value on the right"
16:46:23 <c_wraith> I recommend not using multiple $ in the same line.  It gets confusing.
16:46:24 <ickabob> isnt that exactly what you just showed?
16:46:54 <ickabob> I think of . as the math f of g definition
16:46:58 <c_wraith> > (+1) . (*2) $ 3 + 7
16:46:59 <lambdabot>   21
16:47:47 <tensorpudding> @type (.)
16:47:48 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:47:49 <dufflebunk> FliPPeh: IF you have a lot of ( ) on the line, you can probaly use $ to remove some and make it more readable. That's the only use I have for it
16:48:14 <tensorpudding> lambdabot has a different type for (.) than GHC does.
16:49:11 <FliPPeh> If I have too many functions with one common argument, I use . and $.. like reverse and take 4 from a string, I'd use (take 4 . reverse $ string)
16:49:20 <merijn> tensorpudding: I think it's because lambdabot has some modules loaded in addition to prelude
16:49:24 <FliPPeh> > take 4 . reverse $ "Blahblah"
16:49:25 <lambdabot>   "halb"
16:49:49 <systemfault> > show 20 `div` 2
16:49:50 <lambdabot>   No instance for (GHC.Real.Integral GHC.Base.String)
16:49:50 <lambdabot>    arising from a use o...
16:49:51 <tensorpudding> #haskell calls it Caleskell, since Cale was responsible
16:49:51 <merijn> Including for instance a declaration that makes . an instance of Functor
16:49:53 <systemfault> > show $ 20 `div` 2
16:49:54 <lambdabot>   "10"
16:49:59 <systemfault> Ah ok :)
16:50:01 <ickabob> wtf
16:50:02 <systemfault> I think I got it
16:50:16 <ickabob> show (20 `div` 2)
16:50:22 <ickabob> no?
16:50:22 <ickabob> dang
16:50:26 <systemfault> . is for chaining
16:50:31 <systemfault> $ is for precedence
16:50:41 <aavogt> tensorpudding: but caleskell isn't officially endorsed
16:50:53 <ickabob> show $ (20 `div` 2)
16:51:03 <merijn> systemfault: Think of both being ways to reduce the obnoxious number of parenthesis :p
16:51:17 <tensorpudding> I'm not sure what that matters, since it's only that way on lambdabot.
16:52:29 <merijn> systemfault: You could write any code with . and $ without those two, but you'd have to introduce a lot of parenthesis for priority and end up with parenthesis balancing headaches. (If you don't mind, lisp is ---> that way :)
16:52:40 <systemfault> Haha
16:52:47 <systemfault> I understand now, it's okay
16:59:50 <sm> seems there is no successor to old-locale yet, Data.Time.Format depends on it
17:03:04 <Spaceghost> I will buy the acer timeline
17:03:08 <Spaceghost> of 15.6
17:03:23 <Spaceghost> have anyone here seen one?
17:12:07 <dankna> sm: yeah I know... kinda irksome, but oh well
17:14:38 <mdurr_> ugh, finding memory issues are taking longer to track down than writing the software
17:14:46 <ickabob> :src @
17:14:49 <ickabob> :t @
17:14:50 <lambdabot> parse error on input `@'
17:16:53 <jlouis> mdurr_: memory usage? get out the heap profiler
17:17:25 <mdurr_> jlouis: yeah, it lets me know where the issues are, but I feel so dirty using deepseq or the likes
17:17:53 <ivanm> *shrug* sometimes you just need a ! in the type
17:18:12 <FliPPeh> > (,,,) <$> Just "Hello " <*> Just "World" <*> Just "Yaaay" <*> Just "Naaaay"
17:18:13 <lambdabot>   Just ("Hello ","World","Yaaay","Naaaay")
17:18:25 <ivanm> e.g. if you have a counter value or some such; if you don't ! it then it will just be a huge block of thunks
17:19:15 <OscZA> what do you think are the main reasons why functional programming hasn't become mainstream despite its undoubtable benefits?
17:19:26 <FliPPeh> Strange new syntax
17:19:30 <merijn> Naah
17:19:37 <FliPPeh> Headache for imperative programmers
17:19:39 <mdurr_> is ! for a list type the same as seq [] which afaik only checks that the list is not _?
17:19:55 <merijn> You can easily create a functional language with a syntax similar to say python
17:20:05 <FliPPeh> But is there?
17:20:09 <OscZA> is it really that its so "difficult" to adapt for the masses
17:20:28 <merijn> OscZA: I think it's mostly that a lot of programmers don't care about what they do
17:20:42 <merijn> And other are never introduced to the functional concepts
17:20:43 <shapr> OscZA: I'd say it's that most of the culture of programming revolves around C-style languages.
17:20:57 <FliPPeh> OscZA: imperative languages have been there since almost half a century
17:21:10 <merijn> FliPPeh: So have functional languages
17:21:11 <FliPPeh> That's a big selling point
17:21:14 <mreh> lol
17:21:15 <shapr> Most people don't realize that a function call is not a basic structure, and so think recursion doesn't make sense.
17:21:23 <merijn> FliPPeh: Lisp is older then the jurassic era in computing terms
17:21:31 <FliPPeh> :/
17:21:33 <OscZA> but surely, people have run into trouble using those languages, with problems related to complexity, concurrency, scalability, etc..
17:21:46 <Entroacceptor> could it be that the imperative paradigm has benefits over the functional one?
17:21:57 <mreh> it's easy to learn
17:22:02 <merijn> Last week I had a discussion with some other CS students here about why Java sucked. I mentioned lack of first class functions. Their reactions "why would you ever need that?"
17:22:17 <jlouis> Entroacceptor: earlier, the imperative languages were faster than the functional, in general
17:22:27 <companion_cube> lack of first class functions, and closures, is so horrible
17:22:28 <FliPPeh> I still don't really know what "first class" really means.
17:22:30 <monochrom> No one "needs" anything.
17:22:38 <aavogt> do you "need" dependent types?
17:22:39 <merijn> jlouis: I disagree, haskell is faster then python :p
17:22:50 <companion_cube> in C, you can hardly use the qsort standard function with a custom compare function
17:22:51 <merijn> And ruby for that matter
17:22:52 <shapr> I don't need dependent types, but they sure would make my code simpler.
17:22:56 <companion_cube> because there is no closures
17:23:01 <merijn> companion_cube: You can and do, actually
17:23:01 <jlouis> merijn: hence the earlier. I am thinking about 1980'es and earlier
17:23:10 <merijn> companion_cube: Function pointers exist
17:23:14 <companion_cube> yeah
17:23:17 <companion_cube> but not closures
17:23:20 <merijn> You don't need closures for that
17:23:20 <shapr> I don't need assembly, I could write machine code, but higher levels make my life easier.
17:23:38 <mreh> what were the 1980s lisp compilers doing? still working with trees?
17:23:45 <mdurr_> low level languages == less head explosions
17:23:51 <companion_cube> i needed a compare function which depended on some third object, and it was hard to do
17:23:55 <merijn> mreh: Still? As if Lisp was ever anything other then trees
17:24:11 <mreh> merijn, I'm talking before graph reduction
17:24:31 <jlouis> mreh: Lisp was fast on specialized hardware, but it weren't for commodity hardware
17:24:48 <mreh> lisp machines
17:24:57 * companion_cube thinks that being fast and easy to parse is not a drawback, for a language :)
17:25:01 <merijn> jlouis: Properly type-hinted lisp can be pretty fast. Certainly close to or equal with haskell
17:25:19 <jlouis> I think a lot of the current state is because of the history from then
17:25:22 <liyang> shapr: Yeah? Well, I could simply wave my hand starting a butterfly chain effect and cause individual cosmic rays to hit my HD and toggle the bits I want.
17:25:31 <lament> fast and easy to parse is not a drawback -- all other things being equal :)
17:25:36 <shapr> liyang: Yeah, good old M-x butterfly
17:25:39 <jlouis> Today, functional languages are almost as fast as state of the art C compilers
17:25:40 <merijn> liyang: But you want because you're wasting your time reading XKCD :)
17:25:49 <merijn> s/want/won't
17:25:55 <systemfault> jlouis: That's false but they're really fast.
17:25:59 <sbpaul> does anybody know where to find the "evo" project?
17:26:04 <merijn> systemfault: How is that false?
17:26:05 <sbpaul> google didn't help
17:26:13 <mdurr_> liyang: infinite monkeys are much more amusing, as long as you don't mind infinite poo and have infinite bananas
17:26:24 <merijn> systemfault: Functional language compilers can do some obscene optimizations C can't dream off
17:26:25 <companion_cube> merijn: how do you type-hint in lisp ?
17:26:34 <systemfault> merijn: Are they doing it?
17:26:38 <merijn> systemfault: Yes
17:26:42 <shapr> For me, Haskell is faster than all other languages, where fast means how quickly I can change the program to take into account new features. In my opinion, speed of change is the most important factor in these times.
17:26:46 <merijn> GHC is an optimizing marvel
17:26:53 <jlouis> companion_cube: you can annotate types to parameters
17:26:55 <liyang> mdurr_: are monkeys carnivorous or even cannibalistic?
17:27:02 <systemfault> merijn: (I know it more or less a good argument) But look at the language shootout
17:27:09 <OscZA> For me, learning new programming paradigms has been usually through running into trouble with some things... then trying to find answers for it
17:27:17 <companion_cube> jlouis: and it does typechecks, also ? Or is it only a hint for optimization ?
17:27:17 <lament> or coprotrophic?
17:27:18 <merijn> companion_cube: I'm not a lisp guru, in fact I've never really done lisp. But I've seen it in code
17:27:19 <liyang> mdurr_: still not sure how to deal with the poo though.
17:27:33 <micah> when using parsec on a non-string stream, what parsers do I use
17:27:38 <jlouis> companion_cube: both. It'll warn you when it can prove you are wrong
17:27:38 <lament> liyang: coprotrophic monkeys
17:27:46 <mdurr_> liyang: even if they were canabalistic infinite monkeys eating infinite monkeys leaves infinite monkeys to deal with
17:28:09 <shapr> I like the whole mental image of "canaballistic".
17:28:13 <merijn> systemfault: There is a research group at the university here creating a functional C language just for the sole reason to have a language for C programmers which can be optimized far more heavily then C can
17:28:26 <companion_cube> jlouis: this is cool :)
17:28:31 <jlouis> shapr: I agree. I can rewrite Haskell code faster than most other code out there
17:28:38 <jeffwheeler> The HTTP library can't do HTTPS, correct?
17:28:48 <nanashi> merijn: interesting
17:28:55 <merijn> (It's aimed at being a language for writing heavy numeric computation code for massive parallel computation on stuff like CUDA)
17:28:57 <mdurr_> jeffwheeler: afaik it can not
17:28:58 <liyang> merijn: it still doesn't help that people are using associative lists when they want finite maps though.
17:29:03 <jeffwheeler> mdurr_, Hmm
17:29:05 <jlouis> companion_cube: the common lisp guys using CMUCL or SBCL knows more about this than me
17:29:21 <mreh> what's a finite map?
17:29:25 <jeffwheeler> It seems to silently use HTTP instead; tricky!
17:29:29 <systemfault> merijn: Research... Nobody has results.
17:29:30 <liyang> mreh: Data.Map
17:29:39 <mreh> what's finite about it?
17:29:40 <McManiaC> has anyone ever done anything with socks5?
17:29:40 <companion_cube> jlouis: ok, thanks
17:29:44 <McManiaC> *in here
17:29:55 <liyang> mreh: (is one implementation.)
17:30:07 <mreh> oh
17:30:07 <systemfault> merijn: Ever looked at BitC?
17:30:08 <mreh> :)
17:30:08 <micah> I am trying to use parsec with a [Token] instead of a String
17:30:12 <micah> how can I do this
17:30:23 <OscZA> Say you are a programmer who has done lots of stuff, say web apps, database apps using ORM, GUI apps, command line apps ... what do you think are the most easy types of applications to convert to functional and what are the most difficult ?
17:30:27 <mreh> that would take a lot of memory, unless you're using a very small address space
17:30:32 <merijn> systemfault: Easy to call it just research. They have quite a bit of code and working compilers for linux and OS X
17:30:49 <merijn> systemfault: The basics work, they're now working on creating more and more optimizations
17:31:14 <systemfault> merijn: We'll see the results eventually
17:31:14 <merijn> nanashi: If you're interested they have binaries and documentation at http://www.sac-home.org/
17:31:30 <nanashi> cool; thanks=)
17:31:34 <micah> any parsec experts?
17:31:44 <jlouis> OscZA: I don't think any type is easier or harder than others. You will have to rethink the design for all of them to get a nice FP fit
17:32:37 <jeffwheeler> micah: just ask
17:32:41 <nanashi> yep jlouis
17:32:43 <micah> I did
17:32:43 <micah> :P
17:32:51 <jeffwheeler> micah: oh, sorry :)
17:32:52 <micah> how do I use parsec on non-String streams
17:32:54 <merijn> OscZA: Also, I find myself just inserting a lot of functional programming code in non-functional languages and applications :p
17:32:57 <OscZA> jlouis: Ok, but you dont think there are any specific types of applications that are really difficult to convert to FP ?
17:33:17 <jlouis> OscZA: no.
17:33:17 <OscZA> that is surprising.. and also promising if you are serious
17:33:42 <merijn> OscZA: I'm working on a compiler (written in C) for class and I have quite a bit of functional code in there
17:33:48 <nanashi> apps that use c/imperative libs - but those can be wrapped to fp as well.
17:33:53 <systemfault> Being a noob, I found that laziness does bite sometimes :(
17:35:17 <merijn> OscZA: For example look at this code (yeah, it kinda sucks I know) http://dpaste.org/RzOW/ Nearly all of it is recursive :p
17:35:50 <liyang> merijn: GOOD GOD MY EYES. THEY BURN.
17:36:07 <OscZA> In OO, when I learned it, I found it nice when you in some methods only had to deal with a subset of the member variables of the instance.. and not having to pass all the parameters along..
17:36:20 <merijn> liyang: It's not *that* bad
17:36:37 <merijn> OscZA: You can have OO functional programming
17:36:42 <merijn> I believe OCaml does that
17:36:47 <jlouis> indeed it does
17:36:48 <mdurr_> merijn: looks like you have a nice start to a haskell interpreter
17:37:34 <ivanm> preflex: seen kamatsu
17:37:34 <preflex>  kamatsu was last seen on #haskell 3 days, 11 hours, 4 minutes and 7 seconds ago, saying: where as you can look at tons of java and still not have any meaning at all
17:37:35 <merijn> OscZA: There's no real reason why OO programming is imperative by definition or functional programming is anti-OO
17:37:41 <mdurr_> I like the saying, any decently complex program has an implementation of lisp in it
17:37:42 <OscZA> how does this OO FP differ from say Haskell ?
17:38:44 <merijn> OscZA: Not much, I'd say. You can just pass objects to function in addition to abstract data types. Probably with the usual inheritance, etc.
17:39:03 <jlouis> merijn: actually they have structural subtyping
17:39:21 <jlouis> meaning that they have inferred "duck typing", more or less
17:39:26 <erikc> is there a toronto haskell group?
17:39:35 <ickabob> :t concatMap
17:39:37 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
17:39:38 <merijn> jlouis: I know, but I was to lazy to explain that :p
17:39:51 <ickabob> that blow my mind
17:40:12 <jlouis> @src concatMap
17:40:12 <lambdabot> concatMap f = foldr ((++) . f) []
17:40:15 <OscZA> merijn: is FP really anti-OO ?
17:40:19 <OscZA> im not sure what you mean
17:40:25 <merijn> OscZA: It isn't, that was my point
17:40:43 <merijn> I think the structural subtyping is in addition to normal subclassing. At least when it came up during compiler construction it was mentioned it doesn't always use structural subtyping
17:40:46 <ickabob> i love @src, does ghci have something similiar?
17:41:01 <OscZA> ok.. it just seems to be as the most prominent imperative languages atm are OO ?
17:41:01 <ivanm> @where goa
17:41:01 <lambdabot> http://haskell.org/haskellwiki/GHC/GHCi#GHCi_on_Acid
17:41:03 <ivanm> ickabob: ^^
17:41:13 <ickabob> ivanm: what does goa stand for
17:41:21 <ickabob> nvm
17:41:22 <ivanm> see the URL! :p
17:41:22 <micah> ghci on acid
17:41:23 <micah> :P
17:41:24 <ickabob> eah
17:41:25 <ivanm> ;-)
17:41:30 <systemfault> OscZA: OO makes it easier to modularise a program..
17:41:31 <ickabob> thanks :)
17:41:33 <companion_cube> OscZA: excepted C :)
17:41:35 <systemfault> It's just that.
17:41:35 <micah> @src fmap
17:41:35 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
17:41:37 <aavogt> what does ivanm stand for?
17:41:39 <merijn> OscZA: Haskell has a (slight) bias against OO, as far as I've noticed know. But there's other functional languages that do use OO
17:41:54 <ivanm> aavogt: technically, it isn't an acronym...
17:41:56 <ickabob> scheme!
17:41:57 <dobblego> systemfault, that's a common myth
17:41:59 <ivanm> but it's short for my name
17:41:59 * syntaxglitch considers the merit of classifying any language that encourages violating the Liskov Substitution Principle as "anti-OO"
17:42:19 <systemfault> I love imperative languages with FP constructs :)
17:42:36 <OscZA> Haskell has its own typing system.. how does it radically differ from say Java classes.. I believe you can "bundle" together some types in some type of your own
17:42:39 <jlouis> systemfault: ocaml, SML :P
17:42:57 <nanashi> u can model whatever you want in haskell or any language
17:43:08 <systemfault> jlouis: They seem too exotic for me though.. :(
17:43:11 <nanashi> 'goa' - it is great to hear of this =)
17:43:24 <jlouis> OscZA: Haskells type system is, perhaps, the most advanced for a general purpose language at the moment
17:43:30 <merijn> OscZA: You can see haskell type classes as Java interfaces. Except you don't need to specify all type classes (interfaces) at the same time or in the same place as you define your data type
17:43:41 <OscZA> merijn: from what facts can you infer that "slight bias against OO" ?
17:43:42 <micah> OscZA: data HoorayType = ConstructorOne Int String | ConstructorTwo String
17:43:44 <ickabob> my only gripe with haskell is that instead of thinking while your coding, I have to sit down for like 40 minutes prior to writing anything and actually think, this may not actually be a gripe. But accordinly I also have a harder time just sitting down and thinking up a problem to solve
17:43:50 <nanashi> what about seeing as it is
17:43:51 <dobblego> no you can't; Java interfaces are nothing like type-classes
17:44:03 <nanashi> rather than as if something were something else.
17:44:13 <systemfault> C++ concepts were close to that :(
17:44:14 <merijn> dobblego: Why not?
17:44:21 <systemfault> But.. no more.
17:44:22 <syntaxglitch> OscZA, pattern matching and algebraic data types are pretty thoroughly anti-OO
17:44:47 <monochrom> only because it is a closed sum in haskell
17:44:48 <dobblego> merijn, Java has nothing like type-classes i.e. implicit dictionary passing. interface K { T apply(U u); } is more like newtype K = K (t -> u)
17:44:52 <merijn> dobie_gi1lis: They specify the existence of a set functions for a class, type-classes specify the existence of a set of functions for a data-type.
17:45:07 <merijn> s/dobie_gi1lis/dobblego
17:45:39 <merijn> dobblego: I agree typeclasses are more generic, but if he comes from a java background that's as good a way to start out thinking what they do as any.
17:45:48 <dobblego> when you pass those interfaces implicitly, you have something like type-classes (see Scala). This is the crucially defining point of type-classes
17:45:50 <syntaxglitch> since the whole point of pattern matching is to look at the internal representation of a data structure, instead of hiding the internals and presenting an interface
17:46:08 <dobblego> merijn, no it's horrible and I spent years preventing that myth from infecting the minds of beginners and I will continue to do so
17:46:31 <merijn> dobblego: It is how I learned to understand them and it has served me fine.
17:46:33 <nanashi> it is good to see things as they are and not as if they were a thing other than what they are.
17:46:53 <micah> that's why all monad analogies usually fail :P
17:47:02 <dobblego> merijn, no it hasn't -- this is evident by your belief in something that is completely (not even approximately) untrue
17:47:19 <OscZA> syntaxglitch: ok, ill have to think about it.
17:47:34 <monochrom> Beware of circular logic.
17:47:34 <micah> typeclasses are quite different from interfaces
17:48:00 <micah> they have slighlty similar basic concepts
17:48:03 <micah> but not very much
17:48:11 <dobblego> no, they don't
17:48:21 <jlouis> I wouldn't, for the love of god, be able to see the similarity between a Java interface and a Haskell type class
17:48:22 <merijn> dobblego: Feel free to correct me then as your initial example hardly makes sense to me
17:48:22 <syntaxglitch> OscZA, existential types and higher-order functions are actually closer to OOP than algebraic data types
17:48:30 <monochrom> Beware of "understanding" too.
17:48:35 <dobblego> merijn, feel free to ask questions; it's very concise
17:48:42 <micah> the similarity is that they are a list of functions that work on a data type
17:48:44 <micah> it ends there
17:48:53 <monochrom> There is almost no objective measurement of "understanding". I dare say it's just a feeling.
17:48:53 <dobblego> micah, so is [a -> b]
17:49:06 <micah> dobblego: not what I meant
17:49:18 <OscZA> merijn: yes, I found that Java interfaces resemble Haskell classes.. but how do they really differ ? Haskell classes say that if you are this class.. you must provide these things.. right ?
17:49:29 <dobblego> micah, great, glad you agree
17:49:39 <ivanm> monochrom: now, if only you could use circular logic to prove that you should beware of circular logic...
17:49:53 <Ferdirand> the real question is: what can you do with a typeclass that you cannot do with [a -> b]
17:50:00 <tommd> I didn't know (or didn't remember) Coq to extract to Haskell - very cool.
17:50:07 <ivanm> Ferdirand: a lot
17:50:07 <tommd> s/to/could/
17:50:11 <dobblego> OscZA, they differ in the same way that a typewriter differs from an elephant. They are both "things" but it stops there
17:50:12 <merijn> OscZA: No, type classes don't say "you must provide these things", they say "these are the functions that implement the expected behaviour"
17:50:24 <companion_cube> tommd: are you saying that coq can interact with haskell ?
17:50:28 <ivanm> @src Monoid
17:50:28 <lambdabot> class Monoid a where
17:50:29 <lambdabot>     mempty  :: a
17:50:29 <lambdabot>     mappend :: a -> a -> a
17:50:29 <lambdabot>     mconcat :: [a] -> a
17:50:42 <ivanm> Ferdirand: ^^ how would [a -> b] get you a definition of mempty?
17:50:53 <tommd> companion_cube: I'm saying Coq declarations can be automatically translated to Haskell with a simple two lines.
17:51:04 <dobblego> ivanm, data Monoid a = M (a -> a -> a) a -- since Java has no concept of type-classes, its interface is equivalent to this
17:51:13 <companion_cube> ah... I hoped it was the opposite :/
17:51:15 <jlouis> tommd: extraction is a great feature of Coq
17:51:16 <tommd> companion_cube:
17:51:17 <tommd> Extraction Language Haskell.
17:51:17 <tommd> Extraction "hi" day.
17:51:38 <ivanm> dobblego: with the [a] -> a function as well?
17:51:47 <tommd> jlouis: Yes, I just thought it was "limited" to OCaml - which was cool in its own right, but Haskell... nice!
17:52:07 <dobblego> ivanm, you can get that by hiding the constructor and supplying a "default"
17:52:15 <ivanm> *nod*
17:52:29 <dobblego> ivanm, importantly, there is nothing like type-classes in Java, not even approximately
17:52:39 <nanashi> hello #haskellers
17:52:51 <micah> don't type-classes have to use something akin to a vtable
17:52:51 * ivanm must have missed the beginning of this conversation
17:53:01 <OscZA> dobblego: sorry, i didnt notice your lines.. too much information ;)
17:53:09 <dobblego> ivanm, just a myth that I have to dispel from beginner's mind all the time
17:53:27 <merijn> dobblego: I wouldn't even know where to begin asking question. If, as you are saying, my entire understanding of typeclasses is wrong, where do I begin figuring out what they are then?
17:53:43 <ivanm> dobblego: you talking about a literal representation or an analogous representation?
17:53:53 <syntaxglitch> one important way the the "Java interfaces" analogy is misleading is that type classes can use the instance type in nearly arbitrary ways
17:54:07 <dobblego> ivanm, even the most conservative approximation doesn't exist, so it's entirely dismissable
17:54:10 <syntaxglitch> it's not an interface to something of a particular type
17:54:23 <dobblego> merijn, I'm not sure your understanding of type-classes is wrong. I only know one thing you believe is wrong.
17:54:52 <ivanm> dobblego: well, yes, but just about any "equality comparison" between two languages is going to fail in subtle ways, and so you could argue about that for just about anything you want
17:55:01 <dobblego> ivanm, but it's not subtle
17:55:15 <ivanm> as such, Java has things that are similar to typeclasses up to a certain point
17:55:20 <ivanm> in that they're meant to achieve the same goal
17:55:28 <dobblego> ivanm, the "extends" keyword is more like type-classes than interfaces
17:55:37 <monochrom> I have zero tolerance of analogies.
17:55:39 * ivanm didn't mention the "i" word :p
17:55:48 <dobblego> but they aren't meant to achieve the same goal; it's not even approximate or subtle or close or any other attempts to save the idea
17:55:55 <tommd> monochrom: Much like our schools have zero tolerance of weapons?
17:55:57 <dobblego> monochrom, same :)
17:55:59 <merijn> dobblego: You do know that extends is used by interfaces in Java, right?
17:56:03 <syntaxglitch> for instance, I'm not sure how you'd understand a type class used for variadic functions with the instance depending on the return type in terms of Java interfaces
17:56:10 <dobblego> merijn, I implemented the Java specification for 4 years
17:56:11 <ivanm> monochrom: you're tolerance for analogies is like an extremists tolerance to reason? :p
17:56:32 <monochrom> "x is like y" is unfalsifiable.
17:56:39 <micah> analogies sometimes help with grapsing things but a lot of the time they give a false impression and they absolutely always break down
17:56:48 <nanashi> for any u there is an i
17:57:10 <ivanm> *your
17:57:10 <merijn> syntaxglitch: That depends on how you think, I consider the capabilities of typeclasses as a superset of the capabilities interfaces.
17:57:11 <tommd> > let isLike x y = x > y - 5 && x < y + 5 in 5 `isLike` 6
17:57:12 <lambdabot>   True
17:57:22 <dobblego> here is an analogy if you truly insist; given interface K { U apply(T t); } is very much like Haskell's newtype K = K (t -> u)
17:57:48 <dobblego> no such analogy exists for Java interfaces; even approximately
17:58:20 <dobblego> that should be T -> U
17:59:04 <ivanm> eh, my knowledge of Java is draining away day by day
17:59:07 <ivanm> as it should be! :D
17:59:44 <nanashi> java is like most things, on its way out as soon as it has finished its way in.
17:59:57 <micah> java is the new cobol
18:00:17 <nanashi> cobol is the ? =)
18:00:23 * bremner_ thinks people should have to program in COBOL for a bit before sneering at Java
18:00:26 <companion_cube> except there is no website in cobol ^^
18:00:31 <micah> bremner_: of course
18:00:38 <micah> bremner_: java is much nicer than cobol
18:00:43 <dobblego> in Haskell, we pass "Ord" implicitly. We do this by making Ord a type-class instead of a data type where it would be explicit (newtype Ord a = Ord (a -> a -> Ordering)). In Java, we pass Comparator<A> *explicitly*. We do this by using an interface. In Java, if we ant to pass it implicitly, we... oh wait, Java has nothing like type-classes, stop now.
18:00:48 <shapr> cobol is so much nicer than machine language.
18:00:52 <nanashi> surely there is cobol websites
18:01:04 <bremner_> shapr: disagree
18:01:04 <merijn> micah: And getting stabbed in the lack is much nicer then getting stabbed in the face
18:01:05 <micah> machine language is so much nicer than... turing machines?
18:01:11 <shapr> bremner_: hah
18:01:14 <merijn> err
18:01:16 <merijn> s/lack/leg
18:01:23 <merijn> michael|: Doesn't mean I want to be stabbed in my leg...
18:01:23 <syntaxglitch> you can write webapps in cobol, even! http://www.coboloncogs.org/INDEX.HTM
18:01:34 <nanashi> a language is not difficult when it is used for the task(s) it is designed for.
18:01:34 * companion_cube runs away
18:01:46 <syntaxglitch> machine language is probably easier than INTERCAL
18:01:47 <ivanm> I take it "cobol on cogs" is a spoof of "ruby on rails"?
18:01:47 <nanashi> even machine language was not difficult - for its purpose it was normal.
18:01:59 <bremner_> well, honestly, I'd rather write assembly than COBOL (nobody really writes machine language do they?)
18:02:17 <[swift]_> argh, i'm very confused by the writer monad. if i want to be able to do: tell "Blah", then should expect runWriter to return (a, [String]) or (a, String)?
18:02:19 <nanashi> bremner_: almost not even machines do! =)
18:02:26 <ivanm> bremner_: there _might_ be some hardcore embedded programmers that do...
18:02:49 <companion_cube> bremner_: depends on if you make a difference between machine language and assembly, i guess
18:02:58 <merijn> A lot of embedded programmers don't even use assembly
18:03:01 <[swift]_> basically, is the writer monad, when used with strings, supposed to be building up a list of strings, or appending to a single string?
18:03:25 <nanashi> [swift]_: should be list of strings
18:03:57 * syntaxglitch once wrote a program that did some math-heavy calculations in GNU Make, not sure if that was better or worse than COBOL
18:04:05 <nanashi> =)
18:04:12 <OscZA> dobblego: Java has Comparable though ? isnt that closer to Haskell type classes than Comparator ?
18:04:22 <syntaxglitch> COBOL at least has, uh, numbers
18:04:55 <nanashi> file management helped to grow language evolution
18:05:11 <dobblego> OscZA, Java has Comparable, which is used with extends/implements. Inheritance is Java's effort at implicit dictionary passing. While this is a more brave attempt to save the idea than "like interfaces", there are some very crucial differences to type-classes and the attempt fails.
18:05:27 <FliPPeh> byorgey: Are you available?
18:05:36 <dobblego> OscZA, have you seen Functional Java?
18:05:36 <ivanm> preflex: seen byorgey
18:05:37 <preflex>  byorgey was last seen on #haskell 3 hours, 50 minutes and 43 seconds ago, saying: great.  I'm actually planning to put out a standalone second edition, hopefully sometime later this spring
18:05:50 <OscZA> dobblego: no
18:05:51 <syntaxglitch> dobblego, isn't that called "Scala"? :)
18:06:12 <dobblego> syntaxglitch, no, Scala has an implicit keyword. Functional Java is written using only Java.
18:06:29 <ivanm> syntaxglitch: don't argue; dobblego wrote it (or at least helped to write it)
18:06:41 <nanashi> notice the smileys.
18:06:52 <dobblego> ivanm, Scala or Functional Java?
18:06:58 <syntaxglitch> dobblego, that sounds painful :(
18:06:59 <ivanm> dobblego: Functional Java
18:07:05 <ivanm> though you help with scalaz, right?
18:07:05 <OscZA> dobblego: ok.. i dont know the term "implicit dictionary passing", you make it sound that its an important concept
18:07:10 <dobblego> ivanm, I wrote Functional Java and a small part of Scala
18:07:13 <dobblego> ivanm, yes
18:07:41 <systemfault> Let's all use clojure :P
18:07:42 <dobblego> OscZA, it's just what type-classes buy you. I'd start by understanding type-classes, but do not use the analogy to interfaces; it's a disastrous diversion
18:07:46 <systemfault> j/k
18:07:50 <ivanm> dobblego: btw, did any bpfg people express interest in the hackathon?
18:08:01 <nanashi> java was written in scala
18:08:02 <dobblego> ivanm, no response on the list, but they are a quiet bunch
18:08:04 <nanashi> or
18:08:06 <ivanm> yeah
18:08:13 <ivanm> nanashi: huh?
18:08:21 <micah> so will anyone answer my parsec question now? :)
18:08:22 <siracusa> Can you bind multiple addresses to the same socket via bindSoccket?
18:08:23 <ivanm> scala compiles down to the JVM
18:08:36 * ivanm doens't know parsec
18:08:40 <Cale> dobblego: Is it really that bad? I suppose it's not really great as an analogy to hold on to for very long, since there are differences in how they work and what they're capable of.
18:08:44 <micah> when you make parsec work on something other than String
18:08:45 <nanashi> thats it jvm sorry (java bytecode assembly ?)
18:08:54 <micah> how do you do anything
18:08:57 <micah> becuase you can't use char or string
18:09:00 <ivanm> nanashi: something like that
18:09:06 <ivanm> micah: parsec-3 supports bytestrings
18:09:10 <aavogt> @type GenParser
18:09:11 <lambdabot> Not in scope: data constructor `GenParser'
18:09:11 <[swift]_> I can't figure out what i'm doing wrong with the Writer monad. Anyone see the problem? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24151#a24151
18:09:13 <ivanm> it uses functions IIRC
18:09:19 <ivanm> @src GenParser
18:09:19 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
18:09:19 <Cale> dobblego: But at least, if you're going to compare typeclasses to *something* in Java, it's probably better that you're comparing to interfaces than to, say, classes.
18:09:23 <ivanm> @hoogle GenParser
18:09:23 <lambdabot> Text.Parsec.ByteString type GenParser t st = Parsec ByteString st
18:09:24 <lambdabot> Text.Parsec.String type GenParser tok st = Parsec [tok] st
18:09:24 <lambdabot> Text.Parsec.ByteString.Lazy type GenParser t st = Parsec ByteString st
18:09:24 <dobblego> Cale, yes, because it provides a diversion from the point of type-classes. It causes ambiguity about answering the question "When should I use a type-class?"
18:09:31 <ivanm> aavogt: ^^ what you meant?
18:09:32 <micah> I'm trying to use parsec on a [Token]
18:09:33 <merijn> Cale: Apparently it is because we just spend like 20 minutes arguing and then I gave up
18:09:43 <aavogt> yeah
18:09:45 <dobblego> Cale, the extends/implements keyword is the closest you'll get, which is not very close at all
18:09:59 <nanashi> tune your cars then they will drive good the next time you want to take it for a spin.
18:11:32 <syntaxglitch> Cale, half-correct but fundamentally misleading analogies are worrisome, though, precisely because they lead people astray with partial understanding
18:11:32 <OscZA> dobblego: if you have some custom written Java class, you can mark it to "implement" "Comparable" that means you are required to provide certain methods with certain types (signature) ? I understand that in Haskell when you have defined some custom data type, you can define it to be "instance of" "Comparable" ...
18:12:15 <syntaxglitch> Like thinking of functors or monads as "containers", which works for some things but makes it really confusing when looking at, say, ((->) a)
18:12:33 <aavogt> syntaxglitch: is that really so confusing?
18:12:34 <dobblego> OscZA, type-classes are a little different
18:12:59 <syntaxglitch> Or thinking of monoids in terms of "appending", not that the language encourages that or anything
18:13:00 <dobblego> yes monads are not containers or space-suits or anything stupid and diverting like that either!
18:13:04 <aavogt> syntaxglitch: is say, Reader confusing as a container?
18:13:06 * dobblego puts on punching gloves
18:13:08 <kmc> no they're totally burritos
18:13:09 <nanashi> =)
18:13:15 <nanashi> they are what they are
18:13:19 <liyang> [swift]_: tell ["All unique problem!"]
18:13:23 <sbpaul> i'm looking for an article that's supposed to introduce people to FP/OOP/IP
18:13:29 <sbpaul> it's like "the progression of a programmer"
18:13:30 <syntaxglitch> monads are just monoid objects on an endofunctor category, it's simple enough
18:13:34 <sbpaul> but it is NOT "the evolution of a _______ programmer"
18:13:45 <nanashi> personal blogs, sbpaul
18:13:49 <bremner_> dobblego, and other experts: I'd be happy for comments on http://www.cs.unb.ca/~bremner/blog/posts/functional-jvm/
18:13:50 <dobblego> http://projects.tmorris.net/public/what-does-monad-mean/artifacts/1.1/chunk-html/ar01s04s03.html Monad metaphors are stupid
18:13:53 <Cale> syntaxglitch: I think (->) a is a particularly good container-like functor, myself ;)
18:13:56 <sbpaul> it's a specific article
18:14:03 <[swift]_> liyang: so Writer concatenates, rather than producing a list. i see. thanks!
18:14:10 <Cale> syntaxglitch: It's things like IO a where the container analogy starts getting hard :)
18:14:22 <liyang> [swift]_: your writer takes elements of the monoid ([String], ++)
18:14:25 <Entroacceptor> syntaxglitch: thanks, that actually helped me understanding
18:14:39 <Cale> you can think of a function a -> b as being an a-indexed container of b values.
18:14:56 <Cale> (like a giant array with one value of type b for each value of type a)
18:15:05 <dobblego> bremner_, there are a group of us who regularly discuss how to best target the JVM. Perhaps with a Haskell-like language
18:15:21 <sbpaul> i'd love to see a good FP lang on top of the JVM
18:15:22 <syntaxglitch> Cale, it took me an embarrassing amount of time for me to realize that you can, say, apply fmap to an IO value without binding it in a do block or whatever :(
18:15:43 <ivanm> sbpaul: scala is probably the closest you can get atm
18:15:47 <[swift]_> liyang: the implied ++ operator is because the instance of Monoid for lists uses ++, right?
18:16:00 <sbpaul> yeah
18:16:05 <sbpaul> i named my last album "scala"
18:16:07 <liyang> [swift]_: Well, only because in your instance, for any alpha, ([alpha], ++) is a Monoid.  yes, what you just said.
18:16:11 <sbpaul> no joke
18:16:11 <OscZA> syntaxglitch: I understand that.. but I thought that given my Java/OO background I thought maybe you guys could provide some clues on what really ARE the differences... I understand if its because I dont understand some fundamental concept in Haskell... I guess its type classes in Haskell ?
18:16:25 <dobblego> sbpaul, see Scalaz for Haskell-like libraries on the JVM
18:16:37 <benmachine> @quote endofunctors.shit
18:16:38 <lambdabot> copumpkin says: a monad is just a lax functor from a terminal bicategory, duh. fuck that monoid in category of endofunctors shit
18:16:44 <benmachine> that is my input.
18:16:48 <syntaxglitch> heh
18:17:03 <[swift]_> liyang: OK, i think i'm getting it now. I remember reading about this in RWH but i guess it didn't click until now
18:17:30 <merijn> OscZA: I think the only real way to understand the differences is starting to learn and program haskell
18:17:45 <sbpaul> that's true for every language
18:17:52 <sbpaul> steep-ass learning curve for haskell though
18:17:53 <OscZA> merijn: you are right
18:17:53 <dobblego> OscZA, it's best to forget your Java/OO background.
18:18:05 <merijn> OscZA: It will be time well spend
18:18:07 <dobblego> OscZA, in fact, your inability to forget it will be the biggest difficulty
18:18:27 <OscZA> dobblego: really.. there must be something that I can use ?
18:18:33 <liyang> [swift]_: had your Writer been producing Strings (rather than [String]s), then it'd concatenate Strings rather than lists of strings, and then you'd write tell "foo".
18:18:45 <mdurr_> OscZA: continuing to have to use it will be the biggest difficulty!
18:18:46 <dobblego> OscZA, I wish there was. I've been trying to find a way to help that for a long time.
18:18:57 <ivanm> dobblego: help what? forget analogies?
18:19:00 * syntaxglitch also notes that ((->) a) as a functor is a great way to obfuscate code by using fmap instead of (.)
18:19:10 * ivanm suggests running at a brick wall
18:19:18 <benmachine> :t fmap fmap fmap
18:19:18 <merijn> I think it also highly depends on which OO languages
18:19:19 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
18:19:19 <benmachine> etc.
18:19:21 <ivanm> or just to start coding *shrug*
18:19:27 <dobblego> ivanm, specifically, help people learn "Haskell" (advanced programming) when they have been exposed to degenerate notions of programming (specifically, Java)
18:19:34 <[swift]_> liyang: i got ya now. for some reason i expected it to accumulate a list of the things i was tell'ing it.
18:20:12 <merijn> python gave me good starting place for grokking a lot of concepts (first class functions, generator expressions (which are sorta similar to lazy lists), list comprehensions and stuff like map/reduce)
18:20:18 <ivanm> dobblego: *shrug* just get them to go through tutorials, start coding, and tell them to not bother with analogies, etc. and think of it as completely new/different
18:20:30 <merijn> To bad python doesn't have function composition or I wouldn't be so annoyed with it now
18:20:34 <dobblego> ivanm, I envy your naivety to the dilemmas that await :)
18:20:37 <ivanm> merijn: *shudder* I _hate_ python's list comprehensions
18:20:43 <ivanm> dobblego: heh
18:20:46 <OscZA> ok you superhumans.. have you ALWAYS coded functional.. what made you turn into it? ;)
18:20:53 <companion_cube> too bad python does not have true lambda functions
18:21:01 <merijn> companion_cube: It does
18:21:16 <ivanm> OscZA: *shrug* Haskell was suggested to me by someone on a scholarship interview panel when I said I had liked the first year scheme subject
18:21:18 <syntaxglitch> python is fun, I tried to implement continuation-based cooperative multithreading using python's generators once
18:21:24 <liyang> OscZA: while I was doing my maths undergrad, my fellow CompScis complained about this horrible language called ML they had to learn.
18:21:25 <syntaxglitch> it mostly worked
18:21:26 <dobblego> lambda f: lambda g: lambda x: f(g(x))
18:21:27 <merijn> OscZA: I learned Java and python first, then C and assembly and then learned a bit of ocaml in out theoretical CS course.
18:21:34 <companion_cube> from the point of vue of haskell programmers, it has, but comparatively to,say, lisp, it does not
18:21:37 <liyang> OscZA: it kind of went downhill from there.
18:21:54 <ivanm> I had done some Python, but wrote it in more of an OOP style; and IIRC I hadn't really done much programming in the 6 months before I taught myself Haskell over summer
18:22:11 <merijn> OscZA: Then started with lisp and haskell in my own time later, mostly because my python code become more functional over time and haskell is prettier when doing functional programming
18:22:12 * ivanm started gulping down the Haskell "kool-aid" rather quickly
18:22:20 * syntaxglitch was mostly a C# and Python programmer, and had dabbled a bit in Scheme
18:22:44 * companion_cube discovered programmation at school with ocaml 8)
18:22:46 <ivanm> I liked scheme because I had always wanted to learn lisp from being interested in AI when I was younger
18:22:50 <syntaxglitch> I got interested in Haskell because it was the first language I'd seen in years that made me actually have to put in some effort to learn it
18:22:58 <merijn> ivanm: Haskell's list comprehensions are more compact then python's. But everything I learned about them in python is pretty directly transferable to haskell
18:22:59 <ivanm> and I wasn't afraid of parentheses like most students ;-)
18:23:05 <SamB_XP> syntaxglitch: yay!
18:23:11 <FliPPeh> Parantheses are awesome
18:23:12 <ivanm> merijn: I don't like verbosity
18:23:14 <FliPPeh> Clear code.
18:23:14 <SamB_XP> you could also try VHDL sometime
18:23:16 <merijn> I still need to really learn lisp
18:23:19 <syntaxglitch> ivanm, don't get me started, I still miss scheme's syntax
18:23:19 <ivanm> which is what had always annoyed me with Java
18:23:28 <ivanm> syntaxglitch: :o
18:23:30 <sbpaul> > 100!
18:23:31 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
18:23:34 <SamB_XP> I guarentee it will take effort to learn ;-P
18:23:36 * liyang learnt BASIC, C, x86 asm, C++, Perl, O'Caml, Haskell, and from that point onwards learning a new language was simply a matter of getting used to the syntax + libraries.
18:23:36 <merijn> I'm thinking of doing Clojure since that runs on the JVM I can run it on my android phone
18:23:38 <OscZA> ivanm: good reason.. im really learning Haskell because of my interest in AI and related subjects
18:23:39 <sbpaul> > fac 100
18:23:40 <lambdabot>   Not in scope: `fac'
18:23:43 <sbpaul> hmhm
18:23:45 * ivanm doesn't miss it, but isn't completely anti-sexps
18:23:57 <syntaxglitch> one of these days I'm going to write a Haskell dialect that uses lisp-y non-syntax
18:23:57 <SamB_XP> liyang: you have yet to learn VHDL, though ?
18:23:58 <ivanm> sbpaul: you want factorial?
18:24:02 <sbpaul> i do
18:24:10 <ivanm> > let fact = product . enumFromTo 1 in fact 100
18:24:11 <fax> syntaxglitch, why?
18:24:11 <lambdabot>   933262154439441526816992388562667004907159682643816214685929638952175999932...
18:24:20 <ivanm> sbpaul: ^^
18:24:24 <sbpaul> ic
18:24:30 <syntaxglitch> fax, why not? I don't really like syntactic sugar, mostly.
18:24:32 <liyang> SamB_XP: I've seen enough of it via my dad's job.
18:24:40 <companion_cube> OscZA: are you supposed to learn haskell to do AI ?
18:24:52 <fax> syntaxglitch I didn't say DONT
18:25:14 <merijn> syntaxglitch: I started trying to design a haskell/python hybrid, but so far it looks like it'll just turn out to be strongly-typed lazy scheme >.>
18:25:16 <ivanm> liyang: what character is that meant to be before "my"?
18:25:20 * ivanm has an empty box
18:25:39 <liyang> SamB_XP: I don't think I'd learn anything from playing with it, and if I do need it in the future for whatever reason I ought to be able to pick it up quickly enough.
18:25:46 <companion_cube> merijn: statically typed scheme would be so awesome \o/
18:25:47 <OscZA> companion_cube: no, i just thought it might be helpful to learn some notion of functional kind of "reasoning" to think about AI and related problems
18:25:48 <liyang> ivanm: er I'm not sure
18:26:04 <syntaxglitch> merijn, how on earth did you get scheme out of Haskell+Python?
18:26:12 <ivanm> syntaxglitch: liskell?
18:26:14 <liyang> ivanm: looks like a space though I might have spazed out a bit on the keyboard and typed something weird.
18:26:16 <sbpaul> > sum (map (\x->ord x-48) (show (product [1..100])))
18:26:17 <lambdabot>   648
18:26:20 <sbpaul> aHA
18:26:22 <merijn> syntaxglitch: Because syntax is irrelevant?
18:26:29 <sbpaul> is there a better way to do that
18:26:31 <ivanm> liyang: some weird non-ASCII space? :p
18:26:31 <merijn> syntaxglitch: I was thinking at an AST level
18:26:42 <merijn> syntaxglitch: And then combining the two really just becomes lisp
18:27:08 <syntaxglitch> ivanm, heard of it--didn't seem to be very alive, though
18:27:15 <ivanm> yeah
18:27:33 <ivanm> personally, I prefer Haskell's syntax to sexps for ease of function composition if nothing else
18:27:34 <SamB_XP> liyang: it's unlikeness to anything I'd learned before rivals that of Haskell -- and I learned Haskell first!
18:27:45 <ivanm> and whilst I can live with sexps, they tend to get rather messy rather quickly IMHO
18:27:55 <liyang> ivanm: I don't know. Just copy/pasted that bit into xxd and it seems to think it's a bog standard 0x20.
18:28:03 <Saizan> > sum . map digitToInt . show . product $ [1..100]
18:28:03 <ivanm> weird :s
18:28:04 <lambdabot>   648
18:28:29 <mdurr_> anyone use leksah and love it more than emacs?
18:28:34 <merijn> You have statements and expressions, well. The expression part is pretty much just haskell. Once you start wanting to generalize statements into "functions" and creating statement closures how is that different from lisp?
18:28:38 <syntaxglitch> ivanm, personally I like the idea of sexps with syntactic whitespace
18:28:49 <ivanm> > ord ''
18:28:49 <lambdabot>   <no location info>:
18:28:50 <lambdabot>      lexical error in string/character literal at chara...
18:28:53 <ivanm> hmmm...
18:29:03 <aavogt> merijn: you have statements in haskell too. it's not as if do notation is made up of expressions...
18:29:11 <aavogt> or every line is an expression
18:29:13 <merijn> aavogt: I know
18:29:28 <merijn> That's how I realized it should be pretty easy to compile it to haskell :p
18:29:58 <pastorn> mdurr_: sorry :(
18:30:06 <pastorn> only ED THE STANDARD EDITOR here
18:30:15 <shapr> ooh ed!
18:30:30 <mdurr_> heh
18:30:33 <SamB_XP> pastorn: I thought the cult of ed(1) was a myth!
18:30:36 <ivanm> mdurr_: the writers of leksah seem to think it's the "haskell IDE of choice" solely because it has more downloads than yi...
18:30:41 <liyang> SamB_XP: which part of VHDL in particular? The behaviour model parts is just bog-standard imperative programming, the rest is just digital electronics.
18:31:03 <SamB_XP> ivanm: if they mean the Haskell IDE written in Haskell, sure!
18:31:05 <ivanm> liyang: those boxes are back! "the rest is just digital electronics."
18:31:19 <pastorn> mdurr_: i have actually never gotten leksah to work properly :(
18:31:21 <ivanm> SamB_XP: that is different from "Haskell IDE" though (and they refuse to admit that)
18:31:26 <benmachine> they are reverse-video backslashes
18:31:37 <SamB_XP> liyang: I don't think either is bog-standard
18:31:39 <liyang> ivanm: is anyone else seeing those? 
18:31:54 <SamB_XP> there was a guy in my class who as trying to do a while loop that took no time
18:31:54 <mdurr_> pastorn: I got it to work once, but didn't feel like spending the time to configure it, so just wondering if it is worth it
18:31:57 <ivanm> liyang: dunno
18:32:00 <SamB_XP> s/as/was/
18:32:03 <benmachine> liyang: I saw something
18:32:03 * syntaxglitch writes Haskell using SciTE and some terminal windows, screw you people with your fancy IDEs
18:32:06 <ivanm> benmachine: huh?
18:32:19 <ivanm> syntaxglitch: IDE? what IDE? I use emacs!
18:32:25 <liyang> I'm using Colloquy. I may be pressing some key combination for colour codes without knowing it.
18:32:32 <syntaxglitch> ivanm, IDE and/or operating system, sorry
18:32:36 <ivanm> hmmm...
18:32:37 <Zao> I thought that most of the industry had moved to Verilog from VHDL?
18:32:42 <ivanm> syntaxglitch: *sigh*
18:32:44 <SamB_XP> Zao: possibly!
18:32:48 <pastorn> VI VI VI editor of the beast
18:32:51 <SamB_XP> Zao: I think they're crazy, personally
18:32:55 <benmachine> I didn't get along with colloquy
18:32:57 <SamB_XP> VHDL has some decent types
18:33:12 <mdurr_> I would write haskell in my own os, but it only boots to an ascii smiley face
18:33:20 <syntaxglitch> ivanm, given everything emacs can do I wonder why emacs fans ever use anything else
18:33:37 <FliPPeh> What's the relationship between monad transformers and the applicative type class?
18:33:38 <aavogt> liyang: can you help me rewrite hlist using type families?
18:33:51 * companion_cube cannot install yi with ghc6.12
18:33:56 <pastorn> is there VIM key bindings for emacs?
18:33:57 <liyang> aavogt: er no?
18:34:01 <ivanm> syntaxglitch: it sucks as a browser
18:34:03 <SamB_XP> pastorn: of course!
18:34:05 <benmachine> ivanm: http://www.srcf.ucam.org/~bm380/irc.png
18:34:06 <ivanm> and it doesn't have concurrency
18:34:13 <SamB_XP> or vi, at any rate
18:34:16 <ivanm> hopefully emacs 24 will fix that! :p
18:34:29 <SamB_XP> pastorn: look up "viper"
18:34:30 <ivanm> benmachine: aha!
18:34:30 <syntaxglitch> ivanm, the web's overrated anyhow
18:34:32 <pastorn> (i wanna change the standard editor in Visual Studio for something better... getting vim in there is pretty messy)
18:34:35 <merijn> mdurr_: There's a barebones OS written in haskell
18:34:37 <aavogt> liyang: then there's still lots to learn
18:34:43 <syntaxglitch> and for concurrency, I dunno. Run more than one copy of emacs?
18:34:47 <FliPPeh>       nfortunately, monads do not compose as nicely as applicative functors (yet
18:34:48 <mdurr_> merijn: house right?
18:34:50 <FliPPeh> another reason to use Applicative if you dont need the full power that Monad
18:34:51 <ivanm> pastorn: there is a python-based IDE that uses vim as the editor
18:34:52 <FliPPeh> What does that mean?
18:34:52 <merijn> mdurr_: Yeah
18:34:54 <FliPPeh> provides), but som
18:35:02 <ivanm> (it apparently supports emacs as well but I couldn't get it to work at the time)
18:35:25 <mdurr_> merijn: yeah I saw it, interesting idea
18:35:29 <liyang> aavogt: type families seem like a cheap trick after using Agda / dependent types.
18:35:40 <pastorn> ivanm: yeah, i have some python stuff, but with that i have to use vim as a standalone editor and then i import/export files between vim and VS
18:35:41 <merijn> Anyhoo, bed time
18:35:55 <ivanm> pastorn: I mean an IDE written in Python
18:35:58 <pastorn> pretty annoying, i want it to replace the standard VS editor
18:36:11 <pastorn> ivanm: heh, ok :)
18:36:14 <SamB_XP> ivanm: there are actually some reasons to use VS, I've discovered
18:36:21 <liyang> benmachine: I don't know. :( Hello kern! Haven't seen you in a while.)
18:36:22 <SamB_XP> it actually has a pretty decent debugger
18:36:34 <ivanm> SamB_XP: O RLY?
18:36:35 <SamB_XP> at least if you've the PDBs
18:36:47 <ivanm> "PDBs" ?
18:36:49 * syntaxglitch unintentionally writes some code that brings GHC to its knees
18:36:53 <SamB_XP> the debugging symbols
18:36:59 <ivanm> ahhh
18:37:00 <aavogt> liyang: I suppose ensuring termination is quite expensive
18:37:03 <syntaxglitch> Never seen GHC choke like that :(
18:37:09 * ivanm nowadays pretty much just writes haskell
18:37:19 <SamB_XP> I mean, you'd want something more like Olly if you had no symbols
18:37:40 <mdurr_> gee, wikipedia has 100k + categories, my haskell parser has been parsing 10k for 2 hours and at 500Mb of memory *sigh* time to do some more profiling
18:37:55 <liyang> aavogt: I understand the idea behind type families, I've just never gotten around to actually putting it to use yet, seeing as I haven't had a chance to hack on anything in Haskell for a while.
18:38:46 <SamB_XP> I've been reading that VS can actually pull source out of your VCS based on information stored in the PDBs if you set up your build right!
18:39:24 <SamB_XP> (apparantly this can be done for many VCSes, including SVN...)
18:40:04 <syntaxglitch> public service announcement, don't do this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24153#a24153
18:40:06 <syntaxglitch> :(
18:40:18 <OscZA> I think there are many bright minds on this channel.. may I ask what is the most influential book you guys have read?
18:40:31 <omg911> has anyone gotten the hmatrix package to install sucessfully on mac or linux?
18:41:02 <ivanm> OscZA: in what sense?
18:41:09 <SamB_XP> OscZA: you may ask, but I can't for the life of me answer any question involving "what was the most FOO book you've ever read" unless FOO is something really specific ...
18:41:26 <syntaxglitch> OscZA, Hofstadter's Godel, Escher, Bach made a huge impression on me as a kid, for what that's worth
18:41:43 <syntaxglitch> But having read it again recently it was kind of disappointing
18:42:02 <SamB_XP> GEB is almost depressing
18:42:05 <ivanm> if "influential" implies "had an influence on your life/personality/etc." than the various humorous anthologies of feynmans stories
18:42:13 <liyang> OscZA: and in a similar vein, Krner's The Pleasures of Counting, though I haven't read it yet.
18:42:14 <dmhouse> The Pragmatic Programmer I found pretty inspiring.
18:42:42 <SamB_XP> "hardest to read" might have been the first chapter of waverly ;-P
18:42:48 <omg911> Flatland
18:43:07 <liyang> Oh, and Mathematics Made Difficult. That was awesome.
18:43:22 <mdurr_> me... read?
18:43:27 <SamB_XP> liyang: huh ... interesting concept
18:43:37 <fax> most influencial book: The Bible
18:44:14 <SamB_XP> I said a couple days ago that I'd probably not say "Math is hard, let's go shopping!", but rather "shopping is hard, let's do Math!"
18:44:31 <liyang> SamB_XP: http://www.reddit.com/r/math/comments/b7i3u/mathematics_made_difficult_pdf/
18:45:02 <nanashi> =)
18:45:23 <SamB_XP> I suppose the bible would have to be it, but I kindof figured that didn't count somehow ... kinda like if you ask someone in here what their favorite language was, they'd probably assume you meant "other than Haskell" if Haskell was their favorite?
18:45:25 * liyang isn't so familiar with geometry/topology though, so the latter parts of the book is a bit wasted on him.
18:45:28 * syntaxglitch kills GHC after it reaches 1.5 GB of memory and 100% CPU trying to type check something
18:45:57 * liyang 's favourite language is JavaScript.
18:46:06 <maurer_> How do I pass flags to gcc through ghc?
18:46:23 <nanashi> syntaxglitch uh oh =
18:46:25 <ivanm> --opt- I think
18:46:25 <nanashi> )
18:46:25 <mdurr_> liyang: I'll pretend I didn't see that
18:47:00 <OscZA> I just ment in general... GEB is my choice too.
18:47:27 * syntaxglitch was tinkering with some code earlier and some sort of intermediate type was gigantic... completely slaughtered GHC trying to typecheck it
18:47:51 <Saizan> doing heavy type hackery?
18:47:55 <OscZA> Are there any books like that, like GEB?
18:48:01 <syntaxglitch> Saizan, nope
18:48:23 <syntaxglitch> Saizan, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24153#a24153 is similar code, stripped of anything worthwhile
18:49:00 <liyang> mdurr_: I love trolling for reactions. But in all seriousness, there are nice bits of JS, as long as you pretend to yourself that it's a restricted subset of Scheme.
18:49:15 <Saizan> oh, you're just hitting the worts cases of Hindley-Milner or?
18:49:31 <syntaxglitch> load that code in GHCi and try ":t uh.oh" to see what the problem is
18:49:59 <maurer_> ivanm: Seems to be -optc. Thanks though.
18:50:00 <mdurr_> liyang: actually I like JS as a language, its the browser quirks that make it painful
18:50:18 <nanashi> i had less problems with javascript than java
18:50:38 <syntaxglitch> Saizan, probably, the original code all unified to some simple types but the inferred intermediate types were insane I expect
18:50:50 <Entroacceptor> after having thought for a while I'd say that the book about nonviolent communications had the most impact on me recently
18:51:05 <OscZA> ivanm: let's say influential on your intellectual life ? ;) I dont care what made you wear those leather pants
18:51:11 <nanashi> Entroacceptor =)
18:51:41 <liyang> mdurr_: let's not talk about the DOM here. :)
18:52:10 <syntaxglitch> also, loading the code I hpaste'd into GHCi and entering "let x = down.down.down.down.down.up.up.up.up" will do Bad Things
18:52:54 <liyang> Entroacceptor: which one in particular? I'm interested but haven't gotten around to it yet.
18:53:45 * syntaxglitch is actually kind of surprised that GHC doesn't bail out when the inferred types get that large, given how stupidly shallow the default recursion depth for finding type class instances is...
18:54:10 <ivanm> OscZA: I don't have any leather pants...
18:54:13 <Entroacceptor> liyang: nvc - a language of life
18:54:28 <ivanm> and feynman's stories were partially influential on how I act and think *shrug*
18:54:37 <ivanm> intellectually, nothing much...
18:54:44 <OscZA> hehe.. what books are they ?
18:54:48 <ivanm> Haskell/FP in general has been influential
18:54:52 <Entroacceptor> and otherwise... lots of stuff
18:54:58 <ivanm> OscZA: "Surely you're joking Mr Feynman", etc.
18:55:01 <nanashi> =)
18:55:14 <OscZA> ok..
18:55:15 <ivanm> OscZA: http://en.wikipedia.org/wiki/Feynman#Popular_works
18:55:19 <syntaxglitch> Surely You're Joking was by far the best, I think
18:55:29 * companion_cube --> GEB too, maybe
18:55:50 <syntaxglitch> but Feynman is worth reading about even if the book as a whole is disjointed
18:55:56 <ivanm> syntaxglitch: agreed (to both)
18:56:00 <syntaxglitch> what with him being Feynman and all
18:56:42 <Entroacceptor> Sophie's World paved the way to GEB for me
18:56:54 <OscZA> ordered.
18:56:55 <ivanm> who else would go and deliberately find ways to piss off censors? :p
18:57:10 * syntaxglitch was like... 13 or something when he read GEB
18:57:11 <Entroacceptor> and Illuminatus!
18:57:13 <ClaudiusMaximus> OscZA: i got quite into roger penrose "the emperor's new mind" when i was young
18:57:14 <ivanm> OscZA: there's various copies online IIRC
18:57:18 <ksf> @tell jlouis I like torroid as name for haskell-torrent. A torroid is a torrent in the category of haskell programs.
18:57:19 <lambdabot> Consider it noted.
18:57:23 * ivanm mainly reads fiction, anyway
18:57:31 <shapr> ksf: What about combinatorrent?
18:57:44 <OscZA> ClaudiusMaximus: Ive read about that stuff.. the quantum mind theory
18:57:46 <ivanm> that reminds me...
18:57:47 <syntaxglitch> ivanm, probably quite a few people would consider it
18:57:49 <theorbtwo> Too long and hard to spell?
18:57:53 <OscZA> but thought thats mostly crankery
18:57:57 <ksf> too long, too bad a pun and not obviously haskell enough.
18:58:07 <ClaudiusMaximus> OscZA: more the earlier chapters on turing machines and fractals and things
18:58:09 <ksf> ...better than haskell-torrent, though.
18:58:13 <shapr> ksf: Well awright then...
18:58:18 <ivanm> syntaxglitch: consider what?
18:58:25 <theorbtwo> azeureus is also long and hard to spell, of course.
18:58:28 <syntaxglitch> ivanm, piss off censors
18:58:35 <theorbtwo> In fact, I think I just misspelled it.
18:58:41 <theorbtwo> horrent?
18:58:42 <syntaxglitch> ivanm, few people are simultaneously as smart and ballsy as feynman was
18:59:02 <ivanm> syntaxglitch: yeah ;-)
18:59:08 <ivanm> and socially inept
18:59:08 <OscZA> ClaudiusMaximus: ok.. I have his "The road to reality"
18:59:27 <Entroacceptor> oh, yes, Jurassic Park lead me to love fractals  :)
18:59:42 <liyang> Entroacceptor: and Unix?
18:59:54 <syntaxglitch> ivanm, the bit with the O-ring in the ice water was pretty much his crowning moment of awesome though
19:00:20 <theorbtwo> Hm.  There's a great biography of him by James Glick.
19:00:22 <Entroacceptor> I think a book on computer graphics told me about unix
19:00:28 <ivanm> syntaxglitch: oh, the challenger disaster?
19:00:31 <theorbtwo> I don't think he was all that socially inept.
19:01:03 <syntaxglitch> Entroacceptor, pop quiz! What's the name of the fractal that was in Jurassic Park? :)
19:01:36 <syntaxglitch> ivanm, yeah, though that was in a different book
19:02:43 <monochrom> hahahaha torroid
19:02:44 <Entroacceptor> it's called Dragon curve in english, too
19:03:18 <syntaxglitch> yeah, or Heighway's dragon
19:03:29 <syntaxglitch> have you seen the paper-folding method of constructing it?
19:03:35 <Entroacceptor> no
19:04:36 <OscZA> what would be a good book about turing machines, computability etc.. related subjects ?
19:04:48 <Entroacceptor> Diamon Age ;)
19:05:08 <syntaxglitch> Entroacceptor, take a strip of paper, hold one end in place. Fold it in half to the right, then fold to the right again, etc., keeping the one end where it is
19:05:17 <znutar> Sipser's book is pretty kewl
19:05:32 <syntaxglitch> Entroacceptor, then unfold the strip of paper so that every crease is a right angle
19:05:44 <syntaxglitch> and the strip will trace out the dragon curve
19:05:58 <monochrom> "here be dragons"
19:06:10 <syntaxglitch> unfortunately it becomes impossible to fold after only a few iterations :(
19:06:34 <syntaxglitch> but if you make 2^n copies you can place them end-to-end to make a bigger dragon
19:06:35 <mdurr_> (unfoldr . foldl) paper
19:07:09 <monochrom> if some haskell newbie enters now, we can scare him/her with "here be dragons" :)
19:07:24 <Entroacceptor> :)=
19:07:25 <Niccus> infinite dragons no less
19:07:42 <Entroacceptor> ok, remind me to attend to the next C3
19:08:01 <JuanDaugherty> anybody use Nixos? I thought it was at least partially in haskell.
19:08:23 <SamB_XP> lol @ "the piano has only 88 keys"
19:08:35 <monochrom> 88 sounds correct.
19:08:46 <Entroacceptor> JuanDaugherty: I installed it in a vm once
19:08:51 <Entroacceptor> it's fun
19:08:53 <syntaxglitch> my current favorite fractal is "graph the roots of all complex polynomials of order N with all coefficients 1 or -1"
19:09:03 <SamB_XP> monochrom: it's from "mathematics made difficult"
19:09:05 <SamB_XP> page 14
19:09:20 <monochrom> is that book a prank?
19:09:34 <SamB_XP> ... no, it's some kind of jokebook
19:09:43 <JuanDaugherty> i can't find any haskell code in the sources for it's four or five component projects but I thought I saw it say somewhere it in it's web site it did
19:09:49 <monochrom> what does it compare piano keys to?
19:09:59 <JuanDaugherty> *its 4 or 5
19:10:37 <JuanDaugherty> you'd think it would go naturally with HP, cabal, etc.
19:10:45 <SamB_XP> monochrom: it goes on to say "hence, anyone counting with these axioms is soon played out."
19:11:27 <OscZA> znutar: "Introduction to the Theory of Computation" ?
19:11:36 <monochrom> hahaha I see now, peano, piano
19:11:41 <znutar> OscZA: yes, that one
19:12:38 <syntaxglitch> ah, the peano/piano pun, never gets old
19:13:15 <liyang> OscZA: P T Johnstone's Notes on logic and set theory? http://www.amazon.co.uk/dp/0521336929 It's not a bedtime book though.
19:15:09 * syntaxglitch has a life goal of finding some interesting result combining Rice's Theorem and combinatory logic just so that he can write it up under the title "Curry and Rice"
19:16:03 <monochrom> find a way to involve someone called Lamb, too.
19:16:15 <Entroacceptor> lambda
19:16:18 <Entroacceptor> close enough
19:16:29 <syntaxglitch> I was about to suggest that
19:16:29 <fax> I totally don't understand rice's theorem
19:16:37 <OscZA> liyang: thats sounds like a good book too
19:16:44 <fax> do you operate on the syntax of programs? or what like. it doesn't make sense
19:16:55 <fax> of course predicates on real functions are undecidible if some of them are infinite loops
19:16:55 <syntaxglitch> unfortunately Curry's combinatory logic is precisely not the lambda calculus
19:18:00 <fax> but yeah I don't really geti t
19:18:05 <liyang> OscZA: alternatively Forster's book which covers similar ground: http://www.amazon.co.uk/dp/0521533619  I found it matched my style of thinking slightly better.
19:18:06 <syntaxglitch> fax, isn't it just another result along the lines of "everything interesting is impossible, Godel and Turing are laughing at you from beyond the grave"
19:18:11 <fax> apparently it's a totally basic theorem that everyone should know
19:18:35 <fax> syntaxglitch -- I don't understand the result myself, I know it implies halting problem
19:18:58 <fax> maybe not so much the result but the statement
19:19:21 <fax> if you DID work on the syntax of programs then something like 'source code length is bigger than 10 lines' is a nontrivial predicate..
19:19:43 <syntaxglitch> fax, I think it deals with algorithms, not source code
19:20:18 <fax> in that case it seems like a really trivial result
19:20:24 <syntaxglitch> mathematical properties of a function vs. algorithms that might implement them, or whatnot
19:20:30 * syntaxglitch doesn't recall the details
19:20:43 <fax> other than the constant function, there isn't anything continuous which f(_|_) \= _|_
19:20:43 <syntaxglitch> everything in math is trivial
19:20:52 <syntaxglitch> well, trivial or unproven
19:20:56 <fax> trivial as in: You gotta be kidding me
19:21:17 <fax> I'm just saying this stuff here in the hope someone corrects me :P
19:21:28 <fax> because this has been bugging me a bit for a long  long time
19:21:35 <syntaxglitch> sorry, I don't know it well enough to help :(
19:21:38 <Niccus> well there's unproven and then there's unprovable
19:21:47 * Entroacceptor imagines a universe where Gdel's theorem is wrong 
19:21:50 <theorbtwo> fax: OTOH, there are tons of discontinous functions.
19:22:02 * fax imagines a universe where -1 * -1 = -1
19:22:09 <fax> theorbtwo, yeah but they're not computable
19:22:14 <Entroacceptor> fax: that's easy, you can just define it
19:22:42 <syntaxglitch> Entroacceptor, arguably Goedel's theorem doesn't apply to "this universe" anyway
19:22:43 <fax> maybe this thing about continuous functions is a big lemma that I just weild to haphazardly and that's why I don't see rice as a big deal?
19:22:52 <Entroacceptor> syntaxglitch: how so?
19:23:11 <monochrom> rice should not be a big deal. maybe a useful theorem to save work.
19:23:24 <syntaxglitch> Entroacceptor, on second thought, I'm confused, never mind
19:23:26 <fax> monochrom do you think I misunderstand the theorem?
19:23:58 <monochrom> I am usually more comfortable with reducing things to the halting set than invoking rice.
19:23:59 * twink suspects compact elements and full abstraction could be fun here
19:24:04 <fax> me too
19:24:14 <syntaxglitch> Entroacceptor, some people argue that reality is more fundamentally limited than many mathematical constructs but I don't think any of it escapes goedel's result
19:24:27 <fax> now it is getting topological and I really have not a good grasp of this,
19:24:41 <fax> but I did learn "compact means that any infinite covering can be reduced to a finite cover"
19:24:45 <fax> or roughly that sort of thing
19:25:05 <Entroacceptor> from what I've seen the universe isn't that limited  :)
19:25:09 <fax> wonder if 'full' abstraction has anything to do with full functors
19:25:10 <fax> ?
19:25:31 <monochrom> No.
19:25:44 <syntaxglitch> Entroacceptor, does the universe contain real numbers?
19:25:54 <fax> does -1 exist? :P
19:25:57 <nanashi> if real numbers contain the universe
19:26:08 <monochrom> -1 exists in my theorem prover.
19:26:11 <nanashi> and if the lack of -1 does exist
19:26:19 <Niccus> aren't all physical computers expressible as finite automata
19:26:25 <nanashi> if the lack of something does exist, then the something itself does also exist
19:26:31 <monochrom> Oh I can butcher my theorem prover to lack -1 too.
19:26:32 <syntaxglitch> specifically the real numbers that do not have computable approximations
19:26:39 <twink> Full abstraction is when axiomatic, denotational, and operational semantics are equal.
19:26:48 <syntaxglitch> which, statistically speaking, is all of them
19:27:10 <fax> not all of them, but probabilty 1 of them ? :P
19:27:22 <syntaxglitch> hence "statistically speaking"
19:27:49 <Entroacceptor> syntaxglitch: I'd say so, yes
19:28:02 <fax> I read in aphilosophical paper that because of quantum physics and infinite space everythign has happened with probability 1
19:28:08 <syntaxglitch> the set of real numbers with computable approximations being merely countably infinite
19:28:14 <fax> and I wonder.. who bothers to write this bullshit!
19:28:35 <nanashi> those who cannot see the simple formula to make it a useful tool or language for others to use.
19:28:42 <monochrom> Why do people correct each other's wording with totally equivalent wording?
19:28:45 <nanashi> (ie. those who do not understand it themselves.)
19:29:15 <monochrom> "Hi I'm using GHC 6.12"  "No, you're using GHC (smallest positive perfect number).(twice that)"
19:29:25 <syntaxglitch> monochrom, because they're on the internet
19:29:36 <syntaxglitch> it's just how it goes
19:29:44 <nanashi> monochrom: not enough unicode yet =)
19:30:01 <Entroacceptor> from what I've seen of physics so far I'd say that the reality is of a higher order than our mathematics so far
19:30:12 <nanashi> or lower !
19:30:29 <Niccus> or nonexistent
19:30:33 <fax> monochrom by people do you mean me? I wasn't correcting
19:30:38 <Entroacceptor> or nonexistant
19:31:09 <Niccus> I thought it's existent
19:31:21 <nanashi> all But's can be replaced with And's
19:31:50 * syntaxglitch is inclined to think that reality is essentially computable and that anything involving an uncountable infinity exists only as an illusion of mathematics
19:32:39 <Entroacceptor> Niccus: looks like it's an e, you're right, but that wasn't what I wanted to say
19:32:46 <Entroacceptor> I was just repeating that
19:32:47 <nanashi> computing the result of the computation makes more computations to compute. (fractallistic!)
19:33:09 <Entroacceptor> syntaxglitch: I'm leaning more towards that all maths can only be approximations to reality
19:33:16 <nanashi> whatever computes reality also belongs to reality which also then needs computing. so what computes ?
19:33:45 <Entroacceptor> because we can never prove that a formula really is the correct once
19:33:51 <Entroacceptor> s/once/one/
19:34:01 <nanashi> without more formulas that need more proofs =)
19:34:27 <Entroacceptor> actually that's Gdel again, isn't it?
19:34:43 <syntaxglitch> Then again I'm also inclined to think that using Turing-complete programming languages was a mistake that we should abandon as soon as possible, so I probably just have odd ideas
19:34:59 * fax tries to sya something deeply philosophical about rices theorem
19:35:15 <monochrom> rice's theorem puts rice on the table
19:35:18 <fax> syntaxglitch -- I like this!
19:35:29 <Niccus> which theorem puts bacon on dinner
19:35:38 <fax> syntaxglitch, I do have a soft spot for sub-turing languages
19:35:40 <theorbtwo> syntaxglitch: You think we can get away with making nonterminal programs impossible?
19:35:51 <Entroacceptor> what is yellow and equivalent to the axiom of choice?
19:36:02 <fax> egg fried rices theorem!
19:36:08 <monochrom> banana-tarski theorem
19:36:38 <Entroacceptor> zorn's lemon
19:36:47 <monochrom> why not banana
19:36:47 <syntaxglitch> theorbtwo, I'm not convinced that turing-completeness is required for most useful programs
19:37:24 <Niccus> it doesn't take a lot to be turing-complete
19:37:41 <dobblego> just an S and a K
19:37:49 <theorbtwo> syntaxglitch: Right, but what particular bit of the requirements do you want to get rid of?
19:37:59 <syntaxglitch> ideally the only useful program written in a turing-complete language would be the interpreter/compiler for the language everything else uses
19:38:40 <syntaxglitch> theorbtwo, ditching well-typed fixed point combinators would be a start
19:38:44 <monochrom> ideally the first thing you do is re-implement lisp. so yes you need turing-complete. :)
19:39:58 <syntaxglitch> typed lambda calculi are, in general, not turing complete, and that's the model I'd start from
19:40:58 <syntaxglitch> structural recursion, guarded corecursion, and dependent types ought to let you write a substantial number of useful programs
19:41:06 <nanashi> when a computer can make its language like ppl do each have their own personal language.
19:41:17 <twink> I forget what the languages along this line are called again. Chorus? Charity? Something like that.
19:42:12 <syntaxglitch> twink, such languages exist
19:43:03 <syntaxglitch> but only as research projects and theorem provers, not really something suited for practical programming. at least, not yet.
19:43:04 <SamB_XP> they say that a stock R2 can't talk to luke's X-wing anymore
19:43:18 <nanashi> pff practical programming is the least useful
19:51:08 <Entroacceptor> so, sub-turing languages killed the discussion
19:51:25 <Entroacceptor> they're not powerful enough to carry it
19:51:36 <JuanDaugherty> you didn't do anything further with Nixos?
19:51:45 <Entroacceptor> not much, no
19:52:06 <Entroacceptor> but if I ever install a new play computer I'll use it
19:52:25 <JuanDaugherty> I have to admit I'm taken aback there's no haskell at all in it.
19:52:39 <Entroacceptor> or if I get to roll out lots of similar configurations
19:52:43 <JuanDaugherty> nor any other pure FP lang
19:52:57 <JuanDaugherty> i still intend to use it though
19:54:13 <JuanDaugherty> since it is still pure functional in its approach to unix packaging
20:10:27 <mdurr_> pumpkin time! later
20:11:07 <ivanm> :o what are you and copumpkin doing? :o
20:11:12 <edwardk> hah
20:11:17 <edwardk> that was my first reaction =)
20:13:02 <edwardk> You know you've been staring at math too long when you decide that the obvious and most efficient way to describe a fairly rudimentary set of operations on a data structure is as a lattice-ordered group homomorphism.
20:13:18 <ivanm> wrong type of maths for me...
20:13:45 <SamB_XP> edwardk: dunno
20:14:11 <SamB_XP> that sounds much saner than most of the stuff I've seen in Mathematics Made Difficult
20:14:14 <edwardk> ivanm: it started out when i was considering the kinds of monotone boolean valued functions that vary over a buffer/bytestring and when i started to consider how you can mix and match those functions
20:14:59 <edwardk> of course, the downside is that it has me second guessing the way i'm structuring the whole shebang
20:15:14 <edwardk> because it could be used for more general monoids. but that is a very slippery slope =)
20:15:42 <twink> Someone wrote something called "Mathematics Made Difficult?"
20:16:09 <edwardk> so far i have a fingertree of genetically enhanced bytestrings. (they've been spiffed up to track the number of utf8 tail bytes in them)
20:16:20 <edwardk> the fingertree tracks the # of bytes and the # of tail bytes.
20:17:07 <edwardk> which yields 3 common thresholds i can use that are monotonic, that don't involve mixing thresholds. # of bytes, # of chars (bytes - extra), and # of extra bytes.
20:17:39 <edwardk> plus, you could theoretically take the min or max of two or more of those functions, so you can wind up with a little min (max (min (... ))))) alpha beta action going on.
20:18:33 <edwardk> with that you can test the function at the start and end of the fingertree, and if it goes from low to high in the interim you can find the point at which the edge triggered, and return that element.
20:19:05 <edwardk> ideally this would let me say something like splitAt (chars 64) someRope
20:19:46 <ddarius> Why do you want to say splitAt (chars 64) ?
20:19:51 <edwardk> or splitAt (byte 12)    -- or splitAt (byte 12 `minThreshold` char 7) to cut the fingertree'd buffers at the point where you see the 12th byte or the 7th char
20:21:24 <edwardk> because i have two sets of operations, one that works on chars, one that works on word8s, and then there are some which name neither in the type
20:21:54 <edwardk> most of the machinery i set up to make it so that it is very fast to splice at the nth character boundary
20:22:42 <edwardk> O(log(min(n,l-n)/c)) for a buffer of length l, index n, where c is the average chunk size
20:23:16 <edwardk> er maximum chunk size for text with high bytes, the runs with all ascii text can be arbitrarily large
20:24:01 <edwardk> ddarius: that and i was mostly just trying to figure out if i could reason about thresholds using some nice machinery ;)
20:24:21 <edwardk> but of course, now that i'm looking at this in full generality there are many kinds of signals you might want to look at over the length of a buffer
20:24:30 <edwardk> for instance the number of newlines
20:24:58 <ddarius> Indeed.
20:25:11 <ddarius> One thing this made me think of is bytes v. opcodes.
20:25:12 <edwardk> so that you can look map backwards from the 700th and know that it is on line 180
20:26:31 <edwardk> so one option is to define all of these using a galois connection to the byte count, and represent their value in a lattice ordered group. which is enough to give me positive, negative, abs, the ability to subtract out the value of an interval, etc.
20:27:29 <ddarius> "lattice ordered" seems redundant to me
20:28:01 <edwardk> coz one thing i get that i love about the connection with the extra bytes is that it gives rise to 3 measures, which can be calculated very cheaply, by walking from either end of a buffer, so if i take 64 bytes from a 100 byte buffer i can just subtract off the end
20:28:46 <edwardk> the lattice ordering is important because i need monotonicity, and it lets me have a way to check for zeros, and positive values.
20:29:25 <ddarius> I was saying the term "lattice ordered" itself seems to be redundant with itself.
20:29:45 <edwardk> l-group if you prefer ;)
20:30:05 <edwardk> http://math.chapman.edu/cgi-bin/structures.pl?Lattice-ordered_groups
20:30:54 <ddarius> Googling "lattice ordered group" gives me "partially ordered group" which seems much more sensible.
20:31:21 <edwardk> they are but i lose the notion of a 0 and positive values which give me the ability to enforce monotonicity
20:32:08 <edwardk> well i don't lose it
20:32:11 <edwardk> it just becomes a lot weaker
20:34:51 <edwardk> ultimately the only portion of the partially-ordered group i'd be able to interact with would be in the positive cone of G+, which requires it to be unperforated, the mapping is now no longer onto the whole group or even half the group but only onto that cone, etc.
20:36:05 <ddarius> Yeah, I see that a lattice ordered group is a bit stronger notion.
20:36:21 <edwardk> so what i'm debating about is if it makes sense to restructure some of what i've been doing to support these buffers to support these more interesting thresholds
20:37:01 <ddarius> How many applications can you think of for the generalization and what will it cost you?
20:37:52 <edwardk> well, it depends, right now the existing version bakes in the extra bytes measure really deep. it is part of my customized fingertrees, it is added to all of the bytestring machinery, etc.
20:37:58 <edwardk> it is wedged in tight. ;)
20:38:11 <edwardk> to generalize it i'd need to move it out, preferably out of the fingertree entirely
20:38:45 <pchickey> Hi, I have a newbie question: I want to build a list by applying a function transformAngle :: Float -> IO Float (simulating a random walk) to its result, iteratively, collecting the results in a list
20:38:46 <edwardk> what i do right now is in regions where the value is non-zero for the suplemental measure i require bytestrings to be subdivided quite finely (112 bytes at the moment)
20:38:59 <edwardk> but where it is zero, they can go up to 64k or so
20:40:05 <edwardk> the intuition for utf8 is that a lot of text is ascii, and anything in the 0..0x7f range can be decoded using a simple byte decoder, so parsing it using something that just reads a byte and returns a char (like the old packedstring stuff) is actually correct over that interval
20:40:26 <jeffwheeler> @pl (\(k, v) -> (k, drop 1 v)
20:40:26 <lambdabot> (line 1, column 26):
20:40:26 <lambdabot> unexpected end of input
20:40:26 <lambdabot> expecting variable, "(", operator or ")"
20:40:27 <edwardk> so nicely all my char ops can look at the bytestring, check if it has 0 extra bytes and just sprint through at bytestring speed
20:40:33 <jeffwheeler> @pl \(k, v) -> (k, drop 1 v)
20:40:33 <lambdabot> second (drop 1)
20:41:11 <edwardk> and when i do see something hinky going on i start chunking the string up on a finer grain, so that the fingertree takes over more of the responsibility of tracking counts in that interval.
20:41:11 <jeffwheeler> Thanks, lambdabot.
20:41:21 <edwardk> but if i want multiple measures i can't let the fingertree do all the work
20:41:51 <Cale> pchickey: Okay, there are a few ways to go about it.
20:42:03 <Cale> pchickey: You could just do direct recursion of course.
20:42:41 <edwardk> so i'd probably have to pull the refinement of the bytestring chunk sizes out of the fingertree, and track things in some supplemental structure that is interval based on tight intervals and says over this interval the delta in my particular monoid is x. so now instead of one fingertree, i get two.
20:43:30 <edwardk> or n+1 for the bytestrings themselves and a much much smaller one for the annotations about which intervals contain non-zero values for how the l-groups change valuation.
20:43:35 <pchickey> I'm not comfortable enough with values wrapped in IO to get that, I think
20:44:03 <pchickey> is this a situation where I should use mplus?
20:44:16 <edwardk> in my fingertree right now i can't tell you exactly which bytes are high, but i can tell you how many in each chunk are, and the chunks that have high bytes are at most 112 bytes long, so i can seek to subdivide them in the rare case i'm splitting in the middle of one of those blocks
20:44:27 <Cale> pchickey: I don't think so. Have you seen how sequence works?
20:44:51 <Cale> pchickey: Your function will be similar to sequence, but different because you want to thread along the result of the last iteration.
20:45:26 <Cale> sequence's job is to turn a list of IO actions into one big action which when it's run will run each of them in turn, producing a list of results
20:45:37 <Cale> It's defined recursively
20:45:39 <edwardk> so i can do something similar, just maintain a small fingertree of values of the form (Interval, Int, m) for some monoid m, which is careful to never let an interval get bigger than some small threshold, and whenever it finds a non-zero value for a given byte, tries to extend the interval
20:45:48 <Cale> So first of all, on the empty list we have:
20:45:53 <Cale> sequence [] = return []
20:46:11 <Cale> When the list of actions is empty, the resulting action will be one that produces an empty list of results
20:46:15 <pchickey> cool sorry I was in the other window digging for the definition of sequence, but i'm with you.
20:46:20 <edwardk> of course, nothing says that the intervals have to actually contain data present in the string, which is why i kind of like this idea.
20:46:26 <Cale> sequence (x:xs) = ...
20:46:46 <Cale> now, on a nonempty list, we want the resulting action to first run x...
20:46:51 <Cale> sequence (x:xs) = do v <- x; ...
20:47:00 <Cale> (getting a result v)
20:47:12 <Cale> and then we need to run the rest of the actions in the list
20:47:15 <pchickey> right, and then cons v with the remaining sequence
20:47:26 <dark> "I'd also like to see some mention of the fact that Haskell is the most high-level general-purpose programming language that is being used by a large number of people."  a comment at http://book.realworldhaskell.org/read/why-functional-programming-why-haskell.html
20:47:28 <pchickey> but i need a second argument to sequence, which is v itself
20:47:38 <Cale> So, conveniently, we have a function which turns that list of actions into a single action we can run
20:47:47 <Cale> It's the function we're writing ;)
20:47:48 <dark> what this really means?
20:47:50 <Cale> sequence (x:xs) = do v <- x; vs <- sequence xs; ...
20:47:54 <edwardk> i.e. i can use a file position monoid that tracks line # changes based on newlines, but then you splice out the #line directives and replace them by putting in between the appropriate characters new values on the pos monoid which the buffer would use as a sign post
20:48:02 <jmcarthur> edwardk: so... when does this get released? :)
20:48:11 <Cale> So now we have v, the result of the first action, and vs, the results of all the remaining actions in the list
20:48:21 <Cale> and we just need to put them together
20:48:22 <dark> [ btw i think common lisp is more used than haskell, but a) i'm not sure, b) i'm not sure if common lisp is more 'high level' than haskell ]
20:48:25 <Cale> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
20:48:35 <pchickey> ok, that looks right to me
20:48:48 <edwardk> then if i went back and ran a normal parser over the buffer it'd be oblivious to line directives until there was an error, but then you can look at a slice of the buffer, and get back the line and column numbers, respecting line directives, and even with info on macro expansion, etc.
20:49:01 <edwardk> that seems to be the killer app for this alternative approach
20:49:06 <twink> "Mathematics Made Difficult" isn't my cup of tea.
20:49:07 <edwardk> jmcarthur: a very good question ;)
20:49:38 <dark> "Haskell has a family (functional programming languages) but when you compare it to its brothers and sisters, you might think it was adopted." < this is a good analogy..
20:50:07 <edwardk> jmcarthur: i have the buffer code for working with the leaf level buffers working. i have about a third of the fingertree code written for tracking it the way i described at first, but now i'm second guessing myself and playing with the notion of supporting these auxillary l-groups
20:50:12 <pchickey> Cale: I think I know where to go now, that was illuminating
20:50:15 <Cale> pchickey: So sequence is a sort of 'primordial loop', from which we can build almost any sort of loop where we can determine what the actions we want to run on each iteration are beforehand.
20:50:20 <Cale> pchickey: okay :)
20:50:59 <edwardk> the nice thing about doing it with the l-group machinery is i can throw out my custom bytestring implementation
20:51:11 <Cale> dark: Actually, it depends on *which* functional languages you compare it to
20:51:15 <pchickey> Cale: thanks very much, i'll get  back to you in a few minutes once I've thunk on it
20:51:30 <Cale> pchickey: sure :)
20:52:08 <edwardk> other example of things you could track with the machinery are things like utf8 encoded error locations, starts of individual records in a buffer, etc.
20:52:25 <Cale> dark: Haskell bears quite a lot of resemblance to the ML family of languages, and has yet closer ties with Miranda and KRC.
20:52:38 <edwardk> so i can think of a few applications, but there is a certain dread simplicity in the current approach
20:52:41 <dark> hmm
20:52:50 <Cale> dark: To the lisp family, it's not as close.
20:52:55 <edwardk> and it has the current version has the benefit of being haskell98'ish, no mptcs
20:53:18 <dark> "I don't understand why you would offer separate courses for Scheme and Haskell. Why not include LISP, Scheme, ml, Haskell, and several other languages in the same course?" < i think that using just one language is a win, especially for freshmen courses..
20:53:41 <dark> to learn how to think in a given programming language is already hard enough
20:53:50 <edwardk> dark: too many languages and people start to think there is no real difference between them that matters. they just see everything as c with different syntax.
20:53:58 <Cale> Of course, maybe the point is to keep you from thinking in one language.
20:54:13 <edwardk> so there is probably a sweet spot in there somewhere
20:54:42 <Cale> edwardk: Well... depends which "too many" :)
20:54:54 <dark> Cale, i think you need to be able to think in many languages
20:55:04 <dark> and also in the languages you yourself design
20:55:11 <dark> but you need to begin with something, right?
20:55:12 <Cale> dark: Yeah.
20:55:23 <edwardk> cale: i've seen too many people come out of college and think of haskell as that language that 'only supports lazy lists'
20:55:33 <edwardk> because their profs didn't have enough time to teach them any other data structure
20:55:34 <Cale> edwardk: heh
20:55:59 <ivanm> edwardk: :o
20:56:51 <Cale> dark: I've had a fair amount of success with teaching Haskell to complete beginners to programming. Interestingly, the difficulty in switching from an imperative mindset to programming in Haskell doesn't quite go in both directions. :)
20:57:09 <dark> i have a problem with quasi-functional languages like ruby: when i start trying to actually be functional, i don't have tail-call optimization..
20:57:30 <dark> Cale, you find easy to switch from haskell -> imperative, and not from imperative -> haskell?
20:57:41 <ddarius> edwardk: Haskell has data structures other than lists?
20:57:42 <Cale> (People are generally frustrated by not being able to make their imperative programs very safe, and with the lack of abstractions offered by most imperative and OO languages, but otherwise have an easy time.)
20:57:51 <pchickey> Cale: generateWalk x = do v <- advanceWalk x; vs <- generateWalk v; return (v:vs)
20:57:59 <pchickey> is now IO [Float]
20:58:08 <Cale> pchickey: Yeah, though you'll want a base case.
20:58:23 <Cale> pchickey: because when IO actions run, they run in order.
20:58:31 <pchickey> ok, thats why take 10 was broken
20:58:57 <dark> Cale, here at my univ, the professor teaches ocaml in the first programming class of computer science and computer engineering. people usually think it's too hard, and that the professor goes too fast. (he covered functional, imperative, OO, with functors and things like that..)
20:59:02 <Cale> (consider the case where advanceWalk does something like read input from the terminal)
20:59:11 <pchickey> sure
20:59:46 <dark> Cale, but their complaint is that the next class, algorithms and data structures, is taught with C++, and the professor doesn't actually teach it, so they have to learn C++ on their own..
21:00:18 <dark> the other thing that most people hate is that ocaml isn't (considered) very useful for practical problems :)
21:00:24 <Cale> That's how it ought to be done in the first place anyway
21:00:25 <pchickey> but I'm not trying to match a base case on the argument to generateWalk, am I? because you always get an 'x'
21:00:28 <ddarius> dark: Good practice.
21:00:48 <Cale> "In this course, we'll be using Haskell. You'll be expected to learn it on your own time. Get to work."
21:00:58 <ivanm> heh
21:01:03 <ddarius> They are going to have to learn new languages and new APIs throughout their careers.
21:01:16 <ivanm> Cale: you're really trying to drive up your IRC-based tutoring, aren't you? :p
21:01:21 <Cale> hehe
21:01:25 <ivanm> have you yet worked out how to make money out of it though?
21:01:35 <Cale> ivanm: Unfortunately, not so much.
21:01:37 <dark> good practice = for the professor? hmm yes i liked it, ocaml is now my favorite language
21:01:37 <ivanm> I mean, it's no good drumming up business if you end up doing it all for _free_ ...
21:01:39 <pchickey> dark: in a similar course we were just told to buy The Little Schemer and know all of it by the time the first assignment was due, worked well, for what its worth
21:01:51 <Cale> I would love to get paying customers, but I am my own worst competition ;)
21:02:08 <ivanm> Cale: set up a paypal account or something, and for $30 get free one-on-one IRC tutoring with you? :p
21:02:24 <Cale> I have a paypal account if anyone wants to send me money ;)
21:02:52 <ivanm> or, write and sell copies of Calebot, the Haskell automated tutor!
21:03:00 <dark> Cale, there is also another class, that goes after c++ and java, where the alumni is expected to build an interpreter with haskell. and the professor says: okay, you will learn haskell on your own. what i'm seeing: some weeks after this, some people didn't installed a haskell interpreter, and know nothing of haskell...
21:03:01 <ivanm> (or you could do the boring thing and write a book...)
21:03:19 <ivanm> in this first year class I'm tutoring here at ANU with Axman6, it's 2/3 Haskell + 1/3 Java
21:03:25 <dark> pchickey, hmmmm.. interesting, people seems to be really motivated then :)
21:03:30 <ivanm> (methinks the Java is there just to piss off dobblego... :P )
21:03:43 <Cale> dark: Yeah, we get a few students in here from time to time who are pulling their hair out because they didn't start learning the language on day 1 like they were supposed to.
21:03:59 <Cale> "Oh, it'll just be another reskinning of Java, I'll pick it up in a week"
21:04:04 <ivanm> *shudder*
21:04:11 <ivanm> Cale: what's your take on zaxis on -cafe?
21:04:17 <dark> i say c++ and java, but these classes aren't formally tied to the languages
21:04:22 <Cale> I haven't been following -cafe
21:04:30 <dobblego> Java is there because corporations pressure universities to teach/indoctrinate it
21:04:39 <ivanm> yeah :(
21:04:48 <Cale> I think C++ is an *awful* teaching language though.
21:04:50 <pikhq> Reskin of Java? Man. I'd actually have to learn a thing or two for that. I actually have yet to learn such a language.
21:04:54 <dark> when there is a professor change, he or she can change the language. the introductory language used to be C++ actually, and before this, scheme
21:04:55 <pikhq> Cale: Agreed.
21:04:58 <ivanm> dobblego: *shrug* at least it isn't C#... with Java, you can _pretend_ that it's OS-agnostic
21:05:09 <pikhq> C is, amusingly, a better language for the purpose.
21:05:19 <pchickey> Cale: so will a base case allow me to use a function like take on this "list"
21:05:43 <pikhq> Though C has many ways of shooting yourself in the foot, there's at least nothing too hard to actually *comprehend* in the language proper.
21:05:50 <pikhq> Just many, many ways of it blowing up.
21:05:51 <Cale> pchickey: Well, the list will be computed "strictly" in the sense that all the IO will happen before you see the first element of the list
21:05:59 <dark> actually, when i say C++, i ought to say C/C++.. in the old introductory class, most of time the professor was with C only, and then give some 'advanced' stuff with C++
21:06:13 <Cale> pchickey: That's a minor lie, in that there are some lazy IO things you can use which are a bit magic, like getContents and readFil
21:06:16 <Cale> readFile*
21:06:17 <dark> but with c++-style i/o, with cin/cout, from day 1
21:06:27 <pikhq> dark: That's not to say C is a *good* language for teaching.
21:06:34 <pikhq> Just that it's better than C++.
21:06:35 <dark> :)
21:06:55 <Cale> But it's still the case that all the IO actions will happen in order, unless you use black magic to defer the IO to evaluation time. (Not usually recommended)
21:06:56 <ddarius> pikhq: Its better for learning because there's little to learn?
21:07:17 <pchickey> ok, so the way I see this is
21:07:24 <dark> all engineering courses here have some programming, also physics etc. but all of them will have not those esoteric languages, but instead C, C++ and maybe java and fortran
21:07:27 <pikhq> ddarius: It's a language that it is feasible for you to actually learn most of.
21:07:29 <pchickey> its currently building an infinite list
21:07:47 <Cale> pchickey: yeah, but it never reaches the 'return' at the end when it executes
21:08:05 <dark> by 'esoteric' i mean 'non-mainstream' :)
21:08:17 <pikhq> I'd imagine most good C programmers could actually write out a fairly good description of the whole language from memory, given enough time.
21:08:23 <pchickey> ok, so I can't lazily generate the elements like in some of those 'fib' examples
21:08:26 <pikhq> I doubt anyone but Stroustrup could do the same for C++.
21:08:33 <Cale> pchickey: Not if you're doing I/O
21:08:56 <Cale> pchickey: If you only need pseudorandom number generation, you don't really need to be in IO
21:09:10 <ivanm> get your seed in IO and pass it around
21:09:14 <Cale> yeah
21:09:21 <ivanm> actually, I"m not sure if you even need to do that with bos' new PRNG
21:09:22 <Cale> newStdGen :: IO StdGen
21:09:22 <ddarius> pikhq: By that metric, brainfuck should be taught.
21:09:24 <ivanm> since it uses State
21:09:31 <pchickey> yeah, thats also a function of my ignorance. I think I just googled and settled on newStdGen right away
21:09:51 <Cale> I think it's a good idea to learn to do PRNG by passing StdGens around at least once :)
21:09:57 <pikhq> ddarius: It should, indeed, be taught. Not initially, but yes.
21:10:09 <pchickey> I can see how to do that now
21:10:13 <dark> pikhq, i'm not sure stroustrup can do that..
21:10:33 <pikhq> dark: Yeah, but he's the only guy who has a chance of it.
21:11:10 <Cale> pchickey: Basically, the idea is that if you're going to use pure functions to do pseudorandom number generation, you have the problem that functions are determined *entirely* by the values of their parameters. So if you need to be producing something 'random', you need a source of noise, or some kind of seed for the randomness as a parameter input.
21:11:31 <Cale> pchickey: that is, with the basic System.Random library, a value of type StdGen
21:11:48 <pchickey> yeah, and that source of randomness can't come from calling the StdGen IO functions each time I need one
21:11:57 <Cale> Yeah, you don't really want to do that
21:12:11 <Cale> When you use something like random or randomR
21:12:26 <Cale> along with your new random value, you'll get another StdGen
21:12:38 <ivanm> except randomRs won't :(
21:12:38 <pchickey> right, and I pass that along explicitly
21:12:41 <Cale> and that's the next one to use
21:12:42 <Cale> yeah
21:12:47 <ivanm> so you need to use split, which is bad :s
21:12:55 <Cale> I don't think split is bad
21:13:06 <Cale> I think more PRNG libraries should try to support ti
21:13:08 <Cale> it*
21:13:49 <ivanm> Cale: didn't someone find a bug in split recently?
21:13:50 <Cale> Of course it would be *nice* if someone knowledgeable in these things did the math to determine how to keep the statistical properties nice.
21:13:53 <pchickey> allright well thanks Cale, I'll buy your book when you write it one day :)
21:14:03 <ivanm> that it produced predictable random numbers?
21:14:41 <Cale> ivanm: There's a concern that there might be some kind of correlation which develops between the sequences of numbers obtained from split generators
21:14:48 <ivanm> yeah
21:15:11 <Cale> But I don't know if there's any evidence that this actually happens
21:15:23 <ivanm> hmmm... the docs for mwc-random say that to convert (0,1] to [0,1) you should subtract 2**(-33) for Float and 2**(-53) for Double; is that likely to be architecture-dependent?
21:15:28 <Cale> and for many applications, you don't care anyway
21:15:36 <ivanm> or are the sizes for FLoat and Double fixed (unlike Int)?
21:15:58 <Cale> er, what?
21:16:03 <ddarius> ivanm: If they are IEEE floats, then they are set, but they don't need to be IEEE floats.
21:16:05 <ddarius> :t isIEEE
21:16:07 <lambdabot> forall a. (RealFloat a) => a -> Bool
21:16:47 <Cale> In principle, anyway, there's no reason that a good implementation of split shouldn't exist.
21:17:02 <ivanm> Cale: minBound and maxBound for Int are dependent upon architecture (32bit vs 64bit); is this the same for Float and Double (for the smallest and largest positive numbers they can represent)
21:17:10 <Cale> and I think that it ought to be something that people designing the generators think about.
21:17:15 <ivanm> the nice thing about System.Random is that it's relatively easy to understand
21:17:21 <Cale> (It's really stupid that they don't)
21:17:41 <ivanm> mersenne-random{,-pure64} isn't, and a quick look at mwc-random shows that it isn't that clear either
21:17:51 <edwardk> ddarius: they are undocumented, and best kept secret. you don't want to scare everyone off.
21:18:13 <Cale> > isIEEE undefined
21:18:14 <lambdabot>   True
21:18:16 <ivanm> since mwc-random uses ST ...
21:18:22 <ivanm> :o
21:18:29 <ddarius> I encode everything into [forall a. a] anyway.
21:19:02 <Cale> ivanm: It's really unfortunate.
21:19:10 <ivanm> Cale: agreed
21:19:16 <Cale> ivanm: Sometimes the explicit generator passing style is nice
21:19:16 <ddarius> ivanm: Use bos's newer library.
21:19:16 <ivanm> random has a nice interface but poor performance
21:19:31 <ivanm> ddarius: which is mwc-random is it not?
21:19:36 <ddarius> Maybe.
21:19:39 <edwardk> that works as a handy way to model conaturals ;)
21:19:46 <ivanm> and as I just said, random has a nicer interface ;-)
21:19:47 <Cale> Sometimes it's actually preferable to the monadic style -- particularly when you want to be careful about laziness and you're working with infinite structures.
21:19:57 <ivanm> I'm looking at mwc-random and have no real clue how to use it
21:20:34 <Cale> But split is so essential, and yet we know so little about how it actually works.
21:20:35 <ivanm> since the usage of the parametrised Gen type (as well as ST) confuses me
21:20:52 <edwardk> i think in the end split is just a hard thing to get right, there is no good model for why it should work either ;)
21:20:52 <Cale> Don't any of you guys have Ph.D. students you can throw at this problem? ;)
21:21:10 <ivanm> Cale: how can I, when I _am_ a PhD student? ;-)
21:21:19 <ivanm> and I'm dealing with graph generation, not PRNGs
21:21:29 <edwardk> ivanm: well, then you'd best finish up so you can have a crop of them of your own
21:21:29 <Cale> :)
21:21:59 <edwardk> i mean even if you just do a post doc and are mostly borrowing someone elses' you can at least get them to go get you coffee.
21:22:07 <luite> ivanm: hm, interesting, random graphs?
21:22:10 <ddarius> ivanm: You create a Gen and then you apply uniform to it when you need a random number.
21:22:14 <ivanm> edwardk: well, I need 3 years to finish my PhD, and then I need to get a position at a uni and work my way up before I'm allowed to have PhD students
21:22:14 <Cale> edwardk: Maybe it's the case that a PRNG needs to be built from the ground up with split in mind to get it right
21:22:21 <ivanm> luite: probably not
21:22:30 <ivanm> edwardk: heh
21:23:02 <ivanm> ddarius: how do you create Gen? what is the significance of its type parameter? how do you use ST?
21:23:24 <ivanm> ddarius: I've been using Haskell for a few years now and it confuses me; how would a newbie come in and be able to use it?
21:23:40 <ivanm> (note: ST confuses me most likely because I've never had to use it and thus have never really studied the docs)
21:23:54 <ivanm> Cale: anyway, I'm hoping I'll be able to re-implement nauty in haskell, since HGAL really, really sucks
21:24:06 <Cale> ivanm: That would be great
21:24:16 <Cale> ivanm: I've looked at HGAL's code and I agree.
21:24:16 <ivanm> or, if I can get Brendan to re-license it to a real F/LOSS license, just make bindings to it
21:24:29 <ddarius> ST is straightforward and not particular to this library.  create is like newStdGen, you use it exactly the same way.
21:24:30 <edwardk> cale: in the meantime i'll stick to the evil impure supply comonad ;)
21:24:30 <ivanm> Cale: I've started a re-implementation, but I got off track doing something else
21:24:36 <ivanm> (graphviz most probably)
21:24:39 <ddarius> ivanm: All the s type parameters have to do with ST.
21:24:51 <ivanm> ddarius: except newStdGen isn't parametrised
21:24:59 <ddarius> ivanm: Because it's IO not ST.
21:25:09 <ivanm> aha
21:25:36 <ddarius> ivanm: If you were familiar with ST, then mwc-random would be trivial (or at least no worse than the standard IO random functions).
21:25:46 <Cale> That reminds me that one area that I'd like to see some research put into is graph layout algorithms for symmetric graphs.
21:25:48 <ivanm> most likely, yes
21:25:50 <ivanm> ddarius: so using mwc-random, what would you likely have s be though?
21:26:00 <ivanm> Cale: hmmm...
21:26:01 <edwardk> ivanm: the short version of why ST has an extra parameter is that it is a big of magic to keep you from acccidentally referencing references created in one runST block from another.
21:26:06 <ddarius> ivanm: Nothing.  You can't specify it for it to work with ST.
21:26:36 <ivanm> Cale: my actual topic is kinda still in flux; I will most likely be implementing a new fullerene generating algorithm that he's developed with some other people and comparing it to the "standard" algorithm
21:26:49 <ivanm> edwardk, ddarius: ahhhh
21:27:07 <ivanm> so you never provide a fixed type for s? it's always meant to be parametric?
21:27:13 <ddarius> ivanm: Yes.
21:27:30 <ddarius> If you write create :: ST Int (Gen Int) you will never be able to execute it
21:27:42 <ivanm> *nod*
21:27:53 <ivanm> OK, then I can see how to use mwc-random
21:28:11 <luite> I recently had some type of uniform generation problem for graphs, where you had to generate uniformly a single graph from all possible graph possible given the constraints. but the problem is #P-complete. are there #P-complete problems for which it is still easy to randomly generate a graph?
21:28:12 <ivanm> a version of randoms would be nice, but I guess infeasible
21:28:13 <Cale> All the graph layout algorithms I've seen have been either completely trivial -- like, spread the vertices evenly around a circle -- or they've done nothing to take advantage of the automorphism group of the graph.
21:28:24 <edwardk> ivanm: the gist of it is all of the methods that manipulate references carry that parameter as a brand. and then runST requires that your whole 'monadic action' has the same brand. if i give you an ST computation and runST has completed, it'll have a brand that doesn't match any other ST monad you could make... so you can't run the action. contrast with IO, if I give you an IO action you could run it at any point lat
21:29:01 <edwardk> so if i made an mutable array, you could have a bunch of io actiosn that will hack on it, but if i want to 'freeze' that array i have to take your word that you won;t continue mutating it after i call for 'pencils down' ;)
21:29:06 <ivanm> Cale: AFAIK, most don't; most graph generating algorithms (especially for larger ones) seem to "grow" graphs by adding edges, etc.
21:29:16 <ddarius> edwardk: You should have your client automatically split long lines.
21:29:18 <edwardk> on the other hand, if i have an ST action, the STArray is branded with the current 'runST session
21:29:35 <edwardk> ddarius: where'd i get clipped?
21:29:47 <ddarius> "you could run it at any point lat"
21:29:59 <edwardk> ah: 'later' ;)
21:30:07 <ivanm> ddarius: someone (monochrom?) was complaining the other day about people splitting what they were saying up into smaller lines ;-)
21:31:16 <monochrom> My client automatically split lines minimally.
21:31:40 <edwardk> ivanm: you can use this trick yourself, it isn't limited to the ST s monad. i use it to pass around type level brands in the 'reflection' library
21:32:06 <ivanm> edwardk: how do you make each one unique?
21:32:31 <edwardk> you don't have to. forall a. is what saves you.
21:32:36 <dankna> I like to split lines
21:32:40 <dankna> it breaks up my thoughts a bit
21:32:42 <dankna> this is a haiku
21:32:53 <Cale> So if you have a graph with lots of symmetries, and you have a particular subgroup of the automorphism group G whose structure is compatible with a subgroup of some geometric group on R^n (isometries, say), maybe you could do something like a spring-force model, but where you enforce the symmetry as well, and if needs be afterward, project the result down in a nice way from higher dimensional space (so as to try to avo
21:32:53 <Cale> id overlap)
21:33:01 * ivanm did something slightly similar with the last release of graphviz where he used a data type with no exported constructor to prevent people from using unsafe values
21:33:09 <ivanm> edwardk: aha
21:33:14 <edwardk> ivanm: http://hackage.haskell.org/packages/archive/reflection/0.3.0/doc/html/Data-Reflection.html
21:33:21 <edwardk> ivanm: look at the type of reify
21:33:25 <edwardk> you can say something like
21:35:07 <edwardk> reify (+) (Tagged Hello) -- and the contents are Tagged with a universally quantified 's' brand, tje reify requires that it be universally quantified.
21:35:16 <edwardk> if you had one lying around hard coded somewhere
21:35:28 <edwardk> foo :: Tagged Int Int
21:35:32 <edwardk> then reify (+) foo
21:35:43 <edwardk> will fail to unify because 'the type is less polymorphic than expected'
21:36:20 <edwardk> since the second argument to reify is required to be a valid Tagged s a regardless of the choice of s. (except in this case insofar as there exists an instance for Reifies s a lying around.
21:36:25 <Cale> ivanm: While many graphs out there in the real world have trivial automorphism groups, it would at the very least be a really useful thing for the mathematicians studying these types of graphs to be able to draw them without spending hours trying to work out a good way.
21:37:43 <Cale> Though, you're talking about fullerenes, and those have nice symmetries :)
21:37:47 <edwardk> ivanm: the latter there is what lets me ask for the value i reified later on in the calculation. 'reify 2 ((+) <$> reflect <*> reflect)'  -- returns 4.
21:38:02 <ivanm> Cale: yeah
21:40:52 <Cale> Those should have nice layouts because their whole symmetry group (or a large chunk of it if not the whole thing) typically embeds into the group of rotations on R^3
21:41:45 <ddarius> (exists s. ST s a -> a) => (forall s. ST s a) -> a
21:41:49 <Cale> (of course, physics actually finds this answer :)
21:44:11 <sbpaul> dankna:
21:44:20 <sbpaul> spring opens outside;
21:44:30 <sbpaul> haskell channel brings haiku
21:44:41 <sbpaul> white cherry blossoms
21:46:40 <monochrom> (exists p. Drink p -> forall q. Drink q)
21:47:05 <ddarius> I actually came across the drinkers paradox just yesterday.
21:47:39 <edwardk> ddarius: the drinker's paradox? is that something about how the cheaper the booze the harder it is to get drunk off it? =)
21:47:42 <sbpaul> who comes up with the names for these things
21:48:13 <sbpaul> well, the first guy to come up with the ridiculous real-life application
21:48:29 <sbpaul> like the one with the hotel...
21:48:52 <monochrom> hilbert's brothel
21:49:11 <sbpaul> see that's much better than the original
21:49:16 <sbpaul> shame
21:49:30 <monochrom> travelling student problem
21:49:45 <sbpaul> what's the one they use for AI problems
21:49:52 <sbpaul> it has the syllable "ump" in it somewhere
21:50:05 <sbpaul> with the 2x2 grid world
21:50:07 <monochrom> wumpy
21:50:12 <sbpaul> wumpus world
21:50:32 <Niccus> hunt the wumpus
21:51:18 <sbpaul> 1 aur/bethewumpus 0.05-2 (11 votes)
21:51:18 <sbpaul>     a game with no graphics, with no text, only audio
21:51:41 <jmcarthur> > 2 == sqrt 2 * sqrt 2
21:51:57 <lambdabot>   False
21:51:57 <jmcarthur> > (2 :: CReal) == sqrt 2 * sqrt 2
21:51:57 <lambdabot>   True
21:52:00 <jmcarthur> > (2 + 1/10^42 :: CReal) == sqrt 2 * sqrt 2
21:52:02 <lambdabot>   True
21:52:16 <jmcarthur> :(
21:52:33 <jmcarthur> (due to the imprecise implementation of (==)
21:52:35 <jmcarthur> )
21:52:49 <ddarius> jmcarthur: Asking for equality on reals is silly anyway.
21:52:59 <jmcarthur> ddarius: i think nontermination would make more sense
21:53:03 <jmcarthur> when impossible
21:53:20 <jmcarthur> for certain pairs of reals it's perfectly feasible though
21:53:33 <ddarius> jmcarthur: It depends on the representation.
21:53:34 <jmcarthur> when they happen to be rational, in particular
21:53:58 <jmcarthur> yes it does, but i'd still rather it be _|_ sometimes than be incorrect sometimes
21:54:20 <ddarius> What if it is bottom except when it is False?
21:55:00 <FliPPeh> @src foldl
21:55:00 <lambdabot> foldl f z []     = z
21:55:00 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
21:55:11 <jmcarthur> i'd still say it beats spitting out True when it's wrong
21:55:34 <jmcarthur> it's be one thing if the spec was "numbers up to X precision," but that's not the spec
21:55:39 <jmcarthur> *it'd
21:57:50 * ddarius might write an LCF style theorem checker for the classical implicational propositional logic in a bit.
22:19:11 <ivanm> Cale: did you see http://mvngu.wordpress.com/2010/03/19/algorithmic-graph-theory-book-0-3-released/ ?
22:27:39 <Cale> ivanm: I hadn't, interesting :)
22:44:44 <FliPPeh> @pl f x xs = Right (fst x : xs)
22:44:44 <lambdabot> f = (Right .) . (:) . fst
22:49:41 <edwardk> hrmm. i think i might have a model i don't hate for dealing with annotated fingertrees.
22:52:29 <edwardk> the goal being to allow me to start with Rope () -- and gradually add annotations to it. Rope Comments with the comments ripped out and placed into a map of annotations, Rope Pos -- with line directives ripped out and placed with positions, where Comments and Pos, all support a 'slice' operation that removes a chunk of text or condenses the contents  of a range.
22:52:48 <edwardk> Rope (Comments :*: Pos) would slice both
22:55:06 <edwardk> so the end of the preprocessing is something like Rope(Comments :*: Macro Positions :*: Pragmas :*: ...), which you can then dumb down to a Rope () to walk, but can use an index into the positions to reverse engineer line and column counts, and the include chain that got you there, etc.
23:21:01 <dmorti> Hi all, can anyone tell me what "Failed to load interface for ..." means (when trying to build using GHC)? or where I can find out?
23:25:50 <Cale> dmorti: Which module are you having trouble loading the interface for?
23:26:13 <dmorti> I'm trying to use wai
23:26:29 <dmorti> or actually: just trying to get the test code that comes with wai to build
23:26:44 <pikhq> dmorti: It *means* that it couldn't find the .hi file that indicates the interface for a certain module. What caused that, though? Could be any number of things.
23:27:11 <Cale> dmorti: If it's a module which is part of your project, try just getting rid of stray temporary files (.hi and .o), and recompiling
23:27:18 <dmorti> using the "-v" option shows that it finds the .hi file that I'd have thought was associated with the module
23:27:35 <pikhq> Hrm.
23:29:08 <dmorti> ahh
23:29:27 <dmorti> actually --- it hadn't built that file.
23:30:46 <dmorti> Thanks
