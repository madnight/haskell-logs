00:00:00 <sinelaw> looks nice
00:00:04 <sinelaw> perl :( :( :( :(
00:00:09 <sinelaw> :_(
00:00:21 <sinelaw> :O
00:00:23 <sinelaw> :|
00:02:43 <Argue> if I have [a], how do I get [(f a) + (g a)]?
00:02:48 <Argue> That is, do something like (a -> b) -> (a -> b) -> (b -> b -> c)[a] -> [c]
00:03:32 <sinelaw> Argue, i'd find out how to do a -> (f a) + (g a), then use map with that.
00:03:47 <sinelaw> @pl \f g a -> (f a) + (g a)
00:03:48 <lambdabot> liftM2 (+)
00:03:57 <sinelaw> ok: map (liftM2 (+))
00:03:58 <sinelaw> :)
00:05:42 <Argue> ok, trying that now.
00:07:08 <sinelaw> Argue, @pl is a fun tool. it gives you a point-less version of a function. for some cases it gives really good answers (like this one). in others its useless, because it doesn't know the arrow functions
00:09:41 <Argue> Sorry, point-less?
00:11:24 <sinelaw> Argue, point-full is e.g. (\x y -> x+y)
00:11:31 <sinelaw> point-less version of that is, (+)
00:11:37 <sinelaw> @pl (\x y -> x+y)
00:11:37 <lambdabot> (+)
00:11:59 <Argue> ah, okay.
00:17:14 <int-e> "point-free" is the more common term. "point-less" is a bit of a joke.
00:19:59 <SubStack> @pl (&&&)
00:19:59 <lambdabot> (&&&)
00:20:02 <SubStack> o_O
00:20:14 <dobblego> @unpl (&&&)
00:20:15 <lambdabot> (&&&)
00:20:19 <dobblego> blah
00:20:28 <dobblego> @type \i j -> i &&& j
00:20:29 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
00:20:43 <SubStack> @pl arr (\b -> (b,b)) >>> f *** g
00:20:43 <lambdabot> arr (join (,)) >>> f *** g
00:40:49 <ablmf1> It's said that in haskell foldr is more useful than foldl, is that true?  I can not see much difference
00:44:43 <SubStack> who says these things?
00:45:07 <olsner> I think I've used foldl more than foldr
00:45:19 <Janni> Hello.
00:45:27 <Saizan> foldr is more fundamental
00:45:41 <Saizan> and if you have a lazy step function it's the one to prefer.
00:45:55 <Saizan> foldl is almost never the one you should use, preferring foldl' instead
00:46:11 <Saizan> for the cases where your step function is strict
00:47:08 <Saizan> lots of common list functions are (or can be) implemented with foldr, while they wouldn't have the same semantics with foldl
00:47:52 <Saizan> e.g. concat = foldr (++) []; map f = foldr (\x ys -> f x : ys) []; ...
00:48:47 <Saizan> ?src foldr
00:48:47 <lambdabot> foldr f z []     = z
00:48:47 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
00:49:08 <idnar> you could say that foldr is more useful than foldl because you can implement foldl in terms of foldr, but not vice-versa
00:49:16 <idnar> (unless you ignore strictness)
00:49:27 <idnar> actually, I suppose that's not true
00:50:08 <Saizan> depends on what you apply foldl at, if we stick to applying it to the input list that's true
00:50:37 <Saizan> (otherwise there's always const..)
00:51:20 <idnar> anyhow, foldr can evaluate the spine of the list lazily
00:51:36 <Janni> I wanted to ask whether what I'm programming right now is some quite usual design pattern I don't know about. Given some recursive data-type T (no mutual recursion for now) I specified two higher-order functions that would apply some (isomorphic?) transformation function at each recursive point:
00:51:40 <Saizan> yeah, a simple observation is that foldl doesn't terminate if applied to infinite lists
00:52:02 <Janni> anywhere :: MonadPlus m => (T -> m T) -> T -> m T
00:52:08 <Janni> everywhere :: (T -> Maybe T) -> T -> Maybe T
00:52:31 <Janni> Both function traverse the recursive structure (like a fold).
00:53:09 <Janni> However to each occurring T a (transforming) function is applied.
00:53:47 <Saizan> they vaguely resemble instances of foldMap, but the types won't match
00:54:39 <Janni> Difference between the functions: everywhere returns the tree transformed at every point, whyle anywhere would return a list (as an instance of MonadPlus) of possible transformations.
00:54:51 * Janni is checking foldMap
00:56:32 <idnar> Janni: hmm, Maybe is a MonadPlus, so those are almost the same type
00:57:03 <Janni> Yes, everywhere should return Nothing if the term was not rewritten anywhere.
00:57:03 <Saizan> the type doesn't tell the full story here :)
00:57:13 <Janni> Sorry.
00:57:18 <Janni> Eh, yes.
00:57:24 <idnar> Saizan: yeah, I guess not
00:57:33 <idnar> I'm still struggling to wrap my head around what the functions should actually do
00:57:38 <Janni> everywhere :: (T -> T) -> T -> T would be fine two.
00:57:43 <Janni> OK, one moment.
00:57:53 <idnar> my brain wants T to have kind * -> *, not *
00:58:19 <Janni> Assume an implementation of the lambda-calculus: data T = A T T | T T | V Int
00:58:52 <idnar> oh, lambda calculus, no wonder my head is exploding ;)
00:59:04 <Janni> Eh, some bad naming here, sorry: T = term, A = application, T = lambda (?)
00:59:07 <Saizan> any tree
01:00:26 <Janni> be right back (to tell the rest of the story)
01:00:56 <Saizan> Janni: in everywhere, do you recurse before or after transforming the node?
01:01:03 <freiksenet1> is it possible to have counters in list comprehension run at the same time, rather than step by step?
01:01:17 <Saizan> freiksenet1: use zip
01:01:25 <freiksenet1> Saizan: reasonable :)
01:01:50 <idnar> > [(x, y) | x <- [1..10] | y <- [10..20]]
01:01:51 <lambdabot>   [(1,10),(2,11),(3,12),(4,13),(5,14),(6,15),(7,16),(8,17),(9,18),(10,19)]
01:01:58 <idnar> but that extension is pretty confusing
01:02:08 <Saizan> Janni: however, this seems like generic libraries like SYB or Uniplate should have similar combinators, or that you could implement them generically anyway
01:02:36 <Saizan> Janni: Uniplate is probably the easier to learn
01:02:43 <freiksenet1> idnar: that's an extension?
01:02:52 <freiksenet1> Saizan: thanks, zip works better
01:03:53 <Cale> http://www.youtube.com/watch?v=Qj0SL58no-k -- this will be good
01:04:01 <idnar> freiksenet1: http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#parallel-list-comprehensions
01:04:06 <freiksenet1> idnar: thanks
01:04:20 <freiksenet1> is that part of new haskell?
01:04:26 <Cale> oh, oops, wrong channel, that's still a good video ;)
01:04:36 <freiksenet1> I mean haskell 2010 standard
01:04:46 <Saizan> no
01:28:33 <Janni> Saizan: Thanks for your hints. Sorry for being afk just after starting this. To your question: everywhere would recurse before rewriting the node. And I am considering to use generic programming (although that's new for me)
01:29:31 <Janni> And I probably should have a look at combinators of generic programming libraries, which I'll be doing right away...
01:32:44 <pastorn> i have a [String] and i want to append stuff at the end quickly
01:32:52 <pastorn> O(1), preferrably
01:33:02 <dobblego> DList
01:33:08 <pastorn> what structures should i considerL
01:33:10 <pastorn> ok?
01:33:12 <arw_> or append to the front...
01:33:37 <pastorn> arw_: i don't want to bother with worrying about reversing etc.
01:33:43 <Jafet> Something other than a (:), hopefully.
01:34:52 <arw_> pastorn: then you need dlist
01:34:56 <pastorn> ok
01:34:59 <pastorn> cool
01:35:04 <Janni> pastorn: Maybe you are aware of that, but you should be aware of the fact, that with lazy evaluation the appending itself is very efficient, the question is only whether the inspection of the resulting value will be ...
01:35:14 <Cale> I never bother with DList usually
01:35:27 <Cale> You can just use String -> String functions and (.) for concatenation
01:35:35 <pastorn> Janni: i will only inspect it very rarely
01:35:48 <Cale> and then apply the thing to the empty list at the end when you want a normal string back
01:35:59 <pastorn> it's for storing strings that are lines that were feeded to my IRC bot
01:36:10 <idnar> Cale: [String] -> [String], you mean?
01:36:24 <Cale> idnar: Depends what sort of concatenation you want
01:36:29 <pastorn> so instead of having multiple files to keep track of all the different parts of the state, i'll just log all the input lines that generated new commands to my bot
01:36:34 <Cale> oh, yeah
01:36:42 <Cale> [String] -> [String] in that case
01:36:49 <Cale> (sorry, missed part of teh context)
01:38:09 <Cale> So, your state is some f :: [String] -> [String], and to append some String x to the end, you just use f . (x:)
01:39:09 <ivanm> @tell sinelaw yeah, it just came out the other day
01:39:09 <lambdabot> Consider it noted.
01:39:13 <Cale> pastorn: Does that make sense?
01:41:02 <pastorn> Cale: maybe if i stare at it enough
01:41:06 <Saizan> the only problem is that this approach is mostly suited to build a single large list that you'll observe only once at the end
01:41:07 <pastorn> but i don't want to bother
01:41:15 <pastorn> it'll just make my code mor illegible
01:41:20 <pastorn> import Data.DList (DList)
01:41:22 <pastorn> import qualified Data.DList as DL
01:41:25 <pastorn> i'll just use those
01:42:02 <ivanm> grrr.... I just realised there's a bug in graphviz where it assumes that there's a semicolon at the end of each line... and I'm not sure how to fix it :s
01:42:25 <pastorn> if i have a file that i will read at the beginning of my program, and then write to many times later during the running of my program
01:42:35 <pastorn> is readFile/writeFile enough?
01:42:42 <pastorn> or should i mess with handles?
01:44:04 <Saizan> pastorn: make sure you've force the content of the readFile before you attempt the writeFile
01:44:09 <idnar> @hoogle readFle
01:44:09 <lambdabot> No results found
01:44:11 <idnar> @hoogle readFile
01:44:11 <lambdabot> Prelude readFile :: FilePath -> IO String
01:44:11 <lambdabot> Data.ByteString readFile :: FilePath -> IO ByteString
01:44:11 <lambdabot> System.IO readFile :: FilePath -> IO String
01:44:29 <pastorn> Saizan: seq?
01:44:31 <Saizan> so the Handle opened by readFile will get closed
01:44:33 <pastorn> or something?
01:44:44 <pastorn> oh, right
01:44:55 <Saizan> do str <- readFile "foo"; length str `seq` return str
01:44:58 <idnar> ugh, lazy IO
01:45:00 <pastorn> but if i manually write hGetContents, hClose, will that fix it?
01:45:08 <Saizan> pastorn: that's worse
01:45:15 <pastorn> why?
01:45:18 <Saizan> the problem is that hGetContents uses lazy I/O
01:45:23 <pastorn> oh, ok
01:45:32 <Saizan> and readFile is written in terms of it
01:46:24 <Saizan> Data.ByteString.readFile doesn't have this problem, but doesn't give you a String, you've to use D.B.C.unpack
01:46:38 <pastorn> ugh...
01:47:01 <pastorn> isn't there a Syste.File.Strict?
01:47:25 <pastorn> that has a strict readfile
01:47:41 <Saizan> not that i know of, though hackage is large :)
01:47:52 <pastorn> hayoo!
01:49:47 <sepp2k> Haskell doesn't have an "or" for pattern matches like ocaml, does it? Like  foo (Pattern1 or Pattern2) = bar  (where Pattern1 and Pattern2 would bind the exact same variables).
01:50:40 <pastorn> do str <- readFile "foo"; id str `seq` return str <-- will this do?
01:54:03 <c_wraith> pastorn: no
01:54:12 <c_wraith> that will only force the first (:) of str
01:54:26 <pastorn> map id?
01:54:42 <c_wraith> will only force the first (:) of str
01:54:51 <pastorn> that too?
01:54:54 <c_wraith> yes
01:54:57 <c_wraith> map is also lazy
01:54:59 <pastorn> that seems weird
01:55:01 <pastorn> awww
01:55:16 <c_wraith> You have a couple options.
01:55:28 <c_wraith> the deepseq packag is the most correct
01:55:29 <pastorn> unsafePerformIO (return . id $ str) +
01:55:31 <pastorn> ?
01:55:46 <pastorn> ok
01:55:53 <c_wraith> but you can also usually get away with something like:  length str `seq` return str
01:55:58 <Cale> No need to unsafePerformIO
01:56:08 <c_wraith> That depends on the implementation of length forcing the whole list
01:56:16 <c_wraith> But in GHC, at least, it does
01:56:17 <Cale> you could also  foldr seq ()
01:56:36 <c_wraith> huh.  so you could.  that's cute. :)
01:57:03 <c_wraith> :t foldr seq
01:57:04 <lambdabot> forall a b. b -> [a] -> b
01:57:16 <pastorn> i'll use deepseq
01:57:18 <pastorn> seems nice
01:57:27 <c_wraith> deepseq will force list elements, too.
01:57:31 <c_wraith> Which is fine in your case
01:57:35 <c_wraith> But sometimes isn't what you want
01:57:51 <c_wraith> sometimes you only care about forcing the structure, and not the contents of it.
01:58:39 <pastorn> c_wraith: ok... you have something in mind?
01:58:55 <c_wraith> Like I said, deepseq is fine for what you're doing.
01:59:38 <c_wraith> There are cases where it has noticeable performance overhead.  Thought it's arguable that lists are the wrong structure in that case, anyway.
01:59:47 <pastorn> yeye, but can you think of some problem where you only want the structure evalueated, but not the contents?
02:00:01 <fasta> Does anyone in here have experience with monadic tunnelling?
02:00:12 <pastorn> fasta: tunneling?
02:00:16 <pastorn> what do you want to do?
02:00:31 <pastorn> bind is pretty tunneling...
02:00:34 <fasta> pastorn, I want to give a GTK callback monadic state.
02:01:04 <fasta> pastorn,  http://www.haskell.org/pipermail/haskell-cafe/2007-July/028501.html
02:01:31 <fasta> In the simple case described there, it works, but when you add GTK into the mix it stops working.
02:01:47 <fasta> I even changed to MVars to be on the safe side.
02:02:21 <c_wraith> pastron: benchmarking permutation code.  Using rnf (which is what deepseq is implemented in terms of) added significantly more overhead to the tests than just forcing the spines of all the sublists.
02:03:04 <c_wraith> pastorn: Like using rnf made each test run 10% longer than custom code designed to force only what it cared about.
02:03:35 <pastorn>  oh, ok :)
02:03:43 <metaperl_> ?source drop
02:03:43 <lambdabot> drop not available
02:03:48 <pastorn> anyway, i doubt my file will have more than 200 lines
02:03:52 <Taejo> :t round
02:03:53 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
02:04:29 <c_wraith> I never did finish my permutation algorithm work.
02:05:08 <c_wraith> I still have no clue why Data.List uses the algorithm it does.  It's not the fastest I found, nor does it produce any meaningful order in its results.
02:05:58 <c_wraith> Sadly, I couldn't find anything that produced lexicographically-ordered output that was nearly as fast as my fastest solutions.
02:07:37 <c_wraith> > round 6.5
02:07:38 <lambdabot>   6
02:07:44 <c_wraith> > round 7.5
02:07:45 <lambdabot>   8
02:08:03 <c_wraith> Despite knowing that's designed behavior, it seems odd to me.
02:10:36 <fasta> c_wraith, http://www.haskell.org/pipermail/glasgow-haskell-users/2009-August/017640.html
02:24:44 <erikc> hrm, trying out leksah 0.8, config/build package dont seem to do anything
02:24:58 <metaperl_> I think emacs-haskell-mode is in numerous recursive edit levels for some reason - http://www.screencast.com/users/metaperl/folders/Jing/media/6102299c-7544-4a80-b9ef-0da6068c26cb
02:25:08 <metaperl_> hi erikc - nice to see you again
02:25:11 <metaperl_> you get around :)
02:25:25 <metaperl_> I felt cold-shouldered by the Factor community, so I left
02:28:22 <erikc> metaperl_: ah
02:28:41 <erikc> i still keep tabs on haskell
02:29:24 <metaperl_> I left Factor for Forth, but Forth is simply too ghetto. Slava did a genius-level job in upgrading Forth for the modern age
02:32:38 <metaperl_> The comment feature on Real World Haskell http://book.realworldhaskell.org/read/types-and-functions.html  .. is simply awesome
02:32:46 <metaperl_> how was that done?
02:35:07 <fasta> metaperl_, too ghetto in what way?
02:36:12 <metaperl_> fasta: well... let's just say: too open-ended... Forth is genius-level work too... but if you get comfortable with all that Factor offers, then Forth is like pulling teeth... no arrays in the standard forth for instance
02:36:28 <Twey> metaperl_: Tables, though…
02:36:42 <metaperl_> Tables? I dont understand your comment Twey
02:37:00 <Twey> FORTH may not have arrays, but it has tables
02:37:09 <Twey> Which… are basically arrays, really
02:37:31 <fasta> metaperl_, I think Forth is great, but it also needs embedded languages (e.g. Haskell), when you don't want to have your system crash when you make one tiny mistake.
02:37:57 <fasta> metaperl_, Forth just needs infrastructure.
02:38:24 <Twey> I'd rather have FORTH be the embedded language, really… but there are times when you really do want that much control, and FORTH is great for that.
02:38:40 <metaperl_> the gForth community was very response and helpful. But the thing is: Forth has you focused on stack-dancing, not problem solving
02:39:00 <Taejo> @hoogle (a -> m Bool) -> m ([], [])
02:39:00 <lambdabot> Did you mean: a -> m Bool -> m ([a], [a]) /count=20
02:39:00 <lambdabot> No results found
02:39:14 <Taejo> @hoogle (a -> m Bool) -> m ([a], [a])
02:39:15 <lambdabot> No results found
02:39:24 <Taejo> where is partitionM?
02:39:53 <metaperl_> swapping elements to get them right for the next function... calling OVER and TUCK so arguments stay around for the word after the current one
02:40:06 <fasta> metaperl_, there are local variables in Forth too.
02:40:29 <metaperl_> fasta: yes, and gforth extends that for multiple locals in the body
02:40:48 <fasta> The nice think about Forth is that there is no barrier with "primitives".
02:40:59 <fasta> No broken, buggy RTS.
02:41:04 <metaperl_> yes, and very simple to parse
02:41:13 <metaperl_> very english-like at times
02:41:30 <Twey> I don't consider that one a positive thing ;)
02:41:39 <metaperl_> Factor had a cool datetime class. You could create a datetime instance by saying: 18 years ago
02:41:47 <metaperl_> and years and ago were words :)
02:42:17 <Twey> Heh
02:42:21 <metaperl_> but I realized that Haskell point-free programming was what I was aiming for in my Forth programming
02:42:53 <metaperl_> args when they make things clear, point-free when that makes things clear
02:43:47 <Twey> It's pretty easy to do.  : YEARS  365 24 60 60 * * * ; : AGO  NOW SWAP - ;
02:44:17 <Twey> Plus one *
02:47:16 <metaperl_> Twey: here is my attempt to anglicize Forth - http://pastie.org/859293  ... I was influenced by the book "Thinking Forth" by Leo Brodie
02:48:50 <metaperl_> Anton (main author of gforth) thought I was overfactoring things :)
02:49:05 <metaperl_> I said I was trying to make Forth a dataflow/point-free language
02:49:35 <Twey> Yeah, I don't like it :þ
03:00:04 <metaperl_> I tried to implement take ( http://pastie.org/pastes/859301 ) but I am getting a type error - cannot construct the infinite type a  = [a]
03:00:17 <metaperl_> Twey: :)
03:01:47 <Taejo> > partition even [1..]
03:01:49 <lambdabot>   ([2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52...
03:01:53 <Taejo> > partition even [1..5]
03:01:54 <lambdabot>   ([2,4],[1,3,5])
03:03:10 <Blarumyrran> Hello! I'm a complete newbie, and I have this, http://pastebin.ca/1828405 , and you can probably see what I want to do there - but it prints 0 instead of 1. Why?
03:05:45 <fasta> Blarumyrran, get a new CPU? There is nothing wrong with the code.
03:07:42 <metaperl_> Blarumyrran: why did you parenthesize (yyy) in the 2nd line like that
03:08:01 <Blarumyrran> Nevermind, compiled into wrong place...
03:08:33 <McManiaC> http://npaste.de/KS/
03:08:35 <McManiaC> why?! :(
03:08:58 <Blarumyrran> Well in most examples there are parenthesis there, like (lambaformula) (parameters)
03:09:07 <Blarumyrran> So I guessed it's necessary
03:09:32 <McManiaC> I've installed hslogger several times now…
03:09:34 <McManiaC> fucking ghc :(
03:12:18 <ToRA> McManiaC: cabal installed hs-logger 1.0.10, the log wants 1.0.7, try "cabal install hs-logger-1.0.7" ?
03:12:33 <ToRA> *hslogger-1.0.7
03:12:42 <Alpounet> yep
03:12:47 <Alpounet> this simply is a version mismatch
03:14:35 <McManiaC> huh
03:14:36 <McManiaC> okay
03:14:44 <McManiaC> it seems to need 3 different hslogger versions
03:14:51 <McManiaC> .7 .9 .10
03:14:55 <McManiaC> thx tho ToRA
03:15:28 <quicksilver> metaperl_: x is an element, not a list
03:15:35 <quicksilver> metaperl_: you mean acc ++ [x], not acc ++ x
03:16:01 <quicksilver> metaperl_: (incidentally it's faster to use x:acc and reverse in the last step)
03:20:30 <ivanm> gahhhhh!!!!! there are so many stupid ways Dot code can be parsed!!! :@
03:20:51 <ivanm> e.g. this is valid: a -> b c -> d
03:21:09 <Alpounet> ahah
03:21:27 <ivanm> how the hell am I meant to be able to parse that properly?!?!?!?!?!?!?!??!
03:22:09 <Alpounet> this will yield a -> b and c -> d right ?
03:22:22 <metaperl_> quicksilver: thank you. it now works
03:25:29 <ivanm> Alpounet: yes
03:25:39 <Twey> metaperl_: That's a terrible implementation — O(n²).  You'd be better off sticking to myTake 0 xs = xs; myTake _ [] = []; myTake n (x : xs) = x : myTake (pred n) xs
03:25:43 <ivanm> Alpounet: thing is, there's also optional attributes that can also be in there
03:26:21 <ivanm> Alpounet: my first attempt at removing the restriction for semicolons or newlines resulted in "a -> b" being parsed as a node specification for a :s
03:26:43 <metaperl_> Twey: I see. Thanks
03:27:14 <Twey> metaperl_: But the type error is caused by your use of (acc ++ x)
03:27:24 <metaperl_> yes
03:27:29 <Twey> ++ takes two lists
03:27:43 <Twey> So the only way that can make sense is if x is a list of lists of lists of lists of lists of…
03:27:57 <Blarumyrran> Now that I'm on this channel anyway, why does 3/(-0) give +Infinity in hugs but -Infinity in ghci?
03:28:00 <Twey> Which the compiler rightly dislikes :þ
03:28:15 <Twey> Blarumyrran: Because hugs is wrong? :þ
03:28:26 <idnar> > -0
03:28:27 <lambdabot>   0
03:28:36 <idnar> > -0 :: Double
03:28:37 <lambdabot>   -0.0
03:28:48 <idnar> @type 3 / (-0)
03:28:49 <lambdabot> forall t. (Fractional t) => t
03:29:14 <Twey> :t let n = 3 / negate 0 in n
03:29:15 <lambdabot> forall t. (Fractional t) => t
03:29:22 <Twey> Damn, thought that might force defaulting :þ
03:43:04 <Alpounet> ivanm, oh, ok. And yeah you have optional labels, and color attributes, and so on. What are you writing the parser for ?
03:43:13 <ivanm> my graphviz library
03:43:17 <ivanm> @hackage graphviz
03:43:17 <lambdabot> http://hackage.haskell.org/package/graphviz
03:43:32 <ivanm> I found some code I wanted to parse but it didn't work (the output of ghc-pkg dot)
03:48:11 <Alpounet> ok
03:48:19 <Alpounet> good luck then Ivan
03:49:16 <ivanm> thanks
03:49:22 <ivanm> preflex: seen malcolmw
03:49:22 <preflex>  malcolmw was last seen on #haskell 2 days, 20 hours, 22 minutes and 47 seconds ago, saying: pozic: on the other hand, if you count a PhD position as "full time Haskell", you could be earning more like £16,000 per annum, but it is tax free and you have lots of flexibility
03:50:59 <fasta> Does anyone know what the 3A means in the output of Hayoo? E.g. Graphics.UI.Gtk.Gdk.Pixbuf.3ApixbufComposite   	:: Pixbuf -> Pixbuf -> Int -> Int -> Int -> Int -> Double -> Double -> Double -> Double -> InterpType -> Word8 -> IO ()
03:50:59 <fasta> gtk2hs 	
03:51:00 <fasta> + src - the source pixbuf dest - the pixbuf into which to render the results destX - the left coordinate for region to render destY - the top coordinate for region to render destWidth - the width of the region to render destHeight - the height of the region to render offsetX - the offset in the X direction (currently rounded to an integer) offsetY - the offset in the Y direction (currently rounded to an integer) scaleX - the scale factor in the X direction scale
03:51:01 <fasta> Y - the scale factor in the Y direction the interpolation type for the transformation alpha - the transparency
03:58:08 <pastorn> @pl \def mb f -> maybe def f mb
03:58:08 <lambdabot> flip . maybe
03:58:37 <ClaudiusMaximus> > chr 0x3A
03:58:38 <lambdabot>   ':'
04:39:52 <Botje> fasta: could it be RGB + alpha?
04:40:46 <fasta> Botje, what do you mean?
04:41:57 <Botje> that 3A thing you were talking about
04:42:15 <Botje> or is it really just a hayoo artifact?
04:46:10 <quicksilver> just an artefact I think
04:46:20 <quicksilver> haskell symbols can't begin with a number can they?
04:46:44 <quicksilver> 3A is the hex for ':' although I still dont' see how it happens
04:57:01 <sinelaw> yo
04:57:01 <lambdabot> sinelaw: You have 1 new message. '/msg lambdabot @messages' to read it.
04:58:15 <sinelaw> ivanm, do you have a link for that program?
05:05:14 <taotetek> I am a programmer who is reasonably proficient with several languages, and have recently gotten into list comprehensions via python.  I'd like to start exploring haskell by rewriting a few utilties I've written in other languages.  I am hoping for some pointers for books / online documentation resources that are considered the best for coming up to speed with haskell both conceptually and syntactically.
05:06:13 <Zao> The two canonical "books" tend to be Real World Haskell and Learn You A Haskell.
05:07:28 <arw_> but there are tons of tutorials and introductions out there that are just as useful for certain aspects.
05:07:42 <arw_> just look around haskell.org a little.
05:09:50 <PepeSilvia> hi, what could be going wrong when `runhaskell Setup.hs test` works, but `cabal test` doesn't?
05:10:23 <Cale> @where lyah
05:10:23 <lambdabot> http://www.learnyouahaskell.com/
05:10:26 <Cale> @where rwh
05:10:26 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
05:11:21 <Alpounet> PepeSilvia, any error that can help us find why cabal test isn't working ?
05:11:23 <Cale> taotetek: Also, don't be afraid to ask questions about the language here. :)
05:11:40 <PepeSilvia> Alpounet: cabal doesn't give an error. It just does nothing
05:11:56 <taotetek> thank you for the pointers!  and I am sure to be around asking questions once I start diving in :)
05:11:56 <PepeSilvia> my runTests hook is a mere putStrLn at the moment
05:12:23 <Alpounet> hmm
05:12:37 <PepeSilvia> cabal test also has a return code of 0
05:12:56 <PepeSilvia> but no output
05:25:40 <PepeSilvia> where does cabal look for the Setup.(l?)hs file?
05:26:14 <PepeSilvia> hm no, also doesn't seem to matter..
05:27:16 <Taejo> PepeSilvia: it doesn't, as far as I know. On the contrary, Setup.hs looks for the cabal file
05:28:49 <mathijs> Hi all, I'm looking for a ssh library in haskell. What's important to me is that it has connection/channel functionality, so I can connect to a machine, type in some commands and send aditional input depending on the output.
05:29:50 <k23z__> mathijs: isn't it enough if you have public key auth set up and doing stuff like
05:29:59 <k23z__> mathijs: ssh user@machine  <command>
05:30:00 <PepeSilvia> Taejo: if Setup.hs looks for the cabal file, how would a cabal command work then?
05:30:03 <k23z__> mathijs: and parsing the output ?
05:30:22 <k23z__> mathijs:  and then doing some command depending on the output
05:30:33 <HandheldPenguin> Could someone give me a hand with this... http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23332#a23332 ?
05:30:44 <HandheldPenguin> It's supposed to go through the list and check if all the strings are numbers
05:30:54 <mathijs> k23z__: nope that's not enough. I want to do advanced stuff while the connection is active (thus having command waiting for input)
05:31:36 <Taejo> PepeSilvia: I'm not sure what you're asking
05:31:52 <k23z__> mathijs: well, if Haskell has an interface for expect then I imagine you can do what you need
05:32:26 <k23z__> mathijs: http://www.mail-archive.com/haskell-cafe@haskell.org/msg52080.html
05:32:29 <mathijs> k23z__: to give you an example... I want to coordinate mysql master-slave switching, which means locking tables, changing some setting on 2 machines and then unlocking. locks will be released when a mysql-client-session closes, so I need it to "hang in there" while acting on the other machine.
05:33:07 <zygoloid> HandheldPenguin: well, the indentation is the cause of the immediate error
05:33:21 <PepeSilvia> Taejo: well, as I understand it, cabal needs the Setup.hs file to be able to call the right hooks
05:33:22 <HandheldPenguin> oh :s
05:33:31 <zygoloid> HandheldPenguin: but you also have a type error.
05:33:40 <zygoloid> @type isDigit
05:33:41 <lambdabot> Char -> Bool
05:33:44 <mathijs> k23z__: ah... that's even better :)  just use the external "ssh" command and not worry about library updates and stuff :)
05:33:44 <zygoloid> isDigit operates on Char not String
05:33:55 <HandheldPenguin> oh ok
05:34:49 <HandheldPenguin> What's the indentation problem?
05:35:01 <k23z__> mathijs: how do library updates interfere in the problem ?
05:35:08 <Taejo> PepeSilvia: I don't see a contradiction between the cabal tool needing a Setup.hs and Setup.hs needing a .cabal file
05:35:41 <PepeSilvia> Taejo: there's no contradiction, but cabal still needs to be able to find the Setup.hs file if you enter `cabal configure` for example
05:37:24 <mathijs> k23z__: no, that's not really a problem. Just something you normally have to be cautious about when linking to libraries (such as a c openssh/openssl lib). The moment a newew version of the lib+headers comes out, you have to recompile. Just using pipes (your suggestion) and use an external command works around that hazard.
05:37:26 <PepeSilvia> and my question was, where it would look for that Setup.hs file
05:38:19 <mathijs> k23z__: but.... Just read the thread you linked... it won't work in my case, since System.Process doesn't use ptys. (just see the replies to the post you linked)
05:38:44 <dmead> @hoogle donsbot
05:38:45 <lambdabot> No results found
05:38:48 <dmead> @hoogle lambdabot
05:38:49 <lambdabot> No results found
05:38:52 <dmead> lolw0t
05:40:02 <Arnar> @where lambdabot
05:40:02 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
05:42:25 <k23z__> mathijs: yes I have read
05:43:10 <mathijs> k23z__: System.Posix.Terminal seems to have pty functionality
05:43:47 <k23z__> mathijs: http://hackage.haskell.org/package/libexpect
05:44:46 <dmead> Arnar, thanks
05:44:54 <mathijs> k23z__: ah thanks, that's a bit more high-level than opening ptys by hand and hoping to set everything right :)
05:45:40 <trofi> :t text
05:45:41 <lambdabot> String -> Doc
05:45:52 <k23z__> mathijs: yw
05:58:18 <CalJohn> Hello, I'm install ghc 6.12.1, and now, with cabal I have an error related to Chart-0.12 not having some gtk packages available.  These packages are on my system (from debian).  What can I do to resolve this problme?
05:58:46 <Zao> CalJohn: Surely they are not built with 6.12.1?
05:58:58 <CalJohn> no, I don't think they are
05:59:05 <Zao> CalJohn: Grab the gtk2hs source from their site, ensure you have the right C libraries installed, and build it yourself.
05:59:16 <Zao> CalJohn: Libraries are tightly coupled to the GHC version used to build them.
05:59:31 <Zao> ghc-pkg list  will show you the packages installed, by the way.
06:03:07 <CalJohn> thanks
06:10:55 <sepp2k> Is there a function f so that f 3 "abcdef" = ["abc", "bcd", "cde", "def"] ? Other than f n = filter ((==n) . length) . map (take n) . tails ?
06:11:16 <Botje> sepp2k: look at Data.List.Split
06:11:33 <Botje> @hoogle Int -> [a] -> [[a]]
06:11:33 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
06:11:34 <lambdabot> Prelude drop :: Int -> [a] -> [a]
06:11:34 <lambdabot> Prelude take :: Int -> [a] -> [a]
06:11:37 <Botje> grr
06:12:04 <yitz> > takeWhile ((>= 3) . length) . map (take 3) . tails $ "abcdef"
06:12:05 <lambdabot>   ["abc","bcd","cde","def"]
06:12:28 <Botje> anyway
06:12:36 <Botje> sepp2k: look at the chunk method of Data.List.Split
06:12:42 <sepp2k> Botje: Thanks.
06:12:47 <yitz> > init . init . init . map (take 3) . tails $ "abcdef"
06:12:48 <lambdabot>   ["abc","bcd","cde","def"]
06:13:34 <Botje> > unfoldr (\x -> if null x then Nothing else Just $ splitAt 3 x) "abcdefghi"
06:13:35 <lambdabot>   ["abc","def","ghi"]
06:13:42 <Botje> on second thought
06:13:50 <Botje> i was thinking of a completely different function, fuck :(
06:15:00 <ClaudiusMaximus> > let f n = (!!n) . iterate init . map (take n) . tails in f 3 ['a'..'f']
06:15:01 <yitz> > map (take 3) . takeWhile (not . null) . iterate (drop 3) $ "abcdefghi" -- Botje
06:15:01 <lambdabot>   ["abc","bcd","cde","def"]
06:15:02 <lambdabot>   ["abc","def","ghi"]
06:16:01 <Botje> myeah. bleh :)
06:16:30 <yitz> :)
06:16:52 <Szilva> where can I find something about the syntax of '@' ?
06:16:54 <Szilva> as all I managed to find out is that it is related to pattern matching but no description/example whatsoever.
06:17:11 <Zao> omg@(Wtf bbq lol)
06:17:20 <Zao> That is, gives a name to something you've matched on.
06:17:38 <Szilva> ic
06:18:12 <yitz> Szilva: syntax: basically, enclose the thing you are naming in parens, but you don't need to enclose name@ in parens
06:18:37 <yitz> which always seemed strange to me, but it works.
06:19:20 <Jafet> Well now you know that at least someone working on haskell pronounces @ as 'alias'
06:19:32 <Jafet> A useful icebreaker at conferences
06:19:50 <yitz> Jafet: also known as "strudel"
06:19:59 <Twey> You don't need to parenthesise the thing you're naming unless you would otherwise
06:20:12 <Twey> > let f a@b = a + b in f 3
06:20:13 <lambdabot>   6
06:20:35 <Twey> > let f a@5 = 6 + a in f 5
06:20:35 <Szilva> aham
06:20:36 <lambdabot>   11
06:20:41 <yitz> Twey: ok, fair enough. if you're bothering to name it it's probably complex enough that it'll be in parens though.
06:20:56 <zygoloid> > let allBut n xs = zipWith const xs (drop n xs) in allBut 3 . map (take 3) . tails $ "abcdef"
06:20:57 <Twey> Szilva: Basically, just take any pattern and stick ‘name@’ in front of it.
06:20:57 <lambdabot>   ["abc","bcd","cde","def"]
06:21:04 <Jafet> yitz: for some reason that made me think of a. appel
06:21:05 <Twey> yitz: Well, records are the obvious exception
06:21:12 <Jafet> Maybe I'm hungry.
06:21:24 <yitz> Twey: mm?
06:21:29 <Twey> yitz: No need for brackets with record syntax
06:21:41 <Szilva> all right, getting better, now I only have to fix an other syntax error in my script but i will try to do myself
06:21:45 <pastorn> is writeFile lazy or strict?
06:21:46 <Twey> f r@SomeRecord { field1 = a, field2 = b }
06:21:58 <Szilva> this @ thingy is somehow lost in the tutorials i read so far
06:22:17 <Twey> pastorn: Does a lazy writeFile even make sense?
06:22:17 <pastorn> i dunno
06:22:18 <Zao> pastorn: As it has to force everything to write it out, I can't quite see the distinction.
06:22:18 <pastorn> for readFile it does
06:22:20 <pastorn> ...
06:22:22 <yitz> pastorn: technically it's lazy but you can think of it as being strict.
06:22:34 <pastorn> yitz: thank you :)
06:22:35 <Twey> pastorn: But you can't tell the OS to write it when it's being read by something else.
06:22:35 <Zao> Unless you intend to abort things.
06:22:51 <pastorn> Zao: i don't see that happening...
06:22:53 <Twey> It's lazy in its argument, but it writes immediately
06:23:02 <Twey> AFAIK.
06:23:21 <Twey> I.E. it's not lazy IO
06:23:59 <yitz> Prelude> seq (writeFile undefined) 42
06:24:00 <yitz> 42
06:24:09 <yitz> Prelude> seq (writeFile "foo" undefined) 42
06:24:10 <yitz> 42
06:24:24 <yitz> so it's lazy
06:24:34 <ben> What
06:24:38 <yitz> but that's not really important in practice
06:24:40 <ben> the IO action gets evaluated
06:24:42 <ben> but not executed
06:24:47 <yitz> right
06:24:56 <ben> Can we stop overloading 'lazy'? :V
06:25:13 <ben> I move we start calling anything that involved unsafeInterleaveIO 'evil' instead of 'lazy'
06:25:20 <yitz> ben: i guess we could but we're too.. uh... lazy
06:25:38 <zygoloid> pastorn: if you want a lazy writeFile, you could use (forkIO $ writeFile "foo" stuff)
06:26:12 <pastorn> zygoloid: that or unsafeInterleaveIO or whatever it's called
06:26:29 <SamB_XP> pastorn: that wouldn't work at all!
06:26:40 <Twey> ben: I concur :þ
06:26:49 <pastorn> ok
06:26:55 <zygoloid> pastorn: unsafeInterleaveIO would just wait until the produced () was evaluated
06:27:04 <pastorn> hoho
06:27:40 <pastorn> that's cool :)
06:34:18 <MadHatterDude> @hoogle mplus
06:34:18 <lambdabot> Control.Monad mplus :: MonadPlus m => m a -> m a -> m a
06:39:01 <Dementati> Where does ghc look for modules when I use import?
06:43:33 * hackagebot DocTest 0.0.6 - Test interactive Haskell examples  http://hackage.haskell.org/package/DocTest-0.0.6 (SimonHengel)
06:47:04 <llambda> If I have a Net = ReaderT Bot IO, and I want to forkIO a function that returns a Net (), how would that be done?
06:47:21 <Dementati> I just installed a HUnit 1.2.2.1 through cabal (using cabal-install), apparently successfully. But ghc does not recognize the module name 'HUnit'. Ideas as to what could cause this?
06:47:27 <Dementati> -a*
06:48:04 <SamB_XP> Dementati: isn't there supposed to be other stuff in the name?
06:48:05 <shepheb> is there a canonical name for >> ?
06:48:22 <SamB_XP> @hoogle HUnit
06:48:22 <lambdabot> package HUnit
06:48:22 <lambdabot> module Test.HUnit
06:48:52 <Dementati> Meh. The user guide provides invalid code.
06:49:07 <Dementati> http://hunit.sourceforge.net/HUnit-1.0/Guide.html <- Just under 'Getting started'.
06:49:13 <SamB_XP> Dementati: probably they forgot to update it when they changed that?
06:49:20 <Dementati> Probably.
06:49:49 <fasta> Dementati, 8 years old.
06:49:50 <SamB_XP> send an email, or make an sf.net bugtracker item
06:50:00 <SamB_XP> or ... uh ...
06:50:11 <fasta> Dementati, do not expect up to date documentation for anything.
06:50:13 <SamB_XP> try to find where the development moved to?
06:50:22 <Dementati> SamB_XP: Less altruistic alternatives?
06:50:33 <SamB_XP> Dementati: say what now?
06:50:37 <Dementati> =P
06:50:43 <SamB_XP> Dementati: do you want it fixed or not?
06:50:56 <Dementati> SamB_XP: Well, it doesn't matter to me now.
06:51:03 <pokoko222> >	I am on euler 54 http://projecteuler.net/index.php?section=problems&id=54 anyone knows poker rules? I dont understand this: 1. what happens if both players have lets say one pair of 4s and one pair of 8s and the last card is value 9
06:51:09 <fasta> Dementati, test-framework is a newer package.
06:51:29 <fasta> It is also not 'perfect', but it is acceptable for me for the time being.
06:51:31 <SamB_XP> pokoko222: huh, I would've assumed they both lost in that instance
06:51:43 <llambda> I don't quite understand what this ReaderT implies and how to switch Net back to IO
06:51:49 <SamB_XP> or, well, I guess the pair of 8s wins
06:51:52 <llambda> From IO to Net is was just liftIO
06:51:58 <llambda> it was*
06:52:16 <pokoko222> SamB_XP but they both got pair of 4s and a pair of 8s :D
06:52:17 <SamB_XP> usually if two players have the same type of hand, the one with it in higher-valued cards wins
06:52:20 <pokoko222> and the last one is 9
06:52:20 <Dementati> fasta: Well, I don't exactly -expect- up-to-date documentation, but I usually try to follow official documentation initially.
06:52:30 <SamB_XP> oh, both have 2 pairs ?
06:52:37 <SamB_XP> then it's a tie, I suppose
06:52:39 <Dementati> fasta: If that doesn't work, I have to find other solutions. *shrug*
06:52:41 <fasta> Dementati, in case of doubt, use the source code.
06:52:42 <pokoko222> yes they both have, 4,4,8,8,9
06:52:47 <Dementati> fasta: Thanks for the tip.
06:52:47 <SamB_XP> I mean, if it's the SAME two pairs
06:53:01 <ablmf> What is the return value of "ord" with a utf-8 character?
06:53:04 <SamB_XP> I would assume they split the pool
06:53:14 <SamB_XP> ablmf: there is no such thing as a utf-8 character
06:53:21 <Dementati> fasta: Or refer to my esteemed and more knowledgeable peers.
06:53:42 <pokoko222> How many hands does Player 1 win? i should give solution for that, i guess i should skip this draw cases if they are so
06:53:49 <ablmf> Ok, SamB_XP: then what is the return value of :  ord '草'
06:53:53 <pokoko222> i am gonna ask some more people
06:53:53 <yitz> SamB_XP: there used to be, but System.IO is now fixed to use encodings. :)
06:54:10 <SamB_XP> > ord '草'
06:54:11 <lambdabot>   33609
06:54:17 <ablmf> 33609
06:54:27 <ablmf> But what does 33609 mean?
06:54:41 <yitz> > chr 33609
06:54:41 <ablmf> It doesn't look like utf-8
06:54:42 <lambdabot>   '\33609'
06:54:48 <SamB_XP> > "U+" ++ showHex ord '草' ""
06:54:49 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
06:54:49 <lambdabot>         against inferred ty...
06:54:56 <SamB_XP> > "U+" ++ showHex (ord '草') ""
06:54:57 <lambdabot>   "U+8349"
06:55:18 <llambda> > text ord (char 33609)
06:55:19 <lambdabot>   Couldn't match expected type `GHC.Base.String'
06:55:19 <lambdabot>         against inferred typ...
06:55:32 <ablmf> U + 8346 ?
06:56:06 <ablmf> But, what does that mean?
06:56:18 <SamB_XP> ablmf: huh? a six ?
06:56:32 <SamB_XP> anyway, that's the Unicode codepoint of the character
06:56:57 <SamB_XP> apparantly, the name of that character is "CJK Unified Idoegraph"
06:57:03 <SamB_XP> really informative name, that
06:57:09 <yitz> ablmf: The unicode value for that character is 33609. utf-8 is an encoding of unicode where each character is expressed as 2 bytes. The Char type in Haskell contains actual unicode characters, not their utf-8 encoding
06:57:10 <ablmf> So, it's the position of the character in unicode ?
06:57:31 <ablmf> OK, I see.
06:57:31 <SamB_XP> it is the number the character is assigned in unicode, yes
06:58:05 <SamB_XP> not all codepoints are assigned to characters -- there is a particular range that is set aside for use in UTF-16, for instance
06:58:34 <ablmf> BTW : I think ghc should include common encoding conversion libraries
06:58:58 <yitz> ablmf: the Haskell Platform will include it
06:58:59 <ablmf> It's a very common task
06:59:28 <yitz> (or does already, i don't remember)
06:59:33 <SamB_XP> which is nice, because that means we haven't got to worry about confusion between things encoded in the old UCS-2 form and things encoded in UTF-16 -- it makes UTF-16 just a superset of UCS-2
07:00:07 <SamB_XP> anyway, I know such libraries are in the works if not already included
07:00:27 <SamB_XP> or rather I think that's going to be in base
07:00:31 <Eelis> when is this haskell platform thingy going to take off? i've heard it touted as the solution to problems large and small for what feels like years, but there's still no package for my distro for it (opensuse)
07:00:39 <Lycurgus> no this is six: 六
07:01:11 <ablmf> Does haskell platform works with ghc?
07:01:13 <SamB_XP> Lycurgus: I meant, how did he get a six at the end of his "U+" string
07:01:20 <SamB_XP> Haskell platform includes GHC
07:01:25 <Lycurgus> ah
07:01:39 <SamB_XP> at least, the Windows installer does ;-)
07:01:39 <yitz> hmm, no, it's not in the HP yet, but i'm sure it will be in the upcoming version in a few weeks.
07:02:05 <yitz> oh, i mean encodings /Data.Text. ghc is in HP.
07:02:45 <ablmf> yitz: Glad to know that.
07:03:47 <Dementati> It appears there is no "cabal uninstall" command, so how I go about manually removing a package from my system?
07:03:54 <Dementati> how would*
07:04:26 <yitz> Eelis: can you package it up?
07:04:42 <Eelis> yitz: no, i know nothing about suse packaging
07:04:42 <SamB_XP> Dementati: use ghc-pkg
07:05:10 <SamB_XP> assuming the compiler you are using is GHC, of course ;-P
07:05:51 <Dementati> SamB_XP: Ah, yes. Perfect, thanks.
07:06:22 <yitz> Eelis: according to the HP page, if your distro doesn't have a package yet, you should use the generic source package. leave yourself some time for it to compile tho.
07:07:18 <SamB_XP> yitz: that source package -- it's for use with whatever GHC version was shipped with that HP?
07:07:27 <Eelis> yitz: there /are/ ghc packages for suse, so i'm not sure it's worth the trouble to try and get that HP thing from source going
07:07:50 <SamB_XP> or does the HP source package grab the GHC source and build that, too?
07:08:05 <yitz> Eelis: which version of ghc do you have there?
07:08:23 <Eelis> yitz: 6.10.1
07:08:51 <yitz> SamB_XP: the current HP source tarball requires you to have a 6.10.4 binary.
07:09:36 <yitz> Eelis: ok, so that's a bit old.
07:10:22 <SamB_XP> so what should he do, grab the GHC binary tarball or something?
07:10:29 <roconnor> @free []
07:10:29 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-23
07:10:47 <roconnor> @free return :: [a]
07:10:47 <lambdabot> $map f return = return
07:11:09 <roconnor> @free [] :: [a]
07:11:09 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-23
07:11:32 <Eelis> i know i /can/ somehow install the HP if i mess with source and/or generic binary tarballs long enough. i was just wondering what the roadmap for this utopian vision of the HP is, because clearly it's not here yet :)
07:12:09 <int-e> @free f :: a -> [a]
07:12:09 <lambdabot> $map g . f = f . g
07:12:40 <yitz> Eelis: the current version of HP has been out since last July. But your distro is way behind - your complier is almost 1.5 years old, from the pre-platform days.
07:13:02 <yitz> Eelis: but it's not hard to install the generic source tarball.
07:13:19 <Eelis> yitz: then do i understand correctly that part of the HP plan is to just sit back and hope that distro's start packaging it?
07:13:33 <yitz> SamB_XP: right, he should get a generic binary tarball of a more current version of ghc, and then install the HP source tarball.
07:15:05 <yitz> Eelis: many distros are up to date, see the list on the site. they tend to be the ones that people from the community use. so it will naturally include all the distros that are popular with hackers. to get it on other distros, we need volunteers to package it up. shouldn't be too hard.
07:15:18 <Eelis> i see. oh well.
07:16:05 <yitz> Eelis: also, perhaps people don't see it as the highest priority, since it really isn't that hard to set up from the source tar ball. and opensuse is rare in that it is so far behind on ghc itself.
07:16:53 <cogline> has anyone used Network.HTTP.Browser and experienced issues with redirects?
07:17:30 <yitz> perhaps you're right though. we should make more of an effort to find packaging volunteers.
07:18:01 <yitz> cogline: i haven't tried it, but i'm interested to know what happened to you.
07:18:02 <SamB_XP> yitz: yeah, at least for distros that package GHC
07:18:26 <yitz> SamB_XP: well, for all major distros. opensuse is a pretty important one to be missing.
07:18:59 <SamB_XP> I guess there ought to be a page about the different distro's plans for it?
07:19:04 <cogline> yitz: everytime it hits a 301 redirect, it prints recovering connection and then hangs... haven't checked if the thread is ending, so it may be exiting
07:19:17 <yitz> i see we have fedora but not redhat or centos. i wonder if they can use the fedora package.
07:19:32 <yitz> cogline: ouch
07:20:13 <yitz> a *lot* of vps providers use centos by default, and a lot of companies use redhat by default.
07:20:58 <Eelis> yitz: i'm using an old version of opensuse. for the most recent opensuse version it seems there are ghc 6.10.4 packages
07:21:09 <Eelis> and even 6.12.1
07:21:21 <yitz> ah great
07:21:27 <yitz> but not the platform?
07:21:35 <Eelis> doesn't look like it
07:21:51 <yitz> no sign of mandriva either, at least on the list at the HP site.
07:22:07 <J-roen> I want to try GHC 6.12.1 and cabal-install 0.8 on Windows Vista. I successfully installed GHC and downloaded the cabal binary, but when I try to install a package I get the following error message every time: cabal: ar is required but it could not be found. There is no package 'ar' and I can't find what else it can be. How can I solve this problem? Thanks.
07:22:08 <misk20> Hi, i am writing a interpreter for a small variant of function language and stuck in middle, can any body have any such related resources that might be helpful
07:22:48 <yitz> J-roen: ndm just posted a 6.12.1 build of cabal-install. did you get it?
07:23:13 <yitz> misk20: what are you stuck on?
07:23:20 <J-roen> yitz: No, sorry. Where can I get it?
07:23:33 <misk20> like unification
07:23:41 <yitz> J-roen: i saw it on the cafe.
07:23:46 * yitz looks
07:23:50 <J-roen> yitz: Thanks, I will take a look myself.
07:24:14 <yitz> http://community.haskell.org/~ndm/temp/cabal.zip
07:24:26 <yitz> J-roen: ^^
07:24:38 <J-roen> yitz: Thanks very much!
07:46:01 <mathijs> Hi all, in RWH (chapter 20), forkProcess is used. Also, MVars are used to hand some data to the child process. Why is this needed? MVars are meant for synchronized access between threads, but forkProcess creates a different process (which _copies_ all vars, so no need to sync them?)
07:53:40 <quicksilver> mathijs: I believe you are mistaken.
07:53:49 <dmead> something sounds wrong
07:53:59 <mathijs> I probably am :)
07:54:03 <quicksilver> mathijs: forkProcess is only used mess with FDs before exec()'ing another file
07:54:29 <quicksilver> no MVars are read or written to between the fork + exec
07:54:40 <quicksilver> all that is done is dupping and closing fds
07:56:46 <mathijs> quicksilver: well, hoogle tells me forkProcess _does_ fork and copy everything. It also mentions it should only be used to mangle fd's and executeFile (the way it is used in the book), but it does state it copies everything (except for threads) as a new process.
07:57:18 <quicksilver> mathijs: yes, that's not the part you were mistaken about.
07:57:22 <quicksilver> you are were right about that bit.
07:57:34 <quicksilver> you were wrong about "MVars are used to hand some data to the child process"
07:57:57 <quicksilver> those MVars are read just before the fork, not after it
07:58:18 <mathijs> quicksilver: but they are used inside the "child process"
07:59:15 <quicksilver> the code I'm looking at (here http://book.realworldhaskell.org/read/systems-programming-in-haskell.html )
07:59:24 <quicksilver> does not read any MVars after the fork
07:59:41 <quicksilver> the only things it does after fork is some dupTos, some closeFds, and an executeFile
07:59:48 <mathijs> nope, not MVars, but the stuff that was read from the MVar before forking.
08:00:26 <llambda> What is that symbol that looks like a crosshair?
08:00:35 <quicksilver> mathijs: yes, indeed.
08:00:42 <quicksilver> mathijs: but, no MVars are read after the fork.
08:00:42 <ben> direct sum?
08:00:48 <quicksilver> that would, as you said initially, be absurd.
08:01:09 <llambda> Yeah, thanks ben
08:01:10 <mathijs> so my question really is: why put them into an MVar in the first place? since giving them plain (normal list) to the child process would be safe right?
08:01:22 <quicksilver> mathijs: they do give a plain list to the child process.
08:01:33 <mathijs> ah, ok now I get it ;)
08:01:59 <quicksilver> the reason for using MVars at all is that they envisage you will use this in a main process which is multithreaded
08:02:15 <quicksilver> and lots of different pipe-like things may be concurrently adding to the list of "fds which must be closed next time we fork"
08:02:19 <mathijs> but even in the parent process, I don't see the need for an MVar, so I thought it was because of forking, but as you showed... the forked process doesn't get an mvar.
08:02:31 <quicksilver> it's because the parent process is multithreaded
08:02:41 <quicksilver> and they expect you to use it in a possibly even more multithreaded way
08:02:56 <mathijs> quicksilver: yeah, but I couldn't find a place where the other threads were changing the mvar
08:03:55 <mathijs> quicksilver: ok, so it's not in this code per-se, just to make the library "safe" if I decide to multithread on top of it
08:04:25 <quicksilver> yes.
08:05:03 <mathijs> quicksilver: ok thanks for helping
08:05:42 <mreh> how can I load two modules into my namespace when debugging?
08:05:53 <mreh> with GHCi
08:07:17 <mreh> I've got a function that works on data structure whose implementation is hidden, needing to debug it in GHCi, but I can't load two module at once
08:08:05 <sm> mreh: :m +*ModuleName ?
08:08:12 <quicksilver> all your interpreted modules should have hidden stuff available
08:08:13 <mreh> *?
08:08:23 <quicksilver> but if you load a compiled module it will only have public stuff available
08:08:36 <quicksilver> you may want to delete *.o files to make sure you're getting the interpreted version
08:08:41 <sm> right
08:08:42 <mreh> okay
08:08:47 <mreh> what does *do?
08:08:49 <DerisionSnort> @pl mconcat . map
08:08:50 <lambdabot> mconcat . map
08:09:01 <quicksilver> * attaches the module in the 'all members visible' form
08:09:02 <sm> loads non-exported symbols
08:09:09 <quicksilver> you get the *-version by default when you use :load anyway
08:09:21 <quicksilver> (well, you do if it chooses to interpret)
08:09:31 * sm still gets confused by :l vs. :m
08:09:40 <quicksilver> all :m does it change scope
08:09:44 <quicksilver> :m doesn't load anything
08:09:49 <quicksilver> :l loads source files.
08:10:10 <sm> quicksilver: :l wipes out your previous context, right ?
08:10:29 <HandheldPenguin> If I have a [Bool] how do I return true if all the items in the list are true?
08:10:42 <sm> HandheldPenguin: all
08:10:43 <quicksilver> sm: yes I believe so
08:10:50 <quicksilver> :t all
08:10:52 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
08:10:54 <quicksilver> you mean 'and' ;)
08:10:55 <quicksilver> :t and
08:10:56 <lambdabot> [Bool] -> Bool
08:11:09 <sm> huh
08:11:15 <quicksilver> all is for predicates on a list, and is for a Bool list
08:11:25 <quicksilver> > all even [2,4,6]
08:11:26 <lambdabot>   True
08:11:31 <quicksilver> > and [True,True,True]
08:11:32 <lambdabot>   True
08:11:35 * sm didn't know and did that
08:11:48 <sm> > or [False, True]
08:11:49 <lambdabot>   True
08:12:00 <roconnor> @src all
08:12:00 <lambdabot> all p =  and . map p
08:12:07 <HandheldPenguin> Ok, thanks.
08:14:34 <mreh> that worked
08:14:58 <mreh> that's why is sometimes appends '*' to my module names
08:15:51 <RayNbow> preflex: seen copumpkin
08:15:51 <preflex>  copumpkin was last seen on #haskell-blah 11 hours, 17 minutes and 10 seconds ago, saying: holy shit I've spent so much time on these slides
08:15:54 <edwardk> mreh ?
08:16:30 <mreh> BOO!
08:16:34 <mreh> haha, suprised you
08:17:14 <HandheldPenguin> Ok, me again, where do I put the 'all' in in here... http://haskell.pastebin.com/K1Dkupry ?
08:17:59 <zygoloid> @type isDigit
08:18:01 <lambdabot> Char -> Bool
08:18:03 <zygoloid> @type all isDigit
08:18:04 <lambdabot> [Char] -> Bool
08:18:06 <zygoloid> @type all
08:18:07 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
08:18:16 <zygoloid> @src String
08:18:16 <lambdabot> type String = [Char]
08:18:50 <zygoloid> HandheldPenguin: ^^ String is just a list of Char. all takes a predicate (function from something to Bool) on type 'a' and produces a predicate on type list-of-a
08:18:59 <HandheldPenguin> huh?
08:19:07 <HandheldPenguin> I want to convert my [Bool] to Bool
08:19:34 <mux> :t or
08:19:36 <lambdabot> [Bool] -> Bool
08:19:36 <mux> :t any
08:19:38 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
08:19:41 <mux> err
08:19:43 <mux> :t and
08:19:44 <lambdabot> [Bool] -> Bool
08:20:29 <zygoloid> HandheldPenguin: if you just want the answer, you should write: digits xs = all (all isDigit) xs
08:20:30 <byorgey> HandheldPenguin: in that definition, you should replace  :  by  &&
08:20:39 <HandheldPenguin> cool
08:20:40 <HandheldPenguin> thanks
08:20:46 <byorgey> zygoloid: that doesn't type check
08:21:00 <zygoloid> @type all (all isDigit)
08:21:01 <lambdabot> [[Char]] -> Bool
08:21:02 <byorgey> HandheldPenguin: however, note that what you are doing is applying 'isDigit' to every element of a list
08:21:21 <byorgey> HandheldPenguin: this pattern (applying a function to every element of a list) is what 'map' does
08:21:26 <zygoloid> i see, the problem has changed since last time :)
08:21:32 <HandheldPenguin> Nope
08:21:42 <byorgey> so instead of what you have you could have written  'digits = map isDigit'
08:21:53 <HandheldPenguin> :D I'm still tryign to get my head around all this functional stuff
08:21:56 <MadHatterDude> @pl (\x y z -> x ++ " -> " ++ y ++ " -> " ++ z)
08:21:56 <lambdabot> (. (((" -> " ++) .) . (. (" -> " ++)) . (++))) . (.) . (++)
08:22:11 <byorgey> that would give you a list of Bool values
08:22:28 <byorgey> then you could apply and to that, so  digits s = and (map isDigit s)
08:22:41 <byorgey> but that is the same as   digits = all isDigit
08:23:14 <aavogt> > \a b c -> intercalate " -> " [a,b,c]
08:23:16 <lambdabot>   ""->
08:23:16 <lambdabot>    ""->
08:23:16 <lambdabot>      ""->
08:23:16 <lambdabot>        " ->  -> "
08:23:16 <lambdabot>      "a"->
08:23:18 <lambdabot>        " ->  -> a"
08:23:20 <lambdabot>     ...
08:23:46 <HandheldPenguin> What's annoying is if I were to type all isDigit['4'] into ghci is that it would work
08:24:01 <byorgey> ok, why is that annoying?
08:24:18 <HandheldPenguin> Well I want to be able to apply that to the input of my function...?
08:24:19 <MadHatterDude> @hoogle intercalate
08:24:20 <lambdabot> Data.ByteString intercalate :: ByteString -> [ByteString] -> ByteString
08:24:20 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
08:24:20 <lambdabot> Data.ByteString.Char8 intercalate :: ByteString -> [ByteString] -> ByteString
08:24:22 <HandheldPenguin> In written form
08:24:35 <HandheldPenguin> in .hs file
08:24:37 <byorgey> HandheldPenguin: ok, so just say:  digits s = all isDigit s
08:25:08 <byorgey> isn't that what you just said?  apply 'all isDigit' to the input of your function.
08:25:12 <byorgey> the input is s.
08:25:16 <MadHatterDude> @pl \x -> concat (interpserse " " x)
08:25:16 <lambdabot> join . interpserse " "
08:25:24 <MadHatterDude> @hoogle join
08:25:24 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
08:25:24 <lambdabot> System.FilePath.Posix joinDrive :: FilePath -> FilePath -> FilePath
08:25:25 <lambdabot> System.FilePath.Windows joinDrive :: FilePath -> FilePath -> FilePath
08:25:50 <byorgey> MadHatterDude: join = concat  in the list monad.
08:26:04 <byorgey> concat :: [[a]] -> [a],  join :: m (m a) -> m a
08:26:07 <MadHatterDude> byorgey: yeah, I figgured
08:26:48 <MadHatterDude> Would it be possible to write a haskell preprocessor that preprocessed haskell with haskell?
08:27:02 <byorgey> HandheldPenguin: sure.
08:27:06 <byorgey> er, MadHatterDude
08:27:21 <MadHatterDude> byorgey: That would be awesome.
08:27:25 <gwern> yo dawg...
08:27:36 <MadHatterDude> gwern: Oh no...
08:27:37 <Arnar> oh god.. don't finish that
08:27:43 <byorgey> hehe
08:27:45 <gwern> @quote i.*heard
08:27:45 <lambdabot> quicksilver says: I heard you like binding so I put a language in your language so you can let_ while you let?
08:28:04 <gwern> @quote so.*you.*can
08:28:05 <lambdabot> jcreigh says: <chessguy> i mean if someone says factorial should be of type String -> [(Float, Bool)], you should just tell them they're nuts  <jcreigh> > let fac n = map (\x -> (x, True)) $ scanl (*
08:28:05 <lambdabot> ) 1 [1..(read n)] in fac "5" :: [(Float, Bool)]
08:28:32 <byorgey> MadHatterDude: to write a standalone preprocessor you'd probably want to use haskell-src-exts
08:28:35 <gwern> hm. too general a regexp :)
08:28:37 <gwern> @quote so.you.can
08:28:37 <lambdabot> chrisdone says: yo dawg we heard you like haskell so we installed a lambdabot in your ghci so you can monad while you monad
08:28:46 <byorgey> which is a Haskell parser written in Haskell
08:28:56 <MadHatterDude> ok
08:29:01 <zygoloid> @quote HERD
08:29:01 <lambdabot> pjdelport says: YO DAWG I HERD YOU LIKE CARS SO WE PUT A PAIR IN YO CAR SO YOU CAN CAR WHILE YOU CAR
08:29:06 <byorgey> MadHatterDude: there's also Template Haskell which might work, depending on what you actually want to do
08:29:07 <gwern> byorgey: I suppose hlint is already a preprocessor - it processes haskell into more idiomatic haskell
08:29:22 <aavogt> it doesn't do substitutions though
08:29:22 <MadHatterDude> @pl (\x y z -> [x, y, z])
08:29:23 <lambdabot> (. ((. return) . (:))) . (.) . (:)
08:29:25 <gwern> and then there's that literal xml syntaxd preprocessor thing
08:29:31 <byorgey> true, and it uses haskell-src-exts, doesn't it?
08:29:40 <gwern> aavogt: not very hard - I have a feature open on hlint for that
08:29:52 <gwern> @quote so.you.can
08:29:52 <lambdabot> quicksilver says: I heard you like binding so I put a language in your language so you can let_ while you let?
08:29:55 <gwern> @quote so.you.can
08:29:55 <lambdabot> quicksilver says: I heard you like binding so I put a language in your language so you can let_ while you let?
08:30:02 <gwern> hm. did mine disappear?
08:30:13 <aavogt> gwern: there's the issue of not losing comments in the original source
08:30:14 <zygoloid> @quote dawg.*interpret
08:30:14 <lambdabot> mauke says: YO DAWG I HEARD YOU LIKE METACIRCULARITY SO WE PUT AN INTERPRETER IN YOUR INTERPRETER SO YOU CAN RUN CODE WHILE YOU RUN CODE
08:30:31 <gwern> @quote good.news
08:30:32 <lambdabot> gwern says: good news everyone! we heard you like interpreters so we used the 3rd futamura projection to interpret your compiler so you can compile while you interpret!
08:30:59 <zygoloid> heh. i like the futurama^Wfutamura reference
08:31:05 <aavogt> > sort "futamura" == sort "futarama"
08:31:06 <lambdabot>   False
08:31:13 <byorgey> HandheldPenguin: so, does that make sense?  or are you still confused?
08:31:41 <gwern> > sort "futurama" == "futamura"
08:31:42 <byorgey> > sort "futamura" = sort "futurama"
08:31:42 <lambdabot>   False
08:31:43 <lambdabot>   <no location info>: parse error on input `='
08:31:47 <zygoloid> > comparing sort "futurama" "futamura"
08:31:48 <lambdabot>   EQ
08:31:48 <mreh> they are so the same
08:31:53 <MisterN> > sort "futurama"
08:31:54 <lambdabot>   "aafmrtuu"
08:31:55 <zygoloid> helps if you spell them right :)
08:32:01 <byorgey> gah, we all fail
08:32:11 <byorgey> except zygoloid
08:32:13 <mreh> eyeball win!
08:32:18 <gwern> ??? I thought I spelled it right
08:32:27 <byorgey> gwern: you forgot the second sort =)
08:32:27 <medfly> == :)
08:32:32 <MisterN> :src comparing
08:32:32 <gwern> d'oh
08:32:35 <byorgey> and I forgot the second =
08:32:37 <medfly> > sort "futamura" == sort "futurama"
08:32:37 <HandheldPenguin> byorgey: Very confused :S!
08:32:38 <lambdabot>   True
08:33:02 <gwern> the anagram just makes my futurama joke better
08:33:12 <HandheldPenguin> I want to be able to do 'digits ['444']'
08:33:17 <HandheldPenguin> and for that to return true
08:33:35 <byorgey> HandheldPenguin: ['444'] doesn't make sense, ' '  is only for single characters
08:33:49 <HandheldPenguin> oh :(
08:33:54 <zygoloid> > all isDigit "444"
08:33:55 <lambdabot>   True
08:33:55 <byorgey> I think you want either ['4','4','4'] or even better, "444"
08:34:01 <HandheldPenguin> ah yeah
08:34:02 <HandheldPenguin> The latter
08:34:16 <HandheldPenguin> No wonder I was having trouble
08:34:21 <byorgey> hehe
08:34:55 <byorgey> HandheldPenguin: so does it work with "444"?
08:34:57 <Arnar> :t 'a'
08:34:58 <HandheldPenguin> Thanks guys
08:34:58 <lambdabot> Char
08:34:59 <Arnar> :t "a"
08:35:00 <HandheldPenguin> Yeah it does now
08:35:00 <lambdabot> [Char]
08:35:03 <byorgey> great =)
08:35:09 <HandheldPenguin> digits s = all isDigit s
08:35:11 <HandheldPenguin> Cheers.
08:35:19 <HandheldPenguin> By far the most helpful irc I have ever seen lol
08:35:26 <Arnar> HandheldPenguin: if you want to be fancy-pants:
08:35:29 <Arnar> digits = all . isDigit
08:35:33 <Arnar> ;)
08:35:39 <byorgey> HandheldPenguin: excellent.  and note that (if you want) you can remove the s from both sides:  digits = all isDigit
08:35:50 <Arnar> sry.. meant that
08:35:52 <Arnar> ignore me
08:36:27 <HandheldPenguin> Thanks...one of my problems was that I think this answer may have been overengineered :D http://answers.yahoo.com/question/index?qid=20090308080419AANMmfc
08:36:36 <HandheldPenguin> Note, that isn't me asking the question on there
08:36:43 <zygoloid> HandheldPenguin: if you want 'digits [] = False' then you can't use "digits = all isDigit" for the second line, sadly, since haskell requires all definitions to have the same number of arguments
08:37:03 <HandheldPenguin> ok
08:37:44 <byorgey> HandheldPenguin: it is, a bit =)
08:39:09 <companion_cube> hello
08:39:17 * copumpkin loves companion_cube 
08:39:25 * copumpkin throws companion_cube into the fiery pit
08:39:33 <companion_cube> I have problems building haskell-plugins on both archlinux and debian
08:39:42 <companion_cube> \o/ copumpkin
08:39:51 * companion_cube draws ♥ everywhere
08:40:10 * gwern wonders what haskell-plugins is
08:40:32 <companion_cube> it enables dynamic linking of haskell code
08:40:43 <companion_cube> I think lambdabot uses this
08:40:57 <gwern> not anymore
08:40:58 * zygoloid disregards companion_cube's advice
08:41:54 * companion_cube promises some cake to everyone here wearing a red suit
08:42:04 <copumpkin> LIES!
08:42:29 <companion_sphere> I'm harder
08:42:50 <benmachine> you are not harder you are just more tedious
08:42:56 <companion_sphere> :(
08:43:34 <zygoloid> companion_sphere: i don't need you, i'm just going to stack up a bunch of security cameras i found offstage
08:43:37 * companion_sphere rolls himself into the fiery pit
08:43:55 <copumpkin> I hope they don't fuck up the sequel :)
08:44:10 <zygoloid> likewise
08:44:15 <benmachine> lambdabot uses mueval
08:44:22 <benmachine> in case anyone didn't cover that
08:44:25 <copumpkin> but they've been pretty good with all the games they've made so far, so they'll probably do a good job
08:44:29 <benmachine> i.e. spawns a separate process
08:44:32 <copumpkin> how about nueval?
08:44:45 <benmachine> the very idea is absurd
08:44:55 <zygoloid> copumpkin: you mean the Narbacular Drop guys or Valve?
08:45:13 <benmachine> also my feet are cold because I am not wearing socks
08:45:20 <copumpkin> zygoloid: valve mostly, but I think the narbacular drop guys are working for valve now aren't they?
08:45:21 <benmachine> what to do what to do
08:45:39 <zygoloid> copumpkin: yep. no idea how much portal2 is still their baby though
08:45:56 <copumpkin> anyway, valve makes awesome games even aside from portal, so I think we're safe
08:46:07 <zygoloid> benmachine: my right toe is cold due to my sock having twice the normal number of holes
08:46:27 <copumpkin> I'm making a note here, huge success
08:46:29 <benmachine> my heels always fail before the toes
08:46:38 * zygoloid wonders why HL2EP3 is taking so long
08:46:45 <benmachine> maybe I have pointy heels
08:47:00 <Jafet> Dual of a mpanion sphere?
08:47:03 <zygoloid> maybe i should buy some nailclippers
08:47:14 <copumpkin> zygoloid: maybe they wanted to cover more of portal before doing EP3 because they're in more or less the same setting
08:47:22 <copumpkin> and they felt they needed to expand on it a bit
08:47:40 <zygoloid> i hope so. i'm also wondering if it's taking longer because they need to make it portalgun-safe
08:48:51 <benmachine> I always felt cheated by the places where they put no-portal walls
08:48:55 <benmachine> seemed cheap to me
08:49:05 <benmachine> also I was upset that you couldn't fire portals through portals
08:49:18 <zygoloid> benmachine: well, you can.
08:49:21 <zygoloid> (ish)
08:49:26 <benmachine> ish?
08:49:30 <tensorpudding> wow
08:49:39 <tensorpudding> mike patton provided vocal growling effects in portal
08:49:46 * zygoloid got ridiculously low #portals for some of the challenges using this technique
08:50:09 <zygoloid> stand just through a portal, fire a portal and backpedal through the portal before the shot hits the wall
08:50:10 <copumpkin> you can fire a portal through another if you're half sticking through it
08:50:31 <benmachine> that's pretty cool
08:50:35 <zygoloid> you need to travel through it before it hits or you tend to fall down
08:50:38 <benmachine> but not as cool as actually doing it would be :P
08:51:00 <copumpkin> I think you could make an awesome tactical deathmatch out of it, but it might not be too popular
08:51:25 <benmachine> also if everyone has a portal gun isn't your GPU going to get upset
08:51:30 <copumpkin> lol
08:51:50 <copumpkin> you'd have all sorts of murderous devices and bottomless pits and stuff, and need to get the other players to fall through your portals into the death traps
08:52:12 <benmachine> hmm
08:52:43 <benmachine> I sometimes wonder if
08:53:00 <benmachine> if one made a game with, say, 90s-era graphics i.e. very very basic 3D
08:53:05 <zygoloid> > let portal = In portal : portal in portal
08:53:06 <lambdabot>   No instance for (GHC.Show.Show (L.Mu []))
08:53:06 <lambdabot>    arising from a use of `M145236...
08:53:19 <copumpkin> lol
08:53:20 <benmachine> you'd be able to throw around so many of them at once that
08:53:39 <benmachine> you could do things like portals everywhere
08:53:45 <jmcarthur> "The primitive operators [like first class functions] that are necessary to implement [things like reduce] are built into Python, where in functional languages, those concepts are the primitive operations [because functional languages lack the primitives like first class functions that are necessary to implement them]." -- Guido
08:54:05 * jmcarthur throws his hands up
08:54:11 <benmachine> that makes no sense
08:54:16 <benmachine> where did you get that from
08:54:18 * copumpkin points a gun at jmcarthur 
08:54:21 <jmcarthur> that's what i read into from this: http://fold.sigusr2.net/2010/03/guido-on-functional.html
08:54:24 <jmcarthur> benmachine: ^^
08:54:33 <copumpkin> wow
08:54:37 <copumpkin> that's a pretty impressive quotation
08:54:52 <benmachine> list isn't a functional language?
08:55:03 <jmcarthur> i think he's talking about common lisp
08:55:09 <copumpkin> "You can write reduce() in a few lines of Python. Not so in a functional language."
08:55:11 <jmcarthur> sometiems i tend to agree
08:55:20 <copumpkin> that just shows he's ignorant
08:55:21 <Alpounet> that's ... impressive indeed
08:55:32 <jmcarthur> what gets me is the people on reddit defending him
08:55:53 <benmachine> ooh where are they
08:55:54 <jmcarthur> and they accuse *us* of circle jerking...
08:56:06 <arw_> the world is full of less able people. ignore them or die of heart failure :)
08:56:09 <jmcarthur> http://www.reddit.com/r/programming/comments/baph7/you_can_write_reduce_in_a_few_lines_of_python_not/
08:56:30 <jmcarthur> admittedly, most commenters aren't really defending him. just a few
08:56:52 <zygoloid> i'm lost. is he saying that first class functions are primitive in functional languages because without them you can't implement them, whereas in python, they're ... also primitive?
08:57:15 <jmcarthur> zygoloid: he's saying that reduce is a primitive in functional languages because you can't implement it otherwise
08:57:22 <Jafet> When reading that, always remember that you're reading success itself.
08:57:33 <jmcarthur> zygoloid: but you can implement reduce in python because, among other things, it has first class functions
08:57:44 <jmcarthur> Jafet: success is pretty random sometimes
08:57:55 <Jafet> Be quiet, pointy-haired lambda-twiddler
08:58:00 <jmcarthur> zygoloid: that's what i read into it, anyway
08:58:01 <zygoloid> wait, what. so he's saying that functional languages (one definition: languages with first-class functions) all lack first-class functions?
08:58:13 <jmcarthur> zygoloid: that's what i think
09:00:19 <Jafet> While we're in this mood, someone link to his comments on GIL and tail recursion
09:01:06 <tensorpudding> another guido rant?
09:01:57 <Zao> Jafet: It's linked in the thread.
09:02:10 <Zao> At least the tail-calls.
09:02:13 <Jafet> Oh, naturally.
09:02:15 <Zao> http://mail.python.org/pipermail/python-dev/2004-July/046353.html <- that
09:03:04 <tensorpudding> hmm, forgot how lame /r/programming was
09:03:31 <tensorpudding> lots of really whingey comments
09:05:09 <fasta> Did you know that map is a built-in in Python?
09:05:20 <gwern> :i Foldable
09:05:26 <gwern> hm.
09:05:35 <gwern> Foldable has a lot of methods for a typeclass like that
09:05:37 <Alpounet> fasta, uh ?
09:06:15 <RayNbow> Python's map is more than a map
09:06:21 <RayNbow> it's also zipWithN
09:06:38 <seanmcl> is there a way to get profiling info on the containers package?  I can't get cabal to reinstall them with profiling turned one.
09:06:40 <fasta> RayNbow, I am fairly sure that Scheme implementations don't do that.
09:06:43 <byorgey> yes, and now that GHC can derive Foldable, you can write 'reduce' in Haskell for *any* (sufficiently regular) data type in *zero* lines of code =)
09:06:49 <benmachine> well, map is technically zipWith1 >_>
09:06:57 <gwern> byorgey: since when could hc do that?
09:07:07 <benmachine> 6.12 derives Foldable
09:07:09 <byorgey> gwern: since 6.12, see my recent blog post
09:07:22 <benmachine> also Traversable
09:07:24 <gwern> seanmcl: reinstalling containers or base is a sure way to you have no chance make your time
09:07:41 <byorgey> gwern: http://byorgey.wordpress.com/2010/03/03/deriving-pleasure-from-ghc-6-12-1/
09:07:46 <seanmcl> gwern:  sorry, I don't understand
09:08:06 <gwern> YOU ARE ON THE WAY TO DESTRUCTION YOU HAVE NO CHANCE MAKE YOUR TIME HA HA HA
09:08:09 <byorgey> seanmcl: http://en.wikipedia.org/wiki/All_your_base
09:08:18 <zygoloid> TAKE OFF EVERY ZIG
09:08:30 <edwardk> byorgey:ooh, when did ghc pick up derive (Foldable)?
09:08:30 <byorgey> FOR GREAT JUSTICE
09:08:37 <fasta> byorgey, that counts as one line of code, but zero lines of thought.
09:08:48 <byorgey> edwardk: since 6.12.1, and also Functor and Traversable
09:08:49 <edwardk> hah, already answered
09:08:51 <edwardk> nice
09:09:24 <shepheb> whoa, deriving (Functor, Foldable, Traversable) without GeneralizedNewtypeDeriving?
09:09:41 <edwardk> byorgey: that eliminates a hell of a lot of boilerplate from my code =)
09:09:48 <byorgey> edwardk: heck yes it does =)
09:09:53 <shepheb> what traversal order would it give to eg. data BTree a = Empty | Node (BTree a) a (BTree a) ?
09:10:03 <byorgey> shepheb: the only one that makes sense. ;)
09:10:12 <benmachine> I did wonder about that
09:10:17 <shepheb> preorder, postorder, inorder, levelorder...
09:10:20 <byorgey> well, fair enough, I guess you could do it in different orders.
09:10:27 <byorgey> it just does it L-R
09:10:27 <edwardk> shepheb: assume it will give you the one without the lambda ;)
09:10:27 <benmachine> since there's only one functor but multiple possible folds
09:10:30 <shepheb> my money's on preorder, but it's still an arbitrary decision, isn't it?
09:10:36 <benmachine> but I reckon it'll do it left to right
09:10:37 <byorgey> based on how you declare your constructors.
09:10:52 <shepheb> oh, I see
09:10:52 <byorgey> shepheb: for that definition, it would do inorder.
09:10:59 <shepheb> awesome
09:11:10 <benmachine> you don't *have* to derive those classes
09:11:19 <shepheb> no, of course not
09:12:11 <benmachine> so we have what, 9 derivable classes now?
09:12:38 <benmachine> enum eq ord show read data typeable foldable functor traversable guess that's 10
09:12:59 <arw_> @source map
09:12:59 <lambdabot> map not available
09:13:05 <benmachine> @src map
09:13:06 <lambdabot> map _ []     = []
09:13:06 <lambdabot> map f (x:xs) = f x : map f xs
09:13:08 <benmachine> @help source
09:13:09 <lambdabot> source <lib>. Lookup the url of fptools libraries
09:13:13 <Jafet> Coming soon, automatic class derivation
09:13:13 <byorgey> benmachine: more than that I think
09:13:27 <benmachine> byorgey: oh?
09:13:36 <byorgey> Eq Ord Enum Ix Bounded Read Show Typeable Data Functor Foldable Traversable
09:13:38 <shepheb> "It looks like you're writing monadically and haven't realized it."
09:13:38 <byorgey> that's 12
09:13:40 <MadHatterDude> Hey, guys! I made a concatenative sub language
09:13:52 <benmachine> oh I forgot Bounded, and I didn't know Ix was deriveable
09:14:29 <benmachine> (I guess that works pretty much like Enum?)
09:14:49 <zygoloid> TH for the win! deriveMyTypeclass ''MyType
09:14:52 <byorgey> I guess so, I don't think I've ever used deriving Ix
09:14:59 <Jafet> data Foo = ... deriving (Derivable)
09:15:44 <Jafet> Then derivations are added on demand until your code typechecks
09:15:49 * benmachine envisions a source file containing only "derive WebServer"
09:17:47 <benmachine> hmm, I wonder what the most constructors you could apply to a single data declaration would be
09:17:50 <benmachine> err
09:17:53 <benmachine> the most derivings
09:18:03 <benmachine> I don't think you can have Enum and Functor on the same thing
09:18:18 <MadHatterDude> benmachine: watch me.
09:18:19 <benmachine> or maybe you could
09:20:12 <benmachine> woah that's weird
09:20:14 <MadHatterDude> Nope, Functor and Enum, not possible
09:20:25 <MadHatterDude> ?
09:20:34 <zygoloid> benmachine: as many as you like with GeneralizedNewtypeDeriving
09:20:51 <benmachine> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23337#a23337 not the friendliest of messages
09:20:56 <benmachine> zygoloid: I said data :P
09:21:04 <zygoloid> oh, oops :)
09:21:12 <zygoloid> it's a pity you can't derive generic classes
09:21:23 <benmachine> how would that work?
09:21:52 <zygoloid> same way standalone deriving works for them.
09:22:12 <benmachine> it does?
09:22:23 <benmachine> what do you mean by generic classes
09:22:24 <zygoloid> umm, no, wait, that's not how you do it
09:22:41 <zygoloid> you say 'instance Foo x' and leave off the 'where' iirc
09:22:51 <benmachine> oicwhatyoumean
09:22:53 <zygoloid> benmachine: these things: http://www.haskell.org/ghc/docs/latest/html/users_guide/generic-classes.html
09:23:18 <zygoloid> i guess the trouble is that GHC doesn't know what the context should be. but surely it can infer it from the generic definitions? :)
09:24:25 <benmachine> data Const t = Unit deriving Enum
09:24:31 <benmachine> ^ this does strange things
09:24:39 <zygoloid> huh, that looks like it should work
09:24:49 <benmachine> it fails in a way that smells buggy
09:25:39 <zygoloid> 'not applied to enough type arguments'? yeah, that looks like a bug
09:26:09 <benmachine> that doesn't sound like what I've got, are you on 6.10?
09:26:15 <zygoloid> i get the same on both
09:26:23 <zygoloid> (6.10.1 and 6.8.3)
09:26:34 <benmachine> I'm on 6.12 :P
09:26:38 <benmachine> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23337#a23337 and this is what I get
09:27:30 <zygoloid> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23337#a23338 this is what I get
09:27:57 <zygoloid> looks like a different wording for the same error
09:28:07 <benmachine> oh right
09:28:08 <benmachine> yes
09:28:11 <benmachine> probably
09:28:32 <c_wraith> looks like a legit error to me
09:28:41 <benmachine> interesting how the line is given as 1
09:28:45 <c_wraith> You can't have a value of type K
09:28:50 <c_wraith> (in the second example)
09:28:58 <benmachine> you can't no
09:28:58 <c_wraith> Because K has kind * -> *
09:29:03 <benmachine> but you can have a value of type K a
09:29:08 <zygoloid> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23337#a23339 <-- here's what it derived
09:29:12 <c_wraith> Sure, but look at what the error is actually about.
09:29:25 <zygoloid> c_wraith: the error is in code GHC incorrectly generated
09:29:35 <roconnor> @free comonoid :: a -> (a,a)
09:29:36 <lambdabot> $map_Pair f f . comonoid = comonoid . f
09:30:00 <c_wraith> Oh, I see.  In the derived definition of Enum.
09:30:06 <zygoloid> Main.$tag2con_K (GHC.Base.I# a_a8j) = GHC.Prim.tagToEnum# a_a8j :: Main.K
09:30:06 <copumpkin> @free moo :: a -> (a, a, a)
09:30:06 <lambdabot> $map_Triple f f f . moo = moo . f
09:30:12 <zygoloid> ^^ it's put in a broken type signature here
09:30:20 <zygoloid> everything else looks ok i think
09:31:02 <c_wraith> that looks like a bug with deriving Enum, indeed.
09:31:23 <benmachine> yeah seems like an oversight on the grounds that there's virtually no reason anyone'd want to derive enum on a parameterised data type :P
09:31:23 <copumpkin> yay bugs
09:31:39 <copumpkin> > [[1,2]..[3,4]]
09:31:40 <lambdabot>   No instance for (GHC.Enum.Enum [t])
09:31:40 <lambdabot>    arising from the arithmetic sequence...
09:31:42 <copumpkin> boo
09:34:22 <Jafet> How would that work
09:37:25 <bitstream0101> Can someone help me figure out how the type of (flip id) is derived?
09:37:34 <benmachine> ugh every time I want to submit a ghc bug I forget my password
09:37:39 <benmachine> every. single. time
09:37:48 <benmachine> bitstream0101: how far have you got?
09:38:23 <bitstream0101> benmachine: just some scribbles, but not making much headway. i think that the use of flip will constrain the argument to id to be a function type of some kind.
09:39:09 <Jafet> *->*>*
09:39:35 <benmachine> :t flip
09:39:36 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
09:39:39 <benmachine> augh
09:39:42 <benmachine> :t Prelude.flip
09:39:44 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
09:39:47 <ddarius> benmachine: Write it down and stick it to your monitor.
09:40:02 <benmachine> what why
09:40:05 <copumpkin> that's always the best way to store passwords
09:40:08 <benmachine> oh
09:40:09 <benmachine> that
09:40:17 <benmachine> I thought you were talking about the type signature for flip
09:40:29 <bitstream0101> i guess i'm not clear how (a->b->c) gets unified with id's type, actually
09:40:43 <benmachine> bitstream0101: does it help if you think of it as a -> (b -> c)?
09:40:46 <ddarius> bitstream0101: Learn Prolog.
09:40:57 <bitstream0101> ddarius: :)
09:41:20 <bitstream0101> benmachine: perhaps, but won't that constraint a to be (b->c)?
09:41:29 <benmachine> yes, yes it will
09:41:29 <edwardk> hah, is there a caleskel flip on here as well?
09:41:34 <copumpkin> yep
09:41:36 <c_wraith> I had a 6.12 bug to report, but couldn't even get password recovery to work properly
09:41:38 <edwardk> lol
09:41:41 <bitstream0101> oh :P
09:41:44 <copumpkin> :t (++)
09:41:45 <lambdabot> forall m. (Monoid m) => m -> m -> m
09:41:47 <bitstream0101> thanks >.>
09:41:49 <copumpkin> evil monoids infected us too
09:41:53 <benmachine> :P
09:42:11 <ddarius> I don't really, actually, have a problem with generalizing (++) to Monoid.
09:42:11 <edwardk> copumpkin: thats perfectly ok ;)
09:42:22 <copumpkin> NO!! the monoids are infecting our monoids
09:42:28 <copumpkin> minds, even!
09:42:31 <benmachine> I like ++ being mappend
09:42:31 <copumpkin> see! it's already happening
09:42:32 <dmead> anybody know a good trick for describing a tuple of arbitrary length in an ADT?
09:42:42 <benmachine> although I heard someone suggest +> for mappend
09:42:43 <edwardk> ddarius: the dilemma comes down to monoid vs. monadplus/functorplus
09:42:46 <benmachine> and <+ for flip mappend
09:42:48 <benmachine> which is nice as well
09:42:50 <copumpkin> dmead: nested tuples
09:42:59 <dmead> nested you say?
09:43:09 <copumpkin> > (5, (True, ("moo", (LT, ()))))
09:43:09 <benmachine> edwardk: monoid is up to 30% more awesome than monadplus imo
09:43:10 <lambdabot>   (5,(True,("moo",(LT,()))))
09:43:13 <ddarius> copumpkin: Well, monoids form and M-set via monoids acting on monoids via the endofunctor monoid.
09:43:13 <edwardk> benmachine: i think the ultimate resolution was <>
09:43:20 <copumpkin> dmead: tada!
09:43:26 <benmachine> edwardk: what that doesn't help at all
09:43:29 <c_wraith> Yeah, if I try to use the reset password I got from GHC Trac, I end up in an infinite redirect loop.
09:43:40 <dmead> ahh
09:43:42 <copumpkin> dmead: that's basically all HList is, with a lot of MPTCs to give you type-level functions
09:43:44 <ddarius> dmead: Probably not useful to you, but maybe interesting, but look up the Zip Calculus.
09:44:05 <edwardk> benmachine: the +> gives an appearance of asymmetry to a fundamentally associative operator. <+ is a fairly artificial addition that only makes sense once you've adopted that asymmetry
09:44:29 <dmead> mhmm!
09:44:37 <benmachine> edwardk: associative but not commutative
09:45:13 <benmachine> the monoid instance for Ordering is pretty obviously asymmetric
09:45:21 * copumpkin associates with many commuters
09:45:24 <benmachine> (for example)
09:45:42 <benmachine> do you commute with many associates though
09:45:42 <edwardk> benmachine: sure, but you can section. rarely when i work with a monoid do i find myself flipping all over the place enough that it is any more fundamental than just being explicit about using flip mappend
09:46:00 <benmachine> edwardk: well, okay
09:46:12 <benmachine> but rarely do I find myself using =<<
09:46:18 <benmachine> but it's still neat to have it there
09:46:26 <copumpkin> I almost exclusively use =<<
09:46:37 <jmcarthur> same
09:46:38 <benmachine> using flip with operators is less convenient than with functions
09:46:40 <copumpkin> it's either do or =<< for me
09:46:41 <edwardk> i prefer =<< because it is closer to the 'correct' definition, which doesn't presuppose the category has exponentials ;)
09:46:46 <jmcarthur> i sometimes use >>= for IO
09:46:48 <jmcarthur> that's it
09:47:13 <edwardk> @type (=<<)
09:47:15 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
09:47:16 <jmcarthur> but for IO i usually just use do notation, now
09:47:28 <copumpkin> DO NOT FEAR THE DO
09:47:30 <jmcarthur> for most other monads, =<< all the way
09:47:40 <edwardk> Monad m => (a -> mb) -> (m a -> m b) -- takes a kleisli arrow into an arrow in the underlying category.
09:47:49 <edwardk> @type (>>=)
09:47:51 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
09:47:54 <mm_freak> i use do notation and (>>=) or (=<<) intermixed
09:47:57 <edwardk> is a cluttered mess ;)
09:48:05 <edwardk> it is easy to dualize the former.
09:48:06 <copumpkin> yep :)
09:48:16 <edwardk> Comonad m => (m a -> b) -> m a -> m b
09:48:22 <edwardk> the latter is far less clear ;)
09:48:40 <mm_freak> do content <- mapM readFile =<< getFiles; doSomethingWith content
09:49:06 <benmachine> well fine I'm wrong about everything
09:49:09 <edwardk> because you have to recognize that the (m a -> m b) that results, is split and flipped around
09:49:13 <edwardk> benmachine: =)
09:49:23 <copumpkin> screw =<<, we should use <=< all the time, maybe with a const and an undefined if necessary
09:49:27 <benmachine> heh
09:49:32 <jmcarthur> <3 <=<
09:49:40 * copumpkin is a fish convert
09:49:41 <jmcarthur> i only wish i could use it more
09:49:52 <mm_freak> copumpkin: what's wrong with =<<, if you don't need <=<?
09:50:01 <edwardk> jmcarthur: that looks like some strange cupid operator
09:50:01 <dmead> copumpkin, phish or fish?
09:50:06 <benmachine> :t flip const myThreadId
09:50:06 <jmcarthur> haha
09:50:07 <lambdabot> Not in scope: `myThreadId'
09:50:09 <benmachine> hmm
09:50:10 <copumpkin> mm_freak: =<< is not a fish! <=< is.
09:50:20 <dmead> fishy face
09:50:21 <dmead> sad face
09:50:27 <dmead> ==<
09:50:31 <benmachine> no that's silly normal const is fine
09:50:44 <copumpkin> @let tsnoc = flip const
09:50:46 <lambdabot>  Defined.
09:50:51 <benmachine> heehee
09:50:54 * copumpkin submits a libraries proposal for adding that
09:50:55 <mm_freak> hmm
09:51:15 <benmachine> all functions should have a flipped version made by spelling it backwards >_>
09:51:23 <benmachine> in fact it should be a language feature!
09:51:31 <jmcarthur> mm_freak: "do content <- mapM readFile =<< getFiles; doSomethingWith content"  ew... mixing =<< with do notation in the IO monad
09:51:47 <mm_freak> jmcarthur: sure
09:51:58 <benmachine> in the case of palindromes hmm
09:52:03 <stevenmarky> heh
09:52:14 <jmcarthur> doSomethingWith <=< mapM readFile =<< getFiles
09:52:19 <copumpkin> are those the streets that palin drives on?
09:52:24 <olsner> clearly, functions spelled as palindromes need to be their own inverses
09:52:28 <benmachine> very possibly
09:52:38 <benmachine> heh
09:52:39 <mm_freak> jmcarthur: i'm not assuming a simple 'doSomethingWith'
09:52:40 <Jafet> deriving (Invertible)
09:52:57 <aavogt> od tnetnoc -< Mpam eliFdaer <<= ;seliFteg htiWgnihtemoSod tnetnoc
09:52:57 <copumpkin> deriving (RepublicanPolicies)
09:53:00 <jmcarthur> mm_freak: i am :)
09:53:02 <edwardk> benmachine: but should the reversal be for the flipped or the dual notion? =)
09:53:12 <benmachine> augh
09:53:13 <edwardk> copumpkin: ex falso quod libet
09:53:25 <jmcarthur> i like to make doSomethingWith functions simple
09:53:31 <edwardk> er quodlibet
09:53:32 <mm_freak> jmcarthur: then that's ok, but in general i have many uses for mixed notation =)
09:53:37 <copumpkin> @djinn Void -> a
09:53:37 <lambdabot> f = void
09:53:38 <aavogt> jmcarthur: you'd rather have nested do?
09:53:41 <copumpkin> zomg
09:53:44 <jmcarthur> no
09:54:03 <olsner> aavogt: od-notation? you know real coders use the srotarepo danom directly :P
09:54:12 <mm_freak> jmcarthur: especially in the list monad i often find uses for that
09:54:14 <jmcarthur> for that particular monad (IO), i'd rather stick with a single direction of effects throughout a function
09:54:19 <edwardk> olsner: i have an od macro in scheme for that very reason ;)
09:54:22 <jmcarthur> for other monads, i dont' mind mixing it
09:54:22 <copumpkin> ex falsis, quodlibet:
09:54:28 <copumpkin> @djinn Void -> Void -> Void -> a
09:54:28 <lambdabot> f = void
09:54:31 <mm_freak> even though most often i rather try to encode my computation in combinators
09:54:31 <copumpkin> :(
09:54:33 <jmcarthur> it's personal preference
09:54:47 <edwardk> copumpkin: well, its correct ;)
09:54:50 <copumpkin> :(
09:54:58 <mm_freak> so i found myself defining things like iterateM or takeWhileM
09:55:11 <mm_freak> iterateM is particularly useful =)
09:55:18 <aavogt> forever?
09:55:21 <jmcarthur> mm_freak: i thought that was defined somewhere already
09:55:30 <jmcarthur> maybe i'm thinking replicateM
09:55:38 <edwardk> @djinn a -> Not a -> b
09:55:39 <lambdabot> f a b = void (b a)
09:55:47 <mm_freak> no, replicateM is defined, but iterateM is not
09:56:02 <copumpkin> @djinn (b -> Void, Void) -> a
09:56:02 <lambdabot> f (_, a) = void a
09:56:03 <edwardk> ex contradictione quodlibet
09:56:08 <copumpkin> boo, it should use it
09:56:12 <mm_freak> iterateM :: Monad m => (a -> m a) -> a -> m [a]
09:56:24 <mm_freak> or sometimes with a count
09:56:25 <copumpkin> :t void
09:56:27 <lambdabot> Not in scope: `void'
09:56:31 <mm_freak> iterateCountM :: Monad m => Int -> (a -> m a) -> a -> m [a]
09:57:00 <jmcarthur> iterateM = replicateM ∞
09:57:45 <aavogt> @type replicateM
09:57:47 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
09:58:02 <benmachine> that's not the same thing
09:58:13 <aavogt> it could be if you use State
09:58:18 <mm_freak> replicateM n = iterateCountM n id
09:58:26 <mm_freak> ah, no
09:58:28 <mm_freak> replicateM n = iterateCountM n return
09:58:42 <benmachine> that doesn't work either
09:58:44 <mm_freak> no, not even
09:58:50 <benmachine> that just gives you return :P
09:58:53 <mm_freak> yeah, sorry…  completely wrong =)
09:58:53 <benmachine> or
09:58:54 <benmachine> erm
09:58:58 <benmachine> return . replicate I guess
09:58:59 <mm_freak> it doesn't compile
09:59:05 <mm_freak> type error =)
09:59:10 <aavogt> @type flip evalStateT ?state . replicateM ?n
09:59:11 <lambdabot> forall a (m :: * -> *) a1. (Monad m, ?state::a, ?n::Int) => StateT a m a1 -> m [a1]
09:59:24 <mm_freak> iterateCountM takes an 'a', whereas replicateM takes an 'm a'
09:59:28 <aavogt> @type StateT
09:59:30 <lambdabot> forall s (m :: * -> *) a. (s -> m (a, s)) -> StateT s m a
09:59:38 <mm_freak> but i'm sure you can write replicateM in terms of iterateCountM, at least intuitively
09:59:43 <aavogt> @type flip evalStateT ?state . replicateM ?n . lift
09:59:45 <lambdabot> forall a (m :: * -> *) a1. (Monad m, ?state::a, ?n::Int) => m a1 -> m [a1]
09:59:53 <benmachine> probably involves const
10:00:14 <copumpkin> omg aavogt
10:00:14 <aavogt> and then the appropriate wrapping of get and put
10:00:34 <aavogt> which part?
10:00:44 <copumpkin> nah, just omg
10:01:32 <aavogt> @type flip evalStateT ?state . replicateM ?n . (\f -> do a <- get; r <- f a; put r; return r) . lift
10:01:33 <lambdabot>     Couldn't match kind `(* -> *) -> * -> *' against `?? -> ? -> *'
10:01:33 <lambdabot>     When matching the kinds of `t :: (* -> *) -> * -> *' and
10:01:33 <lambdabot>                                `(->) :: ?? -> ? -> *'
10:02:02 <tensorpudding> that's a lovely error message there
10:02:35 <aavogt> @type get
10:02:36 <copumpkin> omg kind mismatch
10:02:37 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => m s
10:03:02 <portnov> @pl \x -> getName x == name
10:03:03 <lambdabot> (name ==) . getName
10:03:13 <olsner> copumpkin: kind mismatch, unkind error
10:03:21 <aavogt> @type flip evalStateT ?state . replicateM ?n . (\f -> do a <- get; r <- lift $ f a; put r; return r)
10:03:23 <lambdabot> forall a (m :: * -> *). (Monad m, ?n::Int, ?state::a) => (a -> m a) -> m [a]
10:03:24 <copumpkin> yep :(
10:05:26 <edwardk> @pl \x -> name == getName
10:05:26 <lambdabot> const (name == getName)
10:05:32 <edwardk> er
10:05:40 <edwardk> @pl \x -> name == getName x
10:05:40 <lambdabot> (name ==) . getName
10:05:52 <copumpkin> beautiful
10:05:55 <ddarius> :t getName
10:05:56 <lambdabot> Not in scope: `getName'
10:05:58 <edwardk> interesting, pl noticed that it could commute (==) ?
10:06:05 <ddarius> @hoogle getConstr
10:06:09 <lambdabot> No results found
10:06:18 <ddarius> edwardk: @pl is loaded with many false rewrite rules.
10:06:24 <ddarius> @pl (+ 3)
10:06:28 <lambdabot> (3 +)
10:06:32 <edwardk> ddarius: ack!
10:06:37 <llambda> \o/
10:06:39 <copumpkin> syn!
10:06:49 <copumpkin> (this exchange is already fucked)
10:07:20 <int-e> rst then
10:07:26 <edwardk> copumpkin: =)
10:08:10 <int-e> edwardk: but it didn't commute == at all.
10:08:11 <edwardk> you can send ack and syn in separate packets ;)
10:08:17 <copumpkin> yeah, I was wondering about that
10:08:50 <int-e> edwardk: oh. didn't look far enough back.
10:08:50 <edwardk> int-e: one of them got commuted, notice the one I @pl'd vs the original
10:08:50 <int-e> @pl flip (==)
10:08:50 <lambdabot> (==)
10:08:52 <copumpkin> ooh
10:08:53 <edwardk> *nods*
10:08:54 <copumpkin> hawt
10:09:27 <llambda> If I have a type Net = ReaderT Bot IO, and data Bot = Bot {some state here}, how would I do a forkIO on a function with the type Net () ?
10:10:09 * copumpkin should go rehearse his talk
10:10:15 <djahandarie> So I guess that'd be either a) change Net () back into IO () somehow, b) completely redo the program, or c) ???
10:10:26 <int-e> llambda: forkIO' act = get >>= lift . forkIO . runReaderT act  ?
10:10:49 <llambda> djahandarie, profit? :)
10:11:11 <dmead> profit!
10:11:18 <int-e> sorry. s/get/ask/
10:11:22 * llambda needs to read up on his arrows
10:12:00 <shepheb> no, fail to avoid success.
10:12:23 <int-e> failure to avoid success denied.
10:12:31 <llambda> int-e, what if I want to fork in the middle of one of the a -> Net () functions?
10:12:39 <llambda> That'd only fork at the point of runReaderT, right?
10:14:04 <int-e> llambda: no, it will do that - the point is that you can extract the context (using ask) and pass that to the internal action. and because the context is constant (unlike StateT) this will behave quite nicely. (doing the same with StateT will duplicate the state - not what you'd want, usually)
10:15:58 <int-e> @type \f-> ask >>= lift . runReaderT f
10:16:00 <lambdabot> forall a (m :: * -> *) b (t :: (* -> *) -> * -> *). (MonadReader a (t m), MonadTrans t, Monad m) => ReaderT a m b -> t m b
10:17:44 <llambda> What is t in that?
10:18:07 <int-e> t = ReaderT a  is what I had in mind
10:18:33 <llambda> ~.~ I am sorely confused.
10:18:37 <int-e> in which case this is the identity function on ReaderT a m b.
10:18:48 <jnss> hunny
10:21:02 <eevar> which gui library is least annoying? -- I want to display some simple graphs and tables on windows and linux
10:21:17 <ulfdoz> qt
10:21:24 <eevar> i've used swing a fair bit, but none of the c(++) ones
10:21:59 <ulfdoz> swing is quite expensive coding. Too much code for too little results. However, it at least works.
10:22:03 <ben> gtk
10:24:55 <ulfdoz> I find gtk from the user's perspective quite annoying. But that's only my opinion and should not start a gui-toolkit-war
10:25:16 <Zao> All GUI sucks.
10:25:55 <ben> gtk did not make me figure out widget positions/size in pixels, so I was instantly sold
10:26:11 <ulfdoz> however, emacs perfectly fits into gtk. ;)
10:26:11 <eevar> hmm.. qtHaskell is gpl, so that's out
10:27:06 <ulfdoz> pay money and buy commercial source code.
10:27:18 <Zao> ulfdoz: Qt is tri-licensed.
10:27:24 <Zao> ulfdoz: Commercial, LGPL and GPL.
10:27:30 <Zao> ulfdoz: The problem would be on qtHaskell's side.
10:27:41 <ulfdoz> Zao: I meant that side.
10:28:20 <ulfdoz> I have similar problems with java and usb. Using RXTX would be just too easy. ;)
10:28:24 * Zao holds back rant about people (mis)using GPL.
10:29:02 <Twey> You consider qtHaskell an inappropriate subject for the GPL?
10:29:53 <Zao> Twey: As it's essentially a library, yes.
10:30:04 <Zao> Twey: And because it's completely useless with two of the three licensing schemes.
10:30:15 <Twey> Zao: How so?
10:30:27 <Twey> And why do you believe that the GPL should not apply to libraries?
10:30:45 <Zao> Twey: The LGPL license is an excellent license for libraries.
10:30:55 <Zao> Twey: If you modify the library, you're obliged to send code upstream.
10:31:14 <Zao> If you don't, someone can drop in a pristine copy and all is fine.
10:31:20 <eevar> while if it's gpl, you just don't use the library
10:31:35 <mahogny> eevar, I seem unique in that I think swing is the best GUI. but then I have my tricks, helper classes and most layout managers are useless. but whatever you do, don't use a GUI editor :S
10:32:55 <eevar> using swing from haskell probably isn't the way to go, though?
10:33:02 <mahogny> no
10:33:25 <chrisdone> eevar: you could just use a web browser
10:34:10 <chrisdone> do you need a specific way of viewing the graphs that requires a standalone GUI?
10:34:13 <eevar> chrisdone, i do web stuff at my day job, so that's out of the question ;)
10:34:43 <yitz> eevar: (half joking) use hcurses
10:35:09 <mahogny> correct me if I'm wrong but Qt seems to be the only GUI really moving forward. GTKs main point for a long time was the license but now it's not so obvious
10:36:28 <yitz> mahogny: what do you mean by "moving forward"? GNOME is very popular, so GTK is widely used and being improved. you might not like it or its direction though.
10:36:59 <Dementati> Microsoft stuff is also moving forward.
10:37:25 <stevenmarky> I <3 Qt
10:37:36 <yitz> eevar: btw i agree with chrisdone for the task you are describing. sorry it's your day job tho. :)
10:37:52 <yitz> Dementati: so is cocoa
10:38:00 <Dementati> yitz: Definitely.
10:38:42 <yitz> that's what's attractive about the idea of wx, though living up to it is another thing.
10:39:10 <Alpounet> I wish qthaskell was a bit more popular and open and active
10:39:41 <mahogny> yitz, qt seems a bit more aggressive in improving stuff(?), in the main library, but I'm totally out of date here. certainly the users of the libraries are moving forward though
10:40:25 <yitz> could be
10:41:13 <Alpounet> Qt also has a lot of new stuffs in it
10:41:30 <Alpounet> and more supported platforms, afaik
10:41:41 <chrisdone> what's that haskell reddit for ideas?
10:41:49 <eevar> Alpounet, I'm guessing the lack of openness could be _one_ reason why it's not very active
10:42:06 <Alpounet> eevar, regarding qthaskell ? yeah, indeed
10:42:21 <Alpounet> just look at Qt too se how well it goes :)
10:42:32 <Alpounet> chrisdone, it's for motivated people missing project ideas
10:43:24 <Ke> ugly preprocessor language
10:43:31 <waterlaz> hi, could anyone help me with making a cabal package?
10:43:32 <Ke> gtk+!
10:43:47 <Alpounet> waterlaz, have you checked out mkcabal ?
10:44:07 <waterlaz> I curently build my files with including this line `pkg-config --libs xmms2-client`
10:44:56 <waterlaz> Alpounet, I'll try but I though it wasn't such an intelligent tool
10:45:21 <chrisdone> Alpounet: I mean what is the name of it? :p
10:46:00 <Alpounet> chrisdone, haskell_proposals
10:51:44 <chrisdone> Alpounet: thanks =)
10:54:42 <zygoloid> how does qthaskell work? from C++, a fair amount of Qt stuff is done by deriving from Qt classes rather than signals/slots. how does qthaskell handle that?
10:56:32 <waterlaz> Alpounet, mkcabal does only the easy stuff =)
10:56:46 <waterlaz> i'm having troubles with include paths etc
10:57:31 <yitz> waterlaz: someone posted this on reddit, don't know if it helps: http://progandprog.blogspot.com/2010/03/projecttemplate-template-based-tool-for.html
10:57:49 <waterlaz> thanks
10:58:33 <yitz> also, there's this comment in the reddit: "The successor to mkcabal was recently added into the cabal-install tool (I think). Brent Yorgey and someone whose name I can't recall were working on it at the Edinburgh Hackathon."
11:00:41 <waterlaz> is it okay if I would just add "/usr/lib/xmms2/" as an include dir?
11:01:12 <waterlaz> the proper way would be to use pkg-cfg I guess but cabal doesn't seem to go this way
11:01:47 <zygoloid> anyone got implementation experience with SSA forms (or equivalent)? my implementation feels a but clunky and imperative :(
11:03:09 <codefest_prashan> We invite you to be a  part of the Largest Online Coding festival in the Indian Subcontinent.[ http://itbhu.ac.in/codefest ]     Sit right in front of your systems and take part in challenging and mind boggling competitions on application development, algorithm design etc. PS:Attractive Prizes.Adobe & BT certificates.
11:03:26 <mathijs> Hi all, anyone around with some knowledge of file descriptors, handles and ptys? I came across this blogpost from Bryan O'Sullivan which I wanted to try out. it compiles, even runs, but throws an exception. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23343
11:07:48 <yitz> waterlaz: what are you using in /usr/lib/xmms2/
11:09:21 <yitz> and when and how do you use it?
11:10:10 <gwern> out of curiosity, does anyone here use as their main computer a computer with less than 512MB of RAM?
11:10:26 <yitz> @google ssa forms
11:10:28 <lambdabot> Plugin `search' failed with: Lib.URL.isTextHTML: getHeader failed
11:10:32 <medfly> I have 512mb of RAM.
11:10:34 <yitz> @google ssa forms
11:10:35 <lambdabot> Plugin `search' failed with: Lib.URL.isTextHTML: getHeader failed
11:11:07 <yitz> well, anyway, ssa forms googles to the U.S. Social Security Administration's forms page.
11:11:20 <yitz> gwern: i do
11:11:24 <gwern> !
11:11:26 <gwern> how much?
11:11:45 <yitz> 256
11:12:02 <gwern> wow. yitz is kicking it like it's 1996
11:12:11 <c_wraith> yitz: you don't compile much haskell code on that computer, do you?
11:12:59 <yitz> i was using debian testing until a few weeks ago. the upgrades to squeeze killed my machine, had to wipe and install etch from scratch. now it's fine again.
11:13:06 <yitz> c_wraith: sure do. no prob.
11:13:20 * gwern flips yitz a nickel. go get yourself a real computer kid :)
11:13:33 <yitz> i use xmonad, it's real snappy.
11:13:33 <c_wraith> Really?  If I compile anything that's more than a toy, ld wants at least 700 megs of ram.
11:13:38 * tommd thinks yitz is talking about his cell phone
11:13:43 <yitz> hehe
11:13:51 <c_wraith> and ld swapping is *bad* for compiler times
11:13:54 <gwern> tommd: maybe yitz is japanese
11:14:06 <yitz> my palm pilot has about 32, if that's what you're referring to tommd.
11:14:25 <c_wraith> err.  compile* times
11:14:31 <yitz> my macbook has a bit more than that tho. :)
11:14:32 <gwern> and so does everything on a handheld
11:15:29 <portnov> @hoogle a -> a
11:15:29 <lambdabot> Prelude id :: a -> a
11:15:29 <lambdabot> Data.Function id :: a -> a
11:15:30 <lambdabot> Control.Exception mapException :: (Exception e1, Exception e2) => (e1 -> e2) -> a -> a
11:16:04 <deadguys> anyone know who admins hackage trac?  I got snagged by a trac bug, now I'm locked out
11:22:46 <edwardk> zygoloid: yes.
11:23:06 <yitz> gwern: 異伊江
11:23:32 <zygoloid> edwardk: how did you represent it? got any tips?
11:25:04 <zygoloid> at the moment i've got indices for the statements/variables, a map from indices to statements to define what they are, and basic blocks represented as a sequence of indices
11:26:27 <zygoloid> i'm wondering whether i might be better off with a CPS-style representation
11:27:55 <edwardk> zygoloid: last time i used it i used a funny hoas based representation to avoid naming indices, etc. personally i prefer ANF it feels more natural when talking about functional code
11:28:08 <dons> deadguys: igloo does
11:31:48 <mux> Foldable is great; I could have avoided writing quite a few functions if I had defined the instance first, but now I worry that the versions based on Foldable would be less efficient
11:31:49 <zygoloid> edwardk: well, i'm representing python code... how does ANF handle control constructs? recursion?
11:33:09 <edwardk> one sec, supplying references
11:33:26 <dons> parsec question, if someone would like to help out a newbie, http://stackoverflow.com/questions/2403873/parsec-backtracking-not-working
11:34:10 <edwardk> zygoloid: http://en.wikipedia.org/wiki/Administrative_normal_form http://citeseer.ist.psu.edu/flanagan-essence.html http://lambda-the-ultimate.org/node/3467
11:34:47 <edwardk> zygoloid: anf tends to feel more 'haskelly' given that you compose with lambdas and explicit continuations
11:37:18 <zygoloid> edwardk: thanks muchly for the references
11:37:22 * zygoloid puts on reading glasses
11:38:55 <edwardk> zygoloid: one more for the pile: http://lambda-the-ultimate.org/node/2406
11:39:30 <sinelaw> hi
11:41:35 <medfly> hey
11:44:59 <Taejo> is it possible to compile a Haskell module only up to type-checking, warnings, etc. but not producing any output?
11:45:41 <gabl> This code should update dzen every second, but takes much longer and I can't see any reason: http://paste2.org/p/707607
11:47:19 <medfly> >> ?
11:49:03 <sinelaw> Taejo, you can stop compilation after various stages, see the flags: -E, -C, -S, -c
11:51:37 <Taejo> sinelaw: I saw those, but it seems like all of them generate some output
11:54:10 <jmcarthur> maybe you could find a way to have to output go to stdout and then you can pipe that to /dev/null?
11:54:18 <jmcarthur> *have the output
11:55:28 <tomh-> oh oh 666 people idling here -.-
11:55:38 <c_wraith> quick, kick someone!
11:55:43 <c_wraith> oh, that works too, I guess
11:55:48 <tomh-> yeah that works
11:56:07 <pokoko222> anyone has the solution number for euler 54? i get 383, it is not correct
11:56:21 <c_wraith> @users
11:56:22 <lambdabot> Unknown command, try @list
11:56:29 <c_wraith> oh, right, that was removed too
12:00:05 <aavogt> ooh, ghci segfaulted
12:00:23 <chrisdone> aavogt: did you unsafeCallCthulu?
12:00:46 <elly> unsafeCallBetweenTheStarsToTheElderGodsThatLieSleepingThere?
12:00:53 <elly> (it'll be in Haskell', people)
12:01:14 <chrisdone> :D
12:01:47 <aavogt> chrisdone: no, I loaded a different file, and a couple seconds later it died
12:02:46 <chrisdone> report that!
12:05:42 <chrisdone> @hoogle parens
12:05:43 <lambdabot> Text.Read parens :: ReadPrec a -> ReadPrec a
12:05:43 <lambdabot> Text.Parsec.Token parens :: GenTokenParser s u m -> ParsecT s u m a -> ParsecT s u m a
12:05:43 <lambdabot> Text.PrettyPrint.HughesPJ parens :: Doc -> Doc
12:10:32 <pokoko222> anyone knows what TD means in first line of player one vs player two? http://projecteuler.net/index.php?section=problems&id=54
12:10:41 <pokoko222> D is for diamond, but T?
12:11:23 <Raynes> I was about to say tuberculosis, but it's a D and not a B. :(
12:11:31 <mauke> turducken
12:11:52 <Raynes> It could be TurD. You never know.
12:12:15 <forrest> touchdown?
12:12:28 <Axman6> Tower Defence
12:12:42 <Raynes> There ya go!
12:12:55 <pokoko222> Touch Down ok
12:13:19 <pokoko222> nah seriosly people help this poor sould that writes 400 code in c++ today for euler 54
12:13:29 <MaciejP> Is there a partition function :: (a -> a -> Bool) -> [a] -> [[a]] somewhere?
12:13:36 <pokoko222> ok got it, it means 10 :O
12:13:48 <Raynes> 400 lines of C++ code for a Euler challenge?
12:14:01 <mauke> :t partition
12:14:02 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
12:14:05 <Raynes> You see, this is why I don't do Euler challenges (or C++ for that matter).
12:14:07 <mauke> MaciejP: why [[a]]?
12:14:21 <danderson> when I execute an STM action with atomically, will the action automatically retry if it finds on commit that another thread messed up the state it was touching, or will it abort with an exception?
12:14:45 <mauke> danderson: it will retry
12:14:57 <danderson> intuition says retry is the saner option, just want to make sure before I start building my huge TChan network
12:15:00 <danderson> cheers.
12:15:03 <MaciejP> mauke: I want to split a equivalence relation to it's classes.
12:15:20 <mauke> :t groupBy
12:15:21 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
12:15:35 <Jafet> @hoogle (a -> a -> Bool) -> [a] -> [[a]]
12:15:36 <lambdabot> Data.List groupBy :: (a -> a -> Bool) -> [a] -> [[a]]
12:15:36 <lambdabot> Data.List nubBy :: (a -> a -> Bool) -> [a] -> [a]
12:15:36 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
12:15:50 <pokoko222> yeah i wrote my own sort, compare array, and other help functions
12:15:55 <pokoko222> in haskell u have it all
12:16:40 <MaciejP> mauke: No, groupBy does something else.
12:16:43 <mauke> pokoko222: "Royal Flush: Ten, Jack, Queen, King, Ace, in same suit."
12:17:07 <pokoko222> ah? mauke ?
12:17:18 <jmcarthur> you could sortBy then groupBy
12:17:19 <mauke> pokoko222: you wanted to know about the T, no?
12:17:43 <pokoko222> yeah i got answer, it is 10 i wrote above but hey thanks for the trouble ;)
12:17:46 <jd10> say i have a tuple of integeres, what would be the nicest way of formatting it as "1,2,3"
12:17:56 <edwardk> > groupBy (\x y -> mod x 4 == mod y 4) [0..20]
12:17:57 <lambdabot>   [[0],[1],[2],[3],[4],[5],[6],[7],[8],[9],[10],[11],[12],[13],[14],[15],[16]...
12:18:08 <tensorpudding> that doesn't seem to work
12:18:09 <edwardk> groupBy doesn't work
12:18:12 <mauke> oh, whoops
12:18:28 <jd10> i'm getting a bit bored of writing 'show' all over the place
12:18:52 <roconnor> edwardk: groupBy doesn't do what you think it does, it does something retarded instead.
12:19:15 <llambda> \o/
12:19:18 <jmcarthur> > let f op x y = mod x 4 `op` mod y 4 in groupBy (f (==)) . sortBy (f compare) $ [0..20]
12:19:19 <edwardk> roconnor: i know, i was following up to MaciejP's comment that it does something different in response to mauke
12:19:20 <lambdabot>   [[0,4,8,12,16,20],[1,5,9,13,17],[2,6,10,14,18],[3,7,11,15,19]]
12:19:22 <Jordi_> groupBy groups adjacent equal terms
12:19:32 <roconnor> ah, sorry, I just joined in
12:19:47 <edwardk> roconnor: no worries =)
12:19:50 <Jordi_> > foldl1 (*) [1..5]
12:19:50 <jmcarthur> (==) `on` ...   and   comparing   would have been nicer than what i just did
12:19:51 <lambdabot>   120
12:20:01 <Jordi_> lambdabot ownz
12:20:35 <jmcarthur> > groupBy ((==) `on` (`mod` 4)) . sortBy (comparing (`mod` 4)) $ [0..20]
12:20:35 <MaciejP> jmcarthur: Thanks!
12:20:36 <lambdabot>   [[0,4,8,12,16,20],[1,5,9,13,17],[2,6,10,14,18],[3,7,11,15,19]]
12:20:57 <roconnor> > (\ (x,y,z) -> intercalate ',' (map show [x,y,z])) (1,2,3)
12:20:58 <lambdabot>   Couldn't match expected type `[a]'
12:20:58 <lambdabot>         against inferred type `GHC.Types...
12:21:10 <blackh> aavogt: I'm making progress with the ticket 89 / ghc 6.12 problem
12:21:12 <roconnor> @type intercalate
12:21:13 <lambdabot> forall a. [a] -> [[a]] -> [a]
12:21:22 <roconnor> > (\ (x,y,z) -> intercalate "," (map show [x,y,z])) (1,2,3)
12:21:23 <lambdabot>   "1,2,3"
12:21:32 <roconnor> jd10: ^^
12:21:37 <jd10> thx :]
12:21:42 <jd10> luv it
12:21:44 <edwardk> MaciejP: note that that version requires that each equivalence class have a canonical (==) member and that the classes have an ordering.
12:22:39 <jmcarthur> nubBy almost does the right thing, except it trashes all but one element in each equivalence class
12:23:07 <jmcarthur> @src nubBy
12:23:07 <lambdabot> nubBy eq []             =  []
12:23:07 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
12:23:43 <MaciejP> edwardk: Yes, they have
12:23:45 <jmcarthur> > nubBy ((==) `on` (`mod` 4)) [0..20]
12:23:46 <lambdabot>   [0,1,2,3]
12:24:59 <edwardk> > let groupBy' cmp (a:as) = let (ms,ns) = partition (cmp a) as in ms : groupBy' cmp ns; groupBy' cmp [] = [] in groupBy' ((==) `on` (`mod` 4)) [1..20]
12:25:00 <lambdabot>   [[5,9,13,17],[6,10,14,18],[7,11,15,19],[8,12,16,20]]
12:25:41 <edwardk> no ordering or exemplar required
12:25:57 <edwardk> might get a bit slow as the list gets bigger though ;)
12:26:42 <jmcarthur> edwardk: what happened to [0..4]?
12:26:50 <jmcarthur> err, 1..4
12:27:03 <edwardk> jmcarthur: I implemented it wrong, thats what ;) =)
12:27:20 <edwardk> > let groupBy' cmp (a:as) = let (ms,ns) = partition (cmp a) as in (a:ms) : groupBy' cmp ns; groupBy' cmp [] = [] in groupBy' ((==) `on` (`mod` 4)) [1..20]
12:27:22 <lambdabot>   [[1,5,9,13,17],[2,6,10,14,18],[3,7,11,15,19],[4,8,12,16,20]]
12:29:05 <MaciejP> Such a function should go to Data.List IMHO
12:29:36 <jmcarthur> i think it's what partition should have been, myself
12:29:45 <jmcarthur> :t partition
12:29:46 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
12:29:54 <jmcarthur> instead of that
12:34:01 <dmead> @hoogle splitBy
12:34:02 <lambdabot> No results found
12:34:03 <aavogt> blackh: so actually getting a proper package id?
12:34:08 <dmead> ?src splitBy
12:34:08 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
12:34:14 <aavogt> @hackage split
12:34:14 <lambdabot> http://hackage.haskell.org/package/split
12:34:16 <dmead> tks
12:34:47 <edwardk> hrmm been toying with erlang (mostly for some server side things). just realized i can do something i'm used to doing in old game engines with it as well. traditionally we used to use a huge per-frame heap that we'd just throw away after the frame for most of the detritus we accumulated.
12:34:50 <blackh> aavogt: Yes, that's right - I need to tidy it up a bit, but what I've got works.
12:35:18 <aavogt> nice
12:35:24 <edwardk> in erlang, i can just make the frame into a process, which gets its own heap, build up a crud ton of temporary crap in that, and as long as the heap is started large enough it will never gc.
12:35:27 <edwardk> poor man's regions
12:35:28 <aavogt> how about the cabal-install problems?
12:36:00 <jlouis> edwardk: heh, nice idea
12:36:22 <jmcarthur> huh that's cool
12:36:29 * hackagebot AC-Colour 1.1.3 - Efficient RGB colour types.  http://hackage.haskell.org/package/AC-Colour-1.1.3 (AndrewCoppin)
12:37:10 <edwardk> jlouis: nicely that is very much the way processes work in my toy compiler, so i hold out hope for using kata for something interactive yet ;)
12:38:28 <ivanm> sinelaw: see gloss on hackage ;-)
12:40:43 <arcatan> > maximum [1..1000000]
12:40:45 <lambdabot>   * Exception: stack overflow
12:40:50 <arcatan> why does that happen?
12:41:06 <roconnor> @src maximum
12:41:07 <lambdabot> maximum [] = undefined
12:41:07 <lambdabot> maximum xs = foldl1 max xs
12:41:24 <roconnor> > foldl1 max [1..1000000]
12:41:26 <lambdabot>   * Exception: stack overflow
12:41:29 <roconnor> > foldl1' max [1..1000000]
12:41:30 <lambdabot>   1000000
12:41:41 <mauke> insufficient strictness
12:41:44 <cebewee> @src foldl
12:41:44 <lambdabot> foldl f z []     = z
12:41:44 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
12:41:57 <roconnor> arcatan: because you haven't turned on ghc optimizations
12:42:12 <arcatan> how do i turn them on?
12:42:21 <roconnor> arcatan: what is your context?
12:43:24 <arcatan> solving a project euler problem, i want to find the maximum of a list of ints
12:44:33 <arcatan> well, foldl1' max did the trick
12:44:52 <mauke> ghc -O2
12:45:17 <roconnor> arcatan: are you using ghci?
12:45:24 <roconnor> what mauke said
12:45:36 <roconnor> you need to compile a module with -O2 and load it into ghci
12:45:48 <roconnor> or just run a compiled executable
12:45:57 * roconnor wonders if -O2 will actually optimize this.
12:46:24 <Alpounet> anyway, foldl1' is better for that context
12:46:54 <chrissbx> How do you implement a show for nested / possibly cyclic data structures that stops at a certain depth?
12:47:18 <tensorpudding> how do you know the data structure is bounded?
12:47:25 <chrissbx> Threading through a depth counter would be easy except if I have to contain stuff that has it's own show already (and can't contain cycles).
12:47:30 <arcatan> roconnor: seems it actually does optimize that
12:47:34 <chrisdone> show foo = myshow foo 0 where myshow value level = .. ?
12:47:41 <tensorpudding> or are you trying to implement show which descends the structure only to a certain depth?
12:47:47 <c_wraith> tensorpudding: he means show has bounded depth, not the structure
12:47:53 <chrissbx> tensorpudding: that latter.
12:48:22 <chrissbx> so just writing a show with a depth counter would be the way to go, but I'd like to reuse existing show code of non-nested classes.
12:48:27 <jmcarthur> Alpounet: i wish i could do geometry shaders :(
12:48:37 <tensorpudding> you could do show (Foo bar baz) = show' (Foo bar baz) 10, where show' recurses on itself, decrementing by 1 each time, and stops at 0
12:48:40 <chrissbx> well I guess I just have to cover all these cases manually.
12:48:44 <Alpounet> jmcarthur, heh, can't you ?
12:48:57 <jmcarthur> Alpounet: mesa only supports GLSL 1.2
12:49:23 <Alpounet> oh
12:49:25 <jmcarthur> so i can only do vertex and fragment shaders
12:49:50 <Alpounet> jmcarthur, you still can think about the design of your library though
12:50:08 <jmcarthur> i'd rather be able to code it. i want to actually use it
12:50:30 <Alpounet> write the code supporting vertex & fragment shaders for the moment then... ?
12:50:36 <chrisdone> I don't suppose you can NoImplicitPrelude to hide the Show class and redefine Show so that show is really == show' 0, can you?
12:50:37 <jmcarthur> yeah..
12:50:49 <freedrull> hi im having trouble with an infinite type error, if anyone could help me that would be great: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23347#a23347
12:51:00 <Alpounet> but I understand your disappointment though
12:51:27 <jmcarthur> i've been wanting to get more into graphics programming. maybe i could get a machine with a better graphics card and run windows on it, or os x if it's a mac
12:51:48 <jmcarthur> dunno what versions of opengl are supported on each
12:52:34 <jmcarthur> hmm, apparently nvidia has an opengl driver for linux that supports opengl 3
12:52:35 <edwardk> jmcarthur: just invested a small fortune so i could do directcompute shaders =/
12:52:59 <erikc> jmcarthur: they do, works fine for me
12:53:07 <jmcarthur> erikc: ooh good to hear
12:53:21 <erikc> (9800 gtx)
12:54:04 <ben> freedrull: "l" is a Tree a, you are trying to use it as first argument to a Node, which wants an a instead
12:54:05 <c_wraith> freedrull: the problem is the use of l in the expression "Node l (Leaf)(Leaf)"
12:54:25 <jmcarthur> lol, my crappy ION 330 supports it
12:54:39 <erikc> and ATI is waking up to linux and opening up a lot of their gpu internals, so hopefully that side of the fence will get better soon
12:54:43 <jmcarthur> i guess i'll be doing some programming on it
12:55:13 <edwardk> erikc: hopefully. ati has lagged pretty bad in its support for opengl extensions in the past
12:55:56 <Beelsebob> gwern: you about?
12:55:59 <erikc> yea, unfortunately when it comes to 3d platforms are totally at the mercy of ATI and Nvidia for driver support
12:58:08 <edwardk> waiting for my shiny 5970 to arrive to i can get back to hacking away on trivial irradiance/beer's law effects that are better approximated using er.. less computationally intensive means than i am brining to bear.
12:58:19 <edwardk> er bringing
12:59:09 <freedrull> c_wraith ben: but i don't get the same error on this 'insert' function, which has nearly the same arguements and type signature: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23347#a23348
12:59:25 <erikc> edwardk: lol
12:59:52 <c_wraith> freedrull: that's because you're using x as the first argument, which has the correct type.  the problem is you're using a Tree a where you mean to use an a in remove
13:00:19 <Beelsebob> freedrull: note the first argument to Node in your return type
13:00:22 <Beelsebob> it's a Tree
13:00:24 <Beelsebob> not an element
13:00:45 <Beelsebob> probably what you meant was remove (Node x l Leaf) | a == x = l
13:02:48 <freedrull> so (Leaf) and Leaf are different?
13:03:03 <erikc> edwardk: that card is a beast
13:03:04 <edwardk> freedrull: no
13:03:06 <freedrull> i understand why Node l (Leaf)(Leaf) is different from l
13:03:18 <freedrull> oh ok
13:03:27 <freedrull> i understand now
13:03:39 <edwardk> Node l Leaf Leaf and Node l (Leaf) (Leaf) are the same thing. but what are the types of the slots for Node?
13:04:07 <edwardk> and what is the type of l
13:04:34 <edwardk> erikc: yeah, i figure i'll be able to run my little simulations on that, and if not... i can add another
13:04:57 <freedrull> l is a Tree, so I was making a Node (Tree a) (Leaf)(Leaf), when I wanted just a Tree a
13:05:09 <edwardk> erikc: and my worse case scenario is that i get bored, and have a gaming rig that is good for another 4 years ;)
13:05:18 <erikc> haha
13:05:33 <erikc> is there a haskell binding to directcompute, or you using c/c++?
13:05:43 <edwardk> erikc: alas, c++.
13:06:09 <Trafalgard> so I'm getting a divide by zero exception. And :history's first entry is... mStar = mass. I don't see any integer divisions leading to mass that could be dividing by zero, and as far as I can tell the only thing unknown that could be zero is the reactions variable, but ... when it's calculated, it's a double, which then gets converted to an integer. No divisions would be done on it before it's converted to an integer...
13:06:15 <Trafalgard> er
13:06:18 <Trafalgard> after it's converted, I mean
13:06:31 <edwardk> erikc: though i'm thinking about bringing the erlang over from the server to the client if i actually do something serious with this to avoid reimplementing some functionality in two languages.
13:06:34 <Trafalgard> so I don't get why it's doing this
13:07:08 <Trafalgard> (It shouldn't BE zero in the first place >_<)
13:07:36 <Trafalgard> apparently doing $! before rounding it doesn't help
13:07:37 <edwardk> erikc: at this point this is mostly just an exercise for me to explore erlang in some ways i hadn't previously, and to explore the new functionality in directx 11 to keep myself from becoming a dinosaur. no concrete goal yet
13:11:06 <Trafalgard> Also, why is it that GHCI, when debugging, is unable to see any local variables in a function?
13:11:15 <Trafalgard> they're always out of scope >_<
13:11:46 <Trafalgard> Are there any debuggers for haskell that can actually see local variables?
13:12:26 <chrisdone> I never used a haskell debugger. I should look into that
13:12:48 <Trafalgard> at best it tells you where an exception didn't really come from
13:14:48 <chrisdone> for your problem I would typically isolate the code that uses division and the code providing it with inputs, and analyse them on an individual basis
13:15:23 <chrisdone> though I am more interested in defining quickcheck properties at the moment
13:15:56 <ickan> the haddock 2.6.0 package wont build via cabal-install due to a missing package dependency identified as "alex" in the error output, So I tried using cabal-install to install the alex package, and it sucsessfully finished installing alex2.3.2.  However the haddock package still raises the same exception? Anyone have any insight to what the problem might be here?
13:16:15 <chrisdone> unless you're doing very difficult systems programming, using a debugger, I think, is a sign that you don't really understand your code
13:16:38 <mornfall> ickan: You need to have that alex on your PATH.
13:17:28 <benmachine> chrisdone: what is the quote, if you write your code as cleverly as you can you are by definition not clever to debug it?
13:17:32 <benmachine> *enough
13:18:15 <benmachine> having bugs is a sign that you don't really understand your code
13:18:20 <benmachine> unless you put them in there on purpose
13:18:23 <Trafalgard> haha.
13:18:48 <Trafalgard> If you don't test it, it won't work. It's impossible to write 100% perfect code.
13:18:52 <Kagami`> @pl \y -> x `mod` y == 0
13:18:52 <lambdabot> (0 ==) . (x `mod`)
13:19:37 <benmachine> Trafalgard: it's not, it's just (pretty much) impossible to know when you have done so
13:20:15 <freedrull> i think using a *compiler* is a sign you don't really understand your code :p
13:20:30 <benmachine> what no that doesn't make sense at all
13:20:40 <benmachine> I don't understand assembly
13:20:43 <benmachine> but I don't want to or need to
13:21:00 <Trafalgard> I think this stack trace is a sign that GHCI doesn't understand my code.
13:21:17 <benmachine> itc code is misunderstood
13:21:20 <gwern> oh noes, I missed Beelsebob
13:21:23 <Trafalgard> because there are no integer divisions from this line
13:21:32 <Trafalgard> which could divide by zero
13:21:40 <Trafalgard> they're all on non-zero constants
13:21:41 <gwern> whatever could he've to do wi'me?
13:21:47 <chrisdone> Trafalgard: do you have to test that map (+1) [1..5] == [2,3,4,5,6]?
13:21:50 <freedrull> benmachine: just wanted to make a joke ^_^
13:22:21 <gwern> @hoogle system
13:22:21 <lambdabot> No results found
13:22:36 <benmachine> freedrull: oh, then I apologise for my pedantry :P
13:22:39 <chrisdone> gwern: System.Process has a system command iirc
13:22:50 <Trafalgard> The only place that divides by a non-constant that could possibly be zero has nothing to do with this line that GHCI claims the exception came from
13:22:54 <gwern> hm, but maybe it was System.Cmd
13:22:57 <gwern> or whatever
13:23:19 <chrisdone> http://www.haskell.org/ghc/docs/latest/html/libraries/process-1.0.1.2/System-Process.html#v%3Asystem
13:23:27 <gwern> fine fine
13:23:28 <chrisdone> http://www.haskell.org/ghc/docs/latest/html/libraries/process-1.0.1.2/System-Cmd.html#v%3Asystem
13:23:28 <aavogt> well ghci claims the exception comes from where it is forced, Trafalgard
13:23:38 <aavogt> at least initially
13:23:41 <chrisdone> I think one exports the latter
13:24:12 <Trafalgard> I did :set -fbreak-on-exceptions, :trace main, it Stopped at <exception thrown> did not say where, I did :history to see the stack trace
13:24:47 <chrisdone> Trafalgard: let's see your code
13:24:50 <Trafalgard> the exception itself had no information about where it originated
13:25:26 <Trafalgard> it's rather long
13:25:43 <chrisdone> >1000 lines?
13:26:00 <Trafalgard> not quite that long
13:26:48 <tibbe> dons: you there?
13:26:55 <dons> yo
13:27:16 <dons> you got a 10 minute window. go go go
13:27:20 * gwern wishes git had darcs-send
13:28:24 <chrisdone> Trafalgard: http://hpaste.org/
13:28:35 <Trafalgard> already pasting it in
13:29:14 <tibbe> dons: sent you a private msg in case you didn't see :)
13:29:25 <gwern> goodness, timber has a lot of haskell98-isms
13:29:34 <damd> what is the for loop syntax in haskell
13:29:45 <gwern> [a, b, c]
13:30:03 <tibbe> damd: there's no syntax for for loops per se, what do you want to do?
13:30:50 <c_wraith> typically loops are written as map or fold.  Sometimes other combinators, rarely even explicit recursion
13:31:00 <dons> gwern: a lot of the code is circa 200
13:31:01 <dons> 0
13:31:10 <gwern> didn't know timber was that old
13:31:42 <dons> yeah, OGI / DARPA project nearly a decade ago, iirc
13:31:52 <dons> real time control of flying vehicles, or some such
13:31:55 <damd> i made a static variable but i can't change it, how do i change it
13:32:01 <Trafalgard> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23352#a23352
13:32:03 * gwern notes another example of bad follow through. a perpetual problem
13:32:12 <c_wraith> damd: you don't.
13:32:24 <Trafalgard> it claims the problem is on what's line 166 there or so
13:32:26 <c_wraith> damd: back up a step and tell us what you're actually trying to do
13:32:35 <dons> gwern: "Andrew P. Black, Magnus Carlsson, Mark P. Jones, Dick Kieburtz, and Johan Nordlander, Timber: a Programming Language for Real-Time Embedded Systems. Technical report CSE-02-002, Oregon Health & Science University, 2002."
13:32:40 <c_wraith> damd: (rather than how you're trying to do it)
13:32:52 <damd> c_wraith: i'm trying to change a static variable
13:33:08 <Trafalgard> the only place I saw that divided by a non-constant that COULD be zero was line 135? 136? These line numbers don't line up with the actual lines.
13:33:16 <gwern> dons: only a year or two off then
13:33:18 <Trafalgard> the lifespan = line
13:33:26 <benmachine> Trafalgard: use Debug.Trace?
13:33:27 <dons> gwern: well, the first paper in '99
13:33:31 <c_wraith> damd: back up a step, and tell me what you're trying to do, not how you're trying to do it.  *why* do you want to "change a static variable"?
13:33:40 <damd> c_wraith: so i can use it in a for loop
13:33:50 <dons> gwern: a bunch of ex-timberites at galois now worked on it
13:34:02 <benmachine> damd: usually there are other ways of doing that
13:34:05 <c_wraith> damd: higher-level, please.  What is your goal?  What operation are you trying to perform?  Is it a map?  Is it a fold?
13:34:10 <benmachine> and by usually I mean invariably
13:34:14 * gwern nods. not really relevant to my de-haskell98'ing, but vaguely of interest
13:34:23 <Trafalgard> also, normally this would recurse, but I commented that out temporarily for testing purposes - it doesn't throw the exception until it recurses
13:34:30 <Trafalgard> line ~130
13:34:31 <dons> gwern: you submitting to the maintainers?
13:34:34 <dons> its an active project now.
13:34:42 <dons> johan nordlander's very active on it.
13:34:51 <gwern> dons: it would hardly suit my arguments to keep the module tweaks private
13:34:53 <dv-> damd, try http://hackage.haskell.org/package/io-storage
13:35:00 <CalJohn> dons: c_wraith is saying that you are coming at this from the wrong angle.  essentially, there aren't variable in haskell, and there aren't for loops either :)
13:35:02 <dons> gwern: just checking that you're working from the latest code base
13:35:10 <dons> CalJohn: :)
13:35:16 <dons> thats good advice.
13:35:18 <c_wraith> yay for tab-completion!
13:35:22 <CalJohn> whoops
13:35:23 <jmcarthur> ah
13:35:33 <jmcarthur> wrong channel
13:35:33 * dons notes down to use less loops, more combinators.
13:35:41 <damd> dv-: please stop trolling
13:35:45 <CalJohn> dons: i hope you take the time to reflect upon my deep and profound advice :)
13:36:03 <dons> gwern: just to double check, you're working from http://code.haskell.org/timber ?
13:36:05 <jmcarthur> trolling?
13:36:11 <dv-> damd, ok?
13:36:20 <damd> dv-: can you help me with my for loop
13:36:21 <c_wraith> damd: haskell doesn't have for loops.  It solves those kinds of problems in different ways.  In order to tell you what way is best, we need to know what the actual problem is.
13:36:31 <jmcarthur> damd: it sounds more like you are the one trolling
13:36:32 <benmachine> it's not good form to accuse people of trolling when you are asking for help, I think
13:36:36 <dons> :t forM_
13:36:37 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
13:36:39 <dv-> damd, sure
13:36:41 <gwern> dons: yes
13:36:41 <damd> thank you dons
13:36:45 <dons> gwern: great!
13:37:03 <dv-> damd, forM_ [1..n] $ \n -> do (something with n)
13:37:04 <damd> why is this called forM_ in haskell not just for
13:37:09 <dons> :t mapM_
13:37:10 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
13:37:15 <dons> because of map/mapM_
13:37:15 <c_wraith> damd: because it doesn't do what you think it does.
13:37:18 <jmcarthur> damd: because it's not really a for loop as you expect it to be
13:37:21 * gwern moves on to the next project on the list: yhc
13:37:32 <pikhq> damd: There are no for loops. They are meaningless.
13:37:32 <dons> it has a reasonable type for a for loop though
13:37:32 <benmachine> the M stands for monad
13:37:39 <benmachine> the _ stands for throw away the result
13:37:42 <dons> iterate, running an effect, return ()
13:37:46 <jmcarthur> a close approximation, sure
13:38:04 <benmachine> :t flip map
13:38:05 <lambdabot> forall a b. [a] -> (a -> b) -> [b]
13:38:07 <dons> M_ are funky haskell idioms. somewhat odd that we do that.
13:38:14 <benmachine> ^ some people might call that for
13:38:16 <mornfall> Let's say that a for loop makes no sense in a world free of side effects. Thence, M as in Monad.
13:38:17 <dons> there's no 'for' for example for = flip map
13:38:19 <damd> is forM_ a monad
13:38:27 <gwern> wow. packedstring
13:38:28 <jmcarthur> it's because we don't have the genericity to make map and mapM the same
13:38:32 <gwern> haven't seen that since template-haskell
13:38:36 <benmachine> forM_ is a function that deals with monads
13:38:40 <jmcarthur> at least not without being overly complex
13:38:49 <pikhq> No, forM_ is a function that deals with monads.
13:38:49 <dons> gwern: packedstring is old school. ask bos :)
13:38:52 <Trafalgard> Hmm, debug.trace looks useful
13:38:52 <benmachine> jmcarthur: would we even want them the same? that'd be weird
13:39:03 <jmcarthur> benmachine: i don't think it would be that weird
13:39:03 <pikhq> (And courtesy of the function monad, it is a value *in* a monad)
13:39:06 <gwern> @hoogle stderr
13:39:06 <lambdabot> System.IO stderr :: Handle
13:39:07 <damd> can i make my own monad to use for loops?
13:39:16 <pikhq> damd: You don't want that.
13:39:17 <mornfall> jmcarthur, well, mapM ~ sequence . map, no?
13:39:23 <jmcarthur> benmachine: the weird thing is that the only way i have thought of to do it would require wrapping your functions in Kleisli
13:39:24 <pikhq> damd: What do you actually want to do?
13:39:31 <jmcarthur> mornfall: yes
13:39:34 <benmachine> oh, ok
13:39:44 <c_wraith> pikhq: I've been trying to get an answer to that question for 15 minutes.  He doesn't want to answer it.
13:39:57 <gwern> @hoogle unsafePerformIO
13:39:57 <lambdabot> Foreign unsafePerformIO :: IO a -> a
13:39:58 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
13:40:02 <pikhq> c_wraith: So apparently he thinks we are magicians.
13:40:03 <damd> i want to write a function that takes an array of strings and puts them together into one long string
13:40:11 <damd> for this i need a for loop and a static variable
13:40:11 <c_wraith> :t concat
13:40:12 <lambdabot> forall a. [[a]] -> [a]
13:40:14 <bos> packedstring? blast from my past!
13:40:15 <lambdabot> bos: You have 1 new message. '/msg lambdabot @messages' to read it.
13:40:20 <gwern> pikhq: we are magicians
13:40:23 <c_wraith> Or you could use the existing function that does that.
13:40:27 <jmcarthur> cmap :: Category (~>) => (a ~> b) -> (f a ~> f b)
13:40:27 <Trafalgard> well, reactions is indeed zero.
13:40:29 <pikhq> damd: You do not need a for loop. You do not need a variable.
13:40:36 <gwern> there is no spoon
13:40:39 <c_wraith> > concat ["foo", "bar", "baz"]
13:40:40 <pikhq> damd: You need a function from a list of strings to a string.
13:40:40 <lambdabot>   "foobarbaz"
13:40:41 <jmcarthur> damd: no you don't
13:40:45 <pikhq> It looks like this:
13:40:47 <pikhq> @src concat
13:40:48 <lambdabot> concat = foldr (++) []
13:40:57 <damd> is foldr a monad
13:40:59 * Trafalgard hands damd a spork
13:41:01 <pikhq> No.
13:41:07 <gwern> ...yhc is completely littered with haskell98isms
13:41:11 <pikhq> foldr is a function of the following type:
13:41:12 <pikhq> :t foldr
13:41:13 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
13:41:16 * gwern begins googling for 'recursive text replacement'
13:41:26 <benmachine> damd: have you read a tutorial at all
13:41:28 <pikhq> With the following source:
13:41:28 <mornfall> jmcarthur: Also, it seems that map f ~ runIdentity . (return . f)
13:41:28 <chrisdone> I think damd needs to go back to the books
13:41:29 <pikhq> @src foldr
13:41:29 <lambdabot> foldr f z []     = z
13:41:29 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
13:41:38 <chrisdone> @google real world haskell
13:41:38 <Trafalgard> IO is a monad
13:41:38 <damd> forall a b <- for loop thank you very much....
13:41:40 <lambdabot> http://www.realworldhaskell.org/
13:41:40 <lambdabot> Title: Real World Haskell
13:41:54 <damd> why you say there is no for loop you showed me now
13:42:00 <Trafalgard> um.
13:42:04 <pikhq> damd: That's not a for loop.
13:42:10 <benmachine> damd: is your minimum requisite for something being a for loop that it contains the word "for"
13:42:23 <mornfall> jmcarthur: map f ~ runIdentity . mapM (return . f)
13:42:25 <mornfall> jmcarthur: I mean. :)
13:42:29 <pikhq> That's a statement regarding the polymorphism of the type.
13:42:29 <chrisdone> I think damd needs to read a book, or is pulling our leg =)
13:42:31 <damd> "forall" is from python it's like for loop but shorter
13:42:50 * benmachine gives up
13:42:52 <Trafalgard> Yes, and they just copypasta'd the function straight from python
13:42:53 <Twey> I'm guessing the latter :þ
13:42:58 <damd> hahaha
13:43:03 <c_wraith> You know...  I'm pretty sure I've seen damd do this before.
13:43:08 <c_wraith> I should know better
13:43:10 <damd> i can't believe you guys let me do this almost every night
13:43:10 <pikhq> @where lyah
13:43:11 <lambdabot> http://www.learnyouahaskell.com/
13:43:12 <demolithion> guido is that you? :S
13:43:16 <benmachine> hah
13:43:26 <chrisdone> #haskell is too helpful to call out trolls as soon as they detect it
13:43:29 <benmachine> yep
13:43:31 <benmachine> we are too nice
13:43:33 <benmachine> how terrible of us
13:43:42 <mornfall> Call the Haskell police.
13:43:49 * benmachine hugs everyone
13:44:03 * damd ghcis benmachine
13:44:05 <pikhq> We should be more like ##c++. Where kickbanning is a way of handling personal disputes.
13:44:14 <copumpkin> sounds awesome
13:44:14 * benmachine falls over
13:44:31 * Twey hugs damd.
13:44:42 * jmcarthur doesn't think anybody will believe him if he says he was on to damd's game
13:44:49 <benmachine> I will
13:44:54 <benmachine> but that is because I am credulous
13:44:56 <mornfall> Never been banned from ##c++. Although they didn't seem happy when I failed to sing hymns about boost.
13:45:21 <copumpkin> jmcarthur: you're welcome to become maintainer :) I'm glad you think it's even worth maintaining! I'd pretty much given up on it
13:45:22 <tensorpudding> the best way to troll haskell is to ask a ton of honest questions while cale is around
13:45:32 <damd> boost is proof of c++ failing... *bait*
13:45:35 <jmcarthur> copumpkin: i don't know that i would do much with it
13:45:37 <tensorpudding> the chat will get flooded with cale helpfully explaining
13:45:43 <Twey> jmcarthur: Too obvious.  I'd have a harder time believing you weren't.  :þ
13:45:45 <benmachine> damd: as if we needed proof :P
13:45:46 <c_wraith> damd: you'll get a lot less argument on that topic here. :)
13:45:46 <copumpkin> jmcarthur: up to you then :P but I don't care either way
13:45:50 <Twey> tensorpudding: Haha
13:45:57 <pikhq> damd: Indeed, Boost is a formal proof of this.
13:46:00 <jmcarthur> copumpkin: i just have the Unbox instance that i want to put on hackage, is all
13:46:02 <chrisdone> tensorpudding: indeed. immovable object meets the unstoppable force
13:46:18 <copumpkin> jmcarthur: ah, sure. I don't mind staying the maintainer if you don't want to be
13:46:23 <jmcarthur> maybe i should write some code with it first to make sure i didn't royally screw it up
13:46:27 <benmachine> I think if you tried to do that you might accidentally find yourself understanding things >_>
13:47:01 <jmcarthur> copumpkin: i don't mind either. whatever
13:47:03 <chrisdone> troll vs Cale.  ... ten years later ...  Cale: "so do you see how monads work now?" troll: "*weep* monads are haskell's hack for doing IO *wimper*"
13:47:28 <benmachine> here is a thought
13:47:30 <Twey> Hahahaha
13:47:48 <benmachine> since all operations to read or write them are in IO, would it do any harm to have a pure function for IORefs
13:47:52 <pikhq> chrisdone: :)
13:47:53 <benmachine> (yes, but why?)
13:48:14 <benmachine> I guess semantically it would have to return the same one every time
13:48:19 <jmcarthur> a pure functions doing what? reads or writes?
13:48:20 <Twey> benmachine: I don't understand the question
13:48:25 <benmachine> oh, making them
13:48:29 <jmcarthur> ah
13:48:31 <Twey> Ah, yeah
13:48:34 <Twey> Same IORef every time
13:48:35 <quicksilver> newIORef :: IORef a, I assume he means
13:48:43 <pikhq> benmachine: What meaningful pure functions are there on IORefs, other than functions that are on all types?
13:48:50 <benmachine> pikhq: there aren't any
13:48:52 <quicksilver> pikhq: well you might compare them
13:48:52 <Twey> It'd probably even get helpfully memoised ☺
13:49:00 <benmachine> which is exactly why I'm wondering if it could be used to break anything
13:49:00 <Twey> (okay, shared)
13:49:13 <Twey> I don't think it would break anything
13:49:15 <jmcarthur> it's polymorphics, so you'd get different IORefs for each type?
13:49:16 <Twey> It just wouldn't be very useful
13:49:20 <jmcarthur> *polymorphic
13:49:20 <chrisdone> pikhq: take 1 [newIORef,newIORef] :P
13:49:23 <benmachine> mm I guess so
13:49:24 <Twey> jmcarthur: Haha, cute
13:49:47 <quicksilver> instance Eq IOref is fine. instance Ord IORef is forgivable but not very semantically sound.
13:50:05 <jmcarthur> compare a b = EQ
13:50:10 <benmachine> heh
13:50:12 <jmcarthur> i guess not true
13:50:19 <jmcarthur> if EQ has to imply (==)
13:50:36 <chrisdone> not (a == b) == a == b
13:50:38 <chrisdone> oh gods!
13:51:03 <chrisdone> uh
13:51:04 <benmachine> infix parsing error :P
13:51:07 <benmachine> *fixity
13:51:10 <chrisdone> disregard that, hahaha
13:51:26 <chrisdone> I meant (a /= b) == (a == b)
13:51:37 <jmcarthur> False
13:51:41 <benmachine> heh
13:51:49 <ray> NaN
13:52:03 <mornfall> I guess there ain't a way to trap into GHC runtime at a ccall cost, hm? :)
13:52:12 <blackh> aavogt: I've added my two patches to ticket 89 that fix the problem for me - I'd appreciate you reviewing/testing it if you want to.
13:52:29 <blackh> http://hackage.haskell.org/trac/hackage/ticket/89#comment:28
13:56:01 <Trafalgard> well I see why it's dividing by zero now
13:56:15 <edwardk> mornfall: consider the implications of said system. you call haskell which calls your c routine, which calls haskell, which calls your c routine. untold messes left on the stack on either side. now gc.
13:56:50 <edwardk> mornfall: cleaner to have the separate haskell stacks and do some scheduling
13:56:58 <byorgey> Alpounet, yitz: yes, the init command is now in cabal-install as of 1.8; mkcabal should be considered deprecated.  However, I don't think it would help waterlaz (but patches welcome).
13:57:22 <gwern> ...there are weird syntax errors all over this yhc code
13:57:29 <byorgey> I will write something about it on my blog when the HP (and with it cabal-install 1.8) is released
13:57:37 <gwern> one type signature reads, '(Quux, [Foo, Bar])'
13:58:05 <gwern> there's a case expression with '=' instead of '->'; another function has 'State $ cs -> ...'
13:58:12 <gwern> how the heck did this ever work?
13:58:14 <chrisdone> gwern: is that some shortcut for (Quux,[(Foo,Bar)])?
13:58:19 <byorgey> perhaps [Foo, Bar] is the type of lists whose elements alternate between Foo and Bar?
13:58:34 <gwern> but but
13:58:39 <byorgey> =)
13:58:44 <gwern> chrisdone: it's broken is what it is!
13:58:49 <chrisdone> :o
13:59:04 <gwern> why else would I'd be kvetching to a bunch of schlemihls like you dummkopfs!
13:59:11 <gwern> oy vey
13:59:50 <benmachine> maybe it's a bunch of weird extensions
14:00:04 <metaperl> what do I have to add so that I can apt-get install this Haskell Platform? http://wiki.debian.org/Haskell/Platform   ... debian/testing only has 6.8 in the package manager
14:00:16 <Alpounet> byorgey, nice, thank you
14:00:59 <blackh> metaperl: You'd need to use the newer version of Debian. It's possible to hack Debian so you can install some packages from newer versions but keep your distribution the same.
14:01:25 <metaperl> blackh: I have debian/testing... what do you mean newer version of debian? the unstable?
14:01:52 <blackh> metaperl: I think so. The Haskell platform is definitely in some new version of Debian, so it would be unstable, I expect.
14:02:54 <blackh> metaperl: You could consider just installing ghc 6.10.X from binary + cabal-install.  This gives you the same thing as you get with the platform.
14:03:08 <metaperl> blackh: yes, I was certainly thinking hard about that route :)
14:03:19 <metaperl> I think I will do that
14:03:33 <blackh> Really, the platform is just ghc + cabal-install + some packages preinstalled that cabal install can give you easily
14:04:16 <blackh> The platform will be wonderful when it is less of a pain to install on Linux - but it'll be a few months before the distros catch up.
14:04:28 <benmachine> or you could install 6.12 from binary, if you're feeling daring
14:05:00 <blackh> ...and if you're not feeling daring but you want something that works, then use 6.10. :)
14:05:11 <benmachine> heh
14:05:22 <alise_> data □ a where ... is a syntax error. Is □ not a valid name in this context?
14:05:24 <benmachine> yes don't listen to me I have strange priorities
14:05:25 <alise_> (Yes, that is a square.)
14:05:38 <benmachine> alise_: if it's a syntax error, I guess not :P
14:05:38 <mauke> alise_: doesn't look like a letter to me
14:05:48 <alise_> benmachine: It could also be encoding issues.
14:05:54 <benmachine> > generalCategory '□'
14:05:55 <lambdabot>   OtherSymbol
14:05:57 <metaperl> It seems odd that the version of ghc which include libtinfo is smaller than the one which requires it - http://haskell.org/ghc/download_ghc_6_10_4.html#x86linux
14:06:07 <benmachine> alise_: you want uppercase letters
14:06:10 <alise_> mauke: what abou data (□) a?
14:06:15 <benmachine> or, operators beginning with colons
14:06:15 <alise_> I guess that would not be allowed either.
14:06:16 <benmachine> that's all
14:06:17 <alise_> Such a shame.
14:06:23 <alise_> Maybe data (:□) a.
14:06:26 <alise_> But that would be so ugly to use;
14:06:27 <benmachine> uppercase letters includes Θ though
14:06:29 <alise_> *use.
14:06:36 <alise_> benmachine: That is not really anything like □ :-P
14:06:48 <benmachine> yes it is just an example
14:06:54 <alise_> For the record, □ is being used in the sense of quoting.
14:07:03 <benmachine> Π?
14:07:09 <alise_> As in, □ (a -> b) as in typed ASTs.
14:07:15 <alise_> So we have eval :: □ a -> a
14:07:15 <byorgey> benmachine: I thought it was only data constructors that are requireed to start with a colon, not type constructors?
14:07:27 <alise_> byorgey: Yes. Otherwise -> would not be valid, surely.
14:07:27 <Kagami`> @type generalCategory
14:07:28 <benmachine> byorgey: constructors in general, I think?
14:07:28 <lambdabot> Char -> GeneralCategory
14:07:34 <alise_> And (,).
14:07:35 <benmachine> -> is special
14:07:37 <benmachine> so is ,
14:07:43 <Cale> byorgey: If you define your own infix type constructors, they are too
14:07:50 <byorgey> oh, ok
14:07:57 <benmachine> -> is used in case and lambda; it is syntax
14:08:02 <Cale> byorgey: : is treated as the only "uppercase" symbol character :)
14:08:10 <benmachine> , is used in list-sugar and so forth
14:08:16 <benmachine> so both of those are exceptions
14:08:27 <alise_> Capital pi or phi would work, I suppose.
14:08:36 <mauke> Q
14:08:53 <benmachine> alise_: use O and a really really low-res font
14:08:54 <alise_> mauke: hellooooooo 1960s
14:08:58 <alise_> benmachine: haha
14:09:02 <byorgey> Cale: I see, how silly.
14:09:15 <alise_> Wish I could use lowercase phi, much prettier than uppercase.
14:09:29 <Cale> Well, you've got to tell between them somehow. You can also have infix type variables
14:09:35 <mauke> Ξ
14:09:43 <Cale> ~> is often used in that way
14:09:46 <benmachine> isn't infix type variables an extension?
14:10:07 <Cale> Yeah, but so is infix type constructors other than -> itself, as I recall.
14:10:12 <alise_> Cale: I'm a dependently-typed loser, we need no distinction :P
14:10:16 <benmachine> I don't think so
14:10:19 <benmachine> hmm
14:10:21 <benmachine> I don't know
14:10:23 <benmachine> I didn't think so
14:10:26 <benmachine> but now I am unsure
14:10:32 <Cale> I suppose if you explicitly quantify everything, then there's no problem
14:10:37 <Ke> mauke: ie. Riemann-integrate just like you did in high school -symbol
14:11:08 <benmachine> oh you are right
14:11:12 <benmachine>     Illegal declaration of a type or class operator `:+:'
14:11:23 <tensorpudding> Ψ is a good greek letter too
14:11:45 <alise_> tensorpudding: Agreed.
14:11:49 <alise_>   λ   :: (ID a → Λ b) → Λ (a → b)
14:11:54 <alise_> Oh come on, let me have /some/ niceties.
14:11:57 <alise_> Not even that! Pah
14:12:05 <shepheb> is accumArray strict? what about array?
14:12:06 <benmachine> that's not allowed?
14:12:08 <benmachine> I'm surprised
14:12:12 <alise_> Lambda is lowercase.
14:12:12 <benmachine> shepheb: I think so
14:12:16 <benmachine> oh
14:12:17 <alise_> Another reason Haskell is useless, apart from the _|_ rubbish! :P
14:12:17 <benmachine> yes
14:12:18 <shepheb> benmachine: array too?
14:12:38 <benmachine> shepheb: array structures are fast because they are allocated in a block of memory
14:12:54 <shepheb> well yes but it can do that with the bounds
14:13:14 <alise_> Does GHC interpret code as UTF-16 on Windows or something? X_X
14:13:24 <alise_> Or even codepages or whatever.
14:13:25 <benmachine> shepheb: oh, I see what you mean
14:13:30 <alise_> How can I tell it it's UTF-8?
14:13:30 <benmachine> I don't know then
14:13:34 <benmachine> unboxed arrays certainly are
14:13:47 <shepheb> I think accumArray is stricter than array... not sure though.
14:13:59 <mauke> {-# LANGUAGE UnicodeSyntax #-} ?
14:14:16 <benmachine> unicodesyntax is only for things like → isn't it?
14:14:19 <benmachine> and ∀
14:14:30 <mauke> hmm
14:14:31 <benmachine>  > ∀
14:14:32 <copumpkin> it gives you everything but a lambda
14:14:37 <benmachine> > ∀
14:14:38 <lambdabot>   Not in scope: `forall'
14:14:39 <copumpkin> (unicodesyntax)
14:14:44 <copumpkin> that's amusing
14:14:49 <alise_> UnicodeSyntax doesn't work, it's an error in the actual decoding
14:15:00 <alise_> It's saying my beautiful greek is actually accented letters
14:17:20 <sfuentes> ok i just got a string of data that's suppose to be binary and i'm wondering if anyone knows how i can take this string data and convert it to binary data.
14:17:27 <alise_> Pah.
14:18:06 <sfuentes> some context: the string data is a basically a jpg that i have in a [String] but i need to spit that out to a file as binary data
14:18:51 <blackh> sfuentes: The best thing to do is turn it into a ByteString which you can do with B.pack . map BI.c2w where B = Data.ByteString and BI = Data.ByteString.Internal
14:18:59 <alise_> see ByteString, sfuentes.
14:19:05 <alise_> But ideally you'd have the jpeg as a ByteString in the first place.
14:19:18 <mauke> :t openBinaryFile
14:19:20 <lambdabot> Not in scope: `openBinaryFile'
14:19:44 <benmachine> you can do IO with bytestrings directly can't you?
14:19:49 <benmachine> there is a BS.readFile or some such
14:19:53 <mauke> yes
14:19:53 <benmachine> :t BS.readFile
14:19:55 <lambdabot> FilePath -> IO BSC.ByteString
14:19:57 <alise_> I wish {-# ENCODING UTF-8 #-} Just Worked.
14:20:04 <saml> hey, how can I benchmark simply?  like in java,  final long t = System.currentMill....
14:20:24 <sfuentes> ok so if i simply convert it to bytestring and write it out to a file it should be fine?
14:21:00 <Alpounet> sfuentes, where are you getting that jpg data from ?
14:21:19 <copumpkin> @hackage criterion
14:21:20 <lambdabot> http://hackage.haskell.org/package/criterion
14:21:22 <Alpounet> network ? you can use the network-bytestring package
14:21:26 <copumpkin> saml: that isn't a benchmark
14:21:29 <copumpkin> criterion is
14:21:32 <Alpounet> file ? see what benmachine said
14:21:45 <saml> no.. i just want to time it simply
14:21:50 <saml> i'll read the doc
14:21:54 <copumpkin> @hackage timeIt
14:21:54 <lambdabot> http://hackage.haskell.org/package/timeIt
14:22:02 <copumpkin> http://hackage.haskell.org/package/timeit
14:22:06 <copumpkin> saml: ^
14:22:22 <saml> thanks copumpkin
14:22:29 <Alpounet> wow, copumpkin is a map from needs to packages
14:22:49 <sfuentes> Alpounet: i'm getting it form Network.HTTP
14:23:45 <copumpkin> type Copumpkin = Data.Map.Map Need Package
14:23:55 <copumpkin> or maybe just Need -> Package
14:23:59 <copumpkin> seems more pure
14:24:35 <Alpounet> sfuentes, you may want to check network-bytestring, to have it directly in that format
14:25:19 <sfuentes> ok. will look into that. thanks guys
14:25:58 <blackh> sfuentes: In the old days people used to use String to store binary data and a bit of that is still hanging around.
14:26:22 <Alpounet> copumpkin, hmm, it seems you're thinking of yourself as a type, rather than a value of that type. Why's that ?
14:26:29 <blackh> sfuentes: It's an especially bad idea now because of the new encoding-aware stuff in the new version of base that comes with ghc-6.12
14:26:44 <copumpkin> Alpounet: I have many personalities, but they all map from needs to packages
14:26:47 <copumpkin> fine
14:26:52 <copumpkin> copumpkin :: Need -> Package
14:27:10 <mux> @pl \x _ -> x + 1
14:27:10 <lambdabot> const . (1 +)
14:27:28 <benmachine> so pumpkin :: Package -> Need?
14:27:31 <tommd> .. So copumpkin takes needs and produces packages?  What is the relation between the two?
14:27:42 <copumpkin> benmachine: yep
14:28:03 <sfuentes> blackh: good to know
14:28:04 <alise_> tommd: you can't say without dependent types
14:28:09 <copumpkin> copumpkin = const Spoon
14:28:22 <blackh> blackh :: Requirement -> Coffee -> Code
14:29:07 <shepheb> [DateTime->Requirement] -> Coffee -> Code
14:29:10 <copumpkin> blackh-effective :: forall r c. satisfies r (blackh r c)
14:29:20 <shepheb> set of requirements that vary independently with time
14:29:28 <gwern> @quote ParsecT
14:29:28 <lambdabot> edwardk says: heh, i'm amused the ParsecT that Antoine Latter put together is in the form of a right kan extension ;)
14:29:34 <gwern> @quote backdoors
14:29:34 <lambdabot> Philippa says: <TR1N1TY> I'm selling botz and backdoors <Philippa> I'm selling bans
14:29:45 <gwern> @quote longer.*than.*program
14:29:45 <lambdabot> No quotes match. I am sorry.
14:29:51 <gwern> @quote longer.*
14:29:52 <lambdabot> Wikipedia says: In topology, the long line (or Alexandroff line) is a topological space analogous to the real line, but much longer.
14:29:54 <copumpkin> that was on reddit
14:30:00 <gwern> wrong. it was on HWN
14:30:09 <benmachine> haha I remember finding that wikipedia page
14:30:09 <copumpkin> it was cited on HWN from reddit
14:30:18 <gwern> @remember samlee [via Reddit] haha those ghc options are longer than actual program
14:30:19 <lambdabot> Good to know.
14:30:22 <gwern> @flish
14:30:28 <copumpkin> @flesh
14:30:29 <lambdabot> Not enough privileges
14:30:31 <copumpkin> :(
14:30:36 <copumpkin> I want moar flesh
14:30:36 <mauke> @flash
14:30:36 <lambdabot> Not enough privileges
14:30:39 <olsner> gwern: heh, where did you find that?
14:30:50 <gwern> my rss reader
14:30:50 <copumpkin> @fleshbot
14:30:51 <lambdabot> Unknown command, try @list
14:30:54 <Becquerel> the flesh is willing but the lambda is weak
14:31:02 <Becquerel> or
14:31:02 <benmachine> gwern: than actual program?
14:31:03 <Becquerel> no
14:31:10 <gwern> benmachine: sure
14:31:11 <Becquerel> I forget.
14:31:13 <mightybyte> Does haskell have a way to do pointer-like comparison?  i.e. I have two declarations "foo = ..." and "bar = ..." which both have type T.  Then somewhere else I want to check to see whether a field in another data structure contains foo or bar.
14:31:16 <mightybyte> But the expression "field == foo" requires that T have an Eq instance.
14:31:19 <mauke> @admin + copumpkin
14:31:22 <benmachine> gwern: [sic]?
14:31:22 <gwern> benmachine: don't you always than actual program?
14:31:26 <mauke> copumpkin: you got fleshed
14:31:27 <copumpkin> @flush
14:31:30 <copumpkin> zomg!
14:31:33 <copumpkin> I can flesh!
14:31:43 <copumpkin> thanks :)
14:31:43 <gwern> i flesh you so hard
14:31:51 <copumpkin> gwern: pm please
14:32:07 <copumpkin> flesh harder
14:32:13 <copumpkin> oh whoops
14:32:13 <olsner> flesh you all
14:32:55 <mauke> copumpkin: bonus points if you can figure out how I got @admin powers :-)
14:33:08 <gwern> @hoogle Locale
14:33:08 <lambdabot> No results found
14:33:17 <copumpkin> mauke: like I usually use @msg?
14:33:17 <benmachine> mauke: I am kind of curious, why do you occasionally do drive-by quotings?
14:33:18 <gwern> hm. Locale is a new one on me
14:33:44 <gwern> ah, System.Locale
14:33:45 <copumpkin> mauke: I occasionally webchat into TheHunter and use it to @join or @msg :)
14:34:09 <mauke> I see
14:34:13 <mauke> benmachine: example?
14:34:20 <copumpkin> but someone added autorename to his account
14:34:26 <copumpkin> so you have to be really fast now if you want it to work
14:34:30 <benmachine> mauke: oh, I meant gwern
14:34:35 <mauke> copumpkin: or be the account owner :-D
14:34:40 <copumpkin> mauke: that too :P
14:34:42 <benmachine> sorry, five letter names
14:34:44 <benmachine> lowercase
14:34:58 <benmachine> gwern: I am kind of etc.
14:34:58 <saml> > sum [1..100]
14:34:59 <lambdabot>   5050
14:35:04 <saml> > sum [1..1000]
14:35:05 <lambdabot>   500500
14:35:07 <gwern> @hoogle Time
14:35:07 <lambdabot> module Data.Time
14:35:07 <lambdabot> module System.Time
14:35:08 <lambdabot> package time
14:35:17 <gwern> shoot. is haskell98 Data.Time or System.Time?
14:35:31 <mauke> neither, H98 doesn't have . in module names
14:35:48 <benmachine> Data.Time comes from time and System.Time comes from old-time
14:35:50 <benmachine> if that helps
14:35:50 <Cale> mightybyte: You really don't want to compare pointers. Things get moved around by the garbage collector.
14:36:06 <gwern> benmachine: I need 'Time' -> '?.Time'
14:36:22 <copumpkin> @hoogle reallyUnsafe
14:36:22 <lambdabot> No results found
14:36:25 <copumpkin> damn
14:36:30 <gwern> drat. it was System.Time and not Data.Time
14:36:32 <Cale> mightybyte: There's no real way to do that. You're better off inventing your own structure to hold and refer to values of type T.
14:36:33 <znutar> What's the path of least resistance for getting ghc 6.12 and cabal-install 0.8 onto a ubuntu machine?  Should I get the haskell platform packages and go from there?
14:36:44 <Cale> mightybyte: For example, perhaps an IntMap
14:36:49 <Alpounet> mightybyte, you really should define the Eq instance, if it makes sense. Otherwise, find why you're wrong about wanting to do that.
14:37:11 <mightybyte> Cale: Ahhh, I was hoping I wouldn't have to do that.
14:37:38 <c_wraith> znutar: dowload the 6.12.1 binary release.  install it.  download cabal-install 0.8 from hackage, unpack it, and run bootstrap.sh
14:37:53 <Cale> mightybyte: What are you trying to accomplish?
14:38:06 <mightybyte> Alpounet: In my case, T is Parser, so that's not as easy as it sounds.
14:38:16 <znutar> c_wraith: thanks!
14:38:25 <c_wraith> znutar: It really was that painless for me.  Your luck may vary. :)
14:38:27 <mightybyte> Cale: I have a predefined table mapping strings to Parsers.
14:38:47 <mightybyte> (actually it's just an association list)
14:39:25 <mightybyte> So I'm using that to look up the right parser to use, but I also need to do some checks to see which parser I'm dealing with.
14:39:43 <Cale> Why?
14:40:01 <mightybyte> Because there are some special cases.
14:40:14 <Cale> Perhaps include extra data alongside the Parser value in the table?
14:40:17 <Alpounet> mightybyte, can't you just have your assoc list hold additional information on the parser ? that would let you handle these special cases
14:40:21 <mightybyte> Yeah, I can do that.
14:40:40 <mightybyte> It just seemed like the C-ish "pointer" approach was the simplest.
14:41:07 <Cale> It's strange to think of values having identities, even if they occupy real bits of memory as the program is running. :)
14:41:41 <Cale> When I think about comparing two Parsers to see if they're equal, I'd imagine verifying somehow that they parse the same language...
14:41:52 <mightybyte> Heh
14:42:07 <olsner> hmm, and that way the halting problem lies :P
14:42:22 <mightybyte> I agree, but knowing that we're using a Turing machine suggests a trivial alternative.
14:42:32 <Cale> Well, you can do it for some special classes of parsers. Regular expressions, certainly :)
14:42:52 <mornfall> Cale: And that's about it... : - P
14:43:06 <Cale> In fact, I wrote a program which can test if the language parsed by one regular expression is a sublanguage of that parsed by another.
14:43:52 <Cale> How intractable is the problem for context-free languages?
14:43:59 <saml> http://www.reddit.com/r/programming/comments/baph7/you_can_write_reduce_in_a_few_lines_of_python_not/c0lt9tw    hey . can you help me write optimized version of haskell?
14:43:59 <olsner> hmm, at which point in the hierarchy does equality turn undecidable?
14:44:06 <mornfall> Cale: Well, if you convert it to NFA, then determinize and minimize and canoni(ci?)ze, you have your answer (about regexen).
14:44:09 <saml> i want to beat python performance
14:44:22 <mornfall> Cale: As for CFLs, I suspect this is undecidable.
14:44:26 <sinelaw> Alpounet, howzit :)
14:44:26 <mornfall> Cale: Even for equality. But let me check.
14:44:29 <chrisdone> saml: not this time!!
14:44:43 <saml> it's my homework. i need to pass this class
14:44:58 <chrisdone> saml: fool me once, shame on you
14:45:26 <chrisdone> you cheeky bugger
14:45:33 <mauke> hrml?
14:45:38 <Cale> saml: Use foldl'
14:45:47 <Cale> or compile with -O2
14:45:55 * chrisdone makes some popcorn
14:46:14 <Cale> saml: If you care *at all* about performance of Haskell code, compiling without optimisations is a bad idea.
14:46:31 <saml> Cale: ah thanks!
14:46:40 <mornfall> Cale: For CFLs given as grammars, equality is indeed undecidable.
14:46:40 <Alpounet> sinelaw, hey
14:46:43 <Cale> GHC's optimisations can improve the asymptotic complexity of code in some cases, even.
14:46:48 <Alpounet> how are you doing ?
14:46:50 <mornfall> Cale: At least according to WP. : - P
14:46:50 <copumpkin> mornfall: spoilsport
14:47:05 <copumpkin> anyone remember roconnor's ridiculous improvement?
14:47:15 <Cale> mornfall: Okay, that's reasonable I suppose.
14:47:41 <copumpkin> it's sad how many things are undecidable
14:47:55 <NEEDMOAR> Given f True False = False, if I have to evaluate f True False, it would match the first and second argument at once, or it would do: f True False = (f True) False ->(match the first argument, and create and return a function f') f' False where f' False = False -> False?
14:47:55 <saml> Cale: nice! it takes 11 seconds!! and answer is correct!
14:48:06 <mornfall> Well, it's quite likely in r.e. though. If that cheers you a little...
14:48:07 <copumpkin> saml: how much slower was itbefore?
14:48:13 <saml> it never halted
14:48:16 <copumpkin> yeah, REs are easy though
14:48:18 <saml> and blew memory
14:48:27 <sinelaw> Alpounet cool
14:48:40 <jlouis> copumpkin: undecidable things and evil complexity classes together with parallel execution just makes it more fun!
14:48:41 <sinelaw> trying to design a functional higher-level interface module over HOpenCV
14:49:14 <Cale> saml: If you want the program to work when not compiled with optimisations, you can replace the foldl with foldl' from Data.List
14:49:18 <Alpounet> sinelaw, haha, that's exactly what I'm waiting for to seriously tackle my project
14:49:34 <Cale> saml: I can show you what's happening to cause it to crash
14:49:35 <Alpounet> I couldn't get my head around the current stuffs since I don't know OpenCV
14:49:42 <Cale> saml: Let's use a smaller list...
14:49:47 <Cale> foldl (+) 0 [1,2,3]
14:49:53 <mornfall> Cale: (Just in case, I meant r.e. as in recursively enumerable...)
14:49:55 <Cale> @src foldl
14:49:56 <lambdabot> foldl f z []     = z
14:49:56 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
14:50:14 <sinelaw> Alpounet unfortunately it's not a trivial problem for me, first time i'm doing soemthing like this
14:50:15 <mux> > foldl (const . (+1)) 0 [1..10]
14:50:17 <lambdabot>   10
14:50:17 <saml> call graph is large!!!!!!!!!
14:50:33 <Cale> -> foldl (+) (0+1) [2,3]
14:50:40 <Cale> -> foldl (+) ((0+1)+2) [3]
14:50:45 <Cale> -> foldl (+) (((0+1)+2)+3) []
14:50:47 <mornfall> Cale: (Although the r.e. problem here would be L(G) /= L(G') for G, G' CFGs..., not ==)
14:50:49 <Cale> -> ((0+1)+2)+3
14:50:51 <Alpounet> sinelaw, I guess so yeah. If you want some feedback/testing/discussion, don't hesitate
14:50:54 <Alpounet> would be glad to help
14:50:59 <Cale> ^^ here is where you need a lot of stack
14:50:59 <mux> > foldl (+) x [y,z]
14:51:00 <lambdabot>   x + y + z
14:51:02 <sinelaw> Alpounet i managed to write one attempt, but the resulting types are not clean enough. as you compose, they type accumulates things that you shouldn't be seeing
14:51:14 <mux> > foldl f x [y,z]
14:51:15 <lambdabot>   f (f x y) z
14:51:20 <saml> Cale: you mean 3 lists?
14:51:21 <Alpounet> ok, so you gotta expose a cleaner interface
14:51:22 <Alpounet> hmm
14:51:27 <Alpounet> I guess it's not that easy at all
14:51:28 <Cale> Because (+) "pattern matches" on both its parameters
14:51:31 <mux> SimpleReflection is still cool
14:51:35 <mornfall> I apparently forgot the closure properties of rec and r.e. problems. Sigh.
14:51:46 <Cale> The outermost (+) needs to wait for its first parameter to evaluate before it can continut
14:51:48 <Cale> continue*
14:52:04 <Cale> So "(...) + 3" is put on the stack
14:52:16 <sinelaw> Alpounet http://github.com/sinelaw/cv-combinators/tree/master/src/AI/CV/
14:52:16 <Cale> and then evaluation proceeds with (0+1)+2
14:52:18 <saml> how does  foldl'  different? it says strict version
14:52:20 <jmcarthur> it's just like writing a non-tail-recursive function in a strict language
14:52:26 <Cale> and then "(...) + 2" is put on the stack
14:52:28 <Cale> and so on
14:52:30 <jmcarthur> foldl' is the tail recursive version :)
14:52:43 <sinelaw> Alpounet Processor.hs is the main thing, ImageProcessors.hs is an example of using that for OpenCV
14:52:53 <Cale> foldl is tail recursive, but that doesn't mean much to a lazy evaluator
14:53:06 <saml> oh darn implementation detail!!!!  we python users don't understand tail recursion
14:53:17 <sinelaw> Alpounet the problem is that the function chain accumulates junk in a tuple to be able to properly run things later
14:53:20 <sfuentes> how can i write a bytestring of data to a file? most of the functions i see for file i/o take strings but i need this to write out binary data
14:53:21 <saml> but it's nice that -O2 recogmizes it and fixes it
14:53:26 <Cale> Don't bother yourself with it
14:53:37 <jmcarthur> i don't consider tail recursion to be an implementation detail in a strict language
14:53:40 <sinelaw> the monad in that file is going to be IO for all we care
14:53:42 <mornfall> sfuentes: Data.ByteString.writeFile?
14:53:54 <Cale> Tail recursion isn't really the right concept to be paying attention to for programming with a lazy evaluator.
14:53:54 <jmcarthur> just like i don't consider the difference between laziness and strictness to be an implementation detail in haskell
14:54:02 <ivanm> hey sinelaw
14:54:50 <ickan> can anyone point me a discussion on understanding foldl in terms of foldr?
14:54:51 <mornfall> Well, when someone invents an evaluator for which laziness would be an implementation detail, they will be rich and famous and all...
14:55:32 <sfuentes> mornfall: excuse my ignorance
14:56:02 <Cale> Laziness is an implementation detail. Nonstrictness is really the important thing.
14:56:06 <mux> the biggest problem I have with haskell today, is that I can't stop myself from staring ecstatically at my code thinking how damn elegant it is
14:56:22 <Cale> But to understand the stack overflow here, you do need to understand the implementation.
14:56:29 <Trinitron> Prelude> thousand 0 = 0
14:56:30 <sinelaw> I'm trying to write a generic interface for chaining things that do: Allocate ; run; release.
14:56:30 <Trinitron> <interactive>:1:11: parse error on input `='
14:56:38 <Alpounet> sinelaw, ok, looks promising
14:56:39 <mux> haskell is the language of narcisists
14:56:40 <Cale> Trinitron: Definitions go into a file
14:56:53 <copumpkin> sinelaw: have you seen the region code on hackage?
14:56:55 <sinelaw> the chaining should result in: allocate, allocate, allocate, ..., run run run run, ... release (in reverse order)
14:56:59 <Cale> Trinitron: You load that file with ghci, and then test things by writing expressions
14:57:09 <Trinitron> with .hs?
14:57:12 <copumpkin> @hackage regions
14:57:12 <lambdabot> http://hackage.haskell.org/package/regions
14:57:12 <Cale> yeah
14:57:21 <Cale> Trinitron: I tend to keep my editor open in a separate window alongside ghci
14:57:29 <sinelaw> copumpkin nope but i was suspecting something like this already exists
14:57:34 <Cale> Trinitron: and then when I save the file, just type :r in ghci to reload it
14:57:45 <c_wraith> yes.  become friends with :r in ghci. :)
14:58:15 <Trinitron> Ok, this is different to python, which has an interactive mode
14:58:27 <jmcarthur> we have an interactive mode
14:58:28 <Trinitron> I'm used to typing my functions in the same window
14:58:39 <jmcarthur> oh, data definitions
14:58:43 <Cale> You can put function definitions in there, but it's not really a great idea.
14:58:47 <jmcarthur> you can define functions in ghci, just not data
14:58:50 <Cale> If you prefix them with let
14:58:50 <Trinitron> ok'
14:58:54 <Alpounet> sinelaw, no way to make that generic ?
14:59:01 <Alpounet> oh
14:59:03 <jmcarthur> you can kind of treat ghci as an augmented IO monad, in terms of syntax
14:59:03 <Alpounet> regions might do it
14:59:08 <Cale> However, you have to squish them onto one line
14:59:15 <jmcarthur> do notation, that is
14:59:18 <Cale> Or else, I think there's some :{ :} syntax
14:59:19 <Trinitron> I don't know what a monad is.
14:59:19 <Alpounet> copumpkin :: Need -> Package striked again
14:59:22 <Trinitron> Sorry.
14:59:23 <copumpkin> :)
14:59:36 <Cale> Trinitron: Don't worry about that :)
14:59:36 <mux> I think it's Need -> IO Package
14:59:53 <Alpounet> that's similar to the RAII principle actually
14:59:53 <copumpkin> Need -> Maybe Package
14:59:58 <Alpounet> well, that's the raii principle
15:00:24 <sinelaw> copumpkin looks complicated
15:00:32 <copumpkin> sinelaw: it should be too bad
15:00:37 <copumpkin> you need to define an instance of Resource
15:00:41 <Cale> Trinitron: The important thing is that ghci, by default, will print the value of the expressions that you type. There is an exception in the case that they are IO actions, in which case it executes them, and also in recent versions, prints their result.
15:01:00 <Cale> For example, try  getLine :: IO String
15:01:07 <Alpounet> sinelaw, you can roll own your own version of that, being minimal for your task.
15:01:08 <Cale> which is an IO action for getting a line of text from the user
15:01:16 <copumpkin> sinelaw: check out the oleg paper on it... it's more complicated than you might think to do it right
15:01:26 <copumpkin> http://okmij.org/ftp/Computation/resource-aware-prog/region-io.pdf
15:01:27 <Cale> lambdabot, by contrast, only evaluates expressions, so we can see the difference:
15:01:30 <Cale> > getLine
15:01:31 <lambdabot>   <IO [Char]>
15:01:47 <Cale> ^^ it evaluates it into an IO action, but doesn't execute it
15:01:47 <sinelaw> copumpkin i'm looking at that paper
15:02:05 <altmattr> it is possible to get ghci to send its output to a pipe?
15:02:08 <sinelaw> and it looks complicated
15:02:17 <altmattr> I have debugging output I want to look at
15:02:25 <altmattr> in my text editor
15:02:32 <copumpkin> sinelaw: maybe you don't need all of its features, I dunno :)
15:02:33 <Trinitron> How do I load a .hs file?
15:02:53 <Cale> Trinitron: Either pass it as a commandline parameter to ghci, or :l <filename>
15:02:57 <Trinitron> ok
15:03:01 <ivanm> where :l is short for :load
15:03:04 <copumpkin> sinelaw: one key feature is that it prevents you from even using values outside of the region
15:03:10 <copumpkin> unlike something like alloca
15:03:13 <copumpkin> @hoogle alloca
15:03:13 <lambdabot> Foreign.Marshal.Alloc alloca :: Storable a => (Ptr a -> IO b) -> IO b
15:03:13 <lambdabot> Foreign.Marshal.Array allocaArray :: Storable a => Int -> (Ptr a -> IO b) -> IO b
15:03:13 <lambdabot> Foreign.Marshal.Array allocaArray0 :: Storable a => Int -> (Ptr a -> IO b) -> IO b
15:03:14 <sinelaw> and the interface is monadic, i may be wrong but that's not what i want. i want to be able to do: test =  processor1 `chain` processor2 `chain` processor3;  then inside an IO do result <- runProcessor test
15:03:15 <Cale> You can type :? to get a list of these special commands
15:03:22 <ivanm> or, if using haskelll-mode in emacs, C-c C-l ;-)
15:03:40 <Cale> and unique prefix of one of the commands will work as well
15:03:41 <copumpkin> sinelaw: there's nothing preventing that IO b from containing the Ptr a, so you could do unsafe stuff with that
15:03:44 <Cale> any*
15:04:27 <ivanm> Cale: not quite; :b isn't unique but is a shortcut for :break
15:04:32 <Trinitron> == is equality?
15:04:37 <tommd> Typically
15:04:38 <Trinitron> 5 == 5 is True
15:04:43 <tommd> > 4 == 3
15:04:44 <lambdabot>   False
15:04:45 <Cale> :back
15:04:46 <ivanm> (which annoys me to no end when I want to do :browse)
15:04:46 <sinelaw> ok, need to go for now.
15:04:49 <Cale> er, oh
15:04:52 <Cale> I see
15:05:17 <Cale> Yeah, that's irritating.
15:05:24 <copumpkin> sinelaw: let me know what you end up doing :)
15:05:30 <Cale> I wonder what made them decide to make it :break
15:05:43 <ivanm> Cale: it was :break before they added :back and :browse ?
15:05:56 <ivanm> or else they figured people are more likely to want debugging functionality?
15:05:58 <Cale> I'm pretty sure :browse predates the debugger entirely.
15:06:01 * ivanm has never used the ghci debugger...
15:06:14 <Cale> Yeah, I don't use the debugger either.
15:06:17 <copumpkin> me neither
15:06:24 <copumpkin> I played with it to see how it works, and then never used it
15:06:27 <ezyang> what is Control.OldException.Exception?
15:06:29 <HugoDaniel> i have used
15:06:31 <jmcarthur> i tried it once for kicks
15:06:33 <HugoDaniel> it was handy
15:06:40 <jmcarthur> didn't seem useful to me
15:06:48 <ezyang> ^_^
15:06:54 <HugoDaniel> i had to use it, i tend to write really nasty haskell
15:06:57 <Trinitron> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23357#a23357
15:07:01 <Trinitron> Halp.
15:07:01 <ivanm> ezyang: the old exception setup from base-3
15:07:02 <copumpkin> aha
15:07:04 <copumpkin> HALP
15:07:10 <ivanm> it's there in base-4 for compatability reasons but shouldn't be used
15:07:17 <ivanm> Trinitron: what?
15:07:32 <jmcarthur> it seems to me that to understand the output of ghci's debugger you have to understand your code in the first place
15:08:05 <ezyang> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23358#a23358
15:08:13 <ezyang> one of these imports is grabbing the old exception.
15:08:27 <ivanm> none of them should be...
15:08:28 <ezyang> I'm... not quite sure how to divine this out
15:08:35 <ivanm> since imports aren't recursive
15:08:40 <Trinitron> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23357#a23359
15:08:45 <Trinitron> Please help me with this.
15:08:47 <ivanm> unless they explicitly re-export OldException, but none of them should
15:08:49 <Alpounet> copumpkin, huh ?
15:08:51 <Alpounet> :p
15:08:53 <ivanm> Trinitron: what's your problem?
15:08:59 <copumpkin> Alpounet: I love "halp"
15:08:59 <ezyang> ivanm: They could. I've seen worse ^^
15:09:12 <ezyang> I guess I can start bisecting...
15:09:13 <ivanm> ezyang: but these are all "big" ones, and thus shouldn't
15:09:16 <Trinitron> I get an error.
15:09:22 <Trinitron> Failed.
15:09:27 <ivanm> _what_ error? ;-)
15:09:34 <ivanm> oh, I know what it is
15:09:36 <Trinitron>  Couldn't match expected type `t -> t1 -> Bool'
15:09:36 <Trinitron>            against inferred type `Bool'
15:09:39 <ivanm> @type trinitron
15:09:40 <lambdabot> Not in scope: `trinitron'
15:09:42 <ivanm> whoops
15:09:46 <ivanm> @type or
15:09:47 <lambdabot> [Bool] -> Bool
15:09:50 <ezyang> ivanm: Ok.
15:09:51 <ivanm> @type (||)
15:09:52 <lambdabot> Bool -> Bool -> Bool
15:09:55 <ezyang> Maybe my cabal setup is messed up
15:10:01 <ivanm> Trinitron: or is for a list of Bool values
15:10:05 <ivanm> you want ||
15:10:14 <Trinitron> Huh?
15:10:16 <ivanm> (also, you're using or as infix when it's prefix)
15:10:33 <ezyang> Here's the code that's erroring: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23360#a23360
15:10:37 <ivanm> Trinitron: how did you write that?
15:10:42 <ivanm> because it's _full_ of errors?
15:10:51 * ivanm suggests Trinitron go through a tutorial
15:10:58 <Trinitron> I sort of did
15:11:01 <ezyang> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23361#a23361 is the error
15:11:12 <ivanm> Trinitron: don't "sort of", actually do!
15:11:15 <NEEDMOAR> Given f True False = False, if I have to evaluate f True False, it would match the first and second argument at one shoot, or it would do: (f True) False, match the first argument: f' False where f' False = False and therefore False?
15:11:32 <ivanm> NEEDMOAR: huh?
15:11:33 <copumpkin> if looks a lot more complicated than it needs to be
15:11:40 <ivanm> depends on how you define your function
15:11:44 <ivanm> copumpkin: whose?
15:11:51 <jmcarthur> NEEDMOAR: are you asking about the evaluation semantics of pattern matching?
15:11:59 <NEEDMOAR> jmcarthur: yes.
15:12:06 <NEEDMOAR> ivanm: the definition is f True False = False
15:12:12 <copumpkin> NEEDMOAR: conceptually, the (f True) False, but in practice I think it might pass the arguments to a single function call behind the scenes
15:12:23 <jmcarthur> NEEDMOAR: i'm pretty sure that both arguments would be evaluated there, even if the first is wrong
15:12:43 <ivanm> jmcarthur: hmmm... I would think it would try to match the first argument
15:12:51 <jmcarthur> copumpkin: really? what you describe sounds like the semantics of partial evaluation
15:13:05 <ivanm> > let f True False = True; f _ _ = False in f False undefined
15:13:06 <lambdabot>   False
15:13:09 <ivanm> jmcarthur: ^^
15:13:20 <Trinitron> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23362#a23362
15:13:24 <ivanm> NEEDMOAR: so it tries to match the first arg, if it fails it doesn't bother to match the second arg
15:13:27 <jmcarthur> i stand corrected
15:13:35 <Trinitron> It won't run.
15:13:36 <copumpkin> Trinitron: you need to read a tutorial :P
15:13:40 <ivanm> Trinitron: go read a tutorial
15:13:51 <ivanm> #haskell `notElem` tutorials
15:13:57 <copumpkin> :t let thousand x = if ((x `mod` 3) == 0) || ((x `mod` 5) == 0) then (x + thousand x-1) else (thousand x-1) in thousand
15:13:57 <ivanm> @where lyah
15:13:57 <lambdabot> http://www.learnyouahaskell.com/
15:13:58 <lambdabot> forall a. (Integral a) => a -> a
15:14:00 <ivanm> @where yaht
15:14:00 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
15:14:03 <ivanm> @where wikibook
15:14:03 <lambdabot> http://en.wikibooks.org/wiki/Haskell
15:14:11 <copumpkin> Trinitron: or if you just want quick and dirty, copy what I just wrote
15:14:24 <ivanm> or else read a book such as Craft of Functional Programming or Haskell School of Expression
15:14:42 <ezyang> aha, throwCGI is using the old exception
15:14:48 <jmcarthur> > let (a, b) &* (c, d) = a + b in (1, 2) &* undefined
15:14:49 <lambdabot>   * Exception: Prelude.undefined
15:14:54 <jmcarthur> that's the situation i was thinking
15:14:57 <jmcarthur> my bad
15:15:20 <jmcarthur> the full pattern is matched even if the rhs doesn't use an argument
15:15:32 <ivanm> Trinitron: stop doing project euler until you've _finished_ at least one tutorial
15:15:39 <jmcarthur> but only if the pattern doesn't fail to match before it's done
15:15:49 <ivanm> ezyang: so it's _using_ it, not re-exporting it?
15:15:58 <NEEDMOAR> But, it's done argument by argument, or in one shoot?
15:16:01 <jmcarthur> is Trinitron HaskellLove?
15:16:01 <ivanm> jmcarthur: yeah, with variables
15:16:09 <ezyang> It looks like I have an old version of CGI installed
15:16:09 <jmcarthur> NEEDMOAR: argument by argument, apparently
15:16:10 <ivanm> NEEDMOAR: appears to do literal matches by argument
15:16:21 <ivanm> jmcarthur: needs a ~ ;-)
15:16:27 <jmcarthur> ivanm: right ;)
15:16:30 <ivanm> > let (a, b) &* ~(c, d) = a + b in (1, 2) &* undefined
15:16:31 <lambdabot>   3
15:16:33 <ivanm> \o/
15:16:38 <Trinitron> What HaskellLove?
15:16:39 <ezyang> Yay!
15:16:50 <jmcarthur> Trinitron: doesn't worry about it
15:16:56 <mauke> I thought pokoko222 was HaskellLove
15:17:01 <ivanm> Trinitron: someone who came here and wanted help doing every single project euler problem because he didn't want to do a tutorial
15:17:03 <jmcarthur> Trinitron: it was somebody else who got wrapped up in doing project euler problems instead of learning the language
15:17:11 <copumpkin> @tell sinelaw btw, http://hackage.haskell.org/packages/archive/usb-safe/0.5.1.1/doc/html/System-USB-Safe.html contains an example of how to use regions
15:17:11 <lambdabot> Consider it noted.
15:17:22 <ivanm> jmcarthur: copumpkin and I were considering that off-channel ;-)
15:17:30 <jmcarthur> haha
15:17:42 <pokoko222> pokoko222 is HaskellLove yea
15:17:51 <jmcarthur> ah!
15:17:52 <medfly> are you?
15:17:57 <pokoko222> daah
15:18:36 <pokoko222> i got this name now cause on c++ forums with HaskellLove I will get raped, and i do c++ now cause i got exams
15:18:38 <ivanm> medfly: if you're going by the "New Now Know How", that's apparently the IRC client
15:18:48 <ivanm> oh, it is the same person
15:18:54 * ivanm adds pokoko222 to his ignore list
15:18:56 <medfly> nono, he said it... about himself
15:19:04 <medfly> hhaha, ouch
15:19:06 <NEEDMOAR> ivanm, jmcarthur: how do you figure it's argument by argument?
15:19:17 <ivanm> > let f True False = True; f _ _ = False in f False undefined
15:19:18 <lambdabot>   False
15:19:19 <jmcarthur> NEEDMOAR: i don't understand the question
15:19:33 <ivanm> NEEDMOAR: if it evaluated each argument, then it would crash from trying to match undefined to False
15:19:39 <pokoko222> aaa ivanm my beloved friend
15:19:42 <jmcarthur> oh i get it
15:20:41 <jmcarthur> NEEDMOAR: we know because f False _|_ in ivanm's test code is False instead of _|_
15:20:42 <NEEDMOAR> f False undefined, then tries to match with the first sentense (using both arguments), if not then tries with the second, etc. OR you take (f False) undefined, then you calculate (f False) by matching only in the first argument, and this gives you a f' _ = False, which is applied then to False thus giving False?
15:21:07 <ivanm> huh?
15:21:25 <jmcarthur> NEEDMOAR: it tries one pattern at a time and short circuits to the next pattern if it finds that it doesn't match early
15:21:37 <ivanm> NEEDMOAR: it takes f False undefined; it tries the first pattern match where the first arg is first = True and second = False
15:21:49 <ivanm> since the first arg is _not_ True it doesnt' bother  trying to match the second arg
15:22:00 <ivanm> NEEDMOAR: why do you need to know/care ?
15:22:17 <ivanm> the only tiems I can see it mattering is if you have undefined values everywhere or possibly expensive thunks
15:22:22 <jmcarthur> well, it changes my outlook on evaluation order :)
15:22:26 * copumpkin cries
15:22:27 <copumpkin> " Num instance for Lazy ByteStrings"
15:22:30 <Trinitron> How many pages is the Wiki Haskell tutorial if I print it?
15:22:37 <ivanm> copumpkin: yeah, I saw that as well :s
15:22:42 <NEEDMOAR> ivanm: I'm trying to understand evaluation order.
15:22:43 <jmcarthur> copumpkin: o_O
15:22:43 <ivanm> Trinitron: why not just read it online?
15:22:44 <Trinitron> I don't want to cart my laptop around with me.
15:22:50 <ivanm> if you want a paper book then _get_ a paper book
15:22:50 <copumpkin> jmcarthur: cafe :)
15:22:50 <Trinitron> I'm going soon.
15:22:56 <ivanm> (since they're better anyway IMHO)
15:23:14 <Trinitron> Do you recommend any paper books?
15:23:30 <ivanm> Craft of Functional Programming (2nd ed) by Simon Thompson
15:23:30 <Trinitron> Dead-tree variety.
15:23:37 <ivanm> or Haskell School of Expression (forget the author)
15:23:44 <copumpkin> hudak
15:23:45 <ivanm> the haskell homepage has a list of them
15:23:48 <ivanm> copumpkin: that's right
15:23:49 <pokoko222> just read anything while u r noob man
15:23:56 <jmcarthur> so it's like Integer but with variable overflow?
15:23:59 <copumpkin> only later can you become a ninja like pokoko222
15:24:06 <Trinitron> Does Craft  of ... cover haskell or functional languages in general?
15:24:07 <ivanm> there's also graham hutton's book, but it uses symbols rather than actual characters...
15:24:12 <pokoko222> correct, after 50 eulers u will join ninjas
15:24:21 <jmcarthur> no
15:24:21 <copumpkin> pokoko222: so I'm already a ninja?!?
15:24:23 <ivanm> Trinitron: 2nd edition is Haskell
15:24:24 <jmcarthur> stop eulering
15:24:25 <copumpkin> zomg
15:24:27 <Trinitron> Ok.
15:24:30 <pokoko222> copumpkin no u r samurai
15:24:32 <ivanm> pokoko222: what would you know; you didn't seem to read anything
15:24:35 <NEEDMOAR> I find it different to do: try to match the first argument with True and the second argument with False, to match the first argument with True, fail, try with _, match, return a function, and that function then has another pattern matching.
15:24:35 <ickan> what is the definition of a "clause" in haskell?
15:24:36 <copumpkin> pokoko222: !
15:24:49 <ickan> and how does it compare to an expression
15:24:59 <Trinitron> I know over 9000 imperitive languages, yet I only know a bit of Scheme in the functional realm.
15:24:59 <ivanm> NEEDMOAR: I really have no idea what you're saying/asking
15:25:06 <Trinitron> imperative*
15:25:07 <ivanm> Trinitron: /me calls bullshit
15:25:25 <copumpkin> OVER 9000!?!?
15:25:25 <Trinitron> :D
15:25:28 <ivanm> I doubt there are 9000 imperative languages (well, there might be heaps of  one-man languages, but unless you invented them all...)
15:25:30 <ickan> the fact that value 9000 was mentioned makes me suspect it too :P
15:25:43 <ivanm> ickan: in what context?
15:25:45 <pokoko222> wow and i thought i was ninja, 9000?
15:25:47 <jmcarthur> NEEDMOAR: are you sure that what you are proposing is not semantically equivalent to what is actually happening?
15:25:51 <ivanm> ickan: (clauses)
15:25:54 <copumpkin> http://www.youtube.com/watch?v=TBtpyeLxVkI
15:25:58 <copumpkin> (re 9000)
15:26:03 <NEEDMOAR> jmcarthur: I think both are semantically equivalent.
15:26:14 <ickan> ivanm: a single clause... in particualar a lambda expression only allows a single clause
15:26:22 <ivanm> ickan: hmmm...
15:26:25 <ivanm> check the report
15:26:27 <ivanm> @where report
15:26:27 <lambdabot> http://www.haskell.org/onlinereport/
15:26:32 <ickan> good call
15:26:33 <NEEDMOAR> jmcarthur: but operationally they seem to be different to me.
15:26:34 <jmcarthur> NEEDMOAR: so you are only interested in the implementation
15:26:34 <ivanm> @go haskell clause
15:26:34 <lambdabot> Maybe you meant: google googleit do
15:26:35 <jmcarthur> ?
15:26:40 <ivanm> @google haskell clause
15:26:41 <lambdabot> http://www.haskell.org/tutorial/patterns.html
15:26:42 <lambdabot> Title: A Gentle Introduction to Haskell: Patterns
15:26:56 <NEEDMOAR> jmcarthur: not only in the "implementation" but also in the rules that the evaluation order uses.
15:26:56 <jmcarthur> NEEDMOAR: look up the spineless tagless g-machine papers
15:27:13 <jmcarthur> @where stg
15:27:13 <lambdabot> http://citeseer.ist.psu.edu/peytonjones92implementing.html
15:27:18 <jmcarthur> there we go
15:27:32 <jmcarthur> things have changed a bit, but the basic idea is still there
15:27:42 <NEEDMOAR> But it shouldn't be an implementation issue.
15:27:45 <pokoko222> i got 400 lines of code for euler 54 in one day, does not that make u love Haskell even more ? :D
15:27:59 <copumpkin> holy crap
15:28:05 <copumpkin> I hope it wasn't 400 lines of haskell
15:28:10 <pokoko222> c++
15:28:16 <danderson> In STM, can multiple threads readTVar concurrently without retrying, as long as nobody does a writeTVar?
15:28:18 <copumpkin> I did all my euler problems in ghci
15:28:27 <copumpkin> well, almost all
15:28:40 <pokoko222> yeah well i do them now in C++ cause i got exams on it, but will be back with haskell in 2 months
15:28:42 <ivanm> pokoko222: you're typing patterns make me love _proper_ english spelling and grammar even more...
15:28:55 <jmcarthur> i did all my euler problems using unsafeCoerce
15:29:16 <Cale> ivanm: you're?
15:29:21 * copumpkin giggles
15:29:21 <pokoko222> did i mention i debug all day? :D hahaha u blessed haskell souls
15:29:22 <Zao> jmcarthur: unsafeCoerce _|_ :: Euler 23
15:29:29 <ivanm> Cale: whoops ;-)
15:29:31 <copumpkin> ooh, type-level naturals
15:29:32 <danderson> specific use case: I want to share a routing table between all threads which manage traffic. The routing table updates infrequently. Will the traffic threads be able to concurrently walk over the shared routing table with no contention as long as the manager thread doesn't update said table?
15:29:33 <jmcarthur> Zao: it magically worked!
15:29:34 <jcreigh> I did all my euler problems on my full-scale model of the difference engine.
15:29:37 <olsner> unsafeCoerce 42 should answer to everything :P
15:29:48 * ivanm suddenly goes and classifies that as irony and not a typo
15:29:49 <ivanm> :p
15:30:00 <ivanm> olsner: no, it doesn't answer everything
15:30:11 <Cale> Do all the Euler problems by building custom gear assemblies.
15:30:19 <Zao> The proper entity to unsafeCoerce is unsafePerformIO.
15:30:21 <pokoko222> hey Cale is here
15:30:26 <Cale> yep
15:30:26 <ivanm> it answers an infinite number of numeric problems and one non-numeric problem
15:30:34 <pikhq> danderson: Yes, the transaction is only retried if the transaction fails.
15:30:41 <jmcarthur> do the euler problems using configurations of dominos
15:30:47 <pokoko222> ah i still remember your zipWith diagrams, lovely stuff
15:31:00 <pikhq> danderson: When you haven't actually done a writeTVar, you will, of course, not have any failing transactions.
15:31:15 <danderson> fantastic.
15:31:23 <Cale> pokoko222: you might enjoy these: http://cale.yi.org/index.php/Fold_Diagrams
15:31:30 <danderson> that was my intuition, glad to see there aren't any sneaky cases that screw it up.
15:31:33 * copumpkin does all the euler problems at the type level
15:31:41 <pokoko222> i did
15:31:49 <Zao> copumpkin: All fine, until you get a type clash.
15:31:57 <copumpkin> nah
15:31:58 * Zao has nightmares from using the Salsa library.
15:32:12 <danderson> yay for trivial yet efficient shared state.
15:32:13 <pokoko222> i remember asking why are type systems so cool like haskell's one, a litle c++ and i got my answer
15:32:35 <copumpkin> c++ is pretty powerful, typewise, if you use templates
15:32:36 * ivanm got overly excited to see Haskell appearing in the BBC newsfeed... and then saw it was about some soccer player or something :@
15:32:39 <copumpkin> but it's also very ugly
15:33:00 * ivanm wonders why we're discussing an inferior language here
15:33:07 <copumpkin> haskell?
15:33:08 <HugoDaniel> what are iorefs ?
15:33:08 <copumpkin> dunno
15:33:15 <ivanm> @slap copumpkin
15:33:15 * lambdabot activates her slap-o-matic...
15:33:19 <copumpkin> HugoDaniel: mutable variables
15:33:24 <ivanm> evil, evil things...
15:33:26 <HugoDaniel> oh hmm
15:33:34 <olsner> ivanm: because superiority is nothing without inferiors?
15:33:35 <HugoDaniel> i shalt not use them
15:33:41 <ivanm> olsner: heh, true
15:34:59 <HugoDaniel> oh, lambdabot is female
15:35:06 <ivanm> yes
15:35:10 <ivanm> @vixen asl
15:35:10 <lambdabot> 19/f/California
15:35:11 <HugoDaniel> probably the only one on this # :(
15:35:17 <NEEDMOAR> ivanm: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=23363#a23363
15:35:17 <ivanm> no, there's Philippa
15:35:26 <c_wraith> misspiggy, when she's about
15:35:37 <c_wraith> there are others, but a lot of women on IRC don't advertise it
15:35:47 <c_wraith> since it just leads to stupidity
15:35:50 <HugoDaniel> its understandable
15:35:53 <HugoDaniel> yes, indeed
15:36:09 <ivanm> understandable, yes; acceptable, no
15:36:12 <ivanm> (the stupidity)
15:36:25 <ivanm> NEEDMOAR: you mean you want to evaluate "f False undefined"?
15:36:46 <ivanm> NEEDMOAR: I think it's more explanation A
15:36:49 <ivanm> it goes line-by-line
15:37:38 <HugoDaniel> hmm
15:37:45 <HugoDaniel> i was looking at the hpong code
15:37:47 <NEEDMOAR> ivanm: but it tries all the arguments at once (and you don't try the following arguments if one failed)?
15:37:53 <HugoDaniel> and there is a very wicked thing there
15:37:56 <HugoDaniel> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23364#a23364  <- here
15:38:01 <ivanm> NEEDMOAR: no, it does one line at a time one argument at a time
15:38:03 <ivanm> (AFAICT)
15:38:03 <HugoDaniel> can someone explain to me what thats about ?
15:38:08 <ivanm> left to right, top to bottom
15:38:24 <ivanm> same as text in western languages ;-)
15:38:45 <ivanm> HugoDaniel: the deriveAccessors?
15:38:47 <NEEDMOAR> left to right, top to bottom or top to bottom, left to right?
15:38:47 <HugoDaniel> yes
15:38:49 <ivanm> looks like template haskell
15:39:01 <zygoloid> HugoDaniel: that's template haskell, deriving some typeclass for Game presumably
15:39:17 <ivanm> NEEDMOAR: ummm, one line at a time
15:39:24 <HugoDaniel> hmm
15:39:24 <ivanm> (however you comprehend that) ;-)
15:39:38 <ivanm> start at the first line, then each argument at a time
15:39:40 <HugoDaniel> the code imports Data.Accessor
15:39:46 <HugoDaniel> and Data.Accessor.Template
15:39:52 <ivanm> right
15:40:11 <ivanm> it uses TH to let you derive more typeclasses automagically
15:40:42 <HugoDaniel> im reading about that on the hdb page of data.accessor
15:40:57 <NEEDMOAR> ivanm: if the first argument matches, then it creates a function and returns it to be further evaluated (which will have the resting pattern matching in it)? Or the pattern continues with the other arguments?
15:41:12 <ivanm> NEEDMOAR: just continues pattern matching I think
15:41:32 <jmcarthur> NEEDMOAR: semantically the same thing
15:41:51 <NEEDMOAR> jmcarthur: it gives the same value, I think, yes.
15:42:01 <jmcarthur> NEEDMOAR: and evaluates the same thunks
15:42:08 <jmcarthur> NEEDMOAR: it's the same in all practical ways i can think of
15:44:23 <ickan> partial function application scares the mahoozas out of me
15:44:25 <ivanm> implementation issue ;-)
15:44:33 <ivanm> @wn mahooza
15:44:34 <NEEDMOAR> jmcarthur: yep, but I'm still curious about it :-/
15:44:35 <lambdabot> No match for "mahooza".
15:44:42 <jmcarthur> i do think lazy partial evaluation would be awesome from an optimizatiosn standpoint
15:44:49 <jmcarthur> *optimization
15:45:03 <jmcarthur> NEEDMOAR: then read the STG paper i linked to
15:45:19 <jmcarthur> or read the Core output of your haskell programs
15:45:32 <jmcarthur> s/or/and/ perhaps
15:46:23 <NEEDMOAR> jmcarthur: the idea of matching all arguments of the patterns at once sounded me a bit "contradictorial" with currification.
15:46:43 <NEEDMOAR> It was like you were looking all the arguments at once, instead of returning functions in the middle.
15:46:48 <jmcarthur> NEEDMOAR: if it has the same result then i don't see it as contradictory
15:46:59 <jmcarthur> you are returning functions "in the middle"
15:47:02 <jmcarthur> semantically
15:47:19 <jmcarthur> which you can pass around at will
15:49:08 <NEEDMOAR> Yeah, but doing the pattern matching over all the arguments at once, it's like you choose the rule it fits all the arguments. You don't create (f False) ever.
15:50:21 <jmcarthur> sure you do, at the haskell level
15:50:27 <NEEDMOAR> You don't create (f False), and then apply it to undefined. You just take False and undefined, and try to match both arguments at once.
15:50:30 <jmcarthur> it doesn't matter at all how the implementation works if it does what you intend
15:50:50 <jmcarthur> and heck, sometimes it probably works that way
15:50:56 <jmcarthur> just read the STG paper and read some Core
15:51:03 <jmcarthur> like i've been saying
15:51:05 <NEEDMOAR> Haha, ok, ok.
15:51:08 <NEEDMOAR> Thanks.
15:51:08 <jmcarthur> ;)
15:51:47 <Alpounet> Cale, ping ?
15:55:10 <Trinitron> What's the shortest book/tutorial on haskell?
15:55:35 <Cale> hello
15:55:35 <sinelaw> write functions
15:55:35 <lambdabot> sinelaw: You have 1 new message. '/msg lambdabot @messages' to read it.
15:55:39 <ivanm> if it's short, it's no good
15:55:43 <sinelaw> Trinitron there it was.
15:55:50 <ivanm> sinelaw: heh
15:56:22 <sinelaw> copumpkin thanks i'm also going to need usb for my project so it all comes together :)
15:56:47 <Cale> Trinitron: you might like to start with "Learn You A Haskell"
15:56:51 <Cale> @where lyah
15:56:51 <lambdabot> http://www.learnyouahaskell.com/
15:57:13 <Cale> For a more in-depth view of how to use the language for practical tasks, you might try Real World Haskell
15:57:16 <Cale> @where rwh
15:57:16 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
15:58:37 <Cale> http://haskell.org/tutorial/ is short, but the name, "A Gentle Introduction to Haskell 98" is a lie, it's not really very gentle at all.
15:58:52 <copumpkin> has anyone implemented shor's algorithm in luqui's quantum-arrow?
15:59:03 <Cale> (Gentler than reading the Report, perhaps)
15:59:30 <Alpounet> Cale, what did you use to generate your dirichlet function animation ?
15:59:42 <Trinitron> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23365#a23365
15:59:44 <ivanm> Cale: well, yes, but the report isn't a tutorial last I checked :p
16:00:09 <ivanm> Trinitron: and yup, that's because you're probably doing it wrong ;-)
16:00:33 <Cale> Alpounet: Mathematica
16:00:35 <ivanm> you may want to force the recursive calculations of thousand (x - 1)
16:00:40 <Alpounet> ok, thanks
16:00:42 <ivanm> no, wait, I know what you're doing
16:00:50 <ivanm> Trinitron: "thousand x - 1" == (thousand x) - 1
16:00:56 <ivanm> so you're doing an infinite loop!
16:01:03 <ivanm> Trinitron: thousand (x - 1) is what you want
16:01:07 <Trinitron> ohhh
16:01:09 <Trinitron> Thanks
16:01:21 <ivanm> that's an easy mistake to make; don't worry about it
16:01:37 <Cale> Yeah, the most important thing to remember about precedence in Haskell is that function application binds tighter than any infix operator
16:01:56 <Trinitron> Ahh.
16:01:57 <Trinitron> I see.
16:02:03 <Trinitron> Arigatou.
16:04:29 <HugoDaniel> :)
16:04:35 <HugoDaniel> i always wondered about that
16:04:51 <Trinitron> Yay, my first Haskell program.
16:04:55 <Trinitron> :D
16:05:10 <Cale> Trinitron: どう致しまして
16:05:40 <Trinitron> 很好
16:05:42 <ivanm> when did this turn into #haskell-jp ? :p
16:05:53 <Trinitron> ii datta
16:06:02 <EvanCarroll> OHHH SUBTLE HINTS..
16:06:06 <c_wraith> amusingly, I don't know the kanji Cale used, but I can still read it just fine.  yay for traditional phrase exchanges. :)
16:06:21 <Trinitron> Is wasn't Kanji...
16:06:31 <Trinitron> It was Hiragana.
16:06:32 <c_wraith> there is one kanji in the middle
16:06:45 <c_wraith> ita (or iita?)
16:06:47 <Trinitron> oh well my client shows that as a blank space.
16:06:52 <copumpkin> :o
16:06:55 <JoshTriplett> Does Eager Haskell still exist in any usable form?
16:06:56 <copumpkin> failclient
16:06:56 <Trinitron> I'm using fixedsys
16:06:59 <Trinitron> font
16:07:00 <copumpkin> JoshTriplett: I hope not
16:07:06 <JoshTriplett> copumpkin: I rather hoped so. :)
16:07:13 <copumpkin> :P
16:07:22 <Trinitron> Only has ASCII chars
16:07:25 <JoshTriplett> copumpkin: I'd ask "why do you hope not", but that would probably kick off a flame. :)
16:07:27 <Trinitron> no unicode for me.
16:07:32 <JoshTriplett> copumpkin: I just wondered if I could find and try it somewhere.
16:07:50 <Trinitron> But somehow it showed the Hiragana, but not the Kanji.
16:07:51 <Trinitron> Meh.
16:07:56 <mauke> http://www.fixedsysexcelsior.com/
16:08:18 <ivanm> JoshTriplett: dammit, I wanted to ask him why he hopes not but now if I do then apparently I'll start a flame war
16:08:20 <ivanm> thanks a lot!
16:08:22 <Trinitron> Fixedsys Excelsior 2.00 11
16:08:26 <Trinitron> That's my font
16:08:39 <JoshTriplett> Trinitron: DejaVu and FreeFont both work nicely.
16:08:48 <Trinitron> meh, I like this hacker font
16:08:49 <Trinitron> :F
16:09:37 <Trinitron> I used to use mIRC a lot, now I use X-Chat.
16:09:43 <Trinitron> I'm used to Fixedsys.
16:10:33 <Trinitron> Yuck, imperative seems so stupid now that I've wrote my first haskell program.
16:10:40 <lament> yuck.
16:10:42 <Trinitron> Like a waste of time and energy.
16:10:50 <Trinitron> So many lines, and verbose.
16:10:51 <Cale> I use DejaVu Sans Mono for English text, and FreeType splices in bits of other fonts for additional unicode coverage. My Japanese preferred font is MS Gothic, but there are a couple rare hiragana which show up in Meiryo
16:10:56 <Trinitron> And buggy.
16:11:10 <lament> Trinitron: you just wrote your first haskell program. Chances are you have no clue what you're talking about.
16:11:35 <Trinitron> Yeah, true, I've been reading people's opinions about functional programming on the web.
16:11:54 <Trinitron> But I see solutions for problem 1 on PE that are 30 lines long
16:12:00 <Trinitron> my one in haskell is 2
16:12:03 <Trinitron> :D
16:13:41 <nagnatron> I love the guys who do PE in assembler.
16:17:08 <Trinitron> Assembler is imperative, I need to practice functional.
16:17:27 <Trinitron> I've only ever programmed imperative before. :(
16:17:29 <nagnatron> I know. Just sayin'.
16:17:49 <Trinitron> My University started me off in Java. *shudders*
16:18:01 <Trinitron> university*
16:18:54 <lament> Trinitron: it's too late for you now, learning java has permanently damaged your brain
16:19:10 <Trinitron> Oh dear.
16:19:22 <Trinitron> But I've taken maths courses.
16:19:40 <Trinitron> I'll just think about the maths, and not horrible, horrible Java.
16:20:02 <lament> linear programming and intro to statistics?
16:20:15 <c_wraith> Hmm.  Can I blame my problems on learning java, even if they're not programming-related?
16:20:30 <aavogt> @faq can haskell let you do that?
16:20:30 <lambdabot> The answer is: Yes! Haskell can do that.
16:20:39 <Trinitron> Err, Differential Calculus, Linear Algebra, Discrete maths and integral calculus and modelling.
16:20:47 * c_wraith starts making a list of everything java's responsible for.
16:21:38 * ddarius will never understand fragmenting calculus into differential and integral calculus.
16:22:10 <theorbtwo> c_wraith: Clearly if you hadn't started programming java, you wouldn't have started drinking, and then you wouldn't have run over that poor infant and the nun that was pushing his pushchair.
16:23:37 <pikhq> ddarius: Because people like forgetting the fundamental theorem?
16:23:59 <c_wraith> I was thinking more about The Incident Of Which I Shall Not Be More Specific.  It's a long name, but reasonably descriptive. :)
16:24:24 <avenge`> p
16:24:34 <ivanm> c_wraith: well, one good thing I can think of: isn't it the first "major" language that had GC?
16:25:17 * ddarius splutters.
16:25:29 <c_wraith> Uh.  For some definition of major, probably.  (Ignore all the history of FP, etc)
16:26:02 <ivanm> c_wraith: as in that corporations, etc. routinely use
16:26:05 <c_wraith> that definition is that the major languages are: assembly, C, C++, Fortran, and Java.  :)
16:26:05 <theorbtwo> Ignore dynamic languages too.
16:26:06 <ddarius> Ignore Smalltalk, APL, Lisp, ...
16:26:13 <theorbtwo> Perl.
16:26:36 <theorbtwo> Hm.  I'm honestly not sure if the other ones predate java or not.
16:26:45 <companion_cube> hey, lisp is not so bad
16:26:45 <c_wraith> java is quite recent.
16:26:48 <HugoDaniel> has anyone tried out leksah ?
16:26:54 <HugoDaniel> it seems v.0.8 is out
16:27:12 <jmcarthur> Trinitron: "Assembler is imperative"  ... not necessarily, but true for most CPUs
16:27:18 <pikhq> Ignore Lisp, Smalltalk, APL, Perl, Tcl, *Boehm GC*, etc.
16:27:40 <companion_cube> jmcarthur: there exist functional architectures ??
16:27:42 <companion_cube> +s
16:28:02 <jmcarthur> companion_cube: ever heard of a GPU?  (but that's stretching it because i think the assembly is still imperative in style)
16:28:20 <ivanm> ddarius, theorbtwo: I'm not talking about order of when they were created; I'm talking about ones that are used routinely in industry, etc.
16:28:24 <jmcarthur> companion_cube: there's also some hardware out there for executing a compiled form of haskell
16:28:29 <Cale> companion_cube: Yeah, if you're going to do graph reduction, having a lot higher memory bandwidth is desirable.
16:28:29 <companion_cube> GPU just have a smaller set of instructions, but it remains imperative
16:28:30 <aavogt> if the hardware has circuits to interpret a language, does that make that language assembly?
16:28:31 <jmcarthur> i forget the name of that project
16:28:49 <Cale> companion_cube: I think jmcarthur is thinking of the Reduceron
16:28:51 <pikhq> ivanm: Perl, though.
16:29:03 <pikhq> I'm pretty sure that saw common use before Java.
16:29:03 <ivanm> is perl used for large scale projects?
16:29:12 <companion_cube> a hardware specialized in interpreting haskell would be quite intersting :D
16:29:12 <ivanm> I thought it was mainly a "glue" or scripting language
16:29:19 <pikhq> Scripting language.
16:29:22 <Cale> It's really cool, an FPGA implementation of graph reduction for use with Haskell (and could be used with other programming languages)
16:29:24 <theorbtwo> ivanm: It gets used for a lot of large projects.
16:29:24 <companion_cube> but imho it is doomed, like old lisp-machines
16:29:38 <Cale> companion_cube: FPGAs make it reasonable to do.
16:29:46 <theorbtwo> Most publicly, a good many web sites.
16:30:08 <ddarius> ivanm: All of those were significantly used at one point or another.
16:30:09 <jmcarthur> i think GPUs (and performance critical hardware in general) is going to gravitate toward functional paradigms
16:30:16 <ivanm> ddarius: *shrug* fine then
16:30:18 <jmcarthur> s/is/are/
16:30:24 <pikhq> Yeah, it was one of the earlier languages for doing CGI stuff.
16:30:41 <pikhq> PHP replaced it, and I don't think that was a positive change.
16:30:51 <theorbtwo> It's still quite good at it, but it's no longer sexy.
16:30:57 <companion_cube> jmcarthur: most people don't like FP
16:31:15 <pikhq> Perl is a pretty heavy hack, sure, but it at least *embraces* that.
16:31:20 <CalJohn> http://haskell.org/gtk2hs/archives/2010/01/18/compiling-with-ghc-612/ <-- does this imply that i cannot compile gtk2hs-10.1 on ghc 6.12?
16:31:31 <jmcarthur> companion_cube: most people have never used it
16:31:44 <companion_cube> jmcarthur: yes, but they still are afraid of it
16:31:55 <theorbtwo> The wonderful thing about perl, I think, is that it embraces everything these days -- including not being a horrible hack.
16:31:57 <jmcarthur> companion_cube: they use it without realizing sometimes
16:32:01 <companion_cube> most imperative programmers are afraid of FP
16:32:02 <pikhq> companion_cube: That's because a lot of people think it's massively difficult.
16:32:11 <companion_cube> yes
16:32:16 * shepheb wonders what else can be described "Liked by those who have tried it, feared by those who have not."
16:32:28 <theorbtwo> shepheb: Perl?
16:32:29 <pikhq> theorbtwo: Hahah. Yes, Perl is nearly everything. That's both the scariest feature about it and its most endearing feature.
16:32:38 <companion_cube> but this is a serious obstacle in the way to functional GPU or equivalent
16:32:42 <shepheb> theorbtwo: various sexual deviances?
16:32:45 * ddarius would guess that most programmers don't know that there is much more than Java + C or so.
16:32:46 <jmcarthur> i've used perl a fair bit and i still fear it
16:32:52 <shepheb> skydiving?
16:33:06 <pikhq> jmcarthur: As you should. There is much to fear in it.
16:33:13 <chrisdone> I just had a flashback to to before I started to learn haskell
16:33:13 <ddarius> theorbtwo: I've "tried" Perl three times and never liked it, nor have I ever feared it.
16:33:19 <chrisdone> haskell is scary
16:33:25 <chrisdone> remember that!
16:33:28 <theorbtwo> I think almost everybody pretty quickly gravitates toward a paradigm, a favoried bit of the map.
16:33:31 <jmcarthur> companion_cube: there is no obstacle for functional hardware. we would still have compilers from imperative languages to functional low-level code *shudder*
16:33:57 <theorbtwo> There's an awful lot of evidence of that around here toward imperitive languages.
16:34:04 <theorbtwo> ...like that "shudder".
16:34:30 <jmcarthur> theorbtwo: i have a favorite, i won't deny, but i don't feel that it is irrational
16:34:42 <jmcarthur> theorbtwo: i came to haskell with many years of background in imperative languages
16:34:46 <companion_cube> compiling imperative to functional seems quite difficult to me
16:35:05 <copumpkin> depends what you mean by functional
16:35:06 <ddarius> companion_cube: That's what many modern compilers do.
16:35:07 <copumpkin> SSA is commonly used
16:35:13 <jmcarthur> companion_cube: most optimizating compilers already do it when they convert to SSA
16:35:30 <pikhq> companion_cube: Not really. It's a difficult to do the opposite, but imperative to functional is common.
16:36:13 <jmcarthur> heh, it harder to write efficient imperative code than efficient functional code, by implication ;)
16:36:50 <companion_cube> i didn't know that :)
16:36:51 <pikhq> jmcarthur: Well, it's certainly harder to do meaningful transformations on them. :)
16:36:57 <jmcarthur> yes
16:37:15 <theorbtwo> jmcarthur: Of course.  Functional programming forces you to be explicit about every cross-linkage; nothing is implicit.
16:37:43 <theorbtwo> That gives compilers the ability to redorder things in time, to whatever sequence it thinks best.
16:37:56 <theorbtwo> OTOH, it increases the semantic load to the programmer.
16:37:58 <aavogt> it can be just as implicit using say State monads
16:38:14 <jmcarthur> theorbtwo: that could be restated to look like a negative for imperative languages
16:38:21 <theorbtwo> aavogt: But doesn't that make your code effectively imperative?
16:38:32 <theorbtwo> jmcarthur: Of course it could be.
16:38:46 <theorbtwo> I'm not saying that both viewpoints are valid.
16:38:53 <aavogt> theorbtwo: well parts of it
16:39:39 <HugoDaniel> i dont understand why people use processing
16:39:53 <theorbtwo> HugoDaniel: ?
16:40:39 <freedrull> yesss my binary search tree works!!! \o/
16:42:29 <freedrull> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23366#a23367 please criticize, flame this code if you're bored
16:42:33 <c_wraith> good job, freedrull. :)
16:43:26 <theorbtwo> Hm.  I guess part of the problem I see with haskell is that most of my haskell code has been inside a very imperitive-ish monad of one sort or another.
16:43:37 <theorbtwo> Either I'm writing IO code or I'm writing Parsec code.
16:43:46 <ivanm> freedrull: since you insist:
16:43:47 <theorbtwo> Possibly I should find a better project.
16:44:04 <ivanm> 1) if you derive Show, you should also derive Read (also split your data definition across multiple lines)
16:44:22 <ivanm> and why not derive Ord, etc. as well whilst you're at it?
16:44:39 <ivanm> 2) the | in lines 23 and 24 should line up
16:44:59 <ivanm> same for 31/32, 34/35 and 38/39
16:45:21 <ivanm> 3) the parens around (Leaf) aren't needed
16:45:28 <ivanm> freedrull: had enough? :p
16:46:43 <freedrull> ivanm: pretty much, thanks
16:47:07 <gwern> thank goodness for music. de-haskell98ing stuff is pretty tedious
16:47:21 <ivanm> hmmm?
16:47:49 <theorbtwo> gwern: Removing syntatic extensions, you mean?  Er, can I ask why?
16:47:59 <blackh> theorbtwo: It takes a little while for the osmosis to happen. I think it's a good idea to some really pure code. One thing I think is worth doing is to write a game that works as a function from input to output, with a completely pure core.
16:48:00 <gwern> theorbtwo: no, I mean modules
16:49:57 <blackh> theorbtwo: Also it's really great when you understand that monads are really thinly veiled co-routines.
16:50:09 <aavogt> what's wrong with  "import Monad; import List", gwern?
16:50:09 <blackh> ...so they're actually completely pure
16:51:05 <theorbtwo> Hm.  I see that they are thinly veiled calls to functions defined by the monad in use... but I'm not sure that I see they are coroutines.
16:51:14 <theorbtwo> ...possibly because I haven't worked with coroutines at all.
16:51:57 <aavogt> so comonads should be interpreted as cocoroutines?
16:52:12 <pokoko222> hi?
16:52:22 <aavogt> hello pokoko222
16:52:26 <pokoko222> hmm wierd i can send here but not at c++, sorry for testing
16:52:32 <gwern> aavogt: they are inconsistent, get mixed with newer module names, and mask dependencies on packages like directory/old-time/old-locale/process
16:52:59 <blackh> Well, they work like co-routines - they essentially take you out of 'pure land' into a region controlled by however the monad is defined, then back into 'pure land' again.  It's logically equivalent to passing a continuation - which consists of everything after the next >>= or >>
16:53:53 <aavogt> well just as devil's advocate, I think the distinction between Control.* and Data.* is pretty blurry sometimes
16:54:10 <blackh> You can write a monad that works exactly like a co-routine (e.g. a generator in Python).
16:54:42 <gwern> aavogt: a blurry distinction is still a distinction
16:54:44 <gwern> @hoogle Word
16:54:44 <lambdabot> module Data.Word
16:54:45 <lambdabot> Data.Word data Word
16:54:45 <lambdabot> Data.Word data Word16
16:55:03 <aavogt> @hoogle Monoid
16:55:03 <lambdabot> module Data.Monoid
16:55:04 <lambdabot> Data.Monoid class Monoid a
16:55:42 <theorbtwo> Hm.  Yes, I think I see you a bit more clearly now.
16:56:01 <ivanm> why? did you clean your glasses or something? :p
16:56:06 <copumpkin> are there standard library bindings to file operations like copy and move?
16:56:08 <blackh> It's definitely true that Haskell isn't all about monads, but it's also true that monads are _very_ useful.
16:56:30 <copumpkin> pokoko222: you're probably banned or not logged in
16:56:49 <pokoko222> nah i am ok now, some freenode problems
16:57:14 <aavogt> @hoogle Directory
16:57:15 <lambdabot> module System.Directory
16:57:15 <lambdabot> package directory
16:57:15 <lambdabot> System.Directory createDirectory :: FilePath -> IO ()
16:57:36 <copumpkin> aavogt: perfect, thanks
16:57:43 <aavogt> copumpkin: but directory has painfully long identifiers
16:57:49 <copumpkin> I'll survive
16:57:51 <copumpkin> just writing a quick script
16:58:07 <gwern> quick and dirty. djikstra would not like it.
16:58:09 <aavogt> yeah, it won't be so quick with that library ;)
16:58:59 <aavogt> somebody needs to upload to hackage a version that uses identifiers like cp and mv
16:59:12 <copumpkin> I'll live :P
16:59:27 <ivanm> IIRC, dons started making such a library...
16:59:42 <copumpkin> bam, done :P
16:59:45 <copumpkin> thanks aavogt :)
16:59:59 <aavogt> well it doesn't take very long, it's probably only 20 functions
17:00:04 <aavogt> no problem
17:00:21 <aavogt> the bigger problem is deciding what to call the modules and package
17:00:37 <ivanm> aavogt: it was duplicating all the command line flags of coreutils' versions that was taking all the time from memory
17:00:56 <theorbtwo> System.Directory.ShLike ?
17:01:16 <gwern> @hoogle Array
17:01:16 <lambdabot> module Data.Array
17:01:16 <lambdabot> module Foreign.Marshal.Array
17:01:16 <lambdabot> package array
17:01:34 <aavogt> > let (../) = "../" in ../
17:01:35 <lambdabot>   <no location info>: parse error on input `../'
17:02:12 <gwern> @hoogle Ix
17:02:13 <lambdabot> module Data.Ix
17:02:13 <lambdabot> Data.Ix class Ord a => Ix a
17:02:13 <lambdabot> Data.Array.IArray ixmap :: (IArray a e, Ix i, Ix j) => (i, i) -> (i -> j) -> a j e -> a i e
17:02:14 <ivanm> aavogt: infix functions have to have at least two args
17:02:15 <ivanm> ;-)
17:02:19 <ivanm> @src Ix
17:02:20 <lambdabot> class (Ord a) => Ix a where
17:02:20 <lambdabot>     range           :: (a,a) -> [a]
17:02:20 <lambdabot>     index           :: (a,a) -> a -> Int
17:02:20 <lambdabot>     inRange         :: (a,a) -> a -> Bool
17:02:20 <lambdabot>     rangeSize       :: (a,a) -> Int
17:02:27 <jimfear> Does it ever make sense to have an IORef containing an IArray? Or might I as well use an MArray?
17:04:03 <aavogt> > let (../) = \_ _ -> "../" in 1 ../ 2
17:04:04 <lambdabot>   "../"
17:04:15 <aavogt> > let (../) = \_ -> "../" in 1 ../
17:04:16 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
17:04:29 <kw317> can someone help me decipher the second part of this sentence: "I had to build  the darcs version of gtk2hs, and compiler data accessor-template with the -ftemplate_2_4 flag"
17:04:41 <kw317> what's this accessor-template?
17:05:03 <aavogt> it is a package on hackage that won't build with ghc-6.12 without that flag
17:05:35 <aavogt>  as in   cabal install data-accessor-template -ftemplate_2_4
17:05:59 <kw317> aavogt: thanks
17:06:44 <aavogt> it's a packaging bug (or maybe cabal's fault?) that it otherwise tries to install template haskell 2.3 for ghc-6.12
17:07:06 <ivanm> aavogt: oh? pretty sure I built it with 6.12
17:07:18 <ivanm> (on my laptop at home, so I can't check and verify that)
17:07:21 <gwern> is everyone out partying or something? I've sent out >18 emails tonight and gotten only one reply ~-~
17:07:33 <ivanm> gwern: obviously didn't send one to me...
17:07:34 <ivanm> @time
17:07:50 <ivanm> I don't think the uni would appreciate me partying in the middle of the day when they're paying me to work...
17:07:55 <ivanm> @bot
17:07:55 <lambdabot> :)
17:08:09 <ivanm> hmmm, this client stops CTCP requests by the looks of things...
17:08:19 <ivanm> s/work/study/
17:09:45 <aavogt> ivanm: well I seem to have uninstalled it, but here's what I get: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23368#a23368
17:10:04 <ivanm> :o
17:10:27 <ivanm> oh, wait, IIRC I needed it for criterion's chart support, but gtk2hs doesn't work with 6.12 so I uninstalled all of them
17:10:47 <aavogt> but you can add  --constraint="template-haskell >= 2.4" (or also to ~/.cabal/config), and then it does the right thing
17:10:48 <ivanm> so maybe I haven't built it on 6.12...
17:10:54 <tommd> Is Tony Morris an IRC regular under a nick I don't know?
17:11:06 <aavogt> preflex: seen dobblego
17:11:06 <preflex>  dobblego was last seen on #haskell 15 hours, 38 minutes and 3 seconds ago, saying: DList
17:11:10 <ivanm> tommd: dibblego aka dobblego
17:11:16 <ivanm> sometimes even dabblego
17:11:17 <tommd> Oh - that's Tony?  Thanks
17:11:20 <ivanm> preflex: seen dibblego
17:11:21 <preflex>  dibblego was last seen on #haskell 6 days, 18 hours, 48 minutes and 41 seconds ago, saying: where boots?
17:11:41 <ivanm> tommd: he was in singapore for the weekend though, so he might not be around atm
17:12:07 <tommd> Damn, then I have no choice but to stop all work, fly to his house and ask questions about his library.
17:12:14 <ivanm> heh
17:12:16 <ivanm> which one?
17:12:29 <gwern> he has that many houses? o.0
17:12:49 <ivanm> which _library_
17:12:58 <kw317> LOL
17:15:06 <gwern> anyone know where nobench patches go/
17:15:30 <tommd> ivanm: OSM and GPX
17:15:37 <ivanm> ahhhhh
17:15:42 <aavogt> isn't there a maintainer to bother?
17:15:48 <tommd> I'm thinking of hacking up my own version of TangoGPX (but with a few twists and in Haskell)
17:15:59 <gwern> aavogt: nobench isn't a package so there's no cabal to look at
17:16:11 <gwern> eh. I'll send to to malcolm wallace
17:16:13 <tommd> aavogt: Sure, but IRC and real-time-bothering is more my style.
17:16:27 <tommd> Oh, that wasn't directed at me.
17:19:12 <dobblego> hello
17:19:27 <ivanm> hey dobblego
17:19:32 <ivanm> surgery went OK?
17:19:38 <tommd> dobblego: Hello!
17:19:43 <dobblego> the surgery itself is fine; what it revealed is not
17:19:46 <dobblego> hello tommd
17:19:53 <gwern> @hoogle inTToBool
17:19:54 <lambdabot> No results found
17:19:59 <gwern> @hoogle intToBool
17:20:00 <lambdabot> No results found
17:20:02 <ivanm> dobblego: even more problems? :(
17:20:14 <dobblego> ivanm, yes, now we all know why I was screaming so loud
17:20:19 <tommd> dobblego: Sorry to hear the bad news.  Is now not a good time to ask about OSM?
17:20:21 <ivanm> heh
17:20:29 <dobblego> tommd, sure, ask away
17:20:42 * gwern didn't know dobblego was screaming at all
17:20:53 <dobblego> gwern, google "Tony Morris suicide"
17:21:11 <tommd> dobblego: First: Is there some sort of document beyond haddock?  There are enough modules that I could use an overview of what the OSM module is even intended to cover.
17:21:13 * gwern sees dead people???!
17:21:25 <ivanm> gwern: almost dead people
17:21:33 <dobblego> tommd, I have some example usages as well
17:21:40 <dobblego> tommd, otherwise, there is no more documentation
17:23:15 <tommd> dobblego: In the tarball I assume?  I'll look at those.
17:23:21 * gwern once thought about suicide. began making a list of all the stuff I had to do first to leave with a light conscience, and after all, said fuck it
17:23:38 <gwern> *a while
17:24:07 <dobblego> tommd, I don't think I included them in the tarball, but at least, they are in the source repo http://code.google.com/p/geo-osm/source/browse/#hg/Data/Geo/OSM/Example
17:26:28 <kw317> did anyone ever build gtk2hs with 6.13?
17:26:48 <aavogt> it works with 6.12
17:26:52 <ivanm> kw317: the released version doesn't even work with 6.12 (though the repo does)
17:27:43 <kw317> I'm trying to build the repo version, but I keep hitting the  Failed to load interface for `System.Glib.UTFString' problem
17:30:40 <tommd> kw317: Not sure about that problem, but be sure you use --disable-split-objs on ./configure
17:31:53 <kw317> tommd: that doesn't make any difference I'm affraid
17:32:33 <tommd> It will once you get pasted that problem.
17:42:57 <gwern> new reason to dislike haskell98: it lets people like jon meachem casually copy-paste the definitions of repeatM_/repeatM
17:43:10 <ivanm> hmmm?
17:43:33 <ivanm> you mean since it wasn't defined in haskell98 and they're using haskell98 explicitly they have to redefine it themselves?
17:43:41 <gwern> one of his drift modules does just that; when I swapped 'import Control.Monad' for import Monad, it broke
17:44:01 <ivanm> *shudder*
17:54:09 <jmcarthur> i wish haddock documentation showed the fixity of operators
17:58:07 <aavogt> I wish haddock did a lot of things
18:03:02 <sm> gwern: hey thanks for the patch
18:03:31 <sm> pushing.. can I ask you to sign CONTRIBUTORS too ?
18:07:12 <gwern> sm: it's not much of a contribution
18:07:32 <Tomas> what does it mean when ghci puts an m before a type, like inferred type 'm a'?
18:07:41 <gwern> Tomas: monad
18:07:44 <gwern> traditionally
18:08:07 <Tomas> ok, thanks
18:08:11 <Alpounet> Tomas, there probably is "Monad m =>" before the type, too
18:08:12 <ivanm> @type return
18:08:12 <companion_cube> btw, what are existential types intended to do ?
18:08:13 <tensorpudding> it generally refers to a datatype or class
18:08:13 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
18:08:29 <sm> sure, but I'm hoping it will lead to more.. I like to make sure folks are aware/ok with the license early on
18:08:39 <tensorpudding> but m is usually reserved for if that is an instance of Monad
18:08:52 <tensorpudding> similarly, f is used for instances of Functor
18:08:57 <gwern> sm: I'm probably not ok, but it's more important that as many haskell98 deps be removed than to argue over licenses
18:08:57 <tensorpudding> @type fmap
18:08:58 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:10:00 <sm> if you don't want to sign CONTRIBUTORS as it is right now, no problem. I'll have to bring it up again next time
18:10:14 <sm> thanks again for the patch, I'd love to see more
18:10:23 <gwern> sm: I also de-haskell98'd hinvaders but you took down that repo
18:11:04 * hackagebot c10k 0.1.0 - C10k server  http://hackage.haskell.org/package/c10k-0.1.0 (KazuYamamoto)
18:11:10 * sm nominates gwern as new hinvaders maintainer
18:11:52 <ivanm> gwern: any particular reason for you going on your anti-haskell98 spree?
18:12:00 <sm> haskell.. the awesome retro games programming languages
18:12:01 <gwern> ivanm: I have the energy right now
18:12:15 <aavogt> because it will soon be obsolete
18:12:23 <gwern> plus, the list takes an unsightly amount of space in my TODO page, and causes mental anguish
18:12:49 <gwern> 'Network library to handle OVER 10,000 CONNECTIONS A SECOND!!!!'
18:12:53 * gwern paraphrases
18:12:59 <copumpkin> OVER 9000!
18:13:17 <gwern> impossible!
18:13:38 <copumpkin> I think it'll be a lot more successful if it's advertised that way
18:13:43 <copumpkin> even if it does get more than 10k
18:14:44 <gwern> > let x = [54,69,42,54,44,62,44,35,85,50,44,42,57,65,51,56,42,53,40,47,45,51,57,57,56,76,66,60,46,52,59,48,28,45,43,47,50,40,57,46,33,19,43,58,36,52,44,64]  in sum x / length x
18:14:45 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
18:14:45 <lambdabot>    arising from a use o...
18:14:47 <gwern> > let x = [55,76,56,55,44,41,44,45,65,70,46,65,46,52,68,52,57,50,64,43,41,50,69,44,47,63,34,57]  in sum x / length x
18:14:48 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
18:14:48 <lambdabot>    arising from a use o...
18:15:06 <gwern> hm.
18:15:12 <gwern> > 10000 / 67
18:15:13 <lambdabot>   149.2537313432836
18:15:29 <gwern> :t sum [1,2,3]
18:15:30 <lambdabot> forall t. (Num t) => t
18:15:34 <gwern> :t length [1,2,3]
18:15:35 <lambdabot> Int
18:15:38 <gwern> :t (/)
18:15:39 <lambdabot> forall a. (Fractional a) => a -> a -> a
18:16:08 <gwern> @hoogle Int -> Int -> Double
18:16:08 <lambdabot> Data.Graph.Inductive.Query.SP spLength :: (Graph gr, Real b) => Node -> Node -> gr a b -> b
18:16:08 <lambdabot> Data.Graph.Inductive.Query.MaxFlow maxFlow :: (DynGraph gr, Num b, Ord b) => gr a b -> Node -> Node -> b
18:16:08 <lambdabot> Data.Data gmapQi :: Data a => Int -> (d -> u) -> a -> u
18:16:11 <gwern> @hoogle Int -> Int -> Float
18:16:11 <lambdabot> Data.Graph.Inductive.Query.SP spLength :: (Graph gr, Real b) => Node -> Node -> gr a b -> b
18:16:11 <lambdabot> Data.Graph.Inductive.Query.MaxFlow maxFlow :: (DynGraph gr, Num b, Ord b) => gr a b -> Node -> Node -> b
18:16:11 <lambdabot> Data.Data gmapQi :: Data a => Int -> (d -> u) -> a -> u
18:16:19 <gwern> @hoogle div
18:16:19 <lambdabot> Prelude div :: Integral a => a -> a -> a
18:16:19 <lambdabot> Data.Fixed div' :: (Real a, Integral b) => a -> a -> b
18:16:19 <lambdabot> Control.Exception DivideByZero :: ArithException
18:16:29 <gwern> > let x = [55,76,56,55,44,41,44,45,65,70,46,65,46,52,68,52,57,50,64,43,41,50,69,44,47,63,34,57]  in sum x `div` length x
18:16:30 <lambdabot>   53
18:16:47 <gwern> > let x = [54,69,42,54,44,62,44,35,85,50,44,42,57,65,51,56,42,53,40,47,45,51,57,57,56,76,66,60,46,52,59,48,28,45,43,47,50,40,57,46,33,19,43,58,36,52,44,64]  in sum x `div` length x
18:16:48 <lambdabot>   50
18:17:16 <gwern> sort [10, 8, 15]
18:17:23 <gwern> > sort [10, 8, 15]
18:17:24 <lambdabot>   [8,10,15]
18:18:04 <ivanm> gwern: :o you couldn't sort that list by hand? :p
18:18:14 <gwern> ivanm: wanted to make sure it was ascending order
18:18:21 <ivanm> ahhh
18:18:25 <gwern> > let x = [54,69,42,54,44,62,44,35,85,50,44,42,57,65,51,56,42,53,40,47,45,51,57,57,56,76,66,60,46,52,59,48,28,45,43,47,50,40,57,46,33,19,43,58,36,52,44,64] in take (length x `div 5) x
18:18:26 <lambdabot>   <no location info>: parse error on input `5'
18:18:34 * ivanm introduces gwern to the magic that is /msg lambdabot
18:18:44 <copumpkin> he isn't a fan of that
18:18:47 <gwern> > let x = [54,69,42,54,44,62,44,35,85,50,44,42,57,65,51,56,42,53,40,47,45,51,57,57,56,76,66,60,46,52,59,48,28,45,43,47,50,40,57,46,33,19,43,58,36,52,44,64] in take (length x `div` 5) x
18:18:48 <lambdabot>   [54,69,42,54,44,62,44,35,85]
18:18:49 <copumpkin> he's made it quite clear
18:18:56 <copumpkin> all 600 people need to know
18:19:00 <ivanm> copumpkin: isn't he?
18:19:08 <gwern> copumpkin: don't you realize? you are all my dreams
18:19:12 <copumpkin> :)
18:19:20 <copumpkin> gwern: don't worry, I dream about you too ;)
18:19:29 <gwern> when I'm not here, you guys don't exist. you think you would be grateful for the extra time, but no...
18:19:53 <ivanm> @slap gwern
18:19:53 * lambdabot secretly deletes gwern's source code
18:20:00 * gwern has backups
18:20:01 <gwern> > let x = sort [54,69,42,54,44,62,44,35,85,50,44,42,57,65,51,56,42,53,40,47,45,51,57,57,56,76,66,60,46,52,59,48,28,45,43,47,50,40,57,46,33,19,43,58,36,52,44,64] in take (length x `div` 5) x
18:20:02 <lambdabot>   [19,28,33,35,36,40,40,42,42]
18:20:05 <gwern> > let x = sort [55,76,56,55,44,41,44,45,65,70,46,65,46,52,68,52,57,50,64,43,41,50,69,44,47,63,34,57] in take (length x `div` 5) x
18:20:06 <lambdabot>   [34,41,41,43,44]
18:20:16 <gwern> hm. interesting
18:20:31 <gwern> not only is the average a bit higher, there's a 'floor'
18:20:34 <ivanm> gwern: or else just ghci on your own computer?
18:20:55 <pikhq> Clearly he can't install GHCI.
18:21:38 <copumpkin> > text . map snd . sortBy (comparing fst) $ [(75,'p'),(70,'u'),(65,' '),(60,'k'),(55,'c'),(50,'u'),(45,'f'),(40,' '),(35,'e'),(30,'h'),(25,'t'),(20,' '),(15,'t'),(10,'u'),(5,'h'),(0,'s')]
18:21:39 <lambdabot>   shut the fuck up
18:21:45 <gwern> I suspected my second set of scores was higher, but good to know
18:22:34 <gwern> copumpkin: did you write that by hand? :)
18:22:38 <copumpkin> nope
18:23:00 <copumpkin> if we had a decent randomness source it could've been more randomish
18:24:48 <ivanm> :o
18:24:56 <ivanm> since when did lambdabot start using profanity?
18:25:09 <ivanm> @ask Cale when and why did you teach lambdabot profanity?!?!?!? :o
18:25:09 <lambdabot> Consider it noted.
18:25:15 <medfly> he didn't
18:25:27 <aavogt> @slop food
18:25:27 * lambdabot is overcome by a sudden desire to hurt food
18:25:29 <medfly> someone sent lambdabot a command...
18:25:34 <ivanm> oh, wait, copumpkin's command produced that
18:25:47 <ivanm> @tell Cale nvm, copumpkin thought he was funny
18:25:47 <lambdabot> Consider it noted.
18:25:55 <copumpkin> o.O
18:26:08 * hackagebot webserver 0.1.0 - HTTP server library  http://hackage.haskell.org/package/webserver-0.1.0 (KazuYamamoto)
18:26:30 <gwern> I think the profanity may;ve been there for years and years from when dons was on openbsd and liked the sudo messages
18:26:47 <copumpkin> nothing wrong with profanity
18:26:56 <gwern> profanity is of the deble!
18:27:06 <copumpkin> nothing wrong with the deble
18:29:09 * hackagebot webserver 0.1.1 - HTTP server library  http://hackage.haskell.org/package/webserver-0.1.1 (KazuYamamoto)
18:29:51 <ivanm> OK, who's playing silly buggers with lambdabot?
18:34:04 <tensorpudding> did the sudo insults originate at openbsd?
18:34:13 <Cale> ivanm: I had nothing to do with it
18:34:13 <lambdabot> Cale: You have 2 new messages. '/msg lambdabot @messages' to read them.
18:34:34 <ivanm> Cale: yeah, I worked out afterwards what copumpkin had done
18:35:03 <copumpkin> I was reacting to gwern :)
18:35:04 <ivanm> now, however, I'm getting random messages like "wtf!", etc. purportedly from lambdabot...
18:35:15 <gwern> heh
18:35:19 <ivanm> copumpkin: yes, I worked that one out ;-)
19:02:19 <wolfspaw> Anyone here knows how to install Haskell-Mode in emacs(Windows)? I Followed those 2 guides: http://mail.cs.unm.edu/pipermail/cs357/2009-April/000115.html , http://learnhaskell.blogspot.com/2007/09/lesson-1-hello-world.html but noone worked. My .emacs does not give any error, but M-x ghci does not works
19:02:23 <wolfspaw> =(
19:03:26 <ivanm> don't use M-x ghci
19:03:48 <wolfspaw> what should i use?
19:04:01 <ivanm> C-c C-l within a .hs file should load it into ghci
19:04:40 <ivanm> or M-x inferior-haskell-start-process might work
19:05:01 <ivanm> (since haskell-mode works with hugs as well)
19:05:34 <wolfspaw> i also tried C-c C-l, but it failed. It says its a keybind disabled for lowering case of a selected region.  I'll try the inferior-haskell-start-process thanks for the help!
19:05:46 <horms> does anyone have a recommended haskell mode for use with vim?
19:07:28 <Zao> horms: I tend to use http://projects.haskell.org/haskellmode-vim/
19:07:57 <ivanm> wolfspaw: is that from a .hs file?
19:08:07 <ivanm> what major mode is it in (it should be in haskell-mode)
19:08:14 <horms> Zao: thanks, i'll give it a spin
19:08:23 <ivanm> wolfspaw: there's also a mailing list and a bug tracker
19:10:07 <wolfspaw> ivanm the command worked a bit, it opened the inferior-haskell but in background and didn't load the .hs (i don't know if its the normal behavior) .
19:10:28 <ivanm> wolfspaw: no, you open a haskell file in emacs (either .hs or .lhs)
19:10:48 <SColes> What causes a "cannot construct the infinite type..." error?
19:11:01 <ivanm> if you set up haskell-mode properly, then that buffer's major mode should be haskell-mode and C-c C-l should load it into a *haskell* buffer
19:11:10 <ivanm> SColes: usually treating a value as a list
19:13:08 <Guest42737> Hi! Is there a de facto Unix-like operating system that is used by Haskellers? I'm on FreeBSD now, but the latest version of GHC that is available is 6.10.4, and that's making it difficult to install some of the libraries through Cabal (and I don't want to rely on the OS vendor to provide Haskell libraries). I've seen a lot of people mentioning Arch...is that what I should go with?
19:13:09 <Cale> SColes: There are a whole bunch of related type errors of that sort.
19:13:56 <wolfspaw> ivanm it seems i'm almost there.  When i open a .hs file in emacs it says "haskell-ghci is obsolete" and C-x C-l still doesnt work. But when i do M-x inferior-haskell-start-process the *haskell* buffer appears in background and i can change it with C-x B
19:14:07 <Cale> SColes: We'd have to see more of the message to know what exactly the problem is, but it's a type error, regardless. Usually the best thing to do, even before reading the type error closely is just to go to that line in your source and read the code carefully and check if everything makes sense.
19:14:16 <ivanm> wolfspaw: not C-x C-l, C-c C-l ;-)
19:14:21 <ivanm> what version of haskell mode are you using?
19:14:25 <ivanm> did you follow the README file?
19:14:33 <ivanm> what version of emacs?
19:14:52 <ivanm> Cale: hang on, code is meant to make sense now? :o
19:15:13 <Cale> Guest42737: Linux is popular. Any flavour of linux should do.
19:15:19 <ivanm> Guest42737: arch linux has probably the best haskell support, followed by gentoo, then fedora, debian, etc.
19:15:31 <DigitalKiwi> <3 arch
19:15:52 <Guest42737> ivanm: That's what I've been observing, but I just wanted to make sure. I swear I'm *NOT* trying to start a flame war.
19:15:59 <Cale> If you actually care about Haskell, you shouldn't use your distribution's packages anyway
19:16:13 <Cale> Get the generic linux binary of GHC and install that.
19:16:17 <wolfspaw> ivanm hm, no, I followed a tutorial in the net.  Latest version of emacs i guess (23.1.1) .  C-c C-l works =D. It was a confusion by my part after all x.x
19:16:20 <ivanm> Guest42737: I use gentoo, so if I say arch probably has better haskell support then it's obvious I"m not starting a flame war ;-)
19:16:22 <ivanm> Cale: :o
19:16:23 <Cale> and then install cabal-install
19:16:32 <DigitalKiwi> if you actually care about your OS you should use your package manager!
19:16:39 <ivanm> Cale: I beg to differ, especially if it needs C libs
19:16:55 <DigitalKiwi> screams the inner package manager programmer in me
19:16:57 <Guest42737> Cale: Even for something like GHC?
19:17:00 <ivanm> Guest42737: the main reason that arch has better haskell support is because AFAICT dons churns out heaps of packages
19:17:07 <ivanm> in this case, "better" == "more libraries"
19:17:10 <Cale> I'll generally use my package manager to install the relevant C libraries
19:17:12 <horms> DigitalKiwi: amen
19:17:14 <ivanm> in gentoo, we take more care with them :p
19:17:20 <Cale> But cabal-install to install the Haskell bindings to them
19:17:23 <ivanm> (because we have to support more versions of GHC, archs, etc.)
19:17:26 <Cale> Guest42737: yeah
19:17:35 <ivanm> DigitalKiwi: agreed
19:17:40 <Cale> And whatever you do, *don't* bother compiling GHC yourself.
19:17:52 <ivanm> Cale: why, what distro do you use that you don't use the system one?
19:17:58 <Cale> Because it's a tremendous waste of time unless you're hacking on it.
19:18:13 * ivanm was compiling ghc on his uni ubuntu machine until the platform complained due to missing libedit
19:18:29 <DigitalKiwi> there are some 1300+ haskell-$lib packages in arch repos/aur
19:18:30 <ivanm> maybe I'll just go stuff it, go with 6.12 + cabal-install and forget the platform however
19:18:35 <wolfspaw> ivanm thanks a lot for the help, you saved my night xD. I just need to fix a bit my .emacs now because the "ghci-haskell" is obsolete indicates something odd
19:18:37 <Cale> You need a working GHC binary to compile GHC anyway
19:18:53 <ivanm> Cale: I compile GHC...
19:18:54 <Cale> (unless you're bootstrapping, which means you're hacking on it)
19:18:59 <ivanm> I compile just about _everything_!
19:19:10 <Cale> and so you might as well get the most recent GHC binary to begin with and not waste your time
19:19:10 <ivanm> (with the exception of proprietary packages and openoffice)
19:19:24 <Cale> Compiling stuff yourself is a waste of energy
19:19:25 <shapr> I sometimes wonder, are tensorpudding and functorsalad related?
19:19:25 <SamB_XP> Cale: you still need a working binary SOEMWHERE
19:19:34 <Cale> SamB_XP: right
19:19:44 <ivanm> shapr: hmmm.... we need a main course in between them...
19:19:45 <ivanm> ;-)
19:19:47 <shapr> hah
19:20:06 <ivanm> Cale: but with USE flags I get to remove heaps of unwanted dependencies!
19:20:16 <ivanm> and OMG I"M GOING SO FAST!!!!!
19:20:17 <ivanm> ;-)
19:20:47 <Cale> Yeah, that's so silly. I prefer to let the people who wrote the software compile it.
19:21:01 <Cale> They know better than I do how it ought to be compiled.
19:21:20 <ivanm> better not let flameeyes hear you say that...
19:21:34 <Cale> At the very least it's something which should be done centrally, so as not to waste power.
19:21:44 <DigitalKiwi> Cale: sometimes I wonder if they actually do
19:21:44 <ivanm> his blog posts often contain diatribes about upstream who do stupid decisions in their build process
19:21:54 <ivanm> e.g. internal versions of libraries
19:21:56 <DigitalKiwi> and sometimes I find that they actually do not know how to compile their software
19:22:17 <ivanm> which is why distros usually compile the software themselves rather than trusting upstream
19:22:19 * DigitalKiwi wants to scream every time he finds something that needs -fPIC 
19:22:24 <Cale> DigitalKiwi: This is possible too, but for big projects, usually they do.
19:22:37 <FauxFaux> I kind of dislike the compiling-for-the-worst-case thing distros have to do.  SSE is actually getting towards the point where it has useful stuff in and is available on modern cpus.
19:23:15 <Cale> and I don't really give a damn about whether the binary is compiled for my specific hardware, so long as it runs as it's supposed to.
19:23:25 <ivanm> Cale: SAGE is a nightmare... upstream have it chock full of customised versions of libs
19:23:31 <ivanm> rather than pushing patches to those libs' upstream
19:23:39 <Cale> SAGE is a nightmare just conceptually.
19:23:45 <ivanm> FauxFaux: *cough* gentoo *cough* :p
19:24:09 <DigitalKiwi> FauxFaux: arch doesn't do that, they do i686 and x86_64 optimized
19:24:18 <DigitalKiwi> f i386!
19:24:20 <Cale> SAGE is really just a whole pile of ridiculous text-processing hackery.
19:24:21 <FauxFaux> ivanm: That's the only defence of gentoo. ¬_¬  Luckily, Sun's JVM uses SSE if available, so the actual answer is to just use Java. ¬_¬
19:24:38 <FauxFaux> DigitalKiwi: Yeah, but i686 lacks, like, half the instructions available on a core2. :p
19:24:44 <ivanm> FauxFaux: I beg to differ; the customisation of USE flags is actually why I use gentoo, not the optimisation stuff
19:24:49 <DigitalKiwi> so use the x86_64 one ;p
19:25:01 <sbahra> i686 does not lack half the instructions available on a Core 2, really. :-/
19:25:28 <ivanm> DigitalKiwi: last time I tried installing x86_64 versions of linux on my c2d laptop, it kept segfaulting (even using various liveCDs)
19:25:39 <ivanm> sbahra: I think FauxFaux refers to SSE3, etc.
19:25:44 <DigitalKiwi> Linux lappy 2.6.32-ARCH #1 SMP PREEMPT Tue Feb 9 15:12:10 CET 2010 x86_64 Intel(R) Core(TM)2 Duo CPU T8300 @ 2.40GHz GenuineIntel GNU/Linux
19:25:51 <pikhq> There are a few things that make Gentoo very handy. USE="doc", FEATURES="splitdebug keepsource", CFLAGS="-ggdb".
19:25:57 <Cale> On Ubuntu, I've started having to compile a couple of packages by hand, and this is giving me a strong reason to switch distributions to something less stupid. Unfortunately, I'm not sure if it exists.
19:26:00 <sbahra> ivanm, sure.
19:26:15 <Cale> Probably I'll just go back to Debian
19:26:36 <FauxFaux> USE flags made me so sad. /o\  What's that, you wanted the ability to /list directories/ in the webserver?  RECOMPILE.
19:26:51 <ivanm> pikhq: I had gcc refuse to build when I accidentally had that CFLAG there...
19:27:00 <pikhq> ivanm: "-ggdb"?
19:27:06 <ivanm> FauxFaux: OK, how would you do it in a binary distro?
19:27:07 <FauxFaux> Debugging info.
19:27:07 <ivanm> pikhq: yup
19:27:10 <pikhq> That is all kinds of fucked up.
19:27:14 <Cale> FauxFaux: yeah, just building everything with all the features you could ever want makes more sense to me
19:27:19 <jcreigh> Cale: but then you have to either follow testing and upgrades 100s of packages all the time or else use stable and enjoy cutting edge technology from 2 years ago....
19:27:28 <FauxFaux> Cale: I'm not sure if that's sarcasm, but I agree. :p
19:27:38 <ivanm> Cale: so build openoffice with gnome + kde support even if you use neither?
19:27:48 <DigitalKiwi> and then there was arch.
19:27:59 <SamB_XP> jcreigh: I use testing and rarely upgrade the packages so I get to do BOTH!
19:27:59 <Cale> "But... but it uses up a few megabytes more disk space!!!1111one one one lim x -> 0 of sin(x)/x"
19:28:00 <FauxFaux> ivanm: It's only a hundred meg or so extra, who cares?
19:28:05 <ivanm> which requires you to twiddle with the build scripts yourself IIUC to change compile time options
19:28:08 <ivanm> FauxFaux: I do
19:28:21 <ivanm> since it also brings in a whole bunch of other unneeded libs + apps
19:28:28 <Cale> Oh no!
19:28:38 <FauxFaux> You could've earnt the money to buy an extra 100mb of storage in the time we've been arguing, let alone the time you'd wait for openoffice to compile.
19:28:43 <jcreigh> SamB_XP: haha. Actually, I am drinking the Ubuntu Kool-aid at the moment, but following testing is not a bad option.
19:28:45 <DigitalKiwi> if it brings them in then how are they unneeded?
19:28:55 <ivanm> because _I_ don't use them
19:28:58 <ivanm> and dont' need that support
19:28:59 <Cale> jcreigh: I'm really annoyed by the PulseAudio garbage.
19:29:08 <DigitalKiwi> lolpulse
19:29:10 * FauxFaux actually prefers the Windows model, I think, but that may be because I hate people changing what I have installed.  GOOGLE.
19:29:17 <ivanm> FauxFaux: actually, openoffice is the only package I dont' compile
19:29:20 <sbahra> FauxFaux, "compiling all features" means more potential for security holes, more maintenance overhead, etc...let alone some "features" are mutually exclusive.
19:29:38 <ivanm> FauxFaux: ummm... no-one changes what I have installed on my linux machine...
19:29:39 <FauxFaux> No sensible application has mutually exclusive features.
19:29:50 <jcreigh> Cale: that is slightly annoying. I haven't had any problems with it, other than having to upgrade to the beta version of wine (which was in the repo, so it wasn't hard) to get sound (mostly) working in wine.
19:29:51 <ivanm> DigitalKiwi: yeah, another advantage of gentoo: don't want pulseaudio? don't install it!
19:29:52 <FauxFaux> ivanm: Any update command has the potential to do so, though.
19:29:52 <Cale> and the fact that nothing I care about has actually improved meaningfully in Ubuntu in the last few versions, while they've managed to mess a bunch of stuff up
19:30:21 <ivanm> FauxFaux: which is why you _check_ what it is going to update first, and if you don't want something updated you tell it so
19:30:30 <Cale> PulseAudio doesn't work with my sound hardware correctly (and it's just an Audigy 2 card, I don't know why it should have such difficulty)
19:30:37 <DigitalKiwi> ivanm: well with arch i don't need pulse but i also don't have to spend dozens of hours compiling stuff ;p
19:30:46 <ivanm> *shrug*
19:30:59 <ivanm> DigitalKiwi: if arch was around when I started using nix, maybe I would have gone with it
19:31:08 <DigitalKiwi> it's not to late, it's never to late
19:31:09 <FauxFaux> ivanm: And when it tells you you need to pull in a new libc to install a new package..?
19:31:10 <Cale> It took the couple dozen volume controls that ALSA had, and stuck them *all* behind a single master volume, and fixed the headphone volume at 0%
19:31:12 <DigitalKiwi> too*
19:31:27 <ivanm> but looking at it nowadays; yes it saves you compilation time but so much of its config, etc. seems so brain-dead (in that they drank too much of the KISS "kool-aid")
19:31:44 <ivanm> FauxFaux: never does
19:31:53 <ivanm> (usually because I keep my system up to date anyway)
19:32:04 <DigitalKiwi> a gentoo user just told me he arch takes too much time configing
19:32:09 <DigitalKiwi> i think i might die
19:32:13 <ivanm> FauxFaux: try nixos then; it lets you have different "sets" (forget its terminology) of packages
19:32:17 <Cale> So I had to uninstall PulseAudio, and I've been doing this for the last couple versions pretty painlessly, but in the latest release, they, for some reason, built a bunch of the gnome audio stuff with no ALSA support.
19:32:19 <ivanm> so you can have multiple libcs, etc.
19:32:23 <DigitalKiwi> can't...breathe...
19:32:29 <FauxFaux> ivanm: Or Windows, Windows is good.
19:32:51 <tensorpudding> i hear osx is pretty easy to use
19:32:52 <ivanm> DigitalKiwi: I didn't say that; I said it was brain dead in the whole "manually edit the config scripts yourself", etc. side of things
19:33:00 <ivanm> oh, and one-version-only of packages
19:33:02 <DigitalKiwi> oh i misread
19:33:11 <ivanm> tensorpudding: and pretty crap to use ;-)
19:33:18 <ivanm> FauxFaux: then use windows
19:33:18 <DigitalKiwi> i thought you said "it doesn't take time to compile but it takes time to configure"
19:33:29 * ivanm doesn't care what people use as long as they don't force it upon him
19:33:36 <FauxFaux> ivanm: USE WINDOWS NOW
19:33:36 <ivanm> DigitalKiwi: heh
19:33:41 <ivanm> @slap FauxFaux
19:33:41 * lambdabot pushes FauxFaux from his chair
19:33:47 <Cale> Oh, and they also got rid of the panel volume control applet altogether, so I had to fix that too.
19:34:10 <ivanm> DigitalKiwi: I would think that arch would take a similar amount of configuration time as gentoo does due to the rolling releases, setup from scratch, etc.
19:34:14 <Cale> So the latest upgrade consisted of no meaningful new features and about 24 hours of figuring out and fixing mistakes.
19:34:25 <ivanm> anyway... should we take this to -blah ?
19:34:39 <Cale> If people start talking about Haskell.
19:35:01 <ivanm> fair enough
19:35:09 <DigitalKiwi> depending on how much configuration you want to do to your arch it can take anywhere between 20 minutes to three months to configure how you want it
19:35:19 * ivanm should probably get back to looking for papers
19:35:28 * hackagebot mighttpd 0.1.0 - Simple Web Server in Haskell  http://hackage.haskell.org/package/mighttpd-0.1.0 (KazuYamamoto)
19:35:41 <Cale> I liked Ubuntu a few versions back, because the default configuration was particularly close to how I wanted my machine to begin with.
19:35:44 <ivanm> DigitalKiwi: same with gentoo (post-installation that is; don't know the arch installation process)
19:35:54 <Cale> But it's been going downhill for a while.
19:36:00 <DigitalKiwi> 20 minutes including installation
19:36:35 <DigitalKiwi> (I am seriously not joking, that included downloading packages for ftp install if you get a nice mirror)
19:36:40 <SamB_XP> DigitalKiwi: only 3 months ?
19:37:09 <DigitalKiwi> SamB_XP: ok sideways 8
19:37:20 <DigitalKiwi> didn't want to scare people off too badly
19:37:38 <jcreigh> is it still the case with arch that if you want to install any new packages, you have to upgrade your whole system to the latest? (ie, like following the Debian testing branch?)
19:37:50 <ivanm> DigitalKiwi: for me gentoo takes longer to install if only because I like to recompile all the packages from scratch (doesn't help when I got a bunch of i486 binaries; not going to trust funtoo any more for bootstrapping packages :@)
19:37:53 <SamB_XP> DigitalKiwi: ah, yeah, that's generally how long it takes me too ;-P
19:38:12 <Cale> I ran Debian unstable for about 5 or 6 years before Ubuntu, and I was pretty happy with it
19:38:12 <DigitalKiwi> jcreigh: that hasn't relaly ever been the case
19:38:18 <tensorpudding> "The first version was the worst, and the next version was worse yet.. The next version I didn't enjoy at all. After that I went into a bit of a decline"
19:38:21 <dons> jcreigh: its not really like that.
19:38:28 <tensorpudding> it*
19:38:30 <ivanm> tensorpudding: where's that from again?
19:38:31 <DigitalKiwi> what you are referring to is doing a -Sy without -Su and then installing without updating
19:38:37 <ivanm> marvin the paranoid android?
19:38:41 <tensorpudding> shamelessly ripped from marvin the pa yeah
19:39:30 <jcreigh> DigitalKiwi: when I was using Arch, ISTR some people telling me that the best practice is to upgrade all packages in case, eg, a library has been updated and the new package depends on having the newest version or something.
19:39:34 <jcreigh> but I could be mistaken.
19:40:43 <ivanm> IIRC, xmonad was broken for a bit in arch because they rebuilt xmonad but not xmonad-contrib...
19:40:58 * ivanm points out that this isn't a problem in gentoo :p
19:40:58 <DigitalKiwi> the issues is like: you install a system, run -Sy and get a new cache list of installable packages, but don't upgrade, then install something and  it was built on a library that you didn't upgrade to, then you can be in trouble
19:41:54 <Cale> I tend to think of my distribution as a convenient repository of all the software that I'm not really particular about.
19:42:14 <DigitalKiwi> but if you do not -Sy, it will continue to pull (or try to) a "correct" package
19:42:16 <Cale> If I care about something, I'll install and configure it myself.
19:42:35 <jcreigh> DigitalKiwi: ah, so they keep old versions hanging around for a bit?
19:42:49 <Cale> For example, I don't run Ubuntu's version of Firefox, because they've surely done a bunch of braindamaged things to it.
19:42:50 <DigitalKiwi> yes and no
19:42:54 <DigitalKiwi> not intentionally
19:43:00 <DigitalKiwi> but mirrors take a while to sync :)
19:43:37 <jcreigh> haha.
19:43:49 <DigitalKiwi> mirrors only have one version of a package at any given time, but given enough mirrors some of them are inevitably outdated to some extent, and the old one might be on one of them
19:44:00 <ivanm> Cale: yeah, I can't stand the stupid extra extension they force upon it
19:44:05 <jcreigh> but really, it is like following Debian testing then. If you don't do an "update", you can get away with just installing new packages for a while, but eventually you start getting 404s.
19:44:17 <DigitalKiwi> right
19:44:35 <DigitalKiwi> in which case you could do -Sy, and probably even install a lot of single packages without having problems
19:44:39 <DigitalKiwi> but eventually you might
19:44:57 <DigitalKiwi> it's just best to -Syu
19:45:15 <dobie_gillis> which can *also* break many packages
19:45:23 <dobie_gillis> in which case it's just best to use gentoo
19:45:25 <DigitalKiwi> usually doesn't >.>
19:46:13 <ivanm> well, in gentoo there's a one command fix for this: revdep-rebuild (or reconcilio if you use paludis; not sure about pkgcore)
19:46:26 <DigitalKiwi> I would rather have the arch devs recompiling the hundreds of packages libjpg and png are dependencies for than me do it
19:46:35 <ivanm> well, then there's also {haskell,python,emacs}-updater and whatever perl calls their tool...
19:47:37 <jcreigh> My plan is to keep with Ubuntu until it screws me over in some way, and then switch to Debian stable (or maybe testing) and just install backports/compile myself all the packages I really care about.
19:48:59 <DigitalKiwi> if ubuntu screws you wouldn't it really be debian screwing you? ;D
19:49:12 <SamB_XP> DigitalKiwi: not really
19:49:16 <jmcarthur> the xmonad-contrib situation could be solved in arch with a simple bauerbill -S --abs xmonad-contrib
19:49:20 <DigitalKiwi> "if ubuntu is debian then why is there ubuntu?" epic lulz
19:49:34 <ivanm> jmcarthur: which does?
19:49:43 <jmcarthur> ivanm: builds it from abs
19:49:47 <DigitalKiwi> clyde > bauerbill
19:49:48 <SamB_XP> Debian doesn't do that much -- mostly they just deny you GFDL+invariant-section docs without stating this in the description of the -doc package ...
19:49:51 <jmcarthur> from source, that is
19:50:09 <DigitalKiwi> someday clyde will even do that nifty --abs thing! >.>
19:50:13 <jmcarthur> DigitalKiwi: i haven't tried clyde
19:50:24 <jmcarthur> what's nice about it?
19:50:28 <DigitalKiwi> well I don't mean to blow my own whistle but it is awesome
19:50:33 <jmcarthur> oh you made it?
19:50:34 <ivanm> jmcarthur: and abs is?
19:50:37 <ivanm> jmcarthur: oh, from source
19:50:43 <DigitalKiwi> arch build system
19:50:48 <DigitalKiwi> ports like build system
19:50:54 <ivanm> DigitalKiwi: you wrote clyde I take it?
19:50:57 <jmcarthur> ivanm: the repository of package builds that the binary packages are built from
19:51:00 <DigitalKiwi> ivanm: yupp
19:51:13 <ivanm> does arch use categories or is everything chucked into one big huge repo folder?
19:51:18 <DigitalKiwi> jmcarthur: well are you familiar with yaourt?
19:51:41 <jmcarthur> ivanm: four official repos, but not really categorized
19:51:43 <DigitalKiwi> 21:51 < phrik> DigitalKiwi: <DigitalKiwi> Tass`: clyde is like yaourt only doesn't suck
19:51:52 <jmcarthur> just core, extras, community, and testing
19:51:53 * ivanm writes that down as another reason to prefer gentoo
19:52:02 * jmcarthur doesn't miss categories whatsoever
19:52:07 <jmcarthur> ontologies are overrated
19:52:16 <jmcarthur> DigitalKiwi: yes
19:52:16 <ivanm> jmcarthur: it avoids having ghc6-foo or haskell-foo in package names
19:52:19 <DigitalKiwi> we have groups and meta packages
19:52:34 <ivanm> and if I'm looking for an app that does something (usually a new game) I can browse through the category
19:52:47 <jmcarthur> ivanm: but for all practical purposes you still would have to say haskell/foo
19:52:54 <jmcarthur> or whatever namespace scoping there is
19:53:00 <ivanm> jmcarthur: right, we do
19:53:15 <jmcarthur> browsing is fine, except i usually just use search anyway
19:53:15 <ivanm> except that if the package name is unique then you can usually skip the category
19:53:20 <ivanm> e.g. emerge criterion
19:53:28 <ivanm> rather than emerge dev-haskell/criterion
19:54:06 * jmcarthur hasn't found it to be an issue
19:54:13 <ivanm> jmcarthur: I "browse" by searching as well: eix -C dev-haskell ;-)
19:54:17 <ivanm> jmcarthur: I find it handy
19:54:22 <DigitalKiwi> jmcarthur: http://bbs.archlinux.org/viewtopic.php?id=91860
19:54:25 <ivanm> and I have the whole ghc6-foo package naming system
19:54:49 <DigitalKiwi> ugh I have to go really sooooon :(
19:55:02 <ivanm> DigitalKiwi: lua is fast? isn't it just another scripting language?
19:55:12 <ivanm> (and as such how can it be fast?)
19:55:21 <jmcarthur> it's faster than bash
19:55:24 <DigitalKiwi> yup
19:55:30 <jcreigh> ivanm: It's not JITed or anything. Just a little custom bytecode compiler with matching VM.
19:55:30 <DigitalKiwi> though that's not saying much ;D
19:55:34 <jmcarthur> DigitalKiwi: does it offer anything aside from speed?
19:55:35 <jcreigh> ivanm: probably has okay performance.
19:55:39 <jmcarthur> DigitalKiwi: bauerbill is quite fast
19:55:40 <SamB_XP> ivanm: I SOOOOO want to squish you for that false generalization
19:55:43 <ivanm> jcreigh: *nod*
19:55:43 <DigitalKiwi> as a language? I love using it
19:55:50 <ivanm> SamB_XP: :D
19:56:10 <ivanm> SamB_XP: I thought we preferred compiled languages here since ghc is a _compiler_
19:56:13 <SamB_XP> I mean, scripting languages can go as fast as you can write JITs to make them go
19:56:13 <DigitalKiwi> jmcarthur: I've really only used bauerbill for searching, at which clyde is about 2-4 times faster than bauerbill
19:56:41 <DigitalKiwi> SamB_XP: squish him
19:56:50 <DigitalKiwi> lua is blazing
19:56:51 <SamB_XP> in fact, "scripting language" just means "it doesn't take reams of code to write a useful program"
19:56:58 <jmcarthur> DigitalKiwi: bauerbill also has a special flag to trust packages from hackage, builds from abs, and supports cpan
19:57:09 <chowder> uber haskell newb here looking for some advice. I'm using ghci and I'm getting a strange error when I do :l file.hs. I think it has to do with an if statement.
19:57:26 <ivanm> DigitalKiwi: in that case, why lua rather than haskell? ;-)
19:57:35 <DigitalKiwi> because I know lua
19:57:38 <Cale> chowder: if expression, you mean ;)
19:57:42 <Cale> chowder: What's the error?
19:57:45 <ivanm> chowder: paste the error up with the file somewhere
19:57:48 <ivanm> @hpaste
19:57:48 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
19:57:50 <ivanm> chowder: ^^
19:57:51 <chowder> Cale: I'll pastebin it
19:58:02 <DigitalKiwi> codepad >  hpaste
19:58:25 <ivanm> DigitalKiwi: never!
19:58:37 <DigitalKiwi> hpaste doesn't run code
19:58:37 <jmcarthur> codepad is nice, but i kind of like a paste site to just paste
19:58:42 <jmcarthur> codepad for specific cases
19:58:49 <ivanm> DigitalKiwi: ummm.... isn't that a _good_ thing?
19:58:56 <ivanm> why would you want a paste site to run code? :s
19:59:03 <DigitalKiwi> to show the output!
19:59:12 <jmcarthur> ivanm: codepad can be nice to flag errors or demonstrate something to somebody
20:00:07 <ivanm> jmcarthur: ummm... paste the error up somewhere as well?
20:00:14 <jmcarthur> extra work
20:00:14 <chowder> http://haskell.pastebin.com/CXVYJSNa <<error along with source of program I was trying to load
20:00:22 <jmcarthur> you're pasting the code already, why bother with other junk?
20:00:23 <ivanm> if it runs your code, then they'd have to be really careful wrt sandboxing
20:00:29 <jmcarthur> yes, they are
20:00:33 <ivanm> also, it woudl depend on compiler/libraries as well
20:00:34 <chowder> DigitalKiwi: I believe I've seen you on #archlinux
20:00:38 <jmcarthur> they have a page dedicated to explaining how they do it
20:00:48 <DigitalKiwi> chowder: would not surprise me a bit
20:01:03 <chowder> DigitalKiwi: I got too lazy for arch
20:01:14 <DigitalKiwi> :(
20:01:19 <ivanm> chowder: you don't wnat that putStrLn there
20:01:22 <ivanm> if you want an error, use error
20:01:25 <jmcarthur> i'm too lazy for ubuntu
20:01:35 <ivanm> but in Haskell we don't mix our computations with IO
20:01:55 <jmcarthur> i have found arch far easier to maintain and, more importantly, diagnose and customize
20:02:00 <chowder> ivanm: I see. I just want a way of telling the user...hey...wtf r u doing
20:03:03 <chowder> jmcarthur: very true. Ubuntu is a pain to customize. Arch is actually one of my fave Linux distros. I tried Slackware for a while but I got really tired of managing my own dependencies
20:03:04 <ivanm> chowder: use error or wrap the result in a Maybe and return Nothing if the result can't be computed
20:03:17 <ivanm> in more advanced code/libraries the latter is preferred as it won't crash your program :p
20:03:35 <chowder> ivanm: can I get an example? I'm still reading the "Learn you a haskell for great good"
20:03:41 <chowder> plus I'm new to functional programming
20:03:52 <chowder> used to procedural, OO, and imperative
20:04:20 <ivanm> the usual example is division
20:04:33 <ivanm> safeDivide x y = if y == 0 then Nothing else Just (x / y)
20:04:42 <ivanm> @type let safeDivide x y = if y == 0 then Nothing else Just (x / y) in safeDivide
20:04:43 <lambdabot> forall a. (Fractional a) => a -> a -> Maybe a
20:04:54 <ivanm> > let safeDivide x y = if y == 0 then Nothing else Just (x / y) in safeDivide 3 0
20:04:55 <lambdabot>   Nothing
20:04:58 <ivanm> > let safeDivide x y = if y == 0 then Nothing else Just (x / y) in safeDivide 3 6
20:04:59 <lambdabot>   Just 0.5
20:05:23 <Cale> chowder: Another note, if/then/else is usually indented like:
20:05:24 <Cale> if foo
20:05:26 <Cale>    then bar
20:05:28 <Cale>    else quux
20:05:38 <Cale> It's more nicely balanced that way
20:05:55 <ivanm> Cale: I still usually have if then and else lined up in pure code...
20:05:56 <chowder> i see, I'll make a note of that
20:06:04 <ivanm> does that mean I'm going to hell? :p
20:06:21 <Cale> ivanm: Well, it's not such a big deal, but I prefer at least one more space
20:06:29 <tensorpudding> i like lining them up
20:06:33 <jcreigh> ivanm: naw, eternal damnation is only if you use unsafePerformIO.
20:06:34 <tensorpudding> except when they're in a do block
20:06:40 <ivanm> *phew*
20:06:49 <Cale> ivanm: The 'then' and 'else' are part of the 'if', so it makes sense to me that they should start in a deeper column
20:06:56 <ivanm> jcreigh: oh, wait, I used that to wrap around some referentially transparent IO calls... :s
20:07:02 <Cale> and they're siblings of each other, so they should line up
20:07:16 <Cale> (this, we agree on :)
20:07:20 <ivanm> Cale: yeah, but I'm used to lining them all up from other languages ;-)
20:07:27 <jcreigh> ivanm: ah. well, sorry then. The exact moment that you go to hell can't be predicted, but sooner or later, Satan will evaluate that thunk....
20:07:38 * hackagebot HDBC-mysql 0.6.1 - MySQL driver for HDBC  http://hackage.haskell.org/package/HDBC-mysql-0.6.1 (ChrisWaterson)
20:07:42 <ivanm> Cale: that we kinda have to agree on; IIRC it won't compile if else is indented differently from then
20:07:51 <Cale> actually it will
20:07:55 <Cale> if foo
20:07:58 <Cale>          then bar
20:08:01 <Cale>    else quux
20:08:02 <Cale> is fine
20:08:15 <Cale> if/then/else actually isn't subjected to the layout rules specially
20:08:25 <Cale> But it looks bad if you do stuff like that
20:09:24 <chowder> can you do if/else-if/else in haskell?
20:09:35 <Cale> (the actual layout rules only care about let, do, where, and of, and the part that follows them)
20:09:37 <gwern> anyone have a quick recipe for a sliding average of a [Int] (with a window of 10)?
20:09:41 <ivanm> :o
20:09:46 <ivanm> Cale: even in do blocks?
20:09:56 <Cale> chowder: You can, but it's ugly, using guards is better
20:09:58 <ivanm> gwern: I've done something like that
20:10:02 <Cale> if foo
20:10:07 <Cale>    then bar
20:10:12 <ivanm> IIRC I did something like map 10 . tails
20:10:12 <Cale>    else if quux
20:10:19 <gwern> tails huh
20:10:20 <Cale>            then frotz
20:10:25 <gwern> > tails [1..4]
20:10:26 <lambdabot>   [[1,2,3,4],[2,3,4],[3,4],[4],[]]
20:10:27 <Cale>            else quelb
20:10:43 <ivanm> * map (take 10) . tails
20:10:46 <gwern> ivanm: sure it's not map take 10?
20:10:51 <gwern> ah
20:10:57 <Cale> chowder: You just nest them.
20:11:23 <ivanm> gwern: of course, then you have issues with what to do with the values on either side (i.e. that aren't in the middle of a block of 10)
20:11:29 <Cale> chowder: However, guards let you do the equivalent without nesting things, and are actually usually syntactically preferable to if as well.
20:11:35 <gwern> ivanm: me, I'll discard them
20:11:40 <chowder> Cale: interesting
20:11:44 <ivanm> yeah, that's the easiest way
20:11:49 <chowder> I really need to learn more about haskell
20:12:01 <chowder> I'm reading Real World Haskell.
20:12:13 <ivanm> I had to do one (in Python however) that included the outliers as well (to calculate a baseline value for some data) where I did bookkeeping to add/remove values from either end
20:12:22 <Cale> You can also make a nice function for selecting cases, though one doesn't exist in the Prelude.
20:12:26 <ivanm> chowder: RWH is OK if you've programmed before
20:12:31 <ivanm> there are other tutorials available
20:12:35 <ivanm> @where lyah
20:12:35 <lambdabot> http://www.learnyouahaskell.com/
20:12:37 <ivanm> @where wikibook
20:12:38 <lambdabot> http://en.wikibooks.org/wiki/Haskell
20:12:40 <ivanm> @where yaht
20:12:40 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
20:13:03 <chowder> ivanm: I have experience with Java and Perl, mostly
20:13:05 <ivanm> or, if you prefer real books, there's Craft of Functional Programming, Haskell School of Expression and Programming in Haskell amongst others
20:13:17 <ivanm> there's also a haskell tutorial for C programmers IIRC
20:13:33 <Cale> I find that a weird perspective.
20:13:37 <chowder> interesting
20:14:01 <Cale> I think it's best, if you're learning Haskell, to just try to discard your existing programming knowledge for the time being -- especially of languages like C.
20:14:12 <Cale> It will just get in the way if you try to make comparisons.
20:15:06 <ivanm> Cale: yeah, I had a quick read through it once; it does a contrast between the two IIRC
20:15:10 <ivanm> some people like it *shrug*
20:18:12 <Cale> It's a lot like learning to program for the first time in a number of ways, if you've only been exposed to OO and/or imperative languages especially.
20:18:42 <Cale> First with regard to how you express your program, and then with regard to your sense of what code will perform well.
20:19:14 <chowder> Cale: I'm familiar with Perl, Java, C (very little), and BASH
20:19:30 <Cale> Yeah, so this should seem all very new. :)
20:19:43 <Cale> Don't worry, it gets easier over time.
20:19:50 <chowder> someone recommended that I learn Lisp but I didn't really like it for whatever reason
20:20:24 <SamB_XP> chowder: I don't really either :-)
20:20:29 <Cale> Common Lisp I find is really awkward as a functional language. Scheme is nicer. I think Haskell is a nice place to dive in though.
20:20:34 <SamB_XP> It leaves me too confused about what to do
20:21:24 <gwern> and then there's CLOS
20:21:28 <gwern> goodness me
20:22:04 <SamB_XP> but you can't overload the + operator!
20:22:07 <Cale> The main problem I have when programming in Scheme is that it's not lazy, and I'm way too used to lazy evaluation now. After that, I have problems with the lack of a type system. It really really sucks to spend an hour debugging your program to discover that the problem is something that would have been a simple type error.
20:22:34 <SamB_XP> Cale: yeah, I think that's why I always feel so undirected when I try to use Lisp
20:22:42 <SamB_XP> hardly any syntax, hardly any typing ...
20:22:46 <chowder> I just like the idea of functional programming being analogous to Lambda Calculus
20:22:49 * chowder loves math
20:22:58 <Cale> Ah, you're in good company then :)
20:23:05 <SamB_XP> indeed
20:23:12 <Cale> @where Awodey
20:23:12 <lambdabot> http://www.math.uchicago.edu/~may/VIGRE/VIGRE2009/Awodey.pdf
20:23:18 <gwern> heh. I'm so used to lazy evaluation that I was editing my .emacs, I put in a call to '(boundp undefined-variable)' as part of an if clause, and I kept getting confused why on earth it was triggering an exception on undefined when an exception was exactly what it was supposed to be avoiding
20:23:22 <SamB_XP> (I thought functional programming WAS lambda calculus?)
20:23:24 <Cale> ^^ my favourite book on Category theory :)
20:23:27 <chowder> but the first time I looked at haskell I got a "what" moment
20:23:46 <gwern> turns out, I need (boundp 'undefined-variable) because the undefined-varable was getting evaluated *first*
20:24:13 <Cale> (which you might want as enrichment eventually as a Haskell programmer -- some of us are stealing ideas from CT and bringing them into the world of computer science and practical programming)
20:24:52 <chowder> very interesting
20:24:55 <dolio> I have to say, I've been reading some of Categories for the Working Mathematician...
20:25:02 <dolio> And I think I like Awodey better.
20:25:04 <ddarius> Cale applied transitivity there.
20:25:17 <ddarius> Moggi steal CT for denotational semantics and the Wadler steals CT for Haskell.
20:25:46 <ddarius> dolio: Awodey is a way better intro, particularly for programmer types.
20:26:01 <Cale> Yeah, CFTWM requires you to be more of a working mathematician, and is less refined in its presentation of the material.
20:26:01 <Spaceghost> hi
20:26:03 <Spaceghost> wow
20:26:07 <dolio> Well, there's certainly that.
20:26:07 <ddarius> dolio: But, Categories for the Working Mathematician is a reasonably good reference.  It would be better if it were more encyclopedic.
20:26:08 * ivanm has CT for the working computer scientist (something like that anyway)
20:26:23 <Cale> Hello Spaceghost
20:26:40 <ddarius> dolio: You've read the Barr and Wells ESSLLI lecture notes, yes?
20:26:42 <ivanm> I started reading it a few years ago; I almost got the "let's use categories to implement a stack" but arrows were a complete what-the
20:26:56 * ivanm waves idly in Spaceghost's general direction
20:28:02 <ddarius> I skimmed Pierce's CT book and didn't care for it.
20:28:12 <copumpkin> of the various sources I've read parts of for CT, I like awodey and the B&W notes the most
20:28:22 <dolio> ddarius: I have them. I don't think I've read them.
20:28:49 <ddarius> And there is another freely available online book by Longo(?) that's okay and meant to be for CS-y people, but I wouldn't say is the best intro.
20:28:54 <ddarius> dolio: Definitely read it.  Right now.
20:29:06 * copumpkin cracks his whip for ddarius
20:29:38 * copumpkin elects himself to the position of sidekick
20:29:52 <Spaceghost> ivanm, ?
20:30:21 <ivanm> I was waving at you rather than saying hello
20:30:23 <ivanm> ;-)
20:30:32 <Spaceghost> ah, ok
20:30:40 <ivanm> copumpkin: for whom?
20:30:41 <Cale> Spaceghost: Learning Haskell?
20:30:57 <dolio> ddarius: Incidentally, I think I have a clearer understanding of what exactly goes wrong with parametricity when you add dependent types.
20:30:58 <Spaceghost> Cale, yes, I will use it in a curse of logic
20:31:07 <copumpkin> ivanm: ddarius' sidekick! I cracked the whip for added effect
20:31:16 <Spaceghost> we will start the wednesday with him
20:31:17 <Spaceghost> :P
20:31:18 <ivanm> Spaceghost: I hope you meant course rather than curse there...
20:31:19 <ddarius> dolio: It sounds like it from what you were saying earlier, sporadically.
20:31:20 <dolio> Since I've been attempting to explain it over at the n-category cafe.
20:31:26 <Cale> Spaceghost: ah, cool. Don't hesitate to ask any questions you might have about it. People are generally pretty friendly to beginners around here.
20:31:28 <ddarius> dolio: Link?
20:31:29 <Spaceghost> yes, ivanm thanks
20:31:32 <Spaceghost> my english is bad
20:31:35 <ivanm> copumpkin: so you're whole role revolves around you cracking a whip?
20:31:45 * copumpkin coughs
20:31:49 <Cale> ivanm: "you're"
20:31:52 <copumpkin> (but yes)
20:31:55 <ivanm> gah! I've done it again!
20:32:02 * ivanm doesn't know what's going on with him today
20:32:15 <copumpkin> your not you'reself
20:32:15 <dolio> ddarius: http://golem.ph.utexas.edu/category/2010/03/in_praise_of_dependent_types.html#comments
20:32:19 <ddarius> Danke.
20:32:46 <SamB_XP> lol @ copumpkin's "your"
20:33:00 <gwern> if you're not yourself, then who are you?
20:33:11 <SamB_XP> somebody else!
20:33:23 <ivanm> gwern: a tired shallow copy of me
20:33:27 <SamB_XP> or nobody, could be!
20:33:38 <gwern> if it's nobody, then who said that?
20:33:53 <dolio> ddarius: I'm not sure all my thoughts are laid out there, but there's some of it.
20:35:17 <dolio> Essentially, in Haskell, we have 'forall a. ...' which is parametric in a. And then separately, there are * -> * functions in the type level that aren't parametric.
20:35:30 <dolio> And dependent typing mixes those together into the same thing (with some additional stuff).
20:37:27 <nettok> Hey, do you think reading Awodey's CT will make me a better haskeller?
20:37:48 <chowder> I'm reading it now
20:37:55 <chowder> its....fascinating
20:38:05 <chowder> and I haven't even learned set theory, yet
20:38:45 <ivanm> nettok: probably not
20:38:46 <dolio> And importantly, something like '(exists a. P a) -> Type' doesn't have to be parametric in 'a', because if you don't worry about the 'P a' part, it's living in the non-parametric * -> * area.
20:38:56 <nettok> yeah, but how does it relates to haskell?  i think i will read it just for the math knowledge anyway
20:39:16 <ivanm> it might help you understand how haskell works a bit better, but I for one usually write very "normal" functions without any arrows, etc.
20:39:29 <ivanm> (well, I do use first, second and *** with functions on pairs...)
20:39:33 <ddarius> dolio: I'm looking through it.  Having Neel Krishnaswami on your "side" though, isn't a bad thing.
20:39:52 <ivanm> nettok: well, a lot of abstract structures, etc. in haskell are based on category theory: monads, monoids, functors, arrows, etc.
20:40:22 <dolio> But it still messes with the abstraction properties of exists/forall. In Haskell, functions like that are ruled out because it uses the dependent typing (*,[],[]) pi rule.
20:40:45 <dolio> Yeah, I guess that means I must not be totally off. :)
20:42:00 <nettok> ok, I'll take a look at the book
20:42:15 <nettok> It looks interesting
20:44:59 <ddarius> dolio: Note that, at least at a basic level, a language can definitely have both parametric polymorphism and dependent types.
20:48:43 <dolio> Well, I don't doubt that. I'd expect erasure pure type systems (for instance) to have parametric polymorphism via their eraseable abstraction.
20:48:51 <ologNation> Has anyone used Data.Graph?
20:48:52 <dolio> Although I don't think that's what they were shooting for when they came up with the idea.
20:49:03 <ivanm> ologNation: *shudder* you're better off not using it
20:49:07 <ologNation> It seems difficult to find a helloWorldData.Graph.hs which shows how ot even build one.
20:49:11 <ologNation> ivanm, Oh yeah?
20:49:23 <ivanm> FGL is a better graph abstraction
20:49:28 <ivanm> or roll-your-own using Data.Ma[
20:49:31 <ologNation> I figured it might be a sort of standard, since it's the one built into the heirarchical libs.
20:49:32 <ivanm> *Data.Map
20:49:41 <ologNation> Data.Ma[?
20:49:45 <SamB_XP> ologNation: I loath Data.Graph
20:49:48 <ologNation> Data.Map.
20:49:49 <ivanm> ologNation: only because no-one has (yet) replaced it with something better
20:49:57 * ivanm is working on a replacment class-based approach
20:49:57 <ologNation> SamB_XP, This sounds like a concensus.
20:50:04 <ologNation> Hm.  Well, what about the FGL one?
20:50:18 <ivanm> it's not the greatest (too many usages of tuples, etc.) but it's not too bad
20:50:31 <ologNation> How hard is it to replace it with something better?
20:51:05 <ivanm> well, you have to have a good enough replacement that people will agree is good enough ;-)
20:52:01 <SamB_XP> personally, I would just stick a big "this module is almost universally loathed; try fgl" at the top of Data.Graph
20:52:10 <ologNation> Hmm.  Well that is a surprise to me.
20:52:27 <dons> http://www.itmatchonline.org/freelance/requirement-of-haskell-programming.htm
20:52:28 <ologNation> I would think that graph is an important enough structure that someone would want a good one in haskell.
20:52:34 <dons> someone paying for haskell assignments. :/
20:52:47 <ologNation> Hey dons.
20:53:00 <dons> heya ologNation !
20:53:09 <SamB_XP> dons: what an idiot! doesn't he know it's better to just get them done for free here?
20:53:12 <ivanm> ologNation: yeah, Cale & co. tend to roll their own
20:53:19 <SamB_XP> often one or another of us can't help ourselves ;-P
20:53:39 <ivanm> what I'm working on is a generic graph representation so that people can use whatever data structure they want for graphs but libraries should work on all of them
20:53:48 <ologNation> That's a funny link.
20:53:54 <ivanm> dons: :/
20:53:56 <ologNation> Kind of sad.
20:54:07 <dons> they teach haskell in dubai though (?)
20:54:09 <ddarius> There is no happy graph library, so I would recommend adopting an approach like Cale's.
20:54:35 * ivanm assumes that the kind of websites that accept "jobs" like that probably wouldnt' have competent haskell hackers looking for work there
20:54:37 <ologNation> ddarius, What is that?
20:54:45 <ivanm> ologNation: using Data.Map or Data.IntMap
20:54:47 <ddarius> @hackage astar
20:54:47 <lambdabot> http://hackage.haskell.org/package/astar
20:54:56 <ivanm> oh, that approach
20:55:13 <ivanm> ddarius: that's feasible for people writing simplistic libraries, but not really for larger ones
20:55:16 <ivanm> (IMHO)
20:55:47 <ddarius> ivanm: I'm pretty sure it is readily scalable.  It's essentially what happens with ML modules.
20:55:56 <ologNation> Well, maybe I can tell you what I want to do with graphs.
20:56:00 <ddarius> It's just programming to an interface instead of an implementatino.
20:56:10 <ivanm> scalable, yes; feasibly scalable? that I'm not sure about
20:56:18 <ivanm> ologNation: shoot
20:56:43 <ddarius> You can package all the arguments into a record and then you have a very crappy, simplistic first-class module system.
20:57:23 <ezyang> I'm trying to convince my teammates that having this one small program be in Haskell is a good idea
20:57:33 <ezyang> and this devolved into explaining currying and monads
20:57:51 <ezyang> and apparently one of these teammembers knows Bluespec and thought it was a pain in the ass.
20:57:57 <ivanm> :o
20:57:59 <copumpkin> oh no, a monad explainer
20:58:02 <ologNation> The longer term goal is to build some code implementing David Spivak's "Geometric Model for Databases."
20:58:03 <ClaudiusMaximus> any awesomely memory-efficient datastructures for navigating hyperbolic space?  supposing i want an infinite tiling of pentagons with 1 bit stored in each, and i want to move around between cells and mutate them
20:58:08 <ezyang> Yeah, I stopped myself fairly quickly.
20:58:13 <ivanm> copumpkin: better than a monad apologist...
20:58:25 <ologNation> In the shorter term, I want to have some access to the language of Category Theory.
20:58:27 <ivanm> ClaudiusMaximus: none that I know of
20:58:31 <ologNation> Here is where it gets interesting.
20:58:57 <ologNation> There is a way of saying what a Category is using these things called signatures and schemes, which I am only beginning to learn about.
20:59:26 <roboshibby> i think you guys need to see this: http://www.images.generallyawesome2.com/photos/funny/photos/donkey-pulling-cart.jpg
20:59:29 <copumpkin> I came across the category of schemes the other day for some reason
20:59:34 <copumpkin> roboshibby: no we don't
20:59:46 <roboshibby> but it's SO good
20:59:46 <ologNation> It's interesting to me because I like the language of Categories and here is a way of bringing that language into the computational domain.
20:59:51 <copumpkin> if you really want to show people, show it to #haskell-blah
20:59:51 * ivanm is sure he will live without looking at that picture
20:59:56 <roboshibby> ok
21:00:00 <ivanm> roboshibby: that's what all the spam ads on proggit say...
21:00:15 <roboshibby> im not selling anything, big difference
21:00:19 <roboshibby> im a person sharing something funny
21:01:27 <ivanm> and they just want to share their favourite band with people
21:01:35 <ologNation> Well, it sounds like you guys strongly recommend not using Data.Graph.
21:01:38 <ologNation> How can I get started?
21:01:46 <ivanm> roboshibby: anyway, I'm picking more on your choice of words ;-)
21:01:51 <ivanm> ologNation: have a look at FGL
21:01:53 <ivanm> @where fgl
21:01:53 <lambdabot> http://www.cs.orst.edu/~erwig/fgl/
21:01:55 <ologNation> Okay.
21:01:59 <ivanm> read his papers, etc.
21:02:08 * ologNation goes off reading FGL docs. 
21:02:13 <roboshibby> fair enough, though i think there's nothing better than a funny donkey picture
21:03:03 <SamB_XP> lol @ picture
21:03:15 <roboshibby> see? happiness abounds :D
21:04:13 <ivanm> heh
21:04:27 <edwardk> hrmm is it just me or is http://hackage.haskell.org/packages/archive/generator/0.5.3/doc/html/src/Control-Monad-DList.html subtly broken? i.e. using ListT rather than a ListT done right
21:04:28 <roboshibby> ivanm, c'mon, admit you loved the picture ;)
21:04:41 * ivanm didn't even look at the picture just to spite roboshibby
21:04:49 <roboshibby> rofl
21:05:01 * roboshibby is foiled again
21:05:04 <ivanm> edwardk: what do you mean by using listT rather than listT?
21:05:13 <ivanm> s/listT/ListT/g
21:05:21 <ezyang> edwardk: Hey, thanks for commenting on my blog post!
21:05:25 <edwardk> ivanm: i meant rather than "ListT done Right" as in the article on haskell.org
21:05:36 * ivanm has no idea
21:05:58 * ologNation takes it one step at a time. 
21:06:01 <ologNation> installing cabal...
21:06:27 <edwardk> ivanm: http://www.haskell.org/haskellwiki/ListT_done_right talks about the fact that ListT as commonly defined does the wrong thing
21:06:57 <edwardk> because you need a placeholder for effects caused by forcing the spine. otherwise you fail monad laws
21:07:28 <edwardk> ezyang: happily. i really enjoyed your article =)
21:07:53 <Space> uhm
21:08:28 <ivanm> edwardk: eh, never used ListT
21:08:33 <edwardk> interestingly the main client of the DList used there is the Generator monad, which is a variant on ContT (though it doesn't realize it), so that should work anyways, because ContT takes monads-that-violate-associativity and makes them into monads.
21:08:43 <ezyang> edwardk: Thanks. :-)  In many ways it was a failed experiment, but I'll keep trying.
21:10:22 <edwardk> ezyang: how did your prof try to spin monads in scheme anyways?
21:11:01 <ezyang> edwardk: We were looking at continuation passing style the previous class, and he was spinning it as a way to remove plumbing.
21:11:21 <edwardk> the biggest problem i have with most scheme monad presentations is they tend to be monomorphic. you wind up reimplementing all of your combinators for each individual monad you come across, which makes the fact that something is a monad becomes an interesting bit of trivia, not a key component in sharing code
21:11:39 <edwardk> er s/becomes/become/
21:11:54 <ezyang> edwardk: That was the first thing we solved in that class, with generic operators :-)
21:12:05 * ddarius would probably implement monads in Scheme along the lines of the dictionary-passing translation of Haskell type classes.
21:12:32 <copumpkin> edwardk had some monadey stuff
21:12:33 <edwardk> ddarius: that was my approach as well. i 'reader monad transformed' my monad sugar, so that it plumbed a dictionary of methods around
21:12:35 * SamB_XP would probably end up trying to find a port of CLOS
21:12:45 <edwardk> ddarius: http://paste.lisp.org/display/86914
21:13:18 <edwardk> ddarius: i have a version which doesn't rely on any extensions as well, but it is cruftier to work with
21:13:50 <ddarius> edwardk: Yeah, I would also have some macros to make it look pretty again.
21:14:36 <edwardk> ddarius: yeah the do macro in there feels very haskelly: (define (modify f) (do (x <- get) (put (f x))))
21:15:08 <edwardk> the result is a function from a dictionary (Monad m) -> m a
21:15:28 <edwardk> er in this case, where that dictionary also implements get and put methods
21:16:34 <edwardk> ddarius: this is the approach i'm taking for kata's monad sugar as well, because i don't have types to guide it
21:17:19 * ivanm decides to call it a day
21:17:42 <ivanm> bye all (for at least half an hour until I turn my laptop on at home)
21:18:10 <ezyang> The other thing that Sussman got was that he implemented the monadic system inside the metacircular evaluator
21:18:14 <ezyang> ivanm: bye bye!
21:18:25 <ezyang> which I imagine makes things easier to implement
21:18:49 <edwardk> arguably
21:19:01 <edwardk> i suppose i find working with any one monad kinda boring ;)
21:20:18 <copumpkin> MultiMonadMan!
21:20:28 <ddarius> Gotta catch 'em all!
21:21:07 <lament> PokeMonad?
21:22:01 <flippo> Polymonadism
21:23:27 <edwardk> wouldn't that just be Polyadism?
21:23:43 * stevenmarky replaces all instances of monad with gonad
21:24:04 <edwardk> stevenmarky: i keep waiting for go to discover monads. ;)
21:29:19 <Space> I apriece that
21:33:40 <dmead> @hoogle instance Read
21:33:40 <lambdabot> No results found
21:34:31 <ologNation> If Fgl is better than Data.Graph, why isn't it incorporated into the Heirarchical libraries?
21:34:37 <SamB_XP> @instances Read
21:34:38 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
21:34:56 <SamB_XP> ologNation: it's a bit big to go in the "collections" package
21:35:08 <dmead> ah
21:35:46 <aavogt> how does one tell ghci to act as if there is a #include directive to CPP?
21:36:08 <dmead> are we not allowed to just overload the read function?
21:36:33 <ezyang> dmead: It's not recommended.
21:36:44 <ddarius> dolio: That n-Categories conversation was interesting.  Glad I could minorly and somewhat inadvertently be of assistance.
21:37:23 <dmead> ezyang, parsing a language without a grammar defined isnt either!
21:38:15 <ezyang> it's true!
21:38:27 <dmead> but that isn't stopping me!
21:38:50 <aavogt> ah using -pgmP "cpp --include=dist/build/autogen/cabal_macros.h"
21:39:24 <dmead> should you really need a grammar to parse sql?
21:39:30 <dmead> seems like it's good enough to have a pda
21:39:36 <dmead> smeh
21:39:39 <copumpkin> a grammar is equivalent to a pda
21:39:47 <copumpkin> if you're talking about a CFG
21:42:02 <dmead> sure sure
21:43:01 <dmead> by that i mean i'm not sure if i'm being lazy by not using parsec to do this
21:43:07 <dmead> and just writting a consumer to parse the language
21:43:11 <ezyang> you could always use attoparsec
21:43:17 <dmead> never heard of it
21:44:12 <ddarius> edwardk: I would say that saying that "if you were expert enough at foo, you'd have no problem teaching foo" takes away from the skill of teaching itself.
21:45:00 <ezyang> ddarius: I mean, that's what makes an expert teacher, no?
21:45:03 <edwardk> ddarius: perhaps. i just find that i don't truly understand something until i've taught it a few times. so perhaps it is a sufficient but not necessary condition
21:45:10 <SamB_XP> ddarius: heck yes
21:45:40 <ddarius> ezyang: Being an expert at foo doesn't mean being an expert at teaching.
21:45:47 <ezyang> ddarius: I agree.
21:46:13 <SamB_XP> maybe Jack here can't be an expert at foo without being able to teach it, but you don't know Jack anyway, so ...
21:46:46 <ezyang> snerk
21:46:51 <dmead> @hoogle attoparsec
21:46:51 <lambdabot> No results found
21:46:53 <dmead> i am jacks livre
21:46:54 <aavogt> gurgle
21:47:12 <aavogt> @hackage attoparsec
21:47:12 <lambdabot> http://hackage.haskell.org/package/attoparsec
21:47:21 <dmead> yea i'm looking for docs
21:47:57 <aavogt> you can build the docs yourself
21:48:21 <dmead> smeh?
21:48:32 <aavogt> or if you use cabal install, you can tell it to do that for you
21:49:17 <SamB_XP> aavogt: how come Hackage didn't builded them ?
21:51:11 <dmead> SamB_XP, most hackage packages don't have docs
21:51:20 <dmead> sadly
21:51:32 <aavogt> SamB_XP: because of this mysterious build failure http://hackage.haskell.org/packages/archive/bytestring-lexing/0.2.1/logs/failure/ghc-6.12
21:51:42 <SamB_XP> because they didn't got builded, or because they aren't syntactically valid, or ???
21:52:05 <aavogt> in other words, the alex installation on the hackage server is inadequate
21:52:05 <dmead> SamB_XP, because they don't exist?
21:52:20 <SamB_XP> aavogt: ah!
21:52:25 <dmead> i don't know what the lack of documentation on hackage is about
21:52:51 <aavogt> it's supposed to find a header for lexing strict bytestrings, but that one is missing
21:53:34 <aavogt> it isn't mentioned in the docs for alex-2.3 (because the interface is the same as for lexing lazy bytestrings), but those packages do build with it
21:54:18 <avenge> Anyone know what Kind '#' is?  Some kind of special kind for built-in types?  I'm getting weird compile errors like this:
21:54:18 <avenge>     Couldn't match kind `#' against `*'
21:54:18 <avenge>     When matching the kinds of `GHC.Prim.Int# :: #' and `t :: *'
21:54:18 <avenge>       Expected type: t
21:54:21 <avenge>       Inferred type: GHC.Prim.Int#
21:54:35 <dmead> # is a compiler thingy i'm told
21:54:42 <dmead> like *
21:54:50 <dmead> but  more compilery
21:54:58 <aavogt> @type 1#
21:54:59 <lambdabot> GHC.Prim.Int#
21:55:05 <avenge> I understand *.  How do I convert something of type # to *.  Can I wrap it in a boxed type somehow?
21:55:20 <ddarius> @src Int
21:55:21 <lambdabot> data Int = I# Int#
21:55:26 <ddarius> :k Int
21:55:27 <lambdabot> *
21:55:27 <ddarius> :k Int#
21:55:28 <lambdabot> Not in scope: type constructor or class `Int#'
21:55:39 <aavogt> :k I#
21:55:40 <lambdabot> Not in scope: type constructor or class `I#'
21:56:00 <aavogt> you remove it from the I# box
21:56:00 <ddarius> # is the kind of unboxed types.
21:56:04 <dons> avenge: its a kind. the kind of types that can be stored in an unboxed fashion
21:56:08 <dons> i.e. in registers.
21:56:17 <dons> different  to regular haskell types, which are heap allocated objects
21:56:31 <avenge> Right, so what's the Haskell code to box something?
21:56:31 <dons> (in registers, or on the stack)
21:56:38 <dons> its constructor
21:56:43 <dons> i.e. I# 7#
21:56:51 <dons> puts the raw 7# int value onto the heap.
21:57:00 <dons> I# is the constructor for Int
21:57:06 <dons> 7# is a value of Int# type
21:57:22 <avenge> Not totally following.  How do you unI#?
21:57:28 <dons> pattern matching.
21:57:36 <aavogt> hey dons, about that bytestring-csv stuff, it turns out that my implementation with attoparsec is quite a bit slower than alex (10x) on large inputs (say 10M)
21:57:46 <dons> case I# x of x -> I# (x +# 2#) --- primitive integer arith.
21:57:57 <dons> the primitives of ghc are all raw operations (cpu add is +#)
21:57:57 <ddarius> To clarify what dons said, I# isn't "the" boxing operation for Int# but one of them, or rather one shouldn't think of them as special really.
21:58:25 <dons> yeah. they're not special. constructors can lift unboxed types into regular haskell types.
21:58:27 <avenge> dons:  But what you are telling me is how to unbox something.  I want to box it, or somehow get rid of my error message, even if it costs performance.
21:58:47 <dons> you almost never need to write unboxed thiings directly
21:58:58 <avenge> I'm trying to define methods of an instance of a class and getting these errors.
21:59:04 <dons> but depending on your type, there are constructors for them, like I# for Int, D# for Double.
21:59:07 <ezyang> I cargo culted some unboxing code from IntMap. It didn't actually help performance.
21:59:22 <ddarius> There's almost no reason to explicitly used unboxed code.
21:59:26 <dons> avenge: we'd need to see the code.
21:59:32 <ezyang> dons: Recursive freeze in O(1) isn't actually possible in GHC, is it?
21:59:41 <dons> yes, there's no reason. ghc is very very smart. so unless you understand ghc don't unbox.
21:59:46 <ddarius> This was the goal when unboxed types were added, and GHC has pretty much succeeded since they were added.
21:59:55 <dons> ezyang: freeze for mutable arrays?
22:00:05 <dons> ddarius: just took 19 years :) but we did it!
22:00:08 <ezyang> except that the mutable arrays point to more mutable arrays
22:00:17 <dons> ezyang: hmm. right.
22:00:18 <avenge> dons:  Okay, will construct a simple example I can hpaste.  Probably take a few minutes.
22:00:50 <ddarius> dons: Yeah, I remember the transition period when GHC was just getting good enough to make manual unboxing unnecessary.
22:01:05 <dons> it was an awkward time.
22:01:16 <dons> some of the early shootout stuff still shows the idioms of the day
22:01:24 <ddarius> dons: Yeah.  A bunch of "kids" coming in with insane code that wasn't bad the day before but was now.
22:01:42 <dons> :)
22:01:53 <ddarius> Or rewriting all their code to be unboxed and then complaining that it didn't help performance any.
22:01:59 <dons> ghc had a lot of it until igloo rewrote it a couple of years ago
22:02:15 <dons> NewBinary has some examples
22:02:18 <dons> for historical reference
22:02:29 <dons> "puberty" for ghc.
22:06:59 <ddarius> :k (:+:)
22:07:00 <lambdabot> * -> * -> *
22:07:14 <copumpkin> :k (:*:)
22:07:15 <lambdabot> * -> * -> *
22:07:20 <copumpkin> what's that, generic sum and products?
22:07:23 <dons> totally unappreciated
22:07:25 <ddarius> :k (:+:) 1
22:07:26 <lambdabot> * -> *
22:07:33 <copumpkin> :)
22:07:35 <dons> hinze-style compile time-only generics.
22:07:43 <copumpkin> that 1 really bothers me
22:07:57 <copumpkin> way more than it should
22:08:02 <ddarius> No one ever used it.  I remember believing that that system was never fully implemented.
22:08:30 <dons> we've used it at galois
22:08:37 <dons> massive reduction in runtime over syb
22:08:43 <dons> (because it is all compile time)
22:08:45 <ezyang> cool
22:08:55 <copumpkin> I quite like it in theory
22:09:11 <dons> is this the paper? http://portal.acm.org/citation.cfm?id=325709
22:10:44 <dmead> internet five.
22:11:21 <dons> http://www.haskell.org/ghc/docs/latest/html/users_guide/generic-classes.html
22:11:55 <ddarius> Probably "A generic programming extension for Haskell."
22:12:25 <dons> "Derivable type classes", Ralf Hinze and Simon Peyton Jones"
22:13:11 <avenge> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23370#a23370
22:13:21 <avenge> That's the simplest example I could come up with of this weird error.
22:13:46 <ddarius> avenge: Why are you using unboxed types?
22:14:01 <copumpkin> :O
22:14:24 <avenge> ddarius: I'm not.  The library is, and I can't change it.
22:14:37 <ddarius> Which library?
22:14:38 <copumpkin> you can't work with it
22:14:44 <dons> oh?
22:14:44 <copumpkin> you need to wrap it
22:14:52 <copumpkin> myMethod (I# v1)
22:14:58 <avenge> Just for my example I'm replicating what the library (Language.Haskell.TH.Syntax) is doing.
22:15:07 <dons> yeah, just rebox the value after calling myMethod
22:15:12 <copumpkin> and remember kids, you should always wrap it before using it
22:15:21 <dons> myMethod (TheirConstructor v1) = TheirConstructor (myMethod v1)
22:15:23 <dons> make sense?
22:15:39 <avenge> Yes, that works, thanks.
22:15:39 <dons> other way, actually.
22:15:40 <FauxFaux> copumpkin: <3
22:15:46 <avenge>     myMethod (TheirConstructor v1) = myMethod (I# v1)
22:15:46 <avenge>  
22:15:49 <dons> right
22:16:02 <avenge> Now I have to figure out how to do that automatically in my template haskell code.  Yuck.
22:16:08 <dons> they could get  the same result with: data TheirData = TheirConstructor !Int
22:16:17 <avenge> But at least I understand now.  Thanks for your help!
22:16:24 <dons> and compile with -funbox-strict-fields
22:16:30 <dons> avoiding all the pain
22:17:26 <aavogt> shouldn't funbox be included in -O2?
22:17:33 <dons> yep. it should be.
22:17:44 <dons> due to other ghc oddities, it could occasionally make things work.
22:17:53 <dons> we should just run nofib and check the times, then enable it with -O2
22:17:55 <dons> or even -O
22:20:13 <o-_-o> well I finally ordered RWH, the dead tree version yesterday
22:20:27 <dons> i hope you enjoy it!!
22:20:37 <avenge> So there's no way to do something like:
22:20:37 <avenge> instance MyClass Int# where
22:20:37 <avenge>     myMethod = I#
22:21:06 <avenge> Oh, because Contexts with (MyClass x) => wouldn't work!
22:21:07 <dons> no classes on unboxed types, no. (can't think of a good reason why though)
22:21:13 <o-_-o> dons, yeah, it was too expensive in my country, but now the price has come down
22:21:36 <dons> avenge: yeah, it's tied to parametric polymorphism notions.
22:21:44 <dons> unboxed kinds are really a separate language
22:21:50 <dons> with little movement between them and regular haskell.
22:22:00 <dons> just case analysis, and function application, basically.
22:22:33 <dons> some magic functions are kind polymorphic
22:22:49 <dons> unsafeCoerce#, seq (I think), type (->), application.
22:22:55 <dons> :t unsafeCoerce#
22:22:55 <lambdabot> Not in scope: `unsafeCoerce#'
22:23:00 <dons> :t GHC.Base.unsafeCoerce#
22:23:01 <lambdabot> forall t b. t -> b
22:23:05 <dons> mm. wrong.
22:23:46 <dons> Prelude> :set -XMagicHash
22:23:47 <dons> Prelude> GHC.Base.D# (GHC.Base.unsafeCoerce# 3#)
22:23:47 <dons> 1.5e-323
22:24:03 <dons> Prelude> GHC.Base.D# (GHC.Base.unsafeCoerce# ())
22:24:03 <dons> 5.43091001e-315
22:24:16 <o-_-o> Are there functors in RWH ?
22:24:19 <dons> so true magic dwells there.
22:24:38 <dons> o-_-o: ch10
22:24:41 <o-_-o> An explanation of functors,that is
22:24:45 <o-_-o> dons, ok...thanks
22:24:46 <dons> "Introducing functors"
22:25:39 <copumpkin> a functor is an object that wraps a function! ;)
22:26:57 <pikhq> copumpkin: MURDER.
22:27:00 <pikhq> ALSO LAMBDA.
22:27:01 <copumpkin> MURTHER
22:28:49 <SamB_XP> MAMBDA
22:39:56 <ddarius> dons: seq shouldn't need to be kind polymorphic.
22:41:02 <dons> ah, indeed it isn't.     Couldn't match kind `#' against `*'
22:41:44 <dons> i was mis-remembering how this worked, http://www.cse.unsw.edu.au/~dons/crawl/crawl.hs
22:42:31 <dons> interesting. that program doesn't compile anymore either
22:42:32 <dons> kind errors
22:48:26 <azathoth991> are there video to learn haskell?
22:51:35 <aavogt> sure
22:52:09 <aavogt> http://channel9.msdn.com/shows/Going+Deep/Lecture-Series-Erik-Meijer-Functional-Programming-Fundamentals-Chapter-1/
22:53:20 <ulfdoz> Sagt meine Cheffin auch immer.
22:53:24 <ulfdoz> ewin, sorry.
22:54:29 <maxmud> Privet  Milo
23:26:34 --- mode: ChanServ set +o mauke
23:26:34 --- mode: mauke set +b *!*@cpe-76-172-28-85.socal.res.rr.com
23:26:47 <copumpkin> omg I'm crying
23:26:47 --- kick: gws was kicked by mauke (gws)
23:26:55 --- mode: mauke set +b *!*gschuet*@*
23:27:00 <copumpkin> I actually just saw jdh
23:27:02 <copumpkin> use a smiley
23:27:12 <copumpkin> in a response to a member of the haskell community
23:28:37 <o-_-o> I bestof'd the safiire's comment on reddit/haskell
23:28:43 <o-_-o> http://www.reddit.com/r/haskell/comments/b913t/share_your_greatest_holy_thats_what_a_haskell/c0lkko4
23:28:49 <o-_-o> this is a really cool tutorial
23:28:54 --- mode: mauke set -o mauke
23:47:30 <avenge> Int# is to I# as Word# is to ???
23:49:39 <c_wraith> @src Word
23:49:39 <lambdabot> Source not found.
23:49:48 <c_wraith> You'd have to look up the source, I guess
23:50:04 <avenge> There doesn't seem to be source for GHC.Prim.  I guess because it's built in?
23:50:27 <aavogt> :i Word
23:50:33 <aavogt> data Word = GHC.Word.W# GHC.Prim.Word# -- Defined in GHC.Word
23:50:38 <c_wraith> There's source for it somewhere.  Just need to find it. :)
23:51:13 <avenge> Okay, cool.  Weird that the other ones are in GHC.Types.  I guess because Int and Char are in the prelude.
23:55:44 <shapr> copumpkin: What was it?
23:58:22 * shapr grumbles about gitit and quickcheck problems
23:58:41 <shapr> I swear, I'm -> <- this close to doing an NMU.
