00:00:30 <osfameron> NMU?
00:00:43 <shapr> Debian term non-maintainer upload
00:00:48 <osfameron> ah
00:00:50 <shapr> aka, fix it and stick it up there.
00:01:38 <shapr> hackagebot: Hey you!
00:01:44 <shapr> Get off of my lawn!
00:01:59 <aavogt> @slap hackagebot
00:01:59 * lambdabot places her fist firmly on hackagebot's jaw
00:04:59 <shapr> Has anyone recently installed gitit?
00:08:56 <shapr> Aha "cabal install gitit --constraint=datetime==0.1"
00:23:41 <freedrull> say i have a function composition like this: splay a (Node x l (put a r)), now, if put is recursive, will all the recursive calls to put terminate(assuming they will terminate) before splay is called?
00:24:09 <c_wraith> Well.  The language is lazy, so the answer is a very definite maybe. :)
00:27:16 <freedrull> c_wraith: o
00:28:17 <therp> freedrull: what do you mean by "will all the recursive calls to put terminate"? This somehow implies two parties, a callee and a caller. recursive (in most cases) means that callee=caller
00:30:26 <Phyx-> therp: that's only direct recursive
00:31:17 <therp> Phyx-: see "in most cases"
00:33:05 <Phyx-> therp: sure, I did see it, but the statement should have been "in some types of recursion" imho
00:37:15 <therp> I disagree. I do not need a proper definition of recursion types to convey the idea that not all recursive code implies caller=callee. "in most cases" is perfectly fine, although the reader doesn't get any clue in which cases.
00:38:39 <freedrull> i guess i was just wondering which function will be evaluated first
00:39:17 <therp> splay will be called with not necessarily evaluated "trunks"
00:40:00 <freedrull> woah
00:40:04 <therp> if splay decides to evaluate its second argument, its second argument will be brought to head normal form, which it is anyway with the (Node x l (put a r)) call
00:40:58 <therp> (by decides to evaluate I mean to put it into a case statement, "case secondArgument", or something that desugars to case statements, such as for example let)
00:41:52 <therp> if the case statement "case secondArgument of (Node x y z) -> blabla" with the expression blabla evaluates z only then you will see an evaluation of put
00:42:26 <freedrull> hmm
00:43:37 <therp> try to write a little program, and add "trace" calls (Debug.Trace module) so that you can see when stuff is evaluated.
00:44:08 <therp> iDontNeedMySecondArgument a b = a
00:44:27 <therp> and try iDontNeedMySecondArgument (trace "first arg" 1) (trace "second arg" 2)
00:47:03 <freedrull> oh Debug.Trace that sounds cool
00:49:19 <freedrull> thanks
00:49:45 <therp> @hoogle Debug.Trace
00:49:46 <lambdabot> module Debug.Trace
00:49:46 <lambdabot> Debug.Trace trace :: String -> a -> a
00:49:46 <lambdabot> Debug.Trace traceShow :: Show a => a -> b -> b
01:03:52 <voidprayer> Do Debug.Trace have side-effect?
01:04:02 <voidprayer> If no, where to show?
01:05:14 <therp> the side-effect is to print the String (or Show) argument when it gets evaluated. it will return its second argument
01:22:47 <HandheldPenguin> hhmm
01:23:01 <HandheldPenguin> I'm having trouble identifying inputs to my function...
01:23:01 <HandheldPenguin> http://haskell.pastebin.com/i6DYUNSw
01:28:59 <jd10> @where rwh
01:29:00 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
01:29:01 <Cale> HandheldPenguin: you probably want  valid n s = ...
01:29:19 <Cale> HandheldPenguin: You could also write this like:
01:29:31 <Cale> valid n s = n == length s
01:30:12 <Cale> HandheldPenguin: If you really want your function to take a pair as its parameter, you would want the type to be  (Int, String) -> Bool
01:31:38 <twink> valid 0 [] = True ; valid n (x:xs) | n > 1 = valid (n - 1) xs | otherwise = False ; valid _ _ = False ?
01:33:13 <twink> s/n > 1/n >= 1/
01:33:46 <Janni> Hello.
01:33:51 <HandheldPenguin> Cale: Thanks
01:33:53 * hackagebot redis 0.3 - A driver for Redis key-value database  http://hackage.haskell.org/package/redis-0.3 (AlexanderBogdanov)
01:34:22 <HandheldPenguin> Doesn't seem to work with this... valid n s = n == length s
01:34:28 <HandheldPenguin> Doesn't it need an if statement?
01:34:31 <Cale> no
01:34:55 <Cale> If n is an Int, and s is a String, then that should typecheck
01:35:12 <HandheldPenguin> ok, so haskell guesses what you're referring to?
01:35:15 <Cale> > let valid n s = n == length s in valid 5 "hello"
01:35:16 <lambdabot>   True
01:35:22 <Cale> Guesses?
01:35:42 <Cale> The (==) function is defined to produce a Bool value to begin with.
01:35:49 <HandheldPenguin> Well it knows that I'm talking about the string when i say length?
01:36:01 <Cale> no, that's why the s is there
01:36:13 <HandheldPenguin> So s is some  standard to refer to input strings?
01:36:16 <Cale> no
01:36:16 <HandheldPenguin> and n is for ints?
01:36:22 <Cale> s is the second parameter to your function
01:36:32 <Cale> n is the first parameter
01:36:32 <HandheldPenguin> so you specify when you say valid ns...
01:36:40 <Cale> valid n s, yes
01:36:44 <idnar> the "valid n s" part names the function "valid", the first parameter "n", and the second parameter "s"
01:37:19 <Cale> It's the same thing if you write  valid x y = x == length y
01:37:21 <HandheldPenguin> Cool
01:37:25 <HandheldPenguin> thanks, got it going now :D
01:37:36 <Janni> I'm currently looking into Data.Generics.Uniplate.Operations to do some term rewriting. I'm missing a monadic function there that performs a monadic transformation at most once on the data structure, returning mzero if the transformation couldn't be applied anywhere and otherwise the sum of the transformations (or: the list of all possible rewrites). I'm hesitating defining this function myself because I'd have to go into the "internals" of the uniplate library a
01:37:38 <HandheldPenguin> ok so you tell it what the vars are called on the first bit
01:37:45 <Cale> HandheldPenguin: yeah
01:38:34 <Janni> "rewrite(M)" performs the transformation everywhere at once, while "transform(M)" needs to succeed everywhere (I suspect) otherwise it returns mzero.
01:39:51 <Janni> Anybody got a hint for me? Or are some more explanations necessary?
01:40:01 <Cale> Well, those functions all have fairly simple definitions
01:40:33 <Cale> Perhaps you can study their definitions and determine how to write the function you're after? I'm not really familiar with uniplate
01:40:36 <Janni> So you suggest that I probably should have a look at the uniplate source code
01:40:45 <Cale> http://hackage.haskell.org/packages/archive/uniplate/1.5.1/doc/html/src/Data-Generics-Uniplate.html#transform
01:40:50 <Janni> Yeah, thanks.
01:41:16 <Cale> Well, given that the operation you want doesn't seem to be there... ndm would know better, I'm sure :)
01:42:23 <quicksilver> ndm doesn't IRC as much as he used to; damn these "real jobs"
01:42:57 <quicksilver> preflex: seen ndm
01:42:57 <preflex>  ndm was last seen on #haskell 303 days, 23 hours, 24 minutes and 16 seconds ago, saying: plus with current compiler technology, it would be slower
01:43:18 <Cale> heh
01:43:31 <Cale> Over a year? Really?
01:43:36 <Cale> er, no
01:43:39 <quicksilver> :P
01:43:46 <Cale> Misread that
01:43:57 <Cale> Still, coming up on a year
01:44:02 <quicksilver> I have a feeling he had another nick more recently but in PM with preflex I couldn't work out what it was, didn't want to spam the channel
01:44:13 <Cale> I could have sworn I'd seen him in the channel more recently than that though.
01:44:22 <Cale> yeah, hmm
01:44:48 <quicksilver> I was fairly sure it was 'ndmitchell' but preflex has no memory of that one at all so I think I'm wrong.
01:45:15 <Cale> preflex: seen ndmitchell
01:45:15 <preflex>  Sorry, I haven't seen ndmitchell
01:45:22 <Cale> huh
01:45:27 <Cale> My logs have ndmitchell
01:45:42 <quicksilver> does preflex try to do clever rename tracking, perhaps?
01:45:58 <Cale> Sep 23 10:28:37 <ndmitchell>	cool, glad you like it :)
01:45:59 <Janni> Turns out the uniplate code isn't very complicated indeed, so I think I'll be able to cope with it...
01:46:18 <quicksilver> Janni: uniplate is really rather elegant but there are some things it is incapable of
01:46:35 <quicksilver> still, if you're inside its domain it's very much recommended.
01:46:51 <quicksilver> the paper on it is an enjoyable read as well.
01:53:04 <Janni> Seems like the uniplate author (ndm?) avoided to use MonadPlus, hence the lack of a "anywhere" function (or whatever I'm going to call it)
01:55:22 <Polarina> Is there a binding to glPopMatrix and glPushMatrix in Graphics.Rendering.OpenGL? I could use preservingMatrix, but I need to call them in reverse.
01:59:55 <aleator> Anyone know how to use LLVM bindings to define functions whose arity is not known statically. 'createFunction' seems to always require a fixed number of parameters.
02:01:55 <sergio1> Hi Haskellers,
02:02:02 <sergio1> I'm trying to narrow a problem I have with a parsing program of mine.
02:02:08 <sergio1> I'm parsing a few tens of ca. 150 Kb files, and get a parse error from time to time.
02:02:20 <sergio1> I suspect a memory problem, since when I parse very few files, I don't have the problem.
02:02:28 <sergio1> And when I parse a lot of files, the error occurs at more or less regular intervals.
02:02:36 <sergio1> Here's an example of the parse error diagnostic I get:
02:02:43 <sergio1> line 1: Parsing of f1.txt failed:
02:02:51 <sergio1> line 2: " | "
02:02:58 <sergio1> line 3: "f1.txt" (line 14, column 771):
02:03:05 <sergio1> line 4: unexpected end of input
02:03:12 <sergio1> line 5: expecting MyPersonalEndOfLine
02:03:20 <sergio1> The message on line #5 is mine,  being the catch-all for an eol grammar (as seen in, e.g., "ch16/csv8.hs" in Real World Haskell).
02:03:28 <sergio1> The message on lines #3 and 4 seems habitual of Parsec (see example run of "ch16/csv8.hs" in RWH)
02:03:36 <sergio1> Do you guys know where does the message on lines #1 and 2 originate from?
02:03:46 <sergio1> Also, line #14 of my test file *is not* 771 characters long.
02:03:52 <sergio1> Obviously, EOL synchro was lost in the reading/transforming of my file...
02:04:33 <quicksilver> Polarina: glPush/Pop are not exported, indeed. Why would you need to call them in reverse?
02:04:46 <quicksilver> Polarina: you can explicitly save and restore matrix though
02:05:24 <Polarina> quicksilver, that would be great, do you happen to have an example?
02:05:51 <Polarina> quicksilver, I am changing the ortho when the window is resized.
02:06:03 <Polarina> quicksilver, but I still wish to preserve the original matrix.
02:06:40 <quicksilver> that would not require reversing push and pop
02:06:50 <quicksilver> you mean chaning the projection, I presume?
02:07:16 <Cale> sergio1: Maybe you could post the code somewhere?
02:07:55 <sergio1> cale: it's too big ATM, and I'm not sure I can publish it...
02:07:57 <Polarina> quicksilver, no, ortho. :)
02:08:11 <quicksilver> Polarina: there is no matrix called "ortho"
02:08:18 <sergio1> I have no " | " string in my parsers...
02:08:23 <quicksilver> Polarina: there are three matricies, called "modelview", "projection" and "texture"
02:08:50 <Polarina> quicksilver, glOrtho.
02:08:59 <Polarina> quicksilver, the projection matrix.
02:09:00 <quicksilver> glOrtho is not a matrix, it is a command
02:09:02 <quicksilver> right.
02:09:08 <Cale> sergio1: weird
02:09:08 <quicksilver> So, just change the projection matrix.
02:09:17 <quicksilver> that will not affect the modelview matrix
02:09:36 <quicksilver> there is no need to save and restore the modelview matrix, because in any case it will not be affected by changes to the projection matrix.
02:09:39 <Polarina> I'll try loadIdentity.
02:09:50 <dmead> hey channel
02:09:54 <quicksilver> loadIdentity clears the current matrix.
02:09:57 <dmead> consider this
02:10:04 <quicksilver> make sure the current matrix is what you want before you call it :)
02:10:08 <dmead> 2d movies are actually in 3 dimensions
02:10:24 <dmead> and 3d movies are actually in 4 dimensions
02:10:31 <dmead> think about it, man
02:11:15 <quicksilver> Polarina: the standard way to do what it sounds like you're doing is a method called 'reshape'
02:11:30 <quicksilver> Polarina: which sets up the viewport + projection matrix based on current window size
02:11:45 <quicksilver> Polarina: in GLUT, you make that your reshapeCallback
02:11:52 <quicksilver> other toolkits have comparable mechanisms.
02:12:06 <Polarina> quicksilver, I am being called from reshapeCallback.
02:18:13 <quicksilver> Polarina: ok, well here is a typical reshape callback: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23372#a23372
02:18:28 <quicksilver> Polarina: that's a frustrum one, I'm sure I have an ortho one lying around too, let me see
02:19:00 <Polarina> Hmm, seems simple enough.
02:19:49 <sergio1> cale: you wrote "weird": That's why I'm trying to narrow it out ;-)
02:20:19 <quicksilver> Polarina: ortho2D one : http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23372#a23373
02:20:22 <quicksilver> Polarina: (even simpler!)
02:20:42 <Polarina> :D
02:23:43 <Polarina> Thanks.
02:24:51 <Ke> so is there any opengl2/3 support
02:25:04 <Polarina> Ke, there is for OpenGL2, I haven't found bindings for 3.
02:25:05 <Ke> or anyone working on wrapping those
02:25:36 <Ke> ok
02:26:55 <mreh> has anyone ever made their haskell look nice in latex?
02:27:16 <mreh> I haven't put much effort in so far, but the listings package doesn't do a very convincing job
02:28:12 * hackagebot BerkeleyDB 0.8.1 - Berkeley DB binding  http://hackage.haskell.org/package/BerkeleyDB-0.8.1 (StephenBlackheath)
02:29:05 <quicksilver> Ke: openglraw has support up to 3.2
02:29:13 * hackagebot BerkeleyDBXML 0.7.1 - Berkeley DB XML binding  http://hackage.haskell.org/package/BerkeleyDBXML-0.7.1 (StephenBlackheath)
02:29:19 <quicksilver> Ke: but the 'convenient bindings' in the package opengl are only 2.x
02:31:07 <mreh> it highlights things like "Monad" and "Array", but nothing else capitalised, like most other type names and constructors
02:41:13 <Janni> Hmm. How do I express this more elegantly? \x -> f x `mplus` g x
02:42:14 <copumpkin> liftM2 mplus f g
02:42:27 <copumpkin> or mplus <$> f <*> g
02:42:42 <copumpkin> there's a few more combinations but those are the major classes of them
02:42:44 <Janni> Thx. lifting mplus... wouldn't have though of that.
02:43:04 * Janni has to look at Applicative sometime
02:44:17 <copumpkin> :)
02:45:50 <cheater> @faq can haskell describe every language that can be described in existential second-order logic?
02:45:50 <lambdabot> The answer is: Yes! Haskell can do that.
02:45:53 <cheater> omg
02:46:02 <cheater> lambdabot has just proven P=NP
02:46:35 <idnar> cheater: it didn't say it could do it in polynomial time
02:46:43 <cheater> doesn't matter if it can
02:46:45 <cheater> http://en.wikipedia.org/wiki/P_versus_NP_problem#Logical_characterizations
02:47:02 <idnar> er
02:47:04 <idnar> finite time, I mean
02:47:13 <cheater> doesn't matter either
02:47:43 <Phyx-> > 1+1==3
02:47:44 <lambdabot>   False
02:47:54 <Phyx-> my faith in lambdabot has wavered
02:47:58 <idnar> then I'm missing something
02:48:34 <copumpkin> > let 1 + 1 = 3 in 1 + 1 == 3
02:48:35 <lambdabot>   True
02:48:48 <Phyx-> copumpkin: lol, cheating
02:49:15 <idnar> cheater: how do I get from your FAQ to P = NP?
02:49:31 <cheater> read the paragraph i just linked to
02:49:51 <idnar> I did, but I don't understand what it has to do with Haskell
02:50:10 <cheater> Thus, the question "is P a proper subset of NP" can be reformulated as "is existential second-order logic able to describe languages (of finite linearly ordered structures with nontrivial signature) that first-order logic with least fixed point cannot?".
02:50:25 <cheater> doesn't haskell implement forst-order logic with lfp?
02:51:18 <idnar> "However, no axiom system in first order logic is strong enough to fully (categorically) describe infinite structures such as the natural numbers or the real line. "
02:51:48 <Phyx-> > bar
02:51:49 <lambdabot>   Not in scope: `bar'
02:51:50 <idnar> I'm kinda way out of my depth here, though
02:55:14 <Dementati> cheater: That just means Haskell can express NP languages. Duh.
02:56:56 <Dementati> Doesn't really say anything about P=NP.
02:57:44 <Janni> Would _proper_ subset mean, P/=NP?
02:57:52 <Janni> s/Would/Wouldn't/
02:57:55 <Dementati> Excuse the 'Duh.', that was rude of me.
02:58:12 <Dementati> Janni: Indeed.
02:58:38 <Dementati> Janni: When I say 'P=NP', I'm referring to the question of whether or not it is true.
02:58:59 <mux> that's why I usually say "P vs NP"
02:59:05 <mux> there's less room for confusion thisway
02:59:19 <Dementati> mux: That's reasonable.
02:59:20 <profmakx> i am just going to prove P = PSPACE. all problems will go away then.
02:59:36 <Phyx-> P = what?
02:59:37 <Phyx-> lol
02:59:52 <Phyx-> PSPACE = ?
03:00:32 <profmakx> Phyx-: problems that can be solved by an algorithm that has polynomially bounded space complexity
03:00:50 <Dementati> Phyx-: P = Set of all problems decidable by a Turing-machine in polynomial time.
03:01:05 <Dementati> Phyx-: NP = Set of all problems verifiable by a Turing-machine in polynomial time.
03:01:27 <trzkril> IBTD
03:01:44 <Dementati> PSPACE = Set of all problems decidable by a Turing-machine in polynomial space I guess? (Making assumptions, correct me if I'm wrong)
03:01:49 <Phyx-> profmakx: ah
03:03:00 <profmakx> unless complexity theory has made progress i didn't notice it its not known whether P is a proper subset of PSPACE, very much like P vs. NP
03:03:39 <trzkril> Dementati: I learned that P is the class of problems which can be solved by a deterministic Turing-machine in polynomial time, where NP is the same for non-deterministic Turing-machines
03:04:01 <Dementati> trzkril: Oh, yes, what I said above concerns deterministic TMs.
03:04:11 <Dementati> trzkril: What you said is equivalent to the above.
03:07:09 <Phyx-> god this is torture....
03:07:18 <Phyx-> my FF13 still hasn't arrive... damn pre-order...
03:15:31 <ivanm> Phyx-: "FF13"?
03:16:46 <profmakx> Final Fantasy 13 ivanm
03:16:53 <ivanm> ahhh
03:17:30 <jlouis> Firefox 13
03:17:35 <jlouis> Arrives in 10 years
03:19:11 <jlouis> trzkril: NP is like you said. An equivalent definition is the class of problems whose solutions can be verified in P on a deterministic TM
03:19:33 <jlouis> It is, occasionally, easier to work with as a definition
03:20:17 <Dementati> jlouis: Which is... What I said. =]
03:20:33 * hackagebot concurrent-extra 0.4 - Extra concurrency primitives  http://hackage.haskell.org/package/concurrent-extra-0.4 (BasVanDijk)
03:21:49 <McManiaC> hmhm
03:21:54 <pozic> Is there a way to compute sin x and cos x faster in some way then just calling both sin x and cos x?
03:21:58 <McManiaC> how can I get CString work with utf8?
03:22:08 <pozic> s/then/than
03:22:16 <jlouis> Dementati: hah, I applied a filterM to the conversation it seems
03:22:18 <McManiaC> > newCString "❤" >>= peekCString
03:22:19 <lambdabot>   Not in scope: `newCString'Not in scope: `peekCString'
03:22:26 <profmakx> pozic: precompute and lookup
03:22:27 <McManiaC> hm
03:22:31 <profmakx> pozic: and interpolate :P
03:23:27 <Dementati> jlouis: I see. =P
03:26:59 <jlouis> Dementati: hopefully my monad allows me to run in the BPP class, so I'll regard it as a stray error :P
03:27:52 <gspr> I'm a bit confused, so I'll just ask... what's the simplest way to get numpy/octave-like slicing with arrays?
03:28:24 <pozic> gspr: you mean "views" of arrays?
03:28:24 <ivanm> preflex: seen TacticalGrace
03:28:25 <preflex>  TacticalGrace was last seen on #haskell 1 day, 10 hours, 55 minutes and 26 seconds ago, saying: copumpkin: wrong channel ;)
03:28:34 <copumpkin> :o
03:28:41 * ivanm waits to see if the incantation magically summons TacticalGrace or not
03:28:57 <pozic> gspr: also, there is no such thing as arrays in Haskell. There are a lot of different array like types.
03:28:58 <Cale> gspr: With Data.Array? I don't think there's a built-in library function. You can make a new array whose elements are defined by indexing the other array.
03:29:03 <Trinitron> Project euler problem 1 in one line: thousand x = if x == 0 then 0 else if mod x 3 == 0 || mod x 5 == 0 then x + thousand (x-1) else thousand (x-1)
03:29:10 <ivanm> hmmm... is Ord a super- or a sub- class of Eq (in that all Ord instances have to be Eq instances)?
03:29:12 <Cale> There are arrays in Haskell.
03:29:12 <gspr> Cale: That's what I want to do, yes
03:29:17 <ivanm> I can never remember that terminology :s
03:29:31 <ivanm> gspr: I think vector supports slicing
03:29:36 <ivanm> and hmatrix might as well
03:29:42 <copumpkin> ivanm: Eq is a superclass of Ord
03:29:50 <ivanm> but you can't really do that with the "inbuilt" array types
03:29:55 <ivanm> copumpkin: so ord is a subclass?
03:29:58 <pozic> What exactly do you mean by slicing?
03:30:01 <gspr> ivanm: I was thinking of going via vector of hmatrix, yes, but my data will soon be needed as a carray, so I'd like to stay there
03:30:17 <ivanm> pozic: getting sub-arrays IIRC
03:30:29 <ivanm> e.g. getting the second to the tenth elements of the array
03:30:40 <gspr> pozic: In this case I mean constructing an array x which on some indices is defined as the elements of an array y and on others as the elements of an array z
03:31:20 <gspr> of course I'll manage to work it out, but I just thought I'd ask to see if there's some pretty way to do it
03:31:36 <Phyx-> ivanm: lol, yeah, final fantasy 13
03:31:47 <quicksilver> ironically the bulit-in arrays have views
03:31:54 <ivanm> gspr: whichever way you do it, you'll almost definitely have the values in x be copies of the values in y and z; if you edit x the changes won't be reflected in y and z
03:31:54 <quicksilver> that's how indexing works
03:32:02 <quicksilver> but they don't have combinators to let you construct your own views
03:32:03 <quicksilver> shame!
03:32:36 <gspr> ivanm: That's ok... there aren't that many elements, so I don't think copying will be expensive compared to what I'll do with the result later on
03:32:47 <pozic> ivanm: you can do that in a single threaded way or via a copy.
03:33:14 <pozic> ivanm: AFAIK, the nice thing about the optimized libraries is that they are allergic to copying.
03:33:24 <gspr> In short, what I want to do is this: Let x be an array of length m, y an array of length n. I want to define an array z of length m+n equalling x on the index set a and y on the index set b
03:33:27 <ivanm> "allergic"? in that they don't let you?
03:33:40 <pozic> ivanm: as in that they try hard. \
03:33:52 <pozic> ivanm: a good thing.
03:34:00 <gspr> (where size a + size b = m + n)
03:34:15 <Dementati> jlouis: Haha, indeed. =]
03:34:53 <sergio1> cale: I screwed up: The " | " is in my code (but not in my parser, that's why I failed to locate it at first)
03:38:09 <gspr> ah, ixmap does what I want I guess
03:39:46 <gspr> hmm, possibly :)
03:41:05 <AnnaBanz> http://imgnow.info/DSC-1268134841.jpg do my boobs look small?
03:43:12 <kowey> is this type error easy to fix? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23375#a23375
03:43:56 * kowey foolishly bashes things with an existential type hammer and hits his thumb
03:44:41 <kowey> if it's not easy to fix, I think I should just make data KeyValue = KeyValue HillKey JSValue instead, kiss
03:45:32 <copumpkin> unfortunately not
03:45:36 <olsner> KeyValue can take "anything" as its second argument, and jsonField returns "anything"
03:45:43 <olsner> you need to decide which anything you want
03:46:52 <kowey> I'm afraid that's still over my head, olsner (sorry!)
03:46:58 <olsner> hmm, is v <- foo monomorphic by default or something?
03:47:06 <copumpkin> you could also parametrize KeyValue by a type and avoid the existential
03:47:34 <McManiaC> how can I activate pragmas in ghci?
03:47:34 <kowey> well, the idea of having an existential was to have heterogenous KeyValue thingies
03:47:49 <copumpkin> ah
03:48:28 <kowey> that's OK; I don't think I have a compelling reason not to use JSValue instead
03:48:34 <kowey> was just trying to be more clever than I actually am
03:49:41 * hackagebot hsndfile 0.4.0 - Haskell bindings for libsndfile  http://hackage.haskell.org/package/hsndfile-0.4.0 (StefanKersten)
03:50:23 <ivanm> @tell jfredett there, I've provided you with more content for the next HWN; happy now? :p
03:50:23 <lambdabot> Consider it noted.
03:51:41 * hackagebot hsndfile-vector 0.4.0 - Haskell bindings for libsndfile (Data.Vector interface).  http://hackage.haskell.org/package/hsndfile-vector-0.4.0 (StefanKersten)
03:51:43 <zygoloid> kowey: (>>=) doesn't have an impredicative type; you can't give it a polymorphic value and hope to get a polymorphic value out
03:52:09 <kowey> what's an impredicative type?
03:52:37 <theorbtwo> One where you can give it a polymorphic value in and get a polymorphic value out?
03:52:40 * theorbtwo ducks.
03:52:42 <zygoloid> roughly, that's when you use a forall inside an argument of a type constructor
03:52:57 <zygoloid> (note i'm not 100% certain of the terminology here either...)
03:53:06 <copumpkin> a type constructor that isn't (->)
03:53:13 <kowey> hmm, the GHC manual seems to give an idea - http://www.haskell.org/ghc/docs/6.10.1/html/users_guide/other-type-extensions.html
03:53:27 <copumpkin> it's just higher-rank for (->)
03:53:47 <copumpkin> has something to do with being able to instantiate polymorphic types in type variables, which (->) has none of, I guess
03:56:32 <ivanm> copumpkin: you were asking me about the generic graph class stuff recently, weren't you?
03:58:07 <copumpkin> yep
04:01:19 <urmet> hi. how do i define a function taking a list of lists? i'm having some problem getting the signatures right
04:01:28 <copumpkin> [[a]] -> ...
04:01:53 <copumpkin> or [] ([] a) if you want to avoid syntactic sugar
04:02:04 <ivanm> copumpkin: my latest blog post has a bit more of a rationale about why it isn't out yet ;-)
04:02:12 <ben> :t (i :: [] a)
04:02:13 <lambdabot>     Couldn't match expected type `[a]' against inferred type `Expr'
04:02:13 <lambdabot>     In the expression: (i :: [] a)
04:02:19 <ben> derp
04:02:32 <zygoloid> kowey: in any case, i would guess if you were to wrap the value in an existential before passing it through >>= it might work
04:02:33 * ivanm is not just artificially driving traffic to his blog, honest!
04:02:39 <ben> :t [] :: [] a
04:02:40 <lambdabot> forall a. [a]
04:02:49 <ivanm> kowey: oh, and I'm working on record types for graphviz
04:03:07 <ivanm> the same blog post has my excuses about why it's not available yet when I promised you the end of last month :s
04:03:29 <nostrand^^> hi, where is teh "par" combinator in GHC 6.12, there's no module Control.Parallel =/
04:04:06 <ivanm> nostrand^^: it's in the parallel library
04:04:10 <ivanm> it doesn't come with ghc
04:04:14 <nostrand^^> ah =/
04:04:18 <ivanm> (hasn't for a while)
04:04:36 <ivanm> hayoo would tell you that ;-)
04:05:04 * ivanm -> land of nod
04:07:07 <Jafet> Is there some way to express the type of a function that takes an argument and returns itself? That is, type f = forall a. (a -> f)
04:07:23 <Jafet> @pl let f a = f in f
04:07:23 <lambdabot> fix const
04:07:29 <Jafet> @type fix const
04:07:30 <lambdabot>     Occurs check: cannot construct the infinite type: a = b -> a
04:07:30 <lambdabot>     Probable cause: `const' is applied to too few arguments
04:07:30 <lambdabot>     In the first argument of `fix', namely `const'
04:08:03 <maltem> Jafet, I think there's a way to avoid the infinite type with the help of a newtype
04:08:22 <Kagami`> @type fix
04:08:23 <lambdabot> forall a. (a -> a) -> a
04:08:33 <Kagami`> :t fix
04:08:34 <lambdabot> forall a. (a -> a) -> a
04:09:27 <alex404> Does anyone know the best way to stream an animation into a GUI via gtk2hs?
04:09:46 <alex404> The options are: Cairo, OpenGL, Gstreamer
04:10:17 <Jafet> Hmm. I am unfamiliar with newtypes, but I'll look.
04:11:34 <benmachine> Jafet: you have a function that takes an argument and returns a (function which takes an argument and returns a (...
04:11:58 <benmachine> what would it be *for* anyway?
04:14:23 <Cale> Jafet:
04:14:27 <Cale> Jafet: sort of
04:14:33 <Jafet> benmachine: it's for an elaborate, high budget thought experiment
04:14:49 <Cale> Jafet: you can make a newtype which essentially gives you that
04:16:28 <Cale> newtype Rec a = In { out :: a -> Rec a }
04:16:51 <Cale> f = In (\x -> f)
04:18:28 <Jafet> Well, the source of this question is when I thought about how you could do it in C++, a (in theory) strongly typed language; by creating a class and overloading the function call operator
04:19:02 <Jafet> And wondering exactly which features of the language bridge the recursion gap
05:00:57 <sergio1> cale: are you still around?
05:04:16 <liff> is there any way to write: Functor f => f (a -> b) -> a -> f b
05:04:49 <benmachine> yes
05:05:24 <liff> how?
05:05:30 <benmachine> :t fmap
05:05:31 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
05:05:36 <tensorpudding> that's not quite fmap
05:05:40 <benmachine> no
05:05:45 <benmachine> but fmap helps
05:06:05 <benmachine> take fmap and set a = c -> d
05:06:16 <benmachine> err
05:06:20 <benmachine> take fmap and set a = c -> b
05:06:53 <benmachine> then fmap :: ((c -> b) -> b) -> f (c -> b) -> f b
05:07:12 <benmachine> and that's almost there
05:07:15 <tensorpudding> @type flip fmap ($)
05:07:16 <lambdabot> forall b a b1. ((a -> b1) -> b) -> (a -> b1) -> b
05:07:25 <tensorpudding> hmm
05:07:26 <benmachine> nope
05:07:38 <benmachine> close though :P
05:07:47 <tensorpudding> @type flip fmap ($ 10) [\
05:07:48 <lambdabot> parse error (possibly incorrect indentation)
05:07:51 <tensorpudding> damn
05:08:00 <tensorpudding> @type flip fmap ($ 10) [succ]
05:08:01 <lambdabot>     Couldn't match expected type `[a -> a]'
05:08:02 <lambdabot>            against inferred type `b1 -> b'
05:08:02 <lambdabot>     In the expression: flip fmap ($ 10) [succ]
05:08:06 <tensorpudding> @type (flip fmap) ($ 10) [succ]
05:08:07 <lambdabot>     Couldn't match expected type `b1 -> b' against inferred type `[a]'
05:08:07 <lambdabot>     In the second argument of `(flip fmap)', namely `[succ]'
05:08:07 <lambdabot>     In the expression: (flip fmap) ($ 10) [succ]
05:08:20 <benmachine> you just need to make ((c -> b) -> b) using c
05:08:20 <tensorpudding> oh wait
05:08:27 <tensorpudding> @type (flip fmap) [succ] ($ 10)
05:08:28 <lambdabot> forall a. (Enum a, Num a) => [a]
05:08:51 <ski> @type flip
05:08:52 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
05:09:00 <benmachine> heh
05:09:18 <benmachine> @type Prelude.flip -- the normal one
05:09:19 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
05:09:21 <tensorpudding> oh, caleskell
05:09:31 <ski> @type flip (fmap . flip ($))
05:09:32 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
05:09:41 <tensorpudding> @type \f x -> (flip fmap) f ($ x)
05:09:42 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
05:09:42 <ski> @type \fab a -> fmap ($ a) fab
05:09:43 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a -> b) -> a -> f b
05:10:01 <hatds> does getLine pause all threads?
05:10:18 <benmachine> ski: ruining it :(
05:10:22 <benmachine> :P
05:10:28 <benmachine> hatds: don't think so
05:10:38 <ski> (sorry, ruining what ?)
05:10:56 <benmachine> I was trying to make people work it out themselves
05:11:09 <benmachine> but there wasn't really a good reason for me doing so
05:11:15 <ski> oh, sorry. i didn't notice that
05:11:26 <liff> couldn't quite figure it out so thanks :)
05:11:39 <benmachine> 'sfine
05:11:51 * benmachine wonders if functorflip is equivalent to fmap
05:12:00 <benmachine> oh, I guess not
05:12:09 <liff> what would you call that operation though?
05:12:31 <benmachine> liff: do you know about ((->) r) being a functor?
05:12:57 <Botje> ((->) r) is the functor you love to hate
05:13:04 <benmachine> heh
05:13:15 <benmachine> what's wrong with it
05:13:20 <tensorpudding> @pl \f x -> fmap ($ x) f
05:13:20 <lambdabot> flip (fmap . flip id)
05:13:35 <liff> well i sort of know that it is but don' t really know how to make good use of it
05:13:40 <tensorpudding> damn
05:13:43 <tensorpudding> flip id?
05:13:50 <benmachine> tensorpudding: ($) = id
05:13:55 <tensorpudding> yeah
05:14:00 <tensorpudding> well
05:14:01 <Botje> @pl \xs -> xs == reverse xs -- liff: that's one use
05:14:01 <lambdabot> ap (==) reverse
05:14:10 <tensorpudding> @type flip ip
05:14:11 <lambdabot> Not in scope: `ip'
05:14:12 <tensorpudding> @type flip id
05:14:13 <lambdabot> forall a b. a -> (a -> b) -> b
05:14:27 <tensorpudding> clever girl
05:14:34 <ski> @type \f fa -> flip (fmap (flip ($)) fa) f
05:14:35 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
05:14:50 <benmachine> liff: well, you get something interesting if you put that functor into the function you just made
05:14:56 <poucet> @pl \f fa -> flip (fmap (flip ($)) fa) f
05:14:56 <lambdabot> flip (flip . fmap (flip id))
05:15:53 <benmachine> @type \f fa -> flip (flip fa) f
05:15:54 <lambdabot> forall a a1 b. a -> (a -> a1 -> b) -> a1 -> b
05:16:04 * benmachine confuses self
05:16:29 <benmachine> liff: basically, using f = (r ->) then the function you asked for is just flip
05:16:41 <benmachine> so your function is a generalisation of flip
05:16:49 <benmachine> don't know if that helps though :P
05:17:31 <liff> i was actually looking to use it with a map of functions, i.e. Map t (a -> b) so that i could do Map.lookup x m `andApply` y (where andApply = flip (fmap . flip ($)))
05:18:31 <benmachine> imo andApply doesn't benefit from being pointfree
05:18:39 <benmachine> @unpl flip (fmap . flip id)
05:18:39 <lambdabot> (\ b c -> fmap (\ f -> f c) b)
05:18:46 <benmachine> wait hmm
05:19:04 <benmachine> no that's sort of right
05:19:18 <benmachine> except I'd do andApply b c = fmap ($ c) b
05:20:02 <benmachine> you could equally do ($ y) `fmap` Map.lookup... directly
05:20:09 * ski might have called it `applyEach', in this instance
05:20:28 <ski> (or maybe `eachApply' .. hm)
05:21:03 <liff> indeed
05:21:10 <Jonno_FTW> @src tail
05:21:11 <lambdabot> tail (_:xs) = xs
05:21:11 <lambdabot> tail []     = undefined
05:23:00 <liff> i guess it makes more sense to put the application on the left side
05:23:07 <liff> of lookup that is
05:23:31 <benmachine> it just saves you the trouble of defining the extra function
05:26:15 <liff> i don't think defining extra functions as trouble :)
05:26:32 <liff> naming them, otoh...
05:53:07 <tensorpudding> @type fix flip
05:53:08 <lambdabot> forall a b. a -> a -> b
05:53:44 <sepp2k> @type flip flop
05:53:45 <lambdabot> Not in scope: `flop'
05:53:55 <tensorpudding> @type flip flip flip flip
05:53:56 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *) b1. (Functor f, Functor f1) => f1 ((f (a -> b) -> a -> f b) -> b1) -> f1 b1
05:59:58 <tsou> I'm reading a rather-old paper by Hutton, "Monadic Parsing in Haskell".  There, he uses the built-in classes MonadZero and MonadPlus.  What has happened to them? ;)
06:00:22 <tensorpudding> MonadPlus is still around
06:00:37 <Saizan> MonadZero got lumped into MonadPlus
06:00:42 <tensorpudding> @type mplus
06:00:43 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
06:00:50 <tensorpudding> @type mzero
06:00:51 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a
06:02:59 <tsou> thanks!
06:12:23 <ehamberg> is there a “built-in” function for finding the /index/ of the largest element in a list? i tried hoogling “[a] -> Int” and “[a] -> (a -> a -> Comparing) -> Int” but couldn't find anything.
06:13:59 <Botje> don't think so
06:14:15 <pozic> ehamberg: the first one?
06:14:45 <pozic> ehamberg: find largest [2,2,2,2] => ?
06:15:03 <aledge> why not maximumBy (<= . snd) . zip [1..]
06:15:11 <aledge> err
06:15:26 <aledge> fst . maximumBy (<= . snd) . zip [1..] I suppose
06:15:38 <ehamberg> pozic: a number between 0 and 3 ;)
06:16:03 <mm_freak> > maximumBy (compare `on` snd) . zip [1..] $ [1,3,4,1]
06:16:04 <lambdabot>   (3,4)
06:16:09 <mm_freak> > fst . maximumBy (compare `on` snd) . zip [1..] $ [1,3,4,1]
06:16:10 <lambdabot>   3
06:16:20 <aledge> oh, durr
06:16:21 <mm_freak> oh well, indices start at 0
06:16:22 <aledge> zip [0..]]
06:16:23 <aledge> haha
06:16:25 <aledge> yeaah
06:16:27 <mm_freak> > fst . maximumBy (compare `on` snd) . zip [0..] $ [1,3,4,1]
06:16:28 <lambdabot>   2
06:16:34 <mm_freak> there you go =)
06:17:07 <mm_freak> ehamberg: do you need the index to access the element or does your algorithm involve computing the index?
06:17:12 <ehamberg> mm_freak: thanks. that was much more elegant than what i wrote the last time. :)
06:17:28 <ehamberg> mm_freak: i need the index for access.
06:17:38 <mm_freak> then consider using a different data structure
06:17:43 <mm_freak> lists may not be what you want
06:18:03 <mm_freak> try arrays (Data.Array) or vectors (Data.Vector from the 'vector' package)
06:18:18 <mm_freak> note that random access on a list is slow
06:18:35 <Saizan> or Data.Sequence
06:18:58 <ehamberg> right. you may actually have a point. i'm using list more out of habit than anything else.
06:20:02 <ehamberg> thanks :)
06:20:32 <mm_freak> or ask yourself whether you really need random access ;)
06:21:23 <ski> > prod [sum,product,product,sum,sum,product]
06:21:24 <lambdabot>   [10,4,2,2,1,1]
06:21:43 <ben> the fuck
06:21:46 <pozic> Lists are only useful for co-data. In all other cases sequences are better. IMHO, the compiler should optimize trivial uses of sequences to lists or arrays or something faster.
06:22:12 <Kagami`> :t prod
06:22:13 <lambdabot> forall a. [[a] -> a] -> [a]
06:22:24 <Kagami`> @src prod
06:22:24 <lambdabot> Source not found. Sorry.
06:22:41 <ben> prod [head]
06:22:42 <ben> > prod [head]
06:22:43 <lambdabot>   [* Exception: Prelude.head: empty list
06:22:54 <ben> > prod [const 1]
06:22:55 <lambdabot>   [1]
06:23:13 <applicative> :t product
06:23:14 <lambdabot> forall a. (Num a) => [a] -> a
06:23:29 <Kagami`> > prod [sum]
06:23:30 <lambdabot>   [0]
06:23:46 <applicative> It is starting to make sense.
06:23:53 <Botje> > prodc [id]
06:23:54 <lambdabot>   Not in scope: `prodc'
06:23:56 <Botje> > prod [id]
06:23:57 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
06:24:01 <Botje> aww
06:24:13 <Kagami`> > prod [sum, sum]
06:24:14 <lambdabot>   [0,0]
06:24:19 <maltem> > prod [f,g,h] :: [Expr]
06:24:21 <lambdabot>   [f [g [h []],h []],g [h []],h []]
06:24:36 <ski> (having fun, yet ?)
06:24:48 <applicative> your freaking me out
06:25:15 <mm_freak> @djinn [[a] -> a] -> [a]
06:25:15 <lambdabot> Error: Undefined type []
06:25:16 <applicative> where is the prod function?
06:25:21 <ski> (oh, and sorry, `prod' is just a nonsense name, since i couldn't think of anything appropriate)
06:25:30 <ski> applicative : i whispered it to lambdabot
06:25:37 <applicative> oh
06:26:07 <ski> > take 7 $ covi (repeat (leastPrimeFactor . succ . product))  -- a list containing only primes
06:26:08 <lambdabot>   [2,3,7,43,13,53,5]
06:26:31 <applicative> :t covi
06:26:32 <lambdabot> forall a. [[a] -> a] -> [a]
06:26:45 <ski> .. similar, but different
06:27:25 <applicative> > covi [head]
06:27:26 <lambdabot>   [* Exception: Prelude.head: empty list
06:27:28 <maltem> @check \xs -> not (null xs) ==> head (prod xs) == foldr ($) [] xs
06:27:29 <lambdabot>   Not in scope: `prod'
06:27:34 <maltem> bah
06:28:27 <mm_freak> > take 41 . map (\n -> n^2 - n + 41) $ [0..]
06:28:28 <lambdabot>   [41,41,43,47,53,61,71,83,97,113,131,151,173,197,223,251,281,313,347,383,421...
06:28:38 <applicative> > covi (\x -> if (not.null) x then head x else 'a')
06:28:39 <lambdabot>   The lambda expression `\ x -> ...' has one argument,
06:28:39 <lambdabot>  but its type `[[a] ->...
06:28:46 <ski> > covi (const 0 : const 1 : repeat (\(a0:a1:_) -> a0 + a1))
06:28:47 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
06:28:58 <applicative> > covi [(\x -> if (not.null) x then head x else 'a')]
06:29:00 <lambdabot>   "a"
06:29:17 <mm_freak> :t covi
06:29:18 <lambdabot> forall a. [[a] -> a] -> [a]
06:29:43 <mm_freak> what does that function do?
06:29:53 <applicative> > prod [(\x -> if (not.null) x then head x else 'a')]
06:29:54 <lambdabot>   "a"
06:30:06 <applicative> ski is leaving it to you to figure out
06:30:27 <mm_freak> > covi [sum]
06:30:28 <lambdabot>   [0]
06:30:32 <mm_freak> > covi [product]
06:30:33 <lambdabot>   [1]
06:30:41 <mm_freak> > covi [(\[] -> 0)]
06:30:43 <lambdabot>   [0]
06:30:46 <ehamberg> so, has anyone written the “when to use lists, vectors, arrays and sequences” blog post? ;)
06:30:59 <mm_freak> > covi [(\[] -> 0), (\[] -> 0)]
06:31:00 <lambdabot>   [0,* Exception: <interactive>:1:160-167: Non-exhaustive patterns in lambda
06:31:07 <mm_freak> > covi [(\[] -> 0), (\[[]] -> 0)]
06:31:08 <lambdabot>   No instance for (GHC.Num.Num [t])
06:31:08 <lambdabot>    arising from the literal `0' at <inter...
06:31:20 <mm_freak> > covi [(\[] -> 0), (\[0] -> 0)]
06:31:21 <lambdabot>   [0,0]
06:31:30 <applicative> ehamberg, isn't there discussion in RWH
06:31:32 <mm_freak> > covi [(\[] -> 0), (\[0] -> 1), (\[1] -> 3)]
06:31:33 <lambdabot>   [0,1,* Exception: <interactive>:1:185-193: Non-exhaustive patterns in lambda
06:31:47 <mm_freak> > covi [(\[] -> 0), (\[0] -> 1), (\[0,1] -> 3)]
06:31:48 <lambdabot>   [0,1,* Exception: <interactive>:1:189-199: Non-exhaustive patterns in lambda
06:31:54 <ski> maltem : intriguing that that `Expr' trick worked ..
06:32:00 <pokoko222> is 1 the reverse number of 100?
06:32:02 <pokoko222> i do euler problems involving reversing numbers, and i dont know what to do with these cases
06:32:05 <pokoko222> is 1 the reverse number of 100?
06:32:11 <pokoko222> or numbers ending with 0 have no reverse?
06:32:15 <ski> > reverse 100
06:32:16 <lambdabot>   No instance for (GHC.Num.Num [a])
06:32:16 <lambdabot>    arising from the literal `100' at <int...
06:32:47 <ehamberg> applicative: i'll have a look. :)
06:32:57 <ski> > covr [(\[] -> 0), (\[0] -> 1), (\[0,1] -> 3)]  -- mm_freak
06:32:57 <mm_freak> > covi [join, join, join]
06:32:58 <lambdabot>   [0,1,3]
06:32:58 <lambdabot>   [[],[],[]]
06:33:10 <mm_freak> > covi [const [0], join, join, join]
06:33:11 <lambdabot>   [[0],[0],[0,0],[0,0,0,0]]
06:33:32 <mm_freak> ok, that gets us somewhere
06:33:45 <gwern> another reason to disliek '--' - it confuses people like malcolm wallace when reading diffs
06:33:47 <sepp2k> pokoko222: That should be defined as part of the problem description.
06:34:12 <pokoko222> it is not
06:34:23 <mm_freak> pokoko222: which problem is it?
06:34:29 <pokoko222> 55
06:34:31 <ski> (`covr' is a small variation of `covi' ..)
06:34:33 <pokoko222> lychrel numbers
06:35:20 <sepp2k> pokoko222: In that case I'd think the reverse of 100 is 1.
06:35:20 <mm_freak> pokoko222: yes 1 seems to be the "reverse" in that sense
06:35:29 <pokoko222> tnx
06:35:34 <mm_freak> it doesn't define what a reverse is, but it gives examples, so you can work it out
06:35:42 <sepp2k> Because otherwise the problem wouldn't be well-defined.
06:36:10 <pokoko222> well it does not say anything on these cases
06:36:18 <applicative> ehamberg, So far I see http://book.realworldhaskell.org/read/data-structures.html
06:36:29 <applicative> but it doesn't have a general discussion.
06:39:45 <ski> > (leastPrimeFactor `graph`) `map` [2..]
06:39:46 <lambdabot>   [(2,2),(3,3),(4,2),(5,5),(6,2),(7,7),(8,2),(9,3),(10,2),(11,11),(12,2),(13,...
06:41:41 <applicative> > covi [((leastPrimeFactor `graph`) `map`)]
06:41:42 <lambdabot>   Occurs check: cannot construct the infinite type: a = [(a, a)]
06:42:06 <yitz> preflex: seen quicksilver
06:42:07 <preflex>  quicksilver was last seen on #haskell 3 hours, 10 minutes and 3 seconds ago, saying: shame!
06:42:21 <quicksilver> yitz: I deny everything. You can't prove it.
06:42:27 <yitz> shame!
06:42:29 <applicative> > covi [((leastPrimeFactor `graph`) `foldr` 0)]
06:42:30 <lambdabot>   Couldn't match expected type `b -> b'
06:42:30 <lambdabot>         against inferred type `(a, a)'
06:42:49 <applicative> sorry lambdabot
06:43:12 <yitz> quicksilver: please see my post i just sent in to the cafe on the topic of the Num instance for ByteString.
06:43:37 <yitz> @vixen sorry lambdabot
06:43:38 <lambdabot> it's okay, i forgive you
06:43:52 <ski> @type ((leastPrimeFactor `graph`) `map`)
06:43:53 <lambdabot> forall a. (Integral a) => [a] -> [(a, a)]
06:43:54 <quicksilver> yitz: why, is it the kind of thing I'd object to? ;)
06:44:09 <yitz> i guess that's my question. :)
06:44:56 <applicative> I saw a list-taking function and jumped...
06:45:58 <LMolr> Woot. I've just had my distribuited systems teacher accept darcs as case study for the exam. Cool. Nobody here even know that haskell actually *exists*
06:46:10 <ski> (mm_freak,applicative : if you prefer, i could explain what `covi',`covr',`prod' does ..)
06:46:17 <yitz> LMoir: great! where?
06:46:56 <LMolr> in the middle of the fields in northern italy :\
06:46:57 <quicksilver> yitz: I don't see it yet. I think the archives haven't picked it up. I can't get my email right now due to hard disk failure.
06:46:57 <applicative> ski, well, ...?
06:47:08 <applicative> i thought is was the quiz question of the day
06:47:11 <quicksilver> yitz: I'll keep an eye out for it though
06:47:17 <yitz> ok thanks
06:47:19 <SamB_XP> quicksilver: what does that have to do with your email?
06:47:27 <mm_freak> ski: well, it somehow accumulates the function return values starting at the empty list
06:47:55 <yitz> LMoir: sounds beautiful
06:48:13 <quicksilver> SamB_XP: my configured email client is sitting on that machine and I can't be bothered to configure a new client
06:48:31 <quicksilver> given that the machine will be fixed tomorrow and I can live without email till then.
06:48:37 <SamB_XP> quicksilver: what? why can't you use webmail ?
06:48:51 <quicksilver> can't remember if I have a working webmail setup right now :)
06:48:58 <ski> applicative : it sortof was meant as that .. but if you're stuck and want the answer, i can provide it
06:49:06 <applicative> ski: and of course it has to be able to figure what what the empty list is an empty list of
06:49:13 <JoelMcCracken> sortBy (\ ((a, _), (b, _)) -> compare a b) [(1, 2), (2, 1)]
06:49:33 <JoelMcCracken> there is something wrong with the types here, and I'm not sure what it is
06:49:45 <JoelMcCracken> Couldn't match expected type `((t, t1), (t, t2)) -> Ordering'
06:49:45 <JoelMcCracken>            against inferred type `Ordering'
06:49:50 <JoelMcCracken> I would love some help
06:49:53 <applicative> > covi [join, join, join]
06:49:54 <lambdabot>   [[],[],[]]
06:50:00 * ski is not sure what "what the empty list is an empty list of" means, here
06:50:03 <LMolr> yitz: can be. But our universities are so tied to java .. And mine in particular, as it has a multi agent systems hot spot
06:50:16 <applicative> just meant, empty list of Ints, of Chars of whatever
06:50:24 <HandheldPenguin> What's the best way to go through 2 strings comparing each character and summing how many are equal?
06:50:35 <quicksilver> :t sortBy
06:50:36 <SamB_XP> > sortBy (compare `on` fst) [(1, 2), (2, 1)]
06:50:36 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
06:50:36 <yitz> LMolr: oh, i was thinking about the fields in northern Italy
06:50:37 <lambdabot>   [(1,2),(2,1)]
06:50:48 <quicksilver> JoelMcCracken: sortBy expects a 2-argument function
06:50:51 <yitz> LMolr: right, shame to dirty them with Java.
06:50:52 <quicksilver> (curried, that is)
06:50:57 <applicative> But I take it back since its willing to answer  > covi [join, join, join]
06:51:03 <Jafet> > cycle "what the empty list is an empty list of is "
06:51:04 <lambdabot>   "what the empty list is an empty list of is what the empty list is an empty...
06:51:05 <JoelMcCracken> hmm
06:51:09 <quicksilver> JoelMcCracken: you mean \(a,_) (b,_) -> ...
06:51:20 <quicksilver> JoelMcCracken: note, no outer (), no comma in between
06:51:22 <JoelMcCracken> oh, okay
06:51:23 <quicksilver> 2 args, not a tuple.
06:51:53 <quicksilver> :t sortBy (\(a,_) (b,_) -> compare a b)
06:51:54 <lambdabot> forall t t1. (Ord t) => [(t, t1)] -> [(t, t1)]
06:51:56 <JoelMcCracken> awesome
06:52:00 <LMolr> yitz: oh that's cool :D My grandfa just built a new plough. Hehe.
06:52:10 <JoelMcCracken> i thought I had tried that before and gotten a parse error
06:52:10 <SamB_XP> JoelMcCracken: or you could use (compare `on` fst), of course ;-)
06:52:21 <quicksilver> JoelMcCracken: as SamB_XP hinted, that is also written  (compare `on` fst), but I thought you'd like to learn why
06:52:33 <JoelMcCracken> yep, very nice
06:52:55 <mm_freak> ski: got a challenge for you, too =)
06:53:01 <JoelMcCracken> where is `on` ?
06:53:06 <mm_freak> JoelMcCracken: Data.Function
06:53:26 <applicative> > prod [sum]
06:53:27 <lambdabot>   [0]
06:53:28 <JoelMcCracken> thanks
06:53:36 <applicative> > prod [sum,product]
06:53:37 <lambdabot>   [1,1]
06:53:45 <applicative> > prod [sum,product,product]
06:53:46 <lambdabot>   [2,1,1]
06:54:00 <applicative> > prod [sum,summ]
06:54:01 <lambdabot>   Not in scope: `summ'
06:54:05 <applicative> > prod [sum,sum]
06:54:06 <lambdabot>   [0,0]
06:54:12 <applicative> > prod [sum,sum, sum]
06:54:14 <lambdabot>   [0,0,0]
06:54:16 <yitz> LMoir: ok, sounds nice. hope the plough is functional. (ducks)
06:54:31 <applicative> > prod [product]
06:54:32 <lambdabot>   [1]
06:54:36 <mm_freak> > mmSubs [[0], [0,0], [0,0,0]]
06:54:37 <lambdabot>   [[0,0,0,0,0,0],[0,0,0],[0,0,0,0,0,0],[0,0,0],[0,0,0,0,0],[0,0],[0,0,0,0,0],...
06:54:37 <applicative> > prod [product,product]
06:54:38 <lambdabot>   [1,1]
06:54:54 <mm_freak> > mmSubs ["x", "xx", "xxx"]
06:54:55 <lambdabot>   ["xxxxxx","xxx","xxxxxx","xxx","xxxxx","xx","xxxxx","xx"]
06:55:01 <mm_freak> :t mmSubs
06:55:02 <lambdabot> forall a. [[a]] -> [[a]]
06:55:04 <yitz> what are all these crazy functions here?
06:55:24 <SamB_XP> yitz: I'm assuming someone used @let lately
06:55:37 <mm_freak> ski started it =P
06:55:50 <yitz> > leastPrimeFactor 10001
06:55:52 <lambdabot>   73
06:56:02 <applicative> yitz: It "Can you name that function?"  -- I can name that function with three examples, Jack...
06:56:38 <applicative> edwardk will figure it out
06:56:57 <edwardk> of course i will.
06:57:03 <edwardk> what is it that i'm figuring out?
06:57:28 <applicative> > prod [sum,product,product,sum,sum,product]
06:57:29 <lambdabot>   [10,4,2,2,1,1]
06:57:30 <applicative> what is prod
06:57:43 <yitz> edwardk: they defined a whole bunch of @let functions today.
06:57:44 <benmachine> :t prod
06:57:45 <lambdabot> forall a. [[a] -> a] -> [a]
06:57:59 <yitz> edwardk: i figured out what "leastPrimeFactor" does. your turn.
06:58:14 <edwardk> hah
06:58:14 <applicative> > prod [join, join,join]
06:58:15 <lambdabot>   [[],[],[]]
06:58:30 <benmachine> > prod [head]
06:58:31 <lambdabot>   [* Exception: Prelude.head: empty list
06:58:38 <benmachine> hmm
06:58:59 <mm_freak> @let factor n = gcd n . product . takeWhile ((<= n) . (^2)) $ [2..]
06:59:01 <lambdabot>  Defined.
06:59:05 <mm_freak> > factor 12827
06:59:06 <lambdabot>   101
06:59:27 <benmachine> > factor 6561
06:59:28 <lambdabot>   6561
06:59:45 <theorbtwo> > factor 1
06:59:46 <lambdabot>   1
06:59:50 <yitz> > factor 10001
06:59:51 <lambdabot>   73
06:59:56 <theorbtwo> > factor 10
06:59:57 <lambdabot>   2
07:00:14 <ski> yitz : `leastPrimeFactor' was just a means of showing off `covi'
07:00:14 <yitz> mm_freak: at least you could have used 2:[3,5..]
07:00:24 <yitz> awww...
07:00:35 <applicative> > covi [join,join, join]
07:00:36 <lambdabot>   [[],[],[]]
07:00:39 <applicative> was wierd enough
07:00:46 <mm_freak> yitz: sure, but that wouldn't make it look so scary, but rather familiar =)
07:00:55 <edwardk> i think prod might be loeb's paradox
07:00:59 <yitz> mm_freak: got it
07:01:08 <ski> > take 7 $ covi (repeat (leastPrimeFactor . succ . product))  -- lambdabot can't take it to compute more of 'em
07:01:10 <lambdabot>   [2,3,7,43,13,53,5]
07:01:15 <edwardk> loeb x = fmap (\a -> a (loeb x)) x
07:01:28 <ski> edwardk : not quite :)
07:01:34 <edwardk> ski: had the right type =)
07:01:41 <ski> a-*nod*
07:01:48 <edwardk> @type \x -> fmap (\a -> a (loeb x)) x
07:01:49 <lambdabot> Not in scope: `loeb'
07:01:52 <applicative> well, fmap is more general?
07:01:53 <edwardk> er
07:02:16 <edwardk> @type let loeb x = fmap (\a -> a (loeb x)) x in loeb
07:02:17 <lambdabot> forall (f :: * -> *) b. (Functor f) => f (f b -> b) -> f b
07:02:35 <edwardk> applicative: yes, but loeb limited to lists has the same type as the function in question
07:02:56 <edwardk> > prod [length,\x -> x!!0]
07:02:58 <lambdabot>   [1,* Exception: Prelude.(!!): index too large
07:03:00 <applicative> yeah, i know, i just thought that might be ski's reason for denying its loeb
07:03:16 <edwardk> ok, not loeb
07:03:19 <benmachine> > prod [length]
07:03:20 <lambdabot>   [0]
07:03:27 <benmachine> > prod [length,length]
07:03:28 <lambdabot>   [1,0]
07:03:32 <benmachine> > prod [length,length,length]
07:03:33 <lambdabot>   [2,1,0]
07:03:40 * benmachine hmms
07:03:49 <benmachine> > prod [head,length]
07:03:49 <edwardk> i think it looks like a causal version of loeb
07:03:50 <lambdabot>   [0,0]
07:03:53 <theorbtwo> > prod [show a]
07:03:54 <lambdabot>   Couldn't match expected type `[a] -> a'
07:03:55 <lambdabot>         against inferred type `GHC....
07:03:57 <sioraiocht> :t prod
07:03:58 <lambdabot> forall a. [[a] -> a] -> [a]
07:04:02 <sioraiocht> lol what?
07:04:03 <benmachine> it looks like it is applying the function at the head to the tail
07:04:04 <edwardk> where each item can only see the tail
07:04:22 <edwardk> which would explain why its limited to []
07:04:27 <sioraiocht> what does that fucntion do?
07:04:54 <benmachine> :t let prod (f:fs) = f fs : prod fs in prod
07:04:55 <lambdabot>     Occurs check: cannot construct the infinite type: t = [t] -> a
07:04:55 <lambdabot>     Probable cause: `f' is applied to too many arguments
07:04:56 <lambdabot>     In the first argument of `(:)', namely `f fs'
07:04:56 <mm_freak> > prod . repeat $ 0
07:04:57 <lambdabot>   No instance for (GHC.Num.Num ([a] -> a))
07:04:58 <lambdabot>    arising from the literal `0' at...
07:04:58 <benmachine> augh
07:05:09 <mm_freak> > prod . repeat $ join
07:05:11 <lambdabot>   [* Exception: stack overflow
07:05:14 <ski> > covi [length,length,length]
07:05:15 <ski> > covr [length,length,length]
07:05:16 <lambdabot>   [0,1,2]
07:05:17 <lambdabot>   [0,1,2]
07:05:35 <edwardk> prod [] = []; prod (f:fs) = let ts = prod fs in f ts : ts   -- perhaps?
07:05:51 <theorbtwo> > prod (repeat \x->0)
07:05:52 <lambdabot>   <no location info>: parse error on input `\'
07:05:56 <benmachine> :t let prod (f:fs) = f (prod fs) : prod fs in prod
07:05:57 <lambdabot> forall a. [[a] -> a] -> [a]
07:06:02 <benmachine> that's the one
07:06:27 <edwardk> > let { prod [] = []; prod (f:fs) = let ts = prod fs in f ts : ts } in prod [length,length,length]
07:06:28 <lambdabot>   [2,1,0]
07:06:29 <edwardk> there
07:06:36 <edwardk> applicative: told you i'd find it ;)
07:06:51 * benmachine would like to claim partial credit
07:06:52 <applicative> I had complete confidence in you
07:07:07 <applicative> benmachine too
07:07:28 <edwardk> benmachine: ah missed your comment above, yes, definitely =)
07:07:33 <HandheldPenguin> Ok, so this is my attempt @ summing the number of identical characters in a string...
07:07:34 <HandheldPenguin> http://haskell.pastebin.com/46wNuPzK
07:07:51 <benmachine> edwardk: I didn't quite get it but I was close
07:08:47 <edwardk> it is a cute combinator. now, the interesting question is what is the generalization of it
07:09:02 <pookleblinky> Has anyone here played with http://ideone.com/ ?
07:09:08 <YamNad> Yes
07:09:20 <benmachine> :t foldr (\f fs -> f fs : fs) []
07:09:21 <lambdabot> forall a. [[a] -> a] -> [a]
07:09:36 <pookleblinky> I wonder about integrating it into a real-time programming contest site.
07:09:37 <edwardk> benmachine: nice
07:09:46 <mm_freak> :t isqrt
07:09:47 <lambdabot> Not in scope: `isqrt'
07:09:47 * benmachine reckons that'd be a good starting point
07:10:12 <edwardk> yeah i was looking for a nice way to encode it as a catamorphism
07:10:30 <edwardk> :t foldr ((:) =<<) []
07:10:31 <lambdabot> forall a. [[a] -> a] -> [a]
07:10:35 <benmachine> heh
07:10:36 <pookleblinky> Would you spend time watching a live edit session, screaming at people making dumb errors, biting your fingernails as they desperately try to refactor foo.hs into point-free style?
07:11:01 <applicative> poodleblinky, why not?
07:11:23 <applicative> substituting k for d
07:11:40 <pookleblinky> It sounds terribly attractive to me. Yet I've not seen any implementations yet. There may be a reason for that.
07:12:02 <kw317> uhm.. silly question, but is there a problem with linking programs built with 6.13 against libraries built with 6.10?
07:12:22 <Saizan> kw317: you simply can't
07:12:33 <Saizan> or, at least, it's not supported by ghc
07:13:00 <ski> edwardk : nice :), your definition is even simpler than the one i used ;)
07:13:26 <kw317> hmm.. so what's the binary compatibility between versions?
07:13:36 <edwardk> ski: did you define the version in @let ?
07:13:48 <Saizan> kw317: there's none
07:13:56 <ski> yes
07:14:18 <edwardk> ski: what was the motivation? it is a cute little combinator
07:14:29 <ski> (and by "your definition" i mean the pre-`foldr' one)
07:15:00 <edwardk> ski: what was the original?
07:15:32 <ski> a more complicated beast, using `fix' and irrefutable patterns
07:15:37 <edwardk> the foldr one is just a cheesy abuse of the reader monad.
07:15:46 <ski> (i know)
07:15:54 <edwardk> ick
07:16:01 <edwardk> okay, then i'm much happier with mine ;)
07:16:32 <ski> (i probably used that since that's what i had in another function which i modified to produce `prod')
07:16:47 <ski> (.. not having realized that i could skip that in this case)
07:16:50 <edwardk> those being the covi/covr things?
07:16:56 <djahandarie> Any reason why @pl doesn't work on this equation?
07:17:03 <djahandarie> @pl (\x -> 25*((1 + x**6)**1.6 - 3*((1+(x/3)**6)**1/6)+2))
07:17:03 <lambdabot> (25 *) . (2 +) . ap ((-) . (** 1 . 6) . (1 +) . (** 6)) ((3 *) . (/ 6) . (** 1) . (1 +) . (** 6) . (/ 3))
07:17:09 <ski> edwardk : `covr'
07:17:12 <djahandarie> > ((25 *) . (2 +) . ap ((-) . (** 1 . 6) . (1 +) . (** 6)) ((3 *) . (/ 6) . (** 1) . (1 +) . (** 6) . (/ 3))) 10
07:17:13 <lambdabot>   No instance for (GHC.Float.Floating (f b))
07:17:13 <lambdabot>    arising from a use of `GHC.Fl...
07:17:33 <djahandarie> > (\x -> 25*((1 + x**6)**1.6 - 3*((1+(x/3)**6)**1/6)+2)) 10
07:17:33 <edwardk> djahandarie: be warned @pl has a bunch of hinky rewrite rules where arithmetic operators are concerned.
07:17:33 <lambdabot>   9.952693477201402e10
07:17:42 <djahandarie> edwardk, okay, that's what I was suspecting
07:17:58 <djahandarie> @pl (- 3)
07:17:59 <lambdabot> -3
07:18:07 <edwardk> @pl (== 123)
07:18:07 <lambdabot> (123 ==)
07:18:08 <djahandarie> @pl (\x -> x - 3)
07:18:08 <lambdabot> subtract 3
07:18:13 <theorbtwo> It's like LISP, except somebody removed the I an S, and stuck a D on the end.
07:18:19 <djahandarie> @pl (\x -> 3 - x)
07:18:19 <lambdabot> (-) 3
07:18:24 <theorbtwo> s/an S/and P/!
07:18:59 <djahandarie> @pl (\x -> x - 3 - x)
07:18:59 <lambdabot> (-) =<< subtract 3
07:19:07 <djahandarie> (lol)
07:19:45 <ski> edwardk : as for motivation; i appear to come back to `loeb'-like things now and then, thinking there's something i've missed
07:19:53 <yitz> HandheldPenguin: we try never to return undefined as a result. that crashes your program. the whole idea of haskell is to use type safety to avoid that.
07:20:05 <edwardk> ski: fair enough. i do the same thing with recursion schemes ;)
07:20:34 <edwardk> so, what is covr?
07:20:42 <HandheldPenguin> yitz: ty, will change
07:20:55 <ski> (edwardk : .. though, it would be nice to have some kind of computational interpretation of the Grzegorczyc "thing")
07:22:19 <yitz> HandheldPenguin: undefined is useful while you're writing a function if you're not sure what to write somewhere. you temporarily put undefined there, then ask ghci what the type of your function is.
07:22:37 <ski> > covr (repeat ((0:) . map (+1) . concat))
07:22:38 <lambdabot>   [[0],[0,1],[0,1,1,2],[0,1,1,2,1,2,2,3],[0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4],[0...
07:22:42 <yitz> (also, comment out the type signature, of course)
07:22:49 <edwardk> Never had a chance to play with Grzegorczyk logic
07:22:51 <pozic> yitz: fromJust and head still have are non-total functions.
07:23:02 <yitz> pozic: yeah. :(
07:23:35 <edwardk> @type covr
07:23:36 <lambdabot> forall a. [[a] -> a] -> [a]
07:23:56 <edwardk> > covr [length,length,length]
07:23:57 <lambdabot>   [0,1,2]
07:24:07 <yitz> ahah, looks suspiciously similar
07:24:14 <Polarina> Using GLUT.renderString, I can render stroke fonts properly (calling OGL.loadIdentity right prior), but bitmapped fonts are not rendering at all. Am I missing something?
07:24:34 <quicksilver> Polarina: bitmapped fonts use somethign called the raster position
07:24:37 <theorbtwo> > covl [length,length,length]
07:24:38 <lambdabot>   Not in scope: `covl'
07:24:45 <quicksilver> which is entirely separate, and deprecated, and broken in many drivers
07:24:50 <ski> > covi [length,length,length]
07:24:51 <lambdabot>   [0,1,2]
07:24:53 <Polarina> quicksilver, I set OGL.currentRasterPosition to Vector4 0 0 0 0
07:25:11 <theorbtwo> Oh.  r/i, not r/l.  They probably don't go with foldr/l, then.
07:25:11 <quicksilver> I forget the contortions I had to go through to get it working
07:25:16 <creichen> Hi!  I'm having trouble figuring out how to use multiple extensions in one constructor and can't seem to find this documented anywhere.
07:25:18 <quicksilver> I swore never to bother again ;)
07:25:21 <creichen> Here's what I'd like to do:  data Add = forall a, b. Term a, b => Add (a, b)
07:25:35 <edwardk> r = recursive, i = inductive?
07:25:48 <ski> > covi (const 0 : const 1 : repeat (\(a0:a1:_) -> a0 + a1))
07:25:50 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
07:25:54 <ski> edwardk : almost, but not quite
07:26:00 <quicksilver> creichen: the syntax is Term a, Term b, but don't do it
07:26:01 <edwardk> > covr (const 0 : const 1 : repeat (\(a0:a1:_) -> a0 + a1))
07:26:02 <lambdabot>   [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
07:26:10 <djahandarie> Interesting
07:26:13 <yitz> > let f = head . (++[42]) in covi [f,f,f]
07:26:14 <lambdabot>   [42,42,42]
07:26:16 <quicksilver> creichen: typeclass constraints in constructor definitions are a bug in the language and shouldn't be used.
07:26:18 <roconnor> @oesis 0,1,1,1,1,1,1,1,1,1
07:26:20 <lambdabot>  A run of 2^n 0's followed by a run of 2^n 1's, for n=0, 1, 2, ...
07:26:20 <lambdabot>  [0,1,0,0,1,1,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0...
07:26:24 <edwardk> so much for hoping they were the same function ;)
07:26:26 <yitz> > let f = head . (++[42]) in covr [f,f,f]
07:26:27 <lambdabot>   [42,42,42]
07:26:34 <djahandarie> @hoogle covr
07:26:34 <lambdabot> No results found
07:26:44 <djahandarie> Where was this defined
07:26:54 <edwardk> djahandarie: by ski using @let
07:26:55 <yitz> > covi [sum, sum, sum]
07:26:56 <lambdabot>   [0,0,0]
07:27:03 <edwardk> as a puzzle apparently for us to reverse engineer ;)
07:27:06 <creichen> quicksilver: I see.  So proper bounded existentials aren't really supported?
07:27:11 <roconnor> @src covr
07:27:11 <lambdabot> Source not found. I am sorry.
07:27:14 <opqdonut> :t (covi, covr)
07:27:14 <roconnor> @src L.covr
07:27:14 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
07:27:15 <lambdabot> forall a a1. ([[a] -> a] -> [a], [[a1] -> a1] -> [a1])
07:27:27 <ski> creichen : maybe you wanted `data Add = forall a b. (Term a,Term b) => Add (a, b)' ?
07:27:53 <creichen> ski: Terrific, that's it!  Thank you. :-)
07:27:58 <yitz> @check covi = reverse . covr
07:27:58 <lambdabot>   Parse error at "=" (column 6)
07:28:20 <yitz> @check \f covi f == (reverse . covr) f
07:28:20 <lambdabot>   Parse error at "==" (column 11)
07:28:22 <ski> creichen : you'll need to existential-thingy extension, of course
07:28:27 <yitz> @check \f -> covi f == (reverse . covr) f
07:28:28 <lambdabot>   Not in scope: `covi'Not in scope: `covr'
07:28:32 <djahandarie> haha
07:28:33 <quicksilver> creichen: oh, hang on, I didn't see the existential part
07:28:37 <quicksilver> creichen: yes that's fine :)
07:28:38 <Polarina> quicksilver, :(
07:28:43 <edwardk> yitz: shucks no access to @let bindings in @check
07:28:53 <yitz> it was an idea anyway
07:28:54 <quicksilver> creichen: although Add (a,b) is a bit perverse
07:28:57 <quicksilver> creichen: just use Add a b
07:29:11 <edwardk> yitz: wonder if you can use the somewhat magical a b c d, etc. bindings
07:29:21 <yitz> doubt it
07:29:41 <quicksilver> Polarina: believe me it's not worth the pain, they behave oddly and fail completely on some cards
07:29:42 <creichen> quicksilver: Ah, right.  I come from an SML background, so I'm a bit too tupled in my thinking.
07:29:55 <Polarina> quicksilver, what can I do?
07:30:05 <quicksilver> Polarina: use a real font library
07:30:05 <edwardk> ah types don't match
07:30:16 <Polarina> quicksilver, do you have any in mind?
07:30:26 <quicksilver> sdl_tff, gtk, wx
07:30:34 <quicksilver> ttf not tff ;)
07:30:42 <Polarina> Anything else? :)
07:32:04 <ski> > let f = [const 0,const 1,\(x:y:_) -> x + y] in uncurry (==) `graph` (covi f,(reverse . covr) f)  -- yitz
07:32:05 <lambdabot>   (([0,1,1],[1,1,0]),False)
07:32:06 <quicksilver> Polarina: ftgl
07:33:04 <Polarina> quicksilver, thanks.
07:33:07 <ski> @check a == a
07:33:08 <lambdabot>   "OK, passed 500 tests."
07:33:27 <Polarina> quicksilver, I cannot find ftgl on hackage.
07:33:49 <quicksilver> http://hackage.haskell.org/package/FTGL
07:34:08 <Phyx-> > a
07:34:09 <lambdabot>   a
07:34:16 <Phyx-> > p
07:34:17 <lambdabot>   p
07:34:24 <Polarina> quicksilver, thanks.
07:34:56 <Phyx-> > b
07:34:57 <lambdabot>   b
07:35:01 <Phyx-> > bo
07:35:02 <lambdabot>   Not in scope: `bo'
07:35:36 <mm_freak> map snd . filter (\(e,n) -> iterate (\x -> mod (x^2 - 2) n) 4 !! (e-2) == 0) . zip [2..] . map (subtract 1) . iterate (*2) $ 4
07:35:40 <mm_freak> > map snd . filter (\(e,n) -> iterate (\x -> mod (x^2 - 2) n) 4 !! (e-2) == 0) . zip [2..] . map (subtract 1) . iterate (*2) $ 4
07:35:44 <lambdabot>   mueval-core: Time limit exceeded
07:35:50 <mm_freak> hmm
07:35:53 <mm_freak> > take 10 . map snd . filter (\(e,n) -> iterate (\x -> mod (x^2 - 2) n) 4 !! (e-2) == 0) . zip [2..] . map (subtract 1) . iterate (*2) $ 4
07:35:54 <lambdabot>   [7,31,127,8191,131071,524287,2147483647,2305843009213693951,618970019642690...
07:37:26 <ski> > mmSubs ["","a","bc"]
07:37:28 <lambdabot>   ["abc","abc","bc","bc","abc","abc","bc","bc"]
07:37:36 <ski> > mmSubs ["","a"]
07:37:37 <lambdabot>   ["a","","a",""]
07:38:39 * ski suspects `reverse' is involved somewhere ..
07:40:59 <djahandarie> > mmSubs ["1", "2", "3"]
07:41:00 <lambdabot>   ["123","12","13","1","23","2","3",""]
07:41:21 <progo> power series?
07:41:32 <progo> er.. sets :)
07:41:38 <djahandarie> Yes, like a reverse foldr of one or something
07:42:43 <djahandarie> @src mmSubs
07:42:43 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
07:42:56 <mm_freak> =)
07:44:04 <benmachine> @pl 1.6
07:44:05 <lambdabot> 1 . 6
07:44:10 <djahandarie> LOL
07:44:12 <benmachine> no lambdabot that is not 1 composed with 6
07:44:20 <benmachine> djahandarie: I think that was your problem earlier
07:44:33 <ski> @type 1 . 6
07:44:34 <lambdabot> forall a b (f :: * -> *). (Num (a -> b), Num (f a), Functor f) => f b
07:44:41 <djahandarie> Yeah it was
07:44:44 <ski> nice, eh ?
07:44:58 <djahandarie> Can someone fix @pl to not be stupid
07:44:58 <mm_freak> 1 . 6 does indeed work
07:45:05 <mm_freak> > (1 . 6) 0
07:45:06 <lambdabot>   No instance for (GHC.Num.Num (t -> a))
07:45:06 <lambdabot>    arising from the literal `6' at <...
07:45:19 <mm_freak> hmm
07:45:26 <ski> @type let (.) = (Prelude..) in 1 . 6  -- no Caleskell,atm, dammit !
07:45:27 <lambdabot> forall b c a. (Num (b -> c), Num (a -> b)) => a -> c
07:45:57 <mm_freak> :t (Prelude..)
07:45:58 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
07:46:03 * ski wonders why Caleskell doesn't contain `instance Num a => Num (e -> a)' ..
07:46:27 <ski> Cale : maybe that's something to fix ?
07:46:28 <benmachine> ski: doesn't that result in fromInteger = const . fromInteger
07:46:33 <benmachine> which is just plain weird
07:46:41 <djahandarie> > (map concat. mapM ( \x -> [[x],[]))) ["1","2","3"]
07:46:42 <lambdabot>   <no location info>: parse error on input `)'
07:46:47 <djahandarie> ~.~
07:46:47 <ski> benmachine : yes .. just like the other `(e ->)' things
07:46:53 <djahandarie> > (map concat. mapM ( \x -> [[x],[]]))) ["1","2","3"]
07:46:54 <lambdabot>   <no location info>: parse error on input `)'
07:46:57 <djahandarie> fqiuweq
07:47:01 <benmachine> ski: but, then you get like, 3 4 == 3
07:47:05 <djahandarie> > (map concat. mapM ( \x -> [[x],[]] )) ["1","2","3"]
07:47:06 <lambdabot>   [["1","2","3"],["1","2"],["1","3"],["1"],["2","3"],["2"],["3"],[]]
07:47:22 <djahandarie> Pwnt
07:47:46 <djahandarie> mm_freak, is that right?
07:48:12 <ski> benmachine : is that more strange than `return 3 4 = 3' ?
07:48:21 <benmachine> ski: yes
07:48:24 <ski> why ?
07:48:36 <benmachine> because return is a function but usually 3 isn't
07:48:42 <benmachine> or if it is, it's not a constant function
07:48:47 <mm_freak> djahandarie: i don't think so
07:48:51 <ski> (hint, the two `3's in `3 4 == 3' have different types)
07:49:03 <benmachine> oh man supervision time
07:49:04 <mm_freak> > (map concat. mapM ( \x -> [[x],[]] )) ["x", "xx", "xxx"]
07:49:05 * benmachine vanishes
07:49:06 <lambdabot>   [["x","xx","xxx"],["x","xx"],["x","xxx"],["x"],["xx","xxx"],["xx"],["xxx"],...
07:49:11 <ski> > return 3 4
07:49:12 <lambdabot>   3
07:49:14 <mm_freak> > mmSubs ["x", "xx", "xxx"]
07:49:15 <lambdabot>   ["xxxxxx","xxx","xxxxxx","xxx","xxxxx","xx","xxxxx","xx"]
07:49:24 <djahandarie> :D
07:49:31 <zygoloid> different types? really?
07:49:46 <zygoloid> @type \x -> return x undefined
07:49:47 <lambdabot> forall a. a -> a
07:50:20 * zygoloid realises he needed to read further up the scrollback for full context :o
07:50:40 <ski> @type 3 `asTypeIn` \three -> three 4 == 3
07:50:42 <ski> @type 3 `asTypeIn` \three -> 3 4 == three
07:50:44 <lambdabot> forall t a. (Num (t -> a), Num t, Num a) => t -> a
07:50:48 <lambdabot>     Ambiguous type variable `t' in the constraint:
07:50:52 <lambdabot>       `Num t' arising from the literal `4' at <interactive>:1:25
07:50:57 * ski kicks lambdabot
07:51:00 <lambdabot> Plugin `type' failed with: thread killed
07:51:06 <ski> @type (3,3) `asTypeIn` \(threeA,threeB) -> threeA 4 == threeB
07:51:10 <lambdabot> forall t a. (Num (t -> a), Num a, Num t) => (t -> a, a)
07:51:37 <ski> see, one is `t -> a', the other being `a'
07:52:19 <zygoloid> ski: right, i thought we were talking about 'return 3 4' ;-)
07:52:35 <ski> zygoloid : i suppose we was, too :D
07:54:13 <djahandarie> Why in the hell does this function change with the length of its inputs. ~.~
07:55:41 <djahandarie> Okay enough time wasting on this. XD
07:55:59 <ski> @tell Cale in the interest of further confounding newbies, continuing of the "environment"/"point-wise" line of `(.)',`flip', maybe consider adding `instance Num a => Num (e -> a)' to Caleskell ?
07:55:59 <lambdabot> Consider it noted.
07:56:14 <ski> djahandarie : you're referring to `return' ?
07:56:24 <djahandarie> No, mmSubs
07:56:34 <djahandarie> Almost had a solution until the inputs got more complex
07:59:05 <ski> > (length . mmSubs . (`replicate` undefined) `map` [0..]
07:59:06 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
07:59:11 <ski> > (length . mmSubs . (`replicate` undefined)) `map` [0..]
07:59:15 <lambdabot>   mueval-core: Time limit exceeded
07:59:40 <ski> > (length . mmSubs . (`replicate` undefined)) `map` [0 .. 15]
07:59:41 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768]
08:00:10 <cYmen2> I'm conducting a survey. I'm not sure this applies to haskell but still: I've heard hat multiple return statements in a function are bad. Does anybody know why?
08:00:44 <ski> haskell doesn't have "return statements" (in the sense you're thinking of), no
08:01:17 <ski> i believe the usual rationale is that it is harder to keep track of blocks with multiple exit paths
08:01:33 <jaspervdj> cYmen2: You're probably referring to the single exit point philosophy
08:01:35 <Botje> cYmen2: very much not haskell.
08:01:52 <ski> the structured programming paradigm advocated single-entry single-exit control structures
08:02:03 <cYmen2> :)
08:02:09 <cYmen2> that was an awesome sentence
08:03:19 <cYmen2> ski: so would you say you agree? (to make this a little more fun)
08:03:36 <commanace> hey, can anyone tell me what is going wrong here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23381#a23381 ?
08:04:10 <commanace> might seem stupid, but the whole typeclassing/datastuff puzzles me a bit :)
08:04:37 <ski> cYmen2 : well, certainly, if the problem can be conveniently fitted into the single-entry single-exit shape, then that would be preferable to other expressions
08:04:40 <dancor> can't the multiple-returns thing come up in continuation passing style?
08:04:51 <ski> cYmen2 : however, in some cases, there's so good way to do this
08:05:01 <ski> s/so/no/
08:05:09 <dschoepe> commanace: you need exactly what the error message tells you: -XFlexibleInstances when compiling, or {-# LANGUAGE FlexibleInstances #-} in your file
08:05:31 <cYmen2> ski: but you approve of having a return variable and setting it in various places instead of just returning then?
08:05:48 <danderson> is there actually documentation somewhere that lists all the language pragmas and their pros/cons?
08:06:02 <ski> dschoepe : that, or rexpression (or maybe bug-fixing) of the program, so as not to need that .. (not having looked at the code in question)
08:06:03 <danderson> presumably things like FlexibleInstances also have a cost associated, no?
08:06:14 <Saizan> commanace: that instance won't work though
08:06:24 <commanace> dschoepe: i was told that flexinstances is deprecated, so i thought that's probably rather a problem in my code :)
08:06:27 <Saizan> danderson: FlexibleInstances are pretty free
08:06:28 <ski> cYmen2 : i don't really approve of the concept of "setting" at all ;)
08:06:29 <yitz> commanace: to be an instance of ControlSystem, output must map s and d to d for *any type d*
08:06:34 <yitz> not just a single type
08:06:51 <Saizan> FlexibleInstances is not deprecated.
08:07:08 <yitz> commanace: i don' t think that's what you had in mind.
08:07:17 <cYmen2> ski: alright never mind...this really is very off-topic
08:07:36 <cYmen2> let's just put down "haskell is to awesome to deal with shit like that"
08:08:26 <ski> cYmen2 : hehe, i think it's an interesting topic .. probably CPS comes in somewhere as dancor suggested
08:08:26 <commanace> yitz: ok, that rather sounds like what i was planning :) i could solve it with multi-type typeclasses to bind d, right?
08:08:55 <Saizan> multi-parameter, yes
08:08:58 <danderson> Saizan: okay. See, that's why I'd like documentation on all of these. I recently discovered OverloadedStrings, which is amazing when working with bytestrings
08:09:04 <yitz> commanace: oh, i also see that the SimpleSystem type constructor requires a single type as its parameter. As a data constructor, it takes a function of that type to itself.
08:09:07 <danderson> I'm just wondering what other awesomeness I'm missing out on
08:09:13 <Saizan> danderson: isn't there documentation in the ghc manual?
08:09:43 <ski> cYmen2 : to be more clear, i think the style of "setting" a return variable in various branches can be a fine solution in some cases
08:09:51 <danderson> Saizan: doh, probably. Sorry, brain fart somehow disconnected the existence of a manual with my search for an answer.
08:09:59 <yitz> commanace: so SimpleSystem (Int-->Double) will contain a function of type (Int->Double)->Int->Double.
08:10:23 <commanace> yitz: that was my intention...
08:10:37 <yitz> commance: ok then :)
08:11:05 <ski> cYmen2 : if you want, we could maybe discuss this somewhat more in #haskell-overflow
08:11:48 <commanace> yitz: not sure though whether i implemented that correctly... :)
08:12:52 <yitz> commanace: well, your definition of output in your instance doesn't work for any type; only for Int->Double. you need it to work for any type.
08:14:02 <yitz> commanace: i have a feeling that you don't really want a type class here.
08:14:23 <commanace> yitz: might be
08:14:25 <commanace> :)
08:15:20 <yitz> commanace: how about data ControlSystem s a b = ControlSystem (s -> (a -> b) -> a -> b)
08:16:10 <ski> (dancor : did you have anything specific in mind re the CPS ?)
08:16:36 <yitz> commanace: can you give an example of a control system that you are trying to model here?
08:17:04 <commanace> yitz: i'll give that a try... my problem is (i guess people here know that) the oop background that makes one want to model everything as a class :D
08:17:10 <yitz> commanace: i doubt that what i wrote above is what you want either.
08:17:25 <yitz> commanace: the word class means something very different in haskell
08:17:44 <yitz> commanace: there isn't anything like an OO class. we abstract in other ways.
08:17:45 <commanace> yitz: i learned that, yes... but still you can also want to add a lot of interfaces
08:18:11 <yitz> commanace: so give at least one example to start with. two examples even better, so we can generalize.
08:18:40 <commanace> i'm wondering, if that what you were saying about the unbound d is true, should'nt that than work here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23381#a23382
08:18:43 <commanace> ?
08:19:57 <yitz> commanace: no. it doesn't work for *any* type d.
08:20:39 <yitz> commanace: there are very few functions of type d->d for any type d. "id" is about the only example, other than "undefined
08:20:45 <commanace> ok, let's say i want a discrete linear system ... discrete means that d::Int->Double for example... linear means i might add a constructor that takes a few vectors/matrices to build the system
08:20:49 <yitz> " or "error"
08:21:08 <commanace> d :: a->b
08:21:21 <commanace> so i'm mapping from functions to functions of the same type
08:21:41 <aavogt> what about using unbounded integers, or say fixed point numbers?
08:21:48 <commanace> and i thought that the any part should be gone using the multiparam class in the new version
08:22:08 <yitz> commanace: i don't understand why you would want a type class here.
08:22:37 <djahandarie> I can't imagine writing a 258 page thesis
08:22:47 <yitz> commanace: so given a function of type say Int -> Double so what do you want your control system to do to this function?
08:22:51 <commanace> yitz: the abstract idea that i had was that you could more restricted classes to your system
08:22:52 <djahandarie> I don't think I've written that many pages total in my life to this point
08:23:20 <yitz> commanace: abstract ideas are not much use if there is not even a single concrete example
08:23:59 <commanace> yitz: ControlSystem is the most general one... but than i might have DigitalSystem that places restrictions on the system as that the input for example is an enum type
08:24:28 <commanace> yitz: wait, i'll post a first approach that i have made, that's a bit more concrete
08:25:11 <yitz> coshapr: why not shaprpumpkin?
08:26:10 <Botje> is it coMarch again?
08:26:56 <yitz> djahandarie: can you imagine writing a one page thesis? then apply take 258 . repeat
08:26:57 <commanace> yitz: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23383#a23383
08:27:25 <djahandarie> yitz, that makes it sound more intensive. T_T
08:28:03 <yitz> djahandarie: well it means one small step at a time, one day at a time. then you'll get there.
08:28:33 <commanace> yitz: that example worked (probably not the version i've posted cause i messed it up a bit already :-), but an earlier one)
08:28:44 <djahandarie> Well thankfully I won't need to write a PhD thesis any time soon, but I'm reading a 258 page one right now
08:29:58 <coshapr> yitz: Today, I am the dual of shapr.
08:30:15 <commanace> the only problem i had there was that i wanted to be able to combine control systems of different types... and this combination somehow smelled monadic... than however i would need a datatype controlSystem that is able to hold all the different representations of such a system
08:30:36 <coshapr> yitz: Today I am calm, quiet, disciplined and introverted.
08:30:48 <quicksilver> yitz: yes, I agree.
08:30:57 <quicksilver> yitz: that instance would be best in a newtype.
08:31:10 <shapr> Wow, that was boring.
08:31:16 <yitz> quicksilver: i had no doubt you would agree with that part
08:31:44 <yitz> shapr: ok i get it now.
08:31:51 <quicksilver> yitz: ok, which bit did you want feedback on then?
08:32:43 <yitz> quicksilver: that there is a need for a way to prevent importing instances.
08:33:26 <quicksilver> you want to make it possible to make an application which links in two libraries which use incompatible instances?
08:33:39 <yitz> commanace: a type class is not a data type.
08:33:51 <samphippen> how do I generate a random number in haskell?
08:34:21 <aavogt> @hoogle random
08:34:22 <lambdabot> package random
08:34:22 <lambdabot> System.Random random :: (Random a, RandomGen g) => g -> (a, g)
08:34:22 <lambdabot> module System.Random
08:34:33 <yitz> quicksilver: yes, when that unfortunately becomes necessary. and it does happen.
08:35:33 <quicksilver> yitz: I'm not sure that's wise. You can get subtle bugs that way.
08:36:48 <jmcarthur> could try to work with the libraries' authors to get the instances factored out to a separate package
08:36:54 <jmcarthur> that's some hassle
08:37:04 <jmcarthur> oh, *incompatible* instances
08:37:25 <jmcarthur> ... i have no idea what to do in that situation besides convince one of the authors to use a newtype wrapper or something
08:37:25 <commanace> yitz: hm... i'll reconsider my approach... thanks
08:37:42 <yitz> quicksilver: it's certainly not wise. but if you have two existing systems that have inadvertently become incompatible in this way, there must be some escape hatch other than the major refactoring that can be required by changing one of them into a newtype wrapper. the alternative is accepting the risk that any large software project in haskell could potentially die at any moment.
08:37:47 * ski passes shapr to an adjoint functor
08:38:05 <quicksilver> yitz: if the link option made the types different, that would be OK with me.
08:38:33 <quicksilver> so, if library1 had an instance for (Ord Int) and library2 had a different instance for (Ord Int)
08:38:48 <quicksilver> then you'd have to change one of those Ints to 'library2:Int', say.
08:38:54 <quicksilver> that would be a sound transformation.
08:39:28 <quicksilver> (NB - GHC already does this with different versions of the same library; bytestring-0.9.0:ByteString is a distinct type from bytestring-0.9.1:ByteString)
08:39:33 <yitz> quicksilver: perhaps my code does not use either of those instances. i just want to block them both.
08:39:47 <quicksilver> I just propose extending that mechanism to types not owned by the library, if necessary.
08:39:57 <yitz> quicksilver: without needing to rename every instance of that type throughout my code.
08:40:08 <quicksilver> I'm suggesting a link-time transformation
08:40:13 <quicksilver> the source would be the same
08:40:17 <yitz> i see
08:40:20 <quicksilver> you'd just enable the linker to rename types
08:40:29 <quicksilver> to maintain soundness in the presence of incompatible instances
08:40:52 <yitz> so if i don't care about those instance i can let the linker do whatever it pleases and it shouldn't affect me.
08:40:57 <quicksilver> yes.
08:41:13 <jmcarthur> but what about the case that i *do* want one of those instances?
08:41:16 <quicksilver> it's just a way of "proving" that the way you use the libraries doesn't permit the two instances to conflict.
08:41:38 <quicksilver> jmcarthur: that would be fine too as long as you don't try to use them both at the same place.
08:41:51 <yitz> jmcarthur: yes that can come up and you have to be more careful then.
08:42:11 <jmcarthur> i wish type classes weren't so global in natures
08:42:14 <jmcarthur> *nature
08:42:24 <quicksilver> then what you wish for is not type classes
08:42:29 <Alpounet> scoped type class ?
08:42:30 <jmcarthur> indeed
08:42:31 <quicksilver> globality is the very essence of typeclasses
08:42:38 <quicksilver> the thing you want is something else.
08:42:39 <jmcarthur> it's more like modules
08:42:45 <quicksilver> probably not very different from explicit dictionaries.
08:42:45 <Alpounet> yeah
08:42:51 <Alpounet> ML-like modules/functors
08:42:59 <jmcarthur> i wish i could have the implictness of type classes with the scopedness of modules
08:43:13 <yitz> quicksilver: if i could say import Foo (instance Bar Baz, ...) then it specifies exactly what I mean when I use the methods of Bar in this module
08:43:16 <jmcarthur> but i'm a complainer like that :)
08:44:15 <ManateeLazyCat> Have anyone use qtHaskell? I will try it after i install *awesome* KDE4. :)
08:44:33 <yitz> quicksilver: of course that could introduce bugs when some other module i import makes other assumptions.
08:45:28 <Ke> ManateeLazyCat: It will be less awesome once you'll get to 4.4 in which nothing works anymore
08:45:51 <yitz> ManateeLazyCat: what is awesome about KDE4, other than it removes all of the flexibility I used to have in KDE3, and that it sucks up so much of the resources on my old machine that it grinds to a halt?
08:46:14 <Alpounet> ManateeLazyCat, I have played with qthaskell yeah
08:46:21 <ManateeLazyCat> yitz: I never use KDE3 before.
08:46:27 <ManateeLazyCat> Ke: What?
08:46:37 <ManateeLazyCat> Ke: I'm use KDE 4.3.2
08:46:54 <ManateeLazyCat> Alpounet: API fully? Stable?
08:47:06 <Ke> ManateeLazyCat: enjoy it while it lasts ;o)
08:47:07 <Alpounet> it supports the whole Qt
08:47:20 <Alpounet> and soon there'll be a release corresponding to Qt 4.6
08:47:37 <Alpounet> with the new stuffs of 4.6
08:47:38 <Alpounet> (animation + state machine framework, and all)
08:47:38 <ManateeLazyCat> Alpounet: Newest 4.6 API? Fully?
08:47:39 <Alpounet> you can use QtScript, the designer and all
08:47:46 <Alpounet> ManateeLazyCat, yeah, soon
08:47:53 <ManateeLazyCat> Alpounet: How soon? Weeks?
08:47:55 <ManateeLazyCat> :)
08:48:06 <Alpounet> no news from the author of qthaskell
08:48:15 <Alpounet> but it shouldn't be too long
08:49:08 <ManateeLazyCat> Alpounet: Convert Qt -> Haskell is easy, in gtk2hs, i can generate most code automatically, don't need write by hand.
08:50:10 <ManateeLazyCat> Ke: I don't understand, *KDE 4.4 nothing works*? detail?
08:50:41 <ManateeLazyCat> Alpounet: Sorry, It's easy that convert from Qt library to Haskell?
08:50:58 <Alpounet> what do you mean ?
08:51:02 <Alpounet> can you be a bit more precise?
08:51:36 <zygoloid> ManateeLazyCat: i was reading the qtHaskell primer yesterday as it happens. it seems pretty cool, about as good as a wrapper of a very c++-minded library can be
08:52:01 <jmcarthur> Alpounet: i think i'm going to run with geometry shaders after all. all i need to do is use my HTPC for testing (!!) for now and eventually get a laptop with a nice nvidia card so i can use the nvidia opengl drivers
08:52:09 <maxmud> Xerok  hello :)
08:52:15 <zygoloid> they seem to have made the right trade-offs with things like overriding virtual functions, naming, function overloading and so on
08:52:16 <quicksilver> zygoloid: I just wish all those () weren't all over the place.
08:52:35 <jmcarthur> Alpounet: glsl 1.5 seems a lot more featureful than glsl 1.2. it's actually kind of daunting in comparison
08:52:40 <ManateeLazyCat> Alpounet: Example, in gtk2hs, i can write use some template utils that generate haskell API automatically, not need write Haskell code by hand. So i want to know qtHaskell is automatically, or write by developer line by line?
08:52:45 <jmcarthur> should make my DSL a lot more flexible though
08:53:19 <zygoloid> quicksilver: i assume ensuring the overloaded functions are all unary makes the evil typeclass hack work better
08:53:36 <ManateeLazyCat> zygoloid: Sound cool, i will try install qtHaskell and looks it.
08:53:41 <quicksilver> zygoloid: ah that must be it
08:53:53 <quicksilver> zygoloid: I didn't realise that was going on behind the scenes, I just browsed the tutorials
08:54:06 <Alpounet> jmcarthur, okay, nice ! I have to check out what does my graphic support so that I will provide you some feedback/test results ;)
08:54:13 <jmcarthur> heh
08:54:40 <jmcarthur> Alpounet: afaik, nvidia is the only vendor supporting opengl 3 on linux, and that with only some of their newer cards
08:54:52 <ManateeLazyCat> Alpounet: Why i can't see QX11EmbededContainer in qtHaskell API (http://qthaskell.berlios.de/doc/apiGuide/index.html) ? Haven't binding it?
08:55:08 <Alpounet> jmcarthur, I have a nvidia graphic card :)
08:55:10 <Alpounet> quite recent afaik
08:55:14 * gour has ati
08:55:19 <jmcarthur> ah, you might be alright then
08:56:03 <Ke> amd has supported opengl3 since like forever afaik?
08:56:08 <ManateeLazyCat> Alpounet: qtHaskell is young project since 2009? I saw "Copyright @ 2009 David Harley".
08:56:19 <Alpounet> ManateeLazyCat, indeed it seems there isn't any. You should write to David
08:56:21 <Alpounet> btw
08:56:34 <Alpounet> qthaskell would benefit a *lot* from opening itself more to the community
08:56:43 <Alpounet> only few people know about it
08:56:46 * gour agrees
08:56:56 <gour> it's hard to help without knowing how
08:56:58 <Alpounet> and when people hear about it they are quite interested
08:57:02 <maxmud> jmcarthur   hello
08:57:16 <maxmud>  8-)
08:57:21 <ManateeLazyCat> Alpounet: Oh, i want to become a qtHaskell developer.
08:57:27 <gour> otoh, jeremy (wxhaskell dev) also wrote recently that haskell community cannot properly support even one gui binding
08:57:44 <gour> (he was thinking that gtk2hs is also going slow)
08:57:45 <jmcarthur> Alpounet: (un)fortunately, i have some preliminary work to do before i can start on the shader compiler. i'm designing it so that you can design and test your shaders in pure functions e.g. with quickcheck, so i have to implement a lot of the maths in pure code
08:57:48 <ManateeLazyCat> Alpounet: BTW, are you a qtHaskell developer?
08:57:57 <jmcarthur> maxmud: hello
08:58:17 <Ke> does qtHaskell support windows, osX...?
08:58:25 <ManateeLazyCat> gour: gtk2hs developers is too little.
08:58:33 <maxmud> hello
08:58:39 <Alpounet> ManateeLazyCat, no, but I'm likely to be one of the only persons being *really* interested in qthaskell
08:58:39 <ManateeLazyCat> maxmud: hello.
08:59:00 <Alpounet> Ke, as far as GHC does :)
08:59:04 <shapr> hiya maxmud!
08:59:13 <gour> ManateeLazyCat: yeah, everywhere the same situation...wxhaskell also mainly one dev...who wonders that haskell is not more widely adopted then
08:59:16 <Alpounet> since Qt supports a lot of platforms
08:59:48 <maxmud> what  is you  neym ?
08:59:52 <gour> i'm thinking about MeeGo as well
09:00:26 <eevar> qtHaskell is GPL, so meh..
09:00:31 <shapr> maxmud: Are you from Austria?
09:00:36 <ManateeLazyCat> gour: I'm gtk2hs developer too, but recently, have some GtkSocket/GtkPlug multi-thread problem make me crazy, so i want to install qtHaskell, mabye is good choice. :)
09:00:56 <ManateeLazyCat> gour: I'm do some API update work for gtk2hs.
09:00:58 <maxmud> no
09:01:19 <shapr> maxmud: Are you learning Haskell?
09:01:29 <maxmud> ay am from
09:01:33 <gour> ManateeLazyCat: long time i was thinking to use gtk2hs, but it looks that wx & qt are better on mac os which is becoming important platform to support for me
09:01:51 <ManateeLazyCat> Alpounet: Before today, i never use KDE, just use Gtk+/GNOME, because KDE not stable enough, but today, i try it, one word *awesome*.
09:02:04 <maxmud> ay am from AZERBAIJAN 8-)
09:02:17 <ManateeLazyCat> gour: gtk2hs is better than wx
09:02:32 <gour> i use gnome and will continue to do so despite using qthaskell ;)
09:02:34 <ManateeLazyCat> gour: Because gtk2hs can handle memory automatically, you don't care this.
09:03:02 <ManateeLazyCat> gour: You have try qtHaskell? How feeling?
09:03:04 <gour> ManateeLazyCat: well, i know about that faq entry, but i believe that things changed in wx as well
09:03:06 <shapr> maxmud: Cool! Do you use Haskell in Azerbaijan?
09:03:16 <maxmud> shapr  where are you from ? :)
09:03:29 <shapr> maxmud: I am from the USA, from Alabama in the USA.
09:03:49 <Alpounet> ManateeLazyCat, well it's mostly a taste issue. But try not to tie too much KDE and Qt
09:04:06 <ManateeLazyCat> gour: Infact, gtk2hs always make me happy (even API is old), except today make me crazy. GtkSocket always occur `BadWindow` X window error.
09:04:09 <gour> ManateeLazyCat: i tried it long ago...now i cannot install it...waiting for new release or some reply from the main dev...it looked ok as far as i can tell, but reading about qt in general, well - great!
09:04:11 <Alpounet> KDE is much slower than what Qt can offer performance-wise, e.g.
09:04:25 <Alpounet> Qt is amazingly fast.
09:04:38 <Alpounet> AND
09:04:40 <ManateeLazyCat> gour: Install darcs version with GHC 6.8 or GHC 6.12.1
09:04:43 <Alpounet> there's a Qt based coffee machine !
09:05:08 <ManateeLazyCat> Alpounet: How about Qt licence now? ALL GPL?
09:05:13 <gour> i became interested for wx, but it cannot compete with qt these days...some people are interested to do wxqt, but not enough resources, i'm afraid
09:05:22 <maxmud> yes ay am from AZERBAIJAM  Shapr 8-)
09:05:24 <Alpounet> jmcarthur, please keep me posted. If you manage to provide a neat combinator-based interface to the library, I'd be quite interested.
09:05:28 <ManateeLazyCat> gour: I don't like wx
09:05:33 <Alpounet> ManateeLazyCat, Qt is LGPL, GPL or Commercial licensed
09:05:43 <gour> it's GPL3, right
09:05:47 <Alpounet> not only
09:05:50 <Alpounet> also LGPL now ;)
09:05:54 <gour> heh
09:05:55 <Alpounet> (it's been a year iirc)
09:05:59 <eevar> ManateeLazyCat, Alpounet: the qtHaskell license just says GPL, though
09:05:59 <ManateeLazyCat> Alpounet: GPL3 is i want. :)
09:06:04 <shapr> maxmud: Do you write computer programs?
09:06:12 <Alpounet> eevar, yeah, but qthaskell isn't Qt
09:06:19 <gour> ManateeLazyCat: why you don't like wx? gtk+ port for mac os is not in a good shape
09:06:22 <Alpounet> but yeah that can be annoying
09:06:42 <maxmud> Yes  Shapr :)
09:06:59 <shapr> maxmud: Do you write computer programs with Haskell?
09:07:21 <maxmud> do you girl ?
09:07:34 <shapr> Um
09:07:37 <jmcarthur> Alpounet: it won't be really combinator based
09:07:52 <shapr> maxmud: This channel is about writing computer programs, not so much girls.
09:07:57 <jmcarthur> Alpounet: the DSL itself will be somewhat implementation driven (it's explicitly a shader)
09:08:13 <ManateeLazyCat> Alpounet: I will try to install qtHaskell first, then try to write binding for QtX11EmbededContainer/QX11EmbededWidget
09:08:15 <maxmud> no Shapr 8-)
09:08:16 <Alpounet> jmcarthur, what do you want it to look like ?
09:08:26 <jmcarthur> i'm trying to stick with flexibility more than high-level, in this case
09:08:35 <jmcarthur> a combinator library could be built on top of it though
09:08:42 * gour notices that shapr is still alive, just wonder on which continent he lives now
09:08:45 <Alpounet> ManateeLazyCat, heh ok. Why do you need something X11 specific ? The point of Qt is that it's highly portable.
09:09:08 <ManateeLazyCat> Alpounet: Not X11, just name.
09:09:29 <shapr> gour: bok! I live in Alabama, USA! Are you still in Zagreb.hr ?
09:09:34 <ManateeLazyCat> Alpounet: QtX11EmbeddedContainer is Qt library for XEmbedded protocol.
09:09:43 <maxmud> how old are you ?  8-)
09:09:45 <Alpounet> ok
09:10:11 <ManateeLazyCat> Alpounet: You can use XEmbedded protocol write multi-process framework that embedded other Gtk+/Qt program in your program.
09:10:15 <shapr> maxmud: This channel is for programming with Haskell. Do you use Haskell?
09:10:28 <Alpounet> ok, never had to use it
09:10:35 <jmcarthur> Alpounet: it could be viewed as a combinator library if you ignore the explicit compilation step, i suppose
09:10:48 --- mode: ChanServ set +o quicksilver
09:10:52 <ManateeLazyCat> Alpounet: Example, i can use QtX11EmbeddedContainer embedded other program, such as firefox, mplayer in my program.
09:10:58 <gour> shapr: bok! nope, we moved to the country side - northern part of croatia (map google 'hlapicina'), close to the river :-) no more dirty city ;)
09:11:04 <ManateeLazyCat> Alpounet: But all those program running in separate processes.
09:11:13 <Alpounet> ok
09:11:18 <Alpounet> interprocess communication
09:11:28 <ManateeLazyCat> Alpounet: Corresponding Gtk+ library is GtkSocket/GtkPlug.
09:11:33 <maxmud> no Shapr
09:11:50 <shapr> maxmud: Do you want to learn to write Haskell for computer programs?
09:11:53 <ManateeLazyCat> Alpounet: But GtkSocket/GtkPlug make me crazy. :)
09:11:56 <Alpounet> heh
09:11:57 <jmcarthur> although i might be able to make it fit in more nicely than explicit compilation.... basically i'm yet unsure about all that :)
09:12:08 <maxmud> how old are you ? 8-)
09:12:09 <ManateeLazyCat> Alpounet: Like Chrome design model.
09:12:16 <Alpounet> yeah I see
09:12:26 <Alpounet> jmcarthur, okay.
09:12:30 <ManateeLazyCat> Alpounet: Use DBus communication those separate process.
09:13:14 <maxmud> no no no no no  Shapr. :'(
09:13:50 <ManateeLazyCat> Alpounet: qtHaskell have develop version, i found https://developer.berlios.de/project/showfiles.php?group_id=10072 newest version is udpate 2009-10-01
09:13:55 <ManateeLazyCat> ?
09:14:03 <Alpounet> that's the latest release
09:14:07 <shapr> maxmud: I think you may have failed your Turing Test.
09:14:22 <Alpounet> there'll be a new release soon, as I said above.
09:14:43 <ManateeLazyCat> Alpounet: Haven't develop repo? (Darcs or Git)
09:14:49 <shapr> maxmud: The #haskell irc channel is for learning and writing the Haskell programming language.
09:15:20 <maxmud> no Shapr
09:15:50 <maxmud> how old are you Shapr ?
09:16:09 <djahandarie> How do such people find their way here
09:16:11 <shapr> maxmud: If you do not talk about Haskell, I will be forced to remove you.
09:16:29 --- mode: ChanServ set +o shapr
09:16:40 <maxmud> no
09:16:46 <shapr> maxmud: #haskell is for talking about Haskell - http://www.haskell.org/
09:16:47 --- mode: quicksilver set +b *!*opera@91.135.242.*
09:16:47 --- kick: maxmud was kicked by quicksilver (no need, I will)
09:16:47 <Alpounet> ManateeLazyCat, I can't find it. Ask David Harley :)
09:16:57 <quicksilver> you have too much patience some times shapr
09:16:59 <quicksilver> you're just so nice.
09:17:18 <ManateeLazyCat> Alpounet: Thanks for your help. I try qtHaskell now. :)
09:17:32 <quicksilver> nobody who genuinely has poor english spells it like a silly phonetic representation of a heavy accent.
09:17:48 <shapr> quicksilver: And sometimes people who have trouble communicating end up being community members because of that :-)
09:18:03 <shapr> Consider me the Asperger's outreach program.
09:18:14 <quicksilver> I always have ;)
09:18:16 <shapr> haha
09:18:22 <shapr> And I mean that in both ways ;-)
09:18:25 --- mode: shapr set -o shapr
09:18:32 --- mode: quicksilver set -o quicksilver
09:19:38 <gour> 645 entities here and, iirc, all due to shapr!
09:20:07 <shapr> Nowadays, due to dons!
09:20:28 <shapr> And Cale
09:20:46 <gour> well, pioneers are always pioneers
09:20:54 * ManateeLazyCat Haskell really need a *awesome* program to force Haskell GUI library.
09:20:58 * gour is today happy archlinux user thanks to dons
09:21:27 <gour> ManateeLazyCat: i plan to write on gui, but probably it won't be awesome :-D
09:21:31 <gour> *one
09:21:33 <shapr> I am reflexively a pioneer, it's true.
09:22:16 <gour> shapr: still freelancer?
09:22:38 <shapr> No, unemployed student, getting my CS degree in northwest Alabama. I would freelance if I could find some work :-)
09:22:45 <ManateeLazyCat> gour: I have write one gui program base on gtk2hs (http://farm3.static.flickr.com/2628/3952175905_9295a7421a_o.png), but now i want to try qtHaskell for compare. I found qtHaskell documentation is more completely.
09:23:48 <gour> ManateeLazyCat: cool. i'm interested to hear about comparison, although i decided to use qthaskell...out of qt, not much opportunity to target mobile devices
09:23:53 <ManateeLazyCat> gour: If qtHaskell is fully enough, i will try to do a convert.
09:23:58 <jmcarthur> dang, i just lost a race to get the 10000th commit in my company's svn repository
09:24:15 <ManateeLazyCat> gour: Infact, gtk2hs is cool enough.
09:24:18 <jmcarthur> i got 9999 and 10001
09:24:28 <gour> jmcarthur: next compete using darcs :-)
09:24:31 <shapr> gour: You know of any freelancing work in hr?
09:24:34 <jmcarthur> i thought i had an edge because use darcs locally
09:24:43 <jmcarthur> so i just committed some patches from that
09:24:50 <jmcarthur> but somebody squeezed in there
09:24:53 <ManateeLazyCat> gour: You can just use 10 lines write a fully terminal with gtk2hs.
09:25:07 <jmcarthur> *because i use darcs locally
09:25:23 <ehamberg> jmcarthur: i got commit 100 000 this summer with the diff ‘>’ → ‘<’. that wasn't popular at all. even if it fixed a grave bug :P
09:25:28 <gour> shapr: web design, but that's monkey business...we're doing startup with counselling/homeopathy
09:25:42 <jmcarthur> ehamberg: yeah the guy that got this one had a one line commit
09:25:49 <ehamberg> ;-)
09:25:52 <jmcarthur> it was meaningful, but it was only one line :(
09:25:56 <zygoloid> jmcarthur: i got change 20000 here, but missed bug 10000 (got 9999 and 10001 though)
09:26:01 <jmcarthur> i had a much larger one
09:26:38 <shapr> gour: I'd take web design if I could do it remotely.
09:27:25 <ManateeLazyCat> gour: I never try qtHaskell, but have use gtk2hs some time, gtk2hs is fully enough, most important library is update.
09:28:25 <gour> shapr: also some kind of consulting, maybe for IT, i may ask some remote-friend who may be doing something like that...what do you mean remotely? living in croatia and doing remotely?
09:28:50 <shapr> gour: That would be cool, but I'm living in the USA until I finish my CS degree.
09:29:31 <gour> shapr: recently i've found out that many support guys who work for http://www.subhosting.net/ are living in cro. how much you need to finish?
09:29:38 <shapr> Lots.
09:30:32 <gour> shapr: otoh, getting salary in cro and living in usa...hmm, you'd have to adjust ;)
09:31:18 <gour> shapr: slovenia is very close to hear and there is better situation
09:31:45 <shapr> Hm, I wonder if anyone is looking for Haskell remote work?
09:31:55 * ManateeLazyCat KDE4 files search is idiot and slow.
09:32:24 <gour> shapr: haskell web design, using e.g. yesod?
09:32:31 <zygoloid> shapr: you hiring or employee'ing?
09:32:43 * Alpounet would be interested
09:32:51 * jmcarthur too!
09:32:51 <shapr> zygoloid: Employee'ing
09:33:06 <jmcarthur> if only it was true
09:33:19 <gour> zygoloid: don't believe him. he is his own guy
09:33:29 <Alpounet> that's not like there is any haskell company in France...
09:33:45 <shapr> Alpounet: Start one? Work for the Belgian Haskell company?
09:34:49 <ManateeLazyCat> Alpounet: Are you French?
09:34:54 <Alpounet> shapr, still studying, but I'm actually thinking more and more about it when done with the studies
09:35:07 <Alpounet> shapr, the Belgian Haskell company ? uh ?
09:35:17 <shapr> Isn't Tupil Haskell based?
09:35:29 <shapr> http://tupil.com/ ?
09:36:21 <shapr> They publish Haskell open source stuff at least - http://tupil.com/opensource.html I'm still not sure if their iPhone games are produced using Haskell.
09:37:31 <Alpounet> hmm interesting shapr, thanks
09:37:48 <Alpounet> but Netherlands :/
09:37:49 <ManateeLazyCat> Alpounet: How many active developer for qtHaskell?
09:38:09 <gour> ManateeLazyCat: probaly only one, until we change it
09:38:10 <Alpounet> ManateeLazyCat, the whole qthaskell thing has been done by David Harley, alone.
09:38:30 <ManateeLazyCat> Alpounet: Cool, i like to join. :)
09:38:31 <gwern> qthaskell was hard to install last I checked
09:38:46 <Alpounet> ManateeLazyCat, try to contact him
09:38:58 * gour wonders why c2hs is not more widely adopted within haskell community as the 'tool of choice for creating bindings'
09:39:00 <ManateeLazyCat> Alpounet: Yes, i will.
09:39:02 <Alpounet> gwern, that's mostly due to a call to "gmake" instead of make
09:39:15 <ManateeLazyCat> gour: c2hs is awesome
09:39:16 <Alpounet> people mostly have a "make" program, not "gmake"
09:39:46 <ManateeLazyCat> gour: Infact, c2hs generate most all code of gtk2hs.
09:39:47 <gour> ManateeLazyCat: it is, but so little bindings on hackage are done with it...mostly they use hsc2hs
09:40:33 <ManateeLazyCat> gour: But for some complicated function, you still need write Haskell code line by line.
09:40:58 <gour> ManateeLazyCat: sure, c2hs is simply not deployed much
09:41:29 <ManateeLazyCat> gour: Sometimes, you need write C code to help binding.
09:42:38 <gwern> > concat [1..10]
09:42:40 <lambdabot>   No instance for (GHC.Enum.Enum [a])
09:42:40 <lambdabot>    arising from the arithmetic sequence...
09:42:52 * hackagebot hmk 0.9.7 - A make alternative based on Plan9's mk.  http://hackage.haskell.org/package/hmk-0.9.7 (MathieuBoespflug)
09:43:11 <ManateeLazyCat> gour: The author of gtk2hs is hero, maintain gtk2hs so long time.
09:43:14 <djahandarie> >concat [1..5] [6..10]
09:43:18 <djahandarie> lol
09:43:22 <djahandarie> >concat [[1..5],[6..10]]
09:43:28 <djahandarie> fff
09:43:30 <djahandarie> > concat [[1..5],[6..10]]
09:43:31 <gour> ManateeLazyCat: i fully agree
09:43:31 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
09:43:40 <xerox> > (++) [1..5] [6..10]
09:43:41 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
09:43:43 <djahandarie> Why is that space required anyways
09:44:32 <c_wraith> so that evil smileys don't trigger \bot
09:44:36 <c_wraith> >:)
09:45:12 <djahandarie> I see. :P
09:45:57 <Arnar> does anyone have trouble writing \ by hand? I always write lambda and have to reach for the eraser :/
09:46:20 <pikhq> If you're writing Haskell out by hand, just go ahead and write lambda. :P
09:46:24 <medfly> I haven't noticed that
09:46:36 <medfly> oh... on paper?
09:46:40 <ManateeLazyCat> gour: http://farm5.static.flickr.com/4058/4419736703_18d4acb203_o.png
09:46:43 <Arnar> medfly: haha.. yes.. or whiteboard
09:46:49 <progo> It's for us european users with \ being in altgr-+
09:47:00 <medfly> I'm like "well, the \ key is pretty far from the alphabet..."
09:47:06 <Arnar> progo: altgr+ in my case :)
09:47:15 <ManateeLazyCat> gour: I use Emacs reading qtHaskell documentation.
09:47:19 <ManateeLazyCat> gour: :)
09:47:24 <djahandarie> medfly, and you have an eraser key too? :P
09:47:30 <medfly> I have backspace.
09:47:44 <c_wraith> I've heard of european programmers buying US keyboards, just to not have to fight with US-keyboard-centric punctuation in programming languages
09:47:54 <gour> ManateeLazyCat: i also use Emacs, but read qthaskell docs in ff
09:48:03 <Arnar> c_wraith: using us kbd layout is extremely common for programmers in iceland and sweden
09:48:10 <medfly> are US keyboards that different?
09:48:14 <arw_> c_wraith: correct.
09:48:14 <ben> c_wraith: I use the us keymap but have never bothered with getting an actual us keyboard
09:48:15 <Arnar> but US keyboards suck (there is one button missing and the enter key has a weird shape)
09:48:25 <ManateeLazyCat> gour: See my ChmView: http://www.emacswiki.org/emacs/ChmView
09:48:36 <ManateeLazyCat> gour: Reading CHM
09:48:40 <ben> medfly: My native keyboard makes me press altgr-7-9 for {}, []
09:48:42 <c_wraith> arnar: there are two variants of us keyboards, as far as the enter key shape.  I prefer the ones with a rectangular enter key.
09:48:43 <arw_> medfly: german keyboards have braces on AltGr-8 and stuff...
09:48:48 <ManateeLazyCat> gour: Or use w3m reading all HTML file in Emacs.
09:48:49 <medfly> oh, strange.
09:48:56 <Arnar> c_wraith: rectangular = covers one or two rows?
09:48:58 <pikhq> arw_: There's a rectangular enter key and an L-shaped one.
09:49:00 <medfly> yeah, mine is pretty US like...
09:49:02 <c_wraith> arnar: one row
09:49:02 <ben> also ` is a deadkey
09:49:05 <pikhq> The L-shaped one is an archaicism.
09:49:07 <djahandarie> I have a http://daskeyboard.com
09:49:07 <Arnar> yes.. the rectangluar one-row is the US one
09:49:07 <gour> ManateeLazyCat: hmm, didn't know about it...the other day i had to install xchm
09:49:17 <Arnar> european keyboards have the l shaped one in two rows
09:49:19 <pikhq> Yes. And that's much nicer.
09:49:25 <medfly> I have a US layout I think, and for my native language I alt+shift :P
09:49:27 <medfly> much better.
09:49:38 <ManateeLazyCat> gour: You will found use Emacs reading chm is cool, and support many languages than xchm.
09:49:56 <gour> ManateeLazyCat: but archmage was not working on my distro
09:49:57 <Arnar> c_wraith: but then the button between left-shift and Z is missing on yours, right?
09:50:05 <c_wraith> arnar:  well, having enter be one row makes \ easy to hit.  For haskell!  :)
09:50:13 <ManateeLazyCat> gour: ArchLinux?
09:50:20 <gour> ManateeLazyCat: yep
09:50:22 <c_wraith> arnar: indeed, I'm unaware of any US keyboard with a button there.
09:50:34 <ManateeLazyCat> gour: I never use it, but i think you can compile it source code?
09:50:39 <arw_> c_wraith: doesn't matter, \ is some weird combination anyways. altgr-* afair
09:50:40 <Arnar> c_wraith: the \ is on that button :)  right under the left pinky
09:51:15 <Arnar> if you use us/uk layout that is
09:51:28 <pikhq> Button, to the left of Z? *shudder*
09:51:35 <pikhq> That just makes shift so much harder.
09:51:36 <c_wraith> A friend of mine went to finland a while ago.  She was astounded to report that their keyboards have a 1/2 button. :)
09:51:56 <djahandarie> > (unwords . reverse . words) "My grammar is all backwards"
09:51:57 <silver_> they like to div
09:51:58 <lambdabot>   "backwards all is grammar My"
09:52:15 <Arnar> that function should be called yoda
09:52:15 <silver_> master joda is that you?
09:52:30 <progo> c_wraith, yeah! ½
09:52:50 <progo> so easy to halve anything :sniff:
09:53:06 <djahandarie> Ooops, sent that to the wrong channel anyways, tehe
09:53:10 <silver_> half the world's misery, hunger and wars
09:53:25 <Arnar> and half the temperature as well
09:53:48 <Becquerel> @let yoda = unwords . reverse . words
09:53:50 <lambdabot>  Defined.
09:53:53 <djahandarie> This happens because 2/3 of the people in #japanese are also in #haskell
09:54:21 <silver_> is that true?
09:54:24 <djahandarie> No
09:54:27 <djahandarie> But it feels that way
09:54:27 <djahandarie> :P
09:54:28 <silver_> :(
09:54:44 <djahandarie> We have lambdabot in there!
09:54:45 <pikhq> Just some of the more talkative people in #haskell are in #japanese is all.
09:54:58 <gwern> > maxBound :: Integer
09:54:59 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Integer.Internals.Integer)
09:54:59 <lambdabot>    arising...
09:55:38 <silver_> @more
09:55:43 <zygoloid> @let ½ = 1%2; ¾ = 3 % 4
09:55:43 <lambdabot>   Illegal character ''\189''
09:55:47 <zygoloid> ;(
09:58:22 <djahandarie> lol
09:59:11 <zygoloid> fractions: they're not just hard to type, they're against the law!
10:07:02 <yitz> > let frac '½' = 1%2; frac '¾' = 3 % 4 in frac '½' + frac '¾' -- zygoloid
10:07:03 <lambdabot>   5 % 4
10:08:45 * djahandarie reminds self to read Haskell grammar one day
10:12:27 <sinelaw> copumpkin, is the regions thing meant mainly for safe resource usage?
10:13:01 <sinelaw> because what i'm concerned about, perhaps currently more than safe resources, is a nice compositional interface
10:13:13 <medfly> hi sinelaw :)
10:13:17 <sinelaw> hi medfly
10:19:09 <Nereid_> :t concat . maybeToList
10:19:11 <lambdabot> forall a. Maybe [a] -> [a]
10:19:26 <Nereid_> > map (concat . maybeToList) [ Nothing, Just [1] ]
10:19:27 <lambdabot>   [[],[1]]
10:22:15 <aavogt> @type fromMaybe []
10:22:16 <lambdabot> forall a. Maybe [a] -> [a]
10:22:31 <Nereid_> :t fromMaybe
10:22:32 <lambdabot> forall a. a -> Maybe a -> a
10:22:35 <aavogt> > catMaybes [ Nothing, Just [1] ]
10:22:36 <lambdabot>   [[1]]
10:22:52 <Nereid_> thanks
10:22:54 <Nereid_> :)
10:23:13 <Nereid_> (fromMaybe describes better what I wanted to do)
10:33:27 <ManateeLazyCat> Alpounet: qtHaskell works well with `-threaded` flags?
10:36:32 <jmcarthur> sinelaw: maybe you should be looking into finalizers and stuff instead?
10:37:11 <jmcarthur> i don't really remember what it is you are doing
10:38:44 <djahandarie> Is there some way to dynamically link to other modules at runtime
10:38:47 <aavogt> 54 separate class constraints on one function!
10:39:45 <aavogt> djahandarie: plugins or ghc-api (more nicely seen through hint) or just call ghc on that code at runtime (like xmonad or yi)
10:40:17 <aavogt> I'm not sure about plugins (formerly hs-plugins?) working with the most recent ghc though
10:40:23 <jmcarthur> aavogt: !!
10:40:28 <djahandarie> I did see ghc-api
10:40:28 <jmcarthur> 54!?
10:42:09 <Alpounet> ManateeLazyCat, it should :)
10:42:17 <aavogt> jmcarthur: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23384#a23384
10:42:29 <aavogt> almost longer than the implementation ;)
10:42:45 <Alpounet> what the hell
10:42:50 <ManateeLazyCat> Alpounet: That's cool.
10:42:52 <The_third_man> http://en.wikipedia.org/wiki/Do_not_want
10:42:54 <ManateeLazyCat> Alpounet: Thanks.
10:43:16 <djahandarie> Bahaha... "This page is in Danish. Would you like to translate it?"
10:43:22 <zygoloid> aavogt: hooooooly cow
10:43:28 <djahandarie> Apparently Haskell is danish now
10:43:34 <djahandarie> And yeah, wow aavogt
10:43:44 <aavogt> but it's inferred
10:44:53 <jmcarthur> aavogt: what is that from?!
10:45:36 <djahandarie> Don't any of those constraints overlap?
10:46:05 <aavogt> djahandarie: hlist does use some overlapping instances I believe
10:46:42 <aavogt> jmcarthur: basically every time you want to map a function over a hlist, that adds another class constraint
10:46:52 <jmcarthur> :o
10:47:04 <djahandarie> lol.
10:47:12 <aavogt> so the whole implementation is more or less visible through the type
10:48:54 <djahandarie> All my channel got eerily silent all of a sudden
10:49:03 <djahandarie> -s
10:49:07 <jmcarthur> all your channel are belong to us
10:49:21 <silver_> bz
10:49:44 <djahandarie> For great justice
10:52:13 <zygoloid> take off every +d
11:02:18 <djahandarie> Ooh, found an interesting paper modeling quantum computing in Haskell
11:02:25 <djahandarie> By Amr Sabry from Indiana Uni
11:02:57 <ski> Arnar : seconded
11:03:27 <Arnar> ski: eh?
11:05:08 <ski> re typing lambda by hand
11:06:14 <Arnar> ah.. yes :)
11:06:50 <pokoko222> what is the bigest integer type haskell supports
11:06:58 <pokoko222> i ned 28 digits for integer
11:07:07 <Arnar> pokoko222: Integer can be as big as your memory can hold
11:07:17 <BONUS> > 1234567890123456789012345678 :: Integer
11:07:18 <lambdabot>   1234567890123456789012345678
11:07:27 <ski> > product [1..100]
11:07:28 <lambdabot>   933262154439441526816992388562667004907159682643816214685929638952175999932...
11:07:47 <pokoko222> wow, what is the limit
11:07:54 <ski> your memory
11:07:55 <BONUS> the sky
11:07:56 <yitz> > length . show . product $ [2..100]
11:07:57 <lambdabot>   158
11:08:01 <pokoko222> awesome :D
11:08:26 <pokoko222> i do a problem in c++ and there is no type for 28 digits so i gotta do a class to handle that or i might as well solve the problem in haskell
11:08:28 <ski> just make sure to use the type `Integer' rather than `Int'
11:08:44 <Arnar> @hoogle [a] -> [(a,Int)]
11:08:45 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
11:08:45 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
11:08:45 <lambdabot> Test.QuickCheck two :: Monad m => m a -> m (a, a)
11:08:50 <ski> > product [1..100] :: Int
11:08:51 <lambdabot>   0
11:08:59 <aavogt> > length (show (maxBound :: Int))
11:09:00 <lambdabot>   19
11:09:06 <aavogt> > length (show (maxBound :: Int64))
11:09:07 <lambdabot>   19
11:09:12 <aavogt> > length (show (maxBound :: Word64))
11:09:13 <lambdabot>   20
11:09:15 <ski> > maxBound :: Int
11:09:16 <lambdabot>   9223372036854775807
11:09:25 <ski> > maxBound :: Int8
11:09:26 <lambdabot>   127
11:10:17 <pokoko222> maxBound :: Integer
11:10:26 <pokoko222> > maxBound :: Integer
11:10:27 <ski> > maxBound :: Integer
11:10:27 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Integer.Internals.Integer)
11:10:28 <lambdabot>    arising...
11:10:28 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Integer.Internals.Integer)
11:10:28 <lambdabot>    arising...
11:10:41 <ski> as you see, there is no `maxBound' for `Integer'
11:10:46 <djahandarie> > maxBound + 1 :: Int
11:10:47 <lambdabot>   -9223372036854775808
11:10:50 <pokoko222> amazing :D
11:10:59 <djahandarie> > minBound - 1 :: Int
11:11:00 <lambdabot>   9223372036854775807
11:11:08 <djahandarie> > subtract minBound :: Int
11:11:09 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
11:11:09 <lambdabot>         against inferred type ...
11:11:11 <aavogt> > maxBound
11:11:12 <lambdabot>   ()
11:11:12 <djahandarie> Oops
11:11:16 <djahandarie> > subtract 1 minBound :: Int
11:11:17 <lambdabot>   9223372036854775807
11:11:24 <ski> djahandarie : `negate' ?
11:11:26 <djahandarie> > subtract minBound 1 :: Int
11:11:27 <lambdabot>   -9223372036854775807
11:11:29 <djahandarie> Damn it
11:11:31 <aavogt> @check maxBound  == minBound
11:11:32 <lambdabot>   "OK, passed 500 tests."
11:11:32 <djahandarie> What returned the error
11:11:38 <ski> aavogt ;)
11:12:57 <djahandarie> I remember there was some function that returned an error if it went past the bounds, instead of overflow
11:13:12 <aavogt> > succ maxBound :: Int
11:13:13 <lambdabot>   * Exception: Prelude.Enum.succ{Int}: tried to take `succ' of maxBound
11:13:30 <yitz> > [maxBound - 5..] :: [Int]
11:13:31 <lambdabot>   [9223372036854775802,9223372036854775803,9223372036854775804,92233720368547...
11:13:50 <yitz> > [maxBound - 2..] :: [Int]
11:13:51 <lambdabot>   [9223372036854775805,9223372036854775806,9223372036854775807]
11:13:55 <ski> > succ ()
11:13:56 <lambdabot>   * Exception: Prelude.Enum.().succ: bad argument
11:14:03 <djahandarie> :t succ
11:14:03 <yitz> > [maxBound - 1..] :: [Int]
11:14:04 <lambdabot> forall a. (Enum a) => a -> a
11:14:04 <lambdabot>   [9223372036854775806,9223372036854775807]
11:14:18 <aavogt> > toEnum 3 :: ()
11:14:18 * ski wonders why that uses a different error message ..
11:14:19 <lambdabot>   * Exception: Prelude.Enum.().toEnum: bad argument
11:14:35 <aavogt> > fromEnum ()
11:14:36 <lambdabot>   0
11:14:44 <djahandarie> ski, succ probably has a specific check for maxBound
11:14:45 <yitz> > iterate (+1) (maxBound -1 :: Int)
11:14:46 <lambdabot>   [9223372036854775806,9223372036854775807,-9223372036854775808,-922337203685...
11:15:00 <Arnar> > let hist = map (\g -> (head g, length g)) . group . sort in hist $ show $ product [1..100]
11:15:01 <lambdabot>   [('0',30),('1',15),('2',19),('3',10),('4',10),('5',14),('6',19),('7',7),('8...
11:15:03 <ski> > () == maxBound
11:15:04 <lambdabot>   True
11:15:10 <ski> @type succ
11:15:11 <lambdabot> forall a. (Enum a) => a -> a
11:15:41 <ski> djahandarie : iirc, `Bounded' is not a superclass of `Enum', so then it couldn't do that (in the general case)
11:15:51 <djahandarie> Hm
11:16:04 <ski> (in the `Int' case, and possibly other cases too, sure)
11:16:25 <ski> (which was why i wondered why not in the `()' case, which is a standard data type)
11:16:39 <yitz> > let hist = map (\g -> (head g, length g)) . group . sort in drop 5 . hist $ show $ product [1..100]
11:16:40 <lambdabot>   [('5',14),('6',19),('7',7),('8',14),('9',20)]
11:16:55 <zygoloid> the Int case looks a lot like the formatting you get when deriving Enum
11:16:59 <zygoloid> (the {Int} bit)
11:17:25 <edwardk> Integer is an instance of Enum, but is not Bounded.
11:17:49 <edwardk> sadly Float and Double are also instances of Enum =(
11:17:55 <djahandarie> > succ maxBound :: Integer
11:17:56 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Integer.Internals.Integer)
11:17:56 <lambdabot>    arising...
11:17:59 <zygoloid> hpaste just broke :(
11:18:02 <yitz> > [False..]
11:18:03 <lambdabot>   <no location info>: parse error on input `]'
11:18:18 * ski str some histogram function in `Data.Array' ..
11:18:30 <ski> .. maybe i'm misremembering, though
11:18:33 <zygoloid> > [False ..]
11:18:34 <lambdabot>   [False,True]
11:18:49 <pokoko222> what was inverse of tail, it has been a while since i did haskell
11:19:12 <ski> pokoko222 : maybe you're after `head' (which is not the inverse of `tail') ?
11:19:15 <zygoloid> tail's not invertible. what do you want? head?
11:19:20 <zygoloid> init, maybe?
11:19:21 <pokoko222> yes
11:19:30 <ski> > init "abcd"
11:19:31 <lambdabot>   "abc"
11:19:34 <ski> > inits "abcd"
11:19:35 <lambdabot>   ["","a","ab","abc","abcd"]
11:19:39 <pokoko222> yep thanks
11:19:51 <zygoloid> > (head "abcd", init "abcd", tail "abcd", last "abcd")
11:19:52 <lambdabot>   ('a',"abc","bcd",'d')
11:19:57 <pokoko222> > tail "abcdefgh"
11:19:58 <lambdabot>   "bcdefgh"
11:20:00 <yitz> > maxBound :: Float
11:20:01 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Types.Float)
11:20:01 <lambdabot>    arising from a use of...
11:20:34 <yitz> > [1..] :: [Float]
11:20:35 <lambdabot>   [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0,11.0,12.0,13.0,14.0,15.0,16.0,17....
11:20:45 <ski> > [(:[]) . head,init,tail,(:[]) . last] `flip` "abcd"  -- mrf ?
11:20:46 <lambdabot>   ["a","abc","bcd","d"]
11:21:17 <conal> jmcarthur: ping
11:21:17 <lambdabot> conal: You have 1 new message. '/msg lambdabot @messages' to read it.
11:21:55 <jmcarthur> conal: pong
11:23:10 <conal> jmcarthur: i'm wondering what to do about INLINE pragmas for vector-space and other libraries.  i love optimizability and clean/elegant/terse code.  and i don't know how to resolve that tension.
11:23:14 <yitz> @type flip
11:23:15 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
11:23:21 <jmcarthur> conal: yeah, me either. it's annoying
11:23:22 <yitz> oh, Caleskell
11:23:41 <jmcarthur> conal: a compiler feature to do it more succinctly would be nice, if we can come up with one
11:23:52 <conal> jmcarthur: i'm thinking exactly the same
11:24:00 <Arnar> @hoogle Arrow a => a b c -> a b d -> a b (c,d)
11:24:00 <lambdabot> Control.Arrow (&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
11:24:04 <conal> jmcarthur: a ghc flag that does what you did manually
11:24:35 <Arnar> > let hist = map (head &&& length) . group . sort in hist $ show $ product [1..100]
11:24:36 <lambdabot>   [('0',30),('1',15),('2',19),('3',10),('4',10),('5',14),('6',19),('7',7),('8...
11:24:41 <jmcarthur> conal: yeah, but we still need to do better than inlining *all* functions. we need to be able to tell it we want it to inline all functions satisfying some predicate or something
11:25:07 <jmcarthur> like, there's no point in forcing to inline functions having absolutely nothing to do with vector, for example
11:25:18 <conal> jmcarthur: i wonder.  ghc already has some heuristics.  do we really want anything different/unusual?
11:25:26 <jmcarthur> then again, combinators that don't inline and get used in a vector function later might still be annoying
11:26:08 <conal> jmcarthur: maybe some kind of demand-driven mechanism
11:26:09 <mreh> @wn inline
11:26:10 <lambdabot> No match for "inline".
11:26:21 <jmcarthur> conal: that's what i was thinking would be best
11:26:28 <conal> jmcarthur: ie pull inlining rather than push them.  or some combo.
11:26:28 <yitz> @quote inline
11:26:29 <lambdabot> ghc says: Warning: you can make GHC diverge by using SPECIALISE INLINE on an ordinarily-recursive function.
11:26:33 <ski> @wn unfold
11:26:34 <lambdabot> *** "unfold" wn "WordNet (r) 2.0"
11:26:34 <lambdabot> unfold
11:26:35 <lambdabot>      v 1: develop or come to a promising stage; "Youth blossomed into
11:26:37 <lambdabot>           maturity" [syn: {blossom}, {blossom out}, {blossom forth}]
11:26:38 <sinelaw> hi conal :)
11:26:39 <lambdabot>      2: open to the view; "A walk through town will unfold many
11:26:41 <lambdabot> [7 @more lines]
11:26:47 <conal> sinelaw: hi
11:27:21 <conal> jmcarthur: i don't think this issue is specific to either vector fusion or to the vector-space package.
11:27:28 <jmcarthur> conal: actually, this is about rewrite rules more than inlining
11:27:40 <jmcarthur> conal: maybe if we focus on the rewrite rules we can think of something nicer
11:27:46 <conal> jmcarthur: ah, yeah.
11:28:32 <conal> jmcarthur: have you talked with they ghc guys about this issue?  i wonder what practice they'd advise for use with the current ghc
11:28:54 <jmcarthur> i have not
11:29:47 <conal> jmcarthur: how did the inlining/rewriting concern arise for vector fusion and the vector-space package?
11:30:16 <jmcarthur> conal: i assume you read the email i linked to?
11:30:27 <jmcarthur> this one: http://www.haskell.org/pipermail/haskell-cafe/2010-March/074153.html
11:30:34 <conal> jmcarthur: yes.  i'l reread now.
11:31:03 <jmcarthur> conal: "in general, you have to add INLINE pragmas in such cases if you want to be sure your code fuses. A general-purpose mechanism for handling situations like this automatically would be great but we haven't found a good one so far."
11:31:14 <jmcarthur> i think the most relevant line
11:31:40 <zygoloid> reverse with foldr can be written as:
11:31:49 <conal> jmcarthur: thx.  and the difficulty (with current ghc) is specifically cross-module, right?
11:31:53 <zygoloid> > foldr (\a r -> r ++ [a]) [] "hello"
11:31:54 <lambdabot>   "olleh"
11:32:00 <jmcarthur> conal: that is my understanding
11:32:10 <jmcarthur> but perhaps it is more complex
11:32:16 <zygoloid> however, this is inefficient due to the left-associated (++)s. so i tried to rewrite with DList:
11:32:30 <zygoloid> > foldr (\a r -> r . (a:)) id [] "hello"
11:32:31 <lambdabot>   "hello"
11:32:39 <zygoloid> ^^ why is the list now coming out forwards?
11:32:49 <conal> jmcarthur: if so, i wonder if ghc could be fixed to inline between modules according to the same heuristics as within a module.
11:34:08 <ski> > foldr (\a m k -> m ((a :) . k)) ($ []) "hello" id  -- `reverse', using `foldr' with nqCPS
11:34:09 <lambdabot>   "olleh"
11:34:36 <jmcarthur> conal: maybe.
11:34:41 <saml> (\x lower upper -> if x < lower then lower else if x > upper then upper else x)   how would you name this?
11:34:45 <saml> bracket?
11:34:50 <zygoloid> clip
11:34:52 <jmcarthur> conal: i'm going to eat lunch with sarah now. i'll talk to you about this later
11:34:54 <saml> zygoloid: thanks
11:34:55 <edwardk> @type \a r -> r . (a:)
11:34:56 <lambdabot> forall b a. a -> ([a] -> b) -> [a] -> b
11:35:34 <conal> jmcarthur: part of my discomfort is that i don't know whether the INLINE directives are more helpful or more harmful under all uses.  if they were generally helpful, i imagine ghc would do it.
11:35:34 <conal> jmcarthur: k.  take care.
11:35:46 <zygoloid> > foldr (\a r -> r . (:) a) id "hello" []
11:35:47 <lambdabot>   "olleh"
11:35:49 * zygoloid == idiot :)
11:35:53 <edwardk> @type \a m k -> m ((a :) . k)
11:35:54 <lambdabot> forall a (f :: * -> *) t. (Functor f) => a -> (f [a] -> t) -> f [a] -> t
11:36:42 <edwardk> zygoloid: good catch
11:37:57 <mreh> how was doing an ACO in haskell recently?
11:38:12 <mreh> I reckon that would be a nice reactive project
11:38:32 <ski> zygoloid : all clear ?
11:38:33 <mreh> s/how/who/
11:39:01 <zygoloid> ski: just got the arguments in the wrong order :) your cps version is nice too though
11:42:08 <pokoko222> can someone please run this and tell me result: http://www.haskell.org/haskellwiki/Euler_problems/51_to_60#Problem_55 euler 55, i have filesystem problems in ubuntu cant load it, actually cant locate a file :O
11:44:52 <ski> > foldr (\a m k -> m (k . (a :) . k)) ($ []) [0,1,2,3,4] id  -- *fanfare*
11:44:53 <lambdabot>   [0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0]
11:49:42 <dantheman_> Hey, can anyone help me with a stupid question I have re the ffi?
11:50:11 <mauke> unknown
11:50:13 <dantheman_> Basically, I'm trying to compile a file from the real world haskell tutorial Regex.hs
11:50:41 <dantheman_> in ghci using the command > ghci Regex.hs -lpcre
11:51:06 <mauke> but ghci is not a compiler
11:51:14 <dantheman_> sorry, load
11:51:26 <sinelaw> conal, i'm trying to wrap an imperative lib (opencv), that works with transformers: Ptr a -> Ptr a -> IO () , where the first is input, and the second (output) pointer has to be pre-allocated
11:52:17 <Reisen> Trying to build something using cabal (sorry if this isn't the right place to ask), but it says I'm missing several packages which I'm not (using cabal to install them)
11:52:24 <Reisen> http://pastebin.ca/1830539 you can see my output here
11:52:36 <dantheman_> essentially, it needs to link to a pcre.dll
11:52:43 <dantheman_> but all I have is a pcre.dll.a
11:52:51 <dantheman_> How do I get from one to the other?
11:52:55 <dantheman_> Or is that even possible?
11:53:05 <mauke> Reisen: try cabal --user
11:53:27 <Reisen> The output in that pastebin is from --user
11:53:52 <roconnor> uniplate is way better than I assumed.
11:54:12 <mauke> Reisen: what, both?
11:54:15 <Reisen> mauke, oh, from ghc-pkg --user I mean, I don't know of a cabal --user
11:54:22 <Reisen> mauke, nah sorry, top is from runhaskell Setup.hs configure
11:54:30 <Reisen> Bottom is from ghc-pkg list --user
11:54:40 <mauke> Reisen: try runhaskell Setup.hs configure --user, then
11:55:07 <Reisen> Ah, never needed to do that before, worked
11:55:10 <Reisen> mauke, thanks, appreciate it
11:55:35 <conal> sinelaw: ok
11:55:46 <sinelaw> conal, my idea was to wrap it in a functional combinator library, that build an action whose type includes the input and output types
11:56:01 <sinelaw> of each of the transformers
11:56:56 <jmcarthur> conal: "part of my discomfort is that i don't know whether the INLINE directives are more helpful or more harmful under all uses."  <-- me too
11:57:13 <dantheman_> its on hpaste here .. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23520#a23520
11:57:43 <pokoko222> http://www.haskell.org/haskellwiki/Euler_problems/51_to_60#Problem_55 please someone compile 55 and tell me result, i got filesystem problems
11:57:46 <conal> jmcarthur: i just found that haskell-cafe thread and added a reply.
11:58:31 <conal> jmcarthur: hoping that don, roman, etc will have some ideas in addressing that discomfort.
11:58:33 <dantheman_> I'm just a bit ignorant about linking to libraries/dlls on windows... do I have to just go and find a proper dll on the net, or can I somehow use pcre.dll.a or pcre.lib?
11:58:33 <jmcarthur> conal: was it really 171 pragmas? jeez
11:58:48 <conal> jmcarthur: yeah.  crap.  a lot of work on your part.
11:59:09 <conal> jmcarthur: and aesthetically, ghc pragmas are ugly attention-grabbers.
11:59:12 <jmcarthur> it didn't seem like that much
11:59:18 <jmcarthur> yes they are. i think by design
11:59:19 <sinelaw> conal the idea is that in the end you take the composed transformer and run it inside IO, and it will a sequence of allocations for all intermediate results, the sequence of transformers, and reverse deallocation. but i can't get the types to play nicely. when i chain them i have to express somehow the composed allocators and releasers, which now need to allocate/release more than one thing
11:59:42 <conal> jmcarthur: they shout more loudly than the lovely code sitting next to them.  all elbows
11:59:43 <roconnor> whomever complains about GHC's error messages should try ocaml
11:59:54 <roconnor> File "translator.ml", line 44, characters 28-30:
11:59:55 <roconnor> Error: Syntax error
12:00:07 <sinelaw> roconnor, tex beats them all
12:00:14 <roconnor> :D
12:00:20 <lament> ?
12:00:34 <roconnor> tex gives you an error and then gives you a prompt that you can never escape from!
12:00:37 <jmcarthur> conal: don't feel obligated to use the patch just because it was apaprently so much work
12:00:44 <jmcarthur> *apparently
12:01:07 <sinelaw> roconnor: it's punishment
12:01:24 <jmcarthur> ^D
12:02:03 <Alpounet> roconnor, haha, you too have been caught in that prompt
12:02:07 <conal> jmcarthur: ok.
12:02:25 <Alpounet> I remember how 'handy' it was when I was beginning to use it
12:02:34 <sinelaw> i think i end up making something that's a monad
12:02:46 <sinelaw> but that doesn't matter much, i just want to get the interface nice
12:02:51 <sinelaw> which i can't
12:04:58 <ski> sinelaw : for some reason, what you say make me think of the (later) implementation of fudgets ..
12:06:19 <ski> (also, maybe you'll want to make `type Transformer a b = Ptr a -> Ptr b -> IO ()' (or whatever) into an arrow
12:06:22 <ski> )
12:08:35 <sinelaw> ski that's exactly what i've been thinking
12:08:41 <conal> jmcarthur: i'll keep following the haskell-cafe thread, too.  and it's easy to me to apply your patch and then undo it later if a prettier and safer solution arises.
12:08:48 <sinelaw> it's an arrow probably
12:09:19 <conal> sinelaw: the arrow interface would want you to have pair-valued pointers.
12:09:22 <sinelaw> except that on composition, instead of a ~> c  i get a ~> (b,c)
12:09:58 <jmcarthur> conal: apparently the real trick is that GHC will not inline functions in a function that is annotated INLINE, meaning that rewrite rules can fire on the outermost rule before firing on inner ones
12:10:26 <sinelaw> i want a ~> b chained to b ~> c to give a ~> c
12:10:30 <jmcarthur> conal: i think it would be nice if we could come up with a way for rewrite rules to affect GHC's inliner
12:10:44 <conal> jmcarthur: yeah.  maybe INLINE ought to be decomposed into two sub-meanings.
12:10:45 <jmcarthur> then it would only happen when necessary
12:11:14 <sinelaw> this is what i've got so far
12:11:15 <sinelaw> http://github.com/sinelaw/cv-combinators/blob/master/src/AI/CV/Processor.hs
12:11:17 <jmcarthur> well, the fact that it forces that function to be inlined is also good though
12:11:33 <jmcarthur> which is apparently important across module boundaries
12:11:40 <sinelaw> it's a little ugly because i've abstracted away the IO into any monad
12:11:45 <conal> jmcarthur: maybe ghc could *never* inline functions into an inline body.  and then do some caching to avoid redundant work.
12:12:00 <jmcarthur> perhaps. still leaves the cross-module inlining issue though
12:12:24 <esr> Hello, all.  I'm in the process of blogging "On Learning Haskell".
12:12:32 <jmcarthur> i suspect this is also architectural
12:12:44 <jmcarthur> ghc doesn't know if it will inline a function across a module boundary in advance
12:12:52 <jmcarthur> therefore it goes ahead and inlines into it
12:13:04 <jmcarthur> *inlines other functions into it
12:13:31 <conal> jmcarthur: i don't understand how module boundaries come into play
12:14:40 <jmcarthur> conal: my suspicion is that because ghc builds modules separately it can't know whether a function will be inlined in another module, so if it's not marked INLINE it feels free to inline other functions into it as it pleases
12:15:17 <jmcarthur> conal: but a function marked INLINE is clearly going to be inlined everywhere it's used, so ghc can go ahead and avoid inlining into it
12:15:49 <edwardk> @seen sclv
12:15:50 <lambdabot> Unknown command, try @list
12:15:55 <edwardk> preflex: xseen sclv
12:15:55 <preflex>  sclv was last seen on freenode/#haskell 41 days, 3 hours, 37 minutes and 5 seconds ago, saying: @remember cale Differential geometry is the study of manifolds under change of notation.
12:17:07 <jmcarthur> conal: perhaps a way around it would be to avoid making inlining decisions about exported functions at all until link time
12:17:20 <jmcarthur> but that would stink a little
12:17:24 <conal> jmcarthur: maybe so.  sounds like a place for improving ghc.  it makes an invalid assumption: that a def not marked INLINE won't be inlined.
12:17:25 <conal> jmcarthur: instead, it could be prepared to inline elsewhere.
12:17:25 <conal> jmcarthur: i'm confused though.  ghc *is* prepared to inline elsewhere.
12:17:42 <djahandarie> esr, learning a sane language this time? :-)
12:17:49 <roconnor> In my experenice GHC's inliner is arbitrary and totally unstable (in a certain sense of unstability)
12:18:15 <roconnor> unstable meaning a minor change here can ripple and have huge effects on what does or does not get inlined later
12:18:23 <jmcarthur> conal: well, it's not that ghc makes an invalid assumption, i think. it just doesn't take certain steps unless you tell it to explicitly
12:18:27 <esr> djahandarie: What other time are you implicitly referring to? :-)
12:18:57 <shapr> esr: Got any questions we can answer?
12:18:58 <conal> jmcarthur: the invalid assumption i mean is that it's not worth saving an inline-and-optimze-friendly def.
12:19:05 <djahandarie> esr, any other period of time in your life that lead to learning another language. ;) Just a joke though.
12:19:43 <conal> jmcarthur: cross-module inlining is only possible because ghc stashes a definition in a .hi, iuuc.  i'm suggesting that the stashed definition either (a) never include further inlinings, or (b) be augmented by such a definition.
12:20:00 <esr> djahandarie: It helps having been a hard-core LISP-head at one time.  A *lot*.
12:20:07 <jmcarthur> conal: i agree with that suggestion, if our understanding of how it works is correct
12:20:54 <conal> jmcarthur: okay.  let's take this understanding into the haskell-cafe discussion and see what evolves.  okay?
12:20:57 <edwardk> esr: how have you found the Haskell learning process so far?
12:21:04 <jmcarthur> alright
12:21:13 <conal> jmcarthur: i'm going to go chain-sawing now.  thanks for the chat.
12:21:39 * Heffalump remembers where conal lives and decides that's probably not a euphemism :-)
12:21:45 <jmcarthur> conal: mm chain sawing
12:21:51 <jmcarthur> Heffalump: heh
12:21:58 <edwardk> esr: and yeah, a good scheme/lisp background can help out quite a bit
12:22:01 <djahandarie> esr, yep, coming from another functional language certainly helps a lot, I came from Erlang myself. There is certainly plenty left to learn though even with that background, though.
12:22:10 <shapr> I came from Python...
12:22:33 <djahandarie> Python has little bits of functional stuff in it
12:22:38 <jmcarthur> conal: if you don't before i do, i'll write up an email for the mailing list later. i should do some work first :)
12:22:46 <esr> I'm trying to explain some of Haskell's fundamental concepts, partly as a way of clarifying my own thoughts.  Functional programming style: easy.  Type inference: easy.  Monads: easy once you get that they're just a fancy wrapper  around deferred evaluation of closures, but getting that is a bit hard.
12:23:16 <Heffalump> well, in Haskell laziness means that everything is a deferred evaluation of a closure
12:23:32 <djahandarie> Unless it is strict. :o)
12:23:50 <esr> I think the thing I'm having the most trouble modeling in my head at this point is lazy evaluation. That is, predicting what will happen then,
12:23:55 <edwardk> esr: that intuitive model for monads will carry you for a ways, but doesn't work well when thinking about the list monad, or monad transformers.
12:24:15 <esr> edwardk: Can you elaborate?
12:24:31 <edwardk> esr: have you looked at monad transformers at all?
12:24:45 <esr> Yes.  I don't undetstand them yet.
12:24:46 <edwardk> just trying to figure out the right amount of background to delve into
12:25:09 <conal> Heffalump: right.  i do all my heating by wood.  and there are always plenty of fallen trees here.
12:25:29 <edwardk> well, lets take a very different way of looking at monads -- as ways you might try to refactor code -- and then try to come back to the sort of operational IO-like monads
12:26:44 <edwardk> if you have a function of type (a -> b) -- you could change that function in some fairly mechanical ways. for instance you could add another argument to it. some kind of environment that you want to give your program access to. a -> e -> b. and you can compose these functions, by just feeding the environment to both
12:27:51 <edwardk> on the other hand, perhaps you want to add some kind of appearance of mutable state. you could add another argument, and plumb it through to the result. a -> s -> (s, a)
12:28:04 <esr> Right, I get that.
12:28:07 <edwardk> composition just wires up the state you output to the input state of the next function
12:28:52 <edwardk> you could add some kind of logging, where a monoid just serves as a way to define how to compose log entries a -> (b, w), etc.
12:29:43 <edwardk> it turns out that these refactorings happen a lot. we encapsulate them into monad transformers. so you can layer them over each other and over other things that happen to be monads.
12:30:00 <esr> This isn't overly difficult.  I make my *C* functions pass around pointers to context structures to avoid globals. :-)
12:30:25 <c_wraith> yes, but in C, you have to manually specify the arguments. :)
12:30:31 <esr> Indeed.
12:30:44 <edwardk> i.e. you can play with a depth first/breadth first search monads, and then apply those same transformers to them, the ordering determines whether or not you remember state changes across backtracking attempts
12:32:53 <edwardk> the power of monads comes when you start playing with the more interesting monads. state, reader, writer, all have a fairly intuitive grounding, because you can shoehorn them all into the IO monad, but backtracking or the cps transforming monad, can have a fairly complicated effect on control flow.
12:33:01 <esr> I'm going to have to write actual code before I grok this fully, I think.
12:33:49 <edwardk> fair enough. we're happy to help with questions
12:35:25 <djahandarie> You know, a really nice tutorial on monads would be something like "here is a really common problem", "here is the generic solution for all problems like that", a couple times over until you get to the overall generalization of a Monad
12:36:05 <djahandarie> Since building from the ground-up can be kind of non-intuitive
12:36:13 <edwardk> djahandarie: yeah. that seems to fit with the intuition that people first 'get' monads some time around the third monad tutorial they read ;)
12:37:03 <edwardk> by then they've been inundated with analogies and know that monads are both burritos _and_ space suits. ;)
12:37:43 <djahandarie> Haha
12:38:54 <esr> Just for fun, here's the last bit I just added to my essay: "User-defined types are just the values of type-valued expressions.  The single most delightfully weird detail of Haskell I've run into so far is this: you can have type-valued variables, and write type-valued expressions that are <em>recursive</em>!  For some types, such as trees, this is the natural way to do things."
12:41:16 <forrest> esr: is your essay up on the web somewhere?
12:41:30 <esr> No, but it will be soon.
12:41:38 <edwardk> heh, if you're masochistic you can even factor the recursion out of the Tree: newtype Fix f a = In (f (Fix f) a); data Tree b a = Tip | Bin b a b -- then Fix Tree a -- has values like In Tip   or In (Bin (In Tip) a (In Tip)) -- and is recursive even though Tree doesn't appear to be
12:41:58 <esr> edwardk: *head asploding*
12:42:00 <Heffalump> I didn't actually understand that statement at all until the last sentence.
12:42:15 * forrest has class on saturday, and is supposed to have some news items from the web
12:42:32 <Heffalump> what does "type-valued" mean?
12:42:53 <Heffalump> I guess that you're saying that the language for defining types looks a bit like the expression language, which I don't think is really true.
12:43:14 * ski would prefer `Fix (Tree a)', there, with the arguments to `Tree' flipped, and the usual `Fix'
12:43:49 <edwardk> ski: i was going for a bifunctor fixpoint. Fix (Tree a) makes it harder to make your Tree into a functor, etc.
12:44:51 <esr> Heffalump: But the same things that work as right sides for defining a function signature work as the right sides for type definitions. (Or am I wrong about that?) It's those right sides that I think of as type-valued expressions.
12:45:19 <edwardk> ski: an extra benefit is this approach allows for the painful formulation of the free monad i have in category-extras. ;)
12:45:21 <Heffalump> can you give a concrete example?
12:45:46 <Heffalump> a typical tree type would be data Tree a = Leaf a | Fork (Tree a) (Tree a)
12:46:22 <esr> Right.  to me, "Leaf a | Fork (Tree a) (Tree a)" is a type-valued expression parametric in a.
12:46:29 <edwardk> esr: you can't do everything in a type signature that you can do at the term level. the type and term level are fairly different, you have type level and term level application, and you have some operators at the type level, but they are different languages in many ways. you have no type level lambdas for instance
12:46:35 <edwardk> there is no type case, etc.
12:46:59 <copumpkin> there is a spoon though
12:47:09 <ski> but, there's variables and application at the typelevel, yes
12:47:36 <esr> edwardk: OK< do you think I'm going to be fatally misleading idf I talk about type-valued expressions?
12:47:37 <edwardk> also Leaf a | Fork (Tree a) (Tree a) -- is a mixture of things, you have the names of constructors (Leaf and Fork) and you have the names o the types of their fields.
12:48:00 * roconnor wants reducable combinators at the type level such as B C K I and W
12:48:12 * djahandarie wants less one-letter symbols
12:48:15 <edwardk> perhaps a better intuition of the meaning of that right hand side can be obtained by writing it using "GADT" notation.
12:48:38 <edwardk> data Tree a where Leaf :: a -> Tree a; Fork :: Tree a -> Tree a -> Tree a
12:49:11 * ray wants fewer one-letter type variables
12:49:20 <roconnor> djahandarie: what part of B (B (B W) C) (B B) don't you understand?
12:49:45 <edwardk> now you can see that that notation basically gives the types of the constructors "Leaf" and "Fork". Leaf takes a value of any type a and gives you a Tree parameterized by that type. Fork expects two trees parameterized on the same type to give you a new tree
12:49:52 <ray> translate that into S K and I please
12:49:53 <ski> esr : i don't think it's that misleading, as long as you understand that the `|' in `Leaf a | Fork (Tree a) (Tree a)' doesn't combine type expressions into larger type expressions, and that you don't have `if',`case', &c. in type expressions .. only variables, constants and application
12:50:00 <roconnor> ray: S
12:50:10 <ray> makes sense!
12:50:34 <Heffalump> I don't think they're much like expressions, given how they switch from term constructors like Leaf and Fork to type constructors like Tree.
12:50:37 * djahandarie has drowned in symbol land's treacherous swamps
12:51:12 <edwardk> in data Foo a b c = Bar a | Baz (Quux b) (Quaffle c) -- the only type expressions are the one being defined 'Foo a b c', and the argument types: 'a', 'Quux b', and 'Quaffle c'
12:51:21 <esr> I wiull note that I am glossing over some details...
12:51:41 <edwardk> esr: i appreciate that; no worries. just trying to clarify =)
12:52:13 <ski> Heffalump : yes, `Fork (Tree a) (Tree a)' is not a type expression there .. but `Tree a' and `StateT Foo (ContT o IO) (Maybe Int)' are
12:53:41 <esr> First sentence revised: "User-defined types are (more or less) the values of type-valued expressions (it's actually more complicated than that, but thinking about it this way is a useful point of entry)."
12:54:18 <bos> hee hee! i just set up a google adwords campaign for RWH
12:54:23 <edwardk> roconnor: clearly you should restate that as ((S(K((S(K(S(K((S(K(S((S(K((S((SK)K))((SK)K))))((S(K((S(KS))K)))((S(K(S((SK)K))))K))))))K)))))((S((S(K((S(KS))K)))S))(KK)))))(S(K((S(KS))K)))) ;)
12:54:31 <roconnor> :D
12:55:38 <djahandarie> There should be a module in lambdabot for that
12:55:52 <esr> Combinators *definitely* make my head asplode.
12:56:27 <esr> I mean, thety're easy to understand in a local sense, but....
12:56:35 <djahandarie> I(I(I(I(I(I(I(I(I(I(I(I(I(I(AHHHHHHHHH)))))))))))))))
12:57:03 <edwardk> esr: to be fair, i cheated and used a lookup table ;)
12:57:14 * esr waves a mackerel threateningly at djahandarie
12:57:58 * djahandarie is reminded of some japanese meme about people waving fish around
12:59:02 <esr> Reference from the Battle For Wesnoth channel where I occasionally chastise people by slapping them with a fish.
12:59:02 * roconnor sighs
12:59:08 <roconnor> I wish software were less buggy
12:59:36 <esr> roconnor: And you want a pony, yes? :-)
12:59:39 <edwardk> esr: i think that meme has propagated to almost every channel (and bot) on the internet ;)
12:59:44 <roconnor> a pony would be good too
12:59:48 <Trinitron> http://pastie.org/862042 I'm doing Project Euler problem two and I have the recurrence relation, now I don't know how to only add even fibonacci numbers...
13:00:00 <FauxFaux> filter
13:00:04 <Trinitron> you can't return two things can you?
13:00:10 <Zao> You can return a tuple.
13:00:18 <Zao> Or a custom datatype.
13:00:20 <Zao> Or pie.
13:00:21 <ski> > filter even [1,4,2,8,5,7]
13:00:22 <lambdabot>   [4,2,8]
13:00:22 <esr> I don't know where I picked up the meme.
13:00:25 <roconnor> Trinitron: BTW fibs 0 = 0 and fibs 1 = 1
13:00:30 <Trinitron> uhuh
13:00:41 <Trinitron> oh
13:00:55 <Trinitron> bi
13:00:57 <roconnor> well, I don't know the Project Euler definition
13:01:00 <Trinitron> wait
13:01:10 <roconnor> but that is the mathematical definition of fib.
13:01:12 <mauke> http://www.youtube.com/watch?v=xCwLirQS2-o
13:01:33 <edwardk> http://en.wikipedia.org/wiki/The_Fish-Slapping_Dance
13:01:58 <Trinitron> yeah
13:02:05 <Trinitron> changed it now
13:02:10 <jmcarthur> edwardk: your SK expression doesn't seem to type check
13:02:20 <roconnor> the sum of all even fibs is infinity :D
13:02:43 <edwardk> jmcarthur: in haskell? it shouldn't
13:03:08 <edwardk> jmcarthur: yours was a fixed point combinator no?
13:03:12 <jmcarthur> oh is it a fixed point?
13:03:17 <jmcarthur> nevermind then
13:03:22 <jmcarthur> i wasn't really paying attention
13:03:31 <edwardk> er roconnor's was
13:03:34 <jmcarthur> ah
13:03:43 <edwardk> i just expanded it
13:03:52 <edwardk> so it'll slam into the occurs check
13:04:12 <esr> Are y'all Haskellites? Haskellians? Haskellators?  What is the proper collective noun?
13:04:20 <Trinitron> how do I generate a list from a recurrence relation?
13:04:21 <ceii> haskelers?
13:04:23 <Trinitron> yield?
13:04:26 <ceii> haskellers*
13:04:30 <edwardk> Haskellers
13:04:46 <damd> how can i change a static variable in haskell
13:04:55 <esr> Sounds like somewhere you'd go in Germany to drink a beer :-)
13:05:01 <copumpkin> damd: this is getting old
13:05:05 <damd> :)
13:05:06 <mauke> haskelletons
13:05:23 <ologNation> Funktologist
13:05:31 --- mode: ChanServ set +o mauke
13:05:31 --- mode: mauke set +q $a:damd
13:05:32 * esr likes "haskelletons"
13:05:40 <ologNation> hactuary
13:05:40 <copumpkin> tons of haskell
13:05:54 <edwardk> mauke: that is what you turn into if it takes too long to get your code to compile.
13:05:55 <medfly> worshippers of the Cale
13:06:05 <roconnor> > let fiblist = 0:1:[x + y | (x,y) <- zip (drop 1 fiblist) (drop 2 fiblist0] in fiblist
13:06:06 <lambdabot>   <no location info>: parse error on input `]'
13:06:10 <roconnor> > let fiblist = 0:1:[x + y | (x,y) <- zip (drop 1 fiblist) (drop 2 fiblist)] in fiblist
13:06:14 <lambdabot>   mueval-core: Time limit exceeded
13:06:16 <medfly> or oleg, I dunno.
13:06:43 <roconnor> > let fiblist = 0:1:[x + y | (x,y) <- zip fiblist (tail fiblist)] in fiblist
13:06:44 <edwardk> oleg doesn't write haskell. he writes prolog. he just happens to write it at the haskell type level.
13:06:44 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
13:06:56 <Trinitron> How would I do this just using basic functions, or you can't?
13:07:09 <FauxFaux> zip and tail are basic functions.
13:07:13 <Trinitron> Like basic function defintions, such as i posted?
13:07:16 <copumpkin> @remember edwardk oleg doesn't write haskell. he writes prolog. he just happens to write it at the haskell type level.
13:07:17 <lambdabot> I will remember.
13:07:19 <Trinitron> like I mean lambda calc
13:07:28 <Trinitron> only
13:07:31 <roconnor> > let fiblist = 0:1:map (\(x,y) -> x + y) (zip fiblist (tail fiblist)) in fiblist
13:07:31 --- mode: mauke set -o mauke
13:07:32 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
13:07:35 <mauke> @src tail
13:07:35 <lambdabot> tail (_:xs) = xs
13:07:35 <lambdabot> tail []     = undefined
13:07:37 <mauke> @src zip
13:07:38 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
13:07:38 <lambdabot> zip _      _      = []
13:07:46 <roconnor> @pl  (\(x,y) -> x + y)
13:07:47 <lambdabot> uncurry (+)
13:07:58 <roconnor> > let fiblist = 0:1:map (uncurry (+)) (zip fiblist (tail fiblist)) in fiblist
13:07:59 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
13:08:04 <mauke> did you mean: zipWith
13:08:09 <roconnor> > let fiblist = 0:1:zipWith (+) fiblist (tail fiblist)) in fiblist
13:08:10 <lambdabot>   <no location info>: parse error on input `)'
13:08:15 <roconnor> mauke: thank you Dr. Haskell
13:08:16 <jmcarthur> i think roconnoris building up
13:08:21 <roconnor> > let fiblist = 0:1:(zipWith (+) fiblist (tail fiblist)) in fiblist
13:08:22 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
13:08:34 <edwardk> roconnor: superfluous parens ;)
13:08:42 <jmcarthur> @pl fiblist = 0:1:(zipWith (+) fiblist (tail fiblist))
13:08:43 <lambdabot> fiblist = fix ((0 :) . (1 :) . ap (zipWith (+)) tail)
13:08:44 <roconnor> > let fiblist = 0:1:zipWith (+) fiblist (tail fiblist) in fiblist
13:08:45 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
13:08:56 <roconnor> > fix ((0 :) . (1 :) . ap (zipWith (+)) tail)
13:08:57 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
13:09:20 <copumpkin> that's awfully involved
13:09:35 <copumpkin> oh I guess you're translating the usual version
13:09:55 <mauke> > iterate (round . ((0.5 + sqrt 1.25) *) . fromIntegral) 1
13:09:56 <lambdabot>   [1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,177...
13:10:07 <Cale> Trinitron: What is it that you want to do again?
13:10:08 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
13:10:16 <Trinitron> Can you do it without constructing a list?
13:10:31 <roconnor> > fix (fmap fmap fmap (return 0) (return 1) `fmap` ap (zipWith (+)) tail)
13:10:31 <Trinitron> As in within the recurrence relation
13:10:32 <lambdabot>   No instance for (GHC.Num.Num [a])
13:10:32 <lambdabot>    arising from the literal `1' at <inter...
13:10:35 <edwardk> > fix((1:).scanl(+)1)
13:10:36 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
13:10:37 <jmcarthur> it doesn't necessarily construct a full list (in fact it can't because it's infinite)
13:10:48 <Cale> Trinitron: Do what?
13:10:55 <roconnor> edwardk: missing 0?
13:10:56 <Cale> Trinitron: Memoise fib?
13:11:07 <edwardk> > 0:fix ((1:) . scanl (+) 1)
13:11:08 <Trinitron> http://projecteuler.net/index.php?section=problems&id=2
13:11:09 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
13:11:13 <edwardk> =)
13:11:14 <roconnor> :D
13:11:31 <jmcarthur> > (0:fix ((1:) . scanl (+) 1)) !! 1000
13:11:32 <lambdabot>   434665576869374564356885276750406258025646605173717804024817290895365554179...
13:11:33 <Cale> Trinitron: Sure
13:11:41 <Cale> Trinitron: though, it would be silly not to use a list
13:11:52 <Trinitron> I'm trying to do it the discrete maths way
13:11:56 <jmcarthur> > (0:fix ((1:) . scanl (+) 1)) !! 10000
13:11:57 <Cale> Trinitron: Because that's just begging for filter even
13:11:57 <lambdabot>   336447648764317832666216120051075433103021484606800639065647699746800814421...
13:12:05 <Trinitron> i.e all within a recurrence relation
13:12:10 <Trinitron> no lists or whatever
13:12:12 <jmcarthur> > filter even (0:fix ((1:) . scanl (+) 1)) !! 10000
13:12:12 <ski> > fix ((0:) . scanl (+) 1)  -- edwardk, please
13:12:13 <lambdabot>   190424356734624387485009768471757502894402291602333519273391184052044801863...
13:12:13 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
13:12:17 <Cale> Trinitron: and takeWhile (< 4 * 10^6)
13:12:31 <edwardk> ski: better
13:12:49 <Trinitron> I'll just take your advice and use a list then.
13:12:52 <Cale> Trinitron: But sure, we could write a recursive function which does it.
13:13:27 <Alpounet> Cale, your HRSS stuff is nice :-)
13:13:33 <roconnor> Trinitron: your original function didn't use lists
13:13:35 <Alpounet> just used it
13:13:43 <roconnor> Trinitron: it worked fine (though slowly)
13:13:46 <Alpounet> I had to replace 'pure' by 'arr' but still
13:13:47 <jmcarthur> > sum . takeWhile (<=4000000) . filter even $ fix ((0:) . scanl (+) 1)
13:13:48 <lambdabot>   4613732
13:13:54 <Cale> Alpounet: Thanks! I'd actually never really used it myself :)
13:15:25 <edwardk> Trinitron: you can define something like: fib 0 = 0; fib 1 = 1; fib n = fib (n - 1) + fib (n - 2) -- but that version doesn't take advantage of the memoization of previous results. and if you then build a list out of that using something like map fib [0..] -- that will take a lot longer than those more complicated fibs above
13:15:43 <Trinitron> OK thanks.
13:16:20 <Trinitron> Are arrays the same as lists in Haskell?
13:16:25 <ski> no
13:16:43 <ski> lists are single-linked list cells
13:16:43 <djahandarie> Could do a combinator and the memoization in there
13:17:18 <Cale> No, they're very different. Lists can be infinite, but it takes linear time to walk down to the nth element. Arrays must be finite, but allow fast random access.
13:17:28 <Trinitron> I see.
13:18:11 <Cale> > let fib = Memo.integral fib'; fib' 0 = 0; fib' 1 = 1; fib' n = fib (n-1) + fib (n-2); foo n s | m > 4*10^6 = s  | even m = foo (n+1) (s+m)  | otherwise = foo (n+1) s where m = fib n in foo 0 0
13:18:12 <lambdabot>   4613732
13:19:06 <Cale> > let fibs = fix ((0:) . scanl (+) 1) in sum . filter even . takeWhile (< 4*10^6) $ fibs
13:19:07 <lambdabot>   4613732
13:19:12 <djahandarie> Oh, didn't even know there were ready made memo combinators
13:19:12 <edwardk> Trinitron: the problem is that the naive fib has a tight asymptotic complexity bound of something like Theta(fib n) itself, whereas the version mentioned above is asymptotically faster
13:19:44 <Trinitron> OK I'll use the list version then.
13:20:13 <Cale> Trinitron: The list version is quite clever, but you can also use Data.MemoCombinators to good effect
13:20:18 <edwardk> Trinitron: this becomes important for things like Project Euler, which tries to make sure that the naive versions of a lot of stuff you could do will take more computation power than you have available ;)
13:20:52 <Cale> In fact, if you're going to be doing Euler problems, I think often the nicest way involves writing the naive recursive solution, and then memoising it using Data.MemoCombinators
13:20:53 <copumpkin> has category theory explained the notion of tradeoffs yet?
13:21:01 <Cale> copumpkin: tradeoffs?
13:21:04 <edwardk> copumpkin: ?
13:21:11 <Trinitron> [ f x | x <- xs ] what is f doing here?
13:21:12 <copumpkin> why can't I have a datastructure that does everything in amazing time!
13:21:15 <copumpkin> why can't I have a pony?!
13:21:27 <copumpkin> to get one thing I tend to have to give up something else :(
13:21:39 <edwardk> > [ sin x | x <- [0..] ]
13:21:39 <Cale> Trinitron: That is the list whose elements are of the form f x, where x is selected from the list xs
13:21:40 <lambdabot>   [0.0,0.8414709848078965,0.9092974268256817,0.1411200080598672,-0.7568024953...
13:21:44 <copumpkin> getting one thing is adjoint to giving something else up
13:21:47 <copumpkin> :( :(
13:21:49 <Cale> > [x^2 | x <- [1..10]]
13:21:50 <lambdabot>   [1,4,9,16,25,36,49,64,81,100]
13:21:51 <edwardk> f can be any function
13:21:52 <Trinitron> so f is a function
13:21:54 <Cale> yeah
13:21:55 * copumpkin shuts up
13:21:55 <Trinitron> OK.
13:22:19 <edwardk> copumpkin: you can, it is called a finger tree ;)
13:22:29 * copumpkin gives edwardk the finger tree
13:22:42 * edwardk places it with the others.
13:22:42 <copumpkin> :)
13:22:54 <Trinitron> To define a list comprehension do I need to say let or I can just say blah = [ x | x <- [1..10] ]
13:22:55 * copumpkin stares at ezyang, btw
13:23:15 <edwardk> [ x | x <- [1..10] ] -- is of course the same as saying [1..10]
13:23:16 <ski> preflex: seen lunabot
13:23:17 <preflex>  lunabot was last seen on #haskell 38 days, 14 hours and 30 seconds ago, saying:  31
13:23:23 <ski> preflex: seen mmorrow
13:23:23 <preflex>  mmorrow was last seen on #ghc 50 days, 18 hours, 25 minutes and 38 seconds ago, saying: * mmorrow is rtfm'ing
13:23:27 <copumpkin> ski: :(
13:23:38 * copumpkin mmisses mmorrow
13:23:38 * sinelaw stares at 
13:23:41 <Trinitron> I was just doing a stupid example for the sake of it.
13:23:42 <ski> copumpkin : missing in action ?
13:23:48 <copumpkin> no idea where he went
13:23:54 <copumpkin> he didn't reply to my email asking what was up
13:23:57 <edwardk> blah = whatever is declaration. let blah = whatever in ... is an expression.,
13:24:01 <Cale> Trinitron: You'd use let <decl> on the GHCi commandline
13:24:08 <sinelaw> he's rtfm'ing for the last 50 days
13:24:15 <copumpkin> sinelaw: yeah, long manual :(
13:24:15 <ray> it's a long manual
13:24:21 <Cale> Trinitron: Or  let <decl> in <expr>  if you want it to be an expression
13:24:27 <Trinitron> In a .hs file I don't need to?
13:24:29 <edwardk> in lambdabot or ghci you can only use the latter. in a haskell source file you say blah = ...
13:24:37 <Cale> But you'd just write the declaration in a .hs file
13:24:55 <Cale> The top level of a .hs is a sequence of declarations.
13:27:46 <Trinitron> fibs = [x + y | x <- 1, y <- 0]; That is wrong, but I don't know any better.
13:28:01 <Cale> 1 isn't a list
13:28:04 <Trinitron> That's as close as I can get to defining the set comprehension
13:28:24 <Cale> When you write x <- xs in a list comprehension, xs must be a list
13:28:39 <Trinitron> I see.
13:28:46 <Trinitron> fibs = [x + y | x <- [1], y <- [0]]
13:29:07 <ski> > [x + y | x <- [1], y <- [0]]
13:29:08 <Cale> Of course, that's pretty boring, when there's only one choice for x and y
13:29:08 <lambdabot>   [1]
13:29:12 <Trinitron> heh
13:29:16 <ski> > [x + y | x <- [1], y <- [0]] :: [Expr]
13:29:17 <lambdabot>   [1 + 0]
13:29:51 <Trinitron> fibs = [x + y | x <- [1,fibs], y <- [0,fibs]]
13:30:10 <Trinitron> No, that wouldn't work either...
13:30:11 <edwardk> Trinitron: you can view a comprehension as drawing one item from each of the lists you give it as input
13:30:36 <edwardk> > [x + y | x <- [1..10], y <- [11..20]]
13:30:37 <lambdabot>   [12,13,14,15,16,17,18,19,20,21,13,14,15,16,17,18,19,20,21,22,14,15,16,17,18...
13:30:44 <Trinitron> But I'm trying to define the list in the first place.
13:30:47 <Trinitron> Hmm.
13:30:51 <Trinitron> I need breakfast.
13:30:53 <edwardk> yeah, that gets tricky =)
13:30:55 <esr> "Lazy evaluation is easier to understand.  All it means is that the value of an expression is not computed until it's actually needed by the caller; evaluation runs outside-in rather than inside-out.  If you're familiar with the idea of a closure from Scheme (or another language, such as Ruby, that has borrowed Scheme closures) it helps to think of Haskell expressions as returning closures. ...
13:30:56 <esr> ...When the program runs, the outermost (main) closure is evaluated; this may trigger the evaluation of other closures (expressions and function calls) directly inside it, and so on through their sub-expressions which are also closures."  What does this leave out, if anything?
13:31:04 <Cale> > [x + y | x <- [1,2,3], y <- [10,20,30]]
13:31:05 <lambdabot>   [11,21,31,12,22,32,13,23,33]
13:31:27 <edwardk> cale: probably a bit more compelling than my example, yes ;)
13:31:29 <Heffalump> sounds ok, though the caching aspect should probably be mentioned
13:31:37 <c_wraith> esr: it leaves out that thunks will only be evaluated once
13:31:38 <forrest> esr: be sure to use the word "thunk". it's a cool word.
13:31:45 <Trinitron> Be back later, stomach rumbling.
13:32:10 <Cale> I don't really like the words 'closure' or 'thunk', at least when not directly talking about implementing a language.
13:32:20 <Cale> I prefer just to say 'expression' normally.
13:32:29 * ski grins
13:32:43 <edwardk> esr: the thunk replaces itself with a pointer to its answer once evaluated.
13:33:02 <forrest> I thought that a thunk was the partially-evaluated expression returned from a function
13:33:03 <edwardk> esr: though cale will probably lynch me for phrasing it in those terms ;)
13:33:13 <esr> Cale: Remember, the point is to be accessible to experienced programmers who have never seen a lazy-evaliation language before.
13:33:14 <Cale> nah, that's fine, we can talk about the implementation
13:34:33 <edwardk> te other thing is that the compiler is free to figure out that you will demand the answer to a thunk along all execution paths and if it can do so it can reshuffle the order of operations around to just get that out of the way or never bother to construct the thunk in the first place.
13:34:50 <forrest> the word "thunk" has the connotations of "think" + a big thing dropping (an yet-to-be-evaluated expression rather than just and answer)
13:35:00 <Cale> Each variable is a pointer to code representing the expression it is bound to. When the variable needs to be evaluated, the code is entered, and the expression evaluates to a value. Before returning that value, the code rewrites the code pointer to point at a smaller piece of code that simply returns the value immediately the next time.
13:35:00 <edwardk> esr: that is how tight inner loops for haskell code tend to get compiled down into something fast despite such a seemingly baroque execution model.
13:35:40 <esr> I'll just say "I'm leaving out some optimixation tricks."
13:36:01 <edwardk> forrest: the term thunk has lots of connotations, i'm sure esr has it in a dictionary somewhere. ;)
13:36:02 <roconnor> @type fromMaybe
13:36:04 <lambdabot> forall a. a -> Maybe a -> a
13:36:11 <roconnor> @type maybe
13:36:12 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
13:36:21 <esr> edwardk: Er, yes, actually :-)
13:37:26 <esr> Previous 'graph reads: "Now I will admit that the preceding paragraphs contained two fibs.  First: Haskell does  have variables, sort-of kind-of. But such a "variable" can only assigned once and the value of the variable is a promise to re-evaluate the expression on the right side of the assignment whenever the variable is evaluated; it behaves like a safe macro or an Algol-60 call-by-name...
13:37:28 <esr> ...rather than like what people used to modern imperative languages call variables.  Second: it is possible to define operations that have side effects, and things that have the behavior of real variables, using a construct called a monad."
13:37:53 <Cale> esr: Normally I like to imagine the evaluation of Haskell code in terms of just rewriting expression graphs over and over.
13:38:28 <Cale> http://www.cas.mcmaster.ca/~kahl/HOPS/ANIM/index.html -- something like this (I really wish this program was publically available :)
13:38:33 <edwardk> hrmm: interestingly the idiosyncratic windows use of the term 'thunking' isn't mentioned in that article.
13:39:33 <edwardk> cale: beautiful link
13:39:35 <ski> monads takes the "side-" out of "side-effect"
13:39:35 <Heffalump> esr: the bit about re-evaluating whenever seems actively misleading, given that all implementations evaluate it at most once
13:40:34 <edwardk> esr: we use call-by-need, (in practice) not call-by-name. so the first time a thunk gets evaluated it gets replaced with its answer. which if ever asked to be evaluated just hands itself back.
13:40:43 <copumpkin> Cale: I've seen him post on the agda mailing list before... have you asked him?
13:41:57 <Cale> copumpkin: A while back when I was working at McMaster.
13:42:02 <copumpkin> ah
13:42:41 <Cale> copumpkin: He apparently was working on another version of it to be released, but I'm not sure if that's still going on, or if he's been distracted by something else by now.
13:42:48 <copumpkin> probably agda :)
13:43:58 <yitz> Cale: you're not at McMaster anymore?
13:44:13 <Cale> yitz: I haven't been there for years now
13:44:25 <copumpkin> McMistress now
13:44:30 <Cale> lol
13:45:03 <yitz> Cale: may i ask where you are now?
13:45:44 <Cale> Brantford, Ontario. I've done various small jobs, and I've been studying a bunch of things on my own, but I'm not employed at the moment.
13:46:32 <yitz> Cale: ok. good luck!
13:46:34 <sm> hi all. "hledger web" starts a server and opens a web browser, like so: http://gist.github.com/327156 . On linux, the browser hangs on the first request, but works if you restart it. Can anyone see why ?
13:48:48 <yitz> Cale: oh, i grew up in cleveland, across the lake. we used to watch channel 10.
13:51:34 <edwardk> preflex: xseen mmorrow
13:51:34 <preflex>  mmorrow was last seen on freenode/#ghc 50 days, 18 hours, 53 minutes and 49 seconds ago, saying: * mmorrow is rtfm'ing
13:51:39 <edwardk> @yow
13:51:39 <lambdabot> Couldn't find fortune file
13:51:56 <edwardk> how boring, she always seems to pick that one these days ;)
13:52:52 <ray> @quote
13:52:53 <lambdabot> denq says: oh! something bing in my brain :)
13:53:00 <yitz> @vixen where is the fortune file?
13:53:01 <lambdabot> i'll hafta plead the fifth on that one.
13:53:14 <ray> @quote vi
13:53:14 <lambdabot> dons says: ah, via the magic of SCIENCE
13:54:30 * sm wonders if processes started with system are tied into the parent process' IO in some way
13:54:44 <yitz> americanism: "plead the fifth" means invoke the fifth amendment to the u.s. constitution, which gives one the right to refuse to incriminate one's self in court.
13:55:12 <yitz> edwardk: why xseen and not seen?
13:55:32 <ski> preflex: yseen xseen
13:55:46 <edwardk> preflex: seen mmorrow
13:55:46 <preflex>  mmorrow was last seen on #ghc 50 days, 18 hours, 58 minutes and 1 second ago, saying: * mmorrow is rtfm'ing
13:56:00 <edwardk> yitz: coz last time i tried seen on preflex it didn't work? =)
13:56:27 <yitz> preflex seen mmorrow
13:56:27 <preflex>  mmorrow was last seen on #ghc 50 days, 18 hours, 58 minutes and 42 seconds ago, saying: * mmorrow is rtfm'ing
13:56:38 <edwardk> yitz: it appears to have since been fixed
13:56:42 <Alpounet> it just added "freenode/"
13:57:14 * ski wonders if there's a name for the relation between `f' and `g' that `forall a0 a1. f a0 = f a1 => g a0 = g a1'
13:57:22 <preflex> I have a help command, you know
13:58:32 <yitz> preflex: help xseen
13:58:32 <preflex>  xseen NICK - report when a user has been seen (on any network)
13:58:45 <yitz> preflex: help seen
13:58:45 <preflex>  seen NICK - report when a user has been seen
13:58:54 <gloob_> hi guys..a have problem with client/server app..it chat-like app where client connects to the server, then second client connects to the server and then conversation starts..but message from one client to another arrives shortened - last two chars are missing..i use Handles and every client has one Handle for reading and another for writing..
14:01:01 <Saizan> i think you're mishandling a \r\n somewhere
14:05:05 <bitstream0101> Can someone help me figure out how to convert a Data.Time.Clock.POSIXTime (i.e., type POSIXTime = NominalDiffTime) to a System.Posix.Types.EpochTime (i.e., a Foreign.C.Types.CTime)? The documentation only mentions something about converting the other way.
14:05:06 <Trinitron> Is there such thing as a recursive list comprehension?
14:05:11 <shapr> Anyone using gitit for blog entries?
14:05:43 <ski> Trinitron : not per se, but you can easily make a recursive definition whose body contains a list comprehension
14:06:10 <Trinitron> I guess I should just construct a list, rather than a list comprehension.
14:06:29 <ski> > let numbers = 1 : [y | x <- numbers, y <- [2 * x,2 * x + 1]] in numbers
14:06:30 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
14:06:47 <gloob_> Saizan> how to handle \r\n ?:
14:06:58 <ski> Trinitron : a list comprehension is one particular kind of expression, that is used to construct lists
14:07:13 <Trinitron> Based on already existing lists.
14:07:21 <Trinitron> In my case, I have no existing lists.
14:07:23 <ski> not necessarily
14:07:40 <ski> `numbers' above is defined in terms of itself, not any previously constructed list
14:08:21 <Trinitron> Oh I see now.
14:08:32 <Trinitron> but you need a starting element, but that makes sense.
14:08:40 <Trinitron> The edge case.
14:08:42 <Saizan> gloob_: well, that mostly depends on how you're fetching the data from the Handle and sending it back
14:09:21 <ski> Trinitron : yes, you need something that makes it not go around in a loop without producing any output
14:09:36 <ski> in the case of `numbers' above, the `1 : ' has that function
14:09:50 <ski> it adds an initial `1' that we're sure belongs to the list
14:10:32 <Trinitron> fibs = 0:1[x + y | x <- succ fibs, y <- fibs ] - Ta da!
14:10:34 <ski> then the `numbers' variable inside the list comprehension will "know" that `x' can at least be `1', so it can continue producing more numbers
14:10:52 <Trinitron> wait, something is wrong there,
14:10:53 <ski> Trinitron : almost
14:11:01 <Trinitron> that is cartesian product.
14:11:07 * Trinitron sighs
14:11:13 <ski> you probably don't want `succ', there
14:11:26 <ski> > succ [2,3,4]
14:11:27 <lambdabot>   No instance for (GHC.Enum.Enum [t])
14:11:28 <lambdabot>    arising from a use of `GHC.Enum.succ...
14:12:01 <ski> (also, you're probably missing a `:' ..)
14:12:02 <doserj> > let fibs = 0:1:[x + y | x <- tail fibs| y <- fibs ] in fibs
14:12:03 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
14:12:06 <Trinitron> x is supposed to be fibs (x-1) and y is fibs ( x-2)
14:12:26 <metaperl> I'm trying to build Haskell Platform on debian/testing. GHC has already been installed from binary. However, I am told 'editline not found' even though I installed libeditline-dev and libeditline0
14:12:54 <Trinitron> Won't that give a cartesian product?
14:13:14 <Trinitron> I thought that is how list comprehensions work.
14:13:42 <mauke> Trinitron: he used | between the list
14:13:43 <doserj> metaperl: try libedit-dev?
14:13:45 <ski> if you use multiple generators in a list comprehension, then yes, it works similar to a cartesian product
14:13:54 <metaperl> ok doserj I will
14:15:00 <Trinitron> What's the difference between fibs = 0:1:[x + y | x <- tail fibs, y <- fibs ] and fibs = 0:1:[x + y | x <- tail fibs | y <- fibs ]?
14:15:36 <Trinitron> I'm referring to the pipe symbol.
14:15:47 <ologNation> know any good debuggers for haskell?
14:16:21 <Trinitron> I thought you could only have one pipe symbol inside a set comprehension.
14:16:24 <Cale> Trinitron: Whether it does nested concatMaps (Cartesian product) or it zips the choices together
14:16:36 <doserj> > [(x,y)| x<-[1,2,3] , y <- [3,4,5]]
14:16:37 <lambdabot>   [(1,3),(1,4),(1,5),(2,3),(2,4),(2,5),(3,3),(3,4),(3,5)]
14:16:42 <doserj> > [(x,y)| x<-[1,2,3] | y <- [3,4,5]]
14:16:42 <Cale> Trinitron: The second pipe symbol is an extension
14:16:43 <lambdabot>   [(1,3),(2,4),(3,5)]
14:16:57 * ezyang always thought it made more sense the other way around... 
14:17:36 * yitz never liked that extension, and just uses zip explicitly to be more clear
14:17:48 <Trinitron>     Illegal parallel list comprehension: use -XParallelListComp
14:17:48 <Trinitron> Failed, modules loaded: none.
14:17:53 <aavogt> > [((a,b),(x,y)) | a <- "ab", b <- "cd" | x <- "ef", y <- "gh" ]
14:17:54 <lambdabot>   [(('a','c'),('e','g')),(('a','d'),('e','h')),(('b','c'),('f','g')),(('b','d...
14:18:03 <Trinitron> When I use fibs = 0:1:[x + y | x <- tail fibs | y <- fibs ].
14:18:14 <aavogt> > [[a,b,x,y] | a <- "ab", b <- "cd" | x <- "ef", y <- "gh" ]
14:18:15 <lambdabot>   ["aceg","adeh","bcfg","bdfh"]
14:18:21 <aavogt> Trinitron: it told you how to accept it
14:18:50 <Trinitron> Are parallel list comprehensions seldom used?
14:18:56 <Trinitron> or advised against?
14:19:16 <aavogt> they aren't used much
14:19:23 <esr> "On learning Haskell", partial draft (everything except monads) is here:  http://pastebin.com/6BMTFGEE
14:19:23 <c_wraith> > fix $ (0:) . scanl (+) 1
14:19:24 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
14:19:40 <bitstream0101> Can someone help me figure out how to safely convert a Data.Time.Clock.POSIXTime -> System.Posix.Types.EpochTime? The documentation only talks about converting the other way.
14:22:00 <yitz> bitstream0101: the process described is not invertible?
14:22:22 <aavogt> they seem to be the same thing
14:22:58 <bitstream0101> POSIXTime is a NominalDiffTime (Data.Fixed with picoscecond resolution), and EpochTime is a CTime (newtype'd Int32...)
14:23:13 <aavogt> so you will lose precision
14:23:20 <bitstream0101> The documention just says 'To convert from a Foreign.C.CTime or System.Posix.EpochTime, use realToFrac.'
14:23:45 <bitstream0101> I'm fine with losing precision, I guess I'm just not sure how to do the conversion.
14:24:33 <ddarius> Trinitron: I'm personally of the opinion that explicitly using zip is clearer and more compact.
14:24:53 <aavogt> @type realToFrac
14:24:54 <lambdabot> forall a b. (Real a, Fractional b) => a -> b
14:25:35 <Trinitron> Well if parallel list comprehension don't work without an option passed to GHCi then I'll use something that doesn't need an option passed.
14:25:42 <Trinitron> comprehensions*
14:25:50 <ddarius> > let select xs bs = [x | x <- xs | True <- bs] in select [1,2,3,4,5] (map even [1..])
14:25:51 <lambdabot>   [1,2,3,4,5]
14:25:52 <aavogt> bitstream0101: there seems to be instances for  Real CTime  and for   Fractional EpochTime
14:26:06 <aavogt> so realToFrac may work correctly in reverse
14:26:10 <shapr> esr: I would say that mutable programming means the programmer is convinced they are smart enough to know when a value can be garbage collected.
14:26:22 <yitz> bitstream0101: the next function down in the docs is utcTimeToPOSIXSeconds
14:26:30 <shapr> esr: Whenever you write a new value into a variable, you are asserting that the old value will never be used again.
14:26:37 <bitstream0101> yitz: Yeah, I'm currently using utcTimeToPOSIXSeconds to obtain the POSIXTime value
14:26:49 <esr> shapr: Ah.
14:27:04 <aavogt> > (\x -> [ x | x <- x ] ) "shapr"
14:27:05 <lambdabot>   "shapr"
14:27:31 <yitz> bitstream0101: so what's wrong with that?
14:27:43 <shapr> esr: What do you think? Is that valid?
14:28:07 <bitstream0101> yitz: It doesn't get me an EpochTime.
14:28:18 <esr> shapr: Yes, but I don't really see where it fits in my essay.
14:28:23 <bitstream0101> aavogt: I get No instance for (Fractional System.Posix.Types.EpochTime) when I try to use realToFrac to go the other way.
14:28:40 <shapr> esr: Yeah, good point.
14:28:44 <ski> ddarius : interesting ..
14:29:00 <ddarius> ski: That didn't do what I was hoping.
14:29:10 <ski> that's why it was interesting
14:29:27 <bitstream0101> aavogt: Where did you see that there's a Fractional EpochTime?
14:30:18 <bitstream0101> yitz: Maybe I'm not following you. I am using utcTimeToPOSIXSeconds to obtain a value of type POSIXSeconds, that's not the problem, but I need an EpochTime from that.
14:30:20 <aavogt> I must have meant   Fractional POSIXTime
14:30:42 <pokoko222> 1 + 1/(2 + 1/(2 + 1/(2 + 1/2)))  What is the recursive function here? how to define this?
14:31:15 <bitstream0101> (correction to the above, utcTimeToPOSIXSeconds to obtain a value of type POSIXTime, I misspoke).
14:31:16 <aavogt> pokoko222: do you see that's a right fold?
14:31:27 <shapr> esr: I like it. I don't think it's necessary to learn Lisp before Haskell, but I do think programmers should be exposed to both. (and Prolog, and PostScript, and ...)
14:31:36 <aavogt> > foldr (/) [a,b,c]
14:31:37 <lambdabot>   No instance for (GHC.Real.Fractional [SimpleReflect.Expr])
14:31:37 <lambdabot>    arising from ...
14:31:41 <pokoko222> aavogt yes but i cant do it, it has been a while since i did haskell
14:31:42 <ezyang> shapr: Eww Postscript
14:31:46 <aavogt> > foldr (*) [a,b,c]
14:31:48 <lambdabot>   No instance for (GHC.Num.Num [SimpleReflect.Expr])
14:31:48 <lambdabot>    arising from a use of...
14:31:53 <yitz> POSIXSeconds is just a NominalDiffTime. The docs for NominalDiffTime say "Conversion functions will treat it as seconds." A Posix Epoch is a CTime, which has a Num instance and represents seconds.
14:31:53 <aavogt> > foldr (/) [a,b,c] :: Expr
14:31:54 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
14:31:54 <lambdabot>         against inferred ...
14:32:06 <Axman6> > let f 0 = 2; f n = 1/(2+f (n-1)) in f 3 :: Expr
14:32:07 <lambdabot>   1 / (2 + 1 / (2 + 1 / (2 + 2)))
14:32:08 <shapr> ezyang: I enjoy stack based languages. They're a lot more fun than I expected.
14:32:09 <yitz> bitstream0101: so you do have it
14:32:18 <ddarius> shapr: Have you learned J yet?
14:32:21 <Axman6> > let f 0 = 1/2; f n = 1/(2+f (n-1)) in f 3 :: Expr
14:32:22 <lambdabot>   1 / (2 + 1 / (2 + 1 / (2 + 1 / 2)))
14:32:28 <shapr> ddarius: Not yet, is there a libre implementation?
14:32:35 <Axman6> > let f 0 = 1/2; f n = 1/(2+f (n-1)) in 1 + f 3 :: Expr
14:32:36 <lambdabot>   1 + 1 / (2 + 1 / (2 + 1 / (2 + 1 / 2)))
14:32:44 <bitstream0101> yitz: I apologize for being dense.  What's the expression I can use to convert between one and the other? I'm missing something.
14:32:56 <ddarius> shapr:  There's only one implementation.
14:33:02 <bitstream0101> yitz: E.g., what conversion functions for NominalDiffTime?
14:33:12 <yitz> bitstream010: try this:  realToFrac . utcTimeToPOSIXSeconds
14:33:33 <shapr> Ah, gratis but not libre... I dunno, maybe one day.
14:33:45 <ezyang> shapr: My distaste might also stem from distaste of LaTeX programming, more than anything logical
14:34:00 <shapr> I don't' mind writing LaTeX either.
14:34:05 <Axman6> > let f 0 = 1/2; f n = 1/(2+f (n-1)) in 1 + f 3
14:34:06 <lambdabot>   1.4137931034482758
14:34:11 <Axman6> > let f 0 = 1/2; f n = 1/(2+f (n-1)) in 1 + f 10
14:34:12 <lambdabot>   1.4142135642135643
14:34:16 <Axman6> > let f 0 = 1/2; f n = 1/(2+f (n-1)) in 1 + f 100
14:34:17 <lambdabot>   1.4142135623730951
14:34:41 <bitstream0101> yitz: As in, :t (realToFrac . utcTimeToPOSIXSeconds) (undefined :: UTCTime) :: Foreign.C.Types.CTime ?
14:34:47 <lelf> > foldr1 (/) [a,b,c]
14:34:47 <bitstream0101> I get: No instance for (Fractional CTime)
14:34:48 <lambdabot>   a / (b / c)
14:34:57 <jmcarthur> @pl f n = 1/(2+f (n-1))
14:34:58 <lambdabot> f = fix ((((1 /) . (2 +)) .) . (. subtract 1))
14:35:01 * yitz nods
14:35:02 <jmcarthur> ew
14:35:24 <yitz> bitstream0101: hmm, a CTime is a Real, but not a Fractional...
14:35:40 <gio123> Cale: hi
14:35:46 <bitstream0101> yitz: ...
14:36:05 <mm_freak> > sqrt 2
14:36:06 <lambdabot>   1.4142135623730951
14:36:25 <bitstream0101> yitz: Right, so it'd make sense that that function doesn't work, right?
14:37:07 <doserj> it is a Enum, I guess
14:37:46 <Trinitron> What's the easiest way to define the Fibonacci numbers in a list in Haskell? My interpreter doesn't like parallel list comprehensions.
14:37:49 <Peaker> I'm toying with wrapping GLUT's mainloop with something that installs all the interesting callbacks and throws them into an Event mvar that some other thread is supposed to be milking.. Is there something that does this already, or better? (Besides reactive-glut)
14:38:02 <jmcarthur> > fixpoint $ \x -> 1 + 1/(x+1)
14:38:03 <lambdabot>   Not in scope: `fixpoint'
14:38:07 <jmcarthur> dang it's gone
14:38:09 <Peaker> Trinitron, fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
14:38:09 <ddarius> > fix ((0:) . scanl (+) 1)
14:38:10 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
14:38:24 <Peaker> Depends on what you mean by "easiest", I guess :)
14:38:33 <Peaker> point-free recursion is still a bit confusing to me :)
14:38:42 <yitz> bitstream0101: yeah. so i guess you need to round it to an integer, since there is no guarantee that CTime will support non-integers. platform dependent i guess. is that ok for you to lose that precision?
14:39:48 <bitstream0101> yitz: Yeah, I think the precision loss is okay.
14:39:54 <Alpounet> > let select = (filterMap ((== True) . snd) fst .) . zip in select [1..10] (map even [1..])
14:39:55 <lambdabot>   [2,4,6,8,10]
14:39:57 <yitz> bitstream010: so try this:  fromInteger . round . utcTimeToPOSIXSeconds
14:40:39 <Trinitron> Why do I need to enclose the addition sign with parentheses?
14:41:14 <bitstream0101> yitz: Which works because I'm to assume that NominalDiff's RealFrac instance "does the right thing"?
14:41:15 <ddarius> Otherwise it would mean scanl + 1, i.e. add scanl to 1
14:41:19 <Peaker> Trinitron, If you don't, you have to use it infix
14:41:22 <mreh> > read 9.9990000e+03
14:41:23 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Base.String)
14:41:23 <lambdabot>    arising from the l...
14:41:25 <mreh> > read "9.9990000e+03"
14:41:26 <lambdabot>   * Exception: Prelude.read: no parse
14:41:29 <jmcarthur> @let fixpoint f = fst . head . dropWhile (uncurry (/=)) . uncurry zip <<< id &&& tail <<< iterate f
14:41:30 <lambdabot>  Defined.
14:41:33 <Peaker> Trinitron, + is infix and (+) is prefix.  So 1 + 2   is equivalent to (+) 1 2
14:41:41 <Trinitron> I see
14:41:44 <jmcarthur> > fixpoint $ \x -> 1 + 1/(x+1)
14:41:45 <lambdabot>   -0.375->
14:41:45 <lambdabot>    1.4142135623730951
14:41:45 <lambdabot>  -0.75->
14:41:45 <lambdabot>    1.4142135623730951
14:41:45 <lambdabot>  -1.5->
14:41:47 <lambdabot>    1....
14:41:50 <jmcarthur> woops
14:42:01 <Stalafin> when using guards, may i combine several evaluations like so: | (a>b) || (a<b) ?
14:42:10 <c_wraith> yes
14:42:15 <Trinitron> So I could say "fibs = 0 : 1 : zipWith fibs + (tail fibs)".
14:42:18 <jmcarthur> > fixpoint (\x -> 1 + 1/(x+1)) 2
14:42:18 <c_wraith> it's just any expression of type Bool
14:42:19 <ddarius> Stalafin: You can write any boolean expression.
14:42:19 <lambdabot>   1.4142135623730951
14:42:24 <yitz> bitstream0101: well, the docs say it represents the number of seconds since the Unix epoch, ignoring leap seconds. i think that is indeed what you want.
14:42:30 <c_wraith> > otherwise
14:42:31 <lambdabot>   True
14:42:41 <bitstream0101> yitz: *nod* Okay, thanks. :)
14:42:48 <jmcarthur> Axman6: ^^ :)
14:42:53 <ddarius> Stalafin: You can put a let expression in there that defines a five page long function that is applied to yield a Bool.
14:42:55 <Saizan> Trinitron: no, because you've to pass (+) as a function as the first argument of zipWith
14:42:57 <yitz> bitstream0101: the leap seconds bit is the difference between DiffTime and NominalDiffTime
14:43:21 <Alpounet> jmcarthur, ok you lost me there
14:43:23 <Saizan> Trinitron: what you wrote is trying to add "zipWith fibs" together with "(tail fibs)"
14:43:26 <c_wraith> > let fibs = 0 : scanl (+) 1 fibs in fibs
14:43:26 <Alpounet> can you give some explanations
14:43:27 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
14:43:31 <pikhq> @src fixpoint
14:43:31 <lambdabot> Source not found. My mind is going. I can feel it.
14:43:32 <Trinitron> Oh. Nice, no function pointers like C.
14:43:40 <jmcarthur> pikhq: @let fixpoint f = fst . head . dropWhile (uncurry (/=)) . uncurry zip <<< id &&& tail <<< iterate f
14:43:42 <Stalafin> ddarius: that's actually a good idea.... i was just wondering, because i am getting a Non-exhaustive patterns in function error
14:43:43 <Trinitron> C function pointers are involved.
14:43:51 <pikhq> jmcarthur: Dankon.
14:44:02 <mreh> > read "1e+1"
14:44:03 <lambdabot>   * Exception: Prelude.read: no parse
14:44:07 <mreh> > read "1"
14:44:09 <lambdabot>   * Exception: Prelude.read: no parse
14:44:11 <jmcarthur> Alpounet: fixpoint applies the function repeatedly until it gets the same result twice
14:44:16 <Saizan> Trinitron: right, you can pass functions around like any other value
14:44:19 <Peaker> > read "()"
14:44:23 <lambdabot>   ()
14:44:24 <bitstream0101> yitz: Hmm, yeah I just noticed the leap seconds bit.
14:44:25 <mreh> > read "1" :: Int
14:44:26 <lambdabot>   1
14:44:29 <Alpounet> oh yeah
14:44:30 <c_wraith> > read "1e+1" :: Double
14:44:31 <lambdabot>   10.0
14:44:34 <mreh> yay
14:44:34 <Trinitron> If only the old languages were like hat.
14:44:36 <Alpounet> the implementation was a bit dark for me
14:44:37 <Trinitron> that*
14:44:37 <bitstream0101> yitz: That seems like it could be a problem for timestamps on files.
14:44:47 <Alpounet> but I think I got it now
14:44:51 <mreh> > read "9.9990000e+03" :: Double
14:44:52 <lambdabot>   9999.0
14:45:09 <Trinitron> Imperative languages seem to be low level now, not on the same level as a problem, but I'm sure some here would disagree.
14:45:10 <Alpounet> yeah I get it
14:45:12 <Alpounet> haha
14:45:18 <mreh> is read magic?
14:45:25 <jmcarthur> > fixpoint sqrt 2
14:45:26 <lambdabot>   1.0
14:45:29 <yitz> bitstream0101: well, unix time ignores them, Data.Time usually doesn't. Since several leap seconds have occurred since 1970, you'll be off otherwise
14:45:33 <c_wraith> @src Read
14:45:33 <lambdabot> class Read a where
14:45:33 <lambdabot>   readsPrec    :: Int -> ReadS a
14:45:33 <lambdabot>   readList     :: ReadS [a]
14:45:33 <lambdabot>   readPrec     :: ReadPrec a
14:45:33 <lambdabot>   readListPrec :: ReadPrec [a]
14:45:40 <c_wraith> Read is just a typeclass function
14:45:47 <bitstream0101> yitz: yeah, i guess it has some logistical challenges :P
14:45:50 <mreh> C is a high level programming language
14:45:51 <Peaker> Trinitron, Haskell didn't yet abolish imperative programming. Most Haskell programs have a significant imperative subset
14:45:53 <c_wraith> well, or implemented in terms of them
14:45:59 <Peaker> Though Haskell is pretty good at imperative programming too
14:46:00 <bitstream0101> yitz: it'd get out of data pretty quickly.
14:46:07 <ski> esr : variables do have types, but you don't have to type them manually. the compiler can do type inference fine even if you omit type signatures on functions (except in some special, somewhat rare cases), but it is (usually, i think) considered good style to "comment" top-level functions with type signatures (some persons might disagree, here)
14:46:08 <yitz> bitstream0101: time is inherently complicated
14:46:11 <Trinitron> Which parts are imperative?
14:46:16 <Peaker> Trinitron, The IO monad
14:46:20 <bitstream0101> yitz: unix time ignoring them is good enough for me; I wasn't sure about that. Thanks again :)
14:46:22 <Trinitron> I see.
14:46:27 <jmcarthur> and the ST monad
14:46:35 <Trinitron> So only monads are imperative?
14:46:39 <mreh> all strict monads
14:46:40 <jmcarthur> not all monads are
14:46:45 <Peaker> Trinitron, Monads are not in general imperative
14:46:55 <Trinitron> So only strict monads are imperative?
14:47:02 <mreh> that was a guess
14:47:02 * ski thinks monads in general are imperative :)
14:47:08 <jmcarthur> imperative ideas happen to be monadic
14:47:09 <Peaker> Trinitron, once you dive deep into the functional/imperative distinction, it becomes more evasive than it initially seems
14:47:17 <Trinitron> The rest are purely functional?
14:47:22 <Trinitron> Right.
14:47:22 <mreh> lazt
14:47:25 <mreh> lazy
14:47:27 <Alpounet> > fixpoint (flip (**) 10) 0.1
14:47:28 <lambdabot>   0.0
14:47:29 <ski> (including `Maybe' and `[]' and `(e ->)' and `Cont o' and `Identity' ;)
14:47:33 <Trinitron> But the real world is inherently stateful.
14:47:40 <Trinitron> Such as a bank account.
14:47:41 <Peaker> Trinitron, And a good way some agree to define it is: "Imperative = (usually monads with) Complex semantics, functional = simple/denotational semantics"
14:47:44 <Zao> Trinitron: Depends on who you ask.
14:47:56 <mreh> could be approximate 1.5 with an infinite series? I wanna see that done
14:48:00 <jmcarthur> Trinitron: i disagree
14:48:02 <Peaker> Trinitron, "Stateful" and "imperative" are different concepts. I, for one, think pure functional programming handles statefulness better :)
14:48:04 <mreh> 2 even
14:48:05 <Stalafin> i don't understand: when i use guards, why would i even get a 'Non-exhaustive patterns in function' error? i mean, shouldn't 'otherwise' catch everything that's out of the ordinary?
14:48:25 <Peaker> Trinitron, BankAccount -> BankAccount   functions, for example, are inherently transactional
14:48:36 <Alpounet> guards don't cover patterns
14:48:42 <Peaker> Trinitron, Whereas destructive writes to a bank account data structure in a typical imperative language means your account goes through intermediate incoherent states
14:48:44 <Zao> Stalafin: In what patterns?
14:48:48 <Peaker> Trinitron, which is error-prone and dangerous
14:48:51 <jmcarthur> mreh: what do you mean approximate 1.5 with infinite series?
14:48:58 <mreh> jmcarthur: 2
14:48:59 <jmcarthur> > fixpoint (const 1.5) 100
14:49:00 <lambdabot>   1.5
14:49:01 <Zao> Stalafin: otherwise as a guard is a catch-all, yes.
14:49:03 <jmcarthur> > fixpoint (const 2) 100
14:49:04 <lambdabot>   2
14:49:11 <Trinitron> Fuctional style returns a new bank account.
14:49:13 <Zao> Stalafin: otherwise as a pattern, matches True booleans.
14:49:19 <mreh> 1 + 1/2 + 1/4...
14:49:20 <Trinitron> That's funny at first
14:49:21 <mreh> that one
14:49:23 <Alpounet> patterns are like [] and x:xs for lists
14:49:37 <Alpounet> guards are constraints on what appears before the |
14:49:41 <ski> `otherwise' as a pattern, matches any value
14:49:51 <Peaker> Trinitron, Also, some would say the universe is a pure function of space/time
14:49:52 <mornfall> Trinitron: So when you withdraw 10 eur, you have accounts worth of 2n-10? : - )
14:49:55 <monadic_kid> it's easy to make that parameter disappear
14:49:58 <Peaker> Trinitron, rather than a state-changing sequence
14:50:03 <ski> > let f otherwise = otherwise + 1 in f 40
14:50:04 <lambdabot>   41
14:50:18 <Stalafin> Zao: http://pastebin.com/H5Px1AKD
14:50:24 <Trinitron> Now you're getting philisophical. Where is the super soaker?
14:50:28 <Peaker> Trinitron, Haskell makes it very easy to compose (a -> a) functions together to go from some initial a to some later a
14:50:40 <monadic_kid> BankAccount -> BankAccount to MonadSate BankAccount m => m ()
14:50:41 <Zao> ski: Oh right. I just realized that trying to get lambdabot to fail.
14:50:57 <Peaker> Trinitron, The point is that arguments like "the universe is inherently..." are tautological - they only reflect your view on things
14:51:03 <Stalafin> Zao: so yeah, that's the one i am getting errors for
14:51:04 <Zao> Stalafin: If the list has 0-2 elements, you'll miss.
14:51:12 <lament> the universe is inherently purple.
14:51:15 <Trinitron> I've never used a monad. I only wrote my first real Haskell program yesterday.
14:51:23 <jmcarthur> mreh: my fixpoint function isn't enough for a simple, direct solution, but a version with an accumulator could do it easily
14:51:26 <tensorpudding> the universe inhereits Object
14:51:35 <Peaker> Trinitron, and arguments about the machine ("The machine is inherently..") are meaningful in some contexts, but I don't think they are meaningful when trying to find the best language to *model* things (where you don't care how they run on the machine)
14:51:41 <mreh> @wn monad
14:51:42 <lambdabot> *** "monad" wn "WordNet (r) 2.0"
14:51:42 <lambdabot> monad
14:51:42 <lambdabot>      n 1: an atom having a valence of one
14:51:42 <lambdabot>      2: a singular metaphysical entity from which material
14:51:42 <lambdabot>         properties are said to derive [syn: {monas}]
14:51:44 <lambdabot>      [also: {monades} (pl)]
14:51:55 <Trinitron> Yeah, I was actually quoting something I read.
14:51:58 <Trinitron> Heh.
14:51:59 <monadic_kid> Trinitron: you did but you just didn't realize it
14:52:01 <mreh> I never understood why they called them monads
14:52:07 <lament> i don't know what the universe is, but a void pointer can point to it.
14:52:11 <flazz> i have a [ IO [a] ] and i want IO [a] as if return $ flatten [a], but without the IO in there to mess it up :)
14:52:12 <tensorpudding> i've never seen the (1) definition before
14:52:14 <Zao> Stalafin: Your guards there both belong to the function you're matching there.
14:52:18 <lelf> Oh. singular metaphysical entity
14:52:29 <Peaker> Trinitron, Monads are not complicated, but apparently they are difficult to learn.  The Typeclassopedia has a good explanation of them
14:52:30 <tensorpudding> (2) is the one that Leibniz invented
14:52:32 <ski> flazz : `sequence'
14:52:37 <Trinitron> Ok thanks Peaker.
14:52:39 <Peaker> mreh, what would you call them?
14:52:43 <Trinitron> The last language I used a lot was Python. Everyone was raving about it.
14:52:44 <flazz> ski: that is it?
14:52:52 <Peaker> Trinitron, I loved Python, then I discovered Haskell :)
14:52:54 <jmcarthur> @let fixpointWith f c = fst . head . dropWhile (uncurry (not . c)) . uncurry zip <<< id &&& tail <<< iterate f
14:52:54 <ski> flazz : or, hm, didn't notive the outer `[..]'
14:52:54 <lambdabot>  <local>:17:52:
14:52:55 <lambdabot>      Couldn't match expected type `b -> c' against inferred t...
14:52:56 <mreh> Peaker: spacesuits
14:52:59 <Trinitron> But it's your run of the mill, sugared up C.
14:52:59 <psykotic> @type sequence
14:53:00 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
14:53:02 <Zao> Stalafin: If I say   coords [1,2]   , what happens?
14:53:02 <jmcarthur> oh i suck
14:53:10 <Trinitron> standard VHL language.
14:53:11 <ski> @type lift concat . sequence
14:53:12 <lambdabot>     Couldn't match kind `(* -> *) -> * -> *' against `?? -> ? -> *'
14:53:12 <lambdabot>     When matching the kinds of `t :: (* -> *) -> * -> *' and
14:53:13 <lambdabot>                                `(->) :: ?? -> ? -> *'
14:53:19 <ski> @type liftM concat . sequence
14:53:20 <lambdabot> forall a (m :: * -> *). (Monad m) => [m [a]] -> m [a]
14:53:22 <Cale> :t fmap concat . sequence
14:53:23 <lambdabot> forall a (f :: * -> *). (Functor f, Monad f) => [f [a]] -> f [a]
14:53:28 <ski> flazz : try that ^
14:53:32 <jmcarthur> @let fixpointWith c f = fst . head . dropWhile (uncurry (not . c)) . uncurry zip <<< id &&& tail <<< iterate f
14:53:33 <lambdabot>  <local>:17:52:
14:53:33 <lambdabot>      Couldn't match expected type `b -> c' against inferred t...
14:53:41 <mreh> haskell is a good way of intimidating your peers
14:53:42 <Trinitron> Argh I have to write a shell in C this semester.
14:53:45 <mreh> that's why I do it
14:53:53 <jmcarthur> i suck a lot. i get what i did now
14:53:59 <Trinitron> I want to write it in haskell.
14:54:03 <Zao> Stalafin: When a function is invoked, the patterns are matched one by one until one that seems to work is found. If it has guards, they are tried top-down. If none of the guards pass, fall through to the next pattern.
14:54:26 <jmcarthur> @let fixpointWith c f = fst . head . dropWhile (uncurry ((fmap.fmap) c)) . uncurry zip <<< id &&& tail <<< iterate f
14:54:27 <mreh> Trinitron: GHC can compile to C IIRC
14:54:27 <lambdabot>  <local>:17:43:
14:54:27 <lambdabot>      Couldn't match expected type `Bool' against inferred typ...
14:54:30 <ski> Trinitron : i suppose you can't let GHC handle the "to C" conversion ..
14:54:36 <Trinitron> Heh.
14:54:37 <jmcarthur> *sigh* i quit
14:54:38 <mreh> :D
14:54:44 <Trinitron> I have to hand in .c files
14:54:44 <jmcarthur> too much kernel programming, not enough haskell programming
14:54:49 <Peaker> Cale, (fmap concat .)  = (fmap . fmap)  in Caleskell right?
14:54:51 <Stalafin> Zao: i understand..... hmhmhm, my list always has 3 elements at least; but i get your point
14:55:01 <Peaker> oops
14:55:08 <Peaker> fmap (x .) = (fmap . fmap) x
14:55:08 <mreh> someone made the first verifiable OS recently
14:55:11 <c_wraith> trinitron: maybe you can use the -fvia-c optio to ghc. :)
14:55:14 <Trinitron> Most university use pedagogies 30 years old.
14:55:18 <Trinitron> universities*
14:55:29 <Trinitron> For comp sci
14:55:42 <Peaker> mreh, Hypervisor iirc
14:55:45 <Trinitron> My university started me on a OO language first.
14:56:08 <Trinitron> Danger Will Robinson! Danger! Danger!
14:56:21 <mreh> 30 years old? like ALGOL?
14:56:27 <Zao> Either add in a catch-all base case = error "won't happen"; consider a different definition; or ignore it.
14:56:29 * ski is reminded of the old game "Menace" ..
14:56:33 <Peaker> OO was great at bringing encapsulation and polymorphism to the masses. Unfortunately it brought inheritance with it
14:56:36 <mreh> Peaker: thanks
14:56:54 <Trinitron> Well, my point was really that we learn OO as our idea of programming,
14:57:07 <Trinitron> which is stupid, I know another university that teaches Haskell in first year,
14:57:14 <jmcarthur> @let fixpointWith c f = fst . head . dropWhile (not . uncurry c) . uncurry zip <<< id &&& tail <<< iterate f
14:57:16 <lambdabot>  Defined.
14:57:18 <Trinitron> But at least I'm learning now.
14:57:20 <ddarius> FP is older than OOP.
14:57:39 <Trinitron> Lisp isn't purely functional
14:57:43 <ski> @type fixpointWith
14:57:44 <lambdabot> forall a. (a -> a -> Bool) -> (a -> a) -> a -> a
14:57:51 <mreh> it so is
14:57:54 <flazz> ski: (liftM concat . sequence) FTW!
14:58:18 <mreh> Miranda is older than OOP
14:58:19 <jmcarthur> > let f (acc, x) = (acc+x, x/2) in fst $ fixpointWith ((==) `on` fst) (0, 1)
14:58:20 <lambdabot>   Couldn't match expected type `(a, b) -> (a, b)'
14:58:20 <lambdabot>         against inferred ty...
14:58:32 <ski> flazz : of course, depending on your particular use, it might be nicer to use `mapM', instead of `map' and `sequence'
14:58:35 <ddarius> Trinitron: ISWIM is.
14:59:00 <Trinitron> That's also imperative.
14:59:04 <sshc> how do I load a file with the CPP extention?
14:59:07 <sshc> within ghci?
14:59:23 <c_wraith> sshc: does using a language pragma work?
14:59:49 <Peaker> ddarius, FP with polymorphism?
14:59:57 <Peaker> ddarius, Lisp wasn't very polymorphic
15:00:05 <sori> Peaker: Hi. I haven't followed your discussion, but could you maybe explain what is bad about inheritence?
15:00:09 <ddarius> Peaker: I didn't say anything about polymorphism.
15:00:17 <Peaker> ddarius, Ah, ok
15:00:36 <commanace> let's say i've f :: (MyClass a) => a -> Int (or something similar), can i then somehow pattern match on the first parameter? or, putting it differently: when I run in such a situation, does that mean, that I made a wrong design decision? :)
15:01:04 <ski> commanace : you can't pattern-match on the `a' argument there, no
15:01:25 <Trinitron> http://en.wikipedia.org/wiki/Haskell_(programming_language)#Criticism - my respsonse is Paragraph 1: Who cares  Paragraph 2: It pays off once you know what you're doing.
15:01:38 <Trinitron> Static typing is good.
15:01:52 <jmcarthur> > let f (acc, x) = (acc+x, x/2) in fst $ fixpointWith ((==) `on` fst) f (0, 1)  -- mreh
15:01:53 <lambdabot>   2.0
15:01:57 <ski> commanace : either defer to the operations in `MyClass', or maybe use an algebraic data type instead of the class
15:02:00 <ben> Ah, the paragraph is quoting Simon Peyton Jones, the most vocal critic of Haskell
15:02:05 <ski> (depends on what you're doing, of course)
15:02:06 <Peaker> sori, Inheritance flaws (as it typically is in most languags I know) (IMO): A) Namespace mangling [different authors' names collide] B) Interface between super-class and sub-class is not well-specified (if at all!) C) Single-dispatch polymorphism based on it is extremely limited  D) Does both interface instantiation and type products and other unrelated things  E) Semantics are too complex
15:02:13 <danderson> is there an obvious function I'm missing to get a thread to sleep for ever?
15:02:28 <ben> ... kill it?
15:02:33 <Trinitron> Peaker, just try and learn C++.
15:02:36 <mauke> forever (threadDelay maxBound)
15:02:40 * Trinitron shudders
15:02:42 <Stalafin> Zao: the thing i posted the link to, i was using that function without any guards first; it worked fine; just after i introduced guards i got this error
15:02:45 <jmcarthur> takeMVar =<< newEmptyMVar
15:02:52 <commanace> ski: hm... thanks :)
15:02:52 <mauke> jmcarthur: that may get you killed
15:02:57 <danderson> (reason: I'm starting various threads that do a lot of stuff, and don't have the overseer management code to run yet
15:03:01 <danderson> jmcarthur: nice, thanks.
15:03:05 <jmcarthur> same thing as sleeping forever
15:03:11 <Peaker> Trinitron, It's better than Python in A and B. At least Python doesn't need inheritance most of the time
15:03:28 <Trinitron> Yes.
15:03:30 <sshc> c_wraith: yes
15:03:38 <Trinitron> Python is dastardly in complexity, acutally.
15:03:40 <ski> Peaker : F) code of class and subclass too tightly coupled
15:03:44 <Trinitron> C is easier to learn.
15:03:54 <Trinitron> Despite what people say.
15:03:55 <Peaker> ski, Yeah, I guess this kinda results from B
15:03:55 <sshc> c_wraith: the file i'm trying to load with ghci wants Data.Binary from the binary package, but ghci is hiding it.
15:04:33 <c_wraith> ghci doesn't hide anything by default.
15:04:35 <Peaker> and my D and E are pretty much the same too
15:04:36 * ddarius thinks ski is relating the requirements of Liskov substitutibility.
15:04:49 <ddarius> ("substitutibility" is a ridiculous word)
15:05:06 <ski> commanace : generally, don't make a type class if you can't already think of two different types you want as instances
15:05:13 <mreh> if OOP is an intellectual fad, would you say O'Caml is evil?
15:05:23 <Peaker> Mutable data + Liskov -> Inheritance is pretty much only usable to instantiate interfaces.. And this is far better done by type-classes or passing records explicitly
15:05:27 <mreh> I might apply for an internship where they do O'Caml
15:05:42 <Peaker> @quote ill-defined
15:05:42 <lambdabot> No quotes match. Take a stress pill and think things over.
15:05:46 * ddarius doesn't have a problem with a lot of the ideas in OOP.
15:06:05 <sshc> c_wraith:     Could not find module `Data.Binary':
15:06:06 <Peaker> ddarius, What good ideas do you think OOP has (besides encapsulation and polymorphism)?
15:06:06 <sshc>       It is a member of the hidden package `ghc-binary-0.5.0.2'.
15:06:14 <sshc> c_wraith: how do I unhide it?
15:06:25 <sshc> c_wraith: I'm using the "l" command from ghci
15:06:29 <ski> mreh : aiui, they don't really use the OO system in O'Caml that heavily ..
15:06:44 <Trinitron> Protip: to save one keystroke, go to gogle.com.
15:06:55 <Trinitron> saves you time, that adds up
15:07:03 <Trinitron> :D
15:07:12 * jmcarthur just types search terms in his url bar
15:07:13 <pantsman> thx4datip
15:07:20 <c_wraith> sshc: If you didn't tell ghci to hide the package yourself, I don't know why it's hidden.  see if ghc-pkg lists the package as hidden
15:07:23 <sori> Peaker, I see. But usually for the programmers I think the practical good thing about (the usual) OOP is that the inheritance allows you to write less code
15:08:09 <mreh> unfortunately hardly anything is really an object
15:08:12 <pantsman> but code reuse is not the point of inheritance
15:08:13 <mreh> as I see it
15:08:33 <Peaker> sori, There are other methods that save even more code, and have much nicer semantics and more power
15:08:45 <ski> (pantsman : .. interface or implementation inheritance ?)
15:08:56 <Peaker> mreh, What does it mean that something is "an object"?
15:09:13 <mreh> Peaker: requires encapsulated state
15:09:14 <ddarius> Peaker: I don't consider encapsulation a concept owned by OO, and I assume by polymorphism you mean dynamic dispatch which I think is a good idea.  I don't really have a problem with subtyping (also not an idea owned by OO, in my opinion) or with interface inheritance.  I also view the conceptual perspective of OO, not inappropriate and quite natural to concurrent programming.
15:09:29 <pantsman> ski, interfaces don't really help code reuse do they, they're just contracts
15:09:37 <ski> Peaker : that is a value in a (possibly coinductive) record type
15:09:43 <Peaker> ddarius, You mean the actor model?
15:09:46 <sori> Peaker, I don't disagree that, but I was just trying to put what is practically useful of inheritence. . .
15:09:48 <ddarius> Peaker: No.
15:10:00 <pookleblinky> Encapsulation aims to produce orthogonal code... exactly as functional programming *forces* you to do.
15:10:02 <sshc> c_wraith: how do I do that?
15:10:17 <mornfall> pookleblinky: How does it force you?
15:10:17 <pookleblinky> OOP tries to do what any FP actually accomplishes.
15:10:29 <Peaker> ddarius, Concurrent entities messaging each other (Actors) is the conceptual OO model, isn't iT?
15:10:31 <copumpkin> OOPs
15:10:33 <ddarius> Peaker: Or at least, not necessarily.  I just mean that concurrent programming naturally leads to a style of programming rather like OO (but missing some things usually considered OO such as inheritance.)
15:10:35 <sshc> c_wraith: Running ghc-pkg expose  seemed to fix it
15:10:41 <mreh> pookleblinky, can you explain what you mean by orthogonal?
15:10:43 <mreh> in this context
15:10:45 <sshc> c_wraith: this terminal doesn't like pasting
15:10:53 <metaperl> I wish this patch would get added to Haskell Platform - http://trac.haskell.org/haskell-platform/ticket/84
15:10:54 <ddarius> Peaker: Actors has more baggage than that.
15:10:57 <ski> pantsman : i've not claimed yea or nay to that
15:11:07 <Peaker> ddarius, oh, what else?
15:11:17 <Peaker> ddarius, Concurrency can also lead you to things like NDP or pseq/etc
15:11:25 <pookleblinky> mornfall, it is difficult to add side-effects into haskell code at the same level as with the equivalent in OOP.
15:11:26 <ddarius> Peaker: Well, for a start do you consider Erlang to be Actor-based concurrency?
15:11:33 <Peaker> ddarius, as far as I know, yeah
15:11:42 <ddarius> Peaker: Both of those have no concurrency in them whatsoever.
15:11:46 <Peaker> (I only know Erlang superficially)
15:11:52 <mornfall> pookleblinky: Maybe I just misunderstand what you mean with orthogonal...
15:12:14 <jethr0_> good <time of day> haskell!
15:12:19 <Peaker> ddarius, Oh, ok, then it may lead you to things like Reactive/FRP
15:12:19 <mornfall> pookleblinky: (But if you mean composable, then, although FP is better for that, it's by no means a panacea...)
15:12:34 <Trinitron> How do I sum a list of numbers?
15:12:37 <pookleblinky> Orthogonal means the lack of side-effects. Function foo does not add two numbers then reset the framebuffer then order a pizza.
15:12:39 <jmcarthur> An interesting thought to consider: concurrency lends itself to OO ideas, and parallelism lends itself to FP ideas.
15:12:42 <Peaker> ddarius, I think that's the most "natural" concurrency
15:12:43 <Trinitron> The sugar way?
15:12:47 <mreh> I'm supposed to be writing my ant colony into existence
15:12:48 <jethr0_> does anyone know what kind of software realworldhaskell.org runs on?
15:12:52 <Peaker> Trinitron, sum [1,2,3]
15:12:59 <jethr0_> i'd love to use that software for my own book project...
15:13:04 <jmcarthur> Peaker: unfortunately FRP is not fully discovered yet
15:13:26 <Trinitron> What happens if I call sum on an infinite list?
15:13:29 <metaperl> jethr0_: I think the book was writtein Docbook
15:13:39 * ski thinks declarative concurrency, as with dataflow variables, is interesting
15:13:40 <jmcarthur> Trinitron: it runs until you get bored
15:13:42 <mornfall> Trinitron: Nothing. :)
15:13:48 <Peaker> jmcarthur, well, not in its Reactive (temporal) form.. In more limited forms, there are some working libraries
15:13:49 <metaperl> jethr0_: I think CosmicRay uses Drupal for other parts
15:13:53 <jethr0_> metaperl: hmm, i was thinking of the software the website runs on (inline comment functionality, etc.)
15:13:54 <ddarius> Peaker: When I use the term "concurrency", I usually mean it to mean observable (i.e. non-deterministic) concurrency.  NDP/pseq is parallelism.
15:13:59 <metaperl> jethr0_: the blog has some comments on the comment system
15:14:02 <pookleblinky> mornfall, nothing unless he actually asks for that sum.
15:14:09 <jethr0_> "comment system"?
15:14:11 <jmcarthur> Peaker: granted, but i don't really find those limited forms to be all that "natural"
15:14:12 <jethr0_> > sum [1..]
15:14:17 <metaperl> jethr0_: if you do a google reverse search on realworldhaskell.org for source ... you will see a blog comment on that
15:14:18 <lambdabot>   mueval: ExitFailure 1
15:14:23 <Peaker> ddarius, Yes, I am familiar with that definition, I usually use it that way too, not sure why I read parallelism when you wrote concurrency :)
15:14:31 <jmcarthur> ddarius: FRP address nondeterministic concurrency
15:14:34 <jmcarthur> *addresses
15:14:56 <jethr0_> metaperl: cool! not sure what you mean by "reverse search" though
15:14:59 <Trinitron> so far I have "sum filter even 0 : 1 : zipWith (+) fibs (tail fibs)" but I only want to add numbers that are <= 4000000.
15:15:04 <jmcarthur> oh i misread the intent of that statement
15:15:10 <Trinitron> I'm doing PE 2.
15:15:12 <mreh> > reverse "realworldhaskell.org"
15:15:14 <jmcarthur> didn't realize that Peaker related concurrency to ndp
15:15:15 <lambdabot>   "gro.lleksahdlrowlaer"
15:15:15 <Peaker> Trinitron, You are missing some parenthesis
15:15:27 <ddarius> Peaker: One thing the Actor model often suggests, for example, is asynchronous message passing.  For the natural OO style arising from concurrency, asynchronous v. synchronous is irrelevant, i.e. a natural OO-like style would emerge either way.
15:15:29 <jethr0> > filter (<10) [1..]
15:15:33 <lambdabot>   mueval-core: Time limit exceeded
15:15:36 <metaperl> jethr0_: goto google.com and type in this - site:realworldhaskel.org source  and look through the results ... they will mention django
15:15:38 <Peaker> Trinitron, Take a look at takeWhile
15:15:39 <jethr0> > takeWhile (<10) [1..]
15:15:40 <lambdabot>   [1,2,3,4,5,6,7,8,9]
15:15:58 <ski> (Erlang definitely has non-deterministic concurrency)
15:16:09 <jmcarthur> i think the important thing about OO is message passing
15:16:09 <jethr0> metaperl: thx a lot. i had hoped that it was sth. out of the box ;(
15:16:16 <ddarius> Peaker: Also, usually there are specific ideas about how actors are structured which is more baggage than I think is necessary, though Actors are indeed a fine OO-like system grown out of concurrency.
15:16:51 <metaperl> jethr0: http://www.realworldhaskell.org/blog/2008/02/10/about-our-comment-system/
15:17:07 <metaperl> I do think the comment system is quite sweet as well :)
15:17:10 <Peaker> ddarius, And I think that model is not a very good one, because message passing easily grows intermediate incoherent states, which when combined with concurrency, cause a real mess.. unless you use something like STM, I guess.  I prefer the FRP model
15:17:35 <jethr0> metaperl: very nice. thank you so much!
15:17:36 <Trinitron> sum filter even takeWhile (<=4000000) 0 : 1 : zipWith (+) fibs (tail fibs)     parse error (possibly incorrect indentation)
15:17:36 <Trinitron> Failed, modules loaded: none.
15:17:39 <Peaker> ddarius, (message object A to destructively update its state, then message object B -> incoherent intermediate state)
15:18:03 <Peaker> Trinitron, as I said, you're missing ().  Function application is left-assocative, so that parses like:  ((sum filter) even) ...
15:18:27 <Peaker> Trinitron, so you're trying to treat the "filter" function itself as a list of things to sum there
15:18:29 <jethr0> Trinitron: start slow! from what I'm seeing you are not composing your functions correctly (regarding parens, etc.)
15:18:33 <jmcarthur> Peaker: i'd say that if you are doing that in a concurrent environment then you designed your object wrong
15:18:41 <Peaker> Trinitron, You want something like   sum (filter even (takeWhile ...
15:18:57 <jethr0> > sum . takeWhile (<10) $ [1..]
15:19:00 <lambdabot>   45
15:19:03 <Peaker> jmcarthur, Well, how do you design it otherwise? You need a world-update that involves more than one object
15:19:16 <jmcarthur> Peaker: objects are typically given documented invariants that must remain true after each message is handled
15:19:25 <Stalafin> is this wrong? >> http://pastebin.com/nqTLAU8e
15:19:34 <Peaker> jmcarthur, what about inter-object invariants?
15:19:44 <Stalafin> gives me an error : parse error in pattern
15:19:48 <jmcarthur> Peaker: if you have such a thing then they should not be separate objects
15:20:03 <mauke> Stalafin: yes, coords m:[] is parsed as (coords m) : []
15:20:06 <Peaker> jmcarthur, the whole idea is to have modularity through division into little objects
15:20:20 <jmcarthur> Peaker: but you are not describing a modular design
15:20:24 <Stalafin> mauke: love you, thanks
15:20:28 <Peaker> jmcarthur, and there's really nothing wrong about having a lot of your "current state" get updated in some cases
15:20:30 <ddarius> Inter-object invariants are handled through protocols just like the Internet.
15:20:32 <Peaker> jmcarthur, Why not?
15:20:35 <mauke> Stalafin: on the other hand, the parens in ((m ==  20) || (n == 20)  || (o == 20)) are completely redundant
15:20:47 <Peaker> ddarius, Like a mutex protocol?
15:20:56 <mauke>   | 20 `elem` [m, n, o]
15:21:04 <Peaker> ddarius, I think that path leads to deadlocks and/or more tight coupling
15:21:06 <jmcarthur> Peaker: no, there is nothing wrong with state updates. but the basic rule is that objects should be coherent before and after each message is handled
15:21:08 <Trinitron> sum (filter even (takeWhile (<=4000000) 0 : 1 : zipWith (+) fibs (tail fibs)))
15:21:13 <Trinitron> Parse error
15:21:34 <Peaker> jmcarthur, Well, assuming you managed to get good modularity, and have a lot of little objects -- now you might need to update a lot of them transactionally
15:21:36 <jmcarthur> Peaker: the internet does not use mutexes
15:21:48 <ddarius> Peaker: The example I mentioned was the Internet.  I find it hard to say the "nodes" of the Internet are tightly coupled or that the Internet deadlocks.
15:22:00 <jmcarthur> Peaker: look at the ideas of REST, for example. every request is transactional
15:22:10 <Peaker> well, the internet is willing to give correctness up for various corner cases
15:22:17 <jmcarthur> Peaker: division is not necessarily modularity
15:22:20 <Trinitron> is it because takeWhile (<=4000000) 0: 1 etc is interpreted as (takeWhile (<=400000) 0) :1 etc
15:22:21 <Trinitron> ?
15:22:24 <ddarius> Peaker: Define "correctness."?
15:22:32 <Peaker> When routers update each other, they do so without mutexes - but they also get incoherent intermediate states
15:22:37 <Peaker> ddarius, No route loops
15:22:48 <jmcarthur> Peaker: a module is by definition self-contained, and a set of objects that are interdependent is anything but self-contained
15:23:12 <Peaker> jmcarthur, I think lots of complex systems have a lot of small objects that need to be updated transactionally
15:23:26 <jmcarthur> Peaker: i do too, but that doesn't mean they are designed well
15:23:27 <Peaker> jmcarthur, Even if they are loosely coupled
15:23:40 <copumpkin> is there a nice abstract mathematical definition of what happens with log's transformation of exponentiation to multiplication and multiplication to addition?
15:23:46 <Peaker> jmcarthur, (Some "coordinator" might be in charge of the "glue", being aware that they even exist)
15:23:55 <jmcarthur> Peaker: i'm not going to deny that your situation should never ever happen, for the record
15:24:14 <jmcarthur> but that's what protocols are for
15:24:26 <ddarius> copumpkin: It's a group/monoid homomorphism.
15:24:48 <Trinitron> sum (filter even (takeWhile (<=4000000) 0 : 1 : zipWith (+) fibs (tail fibs))) parse error (possibly incorrect indentation) Anyone got an idea?
15:24:49 <Peaker> jmcarthur, your protocol might include something like: 1) lock everyone (stop handling requests) 2) update everyone to new state 3) unlock everyone
15:25:01 <ddarius> copumpkin: You might even say (on suitable domains) it is a group isomorphism.
15:25:07 <copumpkin> ddarius: I guess that makes sense :)
15:25:23 <Peaker> Trinitron, : has lower precedence than function application (of takeWhile)
15:25:23 <jmcarthur> Peaker: sure, but then your objects' invariants are (coherent state) || (locked)
15:25:31 <jmcarthur> Peaker: meaning the invariants still hold
15:25:35 <Peaker> Trinitron, You should have: takeWhile (..) (0 : 1 : ...)
15:25:39 <Trinitron> ok
15:25:43 <jmcarthur> Peaker: but if that invariant doesn't hold, you are doing OO wrong
15:25:48 <Peaker> jmcarthur, right -- that's why I said you go into mutex land when you go protocols though
15:25:51 <Trinitron> thanks
15:25:57 <Trinitron> I don't know the precendence rules.
15:25:58 <Peaker> jmcarthur, if you use the lock/unlock protocol that'll probably work
15:26:00 <benmachine> the most common causes of parse errors are mismatched parentheses
15:26:01 <jmcarthur> Peaker: but a mutex doesn't have to mean in the global sense
15:26:09 <jmcarthur> Peaker: the object can handle the locking itself
15:26:11 <benmachine> or, as it says, incorrect indentation
15:26:13 <Peaker> Trinitron, the main precedence rule to remember is that function application is stronger than all infix operators
15:26:22 <Peaker> jmcarthur, It doesn't matter
15:26:35 <Peaker> jmcarthur, It still leads to the same deadlock/coupling issues
15:26:42 <Trinitron> Oh, I thought some infix operators could have higher precedence. Thanks then.
15:27:19 <jmcarthur> Peaker: i'd still say you can always design such a concurrent system to not need transactions
15:27:36 <jmcarthur> i'm not arguing against STM. i think it's a fine piece of technology with perfectly good use cases
15:27:38 <Trinitron> sum (filter even (takeWhile (<=4000000) (0 : 1 : zipWith (+) fibs (tail fibs)))) still an error.
15:27:38 <jmcarthur> but it's not OO in style
15:27:46 <Peaker> jmcarthur, If your state update is complex and requires querying something -- and that query depends directly or indirectly on a request.. you're toast. This is a kind of tight-coupling. Too much thinking about the how, and not about the "what". I don't like this model
15:27:47 <Trinitron> parse error
15:27:57 <benmachine> > sum (filter even (takeWhile (<=4000000) (0 : 1 : zipWith (+) fibs (tail fibs))))
15:27:57 <mreh> watching SPJ is much more fun than reading his slides
15:27:58 <lambdabot>   Not in scope: `fibs'Not in scope: `fibs'
15:28:03 <benmachine> hmm
15:28:03 <jmcarthur> Peaker: exactly. and that's not good OO design either
15:28:06 <Peaker> jmcarthur, How do you avoid a transaction in a big system that needs to handle requests in a coherent manner?
15:28:07 <ddarius> mreh: Agreed.
15:28:13 <Trinitron> whoops
15:28:16 <benmachine> > let fibs = undefined in sum (filter even (takeWhile (<=4000000) (0 : 1 : zipWith (+) fibs (tail fibs))))
15:28:17 <lambdabot>   * Exception: Prelude.undefined
15:28:21 <benmachine> not a parse error
15:28:24 <ddarius> mreh: I think most people would be entertained by his short STM talk even if they knew nothing about programming.
15:28:28 <jmcarthur> Peaker: messages should themselves be transactional
15:28:31 <benmachine> therefore there is something you are not telling us :)
15:28:55 <Peaker> jmcarthur, But a single message can only update 1 object. At our workplace, for example, we have nodes running on multiple computers, all need to be updated
15:29:02 <mreh> ddarius: the guy that filmed at OSCON 2007 seems to keep the camera focused on him, rather than showing what he's put on the screen :)
15:29:12 <Peaker> jmcarthur, And we don't want an incoherent state where some nodes are responding with new state, some with old
15:29:14 <jmcarthur> Peaker: right, 1 object. encapsulation
15:29:21 <Peaker> jmcarthur, How do you avoid a transaction here?
15:29:35 <Trinitron> how do I do 0 : 1 : zipWith (+) fibs (tail fibs) and replace fibs with itself inside an expression?
15:29:39 <ddarius> mreh: Yeah, that is kind of annoying.  You can get the slides separately and view them side by side (with a little guessing about when to switch.)
15:29:51 <Trinitron> originally I had fibs = ...
15:30:00 <mreh> SPJ is pointing now :D
15:30:01 <jmcarthur> Peaker: the 1 object handles the transactions among the other objects
15:30:05 <mreh> now he's running!
15:30:09 <jmcarthur> Peaker: that's essentially how STM works anyway
15:30:13 <benmachine> Trinitron: easiest way is to define it in a let
15:30:28 <Trinitron> > sum (filter even (takeWhile (<=4000000) (0 : 1 : zipWith (+) fibs (tail fibs))))
15:30:28 <Peaker> jmcarthur, But that 1 object, in order to handle the transaction, is going to have to use locking
15:30:29 <lambdabot>   Not in scope: `fibs'Not in scope: `fibs'
15:30:33 <jmcarthur> but the external interface is only 1 object
15:30:53 <benmachine> Trinitron: but a not in scope error means it parsed correctly
15:30:53 <jmcarthur> Peaker: no. that 1 object is encapsulating the other objects
15:30:59 <jmcarthur> Peaker: nothing else should have access to them
15:31:02 <benmachine> if you are getting a parse error something different is wrong
15:31:02 <Trinitron> > sum (filter even (takeWhile (<=4000000) (let fibs = 0 : 1 : zipWith (+) fibs (tail fibs))))
15:31:03 <jmcarthur> no locks
15:31:03 <lambdabot>   <no location info>: parse error on input `)'
15:31:11 <Peaker> jmcarthur, At the implementation level, it's probably one of the sane things to do (there might be more sane options I'm unaware of) - but I really would like something to handle the transactions for me in a way that doesn't deadlock/etc
15:31:21 <jmcarthur> the object could have locks in its implementation
15:31:25 <jmcarthur> but they are not exposed
15:31:31 <Peaker> jmcarthur, well, those objects are actually serving user requests, in my case, for example
15:31:45 <benmachine> Trinitron: let name = thing in expression
15:31:47 <jmcarthur> Peaker: i bet user requests are mediated through a load balancer of some sort
15:32:02 <Peaker> jmcarthur, It's external to our machine (and doesn't actually always exist)
15:32:09 <benmachine> > let fibs@(_:t) = zipWith (+) fibs t in fibs
15:32:13 <lambdabot>   mueval-core: Time limit exceeded
15:32:31 <jmcarthur> Peaker: i'm just saying that users have a single transactional interface, and all this locking business is transparent to them, right?
15:34:05 <jmcarthur> or rather, opaque. they don't see it
15:34:12 <Peaker> jmcarthur, the users just expect it to be coherent of course. But we have to be very careful about timing in our locked section, deadlock awareness.. generally when designing component A we must be aware of component B so as to not create deadlocks/etc
15:34:29 <Trinitron> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in sum (filter even (takeWhile (<=4000000) fibs))
15:34:30 <lambdabot>   4613732
15:34:51 <benmachine> oh I forgot the 0 : 1
15:34:51 <Peaker> jmcarthur, We don't have true separation of concerns between our top-level software nodes at least -- to avoid deadlocks without STM you must break modularity this way
15:35:02 <benmachine> > let fibs@(_:t) = 0 : 1: zipWith (+) fibs t in fibs
15:35:03 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
15:35:04 <benmachine> whee
15:35:08 <Trinitron> I got parse expression
15:35:09 <Trinitron> error
15:35:15 <Trinitron> parse error in GHCi
15:35:20 <Trinitron> but works on lambda bot....
15:35:34 <Peaker> jmcarthur, (No way to preserve lock ordering without either breaking modularity or only allowing locking on very limited types of code)
15:35:45 <ski> Trinitron : maybe you inadvertently copied the leading `> ' ?
15:35:50 <Trinitron> nope
15:35:59 <c_wraith> Trinitron: hpaste your code and the error message?
15:36:13 <Trinitron> Can't, hpaste is broken.
15:36:21 <benmachine> there are always more hpastes
15:36:21 <Peaker> unqualified imports are so common in Haskell code :-(   Haskell encourages it when it should probably just disallow it
15:36:22 <c_wraith> again?  *sigh*
15:36:23 <benmachine> unsafecoerce.com
15:36:49 <ski> (<http://paste.lisp.org/new/haskell.hr>)
15:37:19 <ivanm> who runs unsafecoerce.com?
15:38:00 <Trinitron> http://unsafecoerce.com/fastcgi/hpaste.fcgi/view?id=8520#a8520
15:38:52 <Trinitron> I don't know why it says that...
15:39:31 <Peaker> Trinitron, It works for me
15:39:40 <Trinitron> hmmm
15:39:43 <ivanm> is that in ghci?
15:39:44 <Peaker> Trinitron, what else do you have in that file?
15:39:48 <Trinitron> nothing
15:39:54 <ivanm> or in an actual file?
15:39:55 <Peaker> Trinitron, paste it into ghci
15:40:21 <Trinitron> works when I paste it in
15:40:35 <ivanm> Trinitron: try removing the space from your file name ;-)
15:40:39 <ivanm> I think that's it
15:40:53 <Trinitron> Nope
15:40:54 <jmcarthur> Peaker: component A and component B needn't be aware of each other if component C is their only client
15:40:59 <Trinitron> Space or no space same error
15:41:07 <Peaker> jmcarthur, Well, component A might have a callback
15:41:15 <Peaker> jmcarthur, that component C installs on A
15:41:21 <Peaker> jmcarthur, and C also calls D
15:41:23 <ivanm> Trinitron: http://unsafecoerce.com/fastcgi/hpaste.fcgi/view?id=8520#a8521
15:41:28 <Peaker> jmcarthur, this causes arbitrary lock ordering
15:41:36 <ivanm> if you want to have it in a file, do it that way
15:41:38 <Peaker> jmcarthur, (between D and A)
15:41:47 <Trinitron> i think I found a bug
15:41:52 <Trinitron> maybe
15:41:55 <jmcarthur> Peaker: if component C did it then component C should make sure the callback satisfies the preconditions of the objects it communicates with
15:42:09 <ivanm> or slightly nicer: main = print . sum . filter even . takeWhile (<= 4000000) $ fibs
15:42:30 <Peaker> jmcarthur, So component A has to document exactly what kind of locking it does around each callback - which may be quite complicated - and exposes a lot of the guts, rather than exposing a simple interface
15:42:40 <jmcarthur> Peaker: the *callback* could do the locking. component A shouldn't care
15:42:41 <ivanm> Trinitron: that let ... in ... syntax is used either _within_ another function or in ghci; not as a top-level definition in a file
15:42:51 <Peaker> jmcarthur, no, I mean when A calls a callback while something is locked
15:43:05 <Trinitron> oh
15:43:06 <Peaker> jmcarthur, Actually, for C there might be no way to know if the callback from A will be called or not
15:43:13 <Trinitron> how do I do it as a top level?
15:43:14 <Trinitron> one
15:43:19 <Peaker> jmcarthur, So it doesn't know if it's safe to call D which locks another lock
15:43:35 <jmcarthur> Peaker: if there is no way to know then either A is ill specified or C should know to be careful
15:43:40 <ivanm> Trinitron: you want a single line definition?
15:43:45 <Trinitron> Yes
15:43:47 <Peaker> jmcarthur, If C asks A "are you going to lock if I do this?" and only if the answer is "no", it calls it -- it is actually beginning to look like an impl. of STM
15:43:50 <jmcarthur> Peaker: and you argument seems to be assuming the existence of locks int he first place
15:44:04 <Trinitron> I just added answer = to the beginning
15:44:08 <Trinitron> but that's cheating
15:44:08 <Peaker> jmcarthur, I thought we already established the requirement for locks
15:44:08 <jmcarthur> Peaker: exactly. C does the transactional logic
15:44:11 <Trinitron> I don't want LHS
15:44:12 <ivanm> Trinitron: http://unsafecoerce.com/fastcgi/hpaste.fcgi/view?id=8520#a8522
15:44:15 <Trinitron> I just want an expression
15:44:21 <ivanm> Trinitron: why is that cheating?
15:44:31 <Trinitron> I dunno.
15:44:31 <ivanm> (you could use a where instead of a let...)
15:44:37 <jmcarthur> Peaker: because it's actually in scope for C. A and B shouldn't care
15:44:47 <ivanm> Trinitron: you could have fibs seperate from the sum, and define the sum in a different expression
15:45:03 <jmcarthur> Peaker: that is, A and B are the transactional variables, not their members
15:45:15 <Peaker> jmcarthur, But then the interface between A and C is not a simple API, complicated only by allocation lifetimes. It's now complicated (potentially a LOT) by lock specifications
15:45:40 <Peaker> A needs to tell&guarantee to C about what kind of locks are held at exactly what situations
15:45:45 <benmachine> Trinitron: a haskell file contains a program or a library, both of which amount to basically defining things
15:45:46 <jmcarthur> Peaker: no, A doesn't care. if C is its only client then only C cares
15:45:49 <Peaker> the API widens and widens - at some point, A and C are tightly coupled
15:45:55 <benmachine> just free expressions aren't really useful
15:46:02 <jmcarthur> i'm assuming a clean design slate here. A doesn't need locks
15:46:12 <Peaker> jmcarthur, If C cares too much about A's implementation details - modularity is broken
15:46:20 <jmcarthur> this is not about implementation at all
15:46:32 <jmcarthur> well, it's C's implementation and A's interface
15:46:46 <Peaker> jmcarthur, A needs locks because it handles external communication and communication from C
15:47:04 <jmcarthur> Peaker: where is this external communication?
15:47:13 <Peaker> jmcarthur, From clients of the whole machine
15:47:18 <copumpkin> is llvm merged with HEAD now?
15:47:23 <copumpkin> or is it still waiting
15:47:24 <jmcarthur> Peaker: C is the only client
15:47:56 <Peaker> jmcarthur, The whole point is to distribute the work of handling external clients across multiple entities
15:48:04 <jmcarthur> Peaker: yes. C handles that
15:48:10 <Trinitron> > sum (filter even (takeWhile (<=4000000) fibs)) where fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
15:48:11 <lambdabot>   <no location info>: parse error on input `where'
15:48:43 <pastorn> i'm looking for an old blog post on how to do object oriented style game objects in haskell
15:48:53 <ivanm> Trinitron: it still needs a value to assign to it...
15:48:54 <pastorn> i remember the page being yellow-ih
15:48:54 <jmcarthur> C communicates with external clients atomically and handles the transactional stuff in its implementation so that A and B don't have to care
15:49:00 <ivanm> sumFibs = ...
15:49:00 <pastorn> *ish*
15:49:12 <jmcarthur> and A and B also handle their own messages atomically
15:49:16 <Trinitron> so a haskell file cannot just have an expression
15:49:17 <ivanm> Trinitron: haskell files aren't scripts; top level definitions need definition names
15:49:23 <ivanm> Trinitron: nope, they can't
15:49:26 <Trinitron> .hs needs definitions
15:49:31 <Trinitron> not just one expression
15:49:36 <Trinitron> I'm used to python
15:49:46 <Trinitron> where, you know what I mean.
15:50:05 <Peaker> jmcarthur, to do it atomically - they need locks
15:50:17 <Peaker> jmcarthur, I think we might be talking past each other.. maybe continue another day :)
15:50:31 <jmcarthur> Peaker: no. i'm talking about their own internal states. not global state
15:50:44 <jmcarthur> Peaker: their internal states are manipulated atomically
15:50:49 <benmachine> Trinitron: haskell isn't much harder, really
15:50:57 <jmcarthur> Peaker: and A and B themselves form the internal state of C
15:51:06 <benmachine> in python you have 'print 3' in haskell this is 'main = print 3'
15:51:10 <benmachine> big deal :P
15:52:08 <ivanm> chuck it all in a main = do ... ;-)
15:52:56 <Trinitron> I made is answer =
15:53:07 <Trinitron> Is the convention "main ="?
15:53:27 <Trinitron> it(
15:53:28 <Trinitron> it*
15:53:46 <aavogt> you can write your file like:    main = do {\n..... \n}
15:54:39 <jmcarthur> Peaker: and if A and B suddenly want to communicate with D then it's only because C *gave* them a reference to D, so C better have made sure that it's okay that D can receive interleaved messages from A and B *or* A and B are specified to obey some protocol with the object D that was given them
15:54:46 <ivanm> Trinitron: use main to make it a program
15:54:52 <ivanm> but then it needs to be in IO
15:55:06 <Peaker> jmcarthur, Let's continue discussing it, but it's gotten quite late here in Israel :)
15:55:15 <jmcarthur> heh, alright
15:55:57 <jmcarthur> honestly, i don't even think OO is that great
15:55:58 <aavogt> though you need semicolons then
15:56:13 <jmcarthur> but this is one area where i think it shines, when used appropriately
15:56:37 <Zao> Stalafin: Are you sure it's an error? Is it at compile-time or runtime?
15:59:16 * hackagebot glpk-hs 0.2.4 - Comprehensive GLPK linear programming bindings  http://hackage.haskell.org/package/glpk-hs-0.2.4 (LouisWasserman)
16:01:05 <Trinitron> I <3 Haskell.
16:01:56 <gio123> is here anybody who uses cduce?
16:02:12 <mmmulani> can you match data constructors in smart constructors?
16:02:53 <gio123> is here anybody who uses cduce?
16:04:28 <jmcarthur> mmmulani: maybe you are looking for something like ViewPatterns
16:04:34 <jmcarthur> (which i think could be better)
16:07:12 <Entroacceptor> is it okay that cabal install happstack fails with an error that happy can't be found?
16:07:42 <jmcarthur> Entroacceptor: install happy. cabal unfortunately doesn't track build program dependencies like that
16:07:52 <jmcarthur> Entroacceptor: also make sure that happy is in your PATH
16:08:00 <Trinitron> Are there any Haskell jobs in Sydney, Australia?
16:08:05 <Trinitron> Or a Haskell meetup?
16:08:10 <jmcarthur> Entroacceptor: i'm a little surprised that happstack requires happy
16:08:12 <Trinitron> For Sydney?
16:08:33 <Entroacceptor> jmcarthur: the failing is in haskell-src-exts
16:08:35 <dobblego> Trinitron, there is fp-syd group
16:08:42 <jmcarthur> ah
16:08:59 <gio123> is here anybody who uses cduce?
16:09:31 <Trinitron> I've been to a Python meetup, but I'm interesting in functional programming now.
16:09:43 <Entroacceptor> jmcarthur: ok, manually installing happs and now it works
16:09:53 <Trinitron> Thanks dobblego
16:09:54 <Entroacceptor> thanks
16:11:40 <psykotic> is there a darcs repo for the latest quickcheck source code?
16:13:14 <copumpkin> psykotic: http://code.haskell.org/QuickCheck/ I think
16:13:27 <psykotic> thanks. for some weird reason google wasn't much help.
16:13:45 <copumpkin> a lot of things moved quite recently, so google might be confused
16:15:53 <mreh> how do you do thinks like dijkstra's algorithm in haskell? mutating a matrix of values over time
16:16:04 <mreh> over recursive calls that is
16:16:07 <Trinitron> So there isn't really a Haskell meetup in Sydney, just a general FP group?
16:16:24 <Trinitron> That's good as well.
16:16:30 <Trinitron> If it's true.
16:16:57 <psykotic> mreh: you just fold your update function over a Map from vertices to distances
16:17:04 <psykotic> that's the most idiomatic way, anyway
16:17:58 <benmachine> it's not like there aren't mutable arrays if you need them
16:18:04 <ski> mreh : .. maybe one can express it as a recursively defined array ?
16:18:25 <psykotic> benmachine: and you can use STArray to contain the mutability
16:18:28 <copumpkin> it seems like that might be possible
16:19:02 <psykotic> before you code dijkstra, try a simpler algorithm, since it will need to address the same concerns over state update
16:19:46 <benmachine> is there actually any reason why IOArray exists given STArray?
16:19:57 <copumpkin> if you're already in IO, why not use it?
16:20:07 <benmachine> you can if you like
16:20:24 <benmachine> but is it actually just convenience
16:20:38 <benmachine> I guess convenience is a valuable thing
16:21:52 <psykotic> mreh: here's the 'duh' algorithm. you start with an initial map containing 0 for the source vertex and infinity for all others. then you iterate the function that folds over the vertex list, for each vertex updating the map by propagating its distance using its adjacency relation and 'min'
16:22:10 * copumpkin looks it up in CLRS
16:22:25 <psykotic> when you see two identical maps in the list generated by 'iterate', things have stabilized, and you have the final values
16:22:42 <psykotic> that's probably the slowest but also simplest algorithm for single-resource min paths
16:22:45 <psykotic> err, single-source
16:23:23 <copumpkin> :t \f -> takeWhile (null . drop 1) . group . iterate f
16:23:24 <lambdabot> forall a. (Eq a) => (a -> a) -> a -> [[a]]
16:23:33 <copumpkin> :t \f -> last . takeWhile (null . drop 1) . group . iterate f
16:23:34 <lambdabot> forall a. (Eq a) => (a -> a) -> a -> [a]
16:23:49 <copumpkin> meh, not that
16:23:59 <copumpkin> :t \f -> head . last . takeWhile (null . drop 1) . group . iterate f
16:24:00 <lambdabot> forall a. (Eq a) => (a -> a) -> a -> a
16:24:06 <mreh> slow down D:
16:24:45 * copumpkin woke up at 8am, yesterday
16:24:54 <copumpkin> :(
16:25:06 <mreh> insomnia?
16:25:19 <copumpkin> lots of work, and now I'm waiting for someone to do something before I can go to sleep
16:25:28 <Cale> You might also want to manipulate a Map Vertex Vertex tree as you go to keep track of what all the best paths are.
16:25:30 <mreh> usually exacerbated by tiredness
16:26:04 <mreh> here's the deal, I have to ant colony optimisation, each iteration keeps track of the pheromone levels on each edge
16:26:22 <mreh> so I need an nxn symmetrical matrix
16:26:44 <Cale> How large is n?
16:26:45 <gio123> Cale: hi
16:26:49 <Cale> hi
16:27:00 <mreh> how long is a piece of string?
16:27:03 <mreh> :D
16:27:09 <copumpkin> mreh: is it sparse?
16:27:23 <mreh> copumpkin: no
16:27:27 <copumpkin> boo
16:27:30 <Cale> mreh: Well, just ballpark, I'm interested in what size of a simulation you're talking about
16:27:31 <mreh> some problems are fully reticulated
16:27:34 <copumpkin> what's its kolmogorov complexity?
16:27:43 * copumpkin whistles
16:27:48 <mreh> Cale: well, I may use it for a 50x50 grid, it's part of the homework
16:27:59 <Cale> Okay, that's sensible to use a Data.Map on then.
16:28:12 <mreh> from edges to values?
16:29:10 <Cale> Yeah
16:29:22 <mreh> too many weeks of enforced MATLAB and you see Matrices everywhere
16:29:43 <Cale> Well, it is a matrix too ;)
16:29:56 <mreh> in the abstract
16:29:56 <Cale> You don't have to store every matrix as an array :)
16:30:55 <Cale> In fact, this might actually be closer to the formal definition of a matrix in mathematics -- as a function from {1..n} x {1..m} to coefficients. :)
16:31:44 <mreh> in practice it's not slower to do matrix multiplication with Map's really... is it?
16:31:53 <copumpkin> what's the minimum you need to do interesting things with the matrix? a semiring on the coefficients?
16:32:10 <mreh> I don't know what that is
16:33:28 <pantsman> I go all the way when it comes to rings
16:34:05 <copumpkin> a semiring could give you matrix addition and multiplication, but no inversion of matrices
16:34:25 <Cale> mreh: Yeah, there's a log factor asymptotically, but you only have so much memory anyway
16:36:07 <prometheus`> hey, has anyone here compiled the haskell-platform with ghc 6.12 ?
16:36:49 <copumpkin> several people will have in a week or two
16:37:08 <ivanm> seeing as how there is no 6.12 version of the platform, no-one has!
16:37:16 <mreh> hmmm, now I need to nest the Maps for each index element
16:37:27 <Cale> mreh: You could use a map from pairs
16:37:29 <prometheus`> so, you suggest just waiting till there's a 6.12 version?
16:37:42 <mreh> Cale: well I was thinking "what if I want to get a whole row/column"
16:37:48 <ivanm> or get 6.12, get cabal-install-0.8.* and get what libraries you want yourself
16:37:50 <Cale> mreh: That's true
16:37:52 <copumpkin> psykotic: you mentioned finding an unexpected use for your matrix zippers the other day by the way. Do you have time to explain what that was?
16:38:05 <psykotic> oh
16:38:10 <psykotic> a version of knuth's dancing links algorithm
16:38:25 <psykotic> it's not quite the matrix zipper but it's quite close
16:38:32 <ivanm> psykotic: do you have a link?
16:38:34 <psykotic> the main thing is that the matrix used for dancing links is sparse
16:38:52 <psykotic> other than that, it's very close
16:38:59 <prometheus`> ivanm: ok, I might try that out too.
16:39:00 <mreh> Cale: memo-tries I'm thinking?
16:39:08 <prometheus`> but if there's a new release of HP around the corner, I can wait
16:39:44 <psykotic> ivanm: still too messy to share
16:39:53 <copumpkin> :)
16:39:57 <ivanm> fair enough
16:40:04 <copumpkin> ivanm: if you dig around on reddit you'll find his first iteration of the idea though!
16:40:06 <psykotic> i had it working but then i mangle it a bit
16:40:12 <psykotic> so now i have to unmangle it
16:40:13 <Cale> mreh: I've never used memo-tries
16:40:31 <ivanm> copumpkin: which reddit and how far back?
16:40:37 <mreh> if you're doing it twice or more, use a memo-trie
16:40:41 <copumpkin> ivanm: haskell subreddit I believe, several months ago
16:40:50 <psykotic> the stuff on reddit isn't for dancing links, it's just a matrix zipper designed for efficient gaussian elimination, etc, for list-based matrices
16:40:50 <ivanm> hmmm
16:41:01 <copumpkin> yeah
16:41:24 <copumpkin> still interesting, though: http://haskell.pastebin.com/f55d96074
16:41:52 <psykotic> damn, 500 lines
16:42:01 <copumpkin> most of it is english :P
16:42:10 <psykotic> yeah
16:53:43 <pokoko222> euler problems seem easy now, am i becoming a ninja?
16:54:03 * shapr gives pokoko222 the gold ninja star
16:54:38 <copumpkin> pokoko222: they get harder as you get to the higher numbers
16:54:53 <copumpkin> (although there are some fairly easy ones in the higher numbers too)
16:54:54 <pokoko222> well i am on 59 i guess hard is later?
16:59:43 <psykotic> they are up and down, i wouldn't say they ramp up too much (except for the very beginning)
17:00:15 <pflanze> Is there a way to have several cases map to the same expression in a pattern?
17:00:27 <psykotic> use |
17:00:33 <pflanze> for example:   case sexp of   VLInteger _ | VLTrue | VLFalse | VLChar _  ->  _val sexp
17:00:43 <psykotic> oh like that
17:00:49 <copumpkin> unfortunately not
17:00:51 <pflanze> This gives parse error on input `|'
17:00:54 <copumpkin> however
17:00:54 <psykotic> yeah, you can't do that
17:01:03 <psykotic> i thought you meant when you want to have guard conditions
17:01:15 <copumpkin> pflanze: you can have the same record accessor name across multiple data constructors, but that might not help you here
17:01:41 <pflanze> Seems the only way to do it is by repeating -> _val sexp then?
17:02:00 <pokoko222> anyways this problem http://projecteuler.net/index.php?section=problems&id=59 i have read on encryption and stuff, but, it says here the key is 3 lower case letters. that is 24 bytes. so lets say i need do decrypt one byte, lets say 79 representing some letter, i would need to do xor with 3 letters on 7 and 3 letters on 9? so letter1 xor letter 2 xor letter3 xor 7 ?
17:02:34 <copumpkin> 24 bits, you mean?
17:03:19 <pokoko222> yes sorry
17:03:56 <psykotic> zipWith xor (cycle key)
17:04:06 <psykotic> with some ord and chr thrown in there
17:04:14 <pokoko222> no i dont need solution in code, i dont understand it on higher level
17:04:26 <pokoko222> code will be easy
17:04:36 <psykotic> in this case there isn't really a difference :)
17:05:13 <psykotic> the idea is that you repeat the password as many times as needed to get a key the same length as the text
17:05:17 <psykotic> you then xor letterwise
17:06:18 <pokoko222> psykotic ok lets go slow
17:06:25 <psykotic> i'm not sure i can go slower than that
17:06:33 <pokoko222> lets say first value u need do decrypt is 79
17:06:46 <copumpkin> pokoko222: psykotic is the ninja emperor
17:07:00 <pokoko222> and u r told the key is three lower case letters
17:07:03 <DBAlex> Hi
17:07:08 <pokoko222> follow me?
17:07:10 <copumpkin> DBAlex: OHAI
17:07:11 <DBAlex> how do I get raw HTML from a URL in Haskell?
17:07:14 <psykotic> pokoko222: here's an example. let's say the password is 'xyz' and the text is 'abcdef' then the key is 'xyzxyz'
17:07:19 <DBAlex> in python i'd use urllib :-)
17:07:49 <copumpkin> http://hackage.haskell.org/package/HTTP maybe?
17:07:50 <lament> xorority
17:07:51 <ivanm> DBAlex: there's curl bindings
17:07:55 <ivanm> or HTTP as copumpkin suggested
17:07:59 <ivanm> have a look on hackage
17:08:06 <DBAlex> ivanm: ok
17:08:15 <DBAlex> theres nothing standard, or with GHC?
17:08:49 <ivanm> HTTP comes with the platform IIRC
17:08:55 <ivanm> or is that network?
17:08:56 <ivanm> *shrug*
17:09:00 <pokoko222> psykotic slow down, password and key? not same?
17:09:04 <copumpkin> o.O
17:09:04 <pokoko222> i mean in this case
17:09:04 <copumpkin> fac n = let {  f = foldr (*) 1 [1..n] } in f
17:09:13 <copumpkin> O.o
17:09:15 <psykotic> pokoko222: have you even read the problem?
17:09:21 <pokoko222> daah
17:09:22 <psykotic> i'm using their terminology.
17:09:28 <ivanm> copumpkin: why bother defining f ?
17:09:34 <psykotic> "If the password is shorter than the message, which is likely, the key is repeated cyclically throughout the message."
17:09:38 <copumpkin> ivanm: that's why I'm o.Oing
17:09:44 <ivanm> ahhh
17:09:46 <copumpkin> ivanm: it's in someone's signature on haskell-cafe
17:09:47 <ivanm> and O.oing?
17:09:54 <ivanm> oh, yeah, that's right
17:09:55 <copumpkin> nah, that's just my regular face
17:09:59 <ivanm> heh
17:10:01 <copumpkin> one of my eyes is twice the size of the other
17:10:38 <pokoko222> psykotic ok got it now
17:10:39 <ivanm> copumpkin: so then for you to do o.O  your small eye has to grow to four times its normal size?
17:10:50 <psykotic> pokoko222: cool
17:10:58 <DBAlex> also is there a way to list modules?
17:11:00 <DBAlex> *all available
17:11:03 <DBAlex> (In GHCI)
17:11:04 <copumpkin> ivanm: yep
17:11:06 <DBAlex> or GHC w/e
17:11:22 <ivanm> DBAlex: ghc-pkg list
17:11:27 <DBAlex> ahh
17:11:29 <ivanm> that lists all installed libraries
17:11:30 <DBAlex> thanks :-)
17:11:42 <ivanm> you can do ghc-pkg dump to get all modules thataway...\
17:13:30 <pokoko222> psykotic so basically here is what u do: 1. u have 3 lower case letters "abc"  2. you have text to encrypt "Hello" 3. you do this: 'a' xor 'H'        'b' xor 'e'       'c' xor'l'         'a' xor 'l'         'b' xor 'o'
17:13:33 <pokoko222> correct?
17:13:58 <DBAlex> also, how do I install a package from a .tar.gz ?
17:13:59 <psykotic> bingo
17:14:27 <ivanm> DBAlex: get the cabal-install tool
17:14:27 <ivanm> @where cabal-install
17:14:27 <lambdabot> http://hackage.haskell.org/trac/hackage/wiki/CabalInstall
17:14:27 <copumpkin> tar xf
17:14:28 <DBAlex> (I don't have a cabal command available... even though it lists cabal in ghc-pkg list)
17:14:37 <ivanm> then it will download the package and install it for you
17:14:43 <ivanm> DBAlex: Cabal /= cabal-install
17:14:50 <DBAlex> ok
17:15:37 <DBAlex> do I just need cabal.exe?
17:16:10 <ivanm> yes
17:16:22 <ivanm> but if you're using ghc 6.12, the version of cabal.exe on the website is wrong
17:16:31 * ivanm goes off to find ndm's 6.12 compatible one
17:17:31 <DBAlex> i'm using 6.10.1
17:17:51 <ivanm> oh, then you have no problems
17:18:00 <ivanm> DBAlex: I'd suggest upgrading to the latest release of the haskell platform though
17:18:06 <ivanm> which would give you cabal-install
17:18:15 <DBAlex> hmm
17:18:25 <DBAlex> I need to set the proxy settings too
17:18:26 <DBAlex> :s
17:20:13 <DBAlex> is there a way to set my proxy?
17:20:13 <DBAlex> :S
17:20:26 <ivanm> *shrug* probably
17:20:35 <ivanm> /ipconfig IIRC
17:20:42 <ivanm> (in cmd.exe)
17:20:53 <chipmonkpyro> Im trying to reference a second haskell file in my first haskell file. The first is hw6.hs and the second is cards.hs . I have cards.hs in the active directory of emacs (the one with my .emacs file) but when I try and add the line "import Cards" in hw6.hs all i get is the error "File name does not match module name:" Saw: `main' Expected: `cards'; the error message references the first line...
17:20:54 <chipmonkpyro> ...of cards.hs
17:20:57 <chipmonkpyro> any takers?
17:21:32 <ivanm> chipmonkpyro: up the top of your code, you want: module Cards where
17:21:40 <ivanm> and change the filename to Cards.hs
17:22:00 <psykotic> @type
17:22:02 <lambdabot> <no location info>: not an expression: `'
17:22:02 <ivanm> (module names need to be capitalised, and the convention is to have the module name be the same as the file name sans extension)
17:22:04 <psykotic> @type ord
17:22:05 <lambdabot> Char -> Int
17:22:32 <aavogt> @check \x -> ord x == fromEnum x
17:22:33 <lambdabot>   "OK, passed 500 tests."
17:22:46 <aavogt> @scheck \x -> ord x == fromEnum x
17:22:47 <lambdabot>   "OK, passed 500 tests."
17:22:58 <ivanm> @src ord
17:22:58 <lambdabot> Source not found. That's something I cannot allow to happen.
17:23:06 <ivanm> @src Char fromEnum
17:23:07 <lambdabot> Source not found. :(
17:23:11 <copumpkin> @check  liftM2 (==) fromEnum ord
17:23:12 <lambdabot>   "OK, passed 500 tests."
17:23:15 <DBAlex> ahh, it works now :)
17:23:16 <aavogt> the convenience is that you don't have to import fromEnum
17:23:20 <psykotic> > let crypt pass text = map chr . zipWith xor (cycle (map ord pass)) . map ord in crypt "xyz" "hello world"
17:23:22 <lambdabot>   ""->
17:23:22 <lambdabot>    ""
17:23:22 <lambdabot>  "a"->
17:23:22 <lambdabot>    "\EM"
17:23:22 <lambdabot>  "aa"->
17:23:24 <lambdabot> [4 @more lines]
17:23:35 <DBAlex> SET HTTP_PROXY=<proxy_address>
17:23:38 <DBAlex> then cabal update
17:24:42 <ivanm> aavogt: you mean import ord?
17:25:59 <aavogt> well however you want to interpret my statement, the fact is that Enum is in the Prelude while ord is not
17:26:25 <DBAlex> Yay! I have Network.HTTP! thanks ivanm, copumpkin
17:26:31 <chipmonkpyro> @ivanm thanks that worked
17:26:32 <lambdabot> Unknown command, try @list
17:26:32 <ivanm> no worries DBAlex
17:26:32 <copumpkin> yay
17:26:46 <roboshibby> http://www.youtube.com/watch?v=IBIa6sKSFQk <- how haskell makes me feel
17:26:51 <ivanm> chipmonkpyro: the @ isn't needed ;-)
17:27:10 <chipmonkpyro> ivanm: gotcha
17:32:56 <metaperl> Re: http://www.haskell.org/tutorial/pitfalls.html  .. I dont think the type signature is precise --- average                 :: (Fractional a) => [a] -> a   ... I dont think the list needs to derive from Fractional, only the result of the division
17:33:10 <copumpkin> roboshibby: keep posting links like that and you'll get banned, you know
17:33:23 <roboshibby> it's not allowed to share in here?
17:33:38 <copumpkin> roboshibby: it wouldn't be terrible if you'd made any indication of ever being _on_ topic in here
17:33:41 <copumpkin> but you haven't
17:33:49 <ivanm> metaperl: the problem is, there's no real easy way to automatically convert any number into a Fractional type
17:33:51 <roboshibby> i asked about monads once
17:33:57 <copumpkin> roboshibby: it was as a joke
17:34:02 <Zao> copumpkin: Or was it?
17:34:16 <roboshibby> hm, don't recall that part
17:34:16 <ivanm> Zao: that's what he _wants_ us to think!
17:34:32 <metaperl> oh
17:34:35 <ivanm> metaperl: so you pretty much need to have an integral-specific one, a fractional-specific one, etc.
17:34:50 <ivanm> (someone was asking about that here the other day IIRC...)
17:34:51 <copumpkin> anyway, I'm just saying
17:34:51 <metaperl> oh
17:34:55 <copumpkin> I don't have any power to do it myself :)
17:35:08 <aavogt> you probably don't want an integral average though
17:35:09 <ivanm> copumpkin: because we couldn't trust you with it? :p
17:35:18 <copumpkin> ivanm: probably :)
17:35:22 <ivanm> aavogt: he means (Integral a) => [a] -> Double or something methinks
17:35:29 <ivanm> aavogt: and I've used integral averages before ;-)
17:35:35 <aavogt> @type \xs -> sum xs `div` fromIntegral (length xs)
17:35:36 <lambdabot> forall a. (Integral a) => [a] -> a
17:35:37 <roboshibby> oh no i just didn't realize that would be against the rules or something. but if you're going to lose your temper, i can stop sharing
17:35:53 <ivanm> roboshibby: #haskell-blah is that way ===>
17:35:54 <ivanm> ;-)
17:36:03 <roboshibby> hehe
17:36:21 <roboshibby> you're way nicer ivanm than copumpkin
17:36:30 <copumpkin> roboshibby: yeah, I'm an asshole
17:36:30 <shapr> He's right though...
17:36:44 <shapr> #haskell-blah is that-a-way...
17:36:51 <ivanm> copumpkin: so you're an asshole that accused me of being violent?
17:37:26 <shapr> In any case, youtube links that are not about Haskell are really off-topic.
17:38:04 <ivanm> oh great shapr, wise keeper of the on-topic, is discussing what is on-topic on-topic? :p
17:38:14 <djahandarie> It was about /funky town/ though. o-\-< o-/-<
17:38:18 <mornfall> copumpkin is the evil dual of pumpkin...
17:38:23 <shapr> ivanm: :-P
17:38:35 <Pseudonym> ivanm: You can reify meta-discussions in the #haskell discussion system.
17:38:41 <ivanm> heh
17:38:47 <shapr> So, um... I think it's easier to write tcp servers in Haskell than in C++
17:38:57 <Pseudonym> shapr: THere are some good C++ libraries.
17:39:12 <copumpkin> none that abstract you as nicely as the green thread model, I think
17:39:15 <Pseudonym> Or you could always use inetd.
17:39:16 <copumpkin> at least that I've come across
17:39:31 <shapr> I made a sort-of bet with a guy on another irc channel, we'll each try to write a simple TCP/IP server that can serve up a hello world webpage.
17:39:44 <copumpkin> :o
17:39:46 <roboshibby> djahandarie knows what it's good for him :D
17:39:53 <aavogt> do threads come in other colours too?
17:39:58 <Pseudonym> The problem with plain C++ is that you're using the raw Berkeley socket library.
17:40:15 <copumpkin> @hackage c10k over 9000!!!!111!!11!11!!!one!1!!!
17:40:15 <lambdabot> http://hackage.haskell.org/package/c10k over 9000!!!!111!!11!11!!!one!1!!!
17:40:19 <Draconx|Laptop> shapr, make it more challenging: make a web server that can serve a hello world webpage to more than 10,000 clients simultaneously.
17:40:25 <shapr> Pseudonym: I got some advice from some other folk, and ended up trying the Pion library, but I still can't figure out how to compile anything.
17:40:33 <Pseudonym> And to make it even more challenging: test it!
17:40:37 <ivanm> OK, does anyone have any suggestions of how I can sensibly parse something like "a b -> c [color="red"] d -> e" as (DotNode "a" []), (DotEdge "b" "c" [Color "red"]),  and (DotEdge "d" "e" []) ?
17:40:51 <ivanm> (in the sense that how can I tell when something stops being a node and starts being an edge)
17:41:00 <shapr> copumpkin: wow, nifty!
17:41:21 <Pseudonym> shapr: http://pocoproject.org/docs/00100-GuidedTour.html#4 <- I use POCO
17:41:56 <mornfall> ivanm: Needs lookahead, for all I can tell.
17:42:02 <ivanm> mornfall: yeah :(
17:42:04 <Pseudonym> And I cut and paste that boilerplate.
17:42:20 <ivanm> @slap overly liberal language specs
17:42:21 * lambdabot pokes overly liberal language specs in the eye
17:42:33 <mornfall> ivanm: Wasn't there a lookahead operator in parsec?
17:42:44 <ivanm> mornfall: problem is, I'm not using parsec ;-)
17:42:53 <shapr> Pseudonym: I ended up trying to build http://www.pion.org/files/pion-net/net/doc/html/_hello_service_8cpp-source.html
17:42:59 <mornfall> ivanm: But?
17:43:18 <Pseudonym> Eek, extern "C".
17:43:23 <ivanm> mornfall: yeah, I'll have to have a look; pretty sure polyparse has something like that though as well
17:43:26 <Pseudonym> So what's the problem?
17:43:27 <ivanm> but I was hoping to avoid it :s
17:43:57 <ivanm> (if nothing else because the lookahead might not result in the exact same String being returned)
17:43:59 <mornfall> ivanm: I don't think this level of ambiguity can be done without lookahead...
17:44:01 <shapr> Pseudonym: I can't build it.
17:44:04 <shapr> :-)
17:44:04 <ivanm> mornfall: yeah
17:44:17 * Pseudonym tries to find an Ubuntu package for pion
17:44:30 <shapr> I installed the pion lib just fine, I think.
17:45:16 <Pseudonym> Oh, pion uses Boost.
17:45:30 <Pseudonym> You have that?
17:45:40 <shapr> I do now.
17:56:40 <psykotic> what do people think of coarbitrary's approach to generating functions?
17:57:26 <psykotic> neat and simple but by construction it tends to sample the most random cases
17:58:29 <psykotic> i mean, it's more or less just hashing the function input and feeding it as the seed to the output's generator
18:00:20 <Cale> psykotic: It makes sense for generating random functions
18:00:51 <psykotic> well, it tends to generate 'discontinuous' functions that have no correlation between input and output
18:01:01 <Cale> That's true
18:01:04 <psykotic> one of the nice things about quickcheck is its ramp up
18:01:38 <psykotic> where you get some coherence in the beginning
18:02:03 <psykotic> you don't seem to have that with functions. though i'm not sure what a reasonable alternative is. actually, i have ideas, but none are that great.
18:02:37 <Cale> Maybe newtyped generators for special classes of functions?
18:02:47 <Cale> (linear functions, low-degree polynomials, etc.)
18:03:08 <psykotic> well, an obvious way is to use arbitrary for a data type of typed syntax trees that can be evaluated into actual functions
18:03:30 <psykotic> right
18:03:38 <psykotic> so you could have functions like (+) and (*) as building blocks
18:03:49 <psykotic> and arbitrary would build random compositions of them meeting the input-output type constraints
18:04:22 <ivanm> hmmmm.... should I bother witht he platform or just go straight to 6.12 on my uni machine?
18:04:35 * ivanm has already built 6.10.4 ...
18:06:05 <psykotic> if all the building blocks have same domain and range type, this would be simple and could use aritrary's existing infrastructure for building the 'syntax tree'
18:06:18 <psykotic> if they can detour via other types, it gets trickier and you would need something more like prolog-style search
18:07:10 <psykotic> (or GADTs i guess?)
18:08:36 <psykotic> so, the syntax tree would be something like... data Tree a = Const | Unary (a -> a) (Tree a) | Binary (a -> a -> a) (Tree a)
18:09:03 <psykotic> you generate random instances using the normal arbitrary and populate the a -> a and a -> a -> a from predefined lists, e.g. negation for a -> a, (+) and (*) for a -> a -> a
18:09:51 <psykotic> and then you 'evaluate' it in quickcheck by replacing Consts with 'arbitrary' calls, and feeding function inputs as appropriate
18:17:15 <ivanm> @. elite protontorpedo
18:17:16 <lambdabot> h0w wOUlD h4skEL| S0L\/e THe ph0L10WinG 9nARL3y PR0BlE/\/\: m4NY C1IENT diStRi8u73d a(CroSz0rz 7|-|e U5A, 7R4n5phER5 MU$T +Ak3 p4l(E IN +|-|e phORM 0ph phI|e 7R4nsf3R, aNd data muz+ B3 RE4d phROM
18:17:16 <lambdabot> phil3S, 4nd reCoRD3D, +|-|En O+h3R PARTNER5 \/\/H0 4pPlY TAx35 to THiz dAt4 aND 7|-|en 9IV3 4bxx nEW fil3z0rz \/\/IT|-| tAxez aDed, +|-|eN 1A57 trAN$3rz0rz 70 4t|-| p4RTIez0rz WHo 93T Uz p4Id 4 +hE
18:17:16 <lambdabot> p|-|On3 cA1lz0rz +HA+ Ar3 ThE PR0Duct
18:17:38 <ivanm> oh, didn't realise that @protontorpedo quotes were that big...
18:37:06 <dmead> hello channel
18:37:10 <dmead> i have a question
18:37:19 <dmead> if i'm trying to parse SQL statements
18:37:34 <dmead> should i use parsec and define a grammar?
18:37:40 <dmead> or, just rig up a parser
18:37:45 <copumpkin> yep, or some other combinator library
18:37:49 <dmead> k
18:37:54 <copumpkin> don't roll your own unless you have some novel ideas in the area
18:38:00 <ivanm> ummm... don't you use alex + happy when defining a grammar?
18:38:02 <copumpkin> it'll just be buggier and slower :)
18:38:08 <dmead> sure sure
18:38:18 <copumpkin> combinators make a grammar too
18:38:20 <dmead> i just want to translate sql into an ADT i've defined
18:38:32 <dmead> and i'll be writing an eval function for sql types
18:38:32 <copumpkin> alex and happy are faster but uglier
18:38:36 <ivanm> agreed
18:38:52 <dmead> sound correct?
18:38:54 <dons> attoparsec seems ... close to alex for simple things
18:39:01 <dmead> yea i've seen attoparsec
18:39:03 <dmead> but i can't find docs
18:39:11 <ivanm> yeah, hackage can't build them
18:39:19 <ivanm> because the version of alex on hackage is too old IIRC
18:39:20 <dmead> do they live somewhere else?
18:39:21 <copumpkin> how come?
18:39:22 <copumpkin> ah
18:39:26 <dons> build the docs locally the
18:39:27 <dons> n
18:39:34 <dmead> how do you mean?
18:39:51 <ivanm> cabal haddock attoparsec
18:39:55 <dmead> ah
18:40:10 <dmead> is cabal in apt?
18:40:15 <ivanm> I think so
18:40:30 <dons> you need it if you're doing haskell dev.
18:40:37 <ivanm> http://packages.qa.debian.org/h/haskell-cabal-install.html
18:40:41 <ivanm> dons: I beg to differ
18:40:56 <ivanm> I find it useful when testing if my code builds, etc.
18:41:00 <ivanm> but I don't _need_ it
18:41:00 <dmead> ivanm, i mean ubuntu apt
18:41:00 <dons> well, it ships with the platform, and you need at least something approximating the platform.
18:41:10 <ivanm> dmead: *shrug* you have it, not me ;-)
18:41:17 <dmead> dons: support for cabal on ubuntu is lacking
18:41:26 <dons> cabal install attoparsec --enable-documentation
18:41:30 <dons> is what you're looking for though
18:41:39 <dmead> gotcha
18:41:47 <dmead> where do the docs go after that?
18:42:09 <dons> --haddockdir=DIR
18:42:22 <dons> ah , no. that's where haddock lives (?)
18:42:25 <dons> --docdir=DIR
18:48:55 <chipmonkpyro> how would i represent a function in one of the inputs of a where...
18:48:56 <chipmonkpyro> say for example i want a function "b" inside of a where in which b accepts a function "m -> n" along with an int "x"  and it outputs  (m - > n) x
18:48:58 <chipmonkpyro> what would the where line look like?
18:49:35 * ivanm has no idea what chipmonkpyro is wanting
18:49:45 * Alpounet neither
18:49:59 <chipmonkpyro> read it carefully ;)
18:50:00 <ivanm> do you mean inside of a where clause?
18:50:03 <chipmonkpyro> yes
18:50:19 <ivanm> what is (m -> n) x meant to represent?
18:50:40 <ivanm> it sounds like you want b = ($)
18:50:41 <chipmonkpyro> i want the output to apply (m->n) to x
18:50:59 <ivanm> except that what types are m and n vs the type of x?
18:51:03 <ivanm> @type ($)
18:51:04 <lambdabot> forall a b. (a -> b) -> a -> b
18:51:11 <ivanm> > ($) show 2
18:51:13 <lambdabot>   "2"
18:51:20 <copumpkin> I think haskell needs lazy code generation, so we can inline recursive functions too
18:51:23 <ivanm> chipmonkpyro: ^^ is that what you want?
18:51:23 <chipmonkpyro> i need a general form though
18:51:27 <ivanm> copumpkin: hmmm?
18:51:33 <ivanm> chipmonkpyro: still not following you
18:51:40 <ivanm> how can you get more general than ($) ?
18:51:43 <chipmonkpyro> how would i input a funtion into a where clause?
18:51:48 <ivanm> unless you want to do type coercement
18:51:51 <ivanm> which is _bad_
18:52:02 <ivanm> chipmonkpyro: same as you would for a top-level function
18:52:14 <copumpkin> but I guess lazy code generation and inlining would amount to a jump :)
18:52:34 <ivanm> you can consider (not very well, but it's a good-enough analogy for now) for the where clause to contain a mini module which can see everything defined in the top level of the current module
18:52:37 <chipmonkpyro> alright lemme play with it a bit more
18:52:58 <chipmonkpyro> ivanm: kk
18:57:26 <dobblego> ivanm, http://blog.tmorris.net/what-really-happened/
18:57:40 <DBAlex> Hey
18:57:47 <DBAlex> how do I go from IO String -> String
18:57:52 <dobblego> you don't
18:57:56 <Zao> Depends.
18:57:56 <DBAlex> (assuming the operation didn't fail)
18:57:58 <DBAlex> I know
18:57:59 <DBAlex> ..
18:57:59 <DBAlex> :P
18:58:10 <ivanm> you have pure functions that deal with data
18:58:16 <ivanm> and then call them within the IO monad
18:58:20 <dobblego> you can go from IO String -> (String -> a) -> IO a though
18:58:20 <DBAlex> really I want to extract Just String if it was e.g. maybe
18:58:32 <dmead> mannnnnn
18:58:38 <dmead> how do you get cabal on ubuntu :<
18:58:41 <dobblego> it's definitely not Maybe
18:58:44 <micah> I am trying to install yi with a cocoa frontend
18:58:48 <DBAlex> yeah
18:58:49 <dobblego> dmead, download it and run bootstrap.sh
18:58:55 <Zao> dmead: Haskell Platform, bootstrapping, magic?
18:58:59 <micah> I got pretty far but
18:59:02 <micah> [ 19 of 125] Compiling Yi.Prelude       ( Yi/Prelude.hs, dist/build/Yi/Prelude.o )
18:59:02 <micah> Yi/Prelude.hs:182:9:
18:59:02 <micah>     Duplicate instance declarations:
18:59:02 <micah>       instance Category Accessor.T -- Defined at Yi/Prelude.hs:182:9-38
18:59:03 <micah>       instance Category Accessor.T
18:59:03 <micah>         -- Defined in data-accessor-0.2.1.2:Data.Accessor.Private
18:59:03 <micah> cabal: Error: some packages failed to install:
18:59:04 <micah> yi-0.6.1 failed during the building phase. The exception was:
18:59:04 <micah> exit: ExitFailure 1
18:59:04 <ivanm> dobblego: and the surgeons in singapore were better than the ones here? :o
18:59:08 <DBAlex> can I convert IO String -> Maybe String
18:59:17 <copumpkin> @where paste
18:59:17 <lambdabot> http://hpaste.org/new
18:59:19 <Zao> micah: What made you think pasting a dozen lines into the channel was a bright idea?
18:59:20 <dobblego> ivanm, they were as good as the good ones I know here
18:59:25 <ivanm> micah: current problem
18:59:25 <micah> I am sorry
18:59:26 <dobblego> DBAlex, no
18:59:26 <copumpkin> @hpaste
18:59:26 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
18:59:33 <dmead> Zao it brightened my day!
18:59:35 <ivanm> micah: get the previous version of data-accessor
18:59:36 <micah> I shouldn't have done that
18:59:41 <Zao> DBAlex: See above statement about  IO String -> (String -> a) -> IO a.
18:59:49 <DBAlex> dobblego: essentially, how do I catch IO failures..
18:59:59 <dobblego> @type catch
18:59:59 <Zao> You could get an IO (Maybe String)  out of the deal :)
19:00:00 <aavogt> @hoogle catch
19:00:00 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
19:00:00 <lambdabot> Prelude catch :: IO a -> (IOError -> IO a) -> IO a
19:00:01 <lambdabot> Control.Exception catch :: Exception e => IO a -> (e -> IO a) -> IO a
19:00:01 <lambdabot> Control.OldException catch :: IO a -> (Exception -> IO a) -> IO a
19:00:18 <DBAlex> hmm
19:00:26 <DBAlex> I guess I'll just have to have an IO a
19:00:28 <Zao> dmead: I realized halfway through typing the kick that I don't have op :(
19:00:58 <Zao> In order to do anything extractive to an IO action, you need to be in an IO-ish environment.
19:01:13 <ivanm> dobblego: anyway... from ankle problems to spinal surgery? ouch!
19:01:15 <DBAlex> but you can't e.g. do reverse on an IO String
19:01:17 <DBAlex> kinda sux :/
19:01:26 <copumpkin> :t fmap reverse
19:01:27 <lambdabot> forall a (f :: * -> *). (Functor f) => f [a] -> f [a]
19:01:30 <dmead> Zao :P
19:01:34 <dobblego> ivanm, I've no idea about prognosis
19:01:41 <chipmonkpyro> im kinda confused about a type definition thing here, bear in mind this is for homework :P
19:01:43 <chipmonkpyro> If I've got this as a definition:
19:01:44 <chipmonkpyro> data Suit = Clubs | Diamonds | Hearts | Spades
19:01:46 <chipmonkpyro>  	    deriving (Eq, Ord, Enum, Show)
19:01:48 <chipmonkpyro> data Card = Carte Suit Int
19:01:49 <chipmonkpyro> how would I make something of the type "Card -> Int" that simply displays the Int from the card?
19:01:52 <chipmonkpyro> hpaste is down btw...
19:01:55 <DBAlex> can't understand why you can't go IO a -> a as long as you catch IOError's
19:01:55 <DBAlex> ?
19:02:01 <copumpkin> @hpaste
19:02:02 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
19:02:05 <ivanm> DBAlex: because it breaks referential transparency
19:02:23 <DBAlex> ivanm: come again?
19:02:34 <DBAlex> (can you explain that for simpletons? :-) )
19:02:39 <ivanm> DBAlex: referential transparency basically means that given the same input, the same output is always returned
19:02:54 <ivanm> i.e. same as in maths
19:02:56 <DBAlex> meh
19:02:57 <aavogt> DBAlex: a + b, where you've taken those values out of IO, which one prints something first?
19:02:59 <ivanm> however, with IO a -> a that isn't true
19:03:09 <DBAlex> true
19:03:17 <DBAlex> it's rather annoying though
19:03:21 <chipmonkpyro> If I've got this as a definition:
19:03:22 <chipmonkpyro> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=8523#a8523
19:03:24 <chipmonkpyro> how would I make something of the type "Card -> Int" that simply displays the Int from the card?
19:03:26 <ivanm> getStringOutOfIO getLine <-- will (potentially) return a different String each time
19:03:30 <Zao> DBAlex: It helps if you're not fighting the system :)
19:03:41 <copumpkin> chipmonkpyro: two ways to do it
19:03:45 <ivanm> chipmonkpyro: card (Card _ i) = i
19:03:47 <DBAlex> but how do you peform normal string operations e.g. reverse on an IO String?
19:03:49 <ivanm> yay for pattern matching!
19:03:54 <DBAlex> Zao: ^^, ivanm ^^
19:03:59 <copumpkin> data Card = Carte { suit :: Suit, int :: Int }
19:04:00 <ivanm> DBAlex: lift the reverse into the IO!
19:04:00 <dobblego> @type fmap reverse
19:04:01 <Zao> DBAlex: By lifting reverse into IO.
19:04:02 <lambdabot> forall a (f :: * -> *). (Functor f) => f [a] -> f [a]
19:04:06 <ivanm> @type liftM reverse
19:04:09 <lambdabot> forall a (m :: * -> *). (Monad m) => m [a] -> m [a]
19:04:14 <DBAlex> ok
19:04:17 <DBAlex> ahh :-)
19:04:20 <ivanm> @type liftM reverse getLine
19:04:21 <lambdabot> IO [Char]
19:04:39 <DBAlex>  fmap reverse $ getURLHTML "http://google.com"
19:04:39 <ivanm> DBAlex: as I said: you write pure data-processing functions, and then call them within the IO monad when processing your actual data
19:04:41 <DBAlex> sweet!
19:04:42 <DBAlex> :)
19:05:13 <DBAlex> now I can write a nice scraper that downloads all my module files daily..
19:06:02 <Zao> The more explicit way would be   do { x <- mahAction; return (reverse x) }
19:06:16 <DBAlex> Zao: yeah but getURLHTML is just general..
19:06:26 <DBAlex> maybe I will upload it somewhere, people may find it useful
19:06:34 <DBAlex> especially since the Network.Browser example is broken
19:07:02 <DBAlex> http://hackage.haskell.org/packages/archive/HTTP/4000.0.9/doc/html/Network-Browser.html
19:07:04 <DBAlex> this one
19:11:34 <DBAlex> http://www.serpentine.com/blog/2007/02/27/a-haskell-regular-expression-tutorial/
19:11:38 <DBAlex> this may be useful :)
19:15:44 <copumpkin> uorygl: :O
19:15:52 <uorygl> I got the job!
19:15:54 <uorygl> Well, no.
19:18:17 <flazz> ski: "liftM concat . sequence" does exactly what i want but i don't grok what exactly it does (when applied to [ IO [a] ], i get IO [a])
19:18:24 <dmead> hey dudes
19:18:29 <dmead> i get an error building the platform
19:18:31 <dmead> Graphics/Rendering/OpenGL/GL/BasicTypes.hs:29:7:
19:18:31 <dmead>     Could not find module `Data.Word':
19:18:41 <ivanm> :o
19:18:45 <ivanm> that's weird.....
19:18:59 <ivanm> @type liftM concat . sequence
19:19:00 <lambdabot> forall a (m :: * -> *). (Monad m) => [m [a]] -> m [a]
19:19:05 <ivanm> flazz: let's take it one step at a time
19:19:07 <ivanm> @type sequence
19:19:08 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
19:19:29 <ivanm> you happy with what sequence does?
19:19:34 <flazz> yep
19:19:40 <ivanm> @type liftM concat
19:19:41 <lambdabot> forall a (m :: * -> *). (Monad m) => m [[a]] -> m [a]
19:19:52 <ivanm> and that?
19:19:57 <flazz> so the monad the liftM is operating on is a List?
19:20:17 <ivanm> flazz: nope, generic
19:20:30 <ivanm> any monad
19:20:37 <dmead> flazz, liftm uses the bind operator
19:20:38 <flazz> but in this case?
19:20:46 <ivanm> flazz: we just need there to be a http://en.wikipedia.org/wiki/Special:Search?go=Go&search=a inside the monad
19:20:52 <dmead> which is overloaded for lists and uses concatmap
19:21:04 <ivanm> lets use new type variables:
19:21:14 <aavogt> @type foldMap
19:21:14 <dobblego> @type liftM join . Data.Traversable.sequence
19:21:15 <ivanm> wtf did this stupid client do to what I entered?
19:21:15 <lambdabot> Not in scope: `foldMap'
19:21:16 <lambdabot> forall (m :: * -> *) a (m1 :: * -> *). (Monad m, Monad m1, Data.Traversable.Traversable m) => m (m1 (m a)) -> m1 (m a)
19:21:28 <aavogt> @type Data.Foldable.foldMap
19:21:29 <lambdabot> forall a m (t :: * -> *). (Data.Foldable.Foldable t, Monoid m) => (a -> m) -> t a -> m
19:22:04 <dmead> hmm
19:22:08 <dmead> make fails on opengl
19:22:15 <ivanm> flazz: let's use different variable names: sequence :: [m b] -> m [b]
19:22:17 <dmead> but ./configure; ./scripts/build.sh works
19:22:25 <dmead> nevermind
19:22:26 <dmead> fail
19:22:30 <ivanm> and liftM concat :: m [[c]] -> m [c]
19:22:44 <ivanm> when we use (.), we have to equate m [b] with m [[c]]
19:22:48 <ivanm> happy with that?
19:23:16 <aavogt> make a subsititution:  type T = [c]
19:23:28 <aavogt> but maybe that doesn't help?
19:23:31 <flazz> ivanm: superficially, but i need time to marinade to really sink in
19:23:56 <ivanm> flazz: heh, OK
19:24:07 <ivanm> anyway, the only way to equate them is if b = [c]
19:24:24 <ivanm> so this means that liftM concat . sequence :: [m [c]] -> m [c]
19:24:31 <flazz> liftM takes the function (concat . sequence) and applies it to the "innards" of the monad applied
19:24:39 <ivanm> no, no, no
19:24:43 <ivanm> flazz: that's not what we're doing
19:24:56 <ivanm> liftM (concat . sequence) /= liftM concat . sequence
19:25:00 <dmead> @hoogle Data.Word
19:25:00 <lambdabot> module Data.Word
19:25:00 <lambdabot> Data.Word data Word
19:25:00 <lambdabot> Data.Word data Word16
19:25:13 <dmead> is that part of libhugs?
19:25:26 <ivanm> dmead: part of base IIRC
19:25:34 <ivanm> flazz: we do the sequence _first_ (reducing the list of monads down to a single monad)
19:25:36 <flazz> concat is lifted
19:25:37 <SamB_XP> wth is libhugs ?
19:25:48 <ivanm> then we concat the list of lists inside the monad together into one big list
19:25:53 <ivanm> flazz: right
19:25:54 <SamB_XP> ivanm: that doesn't make any sense!
19:25:54 <aavogt> hugs should in one for or another have access to Data.Word
19:26:15 <ivanm> SamB_XP: what doesn't? and why?
19:26:25 <djahandarie> Cabal seems to be refusing to install plugins
19:26:33 <SamB_XP> well, how do you reduce this down to one monad:
19:26:40 <SamB_XP> @instances Monad
19:26:41 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
19:26:41 <dmead> ruh roh
19:26:53 <djahandarie>  Cabal-1.8.0.2-f1b96fbe00cb2101ed495d60417d9464 is shadowed by package Cabal-1.8.0.2-a7cb9536dae40bb8d1ebb7fda099f46a
19:27:18 <ivanm> SamB_XP: OK, fine, we're reducing a list of monadic values into one big monadic value
19:27:33 <aavogt> djahandarie: why two Cabals?
19:27:33 <ivanm> djahandarie: did you try to upgrade/re-install Cabal?
19:27:40 <ivanm> aavogt: methinks someone stuffed up
19:27:53 <djahandarie> Yeah I did
19:27:58 <adu> wow
19:28:07 <ivanm> djahandarie: there's your problem
19:28:10 <flazz> ivanm: sequence [ IO a ] -> IO [a], we get a list of the innards, and liftM raises concat to that list, i get it
19:28:13 <flazz> right?
19:28:18 <ivanm> also, I think plugins might need tweaking to work with 6.12
19:28:26 <ivanm> flazz: right
19:28:26 <djahandarie> ivanm, was I not suppose to do that? :-(
19:28:33 <ivanm> djahandarie: nope
19:28:38 <djahandarie> lol drats
19:28:42 <ivanm> flazz: except that for concat to work, the innards have to be [a] to start with
19:28:42 <djahandarie> There should be a warning!
19:28:47 <ivanm> so after sequence you have [[a]]
19:28:49 <flazz> right
19:28:56 <ivanm> djahandarie: that's why "cabal upgrade" is currently disabled
19:29:46 <djahandarie> So... how should I go about fixing this?
19:30:03 <flazz> is the precedence for . higher than application?
19:30:11 <copumpkin> nope
19:30:15 <flazz> er lower i mean
19:30:29 <copumpkin> yep
19:30:40 <ivanm> djahandarie: any idea which of those two cabals were the one that came with GHC originally?
19:31:06 <SamB_XP> ivanm: won't the paths to the .a files tell?
19:31:19 <djahandarie> ivanm, no, but I have a 50% chance don't I?
19:31:25 <flazz> what does . mean if the RHS is not a function?
19:31:35 <copumpkin> flazz: qualified modules?
19:31:36 <Axman6> it has to be a function
19:31:37 <Cale> flazz: Function application binds tighter than any infix operator
19:31:51 <copumpkin> it could be a type variable too
19:31:51 <copumpkin> in certain contexts
19:31:53 <Axman6> flazz: example?
19:32:00 <SamB_XP> > (+1) . [1..]
19:32:02 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
19:32:02 <ivanm> SamB_XP: dunno, maybe
19:32:14 <ivanm> Axman6: any idea how to fill out this time sheet?
19:32:19 <Cale> Ah, in lambdabot, I have (.) defined to be fmap, which is a generalisation of function composition
19:32:20 * hackagebot piki 0.3.0 - Yet another Wiki format converter  http://hackage.haskell.org/package/piki-0.3.0 (KazuYamamoto)
19:32:25 <Axman6> sort of... go ask Chelsea
19:32:46 <ivanm> heh
19:32:48 <djahandarie> Have you seen this thing cale?
19:32:49 <flazz> "listM concat . sequence $ xs" . is the root of the ast, and the RHS is xs applied to sequence?
19:32:54 <djahandarie> @pl 1.6
19:32:55 <lambdabot> 1 . 6
19:33:00 <ivanm> Cale: haven't we told you that that was a bad idea? :p
19:33:06 <Cale> ivanm: Hm?
19:33:16 <Cale> ivanm: Some people like it, some people don't.
19:33:17 <SamB_XP> Cale: (.) = fmap
19:33:25 <SamB_XP> oh, you figured it out
19:33:26 <ivanm> Cale: Axman6 and I have argued a number of times that Caleskell (particularly (.)) is confusing to newbies!
19:33:27 <Cale> I happen to like it
19:33:30 <Axman6> flazz: that's "(listM concat . sequence) xs"
19:33:57 <SamB_XP> Cale: the (.) should be, like, yellow or something
19:34:01 <Cale> There are a lot of other libraries which are loaded into lambdabot that might be confusing to newbies too.
19:34:13 <Axman6> but those done affect newbies
19:34:17 <Cale> Sure they do.
19:34:21 <Axman6> (.) = fmap does, a hell of a lot
19:34:25 <Axman6> such as?
19:34:35 <Cale> simplereflect
19:34:47 <SamB_XP> if a function they've never heard of doesn't do what they expect, it's no biggie, is it ?
19:34:51 <Axman6> that's far less confusing than (.) = fmap
19:34:59 <Axman6> in face, it makes learning more intuitive for them
19:35:01 <aavogt> > f x + 1
19:35:02 <lambdabot>   Ambiguous type variable `a' in the constraints:
19:35:02 <lambdabot>    `SimpleReflect.FromExpr ...
19:35:02 <Cale> It defines all the one-letter variables, so it's rather easy to accidentally use simplereflect without intending to
19:35:03 <Axman6> fact*
19:35:19 <roboshibby> what does j do?
19:35:25 <SamB_XP> Cale: yeah, but then they'll be like "hey, how did lambdabot do that!"
19:35:41 <SamB_XP> not like "what the heck? how does this even typecheck?"
19:35:42 <djahandarie> > a
19:35:43 <Cale> SamB_XP: Except that usually it just results in weird error messages
19:35:43 <lambdabot>   a
19:35:53 <SamB_XP> > f x
19:35:54 <lambdabot>   Ambiguous type variable `a' in the constraints:
19:35:55 <lambdabot>    `GHC.Show.Show a'
19:35:55 <lambdabot>      a...
19:35:56 <flazz> "listM concat . sequence $ xs" is "((listM concat) . sequence) xs" ?
19:35:59 <djahandarie> > a . b
19:35:59 <Cale> ^^ like that one :)
19:36:00 <SamB_XP> Cale: oh, true
19:36:00 <lambdabot>   Couldn't match expected type `a -> b'
19:36:00 <lambdabot>         against inferred type `Simple...
19:36:06 <SamB_XP> I forgot about that
19:36:08 <aavogt> > f x :: Expr
19:36:08 <SamB_XP> why IS that?
19:36:10 <lambdabot>   f x
19:36:17 <Cale> Because the type is ambiguous
19:36:25 <SamB_XP> ... so?
19:36:26 <dolio> > f x y z :: Expr
19:36:28 <lambdabot>   f x y z
19:36:28 <SamB_XP> > 1
19:36:29 <lambdabot>   1
19:36:30 <copumpkin> I wish the defaulting mechanism could be overloaded
19:36:34 <SamB_XP> *that* works!
19:36:44 <djahandarie> > 1.1 :: Expr
19:36:45 <lambdabot>   1.1
19:36:48 <Axman6> and i still can't believe we're arguing this. the only person who wants to keep the Caleskell stuff is Cale. other people like it, but i've not heard one who would complain vehemently if it were removed
19:36:50 <roboshibby> copumpkin: where can i read about the defaulting mechanism?
19:36:51 <Cale> SamB_XP: Yes, that's numeric defaulting
19:36:58 <Cale> SamB_XP: It only applies to numeric types
19:37:10 <dolio> > f s t e w a r d e s s e s :: Expr
19:37:11 <lambdabot>   f s t e w a r d e s s e s
19:37:12 <Axman6> it pisses me off, it annoys ivanm, and others, it confuses people, and it's liked by one person. how selfish can you get?
19:37:12 <Cale> SamB_XP: and only when the typeclasses involved are Prelude types
19:37:29 <copumpkin> dolio: lol
19:37:29 <Cale> Axman6: Not just one person. I'm not the only one who likes it
19:37:30 <SamB_XP> Cale: grr
19:37:38 <SamB_XP> I thought GHCi had better defaulting than that?!?
19:37:47 <Axman6> you're the only one who would mind if it were removed
19:37:49 <copumpkin> roboshibby: http://www.haskell.org/onlinereport/decls.html#sect4.3.4 I think
19:38:14 <aavogt> Axman6: we've hade other bots for haskell evaluation in here before
19:38:34 <copumpkin> but mmorrow disappeared :(
19:38:35 <Axman6> yes, but lambdabot is _the_ bot everyone uses
19:38:38 <copumpkin> and with him lunabot
19:38:44 <roboshibby> nice
19:38:48 <roboshibby> thank you copumpkin
19:39:11 <Axman6> make a new bot, call it calebot, and make everyone happy. lambdabot is generally used as a teaching tool (among other things), so why make that difficult?
19:39:16 <Axman6> it's just insane
19:39:43 <dons> ah Caleskell.
19:39:46 <copumpkin> axbot!
19:39:47 <dons> in the folklore now
19:39:47 <roboshibby> Axman6: thank you for fighting for the little guy
19:39:51 <copumpkin> for when people ax questions
19:40:13 <dolio> Well played.
19:40:23 <Axman6> i don't have a problem with caleskell. I have a big problem when it gets in my way, and the way of others, especially when there's absolutely no need for it to
19:40:27 <aavogt> haskell already has enough gotchas involving Num such that making (++) :: Monoid m => m -> m -> m, and this (.) probably doesn't make error messages much worse
19:40:32 * copumpkin has the lamest sense of humor of anyone in here
19:40:34 <djahandarie> Honestly, I agree that things defined in Haskell 98 shouldn't be changed for the standard bot used in this channel
19:40:50 <Axman6> aavogt: yes, it does, all the time
19:40:51 <djahandarie> So either make it comply or change the standard, in my opinion.
19:40:52 <aavogt> heliuuumbot?
19:41:02 <roboshibby> and djahandarie liked funky town video, so he knows what he's talking about
19:41:05 * copumpkin has grown to not mind caleskell
19:41:08 <copumpkin> it was unexpected at first
19:41:29 <Axman6> Cale: like i said, i don't mind it, i think it's cool. but lambdabot is not the place for it
19:41:32 <djahandarie> Should opinion even factor in?
19:41:46 <copumpkin> how about a different prefix for caleskell?
19:41:52 <Axman6> sure
19:41:55 <djahandarie> The prelude is defined in Haskell 98, even if it sucks... it is still the standard
19:41:57 <copumpkin> ::t vs. :t and > vs >> ?
19:42:06 <SamB_XP> djahandarie: that's a really lousy argument
19:42:08 <copumpkin> djahandarie: screw that, I hate standards anyway
19:42:11 <djahandarie> !!
19:42:14 <djahandarie> Then fix the standard
19:42:28 <SamB_XP> djahandarie: yeah, well, that's supposedly in progress
19:42:35 <Axman6> anything, just make (.) :: (b -> c) -> (a -> b) -> a -> c, and i'll be happy
19:42:43 <Axman6> and don't tell me it is, because it isn't
19:42:51 <SamB_XP> right now, libraries@ is really in charge of Prelude, afaict
19:42:53 <roboshibby> what's :: ?
19:43:01 <aavogt> @let f . g = \x -> f (g x)
19:43:02 <lambdabot>  <local>:18:2:
19:43:02 <lambdabot>      Multiple declarations of `L..'
19:43:02 <lambdabot>      Declared at: .L.hs:85...
19:43:04 * copumpkin changes (.) to Prelude.. but leaves flip as is, just to piss Axman6 off
19:43:10 <Axman6> roboshibby: type declaration
19:43:16 <roboshibby> oh
19:43:16 <copumpkin> > (+1) Prelude.. (*5) $ 5
19:43:17 <lambdabot>   Not in scope: `Prelude..'
19:43:25 <SamB_XP> @type flip
19:43:26 <dons> we need some April 1 prelude proposals...
19:43:26 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
19:43:34 <ivanm> dons: heh
19:43:35 * Axman6 inserts a hot poker into copumpkin's fleshy bits
19:43:45 <SamB_XP> that flip makes no sense
19:43:46 <copumpkin> Axman6: ooh, just a little farther left!
19:43:51 <copumpkin> oh yes, that's perfect!
19:43:57 <copumpkin> SamB_XP: sure it does!
19:43:59 * ivanm fires a crowbar satellite at copumpkin
19:44:05 <djahandarie> copumpkin, you do have the worst sense of humour in here
19:44:11 <SamB_XP> copumpkin: it doesn't evoke the idea of "flipping" with that typesig
19:44:21 <copumpkin> djahandarie: hey, at least I acknowledge it :)
19:44:22 <Axman6> not at all
19:44:36 <copumpkin> I have been up for a day and a half now
19:44:41 <SamB_XP> it's more like, oh, "push the functor to past the arrow"
19:44:41 <aavogt> SamB_XP: it flips the f and the a
19:44:45 <copumpkin> which probably makes my humor even worse than usual
19:44:52 <ivanm> SamB_XP: agreed
19:45:26 <aavogt> funFlip?
19:45:40 <copumpkin> @let fffflip = flip
19:45:40 <Cale> djahandarie: I think that implementations should change before standards.
19:45:42 <lambdabot>  Defined.
19:45:58 <Cale> djahandarie: Standardising unimplemented and untried things is always a bad idea.
19:46:20 <Axman6> but forcing change on people while you test things is just a dick move
19:46:20 <SamB_XP> yeah
19:46:21 <djahandarie> Cale, a learning tool shouldn't be the testing grounds for that.
19:46:36 <copumpkin> it's a golfing tool
19:46:42 <Axman6> djahandarie: exactly
19:46:43 <copumpkin> what is this learning of which you speak?
19:46:58 <aavogt> we're preparing #haskell for the future
19:47:02 <ivanm> @slap copumpkin
19:47:02 * lambdabot locks up copumpkin in a Monad
19:47:16 <Axman6> ffs!
19:47:17 <copumpkin> tiger woods is on his way, now that we've fixed up lambdabot with caleskell
19:47:25 <SamB_XP> lambdabot: what if you just used the identity Monad!
19:47:33 <ivanm> aavogt: wow, that's  a relief; I would have no idea how to progress into the next second if it weren't for someone preparing for the future!
19:47:51 <SamB_XP> ivanm: lol
19:47:57 <ivanm> @vixen what if you just used the identity Monad?
19:47:58 <lambdabot> oh, but only if, right?
19:48:03 <ivanm> ???
19:48:12 <copumpkin> you're ALWAYS using the identity monad/functor!
19:48:17 <SamB_XP> ivanm: too bad they didn't finish preparing for that second before you reached it!
19:48:42 <SamB_XP> copumpkin: it doesn't work very well for preventing escape ;-P
19:48:42 <ivanm> yeah
19:48:50 * ivanm -> tutoring
19:49:06 <Cale> ivanm: Let's all thank the gnomes in the interstices between timeslices who do all the hard work of moving everything just so, according to the rules.
19:49:13 <Axman6> o/ ivanm, come back and keep up the good fight afterwards!
19:49:27 <ivanm> Axman6: eh, it depends if I want to head off home or not
19:49:32 <SamB_XP> propel propel your craft ... o/
19:49:48 <SamB_XP> er. forgot a propel. oops...
19:50:22 <Axman6> @let (+) = (*)
19:50:23 <lambdabot>  Defined.
19:50:39 <copumpkin> ooh, Axman6 just applied exp
19:50:58 <Axman6> @let show = const "fail"
19:50:59 <lambdabot>  Defined.
19:51:02 <aavogt> @let (*) = (+)
19:51:03 <lambdabot>  <local>:1:6:
19:51:03 <lambdabot>      Ambiguous occurrence `*'
19:51:03 <lambdabot>      It could refer to either `L....
19:51:19 <copumpkin> mutiny!
19:51:24 <aavogt> @vixen no logs eh?
19:51:24 <lambdabot> i didn't think so
19:51:32 <Axman6> @let fmap = L.show
19:51:33 <lambdabot>  .L.hs:85:6:
19:51:33 <lambdabot>      Ambiguous occurrence `fmap'
19:51:33 <lambdabot>      It could refer to either `...
19:51:53 <Axman6> @let fmap = Prelude.show
19:51:54 <lambdabot>  .L.hs:85:6:
19:51:54 <lambdabot>      Ambiguous occurrence `fmap'
19:51:54 <lambdabot>      It could refer to either `...
19:52:28 <ivanm> Axman6: OK, now you're just being a PITA and not helping our glorious cause
19:52:33 <Axman6> @let return = const (fail "Massive fail")
19:52:33 * ivanm really heads off this time
19:52:34 <lambdabot>  Defined.
19:52:41 <Axman6> no, it's Axskell :)
19:53:02 <Axman6> i'm chainging the implementation to how i think it should be used
19:53:32 <Axman6> some people might find it helpful, most will find it a pain in the arse, but that's ok apparently
19:53:56 <cads> @pl (\ a b -> 4*a + b )
19:53:56 <lambdabot> (+) . (4 *)
19:53:57 <copumpkin> > show (fmap (+ 1) (return 5) :: [Int])
19:53:58 <lambdabot>   "[6]"
19:54:07 <copumpkin> :O
19:54:11 <cads> > (+) . (4 *) 2 1
19:54:12 <lambdabot>   No instance for (GHC.Show.Show (f (a -> a)))
19:54:12 <lambdabot>    arising from a use of `M318...
19:54:28 <copumpkin> cads: needs moar parentheses
19:54:42 <cads> > ((+) . (4 *)) 2 1
19:54:43 <lambdabot>   9
19:55:31 * Axman6 senses an unlet
19:55:33 <Axman6> win 20
19:56:19 <SamB_XP> > return 1
19:56:20 <lambdabot>   No instance for (GHC.Show.Show (m t))
19:56:20 <lambdabot>    arising from a use of `M5827472969...
19:56:31 <cads> Thanks copumpkin
19:56:34 <Alpounet> > fmap 4
19:56:35 <lambdabot>   No instance for (GHC.Num.Num (a -> b))
19:56:35 <lambdabot>    arising from the literal `4' at <...
19:56:47 <SamB_XP> > fmap (4+)
19:56:48 <lambdabot>   No instances for (Test.SmallCheck.Serial (f t),
19:56:48 <lambdabot>                    GHC.Show...
19:57:06 <SamB_XP> > fmap (4+) :: Int -> Int
19:57:07 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
19:57:07 <lambdabot>         against inferred type ...
19:57:19 <SamB_XP> > fmap (4+) :: [Int] -> [Int]
19:57:20 <lambdabot>   []->
19:57:21 <lambdabot>    []
19:57:21 <lambdabot>  [-2]->
19:57:21 <lambdabot>    [2]
19:57:21 <lambdabot>  [-2,-1]->
19:57:22 <lambdabot> [4 @more lines]
19:57:31 <SamB_XP> @more
19:57:31 <lambdabot>    [2,3]
19:57:31 <lambdabot>  [-2,-1,0]->
19:57:32 <lambdabot>    [2,3,4]
19:57:32 <lambdabot>  [-2,...
20:00:04 <flazz> how can i express "getFileSize path = liftM fileSize $ getFileStatus path" point free?
20:00:39 <Axman6> getFileSize = fmap fileSize . getFileStatus
20:00:57 <SamB_XP> @pl getFileSize path = liftM fileSize $ getFileStatus path
20:00:57 <lambdabot> getFileSize = fmap fileSize . getFileStatus
20:01:06 <SamB_XP> lambdabot actually got it right!
20:01:10 <SamB_XP> hooray!
20:01:10 <flazz> wow
20:01:39 <flazz> thanks
20:02:08 * SamB_XP thinks he would go with the pointful version though
20:03:28 <flazz> so the reason that works is because IO is n instance of Functor?
20:03:57 <Axman6> yes
20:04:03 <Axman6> all Monads are Functors
20:04:42 <flazz> all monads?
20:04:42 <SamB_XP> or at least, you get to flame the author if they aren't!
20:04:49 <Axman6> yes, all Monads
20:04:52 <flazz> ok
20:04:57 <aavogt> the language does not require instances to exist though
20:04:58 <Axman6> or, they should be
20:05:00 <copumpkin> they are, even if there's no instance for it
20:05:14 <SamB_XP> hence the license to flame ;-P
20:05:23 <Axman6> is there an instance defined anywhere instance Monad a => Functor a?
20:05:38 <SamB_XP> nowhere *I* import from!
20:05:43 <Axman6> :t fmap
20:05:44 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
20:05:47 <Axman6> :t liftM
20:05:48 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
20:05:57 <Axman6> flazz: that's why ^^^
20:06:00 <SamB_XP> Axman6: saves a character ;-P
20:06:57 <Gracenotes> :t (<$>)
20:06:58 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
20:09:12 <jmcarthur> :t liftA
20:09:13 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (a -> b) -> f a -> f b
20:09:28 <jmcarthur> :t (.)
20:09:29 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
20:09:38 <jmcarthur> (that one's a lie)
20:10:26 <SamB_XP> jmcarthur: I was not aware that (.) == cake
20:10:47 <Axman6> > cake
20:10:48 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
20:10:57 <SamB_XP> lol
20:11:01 <DBAlex> is there a string function that can match between 2 chars?
20:11:05 <jmcarthur> The (.) is a lie. The (.) is a lie. The (.) is a lie. The (.) is a lie. The (.) is a lie.
20:11:11 <Axman6> > map (head . drop 1) cake
20:11:13 <lambdabot>   "nnhonhnwoiiiiiuianlniniwnnwwnnhnnwdlonnrnh"
20:11:19 <DBAlex> e.g. match '>' '<' "<p>Hello</p>"
20:11:20 <Axman6> > map (head . drop 2) cake
20:11:21 <lambdabot>   "eeruereonssssslsnepsbdnee ooeereeojarjjada"
20:11:22 <DBAlex> without using regex
20:11:33 <Gracenotes> what do you mean by 'match' and 'between'?
20:11:43 <DBAlex> that would return "Hello"
20:11:44 <lambdabot> This was a triumph
20:11:49 <jmcarthur> DBAlex: what type should the function have, and give some sample input and output
20:11:53 <lambdabot> I'm making a note here: huge success.
20:12:05 <DBAlex> match Char -> Char -> String -> String
20:12:11 <lambdabot> It's hard to overstate my satisfaction
20:12:15 <SamB_XP> lambdabot: is this the orchestra version or the silly version?
20:12:21 <Gracenotes> /kb lambdabot
20:12:23 <jmcarthur> okay so you want it to return the string between the two chars?
20:12:24 <DBAlex> match '>' '<' "<p>Hello</p>"
20:12:27 <DBAlex> "Hello"
20:12:28 <DBAlex> yes
20:12:46 <DBAlex> I'm having difficulty seeing as writing it recursively means you collect the chars in e.g. [c]
20:12:53 <SamB_XP> hmm, I haven't heard either in a while
20:13:06 <SamB_XP> probably because I've been tuned to V-wave ...
20:13:09 <Gracenotes> that's more complicated than you made it sound. How about match '<' '>' "<a<b>c>", or with the last argument as "abc>de"?
20:13:16 <DBAlex> it's hard since I can't just set a flag to say "We found the start char"
20:13:32 <Gracenotes> DBAlex: don't use a flag, use an int :)
20:13:38 <jmcarthur> > let match a b = takeWhile (/=b) . tail . dropWhile (/=a) in match '>' '<' "<p>Hello</p>"
20:13:39 <lambdabot>   "Hello"
20:14:08 <DBAlex> Gracenotes: it's not hard since i'll just remove the section once I match on  it (and map the match function to the rest)
20:14:14 <jmcarthur> that will fail on empty strings or strings that don't have the characters you are looking for
20:14:17 <DBAlex> jmcarthur: nice
20:14:32 <DBAlex> jmcarthur: I could use the Maybe monad
20:14:34 <DBAlex> nice :)
20:14:52 <SamB_XP> or the Parsec, perhaps
20:14:55 <SamB_XP> or even ReadM
20:15:08 <jmcarthur> if you are doing anything remotely complex i'd go with a parser library
20:16:42 <DBAlex> jmcarthur: I think should should be ok for all I want
20:16:54 <DBAlex> getting ahref's
20:17:13 <jmcarthur> > let match a b = takeWhile (/=b) . tail . dropWhile (/=a) in match '>' '<' "<a<b>c>"
20:17:14 <lambdabot>   "c>"
20:17:22 <jmcarthur> another issue with that one
20:17:59 <jmcarthur> actually i guess that is correct
20:18:05 <jmcarthur> > let match a b = takeWhile (/=b) . tail . dropWhile (/=a) in match '<' '>' "<a<b>c>"
20:18:06 <lambdabot>   "a<b"
20:18:12 <jmcarthur> that's probably not what you would mean
20:18:27 <jmcarthur> i guess the whole idea is malformed html though
20:19:35 <Cale> DBAlex: Have you seen TagSoup?
20:20:07 <Cale> DBAlex: I've found it's a heck of a lot nicer than direct string manipulation if you're scraping HTML.
20:20:29 <DBAlex> ok
20:20:38 <DBAlex> I guess, but all I want is links
20:20:49 <DBAlex> seems overkill for that
20:21:04 <DBAlex> how hard can getting the string between "<a href="  and ">" be
20:21:04 <DBAlex> :P
20:21:27 * shapr has traumatic flashbacks
20:21:55 * Pseudonym doesn't like HTML
20:22:15 <Pseudonym> That you need an HTML parser distinct from an SGML or XML parser is just silly.
20:23:26 <jmcarthur> separate from SGML?
20:23:28 <DBAlex> *Main> match '>' '<' ""
20:23:28 <DBAlex> ""
20:23:28 <DBAlex> *Main> match '>' '<' " "
20:23:28 <DBAlex> "*** Exception: Prelude.tail: empty list
20:23:30 <DBAlex> Hmm
20:23:30 <Cale> Well, that's easy... [(innerText (takeWhile (not . isTagCloseName "a") rs, fromAttrib "href" a) | (a:rs) <- partitions (isTagOpenName "a")]
20:23:34 <DBAlex> That's strange
20:23:45 <Pseudonym> HTML-in-the-wild is usually not valid SGML, is it?
20:23:47 <jmcarthur> that error makes sense to me
20:24:05 <DBAlex> yeah, but, " ", how can I check
20:24:08 <DBAlex> *for that
20:24:09 <DBAlex> :/
20:24:17 <jmcarthur> it drops elements until it sees '>', but it never sees that, so the result is empty, then you apply tail to that and boom
20:24:27 <SamB_XP> Pseudonym: sadly :-(
20:24:28 <jmcarthur> DBAlex: we've been suggesting alternatives ;)
20:24:30 <copumpkin> bo'om
20:24:33 <DBAlex> heh
20:24:36 <Cale> TagSoup is lightweight and saves a lot of trouble
20:24:42 <DBAlex> I'll live dangerously :)
20:24:45 <DBAlex> for now
20:24:46 * copumpkin votes for tagsoup
20:24:51 <jmcarthur> DBAlex: go with tagsoup. it's very simple
20:25:05 <SamB_XP> apparantly, valid SGML that uses the HTML DOCTYPEs isn't necessarily legal HTML, either, even if it doesn't violate any of the tag nesting rules or anything!
20:25:08 <DBAlex> yeye, I've seen all those sort of things... I think it's overkill for some stuff
20:25:18 <DBAlex> If your doing heavy HTML stuff I'd use them though
20:25:21 <Cale> It's not overkill at all.
20:25:22 <jmcarthur> DBAlex: tagsoup is not overkill. this is what it's for
20:25:26 <dmead> hey guys
20:25:29 <DBAlex> BeautifulSoup in Python is great
20:25:37 <Cale> This is exactly the sort of task that tagsoup is for
20:25:38 <dmead> i'm getting this exact build error for the platform: http://permalink.gmane.org/gmane.comp.lang.haskell.glasgow.bugs/21168
20:25:43 <dmead> anybody know the fix for that?
20:25:45 <dmead> if it exists?
20:25:49 <Axman6> DBAlex: oi, just do as you're told :P
20:25:52 <DBAlex> I guess I don't liketoo many  dependencies
20:25:56 <jmcarthur> DBAlex: our tagsoup is crippled compared to python's (read: lightweight and perfect for this purpose)
20:26:04 <copumpkin> DBAlex: NIH
20:26:10 <Axman6> you asked for advice, and you're getting good advice. it's bad style to ignore good advice
20:26:11 <DBAlex> NIH?
20:26:15 <SamB_XP> copumpkin: the rats are coming ?
20:26:26 <DBAlex> Nine Inch.. Heels?
20:26:28 <Cale> It's not a proper HTML parser. It just gives you a list of tags, and some tools for picking through them to find the bits you want
20:26:30 <DBAlex> Wut?
20:26:38 <copumpkin> it's one of national institutes of health or not invented here
20:26:45 <jmcarthur> DBAlex: heh, i started reading it as "nine inch <something>" as well
20:26:52 <DBAlex> Nine Inch Nails!
20:26:55 <copumpkin> jmcarthur: how'd you know?!
20:26:55 <DBAlex> Quake music! ...
20:27:01 <DBAlex> See how my brain works.. :-P
20:27:09 <jmcarthur> mm quake
20:27:13 * Pseudonym is reminded of the Muppet sketch with Nine Inch Snails
20:27:18 <Cale> NIH in this context stands for "Not Invented Here", and it's the condition where rather than using a library that does exactly what you want, you rewrite the thing yourself. ;)
20:27:18 <DBAlex> Quake -> Id -> Doom -> Wolf3D... -> Apogee...
20:27:28 <Pseudonym> http://www.youtube.com/watch?v=S0qQ1pomYzk
20:27:32 <DBAlex> my brain is just a linked list .. :D
20:27:39 <jmcarthur> DBAlex: Not Invented Here syndrome
20:27:39 <copumpkin> every time a library doesn't get used for the purpose it was designed for it makes me sad, especially if it's rejected for reasons entirely unrelated to its own merits
20:27:59 <Cale> http://hackage.haskell.org/package/download-curl -- another one that I'd recommend
20:28:05 <SamB_XP> @google NotInventedHere
20:28:06 <lambdabot> http://en.wikipedia.org/wiki/Not_Invented_Here
20:28:06 <DBAlex> ok
20:28:06 <lambdabot> Title: Not Invented Here - Wikipedia, the free encyclopedia
20:28:12 <Cale> You can use openAsTags to get a list of TagSoup tags
20:28:17 <SamB_XP> @google NotInventedHere wiki
20:28:18 <lambdabot> http://en.wikipedia.org/wiki/Not_Invented_Here
20:28:18 <lambdabot> Title: Not Invented Here - Wikipedia, the free encyclopedia
20:28:24 <SamB_XP> @google NotInventedHere c2
20:28:25 <lambdabot> http://c2.com/cgi/wiki?NotInventedHere
20:28:25 <lambdabot> Title: Not Invented Here
20:31:14 <Cale> ghci> Right tags <- openAsTags "http://haskell.org"
20:31:15 <Cale> ghci> [(name, url) | (a:rs) <- partitions (isTagOpenName "a") tags, let {name = innerText . takeWhile (not . isTagCloseName "a") $ rs; url = fromAttrib "href" a}, not (null url)]
20:31:15 <Cale> [("","/haskellwiki/Haskell"),("Haskell","/haskellwiki/Haskell"),("Wiki community","/haskellwiki/HaskellWiki:Community"),("Recent changes","/haskellwiki/Special:Recentchanges"),("Random page","/haskellwiki/Special:Random"),("Special pages","/haskellwiki/Special:Specialpages")...
20:31:47 <dmead> argh
20:31:50 <dmead> AARRGH
20:31:51 <dmead> unrecognized option `--with-cabal-install=../cabal-install-0.6.2/dist/build/cabal/cabal'
20:31:54 <dmead> :(
20:32:06 <dmead> oh haskell, such a love hate relationship
20:32:23 <copumpkin> why are you building the platform, anyway?
20:32:27 <Cale> Why such an old cabal-install?
20:32:32 <Cale> Oh, platform?
20:32:39 <copumpkin> I thought
20:32:39 <Cale> On linux, don't bother with it
20:33:16 <Cale> Just get the GHC generic linux binary from the GHC website, and then get cabal-install and run the bootstrap.sh script
20:33:55 <Cale> Once you have cabal-install, you can just use it to install any package you might need
20:34:30 <dmead> i need cabal right?
20:34:37 <dmead> but on ubuntu, it's an old ghc
20:34:41 <dmead> and it doesn't come with cabal
20:34:46 <Cale> Yeah, don't use Ubuntu's GHC package.
20:34:50 <dmead> :/
20:34:55 <dmead> well i'm trying to build this dealy
20:34:56 <Cale> Get the generic linux binary from the GHC website
20:35:06 <dmead> will that have cabal?
20:35:42 <Cale> It won't have cabal install, but it will have everything you need to get cabal-install running using the tarball from hackage
20:36:10 <Cale> (with ubuntu's GHC, there are a bunch of other packages, it's complicated because they split everything into a million pieces)
20:36:22 <Cale> http://hackage.haskell.org/packages/archive/cabal-install/0.8.0/cabal-install-0.8.0.tar.gz
20:36:32 <Cale> ^^ this is the tarball of cabal-install you'll want
20:36:35 <dmead> ah
20:36:36 <dmead> thanks man
20:36:44 <dmead> i have basically everything installed
20:36:46 <dmead> so perhaps it'll work
20:36:55 <Cale> You can run the bootstrap.sh script from it to get things going
20:37:43 <Cale> After you have it installed of course you can use cabal-install to update itself
20:39:22 <dmead> gotcha
20:39:54 <dmead> i wonder what the reason is for ubuntu being so behind
20:40:15 <SamB_XP> lack of package maintainers ?
20:40:30 <dmead> perhaps
20:40:33 <tavelram> btw, is there a way to tell cabal-install to not compile Setup.hs, but to just runhaskell it?
20:40:38 <dmead> gentoo never had that problem though
20:40:50 <dmead> tavelram, that is compiling it...
20:41:03 <tavelram> ok, well, not linking it then :p
20:41:07 <SamB_XP> well, maybe gentoo has something else that is just as good as package maintainers ?
20:41:30 <dmead> SamB_XP, i think alot of haskellers do their haskelling on gentooo
20:41:45 <dmead> i'm usually one of them, but i don't have the patience to build a gentoo on a laptop
20:42:57 <dmead> all this run around just to get at docs
20:44:06 <Axman6> don't you just love ubuntu?
20:44:32 <Cale> There are a fair number of Haskellers using Ubuntu, but I suppose personally I don't really care what condition Ubuntu's packages are in, because I'm going to install GHC myself anyway.
20:44:51 <Cale> and get all my Haskell libraries from Hackage
20:45:17 <DigitalKiwi> arch ftw
20:45:18 <DigitalKiwi> amirite?
20:45:26 <Cale> It would be nice if they stayed more up to date, but the Ubuntu dev cycle is also pessimally aligned with the GHC dev cycle
20:45:59 <Cale> So GHC releases a new version often just a few weeks after Ubuntu freezes.
20:46:09 <DigitalKiwi> lmao
20:47:20 <SamB_XP> I still don't get that "freeze" bussiness
20:47:57 <Cale> Ubuntu tries to make sure that everything works together for the release, but it seems not to be working.
20:48:07 <SamB_XP> what exactly is this "release" thing ?
20:48:18 <Cale> The last release of Ubuntu got me nothing except about a day's worth of solving their mistakes.
20:48:48 <Cale> So I'm thinking I should switch back to Debian unstable or testing.
20:48:52 <jmcarthur> ubuntu gets me convenient XBMC. that's about it
20:48:56 <jmcarthur> arch ftw
20:49:19 <Cale> I ran Debian unstable for 6 years or so before Ubuntu, and I liked that fairly well.
20:50:10 <SamB_XP> Cale: yeah, I'm a testing user myself
20:50:21 <SamB_XP> though I'm way behind on updates, as usual
20:51:37 <DigitalKiwi> community/xbmc 9.11-11 [installed] [44.27 MB] XBMC Media Center
20:51:41 <dmead> @hoogle parsec
20:51:41 <lambdabot> package parsec
20:51:41 <lambdabot> module Text.Parsec
20:51:41 <lambdabot> module Text.ParserCombinators.Parsec
20:51:45 <dmead> guys
20:51:45 <DigitalKiwi> how is ubuntu more convenient than that? :P
20:51:52 <dmead> if i want to get the docs for parsec via cabal
20:51:54 <dmead> what do i do?
20:51:56 * hackagebot attoparsec 0.8.0.0 - Fast combinator parsing for bytestrings  http://hackage.haskell.org/package/attoparsec-0.8.0.0 (BryanOSullivan)
20:52:30 <dmead> right
20:52:34 <dmead> how do you get the docs?
20:52:51 <Cale> Usually I just read them off the web
20:53:00 <Cale> They're linked from the hackage package description
20:53:15 <Cale> But you could probably cabal fetch and then cabal haddock
20:53:40 <dmead> do you see them on the attoparsec page?
20:53:44 <dmead> am i just blind and dumb?
20:54:10 <jmcarthur> DigitalKiwi: xbmc wasn't in community last i checked, so that's a new one for me
20:54:24 <DigitalKiwi> it's been there a few months at least
20:54:34 <jmcarthur> DigitalKiwi: oh wait, yes it was. my issue was with xbmc's integration with remote controls under arch
20:54:35 <Cale> attoparsec *just* got uploaded there
20:54:40 <DigitalKiwi> oh
20:54:51 <Cale> so its docs haven't been generated
20:55:15 <copumpkin> bos: any plans for an AttoParsec on Data.Text?
20:55:15 <Cale> You can click on the previous version and those docs are present
20:55:31 <Cale> (though it's true that it can be frustrating to wait)
20:55:33 <jmcarthur> DigitalKiwi: i got tried of tinkering. it worked the first time under ubuntu
20:55:48 <jmcarthur> i love arch, but xbmc is designed specifically for ubuntu
20:56:13 <dmead> Cale,  i'm not seeing them
20:56:23 <Cale> http://hackage.haskell.org/package/attoparsec-0.7.2
20:56:41 <Cale> The "Versions" field at the top lists the versions
20:57:06 <Cale> and then near the bottom, you see a list of modules, which are links to documentation
20:57:35 <Cale> You know, I think it might be nice for the cabal sdist command to build the documentation, even though that's a little strange, since then when the package is uploaded to Hackage, it could simply put that documentation up.
20:57:38 <dmead> ah, so i'm dumb
20:57:39 <dmead> gotcha
21:01:32 <scutigera> Polnomial a = [a]; can I define and instance of show (without using newtype or data decl) ?
21:02:00 <scutigera> I mean ; type Polynomial a = [a]
21:02:05 <ezyang> scutigera: No.
21:02:14 <ezyang> The compiler doesn't differentiate between Polynomial and []
21:02:30 <ezyang> (except in some strange ways in error message construction that I don't understand :-)
21:03:11 <scutigera> that's what I suspected.  so I declared a newtype, then the problem is that, for recursive calls  I have to do (Polynomial (x:xs) everywhere...
21:03:41 <DBAlex> *Main> fmap (filter (\x -> (take 7 x) == "http://")) $ fmap getLinks $ getURLHTML "http://google.com"
21:03:41 <DBAlex> ["http://images.google.co.uk/imghp?hl=en&tab=wi","http://video.google.co.uk/?hl=en&tab=wv","http://maps.google.co.uk/map
21:03:41 <DBAlex> s?hl=en&tab=wl","http://news.google.co.uk/nwshp?hl=en&tab=wn","http://www.google.co.uk/prdhp?hl=en&tab=wf","http://mail.
21:03:41 <DBAlex> google.com/mail/?hl=en&tab=wm","http://www.google.co.uk/intl/en/options/"]
21:03:43 <DBAlex> yay :)
21:04:18 <DBAlex> Cale: I'm considering TagSoup though
21:04:19 <ezyang> scutigiera: Sure.
21:04:28 <DBAlex> especially now I have Cabal set up properly :-)
21:04:36 <DBAlex> now I can have gtk2hs on XP too
21:04:55 <scutigera> just write fun (Polynomial ls) = loop (x:xs) = ... ; or is there some other syntactic short-cut ?
21:05:45 <ezyang> Could you post some sample code that's making you itch?
21:06:06 <ezyang> I usually am ok with the wrapping and unwrapping; pattern matching makes this mostly not irksome
21:06:42 <scutigera> ezyang: I can post something as soon as I finish writing it :-) should be a few minutes.
21:17:22 <scutigera> ezyang: http://www.unsafecoerce.com/fastcgi/hpaste.fcgi/view?id=8524#a8524
21:17:44 <scutigera> it doesn't compile, can't quite figure out what to do.  it's messy !
21:17:49 <djahandarie> I don't get why growingElements is written the way it is in quickCheck
21:18:16 <djahandarie> The bigger the list, the LESS trials required to cover the whole list
21:18:19 <ezyang> scutigera: You need another Polynomial constructor on the recursive case.
21:18:33 <djahandarie> It is log while I'd expect an exp
21:18:51 <scutigera> ezyang: yep- tried that. didn't work. I'm missing something...
21:19:08 <ezyang> imo, there's nothing really wrong with that code. If Polynomial is a bit long you could always make shorter name for it
21:19:15 <ezyang> scutigera: Did you make sure precedence was correct?
21:19:20 <ezyang> Pasting your error might also help
21:19:46 <djahandarie> > let log' = round . log . fromIntegral in (\n -> (log' n + 1) * 100 `div` log' 100) 200
21:19:47 <lambdabot>   120
21:20:03 <djahandarie> So it'd take 120 elements from a 100 element list after 200 trials
21:20:11 <djahandarie> > let log' = round . log . fromIntegral in (\n -> (log' n + 1) * 1000 `div` log' 100) 200
21:20:12 <lambdabot>   1200
21:20:19 <scutigera> ezyang: ok -did that.
21:20:24 <djahandarie> Oh bad examples with powers of 10 lol
21:20:47 <djahandarie> > let log' = round . log . fromIntegral in (\n -> (log' n + 1) * 20 `div` log' 100) 50
21:20:48 <lambdabot>   20
21:20:49 <scutigera> ezyang: duh, I'm trying to cons a Poly.
21:21:04 <djahandarie> > let log' = round . log . fromIntegral in (\n -> (log' n + 1) * 890 `div` log' 100) 50
21:21:05 <lambdabot>   890
21:21:10 <djahandarie> Gah
21:21:12 <djahandarie> > let log' = round . log . fromIntegral in (\n -> (log' n + 1) * 890 `div` log' 100) 10
21:21:14 <lambdabot>   534
21:21:23 <djahandarie> > let log' = round . log . fromIntegral in (\n -> (log' n + 1) * 20 `div` log' 100) 10
21:21:25 <lambdabot>   12
21:21:27 <scutigera> ezyang: won't work. need a top level decl to unwrap poly and then use an "unPoly" helper that works on regular list.
21:21:29 <djahandarie> Whatever
21:21:33 <ezyang> scutigiera: That too :-)
21:21:34 <djahandarie> It is dumb. QED
21:21:57 <ezyang> scutigiera: One possibility is to move the actual recursion into a helper function with where
21:21:59 <Gracenotes> @vixen Are you open to private messages?
21:21:59 <lambdabot> i just turned 19
21:22:11 <ezyang> You could also write out the function for lists, and then lift it into polynomial context
21:22:13 <Gracenotes> lambdabot said it accepts queries out of the channel
21:22:31 <ezyang> lambdabot: Happy birthday!
21:22:33 <uorygl> So, I feel like one of my skills is turning vague goals into detailed plans.  I've familiarized myself with various random tools, and so given a task like "calculate a user's credit limit based on borrowing history and other traits", I can come up with a detailed method for doing that.
21:22:56 <scutigera> ezyang: oooh. tell me more about the lifting, example ?
21:22:58 <djahandarie> I don't even know what the point of explaining this to anyone way, not like anyone can update QuickCheck code in here :P
21:23:07 * hackagebot has 0.2.1 - Pliant data types and functions  http://hackage.haskell.org/package/has-0.2.1 (YusakuHashimoto)
21:23:22 <ezyang> scutigiera: I'm sort of abusing vocabulary. Sort of.
21:23:31 <uorygl> So it seems like I'm destined to do progamming work.  The thing is, I'm really bad at taking those detailed plans and executing them.  I can have a program feel fully formed in my head, and yet not a single line of code.
21:23:47 <ezyang> basically, the type of the function I'm thinking of is ([a] -> [a] -> [a]) -> Polynomial a -> Polynomial a -> Polynomial a
21:23:58 <SamB_XP> uorygl: start with the types!
21:25:49 <uorygl> It seems like I tend to get hung up when I take certain detailed steps and try to implement them.  Suppose I have this: "Present a web interface with six pages, with this page displaying this content, etc."
21:26:20 <ezyang> uorygl: The best remedy I've found is to always have something working as soon as possible
21:26:26 <uorygl> In attempting to implement that, I go look at Happstack, figuring Happstack is the solution to my problem, and I start reading the tutorial, and soon I get bored and stop.
21:26:39 <ezyang> it's a positive self-reinforcement loop
21:26:52 <ezyang> But I also know from having friends who have the same problem you describe that putting this in practice is hard.
21:27:15 <SamB_XP> how does he deal with the "get bored and stop" issue ?
21:27:21 <scutigera> ezyang: ok take a look at the latest.  I like it. what do you think ?
21:27:32 <ezyang> SamB_XP: That's where the "oh man, I have something working" comes in :-)
21:27:56 <ezyang> If you don't get a kick out of that, drop programming and go become a professional sailboat racer or something
21:28:05 <ezyang> "I get no kick out of champagne..."
21:28:09 <uorygl> So, what should I do?  Work on the back-end first?  Make a simple and ugly but functional front-end first?  Figure out how to make a pretty front-end first?
21:28:32 <SamB_XP> uorygl: simple and ugly, sure!
21:28:37 <ezyang> uorygl: Do you get a kick when you create something pretty or nonfunctional? This is not true for me, but I'm not a graphics designer :-)
21:28:41 <ezyang> *and
21:29:16 <uorygl> I guess the thing is, the front end isn't the only place where I would have to learn something before being able to proceed.
21:29:20 <SamB_XP> do you know I hate the way everyone feels like they've got to make their websites "pretty"?
21:29:31 <SamB_XP> I wish they would just make them navigable, often ...
21:29:47 <uorygl> It's not obvious how I would store stuff in a database.
21:30:05 <ezyang> uorygl: In the case of Happstack, you'd use MACID
21:30:29 <uorygl> SamB_XP: I imagine this ugly front-end as not even being a web site, but rather a CLI or something.
21:30:43 <ezyang> uorygl: Sure. I find command line parsing obnoxious
21:31:36 <copumpkin> wow, deriving sure doesn't like NoImplicitPrelude
21:31:57 <scutigera> how do I make a "generic" 0.0, i.e. something that satisfies Num a ?? e.g. Num a => a -> a ; add0 x = x + 0.0
21:32:00 <SamB_XP> should it ?
21:32:10 <copumpkin> SamB_XP: gives a bunch of unexpected errors
21:32:35 <uorygl> If someone tells me, "Use this component!", I have to figure out how to use that component.  I don't really want to do that.
21:32:35 <SamB_XP> copumpkin: maybe we should revoke your GHC hacking license!
21:32:43 <uorygl> scutigera: it sounds like 0 is the 0.0 you're looking for.
21:32:51 <SamB_XP> uorygl: go do it!
21:32:52 <uorygl> @type let add0 x = x + 0 in add0
21:32:53 <lambdabot> forall a. (Num a) => a -> a
21:33:06 <copumpkin> :(
21:33:09 <SamB_XP> uorygl: before I send you a copy of J2EE
21:33:44 <uorygl> SamB_XP: in the past, I have spent entire days trying and failing to figure out how to utilize components.
21:33:52 <scutigera> uorygl: yes it was.  I was using 0.0 and getting an undecipherable error message about Fractional
21:33:57 <SamB_XP> uorygl: don't use that word
21:33:59 <scutigera> uorygl: thanks !
21:34:06 <ezyang> ==SamB_XP
21:34:24 <uorygl> In the morning, I discover Unix domain sockets.  In the evening, I still have no idea how to write code that uses them.
21:34:30 <uorygl> SamB_XP: "components"?
21:34:33 <SamB_XP> uorygl: oh, me either
21:34:36 <SamB_XP> uorygl: "utilize"
21:34:39 <SamB_XP> just say "use"
21:34:43 * uorygl nods.
21:35:04 <uorygl> I still don't know how to leverage components.  :P
21:35:12 <SamB_XP> argh!!!
21:35:20 <SamB_XP> there you go with that suit-ese again!
21:35:27 <uorygl> Leverage.  What a strange word.
21:35:38 <copumpkin> how are you supposed to write numeric constants with NoImplicitPrelude? ones that don't jump through my custom fromInteger, that is
21:35:50 <SamB_XP> copumpkin: hehehehe
21:35:55 <copumpkin> must I make 0# and stuff?
21:36:14 <uorygl> SamB_XP: when you say "me either", are you talking specifically about Unix domain sockets?
21:36:17 <SamB_XP> I think you're expected to be building the normal Prelude ;-P
21:36:26 <SamB_XP> uorygl: indeed
21:36:26 <copumpkin> SamB_XP: it's a LANGUAGE pragma
21:36:35 <SamB_XP> I haven't the slightest idea how to use them
21:36:47 <copumpkin> they're pretty straightforward
21:37:05 <SamB_XP> yeah, I guess I just never had any reason to want to use them?
21:37:46 <SamB_XP> I only know enough to recognize them lying about in /tmp, basically
21:38:09 <DBAlex> Oh nice
21:38:16 <DBAlex> I just realised I can clear the screen from ghci
21:38:19 <DBAlex> :!cls
21:38:20 <DBAlex> :D
21:38:42 <uorygl> Perhaps I could sort of make a diagram of my application, understand the functionality of each external component, and leave very precisely-shaped holes that hopefully can be filled in easily.
21:38:46 <copumpkin> tried to sneak past it with n + k patterns
21:38:47 <copumpkin> but failed
21:38:53 <uorygl> You can run GHCi from GHCi! :!ghci
21:39:13 <SamB_XP> uorygl: so you can hazkell while you hazkell?
21:39:31 <uorygl> Yo dawg, I herd you like... no, never mind.
21:40:01 <SamB_XP> oh, are you supposed to start with "I heard you like" when you do that kind of joke ?
21:40:17 <SamB_XP> @quote I heard you like
21:40:17 <lambdabot> No quotes match. You untyped fool!
21:40:22 <SamB_XP> @quote heard you like
21:40:22 <lambdabot> No quotes for this person. Take a stress pill and think things over.
21:40:31 <SamB_XP> @quote heard.you
21:40:31 <lambdabot> chrisdone says: yo dawg we heard you like haskell so we installed a lambdabot in your ghci so you can monad while you monad
21:40:59 <SamB_XP> @quote while.you
21:40:59 <lambdabot> pjdelport says: YO DAWG I HERD YOU LIKE CARS SO WE PUT A PAIR IN YO CAR SO YOU CAN CAR WHILE YOU CAR
21:41:00 <uorygl> @quote herd you
21:41:00 <lambdabot> No quotes for this person.
21:41:11 <uorygl> @quote herd.you
21:41:11 <lambdabot> pjdelport says: YO DAWG I HERD YOU LIKE CARS SO WE PUT A PAIR IN YO CAR SO YOU CAN CAR WHILE YOU CAR
21:41:22 <SamB_XP> @quote while.you
21:41:22 <lambdabot> chrisdone says: yo dawg we heard you like haskell so we installed a lambdabot in your ghci so you can monad while you monad
21:41:26 <SamB_XP> @quote while.you
21:41:26 <lambdabot> pjdelport says: YO DAWG I HERD YOU LIKE CARS SO WE PUT A PAIR IN YO CAR SO YOU CAN CAR WHILE YOU CAR
21:41:31 <SamB_XP> hmm, is that it then ?
21:42:57 <uorygl> The original is something like this: "Yo dawg I herd you like cars so we put a car in your car so you can drive while you drive!"
21:43:14 <copumpkin> any no implicit prelude experts around?
21:44:00 <copumpkin> I really don't want to have to drop down to GHC.* and MagicHash to get number literals...
21:44:14 <SamB_XP> copumpkin: hmm, I suppose if you make your typeclass defer to Prelude.fromInteger in some cases, it should be okay?
21:44:27 <copumpkin> I don't have fromInteger in a typeclass
21:44:40 <copumpkin> I could, but I'd prefer not to
21:44:44 <copumpkin> I guess I'll just do that
21:44:44 <DBAlex> *Main> fmap (fileType "html") $ fmap httpLinks $ fmap getLinks $ getURLHTML "http://news.bbc.co.uk/"
21:44:45 <DBAlex> ["http://www.w3.org/1999/xhtml","http://www.bbc.co.uk/accessibility/accesskeys/keys.shtml","http://www.bbc.co.uk/blogs/h
21:44:45 <DBAlex> aveyoursay/2010/03/does_the_uk_need_less_graduate.html","http://www.bbc.co.uk/blogs/haveyoursay/2010/03/does_the_uk_need
21:44:45 <DBAlex> _less_graduate.html"]
21:44:48 <DBAlex> yay :-)
21:44:58 <DBAlex> Now ban me for spamming... ;-)
21:45:07 <DBAlex> copumpkin: it works, it works!
21:45:07 <SamB_XP> copumpkin: you have one that isn't ?
21:45:16 <copumpkin> great :)
21:45:19 <copumpkin> SamB_XP: ?
21:45:30 <DBAlex> and Cale and jmcarthur
21:45:32 <DBAlex> :P
21:45:44 * uorygl grabs a sheet of paper and begins scribbling.
21:45:50 <SamB_XP> a non-classed fromInteger ?
21:46:05 <copumpkin> well I put it in a class now
21:46:10 <copumpkin> fixed it
21:46:50 <DBAlex> SamB_XP: Yo dawg, I herd you like lambdas...
21:46:51 <DBAlex> :P
21:47:06 <uorygl> User interface, protocol, back end, database, Agda...
21:47:10 * DBAlex didn't get why no one did that
21:47:13 <SamB_XP> so you put a lambda in my lambda so I can curry ?
21:47:13 <uorygl> (Which of those five does not belong?)
21:47:21 <DBAlex> SamB_XP: yep!
21:47:34 <SamB_XP> mmm, delicious curry!
21:47:38 <ezyang> uorygl: What's the biggest application you've written from start to finish to date?
21:47:48 <DBAlex> I put a lambda in your lambda so you can curry while you curry...
21:48:02 <DBAlex> ofc!
21:48:10 <SamB_XP> DBAlex: don't you need three lambdas for that ?
21:48:11 <copumpkin> wtf
21:48:12 <copumpkin> *Main> :t 2
21:48:12 <copumpkin> 2 :: (P.Num t) => t
21:48:14 <uorygl> ezyang: probably something like an Unlambda interpreter.
21:48:18 <ezyang> "I'd like curry with a side of lambda"
21:48:33 <DBAlex> SamB_XP: true, but the meme isn't complete without it
21:48:40 <SamB_XP> ezyang: no, no, the sugar lambdas are for desert!
21:48:40 <ezyang> uorygl: Ok. So something equivalent to ~large scale algorithm
21:48:42 * DBAlex can't think of one for monads
21:48:46 <uorygl> ezyang: yeah.
21:48:48 <DBAlex> I don't think it exists..
21:49:04 <ezyang> uorygl: Systems programming is a bit of different flavor
21:49:15 <SamB_XP> I put a monad in your monad so you can bind while you bind
21:49:20 <ezyang> uorygl: Blasphemer I am, I don't think you should do your first foray in Haskell
21:49:23 <SamB_XP> and I don't think I'm the one who came up with that, either
21:49:35 <DBAlex> nice
21:49:36 <DBAlex> :P
21:49:37 <uorygl> Yo dawg, I herd you like functors so we put a left adjoint functor in yo right adjoint functor so you can fmap while you fmap.
21:49:49 <DBAlex> lol
21:49:59 <SamB_XP> uorygl: I've no idea what that means, but lol anyway
21:50:13 <DBAlex> *Main> fmap (fileType "html") $ fmap httpLinks $ fmap getLinks $ getURLHTML "http://news.bbc.co.uk/"
21:50:13 <DBAlex> ["http://www.w3.org/1999/xhtml","http://www.bbc.co.uk/accessibility/accesskeys/keys.shtml","http://www.bbc.co.uk/blogs/h
21:50:13 <DBAlex> aveyoursay/2010/03/does_the_uk_need_less_graduate.html","http://www.bbc.co.uk/blogs/haveyoursay/2010/03/does_the_uk_need
21:50:13 <DBAlex> _less_graduate.html"]
21:50:17 <DBAlex> SamB_XP: ^^
21:50:45 <Dementati> Yo dawg, I herd you like functions so we put a lambda in yo expression so you can apply while you define. <- How about that one?
21:50:56 <DBAlex> kinda depressing links though
21:51:00 <copumpkin> confused: http://snapplr.com/0agt
21:51:01 <DBAlex> UK needs less graduates apparently
21:51:08 <DBAlex> ... -_-
21:51:15 <DBAlex> possibly just usual BBC moaning though
21:51:42 <DBAlex> so they charge us more in tuition fees, cut spending, then tell us were not needed -_-
21:51:58 <uorygl> ezyang: any idea what I should do my first foray in?
21:52:07 <DBAlex> uorygl: web scraper!
21:52:22 <ezyang> uorygl: It depends on which system you want to learn first.
21:52:24 <uorygl> That's a programming language now?
21:52:37 <DBAlex> uorygl: what are you interested in?
21:52:47 <DBAlex> I want to do breakout in Haskell
21:52:49 <DBAlex> do that...
21:52:50 <uorygl> I'm interested in creating this application.  :P
21:52:56 <DBAlex> lookup SDL bindings on hackage
21:53:05 <copumpkin> any ideas?
21:53:06 <ezyang> uorygl: Ah, the one you initially mentioned
21:53:25 <DBAlex> probably any small project would be good
21:53:40 <DBAlex> something with AI could be good and challenging
21:53:45 <ezyang> copumpkin: peeking, but not optimistic
21:54:02 <DBAlex> uorygl: whats the app?
21:54:07 <ezyang> copumpking: oh, delicious >.>
21:54:13 <copumpkin> oh
21:54:18 <copumpkin> it's a ghci thing
21:54:24 <copumpkin> it ignores NoImplicitPrelude if it's in the loaded file
21:54:27 <ezyang> uorygl: PHP.
21:54:32 <ezyang> And I'm being completely earnest
21:54:46 <uorygl> The app is a peer-to-peer prediction market theorem verifier thing.
21:54:53 <ezyang> it is singularly good at getting the bullshit "you need to level up N times" to do something at all
21:54:57 <ezyang> eliminated
21:55:28 <ezyang> It'll also teach you how horrible languages can be, but give you an appreciation for a language that lets you use as much duct tape as you want
21:56:14 <ezyang> Pythonistas dream of making their applications as easy to deploy as PHP applications
21:56:17 * hackagebot powerpc 0.0.1 - Tools for PowerPC programs.  http://hackage.haskell.org/package/powerpc-0.0.1 (TomHawkins)
21:56:39 <ezyang> I'll shut my trap now :-)
22:01:12 * ezyang hopes he didn't kill the chan >.> 
22:03:54 <DBAlex> pythonistas? hahaha
22:03:55 * uorygl clutches at his chest.
22:04:06 * uorygl uses his last ounce of strength to point at ezyang.
22:04:20 <DBAlex> PHP sux, no need to learn it
22:04:36 <DBAlex> uorygl: if you don't know a programming language yet start with Python
22:04:41 <DBAlex> then Haskell...
22:04:45 <DBAlex> why wait
22:04:52 <uorygl> Don't worry, I know Haskell.
22:05:28 <ezyang> PHP might be a little over the top. The point I was actually trying to make was pick technologies that are easy to deploy and easy to get started on.
22:05:43 <ezyang> and don't worry too much about whether or not it's The Right Way
22:06:08 * jmcarthur implements Unboxed for vector-static is a more sane way
22:06:08 <ezyang> you're not in it for the resulting software, you're in it for the experiences putting together complicated components and making the whole thing run
22:06:29 * jmcarthur tries, anyway
22:07:41 <uorygl> I sort of wish I could just tell someone else to do that.
22:08:04 <ezyang> uorygl: Sometimes you can :-)
22:08:42 <ivanm> Axman6: well, I'm back from tutoring, but I figure I'll go home rather than help you argue with Cale ;-)
22:14:38 <uorygl> I sort of wonder if I could simply write a fully detailed description of how this works and hope someone else finds it interesting enough to implement.
22:15:41 <uorygl> Perhaps life doesn't work that way; maybe it is about fussing over the details more than coming up with plans.
22:19:26 <dmead> uorygl, oh the dreams of open source
22:20:30 <uorygl> :)
22:21:35 <ezyang> uorygl: This hit #2 on Y combinator today: http://www.johndiesattheend.com/updates/?p=1071
22:21:58 <ezyang> it might be interesting reading
22:22:01 <uorygl> Well, then, I'm off to become a geologist.  Bye!
22:22:04 <uorygl> :P
22:23:23 <Gracenotes> farewell
22:23:54 <Gracenotes> though it is a rocky journey, may you unearth many facets of geological inquiry
22:30:59 <roboshibby> ey guys, why do people say the new milenium started in 2001 not 2000
22:31:18 <ezyang> roboshibby; because there was no year "0"
22:31:44 <roboshibby> says who?
22:31:57 <roboshibby> there was no day 0 either
22:32:10 <ezyang> Wikipedia! http://en.wikipedia.org/wiki/Year_0
22:32:26 <ezyang> our year numbering system is fairly arbitrary :-)
22:32:45 <uorygl> Says the people who defined B.C.
22:32:58 <roboshibby> oh
22:36:31 <shapr> roboshibby: Are you learning Haskell?
22:37:15 <roboshibby> yes
22:37:27 <sinelaw> will dependent typing be any easier to implement if it only allows integer dependencies?
22:37:31 <shapr> roboshibby: What are writing at the moment?
22:38:17 <roboshibby> just learning the basics
22:38:30 <roboshibby> prime number calculator, etc. little things
22:38:49 <shapr> roboshibby: Got any questions about the code you're working on?
22:41:06 <uorygl> Hmm, I just realized that I recently read a paper that was a precise description of the behavior of a computer system, leaving all the ugly stuff up to the implementors.
22:41:29 <roboshibby> uorygl: url?
22:41:33 <roboshibby> shapr, no, but thank you!
22:41:39 <roboshibby> ill take a rain check on that
22:41:46 <shapr> sure
22:41:57 <roboshibby> shapr, how long have you been programming with haskell?
22:42:14 <shapr> hm... nearly nine years.
22:42:18 <roboshibby> whoa
22:42:23 <roboshibby> you must be a master
22:42:27 <uorygl> http://google.com/search?q=decentralized+currency
22:42:36 <shapr> I know some stuff, but there's still a lot to learn.
22:42:46 <roboshibby> uorygl: ?
22:42:51 <sinelaw> roboshibby, he only founded this channel, nothing major.
22:42:59 <uorygl> That search page will yield lots of links to one paper.
22:43:06 <shapr> Yeah, I did start #haskell
22:43:11 <uorygl> "Off-line Karma: A Decentralized Currency for Peer-to-peer and Grid Applications"
22:43:16 <shapr> Not sure I'm famous for anything else though :-)
22:43:37 <sinelaw> like michael collins (of apollo 11) said: "famous for being famous"
22:43:39 <uorygl> Looks like it was written by two people at an Institute for Computing and Information Science.
22:43:46 <sinelaw> but in your case, it's more than that :)
22:43:55 <shapr> uorygl: Is there a Haskell implementation? :-)
22:44:08 <shapr> sinelaw: Um, working on lambdabot?
22:44:12 <uorygl> As far as I know, there's no implementation at all.
22:44:53 <roboshibby> shapr, nice work
22:45:07 <roboshibby> irc was still pretty decent back in 2001
22:45:19 <uorygl> @get-shapr
22:45:19 <lambdabot> shapr!!
22:45:26 <uorygl> shapr will be forever immortalized in that command.
22:45:29 <shapr> You called?
22:45:38 <shapr> roboshibby: heh, I started on irc in 1989 :-)
22:45:52 <roboshibby> that definitely predates my '96
22:46:26 <sinelaw> in '89 i was in elementary school
22:47:04 <roboshibby> shapr, which other languages do you know?
22:47:18 <uorygl> In '89, I was cleft in twain.
22:47:40 <sinelaw> uorygl, what?
22:47:45 <uorygl> I would not be junct until around January or February of 1992.
22:48:35 <shapr> roboshibby: Um, several... I've been paid to write Haskell, VB, Python, Java and C# at least. Nothing else commercial, but I've written a lot of other languages for fun.
22:48:56 <roboshibby> nice
22:48:56 <shapr> roboshibby: What about you? What languages do you know?
22:49:03 <sinelaw> Haskell, VB, ... wait what?
22:49:08 <roboshibby> php back in the day, ruby and objc recently
22:49:47 <sinelaw> shapr so VB is your favorite, eh?
22:49:55 <shapr> Um, no.
22:50:06 <shapr> That was a random ordering.
22:50:10 <sinelaw> type inference!
22:50:12 <sinelaw> :P
22:50:44 <shapr> I have written VB3 and VB.net for .NET 3.5 though, quite a range of years...
22:51:00 <shapr> roboshibby: So what brought you to #haskell?
22:51:10 <roboshibby> shapr, the learning of haskell
22:51:18 <shapr> Well, yeah.. but what got you interested in Haskell?
22:52:53 <roboshibby> i wanted to pick up one of the mathy languages
22:53:00 <roboshibby> something very different
22:53:03 <copumpkin> coq!
22:53:04 <copumpkin> :P
22:53:31 <sinelaw> eternally a bad name
22:53:57 <roboshibby> copumpkin: #haskell-blah is that way.. ====>
22:54:12 <copumpkin> you're talking about mathy languages
22:54:14 <copumpkin> I suggested one
22:54:37 <elly> agda!
22:54:40 <copumpkin> yay
22:56:24 <shapr> roboshibby: So, what do you think so far?
22:57:05 <roboshibby> it's.. different. im treating it like a relationship that'll grow slowly over time vs trying to 'hurry up and learn it all'
22:57:17 <copumpkin> :)
22:57:38 <roboshibby> monads mesh with how my mind works naturally, though, which is nice
22:57:50 <CcSsNET> roboshibby ive been idling this chan for months. i learned like ehmm. nothing yet
22:57:58 <CcSsNET> XD
22:58:09 <roboshibby> hehe
22:58:14 <copumpkin> CcSsNET: knowledge doesn't "seep in" by idling, sadly :)
22:58:28 <CcSsNET> o yes i know. just saying this language is crazy
22:58:29 <copumpkin> at least not quickly
22:58:29 <CcSsNET> hehe
22:58:31 <roboshibby> alright guys, nice chatting. im gonna go get blazed
22:58:38 <roboshibby> toodles!
22:58:45 * roboshibby & reefer
22:59:38 <copumpkin> lol
23:01:04 * sinelaw doesn't understand the variant of English being spoken here today
23:02:01 <sinelaw> if this is English at all
23:04:06 <Dementati> copumpkin: I find it kind of does. It's not as focused as actually studying a single subject directly, but you learn small things about lots of subjects by idling.
23:04:48 <pikhq> Dementati: Knowledge only "seeps in" if you're learning a foreign language and idling in that language.
23:04:51 <pikhq> ;)
23:05:10 <Dementati> pikhq: Hah, I completely agree, except for the 'only'. =D
23:05:12 <Entroacceptor> pikhq: that's how children learn to speak
23:05:22 <tomberek> Alpounet: ping
23:05:36 <pikhq> Entroacceptor: And that's how one achieves high levels of proficiency in an L2.
23:05:51 <Dementati> pikhq: L2?
23:06:11 <pikhq> Dementati: Second language. Sorry. Talking to linguists too much.
23:06:34 <Dementati> pikhq: I guessed that, but I wasn't sure.
23:23:07 <Lycurgus> sinelaw, you must not be a native speaker, I am and see nothing amiss
23:27:00 <kian> Does anyone here have any experience with metamorphic programming?
23:27:41 <elly> if this were any other channel, I'd accuse you of having made that term up
23:30:45 <Lycurgus> maybe something with dynamic types. Zounds like fun, but not in a good way.
23:31:00 <sagelywizard> What's the difference between "->" and "=>"?
23:31:18 <sagelywizard> In reference to types, that is.
23:31:40 <tomberek> => comes after a class restriction
23:31:50 <tomberek> -> denotes a function
23:32:26 <sagelywizard> Thanks.
23:45:33 <kian> Sorry if someone answered my earlier question and I missed it, I was having trouble with my IRC client, so I don't mean to be rude in duplicating my question :  has anyone here had any experience with metamorphic programming? I'm trying to experiment a bit with some code written by martin erwig (ADT.hs and ADTlib.hs from http://web.engr.oregonstate.edu/~erwig/meta/), and I'm having a bit of trouble getting the rose trees to compile properly.
23:49:27 <tomberek> kain: sorry, don't know much about it
23:50:50 <tomberek> kian: sorry
23:51:09 <kian> It may be an issue that doesn't require any deep knowledge of the specifics of the library - when I attempt to compile it, I get the following type error: ADTlib.hs:205:55:
23:51:10 <kian>     Couldn't match expected type `[[a]]'
23:51:10 <kian>            against inferred type `Rose t -> [Rose t]'
23:51:10 <kian>     In the first argument of `concat', namely `kids'
23:51:11 <kian>     In the third argument of `toB', namely `(concat kids)'
23:51:11 <kian>     In the second argument of `ADT', namely
23:51:11 <kian>         `(toB null (fmap root) (concat kids))'
23:51:33 <kian> forest :: ADT (I [Rose a]) (Binary [a]) [Rose a]
23:51:33 <kian> forest =  ADT (fromI id) (toB null (fmap root) (concat kids))
23:51:38 <kian> from that piece of code
23:51:47 <Saizan> kian: don't paste code in channel, please
23:51:57 <tomberek> yeah, it's hard to read
23:51:58 <kian> My apologies, Saizan
23:52:03 <tomberek> hi Saizan
23:52:12 <tomberek> kian: put it in a pastebin and post the link
23:53:56 <Saizan> hi
23:54:52 <Trinitron> sieve (p : xs) = p : sieve [x | x <- xs, x `mod` p > 0]  What the heck does the sieve (p : xs) part mean?
23:55:20 <Trinitron> It's from Wikipedia.
23:55:20 <tomberek> Trinitron: it's a pattern match
23:55:49 <kian> Tomberek : I've never used pastebin before. Thanks for the tip. Here's the link http://pastebin.com/DVKMSQ3Z
23:55:52 <Saizan> kian: the code seems to assume Functor has a "map" method instead of a "fmap" one, maybe you've fixed that in other parts but not there?
23:56:09 <tomberek> it says that sieve of a list (a list which is a p and another list called xs) is equal to ....
23:56:10 <kian> Saizan: I fixed it there as well,
23:56:16 <tomberek> kian: one sec
23:56:54 <Trinitron> primes = sieve [2..]
23:56:55 <Trinitron>  sieve (p : xs) = p : sieve [x | x <- xs, x `mod` p > 0] is sieve a function or a variable?
23:57:07 <Trinitron> I thought varibles have to be on LHS.
23:57:10 <Trinitron> Like C
23:57:11 <Saizan> kian: ah, you removed map, rather than changing it, try this http://pastebin.com/4iGAnqPC
23:57:22 <fhein> anyone happen to have a link to a tutorial explaining how to implement a simple functional language interpreter in Haskell using call-by-name and closures? :)
23:57:51 <kian> ahh, i must have screwed up my find and replace :)
23:57:53 <kian> thank you
23:57:58 <Saizan> np :)
23:58:14 <kian> that worked
23:58:17 <kian> Perfectly :)
23:58:35 <Trinitron> primes = sieve [2..] I don't get the semantic of putting the word "sieve" there.
23:58:45 <fhein> or if anyone's interested.. here I've implemented call-by-value using closures but I'm trying to change it to call-by-name and now it fails: http://pastebin.com/C8EJ2JGN
23:59:11 <Trinitron> Oh sieve is a function, that is defined in the next line.
23:59:24 <Trinitron> I've got my imperative hat on.
