01:57:04 --- topic: '["Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]'
01:57:04 --- topic: set by glguy!~glguy@unaffiliated/glguy on [Sat Jan 30 19:06:07 2010]
01:57:04 --- names: list (clog miclorb therp fusion5 Xyzzy eevar2 silver trzkril m-i-l-a-1 shag cads Space nff danvet ttmrichter Volfram mexisme mreggen Walt kamatsu kisvoros d0ugal kqrx cjs wisemanby Argue_ jejansse Mowah maxter jeltsch bens snorble melanson perspectival pao takuan Alpounet mwc ttvd tommd execve SColes cp2 SubStack dino- htoothrot hackagebot Mathnerd314 Anoq gonsor Taejo trin_cz NULL_PTR enthymene m3ga Athas c_wraith ttt-- fmardini derrida shintah FliPPeh FliPPeh__)
01:57:04 --- names: list (chrissbx al-maisan ablokzijl EvanR raymonvw_ lowasser mail dolio tps_ philo portnov lyndon znutar AtnNn drwho harrison kniu novas0x2a applicative josephholsten cdrz adu Glert kermit drbean triplez kadoban Philonous1 otto_s_ migge felzix DigitalKiwi otulp tensorpudding Nereid_ tehgeekmeister cdsmithus ray phnglui Bobrobyn kfish jinjing ddarius Lycurgus gogonkt amiri QinGW Cthulhon|| cying tilman OnionKnight jao chowder orlandu63 dropdrive Nshag pheaver)
01:57:04 --- names: list (psykotic theorbtwo saccade_ Ytinasni sioraiocht cheater2 `0660 eevar_ nanothief Amadiro desu regalia jleedev hazridi kmc scm Peaker dreixel fonz Elench sbahra augur dancor cozmic caligula_ horms opqdonut quetzal- mysmysery nagnatron ksf ville waterlaz aluink erikc mun_ Poeir flori TR2N Jaak Wolong wolverian greap Saizan sjanssen jmv shrughes megaTherion danblick s76_ [|] palmje preflex Eghie mauke TacticalGrace noam kpreid metaperl stenobot2010 etpace ts33kr)
01:57:04 --- names: list (nominolo ps-auxw solidsnack ehamberg canvon shutdown_-h_now dqd mm_freak_ xinming_ nieppa _sh3 geir_ voker57 aconbere jsgf potatishandlarn Gracenotes Spockz|lap Raadad22 jbauman alexsuraci amuck Apocalisp langtree hsaliak Colours oklopol og01 creichen sagelywizard thetallguy u_quark ozamosi tomoj PsiOmega Desustorm Axman6 tltstc BONUS JaffaCake zygoloid paolino Pewpewarrows glith mfoemmel joed systemfault gbacon Cale Polarina ahlmal Philippa CalJohn shepheb)
01:57:04 --- names: list (suiside niksnut luite OscZA kw317 karld SpaghettiMonster sfuentes nornagon jvoorhis dfeuer shawn_ dons helgikrs michael| mfp Tophan twink dju danderson dionoea DrSyzygy Adamant p_l eintopf nathanic_work avenge` [swift] pshc_ roboshibby araujo ben Mr_Awesome kaol a11235 rt7 VeXocide Ornedan SamB_XP zhijie raxas Blub\0 idnar jonafan lament Augur_ igorgue lambdabot andrewsw djahandarie lostlogic SimonRC mikste rtaycher Igloo mog tumult BrianHV djinni clanehin)
01:57:04 --- names: list (dcolish bbee Counter-Strike StoneToad Milo- thingwath CosmicRay dual cognominal stepcut stepnem lispy pikhq lefant EvanR-work The_third_man sshc bnjmn periodic welterde oddraisin amuller arw iizuka ClaudiusMaximus boyscared Megant sm absentia ned lomeo jontore zax sebbe1991 joga liesen Sagi felipe_ monochrom alexbobp qwr byorgey dobie_gillis Innominate wto anders^^ MoALTz muep noreply_ ido Boohbah dogmaT FauxFaux bremner_ freedrull wagle EvanCarroll)
01:57:04 --- names: list (nostrand^^ goldegg nimred khiroc det kwinz gds Stephan202 mercury^ mux noj blackdog ahf cjay cebewee koala_man mjrosenb ahihi jlaire ikonia __marius__ Veinor cyanoacry jmtd ezyang kosmikus PepeSilvia willb joni6128 Twigathy geekagen1 woggle MarcWeber taruti noddy MisterN gbeshers Entroacceptor nicolai dMazzz Zeiris Tinned_Tuna companion_square int-e Feuerbach eagletmt walrus Twey newsham orbitz sorrofix emma Botje ski saccade jamwt And[y] strobedream)
01:57:04 --- names: list (neurogeek BeZerk MadX` companion_cube samulihs sohum profmakx HandheldPenguin Arnar mokus tew88 elly StarFire shortcircuit thoughtpolice eek Laney mrshoe eelco epokal dayz Bassetts kynky harlekin lsthemes jd10 uorygl flux Boney fritschy ziman birkenfeld eno ksandstr mmmdonuts PHO_ Nanar mornfall TML MacCoaster ybit thetallguy1 hiredman Jiten digy te dixie lostman thorkilnaur_ jql burp edwinb MrDomino^ poucet regulate deavid nniro Ferdirand liff eldragon)
01:57:04 --- names: list (moshisushi savonarola cYmen m4thrick zsol ctjv cods agemo npouillard helino avenge Paks stroan revertTS AnMaster Khisanth dcoutts dmwit kolmodin jmcarthur kloeri Bleadof quicksilver baaba oeblink fabjan M| astrocub notrael Taggnostr radhermit termos michie1 drd tromp_ QtPlatypus srcerer xerox kar-1 Deewiant mq KatrinaTheLamia nothingmuch mullein mrothe Nereid brtk Edu_ Zao fihi09 jml mietek mmmulani drhodes albertosantini mdordal2 AndyP ve bran laz0r)
01:57:04 --- names: list (keseldude untwisted majoh Lemmih davidL dufflebunk mml` kennethd galdor shrimpx nwf codemac McManiaC bolmar bjorkintosh bwr levitation[A] guerrilla b4taylor integral fnordus @ChanServ allbery_b sproingie _br_ smiler inimino impl Vulpyne dilinger Paradox924X theclaw pastorn nlogax kalven yahooooo ennen tmug timchen1` Baughn jlouis olsner dumael duairc wdonnelly go|dfish netcat c9s kevinclark saurik aleator \yrlnry tafryn endojelly jix Becquerel alios tomaw)
01:57:04 --- names: list (aiko_ chromakode sbok hugin edwtjo anekos saiam emias DustyDingo encryptio Reisen ibt Ke aavogt alip epmf jvogel beatmox alexsdutton gereedy bd_ tamiko Exteris Gabbie hellige jrockway Gilly nuba Liskni_si osfameron Dementati Aisling benmachine Raku^ icee Heffalump mwoz amxx Tomas pettter matthew-_ ToRA clarkb Hunner koninkje_away jayne deadguys mrd skaar Dephyrial dejones mlh o-_-o Sisu slabanja ath shachaf ibid Vq Valodim mattam)
01:57:15 <kmc> tomoj, there's also HUnit
01:57:18 <ksf> is it passing in bleeding [()]?
01:57:22 <c_wraith> yes
01:57:23 <kmc> ksf, yes
01:57:39 <c_wraith> @check \xs -> xs == reverse (xs :: [Int])
01:57:40 <lambdabot>   "Falsifiable, after 2 tests:\n[-2,0]\n"
01:57:44 <kmc> Haskell isn't as heavily dependent on tests as some languages
01:57:50 <kmc> we like to get the program right statically
01:57:59 <tomoj> yeah
01:58:10 <c_wraith> HUnit is good when the tests involve IO.
01:58:21 <tomoj> do you mock out the IO?
01:58:24 <kmc> though Haskell's type system isn't powerful enough to do it perfectly
01:58:28 <cads> there's also quickcheck I believe
01:58:37 <ksf> quickcheck is good for invariants you didn't bother to express at the type level
01:58:48 <kmc> or can't
01:59:01 <ksf> kmc, beware, you're invoking oleg
01:59:21 <cads> tomoj: you're a rubyist?
01:59:28 <tomoj> I wonder how often you can combine free theorems with quickcheck invariants to be reasonably sure you've got the right function
01:59:33 <tomoj> cads: used to be
02:00:48 <cads> what brings you to haskell?
02:03:21 * ksf wonders about the downvotes for http://www.reddit.com/r/haskell_proposals/comments/bdbi5/make_haskell_run_on_the_appengine/
02:03:31 <kmc> ksf, heh
02:03:32 <jejansse> is there a haddock zip for the haskell-platform somewhere, containing all the haddock documentation?
02:03:51 <kmc> meh, run your haskell code on a real cloud hosting service
02:03:52 <tomoj> cads: clojure
02:04:26 <ksf> I'm too old for dynamically typed languages
02:04:39 <tomoj> yeah, someday I'd like to move to haskell
02:04:45 <tomoj> but I don't feel ready yet
02:05:26 <cads> tomoj: clojure's fun
02:06:08 <kmc> how does one come to Haskell by way of clojure?
02:09:18 <cads> kmc, functional programming and lazy streams are big in clojure
02:09:40 <kmc> they're big in ruby and python too
02:09:43 <cads> though they don't have stuff like type inferrence and ADTs, I think
02:10:11 <kmc> clojure is dynamically typed, so it wouldn't have inference as a language feature (implementations might, however, use it to generate better code)
02:10:22 <cads> I wonder how many pythonistas come to haskell
02:10:31 <cads> I came from ruby
02:10:40 <kmc> that seems to be a common route
02:10:49 <kmc> i don't remember which language i learned immediately before Haskell
02:11:23 <tomoj> kmc: functional programming in particular is much bigger in clojure
02:11:24 <kmc> or perhaps "started learning" because one is never really finished
02:11:34 <cads> lots of people that talk about those languages give haskell its dues, and it's easy to get curious about it
02:11:35 <tomoj> at least, persistent data structures
02:11:48 <tomoj> yeah
02:12:17 * cads thinks clojure is the most functional lisp since scheme
02:12:19 <eevar2> yup, clojure data structures are immutable, so FP is the only way to go, unlike ruby
02:12:41 <tehgeekmeister> i came from ruby too, but had heard of haskell a long time before that and it seemed strange and ridiculous, so i didn't try it.  wish i had tried it earlier now!
02:12:57 <kmc> yeah, i liked rich hickey's description of the persistent hash tries in clojure
02:13:06 <ksf> haskell has been my second language of choice, after perl. I basically just learned scheme because I read sicp
02:13:39 <cads> ksf, it's worth going through sicp, right?
02:13:46 <ksf> definitely
02:13:59 <ksf> ctm, too.
02:14:01 <kmc> my cynical view is that a lot of people mention Haskell in order to position their own language of choice as a more "practical" alternative
02:14:20 <ksf> another one is advanced programming language design
02:14:27 <ksf> there's pdf's of it somewhere on the net
02:14:35 <kmc> without addressing the actual features or lack thereof
02:14:41 <cads> ksf, are those three written by sussman/ableson?
02:14:50 <ksf> http://www.nondot.org/sabre/Mirrored/AdvProgLangDesign/
02:14:58 <cads> I've been rather interested in pierce's types and programming languages
02:15:04 <kmc> yay TaPL
02:15:05 <tomoj> I vaguely remember rich from clojure saying he just wanted a lisp
02:15:07 <ksf> npe ctm is the mozart/oz book
02:15:08 <kmc> you should also read his coq tutorial
02:15:36 <cads> man if pierce wrote it I will read it!
02:16:11 <ksf> for more scheme, there's the little schemer series
02:16:21 <ksf> the last one (iirc) is even co-authored by oleg
02:16:42 <kmc> http://www.cis.upenn.edu/~bcpierce/sf/
02:16:51 <cads> I read a few chapters of his 'category theory for computer science', amazing stuff that sadly swooped over my head after the third chapter
02:17:40 <ksf> oh I should try that tutorial again
02:17:47 <cads> is that the coq tutorial?
02:17:48 <ksf> last time, I got stick
02:18:02 <ksf> feels kinda like the lucas arts adventure times.
02:18:04 <ksf> *stuck
02:18:15 <ksf> yes, and it's great
02:18:45 <ski> ksf : the continuation-based "IO" language there is interesting
02:18:49 <ksf> coq has an abysmal terminal interface, though.
02:19:14 <kmc> yeah
02:19:16 <kmc> i use coqide
02:19:25 <ksf> ski, that's the place where I point people when they ask about continuations
02:19:58 <psykotic> ksf: proof general for emacs makes it nice.
02:20:01 <ski> (the nested loop construct is also nice)
02:20:09 <psykotic> well, niceR
02:20:11 <c_wraith> I wish xchat didn't color kmc and ksf the same. >_>
02:20:18 <cads> psykotic: does proofgeneral work with agda by any chance?
02:20:20 <ksf> nothing involving emacs can be truthfully described as "nice"
02:20:35 <Alpounet> c_wraith, same here !
02:20:37 * psykotic cracks knuckles and stares at ksf
02:20:47 <ivanm> preflex: seen Axman6
02:20:47 <preflex>  Axman6 was last seen on #haskell 2 hours, 33 minutes and 9 seconds ago, saying: i wish the cuda code was open, then i would have something to go off
02:21:05 <psykotic> cads: i didn't think agda had a proof assistant mode?
02:21:11 <psykotic> proof general is for interactive proof assistants
02:21:17 <ski> (ksf : lucas arts adventure times ?)
02:21:19 <ksf> > let hash = (% 9) . sum . ord in hash "kmc" == hash "ksf"
02:21:20 <lambdabot>   Couldn't match expected type `[a]'
02:21:20 <lambdabot>         against inferred type `GHC.Types...
02:21:29 <ksf> > let hash = map ((% 9) . sum . ord) in hash "kmc" == hash "ksf"
02:21:30 <lambdabot>   Couldn't match expected type `[a]'
02:21:30 <lambdabot>         against inferred type `GHC.Types...
02:21:36 <kmc> Agda has its own very fancy emacs mode
02:21:40 <ski> psykotic : for Agda1, there's Alfa
02:21:46 <ksf> > let hash = (% 9) . sum . map ord in hash "kmc" == hash "ksf"
02:21:47 <lambdabot>   False
02:21:52 <ksf> > let hash = (% 10) . sum . map ord in hash "kmc" == hash "ksf"
02:21:53 <lambdabot>   False
02:21:55 <kmc> Agda2 is maybe the sexiest programming language i've ever seen
02:21:55 <ksf> er
02:22:00 <ksf> how many colours?
02:22:15 <c_wraith> I have no clue.  whatever the defaults are
02:22:27 <ski> (16 or 32 or something, iirc)
02:22:31 <ksf> you should just stop using it.
02:22:34 <psykotic> tomoj: i didn't know you were here too. here, have some monads. http://gist.github.com/331761
02:22:45 <ksf> colouring, that is, not xchat
02:23:35 <ksf> ski, sitting half a day in front of the computer screen, not getting anywhere and returing a month later
02:23:58 <ski> psykotic : hm .. i suppose Clojure doesn't have any kind of hygienic macros ?
02:24:02 <ksf> those were, I remind y'all, after all pre-internet times.
02:24:04 <psykotic> ski: that's a good thing!
02:24:15 <ksf> no such thing as looking at a walkthrough.
02:24:31 <ksf> if you were lucky you could ask someone who had played it.
02:24:35 <ski> a non-hygienic (by-default) macro system is a bug
02:24:48 <cads> kmc, if I've got some basic informal proofs I've done, is it usually pretty hard to transcribe them to something like coq or agda?
02:24:55 <kmc> yes
02:24:59 <cads> Earlier tonight I showed cos(5a) = cos(a)^5 - 10*cos(a)^3*sin(a)^2 + 5*cos(a)*sin(a)^4, for example.
02:25:03 <kmc> proofs in Coq look nothing like normal informal proofs :/
02:25:12 <kmc> they are programs in a very ad-hoc imperative language for manipulating proof state
02:25:19 <psykotic> ski: clojure does something that makes the usual cases for hygeine look weak.
02:25:22 * ski thinks proof tactics are strange
02:25:32 <ski> psykotic : .. being ?
02:25:37 <psykotic> you still have to gensym, but there's no inadvertent capture, unless you want it to happen
02:25:43 <kmc> coq uses this ad-hoc imperative language to talk *about* a beautiful functional language
02:25:49 <ksf> Theorem foo = bar. Proof. WaveHands. Qed.
02:25:50 <psykotic> ski: symbols are resolved to vars (which live in namespaces) before macro expansion
02:26:14 <psykotic> the typical example of hygeine of redefining 'list' in scheme isn't a problem
02:26:18 <kmc> a proof is actually just a term in said functional language, whose type is the proposition to be proven (curry-howard isomorphism)
02:26:27 <psykotic> ski: anyway, too much to go into on this channel.
02:26:34 <tomoj> (plus, auto-gensyming)
02:26:39 <kmc> the imperative tactic language is a shorthand for building these terms, which are generally very large
02:26:49 <ski> psykotic : that to me sounds like (at least some) support for hygiene ..
02:26:49 <psykotic> tomoj: which is rarely useful, because it doesn't work across unquote/quote boundaries.
02:26:52 <cads> kmc - I see
02:27:06 <tomoj> psykotic: orly?
02:27:13 <cads> kmc: is agda's approach as pained?
02:27:35 <kmc> coq's approach is good for actually getting proofs done
02:27:43 <ski> cads : there's no tactics in agda -- you build the proof terms, themselves
02:27:47 <psykotic> tomoj: no.
02:27:49 <ksf> cads, coq is basically a dumb student who needs to be told what he should bruteforce.
02:28:01 <kmc> i don't know of any feature of agda that makes its proof terms smaller or simpler to construct than coq's
02:28:05 <kmc> but i don't know agda very well
02:28:12 <psykotic> ski: yes, but it isn't anything as horrible as what most people think of as hygeine in the scheme world.
02:28:22 <kmc> the coq designers think it's impractical to write out proof terms
02:28:29 <kmc> and hence put a lot of effort into their tactic system
02:28:43 * ski isn't sure what would be horrible with hygiene
02:29:22 <psykotic> ski: syntax-rules, syntax-case all suck.
02:29:38 <ksf> I'd like to see a middle-ground approach, where you give proof terms for the rough outline and tactics fill in the rest.
02:29:39 <psykotic> syntax-rules because it's taking me out of my wonderful programming language for dealing with lists
02:29:44 <psykotic> syntax-case because it's insanely complex
02:29:50 <cads> kmc: I get a scary feeling whenever I try to imagine what tactics might be, I imagine a terribly complicated pattern matching and transformation language like what I imagine underlies mathematica
02:29:57 <kmc> sort of yes
02:29:58 <ivanm> @tell Axman6 I believe you were going to send an email today...
02:29:58 <lambdabot> Consider it noted.
02:30:13 <kmc> they're not so hard to use
02:30:17 <harlekin> @pl \st a -> flip runStateT st (foo a)
02:30:17 <lambdabot> (. foo) . flip runStateT
02:30:17 <kmc> i imagine they're quite nasty to write
02:30:20 <ski> kmc : how much of an issue is it to have to change proofs, when the tactis language change ?
02:30:26 <ski> s/proofs/proof scripts/
02:30:49 <cads> ski, are you talking about translating a proof from system to system?
02:31:14 <ski> cads : no, i'm talking about maintaining a proof, when the system is upgraded
02:31:52 * ski doesn't know much Coq, but has heard someone complain about something like that
02:32:32 <kmc> ski, i've been wondering that
02:32:48 <kmc> i have not used coq enough for it to come up
02:33:05 <ksf> I don't think they make the tactics less powerful, so stuff should still work
02:33:14 <kmc> there's also the opposite problem, that your tactic-using scripts are quite brittle and will break when you change definitions slightly
02:33:19 <ski> psykotic : well, i don't think it is reasonable to manipulate the expressions as lists .. but i don't know `syntax-case' very deeply
02:33:22 <kmc> that i have run into, even in relatively simple cases
02:33:45 <harlekin> @pl \st a -> fst `fmap` run st a
02:33:45 <lambdabot> ((fst `fmap`) .) . run
02:34:00 <ski> ok (it might be i was confusing things, and that was what i heard complaints about)
02:36:16 <cads> kmc, coq or agda, what would you suggest for me to try first? My list of theorems to formally prove keeps getting longer and I keep putting off actually learning a system.
02:36:26 <kmc> coq is more established
02:36:45 <kmc> also that book by pierce et al really is excellent, i haven't found anything that good for agda
02:36:50 <cads> So I'd be able to find more tutorials and community help, if needed.
02:36:55 <kmc> yeah
02:37:04 <kmc> coq is a bit closer to the proof side of things; agda has more aspirations to be a practical programming language
02:37:29 <kmc> the great thing about a proof assistant is that it's an addictive puzzle game
02:37:33 <cads> So in agda I'd be able to do other things aside from proofs.
02:37:42 <kmc> in coq as well
02:37:49 <kmc> both are dependently typed functional programming languages
02:38:10 <kmc> Agda will feel a bit more natural coming from Haskell
02:38:29 <kmc> for example the way you declare both datatypes and axiomatic propositions in Agda is very similar to a Haskell GADT
02:38:59 <cads> how does that contrast to the experience of using coq coming from haskell?
02:39:09 <kmc> *shrug*
02:39:10 <ksf> agda won't compile down to performant haskell, though, with all those unsafeCoerces around.
02:39:15 <kmc> it's pretty similar either way
02:39:52 <kmc> i recommend you read that Coq tutorial i linked, and also www.cse.chalmers.se/~ulfn/papers/afp08/tutorial.pdf
02:40:02 <cads> maybe I'll sit down with both and try to code a simple proposition
02:40:25 <kmc> ksf, oh?
02:40:36 <cads> does coq have mixfix operators like agda?
02:40:47 <kmc> yes but they're not as nice
02:40:52 <c_wraith> err.  I thought unsafeCoerce had no runtime cost.  Or do you mean something else?
02:41:05 <kmc> coq is mostly ASCII, i think it has recent Unicode support
02:41:26 <kmc> on the flip side, it means you don't need to learn a crazy input mode just to use the standard natural numbers library ;)
02:41:42 <ksf> but you miss optimization possibilities because ghc just doesnt' know jack about your code
02:41:52 <c_wraith> ah, I see.
02:41:59 <c_wraith> yes, that's a real issue.
02:42:22 <cads> thanks for the links kmc
02:43:10 <ksf> the agda guys even have the gall to assume you will be using emacs
02:43:12 <cads> I'll do the agda tutorial and program my next project euler problem in agda, and then I'll see if it's possible to prove it correct!
02:43:52 <cads> ksf don't be a hater :)
02:45:27 * cads still has a handwritten shortcut map for agdamode floating around his desk somewhere
02:45:50 <cads> at the time it didn't occur to me that I had a printer..
02:47:13 * ksf has a printer, and both toner cartdriges have the same blind spots.
02:47:30 <ksf> which is strange, because they come with their own electrolucing thingie.
02:48:07 <cads> I'd think about a new printer
02:48:24 <cads> sounds like something's going amiss there
02:50:17 <cads> do those things still use a laser to ionise a dielectric roll?
02:54:29 <yakov> hey!
02:55:08 <yakov> do I need separate account for hackage.haskell.org/trac/summer-of-code/wiki ? I already have HaskellWiki and Hackage one
02:55:35 <Alpounet> yes
02:56:17 <yakov> ok, ill drop Edward a word.
02:56:41 <Alpounet> he can't create accounts
02:56:50 <Alpounet> the issue is being worked out
02:56:56 <Alpounet> but he can add you to the interested students yeha
02:57:51 <yakov> oh, ok
02:58:14 <cads> kmc, are there other mixfix operators in haskell besides   _ :: _ => _ ?
02:58:36 <ski> cads : that's not really a mixfix operator
02:58:54 <ski> (however, `if ... then ... else ...' can be seen as one)
02:59:11 <idnar> @pl concatMap (\x -> [x, x]) xs
02:59:11 <lambdabot> ap (:) return =<< xs
02:59:14 <idnar> er, no
02:59:18 <idnar> @pl \xs -> concatMap (\x -> [x, x]) xs
02:59:18 <lambdabot> (ap (:) return =<<)
02:59:20 <opqdonut> yeah, :: is a binary operator symbol -> type -> (), and => is a binary operator context -> type -> type
02:59:23 <cads> ski: oh yeah
02:59:30 <idnar> @type ap (:)
02:59:31 <lambdabot> forall a. (a -> [a]) -> a -> [a]
02:59:32 <opqdonut> or rather, context -> simpletype -> type
02:59:44 <idnar> @type ap (:) (:[])
02:59:45 <lambdabot> forall a. a -> [a]
03:00:04 <ski> > let x,y :: Int; [x,y] = [42,17] in x + y
03:00:05 <lambdabot>   59
03:00:52 <kmc> yes if_then_else_ would be the typical example
03:01:10 <kmc> it's the only one that's a normal function aside from syntax, iirc
03:01:16 <kmc> that pisses me off
03:01:49 <cads> it would be cool if there was a facility for defining more
03:02:02 <cads> but I bet it would be terribly easy to misuse
03:02:02 * hackagebot Attrac 0.1.3 - Visualisation of Strange Attractors in 3-Dimensions  http://hackage.haskell.org/package/Attrac-0.1.3 (RubenZilibowitz)
03:02:05 <ski> (so, `::' can take a sequence of identifiers on the left, not just a single identifier)
03:02:22 <ski> cads : you can define `if_then_else_' in Agda
03:04:26 <kanalj> ?faq Can you implement a browser in Haskell?
03:04:26 <lambdabot> The answer is: Yes! Haskell can do that.
03:04:46 <cads> hmm
03:05:10 <Entroacceptor> ?faq is it a good idea to implement a browser in haskell?
03:05:11 <lambdabot> The answer is: Yes! Haskell can do that.
03:05:13 <ksf> no, you can't. there's too much despair going on wrt. low-level graphics
03:05:35 <Jafet> THere
03:05:35 <cads> > let [a , b] = [id, (^2)] in b . a 10
03:05:36 <lambdabot>   Occurs check: cannot construct the infinite type: a = f a
03:05:41 <Jafet> 's even more despair with desktop systems
03:06:09 <ski> kanalj : e.g. WWWBrowser at the bottom of <http://www.cs.chalmers.se/Cs/Research/Functional/Fudgets/demoform.html> for an (old) example
03:06:45 <cads> > let [a , b] = [1, 2] in a+b
03:06:46 <lambdabot>   3
03:06:54 <Alpounet> any webkit port going on somewhere maybe ?
03:07:52 <cads> > let [a , b] = [id, (^2)] in (b . a) 10
03:07:53 <lambdabot>   100
03:08:19 * ksf reads up on texture caches
03:08:20 <eevar2> speaking of web crap.. anyone had a look at Node.js? is that a viable approach for a haskell based web framework/library?
03:08:28 <Alpounet> > ap [id, (*10)] [1..10]
03:08:29 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,10,20,30,40,50,60,70,80,90,100]
03:08:46 <cads> I still don't know when I need to put parens around function composition, when I need a $, and when I'm okay the way it is.
03:08:50 <Alpounet> eevar2, you should join #haskell-web
03:08:55 <rtaycher> is there a standard opposite of null function, I get not null and length /= 0, but it would be nicer if there was a standard function to test list non emptiness
03:09:39 <ksf> ...those bits& pieces that I'm working on which both don't work nor fit together might develop into something that's able to do html/css, but I sure as hell won't suffer the agony of writing an sgml parser
03:09:43 <cads> ksf, texture caches sound like a cool graphics term
03:10:35 <Jafet> Caches... for textures...
03:10:44 <Jafet> @pl not.null
03:10:45 <lambdabot> not . null
03:11:14 <ksf> if you want a browser, I suggest starting out with implementing ecmascript. there might be something usable be done graphics-wise once you're done.
03:11:30 <Alpounet> this Attrac thing is fun
03:11:43 <ski> cads : function application associates to the left, and binds tighter than everything else (excepting a few things regarding patterns)
03:11:46 <lowasser> can anyone tell me a type with an *obscene* kind?
03:11:55 <lowasser> just give me a type and a package location
03:12:14 <Alpounet> lowasser, I finished to read your draft
03:12:18 <Alpounet> it is very nice
03:12:21 <lowasser> thanks!
03:12:22 <ski> cads : i'd suggest not using `$', until you understand well how function application groups
03:12:48 <ski> lowasser : not sure what an "obscene" kind is .. maybe
03:12:51 <ski> @kind RWST
03:12:51 <lambdabot> * -> * -> * -> (* -> *) -> * -> *
03:12:54 <ski> ?
03:12:54 <Alpounet> except the remarks folks in here gave you, really nothing to suggest
03:12:59 <lowasser> that's pretty good
03:13:13 <Entroacceptor> ?faq Why would you want to write a browser in Haskell?
03:13:13 <lambdabot> The answer is: Yes! Haskell can do that.
03:13:15 <lowasser> oooh, I win, I win!
03:13:37 <ski> rtaycher : i usually use `not . null'
03:13:37 <lowasser> I spent the past five hours trying to do automatic kind inference in Template Haskell
03:14:11 <rtaycher> thanks I ended up using $ , '.' seems to hate me
03:14:55 <ski> rtaycher : maybe you want `not (null theList)' or `(not . null) theList' ?
03:15:39 <ski> rtaycher : if i'm passing the function to another function, i usually go for `(not . null)' like `filter (not . null) listOfLists'
03:15:59 <ksf> gosh, we don't even have an r-tree implementation
03:16:14 <ski> rtaycher : but if you're testing a direct function input, it would probably be better to use pattern-matching, directly
03:16:28 <cads> Ski, is this a correct illustration of function application?  f a b + c = (f a) b + c = (f a b) + c = (+) (f a b) c. Here, if f is a function that still produces a function after recieving two values, we have a syntax error.
03:17:24 <cads> ski, could you recommend a good tutorial that covers aspects like left association and binding?
03:17:32 <ski> cads : not necessarily .. `(+)' might accept a function as first argument
03:17:42 <Jafet> ksf, datastructures without proven complexity are for hackjob beardies!
03:18:07 <cads> ski: Ah, yeah, we might have defined it that way.
03:18:18 <ski> (either because you've (probably) done `instance Num a => Num (e -> a)', or because you've locally shadowed `(+)' to something else)
03:18:27 <ski> (in any case, it is not a *syntax* error)
03:18:51 <ksf> ha! I challenge you to give me the cache miss asymptotics for IntMap!
03:18:57 <ski> cads : anyway, those four expressions all express the same thing
03:19:55 <ksf> I've considered implementing cache-oblivious stuff in haskell, but it seems like it'd be utter hell without uniqueness types
03:20:25 <ski> cads : i'm not sure about a tutorial .. i assume "Haskell: The Craft of Functional Programming" (which i learned from) probably had some association and precedence discussion, at some point
03:20:53 <ksf> speaking of uniqueness types, are there or have there ever been any kind of plans to add them to haskell?
03:21:19 <ski> (not that i know of)
03:21:52 <Jafet> Is there no existing mechanism?
03:21:58 <Jafet> ST is passingly similar
03:22:32 <ski> not really
03:23:09 <ski> one can combine `ST'-like things with uniqueness, to get both abilities (Mercury supports this)
03:24:00 <cads> thanks ski. I'd tried understanding associativity and precedence from the haskell report the other day. When it got into a metarule about lambda syntax or something I completely lost it, rushed to skimmed the single fact I needed, and closed out the document in a panic
03:24:11 <ski> with `ST', you get normal sharable references pointing to unique cells, wrt some hidden unique state
03:24:32 <cads> it wasn't quite so dramatic as that, but that felt beyond my level :)
03:24:50 <ski> so you can use the usual "action at a distance" that happens with pointers/references
03:25:12 <ski> with raw unique values, you're passing around the values, themselves, instead
03:26:53 <ski> cads : basically, if you have `foo + bar * baz', then you start by looking at the precedence levels for `+' and `*' -- since `*' has higher precedence, it parses as `foo + (bar * baz)'
03:27:45 <ski> cads : when you have the same precedence, you look for whether operators are left-associative, right-associative, or non-associative
03:28:46 <ksf> thinking about it, I guess the vanilla way to get cache obliviousness, that is e.g. laying out your binary tree in an array in van emde boas layout isn't that smart in haskell due to sharing
03:29:03 <ksf> the better thing would be a gc that can be told to do that layout.
03:29:36 <ksf> which I will euphemistically call an "open research problem"
03:55:55 * ksf is flabberghasted
03:56:25 <ivanm> ksf: at what?
03:57:13 <ksf> unlike the hackage version lambdacube's svn version has functional haddock docs, and the scope is _gigantic_
03:57:20 <ksf> there's gigatons of code there
03:58:06 <ksf> and it all seems to be very, very flexible
03:58:32 <ivanm> lambdacube?
03:58:46 <ksf> http://www.haskell.org/haskellwiki/LambdaCubeEngine
03:58:48 <ivanm> hmmm.....
03:58:56 <ivanm> where is this mystical svn version?
03:59:06 <ivanm> ksf: oh, not this one? http://hackage.haskell.org/package/lambdacube
03:59:09 <ksf> http://code.google.com/p/lambdacube/
03:59:59 <ksf> ...and csaba added a bsp loader just 10 hours ago
04:04:13 <rtaycher> can you do type A = [String] deriving Show, ie derive w/Type synonyms
04:05:17 <ksf> yes and no
04:05:50 <ksf> you can do TypeSynonymInstances and define instances for synonyms
04:05:54 <ivanm> you can using an explicit instance
04:05:58 <ivanm> but you can't derive one
04:06:05 <ivanm> (using that extension)
04:06:07 <ksf> ...but as A will be [String], you already have an instance.
04:06:12 <ivanm> note that that's usually a bad idea
04:06:29 <ivanm> ksf: I'm not sure, are you able to override it?
04:06:58 <ksf> so even if you could derive, you'd error out because you can't define two instances for one type
04:07:12 <ksf> the solution is to do a newtype
04:12:26 <harlekin> Is there an efficient way to serialize a Haskell function?
04:12:40 <harlekin> (And deserialize of course.)
04:12:59 <ksf> there's no way at all
04:13:18 <ksf> at least in all the implementions that I'm aware of
04:13:25 <harlekin> Well... I guess I could dump the source of the function and load it dynamically. :-)
04:13:36 <SubStack> yhc I think could do that
04:14:10 <ksf> but you can't generally get a source-level representation of captured variables
04:24:37 <sinelaw> my build on hackage failed
04:24:46 <sinelaw> http://hackage.haskell.org/packages/archive/HOpenCV/0.1.1/logs/failure/ghc-6.12
04:25:16 <sinelaw> but i don't understand why, because Ross (hackage guy) said that opencv is installed on that machine
04:25:49 <sinelaw> cabal-setup: Missing dependencies on foreign libraries:
04:25:49 <sinelaw> * Missing C libraries: cv, highgui, cv, highgui
04:27:21 <Alpounet> maybe as said they are installed in non standard locations ?
04:27:27 <Alpounet> or missing the -dev packages ?
04:27:35 <Alpounet> -the
04:28:25 <ivanm> @slap binary distros that split headers, etc. out from the libraries themselves
04:28:26 * lambdabot secretly deletes binary distros that split headers, etc. out from the libraries themselves' source code
04:28:39 <Alpounet> :D
04:29:48 <sinelaw> heh
04:30:25 <sinelaw> Alpounet, i asked him about the dev packages and he said they're installed
04:30:49 <Alpounet> in system-wide locations and all ?
04:30:57 <sinelaw> dunno, just mailed him again.
04:31:00 <Alpounet> ok
04:31:15 <sinelaw> come to think of it, it won't help, because i require the 2.0 version of OpenCV
04:31:25 <sinelaw> which isn't yet part of most distros
04:32:40 <Alpounet> ok
04:36:32 <mreh> Build depends failure :(
04:36:33 <mreh>   Build-depends:
04:36:34 <mreh>     base      == 4.*,
04:36:34 <mreh>     haskell98 == 1.*,
04:36:34 <mreh>     hmatrix   >= 0.7.*
04:36:44 <mreh> I can't see what's wrong with it
04:37:07 <mreh> this is a "cabal configure" error
04:37:35 <benmachine> >= 0.7.* doesn't really make sense
04:37:41 <benmachine> don't you just mean >= 0.7?
04:37:52 <mreh> yes
04:37:56 <mreh> doi!
04:38:03 <benmachine> (although you should upper bound that, I think)
04:38:13 <benmachine> (at 0.8 or 1.0 if you are feeling optimistic)
04:38:52 <benmachine> (imo, optimism is overrated; restrictions are easier to relax than tighten)
04:40:26 <mreh> benmachine: if you say so
04:40:39 <benmachine> well, you don't have to listen to me :)
04:40:52 <mreh> that's a paradox
04:40:56 <mreh> what do i do?!
04:40:58 <benmachine> heh
04:41:50 <benmachine> well, upper bounds are good because a lot can change in the future
04:42:08 <benmachine> and it's reasonable to expect a major release to throw the entire API off in some way
04:42:11 <mreh> generally, people should keep the interface the same across minor updates
04:42:19 <mreh> yes
04:42:34 <mreh> well, that's not the same as the negation of what I said
04:42:49 <mreh> but I can't be too optimisitic
04:42:54 <benmachine> heh
04:42:58 <mreh> or optimistic
04:43:30 <benmachine> I can't be too optimistic - it is impossible to be too optimistic because no amount of optimism is too much
04:43:33 <mreh> I'll be reasonably optimistic and keep the major version number open
04:43:36 <benmachine> is how I read that at first
04:43:52 <mreh> I should not be too optimistic
04:43:58 <benmachine> yes
04:44:05 <mreh> s/major/minor/
04:44:08 <mreh> blegh
04:44:18 <benmachine> have you read the PVP?
04:44:40 <benmachine> well, I think you're probably right anyway
04:47:35 <mreh> benmachine: PVP?
04:47:54 <benmachine> http://haskell.org/haskellwiki/Package_versioning_policy
04:48:00 <benmachine> @where PVP
04:48:00 <lambdabot> http://www.haskell.org/haskellwiki/Package_versioning_policy
04:48:04 <benmachine> oh, right
04:48:11 <mreh> it's very unlikely someone will include this into another library, it's Haskelloids
04:48:18 <benmachine> hah
04:48:20 <benmachine> fair enough
04:48:38 <benmachine> but it at least tells you about what other library users are likely to do
04:48:42 <mreh> if it breaks, collateral damage should be minimised
04:48:50 <benmachine> yeah
04:59:10 <sunfun> is there anybody who could let me know how to create an instance of a data type Tree? data Tree a = Leaf a | Branch (Tree a) (Tree a)
04:59:47 <kmc> «Tree» is not a type (it's a type constructor) but for example «Tree Char» is
04:59:54 <kmc> «Leaf 'x'» is a value of type «Tree Char»
05:00:24 <kmc> btw we wouldn't say "instance"
05:01:01 <langtree> Leaf 5 is an instance.
05:01:14 <xerox> I guess something like t = Branch (Branch (Leaf 1) (Leaf 2)) (Branch (Leaf 3) (Leaf 4))
05:01:17 <Alpounet> it's a value
05:01:20 <kmc> oh, do you mean as in instantiating the polymorphic type?
05:01:33 <sunfun> yes
05:01:52 <kmc> that happens when you use it
05:02:04 <sunfun> i have difficulties to create an instance in a .hs file
05:02:11 <kmc> what do you mean "instance"?
05:02:14 <kmc> do you mean a value of this type?
05:02:19 <sunfun> yes
05:02:20 <sunfun> sorry
05:02:22 <kmc> or do you mean a typeclass instance, which is a totally different thing?
05:02:25 <kmc> okay
05:02:26 <sunfun> i'm new to functional programming
05:02:31 <kmc> because the "instance" keyword is not used here
05:02:42 <sunfun> i see ok
05:02:58 <kmc> data Tree a = Leaf a | Branch (Tree a) (Tree a)
05:03:01 <kmc> myTree = Leaf 7
05:03:09 <kmc> those two lines should do it
05:03:31 <kmc> you could provide a type signature between the two, i.e. «myTree :: Tree Integer»
05:03:33 <sunfun> oh... easy then.. thanks
05:03:36 <kmc> it's not necessary though
05:03:38 <kmc> no problem
05:04:28 <sunfun> but if i would like to create a tree with different node  myTree = Node (Leaf 6) (Leaf 7) should word?
05:04:31 <sunfun> work sorry
05:04:48 <kmc> sure
05:05:08 <kmc> «Node (Leaf 6) (Leaf 7)» is another value of type «Tree Integer»
05:05:26 <kmc> (whether you give it a name seems secondary to whether you've "created" the value)
05:05:50 <kmc> in general try not to think in terms of "doing stuff" like creating, modifying, etc.
05:05:55 <kmc> a Haskell program is very declarative
05:05:59 <sunfun> oh kmc really thanks
05:06:15 <kmc> when you say "myTree = Leaf 7" you are saying "myTree is another name for the expression (Leaf 7)"
05:06:22 <kmc> just declaring it to be so
05:06:42 <sunfun> i see.. good
05:06:52 <kmc> and since function application never has side effects, you really can reason about equals-for-equals, which is quite powerful
05:07:36 <Twey> kmc: You're using crazy-encoding
05:07:44 <sunfun> yes i've heard about it reading the tutorial for beginner i found called : "a Gentle introduction to Haskell 98"
05:09:08 <kmc> Twey, :/
05:09:10 <kmc> know which one?
05:09:15 <sunfun> :)
05:09:57 <sunfun> kmc why i had this error? parse error on input `='
05:09:59 <ski> s/Node/Branch/
05:10:37 <kmc> sunfun, impossible to say without context
05:10:46 <kmc> you can upload your code to hpaste.org and send the link here
05:11:26 <ski> sunfun : maybe you tried to enter the above snippets into GHCi/Hugs, instead of into a source file ?
05:11:34 <sunfun> oh no no sorry... i forgot "let"
05:11:53 <ski> (sounds like that, yes ..)
05:12:00 <sunfun> :D
05:12:10 <kmc> you would use "let" at the GHCi prompt, but not at the top level of a file
05:12:37 <ski> (also you can't define new datatypes on the fly in the interactor)
05:12:53 <sunfun> sorry guys it's just four days i'm trying to learn this language :) it is fun and grate but i have to change paradigm... so.. it could be not easy
05:13:06 <kmc> no worries :)
05:13:14 <kmc> we are here to help beginners
05:13:20 <sunfun> thank you
05:13:39 <kmc> and to make obscure jokes about category theory
05:13:48 <sunfun> i have to stop thinking imperative :D
05:14:16 <kmc> sunfun, it depends, Haskell is a really good imperative language.  it's more about not forcing your problem to be imperative when it isn't inherently imperative
05:14:33 <kmc> though you probably won't do any imperative programming in Haskell until much later in a course of study
05:14:36 <sunfun> yesterday i discovered that quicksort here is so easy... omg i remember a lot of code lines lol
05:15:57 <sunfun> kmc oh i see but i'm using this because i have to study recursion theory... and i think Haskell is really good for this
05:16:11 <kmc> ah :)
05:16:54 <sunfun> kmc and it is really short... no more 10000 lines lol
05:17:57 <orlandu63> kmc: how is haskell an imperative language? can a language be both functional and imperative?
05:18:15 <sunfun> i was looking also for using haskell with clips for expert systems... it would be fun
05:18:51 <kmc> orlandu63, i think so.  there is not perfect agreement on what these terms mean
05:19:14 <ski> "Haskell is the worlds finest imperative language" - SPJ
05:19:17 <sunfun> kmc, tnx i've learned a lot from you in 5 minutes
05:19:24 <kmc> the way i think about it is: Haskell is a functional language; we compose functions in order to manipulate data of various types.  One of those types is "sequence of steps".
05:19:42 <kmc> a value of that type corresponds to an imperative program
05:20:02 <kmc> so you can use Haskell to write imperative programs, or if you want to be precise, you can use Haskell to *compute* imperative programs (and run them)
05:20:29 <Twey> kmc: Looks like Western-1 if those were supposed to be guillemets
05:20:35 <kmc> Twey, thanks
05:20:39 <kmc> they were
05:21:11 <ski> ("«»"s ?)
05:21:17 <kmc> orlandu63, every practical functional language has a way to do imperative programming
05:21:24 <Twey> ski: "Â«Â»"s
05:21:25 <orlandu63> kmc: i see
05:21:29 <kmc> and every good general-purpose imperative language supports first-class functions
05:21:52 <kmc> because first-class functions are useful in heavily imperative code
05:22:10 <kmc> imo this supposed split has nothing to do with the nature of imperative or functional programming, and everything to do with some mistakes made while designing C++ and Java in particular
05:22:16 <ski> > "Â«Â»" == ['Â','«','Â','»']
05:22:17 <lambdabot>   False
05:22:31 <kmc> (and similar limitations in C, but i can't quite call them mistakes as C is a low-level systems language)
05:23:55 * Alpounet experimenting cps i/o
05:24:18 <ski> dialogue-based ?
05:24:35 <Alpounet> what do you mean by "dialogue" ?
05:24:43 <o-_-o> in C we do something like while (!quit) { call_stuff(); } what is the equivalent of this in haskell ?
05:24:53 <o-_-o> quit being set by some call back function
05:24:59 <ski>   type Dialogue = [Response] -> [Request]
05:25:27 <ski>   putStr :: String -> Dialogue -> Dialogue
05:25:29 <opqdonut> o-_-o: you can do something like that with forever
05:25:31 <opqdonut> :t forever
05:25:32 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
05:25:39 <ski>   getLine :: (String -> Dialogue) -> Dialogue
05:25:41 <ski> &c.
05:25:47 <o-_-o> opqdonut, thanks
05:25:58 <Alpounet> I've just started, so haven't reached that point. But that's interesting. Any pointer ?
05:26:11 <opqdonut> o-_-o: or then you can just make it "f = do stuff; stuff; when (not quit) f;"
05:26:20 <FliPPeh__> Can someone tell me how GTK2HS work? If you can't modify state, how does Gtk2hs render widgets then? If you only return copies, wouldn't you have a GUI full of copies?
05:26:33 <ski> hm, istr some of the initial papers on monads compared them to this style (which existed before monadic I/O in haskell)
05:26:40 <ski> wadler, i think
05:26:47 <Alpounet> ok
05:26:50 <Alpounet> thanks
05:26:59 <Twey> FliPPeh__: You do modify state in Gtk2Hs
05:27:04 <kmc> FliPPeh, why do you think Haskell has no mutable state?
05:27:07 <Accidus> Where can I find documentation for the various code transformations GHC employs for optimisation based on effects? (I'm assuming it employs such optimisations)
05:27:13 <FliPPeh__> Well, it has
05:27:19 <FliPPeh__> But GTK runs in the IO monad
05:27:24 <opqdonut> Accidus: the ghc manual, probably
05:27:27 <Twey> FliPPeh__: Precisely
05:27:30 <kmc> you can create mutable reference cells.  they aren't values.
05:27:43 <opqdonut> Accidus: also, look at the program ghc-core that lets you view ghc's internal representations in a nice way
05:27:57 <ski> Alpounet : the idea being that a value of type `Dialogue' returns a list of requests to the operating system, and receives corresponding responses in the input list
05:27:58 <kmc> Haskell *values* are immutable and Haskell *functions* have no side effects.  this is often and incorrectly summarized as "Haskell has no mutable values or side effects"
05:28:00 <opqdonut> Accidus: good for checking what ghc exactly does with your code
05:28:12 <kmc> or "no mutation" rather
05:28:25 <Twey> They are kind of valuesâ€¦
05:28:36 <Accidus> opqdonut, thanks, I'm checking them out now.
05:29:15 <Alpounet> ok
05:29:17 <ski> Alpounet : so e.g. `getChar k ~(GotChar c:resps) = GetChar : k c resps' and `putChar c k ~(Ok:resps) = PutChar c : k resps'
05:29:22 <FliPPeh__> Hmm
05:29:26 <FliPPeh__> Thanks for clearing me up on that
05:29:28 <kmc> o-_-o, it would be uncommon to terminate a loop by setting a variable that way
05:29:28 <FliPPeh__> :)
05:29:30 <kmc> but you can do it
05:31:15 <kmc> FliPPeh__, another way to look at it: GTK widgets are not values.  names of GTK widgets are values
05:31:15 <krey> hi, I want to create exception/error handling around monadic computations
05:31:16 <ski> Haskell has no mutable *values* or *side* effects
05:31:24 <krey> can somebody help?
05:31:24 <Alpounet> ski, ok, I will take a look at the paper, thanks !
05:31:47 <kmc> the name is totally immutable, and it's how you refer to the widget to ask the system to change stuff
05:36:42 <ksf> widgets are isomorphic to functions
05:36:55 <ksf> or, rather, they form an applicative monoid
05:37:03 <ksf> (please don't ask me about recursion)
05:37:23 <kmc> ksf, what about recursion?
05:37:49 <kmc> krey, can you be more specific?
05:38:21 <ksf> krey, do you want plain, simple and vanilla or absolute overkill?
05:38:27 <Taejo> gah, two three-letter nicks starting with k, and xchat makes them the same colour :|
05:38:35 <kmc> everyone says that
05:38:53 <ksf> I still have to see a proof for that
05:39:12 <ksf> also, my nick is clearly shorter
05:39:27 <Taejo> ksf: fixed-width font
05:39:35 <ksf> SEP
05:39:49 <sinelaw> Taejo, here too :)
05:40:02 <Saizan> coloured nicks are the work of evil
05:40:08 <ski> (.. everyone's got the same nick color, except me)
05:40:18 <sinelaw> are you color blind?
05:40:39 <ksf> no, he's using a sane colouring scheme
05:40:48 <kmc> krey, Control.Monad.Error gives you conceptually nice exceptional control flow... it's implemented in a few lines of ordinary Haskell, and doesn't require you to care about evaluation order, and you can easily get results out of the monad
05:41:13 <Taejo> okay, I've switched to a proportional font -- much better
05:41:32 <ski> kmc : except for the proliferation of the `Error e' constraint everywhere :/
05:41:35 <ksf> the overkill version of that is http://hackage.haskell.org/package/control-monad-exception
05:41:36 <Taejo> ksf: proof: http://imgur.com/PxjRQ (unfortunately imgur converts to JPG)
05:41:50 * ski doesn't like having to define `instance Error Int', &c.
05:42:02 <ksf> you should really, really fix that font
05:42:18 <kmc> Control.Exception has the "real" exceptions that can be thrown by IO, or from pure code, or asynchronously from another thread, etc.  as a result, semantics and implementation are more complicated
05:42:52 <kmc> and you can only catch in the IO monad
05:43:22 <ksf> whereas control.monad.exception has all that javaish bondage+discipline, just way better. you won't forget to catch exceptions, like that
05:43:24 <Alpounet> Taejo, what's my color ? just to know
05:43:40 * Alpounet always wondered that
05:43:45 <Accidus> opqdonut, the manual only gives the names of optimisations, but I'm interested in the nature and proofs for their correctness.
05:43:47 <Taejo> ksf: I've switched to Comic Sans -- that way everything looks like it was written by SPJ so I think I'm learning something on IRC
05:43:55 * hackagebot cpsa 2.0.2 - Symbolic cryptographic protocol analyzer  http://hackage.haskell.org/package/cpsa-2.0.2 (JohnRamsdell)
05:43:58 <Taejo> Alpounet: orange
05:44:09 <kmc> Taejo, surely you should use MS Comic Chat as your client, then
05:44:33 * ksf uses DejaVu Serif
05:44:52 <Jafet> @remember Taejo I've switched to Comic Sans -- that way everything looks like it was written by SPJ so I think I'm learning something on IRC
05:44:52 <lambdabot> It is stored.
05:49:33 <krey> kmc: I need all computation to stop when a single exception is found
05:49:42 <krey> kmc: Can it do that?
05:49:50 <ksf> it does, by default.
05:50:04 <ksf> ...when with "stop" you mean your program dies
05:50:06 <kmc> yes, both systems work that way
05:50:25 <kmc> are you familiar with the Maybe monad? that is perhaps the simplest exception-like thing in Haskell
05:50:30 <krey> yes
05:50:35 <krey> I need something very similar
05:50:57 <kmc> Either and ErrorT are similar but let you attach more useful information than "Nothing"
05:51:22 <krey> what I don't get is the typing
05:51:27 <kmc> (Left e) >>= _ = Left e;  (Right x) >>= f = f x
05:51:57 <kmc> how so?
05:51:59 <krey> Monad m => m (Either e a)
05:52:26 <Botje> no, Either e *is* the monad
05:52:27 <ksf> nope that's a monadic action that returns Either e a
05:52:44 <kmc> you can do that, and it might even be useful, but you're not using Either monadically
05:52:49 <ksf> > Right 4 >>= return . (*2)
05:52:50 <lambdabot>   Ambiguous type variable `a' in the constraints:
05:52:50 <lambdabot>    `Control.Monad.Error.Cla...
05:52:55 <ksf> > Right 4 :: Int >>= return . (*2)
05:52:56 <lambdabot>   <no location info>: parse error on input `.'
05:53:05 <kmc> krey, if you want to add exception handling to another monad, what you need is the ErrorT monad transformer
05:53:05 <ksf> > Right (4 :: Int) >>= return . (*2)
05:53:06 <lambdabot>   Ambiguous type variable `a' in the constraints:
05:53:06 <lambdabot>    `GHC.Show.Show a'
05:53:06 <lambdabot>      a...
05:53:44 <ksf> > (Right 4 >>= return . (*2)) :: Either () Int
05:53:45 <lambdabot>   No instance for (Control.Monad.Error.Class.Error ())
05:53:45 <lambdabot>    arising from a use ...
05:53:49 <ksf> > (Right 4 >>= return . (*2)) :: Either () Int
05:53:49 <lambdabot>   No instance for (Control.Monad.Error.Class.Error ())
05:53:50 <lambdabot>    arising from a use ...
05:53:52 <ksf> > (Right 4 >>= return . (*2)) :: Either String Int
05:53:53 <lambdabot>   Right 8
05:53:59 <ksf> phew
05:54:03 <Jafet> > concat (fmap show [1..10] ++ [error "lol"] ++ fmap show [11..20])
05:54:04 <lambdabot>   "12345678910* Exception: lol
05:54:10 <krey> lemme pastebin...
05:54:40 <ksf> > (Left "ugs" >>= return . (*2)) :: Either String Int
05:54:41 <lambdabot>   Left "ugs"
05:55:22 <krey> does this make any sense: http://pastebin.com/ERUaAA4S ?
05:55:23 <ksf> ...the not-so-nice thing about Monad Either is that it doesn't short-circuit.
05:56:43 <Entroacceptor> it doesn't what?
05:56:46 <ksf> it's Right e >>= f = Right (f e)
05:57:46 <ksf> you can get rid of that Exception type, and use get (Left e) = e
05:58:21 <ksf> ...except, of course, bind won't ever give it to you, anyway.
05:59:05 <ksf> now we need someone with a black belt in category-foo to figure out how to properly monadize over two return types
05:59:19 <ksf> ...if in doubt, you could use arrows
05:59:50 <ksf> I guess the real question is: what do you want to use those exceptions for?
06:03:58 <Ferdirand> ksf: what do you mean by not short-circuiting ?
06:05:17 <ksf> Left 1 >>= foo >>= bar >>= baz matches Left three times, one time for each bind.
06:05:52 <ksf> I'm talking nonsense.
06:05:59 <benmachine> >>= is infixl
06:06:02 <mreh> :t e
06:06:03 <lambdabot> Expr
06:06:11 <mreh> :t exp
06:06:12 <lambdabot> forall a. (Floating a) => a -> a
06:06:12 <Accidus> Okay, lets try this differently: what kinds of optimisation does GHC employ for monads? What kind of optimisations does the use of monads repress? Where would be the appropriate place to look?
06:06:26 <mreh> 10 `exp` 3
06:06:30 <mreh> > 10 `exp` 3
06:06:32 <lambdabot>   No instance for (GHC.Float.Floating (t -> a))
06:06:32 <lambdabot>    arising from a use of `GHC...
06:06:35 <ksf> no special ones, none, everywhere.
06:06:40 <benmachine> ksf: you're right, but that's easy to fix by bracketing properly
06:06:58 <Taejo> mreh: exp only takes one argument. You may be looking for (^^), (**) or (***)
06:07:15 <Taejo> gah
06:07:15 <benmachine> :t (***)
06:07:16 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
06:07:23 <benmachine> hmm :P
06:07:27 <Taejo> I meant (^), (^^) or (**)
06:07:35 <mreh> Taejo: I'm looking for an `x * 10^y` operator
06:07:37 <benmachine> :t ((^), (^^), (**))
06:07:38 <lambdabot> forall a b a1 b1 a2. (Num a, Integral b, Fractional a1, Integral b1, Floating a2) => (a -> b -> a, a1 -> b1 -> a1, a2 -> a2 -> a2)
06:07:52 <benmachine> @pl \x -> x * 10 ^ y
06:07:52 <quicksilver> mreh: that operator is called x * 10^y ;)
06:07:52 <lambdabot> (10 ^ y *)
06:08:11 <quicksilver> @pl \x y -> x * (10 ^ y)
06:08:12 <lambdabot> (. (10 ^)) . (*)
06:08:41 <byorgey> > 9e3
06:08:42 <lambdabot>   9000.0
06:08:52 <quicksilver> that's not an operator, though, it's syntax.
06:08:53 <byorgey> you can use an infix 'e' for floating-point constants
06:08:56 <byorgey> right.
06:09:01 <mreh> > 10^(-3)
06:09:01 <lambdabot>   * Exception: Negative exponent
06:09:06 <byorgey> but maybe that's what mreh was thinking of?
06:09:20 <mreh> byorgey: yes
06:09:22 <ksf> > 10**(-3)
06:09:23 <lambdabot>   1.0e-3
06:09:37 <ksf> > 10^^(-3)
06:09:38 <lambdabot>   1.0e-3
06:09:39 <burp> > 10^^(-3) -- enough
06:09:41 <lambdabot>   1.0e-3
06:09:42 <mreh> I don think I can use that with unbound variables?
06:10:19 <mreh> thanks
06:11:45 <xerox> can we put a metric on types
06:14:28 <Jafet> Well, there is a lattice...
06:14:39 <ksf> http://arxiv.org/abs/1003.2547
06:14:40 <ksf> zomg
06:15:23 <mercury^> Of course you *can* put a metric on types, why would you?
06:15:34 <Jafet> Yeah, that exclamation charactierizes arxiv
06:15:36 <Taejo> xerox: you can put a metric on anything, but I can't think of a useful metric off the top of my head
06:15:52 <xerox> Taejo: not quite, there are spaces that aren't metrizable
06:16:06 <Taejo> xerox: depends what you mean by space
06:16:15 <ksf> "The C Object System (COS) is a small C library which implements
06:16:15 <ksf> high-level concepts available in CLOS, OBJECTIVEC
06:16:15 <ksf> and other object-oriented programming languages: uniform
06:16:15 <ksf> object model (class, metaclass and property-metaclass),
06:16:15 <ksf> generic functions, multi-methods, delegation, properties, exceptions,
06:16:16 <ksf> contracts and closures. COS relies on the programmable
06:16:18 <ksf> capabilities of the C programming language to extend
06:16:20 <ksf> its syntax and to implement the aforementioned concepts
06:16:22 <ksf> as first-class objects."
06:16:24 <ksf> oh sorry
06:16:24 <mercury^> xerox: you'd need a topology on the types first for that to be relevant.
06:16:36 <ksf> those shouldn't have been pre-wrapped
06:16:37 <xerox> mercury^: and we've done that right?
06:16:54 <mercury^> I don't know what topology you are referring to, but if you say so..
06:16:55 <Taejo> xerox: we have?
06:17:32 <kmc> Accidus, "Monad" is an ordinary typeclass and (>>=) is an ordinary higher-order function
06:17:41 <xerox> http://www.cs.bham.ac.uk/~mhe/papers/entcs87.pdf
06:17:44 <kmc> as far as I know, GHC's optimizer does not treat them specially
06:18:04 * hackagebot TreeStructures 0.0.2 - A collection of heaps and search trees  http://hackage.haskell.org/package/TreeStructures-0.0.2 (BrendanHickey)
06:18:37 <mercury^> xerox: what's the idea behind that?
06:19:04 <Taejo> when I did functional computable analysis, elements of all types were represented by sequences of naturals, and then you use the topology generated by the representation function
06:19:26 <Taejo> where the sequences of naturals have the usual topology (which is metrizable)
06:20:33 <kmc> Accidus, many different types with different representations conform to the monad interface
06:20:48 <Taejo> this gives you the property that all computable functions are continuous (I believe Baire already noticed this for functions on [Natural])
06:21:01 <mercury^> That paper seems concerned not with a topology of the "set of types", but rather with making types topological spaces.
06:21:06 <kmc> and so i think the relevant optimizations will depend heavily on what monad you're considering
06:21:23 <mreh> would you say FP causes you to have to include every possible use someone could require from your library, in your API?
06:21:34 <Taejo> mercury^: yes, and I was making the same confusion
06:21:45 <xerox> the topology is exactly what Taejo is talking about, the one that makes computable functions continuous
06:21:47 <kmc> if you are interested in the IO monad in particular, you should read about how GHC implements the IO monad in terms of special impure functions, then perhaps read "Secrets of the GHC Inliner" to read about how functions are inlined
06:21:47 <mreh> I suppose that is true of all encapsulation
06:22:14 <Cale> It's important to notice that the meaning of the term "topological space" needs a slight modification.
06:22:23 <Taejo> Cale: it does?
06:22:39 <xerox> oh dang.
06:22:43 <Cale> Yeah, instead of arbitrary unions, you need to be able to compute the sequence of terms in your union.
06:22:46 <Taejo> xerox: I don't claim that that topology is the only one with that property
06:23:06 <Cale> But aside from that, everything works out nicely.
06:23:06 <xerox> Taejo: agreed, but then, if the definition is different, the theory doesn't apply anyway.
06:23:50 <Cale> Otherwise, since each subset of the naturals containing only one element is open, every subset of the naturals would be too.
06:24:07 <xerox> aka discrete topology
06:24:19 <Cale> Right, which is what happens in the usual case.
06:24:20 <Taejo> Cale: the topology on the naturals *is* the discrete topology
06:24:45 <Cale> But it's not the right thing for computability theory.
06:24:48 <Taejo> Cale: I didn't say that every continuous function is computable
06:24:53 <Taejo> only the converse
06:25:10 <Cale> You want only the semidecidable sets as the open sets.
06:25:18 <Taejo> Cale: we called your concept "c.e. openness" I believe
06:25:34 <mercury^> c.e. meaning?
06:25:36 <xerox> does a "metric" come with that "topology"
06:25:43 <mercury^> computably enumerable?
06:25:47 <Taejo> yes
06:26:06 <Taejo> a c.e. union of c.e.-open sets is c.e. open
06:26:37 * Taejo remembers very little about metrizability, unfortunately
06:28:31 <Taejo> I'm looking for an introductory article from the FCA/CCA group
06:29:50 <twink> > let i = 0 :+ 1 in i ** i
06:29:51 <lambdabot>   0.20787957635076193 :+ 0.0
06:31:20 <Taejo> http://arxiv.org/abs/0905.4679 is somewhat introductory, but doesn't focus on topology that much
06:32:00 * ksf tries to wrap around http://cos.cvs.sourceforge.net/viewvc/cos/CosBase/include/cos/cpp/algos.h?revision=1.1&view=markup
06:32:06 <ksf> those are folds implemented in CPP
06:32:14 <ski> Taejo : "FCA/CCA" ?
06:32:37 <Taejo> functional computable analysis / computability and complexity in analysis
06:32:51 <ski> (any specific link ?)
06:33:41 <Taejo> cca-net.de is the group's site
06:34:25 <Jafet> ksf: http://www.boostpro.com/tmpbook/preprocessor.html
06:34:30 <Cale> Another option I like is just to take the usual DCPO on each type and use it to form a preorder category, so that you can think of types as categories. You can then recover quite easily the usual results about fixpoints in a fairly general categorical setting.
06:34:46 <Cale> and apply the very same results at the type level
06:34:56 <Alpounet> Cale, any paper / article on that ?
06:35:25 <Cale> Alpounet: I'm not sure. I noticed that it was the case on my own, but I'm sure someone must have written about it.
06:35:27 <Accidus> kmc, Yes, but I'm referring mainly to the famous effect monads: exceptions, state, IO
06:36:00 <Alpounet> Cale, what about ... you, writing something on that ? =)
06:36:08 <Taejo> Cale: what kind of thing do you mean by "the usual results about fixpoints"?
06:36:35 <twink> I guess ErrorT for exceptions?
06:36:58 * Taejo needs to do some real maths again, before his brain turns to mush
06:37:55 * twink mostly remembers bonehead analysis and bare definitions wrt. algebra.
06:38:42 <ski> (Accidus : continuations are also famous)
06:38:43 <twink> I've forgotten more topology, category theory, etc. than I ever knew.
06:38:52 <Cale> Taejo: Existence of least fixed points.
06:38:55 <ksf> I think my main mental block is that I never managed to beat that macro languages have any power, at all, into my head
06:39:04 <ksf> I _know_ tex is turing complete, but....
06:39:26 <Taejo> ksf: so code something in it!
06:39:33 <ksf> hell no I won't
06:39:44 <Jafet> Taejo, in cpp or tex?
06:39:49 <ksf> either
06:39:51 <Jafet> Lamport could do it, so can you!
06:40:16 <Taejo> tex is probably easier than cpp: at least tex has arithmetic
06:40:21 <ksf> there's a reason they did luatex
06:40:48 <ksf> ...basically because the whole of latex is a hack of gargantuan proportions
06:41:00 * twink never seriously thought about how much power (or lack thereof) macro languages have.
06:41:17 <Cale> http://www.uni-koblenz.de/~laemmel/paradigms0910/resources/denotational3.html
06:41:30 <Cale> ^^ the contents of this lecture generalise to suitable categories
06:41:34 <Taejo> somebody did ICFP-PC '08 in TeX, AFAIR
06:41:43 <ksf> changing any latex module is an exercise in luck: you might have to reimplement the whole of tex to add a rather trivial feature
06:42:23 <ksf> s/tex/latex/
06:42:31 <ksf> ...though the former might be easier.
06:42:33 <Cale> You can replace directed-completeness with chain-completeness (has all limits of chains), and having a bottom element with having an initial element.
06:42:38 <SamB_XP> ksf: you mean, reimplement TeX in *TeX* ?
06:42:39 <Cale> An initial object, sorry :)
06:43:01 <SamB_XP> Cale: how does that help little LaTeX feature work?
06:43:05 <ksf> I'd rather reimplement tex in haskell
06:43:12 <ksf> without the language part, thoug.h
06:43:13 <Cale> Whaaat?
06:43:17 <Cale> LaTeX?
06:43:55 <mercury^> I wonder if implementing TeX in TeX can get me around taking a course in TeX.
06:43:57 <SamB_XP> ksf: is conTeXt any better ?
06:44:00 <Taejo> Cale: I haven't done much order theory: directed-completeness == every directed set has a join? Now I just need to remember what a directed set is
06:44:11 <ksf> never used it
06:44:19 <SamB_XP> mercury^: I would suggest just taking the course ;-P
06:44:37 <ksf> I stumbled over luatex because I wanted both true-type fonts and microtypography
06:44:44 <xerox> mercury^: argh, that's not a good plan
06:44:56 <ksf> ...and while it's considered beta, it actually works just fine.
06:45:32 <ksf> it implements all the stuff the various tex dialects specialised in.
06:46:06 <mercury^> I've used context before and found it awful.
06:46:07 <Cale> Taejo: A directed set is a set where every pair of elements has an upper bound.
06:46:11 <SamB_XP> what mean you by "dialects"?
06:46:15 <Taejo> ah, right
06:46:22 <ksf> I also guess that it's going to speed up tex by a significant amount, as lua is pretty fast
06:46:34 <ksf> pdftex, xetex, and so on
06:46:37 <SamB_XP> ah
06:46:47 <SamB_XP> so the different hacked-up tex(1)s
06:46:54 <ksf> yep
06:47:02 <Cale> I suppose actually that the proper analogy is a little different than what I thought it was....
06:47:07 <SamB_XP> not LaTeX, conTeXt, plain TeX, texinfo ...
06:47:16 <ksf> nope
06:47:24 <ksf> those are standard libraries
06:47:25 <Cale> hmm :)
06:47:31 <ksf> (or the absence therof)
06:47:40 <Accidus> ski, yeah, but as every expressible monad is can be represented by the continuation monad, I somehow doubt I could get many such optimisations out of the continuation monad
06:47:55 <Cale> It was a little while since I thought about this last, so I forget what details I worked out.
06:48:02 <SamB_XP> is there any TeX format that isn't a giant hack but *is* useful?
06:48:29 <ksf> the nice thing with luatex is that you could do e.g. a fully procedural font, right in your .tex file.
06:48:58 <SamB_XP> ksf: that outputs how?
06:49:09 <SamB_XP> I mean, what does it turn into in the PDF?
06:49:12 <ksf> you can inject it into the tex interpreter
06:49:15 <ksf> ...as a font
06:49:20 <Jafet> SamB_XP, tex is a string rewriting system
06:49:23 <Cale> Accidus: GHC is surprisingly good at optimising code which is expressed in terms of continuations for some reason.
06:49:24 <Jafet> What do you expect
06:49:25 <SamB_XP> ah, saweeet!
06:49:35 <SamB_XP> Jafet: it's a little bit more than that!
06:50:07 <Accidus> Cale, yeah, but I'm talking about effect specific optimisations
06:50:13 <SamB_XP> though it does seem that it's usually necessary to resort to a lot of token-stream rewriting in a format of any complexity
06:50:25 <Accidus> So optimisations which will hold in the presence of reads, but not writes, etc.
06:51:01 <Accidus> Cale, but even with continuations --- can you refer me to equations of such optimisations?
06:51:49 * ksf guesstimates continuations get the best out of the strictness analyzer
06:52:14 <ski> (Accidus : .. actually nqCPS)
06:52:35 <Cale> Accidus: I think it has something to do with the fact that it does a better job of removing allocations in code that is written in continuation passing style.
06:52:37 <SamB_XP> Cale: maybe that's why CPS transforms are/were all the rage in functional language compilers ?
06:52:41 <zygoloid> ski: nq?
06:52:48 <ski> "noq-quite"
06:52:53 <Cale> But don't quote me on that
06:53:03 <zygoloid> ski: where noq is nqnot? :)
06:53:03 <ski> `forall o. (a -> o) -> o' is basically the same as `a'
06:53:16 <ski> er, "not-quite" :)
06:53:41 <SamB_XP> @djinn forall o. (a -> o) -> o
06:53:42 <lambdabot> -- f cannot be realized.
06:53:43 <Accidus> Cale, I can see how CPS can deforest
06:53:49 <SamB_XP> @djinn forall o. (Int -> o) -> o
06:53:50 <lambdabot> Error: Undefined type Int
06:53:54 <SamB_XP> @djinn forall o. (Bool -> o) -> o
06:53:55 <lambdabot> f a = a False
06:53:59 <ski> @djinn a -> (a -> o) -> o
06:54:00 <lambdabot> f a b = b a
06:54:04 <Accidus> Cale, shouldn't all this stuff about optimisations be documented somewhere?
06:54:11 <ski> @djinn (forall o. (a -> o) -> o) -> a
06:54:11 <lambdabot> -- f cannot be realized.
06:54:24 <ski> would work, if djinn could handle rank-2 propositions
06:54:42 <SamB_XP> ski: are those decidable ?
06:54:50 <Accidus> Rewrite rules seem related as well. Is there any collection of standard rewrite rules GHC applies?
06:54:51 <zygoloid> that one is :)
06:54:51 <Cale> Accidus: Possibly, but I don't know where exactly it would be...
06:55:02 <SamB_XP> zygoloid: "that one is"?
06:55:03 <ski> @type let run :: (forall o. (a -> o) -> o) -> a; run m = m id in run
06:55:03 <Accidus> Cale, cheers anyway
06:55:04 <lambdabot> forall a. (forall o. (a -> o) -> o) -> a
06:55:09 <Cale> Accidus: Oh, the rewrite rules are spread throughout the libraries.
06:55:12 <SamB_XP> a single proposition a decidable class does not make
06:55:27 <Cale> Accidus: You'll find them in the source code for the libraries that define the functions they rewrite.
06:55:30 <SamB_XP> at least, not an *interesting* decidable class
06:55:33 <ski> SamB_XP : i don't really recall
06:55:33 <dantheman_> Hey, I have a question about a simple haskell program I've written using threads, can anyone help me? Thanks.
06:55:41 <zygoloid> SamB_XP: hence the smiley
06:55:58 <Accidus> Cale, so the State library will contain rewrite rules for the state monad?
06:56:07 <SamB_XP> dantheman_: can you ask the question? Thanks.
06:56:09 <Cale> I don't think there are any in that case.
06:56:14 <dantheman_>  The program is at http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=23989#a23989
06:56:16 <zygoloid> SamB_XP: slightly less tongue-in-cheek, my point was that even for semi-decidable classes, @djinn could be useful if time-limited
06:56:29 <byorgey> join :: Ask (Ask Question) -> Ask Question  ;)
06:56:38 <dantheman_> With my understanding, both threads should terminate once b terminates
06:56:41 <Cale> There's simple foldr/build fusion for lists, but there's stream fusion for ByteStrings, and I think someone was working on a similar sort of fusion for normal lists.
06:56:56 <SamB_XP> Cale: certainly!
06:57:00 <dantheman_> But when I run it in ghci, the a printer thread keeps going even after the command prompt thread finishes
06:57:18 <SamB_XP> I only wish I could see how to prove the fusion correct with a theorem prover
06:57:37 <dantheman_> Shouldn't all threads terminate once the main thread (i.e. b) finishes?
06:57:51 <Accidus> Cale, hmmm... But surely there are such optimisations? Like dead code elimination and such like...
06:58:03 <Cale> dantheman_: GHCi is weird in that respect, because *its* thread is the main thread.
06:58:05 <SamB_XP> where "correct" includes giving the same productivity as the original
06:58:11 <mreh> I could never find an easy way of collecting the content of all Just's until the first Nothing
06:58:37 <mreh> or a monad that is monomorphic to Maybe and will do that for me
06:58:41 <dantheman_> Ahhh... thanks Cale.  Actually that possibility just dawned on me whiles writing this question !
06:58:45 <Cale> Accidus: Oh, those sorts of rewrites, yes, there are a lot of those in the compiler itself.
06:58:50 <nainaide> Is "@" a operator in Haskell ?
06:58:53 <Cale> In the 'simplifier'
06:59:04 <ski> nainaide : it is a pattern "operator", yes
06:59:06 <byorgey> nainaide: no, but it can be used in patterns
06:59:09 <Cale> nainaide: No, it's part of the syntax of patterns.
06:59:21 <dantheman_> Do you have any idea how I might change it so that the spawned thread is killed properly in ghci?
06:59:24 <SamB_XP> ... I guess you'd get that from giving the same results even for partial values (those containing _|_)
06:59:32 <Accidus> Hmm... so I should look at the simplifier's documentation, I guess.
06:59:32 <ski> @src scanr
06:59:32 <lambdabot> scanr _ q0 []     =  [q0]
06:59:32 <lambdabot> scanr f q0 (x:xs) =  f x q : qs
06:59:32 <lambdabot>     where qs@(q:_) = scanr f q0 xs
06:59:46 <nainaide> Thansk
06:59:54 <Cale> <var>@<pat> will match the pattern <pat>, and bind the entire matched thing to the variable <var>
07:00:00 <ski> ^ `scanr f q0 xs' is both named `qs' and matched against `q:_', there
07:00:11 <Cale> > let xxs @ (x:xs) = [1,2,3] in (xxs,x,xs)
07:00:12 <lambdabot>   ([1,2,3],1,[2,3])
07:00:21 <nainaide> great ! very useful
07:00:41 <dantheman_> anyone?
07:00:44 <benmachine> Cale: the plural of xs is xss :P
07:00:47 <nainaide> Thank you Cale
07:00:57 <byorgey> dantheman_: just get the a printer thread's ThreadID from the forkIO call, and kill it with killThread when you're done
07:01:00 <ski> > let u @ _ = () in u
07:01:01 <lambdabot>   ()
07:01:04 * Twey wonders if anyone has ever used the identifier â€˜xsssssâ€™
07:01:12 <Cale> dantheman_: You could capture the threadid when you forkIO a, and then explicitly killThread
07:01:16 <ski> (`_' is an identity to `@')
07:01:27 <dantheman_> Hey byorgey and cale, thanks, I'll try that.
07:01:57 <ski> byorgey : but `xxs' there was not a list of lists of numbers
07:02:05 <benmachine> > let _ @ u = () in u
07:02:06 <lambdabot>   <no location info>: parse error on input `@'
07:02:08 <benmachine> aw
07:02:10 <Cale> I've used xss, but never xsss
07:02:30 <ski> benmachine : doesn't work, unfortunately, due to restriction that left argument must be an identifier
07:02:45 <benmachine> I've used ass before >_>
07:02:51 * ski thinks that ought to be removed
07:02:57 <zygoloid> xxs@(x:xs) seems quite reasonable. i usually use xs@(x:xt) for that
07:03:13 * ski often uses `xs0@(x:xs)'
07:03:43 <theorbtwo> xs'@(x:xs) -- and people say that perl is unreadable!
07:03:50 <benmachine> it is.
07:04:01 <zygoloid> especially now we have view patterns, i think the lhs of @ should be a general pattern
07:04:18 <benmachine> hmm
07:04:24 <benmachine> so we have a sort of parallel match
07:04:36 <zygoloid> let  xxs@(head -> x)@(tail -> xs) = ...
07:04:45 <ski>   foo (viewl -> x0 <: xs0)@(viewr -> xs1 :> x1) = ...  -- e.g. here a symmetric `@' would be useful
07:04:51 <benmachine> maybe @ isn't as appropriate then
07:05:04 <zygoloid> ski: that's a much better example :)
07:05:12 <ski> zygoloid : seconded
07:05:23 * theorbtwo shrugs.  It's a completely compatable extension, though, benmachine.
07:05:58 <ski> (btw, we also ought to have or-patterns (and always failing patterns))
07:06:24 <benmachine> always failing patterns?
07:06:31 <theorbtwo> What use would an always failing pattern be?
07:06:33 <Cale> Is it really worth the extra syntax?
07:06:38 <ski> yes, as the unit to the or-pattern
07:06:57 <Cale> What would a use-case of the always-failing pattern be?
07:07:01 <Jafet> Next we'll be using regular expressions as guards, and borrow pugs code to parse
07:07:10 <benmachine> heh
07:07:20 <ski> no regular expressions, please :)
07:07:39 <benmachine> let s =~ /(x:(xs|[])/
07:07:48 <Cale> I've used always-False guards before, but I don't see how it would be useful to have a pattern that always fails.
07:07:49 <theorbtwo> You can use any boolean expression as a guard already, can't you?
07:07:54 <zygoloid> Jafet: foo ($(regexMatcher "(.*)foo(.*)") -> (pre, post)) = ...
07:07:55 <benmachine> yes
07:08:17 * ski foremost thinks we should have failing patterns for symmetry reasons (similar to why we should allow declaration of empty type)
07:08:33 <Cale> (the only purpose of that always-False guards I've used was either in using magical things like Debug.Trace, or slightly-less-magical things like seq)
07:08:53 <zygoloid> Cale: i've used always-false guards to give partial type signatures
07:09:48 <theorbtwo> > foo undefined = "undef" in foo undefined
07:09:49 <benmachine> ski: I'm in favour of avoiding syntax clutter though
07:09:49 <lambdabot>   <no location info>: parse error on input `='
07:10:11 <benmachine> it's already sometimes hard to find good operator names
07:10:16 <Cale> or-patterns are conceptually a good idea, but I'm not entirely convinced that it's worth the additional syntax they'd eat up.
07:10:32 <Cale> We already have few enough available short infix operators
07:10:36 <ski> they'd reduce code duplication, in some cases
07:10:41 <zygoloid> how do you deal with bindings in or-patterns?
07:10:49 <benmachine> that's a good question
07:10:52 <ski> easy
07:11:08 <benmachine> you have to require all the bindings to be the same type?
07:11:11 <ski> either insist each branch binds the same variables; or take the intersection of the bound variables
07:11:11 <Cale> I've seen some convincing use-cases like in doing certain sorts of tree-balancings.
07:11:19 <Cale> But they seem kind of rare
07:11:31 <zygoloid> fromMaybe a (Just b)|(const a -> b) = b
07:11:40 <zygoloid> s/|/umm something else/
07:12:14 <theorbtwo> That's part of the problem -- you kill global namespace this way.
07:12:34 <theorbtwo> ...and that example you can just as easily write as two seperate equations.
07:13:02 <zygoloid> only because duplicating the RHS in this case is cheap
07:13:19 <theorbtwo> Yeah, well, duplicating the RHS is always cheap -- make it a named function.
07:13:57 <ski> <http://rosettacode.org/wiki/Pattern_Matching#OCaml>
07:14:27 <zygoloid> theorbtwo: if that's cheap enough then the extension seems to have no value, i agree. but that seems subjective
07:15:08 <ski> (with enough local variables to pass on to the named function, it gets irritating)
07:15:09 <Cale> ski: Right, that very piece of code is the only convincing example of or-patterns I've actually seen.
07:15:41 <Cale> and as such, it seems like a rare enough condition not to be worth using up syntax on it.
07:16:33 <Cale> (unless someone can come up with something particularly clever in that regard...)
07:17:53 <theorbtwo> The useful case of or patterns would probably be multiple or patterns, since the alternative is writing out a cartesian product.
07:18:05 <Cale> Maybe re-use the 'else' keyword?
07:24:18 <ski> (i can't seem to find where i cluttered down some notes on this, but at least i think that when you write `at : {A : Set} {n : Nat} -> Fin n -> Vec A n -> A' and then `at FZero ()' in Agda, that really means `foo FZero ^ = ^', where `^' here stands for the failing pattern)
07:24:55 <roconnor> preflex: seen greenrd
07:24:55 <preflex>  Sorry, I haven't seen greenrd
07:25:25 <ski> (er, s/foo/at/. the idea being that having matched the first argument with `FZero', there's no possibly case for the second argument, so the failing pattern covers all cases there)
07:30:37 <ManateeLazyCat> I have library that have many small pure function, and have some bigger pure function include some small functions. Because those function is pure function, i need transform old value to function and return new value. But problem is, in bigger function, i always do below action: let fooA = funA foo; ... some code ...; let fooB = funB fooA; fooC = funC fooB.
07:31:15 <ManateeLazyCat> like list action for fooA, but important is i need fooC.
07:31:41 <ManateeLazyCat> Have any way make my life easier?
07:33:13 <Cale> I don't think I understand the question.
07:33:37 <roconnor> let fooC = funC . funB . funA $ foo  ?
07:33:45 * ManateeLazyCat pasted "Example code." at http://paste2.org/get/718520
07:33:48 <aavogt>  (fooB,fooC) = f fooA        where  f x = let a = funB x in (a,funC a)
07:33:52 <ManateeLazyCat> Cale: Above example code.
07:34:14 <ManateeLazyCat> Cale: Have wList, wList', wList''
07:34:26 <aavogt> if it happens that you only use  funB and funC together like that
07:34:54 <ManateeLazyCat> Cale: Have a way make me don't generate those wList''''' ?
07:35:31 <roconnor> ManateeLazyCat: you could slap a StateT wrapper around it ... I'm not sure this is really better though
07:35:33 <aavogt> ManateeLazyCat: if you don't need the original ones, you can reuse the old names
07:35:38 <Cale> So long as you're not using the intermediates elsewhere, why define them at all?
07:35:47 <roconnor> aavogt: good point
07:35:57 <dantheman_> Hey, I have an application (http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=23989#a23989) that forks a separate printer thread,  waits in the main thread for input from the user to a prompt, and then kills both threads. Does anyone know how I could change this so that the output of both threads is directed to 2 SEPARATE console windows?
07:36:11 <dantheman_> Thanks.
07:36:12 <Cale> Though, you do seem to use each of them for something else.
07:36:12 <ManateeLazyCat> aavogt: reuse the old names?
07:36:21 <aavogt> but you might hate yourself for shadowing names when you decide to reorganize your functions
07:36:25 <Cale> I don't recommend shadowing.
07:36:26 * hackagebot explicit-sharing 0.6 - Explicit Sharing of Monadic Effects  http://hackage.haskell.org/package/explicit-sharing-0.6 (SebastianFischer)
07:36:44 <Cale> It'll just make things more confusing without actually helping anything.
07:37:02 <aavogt> well it's no worse than adding so many apostrophes
07:37:04 <ManateeLazyCat> aavogt: I always need transform parameter *in* and *out*.
07:37:04 <roconnor> Cale: In this case I might advocate it, so you don't accidentally use the wrong name when modifying the code
07:37:14 <ManateeLazyCat> aavogt: It's boring.
07:37:20 <roconnor> Cale: so yes it could help things
07:37:26 <dantheman_> anyone?
07:37:47 <aavogt> then if you want the same parameter in and out, as we said, use pointfree or StateT
07:37:50 <Cale> You need the original wList for the second windowNew line, you only use wList' to define wList'', but you can't eliminate its definition easily, because it's bound as the second part of a triple.
07:37:55 <roconnor> ManateeLazyCat: is windowNew your code or a library function?
07:38:07 <dantheman_> I'm guessing I have to start a new process to create a separate console window?
07:38:15 <mreh> dantheman_: tail on two log files :)
07:38:24 <ManateeLazyCat> roconnor: My code.
07:38:30 <Cale> however, you only use wList'' to define newWindowList, so you could eliminate the definition of wList''
07:38:41 <Cale> and just write
07:38:45 * ManateeLazyCat pasted "Library" at http://paste2.org/get/718528
07:38:49 <ManateeLazyCat> roconnor: Above
07:38:54 <ManateeLazyCat> roconnor: My library.
07:39:05 <Cale> let newWindowList = windowListFocus (windowListRemoveWindow wList') windowChild1
07:39:18 <dantheman_> mreh... sorry I think that went over my head :)
07:39:22 <Cale> Now you don't have wList'' anymore
07:39:37 <mreh> dantheman_: the unix command "tail"
07:40:05 <ManateeLazyCat> Cale: I know that. But problem, i found library is very ugly style.
07:40:10 <dantheman_> ahh.. Unfortunately I'm working on windows for my sins!
07:41:06 <ManateeLazyCat> Cale: At the beginning, function parameter `WindowList` and  `WindowNodeList` is `IORef WindowList` and `IORef WindowNodeList`.
07:41:12 <tumult> question: if i want to insert the date ghc built my source as a string somewhere in a source file, how do i do that?
07:41:16 <ManateeLazyCat> Cale: Then i found it's a bad idea.
07:41:30 <ManateeLazyCat> Cale: I update those value in every functions.
07:41:48 <ManateeLazyCat> Cale: Speical when i IORef not safe in multi-thread.
07:41:55 <dantheman_> Nice idea though!
07:42:06 <Cale> tumult: Write a shellscript wrapper around GHC?
07:42:15 <ManateeLazyCat> Cale: So i do refactory today, and convert `IORef WindowList` to `WindowList`.
07:43:16 <ManateeLazyCat> roconnor: From my library, use StateT wrap is good idea?
07:43:20 <tumult> Cale: is there a way to do it without shell scripts? since i build on both windows and linux
07:43:31 <mreh> dantheman_ why do the messages need to go to two separate windows?
07:43:52 <Cale> tumult: Write a Haskell program which is a wrapper around GHC?
07:44:06 <Cale> tumult: I'm pretty sure GHC doesn't have that specific feature
07:44:16 <tumult> ok :)
07:44:20 <tumult> thanks
07:44:31 <ManateeLazyCat> roconnor: http://paste2.org/get/718528 is good style? Or any suggestion to improve?
07:45:03 <Cale> ManateeLazyCat: Somehow there are a lot of tuples in your code...
07:45:27 <Cale> also a lot of IO, though it might be hard to extract that.
07:45:47 <roconnor> ManateeLazyCat: one possiblity, though I'm not sure it is better: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23992#a23992
07:45:52 <dantheman_> Hey mreh... its just that I want to have one window accepting a stream of input data (stock ticks in my real app), and then use the other window to display a command prompt to control
07:45:57 <ManateeLazyCat> Cale: Yep. At the beginning, i use IORef as function parameter, after refactory, so many function return tuple for keep same mean.
07:46:01 <dantheman_> what to do in response to that data
07:46:09 <roconnor> ManateeLazyCat: I looks to me like you need more data structures
07:46:42 <dantheman_> Having everything going to a single screen results in new input ticks pushing the command prompt off the screen
07:46:49 <mreh> dantheman_ I think I would tail on a log file personally, there must be a windows equiv where it reads the file as it is written to
07:47:00 <roconnor> ManateeLazyCat: in my code example the return type of windowNew would need to be rearranged
07:48:00 <mreh> unix is the perfect operating system, you could fork a new process and then pick it up with another terminal
07:48:04 <BorisL> Hi all! How can I do some IO using LLVM bindings? Wrapping haskell IO functions into CodeGenFunction does not work.
07:48:19 <roconnor> ManateeLazyCat: in fact you might want to make it return StateT WindowList IO (Window,WindowNodeLIst)
07:48:21 <dantheman_> mreh. ok. How would I go about calling that from haskell though.i.e. is there some standard way to call outside programs
07:48:33 <roconnor> ManateeLazyCat: in fact you may want to put even more stuff into the State
07:48:34 <mreh> dantheman_ try the System library
07:48:44 <mreh> the System package, pardon
07:48:51 <mreh> it's in the base library
07:49:12 <dantheman_> ah ok, sounds like what I want. I'm guessing I'll need some kind of forkProcess command instead of forkIO though no?
07:49:14 <mreh> I'm not an expert on doing these things in haskell
07:49:18 <ManateeLazyCat> roconnor: I just want my code is easier to read, and don't so much foo''''
07:49:40 <roconnor> ManateeLazyCat: this is the common way to do it
07:49:44 <roconnor> use a state monad
07:50:00 <mreh> there is only one State monad
07:50:11 <mreh> and there shall be no other before it
07:50:20 <roconnor> mreh: State Bool and State Int are not the same monad
07:50:25 <mreh> d'oh
07:50:34 <mreh> State s is the monad
07:50:36 <xerox> technically neither are :D
07:50:37 <mreh> surely
07:50:38 <roconnor> ]:D
07:50:50 <mreh> I knew i was right
07:51:06 <roconnor> xerox: why not?
07:51:07 <xerox> :x I am wrong
07:51:17 <mreh> a monad is a functor
07:51:25 <roconnor> mreh: State s is not well formed in the empty context
07:51:44 <ManateeLazyCat> roconnor: I see, you use StateT wrap `windowList`, then i can use `modify` instead *temporary* variable that don't need return.
07:51:48 <ManateeLazyCat> roconnor: Right?
07:51:55 <roconnor> ManateeLazyCat: yes
07:52:03 <mreh> I'm not a mathematician, so I'll defer to your confidence
07:52:18 <roconnor> :D
07:52:28 <roconnor> I am a mathematician ;)
07:52:45 <bremner_> [citation needed] :)
07:52:50 <ManateeLazyCat> roconnor: Oh, If i use runStateT in function, i got flexibility and never change this function interface?
07:53:14 <roconnor> ManateeLazyCat: I had to change the signature a bit to use nested tupples
07:53:46 <roconnor> and windowNew would also need to rearrange it's signature to match that expected by StateT
07:53:56 <roconnor> so I don't really know if this is the best way to proceed
07:54:16 <roconnor> ManateeLazyCat: but it seems like you have a lot of state that ought to be wrapped up in a state monad anyways.
07:54:39 <ManateeLazyCat> roconnor: I don't want StateT in function signature, because that maybe failed with some gtk2hs event code.
07:54:59 <roconnor> ManateeLazyCat: newNodeList looks like it could be in the state too
07:54:59 <ManateeLazyCat> roconnor: Yes. I have many state.
07:55:19 * ManateeLazyCat pasted "My State types." at http://paste2.org/get/718551
07:55:19 <roconnor> make a nice record data type for your state
07:55:37 <ManateeLazyCat> roconnor: http://paste2.org/get/718551 My types code.
07:57:26 <ManateeLazyCat> roconnor: In outside, if i use those update state is boring, example, i use IORef keep state reference, i need use `readIORef` then transform to fucntion, after function computation, i need use `writeIORef` update state.
07:58:01 <ManateeLazyCat> roconnor: So i got many `readIORef` and `writeIORef` on those IO functions.
07:58:07 <roconnor> ok
07:59:40 <ManateeLazyCat> roconnor: I think use StateT keep status in fucntion, remove *temporary* variable.
08:00:09 * ManateeLazyCat pasted "Outside." at http://paste2.org/get/718562
08:00:28 <ManateeLazyCat> roconnor: Example, above function use many `readIORef` and `writeIORef`.
08:00:34 * hackagebot Data-Rope 0.1 - Ropes, an alternative to (Byte)Strings.  http://hackage.haskell.org/package/Data-Rope-0.1 (PierreEtienneMeunier)
08:03:17 <BorisL> Has anyone used LLVM?
08:06:34 <tsou> Is there a prettier name for ((,) x)?  I see that (,x) is invalid..
08:06:34 <ManateeLazyCat> roconnor: Looks use `runStateT` _in_ function remove all *temporal* variable. Thank you! :)
08:06:39 <BorisL> How can I do some IO using LLVM bindings?
08:07:33 <BorisL> tsou: Use -XTupleSections. It will make (,x) valid
08:07:39 <ski> (tsou : actually, `(,) x' would corresponds to `(x,)', if it were valid .. you can try `Writer x', instead)
08:08:12 <ski> (oh, right, /me forgot about `TupleSections')
08:08:14 <tsou> actually, what I need is (\x -> (2,x))
08:08:18 <tsou> BorisL: thanks
08:08:23 <Botje> tsou: let (==>) = (,) in (x==>) >:)
08:08:27 <roconnor> @pl  (\x -> (2,x))
08:08:27 <lambdabot> (,) 2
08:08:38 <tsou> any idea why they are invalid by default?
08:08:52 <ski> (or, hm .. maybe you meant at *expression*-level, not type-level)
08:08:53 <Botje> probably because haskell98 doesn't like them.
08:10:13 <tsou> heh ok, thanks
08:10:16 <lysgaard> I want to submit a form on a webpage in program, with haskell. Is there any good way to do that?
08:16:41 * ManateeLazyCat Using StateT improve my code. Thanks all for help! Bye.
08:16:48 <GaMer13> Whenever I run a wxHaskell driven .exe file it says: "Failed to load shared library 'comctl32.dll'
08:17:13 <GaMer13> Even when I put the .dll in the same dir
08:18:55 <nff> GaMer13, you can use Dependency Walker to check a program's dependencies
08:19:26 <nff> there might be missing symbols if the file is not at the expected version or not exporting a function
08:21:24 <cads> @hoogle xor
08:21:24 <lambdabot> Data.Bits xor :: Bits a => a -> a -> a
08:21:34 <GaMer13> And how do I know which version is required?
08:21:55 <xerox> cads: (/=)
08:22:21 <GaMer13> Dependency Walker doesn't give an error @ comctl32.dll...
08:23:35 <nff> GaMer13, sorry that's about the extent of my knowledge on DLL Hell :-/
08:24:03 <GaMer13> kj no problem :)
08:26:31 <GaMer13> @nff: I solved it =) Thanks to you
08:26:32 <lambdabot> Unknown command, try @list
08:26:41 <GaMer13> nff: I solved iit :) Thanks to you
08:27:06 <GaMer13> It appeared that comctl32.dll depended on 2 other .dll files which could not be found =)
08:27:06 <nff> cool :)
08:27:06 <cads> let xor (\ a b -> (a && (not b)) || (b && (not a))) in map (uncurry xor) [(True,True), (False, False), (True, False)]
08:27:11 <cads> > let xor (\ a b -> (a && (not b)) || (b && (not a))) in map (uncurry xor) [(True,True), (False, False), (True, False)]
08:27:12 <lambdabot>   <no location info>: parse error on input `in'
08:27:16 <cads> dang
08:27:21 <cads> sorry for flooding
08:28:56 <fizruk> test
08:29:02 <cads> let xor=  (\ a b -> (a && (not b)) || (b && (not a))) in map (uncurry xor) [(True,True), (False, False), (True, False)]
08:29:12 <cads> oh fer pete's sake
08:29:16 <cads> >  map (uncurry (/=)) [(True,True), (False, False), (True, False)]
08:29:17 <lambdabot>   [False,False,True]
08:29:40 <cads> xerox, heh, thanks for the mini-epiphany
08:29:51 <lysgaard> Anyone know how to fill in webforms in haskell. I need to login to a webpage, and then download the html file after the login.
08:31:22 <amuller> Hello, do you know any elegant way of building a map of maps M.Map  Int (M.Map Int MyObject) ?
08:32:11 <sw17ch> amuller: are those Int's going to be different values?
08:33:11 <amuller> hello sw17ch, yes they will have different values. In fact the first Int is going to be a datatype (an enum?)
08:33:22 <amuller> I put the Int to simplify the representation
08:33:48 <sw17ch> amuller: an elegant representation is going to be based largely on how you generate the contents :\
08:34:17 <roconnor> M.Map a (M.Map b c)  is isomorphic to M.Map (a,b) c
08:34:32 <amuller> I would like to know an elegant way of building the Map of Maps instead :)
08:34:44 <roconnor> amuller: just build it the usualy way
08:34:46 <roconnor> :)
08:34:52 <sw17ch> i use fromList in almost every case
08:34:53 <roconnor> usual
08:34:58 <roconnor> perfect
08:35:07 <sw17ch> M.fromList [(a,b),(c,d),(e,f)] -- etc...
08:35:11 <roconnor> fromList is a fine way to build maps
08:35:24 <amuller> roconnor, it is isomorphic, but I want to do binary splitLookups on the second map, (I want to ignore the data in the other maps).
08:36:29 * ski notes that `Foo' in `data Foo f a = forall b. MkF (b -> a) (f b)' is both a `Functor2' and a `Monad2' .. apart from `Foo f' being a `Functor'
08:36:44 <amuller> Doing a M.Map (a,b) c would make it easier to create the Map I guess. :)
08:37:11 <roconnor> sw17ch: maybe I should ask what is inelegent about what you have tried?
08:37:32 <sw17ch> updating is inelegant
08:37:34 <sw17ch> :\
08:37:55 <roconnor> why?
08:38:12 <sw17ch> i always feel like it us with nested maps
08:38:21 <sw17ch> but then again, i don't like nested structures
08:38:26 <sw17ch> so my opinion is biased
08:38:34 <amuller> roconnor: Well if I want to create a map of maps I was thinking about using inserts.
08:38:35 <sw17ch> i like _recursive_ structures
08:38:57 <amuller> One question, if I use a tuple (Enum, Int) is it going to be automatically ordered?
08:39:03 <roconnor> yes
08:39:07 <amuller> Ordered first by the Enum and then by the Int?
08:39:07 <roconnor> @instances Ord
08:39:08 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), (a, b, c, d, e), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
08:39:20 <roconnor> amuller: probably
08:39:52 <sw17ch> > sort [('z',10),('a',10)]
08:39:53 <lambdabot>   [('a',10),('z',10)]
08:39:58 <sw17ch> > sort [('z',1),('a',10)]
08:39:59 <lambdabot>   [('a',10),('z',1)]
08:40:19 <amuller> OK! thank you sw17ch and roconnor
08:41:26 <zygoloid> @check \a b c d -> ([a, b] < [c, d]) == ((a :: Int, b) < (c, d))
08:41:27 <lambdabot>   "OK, passed 500 tests."
08:42:15 <quicksilver> amuller: well. Enums are not ordered.
08:42:29 <quicksilver> amuller: however, probably all the Enums you are thinking of happen to also be Ord.
08:42:56 <quicksilver> and for any custom data type for which you can derive Enum you can certainly derive Ord.
08:43:07 <zygoloid> for any Enum, there's "comparing fromEnum", but that's not necessarily a sensible compare
08:43:50 <zygoloid> > comparing fromEnum 1.9 1.2
08:43:52 <lambdabot>   EQ
08:44:26 <roconnor> god
08:44:38 <roconnor> floating points should not be in enum
08:45:04 <roconnor> the only reason they are are is to support the [a..b] stuff and even that is so bad no sane person uses it.
08:45:12 <trzkril> > fromEnum 1.9
08:45:13 <lambdabot>   1
08:45:30 <zygoloid> > sortBy (comparing fromEnum) (take 20 $ randomRs (0.0, 10.0) (mkStdGen 10))
08:45:31 <lambdabot>   [0.31531216467621537,0.10011189968793488,0.30365215505092724,2.070685673288...
08:45:37 <theorbtwo> [a..b] shouldn't really work on floats...
08:45:45 <roconnor> no it shouldn't
08:46:40 <theorbtwo> Well, actually, it'd be kind of cool if it would create a Range Float instead of a [Float].
08:47:03 <cads> we have Ranges?
08:47:16 <theorbtwo> cads: Well, you *could* have ranges...
08:47:21 * cads goes off to inspect!
08:47:49 <roconnor> > inRainge (exp 1, pi) 3
08:47:50 <lambdabot>   Not in scope: `inRainge'
08:47:53 <roconnor> > inRange (exp 1, pi) 3
08:47:54 <lambdabot>   Ambiguous type variable `t' in the constraints:
08:47:54 <lambdabot>    `GHC.Arr.Ix t'
08:47:55 <lambdabot>      aris...
08:48:07 <cads> hehe
08:48:27 * theorbtwo would expect haskellian ranges to support inclusive and exclusive.
08:48:51 <zygoloid> > sortBy (comparing fromEnum) (take 20 $ randomRs (0, 10^30 :: Integer) (mkStdGen 10))
08:48:52 <lambdabot>   [814157911569660928749169656853,145627940800921623065370471661,257613490694...
08:48:53 <roconnor> meh, determining if you are on the endpoint is undecidable in general.
08:48:55 <zygoloid> > 814157911569660928749169656853 < 145627940800921623065370471661
08:48:57 <lambdabot>   False
08:49:00 <applicative> > let {a = 1.52 :: Float ; b = 3.74 } in [a..b
08:49:01 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
08:49:02 <applicative> > let {a = 1.52 :: Float ; b = 3.74 } in [a..b]
08:49:03 <lambdabot>   [1.52,2.52,3.52]
08:49:45 <theorbtwo> roconnor: In general, if something is impossible in general, then you are being a little too general.
08:49:49 <cads> > inc 1.32
08:49:50 <lambdabot>   Not in scope: `inc'
08:49:55 <applicative> that is kind of gross [1.52..2.37]
08:49:55 <zygoloid> theorbtwo: impossible!
08:49:58 <cads> > succ 1.32
08:49:59 <lambdabot>   2.3200000000000003
08:50:09 <applicative> yick
08:50:15 <cads> hehe ...003
08:50:33 <cads> > (1.32, 1.32+1)
08:50:34 <lambdabot>   (1.32,2.3200000000000003)
08:50:38 <zygoloid> > last $ [1, 1.01.. 2.005]
08:50:39 <lambdabot>   2.000000000000001
08:50:40 <zygoloid> > last $ [1, 1.01.. 3.005]
08:50:41 <applicative> I guess it must have some use
08:50:41 <lambdabot>   3.0099999999999794
08:50:57 <theorbtwo> Welcome to the Floats are Icky problem.
08:51:08 <applicative> > [1.52, 4.52..8.37]
08:51:09 <lambdabot>   [1.52,4.52,7.52]
08:51:27 <cads> I was looking at the class hierarchy for numbers the other day and scratching my head as to why the floats are in enum
08:51:35 <zygoloid> instance Enum Float where enumFromThenTo = error "You fail at floating point"
08:51:36 <applicative> I folow the advice of the masters and avoid them
08:51:54 <roconnor> applicative: nope, no uses
08:52:23 <applicative> what do you use instead, fractional things?
08:52:32 <theorbtwo> Of course, the problem with floats demonstrated here is that they *are* enumerable.
08:52:36 <cads> applicative, floats are great when you need an approximation to the real numbers that don't have to act _just_ like them
08:52:44 <ken17612> Hi.  How do I read 4 bytes out of stdin and get an Data.Word32?
08:52:44 <roconnor> cads: floats in enum will be the first against the wall when the Caleskell revolution happens!
08:52:55 <zygoloid> instance Enum Float where succ = unsafeCoerce . (succ :: SignMagnitudeInt32 -> SignMagnitudeInt32) . unsafeCoerce
08:53:06 <theorbtwo> -XNoEnumFloat?
08:53:26 <zygoloid> next greater representable float ftw
08:53:30 <roconnor> zygoloid: decodeFloat/encodeFloat is more portable
08:53:35 <cads> now, hmm..  lets see.
08:53:46 <zygoloid> roconnor: but less fun :)
08:53:49 <roconnor> zygoloid: oh right, that doesn't quite work
08:53:49 <cads> > [1.0, 1.2 .. 3]
08:53:50 <lambdabot>   [1.0,1.2,1.4,1.5999999999999999,1.7999999999999998,1.9999999999999998,2.199...
08:54:10 <roconnor> cads: the errors accumulate even!
08:54:16 <cads> yeesh
08:54:23 <applicative> aybe a revisionist Caleskellism won't ban them outright  but require -XEnumFloat
08:54:25 <aavogt> theorbtwo: that would be more or less -XNoImplicitPrelude, and then importing a variation of the Prelude that doesn't have that instance
08:54:37 <Jafet> Carefully specialize enumFromTo!
08:54:44 <zygoloid> > [1.0, 1.2..] !! 500000
08:54:45 <lambdabot>   100000.99999871319
08:54:50 <ski> > [1 , 1.05 .. 1.205] :: [CReal]
08:54:51 <lambdabot>   [1.0,1.05,1.1,1.15,1.2]
08:55:05 <aavogt> applicative: why make it a flag? Why not just require an    import Enum.Unsafe.Float?
08:55:15 <applicative> okay
08:55:27 <cads> > map ((+1).(*0.2)) [0, 10]
08:55:28 <lambdabot>   [1.0,3.0]
08:55:35 <cads> > map ((+1).(*0.2)) [0.. 10]
08:55:36 <lambdabot>   [1.0,1.2,1.4,1.6,1.8,2.0,2.2,2.4000000000000004,2.6,2.8,3.0]
08:55:39 <Jafet> It's Lesssafe
08:55:54 <cads> that's better.
08:55:56 <Jafet> As in every time you use it, Cale appears and tasers you
08:56:11 <aavogt> but as described, it's sort of awkward to do currently because you can't control the import of instances
08:56:28 <zygoloid> > iterate (uncurry encodeFloat . first succ . decodeFloat) 1.0
08:56:29 <lambdabot>   [1.0,1.0000000000000002,1.0000000000000004,1.0000000000000007,1.00000000000...
08:56:32 <applicative> > map ((+1).(*0.2)) [0.. 10] -- obviously the devil at work
08:56:33 <lambdabot>   [1.0,1.2,1.4,1.6,1.8,2.0,2.2,2.4000000000000004,2.6,2.8,3.0]
08:57:02 <cads> applicative, you talking about the .....0004?
08:57:15 <applicative> I'm really sorry to learn about this dirty secret of the Float Enum instance
08:57:30 <applicative> cads, yes,
08:57:45 <theorbtwo> Ot
08:57:47 <zygoloid> would be nice if you could say "import Prelude hiding (instance Enum Float)"
08:57:58 <cads> well, that's just
08:58:03 <theorbtwo> it's not so much a problem with Float Enum as a general problem with floats.
08:58:06 <cads> > 1 + 7*0.2
08:58:07 <lambdabot>   2.4000000000000004
08:58:18 <zygoloid> theorbtwo: floats are fine as long as you don't think they're reals
08:58:53 <applicative> zygloid, but you have to figure out what they are.  It's too disturbing to think about.
08:58:55 <aavogt> zygoloid: hmm, how would that properly work since other modules sort of re-export instances in the prelude...
08:58:56 <roconnor> and most certainly don't think of reals an enum
08:59:17 <cads> I bet floats are engineered to have some nice stability properties, considering
08:59:20 <sepp2k> If I call show 1, how does haskell decide which version of show to call?
08:59:30 <roconnor> sepp2k: based on the type of 1
08:59:40 <aavogt> no, there is defaulting to integer
08:59:45 <roconnor> sepp2k: in this case it uses defaulting declairations
08:59:49 <applicative> sepp it defaults if you just write show 1
08:59:54 <cads> roconnor, I was reading crank proofs stating the reals were countable, the other day :)
08:59:55 <applicative> > show 1
08:59:56 <lambdabot>   "1"
09:00:11 <aavogt> @type (\x -> (show x,x)) 1
09:00:12 <lambdabot> forall a. (Num a) => (String, a)
09:00:22 <theorbtwo> zygoloid: Yeah, sure, but the problem is that you can't always add one to a float and get what you think you would.  Enum Float is just an interface to adding one.
09:00:27 <theorbtwo> :t 1
09:00:28 <lambdabot> forall t. (Num t) => t
09:00:46 <roconnor> If no default declaration is given in a module then it assumed to be:
09:00:48 <roconnor>   default (Integer, Double)
09:01:01 <roconnor> The empty default declaration, default (), turns off all defaults in a module.
09:01:05 <cads> hmm, given a iee float number, can we easily calculate the next largest representable iee float?
09:01:14 <theorbtwo> cads: Reasonably easily, yes.
09:01:21 <applicative> > let a = 1.25 :: Float in [1.25, 1.37 ... 3.45]
09:01:22 <lambdabot>   Not in scope: `...'
09:01:26 <applicative> > let a = 1.25 :: Float in [1.25, 1.37 .. 3.45]
09:01:27 <lambdabot>   [1.25,1.37,1.4900000000000002,1.6100000000000003,1.7300000000000004,1.85000...
09:01:38 <roconnor> cads: it can be done with a bit of complex decodeFloat, mantisia succ
09:01:41 <roconnor> calculuations
09:01:46 <applicative> It doesn't have to just add one...
09:02:00 <roconnor> cads: I don't know if that counts as easy
09:02:02 <theorbtwo> For most values, it's a matter of modifying the LSB of the mantisia.
09:02:23 <theorbtwo> It's certianly something that you can easily wrap in a simple function.
09:02:24 <cads> roconnor, sounds reasonable
09:03:06 <theorbtwo> The hard bit, as per ususal with floats, is what you do with NaNs (which are unordered), and the various zeros.
09:03:29 <applicative> > let a = 1.25 :: Float in map sqrt [1.25, 1.37 .. 2.45]
09:03:30 <lambdabot>   [1.118033988749895,1.1704699910719625,1.2206555615733703,1.2688577540449522...
09:03:30 <theorbtwo> Oh, and, IIRC, there's a +/- inf.
09:05:10 <applicative> > let a = 1.25 :: Float in map (\x -> x / (x - 1.37)) [1.25, 1.37 .. 2.45]
09:05:11 <lambdabot>   [-10.416666666666657,Infinity,12.416666666666657,6.708333333333329,4.805555...
09:05:27 <applicative> i think indinity has nothing to do with it
09:05:31 <applicative> infinity
09:06:01 <cads> wonder what branch of math you'd want to pick up if you just wanted to understand the crap out of floating point numbers
09:08:03 <Jafet> Not point-free topology, I can tell you
09:09:03 <cads> no points, not even floating ones :)
09:09:19 <roconnor> > foldr f z [a,b,c]
09:09:20 <lambdabot>   f a (f b (f c z))
09:09:22 <sepp2k> roconnor: applicative: Thanks, I didn't know about the default declaration.
09:09:34 <meanburrito920_> quick question: I'm trying to figure out how bind works by messing around with it, but I am still a bit confused. Why does the following not work?
09:09:41 <meanburrito920_> > Just 1 >>= id
09:09:42 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe b))
09:09:42 <lambdabot>    arising from the lite...
09:09:51 <meanburrito920_> but > Nothing >>= id
09:09:54 <meanburrito920_> oops
09:09:58 <meanburrito920_> > Nothing >>= id
09:09:59 <lambdabot>   Nothing
09:10:02 <meanburrito920_> that works fine
09:10:05 <meanburrito920_> why is this?
09:10:42 <roconnor> meanburrito920_: Nothing >>= id works because it infers that Nothing has type Maybe (Maybe a)
09:10:43 <int-e> @type Nothing >>= id
09:10:45 <lambdabot> forall b. Maybe b
09:10:58 <dumael> cads: numerical analysis I think, Prof Kahn was heavily involved with floating point / IEEE754, and has notes/lectures on it. http://www.eecs.berkeley.edu/~wkahan/
09:11:02 <int-e> @type \a -> Nothing `asTypeOf` a >>= id
09:11:04 <lambdabot> forall b. Maybe (Maybe b) -> Maybe b
09:11:36 <ski> > Just Nothing >>= id
09:11:37 <lambdabot>   Nothing
09:11:45 <ski> > Just (Just '!') >>= id
09:11:46 <lambdabot>   Just '!'
09:11:51 <applicative> roconnor, cool about Nothing >>= id
09:12:07 <roconnor> (>>= id) is the definition of join
09:12:10 <roconnor> @src join
09:12:10 <lambdabot> join x =  x >>= id
09:12:16 <meanburrito920_> wait, so the Maybe's have to be nested for it to work properly?
09:12:20 <meanburrito920_> as in ski's example?
09:12:23 <ski> yes
09:12:26 <meanburrito920_> ah
09:12:33 <ski> (and `Nothing' is an example of that)
09:12:36 <meanburrito920_> right
09:12:37 * twink remembers JAVAhurt.pdf
09:12:42 <meanburrito920_> ok, that makes a lot more sense
09:12:43 <int-e> > Just 1 >>= return -- or perhaps you meant this?
09:12:44 <roconnor> > [[1],[2,3],[4,5,6] >>= id
09:12:45 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
09:12:45 <lambdabot>   Just 1
09:12:51 <roconnor> > [[1],[2,3],[4,5,6]] >>= id
09:12:52 <lambdabot>   [1,2,3,4,5,6]
09:13:04 <twink> "Why Java floating point hurts everyone everywhere all the time" or some such.
09:13:06 <int-e> @type (>>= id)
09:13:07 <lambdabot> forall (m :: * -> *) b. (Monad m) => m (m b) -> m b
09:13:11 <int-e> @type join
09:13:12 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
09:15:34 <applicative> hoq do I define (>>=) with join and return
09:15:37 <applicative> how
09:16:01 <roconnor> applicative: you need to use fmap
09:16:04 <ski> you don't need to use `return', but you do need to use `fmap'
09:16:35 <applicative> i see, so i start with a functor instance
09:16:57 <applicative> then 'pointed' then add join
09:17:04 <roconnor> sure
09:17:35 * ski wonders how useful `Functor2' and `Monad2' would be ..
09:18:16 <roconnor> Monad not being an instance of Functor will be second up against the wall during the Caleskell revolution.
09:18:36 <applicative> \me thinks that if you want things to be more rational and beautiful, `Functor2` isn't the way forward
09:18:37 <ski> (s/instance/subclass/)
09:18:51 <roconnor> ski: you'd have to use GHC's do notation overridding stuff
09:19:02 <Saizan> what would Functor2 be?
09:19:10 <ski>   class Functor2 t
09:19:12 <ski>     where
09:19:18 <ski>     fmap2 :: (forall b.   f b ->   g b)
09:19:24 <ski>           -> (forall a. t f a -> t g a)
09:19:26 <roconnor> oh
09:19:33 <roconnor> you mean a natural transformation?
09:19:41 <roconnor> er
09:19:43 <roconnor> hmm
09:19:55 <ski> my `Foo' is an instance of `Functor2' and `Monad2' (and `Foo f' is an instance of `Functor', for every `f')
09:20:04 <applicative> oh  i thought you were just going to use it to require it for Monad2
09:20:31 <ski> (`Foo' being `data Foo f a = forall b. MkF (b -> a) (f b)')
09:21:02 <amuller> thanks quicksilver and zygoloid
09:21:48 <ski> applicative : i invented it, to require for `Monad2', yes
09:21:59 <ski> (where `return2' is basically `lift' of `MonadTrans')
09:23:10 <ski> (roconnor : `fmap2' maps a natural transformation in `f >-> g' to a nat. transf. in `t f >-> t g', yes)
09:23:21 <twink> There's some combination of (***), (&&&), etc. yielding \(x, y) -> (f x, g x y)
09:24:01 <harlekin> When compoling a small module I wrote I get mkUsageInfo: internal name? [some symbols]. What is that?
09:24:40 <c_wraith> @hoogle finally
09:24:40 <lambdabot> Control.Exception finally :: IO a -> IO b -> IO a
09:24:41 <lambdabot> Control.OldException finally :: IO a -> IO b -> IO a
09:24:41 <lambdabot> Control.Exception.Base finally :: IO a -> IO b -> IO a
09:25:17 <c_wraith> Are there cases where finally doesn't work?  Some error conditions it doesn't handle?
09:30:40 <ski> @type \f g -> uncurry (uncurry (&&&) . ((const . f) &&& g))
09:30:41 <lambdabot> forall b c c' a. (a -> c) -> (a -> b -> c') -> (a, b) -> (c, c')
09:30:49 <ski> .. not really nice
09:31:26 <twink> there's nothing particularly convenient about piping it around with arrow stuff
09:31:34 <benmachine> @unpl \f g -> uncurry (uncurry (&&&) . ((const . f) &&& g))
09:31:34 <lambdabot> \ f g -> uncurry (\ d -> uncurry (&&&) (((\ i _ -> f i) &&& g) d))
09:31:45 <benmachine> that's um useless
09:32:25 <twink> It gets worse because the case needed has to clean up with \(x, (y, z)) -> (y, (x, z)) after (((+1) . fst) &&& uncurry splitAt))
09:33:20 <ken17612> > (hGet stdin 4) >>= (return . (runGet getWord32le))
09:33:21 <lambdabot>   Not in scope: `hGet'Not in scope: `stdin'Not in scope: `runGet'Not in scope...
09:33:40 <roconnor> @undo proc { a <- f <- x }
09:33:40 <lambdabot>  Parse error at "<-" (column 10)
09:33:47 <ski> @type \f g -> uncurry ((. flip ($)) . flip fmap . (f &&& g))
09:33:48 <lambdabot> forall b b1 a c. (a -> c) -> (a -> b -> b1) -> (a, b) -> (c, b1)
09:33:52 <ski> ^ another variant
09:34:30 <ski> (with mostly the same semantics)
09:34:38 <twink> All this to golf take 5 $ unfoldr (Just . (\(x, (y, z)) -> (y, (x, z))) . (((+1) . fst) &&& uncurry splitAt)) (1,[1..])
09:35:27 <Jafet> It has formal parameters!
09:35:54 <ski> > take 5 $ unfoldr (Just . (\(x, (y, z)) -> (y, (x, z))) . (((+1) . fst) &&& uncurry splitAt)) (1,[1..])
09:35:55 <lambdabot>   [[1],[2,3],[4,5,6],[7,8,9,10],[11,12,13,14,15]]
09:36:09 <twink> The lambda in there is intended to go away eventually.
09:38:13 <twink> Before I started golfing it was take 5 $ unfoldr (\(n, xs) -> let (ys, xs') = splitAt n xs in Just (ys, (n+1, xs'))) (1,[1..])
09:38:51 <ski> which sounds reasonable, i think
09:40:21 <twink> I was hoping something with arrow stuff could do the lambda but maybe not.
09:41:11 <twink> sqrt((1+cos(x))/2)
09:42:59 <ski> > take 5 $ let foo = ((+1) . fst) &&& uncurry splitAt in (tail . map (fst . snd) . iterate (foo . (id *** snd))) (foo (0,[1 ..]))
09:43:00 <lambdabot>   [[1],[2,3],[4,5,6],[7,8,9,10],[11,12,13,14,15]]
09:43:14 <ski> maybe you like that better ?
09:44:12 <ski> hm
09:44:17 <ski> > take 5 $ let foo = ((+1) . fst) &&& uncurry splitAt in (map (fst . snd) . iterate (foo . (id *** snd))) (foo (1,[1 ..]))  -- better
09:44:18 <lambdabot>   [[1],[2,3],[4,5,6],[7,8,9,10],[11,12,13,14,15]]
09:44:26 <twink> Looks better yeah.
09:47:24 <twink> id *** snd is second snd no?
09:48:39 <BONUS> yeah
09:49:49 <ski> hm, *nod*
09:54:44 <benmachine> it is hard thinking of categories for cabal
09:55:32 <fax> learn category theory
09:55:57 <theorbtwo> Er, not that sort of category.
09:56:02 <benmachine> :P
09:56:37 <theorbtwo> benmachine: Because the module is terribly abstract, or...?
09:56:51 <benmachine> theorbtwo: I'm just bad at categorising things :P
09:57:40 <benmachine> my program evaluates haskell expressions step-by-step, it is an educational tool
09:57:53 <mercury^> education, fun, debugging
09:58:08 <mercury^> But hugs can do that already btw.
09:58:16 <benmachine> hugs schmugs
09:58:26 <benmachine> >_>
09:58:30 * twink didn't know hugs could do that.
09:59:06 <mercury^> If you could make it so that you can click on a head to make it evaluate and have a "back" button, that'd be nice.
09:59:29 <benmachine> a back button'd be easy
09:59:51 <benmachine> telling it what to evaluate next, probably wouldn't be very hard
09:59:55 * twink doesn't see how to do it in hugs.
10:00:06 <ManateeLazyCat> /me It's a bad idea that make `IORef` as function argument, you lose flexibility, special when IORef can't work safely
10:00:06 <ManateeLazyCat> 																											  [00:59:20].
10:00:11 <mercury^> twink: well, someone told me it could do that, I never used hugs. :P
10:00:42 <benmachine> I believe hat can do something similar, but with the drawback that hat is ancient and unmaintained
10:00:50 <benmachine> and the auxiliary drawback that I can't claim credit for hat
10:00:53 <benmachine> <_<
10:00:56 <mercury^> =)
10:01:46 <malcolmw> on the other hand, I _can_ take credit for hat, but that doesn't change the fact that it has suffered bitrot and is unmaintained
10:01:59 <benmachine> oh hi
10:02:13 <benmachine> I did look at hat once but it required hmake and hmake didn't build
10:02:14 <ManateeLazyCat> I make IORef in every functions of my library, then i got bad thing.
10:02:29 <benmachine> and I sort of half-heartedly poked at it but never got anywhere
10:02:53 <mercury^> ManateeLazyCat: are you eastern european?
10:03:05 <applicative> harlekin: http://darcs.haskell.org/ghc-6.10/ghc/compiler/iface/MkIface.lhs  explains mkUsageInfo:   internal name?  good luck
10:03:11 <ManateeLazyCat> mercury^: No, Why?
10:03:38 <mercury^> What you said just sounded like it.
10:03:57 <mercury^> benmachine: still involved with tremulous btw?
10:04:23 <ManateeLazyCat> roconnor: I have know StateT can make code clearer, but how to convert code with StateT quickly? Any tips?
10:04:35 <ManateeLazyCat> mercury^: Hehe, I'm a Chinese. :)
10:04:43 <mercury^> Ah, k.
10:05:04 <benmachine> mercury^: yeah, although it's hard to motivate oneself to write C having been here for a few months :P
10:05:42 <mercury^> Hehe. I think C is quite a beautiful language though. Haskell is different and often more convenient, but not strictly better.
10:05:58 <ManateeLazyCat> roconnor: `StateT s m a`, IMO, m is Monad, s is State for update and don't need write variable explicitly, then return `a` as result after all.
10:06:34 <ManateeLazyCat> roconnor: But `s m a` confuse me. I can't convert code quickly.
10:07:11 <benmachine> well, I tend to miss higher-order functions, a lot
10:07:13 <ManateeLazyCat> roconnor: Maybe i'm not familiar with StateT.
10:07:18 <aavogt> preflex: seen ndm
10:07:18 <preflex>  ndm was last seen on #haskell 310 days, 6 hours, 48 minutes and 37 seconds ago, saying: plus with current compiler technology, it would be slower
10:08:12 <ManateeLazyCat> mercury^: If you develop Linux-Kernel, yes C is best. But if you develop application, Haskell is better.
10:08:24 <waterlaz> I'm having troubles configuring  Codec-Image-DevIL-0.2.0, can anyone help me?
10:08:30 <mercury^> I do not think it is that simple..
10:08:34 <waterlaz> it sais   * Missing C library: IL
10:08:59 <waterlaz> though pkg-config --libs IL
10:09:02 <waterlaz> works ok
10:09:24 <sclv> hi lazyweb -- quick question regarding gitit/darcsit. I'm running the latest version, and think I'm setting it to render a toc, but none is showing up. Is there some trick to it?
10:09:43 <mercury^> In general I think if you write an application, you should think about what it should do and how it should do it. Implementation and choice of language are secondary.
10:09:45 <benmachine> mercury^: I do like the simplicity of C, but I find myself missing things like generics and higher-order functions a lot
10:10:01 <mercury^> Higher order functions just don't fit the spirit of C.
10:10:39 <ManateeLazyCat> mercury^: Haskell make you thinking high-level, and focus on really problem, and haven't so much detail like C.
10:10:41 <fax> that's true
10:10:58 <Reisen> geordi, { const char *x = "Should work"; asm( "pushl %0\ncall printf\npopl %%eax" :: "m"(x) : "eax" ); }
10:11:02 <Reisen> Er
10:11:07 <fax> I think C could have pairs though
10:11:08 <Reisen> Wrong channel, sorry, my brain meltdowned
10:11:11 <ManateeLazyCat> mercury^: And you get clearer logic and less code.
10:11:20 <benmachine> if you choose a bad language you will spend time thinking about how to overcome its inadequacies rather than how to best develop your program
10:11:29 <fax> I guess polymorphism would be right out though
10:11:42 <benmachine> fax: structs are kind of pair-y
10:11:45 <waterlaz> mercury^, it's like saying that expressions don't fit the spirit of x86asm :)
10:11:59 <ManateeLazyCat> benmachine: Every language is need develop.
10:12:03 <fax> that's if you do programming and program design simultaneously benmachine, it's not the only way
10:12:23 <benmachine> fax: well however you do things, it will take longer in some languages than others
10:12:26 <ManateeLazyCat> benmachine: So why not improve it if it not inadequacies?
10:12:33 <fax> no I don't agree,
10:12:42 <fax> I think it will take less time in every language :P
10:12:49 <mercury^> benmachine: Yes, but C does not have that problem in my experience. I was never unable to make a C program do something I wanted it to do after a short amount of thinking.
10:13:30 <zachk>  let peasant' x y = let halving x = if x == 0 then [] else x : (halving (x `div` 2)) in let doubling x = x : (doubling (2*x)) in  sum $ map snd $ filter ( \(a,b) -> not $ even a) $ zip (halving x) (doubling y) in peasant' 25 25
10:13:33 <zachk> ahhhh
10:13:38 <zachk> >  let peasant' x y = let halving x = if x == 0 then [] else x : (halving (x `div` 2)) in let doubling x = x : (doubling (2*x)) in  sum $ map snd $ filter ( \(a,b) -> not $ even a) $ zip (halving x) (doubling y) in peasant' 25 25
10:13:40 <lambdabot>   625
10:13:45 <devinus> does anyone know where this new snap web framework code is being hosted?
10:13:59 <benmachine> mercury^: I just find operations like "multiply every element of this array by a number" and "add these two vectors" tend to take much more typing in C than they need to
10:14:04 <ManateeLazyCat> @pl \x -> x
10:14:05 <lambdabot> id
10:14:21 * hackagebot hxt 8.5.2 - A collection of tools for processing XML with Haskell.  http://hackage.haskell.org/package/hxt-8.5.2 (UweSchmidt)
10:14:28 <ManateeLazyCat> @pl \x -> f (g (h x))
10:14:29 <lambdabot> f . g . h
10:14:34 <c_wraith> zachk: CPUs already implement the russian peasant algorithm for integer multiplication.  (It's just multiplication with binary digits, anyway)
10:14:54 <benmachine> there is "what I am thinking" and "what my code says" and the gap between the two is larger in C than in haskell
10:15:05 <benmachine> but that's a vague idea
10:15:30 <ManateeLazyCat> @pl \x -> f x y
10:15:30 <lambdabot> flip f y
10:15:44 <mercury^> Funnily enough, when programming I usually think in pseudo assembler and then convert that into whatever language I work with.
10:15:48 <theorbtwo> All languages claim that, though, or at least almost all.
10:16:03 * fax doesn't know assembler
10:16:10 <benmachine> mercury^: I'm not sure whether to congratulate or commiserate you on that, but I think either way it's a rare thing :P
10:16:14 <theorbtwo> Good, modern C programmers claim that it's closer to the way the computer works, which is quite true...
10:16:22 * hackagebot hxt-filter 8.4.2 - A collection of tools for processing XML with Haskell (Filter variant).  http://hackage.haskell.org/package/hxt-filter-8.4.2 (UweSchmidt)
10:16:24 * hackagebot hxt-xpath 8.5.2 - The XPath modules for HXT.  http://hackage.haskell.org/package/hxt-xpath-8.5.2 (UweSchmidt)
10:16:31 <c_wraith> mercury^: does that feel more like thinking in the solution domain than the problem domain?
10:16:44 <benmachine> theorbtwo: yeah, it's a question of whether you want to make things easier for the computer or for yourself
10:16:55 <mercury^> c_wraith: I think one could say so, yeah.
10:17:14 <benmachine> theorbtwo: these days, correctness and development speed are becoming more important than efficiency, because resources are so cheap
10:17:23 * hackagebot hxt-xslt 8.5.2 - The XSLT modules for HXT.  http://hackage.haskell.org/package/hxt-xslt-8.5.2 (UweSchmidt)
10:17:28 <theorbtwo> benmachine: Oh, I quite agree.
10:18:23 * hackagebot hxt-cache 0.0.4 - Cache for HXT XML Documents and other binary data  http://hackage.haskell.org/package/hxt-cache-0.0.4 (UweSchmidt)
10:20:39 <waterlaz> does anyone know how cabal checks for installed C libraries?
10:22:57 <benmachine> waterlaz: no, but try the -v option
10:23:11 <benmachine> or -v2 oe -v3 I think if you want more information
10:23:14 <waterlaz> it looks like it does use pkg-config
10:23:29 * hackagebot scan 0.1.0.0 - lexical style suggestions for source code  http://hackage.haskell.org/package/scan-0.1.0.0 (ChristianMaeder)
10:23:57 <waterlaz> /usr/bin/gcc returned ExitFailure 1 with error message:
10:23:58 <waterlaz> /usr/lib/libIlmThread.so.6: undefined reference to `sem_init'
10:23:58 <waterlaz> /usr/lib/libIlmThread.so.6: undefined reference to `sem_destroy'
10:23:58 <waterlaz> /usr/lib/libIlmThread.so.6: undefined reference to `pthread_create'
10:24:12 <waterlaz> this is what I get  configuring a package
10:24:33 <waterlaz> how would something like that happen?
10:24:52 <profmakx> what ist Graphics.GenericFR?
10:25:06 <benmachine> waterlaz: sounds like you need -pthread
10:25:16 <benmachine> maybe try compiling -threaded?
10:36:11 <waterlaz> benmachine, fixed by adding a CPP-Options: -lpthread line into the cabal file
10:36:25 <benmachine> that's pretty weird
10:38:20 <waterlaz> yeah... I know, but it works
10:42:50 * benmachine ponders indentation in .cabal files
10:43:16 <benmachine> Extra-source-files is making me indent everything else ridiculously, maybe I should just ignore it
10:44:35 <jmcarthur> how is it making you indent things?
10:44:52 <benmachine> well, if I want things to line up
10:44:59 <jmcarthur> oh i see
10:45:01 <benmachine> which I don't necessarily, but it seems common to do so
10:45:03 <jmcarthur> because it's long
10:45:06 <benmachine> yes
10:45:20 <jmcarthur> you could just newline after Extra-source-files: and indent the same as everything else
10:45:49 <benmachine> mm, that kind of works
10:47:11 * benmachine decides to only line up vaguely related things
10:47:34 <HugoDaniel> hi
10:47:37 <benmachine> hi
10:47:42 <HugoDaniel> how do i convert a string from iso-8859-1 to UTF-8 ?
10:47:50 <roconnor> @tell ManateeLazyCat read "StateT s m a" as "(((StateT s) m) a)"  so (StateT s) is a monad transformer (of kind (* -> *) -> (* -> *) and ((StateT s) IO) is a monad (of kind * -> *) that has both IO and state operations.
10:47:50 <lambdabot> Consider it noted.
10:48:10 <Chaze> http://pastie.org/870632 is something buggy there?
10:48:17 <Saizan> HugoDaniel: there's utf8-string
10:49:05 <benmachine> Chaze: that's a little surprising - how did you define a?
10:49:15 <HugoDaniel> utf8-string is not working
10:49:35 <benmachine> HugoDaniel: not working how
10:50:08 <Saizan> HugoDaniel: how are you getting this string?
10:50:09 <Chaze> benmachine: by a little function that seems to behave oddly. Here: http://pastie.org/870637
10:50:12 <HugoDaniel> it can't handle the Ã‡ character, it just leaves it at code 199 (which is iso-8859-1, and not UTF-8)
10:50:28 <HugoDaniel> im getting as a bytestring from a database
10:50:45 <Saizan> oh
10:50:53 <mauke> preflex: zenc Ã‡
10:50:53 <preflex>  z0c7U
10:51:01 <c_wraith> have you confirmed it's in utf8 inside the database?
10:51:10 <mauke> ^ that's using the 'encoding' package
10:51:12 <HugoDaniel> its in iso-8859-1
10:51:23 <mauke> only decoding, though
10:51:37 <theorbtwo> If a character is expressible in latin-1, then it's latin-1 codepoint and it's unicode codepoint are the same.
10:51:43 <HugoDaniel> not always
10:51:58 <Saizan> Prelude Codec.Binary.UTF8.String> encode "Ã‡"
10:51:59 <Saizan> [195,135]
10:52:00 <HugoDaniel> the hex for Ã§ in latin-1 is e7
10:52:13 <HugoDaniel> the hex for utf-8 is c3a7
10:52:38 <HugoDaniel> oh ok
10:52:40 <benmachine> Chaze: well, have you considered that the number of bytes you got was the number that can fit in a 32-bit integer?
10:52:41 <HugoDaniel> im going to look into the db
10:53:26 <Chaze> benmachine: that explains a lot, I didn't really care about typing ;)
10:53:31 <arw> HugoDaniel: codepoint and encoded character are two different things.
10:53:35 <benmachine> Chaze: there is no way that map f a should be a different length from a though
10:53:40 <HugoDaniel> ah ok
10:53:58 <roconnor> @free map
10:53:59 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
10:54:18 <benmachine> I don't get what the $ are there
10:54:38 <Chaze> well, I just defined a like by   let a = binToString 2361031878030638688519054699098996
10:54:45 <roconnor> $map is the derived map from the data type, which in this case is map
10:54:49 <arw> HugoDaniel: codepoint is something like U+1234, which is just some number assigned to each glyph. and the encoding is a function like utf8:: Codepoint -> [Byte]
10:54:50 <HugoDaniel> anyway, im reading the database bytestrings with UTF8.toString, and it outputs "MARIA GON\199ALVES"
10:54:51 <ski> @tell edwardk on more thought, i'm thinking the construction possibly is the free functor over a type function
10:54:51 <roconnor> @free either
10:54:51 <lambdabot> Consider it noted.
10:54:52 <lambdabot> g . k = p . f => g . q = f1 . h => g . either k q = either p f1 . $map_Either f h
10:55:16 <Chaze> benmachine: after that, a was correctly printed
10:55:24 <benmachine> Chaze: weird
10:55:33 <roconnor> HugoDaniel: what do you mean outputs?
10:55:41 <HugoDaniel> the string
10:55:47 <roconnor> outputs in GHCi?
10:55:51 <HugoDaniel> yes
10:55:52 <roconnor> outputs using putStr?
10:55:55 <HugoDaniel> ghci
10:56:24 <HugoDaniel> if i do a show
10:56:25 <roconnor> outputing in ghci probably truncates to the last 8 bits of the character
10:56:31 <HugoDaniel> it goes like "\195\135"
10:56:37 <HugoDaniel> instead of Ã‡
10:56:38 <benmachine> oh!
10:56:44 <Saizan> ?
10:56:56 <benmachine> Chaze: it behaves surprisingly because a is polymorphic
10:57:48 <benmachine> Chaze: when you use a function on a that forces it to be [Int], it's only four items long, but when [Integer] it is 14
10:57:48 <Saizan> HugoDaniel: toString assumes the content of the bytestring is in utf8.
10:57:54 <roconnor> HugoDaniel: showing the original uncoverted bytestring displays "\195\135"?
10:58:39 <Chaze> benmachine: yes, really peculiar to someone unfamiliar with it
10:58:48 <roconnor> HugoDaniel: anyhow the standard output functions, putStr essentially do not work for non-ascii strings
10:58:57 <roconnor> though there has been some recent progress on this I think
10:58:59 <HugoDaniel> roconnor: yes
10:59:11 <Chaze> benmachine: so which function forces it to me Int ?
10:59:19 <HugoDaniel> showing the original uncoverted displays 195\135
10:59:21 <Chaze> *be Int
10:59:28 <roconnor> HugoDaniel: but this is fine, just use outputing functions from a proper library.
10:59:42 <Chaze> benmachine: ah, chr obviously
10:59:49 <HugoDaniel> if i open it with kate it complains about illegal characters
10:59:51 <HugoDaniel> :/
11:00:06 <Chaze> benmachine: so could i fix this with an explicit cast where I need it?
11:00:12 <roconnor> just use UTF8.toString like you are doing
11:00:16 <roconnor> the result is fine
11:00:30 <benmachine> Chaze: yeah
11:00:36 <roconnor> you can see by yourself by doing map (fromEnum) over your reselt.
11:00:42 <benmachine> with toInteger, or fromIntegral
11:00:44 <roconnor> result
11:00:57 <roconnor> > map fromEnum (UTF8.tostring blah)
11:00:58 <lambdabot>   Not in scope: `UTF8.tostring'Not in scope: `blah'
11:01:45 <Chaze> benmachine: thank you!
11:01:52 <Saizan> a String should always be kept as unicode codepoints, anything else causes only confusion.
11:02:07 <HugoDaniel> :(
11:02:13 <HugoDaniel> i hate this
11:02:25 <roconnor> HugoDaniel: it's all good; no worries
11:02:34 <Saizan> and remember that text IO does unicode [de]coding according to your locale, since 6.12
11:03:09 <HugoDaniel> it ain't
11:03:24 <HugoDaniel> if i open it with kate, it shows the Ã‡ character as a dark ?
11:03:35 <HugoDaniel> but if i switch it to iso-8859-1 it displays it correctly
11:03:37 <roconnor> HugoDaniel: are you opening the input or output?
11:03:41 <HugoDaniel> the output
11:03:42 <Saizan> so "System.IO.putStrLn someStringWhichIsReallyUtf8Octects" won't work if your locale is utf8
11:03:43 <HugoDaniel> i did a writeFile
11:03:58 <roconnor> HugoDaniel: are you using ghc 6.12 or earlier?
11:03:59 <HugoDaniel> writeFile "test.txt" myUTF8String
11:04:18 <HugoDaniel> 6.10
11:04:22 <Saizan> ok
11:04:43 <roconnor> you will have to use a replacement for writeFile
11:05:08 <HugoDaniel> ok
11:05:12 <roconnor> such as http://hackage.haskell.org/packages/archive/utf8-string/0.3.6/doc/html/System-IO-UTF8.html#v%3AwriteFile
11:05:12 <HugoDaniel> any proposals ?
11:05:15 <Saizan> use System.IO.UTF8.writeFile
11:05:22 <HugoDaniel> allright, thanks
11:06:18 <HugoDaniel> sweet
11:06:21 <HugoDaniel> it works fine now :D
11:06:33 <HugoDaniel> im such a douchebag, i should have known this
11:06:42 <roconnor> HugoDaniel: it would probably also work fine under ghc 6.12
11:07:32 <roconnor> gwern's James Falen, _Le Ton beau de Marot_ quote ought to be haskell's motto :D
11:07:37 <Saizan> yeah, with the toString and the standard writeFile
11:07:55 <roconnor> http://blog.ezyang.com/2010/03/straitjacket-programming/#comment-185
11:08:23 <Saizan> (though this means your original ByteString contains utf8
11:10:40 <roconnor> an
11:10:42 <roconnor> ca
11:10:46 <roconnor> ack
11:10:49 * hackagebot checkers 0.2.5 - Check properties on standard classes and data structures.  http://hackage.haskell.org/package/checkers-0.2.5 (ConalElliott)
11:11:01 <roconnor> @faq can Haskell write the ackermann function in the type system?
11:11:02 <lambdabot> The answer is: Yes! Haskell can do that.
11:11:05 <c_wraith> let me inquire again..  Are there error conditions which can kill a thread without a use of finally inside it being triggered?
11:11:12 <conal> hackagebot: thanks!
11:11:34 <c_wraith> now what will the checkers game package be called?
11:11:38 <sclv> so quick question again -- anybody here have much experience with gitit/darcsit?
11:11:51 <roconnor> c_wraith: hcheckers
11:12:51 * hackagebot data-category 0.0.3.1 - Restricted categories  http://hackage.haskell.org/package/data-category-0.0.3.1 (SjoerdVisscher)
11:13:07 <Saizan> c_wraith: i think all the killings are done by throwing exceptions
11:14:09 <zygoloid> i like that ezyang's notional 'programmers who don't like the constraint of a type system' spell straitjacket differently :) that's good characterization...
11:14:59 <fax> never really understood it
11:15:10 <fax> try to ask them 'what programs do you write which are not well typed?"
11:15:23 <fax> of course even if there was one.. it would be hard to name it..
11:15:47 <Saizan> "in which type system?"
11:15:57 <fax> haskell
11:17:16 <tsou> Is there a parser in Parsec that will keep performing two parsers until some end-parser is satisfied, and fail if any of those two fails before reaching the end-parser?
11:17:44 <jmelesky> fax: the most common not-well-typed pattern i've seen involves heterogeneous collections
11:17:44 <EvanR-work> fax: i write programs that are not well typed on a regular basis
11:17:57 <fax> tsou no there is not but you can write one in almost exactly the way you just explained it
11:18:05 <EvanR-work> because at work i use javascript, and its type system is abominable
11:18:24 <fax> can you show me an example, just because this is a curiousity
11:18:27 <tsou> fax: yes, I would just not like to make up my own if one already exists
11:18:29 <tsou> fax: thanks ;)
11:19:16 <tsou> Is it an uncommon parser?  I'm asking because maybe i'm handling the situation wrong..
11:19:45 <HugoDaniel> ok
11:19:53 <HugoDaniel> so now all the other special characters went strange
11:19:59 <HugoDaniel> but the Ã‡ shows up fine
11:20:00 <HugoDaniel> :/
11:20:16 <HugoDaniel> at least kate now recognizes it as valid utf8
11:20:24 <fax> tsou, I have never met this before
11:20:28 <tsou> I'm parsing a file that contains a series of lambda-calculus terms, each one ended by ";\n".
11:20:32 <zygoloid> tsou: i guess people usually use 'sepBy' or friends, and rely on the end-parser not matching the internal bits
11:20:37 <fax> but then I only parse programming languag and very basic lingustics
11:20:43 <zygoloid> (or vice-versa, rather)
11:20:47 <fax> so I am not really someone who knows all about
11:20:52 <Saizan> HugoDaniel: heh, i suspect your source ByteString is latin1 except for this Ã‡
11:21:10 <Saizan> HugoDaniel: which is actually already in utf8 within it
11:21:10 <sinelaw> yo
11:21:12 <fax> tsou I'd probably attack it differently but by no means does that suggest your way is not fine
11:21:28 <tsou> fax: any ideas on what differently would mean?
11:21:48 <fax> well zygoloid said it
11:22:12 <HugoDaniel> oh, thats great
11:22:23 <tsou> it's my first parser and by the size of my source file, I _do_ think that I'm not in the right track..
11:22:59 <HugoDaniel> these are other db fields
11:23:10 <HugoDaniel> ill try to read them as they were normal bytestrings
11:23:23 <tsou> zygoloid: hmmm thanks, I'll try to see if I can get it right this way..
11:32:09 <roconnor> @quote O'Connor's Law
11:32:09 <lambdabot> No quotes for this person. :(
11:34:06 <lpsmith> What's O'Connor's law?
11:35:32 <olsner> @quote connor
11:35:33 <lambdabot> pumpkin says: "roconnor would have strangled me if I had given any more information than a Maybe."
11:36:31 <olsner> hmm, who maintains lambdabot anyway? I found out what causes the getRandItem exception in the quote plugin
11:37:16 <c_wraith> if it's on hackage, it should list a maintainer
11:37:36 <olsner> ah, hackage lists Cale, author and vehement proponent of Caleskell
11:38:01 <c_wraith> I knew cale ran the specific instance that lives here.  I didn't realize he also officially maintained the project
11:38:31 <olsner> for some reason, I always thought it was gwern who maintained the code
11:40:03 <roconnor> [OConnor's Law]
11:40:05 <roconnor>     roconnor :: As an online discussion of static types vs dynamic types
11:40:06 <roconnor>                 grows longer, the probability of mentioning heterogenous
11:40:08 <roconnor>                 lists approaches 1.
11:40:31 <roconnor> [Lemmih's Law]
11:40:33 <roconnor>     Lemmih ::   Every 18 months, compilers will make their warnings and
11:40:34 <roconnor>                 error message s twice as cryptic
11:40:50 <hatds> anyone know about polynomial/curve fitting in haskell?
11:40:50 <zygoloid> re: o'connor's law: once that happens the discussion is over and whoever mentioned them is considered to have lost?
11:41:14 <lpsmith> data Ex = forall a.  Ex a
11:41:16 <c_wraith> hatds: I can't think of any reason the standard algorithms wouldn't apply in haskell.
11:41:20 <Gracenotes> funny, the probability must grow very slowly
11:41:37 <lpsmith> [Ex 1, Ex "foo"].  There, problem solved ;-)
11:41:52 <hatds> well I mean what algorithms are there already implemented that would be appropriate for polynomial fitting
11:42:25 <olsner> ah, so according to lemmih's law c++11 will be approximately 400 times more cryptic than C++98
11:42:55 <hatds> > log 400 / log 2
11:42:56 <lambdabot>   8.643856189774725
11:43:18 <hatds> :)
11:43:30 <roconnor> lpsmith: and people say haskell doesn't have hetereogenous lists...
11:45:01 <roconnor> olsner: TestIrSdeAbstractFactory.obj : error LNK2019: unresolved external symbol "double __cdecl NCCSample<1>(double,double,class UniformGenerator &,class NormalGenerator &)" (??$NCCSample@$00@@YANNNAAVUniformGenerator@@AAVNormalGenerator@@@Z) referenced in function "class Vector<double,long,class FullArray<double,class std::allocator<double> > > __cdecl NonCentralChiSquaredSimulation<1>(class CIRSde const &,class Vector<double,long,class
11:45:02 <roconnor> FullArray<double,class std::allocator<double> > >,class UniformGenerator &,class NormalGenerator &)" (??$NonCentralChiSquaredSimulation@$00@@YA?AV?$Vector@NJV?$FullArray@NV?$allocator@N@std@@@@@@ABVCIRSde@@V0@AAVUniformGenerator@@AAVNormalGenerator@@@Z)
11:45:06 <roconnor> oh crap
11:45:08 <roconnor> sorry
11:45:16 <roconnor> that example was a bit more cryptic than I had realized
11:45:39 <lpsmith> template metaprogramming?
11:45:58 <lpsmith> ahh yes
11:45:58 <roconnor> it's like gcc puked on my keyboard
11:46:13 <MasX_Chief> :t snd
11:46:13 <lpsmith> g++, you mean ;-)
11:46:14 <lambdabot> forall a b. (a, b) -> b
11:46:17 <roconnor> g++ yes
11:46:34 <Cale> c_wraith: I don't officially maintain the project, that's just what Hackage says.
11:46:35 <MasX_Chief> :t null
11:46:35 <lambdabot> forall a. [a] -> Bool
11:46:50 <Cale> olsner: ^^ also
11:47:01 <MasX_Chief> :t head.tail
11:47:02 <lambdabot> forall a. [a] -> a
11:47:02 <c_wraith> Cale: you should totally upload a new version changing the maintainer to someone else
11:47:12 <olsner> Cale: hmm, I see, who fixes stuff then?
11:47:35 <Cale> Random people.
11:47:47 <Cale> I'll happily apply patches to the running lambdabot.
11:47:53 <lpsmith> so how do people manage their haddock documentation?
11:48:08 <aavogt> cabal install does reasonably well now
11:48:10 <c_wraith> Technically, anyone can upload a new version of anything on hackage.
11:48:35 <aavogt> c_wraith: I think that got changed
11:48:52 <c_wraith> aavogt: hmm.  I've only uploaded to my own packages, so I guess I wouldn't know
11:49:01 <lpsmith> I've started hacking cabal-install to be able to regen documentation for most things on the system,  I've made progress but still have a ways to go
11:49:34 <olsner> Cale: what happens with the patch after you applies it - does it ever get into "the" tree?
11:51:54 <Cale> I'm not sure if there is a "the" tree.
11:51:59 <olsner> that sucks
11:52:04 <evanbd> Hello.  I'm trying to write some code to parse a mixed binary / utf8 protocol, and having trouble.
11:52:22 <Cale> Well, there's the tree of code which the actual lambdabot is run from.
11:52:34 <Cale> and there's one on code.haskell.org
11:53:01 <Cale> but given that lambdabot has no maintainer, it's not exactly centralised
11:53:16 <evanbd> I want to do something like a lazy "contents <- hGetContents handle", but I don't see how to turn that into a mix of Strings and ByteStrings
11:53:48 <evanbd> While keeping the parsing portion pure, that is.
11:54:23 <Cale> Maybe utf8-light?
11:54:45 <evanbd> Basically I want to read a line (like with hGetLine), parse that line, possibly read a known number of bytes into a ByteString, and then read another line.
11:55:47 <Cale> What's the problem with just doing that then?
11:56:35 <evanbd> Is there a way to do that without mixing the IO stuff and the purely functional parser?
11:56:52 <Cale> Well, you have a parser for one line which is pure
11:57:44 <evanbd> :/
11:59:03 <evanbd> If not for the binary portion, I'd just do a lazy read of everything into a String, and pass that to the parser that runs it through lines and returns a [Message] or something.
11:59:49 <Cale> You could read it all into a lazy ByteString and then convert the relevant sections into Strings using, say, the utf8-light library.
12:00:32 <evanbd> I'm probably missing something silly, but I don't see how to do that.
12:01:04 <evanbd> I need something like a getUTF8Line :: ByteString -> (String, ByteString)
12:01:49 <evanbd> (and yes, I'm looking at the UTF8-light lib on hoogle now, thanks)
12:02:17 <Cale> Maybe use span or break?
12:02:36 <Cale> (to split the string at the first newline character)
12:03:07 <Cale> I suppose that's hard because of the particulars of UTF8?
12:03:11 <evanbd> I thought of that, but how do I recognize the newline character?
12:03:14 <Cale> Seems like a weird protocol.
12:03:24 <evanbd> Right; chars in UTF8 can be multiple bytes long
12:03:34 <evanbd> Well, it's fairly simple.
12:03:36 * hackagebot amqp 0.1.1 - Client library for AMQP servers (currently only RabbitMQ)  http://hackage.haskell.org/package/amqp-0.1.1 (HolgerReinhardt)
12:04:30 <evanbd> It's "MessageName\nkey1=val1\nkey2=val2\n...EndMessage" or "MessageName\nkey1=val1\nkey2=val2\n...Data\n<binary goes here>"
12:05:06 <evanbd> Everything except the binary is in UTF8, and the length of the binary is fully specified in the preceding lines of the message
12:05:13 <zachk> > let myConcat' = foldr (++) [] in myConcat [[1..5],[6..10],[11..20]
12:05:15 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
12:05:29 <drk-sd> zachk: +] :p
12:05:36 <roconnor> > let myConcat = foldr (++) [] in myConcat [[1..5],[6..10],[11..20]
12:05:38 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
12:05:42 <roconnor> > let myConcat = foldr (++) [] in myConcat [[1..5],[6..10],[11..20]]
12:05:44 <zachk>  > let myConcat' = foldr (++) [] in myConcat '[[1..5],[6..10],[11..20] ]
12:05:45 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
12:05:53 <meanburrito920_> It doesnt seem to be legal to define a function as such: \x Just (x * 2)
12:05:57 <meanburrito920_> Why is this not correct?
12:06:07 <roconnor> \x -> Just (x*2)
12:06:08 <Cale> evanbd: Yeah, that's the weird part. It's not a valid UTF-8 stream as a whole, you have to short-circuit the UTF-8 parser at just the right point and switch to reading binary data.
12:06:16 <meanburrito920_> roconnor: oh, dur.
12:06:21 <meanburrito920_> thanks :)
12:06:37 <evanbd> Cale: Right.
12:07:08 <Cale> It would have made more sense to make it a binary protocol with UTF-8 sections which were counted.
12:07:35 <evanbd> Perhaps, but I don't get to do that now :)
12:07:42 <zachk> > let myConcat []=[];myConcat ([]:xs)=myConcat xs;myConcat ((x:xs):xss)=x:myConcat (xs:xss) in myConcat [[1..5],[6..15].[16..30]]
12:07:43 <lambdabot>   Couldn't match expected type `a -> t' against inferred type `[a1]'
12:08:20 <meanburrito920_> lets say I wanted to mutliply two numbers that are in the Maybe monad. is there an easy way to do this?
12:08:37 <zachk> > let myConcat []=[];myConcat ([]:xs)=myConcat xs;myConcat ((x:xs):xss)=x:myConcat (xs:xss) in myConcat [[1..5],[6..15],[16..30]]
12:08:39 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
12:08:42 <evanbd> Cale: I'm tempted to just ignore the binary portion and continue implementing without it.  Most of the messages don't have binary data...
12:08:53 <drk-sd> meanburrito920_: fmap (*) fstmb <*> sndmb ?
12:09:06 <zachk> ok now the second version of myConcat is longer, but it is faster then the foldr version right?
12:09:13 <evanbd> meanburrito920_: What drk-sd said; if you want to understand it, look up Functors.
12:09:33 <drk-sd> (thanks for the completion :p)
12:09:34 <zygoloid> meanburrito920_: liftM2 (*)
12:09:52 <drk-sd> or that, ok.
12:09:54 <meanburrito920_> thanks :)
12:10:32 <zachk> > liftM2 (*) (Just 25) (Just 25)
12:10:34 <lambdabot>   Just 625
12:11:02 <Cale> http://hackage.haskell.org/packages/archive/utf8-string/0.3.6/doc/html/Data-ByteString-Lazy-UTF8.html -- you might be able to use this
12:11:42 <zygoloid> > Just 25 <^(*)^> Just 6
12:11:44 <lambdabot>   Not in scope: `<^'Not in scope: `^>'
12:11:46 <zygoloid> :(
12:11:55 <Cale> Use decode a bunch to collect Chars until you get a newline character
12:12:01 <zygoloid> @let (<^) = flip fmap; (^>) = (<*>)
12:12:04 <lambdabot>  Defined.
12:12:05 <zygoloid> > Just 25 <^(*)^> Just 6
12:12:07 <lambdabot>   Just 150
12:12:16 <drk-sd> cheat :D
12:12:23 <zygoloid> Control.Applicative.Infix
12:12:30 <Cale> oh, or maybe just break
12:12:56 <sinelaw> cool
12:13:01 <evanbd> Oh.  Yeah, I think that's what I was looking for.
12:13:05 <evanbd> Cale: Thanks :)
12:13:11 <zygoloid> @hackage InfixApplicative
12:13:12 <lambdabot> http://hackage.haskell.org/package/InfixApplicative
12:13:13 <roconnor> @type maybe Just break
12:13:14 <lambdabot>     Couldn't match expected type `Maybe [a]'
12:13:14 <lambdabot>            against inferred type `([a], [a])'
12:13:14 <lambdabot>     In the second argument of `maybe', namely `break'
12:13:22 <Cale> This is in the fancier utf8-string package
12:13:33 <zygoloid> @faq Can Haskell programs maybe Just break?
12:13:34 <lambdabot> The answer is: Yes! Haskell can do that.
12:13:51 <zygoloid> WRONG! the correct answer is 'type error'
12:14:49 <drk-sd> :DD
12:15:45 <sinelaw> @type liftM
12:15:46 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
12:16:02 <sinelaw> @type return
12:16:02 <danderson> this is one thing I rather like in Haskell. Compiler errors all stem from my failure to understand what I'm doing.
12:16:03 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
12:16:26 <zygoloid> @type fmap join liftM2 return
12:16:28 <lambdabot> forall r (m :: * -> *). (Monad m) => m r -> m r
12:16:34 <zygoloid> @type fmap join liftM2 return id
12:16:35 <lambdabot> forall a. a -> a
12:16:39 <danderson> once I successfully formulate to myself what it is that I want exactly, the compiler just nods sagely and gives me a binary
12:17:01 <Twey> :t fmap join liftM2 return
12:17:01 <lambdabot> forall r (m :: * -> *). (Monad m) => m r -> m r
12:17:20 <Twey> Ah, heh
12:18:33 <aavogt> @type Just.maybe.break
12:18:34 <lambdabot> Couldn't find qualified module.
12:18:35 <meanburrito920_> in the following type, why is there an m before the (a -> b) ? ap :: (Monad m) => m (a -> b) -> m a -> m b
12:18:55 <aavogt> because otherwise you want fmap
12:19:01 <zygoloid> or ($). or id
12:19:23 <jmcarthur> meanburrito920_: it means you have something like IO (a -> b) or Maybe (a -> b) or whatever
12:19:38 <jmcarthur> and you need to apply it to something of type IO a or Maybe a respectively
12:20:14 <zygoloid> meanburrito920_: it's generalized function application. you have a function inside a monad and an argument for the function inside a monad, and it glues them together and produces a value representing the result.
12:20:21 <jmcarthur> that is, to use the function the effects must also happen, and ap allows you to do that without the hassle
12:20:23 <meanburrito920_> oh, so the function itself is in a monad
12:20:26 <jmcarthur> yes
12:20:40 <zygoloid> (and it's got to be the same monad, so it's the same m throughout)
12:23:15 <xarch> hi
12:24:04 <sinelaw> hey
12:24:24 <sinelaw> j'existential
12:26:19 <roconnor> meanburrito920_: it is common to do "return myFunction `ap` monadItem1 `ap` monadItem2 `ap` monadItem3"
12:26:40 <roconnor> or in applicative notation: myFunction <$> monadItem1 <*> monadItem2 <*> monadItem3
12:27:35 <sinelaw> @quote burrito
12:27:35 <lambdabot> jmcarthur says: web monads are unicorn burritos that have been laying around in the attic for a few years
12:27:56 <xarch> what's <^(*)^> ?
12:28:04 <drk-sd> :D
12:28:15 <pantsman> that's Kirby yawning
12:28:26 <mauke> it's that monster from chrono trigger
12:28:29 <drk-sd> xarch: Â« 20:17:24 < zygoloid> @let (<^) = flip fmap; (^>) = (<*>) Â»
12:31:18 <fax> I got bored of my category theory book so I skipped forward a bit... then it's talking about toposes and sheafs and fiberations and smyth plotkin categories
12:31:24 <xarch> ok
12:31:27 <xarch> thanks
12:31:43 <fax> so I must have skipped something pretty important....
12:32:13 <fax> before taht i twas all 1 is isomorphic to isomophism up to isomorphic isomorphisms
12:32:51 * fax just doesn't get any this at all..
12:33:39 <mreh> you don't need to do haskel
12:34:15 * mreh doesn't understand any of this
12:34:56 <seydar> i seek pumpkin
12:36:28 <mreh> how do I do acceleration due to thrust in Yampa, plus a constant co-efficient of friction
12:37:01 <mreh> maybe I should just throw thrust out the window and model the acceleration directly
12:37:29 <jmcarthur> seydar: i haven't seen pumpkin here in a whole day i think, which is unusual
12:37:30 <seydar> thrust... isn't that the derivative of acceleration?
12:37:53 <mreh> thrust is a force, so it's proportional to the acceleration
12:38:03 <evanbd> seydar: thrust is one of multiple forces... net force is accel times mass
12:38:12 <mreh> I trust we're all Newtonians here
12:38:33 <aconbere> under certain scales certainly :)
12:38:34 <evanbd> An airplane at constant velocity can have nonzero thrust
12:39:03 <mreh> evandb, that's because it is at terminal velocity
12:39:04 <seydar> evanbd: ah, but on tuesdays after thanksgiving before the fiscal new year?
12:39:40 <evanbd> mreh: No.  Terminal velocity usually refers to the condition of air friction matching gravity, with no applied thrust.
12:40:00 <evanbd> mreh: A cruising airplane at constant velocity has lift matching gravity, and thrust matching drag.
12:40:04 <mreh> well, there is no gravity in Haskelloids, so :P
12:40:10 <paulmitchell> I'm a Newton-Johnian... exploring physics through the medium of expressive dance
12:43:16 <seydar> i don't mean to offend any finns here
12:43:22 <seydar> but i'm watching this finnish rap video
12:43:24 <seydar> and everyone is so tame
12:44:02 <sinelaw> what?! we will take you prisoner as soon as we conquer the USSR
12:44:34 <seydar> sinelaw: are you finnish?
12:44:35 <meanburrito920_> why does filterM return a list inside a monad instead of a list of monads?
12:44:45 <meanburrito920_> it seems like the latter would be more useful
12:44:49 <sinelaw> seydar, inasmuch as you are soviet
12:45:00 <mreh> @src mapM
12:45:00 <lambdabot> mapM f as = sequence (map f as)
12:45:03 <mreh> that's why
12:45:09 <mreh> BECUZ
12:45:15 <seydar> sinelaw: so... do you live in finland?
12:45:25 <sinelaw> seydar, never been there :)
12:45:38 <mreh> meanburrito920_, if you want the latter, use map :)
12:45:44 <conal> i'm not entirely sure, but i hear that yampa exposes time sampling. and so isn't really continuous time.  which would interfere with declarative/denotative physics-based behavior.
12:45:46 <seydar> see, you just got my hopes up. i is sad panda
12:45:54 <meanburrito920_> mreh: filter?
12:46:03 <mreh> meanburrito920_, map
12:46:13 <meanburrito920_> why use map if I want to replace filterM?
12:46:23 <mreh> conal: this is true
12:46:43 <mreh> meanburrito920_, oh, sorry I misread what you said
12:46:47 <meanburrito920_> ah
12:46:48 <mreh> the principle is the same though
12:46:50 <meanburrito920_> ok
12:46:50 <sinelaw> seydar, so you're chinese?
12:46:52 <mreh> @src filterM
12:46:52 <lambdabot> Source not found.
12:46:55 <mreh> :(
12:47:00 <seydar> sinelaw: america
12:47:31 <medfly> seydar, I am Asia!
12:47:46 <sinelaw> seydar, ooh sounds exotic. which part?
12:47:47 <mreh> conal: with "reactimate" you supply how long it was since the last "sense" action, and are obliged to keep that invariant
12:48:09 <sinelaw> mreh, you are? i thought you're supposed to tell the real time
12:48:12 <seydar> sinelaw: where we have the worst weather in the country. "turn back now if the weather is bad"
12:48:31 <medfly> seydar, hot or cold?
12:48:35 <mreh> sinelaw, you are
12:48:53 <sinelaw> i've abandoned hope of understand Yampa
12:48:53 <seydar> medfly: cold
12:49:00 <sinelaw> i love cold
12:49:04 <mreh> sinelaw: it's amazingly hard
12:49:14 <mreh> but I'm getting there... sloooowly
12:49:18 <sinelaw> mreh, i know. i'm sort of working on a replacement.
12:49:40 <mreh> sinelaw: is it arrowized?
12:49:52 <sinelaw> mreh, indeed it is, but that's not a central thing right now.
12:49:58 <sinelaw> it may turn out not to be
12:50:13 <sinelaw> seydar, cold beats sandstorms
12:50:20 <sinelaw> *cough*
12:50:52 <seydar> i love cold too. i can't imagine living anywhere that doesn't have similar weather
12:50:58 <mreh> I hope yampa doesn't turn out to be a waste of time, I suspect I may turn to other things later
12:51:02 <conal> sinelaw: were you trying to understand yampa semantically (denotationally)?
12:51:05 <mreh> part of the learning process
12:51:23 <sinelaw> conal, also, but the lib is such a mess that even to understand how things are supposed to work is hard
12:51:42 <sinelaw> conal, and semantically they give you only the very basic stuff
12:51:46 <mreh> I'm not looking under the hood thanks be to god
12:51:56 <sinelaw> conal, and don't seem to follow it through
12:52:17 <sinelaw> mreh, i meant "how i'm supposed to use them"
12:52:34 <mreh> sinelaw: have  you read the source?
12:52:40 <mreh> there are a fair few comments
12:52:45 <sinelaw> mreh, i tried to avoid that, but the comments are the best docs
12:52:47 <mreh> at the top level atleast
12:52:50 <sinelaw> yeah exactly
12:53:00 <sinelaw> they're not haddocked
12:53:11 <lowasser> anyone here use TH extensively?
12:53:19 <mreh> not me
12:53:32 <lowasser> I think I discovered a bug in TH kind parsing maybe
12:53:42 <mreh> unlikely :)
12:54:02 <lowasser> pretty sure of it, if you're responding to me =P
12:54:19 <mreh> If I had a bug for every bug I thought I had found... I would be much smarter than I am now
12:54:39 <sinelaw> parse error
12:54:55 <lowasser> okay
12:55:16 <lowasser> test2 :: String
12:55:16 <lowasser> test2 = $(do test <- [d| type family HTrieMapT (a :: *) :: * -> (* -> *) -> * |]; return (LitE (StringL (show test))))
12:55:37 <lowasser> so, the newest version of TH has a Kind type
12:55:42 <lowasser> data Kind = StarK | ArrowK Kind Kind
12:55:56 <mreh> conal: what is the other solution rather than time slicing and trapezium approximations of continuous functions?
12:56:04 <lowasser> which the comments say is essentially what you think it is: ArrowK k1 k2 == k1 -> k2, StarK == *
12:56:12 <mreh> I assume that's how Yampa does its thing
12:56:29 <aavogt> is there a way to hide intermediate type variables?
12:56:49 <lowasser> so I assume that TH should be telling me that the kind of this type family is (StarK `ArrowK` (StarK `ArrowK` StarK) `ArrowK` StarK)
12:56:59 <lowasser> assuming right-associativity, which is how kinds should work
12:57:12 <lowasser> that is, * -> ((* -> *) -> *))
12:57:29 <lowasser> and instead it tells me the kind is (ArrowK (ArrowK StarK StarK) (ArrowK StarK StarK))
12:57:43 <lowasser> or (* -> *) -> (* -> *)
12:57:58 <aavogt> as in:   C1 a b | a -> b,  C2 b c | b -> c,      I want:    class (C1 a b, C2 b c) => D a c | a -> c,   but I'm not allowed to leave out the intermediate `b'
12:57:58 <dino-> What do the items in ghc-pkg list in blue or ( ) mean?
12:58:08 <lowasser> if you use pprint, it actually shows you that it's getting the wrong kind
12:58:09 <aavogt> dino-: hidden or broken?
12:58:24 <lowasser> so there's definitely either a bug in pretty-printing or in kind parsing, and I think it's in kind parsing
12:58:37 <conal> mreh: "the other"?  i expect there's more than one.  i'd start (as always) by asking what the spec is, rather than the implementation.
12:59:09 <dino-> aavogt: If you're asking me, I don't know.
12:59:41 <aavogt> lowasser: do associated types compose in such a way that users of the functions don't have to name intermediate variables in type signatures?
12:59:43 <dino-> But I can't build something that depends on binary -any and I have (ghc-binary 0.5.0.2) in my list
12:59:44 <sinelaw> does ghc suffer if types get nested very deeply?
12:59:54 <aavogt> dino-: I mean that it is one or the other
12:59:58 <sinelaw> like (a (b (c (d (....))))))
13:00:11 <mreh> conal: the spec is I suppose, let's do calculus over discontinuous functions
13:00:33 <lowasser> aavogt: ....I think that's accurate, not entirely sure of the terminology, but I know type families, and I know TH, and something's terribly wrong
13:00:36 <sinelaw> one problem with yampa is that the spec is hard to find / not clear
13:00:39 <dino-> aavogt: Ok, thanks
13:00:47 <mreh> sinelaw: it's no impossible though
13:01:30 <mreh> did I show you the space invaders and synthesiser papers?
13:04:15 <sinelaw> mreh, i read a few of the yampa papers
13:04:18 <lispy> What is the correct way to get the same memory layout as C when you're filling a struct to pass to the FFI?
13:04:26 <aavogt> lowasser: to me the parsing looks broken in your case, but I don't understand what the kind should be anyways.
13:04:39 <sinelaw> mreggen, the yampa arcade, afrp continued, robots arrows and ???, and maybe another.
13:04:45 <sinelaw> oops. mreh :)
13:04:46 <mathijs> is there a way to make hGetContents "safe"? I mean when an IO error happens, I would like hGetContents to just interpret this as EOF and end the string that comes out.
13:04:47 <lispy> This code allocates a buffer and then pokes values at it
13:04:48 <aavogt> #ghc has been more helpful to me for TH stuff
13:04:57 <lowasser> I mean, in TH,m, there's a spot where the kind of the whole family expression should go
13:05:05 <mreh> sine: everything I've read then
13:05:05 <mauke> lispy: a Storable instance
13:05:07 <lowasser> that is, the output *should* be (* -> (* -> *) -> *)
13:05:08 <lispy> But, I'm worried that's not getting the right in memory layout
13:05:27 <sinelaw> lispy, what mauke said
13:05:32 <mauke> lispy: for which you'll probably need a tool like hsc2hs (or c2hs, but I'm not familiar with that)
13:05:45 <lispy> This is a .hsc file, BTW
13:05:53 <lispy> (this is Takusen code actually)
13:06:01 <mauke> ok, so it's using hsc2hs
13:06:23 <lispy> pokeSmallInt buffer #{offset TIMESTAMP_STRUCT, year} (fromIntegral year)
13:06:26 <lispy> The code looks like that
13:06:41 <sinelaw> lispy, look at CvSize
13:06:42 <mauke> ok, that's not obviously wrong
13:06:47 <sinelaw> http://github.com/sinelaw/HOpenCV/blob/master/src/AI/CV/OpenCV/CxCore.hsc
13:06:52 <sinelaw> lispy, ^^^
13:07:18 <sinelaw> struct CvSize { int width, int height } i think.
13:07:54 <mauke> I'm very skeptical of that alignment definition
13:07:55 <sinelaw> lispy, and the C struct is defined in the #include right above that. this too is an hsc file
13:08:14 <lispy> hmm and you use #poke instead of #offset
13:08:35 <mauke> that only works because w and h have fixed types
13:08:44 <sinelaw> mauke, i know. sort of.
13:09:01 <sinelaw> this code is the result of skimming through a few tutorials, no deep understanding.
13:09:38 <sinelaw> i guess the alignment is crucial, though, so maybe this won't help you unless you have something similar to poke
13:11:38 <lispy> Yeah, maybe I need to write a Storable
13:11:53 <lispy> Thanks for the examples and the info
13:11:57 * lispy heads back to debuggin
13:12:53 <mauke> #let alignment t = "%lu", (unsigned long)offsetof(struct {char x__; t (y__); }, y__)
13:22:10 <krey> hi, can somebody help me understand the MaybeT monad
13:22:11 <krey> ?
13:22:48 <roconnor> krey: sure
13:22:56 <roconnor> though MaybeT is a monad transfomer
13:22:59 <opqdonut> ?src MaybeT (>>=)
13:22:59 <lambdabot> Source not found. The more you drive -- the dumber you get.
13:23:07 <opqdonut> ?src (>>=) MaybeT
13:23:07 <lambdabot> Source not found. Just try something else.
13:23:10 <opqdonut> gah!
13:23:43 <krey> so, can someone give an example of the usage of this monad?
13:24:07 <mauke> what monad?
13:24:15 <Taejo> krey: MaybeT IO a ~= IO (Maybe a)
13:24:17 <krey> mauke: MaybeT
13:24:20 <roconnor> runMaybeT do { "hunter2" <- getPassword }
13:24:23 <mauke> krey: MaybeT is not a monad
13:25:00 <krey> mauke: What??? http://www.haskell.org/haskellwiki/New_monads/MaybeT
13:25:26 <mauke> krey: what about it?
13:26:01 <krey> mauke: instance Monad m => Monad (MaybeT m) where...
13:26:09 <mauke> yes
13:26:13 <mauke> not instance Monad MaybeT where
13:26:43 <krey> mauke: yep, so MaybeT m
13:27:29 <krey> mauke: say MaybeT [], could you give me a working example with that?
13:28:07 <roconnor> does anyone else here like me spend more time thinking than typing when programming?
13:28:19 <opqdonut> easily
13:28:43 <roconnor> I don't get this thing about the mouse use slowing down programmers
13:29:00 <Heffalump> roconnor: I do
13:29:00 <mreh> roconnor: I asked that question before, the answer is "yes"
13:29:04 <mauke> krey: working yes, but I can't think of anything useful
13:29:08 <roconnor> If mouse use is slowing down a programer than you've got a different problem. :D
13:29:29 <mreh> switching between documentation and text editor is a fag with the mouse
13:29:30 <BONUS> when people say that, I think that by "programmers", they actually mean "java programmers"
13:29:33 <byorgey> roconnor: the mouse doesn't slow me down when I'm *programming* but it would often slow me down at other times, if I used it.
13:29:37 <mreh> zing
13:29:49 <krey> mauke: please, I can't (and am not planning to be able to) use the IO monad
13:30:20 <opqdonut> MaybeT [] is kinda useless
13:30:27 <mauke> runMaybeT (return 42) == [Just 42]
13:30:34 <opqdonut> you have multiple results, some of which fail
13:30:35 <roconnor> > runMaybeT $ do { ["foo", "FOO", "Bar","BAR"]; guard (all isUpper) }
13:30:36 <lambdabot>   Not in scope: `runMaybeT'
13:30:39 <opqdonut> you might as well not have some of them
13:31:01 <mreh> opqdonut: use mplus
13:31:07 <opqdonut> MaybeT Reader might be more useful
13:31:08 <BONUS> ya. [Nothing, Nothing, Just 42, Nothing, Just 92] is really redundant
13:31:09 <mreh> msum even
13:31:10 <roconnor> byorgey: ah, okay.  What times are you thinking?
13:31:21 <opqdonut> @unmtl MaybeT Reader a
13:31:21 <lambdabot> err: `Reader (Maybe a)' is not applied to enough arguments, giving `/\A. Maybe a -> A'
13:31:24 <roconnor> BONUS: that makes sense in the context I'm reading
13:31:29 <mreh> > msum [Nothing, Just 2, Just 3]
13:31:30 <lambdabot>   Just 2
13:31:37 <opqdonut> @unmtl MaybeT (Reader r) a
13:31:37 <lambdabot> r -> Maybe a
13:31:59 <BONUS> @unmtl ReaderT r Maybe a
13:31:59 <lambdabot> r -> Maybe a
13:32:05 <aavogt> > mconcat [Nothing, Just (Sum 1), Just (Sum 3)]
13:32:06 <lambdabot>   Just (Sum {getSum = 4})
13:32:14 <sinelaw> @type do $ return $ return (1,2)
13:32:14 <lambdabot> Empty 'do' construct
13:32:21 <sinelaw> @type do return $ return (1,2)
13:32:22 <lambdabot> forall (m :: * -> *) t t1 (m1 :: * -> *). (Monad m, Num t, Num t1, Monad m1) => m (m1 (t, t1))
13:33:34 <krey> I was intending to use MaybeT for primitive error handling
13:33:41 <krey> is that a good idea?
13:34:26 <roconnor> krey: yes
13:34:32 <BONUS> yeah, it's a good way to add short-circuiting failure to existing monads
13:35:25 <sinelaw> let's say i have a two-level nested monad
13:35:41 <sinelaw> m1 (m2 a)
13:36:01 <sinelaw> and i want to run an m1 action inside m2
13:36:15 <sinelaw> like, a -> m1 b
13:36:18 <sinelaw> how do I do that?
13:36:41 <volothampita> sinelaw: have you tried join? http://haskell.org/ghc/docs/latest/html/libraries/base-4.2.0.0/Control-Monad.html#v:join
13:36:46 <byorgey> roconnor: like when I'm reading some web pages and occasionally flipping back and forth to an IRC channel (like now), or when I'm writing something (a paper, blog post, etc.) and have to refer to other sources/documentation/etc...
13:36:56 <BONUS> volothampita: m1 and m2 aren't the same monad
13:37:03 <sinelaw> right
13:37:08 <volothampita> right..
13:37:12 <krey> x // 0 = Nothing
13:37:13 <sinelaw> \m1m2a -> do $ do b <- m1m2a    <--- will this work?
13:37:15 <roconnor> sinelaw: my money is on you can't without a distributive function
13:37:21 <krey> x // y = Just (x/y)
13:37:27 <sinelaw> it shouldn't work
13:37:33 <sinelaw> roconnor, what?
13:37:54 <byorgey> roconnor: and actually, I even do a lot of switching between windows while programming at times, when I'm doing something that requires referencing some documentation.
13:37:57 <krey> say I want to: map (10//) [1,0,5,2]
13:38:24 <krey> except I want to whole thing to stop when the first Nothing happens
13:38:27 <sinelaw> actually never mind. i think i can do without this.
13:38:33 <sinelaw> let's see now....
13:38:41 <roconnor> sinelaw: I'm not sure but I don't think you can do it without a function distr: m2 (m1 a) -> m1 (m2 a)
13:38:42 <BONUS> krey: takeWhile isJust?
13:38:45 <krey> (how) could I do this with MaybeT ?
13:38:50 <sinelaw> roconnor, ah
13:39:04 <krey> BONUS: could be any monad
13:39:07 <BONUS> > takeWhile isJust [Just 3, Just 9, Just 2, Nothing, Just 9]
13:39:08 <lambdabot>   [Just 3,Just 9,Just 2]
13:39:10 <roconnor> sinelaw: don't quote me on this.  Much harder to prove things impossible than possible.
13:39:20 <BONUS> ah
13:39:29 <sinelaw> roconnor, i'm trying another way for now
13:39:33 <roconnor> > concatMaybes [Just 3, Just 9, Just 2, Nothing, Just 9]
13:39:34 <lambdabot>   Not in scope: `concatMaybes'
13:39:44 <roconnor> > concatMaybe [Just 3, Just 9, Just 2, Nothing, Just 9]
13:39:45 <lambdabot>   Not in scope: `concatMaybe'
13:39:47 <roconnor> :/
13:39:51 <BONUS> catMaybes
13:39:52 <BONUS> imo
13:40:03 <c_wraith> err.  That's not an opinion. did you mean iirc? :P
13:40:12 <BONUS> i just always say imo :P
13:40:15 <c_wraith> and that is the correct function :)
13:40:25 <BONUS> catBabies
13:40:31 <krey> so, is it not a good idea to use MaybeT for this?
13:40:31 <c_wraith> :t kittens
13:40:32 <lambdabot> Not in scope: `kittens'
13:40:52 <BONUS> krey: yeah generally it is, if i'm getting you right
13:40:52 <c_wraith> @let kittens = "kittens"
13:40:53 <lambdabot>  Defined.
13:40:56 <c_wraith> :t kittens
13:40:57 <lambdabot> [Char]
13:41:04 <roconnor> sinelaw: when you have such a functions (satifying the requiste laws) then (m1:. m2) is a monad.
13:41:16 <roconnor> sinelaw: such a function
13:41:17 <krey> BONUS: so, how do you do it then? (with this example)
13:41:31 <sinelaw> roconnor, good to know. what's :. ?
13:41:36 <mm_freak_> we should rename 'id' to 'please'
13:41:45 <sinelaw> heh
13:41:53 <sinelaw> and 'const' to 'now'
13:42:12 <sinelaw> @quote psychobot
13:42:12 <lambdabot> psychobot says:  A negative programming tools is a database.
13:42:22 <mm_freak_> that would give haskell code a cobollish and intercallish flavor, something big bosses seem to love
13:42:28 <BONUS> krey: well with that example i don't think you'd be able to do it like that. getting something while something is a Just is inherently list-like
13:42:29 <roconnor> sinelaw: :. is type composition.
13:42:36 <sinelaw> ooh
13:42:45 <roconnor> not that there is really a standard notation for it
13:42:48 <BONUS> but if you're in IO (i know you said you won't do IO but still) and if you have do print 1; print 2; mzero; print 3
13:42:52 <BONUS> only 1 and 2 will get printed
13:43:03 <BONUS> (mzero = MaybeT $ return Nothing)
13:43:27 <ickabob> can somone explain to me the difference between a data declaration and a newtype declaration, specifically why a newtype does away with a constructor?
13:43:33 <roconnor> BONUS: guard is a great thing to use in MaybeT IO
13:43:40 <BONUS> yeah
13:43:49 <sinelaw> Are these equivalent:
13:43:54 <roconnor> ickabob: what do you mean does away with?
13:43:56 <sinelaw>             let m2x2' = do
13:43:56 <sinelaw>               x2 <- m2x2
13:43:56 <sinelaw>               pf2 b' x2
13:43:59 <sinelaw> and:
13:44:05 <sinelaw> m2x2 >>= pf2 b' x2
13:44:27 <krey> what dont get is, staying with my example: map (10//) [10,0,5,2] is a monadic computation, right?
13:44:28 <roconnor> ickabob: anyhow, a newtype is almost exactly the same as data other than stricter (which leads to a more efficent implementation).
13:44:40 <ickabob> sinelaw: was that directed at me?
13:44:41 <krey> so why doesn't the whole MaybeT thing work with it?
13:44:45 <byorgey> ickabob: a newtype declaration may only have a single constructor, so the constructor is not actually needed at runtime.
13:44:59 <sinelaw> ickabob, no, not specifically, unless you happen to know :)
13:45:06 <BONUS> krey: i wouldn't call it monadic
13:45:39 <BONUS> i consider monadic functions to be those that non-trivially use >>=
13:45:45 <krey> BONUS: I'm trying to handle primitive exceptions here
13:45:58 <sinelaw> BONUS, are the two things above equivalent?
13:46:14 <byorgey> i.e. it makes a new type which is isomorphic to another type, and is represented exactly the same at runtime --- but the type checker can distinguish between them at compile time.
13:46:24 <BONUS> which two things?
13:46:25 <krey> BONUS: so I create this function // that may raise an exception (ie. Nothing)
13:46:45 <krey> BONUS: and I need the computation to stop, when exception happens
13:46:51 <krey> BONUS: is this impossible?
13:46:52 <fax> I just thought of it as monadic if you you have an arrow ending in  m a  (for some m or Monad m)
13:47:06 <roconnor> sinelaw: your second thing isn't well typed, but the first is equivalent to m2x2 >>= pf2 b'
13:47:18 <ickabob> roconnor: so newtype is used to strictly bind a type synonym where as data introduces an algebraic type?
13:47:30 <orlandu63> should i use cabal or my local package manager (pacman) to install haskell software?
13:47:31 <roconnor> @undo do {x2 <- m2x2; pf2 b' x2}
13:47:31 <lambdabot> m2x2 >>= \ x2 -> pf2 b' x2
13:47:32 <sinelaw> roconnor, ah right. thanks.
13:47:34 <jmcarthur> ickabob: a newtype is more than a type synonym. it's a whole new type
13:47:44 <sinelaw> should have removed x2
13:47:52 <roconnor> and (\ x2 -> pf2 b' x2) is equivalent to pf2 b'  by eta contraction
13:47:53 <ickabob> but only is able to have a single constructor?
13:47:55 <jmcarthur> ickabob: the new type just has an isomorphism with the type your construct it from
13:48:01 <BONUS> krey: not with MaybeT and mapping // over a list. MaybeT works in such a way that instead of stopping, it tries to make sure that all of the values are Just
13:48:04 <jmcarthur> *you construct it from
13:48:04 <BONUS> in the case of lists
13:48:05 <roconnor> thus yielding m2x2 >>= pf2 b'
13:48:06 <ickabob> aaahh
13:48:11 <sinelaw> roconnor, right.
13:48:18 <BONUS> it's kind of like Maybe:
13:48:21 <ickabob> the connection with an isomorphism makes sense
13:48:25 <BONUS> > sequence [Just 3, Just 9, Nothing, Just 1]
13:48:26 <lambdabot>   Nothing
13:48:57 <fax> newtype Foo v ... from T[v,...]  -- would be nicer..., it should automatically have constructor Foo and unFoo
13:49:00 <byorgey> orlandu63: opinions differ, but I use cabal.
13:49:17 <jmcarthur> fax: and inFoo, inFoo2, etc. :)
13:49:24 <krey> ?src sequence
13:49:25 <lambdabot> sequence []     = return []
13:49:25 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
13:49:25 <lambdabot> --OR
13:49:25 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
13:49:39 <fax> what's inFoo?
13:49:47 <jmcarthur> fax: inFoo f = Foo . f . unFoo
13:49:58 <byorgey> orlandu63: some are leery of using multiple package management systems and prefer using their local package manager for everything.
13:49:59 <fax> hm
13:50:04 <jmcarthur> it's useful :)
13:50:05 <BONUS> krey: the thing is that lists, while they can be viewed as sequential (like [1,2,3] being viewed as: 1 and then 2 and then 3) aren't regarded as such semantically. they're considered more like non-deterministic computations (i.e. [1,2,3] is: all of these: 1, 2, 3 at once)
13:50:06 <fax> you could probably just have 'in'
13:50:13 <fax> using a typeclass
13:50:20 <jmcarthur> fax: yeah i have that in alt-stdlib
13:50:21 <byorgey> orlandu63: but I'd say that using pacman to manage your Haskell packages will just give you a poor approximation of what cabal would do.
13:50:26 <BONUS> aren't regarded as such usually in haskell anyway
13:50:36 <BONUS> in the context of them being monads
13:51:01 <jmcarthur> fax: http://patch-tag.com/r/jmcarthur/alt-stdlib/snapshot/current/content/pretty/Data/Wrapper.hs
13:51:13 <jmcarthur> i wish i could just use in, but it's a keyword
13:51:35 * maltem found BONUS's conclusive remark to be essential
13:51:41 <krey> BONUS: thank you for trying to help, but I don't really get how this works
13:51:56 <BONUS> maltem: yeah hehe lucky i added that
13:52:05 <BONUS> krey: don't worry about it
13:52:33 <krey> BONUS: point is: what I'm trying to do, can not be done, over general monads
13:52:36 <krey> BONUS: right?
13:53:11 <jmcarthur> fax: the problem with useing a type class though is that you can't control whether the "in" functions are exported
13:53:13 <jmcarthur> *using
13:53:24 <jmcarthur> so i've been thinking about doing away with that type class
13:53:27 <BONUS> i'm very wary of saying that something "can't be done", but yeah, i'd say that monads don't offer the functionality you're looking for
13:53:46 <BONUS> and doing that with monads and transformers would probably be shoehorning something in
13:53:55 <roconnor> what is krey trying to do?
13:54:20 <mathijs> is there a way to get unsafeInterleaveIO handle exceptions (that pop up later) more gracefully?
13:54:22 <krey> roconnor: map (10//) [10,5,0,2]
13:54:26 * sinelaw mind is boggled
13:54:29 <ickabob> being very unfamiliar with ghc standard packages, is there one that would provide usefull in representing tree structures, ie a huffman compression implementation?
13:54:30 <sinelaw> *'s
13:54:30 <roconnor> what is //?
13:54:36 <BONUS> roconnor: to use MaybeT (or something else having to do with monads) to turn [Just 1, Just 2, Nothing, Just 4] into [Just 1, Just 2]
13:54:37 <jmcarthur> safe division?
13:54:37 <krey> x // 0 = Nothing
13:54:46 <krey> x // y = Just (x/y)
13:54:47 <BONUS> i.e. takeWhile isJust
13:54:51 <c_wraith> mathijs: only if you can handle the exception sanely in the context of the IO action being interleaved
13:54:52 <orlandu63> byorgey: thanks for the input. i was mainly concerned with using multiple package management systems. but i'm guessing hackage will always be more up-to-date than the arch repository (which is my main priority), so i guess i'll go with cabal
13:55:07 <krey> roconnor: and I need it to fail after the first nothing
13:55:27 <jmcarthur> :t sequenceA . takeWhile isJust
13:55:28 <lambdabot> Not in scope: `sequenceA'
13:55:35 <jmcarthur> :t Data.Traversable.sequenceA . takeWhile isJust
13:55:36 <lambdabot> forall a. [Maybe a] -> Maybe [a]
13:55:50 <mathijs> c_wraith: well, I'm using hGetContents and passing the resulting string to pure functions. What I want is that if an IO error pops up, the string is just terminated (as EOF)
13:55:52 <jmcarthur> :t fromJust . Data.Traversable.sequenceA . takeWhile isJust
13:55:53 <lambdabot> forall a. [Maybe a] -> [a]
13:56:02 <krey> BONUS: takeWhile isJust, then check something about whether I have all the steps I wanted
13:56:24 <c_wraith> mathijs: I think you'd be better off not using hGetContents.
13:56:36 <metaperl[A]> there's no haskell-platform package for ubuntu?
13:56:41 <c_wraith> mathijs: use a strict read function, instead.
13:56:49 <mathijs> c_wraith: yeah but that means a lot of extra work :(
13:57:19 <jmcarthur> mathijs: Data.ByteString.hGetContents is strict
13:57:20 <c_wraith> mathijs: only if you aren't willing to read it all into memory in one shot
13:58:10 <mathijs> nope, strict won't help me... the string I'm using is the output (stdout) of a child process. I need to pass input back in and read further.
13:58:36 <jmcarthur> mathijs: you could learn iteratee, but i admit that is not such a trivial thing
13:59:13 <c_wraith> if it's line-oriented, you could use hGetLine, which is strict
13:59:35 <c_wraith> But stops reading after EOL
13:59:40 <sinelaw> @type lift
13:59:41 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
13:59:43 <roconnor> > foldr (\x y -> maybe [] (:y) x) [Just 1, Just 2, Nothing, Just 4]
13:59:43 <lambdabot>   []->
13:59:44 <lambdabot>    [Just 1,Just 2,Nothing,Just 4]
13:59:44 <lambdabot>  [Nothing]->
13:59:44 <lambdabot>    []
13:59:44 <lambdabot>  [Nothing,Nothing...
13:59:50 <jmcarthur> mathijs: actually, what you want sounds like the default behavior of hGetContents... it gives you EOF if there is an error, i thought
13:59:55 <roconnor> > foldr (\x y -> maybe [] (:y) x) [] [Just 1, Just 2, Nothing, Just 4]
13:59:56 <lambdabot>   [1,2]
14:00:04 <c_wraith> no, hGetContents blows up if there's an error.
14:00:24 <jmcarthur> oh... well, i like it blowing up better, personally, but i thought it was just EOF. oh well
14:00:24 <roconnor> hmm
14:00:25 <c_wraith> and broken pipe is an easy error, in this case
14:00:51 <mauke> @src hGetContents
14:00:51 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
14:01:06 <mathijs> c_wraith: well there are other options for strict reading, but by making it strict, I have to create lots of IO parts inbetween, while I would like to create a function that reads input (string) and writes output (string) back to the handle
14:01:16 <_nickel> can anyone recommend a relatively easy-to-read paper involving haskell for my trip to the gym today?
14:01:31 <_nickel> maybe something from Monad reader
14:01:43 <mathijs> jmcarthur: thought so too, but it seems to blow up on the function reading from the string. even if I use catch around hGetContents
14:01:55 <roconnor> > mapM tell [Just 1, Just 2, Nothing, Just 4]
14:01:56 <lambdabot>   No instance for (Control.Monad.Writer.Class.MonadWriter
14:01:57 <lambdabot>                    ...
14:02:04 <roconnor> @type tell
14:02:05 <lambdabot> forall w (m :: * -> *). (MonadWriter w m) => w -> m ()
14:02:18 <roconnor> > mapM (tell . return) [Just 1, Just 2, Nothing, Just 4]
14:02:19 <lambdabot>   No instance for (Control.Monad.Writer.Class.MonadWriter
14:02:19 <lambdabot>                    ...
14:02:36 <jmcarthur> "Any I/O errors encountered while a handle is semi-closed are simply discarded."
14:02:41 <sinelaw> @hoogle :.
14:02:41 <lambdabot> No results found
14:03:31 <roconnor> > mapM (tell . return) (MaybeT [Just 1, Just 2, Nothing, Just 4])
14:03:32 <lambdabot>   Not in scope: data constructor `MaybeT'
14:04:01 <mathijs> jmcarthur: yeah, I read that too, so I thought I would be fine. the error I'm getting is "hardware fault" though :(  so that probably slips through, although being an IO error
14:04:02 <sinelaw> where is :. documented
14:04:04 <sinelaw> ?
14:04:23 <roconnor> > mapM (tell . return) (Control.Monad.Maybe.MaybeT [Just 1, Just 2, Nothing, Just 4])
14:04:24 <lambdabot>   Not in scope: data constructor `Control.Monad.Maybe.MaybeT'
14:04:29 <roconnor> @hoogle MaybeT
14:04:30 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
14:06:06 <MadHatterDude> Is there a function that behaves like a fold but instead builds a list of the sub-results?
14:06:15 <lowasser> ...scan
14:06:24 <lowasser> scanl and scanr
14:06:43 * MadHatterDude dopeslaps himself
14:06:43 <sinelaw> @hoogle Monad m => m a -> a
14:06:44 <lambdabot> Prelude (>>) :: Monad m => m a -> m b -> m b
14:06:44 <lambdabot> Control.Monad (>>) :: Monad m => m a -> m b -> m b
14:06:44 <lambdabot> Control.Monad.Instances (>>) :: Monad m => m a -> m b -> m b
14:07:09 <sinelaw> do all monads have a runThatMonad?
14:07:10 <aavogt> sinelaw: wherever somebody defined it
14:07:17 <sinelaw> @hoogle runMaybeT
14:07:18 <lambdabot> No results found
14:07:32 <mauke> sinelaw: what would runMaybe look like?
14:07:36 <aavogt> sinelaw: not IO (unless you're feeling unsafe)
14:07:40 <lowasser> not all monads
14:07:44 <aavogt> @type fromMaybe
14:07:45 <lambdabot> forall a. a -> Maybe a -> a
14:07:53 <sinelaw> aavogt, yeah, but the runtime system does it
14:08:00 <sinelaw> so if i can get my monad to main, it's ok
14:08:18 <lowasser> not all monads have a run method
14:08:22 <lowasser> e.g. the list monad =P
14:08:33 <lowasser> not reducible to e.g. an IO computation
14:08:36 <sinelaw> runMaybeT :: m (Maybe a)
14:08:41 <mathijs> instead of trying to bypass/ignore the IO error, I would rather make sure it doesn't happen in the first place. This is just reading from a pty device though, of which the other end went away (process exited)
14:09:45 <mathijs> I couldn't find a way to have that just end with an EOF, which does work for non-pty io streams
14:09:50 <MadHatterDude> is scanl productive with infinitel ists?
14:09:55 <MadHatterDude> lists*
14:10:09 <Twey> It can be
14:10:19 <c_wraith> scanl is fundamentally lazy
14:10:22 <jmcarthur> :t scanl
14:10:23 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
14:10:31 <jmcarthur> > scanl (+) 0 [1..]
14:10:32 <lambdabot>   [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,...
14:10:45 <Twey> > scanl (*) 1 [1 ..]
14:10:46 <lambdabot>   [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800...
14:11:09 <aavogt> > scanr (:) [] [1..]
14:11:10 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
14:11:20 <jmcarthur> heh
14:11:24 <sinelaw> @hoogle Monad m => (a -> m b) -> (b -> m c) -> (a -> m c)
14:11:25 <lambdabot> Control.Monad (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
14:11:25 <lambdabot> Control.Monad (<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c
14:11:25 <lambdabot> Control.Exception bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
14:11:31 <c_wraith> scanr...  I still don't really see the point of.
14:11:54 <c_wraith> I guess it probably has an occasional use, but it's nothing like the use of scanl
14:11:59 <jmcarthur> > scanr (:) [] [1..4]
14:12:00 <lambdabot>   [[1,2,3,4],[2,3,4],[3,4],[4],[]]
14:12:14 <jmcarthur> > tails [1..4]
14:12:15 <lambdabot>   [[1,2,3,4],[2,3,4],[3,4],[4],[]]
14:12:28 <jmcarthur> tails = scanr (:) []   :)
14:12:43 <fax> @src tails
14:12:43 <lambdabot> tails []         = [[]]
14:12:44 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
14:12:47 <sinelaw> Why isn't Monad a Category?
14:12:53 <jmcarthur> i agree though. not as useful as scanl most of the time
14:12:56 <fax> @src scanf
14:12:56 <lambdabot> Source not found. I feel much better now.
14:12:57 <fax> @src scanr
14:12:57 <lambdabot> scanr _ q0 []     =  [q0]
14:12:57 <lambdabot> scanr f q0 (x:xs) =  f x q : qs
14:12:57 <lambdabot>     where qs@(q:_) = scanr f q0 xs
14:13:00 <jmcarthur> sinelaw: Kleisli
14:13:21 <jmcarthur> sinelaw: Monad has the wrong kind entirely, but Kleisli does
14:13:37 <jmcarthur> sinelaw: <=< and <<< are the same thing :)
14:13:54 <jmcarthur> they just have different types due to newtype wrapping
14:13:55 <sinelaw> jmcarthur, <=< = (.)
14:13:56 <sinelaw> no?
14:14:01 <jmcarthur> sinelaw: also the same
14:14:44 <sinelaw> can't i write: instance Category (Monad m) where (.) = <=< , id = liftM id
14:14:58 <jmcarthur> sinelaw: it won't work
14:14:58 <sinelaw> oops wrong id
14:15:06 <sinelaw> id = do return
14:15:09 <sinelaw> jmcarthur, why?
14:15:12 <jmcarthur> try it
14:15:29 <jmcarthur> (you also wrote that wrong)
14:15:42 <jmcarthur> you meant: instance Monad m => Category m where ... i assume
14:15:43 * metaperl_ turns off "use emoticons" so he can read this code :))
14:15:52 <jmcarthur> sinelaw: but m has the wrong kind
14:15:58 <jmcarthur> m :: * -> *
14:16:07 <jmcarthur> but Category wants something with kind * -> * -> *
14:16:08 <sinelaw> yeah
14:16:34 <Saizan> you'd want to writle instance Monad m => Category (\a b -> a -> m b) where ..
14:16:40 <sinelaw> ah
14:16:41 <sinelaw> yes.
14:16:52 <jmcarthur> yeah, and of course that won't work
14:17:10 <Saizan> but we don't have type level lambdas, and there isn't a good way to do typeclass resolution if you add them
14:17:12 <jmcarthur> which is why we have the Kleisli newtype wrapper
14:17:21 <roconnor> execWriter $ runMaybeT $ mapM_ (\n -> do {Just x <- return n; tell [x]}) [Just 1, Just 2, Nothing, Just 4]
14:17:24 <roconnor> > execWriter $ runMaybeT $ mapM_ (\n -> do {Just x <- return n; tell [x]}) [Just 1, Just 2, Nothing, Just 4]
14:17:25 <lambdabot>   Not in scope: `runMaybeT'
14:17:30 <jmcarthur> :t Kleisli
14:17:31 <lambdabot> forall a (m :: * -> *) b. (a -> m b) -> Kleisli m a b
14:18:46 <roconnor> how do you convert from Maybe a to a MonadZero
14:18:56 <roconnor> @type fromMaybe
14:18:57 <lambdabot> forall a. a -> Maybe a -> a
14:18:58 <fax> maybe return mzero ??
14:19:03 <roconnor> ya
14:19:12 <fax> wait Maybe is MonadZero
14:19:21 <fax> oh sorry
14:19:26 <fax> im stupid :D
14:19:53 <sinelaw> jmcarthur, ooh
14:19:59 <sinelaw> @hoogle Kleisli
14:19:59 <lambdabot> Control.Arrow newtype Kleisli m a b
14:20:00 <lambdabot> Control.Arrow Kleisli :: (a -> m b) -> Kleisli m a b
14:20:00 <lambdabot> Control.Arrow runKleisli :: Kleisli m a b -> a -> m b
14:20:27 <roconnor> @type maybe return mzero
14:20:27 <lambdabot> forall a (m :: * -> *) a1. (Monad m, MonadPlus ((->) a1)) => Maybe a1 -> a -> m a
14:20:33 <roconnor> @type maybe
14:20:34 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
14:20:40 <jmcarthur> :t maybe mzero return
14:20:40 <roconnor> @type maybe mzero return
14:20:41 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => Maybe a -> m a
14:20:41 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => Maybe a -> m a
14:21:02 <jmcarthur> :t maybe empty pure
14:21:03 <lambdabot>     Ambiguous occurrence `empty'
14:21:03 <lambdabot>     It could refer to either `Control.Applicative.empty', imported from Control.Applicative
14:21:03 <lambdabot>                           or `Text.Regex.Posix.empty', imported from Text.Regex.Posix at State/L.hs:56:0-22
14:21:11 <jmcarthur> :t maybe Control.Applicative.empty pure
14:21:12 <sinelaw> i can't believe i'm sort of comprehending something called the Kleisli Arrow wrapper for monad
14:21:12 <lambdabot> forall (f :: * -> *) a. (Alternative f) => Maybe a -> f a
14:21:36 <aavogt> :t Data.Foldable.foldr Control.Applicative.empty pure
14:21:37 <lambdabot> forall a a1 (f :: * -> *) (t :: * -> *). (Alternative ((->) a), Applicative f, Data.Foldable.Foldable t) => t a -> a1 -> f a1
14:21:50 <roconnor> krey:
14:21:51 <fax> sinelaw, huh?
14:21:51 <roconnor> Control.Monad.Maybe Control.Monad.Writer> execWriter $ runMaybeT $ mapM_ (\n -> maybe mzero return n >>= (tell . (:[]))) [Just 1, Just 2, Nothing, Just 4]
14:21:53 <roconnor> [1,2]
14:21:58 <aavogt> :t Data.Foldable.foldr (const . pure) Control.Applicative.empty
14:21:58 <roconnor> BONUS: ^^
14:21:59 <lambdabot> forall a (f :: * -> *) (t :: * -> *). (Alternative f, Data.Foldable.Foldable t) => t a -> f a
14:22:21 <BONUS> ahhh, clever!
14:22:26 <sinelaw> fax, i just had a glimpse of understanding what that Kleisli thing is for
14:22:36 <fax> ah I stil have no idea
14:22:39 <roconnor> BONUS: it is a little contrived
14:23:06 <BONUS> hehe, but still, this is why i avoided saying that it can't be done :)
14:23:11 <sinelaw> fax, for one it gives a Category instance for Monad m => (a -> m a)
14:23:13 <BONUS> things can always generally be done
14:23:50 <jmcarthur> sinelaw: you mean a -> m b
14:24:02 <sinelaw> jmcarthur, thanks oops :)
14:24:33 <jmcarthur> @pl \a b -> a $$$ m b
14:24:33 <lambdabot> (. m) . ($$$)
14:24:46 <sinelaw> jmcarthur, can kleisli's be type-composed?
14:24:52 <jmcarthur> instance Monad m => Category ((. m) . (->))
14:25:12 <jmcarthur> sinelaw: you mean like nested monads?
14:25:57 <sinelaw> i mean like bla:: k1 -> k2 -> (k1:.k2)
14:26:45 <Twey> Is it possible to have Haddock pick up a chunk of LaTeX to use as the module description?
14:26:47 <BONUS> hmmm, why isn't there a default instance for MonadPlus m => MonadPlus (ContT r m)
14:26:55 <BONUS> i mean in mtl
14:26:56 <Twey> From a Literate Haskell file
14:27:37 <roconnor> tell . (:[]) needs it's own name :)
14:27:49 <roconnor> tellMonkey
14:27:56 <sinelaw> tellHamburgerMuncher
14:27:58 <jmcarthur> sinelaw: there is not a general composition for monads, so i would imagine the same holds for Kleisli, but that doesn't mean specific cases can't be composed
14:28:11 <MadHatterDude> @hoogle tell
14:28:12 <lambdabot> Control.Monad.Writer.Class tell :: MonadWriter w m => w -> m ()
14:28:12 <lambdabot> System.IO hTell :: Handle -> IO Integer
14:28:32 <jmcarthur> sinelaw: so if m:.n is a Monad then Kleisli (m:.n) should be an Arrow
14:29:21 <roconnor> Isn't Kleisli m always an Arrow when m is a monad?
14:29:29 <jmcarthur> roconnor: right
14:29:43 <jmcarthur> sinelaw was asking if there is a general way to compose Kleisli
14:29:59 <jmcarthur> and i was saying if you can compose the monads
14:30:12 <jmcarthur> *saying you can if
14:30:51 <nizze> Hello.
14:31:14 <sinelaw> jmcarthur, ok I see why.
14:31:28 <nizze> I'm studying Haskell and I bumped into something I do not understand and it's quite hard to google for.
14:31:29 <jmcarthur> sinelaw: i'm pretty sure that Kleisli doesn't open opportunities for composing monads that we didn't already have, considering that you can create a Kleisli arrow from any Monad and a Monad from any Kleisli arrow
14:31:42 <sinelaw> yeah
14:31:51 <sinelaw> nizze, shoot
14:31:52 <nizze> A definition of list if List a = Cons a (List a)
14:31:56 <nizze> | Nil
14:32:12 <nizze> Why is 'a' mentioned both sides of '=' ?
14:32:27 <nizze> Since Maybe = Just a | Nil
14:32:27 <jmcarthur> nizze: it's just like a function parameter, except for a type
14:32:30 <jmcarthur> nope
14:32:36 <jmcarthur> data Maybe a = Just a | Nothing
14:32:57 * sinelaw 's brain melts from monad overload
14:32:59 <nizze> Hmm
14:33:05 <nizze> Let's see...
14:33:19 <MadHatterDude> "Monads are usually a personal experinece"
14:33:21 <BONUS> we say Maybe a because the a can be of any type and which type that is will be evident when we use it. like Just 3 :: Maybe Int
14:35:08 <nizze> jmcarthur: Thanks. I feel kinda stupid now...
14:36:04 <jmcarthur> nizze: nah. just a simple oversight :)
14:36:39 <krasno> Is there a sensible way to make s-expressions instances of applicative?
14:36:49 <ahf> ugh
14:37:06 <roconnor> yes
14:37:08 <krasno> In my datatype, there are atoms, symbols of strings, conses, and Nil.
14:37:22 <krasno> Does the existence of the symbols make it sure to violate the applicative laws?
14:37:34 <jmcarthur> it depends how you define things, i'm sure
14:37:41 <roconnor> krasno: the type variable is the type of atoms?
14:37:42 <sinelaw> jmcarthur, i think i just need that regions thingy
14:37:51 <sinelaw> if that is a "just"
14:38:04 <jmcarthur> sinelaw: regions thingy?
14:38:10 <krasno> data Lisp a = Nil | Symbol String | Atom a | Cons (Lisp a) (Lisp a)
14:38:19 <sinelaw> http://hackage.haskell.org/packages/archive/regions/0.4/doc/html/Control-Monad-Trans-Region.html
14:38:23 <sinelaw> jmcarthur, ^^
14:38:35 <jmcarthur> sinelaw: i don't see the relevance to our conversation, is all
14:38:35 <roconnor> krasno: yes, it even forms a monad.  It is almost the free monad
14:38:57 <krasno> it forms a monad. Then I'll get thinking and make it a one of those as well.
14:39:13 <sinelaw> jmcarthur, the reason i'm trying all these weird things, is that i'm trying to implement something that runs nested monads
14:39:25 <jmcarthur> "runs nested monads"?
14:39:34 <sinelaw> jmcarthur, well that's a bad way to say it, i was just typing :)
14:40:04 <sinelaw> jmcarthur, basically something that does: allocate - runstuff - deallocate, where runstuff could be again the same, but in a different monad.
14:40:36 <dancor> sinelaw: is this like using lift with monad transformers but you don't want to use monad transformers for some reason?
14:40:37 <nizze> jmcarthur: There is another thing which I do not understand. map (+ 1) [1,2,3,4] works fime, but map putStrLn ["foo", "bar", "baz"] gives me scary error message.
14:40:39 <roconnor> It's a bit hard to find applicative functors that are not monads.
14:40:39 <krasno> Wait... you're *sure* it forms a monad?
14:40:46 <roconnor> I am sure
14:41:07 <nizze> jmcarthur: When I do :t putStrLn and :t map I dan see that something fishy is going on.
14:41:08 <sinelaw> dancor, i'm just not too familiar to monad transformers to  realize what i could be doing
14:41:08 <mauke> > map putStrLn ["foo", "bar", "baz"]
14:41:10 <lambdabot>   [<IO ()>,<IO ()>,<IO ()>]
14:41:11 <lowasser> roconnor: false!
14:41:17 <dancor> nizze: mapM_ putStrLn ["foo", "bar", "baz"]
14:41:20 <roconnor> lowasser: oh noes
14:41:21 <lowasser> StateL, ZipList
14:41:28 <sinelaw> dancor, and the RegionT transformer seems to do something very related to what i want
14:41:32 <lowasser> all applicative and non-monad
14:41:34 <roconnor> lowasser: what is StateL?
14:41:46 <dancor> nizze: putStrLn is monadic
14:41:58 <lowasser> the State monad, except the state propagates in the other direction
14:42:06 <nizze> dancor: Thanks I know mapM_ solves my problem, but I do not get why.
14:42:08 <roconnor> ugh
14:42:09 <dancor> sinelaw: i think you should learn monad transformers and then go from there
14:42:37 <MadHatterDude> god damnit!
14:42:53 <MadHatterDude> wait, nvm
14:42:58 <lowasser> lololol
14:42:59 <dancor> nizze: putStrLn has type String -> IO (), so map putStrLn ["a", "b"] has type [IO ()]
14:43:20 <sinelaw> dancor, ok, i will. and jmcarthur thanks for the help. i'm off
14:43:27 <nizze> ah and map has type (a -> b) [a] -> [b]
14:43:45 <dancor> nizze: IO actions only occur when the IO monad is "on the outside"
14:43:55 <nizze> "on the outside" ?
14:44:07 <dancor> [IO ()] is like a list of actions that haven't been performed yet
14:44:25 <MadHatterDude> Yay, my bitmap make works!, unfortunately it doesn't put what I want on the bitmap...
14:45:03 <nizze> dancor: Okay, sounds cool! How should I tell haskell "give me a list of IO actions but do not perform them now, I'll do it later"
14:45:03 <nizze> ?
14:45:22 <opqdonut> just build that list
14:45:25 <dancor> actions = map putStrLn ["a", "b"]
14:45:33 <dancor> main = sequence actions
14:45:39 <dancor> :t sequence
14:45:40 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
14:46:10 <dancor> that program will perform the two IO actions in order
14:46:31 <burp> :t mapM_
14:46:33 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
14:46:41 <dancor> @src mapM_
14:46:41 <lambdabot> mapM_ f as = sequence_ (map f as)
14:46:44 <nizze> Let's see what ghci says.
14:47:18 <nizze> Ah
14:47:22 <nizze> Now I get it.
14:48:01 <cads> Hey, can I get ghci to compile the little tidbits that I load into it? So far I've only used tiny files, but sometimes the execution times are about 30 seconds. On the other hand, the compiled versions, which take about 5 seconds to compile, usually finish in a fraction of a second.
14:48:16 <nizze> if I do map putStrLn ["foo", "bar", "baz"]  in ghci it'll complain, but if I do it in file and compile it's okay. It seems that ghci is complaining because it's trying to evaluate those IO () 's
14:48:17 <burp> nope :>
14:48:40 <MadHatterDude> This is just plaijn weird.
14:48:46 <burp> nizze: use mapM_ for that
14:48:46 <MadHatterDude> plain*
14:48:53 <nizze> Okay
14:48:58 <aavogt> nizze: well   map putStrLn [...] doesn't settle on an evaluation order
14:49:02 <MadHatterDude> Every file operation i do is utterly ignored...
14:49:25 <Twey> Show code, not astonishment
14:49:26 <dobblego> MadHatterDude, orly? got an example
14:49:28 <krasno> @hoogle a -> b -> a
14:49:28 <lambdabot> Prelude const :: a -> b -> a
14:49:29 <lambdabot> Data.Function const :: a -> b -> a
14:49:29 <lambdabot> Prelude seq :: a -> b -> b
14:49:54 <krasno> @hoogle t1 a -> t2 a
14:49:55 <lambdabot> Data.Generics.Aliases unGM :: GenericM' m -> a -> m a
14:49:55 <lambdabot> Data.Foldable toList :: Foldable t => t a -> [a]
14:49:55 <lambdabot> Language.Haskell.TH.Syntax qRunIO :: Quasi m => IO a -> m a
14:50:05 <MadHatterDude> Bytestring.Lazy.writeFile "test.bmp" <some bytestring>
14:50:15 <MadHatterDude> Nothing happens.
14:50:23 <nizze> It seems that I'm bit too green to understand the difference between map and mapM_ -> More studying :9
14:50:29 <nizze> Ah, one more thing.
14:50:35 <roconnor> @src mapM_
14:50:36 <lambdabot> mapM_ f as = sequence_ (map f as)
14:50:43 <burp> yup it's just that
14:50:54 <aavogt> but then you go chasing the definitions of sequence
14:50:55 <burp> @src mapM
14:50:56 <lambdabot> mapM f as = sequence (map f as)
14:51:00 <aavogt> @src sequence_
14:51:00 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
14:51:10 <roconnor> ah yes, the notion of sequence is a bit more involved
14:51:24 <burp> one could just accept what is does :>
14:51:28 <nizze> Are monads something that the compiler is aware of (built into the language) or is it just some goodie provided by Haskell's type system?
14:51:35 <dancor> sequence_ [a, b, c] = do {a; b; c; return ()}
14:51:36 <roconnor> but it is good to break the problem into understanding map and then understanding sequence
14:51:53 <MadHatterDude> nizze: Compiler has syntactic sugar for monads
14:52:04 <nizze> MadHatterDude: That I knew.
14:52:08 <MadHatterDude> nizze: do-notation
14:52:08 <nizze> But nothing else?
14:52:17 <MadHatterDude> nizze: nope...
14:52:22 <aavogt> nizze: the type class is no different from ones you could define yourself
14:52:30 <nizze> Okay.
14:52:39 <nizze> How much of prelude is coded in Haskell
14:52:46 <MadHatterDude> nizze: a lot.
14:52:48 <dancor> nizze: the compiler only has to treat the IO Monad in particular specially
14:53:06 <nizze> dancor: how?
14:53:24 <MadHatterDude> nizze: and the implementation specific number operations such as the Int and Float/Double type
14:53:46 <MadHatterDude> nizze: The IO monad is used with input/output operations
14:54:04 <MadHatterDude> nizze: They are coded in a low-level language
14:54:07 <dancor> nizze: idk the details, but it has to actually perform the IO actions
14:54:19 <nizze> Okay.
14:54:33 <aavogt> lists and tuples have special syntax, you can't define the same sugar in haskell
14:54:43 <nizze> Yeah
14:54:48 <nizze> Anything else?
14:55:33 <nizze> I'm asking since I've found that languages that are written largely in them selves are easier to understand.
14:55:57 <c_wraith> haskell is mostly written in itself.  ghc is mostly in haskell, as well
14:56:07 <nizze> Okay
14:56:21 <nizze> Where should I look if I want to read the whole prelude?
14:56:28 <MadHatterDude> nizze: lists, tuples, IO. thats it.
14:56:29 <aavogt> @where report
14:56:29 <lambdabot> http://www.haskell.org/onlinereport/
14:56:46 <Gracenotes> well, Prelude is just in a single file (plus everything it imports)
14:56:46 <c_wraith> and lists and tuples are just special syntax.  they don't do anything semantically special.
14:56:48 <nizze> "The Haskell Report" looks scary
14:57:04 <MadHatterDude> nizze: I think so too...
14:57:04 <lament> the ll is silent
14:57:21 <MadHatterDude> lament: It is???
14:57:24 <lament> no
14:57:54 <geheimdienst> nizze, in the haddock documentation, you can click "source code" on the right hand side ... http://haskell.org/ghc/docs/latest/html/libraries/base-4.2.0.0/Prelude.html that helps me a lot
14:58:06 <MadHatterDude> Yay, my good stuff works now... But I still need to get a damn file opened and write to it.
14:58:11 <MadHatterDude> grr...
14:58:29 <c_wraith> MadHatterDude: don't worry, writing to a file is easy. :)
14:58:45 <c_wraith> (reading, if you use lazy IO, can be more complicated.  But writing is always easy.)
14:58:46 <nizze> geheimdienst: Thanks! that seems nice.
14:58:53 <metaperl[A]> In building haskell-platform on ubuntu, I am getting an error ( http://pastie.org/pastes/871125 ) -- unrecognized option `--with-cabal-install=../cabal-install-0.6.2/dist/build/cabal/cabal'
14:59:24 <MadHatterDude> c_wraith: Stange, I can't seem to see how "writeFile name somefile" is that difficult either, but it has been bothering me for a good 10 minutes.
14:59:30 <jmcarthur> :t map
14:59:31 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
14:59:33 <jmcarthur> :t sequence
14:59:34 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
14:59:37 <jmcarthur> nizze: ^^
14:59:47 <jmcarthur> :t \f -> sequence . map f
14:59:48 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => (a1 -> m a) -> [a1] -> m [a]
14:59:55 <jmcarthur> :t mapM
14:59:56 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
15:00:01 <c_wraith> :t withFile
15:00:01 <lambdabot> Not in scope: `withFile'
15:00:07 <c_wraith> :t System.IO.withFile
15:00:08 <lambdabot> forall r. FilePath -> GHC.IOBase.IOMode -> (GHC.IOBase.Handle -> IO r) -> IO r
15:00:17 <nizze> jmcarthur: Thanks but that's bit too high level
15:00:18 <jmcarthur> nizze: the difference between map and mapM is sequence
15:00:49 <c_wraith> :t System.IO.hPut
15:00:50 <lambdabot> Not in scope: `System.IO.hPut'
15:00:51 <MadHatterDude> nizze: sequance does the same as putting stuff in a do-statement
15:00:53 <c_wraith> :t System.IO.hWrite
15:00:54 <lambdabot> Not in scope: `System.IO.hWrite'
15:00:56 <jmcarthur> nizze: so you start with something like [IO a] and get something like IO [a]
15:00:57 <c_wraith> gah.
15:01:07 <jmcarthur> nizze: combine that with map and you get mapM :)
15:01:12 <nizze> :)
15:01:22 <nizze> Thanks, you guys are so helpful here.
15:01:32 * roconnor often uses map and sequence and forgets he can use mapM
15:01:37 <jmcarthur> yeah this is my favorite channel
15:01:43 <nizze> ;)
15:02:04 <nizze> How come Haskell's performance is so great?
15:02:10 <c_wraith> MadHatterDude: is the issue possibly having to do with relative paths?
15:02:17 <MadHatterDude> if I have a Data.ByteString.Lazy.writeFile in my main it should be executed, right?
15:02:19 <roconnor> nizze: because we have compilers?
15:02:25 <jmcarthur> nizze: because so much is statically known due to the type system
15:02:53 <c_wraith> MadHatterDude: can you put the code in a pastebin?
15:02:57 <jmcarthur> nizze: not only do we get performance despite the high levels of abstraction, we get performance precisely *because* of it, in this case!
15:03:17 <nizze> Things like map or (++) are rarely in the same language, usually those "frequently used" functions are written in C and are hidden somewhere.
15:03:28 <jmcarthur> nizze: for example, we have things called rewrite rules that can do high level optimizations, and you can even write your own rewrite rules in your own library
15:03:55 <jmcarthur> nizze: so for example, you could have a rewrite rule that changes anything of the form (map f . map g) into (map (f . g))
15:04:05 <c_wraith> nizze: that's often true of interpreted systems, but not so often in compiled system.  (I don't want to claim languages are compiled or interpreted.  that would be risky in this room :)
15:04:11 <jmcarthur> nizze: and this is statically guaranteed to be safe due to purity and nice type system :)
15:04:56 <nizze> Haskell's type system seems so good.
15:05:22 <nizze> After seeing it, it seems that Java and C# type systems are lying...
15:05:25 <lowasser> there's a reason so many people use it for type system *research*
15:05:36 <jlouis> nizze: that is also almost true
15:05:52 <nizze> I never understood how come functions which returns type Foo can also return null
15:05:53 <lament> it's almost true, and so are Java and C# type systems
15:06:08 <fax> > 9 - 16
15:06:09 <lambdabot>   -7
15:06:24 <fax> > 6*(-7)-16
15:06:25 <lambdabot>   -58
15:06:52 <jmcarthur> nizze: to be fair, we have something similar to null (undefined), but since you can't idiomatically observe it without nontermination it's not as prevalent in haskell programs
15:07:08 <lament> nizze: they return null because not being able to return null is very rarely useful
15:07:30 <jmcarthur> nizze: but nontermination is a member of every type
15:07:30 <Alpounet> their null is much like Nothing in Haskell...
15:07:31 <lament> nizze: i.e. most functions are not total
15:07:53 <jmcarthur> Alpounet: yes, but at least ours is in the type system as well
15:08:06 <Alpounet> yeah
15:08:26 <CalJohn> "their null" is much much more of a pain than Nothing.  Evaluating it normally causes a crash, and it's hard to predict where it will occur
15:08:28 <lament> having Nothing is so useful that I wouldn't mind having it in every type by default.
15:08:46 <nizze> Aha, okay.
15:08:55 <lament> CalJohn: nonsense, "evaluating null" is the same as fromJust on a Nothing which causes a crash just the same
15:08:57 <RichardBarrell> lament: please let's not.
15:09:29 <CalJohn> lament: yes, i know this
15:09:31 <nizze> How does the Haskell know whether function is pure?
15:09:41 <lament> RichardBarrell: it would be bad in Haskell because there's no sugar for it
15:10:12 <nizze> If I have function String -> String but use some function which causes I/O insied.
15:10:24 <nizze> *inside
15:10:29 <jmcarthur> nizze: it would be in the type signature
15:10:30 <dobblego> nizze, that will not compile, try it
15:10:36 <CalJohn> i think having Maybe in every type would damage the value of being able to isolate nullable types to small parts of the program
15:10:50 <jmcarthur> :t (undefined :: String -> IO String) :: String -> String
15:10:51 <lambdabot>     Couldn't match expected type `String'
15:10:51 <lambdabot>            against inferred type `IO String'
15:10:52 <lambdabot>     In the expression:
15:10:57 <jmcarthur> nizze: ^^
15:11:01 <paulmitchell> umm... unsafePerformIO?
15:11:11 <CalJohn> paulmitchell: shhh!  don't tell anyone!
15:11:13 <lament> CalJohn: true, except for "small parts"
15:11:16 <jmcarthur> paulmitchell: it's prefixed with "unsafe" for a reason
15:11:19 <lament> CalJohn: you can isolate IO to small parts of a program
15:11:21 <paulmitchell> arg! oops! eek!
15:11:26 <lament> CalJohn: but total functions are super-rare
15:11:29 <dobblego> paulmitchell, I recommend not mentioning that to beginners
15:11:37 <paulmitchell> it's important though...
15:11:39 <jmcarthur> lament: i disagree. i think total functions are very common
15:11:40 <dobblego> it only causes confusion
15:11:49 <dobblego> of course it's important; so are many things
15:12:10 <nizze> :D
15:12:13 <c_wraith> I think we should teach everyone about unsafeInterleaveIO, but not unsafePerformIO
15:12:15 <lament> jmcarthur: outside number-crunching, can't think of too many cases
15:12:36 <nizze> I'm aware of that thing unsafePerformIO, there's supposedly something bad about it...
15:12:52 <paulmitchell> ah, so this is like that thing where someone has a massive wart on the end of their nose, but no-one looks at it or talks about it? :D
15:12:59 <jmcarthur> nizze: it prevents the exact thing that is so nice about haskell: purity
15:13:05 <c_wraith> nizze: it basically has two issues.  One is that it lies to the type system.  The other is that it can work in unexpected ways because it lies to the type system
15:13:08 <lament> jmcarthur: oh i guess building up data structures
15:13:12 <jmcarthur> nizze: it means code that appears to be pure can have side effects
15:13:25 <CalJohn> lament: it seems like an interesting discussion to have (because I don't agree), but i'm quite busy, sorry!
15:14:04 <jmcarthur> nizze: you not only lose the ability to easily reason about your code, but so does the compiler. the problem with that latter point though is that the compiler still thinks it *can* reason about it and will do horrible horrible things to it if you aren't careful
15:14:05 <nizze> Ah I expected something like that.
15:14:33 <dobblego> paulmitchell, no, it's where we value education and do not overload beginners with too many concepts at once
15:14:34 <jmcarthur> nizze: the short story is "don't use unsafePerformIO unless you really know what you are doing"
15:14:34 <nizze> Hmm.. well it says unsafe in the name :P
15:14:50 <dobblego> and so now we have this
15:15:10 * jmcarthur maliciously mentions unsafePerformIO, unsafeInterleaveIO, unsafeCoerce
15:15:12 <fax> unsafePerformIO is pretty much completely useless
15:15:21 * jmcarthur waits for confused newbies to ask about them
15:15:32 <c_wraith> unsafeCoerce is good for segfaulting ghci
15:15:33 <jmcarthur> fax: i have used it, but only to implement "primitives"
15:15:49 <fax> it's not something you'd mention if you were teaching because it's also not even interesting
15:16:01 <jmcarthur> c_wraith: also good for telling the compiler things about types that it's not powerful enough to figure out by itself
15:16:04 <fax> so not interesting + not useful --> not worth making a big deal about
15:16:45 <nizze> I'm not into screwing with ghc, so far it always wins :D
15:16:52 <nus> jmcarthur, "in case you think you know what you are doing, rethink your thinking"? (-;
15:17:05 <c_wraith> unsafePerformIO was originally intended for building pure interfaces to external code via FFI.  It's still the only way to do that.
15:17:46 <paulmitchell> handy for tracing
15:17:50 <c_wraith> Of course, it helps if you're not lying to the compiler in the process, and the external code is actually pure. :)
15:17:59 <jmcarthur> nus: i've used unsafePerformIO to construct ivars before. also see my procrastinating-structure package or, perhaps more clearly showign my point, procrastinating-variable (which i didn't write)
15:18:28 <jmcarthur> paulmitchell: Debug.Trace is handier for tracing ;)
15:18:30 <nus> jmcarthur, ok, will do.
15:18:38 <jmcarthur> which is probably implemented using unsafePerformIO, though
15:18:50 <paulmitchell> jmcarthur: of course, I just hoogled the code for Debug.Trace, knowing exactly what I'd find :)
15:19:07 <jmcarthur> smart man
15:19:16 <paulmitchell> iow, someone who knew what they were doing
15:19:17 <opqdonut> print is taking a fourth of my running time
15:19:27 <opqdonut> could bytestring make it faster?
15:19:41 <c_wraith> is it really print, or is it calling show?
15:19:52 <opqdonut> show, probably
15:19:59 <c_wraith> because print is probably the first thing that actually forces your data structure, likely.
15:19:59 <opqdonut> just integers, tho
15:20:08 <c_wraith> oh.  *big* integers?
15:20:17 <opqdonut> not that big
15:20:17 <c_wraith> or just a lot of them?
15:20:46 <BONUS> why is the success continuation in the logic monad (a -> r -> r)
15:20:49 <BONUS> instead of (a -> r)
15:20:56 <opqdonut> well 10000 in this case
15:21:16 <c_wraith> really, it sounds like the time spent calculating the result is being attributed the the print call...  If the numbers aren't forced before they're being printed.
15:21:30 <nizze> jmcarthur: How come the compliler knows that I'm using side effecting function iside my function? I know that the type signature will say something like String -> IO (), but cant I just use some global function inside which is not visible from the function's type?
15:21:38 <tsou> Is there a specific version of automake and of autoconf that I should use?  I'm on OpenBSD, which has ghc-6.6.1, trying to build ghc-6.10.4.
15:21:45 <opqdonut> c_wraith: yeah, I guess that might actually be the case
15:21:58 <kmc> nizze, there are no side effecting functions
15:22:13 <opqdonut> I thought having a cost center for the stuff that makes the computation solved it
15:22:21 <opqdonut> but the work is accounted in the place that forces it, right?
15:22:30 <kmc> a value of type «String -> IO ()» is a pure, side-effect-free function.  what it returns is a recipe for performing effects
15:22:35 <jmcarthur> nizze: if there is a side effecting function it's in the type signature
15:22:38 <c_wraith> well, that's where the work is actually done. :)
15:22:41 <kmc> that's what «IO ()» represents
15:23:00 <choffstein> Hey all, quick stupid question: I think I somehow installed a second copy of 'process' (From this error: Loading package process-1.0.1.1 ... linking ... done.  Loading package process-1.0.1.2 ...).  process-1.0.1.2 was loaded using cabal.  How do I go about finding libraries dependent on it, and how can I remove it?
15:23:03 <c_wraith> opqdonut: try forcing the values before the print, and see if that changes things?
15:23:08 <jmcarthur> nizze: i can't construct a pure function from impure functions (without unsafePerformIO)
15:23:10 <opqdonut> yeah I could to that
15:23:27 <nizze> jmcarthur: let's forget about unsafePerformIO
15:23:28 <nizze> :)
15:23:34 <jmcarthur> okay, good idea :)
15:23:35 <c_wraith> good call. :)
15:24:15 <kmc> you can't merely think of IO as a tag on the type of a function  that marks it as impure
15:24:16 <jmcarthur> nizze: but that's part of the point. unsafePerformIO is the only function that take IO out of the result type, therefore if I don't use it then i can't get rid of it
15:24:21 <nizze> I basicallly mean that my function would take a String and use some globally visible IO functiona and return a string.
15:24:38 <jmcarthur> nizze: but this IO function you're talking about has IO in the type
15:24:49 <jmcarthur> nizze: therefore you can't just return a String
15:24:51 <nizze> jethomas: yes
15:25:06 <kmc> :t \x -> let y = putStrLn "Hello, world!" in x
15:25:07 <lambdabot> forall t. t -> t
15:25:18 <kmc> :t \x -> let y = putStrLn "Hello, world!" in (x :: String)
15:25:19 <lambdabot> String -> String
15:25:21 <jmcarthur> kmc: sure, but the you aren't actually using putStrLn
15:25:22 <nizze> but cant I unwraw the IO String like I could unwrap the Maybe String ?
15:25:26 <jmcarthur> *then you aren't
15:25:29 <kmc> yes, i'm trying to make that point
15:25:41 <jmcarthur> nizze: there is no "run function" for IO
15:25:41 <kmc> that's why we shouldn't talk about calling "impure functions" as how you perform IO
15:25:54 <kmc> nizze, you can't pattern-match the constructors of the IO type; they aren't visible
15:25:54 <jmcarthur> nizze: the run time system is the only run function for it, that is, and you can't call it manually
15:25:59 <kmc> whereas you can pattern match Just or Nothing
15:26:30 <kmc> nizze, if you import the right internal modules from GHC you *can* pattern match IO actions, and do all sorts of dark magic, for example implement unsafePerformIO
15:26:51 <jmcarthur> but that's a GHC module. discouraged for the same reasons as unsafePerformIO
15:27:39 <jmcarthur> @hoogle IO a -> a
15:27:39 <lambdabot> Foreign unsafePerformIO :: IO a -> a
15:27:39 <lambdabot> Data.ByteString.Internal inlinePerformIO :: IO a -> a
15:27:40 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
15:27:51 <jmcarthur> what is inlinePerformIO?
15:27:56 <lowasser> in general, the whole *point* of the IO module is that you can't unwrap it
15:28:02 <choffstein> Does anybody know how I can get rid of duplicate definition issues from having two versions of the 'process' library present on my machine?
15:28:02 <kmc> inlined version of unsafePerformIO
15:28:06 <nizze> Okay, but basically if I do IO (let's just forget about unsafePIO) inside a funciton it will show in the type because I cannot unwrapi IO like I can unwrap Maybe
15:28:14 <fax> ;(
15:28:20 <c_wraith> nizze: that's it exactly
15:28:28 <paulmitchell> nizze: correc
15:28:30 <paulmitchell> t
15:28:30 <jmcarthur> choffstein: ghc-pkg hide package-to-hide-1.0   or whatever
15:28:31 <lowasser> choffstein: most reliable approach is
15:28:40 <kmc> nizze, not really, you can get an IO action and throw it away, like my example above
15:28:45 <lowasser> I prefer just ghc-pkg unregister bad-version-of-package
15:29:00 <lowasser> kmc, nizze: but it's a good intutition to have
15:29:10 <kmc> i disagree
15:29:16 <kmc> you have to understand that IO actions are first-class
15:29:19 <nizze> kmc: could you rephrase your example
15:29:20 <kmc> and that IO-returning functions are pure functions
15:29:26 <choffstein> What happens if I have different packages that are reliant on different versions of the library?
15:29:26 <lowasser> true fact
15:29:37 <lowasser> choffstein: reinstall them, is the easiest way
15:29:41 <jmcarthur> nizze: the real gist we are trying to get at is that you don't call an IO function. you just create a main action, and the runtime calls it
15:29:42 <lowasser> seriously
15:29:48 <choffstein> lowasser: okay, thank you
15:29:52 <jmcarthur> nizze: IO actions are composed, not run, basically
15:30:01 <kmc> nizze, any function anywhere could contain, syntactically, a call to putStr.  the point is that calling putStr does not put any str; it returns an IO action.  and an IO action is pretty useless unless you glue it into some other IO actions that make up "main"
15:30:11 <lowasser> you can treat IO a as a value like any other type
15:30:16 <jmcarthur> nizze: so a haskell program is just an IO action that you constructed out of smaller pieces
15:30:19 <kmc> so if you call putStr within a function that does not return an IO action, you know that the action is "lost"
15:30:27 <lowasser> but you can't get access to the "value" inside it without working inside the IO monad, or without running the program
15:30:30 <kmc> (unless it returns, for example, a type which contains IO actions)
15:30:44 <ksf> http://www.cs.brown.edu/people/acb/codebubbles_site.htm
15:30:50 <ksf> I want that for haskell
15:30:54 <jmcarthur> > [putStrLn "foo", print 5] !! 1
15:30:55 <lambdabot>   <IO ()>
15:31:29 <c_wraith> IO is fun, because it's nothing special.  You can even have type like "a -> IO (IO a)" and have them be coherent and useful.
15:31:35 <jmcarthur> ^^ in that i didn't end up using the first action, but i did use (or at least didn't throw away) the second action
15:31:56 <nizze> Ah
15:32:01 <ksf> but then, we don't even get hare working, much less integrated with anything else but itself.
15:32:02 <nizze> Now I got it...
15:32:03 <fax> c_wraith, I like this!
15:32:16 <fax> no strange edge-cases is very nice
15:32:18 <jeffwheeler> How can I propose a SoC idea while the Trac is broken?
15:32:20 <kmc> the "Beautiful Concurrency" paper defines a (useful!) function of type [(STM a, a -> IO ())] -> IO ()
15:32:22 <jeffwheeler> Should I send it to the mailing list?
15:32:33 <lowasser> jeff: probably
15:32:47 <lowasser> alternatively you can throw it out here for grins =)
15:32:52 <paulmitchell> kmc: is that the one published in the "Beautiful Code" book?
15:32:55 <kmc> yes
15:32:56 <jeffwheeler> lowasser, alright
15:33:00 <jmcarthur> nizze: haskell is called functional because functions are first class and can be passed around, but haskell also make IO actions first class... i don't know what to call that :)
15:33:01 <nizze> So IO a is value representing an side effect waiting to be executed
15:33:05 <Twey> But is a -> IO (IO ()) isomorphic to IO (a -> IO ())?
15:33:06 <paulmitchell> kmc: that's what got me into Haskell in the first place
15:33:08 <kmc> jmcarthur, you call it "imperative"
15:33:09 <jmcarthur> nizze: exactly
15:33:14 <jeffwheeler> I think the layout code in xmonad could be abstracted for integration in other projects like Yi.
15:33:21 <lowasser> Twey: no!
15:33:23 <jmcarthur> kmc: imperative languages don't necessary give you actions as first class objects
15:33:24 <ksf> jmcarthur, imperative programming
15:33:37 <kmc> jmcarthur, i'd like to revoke the term for the ones that don't ;)
15:33:41 <kmc> but also, the good ones do
15:33:41 <c_wraith> Twey, in the case of IO, I don't think it is.
15:33:42 <lowasser> you can't get inside a  IO (a -> IO ()) withotu going into the IO monad
15:33:51 <ksf> what's usually called an imperative language isn't imperative at all, because it lacks first-class actions
15:33:52 <kmc> in that most of them muddle together "function" and "action", and the good ones have first class functions
15:33:57 <lowasser> but you can apply a function of type a -> IO (IO ()) to a value
15:34:10 <fizruk> who knows, what for could this be written: "let len = case length cs of l -> l" ?
15:34:13 <ksf> in the same sense that a functional language without first-class functions isn't properly functional
15:34:14 <Twey> lowasser: But it doesn't do anything until you go inside IO anyway
15:34:23 <nizze> But wait!!! Having IO as a first class value if so F*CKING COOL!
15:34:26 <HugoDaniel> hi
15:34:32 <c_wraith> nizze: yes, it is. :)
15:34:37 <ksf> I think we should go zen and say that haskell is a non-dysfunctional language.
15:34:42 <lowasser> Twey: consider the following
15:34:55 <jmcarthur> kmc: i once argued that haskell is a better imperative language precisely because it allows you to *escape* the imperative world, while most "imperative" languages just throw you in it and keep you there
15:35:10 <jmcarthur> nizze: and now you are drinking the koolade :)
15:35:25 <kmc> i think this is important for advocacy as well as understanding.  if you hear about Haskell and you think that IO is a tag on functions to mark them as impure, it sounds stupid and limiting
15:35:30 <nizze> WOW! So basically this means that I could write bunch of code which which causes side effects and later on select which of those I actually want to run
15:35:32 <lowasser> do {writeFile "myFile" "thisText"; thisThing <- readFile "myFile"; return (\ xs -> return (thisThing ++ xs))
15:35:37 <kmc> nizze, yes
15:35:38 <lowasser> nizze: EXACTLY
15:35:39 <jmcarthur> nizze: right
15:35:46 <lowasser> how badass do you feel now?
15:35:48 <kmc> nizze, it also means you can define your own control flow
15:35:50 <c_wraith> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23998#a23998 uses IO (IO a) in a very silly way.
15:35:50 <lowasser> Twey:
15:35:55 <kmc> because you can make functions that take as well as return IO values
15:36:12 <kmc> for example mapM_ is basically a "for" loop, but it's an ordinary Haskell function
15:36:13 <nizze> lowasser: REALLY!
15:36:13 <lowasser> we can have actions getting performed by the outside IO
15:36:44 <lowasser> and if we applied a function of type (a -> IO (IO ())) several times, then we'd *have* to apply that action several times
15:36:45 <jmcarthur> nizze: i one wrote my own cooperative scheduler in plain haskell, and that's not even such a crazy sounding thing for haskell :)
15:36:56 <kmc> jmcarthur, using continuations?
15:37:02 <jmcarthur> nizze: but it could fork threads, context switch, everything
15:37:12 <jmcarthur> kmc: yeah
15:37:14 <lowasser> but if we have an IO (a -> IO ()), then there might be some "outside" action that only gets applied once before that function is generated
15:37:20 <nizze> Hmm.. This sounds like Haskell does side effects better than imperative languages...
15:37:28 <HugoDaniel> :)
15:37:29 <jmcarthur> nizze: and it's all because i could *control* my side effects
15:37:47 <Twey> lowasser: But see also \xs -> writeFile "myFile" "thisText" >> readFile "myFile" >>= return . (++ xs)
15:37:54 <lowasser> yes
15:38:00 <lowasser> and so if we apply that function several times
15:38:01 <kmc> nizze, STM is another good example of higher-order imperative programming... we define a new monad "STM" with stronger concurrency guarantees than IO.  then we define a function «atomically :: STM a -> IO a» to embed a block of STM actions into IO
15:38:08 <lowasser> then we perform (writeFile "myFile" "thisText") several times
15:38:13 <kmc> RWH has a great chapter about STM if you're interested
15:38:16 <nizze> Ah! So now I understand why IO is special and everything else is plain Haskell
15:38:21 <jmcarthur> nizze: with power comes responsibility, and that's where the type system comes in, and it's why we have some of the odd-looking limitations, like the difference between map and mapM
15:38:38 <lowasser> so Twey: let's say instead of writeFile "myFile" myText"
15:38:40 <kmc> nizze, there are a few other monads with special implementation like IO
15:38:41 <lowasser> we had something that
15:38:43 <Twey> lowasser: Yes, but to get to the end result (thisThing ++ xs) that has to happen anyway
15:38:46 <kmc> such as ST and STM
15:38:47 <lowasser> holdup
15:38:49 <jmcarthur> nizze: IO is special because it doesn't have a run function. it's not special for any other reason
15:38:50 <Twey> Aye-aye
15:38:53 <nizze> kmc: I'm reading RWH all the tme
15:39:05 <kmc> but in general, monads are ordinary Haskell datatypes defined in Haskell
15:39:09 <Twey> jmcarthur: STM doesn't have a run function either :Ã¾
15:39:13 <kmc> and in general they can have a "run" function
15:39:17 <jmcarthur> Twey: then it's special ;)
15:39:19 <nizze> jmcarthur: yes
15:39:21 <lowasser> writeFile "myFile" (liftM show getCurrentTime)
15:39:22 <ksf> nizze, it doesn't eliminate off-by one errors if you code your algorithms non-functional, or magically fix the order of statements to be.
15:39:27 <jmcarthur> Twey: but really, atomically is a kind of run function
15:39:29 <lowasser> writes the current time into "myFile"
15:39:38 <ksf> that's the reason why we tend to keep code non-imperative, anyway.
15:39:53 <Twey> lowasser: I suppose so
15:40:06 <Twey> jmcarthur: No, it's a kind of lift :Ã¾
15:40:14 <ksf> .oO( run is not a feature of monads )
15:40:20 <kmc> that works if:  writeFile :: FilePath -> IO String -> IO ()
15:40:25 <kmc> which i don't think is the case
15:40:28 <kmc> :t writeFile
15:40:28 <lambdabot> FilePath -> String -> IO ()
15:40:31 <lowasser> then the function (\ xs -> do{ writeFile "myFile" (liftM show getCurrentTime); thisThing <- readFile "myFile"; return (\ xs -> return (thisThing ++ xs))}
15:40:37 <lowasser> whoops
15:40:44 * hackagebot redis 0.3.1 - A driver for Redis key-value database  http://hackage.haskell.org/package/redis-0.3.1 (AlexanderBogdanov)
15:40:44 <dancor> lament: well i didn't quite get 8 ply but this is my initial repertoire: http://github.com/dancor/goldbug/blob/master/best-repertoire
15:40:56 <Twey> Well, lowasser obviously meant fmap show getCurrentTime >>= writeFile "myFile"
15:40:58 <nizze> Whoa! Thanks guys! I feel like my bain's exp is ^2
15:40:59 <Twey> Or something like that
15:41:05 <lowasser> Twey: they're equivalent ;)
15:41:05 <jmcarthur> Twey: newtype STM a = STM { atomically :: IO a }   -- that's not true, but it's not a complete lie either
15:41:13 <paulmitchell> nizze: that's normal :)
15:41:28 <Twey> lowasser: No, 'cause yours didn't typecheck, as kmc pointed out ;)
15:41:31 <lowasser> one mo'
15:41:51 <Twey> lowasser: But it's not important.  I get what you're saying.
15:41:54 <nizze> And I also feel that other languages are some candymen which are trying to lure me into their gingerbread houses..
15:41:56 <lowasser> I meant =<<
15:42:00 <lowasser> lololol
15:42:03 <lowasser> okay, so
15:42:15 <ksf> jmcarthur, to be precise, both STM and IO are newtypes around that -> World# thingie, at least in ghc.
15:42:18 <lowasser> yeah, the (a -> IO ()) version will always return the current time, essentially
15:42:34 <ksf> you can do instance MonadFix STM where mfix = unsafeCoerce fixIO
15:42:35 <lowasser> and the IO (a -> IO ()) will return a function that returns the time that the *outside* IO action was evaluated
15:42:37 <jmcarthur> nizze: "I feel like my bain's exp is ^2" ... and you're just getting started ;)
15:43:13 <nizze> jmcarthur: Well that happened first time when I did last = reverse . first
15:43:15 <lament> dancor: those openings probably have real names
15:43:24 <lowasser> moreover, the (a -> IO ()) version will *always* have to execute its action every time
15:43:37 <ksf> nizze, last = head . reverse?
15:43:47 <nizze> ksf: Yeah...
15:43:47 <dancor> lament: how might i find them?
15:43:59 <dancor> i looked on sensei's library
15:44:26 <lament> um... from a book maybe :)
15:44:28 <dancor> i was most surprised by the "3-3 high" opening
15:45:02 * ksf thinks we should introduce (|) as flip (.)
15:45:05 <lament> i can't visualize them, and can't put them on a board at work :(
15:45:12 <nizze> jmcarthur: This has been one of most enlighting moments of my life... I never imagined I could be in so much control...
15:45:24 <ksf> we could then pretend to be a sh-decendent language.
15:45:53 * Twey likes flip (.)'s
15:46:01 <geheimdienst> nizze, imagine how enlightened you'll feel once you get to the zygomorphisms http://www.willamette.edu/~fruehr/haskell/evolution.html ;-)
15:46:27 <jmcarthur> heh, yeah, the bigger the word the more enlightening it is. everybody knows this
15:46:28 <Twey> My method of writing a pipeline function generally involves working from the right but typing left-to-right, which is really annoying because I have to skip back after each termâ€¦
15:46:32 <jmcarthur> IO is a short word
15:46:49 <ksf> I actually write them in both directions.
15:46:55 <masxmasx> > [1..]
15:46:56 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
15:47:10 <ksf> if you know what you want to have, starting form the left is quite easy
15:47:10 <kmc> :t (>>>)
15:47:12 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
15:47:22 <Twey> Yeah, >>> is my friend â˜º
15:47:24 <c_wraith> heh.  that looks like caleskell
15:47:37 <[swift]> is there any way i can import a specific version of a module?
15:47:39 <kmc> yeah but 'tis in the standard Control.Arrow as well
15:47:43 <ksf> the worst thing one can do is mixing directions, though.
15:47:49 <fax> @instances-importing Control.Category.Category Category
15:47:49 <lambdabot> Couldn't find class `Category'. Try @instances-importing
15:47:54 <kmc> [swift], GHC supports a "package-qualified imports" extension
15:47:57 <fax> @instances-importing Category Control.Category.Category
15:47:57 <lambdabot> (->)
15:48:04 <fax> what a pointless thing to defined...?
15:48:08 <fax> @instances-importing Category Control.Category
15:48:08 <kmc> which?
15:48:08 <lambdabot> Couldn't find class `Control.Category'. Try @instances-importing
15:48:12 <Twey> c_wraith: Not with quite those types though â˜º
15:48:14 <fax> it's only (->)
15:48:20 <jmcarthur> if i'm working with a long chain of function compositions i usually start with (undefined :: Foo -> Bar), then compose a function on its right and change the type signature, then compose another function and change its type signature, and i just repeat until i can get rid of the undefined and have the overall type i want
15:48:25 <Twey> c_wraith: Usually s/Category/Arrow/
15:48:29 <kmc> fax, sure, but you can invent more instances
15:48:30 <[swift]> kmc: thanks, i'll look that up
15:48:35 <fax> such as?
15:48:44 <ksf> fax, that's because control.category only comes shipped with Hask
15:48:45 <rryan> Hi all, dumb question. I'm trying to use cabal. I installed haskell-platform-2009.2.0.2 on my Ubuntu 9.10 machine, I have ghc 6.10.4 from the 9.10 repositories. I have run cabal update and when I type `cabal install giti' I get the following: http://pastebin.com/wXtmXTyh How can I fix that?
15:48:58 <ksf> you have to implement other concrete categories yourself.
15:49:00 <rryan> sorry, gitit not giti
15:49:08 <kmc> fax, well, i once wrote a language of video filters that could be composed like functions
15:49:12 <jmcarthur> ksf: kleisli, too
15:49:16 <kmc> fax, they had identity and associative composition, so formed a Category
15:49:49 <kmc> fax, but they weren't Haskell functions (i had a first-order code representation compiling to C++ and GLSL) and they weren't Arrows either (because that requires a morphism from Hask, i.e. arr :: (a -> b) -> (a ~> b))
15:49:53 <jmcarthur> oh, it's in Control.Arrow
15:50:11 <jmcarthur> @instance-importing Category Control.Arrow
15:50:12 <lambdabot> Couldn't find class `Control.Arrow'. Try @instances-importing
15:50:26 <jmcarthur> @instance-importing Control.Arrow Category
15:50:27 <lambdabot> Couldn't find class `Category'. Try @instances-importing
15:50:37 <jmcarthur> can i import more than one module with that?
15:50:41 <ksf> fax, I think the most popular one is Cat, which is the category of cute kittens.
15:51:17 <jmcarthur> i think arr should be the only member of Arrow (and should still require Category) and the other stuff should be separated from it
15:51:24 <ksf> where objects are furry and arrows are cuddly.
15:51:30 <jmcarthur> and the other stuff should nto require Arrow, that is
15:51:39 <jmcarthur> because arr is very limiting
15:51:54 <ksf> it's actually iso to CoDog.
15:53:29 <kmc> jmcarthur, then "Arrow (~>)" is just "Functor Hask (~>)"
15:53:50 <lament> dancor: note that after each common opening there's a bunch of popular lines of play
15:53:53 * hackagebot haddock 2.7.1 - A documentation-generation tool for Haskell libraries  http://hackage.haskell.org/package/haddock-2.7.1 (DavidWaern)
15:53:56 <jmcarthur> kmc: right. i was just avoiding going to a tangent by not pointing that out ;)
15:54:01 <kmc> ;)
15:54:06 <lament> dancor: popular in the sense that people know them, but not in the sense that they get played a lot
15:54:19 <lament> dancor: so you won't necessarily find them by statistical analysis
15:54:35 <[swift]> ok, even with package-qualified imports, i'm having trouble. the problem is that i installed parsec 3 and now it seems to have "replaced" parsec 2. I now get the error "Failed to load interface for `Text.ParserCombinators.Parsec': It is a member of the hidden package `parsec-2.1.0.1'."
15:54:49 <lament> dancor: obsolete joseki basically
15:55:09 <kmc> [swift], i think in Parsec 3 it's just called "Text.Parsec" isn't it?
15:55:28 <lament> dancor: but when you're actually playing, it's quite possible that such a line comes up (they tend to be "obvious" moves) so it helps to know how to respond
15:55:50 <lament> so statistical analysis doesn't show you this, but a book does
15:56:08 <dancor> mm
15:56:14 <[swift]> kmc: well, before i added the package-qualifier to the import statement, it successfully imported Parsec as usual but the types of some Parsec functions had changed, breaking my code
15:56:19 <lament> i guess my point is that pro games aren't random good games
15:56:31 <lament> so statistical analysis is inaccurate
15:56:34 <[swift]> kmc: i'd really just like to use Parsec 2 for this code rather than port it over
15:56:43 <lament> they aren't random because pros have seen many past games and take them into account
15:56:44 <dancor> inaccurate to what tho :)
15:57:17 <dancor> i don't think this is a worse 6ish-ply repertoire than you can get by other means
15:57:19 <lament> like, a bunch of josekis are "popular" but never actually played
15:57:36 <dancor> assuming that you are so bad that you don't have a type-of-game-you-are-stronger-at yet
15:58:06 <krey> Can anyone help me with exception handling during unfolding of trees?
15:58:16 <lament> it's widely assumed that if you're below at least dan level, it doesn't matter where you place the first few moves :)
15:58:54 <dancor> lament: ya.  this is mostly so that i can gain familiarity with a setup that i'll possibly still be using once i'm dan
15:58:55 <evanbd> Unless, of course, you wind up in one of those messy josekis that your opponent happens to know and you don't :)
15:59:22 <Mathnerd314> no Haskell binding for http://icculus.org/physfs/ ? :-(
15:59:45 <ivanm> Mathnerd314: I highly doubt it
15:59:48 <dancor> i'll think about what you said and how future analyses might be improved
15:59:53 <ivanm> Mathnerd314: if you want them, write them
16:00:27 <Mathnerd314> ok, ok...
16:01:01 <geheimdienst> so, i have a newbie problem with an Int32 vs. Word32 ... http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23995#a23995
16:01:15 <geheimdienst> anyone got any ideas? it's probably 10 seconds to solve for you guys :)
16:02:02 <jmcarthur> :t let clamp x bound = min (max x 0) bound in clamp
16:02:03 <lambdabot> forall a. (Ord a, Num a) => a -> a -> a
16:02:07 <jmcarthur> geheimdienst: ^^
16:02:13 <krey> Exception handling, unfolding trees anyone, please?
16:02:34 <geheimdienst> yes, that's part of the problem ... it shouldn't be "a" three times
16:02:41 <ivanm> geheimdienst: to convert from one to another, use fromIntegral
16:02:55 <jmcarthur> geheimdienst: it takes two inputs and has one output. looks right to me
16:03:02 <dancor> i'm also interested in comparing like last10years to last2.  but there are so few games in the collections i have access to (like two orders of magnitude less than for chess).  idk if that's bc fewer pro games are played, or collections still have bad coverage
16:03:05 <geheimdienst> i tried a -> b -> a and then said fromIntegral bound, but that didn't work out
16:03:23 <jmcarthur> geheimdienst: look at the type for min and max
16:03:26 <jmcarthur> :t min
16:03:27 <lambdabot> forall a. (Ord a) => a -> a -> a
16:03:28 <jmcarthur> :t max
16:03:29 <lambdabot> forall a. (Ord a) => a -> a -> a
16:03:37 <jmcarthur> you can't compare values of different types
16:04:06 <jmcarthur> fromIntegral didn't work?
16:04:16 <jmcarthur> :t let clamp x bound = min (max x 0) (fromIntegral bound) in clamp
16:04:17 <lambdabot> forall a a1. (Integral a1, Ord a, Num a) => a -> a1 -> a
16:04:25 <jmcarthur> looks fine to me
16:05:17 <ezyang> Any Planet Haskell admins around?
16:05:55 <ezyang> I'd appreciate it if someone could apply http://lists.planetplanet.org/archives/devel/2007-July/001608.html so I can edit my blog posts without fear of spamming everyone repeatedly :-/
16:06:02 <kmc> krey, you're more likely to get help if you describe your problem
16:06:07 <kmc> and put code on hpaste if applicable
16:06:31 <ivanm> ezyang: agreed
16:06:53 <ivanm> ezyang: email the planet.haskell maintainer?
16:07:01 <ezyang> ivanm: Aww, but IRC was so much easier :-)
16:07:06 <ezyang> Yeah, I'll prolly do that
16:07:11 <rryan> hi all, I can't seem to install strict-concurrency-0.2.3 from cabal -- I get this error: http://pastebin.com/cMjXzTH4 Does anyone know what steps I can take to debug or fix this?
16:08:24 <geheimdienst> jmcarthur, uh well, fromIntegral fixes the problem in my test program, but not in the one i was actually working on *head scratch*
16:08:26 <geheimdienst> hang on
16:09:15 <ivanm> rryan: what version of ghc do you have?
16:09:53 <ivanm> rryan: oh, are you using cabal-install?
16:10:04 <ivanm> looks like the developer of strict-concurrency is naughty...
16:10:33 <rryan> ghc 6.10.4 from the ubuntu 9.10 repositories, and I am using haskell-platform-2009.2.0.1
16:10:40 <ivanm> @slap dons
16:10:40 <lambdabot> *SMACK*, *SLAM*, take that dons!
16:10:47 <ivanm> rryan: there's a bug in strict-confurrency
16:10:53 <ivanm> *concurrency
16:11:01 <dons> there is?
16:11:14 <dons> i just uploaded a new version though. what's the bug?
16:11:17 <ivanm> you have strict-concurrency dep on base >= 3 && < 5, yet it uses Control.OldException
16:11:22 <ivanm> which is in base 4
16:11:29 <rryan> ivanm : ah I see -- I was trying to install gitit, and gitit complains that strict-concurrency-0.2.3's build fails
16:11:43 <ivanm> rryan: anyway, cabal /= cabal-install
16:11:43 <Mathnerd314> what is this? http://pastebin.com/v8TfzKfK
16:11:46 <dons> oh, not in 3?
16:11:51 <geheimdienst> (confurrency obviously is the package that contains the category Cat and all the cute kittens)
16:11:54 <dons> tommd: around? did you see Neil's talk today?
16:11:56 <krey> kmc: I am writing very basic proof writer
16:12:05 <ivanm> rryan: http://ivanmiljenovic.wordpress.com/2010/03/15/repeat-after-me-cabal-is-not-a-package-manager/
16:12:08 <krey> kmc: that is, for propositional logic
16:12:17 <ben> cabal is not a package manager
16:12:20 <ivanm> dons: no, the whole point of oldexception is to let base-4 users migrate from base-3 by changing an import
16:12:29 * ivanm pats ben on the head
16:12:33 <dons> i must have forgotten i was using that.
16:12:33 <ben> :3
16:12:41 <dons> wish there was an api checker...
16:12:41 <ivanm> dons: heh
16:12:57 <ivanm> rryan: anyway, cabal install strict-concurrency --constraint="base == 4.*"
16:13:00 <ivanm> that should do the trick
16:13:02 <ivanm> dons: agreed
16:13:05 <benmachine> cabal is a hackage manager?
16:13:11 <krey> I have it mostly figured out, apart from the exception handling
16:13:19 <rryan> ivanm : Ahh ok thanks. I am exactly the person you describe in that post then. :S
16:13:21 <ivanm> benmachine: no, cabal is the common architecture for building applications and libraries
16:13:26 <jmcarthur> hmm... would be nice to write a program that builds packages with all possible combiantions of dependencie, runs tests, etc.
16:13:28 <ivanm> rryan: :D
16:13:35 <benmachine> ivanm: isn't that Cabal
16:13:43 <ivanm> jmcarthur: could get rather large
16:13:46 <jmcarthur> *builds a particular package with all possible dependencies
16:13:48 <ivanm> benmachine: yes, but you did say cabal
16:13:51 <ivanm> cabal-install /= cabal
16:14:01 <jmcarthur> ivanm: it would be a run-once-before-uploading-to-hackage kind of thing
16:14:08 <ivanm> jmcarthur: e.g. how far back wrt ghc would you go?
16:14:14 <mreh> I've got an Yampa.Event, need to convert it into a signal function that gives an acceleration on "Event ()", even just a general solution to making my spaceship thrust properly
16:14:20 <jmcarthur> ivanm: ghc and base would make it more complex
16:14:25 <krey> so, propositional logic proof solver anyone?
16:14:28 <jmcarthur> i just mean libraries in general
16:14:31 <rryan> ivanm: http://pastebin.com/FMrn7zxy
16:14:33 <fax> krey what?
16:14:48 <jmcarthur> maybe excluding base unless the user has multiple ghc versions installed
16:14:48 <ivanm> the current problem here is that dcoutts added a hack to cabal-install to default to base-3 due to the number of old dodgy packages that didn't have an upper bound for the version of base but didn't build with base-4
16:15:00 <krey> fax: struggling to write program to prove propositional formulas
16:15:06 <ivanm> rryan: hmmm.... cabal clean first?
16:15:09 <jmcarthur> i really don't like cabal-install's defaulting
16:15:10 <fax> krey, do you have an algorithm
16:15:13 <jmcarthur> i wish it would just go away
16:15:16 <krey> fax: yep
16:15:19 <jmcarthur> it confuses me
16:15:25 <ivanm> rryan: looks like it's trying to use its previous build stage...
16:15:29 <krey> fax: proofs are constructed as trees
16:15:30 <fax> krey, but you have not managed to implement it perfectly?
16:15:31 <rryan> 'No cabal file found' when I typed `cabal clean' ?
16:15:36 <ivanm> rryan: oh, right
16:15:37 <ivanm> hmmm...
16:15:45 <ivanm> jmcarthur: yeah, maybe its time dcoutts removed that defaulting
16:15:54 <benmachine> I dunno
16:15:55 <krey> fax: yes, proof should fail as soon as a single branch fails
16:16:02 <fax> ???
16:16:09 <benmachine> it's kind of handy to make people get their acts together wrt dependency specification
16:16:09 <ivanm> rryan: try removing the strict-concurrency folder from ~/.cabal/packages/
16:16:19 <ivanm> benmachine: most people have
16:16:20 <mreh> the "tableau" method
16:16:27 <ivanm> except for the friggin lazy ones that use base < 10
16:16:29 <krey> fax: by failure i mean find counterexample
16:16:49 <jmcarthur> i don't think cabal-install should have to account for the sloppiness of the packages on hackage
16:16:55 <jmcarthur> the packages should be updated, not babied
16:16:55 <mreh> it's analogous to boolean logic, i've written one of those
16:17:05 <rryan> ivanm : :-/ http://pastebin.com/kG1cXZP9
16:17:05 <ivanm> @ask dcoutts maybe it's time you remove the defaulting to base-3 from cabal-install; there was just a case now in #haskell where a package failed _because_ it defaulted to base-3 when it should have used base-4
16:17:05 <lambdabot> Consider it noted.
16:17:10 <mreh> it'll take you five minutes
16:17:17 <dons> ivanm: wait till the hackathon
16:17:22 <krey> mreh: probably
16:17:27 <ivanm> dons: well, I won't be there ;-)
16:17:36 <ivanm> rryan: weird... it isn't providing all the deps, etc. for it
16:17:49 * ivanm wonders where else strict-concurrency stuff might be found
16:17:53 <krey> mreh: I couldn't do it for a month, five minutes would be fantastic!
16:18:01 <geheimdienst> ok, i don't know what's going on ... here is the actual code i'm trying to fix: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23999#a23999
16:18:14 <mreh> krey: I'll give you the source code
16:18:23 <geheimdienst> i *thought* the little test program was essentially the same, but apparently it isnt
16:18:30 <rryan> this might be relevant : `cabal install base' says 'cabal: internal error: impossible' ?
16:18:35 <geheimdienst> any ideas?
16:18:40 <krey> mreh: can't you just tell me how you handle exceptions
16:18:49 <krey> mreh: also, what proof system are you using?
16:19:02 * ivanm tries building strict-concurrency himself to work out what's happening
16:19:09 <mreh> krey: proof by exhaustion
16:19:12 <jmcarthur> geheimdienst: are you intending to rebind x y w h the way you are?
16:19:17 <ivanm> :o it worked...
16:19:29 <ivanm> dammit, dcoutts must have removed that restriction for cabal-install-0.8.*
16:19:30 <jmcarthur> geheimdienst: the redefinition of w might be using the new definition of x, for example
16:19:30 <mauke> geheimdienst: (hint: the answer is "no")
16:19:31 <krey> mreh: that is unknown to me, I use sequents
16:19:45 <jmcarthur> i'm not really reading too deeply into it though
16:19:48 <jmcarthur> i'm about to leave
16:20:08 <mreh> krey: you just evaluate the expression with all the possible evaluations of the variables
16:20:31 <mauke> geheimdienst: you can use fromIntegral to convert between integer types
16:20:39 <fax> > all (True : cycle False)
16:20:40 <lambdabot>   Couldn't match expected type `[GHC.Bool.Bool]'
16:20:40 <lambdabot>         against inferred typ...
16:20:41 <Alpounet> defaulting to base-3.x also adds many warnings when building libs
16:20:42 <krey> mreh: ah, you mean a sat solver...
16:20:45 <fax> > all (True : repeat False)
16:20:46 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
16:20:46 <lambdabot>         against inferred ...
16:20:54 <fax> > and (True : repeat False)
16:20:55 <lambdabot>   False
16:20:59 <mreh> I think I implemented tableau in my first year logic classes, let's see if I can get the source code, I doubt it
16:21:07 <krey> mreh: I already did that
16:21:07 * ivanm wonders what package he can try to build that he know will fail
16:21:23 <krey> mreh: do you know sequent calculus?
16:21:34 <mreh> krey: I thought we were talking about prop calculus
16:21:42 <fax> krey, what algorithm
16:22:06 <krey> fax: do you know sequents?
16:22:11 <radsis> is it possible to do nested list comprehsension, something like [ [x,y,x|y<-b,z<-c] |x<-a]
16:22:14 <radsis> ?
16:22:16 <krey> fax: cause there's only one algorithm for them :)
16:22:17 * hackagebot th-kinds 0.0.0 - Automated kind inference in Template Haskell.  http://hackage.haskell.org/package/th-kinds-0.0.0 (LouisWasserman)
16:22:35 <lowasser> shweeeeeeet.
16:22:37 <fax> what agorithm
16:22:44 <rryan> ivanm : hmm I wonder if this has do with my install being broken somehow. Should I be compiling GHC myself or should is it ok to use the Ubuntu 9.10 ghc6 package (it's ghc 6.10.4)
16:22:45 <krey> mreh: Sequent calculus is a proof system over PL
16:22:48 <jmcarthur> radsis: probably, but you can probably get the same thing without the nesting
16:23:03 <fax> what is the descrption of the algorithm you use
16:23:10 <lowasser> radsis: yes.
16:23:11 <fax> would likie to use*
16:23:12 <ben> > let (a, b, c) = ([1, 2], [3, 4], [5, 6]) in [ [(x,y,x)|y<-b,z<-c] |x<-a]
16:23:13 <lambdabot>   [[(1,3,1),(1,3,1),(1,4,1),(1,4,1)],[(2,3,2),(2,3,2),(2,4,2),(2,4,2)]]
16:23:16 <ivanm> rryan: should be OK to use ubuntu's
16:23:26 <mreh> krey: so is tableau :)
16:23:31 <ben> I must have done that wrong
16:23:33 <ben> Oh
16:23:34 <jmcarthur> radsis: [(x, y, x) | x <-a, y <- b, z <- c]
16:23:35 <ivanm> rryan: I'm just trying to work out why it isn't doing all the configuring again...
16:23:43 <mreh> you negate the formula
16:24:10 <krey> fax: you have a sequent, and you apply a rule to it, the rule will either give you one or two sequents, to which you apply an appropriate rule again, until reaching a sequent that can not be simplified
16:24:15 <krey> fax: this creates a tree
16:24:32 <ivanm> anyone knows where cabal-install does the building of packages?
16:24:35 <fax> krey, can I see your data?
16:24:40 <fax> I mean the tree and so on
16:24:45 <mreh> why don't haskell newbies start with easy problems :D
16:25:04 <krey> mreh: cause I'm not a newbie :P
16:25:06 <ben> I thought Haskell made the hard things easy
16:25:10 <mreh> D:
16:25:25 <mreh> it makes things that shouldn't be hard easy
16:25:35 <lowasser>  ben: Haskell adds a whole new dimension of hard, but it makes the old hard stuff easy
16:25:35 <mreh> it makes easy things hard also
16:25:37 <benmachine> @quote impossible
16:25:37 <lambdabot> adam says: Lisp is like Ruby with an ugly syntax, impossible stdlib, and some macros that don't compensate for above shortcomings
16:25:41 <benmachine> oh pff
16:25:45 <benmachine> @quote impossible.just
16:25:45 <lambdabot> <autrijus> says: Perl: "Easy things are easy, hard things are possible" <autrijus> Haskell: "Hard things are easy, the impossible just happened"
16:25:57 <fax> krey, I don't see how you do this because what about proving  a -> b -> c -> d -> b,  I mean to prove b you must find it in your list of hypothesis right? but what if proving 'b' meant constructing something difficult from 'a' and so on?
16:26:04 <ivanm> rryan: do you have anything in /tmp/ that looks like it's from strict-concurrency being built?
16:27:03 <rryan> ivanm : I don't think so -- when I removed ~/.cabal/packages/hackage.haskell.org/strict-concurrency it looks like cabal re-downloaded it
16:27:05 <krey> fax: this is some old code: http://pastebin.com/K3ZvFQLR
16:27:10 <fax> old?
16:27:13 <geheimdienst> "Haskell: Making hard things easy and easy things an endofunctor"
16:27:25 <jeffwheeler> geheimdienst: I like it
16:27:41 <lowasser> bahahahahhahahaa
16:27:42 <krey> fax: yep, i.e. no monads
16:27:51 <lowasser> that's *so true*
16:28:42 <krey> fax: you can't prove b, but if the letter denote boolean variables then this proof decides whether it's always true or not
16:28:47 <ivanm> rryan: yeah, I'm having a similar problem here when trying to test building with ghc-core 0.5 (which I _know_ requires base-3 but with a dep of base < 10)
16:29:02 <rryan> ivanm : `strace -e trace=open cabal install strict-concurrency` shows it extracting stuff into /tmp/ but it deletes it afterward
16:29:12 <krey> fax: I got the logic side, but I can't do it in haskell
16:29:24 <fax> krey: i dont understand your algorithm :(
16:29:25 <mreh> haskell, doing high brow humour since 1987
16:29:32 <krey> fax: I could probably do it in some imperative language, which has exceptions
16:29:35 <fax> krey: if you can't prove b isn't it wrong?
16:29:53 <krey> fax: what's b?
16:30:01 <mreh> krey: why do you need an exception? for failure?
16:30:03 <fax> proving a -> b -> c -> d -> b
16:30:09 <lowasser> rryan: if you go into .cabal/packages/hackage.haskell.org/thispackage
16:30:12 <fax> means proving b in the context [a,b,c,d]
16:30:12 <krey> what is b?
16:30:13 <fax> no?
16:30:16 <lowasser> then you can untar it right there
16:30:19 <lowasser> build it right there
16:30:21 <krey> ah
16:30:24 <fax> variable
16:30:24 <krey> yeah ok
16:30:25 <lowasser> and then you get access to the guts of the build
16:30:34 <krey> so
16:30:57 <krey> the formula you gave me is true
16:30:59 <fax> now what about proving  X -> Y -> Z -> b,  where X Y and Z are complex terms, which do prove b -- but in a non obvious way,  how does your algorithm prove this?
16:31:26 <geheimdienst> Haskell: Not doing I/O since 1987
16:31:42 <krey> it removes the connectives (and, or, implies) and nots step by step
16:31:51 <ivanm> rryan: did I tell you to use --constraint or --configure?
16:32:03 <fax> oh so a hypothesis X /\ Y is turned into two, X, Y
16:32:06 <fax> I guess?
16:32:10 * ologNation is reading through buglist for System.Time
16:32:16 <rryan> ivanm : cabal install strict-concurrency --constraint "base==4.*"
16:32:20 <krey> fax: /\?
16:32:23 <fax> AND
16:32:28 <ivanm> OK, I gave you the right flag
16:32:28 <krey> ah
16:32:32 <krey> yep!
16:32:32 * ivanm was using --configure :s
16:32:36 <fax> I suppose OR splits into attempting two different proofs (as long as one works we are okay)
16:32:40 <fax> but what does IMPLIES do?
16:32:44 <ivanm> rryan: maybe try with an equals sign... --cosntraint="base == 4.*"
16:32:55 <kmc> Haskell: doing I/O since 1995
16:33:06 <krey> a -> b is equivalent to (not a) or b
16:33:11 <ologNation> under "BUGS" in System.Time, it suggests "add proper handling of microsecs", but this doc is from 2000.  I wonder if it's been taken care of.
16:33:16 <mreh> was there no IO in haskell?
16:33:21 <fax> krey, oh!!! this is classical logic then?
16:33:38 <kmc> i don't' know if the pre-monadic IO systems were standardized
16:33:38 <fax> krey, if it is not a or b this is much easier :)
16:33:39 <krey> fax: donno, maybe :)
16:33:40 <kmc> they sucked anyway
16:33:43 <rryan> ivanm: same error with --constraint="base == 4.*"
16:33:46 <fax> since we already covered not a or b
16:33:54 <kmc> Haskell 1.3 standardized monadic IO
16:34:00 <fax> well not a or b being equivalent to implication seems to be a consequence of P \/ ~P to me
16:34:02 <geheimdienst> mreh, i thought it's all so pure and stuff
16:34:05 <mreh> I was taught miranda for ages and never did anything useful with it
16:34:16 <mreh> i.e. any IO
16:34:18 <fax> or perhaps it is a consquence of  P = T \/ P = F
16:34:30 <fax> I wonder if these are the same...
16:34:32 <fax> anyway
16:34:33 <krey> fax: not sure I get what you're saying
16:34:35 <byorgey> fax: they are.
16:34:41 <byorgey> those are all logically equivalent.
16:34:41 <fax> sorry just thinking out loud
16:34:57 <byorgey> along with double negation elimination, and peirce's law
16:35:14 <rryan> still getting "Could not find module `Control.OldException':"
16:35:33 <mreh> i taught miranda once too, and didn't know monads, it was a perpetuating cycle of uselessness
16:35:38 <krey> fax: so yeah, it's classical logic
16:35:47 <fax> that's fine
16:35:50 <krey> fax: will that help me getting exceptions then?
16:35:59 <fax> no
16:36:12 <fax> by the way
16:36:14 <mreh> krey: why do you need the exception?
16:36:26 <fax> krey, you know the OR case where we split into two proof attempts
16:36:38 <mreh> it's rarely needed unless you're safeguarding user/system input
16:36:42 <fax> rather than 'exception' you can just "split" into 0 proof attempts
16:37:05 <krey> mreh: when I unfold the proof tree, and hit a sequent that is not true, I must throw an exception
16:37:06 <mreh> this sounds like an application of Maybe?
16:37:34 <mreh> that's not an exception, that's normal surely
16:37:38 <fax> krey, this defintiion of implication changes things
16:37:42 <c_wraith> I was thinking [], actually.  mzero for "stop this branch", and the ability to generate more "next stuff"
16:37:47 <fax> krey, we were collecting up hypothesis, then deaing with them...
16:37:52 <krey> fax: this is the only definition I know :)
16:38:06 <fax> krey, but now we really have to prove  not p \/ p,  (rather than p -> p)
16:38:18 <fax> krey, so how does that relate to the contexts/hypothesis thing?
16:38:32 <krey> fax ?
16:38:41 <fax> what question is the lone question mark
16:38:46 <Alpounet> damn
16:38:52 <mreh> the question that has no answer
16:38:54 <Alpounet> cabal install gitit fails
16:39:27 <krey> fax: when you have a sequent like p -> p
16:39:28 <rryan> Alpounet : what problem are you seeing? I'm trying to do the same thing and having problems.
16:39:36 <krey> then you reached a so called axiom
16:39:39 <fax> krey, but p -> p is just a notation for  not p or p  right?
16:39:52 <Alpounet> rryan, I've already worked around some problems by editing the cabal file and installing libs by hand
16:39:55 <fax> so how do you pattern match on shapes like  "not p or p"?
16:40:00 <Alpounet> but at the moment I have an error with happstack-data
16:40:05 <krey> fax I can give you my lecture notes on sequent calculus
16:40:20 <krey> fax but the point is, there always has to be a -> in the middle
16:40:27 <fax> hm
16:40:29 <krey> that's how the proof system works
16:40:30 <Alpounet> I'm gonna try to install gitit the arch way
16:40:50 <dons> Alpounet: you can download the binary .tar.gz i linked in the AUR page for gitit
16:40:52 <fax> and no other (->)'s ?
16:40:53 <dons> and install with pacman -U
16:41:02 <krey> yeah, sure, you can have other ->s
16:41:03 <dons> (add -d --force, and install haskell-filestore first)
16:41:17 <krey> but there's always one in the middle
16:41:33 <Alpounet> dons, ok, let's try that, thanks
16:41:46 <dons> assuming you're on 64 bit x86
16:41:51 <krey> fax: point is, I unfold the proof and if I find a single counterexample, the whole thing must stop
16:42:03 <krey> can you do this in haskell>
16:42:03 <krey> ?
16:42:13 <ivanm> dons: you have any idea for rryan's problem?
16:42:26 <Alpounet> dons, my arch is 32 bit :/
16:42:28 <ivanm> it seems that once it has configured the deps for a package once, cabal-install refuses to re-configure them
16:42:35 <ivanm> and keeps ignoring --constraint options :@
16:43:06 <krey> fax: also unfolding is monadic
16:43:39 <fax> you can use list monad
16:43:48 <krey> list?
16:43:55 <krey> why would I do that?
16:44:01 <mreh> krey: the list Monad
16:44:04 <rryan> well, first I had a QuickCheck dependency issue, and then I did `cabal install gitit --constraint='datetime==0.1'' which has now led me to this strict-concurrency issue.
16:44:16 <fax> @go replace failure with a list of sucessess
16:44:17 <lambdabot> Maybe you meant: google googleit do
16:44:21 <fax> that is why
16:44:30 <Alpounet> damn, happstack-data fails to install
16:44:45 <krey> fax: I don't get it, I am sorry
16:44:48 <ivanm> rryan: :s
16:44:55 <fax> krey, read 'replace failure with a list of sucessess'
16:45:06 <ivanm> rryan: only other thing I think of is that you "build" strict-concurrency by hand
16:45:10 <fax> you can find it online but I have to go
16:45:27 <krey> fax: ok, thanks for trying to help
16:45:41 <rryan> ivanm : ok I'll download the tar from hackage and give it a shot. thanks a lot for your help so far btw.
16:46:21 <Alpounet> rryan, we're having different issues, that kind of fun
16:47:09 <ivanm> i.e.: cabal unpack strict-concurrency; cd strict-concurrency-<version>; cabal configure --constraint="base > 3"; cabal build; cabal install
16:47:16 <ivanm> rryan: no need to download it by hand ;-)
16:49:16 <Alpounet> dons, how did you manage to build your binaries ?
16:49:46 <Alpounet> if I handle to build them for 32 bit, I can put them somewhere online... but gotta work the issues out first
16:50:48 <rryan> ivanm : :) ok -- well I did that and `cabal build' fails with the same message
16:50:59 <rryan> `Could not find module `Control.OldException':'
16:52:26 <ivanm> :s
16:52:33 <ivanm> rryan: I'm completely stumped then
16:53:06 <ivanm> rryan: well, give up and edit the strict-concurrency.cabal file since you have it there unpacked already ;-)
16:53:13 <ivanm> (make it base >= 4 && < 5 )
16:53:27 <rryan> ivanm : oi :) so this builds fine for you ? out of curiosity what version of ghc do you have and what version of haskell-platform?
16:54:01 <geheimdienst> okay IT WORKS :)
16:54:09 <geheimdienst> after many graphic threats to the compiler
16:54:13 <geheimdienst> thanks guys :)
16:54:15 <rryan> ivanm : ok .. well it compiled when I changed the cabal file
16:54:47 <ivanm> yeah, it forces the deps correctly
16:54:52 <Alpounet> damn
16:54:57 <ivanm> I have 6.12 with cabal-install 0.8 (no platform as yet)
16:54:57 <Alpounet> happstack-data won't build
16:57:28 <rryan> ivanm : ah ok. Hmm I think my install may be very messed up. `ghc-pkg check' prints out scores of broken packages
16:58:28 <ivanm> rryan: :/
17:01:07 <rryan> ivanm : oh actually nevermind `ghc-pkg check' works fine now
17:01:54 <ivanm> heh
17:03:24 * Alpounet gives up
17:03:43 <rryan> ivanm : awesome, gitit compiled fine now.. thanks a ton
17:04:20 <Alpounet> rryan, haven't you got some happstack-data relared issues ?
17:04:25 <Alpounet> related*
17:04:50 <ivanm> rryan: no worries
17:05:00 <rryan> Alpounet : Yea -- happstack-data  was complaining about strict-concurrency failing to install
17:05:26 <Alpounet> 'cause I'm getting errors and there doesn't seem to be a way to work them out
17:05:48 <ivanm> @ask dcoutts it seems that if I build something with cabal-install, get a build failure due to dependency ranges being too lax and then try to use --constraint to force a different dependency version, it doesn't seem to work; do you know if this is correct?
17:05:48 <lambdabot> Consider it noted.
17:08:03 <interferon> can i use quickcheck to test specific examples?
17:08:11 <interferon> ie length [1, 2, 3] == 3 rather than property-based tests
17:09:29 <ivanm> yes, I think
17:09:36 <ivanm> not sure why you would want to, but you can
17:11:00 <Igloo> You may want to check out HUnit instead
17:12:38 <Phyx-> evening, does anyone know is hsc2hs has a known bug with files with Windows file endings on linux? I've been trying to compile a file for ages now, and failed, converted to unix line endings and it worked
17:13:39 <geheimdienst> phyx-, dunno, but could the file have had some endings in win and some in unix ...?
17:15:18 <ivanm> Phyx-: weird...
17:15:39 <Phyx-> geheimdienst: no, it was all windows endings, it was generating almost identical code, except that the placement of the ");" were off
17:16:11 <geheimdienst> ... it was just a wild guess :)
17:16:30 <ivanm> Phyx-: sure you didn't somehow magically change the file encoding? :;
17:16:33 <ivanm> * :p
17:17:34 <Phyx-> ivanm: not that i know off, it was compiling fine on windows, but when testing my tool on linux i would get odd errors, and the errors would all point to empty lines
17:18:34 <Phyx-> ivanm: and i can reproduce it by converting the file to Windows line endings again
17:18:49 <ivanm> weird...
17:20:57 <Phyx-> ivanm: i can basically reproduce it with just 2 lines, get it to print out a syntax error
17:23:22 <ksf> can someone do me a favor and formally prove in a blog post that program design is undecidable?
17:23:42 * ivanm passes
17:24:39 <Phyx-> ivanm: http://phyx.pastebin.com/tPqD6YGi the only real difference is on line 13-14 and line 55
17:25:16 <ksf> ftp likes to do that line ending transformation stuff
17:25:34 <Phyx-> that, and it seems to be mixing in some \n in the fputs
17:25:36 <ksf> gave me a lot of headaches in the past. then, I switched to unix.
17:25:38 <ivanm> Phyx-: :o one extra newline gets put in? :s
17:26:10 * hackagebot th-kinds 0.0.1 - Automated kind inference in Template Haskell.  http://hackage.haskell.org/package/th-kinds-0.0.1 (LouisWasserman)
17:26:18 <Phyx-> ivanm: i'm assuming that would happen for every #let in the original file
17:26:54 <ivanm> *nod*
17:27:27 <ksf> there seems to be something fundamentally wrong with the minds that decided to do crlf. I can't imagine the confusion needed to decide that putting printer control characters in a file encoding would be a jolly good idea.
17:28:27 <c_wraith> of course it's a jolly good idea.  It means you can just send the file directly to the printer, no fancy "drivers" needed.
17:28:39 <c_wraith> Just write the bytes to the serial port
17:28:41 <ksf> hell no
17:28:59 <ksf> my printer back then didn't speak ascii.
17:29:02 <Phyx-> the odd thing is actually, that compiling the file in windows with windows file endings doesn't have the "\r\n" intermixed like when i run it on linux
17:29:03 <theorbtwo> ksf: Because at the time, non-printer display devices were a rarity?
17:29:05 <Phyx-> it's all \n
17:29:38 <theorbtwo> ...and file formats and text were different things?
17:29:53 <ksf> DOS came with printer consoles?
17:30:01 <geheimdienst> phyx-, in the lines about Tuples.h, there's 2 stray "\r"s without any \n
17:30:09 <geheimdienst> don't know if that's the problem ...
17:31:07 <Phyx-> geheimdienst: could be, don't know myself, but i've ran the file both on win and linux, using windows EOF the result is http://phyx.pastebin.com/As0VqppE
17:31:27 <Phyx-> it could indeed be the stray \r
17:31:45 <theorbtwo> ksf: ASCII, and CR LF line endings, far predates DOS.
17:32:45 <thawk> hey, quick dumb question, but how do you comment in haskell
17:32:47 <ksf> it may be ascii's fault for not having cr, lf and eol
17:33:10 <mauke> thawk: {- block -}, -- line
17:33:22 <thawk> thanks
17:33:26 <ksf> and blocks can be nested!
17:33:35 <mauke> not really
17:33:37 <ksf> but --> is not a comment
17:33:42 <ksf> it's an operator
17:33:42 <tensorpudding> there's also the special ones for haddock
17:33:52 <tensorpudding> --|
17:33:57 <thawk> haddock?
17:34:03 <ksf> you can also do -XCPP and the #if 0 thingie
17:34:08 <geheimdienst> thawk: it's somewhat like javadoc
17:34:12 <ivanm> thawk: haskell's documentation generator
17:34:12 <tensorpudding> haddock is the thing that generates haskell documentation
17:34:15 <theorbtwo> IIRC, it's technically {-whitespace and --whitespace.
17:34:24 <ivanm> tensorpudding: doesn't that need a space? -- | , -- ^ , etc.
17:34:27 <theorbtwo> If you don't have the whitespace there, it isn't really a comment.
17:34:33 <theorbtwo> I could well be wrong, though.
17:34:36 <tensorpudding> it's fulfills a similar role to docstrings, doxygen, etc.
17:34:39 <mauke> --comment
17:34:39 <ksf> it's --<not an operator symbol>
17:34:39 <kmc> i love how thoroughly we can answer the most superficial question
17:34:45 <jmcarthur> here's a question i've often thought about but never asked: how do you guys test the properties that rewrite rules depend on? do you compile without rewrite rules?
17:34:50 <ivanm> theorbtwo: it has to be a non-symbol
17:34:51 <tensorpudding> ivanm: I don't think so?
17:34:57 <Phyx-> does anyone know where to report hsc2hs bugs?
17:35:00 <tensorpudding> maybe
17:35:24 <jmcarthur> another way might be to have two versions of a function, one that's exported and has rewrite rules, and one that has no rules and is not exported
17:35:24 <tensorpudding> you are right, it's -- |
17:36:14 <jmcarthur> the latter solution would also allow one to test that rewrite rules don't change semantics
17:36:17 <ivanm> Phyx-: to the maintainer: http://hackage.haskell.org/package/hsc2hs
17:36:19 <jmcarthur> but it would be a hassle
17:36:26 <jmcarthur> any alternative?
17:36:30 <ivanm> tensorpudding: yeah, because --| is a valid operator
17:36:32 <ksf> not using rewrite rules
17:36:41 <ksf> aka the stream-fusion way
17:37:06 <jmcarthur> stream-fusion the package? that's how it runs its tests?
17:37:17 <Phyx-> ivanm: thanks
17:37:17 <ksf> no it's not using rewrite rules, at all
17:37:28 <ksf> (or just one of them for all the stuff it does)
17:38:01 <ksf> it relies on constructor elimination, case rewriting etc.
17:38:35 <ksf> I'd recommed to read the paper, it's all described in there
17:38:48 <jmcarthur> i've read it
17:39:00 <jmcarthur> but that doesn't really eliminate the issue
17:39:49 <jmcarthur> or does the paper say something along the lines of stream-fusion being a reasonable susbstitute for all other kinds of rewrite rules? that would be fascinating if so
17:39:51 <ksf> can you put the rules into another package that imports the functions?
17:40:13 <jmcarthur> s/stream-fusion/stream fusion/
17:40:17 <ksf> it says something along the lines of rewrite rules being a bad idea if you want to fuse
17:40:45 * jmcarthur looks up the paper again
17:41:00 <ksf> you could also extract your code with th and leave out the rewrite rules
17:42:32 <danderson> quizz: how would you go about rounding a number up to the nearest power of 2 elegantly?
17:43:27 <ivanm> danderson: I would guess by doing something like: 2 ^ (ceil $ logBase 2 x)
17:43:38 <Veinor> pretty much that.
17:44:20 <danderson> sounds good, thanks.
17:44:58 <Phyx-> ivanm, geheimdienst found the issue btw, it's that due to the \r\n in the files, and it expecting \n it inserts a newline after the #define , which breaks because the define then unexpectedly ends, and then in #include statements it unexpectedly quotes the closing " (i guess in an attempt to remove the \n) so foo.h becomes "foo.h\r\"
17:45:56 <ivanm> Phyx-: weird :s
17:46:35 <Phyx-> yeah
17:49:26 * hackagebot haddock 2.7.2 - A documentation-generation tool for Haskell libraries  http://hackage.haskell.org/package/haddock-2.7.2 (DavidWaern)
17:50:57 <jmcarthur> ksf: a search for "rewrite" in the paper doesn't reveal any occurrences of saying anything like rewrite rules being bad for fusion
17:51:18 <jmcarthur> and i just skimmed the whole thing looking for related things that might not have had "rewrite" in them
17:52:08 <roconnor_> danderson: Integer or Int?
17:52:21 <jmcarthur> i guess i could use a separate package
17:52:26 <danderson> roconnor_: Word8 actually
17:52:36 <jmcarthur> err, module
17:53:02 <jmcarthur> screw it. i'll just build test code with rewrite rules disabled and see how badly it performs
17:56:06 <roconnor_> let roundUp n = let n0 = pred n in succ $ foldl' (.|.) 0 [n0 `shiftR` i | i <-[0..bitSize n0]] in map roundUp [0..
17:56:10 <roconnor_> > let roundUp n = let n0 = pred n in succ $ foldl' (.|.) 0 [n0 `shiftR` i | i <-[0..bitSize n0]] in map roundUp [0..]
17:56:12 <lambdabot>   Ambiguous type variable `a' in the constraints:
17:56:12 <lambdabot>    `Data.Bits.Bits a'
17:56:12 <lambdabot>      ...
17:56:18 <roconnor_> > let roundUp n = let n0 = pred n in succ $ foldl' (.|.) 0 [n0 `shiftR` i | i <-[0..bitSize n0]] in map roundUp [0..] ::[Word8]
17:56:19 <lambdabot>   [* Exception: Enum.pred{Word8}: tried to take `pred' of minBound
17:56:25 <roconnor_> > let roundUp n = let n0 = pred n in succ $ foldl' (.|.) 0 [n0 `shiftR` i | i <-[0..bitSize n0]] in map roundUp [1..] ::[Word8]
17:56:26 <lambdabot>   [1,2,4,4,8,8,8,8,16,16,16,16,16,16,16,16,32,32,32,32,32,32,32,32,32,32,32,3...
17:56:35 <roconnor_> danderson: doesn't work for 0 :(
17:57:14 <danderson> heh, nice all the same.
17:57:18 <roconnor_> but it does have ( .|. ) in it which kinda looks like a dimpled bum.
17:57:23 <roconnor_> so it is okay
17:57:58 <danderson> I prefer what a friend casually refers to as the boobies operator: (.).(.)
17:58:06 <Veinor> @unpl (.) . (.)
17:58:06 <lambdabot> (\ i b c f -> i (b c f))
17:58:35 <roconnor_> > let roundUp n = let n0 = n - 1 in (+1) $ foldl' (.|.) 0 [n0 `shiftR` i | i <-[0..bitSize n0]] in map roundUp [0..] ::[Word8]
17:58:36 <lambdabot>   [0,1,2,4,4,8,8,8,8,16,16,16,16,16,16,16,16,32,32,32,32,32,32,32,32,32,32,32...
17:58:42 <roconnor_> pft
17:58:46 <roconnor_> that just gives the wrong anser
17:58:51 <roconnor_> answer
17:58:56 <Veinor> what? it gives the right answer
17:59:03 <roconnor_> is 0 a power of 2?
17:59:11 <dmwit> > let roundUp 0 = 42; roundUp n = 56 in roundUp 0 -- have you forgotten the power of pattern matching!
17:59:13 <lambdabot>   42
17:59:20 * Veinor rolls his eyes
18:00:43 <roconnor_> danderson: I guess foldl1' (.|.) would be slightly faster, but wouldn't work on 0 bit numbers.
18:00:46 <ivanm> is someone killing weeds in here or something that they're spraying RoundUp everywhere? :p
18:01:12 <Phyx-> hrm... today must not be my lucky day.... somehow calling a haskell function from FFI which is supposed to be byvalue "somehow" modifies the variable i passed to it. randomly my loop counter changes values (well not random, after exactly 4 calls to the haskell function)
18:01:13 <Phyx-> anyone have anything similiar?
18:01:44 <roconnor_> danderson: oh, you can parallelize it!!!  map/reduce FTW!!
18:01:57 <roconnor_> each thread can compute one call to (.|.)
18:02:06 <[swift]> i'm having a little trouble composing do blocks
18:02:12 <danderson> another golfing question: I'm reasonably sure that there's a more elegant/concise way of saying: (\x y -> x `shiftL` 8 + y)
18:02:13 <[swift]> what's wrong with my syntax here: elements = do emptyString <|> many1 do { spacing ; idToken <|> stringToken }
18:02:29 <dmwit> danderson: That looks fine to me.
18:02:31 <danderson> (used by a fold)
18:02:52 <Phyx-> http://phyx.pastebin.com/K2XDGaHG <-- haskell code, C code and test, the value of "x" is randomly changed by the call to the haskell function genNumberSec
18:02:53 <mauke> danderson: x*2^8+y
18:04:05 <dmwit> [swift]: I don't think do-blocks are the kind of expression that prefix functions can be applied to.
18:04:31 <danderson> dmwit: it's fine, yeah. But since discovering that `uncurry (==)` completely replaced my (\(x,y) -> x == y) in another piece of code, I wonder what else I'm missing.
18:04:37 <dmwit> [swift]: But what's the exact error?
18:04:48 <[swift]> dmwit: parse error on the "do"
18:05:01 <dmwit> [swift]: The second one, I assume?
18:05:05 <[swift]> dmwit: right
18:05:15 <roconnor_> danderson: if you put a specialize pragma for roundUp on Word8, ghc might even unroll the loop completely.
18:05:17 <ivanm> [swift]: many1 $ do ...
18:05:23 <dmwit> [swift]: You can use many1 (do { ... }) or many1 (spacing >> idToken <|> strinkToken).
18:05:27 <dmwit> ivanm: careful
18:05:32 <ivanm> actually, that might play up with the <|>
18:05:32 <dmwit> ivanm: won't work here
18:05:34 <roconnor_> does ghc do loop unrolling?
18:05:36 <ivanm> dmwit: yeah, just noticed that
18:05:49 <roconnor_> someone in the pipeline is liable to do that
18:05:54 <[swift]> dmwit: thanks! i knew there was some way to do it
18:05:55 <ivanm> roconnor_: don't think so...
18:06:13 <ivanm> roconnor: since IIRC dons has manually unrolled some loops in some benchmarks
18:06:20 <roconnor> pft
18:06:23 <roconnor> what about c--
18:06:26 <roconnor> llvm
18:06:29 <roconnor> someone?
18:06:46 <mauke> Phyx-: where's your FFI declaration?
18:07:16 <ivanm> roconnor: they're waiting for _you_ to do it! :p
18:07:28 <roconnor> :O
18:08:20 <[swift]> ok, a quick followup. the do in parentheses worked, but this expression doesn't work due to precedence problems: many1 (spacing >> idToken <|> stringToken)
18:08:40 <dmwit> Oh, rats.
18:08:47 <[swift]> do i just need to add parentheses, or is there a nice shortcut like "$" that one can use here?
18:08:50 <dmwit> many1 (spacing >> (idToken <|> stringToken)), then
18:08:53 <ivanm> spacing >> (idToken <|> stringToken) ?
18:09:07 <dmwit> There's no (nice) shortcut for this case.
18:09:08 <benmachine> >> is already lower than <|> isn't it?
18:09:09 <ivanm> [swift]: you're out of luck
18:09:16 <[swift]> haha i just love $ so much, i want to use it everywhere, but it doesn't work here =)
18:09:31 <dmwit> benmachine: both infix[rl] 1
18:09:41 <[swift]> seems in general mixing binary operators with $ doesn't do what i for some reason imagine it should do
18:09:56 <benmachine> oh, Text.Parsec.<|> is infixr 1 but Control.Applicative.<|> is infixl 3
18:10:51 <byorgey> [swift]: well, $ is just a normal binary operator itself.
18:10:55 <byorgey> it isn't magic syntax
18:11:10 <[swift]> byorgey: yeah, i know why it doesn't work, but i wish there was a way to make it work =)
18:11:19 <byorgey> yes, I understand =)
18:11:44 <kacper__> is in c++ any data structure like a map but without ordering?
18:12:01 <mauke> why without ordering, and how is that a haskell question?
18:12:20 <ivanm> mauke: I'm still trying to work out what kacper__ is asking ;-)
18:12:30 <rventuri> This may be a silly question, but I am a noob to haskell, and wxHaskell
18:12:39 <tensorpudding> @type if
18:12:40 <lambdabot> parse error (possibly incorrect indentation)
18:12:41 <ivanm> byorgey: ($) isn't a binary operator...
18:12:47 <mauke> ivanm: yes, it is
18:12:55 <rventuri> On windows, how can I keep my compiled wxHaskell GUI from also opening a command prompt?
18:13:06 <ezyang> :t ($)
18:13:06 <tensorpudding> if is special, but I don't see why should be that way
18:13:07 <lambdabot> forall a b. (a -> b) -> a -> b
18:13:12 <ivanm> mauke: binary operators take two values from one set of values and return another value from that set
18:13:15 <tensorpudding> err, why it*
18:13:17 <ezyang> "it just happens that b tends to be a function..."
18:13:20 <mauke> ivanm: no
18:13:27 <ivanm> "More precisely, a binary operation on a set S is a ternary relation that maps elements of the Cartesian product S Ã— S to S"
18:13:40 <mauke> ivanm: this is not #math
18:13:52 <geheimdienst> kacper__, the way i understand it, the point about a map is that it gives you a value if you hand it a key. if the keys happen to be ordered, that's more like an implementation detail
18:14:10 <mauke> ivanm: a binary operator is an operator that takes two arguments
18:14:15 <mauke> or operands
18:14:38 * ezyang <3 cartesian product 
18:15:47 <Phyx-> mauke: it's foreign export stdcall "genNumberSec" genNumberSecA :: CLLong -> CInt
18:16:09 <mauke> Phyx-: can you give me something compilable?
18:16:21 <Phyx-> sure, one sec
18:18:15 <rventuri> I just wrote my first haskell GUI program using wxHaskell. The program is working wonderfully except that when I execute it, it loads a command prompt window as well. Is there anyway to keep command prompt from loading with the program? I tried closing it but it also closes my application if I don't let it stay open. I have searched google and wxHaskell at length without any luck. :(
18:18:28 <kacper__> geheimdienst, map is ok to store my data but order is not necessary and it slows my algorithm
18:25:45 <Trinitron> Can I define a function in Haskell that takes two arguments like this: "Func x y = x + y"?
18:25:57 <Trinitron> I've only ever has single argument fuctions.
18:25:57 <mauke> no
18:25:59 <Trinitron> had*
18:26:05 <mauke> functions must start with a lowercase letter
18:26:05 <tommd> Trinitron: You should probably read some more tutorials.
18:26:08 <ivanm> Trinitron: can't use a capital letter
18:26:16 <ivanm> (to start a function name)
18:26:28 <tommd> > let func x y = x + y in func 42 24
18:26:29 <lambdabot>   66
18:26:44 <mail> doesn't haskell do some magic and apply the function twice with each variable sperately
18:26:53 <Trinitron> Currying, yes.
18:27:15 <Phyx-> mauke: http://phyx.pastebin.com/zq9uPkVK that should compile, took a bit to combine the generated code and the library code into one
18:27:19 <mail> need to understand that properly
18:28:04 <ddarius> There's nothing to understand.  There is no magic.
18:28:13 <Veinor> > fix show
18:28:14 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
18:28:15 <Trinitron> Err how do I index a list?
18:28:16 <ddarius> You can do the same thing in C#
18:28:28 <mauke> Trinitron: !!
18:28:41 <Trinitron> Danke.
18:30:08 <Veinor> I kind of want to write !!' that has special semantics for negative numbers
18:31:18 <mauke> Phyx-: that just segfaults
18:32:36 <Phyx-> mauke: odd, i'm running the code on windows and the first few calls work fine, but then no segfault, x is just changed
18:34:19 <mauke> Phyx-: your C code is missing hs_init/hs_exit
18:34:33 <Trinitron> What is the inequality operator, != doesn't work.
18:34:39 <Trinitron> ?
18:34:39 <sshc> Trinitron: /=
18:34:47 <Trinitron> Arigato.
18:35:05 <Phyx-> mauke: i prove a custom lib entry point to initialize and exit, so it's contained inside the lib itself
18:35:18 <Phyx-> provide*
18:35:28 <mauke> where?
18:35:37 <mauke> it's not in the code you pasted
18:36:12 <ivanm> Trinitron: are you doing a "round the world thank-you" or something?
18:36:22 <Phyx-> no, it's not part of the Haskell file, let me make a new paste, i just do ghc -c dllmain.c and then include the .o file later when compiling with -shared
18:36:32 <Trinitron> Quite possibly, ivanm.
18:36:44 <Trinitron> Your powers of deduction astound me ;)
18:36:54 <ivanm> \o/
18:37:34 <Phyx-> mauke: http://phyx.pastebin.com/GqR8CbkN
18:37:54 <mauke> ew, windows
18:37:59 <mauke> can't compile that
18:38:14 <Phyx-> well, I have a linux version too
18:38:21 <Phyx-> one sec
18:39:21 <Phyx-> mauke: http://phyx.pastebin.com/fQq7Wp6Z that should be the equivalent
18:40:04 <Trinitron> !! returns a list with one element, right?
18:40:07 <mauke> what is <Rts.h>?
18:40:10 <mauke> Trinitron: no
18:40:21 <mauke> wait, reading ghc docs
18:40:29 <Trinitron> Occurs check: cannot construct the infinite type: t = [t]   Expected type: [t]   Inferred type: t
18:40:32 <geheimdienst> :t !!
18:40:33 <lambdabot> parse error on input `!!'
18:40:39 <geheimdienst> :t (!!)
18:40:40 <lambdabot> forall a. [a] -> Int -> a
18:40:53 <Phyx-> mauke: it's include in the GHC Includes, just contains the GHC C types like HsBool and the hs_init call etc
18:41:17 <Trinitron> Is !! prefix?
18:41:24 <ivanm> infix
18:41:31 <geheimdienst> > [1,2,3] !! 0
18:41:32 <lambdabot>   1
18:41:38 <geheimdienst> > [1,2,3] !! 2
18:41:38 <lambdabot>   3
18:41:46 <Trinitron> func (number/(primes !! index)) index
18:41:54 <Trinitron> rpimes is a list.
18:41:57 <Trinitron> Primes*
18:42:04 <Trinitron> the rest are integers
18:42:12 <Trinitron> it doesn't like it, at all.
18:42:14 <ivanm> Trinitron: then you need some fromIntegral's thrown in there as well
18:42:21 <ivanm> or else use `div` rather than /
18:42:27 <ivanm> @type fromIntegral
18:42:28 <lambdabot> forall a b. (Integral a, Num b) => a -> b
18:42:39 <mauke> ivanm: that won't solve the infinite type problem
18:42:52 <ivanm> what infinite type problem?
18:43:15 <mauke> ...
18:43:30 <geheimdienst> here is something i don't understand: when i say let f = g, why is f not really the same as g? wtf?
18:43:32 <byorgey> Trinitron: what is the type of func?
18:43:32 <geheimdienst> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24002#a24002
18:43:39 <Trinitron> Inferred.
18:43:48 <ivanm> huh?
18:43:50 <Trinitron>  func number index =
18:44:09 <geheimdienst> i thought the 2 main functions should do the same, but one compiles and one doesnt
18:44:38 <byorgey> geheimdienst: ah, this is the Dreaded Monomorphism Restriction
18:44:46 <Trinitron> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24003#a24003
18:45:05 <ivanm> Trinitron: what type do you _want_ it to be?
18:45:08 <byorgey> geheimdienst: I recommend turning it off; at the top of your file put  {-# LANGUAGE NoMonomorphismRestruction #-}
18:45:22 <Trinitron> int -> int -> int
18:45:22 <Cale> geheimdienst: {-# LANGUAGE NoMonomorphismRestriction #-}  or add an explicit parameter to the definition of f
18:45:24 <ivanm> Trinitron: also, guards are much nicer than nested if statements
18:45:55 <byorgey> er, *Restriction, not Restruction
18:45:56 <geheimdienst> woah it works. thanks guys
18:46:00 <Cale> geheimdienst: There's a stupid rule in Haskell 98 which says that pattern bindings (as opposed to function bindings) can't be typeclass polymorphic unless they have an explicit type signature
18:46:18 <ivanm> so you want at the end:  func (round $ fromIntegral number / (fromIntegral $ primes !! index)) index
18:46:39 <geheimdienst> cale, and i take it "let f = g" is a pattern binding, not a function binding?
18:46:42 <Cale> yeah
18:46:46 <Trinitron> I got to go, thanks for the help.
18:46:57 <Cale> even though f is actually a function
18:47:14 <geheimdienst> i see. how bizarre
18:47:31 <geheimdienst> but surely this is getting fixed in haskell 2010 or something, right?
18:47:33 <mauke> Phyx-: works here (after fixing the obvious errors)
18:47:56 <ivanm> geheimdienst: not 10, hopefully 11
18:48:02 <Cale> Haskell 2010 doesn't change anything much
18:48:34 <ivanm> it was mainly to get the ball rolling
18:48:41 <ivanm> how long have they had the haskell' project going?
18:48:49 <Phyx-> mauke: then it might be a windows bug in the Rts
18:49:14 <Phyx-> mauke: and which error btw?
18:49:44 <mauke> Phyx-: inconsistent types for Test_load, missing ; in line 9
18:49:44 <Phyx-> I haven't tested the tool on linux yet, in the process of doing so now
18:50:09 <Phyx-> oh right, that one was produced using an old file
18:50:13 <Eelis> in a .cabal, is there a way to specify that a certain flag should not be backtracked on? i don't want the flag to be automatically set to its non-default value when its dependencies cannot be met
18:51:02 <Phyx-> mauke: so the loop produces all the values?
18:51:11 <ivanm> Eelis: what do you mean by "backtracked on"?
18:51:24 <ivanm> Eelis: you can provide default values for flags...
18:51:26 <mauke> Phyx-: http://p3rl.org/scribble/scribble.plp/8677SHIV
18:51:42 <Cale> Actually, I shouldn't say that when I actually disagree with some of the changes that Haskell 2010 made
18:51:48 <Eelis> ivanm: it's described here: http://www.haskell.org/cabal/release/cabal-latest/doc/users-guide/authors.html#configurations (search for "Cabal does a complete backtracking search to find a satisfiable package configuration")
18:51:54 <byorgey> Cale: which ones, out of curiosity?
18:52:08 <Cale> The if/then/else thing
18:52:19 <benmachine> doandifthenelse?
18:52:24 <Phyx-> mauke: yup, that's correct, Ok, cool thanks! :) Now I know it's the windows RTS
18:53:26 <ivanm> Eelis: *shrug* ask dcoutts? :p
18:53:39 <Cale> yeah
18:53:41 <Eelis> dcolish: ^ :)
18:53:44 <Eelis> whoops
18:53:48 <Eelis> dcoutts: ^
18:53:53 <Cale> It's the opposite of the change I would have made
18:53:54 <ivanm> preflex: seen dcoutts
18:53:54 <preflex>  dcoutts was last seen on #haskell 1 day, 19 hours, 2 minutes and 45 seconds ago, saying: byorgey: nope
18:54:05 <ivanm> Eelis: yeah, I've been bitten by doing that a few times as well ;-)
18:54:14 <Cale> I think the layout of if/then/else should be *more* restrictive than Haskell 98.
18:54:15 <Eelis> :)
18:54:19 <dmwit> You might want to ?ask him or (dare I say it?) check out the cabal mailing list...
18:54:39 <dmwit> When he's here, he's very helpful, but he's not always here. =)
18:54:52 <Cale> That rule just helps beginners learn the wrong way to indent things.
18:55:03 <Eelis> dmwit: alright, i'll keep an eye out
18:55:45 <ivanm> dmwit: any idea if he ended up finishing his thesis off?
18:55:55 <Phyx-> hmm the Maintainer email on http://hackage.haskell.org/package/hsc2hs is no longer valid, bounced, anyone know where else you can report an hsc2hs bug?
18:55:56 <ivanm> Cale: agreed
18:56:07 * dmwit shakes his head
18:56:53 <ivanm> Phyx-: the LICENSE file talks about GHC directly
18:57:00 <ivanm> so maybe #ghc or the ghc users mailing list?
18:57:38 <Phyx-> ivanm: ok, cool thanks :)
18:58:56 <ivanm> I was about to suggest dcoutts again, but he does c2hs, not hsc2hs
18:59:43 <Phyx-> well, according to hackage the last upload was in 2006, so I wonder if it's even been updated
19:01:26 <ivanm> Phyx-: looks like the upload was unofficial
19:01:37 <ivanm> it's pretty much shipped as part of ghc now AFAICT
19:01:52 <Phyx-> yeah, i'll mail the mailing list
19:04:22 <geheimdienst> by the way, what's this with that bazillion "module prelude is deprecated" warnings that i'm getting?
19:04:30 <geheimdienst> (last question before bed for me)
19:05:17 <Cale> geheimdienst: Er, what?
19:05:21 <ivanm> geheimdienst: base-3 is deprecated
19:05:37 <ivanm> so 6.12 spits out warnings if it's compiling a package using base-3
19:06:05 <aavogt> that way people will either port the code to use base-4, or start ignoring ghc's warnings
19:07:30 <geheimdienst> ivanm, so i would need to change my .cabal file to get rid of the "depends: base < 4" ?
19:08:03 <ickabob> is it foolish to attempt to fold over other structures that are not lists? possibly like a tree?
19:08:13 <ivanm> geheimdienst: well, it won't necessarily build immediately with that
19:08:35 <ivanm> ickabob: folding over a tree requires you to state in which order (i.e. traversal) you're doing
19:08:37 <benmachine> geheimdienst: if there is no constraint at all, cabal guesses you meant base 3 and then whines about it
19:08:37 <geheimdienst> that's a little unfortunate, because i'm messing around in xmonad-contrib, which does not depend on base-3
19:08:48 <geheimdienst> i guess it depends on xmonad, which depends on base-3
19:08:56 <geheimdienst> that's a little silly ...
19:09:02 <ivanm> benmachine: actually, it appears cabal-install (cabal-install /= cabal!) 0.8.* no longer defaults to base-3
19:09:17 <benmachine> ivanm: o rly?
19:09:23 * benmachine experiments
19:09:31 <EvanCarroll> any gene guys in here? I have a totally off topic question pertaining to a passage I'm reading in The Greatest Show on Earth, I think it is 101 type stuff...
19:09:41 <ivanm> geheimdienst: xmonad still uses base-3 to provide compatability with ubuntu LTS users who are stuck with GHC 6.8 (which has base-3), but they're starting to port it to base-4
19:09:45 <aavogt> genetic programming
19:09:48 <ivanm> benmachine: it did for me before... :s
19:09:52 <byorgey> geheimdienst: what version of xmonad?
19:09:58 <aavogt> ivanm: they have finished porting it
19:10:04 <ivanm> aavogt: you have? :o
19:10:05 <benmachine> ivanm: I'm definitely getting base-3 defaulting
19:10:06 <ivanm> \o/
19:10:07 <byorgey> IIRC the latest darcs version uses extensible-exceptions so it no longer depends on base-3
19:10:18 <ivanm> benmachine: interesting... maybe that's only if you don't have an upper bound
19:10:25 <geheimdienst> byorgey, don't know exactly when my last darcs pull was :)
19:10:35 <byorgey> geheimdienst: ah, well, do another one =)
19:10:40 <aavogt> ivanm: yeah, it's been done for a couple months I think
19:10:51 <ivanm> benmachine: I was testing it on a package which has base >= 3 && < 5 which I _know_ won't build with base-4; yet cabal-install 0.8 kept using base-4 with it
19:10:54 <benmachine> ivanm: yeah, if you specify base < 5 it'll use 4
19:11:01 <ivanm> benmachine: *nod*
19:11:22 <benmachine> I think the rule came in place when the switch from base 3 to base 4 broke a lot of packages that didn't specify versions
19:11:31 <ivanm> benmachine: it's constraints seem stuck, however; even using --constraint="base <4" or "base == 3.*" keeps using base-4 (and failing) :s
19:11:35 <ivanm> benmachine: yup
19:11:47 <benmachine> oh, that's odd
19:11:52 <aavogt> in short  base > 2   is read as   base > 2 && < 4
19:12:01 <ivanm> aavogt: only in cabal-install
19:12:08 <aavogt> yes
19:12:15 <aavogt> that's confusing sometimes
19:12:26 <ivanm> yeah
19:12:43 * ivanm makes sure he tests his code with both base-3 and base-4 by editing the cabal file to force one of them
19:13:03 <benmachine> you could add a flag
19:13:16 <ivanm> *shrug* why bother?
19:13:27 <ivanm> I only do it before I release it
19:13:51 <ivanm> and there shouldn't be a problem since AFAIK the only way they differ is by the new exception framework, and I use extensible exceptions
19:14:02 <ivanm> oh, and syb was removed to its own library, but I don't use syb
19:14:08 <EvanCarroll> Dawkins says, human/dog cell, should have the same relationship score as chimpanzee/dog,... And, human/cat should have the same score a chimpanzee/cat. He says this because they are "all connected to [...] via their common ancestor"
19:14:17 <EvanCarroll> I have no idea how to make heads or tails of this paragraph
19:14:50 <EvanCarroll> I would imagine a human/cat would have a totally different relationship than say a dog/cat.
19:15:07 <geheimdienst> any word on human/lolcat?
19:20:05 <EvanCarroll> I think his point is that human/foo has the same relationship to human/bar but I can't make sense of this in either genes/cells etc.
19:22:28 <EvanCarroll> it seems he is missing qualification
19:27:52 <geheimdienst> ok i'm off. good night everyone
19:28:11 <ozamosi> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24004#a24004 Could anyone please look at this error and point out what I'm doing wrong? I'm thinking I need some kind of lifting, but I can't figure out what would work.
19:30:50 <ivanm> ozamosi: read the value first? *shrug*
19:32:12 <benmachine> ozamosi: don't you need to unwrap the newtype before you can runReaderT it?
19:32:16 <byorgey> ozamosi: I think you need to make a runAppT which strips off the newtype wrapper and calls runReaderT
19:33:05 <ozamosi> Ah, that works. Thanks.
19:36:47 <dino-> What is happening with cabal-install when you use the --enable-library-profiling switch? Is it modifying the data that came from the .cabal file to add ghc-prof-options or something?
19:37:32 <ivanm> dino-: it just builds the librar twice, once with profiling and one without
19:37:53 <dino-> ivanm: So this can't be achieved easily without cabal-install?
19:37:55 <ivanm> i.e. it adds -prof to the GHC command line switches
19:38:01 <ivanm> dino-: sure it can
19:38:25 <ivanm> dino-: this just lets you have profiling versions of the libraries you install
19:38:31 <dino-> Ok, so would have to hack the .cabal file otherwise
19:38:47 * ivanm isn't sure what dino- is wanting/asking
19:39:18 <dino-> I'm trying to build profiling versions of some libs using the Arch build system so they can be install/uninstallable packages on that distro.
19:39:21 <ivanm> you can do it with runhaskell Setup.hs as well
19:39:32 <dino-> The Arch system invokes Setup configure ... etc without cabal-install.
19:39:36 <ivanm> dino-: it's a Cabal option that cabal-install makes available
19:40:33 <ivanm> dino: runhaskell Setup configure -p
19:40:41 <ivanm> (or --enable-library-profiling if you prefer)
19:40:55 <ivanm> for executables, use --enable-executable-profiling (though you're less likely to want that)
19:41:05 <dino-> Ah, the same switch that goes for cabal-install or in the .cabal/config file
19:41:44 <dino-> Which would have been apparent to me if I ever did runhaskell Setup.hs configure -h  :/
19:41:54 <ivanm> dino-: how do you think got it? :p
19:42:06 <ivanm> dino-: in the .cabal file, you specify _how_ the profiling libraries should be built
19:42:11 <ivanm> you shouldn't force them to be built
19:42:23 <dino-> Ok, that makes sense
19:42:40 <trainpic> is there any discussion of porting GHC to x86_64?
19:43:06 <dino-> ivanm: Thank you
19:43:11 <ivanm> trainpic: ummm.... there's been x86_64 support for _years_
19:43:19 <trainpic> ok...
19:43:20 <ivanm> dino-: no worries
19:43:29 <trainpic> so is this an os-specific thing then?
19:43:32 <trainpic> (mac os x)
19:43:33 <ivanm> yes
19:43:37 <trainpic> ok
19:43:47 <ivanm> trainpic: oh, yeah, that's because there's some compatability problem or something
19:44:00 <trainpic> any idea what?
19:44:01 <ivanm> apparently a new version of the haskell platform comes out in the next week or so, so it might have something
19:44:06 <tensorpudding> I think it's only with Snow Leopard.
19:44:09 <trainpic> um
19:44:09 <ivanm> not really; check the OSX page on the wiki
19:44:22 <tensorpudding> and not with older versions of OSX
19:44:31 <trainpic> the problem with Snow Leopard was that GHC only builds 32 bit on os x
19:44:41 <trainpic> and Snow Leopard defaults to 64 bit for everything
19:44:47 <tensorpudding> Hmm, so as a different problem.
19:45:06 <nus> trainpic, it does not "default to 64 bit for everything"
19:45:11 <trainpic> ok
19:45:12 <trainpic> ...
19:45:30 <trainpic> that was my (apparently imperfect) understanding
19:45:51 <trainpic> what is preventing 64 bit ghc on os x?
19:46:18 <ivanm> trainpic: IIUC, the main problem is people who are knowledgeable enough about GHC build process + OSX architecture and willing to do the work
19:46:28 <trainpic> hm
19:46:53 <tensorpudding> Kinda odd, that, considering how many people use OSX
19:46:56 <ivanm> the IHG is still looking for someone to do dynamic linking on OSX IIRC
19:47:09 <ivanm> tensorpudding: I just think they're noisier than windows and linux users :p
19:47:18 <trainpic> hm
19:47:24 <trainpic> well I just got my first mac
19:47:26 <tensorpudding> There are more Mac users than Linux users.
19:47:33 <trainpic> and so I'm not really familiar with it
19:47:41 <tensorpudding> Maybe not more Mac GHC users than Linux GHC users though.
19:47:44 <ivanm> tensorpudding: globally? or using Haskell?
19:47:52 <ivanm> and do you include institutions as "linux users"
19:47:54 <trainpic> but if there's a good tutorial on the build process I'd love to take a look
19:47:57 <ivanm> tensorpudding: exactly
19:48:05 <ivanm> trainpic: maybe ask in #ghc?
19:48:18 <trainpic> ok
19:48:23 <trainpic> thanks
19:48:31 <tensorpudding> I don't know globally.
19:48:50 <tensorpudding> I can only speak for the US.
19:49:02 <tensorpudding> but I'm pretty sure Mac is more popular than Linux here.
19:49:22 <ivanm> tensorpudding: do you include people using linux at home?
19:49:28 <ivanm> or institutions as well?
19:49:44 <ivanm> (since I'm sure there's more linux servers than mac servers :p )
19:50:07 * jeffwheeler is surprised to learn that my school's servers randomly have 6.12.1 on them. I was very pleasantly surprised. I wonder what the admin uses it for.
19:50:18 <tensorpudding> How many servers use GHC though?
19:50:24 <ivanm> jeffwheeler: part of some default package set?
19:50:34 <ivanm> tensorpudding: probably not as many ;-)
19:50:35 <jeffwheeler> ivanm: that recent a version?
19:50:41 <ivanm> jeffwheeler: true
19:50:54 <ivanm> jeffwheeler: which school?
19:50:56 <dino-> jeffwheeler: shell scripting!
19:51:07 <ivanm> I wonder if it's because they use something like pandoc or gitit...
19:51:14 <jeffwheeler> ivanm: University of Illinois at Urbana-Champaign. These are the engineering machines.
19:51:14 <tensorpudding> I was thinking more of individuals
19:51:24 <ivanm> jeffwheeler: do they teach haskell?
19:51:35 <ivanm> tensorpudding: in that case, yes, there's probably more mac users than linux users
19:51:36 <jeffwheeler> ivanm: probably in /some/ course, but I've never seen it.
19:52:30 <danblick> I am trying to implement something like the reactor pattern in Haskell, and it's got me thinking about what the right way to replace objects would be
19:53:46 <Cale> What does the reactor pattern have to do with objects?
19:54:07 <ivanm> what is the reactor pattern?
19:54:15 <danblick> Suppose I have 3 objects, A B and C, with references between the pairs A and B and B and C.  I'm wondering, is there a clean way to translate this using maybe the State monad? (data StateB = StateB StateA StateC); type B = State StateB ...?
19:54:17 <Cale> You handle requests in one thread, and fork off more threads to handle them concurrently.
19:54:19 <ivanm> does it have to do with control rods?
19:54:28 <ivanm> Cale: ahhhh
19:54:35 <ivanm> nuclear reactors sound cooler... :p
19:54:51 <Cale> ivanm: To be honest, I had to look it up.
19:55:04 <ivanm> Cale: sounds like something STM would be good at
19:55:14 <danblick> ivanm: it's hard to summarize entirely; basically the reactor pattern is used for demultiplexing inputs and serializing them.
19:55:34 <ivanm> ... which sounds completely different from what Cale said
19:55:38 <Cale> You might use STM if you need communication of some sort between the service handlers.
19:55:53 <ivanm> or else I completely misunderstood what Cale said ;-)
19:56:20 <Cale> Er, hmm
19:56:26 <Cale> Perhaps I misread it
19:56:33 <danblick> ivanm: this works - http://en.wikipedia.org/wiki/Reactor_pattern - there is a good description in the pattern oriented software architecture books
19:57:03 <Cale> Okay, so it's really about sequentialising requests from multiple threads?
19:57:20 <ivanm> sounds like it
19:57:34 <ivanm> "demultiplexer" sounds weird though...
19:57:45 <kmc> ugh, design patterns
19:57:54 <nainaide> I am confuse on orElse in http://www.haskell.org/haskellwiki/HXT#Filter_combinators , why orElse take 3 parameter but not 2. Could anyone help me? Thanks
19:58:26 <kmc> nainaide, type XmlFilter = XmlTree -> [XmlTree]
19:58:40 <ivanm> nainaide: is XmlFilter a type alias for a function?
19:58:44 <kmc> expand out that synonym in the type of orElse
19:58:45 <ivanm> kmc: yeah, that's what I thought
19:58:46 <danblick> kmc, you need them in less expressive languages :)
19:58:48 <kmc> and you'll see that it takes three args
19:58:55 <nus> danblick, do you want the mux loop implemented in one or several (OS) threads?
19:59:04 <ivanm> nainaide: as such, it returns a function, which is listed explicitly rather than implicitly
19:59:08 <nainaide> kmc, yes XmlFilter a type of func.
19:59:11 <kmc> danblick, there are patterns in Haskell too, but we mostly agree that they're a *bad* thing
19:59:13 <danblick> nus: 1
19:59:20 <ivanm> (since the value of orElse depends upon the result of what is possibly the returned value)
19:59:25 <kmc> that is, you should endeavor to replace each pattern with a library or if necessary a language extension
19:59:42 <kmc> i guess there are reactor pattern libraries for all these other languages too
19:59:48 <nus> danblick, i.e. there're no FFI callbacks supposed to come in?
20:00:20 <danblick> nus: I'm using epoll on Linux, it's like select/poll
20:00:33 <kmc> yes this sounds very much like select()
20:00:41 <arw> wtf? since when is a simple loop with select a pattern, and why does one need a library for that?
20:00:50 <Cale> danblick: Simple answer: before creating the threads that will send the requests, create an (empty) MVar, say v, and pass takeMVar v to the thread which will handle the requests, and putMVar v to the threads which will send the requests
20:01:07 <arw> next on this frequency: the "if"-pattern
20:01:15 <Cale> danblick: This is supposing you want requests to block until they can be handled
20:01:16 <kmc> abstract conditional factory pattern
20:01:19 <kmc> how is this superior to creating one thread per resource?
20:01:28 <kmc> i think it's superior because threads are a royal pain in most languages
20:01:28 <Cale> danblick: If you don't want them to block, use a Chan in place of an MVar
20:01:29 <ozamosi> arw: I blame java. But otoh, I always blame java.
20:01:29 <danblick> arw: it's not just that, it involves registering event handlers.
20:02:12 <Cale> danblick: Are you familiar with MVar and Chan?
20:02:27 <danblick> Cale: No, thanks for the suggestion I will read up on those
20:02:43 <nainaide> kmc, ivanm, I still dont understand:   orElse :: XmlFilter -> XmlFilter -> XmlFilter , in  orElse f g t  , f g t all referr to XmlFilter?
20:02:46 <Cale> MVar or Chan, and forkIO are *probably* the answer.
20:02:48 <kmc> nainaide, no
20:02:51 <kmc> nainaide, expand the synonym
20:03:00 <nainaide> kmc, exanpad
20:03:01 <Cale> You can get fancier if those don't do, but for most simple things they do.
20:03:13 <kmc> nainaide, XmlFilter is a type synonym declared with "type"
20:03:14 <danblick> Cale: um, hang on, i am looking for a solution that is inside a single thread
20:03:18 <kmc> danblick, they're some of the basic building blocks for concurrent programming in Haskell
20:03:29 <Cale> danblick: Why?
20:03:31 <ivanm> nainaide: no
20:03:38 <kmc> danblick, it's a common pattern in other languages to jump through ridiculous hoops to avoid threads
20:03:52 <Cale> "The reactor design pattern is a concurrent programming pattern"
20:04:01 <kmc> and it's a common pattern for people to come in here asking how to translate their favorite hoops into Haskell
20:04:02 <ivanm> nainaide: f and g do, but XmlFilter is a function and the t is the argument to that function
20:04:09 <ivanm> (that is returned)
20:04:15 <Cale> I can't imagine wanting to do what is described here without concurrency.
20:04:19 <Cale> What would it even mean?
20:04:23 <nainaide> ivanm, got it! thanks!
20:04:28 <ivanm> no worries
20:04:50 <nainaide> haskell is so interesting! hah
20:05:11 <danblick> kmc: :(
20:05:21 <kmc> danblick, why do you want to avoid multiple threads
20:05:48 <Cale> danblick: Can you even describe the reactor design pattern for me without mentioning threads?
20:06:02 <danblick> Cale: yes
20:06:24 <Cale> I have a really hard time imagining what this would mean independent of performing things concurrently.
20:07:26 <arw> you have a special call like 'select' which tells you what request (file descriptor to read from in the case of select) can be processed without blocking
20:08:10 <arw> you call 'select' repeatedly and perform some action depending on which request you were able to process. if the request is complete, start over.
20:08:37 <arw> or did i miss something there?
20:09:53 <Cale> Well, that's one half of it, but there must be concurrent processes going on somewhere to tell the next select what to produce.
20:10:19 <kmc> yeah, but not threads within the same process
20:10:24 <danblick> kmc: (not sure how to answer your question; i am partially trying to avoid IO in the program logic here; my question was about how to model the objects / state; i am also trying to avoid the fact that OS threads don't scale. i'm not sure my answer here is adequate.)
20:10:41 <Cale> danblick: Haskell threads are not OS threads.
20:10:46 <kmc> GHC threads are not OS threads
20:10:50 <arw> in the case of select, thats the job of the OS kernel. it schedules the process when select would return an answer and returns the appropriate fd in select.
20:10:55 <kmc> GHC's runtime will map them onto a configurable number of OS threads
20:10:59 <Cale> danblick: You can make hundreds of thousands of them with no problem/
20:11:02 <danblick> i know
20:11:13 <kmc> avoiding IO in the program logic seems totally orthogonal
20:11:17 <kmc> the reactor pattern is a pattern for IO
20:11:26 <kmc> if you want a pure computational pattern you should probably ditch it
20:11:57 <kmc> it's worth noting that Haskell supports parallel computation without threads
20:12:09 <Cale> Yeah, in a pure setting, this is meaningless. Just decide what it is that you want to compute and describe that computation. Waiting for a resource doesn't make sense when there's no time.
20:12:12 <ivanm> kmc: it does?
20:12:20 <Cale> ivanm: absolutely
20:12:24 <kmc> yes, par and all that good stuff
20:12:25 <Cale> ivanm: par
20:12:28 <kmc> implemented with threads of course
20:12:31 <ivanm> I thought par used OS threads
20:12:37 <kmc> but the user isn't responsible for knowing or caring about that
20:12:40 <ivanm> oh
20:12:45 <Cale> ivanm: yeah, but they're not threads from the Haskell perspective
20:12:47 <kmc> you don't have to spawn workers and synchronize t hem
20:12:48 <ivanm> I thought you meant that it didn't use threads at all...
20:13:04 <ivanm> *phew*
20:13:21 <Cale> They're just expressions which hopefully get evaluated before you need them.
20:13:26 <kmc> yes it's hard to run a program with zero threads ;)
20:13:49 <Cale> and since the result of doing that evaluation is independent of the order in which the evaluation occurs, you don't need to imagine the threads at all
20:14:09 <kmc> though you do once you care about optimizing for performance
20:14:14 <Cale> yeah
20:14:22 <kmc> which is sort of the whole point of using par
20:14:36 <kmc> but the hope is that naive guesses on top of a high level library will provide a good start
20:14:54 <Cale> Ideally, you use par to annotate chunks of work which are "large enough".
20:15:18 <kmc> it's nice to simply replace "map" with "parMap rnf" and get ~60% of a second core for free
20:15:23 <Cale> You don't necessarily have to care how many real OS threads there are, but that might affect what's considered the right size amount of work
20:15:28 <kmc> it's tricker to get 100% of that second core
20:16:05 <Cale> Sometimes parMap rnf should work, depending on what the computation is and how big the tasks are that you're mapping over the list.
20:16:18 <Cale> (to fill up your available processors)
20:16:18 <ivanm> @type parMap
20:16:19 <lambdabot> forall b a. Strategy b -> (a -> b) -> [a] -> [b]
20:16:42 <ivanm> is GHC able to automatically detect how many CPUs/cores are available and use them all yet?
20:16:50 <kmc> think so
20:16:51 <ivanm> or even let you set how many to use within the program?
20:17:11 <kmc> iirc 6.12 rts supports «+RTS -N» without a numerical arg
20:17:16 <kmc> that i don't think is supported
20:17:18 <kmc> would be nice
20:17:30 <kmc> currently there's no easy way to bake in RTS parameters
20:17:36 <kmc> you can do it with a little C file that gets linked in
20:17:44 <ivanm> *nod*
20:18:01 <Cale> :t GHC.Conc.numCapabilities
20:18:02 <lambdabot> Int
20:18:08 <Cale> > GHC.Conc.numCapabilities
20:18:09 <lambdabot>   Not in scope: `GHC.Conc.numCapabilities'
20:18:13 <Cale> ;)
20:18:19 <Cale> numCapabilities :: Int	Source
20:18:19 <Cale> the value passed to the +RTS -N flag. This is the number of Haskell threads that can run truly simultaneously at any given time, and is typically set to the number of physical CPU cores on the machine.
20:19:00 <kmc> including SMT?
20:19:00 <ivanm> how did you get italics into IRC? :o
20:19:12 <tensorpudding> why would you want italic in irc?
20:19:22 <Cale> Italics?
20:19:29 <ivanm> tensorpudding: I see italics in Cale's message  "numCapabilities :: IntSource"
20:19:35 <ivanm> (the "Source" is in italics)
20:19:36 <tensorpudding> Italics.
20:19:36 <Cale> weird, I don't
20:19:47 <ivanm> ... interesting ...
20:19:50 <ivanm> must be my client
20:20:00 <Cale> But that was a link from Firefox that I pasted into XChat
20:20:06 <ivanm> hmmm...
20:21:13 <Cale> But GHC.Conc isn't something you'd normally want to rely on
20:21:35 <ivanm> *nod*
20:21:49 <ivanm> GHC.* isn't something you'd normally want to rely on ;-)
20:23:32 <ickabob> how do i use ghci to test a incomplete packages module?
20:24:07 <ivanm> incomplete in what sense?
20:24:11 <Cale> ghci Foo.hs ?
20:24:29 <ivanm> if you have functions whose definitions aren't complete, use undefined
20:24:43 <ivanm> @type let foo x y z = undefined in foo
20:24:44 <lambdabot> forall t t1 t2 a. t -> t1 -> t2 -> a
20:25:09 <ickabob> ivanm: thats exactly what i was looking for thanks, sorry for the loose question
20:25:14 <ivanm> no worries
20:26:19 <ivanm> oh, that reminds me: if people start coming in here or on the mailing lists wanting help with how to do various image-based manipulations, it's an assignment
20:27:26 <danblick> i wonder what it would be like to (implement a compiler for / program in) a language based on the pi calculus or another process calculus
20:28:07 <nus> hmm, is there a string/buffer based module load around?
20:28:09 <kmc> CSP has been used as the basis for a variety of practical languages / libraries
20:28:11 <danblick> (i've looked at pict but not tried it)
20:28:37 <kmc> including a haskell library, CHP
20:28:43 <ivanm> nus: in what sense?
20:28:48 <nus> yi/leksah/anything?
20:28:52 <twink> I've not even heard of pict.
20:29:22 <ivanm> nus: as in a display widget for a text editor or something?
20:29:51 <nus> ivanm, load a module not from a file, but some memory serialization.
20:30:16 <ivanm> hmmmm....
20:30:18 <danblick> twink: this is the one - i think it looks interesting but the source code has not been updated in years - http://www.cis.upenn.edu/~bcpierce/papers/pict/Html/Pict.html
20:30:26 <ivanm> nus: as in a haskell module?
20:30:30 <nus> yep
20:30:41 <ivanm> dunno
20:30:54 <ivanm> do you mean for xmonad/yi-style configuration and restarting?
20:31:33 <nus> i mean: "ghci load this string, it's a module textual representation"
20:31:53 <ivanm> oh...
20:31:59 <ivanm> *shrug* look at their sources! :p
20:32:08 <ivanm> nus: but I'm not sure if ghci can do that
20:32:14 <danblick> btw, thanks for your help everyone, i will look into mvar, chan and par
20:32:16 <nus> ivanm, ghci can't
20:32:16 <ivanm> AFAIK ghci loads modules from file...
20:32:20 <ivanm> aha
20:32:44 <ivanm> nus: I would assume that yi and leksah are just doing passing ":load path/to/file.hs" to ghci
20:33:05 <nus> sigh, so nobody bothered...
20:33:21 <ivanm> why would they?
20:33:37 <ivanm> and this is of course assuming that it's possible without hacking on ghc itself
20:33:55 <twink> JoCaml I've heard of.
20:33:59 <nus> uhh, it's not. you'd need to rewrap the GHC monad, or something
20:35:37 <danblick> twink: looks interesting
20:35:47 <dankna> hmm
20:36:05 <dankna> so I'm working on dynamic-plugins, adding features that try to ensure type-safety by poking through the installed .hi files
20:36:26 <dankna> I thought I was going to implement the function symbolType :: (String, String, String) -> Maybe TypeRep
20:36:46 <dankna> but I guess I can't, because there's no guarantee that the type in question even derives Typeable, and even if it does I'm not clear that there's any way to call it
20:36:58 <dankna> just thinking out loud now and trying to come up with alternate ideas
20:37:57 <dankna> I could certainly return a string representation of the type and have the user check that
20:38:51 * hackagebot adaptive-tuple 0.2.0 - Self-optimizing tuple types  http://hackage.haskell.org/package/adaptive-tuple-0.2.0 (JohnLato)
20:39:04 <monochrom> Usually we are happy with: getSymbol :: (Typeable a) => blahblah -> a
20:39:19 <dankna> hmm
20:39:33 <dankna> that might be doable, I'm not certain
20:39:42 <monochrom> With (Typeable a), getSymbol has access to TypeRep and can check.
20:39:54 <monochrom> And of course you can do Maybe a instead of just a.
20:40:01 <dankna> yeah, certainly
20:40:37 <monochrom> dons's plugin paper lists more choices.
20:40:47 <dankna> adding the context there makes sense, absolutely, but I'm still not really sure how I go about constructing a TypeRep given a string, or if it's even possible
20:41:14 <dankna> I mean, a TyCon is internally a string, the nature of which depends on the type
20:41:23 <dankna> which implies that I would need to have already loaded some code from the module to check it
20:41:31 <dankna> I've read that paper, but perhaps I should give it another look
20:41:40 <dankna> (indeed, it was the inspiration for my reinvention of his library :) )
20:43:46 <dankna> he says:
20:43:49 <monochrom> I forgot the exact choices, but one of them is very safe, as in, honest oversights are caught.
20:43:55 <dankna> "... fromDynamic expects to be applied to a value of type Dynamic. Unfortunately, this leads to a weakness in dynload: neither the operating system?s nor GHC?s dynamic loader can guar- antee that a symbol obtained from a separately compiled and loaded plugin has type Dynamic. If a plugin provides the correct symbol name, but is bound to a non-Dynamic value, fromDynamic will simply crash."
20:44:01 <dankna> yeah, hm
20:44:10 <dankna> I'm trying to go beyond that.  I've read his code and it doesn't grovel the .hi files.
20:44:56 <dankna> by poking inside the .his it should be possible to overcome this restriction and catch things that aren't the correct type, flat-out.
20:44:58 <dmwit> nus: Have you looked at Hint?
20:45:02 <dmwit> ?hackage hint
20:45:02 <lambdabot> http://hackage.haskell.org/package/hint
20:45:30 <dmwit> nus: Or, if that's not powerful enough for you, the GHC API?
20:46:17 <dankna> hmm
20:46:52 <dankna> of course none of this will provide safety in the event of malicious code; but that was never the intent.
20:47:01 <dankna> if you're loading a plugin into your address space that implies a certain amount of trust.
20:48:57 <ddarius> PCC
20:49:02 <dankna> I guess one thing I could do is provide loadDynamic :: ... -> Dynamic, which checks the .hi files to ensure that the thing it's loading really is a base:Data.Dynamic.Dynamic
20:49:10 <dankna> yeah, I'm aware of PCC and very impressed by it
20:49:28 <nus> dmwit, no, haven't looked @ Hint (one more package to check :-)...
20:49:40 <dankna> but it's orthogonal to my goal, which is simply to provide a more practical way to design Haskell programs that use plugins. :)
20:52:12 * ManateeLazyCat pasted "Code" at http://paste2.org/get/719204
20:52:12 <lambdabot> ManateeLazyCat: You have 1 new message. '/msg lambdabot @messages' to read it.
20:52:13 <ManateeLazyCat> How to use StateT modify above code to remove *temporary* variable? Thanks!
20:53:02 <ickabob> whats the difference between the types Int and Integer?
20:53:21 <monochrom> > 2^100 :: Integer
20:53:21 <aavogt> > maxBound :: Int
20:53:22 <lambdabot>   1267650600228229401496703205376
20:53:22 <lambdabot>   9223372036854775807
20:53:23 <tensorpudding> Int is a machine Int.
20:53:30 <tensorpudding> It is bounded.
20:53:32 <tensorpudding> Integer is not.
20:53:44 <ickabob> hmmmm
20:53:48 <ickabob> thank you
20:53:49 <kmc> using Int over Integer is usually premature optimization; unfortunately the standard library makes this choice in a number of places
20:53:49 <tensorpudding> Integer corresponds to BigNum in other languages
20:54:05 <Zao> Int guarantees a signed 2^29 bits or something.
20:54:29 <dankna> I think you mean 29 bits, not 2^29 :D
20:54:33 <ickabob> yeah i have a type inference exception between Int and Integer :(
20:54:34 <tensorpudding> If you want signed and unsigned Int's of various sizes, there are a decent number available.
20:54:46 <tensorpudding> Int isn't always the same size on all architectures though
20:54:46 <kmc> ickabob, you can use fromIntegral to convert
20:54:48 <kmc> :t fromIntegral
20:54:50 <lambdabot> forall a b. (Integral a, Num b) => a -> b
20:55:02 <ManateeLazyCat> roconnor: Can you help me convert http://paste2.org/get/719204 code to StateT, i failed many times, and don't know how to handle `a` in `StateT s m a`
20:55:09 <tensorpudding> they're in Data.Word
20:55:28 <roconnor> ManateeLazyCat: which temporary variables?
20:56:05 <ManateeLazyCat> roconnor: http://paste2.org/get/719204 windowNodeList
20:56:10 <ickabob> kmc: thank you for that function that saves me :)
20:56:12 <ManateeLazyCat> roconnor: Type is WindowNodeList.
20:56:49 <ManateeLazyCat> roconnor: I try to use runStateT like your code, but failed.
20:57:47 <ManateeLazyCat> roconnor: I'm confusion the `StateT s m a` and when i got `a`? I know `s` for update state in StateT, `m` for integrate with other moand. but no idea how to use `a`.
20:57:56 <tensorpudding> oh, and Data.Int too
20:58:05 <roconnor> ManateeLazyCat: same way a is used in IO a
20:58:06 <aavogt> ManateeLazyCat: a is the value in the monad
20:58:24 <aavogt> :k StateT
20:58:25 <lambdabot> * -> (* -> *) -> * -> *
20:58:31 <aavogt> :k IO
20:58:32 <lambdabot> * -> *
20:58:59 <aavogt> :k IO ()
20:58:59 <kmc> @unmtl StateT s m a
20:58:59 <lambdabot> s -> m (a, s)
20:59:00 <lambdabot> *
20:59:20 <roconnor> ManateeLazyCat: I don't see anything worthwhile changing in that code.
20:59:23 <kmc> @unmtl StateT s1 (StateT s2 m) a
20:59:23 <lambdabot> s1 -> s2 -> m (a, s1, s2)
20:59:35 <roconnor> ManateeLazyCat: nodeList is never modified
21:00:00 <ManateeLazyCat> roconnor: Oh, sorry paste wrong code.
21:00:20 * ManateeLazyCat pasted "Code" at http://paste2.org/get/719209
21:00:22 <ManateeLazyCat> roconnor: Is above.
21:00:25 <ManateeLazyCat> roconnor: Sorry.
21:01:20 <ManateeLazyCat> roconnor: I got `nodeList` from `windowNodeList`, then got `newNodeList` from `nodeList`.
21:01:29 <aavogt> ManateeLazyCat:     pattern <- return $ ...    can be written as    let pattern = ...
21:01:51 <kmc> can and should ;)
21:02:23 <roconnor> ManateeLazyCat: you can do let (id, nodeList) = case vId of ... (removing the return statements).
21:02:24 <ManateeLazyCat> roconnor: If i use runStateT wrap function body. How to handle return value of function?
21:02:31 <aavogt> also, it might be nicer to write windowNode as applicative
21:02:59 <aavogt>    windowNode id <$> windowNodePanedNew direction
21:03:01 <ManateeLazyCat> roconnor: Yes,
21:03:01 <roconnor> ManateeLazyCat: let me try
21:03:10 <ManateeLazyCat> roconnor: Thanks.
21:03:24 <aavogt> <*> newIORef .. <*> .. <*> pure direction
21:04:27 <aavogt> that way you don't need to distinguish between the iorefs and the values they contain
21:04:47 <roconnor> @type runStateT
21:04:48 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
21:06:19 <ManateeLazyCat> @type <$>
21:06:20 <lambdabot> parse error on input `<$>'
21:06:39 <ivanm> @type (<$>)
21:06:40 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
21:06:42 <ivanm> ManateeLazyCat: ^^
21:06:48 <ManateeLazyCat> ivanm: Thanks.
21:06:59 <ivanm> @src (<$>)
21:06:59 <lambdabot> f <$> a = fmap f a
21:07:10 <ivanm> with the mnemonic of it being like $
21:07:21 <ivanm> @type (<*>)
21:07:22 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
21:07:37 <ivanm> @type ap
21:07:38 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
21:08:02 <aavogt> um, <*> is as close (in the type) to $ as <$> is
21:08:41 <aavogt> it should be that more angle brackets indicate a type inside a functor on that side or something
21:08:47 <ivanm> aavogt: that's the description usually given to me ;-)
21:09:08 <aavogt> @type ($>)
21:09:09 <lambdabot> Not in scope: `$>'
21:09:13 <aavogt> @type (<$)
21:09:14 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
21:09:23 <roconnor> ManateeLazyCat: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24005#a24005
21:09:26 <ManateeLazyCat> aavogt: don't need to distinguish between the iorefs and the values they contain? I can't understand.
21:09:28 <roconnor> kinda does it, but nto really
21:09:34 <roconnor> not really
21:09:39 <ManateeLazyCat> roconnor: Thanks, i look it.
21:09:49 <aavogt> ManateeLazyCat: I mean how you don't have to name the intermediate IORef
21:10:16 <ManateeLazyCat> aavogt: For clean.
21:10:34 <ManateeLazyCat> aavogt: I don't want write everything in *one* line sometimes.
21:12:28 <roconnor> ManateeLazyCat: I kinda think it was fine as it was
21:12:37 <roconnor> at least as far as the state is concerned
21:12:48 <roconnor> you only "update" it at one point and then immediately return it
21:12:50 <aavogt> ManateeLazyCat: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24005#a24006
21:12:58 <roconnor> it is almost the definition of a good function
21:13:24 <aavogt> I don't mean that it should be done in one line, but that naming things you use in one place is more confusing sometimes
21:16:14 <ManateeLazyCat>     Couldn't match expected type `IO Paned'
21:16:15 <ManateeLazyCat>            against inferred type `StateT WindowNodeList m Paned'
21:16:15 <ManateeLazyCat>     In a stmt of a 'do' expression:
21:16:15 <ManateeLazyCat>         paned <- windowNodePanedNew direction
21:16:17 <ManateeLazyCat>  
21:16:36 <ManateeLazyCat> roconnor: I need change `windowNodePanedNew` something?
21:16:45 <kmc> please don't paste that many lines here
21:16:52 <aavogt> it needs more lift
21:17:12 <ManateeLazyCat> aavogt: How?
21:17:16 <aavogt> which will add more verbosity than you save with StateT
21:17:32 <aavogt>   lift $   windowNodeConnectToParent windowNode (nodeList, container)
21:17:55 <ManateeLazyCat> aavogt: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24005#a24006 have different with my version?
21:18:01 * hackagebot tupleinstances 0.0.1 - Functor, Applicative and Monad for n-ary tuples.  http://hackage.haskell.org/package/tupleinstances-0.0.1 (DiegoEcheverri)
21:18:58 <aavogt> ManateeLazyCat: like this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24005#a24007
21:19:56 <ManateeLazyCat> aavogt: Sorry, emacs w3m let me access *old* url
21:21:03 <ManateeLazyCat> aavogt: That's cool. I try it.
21:22:25 <ManateeLazyCat> aavogt: Yes, your're right, i got clear logic.
21:22:58 <ManateeLazyCat> aavogt: Just haven't know have <$> and <*> . :)
21:23:58 <aavogt> well they aren't complicated. They can get awkward if the function that collects up the values needs a different parameter order than the side-effects you want
21:24:17 <aavogt> but here it doesn't matter at all which ioref gets initialized first
21:24:51 <ManateeLazyCat> aavogt: Good tips.
21:24:57 <monochrom> Oh bother, people use emacs w3m too? Now I have to test all my webpages on it too.
21:25:10 <ivanm> heh
21:25:19 <SamB_XP> monochrom: no, you don't!
21:25:29 <SamB_XP> just links, ie6, and mozilla!
21:25:42 <SamB_XP> (and guess which is hardest to please?)
21:25:57 <ivanm> ie6?
21:25:57 * ManateeLazyCat pasted "Clearer code." at http://paste2.org/get/719232
21:26:12 <ivanm> SamB_XP: by "mozilla", you mean the old-school one that's now called seamonkey?
21:26:14 <ManateeLazyCat> http://paste2.org/get/719232 i got clear logic, cool.
21:26:32 <SamB_XP> ivanm: no, it's just that I call firefox that half the time
21:26:43 <ivanm> ahhh
21:26:53 <SamB_XP> and I thought seamonkey was just Navigator
21:27:07 <thoughtpolice> woot
21:27:18 <ManateeLazyCat> roconnor: I still can use nodeList in it, if nodeList haven't change?
21:27:25 * thoughtpolice got his tiny server running with attoparsec-iteratee finally working
21:27:30 <ivanm> seamonkey is their all-in-one suite
21:27:34 <thoughtpolice> must say, applicative parser combinators = win
21:27:35 <ivanm> even though it's unofficial
21:27:37 <roconnor> ManateeLazyCat: nodeList will always refer to the inital value
21:27:51 <roconnor> ManateeLazyCat: but like I said, I thought your code was fine without using stateT
21:28:45 <ManateeLazyCat> roconnor: I have another confusion, my function return `IO (WindowNode, WindowNodeList)`, after use runStateT, why just retutn `windowNode`?
21:28:46 <monochrom> oh w00t attoparsec-iteratee sounds like the best of all worlds!
21:29:07 <ManateeLazyCat> roconnor: runStateT will return final value?
21:29:13 <ivanm> monochrom: as in efficient, low-level parsing library that's also lazy?
21:29:18 <monochrom> "combine the most beautiful nose, the most beautiful eyes, the most beautiful cheeks..."
21:29:31 <roconnor> ManateeLazyCat: ya
21:29:34 <roconnor> @type runStateT
21:29:36 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
21:29:47 <ManateeLazyCat> roconnor: What's point of `a`?
21:29:57 <roconnor> a is the return value
21:30:08 <monochrom> don't forget suspendible-resumable
21:30:18 <ManateeLazyCat> roconnor: In State Mond, use `s` and `m`, just use `a` when need return ?
21:30:24 <ivanm> is there an execStateT?
21:30:28 <ivanm> @hoogle execStateT
21:30:28 <lambdabot> Control.Monad.State.Lazy execStateT :: Monad m => StateT s m a -> s -> m s
21:30:28 <lambdabot> Control.Monad.State.Strict execStateT :: Monad m => StateT s m a -> s -> m s
21:30:31 <roconnor> ManateeLazyCat: all monads have a return value
21:30:33 <ivanm> ManateeLazyCat: ^^
21:30:51 <NEEDMOAR> Linking Setup ...
21:31:01 <NEEDMOAR> Why does always take ages and high cpu load?
21:31:08 <ivanm> to spite you
21:31:14 <NEEDMOAR> Ages like... 10minutes and counting for Haskell platform.
21:31:26 <SamB_XP> NEEDMOAR: does it also swap tons?
21:31:32 <ivanm> NEEDMOAR: it's taking all those little object files (including those from all the libraries used) into one big executable (for applications)
21:31:32 <NEEDMOAR> Indeed, I had to suspend the process to be able to switch to this terminal.
21:31:35 <NEEDMOAR> SamB_XP: yes.
21:31:51 <dmwit> Buy more RAM, thank us later.
21:31:59 <dmwit> Also: why are you building the Haskell platform?
21:32:02 <ivanm> of course, this would depend on what exactly your'e compiling, your HW specs, which OS you're using, etc.
21:32:03 <roconnor> ManateeLazyCat: runStateT take a "(StateT s m) a" and returns a "m (s,a)"
21:32:03 <SamB_XP> well, if you upgrade ld, it might work better ?
21:32:16 <roconnor> in your case
21:32:18 <SamB_XP> I heard they made a change to the algorithm
21:32:22 <roconnor> ManateeLazyCat: runStateT take a "(StateT s IO) a" and returns a "IO (s,a)"
21:32:24 <dmwit> If you're on any of the most popular OS's, there should be builds already, that's the whole point of the platform.
21:32:29 <NEEDMOAR> It'd take ages linking ld :-p
21:32:33 * ivanm wonders if that "gold" linker would work with GHC
21:32:50 <ivanm> dmwit: I thought the whole point of the platform was to specify blessed libraries...
21:32:56 <ivanm> (i.e. recommended libraries)
21:33:04 <dmwit> ivanm: Yes, and to make them available to the masses.
21:33:07 <roconnor> ManateeLazyCat: as ivanm points out there is also evalStateT and execStateT which will only return either the output or the final state only
21:33:23 <dmwit> ivanm: i.e. without requiring them to understand the Haskell toolchain
21:34:34 <roconnor> dmwit: the point of the HP is to entrench imperfectly designed libries so they can never be changed in the same way the Prelude can't be changed.
21:34:56 <SamB_XP> roconnor: exactly!
21:35:21 <ManateeLazyCat> roconnor: I need use `lift` wrap `IO Monad` in `runStateT`, right?
21:35:37 <NEEDMOAR> Bah, I'll buy more ram :-(
21:35:44 <roconnor> ManateeLazyCat: you need lift to convert an IO a into a StateT s IO a
21:35:48 <roconnor> ManateeLazyCat: yes
21:36:11 <dmwit> NEEDMOAR: What system are you on?
21:36:38 <NEEDMOAR> dmwit: Ubuntu 8.10, 512MB of RAM.
21:37:16 <ivanm> NEEDMOAR: *shudder*
21:37:23 <ivanm> (to both)
21:37:33 <dmwit> NEEDMOAR: Ubuntu has packages for it, surely.
21:37:43 <ManateeLazyCat> roconnor: And i found another advantage, if i use State Monad, i can change code sequence anytime, if i use *temporary* variable, it's hard to modified.
21:37:52 <roconnor> yes
21:38:05 <ManateeLazyCat> roconnor: Cool.
21:38:21 <NEEDMOAR> dmwit: I just wanted to try Haskell platform.
21:38:48 <NEEDMOAR> My GHC was working fine until today.
21:39:21 <ManateeLazyCat> I will use StateT always even it just *one* temporary variable, easier to add new state code and maintain.
21:40:22 <ManateeLazyCat> aavogt: Your <$> <*> tips make my code beautiful. :)
21:40:25 <dmwit> Huh, a bit of googling does *not* turn up an Ubuntu package for the platform.
21:40:31 * dmwit is amazed
21:41:01 <ivanm> dmwit: *cough* debian packages *cough*
21:41:07 <ivanm> @where platform
21:41:08 <lambdabot> http://hackage.haskell.org/platform/
21:41:11 <ivanm> ^^ link there
21:42:52 <ManateeLazyCat> @type (<$>)
21:42:54 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
21:43:03 <ManateeLazyCat> @type (<*>)
21:43:04 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
21:43:32 <Veinor> what's an example of when you would need a function of type () -> a for some a?
21:43:51 <Trinitron> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24008#a24008 Halp.
21:43:58 <ManateeLazyCat> I found i don't need change current function signature if use runStateT in function.
21:44:07 <Veinor> I think you mean halp, plz. :]
21:44:13 <Veinor> gimme a sec, lemme take a look
21:44:14 <Trinitron> I'm using guards.
21:44:16 <ManateeLazyCat> But perhaps need add some `lift`. :)
21:44:21 <Trinitron> Halp, pl0x.
21:44:37 * Trinitron waits for ban for leetspeak
21:45:14 <dmwit> Trinitron: did you mean
21:45:22 <dmwit> mod number (primes !! index) /= 0
21:45:23 <dmwit> ?
21:45:43 <ivanm> weren't we helping you with that before Trinitron?
21:45:47 <dmwit> (and similarly in the other places)
21:45:54 <ivanm> at least you're using guards now...
21:46:08 <Trinitron> =/ binds higher than !!?
21:46:14 <ivanm> number `mod` primes !! index /= -
21:46:20 <ivanm> s/-/0/
21:46:22 <dmwit> No, function application binds tighter than (almost) everything.
21:46:30 <dmwit> it parses as
21:46:35 <dmwit> (mod number primes) !! index
21:46:39 <ivanm> > 2 `mod` [3,4,5] !! 1 == 0
21:46:40 <lambdabot>   False
21:46:53 <Trinitron> Ah, that always kicks me in the butt.
21:47:03 <Trinitron> I have to put a sticky on my computer about that rule.
21:47:08 <ivanm> use `mod`: it's cleaner to read and avoids this problem
21:47:51 <NEEDMOAR> Still linking...
21:47:51 <Trinitron> Oh, I thought infix mode of operation was generally eschewed for prefix operators.
21:48:10 <Trinitron> I.E ``
21:48:18 <Trinitron> I.E*
21:48:18 <kmc> the feature is there for a reason
21:48:20 <Zao> Trinitron: Have you've been hugging lispers nowadays?
21:48:27 <Zao> Err, *recently.
21:48:37 <Trinitron> Well I started learning Scheme before Haskell.
21:48:43 <dmwit> Trinitron: Judging solely by your spacing, you probably also mean "func number (index + 1)" after the second guard.
21:48:47 <Trinitron> If that answers your question.
21:48:54 <kmc> some prefix functions are meant to be used infix by their names
21:48:59 <kmc> i think "mod" counts as one of these
21:49:10 <Trinitron> OK. You learn something new every day.
21:49:13 <Zao> `elem`, `isPrefixOf`, etc.
21:49:18 <dmwit> `on`
21:49:26 <Zao> `fmap` :P
21:49:31 <Trinitron> Hai, wakatta.
21:49:35 <Veinor> I think you mean <$>
21:49:42 <dmwit> I think you mean .
21:49:50 <Zao> For certain definitions of .
21:50:08 <aavogt> For certain
21:50:13 <dmwit> Fore!
21:50:17 <Zao> Forth!
21:50:18 <dmwit> English golf.
21:51:17 <Trinitron> So "number `mod` primes !! index+1" parses as "number `mod` (primes !! index)+1"?
21:51:32 <kmc> that depends on the declared fixity of `mod`, !!, and +
21:51:33 <dmwit> Trinitron: Use ghci!
21:51:46 <kmc> (you can declare fixity of a infixified prefix name)
21:51:53 <dmwit> Trinitron: Try ":i !!" and ":i mod" to find out the precedence of those infix operators.
21:52:21 <Trinitron> "i" stands for information, in this case?
21:52:25 <dmwit> yes
21:52:52 <aavogt> @info mod
21:52:52 <lambdabot> mod
21:53:06 <dmwit> ?undo mod
21:53:06 <lambdabot> mod
21:53:13 <dmwit> ?info do {x <- foo; bar x }
21:53:14 <lambdabot> foo >>= \ x -> bar x
21:53:18 <kmc> Trinitron, also, i'm not sure what exactly you're doing, but you're aware that (xs !! n) takes time O(n)?
21:53:37 <Trinitron> I remember that now.
21:54:10 <Trinitron> But the number of times it has to call it self is sub-linear perhaps.
21:54:19 <Trinitron> itself*
21:54:25 <Veinor> I forget, which are the fast list operations in haskell
21:54:32 <kmc> the point is just that lists are not a good random-access datastructure
21:54:42 <kmc> Haskell lists are more like a control-flow structure
21:54:47 <dmwit> Veinor: (:), head, and null; that's about it
21:54:49 <Trinitron> What do you suggest?
21:54:52 <kmc> they are the way you wire a producer and a consumer together to make a coroutine
21:54:59 <dmwit> Veinor: and tail, of course
21:55:14 <kmc> Trinitron, for random access by integral keys?
21:55:25 <Trinitron> Yes.
21:55:37 <aavogt> well scans and folds couldn't be faster with other structures
21:55:39 <dmwit> Veinor: Depending on your definition of "fast", foldr and scanl might qualify as well.
21:55:41 <kmc> Data.Map is pretty easy.  Data.IntMap is a faster version where the key must have type Int
21:55:59 <Veinor> not Integer?
21:56:04 <kmc> correct
21:56:11 <kmc> Data.Sequence provides a finite-sequence type which is much like a list but faster
21:56:18 <dmwit> Veinor: List indexing using (!!) doesn't use Integer, either. ;-)
21:56:42 <Veinor> that's a bug, not a feature
21:56:48 <kmc> arrays are clunkier than all of those, but may give the best performance, if you care
21:56:58 <Trinitron> I'm used to Python, where lists are O(1).
21:57:03 <dmwit> I will point out that Data.Map, Data.IntMap, and Data.Sequence all do very badly on infinite structures compared to lists.
21:57:05 <Trinitron> List indexing*.
21:57:32 <kmc> Trinitron, i don't think that's true for arbitrarily large lists in Python.  does it reallocate into a contiguous chunk of memory always?
21:57:53 <Trinitron> In the Cpython implementation, lists are stored as arrays of pointers.
21:58:06 <Trinitron> to the elements, of course.
21:58:41 <Trinitron> So I have that thinking when I think about Haskell lists, which are linked lists?
21:58:45 <kmc> yes
21:58:51 <Trinitron> Damn,.
21:58:53 <Trinitron> Linked....
21:58:54 <dmwit> Haskell lists are essentially Python generators.
21:58:55 <kmc> which is important for laziness and sharing
21:59:03 <Trinitron> Sure.
21:59:09 <kmc> a Haskell list is simply:   data List a = Nil | Cons a (List a)
21:59:13 <kmc> with special syntax
21:59:25 <Cale> Trinitron: also note, you can have a Haskell list which is infinitely long, but where when the program runs, only one element of the list is ever in memory
21:59:26 <kmc> if "primes" is an infinite list of prime numbers then as dmwit points out, you can't replace it by a finite-sequence type like Seq. however you can directly memoize the function that gives you the nth prime
21:59:32 <kmc> e.g. using the data-memocombinators package
21:59:40 <Trinitron> Ok.
21:59:46 <Trinitron> Thanks for the tip.
21:59:58 <Veinor> I actually recommend memotrie or whatever it's called
22:00:03 <kmc> (which internally uses a tree)
22:00:03 <Cale> Trinitron: Lists are sort of the solidified or reified version of loops.
22:00:09 <kmc> ah that's cool
22:00:44 <kmc> heh, memotrie has an operator named (@.@)
22:01:06 <Veinor> the advantage of memo-combinators is that you can write your own memoizer, the advantage of memotrie is that it's easier to memoize things with funky types
22:01:27 <Veinor> er, nevermind
22:02:08 <monochrom> hahahaha "@.@"
22:02:08 <Trinitron> I hate the fact that I was taught in an imperative language first... It's like my brain is scarred.
22:02:25 <Trinitron> I like referential integrity.
22:02:25 <kmc> Trinitron, indeed.  Though, Haskell is an imperative language also
22:02:42 <NEEDMOAR> OH YEAH.Linking finished!
22:02:43 <kmc> the opposite of "functional" is "dysfunctional"
22:02:54 <Trinitron> Very good.
22:03:02 <tensorpudding> The opposite of functional would be "without functions"
22:03:11 <tensorpudding> which would be quite a disappointing language
22:03:12 <aavogt> the opposite of imperative is unnecessary
22:03:15 <Trinitron> Just assembly.
22:03:25 <kmc> assembly on most architectures has a notion of function still
22:03:40 <Trinitron> Sorry, I unintentionally trolled the channel into the realm of the off topic.
22:03:47 <Trinitron> Back to Haskell :).
22:03:53 <tensorpudding> This channel gets off-topic a lot
22:03:58 <Veinor> it does.
22:04:13 <tensorpudding> So long as its tangential to Haskell it's okay.
22:04:13 <kmc> this is not very offtopic by our standards
22:04:22 <kmc> if you want to see sparks fly just mention C++ in any context
22:04:26 <Trinitron> Heh.
22:04:32 <Trinitron> O SHI-
22:04:36 <Trinitron> You just did.
22:04:42 <kmc> :O
22:04:44 <tensorpudding> As in, talking about programming, or category theory, or operating system design, or the price of tea in china
22:04:48 <monochrom> Like this? f :: (C++ a) => Dynamic -> a
22:05:03 <kmc> we don't talk about OS design that much :/
22:05:19 <Trinitron>  I'm taking a course in OS internals this semester.
22:05:19 <Trinitron> :D
22:05:20 <tensorpudding> UNIX killed it.
22:05:28 <kmc> the triumph of mediocrity
22:05:45 <Veinor> I do like everything being a file.
22:05:47 <tensorpudding> Hmm, Unix, vs. UNIX, which one is right.
22:05:52 <SamB_XP> Unix now
22:05:58 <SamB_XP> UNIX was, once, I think
22:06:00 <Veinor> eunuchs
22:06:04 <kmc> Veinor, it's not really true in most unixes
22:06:06 <Veinor> never LINUX.
22:06:13 <Trinitron> I think it's strange, the etymology.
22:06:14 <tensorpudding> I thought saying UNIX meant that it was licensed from the Open Group.
22:06:16 <kmc> sure everything is a file, but every interesting file has a hundred special-case ioctl()s
22:06:31 <tensorpudding> Hmm, but AT&T called it UNIX.
22:06:50 <kmc> and the other problem with "everything is a file" is that UNIX files are untyped
22:06:55 <Trinitron> Let's name our operating system after castrated people.
22:06:57 <kmc> the only type UNIX knows about is [Word8]
22:07:01 <Trinitron> That makes sense.
22:07:07 <tensorpudding> And it was IRIX, AIX, A/UX, XENIX, HPUX
22:07:08 * Trinitron </sarcasm>
22:07:12 <tensorpudding> always all-caps
22:07:20 <FauxFaux> AIX. :(
22:07:47 <enthymeme> Trinitron: you actually know the origin of the name, right?
22:07:50 <p_l> actually, Unix files are typed, but that was error in implementation that wasn't supposed to exist, but ended being there...
22:07:52 <Trinitron> Maybe it's named after the noble eunuchs of imperial China?
22:07:59 <enthymeme> ...
22:08:01 <enthymeme> It's a pun
22:08:02 <kmc> it's a pun on Multics
22:08:04 <tensorpudding> If proprietary Unix isn't dead yet, it's gasping its last breaths.
22:08:18 <p_l> enthymeme: I recall a pun on UNIX -> Eunuch in a fantasy book :D
22:08:32 <enthymeme> all hail the free unices
22:08:43 <tensorpudding> There's still Solaris.
22:09:00 <p_l> enthymeme: where a witch states that those "wizards" truly went to great sacrifices to achieve power ;-)
22:09:18 <tensorpudding> Presumably AIX is used somewhere yet.
22:09:29 <enthymeme> HP-UX is used at my university
22:09:34 * FauxFaux gets to use AIX on a regular basis.
22:09:40 <enthymeme> I think on one of our email servers
22:09:55 <Veinor> I use linux, os x, and windows on a daily basis
22:10:00 <tensorpudding> But IBM uses Linuxes now too.
22:10:24 * FauxFaux thanks the Pony that OSX isn't a supported server platform for work. :p
22:10:38 <enthymeme> yeah ditto
22:10:56 <tensorpudding> SGI is dead, and presumably IRIX is too.
22:11:29 <Veinor> OSX isn't that bad
22:11:43 <Veinor> the lack of customization does annoy me though
22:11:54 <Trinitron> So they tried to make it sound like "Multics", and give it the meaning of eunuchs, "for the lols"?
22:12:02 <enthymeme> nope
22:12:07 <kmc> it was castrated multics
22:12:08 <tensorpudding> OS X is a proprietary UNIX I guess.
22:12:27 <tensorpudding> But Darwin, the UNIX core, is freely available.
22:13:00 <Trinitron> MAC OS X consists of the Mach microkernel and FreeBSD.
22:13:07 <Trinitron> Mac OS X*
22:13:20 <jeffwheeler> What's the UI called?
22:13:22 <Zao> -Free
22:13:24 <jeffwheeler> Like, it's X?
22:13:29 <Trinitron> I forget.
22:13:39 <jeffwheeler> That's one part that really is great.
22:13:48 <p_l> Irix is dead as were MIPS-based SGI machines
22:13:53 <tensorpudding> Quartz is the graphics rendering stuff.
22:14:01 <pikhq> jeffwheeler: Which bit?
22:14:14 <jeffwheeler> pikhq: whatever you consider the mirror for X
22:14:22 <Zao> p_l: I've got an O2 next to me. It's very much alive :)
22:14:23 <p_l> Trinitron: OSX consists of OpenSTEP with new libraries and completely new graphic system, as well as Mac-compatible look
22:14:25 <tensorpudding> The Cocoa API is the special stuff that OS X apps use.
22:14:26 <pikhq> Display PDF? Quartz? Cocoa?
22:14:51 <Trinitron> My textbook is out of date, then.
22:14:59 <jeffwheeler> Cocoa is more comparable to, say, Gtk, no?
22:15:01 <p_l> Trinitron: FreeBSD is probably as much represented in OSX as it is in Windows NT
22:15:16 <p_l> jeffwheeler: GNUstep :)
22:15:23 <jeffwheeler> Display PDF seems like it'd also be at a higher level, and I'm not exactly sure where Quartz fits in.
22:15:30 <jeffwheeler> p_l, ha, yeah
22:15:46 <Trinitron> My text book is "Operating Systems" by William Stallings.
22:15:57 <Trinitron> I guess it hasn't been updated.
22:16:08 <tensorpudding> GNUstep is an open-source implementation of Openstep, which is based on NeXTStep, which was what evolved into Cocoa (i think)
22:16:23 <pikhq> tensorpudding: GNUstep also implements portions of Cocoa.
22:16:33 <pikhq> (for the sake of making crossplatform apps easier)
22:16:38 <jeffwheeler> tensorpudding: yeah, I remember playing vaguely with GNUstep before; it's an ObjC toolkit like Cocoa
22:16:41 <tensorpudding> NeXTStep was made by NeXT, which was the company Steve Jobs founded after he was booted out of Apple.
22:16:54 <p_l> Trinitron: the thing is that OpenSTEP was built on top of modified Mach, with CMU Mach starting out based on 4.3BSD (or 4.4, don't remember exactly), then added parts from OSF/1 (also BSD-related) and used Obj-C for their own ABI
22:17:04 <aavogt> jeffwheeler: what's the status on this bug: http://code.google.com/p/yi-editor/issues/detail?id=306  ? As it stands, the hackage yi doesn't build on any ghc.
22:17:35 <tensorpudding> And when he came back, and they started working on making a replacement to the old Mac OS, they decided to use an updated version of NeXTStep
22:17:48 <jeffwheeler> aavogt: I don't know; I just tried messing with package dependencies earlier today to see if I could get anything working (even by modifying other cabal files), but I gave up after a while
22:17:52 <tensorpudding> Though that was after their first effort failed miserably
22:18:04 <jeffwheeler> aavogt: (I was running darcs yi, but I'm not sure much has changed)
22:18:33 <Trinitron> I'm off now.
22:18:39 <Trinitron> Thanks for the help!
22:18:53 <pikhq> tensorpudding: Their replacement for the old Mac OS didn't fail horribly. They just didn't follow through.
22:19:09 <pikhq> A/UX was actually rather nice.
22:19:26 <tensorpudding> I was thinking of Copland.
22:19:57 <pikhq> Ah. That.
22:20:11 <pikhq> Yeah, that was an abortion.
22:20:30 <tensorpudding> A/UX is a really rare commodity though.
22:20:45 <monochrom> Hope is a new hope.
22:24:59 <aavogt> jeffwheeler: hmm, I think I build yi from darcs on 6.12 and 6.10 recently...
22:25:13 <aavogt> I don't recall having any problems
22:25:38 <jeffwheeler> aavogt: I sure wish I could; I had lots of trouble with data-accessor-template and template-haskell conflicts
22:26:23 <aavogt> jeffwheeler: oh, right. You have to specify to cabal install    --constraint="template-haskell >= 2.4"
22:27:22 <aavogt> either the data-accessor cabal file or cabal install is broken for thinking that you can install an older template-haskell in a newer ghc
22:27:38 <jeffwheeler> aavogt: hm, well, now I've been playing with my GHC to get LLVM setup, so I've screwed it up and can't test that at the moment
22:28:51 <aavogt> if you do run into other problems, ping me and I might remember having dealt with the same ones
22:29:01 <jeffwheeler> aavogt: alright; thanks
22:29:19 <jeffwheeler> I'm glad that Yi has been getting some attention in the last few days; it's really a great project.
22:30:52 <aavogt> I can't use it myself yet since I have not spent the time to figure out how to remap keys in the vim emulation mode
22:31:29 <jeffwheeler> aavogt: you mean remap to the vim mode, or to add to the vim keymap?
22:31:42 <aavogt> remap keys in the vim keymap
22:32:45 <jeffwheeler> aavogt: try looking at src/Yi/Users/Jeff.hs; I remap a bit for vim
22:33:11 <jeffwheeler> aavogt: Corey.hs, too
22:33:58 <jeffwheeler> Hope that helps; I've got class tomorrow, so I'm off to bed. G'night.
22:40:04 <p_l> tensorpudding: I'm still wishing for proper macintosh emulator to run A/UX :/
22:44:18 <p_l> pikhq: btw, the replacement for A/UX (aka A/UX 4.0, iirc) was supposed to be based on OSF codebase (which ironically is present in OSX xD)
22:46:23 <ski> preflex: xseen edwardk
22:46:23 <preflex>  edwardk was last seen on freenode/#haskell 22 hours, 23 minutes and 28 seconds ago, saying: conal: iirc io snuck into his specification because of ffi constraints
23:04:54 <aavogt> @hoogle Max
23:04:54 <lambdabot> Prelude max :: Ord a => a -> a -> a
23:04:55 <lambdabot> Data.Ord max :: Ord a => a -> a -> a
23:04:55 <lambdabot> Prelude maxBound :: Bounded a => a
23:04:58 <aavogt> @hoogle Maximum
23:04:58 <lambdabot> Prelude maximum :: Ord a => [a] -> a
23:04:58 <lambdabot> Data.ByteString maximum :: ByteString -> Word8
23:04:58 <lambdabot> Data.Foldable maximum :: (Foldable t, Ord a) => t a -> a
23:21:39 * hackagebot dwarf 0.22 - Parser for DWARF debug format.  http://hackage.haskell.org/package/dwarf-0.22 (ErikCharlebois)
23:35:38 <mail> woah learning about sets
23:35:48 <mail> looks a lot like lists in haskell
23:36:21 <kmc> Data.Set?
23:38:19 <mail> reading theory of computation by sipser
23:38:23 <kmc> oh
23:38:29 <kmc> great book
23:38:37 <kmc> sets from set theory differ from Haskell lists in some important ways
23:38:40 <mail> there is a lot of shit here that i learned from reading abot uhaskell
23:56:56 <roboshibby> how do sets differ from haskell lists?
23:57:45 <kmc> sets are unordered and can't contain duplicates
23:57:56 <roboshibby> ahh
23:58:14 <roboshibby> so haskell lists are like arrays? (ordered, duplicates allowed)
23:58:25 <kmc> they're like arrays in those two respects
23:58:30 <kmc> they are unlike arrays in some other ways
23:58:33 <kmc> haskell lists are linked lists
23:58:35 <roboshibby> which are?
23:58:41 <roboshibby> what's linked lists mean?
23:58:56 <kmc> data List a = Nil | Cons a (List a)
23:59:18 <kmc> every list is the empty list, or it's a "head" consisting of some element, and a "tail" consisting of the rest of the list
23:59:36 <roboshibby> isn't that a hash?
23:59:40 <kmc> not at all
23:59:55 <roboshibby> is it like an array which contain an array object?
