00:07:16 <Saizan> well, upgrade installs new versions of the dependencies if it finds them, and that tends to cause problems
00:07:39 <copumpkin> why not take it out?
00:07:43 <copumpkin> or make it not mess things up
00:07:50 <copumpkin> it's awfully tempting :)
00:08:00 <c_wraith> really, there's an O(n^2) problem with the fact that dependencies are statically compiled into libs at build time.
00:08:15 <c_wraith> err, it's worse, isn't it.  It's exponential.
00:08:25 <znutar> no its linear
00:08:27 <Saizan> copumpkin: they are moving towards the latter
00:08:41 <c_wraith> if there are two versions of every library, there are 2^n combinations of libs something that depends on each lib could use
00:08:52 <c_wraith> err, something that depends on n libs
00:10:23 <Cale> http://www.youtube.com/watch?v=mQgd1fmPI1k :)
00:11:12 <SamB_XP> c_wraith: assuming the dependancies don't have constraints, yeah
00:11:21 <SamB_XP> but of course in reality it's worse than that, he's dead jim!
00:13:21 <c_wraith> in theory, dynamic linking helps significantly, right?
00:14:29 <Saizan> not really
00:14:47 <Saizan> dependencies aren't linked in fact
00:15:00 <Saizan> the problem is that the ABIs are not stable.
00:15:49 <Saizan> but i guess they have to make them "stabler" to make dynamic linking useful
00:20:48 <alex404_> foo
00:21:07 <Axman6> bar
00:21:28 <alex404_> Excellent!
00:24:53 <alex404_> Is there any sort of trick to calling c functions which perform IO in haskell? I can't even seem to get printf to work.
00:25:31 <Axman6> all C functions are treated the same
00:26:01 <copumpkin> alex404_: how are you calling it?
00:26:30 <alex404_> foreign import "printf" printf :: Ptr CString -> IO ()
00:26:35 <alex404_> Is the import statement
00:26:43 <alex404_> IIRC
00:26:48 <copumpkin> variadic functions and FFI do not enjoy each other
00:27:07 <copumpkin> well, haskell in general :)
00:27:09 <Axman6> so, write a wrapper function in C
00:27:10 <alex404_> That's a good point...
00:27:48 <alex404_> Well, I'm trying to call a big IO function, and that isn't working either. It compiles, but than just does nothing. I'll try writing a little toy c wrapper...
00:27:57 <alex404_> for printf
00:28:10 <alex404_> (Note: My c isn't veriadic)
00:28:51 <alex404_> Does ghci warn you if you mistype your foreign imports, or will it just do nothing?
00:29:57 <copumpkin> alex404
00:30:05 <copumpkin> how are you calling your big io function?
00:30:14 <copumpkin> from haskell
00:30:22 <alex404_> Same way I'm doing with printf above
00:30:23 <absentia> with love
00:30:27 <absentia> dern
00:30:41 <alex404_> Ultimately called inside main
00:30:53 <copumpkin> hm
00:31:03 <copumpkin> so you're sure you're actually calling it and not just evaluating it?
00:31:24 <alex404_> Sorry, what do you mean?
00:31:32 <alex404_> Does this have to do with laziness or something?
00:31:56 <Axman6> it could do
00:32:16 <copumpkin> alex404_: not really laziness
00:32:26 <copumpkin> but in haskell there's a fundamental distinction between evaluating and executing
00:32:33 <copumpkin> > map print [1..5]
00:32:35 <lambdabot>   [<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>]
00:32:47 <alex404_> Hmmm... so that's evaluation?
00:32:53 <copumpkin> I have a bunch of print actions there that I evaluated to show
00:32:58 <copumpkin> but they haven't been run
00:32:59 <alex404_> Right.
00:33:10 <alex404_> But you stick em inside main and they run, no?
00:33:15 <copumpkin> you'd have to sequence that list to make them run
00:33:29 <copumpkin> > sequence_ $ map print [1..5]
00:33:30 <lambdabot>   <IO ()>
00:33:51 <copumpkin> depends what you mean by sticking em inside main :)
00:34:27 <alex404_> Want to see my little haskell code?
00:34:35 * hackagebot uulib 0.9.12 - Haskell Utrecht Tools Library  http://hackage.haskell.org/package/uulib-0.9.12 (DoaitseSwierstra)
00:34:36 <copumpkin> sure
00:34:45 <alex404_> just a sec...
00:34:57 <alex404_> Using a new machine, everything is different...
00:37:23 <alex404_> copumpkin: http://paste.pocoo.org/show/185860/
00:37:40 <copumpkin> yeah, you aren't running it :)
00:37:53 <copumpkin> foo <- c_run_micro
00:37:55 <copumpkin> not let
00:38:12 <alex404_> So that's why the last argument needs to be wrapped in IO?
00:38:38 <copumpkin> well, you don't really need the return () if you aren't using the result of foo
00:38:51 <copumpkin> you could just write c_run_micro ... as the last line of your do
00:40:07 <alex404_> Interesting... I'm going to toy with this for a bit. Thanks for the info.
00:42:19 <copumpkin> np
00:44:42 <Gracenotes> hm. I just came across a weird LaTeX-rendering inconsistency
00:44:57 <copumpkin> on edges of boxes?
00:45:06 <Gracenotes> spacing of mathematical operators
00:45:11 <copumpkin> ah
00:47:03 <copumpkin> I wonder how long this super simple floyd warshall on 5200 nodes will take
00:47:29 <copumpkin> probably quite a while
00:47:29 <Gracenotes> > 5200^3
00:47:30 <lambdabot>   140608000000
00:47:50 <Gracenotes> is it a sparse graph?
00:47:57 <copumpkin> fairly, yep
00:48:17 <copumpkin> johnson's algo is probably better
00:48:24 <Gracenotes> but hella complicated
00:48:36 <copumpkin> yeah :/
00:50:47 <copumpkin> > (5209^3, 5209**2 * log 5209 + 5209 * 56004)
00:50:48 <lambdabot>   (141339344329,5.239387629372643e8)
00:51:00 <copumpkin> > (5209^3, round $ 5209**2 * log 5209 + 5209 * 56004)
00:51:01 <lambdabot>   (141339344329,523938763)
00:51:19 <copumpkin> assuming a small coefficient it definitely looks a lot better :)
00:53:06 <Gracenotes> or you could just be Google and have months of time and a huge server farm
00:53:40 <copumpkin> seems like a waste :)
00:59:23 <blueonyx> some fun with tryand evaluate, can someone help? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23240#a23240
01:02:04 <copumpkin> ah, boost has the algorithm
01:06:51 <alex404_> copumkin: So I got a cheesy little printf to work, but I can't seem to get my actual c code to work. The IO runs in real time, and should take about 100 seconds (it outputs to an oscilloscope) but when I run it control is returned immediately and nothing appears to happen. Any thoughts?
01:07:39 <alex404_> copumpkin: even
01:07:58 <Jonno_FTW> how do i make an executable from an .hs file where the module name is not main
01:08:01 <Jonno_FTW> ?
01:08:35 <Axman6> with the main-is flag (check the man page)
01:08:39 <Axman6> or mainis
01:08:43 <Axman6> or something
01:08:49 <Jonno_FTW> hmm
01:09:51 <Jafet> alex, sounds like IO isn't being evaluated
01:10:16 <alex404_> Heh. That's what he said! ;)
01:10:29 <Saizan> evaluation is irrelevant here
01:10:39 <alex404_> The return value (since the function returns void) is IO (), and it's the last line of my main
01:10:42 <alex404_> Isn't that enough?
01:10:48 <Saizan> though it might be the case that it's not executed as part of the main action
01:11:27 <Saizan> alex404_: it should, unless you mean the type is IO (IO ())
01:11:39 <Saizan> alex404_: can you paste the code?
01:11:55 <copumpkin> you didn't write return (myfunction params) did you? :P
01:12:01 <alex404_> ...
01:12:10 <alex404_> *hits head with 2 by 4*
01:12:15 <Axman6> -_-
01:12:16 <alex404_> Wooh! I got a seg fault
01:12:17 <Axman6> :P
01:12:17 <copumpkin> this is why I think return is a bad name
01:12:19 <alex404_> At least I'm getting somewhere
01:12:31 <alex404_> Never been happy to see a seg fault before
01:13:03 <Axman6> i've always been happy when i see segfaults in haskell, means it's not my proglem usually :P
01:13:10 <copumpkin> my floyd-warshall took 28 minutes on my 2ghz xeon
01:13:15 <copumpkin> not terrible
01:13:19 <copumpkin> but it was a tight c loop
01:13:20 <Gracenotes> im in ur base, accessin ur segments
01:17:56 <Jafet> In soviet russia, is normal form for weak head to be executed of you
01:18:35 <LMolr> hehe
01:19:02 <alex404_> Cannot parse
01:26:47 <alex404_> Is CShort = short int?
01:31:23 <sam123> I am trying to remove an element from a list which contains a specific data type. How can I do that? (I am a newbie)
01:32:03 <integral> what do you mean by "contains a specific data type"?  Which element are you trying to remove?
01:32:35 <anders^^> is there anything similar to the runSTUArray for MVector? I would prefer not using the unsafeFreeze directly...
01:33:56 <voker57> > [1,2,3] \\ [2]
01:33:57 <lambdabot>   [1,3]
01:34:03 <sam123> integral: I have defined a data type called Book and I have a list that contains books. I want to remove one of the books and return the rest.
01:34:03 <voker57> sam123: ^ ?
01:34:28 <integral> Okay, but which book do you want to remove?   There's (\\), and filter, and tail, splitAt, etc
01:34:36 <voker57> if you have your own type, it should derive Eq for that to work
01:34:58 <sam123> voker57: how do I do that? I have done it and I get stackoverflow error
01:35:14 <asdf1>  data Word = W# Word# deriving (Eq, Ord).  What does "#" character means?
01:35:21 <voker57> sam123: show your code please
01:35:31 <copumpkin> anders^^: apply in http://hackage.haskell.org/packages/archive/vector-algorithms/0.3/doc/html/Data-Vector-Algorithms-Combinators.html is sort of it
01:35:34 <sam123> instance  Prelude.Eq BookData where
01:35:34 <sam123> eq:: BookData -> [BookData] -> Bool
01:35:34 <sam123> eq _ [] = False
01:35:34 <sam123> eq b  (x:xs) = if bookID b == bookID x then True else eq b (xs)
01:35:44 <sam123> removeBook:: BookData -> [BookData] -> [BookData]
01:35:45 <sam123> removeBook _ [] = []
01:35:45 <sam123> removeBook bo (x:xs) = delete bo (x:xs)
01:35:50 <voker57> asdf1: that's internal GHC stuff... special types. unboxed iirc
01:35:51 <copumpkin> anders^^: but not ideal, unless you already wanted to modify an existing mutable vector
01:36:01 <voker57> sam123: please paste to http://hpaste.org
01:36:59 <voker57> sam123: if you type is simple, you can not implement Eq yourself but derive it: > data Book = Book name deriving (Eq)
01:37:16 <anders^^> copumpkin: thanks!
01:37:23 <voker57> eh, but that's not te case i guess
01:37:43 <pozic> Does anyone know whether CPU simulators exist which are exact? That is, the time to execute some instructions as predicted by the simulation matches exactly the amount on a real CPU?
01:37:47 <sam123> voker57: so i have to change the instance ?
01:37:57 <voker57> sam123: no, it's ok
01:38:32 <voker57> removeBook = delete
01:38:34 <voker57> :)
01:39:02 <sam123> voker57: what?
01:39:27 <voker57> sam123: your removeBook is exactly the same as "delete" function
01:40:00 <voker57> but your instance is wrong. Why are you comparing BookData and [BookData]?
01:40:12 <sam123> voker57: so what should I do? should I just apply delete? Why do I get stack overflow?
01:40:18 <integral> :t eq
01:40:19 <lambdabot> Not in scope: `eq'
01:40:32 <voker57> sam123: that's because of your instance
01:40:53 <sam123> I want to give it my list and a book to be deleted from it. Is that approach wrong?
01:41:04 <voker57> sam123: give to what?
01:41:18 <sam123> to removeBook
01:41:27 <Axman6> sam123: it's right, but you're doing it wrong :)
01:41:35 <voker57> that's right, but you really don't need removeBook at all
01:41:39 <voker57> delete will do
01:41:57 <Axman6> as long as you actually have an instance for Eq
01:42:04 <Axman6> which, you don't so far
01:42:10 <sam123> voker57: but delete does not know anything about my BookData type!
01:42:22 <Axman6> instance Eq BookThing where uses the default instances which are...
01:42:26 <Axman6> @src ==
01:42:26 <lambdabot> x == y = not (x /= y)
01:42:29 <Axman6> @src /=
01:42:30 <lambdabot> x /= y = not (x == y)
01:42:32 <voker57> sam123: it needs to know only that it's an instance of Eq
01:42:44 <sam123> right
01:43:17 <sam123> voker57: so I need to remove the instance bit and just use delete to do the job?
01:43:38 <voker57> sam123: no. you need instance
01:43:45 <voker57> but you need to do it right
01:44:02 <voker57> implement (==) :: BookType -> BookType -> Bool
01:45:14 <sam123> vcoker57: do I have to change this line : "instance  Prelude.Eq BookData where" ? because I have tried to implement == but got ambiguous error
01:45:42 <voker57> sam123: no, this line seems right
01:45:44 <Axman6> that line is fine (though ou don't need the Prelude. part)
01:46:04 <sam123> Axman6: ghc said I need ??
01:46:09 <Axman6> but under it, you should have (Book x) == (Book y) = x == y
01:46:26 <Axman6> or, something like that
01:46:43 <voker57> sam123: paste your code and error on http://hpaste.org
01:50:31 <sam123> voker57: I have pasted it with the error message.
01:50:44 <voker57> cool, now give us the link
01:51:00 <sam123> voker57: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23241#a23242
01:51:50 <voker57> sam123: you need an indentation level in implementation of Eq
01:52:29 <voker57> and you are still comparing single BookData to a list
01:53:50 <sam123> voker57: so do I have to change == implementation to only get 2 BookData s and then recursively check in my removeBook?
01:54:14 <Axman6> yes
01:54:35 <voker57> sam123: you don't need removeBook. Implement the Eq by implementing comparing two BookData's in time and delete will do.
01:55:54 <pastorn> @pl  (\k n -> write $ privmsg reciever $ show n ++ ": " ++ k)
01:55:54 <lambdabot> ((write . privmsg reciever) .) . flip ((++) . show) . (": " ++)
01:56:01 <pastorn> ehm...
01:56:11 <sam123> voker57: have done it , and have put the indentation as well. But still get 2 errors on ambiguous occurrence?
01:56:44 <voker57> well i'm no telepath so paste 'em
01:57:05 <Axman6> sam123: we can't help you without seeing the code
01:57:16 <voker57> (and the code, yes)
01:57:24 <voidprayer> Is (<-) only available in IO Monad?
01:57:31 <Axman6> no, all monads
01:57:39 <Axman6> it's part of the do notation
01:58:12 <pastorn> voidprayer: monads are there for not making do-notation available for only IO
01:58:13 <Axman6> > do {x <- [1..3]; y <- [4..6]; return (x,y)}
01:58:14 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
01:58:47 <pastorn> voidprayer: ^^ axmans is the list monad, you can think of it as the "for every"-monad
01:58:48 <sam123> Axman6: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23241#a23241  - sorry forgot to send the link
01:58:48 <pastorn> :)
01:58:51 <voidprayer> I see, thanks Axman6 and pastorn.
01:59:30 <Axman6> sam123: == has the wrong type there. it needs to be BookData -> BookData -> Bool, it can't take a list as the second argument
01:59:50 <voker57> sam123: it's the old code.
01:59:59 <voker57> oh, no it isn't sorry
02:00:01 <voidprayer> Then in which way we have (<-)? :i (<-) does not say anything.
02:00:10 <Axman6> voidprayer: it's not a function
02:00:14 <Axman6> it;s syntax
02:00:28 <voidprayer> Axman6: together with Do notation?
02:00:34 <Axman6> yes
02:00:40 * Axman6 must be off. o/
02:00:49 <voker57> sam123: wrong indentation
02:00:56 <voker57> sam123: see http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23241#a23244
02:01:03 <voidprayer> Axman6: 88
02:01:11 <voker57> you need to indent all the lines of implementation
02:01:49 <pastorn> @pl  (\k n -> write $ privmsg reciever $ show n ++ (':':k))
02:01:49 <lambdabot> ((write . privmsg reciever) .) . flip ((++) . show) . (':' :)
02:03:25 <sam123> voker57: why haskell is so fussy about indentation? I have changed it to yours and it says Misplaced type signature: == :: BookData -> BookData -> Bool.
02:04:06 <voker57> sam123: you can use {} and semicolons instead, but indentation is convenient
02:04:40 <voker57> i think you need a space between (==) and ::
02:05:19 <sam123> voker57: no still the same error :(
02:05:42 <tensorpudding> the semicolons and {} syntax is not at all in common use; it was put in place to allow one to mechanically generate haskell code easily
02:05:48 <dMazz> I installed gt2hs 0.10.1 and it was complaining about my ghc version which was one digit greater that the supported: "Continue anyway, but you have to fix the DLL search path yourself."  - any help about fixing this path?
02:06:36 <tensorpudding> sam123: also, what is it you're trying to do?
02:07:00 <voker57> sam123: you don't need a signature there and it's wrong anyway
02:07:04 <voker57> @type ==
02:07:05 <lambdabot> parse error on input `=='
02:07:09 <voker57> @type (==)
02:07:10 <lambdabot> forall a. (Eq a) => a -> a -> Bool
02:07:40 <Alpounet> sm, you need  ( ) around ==
02:08:18 <sam123> tensorpudding: just want to remove an element from a list
02:08:27 <sam123> Alpounet: i have it there
02:08:40 <tensorpudding> what exactly is the code that you wrote?
02:08:53 <sam123> I just dont get why is it so hard to deal with lists in haskell.
02:08:57 <tensorpudding> removing an element from a list isn't hard, you can use filter
02:09:03 <sam123> tensorpudding: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23241#a23244
02:09:17 <Jafet> Heh
02:09:33 <voker57> sam123: here's your fixed instance http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23241#a23245
02:09:38 <tensorpudding> you don't need to put the type signature for (==) in there
02:10:11 <tensorpudding> @type delete
02:10:12 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
02:10:19 <integral> your code defining (==) is _wrong_.  you just need something as simple as: b == d = bookID b = bookID d
02:10:55 <sam123> voker57: thank you so much. It worked perfectly fine. Saved me a lot of time :D
02:12:09 <tensorpudding> like integral said, you could write your instance of (==) as bookID b == bookID d
02:12:27 <integral> sorry, I was too late, I didn't see voker57's correction of exactly that on the paste
02:13:20 <sam123> thank you guys. I was about to give up learning haskell :D
02:16:24 <voidprayer> How many people giving up Haskell everyday?
02:17:23 <dMazz> I'm not giving up.. but how do I fix gtk2hs 0.10.1 installation on ghc 6.10.4? It warned about unsupported ghc version and demands me to fix the DLL search path
02:17:48 <dMazz> which GUI-library do you recommend?
02:23:38 <dMazz> I'm running on winxp; does it mean setting up the PATH-env-variable? or something in package.conf? I'm in dead end here..
02:24:53 <tensorpudding> i didn't know that gtk2hs has a windows version
02:26:03 <voker57> windows has gtk2hs problem
02:26:59 <pastorn> haskell is amazing
02:27:42 <Dementati> Today's XKCD strip feels like a personal insult when you've recently implemented a Collatz function in Haskell for practice.
02:27:42 <pastorn> when i eventually have to write stuff in some other language i'm going to be devastated over not being able to have my code work as intended om my first try :(
02:27:44 <tensorpudding> where is gtk2hs's website...
02:27:59 <pastorn> @where gtk2hs
02:27:59 <lambdabot> http://haskell.org/gtk2hs/
02:29:55 <chipmonkpyro> if ive got an instance "Duration" which is defined as
02:29:57 <chipmonkpyro> data Duration = Time Integer Integer
02:29:58 <chipmonkpyro> How would I convert a "Time n n" value to a float?
02:30:28 <pastorn> chipmonkpyro: conv (Time n m) == n.m ?
02:31:15 <chipmonkpyro> ?
02:31:37 <pastorn> (\(Time n m) -> (read :: String -> Float) $ show n ++ "." ++ show b)
02:31:49 <pastorn> poor mans number conversion
02:32:26 <pastorn> > (\(n, m) -> (read :: String -> Float) $ show n ++ "." ++ show b) (1::Int,3::Int)
02:32:27 <lambdabot>   * Exception: Prelude.read: no parse
02:32:30 <pastorn> shit
02:32:46 <tensorpudding> you want to turn (Time 5 30) into 5.30?
02:32:53 <chipmonkpyro> no
02:33:00 <tensorpudding> or 5.5?
02:33:17 <chipmonkpyro> Time 5 30 -> 330
02:33:30 <tensorpudding> 330 meaning what?
02:33:30 <pastorn> you want the number of minutes?
02:33:39 <chipmonkpyro> data Duration = Time Integer Integer
02:33:41 <chipmonkpyro>                 deriving (Show)
02:33:42 <chipmonkpyro> -- Enroll Duration om the desired type classes
02:33:44 <chipmonkpyro> instance Eq Duration where
02:33:45 <chipmonkpyro>     Time h1 m1 == Time h2 m2  =  (60*h1+m1==60*h2+m2)
02:33:47 <chipmonkpyro> instance Ord Duration where
02:33:47 <pastorn> \(Time h m) -> 60 * h + m
02:33:48 <chipmonkpyro>     Time h1 m1 <= Time h2 m2  =  (60*h1+m1 <= 60*h2+m2)
02:33:50 <chipmonkpyro> instance Num Duration where
02:33:52 <chipmonkpyro>     -- GHC will issue warnings about *, abs, and signum not being
02:33:53 <chipmonkpyro>     -- defined, but it is OK---we don't want them defined.
02:33:54 <pastorn> chipmonkpyro: DUDE!
02:33:55 <chipmonkpyro>     Time h1 m1 + Time h2 m2  =  Time h m
02:33:56 <chipmonkpyro> 	where (h,m) = divMod (60*(h1+h2)+m1+m2) 60
02:33:58 <chipmonkpyro>     Time h1 m1 - Time h2 m2  =  Time h m
02:33:59 <chipmonkpyro> 	where (h,m) = divMod (60*(h1-h2)+m1-m2) 60
02:34:01 <chipmonkpyro>     fromInteger n = Time h m
02:34:02 <chipmonkpyro> 	where (h,m) = divMod n 60
02:34:04 <chipmonkpyro> sorry :)
02:34:06 <tensorpudding> don't middle-click paste
02:34:10 <pastorn> chipmonkpyro: if more than 3 lines, use hpaste
02:34:16 <pastorn> @where hpaste
02:34:16 <lambdabot> http://hpaste.org http://moonpatio.com/fastcgi/hpaste.fcgi/
02:34:17 <tensorpudding> okay
02:34:18 <tensorpudding> so
02:34:34 <tensorpudding> pattern match on (Time h m), and then calculate a function of h and m?
02:34:38 <pastorn> \(Time h m) -> 60 * h + m
02:34:50 <tensorpudding> that's not a float at all though, that's still an Int
02:34:51 <chipmonkpyro> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=8461#a8461
02:36:46 <chipmonkpyro> how would i apply "\(Time h m) -> 60 * h + m" exactly?
02:36:56 <blueonyx> whats the function which turns [1,2,3] into [1,1337,2,1337,3]?
02:37:06 <tensorpudding> blueonyx: intercalate i think
02:37:14 <tensorpudding> @type intercalate
02:37:15 <lambdabot> forall a. [a] -> [[a]] -> [a]
02:37:17 <Cale> intersperse
02:37:22 <tensorpudding> ah, the other one
02:37:23 <blueonyx> ah thanks
02:38:02 <tensorpudding> chipmonkpyro: you could have a function convert :: Time Int Int -> Int
02:38:12 <tensorpudding> and convert (Time h m) = 60*h + m
02:38:20 <chipmonkpyro> ah ok
02:38:45 <Jafet> > (\((,) h m) -> 60 * h + m) (5,30)
02:38:46 <lambdabot>   330
02:42:34 <chipmonkpyro> do you know why this wouldnt work?
02:42:36 <chipmonkpyro> payDay :: [Duration] -> Int
02:42:38 <chipmonkpyro> payDay ds = c (sum ds)
02:42:40 <chipmonkpyro>     where c h m = 60*h + m
02:43:23 <Cale> chipmonkpyro: Because c (sum ds) is a function, not an Int
02:43:34 <tensorpudding> c has two arguments but it has been given only one
02:43:56 <chipmonkpyro> what is "Time 4 50" exactly then?
02:44:02 <chipmonkpyro> i thought that was two numbers
02:44:14 <tensorpudding> it's an abstract data type, with two fields, that are typed Int
02:44:34 <tensorpudding> you can pattern match on it by using c (Time h m)
02:45:25 <chipmonkpyro> like this?
02:45:27 <chipmonkpyro> payDay :: [Duration] -> Int
02:45:28 <chipmonkpyro> payDay ds = c (sum ds)
02:45:30 <chipmonkpyro>     where c (Time h m) = 60*h + m
02:46:32 <tensorpudding> yes, that should work if you defined a Num instance for Duration
02:46:59 <chipmonkpyro> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=8461#a8461
02:47:06 <chipmonkpyro> its not working :(
02:47:36 <chipmonkpyro> oh wait nvm
03:02:29 <o-_-o> it would be pretty nice, if you one of you took a youtube course on cat theory :-)
03:04:16 <cads> o-_-o: look up the catsters videos
03:05:23 <o-_-o> cads, cool thanks
03:10:42 <o-_-o> is there an order to watching those ?
03:10:42 <RayNbow> preflex: seen copumpkin
03:10:42 <preflex>  copumpkin was last seen on #haskell 1 hour, 34 minutes and 51 seconds ago, saying: anders^^: but not ideal, unless you already wanted to modify an existing mutable vector
03:11:11 <o-_-o> it is like trying to decide learning klingon, no idea which are the fundanmental stuff and which is the later stuff
03:11:30 * kw317 is having problems installing criterion on os x
03:12:41 <kw317> I'm trying to install gtk2hs first.. configure runs nicely and I get gtk:yes, cairo:yes
03:13:01 <kw317> but then gmake blows up with: gmake: *** [package.conf.inplace] Error 1
03:16:23 <int-e> kw317: can you paste the last few lines on hpaste?
03:17:48 <kw317> int-e: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23246#a23246
03:18:50 <kw317> int-e: that's what configure is giving me http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23247#a23247
03:21:45 <Szilva> mornin, anybody using biohaskell? I need some help in converting a SeqData to Sequence
03:23:07 <int-e> kw317: oh. the interesting part is the huge command just before the package config warnings. That contains something like /bin/sed -e 's|...' ... gio/gio.package.conf | ghc-pkg update - --force --package-conf=package.conf.inplace ... I wonder if there's something wrong the the sed commands
03:24:50 <int-e> oh. the 'missing id field' is the problem.
03:25:36 <int-e> kw317: which ghc version and which gtk2hs version are you using? I guess: ghc 6.12, and the latest release. You should try the darcs version instead.
03:25:47 <int-e> kw317: and use --disable-split-objs when configuring
03:27:03 <kw317> int-e: I'm using 6.12.1, darcs version of gtk2hs?
03:27:11 <kw317> I'll try --disable-split-objs
03:27:49 <Jonno_FTW> can ghc handle unicode characters?
03:28:03 <Jonno_FTW> or ghci for that matter?
03:30:00 <int-e> kw317: odd, I don't get that message about missing id fields with ghc 6.12.1 and the darcs head. (the --disable-split-objs is irrelevant for generating that package configuration.)
03:30:14 <Jafet> > "当然可以"
03:30:15 <lambdabot>   "\24403\28982\21487\20197"
03:30:38 <int-e> kw317: can you check that after configure, gie/gio.package.conf contains a line id: gio-0.10.1 ?
03:30:40 <Jonno_FTW> > "♥"
03:30:41 <lambdabot>   "\9829"
03:30:59 <Jafet> Perhaps not.
03:32:02 <kw317> int-e: sure, one second
03:32:49 <Tinned_Tuna> \9829
03:32:53 <Tinned_Tuna> :-/
03:33:11 <kw317> int-e: no, I can't see a line like that
03:33:55 <int-e> kw317: that's the problem then. gio/gio.package.conf.in  contains a line  id: gio-@PACKAGE_VERSION@  that is supposed to produce this output, when configure is run.
03:34:53 <kw317> I'll try the version from darcs
03:36:10 <medfly> > read "当然可以"
03:36:11 <lambdabot>   * Exception: Prelude.read: no parse
03:36:16 <medfly> uhh
03:36:18 <medfly> what was it
03:37:33 <Jafet> 真好玩。
03:38:15 <Jonno_FTW> i suspect this will require some library
03:38:43 <Jafet> My ghci appears to use an oblivious line editing library.
03:38:59 <Jafet> Unfortunately, it's the oblivious-and-doesn't-work-by-default kind
03:46:22 <kw317> int-e: darcs head seems to work fine
03:49:09 <sizur> does anyone here use DB2?
03:50:07 <dobblego> I used to
03:50:16 <dobblego> I assume you mean DB2 UDB (DB2 is a brand)
03:51:33 <sizur> isnt that mainframe version?
03:52:31 <sizur> if you want to be specific, then DB2 Express-C
03:54:12 <sizur> i always had trouble installing db packages for ghc.  what's the current best practice for ghc-6.12.1?
03:54:28 <liff> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23248
03:54:48 <liff> is there some library version of the 'apx' function?
03:54:59 <liff> or some other way to do that that i've missed
03:56:09 <FliPPeh> @src odd
03:56:09 <lambdabot> odd = not . even
03:56:14 <FliPPeh> @src even
03:56:14 <lambdabot> even n = n `rem` 2 == 0
03:56:35 <FliPPeh> @src rem
03:56:35 <lambdabot> Source not found. Do you think like you type?
03:56:45 <FliPPeh> ;x
03:56:47 <sizur> :t even
03:56:49 <lambdabot> forall a. (Integral a) => a -> Bool
03:57:58 <sizur> hmm, wont it make sense to write a specific even function for Ints?
03:58:24 <Jafet> It won't -- there already is one.
03:58:28 <FliPPeh> mod?
03:58:29 <sizur> to just check the last bit
03:58:46 <Jafet> :t even :: (Int -> Bool)
03:58:47 <lambdabot> Int -> Bool
03:59:01 <sizur> but that's making a division
03:59:29 <Jafet> Implementation detail you shouldn't worry about.
03:59:38 <Jafet> (But which you do anyway!)
04:00:22 <arw> the difference in a modern processor between applying a bitmask and integer division is at most 1 cycle.
04:00:41 <arw> there is really more performance-eating stuff than that test.
04:01:04 <Jafet> It depends on the processor.
04:01:23 <sizur> agreed.  cannot think of an application where optimizing one cycle for even check will be required
04:01:57 <Jafet> Perhaps you meant "processors Haskell programs tend to get run on", which would indeed rule out micros, embeddeds and weird superscalars
04:02:08 <sizur> ok, maybe in number theoretic applications
04:02:34 <arw> Jafet: right. but the usual pentium/core/opteron/whatever stuff does int division in 1 cycle and bitmasks and stuff in 1 or 0 cycles in register transfer.
04:03:05 <arw> Jafet: on embedded architectures, division really hurts, there you might want to do that optimization.
04:03:45 <FliPPeh> @pl doEven n = (n * 3) + 1
04:03:45 <lambdabot> doEven = (1 +) . (3 *)
04:03:49 <sizur> so guys,  what's the current state of the art on rdbm interfaces for ghc-6.12.1?
04:04:16 <sizur> :t (1+)
04:04:17 <lambdabot> forall t. (Num t) => t -> t
04:04:19 <sizur> :t succ
04:04:20 <lambdabot> forall a. (Enum a) => a -> a
04:04:38 <FliPPeh> > let f = (/2) in f 5.0
04:04:39 <lambdabot>   2.5
04:05:23 <sizur> :t succ <$> (3*)
04:05:24 <lambdabot> forall a. (Enum a, Num a) => a -> a
04:05:31 <FliPPeh> > let f = (`div` 2) in f 5.0
04:05:32 <lambdabot>   Ambiguous type variable `a' in the constraints:
04:05:32 <lambdabot>    `GHC.Real.Integral a'
04:05:32 <lambdabot>   ...
04:05:35 <FliPPeh> > let f = (`div` 2) in f 5
04:05:36 <lambdabot>   2
04:06:09 <sizur> :t succ <<< (3*)
04:06:10 <lambdabot> forall b. (Enum b, Num b) => b -> b
04:11:35 <FliPPeh> @hpaste
04:11:36 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
04:12:08 <FliPPeh> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=8462#a8462
04:12:26 <FliPPeh> What would be a smart way to add the number the function was started with to the beggining of the list?
04:12:46 <FliPPeh> So for
04:12:47 <FliPPeh> *Main> collatz 10
04:12:48 <FliPPeh> [5,16,8,4,2,1]
04:12:59 <FliPPeh> I'd like [10, 5,16,8,4,2,1]
04:13:16 <FliPPeh> s/beggining/beginning
04:13:24 <FliPPeh> I feel ashamed.
04:13:28 <quicksilver> 10 : collatz 10
04:13:29 <quicksilver> ?
04:13:40 <FliPPeh> Without explicitly doing it myself :(
04:13:58 <Jafet> Plot twist
04:14:04 <ToRA> @pl (\x -> x : foo x)
04:14:04 <lambdabot> ap (:) foo
04:15:52 <FliPPeh> Well
04:15:56 <FliPPeh> I did it the obvious way
04:16:06 <FliPPeh> collatz n = n : collatz' n
04:17:06 <ToRA> but ap involves more hurting of brain! brain hurting is good for you! it's what makes learning haskell awesome!
04:17:21 <FliPPeh> :t ap
04:17:22 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
04:17:27 <FliPPeh> What's ap?
04:17:50 * ToRA stabs a guess at application under monad
04:19:46 <Jafet> @djinn (Monad m) => m (a -> b) -> m a -> m b
04:19:47 <lambdabot> -- f cannot be realized.
04:20:10 <FliPPeh> Maaan
04:20:10 <dobblego> ap is (<*>)
04:20:28 <FliPPeh> Haskell can calculate the collatz conjunction of  99999999999999999999999999999999999999999999 in under a second
04:20:51 <FliPPeh> With a list output
04:22:43 <medfly> bigger number doesn't mean moar work
04:22:45 <medfly> necessarily :)
04:23:00 <medfly> > 2^200
04:23:01 <lambdabot>   1606938044258990275541962092341162602522202993782792835301376
04:23:17 <sanxiyn> collatz?
04:23:21 <FliPPeh> Yes
04:23:29 <FliPPeh> http://xkcd.com/
04:23:40 <medfly> collatz conjecture
04:23:41 <FliPPeh> That basically gave me the idea to implement it in haskell
04:24:05 <medfly> http://en.wikipedia.org/wiki/Collatz_conjecture
04:25:12 <FliPPeh> 2^2000 transforms to 2001 calculation steps
04:25:13 <sanxiyn> Paul Erdos said about the Collatz conjecture: "Mathematics is not yet ready for such confusing, troubling, and hard problems."
04:25:26 <sanxiyn> That's quite interesting.
04:25:34 <FliPPeh> But why is it a hard problem?
04:25:53 <FliPPeh> Looks like something people would do when they're bored
04:26:01 <medfly> it's hard to prove it's true
04:26:01 <Jafet> That's also a hard problem.
04:26:04 <medfly> for every number...
04:27:14 <ToRA> > length $ takeWhile (/= 1) $ iterate (\x -> if even x then x `div` 2 else x * 3 + 1) (2 ^ 2000)
04:27:15 <lambdabot>   2000
04:27:22 <ToRA> oops, off by 1 error :s
04:27:36 <FliPPeh> Nah
04:27:40 <tallpaul> how to handle parsing a function application in parsec? If I have a rule like "Expr -> A | Expr Expr", what the approach?
04:27:41 <FliPPeh> I output it as a list
04:27:41 <int-e> > x^20
04:27:42 <lambdabot>   x * x * (x * x) * (x * x * (x * x)) * (x * x * (x * x) * (x * x * (x * x)))...
04:27:52 <FliPPeh> And the head of that list is the beginning number, ToRA
04:27:58 <FliPPeh> Thus I get n+1 results
04:28:18 <ToRA> FliPPeh: no, mine has an off by 1 error
04:28:27 <ToRA> it drops the last 1
04:28:32 <FliPPeh> :o
04:28:37 <sizur> > do{ succ <<< (3*) -< 1
04:28:37 <ToRA> > takeWhile (/= 1) $ iterate (\x -> if even x then x `div` 2 else x * 3 + 1) 12
04:28:38 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
04:28:38 <lambdabot>   [12,6,3,10,5,16,8,4,2]
04:28:56 <FliPPeh> > 5*x
04:28:57 <lambdabot>   5 * x
04:28:59 <sanxiyn> > takeWhile (/= 1) $ iterate (\x -> if even x then x `div` 2 else x * 3 + 1) 27
04:29:01 <lambdabot>   [27,82,41,124,62,31,94,47,142,71,214,107,322,161,484,242,121,364,182,91,274...
04:29:24 <ToRA> > let c x = takeWhile (/= 1) $ iterate (\x -> if even x then x `div` 2 else x * 3 + 1) x in map (length . c) [1..20]
04:29:25 <lambdabot>   [0,1,7,2,5,8,16,3,19,6,14,9,9,17,17,4,12,20,20,7]
04:29:32 <FliPPeh> :t iterate
04:29:33 <lambdabot> forall a. (a -> a) -> a -> [a]
04:31:04 <abum> Is there anything special you should consider with tail-recursion in the (State StdGen a) monad, so that you do not get a stack overflow?
04:31:34 <Saizan> as usual with tail recursion, you've to be strict in the right places
04:32:32 <Saizan> @wiki Stack overflow
04:32:32 <lambdabot> http://www.haskell.org/haskellwiki/Stack_overflow
04:32:41 <abum> Saizan: thanks I will look over the strictness see what happens.
04:32:47 <sizur> does anyone do any rdbm in ghc-6.12.1? if yes, what lib are you using? (sorry if i'm annoying)
04:34:16 <FliPPeh> @src iterate
04:34:16 <lambdabot> iterate f x =  x : iterate f (f x)
04:34:27 <FliPPeh> :/
04:35:50 <hallo_leute> http://www.facebook.com/photo.php?pid=3629610&id=266453492661
05:14:50 <kalven> > abs (-2147483648::Int)
05:14:51 <lambdabot>   2147483648
05:15:40 <kalven> abs (-9223372036854775808::Int)
05:15:49 <kalven> > abs (-9223372036854775808::Int)
05:15:50 <lambdabot>   -9223372036854775808
05:18:07 <benmachine> > abs minBound < 0 :: Int
05:18:08 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
05:18:08 <lambdabot>         against inferred type ...
05:18:12 <benmachine> > abs minBound < (0 :: Int)
05:18:13 <lambdabot>   True
05:30:10 <McManiaC>     Warning: `statusTypeGetPrimitive' is exported by `statusTypeGetPrimitive' and `statusTypeGetPrimitive'
05:30:13 <McManiaC> wtf?
05:56:24 <Jonno_FTW> @src min
05:56:24 <lambdabot> min x y = if x <= y then x else y
05:56:33 <Jonno_FTW> @src minimum
05:56:34 <lambdabot> minimum [] = undefined
05:56:34 <lambdabot> minimum xs = foldl1 min xs
05:57:39 <Robbb> I have a constructor "Foo String". Anyway to create "Foo x" where x is the result of an "IO String" function?
05:58:20 <Zao> Could you elaborate that question a bit more?
05:58:21 <Robbb> I can't seem to define a data type with IO monad in constructor, e.g. "Foo IO String"
05:59:27 <Robbb> Zao: I have a unique ID of type "IO String" (from Data.Unique). I have a Term datatype, with a constructor "Var String" and would like to create a variable based on a unique ID.
05:59:33 <Jonno_FTW> is there any way to apply the suggestions offered by hlint to a source file?
05:59:36 <Alpounet> do { s <- yourIOString ; return (Foo s) } -- you end up with an IO (Foo String) though
05:59:42 <Jonno_FTW> other than manually changing them
06:00:02 <Zao> data Omg = Omg (Wtf Bbq)
06:00:03 <pozic> Robbb: IO is an incomplete type.
06:00:20 <pozic> Robbb: IO is a type constructor, not an actual type.
06:00:45 <pozic> Robbb: Foo IO String, means that IO is a field of Foo, but we just established that that denotes nonsense.
06:01:03 <Zao> Robbb: What you're trying to do is something like   data Omg = Omg Wtf Bbq , that is, a ctor with two fields.
06:01:03 <Robbb> pozic: Ok. I know I can lift to type "IO Term"...
06:01:10 <Zao> One of type Wtf and one of type Bbq.
06:01:26 <pozic> Robbb: I suggest you read a few good books on Haskell before going further.
06:02:12 <pozic> Robbb: or just write whatever you want in another common formal language or pseudo-code and ask how it should look like in Haskell.
06:02:30 <Robbb> The other option is to pass around complex state monads to all of my functions.
06:02:44 <Robbb> I am looking for a simpler way to obtain a unique id
06:02:45 <Zao> Robbb: You cannot extract the result of an IO action without being in IO.
06:03:10 <Zao> (in any way that does not summon the Deep Ones)
06:03:11 <pozic> Robbb: think of the IO monad as a way to construct actions that might someday do something.
06:03:28 <pozic> Robbb: and the only way to do things is via actions.
06:03:38 <pozic> Robbb: then immediately your question becomes nonsensical.
06:03:46 <Zao> Robbb: Use a pure UUID generator?
06:03:56 <Zao> If there is such a thing.
06:04:08 <Robbb> Is there a pure UUID generator for Haskell?
06:04:17 <pozic> Robbb: no.
06:04:37 <pozic> Suppose it is pure, then it would not create unique ids in a distributed fashion.
06:04:51 <pozic> So, it would not be a UUID generator.
06:05:07 <benmachine> depends what you mean by pure
06:05:09 <pozic> Or, it would be impure.
06:05:14 <benmachine> you could have a seeded State sort of thing
06:05:36 <benmachine> oh but you don't want "complex state monads"
06:05:42 <Robbb> I just want something that generates unique values for each run.
06:05:42 <benmachine> but, State is not complex :P
06:06:05 <Zao> Define "run".
06:06:22 <benmachine> pure functions always return the same values for the same input
06:06:23 <Robbb> Each run of the function. Initial value of 0 and successor is good enough.
06:06:32 <pozic> Robbb: so, you do the following: do x <- something_creating_a_unique_value; return (eat_your_heart_out x)
06:06:40 <benmachine> so if you want different runs to return different values, you need different inputs
06:06:52 <benmachine> but those can be hidden conveniently away in a monad structure
06:07:02 <pozic> Robbb: eat_your_heart_out will have type Some_uuid -> WhatEverYouWant.
06:07:30 <McManiaC> is it possible to use GDB with haskell and the FFI?
06:07:33 <Robbb> Everything gets lifted to IO
06:08:23 <benmachine> sooort of
06:08:30 <benmachine> but not really
06:08:41 <benmachine> you write pure functions that operate on uuid values
06:08:53 <benmachine> and then you use them to operate on IO UUIDs
06:09:15 <pozic> Robbb: it is in IO for a reason, obviously.
06:09:26 <Robbb> How do I have a constructor that contains an IO?
06:09:39 <benmachine> :t Just getLine
06:09:40 <lambdabot> Maybe (IO String)
06:09:41 <Robbb> Is it possible to have a constructor "Foo x" where x is in IO String ?
06:09:47 <benmachine> but that's not really what you want
06:09:56 <pozic> Robbb: you are not making a lot of sense.
06:10:04 <Alpounet> I think you rather want something close to : do { s <- yourIOString ; return (Foo s) } -- you end up with an IO (Foo String)
06:10:22 <pozic> Robbb: Foo x is not a constructor. Foo is.
06:10:43 <benmachine> Alpounet: or, Foo <$> yourIOString :P
06:11:22 <Alpounet> benmachine, yeah, not sure it would be easier to understand for him though
06:11:47 <Robbb> I understand what it means.
06:19:44 <jeromo> hi
06:19:59 <jeromo> my program just crashed with 'division by zero' and I have no idea where this occurs
06:20:06 <jeromo> is there a systematic way of finding out?
06:20:17 <medfly> what is dividing?
06:20:20 <medfly> ;)
06:20:35 <jeromo> division occurs in many different places
06:22:00 <medfly> might be something people only do in like imperative languages but you could put an if at each division and if you're about to divide by 0, print a message that lets you identify the location...
06:22:02 <medfly> :o
06:22:31 <jeromo> ok, I was hoping for some development tool that does that automatically
06:22:40 <medfly> oh, I don't know about many tools
06:22:45 <medfly> sorry, maybe someone else does
06:25:31 <ddarius> jeromo: There's a debugger in GHCi and also the profiling mechanism can be abused to produce "stack traces" of sorts.
06:25:53 <ddarius> There are also more heavy-weight debugging tools.
06:30:04 <ToRA> it's possible that turning on hpc and then looking at the marked up code coverage could also reveal where the div by zero occured if it was on a critical path
06:31:13 <ToRA> ghci debugger with :set -fbreak-on-exception is probably your best bet tho
06:45:37 <McManiaC> can you compile .hc files with gcc?
06:46:40 <Robbb> I have a function of type [T] -> T. Is there an easy way to "lift" it to [IO T] -> IO T ?
06:47:51 <Robbb> ?
06:48:24 <ddarius> :t fmap . sequence
06:48:26 <lambdabot> forall a (f :: * -> *) a1. (Functor f) => [a -> a1] -> f a -> f [a1]
06:48:42 <ziman> :t let f = head in fmap f . sequence
06:48:43 <lambdabot> forall a (f :: * -> *). (Functor f, Monad f) => [f a] -> f a
06:49:11 <ddarius> :t \f -> fmap f . sequence
06:49:12 <lambdabot> forall b (f :: * -> *) a. (Functor f, Monad f) => ([a] -> b) -> [f a] -> f b
06:49:29 <ziman> @pl \f -> fmap f . sequence
06:49:29 <lambdabot> (. sequence) . fmap
06:49:51 <ddarius> or s/fmap/liftM if you want to avoid the Functor constraint
06:55:57 <McManiaC> what do you need to compile a .o file (generated by ghc -c) with gcc?
06:56:02 <McManiaC> what libs/cflags?
06:56:53 <aleator> Hi! I tried playing with llvm bindings and got  user error (Unable to find target for this triple (no targets are registered))
06:57:40 <aleator> Google said that someone pasted this same question on hpastetwo lately, also.
06:59:52 <Robbb> liftM , f doesn't seem to be working
07:00:52 <edwardk> @type liftM (,)
07:00:53 <lambdabot> forall a1 b (m :: * -> *). (Monad m) => m a1 -> m (b -> (a1, b))
07:01:08 <quicksilver> I don't believe that's what Robbb wants.
07:01:13 <quicksilver> break the problem down, Robbb
07:01:22 <quicksilver> sequence takes you from [IO T] to IO [T]
07:01:31 <edwardk> quicksilver: i was just trying to see what it was he was saying typed out as ;)
07:01:49 <quicksilver> then fmap or liftM lets you apply a function ([T] -> T) 'under the IO'
07:01:49 <Robbb> (liftM . f) . sequence
07:02:13 <quicksilver> simply (liftM f) . sequence
07:02:20 <Robbb> I have f: [T] -> T and want f': [IO T] -> IO T
07:02:20 <quicksilver> if I correctly understand what your F is.
07:03:00 <edwardk> fmap `fmap` f `fmap` sequence ? =)
07:03:23 <Robbb> edwardk: what?
07:03:28 <edwardk> er wait that was your version, nevermind
07:03:53 <edwardk> Robbb: i'm just mechanically expanding your definition using (.) as fmap, ignore me ;)
07:04:03 <edwardk> Robbb: my statement was less than helpful
07:05:12 <Robbb> so (liftM.f).sequence should give me a function from [IO T] to IO T ?
07:06:07 <RayNbow> :t \f -> fmap fmap fmap f sequence
07:06:08 <lambdabot> forall b (m :: * -> *) a. (Functor m, Monad m) => ([a] -> b) -> [m a] -> m b
07:06:41 <zygoloid> @type flip (liftM liftM liftM) sequence
07:06:42 <lambdabot> forall r (m :: * -> *) a. (Monad m) => ([a] -> r) -> [m a] -> m r
07:08:35 <quicksilver> Robbb: No.
07:08:48 <quicksilver> Robbb: as I already said, you want (liftM f) . sequence
07:09:01 <quicksilver> Robbb: I also explained how to break it down so you can follow the reasoning.
07:10:58 <pozic> What is a reasonable salary for a full-time Haskell position including medical benefits and so on?
07:12:41 <Robbb> Ok, I have a consturctor Term that takes an argument of type T. I have a value t of type IO T. How do I return a value of IO (Term t') where t' is the T component of IO T.
07:13:09 <Robbb> must've been a typo. (liftM f).sequence now works.
07:13:29 <Robbb> But again, I am the issue with a constructor now.
07:13:52 <edwardk> pozic: depends a lot on education, experience, location, etc. there is no one size fits all answer to that
07:18:28 <pozic> edwardk: what about a few data points?
07:20:42 <BONUS> haskell programmers are paid in lambda
07:20:43 <BONUS> s
07:22:06 <Tinned_Tuna> BONUS: yes.
07:22:56 <malcolmw> pozic: I know of some Haskell programmers whose total annual compensation is almost certainly in excess of £100,000
07:22:56 <lambdabot> malcolmw: You have 1 new message. '/msg lambdabot @messages' to read it.
07:23:23 <pozic> malcolmw: wow. Financial people? Where did they get that experience in the first place?
07:24:09 <malcolmw> pozic: banks pay well, especially if your skillset is a rarity
07:24:54 <pozic> malcolmw: all I see banks looking for is Java positions doing stupid work that everyone can do.
07:25:16 <pozic> malcolmw: I saw one ad a few years ago for an OCaml position on the other side of the planet.
07:25:42 <quicksilver> pozic: e.g. http://jobs.reuters.efinancialcareers.co.uk/job-4000000000602450.htm
07:25:54 <jd10> pozic: jsc?
07:26:25 <quicksilver> but you generally don't get these jobs without > 2 years experience in banking
07:26:34 <malcolmw> pozic: on the other hand, if you count a PhD position as "full time Haskell", you could be earning more like £16,000 per annum, but it is tax free and you have lots of flexibility
07:30:07 <tallpaul> Hi folks, i've a question that is not direct related to haskell: If I have a left-recursive grammar like "E -> EE | var" (fun app) and I want to use it with a LL-Parser, I have to remove left-rec: "E -> var T ; T -> ET | empty". Now, how can I get this grammer left-associative?
07:35:17 <mm_freak> say i've got a C library, which uses GMP
07:35:23 <mm_freak> can i use it from haskell using GHC?
07:36:30 <shepheb> for your amusement/horror. today the token "just doesn't get it" guy in my 4th-year theory of programming languages class asked today, immediately after the professor had illustrated do-notation in our unit on Haskell, "How is do different from let?"
07:37:09 <shepheb> the gentleman will eventually scrape together enoug credits to graduate with a degree the same as mine.
07:37:55 <Zao> Hopefully the heat death of the universe occurs beforehand.
07:38:45 <medfly> huh?
07:39:25 <medfly> it is a bit like let, isn't it?
07:41:25 <theorbtwo> Well, do isn't, so much as <- is, no?
07:41:38 <theorbtwo> :t (<-)
07:41:39 <lambdabot> parse error on input `<-'
07:41:59 <theorbtwo> :info (<-)
07:42:10 <theorbtwo> ...or not.
07:42:36 <Woof> @info (<-)
07:42:36 <lambdabot>  Parse error at "<-)" (column 2)
07:42:43 <Woof> @info <-
07:42:43 <lambdabot>  Parse error at "<-" (column 1)
07:44:46 <geheimdienst> guys, i have another newbie monad question ... i *thought* this program should work, but it doesnt: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23249#a23250
07:45:13 <andgra> Hi, does 'if then else' in a do block behave any different then a 'if then else' in a 'normal' block of code?
07:45:31 <andgra> like, always evaluating both branches....
07:46:39 <geheimdienst> andgra, have any concrete code that's not working?
07:54:36 <bitstream0101> I have a Monad m => Data.Map k (m v), and would like to turn this into m (Data.Map k v).  What's the easiest way to go about this? Or, said another way, is there a library function somewhere that does something like (a, m b) -> m (a, b)?
07:57:10 <geheimdienst> bitstream0101, have you had a look at Prelude.sequence yet?
07:57:15 <geheimdienst> should be close
07:57:57 <bitstream0101> Yeah, but I was hoping for something that would sequence over a particular tuple element (say, 2nd, in this case)
07:58:29 <bitstream0101> i mean, I could do something like mapM (\(x,act) -> act >>= return . (,) x)
07:59:56 <bitstream0101> I was just wondering if this was a common pattern, e.g. going from a key/monadic action map/alist to a monadic key/result
08:00:21 <bitstream0101> er, to a monadic key/result (map/alist)
08:23:05 <zygoloid> @instances-importing Data.Traversable Data.Map Traversable
08:23:06 <lambdabot> Map k, Maybe, []
08:23:12 <zygoloid> @type Data.Traversable.sequence
08:23:13 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (Data.Traversable.Traversable t, Monad m) => t (m a) -> m (t a)
08:23:46 <zygoloid> @type Data.Traversable.sequence :: Monad m => Data.Map.Map k (m v) -> m (Data.Map.Map k v)
08:23:47 <lambdabot> forall k (m :: * -> *) v. (Monad m) => M.Map k (m v) -> m (M.Map k v)
08:23:54 <zygoloid> bitstream0101: ^^
08:24:03 <andgra> hi, I have a recursve call in a do-bolock in function of type 'fun:: Int -> [a] -> State StdGen [a]' the recursive call looks like 'ts <- fun (n-1) xs; return $ x : ts' but the program hangs - as if in an ifinite loop
08:24:26 <zygoloid> andgra: do you have a base case for fun 0 or fun 1 or similar?
08:24:56 <andgra> ofcouse, fun 0 _ = return []
08:25:13 <zygoloid> do you define that earlier in the file than your 'fun n' case?
08:25:20 <andgra> yes
08:25:50 <zygoloid> ok, that's the obvious things handled then. can you post your code on hpaste.org?
08:27:12 <zygoloid> > runState (let fun 0 _ = return []; fun n xs = do ts <- fun (n-1) xs; return $ x : ts in fun 10 [1,2,3]) 42
08:27:13 <lambdabot>   ([x,x,x,x,x,x,x,x,x,x],42)
08:27:57 <zygoloid> ^^ the fragments you've given so far work by themselves; it's probably something else in the code which is causing the problem
08:30:24 <andgra> it's here, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23252#a23252
08:31:46 <andgra> the 'pass' funtion is sort of a dummy - but it's like it won't recurse throuh the list..
08:33:05 * hackagebot HJavaScript 0.4.7 - HJavaScript is an abstract syntax for a typed subset of JavaScript.  http://hackage.haskell.org/package/HJavaScript-0.4.7 (NiklasBroberg)
08:33:32 <geheimdienst> andgra, is there any possibility that in evolve, the length function could return something negative?
08:33:46 <jmcarthur> that seems highly unlikely
08:33:55 <jmcarthur> @src length
08:33:55 <lambdabot> Source not found. My brain just exploded
08:34:05 <andgra> no, we have tried it with a fixed value actually - so that does not seams to be the problem
08:36:15 <zygoloid> is it definitely getting to 'pass'?
08:36:34 <jmcarthur> yeah i am kind of wondering more about the population gen part
08:36:41 <zygoloid> the 'population gen' computation could hang. i suppose it could even hang the nth time it's invoked in principle...
08:37:00 <zygoloid> what's in the 'population' value in gen?
08:37:22 <djahandarie> Oh god I'm going to lecture about finding rigorous bound for heuristic search with quantum computing
08:37:29 <djahandarie> And I know like nothing about quantum computing
08:37:41 <zygoloid> djahandarie: how'd you get suckered into that? :)
08:37:43 <djahandarie> I'm trying to read some stuff on it now and it is a lot of stuff
08:38:03 <djahandarie> Just a damn endless chain of papers pointing to each other
08:38:13 <djahandarie> zygoloid, dunno, sounded interesting haha
08:38:22 <djahandarie> Oh wow
08:38:27 <djahandarie> Not "to lecture"
08:38:31 <djahandarie> "to a lecture"
08:38:33 <djahandarie> hahaha
08:38:40 * djahandarie sighs
08:39:01 <zygoloid> that makes ... considerably more sense :D
08:39:36 <zygoloid> Scott Aaronson's blog makes for good reading on such things
08:39:43 <djahandarie> That's what I'm reading
08:39:49 <djahandarie> Along with some of his slides and papers
08:39:54 <zygoloid> but reading it will eat your entire afternoon :)
08:41:09 <moshisushi> hello i get "user error: RTS doesn't support multiple OS threads (use ghc -threaded when linking)" when using ForkOS
08:41:23 <moshisushi> ofcourse, i tried ghc -threaded when compiling
08:41:31 <moshisushi> but the problem remains
08:41:40 <shortcircuit> djahandarie: That's not an endless chain, it's a toroidal graph.
08:42:04 <benmachine> moshisushi: try -fforce-recomp?
08:42:13 <benmachine> actually that's probably not necessary
08:42:16 <benmachine> but try it anyway :P
08:43:17 <moshisushi> benmachine: worked, thanks!
08:43:22 <moshisushi> ah damn
08:43:35 <moshisushi> --make is actually make :D
08:43:43 <jmcarthur> djahandarie: hahaha
08:43:53 <moshisushi> so since my executable was built, no linking was done
08:44:01 <benmachine> mm
08:44:13 <djahandarie> shortcircuit, and I'm currently in the process of doing a random walk on it
08:44:16 <benmachine> I thought it had some clever tricks to rebuild when necessary, but I guess not >_>
08:44:49 <djahandarie> Or a "coordinate loop" whatever that is
08:45:20 <djahandarie> Apparently it mixes faster and has fewer self-interesections than a random walk
08:46:09 * shortcircuit wants to set up some graph-type tasks on Rosetta Code. Maybe start with a common structure task, and have a bunch of search and generation tasks refer back to it.
08:46:26 <shortcircuit> Last night's XKCD got me thinking again. >.>
08:48:27 <Phyx-> hrm... is happy still maintained? building it gives alot of warnings
08:50:54 <bitstream0101> zygoloid: Just saw the Traversable stuff; thanks muchly :)
08:55:53 <jmcarthur> Phyx-: iirc, happy has always had lots of warnings
08:57:51 <Rayne> what is recommended to use: "ismember x xs = any (\y-> x==y) xs" OR "ismember x xs = any (==x) xs"
08:58:14 <Phyx-> jmcarthur: sure but alot of them are "Warning: Defined but not used"
08:58:19 <Phyx-> shouldn't that be cleaned up
08:58:37 <doserj> @src elem
08:58:38 <lambdabot> elem x    =  any (== x)
08:58:51 <Phyx-> and alot of deprecation warnings
09:00:23 <Rayne> doserj, just as an example - most functions i have to write are yet implemented
09:01:26 <Rayne> but i wonder if i should use \y -> x==y annotations or just write ==x (best practise, etc.)?
09:01:31 <doserj> Rayne, if you are learning, use whatever you find easier to understand
09:01:54 <Rayne> okay :)
09:01:58 <Igloo> Note that (\y -> x == y) is (x ==), not (== x), though
09:02:38 <Rayne> Igloo, but it seems to work both because of infix and prefix notation (or it works only in the cases i use it?)
09:02:55 <dschoepe> Igloo: for any sane instance of Eq they are equivalent though
09:03:49 <Igloo> Yes, it shouldn't matter for (==), I was just highlighting that they aren't actually the same
09:04:11 <zygoloid> my intuition is that (x==) would be marginally faster than (==x). anyone know if that's right or should i grab a copy of criterion? :)
09:04:21 <Rayne> Igloo, thanks for that hint
09:06:34 <quicksilver> zygoloid: I wouldn't expect a difference as long as everything inlines.
09:07:00 <quicksilver> zygoloid: but you can certainly imagine Eq instances where (y==x) is slower than (x==y) for certain particular choices of x and y
09:07:20 <quicksilver> tree-shaped structures where your order of traversal is biased by the structure of the left parameter
09:10:19 <zygoloid> when everything inlines they seem to compile to identical code
09:19:58 <edwardk> zygoloid: the main argument for using (x==) would be that you don't wind up with that little stack frame saying to flip the arguments around, you just have a partial application
09:20:15 <quicksilver> edwardk: yes, but that doesn't matter if it all inlines
09:20:22 <dantheman99> Hey, I'm trying to write a gui (on windows vista) with haskell/gtk2hs/glade, but ghci can't seem to find the glade module Graphics.UI.Gtk.Glade, does anyone have any ideas
09:20:27 <edwardk> yeah that was going to be my next point ;)
09:20:49 <edwardk> the difference if it exists at all will be negligible.
09:21:02 <zygoloid> edwardk: right. if it all inlines GHC generates identical code at the asm level. otherwise yeah, the difference would be that tiny frame, which is the source of my intuition
09:21:38 <quicksilver> unless, as I pointed out, your Eq instance is fundamentally time-asymmetric
09:22:17 <zygoloid> sure. but in that case neither of (==x) and (x==) is inherently better, independent of x
09:23:14 * quicksilver nods
09:23:21 <gwern> bleh. the > convention in markdown is so broken
09:23:43 <quicksilver> elegant simple solutions to hard problems always fail
09:23:53 <quicksilver> yaml and markdown are good examples of the trend
09:24:06 <quicksilver> "this problem has been made too hard, I can make it simpler...
09:24:16 <quicksilver> ...oh but I missed this case, and this case, and this case...
09:24:25 <quicksilver> ... let's just nail a bit on here, and cut a bit off there....
09:24:48 <djahandarie> 12:38 < quicksilver> elegant simple solutions to hard problems always fail
09:24:52 <gwern> and * and ** are pretty broken too
09:25:01 <djahandarie> That's a simple and elegent answer to a complex question!
09:25:01 <gwern> but I hardly ever use bold so it doesn't really matter
09:25:52 <benmachine> imo hard problems are quite often easy problems with hard bits that most people don't care about
09:25:58 <dantheman99> Has anyone even tried to install haskell/gtk2hs/glade on windows?
09:26:00 <benmachine> which is why markdown is a good idea
09:26:39 <gwern> well, it certainly beats TeX
09:27:23 <quicksilver> dantheman99: I suspect quite a lot of people aren't using windows.
09:27:34 <quicksilver> dantheman99: you may need to wait for a friendly windows haskeller to drift past
09:28:37 <gwern> what haskellers would use windows? you'd want to commit suicide on a daily basis
09:29:02 <sioraiocht> lol, that should definitely be recorded somewher
09:29:04 * RayNbow raises hand :p
09:29:40 <benmachine> committing suicide on a daily basis is quite difficult
09:29:41 <dantheman99> Hah, I thought not. Unfortunately I have to at the moment.
09:30:02 <luite> benmachine: wanting to commit suicide isn't :p
09:30:09 <gwern> benmachine: that's how awful windows is
09:30:14 <gwern> just one suicide isn't enough
09:30:47 <gwern> ('windows: bet you can't kill yourself just once')
09:31:05 <dantheman99> is there any reason why gtk2hs etc can't be installed using cabal?
09:31:33 <medfly> gwern, I use windows on my sister's laptop...
09:31:45 <medfly> it beats not having a computer :)
09:31:51 <gwern> dantheman99: yes. too darn difficult, too many system-specific things
09:32:04 <dantheman99> Ah, ok.
09:32:08 <gwern> dantheman99: gtk2hs generates cabal packages actually
09:32:10 <djahandarie> medfly, why not just carry around a linux usb stick?
09:32:19 <medfly> I don't have a usb stick?
09:32:27 <medfly> :p
09:32:29 <gwern> medfly: why not? they're like 5 or 10 dollars
09:32:38 <gwern> it'd pay for itself in a few hours
09:32:41 <medfly> I dunno. I just don't have one
09:33:10 <dantheman99> Ok, I guess I'm going to have to try and build it all from source ... sigh
09:33:43 <hotaru2k3> the last time i had one of those cheap usb sticks it died after about a week
09:34:25 <jmcarthur> same here
09:34:42 <jmcarthur> but admittedly that one came from walmart
09:35:05 <jmcarthur> and was due to inserting it into a device that was ungrounded but probably shuld have been
09:35:14 <jmcarthur> *should have been grounded
09:35:58 <jmcarthur> stilled sucked though because i had been using it to hold key material for my encrypted hard drive
09:36:09 <jmcarthur> thank god for LUKS and multiple keys
09:36:25 <chrisdone_> guys, I have ice cream in a cone
09:36:27 <chrisdone_> what do you have?
09:36:31 <chrisdone_> nothing
09:36:37 <jmcarthur> an americano
09:36:38 <benmachine> I have biscuits
09:36:48 <benmachine> so many biscuits
09:36:57 <chrisdone> custard cream?
09:37:01 * jmcarthur wants biscuits more than he want ice cream
09:37:55 <benmachine> custard creams kind of suck
09:38:07 <benmachine> they're kind of cool but also sucky both at the same time
09:38:25 <benmachine> so I don't buy them
09:48:18 <Phyx-> lol, the haskell online interpreter is funny
09:48:25 <Phyx-> > let f = 8 in f * f
09:48:26 <Phyx-> Time limit exceeded.
09:48:27 <lambdabot>   64
09:48:45 <Phyx-> must have a really low timeout value
09:49:27 <kw317> I'm trying to install criterion, but I hit this issue: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23255#a23255 and trying to upgrade array gives me: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23256#a23256
09:49:31 <kw317> :S
09:54:27 * hackagebot sync 0.1 - A fast implementation of synchronous channels with a CML-like API  http://hackage.haskell.org/package/sync-0.1 (NeilBrown)
09:54:38 <zachk> ok i do cabal update. says there is anew cabal-install and to run cabal instal cabal-install. i do that. then do cabal update again. and it still says there is a new version of cabal-install. what gives
09:55:53 <MaciejP> kw317: Try to download array and fix base >=3 to >=4.
09:56:17 <c_wraith> zachk: probably a path issue.  It's installing the new cabal to ~/.cabal/bin
09:56:33 <c_wraith> zachk: and that's probably not what "which cabal" will report to you
09:56:56 <zachk> c_wraith im on windows so how do i do which cabal
09:57:15 <c_wraith> zachk: oh, I don't know how to do that on windows.
09:57:47 <Alpounet> zachk, what does "cabal --version" return ?
09:58:17 <Alpounet> anyway, you just have to add .cabal/bin/ to your PATH
09:58:24 <Alpounet> (don't know where it is on Windows, though)
09:58:35 <Alpounet> so that you'll have your new cabal in the PATH
09:58:44 <Alpounet> just rename the old one, or so, and you should be fine
09:58:49 <zachk> cabal-install 0.6.2 using version 1.6.0.3 of the cabal library
09:58:56 <Alpounet> zachk, ok, that's the old one
09:59:01 <Alpounet> see what I wrote above
09:59:05 <Alpounet> and if it still doesn't work
09:59:21 <Alpounet> you should ask on haskell-cafe@, there are some Windows haskellers hanging around there
09:59:44 <mapreduce> Which of Windows and OS X would Haskell be least awkward on?
10:00:17 <c_wraith> OS X
10:00:26 <c_wraith> You at least have bash. :)
10:00:35 <Phyx-> zachk: I wild stab in the dark here, but are you running the command in the same folder as the old cabal? then it's given preference over the one on your path
10:00:37 <c_wraith> (or whatever shell you desire)
10:00:54 <Phyx-> or if the old one is earlier in your path it'll be given preference aswell
10:01:08 <zachk> im checking my path atm
10:01:37 <mapreduce> c_wraith: I have bash on Windows too, via all 3 of msys, cygwin and (msys again) Git Bash.
10:01:42 <c_wraith> it does require a bit of work to get ghc 6.10 working on osx 10.6, though.
10:01:59 <mapreduce> I see.
10:02:26 <c_wraith> mapreduce: I figure anyone who knows how to use cygwin (or any of those others) isn't going to ask that question
10:02:45 <c_wraith> mapreduce: they'll just make it work everywhere. :)
10:03:34 <mapreduce> Well, I've had difficulties just on Linux before, because of a screwed up gcc installation (I was not root).
10:03:43 <mapreduce> difficulties with ghc, that is.
10:04:22 <c_wraith> I suppose there's only so much you can do when a system-wide bit is screwed up
10:04:35 <c_wraith> (and you don't have permission to fix it)
10:05:16 <nostrand> uh, i only have GHC 5 att school =/. 6.8 is broken
10:05:22 <mapreduce> I documented the experience at the time: http://rickyclarkson.blogspot.com/2008/09/irc-bot-in-haskell-20-code-80-grr.html
10:06:07 <mapreduce> c_wraith: Sure.  Though it has to be said that other languages I use (Scala, Java, C#) don't seem to be screwed up by things like that as easily.
10:06:08 <zachk> got it working
10:06:24 <zachk> i had 4 cabals , and like 2 on some "magic" paths
10:07:03 <c_wraith> mapreduce: yeah, those languages are more standalone.  GHC is kind of tied to the OS more than those, at the moment.
10:07:40 <tensorpudding> ghc 5? that's oooold
10:07:46 <nostrand> tensorpudding: yep =(
10:08:18 <mapreduce> c_wraith: A bit off-topic, but I'd love to be able to 'install' packages as a normal user, for that user, without having to fiddle with ./configure, make --prefix=~/local, make install for everything I use, i.e., user-level package management.
10:09:20 <tensorpudding> cabal does that by default
10:09:39 <c_wraith> Sure, but he meant everything.  Not just haskell.
10:10:41 <tensorpudding> everything?
10:10:54 <medfly> EVERYTHING!!!!!
10:11:10 <c_wraith> Well, maybe not a kernel.  :)
10:11:11 <tensorpudding> a lot of programs require being installed outside of a user's home directory for a variety of reasons
10:11:26 <c_wraith> or anything that has to run as root
10:11:41 <c_wraith> but that still leaves a lot of software
10:12:26 <mapreduce> Bah, if you install a kernel as a user it should, erm, create a VM. :)
10:14:12 * c_wraith checks to see if there are any kernel updates for his VM running on his friend's system
10:14:34 <tensorpudding> install a VM in what?
10:14:53 <c_wraith> tensorpudding: I think that may have been a joke. ;)
10:15:44 <mapreduce> tensorpudding: VirtualBox or something.
10:15:52 <mapreduce> But yes, I was not serious.
10:17:18 <c_wraith> hey, look, I'm installing a new kernel as a user on a friend's box.  In the VM I control.  :)
10:19:41 <c_wraith> err.  I'm connected to this irc server via that box.  Guess I'm gonna bounce, while I reboot it.  >_>
10:20:57 <c_wraith> right.  VMs boot fast. :)
10:52:09 <jonp> have the semantics of `quot` & co. changed between GHC 6.8.2 and 6.12.1?
10:52:19 <jonp> as I have a question about their semantics, but i've only tested on 6.8.2
10:53:40 <Twey> jonp: I don't believe so
10:53:54 <BONUS> i think quot is part of H98?
10:54:00 <Twey> Aye
10:54:10 <jonp> so, my question is simple: the definitino of `quot` (as per http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.2.0.0/Prelude.html)
10:54:25 <jonp> `quot` is "integer division truncated toward 0
10:54:36 <jonp> while `div` id "integer division truncated toward -infinity
10:54:43 <Phyx-> hmm, do GHC macros cross module boundaries?
10:54:48 <jonp> yet, for both operators, -5 OP 3 gives the same value
10:54:55 <SamB_XP> Phyx-: macros ?
10:55:08 <Phyx-> SamB_XP: #define ...
10:55:16 <SamB_XP> Phyx-: of course not
10:55:18 <jonp> -5.0/3.0 is -1.6, so when truncating "toward 0", i'd expect -1, while "truncating toward -inf", i'd expect -2, no?
10:55:23 <Twey> jonp: Um, not here it doesn't
10:55:28 <Phyx-> SamB_XP: lol, just wondering :P
10:55:32 <Twey> That's what I get in 6.12.1
10:55:35 <jonp> Twey: which version?
10:55:59 <jonp> so i'm trying to think/find of some values for which `div` and `quot` behave differently
10:56:00 <SamB_XP> it's just like CPP, only it's altered very slightly so that it doesn't make a mess of our Haskell code
10:56:30 <Twey> Oh, wait — sorry, I read mod instead of quot
10:56:35 <Phyx-> SamB_XP: ok, thanks
10:56:39 <jonp> np
10:56:50 <jonp> i'm just not seeing why Haskell has both when apparently they're identical...
10:57:01 <jonp> or i'm an idiot (always an option)
10:57:08 <doserj> > ((-5) `quot` 3, (-5) `div` 3)
10:57:09 <lambdabot>   (-1,-2)
10:57:29 <jonp> ah, i wasn't using parens!
10:57:44 <jonp> '-5 `div` 3'  isn't '(-5) `div` 3'
10:57:48 <Twey> Ah, that old chestnut… yuck
10:57:52 <jonp> how...odd.
10:57:53 <benmachine> good old unary minus
10:57:54 <SamB_XP> > -5 `divMod` 3
10:57:55 <lambdabot>   No instance for (GHC.Num.Num (t, t))
10:57:55 <lambdabot>    arising from a use of syntactic neg...
10:58:02 <SamB_XP> > (-5) `divMod` 3
10:58:03 <lambdabot>   (-2,1)
10:58:07 <Twey> Wish we'd get whitespace-sensitive operators already.
10:58:09 <SamB_XP> that *is* odd
10:58:14 <BONUS> i like using negate instead of unary -
10:58:16 <jonp> what's the precedence of unary minus?!
10:58:18 <benmachine> > (-5) `quotRem` 3
10:58:19 <lambdabot>   (-1,-2)
10:58:24 <BONUS> cause unary - is weird
10:58:26 <Twey> Yeah, I usually end up using negate nowadays
10:58:27 <jonp> indeed
10:58:27 <benmachine> it's such that -x^2 works
10:58:29 <jonp> didn't know that.
10:58:32 <Twey> jonp: It's hard to say, I think
10:58:37 <jonp> well, that explains a lot then. :-)
10:58:40 <SamB_XP> Twey: well, or include adjacent - signs in the literal
10:58:41 <BONUS> > negate 5 `div` 3
10:58:42 <lambdabot>   -2
10:58:45 <SamB_XP> or SOMETHING
10:58:46 <Twey> SamB_XP: That's the point
10:58:54 <SamB_XP> of course, that still leaves -x
10:58:55 <jmcarthur> benmachine: there are two ways that -x^2 could work :P
10:59:01 <benmachine> jmcarthur: true
10:59:12 <Twey> Whitespace sensitivity means that (-3) can be negate 3, while (- 3) can be subtract 3
10:59:14 <benmachine> but it works in the way that gets you a negative number
10:59:28 <jmcarthur> > -2^2
10:59:29 <lambdabot>   -4
10:59:37 <jmcarthur> ah, so -(2^2)
10:59:39 <c_wraith> I think haskell probably shouldn't have unary -
10:59:40 <benmachine> just like in maths
10:59:42 <Twey> I'm willing to suffer ‘negate x’ for a unary minus that behaves sensibly
10:59:46 <SamB_XP> c_wraith: I have to agree
10:59:55 * doserj would remove unary -. -3 is just a literal.
10:59:56 <benmachine> I think I agree with Twey
11:00:03 <jonp> Twey: thank you for your help.
11:00:08 <SamB_XP> but it really seems like it would be nice if we could have something that looked sorta like a - that WAS unary
11:00:15 <benmachine> not sure whether -3 should be negate or subtract 3
11:00:27 <benmachine> I think that
11:00:35 <Twey> benmachine: Definitely negate
11:00:44 <benmachine> the language that people want when learning haskell
11:00:52 <benmachine> is different from the language that they want when using haskell
11:01:03 <BONUS> yeah, exactly
11:01:10 <Twey> (whitespace sensitivity also hugely expands our identifier space)
11:01:13 <Twey> benmachine: Yeah
11:01:16 <SamB_XP> ben: but we'll still want to write negative literals ;-P
11:01:21 <BONUS> like when you know haskell you want (.) = fmap and (++) = mappend
11:01:29 <BONUS> but when you're learning it, it would confuse the heck out of you
11:01:30 <benmachine> SamB_XP: yeah I think so
11:01:38 <benmachine> -XIKnowWhatImDoing
11:01:42 <benmachine> -XIKnowWhatI'mDoing
11:01:46 <BONUS> haha
11:01:49 <Twey> I've proposed before, semi-seriously, that specialised functions like (++) and map should be in a Prelude.Newbie module
11:01:51 <BONUS> -XNoob
11:02:03 <benmachine> yeah I could get behind that
11:02:06 <edwardk> personally i'm fond os saying -123890 is a single lexeme that happens to be negative,
11:02:12 <Twey> That gets imported automatically unless you pass a flag to stop it :þ
11:02:20 <SamB_XP> hmm, the apostrophe would be a pain in the shell :-(
11:02:23 <Paczesiowa> BONUS: there's helium
11:02:27 <edwardk> but then that would make a difference between (- 123) (-123) and (possibly) (-x)
11:02:42 <SamB_XP> edwardk: I'm okay with that
11:02:49 <benmachine> you could just standardise NoImplicitPrelude and then have ghc-tutorial or whatever
11:02:50 <SamB_XP> we could even ban -x lexically
11:02:50 <Twey> edwardk: And then you might as well extend the whitespace-sensitivity to other operators for consistency
11:02:55 <edwardk> SamB_XP: thats the approach i've taken for kata
11:02:59 <Twey> edwardk: Also, --x
11:02:59 <edwardk> twey: i have ;)
11:03:08 <SamB_XP> Twey: isn't that a comment ?
11:03:08 <ben> Twey: Load regular prelude by default, have cabal load "advanced" prelude by default?
11:03:10 <benmachine> -fprelude=Prelude.Monomorphic
11:03:15 <SamB_XP> > --x
11:03:16 <Twey> SamB_XP: Oh yeah :þ
11:03:16 <lambdabot>   not an expression: `--x'
11:03:20 <SamB_XP> > 1 --x
11:03:21 <lambdabot>   1
11:03:26 <SamB_XP> yeah, it is
11:03:29 <deadguys> hi all. I just checked out ghc sources from darcs (following Building/GettingTheSources), tried to build (Building/Rebuilding) and am getting undefined reference errors.  any tips?
11:03:32 <Twey> benmachine: That'd work
11:03:35 <SamB_XP> sad but true
11:03:57 <c_wraith> deadguys: any particular reason you're building it yourself?
11:04:13 <deadguys> c_wraith: yep :)
11:04:22 <edwardk> twey: that, oddly, lets you use alphanumerics in operators, which isn't terrible A -o B -- is a perfectly reasonable operator -- especially if you're thinking of the lollipop implication operator used in linear logic
11:04:25 <c_wraith> just checking.  Many times, people don't have a good reason.
11:04:48 <Twey> edwardk: Right
11:04:49 <SamB_XP> deadguys: any particular errors?
11:05:01 <Twey> edwardk: It also forces newbies to produce more readable code :þ
11:05:20 <Twey> Always a good thing
11:05:21 <ben> Is there currently a way to get the effects of "import Prelude hiding ((.)); (.) = fmap" via a ghc option instead of actual code?
11:05:28 <benmachine> edwardk: does warming your legs with your laptop CPU count as a good reason
11:05:34 <edwardk> twey: yeah, and since juxtaposition binds more tightly than any of the operators, it makes sense to encourage the use of appropriate whitespace
11:05:34 <Twey> -XCaleskell
11:05:39 <burp> lol
11:05:39 <Twey> :þ
11:05:50 <Twey> edwardk: *nod*
11:05:59 <ben> ... like -XAlternatePrelude=foo.hs
11:06:03 <burp> would be awesome to really have that name ;)
11:06:20 <Twey> edwardk: Cale protests — he likes being able to write x^2
11:06:26 <benmachine> ben: I believe not
11:06:30 <edwardk> ben: Language pragmas alas, don't take arguments.
11:06:36 <deadguys> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23257
11:07:08 <Twey> ben: No, but it's been proposed before.
11:08:26 <edwardk> twey: i've been playing with a compromise that would allow that, but its awkward to explain to new users, so i'm somewhat hesitant
11:08:41 <Twey> edwardk: What is that?
11:08:48 <McManiaC> how do you catch the location of a "<<loop>>" error?
11:09:02 <benmachine> consider yourself lucky you get an error :P
11:09:07 <Twey> Hehe
11:09:09 <Twey> McManiaC: Debugger?  Trace statements?
11:09:17 <Twey> Careful reading?
11:09:18 <McManiaC> what debugger?
11:09:27 <benmachine> ghci has a debugger
11:09:43 <benmachine> http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-debugger.html
11:09:49 <Twey> Hat, GHCi
11:10:33 <benmachine> hat uses hmake
11:10:37 <benmachine> it is that old
11:10:53 <benmachine> I think someone was working on updating either hmake or hat
11:11:06 <benmachine> but no information on their progress
11:13:05 <McManiaC> well, ghci dies if I run my programm
11:13:06 <McManiaC> ^^
11:13:07 <edwardk> twey: the version i last played with had identifiers take the form of repeating single dash separated optionally prime'd alphanumeric segments. (explanation slightly simplified) infix operators are runs of symbols, which disallows -o, but would permit the x^2. unfortunately x^-2 has an ambiguous parse
11:13:08 <aavogt> has anybody succesfully installed criterion with ghc-6.12.1?
11:13:13 <McManiaC> <interactive>: <<loop>>
11:13:15 <McManiaC> <interactive>: warning: too many hs_exit()s
11:13:31 <mwc> Hmm, it's strange that you can't hide a system package as a user
11:13:31 <Twey> edwardk: Ew
11:13:40 <Twey> I don't like x^2 anyway
11:13:40 <edwardk> twey: thats why i said, 'was playing with it' =)
11:13:44 <mwc> ie, hide ghc's base-3 package
11:14:19 <edwardk> in my case it makes sense to require operators to be separated by spaces anyways, because i use _ for namespacing them
11:14:20 <aavogt> I'm running into issues where cabal-install can't be convinced to choose the branch with the newer TH here: http://hackage.haskell.org/packages/archive/data-accessor-template/0.2.1.3/data-accessor-template.cabal
11:15:06 <aavogt> so even when I have data-accessor-template _installed_, cabal install criterion still fails with trying to install the older TH
11:15:26 <edwardk> i.e. x +_int y or x +_Foo.Bar.Baz y
11:15:55 <djahandarie> Phew, that lecture on finding bounds on heuristic algorithms wasn't as complicated as I thought it was going to be
11:16:16 <aavogt> hmm, or is template haskell not bound to a specific ghc version?
11:16:35 <aavogt> anyways, I got it working with   --constraint="template-haskell >= 2.4"
11:16:45 * aavogt wonders why that's not there by default
11:17:17 <jmcarthur> is there a theoretical reason we don't have forall in constraints?
11:17:20 <edwardk> twey: the simpler rule is that the fixity of the identifier is chosen based on its first character being a symbol or not (with an exception to allow negative numbers to not be infix identifiers)
11:17:31 <jmcarthur> (Applicative f, forall a . Monoid (f a)) => ...
11:17:32 <thoughtpolice> aavogt: if you look in data-accessor-template's .cabal file, there's a flag in there called '-ftemplate_2_4' you can pass
11:17:43 <jmcarthur> ^^ is just Alternative, afaik
11:17:44 <thoughtpolice> that will build it against template-haskell 2.4
11:18:13 <thoughtpolice> aavogt: reason being is because in GHC 6.12, the template-haskell library was changed to account for type families/data declarations, so the template haskell ASTs had to change, which broke the interface
11:18:18 <edwardk> jmcarthur: that relies on the fact that you have non-overlapping instances for correctness for one
11:18:19 <philo> hi any one using the llvm bidings here ?
11:18:24 <McManiaC> can you use breakpoints with compiled code?
11:18:37 <edwardk> philo: once upon a time
11:18:46 <djahandarie> I think dons is making everyone get all excited about LLVM bindings
11:19:00 <jmcarthur> edwardk: non-overlapping is a reasonable sounding restriction to me
11:19:04 <philo> is it possible to write an optimization passein haskell
11:19:16 <thoughtpolice> philo: no, not atm
11:19:18 <edwardk> djahandarie: not sure if he means the llvm backend or the llvm bindings that bos and lennart put together
11:19:23 <jmcarthur> heck, you have to enable an extension to get overlapping instances anyway
11:19:34 <jmcarthur> and i don't like overlapping instances
11:19:53 <philo> thoughtpolice: the bindings isnt complete ?
11:20:06 <djahandarie> edwardk, well, the backend is new and shiny, so I am assuming he is talking about that. ;)
11:20:11 <thoughtpolice> philo: no, you just can't write passes for LLVM in haskell since it's written in C++
11:20:40 <edwardk> haskell's llvm bindings are basically a wrapper around the c llvm bindings, which don't expose everything the c++ bindings do
11:20:53 <philo> thoughtpolice: yea , but isnt it possible to write an haskell code that transform the IR ?
11:21:25 <thoughtpolice> philo: you could write something that post-processes LLVM-generated code if that's what you're looking at
11:21:33 <thoughtpolice> the llvm package is only to construct LLVM IR so you can run it
11:21:53 <thoughtpolice> edwardk: the C bindings don't expose everything, but they're quite useful, and the haskell bindings are nice and typesafe at least :)
11:22:01 <djahandarie> The bindings can get really complex though
11:22:23 <philo> thoughtpolice: exactly i a planning to use le LLVM IR as my own IR and creat on top of that some code that do some optimization
11:22:24 <djahandarie> Did you see augustss' last post on his blog?
11:22:24 <edwardk> thoughtpolice: don't get me wrong, i happily killed my haskell assembler dsl when i saw the llvm bindings ;)
11:23:01 <orbitz> murderer
11:23:07 <edwardk> though, i admit i lost a bit of type safety in the process
11:23:50 <thoughtpolice> djahandarie: the llvm packages use some type-level hackery, but for the most part you can still make sense of it all if you just follow the types
11:23:52 <philo> can the bindings produce an on memory representation of an IR code?
11:24:30 * RayNbow wonders what values inhibits the type data D = MkD (D -> D)...
11:24:38 <Twey> edwardk: *nod*  That's what I'd expect
11:24:44 * RayNbow can't think of anything useful
11:25:35 <philo> anyone ?
11:26:29 <edwardk> philo: i don't see any inspection machinery in it
11:26:47 <philo> ok thanks
11:28:25 <edwardk> orbitz: they were asking for it ;)
11:28:36 <edwardk> it was self defense, really
11:33:50 <roconnor> RayNbow: untyped lambda calculus
11:34:14 <RayNbow> roconnor: yeah, that's what Erik Meijer said in an interview
11:34:30 <RayNbow> (although he used C# syntax: delegate D D(D d);)
11:35:15 <LeNsTR> haskell fully support glsl ?
11:35:32 <RayNbow> roconnor: but I don't quite see yet how you could use D
11:38:46 <roconnor> RayNbow: InterpretLambdaCalculus :: LambdaCalculus freeVaraibles -> (freeVariables -> D) -> D
11:39:07 <roconnor> InterpretLambdaCalculus0 :: LambdaCalculus Void -> D
11:39:26 <roconnor> InterpretLambdaCalculus0 x = InterpretLambdaCalculus x void
11:40:07 <roconnor> hmm
11:40:12 <roconnor> less sure how to get stuff out of D.
11:41:18 <roconnor> RayNbow: I guess I don't see how it is usefull either
11:42:11 <RayNbow> roconnor: yeah... given some value (MkD d)... you can't do anything with d
11:42:26 <RayNbow> except applying it to (MkD d) perhaps
11:42:27 <roconnor> you can apply it to other elements of D :D
11:42:51 <roconnor> but ya, it is hard to see how this isn't representing a one point set
11:43:07 <roconnor> which is a solution
11:43:11 <roconnor> 1 = 1^1
11:43:40 <dolio> That's one of the things you can write with it.
11:44:10 <dolio> (\x -> unD x x) (D $ \x -> unD x x)
11:44:18 <dolio> Or something like that.
11:44:46 <roconnor> but are there any non trivial functions from D to bool?
11:45:05 <roconnor> are there any non-constant function from D to Bool
11:45:53 <dolio> (`seq` True)
11:46:58 <dolio> Anyhow, you can't inspect elements of D like you would expect to be able to with untyped lambda terms.
11:47:00 <roconnor> any non-paritally-constant functions from D to Bool?
11:47:15 <dolio> D (\x -> x) is an element of D, for instance.
11:48:00 <dolio> But I doubt you can observe any differences between it and any other element of D, barring seq.
11:48:08 <Phyx-> is there a read for ByteString?
11:50:49 <roconnor> Phyx-: String -> Bytestring?
11:50:52 <c_wraith> @hoogle hRead
11:50:53 <lambdabot> System.IO hReady :: Handle -> IO Bool
11:50:53 <lambdabot> Control.Concurrent isCurrentThreadBound :: IO Bool
11:50:53 <lambdabot> Control.Concurrent killThread :: ThreadId -> IO ()
11:51:03 <roconnor> Phyx-: What would it do?
11:51:36 <roconnor> UTF-8?
11:51:46 <Phyx-> roconnor: i meant, ByteString -> Int for instance
11:51:53 <roconnor> ah
11:53:59 --- mode: ChanServ set +o Philippa
11:54:00 <roconnor> Phyx-: like data binary?
11:54:09 --- mode: Philippa set +b *!*@95.66.40.124
11:54:13 --- kick: ce_mrh was kicked by Philippa (spammer)
11:54:22 <roconnor> what happend?
11:55:05 <Phyx-> roconnor: well, I was wondering if you could do like you would for strings (read "123323" :: Int), but then again, that might not be what ByteString is meant for
11:55:06 <Philippa> got PMed spam for another network when I /joined
11:56:15 <roconnor> ok
11:56:22 <Phyx-> :t sequence . replicate 7
11:56:23 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m [a]
11:56:33 <roconnor> @src replicateM
11:56:34 <lambdabot> replicateM n x = sequence (replicate n x)
11:56:36 <Phyx-> :t sequence . replicate 7 getLine
11:56:37 <lambdabot>     Couldn't match expected type `[m a]'
11:56:37 <lambdabot>            against inferred type `IO String'
11:56:37 <lambdabot>     In the second argument of `replicate', namely `getLine'
11:56:44 <Phyx-> ah
11:59:07 --- mode: Philippa set -o Philippa
11:59:27 <Phyx-> @type flip replicateM getLine
11:59:28 <lambdabot> Int -> IO [String]
11:59:32 <Phyx-> that'll do
12:00:25 <roconnor> @type (`replicateM` getLine)
12:00:26 <lambdabot> Int -> IO [String]
12:00:55 <Phyx-> ah right, using infix notation
12:01:03 * ski wonders whether `forall a. (D -> a) -> (D -> a)' would be any better ..
12:03:03 <roconnor> ski:  only if you could use that to build a non-partially-constant function D -> Bool.
12:06:58 <roconnor> I think data D = A | B D | C D | D (D,D) | E (D -> D)  is far more useful.
12:08:30 <RayNbow> roconnor: what's the use of having B and C?
12:09:24 <roconnor> used to intepret coproducts
12:09:48 <ski> D = 1 | D + D | D * D | D^D
12:10:06 <roconnor> where | is +
12:10:11 <ski> yes
12:10:53 <RayNbow> ah
12:11:46 <edwardk> roconnor: i'd be happier if the (D -> D) were inspectable, i.e. by using a better hoas rep.
12:12:00 * ski wonders about `D = 1 & D + D & D * D & D^D'
12:12:16 <ski> (where `&' is (low-predecence) `*')
12:13:00 <roconnor> it would be unintersting if it weren't for the D + D
12:13:18 <ski> (sortof a machine-level interpretation; every term can be interpreted in every type)
12:14:51 <ski> of course, it's not obvious what `unEither (parse "\\x. x")' should give
12:19:51 <roconnor> ski: what does it do in PHP?
12:21:01 <medfly> roconnor, PHP?
12:21:16 <roconnor> doesn't PHP allow any function to appy to any type?
12:21:25 <roconnor> this is what these untyped people like to do right?
12:21:32 <roconnor> it makes their programs "better"
12:22:00 * ski would go to Scheme, should he want untyped things ..
12:22:29 <roconnor> so that is car id
12:22:37 <roconnor> hmm
12:22:40 <roconnor> no not right
12:22:52 <theorbtwo> roconnor: Please, if you are going to ask questions about languages with different paradigms, do it because you want to understand them, not in order to poke fun at them.
12:22:52 <ski> `unEither' there is a meta-level function
12:23:15 <roconnor> theorbtwo: ok
12:26:13 <theorbtwo> Really, Haskell has a reputation, reasonably well-deserved from what I can see, as being a language that you should learn if you want to get a wider viewpoint on how you think about programming.  It is unfortunate that so much of the community seems uninterested in doing the same, and has a very narrow view of how programming should be done.
12:27:33 <medfly> roconnor, I don't know what you mean, that a function can accept every type? yes.
12:27:38 <medfly> roconnor, it does some pretty wild type things...
12:27:41 <olsner> learning haskell has really made me not want to learn any new imperative languages... for good or bad :)
12:28:02 <burp> for bad if you have to use them :>
12:28:04 <gwern> > 32 / 4.1
12:28:05 <lambdabot>   7.8048780487804885
12:28:20 <gwern> so the ubuntu repos did turn out to be ~30 gigs
12:28:40 <ski> olsner : you still ought to learn about logic programming. and about continuations. and macros
12:28:49 <ski> (maybe you have already done so .. i dunno)
12:28:50 <gwern> and 8 dvds, ouch
12:28:55 <jmcarthur> Not that I'm disagreeing with theorbtwo, but getting a wider viewpoint on programming has the effect of making the ideas you are already familiar with look a lot smaller...
12:29:14 <[swift]_> this is not a haskell question but i thought i might ask in case anyone in here knew, since the level of knowledge in here seems high: is there a name for an automaton that is like a finite state machine but augmented with an accumulator or a single register?
12:29:20 <gwern> 'how can the frog in the well know of the sea?'
12:29:44 <olsner> tried out python, and occasionally had to use it... but really, all I see smells
12:30:02 <FauxFaux> olsner: Correct.
12:30:02 <burp> python has some functional stuff
12:30:11 <jmcarthur> burp: decreasingly so
12:30:19 <dolio> What can the register hold?
12:30:21 <uorygl> [swift]_: if the accumulator or register is limited, that's called a finite state machine.
12:30:22 <medfly> olsner, it has for me. I started with Haskell. now I want a job. ;)
12:30:23 <olsner> burp: gimped-down useless almost-but-not-at-all functional stuff :P
12:30:38 <jmcarthur> it is certainly not guido's goal to support functional programming whatsoever
12:30:52 <[swift]_> dolio: an arbitrary integer
12:31:07 <[swift]_> urogyl: if by limited you mean it has a finite domain, then no, it's not limited
12:31:20 <dolio> I bet you can call that a turing machine, but I'm not 100% certain.
12:31:23 <ski> pair :: D -> D -> D; unUnit (pair d0 d1) = (); unEither (pair d0 d1) = case (unEither d0,unEither d1) of {(Left x0,Left y0) -> Left (pair x0 y0); (Right x1,Right y1) -> Right (pair x1 y1)}; unPair (pair d0 d1) = (d0,d1); unFun (pair d0 d1) = \x -> let (x0,x1) = unPair x in pair (d0 x0) (d1 x1)
12:31:36 <olsner> of course, jmcarthur is correct, which means that there's not much hope of python getting some nice stuff added
12:31:43 * ski has no idea whether that's really sane .. it's some kind of attempt
12:31:45 <uorygl> [swift]_: it really depends on what you can do with the register.
12:31:53 <[swift]_> dolio: pretty sure not. it should be more powerful than an FSM but less than a PDA
12:32:15 <dolio> Why?
12:32:32 <uorygl> If the options are increment, decrement, and test for zero, then without I/O, it might be equivalent in power to an FSM.
12:32:32 <[swift]_> urogyl: i'm thinking increment or decrement it as part of a transition and take a different transition if the register holds a specific value
12:32:33 <dolio> An integer gives it an infinite amount of memory, doesn't it?
12:32:49 <[swift]_> dolio: hmm, you might be right, that's true
12:33:02 <uorygl> Well, simply having an infinite amount of memory isn't enough for Turing-completeness.
12:33:08 <uorygl> A PDA has an infinite amount of memory.
12:33:16 <theorbtwo> Perl has a fair bit of functional stuff.
12:33:21 <uorygl> This is pretty much a Minsky register machine with one register.
12:33:40 <dolio> I suppose it depends on what operations it has on the integer.
12:33:47 <[swift]_> urogyl: i don't think it's equivalent in power to an FSM, because I think it can recognize, say, matched pairs of parentheses, which an FSM can't do for arbitrary nesting depth
12:34:05 <uorygl> Well, I said "without I/O".
12:34:09 <olsner> I think perl qualifies as "interesting", if nothing else for it's syntax (like ursala)
12:34:20 <uorygl> Then again, without I/O, everything whose halting problem is solvable is equivalent to an FSM in some sense.
12:34:27 <[swift]_> urogyl: i'll look up Minsky machines, thanks
12:35:58 <ezyang> Head branch of Cabal for GHC 6.12; correct?
12:35:58 <lambdabot> ezyang: You have 1 new message. '/msg lambdabot @messages' to read it.
12:36:04 <ezyang> /msg lambdabot @messages
12:36:11 <ezyang> erm heh
12:36:18 <ezyang> :irc-msg lambdabot @messages
12:36:24 <ezyang> fail
12:36:40 <ezyang> copumpkin: Yes I do!
12:36:50 <ezyang> @seen copumpkin
12:36:51 <lambdabot> Unknown command, try @list
12:37:50 <benmachine> preflex: seen ezyang
12:37:51 <preflex>  ezyang was last seen on #haskell 1 minute ago, saying: @seen copumpkin
12:38:05 <ezyang> preflex: seen copumpkin
12:38:06 <preflex>  copumpkin was last seen on #haskell 11 hours, 2 minutes and 14 seconds ago, saying: anders^^: but not ideal, unless you already wanted to modify an existing mutable vector
12:38:07 <aavogt> ezyang: well Cabal-the-library comes with ghc
12:38:11 <ski> fun :: (D -> D) -> D; unUnit (fun d_d) = (); unEither (fun d_d) = ???; unPair (fun d_d) = (fun (\x0 -> unFun d0 (pair x0 (error "snd"))),(\x1 -> unFun d1 (pair (error "fst") x1))); unFun (fun d_d) = d_d
12:38:28 <ezyang> ah, right Cabal-1.8.0.2
12:38:36 <ezyang> Ok, I guess I need a newer cabal-install binary
12:38:48 <[swift]_> urogyl: that was exactly what I was looking for! now i've got a couple of papers to read. thanks again.
12:38:59 <dolio> Hmm, I guess it wouldn't be able to keep track of information about the integer it'd need to be able to simulate a Turing machine.
12:38:59 <aavogt> there's a cabal-install snapshot that works with that version of cabal, but it doesn't seem to be linked directly from haskell.org/cabal
12:39:02 <ezyang> @tell copumpkin Yes I do!
12:39:03 <lambdabot> Consider it noted.
12:40:01 <ezyang> bah, I don't have darcs installed
12:40:06 <ezyang> but I can't install darcs without cabal
12:40:07 <ezyang> blah
12:40:22 <ski> (ezyang : if that was (meant as) a private reply, you could have used `/msg lambdabot @tell ...')
12:40:42 <ezyang> (not particularly, but thanks for the pointer)
12:40:56 <benmachine> now we all know that he replied to copumpkin in the positive :O
12:41:19 <benmachine> we could use this information for evil, if only we had any idea what he was replying to
12:41:24 * ski habitually uses `@messages' in public, because he doesn't think lambdabot messages are really private
12:43:40 <ezyang> aha, darcs.haskell.org has a 0.9.0 version
12:47:27 <ezyang> cabal's not clever enough to be able to have multiple versions of some package linked against different versions of other packages, is it?
12:50:25 <aavogt> cabal install doesn't let you get into that situation, but if you use Setup.hs, it will warn you but still go ahead
12:51:42 <roconnor> theorbtwo: Actually I think the idea that you should learn Haskell to get a wider viewpoint of programming is mainly purpetuated by people who have only dabbled in Haskell.
12:51:56 <ezyang> aavogt: Well, the case I'm thinking of is A can use any version of B, C depends specifically on B-0.1, and D depends on A and specifically on B-0.2.
12:52:11 <ezyang> C and D should be able to coexist peacefully.
12:52:26 <Cale> It's true that you should, but it's not the only reason.
12:52:51 <aavogt> well only if those packages don't reexport data that's defined in B
12:52:57 <aavogt> or only one reexports stuff
12:53:10 <roconnor> Cale: who was that in reply to?
12:53:57 <Cale> your message to theorbtwo
12:54:05 <roconnor> ah
12:54:11 <roconnor> I thought that might be the case.
12:54:18 <ezyang> aavogt: No, it should still be fine
12:54:41 <ezyang> aavogt: There just need to be two versions of B, which know which versions of A they're with
12:55:04 <ezyang> hm, that example wasn't the best
12:55:43 <ezyang> let's try: A depends on B; C depends on B-0.1 and A; D depends on B-0.2 and A
12:56:02 <monadic_kid> is me or is youtube is imploding now a days
12:56:10 <ezyang> C works with B-0.1 and A compiled with B-0.1; D works with B-0.2 and A compiled with B-0.2
12:56:27 <ezyang> But once you pick B-0.1 or B-0.2 for A, the other program is excluded
12:56:57 <aavogt> are you sure this case isn't allowed already?
12:57:13 <ezyang> Yes.
12:57:20 <ezyang> At least, for Cabal 1.6
12:57:21 <aavogt> I think I get it now
12:57:35 <aavogt> you want to have the same package installed twice but depending on different things
12:57:37 <ezyang> Because the other day I had to manually change A's deps
12:57:39 <ezyang> Yup!
12:57:59 <ezyang> I don't know if that makes constraint satisfaction NP complete :-)
12:58:40 <aavogt> well with ghc-6.12, packages include a hash which presumably involves dependencies...
12:58:48 <ezyang> oooooh
12:58:51 <ezyang> niice
12:59:01 <aavogt> but I'm not sure if that makes it possible
12:59:18 <gwern> ezyang: constraint satisfaction is already np
12:59:32 <gwern> one of the TMR articles shows this, iirc, reducing it to 3-sat
12:59:45 <ezyang> ah, ok
13:00:57 <ezyang> bah: ezyang@ezyang:~/Dev/cabal-1.8$ runghc Setup.hs install --user Setup.hs: /usr/local/share/doc/Cabal-1.8.0.2: permission denied
13:01:14 <ezyang> in't --user supposed to make it not scribble over /usr/local
13:01:19 <aavogt> probably needs to be configured as user
13:01:40 <ezyang> ok
13:03:42 * hackagebot data-object 0.2.1 - Represent hierachichal structures, called objects in JSON.  http://hackage.haskell.org/package/data-object-0.2.1 (MichaelSnoyman)
13:07:44 <ezyang> hmmm... where did the binaries go...
13:08:09 <ezyang> oh silly Edward. you installed the wrong package
13:17:00 <deadguys> hmmm still having trouble building ghc from source.  can anyone help?  here's the error: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23257
13:17:54 <Igloo> deadguys: What version is /usr/bin/ghc?
13:18:22 <deadguys> Igloo: 6.10.4
13:18:30 <Igloo> And what version are you trying to build?
13:18:43 <deadguys> darcs HEAD
13:19:02 <Igloo> Can you hpaste the output of ghc-pkg list?
13:20:06 <deadguys> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23260
13:21:52 * ezyang is feeling very silly now 
13:22:16 <Igloo> Hmm, I'd guess it's because you have a newer filepath instlaled as a user than the system one
13:22:46 <deadguys> should I unregister 1.1.0.3?
13:23:17 <Igloo> I imagine that doing that and rebuilding would work, yes
13:25:51 <ezyang> hmm. Network/Socket.hsc:1707:45:     Not in scope: data constructor `System.Posix.Internals.Stream'
13:26:32 <ezyang> cabal is such a twisty twisty maze
13:28:57 <Cale> What does Network/Socket.hsc have to do with cabal? Isn't it part of the network package?
13:29:56 <ivanm> yes
13:29:57 <c_wraith> cabal-install depends on network
13:30:08 <ivanm> cabal-install /= cabal
13:30:34 <c_wraith> yes, but people often say cabal when they mean cabal-install, because that's the name of the executable
13:30:37 <Cale> I suppose. Does network no longer come with ghc?
13:30:47 <c_wraith> as of 6.12, it does not
13:32:34 <ezyang> network won't install for me on 6.12
13:32:43 <ezyang> I haven't looked closely enough yet
13:34:42 <newsham> cabal go north
13:35:47 <newsham> cabal pickup torch
13:36:14 <ivanm> Cale: it hasn't come with GHC for a while...
13:36:20 <ivanm> it came with -extras, however
13:36:22 <ivanm> *extralibs
13:36:36 <ivanm> and extralibs was replaced by the platform as of 6.10.4
13:36:43 <Cale> Well, it'd be silly to get the small package ;)
13:38:27 <MaciejP> What an amusing error message: `Inferred type is less polymorphic than expected' :-)
13:39:58 <Cale> That happens when you give a too-general type signature, or too-specific code for the type signature you provided. (So it can be caused by either a bug in the code or the sig)
13:41:48 <MaciejP> Well, there was no type signature. Adding one fixed it
13:42:02 <Heffalump> what was the code?
13:42:16 <MaciejP> everywhereM' f x = do { x' <- f x; gmapM (everywhereM' f) x' }
13:42:34 <Heffalump> ah, so using Rank-2 polymorphism
13:43:06 <Cale> Ah right, higher rank polymorphism can cause it too. Forgot about that.
13:47:03 <c_wraith> that's the only time I've ever seen it.  when I tried to treat runST as a normal function. :)
13:49:06 <narens> what is the fmap implementation for (,)?
13:49:24 <byorgey> @src (,) fmap
13:49:24 <lambdabot> fmap f (x,y) = (x, f y)
13:49:36 <byorgey> technically, it is for ((,) a)  not (,)
13:49:43 <byorgey> (,) cannot be a Functor since it has the wrong kind.
13:50:10 <byorgey> so  fmap :: (b -> c) -> (a,b) -> (a,c)
13:50:16 <byorgey> and there's only one thing it could do!
13:50:26 <narens> i've been trying to understand how this is working fmap concat $ traverse (Data.List.partition even) [[1,2],[3,4]]
13:50:39 <narens> i don't understand how the elements in the first part of the tuple get combined
13:50:42 <c_wraith> fmap (a, _) = (a, undefined)
13:50:49 <c_wraith> that must be what it does!
13:51:02 <byorgey> there's only one thing it could do that does not involve undefined!
13:51:06 <byorgey> =)
13:51:14 <byorgey> or seq!
13:51:17 <byorgey> or unsafePerformIO!
13:51:34 <c_wraith> or errror, or any number of other things that result in _|_
13:51:49 <byorgey> oh yeah, forgot about error
13:52:08 <byorgey> > traverse (partition even) [[1,2],[3,4]]
13:52:09 <lambdabot>   Not in scope: `traverse'
13:52:19 <byorgey> > Data.Traversable.traverse (Data.List.partition even) [[1,2],[3,4]]
13:52:20 <lambdabot>   ([2,4],[[1],[3]])
13:52:29 <narens> yea, how does it combine the first part?
13:52:34 <narens> i understand the snd
13:52:43 <c_wraith> narens, it doesn't.  It just copies it
13:53:03 <c_wraith> > fmap (+1) ("foo", 5)
13:53:04 <lambdabot>   ("foo",6)
13:53:05 <byorgey> hmm, so traverse is the composition of fmap and sequence
13:53:12 <narens> yea, i get that
13:53:18 <byorgey> > fmap (Data.List.partition even) [[1,2],[3,4]]
13:53:19 <lambdabot>   [([2],[1]),([4],[3])]
13:53:46 <byorgey> @type Data.Traversable.traverse
13:53:47 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
13:54:16 <narens> i expand out the traverse an the first thing it would do is (:) <$> partition even [3,4] <*> ([],[])
13:54:17 <byorgey> oh, so to understand what traverse/sequence does here, you must understand the Applicative instance of ((,) a)
13:54:18 <narens> right?
13:54:37 <narens> and then it would do (:) <$> ([2],[1]) <*> ([4],[[3]])
13:54:49 <narens> so how does [2] and [4] become [2,4]
13:55:43 <byorgey> @src (,) Applicative
13:55:43 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
13:55:47 <byorgey> @src (,) (<*>)
13:55:47 <lambdabot> (u, f) <*> (v, x) = (u `mappend` v, f x)
13:55:51 <byorgey> that's how!
13:56:08 <narens> gothca... why it it defined like that? and why is that natural?
13:56:10 <byorgey> the Applicative instance for ((,) a) requires that the 'a' (the first component of the tuples) is an instance of Monoid
13:56:20 <byorgey> well, what else would you do with them?
13:56:31 <narens> dunno :-)
13:56:37 <byorgey> if you have  (a1, f) <*> (a2, x)
13:56:47 <byorgey> you apply the f to the x, but what do you do with a1 and a2?
13:56:52 <byorgey> you need some way to combine them.
13:57:07 <byorgey> the Monoid instance just means there is a generic way to combine elements of that type.
13:57:08 <narens> i guess so
13:57:15 <byorgey> and an identity, which you need to implement pure.
13:57:20 <byorgey> pure x = (mempty, x)
13:57:51 <c_wraith> ok...  top is reporting that this program is shrinking, sometimes.  I thought the haskell RTS-managed heap never shrinks...  Does this imply releasing mmap'd resources, or the like?
13:57:53 <byorgey> all that said, I find that code horrible and quite impossible to understand.
13:58:02 <byorgey> narens: where did you see that code?
13:58:14 <narens> yea, i was basically trying to understand parListChunk which parallelizes a function operating on a list.... but unfortunately, though elegant, was horribly slow.... since it used this same traverse trick
13:58:37 <byorgey> oh, interesting
13:59:04 <narens> i was amazed by how it could trasparently parallelize it.. but slow. so i had to hand parallelize it
13:59:35 <narens> i did it with Vectors instead... and it was a little faster though
14:00:10 <byorgey> > fmap concat $ Data.Traversable.traverse (Data.List.partition even) [[1,2,3,4],[5,6,7,8]]
14:00:11 <lambdabot>   ([2,4,6,8],[1,3,5,7])
14:00:20 <byorgey> > fmap concat $ Data.Traversable.traverse (Data.List.partition even) [[1,2,3,4],[5,6,7,9]]
14:00:20 <narens> mhmmm
14:00:21 <lambdabot>   ([2,4,6],[1,3,5,7,9])
14:00:44 <byorgey> so how is this different than  partition even . concat ?
14:01:22 <narens> well, in the case of Control.Parallel.Strategies... parListChunk would apply a parallel strategy to each chunk
14:01:45 <c_wraith> err. glibc just blew up on me.  In haskell.  >_>
14:01:48 <narens> @sr  Control.Parallel.Strategies.parListChunk
14:01:48 <lambdabot> Source not found. Maybe if you used more than just two fingers...
14:02:00 <c_wraith> Looks like the curl bindings are at fault, in the root
14:02:28 <narens> concat `fmap` parList (seqList strat) (chunk n xs)
14:02:41 <narens> seqList is just traverse
14:02:56 <narens> so, its pretty neat
14:03:05 <byorgey> narens: hmm, what version of Control.Parallel.Strategies do you have?
14:03:12 <narens> but all those mappends kill perf i guess
14:03:13 <byorgey> that's not the source I'm seeing on hackage
14:03:44 <byorgey> oh, wait, it was showing me an old version.
14:03:46 <narens> http://hackage.haskell.org/packages/archive/parallel/2.2.0.1/doc/html/src/Control-Parallel-Strategies.html#parListN
14:04:27 <byorgey> I see.
14:04:30 <narens> oh, i meant to also ask if anyone knew what the compelxity of ++ in Vectors is? I couldn't find it in the source
14:05:37 <cYmen> hey, could anybody take a look at this for me
14:05:38 <cYmen> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23261#a23261
14:05:39 <narens> because i was wondering if there is any list like structure that gives O(1) concatenation
14:05:49 <cYmen> just a newbie compile error I guess but I can't see the problem
14:06:17 <c_wraith> narens: how listlike?
14:06:18 <byorgey> cYmen: try moving the 'where' clause to after all the guards
14:06:35 <c_wraith> narens: see DList, for some definitions of listlike
14:06:46 <cYmen> byorgey: oh...so it applies to all of them?
14:06:48 <narens> c_wraith: well Dlist perf is no where near Vector
14:06:51 <byorgey> cYmen: yep
14:07:19 <narens> c_wraith: I want small space complexity too... :-(
14:07:24 <deadguys> Igloo:  that seems to have resolved it.  thanks for the help
14:07:43 <cYmen> byorgey: thanks
14:08:58 <narens> byorgey: assuming I wrote a partition function that returned [[],[]] instead of ([],[]) and I use the same traverse thing... will it be any faster because the operations on both will just be (:) instead of (++)?
14:09:31 <byorgey> narens: I don't know.
14:10:10 <Cale> Assuming the whole list is evaluated, (xs ++ ys) takes O(length xs) steps to completely reduce
14:10:14 <mm_freak> sorry to disrupt your discussion, but i _need_ to see this again…
14:10:22 <mm_freak> > splitAt 7 . drop 27 . map head $ cake
14:10:24 <lambdabot>   ("TOOTOOT","ASCIICAT")
14:10:35 <Cale> However, one common trick is to replace lists by functions which add elements to the beginning of a list.
14:10:50 <Cale> and (++) with (.) which is constant time
14:11:27 <byorgey> mm_freak: what on earth
14:11:38 <Cale> The empty list is replaced with id, and a single element [x] is replaced by the function (x:)
14:12:25 <Cale> So, for instance, if you have an inorder traversal for a binary tree, it might look something like this:
14:12:29 <ceii1> > cake
14:12:30 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
14:12:45 <Cale> inorder Tip = []; inorder (Branch x l r) = inorder l ++ [x] ++ inorder r
14:12:48 <c_wraith> > drop 27 cake
14:12:49 <lambdabot>   ["Two slash three cups granulated rhubarb.","One tablespoon all-purpose rhu...
14:13:17 <mm_freak> byorgey: tootoot…  it's the ASCII CAT
14:13:31 <c_wraith> > map head cake
14:13:32 <lambdabot>   "OOTFOTOTDFFFFFPFCOAUFANTOATTOOTOOTASCIICAT"
14:13:51 <Cale> But this is inefficient because if the tree leans to the left, it will repeatedly (++) with long lists on the left
14:13:58 <burp> lol funny
14:14:05 <Cale> So you can use this trick, writing:
14:14:26 <Cale> inorder' Tip = id; inorder' (Branch x l r) = inorder' l . (x:) . inorder' r
14:14:28 <mm_freak> i think, the ASCII CAT should become the haskell mascot
14:14:38 <danderson> So, I have a foreign C struct that contains a char array (char ifr_ifname[20]), and I need to copy a haskell string into it. But I'm not quite clear on how to achieve that. Can someone point me to an FFI library that already does this, by any chance?
14:14:39 <Cale> and then  inorder t = inorder' t []
14:14:40 <ivanm> @slap dons
14:14:40 * lambdabot clobbers dons with an untyped language
14:14:48 <ivanm> stop abusing the system with your base < 10 trick!
14:16:12 <Cale> narens: Does that make sense?
14:16:40 <Cale> narens: The new inorder traversal will be linear in the size of the tree, because composition is constant time
14:17:13 <narens> yea, I have used that trick in a more modest way before...
14:18:56 <dons> ivanm:
14:19:01 <roconnor> ivanm: source?
14:20:27 <ivanm> dons: my apologies, this time it was malcolmw copying your trick
14:20:49 <dons> what's that?
14:21:28 <Axman6> base >= 4.0 && < 10
14:21:31 <ivanm> hscolour uses base < 10 for its cabal deps
14:21:31 <dons> ah
14:21:40 <dons> malcolm used to use haskell98, rather than base, as his dep.
14:21:41 <ivanm> Axman6: not even >= 4.0
14:21:45 <dons> he's been at this longer than i ahve.
14:21:45 <Axman6> heh
14:21:45 <ivanm> *nod*
14:21:50 <ivanm> heh
14:22:06 <Cale> Why constrain it to be less than 10?
14:22:22 <ivanm> dons: Axman6 and I were talking yesterday about maybe trying to have an oz hackathon; you planning on coming down under at any time this year?
14:22:33 <ivanm> Cale: hackage complains if you don't have an upper bound
14:22:45 <Cale> Does it actually reject the package though?
14:22:45 <ivanm> and by having it as < 10, it is hoped that you won't have to update it in future for a while
14:22:49 <ivanm> yes
14:22:52 <Cale> ah
14:22:58 <ivanm> even though that backfired for dons with ghc-core
14:23:02 <dons> ivanm: nope, sorry
14:23:11 <Cale> I don't see why it ought to.
14:23:15 <ivanm> (since it didn't build with base-4 for one version where he specified with base < 5)
14:23:17 <Cale> I can imagine giving a warning.
14:23:32 <ivanm> Cale: too many packages that didn't build properly with base-4 but didn't specify that they needed base-3
14:23:40 <ivanm> or base < 4
14:23:44 <dons> < 10 is a strong claim - that you dont' use apis that won't change for 10 years , approx
14:23:51 <dons> 10 - 15 years
14:23:57 <dons> so yeah, you might want to warn.
14:24:11 <ivanm> that's why cabal-install (at least 0.6.x) defatuls to base-3, to build those packages that don't explicitly state that they can build with base-4
14:24:33 <c_wraith> is there a command to tell cabal to dump the list of flags a package has?
14:25:13 <ivanm> c_wraith: IIRC someone was asking that on -cafe recently ;-)
14:25:20 <ivanm> and I think dcoutts said "no"
14:25:40 <ivanm> (even though it shouldn't be that hard to do so; it's probably more of a UI issue)
14:26:19 <MaciejP> What's a good way to debug generated TH declarations?
14:28:22 <ivanm> dons: OK, with mersenne-random-pure64, here for the gentoo ebuild we have a patch from int-e to improve 32bit performance; do you know if you added that patch in upstream?
14:28:44 <dons> recently?
14:29:03 <dons> last patch i have from int-e is 2008
14:29:31 <ivanm> this is applied to 0.2.0.2, so it could be
14:29:47 <dons> check the patch against the repo?
14:29:59 <ivanm> yeah
14:30:14 <dons> http://code.haskell.org/~dons/code/mersenne-random-pure64
14:30:17 <dons> should be up to date
14:30:24 <dons> if its not there, then i don't have it.
14:30:27 <ivanm> hmmm, any particular reason the repo for it is in ~dons rather than just c.h.o/... ?
14:30:57 <dons> too hard to keep track of 100s of things at the top level
14:31:05 <dons> and few have more than me committing to them
14:33:29 <ivanm> dons: looks like you don't have it
14:33:57 <ivanm> this is the patch I'm talking about: http://code.haskell.org/gentoo/gentoo-haskell/dev-haskell/mersenne-random-pure64/files/mersenne-random-pure64-0.2.0.2-double-for-32bits.patch
14:33:58 <dons> int-e: do you have a patch to send?
14:34:53 <c_wraith> gah.  hp2ps is telling me samples are out of sequence.
14:35:23 * ezyang goes "ooh, it's a dons!" 
14:36:58 * uorygl pokes around his Unix system search for the source code to the network library.
14:37:04 <uorygl> s/search/in search/
14:38:46 <dons> cabal unpack network
14:38:54 <c_wraith> ok...  there's no space leak on the heap.  Why else might a haskell program's resident size be ever-growing?
14:39:04 <c_wraith> native code?
14:39:43 <jmcarthur> c_wraith: by no space leak on the heap you mean memory profiling is flat?
14:39:44 <medfly> someone said something about web apps doing that
14:39:49 <medfly> maybe not
14:39:57 <danderson> "there's a space leak on the heap" sounds very much like a warp core breach in progress
14:40:03 <danderson> have you tried realigning the input manifolds?
14:40:26 <ezyang> danderson: "aye aye sir, but there are wumpuses in the garbage collector"
14:40:44 <danderson> ezyang: well then bounce a graviton particle beam off the main deflector dish
14:40:49 <danderson> do I have to think of everything?
14:41:12 <c_wraith> jmcarthur: well, it's lumpy as hell, but it's averaging flat.  (the nature of the application is for a lumpy memory profile)
14:42:12 <jmcarthur> c_wraith: well, the rts never releases memory back to the OS, so if you see lumps then those aren't actually going away
14:42:39 <jmcarthur> i assume you realize that though and you are having a steady increase over time?
14:42:51 <c_wraith> jmcarthur: the trend is flat, though.  new allocations should overwrite collected space on the heap.
14:43:05 <jmcarthur> true, in the absense of fragmentation
14:43:18 <c_wraith> it's a copying collector.  It shouldn't fragment.  I thought.
14:44:11 <jmcarthur> i don't know much about the ghc collector, but i thought it wasn't a copying collector or if it is then it's not a pure copying collector or something
14:44:21 <jmcarthur> i could be wrong
14:44:33 <uorygl> Aha, foreign import statements!
14:44:44 <uorygl> foreign import ccall SAFE_ON_WIN "sendAncillary"
14:44:48 <uorygl> I wonder what file that imports from..
14:44:50 <uorygl> s/.././
14:45:55 <c_wraith> I don't have a clear-enough handle on the memory use.  I wish the profiling code would stop dumping samples out of order
14:46:12 <jmcarthur> tried something like valgrind maybe?
14:46:22 <jmcarthur> i've never run valgrind on a haskell program
14:46:35 <ezyang> that would seem to be sufficiently low level so as to be useless
14:46:37 <c_wraith> That's a scary thought.
14:46:41 <ezyang> except for very small programs
14:46:50 <c_wraith> this is not a very small program, at this point.
14:46:50 <jmcarthur> ezyang: well, if it's a rts bug it's not useless
14:46:55 <ezyang> True.
14:47:05 <c_wraith> I doubt it's an RTS bug.  I'm sure it's native code being used somewhere.
14:47:31 <c_wraith> what's the profiler flag to sort the list by constructor?
14:47:42 <jmcarthur> hc? guessing
14:47:46 <jmcarthur> it's in the docs
14:48:07 <c_wraith> Hrm.  I'm just going to try biographical
14:51:05 <c_wraith> yeah, *something* outside the RTS is involved
14:51:13 <c_wraith> as it's clearly releasing memory back to the OS sporadically
14:51:28 <jmcarthur> oh it is?
14:51:31 <jmcarthur> maybe a FFI binding?
14:51:44 <c_wraith> there are many in use.
14:52:09 <c_wraith> I'm not sure the resident size is actually growing after it reaches a point it's happy with.
14:52:54 <c_wraith> agh.  why do I keep getting samples out of sequence?  It makes it really hard to actually *use* the profiling results
14:53:45 <c_wraith> Is there any way to repair the issue?
14:55:47 <c_wraith> I mean, just in the .hp file?  Can I just discard the offending record?
14:58:53 <danderson> holy hell, hsc2hs is amazing
14:59:10 <danderson> I gave it the most horrible, gnarly #define possible from the linux kernel headers
14:59:23 <danderson> which expands to several nested macros to finally come out as a number
14:59:41 <danderson> and (#const TUNSETIFF) Just Worked
14:59:58 <luite> probably because it just lets gcc do the hard work :)
15:00:44 <Draconx|Laptop> C preprocessors are not the most complicated of programs to get right.
15:01:08 <danderson> luite: oh, it cheats! Okay :P
15:01:10 <Draconx|Laptop> there are some bizarre lexing rules, but other than that...
15:01:55 <luite> danderson: it generates a C program that is compiled by gcc. the program prints out the haskell source, with the correct substitutions
15:01:55 <danderson> Draconx|Laptop: sure. I just tend to be impressed when stuff like that just works out. In any other language FFI interface I'd have expected it to fail for anything but #defines of literal ints
15:02:43 <danderson> luite: aah, fascinating. Makes sense, and takes quite a bit of the magic away :)
15:02:46 <danderson> thanks.
15:03:11 <luite> yeah I guess I should've warned you before spoiling the magic ;)
15:04:36 <narens> how do you make a list of unboxed Int(s) to reduce space?
15:05:33 <dons> narens: use a vector (from the vector package)?
15:05:38 <luite> narens: if you really want to save space, you probably shouldn't use a list but an unboxed array
15:05:39 <dons> an unboxed sequence, rather than list.
15:05:40 <narens> i mean without using vector
15:05:49 <danderson> luite: that's fine. I'll take the awe of understanding over the awe of ignorance any day.
15:05:53 <dons> there are STUArrays
15:05:54 <narens> i am just curios to see how much space it will free up
15:06:04 <dons> 4 to 8x less apce
15:06:05 <dons> space.
15:06:08 <dons> maybe more.
15:06:22 <dons> plus completely differnt complexity on many operations
15:06:36 <narens> that's nice, the reason i want to use a list is because the parition function runs ridiculously fast on a list compared to even a vector
15:07:07 <dons> ah partition
15:07:18 <narens> so, that's why i wanted to see if I could store unboxed stuff in lists
15:07:22 <narens> i just don't know how
15:07:44 <dons> no, you can't really. well, there's the adaptive package, which has unboxed lists.
15:07:55 <dons> so you could actually experiment with that.
15:08:06 <narens> will making the elements strict reduce space as much?
15:08:26 <narens> dons: where is this package?
15:08:46 <ivanm> on hackage
15:08:53 <pastorn> is copumpkin hiding?
15:08:58 <ivanm> preflex: seen copumpkin
15:08:59 <preflex>  copumpkin was last seen on #haskell 13 hours, 33 minutes and 8 seconds ago, saying: anders^^: but not ideal, unless you already wanted to modify an existing mutable vector
15:09:03 <ivanm> pastorn: probably sleeping...
15:09:07 <ivanm> or some such
15:09:26 <pastorn> http://www.reddit.com/r/programming/comments/b9qr9/google_ai_challenge_last_place_finisher_shows_an/
15:09:55 <ivanm> when a library (e.g. text) has two possible options for deps, which one does Cabal (the library) choose?
15:12:54 <jmcarthur> pastorn: haha
15:13:01 <jmcarthur> copumpking would be proud if he was here
15:13:21 <ivanm> proud of going north?
15:13:44 <jmcarthur> ivanm: sure why not
15:13:52 <ivanm> so he's going to canada?
15:13:57 <ivanm> speak of the gourdish devil!
15:14:56 <Adamant> if he keeps going North he'll end up in India via Siberia
15:14:59 <c_wraith> there he is
15:15:09 <c_wraith> copumkin, people are talking about you on reddit
15:15:22 <jmcarthur> copumpkin: :)
15:15:26 <jmcarthur> i didn't do it
15:15:28 <copumpkin> yo :)
15:15:29 <lambdabot> copumpkin: You have 1 new message. '/msg lambdabot @messages' to read it.
15:15:29 <copumpkin> I know
15:15:36 <jmcarthur> but i upvoted it
15:15:44 <copumpkin> me too :)
15:16:07 <jmcarthur> congrats on last place, though
15:16:18 <jmcarthur> that actually seems like it was probably harder to do than it looks
15:16:23 <jmcarthur> ;)
15:16:25 <copumpkin> ezyang: would you have the time/power to try to organize a HUG in the usual place?
15:16:28 <copumpkin> jmcarthur: lol yeah
15:16:46 <copumpkin> I'm going to write a humorous post a bit like a1k0n's describing how I failed so wonderfully
15:17:00 <jmcarthur> make sure you explain how much hard work you put into it
15:17:09 <jmcarthur> and all the incredible thinking that went into it
15:17:22 <jmcarthur> do some data mining, too
15:17:26 <copumpkin> definitely will :)
15:17:33 <copumpkin> got a plan for what to write
15:17:39 <jmcarthur> awesome, can't wait
15:17:46 <copumpkin> but no time to write it... but will probably try to cram in something halfassed tonight if I'm not too sleepy
15:19:28 <osaunders> If I said: foo = bar; bar = foo. What is that?
15:19:40 <jmcarthur> _|_
15:20:00 <jmcarthur> infinite loop caused by mutual recursion
15:20:01 <c_wraith> mutual non-termination
15:20:09 <osaunders> Hm, OK.
15:20:11 <jmcarthur> c_wraith said it better
15:22:26 <ivanm> dons: I know it's deprecated, but 6.12 is throwing out a lot of errors with uvector saying that stuff won't work with 6.14; do you know about this?
15:22:39 <b4taylor> Question, I want to provide my own instance for String.
15:23:06 <b4taylor> I have overlapping instances on, but it is still complaining.
15:23:15 <ivanm> b4taylor: for what class?
15:23:20 <b4taylor> Ord.
15:23:20 <ivanm> and what's the error?
15:23:27 <ivanm> b4taylor: you can't, there's already one there
15:23:32 <ivanm> better idea: don't ;-)
15:23:35 <b4taylor> ivanm: I know, is there any way to shadow it?
15:23:49 <benmachine> newtype
15:24:08 <b4taylor> ivanm: Like that Ord does not do length-lexicographic.
15:24:15 <b4taylor> benmachine: Will read up.
15:24:21 <ivanm> yup, newtype it
15:24:36 <copumpkin> length-lexicographic?
15:24:58 <b4taylor> copumpkin: With just lexicographic ordering "aaa" < "ab"
15:25:05 <copumpkin> ah, yeah
15:25:10 <b4taylor> length-lexicographic takes length into account.
15:25:10 <benmachine> b4taylor: you can just ask here!
15:25:23 <benmachine> I am bored and have no social life so I can help
15:25:26 <b4taylor> benmachine: Sure, but learning on one's own is useful :p
15:25:37 <benmachine> if you say so
15:25:48 <b4taylor> benmachine: I want to see what newtype is then I'll come ask :p
15:29:44 <b4taylor> benmachine: Hmmm, can I do something lighter? Wrapping stuff in the newtype constructor is kind of annoying.
15:29:56 <Phyx-> hmmm anyone got some hints on how to make this faster? http://phyx.pastebin.com/615UvUjf i
15:30:08 <Phyx-> i'm sure unboxing the Int would help no?
15:30:35 <benmachine> b4taylor: there isn't really any way to get what you want nor would it really make sense if there was
15:30:52 <benmachine> newtype is not *that* inconvenient, and has a runtime cost of zero
15:31:13 <b4taylor> benmachine: Sure. Someone just asked me if there was a way to do it as lightly as possible.
15:31:17 <b4taylor> benmachine: This is fine though.
15:35:08 <b4taylor> benmachine: Thanks for the help.
15:35:20 <benmachine> any time, sir
15:35:23 <benmachine> or madam
15:35:28 <b4taylor> sir
15:36:13 <Tomas> is there a function like lookup but it does the opposit?
15:37:05 <b4taylor> Tomas: The Prelude lookup?
15:37:25 <b4taylor> Tomas: You want something that looks in the second for the first?
15:38:20 <Rotaerk> lookdown?
15:38:28 <c_wraith> (:)  ?
15:38:28 <medfly> @type lookup
15:38:29 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
15:38:37 <medfly> @hoogle (Eq a) => a -> [(a, b)] -> Maybe a
15:38:37 <lambdabot> Prelude lookup :: Eq a => a -> [(a, b)] -> Maybe b
15:38:38 <lambdabot> Data.List lookup :: Eq a => a -> [(a, b)] -> Maybe b
15:38:38 <lambdabot> Data.Graph.Inductive.Graph lab :: Graph gr => gr a b -> Node -> Maybe a
15:38:43 <medfly> :/
15:38:51 <b4taylor> There's also Data.Map Data.IntSet lookups
15:38:52 <Rotaerk> c_wraith, the smile-by-a-mirror operator?
15:39:09 <Tomas> :)
15:39:19 <b4taylor> @type flip
15:39:22 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
15:39:24 <c_wraith> yes.  I don't use it as much as the robot monkey operator, though.  Which I use quite a lot when converting from ByteString to Lazy ByteString
15:39:39 <c_wraith> :t (:[]) -- robot monkey operator
15:39:47 <lambdabot> forall a. a -> [a]
15:39:53 <b4taylor> Oh nice.
15:39:58 <Tinned_Tuna> sweeet
15:40:54 <Tinned_Tuna> So I guess there are some fairly experienced coders in here?
15:41:07 <medfly> no I just started yesterday
15:41:10 <c_wraith> that would be a fair assumption
15:41:35 <Tinned_Tuna> huzzah for c_wraith... can anyone give me general feed back; like what I'm doing "wrong" and what I'm doing "right"
15:42:01 <ivanm> medfly: you've sure been idling here for a long time if you only actually started using haskell yesterday...
15:42:03 <Phyx-> hoogle Int -> Int#
15:42:10 <Phyx-> > hoogle Int -> Int#
15:42:11 <medfly> it's sarcasm, damn :/
15:42:13 <lambdabot>   <no location info>: parse error on input `->'
15:42:15 <Phyx-> @hoogle Int -> Int#
15:42:16 <lambdabot> Prelude (!!) :: [a] -> Int -> a
15:42:17 <lambdabot> Data.List (!!) :: [a] -> Int -> a
15:42:17 <lambdabot> Data.Sequence index :: Seq a -> Int -> a
15:42:17 <Tinned_Tuna> I've got some working solutions, but I'm new at this whole Haskell mojiggy: http://dannyturner.net/?x=entry:entry100304-143251
15:42:18 <medfly> but I am not experienced
15:42:26 <c_wraith> Tinned_Tuna: Not that I'm the most experienced in here.  But I'll take a look
15:42:28 <ivanm> "mojiggy"?
15:42:33 <Tinned_Tuna> c_wraith: thank you :-)
15:42:33 <Phyx-> lambdabot: no, you're not paying attention!
15:42:43 * hackagebot treemap-html 0.1 - Generates HTML for Data.Tree as TreeMap  http://hackage.haskell.org/package/treemap-html-0.1 (RadoslavDorcik)
15:42:50 <c_wraith> Phyx-: as far as I know, the only way to do that is pattern match
15:42:52 <c_wraith> @src Int
15:42:53 <lambdabot> data Int = I# Int#
15:43:03 <c_wraith> Phyx-: pattern-match on the I# constructor
15:43:07 <Phyx-> c_wraith: i thought so, but i though the type was abstract
15:43:13 <Phyx-> guess I'm wrong
15:43:19 <Phyx-> thanks
15:43:23 <Axman6> you can only pattern match on # constructors i think
15:43:30 <Tinned_Tuna> c_wraith: http://dannyturner.net/?x=entry:entry100304-143251 is my attempt at a few Euler's
15:43:46 <c_wraith> Tinned_Tuna: I'm checking it out
15:44:44 * hackagebot treemap-html-tools 0.1 - Treemap related commands for producing foldable TreeMap HTML.  http://hackage.haskell.org/package/treemap-html-tools-0.1 (RadoslavDorcik)
15:44:58 <c_wraith> Tinned_Tuna: I probably would have named the LCM function in problem 5, but there's nothing wrong with how you did that
15:45:00 <uorygl> > I#
15:45:02 <lambdabot>   Not in scope: data constructor `I#'
15:45:10 <uorygl> @index I#
15:45:11 <lambdabot> GHC.Exts
15:45:16 <uorygl> > GHC.Exts.I#
15:45:17 <lambdabot>   Not in scope: data constructor `GHC.Exts.I#'
15:45:19 <uorygl> ...
15:45:43 <Phyx-> i would think that it would be in GHC.Prim
15:45:44 <c_wraith> Tinned_Tuna: though some of those parens are extra.  "foldr (\a b -> (a*b) `div` gcd a b) 1 [1..20]" suffices.
15:46:04 <Tinned_Tuna> :-)
15:46:21 <Phyx-> i'm actually getting a kind error, "Expected kind `*', but `Int#' has kind `#'"
15:46:35 <medfly> :k Int#
15:46:36 <lambdabot> Not in scope: type constructor or class `Int#'
15:46:42 <medfly> :k (Int#)
15:46:43 <lambdabot> Not in scope: type constructor or class `Int#'
15:46:46 <medfly> ? :o
15:46:57 <Axman6> i would be #
15:47:00 <Axman6> it*
15:47:03 <c_wraith> :t divMod
15:47:04 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
15:47:05 <uorygl> :k (->)
15:47:06 <lambdabot> ?? -> ? -> *
15:47:10 <Phyx-> @pl (map ((\(I# i)->i) . read ) . words)
15:47:10 <lambdabot> (line 1, column 11):
15:47:10 <lambdabot> unexpected "#"
15:47:10 <lambdabot> expecting letter or digit, operator or ")"
15:47:22 <Axman6> Phyx-: you can't do that
15:47:42 <Axman6> things of kind # can't be stored in polymorphic types
15:47:51 <Phyx-> That would explain alot
15:48:06 <copumpkin> they don't have a uniform shape :)
15:48:19 <Phyx-> yes, makes sense
15:48:30 <copumpkin> whole-program compilation could help there
15:48:58 <jmcarthur> speaking of which, i haven't much about lhc or jhc lately
15:49:04 <uorygl> Hmm.  ancilData.c says that sendAncillary() and recvAncillary() are being phased out in favor of sendFd() and recvFd().
15:49:17 <uorygl> Which is a shame, because sendFd() and recvFd() provide precisely the functionality I don't want.
15:49:19 <Phyx-> guess the only way to optimize this code is to drop Lists for Array
15:49:45 <Phyx-> but the list is only traversed once, so don't know if that'll help anyway
15:50:09 <copumpkin> jmcarthur: jhc had a new release a week ago didn't it?
15:50:26 <jmcarthur> it did?
15:50:27 * jmcarthur peeks
15:50:49 <meanburrito920_> didn't jhc have a jvm option at some point? or maybe an extension?
15:51:13 <jmcarthur> not that i know of
15:51:24 <jmcarthur> it generates C and uses a C compiler
15:51:33 <jmcarthur> i don't think jvm would fit in with that
15:51:44 <c_wraith> > let listFromInteger = reverse . f ; f 0 = [] ; f n = let (q, r) = n `divMod` 10 in r : f q in listFromInteger 350
15:51:47 <lambdabot>   [3,5,0]
15:52:01 <copumpkin> unfoldr ftw
15:52:15 <copumpkin> unfoldl even :)
15:52:25 <copumpkin> although r would be nice here
15:52:26 <c_wraith> unfoldl?  eww.
15:52:26 <Tinned_Tuna> c_wraith: =o.O=
15:52:43 <c_wraith> the problem is that our representation is backwards!!!
15:52:49 <copumpkin> yep
15:52:57 <c_wraith> Though for calculating the sum, you don't care if it's in order
15:53:09 <c_wraith> So you could leave out the reverse
15:53:47 <c_wraith> Tinned_Tuna: it's really just the more straightforward divMod breakdown of a number in a given base.
15:53:50 <jmcarthur> anamorphism, baby
15:54:33 <Tinned_Tuna> c_wraith: I really need to practice this stuff more.
15:54:38 <c_wraith> Tinned_Tuna: that's not even a haskell thing.  Just a math thing. :)
15:54:38 <jmcarthur> i wrote a decimal -> roman numeral converter using unfoldr that i kind of liked once
15:54:51 <Axman6> > map (`divMod` 1) [1..10]
15:54:52 <lambdabot>   [(1,0),(2,0),(3,0),(4,0),(5,0),(6,0),(7,0),(8,0),(9,0),(10,0)]
15:55:00 <Tinned_Tuna> c_wraith: in theory, I'm supposed to be good at maths :-p
15:55:58 <uorygl> If some Haskell code needs to refer to the size of a pid_t, say, should I just export sizeof(pid_t) from my C code somehow?
15:56:20 <jmcarthur> mine, but made mo' betta by trs: http://www.reddit.com/r/programming/comments/658ys/how_to_recognise_a_good_programmer/c02w8mr
15:56:39 <c_wraith> Tinned_Tuna: that last line of 20 is interesting.  It's completely correct, and in no way inefficient, but there are lots of choices of idiom to apply there.  First, a straight simplification.  the "print" function is equivalent to "putStrLn . show"
15:57:29 <Tinned_Tuna> so I could just have put "print $ sum $ listFromInteger ..."
15:57:34 <c_wraith> Tinned_Tuna: beyond that, there's a sort of idiom here for not chaining $ operators.  Instead, chain . operators, with a $ only at the end.
15:57:52 <Tinned_Tuna> use more curry.
15:58:09 <c_wraith> Tinned_Tuna: so it could even be "print . sum . listFromInteger $ factorial 100"
15:58:29 <jmcarthur> print . sum . listFromInteger . factorial $ 100
15:58:34 <c_wraith> that too.
15:58:44 <c_wraith> That has more operators total, though. :P
15:58:56 <Tinned_Tuna> I always seem to use the '.' notation wrong :-/
15:58:59 <jmcarthur> yeah but it means you can drop the 100 and make it a parameter for free, if that's what you want
15:59:19 <c_wraith> Tinned_Tuna: . isn't special.  It's just a function
15:59:22 <c_wraith> @src (.)
15:59:22 <lambdabot> (f . g) x = f (g x)
15:59:52 <jmcarthur> f (g x) = (f . g) x = f . g $ x
16:00:16 <Tinned_Tuna> so where I'm just pilling up the brackets, compose my functions with . instead :-)
16:00:23 <c_wraith> exactly
16:00:34 <c_wraith> We like to be anti-lisp in our use of parens. :)
16:00:41 <Tinned_Tuna> :-D
16:00:44 <jmcarthur> to a point
16:01:24 <jmcarthur> > succ . [1..3]
16:01:26 <lambdabot>   [2,3,4]
16:01:29 <jmcarthur> yay caleskell
16:02:03 <c_wraith> also, don't trust lambdabot.  It doesn't use the same libs as ghc does by default. :)
16:02:06 <Tinned_Tuna> :t succ
16:02:08 <lambdabot> forall a. (Enum a) => a -> a
16:02:12 <jmcarthur> :t (.)
16:02:13 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:02:17 <jmcarthur> ^^ is a lie
16:02:20 <Tinned_Tuna> @src succ
16:02:20 <lambdabot> Source not found. Do you think like you type?
16:02:29 <c_wraith> @src Enum
16:02:29 <lambdabot> class  Enum a   where
16:02:29 <lambdabot>     succ                     :: a -> a
16:02:29 <lambdabot>     pred                     :: a -> a
16:02:29 <lambdabot>     toEnum                   :: Int -> a
16:02:29 <lambdabot>     fromEnum                 :: a -> Int
16:02:31 <lambdabot> [3 @more lines]
16:02:45 <c_wraith> succ is one of the functions in the Enum typeclass, so each type has a different implementation
16:02:52 <jmcarthur> @src succ Int
16:02:52 <lambdabot> Source not found. Sorry.
16:02:58 <jmcarthur> @src Int succ
16:02:59 <lambdabot> Source not found.
16:03:00 <danderson> yay, my FFI segfaults \o/
16:03:03 <jmcarthur> bleh
16:03:09 <danderson> so, how do I go about debugging that kind of thing?
16:03:09 <pastorn> danderson: NICE
16:03:13 <pastorn> you go girl!
16:03:23 <jmcarthur> danderson: the same way you debug it in C...
16:03:25 <jmcarthur> :\
16:03:37 <danderson> I know it's my peek implementation that is broken, but some wisdom on how to home in would be nice
16:03:49 <danderson> jmcarthur: with C I have gdb and symbols that let me poke around :/
16:04:00 <Axman6> look at the c ode _really_ hard
16:04:05 <jmcarthur> danderson: try Debug.Trace
16:04:17 <uorygl> Is there a way to search for something in the entirety of Hackage?
16:04:17 <jmcarthur> danderson: or if you are in IO (i guess you are) you can use print
16:04:34 <jmcarthur> @where hayoo
16:04:35 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
16:04:39 <jmcarthur> uorygl: ^^
16:04:46 <danderson> jmcarthur: thanks for the pointers
16:05:01 <jmcarthur> danderson: ghci also has a debugger, but i'm not a fan of it
16:05:09 <jmcarthur> but i'm not a fan of debuggers anyway
16:05:23 <c_wraith> Tinned_Tuna: ok, 29 has a serious redundancy in it.   "[(\a b -> a^b) a b | a <- [2..n], b <- [2..n]]" is the same as " [a^b | a <- [2..n], b <- [2..n]]"
16:05:29 <sm> how current is hayoo with the latest contents of hackage ?
16:06:05 <c_wraith> No need to use a lambda when you're applying both arguments to it on the spot. :)
16:06:07 <jmcarthur> looks fairly up to date
16:06:22 <Tinned_Tuna> ahh, clever :-)
16:06:32 <jmcarthur> Tinned_Tuna: we can get more advanced still, though :)
16:06:38 <Axman6> sm: if it's got definitions for Gloss, then it's very current
16:06:48 <Tinned_Tuna> jmcarthur: =o.O=
16:06:52 <uorygl> jmcarthur: when it says "nothing found yet", does that mean I need to wait a little while?
16:07:01 <jmcarthur> Tinned_Tuna: liftA2 (^) [2..n] [2..]
16:07:06 <jmcarthur> err
16:07:09 <jmcarthur> Tinned_Tuna: liftA2 (^) [2..n] [2..n]
16:07:10 <Tinned_Tuna> before I got the bus home today I was fighting with the type system a little bit :-p
16:07:51 <c_wraith> jmcarthur is getting fancy now.  This is worth learning. :)
16:07:53 <jmcarthur> Tinned_Tuna: and we can reduce the redundancy even more! ... at the expense of some readability:   join (liftA2 (^)) [2..n]
16:08:00 <Axman6> > (^) <$> [2..5] <*> [2..5]
16:08:01 <lambdabot>   [4,8,16,32,9,27,81,243,16,64,256,1024,25,125,625,3125]
16:08:23 <jmcarthur> > join (liftA2 (^)) [2..5]
16:08:24 <lambdabot>   [4,8,16,32,9,27,81,243,16,64,256,1024,25,125,625,3125]
16:08:26 <Tinned_Tuna> jmcarthur: my mind-eyes!
16:08:27 <Axman6> :t ((^) <$>)
16:08:28 <lambdabot> forall a b (f :: * -> *). (Num a, Integral b, Functor f) => f a -> f (b -> a)
16:08:55 <jmcarthur> hmm, when used in this way, join could be infix perhaps. never thought of that before
16:08:56 <danderson> ugh, the .hc output is horrible :(
16:09:08 <jmcarthur> > liftA2 (^) `join` [2..5]
16:09:09 <lambdabot>   [4,8,16,32,9,27,81,243,16,64,256,1024,25,125,625,3125]
16:09:21 <jmcarthur> completely intuitive
16:09:55 <c_wraith> Interesting definition of intuitive. :P
16:10:01 <uorygl> @type liftA2
16:10:02 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
16:10:26 <jmcarthur> c_wraith: i kind of like it, but i can definitely see it confusing a beginner in so many ways
16:10:26 * ddarius completely understands jmcarthur's code, though doesn't like the infix use of join.
16:10:38 <uorygl> > liftA2 (+) [0..9] [10,20,30]
16:10:39 <lambdabot>   [10,20,30,11,21,31,12,22,32,13,23,33,14,24,34,15,25,35,16,26,36,17,27,37,18...
16:10:50 <c_wraith> Oh, I have no trouble reading it.  I'm just...  Not a beginner. :)
16:10:52 <Tinned_Tuna> jmcarthur: yup.
16:11:35 <uorygl> join (liftA2 (^)) [2..n] is indeed unreadable. flip join [2..n] $ liftA2 (^) is much better.
16:12:02 <ddarius> join . liftA2 (^) . enumFromTo 2
16:12:10 <geheimdienst> i have a little package problem ... if i look at cabal info missingh, i see in the "dependencies" field: "base >=4, base <5" and then a few lines later "base <3"
16:12:12 <uorygl> Perfect!
16:12:13 <geheimdienst> what's going on?
16:12:14 <Tinned_Tuna> I'm simulataneously dreading and looking forwards to next year's functional programming module now...
16:12:15 <ddarius> er not quite
16:12:29 <ddarius> join (liftA2 (^)) . enumFromTo 2
16:12:41 <uorygl> Aww. We can't have that.
16:12:44 <Axman6> Tinned_Tuna: you won't learn code like this at a university (luckily imo)
16:13:05 <ddarius> @where squiggol
16:13:05 <lambdabot> I know nothing about squiggol.
16:13:11 <ddarius> Poor lambdabot
16:13:15 <Tinned_Tuna> Axman6: haha :-)
16:13:16 <ddarius> @google Squigol
16:13:17 <lambdabot> No Result Found.
16:13:18 <uorygl> @pl \x -> ($ x)
16:13:18 <lambdabot> flip id
16:13:22 <ddarius> @google Squiggol
16:13:24 <lambdabot> http://comonad.com/reader/category/squiggol/
16:13:24 <lambdabot> Title: The Comonad.Reader » Squiggol
16:13:28 <uorygl> @type join (liftA2 (^)) . enumFromTo 2
16:13:29 <lambdabot> forall b. (Integral b) => b -> [b]
16:14:30 <ddarius> geheimdienst: Look closer.
16:14:51 <c_wraith> @ty (join .) . liftA2 (^) . enumFromTo 2
16:14:52 <lambdabot> forall a b. (Num [a], Integral b, Enum [a]) => [a] -> [b] -> [a]
16:14:56 <c_wraith> oops.
16:14:59 <c_wraith> Did that wrong
16:15:40 <geheimdienst> ddarius, i don't get it. what do you mean?
16:16:14 <jmcarthur> > flip map [2..5] =<< (^) <$> [2..5]
16:16:16 <lambdabot>   [4,8,16,32,9,27,81,243,16,64,256,1024,25,125,625,3125]
16:16:29 <ddarius> :t ($ liftA2 (^)) . flip join . enumFromTo 2
16:16:30 <lambdabot> forall a. (Integral a) => a -> [a]
16:17:04 <jmcarthur> @pl \x -> flip map x =<< (^) <$> x
16:17:04 <lambdabot> ap ((=<<) . flip map) ((^) <$>)
16:17:19 <c_wraith> I don't know how I feel about using join on functions in general.  I mean, yeah, I do it.  But I feel a bit dirty for others who will read my code later.
16:17:21 <Tinned_Tuna> :t >>=
16:17:22 <lambdabot> parse error on input `>>='
16:17:26 <Tinned_Tuna> p-(
16:17:28 <Tinned_Tuna> *:-(
16:17:33 <c_wraith> Tinned_Tuna: need parens
16:17:38 <c_wraith> :t (>>=)
16:17:39 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
16:17:40 <Philonous> :t (>>=)
16:17:41 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
16:17:42 <jmcarthur> > (=<<) . flip map <*> fmap (^) $ [2..5]
16:17:43 <lambdabot>   [4,8,16,32,9,27,81,243,16,64,256,1024,25,125,625,3125]
16:17:56 <Tinned_Tuna> Monads are still impenetrably confusing to me.
16:18:10 <uorygl> Tinned_Tuna: do you know what a type constructor is?
16:18:12 <ddarius> c_wraith: Do you assume the others that will read your code later are beginners?
16:18:18 <c_wraith> Tinned_Tuna: don't worry about it.  It'll come to you eventually.  Trying to force it won't get you anywhere.
16:18:30 <jmcarthur> > (=<<) . flip fmap <*> fmap (^) <<< enumFromTo 2 $ 5
16:18:32 <lambdabot>   [4,8,16,32,9,27,81,243,16,64,256,1024,25,125,625,3125]
16:18:39 <ddarius> :t ($ liftA2 (^)) . runCont return join . enumFromTo 2
16:18:40 <lambdabot>     Couldn't match expected type `Cont r a'
16:18:41 <lambdabot>            against inferred type `a1 -> m a1'
16:18:41 <lambdabot>     In the first argument of `runCont', namely `return'
16:18:44 <jmcarthur> there, maximally beginner unfriendly
16:18:44 <c_wraith> ddarius: In relative experience, yes.  at least initially. :)
16:19:01 <c_wraith> nice use of <<< there
16:19:05 <Tinned_Tuna> c_wraith: I know what you mean, took me ages to go from understanding procedural coding to OOP and it's variations :-p
16:19:09 <Tinned_Tuna> anyways
16:19:33 <Tinned_Tuna> I've got stuff to do tomorrow (eeee, guitars), and it's gone midnight here
16:19:47 <Tinned_Tuna> thank you very much for your help. Doubtless I'll bug you a lot more later :-)
16:19:52 <Tinned_Tuna> g'night.
16:20:44 <ddarius> :t ($ liftA2 (^)) . (runCont . return) join . enumFromTo 2
16:20:45 <lambdabot>     Couldn't match expected type `(m (m a1) -> m a1)
16:20:45 <lambdabot>                                   -> (f a -> f b1 -> f a)
16:20:45 <lambdabot>                                   -> b'
16:21:00 * jmcarthur sees runCont and shudders
16:21:51 <ddarius> Silly me, confusing the transposition of an adjunctions with the unit.
16:22:05 <jmcarthur> a common mistake
16:22:12 <Axman6> do it all the time
16:22:12 <pikhq> jmcarthur: runCont isn't inherently evil.
16:22:27 <uorygl> What's an adjunction?
16:22:29 <sm> Axman6: I don't think it knows about Gloss
16:22:29 <pikhq> That said, a hell of a lot of the code using it makes Cthulhu weep.
16:22:30 <jmcarthur> pikhq: no, i was shuddering because my beginner unfriendliness is about to be beaten
16:22:40 <pikhq> jmcarthur: Ah.
16:22:48 <sm> so no hayoo experts hang out here eh
16:22:56 <pikhq> Yeah, that is quite a bit less beginner friendly. :)
16:22:58 <jmcarthur> what's a hayoo expert?
16:24:01 * sm wonders when hoogle will finally absorb hackage and become all-knowing
16:24:32 <jmcarthur> uorygl: every monad is constructed from an adjunction of two functors (but many of these functors are not expressible in haskell even though the monad they form may be)
16:24:36 <sm> jmcarthur: I'm thinking of one of the implementors, or someone who uses it enough to know how current it tends to be
16:24:49 <ddarius> :t ($ liftA2 (^)) . (runCont . (. return) . fmap) join . enumFromTo 2
16:24:50 <lambdabot>     Couldn't match expected type `Cont ((f a -> f b1 -> f a) -> b) a1'
16:24:51 <lambdabot>            against inferred type `a2 -> m a2'
16:24:51 <lambdabot>     In the second argument of `(.)', namely `return'
16:24:54 <uorygl> jmcarthur: that doesn't tell me what an adjunction is.
16:24:57 <jmcarthur> sm: it seems pretty current to me. i just found a bunch of stuff about vector in it
16:25:07 <sm> good to know
16:25:19 <jmcarthur> uorygl: i'm not smart enough to even tell you what a monad is
16:25:35 <c_wraith> Speaking of monads, I could go for mexican food for dinner.
16:25:54 <uorygl> jmcarthur: maybe I'm smart enough to understand what you're talking about even if you don't!
16:26:29 <ddarius> uorygl: An adjunction is a triple of two functors, F and U, and a natural isomorphism, φ : Hom(FA,B) -> Hom(A,UB) natural in A and B.
16:26:54 <jmcarthur> i think today is hurt-peoples-brains day
16:27:03 <uorygl> ddarius: what does Hom denote?
16:27:12 <ddarius> This is usually written F ⊣ U with the φ implicit even though the φ is the crucial part.
16:27:53 <ddarius> uorygl: The Hom-set functor for the (implicitly) provided category, i.e. Hom(X,Y) is the set of morphisms, or arrows, between the objects X and Y.
16:28:25 <uorygl> What's the etymology of "Hom" there?
16:28:27 <twink> Kind of like <Ax,y>=<x,A^*y>
16:28:29 <ddarius> uorygl: When pretending that Haskell forms a category, Hom is (->).
16:28:41 <ddarius> uorygl: It's an abbreviation of "homomorphism."
16:29:18 <jmcarthur> you could even make an argument that Hom could be a Category, perhaps
16:29:30 <lament> c_wraith: a burrito is just a monoid object in the category of endofunctors on mexican food...
16:29:38 <uorygl> In Haskell language, does this mean that functors F and U are adjoint if there's an isomorphism (F a -> b) -> a -> U b?
16:29:48 <ddarius> jmcarthur: Calling the type (constructor) variable of the Category class "hom" makes sense.
16:30:02 <ddarius> uorygl: Yes.
16:30:12 <jmcarthur> ddarius: indeed it does
16:30:42 * uorygl ponders adjoint functors.
16:31:55 <ddarius> uorygl: Consider curry and uncurry.
16:32:02 <uorygl> Hang on.
16:32:05 <uorygl> I'm still pondering.
16:32:34 <jmcarthur> uorygl: here's something with some haskell syntax that might help a little http://comonad.com/reader/2008/kan-extensions-ii/
16:32:43 <uorygl> My intuition says that [] doesn't have a neat right adjoint functor, but it does have a neat left adjoint functor, which is along the lines of...
16:32:59 <cYmen> Where do I look up the behavior of foldl?
16:33:13 <Axman6> @src foldl
16:33:14 <lambdabot> foldl f z []     = z
16:33:14 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
16:33:15 <uorygl> Well, along the lines of (,) Natural.
16:33:25 <Axman6> > foldl f z [a,b,c]
16:33:26 <lambdabot>   f (f (f z a) b) c
16:33:52 <uorygl> I guess if you replace [] with Stream, you do get a pair of adjoint functors.
16:34:14 <ddarius> uorygl: Indeed.  Look at curry and uncurry.  That is -directly- relevant to that example.
16:34:15 <uorygl> Because there's an isomorphism ((Natural, a) -> b) -> a -> Stream b.
16:34:33 <uorygl> Okay, curry and uncurry.
16:34:48 <uorygl> :t curry
16:34:49 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
16:35:06 <uorygl> Ah, of course.
16:35:21 <uorygl> To abuse notation, the adjoint functors here are (, b) and (b ->)?
16:35:33 <jmcarthur> uorygl: yup :)
16:35:41 <jmcarthur> uorygl: and they form the State monad!
16:35:41 <ddarius> uorygl: Yes.
16:35:57 <uorygl> They form the State monad.  Wow.
16:35:59 <ddarius> uorygl: Incidentally, representing Stream a = Natural -> a we get your example.
16:36:05 <uorygl> Right.
16:36:26 <uorygl> See, why the heck am I going to college when I can figure out what an adjoint functor is in ten minutes?  :P
16:36:59 <uorygl> So, is there a nice way to write the State monad operations using curry and uncurry?
16:37:11 <Axman6> to prove you can do useful things ;)
16:37:15 <ddarius> :t curry id
16:37:16 <lambdabot> forall a b. a -> b -> (a, b)
16:37:16 <jmcarthur> uorygl: the link i gave you earlier explains it
16:37:21 <ddarius> :t uncurry id
16:37:22 <lambdabot> forall b c. (b -> c, b) -> c
16:37:32 <ddarius> :t runState . return
16:37:33 <lambdabot> forall s a. a -> s -> (a, s)
16:38:04 <ddarius> :t fmap (uncurry id)
16:38:05 <lambdabot> forall b c (f :: * -> *). (Functor f) => f (b -> c, b) -> f c
16:38:11 <jmcarthur> Axman6: staying in college proved that i should have gone to a different college
16:38:28 <uorygl> To prove that what I can do in ten minutes I can also do in twelve hours.
16:39:01 <uorygl> I should just change my nick to uorygl[HireMe] and hang out in this channel instead.  :P
16:39:02 <Axman6> jmcarthur: i'm going to the best university in the country, and they taught me haskell. I think i've found the right place :D
16:39:14 <jmcarthur> Axman6: i'm jealous
16:39:21 <ddarius> :t runState . join . State . fmap (fmap State)
16:39:22 <lambdabot> forall a s a1. (State s a1 -> (State (State s a1) a, s -> (a1, s))) -> State s a1 -> (a, State s a1)
16:39:29 <cYmen> hm...writing this transpose function is a bitch
16:39:42 <uorygl> Axman6: I want to go there, even if "the country" is not the same country as my country.  :P
16:39:45 <jmcarthur> uorygl: if only it was so simple
16:40:00 <Axman6> uorygl: you want to come to my country, trust me :P
16:40:38 <uorygl> I wonder what country is your country.
16:42:32 <Axman6> Australia
16:42:45 <tomberek> how can I search #haskell logs?
16:42:49 <uorygl> That doesn't sound like too bad a country.
16:42:56 <ddarius> Stupid State monad and having the tuple in the wrong order.
16:43:38 <uorygl> Is there much censorship over there?  I've heard bad things about how Australia deals with... uh, video games.
16:44:29 <Axman6> we're working on it
16:45:19 <tomberek> no way to bring up a log of #haskell conversations?
16:45:38 <uorygl> tomberek: well, there are logs at http://tunes.org/~nef/logs/haskell/
16:46:16 <tomberek> thanks
16:46:45 <dobblego> Australia is a fucking disgrace; which is why I am in Singapore at the moment
16:47:48 <Axman6> you left us?
16:48:14 <dobblego> not for good, unfortunately
16:48:19 <dobblego> long story
16:48:27 <uorygl> I judge English-speaking countries by their accents.  Australia has a pretty neat accent, so I think of it as a pretty neat country.
16:48:45 <pikhq> uorygl: That's a poor way to judge things.
16:48:54 <uorygl> I know.
16:51:14 <ddarius> It's an excellent way to judge accents.
16:53:48 <uorygl> True.
16:54:03 <uorygl> In fact, in general, it's a really good idea to judge something by itself.
16:54:51 <uorygl> I mean, how often does someone give you the advice to never judge a book by its book?
16:55:02 <uorygl> @src Cont (>>=)
16:55:02 <lambdabot> m >>= k  = Cont $ \c -> runCont m $ \a -> runCont (k a) c
16:55:50 <ddarius> uorygl: If you want a tricky example of an adjoint, consider flip (which is its own inverse).
16:55:59 <uorygl> :t flip
16:56:00 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
16:56:07 * uorygl coughs.
16:56:13 <ddarius> Um, not that flip...
16:56:16 <uorygl> Yer.
16:56:19 <ddarius> :t Prelude.flip
16:56:20 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
16:57:00 <dolio> ddarius: You mentioned a while back that you don't consider dependent types an unambiguous next step for Haskell, since extensions to it tend to involve polymorphism/parametricity rather than dependency...
16:57:04 <uorygl> So (a ->) is an adjoint functor of itself?
16:57:27 <dolio> Does that apply to pi vs. forall? Or is it more on the existential/inductive end of things.
16:58:00 <ddarius> uorygl: Close but no cigar.
16:58:29 <uorygl> I hope I haven't already forgotten what an adjoint functor is.
16:58:41 <dolio> I'm having difficulty coming up with examples where pi, when restricted to kind-like quantification, wouldn't give you the same parametricity guarantees as forall, assuming there's no type case or the like.
16:59:47 <uorygl> Oh, duh.  I was reading a -> b -> c as (a -> b) -> c.  :P
17:01:12 <uorygl> So, that's a -> (b -> c) and b -> (a -> c)...
17:01:15 <ddarius> dolio: Are you trying to say that pi types strictly generalize parametrically polymorphic types?
17:01:19 <uorygl> I'm not seeing it.
17:01:39 <ddarius> uorygl: It's tricky.  You have to go a bit out of the normal Haskell "category."
17:02:15 <uorygl> All I'm coming up with is the idea of a magical swap-a-and-b functor.
17:02:35 <uorygl> Oh, hang on.
17:02:37 <twink> \(x,y) -> (y,x) ?
17:03:09 <uorygl> Apply one functor to (b -> c) and you get (a -> c); apply the other functor to b and you get a?
17:03:29 <uorygl> The right functor and the left functor, respectively.
17:03:50 <ddarius> uorygl: The functors are already in the type of flip.
17:04:16 <uorygl> I think I'm stumped.
17:04:38 <dolio> ddarius: I'm not sure about it. But I haven't come up with a counter-example yet.
17:05:25 <ddarius> uorygl: (a -> b) is functorial in b, i.e. \b.(a -> b) is a functor, what is it in a or what is (-> b).  It's not a Haskell Functor (with a capital F), but ...
17:05:29 <twink> I thought pi types had to do with predicativity, not parametricity.
17:06:52 <ddarius> dolio: Well, certainly when you talk about impredicative polymorphism, forall a : Set is not the same as for all types a unless Set : Set.
17:07:18 <uorygl> I'm still not seeing anything.
17:08:34 <ddarius> uorygl: The adjunction is (-> c)^op ⊣ (-> c) where the (-> c) :: Hask^op -> Hask (and (-> c)^op :: Hask -> Hask^op).
17:08:47 <ddarius> Hask^op having the same arrows as Hask but going the opposite direction.
17:09:39 <ddarius> Writing Hask(A,B) as a more explicit version of Hom(A,B), flip :: Hask^op(b -> c, a) -> Hask(a, b -> c)
17:11:01 <uorygl> So, every monad is an adjunction of two functors?
17:11:13 <uorygl> Is there a way to write these functors in terms of the monad?
17:11:20 <ddarius> uorygl: Yes, every monad can be decomposed into an adjunction but not uniquely.
17:11:29 <dolio> ddarius: Existentials and sigma types have a more obvious (to me) difference, for instance, in that the former give you a sort of abstraction (via the quantified type being opaque) that the latter lacks.
17:11:37 <ddarius> uorygl: Not in general because the decomposition is not unique.
17:11:47 * uorygl nods.
17:12:02 * uorygl goes off to ponder a bit.
17:12:29 <dolio> But I think that's due to weak sum vs. strong sum, and I don't know of a corresponding distinction for products.
17:13:15 <Polarina> Can someone direct me to nice article on tricks used to make ray-tracing fast?
17:13:19 <Polarina> efficient*
17:13:41 <ddarius> @google Real-time raytracing
17:13:41 <ivanm> what are you doing ray tracing for?
17:13:42 <lambdabot> http://www.realstorm.com/
17:13:43 <lambdabot> Title: Web Site Currently Not Available
17:13:46 <ddarius> Curses
17:13:56 * ivanm doesn't get the obsession that comes up every few montsh about people wanting to do ray tracing
17:13:58 <Polarina> ivanm, photo-realistic graphics.
17:14:07 <ivanm> hmmm
17:14:13 <ivanm> use photos? :p
17:14:19 <Polarina> Artifical.
17:15:12 <iaefai> What was the method of doing a double ^ double
17:15:25 <ddarius> Polarina: http://www.sci.utah.edu/~wald/Publications/2006///IT2006/download//it2006.pdf and other stuff on http://www.sci.utah.edu/~wald/Publications/
17:15:56 <ddarius> Polarina: That discusses what you need to do after you've done the algorithmic stuff of which there is tons and tons of work on various aspects of that.
17:16:04 <ddarius> @google Manhattan Light Transport algorithm
17:16:05 <lambdabot> http://en.wikipedia.org/wiki/Monte_Carlo_method
17:16:05 <lambdabot> Title: Monte Carlo method - Wikipedia, the free encyclopedia
17:16:36 <ddarius> @google "Manhattan Light Transport" algorithm
17:16:37 <lambdabot> No Result Found.
17:17:16 <Cale> iaefai: (**)
17:17:22 <ddarius> Ah
17:17:31 <ddarius> @google "Metropolis Light Transport" algorithm
17:17:32 <lambdabot> http://en.wikipedia.org/wiki/Metropolis_light_transport
17:17:32 <lambdabot> Title: Metropolis light transport - Wikipedia, the free encyclopedia
17:17:43 <iaefai> merci
17:18:14 <ivanm> I notice lambdabot is once again giving web page titles \o/
17:19:03 <iaefai> I swear apple didn't test numbers before they released it. 2 separate bugs in as many hours
17:19:56 <danderson> what do I need in my .cabal file to support building .hsc modules?
17:20:19 <danderson> right now, it's complaining that it can't find the module (because it needs to run hsc2hs and doesn't try)
17:22:31 <Cale> iaefai: apple?
17:22:59 <iaefai> Cale, you know their spreadsheet application?
17:23:42 <danderson> My current cabal file is at https://bitbucket.org/danderson/tunskell/src/tip/tunskell.cabal , if anyone has wisdom.
17:26:56 <Cale> iaefai: oh, I'd sort of assumed you were talking about something Haskell-related :)
17:27:15 <iaefai> Cale, I was using ghci to troubleshoot a problem in Numbers :p
17:27:27 <iaefai> ghci is the best calculator I have
17:28:27 <Cale> Yeah, Haskell programs make better spreadsheets than spreadsheets tend to :)
17:28:53 <jcreigh> a spreadsheet program that accepts Haskell expressions.
17:28:56 <jcreigh> best. idea. ever.
17:29:05 <ddarius> jcreigh: See Vital.
17:29:12 <iaefai> I was observing how Numbers seems to have a ton of bugs in it related to the form of specifying cells = Header Row
17:29:16 <iaefai> Vital?
17:29:21 <ddarius> @where vital
17:29:21 <lambdabot> http://www.cs.kent.ac.uk/projects/vital/
17:30:17 <iaefai> sweet
17:31:31 * iaefai is scared away by java
17:31:52 <iaefai> This is also 6 years old
17:32:04 <iaefai> Might be useful though
17:32:40 <jcreigh> geez, why can't swing use native widgets like everyone else?
17:32:47 <jcreigh> Java thinks it's so special...
17:34:30 <jcreigh> But kinda neat.
17:34:57 <jcreigh> So they must have written some basic version of Haskell just for this app? Or is there a java implementation that they could just embed?
17:35:17 <iaefai> The one feature I do want in a spreadsheet is the ability to add functions to it.
17:35:31 <danderson> aha, figured it out.
17:35:45 <iaefai> lotus improv would be a nice thing to have
17:36:49 <jcreigh> iaefai: I think any major spreadsheet application has that functionality. (Open Office Calc, Excel, etc.)
17:36:56 <jcreigh> iaefai: might not be in a language you want to write in. :)
17:37:05 <iaefai> jcreigh: That is usually the problem
17:37:11 <iaefai> I also don't like Calc or Excel
17:37:25 <jcreigh> iaefai: oh? What do you use instead?
17:37:53 <iaefai> http://www.apple.com/iwork/numbers/
17:38:35 <jcreigh> ah. I saw your reference to "Numbers" earlier, but I didn't know what it was.
17:38:50 <iaefai> Imagine trying to search for help on the product via google
17:39:17 <Adamant> I think Keynote is great, but Pages has enough problems and you would have to pay me to use Numbers if my job actually required me to use a spreadsheet all day.
17:40:45 <jcreigh> iaefai: well, I would imagine that Apple can probably make something more userfriendly that either Microsoft or else OpenOffice devs trying to copy Microsoft. Is that the case?
17:41:06 <iaefai> jcreigh: For the most part
17:41:19 <iaefai> Adamant: It is great for small jobs
17:41:33 <Adamant> iaefai: I can buy that
17:41:58 <iaefai> jcreigh: One big problem with Numbers is that I can't figure out a way to edit a cell with the keyboard
17:42:31 <jcreigh> iaefai: you're kidding. I mean, there must be a way, right?
17:43:07 <iaefai> jcreigh: You would think, but remember apple is mouse company
17:43:59 <iaefai> But there is one good point to it, I don't know if you can do this in excel, but in this debt planning thing I am doing right now, the amount of a certain debt I put in the cell as: Principle*(1+Interest Rate/365)^(365/12)-Payment
17:43:59 <jcreigh> iaefai: Google says Option-Return...does that work?
17:44:09 <iaefai> yes it does
17:44:12 <iaefai> You are good :p
17:44:28 <iaefai> So I can put names in the headers and reference them that way
17:47:25 <uorygl> @docs Control.Comonad
17:47:25 <lambdabot> Control.Comonad not available
17:47:31 <uorygl> Maybe that module doesn't exist.
17:49:27 <twink> iaefai: I guess it beats all the calendrics you'd need with continuous compounding.
17:49:36 * uorygl ponders whether any of IO's corresponding comonads is neat or not.
17:49:44 <iaefai> calendrics?
17:50:02 <iaefai> I am only doing my bestto estimate interest :p
17:50:37 <ddarius> uorygl: IO is not an adjunction and the canonical decompositions of it into an adjunction are not going to provide terribly interesting comonads.
17:50:37 <uorygl> Here's a non-horrible definition of IO: data IO a = Return a | Output Int (IO a) | Input (Int -> IO a)
17:50:54 <uorygl> ddarius: there are canonical ones?
17:51:26 <twink> iaefai: There's some formulas for the interest no matter how much time is between two points in time. When you use those, leap years, the different numbers of days in each month, etc. matter.
17:51:44 <ddarius> uorygl: Yes.  The Kleisli decomposition and the Eilenberg-Moore decomposition.  They are the initial and final (respectively?) adjunctions in a certain category.
17:51:45 <iaefai> yeah no doubt
17:51:56 <iaefai> I don't know what is what in the cryptic formulas in this thing
17:52:10 <uorygl> Huh.
17:52:43 <iaefai> Int his thing a day here and a day there won't mean much difference for paying stuff off
17:53:04 <twink> iaaefai: It looks like it's assuming the months divide the 365-day year evenly, so it raises the daily interest rate to the 365-th power and then takes the 12-th root of that.
17:53:58 <ddarius> uorygl: These examples are vaguely like having the canonical factors of 24, 1 & 24.
17:54:04 <twink> iaefai: Not sure why it bothers with a daily interest rate instead of just an annual or monthly one.
17:54:18 <uorygl> Are those decompositions easy to explain?
17:54:30 <uorygl> Do they set one functor to the identity functor?
17:54:54 <iaefai> twink: I did that, a daily compounding does add up over the period of years I am planning for
17:54:58 <uorygl> ...I'm not sure that would work very well.  :P
17:55:03 <ddarius> The Kleisli decomposition is really easy, the other is not so easy simply because there is a lot more that needs to be defined, it isn't particularly hard otherwise.
17:55:31 <twink> iaefai: How about leap years?
17:55:34 <uorygl> What's the Kleisli decomposition, then?
17:55:54 <iaefai> There is a maximum of 1 day that could occur in my time period
17:58:04 <twink> iaefai: It mostly looks like they want a monthly interest rate which would be monthlyInterestRate = (1+InterestRate)**(365/12)-1
17:58:32 <ddarius> Let T be a monad on a category C, so T : C -> C.  Define the Kleisli category C_T on C as the category whose arrows a -> b are arrows a -> T b in C (id = return composition = (<=<)).  Let U : C_T -> C be U(A) = A, U(f) = f.  Let F : C -> C_T be F(A) = TA, F(f) = Tf.  Then F ⊣ U and T is the monad UF induced by that adunction.
17:59:12 <iaefai> twink: Who is 'they'? I am doing all the calculations myself.
17:59:37 <twink> iaefai: Whoever's specifying all this.
17:59:49 <iaefai> I am
18:00:25 <twink> iaefai: Hmm. What are you trying to do?
18:00:40 <MadHatterDude> Hey, what exactly is syntactically wrong with "(Func f) -> if f $ head str then fmap (head str :) (match p $ tail str) else Nothing" in a case expression it gives me a "parse error on input '('"
18:00:43 <ddarius> uorygl: Er, I might have switched U and F a bit.
18:00:45 <iaefai> twink: Financial planning, how to work out to get rid of 12k debt over 4 years
18:01:36 <iaefai> The more of a plan I have the stress disappears :p
18:02:02 <twink> iaefai: There are formulas for this. You want the balance at the end of the period to be 0, and the balance obeys b(n+1) = b(n)*(1+monthlyInterestRate) - payment, right?
18:02:58 <iaefai> I can't say that, because you are calculating simple interest only
18:05:35 <twink> If b(0) = principal then (B(z)-principal)/z = B(z)*(1+monthlyInterestRate) - payment/(1-z) for B(z)*(1/z-(1+monthlyInterestRate)) = principal/z - payment/(1-z) and B(z) = (principal*(1-z)-payment*z)/((1-z)*(1-(1+monthlyInterestRate)*z))
18:06:20 <cads> Hey, I've got a list comprehension where for a natural number n I'm generating {(x,y,z) in N+^2 | x <= y <= z, z <= n}.
18:06:26 <cads> this translates to
18:07:05 <cads> > let a = [1..n]; f n = [(x,y,z) | x <- a, y <- a, z <- a, x <= y, y <= z ]  in f 3
18:07:06 <lambdabot>   * Exception: not a number
18:07:31 <Axman6> o.O
18:07:41 <cads> > let f n = [(x,y,z) | x <- a, y <- a, z <- a, x <= y, y <= z ] where a = [1..n] in f 3  -- will this work?
18:07:41 <uorygl> > let a = [1..n]; f n = [(x,y,z) | x <- a, y <- a, z <- a, x <= y, y <= z ]  in f 3
18:07:42 <lambdabot>   [(1,1,1),(1,1,2),(1,1,3),(1,2,2),(1,2,3),(1,3,3),(2,2,2),(2,2,3),(2,3,3),(3...
18:07:42 <lambdabot>   * Exception: not a number
18:07:46 <uorygl> Grr.
18:08:10 <uorygl> > let a = [1..?n]; f n = let ?n = n in [(x,y,z) | x <- a, y <- a, z <- a, x <= y, y <= z ]  in f 3
18:08:11 <lambdabot>   Not in scope: `..?'
18:08:22 <uorygl> > let a = [1.. ?n]; f n = let ?n = n in [(x,y,z) | x <- a, y <- a, z <- a, x <= y, y <= z ]  in f 3
18:08:23 <lambdabot>   Unbound implicit parameter (?n::t)
18:08:24 <lambdabot>    arising from a use of implicit parame...
18:08:31 <uorygl> Aww.
18:08:33 <cads> the a is not bound to the same n as in f's definition
18:09:12 <twink> iaefai: I think it comes out as principal*(1+monthlyInterestRate)**48 = payment*((1+monthlyInterestRate)^(48+1)-1)/monthlyInterestRate I think.
18:11:04 <cads> Anyways, I have two questions. First, how are the tuples generated? That is, does it cycle through the values of x first before incrementing y and eventually z, or is it vice versa?
18:11:15 <Axman6> hmm, what do you all think of having a syntax in list comprehensions like so: [... | a,b <- xs], which would be the same as [.. | a <- xs, b <- xs]?
18:11:39 <cads> Heh, that's my second question :)
18:13:30 <cads> Or some kind of product constructor that'd let you write  [... | (a,b,c) <- xs^3], where xs^n would denote the list of n-tuples written from xs' elements.
18:14:24 <Axman6> i think that's unnecessary
18:14:30 <cads> Probably :)
18:14:34 <Axman6> also, it should not use tuple syntax
18:14:46 <Axman6> otherwise you can't then match on tuples
18:15:38 <ddarius> uorygl: Bah, the Eilenberg-Moore construction has the trivial looking adjoint.  U(A) = TA, U(f) = join . fmap f (or = µ . Tf) and F(A) = A, F(f) = return . f (or = η . f).
18:15:52 <iaefai> twink: That is the approximate formula I have
18:16:22 <ddarius> uorygl: So, C_T(FA,B) = C(A,TB) = C(A,UB)
18:16:31 <cads> > test n = [(a,b) | a, b <- [1..n]] in test 3
18:16:32 <lambdabot>   <no location info>: parse error on input `='
18:16:44 <uorygl> We need a version of Haskell that supports all categories, not just Hask!
18:16:54 <twink> iaefai: I think it comes out as payment = principal*monthlyInterestRate*(1+monthlyInterestRate)**48/((1+monthlyInterestRate)^49-1)
18:19:55 <osaunders> The headless stick man operator (<-<) can be given a head by applying it with zero or a variable o (o<-<).
18:20:19 <uorygl> Which makes me think I should learn category theory.
18:20:38 <ezyang> uorygl: Learn category theory with me!
18:20:55 <osaunders> What's Hask?
18:20:56 <ezyang> I'm currently attempting to figure out what a Cayley representation is.
18:20:57 <uorygl> ezyang: only if I'm allowed to do it in an extremely ad-hoc manner.
18:21:04 <uorygl> osaunders: I think it's the category of Haskell types.
18:21:27 <osaunders> Was Hask named after Haskell or is that just a massive coincidence?
18:21:31 * ddarius thinks Yoneda is actually simpler than the Cayley representation even though the latter is a special case of the former.
18:21:34 <ezyang> named after haskell
18:21:39 <osaunders> Ok.
18:21:48 <ezyang> ddarius: O.o
18:22:02 <uorygl> ddarius: don't general things tend to be simpler than specific things?
18:22:16 <uorygl> Most natural numbers are more complicated than the set of all natural numbers.
18:22:27 <dmwit> uorygl: No fair, you have a long head start.
18:22:35 <ddarius> uorygl: Depends on your notion of "simpler."
18:23:00 <ddarius> uorygl: It's easier to see x + x = x + x than x + y = y + x.
18:23:19 <osaunders> uorygl: The easiest things to understand are usually the most relatable or familiar.
18:23:31 <uorygl> Well, it's easier to prove a specific thing than to prove a general thing.
18:23:39 <uorygl> Or, at least, only a constant amount harder.
18:24:20 <ddarius> uorygl: In theory yes, often times though details get in the way.  Also, having more structure available often makes the search space for proofs much larger.
18:24:22 <osaunders> More general is usually more abstract. Abstract has a reputation for being harder.
18:24:49 <ezyang> I dunno, all this talk about objects and arrows seems pretty simple to me 8)
18:25:05 <ezyang> More seriously, I think the /implications/ of really abstract systems are what really bugger people.
18:25:17 <ddarius> ezyang: Categories were invented to define functors which were invented to define natural transformations.
18:25:52 <MadHatterDude> Pointfree code is amazing
18:26:10 <osaunders> Aye.
18:26:19 <Axman6> MadHatterDude: only if used correctly
18:26:26 <MadHatterDude> Axman6: True
18:26:42 <Axman6> when it's abused, it makes life a hell of a lot harder for other people reading your code
18:26:53 <MadHatterDude> Axman6: Yeah
18:26:57 <osaunders> @pl f x y = x + 1 - y / x
18:26:57 <lambdabot> f = ap ((.) . (-) . (1 +)) (flip (/))
18:27:07 <Axman6> lovely
18:27:33 <Axman6> @pl \q w e r t y u i o p -> t y p e w r i t e r
18:27:36 <lambdabot> const ((((((const . (const .)) .) .) .) .) . flip flip id . ((ap . ((flip . (flip .)) .)) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . join . (flip .) . ((flip .) .) . (((flip .) .) .) . ((
18:27:36 <lambdabot> ((flip .) .) .) .) . (((((flip .) .) .) .) .) . flip flip id . (flip .) . ((ap .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((flip .) .) .) .) . (flip .) . ((flip .)
18:27:36 <lambdabot>  .) . (((flip .) .) .) . flip (flip . (flip .) . ((flip .) .) . flip (flip . (flip .))))
18:27:36 <lambdabot> optimization suspended, use @pl-resume to continue.
18:27:39 * Axman6 runs
18:27:43 <ezyang> bargh
18:27:48 <Axman6> XD
18:27:52 <osaunders> lol
18:28:13 <MadHatterDude> @pl (\x y -> fmap (++) x <*> y)
18:28:13 <lambdabot> (<*>) . fmap (++)
18:28:26 <Axman6> benl had a good one, it was relly short, but rediculously long, either to @pl or :t, can't remember which
18:28:55 <ddarius> It's really easy to make terms with exponentially large types.
18:29:09 <osaunders> Oh, I've just had an idea.
18:29:24 <dolio> @type let f0 x = (x,x) ; f1 = f0 . f0 ; f2 = f1 . f1 in f2
18:29:25 <lambdabot> forall t. t -> ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t))))
18:29:33 <osaunders> How about a website where you keep a record of what you're learning and you can see other people at a similar place to you.
18:29:36 <cads> uorygl: Your comment about programming with general categories reminded me of these lecture notes I read: http://physics.bu.edu/~youssef/homepage/talks/categories/01.html
18:29:43 <osaunders> And then talk with them on IRC.
18:30:27 <Axman6> :t @type let { x1 = \y -> \z -> z y y; x2 = \y -> x1 (x1 y); x3 = \y -> x2 (x2 y); x4 = \y -> x3 (x3 y) } in x4 (\z -> z)
18:30:28 <lambdabot> parse error on input `@'
18:30:35 <Axman6> :t let { x1 = \y -> \z -> z y y; x2 = \y -> x1 (x1 y); x3 = \y -> x2 (x2 y); x4 = \y -> x3 (x3 y) } in x4 (\z -> z)
18:30:36 <lambdabot> forall t t1 t2 t3 t4 t5 t6 t7 t8. ((((((((((((((((t -> t) -> (t -> t) -> t1) -> t1) -> (((t -> t) -> (t -> t) -> t1) -> t1) -> t2) -> t2) -> (((((t -> t) -> (t -> t) -> t1) -> t1) -> (((t -> t) -> (
18:30:36 <lambdabot> t -> t) -> t1) -> t1) -> t2) -> t2) -> t3) -> t3) -> (((((((t -> t) -> (t -> t) -> t1) -> t1) -> (((t -> t) -> (t -> t) -> t1) -> t1) -> t2) -> t2) -> (((((t -> t) -> (t -> t) -> t1) -> t1) -> (((t -
18:30:36 <lambdabot> > t) -> (t -> t) -> t1) -> t1) -> t2) -> t2) -> t3) -> t3) -> t4) -> t4) -> (((((((((t -> t) -> (t -> t) -> t1) -> t1) -> (((t -> t) -> (t -> t) -> t1) -> t1) -> t2) -> t2) -> (((((t -> t) -> (t ->
18:30:36 <lambdabot> t) -> t1) -> t1) -> (((t -> t) -> (t -> t) -> t1) -> t1) -> t2) -> t2) -> t3) -> t3) -> (((((((t -> t) -> (t -> t) -> t1) -> t1) -> (((t -> t) -> (t -> t) -> t1) -> t1) -> t2) -> t2) -> (((((t -> t)
18:30:36 <lambdabot> -> (t -> t) -> t1) -> t1) -> (((t -> t) -> (t -> t) -> t1) -> t1) -> t2) -> t2) -> t3) -> t3) -> t4) -> t4) -> t5) -> t5) -> (((((((((((t -> t) -> (t -> t) -> t1) -> t1) -> (((t -> t) -> (t -> t) ->
18:30:38 <lambdabot> [32 @more lines]
18:30:43 <MadHatterDude> :t \a d e r s t w -> s t e w a r d e s s e
18:30:44 <lambdabot>     Occurs check: cannot construct the infinite type:
18:30:44 <lambdabot>       t = t5 -> t3 -> t6 -> t1 -> t4 -> t2 -> t3 -> t -> t -> t3 -> t7
18:30:46 <cads> uorygl, It's not haskell, but it's gives some neat examples of crazy math structures dudes like that guy would have us programming with, before jumping right over my head :)
18:30:46 <lambdabot>     Probable cause: `s' is applied to too many arguments
18:31:00 <osaunders> This is madness.
18:31:03 <osaunders> MADNESS!
18:31:20 * osaunders waits.
18:32:09 <cads> osaunders: that would be a great website
18:32:14 <dmwit> fail troll
18:32:25 <osaunders> cads: Thank you! :-)
18:33:10 <MadHatterDude> @pl \x y z u -> z =<< x <*> fmap u y
18:33:10 <lambdabot> (flip ((.) . (=<<)) .) . (. flip fmap) . (.) . (<*>)
18:36:27 <osaunders> Maybe it would be good as a facebook app.
18:37:04 <osaunders> Only having to have a facebook account would be a big limitation so a facebook app would probably have some be just as an add-on to the main site.
18:38:03 <MadHatterDude> @pl map
18:38:04 <lambdabot> map
18:38:10 <MadHatterDude> damnit
18:39:23 <MadHatterDude> @pl let m f [] = []; m f (x:xs) = f x : m f xs in m
18:39:24 <lambdabot> (line 1, column 9):
18:39:24 <lambdabot> unexpected "["
18:39:24 <lambdabot> expecting pattern or "="
18:41:36 <osaunders> @pl m f (x:xs) = f x : m f xs
18:41:36 <lambdabot> m = fix (flip flip tail . (ap .) . flip flip head . ((.) .) . liftM2 flip (((.) . (:)) .))
18:42:08 <MadHatterDude> I just did a "f0 x = (x,x); f1 = f0 . f0" up to 4 and printed the result... not pretty
18:43:53 <osaunders> I can imagine.
18:44:14 <dolio> Try it for f5.
18:44:49 <osaunders> "Clojure soon to be ported to the .NET framework, as ClojureCLR"
18:44:52 <MadHatterDude> dolio: My quad core spiked for 4 seconds with f4... so no.
18:44:57 <osaunders> What do people here think of Clojure?
18:44:58 <dolio> :)
18:45:22 <MadHatterDude> osaunders: It's a Lisp so I like it by definition
18:47:49 <Axman6> pfft
18:49:34 <MadHatterDude> But since its JVM it evens out
18:49:49 * Axman6 likes the JVM more than lisp
19:13:22 <cads> Is there an automatic way to make a function memoised?
19:13:48 <dobblego> no
19:14:01 <byorgey> cads: try the data-memocombinators package.
19:14:42 <cads> I've got a O(sqrt(n)) function for determining if a number is a perfect square, and I'd like to replace it with a dynamically created lookup hash or something
19:14:49 <cads> I'll check it out byorgey
19:32:33 <sohum> @pl \x n -> n + 1
19:32:33 <lambdabot> const (1 +)
19:32:53 <sohum> wait a tick
19:33:00 <sohum> @pl \n -> n + 1
19:33:00 <lambdabot> (1 +)
19:33:04 <sohum> @pl \n -> 1 + n
19:33:04 <lambdabot> (1 +)
19:33:11 <Axman6> heh
19:33:21 <byorgey> apparently @pl assumes that + is commutative =)
19:33:29 <sohum> @pl \n -> n `funkyNonCommutativeThingy` 1
19:33:29 <lambdabot> (`funkyNonCommutativeThingy` 1)
19:33:45 <sohum> fair enough, I suppose
19:34:11 <byorgey> good catch though, I'd never noticed that before
19:35:13 <shapr> wheee!
19:35:15 <sohum> I wonder why, though
19:35:43 <sohum> it'd be extra work, and I'm not sure outputting (1+) over (+1) is such a benefit
19:36:24 <SamB_XP> > fix ((1:) . scanl (+) 1)
19:36:26 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
19:37:46 <byorgey> hey shapr!
19:39:07 <shapr> y0 byorgey! wassup?
19:39:32 <byorgey> not much, glad it's spring break now
19:40:39 <Axman6> but it's Autumn!
19:41:32 <byorgey> Axman6: pardon me, I meant to say it is Northern Hemispherical Spring Break
19:41:40 <Axman6> thankyou
19:50:22 <cads> byorgey: data-memocombinators worked like a charm, thanks
19:55:16 <Veinor> I forget; how do I embed a literal newline into a string?
19:55:24 <Axman6> \n
20:11:06 <scutigera> today I did: handle,write data, hclose, shell command, repeat on same filename.  First shell command fails (no data).  second is ok. comment out second, and first works fine.  seems like I've had this problem befor.
20:12:28 <scutigera> with files not getting written properly that is.
20:28:18 * hackagebot yst 0.2.3.1 - Builds a static website from templates and data in YAML or  CSV files.  http://hackage.haskell.org/package/yst-0.2.3.1 (JohnMacFarlane)
20:33:31 <iaefai> Does anyone know of a library or example that uses a directed acyclic graph?
20:33:48 <Axman6> make?
20:33:58 <Axman6> not haskell... but still
20:34:14 <iaefai> I have never done any real data structures in haskell before.
20:34:18 <scutigera> for all graph related things you should check out fgl
20:34:30 <sm> how do I combine several hunit tests into one ?
20:34:37 <twink> iaefai: Graph reduction -based interpreters use DAG's heavily.
20:36:19 <Cale> iaefai: For graphs, I usually just use something like Map Vertex (Set Vertex) or some variation thereof.
20:38:06 <sm> by the power of hoogle! TestList
20:39:51 <twink> Map Vertex (Set Vertex) would be undirected; for directed, either two of those or Map Vertex (Set Vertex, Set Vertex)
20:40:22 <Cale> Map Vertex (Set Vertex) would be directed
20:41:05 <iaefai> Cale, I am not sure I entirely understand what Map Vertex (Set Vertex) is.
20:41:10 <twink> Okay, if you don't have "backpointers" or "back edges."
20:41:14 <iaefai> I am a little out of practice
20:41:25 <Cale> iaefai: For each vertex, you have a set of neighbouring vertices.
20:42:02 <Cale> In a directed graph, y is a neighbour of x if there is an arc x ~> y
20:42:22 <Cale> So you record a map from the vertices to their sets of neighbours
20:42:23 <iaefai> What is arc x ~> y
20:42:27 <scutigera>  a -> b -> c is a dag, a <-> b -> c has a cycle between a & b
20:42:31 <Cale> A directed edge
20:42:44 <iaefai> What is an edge
20:43:03 <Cale> You're the one who's asking how to represent graphs, I assumed you'd know what a graph is ;)
20:43:14 <twink> iaefai: Um, you do know basic definitions of graphs?
20:43:24 <iaefai> twink: Graphically, yes
20:43:41 <Cale> A directed graph consists of a set of vertices, and a set of ordered pairs of vertices, called arcs.
20:43:51 <scutigera> bubbles and arrows ? the edges are arrows
20:43:54 <Cale> If x and y are vertices, and (x,y) is an arc, we usually write x ~> y
20:45:01 <Cale> However, this representation, as a set of vertices, and a set of ordered pairs of vertices, while it makes a fine definition, is usually somewhat inconvenient for programming.
20:45:25 <iaefai> Cale, in this picture: http://upload.wikimedia.org/wikipedia/commons/3/39/Directed_acyclic_graph_3.svg  which are which?
20:45:52 <scutigera> arrows are the edges
20:45:59 <Cale> That graph has vertices {2,3,5,7,8,9,10,11}
20:46:21 <twink> addEdgeFrom :: Vertex -> Vertex -> Graph -> Graph, now type Graph = Map Vertex (Set Vertex) where the destinations of out edges from a vertex are the vertices in the set associated with a vertex in the Map has addEdgeFrom x y = Map.insertWith Set.union x (Set.singleton y)
20:46:44 <Cale> and arcs {(5,11),(11,2),(11,10),(11,9),(7,11),(7,8),(8,9),(3,10),(3,8)}
20:48:28 <Cale> For any vertex x in a directed graph, there will be some set of vertices y for which (x,y) is an arc. We call these y the neighbours of x. Intuitively, they're the things which are reachable taking just one step, obeying the direction of the arrows.
20:48:56 <Cale> So, in our example, the neighbours of 11 are {2,9,10}
20:49:10 <Cale> and 9 has no neighbours
20:49:58 <Cale> We can recover the entire graph just knowing what the set of neighbours is for each vertex.
20:50:24 <Cale> Yeah?
20:50:33 <iaefai> So our neighbours can be thought of as the things that depend on us?
20:50:49 <Cale> 'depend on'?
20:50:59 <Cale> I guess, if that's what an arc means
20:51:04 <iaefai> In the parlance of  a make file
20:51:14 <twink> Neighbors are usually the y such that (y,x) and (x,y) are arcs.
20:51:33 <twink> s/and/or/ as needed
20:51:37 <iaefai> My application is similar to a makefile in that it is about dependences
20:52:27 <iaefai> ok, I am going to be drawing something to think about this for a moment
20:53:18 <Cale> I'm preferring this definition of 'neighbour' at the moment because it gives us exactly the information we need to encode the graph effectively, and nothing more.
20:53:47 <iaefai> Yeah, I am importing this data from another language ultimately, so this information is very valuable :p
20:54:04 <twink> Cale: I'm trying to think of what the term for a uni-directional neighbor (maybe that's the term?).
20:54:27 <Cale> I suppose I could have called this 'out-neighbours'
20:54:50 <Cale> and then 'in-neighbours' would be the y such that (y,x) is an arc
20:56:24 <twink> Immediate predecessors/successors in the preorder induced by G?
20:56:58 <Cale> yeah, that works too
20:57:13 <Cale> well...
20:57:19 <Cale> hmm
20:57:25 <iaefai> Cale, this is the diagram (simplified) that I am going to be working with tobegin with: http://web.me.com/iaefai/DAG1.png
20:57:47 <Cale> Taking the transitive closure seems odd
20:59:15 <Cale> iaefai: So you'll have something like  Map.fromList [("SW1", Set.singleton "AND"), ("SW2", Set.singleton "AND"), ("AND", Set.singleton "OUT1")]
20:59:26 <Cale> In my graph representation
20:59:34 <Cale> That would be a Map String (Set String)
20:59:52 <iaefai> Cale, just so I am recalling all of the terms: SW1, SW2, AND, OUT1 are vertices. (SW1, AND), (SW2, AND), (AND, OUT1) are arcs.  (SW1, AND) and (SW2, AND) are neighbours, and arcs are also edges.
21:01:38 <sm> all: should I rename http://hackage.haskell.org/package/shelltestrunner to shelltest ?
21:03:47 <Cale> iaefai: Well, usually I define an edge to be a pair of arcs going in opposite directions between the same vertices.
21:03:58 <Cale> iaefai: But there are many variations on the definitions
21:05:21 <iaefai> Cale, that definition sounds like A <- B  and A -> B would be an edge, but A -> B  and B -> C wouldn't be.
21:07:11 <sm> and actually, how painful is it when you rename a previously published hackage package ?
21:08:56 <Cale> iaefai: right
21:09:23 <iaefai> So being that I have no edges in this definition, I can just call the arrows arcs
21:13:33 <iaefai> Time to play with some code
21:20:53 * twink takes a stab at dfs and bfs.
21:21:31 <FauxFaux> I still read that as breasts-first search.
21:23:37 <copumpkin> twink: one of those will be harder than the other
21:24:06 <copumpkin> well, I guess it depends on how you approach it :)
21:24:29 <twink> copumpkin: They looked almost identical.
21:24:40 <copumpkin> you just switched from queue to stack?
21:25:08 <copumpkin> you're doing it over a general graph or a tree?
21:26:35 <cads> !seen icarly
21:27:35 <twink> copumpkin: queue vs. stack basically being outNeighbors ++ worklist vs. worklist ++ outNeighbors and a seen set.
21:27:55 <copumpkin> yeah, ok :)
21:31:45 <twink> Not sure of a good graph where they'd make a big difference.
21:35:38 * hackagebot shelltestrunner 0.7 - A tool for testing command-line programs.  http://hackage.haskell.org/package/shelltestrunner-0.7 (SimonMichael)
21:53:09 <augur> D:
21:53:11 <augur> copumpkin: D:
21:53:16 <copumpkin> wut
21:54:13 <augur> http://www.reddit.com/r/programming/comments/b9qr9/google_ai_challenge_last_place_finisher_shows_an/
21:56:03 * augur hugs copumpkin
21:56:25 <iaefai> Using jhc, when I try to do import Data.Map it says unknown module, but jhc --list-libraries lists containers-0.2.0.1 which according to hackage has that in it. Any ideas what might be wrong?
21:57:45 <ezyang> compumpkin: Congrats mate
21:57:45 <twink> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=8501#a8501 <-- hmm, I'm suspicious of this bfs/dfs thing
21:57:46 <dmwit> Yeah, it's a real shame that copumpkin was too busy optimizing length-indexed vectors to win at a video game.
21:57:55 <dmwit> ;-)
21:58:26 <copumpkin> :)
21:58:33 <copumpkin> but yeah, that failed miserably
21:58:41 <dmwit> Hey, you won one.
21:58:45 <dmwit> That counts for something. =)
21:58:49 <copumpkin> so I'm going to try something radically different for those length-indexed vectors
21:59:00 <djahandarie> haha copumpkin fail
21:59:05 <copumpkin> oh, I meant the vectors :P I consider the google AI to be a success
21:59:17 <dmwit> hahahaha
21:59:25 <dmwit> Wow, that was so backwards from what I thought. =P
21:59:54 <copumpkin> if you can't win, make a virtue out of necessity and pretend you wanted to lose as badly as possible :)
22:00:09 <augur> XD
22:00:12 <copumpkin> but yeah, bot = const North might have been improved just a tad
22:00:16 <ezyang> those playbacks crack me up
22:00:56 <copumpkin> :)
22:04:08 <Jonno_FTW> is it possible, when importing modules
22:04:22 <Jonno_FTW> to have ghc look in certain folders, instead of the default ones?
22:05:07 <twink> There's "in addition to" but I'm not sure about "instead of."
22:05:17 <Jonno_FTW> well yes
22:05:19 <Jonno_FTW> that
22:05:21 <Jonno_FTW> how?
22:05:27 <Jonno_FTW> in addition too
22:05:45 <twink> -i
22:07:50 <Jonno_FTW> can I make it do it for every session though?
22:09:10 <twink> Not sure why :set -iwhatever couldn't be added to ~/.ghci but it sounds scary to me.
22:09:12 <dmwit> alias ghc="ghc -i ~/.libs"
22:09:29 <Jonno_FTW> i'm on windows
22:09:44 <dmwit> echo "ghc -i ~/.libs" >ghc.bat
22:09:50 <dmwit> ;-)
22:10:18 <iaefai> Is there a pretty printer for maps? I could use something better than fromList ...
22:10:28 <dmwit> Dunno how to pass arguments along. Something like %% or so, but it's been a while since my DOS days.
22:10:40 <dmwit> iaefai: There's bindings to GraphViz.
22:10:54 <dmwit> err
22:10:59 <iaefai> dmwit: that sounds a little overkill
22:11:00 <dmwit> You mean maps as in Data.Map, don't you.
22:11:02 <iaefai> yes
22:11:20 <dmwit> mapM_ print . assocs -- ?
22:11:35 <Jonno_FTW> hmm
22:11:38 <Jonno_FTW> i normally use ghci
22:11:40 <dmwit> Just like fromList, but on different lines. =)
22:12:02 <dmwit> I don't see why the same trick couldn't be used for ghci.
22:12:29 <dmwit> iaefai: As long as we're suggesting overkill, System.Vacuum.Cairo. ;-)
22:12:49 <iaefai> dmwit: It is a little better i suppose :p
22:13:09 <scutigera> dmwit: I _have_ to use -i../lib, -i ../lib doesn't work ??
22:13:19 <Jonno_FTW> and what are the advantages to using the C preprocessor?
22:13:23 <dmwit> scutigera: Yeah, that's probably right, actually.
22:13:30 <dmwit> scutigera: In keeping with gcc's grand tradition.
22:13:39 <scutigera> dmwit: of being annoying
22:13:43 * dmwit nods
22:14:25 <Jonno_FTW> i tried using ghci -i C:\Haskell
22:14:27 <Jonno_FTW> and it didn't work
22:14:48 <iaefai> dmwit: When I do this; printMap = mapM_ print . Map.assocs    it says Ambiguous type variable `k' in the constraint because of print
22:14:59 <scutigera> Jonno_FTW: see above. no space
22:15:05 <Jonno_FTW> right
22:15:15 <scutigera> well, at least on linux
22:15:38 <dmwit> iaefai: Are your maps polymorphic in their key (resp. value) types?
22:15:53 <dmwit> iaefai: If so, you'll have to pin the polymorphism down a bit.
22:15:54 <iaefai> They are like this:  [("SW1", Set.singleton "AND"),
22:16:11 <dmwit> Have you got OverloadedStrings turned on?
22:16:18 <iaefai> I have nothing turned on
22:17:02 <dmwit> iaefai: Have you forgotten to turn off the MR? ;-)
22:17:06 <iaefai> MR?
22:17:13 <dmwit> monomorphism restriction
22:17:30 <iaefai> You mean the referred to here:  -XNoMonomorphismRestriction
22:17:47 <Jonno_FTW> it still didn't work
22:17:52 <dmwit> Yes, either add that flag or stick {-# LANGUAGE NoMonomorphismRestriction #-} to your file.
22:18:01 <dmwit> s/ to / in /
22:18:18 <Jonno_FTW> well it loaded ghci, but when I try to load a script or module from within the included folder it couldn't find it
22:18:19 <iaefai> merci, that works nicely
22:18:28 <iaefai> Now if I could only get jhc to work with it :p
22:18:40 <dmwit> iaefai: Or you can just give an explicit type annotation.
22:18:55 <dmwit> iaefai: The dreaded MR applies only to non-annotated top-level definitions.
22:19:00 <iaefai> dmwit: I wouldn't have any ideas on how to do that
22:19:12 <dmwit> printMap :: (Show k, Show a) => Map k a -> IO ()
22:19:20 <dmwit> See also ":t printMap" in ghci.
22:19:38 <dmwit> If you add that annotation, you can turn the MR back on.
22:20:05 <iaefai> better
22:20:08 <iaefai> That is just annoying
22:31:43 <blackdog> so, not strictly haskell, but I know some of you guys are cryptologically sound: what's the current state of play with using MD5/SHA-1 for passwords? I vaguely remember reading somewhere that they're good for quickly checking identities, but not necessarily the best hashes for resisting being cracked...
22:31:57 <blackdog> my google-fu, however, has failed me badly
22:32:56 <ezyang> blackdog: SHA-1 is at the "get up slowly and start moving towards the exit"
22:33:06 <ezyang> MD5 is at the "you can smell the smoke" stage
22:34:32 <blackdog> ezyang: that's good to know. is there a better one available?
22:35:41 <iaefai> SHA-2?
22:36:13 <ezyang> I'm pretty sure you don't want SHA-2
22:36:28 <ezyang> SHA-256 and SHA-512 are what I hear people mumbling about these days
22:37:08 <lament> if that's the number of bits then yeah, sha-2 might be breakable
22:37:35 <blackdog> ezyang: ok, thanks. i'll go educate myself.
22:38:09 <ezyang> i,i "educate self == get a PhD in cryptography" :-P
22:39:12 <blackdog> ezyang: i'm aiming for not shooting myself in the head. shooting myself in the foot is undesirable but probably unavoidable:)
22:50:30 <dons> crypto is more than a degree, it's a lifestyle choice.
22:51:19 <blackdog> dons: tourist 4 lyfe
22:51:48 <blackdog> i just don't wanna be the sort of tourists that complains that the McDonald's here doesn't taste like it does at home...
22:52:35 <pikhq> blackdog: The secret to that is to not eat at McDonalds.
22:53:24 <iaefai> What exactly do each of these parameters mean? Set.fold :: (a -> b -> b) -> b -> Set a -> b       I know the first one is going to be some function, but taking two parameters? No idea about the second parameter and third is obviously the set.
22:54:23 <pikhq> :t fold
22:54:24 <lambdabot> Not in scope: `fold'
22:54:26 <pikhq> Erm.
22:54:27 <pikhq> :t foldr
22:54:28 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
22:54:33 <pikhq> Any further questions?
22:54:49 <iaefai> I already had this information. It tells me nothing new.
22:55:10 <blackdog> iaefai: b is the type of the result you want to get
22:55:13 <pikhq> So, you're not familiar with foldr and friends?
22:55:24 <Cale> iaefai: fold is like foldr over the list of elements in the set
22:55:26 <iaefai> pikhq: Not a great extent
22:55:34 <Cale> iaefai: It's easier to understand foldr first
22:55:43 <iaefai> Cale, I know that fold is foldr, it says so in the source code
22:55:50 <pikhq> > foldr (+) 0 [0..10]
22:55:52 <lambdabot>   55
22:56:02 <Cale> I like to understand foldr f z as a function which replaces each of the (:)'s in a list with f and the [] at the end with z
22:56:14 * ddarius presumes that the specification of Set.fold is non-deterministic.
22:56:16 <pikhq> The function passed to fold gets two arguments, one from your list, the one is the accumulator.
22:56:31 <pikhq> The second argument to fold is the initial accumulator.
22:56:43 <iaefai> I think Set.elems is what I want...
22:56:59 <pikhq> So, each call of the function gets the result of the previous call of the function.
22:57:05 <Cale> Oh, "in an unspecified order", that's disappointing.
22:57:07 <pikhq> Or what Cale said.
22:57:36 <ddarius> Set.elems = Set.fold (:) []
22:57:49 <Cale> I would have hoped that Set.fold f z = foldr f z . Set.toList
22:57:53 <ddarius> If I guessed the meaning of elems right.
22:58:13 <Cale> (and toList gives an ascending list)
22:58:34 <iaefai> I think this is something like what I am trying to do: (foldr (++) "" (Set.elems a))
22:58:48 <ddarius> foldr (++) "" = concat
22:59:33 <iaefai> I will be putting things inbetween, which as I recall there is a function for that
22:59:47 <dobblego> intercalate/intersperse
23:00:50 <Jonno_FTW> @src concat
23:00:50 <lambdabot> concat = foldr (++) []
23:00:56 <Jonno_FTW> you lie
23:02:17 <iaefai> ok, I have this Map that I need to iterate through, use this function printDAG on each pair, but it is ultimately being printed.
23:02:29 <iaefai> I assume that I can use print at some stage
23:02:50 <iaefai> This is always most difficult to get through at 2am
23:03:01 <iaefai> I never have to think when I am doing C.
23:03:18 <Jonno_FTW> drink some coffee
23:03:27 <iaefai> I have to go to bed in 10 minutes :p
23:03:31 <blackdog> yeah, thinking in C comes at debug time
23:03:43 <iaefai> Yeah, usually with the words WTF
23:03:51 <iaefai> Actually that is cocoa debugging
23:04:11 <ddarius> BTUF
23:07:38 <pikhq> I find that lately in C I end up compiling some sort of odd functional language into C.
23:07:49 <iaefai> hmm: jhc: src/FrontEnd/Representation.hs:98:9-24: No instance nor default method for class operation Data.Binary.put
23:08:10 <pikhq> And then wonder how things are going wrong.
23:08:15 <ddarius> I find that lately in C++ I end up compiling some sort of odd functional language into C++... in the type system!
23:08:30 <pikhq> It was quite bad when I was trying to use getcontext et al...
23:09:02 <pikhq> It's very hard to debug C when the chunk of the stack that actually has the bug is, in fact, not the current stack.
23:10:53 <iaefai> Does ghc have any way of emitting C code?
23:11:11 <pikhq> Yes. And no, it won't help you.
23:11:12 <iaefai> I just have this intuition that jhc isn't going to be worth the pain
23:11:37 <pikhq> I guarantee that you do not want GHC's C output directly.
23:11:46 <iaefai> Why would you say that?
23:11:59 <pikhq> Dear God, have you looked at it?
23:11:59 <copumpkin> it looks nothing like c
23:12:05 <iaefai> pikhq: nope
23:12:25 <pikhq> And GHC doesn't use the output of the C compiler directly. *Oh no*. It does something far more evil.
23:12:41 <pikhq> It tells GCC to compile it to assembly. And then it runs the *evil mangler* on it.
23:13:03 <iaefai> I am really just after a good compiler that can output for the ARM (iPhone) and link with my Cocoa interface :p
23:13:15 <iaefai> GHC support wasn't quite there as I recall
23:13:26 <Cale> Personally, I think I have to think harder when writing C code.
23:13:43 <iaefai> Cale, it is hard to point the gun
23:13:43 <pikhq> Linking with C is quite different from actually emitting C.
23:14:19 <Cale> With Haskell, you can rely on the compiler to catch a lot of your mistakes.
23:14:49 <Cale> With C, not nearly as many, plus you have to think about stuff which is usually irrelevant, like managing memory properly.
23:14:57 <pikhq> iaefai: Allow me to give you a simple example of GHC's C output.
23:15:04 <ddarius> See Cale, you're doing it wrong.  In C, you just carefreely make mistakes.
23:15:15 <pikhq>  http://sprunge.us/VZIS
23:15:32 <iaefai> looks like C to me
23:15:51 <ddarius> The secret to managing memory in C is to never call free.
23:15:52 <pikhq> ... I am chopping your hands off now to prevent you from writing code.
23:16:03 <pikhq> I never call malloc in C any more.
23:16:08 <pikhq> GC_MALLOC for me.
23:16:11 <iaefai> ?
23:16:14 <iaefai> Why no malloc
23:16:19 <iaefai> and why no free
23:16:25 <pikhq> Because I <3 garbage collection.
23:16:34 <iaefai> Ah, I have no such luxury
23:16:53 <iaefai> Also, that is an enemy of small memory spaces
23:17:04 <pikhq> ... No.
23:17:36 <pikhq> Garbage collection does not inherently waste space.
23:17:39 <lament> just use the stack for everything.
23:17:44 <iaefai> So you would use garbage collection on an atmega16 for example?
23:18:14 <iaefai> Considering I am using Cocoa Touch anyways, there is no garbage collector.
23:18:53 <ddarius> If you care about small memory spaces, you should look at the Virgil language.
23:20:23 <pikhq> Considering you're on Cocoa Touch, you're not getting anything Apple doesn't grant you.
23:20:47 <pikhq> Though you might be able to shove Boehm GC in there.
23:20:48 * ddarius prefers the verb "bestow upon"
23:20:51 <iaefai> "To avoid the need for a large runtime system that dynamically manages heap memory and performs garbage collection, Virgil does not allow applications to allocate memory from the heap at runtime."
23:20:54 <lament> er... there's definitely GC on the iphone?
23:21:06 <blackdog> iaefai: you can run haskell code on the iphone...
23:21:07 <iaefai> lament: find the reference then
23:21:13 <lament> ?
23:21:29 <blackdog> admittedly, it's a huge pain in the arse
23:21:30 <lament> autorelease
23:21:32 <iaefai> lament: Find where it says there is GC on the iphone
23:21:32 <SamB_XP> depends how small you mean by small
23:21:33 <ddarius> iaefai: I wasn't mentioning it because it used garbage collection (which it doesn't).
23:21:42 <iaefai> lament: THat is not garbage collection
23:21:49 <SamB_XP> I'd not suggest GC for use in a program for the Atari 2600, for instance ;-P
23:22:10 * ddarius thinks that the iPhone definitely is not a "small memory" device.  Maybe firmware for it?
23:22:11 <lament> iaefai: ok w/e
23:22:12 <iaefai> lament: You are still managing your own memory
23:22:27 <SamB_XP> it only has 1/4 kiB of RAM, after all!
23:23:27 <iaefai> That virgil programming language looks interesting
23:23:41 <pikhq> lament: The iPhone uses Objective C's reference counting.
23:23:58 <pikhq> SamB_XP: I'd not suggest dynamic memory allocation there.
23:24:14 <SamB_XP> pikhq: well, yeah, that's kinda my point I guess
23:24:15 <iaefai> Explicit calls to alloc, release and delayed release
23:24:32 <SamB_XP> just trying to put the term "small" in perspective ;-P
23:24:44 <pikhq> (AKA "leaky garbage collection")
23:24:48 <ddarius> SamB_XP: That's the kind of target Virgil is aiming at.
23:25:16 <SamB_XP> ddarius: 256 bytes of RAM is the kind of target Virgil aims at ?
23:25:20 <ddarius> SamB_XP: Yes.
23:26:01 <SamB_XP> you realize these are just plain new 8-bit bytes, right?
23:26:07 <SamB_XP> not 18-bit or anything!
23:26:23 <pikhq> Yes.
23:26:32 <iaefai> Who decided on making things multiples of 8 bits on the machines we commonly use?
23:27:25 <SamB_XP> why do micros always use power-of-2 multiples of 8?
23:27:26 <pikhq> iaefai: IBM System/360.
23:27:44 <SamB_XP> pikhq: that's no micro!
23:28:08 <pikhq> SamB_XP: It's the reason for micros doing that. ;)
23:28:17 <SamB_XP> oh, is it ?
23:28:23 <SamB_XP> how's that ?
23:28:32 <SamB_XP> ... you'
23:28:43 <SamB_XP> re sure it's not to facilitate the running of Zork ?
23:28:54 <pikhq> It estabilished the convention.
23:29:03 <SamB_XP> the Z-machine is 8-bit too ;-P
23:29:23 <pikhq> And S/360 predates it.
23:30:22 <iaefai> ddarius: The one thing I am not clear on about virgil is what systems does it actually support?
23:31:18 <SamB_XP> ddarius: so ... how is dynamic allocation viable w/ only 256 8-bit bytes of RAM ?
23:31:40 <pikhq> SamB_XP: What dynamic allocation?
23:32:20 <pikhq> SamB_XP: Virgil computes the entire heap at compile-time and does a collection cycle. It bakes in the live portions of the heap.
23:32:24 <pikhq> SamB_XP: There is no other allocation.
23:32:30 <SamB_XP> oh!
23:32:34 <SamB_XP> interesting
23:33:01 <SamB_XP> that would explain how it's useful for only 256 bytes of RAM
23:33:20 <SamB_XP> does it also do cycle-accurate realtime scheduling ?
23:33:35 <pikhq> Dunno.
23:33:41 <pikhq> The 2600 would need it.
23:33:46 <SamB_XP> quite so
23:33:50 <ddarius> SamB_XP: Probably not.
23:34:02 * pikhq is looking at GHC's C output.
23:34:04 <pikhq> *shudder*
23:34:29 <pikhq> GHC's assembly is much easier to read.
23:34:38 <pikhq> Namely, it can be read.
23:34:46 <ddarius> iaefai: It produces C.  To handle hardware specific code, specification files can be provided which probably just gives names and mappings to the C code to generate for such things.
23:35:00 <iaefai> ddarius: I love it already...
23:35:26 <iaefai> But it looks like it was released 3 times and forgotten
23:35:49 <SamB_XP> you've GOT to twiddle those graphics registers at JUST the right time or you're screen image will go kablam
23:36:18 <pikhq> Yeah, the Atari is... Crazy.
23:36:34 <pikhq> I don't think a HLL is appropriate for it.
23:36:40 <SamB_XP> quite
23:36:58 <pikhq> Given that you need clock-cycle accuracy.
23:37:40 <pikhq> (no framebuffer... *shudder*)
23:39:10 * hackagebot liboleg 2010.1.2 - A collection of Oleg Kiselyov's Haskell modules (2008-2010)  http://hackage.haskell.org/package/liboleg-2010.1.2 (DonaldStewart)
23:58:20 <kamatsu> hey, i'm getting a stack overflow, is there a way to figure out what function is causing the stack overflow
23:58:23 <kamatsu> ?
23:58:31 <kamatsu> ghci doesn't seem to tell me
23:58:43 <Cale> kamatsu: Sometimes compiling with -prof -auto-all and running with +RTS -xc will help
23:58:54 <Cale> kamatsu: But generally it can be a bit tough.
23:59:32 <kamatsu> hm
23:59:42 <Cale> kamatsu: Look for places where you're taking lots of separate bits of data and summarizing them into a single piece of data (or something with few separately-evaluatable parts)
