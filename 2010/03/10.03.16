00:00:06 <kmc> no i don't see how
00:00:49 <kmc> they're called "linked" lists because in memory, you can represent this by a bunch of 2-word cells ("cons pairs"): the first word of each cell points to an element, and the second word points to the next cell, or holds some special "null pointer" value in the last cell
00:01:07 <kmc> here "word" means just however many bits the machine uses to store pointers
00:01:16 <kmc> anyway, that level of detail is necessary when implementing linked lists in assembly or C
00:01:21 <roboshibby> man, that sounds wild. what would an example use of that be?
00:01:42 <kmc> they're one of the most fundamental datastructures
00:01:48 <roboshibby> really?
00:01:51 <roboshibby> like a number?
00:01:51 <kmc> linked lists?
00:01:53 <kmc> yes
00:01:57 <kmc> they are more important than numbers
00:02:03 <roboshibby> whoa, how so?
00:02:42 <mail> linked lists are represented by tuples in haskell?
00:02:50 <mail> or was that just an analogy?
00:03:11 <kmc> they're not represented by the tuple types (a,b)
00:03:16 <kmc> data List a = Nil | Cons a (List a)
00:03:49 <kmc> the real list type you write with [] is exactly like that List type, except for special syntax
00:03:58 <roboshibby> how is the LL more important than numbers?
00:04:07 <kmc> that is [1,2,3] is like «Cons 1 (Cons 2 (Cons 3 Nil))»
00:04:40 <kmc> roboshibby, you can represent natural numbers by a list whose elements you ignore
00:04:45 <kmc> that is you only care about length
00:04:58 <kmc> obviously this is not an efficient representation, and "important" is a subjective term
00:05:03 <kmc> but it's worth noting the similarity
00:05:07 <kmc> data List a = Nil | Cons a (List a)
00:05:10 <kmc> data Nat = Zero | Succ Nat
00:05:18 <mail> Cons?
00:05:34 <kmc> mail, it's a name... comes from LISP
00:05:49 <kmc> really all you need is functions; you can Church-encode lists and numbers and everything else as functions
00:06:31 <kmc> roboshibby, explaining why linked lists are useful/important is out of the scope of this channel; it'll be covered by any introductory algorithms / data structures text, or by wikipedia etc
00:07:15 <kmc> it's however worth noting one additional use of lists in Haskell
00:08:19 <kmc> since Haskell implementations use lazy evaluation, if a list is produced by one function and consumed by another, it essentially establishes a coroutine between the two functions
00:09:06 <kmc> that is, rather than building the list in memory all at once, the consumer "asks" for it one element at a time
00:09:16 <roboshibby> ahhh
00:09:19 <roboshibby> nice
00:09:22 <roboshibby> lazy evaluation is nice
00:09:30 <tensorpudding> laziness is virtuous
00:09:37 <kmc> that is, lists in Haskell behave like generators or iterators or what-not, except that they're *also* persistent data structures
00:09:59 <kmc> when you use lists as control-flow structures like that, a clever implementation will avoid constructing the list in memory at all
00:10:07 <kmc> it will just produce code which jumps between the producer and consumer
00:10:37 <kynky> lists are mutable, essentially monads
00:11:24 <kmc> what?
00:15:20 <roboshibby> it's tough to imagine how anything can be used to assemble 'numbers'
00:16:43 <kmc> we do it a bunch of ways
00:16:49 <kmc> in axiomatic mathematics you build the natural numbers out of sets
00:17:07 <kmc> 0 is {}, 1 is {0}, 2 is {0,1}, 3 is {0,1,2}, etc.
00:17:40 <kmc> that is, the numeral 3 is just shorthand for the set { {}, {{}}, { {}, {{}} } }
00:19:08 <kmc> in analysis you define the real numbers as cauchy sequences or dedekind cuts over the rational numbers
00:19:24 <kmc> in binary computers we assemble numbers out of bits
00:19:44 <kmc> in natural language we assemble them out of words and numeral symbols
00:41:43 <Zeiris> Is there a clean, elegant way to make Parsec work with bit streams?
00:44:17 <kmc> the "character" type used by Parsec can be chosen by the user
00:44:31 <kmc> attoparsec is specifically designed to be binary-friendly and works with ByteStrings
00:46:20 <Zeiris> I'm mainly concerned with code that parses arbitrary bits, not aligned on byte boundaries. Is there some ByteString equivalent that abstracts away the byte boundaries?
00:47:17 <kmc> good question
00:47:42 <kmc> you can work with a string of bytes each of which is 0 or 1
00:48:05 <kmc> it will use more memory and might be faster or slower
00:49:59 <lowasser> oooh hold on
00:51:23 <lowasser> I feel like there should be some nice newtyping of ByteStrings that lets you create an instance
00:51:45 <lowasser> Monad m => Stream BitString m Bool
00:52:29 <lowasser> where BitString is, like, a ByteString possibly augmented with "I'm at this position at this byte, plus I have this whole ByteString to read from, later"
00:52:45 <lowasser> and then that'd get you what you want with parsec-3
00:54:26 <theorbtwo> lowasser, kmc: Er, so write it?
00:54:33 <lowasser> working working working
00:54:46 <lowasser> (kmc's approach doesn't use ByteStrings at all, but just a [Bool])
00:55:24 <theorbtwo> It's not hard, from a bit-arithmetic level, to transform a sequence of bytes into a sequence of bits, or to do random access on a bit level into an array of bytes.
00:55:40 <glguy> When looking at monads from the view of [join,fmap,return] we have join . join == join . fmap join  and   join . return == id   and join . fmap return == id , but do we additionally need the fact that return must be a natural transformation and hence   return . f == fmap f . return ?
00:57:29 <lowasser> theorbtwo: the thing, though, is making it work nicely with say Parsec
00:58:34 <theorbtwo> Does Parsec have specialized requirements?
01:00:54 <lowasser> well, you *can* modify ByteStrings to pretend to output Bools as far as Parsec is concerned
01:01:07 <lowasser> that's the objective for the moment ^^
01:03:51 <lowasser> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24009
01:04:49 <lowasser> that should do it, Zaeris, theorbtwo
01:07:53 <Zeiris> So, how would you pop, say, 7 bits off of that then continue?
01:08:36 <lowasser> hehehe
01:08:41 <lowasser> replicateM 7 anyToken
01:08:55 <lowasser> would return a 7-element list of bits
01:09:00 <lowasser> which had been consumed from the ByteString
01:09:23 <lowasser> and then that's a perfectly normal Parsec operation
01:09:38 <lowasser> or to use only Parsec-ish things
01:09:43 <lowasser> you could use
01:09:48 <lowasser> count 7 anyToken
01:10:09 <lowasser> count and anyToken are both in Text.Parsec.Combinator, and they're perfectly common Parsec commands
01:12:04 <Zeiris> Guh. This shouldn't be hard, I think I just badly need sleep. Ima leave the window open and figure it out next morning.
01:12:25 <lowasser> good plan
01:12:44 <lowasser> I should continue working on the essay I have due in seven hours instead of procrastinating with #haskell
01:13:07 <Zeiris> Well, you probably learn more from the procrastination.
01:13:26 <Zeiris> http://www.structuredprocrastination.com/
01:14:55 <lowasser> hehehee, I totally do things like this
01:15:09 <Zeiris> Yeah, it was an eye opener.
01:21:25 <kmc> lowasser, very nice
01:21:47 <lowasser> =)
01:22:27 <lowasser> there's no reason to sacrifice the speed of ByteStrings when it just takes a little wrapper to make it look like a [Bool]
01:29:57 <theorbtwo> Has anybody around here played with facial recognition?  Are there any good libraries to use?
01:31:36 <theorbtwo> There seems to be a researcher named Haskell in the field, which is breaking my google-fu.
01:34:09 <Alpounet> theorbtwo, you can use OpenCV for that
01:34:19 <Alpounet> sinelaw is working on a Haskell binding for OpenCV
01:35:02 <theorbtwo> Ah, good.
01:35:21 <Alpounet> theorbtwo, check http://github.com/sinelaw if you want to test it
01:35:26 <theorbtwo> When I was looking at perl libraries for it, I came across opencv, but the bindings only work for 1.0, not 2.0.
01:35:40 <Alpounet> but he comes here quite often, you should be able to chat with him about that
01:35:49 * theorbtwo nods.
01:36:26 <Alpounet> but the last time I ran his sample, my face was surrounded by a red square
01:37:39 <Alpounet> theorbtwo, http://github.com/sinelaw/cv-combinators/blob/master/src/Test.hs
01:37:41 <theorbtwo> ah, er, I was hoping to not just find faces in the input data, but also find sets of matching faces.
01:37:59 <theorbtwo> It doesn't have to be terribly accurate.
01:38:11 <Alpounet> well, he's probably about to bind the whole library, little by little
01:38:27 <Alpounet> you can help him with that, if you're willing to
01:38:47 <theorbtwo> Not sure how much help I'd be, but I can certianly try...
01:38:47 <idnar> what are my options for parsing binary data formats in Haskell?
01:39:12 <idnar> parsec doesn't seem like it's such a good fit (but please correct me if I'm wrong)
01:39:56 * theorbtwo wonders too -- when I tried asking, I never got an answer that really satasified.
01:40:38 <Alpounet> idnar, iirc, cereal is a better fit for that
01:40:50 <Alpounet> http://hackage.haskell.org/package/cereal
01:40:53 <idnar> hmm, I'll look at that
01:41:20 <idnar> the only documentation I have for this format is some C code and structs, and most of the reading is done by just casting the data to structs
01:42:12 <Alpounet> either cereal or binary (http://hackage.haskell.org/package/binary)
01:42:34 <idnar> hmm, those are a bit low-level :/
01:42:56 <theorbtwo> Sounds like the level you actually have, for the most part.
01:43:16 <theorbtwo> The problem is that, like parsec, they don't seem to have good support for offsets.
01:43:30 <Alpounet> @tell sinelaw theorbtwo is interested in HOpenCV, mostly for facial recognition. You should get in touch with him.
01:43:41 <Alpounet> uh ?
01:43:49 <Alpounet> lambdabot's not here
01:44:06 <theorbtwo> Nooooooo!
01:44:16 <erikc> use hsc2hs to have an ffi binding to the structs, then mmap, cast and use the struct
01:44:23 <erikc> endian swap if necessary
01:44:38 <idnar> erikc: yuck :P
01:45:18 <erikc> if that's what the C code does, you're already hostage to the platform's C ABI
01:45:20 <idnar> the structs are wrong anyway, the code doesn't even run on my system because the types they use aren't the same width on my system
01:45:41 <erikc> oh, better find out what system they were generated on then and check the ABI :\
01:45:52 <idnar> I can pretty much work out what they're supposed to be
01:46:04 <erikc> yea, it's eyeballable i guess
01:46:10 <theorbtwo> A little bit of experimentation should get you there from that.
01:46:23 <idnar> but I'd rather not rely directly on the C code in that case
01:46:28 <theorbtwo> Binary, cerial, or parsec should be OK for what you want.  I've only tried the last one.
01:46:45 <theorbtwo> However, like I said, the big problem is offsets.
01:47:06 <theorbtwo> If you are lucky, your format is streamable, and you won't have any.
01:47:23 <theorbtwo> Otherwise, you'll have to do some semi-nasty tricks to get around it.
01:47:40 <jaspervdj> preflex: seen chrisdone
01:47:40 <preflex>  chrisdone was last seen on #haskell 1 day, 10 hours, 40 minutes and 37 seconds ago, saying: sundays are indeed slow
01:48:08 <theorbtwo> Oh, one other thing, parsec's repeat will blow the stack for large arguments.  That's the point at which I gave up the last time I tried something like this.
01:48:28 <idnar> I guess I'll experiment and see how it goes
01:48:46 <Alpounet> jaspervdj, it's for the HTML comb library ?
01:48:50 <idnar> I was looking for something like erlang's bit syntax
01:49:03 <idnar> although I'm only vaguely familiar with that, so I'm not sure if that would be suitable here either
01:50:33 <jaspervdj> Alpounet: yep
01:50:44 <mail> NFAs are mind bending :/
01:51:09 <kmc> little bit
01:52:02 <kmc> if you want to think of them as deterministic machines, the state at any point in time is a set of NFA states, not a single one
01:52:28 <Zeiris> What's an NFA?
01:53:09 <tensorpudding> nondeterministic finite automaton
01:53:56 <lowasser> I mean, NFAs don't have to be mindbending
01:54:03 <lowasser> the list monad is pretty much nondeterminism right ther
01:54:04 <lowasser> e
01:54:19 <roboshibby> NFA?
01:54:22 <lowasser> haskell makes nondeterminism manageable!
01:54:24 <roboshibby> oh
01:54:40 <Zeiris> Are NFAs related to that Logic monad?
01:54:53 <Trinitron> When I type :i !! it doesn't tell me the precedence rank.
01:55:09 <Trinitron> Prelude> :i (!!) (!!) :: [a] -> Int -> a         -- Defined in GHC.List
01:55:16 <lowasser> I mean, NFAs are some of the theoretical basis for e.g. regexes
01:55:32 <lowasser> frequently seen in introductory CS theory classes, and rarely heard from again, I think...
01:55:54 <lowasser> that was certainly my experience
01:56:04 <roboshibby> unless one studies system theory
01:56:36 <Trinitron> Does "primes !! index+1" parse as "(primes !! index)+1"?
01:56:59 * hackagebot feldspar-language 0.2 - A functional embedded language for DSP and parallelism  http://hackage.haskell.org/package/feldspar-language-0.2 (EmilAxelsson)
01:57:01 <Trinitron> These precedence rules are doing my head in.
01:57:01 * hackagebot feldspar-compiler 0.2 - Compiler for the Feldspar language  http://hackage.haskell.org/package/feldspar-compiler-0.2 (EmilAxelsson)
01:57:35 <kmc> i would definitely write that expression with parentheses for clarity
01:58:04 <theorbtwo> I'm afraid all I know about precidence in haskell is that things never have the precidence I want them too.
01:58:21 <Trinitron> But how does the parser parse that example?
01:58:27 <ivan_m> where's lambdabot?
01:58:31 <Alpounet> he's gone ivan_m
01:58:44 <ivan_m> Alpounet: lambdabot is a _she_
01:58:47 <Alpounet> she yeah
01:58:48 <Alpounet> damn
01:58:50 <ivan_m> preflex: seen lambdabot
01:58:50 <preflex>  lambdabot was last seen on #haskell 2 hours, 53 minutes and 52 seconds ago, saying: Data.Foldable maximum :: (Foldable t, Ord a) => t a -> a
01:58:51 <Alpounet> I won't get used to it
01:58:51 <kmc> her name is Emily
01:59:02 <ivan_m> kmc: huh? where'd you get that from?
01:59:05 <kmc> from @vixen
01:59:20 <ivan_m> really? don't recall vixen saying that before...
01:59:26 <roboshibby> the bot is a she, says computer geek 35? boy, how pathetic
01:59:33 <Twey> @vixen What is your name?
01:59:39 <Twey> Oh, woah
01:59:40 <roboshibby> you're nice ivan, you know i like you, but that's really sad
01:59:43 <Twey> \b is dead?  What?
01:59:44 <ivan_m> Twey: can't ask the non-existant bot
01:59:51 <Twey> Does not computer
01:59:55 <Twey> compute** argh.
01:59:58 <ivan_m> roboshibby: ummm.... I didn't write any part of lambdabot
01:59:59 <Twey> roboshibby: But she is :<
01:59:59 <Alpounet> who runs lambdabot these times ?
02:00:07 <ivan_m> roboshibby: have a look at her page on the wiki
02:00:14 <ivan_m> Alpounet: Cale has access IIRC
02:00:21 <kmc> Trinitron, the answer is yes, it parses that way
02:00:25 <kmc> i have just checked in ghci
02:00:45 <roboshibby> ivan, you've proven yourself unreasonable and insane, so i can't even communicate with you
02:01:01 <ManateeLazyCat> State moand is so cool, remove all *temporary* variable.
02:01:29 <kmc> Trinitron, ghci says that (!!) has no declared precedence; the report says that gives it highest precedence
02:02:00 * ManateeLazyCat pasted "State moand functions." at http://paste2.org/get/719433
02:02:00 <ManateeLazyCat> Above is some handy functions for State Monad. Enjoy! :)
02:02:06 <ivan_m> roboshibby: wtf?
02:11:16 <profmakx> meh. why are so many hackage packagaes broken
02:12:10 <Saizan> mail the maintainers :)
02:12:15 <kmc> some build with GHC 6.10 but not 6.12 or vice versa
02:12:18 <kmc> you can try older versions
02:12:47 <ivanm> profmakx: in what sense?
02:13:00 <ivanm> kmc: I would have thought that if they built with one, they would build with the other
02:13:08 <ivanm> oh, wait, containers, etc. got bumped, didn't they
02:13:22 <profmakx> c2hs for example
02:13:51 <profmakx> i have encountered multiple of the "smaller" packages that seem to depend on 6.10 or whatever
02:13:53 <Trinitron> Is / a different operator to `div`?
02:14:01 <profmakx> @type div
02:14:05 <profmakx> @type (/)
02:14:07 <profmakx> meh
02:14:07 <ivanm> Trinitron: yes
02:14:10 <profmakx> lb not here
02:14:12 <ivanm> first of all, div isn't an operator :p
02:14:20 <ivanm> Trinitron: / is for floating point, div is for integral numbers
02:14:24 <Trinitron> I see.
02:14:28 <Trinitron> Xie xie.
02:14:30 <ivanm> e.g. you can't use div on 2.3
02:14:34 <Trinitron> Cool.
02:14:52 <Trinitron> Wait, how is `div` not an operator/
02:14:53 <Trinitron> ?
02:15:20 <kmc> syntactically
02:15:35 <kmc> (/) :: (Fractional a) => a -> a -> a
02:15:39 <kmc> div :: (Integral a) => a -> a -> a
02:16:00 <Trinitron> div is a finction?
02:16:02 <Trinitron> function?
02:16:04 <kmc> yes
02:16:04 <ivanm> yes
02:16:06 <kmc> well, so is (/)
02:16:15 <kmc> "operator" is just a syntactic concept
02:16:19 <ivanm> operators are composed solely of symbols (excluding parens)
02:16:24 <ivanm> kmc: true
02:16:25 <Trinitron> I see.
02:16:40 <Trinitron> So `mod` is a function, not an operator?
02:17:06 <Trinitron> And `+` is an operator.
02:17:12 <kmc> `+` is a syntax error
02:17:30 <kmc> you put backticks around the name of a non-operator to use it infix as an operator
02:17:56 <Trinitron> Oh...
02:18:03 <Trinitron> Sorry, I'm a Haskell newbie.
02:18:09 <kmc> "An operator is either an operator symbol, such as + or $$, or is an ordinary identifier enclosed in grave accents (backquotes), such as `op`. For example, instead of writing the prefix application op x y, one can write the infix application x `op` y."
02:18:13 <kmc> -- da report
02:18:29 <kmc> just keep in mind that this is just syntax
02:18:57 <baaba> > let plus = (+) in (plus 1 2, 1 `plus` 2, 1 + 2, (+) 1 2)
02:19:10 <kmc> (3, 3, 3, 3)
02:19:14 <baaba> :P
02:19:15 <Alpounet> haha
02:19:24 <kmc> we all gotta pitch in and do our part
02:19:50 <Alpounet> kmc, lambdabot usually begins her answers with a space
02:19:57 <kmc> true
02:20:00 <kmc> i am an impostor
02:20:05 <baaba> kmc is a unique snowflake
02:20:13 <Alpounet> but, well, you're doing great apart from that
02:20:31 <Trinitron> So wait a minute, how do you debug functional programs?
02:20:50 <Trinitron> Just by looking at it?
02:20:54 <kmc> Trinitron, do you mean "how do you debug Haskell programs"?
02:21:03 <baaba> yeah you kind of scrunch up your nose and stare real hard at your monitor
02:21:11 <baaba> if you're hardcore enough you'll see the problem right away
02:21:11 <Twey> *nod*
02:21:27 <Trinitron> Is there a GDB for Haskell?
02:21:32 <Alpounet> ghci has a debugger
02:21:34 <kmc> what would that mean?
02:21:40 <kmc> ghci has a debugger
02:21:53 <Alpounet> http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-debugger.html
02:22:03 <kmc> the main way to debug Haskell programs is to write them as a bunch of small pieces you can test individually
02:22:09 <kmc> i.e. individual functions or other values
02:22:13 <kmc> which you can test in ghci
02:22:17 <Alpounet> and inspect
02:22:40 <kmc> if f doesn't work, then ideally f is defined as (g . h) and you can see whether g and h work
02:22:56 <kmc> i think the ghci debugger is not too commonly used in practice
02:23:08 <kmc> if you need to print values from the middle of some code, you can use Debug.Trace
02:23:18 <kmc> but this is generally not as useful as interactively poking your functions with ghci
02:23:27 <Alpounet> that's more for breakpoints or such features that I would use it
02:23:30 <Alpounet> I haven't yet, though
02:23:42 <Twey> Breakpoints are kind of awkward to use outside imperative-land
02:24:10 <kmc> maybe?
02:24:20 <kmc> they're awkward to use with laziness
02:25:08 <kmc> since we try not to write programs by reasoning about control flow, it doesn't make sense to debug that way
02:25:26 <kmc> unfortunately it's pretty much necessary to debug a lot of performance issues
02:25:37 <ivanm> preflex: seen Axman6
02:25:38 <preflex>  Axman6 was last seen on #haskell 1 day, 2 hours and 38 minutes ago, saying: i wish the cuda code was open, then i would have something to go off
02:27:58 <Twey> kmc: Really?  I think vacuum and Debug.Trace are more usefulâ¦
02:28:20 <kmc> hm, i haven't used vacuum for it, that's a good suggestion
02:28:36 <kmc> i did not mean that ghci debugger is useful for tracking down performance issues
02:29:07 <kmc> i meant that thinking about evaluation order is
02:29:16 <Twey> Oh, right.  Yes.
02:29:23 <kmc> whereas it's supposed to be irrelevant to correctness
02:29:42 <kmc> "hard to make it fast" versus "hard to make it work at all" :)
02:29:52 <Twey> Heh
02:43:45 <Trinitron> So someone said that Haskell was an imperative language.'
02:43:52 <Trinitron> Is it true?
02:44:16 <ibid> depends on your definition of "imperative", but there are sensible definitions that do apply
02:44:24 <ibid> (as well as sensible definitions that don't)
02:44:32 <dbelange> Saizan, why you got to be hating?
02:44:36 <mornfall> You could say there's an imperative EDSL for Haskell. : - )
02:44:38 <ibid> i'd say that haskell has an imperative sublanguage
02:44:41 <ibid> yes :)
02:45:29 <ibid> i think it was SPJ who once said, haskell is the world's best imperative language, or something to that effect
02:46:02 <Trinitron> How can you classify it as an imperative language?
02:46:10 <Trinitron> I don't get that.
02:46:21 <kmc> Trinitron, you can write imperative programs
02:46:34 <kmc> programs that are composed principally of steps to be carried out sequentially, which can affect the outside world
02:46:35 <Trinitron> I didn't know that.
02:46:46 <kmc> it's true of every practical functional language
02:46:59 <kmc> "functional" and "imperative" are in no way antonyms
02:47:08 <kmc> they describe distinct capability-sets that can both be present in one language
02:47:31 <kmc> although people will argue about how this or that language encourages this or that style
02:47:58 <kmc> many languages force you to express even pure computation as a sequence of steps
02:48:25 <Trinitron> So Haskell is a kind of syntactic sugar for imperative languages?
02:48:30 <kmc> no
02:48:59 <Trinitron> It still seems functional to me.
02:49:02 <kmc> yes
02:49:18 <kmc> Haskell treats pure computation more descriptively, but lets you use sequential steps when that's actually what you're trying to express
02:49:18 <ibid> Trinitron: functional and imperative are not mutually exclusive
02:49:25 <baaba> haskell *has* syntactic sugar for imperative programming
02:49:30 <ibid> (except if you define them that way)
02:49:40 <Trinitron> I thought you can't change a variable.
02:49:49 <kmc> Trinitron, sure, but you can change other things
02:50:05 <kmc> there are three or four different flavors of mutable cell in the standard library
02:50:24 <baaba> Trinitron: you use a different construct than normal variables
02:50:30 <Trinitron> I see.
02:50:31 <kmc> a value is immutable, by definition.  and a variable is a name for a value, not a name for a location where values are stored.
02:50:33 <ibid> and besides, variable immutability is by no means the defining characteristic of functionality :-)
02:50:42 <kmc> but there are *other* things (themselves values) which are names for locations
02:50:43 <baaba> but syntax sugar makes it look fairly normal
02:50:45 <kmc> which can be updated
02:50:55 <kmc> in C, a variable is a name for a location
02:51:04 <Trinitron> Hmm so Haskell really can be a turing machine.
02:51:16 <kmc> in Haskell, a variable is a name for a value, which might itself be a name for a location (if it has the right type, e.g. IORef)
02:51:18 <Trinitron> As well as a lamda calculator.
02:51:21 <kmc> indeed
02:51:21 <Trinitron> lambda*
02:51:40 <kmc> Haskell has unusually good support for imperative programming
02:52:06 <kmc> because we treat "sequence of steps" as a first-class datatype which can be built programmatically
02:52:11 <Trinitron> I thought the whole point was to get away from imperative techniques.
02:52:23 <baaba> no
02:52:29 <kmc> so, for example, control flow structures like for, while, try/catch, C++'s RAII or Python's "with", are all ordinary functions in Haskell, not special syntax
02:52:37 <kmc> and you can define your own control flow to suit your problem
02:52:48 <kmc> Trinitron, the point is to get away from the mindset that imperative techniques are the *only* techniques
02:52:56 <Trinitron> Ah.
02:53:03 <kmc> some problems really are imperative!
02:53:27 <Trinitron> I thought you could design a functional language program to do all imperative tasks.
02:53:48 <baaba> sure, you can use brainfuck to do anything too :P
02:53:50 <kmc> i don't know what that means
02:54:10 <baaba> he means every imperative program can be translated to a functional program
02:54:19 <kmc> but what does that mean, a "functional program"?
02:54:20 <Alpounet> hooray
02:54:26 <baaba> probably purely functional
02:54:30 <kmc> in Haskell, does it mean a program which doesn't use the IO type?
02:54:33 <Alpounet> gitit builds fine
02:54:35 <Saizan_> Trinitron: there's research going on to eliminate the need of imperative constructs even for domains where you find them used in haskell
02:54:44 <kmc> yes, for example FRP
02:54:53 <Trinitron> FRP?
02:55:04 <kmc> functional reactive programming
02:55:52 <kmc> e.g., you describe interactive GUIs, animations, etc. as pure functions from time and user input to output
02:56:00 <kmc> but this is still an active area of research
02:56:23 <osfameron> are there any explanations of FRP that make sense to a small-to-medium sized brain? ;-)
02:56:50 <Trinitron> Can you design a purely functional operating system?
02:57:06 <osfameron> Trinitron: it has been done, so yes
02:57:12 <kmc> example?
02:57:16 <osfameron> House ?
02:57:21 <kmc> is an OS written in Haskell
02:57:29 <kmc> i don't know what would make it "purely functional"
02:57:31 <osfameron> ah, not pure FP though?
02:58:00 <kmc> "pure FP" means a bazillion different things
02:58:19 <kmc> for example we say "pure function" to mean a function whose application (and subsequent beta-reduction) causes no side effect
02:58:37 <kmc> which is true of every function in Haskell, as long as you don't cheat and don't look too deep into, say, GHC's implementation of the IO monad
02:58:56 <kmc> but that doesn't mean Haskell programs don't describe and execute effects
02:58:56 <Trinitron> So research is being doing to expand functional programming into all problem domains?
02:59:09 <Trinitron> without using imperative constructs?
02:59:29 <kmc> Trinitron, yes
02:59:42 <Trinitron> Right now, it's an impossibility for some things?
03:00:07 <kmc> sort of?
03:00:11 <Trinitron> OK.
03:00:22 <kmc> it's not clear where you're drawing the lines for "functional programming" and "imperative constructs"
03:00:29 <kmc> i wouldn't worry too much about drawing these lines
03:00:42 <Trinitron> functional programming, like discrete mathematics.
03:00:47 <Trinitron> mathematical functions.
03:01:06 <kmc> you mean functions that are deterministic based on their input, and have no side effects?
03:01:09 <Trinitron> recurrence relations, set comprehensoins
03:01:13 <Trinitron> referential integrity
03:01:18 <kmc> every function in Haskell has that property, even putStr
03:01:32 <Saizan_> the fact is that you purely functionally describe imperative actions to be performed, so the line is quite blurred
03:01:48 <kmc> putStr is a pure function which takes a string and returns an IO-recipe
03:02:25 <Phyx-> hrm... does this error http://phyx.pastebin.com/JHNh0UEG mean what I think it does? That I need to recompile every lib with -fPIC
03:02:54 <kmc> people also say "pure function" to mean "code which does not use monads", which i think is a pretty terrible usage
03:04:50 <kmc> roughly equivalent to saying that "pure function" means "code which does not use map"
03:05:23 <Saizan_> it does make some sense actually
03:06:26 <Saizan_> it's like saying "i'm programming in a language where functions are represented as values of type a -> m b in haskell, so in this language i've side-effects"
03:07:12 <kmc> what about monads that aren't about side effects?
03:07:36 <Saizan_> such as?
03:07:56 <kmc> Maybe, [], Cont r, Parsec
03:07:59 <kmc> most of them?
03:08:11 <Saizan_> in this sense those are about side effects
03:08:16 <kmc> i don't know, you can stretch your definition of "side effect" pretty far
03:08:43 <Phyx-> hrm.. how does one pass extra ghc flags to cabal? (since i wanted this by default, i edited the config file and put them in flags but nothing happened)
03:08:47 <Saizan_> "anything you can't do if you have only a -> b"
03:09:23 <kmc> but «a -> m b» is a type specialization of «a -> b»
03:09:49 <Saizan_> yeah, but application won't do the right thing
03:10:22 <Saizan_> ok, yeah, the language i'm describing is like pure lambda calculus where function application has been substituted with =<<
03:10:40 <Saizan_> though you don't see it
03:12:49 <Saizan_> i wouldn't call such a language pure or side-effect free, whatever the monad is
03:17:54 <Saizan_> (the inverse process is how Moggi used monads for denotational semantics, btw)
03:20:31 <blackh> Why does "t1 <- (modelsAndTextures0 `using` parList rdeepseq) `seq` getSystemTime" not force evaluation, while "t1 <- (rnf $ modelsAndTextures0 `using` parList rdeepseq) `seq` getSystemTime" does??  Anyone know?  getSystemTime is an IO action
03:21:24 * idnar attempts to port Criterion to JavaScript
03:21:52 <fasta> blackh, that only forces enough to prove it is not undefined.
03:22:29 <Saizan_> well, it depends on what "parList rdeepseq" is doing
03:22:32 <Saizan_> or should be doing
03:23:07 <Saizan_> it's not unreasonable to think that parList should propagate the forcing to the whole list
03:23:19 <blackh> But surely no matter how badly I've defined rnf for the elements, either both should force evaluation or both should not!
03:23:33 <Saizan_> well, no
03:23:49 <Saizan_> the second one surely forces the whole spine and its contents
03:24:10 <tumult> hi, i have a weird question about distribution. my haskell program processes files from one format to another. it uses a chunk of binary data (about 15k) when creating the output file. is there a good way to get this binary data into the compiled program binary? since i'm looking to make it easy to distribute.
03:24:12 <Saizan_> however it's quite wasteful, afaiu
03:24:28 <blackh> So why doesn't the first one force the (parallel) evaluation of the list contents/
03:25:34 <blackh> tumult: Use 'print bs' in ghci, then paste the output into your program (assuming bs is a ByteString)
03:25:55 <tumult> haha oh boy, ok
03:26:02 <tumult> guess i'll set up a build script to do that
03:26:08 <Saizan_> blackh: you are using parallel-2.2.0.1 right?
03:26:41 <kmc> tumult, it's the same chunk always?
03:26:51 <tumult> it might change a little between versions of the app
03:26:57 <tumult> but it's just a static chunk of binary data, yeah
03:27:00 <Saizan_> (so that i look at the right code)
03:27:01 <kmc> but it's not generated on compilation?
03:27:04 <blackh> Saizan_, fasta: Yes, 2.2.0.1.  I was under the impression that if you add `using` parList rdeepseq, to something, then `seq` someIOAction in IO should force it to evaluate.  There's something I don't understand!
03:27:05 <tumult> nope
03:27:11 <kmc> yeah, just paste it into a file
03:27:17 <tumult> right on
03:27:44 <fasta> blackh, there is a tutorial on all the concurrency stuff. That will bring you from questioning to knowing.
03:28:12 <quicksilver> blackh: `using` changed completely in one revision of parallel
03:28:28 <fasta> quicksilver, that is hilarious.
03:28:38 <quicksilver> you may say that.
03:28:45 <blackh> quicksilver: I am sure the old `using` worked the way I described.  I seem to be having trouble getting used to the new one.
03:28:52 <quicksilver> the decision was taken after considerable thought and documented in the release notes
03:29:02 <quicksilver> blackh: yes, I think the old one did work the way you describe
03:30:07 <fasta> A proper solution for that stuff is simply to offer a code transformation tool to go from one version to the next preserving semantics.
03:30:30 <blackh> It just seems very odd to me - I thought it was obvious that attaching `using` to something meant that forcing it at the top level with seq will trigger the specified strategy.  Now I'm flummoxed1
03:30:39 <Saizan_> the current using seems a bit broken to me, tbh
03:32:16 * blackh found the link to Simon Marlow's paper and will read it.
03:32:25 <Alpounet> oh, chrome doesn't seem to support mathml
03:32:34 <Alpounet> annoying for gitit
03:33:32 <quicksilver> blackh: I remember reading a rationale for the new C.P.Strategy but I can't find it now.
03:45:34 <Saizan_> where was benmachine's symbolic evaluator?
03:46:43 <amuller> Hello, I want to use the new Data.Map that comes in GHC 6.12.1 instead of the one in GHC 6.10.4... I need the toDescList function that is commented out in an earlier version...
03:47:31 <amuller> Do you recommend using 6.12.1 or is it better to migrate 6.12.1 Data.Map to my local project?
03:48:29 <blackh> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24013#a24013  <-- a test program illustrating parallel-2.2.0.1 behaviour, in case anyone is interested
03:48:43 <blackh> I'm going to get to the bottom of it.
03:50:23 <blackh> amuller: What sort of project is it?
03:51:26 <amuller> I need to do range queries on Data.Map on a large number of objects
03:52:12 <amuller> The project itself is a bioinformatics one, and the amount of data is very large so I need an efficient way of doing binary search.
03:52:44 <amuller> Data.Map in GHC 6.10.4 does not allow efficient range queries because someone commented out an important function called toDescList
03:52:45 <quicksilver> amuller: toDescList does not give you efficient range queries.
03:52:55 <amuller> really quicksilver? ooops
03:53:03 <quicksilver> amuller: lists have O(n) element access
03:53:10 <quicksilver> I don't think toDescList is going to help you much.
03:53:27 <amuller> I thought that because of laziness toDescList would be efficient.
03:53:38 <quicksilver> it's still O(n) to reach an element.
03:53:39 <amuller> How would you do a range query in Haskell quicksilver?
03:53:47 <quicksilver> I'd look up the right structure ;)
03:53:55 <quicksilver> isn't there a clever fingertree for range queries?
03:54:38 <mauke> amuller: isn't that what split is for?
03:54:42 <amuller> OK, I will try using it. In principle a binary tree or an array should be "right" for range queries.
03:54:55 <quicksilver> well, there is a clever fingertree for intervalmaps
03:54:57 <amuller> Yes sure, of course toDescList is applied after doing an split!
03:55:05 <amuller> Therefore I thought that would be efficient
03:55:05 <quicksilver> that's something like the dual of a range query
03:55:18 <mauke> ok, what is a range query?
03:56:31 <amuller> A = [0 .. 20] without [5] and I want to have the range [4,6] then if I apply a range query on A, the result should be [4,6]
03:57:12 <amuller> Give me the numbers such x | min <= x && x <= max in a given list of numbers
03:57:20 <mauke> so split twice
03:57:25 <mauke> also that looks like a Set, not a Map
03:58:02 <amuller> if the keys of a map have a total order, then you can do range queries too mauke
03:58:39 <mauke> they better (isn't that what Ord is for?)
04:00:11 <amuller> So I wanted to use Data.Map because it is very stable and well tested. In 6.12.1 the function is available but when I bring the new file and compile it locally I get:
04:00:12 <amuller> Could not find module `Data.Data':
04:00:13 <amuller>       it is a member of the hidden package `base'
04:00:19 <amuller> Any ideas on how to solve this compilation error?
04:01:06 <amuller> br right back!
04:01:27 <mauke> split is in 6.10
04:10:35 <tumult> is there a way to use cabal to optionally build an executable separate from the normal program binary for my package?
04:10:58 <tumult> but not have it normally include the tests executable when building unless some option is passed or something
04:11:05 <fizruk> @src showsPrec
04:17:05 <jlouis> tumult: flags perhaps?
04:18:41 <Saizan_> blackh: i get different results in ghci
04:19:12 <Saizan_> blackh: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24013#a24014
04:20:27 <blackh> Saizan_: You might be interested in this... http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24015#a24015
04:21:29 <Saizan_> blackh: so it seems to work, right?
04:21:49 <blackh> Well, I have it almost figured out.
04:22:45 <Saizan_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24013#a24016 <- with -threaded it actually gives this result when compiled, your first example i mean
04:23:09 <Saizan_> it's just that the worker threads don't get enough time to work
04:23:21 <blackh> So it looks like it's sparking it, but the `pseq` at the end doesn't force it.
04:23:53 <Saizan_> what do you mean by force?
04:24:09 <Saizan_> that evaluation should block there until all the sparks get run?
04:24:36 <blackh> Yes, that's what you want `pseq` to do... evaluate everything on the left before the things on the right
04:24:43 <Saizan_> ah, no
04:24:55 <Saizan_> pseq evaluates only up to WHNF
04:25:04 <ivanm> Axman6!
04:25:07 <jlouis> hey Axman6 !
04:25:18 <Axman6> o/
04:25:20 <jlouis> **5's ivanm
04:25:23 * Axman6 feels loved
04:25:30 <Saizan_> blackh: which means the first constructor
04:25:31 <jlouis> I hope you are a Floating ivanm and not a Num
04:25:42 <ivanm> Axman6: waiting for you to reply to that email...
04:25:51 <ivanm> jlouis: Floating values are Num values...
04:26:15 <blackh> Right - so I think that with the old parList rnf, forcing WHNF caused it to evaluate. With the new parList rnf, you have to force the spine.
04:26:15 <jlouis> depends on the Prelude!
04:26:27 <ivanm> heh
04:26:54 <Axman6> heym we've got responses, whoot
04:27:06 <ivanm> yup
04:27:10 <blackh> So "(l `using` parList rdeepseq) `using` seqList rwhnf" is equivalent to the old "l `using` parList rnf"
04:27:15 <ivanm> Axman6: that makes four of us...
04:27:40 <Saizan_> blackh: ah, ok, i didn't understood you at first, i thought the problem was that the elements wouldn't get sparked
04:28:02 <blackh> Saizan_: And my horribly ugly test case #2 shows that this actually does evaluate the elements in parallel.
04:28:03 <ManateeLazyCat> I define some IORef attribute in data declaration, if i use MVar or STM wrap data variable, i still get safe result in multi-thread environment?
04:28:24 <Saizan_> blackh: yeah
04:28:37 <ivanm> preflex: seen blackdog
04:28:37 <preflex>  blackdog was last seen on #haskell 9 days, 5 hours, 29 minutes and 13 seconds ago, saying: dark: http://www.cse.unsw.edu.au/~chak/papers/WC08.html
04:28:45 <Saizan_> at which point i wondered what was the problem again :)
04:28:51 <blackh> Saizan_: My original problem was that I couldn't force them.  I didn't want to use `using` rdeepseq because that would involve my huge data structure getting traversed twice
04:29:27 <Axman6> ivanm: ... how do i reply to the message?
04:29:39 <Axman6> when i hit reply, it wants to send it to you :(
04:29:46 <ivanm> Axman6: reply all ;-)
04:29:51 <Axman6> k
04:30:24 <blackh> Saizan_: So the final answer is, with the new parallel-2.2.0.1:  (l `using` perList rdeepseq) `using` seqList rwhnf) `pseq` [something] is how you force a list to be evaluated in parallel
04:31:10 <Saizan_> blackh: ok, it makes sense
04:32:37 <ManateeLazyCat> With multi-thread environment, IORef is safe when outside wrap with MVar or STM ?
04:32:53 <yakov> hey
04:33:07 <Saizan_> the only problem i've with the new parallel is that (`using` rwhnf) doesn't do anything.
04:33:15 <blackh> ManateeLazyCat: I have never looked at the code to verify, but I have used IORef a *lot* assuming it is thread safe and it has never misbehaved.
04:33:41 <blackh> Saizan_: Did it do something before?
04:33:45 <ManateeLazyCat> blackh: IORef is not safe in multi-thread.
04:34:05 <mauke> why would you wrap an IORef in an MVar?
04:34:14 <quicksilver> blackh: (and fasta) here is the release notes I couldn't find before : http://www.haskell.org/pipermail/haskell-cafe/2009-November/069439.html
04:34:19 <mauke> just use a TVar
04:34:27 <Axman6> blackh: how would you like to come over to Aus for a haskell hackathon?
04:35:53 <Saizan_> blackh: heh, you're right, a `seq` a = a  :)
04:37:05 * blackh 's computer just had the dreaded Ubuntu focus stuck bug
04:37:46 <ivanm> blackh: s/just had/has/ s/focus stuck //
04:37:49 <ivanm> ;-)
04:38:49 <blackh> Axman6: It's such a long way!
04:39:35 <Axman6> but when are you ever going to be able to go to a hackell hackathon in NZ?
04:39:43 <ManateeLazyCat> blackh: BTW, never use IORef so much, special don't use `IORef Foo` as your function argument. Keep function purely.
04:40:29 <blackh> ManateeLazyCat: I've been doing a lot of gtk2hs - I don't use IORefs by choice.
04:40:55 <blackh> Axman6: When is it on?
04:41:01 <dcoutts> blackh: I've been using gtk2hs too, I don't use IORefs either.
04:41:19 <dcoutts> blackh: or did you mean you feel forced into using IORefs all over the place?
04:41:25 <Axman6> blackh: hasn't been decided yet
04:41:33 <ManateeLazyCat> blackh: No.
04:41:41 <Axman6> we only floated the idea on -cafe this afternoon :)
04:41:42 <ManateeLazyCat> blackh: I have use gtk2hs too, and don't use IORef.
04:42:07 <ManateeLazyCat> blackh: I have a project, and most code is base on gtk2hs, i never use IORef.
04:42:24 <blackh> dcoutts, ManateeLazyCat: I haven't figured out how to do gtk2hs stuff without IORefs, but I've managed to do a lot of event handling in a co-routine monad
04:42:32 <ManateeLazyCat> blackh: Keep all your function purely, then use TVar or MVar replace.
04:43:02 <blackh> Oh right - forkIO + MVar is definitely better than IORef... but this co-routine thing works really nicely
04:43:26 <Eelis> dcoutts: in a .cabal file, is there a way to specify that a certain flag should not be backtracked on? i don't want the flag to be automatically set to its non-default value when its dependencies cannot be met
04:43:36 <ManateeLazyCat> blackh: I mean, you don't need make `IORef Arg` as argument transform into function. You can use TVar and MVar out those *pure* functions.
04:44:08 <ManateeLazyCat> blackh: TVar is better than MVar.
04:44:49 <zygoloid> preflex: seen lambdabot
04:44:49 <preflex>  lambdabot was last seen on #haskell 5 hours, 39 minutes and 51 seconds ago, saying: Data.Foldable maximum :: (Foldable t, Ord a) => t a -> a
04:44:51 <blackh> Axman6: If it's not too soon, I might come over. I'm a bit busy. Otherwise I'll come to the next one.
04:45:01 <ManateeLazyCat> blackh: Trust me, i write `IORef` everywhere like you, but now i got bad thing, it's lost flexibility.
04:45:09 <Axman6> blackh: it's likely to be mid year
04:45:33 <dcoutts> Eelis: no, all flags can be backtracked on
04:45:36 <blackh> Axman6: Great - well, I am definitely tempted!
04:45:45 <Axman6> :D
04:45:57 <Eelis> dcoutts: i see. is there a issue tracker somewhere where i could request this as a feature? does it seem reasonable?
04:46:19 <dcoutts> Eelis: but if its deps cannot be met then it should not try to pick it in the first place
04:46:33 <ManateeLazyCat> dcoutts: How you doing? Still busy, ah?
04:46:58 <dcoutts> Eelis: unless we're talking about a kind of dep that it currently doesn't consider, like C lib, in which case the solution is to fix that, not extend the semantics of flags.
04:47:17 <dcoutts> ManateeLazyCat: yep, still busy. But going to the hackathon this weekend! Wee!
04:47:19 <ivanm> blackh: were are you based?
04:47:32 <ivanm> dcoutts: going to come down for ours if we manage to get one organised? :p
04:47:39 <blackh> ivanm: I am in New Zealand, in the sunny Manawatu region.
04:47:54 <dcoutts> ivanm: what on the wrong side of the world? ;-)
04:47:54 <ivanm> aha
04:47:55 <Axman6> ivanm: reply sent
04:47:57 <Eelis> dcoutts: i have a package which has an optional component that has extra deps. by default the component should be installed, so i've set the default value of its corresponding flag to true. when people don't have the dependency, i want them to get an error saying that they can explicitly disable the component by unsetting the flag if they don't want the component
04:47:59 <ManateeLazyCat> dcoutts: Axel have on working that make gtk2hs install by cabal. That's really good news. :)
04:48:00 <ivanm> so it's not that far for you!
04:48:10 <ivanm> dcoutts: the "better" side of the world!
04:48:11 <ManateeLazyCat> dcoutts: Then gtk2hs will develop faster.
04:48:15 <ivanm> Axman6: \o/
04:48:19 <dcoutts> ManateeLazyCat: excellent
04:48:26 <Eelis> dcoutts: what i /don't/ want is that cabal silently doesn't build the component, as it constantly confuses my users
04:48:30 <dcoutts> ivanm: oh, thanks for correcting me :-)
04:48:35 <ivanm> no worries!
04:48:36 <ivanm> :D
04:48:41 <blackh> dcoutts, ivanm: The quieter side of the world.
04:48:43 <ManateeLazyCat> dcoutts: And Webkit have push in repository, just some compile error haven't finish.
04:49:08 <ivanm> blackh: hmmm, I suppose there are less politicians in this hemisphere...
04:49:40 <fasta> Haskell specifies that when compiling module M, any instance declaration in any module "below" M is visible. (Module A is "below" M if A is imported directly by M, or if A is below a module that M imports directly.) In principle, GHC must therefore read the interface files of every module below M, just in case they contain an instance declaration that matters to M. This would be a disaster in practice, so GHC tries to be clever.
04:49:55 <fasta> Why would that be a disaster?
04:50:39 <fasta> To me it seems only to be a disaster if you compile file by file ignoring the work that has been done before.
04:50:49 <dcoutts> Eelis: so the point is you want it to fail rather than deciding to not build the optional component, since the optional component isn't all that optional. It's technically optional but your users all expect it to be there.
04:50:56 <Eelis> dcoutts: precisely
04:51:13 <Eelis> 80% of my users will want it, and will be surprised if the package is built without it
04:51:22 <danderson> fasta: the docs probably mean a performance disaster.
04:51:24 <Eelis> the other 20% should unset the flag
04:51:51 <danderson> doing file I/O is slow compared to compilation, and the transitive closure of imports can get really huge
04:51:52 <fasta> danderson, yes, that part was clear. The question is why it would mean a performance disaster.
04:51:55 <ivanm> dcoutts: so I'll put you down as a "yes" then? :p
04:52:10 <fasta> danderson, yes, but why would this file I/O have to be done every single time?
04:52:15 <Eelis> dcoutts: and the way i imagine this could work is if the Flag section just supported a "recurse: False" clause or something
04:52:21 <fasta> danderson, why can't it just cache everything it sees?
04:52:32 <danderson> fasta: I assume this is what is meant by "tries to be clever"
04:52:46 * Axman6 thinks that dcoutts should come down for our hackathon as well
04:52:47 <danderson> another possibility would be to write all instance declarations for the transitive closure in each interface file
04:53:04 <danderson> that way you only need to consult the direct dependencies to get a complete picture of everything your module has
04:53:15 <ivanm> dcoutts: surely welltyped can pay for it in terms of "promotional" costs? :p
04:53:18 <dcoutts> Eelis: so do pleas file a ticket describing the need, ie the 80/20 surprise thing. There are various ways we might think about solving it though, so no need to specify the implementation you first thought of.
04:53:20 <ivanm> preflex: seen dobblego
04:53:20 <preflex>  dobblego was last seen on #haskell 13 hours, 38 minutes and 29 seconds ago, saying: and so now we have this
04:53:24 <ivanm> hmmm...
04:53:37 <Eelis> dcoutts: alright, thanks
04:54:21 <ivanm> Axman6: who else do we have down here who's on IRC? dobblego, blackdog, TacticalGrace, you, me, blackh (right neck of the woods anyway)... anyone I'm missing?
04:54:43 <Axman6> that's all i can think of
04:54:52 <dcoutts> Eelis: a design/spec thing I'm keen to keep is that the semantics for the cabal flags remain simple. What various tools choose to do with them can be more flexible.
04:55:16 <dcoutts> Eelis: the danger is in overspecifying what tools must do with flags.
04:55:20 <Eelis> dcoutts: i'm a big fan of simple semantics, but only if those semantics are the intuitive ones ;)
04:55:22 <blackh> ivanm: Hamish Mac is the other NZ Haskeller. He's one of the authors of Leksah.
04:55:37 <ivanm> blackh: is he on IRC?
04:56:08 <dcoutts> Eelis: flags are a logic/prolog style declaration of conditional dependencies.
04:56:28 <blackh> ivanm: He's been seen on here under the handle 'hamishmack'
04:56:29 <Eelis> dcoutts: that sounds very nicely theoretical, but doesn't help my users :)
04:56:36 <dcoutts> Eelis: you want to put an additional preference/cut in there or something
04:56:40 <ivanm> preflex: seen hamishmack
04:56:40 <preflex>  hamishmack was last seen on #haskell 150 days, 52 minutes and 42 seconds ago, saying: Is it just me, or is hackage down?
04:56:50 <ivanm> blackh: not for a while though by the looks of things...
04:57:27 <blackh> That's a long time ago.  I saw him in person a couple of months ago so I know he exists.
04:57:29 <Eelis> dcoutts: all i really want is the equivalent of autotools' --without-bla configure flag
04:57:47 <dcoutts> Eelis: eg, in complex cases we'll likely need a sat solver, so we do not want to over-serialise the decision process
04:57:54 <blackh> Perhaps he'll come on next time hackage is down.
04:58:07 <zygoloid> dcoutts: sounds like Eelis simply doesn't want a decision process at all for this flag
04:58:10 <dcoutts> Eelis: eg when I want to install 50 interdependent packages in one go
04:58:17 <Eelis> zygoloid: exactly
04:58:28 <dcoutts> zygoloid: there's necessarily a decision process
04:58:40 <dcoutts> when I have things that might depend on Eelis's package
04:59:04 <jlouis> ivanm: you planning an .AU hackathon?
04:59:04 <Eelis> nothing will ever depend on my package. it only exposes some end-user executables
04:59:05 <dcoutts> when asking things like "is this installable consistently with that"
04:59:23 <ivanm> blackh: heh
04:59:29 <dcoutts> which is the sort of question we want to provide answers to on hackage
04:59:40 <ivanm> jlouis: yes
04:59:43 <ivanm> you interested in coming?
04:59:52 <fasta> danderson, well, I cannot see anything which would require "extra work" fundamentally.
04:59:59 <jlouis> ivanm: I would be seriously jetlagged then
05:00:09 <jlouis> I am in the same TZ as Zurihac
05:01:00 <danderson> jlouis: and attending? (Zurihac)
05:01:17 <ivanm> jlouis: but in which part of the world?
05:01:27 <ivanm> timezones cross both hemispheres...
05:01:47 <jlouis> ivanm: Denmark, up north... but not that far
05:01:57 <ivanm> *nod*
05:02:34 <jlouis> danderson: nope. I'll be on IRC though
05:03:27 <dankna> dcoutts: Are you around?  I particularly wanted your opinion on my feature proposal which I mailed to cabal-devel.
05:03:45 <dcoutts> dankna: should I read it first?
05:03:57 <dankna> haha, it would be preferable :D
05:05:38 <dcoutts> dankna: so my first thought is that you probably want a separate richer db for plugin registration
05:05:51 <dcoutts> dankna: I think standard practise is to drop a file in a specific location
05:05:55 <dankna> that's an interesting point
05:06:51 <dankna> the nice thing about doing it my way would be that it already handles the thing about overlaying the per-user database on the global one
05:07:20 <dankna> this is really just to handle discovery - once the plugin is discovered, any further inquiries can be made by linking it and inspecting fields that it exports
05:07:55 <dcoutts> dancor: so instead of proposing a specific solution, perhaps specify the problem more, what features do plugin systems really need.
05:08:26 <dankna> well, this seemed nicely minimal to me, but I certainly take your point
05:08:35 <dcoutts> dancor: perhaps it will be clear that it's best to tie it to the ghc package registration, but perhaps not
05:08:41 <dankna> I'm dankna, btw, not dancor
05:08:42 <dankna> hmm
05:08:47 <dcoutts> oops, sorry :-)
05:08:50 <dankna> np :)
05:09:26 <dankna> the other nice thing about tying it to package registration is that it deals with the multiple-version problem nicely
05:09:36 <dankna> there's no reason to solve that problem again if it can be avoided
05:10:14 <dcoutts> dankna: so, eg how about the plugins finding out where the package is installed and then dropping a file in that package instance's dir
05:10:23 <dankna> hmm
05:10:38 <dankna> I take it it's possible already to hook into Cabal to do that at install-time?
05:11:00 <dankna> that would certainly work
05:11:16 <dcoutts> dankna: every installed package has a unique installed package id, there could be a specific place to put such stuff
05:11:34 <dcoutts> dankna: eg $share/$pkgid/plugins/
05:11:46 <ivanm> dcoutts: btw, did you manage to get my @ask messages before lambdabot died?
05:11:57 <dcoutts> ivanm: I don't recall
05:12:10 <dankna> that makes a lot of sense, actually.  it saves a full traversal of the package tree, for starters.
05:12:16 <dankna> er, list
05:13:02 <ivanm> dcoutts: the main thing I wanted to check with you is: with cabal-install, it seems that if something fails to build due to dep problems and I then try to re-build it with --constraint, it doesn't re-configure and magically pulls out the pre-configured constraints from somewhere
05:13:14 <ivanm> is that correct behaviour?
05:13:54 <dankna> does Cabal-install currently support any sort of post-install script?  that seems like the easiest way to perform that installation
05:13:56 <nuba> w 25
05:14:06 <dcoutts> ivanm: I'm not sure I follow, I'd need a more specific bug report.
05:14:17 <ivanm> dcoutts: *nod*
05:14:20 <dcoutts> dankna: you can put what you like in a custom Setup.hs
05:14:21 <ivanm> dcoutts: want it now or later?
05:14:23 * dcoutts will shortly disappear
05:14:27 <dcoutts> ivanm: email
05:14:29 <ivanm> later then I guess ;-)
05:14:39 <ivanm> dcoutts: OK, I'll do that tomorrow since I was doing it from my uni machine
05:14:39 <dankna> ah, gotcha.  okay.  so perhaps I don't even need a Cabal extension at all then.  yay? :)
05:15:07 <dcoutts> dankna: so perhaps follow up on the list, think through the steps, it might be that Cabal can help a bit, reduce the amount of custom code needed.
05:16:04 <dankna> that makes sense.  I'll start on an implementation in a custom Setup.hs and inform the list of my progress; any custom code that's particularly arduous it might make sense at that point to incorporate into Cabal.
05:16:27 <dankna> thanks for your advice
05:24:59 <mreh> :t constant
05:25:10 <blackh> So what's the trick to hard-code your RTS options?
05:25:15 <mreh> @bots
05:25:40 <blackh> Never mind - found it in the user's guide
05:25:58 <mauke> preflex: version
05:25:58 <preflex>  4.322
05:26:26 <mreh> I've used a function "constant", but I have no idea where it's from
05:26:29 <mreh> @hoogle constant
05:26:36 <mreh> oh.. heh
05:26:43 <mreh> anyway, no results from hoogle
05:27:36 <mauke> what does it do?
05:28:52 <danderson> do you mean the const function?
05:28:56 <Jafet> I expect it produces a constant, but a different one each time
05:28:56 <danderson> @hoogle const
05:29:29 * danderson gives CPR to the bot
05:29:53 <mauke> preflex: seen CalJohn
05:29:53 <preflex>  CalJohn was last seen on #haskell 14 hours, 16 minutes and 28 seconds ago, saying: lament: it seems like an interesting discussion to have (because I don't agree), but i'm quite busy, sorry!
05:29:54 <mauke> er
05:30:14 <Jafet> I'd suggest leaving out the R, but that'd leave a less savoury initialism
05:36:54 <mreh> does intercalate have an inverse?
05:36:58 <ivanm> Axman6: *phew* just did a mini tutorial on type classes are in the `what does "=> "mean? ' thread on streams :s
05:37:12 <mauke> mreh: split package on hackage
05:37:15 <mreh> not inverse...
05:37:45 <ivanm> @type intercalate
05:37:50 <ivanm> bah
05:38:09 <ivanm> mreh: not sure if there is an inverse...
05:38:23 <ivanm> you could do a parsing-like inverse using sepBy, etc. ...
05:38:28 <mreh> inverse was the wrong word
05:38:45 <ivanm> you want :: [a] -> [a] -> [[a]] ?
05:41:27 * ivanm -> sleep
05:59:17 <merijn> Is there a de facto standard (asynchronous) networking library for haskell?
06:00:15 * ManateeLazyCat STM will be more efficient if hardware support it. :)
06:00:33 <ManateeLazyCat> Make hardware looking for value in thread-log.
06:00:54 <jlouis> merijn: There is event on hackage which looks promising
06:01:03 <merijn> ManateeLazyCat: Wouldn't it just be TM once done in hardware?
06:01:39 <ManateeLazyCat> merijn: TM ?
06:01:54 <jlouis> The cool thing about Haskell is that we have several choices almost everywhere
06:02:05 <jlouis> ManateeLazyCat: strike out the Software in STM
06:02:08 <osfameron> there's more than one way to do it!
06:02:10 <merijn> ManateeLazyCat: The S in STM stands for software :p
06:02:24 <ManateeLazyCat> merijn: :)
06:02:25 <jlouis> osfameron: with subtly different performance aspects
06:02:27 <merijn> jlouis: Multiple choices is not better then a single good one
06:02:47 <jlouis> merijn: not if they are built for different situations
06:02:57 <ManateeLazyCat> Yep, STM and simple enough and easier to convert.
06:03:10 <jlouis> I am quite happy we have something like 10 different ways to do concurrency
06:03:48 <ManateeLazyCat> jlouis: I enjoy write Haskell coding, very happy..... :)
06:03:56 <ManateeLazyCat> write Haskell code.
06:04:14 <merijn> jlouis: I'm not saying choice is bad, I'm just saying its not good by definition
06:04:17 * ManateeLazyCat I should write myself English-Helper.
06:05:51 <merijn> jlouis: What exactly is the name of event on hackage? I'm finding a ton of packages with event in the name
06:08:15 <Jonno_FTW> is Haskell declarative as well as functional?
06:09:53 <sioraiocht> Jafet: I would say yes
06:10:24 <Jafet> Splendidly positive of you.
06:14:14 <sioraiocht> Jafet: oops, sorry
06:14:15 <sioraiocht> hehe
06:14:42 <Jafet> If I were Prolog, I would say no!
06:16:33 <fasta> The only declarative about Haskell is that it assumes there is a magical way to run IO actions.
06:18:34 <Saizan_> what definition of "declarative" are we using?
06:18:46 <amuller> Yes mauke, split is in 6.10 but toDesc is not... Therefore efficient ranges cannot be achieved. I will try with finger trees as quicksilver suggested
06:18:51 <Cale> I don't think there is a hard definition of declarative.
06:19:16 <Cale> Haskell can be quite declarative in nature, to the extent that you're defining things equationally.
06:19:27 <mauke> amuller: why would you need toDesc?
06:19:29 <fasta> Declarative is when you only specify the logical properties of a mathematical object and then expect it to be computed.
06:19:31 <Jonno_FTW> that's what I was aksing about
06:20:05 <fasta> And generally not just computed, but efficiently computed.
06:20:32 <Saizan_> w.r.t. pure functions i guess haskell can be seen as less declarative because you defined functions in a strictly syntax-directed manner
06:20:37 <Cale> I'm not sure that's a requirement for declarativeness, myself ;)
06:20:37 <fasta> A kind of fantasy apparatus.
06:20:42 <Saizan_> less declarative than prolog
06:21:46 <Cale> How about "declarativeness" is the extent to which the denotational semantics is sufficient in understanding the operation of a program?
06:21:59 <Jafet> I wonder if you can apply SMT solver to declarative programming
06:22:18 <jlouis> merijn: they might not have pushed it yet: http://github.com/tibbe/event
06:22:29 <Saizan_> SAT Modulo Theories? i'd think so
06:22:45 <Cale> I suppose you'd have to include another factor -- divide by the complexity of the semantics you're using :)
06:23:00 <merijn> jlouis: I'll check it out, thanks
06:23:22 <Saizan_> Cale: i think you're measuring at the wrong level
06:23:29 <Cale> I think that in that regard, Haskell does quite well, even against Prolog (and I would say maybe sometimes better)
06:23:40 <jlouis> merijn: it will backend off of kqueue()/epoll() if possible
06:24:18 <Saizan_> Cale: declarativeness is about not having to transform your knowledge of the problem into a proper algorithm yourself
06:24:51 <mercury^> What's a "proper algorithm"?
06:25:24 <amuller> mauke, split would give me two subsets, one of the items smaller than the query and another of the items larger than the query.
06:25:31 <mauke> yes
06:25:41 <mauke> so what is the toDescList for?
06:25:41 <merijn> mercury^: Impossible to define as there is no clear definition of "algorithm"
06:25:59 <Cale> Prolog has a denotational semantics in terms of mathematical relations, of course, and it's how you really want to think of Prolog programs. Haskell has a denotational semantics in terms of more varied domains, and you usually want to think of Haskell functions as honest, opaque mathematical functions without worrying about the operational semantics.
06:26:09 <amuller> For a range query I need to read both subsets to give the closest elements to a given query.
06:26:13 <Saizan_> mercury^: that's the hard part to make precise :)
06:26:35 <Cale> It's sort of at the points where that stops working in both languages where you start losing the feeling that the language is successfully declarative.
06:26:44 <amuller> Therefore I need to read the "right" subset from left to right and the "left" subset from right to left.
06:27:48 <mercury^> I find that bottom is making declarative thinking very hard in Haskell. Usually the situations where it may occur are those where you need help analising the semantics, but in those cases equational reasoning is not allowed anymore.
06:27:51 <mauke> amuller: huh?
06:28:07 <mauke> amuller: why do you start in the middle of a range?
06:28:31 <Cale> Well, you can reason equationally regarding bottom, but it makes a lot of equations less general.
06:28:35 <amuller> Because I can decide to stop reading the maps if I reach a certain point. mauke
06:28:55 <amuller> This is the way similarity search indexes work for spaces of arbitrary dimension.
06:28:55 <Saizan_> Cale: though you still have to encode what you want into relations or functions, while you might have an even higher-level model of your problem
06:29:07 <Cale> Saizan_: Sure :)
06:29:20 <mercury^> It makes most equations useless. :)
06:29:32 <mauke> amuller: ok, that does make sense
06:29:51 <Cale> mercury^: Though, have you seen the "morally correct" paper?
06:29:56 <amuller> so I could use arrays and a bin sort to achieve the same.
06:29:57 <mercury^> Nope.
06:30:08 <Cale> http://www.comlab.ox.ac.uk/people/jeremy.gibbons/publications/fast+loose.pdf
06:30:09 <amuller> Is there any particular array implementation that you recommend in particular mauke?
06:30:18 <Saizan_> (relations and functions are a poor substitute for each other, btw)
06:30:21 <mercury^> Thanks.
06:30:48 <kamatsu> any germans here?
06:30:50 <kamatsu> does:
06:30:52 <kamatsu> JavaÃ¤hnlichkeitsbehauptung
06:30:57 <kamatsu> mean "claim to be similar to java"?
06:31:05 <mercury^> yes.
06:31:06 <ksf> jlouis, http://www.cs.cmu.edu/~dga/dot/
06:31:18 <kamatsu> awesome, german even has a word for that
06:31:21 <dankna> grrr, haddock
06:31:34 <ksf> that, in addition to rss feeds, and combinatorrent can be used to deal with all of hackage
06:31:50 <kamatsu> as in: Diese JavaÃ¤hnlichkeitsbehauptung ist ungeheuerlich!
06:31:53 <Cale> agglutinative languages can be fun :)
06:32:07 <Saizan_> agglutinative?
06:32:15 <kamatsu> this is coming out of a discussion that says German is the Java of spoken languages, because of words like JavaÃ¤hnlichkeitsbehauptung
06:32:23 <mercury^> Heh.
06:32:27 <Saizan_> ah, i see
06:33:15 <kamatsu> the difference is the long words in german are rich in meaning
06:33:19 <Alpounet> Cale, you have access to the machine that hosts lambdabot right ? Because she left hours ago and didn't come back.
06:33:25 <jlouis> ksf: Interesting! I'll need to look into it
06:33:27 <kamatsu> where as you can look at tons of java and still not have any meaning at all
06:33:43 <jlouis> I better change the name soon :)
06:34:03 <FliPPeh> Lambdabot is female?
06:34:14 <jlouis> FliPPeh: yup
06:34:17 <FliPPeh> Needs a real name them
06:34:20 <FliPPeh> Like Lassy
06:34:24 <jlouis> @vixen a/s/l ?
06:34:56 <Cale> There you go :)
06:34:58 * jlouis pets lambdabot 
06:35:00 <FliPPeh> @vixen a/s/l ?
06:35:01 <Cale> Thanks for letting me know
06:35:03 <FliPPeh> ;x
06:35:06 <lambdabot> 19/f/California
06:35:10 <jlouis> \o/
06:35:17 <FliPPeh> Just the right age
06:35:25 <jlouis> FliPPeh: shes been 19 since 2005
06:35:25 <FliPPeh> But wrong continent.
06:35:25 <dankna> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24017#a24017 -- haddock is not doing what I want
06:35:30 <dankna> how can I make it be? :)
06:35:33 <FliPPeh> Girls always lie about their age.
06:35:47 <jlouis> FliPPeh: I was just about to say "like all real porn stars"
06:35:57 <FliPPeh> :)
06:36:28 <dankna> the issue seems to be that Haddock puts in an empty type context for the first instance, but not for the second
06:36:28 <Cale> I've noticed lots of annoying Haddock bugs about how it's commenting the parameters to functions lately.
06:36:43 <dankna> but adding an extra comment doesn't fix the matter
06:36:58 <Cale> It also spuriously decides that even though they're present in the source code, it would be okay to leave out parens which are actually necessary.
06:37:00 <dankna> hmmm, so you think it's an actual bug, not a misunderstanding on my part?
06:37:10 <ksf> I especially like how dot isn't based on any of that file-identity thing I've been raving about to switch from one torrent to the other.
06:37:12 <Alpounet> Cale, thanks.
06:37:13 <dankna> this being the first time I've ever actually written anything for it, it would be something of a jackpot if it were a bug
06:37:28 <Cale> I wouldn't be surprised if it's a bug, anyway, without having looked carefully at your situation.
06:37:32 <dankna> gotcha
06:37:39 <dankna> well, maybe I need to read the haddock code, heh
06:37:52 <dankna> meanwhile I guess I release anyway ^^'
06:37:58 <jlouis> ksf: my initial idea was merkle trees
06:38:19 <lowasser> amuller, do you know about interval trees?
06:38:31 <ksf> I think btrfs does support (or they want to make it support) spotting duplicate data and reducing it to whatever they use to represend two cow copies.
06:38:34 <lowasser> they're a data structure designed for the exact query you're trying to answer
06:38:43 <lowasser> though I suppose you might not want to have to reimplement things
06:38:53 <lowasser> and Data.Map will answer your query in O(log n) time I suppose
06:38:55 <jlouis> ksf: but this might beat it. We can play like mad when in Haskell... any implementation is small and easy with decent performance
06:39:38 <jlouis> ksf: yeah, btrfs got dedup support lately
06:39:46 <ksf> ...well I might be willing to mirror hackage on my box, but not the same data duplicated a thousand times.
06:39:47 <jlouis> at least ZFS has it
06:40:05 <jlouis> The newest linux kernel has VM dedup as well
06:40:18 <jlouis> for vitualization, that is madly useful
06:40:45 <jlouis> the MLton compiler got hash-consing (dedup) of its GC heap.. that is also useful at times
06:40:58 <ksf> ....and I won't be switching to btrfs before raid5/a new set of disks.
06:42:05 <ksf> ...so combinatorrent is going to include a fuse server?
06:42:09 <Cale> You can construct efficient interval trees almost trivially using fingertrees,  I'm surprised that there doesn't seem to be a package doing that on Hackage.
06:42:45 <bremner_> @tell ManateeLazyCat  consider notmuchmail.org  for your mail client
06:42:45 <lambdabot> Consider it noted.
06:43:00 <jlouis> ksf: perhaps... getting to a point where that is possible will take some releases :)
06:43:14 <dankna> hmmm
06:43:23 <dankna> the issue seems to be that I have a type variable
06:43:37 <dankna> ie, the function that has a problem is :: ... -> Maybe a
06:43:42 <dankna> where the a comes out of nowhere
06:43:52 <dankna> (which is correct, it comes from a call to unsafeCoerce, heh)
06:43:55 <Jafet> maybe.error!
06:44:02 <dankna> haddock assumes that because I have a variable I must have a context
06:44:06 <dankna> so it puts in an empty context
06:44:16 <dankna> and then it looks for a comment on that context and doesn't find one
06:44:42 <dankna> is there some way I could work around this by rephrasing my type or something?
06:44:57 <dankna> I'd rather work around it because then I don't have to wait for a haddock release to release my code :)
06:45:09 <dankna> well, I suppose I don't have to anyway, but.
06:50:48 * hackagebot feldspar-compiler 0.2.1 - Compiler for the Feldspar language  http://hackage.haskell.org/package/feldspar-compiler-0.2.1 (EmilAxelsson)
06:50:50 * hackagebot direct-plugins 1.1 - Lightweight replacement for Plugins, specific to GHC  http://hackage.haskell.org/package/direct-plugins-1.1 (DanKnapp)
06:50:58 <dankna> huzzah
06:57:34 <Cale> Whenever anyone says 'huzzah', I'm reminded of Balrog from Cave Story <[^_^]>
06:58:57 <dankna> haha, yes
06:59:06 <dankna> that was kinda where I got in the habit
07:00:34 <koeien37> what is the minimal complete definition for Enum ?
07:00:56 <Cale>         -- Minimal complete definition:
07:00:56 <Cale>         --      toEnum, fromEnum
07:01:04 <koeien37> thanks, hoogle didn't give my answer
07:01:39 <Cale> Though, that's kind of wrong, since it only works for types that map injectively into Int
07:01:59 <Cale> It's really super-unfortunate that toEnum and fromEnum use Int rather than Integer
07:02:21 <koeien37> I'm lucky since that is not a problem in my case
07:02:42 <koeien37> my type maps injectively into Int (not surjectively, but that's not a problem)
07:04:52 * hackagebot HTF 0.3 - The Haskell Test Framework  http://hackage.haskell.org/package/HTF-0.3 (StefanWehr)
07:06:22 <pokoko222> of what importance is information theory to computer scientists?
07:06:39 <pokoko222> I mean i see all these entropy crazy formulas, i cant imagine where i would use them
07:06:50 <Botje> pokoko222: to the general CS person? not much. to encryption / compression guys? a lot
07:06:55 <merijn> pokoko222: Depends on whether you're a computer scientist or a programmer with a masters degree
07:07:25 <pokoko222> merijn ah?
07:07:37 <merijn> Most students in the CS department here seem to want to become the latter, not the former
07:07:39 <fasta> Botje, the general CS person should understand those.
07:08:07 <Botje> i agree
07:08:18 <merijn> pokoko222: As Botje said it has relevance in cryptography and error correcting codes
07:08:28 <Botje> i know it as well, but i don't use it from day to day
07:08:34 <fasta> pokoko222, it also has relevance in AI.
07:08:45 <pokoko222> I guess i should learn probability and statistics first, but that we study in second year and i am first now, i wanna learn it on my own but i find it extremely hard
07:08:59 <merijn> I've had it, I mostly forgot it, but I know enough I can dive into it with a head start, which is what counts
07:09:01 <pokoko222> fasta i thought so yeah and AI is what i wanna work one day
07:09:02 <fasta> pokoko222, probably anything worth anything uses some information theory somewhere.
07:09:05 <dankna> take statistics courses from the physics department, not from the math department
07:09:12 <dankna> they are better at applying it to the real world
07:09:22 <fasta> pokoko222, no digital computer without information theory.
07:09:52 <fasta> pokoko222, don't wait too long before it is already solved ;)
07:10:25 <merijn> I disagree, computer rely mostly on computational theory. Information theory lets you do a lot of nifty and interesting stuff, but I think we'd still have computers without them
07:10:26 <pokoko222> well we study statistics and probability second year too, damn, and i wanna learn these stuff now, seems hard
07:10:52 <pokoko222> merijn i think similar so far, i think information theory 90 % is theory bull
07:11:31 <merijn> It's not bull nor is it useless, it's just not the foundation of computers, imo
07:13:28 <Eelis> i dare conjecture that the majority of comp.sci researchers do not information theory in their day to day work
07:13:34 <Eelis> *use
07:13:43 <pokoko222> Eelis my point too yes
07:14:09 <pokoko222> anyways being "i wanna know it all freek" i will start with probability for dummies and go on slow
07:16:29 <jlouis> pokoko222: have you learned a version control system yet?
07:17:47 <pokoko222> jlouis dont need one will never use one
07:17:55 <merijn> ...
07:17:59 <merijn> Seriously?
07:18:08 <merijn> Whoever told you that load of crap?
07:18:16 <pokoko222> dah, all i need is nice word file for my notes
07:18:20 <jlouis> pokoko222: collaboration is key to software
07:18:28 <merijn> Word?
07:18:32 <ksf> I've never had use for one, too
07:18:39 <ksf> doesn't fit into my development style.
07:18:44 <merijn> You have *long* way to go in CS
07:18:49 <merijn> ksf: How so?
07:19:05 <ksf> I don't keep a version history, I scatter different approaches into different files
07:19:27 <jlouis> that is version control :)
07:19:35 <merijn> Except really poor version control
07:19:58 <ksf> it's just like with my appartement.
07:20:12 <ksf> the only time I really tidy up is when I move the furniture.
07:20:39 <merijn> ksf: My development style is pretty much the same, that's not really an argument against version control
07:20:44 <pokoko222> version control and all that extreme programming, mind mapping, lol... dudes, organization is simple, i can make a folder and i know how to type in Word, aleluja...
07:21:03 <ksf> ...at that time, everything is planned and accounted for and works in two possible ways and all the intermediate stages.
07:21:40 <merijn> ksf: Yeah, but who says version need to work, I just commit buggy code all the time :)
07:21:42 <ksf> It's definitely useful if you're not the only one working on some piece of code
07:21:52 <ksf> see I wouldn't do that.
07:21:56 <HugoDaniel> hi
07:22:05 <ksf> I never, ever break my code.
07:22:30 <merijn> ksf: Yeah, I used to think that was bad too, and then I spend half a week rewriting a tree traversal of my AST. Ending up with a broken rewrite and no way to get my old code back
07:23:02 <merijn> ksf: Since then I commit whenever I think a part works, rather then whenever there's no parts that don't work
07:23:14 <jlouis> It is like playing a computer game and never ever saving... it is for the hardcore people
07:23:46 <pokoko222> merijn have u ever heard of "Save as" it is a cool thing in any text editor
07:23:50 <ksf> I save my code every time I typecheck, and that's every line or the other.
07:24:29 <merijn> pokoko222: Yeah, and then you wind up with foo.hs, foo1.hs, foo.hs.old, foo2-old.hs and no clue which file contains what code
07:24:39 <ksf> nope
07:24:50 <dancor> version control is extremely useful even just as a diary
07:24:55 <ksf> there's a max of two versions, or you're doing something wrong.
07:25:14 <ksf> dancor, then give me a bleeding file system that tracks what I do
07:25:22 <dancor> bleeding?
07:25:25 <dankna> what dancor said.  even as an individual developer, I commit at a minimum every half-hour or so, otherwise I would be helpless.
07:25:31 <pokoko222> ksf correct i end up with max two versions
07:25:35 <ksf> I don't want to write _bleeding_ commit messages
07:25:38 <merijn> ksf: When writing new code I often refactor it >3 times a day
07:25:41 <merijn> ksf: Then don't
07:25:46 <jlouis> pokoko222: if you use "Save As", you could benefit from version control. It would also help you tremendously, should you ever want to contribute back to projects
07:25:57 <merijn> My commit messages are 2-5 words tops on average
07:26:01 <pokoko222> merijn so u write like 10 000 versions and u r like "this might work some day and this another day" ? i mean, it either works and i save or it does not
07:26:02 <dancor> i commit with 'cp' for checkpoint when i don't feel like writing a commit message
07:26:09 <dankna> my commit messages aren't as good as they should be
07:26:26 <opqdonut> sure, with some rigor a single developer can work on a small enough project with out version control
07:26:49 <opqdonut> but adding version control never hurts, and it is extremely useful for big projects / with multiple developers
07:26:55 <dankna> it blows the mind that they teach how to indent braces in undergrad courses, but not how to use version control
07:27:01 <merijn> pokoko222: No, I don't write 10000 versions, I write one. Then rewrite it, then rewrite it again, then redesign the entire thing, rewrite the redesign and somewhere in between something stops working and I don't know why
07:27:06 <opqdonut> and you never know when a project will jump the gap from one case to the other
07:27:10 <dankna> (I don't consider indentation styles particularly important, as long as you have some consistent one)
07:27:30 <merijn> And version control lets me check what EXACTLY I changed and thus why something worked in the old one but doesn't in the new one
07:27:33 <pokoko222> merijn that is called "i have no idea what i am doing"
07:27:43 <ksf> there's always two states in my approach: the current, working one and the one that I'm working towards.
07:27:58 <ksf> once the towards state is complete, I switch buffers.
07:28:00 <dankna> he's just trolling at this point, I don't think he really deserves further response ^^'
07:28:21 <Saizan_> nick Saizan
07:28:31 * jlouis hands Saizan_ a /
07:28:38 <ksf> don't get me wrong, I tried using version control.
07:28:42 <Saizan_> thanks
07:28:46 <ksf> I even _did_ it.
07:28:46 <jlouis> try again now
07:29:02 <ksf> the thing is, I never, ever looked again at the history or made any use out of it.
07:29:07 <opqdonut> before the modern vcss, i used rcs on private projects :)
07:29:33 <jlouis> ksf: the point in time I am happy everything is under git is when a new regression pops up after a month and I don't which of the 100 commits introduced it
07:29:42 <ksf> it's vitally important that I can have two code paths that I can switch literally on the fly.
07:29:45 <opqdonut> I use lots of branches with the big projects I work with. it'd be hard to develop without branching
07:29:46 <jlouis> bisection easily finds the problem
07:29:58 <merijn> ksf: So create 2 repos?
07:30:13 <opqdonut> nah, 2 branches and a proper version control system
07:30:24 <ksf> it does'nt work like that.
07:30:29 <opqdonut> for example in git switching branches is easy and cheap
07:30:43 <ksf> I'm morphing my code. vcs wants it to be discrete.
07:30:44 <merijn> opqdonut: In Mercurial there's not much difference between maintaining multiple repo's and multiple branches
07:30:55 <opqdonut> ksf: how?
07:31:02 <jlouis> anyway, it doesn't matter that much. pokoko222 will never make any worthwhile contribution to any Haskell project
07:31:47 <merijn> jlouis: He might change, or he'll drop out like most CS students using Word that I met so far during my study :)
07:32:09 <ksf> opqdonut, by starting at the top and changing stuff until you can choose between two paths where you want to make the real change.
07:32:32 <opqdonut> I don't understand
07:32:36 <ksf> ...which has the additional benefit of modularizing my code, which it usually just isn't in the beginning.
07:33:02 <ksf> ...like cutting a cake until the knife hits the spot where you want to pick the cherry.
07:33:03 <jlouis> merijn: I am doubting that. He has a score of competent Haskell programmers willing to teach him. Yet, he doesn't care
07:33:04 <opqdonut> do you mean changing the code so that the actual modification is local?
07:33:19 <luite> hm, I'm pretty sure that a many CS researchers do not use version control at all, for their code
07:33:25 <opqdonut> why not commit the refactor as one commit and the change as another
07:33:28 <luite> so there might be hope for him :)
07:33:49 <ksf> opqdonut, I don't need to, because all those changes are strictly semantics-preserving.
07:33:55 <merijn> luite: Or there's no hope for many CS researchers if you're a pessimist :)
07:34:00 <jlouis> luite: true, but also they don't collaborate with other people :)
07:34:06 <opqdonut> sure, you never *need* to commit
07:34:11 <opqdonut> until you realise you should've
07:34:25 <ksf> I don't change my mental model of how the code works, I just change the implementation.
07:34:25 <jlouis> anyway, sorry for starting all the trolling
07:34:28 <opqdonut> but as I said, it is certainly possible to work without version control
07:34:38 <opqdonut> and if that suits you, go ahead
07:34:52 <pookleblinky> I believe you have been trolled.
07:35:00 <fasta> luite, I think a majority does use version control.
07:35:06 <luite> jlouis: yes that's true... at least not on their code
07:35:09 <fasta> I also think version control is overrated ;)
07:35:11 <ksf> why should I keep old code? there's been a valid reason that I deleted it.
07:35:28 <pookleblinky> ksf, that's a terrible idea.
07:35:29 <fasta> I also think version control tools generally suck.
07:35:50 <fasta> Git is the only tool which I know that I can qualify as not being slow.
07:35:52 <pookleblinky> Your old code is a clue as to the logic behind your current code.
07:35:57 <opqdonut> git is great
07:36:07 <ksf> if it was, then there'd be no new code.
07:36:10 <danderson> fasta: mercurial is speed-equivalent these days
07:36:18 <merijn> fasta: Which tools have you used then? Sure CVS and SVN are slow as hell, but they're ancient by now
07:36:19 <fasta> I think it requires a certain mind to create a tool which doesn't suck.
07:36:23 <danderson> in a larger sense, they're pretty much equivalent systems with different UIs at this point :)
07:36:40 <danderson> (and hg's UI is less insane)
07:36:56 <opqdonut> there's nothing wrong with git's ui
07:37:02 <pookleblinky> ksf, I think it is vital, when looking over any code older than a week or so, to be able to see how it got the way it is.
07:37:04 <Zao> What UI?
07:37:05 <opqdonut> except, perhaps, the learning curve
07:37:12 <jlouis> I use git as a barrier to entry in a certain sense.
07:37:24 <opqdonut> but it's a tool that you end up using a lot, so a learning curve is ok
07:37:24 <fasta> danderson, I don't know all systems in the world, but the time I did use hg, it didn't annoy me so it is probably good. I got the impression hg is more engineered than Git.
07:37:27 <danderson> opqdonut: I still cannot perform a transplant rebase without reading the man page to figure out the argument order.
07:37:30 <danderson> that is a UI failure.
07:37:36 <luite> fasta: I guess it depends on the type of projects they're working on... software engineering projects tend to be larger, but many people I know how work in algorithmics or machine learning tend to make smaller programs, often not version controlled
07:37:42 <ksf> it's the way it is because it needs to be the way it is to do the thing its haddock comment says it does.
07:37:44 <opqdonut> danderson: well how does it look in hg then?
07:37:56 <ksf> ...and because the things it uses are the way they are.
07:38:05 <pookleblinky> luite, I've got a friend in vlsi. His code is terrible.
07:38:14 <pookleblinky> He comments out old code, etc.
07:38:16 <danderson> opqdonut: move to the bit you want to rebase, `hg rebase -d target`, done
07:38:20 <fasta> luite, they taught us to use version control during some project and afterwards it was pretty much a given to always use it, even when working in teams of two.
07:38:42 <opqdonut> danderson: in git: move to the bit you want to rebase, git rebase target
07:38:48 <fasta> Commenting old code can be useful.
07:38:52 <pookleblinky> It's a mess. Apparently they still haven't taught vcs even in senior year of getting a BS.
07:38:59 <quicksilver> I generally use version control even in 1-person projects.
07:38:59 <fasta> Unless you have good tools, which do not exist.
07:39:44 <merijn> pookleblinky: Well, I'm forced to take a course in Software Configuration Management starting in 2 weeks to meet the required courses for my master >.>
07:39:45 <fasta> It might also be that an older implementation does things in a completely different way and you might have introduced a bug.
07:39:50 <danderson> opqdonut: okay, now doing what you'd do with git rebase --onto : hg rebase --detach -d target
07:39:52 <quicksilver> I have gone down the path of a mad day's changes and not being able to get back to where it was before.
07:40:00 <fasta> Then a few revisions later you can remove the old code completely.
07:40:01 <quicksilver> it's pretty depressing.
07:40:10 <pookleblinky> merijn, in EE it is apparently different.
07:40:17 <opqdonut> quicksilver: same here
07:40:25 <danderson> opqdonut: but, as I said, the tools are just about completely functionally equivalent today. If you prefer the git UI, by all means, feel free
07:40:34 <danderson> I'll just use mercurial's hg-git plugin to clone your repo :)
07:40:38 <quicksilver> bzr++ # (by the way)
07:40:52 <ksf> quicksilver, that's because you break your code too much for too long.
07:41:02 <quicksilver> ksf: ultimately it's because I did something stupid, yes.
07:41:09 <quicksilver> ksf: the details of the stupid don't matter, and they can vary.
07:41:11 <pookleblinky> Odd that no one is using DARCS, it's not just me.
07:41:15 <ToRA> monotone++
07:41:16 <merijn> ksf: You never make mistakes, then?
07:41:33 <ksf> I do thousands a day.
07:41:36 <opqdonut> danderson: it's not about preferring the UI as such, git just has more users
07:41:39 <ksf> but they don't stick around for long.
07:41:46 <danderson> opqdonut: [citation needed], kthx.
07:41:57 <pookleblinky> ksf, how often do you have to read other people's code?
07:41:58 <opqdonut> danderson: i haven't used mercurial on any large projects, but git has never let me down. I can _always_ perform the thing I want
07:42:07 <danderson> I've seen that claim thrown around casually everywhere, and have *never* seen one inkling of data to back it up.
07:42:17 <ksf> not often anymore, and I'm quite glad I don't have to.
07:42:22 <opqdonut> danderson: ok, I take it back. The projects I work with use git.
07:42:31 <ksf> I usually ended up rewriting it to make any sense of the mess.
07:42:31 <danderson> opqdonut: that is a good reason to use git :)
07:42:41 <merijn> danderson: The huge growth of github and their free repos is probably the cause of that rumor.
07:42:55 <opqdonut> there should be one vcs that everybody uses
07:43:03 <opqdonut> and IMO it should be git :)
07:43:04 <merijn> On the other hand Google code supports hg and there's plenty of free open source hg hosting sites
07:43:06 <danderson> merijn: huge growth, low absolute numbers. By that metric, Subversion is the best version control system ever because of Sourceforge.
07:43:17 <opqdonut> but I don't have time for arguing about version control
07:43:17 <pookleblinky> merijn, plus github's acquisition of some of the biggie repos.
07:43:22 <opqdonut> got actual code to do ->
07:43:27 <ksf> most people layer too many non-local connections over another.
07:43:42 <merijn> Same here, time to stop procrastinating and go back to my compiler
07:43:43 <ksf> ...mental spaghetti.
07:43:47 <danderson> well, given that we can't have ponies and force a system on everyone, hg has the advantage of being able to work both with hg and git repos :)
07:44:01 <merijn> danderson: And outdated svn repo's!
07:44:23 <danderson> merijn: hgsubversion is less solid than hg-git, so I didn't mention it
07:44:32 <merijn> I can dream
07:44:35 <danderson> it works well if you haven't done anything too crazy with your svn repository
07:44:40 <danderson> very well even.
07:44:41 <quicksilver> ksf: the canonical mistake which involves breaking code is a large refactor
07:44:47 <osfameron> heh
07:44:47 <quicksilver> ksf: Ah, we'll do  it *this* way instead, change this API here
07:44:54 <quicksilver> ksf: and then 5 files later, you realise it was a bad idea.
07:44:59 <osfameron> refactor without a test suite...
07:45:06 <quicksilver> ksf: anecdotally this hardly ever happens to me with haskell.
07:45:07 <danderson> but people do crazy things to their svn repos. Less so than they used to with cvs, but they still do
07:45:10 <danderson> and this confuses hgsvn
07:45:12 <quicksilver> osfameron: that goes without saying.
07:45:22 <quicksilver> osfameron: but the point is, it wouldn't matter even if I had had one
07:45:36 <quicksilver> osfameron: because the realisation that this was a stupid idea comes half-way through, when you've already changed 5 files
07:45:40 <quicksilver> osfameron: and you decide to backtrack.
07:45:40 <ksf> ...you have to have the replacement in place before you switch over.
07:45:41 <danderson> anyway, I was in the middle of parsing BGP path attributes, I think...
07:45:44 <osfameron> ah
07:45:46 <quicksilver> that's when you get in a mess.
07:45:46 <pookleblinky> They are probably the same people who don't know how to ignore whitespace in diffs
07:45:52 <ksf> in the meantime, your code has to be able to choose between both.
07:46:03 <osfameron> oh, how do you ignore whitespace in diffs?
07:46:11 <dankna> -w isn't it?
07:46:17 <quicksilver> ksf: OK, I understand. That's like version control but only the immediate last version.
07:46:30 <quicksilver> ksf: that would definitely catch most of the mistakes I'm describing, yes.
07:46:42 <dankna> basically, ksf gets away with informal version control because ksf has the experience to make it work
07:46:45 <dankna> end of discussion :D
07:47:05 <merijn> dankna: Or lacks the recklessness to make it stop working :p
07:47:06 <pookleblinky> osfameron, whitespace-ignore is available in many vcs outputs
07:47:09 <dankna> haha
07:47:10 <dankna> fair
07:47:17 <ksf> ...I get away with it because I can't stand non-working code for five minutes.
07:47:58 <merijn> ksf: What if your product is to large to create working changes in 5 minutes?
07:48:02 <alexsuraci> is there a way to check for an empty string in hstringtemplate?
07:48:05 <merijn> s/product/project
07:48:35 <ksf> then the pre-change version still works while I keep fledging out the replacement.
07:48:58 <ksf> first the amount of code expands, then it collapses again.
07:49:04 <pookleblinky> ksf, you do erlang as well, don't you?
07:49:11 <ksf> the good days are those where I can delete more lines than I write.
07:49:13 <ksf> nope
07:49:28 <ksf> that might be kmc, people always confuse us.
07:49:52 <pookleblinky> ksf, no, your workflow sounds well suited to erlang's hotswappable module system.
07:53:07 <ksf> yeah hotswap would be a cool thing to have
07:59:34 <opqdonut> (ACt
07:59:37 <opqdonut> oops
08:00:57 <pookleblinky> ksf, you could use a terribly convoluted monad over ffi to send functionality to an erlang process
08:01:12 <pookleblinky> And thus have poor man's hotswapping
08:01:14 <ksf> haskell can work as an erlang node
08:01:31 <pookleblinky> Indeed, but you'd want hotswapping from within haskell
08:02:34 <ksf> ...loading .so's at runtime which contain the code for one process each.
08:04:39 <pookleblinky> http://www.haskell.org/communities/05-2008/html/report.html hs-plugins should allow hotswapping
08:06:31 <Cale> There's also newer things for that which tie in with the GHC API a little more directly
08:06:47 <pookleblinky> http://www.cse.unsw.edu.au/~dons/papers/SC05.html
08:07:01 <Cale> Like hint
08:07:22 <ksf> mhhh I think I'd need to change my process model to accept startup configuration on a chan and I'd be done
08:07:28 <Cale> http://hackage.haskell.org/package/hint
08:08:45 <dantheman_> Hey all, I have a question about using the ffi...any help appreciated as I'm a bit confused.
08:08:53 <ksf> the question is whether output chans would need to get regenerated on reconfiguration or not
08:09:06 <dantheman_> Basically I want to pass a chan (from control.concurrent.chan)
08:09:07 <ksf> right now, I can't think of a situation where it'd be necessary.
08:09:14 <dantheman_> through the ffi
08:09:44 <dantheman_> and then have c code store it, and use it as part of a callback function
08:09:52 <dantheman_> to send data back to my haskell program.
08:10:14 <ksf> you should store the chan on the haskell side and send a Unique to C
08:10:20 <dantheman_> However, I'm not sure how to create a Ptr (Chan a) in my haskell program
08:11:24 <Cale> Use a StablePtr, I think
08:11:34 <dantheman_> Ah, a stablePtr... ok
08:11:36 <dankna> dantheman: I've done that
08:11:37 <dankna> yes
08:11:40 <dankna> you need a StablePtr
08:11:45 <dankna> there's a castStablePtrToPtr or something
08:11:58 <dankna> note that the entire point of a StablePtr is that while it exists, your object won't be garbage-collected
08:12:02 <dantheman_> Great... I wasn't sure whether I needed to do some alloc stuff
08:12:08 <dankna> so you have to think carefully about when to dealloc it
08:12:34 <dantheman_> Ok, thats fine, thanks.
08:12:39 <Cale> Well, StablePtrs are Storable anyway, so you shouldn't necessarily have to cast it
08:12:45 <dankna> interesting point
08:13:24 <dantheman_> ya I think theres a newStablePtr function anyway.
08:14:01 <dantheman_> So I can just change the signatures of my ffi functions to take stablePtrs instead of Ptrs
08:14:16 <amuller> lowasser: I did not know about interval trees! And I was looking for something like them for another type of query I need to do.
08:14:53 <Cale> You should be able to newStablePtr, and then pass the StablePtr you get to a C function which accepts an *HsStablePtr argument, and then when that C call passes it back to your Haskell callback, you can deRefStablePtr
08:14:54 <dantheman_> dankna.. when should I choose to use a ptr instead of a stablePtr then? It seems to me to always be a bit risky to use a ptr no?
08:15:37 <dankna> not so much risky as requires care
08:15:53 <Cale> You should almost always use Ptr. StablePtr is for when you want to be able to pass Haskell values around opaquely on the C side without actually using them for anything
08:16:03 <mxc> hi
08:16:13 <dankna> if there's any chance that Haskell code will be invoked (either in this thread or another one), the Ptr will be potentially invalidated by the GC
08:16:18 <Cale> (with the intention that they'll eventually get passed back to some Haskell code where they can be used)
08:16:38 <mxc> i feel kinda dumb asking this, but I can't find it.  in ghc 6.12, Data.Array.Diff has been moved to its own package, but what package?
08:16:42 <Cale> Ptr values on the other hand are pointers to C-observable values.
08:16:48 <dankna> Ptrs in the Haskell heap are updated by the garbage collector when it moves objects, but the GC ignores the C heap entirely
08:16:57 <dankna> @hoogle diff
08:16:57 <lambdabot> module Data.Array.Diff
08:16:57 <lambdabot> Data.Time.Clock.TAI diffAbsoluteTime :: AbsoluteTime -> AbsoluteTime -> DiffTime
08:16:57 <lambdabot> Data.Array.Diff type DiffArray = IOToDiffArray IOArray
08:17:00 <dankna> hm
08:17:01 <dankna> dunno
08:17:02 <dantheman_> Ah I see, so c can look into ptrs, but stable ptrs could contain anything?
08:17:07 <dankna> correct
08:17:24 <mxc> @dankna - thanks, but I know the module name, just not sure in which package to find it
08:17:25 <lambdabot> Unknown command, try @list
08:17:32 <mxc> dankna - thanks, but I know the module name, just not sure in which package to find it
08:17:33 <dankna> mxc yeah, I realized that, oh well
08:17:37 <dantheman_> Great, thanks danKna and cale.
08:18:36 <Cale> mxc: I'm as of yet unfamiliar with 6.12. (Seems to have enough problems to keep me waiting for the next point release.) It used to be in the array package. It's not anymore?
08:19:12 <Cale> Hmm, Data.Array.Diff is missing from the hierarchical libraries documentation for GHC.
08:19:16 <mxc> its not.  its only in array up to 0.2.0.0
08:19:20 <Cale> So it doesn't come with GHC anyway.
08:19:31 <theorbtwo> Hm.  That sounds like a very useful thing for when you are doing something like making a Haskell binding for a C library that does events with userdata, or similar.
08:19:33 <mxc> http://www.haskell.org/ghc/docs/6.12.1/html/users_guide/release-6-12-1.html
08:19:41 <theorbtwo> Not a hardly ever use this thing.
08:19:56 <mxc> cale - the reason that i'm on 6.12 is that 6.10 has been a nightmare for me on windows (runs like a charm on osx)
08:20:09 <HugoDaniel> so, im using ghc 6.10.x and parsec ain't reading my utf8 values properly
08:20:16 <mxc> 6.12 seems to have solved all the linker errors and general brainfcks  i was getting on windows
08:20:54 <BONUS> i haven't had any problems with 6.10 on windows, Hmmm
08:21:08 <Cale> theorbtwo: That's precisely what it's for.
08:21:38 <theorbtwo> I guess I just overestimate how common those are.
08:21:38 <Cale> theorbtwo: When you're writing callbacks in Haskell and need to pass Haskell values to them.
08:22:11 <Cale> It's not that you'd almost never use those, so much as pointers for other purposes are much more common.
08:22:13 <theorbtwo> Hm.  I'd just pass around the callback itself and let closing handle the rest of the parameters, but yeah, close enough.
08:23:56 <Cale> I wonder why they decided to remove DiffArrays from the array package.
08:24:11 <lowasser> What is a good place/method to put up Haddock documentation for a proposed patch?
08:24:28 <Cale> I know their performance was less than stellar in general, but there were cases where they did better than various alternatives.
08:24:42 <lowasser> Cale: A thought occurred to me about that
08:25:22 <lowasser> though I didn't actually know they'd been removed!
08:25:31 <Saizan> HugoDaniel: are you using String as input to parsec?
08:25:32 <lowasser> I think it's possible that DiffArray performance could have been improved with an alternative implementation that perhaps used IntMaps instead of a sort of linked list version of the history
08:25:55 <lowasser> except that since containers depends on arrays, making that change would require moving DiffArrays out of the array package
08:26:22 <Cale> lowasser: Yeah, there are fancier things you can do with the history trees to try to optimise for the most frequently accessed versions of the array.
08:26:27 <lowasser> I'm not sure if that's actually feasible, but I was actually discussing that possibility with someone yesterday and thinking that that change would be necessary
08:26:59 <harrison> i have a function with type (String -> String) -> IO (). (it's similar to interact). anyways, i now want to pass it a (String -> IO String) or perhaps an arrow of some kind, so the string function can do io of its own. is there a simple way of cramming one of those in there?
08:27:02 <Cale> and yet, for some reason 6.12 still has Data.HashTable
08:27:10 <lowasser> heh, it's true
08:27:21 <quicksilver> Cale: it's used in some obscure part of GHC isn't it?
08:27:24 <Cale> If anything was going to disappear, I would have hoped for it to be that.
08:27:44 <mxc> cale - for things that wouldn't benefit from stream fusion, whats a better choice than diffarrays?
08:27:51 <Cale> quicksilver: Yeah, I think that must be it.
08:27:51 <mxc> if i want arrays with pure semantics
08:28:08 <Cale> mxc: Data.Array
08:28:16 <Cale> Or Data.UArray
08:28:26 <mxc> isn't that O(n) for updates?
08:28:29 <Cale> yep
08:28:36 <lowasser> yes, but DiffArray can get really bad in certain cases
08:28:39 <HugoDaniel> Saizan: yes String
08:28:41 <mxc> such as?
08:28:50 <lowasser> (essentially, when you use the array really persistently)
08:29:06 <Cale> But note that boxed arrays often don't need as many updates as you'd expect from imperative programming.
08:29:26 <Cale> Because you can set all the expressions to their final values, even if they recursively depend on one another.
08:29:37 <lowasser> That's also true.  But in general, DiffArray is fine...until you need persistence, and then it can degenerate pretty badly
08:29:38 <mxc> so, say have an array of 1k ints that are constantly being "updated" but nothing should really be touching older instances of the array
08:29:40 <HugoDaniel> Saizan: im doing a normal readFile to get that string to parsec, perhaps i should change that into the readFile from UTF8 ?
08:29:48 <Saizan> HugoDaniel: then you should make sure that String contains unicode codepoints, rather than utf8 octects
08:29:51 <lowasser> mxc: in that case, DiffArray is fine
08:30:01 <Cale> Well, "fine"
08:30:02 <mxc> essentially, using an array to store real time updates coming in over a wire
08:30:11 <Cale> DiffArray has a *large* overhead.
08:30:16 <Saizan> HugoDaniel: i think so
08:30:20 <Cale> Large enough that unboxed arrays are often faster.
08:30:31 <lowasser> or you should suck it up and use MArrays =P
08:30:33 <HugoDaniel> ok, im going to try it, and then check for those codepoints if it outputs strange characters
08:30:36 <mxc> boo
08:30:43 <mxc> i do use UArrays where possible
08:30:44 <Cale> (even though updates are O(n), sometimes the constants are such that DiffArray is slower!)
08:30:44 <HugoDaniel> thanks
08:31:03 <mxc> in that case, is an IntMap faster?
08:31:11 <Cale> IntMap may very well be faster
08:31:23 <quicksilver> or Data.Seq
08:31:24 <Cale> It has logarithmic access, which might as well be constant.
08:31:35 <quicksilver> Data.Seq is biased towards near-end access
08:31:41 <quicksilver> Data.IntMap is uniform
08:31:55 <quicksilver> near-either-end, I mean
08:31:59 <lowasser> true, but Seq also provides a number of useful methods like concatenation, if that might be useful
08:32:05 <Cale> (after all, array access is only constant time because of ignoring a small log factor in the first place anyway)
08:32:20 <lowasser> in general, I prefer IntMaps, but Seqs have plenty of uses
08:32:32 <quicksilver> but I don't know how the constant overhead compares for Seq vs IntMap
08:32:35 <lowasser> also, things like obtaining slices of sequences == much easier
08:33:11 <lowasser> quicksilver: having hacked around with both, I don't think Seq should be that much slower
08:33:19 <lowasser> hrrrm
08:33:22 <xarch> hey
08:33:23 <lowasser> no, take that back
08:33:24 <Cale> One thing to be careful about with Seq is that even though cons and splitting an element from the end is O(1), the performance when you use them this way is not so great.
08:33:41 <Cale> Lists will obviously win if you only use Data.Seq like a list.
08:33:55 <lowasser> Data.Seq as a queue, though, is pretty high-performance, I think
08:33:59 <Cale> yeah
08:34:02 <HugoDaniel> Saizan: it worked :) thanks
08:34:13 <Saizan> HugoDaniel: np :)
08:34:16 <lowasser> even compared with specialized queue implementations possibly?
08:34:25 <Cale> as far as queue implementations go, it's rather good
08:34:32 <lowasser> hehehe, I'm actually co-author of Data.Sequence now <_< I should know this
08:34:45 <Cale> Oh really? Interesting :)
08:35:06 <lowasser> I wanted to add a lot of methods that Data.List offered but that Data.Sequence didn't have
08:35:16 <Cale> Something that I wish is that GHC become smart enough to optimise datastructures whose constructors have been hidden by a module boundary.
08:35:32 <lowasser> Cale: ...I thought it does already
08:35:43 <Cale> So that we could use Data.FingerTree to implement Data.Sequence with no concerns.
08:35:52 <lowasser> like, if I ghc-core something that makes extensive use of Data.Sequence
08:36:00 <lowasser> and do things like viewl
08:36:11 <lowasser> I'm pretty sure it actually inlines a case over the original Data.Sequence constructors
08:36:33 <Cale> I mean like specialising the actual definition of the structure itself
08:36:40 <tsou> Is there anything special about custom-defined operators that begin with a ":"?
08:36:54 <quicksilver> tsou: yes. They are constructors.
08:36:55 <lowasser> I mean, for things like that, you use {-# UNPACK #-} for single-constructor data types
08:37:10 <lowasser> and for other data types, GHC doesn't know how to do that even inside the same module I thought?
08:37:18 <Saizan> lowasser: that doesn't apply to using fingertree to implement sequence
08:37:23 <tsou> quicksilver: thanks
08:37:24 <lowasser> certainly not in Core
08:37:41 <lowasser> Saizan: explain?  not entirely familiar with fingertree myself
08:37:57 <tsou> quicksilver: where can I find all the restrictions that apply to custom-operators?  Or is it just that one?
08:38:05 <Cale> lowasser: You ought to read the FingerTree paper if you're working on Data.Sequence, since that's where the structure is specialised from.
08:38:12 <lowasser> I mean, I've read the paper
08:38:31 <Cale> lowasser: Data.Sequence is the same thing as Data.FingerTree, but with the specific monoid plugged in and specialised by hand.
08:38:47 <lowasser> and you're suggesting that that specialization should happen automatically?
08:38:49 <Saizan> lowasser: if you start with a general structure S :: * -> * and then you say T = S Int, even if you hide this definition inside a module, it won't specialize S for Int, e.g. unpacking
08:38:53 <Cale> It would be nice if we could rely on GHC to do that specialisation for us, yes.
08:39:05 <lowasser> aha
08:39:19 <ksf> supero!
08:39:39 <lowasser> see, I've thought some about that problem, and I'm not at all sure it's really feasible?
08:39:48 <Cale> I think it must be.
08:39:56 <Saizan> Cale: a problem is that it also has to generate new code for the functions defined on the general structure to work on the specialized one
08:39:56 <quicksilver> tsou: in the online report
08:40:00 <lowasser> I mean, you would probably have something like {-# SPECIALIZE (S Int) #-}
08:40:05 <lowasser> Saizan: exactly
08:40:08 <Cale> Though you need to have the entire source of the polymorphic thing that you're producing a specialised version of
08:40:08 <Saizan> you get the same result as C++ templates
08:40:16 <quicksilver> tsou: the restrictions are basically the list of symbols you are allowed to use; and then the forbidden operators.
08:40:21 <quicksilver> tsou: --, ->, etc
08:40:31 <lowasser> so after you do a {-# SPECIALIZE (S Int) #-}
08:40:46 <lowasser> then you'd need to be able to take functions defined *afterwards* on a general S a
08:40:48 <tsou> quicksilver: thanks again :)
08:40:50 <quicksilver> Cale: whole program compilation is the correct direction to be going, I'm sure of it.
08:40:50 <Cale> It should also only do the specialisation when it's not possible to see the original structure anymore.
08:40:53 <lowasser> and specialize them for S Int
08:41:07 <quicksilver> Cale: with, perhaps, clever heuristics to avoid the pain when there is no gain.
08:41:09 <lowasser> I mean, "not possible to see the original structure" is a really difficult thing to make rigorous
08:41:22 <quicksilver> Cale: alternatively, just-in-time compilation at link time
08:41:29 <quicksilver> Cale: (entire library source made available at link time)
08:41:43 <Cale> lowasser: Well, there's a crude approximation which would be fine: when the data constructors of the type you're specialising are not exported from the module.
08:41:53 <benmachine> Saizan: so, about five hours ago you were looking for my thing
08:41:55 <Alpounet> FAD seems to be very interesting
08:42:15 <lowasser> I mean, that's kind of awkwardly limited
08:42:17 <lowasser> other, bigger problem:
08:42:18 <Saizan> benmachine: heh, i still am :)
08:42:28 <Cale> It would be fine in the case of Data.Sequence
08:42:32 <benmachine> excuse me one moment while I make sure it's in a coherent state
08:42:41 <benmachine> do you want the CGI script or the code?
08:42:44 <Cale> You would still have Data.Sequence, it's just that the implementation would be the obvious one.
08:42:44 <lowasser> {-# SPECIALIZE (S Maybe) #-} could lead to a huge blowup of code size
08:42:44 <mxc> i never understood why, given that modules are essentially nothing more than segregated namespaces, the compiler can't just fully qualify every exposed identifier in each module, concatenate all the code together and compile a large project as a single module, after checking that no non-exported identifiers leak out
08:42:57 <lowasser> unless you *also* restrict it to single-constructor data types
08:43:03 <mxc> wouldn't work for libraries but for final executables it should be able to right?
08:43:15 <Saizan> benmachine: well i was really looking for the website
08:43:22 <benmachine> ah
08:43:22 <lowasser> in which case, that's a really awkwardly limited specialization, no?
08:43:26 <Cale> lowasser: I'd be okay with that too.
08:43:33 <benmachine> bah, my webhost is screwing with me
08:43:43 <lowasser> I'm just not sure it's worth the effort as opposed to, say
08:43:50 <jmcarthur> mxc: compilation times (not that i think that is a strong enough argument to not have the option, but i'm pretty sure that's why people don't really pursue that route)
08:43:52 <Cale> lowasser: The idea being that you just have a way to wrap some composite of datatypes up, and have GHC be smart enough to specialise the structure.
08:44:26 <mxc> jmcarthur - sure, for development.  but for a release with -02 turned on anywya, compilation time isn't really critical is it?
08:44:32 <lowasser> letting the linker (not sure that's the right term for what I mean) do the optimization outside of Haskell?
08:44:41 <Cale> You could restrict it newtypes without exported constructors even.
08:44:48 <jmcarthur> mxc: agreed
08:45:48 <lowasser> Cale: it just seems like it's such a limited capability that it's not significantly superior to copy/pasting from the original code and doing the requisite modifications
08:46:09 <benmachine> Saizan: my webhost moved and is giving me 500 errors now
08:46:17 <benmachine> this is what you get with free stuff I suppose >_>
08:46:28 <gwern> mxc: I remember reading about one haskell program which took a project, conctenated the modules into one module, and compiled it
08:46:32 <Saizan> heh, ok :)
08:46:36 <benmachine> oh arse, it doesn't have libgmp installed
08:46:38 <Cale> lowasser: really?
08:46:50 <gwern> mxc: the author noted that ghc obviously doesn't do a number of cross-module optimizations, since the concatenated version was noticeably faster
08:46:58 <Saizan> benmachine: btw, can it evaluate expressions where some functions are undefined?
08:47:00 <Cale> lowasser: The transformation I'm thinking of is sufficiently complicated to do by hand that it would be much nicer to have the compiler do it.
08:47:21 <lowasser> here's another loophole to plug:
08:47:22 <mxc> interesting
08:47:25 <benmachine> Saizan: well, if a function is undefined it won't evaluate the arguments to it
08:47:35 <benmachine> because the function might be lazy, in which case that's not necessary
08:47:53 <lowasser> importing from the Prelude, you might think that Int is sufficiently "hidden" that it's okay to specialize it
08:47:58 <gwern> mxc: unfortunately it was under a non-OSI approved license and I never got a reply asking for relicensing, so it has disappeared in the mists of time
08:48:04 <benmachine> but if you have, say, (\x -> x "string") reverse, then it will evaluate as far as reverse "string"
08:48:12 <lowasser> but if that actually originates somewhere else, somewhere that does export those constructors, then you're hosed
08:48:16 <benmachine> before stopping because it doesn't know about reverse
08:48:17 <Cale> lowasser: There's nothing to specialise in the case of Int
08:48:21 <Saizan> benmachine: ah, true
08:48:26 <lowasser> it was an example
08:48:34 <Cale> lowasser: Int isn't an application of a parametric type to a type parameter.
08:48:38 <lowasser> we might have a similar situation with something that actually has a type argument
08:49:04 <lowasser> where one module exports it without access to the constructors and one module exports it with the constructors
08:49:06 <Cale> Obviously it should only apply to modules which define the datatype itself.
08:49:08 <benmachine> anyway if you have a way of hosting cgi then http://github.com/benmachine/stepeval compile it yourself :P
08:49:13 <lowasser> more restrictions!
08:49:20 <Cale> The datatype can only be defined in one place.
08:49:29 <benmachine> it acts as a CGI script if QUERY_STRING is in the environment, or a command line tool otherwise
08:49:32 <Cale> It's not a real restriction though.
08:49:37 <lowasser> I don't necessarily know that, though, I think
08:49:41 <Cale> Because you can always do this.
08:49:49 <Saizan> lowasser: when you say "newtype Seq a = Seq (FingerTree Int a)" you know that you can do the transformation for all the occurrences of FingerTree that make up a Seq
08:49:50 <benmachine> it does FunBinds now, albeit that's quite recent so I may be doin it rong
08:50:04 <Cale> If you want an efficient version of a composed datatype, you can always wrap it in a single-constructor datatype and not export the constructor
08:50:08 <lowasser> suppose I decompose that Seq into a FingerTree Int a
08:50:17 <Saizan> benmachine: ok, thanks :)
08:50:27 <lowasser> and that FingerTree Int a is actually *a different datatype* than your typical FingerTree v a
08:50:31 <lowasser> because it was specialized
08:50:39 <Cale> lowasser: Okay, which you can only do from the module which defines the Seq datatype now.
08:51:02 <lowasser> except are we doing the specialization on FingerTree Ints, or on Seqs?
08:51:28 <mux> I use both a fingertree module and the containers module in my "huffman" package, just because I need a priority queue in one case, and queues in another case
08:51:28 <lowasser> if we're doing {-# SPECIALIZE (FingerTree Int) #-}, then *any* module could run into a different version problem
08:51:29 <benmachine> Saizan: I'll poke you again if I get libgmp sorted out (or an alternative location), poke me if it isn't working for you or does something surprising or something
08:51:29 <Cale> Seqs
08:51:31 <mux> sounds like a waste
08:51:36 <Saizan> lowasser: we're not specializing every use of FingerTree Int
08:51:42 <gwern> mux: you need priority queues?
08:52:00 <Cale> lowasser: *Only* Seq will have its own special structure, not FingerTree Int
08:52:01 <lowasser> but we have to have two FingerTree Ints being comparable to each other
08:52:12 <gwern> mux: maybe you should hop on library@ and mention that; people are arguing about rejecting a priority que impl from containers because there's no evidence anyone would use it
08:52:13 <Saizan> not really
08:52:20 <lowasser> like, if I decompose Seq, I get the specialized version of FingerTree Int
08:52:23 <mux> gwern: I've implemented both methods described in the wikipedia page for building a huffman tree; the one with a priority queue for unsorted inputs (On log n), and the one with two queues for sorted inputs in O(n)
08:52:28 <Cale> lowasser: hm?
08:52:35 <Cale> lowasser: I don't understand your concern.
08:52:48 <lowasser> newtype Seq a = Seq ({- specialized version of -} FingerTree Int a)
08:52:51 <Saizan> lowasser: the assumption is that you can decompose Seq only inside the current module, because the Seq constructor is not exported
08:53:00 <lowasser> mkay
08:53:06 <lowasser> we *also* have to guard against
08:53:16 <lowasser> exporting
08:53:27 <lowasser> secretlyAPatternMatch :: Seq a -> FingerTree Int a
08:53:27 <lowasser> secretlyAPatternMatch (Seq tree) = tree
08:53:42 <Cale> Nah, you can export that, it'll just be comparatively expensive.
08:53:59 <lowasser> so we now we have to have conversion functions
08:54:03 <Cale> (It will be compiled into something which actually builds a FingerTree)
08:54:04 <lowasser> between the specialized and unspecialized versions
08:54:36 <danderson> @lastseen bos
08:54:36 <lambdabot> Unknown command, try @list
08:54:36 <Cale> The same as if you'd written a function to transform the existing Data.Sequence into a FingerTree
08:54:39 <danderson> gah
08:54:39 <Saizan> yeah, we already have that for UNPACKed fields, they get packed again during projections
08:54:48 <Saizan> preflex: seen bos
08:54:48 <preflex>  bos was last seen on #haskell 1 day, 8 hours, 56 minutes and 32 seconds ago, saying: i can easily sustain 20,000 HTTP requests per second with a simple web server in haskell.
08:54:54 <lowasser> that's not how unpacks work
08:55:12 <danderson> Saizan: thanks.
08:55:13 <lowasser> we don't have an original version of the data type where data types aren't unpacked
08:55:31 <lowasser> we just rewrite case statements to actually look at the unpacked fields
08:55:38 <Saizan> lowasser: if you've data Foo = Foo !Int and that gets unpacked, proj (Foo i) = i is not a simple access
08:55:52 <Saizan> lowasser: it's rather proj (Foo i#) = I# i
08:56:04 <lowasser> yes, because it gets rewritten
08:56:12 <Saizan> so you can see I# as a conversion function
08:56:14 <Cale> lowasser: Right, I'm saying we do the same thing.
08:56:23 <lowasser> but the problem is that
08:56:30 <lowasser> we don't have a Foo Int and a Foo !Int
08:56:34 <lowasser> that are separate
08:56:50 <lowasser> and in this specialization approach, we'd need to have that separate thing
08:56:53 <Saizan> lowasser: but we have a Int and an Int# that are separate
08:57:14 <lowasser> yes, but that's not actually what we need!
08:57:15 <lowasser> hold on
08:57:19 <lowasser> constructing example
08:57:28 <lowasser> data Foo a = Foo a
08:57:34 <lowasser> {-# SPECIALIZE Foo Int #-}
08:57:38 <Saizan> i'm not saying the current UNPACK gives us what we want.
08:57:49 <lowasser> I'm saying that what we want is a whole different ballgame
08:57:56 <Saizan> i'm just saying that it has similar problems, and it works anyhow
08:58:13 <lowasser> see, what I'd perhaps do
08:58:19 <lowasser> to implement this extension
08:58:22 <lowasser> is use data families
08:58:38 <lowasser> as follows:
08:58:44 <Saizan> we need to track what we've specialized, and put conversion functions where we've to move to the non-specialized structure
08:58:45 <lowasser> newtype PerfectlyNormal a = Normal a
08:58:56 <lowasser> data family FingerTree v
08:59:00 <lowasser> :: * -> *
08:59:01 <Cale> lowasser: The main idea here is just to avoid having to do the stupid manual specialisation that Data.Sequence exemplifies. Anything which gets us there will do. :)
08:59:09 <lowasser> data instance FingerTree v Int = -- specialized version
08:59:22 <lowasser> data instance FingerTree v (PerfectlyNormal a) = -- typical version of FingerTree
08:59:25 <Cale> That doesn't save any work.
08:59:29 <lowasser> hold up
08:59:39 <Saizan> lowasser: yeah, and then youv'e to specialize the code by hand
08:59:39 <Cale> You still have to write the specialised version by hand.
08:59:44 <lowasser> not there yet!
09:00:12 <Saizan> and yeah, even the type definitions are completely mechanical, and yet you've to write them manually
09:00:13 <lowasser> you let the compiler rewrite all the exported methods on these two instances
09:00:35 <lowasser> I'm saying this is how I'd describe the extension y'all want in terms of things the compiler knows how to do =P
09:00:36 <Cale> Moreover, you really don't want to do this sort of specialisation automatically on parametric types, because it *does* make the performance of certain operations much slower.
09:00:47 <Cale> ah
09:00:55 <jmcarthur> conal: is it your intention that AdditiveGroup be abelian? (it's just as association i have with the word "additive" and i wanted to make sure that was *not* your intent as i suspect)
09:01:17 <lowasser> now, we rewrite any function on a generic FingerTree v a (without a being a specialized type) to use PerfectlyNormal a
09:01:52 <lowasser> so the normal, unspecialized version gets put in PerfectlyNormal
09:02:10 <lowasser> the specialized version gets to use the specialized data family instance, and the specialized methods for it
09:02:27 <conal> jmcarthur: hm.  i hadn't thought about it.  so i guess i don't have an intention either way, at least not consciously.  though i have that same association you do.
09:02:27 <Cale> I'm not sure I understand why you'd do it this way though, rather than just constructing an entirely new type at compile time.
09:02:32 <tsou> Is there a syntax that will allow me to "factor out" a and b in a definition of f like this one?   f a b = g $ h a b
09:02:52 <mux> @pl \a b -> g $ h a b
09:02:52 <lambdabot> (g .) . h
09:02:53 <Cale> f = (g .) . h
09:03:06 <conal> f = (result.result) g h
09:03:06 <Cale> Or  f = fmap g . h
09:03:11 <conal> or fmap.fmap
09:03:12 <mux> but I typically stop using point-free style at that point when it becomes uglier than necessary
09:03:26 <conal> in other words, aim g at the result of the result of h
09:03:31 <lowasser> or define (.:) to implement that functionality, as in, g .: h = \ a b -> g (h a b)
09:03:41 <lowasser> and then just use that combinator instead
09:03:42 <lowasser> =P
09:03:57 <lowasser> Cale: because implementing all the necessary restrictions and details you're describing would be spectacularly hard to work into GHC!
09:03:57 <conal> lowasser: though less elegant, in that you'd have to keep adding combinators
09:04:03 <fax> lol today I learned about point free
09:04:09 <lowasser> conal: more readable, though, if that's all you need
09:04:14 <tsou> ok, thanks, I was wandering if there was something like $ that would do that
09:04:19 <Cale> lowasser: I don't see why...
09:04:21 <lowasser> (g .) . h strikes me as pretty unreadable
09:04:33 <Cale> It's readable if you're used to the idiom
09:04:34 <tsou> something like what lowasser said, but that would work for an arbitrary number of arguments
09:04:41 <fax> :t (((?x .) .) .) . ?z
09:04:42 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *) (f3 :: * -> *). (?x::a -> b, Functor f, Functor f1, Functor f2, ?z::f3 (f2 (f1 (f a))), Functor f3) => f3 (f2 (f1 (f b)))
09:04:48 <lowasser> anyway
09:04:52 <conal> lowasser: if you learn to read semantic editor combinators, you'll get a lot of mileage.  way beyond (.:)
09:05:00 <fax> :t let (f . g) x = f(g(x)) in (((?x .) .) .) . ?z
09:05:01 <lowasser> I mean, I know how to read it
09:05:02 <lambdabot> forall t t1 t2 t3 t4 t5. (?z::t5 -> t4 -> t3 -> t2 -> t, ?x::t -> t1) => t5 -> t4 -> t3 -> t2 -> t1
09:05:10 <fax> see this 'trick' with .) generalized
09:05:17 <fax> so it's "readible" once you learn to read it
09:05:18 <lowasser> *I* just would never put that in a module that I wanted to be readable
09:05:25 <fax> it's not just random brackets and dots
09:05:33 <Cale> You apply h to the first parameter x, and then compose the resulting function with g, so that when the second parameter y is applied, it applies first h x, and then g to it
09:05:36 <tsou> (g .) . h is nice indeed
09:05:38 <lowasser> I don't assume people reading my code have a pointfree fetish =P
09:06:00 <lowasser> anyway
09:06:07 <conal> i wouldn't emphasize "readable", which is more a function of reader than readee.
09:06:14 <lowasser> Cale: you're describing a transformation that is really, really *contrived*
09:06:18 <conal> rather useful.
09:06:40 <Cale> lowasser: I think it's a useful one though, given that it's something that people are doing by hand.
09:06:44 <lowasser> like, it has lots and lots of restrictions that can't be described simply
09:06:46 <Cale> lowasser: and is very mechanical
09:06:57 <Cale> lowasser: No, they're quite simple to describe
09:07:08 <jmcarthur> conal: also, i assume by the absense of instances for Int and Integer that the Scalar type for VectorSpace is intended to be a field?
09:07:37 <lowasser> Cale: whether or not a transformation is *useful* is not necessarily correlated to whether or not someone can actually go into the code for GHC and implement the transformation you're describing without lots and lots of awkward hacks!
09:07:38 <Alpounet> jmcarthur, in which library is it ?
09:07:39 <conal> jmcarthur: yeah.  that's my intention.
09:07:50 <jmcarthur> conal: i ask these questions because i'm making checkers-style tests for vector-space classes
09:08:01 <conal> jmcarthur: ah!  :)
09:08:12 <jmcarthur> conal: VectorSpace is tough to test with its existing instances, too, but a Rational instance should make it easier it hink
09:08:15 <Cale> If a newtype constructor is not exported from a module, the compiler is free to specialise a composite of type constructors into a datatype with a new custom representation as it sees fit, and rewrite the functions in that module to operate on the custom datastructure.
09:08:16 <jmcarthur> *i think
09:08:18 <conal> jmcarthur: yet another reason to codify laws explicitly
09:08:25 <jmcarthur> righto
09:08:32 <conal> jmcarthur: nice idea (rational)
09:08:32 <jmcarthur> Alpounet: vector-space
09:08:36 <Alpounet> ok
09:08:36 <lowasser> hmmm
09:08:36 <Cale> That doesn't seem so contrived to me.
09:08:46 <benmachine> you can't square root rationals
09:08:49 <lowasser> you are making some progress towards convincing me, but I am not yet convinced
09:08:58 <jmcarthur> benmachine: you dont' need to be able to do sqrt for a vector space
09:08:59 <zygoloid> lowasser: i think in order for this specialization thing to work, you'd need to specialize the whole Data.FingerTree module, and create essentially a completely distinct FingerTree type
09:09:04 <lowasser> exactly
09:09:12 <lowasser> which is a *huge* expansion in code size, among other things =P
09:09:17 <lowasser> what you'd have to do is
09:09:23 <Cale> Right, that is *exactly* what I am suggesting.
09:09:25 <zygoloid> {-# SPECIALIZE module Data.FingerTree where data FingerTree Int a #-}
09:09:30 <Cale> (zygoloid's comment)
09:09:30 <lowasser> hold on
09:09:43 <zygoloid> in code size, it's a factor of two. that's all
09:09:45 <lowasser> you'd have to rewrite *every* function imported into this new module that operated on FingerTrees
09:09:50 <lowasser> it's not a factor of two, necessarily
09:09:54 <Cale> Take the entire code of the FingerTree module and rewrite the entire thing to work on the custom datatype.
09:10:03 <Cale> Which is what we're currently doing by hand.
09:10:08 <zygoloid> you could do it with CPP even
09:10:11 <lowasser> you'd also need to pull in any other functions you import that operate on FingerTrees
09:10:11 <quicksilver> and it's what C++ does, after all
09:10:13 <Cale> (which is why this is a valuable transformation)
09:10:48 <Cale> Yeah, any function you have which operates on the parametric datastructure you're specialising
09:10:56 <lowasser> hmmmm.
09:10:59 <quicksilver> well, there is another option.
09:11:05 <roconnor> doesn't supero do this?
09:11:06 <Cale> You pull in its source code and rewrite and specialise it to the new specialised datatype.
09:11:06 <lowasser> I'm not yet convinced that this is an acceptable increase in code size
09:11:10 <zygoloid> in this case there are none, which helps somewhat
09:11:22 <quicksilver> You can provide a hidden unwrapper which converts to the parametric form
09:11:31 <quicksilver> and automatically insert that between calls to external functions.
09:11:33 <Cale> We already get this increase in code size, it's just we're writing it all *by hand*.
09:11:37 <quicksilver> that preserves compositionality.
09:11:39 <lowasser> hold on
09:11:44 <lowasser> are you willing to restrict to the case where the variables we're specializing are single-constructor?
09:12:00 <lowasser> if not, then we can get exponential code blowup, which is definitely unacceptable
09:12:06 <zygoloid> quicksilver: given that we're doing this for performance, that seems slightly painful
09:12:21 <roconnor> http://community.haskell.org/~ndm/supero/
09:12:23 <Cale> *Maybe*
09:12:26 <Cale> hehe
09:12:27 <zygoloid> lowasser: how do you get exponential blowup?
09:12:43 <lowasser> one mo'
09:12:45 <Cale> Well, there ought to be some heuristic on the number of resulting constructors, perhaps.
09:12:49 <quicksilver> zygoloid: depends on how common the external calls are
09:12:53 <lowasser> I actually suggested a similar thing to this a while back
09:13:01 <zygoloid> you can copy-paste your code to a new set of modules, with different names, then specialize them all.
09:13:07 <quicksilver> zygoloid: if that's a rare case and we're just supporting it for completeness.
09:13:11 <lowasser> and simonpj brought down the hammer on me for it
09:13:25 <quicksilver> zygoloid: ...if it's a common case there presumably should be a {-# SPECIALIZE #-} for that module too.
09:13:27 <lowasser> for these exact reasons that I'm arguing, which is why I'm not going to be convinced easily =P
09:13:36 <lowasser> let me find the email
09:13:52 <quicksilver> it's exponential code blowup if we automatically specialise for all possible combs+perms
09:14:04 <quicksilver> it's bounded blowup if we only ever specialize for specific chosen instantiations.
09:14:20 <quicksilver> (which is equivalent to what Data.Sequence is doing "by hand", as Cale keeps pointing out ;)
09:14:22 <zygoloid> it's not really specialization we want though, given that we don't want an implicit override (rather, we want an explicitly new data type in a new module)
09:14:32 <Cale> quicksilver: :)
09:14:32 <zygoloid> (at least, that's my understanding...)
09:14:46 <conal> jmcarthur: what are you up to?  do you have any particular interest in the vector-space package?
09:15:00 <Cale> How many constructors does Int have? ;)
09:15:02 <jmcarthur> conal: i've just writing a matrix library at the moment
09:15:11 <Cale> It's either 1 or 2^n ;)
09:15:16 <zygoloid> it certainly seems like the Sequence / FingerTree situation could be solved by Sequence #including FingerTree with some appropriate #defines ;-)
09:15:27 <zygoloid> fsvo solved
09:15:35 <jmcarthur> *i've just been
09:15:42 <quicksilver> zygoloid: yes, I think that's not the vo solved we're hoping for :)
09:15:48 <jmcarthur> doh!    *i'm just
09:15:49 <Cale> zygoloid: er, well, not quite
09:15:59 <zygoloid> Cale: how so?
09:16:29 <Cale> The idea is that Data.FingerTree's representation is not quite ideal for the special case of Data.Sequence -- you can get some extra performance by packing the Int fields into the constructors
09:17:02 <Cale> So the code of Data.FingerTree has to be modified then to deal with that change in representation, but it's all extremely mechanical.
09:17:29 <conal> jmcarthur: ah.  i'd like to discuss sometime.  i realized just before my icfp talk last year that there's a strong & elegant connection between (a) memo tries + linear maps and (b) standard linear algebra representations.
09:17:33 <zygoloid> Cale: #if SEQ \n {-# UNPACK #-} !Int \n #else \n !v \n #endif
09:17:48 <innu> I have a list [some numers] ++ cycle [4, 2, 1]. Now I need to check if this list contains number 5. How can I do this? I get an infinite loop when using `find` because of the `cycle`. Can I somehow tell that if it sees [4, 2, 1] then there is no point searching any more?
09:17:50 <lowasser> the content of simonpj's email:
09:17:51 <lowasser> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24018
09:18:01 <jmcarthur> conal: i'm also thinking about treading on your domain again and trying my hand at a shader dsl, but i'm going to be sticking with something that is still fairly low level and operationally designed unless i'm struck by the lightning bolt of genius. i'm just wanting a way to use haskell instead of GLSL, basically
09:18:05 <fax> the book I want costs 80 pounds :(
09:18:27 <jmcarthur> conal: but i'm a bit put off by the way gpipe does things, hence trying to make my own
09:18:44 <conal> jmcarthur: i haven't looked at gpipe.  what's it like?
09:18:58 <zygoloid> lowasser: ok, but that's tearing down a different approach from the one being suggested
09:19:11 <lowasser> yes, but we'd have the same problem if we unpacked multi-constructor types
09:19:12 <Cale> I would counter what SPJ is saying with the remark that 'exponential' maybe isn't so bad when the numbers involved are small.
09:19:14 <jmcarthur> conal: code sample: http://www.haskell.org/haskellwiki/GPipe
09:19:26 <lowasser> Cale, you can feel free to argue with SPJ, but I'm not going to =P
09:19:28 <conal> jmcarthur: and would you perhaps be interested in collaborating on gpu/glsl generation from haskell?
09:19:32 <Cale> Obviously you'd want some limitation on the resulting number of constructors
09:19:34 <fax> Cale, di d you study mmoonshine monster?
09:19:36 <conal> jmcarthur: thx
09:19:47 <zygoloid> lowasser: i don't see that we would have the same problem. the approach i described is a factor of 2. and that's it.
09:20:05 <lowasser> consider:
09:20:13 <lowasser> data Foo f a = Foo (f a) (f a)
09:20:26 <lowasser> {-# SPECIALIZE (Foo Maybe) #-}
09:20:36 <lowasser> or data Foo f a = Foo (f a) (f a) (f a) (f a)
09:20:43 <lowasser> in which case we get 16x blowup
09:20:50 <Cale> fax: Not in any great detail.
09:21:01 <zygoloid> no. you just get 'data Foo maybe a = Foo (Maybe a) (Maybe a)'
09:21:06 <quicksilver> jmcarthur: can I encourage you to release early, release often. I'd be very interested in what you come up with, even low level and operationall designed
09:21:09 <fax> Cale the book is 80 pounds but I want to own it :(
09:21:14 <quicksilver> jmcarthur: and my feeling is, quite a few people will be interested.
09:21:17 <Cale> fax: Oh, not a specific book.
09:21:20 <lowasser> zygoloid: in that case, we get no benefit from the specialization!
09:21:30 <fax> it's ridiculous to just buy books which cost this much
09:21:35 <Cale> fax: I was assuming you were referring to the monstrous moonshine theory in general.
09:21:40 <fax> yeah I was
09:21:55 <lowasser> if that's the only specialization we're doing, then we don't actually get any performance benefit
09:21:58 <fax> I have to fill in prerequistits to study this
09:22:05 <jmcarthur> conal: i'd be up for collaborating, but i don't really know what i'm doing yet. i never used a shader before haskell at all, only basic opengl, and i've also never written a sophisticated compiler before
09:22:22 <lowasser> we'd get performance benefits if we actually did the constructor unpacking, but as previously stated, exponential blowup
09:22:31 <Cale> fax: What interests you about it?
09:22:37 <conal> jmcarthur: got it.  you'll learn a lot by jumping in the mud puddle an splashing around.
09:22:43 <zygoloid> lowasser: why do you want to unpack multi-constructor types?
09:22:53 <jmcarthur> quicksilver: once i have anything worth putting up i probably will
09:22:56 <lowasser> I'm saying that we ought to rule those out!
09:23:24 <fax> Cale --  I am seduced by the idea there are deep connections between different fields
09:23:28 <lowasser> because we don't get serious performance benefits except by unpacking, and unpacking multi-constructor types leads to exponential blowup, which is bad
09:24:04 <jmcarthur> conal: i'm not sure whether splashing around in a mud puddle sounds much like collaboration though ;)
09:24:20 <Alpounet> jmcarthur, maybe not, but it sounds fun :-)
09:24:35 <zygoloid> lowasser: i hadn't realized you wanted the SPECIALIZE to implicitly also unpack!
09:24:51 <conal> jmcarthur: to me neither.  once you do, though, you may have clearer ideas & more focused curiosity.  let me know when you'd like to chat.
09:24:56 <lowasser> I mean, that's the primary benefit, methinks
09:25:04 <lowasser> I mean, hrrm
09:25:14 <lowasser> I mean, you'd get some benefits without unpacking, now that I think about it
09:25:29 <jmcarthur> con sure
09:25:31 <jmcarthur> err
09:25:33 <jmcarthur> conal: sure
09:25:35 <lowasser> but you'd also get the same benefits
09:25:36 <zygoloid> yeah, in the Sequence case i wonder how much of the benefit comes from inlining the monoid
09:25:50 <lowasser> zygoloid: most of it *does* come from unpacking the Int
09:26:11 <lowasser> I'm sure on that score
09:26:13 <lowasser> but
09:26:37 <lowasser> wouldn't you get the same benefits from copy/pasting the code and find/replacing the type you want to specialize on?
09:26:43 <Cale> lowasser: Well, you get an exponential blowup in general, but in some cases, this just means twice or 4 times the number of constructors, which is really not so bad.
09:26:56 <quicksilver> Cale: exp(constant) is constant!
09:27:01 <lowasser> Cale: argue with SPJ, not me =P
09:27:01 <Cale> lowasser: so you'd just want to put some heuristic bound on it :)
09:27:09 <lowasser> also, you'd have to decide
09:27:14 <quicksilver> lowasser: we would, but he never comes in IRC.
09:27:20 <lowasser> if you'd go past the bound, which constructors do you unpack, which don't you?
09:27:20 <jmcarthur> quicksilver: i'm not going to be waiting until things are *working* before releasing it, but i will probably at least wait until i'm sure the idea is worth pursuing at all (and therefore not embarassing ;) )
09:27:22 <lowasser> (email him!)
09:27:24 <quicksilver> lowasser: I have a long list of things to argue with him about if he ever does.
09:27:27 <lowasser> hahaha
09:27:29 <fax> but I didn't even do analytic number theory
09:27:31 <lowasser> anyway
09:27:32 <fax> and I guess representations
09:27:38 <fax> and functional analysis
09:27:39 <lowasser> the which-constructor-to-unpack question is nonobvious
09:27:41 <fax> lots and lots of stuff I don't know....
09:27:56 <zygoloid> lowasser: "specializing" 'data Foo m a = F (m a) (m a)' into 4 constructors gives a different set of values once you take bottoms into account
09:28:07 <Cale> fax: I like group theory, and I suppose representation theory (though I could stand to learn a lot more of that), but I can't stand analytic number theory for some reason.
09:28:13 <lowasser> yeah, if we're unpacking, they'll also have to be strict
09:28:27 <lowasser> of course we don't unpack a lazy field
09:28:32 <andrewsw> innu: pattern match on multiple elements in the list?
09:28:35 <lowasser> okay, so
09:28:37 <Cale> I like the combinatorial bits of analytic number theory, but not the analysis part :P
09:28:49 <Alpounet> Cale, agreed, I don't find it to be elegant
09:28:51 <fax> I like complex analysis :p
09:29:05 <fax> and zeta function
09:29:08 <lowasser> I claim that if we don't unpack any constructors, then we don't get any benefits that we wouldn't get from copy/pasting the code and find/replacing the type we're specializing on
09:29:11 <fax> but that's not really it
09:29:14 <fax> I guess
09:29:33 <Cale> At a certain point, I get really annoyed with all the refinements of asymptotic bounds on number theoretic functions that I barely care about to begin with ;)
09:29:43 <fax> oh it's like numerical analysis
09:29:55 <lowasser> and if we do unpack constructors, then they'll need to be strict, and current GHC practice would seem to say that we should restrict to single-constructor types.
09:30:21 <zygoloid> lowasser: i would suggest: 1) UNPACK can be applied to type variables, but does nothing by itself. 2) SPECIALIZE can be applied to types, and creates new constructors (one for each existing ctor). 3) in a specialized constructor, single-ctor types with UNPACK get unpacked
09:30:31 <fax> yeah I have to say I found anything which is an approximation formula or similar very hard to remember
09:30:49 <lowasser> zygoloid: this is...sane, so far
09:30:58 <lowasser> I'd add that
09:31:01 <fax> but sometimes you can produce exact results with it, which is a surprise
09:31:06 <lowasser> 4) UNPACK has no effect for nonstrict fields
09:31:09 <zygoloid> you can only SPECIALIZE a type in the module which defines it, obviously, otherwise pattern matching can't work
09:31:32 <zygoloid> lowasser: i think that should still be a hard error
09:31:43 <lowasser> heh, I like that even better
09:31:50 <zygoloid> since no SPECIALIZEing will make the field strict
09:31:52 <fax> "The finite symmetry atoms are very large, and data about each one is encoded into a character table â a square array of numbers, rather like a giant sudoku puzzle. The Monster's table has 194 rows and columns, and the Moonshine connections showed that the first column generates an important sequence of numbers in number theory (the coefficients of the jâfunction)."
09:31:58 <Alpounet> is there any manifold-related math library on hackage ?
09:31:59 <Cale> Algebraic number theory is pretty in places, but also includes some really really brutal stuff.
09:32:00 <Alpounet> can't find any
09:32:15 <monoidal> how to fix this functional dependence? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24019#a24019 must I use type families?
09:32:26 <lowasser> okay, so if we have k different specializations, then we'll blow up the code by a factor of k
09:32:26 <fax> algebraic ? like algebraic geometry?
09:32:53 <jmcarthur> conal: i basically want something like gpipe, but with a more applicative style interface
09:33:08 <Cale> Like the theory of Dedekind domains and ideal class groups.
09:33:11 <lowasser> zygoloid: are we going to restrict that the constructors don't get exported?
09:33:38 <lowasser> if they get exported, then we'll also need some sort of conversiony thingy
09:33:43 <zygoloid> lowasser: i don't think that's a problem actually, since at the point of export you know what the specialized constructors are
09:33:53 <zygoloid> it does mean any code which pattern matches gets specialized too
09:33:58 <Cale> algebraic number fields, rings of integers, and all that :)
09:34:06 <lowasser> yes, but an importing module has to be able to convert between specialized versions and generic versions I think?
09:34:17 <fasta> I get <command line>: unknown package: Vec-0.9.6, when I do ghc --make Foo.hs. Why?
09:34:32 <conal> jmcarthur: what's your level of interest in a semantics-based design?
09:34:33 <jmcarthur> conal: as it stands with gpipe, you basically hoise vertices into the gpu then use fmap to manipulate them, then rasterize, then use fmap to manipulate the pixels, then paint them to a framebuffer
09:34:39 <jmcarthur> *hoist
09:34:40 <lowasser> like, an importing module that created a new function on the specialized type
09:34:48 <lowasser> or
09:34:54 <fasta> I already know that package should not exist, but it should tell me why it wants the package in the first place. I am not telling that it needs it.
09:34:57 <lowasser> a new function on the generic version of the type that had been specialized
09:35:24 <lowasser> would also have to do the k-fold blowup thing
09:35:43 <lowasser> because the generic version and the specialized version aren't actually the same type anymore
09:35:57 <lowasser> and then any function that called that function would have to blow up
09:36:18 <quicksilver> fasta: your package database is claiming that some module (which Foo.hs imports) is to be found in that package?
09:36:20 * Cale is scarred for life by homework assignments where the proofs would break down into cases modulo 4 or 8 or 16, and each case would be its own maze of divisibility relations.
09:36:31 <lowasser> ...and if a function called several different functions, each specializing on different types, then we'd get
09:36:33 <lowasser> exponential blowup.
09:36:39 <Cale> Our professor was a bit cruel :)
09:36:50 <jmcarthur> conal: i'm interested as long as the semantic model captures a large part of what GLSL can do in the raw, but i'm not extremely interested in the search for a great model. i do eventually want to use this to make some actual games
09:36:57 <fasta> quicksilver, I also have 0.9.7 installed, so I don't see why it would want to do that.
09:37:03 <lowasser> example:
09:37:12 <lowasser> suppose we have data Foo a = Bar | Foo {-# UNPACK #-} !a
09:37:19 <lowasser> {-# SPECIALIZE Foo Int, Foo Char #-}
09:37:31 <Cale> We asked him after the course why his homework assignments were so brutal, and he said "I wanted to show that sometimes number theory is just hard".
09:37:42 <lowasser> f :: Foo a -> Foo b -> Bacon
09:37:45 <quicksilver> fasta: that is nevertheless my guess, based on my limited understanding of how this stuff works.
09:37:56 <jmcarthur> conal: i mean, as long as the model is reasonably powerful
09:37:57 <quicksilver> fasta: you can poke around with ghc-pkg find-module and ghc-pkg list
09:37:57 <conal> jmcarthur: k
09:37:58 <lowasser> then f would have to be specialized four different ways
09:38:08 <quicksilver> fasta: (and various other ghc-pkg subcommands)
09:38:40 <lowasser> the alternative would be to provide conversion functions between the generic and the specialized versions
09:39:05 <fax> Cale one of my teachers would give problems and they all have anwsewrs like  1 + 2x + 3x^2 + 4x, or  e^(1x) + e^(2x)  and stuff :P
09:39:07 <lowasser> except for recursive datatypes, that's a huge performance cost, possibly enough to outweigh the whole point of the specialization =P
09:39:14 <conal> jmcarthur: your description matches my interests as well.  except that i am additionally "extremely interested in the search for a great model".
09:39:22 <fax> I mean like they are all set up to gives 1,2,3,.. in the answer
09:39:35 <jmcarthur> conal: well, i'm interested in the search as well, i just have to prioritize
09:39:36 <lowasser> conclusion: I don't think any approach in this vein is practical
09:40:06 <jmcarthur> it's a hard decision :(
09:40:07 <lowasser> unless we do impose the restriction that we don't export the constructors
09:40:55 <lowasser> in which case all we need to worry about is
09:41:12 <lowasser> secretlyAPatternMatch (Seq tree) = tree
09:42:04 <lowasser> in which case, we might be able to do the conversion for just the cases that essentially export the value we're specializing
09:42:22 <lowasser> ...except, hmmm
09:42:41 <lowasser> yeah
09:42:48 <lowasser> that's a serious performance killer, but just for those functions
09:43:20 <lowasser> ...in conclusion, I think the only way of implementing this type of specialization would have to work as follows:
09:43:43 <jmcarthur> conal: actually, you might say i have a model for mine aside from operational, but it's just the lambda calculus
09:44:06 <lowasser> 1) UNPACK can be applied to type variables, but does nothing by itself. 2) SPECIALIZE can be applied to types, and creates new constructors (one for each existing ctor). 3) in a specialized constructor, single-ctor types with UNPACK get unpacked 4) Any specialized data type cannot have its constructors exported, I'm pretty sure
09:44:07 <jmcarthur> conal: a fairly straight up compiler from functional code to GLSL
09:44:16 <conal> jmcarthur: or maybe that you have the same model as the lambda calculus.
09:44:25 <lowasser> anyway
09:44:25 <jmcarthur> hmm
09:44:27 <conal> jmcarthur: that's what i do as well.  very simple.
09:44:57 <jmcarthur> conal: do you have an idea of what the lambda calculus's model is?
09:45:09 <lowasser> it's super convoluted, can only be applied in very limited cases, and I'm not yet convinced that the performance benefit is worth the huge amount of hassle that seems to be necessarily involved
09:45:15 <rajeshsr> is there anyone who has been extremely slow in learning haskell? I somehow miss something about it! I haven't written any non-trivial code with it, except for some fun work in interpreter! Any advice?
09:45:32 <fax> rajeshsr, it does not have to be fast :)
09:45:44 <conal> jmcarthur: depends on typed vs untyped.  dana scott came up with the first model for the untyped lambda calculus.  that development put strachey's work on a foundation.
09:45:48 <jmcarthur> conal: if that's what you are doing then maybe our goals are fairly aligned after all
09:45:49 <lowasser> I'm also not yet convinced that copy/pasting is all that bad a solution...heh.
09:46:02 <jmcarthur> or at least our visions
09:46:17 <jmcarthur> our goals can still diverge even with the same current vision i guess
09:46:20 <conal> jmcarthur: sounds like it.
09:46:30 <lowasser> that is, I don't think you'd have to change that much to change a copy/pasted FingerTree into the actual Seq implementation, with an unpacked integer measure
09:47:21 <rajeshsr> fax, well i have been learning it for more than 6 months, especially for the last 1 months quite well! Even then i seem not have learned all it takes to write some non-trivial code!
09:47:56 <FliPPeh> I am slow in learning haskell
09:47:58 <fax> rajeshsr: I think if you have the basics then at any time you want it will be possible to write something harder -- of course there will be learning on the way too
09:48:01 <FliPPeh> The advanced stuff still scares me
09:48:18 <fasta> quicksilver, I removed all the object files and it magically worked.
09:48:34 <FliPPeh> Also, how to write good haskell code is a mystery. My code always ends up heavily iterativly
09:48:37 <FliPPeh> :(
09:49:10 <merijn> FliPPeh: Heh, how do you write heavily iterative haskell?
09:49:14 <fasta> Someone please write a Haskell compiler that works regardless of existing object files.
09:49:18 <fax> haha my code is bad too
09:49:42 <FliPPeh> merijn: Getting stuck in "do" notation for stuff that should be done in pure functions for example
09:50:36 <rajeshsr> even i suffer from imperative mania! For a wodd-cutter all is wood, may be that is true with imperative programmers! :P
09:50:37 <merijn> Ah, I had a neat trick for that, I didn't look at the do notation until I mostly got how stuff worked :p
09:50:41 <danblick> hm, i'm not sure i understand the techniques for modularizing state in haskell..
09:50:53 <Saizan> fasta: stick -fforce-recomp everywhere?:)
09:51:08 <fasta> Saizan, yes, that would work,  but it would not work efficiently.
09:51:46 <merijn> FliPPeh: pastebin an example function? It helps to see pure implementations of functions next to do notation to get a feel for it
09:52:25 <dantheman_> Hey, can anyone tell me what exactly lambdabot IS and what it is for?
09:52:25 <FliPPeh> merijn: I'll look around
09:52:32 <FliPPeh> dantheman_: It's an IRC bot
09:52:50 <dantheman_> excuse my ignorance but what's an IRC bot?
09:52:52 <merijn> danblick: It's an IRC bot that let's you lookup haskell function definitions and try out code
09:53:03 <FliPPeh> dantheman_: Lambdabot can do THIS:
09:53:11 <merijn> dantheman_: It's just a program scanning all the IRC messages for special syntax to send it commands
09:53:14 <FliPPeh> > map ((+) 2) [1..5]
09:53:16 <lambdabot>   [3,4,5,6,7]
09:53:24 <dantheman_> ah cool
09:53:35 <FliPPeh> > filter (== "Hi") ["ad", "3jhjh", "Hi", "Hi", "jkjk"]
09:53:36 <lambdabot>   ["Hi","Hi"]
09:53:47 * hackagebot HTF 0.3.1 - The Haskell Test Framework  http://hackage.haskell.org/package/HTF-0.3.1 (StefanWehr)
09:53:52 <dantheman_> so what do I have to preface the code with for lambdabot  to pick it up ... is it that little '>'
09:53:58 <FliPPeh> Yep
09:54:01 <FliPPeh> > undefined
09:54:02 <lambdabot>   * Exception: Prelude.undefined
09:54:08 <merijn> dantheman_: Try "/msg lambdabot @help"
09:54:29 <FliPPeh> @hpaste
09:54:29 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
09:54:38 <quicksilver> fasta: gotta love magic.
09:55:09 <FliPPeh> merijn: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=8622#a8622
09:55:11 <dantheman_> merijn did I do that correctly?
09:55:15 <FliPPeh> I don't like this one for example
09:55:26 <FliPPeh> I'm repeating n there
09:55:34 <dantheman_> > /msg lambdabot @help
09:55:35 <lambdabot>   <no location info>: parse error on input `/'
09:55:44 <fasta> quicksilver, I just learned that it is a company trade secret how to change the backlight status on my laptop. I just love magic.
09:56:03 <FliPPeh> > let isPalindrome str = str == reverse str in isPalindrome "otto"
09:56:04 <lambdabot>   True
09:56:10 <FliPPeh> > let isPalindrome str = str == reverse str in isPalindrome "lagerregal"
09:56:11 <lambdabot>   True
09:56:12 <merijn> dantheman_: No, I mean you should just send it a private message directly with the text "@help" that'll make it respond to you via private message with help info
09:56:15 <FliPPeh> > let isPalindrome str = str == reverse str in isPalindrome "Hi"
09:56:17 <lambdabot>   False
09:56:22 <danderson> so, I'm failing to grok the fullness of forall syntax. How should I read the following: newtype Parser a = Parser { runParser :: forall r. S -> Failure r -> Success a r -> Result r }
09:56:27 <merijn> dantheman_: (To avoid spamming the channel)
09:56:36 <aavogt> @let isPalindrome = (==) `ap` reverse
09:56:37 <lambdabot>  Defined.
09:56:45 <FliPPeh> :t ap
09:56:46 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
09:56:49 <FliPPeh> :/
09:56:54 <fax> danderson, do you know continuation pasing style?
09:57:00 <FliPPeh> @pl isP f = f == reverse f
09:57:00 <lambdabot> isP = ap (==) reverse
09:57:08 <dantheman_> ah right, sorry about that... thanks. What happens when you send it something that causes an infinite loop?
09:57:13 <FliPPeh> I don't understand (ap)
09:57:20 <danderson> I read that as equivalent to newtype Parser a r = Parser { runParser :: S -> Failure r -> Success a r -> Result r }, but that then makes no sense.
09:57:31 <merijn> dantheman_: I think it terminate the code after a while
09:57:31 <FliPPeh> dantheman_: Will not happen
09:57:50 <FliPPeh> > foldr (+) 0 [1..]
09:57:51 <merijn> danderson: The last type signature means that all r's there are the same
09:57:51 <lambdabot>   * Exception: stack overflow
09:57:52 <aavogt> FliPPeh: can you substitute   (Monad m)   for    Monad (t ->)
09:58:04 <danderson> fax: yes?
09:58:09 <dantheman_> Ah cool
09:58:26 <fax> danderson -- good
09:58:35 <quicksilver> fasta: wave your finger above the screen and shout LUMOS in a commanding voice.
09:58:41 <fax> danderson what you said is 'equivalent' is not
09:58:57 <fax> danderson, the best thing to do is ask ghci what is the type of  Parser,  and what is the type of  runPaser
09:59:00 <danderson> fax: I guessed as much, since you don't invent new syntax for shits and giggles
09:59:30 <mxc> cpphs should generally give the same result as cpp correct? especially when evaluating the autogen macros like MIN_VERSION_unix
09:59:32 <mxc> etc
09:59:33 <fasta> quicksilver, that probably only works on your machine.
09:59:38 <mxc> cpphs doesn
09:59:39 <mxc> 't
09:59:41 <mxc>  seem to work at all
09:59:50 <merijn> danderson: If I have the following types: "forall t. [Something t]" and (Something t) => [t]" the latter means every item in the list is the same type, which also is an instance of Something. The former means every item in the list is an instance of Something, but they're not all necessarily the same type
09:59:52 <mxc> oops, sry about the multiline - bad keyboard
10:00:03 <zygoloid> lowasser: even not restricting the constructors doesn't prevent exponential blowup within the module
10:00:17 <zygoloid> -not
10:00:17 <augur> heyo haskelliers. anyone know of any websites with graph-theory algorithms, or more importantly, resources for playing with said algorithms
10:00:18 <augur> ?
10:00:18 <fasta> mxc, cpphs and cpp do different things.
10:00:19 <lowasser> conclusion: it's a lost cause.
10:00:30 <merijn> danderson: Excuse the crappy type signature, I'm not sure about the proper way to write them, but I figure it's close enough to get it.
10:00:32 <mxc> the problem is that cpphs doesn't seem to work at all
10:00:38 <mxc> on those macros
10:00:40 <fasta> mxc, the only way to know is to find the documentation of cpphs and compare with what you see.
10:00:46 <lowasser> augur: I enjoy reimplementing the Data.Graph.Inductive.Query modules of fgl
10:00:49 <mxc> been going through that
10:00:50 <fasta> mxc, cpphs has worked for me in the past.
10:00:55 <zygoloid> lowasser: i think the clone-off-a-separate-datatype-in-a-new-module approach is still viable though
10:00:57 <augur> lowasser: :P
10:01:03 <mxc> ever ues the MIN_VERSION_xxx macros from cabal?
10:01:09 <lowasser> hrrm
10:01:11 <augur> lowasser: perhaps! i need test graphs for a maxclique algo tho
10:01:16 <lowasser> ah
10:01:21 <lowasser> can't help you there
10:01:23 <augur> ;)
10:01:25 <fasta> mxc, no.
10:01:26 <lowasser> except maybe
10:01:34 <lowasser> I wrote a script to download my Facebook friend graph =P
10:01:40 <lowasser> meh
10:01:43 <lowasser> I really need to go
10:02:03 <augur> lol
10:03:04 <danderson> merijn: okay, I guess. But what about when r is not constrained at all except by the forall?
10:03:39 <danderson> seems to me in the example I pasted, the only point is so that r doesn't appear in the type of Parser
10:04:36 <merijn> danderson: It would seem that is to be able to have different r's for the Success and Failure?
10:05:02 <merijn> Mind you, I'm not sure I know forall enough to explain that signature
10:05:34 <benmachine> > 1 + (+) 2 3
10:05:35 <lambdabot>   6
10:05:41 <danderson> merijn: that makes no sense though, because the way Failure and Success are used (they're functions), they return the Result that is the overall outcome of the parser
10:05:50 <ski> preflex: xseen edwardk
10:05:50 <preflex>  edwardk was last seen on freenode/#haskell 1 day, 9 hours, 42 minutes and 54 seconds ago, saying: conal: iirc io snuck into his specification because of ffi constraints
10:05:52 <benmachine> Saizan: http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi?expr=let+foldr+f+z+%5B%5D+%3D+z%0D%0A++++foldr+f+z+%28x%3Axs%29+%3D+f+x+%28foldr+f+z+xs%29%0D%0A+in+foldr+%28%2B%29+0+%5B1%2C2%2C3%2C4%5D
10:06:05 <danderson> so if the r's are different, the types for callers would make no sense afaict
10:06:23 <conal> oh.  i missed that remark from edwardk
10:06:51 <danderson> aaah
10:07:06 <danderson> found the haskell wikibook, which explains exactly what I needed
10:07:14 * ski idly wonders what signature merijn is thinking about ..
10:07:16 <benmachine> (wow, I got my thing to compile on GHC 6.8 with only minor modifications)
10:07:17 <danderson> "The forall keyword is used to explicitly bring type variables into scope"
10:08:13 <danderson> so, it's as I was saying: since there's no point in having the r be part of the type for Parser, the type variable is defined at the point of use within the type definition
10:08:40 <monoidal> fundep problem: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24019#a24020 - how to correct it?
10:08:53 * benmachine wonders if adding a dependency on extensible-exceptions is worth extra compatibility
10:08:57 * benmachine decides: yes
10:09:19 * benmachine wonders if it is worth losing the Source-Repo field in .cabal for compatibility, decides: no
10:11:04 <Cale> monoidal: That's right.
10:11:05 <ski> merijn : (assuming `Something' is a class), `forall t. [Something t]' doesn't mean "every item in the list is an instance of Something, but they're not all necessarily the same type"
10:11:39 <merijn> ski: Like I said, I have no clue what the proper formatting on type signatures with forall is
10:11:40 <Cale> monoidal: You already have an instance Color (Maybe u) Blue, so according to the fundep, you can't have an instance Color (Maybe u) Green
10:11:54 <ski> merijn : probably your meant `[exists t. Something t *> t]' (which is made up syntax), but which you can simulate with extensions as
10:12:26 <Cale> monoidal: It's worth noting that the class context can't possibly be used to select between instances, and so is completely ignored for purposes of functional dependencies.
10:12:58 <ski> merijn : `[AnySomething]' where `data AnySomething = forall t. Something t => WrapSomething t' (or in GADT syntax `data AnySomething where WrapSomething :: Something t => t -> AnySomething')
10:13:42 <monoidal> Cale: Understood, thanks. Is it expressible in any other way?
10:15:15 <Cale> With UndecidableInstances, you could write an instance Color u v => Color (Maybe u) v
10:15:33 <aavogt> @type asTypeIn
10:15:34 <lambdabot> forall a b. a -> (a -> b) -> a
10:16:03 <mreh> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24021#a24021 -- could someone have a quick look over my perceptron and tell me why the stack overflows with more than 150 training epochs
10:16:22 <mreh> you set the number of epochs in line 55, follow it through from the main function
10:16:44 <Cale> mreh: First guess, the accumulators
10:16:44 <ski> > length `asTypeIn` \length -> length "foo"
10:16:46 <lambdabot>   ""->
10:16:46 <lambdabot>    0
10:16:46 <lambdabot>  "a"->
10:16:46 <lambdabot>    1
10:16:46 <lambdabot>  "aa"->
10:16:48 <lambdabot> [7 @more lines]
10:16:50 <ski> er
10:16:52 <ski> @type length `asTypeIn` \length -> length "foo"
10:16:53 <lambdabot> [Char] -> Int
10:17:02 <Cale> mreh: nothing is forcing the evaluation of p, fp, or fn
10:17:25 <Cale> mreh: So they're going to build up large expressions like (((...) + 1) + 1) + 1
10:17:40 <Cale> and that could cause a stack overflow
10:17:42 <mreh> Cale: that isn't dependent on the number of epochs
10:17:53 <mreh> but good observation
10:19:27 <mreh> Cale: good, guess, wrong answer :(
10:19:32 <mreh> thanks though
10:19:41 <Cale> Well, okay
10:20:22 <Cale> Out of interest, you're compiling with optimisations, right?
10:20:28 <mreh> Cale: no
10:20:38 <Cale> Try compiling with optimisations and see if it still happens
10:21:46 <Cale> Without optimisations, there's no strictness analysis, which makes things like stack overflow far more likely.
10:22:14 <fax> is there a nice way to display a graph from haskell and also mutate it so the image updates in realtime?
10:24:45 <gwern> @wn belike
10:24:46 <lambdabot> *** "belike" wn "WordNet (r) 2.0"
10:24:46 <lambdabot> belike
10:24:46 <lambdabot>      adv : with considerable certainty; without much doubt; "He is
10:24:46 <lambdabot>            probably out of the country"; "in all likelihood we are
10:24:46 <lambdabot>            headed for war" [syn: {probably}, {likely}, {in all
10:24:48 <lambdabot>            likelihood}, {in all probability}]
10:24:55 <fax> @wn alot
10:24:56 <lambdabot> No match for "alot".
10:25:00 <mreh> I was training the perceptron in GHCi, and with GHC and -O2, it's *slower*
10:25:09 <Cale> very weird
10:25:12 <lowasser> super weird
10:25:27 <lowasser> I seem to remember there being a thing on GHC saying "if that ever happens, report a bug"
10:25:52 <Cale> But more importantly, do you still get the stack overflow?
10:26:00 <mreh> Cale: I can't tell, it takes so long
10:26:09 <mreh> i.e. halting problem
10:26:13 <mreh> I'm going to insert some trace
10:26:22 <Cale> Well, of course the stack overflow might have happened quickly :P
10:27:20 <mreh> Cale: but I can never tell!
10:27:25 <mreh> still whirring away
10:27:45 <mreh> maybe I will get my name on the GHC homepage afterall!
10:27:57 <benmachine> maybe the stack overflow comes from an infinite loop?
10:28:08 <Cale> yeah, I'm starting to suspect that might be the case
10:28:17 <Cale> well...
10:28:21 <benmachine> then GHC would hang while GHCi would just die
10:28:35 <Cale> Actually, no, probably can't be infinite
10:28:39 <benmachine> for some kinds of loop
10:28:40 <Cale> but how large are n and d?
10:29:05 <mxc> so, in ghc 6.12, diff arrays were taken out of the included array pacakge and put somewhere else.. but, I can't seem ot find it on hackage..  anyone know where it is?
10:29:09 <mreh> Cale: ?
10:29:11 <Cale> [1..n] >> d will have n * length d elements
10:29:24 <Cale> and your loop function is going to loop that number of times.
10:29:41 <Cale> mxc: I couldn't find it
10:29:59 <Cale> mxc: It was supposed to be put in a package called diffarray, but I didn't see one
10:30:21 <mxc> cale: thanks anyway, was hoping someone in a later timezone might have had some inside knowledge :)
10:30:34 <Cale> mxc: Perhaps that's one of the things left to do before releasing the Platform for 6.12
10:30:41 <mreh> in this particular case n = 100, and d =~ 400
10:30:49 <mxc> ah
10:31:21 <mreh> Cale ^^
10:31:32 <mreh> but, that list should be lazily evaluated
10:31:41 <Cale> the list will be
10:31:49 <Cale> But that's the number of iterations in your loop
10:32:25 <Cale> I don't know much about Data.Packed.Vector, but I hope it's a strict datastructure.
10:32:35 <aavogt> can you take functions defined using fundeps and wrap them up with type families?
10:33:50 <artzz> hello everyone
10:33:54 <Cale> hello
10:33:58 <artzz> I am testing my first programs with haskell
10:34:02 <Cale> mreh: Which package is that from?
10:34:09 <Cale> artzz: cool :)
10:34:10 <mreh> Cale: hmatrix
10:34:13 <artzz> and I am using vim, identing with tabs, but I am getting parsing errors, do I have to use spaces to indent?
10:34:38 <Cale> mreh: ah, okay, yeah, it's strict then
10:34:48 <arw> artzz: when your tabwidth is not 8, yes
10:34:52 <Cale> artzz: yes
10:35:00 <artzz> arw: oh, but tabwidth 8 sucks.. well, too long for me
10:35:03 <Cale> artzz: :set expandtab and smarttab
10:35:16 <Cale> artzz: tabs are evil and should not be allowed into your source files
10:35:20 <arw> artzz: yes, but haskell assumes that a tab is 8 spaces. if it isn't it breaks.
10:35:23 <tsou> Can I use ghc-6.12.1 to compile ghc-6.10.4?
10:35:30 <artzz> oh ok,
10:35:31 <mreh> Cale: I just remembered, d is more like 4000
10:35:34 <Cale> artzz: I actually wish that the compiler treated them as lexical errors, myself ;)
10:35:39 <mreh> the testing set is =~ 400
10:35:42 <mreh> oops
10:35:54 <arw> artzz: don't use layout or don't use tabwidth other than 8, or just let your editor replace tabs by spaces.
10:36:10 <fax> I need a realtime graph display in haskal
10:36:11 <Cale> mreh: ah, okay, so it's a much larger loop, around 4000000 iterations. That's more sufficient to cause a stack overflow if there's a strictness issue.
10:36:12 <fax> ;{
10:36:18 <artzz> arw: ok, so maybe tabwidth=8 and smarttab and expandtab may do
10:36:42 <arw> artzz: tabwidth=8 or (smarttab and expandtab) may do.
10:36:44 <Cale> artzz: I usually set the tab key to produce 2 spaces.
10:37:10 <artzz> mm but it'd be better if it was shown as less space with vim I guess
10:37:13 <Cale> artzz: and expandtab will ensure that only spaces get inserted
10:37:29 <arw> artzz: if you have expandtab, the tabwidth doesn't really matter.
10:37:38 <Cale> It's just physical tab characters you need to worry about
10:37:50 <arw> artzz: because what counts is visual alignment if you don't use tabs
10:37:55 <artzz> yes, I thought they'd be fine with haskell
10:37:55 <Cale> They're treated by the compiler as aligning to the next 8-space multiple
10:38:26 <Cale> and yeah, it really matters in Haskell to be able to line things up vertically, so variable width tabs are awful.
10:38:53 <Cale> (on the other hand, nobody cares how much you indent things, as long as they line up properly)
10:38:57 <elspru> hey, i've got address translation thing works for single address, breaks for more than one
10:39:00 <elspru> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24022#a24022
10:39:29 <mreh> Cale: I count 400000
10:39:50 <mreh> no you're right
10:39:52 <elspru> if   "translation = firstTranslation", it works fine
10:40:01 <elspru> if it's nextTranslation, it loops forever
10:40:18 <elspru> i've been wracking my brains for a week
10:40:22 <elspru> can't seem to make it work
10:40:37 <mxc> i remember a while back some chatter on haskell-cafe about adding MapLike, ArrayLike, ListLike etc collections typeclasses to hte standard libraries
10:40:47 <mreh> I don't know who is right!
10:41:04 <mxc> is that dead or under development?
10:41:12 <gwern> the barracuda repo is 400 megs. a good example of why you don't check in binaries...
10:42:12 <artzz> what would be wrong with this code? http://pastebin.ca/1842592
10:42:50 <lowasser> mxc: I certainly think it's a bad plan, if only because it clutters the namespace moar
10:42:50 <quicksilver> artzz: the indeentation, for one thing
10:42:54 <quicksilver> > -1 - 2
10:42:55 <lambdabot>   -3
10:43:02 <lowasser> better to have a separate package for that sort of thing
10:43:17 <artzz> quicksilver: can you correct it on pastebin to see how it'd be done?
10:43:25 <Saizan> there's the Edison package already, but noone uses it
10:43:31 <quicksilver> artzz: make 'aa' line up with 'det'
10:43:35 <Cale> mreh: er, maybe I am wrong :)
10:43:41 <artzz> ohh
10:43:46 <quicksilver> artzz: that is, the first 'a' of 'aa' should be in the same column as the 'd' in 'det'
10:43:52 <quicksilver> (in the let clause)
10:44:03 <Cale> mreh: But 400000 seems on the small side to cause a stack overflow.
10:44:09 <mxc> lowasser - part of the appeal of it was so that the standard libs would be so much more generic
10:44:22 <artzz> quicksilver: mm, then programming like this can get painful I guess
10:44:23 <lowasser> generic, perhaps, but polymorphism is expensive
10:44:32 <lowasser> performance-wise
10:44:37 <quicksilver> artzz: not really, if your editor supports it.
10:44:39 <mxc> could specialize teh common cases
10:44:44 <quicksilver> artzz: alternative, put a newline before 'det' as well
10:44:46 <Cale> artzz: all the equations inside the let should start on the same column
10:44:51 <artzz> quicksilver: which editor would you recommend. oh i see
10:44:52 <det> quicksilver, stop saying my name :p
10:44:53 <quicksilver> artzz: (and just indent 'det' and 'aa' to the same tabstop)
10:45:20 <artzz> ok that's a good advice
10:45:20 <Cale> (but putting newline after let is a terrible-looking way to write it)
10:45:23 <quicksilver> artzz: I would recommend emacs.
10:45:25 <artzz> thanks! I'll keep on my haskell tut
10:45:25 <lowasser> specializing is useful, but not necessarily as effective as we'd always like
10:45:31 <quicksilver> I disagree with Cale. I don't think it's terrible looking.
10:45:35 <Cale> Just make sure that det and aa start in the same column
10:45:37 <quicksilver> (although it's not the way I write personally)
10:45:40 <elspru> so any ideas with the address translation?
10:45:49 <elspru> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24022#a24022
10:45:58 <elspru> or suggestions
10:46:08 <lowasser> I prefer the less cluttered namespace, with methods implemented directly
10:46:37 <lowasser> and being able to depend on good performance without worrying about the polymorphism overhead
10:47:11 <mxc> fair points
10:47:15 <lowasser> honestly, there's very little I'd change about the core Haskell language or base, even if I could wish for changes
10:47:28 <mxc> on another note, is the if-then-else syntax different in 6.12 from 6.10?
10:47:38 <Cale> There's a lot that I'd change about the base package if I could get my hands on it :)
10:47:39 <mxc> having a syntax error on 612 on something that compiles fine on 610
10:47:49 <mreh> Cale: I'm tracing out the length of the list of elements, it gets down to 0 and goes back to 400,000
10:48:07 <lowasser> mxc: http://www.haskell.org/ghc/docs/latest/html/users_guide/release-6-12-1.html#id2887987
10:48:26 <lowasser> doesn't look like it
10:48:36 <mxc> yeah was reading that
10:48:40 <mxc> trying to figure this one out
10:48:48 <Saizan> there this DoAndIfThenElse
10:48:55 <Saizan> not sure if it's new in ghc-6.12
10:49:14 <Saizan> you might try with {-# LANGUAGE NoDoAndIfThenElse #-}
10:49:16 <benmachine> I think there was a comment on that that GHC had already been doing it for a while
10:49:27 <fax> I would also kill most of the language keywords mysfel
10:49:30 <elspru> i'm pretty sure the problem is with one of the two functions at http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24022#a24022
10:49:38 <fax> I hate not being able to call my variable 'type' for example
10:49:46 <elspru> either the result of findAddress
10:50:09 <lowasser> I can get over language keywords, given that we're going to need *something8
10:50:13 <elspru> or the logic of nextTranslation in addressTranslate'
10:50:25 <lowasser> like, in Java, you can't use class
10:50:35 <quicksilver> DoAndIfThenElse--
10:50:36 <Cale> I don't have problems with the Haskell syntax, for the most part.
10:50:41 <lowasser> and then when I'm writing a system to schedule an educational program, guess what word I want to use?
10:50:57 * fax has written lots of programs that should have variables called 'type'
10:50:58 <lowasser> (true story)
10:51:00 <Cale> I hate the DoAndIfThenElse thing, though, and I wish the module path separator was different
10:51:01 <lowasser> me too!
10:51:21 <lowasser> I just launched a Template Haskell package that automatically infers the kind of a given type
10:51:26 <lowasser> but I can get over having to use "typ"
10:51:48 <lowasser> in exchange for having a nice, short syntax for type aliasing
10:51:57 <mreh> Cale: it was training a whole perceptron for each point in the test set
10:52:14 <lowasser> and we all know "alias" would also be a nice variable name
10:52:20 <lowasser> in lots of cases
10:53:10 <Saizan> bah, just do dependent types, then type aliases are just definitions like the others
10:53:18 <benmachine> how about ~ as a module separator
10:53:35 <benmachine> I was thinking the other day about how it's odd to have sugar for lazy patterns since they're quite rare in practice
10:53:37 <Cale> benmachine: I wouldn't mind that as much.
10:53:47 <lowasser> it's not just that it's "sugar"
10:53:50 <benmachine> and can be replicated with let/where
10:53:55 <Cale> Though yeah, it does take away the lazy pattern syntax.
10:53:57 <lowasser> with difficulty
10:54:06 <benmachine> wait hmm
10:54:08 <Cale> You do need some way to do lazy patterns though.
10:54:10 <lowasser> like, if I want to lazy match one particular field inside a strict ccase
10:54:12 <Saizan> difficulty?
10:54:28 <benmachine> doing a let pattern is slightly different from a lazy pattern
10:54:33 <lowasser> yes
10:54:38 <Saizan> benmachine: really?
10:54:42 <benmachine> Saizan: I think so
10:54:44 <byorgey> mxc: what's the syntax error?
10:54:49 <lowasser> and you can also use lazy patterns inside of case patterns
10:54:57 <Cale> Pattern bindings automatically have ~ inserted in front of the pattern you write.
10:55:00 <Saizan> lowasser: tha's not a problem
10:55:12 <Cale> That includes pattern bindings inside let, and at the top level
10:55:25 <lowasser> Saizan: it becomes much more awkward to do that if you don't have the ~ syntax
10:55:36 <benmachine> ohh, yeah silly me
10:55:42 <benmachine> I was looking at a function binding in a let
10:55:46 <benmachine> so that's not really a let-pattern
10:55:52 <Saizan> case x of Foo y -> let Bar z = y in ...; ...
10:55:59 <benmachine> lowasser: not much more awkward
10:56:02 <lowasser> hold on
10:56:10 <benmachine> noting in particular that a nested lazy pattern makes no sense
10:56:17 <lowasser> case x of Foo True ~(x:xs) 16 -> ..
10:56:27 <Cale> benmachine: Huh?
10:56:37 <Cale> benmachine: Nested lazy patterns make sense
10:56:39 <benmachine> case x of Foo True ys 16 -> let (x:xs) = ys in ...
10:56:43 <lowasser> if we have a complicated set of nesting strict and lazy pattern matches, though
10:56:49 <benmachine> Cale: how? the outermost one always succeeds
10:56:57 <benmachine> and then the rest is lazy anyway
10:57:16 <Cale> benmachine: right, but then when the inner pattern is matched might also need to be deferred
10:57:19 <lowasser> case x of Foo True ~(True:xs) 16
10:57:20 <lowasser> yep
10:57:31 <Cale> benmachine: Consider something like ~(x,~(y,z))
10:58:01 <lowasser> or even better
10:58:12 <benmachine> Cale: say I have case x of ~(a,~(b,c)) is that different from let (a,(b,c)) = x in
10:58:12 <lowasser> ~(x, (True, ~(y:ys))
10:58:19 <Cale> yes
10:58:26 <artzz> I have another (probably dumb) question: I can do x = 4 in a program loaded with ghci but not in the interpreter, why is that?
10:58:33 <benmachine> oh, this surprises me
10:58:39 <lowasser> heh
10:58:41 <Cale> But it's not different from  let (a,y) = x; (b,c) = y in ...
10:58:43 <geheimdienst> artzz: try "let"
10:58:47 <geheimdienst> let x = 4
10:59:22 <Cale> artzz: GHCi wants expressions, rather than declarations
10:59:22 <benmachine> artzz: the syntax of what you are allowed in the interpreter is a bit like you are in a giant IO do-block
10:59:41 <artzz> ohh i see
10:59:45 <Cale> artzz: Usually the way you do things is write all your declarations in a file, load it up into ghci, and then simply type :r whenever you save your file.
10:59:51 <Cale> (good to keep two windows open)
10:59:53 <byorgey> artzz: in the interpreter you can say   let x = 4
10:59:59 <artzz> good
10:59:59 <benmachine> except if you type in an expression that is not IO it is automatically printed
11:00:06 <artzz> yes, good
11:00:07 <artzz> great, thanks!
11:00:53 <benmachine> > let (a, (b, c)) = (1, undefined) in a
11:00:55 <lambdabot>   * Exception: Prelude.undefined
11:01:04 <benmachine> how about that.
11:01:09 <benmachine> > let (a, ~(b, c)) = (1, undefined) in a
11:01:10 <lambdabot>   1
11:01:24 <benmachine> well ok then lazy patterns are allowed to stay
11:01:30 <benmachine> although I still don't think they're that common
11:02:33 <mxc> byorgey: seems to be from calling Data.Array.IArray.// inside a record update
11:03:24 <mxc> so, rec { arrayField = arrayField rec } is fine but rec {arrayField = arrayField rec // undefined } causes a parse error under 6.12
11:03:28 <mxc> its fine under 6.10
11:03:38 <zygoloid> > let (a, Nothing) = (1, Just 42) in a
11:03:39 <lambdabot>   * Exception: <interactive>:1:149-175: Irrefutable pattern failed for patter...
11:05:36 <Saizan> mxc: sounds like a bug
11:06:28 <Veinor> zygoloid: what did you expect to happen? @_@
11:06:41 <Saizan> > let (a, ~Nothing) = (1, Just 42) in a
11:06:42 <lambdabot>   1
11:08:03 <lowasser> idk if someone answered this before
11:08:24 <lowasser> what is the best way to post Haddock documentation for a pending patch?
11:08:58 <deadguys> hi all.  is darcs rollback on the ghc repo a bad idea?  I went for it, and it blew up.  Now my repo's locked... is it safe to rm _darcs/lock?
11:09:17 <Cale> lowasser: The web?
11:09:18 <lowasser> deadguys: are you sure rollback is what you want?
11:09:54 <lowasser> Cale: I was wondering if there was an established place to host things like that that aren't necessarily stable
11:10:10 <hydo> Is there a shortcut for when you want to patten match against an IO value or is there a "you should really do this" reason for having to say x <- io_action ; case x of?
11:10:12 <deadguys> lowasser: it seemed like what I wanted from what I read
11:10:23 <lowasser> rollback records the reversal of a patch
11:10:32 <lowasser> unrecord un-records a patch you made
11:10:50 <lowasser> and then you can revert if you want to go back to the way things were before, because you want to abandon a patch you tried to make
11:11:04 <deadguys> i still want it to be recorded.  basically just wanted to go back in time for a minute
11:11:06 <Cale> hydo: If you're pattern matching on *the result of* an IO value in the same way a lot, then you can write a function to do it
11:11:08 <lowasser> that's usually what I actually want
11:11:12 <lowasser> hmm yeah I'm clueless then
11:11:23 <lowasser> unless you want to, like
11:11:29 <lowasser> send the patch so it's stored elsewhere
11:11:37 <lowasser> and then reapply it when you want to move forward again
11:12:09 <lowasser> Cale; I don't currently have a web server handy to host random documentation on
11:12:23 <hydo> Cale: ok, I thought about doing that but it's one of those things that I do a LOT... so I assumed that there was a more elegant way to, yes, match against the result of an IO value.
11:12:26 <Cale> lowasser: maybe you could get an account on code.haskell.org
11:12:41 <lowasser> aha!  useful answer this
11:12:44 <zygoloid> Veinor: exactly that :)
11:13:36 <Cale> hydo: Yeah, there's no magical syntax. You can put a pattern match on the left side of the <- but only if there's a single pattern to match
11:14:04 <hydo> Cale: ok, thanks for the clarification!
11:14:05 <zygoloid> deadguys: if you have the patch in another repo, you could unpull it
11:14:27 <zygoloid> (if you don't have it stored externally it'll be gone for good though i think)
11:14:46 <Cale> hydo: People have suggested syntaxes like  case (<- foo) of ... or something, but none of that has been implemented
11:15:13 <lowasser> foo >>= \ f -> case f of....
11:15:23 <c_wraith> I'd be happy with pointless case ...  foo >>= case of ...
11:15:33 <lowasser> yeah, that'd be a nice syntax
11:15:38 <Cale> yeah, that's another possibility
11:16:07 <lowasser> foo -> case of... might be better
11:16:30 <Cale> actually, that syntax was almost supported at one point
11:16:42 <Cale> For a while, you were allowed to write x -> v
11:16:45 <Cale> in place of v <- x
11:16:53 <lowasser> because "foo >>= case of" has special syntax with ">>=", which I don't like
11:16:56 <Cale> But I think they removed that for whatever reason
11:17:04 <Cale> hm?
11:17:05 <lowasser> I like parsing ">>=" as normal Haskell
11:17:09 <c_wraith> lowasser: no it doesn't.
11:17:14 <Cale> Oh, that wouldn't be special syntax with >>=
11:17:16 <benmachine> lowasser: how is that special with >>=
11:17:19 <zygoloid> the special thing is 'case of'
11:17:26 <lowasser> no, but
11:17:27 <Cale> (case of ...) would be equivalent to (\x -> case x of ...)
11:17:27 <benmachine> case of = \x -> case x of
11:17:28 <lowasser> how would we handle
11:17:31 <zygoloid> i think there's a haskell' proposal LambdaCase for that
11:17:33 <lowasser> f case of...
11:17:43 <lowasser> where f would be (foo >>=)
11:17:49 <benmachine> f case of = f (\x -> case x of ...)
11:17:50 <lowasser> like, we'd have to have a syntax for that for all f
11:17:55 <Cale> hm?
11:18:02 <Cale> f (case of ...) would be fine
11:18:05 <c_wraith> why do you think this is special syntax?
11:18:07 <zygoloid> > length case True of _ -> [1,2,3]
11:18:08 <lambdabot>   <no location info>: parse error on input `case'
11:18:13 <lowasser> f (case of ...) is a really awkward syntax
11:18:13 <zygoloid> ^^ currently needs parens
11:18:18 <lowasser> and doesn't really tell me what's actually going on
11:18:29 <zygoloid> > join replicate =<< case True of _ -> [1,2,3]
11:18:31 <lambdabot>   [1,2,2,3,3,3]
11:18:32 <zygoloid> ^^ currently does not
11:18:39 <Cale> lowasser: Basically, omitting the scrutinee of any case expression results in a lambda with a fresh variable that becomes the scrutinee
11:18:49 <lowasser> hrrrm
11:18:49 <benmachine> the interaction of infix ops with syntax is strange
11:18:51 <mxc> seems to be related to infix notation and the // operator
11:18:53 <Zao> I've run into the \x -> case x of ...  pattern a lot.
11:18:54 <lowasser> I'm trying to decide if I'm happy this
11:18:56 <lowasser> with this
11:18:56 <Zao> Annoyed me greatly,
11:19:08 <mercury^> What's wrong with it?
11:19:11 <zygoloid> it might be nicer to extend lambdas to deal with multiple patterns rather than introduce a new form of case
11:19:11 <lowasser> I could be convinced
11:19:14 <mxc> GHC 6.10 is fine with import Data.Array.IArray ((//)) but 6.12 calls that a parse error
11:19:17 <Cale> It's concordant with the operator section syntax
11:19:22 <Cale> and currying in general :)
11:19:27 <lowasser> hmm
11:19:29 <Cale> leave something out to make it a function parameter
11:19:31 <Zao> Let's introduce the keyword caseof.
11:19:51 <lowasser> so cale, you're suggesting something totally general and non-monadic
11:19:52 <benmachine> mxc: what, with just that line alone?
11:19:53 <Twey> Let's have first-class patterns and make it a function >.>
11:19:57 <Cale> lowasser: yeah
11:19:58 <zygoloid> if it were "match <...> against <expr>" rather than "case <expr> in <...>" i'd agree with the currying argument
11:20:04 <mxc> @benmachine yes
11:20:05 <lambdabot> Unknown command, try @list
11:20:10 <Cale> lowasser: Has nothing at all to do with monads, it would just work well in this particular case.
11:20:10 <lowasser> okay, I could deal with this
11:20:10 <mxc> benmachine : yes
11:20:15 <benmachine> mxc: worksforme, are you accidentally using cpp?
11:20:20 <Zao> flip case
11:20:23 <mxc> ah
11:20:25 <mxc> yes
11:20:26 <zygoloid> haha
11:20:28 <lowasser> hahahaha, flip case
11:20:30 <deadguys> is there a way I can save my patches to a file?
11:20:36 <lowasser> darcs send -o filename
11:20:47 <lowasser> "send" is sort of a misnomer
11:20:54 <lowasser> it defaults to sending by email, but send -o just outputs a file
11:21:04 <deadguys> thanks
11:21:10 <zygoloid> flip (flip case of)
11:21:59 <mercury^> I'm not sure it is a good idea to make "case of" behave more like a function...
11:22:24 <lowasser> maybe a new reserved word
11:22:31 <lowasser> "casefunc" or something
11:22:44 <benmachine> argh, HSE's prettyprinter fails me again
11:22:55 <mercury^> I think there is no problem at the moment. :)
11:22:55 <lowasser> "caseof" isn't really suggestive of what we're outlining here
11:23:07 <benmachine> seems to assume + is associative
11:23:10 <lowasser> I'm inclined to agree, but it's a cute syntactic shortcut to have
11:23:39 <lowasser> Cale seems to want a whole bunch of new GHC extensions today =P
11:23:56 <benmachine> seems to get associativities wrong in general
11:24:01 <mercury^> This would save little code in rare cases => not worth it.
11:24:17 <lowasser> probably true
11:24:26 <lowasser> the savings would be, what, five or six characters per occurrence?
11:24:28 <benmachine> not that rare
11:24:38 <benmachine> code admittedly little
11:24:46 <mercury^> benmachine: I doubt you see it more than once every 100 lines.
11:24:52 <benmachine> but I am compelled by the "it's cute" argument :P
11:24:53 <mxc> benmachine - i think you get a prize.  its not accidental since cpphs wasn't working for me at all, but i forgot that w/out -traditional cpp would kill anything after a //
11:25:01 <benmachine> mercury^: I doubt you see lazy patterns that often
11:25:09 <lowasser> I do!
11:25:17 <lowasser> also, the difference between this and lazy patterns
11:25:17 <mercury^> But lazy patterns are necessary.
11:25:21 <benmachine> mxc: thx
11:25:32 <benmachine> mercury^: no they are not you can use nested lets
11:25:42 <lowasser> I thought we just went over this
11:25:56 <benmachine> yes hence the example being to hand
11:25:58 <lowasser> to say nothing of the fact that nested lets add considerably more code than
11:26:24 <lowasser> replacing "\x -> case x of" with "casefunc"
11:26:30 <benmachine> I was wrong but not completely wrong
11:26:51 <lowasser> moreover, lazy syntax makes lazy patterns much more readable than the nested let approach
11:27:03 <lowasser> whereas "\ x -> case x of" is pretty readable
11:27:08 <benmachine> well, one could argue the case syntax makes that more readable
11:27:34 <benmachine> \x -> case x of is clutter, and may require more parentheses than you'd like
11:27:35 <c_wraith> I just don't like introducing a name if it's only used once, right where it's introduced, and adds no clarity
11:27:36 <mercury^> The complexity of "\x -> case x of" is constant, the nested let patterns scale.
11:27:40 <lowasser> yes.
11:28:05 <lowasser> I agree with c_wraith, in general, but it's just not that worth it
11:28:15 <Cale> > let in let in let in 5
11:28:16 <lambdabot>   5
11:28:23 <benmachine> mercury^: scale with the number of nested lazy patterns; I challenge you to find me anywhere where more than two layers were actually used in a real expression
11:28:46 <lowasser> I'm not sure that's the real issue
11:28:48 <Cale> lowasser: Actually the case of thing isn't my idea
11:29:04 <lowasser> I want my language to be able to handle expressions that would never come up in practice gracefully
11:29:07 <mercury^> This discussion is already using up more resources than the change would save.
11:29:14 <lowasser> Truth!
11:29:37 <benmachine> discussion is cheap
11:29:45 <benmachine> so are bytes but whatever
11:29:57 <lowasser> Also, lazy patterns are Haskell 98.  I'm not a fan of deleting H98 functionality.
11:30:23 <benmachine> go tell that to the NoNPlusK people :P
11:30:27 <dolio> Lazy patterns are the definition of let patterns, are they not?
11:30:34 <lowasser> they're part of it, but not entirely
11:30:52 <lowasser> @ben: I'm fine with letting people opt into deleting functionality
11:30:52 <lambdabot> Unknown command, try @list
11:30:53 <benmachine> dolio: let patterns are lazy, but you could just as well say lazy patterns are let, if you see what I mean :P
11:30:55 <lowasser> oops
11:31:14 <dino-> What does it mean if I have two identical lines in ghc-pkg list output?
11:31:16 <lowasser> but I'm not willing to delete that sort of functionality for everybody
11:31:24 <dino-> Right down to the version number. In this case time-1.1.4
11:31:38 <lowasser> dino: is one registered as global and one as local?
11:32:01 <benmachine> lowasser: but anyway, I brought them up the second time as something that was rarely used but still existed, with the idea that even though case of might be rarely used that doesn't mean it shouldn't exist
11:32:29 <dino-> lowasser: No, all global. Doing ghc-pkg list --user is totally empty.
11:32:36 <lowasser> dino: damn, no clue, then
11:32:46 <dino-> It's like shouldn't have been permitted to happen!
11:32:48 <lowasser> although you might try unregistering once and seeing which one stays, and what breaks =P
11:33:05 <benmachine> heh
11:33:06 <dino-> Trying to unreg warns me that my entire universe will be broken. :)
11:33:10 <lowasser> =(
11:33:11 <benmachine> hide?
11:33:15 <lowasser> anyway
11:33:24 <Saizan> dino-: the id is probably different
11:33:27 <dino-> This is in a VM, so I'll just snapshot and do it anyway.
11:33:29 <lowasser> adding a new language construct for so little payoff seems a bit gratuitous
11:33:51 <benmachine> lowasser: maybe a bit.
11:34:04 <lowasser> the payoff being, maybe five saved characters, and slightly more pointfreeness =P
11:34:19 <dino-> Saizan: ah, --verbose=2
11:34:26 <dino-> Yes, they are different
11:34:32 <Saizan> or "ghc-pkg field time id"
11:34:35 <lowasser> ask what happens
11:34:43 <lowasser> if you unregister the first, and if you unregister the second
11:34:51 <lowasser> maybe one of them will break everything if you unregister it
11:34:55 <lowasser> and the other one will break nothing
11:35:09 * benmachine tries to remember which way around haskell-src-exts is supposed to roundtrip
11:35:31 <Saizan> pprint . parse = id
11:35:36 <lowasser> I really need to learn how to use haskell-src-exts
11:35:59 <Saizan> parse . pprint = id is almost always required
11:36:12 <Saizan> s/required/guaranteed/
11:36:26 <mercury^> The other direction is only guaranteed up to natural equivalence.
11:36:45 <dino-> It removed them both
11:37:10 <dino-> But this is rapidly becoming an #arch-haskell issue, trying to reinstall from the AUR is forcing reinstallation of ghc 6.12.1
11:37:17 <benmachine> Saizan: in the latter, am I to assume it only applies where the Exp I give it is the result of a successful parse?
11:37:23 <dino-> Which is how I got here to all ghc-pkg dumped and broken in the first place.
11:37:47 <mercury^> :t parse
11:37:48 <benmachine> i.e. not for Exps that don't correspond to actual expressions (lambdas with no patterns, etc)
11:37:48 <lambdabot> Not in scope: `parse'
11:38:23 <mercury^> Why are such Exps even allowed?
11:38:38 <benmachine> because you can't statically enforce absolutely everything
11:38:57 <mercury^> Could at least dynamically enforce it.
11:39:13 <benmachine> well then you still don't get a roundtrip because you get an error thrown :P
11:40:49 <mercury^> But apart from that: what makes it so hard to make them statically correct?
11:41:07 <benmachine> well, for example, there is a Symbol constructor
11:41:12 <benmachine> Symbol String
11:41:18 <Saizan> well, no idea on those
11:41:22 <benmachine> if I make a Symbol "bleep", that isn't a valid symbol
11:41:46 <benmachine> but it's pretty hard to stop me from doing so
11:42:15 <mercury^> Seems as if "Symbol String" is not what is wanted there then.
11:42:43 <benmachine> Symbol Magictypewhichonlyallowsyoutoinsertcertainsortsofcharacters
11:43:12 <benmachine> well, such a type could exist I guess, although good luck also preventing Symbol ",", Symbol "--" and so forth
11:43:20 <benmachine> but it'd then be a right pain to manipulate
11:44:15 <mercury^> If you only want parse . pprint = id, you don't need any character strings at all.
11:45:19 <benmachine> hmm
11:45:32 <mercury^> But of course we want something like that...
11:45:46 <mercury^> After all pprint . parse should be comprehensible.
11:46:49 <benmachine> what's the default fixity?
11:46:54 <mercury^> 5 iirc
11:46:57 <benmachine> r?
11:47:08 <mercury^> don't remember
11:47:13 <benmachine> no that doesn't help anyway
11:47:36 <benmachine> I think I have found a valid non-round-tripping expression
11:48:36 <benmachine> hmm no I haven't exactly
11:49:14 <mercury^> Err, what the fuck am I doing here? Have an exam tomorrow...
11:49:16 <mercury^> bye :)
11:49:21 <benmachine> haha
11:49:25 <benmachine> good luck
11:49:37 <benmachine> ghci> prettyPrint <$> parseExp "1 + 2 + 3"
11:49:37 <benmachine> ParseOk "(1 + 2) + 3"
11:49:46 <benmachine> that's *kind* of not identity
11:50:05 <xerox> modulo associativity it's all good
11:50:57 <benmachine> hmm, it behaves differently with ^
11:51:01 <benmachine> doesn't bracket it then
11:51:13 <benmachine> which is odd
11:51:50 <xerox> ^ isn't associative
11:52:09 <benmachine> well, technically no Haskell operator is associative
11:52:14 <xerox> > (2^2)^2 == 2^(2^2)
11:52:15 <lambdabot>   True
11:52:18 <benmachine> at least, not according to a parser
11:52:22 <benmachine> haha, unlucky :P
11:52:24 <xerox> (eh eh)
11:52:31 <monochrom> hehehe
11:52:51 <zygoloid> @hoogle |
11:52:52 <lambdabot> Text.Parsec.Prim class Monad m => | (Stream s m t) (s -> t)
11:52:52 <lambdabot> Control.Monad.Error.Class class Monad m => | (MonadError e m) (m -> e)
11:52:52 <lambdabot> Control.Monad.RWS.Class class (Monoid w, MonadReader r m, MonadWriter w m, MonadState s m) => | (MonadRWS r w s m) (m -> r)
11:53:10 <zygoloid> @hoogle .^.
11:53:10 <lambdabot> No results found
11:53:11 <benmachine> hah
11:53:14 <jmcarthur> :t (^)
11:53:16 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
11:53:25 <benmachine> the odd thing is that it parenthises in the case of + but not in the case of ^
11:53:50 <benmachine> it seems that prettyPrint is designed for an observer that doesn't know fixities, but parseExp does know them
11:53:50 <jmcarthur> @check \a b (c :: Integer) -> (a^b)^c == a^(b^c)
11:53:50 <lambdabot>   Parse error in pattern at "->" (column 21)
11:54:15 <zygoloid> > 2^(3^5) == (2^3)^5
11:54:16 <lambdabot>   False
11:54:17 <jmcarthur> @check \a b c -> (a^b)^c == (a^(b^c) :: Integer)
11:54:18 <lambdabot>   "Falsifiable, after 1 tests:\n0\n0\n0\n"
11:54:27 <jmcarthur> o_O
11:54:29 <zygoloid> > (0^0)^0
11:54:30 <monochrom> hehe 0 0 0
11:54:31 <lambdabot>   1
11:54:35 <zygoloid> > 0^(0^0)
11:54:36 <lambdabot>   0
11:54:38 <zygoloid> haha
11:54:39 <jmcarthur> nice
11:54:50 <monochrom> way to go for minimal counterexamples
11:54:50 <benmachine> depends on what you think of 0^0 I guess
11:54:59 <merijn> benmachine: Not really.
11:55:07 <monochrom> 0**0 is the only dispute
11:55:09 <Saizan> benmachine: i think you've to use this to get the roundtrip http://hackage.haskell.org/packages/archive/haskell-src-exts/1.8.2/doc/html/Language-Haskell-Exts-Annotated-ExactPrint.html
11:55:14 <jmcarthur> > 0**0
11:55:15 <lambdabot>   1.0
11:55:18 <merijn> x^0 = 1 according to all my books
11:55:24 <benmachine> Saizan: right, hmm
11:55:36 <benmachine> merijn: 0^x = 0 though :P
11:55:43 <jmcarthur> umm
11:55:45 <monochrom> Do you know why?
11:56:05 <zygoloid> benmachine: 0^x = 0 only for x > 0
11:56:05 <benmachine> why 0^x = 0?
11:56:07 <merijn> benmachine: 0^x = 0 for x > 0, then
11:56:07 <monochrom> It is because x^y is for natural number y only. No trouble there.
11:56:13 <merijn> s/then/yes
11:56:23 <benmachine> ah
11:56:38 <monochrom> x**y though is a real-analysis thing and may have to be tied to ln and exp, that's more troublesome.
11:56:44 <benmachine> I suppose there is little dispute that 0^-1 is unpleasant
11:57:17 <benmachine> monochrom: by x^y I just meant x superscript y, but I see your point
11:57:24 <merijn> benmachine: In my math books powers are defined recursively as "x^0 = 1" and "x^y = x * (x^(y-1))"
11:57:36 <jmcarthur> benmachine: 1 = a^n/a^n = a^(n-n) = a^0
11:57:45 <monochrom> But of course if you @check you're using @check's ^ not your ^
11:57:45 <merijn> In which case 0^0 would be 1 and 0^1 would thus be 0
11:58:31 <benmachine> merijn: in my maths course x^y wasn't formally defined at all until it was exp(y*log x)
11:58:39 <merijn> Which is perhaps not logical, but consistent.
11:58:53 <jmcarthur> the proof i gave is logical
11:58:56 <benmachine> I think at school it was defined as "what your calculator says when you put those in"
11:58:59 <monochrom> In your math books, space is addition and space is multiplication. Your math books are bunk anyway.
11:59:13 <jmcarthur> try it in your calculator :P
11:59:37 <merijn> jmcarthur: Oh yeah, I glossed over it. That's a nice one too
11:59:47 <benmachine> jmcarthur: it is one logical way of doing it, but not necessarily the only one
11:59:56 <jmcarthur> benmachine: no, but one proof is sufficient
12:00:19 <benmachine> jmcarthur: yes, except that you are depending on your definition of ^
12:00:26 <copumpkin> omg
12:00:32 <benmachine> and there are multiple possible such definitions which agree almost everywhere
12:00:34 <benmachine> hi copumpkin
12:00:37 <copumpkin> ohai
12:00:37 <zygoloid> benmachine: we were taught, x^y for y an integer, then for y a rational, then for y a real via (i think) limits, then we were taught logs
12:00:57 <benmachine> zygoloid: oh, we skipped the third step
12:01:03 <zygoloid> although we didn't know about limits back then, so it was a bit handwavey
12:01:05 <jmcarthur> benmachine: i don't really know of any definitions of ^ for which x^0 /= 1
12:01:22 <monochrom> "1 = a^n/a^n" fails when a^n=0.
12:01:32 <benmachine> yes
12:01:34 <zygoloid> > let a ^ b = "hello jmcarthur" in x^0
12:01:36 <lambdabot>   "hello jmcarthur"
12:01:44 * benmachine giggles
12:01:51 <jmcarthur> *sigh*
12:01:59 <zygoloid> sorry ;)
12:02:16 <monochrom> I trust that you also heard of the very logical proof for 0=1.
12:02:25 <sm> morning all. Is there a ghc/language option to help 6.10 to derive instance X String from instance X Char and instance X [a] .. ? 6.12 works it out just fine
12:02:28 <Twey> Zero-division?
12:02:30 <mrshoe> jmcarthur: ^ in C is bitwise xor, right? so x^0 != 1
12:02:31 <zygoloid> (^) as cross product is another case where ^0 /= const 1
12:02:44 <benmachine> oh this is a bit silly now
12:02:45 <twink> zygoloid's method is what I remember too
12:02:51 <monochrom> Yeah, zero-division did it. Same technique as 1 = a^n/a^n
12:02:52 <benmachine> I revoke my original statement, whatever it was >_>
12:02:52 <jmcarthur> these are just bindings. come on
12:03:02 <Twey> x^0 = x in that caseâ¦
12:03:03 <jmcarthur> monochrom: you have a point
12:03:03 <sm> the specific case is deriving instance ToSElem String from http://hackage.haskell.org/packages/archive/HStringTemplate/0.6.2/doc/html/Text-StringTemplate-Classes.html#t%3AToSElem , 6.10 is failing
12:03:58 <benmachine> can we go back to HSE's prettyprinter and why it is annoying
12:04:18 <copumpkin> preflex: seen kmc
12:04:18 <preflex>  kmc was last seen on #haskell 8 hours, 37 minutes and 6 seconds ago, saying: yeah, just paste it into a file
12:04:21 <Saizan> sm: so ":t toSElem :: String -> SElem String" gives an error with 6.10 ?
12:04:48 <Twey> (-2)â° = 1 is a bit crazy
12:05:12 <Saizan> benmachine: why it is annoying?
12:05:22 <jmcarthur> copumpkin: i give up on vector-static, btw. it seems to have a small payoff:effort ratio
12:05:30 <copumpkin> jmcarthur: I agree :)
12:05:44 <copumpkin> jmcarthur: at least it's validation that I'm not just a quitter
12:05:47 <monochrom> perhaps a bug in the prettyprinter. an assumption that all binary operators are right-associative. you give it a left-associative tree, and it feels like parenthesizing.
12:06:04 <jmcarthur> heh
12:06:04 <benmachine> Saizan: it's not fair of me to blame it really, but it doesn't insert parentheses everywhere I want them
12:06:14 <zygoloid> Twey: (-2)^0 = (-2)^1 * (-2)^(-1) = -2 * -1/2 = 1
12:06:47 <benmachine> monochrom: my problem is that I give it InfixApp a (InfixApp b (op +) c) and it prints "a + b + c"
12:06:54 <jmcarthur> > -2 ^ (1/2)
12:06:55 <lambdabot>   Ambiguous type variable `t' in the constraints:
12:06:55 <lambdabot>    `GHC.Real.Fractional t'
12:06:55 <lambdabot> ...
12:07:00 <sm> Saizan: yes it does, http://gist.github.com/334367
12:07:05 <zygoloid> > (-2)^^(1/2)
12:07:06 <lambdabot>   Ambiguous type variable `t' in the constraints:
12:07:06 <lambdabot>    `GHC.Real.Fractional t'
12:07:07 <lambdabot> ...
12:07:08 <monochrom> I guessed correctly then.
12:07:09 <benmachine> but + is infixl so that parses as InfixApp (InfixApp a + b) + c
12:07:12 <jmcarthur> > -2 ** (1/2)
12:07:13 <lambdabot>   -1.4142135623730951
12:07:16 <fax> zygoloid, 0^0 = 0^1 * 0^-1 = 0 * 1/0 = 1??
12:07:19 <jmcarthur> > (-2) ** (1/2)
12:07:23 <lambdabot>   NaN
12:07:24 <Twey> zygoloid: I guess so
12:07:24 <benmachine> monochrom: more or less
12:07:37 <jmcarthur> > (-2) ** (-1/2)
12:07:38 <lambdabot>   NaN
12:07:39 <jmcarthur> woops
12:07:47 <jmcarthur> oh (*)
12:07:48 <benmachine> it doesn't assume all operators are infixl
12:07:51 <Twey> Hm, I suppose that's not so crazy as I thought, actually.
12:07:51 <zygoloid> fax: *** ERROR DIVIDE BY ZERO *** INSERT MORE CHEESE ***
12:07:53 <Saizan> sm: i think the instances are exported from elsewhere
12:08:04 * Twey reinstalls universe and reboots.
12:08:05 * copumpkin inserts more cheese into zygoloid 
12:08:27 <twink> > (-2 :+ 0) ** (-1/2)
12:08:28 <lambdabot>   Precedence parsing error
12:08:28 <lambdabot>      cannot mix prefix `-' [infixl 6] and `Data.Co...
12:08:29 <jmcarthur> *** ERROR DIVIDE BY ZERO *** FEED ME A STRAY CAT ***
12:08:30 <benmachine> but it doesn't parenthise your expressions when they get it wrong
12:08:34 <monochrom> Once upon a time, a theorem prover (an old version of HOL) declared all binary operators right-associative.
12:09:06 <twink> > ((-2) :+ 0) ** (-1/2)
12:09:07 <lambdabot>   4.329780281177467e-17 :+ (-0.7071067811865476)
12:09:25 <sm> Saizan: I'm guessing I need one of ExistentialQuantification, FlexibleInstances, StandaloneDeriving, GeneralizedNewtypeDeriving, TypeSynonymInstances
12:09:33 <Saizan> sm: what happens if you ":m + Text.StringTemplate" ?
12:09:33 <jmcarthur> twink: i had misread the operator. it was supposed to be just (*)
12:09:43 <Saizan> sm: i don't think so.
12:09:59 <sm> Saizan: you're right! that makes it work
12:10:27 <sm> could that be considered a weakness in stringtemplate packaging, or just something haskellers should figure out ?
12:10:28 <Saizan> import Text.StringTemplate.Instances() -- from Text.StringTemplate
12:10:49 <Saizan> i consider it a problem in haddock
12:11:05 <monochrom> benmachine: There is no "wrong" in that sense. parser and prettyprinter don't talk to each other. parser makes one assumption about what you mean when you don't have enough parentheses. prettyprinter makes one assumption about where it can omit parentheses. Nothing says they make the same assumption. You put them together and you feel confused. You consider them individually and it is all explanable.
12:11:49 <benmachine> monochrom: but I am taking an expression, pretty printing it and parsing it and getting a different expression
12:12:09 <monochrom> Yes, because of what I just said.
12:12:09 <benmachine> hence my original question was which way round the roundtrip was supposed to go
12:12:27 <jmcarthur> i wish parsers and printers could be expressed with the same code. are there any libraries that manage that?
12:12:28 <monochrom> Well if they make contradicting assumptions, there is not round trip.
12:12:30 <benmachine> but the roundtrip probably isn't even relevant because my expression can't be the result of a parse anyway
12:12:39 <benmachine> because yes
12:12:40 <jmcarthur> i don't even know what restrictions would be necessary
12:12:44 <benmachine> so it's all my fault
12:12:47 <benmachine> but it's still annoying :P
12:12:55 <jmcarthur> presumably monadic parsing is out
12:13:00 <sm> so the instances are actually defined in.. I see what's going on. Thanks a lot!
12:14:57 <benmachine> ugh I don't want to have to consider fixities in my code
12:15:00 <monochrom> You should modify the prettyprinter. Tell it to respect user-provided fixity and associativity information.
12:15:05 <copumpkin> jmcarthur: that would be awesome, and I think you'd need applicative
12:15:23 <monochrom> Or else just fully parenthesize everything.
12:15:24 <copumpkin> and nothing more, that is
12:15:31 <monochrom> Or else just use XML.
12:15:39 <benmachine> xml whee
12:15:54 * copumpkin throws up
12:16:45 <benmachine> ah, the parser lets you specify fixity information
12:16:58 <monochrom> My teachers once told us a common technique in British politics. "So you want to propose solution X to the people. But they want to have choice. So propose X,Y,Z, where Y and Z really suck, and let them choose."
12:17:18 <benmachine> heh
12:17:58 <Botje> if you want to play it slightly more fair, propose X, Y, and X'
12:18:10 <Botje> where X' is a subtly (or not so subtly) worse version of X
12:18:18 <jmcarthur> copumpkin: i'm still not sure. if i have something of type Parser Foo, i doubt i can get both of these functions from the same thing if it's applicative:  parse :: Parser Foo -> String -> Foo ; print :: Parser Foo -> Foo -> String
12:18:19 <Botje> people will tend to choosing X
12:18:24 <monochrom> I propose X, Y, and XML.
12:18:30 <Botje> monochrom: i vote XML. :)
12:18:37 <jmcarthur> copumpkin: i think it would need to be much more restrictive
12:21:35 <copumpkin> jmcarthur: hmm
12:21:53 <copumpkin> I think the "context free"-ness of it is sufficient
12:22:02 <copumpkin> you'd need to encode the parser in some sort of ADT though
12:22:42 <copumpkin> I might experiment with it once I get some sleep :P
12:22:55 <jmcarthur> copumpkin: sweet!
12:23:36 <jmcarthur> copumpkin: but how would the printer inspect the value the give it?
12:23:44 <jmcarthur> *you give it
12:23:54 <copumpkin> hmm
12:24:07 <jmcarthur> that's where i see the restrictions coming in
12:24:11 <monochrom> Think of parse :: Grammar Foo -> String -> Foo and print :: Grammar Foo -> Foo -> String instead.
12:24:20 <jmcarthur> monochrom: yeah, Grammar
12:24:22 <copumpkin> yeah, I guess you'd need to verify you have an "bijective grammar"
12:24:30 <copumpkin> otherwise it's just impossible anyway
12:24:33 <jmcarthur> right
12:24:48 <copumpkin> but I don't think that'd be a language-level thing
12:25:11 <copumpkin> as in, taking it back to regular languages wouldn't affect it much... it's more of a relation between the data and the language than the language power itself
12:25:30 <jmcarthur> (<$$>) :: f (a -> b) -> f (b -> a) -> (f a -> f b)
12:26:06 <jmcarthur> makes it looks like just making both at once, just interleaved
12:26:47 <MaciejP> In a Cabal file, how do I set the build-depends field for a package B depending on the version of package A?
12:32:38 <mm_freak> ok, there is mwc-random and mersenne-random
12:33:22 <mm_freak> bryan claims that mwc-random is faster, is this true in general?
12:33:38 <jmcarthur> i've used it for a couple things now, but i didn't compare to mersenne
12:33:53 <jmcarthur> but it performed admirably for me, even though i don't have a basis for comparison
12:34:18 <danderson> where do folks find the cairo and gtk packages required by criterion?
12:34:25 <danderson> they don't seem to exist in hackage, according to cabal.
12:34:25 <Zao> danderson: By installing gtk2hs?
12:34:39 <Zao> It's not on hackage, for great justice.
12:35:12 <Zao> http://haskell.org/gtk2hs/
12:35:27 <Zao> Provides all these: http://haskell.org/gtk2hs/docs/current/
12:35:33 <jmcarthur> danderson: gtk2hs is not cabalized, unfortunately :(
12:35:34 <mm_freak> jmcarthur: it doesn't appear to have a non-IO interface, which is bad
12:35:48 <danderson> how come not cabalized? Just because, or for an unusual reason?
12:35:50 <danderson> Zao: thanks.
12:36:14 <Zao> danderson: Non-trivial build solution, I believe.
12:36:50 <danderson> oh yay, sourceforge down. There goes my benchmarking binge :(
12:38:00 <danderson> guess I could always go with the darcs version.
12:38:15 <mrtrac> danderson: but I guess only for you... sf is working for me
12:38:20 <sm> sourceforge, how 80s!
12:38:27 <danderson> ah, it's back
12:38:31 <mrtrac> :)
12:38:40 <danderson> (downforeveryoneorjustme.com was also reporting it down, I swear!)
12:38:44 <jmcarthur> mm_freak: mwc-random uses ST
12:38:57 <jmcarthur> *has an ST interface
12:41:38 <artzz> i have another question
12:42:10 <c_wraith> artzz: just ask
12:43:42 <artzz> hi again
12:43:46 <artzz> yes sorry
12:43:46 <artzz> got disc
12:44:02 <artzz> why doesn't this work when the commented line is uncommented http://pastebin.ca/1842731 ?
12:44:48 <jmcarthur> artzz: putStrLn creates and IO action, but your do block is in the list monad, not the IO monad
12:45:08 <jmcarthur> artzz: because your first case return []
12:45:12 <jmcarthur> *results in []
12:45:53 <jmcarthur> artzz: what is it supposed to do? is f an IO function?
12:46:04 <artzz> I just want to execute an IO function for each element in a list
12:46:13 <jmcarthur> :t mapM
12:46:14 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
12:46:17 <fax> artzz, [IO a] -> IO [a]?
12:46:20 <Cale> artzz: when the list is empty, you probably want  return ()
12:46:34 <jmcarthur> :t mapM   -- artzz
12:46:35 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
12:46:40 <Cale> artzz: which is an IO action that does nothing, producing the empty tuple as its result
12:46:44 <artzz> ok that's chinese for me now
12:46:44 <jmcarthur> sorry for doing that twice
12:46:59 <artzz> what lambdabot wrote
12:47:10 <Cale> So:  funForEach f [] = return (); funForEach f (x:xs) = do ...
12:47:10 <EvanR-work> so tuples can be empty, tuples can have two things, but they cant have one?
12:47:15 <artzz> oh ok
12:47:17 <Cale> EvanR-work: right
12:47:17 <jmcarthur> artzz: mentally replace the m with IO
12:47:22 <EvanR-work> that is rather amusin
12:47:24 <EvanR-work> g
12:47:37 <jmcarthur> EvanR-work: i guess () could be seen as an empty tuple
12:47:42 <mm_freak> artzz: mapM_ print [1,2,3]
12:47:45 <jmcarthur> EvanR-work: perhaps Identity could be a 1-tuple?
12:48:02 <jmcarthur> oh but it's not lazy
12:48:06 <geheimdienst> but why would anyone ever want a 1-tuple?
12:48:10 <jmcarthur> so it's not the same as 2-tuples and up
12:48:26 <c_wraith> I use one-tuples all the time.  I just don't, you know, formalize it.
12:48:28 <mm_freak> artzz: or if you actually want the results: mapM readFile ["a.txt", "b.txt", "c.txt"]
12:48:34 <EvanR-work> jmcarthur: how about a data constructor
12:48:41 <jmcarthur> EvanR-work: that would work
12:48:52 <jmcarthur> data Id a = Id a
12:49:08 <mm_freak> geheimdienst: note that (a) is the same as a
12:49:13 <artzz> mm_freak: nice, thanks
12:49:51 <geheimdienst> mm_freak: in related news, (((((42))))) is the same as (42) and 42
12:50:10 <mm_freak> geheimdienst: you asked why anybody would want to use a 1-tuple
12:50:22 <mm_freak> note that you're probably doing it all the time ;)
12:50:25 <EvanR-work> but is (bottom) equal to Id bottom (see definition of Id above)
12:51:07 <mm_freak> i'd prefer to write Unit over ()
12:51:12 <EvanR-work> you might want a 1 tuple to encapsulate an expression which you may not need, and so may be discarded before being computed
12:51:14 <geheimdienst> mm_freak the questoin was a rhetorical ... i meant i can't see why anyone would ever need a 1-tuple
12:51:34 <mm_freak> so i could write () a to express a 1-tuple
12:51:47 <mm_freak> or in other words:  a simple type =)
12:52:17 <mm_freak> geheimdienst: well, i could see that nobody would want to use a 1-array, but a 1-tuple?
12:52:28 <mm_freak> and sometimes there is even use for a 1-array
12:52:53 <mm_freak> randomBits :: Int -> UArray Int Bool
12:53:06 <mm_freak> uhm
12:53:09 <mm_freak> randomBits :: Int -> IO (UArray Int Bool)
12:53:34 <artzz> wow, i'm starting to like this..
12:54:29 <geheimdienst> i would say an array is a bunch of Strings, bunch of Ints, bunch of what have you. it's possible that sometimes there is only 1 String to process, 1 Int to sum up, etc. so arrays of length 1 are useful imho
12:54:54 <EvanR-work> that is why we have lists
12:54:55 <geheimdienst> a tuple is different because it's a fixed-length thing with different types in it
12:54:55 <lowasser> EvanR -- except that discarding "an expression you may not need" is already done by laziness
12:55:17 <EvanR-work> lowasser: right, nevermind ;)
12:56:22 <mm_freak> geheimdienst: yes, and a 1-tuple is simply a value
12:57:18 <geheimdienst> yes exactly :) that's why i think anyone who needs a 1-tuple can just as well use the value directly
12:57:28 <EvanR-work> that is true
12:57:30 <lowasser> in general, pretty much
12:57:32 <EvanR-work> i think
12:57:37 <mm_freak> geheimdienst: that's what you're doing when using a "1-tuple"
12:57:47 <mm_freak> (a,b,c)
12:57:48 <mm_freak> (a,b)
12:57:49 <mm_freak> (a)
12:57:53 <lowasser> except when you're using unboxed tuples, in which case there's actually a nontrivial use, but that's of course deep magic
12:57:54 <mm_freak> and (a) is the same as a
12:57:55 <EvanR-work> so why does python allow 1 tuple using the syntax (1,) ;)
12:58:03 <EvanR-work> they must not have gotten the memo
12:58:06 <Zao> Because Python is Python.
12:58:09 <Zao> Retarded in some ways.
12:58:12 <EvanR-work> heh
12:58:21 <geheimdienst> evanr, it's because the newlines, obviously :)
12:58:26 <geheimdienst> *of the
12:58:30 <mauke> because python is so inconsistent and arbitrary, unlike perl, where (1,) == (1) == 1
12:58:33 <Zao> (1,) would be a section of a 2-tuple.
12:58:52 <mm_freak> it's just inconsistent in that haskell has no () type constructor, whereas it has (,), (,,) and (,,,)
12:59:11 <copumpkin> how do you mean?
12:59:13 <lowasser> I mean, () is already taken up by a type of its own
12:59:13 <medfly> :t ()
12:59:14 <lambdabot> ()
12:59:22 <mm_freak> i'd prefer to write Unit instead of () for the unit type
12:59:30 <EvanR-work> :t Unit
12:59:31 <lambdabot> Unit
12:59:34 <mm_freak> and () should be a type constructor for what geheimdienst call's a 1-tuple
12:59:35 <copumpkin> mm_freak: oh, you'd want () to be Void?
12:59:39 <copumpkin> oh
12:59:42 <lowasser> no, he want's
12:59:43 <fax> 1-tuple??
12:59:45 <fax> that's a 0-tuple
12:59:47 <geheimdienst> wouldn't () be a 0-tuple?
12:59:48 <lowasser> data () a = (a)
12:59:51 <copumpkin> what's the point of a 1-tuple?
12:59:57 <lowasser> that's the point, though
12:59:58 <mm_freak> or in other words: the identity function for types
13:00:04 <copumpkin> haskell's tuple types are unrealted
13:00:06 <Zao> It's not like you can relate N-tuples to M-tuples anyway.
13:00:09 <copumpkin> the only connection is the syntax
13:00:15 <lowasser> that because you never really need a one-tuple, there's no reason to have a special syntax
13:00:24 <lowasser> while 0-tuples and 2-tuples are useful in their own right
13:00:26 <mm_freak> copumpkin: yes, but using () for the unit type seems wrong to me
13:00:30 <fax> lowasser, what about the identity monad
13:00:30 <mm_freak> or inconsistent if you wish
13:00:40 <lowasser> well, sure, identity monad is fine
13:00:56 <mm_freak> lowasser: you can't express 0-tuples in haskell
13:01:02 <mm_freak> in h98 that is
13:01:05 <lowasser> false!
13:01:06 <artzz> btw, which would be the best to use with linux? ghc or hugs?
13:01:07 <mauke> mm_freak: I can
13:01:13 <mm_freak> really?
13:01:13 <lowasser> () as it's currently implemented
13:01:15 * geheimdienst is lolling a lot at this whole discussion
13:01:15 <jmcarthur> artzz: ghc
13:01:15 <lowasser> is the zero-tuple
13:01:20 <mm_freak> () is not the 0-tuple
13:01:23 <mm_freak> Void is the 0-tuple
13:01:23 <EvanR-work> haha
13:01:24 <diegoeche> isn't () the 0-tuple?
13:01:26 <lowasser> false!
13:01:30 <lowasser> Void isn't the 0-tuple
13:01:34 <EvanR-work> :t Void
13:01:35 <lambdabot> Not in scope: data constructor `Void'
13:01:36 <mm_freak> no?
13:01:43 <jmcarthur> artzz: hugs is unmaintained afaik and is much slower due to being just an interpreter whereas ghc is a compiler (and repl and interpreter)
13:01:44 <lowasser> hold on everybody for just one sec
13:01:47 <c_wraith> Void has no inhabitants.  There's clearly one inhabitant of the type of zero-tuples
13:01:50 <mm_freak> ok, i'm wrong indeed
13:01:51 <lowasser> exactly
13:01:53 <artzz> jmcarthur: oh great, thanks!
13:01:58 <mauke> mm_freak: newtype Void = H98 Void
13:01:59 <diegoeche> 1-tuple: http://hackage.haskell.org/packages/archive/OneTuple/0.2.1/doc/html/Data-Tuple-OneTuple.html
13:02:01 <lowasser> I claim that a k-tuple of Bools has 2^k possible values, not counting bottoms
13:02:13 <lowasser> and therefore a 0-tuple of Bools should have 1 possible value other than bottom
13:02:20 <mm_freak> mauke: hmm, true
13:02:23 <lowasser> essentially, instead of considering tuples as functions on types
13:02:33 <mm_freak> anyway, IMO a 1-tuple type is simply a type
13:02:36 <fax> lowasser, you're using induction!
13:02:43 <mm_freak> so the "1-tuple constructor" is the identity function for types
13:02:51 <lowasser> Yes, and inferring logically what we want the 0 tuple to be.
13:02:55 <lowasser> we say that (), (a), (a, b), (a, b, c), ... is the natural progression of tuple sizes
13:03:01 <fax> lowasser, lets defined n-tuple inductively then,  T [] = (), T (x:xs) = (x, T xs)
13:03:07 <fax> lowasser, now your observation is true
13:03:10 <lowasser> yep
13:03:20 <lowasser> but here's another way of thinking about it
13:03:26 <mm_freak> lowasser: i don't know if using () for the 0-tuple really makes sense
13:03:31 <lowasser> define T [x] = (x) = x, T(x:xs) = (x, T xs)
13:03:36 <mm_freak> note that instead of removing a comma and a type, you just remove a type here
13:03:39 <fax> gross
13:03:50 <lowasser> I mean, if we haven't agreed on a 0-tuple yet
13:03:56 <lowasser> then [x] is a logical place to start!
13:04:28 <lowasser> so if we define T[x] = (x) = x, T(x:xs) = (x, T xs), then we get that for n >= 1, n-tuples of Bools have 2^k values, not counting bottoms
13:04:46 <lowasser> and so we figure out that if we want a sensible definition of 0-tuple, it should obey the same rule
13:04:54 <lowasser> namely, that there is one value of the zero-tuple
13:05:18 <lowasser> but anyway, what part of  (), (a), (a, b), (a, b, c), ... seems unnatural?!
13:05:30 * jmcarthur notes that now we are back to the whole x^0 = 1 thing
13:05:49 <lowasser> hahaha, it's true, except I'm working in math instead of in Haskell syntax =P
13:06:33 <lowasser> consider the constructor of the k-tuple, as opposed to the type of the k-tuple
13:06:34 <fax> jmcarthur lets do 0.9999.. = 1 next!
13:06:40 <lowasser> the constructor of the k-tuple should take k arguments!
13:06:43 <jmcarthur> :t fixpoint
13:06:44 <lambdabot> Not in scope: `fixpoint'
13:06:47 <jmcarthur> darn
13:06:58 <jmcarthur> gone again
13:06:59 <mm_freak> well, i'm fine with the 0-tuple, but there should be a constructor for 1-tuples
13:07:04 <geheimdienst> fax, so you're proposing tuples with non-integer lengths, huh
13:07:06 <fax> lowasser, I use (), (a, ()), (a, (b, ())), ...
13:07:16 <lowasser> I mean, that's a fine way of thinking about it
13:07:22 <artzz> another one.. why (5::Int) + (5::Double) won't work, no implicit conversion from int to double?
13:07:24 <lowasser> , fax
13:07:35 <lowasser> ...I have to ask: artzz, are you kidding?
13:07:46 <fax> artzz, that's just a peculiarity of (+)
13:07:54 <jmcarthur> artzz: no, we do not have implicit conversions
13:07:58 <artzz> lowasser: no, I am still learning, reading a tut, but haven't got there
13:08:02 <lowasser> mkay
13:08:03 <jmcarthur> :t (+)
13:08:04 <lambdabot> forall a. (Num a) => a -> a -> a
13:08:05 <lowasser> just checkin'
13:08:09 <fax> artzz, you could defined your own 'mega+' which does work on that case, but it's pretty awkward and impossible
13:08:11 <artzz> ohh i see
13:08:14 <lowasser> mm_freak:
13:08:28 <c_wraith> fax: it's not that bad, using type functions
13:08:43 <lowasser> I think it's a perfectly reasonable way of doing things, not to have a unit tuple
13:09:01 <lowasser> given that we need the type () to refer to the zero tuple, and (,) to refer to pairs
13:09:05 <lowasser> there's nowhere in the middle
13:09:38 <geheimdienst> lowasser, how about counting the number of commas + the number of close-parens
13:09:39 <lowasser> yes, it's slightly irritating to lose symmetry there, but it's a type that would almost never be used
13:09:40 <artzz> so what would this mean: 'forall a. (Num a) => a -> a -> a'
13:09:40 <geheimdienst> ;)
13:09:58 <geheimdienst> so ( is the 0-tuple, () the 1-tuple, (,) the 2-tuple etc
13:10:15 <fax> lol
13:10:15 <lowasser> ...sure, if you want to not be able to use parentheses in type signatures =P
13:10:21 <fax> ( is the HALF tuple
13:10:24 <mm_freak> lowasser: that's my point of why using () as the unit type is controversial
13:10:26 <jmcarthur> artzz: it means (+) works on types that have an instance of Num defined, both arguments to (+) must have the same type, and the result of (+) is the same type as the type of its arguments
13:10:30 <Zao> (\b) should be the 0-tuple.
13:10:43 <lowasser> mm_freak: there's no actual controversy, though!
13:11:07 <artzz> jmcarthur: oh good, i get it I think
13:11:08 <artzz> thanks
13:11:10 <lowasser> nobody ever uses the 1-tuple
13:11:11 <jmcarthur> np
13:11:14 <lowasser> lots of people use the 0-tuple
13:11:18 <lowasser> lots of people use the 2-tuple
13:11:26 <mm_freak> lowasser: everybody uses the 1-tuple, all the time
13:11:31 <EvanR-work> does the number of people who use it matter
13:11:31 <lowasser> how?
13:11:40 <mm_freak> lowasser: (a) is the 1-tuple
13:11:43 <mm_freak> which is the same as a
13:11:46 <lowasser> personally, I prefer having (a) = a
13:11:51 <mm_freak> yes
13:11:53 * hackagebot vector-space 0.5.9 - Vector & affine spaces, linear maps, and derivatives (requires ghc 6.9 or better)  http://hackage.haskell.org/package/vector-space-0.5.9 (ConalElliott)
13:11:56 <jmcarthur> there's also a distinction between lazy tuples and strict tuples (and maybe another distinction with the idea of cartesian product, although perhaps strict tuples are close enough)
13:11:59 <geheimdienst> evanr: not to haskellers ...
13:12:01 <mm_freak> so a 1-tuple type is just a type
13:12:04 <lowasser> in which case, I never need the 1-tuple!
13:12:11 <lowasser> certainly not a constructor
13:12:18 <mm_freak> but you're using the 1-tuple
13:12:19 <jmcarthur> and for lazy tuples, a 1-tuple is semantically different from just a value
13:12:24 <mm_freak> you're just not calling it a 1-tuple
13:12:27 <lowasser> jmcarthur: not convinced
13:12:41 <jmcarthur> lowasser: data Id a = Id a  is not the same as just  a
13:12:42 <elly> heh; "It's just a monoid in the category of endofunctors, what's so hard?" has become a catchphrase around CMU
13:12:49 <lowasser> hmmm
13:12:52 <EvanR-work> jmcarthur: right, i thought that (a) and a were both adequately lazy
13:12:55 <lowasser> newtype Id a = Id a is the same, though
13:13:06 <jmcarthur> lowasser: yeah, but that's inconsistent with our other tuples
13:13:11 <jmcarthur> lowasser: (,) is lazy
13:13:18 <mm_freak> jmcarthur: the constructor for a 1-tuple type should be the identity function for types
13:13:21 <lowasser> hmmmm
13:13:33 <lowasser> I'm actually agreeing with mm_freak here
13:13:41 <lowasser> if it's the identity for types, then I'm fine
13:13:52 <mm_freak> even with newtype it would be wrong
13:13:54 * hackagebot vector-space 0.6.0 - Vector & affine spaces, linear maps, and derivatives (requires ghc 6.9 or better)  http://hackage.haskell.org/package/vector-space-0.6.0 (ConalElliott)
13:13:56 <jmcarthur> then (_|_,_|_) should be _|_
13:13:57 <mm_freak> it would rather look like:
13:14:00 <mm_freak> type Id a = a
13:14:04 <lowasser> I see what you're saying, jmcarthur
13:14:25 <lowasser> but nobody would use that behavior
13:14:32 <jmcarthur> i do!
13:14:44 <mm_freak> it would be consistent
13:14:51 <lowasser> 'kay, but it's nowhere near as common as the zero tuple or the 1-tuple
13:14:55 <jmcarthur> i would prefer that we have both lazy tuples and either strict tuples or some other approximation with true cartesian products
13:14:58 <danderson> wow, gtk2hs is really really painful to build.
13:14:58 <lowasser> also, mm_freak, you're disagreeing with yourself
13:14:59 <jmcarthur> but we have lazy tuples
13:15:06 <mm_freak> lowasser: where?
13:15:07 <danderson> I guess I've been spoilt by cabal :)
13:15:12 <lowasser> what jmcarthur is proposing as the 1-tuple is *not* the identity function on types!
13:15:13 <geheimdienst> why, (monoid, endofunctor) is just a monad. what's the problem?
13:15:32 <fax> what
13:15:33 <lowasser> (back me up on this, jmcarthur)
13:15:38 <jmcarthur> lowasser: i use the laziness of (,) all the time. it's not just some uncommon thing for me
13:15:48 <lowasser> jmcarthur: me, too
13:15:54 <lowasser> I don't use the laziness of a 1-tuple, though
13:16:12 <mm_freak> lowasser: i know, but i don't agree about the laziness feature anyway
13:16:18 <jmcarthur> because we don't have a 1-tuple in our standard libraries
13:16:21 <lowasser> okay
13:16:30 <lowasser> so nobody would use a lazy 1-tuple
13:16:37 <lowasser> (except jmcarthur)
13:16:42 <fax> @hackage one-tuple
13:16:43 <lambdabot> http://hackage.haskell.org/package/one-tuple
13:16:43 <EvanR-work> i figured that simply having the expression in a pair of parentheses makes it lazy
13:16:44 <mm_freak> if you want a lazy identity monad, define it
13:16:44 <lowasser> are we agreed, mm?
13:16:57 <mm_freak> lowasser: yes
13:17:03 <lowasser> evanr: having any expression makes it lazy, whether or not it's in a pair of parentheses ;)
13:17:07 <EvanR-work> right
13:17:16 <EvanR-work> so i guess you guys are arguing about types only
13:17:26 <lowasser> so if you'd only use the 1-tuple as the identity function on types
13:17:31 <mm_freak> i think it's best to say that we have a number of inconsistencies, but it's highly controversial how to resolve them
13:17:32 <geheimdienst> lowasser: yes, i thought haskell was lazy, tuples or no
13:17:39 <lowasser> exactly!
13:17:49 <lowasser> that was to geheim
13:17:55 <jmcarthur> hmm... i suppose i can see the argument that newtype is reasonable for a 1-tuple
13:18:09 <mm_freak> a similar controversy is about 0^0, but there we can safely say:  "depends on the context"
13:18:10 <lowasser> mm: then what we're saying is, essentially
13:18:15 <lowasser> type OneTuple a = a
13:18:24 <mm_freak> yeah
13:18:34 <lowasser> in which case you would never even need to refer to OneTuple, because you can just remove it anywhere it appears!
13:18:45 <tensorpudding> If that is a 1-tuple, then what does a 0-tuple look like?
13:18:54 <copumpkin> data ZeroTuple
13:18:56 <fax> didn't we just do this ??
13:18:59 <copumpkin> with a total language
13:18:59 <lowasser> yes, we did
13:19:00 <mm_freak> lowasser: it may be useful where a type of kind * -> * is needed
13:19:02 <fax> lol
13:19:06 <mm_freak> and there you can't just remove it
13:19:19 <lowasser> mm_freak: that's true, but that's not needed enough to screw with a perfectly reasonable syntax!
13:19:22 <copumpkin> @src Identity
13:19:22 <lambdabot> newtype Identity a = Identity { runIdentity :: a }
13:19:27 <lowasser> exactly.
13:19:34 <copumpkin> :)
13:19:52 <EvanR-work> are we now in the business of restricting the user from using expressions which can be automatically removed if they dont change anything? :)
13:19:55 <lowasser> in the places we need it, it's more readable code to use "Identity" instead of some sort of one-tuple thing
13:20:02 <EvanR-work> you arent allowed to type 0+0, its just 0
13:20:11 <EvanR-work> for that matter you cant type 1+2 its 3 ;0
13:20:22 <lowasser> evanr: we're explaining why it's perfectly fine not to have that expression in the first place, in that case
13:20:23 <mm_freak> lowasser: well, nothing is needed until it's there =)
13:20:31 <copumpkin> we even have a type-level 1
13:20:33 <copumpkin> :k 1
13:20:34 <lambdabot> *
13:20:56 <mm_freak> lowasser: i didn't need a language as high as haskell when i only knew C
13:20:59 <jmcarthur> newtype Computation a = Computation (Free Identity a)  -- lowasser: this will only have the intended semantics if Identity is defined using data
13:21:17 <lowasser> do whatever laziness thing you want
13:21:21 <xerox> :t undefined :: (1,1)
13:21:22 <lambdabot> (Unit, Unit)
13:21:36 <copumpkin> :t Unit
13:21:37 <lambdabot> Unit
13:21:41 <copumpkin> :t Unit :: 1
13:21:41 <xerox> :o
13:21:41 <lambdabot> Unit
13:21:46 <copumpkin> :)
13:21:49 <xerox> yay that's how to build them!
13:21:49 <lowasser> but it makes sense to not have some sort of 1-tuple thing
13:21:53 <copumpkin> :k (:+:)
13:21:54 <lambdabot> * -> * -> *
13:21:56 <jmcarthur> not to me :\
13:22:03 <lowasser> hold on
13:22:03 <copumpkin> :t InR
13:22:04 <lambdabot> forall a. (Rec a -> a) -> Rec a
13:22:11 <lowasser> especially when it's ambiguous, because you *expect* it to be the identity function, and you also expect it to be lazy
13:22:11 <jmcarthur> it would make sense if our tuples were cartesian products, but they aren't
13:22:14 <mm_freak> lowasser: my point is that we _have_ 1-tuples
13:22:19 <FliPPeh> I wonder, does Lazy evaluation reduce or increase memory usage? I could defer/avoid calcualtions that are not needed, but doesn't it introduce new bookkeeping internals?
13:22:22 <mm_freak> we just don't have a special syntax for them
13:22:38 <FliPPeh> s/I/it
13:22:41 <mm_freak> or we could say that the special syntax is like:  don't use a constructor at all
13:22:51 <jmcarthur> we have 1-tuples with cartesian semantics, but not with the lazy semantics that our other tuples have
13:22:56 <lowasser> ...I'm *totally fine* with that
13:23:03 <mm_freak> FliPPeh: in general it increases memory usage
13:23:06 <tensorpudding> Laziness can increase memory usage, for sure.
13:23:13 <fax> so here's my question
13:23:15 <lowasser> jmcarthur: go define data Identity a = Identity a, and use it wherever you want
13:23:20 <tensorpudding> But it can also decrease usage.
13:23:33 <jmcarthur> lowasser: but my argument is that that definition is most in line with our other tuples
13:23:46 <xerox> copumpkin: anything Rec a -> .. a .. ?
13:23:46 <FliPPeh> So it depends on the situation?
13:23:51 <mm_freak> FliPPeh: but if you do it properly it decreases memory usage for a particular coding style
13:23:51 <FliPPeh> Thanks for clearing this up :)
13:23:53 <lowasser> except that we expect the one-tuple with argument a to be written (a)
13:23:53 <copumpkin> :t InL
13:23:54 <lambdabot> Not in scope: data constructor `InL'
13:23:54 <lowasser> =a
13:24:03 <copumpkin> xerox: nah, that's a different value I think
13:24:04 <jmcarthur> lowasser: that's just syntactic
13:24:16 <copumpkin> xerox: the constructors for :+: should be InR and InL too I think
13:24:19 <lowasser> what are we arguing about?
13:24:20 * geheimdienst thinks a 2-tuple is a value with another value stuck to it. like a C struct, or a record, but without field names. a 1-tuple is silly because that would be a value with no value stuck to it. a 0-tuple is also silly, but it could be something like Java null or SQL NULL, an indication of "no value here, move along"
13:24:31 <lowasser> what's wrong with the existing syntax, then?
13:24:40 * copumpkin is arguing about nothing
13:24:49 <jmcarthur> lowasser: we are arguing about three different things
13:24:49 <copumpkin> fax: I have a thread blocked on you!
13:24:52 <lowasser> the only problem that anybody's complained about with the existing syntax
13:24:59 <jmcarthur> syntax, catesian products, and lazy tuples
13:25:01 <copumpkin> fax: it's like a syn with no syn/ack
13:25:07 <fax> that's very romantic
13:25:09 <jmcarthur> i'm not complaining about syntax
13:25:13 <lowasser> is that the zero tuple doesn't fit the pattern of the other tuple types
13:25:15 <copumpkin> totally
13:25:22 <lowasser> jmcarthur: then I'm not arguing with you!
13:25:23 <jmcarthur> i'm complaining about the confusion between cartesian products and lazy tuples
13:25:25 <jmcarthur> they are not the same
13:25:34 <mm_freak> lowasser: i was the one arguing about syntax, not geheimdienstâ¦  he argued that having 1-tuples, which are different from simple types, is useless
13:25:50 <lowasser> as far as I knew, I was only arguing with mm
13:25:51 <jmcarthur> we have lazy tuples, therefore 1-tuples have distinct semantics from just plain values
13:26:06 <copumpkin> can we make a nice category where lazy tuples are products?
13:26:08 <lowasser> and then jmcarthur came in and started complaining that we were having a fallacy totally unrelated to our discussion
13:26:14 <geheimdienst> jmcarthur, but i thought haskell was a lazy language anyway?
13:26:14 <lowasser> ...I think
13:26:19 <lowasser> aughhhhh
13:26:25 <copumpkin> lol
13:26:35 <lowasser> geheimdienst: yes, and that's not incompatible with jmcarthur's claim
13:26:44 <lowasser> anyway
13:26:44 <mm_freak> anyway, let's end this debateâ¦  haskell is about the best we can get from a practical language (not counting yet-infantile languages like agda)
13:26:52 <lowasser> finally
13:27:02 <lowasser> I need to go study for my topology exam in half an hour >,
13:27:02 <fax> o_O
13:27:29 <fax> I should study too but studying is not fun
13:27:30 <jmcarthur> *sigh*
13:27:31 <mm_freak> i just wish to have a better Prelude and a better Control.Monad and call it Control.Functor instead =)
13:27:54 * fax wishes we didn't have a prelude
13:27:58 <copumpkin> fax: you need to read more books! the more volumes the better
13:28:06 <fax> no reading books doesn't really do anything
13:28:13 <fax> you have to actually solve problems to learn stuff :(
13:28:15 <monochrom> Debate? I want to participate in the debate!
13:28:17 <fax> (I hate solving problems)
13:28:18 <copumpkin> fax: just mocking certain someones :P
13:28:18 <mm_freak> fax: no prelude?
13:28:37 <fax> yeah standard libraries are awful, they just get in the way
13:28:37 <mm_freak> monochrom: you're too late
13:28:48 <monochrom> @quote monochrom debate
13:28:49 <lambdabot> monochrom says: All pointless debates can be settled by going polymorphic.
13:29:03 <fax> arguments for free ?
13:29:04 <mm_freak> fax: sometimes, but not usually and you can always choose not to import the Prelude
13:29:11 <monochrom> haha fax
13:29:16 <jmcarthur> Free Argument a
13:29:20 <mm_freak> lol
13:29:30 <mm_freak> pointOfThisDiscussion :: forall a. a
13:30:02 <copumpkin> is there a nice way of saying that forall a. a === void?
13:30:10 <mauke_> programs for nothing, theorems for free
13:30:11 <stepcut> how do I get ghci to load the cabal_macros.h file?
13:30:12 <mm_freak> copumpkin: no, because it's not
13:30:55 <copumpkin> what's the difference?
13:31:06 <mm_freak> copumpkin: right:  3 <- pointOfThisDiscussion
13:31:12 <mm_freak> wrong: 3 <- gimmeVoid
13:31:39 <copumpkin> exfalso :: void -> a
13:31:49 <mm_freak> or for example you can have undefined + undefined
13:31:54 <monochrom> do you mean (forall a. a) === void ?
13:31:59 <copumpkin> yeah
13:32:28 <monochrom> need function f :: void -> (forall a. a) to complete it
13:32:36 <fax> "It is interesting that categorists began using modes of reasoning like that in the preceding because objects of categories generally lacked elements; now one appreciates them for their own sake /because/ they allow element-free (and thus variable-free) arguments"
13:32:40 <fax> ^ I don't get this...
13:32:43 <copumpkin> yeah, it's a pretty well known function :)
13:32:51 <fax> why should one appreciate this?
13:32:56 <monochrom> oh oops, need the other one, g :: (forall a. a) -> void
13:33:03 <Accidus> that's not exactly correct
13:33:10 <mm_freak> i think (forall a. a) is only the same as void in terms of the C-H isomorphism
13:33:11 <Accidus> fax
13:33:15 <fax> there is this example of using a commutative diagram to declare associativity instead of the equation a(bc)=(ab)c
13:33:26 <Accidus> Categories has evolved doubly
13:33:48 <Accidus> Both with elements (concrete categories) and without elements (abstract categories)
13:34:28 <copumpkin> oh I know
13:34:37 <copumpkin> you can model forall a. a as () -> a
13:34:43 <copumpkin> which is exfalso
13:35:36 <fax> and it says
13:36:38 <fax> "The commutative diagram represents blah blah without use of variables. Of course we did use variables in defining the functions involved, but we remedy that deficiency in Ch 5 when we give a categorical definition of products."
13:36:49 <fax> what deficiency does it mean? :|
13:36:49 <Accidus> fax, in any case, they are appreciated because they allow a higher level treatment. you make something involved (functions on elements) ubiquitous (morphisms)
13:36:56 <merijn> fax: Shortcoming?
13:36:58 <copumpkin> I think it's pretty standard in hask to model non-function values as () -> X
13:37:03 <copumpkin> or am I misunderstanding it?
13:37:15 <Accidus> fax, the "deficiency" of using elements
13:37:20 <monochrom> (forall a. a) could be: I am a type-to-value function, give me type as input, I give you value of that type as output.
13:37:24 <merijn> Oh, I need to learn to read
13:37:44 <merijn> fax: The deficiency of using variables it seems
13:37:46 <Accidus> fax, because they author said that in category theory we /don't/ want to treat morhpisms as mappings of elements.
13:38:00 <innu> I currently use find to know if a list contains an element ( find (==3) list ). Is there a better function?
13:38:12 <mm_freak> innu: elem
13:38:13 <copumpkin> :t elem
13:38:14 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
13:38:17 <mreh> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24025#a24026 -- say what?! I don't think I get arrow syntax properly
13:38:19 <mm_freak> > 3 `elem` [2,3,4]
13:38:20 <lambdabot>   True
13:38:22 <innu> mm_freak, ok thanks
13:38:32 <monochrom> g :: (forall a. a) -> void  then could say: since you give me that function, I pass type void to that function, I get value of type void, I return it.  This implements g.
13:38:47 <copumpkin> omg someone actually using arrow syntax
13:39:10 <mreh> hello
13:39:17 <copumpkin> monochrom: I'm just saying that if you look at the category, it's the same thing
13:39:37 <copumpkin> (I think :))
13:39:56 <monochrom> Oh I just want to announce I figured out how to implement g.
13:40:02 <copumpkin> oh
13:40:32 <mreh> copumpkin: does this suprise you?
13:40:34 <fax> I don't really get it
13:40:55 <copumpkin> mreh: ?
13:40:55 <copumpkin> g x = x x
13:40:55 <copumpkin> :P
13:40:55 <mreh> arrow syntax in actual code
13:40:55 <copumpkin> or g x = x
13:41:08 <copumpkin> mreh: I've never seen anyone actually using arrow syntax
13:41:34 <mreh> copumpkin: with yampa it makes sense
13:41:35 <monochrom> "g x = x" is indeed very compact
13:42:01 <fax> yeah but this category theory stuff is really I don't know how to summarize it
13:42:24 <fax> it's like 5 chapters of really basic stuff, defintions that are just very simple
13:42:34 <copumpkin> yep
13:42:42 <fax> but after that it's just gone completely insane
13:42:52 <fax> and I can't follow any of that stuff
13:43:02 <copumpkin> what was the beginning of the insanity?
13:43:10 <fax> it's liek going from leaning multiplication tables to doing advanced calculus
13:43:24 <fax> yoneda lemma
13:43:39 <monochrom> there is a catster video for that
13:44:06 <fax> what I mean is that I think I have to learn the basic stuff properly
13:44:19 <fax> and I don't really know because there's so much of it and it's all so trivial
13:44:35 <mreh> :t integral
13:44:36 <lambdabot> Not in scope: `integral'
13:44:36 <xerox> yoneda is definition juggling
13:44:47 <xerox> or definition yoga (as my prof says)
13:44:50 <mreh> :t FRP.Yampa.integral
13:44:51 <lambdabot> Couldn't find qualified module.
13:44:55 <fax> there should be some kind of game where you learn about the definitions of category theory without knowing
13:45:19 <Cale> I think the best way to think about Yoneda's lemma is as a sort of 'completion theorem' for categories.
13:45:34 <lament> does yoneda pretty much prove that category theory is useless bullshit and we should just stick to sets and functions?
13:45:49 <fax> lol
13:46:03 <Cale> It takes your possibly-not-so-nice category and embeds it into a potentially much larger category which has all the limits and colimits and other goodies that you could possibly want.
13:46:03 <xerox> I'm seeing this stuff because I'm taking this algebraic geometry course now
13:46:29 <mreh> it seems when you don't get the right type in an Arrow syntax clause it throws a wobbly that I don't understand
13:46:30 <mmmulani> how can I configure cabal to use ghc in location other than the default?
13:46:30 <lambdabot> mmmulani: You have 5 new messages. '/msg lambdabot @messages' to read them.
13:46:40 <Cale> and it does it in such a way that if you can show there's an arrow between two of the objects from your original category using all the fancy new widgets you've got, then that must have actually been an arrow in the original category
13:46:56 <xerox> He anticipated that - but there seem to be too much material to go through for a single man and a single life
13:46:58 <fax> xerox - what sort of stuff do you need to have down pretty solid before doign algebraic geometry?
13:46:58 <monochrom> My view is milder. Topos prove that you may as well use sets.
13:47:44 <xerox> There was a girl at my uni (4 years ago iirc) that graduated at 21, now it's at oxford and does topoi
13:48:14 <xerox> *she's
13:48:24 <mauke> heh
13:48:27 <lament> honest mistake, honest
13:48:30 <monochrom> You're treating her as a math object!
13:48:35 <medfly> lol
13:48:54 <fax> yeah but I am not really talking about yoneda lemma
13:49:02 <fax> I just mean the whole rest of the book from that point
13:49:04 * geheimdienst is a Smalltalk programmer, women are just objects to him
13:49:13 <monochrom> hahaha
13:49:36 <tensorpudding> Marriage is just passing messages back and forth
13:49:45 <lament> i treat objects like women :S
13:50:05 <fax> I think you have to have a strong intuition about all the fundamental definitions like functor and natural transform and so on
13:50:17 <mreh> there's a small child in my master's course, either that or it's a very short woman
13:50:27 <xerox> monochrom: maybe she'd like that :x
13:50:56 <monochrom> mmmulani: in $HOME/.cabal/config there seems to be lines (commented out by default) for pointing to ghc.
13:51:41 <mmmulani> sweet, thanks
13:52:51 <fax> so how do you learn this?
13:53:17 <zachk> learn haskell or learn category theory?
13:53:22 <fax> maybe one just has to be at amuch more advanced level so that it is used quite often?
13:53:41 <danderson> bos: is the attoparsec up on bitbucket current? I'd like to contribute a couple of useful parsers, but I also want to avoid reinventing any wheels you might have stashed on your computers somewhere.
13:53:52 <fax> category theory
13:53:56 <zachk> fax: you can just learn the io monad and use the rest of haskell as just scheme with a type system and really nice syntax
13:54:01 <monochrom> I do these two in parallel: to explore possibilities, look for and create millions of examples; to get through the proofs, let the symbols do the work.
13:54:10 <bos> danderson: should be
13:54:23 <monochrom> Generally when I learn anything at all.
13:55:15 <FliPPeh> Why does Bytestring hate me?
13:55:20 <FliPPeh>  return . read . L.takeWhile (/= ' ') $ c
13:55:25 <FliPPeh> Where c is a bytestring
13:55:36 <mauke> I don't think you can read from a ByteString
13:55:39 <FliPPeh> GHC.Word.Word8 vs Char type conflicht
13:55:46 <Cale> Yeah, read's type requires a String
13:55:53 <mauke> and you're using the wrong L
13:56:06 <FliPPeh> import qualified Data.ByteString.Lazy as L
13:56:12 <mauke> .Char8
13:56:17 <danderson> bos: cool. I'll patchbomb stuff some time after I manage to install gtk2hs and benchmark the code.
13:56:18 <monochrom> Why do you hate types?
13:56:39 * zachk has started to love/like types 
13:56:40 <napping> Is there any way to get IORef (Maybe a) optimized to use null pointers for Nothing?
13:56:49 <xerox> monochrom: there's this article of terry tao that talks about the stages of mathematical evolution, he says careful symbol-working is 2/3
13:57:06 <\yrlnry> xerox:  url?
13:57:13 <Twey> napping: Who says it doesn't already?
13:57:18 <Cale> napping: No, why would it matter?
13:57:22 <napping> -ddump-simpl
13:57:26 <monochrom> dijkstra's articles go all the way to say 3/3
13:57:30 <xerox> ...and it's also part of 3/3 actually.
13:57:30 <mreh> why is every library so keen on double, most people run a 32bit architecture
13:57:31 <Cale> That would actually probably just slow things down.
13:57:57 <zachk> whats double's bit size mreh
13:57:58 <mauke> mreh: because double is C's native floating point type
13:58:01 <napping> depends on the relative cost of following the double indirection in the Just, vs reboxing if you ever actually wanted to carry around the value as a maybe
13:58:16 <mreh> zachk: by IEEE 754 it's 64bit
13:58:20 <Cale> You'd have to explicitly check for a null pointer on read then
13:58:32 <xerox> \yrlnry: hang on
13:58:37 <\yrlnry> xerox:  hanging
13:58:42 <napping> As opposed to explicitly checking for a Nothing
13:58:47 <mreh> > sizeOf (0.0 :: Double)
13:58:48 <lambdabot>   Not in scope: `sizeOf'
13:58:50 <Cale> So it'd be just as expensive as just following the code pointer.
13:58:55 <mreh> > sizeof (0.0 :: Double)
13:58:56 <lambdabot>   Not in scope: `sizeof'
13:58:56 <monochrom> I also know why one of them says 2/3 and the other 3/3.
13:59:01 <xerox> \yrlnry: http://terrytao.wordpress.com/career-advice/
13:59:06 <napping> how do you figure that?
13:59:09 <\yrlnry> xerox: many thanks
13:59:26 <napping> no dereference is required to check if an Addr# is null
13:59:32 <mauke> > sizeOf (0 :: Double)
13:59:33 <lambdabot>   Not in scope: `sizeOf'
13:59:36 <xerox> now for which one it is... hmm.
14:00:02 <xerox> ah, "more to maths than rigour and proofs"
14:00:14 <Cale> napping: It's still extra work that you'd have to perform on every read.
14:00:19 <napping> Oh, I'm assuming extra strictness
14:00:30 <olsner> you always need a pointer to something though, so that (for example) you can change an IORef Nothing into an IORef (Just something)
14:00:30 <xerox> not get me wrong, I love that truth is in the symbols :)
14:00:45 <\yrlnry> Oh, I have read this.
14:00:47 <\yrlnry> Thanks again.
14:00:49 <mm_freak> when i write a constant into a where clause, is its value memoized beyond function invocation?  i.e. if i call the function twice, will it be calculated twice?
14:01:06 <mm_freak> example:  myFunc = â¦ where str = B.pack "blubb"
14:01:22 <napping> Cale: I may have forgotten a bit of strictness. But, say you have IORef (!(Maybe a))
14:02:52 <napping> opening up the IORef to get at the Addr# is the same either way. If you code Nothing as null then you test the pointer directly and either pass it on as an 'a' or go to the Nothing case
14:03:04 <Cale> napping: Even in the case of some sort of strict IORef, it'd still be more work to give a null pointer when the value is Nothing
14:03:13 <Cale> and then have to convert it back on read
14:03:38 <napping> If you use a real maybe, you might be able to recognize Nothing immediately with pointer tagged, but it's an extra indirection to extract from the Just
14:04:44 <napping> Cale: Ah, but after inlining? When I use an IORef (Maybe a) I'm almost always either passing (Just _) or Nothing at any particular call site, and immediately taking a case on the returned value, so it ought to fuse pretty well
14:04:48 <FliPPeh> Why does exception handling hate me, too?
14:04:51 <napping> Er, inline
14:04:53 <FliPPeh> Ambiguous type variable `e' in the constraint
14:05:01 <Cale> Unless you only care about which of the two constructors you have, I think it's usually cheaper to just enter the code pointer regardless.
14:05:13 <olsner> if you see IORef Foo as Foo*, the pointer can never be null - it needs to point to a memory location that you can change
14:05:14 <Cale> and save yourself the extra checking
14:05:26 <napping> No, I'm worried about the double indirection to actually get the value out of the Just, presuming that's what you really want
14:05:41 <olsner> and it can't store the data inside that pointer, because if you have two copies of an IORef they both need to read as the same thing after changing it
14:06:16 <Cale> napping: Two jmps are often faster than most of the other checking you could do.
14:08:08 <napping> The point about multiple references to the IORef may be killer, but I don't understand you on the costs. Two options:
14:08:39 <Cale> An IORef is effectively a mutable pointer to code.
14:08:47 <napping> Nothing represented as null, Just a represented as pointer to a; vs Nothing represented as a pointer to a Nothing, Just a represented as a pointer to a heap allocated Just containing a pointer to a
14:09:05 <Cale> and the Maybe a value you get back is another pointer to code
14:09:22 <napping> Indeed, you would have to promise that the Maybe container - but not necessarily the a within - would be strict for this to be valid
14:09:54 <napping> This is all "why don't our 'nullable refs' compile into actual nullable pointers"?
14:09:56 <Cale> Actually, I'm not sure about that
14:10:06 <Cale> Let me check how IORef is implemented
14:10:14 <Cale> I think it may just be a mutable pointer to a pointer to code
14:10:30 <napping> > :info IORef
14:10:31 <lambdabot>   <no location info>: parse error on input `:'
14:10:31 <Cale> So you don't enter the IORef, you just dereference it
14:10:53 <napping> so in GHC it's a newtype for STRef
14:11:12 <Cale> yeah, which is a data with a MutVar# in it
14:11:17 <napping> which contains a GHC.Prim.MutVar# - which I don't know what that is
14:11:22 <napping> hmm, thought it was Addr#
14:12:09 <napping> Hmm, so we really can't make structs that directly contain mutable pointers to things
14:12:12 <Trinitron> Is there a mathematical way to reverse the digits of a number?
14:12:13 <meanburrito920_> where does cabal install data files associated with a package? the package documentation tells me it should be located in ~/.cabal/share, but it does not appear there
14:12:13 <danderson> wtf, the gtk2hs build process generates .cabal files?!
14:12:19 <Trinitron> I.E turn 123 into 321.
14:12:34 <Trinitron> By using mathematical operators.
14:12:35 <mauke> Trinitron: what about 100?
14:12:45 <Cale> napping: Why does this matter so much?
14:12:47 <Trinitron> I guess that would just turn into 1
14:13:12 <Cale> napping: It seems like something I usually wouldn't want to have to worry about, anyway :)
14:13:16 <Trinitron> But then you lose information.
14:13:27 <Cale> It's GHC's problem how to represent this stuff ;)
14:13:29 <Trinitron> You can't turn it back to 100 with the same transformation function.
14:13:54 <fax> Trinitron: 'mathematical'??
14:14:19 <Trinitron> I.E. Not turning the number into a string then reversing the string.
14:14:26 <Trinitron> That's cheating :)
14:14:43 <Trinitron> Is it in Knuth's book?
14:14:44 <periodic> Trinitron: change it into a + b * 10 + c * 10^2, then reverse the coefficients.
14:14:54 <periodic> That's just what immediately comes to mind.
14:15:06 <napping> Cale: Indeed, I'd like to know I get efficient representations from code like simple types containing IORefs
14:15:10 <sbarr> is there an editor of choice for writing haskell code?
14:15:11 <fax> Trinitron: and what's wrong with cheating?
14:15:24 <Trinitron> It's the easy way out :)
14:15:26 <periodic> sbarr: Whatever editor you're most comfortable in.
14:15:30 <benmachine> sbarr: a lot of people say emacs, but I use vim
14:15:33 <merijn> sbarr: The same editor of choice for any code!  Vim!
14:15:39 * merijn runs from the emacs groupies
14:15:46 <Cale> napping: Best to just use these things and worry about it after you have a program that's too slow
14:15:51 <fax> Trinitron: why make things hard for yourself, give up and ask someone else when you have a BETTER solution??
14:15:53 <benmachine> I think emacs is well-supported because it scripts in a functional language, so there's some intersection of interests
14:16:06 <arw> merijn: the emacs operating system now has a decent editor: viper-mode
14:16:20 <sepp2k> Triniton: rev 0 = 0; rev x = (x `mod` 10) * (log10 x) + rev (x `div` 10)
14:16:25 <periodic> Trinitron: The thing is that arithmatic operators and the like don't care what the representation of a number is.  If your'e talking about the second digit you're really talking about floor . (/ 10) . (mod 100)
14:16:36 <merijn> arw: Or so I've heard, but I can't be arsed to install it and try.
14:16:43 <mreh> must I use Main.hs for a cabal "Main-Is"?
14:17:07 <benmachine> no
14:17:23 <mreh> it says it can't find a Main module...
14:17:23 <arw> merijn: i did, but its not really worth the hassle over plain vim.
14:17:35 <mreh> I've specified Bar.hs
14:17:36 <benmachine> are you importing Main somewhere or something
14:17:38 <mreh> for example
14:17:38 <Trinitron> I have to make a recurrence relation to extract the coefficients then once the edge case is met pop back up with the numbers in the reverse order.
14:17:46 <Trinitron> Shouldn't be too hard.
14:17:56 <benmachine> oh, does Bar.hs have module Bar where
14:18:00 <fax> Trinitron,hey want a fun problem instead
14:18:03 <mreh> benmachine: yes
14:18:08 <Trinitron> ?
14:18:11 <sbarr> thanks!
14:18:20 <fax> I dunno this thing with base 10 digits seems kinda tame
14:18:23 <benmachine> I think main-is just tells cabal what to compile, and possibly doesn't translate into ghc's -main-is
14:18:23 <mreh> :D~~
14:18:28 <benmachine> so it still has to contain module Main
14:18:32 <mreh> benmacine: didn't export main
14:18:34 <monoidal> operations base 10 specific are ugly. mathematics is base agnostic.
14:18:39 <benmachine> oic
14:18:44 <periodic> Hrm, is there a class for something that can be incremented?
14:18:52 <mreh> well, that still didn't fix it
14:18:57 <benmachine> periodic: Enum?
14:19:01 <fax> monoidal, yeah it alwasy struck me as kind of bizarre how there's all these well studied sequence of numbers that have to do with base 10 representation
14:19:01 <benmachine> sorta
14:19:11 <benmachine> mreh: make it module Main where
14:19:12 <periodic> benmachine: It'll probably work.
14:19:12 <mreh> it says "Warning: output was redirected with -o, but no output will be generated because there is no Main module."
14:19:20 <fax> some of the tricks like casting out 9s are really pragmatic and quite elegant -- but taht's rare
14:19:23 <olsner> periodic: you can use [()] :P
14:19:43 <monoidal> casting out 9s is casting (n-1) in base n :)
14:19:50 <mauke> > foldl ((+) . (* 10)) 0 . unfoldr (\x -> if x == 0 then Nothing else Just . (snd &&& fst) $ x `divMod` 10) $123
14:19:51 <lambdabot>   321
14:20:13 <benmachine> snd &&& fst eh
14:20:35 <benmachine> clever
14:20:48 <mreh> benmachine: that did it
14:20:49 <Trinitron> What is a fold?
14:20:53 <benmachine> (not that in particular, in general)
14:20:59 <Cale> Trinitron: in general?
14:21:10 <Trinitron> In Haskell.
14:21:17 <benmachine> in general in haskell? :P
14:21:27 <Trinitron> Ok, that.
14:21:30 <Cale> Trinitron: It's something which replaces the construction of a piece of data with other functions.
14:21:37 <Cale> In some systematic way
14:21:54 <tensorpudding> lots of interesting operations are folds
14:22:00 <Cale> The most canonical example being foldr
14:22:00 <tensorpudding> like sum
14:22:06 <tensorpudding> @src sum
14:22:06 <lambdabot> sum = foldl (+) 0
14:22:11 <benmachine> Cale: are the operations provided by Data.Foldable not really folds?
14:22:26 <tensorpudding> with foldr, you have an operating that works on pairs of elements, and an initial value
14:22:31 <Cale> The function foldr f z replaces each (:) in the construction of the list with f, and the [] at the end with z
14:22:47 <Cale> benmachine: In a really general sense they are.
14:23:09 <Cale> But they're not usually *the* fold for a type
14:23:22 <benmachine> ok
14:23:25 <tensorpudding> foldr and foldl differ in how the tear down the list
14:23:25 <Trinitron> Argh, my client parsed a smiley icon in your explantion.
14:23:27 <tensorpudding> they*
14:23:38 <monoidal> Trinitron: http://www.cs.nott.ac.uk/~gmh/fold.ps
14:23:48 <benmachine> well foldl is a less natural operation than foldr
14:23:48 <Cale> (:) means the list cons
14:24:02 <Cale> http://cale.yi.org/index.php/Fold_Diagrams
14:24:11 <Cale> Look at the diagram in the upper left, the one for foldr
14:24:37 <FliPPeh> @hoogle join
14:24:37 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
14:24:38 <lambdabot> System.FilePath.Posix joinDrive :: FilePath -> FilePath -> FilePath
14:24:38 <lambdabot> System.FilePath.Windows joinDrive :: FilePath -> FilePath -> FilePath
14:24:40 <Cale> We can also write a fold function for trees
14:24:53 <Cale> data Tree a = Tip | Branch a (Tree a) (Tree a)
14:24:56 <Cale> :t Tip
14:24:57 <lambdabot> forall a. Bin a
14:25:00 <Cale> :t Branch
14:25:02 <lambdabot> forall a. a -> Bin a -> Bin a -> Bin a
14:25:06 <Cale> okay, close enough :)
14:25:09 <Trinitron> I have to eat breakfast, be back later. Thanks for explaining so far :)
14:25:13 <tensorpudding> you can think of most (all?) operations that take a list and collapse it to a single value as some kind of fold
14:25:37 <Cale> So, the idea is that our fold will replace each Tip in a tree with some value t, and each Branch with some function b
14:25:40 <benmachine> you can express any function on lists as a fold, but it's not necessarily convenient to do so
14:25:42 <fax> tensorpudding: pretty sure all functions can be implemented that way but the algorithmic complexity can blow up
14:25:55 <jmcarthur> why am i getting downvoted and this bozo getting upvoted? http://www.reddit.com/r/programming/comments/be471/how_do_you_model_things_in_objectoriented/c0mbbhq
14:26:04 <Cale> @let foldTree t b = f where f Tip = t; f (Branch x l r) = b x (f l) (f r)
14:26:06 <lambdabot>  Defined.
14:26:06 <tensorpudding> it's not always a good idea to think of them that way, no
14:26:33 <zachk> > foldr (++) ["this blows up"," really bad ", " man"]
14:26:34 <fax> jmcarthur: you're like an atheist or something
14:26:35 <lambdabot>   []->
14:26:35 <lambdabot>    ["this blows up"," really bad "," man"]
14:26:35 <lambdabot>  [[]]->
14:26:35 <lambdabot>    ["this blows up"...
14:26:41 * geheimdienst notes any program is basically a fold from the command line arguments to the output string *nod wisely*
14:26:45 <jmcarthur> ugh
14:26:47 <tensorpudding> but foldr and foldl are a powerful abstraction that allows you to avoid doing explict recursion and keeps things short
14:26:57 <zachk> oops
14:27:01 <fax> "you should not design with design patterns" -- blasphemy
14:27:17 <fax> there were handed down to us from GO4
14:27:26 <zachk> > foldr (++) [] ["this blows up"," really bad ", " man"]
14:27:27 <lambdabot>   "this blows up really bad  man"
14:27:33 <zachk> what is g04
14:27:42 <jmcarthur> gang of four
14:27:47 <fax> zack, gang of four, was going for similarity with 'GOD'
14:27:54 <jmcarthur> coined to refer to the authors of Deisgn Patterns
14:27:54 <fax> normally written GoF
14:28:04 <jmcarthur> *Design Patterns
14:28:26 <olsner> fax: other people write code while you zealots waste your time praying to gof
14:28:41 <fax> me zealots? :P
14:28:54 <mreh> Visitor pattern is like what functional programming does for breakfast
14:28:58 <jmcarthur> great, now a guy saying he has refused to hire people for saying what i just said
14:28:58 * zachk attacks fax's zealots with upgraded zerglings 
14:29:10 <mreh> HOF at least
14:29:14 <tensorpudding> Which is itself a reference to a different Gang of Four.
14:31:31 * Taejo should learn a generics library
14:33:12 <fax> can you give a proper discussion about why not to do this jmcarthur?
14:33:19 <Cale> jmcarthur: I replied to SomGuy
14:33:26 <Peaker> it's not nice to take something from the early 90's and has become trivial basics by then, and ridicule it for triviality :)
14:33:27 <fax> I mean to be fair, you just said "this is so"
14:34:01 <Cale> http://www.reddit.com/r/programming/comments/be471/how_do_you_model_things_in_objectoriented/c0mbrpc
14:35:07 <ivanm> jmcarthur: what? someone refuses to hire people if they refer to them as the "gang of four" ?
14:35:34 <sinelaw> Peaker, hey
14:35:42 <Peaker> sinelaw: hey
14:36:18 <jmcarthur> ivanm: no, for not designing with design patterns
14:36:28 <jmcarthur> Cale: you rock
14:36:29 <ivanm> ahhh
14:36:43 <jmcarthur> fax: i was under the impression that most programmers understood this. apparently that is not the case
14:37:06 <ivanm> Cale: agreed
14:37:16 <fax> most ______ are $derogatory_term
14:37:20 <jmcarthur> fax: but the point is that it's basically a form of copy paste programming, but with even less direction :\
14:37:45 <jmcarthur> and with consequences affecting not only local code but the entire design of your program
14:37:57 <lament> i thought patterns were concepts, not copy-pasted code
14:38:10 <lament> it seems pretty stupid to rebel against the idea of patterns
14:38:14 <geheimdienst> not copy-pasted code, copy-pasted design
14:38:14 <lament> haskell has tons of patterns
14:38:28 <lament> design should be copy pasted in most cases, since most problems are very similar
14:38:29 <fax> lol
14:39:04 <Peaker> I think maybe one should clarify that: Bad Design < Repetition of patterns of good design < Abstraction of patterns -- By saying the third is better, people think you're dismissing that the second is better than the first
14:39:27 <fax> that's a good point Peaker
14:39:54 <lament> if you're building a house, how do you abstract the fact that it should have windows and doors?
14:40:41 <fax> bridge*
14:40:53 <fax> remember programming = building bridges
14:41:28 <Peaker> lament: I'm not sure I understand, but you don't abstract that you're using a pattern, you just apply an existing pattern rather than repeating it
14:41:30 <lament> consider the haskell pattern of joining a bunch of monadic actions with >>= and >>
14:41:39 <lament> it's so ubiquitous that there's syntax sugar for it
14:41:59 <lament> but having or not having syntax sugar is just a matter of luck and historical reasons
14:42:07 <fax> and idiom brackets too: (| f x y |)
14:42:20 <fax> and if then else :(
14:42:20 <Taejo> should I use (Set.toList . Set.fromList) or (map . group . sort)?
14:42:25 * hackagebot URLT 0.14 - Library for maintaining correctness of URLs within an application.  http://hackage.haskell.org/package/URLT-0.14 (JeremyShaw)
14:42:35 <Peaker> lament: Even without syntax sugar, we do have abstractions of repetative forms of (>>=)  (e.g: liftM2)
14:42:39 <fax> :t map . group . sort
14:42:39 <Taejo> I mean map head
14:42:40 <lambdabot>     Couldn't match expected type `a -> b'
14:42:41 <lambdabot>            against inferred type `[[a1]]'
14:42:41 <lambdabot>     In the first argument of `(.)', namely `group'
14:42:44 <Peaker> lament: Or "sequence", etc
14:42:47 <lament> well yeah
14:42:53 <lament> none of this changes the fact that there's a pattern
14:42:58 <Taejo> :t map head . group . sort
14:42:59 <lament> better yet, monad transformers
14:43:00 <lambdabot> forall a. (Ord a) => [a] -> [a]
14:43:00 <fax> I prefer the set one
14:43:03 <Peaker> lament: This means that if you really have to use (>>=) it's not repetative, it's a different pattern
14:43:05 <fax> because it's cleare what it does
14:43:22 <fax> you are quotienting out the parts of a list by "set"
14:43:28 <fax> and this is an idiom
14:43:31 <Peaker> lament: except for the fact that (>>=) is applied in there multiple times, what can you say about the repeating pattern?
14:43:34 <lament> jmcarthur: do you think something is wrong with monad transformers?
14:43:52 <lament> Peaker: which repeating pattern?
14:44:21 <Peaker> lament: I thought by "pattern" you meant "repeating pattern" (as they do in "Design Patterns")
14:44:21 <lispy> lcasburn: welcome to #haskell :)
14:44:55 <lament> Peaker: um, nothing else i guess.
14:45:00 <merijn> I think the programming world would be better off if the digram "design pattern" was banned
14:45:01 <fax> like you can "quotient out" (normalize) associativity of a tree data type by putting it through the list domain
14:45:16 <fax> or you can normalize beta redexes by putting syntax through a model of lambda calculus
14:45:23 <fax> (even in haskell!)
14:45:25 <lament> Peaker: the point is it's so common to do that that haskell has specail notation for it. But of course you can't have special notation for everything that's common
14:45:53 <Peaker> lament: Without the special notation, it wouldn't be that bad
14:45:55 <napping> no, but you can have a language that lets you define abstractions for things that are common
14:46:12 <fax> it's a very important technique in functional programming,I think
14:46:19 <lament> napping: no language lets you do that in all cases
14:46:20 <Peaker> lament: Using >>= on the end of lines, and \line ->   in the beginning of next line
14:46:41 <lament> Peaker: it was obviously bad enough that they changed the language definition
14:46:55 <fax> lament, what about lsp
14:46:57 <fax> lament, what about lisp
14:47:01 <lament> ?
14:47:12 <fax> doesn't that let you do it?
14:47:15 <pao> hi all! does (==) is optimized in ghc with "reference equality check"?
14:47:23 <fax> since there is syntax macros
14:47:50 <merijn> fax: It doesn't let you do *everything*, but it does let you specify more then any sane person would ever want
14:47:52 <napping> and to the extent a language doesn't let you abstract out common things, that's something to improve in the language
14:48:12 <lament> napping: unfortunately we're stuck using existing languages
14:48:18 <lament> including haskell, and java and whatnot
14:48:23 <merijn> lament: No we're not, just invent your own
14:48:39 <lament> ok, you invent your own, but everyone else is stuck using existing ones
14:48:41 <Taejo> pao: as far as I know, the compiler doesn't know anything about (==) besides what the definition tells it
14:48:53 <lament> especially in the context of commercial software development
14:48:56 <Peaker> lament: I wasn't using Haskell so early to know -- I don't think it has to be that much better for them to make sugar for it
14:49:02 <merijn> Look at Clojure, if Rich Hickey can do it, why wouldn't anyone else be able to
14:49:34 <pao> Taejo: thanks
14:49:37 <Cale> Well, it's sort of how languages make progress. You find out what the most common design patterns are, and work out how you might alter the foundations of the language so that those patterns can be properly abstracted and the code becomes more concise for it.
14:49:49 <lament> merijn: it's not enough to design your own language - it also needs to be better at abstraction than existing ones
14:49:54 <lament> merijn: better than haskell for example
14:49:59 <napping> I think a big part of the problem is that a number of the commonly mentioned design patterns seem more like workarounds for a weak language rather than generic advice that you wouldn't automate if you could
14:50:20 <lament> every language is a weak language; every language has workarounds
14:50:38 <lament> what matters is the patterns in the lanugage you happen to be using
14:50:46 <arw> yes, but they should be kept to a minimum
14:50:47 <lament> if it's java, nothing wrong with GoF patterns
14:50:53 <merijn> lament: Well, obviously. But you implied it's not possible to use anything except existing languages. Which is patently untrue. You don't even need to reinvent entire haskell, you could write a compiler that compiles a new language to haskell
14:51:01 <arw> the more patterns there are, the less "good" the language is.
14:51:04 <mpiechotka> Hello. I try to modify zlib from darcs. I tried both runhaskell Setup.hs install/register, It appears in ghc-pkg list but when I try to import 'module `Codec.Compression.Zlib' is not loaded'. What's wrong?
14:51:34 <lament> arw: monad transformers suggest that as the expressivity of the language increases, the patterns simply become more complex
14:51:51 <napping> mpiechotka: try again with -v and see what pacakges it looks for
14:52:11 <arw> lament: yes, of course. because everything that formerly was a pattern is now part of the language or library.
14:52:31 <lament> i mean, you can't win
14:52:33 <Taejo> :t lookup
14:52:34 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
14:52:38 <lament> there will always be patterns of some kind
14:52:39 <arw> lament: once, in times of if and goto, a counting for-loop was a pattern. now its not, except for assembler.
14:52:43 <napping> and monad transformers are at least substantially a library feature
14:52:52 <Taejo> @hoogle [(a, b)] -> a -> b
14:52:54 <lambdabot> Prelude lookup :: Eq a => a -> [(a, b)] -> Maybe b
14:52:54 <lambdabot> Data.List lookup :: Eq a => a -> [(a, b)] -> Maybe b
14:52:54 <lambdabot> Language.Haskell.TH RecConE :: Name -> [FieldExp] -> Exp
14:53:09 <lament> if your code doesn't have patterns, you have achieved perfect compression :)
14:53:12 <mpiechotka> mapping: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24029#a24029
14:53:21 <arw> lament: yes, but the only people who should learn about patterns are language designers, so they can get rid of them.
14:53:31 <lament> arw: ...
14:53:36 <napping> It's not like we type up a nice page or two about how to add a state threaded parameter to you monad, cause you can slap on a StateT
14:53:38 <lament> arw: haskell programmers shouldn't learn about monad transformers?
14:53:46 <arw> lament: ideally, no.
14:53:59 <lament> ok, back to work...
14:54:01 <arw> lament: they should learn how to use the corresponding library.
14:54:03 <mpiechotka> Ups. napping: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24029#a24029
14:54:18 <napping> Some of the design patterns seem like good ideas that are sufficiently vague you can't really automate them - like using lightweight proxy value for various things
14:54:34 <napping> other are workarounds for weaknesses of the language.
14:54:47 <Peaker> lament: Monad Transformers requires very little "patterns"
14:55:07 <napping> The first sort are genuinely valuable, the rest not so much, except perhaps to standardize
14:55:59 <benmachine> I think the word design patterns means different things to different people
14:56:02 <benmachine> um it's not a word
14:56:04 <benmachine> but
14:56:38 <napping> Actually, I've read Christopher Alexandars book in architecture, and only a few of the writeups from the Java book
14:56:47 <bos> if you can write it directly as code, it's not a design pattern
14:57:13 <lament> alexander is such a hippie
14:57:13 <Trinitron> Ah, folds in Haskell are cool.
14:57:29 <Trinitron> fold (+) [1,2,3] will give 6
14:57:38 <napping> The architecture one is very nice - and you can't just call a library to put well sized eaves on your roof
14:57:40 <monoidal> > foldl (+) 0 [1,2,3]
14:57:41 <lambdabot>   6
14:57:46 <Axman6> :t fold
14:57:47 <benmachine> > fold (+) [1,2,3]
14:57:48 <lambdabot> Not in scope: `fold'
14:57:48 <lambdabot>   Not in scope: `fold'
14:57:50 <benmachine> bah
14:57:54 <benmachine> > Data.Foldable.fold (+) [1,2,3]
14:57:55 <Axman6> there is no fold
14:57:55 <lambdabot>   No instance for (Data.Foldable.Foldable ((->) [t]))
14:57:56 <lambdabot>    arising from a use o...
14:58:01 <Cale> > foldr (+) 0 [1,2,3]
14:58:02 <lambdabot>   6
14:58:05 <benmachine> :t Data.Foldable.fold
14:58:05 <Trinitron> There is no spoon.
14:58:05 <ujihisa> foldl
14:58:06 <lambdabot> forall (t :: * -> *) m. (Data.Foldable.Foldable t, Monoid m) => t m -> m
14:58:13 <benmachine> oh of course
14:58:21 <Axman6> @instances Monoid
14:58:21 <benmachine> > Data.Foldable.foldMap Sum [1,2,3]
14:58:21 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
14:58:22 <Cale> > foldr1 (+) [1,2,3]
14:58:23 <lambdabot>   Sum {getSum = 6}
14:58:23 <lambdabot>   6
14:58:25 <napping> mpiechotka: any more information? It's hard to tell from what you've said so far, but maybe it's in the wrong registry or something?
14:58:27 <Cale> > foldl1 (+) [1,2,3]
14:58:28 <lambdabot>   6
14:58:33 <ujihisa> fo1d1
14:58:38 <ujihisa> foIdI
14:58:42 <benmachine> foldMap is pretty cool
14:58:53 <napping> mpiechotka: oh, and ghc-pkg describe zlib should tell you waht modules are actually called
14:59:14 <Trinitron> "fold" should work, it's on here: http://www.haskell.org/haskellwiki/Fold
14:59:44 <Trinitron> " For instance, we might write
14:59:44 <Trinitron> fold (+) [1,2,3,4,5]
14:59:44 <Trinitron> which would result in 1 + 2 + 3 + 4 + 5, which is 15."
15:00:27 <benmachine> that's kind of illustrative
15:00:33 <benmachine> it doesn't correspond to actual code
15:00:51 <Trinitron> Yeah, I just figured it out after reading that page more carefully.
15:01:00 <mpiechotka> napping: I sent the -v output: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24029#a24029 describe: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24030#a24030
15:01:42 <Trinitron> > foldr (+) [1,2,3]
15:01:43 <lambdabot>   No instance for (GHC.Num.Num [t])
15:01:43 <lambdabot>    arising from a use of `GHC.Num.+' at <...
15:01:50 <FliPPeh> @hpaste
15:01:50 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
15:02:00 <medfly> > foldr (+) 0 [1,2,3]
15:02:01 <lambdabot>   6
15:02:03 <FliPPeh> Hpaste is dead!
15:02:05 <FliPPeh> :(
15:02:12 <medfly> try codepad.org
15:02:18 <medfly> (hope I got that right)
15:02:18 <napping> Hmm, looks like Codec.Compression.Zlib is in exposed-modules for 0.5.2.0
15:02:20 <benmachine> http://hpaste.org/
15:02:28 <benmachine> there are like three different hpastes
15:02:38 <eevar> http://gist.github.com/
15:02:42 <benmachine> generally at least one of them survives
15:02:44 <monochrom> hpaste is dead. long live hpaste?
15:02:48 <benmachine> quite.
15:02:52 <Trinitron> > foldr (+) 1 [2,3]
15:02:53 <lambdabot>   6
15:03:12 <medfly> > foldr f 0 [1,2,3]
15:03:13 <lambdabot>   Ambiguous type variable `b' in the constraints:
15:03:13 <lambdabot>    `GHC.Num.Num b' arising ...
15:03:16 <monochrom> hpaste is probably dead. long live hpaste. <duck>
15:03:18 <medfly> > foldr f 0 [1,2,3] :: Expr
15:03:19 <FliPPeh> http://codepad.org/wP96nUTO (ignore the error it displays, it compiles fine here) - Is this a good coding style for Haskell?
15:03:19 <lambdabot>   f 1 (f 2 (f 3 0))
15:03:26 <FliPPeh> Or what could I improve?
15:03:54 <medfly> cosinelaw, :)
15:04:11 <monochrom> hahaha cosine
15:04:13 <monoidal> I'd factor putStrLn in main
15:04:28 <FliPPeh> True
15:04:41 <napping> mpiechotka: can you figure out which config file ghc-pkg is reading?
15:05:37 <mpiechotka> napping: /home/mpiechotka/.ghc/x86_64-linux-6.10.4/package.conf /usr/lib64/ghc-6.10.4/./package.conf
15:05:50 <FliPPeh> @pl x y = "" ++ (f . g) y
15:05:50 <lambdabot> x = ([] ++) . f . g
15:06:10 <napping> that does seem to match. Try -v -package zlib on ghci
15:07:11 <mpiechotka> napping: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24031#a24031
15:07:56 <napping> strange, it claims it found an linked zlib-0.5.2.0
15:08:07 <napping> are you sure you are spelling the module name correctly?
15:08:15 <napping> I usually write :m + <module>
15:08:24 <napping> I haven'd used import
15:08:46 <Trinitron> > foldl (+) [1,2,3]
15:08:47 <mpiechotka> napping: The same. I copy'n'paste from source
15:08:48 <lambdabot>   No instance for (GHC.Num.Num [t])
15:08:48 <lambdabot>    arising from a use of `GHC.Num.+' at <...
15:09:04 <Trinitron> How do you do foldl?
15:09:19 <Trinitron> foldl (+) [1,2] 3
15:09:22 <mauke> > foldl (+) 50 [1,2,3]
15:09:23 <lambdabot>   56
15:09:25 <Trinitron> > foldl (+) [1,2] 3
15:09:26 <mauke> with a base case
15:09:26 <lambdabot>   No instance for (GHC.Num.Num [[t]])
15:09:26 <lambdabot>    arising from the literal `3' at <int...
15:09:43 <FliPPeh> :t foldl
15:09:45 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
15:09:46 <FliPPeh> :t foldr
15:09:48 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
15:09:52 <mpiechotka> > foldl (+) 3 [1,2]
15:09:53 <lambdabot>   6
15:10:05 <zachk> > foldl (flip (:)) [] [1..10]
15:10:05 <Trinitron> > foldl (+) 3 [1,2]
15:10:06 <lambdabot>   6
15:10:06 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
15:10:35 <fax> I heard that lisp programmers arre like wizards but then what are haskell programmers?
15:10:54 <benmachine> there was an amusing picture about this wasn't there
15:10:56 <mauke> wizzards
15:11:05 <FliPPeh> hazards.
15:11:08 * FliPPeh runs
15:11:09 <fax> so basically normal wizards but they get more sleep?
15:11:14 <mauke> fax: nomads
15:11:17 <pikhq> fax: Magic itself.
15:11:17 <pikhq> :P
15:11:33 <medfly> haha, I vote for nomads :p
15:11:33 <fax> like african nomads but they travel through theoretical computer science instead of time?
15:11:34 <napping> Rhetors?
15:11:57 <mauke> http://blog.desudesudesu.org/?p=108
15:12:00 <xerox> nobody picks up the "people that don't fool you around and take your money" angle?
15:13:04 <Trinitron> :)
15:13:18 <Trinitron> Ah, much better. Disabled graphical smileys.
15:14:12 <FliPPeh> I never had them in IRC ;x
15:14:18 <Trinitron> Are Haskell folds similar to protein folds?
15:14:20 <FliPPeh> It doesn't match with the text-onlyness
15:14:34 <napping> That won't make much sense if you haven't read Anathem
15:15:43 <FliPPeh> It always bugged me that I could not simply mix IO (printf "Debug line here") with pure code when something doesn't work as expected.. now the same bothers me in C...
15:15:47 <FliPPeh> Mad world... mad world...
15:16:13 <napping> FliPPeh: Debug.Trace
15:16:24 <tsou> Trying to make Haskell Platform on OpenBSD, but ./configure fails with this:
15:16:24 <FliPPeh> Didn't know about that one
15:16:25 <tsou> checking for GL/gl.h... yes
15:16:25 <tsou> checking for library containing glEnd... no
15:16:30 <tsou> configure: error: The OpenGL C library is required
15:16:33 <FliPPeh> Ahhh
15:16:35 <tsou> any ideas?
15:16:40 <FliPPeh> Mh
15:16:49 <FliPPeh> Install the OpenGL C library?
15:16:55 <monochrom> You should read http://www.haskell.org/ghc/docs/latest/html/libraries/index.html from cover to cover.
15:16:58 <tensorpudding> Maybe your OpenGL library is too old.
15:17:01 <tsou> FliPPeh: it's there :P
15:17:28 <tsou> and configure found it alright (that's why i pasted the first line)
15:17:31 * FliPPeh is out of ideas
15:17:51 <tsou> and I look at gl.h, and I can see glEnd right there laughing at me
15:18:05 <Heffalump> anyone know where the repo or homepage for the "text" package lives?
15:18:20 <tensorpudding> Maybe it doesn't support something in glEnd that it needs that your GL library is too old for I guess?
15:19:38 <fax> that SomGuy on reddit is a total troll
15:20:06 <fax> I mean you don't say one thing, wait for people to reply then edit your posts to make them say something subtly different -- unless you are trolling ?
15:20:42 <mpiechotka> napping: If I clean .ghc/.cabal i still have this problem. But on root system zlib loads fine.
15:20:55 <napping> fax: sounds like something to mention inline
15:21:37 <fax> inline ?
15:22:40 <napping> fax: how do you view history?
15:22:40 * hackagebot MonadCatchIO-mtl 0.3.0.0 - Monad-transformer version of the Control.Exception module  http://hackage.haskell.org/package/MonadCatchIO-mtl-0.3.0.0 (DanielGorin)
15:22:53 <fax> napping there is no history, I just memory
15:33:24 <Taejo> @hoogle (a -> m [b]) -> a -> m [b]
15:33:25 <lambdabot> No results found
15:33:44 <fax> id ?
15:34:06 <Taejo> @hoogle (a -> m [b]) -> [a] -> m [b]
15:34:07 <lambdabot> No results found
15:34:20 <Taejo> fax: I meant concatMapM
15:34:33 <Peaker> @type (fmap concat.) . mapM
15:34:34 <lambdabot> forall a (f :: * -> *) a1. (Functor f, Monad f) => (a1 -> f [a]) -> [a1] -> f [a]
15:34:39 <mauke> :t (sequence . ) . concatMap
15:34:39 <Peaker> @type (liftM concat.) . mapM
15:34:40 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => (a1 -> [m a]) -> [a1] -> m [a]
15:34:40 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => (a1 -> m [a]) -> [a1] -> m [a]
15:35:09 <Taejo> Peaker: yeah, I was just wondering if it had a name
15:35:23 <fax> :t concatMap
15:35:25 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
15:36:06 <jgrimes> is there an easy way to recompile all of my installed packages when I upgrade ghc?
15:36:31 <sinelaw> conal, hey
15:37:31 * ivanm just read the OOP converstaion on reddit, and agrees with Cale's statement even more now that he sees it in concept
15:38:06 <ivanm> "omg, design patterns are, like, the best thing _evah_!  wtf, n00b, why aren't you using them?"
15:38:46 <Taejo> ivanm: are you talking about http://www.reddit.com/r/programming/comments/be471/how_do_you_model_things_in_objectoriented/
15:38:53 <ivanm> yes
15:40:09 <olsner> oh, what a horrible thread :(
15:42:23 <deech> Hi all, I was hoping some people here would be able to help me sell Haskell to a friend of mine.
15:42:37 <HugoDaniel> its free
15:42:38 <deech> I told him of purity, side-effects etc.
15:42:59 <fax> HASKELL VS OBJECT ORIENTED
15:43:05 <ivanm> HugoDaniel: heh
15:43:18 <benmachine> @faq can my haskell program lay golden eggs?
15:43:18 <lambdabot> The answer is: Yes! Haskell can do that.
15:43:34 <Peaker> deech: Show him some nice examples
15:43:47 <Peaker> deech: No Null dereference exceptions
15:43:55 <deech> But his specific objection was that for most coding competitions (aside from ICFP, the Google AI challenge, for example), C/C++ always seem to take home the gold.
15:43:57 <benmachine> exceptions are for suckers
15:44:16 <zachk> perl used to take home the gold in one competition until they banned it
15:44:21 <benmachine> hah
15:44:22 <deech> So therefore C/C++ must be more productinv languages.
15:44:30 <Axman6> deech: and when have competitions ever been a good way to judge the usefulness of programming languages?
15:44:32 <jlouis> deech: most coding competitions has nothing to do with the language, but with the programmer
15:44:46 <copumpkin> deech: so he thinks windows is 1000 times better than linux, I guess
15:45:05 <Taejo> deech: I use C++ in contests because I've always used C++ in contests (well, since I was in IOI training -- since IOI only allows Pascal and C++)
15:45:08 <monochrom> most competitions ban haskell to begin with.
15:45:13 <danderson> oh, nice
15:45:18 <diegoeche> deech: The ACM contest doesn't allow to use Haskell... I think it's a bit unfair
15:45:30 <danderson> apparently I won't be shaving the specific yak of cabalizing gtk2hs
15:45:30 <zachk> monochrom: they specifically ban it ?
15:45:39 <danderson> the shave is in progress by someone else :)
15:45:42 <drk-sd> Taejo: i though IOI allowed ocaml
15:45:42 <monochrom> they specifically ban everything else, too.
15:45:48 <Peaker> deech: I think in C/C++ correctness is hard, good resource management is easier, and with Haskell, it is the other way around. For small short-term projects where correctness is not that hard anyway, C/C++ may be better candidates, as they compete better on the resource side
15:45:53 <deech> Axman6: well I think the argument is that coding challenges force you to get a quick-and-dirty solution up quickly.
15:45:53 <napping> deech: Show him some Fortran performance numbers! See if  you can get him to switch
15:46:17 <monochrom> a rule that says "only c and c++" equivales a rule that says "all are banned except c and c++"
15:46:51 <deech> Peaker: Yes I'm no Haskell expert that is what I thought.
15:46:58 <zachk> i learned on ti-basic (on a ti home computer) decades ago, and i cant really stand a language such as c that has such shitty support for strings
15:46:59 <Axman6> deech: not something i'd ever encourage
15:47:18 <fax> zachk, never thought to implement your own strings?
15:47:30 <zachk> im too lazy
15:47:43 <zachk> and now i have found haskell and its lazy too
15:47:45 <jlouis> zachk: then Haskell is the right language for you
15:47:49 <zachk> so we get along good
15:47:55 <fax> zachk, I put a little library together which worked kind of liks input output streams, that was really nice EVEN IN C
15:48:13 <monochrom> a competition that bans haskell is a competition that suggests "haskell would make our problems trivial"
15:48:19 <fax> if you can't stand C think of it this way: YOu are just programming in simply typed lambda calculus
15:48:34 <jlouis> without the lambda :)
15:48:35 <fax> (with some restrictions and caveats of course)
15:48:43 <benmachine> lambda calculus has HOFs at least
15:48:47 <deech> I think I will encourage him to check out the Haskell's C FFI.
15:49:04 <deech> Although it cannot compete with C++'s C "FFI"!
15:49:08 <zachk> when i really wanted to learn C i was getting strange errors, then i learned latter that the people who made our computer had superglued the processor hotsink to a pentium 100 and overclocked it to pentium 133
15:49:09 <napping> oh, good point. It is one of the most direct I've seen
15:49:12 <fax> other approach would be implement it in haskell and call out from the C program :P
15:49:31 <napping> even compared to fairly nice ones like Lua
15:49:44 <Axman6> deech: biut you'll just be encouraging him to use C...
15:49:45 <napping> well, I guess it has you do the interfacing work on the Haskell rather than C side
15:49:46 <Axman6> 0i
15:49:48 <Axman6> -i*
15:50:13 <deech> Axman6: Babysteps I guess.
15:50:21 <benmachine> the FFI is probably not good for newbie programmers because the importance of IO and so forth will be less clear to them
15:50:24 <benmachine> imo
15:50:33 <Taejo> monochrom: there is definitely a problem with languages making contest problems trivial/impossible
15:50:45 <benmachine> they might do things like readFile :: FilePath -> String and not understand why it goes wrong
15:50:52 <napping> but seriously, C compilers can't optimize loops nearly as well as Fortran, and Co-array fortran seems to actually be competitive with MPI, unlike any of the UPC things people push
15:50:55 <benmachine> *foreign import readFile
15:51:47 <Taejo> I was once in a contest that had a date handling problem (how many days between dd/mm/yyyy and DD/MM/YYY) and it said "NOTE: Built-in libraries for date-handling are often buggy so we suggest implementing your own"
15:52:01 <benmachine> ahaha
15:52:02 <benmachine> nice
15:52:04 <Axman6> o.O
15:52:08 <monochrom> I know a highschool teacher who ran a contest and the rationale of sticking with c, c++, pascal was explicitly and emphatically "this is a contest of how well you can implement data structures yourselves as opposed to just using Java libs" and hence java was disallow. Now you see what is so productive it is.
15:52:12 <Axman6> well, that's good to hear
15:52:25 <Axman6> built in libraries shouldn't be buggy >_<
15:52:28 <monochrom> s/what is so productive it is/what is so productive about it/
15:52:41 <Taejo> I said, bugger that, the chance of me doing a better job in an hour than the twenty years of Python developers is less than epsilon
15:52:53 <Taejo> and solved the problem in about two minutes
15:52:59 <jlouis> Yeah, Vuze is 490k lines of Java, HaskellTorrent is 3.1k lines :)
15:52:59 <Taejo> (Haskell wasn't allowed)
15:53:39 * benmachine likes "less than epsilon" and may start using it
15:53:39 <deech> I think that's what's so cool about Haskell, it's amazingly productive with a fraction of the support that C++ gets from the STL.
15:53:50 <Saizan> jlouis: you're reaching the size of a window manager!
15:53:53 <arw> time/date handling is a particularly nasty subject. i once read a 30 page paper about why nobody should try it at home, and i'm sufficiently scared by that not to try...
15:53:54 * fax doesn't let epsilon > 0
15:54:23 <arw> (and yes, i have tried and failed)
15:54:24 <jlouis> Saizan: unfortunately :)
15:54:41 <Taejo> arw: even without time zones and DST?
15:54:50 <benmachine> and leap seconds
15:54:59 <Taejo> ah yes
15:55:06 <arw> Taejo: without timezones and dst, but with leap seconds and astronomy.
15:55:12 <ddarius> jlouis: The problem with Vuze is it is not importing java.util.BitTorrent.
15:55:13 <Taejo> ah ok
15:55:14 <jlouis> deech: productive, fun, has excellent community, large library base
15:55:15 <monoidal> arw: do you remember the title?
15:55:28 <benmachine> haskell's community is unparalleled
15:55:38 <jlouis> ddarius: they did import it, but it was buggy as hell
15:55:41 <benmachine> #python are a bunch of grumpy old men so far as I can tell >_>
15:55:43 <Taejo> this problem was whole days only, so leap years but no leap seconds, timezones, dst
15:55:46 <fax> NO LOL
15:55:52 <fax> ;P
15:55:54 <benmachine> exactly.
15:55:58 <deech> jlouis: yes, great people, great libraries and not as framework-y as Java or C++
15:55:58 <ddarius> Haskell's community exists in a spherical space.
15:56:33 <arw> monoidal: not really. i'm trying to find it again via google...
15:56:35 <DigitalKiwi> #lua and #haskell are the nicest programming language channels I've seen
15:56:42 <mreh> what's the Euler number in haskell?
15:56:47 <jlouis> deech: oh and another point: concurrency and parallellism is one of the places where Haskell is probably farther than any other language
15:56:54 <Peaker> Python's channel is generally OK except for a few annoying guys
15:56:58 <[swift]_> DigitalKiwi: i have to agree
15:57:01 <deech> jlouis: agreed.
15:57:09 <[swift]_> i've seen some negativity in the python channel haha
15:57:09 <benmachine> jlouis: isn't erlang supposed to be concurrency incarnate?
15:57:16 <[swift]_> this channel is always pretty positive tho
15:57:32 <mreh> software transactional memory FTW!
15:57:45 <benmachine> Peaker: yeah there are worse but it's not somewhere I'd hang out just to have a chat
15:57:48 <jlouis> benmachine: yes, if you want asynchronous message passing. Haskell has that, STM, synchronous MP, data parallellism, etc
15:57:51 <mreh> > e :: Double
15:57:56 <mreh> @bots
15:58:13 <lambdabot> :)
15:58:13 <deech> I did a little hackfest where I used Haskell and the Supercollider sound server to make music. I had to write a bunch of stuff in Haskell to make notes, scales, beats etc. And it never crashed!
15:58:14 <lambdabot>   Couldn't match expected type `GHC.Types.Double'
15:58:15 <lambdabot>         against inferred ty...
15:58:22 <benmachine> lb seems a little behind
15:58:28 <deech> And I am not *that* good of a programmer.
15:58:44 <mreh> deech: are you a musician?
15:59:02 <deech> mreh: yup, not professionally.
15:59:04 <napping> um, you have to be pretty clever to get haskell to crash
15:59:24 <deech> napping: by crash I meant no bugs
15:59:24 <benmachine> depends what you mean by crash
15:59:31 <mreh> > foldl (+) 0 [1..]
15:59:34 <benmachine> error "lol" --> crash
15:59:37 <lambdabot>   mueval-core: Time limit exceeded
15:59:39 <napping> Ah, no bugs is a bit stronger
15:59:44 <mreh> ^^ crash
15:59:56 <napping> making a haskell program that *does* segfault is harder
16:00:00 <benmachine> my current project crashes all over the place, but always intentionally
16:00:09 <benmachine> segfaults are not that hard if you know where to look :P
16:00:15 <Taejo> yeah
16:00:16 <mreh> > error "crashing."
16:00:18 <lambdabot>   * Exception: crashing.
16:00:19 <c_wraith> you can segfault ghci with "unsafeCoerce () ()"
16:00:19 <benmachine> (particularly: anything beginning with "unsafe"
16:00:21 <c_wraith> :)
16:00:22 <benmachine> )
16:00:40 <deech> napping: And the logic held with very little testing.
16:00:41 <mreh> benmachine: is it a rally simulation?
16:00:43 <napping> Yeah, without unsafeCoerce and Ptr-equivalents
16:00:49 <benmachine> mreh: yes, yes it is.
16:01:11 <benmachine> unsafePerformIO?
16:01:13 <napping> I think you can fake out Dynamic with a bad Typeable instance
16:01:17 <mreh> if your stock-car racing simulator didn't crash all over the place, there would be something terribly wrong
16:01:19 <benmachine> yeah, and cast
16:01:23 <napping> oh, unsafePerformIO is not typesafe either
16:01:23 <ivanm> preflex: seen dobblego
16:01:23 <preflex>  dobblego was last seen on #haskell 1 day, 46 minutes and 33 seconds ago, saying: and so now we have this
16:01:33 <mreh> how can I get the Euler number?
16:01:41 <benmachine> it takes a little determination to segfault haskell though
16:01:41 <deech> And laziness allowed me generate an infinite number of pitches in whatever scale I wanted.
16:01:59 <benmachine> rather than in C where it takes an extraordinary amount of determination to stop it from doing so :)
16:02:17 <mreh> just stay away from the terminal
16:02:47 <mreh> do I have to approximate 'e' myself then?
16:02:56 <c_wraith> > log 1
16:02:59 <copumpkin> > exp 1
16:03:00 <lambdabot>   0.0
16:03:01 <benmachine> > exp 1
16:03:06 <Peaker> if you don't use unsafe* or bad FFI bindings, how do you make Haskell segfault?
16:03:06 <c_wraith> err, wrong function.  hah. :)
16:03:27 <c_wraith> also, \bot just died
16:03:28 <bremner_> > head []
16:03:30 <benmachine> Peaker: cast and Dynamic both can, but only by using unsafe
16:03:39 <napping> well, the Foreign.Ptr stuff is not technically named unsafe
16:03:50 <bremner_> head of empty list is kind of a moral equivalent of segfault
16:03:59 <mreh> exp n is e^n, that's even better
16:03:59 <benmachine> not really
16:04:11 <napping> also, you can handwrite a Typeable instance that returns the typeinfo for another type, and then dynamic will let you cast between them, I think
16:04:22 <deech> I've been wondering, is there some way of list of decreasing numbers so [1 .. ] => [1,0,-1,-2,-3 ...]
16:04:26 <benmachine> yeah
16:04:38 <monochrom> [1, 0..]
16:04:38 <copumpkin> > [1,0..]
16:04:39 <lambdabot>   2.718281828459045
16:04:41 <benmachine> or you can make a newtype wrapper with a Typeable that ignores what's inside it
16:04:48 <benmachine> and then cast anything to anything else
16:04:53 <Veinor> 19:04:14 < copumpkin> > [1,0..]
16:04:55 <Veinor> 19:04:15 < lambdabot>   2.718281828459045
16:04:58 <Veinor> what the hell?
16:05:00 <deech> cool, thanks!
16:05:02 <lambdabot>   * Exception: Prelude.head: empty list
16:05:02 <lambdabot>   2.718281828459045
16:05:04 <copumpkin> Veinor: it's lagging
16:05:04 <monochrom> This is so wrong!
16:05:06 <lambdabot>   [1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20...
16:05:07 <Veinor> ahh.
16:05:13 <monochrom> hahaha
16:06:08 <ivanm> Axman6: dibblego says he's unlikely to come to ozhackathon :(
16:07:15 <Japsu> @djinn Char -> Int
16:07:42 <mauke> :t ord
16:08:05 <ivanm> @type ord
16:08:08 <ivanm> @bot
16:08:11 <Japsu> :(
16:08:16 <mauke> preflex: seen Cale
16:08:17 <preflex>  Cale was last seen on #haskell 1 hour, 9 minutes and 50 seconds ago, saying: > foldl1 (+) [1,2,3]
16:08:17 <ivanm> that's it, who's playing up with lambdabot this time?
16:08:31 <Cale> hmm
16:08:35 * ivanm blames #pugs, etc.
16:09:28 <lambdabot> Error: Undefined type Char
16:09:28 <lambdabot> Char -> Int
16:09:50 <Cale> It's still up, just massive lag.
16:11:27 <mauke> > ord '@'
16:18:05 <fax> Wow I just saw category theory in the wild
16:18:07 <fax> http://terrytao.wordpress.com/career-advice/there%E2%80%99s-more-to-mathematics-than-rigour-and-proofs/
16:18:12 <fax> pre-rigorous â> rigorous
16:18:12 <fax> | â¦â¦â¦â¦â¦â¦â¦â¦â¦.|
16:18:12 <fax> v â¦â¦â¦â¦â¦â¦â¦â¦â¦.v
16:18:13 <fax> heuristic â> post-rigorous
16:18:22 <fax> that comment  ^ it is 'almost' a commutative diagram
16:18:29 <fax> sort of like haskell is 'almost' a category
16:18:55 <fax> so maybe category theory is to give you intuition about things (like haskell programming) even if it's not completely precise?
16:19:44 <uorygl> I wonder how in Haskell one would implement mutable data structures with pointers to each other.
16:20:00 <copumpkin> using ST/IORefs
16:20:43 <fax> you can't implement mutation in haskell
16:20:49 <fax> so has to be what pumpkin says
16:22:05 <mail> anyone familiar with regular expressions describing regular languages
16:22:10 <c_wraith> In order to see that ST uses mutation, you have to do something unsafe.  But you only need concurrency to see that IO uses mutation.
16:22:19 <ivanm> fax: great reversal there ;-)
16:22:20 <ddarius> fax: A lot of "complaints" about category theory is that it "reduces mathematics to computation," so I'm inclined to disagree with you.
16:23:01 <ivanm> Cale: WE CAN HAZ BOT PLZ? KTHNX BYE
16:23:10 <ajones> I have a question about undecidable instances
16:23:31 <ajones> actually about a case where I don't think I should need them, but the compiler believes I do.
16:23:32 <fax> ivanm what ?
16:23:35 <ivanm> that's a coincidence, someone here might have an answer ;-)
16:23:49 <ivanm> fax: from "you can't implement mutation in Haskell" to "you can, if you use what copumpkin said"
16:23:55 <fax> ddarius; I don't know what you mean :(
16:24:04 <fax> ivanm, nah
16:24:15 <MaciejP> mail: What do you want to know?
16:24:26 <Saizan> ajones: code?
16:24:32 <ajones> http://haskell.pastebin.com/g3VHCXjU
16:24:34 <mail> don't worry found the answer
16:24:38 <Taejo> :t modify
16:24:39 <ajones> Sazan^^
16:24:47 <lambdabot> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
16:24:49 <ajones> err, Saizan^^
16:25:22 <ajones> the DataClassifier at the bottom is the only piece that needs them, but I don't think it should.
16:25:44 <ajones> i.e. the classes, attributes, and values are all uniquely determined from the data.
16:25:55 * ivanm hopes that isn't a minimal case... ;-)
16:26:15 <ajones> oh no, it isn't.
16:26:20 <ivanm> ajones: I think you want a fundep or associated types...
16:26:36 <Saizan> ajones: how is DataClassifier defined?
16:26:41 <ivanm> oh, you are using fundeps
16:26:43 <ivanm> just not there...
16:26:57 <fax> ivanm, dunno if you ever looked into how ST and stuff are implemented
16:27:04 <fax> they're built ins
16:27:05 <ajones> Saizan: i'll see if I can pull out something small.
16:27:13 <fax> you can't implement in a pure way, what I said was true
16:27:20 <ajones> class (ClassifiableData d c a v, Classifier b c a v) => DataClassifier b d c a v | d -> b c a v where
16:27:25 <fax> (and pretty obvious)
16:27:45 <Saizan> ajones: does the error say something about the coverage condition?
16:27:48 <copumpkin> that's a pretty epic classifier class
16:27:51 <ajones> Saizan: yes
16:28:15 <ivanm> fax: yes, so you can have mutation
16:28:16 <Saizan> ajones: ok, it's widely known that the coverage condition is too strict, but they didn't find a better heuristic
16:28:23 <ajones> copumpkin: that's just the subset dealing with data instances.
16:28:25 <ivanm> you just need to do it within IO or ST
16:28:28 <copumpkin> :o
16:28:38 <Saizan> ajones: there's a proper description of the condition in ghc's manual
16:28:47 <ivanm> ajones: I think you need to have a fundep for every value...
16:28:53 <ivanm> | d -> b, d -> c, etc.
16:28:58 <Saizan> nah
16:28:59 <ivanm> or else use associated types
16:29:14 <Saizan> he just needs to stick that UndecidableInstances up there :)
16:29:20 <ajones> ivanm: I actually changed from that to this.
16:29:27 <ivanm> heh
16:29:35 <copumpkin> ajones: Saizan told you where to stick UndecidableInstances
16:29:39 <ajones> Saizan: I guess my real question is, do I need to?
16:29:42 <copumpkin> :P
16:29:42 <ivanm> ajones: fundeps are on the way out, anyway...
16:29:48 <ivanm> (not yet, but eventually)
16:29:49 <copumpkin> ivanm: no they aren't :P
16:30:00 <ajones> i.e. is it: 1) I'm missing some reason why I legitimately need them
16:30:01 <mreh> who knows a signal functions (yampa) that will return an Event value until a new Event comes along
16:30:11 <ivanm> copumpkin: oh? I thought they were being replaced with associated types once the constraint stuff, etc. if finished
16:30:17 <ivanm> (i.e. type checker is improved)
16:30:22 <copumpkin> I don't think they should be
16:30:28 <copumpkin> they'll eventually be equivalent in power
16:30:52 <Saizan> ajones: ghc uses some simple heuristics to restrict instances to guarantee termination of instance resolution
16:31:14 <Saizan> ajones: the fact that your instances don't fit these heuristics doesn't actually mean much
16:31:35 <ajones> Saizan: ok, just didn't want to start out assuming I was smarter than the compiler.
16:31:46 <mtnviewmark> anyone here familiar with using the CGI package?
16:32:05 <ajones> flipping that second letter from 'c' to 'h' kind of kills that assumption for me.
16:32:06 <mtnviewmark> I'm having a bizarre outcome where my error messages are logged one character at a time into apache's log file
16:32:22 <ivanm> copumpkin: you prefer fundeps then?
16:32:27 <Saizan> ajones: nah, it's an halting problem, you _are_ "smarter" than the compiler :)
16:32:56 <ajones> Saizan: by "smarter" I meant "know more about the decidability of my instances, thank you very much"
16:33:27 <copumpkin> ivanm: nope, but I see them as representing things in different ways. Typeclasses are type relations, fundeps allow you to specify restrictions on those relations, and type families give us special access to a particular kind of relation we use a lot called a functional :P
16:33:36 <copumpkin> s/functional/function/
16:33:50 <ivanm> hmmm...
16:33:53 <copumpkin> sometimes it's more meaningful to represent something as a relation
16:33:59 <copumpkin> others it's nicer as a function
16:34:03 <ivanm> don't see how associated types inside classes give you a function...
16:34:18 <copumpkin> associated types are just type families
16:34:30 <ivanm> oh, functions between types?
16:34:32 <copumpkin> yeah
16:34:38 <ajones> fwiw I can easily understand fundeps, have yet to find something that helps me achieve this state with type families.
16:34:43 <ivanm> and whilt associated types are more verbose, I find fundep notation messy
16:34:53 <ajones> that could just be me though.
16:34:53 <Cale> ajones: btw,  id $! x is the same as x `seq` id x, which is the same as x `seq` x which is the same as x
16:34:58 <ivanm> especially since there's no way of knowing when you write an instance that there is a fundep
16:35:11 <ivanm> Cale: well, same value...
16:35:21 <Cale> ivanm: No, operationally equivalent
16:35:37 <ajones> Cale: point was to ensure strictness, I take it that doesn't happen?
16:35:42 <ivanm> but $! and seq do some forcing....
16:36:00 <Saizan> "x `seq` x" means "force x when you force x"
16:36:10 <Cale> ivanm: If you were going to force id $! x, you would have been forcing x anyway
16:36:10 <ajones> ahh
16:36:30 <ivanm> Cale: oh, wait, I missed the "id" there in id $! x
16:36:36 * ivanm facepalms
16:36:45 <Cale> yeah, id is already as strict as can be ;)
16:37:17 <ddarius> I believe you can do a double dispatch type trick to get the same effect as a relation using associated types.
16:37:46 <copumpkin> you can simulate them in both ways, as far as I can see
16:37:52 <copumpkin> but sometimes it's more natural to do it one way than another
16:37:54 <Saizan> double dispatch? two functions?
16:38:07 <ddarius> Roughly corresponding to representing R â XÃY as X -> â(Y)
16:38:12 <copumpkin> x `GT` y vs x `GT` y ~ True or something
16:38:17 <ddarius> copumpkin: I agree.
16:38:39 <ajones> I take it I shouldn't really bother with annotating for strictness then?
16:38:50 <ivanm> Axman6: what did you think of my type-class mini-tutorial in streams?
16:39:06 <ajones> Trying to turn some code from a machine learning class into something useful on hackage ... there's a lot of mess to clean up.
16:39:08 <Axman6> i haven't seen it
16:39:47 <applicative> mtnviewmark: that's pretty hilarious, can you paste the module that is doing this?
16:40:03 <fax> ddarius, maybe people don't like mathematics being reduced to computation because it means they have to do horribly difficult computations by hand during exams?
16:40:15 <ivanm> Axman6: it's in the "what does => mean" thread
16:40:22 <Saizan> ajones: yeah, all those id $! are simply redundant
16:40:35 <copumpkin> ivanm: you should teach typeclasses with monads!
16:40:39 <Saizan> ajones: there's really nothing to strictify there
16:40:43 <ivanm> copumpkin: *shudder*
16:40:47 <ajones> Saizan: good to know ... and here I was thinking I was smarter than hlint
16:40:56 <ivanm> copumpkin: "a monad is like a typeclass ..."
16:41:40 <copumpkin> has anyone played with adding typeclasses to hask using topoi?
16:42:01 * ivanm has no idea what hask and topoi are
16:42:08 <fax> can topoi do that??
16:42:16 <copumpkin> fax: not sure :)
16:42:25 <ddarius> fax: Mathematicians don't like mathematics reduced to calculation because it (seems to) devalue what they do.  Anyway, CT doesn't actually do that, though it tends to have a much more constructive feel and does significantly trivialize some formerly clever arguments.
16:42:26 <copumpkin> topoi can have relations over them
16:42:32 <copumpkin> and typeclasses can be seen as relations
16:42:52 <mtnviewmark> @applicative: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24034#a24034
16:42:52 <lambdabot> Unknown command, try @list
16:43:00 <copumpkin> but not sure how it would fit with the view of polymorphism as a natural transformation
16:43:24 <fax> I am enjoying reading about it and stuff but I don't think I realyl understand any of it
16:43:27 <ivanm> copumpkin: what's topoi?
16:43:30 <mtnviewmark> basically - catches an SQL error, calls logCGI on (show of it) and then throws something more "benign"
16:43:38 <ddarius> copumpkin: Toposes are significant overkill just to talk about relations.
16:43:41 <Cale> I think mathematicians like mathematics reduced to calculation where it really makes sense to do so.
16:43:51 <copumpkin> ivanm: it's the plural of topos, which is a category with additional structure
16:43:57 <ivanm> ahhh
16:44:08 * ivanm was trying to find some tool called topoi...
16:44:48 <Cale> There is such a thing as an excessive amount of formalism though.
16:44:59 <copumpkin> ddarius: yeah, mybe
16:45:14 <copumpkin> ddarius: has anyone attempted to integrate typeclasses into hask in any way?
16:45:21 <mtnviewmark> I'm wondering if logCGI is somehow using lazyIO under the hood... and causing the show to be lazily computed
16:45:29 <copumpkin> are the typeclasses just seen as separate categories?
16:45:30 <fax> copumpkin isn't that what haskell is ?
16:45:49 <ddarius> copumpkin: There aren't too many semantics for type classes at all.
16:46:45 <mm_freak> in times of the cabal command line utility is it really necessary/recommended to provide a setup.lhs?
16:47:10 <Peaker> Maybe there should be different words for the semantics of mutation (Which for example the State monad gives) and the machine's destructive write fast implementation of mutation...  Sometimes people want to model mutation but don't care about how it's implemented in the machine, and vice versa, but people misunderstand statements such as "no mutation in Haskell"
16:47:14 <benmachine> I didn't have one in my project until I had to install somewhere that didn't have cabal-install
16:47:29 <benmachine> runhaskell Setup.hs works on any system with GHC
16:47:56 <mm_freak> hmm, ok
16:48:18 <ajones> ugh, just realized I have nothing for haddock to look at in this pair of monster typeclasses.
16:48:46 <ajones> ... guess any decent member of hackage needs this, huh?
16:48:49 <Axman6> ivanm: your explanations of type classes is too complex for the people taking this course
16:48:57 <ivanm> :(
16:48:58 <applicative> > show "hahah"
16:48:59 <lambdabot>   "\"hahah\""
16:49:02 <copumpkin> > fix show
16:49:04 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
16:49:04 <ivanm> but I tried to dumb it down as much as possible!
16:49:11 <copumpkin> ivanm: you're not dumb enough
16:49:13 <ivanm> since my previous explanation was obviously not understood
16:49:16 <ivanm> copumpkin: obviously
16:49:25 <ivanm> and thank you for the backhanded compliment! :D
16:49:38 <copumpkin> :P
16:51:05 <ajones> Axman6: if it doesn't disgust everyone *too* much, I understood them a lot better after looking at CLOS generic functions
16:51:05 <ddarius> So people who write "typeclasses," are you going to write "typeconstructorclasses" or "constructorclasses" when you want to be more precise/accurate?
16:51:13 <m0nkfish> > fix (.)
16:51:14 <lambdabot>   Occurs check: cannot construct the infinite type: a = f a
16:51:18 <m0nkfish> ;_;
16:51:34 <Axman6> > fix (id .) 1
16:51:35 <ivanm> Axman6: well, my first go failed, clem's go failed, so I decided to go more in-depth
16:51:38 <lambdabot>   mueval-core: Time limit exceeded
16:51:40 <mtnviewmark> if I have   foo (show x)   and I want the value of show x to be certain to evaluated to a string before foo is called
16:52:02 <mtnviewmark> do i need to do something like        let s = show x in length s `seq` foo s
16:52:11 <ivanm> foo $! show x ?
16:52:16 <dmwit> Yes, or Control.Parallel.Strategies
16:52:19 <ivanm> mtnviewmark: any particular reason it has to be evaluated first?
16:52:21 <dmwit> ivanm: not good enough
16:52:27 <ivanm> dmwit: yeah, actually, since that will go to rnf
16:52:46 <mtnviewmark> ivanm because foo is (or ends up being
16:52:47 <dmwit> What, really?
16:52:50 <dmwit> ?src ($!)
16:52:51 <lambdabot> f $! x = x `seq` f x
16:52:56 <dmwit> ivanm: no...
16:53:11 <ivanm> dmwit: I meant Control.Parallel.Strategies would let you got o rnf ;-)
16:53:12 <mtnviewmark> hPutStrLn stderr s
16:53:14 <ivanm> *go to
16:53:15 <dmwit> oh =)
16:53:34 <ivanm> mtnviewmark: so? why do you need the String to be evaluated strictly?
16:53:35 <mtnviewmark> and it looks like hPutStrLn is outputting the result to stderr piecemeal as show is computed
16:53:51 <ivanm> is your value that complex?
16:53:55 <ivanm> @hackage deepseq
16:53:55 <mtnviewmark> and THAT is causing the logger at the other end of stderr to log the error message one or two characters at a time !
16:53:55 <lambdabot> http://hackage.haskell.org/package/deepseq
16:53:57 <ivanm> mtnviewmark: ^^
16:54:22 <mtnviewmark> right - I was hoping that calling length on a string was good enough --- for strings, not in general
16:54:51 <dmwit> mtnviewmark: length will get you the spine of the String (which, in most cases, is also as good as the String itself).
16:54:59 <mtnviewmark> I suppose I could fiddle with buffering flags on stderr ... as well...
16:55:13 <mtnviewmark> right - I think it is in this case (it is just a normal string, eh)
16:55:17 <mreh> :t if'
16:55:18 <lambdabot> Not in scope: `if''
16:55:28 <mreh> ((* (-3.0)) . fromIntegral . fromEnum) -- need a shorter way of writing this
16:55:40 <mreh> it takes a boolean
16:55:51 <Axman6> ivanm: see my reply
16:55:55 <dmwit> \p -> if p then -3 else 0
16:55:55 * Axman6 heads off
16:56:00 <copumpkin> mreh: eugh
16:56:02 <dmwit> mreh: That is already shorter, and way more readable.
16:56:11 <mreh> agreed
16:56:14 <copumpkin> x True = -3; x False = 0
16:56:33 <dmwit> :t \p -> sum [-3 | p]
16:56:34 <lambdabot> forall a. (Num a) => Bool -> a
16:56:37 <dmwit> haha!
16:56:45 <copumpkin> lol
16:57:03 * copumpkin is impressed
16:57:15 <tomh-> anyone has a nice oneliner for a list of random numbers?
16:57:18 <c_wraith> yay abuse of list comprehensions
16:57:23 <dmwit> tomh-: randomRs
16:57:33 <tomh-> cool
16:57:39 <tomh-> let me look that up
16:57:44 <Veinor> dmwit: that's atrocious!
16:57:51 <dmwit> Veinor: Thank you!
16:58:04 <ivanm> Axman6: so a condensed version of mine (though I avoided bringing up the different numeric classes)
16:58:10 <ivanm> without the rationale, etc.
16:59:41 <mtnviewmark> fie - that didn't fix it
17:00:15 <dmwit> mtnviewmark: You do know that stderr is NoBuffering by default (for good reason), right?
17:00:47 <dmwit> So "printing one or two characters at a time" is the expected behavior.
17:01:09 <Bassetts> hi, could someone give me a hand compiling a haskell program? I have attempted to but what the binary outputs is different to what is expexted and what I get in ghc
17:01:26 <Bassetts> s/expexted/expected/
17:01:42 <dmwit> Bassetts: "ghc --make" should be good enough for most simple programs.
17:02:00 <ajones> Bassetts: how is what the binary outputs different?
17:02:21 <ajones> also, what dmwit said.
17:02:43 <Bassetts> I  will paste an example
17:03:05 <fax> > let square x = x*x in  sqrt . (/6) . sum . map square $ [1..]
17:03:09 <lambdabot>   mueval-core: Time limit exceeded
17:03:11 <dmwit> Taking a wild stab in the dark: the main difference between ghci and ghc-compiled binaries is that output is buffered by default for compiled binaries but not for ghci.
17:03:12 <fax> > let square x = x*x in  sqrt . (/6) . sum . map square $ [1..50]
17:03:15 <lambdabot>   84.58230705452924
17:03:31 <fax> > let square x = x*x in  sqrt . (*6) . sum . map ((1/) . square) $ [1..50]
17:03:32 <lambdabot>   3.1226265229337264
17:03:35 <copumpkin> :o
17:03:37 <fax> > let square x = x*x in  sqrt . (*6) . sum . map ((1/) . square) $ [1..200]
17:03:39 <lambdabot>   3.136826306330968
17:03:43 <copumpkin> zomg
17:03:51 <fax> close enough for government work?
17:03:54 <dmwit> > sqrt . (/6) . sum . map (^2) $ [1..50]
17:03:55 <copumpkin> yep
17:03:55 <lambdabot>   84.58230705452924
17:04:08 <fax> > let square x = x*x in  sqrt . (*6) . sum . map ((1/) . square) $ [1..2000]
17:04:09 <lambdabot>   3.1411152718364823
17:04:09 <Bassetts> dmwit: http://dpaste.com/172722/
17:04:10 <ajones> I really need to work up a "don't notify me about chat that's really just people torturing lambdabot" extension to my irc.
17:04:14 <fax> 3.141!
17:04:43 <dmwit> Bassetts: Yep, looks like a buffering issue to me.
17:04:47 <ajones> yep
17:04:55 <ajones> "hFlush stdout" should do the trick.
17:04:56 <dmwit> Bassetts: Add some calls to hFlush, or hSetBuffering stdout NoBuffering.
17:04:59 <mtnviewmark> dmwit - hmmm... I wonder how Apache2 is handling CGI output on stderr....
17:05:05 <Peaker> fax: how does this relationship come about?
17:05:16 <mtnviewmark> actually - I'd want it line buffered
17:05:26 <dmwit> > sqrt . (*6) . sum . map (recip . (^2)) $ [1..2000]
17:05:27 <tomh-> mm how does that randomRs work, it takes a range of (min,max) and it generates an infinite list of numbers in that interval?
17:05:27 <lambdabot>   3.1411152718364823
17:05:36 <dmwit> tomh-: exactly
17:05:36 <Bassetts> thanks dmwit
17:05:44 <eevar> > take 10 $ randomRs (0, 100) $ mkStdGen 42
17:05:45 <lambdabot>   [25,87,93,25,28,30,4,74,51,36]
17:05:46 <twink> Not sure why square vs. join (*) or (^2)
17:06:01 <fax> Peaker, I have no idea! I think it's something to do with fundamenal theorem of arithmetic and reimann zeta function -- here's a proof of it though http://mathbin.net/44655
17:06:01 <Peaker> > sqrt . sum . map ((6/) . (^2)) $ [1..20000]
17:06:03 <lambdabot>   3.1415449079376874
17:06:05 <dmwit> twink: Me either, nor why (1/) vs. recip. ;-)
17:06:13 <tomh-> cool
17:06:28 <tomh-> :t take 10 $ randomRs (0, 100) $ mkStdGen 42
17:06:29 <Zao> @type ((*),(^))
17:06:29 <lambdabot> forall a. (Num a, Random a) => [a]
17:06:30 <lambdabot> forall a a1 b. (Num a, Num a1, Integral b) => (a -> a -> a, a1 -> b -> a1)
17:06:52 <tomh-> @type take 10 $ randomRs (0, 100) $ mkStdGen 42
17:06:53 <lambdabot> forall a. (Num a, Random a) => [a]
17:07:08 <tomh-> its not IO [a] or something?
17:07:17 <dmwit> tomh-: Nope, it's pure.
17:07:29 <Peaker> tomh-: why would you need IO for pseudo random generation?
17:07:30 <tomh-> nice
17:07:30 <dmwit> tomh-: Notice that you're passing in a generator seed.
17:07:39 <tomh-> yeah
17:07:53 <tomh-> if I would use newStdGen I would have to wrap it in a monad I guess
17:08:08 <c_wraith> Only the part that calls newStdGen
17:08:13 <c_wraith> the part that *uses* it can be pure
17:08:15 <dmwit> Not just any monad, but IO in particular. ;-)
17:08:24 <tomh-> yeah
17:08:51 <tomh-> its really anoying I forget all my haskell knowledge after not using it for a couple of months :(
17:09:07 <dmwit> Solution: use it every day! =D
17:09:13 <dmwit> ...or every month
17:09:26 <tomh-> i will be using it every day from now on
17:09:52 <tomh-> just have to do a small catch up session again I guess
17:10:33 <mtnviewmark> AHA -
17:10:42 <mtnviewmark> the answer was: calling      hSetBuffering stderr LineBuffering
17:10:46 <mtnviewmark> before calling     runCGI
17:12:23 <jgrimes> is Hayoo open source? I can't seem to find the src if so
17:14:44 <nus> @where holumbus
17:14:44 <lambdabot> I know nothing about holumbus.
17:15:19 <ajones> @where waldo
17:15:20 <lambdabot> I know nothing about waldo.
17:15:27 <ajones> @where Jimmy Hoffa
17:15:28 <lambdabot> I know nothing about jimmy.
17:15:28 <garious> Anybody know where the preprocessor is in the GHC source code?
17:15:32 <ajones> I KNEW IT!!
17:15:38 <nus> @where hayoo
17:15:38 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
17:15:44 <copumpkin> garious: it just calls gcc I think
17:16:02 <copumpkin> there's a pure haskell preprocessor too
17:16:11 <nus> preflex, seen Syzigy-
17:16:11 <preflex>  Sorry, I haven't seen Syzigy-
17:16:19 <nus> preflex, seen Syzygy-
17:16:19 <preflex>  Sorry, I haven't seen Syzygy-
17:16:29 <garious> copumpkin: ok, thanks.  yeah cpphs but gpl'ed
17:16:35 <copumpkin> ah
17:16:36 <NEEDMOAR> Does "deriving Functor" exist?
17:16:43 <copumpkin> NEEDMOAR: as of 6.12
17:16:45 <c_wraith> In 6.12, it does
17:16:51 <ajones> ?!
17:16:51 <lambdabot> Maybe you meant: . ? @ v
17:17:06 <NEEDMOAR> Oh, thanks.
17:17:23 <monochrom> deriving Funky
17:20:54 <twink> I had no idea that was going on in the emacs world.
17:21:09 <ajones> twink: ??
17:21:20 <twink> Sorry meant for -blah
17:23:24 <monoidal> anyone know if/when Haskell Platform will be for 6.12?
17:23:43 <c_wraith> I heard "end of the month" rumors.  I don't recall if they sounded reliable
17:24:04 <c_wraith> So pretend I didn't say that, because I don't want to start rumors if I'm imagining things :)
17:24:10 <monoidal> :)
17:26:21 <ajones> ok, design question time.
17:27:10 <ajones> I have typeclass for a naive bayesian classifier that allows instances to only define update/probability/etc operations on a single (attribute,value) pair.
17:27:36 <ajones> but, it does this by passing in the entire set of attribute/value pairs for a given piece of data.
17:28:01 <ajones> should I try to restrict things at the type level such that you cannot directly use the classifier after a single attribute/value pair has been updated?
17:28:26 <ajones> it probably won't be in a consistent state at that point, so I'd think yes, but I'm stumped as to *how* to go about that.
17:29:13 <ajones> n/m, I think I know what to do.
17:29:34 <ajones> data Incomplete a = Incomplete { extract :: a}
17:29:45 <ajones> then don't export 'extract'
17:30:03 <pickles> maybe try looking at the reader monad?
17:30:13 <ajones> pickles: also a good idea.
17:30:20 <pickles> idk if you'll be continually updating things (given stats, probably)
17:30:57 <pickles> the local function may be of use, if you're not familiar
17:31:08 <pickles> (i only know about it cuz i recently looked at it :) )
17:31:25 <pickles> sry, should probably have quoted "local"
17:31:33 <b52> hey guys, do you know some nice sites which offer a few excersices to dig deeper into haskell?
17:31:46 <pickles> realworldhaskell
17:31:55 <b52> im currently reading that :
17:31:57 <b52> :D
17:31:59 <ajones> pickles: not sure I'm familiar, what do you mean by local function?
17:32:03 <nus> DrSyzygy, oh, here you're (-:
17:32:12 <nus> DrSyzygy, or are you?-)
17:32:21 <monoidal> b52: http://stackoverflow.com/questions/1012573/
17:32:23 <pickles> ajones: there's a function in the reader monad which allows doing a local change to the data
17:32:32 <twink> The ReaderT method
17:32:47 <pickles> oh, was it in ReaderT?
17:33:02 <twink> MonadReader rather
17:34:05 <ajones> pickles: not sure that's what I want.
17:34:27 <pickles> ajones: i figured, but thought i'd mention it anywya just in case :)
17:34:35 <ajones> kind of similar though.
17:34:42 <mm_freak> when compiling a library i'd like to compile a little test program along the way, but that test program shouldn't be installed by cabal-install
17:34:47 <mm_freak> what's the preferred way to do this?
17:35:30 <pickles> b52: check out the paper called "Monad transformers step by step", it'll give you some higher level haskell to think on
17:35:50 <edwardk> hrmm. i've been away from 'practical' haskell for a while, is there an http client library for haskell that uses bytestrings? i just want something i can hand a url off to and get back a way to read its contents, preferably incrementally, but all in one go would be fine as well
17:35:51 <lambdabot> edwardk: You have 2 new messages. '/msg lambdabot @messages' to read them.
17:36:01 <nus> DrSyzygy, any outcome of operads vs FRP?
17:36:10 <b52> pickles: u got a link?
17:36:15 <pickles> lemi c
17:37:00 <mm_freak> edwardk: see the 'HTTP' library
17:37:11 <mm_freak> it supports both String and ByteString
17:37:19 <mm_freak> http://hackage.haskell.org/package/HTTP
17:37:28 <pickles> b52: http://www.grabmueller.de/martin/www/pub/Transformers.pdf
17:38:14 <pickles> b52: took me a whle to wrap my head around it (as it seems to be w/ most things haskell), there are so many layers
17:38:39 <edwardk> mm_freak: i must be overlookingthe bytestring support in there
17:38:57 <b52> pickles: ok thanks, ill have a look at it
17:39:46 <edwardk> ah found what i was missing
17:40:04 <mm_freak> edwardk: http://hackage.haskell.org/packages/archive/HTTP/4000.0.9/doc/html/Network-TCP.html#t%3AHStream
17:40:10 <edwardk> yeah
17:40:29 <edwardk> i'd just for some reason gone blind to the HStream ty => ...'s that were strewn throughout ;)
17:40:44 <mm_freak> =)
17:41:37 <edwardk> i think what threw me was i was looking at getRequest which seems to be tied to Request String, and i just didn't look at the non-convenience functions above.
17:41:45 <mm_freak> it seems like i can't prevent an exectuable from being installed in cabal
17:41:47 <ddarius> edwardk: You ever look into Paul Taylor's Abstract Stone Duality?
17:42:03 <NEEDMOAR> @hoogle (a->Bool)->(a->b)->a->b
17:42:04 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
17:42:04 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
17:42:04 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
17:42:07 <edwardk> ddarius: can't say that i have
17:42:15 <copumpkin> @djinn (a->Bool)->(a->b)->a->b
17:42:16 <lambdabot> f _ a b = a b
17:42:29 <copumpkin> NEEDMOAR: :)
17:42:30 <mm_freak> how do you people quick-n-dirty-test your libraries?
17:42:40 <edwardk> mm_freak: quickcheck
17:43:04 <edwardk> ddarius: bookmarking for later perusal
17:43:14 <pickles> edwark: i just heard about quickcheck, you know any tutorials?
17:43:25 <ajones> "Occurs check: cannot construct the infinite type:" => "ajones: you aren't as capable of imagining crazy problems as I am"
17:43:31 <mm_freak> edwardk: i'd like to keep test code separate from library code and most of the code is IO
17:43:37 <mm_freak> does quickcheck support that?
17:43:44 <edwardk> pickles: we just had a very nice talk given on that subject at the boston haskell user group, but that does you no good ;)
17:43:54 <pickles> haha
17:44:06 <pickles> i should have sent my friend in boston as a proxy
17:44:08 <edwardk> mm_freak: there are monadic quickcheck combinators in a third-party library
17:44:17 <user317> why does ghc --make foo.hs generate foo.hi but if i set the output directory it generates Main.hi when Main is defined in foo.hs
17:44:34 <benmachine> due to magic
17:44:42 <ddarius> edwardk: Yeah, that's what I did.  I got back to it a few years later.
17:44:44 <edwardk> mm_freak: but in general i find that if you need to use quickcheck on monadic code you're generally factored wrong ;)
17:44:47 <benmachine> I remember trying to work out how ghc handled directories for ages
17:44:51 <benmachine> and failing >_>
17:45:00 <danderson> how can I force haskell to reevaluate a pure function?
17:45:01 <edwardk> ddarius: i'll try not to let it go so long ;)
17:45:09 <benmachine> luckily, haskell's automated build tools are pretty good
17:45:11 <mm_freak> edwardk: why?
17:45:22 <benmachine> so when I stopped using Makefiles and started using cabal, everything was okay again
17:45:24 <danderson> I'm trying to burn cpu iterating over my function to get profiling data, but haskell annoyingly compiles everything away into constantness
17:45:27 <Cale> danderson: Call it again?
17:45:41 <edwardk> mm_freak: it just makes things harder to test. (er by 'monadic' there i mean, hardwired to IO or STM)
17:45:45 <c_wraith> danderson: are you using criterion?
17:45:56 <Cale> danderson: Pure functions are not memoised by default, you have to go out of your way to memoise their results.
17:46:14 <c_wraith> Cale: if it's compiled with -O2, it's probably floating the computation.
17:46:18 <edwardk> mm_freak: if you factor out the monad in question, and abstract over the methods you DO need from them, you can then plug in your own test monad. think of it like mock objects for a java developer
17:46:27 <user317> benmachine, so there is no way to make it not do that?
17:46:41 <benmachine> user317: I don't know, I stopped looking
17:46:41 <danderson> c_wraith: I've just finished using Criterion, and it's given me surprising results (my 'fast but ugly' implementation turns out to be 5x slower than my 'elegant but probably slow' implementation)
17:46:42 <mm_freak> edwardk: the pure parts of my program are no problem
17:47:00 <benmachine> user317: basically I just took your question as an opportunity to whine and I have no useful information at all
17:47:01 <danderson> so now I want to grab a CPU profile and figure out why, because I'm surprised :)
17:47:01 <c_wraith> danderson: is it possible there's an issue with laziness?
17:47:03 <benmachine> sorry
17:47:12 <mm_freak> but when i write an IRC library i'd like to test whether it actually connects to a server and posts something to a channel
17:47:20 <mm_freak> in other words:  the check is not that "quick"
17:47:32 <Cale> danderson: What does the computation do?
17:47:38 <edwardk> mm_freak: you might also just want to look at test-framework in hackage
17:47:46 <c_wraith> danderson: is one algorithm evaluating less of the result than the other?  You have to be careful about benchmarking haskell.
17:47:54 <edwardk> there is support in there for HUnit and a bunch of other frameworks including quickcheck
17:47:54 <tsou> where should the binary of cabal be placed, and where should it place libs and programs it downloads?
17:47:59 <edwardk> for where quickcheck isn't the right tool
17:48:14 <user317> no worries
17:48:15 <danderson> the function in question is an Attoparsec parser for a big endian 16 bit integer
17:48:17 <Cale> danderson: Maybe compile with profiling (-prof -auto-all) and run with +RTS -p take a look at the time/allocation profile?
17:48:34 <mm_freak> edwardk: actually i wouldn't even want to distribute my test code
17:48:36 <edwardk> for that i'd probably use hunit
17:48:42 <danderson> the elegant implementation does a foldl' over the input bytestring with a shift/adder to construct the result
17:49:00 <blackdog> are there any tools for managing separate ghc instances, like rvm for ruby?
17:49:07 <edwardk> then break up your project into two cabal files, one for the public stuff, one for your tests
17:49:17 <danderson> the supposed-to-be-fast implementation grabs exactly two Word8's and does a `shiftL` 8 .|. b by hand
17:49:20 <edwardk> and manage them like separate projects
17:49:34 <mm_freak> hmm, yeahâ¦  that's inconvenient, but it seems to be the only way
17:49:53 <edwardk> personally i distribute, but make it a separate compilation target that just doesn't get built by default
17:50:01 <danderson> Cale: that's my problem, I can't get my profiling program (sequence $ take 100000 (cycle func)) to run long enough to matter
17:50:07 <danderson> which confuses me quite a bit.
17:50:13 <mm_freak> edwardk: how can you do that with cabal?
17:50:19 <c_wraith> danderson: it really sounds like laziness.
17:50:19 <mm_freak> Buildable?
17:50:41 <benmachine> danderson: how are you ensuring that the values are all forced?
17:50:59 <danderson> benmachine: I'm not. My original question was how to do that :)
17:51:01 <user317> benmachine, :)  how its my turn to whine
17:51:07 <mm_freak> (for some reason laziness and craziness are rhyming)
17:51:09 <benmachine> ah, rnf?
17:51:14 <c_wraith> rnf is the default answer
17:51:25 <edwardk> mm_freak: you can always make multiple targets in a cabal file like http://comonad.com/haskell/security-policy/security-policy.cabal -- though that one is kinda boring, lemme find something more interesting
17:51:30 <benmachine> or deepseq which is the same thing
17:51:38 <benmachine> thing about rnf and deepseq is they do take time
17:51:53 <benmachine> but I guess you can profile that in any case
17:52:21 <c_wraith> rnf has significant overhead compared to forcing results in a more problem-specific manner.  But it works without thinking about it. :)
17:52:28 <user317> after ghc builds the .o's does it need the .hi files for linking?  from my simple experiments it doesn't
17:52:50 <edwardk> mm_freak: hrmm i don't have any that are convenient that do what i just described.
17:52:54 <c_wraith> user317: it needs the .hi files to compile against those other modules.  For instance, in partial recompilation
17:53:33 <pickles> so, would a combination of those two files be OHI ? </badjoke>
17:53:37 <mm_freak> edwardk: briefly, how do you do it anyway?  i think i can figure it out myself
17:55:04 <user317> basically i can't get it to build 2 different exe's in the same directory, since they both try to build a Main.o, but my exe's share a bunch of the code so i dont want to rebuild all of it in each directory
17:55:24 <mm_freak> user317: use Main-is in your cabal file
17:55:43 <mm_freak> or use Hs-Source-Dirs, which is preferred
17:55:46 <benmachine> a cabal file would help here yes
17:55:50 <ajones> do you think "finishRecordingAttributesForDataItem" is an obnoxious enough name to help people remember they shouldn't be using it in production?
17:56:12 <benmachine> ajones: frafdi is more obnoxious imo :P
17:56:22 <benmachine> frafdi'donotuse
17:56:44 <benmachine> or, be traditional and go with unsafeFinishRecording...
17:56:48 <mm_freak> ajones: unsafeFRAFDI
17:56:54 <benmachine> yes that
17:56:56 <ajones> hmm
17:57:24 <user317> i am not using cabal, i am trying to plug ghc into our make based build system
17:57:28 <benmachine> I think if you're really worried about it you might be able to attach a warning pragma
17:57:35 <benmachine> user317: cabal is so lovely though
17:57:38 <mm_freak> user317: you can combine cabal and make
17:57:43 <ajones> not *really* worried about it.
17:57:48 <mm_freak> cabal really makes your life easier
17:57:58 <ajones> just want to make sure that in the sequence:
17:58:05 <user317> -main-is is being ignored, mm_freak, using cabal would add another dependency to the tool chain
17:58:08 <ajones> record a 1
17:58:10 <ajones> record b 2
17:58:12 <ajones> record b 3
17:58:15 <ajones> increment b
17:58:23 <edwardk> mm_freak: just define say the first target as 'library' with all the usual trappings, then make an executable that contains all your tests
17:58:26 <benmachine> yeah you can attach a warning pragma to a function
17:58:27 <ajones> that you can't try to do something else with 'b' until it's been incremented.
17:58:30 <benmachine> http://www.haskell.org/ghc/docs/latest/html/users_guide/pragmas.html#warning-deprecated-pragma
17:58:32 <mm_freak> user317: cabal is installed where any haskell compiler/interpreter is installed in about 99.99999% of all cases
17:58:32 <edwardk> mm_freak: i think kowey wrote a blog post on it forever ago
17:58:33 <benmachine> 'spretty cool
17:58:51 <mm_freak> user317: just note that to install almost any haskell package you need to use cabal anyway
17:59:03 <benmachine> Cabal is free with ghc isn't it
17:59:18 <Saizan> Cabal the library comes with ghc, yes
17:59:20 <benmachine> we're not talking cabal-install here but Cabal
17:59:30 <user317> mm_freak, we don't install stuff :), we just put everything into the versioning system so developers can check it out without trying to set up the same enviornment everywhere
17:59:30 <Saizan> and you can use the Setup scripts to build
17:59:43 <benmachine> no we're talking cabal-install if we want .cabal files
17:59:45 <benmachine> or are we
17:59:47 * benmachine forgets
17:59:52 <Saizan> benmachine: we aren't
18:00:01 <mm_freak> user317: well, yes, and cabal is to haskell packages what make is to C packages =)
18:00:14 <mm_freak> it's just a library and gets installed by default anyway
18:00:15 <user317> so, ghc -main-is test.hs -- make -outputdir linux_Debug test.hs, builds linux_Debug/ Test.hi  Test.o, but not the exe
18:00:16 <benmachine> .cabal is Cabal not cabal-install?
18:00:28 <mm_freak> benmachine: correct
18:00:32 <benmachine> oh ok
18:00:34 * benmachine notes this down
18:00:44 <mm_freak> you use setup.hs or setup.lhs to use it
18:00:58 <Saizan> user317: "--make" and -main-is takes a module name
18:01:47 <user317> Saizan, that givs me linker errors
18:02:08 <user317> so its trying to link, thats a good sign
18:02:10 <mm_freak> i wonder how well HUnit would work for me
18:02:27 <DrSyzygy> nus: Pong.
18:02:33 <DrSyzygy> nus: Operads vs. FRP?
18:02:37 <benmachine> user317: give an example linker error?
18:02:42 <benmachine> (just one, or pastebin)
18:02:50 <user317> (.text+0x1): undefined reference to `ZCMain_main_closure'
18:02:53 <Saizan> "ghc --make -main-is ModuleNameThatIsInTest -outputdir linux_Debug test.hs"
18:03:02 <Saizan> oh
18:03:12 <Saizan> try with -fforce-recomp
18:03:17 <user317> main is defined in test.hs the module name is Test
18:03:31 <benmachine> -main-is Test.main, presumably
18:03:35 <benmachine> or just Test
18:03:36 <user317> sweet
18:03:38 <user317> thanks :)
18:03:54 <Saizan> the .o wasn't being updated
18:04:04 <user317> but it build it localy :)
18:04:07 * twink uses -main-is a lot.
18:04:07 <user317> the exe
18:04:21 * benmachine uses main-is: instead
18:04:29 <user317> instead of in linux_Debug
18:04:46 <Saizan> user317: i think you've to use the -o flag to redirect the exe
18:05:53 <nus> DrSyzygy, a web search said you were interested in loking at that aproach, no?
18:07:22 <nus> *approach
18:07:59 <DigitalKiwi> looking*
18:08:02 <user317> Saizan: cool, that worked
18:08:04 <nus> fsck, what's going with my grammar :-/
18:08:12 <nus> DigitalKiwi, o'kourse
18:08:13 <DigitalKiwi> on*
18:08:16 <danderson> okay, so after futzing around for 30 minutes, I can only get the profile to tell me that a CAF in GHC.Word is eating all the cpu time
18:08:31 <danderson> which tells me nothing of much use :(
18:08:53 <danderson> but I'll just go with the fact that criterion says the code is awesome.
18:09:07 <benmachine> heh
18:09:44 <benmachine> I should make a code analysis tool where you give it a filepath, it spins the CPU for a bit and then outputs Conclusion: Awesome.
18:09:54 <dmwit> Well, you can't expect to be expert at profiling on your first try.
18:10:01 <danderson> problem is I don't really have a sense of scale, but 60ns to convert bytes into a number doesn't sound too shabby
18:10:20 <danderson> especially when my attempt at being more clever than the compiler resulted in a 5x loss of performance
18:10:21 <user317> just for future refs, it neesd the -main-is flag in the -c step, and -fforce-recomp in the -o step
18:11:03 <ddarius> danderson: Figure out how many instruction cycles it is.
18:11:30 <benmachine> user317: I'd be surprised if it needed -fforce-recomp every time
18:12:03 <benmachine> user317: I think you sometimes need it when your -main-is changes, but apart from that GHC is supposed to get things right
18:17:48 <ajones> why is it that either the immediate or secondary consequence of most of my best thoughts include "rewrite half of what you've just done"?
18:18:29 <ajones> I mean, it's ~130 lines with comments, so that isn't asking for *much*, but still.
18:18:58 <danderson> ddarius: any idea how to estimate that reasonably? based on a bit of futzing with an approximation of dhrystone MIPS (horrible metric) for my CPU, I get a guesstimate of 2100 instruction. But the error bars are probably way off.
18:19:32 <DigitalKiwi> obviously you should originally write your code based on your best thoughts instead of getting to those later ;)
18:19:53 <ajones> DigitalKiwi: that's what I get for lazy evaluation of my ideas.
18:20:01 <DigitalKiwi> lmao
18:20:16 <ajones> evidently I need stream fusion for program implementations, then I should be good.
18:21:48 <NEEDMOAR> data T = F1 | F2 T | F3 T T; now I'm interested in a function z :: (T -> T) -> T -> T such that z g F1 = F1, z g (F2 x) = F2 (g x), z g (F3 x y) = F3 (g x) (g y). What's z? It looks like a fmap or something.
18:22:08 <danderson> ddarius: actually, switching to a more accurate benchmark of my cpu, that becomes 300 integer instructions to parse a Word16 out of a ByteString, which sounds better.
18:22:19 <copumpkin> NEEDMOAR: deriving (Functor)
18:22:28 <copumpkin> oh
18:22:32 <copumpkin> not parametric
18:22:40 <tsou> trying to install X11 by cabal-install, at some point, it needed to compile and run something.  It tried to do so in /tmp, which I have noexec.  Is there a way to instruct it to use a different tmp dir?
18:23:04 <copumpkin> NEEDMOAR: why not data T a = F1 | F2 a | F3 a a?
18:23:04 <NEEDMOAR> copumpkin: do you think I should change my data type by adding it an argument?
18:23:14 <dmwit> NEEDMOAR: yes
18:23:21 <dmwit> NEEDMOAR: Then "z" is fmap.
18:23:24 <copumpkin> NEEDMOAR: well, what is your data doing right now? it's a tree that carries no data
18:23:28 <dmwit> NEEDMOAR: And you can use Mu to get back your data type.
18:23:44 <copumpkin> Moo
18:23:54 <dmwit> ?src Mu
18:23:55 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
18:24:03 <copumpkin> ?src Nu
18:24:04 <lambdabot> Source not found. Do you think like you type?
18:24:12 <copumpkin> if they're equivalent in haskell, why not provide both!
18:24:14 <NEEDMOAR> But I won't have a type functor for the mooized thing.
18:24:24 <dmwit> newtype MewTwo f a = In { out :: f a (MewTwo f a) }
18:24:24 <copumpkin> yeah
18:24:32 <ajones> wth, lambdabot has an attitude.
18:24:43 <copumpkin> ajones: damn right
18:25:00 <NEEDMOAR> copumpkin: yeah like I will have it, or yeah like I won't have it?
18:25:05 <ajones> keep *that* crap up and I **will** turn you into a toaster.
18:25:10 <copumpkin> yeah, you won't have Functor for Mu T
18:25:19 <copumpkin> NEEDMOAR: but you can't have it
18:25:24 <NEEDMOAR> :-(
18:25:28 <copumpkin> it makes sense
18:25:34 <dmwit> But you shouldn't want it. ;-)
18:25:58 <copumpkin> are you sure you don't want something like data T a b = F1 | F2 a | F3 b b ?
18:26:17 <dmwit> or data T a = F1 a | F2 a T T | F3 a T T T
18:26:26 <copumpkin> well, mine is using Moo again
18:26:35 <copumpkin> your trees can't be empty :(
18:26:57 <dmwit> ?src Tree
18:26:58 <lambdabot> Source not found. Sorry.
18:27:19 <dmwit> Anyway, neither can Data.Tree's, and nobody complains about that.
18:27:29 <ddarius> I do.
18:27:34 <NEEDMOAR> copumpkin: I'm kinda interested only in the form of formula, and F2 and F3 are the operators in those formulas.
18:27:43 <copumpkin> NEEDMOAR: ah, I see
18:27:57 <copumpkin> NEEDMOAR: you don't have polymorphic phormulae?
18:28:04 <ddarius> Except I don't use Data.Tree since it is uglyp
18:28:18 * dmwit doesn't find it so
18:28:24 <copumpkin> pugly?
18:28:27 <copumpkin> phugly
18:28:27 <NEEDMOAR> copumpkin: nope.
18:28:36 <dmwit> uglyp, the predicate that tests for ugliness
18:28:42 <copumpkin> aha
18:30:23 <NEEDMOAR> Shit happens :-(
18:30:43 <dmwit> Have you looked into edwardk's Big List of Recursion Schemes?
18:30:59 <NEEDMOAR> Nope.
18:31:06 <NEEDMOAR> I haven't heard of it before.
18:32:14 <dmwit> ?hackage category-extras
18:32:14 <lambdabot> http://hackage.haskell.org/package/category-extras
18:32:14 <dmwit> and
18:32:19 <dmwit> http://knol.google.com/k/catamorphisms
18:32:33 <dmwit> hm
18:32:44 <dmwit> Somewhere there was a list, too, but now I can't find it.
18:33:05 <dmwit> ah
18:33:09 <dmwit> http://comonad.com/reader/2009/recursion-schemes/
18:34:35 <benmachine> :t join (foldr seq)
18:34:35 <lambdabot> forall a. [a] -> [a]
18:34:47 <benmachine> ^ does this do anything interesting
18:35:28 <ddarius> benmachine: Should force each element of its argument, if I'm not mistaken.
18:35:30 <dmwit> seems useful
18:35:37 <Cale> yeah, it's useful
18:35:39 <benmachine> that's what I hoped
18:35:52 <ddarius> > foldr seq [undefined] [error "foo"]
18:35:53 <benmachine> was a little worried it was a long way of saying id :P
18:35:54 <lambdabot>   * Exception: foo
18:36:09 <Cale> It makes it so that pattern matching the first element of the list will force every element of the list to be evaluated.
18:36:56 <benmachine> lazy I/O is a headache
18:37:16 <Cale> (then don't use it)
18:37:41 <DrSyzygy> nus: Maybe. If I knew what FRP is...
18:37:50 <danderson> is it conceivable that an INLINE pragma would make a function slower?
18:37:55 <danderson> Specifically: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24035#a24035
18:37:58 <DrSyzygy> nus: I certainly think that operads should be useful for functional programming...
18:38:08 <Veinor> :t foldr seq
18:38:09 <lambdabot> forall a b. b -> [a] -> b
18:38:24 <danderson> Criterion puts anyWord64le at 10% slower with the INLINE than without
18:38:29 <danderson> and I'm not sure I get why.
18:38:33 <benmachine> I have a function that accepts a lazy ByteString and I want to give it the contents of a file
18:38:53 <[swift]_> i'm a bit confused about record update syntax. can i pass the field to be updated into a function? this doesn't seem to work: update r f v = r { f = f r ++ v }
18:38:55 <benmachine> Data.ByteString.Lazy.readFile is upsetting me, what other options do I have?
18:39:24 <nus> DrSyzygy, I see... well, from my (limited) understanding they seem to be well-fitted for data-flow combinatorics.
18:39:26 <ddarius> Data.ByteString.readFile.
18:39:47 <DrSyzygy> nus: That sounds similar to my own thoughts on the matter.
18:39:54 <DrSyzygy> nus: I haven't _done_ anything about it though...
18:39:55 <benmachine> ddarius: do I need to convert to Lazy then?
18:40:16 <benmachine> oh, fromChunks etc.
18:40:35 <nus> DrSyzygy, ok, seems to be a direction to explore, then (-:
18:42:54 <benmachine> awesomecool
18:43:13 <benmachine> running in constant filehandls
18:43:28 <ajones> anyone know how I can do something like this? http://haskell.pastebin.com/ZZmW0vBU
18:44:07 <ajones> I want to take an updateable classifier and turn it into a non-updateable one with some values precomputed.
18:44:37 <dmwit> class Foo nonfinal final where ...
18:44:37 <dmwit> ?
18:44:49 <copumpkin> or a type family/asstype
18:44:57 <dmwit> s/.../makeFinal :: nonfinal -> final/
18:45:10 <copumpkin> ajones: I do get the impression you're overcomplicating though :P
18:45:26 <copumpkin> are you talking about actually freezing a mutable datastructure that has good reason to be mutable?
18:45:45 <ajones> classifiers kind of see a two-phase use cycle
18:45:52 <ajones> train then use
18:45:56 <copumpkin> yep
18:46:03 <NEEDMOAR> dmwit: thanks.
18:46:19 <ajones> once I'm using the classifier, I don't really need the ability to train it and wouldn't mind precomputing as much as I can.
18:46:34 <dmwit> NEEDMOAR: You're welcome! err... did it actually help? =P
18:47:36 <ajones> I think the solution dmwit came up with will work.
18:47:42 <NEEDMOAR> dmwit: no :-p
18:47:52 <NEEDMOAR> dmwit: I should look at them carefully, tho.
18:48:11 <ajones> copumpkin: don't think I'm overcomplicating it, literally have already performed this operation manually myself.
18:49:00 <copumpkin> ok :)
18:49:14 <copumpkin> I just saw your 4-parameter MPTC earlier and it looked a little scary :P
18:49:23 <ajones> yeah, it does.
18:49:30 <ajones> not so bad in actual use.
18:52:04 <mm_freak> ok, the Crypto package actually installs the test programs
18:52:12 <mail> converting DFAs to regular expressions is soooooooooooo boring :(
18:52:21 <mm_freak> i think i'll do the same
18:52:44 <dankna> @hoogle InvalidArgument
18:52:44 <lambdabot> No results found
18:52:48 <copumpkin> mm_freak: don't!
18:52:57 <copumpkin> mm_freak: cabal options kthx :P
18:53:49 <mm_freak> copumpkin: i'm writing a network library and need to test if it actually connects and works
18:53:55 <mm_freak> the test program is interactive
18:54:04 <copumpkin> mm_freak: still, I'd put the test program not in the default installation
18:54:09 <copumpkin> just use a cabal flag
18:54:32 <mm_freak> copumpkin: i don't know how to do it otherwise
18:55:17 <mm_freak> cabal insists on installing all executables
18:55:34 <mm_freak> at least i haven't found an option to skip installation in the user guide
18:55:53 <copumpkin> oh, hmm
18:57:07 <ajones> you know what, if someone wants to finalize their classifier they're just going to have to do it themselves and make sure to not try and update it.
18:57:40 <ajones> I took two finals yesterday, spent six hours on one today, and have been beaten up by the type system for the last few hours.
18:57:53 <ajones> I'm done.
18:57:58 <mm_freak> copumpkin: actually flags could work by not including an executable section entirely
18:58:12 <copumpkin> ajones: I'd do something Ã  la ST for ensuring people don't reuse it
18:58:41 <ddarius> Because rank 1 types aren't complicated enough.
18:58:54 <copumpkin> yeah, pretty much
18:59:08 <ajones> I've got the updating and classification as two separate typeclasses, the "finalized" structure can just not implement updating.
18:59:26 <ajones> anyways, gtg, thanks all for the help.
19:08:28 <mm_freak> ok, flags work
19:12:03 <applicative> mm_freak: can't you just go by way of `cabal build` then `cabal test`
19:14:07 <mm_freak> applicative: it's overkill for what i want to do
19:15:25 <applicative> Doesn't it just do runhaskell on whatever is in /tests ?
19:15:38 <mm_freak> hmm, does it?
19:15:40 <ivanm> applicative: cabal test requires special hooks in Setup.hs
19:15:46 <ivanm> (I believe)
19:15:51 <ivanm> I don't think it's something automagic
19:15:51 <mm_freak> yeah, that was my impression, too
19:15:56 <applicative> it does, but it's not too hard
19:15:56 <benmachine> mm_freak: buildable: False is I think what you want
19:15:58 <ivanm> preflex: seen dcoutts
19:15:58 <preflex>  dcoutts was last seen on #haskell 14 hours and 51 seconds ago, saying: dankna: so perhaps follow up on the list, think through the steps, it might be that Cabal can help a bit, reduce the amount of custom code needed.
19:16:05 <benmachine> although I also think you've already worked it out by now
19:16:06 <mm_freak> benmachine: yeah, that's what i'm using right now
19:16:12 <applicative> wait til dcoutts shows up
19:16:19 <benmachine> http://github.com/benmachine/stepeval/blob/master/stepeval.cabal
19:16:41 <mm_freak> but i'll need (or want) quickcheck anyway
19:16:54 <ivanm> mm_freak: even if testing is disabled? :o
19:16:55 <ivanm> why?
19:16:58 <mm_freak> so i'll need to figure out how to use 'cabal test'
19:17:09 <mm_freak> ivanm: ?
19:17:37 <ivanm> mm_freak: didn't you say you were using a test flag or something? if so, why would you still depend on quickcheck if --flags=-test ?
19:19:45 <mm_freak> ivanm: the flag for quick-n-dirty tests of IO code and quickcheck for testing of pure code
19:20:06 <ivanm> why not have the flag do both?
19:20:13 * ivanm hates packages that force a dep on QC
19:20:55 <ivanm> end users assume your code is valid (until they find a case otherwise); why should they need the testing stuff built in?
19:21:46 <FauxFaux> Testing is the best form of documentation!
19:22:30 <mm_freak> well, the problem is rather that there is no built-in testing framework
19:23:03 <ivanm> have the tests in specific testing modules and only build them if the testing flag is enabled
19:23:11 <ivanm> FauxFaux: no, documentation is the best form of documentation
19:23:32 <FauxFaux> Documentation rots a lot quicker.
19:23:48 <mm_freak> ivanm: yes and since cabal 1.2 it's easy to depend on quickcheck only if testing is enabled
19:23:55 <ivanm> FauxFaux: then keep the documentation up to date
19:24:03 <ivanm> mm_freak: right
19:24:15 * FauxFaux welcomes ivanm to professional software development.
19:24:28 <ivanm> so "professional" == "lazy"?
19:24:33 * ivanm passes
19:24:57 <FauxFaux> I was more thinking of "with incredibly poor quality codebases maintained by people who couldn't care less">
19:28:17 <ivanm> is that an indication of how "professional software development" is defined, the kind of corporate culture you are used to or the kinds of people that are hired and work for those kinds of companies?
19:29:25 <dmwit> I think even small companies with motivated, hard-working developers have legacy code.
19:30:10 <dmwit> You just have to pick your fights, and sometimes rewriting the non-critical-path software that only runs at night from ten years ago isn't the right fight.
19:31:59 <FauxFaux> As soon as you get above about two developers you end up with people who are just there for money.  Unless you're exceptionally lucky.
19:32:01 <mm_freak> well, self-documenting code is always preferable, so your function's name and type should indicate what it does
19:32:15 <mm_freak> maintaining documentation is tiring, so people get it wrong often
19:32:21 <dankna> and don't get me started on people who insist on using cryptic two-character variable names
19:32:24 <dmwit> FauxFaux: I don't believe that rule. Not for a single second.
19:32:28 <mm_freak> but i don't agree that tests document code
19:32:29 <dankna> the variable name should be an essay on its purpose, haha
19:32:38 <FauxFaux> dmwit: Have fun with your happy illusion.
19:33:22 * dmwit shrugs
19:33:33 <dmwit> I have had better experiences than you; that doesn't make my life an illusion.
19:33:53 <Cale> http://i.imgur.com/EJX4c.jpg -- haha
19:34:08 <dankna> Cale: bwahaha
19:34:16 <SamB_XP_> dankna: yah
19:34:23 * shapr laughs
19:34:25 <SamB_XP_> two characters is one character too long!
19:34:29 <ivanm> Cale: lol
19:34:30 <dankna> gasp!
19:34:46 <dmwit> 2 c = 1 c 2 lng!
19:35:25 <ivanm> SamB_XP_: I'm tutoring a first year course in Haskell; some tutors have responded that after seeing all the simple polymorphic list-based functions use (x:xs), etc. they somehow get the opinion that all variables should have similar names and don't realise they can have more descriptive names... :s
19:35:45 <SamB_XP_> ivanm: seriously ?
19:35:50 <ivanm> seriously
19:35:58 <dmwit> You know what we could use more of in the Haskell community?
19:35:59 <dankna> well, it makes sense that they're getting the idea somewhere
19:36:02 <dmwit> Descriptive type variable names.
19:36:04 <ivanm> it doesn't help that in maths, etc. they would have gotten used to doing f(x), etc. as well...
19:36:29 <mm_freak> dmwit: good ideaâ¦  i'll start with that in my new project
19:36:34 <ivanm> dmwit: you can drag my single letter type variables out of my cold dead hands!
19:36:36 <dankna> but yeah, in a modern compiler you can write a letter to Grandma in the variable name, and sometimes you actually should
19:36:45 <companion_cube> in math, you generally do not have as much names
19:36:56 <ivanm> (though I do use ones like `n' and `e' when referring to nodes and edges...)
19:36:58 <mm_freak> companion_cube: yes, and that's unfortunate
19:37:00 * dankna tosses companion_cube in the incinerator!
19:37:04 <companion_cube> \o/
19:37:07 <dankna> hehe
19:37:10 <ivanm> dankna: :o
19:37:17 <arw> well. there is no problem at all in naming the single argument of a function 'x'. or some string 's' or something.
19:37:21 <ivanm> and people accuse _me_ of being violent here...
19:37:24 <dankna> ... but friendly-like
19:37:44 <benmachine> it's the nice kind of incinerator
19:37:47 <mm_freak> you people are mean today
19:37:51 <mm_freak> let me be mean to lambdabot
19:37:53 <mm_freak> > fix id
19:37:57 <lambdabot>   mueval-core: Time limit exceeded
19:38:05 <dankna> chortle
19:38:20 <companion_cube> remember that aperture science recommends not to listen to me !
19:38:36 <dankna> wasn't the line something like
19:38:36 <benmachine> > fix $ fix id
19:38:40 <lambdabot>   mueval-core: Time limit exceeded
19:38:48 <dmwit> <3 companion_cube
19:38:54 <mm_freak> > please fix id
19:38:58 <lambdabot>   mueval-core: Time limit exceeded
19:39:00 <ivanm> companion_cube: who?
19:39:01 <dankna> Your weighted companion cube is an inanimate object and cannot talk.  Also, if the weighted companion cube does talk, Aperture Science recommends that you not listen.
19:39:01 <Trinitron> Is there a function in Haskell to return the larger of two integers?
19:39:03 <benmachine> > fix error
19:39:04 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
19:39:07 <mm_freak> Trinitron: max
19:39:13 <applicative> @type please
19:39:14 <lambdabot> Not in scope: `please'
19:39:15 <companion_cube> ivanm: it's a reference to a game :)
19:39:19 <ivanm> ahhh
19:39:20 <Trinitron> > max 1 2
19:39:21 <lambdabot>   2
19:39:39 <DigitalKiwi> The cake is a lie!
19:39:46 <mm_freak> the cake?
19:39:48 <dmwit> ivanm: A game so good that I bought Windows just to play it.
19:39:50 <dmwit> no jokes
19:39:50 <ivanm> a tasty, tasty lie!
19:40:01 <copumpkin> dmwit: but it's coming out on mac os soon too!
19:40:05 <SamB_XP_> dmwit: why the heck did you BUY windows?
19:40:12 <nus> > fix id -- "ideee fixe" of an obssessed runtime?
19:40:14 <SamB_XP_> copumpkin: mac is even more expensive
19:40:15 <copumpkin> I bought windows too
19:40:15 <companion_cube> btw, is it considered 'bad' to use explicit state passing instead of using StateT or such ?
19:40:16 <lambdabot>   mueval-core: Time limit exceeded
19:40:22 <nus> s/ideee/idee/
19:40:43 <dmwit> SamB_XP_: I like obeying the laws. Even the ones I don't agree with, believe it or not.
19:40:46 <mm_freak> > splitAt 7 . drop (42 - 15) . map head $ cake
19:40:47 <lambdabot>   ("TOOTOOT","ASCIICAT")
19:40:47 <ivanm> mm_freak: http://xkcd.com/606/
19:40:59 <ivanm> companion_cube: not really
19:41:06 <ivanm> but you may wish to do so to improve your code
19:41:17 <applicative> > cake
19:41:18 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
19:41:19 <Trinitron> > max 1 2 3
19:41:20 <lambdabot>   No instance for (GHC.Num.Num (t -> a))
19:41:20 <lambdabot>    arising from the literal `1' at <...
19:41:28 <Trinitron> D'oh
19:41:35 <Trinitron> only takes two arguments?
19:41:42 <dmwit> > maximum [1, 2, 3]
19:41:43 <DigitalKiwi> haha, if there was a game so good you would buy windows for it, but it was only on a mac, does that mean you would buy a mac for it? :D
19:41:44 <lambdabot>   3
19:41:47 <SamB_XP_> > isLie cake
19:41:49 <lambdabot>   Not in scope: `isLie'
19:41:50 <mm_freak> Trinitron: haskell functions always have a fixed number of arguments
19:41:51 <SamB_XP_> hmm.
19:41:53 <SamB_XP_> needs work
19:41:55 <companion_cube> yes, but i still find hard to deal with monad transformers, and perhaps explicit state passing is more "human" :)
19:41:59 <mm_freak> lol ivanm
19:42:18 <dmwit> DigitalKiwi: Probably not. Buying a Mac: ~$1000; buying Windows: ~$50 after student discounts.
19:42:29 <mxc> anyone have experience with libcurl on windows?
19:42:42 <mxc> having ld errors exactly like this guy:  http://pastie.org/499193
19:42:59 <mxc> wondering if rebuilding libcurl and the curl package is the only way to fix them
19:43:01 <Trinitron> How do I convert a number to a "string"
19:43:02 <Trinitron> ?
19:43:03 <arw> dmwit: ordering an ubuntu cd: 5 mouse clicks.
19:43:10 <mxc> trinitron: show
19:43:15 <mxc> @show 5
19:43:15 <nus> DigitalKiwi, what's wrong with bying just an OSX copy?
19:43:15 <lambdabot> "5"
19:43:19 <dmwit> mxc: Are you linking to in libssh2?
19:43:24 <Trinitron> >show 343
19:43:28 <mxc> not intentionally
19:43:29 <DigitalKiwi> arw: that would assume you actually wanted to use ubuntu ;p
19:43:31 <applicative> > show 343
19:43:33 <lambdabot>   "343"
19:43:33 <dmwit> arw: Playing at 5 fps under Wine: priceless.
19:43:57 * arw likes ta spring.
19:43:58 <companion_cube> of course, since linux is free :D
19:44:00 <mxc> dmwit : honestly, I dont use curl at all, its only because of the HXT dependence
19:44:07 <Trinitron> You get what you pay for.
19:44:09 <dmwit> As a bonus, it crashes 19 times out of 20.
19:44:18 <applicative> > show . sqrt $ 1.0
19:44:20 <lambdabot>   "1.0"
19:44:26 * ezyang had a friend that who setup .exe files to automatically boot up Wine 
19:44:27 <Trinitron> You _only_ get what you pay for.
19:44:43 <Trinitron> There is no such thing as a free lunch.
19:44:49 <dmwit> ezyang: That comes for free by installing Wine these days. =)
19:44:52 <ivanm> Trinitron: sure there is
19:44:55 <Trinitron> Despite what freetards say these days.
19:44:57 <ivanm> when you pretend to be someone you aren't
19:44:58 <ddarius> s/is/ain't
19:45:07 <dmwit> But (at least when I tried), there's still a bunch of stuff that Wine doesn't *quite* do properly.
19:45:07 <Trinitron> There is a price for everything.
19:45:11 <ivanm> arw: you actually order them?
19:45:12 <ezyang> dmwit: wait, seriously?! >:-(
19:45:16 * ezyang disaproves 
19:45:28 * DigitalKiwi uses arch and is happy as can be ^_^
19:45:28 <ivanm> of what? the facts?
19:45:35 <Cale> > isLie cake
19:45:36 <dmwit> ezyang: eh? why?
19:45:36 <lambdabot>   True
19:45:38 <arw> ivanm: some time ago, we ordered a box for distributing on campus and for an install-party.
19:45:51 <arw> ivanm: but usually, no, we just use netinstall :)
19:45:53 <ivanm> arw: ahhh, fair enough
19:45:54 <applicative> @type isLie
19:45:55 <lambdabot> forall a. (Enum a) => [[a]] -> Bool
19:45:58 <ezyang> dmwit: Next thing you know you'll have users infecting the Linux desktops with Windows viruses
19:46:04 <ezyang> Truly Year of the Linux Desktop
19:46:18 <ivanm> then again, you still have the problem that you're installing _ubuntu_
19:46:20 <ivanm> :p
19:46:22 <Trinitron> No-one is switching to Linux desktop any time soon.
19:46:27 <dmwit> ezyang: http://www.linux.com/archive/feed/42031 =)
19:46:29 <DigitalKiwi> ^5 ivanm
19:46:29 <arw> ezyang: already possible. there are several viruses proven to run on wine :)
19:46:37 <ivanm> Trinitron: yeah, because I've already switched
19:46:37 <ezyang> >.>
19:46:39 <DigitalKiwi> arw: and the ubuntu people love doing it!
19:46:40 <ivanm> anyway, -blah
19:46:42 <dmwit> ezyang: Wine can't even do viruses properly. =P
19:46:45 <Trinitron> Minus the freetards.
19:46:53 <DigitalKiwi> http://ubuntuforums.org/showthread.php?t=72598
19:46:53 <Trinitron> Set subtraction.
19:47:02 <SamB_XP_> I wonder if there are any viruses especially for wine ?
19:47:08 <ivanm> Quick! emergency Haskell!
19:47:09 <DigitalKiwi> I lalwed for like half an hour from that thread
19:47:10 <arw> Trinitron: i get windows for free. i still wont use it.
19:47:13 * bremner_ yawns at Trinitron's feeble trolling
19:47:18 <Trinitron> I can't see your average Joe switching.
19:47:18 <ivanm> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs
19:47:19 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
19:47:23 <ivanm> \o/
19:47:27 * ivanm feels better now
19:47:55 * arw just expiriences his first windows-flame on #haskell
19:48:05 <DigitalKiwi> Trinitron: I'm not a freetard :( I like arch a hundred times better than windows, and I used windows avidly for a long time...
19:48:06 <arw> i'm surprised it took so long...
19:48:09 <mxc> dmwit : adding ssh2 to the Extra-Libraries field didn't help
19:48:16 <ezyang> Btw, generating functions are awesome!
19:48:24 <Trinitron> I
19:48:26 <Trinitron> I
19:48:28 <dmwit> > let fromList = length; toList = flip replicate (); (*) = (>>); (+) = (++) in fromList (toList 32 + toList 46 * toList 3)
19:48:28 <ivanm> DigitalKiwi: please stop feeding the troll...
19:48:30 <lambdabot>   234
19:48:31 <dmwit> HASKELL
19:48:33 <DigitalKiwi> ivanm: sowwie
19:48:39 <Trinitron> I'm happy happy with Windows 7.
19:48:50 <ivanm> > "dmwit: " ++ cycle "thank you "
19:48:51 <Trinitron> s/happy//
19:48:51 <lambdabot>   "dmwit: thank you thank you thank you thank you thank you thank you thank y...
19:48:52 <DigitalKiwi> windows 7 ate my baby
19:49:06 <applicative> mm_freak: i think I see what you mean about test executables, I had only fiddled with existing ones, but even my best practices guide builds a test executable in .cabal/bin for one library, if you cabal install it
19:49:25 <Trinitron> God, now the freetards are frothing at the mouth.
19:49:25 <applicative> mm_freak: http://github.com/jgm/texmath
19:49:28 <dmwit> > (32 + 46 * 3, (32 + 46) * 3) --  hehe, whoops
19:49:29 <Trinitron> Back to haskell.
19:49:30 <lambdabot>   (170,234)
19:50:07 <mm_freak> applicative: i wish cabal would have a testing framework built-in
19:50:08 <DigitalKiwi> i called microsoft and the were like "we are very sorry, would a complimentary copy of a 30 day trial of offie 2007 make you happy" and I was like "..." and they were like "is that a yes?"
19:50:17 <ivanm> mm_freak: there's a GSoC proposal for that...
19:50:33 <mm_freak> ivanm: maybe i should participate, but i'm not a student
19:50:57 <ivanm> mm_freak: and it's been a proposal for a while on the cabal bug tracker
19:51:40 <mm_freak> well, my current approach is ugly, but at least it works
19:51:43 <applicative> mm_freak: whereas the testing material in http://hackage.haskell.org/package/pandoc which I've fiddled with, is kind of elaborate to setup.  Hackage will be spared me for a bit longer.
19:51:49 <mm_freak> so until there is something better, i'll stick to it
19:52:39 <mail> what is the regualr expression for this language { w | w does not contain the substring 001 }
19:52:41 <Trinitron> How do you reverse a string?
19:52:48 <mail> alphabet = { 0,1}
19:52:48 <ezyang> mail: Not Haskell?
19:52:51 <Trinitron> > reverse "123"
19:52:52 <lambdabot>   "321"
19:52:57 <applicative> > reverse "haha"
19:52:57 <ivanm> mail: as in you want to write regexps in Haskell?
19:52:58 <lambdabot>   "ahah"
19:53:05 <ezyang> mail: But want to do is manually write out al of the cases
19:53:07 <Trinitron> In python it's reversed
19:53:10 <Trinitron> not reverse
19:53:14 <Trinitron> hmm
19:53:16 <ezyang> ivanm: He's doing computability homework
19:53:25 <mail> i have the dfa
19:53:27 <ezyang> I should know, since I'm being exam'ed on it this Thursday :-)
19:53:32 <mail> i just can't be arsed to convert it :P
19:53:41 <ezyang> Regular expression in the real sense of theterm
19:53:42 <ivanm> ezyang: ahhh
19:53:42 <applicative> Trinitron: in French its something else again
19:53:52 <Trinitron> Ha ha.
19:54:03 <ezyang> mail: You could algorithmicially derive the regular expression, if you have the DFA
19:54:08 <ezyang> It sucks and I don't recommend it
19:54:19 <mail> that's the only way i know
19:54:20 <Trinitron> What biting wit.
19:54:29 <mail> it's very boring
19:54:35 <mail> hence why i asked if anyone knew
19:54:41 <ezyang> mail: Well, a modest bit of cleverness is required for the non-algorithmic way
19:54:46 <ezyang> And I'm not going to do your homework for you ;-)
19:54:56 <ezyang> but "case by case" should be enough to get you started
19:55:06 <mail> the complement of that language is easy
19:55:14 <ezyang> mail: It's true :-)
19:55:29 <ezyang> But there's only an easy algorithm for finding the complement of a DFA
19:55:30 <mail> i can't work out the not in terms of the regular operators
19:55:57 <ezyang> there's not a simple equivalent that operates on regexes
19:56:14 <applicative> mail: { w | w does not contain the substring 001 } doesn't typecheck, try { w | w does not contain the substring "001" }
19:56:21 <dmwit> I've often thought that it would be nice to have "not" and "intersection" operations on regexes. It seems silly not to allow them.
19:56:45 <mail> meh the boring way it is then
19:57:18 <ezyang> dmwit: Heh.
19:59:13 <mail> wait a sec ezyang go to MIT?
19:59:50 <dmwit> mail: http://ezyang.com/ ;-)
19:59:51 <ezyang> mail: Yes.
20:00:18 <arw> ls
20:00:24 <arw> oh, sorry
20:00:55 <arw> should turn on focus-follows-mouse again
20:01:31 <mail> GPA 5.0/5.0
20:01:33 <mail> god damn ...
20:01:49 <philo> hi
20:01:56 <mail> Coursework: Operating Systems Engineering, implemented a minimal operat-
20:01:56 <mail> ing system and live process migration over a network.
20:02:05 <mail> wtf ... you did that in your first year?
20:02:13 <ezyang> mail: No, that was last semester
20:02:14 <dmwit> ezyang: protip: The filename of your resume should have your name in it.
20:02:30 <ezyang> There are plenty of first years who do (I know a HS who went and took the class...)
20:02:33 <philo> how to explicitly select wich intance version haskell uses when using a class method ?
20:02:37 <ezyang> dmwit: Heh, good call.
20:02:48 <dmwit> philo: Just give it a type annotation.
20:02:54 <philo> the type of the method is not enought to infer the instance
20:03:00 <dmwit> > (0 :: Int, 0 :: Rational, 0 :: CReal)
20:03:01 <lambdabot>   (0,0 % 1,0.0)
20:03:14 <copumpkin> dmwit: protip: protips should be sarcastic
20:03:22 <dmwit> oh =(
20:03:28 <philo> dmwit: the type of the method is not enought to infer the instance
20:03:30 <copumpkin> but I forgive you
20:03:35 <dmwit> I thought protips were for being helpful!
20:03:47 <copumpkin> protip: shoot the boss until it dies!
20:03:52 <dmwit> philo: I assume you mean something like this:
20:04:00 <dmwit> > show . read $ "hmm, which type?"
20:04:01 <lambdabot>   "* Exception: Prelude.read: no parse
20:04:08 <ezyang> mail: 6.828 was lots of fun, and very enlightening. If your uni has an equivalent I highly recommend taking it.
20:04:08 <copumpkin> http://encyclopediadramatica.com/File:Protip.jpg
20:04:10 <dmwit> Well, when the MR is not in effect. =P
20:04:23 <dmwit> philo: The answer there is *still* to give a type annotation, just in a different place.
20:04:26 <dmwit> philo: e.g.
20:04:35 <dmwit> > show . (read :: String -> Int) $ "32"
20:04:36 <lambdabot>   "32"
20:05:01 <ezyang> (also a fuckton of work. first week was, "Hi, welcome to 6.828. Go learn assembly. Done now? Ok, time to write a bootloader...")
20:05:24 <ezyang> anyways... back to Haskell...
20:06:25 <ezyang> It'd be kind of neat if GHC also did partial evaluation when it did partial application
20:06:48 <luite> yo dawg?
20:06:49 <dmwit> Partial evaluators are really neat.
20:06:58 <[swift]_> argh.. the info for exceptions in RWH seems to be out of date. Exception takes a type parameter now apparently.. i'm a bit confused how to use handle now
20:07:26 <ezyang> [swift]_: First rule of exceptions: do you actually need an exception/
20:07:57 <[swift]_> ezyang: well i'm doing file IO. i just want to catch the exception with handle and print an error message
20:08:27 <philo> dmwit:  would you mind ? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24038#a24039
20:08:52 <ezyang> [swift]_: Why don't you pastebin some code?
20:09:03 <[swift]_> ezyang: sure, will do
20:10:58 <dmwit> philo: Give newLabel it's (monomorphic) type?
20:11:03 <dmwit> urgh
20:11:03 <dmwit> its
20:11:50 <philo> dmwit: ?
20:11:55 <philo> i am not sure to follow you
20:12:04 <dmwit> philo: try
20:12:13 <[swift]_> ezyang: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24040#a24040
20:12:21 <dmwit> label1 <- newLabel :: State TempGeneratorState Temp Label -- or so
20:12:29 <dmwit> err
20:12:35 <philo> dmwit: ok i get
20:12:36 <philo> trying
20:12:47 <dmwit> philo: No, that won't help. =)
20:12:54 <philo> yea
20:13:20 <philo> cuz the type of newLabel don't give any information on the Temp type
20:13:28 <dmwit> philo: Add a top-level binding for the do-block, and give *that* a monomorphic type.
20:13:49 <dmwit> e.g. foo :: State TempGenerator ([Label], [Temp])
20:14:00 <dmwit> foo = do label1 <- newLabel; label2 <- newLabel; ...
20:14:06 <philo> could a type constraint relation beetween Temp and label solve the probleme ?
20:14:08 <dmwit> philo: But... do you definitely need typeclasses?
20:14:54 <philo> dmwit:  dont know
20:15:03 <philo> that was just the solution that came first
20:15:04 <ddarius> Indeed.  A fundep may help, but this doesn't look like a situation for type classes.
20:15:22 <dmwit> Yeah, I would just drop the class entirely until you know you need it.
20:15:29 <ezyang> [swift]_: Explicitly adding a type signature on the const might fix it
20:15:37 <ezyang> I'm a little surprised GHC is complaining about it
20:15:56 <ezyang> The type you want is IOError
20:16:03 <philo> ddarius:  coming from c++/Java i thought that was the case
20:16:07 <philo> ok reformating lol
20:16:41 <[swift]_> ezyang: so the const is then of type IOError -> IO (), right?
20:16:49 <philo> so there is no way to explicitly choose from what intance the method derive ?
20:16:55 <ddarius> philo: Type classes in Haskell are nothing like classes in Java.
20:17:36 <ezyang> [swift]_: Yup
20:17:46 <philo> yea but i thought that was the way to provide an interface
20:17:50 <philo> to some services
20:18:13 <[swift]_> ezyang: thanks, that fixed it! am I doing something wrong that's screwing up type inference, or is that normal?
20:18:29 <dmwit> No, it's the way to provide ad-hoc polymorphism (i.e. one name with many types).
20:18:31 <ezyang> [swift]_: Usually, the error handler function does pattern matching on e
20:19:06 <ezyang> erm, I mean, using the IO error functions on it
20:19:13 <Cale> I don't really like calling typeclasses ad-hoc polymorphism
20:19:16 <ezyang> I have to admit, I'm not that hot about the IO interface
20:19:23 <philo> so how do informe other people about what a _generator is and what king of operation it does support ?
20:19:24 <[swift]_> ezyang: ahh, i see
20:19:27 <dmwit> philo: You can probably explicitly choose by doing something like (newLabel :: TempGenerator TempGeneratorState Temp Label => State TempGeneratorState Label) or so, but it sounds like way more pain than it's worth.
20:19:49 <Cale> They provide something which is only vaguely related to ad-hoc polymorphism, and considerably more flexible and useful.
20:20:06 <dmwit> philo: ...just provide the operations.
20:20:50 <o-_-o> there are 3900+ people subscribed to haskell reddit ?
20:21:03 <ezyang> 'parently
20:21:10 <o-_-o> and only 733 for C++, how is the C++ reddit larger than haskell reddit ?
20:21:27 <o-_-o> http://www.reddit.com/r/programming/comments/be9mj/favorite_obscure_programming_language/c0mc7q2
20:22:18 <o-_-o> maybe when dons wrote it there were not 3900+ people
20:22:46 <philo> ?
20:23:00 <Cale> There are 3998 subscribers to the C++ reddit
20:23:22 <Cale> (/r/cpp)
20:23:30 <o-_-o> ah
20:23:43 <o-_-o> //r/cplusplus :-)
20:23:44 <o-_-o> heh
20:24:55 <o-_-o> I did my little to haskell and subscribed to haskell reddit, although it is my homepage
20:25:17 <o-_-o> subsribing is just bookmarking the RSS fed, right ?
20:25:23 <o-_-o> subscribing*
20:26:16 <Cale> You go to the list of reddits and click the +frontpage button next to it
20:26:50 <Cale> oh, it also appears in the right hand sidebar
20:26:55 <Cale> (can't miss it)
20:27:16 <o-_-o> ah...yeah it is already on my frontpage too, so that is what subscribing is...
20:31:14 <ivanm> Cale: has anyone tried to refute your anti-pattern argument yet?
20:31:38 <ezyang> ivanm: What are you referring to?
20:32:13 <ivanm> it appears not...
20:32:16 <ivanm> ezyang: http://www.reddit.com/r/programming/comments/be471/how_do_you_model_things_in_objectoriented/c0mbrpc
20:32:39 <ezyang> aha
20:33:16 <Mathnerd314> well, it's true, so it's pretty hard to refute
20:33:38 <SamB_XP_> Mathnerd314: what is true ?
20:33:49 <ivanm> SamB_XP_: http://www.reddit.com/r/programming/comments/be471/how_do_you_model_things_in_objectoriented/c0mbrpc
20:34:03 <ezyang> The only possible argument against it is if no one can agree on how the pattern should actually be implemented, so you have to write it out in full every time
20:34:17 <ivanm> Mathnerd314: except that StoneCypher calls anyone who doesn't think much of design patterns an idiot
20:34:17 <ezyang> Although that may also be a failing of the language :-)
20:34:45 <ivanm> but I note that he hasn't tried to refute Cale's comment ;-)
20:34:46 <copumpkin> StoneCypher is an opinionated idiot himself
20:35:26 <ddarius> The intent of Christopher Alexander, in the context of architecture, was to use patterns to develop a language, not a reference book.
20:37:58 <ivanm> copumpkin: yup
20:38:11 <ivanm> copumpkin: so, you planning on coming to OzHackathon? :p
20:38:18 <copumpkin> I'd love to
20:38:27 <copumpkin> might need someone to pay for my plane ticket
20:39:15 <ivanm> you can yourself!
20:39:27 <Mathnerd314> OzHackathon?
20:39:38 <ivanm> yes
20:39:54 <Mathnerd314> what is it?
20:40:32 <ivanm> an australian hackathon Axman6 and I are trying to organise
20:40:33 <ddarius> It's a murder rampage in the Emerald City.
20:40:54 <ezyang> copumpkin: Is that because it's... (cough) Over The rainbow?
20:41:00 <copumpkin> yep
20:41:07 <ivanm> TacticalGrace: would you come to this proposed OzHackathon?  I know Axman6 wants to be able to pick your brains about Accelerate...
20:41:09 <Axman6> TacticalGrace! you want to come to an Aussie Haskell Hackathon right?
20:41:11 <Axman6> heh
20:41:15 <Mathnerd314> ivanm: you should let google find it ;-)
20:41:28 <ivanm> Mathnerd314: I sent the initial email about it _yesterday_
20:41:34 <ivanm> @google ozhackathon
20:41:35 <lambdabot> No Result Found.
20:41:49 <ivanm> and yup, there hasn't been enough chatter on the interwebs for google to know about it yet
20:42:07 <m3ga> with a bit of luck i'll be there
20:42:07 <ivanm> especially since we never referred to it as "OzHackathon" in the email
20:42:16 <roboshibby> i just met a guy named charles boner
20:42:16 <ivanm> m3ga: \o/
20:42:18 <roboshibby> lol
20:42:20 <ivanm> define "luck"?
20:42:28 <ivanm> roboshibby: so?
20:42:31 <roboshibby> that's the definition of luck.
20:42:40 <Axman6> m3ga: hooray!
20:42:43 <ivanm> roboshibby: that comment was for m3ga
20:42:48 <m3ga> keep it away from weekends, not too far from sydney (ie perth is out)
20:42:58 <ivanm> m3ga: away from weekends? :(
20:43:00 <m3ga> sorry, keep it away from weekdays.
20:43:05 <ivanm> *phew*
20:43:12 <m3ga> weekends good, weekdays bad
20:43:20 <ivanm> well, yes, a weekend in late June, early July is the plan
20:43:37 <m3ga> sounds good
20:44:11 <Mathnerd314> what's the point of 2 days?
20:44:27 <Mathnerd314> are there going to be 1000's of people or something?
20:44:41 <ivanm> @hoogle haskell hackathon
20:44:41 <lambdabot> No results found
20:44:44 <ivanm> grrr...
20:44:48 <ivanm> I think @google is broken
20:45:01 <ivanm> Mathnerd314: haskell hackers get together for a weekend to work on projects together
20:45:06 <m3ga> i'm sure theres not more than say 100 active haskell hackers in the whole country.
20:45:08 <ivanm> there's one in Zuric this weekend
20:45:13 <SamB_XP_> ivanm: I didn't do it!
20:45:21 <SamB_XP_> I haven't touched @google in probably half a decade!
20:45:38 <Axman6> SamB_XP_: that's probably why it's broken!
20:45:42 <ivanm> OK, SamB_XP_ is provisionally out...
20:45:43 <ivanm> ;-)
20:45:58 <ivanm> nah, google has probably changed their URL/API again and so lambdabot can't read the results properly
20:46:21 <ivanm> Mathnerd314: it's usually easier to collaborate in person than via IRC/email
20:46:52 <SamB_XP_> ivanm: or, you could do ALL THREE AT THE SAME TIME!
20:47:18 <ivanm> send an irc message asking someone to email someone else to come over?
20:47:31 <Mathnerd314> @google haskell
20:47:32 <lambdabot> http://www.haskell.org/
20:47:32 <lambdabot> Title: Haskell - HaskellWiki
20:47:38 <ivanm> OK, it's not completely gone...
20:47:42 <ivanm> @google zurihac
20:47:43 <lambdabot> http://www.haskell.org/haskellwiki/ZuriHac
20:47:43 <lambdabot> Title: ZuriHac - HaskellWiki
20:47:48 <ivanm> hmmm, so that works
20:47:50 <ivanm> @hoogle hackathon
20:47:50 <lambdabot> No results found
20:48:07 <SamB_XP_> well, I meant, you could IRC between different portions of a room, and visit eachother's workstations, and email files back and forth
20:48:37 <ivanm> hmmm.....
20:49:04 <ivanm> according to wikipedia, our hackathons are more technically known as "sprints"
20:49:22 <SamB_XP_> ivanm: both are acceptable
20:49:31 <SamB_XP_> hackathons alliterate better
20:49:36 <ivanm> apparently hackathon is for longer ones (e.g. a week)
20:49:40 <ivanm> SamB_XP_: yeah
20:49:42 <SamB_XP_> oh
20:49:45 <SamB_XP_> I see
20:51:29 * ivanm -> tutoring
20:54:43 <ddarius> Yay.  Down with completely coprime filters, up with powers.
20:55:28 <copumpkin> :o
21:04:02 <benmachine> cabal install won't install dynamic libraries for me on OSX because it says I haven't got a dyn version of base
21:04:28 <benmachine> obviously it won't install a dyn version of base
21:04:41 <benmachine> also: it's 4 am :(
21:04:50 * benmachine disables shared for the time being
21:10:19 <Axman6> benmachine: dynamic libraries only work on linux
21:16:22 <newsham> heh, check out the file comparison with 44bsd here: http://minnie.tuhs.org/cgi-bin/utree.pl?file=V1/man/man1/ed.1
21:16:50 <newsham> or http://minnie.tuhs.org/cgi-bin/utree.pl?file=V1/man/manintro.txt or http://minnie.tuhs.org/cgi-bin/utree.pl?file=V1/man/man1/ld.1
21:23:46 <Boohbah> haskell is messing with my lambda!
21:24:02 <newsham> oops, tihs is #haskell.. wrong window :(
21:24:56 <pickles> nite all
21:27:52 <alexbobp> I've googled around but I can't seem to find any documentation on using records
21:30:58 <alexbobp> how do I use haskell records?
21:33:15 <Mathnerd314> you don't?
21:33:16 <tensorpudding> you can define a record type, and it gives you helper functions which access the fields of the record
21:34:48 <Mathnerd314> that works too.
21:35:18 <o-_-o> I am sorry if this sounds dumb, but what do you do in a hackathon ?
21:35:19 <tensorpudding> data Foo = Fooo { first_field :: SomeType; second_field :: OtherType }
21:35:26 <o-_-o> code all day ?
21:35:29 <takeout> hey has anyone read the interview with john goerzen on why one should learn haskell?
21:35:47 * o-_-o is talking about ozHackathon
21:35:47 <tensorpudding> and that gives you functions first_field :: Foo -> SomeType and second_field :: Foo -> OtherType
21:35:56 <shachaf> alexbobp: http://book.realworldhaskell.org/read/data-structures.html might help?
21:36:51 <tensorpudding> also, that shouldn't be ;, but it should be ,
21:38:49 <o-_-o> Axman6, so are newbies allowed to attend a hackathon ?
21:39:05 <Axman6> hell yes they are!
21:39:09 * ezyang woudl hope so 
21:39:27 <Axman6> they're strongly encouraged to come along :)
21:39:54 <o-_-o> Axman6, what if I can't code myself out of a wet paper bag if my life and the life of everyone in the universe depended on it ?
21:40:07 <Axman6> then you shall come and learn!
21:40:14 <o-_-o> ah...ok
21:40:17 <o-_-o> nice
21:40:29 <o-_-o> I was always scared of the term hackathon
21:40:46 <Axman6> chopchopchop
21:41:21 <o-_-o> anyway I am really far away from the ozHackathon, maybe if something happened in my city
21:42:08 <Axman6> where are you?
21:42:25 <o-_-o> India
21:42:27 <o-_-o> :p
21:42:34 <Axman6> bah
21:42:50 <o-_-o> heh...sorry for the disappointing :-)
21:42:59 <o-_-o> but I would've loved to come
21:45:38 <o-_-o> ok serious question time, in OpenGL + GLUT we use the callback model to program. A callback modifies a global variable and then this is accessed by the main loop function to change the influence of the program. In Haskell the same model is carried over and State is used to store the variable which is modified by the callback. Is there any other model, which is more haskellish, and doesn't use to state to achieve the same thing ?
21:46:03 <o-_-o> s/change the influence/change the flow
21:59:18 <Axman6> o-_-o: FRP might do it, not sure
22:17:57 <cads> Hey, can I get @src @hoogle and @pl functionality inside GHCi?
22:19:21 <Veinor> yeah.
22:19:47 <Veinor> http://www.haskell.org/haskellwiki/GHC/GHCi#GHCi_on_Acid
22:21:14 <cads> hello!
22:21:26 <cads> why thanks veinor, that looks damn awesome
22:21:43 <Veinor> it's pretty cool, yeah.
22:22:59 <Veinor> hm. I think I might need to screw around with dependencies though. :(
22:24:26 <Veinor> ok, you need tagsoup-0.6
22:24:38 <Veinor> otherwise you get conflicting version dependencies
22:24:42 <cads> dependency for goa?
22:25:06 <Veinor> for lambdabot.
22:26:12 <Veinor> whee, installing readline
22:27:55 <cads> hmm, lambdabot seems to be compiling from cabal!
22:28:12 <Veinor> ?
22:28:23 <cads> cabal install lambdabot wouldn't work in the past
22:29:04 <Veinor> ah
22:29:31 <cads> ah, it almost installed.
22:29:35 <Veinor> what failed?
22:29:59 <cads> unix-2.4.0.0 and a few things that depended on it like readline
22:30:20 <cads> I'm in windows :)
22:30:53 <Veinor> ahh.
22:31:01 <Veinor> yeah, I have to deal with readline too
22:31:04 <Veinor> osx, wheee
22:31:20 <cads> hmm, you'd think that'd work
22:32:14 <cads> arright, here it is: unix-2.4.0.0 failed during the configure step. The exception was: sh: runGenProcess: does not exist (no such file or directory)
22:32:35 <byorgey> I don't think GOA has been maintained in a very long time.
22:32:49 <byorgey> last upload was September 2008.
22:33:02 <Veinor> yeah, but it still works
22:33:08 <byorgey> really? cool =)
22:33:20 <cads> ah cool, there's a forem entry with my runGenProcess problem
22:33:22 <Veinor> also, I want to see if I can get macports's readline library to work
22:33:38 <Veinor> because, y'know, that's the point of macports :P
22:35:14 <cads> hmm, seems like I just don't have sh and it's required
22:35:33 <cads> cygwin or msys to the rescure!
22:35:55 <Lycurgus> GOA = GHC on Acid?
22:36:04 <Lycurgus> *ACID
22:36:18 <Spaceghost> cads; exist something similar to yakuake for Windows?
22:36:36 <byorgey> I think Acid is the correct capitalization
22:37:04 <Lycurgus> well it's an acronym, so technically no it isn't
22:37:16 <cads> spaceghost, yakuake on windows would be plush :)
22:37:17 <ddarius> It's not an acronym there.
22:37:36 <Lycurgus> it's not Atomicity, Consistencty, etc.?
22:37:44 <Spaceghost> I don't understand
22:37:48 <cads> Spaceghost, there are a few decent terminal emulators for windows, the problem is that there aren't really any decent shells.
22:38:00 <ddarius> Not in that context.  Also, it's GHCi, not GHC.
22:38:08 <o-_-o> is there a video of the galois talk on CHP ?
22:38:28 <ddarius> The reference is to LSD.
22:38:29 <Veinor> http://hackage.haskell.org/trac/ghc/ticket/3121 oh hey
22:38:46 <Spaceghost> something practice for run the commandprompt when I touch a key for Windows is impossible, cads?
22:38:52 <Lycurgus> well that's redundant, the whole haskell deal is trippin' :)
22:40:37 <cads> Spaceghost, check it out: http://www.codeplex.com/PoshConsole . It might need windows vista/7 though
22:40:55 <cads> Lycurgus, like, yeah, man
22:42:24 <Lycurgus> *consistency
22:43:06 <Veinor> cabal keeps telling me there's a newer version @_@
22:43:22 <Veinor> because it's not upgrading itself to 0.6.4 for some reason
22:43:26 <Spaceghost> thanks, let me see
22:45:00 <Veinor> ... wait, where the hell is the cabal binary?
22:45:28 <Veinor> why is it installed in /usr/local/bin?
22:45:38 <Veinor> I blame the haskell platform.
22:46:13 <Mathnerd314> maybe you have multiple cabals? and one is shadowing the other?
22:46:25 <Mathnerd314> (like was happening with me)
22:46:42 <Spaceghost> cads; I was searching this! someone that allow me use the "QuakeMode"
22:46:43 <Veinor> I have the cabal in ~/.cabal/bin, and for some reason the OSX haskell framework installer installed one in /usr/local/bin that pointed to its own copy.
22:46:47 <Spaceghost> thank you so much cads!
22:46:56 <Veinor> bleh... I miss linux.
22:47:00 <Spaceghost> s/someone/something/
22:47:21 <cads> Veinor, be glad you're not stuck in windows
22:47:27 <Veinor> true.
22:48:11 <Veinor> also, it annoys me that this bug has been filed for 12 months and hasn't been fixed. http://hackage.haskell.org/trac/ghc/ticket/3121
22:54:24 <Mathnerd314> it annoys me that C++ has been around for 12 years and still hasn't died.
22:55:31 <Veinor> ok, I managed to work around it.
22:55:49 <Veinor> ... or wait, no I didn't. :(
23:21:21 <cads> Would it be terribly hard to may an experimental haskell extension such that I could define a postfix operator '!' for the factorial?
23:21:38 <cads> s/may/make
23:21:45 <copumpkin> > let (!) x = product [1..x] in 5 !
23:21:47 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
23:21:52 <copumpkin> it is a valid extension
23:21:56 <copumpkin> it used to be turned on in lambdabot
23:22:05 <Veinor> what extension is it?
23:22:15 <copumpkin> -XPostfixOperators
23:22:21 <byorgey> > let (!) x = product [1..x] in (5!)
23:22:22 <lambdabot>   120
23:22:24 <Veinor> ... figured.
23:22:28 <copumpkin> oh that's it
23:22:32 <byorgey> you can sort of do it with sections
23:22:35 <Veinor> ARRRGH
23:22:41 <Veinor> readline still fails. :(
23:22:41 <copumpkin> it's a nasty hack
23:22:43 <copumpkin> don't use it
23:22:57 <ezyang> rlwrap for the win
23:23:02 <cads> heh, that looks like a nasty hack but technically.. is sort of works
23:23:17 <byorgey> hmm, I didn't realize you needed to turn on an extension to enable that.
23:23:30 <ezyang> copumpkin: wouldn't that be partially applying an infix operator?
23:23:35 <ezyang> but... it's not binary :-)
23:23:39 <copumpkin> yep
23:23:41 <shrughes> you didn't in 6.8 anyway, i don't know about 6.10, and apparently you do in 6.12
23:23:55 <Veinor> /Users/phurst/.cabal/lib/readline-1.0.1.0/ghc-6.10.4/HSreadline-1.0.1.0.o: unknown symbol `_rl_basic_quote_characters'
23:24:02 <Mathnerd314> are there any GHC extensions that you *wouldn't* want to use?
23:24:26 <ezyang> Looks like an Apple project
23:24:31 <ezyang> *problem, Veinor
23:24:42 <Veinor> I think it might have something to do with 64-bit-ness
23:24:48 <copumpkin> Mathnerd314: yep
23:24:54 <Veinor> ... should I maybe try GHC 6.12? :O
23:24:55 <copumpkin> overlapping, incoherent, and undecidable instances, mostly
23:25:17 <ezyang> Veinor: Google for that symbol error
23:25:28 <ezyang> I doubt GHC 6.12 will fix things. It will probably break more things
23:26:05 <byorgey> undecidable instances isn't nearly as bad as the other two.
23:26:24 <byorgey> it just means that the type checker might loop.  but if it doesn't, everything is peachy.
23:26:29 <ezyang> i,i {-# LANGUAGE UnrecognizableInstances #-}
23:26:42 <byorgey> termination is overrated.
23:26:42 <copumpkin> :P
23:26:42 <Veinor> :P
23:27:23 <edwardk> hrmmph. i just spent a bunch of time retooling a fingertree of bytestrings that i was using so it could be used as a Network.BufferType -- which works fine, but to do anything useful I need to be an HStream -- and HTTP doesn't export the constructors needed to be able to do that work =(
23:27:30 <cads> > let (!) n = product [1..n]  in (n!)  -- This doesn't work here at home, is it because lambdabot has the extension turned on?
23:27:31 <lambdabot>   * Exception: not a number
23:27:45 <cads> > let (!) n = product [1..n]  in (10!)
23:27:45 <byorgey> edwardk: boo =(
23:27:46 <lambdabot>   3628800
23:28:10 <shrughes> either that or lambdabot isn't running the latest ghc version
23:28:15 <cads> hehe, I tried both forms above here on my ghci and no dice
23:28:16 <edwardk> byorgey: i seriously was not expecting that hurdle. or i wouldn't have spent so much time polishing the string-like methods of the buffer class
23:28:48 <Mathnerd314> copumpkin: those extensions seem to be necessary to program in a polymorphic way...
23:28:57 <copumpkin> Mathnerd314: not really
23:29:09 <copumpkin> well, define what you mean
23:29:22 <Mathnerd314> stuff like inheritance
23:29:39 <copumpkin> well, that's cause we don't use stuff like that
23:29:54 <Mathnerd314> *you* don't use stuff like that
23:30:10 <Mathnerd314> but I get your point
23:30:15 <copumpkin> Mathnerd314: let's say that the idiomatic way doesn't typically involve such constructs
23:30:25 <copumpkin> and that's why we don't mind much that they're relegated in scary extensions
23:30:28 <shrughes> inheritance isn't really any different from a conversion operator
23:30:52 <Mathnerd314> it's probably just another monad...
23:30:58 <copumpkin> Mathnerd314: you can write c or ruby in haskell if you want, but it's not pretty :P
23:31:11 <Mathnerd314> copumpkin: why?
23:31:34 <Mathnerd314> all programs should be pretty...
23:31:38 <jmcarthur> lament: i don't think something is *wrong* with transformers. they just aren't true monad composition. a transformer modifies a monad rather than composing it with another. maybe that distinction is too subtle to matter in practice, though
23:31:54 <shrughes> Mathnerd314: if you want some types to "inherit" from some type Super, write a   class InheritsFromSuper a where { upcast :: a -> Super }
23:32:18 <edwardk> ok, i'm officially forced to give up on parsec 3 as well. because too many of my dependencies needed parsec 2 =(
23:32:21 <Raynes> It's like trying to write a 10 thousand word essay on a 1cm by 1cm piece of paper with a 10 foot wide, 2 inch tall pencil.
23:32:22 <Mathnerd314> if I want overloaded functions though...
23:32:45 <Mathnerd314> Raynes: what is?
23:32:49 <edwardk> i'm starting to agree more and more with the proposal that parsec3 should be a new package, not a version bump on the existing one
23:36:30 <alexbobp> shachaf: Thanks for the link!
23:37:17 <byorgey> I think the proposal to rename parsec-2 to parsec-4 is just absurd though.
23:37:39 <edwardk> well
23:37:42 <edwardk> i'm not so sure
23:37:48 <byorgey> but renaming one or the other as something else could work.
23:38:07 <edwardk> it _would_ fix the weirdness of having the default in hackage that causes everyone headaches
23:38:33 <byorgey> it's absurd on principle.  basically, we'd be doing it just for the side effects, without any regard for the semantics.
23:39:09 <edwardk> well, parsec 3 was an upgrade path that unfortunately people didn't take because it was too big of a break in the semantics
23:39:28 <edwardk> (and in the performance) ;)
23:39:53 <byorgey> fair enough.  but in that case I think we should move parsec-3 to a different name, and delete the current one from Hackage, leaving parsec-2 as the latest version of "parsec".
23:40:01 <edwardk> my biggest problem is that i have to use HTTP and some other machinery all of which use Parsec-2
23:40:20 <edwardk> there is no provision for deleting from hackage
23:40:21 <byorgey> yeah, sad =(
23:40:28 <ezyang> :-(
23:40:37 <byorgey> edwardk: it can be done though.  it just isn't normal.
23:40:38 <ezyang> dcoutts should hurry up and finish his PhD thesis
23:40:43 <byorgey> and this situation is not normal.
23:40:47 <edwardk> so in light of that, the upgrading to parsec 4 is the easiest way to 'erase' it
23:40:48 <edwardk> well
23:40:59 <edwardk> i have a bunch of packages that would break if parsec 3 didn't exist any more
23:41:05 <edwardk> so there is a big ripple effect
23:41:27 <byorgey> edwardk: but would those packages still choose parsec 3 if there was a parsec 4?
23:41:29 <edwardk> you _really_ shouldn't delete things that are referenced, even by old packages
23:41:52 <byorgey> things are going to break any way you slice it.
23:41:54 <edwardk> because then you can't even try to build the old package, even in a configuration that could only run that
23:42:15 <edwardk> adding parsec 4 doesn't break any existing built packages.
23:42:25 <byorgey> sigh
23:42:27 <ezyang> unless they were silly and said parsec > 3
23:42:29 * byorgey hates backwards compatibility
23:42:45 <edwardk> ezyang: then it is their own damn fault for not following the PVP ;)
23:43:31 <ezyang> edwardk: prolly :-)
23:44:23 <edwardk> the "soluton" of deleting parsec 3, and breaking dozens of old and current versions of dozens of packages doesn't sound pleasant. right now they just can't be used with anything that uses parsec 2.
23:45:23 <ezyang> edwardk: Another solution would be to allow multiple major version of package mixing in a binary
23:45:24 <edwardk> i like the fact that i can come along with an old GHC circa 6.8, and just grab the next more recent version of something that happens to still work with the surrounding dependencies
23:46:55 <edwardk> ezyang: i'm told that that involves some fairly deep changes in the way everything gets linked together
23:47:04 <ezyang> blah
23:47:39 <edwardk> it would be nice to be able to distinguish between an internal and an external dependency for a module though
23:48:06 <edwardk> i.e. if HTTP didn't export of parsec 2's constructors or types, it'd be nice to be able to ignore that it uses it
23:48:49 <ezyang> that's definitely true
23:49:04 <ezyang> but the linking namespace is global, isn't it
23:49:10 <edwardk> yeah
23:49:30 <edwardk> i'm mostly just thinking out loud, because i happen to be wrestling with how i load modules in kata at the moment ;)
23:49:46 <ezyang> heh
23:49:51 <edwardk> so i have an opportunity to try to do things differently if there is a better way
23:52:34 <ski> @messages
23:52:34 <lambdabot> edwardk said 6h 14m 35s ago: dataÂ CoYonedaÂ f a =Â forallÂ b .Â CoYonedaÂ (b -> a) (f b) -- is in category-extras Control.Functor.Yoneda, which is of course a left kan extension along Identity.
23:53:10 <ski> edwardk : am i right in thinking `CoYoneda f' is something like a "free functor" over `f' ?
23:53:13 <edwardk> ski: your type was just the contravariant yoneda lemma
23:53:59 <edwardk> it is isomorphic to f (modulo the extra bottom due to haskell's odd implementation of existentials)
23:54:16 <edwardk> the 'free' functor is just like the one in Yoneda
23:54:50 <ski> hm
23:54:55 <ski> consider
23:55:04 <ski>   data T :: * -> *
23:55:06 <ski>     where
23:55:10 <ski>     U :: T ()
23:55:20 <ski> `T' is not a `Functor'
23:55:28 <edwardk> newtypeÂ YonedaÂ f a =Â YonedaÂ {runYonedaÂ ::Â forallÂ b. (a -> b) -> f b} -- also has a functor instance regardless of the type of f
23:55:32 <ski> but i think `CoYoneda T' is a `Functor'
23:55:37 <edwardk> it is
23:55:41 <edwardk> http://hackage.haskell.org/packages/archive/category-extras/0.53.0/doc/html/Control-Functor-Yoneda.html
23:55:44 <edwardk> i have instances for both in here
23:56:06 <edwardk> that is an artifact that Ran f g is a functor regardless of the types of f and g. they only need to have kind * -> *
23:56:16 <ski> so how could `CoYoneda f' be isomorphic to `f', if there's an example where the former is a `Functor', but the latter isn't ?
23:56:19 <edwardk> and Yoneda and CoYoneda are both special cases of Ran f g and Lan f g respectively
23:56:53 <ezyang> edwardk: How much category theory do I have to learn to figure out what Yoneda is?
23:57:08 <edwardk> ezyang: none, just one article by dpiponi
23:57:31 <edwardk> http://blog.sigfpe.com/2006/11/yoneda-lemma.html
23:58:13 <ezyang> Mmmm! Will read.
23:58:23 <ezyang> Instead of doing stupid pointer tricks in Scheme (which I should be doing :-)
23:59:00 <edwardk> ski: well, the isomorphism only works if f is a functor, which it IS, it just isn;t a functor over Hask, so to go from  CoYoneda f ~> f requires Functor f ;)
23:59:28 <edwardk> but you can go from f :~> CoYoneda f regardless of the type of f.
23:59:57 <ski> hm, right, i noted i needed `Functor f' in the "unwrapping" direction
