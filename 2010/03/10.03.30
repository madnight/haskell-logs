00:10:09 <chrisdone> I hope gunther gets banned from the mailing list
00:10:36 <chrisdone> if you're in here, gunther: a pox on you!
00:11:43 <ivanm> chrisdone: agreed
00:11:53 <ivanm> whilst we're wishing, why not that zaxis guy as well
00:12:08 <silver> cafe?
00:12:19 <ivanm> yes
00:12:44 <ivanm> greetings dibblego
00:12:47 <ivanm> hows sydney?
00:12:52 <dibblego> wet
00:13:23 <ivanm> yeah, it's pretty wet here as well :s
00:16:43 <dibblego> they cancelled my flight
00:17:10 <ivanm> dibblego: :o
00:17:17 <ivanm> as in you couldn't even get _to_ sydney?
00:17:25 <dibblego> get home
00:17:57 <ivanm> ahhh
00:18:04 <ivanm> wait, you were doing a flying trip?
00:18:14 <ivanm> I thought you were going for the actual surgery today
00:18:23 <dibblego> no surgery today, just diagnosis
00:18:26 <ivanm> aha
00:18:30 <ivanm> and? how'd it go?
00:18:47 <dibblego> still nothing concrete, but definitely have a lot of people suspicious
00:18:54 <dibblego> I know what it is :)
00:19:10 <dibblego> I'll do their tests while they catch yp
00:19:11 <dibblego> *up
00:19:12 <ivanm> as in suspicious of what it might be or of you?
00:19:20 <dibblego> suspicious of what is going on
00:19:24 <dons> hmm. wishing for bans eh?
00:19:24 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
00:19:26 <dibblego> (and what they are suspicious of, is only half right)
00:19:31 <dons> we'll see. there are methods that can be employed.
00:19:45 <benmachine> bans pfft
00:19:50 <ivanm> yay for dons, the anti-troll!
00:19:50 <benmachine> people need to be less excitable :P
00:20:13 <marcel1> # Appears as ANNA
00:20:26 <marcel1> (#G7::E010M1) hi
00:20:38 <dibblego> omg a 747 is coming to SYD under mayday!
00:20:47 <ivanm> dibblego: :o
00:20:49 <ivanm> where from?
00:20:54 <dibblego> SNG
00:21:17 <ivanm> hmmm...
00:21:29 <dibblego> it just did a fuel dump and is coming back to SYD
00:21:32 <dibblego> a B747!
00:21:34 <putnam> t
00:21:55 <ivanm> dibblego: how many people are starting to run? :p
00:22:38 <dibblego> ha, nobody else knows
00:22:57 <ivanm> how do you know then?
00:23:04 <dibblego> because I watch aircraft
00:23:08 <ivanm> aha
00:23:18 <ivanm> anyway, conroy is having a debate tonight about the internet filter in case you're interested
00:23:58 <dibblego> haha a "debate" haha
00:24:09 <dibblego> more like a comments section on reddit
00:24:13 <ivanm> with someone from EFA, the head engineer from internode, etc.
00:24:18 <ivanm> on ABC radio
00:24:52 <dibblego> does sound interesting
00:25:17 * ivanm does't have a radio, so can't listen
00:25:27 <dibblego> isn't there an internet feed?
00:25:41 <ivanm> could be
00:25:48 <ivanm> but I"ll be watching TV probably anyway *shrug*
00:26:32 <marcel0> # Appears as ANNA
00:26:41 <marcel0> (#G010E010M1) hey guys
00:26:47 <kmc> for real?
00:26:48 <marcel0> (#G1<:E210M1) i'm using ms comic chat to talk in #haskell :D
00:26:52 <Zao> marcel0: Please don't.
00:26:56 <kmc> marcel0, you're my hero
00:27:03 <marcel0> (#G?;:E=10M1) you guys look cool
00:27:16 <kmc> marcel0, do we have to talk like jerkcity now
00:27:17 <Zao> You look like binary dung.
00:27:25 <kmc> which guy am i
00:27:33 <marcel0> (#G?;:E@10M1) you are the one with wiry hair
00:27:35 <Zao> I so wish that Comic Chat would have used some out-of-band identification.
00:27:37 <marcel0> (#G1<:EA10M1) i'll send a screenshot
00:27:52 <marcel0> (#G210E010M1) http://mantup.com/chris/screenshots/2010-03-30_121714-4bb1a57a55988.png
00:28:06 <ivanm> @where ops
00:28:06 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver monochrom
00:28:21 <bens> ivanm: do you mean this from yesterday? http://www.abc.net.au/rn/australiatalks/stories/2010/2835549.htm
00:28:22 --- mode: ChanServ set +o glguy
00:28:23 <kmc> hehe, ChanServ is the guy with the bag on his head
00:28:26 <kmc> oh come on
00:28:28 <kmc> this is good fun
00:28:28 <glguy> What's up?
00:28:31 <kmc> don't ban him ;P
00:28:36 <allbery_b> marcel0
00:28:43 <ivanm> bens: oh, did I get the date wrong?
00:28:48 <kmc> # Appears as PANTS
00:28:57 * allbery_b is Not Amused
00:28:59 <marcel0> (#G>10E=10M1) yes alien monster?
00:29:04 <ivanm> no, please ban him!
00:29:08 <kmc> HLAGHLUAHGLAGAG
00:29:12 <bens> ivanm: I just did a quick look for it since it sounded interesting and found that
00:29:12 <marcel0> (#G010E@10M1) lmao
00:29:19 --- mode: glguy set +b *!*@173-13-170-133-sfba.hfc.comcastbusiness.net
00:29:21 <kmc> GLUAHGLAG LGAHULAG HGLUAGHG
00:29:28 <kmc> ok i'm done
00:29:35 <allbery_b> kmc, go find another channel he's infesting
00:29:36 <bens> I didn't know of it before
00:29:38 <ivanm> bens: bugger, I read it off whirlpool's front page, and didn't realise it was _yesterday's_ news :s
00:29:57 <ivanm> so, who won? :p
00:30:34 <bens> ivanm: oh well, it's there for download.  Haven't listened to it yet.
00:34:40 <putnam> hm
00:34:50 <dobie_gillis> hello, I'm getting a 'less polymorphic than expected' error and i'd like to know why: http://codepad.org/Jzgta5tU
00:35:16 <ivanm> dobie_gillis: is that Hugs?
00:35:25 <ivanm> dobie_gillis: give them explicit types
00:35:37 <ivanm> just setting a type for microsecond should work
00:35:40 <dobie_gillis> ivanm: ghci 6.10.4
00:35:48 <ivanm> it does errors like that?
00:35:49 <ivanm> :o
00:35:53 <ivanm> I dont' recall anything like that...
00:36:03 <ivanm> dobie_gillis: are you wanting them to be Ints or Num a's?
00:36:09 <kmc> dobie_gillis, nothing is forcing microsecond, second, minute, etc. to have the *same* type
00:36:11 <ivanm> I _think_ 1e6 is only valid for Floating
00:36:14 <ivanm> @type 1e6
00:36:15 <kmc> and so it objects that you use f on all of them
00:36:15 <lambdabot> forall t. (Fractional t) => t
00:36:26 <ivanm> nah, the problem is the 1e6 methinks
00:36:26 <dobie_gillis> Num a's because i would like to use log on them
00:36:36 <ivanm> dobie_gillis: that's not right then
00:36:40 <dobie_gillis> hmm.. i think i tried it without the 1e6..
00:36:40 <ivanm> log needs Fractional
00:36:41 <kmc> :t 1e6
00:36:42 <lambdabot> forall t. (Fractional t) => t
00:36:42 <ivanm> @type log
00:36:43 <lambdabot> forall a. (Floating a) => a -> a
00:36:47 <ivanm> dobie_gillis: ^^
00:36:55 <ivanm> microsecond :: (Floating a) => a
00:36:56 <kmc> dobie_gillis, the simplest fix i think is to give a sig for all those constants to Double
00:37:07 <ivanm> kmc: just for microsecond should suffice
00:37:10 <kmc> true
00:37:23 <kmc> actually, never mind, they will all have the same type
00:37:25 <ivanm> though you should give types to all functions and constants
00:37:45 <ivanm> AFAICT, the problem is that microsecond is defaulting to Integral, but then second tries to multiply it by 1e6
00:38:43 <kmc> if you add the sig "microsecond :: Double" , you get another problem
00:38:55 <dobie_gillis> yeah.. but i'll just change everything to Double
00:39:02 <kmc> which is that findAll only requires that you pass it *some* function of the form (a -> a) for (Show a, Num a, Ord a)
00:39:11 <kmc> so it's perfectly legal to pass it id :: Int -> Int
00:39:26 <kmc> seems like the fully-general version would require a rank-2 type
00:39:40 <kmc> findAll :: (forall a. (Show a, Num a, Ord a) => a -> a) -> String
00:39:53 <ivanm> you'll have to restrict the types there
00:39:59 <ivanm> *type constraints
00:40:04 --- mode: glguy set -b *!*@173-13-170-133-sfba.hfc.comcastbusiness.net
00:40:18 <MasseR> How do you haskellers have your vim configured? I have serious trouble for properly indenting haskell with vim. My default setup is "one level = 4 spaces, two level = 1 tab (8 spaces wide)"
00:40:40 --- mode: glguy set -o glguy
00:40:41 <dobie_gillis> MasseR: :O no wonder! don't mix spaces and tabs in haskell...
00:40:45 <kmc> confirming that it checks with this rank-2 type
00:40:52 <kmc> confirmed
00:42:04 <ivanm> MasseR: especially if you want it cross platform: windows thinks 1 tab == 4 spaces
00:42:21 <kmc> Haskell thinks 1 tab = 8 spaces, always.  it's in the spec
00:42:21 <ivanm> note also that some people have their editors set to 1 tab == 4 spaces, or even 2 spaces
00:42:22 <MasseR> ivanm dobie_gillis so, I take it you recommend n-width spaces?
00:42:25 <kmc> best not to use tabs at all
00:42:28 <ivanm> which means your code will have problems being readable
00:42:47 <ivanm> MasseR: indent = 4 spaces (or 2, or whatever, just be consistent)
00:42:52 <ivanm> and then use multiples of that indent
00:42:57 * glguy advocates an all spaces model, but those people who open Haskell files with 4 space tabs are just doing it wrong
00:43:06 <ivanm> kmc: is it? I thought it was OS-dependent...
00:43:12 <kmc> i think it's in the Report
00:43:20 <ivanm> glguy: why, what do you use?
00:43:27 <kmc> remember also that whitespace-dependence is optional, though it's considered good style to use it mostly
00:43:44 <glguy> ivanm: I mean that tabs are defined to be 8 space tabs for Haskell
00:43:50 <dobie_gillis> MasseR: yes, spaces are the best way to go for haskell.. if you do prefer tabs you have to add a newline+indent after do's and let's and some others possibly
00:43:51 <glguy> I indent with 2 spaces
00:44:15 <ivanm> dobie_gillis: huh?
00:46:06 <dobie_gillis> ivanm: i needed to add a newline in some let's to fix syntax errors i was getting when i used tabs for haskell recently.. someone on this channel recommended that trick i forget who
00:46:35 <ivanm> weird :s
00:48:06 <ivanm> :o criterion uses parsec now? what for?
00:48:36 <ivanm> oh, it has for a while...
00:50:15 <superoptimizer> erg. apparently my brain is off this evening. is there an easy way to round an integer to the next power of 10? i'm getting all sorts of type errors i can't seem to fix.
00:52:05 <danderson> divide by 10, round and multiply by 10?
00:52:20 <danderson> with the appropriate fromIntegrals and the like to convert between numeric types
00:52:51 <superoptimizer> I think that's what I'm not getting right. I'm trying to cast a little more like C style and getting errors about numeric constructors.
00:53:44 <luite> > let nextPowerOfTen n = 10^(length $ show (n-1)) in nextPowerOfTen 99
00:53:45 <lambdabot>   100
00:53:49 <luite> :)
00:54:04 <luite> must be one of the ugliest approaches :p
00:54:35 <koala_man> haha nice, log by string length
00:55:33 <koala_man> > let nextPower x = 10^(ceiling (log x/log 10)) in nextPower 99
00:55:34 <lambdabot>   100
00:55:46 <pao> I'm looking for a byN function with signature Int -> [a] -> [[a]] ... doesn't it seem strange there isn't one in Prelude?
00:58:07 <superoptimizer> what's the right way to convert from floating-point to integer?
00:58:21 <superoptimizer> haven't seen this in RWH yet :(
00:58:35 <pao> superoptimizer: round or a variant
00:58:40 <pao> > round 1.2
00:58:41 <lambdabot>   1
00:58:52 <theorbtwo> :t round 1.2
00:58:53 <lambdabot> forall b. (Integral b) => b
00:59:04 <Nereid> :t round
00:59:05 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
00:59:06 <superoptimizer> oh, maybe my mistake is using 10.0 rather than 10.
00:59:08 <superoptimizer> I'm using ceiling
00:59:10 <ivanm> round, trunc, ceil, floor
00:59:15 <superoptimizer> which is what i want
00:59:46 <pao> > ceiling 1.2
00:59:47 <lambdabot>   2
01:00:36 <superoptimizer> okay, thanks. it was the "... * 10.0" rather than "... * 10" causing problems
01:00:38 <superoptimizer> :s
01:00:52 <Jonno_FTW> @src ceiling
01:00:52 <lambdabot> Source not found. My mind is going. I can feel it.
01:04:40 <superoptimizer> > ceiling 17
01:04:41 <lambdabot>   17
01:04:54 <superoptimizer> > ceiling 17.2
01:04:55 <lambdabot>   18
01:06:05 <superoptimizer> > foldr (+) 0 [1..10]
01:06:06 <lambdabot>   55
01:06:22 <superoptimizer> > ((10+1)*(10))/2
01:06:23 <lambdabot>   55.0
01:06:30 <superoptimizer> whew :)
01:08:22 <Nereid> > ((10+1)*(10)) `div` 2
01:08:23 <lambdabot>   55
01:11:01 <FerchoArg> hi I have a noob question
01:11:25 <FerchoArg> I'm doing this:
01:12:04 <FerchoArg> instance Eq (MyNumberList) where
01:12:25 <FerchoArg> (MyNumber x) == (MyNumber y) = x == y
01:12:34 <luqui> :t ceiling
01:12:35 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
01:12:54 <FerchoArg> but I got this error:
01:13:00 <FerchoArg> Ambiguous variable occurrence "=="
01:13:00 <FerchoArg> *** Could refer to: Main.== Hugs.Prelude.==
01:13:22 <luqui> did you indent that second line?
01:13:23 <FerchoArg> I don't know how to eliminate that ambiguity
01:13:25 <Zao> Indent it?
01:14:03 <luqui> without indentation it parses as instance Eq (MyNumberList) where {} ; (MyNumber x) == (MyNumber y) = x == y
01:14:04 <FerchoArg> THANKS, you rock
01:14:19 <FerchoArg> it works now
01:14:22 <FerchoArg> thanks
01:26:13 <Twey> > round 2.5
01:26:14 <lambdabot>   2
01:27:38 <ivanm> has anyone here managed to build the latest version of criterion?
01:30:32 <silver> @hoogle sign
01:30:32 <lambdabot> Control.Concurrent.QSem signalQSem :: QSem -> IO ()
01:30:32 <lambdabot> Control.Concurrent.QSemN signalQSemN :: QSemN -> Int -> IO ()
01:30:33 <lambdabot> Prelude significand :: RealFloat a => a -> a
01:37:10 <Younder> Is NP a true subset of EXPSPACE?
01:38:21 <Younder> Or, let me reprprase that. If they were proven equivalent wouln't P =/= NP follow as P is a true subset of EXPSPACE?
01:39:19 <Younder> EXPSPACE def as the algorithms h of O(2^k)
01:39:29 <ivanm> preflex: seen bos
01:39:29 <preflex>  bos was last seen on #haskell 9 hours, 38 minutes and 20 seconds ago, saying: parameterising over a monad that allows mutation
01:40:30 <ivanm> @ask bos it appears that (even if you use a patched gtk2hs to get it working) that the chart support for criterion doesn't work, apparently because it uses a lot of no-longer-existent uvector functions (e.g. fromU is not in scope)
01:40:30 <lambdabot> Consider it noted.
01:40:35 <ivanm> @tell bos
01:40:35 <lambdabot> Consider it noted.
01:41:02 <ivanm> @tell bos whoops, sorry for the empty msg; this would presumably also apply for people building on <6.12
01:41:03 <lambdabot> Consider it noted.
01:41:23 <Younder> been studying lambda calculus as a alternative to turing machines for theory of NP completeness. ("Computers and intractabillity", "The Lambda calculuse, the sysntax and semantics")
01:42:37 <superoptimizer> @help
01:42:37 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
01:42:41 <superoptimizer> @list
01:42:42 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
01:43:34 <kmc> Younder, by "true subset" you mean "proper subset"?
01:43:51 <superoptimizer> @help unlambda
01:43:52 <lambdabot> unlambda <expr>. Evaluate an unlambda expression
01:44:25 <kmc> NP <= PSPACE < EXPSPACE
01:44:35 <kmc> so NP /= EXPSPACE, this much is known
01:45:01 <luqui> anybody know a subethaedit that works between linux and mac?
01:45:16 <kmc> i have not the slightest idea what that word means
01:45:17 <Younder> kmc, yes, that was sloppy
01:46:10 <quicksilver> luqui: well, emacs supports various simplistic kinds of collaborative editing.
01:46:26 <quicksilver> luqui: not as sophisticated as SEE's reputation would have you think it is. I've never used it though.
01:46:39 * quicksilver is violenty allergic to nonfree editors.
01:46:55 <zygoloid> Younder: you might find this useful/interesting: http://www.math.ucdavis.edu/~greg/zoology/diagram.xml
01:49:23 <MasseR> Is there a program that downloads dependency packages automatically? For hackagedb. (I'm installing hothasktags) which has a few dependencies.
01:51:44 <MasseR> cabal-install apparently
01:52:30 <nff> MasseR, yes cabal is what you need
01:54:23 <Younder> zygoloid, More scary actually.. I don't know but a fraction of those spaces
01:55:53 <Younder> zygoloid, On closer inspection many of the entries are abbeviations for problems and reductions to other problems to spaces..
02:18:40 <systemfault> Compiling ghc+llvm is ffuuuuuu
02:19:31 <silver> n?
02:20:45 <waterlaz> I've uploaded a package to hackage and it sais "Build failure"
02:21:01 <liyang> silver: no, lurk moar.
02:21:20 <waterlaz> The log fails at configure with this "Missing C libraries: xmmsclient, xmmsclient-glib"
02:21:47 <waterlaz> which is obvious since the package is a set of bindings
02:22:10 <waterlaz> so my question is how should I treet this?
02:25:08 <waterlaz> could anyone help me with this, please? :3
02:25:25 <amanda9> http://www.mdhjakten.se/dela/?id=dti2d6s
02:25:27 <amanda9> great stuff
02:27:46 <ivanm> amanda9: with what?
02:28:09 <ivanm> I meant waterlaz
02:28:15 <ivanm> waterlaz: check the build log
02:28:19 <ivanm> oh, right
02:28:22 <ivanm> waterlaz: don't worry about it
02:28:38 <ivanm> in future, you'll be able to upload "proper" hackage docs in situations like this
02:28:50 <ivanm> amanda9: it redirects to mdh.se... why should we care?
02:29:09 * ivanm just started a phd, and doenst' think his uni would be too happy if he suddenly decided to go to sweden instead
02:29:10 <waterlaz> ivanm, thanks
02:34:54 <waterlaz> when is it ok to use unsafe in haskell's ffi?
02:35:21 <waterlaz> I can't find a good explanation of that
02:36:16 <dolio> I believe it's okay when the C doesn't call back into Haskell.
02:37:03 <waterlaz> that's what I've heard
02:37:07 <waterlaz> but...
02:37:39 <waterlaz> is it ok for C code to start another thread and call back into haskell?
02:37:44 <waterlaz> and when is it ok?
02:40:38 <dolio> Yeah, I don't know what the rule is for threading.
02:41:09 <zygoloid> i think the FFI doc just says it's ok to use 'unsafe' if the C call can't trigger a GC
02:43:38 <kmc> ooh, that's tricky
02:44:03 <kmc> when a C-spawned thread makes an FFI call back to Haskell does it get trampolined back to one of the RTS's Haskell worker threads?
02:45:20 <Mathnerd314> @src Maybe join
02:45:21 <lambdabot> Source not found. That's something I cannot allow to happen.
02:47:04 <Mathnerd314> > join :: Maybe (Maybe a) -> Maybe a
02:47:05 <lambdabot>   {Nothing->Nothing;Just Nothing->Nothing;Just (Just ())->Just ()}
02:47:58 * Mathnerd314 wishes lambdabot was built into ghci
02:48:07 <kmc> http://hackage.haskell.org/package/goa
02:48:11 <ivanm> waterlaz: it's safe when it's referentially transparent
02:48:17 <kmc> but good luck getting it to work
02:48:27 <ivanm> kmc: aparently it works again
02:48:27 <kmc> ivanm, that's not what FFI's "unsafe" qualifier means
02:48:38 <kmc> @src join
02:48:38 <lambdabot> join x =  x >>= id
02:48:39 <ivanm> :o
02:48:58 <ivanm> I thought you were only meant to use unsafePerformIO if the IO action is referentially transparent...
02:49:10 <kmc> that is not the "unsafe" in question, i believe
02:49:26 <kmc> thought we were discussing "foreign import" versus "foreign import unsafe"
02:49:29 <dolio> It's the unsafe in "foreign import/export unsafe ..."
02:49:48 <ivanm> oh
02:49:50 <ivanm> sorry
02:49:57 <waterlaz> yes, "foreign import" versus "foreign import unsafe"
02:49:57 <ivanm> I thought he meant unsafe* functions
02:50:14 <ivanm> hmmm.... is there any inbuilt way of performing equality on the _constructors_?
02:50:15 <kmc> unsafe* are a grab bag anyway
02:50:22 <kmc> unsafeCoerce is a lot less safe than unsafePerformIO
02:50:33 <ivanm> i.e. rather than doing eqConst Foo{} Foo{} = True; eqConst Bar{} Bar{} = True; eqConst _ _ = False
02:50:37 <kmc> ivanm, Data.Data can do that
02:50:39 <ivanm> kmc: true
02:50:59 <ivanm> is that part of syb?
02:51:12 <kmc> sort of?
02:51:16 <kmc> it's in the "base" package in 6.10
02:51:30 <kmc> yes it comes from the syb papers
02:51:34 <ivanm> how about 6.8?
02:51:37 <kmc> dunno
02:51:44 <kmc> > dataTypeOf (Just 3 :: Maybe Int)
02:51:45 <lambdabot>   DataType {tycon = "Prelude.Maybe", datarep = AlgRep [Nothing,Just]}
02:52:18 <ivanm> also, I just need it for one small function I'd otherwise define in a where clause for a datatype with 3 constructors; is using Data.Data likely to be more of a pain thatn it's worth?
02:52:25 <kmc> yeah
02:52:37 <kmc> at least it will be less clear
02:52:39 <ivanm> OK, I"ll just define all 4 cases by hand then
02:52:39 <kmc> and slower
02:52:59 <ivanm> well, could be (==) `on` (tycon . dataTypeOf) ...
02:53:03 <ivanm> @type tycon
02:53:04 <lambdabot> Not in scope: `tycon'
02:53:04 <kmc> > toConstr (Just 3 :: Maybe Int)
02:53:05 <lambdabot>   Just
02:53:15 <kmc> :t (==) `on` toConstr
02:53:16 <lambdabot> forall a. (Data a) => a -> a -> Bool
02:53:19 <kmc> that's the one
02:53:28 <ivanm> you can perform equality on constructors? :o
02:53:38 <kmc> you can perform equality on Constr
02:53:43 <ivanm> > (==) `on` toConstr (Just 3) (Just 5)
02:53:43 <kmc> Data.Data.Constr
02:53:44 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe t -> a -> b'
02:53:44 <lambdabot>         against...
02:53:58 <ivanm> > ((==) `on` toConstr) (Just 3) (Just 5)
02:53:59 <lambdabot>   True
02:54:03 <ivanm> oooohhhh....
02:54:08 <ivanm> pretty...
02:54:09 <kmc> > let (===) = (==) `on` toConstr in (Just 3 === Just 5, Just 3 === Nothing)
02:54:10 <lambdabot>   (True,False)
02:54:17 <kmc> yeah, that's less trouble than i expected
02:54:44 <kmc> > constrRep $ toConstr (Just 3 :: Maybe Int)
02:54:45 <lambdabot>   AlgConstr 2
02:54:49 <ivanm> bugger, it's not with 6.8
02:54:55 <Mathnerd314> what's the opposite of cabal install?
02:54:59 <ivanm> and I'm trying to keep compatability (just in case)
02:55:02 <ivanm> Mathnerd314: huh?
02:55:08 <ivanm> do you want to uninstall stuff?
02:55:11 <kmc> ivanm, can you require some syb package?
02:55:14 <ivanm> if so, there's no automatic uninstaller
02:55:19 <Mathnerd314> ok.
02:55:19 <ivanm> kmc: yeah, but that gets messier
02:55:33 <ivanm> kmc: and I'm only using this for the optional test suite; if it was compulsory I'd do it, but it's not
02:55:48 <ivanm> bah
02:55:55 <ivanm> I mean "if I used it more often I'd do it"
02:56:11 <ivanm> since I'm only using it to remove some of the junk that QC produces
02:57:11 <quicksilver> kmc: well, unsafePerformIO can be used to build unsafeCoerce, but unsafeCoerce cannot be used to build unsafePerformIO as far a I know.
02:57:23 <quicksilver> kmc: so I'd argue that unsafePerformIO must be less safe.
02:57:38 <dolio> It can if you have runST.
02:57:39 <kmc> i'm sure that unsafeCoerce can be used to load arbitrary code into memory and execute it
02:58:26 <quicksilver> dolio: ah, that's true, but that's an implementation detail that it happens to work.
02:58:40 <quicksilver> dolio: whereas the other way round is "more natural". If any of this stuff is natural.
02:58:43 <ivanm> kmc: so unsafeCoerce can be used to define eval in Haskell? :p
02:58:52 <kmc> almost any use of unsafeCoerce is an implementation detail
02:59:32 <dcoutts> I used unsafeCoerce and demons flew out of my nose!
02:59:42 <dolio> Any of the evil ones, at least.
03:00:04 <kmc> in some sense they all are, because it's not in the Report and can't be built out of things that are
03:00:22 <kmc> but the GHC docs certify a few uses as safe
03:00:23 <dolio> Sometimes you can use unsafeCoerce to transport between two types you know are the same via other factors.
03:00:51 <kmc> even then you have to be careful
03:00:53 <dolio> But, yeah, accessing the bit-wise representation of Double by casting to an Int is an implementation detail.
03:01:20 <kmc> hmm, what happens in that case if the int gets strictanalyzed and unboxed?
03:01:23 <kmc> nothing good no doubt
03:01:45 <kmc> i suppose unsafeCoerce is opaque enough to the optimizer that it won't happen
03:01:50 <kmc> even though it's a no-op ;)
03:02:09 <dolio> I don't really understand what you're asking.
03:02:22 <kmc> might be that it doesn't make sense
03:02:52 <kmc> yeah, because unsafeCoerce is polymorphic so it will always box the argument
03:02:55 <kmc> never mind
03:05:36 <ivanm> dcoutts: did you happen to take a photo to record that moment for posterity as a warning sign to future young Haskellers on the dangers of dabbling in the "dark side" of Haskell?
03:11:17 <Mathnerd314> ack, why does lambdabot *require* unlambda which requires unix?
03:11:35 <ivanm> because that's how it was written
03:12:01 <Mathnerd314> I thought it had a plugin system
03:12:15 <ivanm> yes; no-one said they were _optional_ plugins though
03:12:47 <kmc> "it"? how offensive
03:12:51 <kmc> she's a real person with a real name
03:12:53 <kmc> @vixen what is your name?
03:12:54 <lambdabot> My name is Emily
03:13:03 <Mathnerd314> oh, sorry.
03:13:12 <kmc> @vixen do you require unix?
03:13:13 <lambdabot> maybe. do you?
03:13:59 <Mathnerd314> I thought the whole point of plugins was that they could be removed, though...
03:14:20 <ivanm> Mathnerd314: who said?
03:14:24 <kmc> sometimes "plugin" just means the code is structured in some modular way
03:14:31 <kmc> and you still need to recompile to change what's in
03:14:35 <kmc> however it should be a simple change
03:15:10 <ivanm> they're _IRC_ plugins
03:15:11 <ivanm> so you don't have to use them within IRC
03:15:11 <ivanm> lambdabot's plugins are basically links to other programs
03:20:35 <misk20> how can i define sum of elements of tree like this "data Tree a = Leaf a | Branch [Tree a]", one approach seems to be traverse the tree and find the array of leafs and sum them is there any other way
03:21:10 <kmc> you can write a simple recursive function to do it
03:21:23 <dolio> Why would you compute an array and then sum the array?
03:21:23 <kmc> or you can write a more general "fold" function for your tree, and pass (+)
03:21:28 <dolio> Just compute the sum.
03:21:32 <kmc> err i think by array misk20 probably means list
03:21:37 <kmc> (they are very different in Haskell)
03:21:43 <kmc> (and lists are the simple one)
03:21:53 <dolio> That doesn't really affect my question.
03:22:24 <misk20> so how do i do that?
03:22:45 <kmc> misk20, this should get you started: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24517#a24517
03:24:34 <misk20> well what i have done is like this http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24517#a24518
03:24:54 <kmc> yeah
03:25:08 <kmc> that's less direct
03:25:18 <misk20> so is there any better solution to this ?
03:25:28 <kmc> but the "tree flattening" function (which you named ttMap, i'm not sure why) could be useful on its own
03:25:37 <kmc> misk20, well, did you look at what i provided as a template
03:25:44 <kmc> do you see how you could fill in the RHS of those two equations?
03:25:49 <kmc> it's not too different from your ttMap
03:25:59 <ivanm> kmc: of course, whenever you fold over a tree you have to think about which traversal order you're going to do...
03:26:02 <zygoloid> dolio: because it decomposes the problem into two smaller, simpler parts
03:26:20 <dolio> It does?
03:26:33 <zygoloid> plus those two parts are then independently reusable
03:27:20 <dolio> That isn't a very good decomposition.
03:27:36 <dolio> Writing the fold for the tree is a better one.
03:27:58 <zygoloid> yes, i agree. but it's still better than no decomposition and explicitly writing the recursion every time.
03:28:45 <ivanm> writing different newtype wrappers with different instances of Foldable is a better one still!
03:29:19 <dolio> No it isn't. :)
03:29:20 <misk20> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24517#a24519  - is this good, but its the same thing right
03:29:30 <kmc> misk20, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24517#a24520 here's the structure of the general fold, to get you started
03:29:36 <kmc> at least of one possible fold you might want
03:29:39 <zygoloid> dolio: even given a fold i'd still be tempted to write a toList in terms of it and compose that with 'sum' :)
03:29:54 <kmc> misk20, sumTree should call itself, and not call ttMap
03:29:58 <ivanm> dolio: so, what traversal order should a fold over a tree use then?
03:30:21 <ivanm> unless you write a _really_ generic fold function that includes the "how to traverse" stuff in it
03:30:31 <kmc> gfoldl!
03:30:33 <dolio> ivanm: The fold shouldn't choose a traversal order.
03:30:35 <kmc> :t gfoldl
03:30:36 <lambdabot> forall (c :: * -> *) a. (Data a) => (forall d b. (Data d) => c (d -> b) -> d -> c b) -> (forall g. g -> c g) -> a -> c a
03:30:42 <kmc> that's a mouthful
03:30:54 <dolio> It should have a signature that is different from foldr. That's the weakness of the Foldable class.
03:31:01 <ivanm> dolio: if you try to write a toList function using a fold, how do you know which order the elements will come out in?
03:31:32 <dolio> fold :: ([r] -> r) -> (a -> r) -> Tree a -> r
03:31:50 <dolio> You will know based on what functions you provide it with.
03:32:11 <ivanm> right, you write a very generic one
03:33:15 <ivanm> gah! why does my testing stuff suddenly end up chewing up so much RAM just because I've started testing my HTML-like label support?!?!?!?! :s
03:33:38 <zygoloid> it's harder to implement 'find the deepest element' with that than it is with a more traditional ordered fold, though...
03:33:56 <ivanm> zygoloid: what ordering?
03:34:08 <ivanm> _that_ is my point
03:34:23 <ivanm> do you write a fold that has some arbitrarily chosen traversal order?
03:34:24 <zygoloid> ivanm: the order implied by the constructors.
03:34:44 <dolio> I don't know how you'd find the deepest element with a fold like foldr from Foldable period.
03:35:00 <ivanm> dolio: especially since you don't know what traversal it's doing
03:35:07 <dolio> You might be able to do with with foldMap, but only by abusing it with a Monoid instance that isn't really a monoid.
03:36:47 <dolio> Actually, that probably wouldn't cut it, either.
03:36:48 <zygoloid> the trick is to use a function type for 'r'
03:37:09 <zygoloid> but you're right, you need a very strange fold to make that easy
03:37:45 <zygoloid> (something like a foldM perhaps)
03:38:01 <dolio> How do you tell how deep an element is if you only have an in-order list of the elements of the tree?
03:39:36 <dolio> I'm pretty sure you need something like the signature I provided, because it keeps the nesting structure around.
03:39:41 <zygoloid> "foldTreeM :: Monad m => ([m r] -> m r) -> (a -> m r) -> Tree a -> m r" can do it pretty easily
03:40:14 <dolio> Well, that can, yes. It has the [] there.
03:40:17 <zygoloid> i take back what i said before, by the way -- the foldr-style thing is useless for this sort of operation
03:40:31 <dolio> foldr from Foldable has the signature (a -> r -> r) -> r -> f a -> r
03:41:06 <ksf> back to the language shootout: my current code is approx. two times slower than the current c entry, which is more or less as fast as those ats/c/c++ programs that don't do elaborate table magic
03:41:25 * zygoloid feels suitably cluebatted
03:41:28 <ksf> (I'm still surprised that the shootout guys let that lookup scheme pass)
03:41:46 <Mathnerd314> hmmm... what is the maybe comonad?
03:42:01 <dolio> Maybe isn't a comonad.
03:42:09 <ksf> and while I _can_ replicate that lookup scheme, I just don't want to, because my current one is so haskellish.
03:42:28 <theorbtwo> Can you give two methods to shootout?
03:42:41 <ksf> certainly.
03:43:04 <ksf> ...I can't ,though, I tried to create an alioth account multiple times, each time failing.
03:43:23 <Mathnerd314> dolio: some random page I read claimed every monad has a corresponding comonad
03:43:54 <zygoloid> Mathnerd314: if that's true, it's not the /same/ structure which is comonadic
03:43:56 <dolio> Well, that's true in a technical sense, but not the obvious way.
03:44:25 <dolio> Every monad is given by an (possibly many) adjunction, and every adjunction gives rise to both a monad and a comonad.
03:44:33 <kmc> is it actually true in Haskell, or just true in category theory?
03:44:36 <misk20> kmc, something like http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24517#a24521, but it doesn't compile
03:44:44 <dolio> But the functor for the monad and the functor for the comonad are typically different.
03:44:57 <kmc> misk20, you're close
03:45:09 <kmc> misk20, what's the type of (foldTree lf bf) in your last line?
03:45:17 <zygoloid> kmc: in haskell all monads are Hask -> (subcategory of Hask). the corresponding comonads will presumably be (subcategory of Hask) -> Hask
03:45:18 <kmc> and what's the type of xs?
03:45:33 <misk20> Tree
03:45:34 <ksf> in case someone wants to hack on the more haskellish solution:    http://gist.github.com/348998
03:45:47 <ksf> (I'm going to copy the c version)
03:46:15 <kmc> misk20, for which?
03:46:35 <dolio> Mathnerd314: For instance, the functor (= -> r) is self-adjoint. In one direction it goes C -> C^op, and in the other it goes C^op -> C.
03:46:43 <misk20> kmc, xs ?
03:46:49 <kmc> xs :: [Tree a]
03:46:57 <kmc> but you shouldn't take apart the list of children
03:46:59 <kmc> just map over it
03:47:14 <misk20> ok
03:47:19 <kmc> to get [b]
03:47:26 <dolio> Mathnerd314: That gives rise to the continuation monad (= -> r) -> r in C. It also gives rise to a comonad in C^op, but when you get rid of the op, the comonad is actually the continuation monad in C.
03:47:54 <kmc> your recursive call to foldTree fails to check because xs is a list of trees and not a single tree
03:47:56 <dolio> Since a monad in C is a comonad in C^op.
03:48:10 <kmc> your call to lf fails to check because you give two arguments and lf is not (in general) a 2-arg function
03:48:21 <kmc> (it might happen to be, depending on the user's whim)
03:49:05 <dolio> Mathnerd314: Another example is that (s, =) is adjoint to (s -> =). This gives rise to the state monad s -> (s, =) and the context comonad (s, s -> =).
03:49:34 <sori> I'm trying to compile a code, which uses an "approximation equality" operator         =~       seemingly on two Double values; but my GHC tells me that it doesn't know this operator. Is this operator known to anyone?
03:50:10 <zygoloid> > "hello" =~ ".*ll.*" :: Bool
03:50:11 <lambdabot>   True
03:50:26 <zygoloid> sori: it's a common operator in regular expression libraries for pattern matching
03:50:37 <sori> I see,,
03:51:24 <kmc> @hoogle (=~)
03:51:24 <lambdabot> Text.Regex.Posix.Wrap (=~) :: (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target) => source1 -> source -> target
03:51:24 <lambdabot> Text.Regex.Posix.Wrap (=~~) :: (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target, Monad m) => source1 -> source -> m target
03:51:32 <sori> zygoloid, could it be used to two Double values?
03:51:38 <kmc> sori, it's probably defined somewhere in your code
03:52:22 <sori> yeah,,, I got it from a SVN, so it should just compile.. But unfortunately it doesnt because of that error :'(
03:52:35 <kmc> what does it import?
03:53:16 <sori> Well, I think that the only relevant import may be Numeric.LinearAlgebra
03:53:29 <kmc> @hoogle LinearAlgebra
03:53:29 <lambdabot> No results found
03:53:32 <ksf> Cost centres not (yet) handled by Template Haskell
03:53:34 <ksf> wtf?
03:53:40 <ksf> 6.10 could do that
03:53:51 <kmc> maybe the doc is a lie
03:53:53 <kmc> wouldn't be the first time
03:54:10 <sori> well, Numeric.LinearAlgebra is from the hmatrix package..
03:54:39 <sori> Hm but it's really an operator on Double.. strange..
03:54:41 <dolio> Mathnerd314: I wouldn't expect going going from a monad to and adjunction to a comonad (as you'd have to do with Maybe, because I don't know what adjunction to use) to get you a very nice comonad, though.
03:55:20 <Younder> sori, does it use LAPACK ?
03:55:45 <sori> Yes sir
03:56:07 <Younder> sori, excellent
03:56:08 <sori> I mean,, I suppose so, because the package hmatrix uses LAPACK, right?
03:56:15 <dolio> Mathnerd314: Because what is typically done is to construct an adjunction with a category that's sort of constructed by the monad (either the Eilenberg-Moore category, or the Kleisli category).
03:57:13 <dolio> So, for instance, if you used that on the state monad, you wouldn't get the (s, =) -| (s -> =) adjunction.
03:58:10 <Younder> That means it is fully scalable. Multible processors and  gpGPu's. From a meesly 30 GFlops to a maiive 50 TFlops
03:58:25 <Younder> massive
04:02:46 <misk20> kmc, could you please help i could not make it working
04:03:58 <kmc> misk20, what did you try?
04:04:06 <kmc> misk20, are you getting type errors; if so, do you understand what they mean?
04:04:53 <misk20> ya i understand why it didn't work, may be because of nesting of tree
04:05:11 <kmc> are you trying to write the "Branch" case of the fold?
04:05:37 <misk20> ya i tried using map
04:05:52 <kmc> xs :: [Tree a]
04:06:07 <kmc> (let's assume you're matching only xs and not (x:xs)... we don't need to treat the first element specially)
04:06:17 <kmc> how do we convert that [Tree a] to [b] ?
04:06:53 <misk20> apply function to a ?
04:07:13 <kmc> what function, and what do you apply it to?
04:08:38 <fasta> misk20, just replace constructors with functions (which are the argument to the fold) and you have a fold.
04:09:17 <kmc> misk20, what's the type of (foldTree lf bf) ?
04:09:22 <misk20> kmc, bf ? not sure
04:09:36 <kmc> misk20, i don't understand
04:09:42 <kmc> you don't know what the type of bf is?
04:10:08 <ivanm> what's the PRAGMA to give a unique name/label to a CAF?
04:11:43 <misk20> ahh, i am confused  , isn't it similar to foldl/foldr
04:12:07 <kmc> misk20, the foldTree you are writing is like foldr
04:12:11 <kmc> but for your Tree type instead of for lists
04:12:21 <arcatan> ivanm, if you mean in profiling context, {-# SCC "blarg" #-} expr
04:12:22 <misk20> ya
04:12:40 <kmc> so what's the type of (foldTree lf bf) within the context of the last line?
04:12:44 <fasta> misk20, think of what happens when you do foldr (:)
04:12:52 <kmc> the one that starts: "foldTree lf bf (Branch xs) = ..."
04:13:13 <fasta> misk20, it's replacing the list constructor with the list constructur function, giving the exact same result.
04:13:25 <misk20> so, like this, "lf (foldTree lf bf xs)"
04:13:35 <fasta> misk20, for trees, you replace the Branch with a branch function.
04:13:44 <kmc> misk20, i'm just asking the type of (foldTree lf bf)
04:13:47 <kmc> what you have written there does not typecheck
04:13:51 <kmc> but the subexpression (foldTree lf bf) does
04:13:54 <kmc> what is its type?
04:14:31 <kmc> misk20, do you understand how we can "partially apply" a function like this?
04:14:40 <kmc> that is, provide only two arguments when it's defined in terms of three?
04:19:13 <Younder> You have to first understand lazy evaluation.
04:19:28 <kmc> Younder, for misk20's question?
04:19:31 <kmc> not at all
04:20:01 <kmc> the same code would work in a strict language
04:20:26 <Younder> kmc: no
04:21:06 <Younder> kmc: to your answer
04:21:35 * kmc is confused
04:22:08 <Younder> misk20, do you understand how we can "partially apply" a function like this?
04:22:09 <ivanm> arcatan: ta
04:22:42 <Younder> The curry requires a bit of explanation.
04:24:40 <Younder> The above misk20 was supposed to be a quote
04:25:54 <kmc> i'm still not sure where laziness comes into it
04:25:57 <ivanm> arcatan: before or after the definition?
04:26:31 <arcatan> ivanm: before methinks
04:29:35 <Younder> kmc. ok were in a tree. Left or right?
04:29:57 <kmc> what?
04:32:23 <ivanm> hmmm..... it's complaining about incorrect indentation...
04:33:55 <ivanm> oh, _right_ before...
04:35:19 <ksf> given a function foo :: (a -> b) -> bar -> baz, how do I make sure that (a->b) is inlined into foo?
04:36:08 <kmc> ksf, not all calls to foo even make that possible
04:36:25 <ksf> well, all that are in my programs are possible
04:36:47 <Taejo> ksf: the inlining goes the other way -- if you have "quux = foo f" then you want foo and f inlined into quux
04:36:59 <Younder> You would have to clompletely infer the types. Which given it's general anture is not possible.
04:37:15 <Younder> nature
04:37:19 <ksf> ...but if I do {-# INLINE foo #-} ghc won't ever inline f, according to the docs.
04:37:50 <Younder> It's a compiler hint
04:38:30 <Younder> ksf: be more spesific
04:38:34 <ksf> I'd hate to have to use TH to get the behaviour I want
04:38:48 <ksf> ...especially because TH fucks up SCCs and everything so I can't properly profile.
04:39:22 <kmc> would you hate to use CPP to get the behavior you want?
04:39:24 * kmc ducks
04:39:40 <ksf> Younder,  http://gist.github.com/348998
04:39:43 <Younder> ksf: tough. When you are spesifying inline you are already going beyond behaviour and addressing execution time
04:40:07 <ksf> ...in my current code I de-TH'ed the body of printSeq so I get SCCs
04:40:17 <kmc> unless you are breaking referential transparency
04:40:18 <ksf> it's not _that_ much slower without TH, but it's slower.
04:40:59 * hackagebot sox 0.2 - Play, write, read, convert audio signals using Sox  http://hackage.haskell.org/package/sox-0.2 (HenningThielemann)
04:41:10 <ksf> strangely enough, unbuffered IO seems to make the program slower.
04:41:37 <flux> isn't performance why buffering is done in the first place?
04:41:57 <ksf> printSeq comes with its own buffer
04:42:02 <Younder> ksf, what's supprising about that?
04:42:04 <ksf> it's not calling putc() or anything
04:42:53 <ksf> also, the c version is using unbuffered io.
04:42:54 <Younder> ksf, putting text on the screen is a very expensive operation. Paralellising it it a great plus.
04:43:08 <ksf> not on my machine, it isn't.
04:43:18 <ksf> also, output is redirected
04:43:30 <Younder> ksf: you don't have a GPU?
04:43:35 <ksf> every additional thread just means yet another context switch
04:43:55 <ksf> I do, and it doesn't ever see any of that stuff that I pipe into a file.
04:44:04 <theorbtwo> Getting rid of output buffering will often make a program feel faster and run slower.
04:44:07 <ksf> I don't have a multicore.
04:44:08 <Younder> ksf: BS
04:44:27 <theorbtwo> That is, the time until completion will go up, but the time until first output will go down.
04:44:47 <ivanm> is it just me, or is the sample heap profile in the SCC section not there? http://www.haskell.org/ghc/docs/latest/html/users_guide/profiling.html
04:44:52 <Younder> Take a look at what you send to your graphics driver..
04:45:03 <ksf> heck I don't care about buffering, it's one of those variables that just have to be tried out.
04:45:18 <ksf> I'm wondering how to properly inline each lookupNuc into printSeq
04:45:39 <ksf> ...as the result of lookupNuc is called every bleeding iteration.
04:45:49 <arcatan> ivanm: doesn't work for me either
04:46:30 <ksf> Younder, you can tell me a lot of things, but not that sending output to a file sends said output to the graphic driver.
04:47:06 <kmc> clearly you don't have the GPGPU patches for ext4
04:47:59 <ksf> I'd be surprised. not that I wouldn't believe that gpgpu /could/ be useful for ext4, but that they would support my ancient glsl card.
04:48:21 <kmc> i'd be surprised if gpgpu could be useful for filesystems
04:48:39 <kmc> doesn't seem like a use case for SIMD floating point
04:48:41 <kmc> but what evah
04:48:49 <ksf> deduping or something.
04:49:08 <ksf> not the whole thing, but I bet there's some specific algorithms where the parallelity is useful.
04:49:57 <koala_man> the hashing part
04:50:25 <ksf> you'd need the right hash for that, but yes.
04:50:34 <kmc> filesystem operations tend to be dominated by the device anyway
04:50:44 <kmc> maybe gpgpu could take some of the burden off encryption or RAID
04:50:55 <kmc> raid has the SIMD part at least
04:51:04 <ksf> I DON'T CARE
04:51:07 <ksf> I want to inline.
04:51:07 <kmc> snap
04:52:08 <ksf> I could give those two functions two different types and SPECIALIZE
04:52:10 <koala_man> why would you need the right hash?
04:52:38 <ksf> I don't think all of them are parallelizable.
04:52:46 <ksf> ...at least it's quite easy to think of one that isn't.
04:53:49 <koala_man> all hashes are parallelizable when you're doing multiple independent runs of each
04:54:10 <ksf> ...well, you can parallelize any by chunking the input and then hashing the individual chunk hashes
04:54:48 <ksf> but that won't give you the same hash as hashing as a whole, and depending on hash it could be less secure
04:54:59 <ksf> (don't listen to me for cryptographic advice)
04:55:05 <Younder> ksf: secure?
04:55:17 <koala_man> you wouldn't hash the entire fs as a whole when you're trying to find duplicated blocks or files
04:56:04 <ksf> no, but you'd want a sha1 hash of one file be the sha1 hash that any strictly sequential program would give.
04:56:20 <ksf> I'm just saying there are issues, not that it can't be done.
04:56:51 <ksf> Younder, collisions etc. pp. ask a hash specialist.
04:57:06 <koala_man> then you can do two files in parallel
04:57:20 <Younder> Does anyone know is the is group on lamba calulus?
04:57:43 <kmc> what?
04:57:52 <opqdonut> did that sentence miss a word or two?
04:58:15 <ksf> I think if that group calls itself the is group, then it's about is, not about lambda calculus.
04:58:49 <Younder> ksf: indeed, this is the closest I could come
04:59:11 <Younder> or lisp
04:59:25 <kmc> well, lambda calculus is a mathematical concept
04:59:28 <kmc> so you could go to #math
04:59:59 <Younder> Neverthess some of my questions have been of a mathematical nature.
05:00:09 <kmc> linguistically, LISP or Scheme is much closer than Haskell to the untyped lambda calculus
05:00:22 <kamatsu> Haskell  is closer to system F
05:00:22 <Younder> kmc: to general. You migt as well say computer science.
05:00:39 <kmc> yes, if there were a general CS discussion channel it would be a good place to ask about lambda calculus
05:00:49 <kamatsu> #compsci?
05:01:14 <kmc> this is probably a fine place to ask, for the same reason it's a fine place to ask about category theory -- not that it's particularly on-topic, but that a lot of the interested people hang out here and diversions are usually tolerated
05:01:41 <kamatsu> although untyped lambda calculus is a pretty simple concept
05:01:49 <kamatsu> which is part of what makes it so clever
05:01:58 <kmc> studying it is more about learning the tricks you can do
05:02:02 <kmc> like church encoding any data type
05:02:05 <kamatsu> yeah
05:02:13 <kmc> and writing fixedpoint combinators
05:02:46 <kamatsu> still, I learnt that stuff in about 2 weeks
05:02:48 <Younder> kmc: thanks for agreeing with my assesment
05:03:22 <kamatsu> and i could do it in less time more intensively
05:03:38 <Younder> kmc: (I also program Haskell)
05:03:53 <kmc> also, metatheory of lambda calculus is hard
05:04:07 <ivanm> yay! I think I've successfully managed to limit the amount of RAM being used by my testsuite!
05:04:09 <Younder> kmc: studying it now..
05:04:25 <kmc> mechanized metatheory at least
05:04:28 <kmc> i.e. representing terms in such a way that proving things in a system like Coq is easy and natural
05:04:41 <kmc> this is an active area of research
05:04:51 <Mathnerd314> dolio: is the "list comonad" here correct: http://logicaltypes.blogspot.com/2008/09/stream-of-primes-as-comonad.html
05:04:52 * ivanm realised that for the new data structures that were causing all of the problems, they would become extremely repetitive at larger sample sizes, and thus not really add much to the testing by letting them be larger
05:05:02 <Younder> kmc: more into Higher Order Logic (HOL)
05:05:19 <jlouis> kmc: In Coq you need PHOAS if you want Lambda Calculus stuff to be tolerable
05:05:25 <kmc> yeah
05:05:38 <Younder> I mostly use Isabelle
05:05:41 <jlouis> De-Bruijn is quirky, but works
05:05:41 <kmc> PHOAS is a good idea and also a fun word to say
05:05:48 <Younder> sometimes ACL
05:05:58 <Younder> ACL2'
05:06:12 <jlouis> Younder: Isabelle has its strengths as well
05:06:50 <ivanm> isabelle + haskabelle sounds quite cool
05:07:44 <kmc> i'd be interested in Hascoq
05:07:57 <kmc> i guess i should learn more Agda
05:08:01 <Younder> Im interested inhaskabelle
05:08:06 <Younder> :)
05:09:40 <weny> pls, how to create buffer for function "hGetBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int" ?
05:09:52 <ivanm> weny: huh?
05:09:55 <ivanm> what buffer?
05:10:38 <ivanm> Younder: you might be able to find a copy of Florian Haftmann's paper at PEPM'10 somewhere
05:10:51 <ivanm> he talked about how to use haskabelle + isabelle to do round-trip proofs
05:10:56 <ivanm> abstract is at http://www.program-transformation.org/PEPM10/AcceptedPapers
05:11:27 <weny> ivanm> "Ptr a" is pointer to some buffer
05:12:04 * ivanm has never done any pointer stuff with haskell
05:17:11 <ivanm> I'm looking through the suggestions on what should be done with calls to unsafePerformIO here: http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.2.0.0/System-IO-Unsafe.html
05:17:33 <ivanm> now, adding the NOINLINE pragma to my code is easy enough, but I'm confused by the other two points
05:18:11 <ivanm> the actual module that uses unsafePerformIO is http://hackage.haskell.org/packages/archive/graphviz/2999.8.0.0/doc/html/Data-GraphViz.html
05:18:26 <ivanm> does anyone here have any (relavent) suggestions on what to do?
05:20:32 <ksf> how do I get the word32 representation of a float?
05:20:40 <ksf> (without using unsafeCoerce)
05:20:51 <dolio> Mathnerd314: I expect not.
05:21:00 <ivanm> ksf: round? >_>
05:21:06 <ksf> @slap ivanm
05:21:06 * lambdabot beats up ivanm
05:21:08 <ivanm> @type round
05:21:09 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
05:21:19 <ivanm> ksf: oh, you mean the in-memory representation?
05:21:22 <ksf> yep.
05:21:28 <ivanm> that I have no idea about
05:21:34 <ivanm> CFloat or something?
05:21:34 <ksf> the one that's faster to compare.
05:21:56 <ksf> @hoogle Float -> Word32
05:21:57 <lambdabot> Prelude ceiling :: (RealFrac a, Integral b) => a -> b
05:21:57 <lambdabot> Prelude floor :: (RealFrac a, Integral b) => a -> b
05:21:57 <lambdabot> Prelude round :: (RealFrac a, Integral b) => a -> b
05:22:56 <dolio> Mathnerd314: Perhaps it is, but the fact that head [] is undefined is undesirable.
05:23:19 <ivanm> ksf: I think you want to use the Foreign.* stuff for this
05:23:22 <ivanm> or maybe GHC.*
05:23:36 <Mathnerd314> dolio: I tried some examples, and it fails e.g. "extract . (extend sum) $ []"
05:23:59 <Mathnerd314> it gives an exception instead of 0
05:24:47 <dolio> Streams are different, because they always have a head.
05:24:57 <dolio> You could have non-empty lists, too.
05:25:10 <Mathnerd314> ok.
05:25:16 <ivanm> streams == infinite list?
05:25:23 <dolio> Yes.
05:27:16 * hackagebot Chart 0.13 - A library for generating 2D Charts and Plots  http://hackage.haskell.org/package/Chart-0.13 (TimDocker)
05:27:38 <Mathnerd314> dolio: is it true that return . extract == extract . return == id ?
05:27:49 <Mathnerd314> (for proper monad-comonad pairs)
05:28:55 <dolio> I'm not sure what is intended by monad-comonad pairs.
05:29:31 <Mathnerd314> if you have both a monad instance and a comonad instance that satisfy all the laws
05:29:44 <dolio> Probably not, then.
05:30:27 <dolio> (r ->) is both a monad and a comonad for monoids r, but return . extract is not id.
05:32:07 <dolio> return = const, extract f = f mempty
05:32:47 <dolio> So (return . extract) f = \_ -> f mempty
05:32:53 <dolio> Which is not necessarily f.
05:35:10 <lomeo> I thought comonad is (-> r) not (r ->)
05:36:34 <ksf> where does ltWord32# live? it's not in GHC.Base as ltWord# is
05:36:38 <sori> I'm defining the pointwise addition      (+) :: (Double,Double) -> (Double,Double) -> (Double,Double)       but GHC complains that (+) becomes then ambiguous (with the prelude function (+) :: Num a => a -> a -> a),,,, what would be a good solution to this situation?
05:36:56 <sori> Since (Double,Double) is not Num, I thought I could do this....
05:37:14 <samebchase> @pl
05:37:15 <lambdabot> (line 1, column 1):
05:37:15 <lambdabot> unexpected end of input
05:37:15 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
05:37:31 <samebchase> @pl x = 3
05:37:31 <lambdabot> x = 3
05:37:31 <sioraiocht> ksf: GHC.Exts, maybe?
05:37:53 <samebchase> @pl Int
05:37:53 <lambdabot> Int
05:53:28 <kmc> sori, no, the whole point of typeclasses is that to overload that operator you must use the class
05:53:47 <kmc> you can define an instance Num (Double, Double)
05:54:07 <kmc> or you can totally hide (+) from Prelude and define it yourself
05:54:19 <kmc> but usually the correct answer is just to use a different name
05:54:38 <sori> yeah,, what I actually tried to do is to define a class (which is extensionally a superclass of Num) consisting only of two operations (+) and (*)
05:55:00 <sori> and make (Double,Double) an instance of that class
05:55:22 <kmc> yeah... the numeric class hierarchy is sort of broken and should be redone from scratch at some point
05:56:09 <sori> Hm but what I don't understand of GHC is,, why it finds such a definition of (+) ambiguous..
05:56:27 <kmc> because the Prelude's is still in scope
05:56:29 <kmc> probably
05:56:40 <sori> because GHC knows that the type (Double,Double) is not an instance of Num right?
05:56:53 <kmc> the type directed resolution of names occurs *only* through the typeclass mechanism
05:57:01 <kmc> it won't resolve two unrelated clashing definitions by type
05:57:13 <sori> okay..:'(
05:57:43 <sori> anyway thanks!! I'll try to hide (+)..
05:57:48 <kmc> sec, i have an example
05:57:56 <sori> okay!!
06:00:15 <kmc> sori, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24523#a24523
06:00:33 <kmc> this uses some heavy language extensions in order to get all the existing Num instances into Ring "for free"
06:00:52 <kmc> if you're not comfortable with the implications of those extensions, best to declare the instances you need one by one
06:01:15 <ksf> htf can
06:01:17 <ksf> w32OfFloat :: Float -> Word32
06:01:17 <ksf> w32OfFloat = unsafeCoerce
06:01:26 <ksf> yield values outside of Word32's range?
06:01:58 <ksf> ah, wait, excess precision.
06:02:06 <sori> kmc, ah, thanks a lot, I think I like your solution
06:02:18 <kmc> :)
06:02:33 <ksf> though it's still strange as hell that the resulting values are out of range.
06:02:35 <kmc> OverlappingInstances is usually fine
06:02:46 <kmc> if you find a need to enable IncoherentInstances you might want to re-think your design ;)
06:02:58 <ksf> showing a Word32 should never, ever yield something like "140214562639943"
06:03:46 <kmc> sori, why do you need to overload (+) instead of defining a new operator?
06:03:49 <kmc> that seems like the simpler solution
06:04:25 <sori> uhm,, you mean why I do not use another identifier for that operator?
06:04:31 <kmc> yes
06:04:38 <kmc> one that's not already taken
06:04:41 <samphippen> does haskell have a built in permutations of a list function?
06:04:46 <burp> yes
06:04:50 <burp> Data.List
06:04:57 <dolio> > maxBound :: Word32
06:04:58 <lambdabot>   4294967295
06:05:03 <sori> just because I think it's natural to use the identifier (+) for the pointwise addition for a tuple.. :'(
06:05:08 <burp> > permutations [1..10]
06:05:09 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10],[2,1,3,4,5,6,7,8,9,10],[3,2,1,4,5,6,7,8,9,10],[2,3,...
06:05:16 <kmc> generally redefining stuff from the Prelude leads to confusing code
06:05:30 <kmc> especially when you change the type in a subtle way
06:05:36 <b0fh_ua> Hi there! If I have module called SomePrefix.Main - how do I compile and link it into an executable one? ghc --make -o myapp SomePrefix.Main complains that no Main module found
06:05:47 <sori> but in fact I'm not making anything ambiguous right? ..
06:06:00 <EvanR> kmc: its ok to import Prelude hiding, though, right?
06:06:00 <SamB_XP> kmc: I thought reimplementing stuff from Prelude was like half of what beginners did in Haskell!
06:06:02 <sori> because the prelude (+) is not defined for my types (typles)...
06:06:03 <kmc> natural syntax is good, but i think having understandable programs is more important than saving a character here and there
06:06:15 <kmc> sori, the prelude (+) is not in scope there at all
06:06:21 <kmc> except qualified as (Prelude.+)
06:06:46 <SamB_XP> > 1 Prelude.+ 2
06:06:47 <lambdabot>   3
06:06:49 <dolio> ksf: Try showing this: "unsafeCoerce (maxBound :: Word64) :: Word32"
06:06:50 <kmc> if you had this code and you (or anyone else) made an instance Num (Double, Double), then there would be much confusion
06:06:57 <dolio> ksf: I get "-1".
06:07:15 <SamB_XP> dolio: I think that's fairly normal
06:07:29 <dolio> Words are unsigned.
06:07:33 <dolio> That's normal?
06:07:39 <SamB_XP> dolio: oh, true
06:07:49 <SamB_XP> dolio: you must be on 64bit
06:07:51 <Eelis> even dumb languages like C++ make it easy to overload + to do elementwise addition on tuples. it's really embarrassing that it's not possible in Haskell without hiding the prelude or something. ugh, i hate Num
06:07:57 <kmc> hahahaha
06:08:12 <kmc> but yes Num sucks
06:08:23 <kmc> b0fh_ua, -main-is
06:08:31 <SamB_XP> dolio: see, Word32 was assuming that the high 32-bits of the field had been masked off
06:08:48 <kmc> i don't like C++'s approach to overloading in general though
06:08:50 <dolio> So it shows it like an Int?
06:09:00 <EvanR> is it possible to build a mechanical graph reduction based implementation
06:09:14 <kmc> yes
06:09:16 <mreh> with brass cogs?
06:09:17 <b0fh_ua> kmc: let me try
06:09:19 <kmc> it's terrible that they let you overload operators but not define new ones
06:09:19 <SamB_XP> dolio: evidently
06:09:30 <SamB_XP> dolio: it wouldn't much matter normally ;-)
06:09:36 <sori> kmc: uh... i'm sorry i'm really haskell beginner, but I don't see your statement that the prelude (+) is not in scope there..
06:09:37 <dolio> That is true.
06:09:45 <kmc> sori, i hide it
06:09:49 <EvanR> mreh: i guess. after doing software and electronics for so long, i find mechanical stuff incomprehensible
06:09:49 <kmc> import Prelude hiding ((+), (*))
06:09:51 <kmc> so it's not in scope
06:09:55 <sori> kmc: ah yes, in your code, yes.
06:09:57 <kmc> except qualified as (Prelude.+)
06:10:08 <sori> ahh, that's what you meant. okay..
06:10:09 <sori> :)
06:10:22 <SamB_XP> EvanR: hmmmm?
06:10:29 <kmc> sori, overloading in Haskell has to be accomplished through typeclasses.  you can't just define the same name twice with different types and expect it to resolve the ambiguity
06:10:34 <Eelis> kmc: Haskell's overload mechanism is fine, it's just the Num hierarchy that sucks so bad. in Clean they have a type class dedicated specifically to +, so that you only have to provide an instance for that class to get + on a type.
06:10:41 <kmc> yeah
06:10:43 <EvanR> a machine to run some kind of lambda calculus
06:10:47 <EvanR> with lazy evaluation
06:11:01 <SamB_XP> EvanR: oh, you want to build a reduction engine ?
06:11:02 <kmc> EvanR, a semiconductor computer and a human are two examples of a machine that runs lambda calculus
06:11:12 <sori> kmc: okay..
06:11:19 <EvanR> yes, now lets make it not biological, and not electronics
06:11:32 <sori> kmc: I'll take it in my mind. thanks :)
06:11:33 <kmc> how about microfluidics
06:11:38 <b0fh_ua> kmc: seems to work, thanks!
06:11:39 <EvanR> sounds good to me
06:11:46 <SamB_XP> EvanR: you could try building it with von neuman machines
06:12:00 <EvanR> is there no more straightforward way
06:12:09 <kmc> probably is
06:12:20 <EvanR> it would be pretty awesome
06:12:27 <kmc> do it
06:12:33 <EvanR> trying :(
06:12:39 <kmc> EvanR, you saw http://woodgears.ca/marbleadd/index.html ?
06:13:07 <EvanR> haha. this looks cool
06:13:07 <kmc> and http://www.blikstein.com/paulo/projects/project_water.html ?
06:13:49 <EvanR> what about parallel. do you HAVE to evaluate the graph one by one?
06:13:54 <b0fh_ua> in main, if I want to write some data into a file to be used later by another code - how do I force the file be actually written (and created, if neccessary)? Usin seq ?
06:13:58 <EvanR> or is a machine free to parallel evaluate stuff
06:14:15 <kmc> EvanR, for Haskell any evaluation order consistent with non-strict semantics is okay
06:14:19 <kmc> meaning, lazy evaluation is not required
06:14:31 <kmc> you can do speculative evaluation
06:14:45 <kmc> as long as you have a way to avoid diverging on some terms that would diverge in strict semantics
06:14:55 <EvanR> that sounds tricky
06:15:05 <kmc> the "par" combinator for example is used to annotate speculative parallel execution in GHC Haskell
06:15:22 <kmc> b0fh_ua, eek, seq is about evaluation, not execution
06:15:45 <b0fh_ua> kmc: I mean force writeFile to do actual writing
06:15:51 <kmc> why doesn't it?
06:16:13 <kmc> it just opens a file and calls hPutStr
06:16:25 <samphippen> what's the easiest way to repeat a list ad infinitum (ie inf [2,3] = [2,3,2,3......])
06:16:30 <kmc> > cycle [2,3]
06:16:31 <lambdabot>   [2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,...
06:16:41 <b0fh_ua> kmc: I'm getting "no such file or directory"
06:16:42 <etpace> @src cycle
06:16:42 <lambdabot> cycle [] = undefined
06:16:42 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
06:17:04 <kmc> oh come on, cycle [] should be an infinite nonproductive loop not an error ;P
06:17:09 <etpace> :t fix
06:17:10 <lambdabot> forall a. (a -> a) -> a
06:17:24 <kmc> > fix (2:3:)
06:17:25 <lambdabot>   The operator `:' [infixr 5] of a section
06:17:25 <lambdabot>      must have lower precedence th...
06:17:35 <kmc> > fix ((2:) . (3:))
06:17:36 <lambdabot>   [2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,...
06:17:40 <EvanR> kmc: wonder if binary is the best for mechanical arithmetic
06:18:03 <Jonno_FTW> @src fix
06:18:03 <lambdabot> fix f = let x = f x in x
06:20:35 <kmc> b0fh_ua, this should not be a matter of lazy evaluation unless there is a library bug or you are doing something seriously unorthodox
06:20:43 <kmc> i think writeFile is supposed to create
06:20:57 <etpace> > fix ([2,3] ++)
06:20:58 <lambdabot>   [2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,...
06:21:02 <kmc> probably your writeFile action is not getting executed
06:21:45 <kmc> the point of monadic IO is to decouple order of execution from order of evaluation
06:22:18 <kmc> bbl
06:26:23 <dsouza> hi everyone
06:28:31 <b0fh_ua> kmc: really. I missed the order of arguments and tried to create file named ""
06:28:37 <dsouza> I'd need a database (key/data works perfect) and I was considering using haskell bindings to berkeleydb database. Is there a /better/ alternative to use in Haskell?
06:28:46 <dsouza> here better is defined: simplicity is better :-)
06:28:49 <Jonno_FTW> "\"" ?
06:28:58 <zakwilson> Let's say I'm parsing a 350mb file with parsec. Is it inherent to parsec that it ends up taking several gigabytes of RAM, or is it more likely the fault of what I'm doing with the data afterward (putting it in a list of simple record structures)?
06:30:46 <theorbtwo> zakwilson: One thing I found out previously -- be careful with the "n times" combinator.
06:30:53 <theorbtwo> (Which I cannot remember the name of.)
06:31:06 <theorbtwo> It is foldl instead of foldl', or a similar problem.
06:31:13 <theorbtwo> You may well have to reimplement it.
06:31:14 <dsouza> berkeleydb would work just fine, but keeping the deadlock detection thread running is kind of boring
06:33:12 <dankna> dsouza:
06:33:22 <dankna> yes.  sqlite3 is better than berkelydb in every possible way. :)
06:33:27 <sori> kmc: just too bad that Num in Prelude is not just defined as a subclass of your Ring. . .
06:33:37 <dankna> and hey!  convenient!  there's about five bindings from Haskell to it, including my own direct-sqlite.
06:34:04 <dankna> berkelydb is more of a framework on top of which a database can be implemented than an actual database
06:34:37 <ksf> how in the seven hells can it be that fromIntegral of an Int32 or Word32 yields numbers that fit in 47 bits.
06:34:50 <arw_> what exactly does runProcess from System.Process do? is it equivalent to exec or exec after fork?
06:35:01 <dankna> it sounds like you only need one table, so you may be tempted to think that you don't need a full relational database, but I'd encourage you to think ahead to when you will need more in the future :)
06:35:09 <arw_> or should i just use System.Posix.Process?
06:35:20 <Zao> ksf: Stealth lossless compression? Compresses any two bits into one.
06:35:36 <SamB_XP> Zao: RIGHT
06:35:48 <ksf> ...I'm just trying to interpret floats as ints to get faster compares.
06:35:53 <mreh> part of coursework is to learn Hadoop to do a MapReduce
06:35:54 <dsouza> dankna: thx, makes sense, although it is likely key/value would work in the future. but sqlite3 works just fine as well.
06:35:57 <ksf> but so far, the only thing I get is off results.
06:35:58 <mreh> I do that all the time now
06:36:01 <zakwilson> theorbtwo: Are you talking about many?
06:36:02 <Zao> Type punning makes kitty cry.
06:36:03 <dankna> dsouza: cool cool, you're welcome
06:36:29 <theorbtwo> No, many is "any number of".
06:36:31 <ksf> I think that particular trick should be included in -freally-unsafe-math or something.
06:36:31 <dsouza> dnolen: thx
06:36:35 <theorbtwo> Hold on a sec, let me find the docs.
06:36:36 <mreh> why learn a whole new Java framework? If I could get haskell working on Amazon AWS then I'd be flying
06:36:36 <ketil> zakwilson, I suspect Parsec uses String and must parse the whole file in order to determine if parsing fails or not.
06:37:12 <theorbtwo> ketil: It does use string, by defualt, but it is certianly possible for parsing to fail before it reaches EOF.
06:37:27 <zakwilson> Reading the whole file in to memory isn't a problem. That should take up about the size of the file in memory.
06:37:47 <zakwilson> It's getting to 10 times that before it starts swapping and I kill it.
06:38:16 <dankna> you're getting 3G loaded into memory before you start swapping?  I want your machine!
06:38:31 <ketil> zakwilson, check out the structure of String.
06:38:40 <dankna> String actually should take up several times the size of the file
06:38:41 <theorbtwo> Ah.  Count.
06:38:44 <dankna> because it's a linked list of characters
06:38:56 <ketil> theorbtwo, but it isn't possible to succeed.
06:39:00 <dankna> use Bytestring instead - isn't there a Parsec variant that uses it?
06:39:10 <ketil> If you just want a parser that fails, that can of course be achieved in constant memory.
06:39:16 <dankna> chortle
06:39:35 <zakwilson> I think there is... and I think I can probably use it without changing anything else.
06:39:44 <theorbtwo> ketil: Hm, you have a certian point.
06:39:49 <dankna> on a 64-bit machine a cons cell is 16 bytes plus the actual character object is an 8-byte pointer and a 1-byte object and 7 bytes of padding for alignment
06:39:49 <ketil> dankna, ISTR using bytestring to chop things up into tokens, and used parsec on those.
06:40:13 <dankna> ketil: yeah, that seems like a good idea too, but I thought there was one that operated on Bytestring directly
06:40:18 <dankna> though I haven't actually used it
06:40:41 <dankna> so that adds up to what, 24 bytes?  so you should be using 24 bytes for every 1-byte character in the input file
06:40:54 <dankna> yes, it's inefficient.  Haskell strings are meant to be short :(
06:40:55 <ketil> dankna, I think you can get away with 16 bytes per char - the data pointer needs to point into a table of chars, but that's a constant cost.  Ideally, at least.
06:41:02 <dankna> oh, good point ketil
06:41:12 <theorbtwo> It's possible now to use parsec directly on a bytestring, IIRC.
06:41:13 <ketil> But it's still...well, expensive.
06:41:24 <ketil> theorbtwo, attoparsec, maybe?
06:41:31 <theorbtwo> Ah, there it is -- http://hackage.haskell.org/packages/archive/parsec/3.1.0/doc/html/Text-Parsec-ByteString-Lazy.html
06:41:51 <theorbtwo> No, attoparsec, as far as I can see, was only neccessary for an older version of parsec.
06:42:10 <theorbtwo> Of course, it's entirely possible that I'm wrong.
06:42:21 <dankna> well, that reference certainly looks like you're right
06:42:24 <danderson> theorbtwo: see serpentine.com, attoparsec is still way, way faster than parsec, unless there have been fundamental changes in parsec
06:42:25 <dankna> don't be so modest =p
06:42:53 <danderson> and that's even against the CPS version of Parsec (is that the mainline now?)
06:43:47 <dankna> hmm, I wish he had benchmarked an LR parser against those
06:43:52 <ksf> > (unsafeCoerce (0.50094324::Float))::Int32
06:43:53 <ksf> 139828012269009
06:43:53 <lambdabot>   Not in scope: `unsafeCoerce'
06:44:05 <ksf> I don't get it.
06:44:08 <dankna> ksf: are you even sure that your int comparisons are faster?
06:44:17 <ksf> yes they are
06:44:23 <dankna> well, okay
06:44:25 <Zao> ksf: Maybe you need more unboxing and strictness?
06:44:25 <ketil> Here's a lazyMany combinator I ripped from someone else: http://malde.org/~ketil/biohaskell/biolib/Bio/Util/Parsex.hs
06:44:31 <dankna> I take it you've benched them on the hardware you plan to run on
06:44:35 <Zao> ksf: Maybe you're coercing the wrong thing or something.
06:44:58 <dankna> > lg ((unsafeCoerce (0.50094324::Float))::Int32)
06:44:59 <lambdabot>   Not in scope: `lg'Not in scope: `unsafeCoerce'
06:45:00 <ksf> > logBase 2 139828012269009
06:45:01 <lambdabot>   46.99064673858745
06:45:01 <MisterN> :t unsafeCoerce
06:45:01 <ketil> Useful for parsing many records without keeping it all in memory.  But may fail halfway through, after returning partial data.
06:45:02 <lambdabot> Not in scope: `unsafeCoerce'
06:45:13 <dankna> I thought we defined lg the other day, did we not save it or something?
06:45:13 <ksf> ...just explain how 47 bits fit into Int32
06:45:32 <MisterN> ksf: probably unsafeCoerce removes them?
06:45:40 <dankna> :t (unsafeCoerce (0.50094324::Float))::Int32
06:45:41 <lambdabot> Not in scope: `unsafeCoerce'
06:45:43 <ksf> it _adds_ bits.
06:46:07 <MisterN> ksf: hmm mabye Int32 is really Int64 on lambdabot?
06:46:12 <ksf> ...try it at home. ghc 6.12.1, amd64
06:46:17 <dankna> > (unsafeCoerce (139828012269009::Int32))::Float
06:46:18 <lambdabot>   Not in scope: `unsafeCoerce'
06:46:34 <ksf> I'm quite sure that its 32 bits everywhere.
06:46:36 <ksf> or should be.
06:46:46 <dankna> > lg ((unsafeCoerce (0.50094324::Float))::Word32)
06:46:47 <lambdabot>   Not in scope: `lg'Not in scope: `unsafeCoerce'
06:46:52 <dankna> > (unsafeCoerce (0.50094324::Float))::Word32
06:46:53 <lambdabot>   Not in scope: `unsafeCoerce'
06:46:55 <dankna> ><
06:47:08 <dankna> @hoogle unsafeCoerce
06:47:08 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
06:47:15 <dankna> > (Unsafe.Coerce.unsafeCoerce (0.50094324::Float))::Word32
06:47:16 <lambdabot>   Not in scope: `Unsafe.Coerce.unsafeCoerce'
06:47:18 <dankna> oh I get it
06:47:19 <ksf> I don't think cale will give us unsafeCltuthulu on lambdabot.
06:47:22 <dankna> you have higher privileges than me
06:47:24 <zakwilson> Text.Parsec.ByteString.Lazy doesn't seem to exist in the version of parsec that's cabal-installable. Am I missing something, or do I need to manually install a newer version?
06:47:32 <dankna> so you can call unsafeCoerce but I can't
06:47:41 <ksf> dankna, no I ran it on my box.
06:47:43 <dankna> zakwilson: did you cabal update?
06:47:46 <dankna> ksf: oh, okay
06:48:08 <dankna> ksf: ah yes, I see now.  somehow I thought that was lambdabot answering you.
06:48:14 <zakwilson> dankna: I did, just before I tried installing it.
06:48:21 <dankna> zakwilson: hmm.....
06:48:56 <dankna> well, I have a 32-bit ghc here, let me try it
06:49:16 <ksf> It's not even really predictable. 0.30295494 resolves to 1050352873 in my compiled program, in ghci it resolves to 139828005641449
06:49:28 <ksf> > 139828005641449 - 1050352873
06:49:29 <lambdabot>   139826955288576
06:49:43 <theorbtwo> Hm... Oh, I suppose if you unsafeCoerce into an IO x, and then try to execute...
06:50:09 <ksf> >139828012269009  -  139826955288576
06:50:21 <ksf> @bot
06:50:22 <lambdabot> :)
06:50:25 <ksf> > 139828012269009  -  139826955288576
06:50:26 <lambdabot>   1056980433
06:50:34 <ksf> that looks right.
06:50:34 <dankna> ksf: is one of those an unlifted type and the other lifted?
06:50:44 <ksf> they're both lifted
06:50:48 <dankna> drat
06:50:49 * theorbtwo should back up a step -- is unsafeCoerce unsafe in as much as it gives results that expose the internals, or in as much as it can make you execute arbitrary code?
06:50:55 <dankna> both
06:51:08 <ksf> > logBase 2 139826955288576
06:51:09 <dankna> the one implies the other, I think
06:51:09 <lambdabot>   46.990635833003026
06:51:37 <ksf> > showHex 139826955288576 ""
06:51:38 <lambdabot>   "7f2c00000000"
06:51:46 <ksf> now that's interesting.
06:51:58 <dankna> > showHex 1050352873 ""
06:51:59 <lambdabot>   "3e9b1ce9"
06:52:01 <dankna> hrm
06:52:30 <ksf> I think I fould a ghc bug.
06:54:44 <zakwilson> dankna: my problem updating parsec was user error, I think. Now it's updated and my parsers won't compile. Isn't bit rot fun?
06:54:56 <dankna> zakwilson: :(
06:55:14 <dankna> you could always use Joy, after I write it
06:55:20 <theorbtwo> zakwilson: Sorry -- I had that problem too, but I can't remember just how I fixed it.
06:55:20 <dankna> (Happy doesn't support shift-actions)
06:55:38 <dankna> but for some reason people are adverse to using "real" parsers :)
06:55:49 <ksf> wait it only seems to appear in interpreted programs.
06:55:53 <ksf> I'm using TH.
06:55:56 <dankna> ohhh
06:56:10 <dankna> yeah, TH is interpreted, as you know
06:56:26 <theorbtwo> dankna: How do you define real?
06:56:32 <dankna> theorbtwo: shift-reduce
06:56:39 <dolio> unsafeCoerce is unsafe in that it defeats the type system.
06:56:55 <dolio> You can pass a Float to a function that expects an Integer. Etc.
06:57:03 <dankna> obviously, this also implies being able to execute arbitrary code
06:57:15 <theorbtwo> dankna: That isn't obvious to me.
06:57:16 <dankna> ie by unsafeCoercing ByteString to IO ()
06:57:38 <ksf> dolio, but unsafeCoercing Float->Int32 should definitely _not_ result in a number that takes 48 bits to represent.
06:57:47 <ksf> I think it's messing up tag vs. data location
06:57:48 <theorbtwo> dankna: But you can't *execute* that IO () unless you can, er, do that.
06:57:54 <ksf> boxed vs. unboxed, something
06:58:08 <dankna> theorbtwo: hm.  okay, maybe so.
06:58:32 <dolio> I don't think coercing a ByteString to an IO () is likely to work for executing arbitrary code.
06:58:49 <theorbtwo> I do wonder if you can use it to create a thunk that then gets lazily evaluated.
06:58:50 <dankna> well, IOArray Word32 then
06:59:02 <ksf> wtf trac wants to verify my email
06:59:36 <zakwilson> The errors I'm getting are "No instance for (Text.Parsec.Prim.Stream s m Char)" and similar. Before I go digging in to this, is there a simple, known change between 2.x and 3.x that causes such errors and maybe even documentation about it?
07:00:00 <dankna> I am afraid that I am not really a Parsec user
07:00:05 <dankna> I don't like the fact that it backtracks
07:00:09 <dankna> so I have no idea
07:01:20 <theorbtwo> zakwilson: Ah, I never mucked about with that layer, so I can't help.
07:01:41 * zakwilson became a Parsec user because it made things easy.
07:02:30 * theorbtwo became a parsec user becuase it looked like it'd make things easy.
07:02:33 <theorbtwo> (It didn't.)
07:02:51 * dankna didn't become a parsec user because it didn't look like it would make things easy ;)
07:03:33 <zakwilson> Parsec made things easy until now.
07:03:34 <dankna> I guess I'm a parser snob
07:03:35 <kmc> unsafeCoerce can execute arbitrary code for the same reason that unsafe pointer operations in C can
07:03:48 <zakwilson> I'm a parser newb.
07:04:05 <kmc> it allows you to write to memory in totally unexpected ways, and to treat the same region as code and data
07:04:23 <kmc> if you actually wanted to execute a ByteString as machine code
07:04:40 <theorbtwo> Hm, I'll ask again, since there seem to be some domain semi-experts around -- anybody know of a parsing framework for haskell that makes parsing non-streaming file formats simple?
07:04:43 <Ke> so ghc does not use noexec bit?
07:05:07 <theorbtwo> That is, ones that store offsets to other locations within the same file.
07:05:18 <kmc> Ke, i don't know, it's below the levels i am describing
07:05:29 <theorbtwo> Ke: The noexec bit isn't a pancea, it just makes things harder.
07:05:30 <dankna> theorbtwo: Happy has a monadic parser.  I don't know what your criteria for "simple" are though.
07:05:33 <theorbtwo> kmc: D'oh.
07:05:34 <kmc> an OS or processor can provide protection that still works after you've circumvented the language's safety
07:06:00 <kmc> the point is that unsafeCoerce allows you to totally circumvent all the Haskell-level guarantees about what your code does
07:06:17 <b0fh_ua> Does anyone know is there some simple and ready-to-use library for parsing of standard Unix-like config files (with # marking comments and name=value pairs) ?
07:06:47 <dankna> I'm not aware of one, bofh
07:06:55 <kmc> to execute a ByteString, you can get its internal ForeignPtr, cast that to Ptr, then to FunPtr, and pass that to a ffi dynamic stub to get a callable function
07:07:08 <kmc> and that should probably work, assuming the code you've loaded in follows your architecture's C calling convention
07:07:16 <dankna> ouch :)
07:07:17 <dankna> I see
07:07:38 <theorbtwo> kmc: Ah, but you couldn't do that without access to ForeignPtr, Ptr, or FunPtr.
07:07:42 <kmc> yes
07:07:54 <kmc> Foreign also allows you to circumvent the type system
07:08:25 <Kj8> Hi all, I'm an Italian student. Should develop a project in Haskell, but I do not know the language. Who can help me to develop this project (including payment)? Please contact me at lurchigi@hotmail.com.
07:08:48 <theorbtwo> Kj8: You are trying to hire somebody to do your homework?
07:09:52 <dankna> :( that's disappointing in many ways
07:10:10 <dankna> I weep for humanity
07:10:18 <Kj8> yes
07:11:33 <theorbtwo> While you get points for being honest about it, it doesn't come anywhere close to making up for how horrible that is.
07:11:39 <dankna> indeed
07:12:09 <zakwilson> In this economy, there's probably somebody here who will do it. That is also sad.
07:12:20 <EvanR-work> free market
07:12:21 <EvanR-work> ;)
07:12:28 <dankna> I would point out that the risk of not being paid is quite high
07:12:39 <EvanR-work> let the buyer beware
07:12:42 <dankna> half the postings on elance.com are like this too
07:12:46 <zakwilson> Or, in this case, the seller.
07:12:49 <dankna> in this case it's - right
07:12:50 <EvanR-work> yes
07:12:56 <EvanR-work> whatever, let trader beware
07:13:06 <dankna> just beware in general
07:13:10 <EvanR-work> lol
07:13:11 <zakwilson> It's a good point though - someone who cheats in school is more likely than average to cheat a service provider.
07:13:17 <dankna> yes, absolutely
07:14:04 <zakwilson> Though I suppose one could provide compiled executables to show that the solution works, then demand payment before delivering the source.
07:14:34 <dankna> that's sop when freelancing anyway, yeah, but.
07:14:56 <mreh> has anyone done cloud computing in haskell yet?
07:15:41 <mreh> it seems easy enough with parallelisation, but I don't know how to interface with the Amazon Web Service tools, If I need to
07:16:11 <dankna> I haven't done it.
07:16:46 <ksf> http://hackage.haskell.org/trac/ghc/ticket/3948
07:16:52 <fasta> Kj8, what kind of money are we talking about?
07:17:04 <ksf> someone please reprocude that, before they send me into a mental asylum.
07:22:12 <dolio> ksf: I don't understand why you think that's a bug.
07:23:12 <ksf> dolio, because something that is an Int32 should not ever contain more than 32 bits?
07:23:22 <ksf> also, the sheer randomness of results.
07:23:50 <dolio> unsafeCoerce may produce some underlying representation that violates an invariant expected of Int32.
07:24:02 <ksf> yes. but that ain't the problem, here.
07:24:04 * Jafet gift wraps ksf a PDP-10.
07:24:26 <ksf> the problem seems to be that the float type tag becomes part of the value of the int.
07:24:48 <dolio> So?
07:24:48 <ksf> ...extending a 32 bit type to 48 bits.
07:25:37 <ksf> dolio, well, the interpreter does it, the compiler doesn't.
07:25:40 <dolio> How do you know an Int32 isn't 64-bits with the higher 32 bits expected to be 0?
07:25:50 <dolio> Or something.
07:25:53 <Jafet> mreh, you can probably wrap the EC2 thingy in a ghc api
07:25:59 <dolio> And unsafeCoerce mixes things up.
07:26:04 <ksf> dolio, it just plain isn't.
07:26:20 <ksf> ...sometimes it mixes it up, sometimes not.
07:26:30 <mreh> Jafet: that's the storage thingy isn't it?
07:26:45 <dankna> I should point out that if it's stored in a register on a 64-bit machine, it actually IS 64 bits
07:26:50 <ksf> anyway, what'd be the officially sanctioned way to get the bit representation of a float?
07:27:08 <dankna> there's accessors for the fields of a float in Numeric
07:27:09 <dolio> Through some primop.
07:27:18 <dolio> Or a bits instance for Float if it exists.
07:27:18 <fasta> This is what Kj8 wants implemented http://www.sti.uniurb.it/padovani/Didattica/LinguaggiCompilatori/Progetto/2009-2010/project.pdf and that for the grand sum of 80 euros.
07:27:18 <Jafet> I have no idea really, just talked to someone who talked to someone who runs nethack on EC2
07:27:21 <dankna> but that doesn't sound like what you want
07:27:24 <dankna> Storable should work too
07:27:31 <ksf> dankna, depends on what operations you do on it. usually, the high bits are ignored.
07:27:34 <edwardk> @type exponent
07:27:35 <lambdabot> forall a. (RealFloat a) => a -> Int
07:27:36 <edwardk> @type mantissa
07:27:37 <lambdabot> Not in scope: `mantissa'
07:27:39 <danderson> why would you run nethack on EC2?
07:27:39 <dankna> ksf: yeah I know... but they're there
07:27:40 <edwardk> hrmm
07:27:46 <danderson> telnet nethack.alt.org, free server!
07:27:54 <ksf> dankna, like xor eax, eax which zeroes all of rax
07:27:56 <Jafet> That's what runs on EC2.
07:28:00 <danderson> ... oh.
07:28:14 <danderson> interesting, I always assumed it was a random dedicated server somewhere :)
07:28:24 <Jafet> Now it's a random dedicated server nowhere
07:28:40 <edwardk> danderson: maybe that is what his buddy runs... oh hah, nm he beat me to it =)
07:28:54 <danderson> Jafet: it's not nowhere, it's IN THE CLOUD!
07:28:55 <danderson> or something.
07:29:07 <dankna> somebody should report him to his professor
07:29:13 <danderson> Jafet: but that works out cheaper than keeping a dedicated machine? I'm mildly surprised
07:29:22 <dankna> is that really the right thing to do?  discuss
07:29:23 <edwardk> it is only a cloud because you don't know what your server looks like so you have no idea what to draw there ;)
07:29:23 <ksf> :t decodeFloat
07:29:24 <lambdabot> forall a. (RealFloat a) => a -> (Integer, Int)
07:29:26 <Jafet> Not really, but the latency is better
07:29:27 <dolio> If unsafeCoerce doesn't turn a Float into an Int with identical bits, though, I don't think there's anything to complain about.
07:29:29 <danderson> last time I ran the numbers, EC2 was still a little pricey unless you were going for economies of scale
07:29:32 <danderson> ah.
07:29:39 <dolio> That's not the kind of thing you can expect to work.
07:29:45 <ksf> but that's not what I want. I want the Int32 representation, which preserves ordering according to IEEE
07:30:02 <ksf> (modulo some issues I don't care about)
07:30:12 <edwardk> ksf: alas, the haskell specification does not imply that floats or doubles have IEEE representation
07:30:22 <Entroacceptor> dankna: no, it is not
07:30:25 <edwardk> ksf: nor, if they do, what endianness everything has
07:30:35 <gwern> danderson: don't forget a dedicated machine might be more administrative hassle
07:30:41 <dankna> Entroacceptor, why is that?  because it was only an attempt and not a success?
07:30:53 <Jafet> unsafeUseX86Float
07:30:56 <Zao> ksf: poke into a Ptr Float#, castPtr, peek from a Ptr Int32# ?
07:30:57 <ksf> dolio, but what should happen if I unsafeCoerce said Int32 back to a float? shouldn't that give the original data?
07:31:10 <ksf> Zao, that'd work, but I don't want the overhead.
07:31:15 <ksf> also, IT'S A BUG.
07:31:17 <dolio> Maybe. Who knows?
07:31:17 <Entroacceptor> dankna: it was the attempt at attempting, yes. And the harm's his anyway
07:31:22 <dankna> mm
07:31:35 <dankna> I guess
07:31:37 <Zao> ksf: In your opinion.
07:31:51 <ksf> *Main> :t bar
07:31:51 <ksf> bar :: Int32
07:31:51 <ksf> *Main> bar
07:31:51 <ksf> 140549560147177
07:31:52 <danderson> gwern: running on EC2 doesn't magically resolve administration problems; if anything it makes it slightly more of a headache to manage the VMs
07:31:52 <edwardk> ksf: unsafeCoerce . unsafeCoerce = id
07:31:56 <ksf> is anything strange, thereL
07:31:57 <ksf> ?
07:32:05 <danderson> but you do get fast failover on hardware failure, yeah.
07:32:16 <dankna> at any rate the professor probably doesn't speak English and I'm not going to mess with trying to get stuff translated to Italian, so...
07:32:21 <Jafet> I would just write this in C and use c2hs
07:32:29 <ksf> that's type safety we're speaking about.
07:32:34 <Jafet> Hahaha
07:32:47 <Jafet> Ok, you know best.
07:33:06 <pastorn> edwardk: is that true?
07:33:17 <pastorn> @type unsafeCoerce
07:33:18 <lambdabot> Not in scope: `unsafeCoerce'
07:33:25 <pastorn> @hoogle unsafeCoerce
07:33:25 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
07:33:27 <edwardk> pastorn: it is an admissable RULE ;)
07:33:36 <edwardk> pastorn: that said, there is a slight lie to it
07:33:42 <edwardk> in that
07:33:45 <siracusa> dankna: Where do you know his university from?
07:34:03 <ksf> I don't expect much from unsafeCoerce, but I _do_ expect it not to mix up type tags with data.
07:34:07 <edwardk> unsafeCoerce :: (a -> b) -> Int -- can do bad things if you seq the Int.
07:34:19 <edwardk> or at least is permitted to
07:34:19 <pastorn> edwardk: hmm... unsafeCoerce is pretty naughty... i have no clue when it could be useful
07:34:25 <dankna> siracusa: fasta linked it
07:34:33 <ksf> pastorn, to get the bit representation of a float
07:34:36 <dankna> pastorn: I've used it
07:34:43 <dankna> pastorn: in dynamic-plugins
07:34:49 <ksf> to implement Data.Dynamic
07:34:55 <pastorn> ksf: unsafeCoerce :: Float -> ????
07:34:56 <dolio> It's useful if you know that two types are equal, but you can't convince the type system of that.
07:34:57 <edwardk> pastorn: i've used it on several occasions to increase sharing
07:35:03 <ksf> Float -> Int32
07:35:12 <pastorn> heh, naughty
07:35:17 <ksf> Double -> Int64 etc.
07:35:18 <dankna> in dynamic-plugins I know the type of a value read from a dynamic library that was just loaded, because I parsed the type out of the .hi file
07:35:27 <dankna> but the type system has no way of knowing
07:35:29 <dankna> so I have to tell it
07:35:43 <dankna> so my use is probably safer than ksf's :)
07:35:45 <pastorn> hmm... maybe this is how you create C structs in haskell :)
07:36:19 <edwardk> ksf: unsafeCoerce :: Float -> Int32 just gives you a 'int-typed' float constructor. attemtping to read from it will see that it has constructor #1, because of dynamic pointer tagging, so most pattern matches will do the right thing
07:36:25 <Jafet> data Float = ... deriving (ByteSize 4)
07:36:25 <dankna> er, direct-plugins.  brain fart.  forgot the name of my own library :)
07:36:32 <pastorn> someone was talking about C functions that took structs as arguments, and how to use that from haskell with FFI
07:36:35 <pastorn> yesterday
07:36:44 <ksf> edwardk, they're doing _different_ things, depending on moon phase
07:36:44 <dankna> pastorn: through libffi is one way
07:37:03 <ksf> where compiled code always behaves as I expect, which is just treating the data as int.
07:37:37 <pastorn> edwardk: hang on...
07:37:38 <ksf> and the interpeted code is being creepy, fitting 47 bits of data into allegedly Int32.
07:37:50 <Liskni_si> dankna: When I was a child, I was told that telling on somebody is not nice. It could've been that people around here hated when their info was given to STB agents, and that in a civilized world it is a usual practice, but still...
07:38:08 <pastorn> so if i do uC :: Float -> Int32 it will actually work?
07:38:16 <pastorn> constructors will just work as well?
07:38:33 <dankna> Liskni_si -- well, I try to be nice in general, but it's not my priority
07:38:35 <ksf> it will, unless you use the interpreter.
07:38:51 <ksf> pastorn, http://hackage.haskell.org/trac/ghc/ticket/3948
07:38:59 <ksf> try to compile it and run directly
07:39:15 <ksf> (you have to remove .o .hi etc. to get it nonfunctional, again)
07:39:21 <edwardk> ksf: accessing the float's internal unboxed Float# via an I# constructor pattern match will try to access the bits that happen to be at the in the thunk position of the Int# argument of I#. but nothing says that thunks have a simple slot structure
07:39:21 <dankna> Liskni_si -- you came into a channel with five hundred people you don't know and advertised your intention to do something immoral.  that was an awful lot of trust in strangers.
07:40:05 <ksf> edwardk, should'nt unsafeCoerce take care of that?
07:40:13 <ksf> that is, same data, different tag?
07:40:14 <edwardk> ksf: you have no guarantee that the Int# would store at the same position in the I# constructor as the Float# in the F#
07:40:35 <Liskni_si> dankna: yeah, that's right, the probability of at least one in 500 being a rat is almost 1, but I wouldn't be proud of being it
07:40:47 <writer> Hi everyone
07:41:09 <edwardk> unsafeCoerce just got rid of the safety check that you can't pass a F# constructor to a function that expects an Int, because the latter checks to see if something is an I#, by checking the tagging bits, and forces it otherwise.
07:41:13 <dankna> Liskni_si -- I'll pretend you didn't just insult me.  Relax.  I already said I'm not going to.  You can stop talking anytime now.
07:41:23 <edwardk> it kind of works becuase the tag bits match, since there is only one constructor
07:41:27 <edwardk> and most pattern matches just check those
07:41:33 <pastorn> FliPPeh_: read above on how to create structs when using FFI ^^^^
07:41:33 <writer> Does anyone has any suggestions about the 'parseIRC' function at http://patch-tag.com/r/abbe/habbott/snapshot/current/content/pretty/habbott.hs ?
07:42:04 <edwardk> ksf: but the unsafeCoerce is simply a typing dodge, it doesn't rewrite the target thunks.
07:42:05 <ksf> edwardk, what I don't understand is how I can have a value which ghci says is "Int32" which holds 48 bits of data.
07:42:34 <ksf> if I call show on it, it should just bail out after the first 32 bits.
07:42:38 <writer> the parseIRC function looks like a ugly hack to me...
07:42:48 <writer> s/a u/an u/
07:42:54 <ksf> (be those right or wrong, that's another topic)
07:43:04 <dolio> Because how do you know it's actually just 32 bits?
07:43:08 <pastorn> writer: use Network.IRC
07:43:13 <pastorn> writer: it comes with a parser
07:43:19 <edwardk> ksf: i'm slightly baffled there. one possibility is that internally Int32 is represented by a 64 bit value. another is that its using some internal show primitive that sees the constructor, not the type
07:43:20 <ksf> dolio, we're statically typed.
07:43:21 <pastorn> writer: cabal install irc
07:43:27 <ksf> Int32 knows that it's 32 bits
07:43:28 <writer> pastorn: Oh, thanks
07:43:30 <dolio> I can write a type called Just32Bits, but have it actually store 118 bits.
07:43:32 <pastorn> hehe
07:43:39 <pastorn> writer: bye bye 200 lines
07:43:40 <Liskni_si> dankna: whatever. Just keep in mind that s/you/he/, or is that my english that's wrong?
07:43:49 <dolio> And only normally allow you to access 32 bits.
07:44:08 <pastorn> writer: also, you should learn how to use parsec
07:44:22 <ksf> oh. bar .&. 0xffffffff doesn't clamp it, either.
07:44:24 <writer> pastorn: I know, but I didn't use it because of the overkill...
07:44:28 <dolio> But maybe if you unsafeCoerce, something gets written into those other bits that I don't expect to ever be there, so my functions screw up.
07:44:46 <writer> pastorn: I wanted to write my own parsing functions...
07:44:46 <pastorn> writer: what overkill? your code looks insane
07:44:51 <edwardk> ksf: that one is interesting =)
07:45:05 <dolio> I can't explain the masking.
07:45:06 <pastorn> writer: why not just reimplement http://eprints.nottingham.ac.uk/archive/00000223/01/pearl.pdf instead
07:45:11 <pastorn> ?
07:45:14 <edwardk> i'd expect that to yield a new constructor, which shouldn't have any hinkiness to it
07:45:21 <ksf> edwardk, http://hackage.haskell.org/trac/ghc/ticket/3948 , patches welcome :)
07:45:41 <Mathnerd314> why is it in "template haskell"?
07:45:55 <ksf> because there's no "interpreted code"
07:45:59 <Mathnerd314> ok
07:46:11 <ksf> and I thought "ghci" gets enough user-interface bugs, already.
07:46:24 <edwardk> ksf: i presume you are on a 64 bit box?
07:46:29 <ksf> yep
07:47:00 <edwardk> ksf: then you're probably seeing an artifact of the fact that slots are 64 bits wide, so int32, etc. are just ops that work on a the first 32 bits of a 64 bit slot
07:47:13 <edwardk> so you're getting garbage in the last 4 bytes
07:47:24 <edwardk> little endian
07:47:28 <ksf> no the low 4 bytes seem ok
07:47:36 <ksf> yes.
07:47:47 <ksf> the 4 bytes above look like a type tag to me.
07:48:00 <ksf> ...two bytes, not 4
07:48:32 <edwardk> the low bytes would be ok. the top bytes would be garbage dangling off the end
07:50:09 <ksf> and what's with the bitmask?
07:50:21 <ksf> (don't tell me its a rule, that'd be too easy)
07:50:21 <edwardk> it gets optimized away
07:50:44 <edwardk> after all the ops you're using just work on the bottom 4 bytes and know it
07:50:54 <dolio> Incidentally, coercing back to a Float always seems to yield the same float, to me.
07:51:08 <edwardk> dolio: i should hope so =)
07:51:26 <dolio> So Float -> Int32 -> Float yields no observable differences, even though Float -> Int32 yields different answers sometimes.
07:51:33 <ksf> I think that's even scarier than the messed high bits.
07:51:51 <edwardk> ksf: no, that is expected behavior, it is a Float constructor after all
07:52:00 <edwardk> if it can't be used as a Float, what CAN you use it for? =)
07:52:19 <Mathnerd314> when are all the C programmers going to switch to Haskell?
07:52:33 <dankna> Mathnerd314, it happened yesterday - nobody told you?
07:52:35 <edwardk> Mathnerd314: next week. there was a memo
07:52:40 <ksf> when they can use unsafeCoerce without running into surprises
07:52:47 * arcatan goes to add -fvia-haskell to gcc
07:52:47 <edwardk> dankna: ah they moved the date up. nobody told me =)
07:52:49 <dolio> edwardk: Well, it is weird that I can type in 'unsafeCoerce (... :: Float) :: Int32' and get different answers each time.
07:52:54 <dankna> hehe
07:52:59 <dolio> I don't understand why that would happen.
07:53:04 <dankna> arcatan: hehehehee
07:53:15 <dolio> It's actually only one of two answers. But it seems random.
07:53:19 <ksf> dolio, randomnized type tags.
07:53:22 <theorbtwo> dolio: Because the float is really a pointer, and the int isn't?
07:53:45 <edwardk> theorbtwo: no, they have the same general form. a constructor and that contains an unboxed foo
07:54:04 <ksf> ...at least on a 64 bit box, I'd expect 32-bit data to be unboxed alongside with their tag.
07:54:04 <edwardk> ksf: its not a type tag. its either the following tag, or the forwarding pointer
07:54:15 <edwardk> ksf: er its not the type tag of the float itself
07:54:29 <ksf> pointer as in hardware pointer? it's too small for that.
07:54:56 <ksf> (whatever an hardware pointer is)
07:55:01 <ksf> well, it isn't size_t.
07:55:07 <edwardk> ksf: you have something like [I#][fwd][Int# slot] or [F#][fwd][Float# slot]
07:55:41 <ksf> and the fwd is optional?
07:55:43 <edwardk> ksf: you're slopping and reading 4 bytes extra one way or the other from the Int# slot. so its not going to reach the I#
07:55:57 <pastorn> what's [fwd]?
07:56:14 <edwardk> the fwd will be a pointer sized value pointing to whereever you've been forwarded during gc.
07:56:18 <Lemonator> xmobar has a "default" configuration.
07:56:27 <dolio> edwardk: http://img57.imageshack.us/img57/5607/coerce.png
07:56:30 <Lemonator> how can I get the file for that default config?
07:57:29 <ksf> dolio, care to attach that to the bug?
07:57:50 <edwardk> what you should be seeing at the 4 bytes that follow your thunk in memory.
07:57:55 <dolio> Don't you essentially have that information?
07:58:21 <ksf> Lemonator, http://hackage.haskell.org/packages/archive/xmonad/0.9.1/doc/html/XMonad-Config.html
07:58:36 <ksf> ...usually, you just override what you need.
07:58:47 <dolio> Oh, I guess you don't. You have two different Floats.
07:58:49 <Lemonator> xmobar, not xmonad.
07:58:55 <ksf> oh.
07:58:57 <edwardk> which should be another tag, or whatever the memory allocator wraps it with, but i think they are basically naked for gc purposes.
07:59:29 <edwardk> http://haskell.org/ghc/docs/6.2.1/html/libraries/base/GHC.Int.html
07:59:45 <ksf> Lemonator, http://code.haskell.org/xmobar/ , Config.hs
08:00:59 <Lemonator> ksf, thanks.
08:03:49 <pastorn> is it possiblo to cast some sort of array (from Data.*Array*) to a Foreing.Array?
08:03:50 <siracusa> Is there no library for handling BBCode in Haskell?
08:04:17 <edwardk> pastorn: no, Data.Array is internally boxed.
08:04:29 <pastorn> what does that mean?
08:04:39 <pastorn> i've never understood the term "boxed"
08:04:40 <edwardk> An Array Int Float is an array if pointers to thunks
08:04:44 <kmc> StorableArray is the array you want for interacting with C code
08:04:48 <jmcarthur> it means the elements have a layer of inderection
08:04:50 <ksf> siracusa, don't. just don't use bbcode.
08:04:56 <ksf> siracusa, hava a look at pandoc.
08:05:04 <jmcarthur> or Data.Vector.Storable :)
08:05:09 <edwardk> each thunk turns into a structure that looks like that [F#][fwd][your floating point value here] when forced
08:06:08 <pastorn> what's a "thunk"?
08:06:13 <siracusa> ksf: sounds interesting, thanks
08:06:18 <pastorn> a collection of data in one spot?
08:06:42 <pastorn> edwardk: "is an array if pointers to thunks"??
08:06:45 <theorbtwo> pastorn: A thunk is how haskell records that it can do something later to get a value, lazily.
08:06:51 <Zao> pastorn: A thunk in a Haskell context is something that either holds a value or a computation.
08:07:10 <ksf> ...a thunk is either a value or a computation which yields said value.
08:07:17 <Lemmih> pastorn: s/if/of/
08:07:26 <pastorn> is that the [fwd] part? does that tell if this is an evaluated value or not?
08:07:31 <theorbtwo> pastorn: Pay attention to zao and ksf, ignore me.
08:07:53 <pastorn> Lemmih: there you are!
08:08:02 <pastorn> Lemmih: can haz sdl tutorials?
08:08:17 <edwardk> > array (1,4) [(1,2.0),(2,undefined),(3,error "forced")] ! 1
08:08:18 <lambdabot>   2.0
08:08:35 <jmcarthur> pastorn: the sdl bindings are basically the same as the C library. you should be able to use the C documentation to figure out the haskell bindings
08:08:38 <edwardk> > pastorn as long as you don't look at the elements of the array that when evaluated would crash your program doesn't crash
08:08:39 <lambdabot>   <no location info>: parse error on input `of'
08:08:40 <Lemmih> pastorn: Btw, you don't really need to know about the heap layout to create a Foreign.Array from a Data.Array. They're just trying to confuse you.
08:09:22 <edwardk> Lemmih: i only mentioned it because he had said something about a heap diagram i'd mentioned earlier. i was just providing context. not intending to confuse
08:09:24 <pastorn> Lemmih: i'm just trying to figure out how to use VBOs with haskells OpenGL
08:09:41 <jmcarthur> pastorn: hah, i was just doing exactly that last night
08:09:49 <jmcarthur> pastorn: i'm using Data.Vector.Storable
08:09:53 <edwardk> pastorn: in c if you go to make an array of floats and computing one of them crashes you crash right then, because you insert them strictly
08:09:58 <pastorn> so i was just thinking that it'd probably be nicer to cast to a Foreign.Array from a Data.Arary than from a list
08:10:22 <edwardk> in haskell a float is just a stored computation that claims it can give you a 'real floating point number when asked.
08:10:30 <pastorn> jmcarthur: cool, could you show me your code?
08:10:50 <Lemmih> pastorn: I'm afraid I don't have any hsSDL specific tutorials.
08:10:53 <jmcarthur> pastorn: nope. it's not done, and it's not available to me here at work
08:10:58 <edwardk> the closer match to a Foreign.array is an STUArray or UArray
08:10:58 <pastorn> edwardk: gogo laziness
08:10:59 <dolio> ksf: Both of the values in my screenshot are too big for 32 bits, right?
08:11:10 <ksf> they look like it.
08:11:13 <edwardk> pastorn: but to represent that laziness you need a layer of indirection
08:11:14 <ksf> if in doubt, logBase 2
08:11:19 <dolio> > 1056980433 :: Int32
08:11:20 <lambdabot>   1056980433
08:11:28 <edwardk> pastorn: that layer of indirection are those 'thunks' mentioned above
08:11:35 <dolio> > logBase 2 1056980433
08:11:36 <lambdabot>   29.9773015235402
08:11:37 <pastorn> Lemmih: i looked at the hacka docs... couldn't find even how to make a window :(
08:11:40 <dolio> Ah, I guess not.
08:11:45 <edwardk> s/are/is comprised of
08:11:57 <ksf> ...ignoring for a moment whether or not that unsafeCoerce thing is a bug and going to be fixed or not, how do I get the bit representation of a float without using unsafeCoerce?
08:12:05 <dankna> Storable
08:12:08 <dolio> ksf: Coercing maxBound :: Int64 to Int32 gives the same 64-bit answer every time.
08:12:11 <ksf> yep. you said thait.
08:12:31 <jmcarthur> pastorn: looks at the C documentation on SDL's web site
08:12:34 <dolio> So Int32 is clearly actually storing 64 bits on x86-64.
08:12:39 <dankna> you basically allocate space for it on the foreign heap, write it there, and read it back out as a Word32
08:12:40 <jmcarthur> pastorn: the APIs are basically the same
08:12:45 <jmcarthur> *look at
08:12:46 <ksf> ...as it works in compiled code, I only have to do that for the non-compiled
08:12:51 <dolio> Well, earlier I tried it with Words, and got it to print -1, which was weird.
08:12:57 <ksf> which mostly makes this the most evil shootout entry ever.
08:13:02 <edwardk> dolio: the 'slots' are 8 bytes wide on x86-64, even if the values in them aren't
08:13:07 <ksf> *most likely
08:13:35 <dolio> Is it possible that it chooses different Floats for 0.50094324 at random?
08:13:44 <dolio> Different approximate representations?
08:13:48 <jmcarthur> o_O
08:13:48 <dolio> And that's what you're seeing?
08:13:59 <edwardk> dolio: nah thats built fromRational, etc.
08:14:01 <pastorn> jmcarthur: i'm told that you can't hold down multiple keys with GLUT, is this true?
08:14:13 <pastorn> (for haskell GLUT)
08:14:17 <jmcarthur> pastorn: GLUT does suffer from very severe limitations like that
08:14:18 <edwardk> dolio: i think you're just seeing that the Float doesn't initialize the last 4 bytes in its slot
08:14:23 <jmcarthur> even the nonhaskell GLUT
08:14:39 <Lemmih> pastorn: This might be of interest even though it also uses OpenGL: http://mirror.seize.it/hsSDL/hssdl/Examples/NeHe/lesson02/lesson2.sdl.hs
08:14:58 <dolio> Wouldn't that yield way more than 2 different possibilities?
08:15:08 <Lemmih> pastorn: 'withInit' and 'setVideoMode' are the important functions.
08:15:35 <pastorn> Lemmih: this is awesome! you should put this in the .tar.gz on hackage
08:15:54 <edwardk> dolio: depends, the contents of memory you're getting is likely remarkably uniform if you're not under gc pressure
08:15:59 <pastorn> along with maybe a comment or two :)
08:16:04 <jmcarthur> pastorn: NeHe is a well-known OpenGL tutorial
08:16:12 <jmcarthur> oh, this is haskell code
08:16:15 <jmcarthur> n/m
08:16:22 <arw_> is there some way to make ghci search for a function in its known set of modules? like "tell me where liftIO is?"
08:16:32 <jmcarthur> i believe somebody has ported most or all of NeHe to haskell somewhere
08:16:34 <jmcarthur> on github maybe?
08:16:35 <sepp2k> When installing haskell-platform how can I tell it not to build GLUT?
08:16:55 <Mathnerd314> @hoogle liftIO
08:16:56 <lambdabot> Control.Monad.Trans liftIO :: MonadIO m => IO a -> m a
08:17:24 <pastorn> jmcarthur: the first ~12 ones are on hackage as 'nehe'
08:17:28 <pastorn> @where nehe
08:17:28 <lambdabot> I know nothing about nehe.
08:17:31 <pastorn> awww
08:17:32 <Lemmih> jmcarthur: Yeah, Jason Dagit ported the NeHe tutorials better than I did.
08:19:27 <EvanR-work> whats a convenient way to do a c style printf. printf returns a string and i have to toStrLn it. how about something like printf that returns IO ()
08:19:47 <Lemmih> EvanR-work: printf can do that (:
08:19:47 <jmcarthur> :t printf
08:19:48 <lambdabot> forall r. (PrintfType r) => String -> r
08:19:53 <jmcarthur> it's not just String
08:19:54 <jmcarthur> ;)
08:19:56 <Lemmih> EvanR-work: printf "Hello world" :: IO ()
08:19:59 <EvanR-work> yeah i see that
08:19:59 * ksf hides under a monad
08:20:05 <ksf> word32 compares aren't faster.
08:20:11 <pastorn> EvanR-work: printf has a super magic type signature
08:20:19 <jmcarthur> a super ugly one :\
08:20:22 <EvanR-work> so printf will print?
08:20:28 <pastorn> EvanR-work: yes...
08:20:31 <jmcarthur> yes it will if you use it in IO
08:20:31 <EvanR-work> :S
08:20:41 <pastorn> EvanR-work: cool, huh?
08:20:45 <EvanR-work> uhm y...eah
08:20:57 <EvanR-work> PrintfType
08:21:00 <ksf> ...and give ever so slightly off results, it seems.
08:21:02 <pastorn> "Don't attempt this at home"
08:21:10 <EvanR-work> lol
08:22:18 <Mathnerd314> ksf: off results? maybe you forgot a \n?
08:24:52 * pastorn doesn't use printf
08:24:57 <pastorn> i consider it unethical
08:25:27 * hackagebot sec 0.0.1 - Semantic Editor Combinators.  http://hackage.haskell.org/package/sec-0.0.1 (SteffenSiering)
08:25:34 <Mathnerd314> todo: write strongly-typed DSL for printf
08:26:38 <edwardk> Mathnerd314: oleg has a couple
08:26:44 <edwardk> Mathnerd314: there is also a type level one using template haskell
08:28:12 <Mathnerd314> Text.TotalPrintF looks promising
08:29:54 <edwardk> i'm tempted to rewite Text.I18n.Printf using a template haskell time printf for my own purposes.
08:30:39 <edwardk> then i could scrap large swathes of my current diagnostic framework, and just use a strongly typed gettext
08:31:05 <FliPPeh_> Why is haskell.org so slow? :(
08:31:33 <ksf> <ksf> http://gist.github.com/349196
08:31:35 <ksf> <ksf> can someone with a shootout-like box bench that against http://shootout.alioth.debian.org/u64/program.php?test=fasta&lang=gcc&id=3 ?
08:32:20 <uorygl> Can I see the Agda package's docs online?
08:32:46 <jmcarthur> ?hackage agda
08:32:46 <lambdabot> http://hackage.haskell.org/package/agda
08:33:15 <jmcarthur> looks like you can't. probably hackage build bot doesn't have alex and happy, so couldn't build the package
08:33:32 <uorygl> Bah.
08:34:55 <uorygl> I wonder how I'm supposed to see the docs, then.
08:35:59 <jmcarthur> uorygl: you could build the docs locally
08:36:16 <uorygl> I thought I had done that, but they're not in the expected location.
08:36:34 <FliPPeh_> Which FFI approach is recommended? "foreign import ccall "header.h function" ...", or including the header with "{-# INCLUDE ... #-}"?
08:36:51 <ksf> if in doubt, use c2hs
08:37:07 <ksf> but flame all of #ghc for nuking CLDouble.
08:37:12 <ksf> ...first.
08:37:19 <FliPPeh_> :)))
08:37:30 <theorbtwo> CLDouble?
08:37:36 <ksf> long double
08:37:47 <FliPPeh_> The problem I see with putting it into the import call is, not getting #defined constants
08:37:48 <theorbtwo> Ah, fair enough.
08:37:57 <ksf> the one that's not guaranteed not to be 64 bits and was nuked because it was 64 bits.
08:40:56 <b0fh_ua> if I have some sort of "data Option a = Option { name :: String, value :: a }" - how do I define collection of options, like "data Options = [Option ...]" - but make it possible to have "Option Int" and "Option String" within the list? I think it's not possible in Haskell, because list is collection of objects with same types. So what is the solution if I want to have collection of "Option a" items ?
08:41:41 <dankna> existential quantification
08:41:53 <jmcarthur> b0fh_ua: data Option = IntOption String Int | StringOption String String
08:42:01 <dankna> data Option = forall a . Option { name :: String, value :: a }
08:42:07 <dankna> yeah, jmcarthur's answer is better
08:42:23 <b0fh_ua> so not use types - but data constructors instead..
08:42:24 <dankna> better design to not use EQ if you don't really need it, and it sounds like your need is more specific
08:42:31 <b0fh_ua> a bit verbose :)
08:42:55 <jmcarthur> not that bad
08:42:55 <fax> ugh
08:42:57 <dankna> well, whether it's excessive verbosity depends on how many types you need it for
08:43:09 <b0fh_ua> just 3 for now - int, string and bool
08:43:16 <dankna> then I would go ahead and do it jmc's way
08:43:18 <b0fh_ua> I thought declare type aliases then
08:43:20 <jmcarthur> b0fh_ua: you could just have constructors in place of names if you know all possible values for name
08:43:33 <jmcarthur> Botje: data Option = Foo Int | Bar String | Baz Bool
08:43:42 <dankna> another way to do things is
08:43:47 <jmcarthur> sorry Botje, i meant b0fh_ua
08:44:20 <dankna> class Option a where optionName :: a -> string
08:44:34 <dankna> data IntOption = IntOption String Int
08:44:54 <jmcarthur> b0fh_ua: instead of doing [OptionInt "foo" 5, OptionString "bar" "mystring"], you could have [Foo 5, Bar "mystring"]
08:45:24 <dankna> oh yeah, I like that
08:45:39 <b0fh_ua> nice idea, thanks :)
08:45:56 <dankna> grrrrr, my Happy works fine in IO but I don't want it in IO
08:46:00 <dankna> *my Happy parser
08:46:56 <dankna> presumably because of guaranteed ordering or something
08:47:13 <Mathnerd314> b0fh_ua: what are you doing with your Options?
08:49:29 <b0fh_ua> Mathnerd314: will read from file and then use in my app :)
08:59:48 <pmaes_> b
08:59:55 <pmaes_> Oops, sorry
09:02:45 * hackagebot mtlx 0.1.3 - Monad transformer library with type indexes,  providing 'free' copies.  http://hackage.haskell.org/package/mtlx-0.1.3 (MarkSnyder)
09:07:38 <FliPPeh_> How do I "catch" defines from included C header files with FFI? :(
09:08:20 <lispy> FliPPeh_: hsc2hs
09:08:35 <FliPPeh_> Ahhh
09:08:37 <FliPPeh_> Thanks lispy
09:08:41 <lispy> FliPPeh_: there used to be a way using -fvia-C but that was intentionally disabled
09:09:10 <ksf> hsc2hs is an ugly hack
09:09:41 <FliPPeh_> Okay, hsc2hs seems to work good
09:09:59 <FliPPeh_> Replacing the defines in place?
09:10:01 <FliPPeh_> :)
09:10:27 <ksf> it's a hack because it doesn't understand what it does, needs a c compiler and runs stuff.
09:10:29 <Vanadium> How else am I going to #define caseof \x -> case x of
09:10:47 <ksf> {-# LANGUAGE CPP #-}
09:11:19 <ksf> ...or use TH
09:11:32 <fax> Vanadium, what's x?
09:11:48 <ksf> that's the infamous lambda-case.
09:12:11 <ksf> foo >>= caseof { bar ->... ; baz ... }
09:12:44 <mightybyte> Anyone know why GHC 6.12.1 gives me "unknown RTS option: -N4" when I compile with +RTS -N4?
09:13:28 <ksf> add a space?
09:13:55 <mightybyte> ksf: Nope
09:14:01 <ksf> compile with -threaded?
09:14:08 <benmachine> would TH be neat or would it require $caseof or something
09:14:20 <ksf> $caseof or something
09:14:33 <ksf> you can only leave it out at the top level
09:14:35 <benmachine> oh well
09:15:24 <mightybyte> ksf: Ahh, that did it.
09:15:34 <FliPPeh_> Okay, I think I'll do FFI when I'm awesome enough to mess with it
09:15:55 <FliPPeh_> Interfacing a rather big library that uses struct about 99% of the time isn't fun
09:15:58 <FliPPeh_> :(
09:16:00 <Vanadium> ffi is evil
09:16:07 <Vanadium> it god me stuck in a writing-c-in-haskell mindset :<
09:16:20 <edwardk> hrmm is the author of mtlx on here atm?
09:16:29 <FliPPeh_> I just want to write a package manager for arch linux in haskell :(:(
09:16:58 <edwardk> i can't think of a nick for mark snyder
09:17:25 <edwardk> FliPPeh_: heh given how many of our packages they support that seems vaguely metacircular
09:18:02 <FliPPeh_> 84% is the last number I heard of.
09:18:16 <FliPPeh_> But the one thing has nothing to do with the other ;x
09:18:31 <QQueue> QQQQQQQQQQQQQQQQQQQQQQQQQQQ
09:18:33 <FliPPeh_> I want to write a pacman like program in Haskell.. hackman or something!
09:18:45 <FliPPeh_> But that means interfacing libalpm, and that's a pain.
09:18:49 <jmcarthur> pacman the game or pacman the package manager?
09:18:58 <FliPPeh_> package manager
09:19:00 <QQueue> that is a good
09:19:02 <QQueue> idea
09:19:04 <QQueue> I support it
09:19:14 <QQueue> rewrite pacman in haskell
09:19:32 <QQueue> the package manager that is
09:19:41 <FliPPeh_> Once the alpm interface is set up, it's trivial
09:19:44 <QQueue> heck I will even pay you to do it
09:19:57 <FliPPeh_> But I'm not good enough to do that in Haskell
09:20:00 <edwardk> FliPPeh_: see, talk about your ideas, and they get sponsored ;)
09:20:18 <jmcarthur> ... my ideas have never been sponsored :(
09:20:19 <Twey> Is Nix written in Haskell?
09:20:24 <jmcarthur> Twey: no
09:20:36 <Twey> Why not?
09:20:49 <jmcarthur> it's a package manager written with purely functional ideas in mind, but not a purely functional implementation
09:21:07 <QQueue> why not make a haskell project fundraiser here?
09:21:15 <QQueue> throw some dollars into a pot
09:21:25 <QQueue> get greedy haskellers to earn a buck
09:21:27 <FliPPeh_> I think I should skip libalpm altogether
09:21:38 <FliPPeh_> And just access the packages on-disk
09:21:58 <jmcarthur> QQueue: there are a couple "bounty" sites for open source software, but not very successful if my observations serve me correctly
09:22:13 <QQueue> might distract the haskell people enough form ctheory to get neat stuff done
09:22:37 <QQueue> I know I would
09:23:08 <edwardk> QQueue: unless they incorporate it into the design. you don't need that package you need a fibration over...
09:23:47 <QQueue> we need to make a theory of packages
09:23:55 <QQueue> or is it done
09:25:22 <QQueue> well maybe if you pay dons
09:25:40 <QQueue> he seems pretty active
09:25:51 <edwardk> QQueue: that is the understatement of the year ;)
09:26:21 <QQueue> why is dons so prolific
09:26:43 <jmcarthur> vested interest, perhaps?
09:26:45 <QQueue> he must be on the juice
09:27:05 <QQueue> I am all for being a success
09:27:18 <QQueue> but if you have to be on the juice...
09:27:38 <Becquerel> then drink more
09:27:44 <edwardk> meh, if you learn to give up sleep you can get a lot done ;)
09:28:03 <QQueue> so what coffee does he drink?
09:28:22 <QQueue> well I guess we will never know
09:28:52 <maltem> QQueue, ask him when he's around?
09:29:23 <maltem> He might then be upset, though :)
09:29:27 <edwardk> he is taking his bi-weekly nap, i'm sure he'll be around for you to ask any minute ;)
09:31:07 <Mathnerd314> his blog says he eats vegan food and drinks beer: http://donsbot.wordpress.com/about/
09:31:44 <jmcarthur> that must be it
09:32:06 <QQueue> sure he is not just strong AI?
09:32:57 <benmachine> or maybe he's actually a pair of twins
09:33:09 <benmachine> only one has ever been seen in public in once
09:33:21 <QQueue> that is a good theory
09:33:28 <uorygl> Twin conspiracies are fun.
09:34:08 <Mathnerd314> QQueue: AI's would give up after failing to solve the halting problem
09:34:44 <uorygl> dons hasn't given up after failing to solve the halting problem?
09:34:53 <uorygl> Perhaps the best way to get anything done is by interesting dons.
09:35:27 <gloob1> hi how can i save data returned by readChan to string variable?
09:35:35 <benmachine> or by highlighting him like a billion times on IRC
09:35:39 <benmachine> I love it when people do that
09:36:11 <benmachine> gloob1: that's an odd question, why do you want to?
09:36:55 <uorygl> gloob1: what are you trying to do?
09:37:59 <gloob1> i need to read string from channel and then split it into words and return in structure;)
09:39:18 <benmachine> what have you tried already?
09:40:42 <gloob1> benmachine: let [a,b] = words (readChan (channel) >>= show)
09:41:04 <gloob1> readChan (channel) >>= print worked well
09:41:10 <benmachine> mmhm
09:41:16 <benmachine> that's pretty close
09:41:42 <benmachine> but, readChan channel :: IO a
09:41:58 <benmachine> words operates on a String
09:42:16 <benmachine> you need a way of applying a function on Strings to an IO String
09:42:23 <benmachine> there are several ways of doing that
09:42:56 <benmachine> an interesting one is the fmap function
09:43:03 <[swift]> unsafePerformIO, obviously =)
09:43:05 <benmachine> :t fmap words getLine
09:43:06 <lambdabot> IO [String]
09:43:09 <benmachine> @slap [swift]
09:43:09 * lambdabot clobbers [swift] with an untyped language
09:43:17 <gloob1> i can't use unsafe functions
09:43:21 <benmachine> yeah don't
09:43:25 <[swift]> gloob1: just a joke, don't do it
09:43:51 <benmachine> fmap allows you to apply a pure function to something in IO
09:43:55 <gloob1> [swift]: :)
09:44:05 <benmachine> (or in other things)
09:44:09 <edwardk> benmachine: watch out there is a list of him. if that list is codata, lambdabot may never finish that task
09:44:42 <benmachine> @map slap [swift]
09:44:42 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
09:44:51 <benmachine> that is not what I wanted at all, lambdabot
09:44:56 <edwardk> at least unsafeInterleaveSlap
09:44:59 <gloob1> benmachine: so can you try to write the code please?
09:45:29 <benmachine> gloob1: I can easily write the code, but if I do that and don't tell you how it works you won't know what to do next time
09:45:31 <edwardk> gloob1: this sounds disturbingly like homework
09:45:41 <benmachine> teach a man to fish, etc.
09:46:02 <benmachine> I advise you to spend some time with fmap in ghci
09:46:11 <benmachine> try things like fmap words getLine
09:46:16 <benmachine> fmap reverse getLine
09:46:19 <Twey> fmap fmap fmap
09:46:21 <gloob1> i want to know how it works;)
09:46:27 <Mathnerd314> @type fmap
09:46:28 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:46:32 <maltem> Shouldn't we suggest do notation right away? Makes things less hairy, looks like they're going to pattern-match on the result anyways
09:46:43 <benmachine> maltem: yeah, maybe
09:46:56 <benmachine> maltem: I was trying to do it this way because he was already using >>=
09:47:04 <benmachine> but you could just use do, instead
09:47:22 <Becquerel> do fmap fmap fmap
09:47:23 <maltem> Yeah, but with do, it's easier to say "see this or that tutorial" ;)
09:47:44 <benmachine> @. type undo do fmap fmap fmap
09:47:45 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
09:48:01 <gloob1> benmachine: ok thanks..lets squeeze the ghci..i'll be back ;)
09:48:02 <benmachine> hooray for things that look much more complicated than they are?
09:48:51 <aavogt> @undo do Just x <- y; return x
09:48:52 <lambdabot> y >>= \ a -> case a of { Just x -> return x; _ -> fail ""}
09:48:52 <Twey> [a, b] <- return . words . show =<< readChan channel
09:49:56 <FliPPeh_> Ghahh
09:49:56 <Twey> y >>= maybe (fail "") return
09:50:12 <FliPPeh_> Why is there nothing on C-structs in Haskell?
09:50:19 <FliPPeh_> I know it has to do with Storable and Ptr
09:50:22 <FliPPeh_> But that's all :/
09:50:58 <benmachine> Twey: itym <- fmap (words . show) (readChan channel)
09:51:09 <Mathnerd314> > do fmap fmap fmap (\x -> x+x) [Just 1]
09:51:10 <lambdabot>   [Just 2]
09:51:18 <benmachine> Twey: also, ruining it :P
09:51:24 <aavogt> Twey: well that's only nice if you have a function like maybe defined
09:51:25 <Twey> benmachine: The whole point was that there's no need for fmap :
09:51:33 <aavogt> that's isn't the case for nested tuples etc.
09:51:47 <benmachine> Twey: there's no *need* for a lot of things
09:51:47 <aavogt> well other than pairs
09:52:00 <Twey> aavogt: Sure, though it's arguably better style to define something like that rather than match every time
09:52:01 <maltem> FliPPeh_, C-structs are a mess to handle, because the FFI doesn't help there
09:52:19 <FliPPeh_> maltem: But the library I want to interface is 99% struct passing and building :(
09:52:56 <benmachine> Twey: but fmap proves there is no need for return and =<<
09:53:02 <benmachine> which is two things instead of one, ergo I win
09:53:06 <pikhq> FliPPeh_: I suggest you write up some C functions to handle the C structs.
09:53:08 <maltem> FliPPeh_, passing structs along is easy (you can use Ptr (), basically)
09:53:16 <Twey> .ienai
09:53:21 <FliPPeh_> But I want data out of those struct :(
09:53:41 <pikhq> From Haskell's point of view, those structs are opaque.
09:53:50 <benmachine> I thought structs could be translated into datas
09:53:53 <pikhq> Thus, you need some C functions to get data out of those structs and put them in.
09:54:04 <maltem> yeah, the easiest way is probably to write getters and setters in C, and interface those
09:54:09 <FliPPeh_> meh
09:54:12 <Twey> Or do pointer arithmetic ;)
09:54:19 <FliPPeh_> I'll drop this project until I'm comfortable with this mess
09:54:21 <maltem> The alternative is peeking and poking around
09:54:26 <FliPPeh_> No Hackman right now :(
09:54:29 <pikhq> Twey: Yes, but that's unportable as all heck.
09:54:34 <gloob1> benmachine, Twey: :*
09:54:37 <Twey> Heck yes.
09:54:51 <Twey> Hello, gloob1
09:55:05 <benmachine> Twey: he is pleased you saved him the work of having to learn anything >_>
09:56:24 <pikhq> I SHALL BEAT HIM WITH A LEARNING STICK
09:56:29 <pikhq> LAMBDA I SAY LAMBDA
09:57:34 <FliPPeh_> Haskell is too high level to allow low level :(
09:57:54 <jmcarthur> FliPPeh_: have you checked out bindings-dsl?
09:58:01 <FliPPeh_> Nahhhh
09:58:09 <jmcarthur> FliPPeh_: it has some macros to help you create accessor functions for struct fields and such
09:58:15 <jmcarthur> among other things
09:58:50 <FliPPeh_> mehhh
09:59:15 <jmcarthur> it's really quite handy
09:59:31 <maltem> c2hs has something for structs too, I think
09:59:56 <FliPPeh_> I'll look into it when I am actually able to handle such a project
10:02:40 <EvanR-work> @src listenOn
10:02:41 <lambdabot> Source not found. There are some things that I just don't know.
10:03:00 <FliPPeh_> :t listenOn
10:03:01 <lambdabot> Not in scope: `listenOn'
10:03:03 <FliPPeh_> :)
10:04:03 <Mathnerd314> @hoogle listenOn
10:04:03 <lambdabot> Network listenOn :: PortID -> IO Socket
10:08:41 <maltem> How standard is /usr/lib64? I'm asking because `cabal install OpenGLRaw' on Arch requires --extra-lib-dirs=/usr/lib64
10:09:19 <danderson> it's reasonably common on mixed 32/64 systems iirc
10:10:22 <maltem> hm ok
10:12:37 <FliPPeh_> Actually, structs look really easy..
10:12:55 <FliPPeh_> Make it a record data type, and build some instance of storable to it
10:13:30 <FliPPeh_> foreign import ccall unsafe "getservent" c_getservent :: IO (Ptr ServiceEntry)
10:13:41 <FliPPeh_> At least that is what Network.BSD tells me
10:18:34 <pokoko222> |sqrt(2)+sqrt(3)-sqrt(5)+sqrt(7)| i need to get rid of absolute value sign, if i do calculation i see i get negative number
10:18:51 <pokoko222> to get rid of abs sign, should i just put the thing in brackets, and put minus before
10:18:59 <fax> > sqrt(2)+sqrt(3)-sqrt(5)+sqrt(7)
10:19:00 <lambdabot>   3.5559477035067735
10:19:02 <fax> what
10:19:13 <pokoko222> oh no wait math chanel
10:19:21 <fax> what
10:19:30 <pokoko222> wrong chanel, that :D
10:19:38 <fax> pokoko
10:19:49 <fax> are you insane
10:19:59 <pokoko222> why
10:20:03 <uorygl> We really ought to decorate this channel so that people don't mistake it for other channels.
10:20:40 <uorygl> Let's change the background color and add an icon in the upper right.
10:20:41 <uorygl> :P
10:20:55 <mreh> what is Simon Moar's handle?
10:22:34 <mreh> gimme so moar, gimme some moar
10:22:38 <dankna> uorygl: that would be possible as a Jabber extension, but definitely isn't on IRC :)
10:22:45 <dankna> but I suspect you of being facetious anyway
10:23:29 <uorygl> Indeed.
10:23:42 <Mathnerd314> aren't there those color codes or whatever?
10:24:05 <opqdonut> oh these?
10:24:07 <dankna> yeah, but those are within the scope of an individual line
10:24:07 <benmachine> colour codes are solely for lamers
10:24:43 <opqdonut> dankna: well, with a little co-operation :)
10:24:54 <dankna> opq: haha, yeah, I suppose
10:26:03 <edwardk> benmachine: *sniff* i just spent a couple of hours adding pretty terminfo color coded diagnostics ;)
10:26:28 <benmachine> edwardk: no terminal colours are totally awesome cool, I wasonly talking about IRC colours
10:26:31 <edwardk> benmachine: or are you purely an IRC-color-code hater?
10:26:35 <EvanR-work> i cannot get the effect of listenOn manually, no matter what i do. with Network.Socket. i go through the usual steps, socket, bind, listen, and get no errors, but no server shows up
10:26:42 <EvanR-work> nothing can connect, netstat -l shows nothing
10:26:44 <edwardk> ah
10:31:23 <Veinor> @pl \x y z -> z
10:31:23 <lambdabot> const (const id)
10:31:30 <Veinor> @pl \x y z w -> w
10:31:30 <lambdabot> const (const (const id))
10:31:59 <Veinor> @pl \x y -> y
10:31:59 <lambdabot> const id
10:32:33 <Veinor> @check \x -> const id x y == const x y
10:32:34 <lambdabot>   No instance for (Test.QuickCheck.Arbitrary SimpleReflect.Expr)
10:32:34 <lambdabot>    arising f...
10:32:41 <Veinor> @check \x y -> const id x y == const x y
10:32:42 <lambdabot>   "OK, passed 500 tests."
10:33:41 <mercury^> That seems weird.
10:35:12 <mercury^> const id == flip const though
10:35:38 <mercury^> Never thought of that before.
10:35:47 <fax> @pl \x y -> (const id x y, flip const x y)
10:35:47 <lambdabot> ap (ap . ((,) .) . const id) (const id)
10:37:21 <benmachine> @check \x y -> x == y
10:37:22 <lambdabot>   "OK, passed 500 tests."
10:37:24 <benmachine> :)
10:37:33 <Veinor> @unpl const id
10:37:33 <lambdabot> (\ _ b -> b)
10:37:39 <Veinor> benmachine: wait what
10:37:46 <Veinor> @_@
10:38:04 <c_wraith> Veinor: it picked () for the polymorphic data type
10:38:06 <benmachine> Veinor: you have to be careful with @check that it doesn't break your types
10:38:10 <Veinor> @check (\x y -> x == y) :: Int -> Int -> Bool
10:38:10 <lambdabot>   Couldn't match expected type `GHC.Types.Int
10:38:12 <benmachine> break is the wrong word
10:38:14 <benmachine> fix too much?
10:38:25 <benmachine> @check \x y -> x == (y :: Integer)
10:38:26 <lambdabot>   "Falsifiable, after 0 tests:\n-1\n0\n"
10:38:48 <benmachine> @check \x y -> const id x y == const x (y :: Integer)
10:38:48 <lambdabot>   "Falsifiable, after 0 tests:\n0\n3\n"
10:39:00 <mercury^> That it *does* fix your types enough
10:39:05 <benmachine> @check \x y -> const id y x == const x (y :: Integer)
10:39:05 <lambdabot>   "OK, passed 500 tests."
10:39:17 <benmachine> mercury^: well, you don't want it to fix your types to ()
10:39:40 <mercury^> That happens when the type is arbitrary, i.e. unspecified.
10:40:00 <Veinor> what type will quickcheck use for \x y -> x + y == y + x
10:40:07 <c_wraith> Integer
10:40:07 <benmachine> probably Integer
10:40:24 <c_wraith> That's the fallback type for things in Num
10:40:40 <benmachine> well hold on
10:40:54 <benmachine> when we say "quickcheck" we mean "@check"
10:41:03 <c_wraith> I mean haskell, in general
10:41:18 <c_wraith> () is the type it defaults a polymorphic type to.
10:41:28 <mercury^> Hmm, interesting though. Should + ever be part of a not-necessarily commutative typeclass, quickcheck should not pick a commutative one.
10:41:35 <c_wraith> if there's a Num constraint, it defaults to Integer
10:41:55 <mercury^> In a way, one would need an Instance that is most general.
10:42:02 <mercury^> Which () is not for a.
10:42:28 <benmachine> c_wraith: only ghci defaults stuff to () I think
10:42:30 <mercury^> Is it even possible to always construct such an instance?
10:42:36 <c_wraith> oh, that's possible
10:43:03 <mercury^> Seems like a hard problem.
10:43:28 <benmachine> it's either impossible or not that hard imo
10:43:29 <c_wraith> what matters depends on what you're testing
10:43:33 <benmachine> yeah
10:43:42 <benmachine> hmm
10:43:55 <edwardk> mercury^: depends, if you make + an alias for mappend, then () is perfectly valid ;)
10:43:58 <benmachine> in some cases you are just going to want all of your inputs to compare unequal to each other and equal to themselves
10:44:20 <benmachine> Integer will usually cover that fine
10:44:21 <mercury^> edwardk: but it does not always yield the correct result
10:44:29 <benmachine> unless you have an uncountably infinite number of inputs?
10:44:39 <edwardk> mercury^: + as mappend?
10:44:40 <mercury^> For example, it is commutative.
10:44:40 <Saizan> i think there's a mailing list post about quickchecking polymorphic functions
10:44:48 <mercury^> edwardk: () is commutative.
10:44:55 <edwardk> mercury^: yes
10:45:07 <mercury^> Yes, so it does not fit the criterion.
10:45:25 <edwardk> there are lots of things that quickcheck for () that don't quickcheck for the full class of things that you substitued () as an implementation of
10:45:31 <mercury^> You want an instance such that for an arbitrary property, if the property holds for your instance, it holds for every instance.
10:45:50 <edwardk> ultimately you'd prefer that it selected the closest thing to a 'free instance' for each instance as possibe ;)
10:46:03 <edwardk> exactly
10:46:03 <mercury^> That's what I am saying.
10:46:13 <edwardk> we're agreeing with way too many words ;)
10:46:16 <benmachine> heh
10:46:19 <mercury^> The question was whether constructing such an instance is always possible.
10:46:30 <benmachine> can't you just use an enumeration of sorts?
10:46:37 <benmachine> or hmm
10:47:04 <benmachine> something a bit like Expr?
10:54:26 <siracusa> Can I tell darcs not to list the complete text when reverting changes?
10:56:52 <FliPPeh_> How do I use Foreign.Ptr to pass a function a pointer to a record I've made an instance of "Storable" for?
10:57:01 <FliPPeh_> int gettimeofday(struct timeval *tp, void *tzp);
10:57:05 <FliPPeh_> Is the C prototype
10:57:13 <FliPPeh_>  foreign import ccall "sys/time.h gettimeofday" c_time :: Ptr TimeVal -> Ptr a -> CInt
10:57:18 <FliPPeh_> Is my haskell import
10:57:22 <FliPPeh_> About correct, no?
10:58:13 <dankna> looks right to me
10:58:21 <FliPPeh_> Then how would I call the function?
10:58:43 <FliPPeh_> c_time (???) nullPtr
10:58:46 <dankna> I've never actually done it quite that way
10:58:55 <dankna> I believe you need to use alloca
10:59:01 <FliPPeh_> Ahh!
10:59:30 <dankna> alloca (\foo -> do { poke foo timeVal ; c_time foo nullPtr })
10:59:49 <dankna> something like that.  may have gotten the args to poke backwards.
11:00:01 <FliPPeh_> I have no implementation of poke :(
11:00:22 <FliPPeh_> Wait, I'll paste it
11:00:23 <FliPPeh_> @hpaste
11:00:24 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
11:01:10 <FliPPeh_> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=9092#a9092
11:01:38 <FliPPeh_> The storable interface isn't finished either
11:01:44 <FliPPeh_> I just want a quick test
11:01:55 <dankna> yeah, you definitely need to implement poke, sorry :)
11:02:11 <FliPPeh_> What's poke anyways? :/
11:02:20 <dankna> writes the value to the foreign heap
11:02:25 <dankna> opposite of peek
11:02:31 <FliPPeh_> "Write the given value to the given memory location. Alignment restrictions might apply"
11:02:38 <dankna> I infer that you are too young to remember BASIC, which is where the name comes from
11:02:59 <FliPPeh_> Well, I played around with basic, but nothing more :)
11:03:01 <dankna> ignore that second sentence, it's unclear what it means
11:03:02 <dankna> haha k :)
11:03:10 <c_wraith> man.  When you wrote BASIC code that actually *used* peek and poke, you were far exceeding the capabilities of the language. :)
11:03:16 <dankna> wraith: yes, hahaha
11:03:40 * hackagebot pqueue 1.0.0 - Reliable, persistent, fast priority queues.  http://hackage.haskell.org/package/pqueue-1.0.0 (LouisWasserman)
11:03:57 <FliPPeh_> How would a valid implementation of poke look like here?
11:04:04 <FliPPeh_> It's a really.. really simple structure
11:04:15 <dankna> well
11:04:23 <FliPPeh_> Basically reversing the peek, eh?
11:04:28 <dankna> yeah pretty much
11:04:35 <FliPPeh_> Just instead of peekByteOff -> pokeByteOff
11:04:46 <dankna> you'll probably be wanting castPtr to get the pointer to the value types
11:04:54 <dankna> (you'll probably want that in peek too)
11:06:58 <dankna> @src hGetContents
11:06:58 <lambdabot> Source not found. Are you on drugs?
11:07:21 <Mathnerd314> those quotes are cool...
11:07:39 <dankna> yes, haha
11:07:45 <dankna> lambdabot is fun
11:07:58 * Mathnerd314 looks through source
11:09:39 <FliPPeh_> dankna: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=9092#a9093 <- Like this?
11:10:09 <dankna> don't you need castPtr to make that work?
11:10:14 <dankna> or does it compile as-is?
11:10:21 <FliPPeh_> Well, it compiles well
11:10:25 <dankna> and of course you'll want to do the milliseconds too
11:10:33 <FliPPeh_>       (\ptr -> pokeByteOff ptr 0 s) p
11:10:33 <FliPPeh_>       (\ptr -> pokeByteOff ptr 4 us) p
11:10:42 <FliPPeh_> Can I just do it like this?
11:10:45 <dankna> yes.
11:10:50 <FliPPeh_> Niiiccceeeee.
11:11:08 <Mathnerd314> ah, "insult" in http://code.haskell.org/lambdabot/lambdabot-utils/Lambdabot/Util.hs
11:11:48 <FliPPeh_> :D
11:11:54 <Mathnerd314> they're from openbsd!
11:12:05 <c_wraith> woo.  attoparsec bug report
11:12:10 <c_wraith> is bos around?
11:12:32 <danderson> c_wraith: what did you break?
11:12:40 <FliPPeh_> dankna: I think it compiles well because inside the "user friendly" haskell record, I'm using the C type "CInt"
11:12:41 <c_wraith> nothing! it was my co-worker!
11:12:49 <dankna> oh, hm, that's possible
11:12:51 <c_wraith> the signed combinator is wrong. >_>
11:12:57 <danderson> (I'm not bos, I just use attoparsec and am curious)
11:13:24 <c_wraith> it has a precedence error in it that results in it reporting negative numbers as positive
11:13:48 <danderson> fun.
11:13:56 <danderson> Yeah, missed that, since I'm using it to parse binary protocols :)
11:14:39 <c_wraith> my co-worker might be the first person to actually use that combinator. :)
11:15:55 <EvanR-work> so yeah anyone have success with Network.Socket functions socket, bindSocket, and listen?
11:16:40 <dankna> EvanR: yeah I have, give me a sec to dig up an example
11:16:57 <dankna> I think so, at least
11:16:58 <EvanR-work> i copied the code for listenOn and it also didnt work for me, though listenOn does
11:17:10 <EvanR-work> frustrating
11:17:21 <EvanR-work> i get no errors, but no listening socket appears
11:17:27 <dankna> never mind - I didn't, I forgot
11:17:36 <dankna> hm.
11:17:39 <dankna> that IS frustrating.
11:17:49 <jmcarthur> different things in scope perhaps?
11:17:52 <FliPPeh_> Gahh
11:17:56 <FliPPeh_> That doesn't work
11:18:05 <EvanR-work> im trying to listen only on localhost, no external connections
11:18:09 <dankna> Flippeh: what happens exactly?
11:18:21 <FliPPeh_> Well, I'm trying to call the function now
11:18:22 <dankna> EvanR: certainly a reasonable thing to want
11:18:31 <FliPPeh_> main = alloca (\foo -> do poke foo (TimeVal { tvSec = 0, tvUSec = 0})  c_time foo nullPtr)
11:18:40 <FliPPeh_> Imagine some newlines in there
11:18:40 <EvanR-work> thanks, im glad you think so :)
11:19:03 <FliPPeh_> Couldn't match expected type `IO ()' against inferred type `CInt'
11:19:24 <jmcarthur> FliPPeh_: main =
11:19:31 <jmcarthur> FliPPeh_: main :: IO ()
11:19:36 <FliPPeh_> Yep, but it still won't do :/
11:19:42 <FliPPeh_> I added "print" in front of it
11:19:50 <jmcarthur> what is the type of c_time
11:19:52 <jmcarthur> ?
11:20:02 <dankna> oh!
11:20:02 <dankna> right
11:20:05 <FliPPeh_> c_time :: Ptr TimeVal -> Ptr a -> CInt
11:20:06 <dankna> you need to declare c_time
11:20:09 <dankna> as IO CInt
11:20:11 <dankna> not CInt
11:20:13 <FliPPeh_> ohhh
11:20:35 <dankna> (the other way is also supported, but means something else and probably should never be used)
11:21:20 <FliPPeh_> Okay, I'm getting a return value of 0
11:21:24 <FliPPeh_> Looks like success
11:22:03 <dankna> excellent
11:22:21 <FliPPeh_> Now "foo" will be my struct that the C function set?
11:22:58 <EvanR-work> dankna: so we can confirm that Network.Socket is broke?
11:23:06 <bos> c_wraith: it's fixed already in the bitbucket tree
11:23:06 <lambdabot> bos: You have 3 new messages. '/msg lambdabot @messages' to read them.
11:23:12 <dankna> EvanR: I don't think so, I'd need to see - in fact, go ahead and nopaste your code
11:23:19 <jmcarthur> Network.Socket has always worked for me
11:23:21 <c_wraith> bos: ah, cool.  thanks
11:23:31 <FliPPeh_> Putting a "return foo" after the c_time call gives me a result of 0x00007f89dba75620
11:23:33 <jmcarthur> but it's been a while. maybe something changed? either way i can't really help
11:23:33 <dankna> Flip: yep.  you need to peek to get the value back out of it.
11:23:43 <FliPPeh_> which is changing with every call
11:23:55 <dankna> yeah, you're looking at the pointer itself there
11:24:02 <FliPPeh_> sweet
11:24:14 <jmcarthur> wow it never even occurred to me that Ptr has a Show instance
11:24:19 <dankna> yeah
11:24:23 <FliPPeh_> AND WE'RE LANDED
11:24:24 <FliPPeh_> It works
11:24:28 <dankna> congrats
11:24:30 <FliPPeh_>  main
11:24:30 <FliPPeh_> TimeVal {tvSec = 1269973373, tvUSec = 0}
11:25:03 <jmcarthur> umm
11:25:06 <jmcarthur> should usec be 0?
11:25:15 <FliPPeh_> I think so
11:25:28 <FliPPeh_> I'll do a quick C check
11:25:46 * hackagebot attoparsec 0.8.0.2 - Fast combinator parsing for bytestrings  http://hackage.haskell.org/package/attoparsec-0.8.0.2 (BryanOSullivan)
11:26:30 <jmcarthur> i really like the ffi
11:26:50 <jmcarthur> i realize that it can get hairy, but when has any ffi not been hairy sometimes?
11:27:25 <jmcarthur> haskell's just works really nicely. nice to not have to drop to C and be able to use some of haskell's abstractions to manage what is essentially C code
11:27:32 <FliPPeh_> Nah, it's not normal
11:27:39 <c_wraith> bos: have a bugfix release in your plans anywhere?
11:27:59 <bos> c_wraith: look in scrollback, up about 10 lines
11:28:20 <c_wraith> oh.  hah.  man, I need to pay attention to hackagebot lines
11:28:44 <EvanR-work> dankna: http://pastebin.com/k0sCxB2M
11:28:47 <c_wraith> thanks again
11:28:58 <EvanR-work> that code is almost exactly like the published code for listenOn
11:29:15 <EvanR-work> but doesnt work, much less work if i change it to not listen on iNADDR_ANY
11:29:26 <dankna> EvanR: indulge me and put a type signature on main.
11:29:38 <EvanR-work> ok
11:29:56 <EvanR-work> http://pastebin.com/ab87X9uV
11:30:15 <dankna> same result, I take it?
11:30:21 <danderson> bos: remember that code review I was asking for with the binary integer parsers? Forget about it (if you haven't already :) ), after more hacking I have an intuition of why it's not good. I'll just look for your implementation when you get to it and gain wisdom from that.
11:30:38 <benmachine> :t forever
11:30:39 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
11:30:45 <EvanR-work> dankna: yes, just checked
11:31:18 <bos> danderson: cheers
11:31:31 <dankna> what's your ghc version?
11:31:33 <dankna> and platform?
11:31:45 <EvanR-work> The Glorious Glasgow Haskell Compilation System, version 6.12.1
11:31:50 <EvanR-work> arch linux
11:32:38 <dankna> @hoogle listenOn
11:32:39 <lambdabot> Network listenOn :: PortID -> IO Socket
11:33:18 <EvanR-work> i can paste the code for a equivalent program that uses listenOn, which works
11:33:52 <dankna> feel free
11:34:14 <FliPPeh_> dankna: Figured it out, a long is 8 bytes here, so the total size is 16 bytes, not 8 like I thought first
11:34:43 <dankna> Flip: ah - okay, yeah, I sorta suspected that might be an issue.  it's why c2hs is nice (but hard to get started with), it can detect that situation for you automatically.
11:35:02 <FliPPeh_> TimeVal {tvSec = 1269974013, tvUSec = 469510}
11:35:05 <FliPPeh_> :)
11:35:06 <dankna> good :)
11:35:12 <dankna> that certainly looks like a valid time :)
11:35:13 <FliPPeh_> Thanks a lot on this one
11:35:16 <dankna> np
11:35:21 <FliPPeh_> I can build up from this
11:35:24 <dankna> good
11:35:31 <FliPPeh_> Interfacing with structs was the hardest thing to get
11:35:38 <EvanR-work> dankna: http://pastebin.com/ptwyF17H
11:35:44 <EvanR-work> dankna: maybe its linker flags?
11:35:52 <EvanR-work> i just built with --make
11:36:09 <dankna> EvanR: hmm... give me the output of ghc-pkg info network
11:36:27 <EvanR-work> Usage:
11:36:30 <EvanR-work> ...
11:36:31 <dankna> haha
11:36:32 <dankna> oops
11:36:54 <dankna> cabal info network, rather
11:36:57 <EvanR-work> dankna: i mean, do either of those work for you?
11:37:02 <dankna> oh, well, I can find out
11:37:18 <EvanR-work> http://pastebin.com/ymdPUagJ
11:37:37 <dankna> that's the latest version, darn
11:37:48 <jmcarthur> FliPPeh_: btw, if you use sizeOf to compute offsets you will be a happier person
11:38:04 <FliPPeh_>  instance Storable TimeVal where
11:38:05 <FliPPeh_>     sizeOf    _ = 16
11:38:11 <FliPPeh_> ;o
11:38:18 <jmcarthur> FliPPeh_: i mean your peek and poke stuff
11:38:22 <FliPPeh_> oh
11:38:46 <jmcarthur> FliPPeh_: also to compute your sizeOf though
11:39:03 <FliPPeh_> Mhh
11:39:07 <FliPPeh_> Could you give me an example?
11:39:21 <jmcarthur> what is your current code for peek?
11:39:23 <dankna> EvanR: well it doesn't work for me either - hmmmmm
11:39:27 <FliPPeh_> Wait
11:39:28 <FliPPeh_> @hpaste
11:39:29 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
11:39:36 <benmachine> is Haskell as defined in the Report required to be lazy, or just non-strict?
11:39:41 <EvanR-work> dankna: thats sort of reassuring, and sort of dreadful
11:39:42 <dankna> EvanR: I've had good luck with the network-bytestring package
11:39:43 <jmcarthur> benmachine: nonstrict
11:39:55 <benmachine> jmcarthur: oh right, thanks
11:40:08 <dankna> EvanR: but hm it doesn't actually create sockets, it relies on network to do that
11:40:09 <FliPPeh_> jmcarthur: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=9097#a9097
11:40:17 <EvanR-work> right
11:40:24 <EvanR-work> it only overrides sendTo, recvFrom, etc
11:40:29 <jmcarthur> benmachine: it's how we can get away with weird things like pure parallelism ;)
11:40:41 <benmachine> heh, okay
11:40:47 <benmachine> I suppose that makes sense yeah
11:41:18 <dankna> but the thing is if network is broken then I should be able to see the bug :(
11:41:21 <jmcarthur> FliPPeh_: sizeOf _ = sizeOf (undefined :: CLong) * 2  -- for example
11:41:26 <dankna> it's quite a short bit of code
11:42:01 <jmcarthur> FliPPeh_: and:  us <- peekByteOff p (sizeOf (undefined :: CLong))
11:42:01 <EvanR-work> dankna: the only explanation is that listenOn does not use the published code, because that code doesnt work
11:42:05 <jmcarthur> FliPPeh_: and so on
11:42:10 <dankna> but it does use the published code
11:42:16 <dankna> hmm
11:42:17 <EvanR-work> then ... gah
11:42:19 <dankna> it's using the ipv6 version
11:42:22 <dankna> see that ifdef?
11:42:47 <dankna> http://hackage.haskell.org/packages/archive/network/2.2.1.7/doc/html/src/Network.html#listen' is the implementation
11:43:01 <mauke> FliPPeh_: I have no context but that Storable instance looks terrible
11:43:17 <FliPPeh_> mauke: :(
11:43:44 * mauke starts his editor
11:44:02 <jmcarthur> yay
11:44:23 <EvanR-work> dankna: -- IPv6 and IPv4. ok i didnt look at these. .... listen'
11:44:29 <byorgey> gentlemen, start your editors
11:44:38 * jmcarthur revs his emacs
11:45:08 <EvanR-work> dankna: it uses getAddrInfo... sounds good to me...
11:45:15 <byorgey> vim viiim vIIIImmmm
11:45:21 <dankna> EvanR: I'm working on my own attempt at this now, but see what you can do as well
11:45:24 <EvanR-work> ok
11:45:30 <dankna> haha, vim as engine noise
11:45:34 * byorgey uses emacs too but couldn't resist that pun
11:45:55 <FliPPeh_> Oh, I just notice
11:46:06 <FliPPeh_> I replaced the record fields with Ints, and I fill in CLongs
11:46:19 <jmcarthur> heh, vim is automatopia now
11:46:21 <FliPPeh_> In this case it will work, but how do I use castPtr to make it foolproof?
11:46:32 <mauke> did you mean: onomatopoeia
11:46:41 <jmcarthur> indeed
11:46:48 <mauke> FliPPeh_: please stop now before someone gets hurt
11:46:55 <mauke> castPtr? wtf
11:47:00 <dankna> castPtr is, er, necessary here
11:47:00 <jmcarthur> i wasn't sure how to spell it and google gave me a crap correction
11:47:04 <FliPPeh_> I said it once and I'll say it again
11:47:07 <FliPPeh_> mauke: :(
11:47:15 <byorgey> oh, I thought you were making yet nother pun =)
11:47:20 <jmcarthur> yeah use the correct types at least
11:47:22 <dankna> and I'm the one who put the idea in his head, so blame me :)
11:48:04 <jmcarthur> man, onomatopoeia is a horrible word
11:48:11 <jmcarthur> at least as far as spelling
11:48:12 <byorgey> AUTOmatopoeia, heh
11:48:21 <benmachine> horrible/wonderful
11:48:21 <jmcarthur> byorgey: ;)
11:48:25 <benmachine> depending on your perspective
11:48:31 <deech> Hi all, I am a Haskell programmer looking to learn C++ - I know Java and Smalltalk so I'm comfortable with OO. Are there any tutorials available this?
11:48:34 * benmachine has a fondness for words which don't want to be spelt correctly
11:49:03 <byorgey> deech: you mean, C++ tutorials for Haskell programmers??
11:49:06 <XniX23> deech i dont think it should be hard to pick up java
11:49:11 <deech> byorgey: yup
11:49:19 <XniX23> woops
11:49:25 <jmcarthur> deech: learn C and then try to haphazardly tack on OO features under the impossible constraint of keeping with C speeds and low level capabilities. now you know c++
11:49:30 <byorgey> if only.
11:49:41 <Taejo> deech: I know there are C++-for-Java-programmers tutorial
11:49:59 <Taejo> but that'll just get you started
11:50:03 <Taejo> C++ is *complex*
11:50:04 <maltem> C++ has some funny ideas about OO that Java and Smalltalk don't have
11:50:04 <deech> I'm just trying to move into greener salary pastures
11:50:24 <deech> Taejo: more complex than learning Haskell?
11:50:29 <arw_> jmcarthur: the limitations of c are not what makes c++ evil. its more the 'nice addons' like the stupid template system and the reference/pointer difference.
11:50:53 <benmachine> references scare me
11:50:54 <deech> Taejo: Haskell kicked(and continues to kick) my ass.
11:50:56 <jmcarthur> arw_: those addons are only designed as they are due to those constraints though
11:51:03 <uorygl> Well, pointers scare me.  So there.
11:51:05 <benmachine> there seem a lot of ways in C++ of making the same code do different things
11:51:21 <dankna> EvanR: got it working, one sec
11:51:22 <benmachine> Taejo: haskell is complex, C++ is complicated
11:51:23 <jmcarthur> i think c++ is harder than haskell
11:51:34 <benmachine> there is a difference (although I might have got it the wrong way round >_>)
11:51:39 <dankna> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24527#a24527
11:51:45 <pippijn> benmachine: C++ is convoluted
11:51:47 <pippijn> :)
11:51:52 <benmachine> that too
11:52:04 <deech> So can I leverage my Haskell experience in any way?
11:52:04 <jmcarthur> C++ is convulsed
11:52:05 <XniX23> c++ also supports multiple inheritance if im not mistaken, a new way to write bugs
11:52:09 <EvanR-work> dankna: i was in the process of typing that in
11:52:12 <dankna> haha okay
11:52:15 <EvanR-work> dankna: finished, but didnt compile ;)
11:52:18 <dankna> nod :)
11:52:19 <pippijn> I like C++
11:52:27 <dankna> needs Control.Exception for bracketOnError
11:52:28 <EvanR-work> dankna: well shit. why didnt the old way work?
11:52:38 <pippijn> you can do so much wrong, it's nice when things actually work
11:52:41 <dankna> I'd like to know that too
11:52:41 <Taejo> benmachine: indeed there is a difference. I meant what I said. C++ is complex: it is made up of many interacting features
11:52:49 <Taejo> it's *also* complicated
11:53:23 <dankna> EvanR: notice by the way that I modified the hints parameter to only look for IPV4 interfaces
11:53:30 <benmachine> Taejo: oh, fine :)
11:53:37 <EvanR-work> dankna: probably not an issue
11:53:47 <dankna> right, I figured.
11:53:47 <EvanR-work> if PHP tries to use ipv6, for some reason
11:53:57 <deech> So the consensus is no?
11:53:59 * hackagebot pqueue 1.0.1 - Reliable, persistent, fast priority queues.  http://hackage.haskell.org/package/pqueue-1.0.1 (LouisWasserman)
11:54:09 <dankna> well, you're only listening on one interface (you'd need two sockets to listen on both)
11:54:14 <dankna> so it should be the ipv4 interface
11:54:22 <EvanR-work> dankna: heh. yeah. on windows XP and netBSD
11:54:36 <EvanR-work> in my opinion the listening socket that can accept both makes more sense
11:54:45 <EvanR-work> those two OS dont allow it though, so portability means use two
11:54:46 <dankna> but there's no such socket
11:54:51 <mauke> FliPPeh_: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24528#a24528
11:54:56 <EvanR-work> it works in linux to accept from both at once
11:55:00 <dankna> oh, interesting
11:55:05 <dankna> but I imagine Lin is the only place that works
11:55:14 <dankna> say rather that Lin extends posix sockets nonportably :)
11:55:22 <EvanR-work> no, its disabled by default in netBSD and basically impossible in windows xp, thats it
11:55:27 <dankna> hm.
11:55:34 <dankna> well, it sounds like you've looked into it more recently than I have, so okay
11:55:44 <EvanR-work> i might be wrong, because that was a few years ago
11:55:46 <mauke> FliPPeh_: wait, that's not quite right
11:55:51 <EvanR-work> the state of ipv6 seems sorry
11:56:03 <dankna> I don't think the posix calls even support a way to do that to BE disabled, is the thing
11:56:06 <mauke> FliPPeh_: remove the CPP extension
11:56:13 <dankna> you'd need some sort of listenOnMultiple call
11:56:30 <EvanR-work> its probably a kernel config option in netbsd, no, no posix
11:57:04 <dankna> I mean, it's not that hard to do it the two-sockets way, when ipv6 becomes popular (if ever)
11:57:15 <EvanR-work> i found it difficult to set it up in C ;)
11:57:21 <dankna> heh, okay :)
11:57:38 <dankna> well, I'm not volunteering to do it, so I'll cease claiming it's easy :)
11:57:45 <EvanR-work> and the api is mildly atrocious in Network.Socket, but i guess cant be avoided. still much better than C
11:57:50 * dankna nods
12:00:21 <EvanR-work> now to make it local...
12:03:46 <EvanR-work> WORKS
12:03:49 <EvanR-work> dankna: you are amazing
12:04:11 <dankna> EvanR: thanks :D
12:05:06 <danderson> terminology question: does haskell's use of monadic IO implement effect types?
12:05:24 <dankna> I don't know what effect types are, so.
12:05:34 <danderson> from the term itself, it seems so (the side-effects are encoded into the function type), but the google is rather reluctant to provide an actual definition of effect types
12:06:12 <EvanR-work> i think the executor plus IO is the only way to do effects
12:06:21 <EvanR-work> so its not like, general support for effect types
12:06:32 <jlouis> danderson: for some ways of doing effect types yes
12:06:33 <danderson> http://lambda-the-ultimate.org/node/2924 suggests that ML and Cyclone have effect types, but I don't know either of those.
12:07:09 <danderson> EvanR-work: what would general support look like? Different types for different kinds of side-effects?
12:07:55 <EvanR-work> danderson: i guess?
12:07:55 <jlouis> danderson: yes, and perhaps even stackable in an effect hierachy which is subtyped
12:08:11 <danderson> jlouis: I see. Thanks!
12:08:15 <EvanR-work> craziness ;)
12:08:57 <jlouis> any reduction is annotated with an effect, which can be epsilon, sitting at the bottom of the effect heirarchy
12:09:48 <jlouis> Then you have to define some rules which lets you use a epsilon-effect-operation in a reduction with, say, a state effect
12:10:04 <jlouis> obeying the subtyping hiearchy of course
12:10:26 <jlouis> Filinskis recent ICFP paper "Monads in Action" has an example
12:10:29 <humasect> now that i am spoiled with haskell, there must be a way to use it as a meta language on top of regular ones .. like C, objective-C, etc? have many people been doing this?
12:10:32 <stepcut> if I have, type Dungeon = Map Pos [Object], then it is easy to check for collisions at a specic location, or to draw the whole map. But it is hard to move a specific object, because there is no easy way to get the specific object.. if I do, map Object Pos, then it is easy to figure out where an object is, but hard to figure out what is nearby.. Is there some clever type that is better than just maintaining two Maps?
12:10:51 <stepcut> humasect: I just write Haskell and forget about the meta part
12:10:56 <humasect> heheh
12:11:04 <jlouis> humasect: atom package on hackage :)
12:11:11 * humasect looks
12:11:23 <jlouis> humasect: for embedded stuff, basically
12:11:28 <humasect> ohh interesting !
12:11:42 <humasect> this is for iphone, and objective-c though i used to love it the most, is a LOT of work in comparison!
12:12:04 * stepcut thinks bimap might do the trick..
12:12:27 <humasect> it is not natural or healthy for a human mind or body to de-evolve
12:12:34 <stepcut> except I might have one-to-many maps :(
12:12:56 <EvanR-work> stepcut: that model seems funny if you upgrade Pos to be R^2 or something ;)
12:13:44 <stepcut> EvanR-work: I won't be. But maybe the R^2 solution is good for N^2 too
12:13:57 <EvanR-work> maybe
12:14:06 <jlouis> stepcut: this is totally overkill, but something like a BSP-tree and a zipper?
12:14:21 <stepcut> jlouis: hmm
12:14:51 <jlouis> zip when moving stuff around
12:15:04 <jmcarthur> humasect: there is a patched version of ghc out there for iphone development i think
12:15:31 <jlouis> stepcut: the problem is that your tree must somehow relate to the geography of your world for that to be effective I think
12:15:49 <jmcarthur> humasect: http://projects.haskell.org/ghc-iphone/
12:15:55 <humasect> hmm ... jhc too has iphone support but had trouble with the repo, i will will investigate a bit more and check the ghc wiki
12:15:57 <humasect> ah thank you
12:16:06 <stepcut> jlouis: yeah
12:16:06 <jlouis> stepcut: http://en.wikibooks.org/wiki/Haskell/Zippers is a good introduction if you need some ideas on what zippers are
12:17:13 <stepcut> jlouis: I know what zippers are.. but not really clear they are going to help here
12:18:08 <jlouis> stepcut: Go with a map where the dissection of the map reveals the position of an object
12:18:33 <jlouis> I would look at BSP I think, but I don't really have a good idea
12:19:03 <humasect> why not do the other way around ? instead of writing the data from the perspective of global, write it from the perspective of the player or view. haskell is *good* at this !
12:19:16 <humasect> then it will never need to "look up" data
12:19:26 <gwern> humasect: jhc has issues with garbage collection and libraries
12:19:28 <stepcut> humasect: ?
12:19:33 <jmcarthur> humasect: because things can change elsewhere in the dungeon too?
12:19:36 <gwern> I wouldn't want to use jhc for anything serious
12:19:58 <humasect> jmcarthur: sure, that is also from the view of the player (its how im doing it, almost no calculations required)
12:20:12 <stepcut> humasect: but what if I have multiple players?
12:20:18 <humasect> gwern: ahh i see .. i have never touched it before =) it is experimental ?
12:20:26 <humasect> stepcut: then the view is between them both
12:20:37 <humasect> or all of them (like a trunk with branches.)
12:20:42 <jmcarthur> humasect: what data structure would you recommend?
12:20:42 <stepcut> humasect: yes..
12:20:52 <gwern> humasect: experimental is not a bad adjective for jhc
12:20:55 <humasect> nothing fancy, just data =
12:20:58 <ickabob> defining >>= as (>>=) :: blah blah blah, defines it as infix correct?
12:21:07 <gwern> ickabob: no
12:21:10 <ickabob> darn
12:21:16 <humasect> gwern: true,  also i hear it is fast and something about bytecode (a little how ocaml is able to cross compile too)
12:21:16 <kpreid> it just is.
12:21:26 <gwern> ickabob: you need something like 'infixr 9 (>>=)'
12:21:29 <humasect> kpreid =)
12:21:31 <jmcarthur> humasect: are you sure you know what you're talking about? :)
12:21:40 <humasect> in the beginning i had thought that jhc was for JIT/jvm
12:21:43 <gwern> humasect: jhc compiles down to C
12:21:44 <stepcut> humasect: um..
12:21:51 <gwern> humasect: nothing about bytecode. maybe you are thinking of yhc
12:21:54 <kpreid> ickabob: >>= is an infix operator by definition because it is made of punctuation.
12:21:58 <humasect> jmcarthur: hehe that is up to you to see, perhaps .. i can only suggest from exp
12:22:05 <gwern> kpreid: oh really?
12:22:10 <humasect> gwern: ah, that must be so =)
12:22:16 * stepcut does this the non-clever way
12:22:17 <kpreid> ickabob: (>>=) is just how you refer to that thing as an expression by itself
12:22:46 <kpreid> gwern: ...last I knew, infixl/infixr only change the precedence and associativity.
12:23:05 <jmcarthur> humasect: stepcut needs three operations: efficient collision checking for each object, efficient map drawing, and efficient object location lookup... right stepcut?
12:23:21 <humasect> yep
12:23:40 <jmcarthur> humasect: how does "from the viewpoint of the player" help at all?
12:23:54 <stepcut> jmcarthur: yes.. the last one being, 'I have an object's id and the direction I want to move it. Now I need to do the move.'
12:24:03 <humasect> it depends how many people i am supposed to explain to
12:24:15 <humasect> i am not so good at doing =(
12:25:03 <jmcarthur> stepcut: i would just keep two mappings, maybe make a new type that keeps them in sync for me
12:25:09 <humasect> haskell is very efficient with real time stuff, software can be designed in such a way to take advantage of laziness and garbage collection as "free" computation, just about entirely
12:25:17 <stepcut> jmcarthur: yeah, that is what I am doing
12:25:29 <jmcarthur> humasect: it's not free. it's just in a different time and place
12:25:57 <stepcut> jmcarthur: just a bit annoying to have to update the position in two places
12:26:10 <humasect> yeah.
12:26:18 <humasect> u can feel what is right and what is not
12:26:30 <humasect> keep playing with it and tweaking until its perfect ..
12:26:35 <humasect> then u will see what it ends up as =)
12:26:41 <jmcarthur> stepcut: there are fancier ways i'm sure, but i think it will all boil down to multiple updates, even if in the same data structure
12:26:42 <stepcut> I think a kdmap might be what I need, but I don't have time for that
12:26:43 <humasect> perhaps this is all i can say
12:27:38 <stepcut> jmcarthur: i think if I had a balanced binary tree where the sort key alternates between position and object every other node, then I would be cool..
12:29:08 <EvanR-work> about the cost of laziness and garbage collection, ive heard/read that gc can be more efficient than old malloc, but that laziness has some sort of unavoidable overhead... not sure how true these are
12:29:12 <EvanR-work> these days
12:29:30 <humasect> yeah =) i love GC and also spoiled with it too
12:29:41 <FliPPeh_> Why does hsc2hs turn those #include lines to "{-# INCLUDE"'s? GHC will just complain about them anyways
12:29:58 <humasect> laziness, i think can be mostly overcome without any hacking that would make ugly code
12:30:08 <jmcarthur> EvanR-work: both can be used or abused in many ways. i think they overall make things easier, but you have to learn what to avoid regardless
12:30:14 <pikhq> EvanR-work: Laziness doesn't have "unavoidable overhead", it just has drastically different performance characteristics.
12:30:44 <humasect> it is best not to just "write code" and have GC and laziness in the background. but that comes with experience to have a feeling/intuition of exactly what will happen that is not visible in one's code.
12:30:52 <benmachine> laziness I think does have unavoidable overhead, but laziness is avoidable :P
12:30:56 <jmcarthur> gc can be faster sometimes. laziness doesn't really change the overall performance if you are using it properly, at least not inherently
12:31:04 <benmachine> due to strictness analysis &c.
12:31:11 <pikhq> That said, there are many cases *where* laziness will cause overhead, and there's nothing you can do about it.
12:31:12 <jmcarthur> right, among other things
12:31:28 <humasect> those cases can be avoided altogether (or the penalty doesnt matter with them.)
12:31:29 <pikhq> Of course, in those cases, you can just make it strict.
12:31:30 <jmcarthur> well, then you dont' use laziness
12:31:34 <humasect> yea..
12:32:10 <jmcarthur> really, it just different, not better or worse. i like it as a default, but that's personal preference
12:32:35 <jmcarthur> i think gc is far more game changing
12:33:38 <opqdonut> how about laziness with manual memory management?
12:33:56 <jmcarthur> o_O
12:34:06 <jmcarthur> i would be frightened
12:34:30 <humasect> heheh
12:35:10 <humasect> i have never had a problem with haskell performance with real time stuff and this computer is 3years old maybe 4
12:35:24 <humasect> or losing memory or any bugs really at all
12:35:36 <humasect> it just works perfectly as long as i am conscious and know what i am doing hehe
12:36:16 <pikhq> opqdonut: It is technically possible if you insist upon it in C. I *strongly* recommend against it. I mean, really, truly, NO.
12:36:30 <humasect> the only problems i have ever had with haskell, at all of any granularity is : 1) wanting to use it for strange stuff like Cocoa or iphone, and 2) getting ghci to work with editing code while it runs with a running opengl context (fixed)
12:36:42 <pikhq> (obviously, to do this you will manually implement closures)
12:39:29 <opqdonut> yeah
12:42:43 <humasect> oh how wonderful--- 'iphone-cabal update'  works and the native mac one does not (Bus error). hehe
12:47:54 <EvanR-work> haskell success story... we need an email throttler to tell exchange to send emails slowly as stored in a database. we threw together a smtp/mysql/socket haskell program with what seems like high reliability in about 3 days
12:48:47 <EvanR-work> smtp-auth not supported yet, dont know about that
12:49:00 <EvanR-work> resistant to screwed up databases and php scripts
12:49:39 <gwern> EvanR-work: that doesn't sound like a success story. that sounds like a fail compared to throwing together a shell or cron script in a minute or two
12:50:01 <jlouis> all effective programs have perl-gaffa in some place
12:50:07 <EvanR-work> theres a lot of jobs with per domain throttling
12:50:22 <EvanR-work> multiple domains per job
12:50:41 <EvanR-work> but i still think this sort of thing should already be built into exchange or something
12:51:07 <arw_> well, there are mailservers other than exchange.
12:51:17 <EvanR-work> not for us!
12:51:22 <arw_> you could put one as a cache in between and throttle there...
12:51:36 <EvanR-work> might take more than 3 days to get that working
12:51:41 <EvanR-work> :\
12:51:56 <arw_> more like less than three hours, if you need to read up on the docs...
12:52:22 <EvanR-work> to be so awesome, thats a success story
12:52:58 <Twey> Silly question: what's the preferred way to make a thread sleep forever?
12:53:10 <EvanR-work> arw_: cron is not very granular
12:53:12 <sajkr> @pl \xs -> sqrt . sum . fmap (\x -> (^2) $ x - sum xs / fromIntegral (length xs)) $ xs
12:53:13 <lambdabot> ((sqrt . sum) .) =<< fmap . ((^ 2) .) . subtract . liftM2 (/) sum (fromIntegral . length)
12:53:34 <gwern> Twey: an 'undefined' to the head
12:53:58 <arw_> EvanR-work: i thought more about something like this: http://www.postfix.org/rate.html
12:54:22 <Twey> Haha
12:54:38 <gwern> Twey: dumb solution: 'threadDelay maxBound'
12:54:45 <Twey> Ew :
12:55:04 <Twey> I prefer my current let loop = loop :: String in print loop
12:55:12 <Twey> At least it doesn't give up and let go
12:55:27 <Twey> I tried forever $ return (), but it started eating my CPU
12:56:02 <arw_> EvanR-work: but i agree, getting something done is a very satisfying experience.
12:56:25 <gwern> Twey: I would suggest you're doing something wrong, but no doubt you're already thought that through
12:56:36 <arw_> EvanR-work: especially when there is a huge gradient between the "before" and "after"
12:56:38 <gwern> Twey: but what's bad about threadDelay?
12:57:41 <dankna> let loop = do { threadDelay maxBound ; loop }
12:57:48 <Twey> gwern: Yep the library I'm using creates a thread behind the scenes, to which I have no access, and I want my main thread to wait and basically do nothing so it can do its stuff
12:58:09 <gwern> dankna: maxBound is pretty darn big
12:58:12 <benmachine> take an empty MVar?
12:58:14 <dankna> can't your main thread just exit?
12:58:19 <Twey> gwern: It takes an Int, so it's got a bound  after about twenty minutes (IIRC) it gives up and lets go
12:58:30 <gwern> dankna: no, when the mainthread exits, all threads exit
12:58:33 <dankna> gwern: yes, but my snippet addresses the only drawback to that solution that I can see
12:58:38 <dankna> oh.  whose idea was that? :)
12:58:40 <Twey> dankna: That works, but I might as well just use my infinite loop, I think
12:58:44 <gwern>  /are killed
12:58:50 <dankna> Twey: if it's not churning cpu, by all means
12:59:01 <gwern> dankna: I think the idea is to prevent zombie processes. 'i exited, why isn't it gone?'
12:59:12 <dankna> mm.  I wonder if it's controllable.
12:59:37 <gwern> > 2147483647 / 1000
12:59:38 <lambdabot>   2147483.647
13:00:10 <Twey> dankna: It doesn't the forever one did
13:00:17 <dankna> > (maxBound :: Int) / (1000 * 60 * 60 * 24)
13:00:18 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
13:00:18 <lambdabot>    arising from a use o...
13:00:28 <dankna> > (fromIntegral (maxBound :: Int)) / (1000 * 60 * 60 * 24)
13:00:30 <lambdabot>   1.0675199116730064e11
13:00:32 <XniX23> [ sqrt(x) | x <- [1..100], x `mod` 5 == 0 ]
13:00:35 <dankna> that's only 1e11 days
13:00:59 <XniX23> why this wont work, i dont understand the compile error
13:01:05 <MisterN> dankna: you mean 1e14?
13:01:09 <MisterN> or wait
13:01:10 <MisterN> lol
13:01:24 <dankna> MisterN: no, I mean 1e11 :)  but the "only" was a joke
13:01:39 <MisterN> dankna: 1e11 days is not so much :)
13:02:04 <dankna> will Haskell still be in use in 1e11 days?  discuss :)
13:02:13 <gwern> heck, my desktop's uptime is more than 1e11 days
13:02:23 <gwern> clearly not useful for corporate purposes
13:02:28 <dankna> haha
13:03:02 <opqdonut> yeah, 1e11 is only 7697 after all
13:03:23 <dankna> ho-ehhh?
13:03:33 <dankna> (strange sound denotes confusion)
13:03:40 <opqdonut> think about it
13:04:02 <dankna> does it have something to do with turning it upside-down or something?
13:04:09 <c_wraith> be more computery :)
13:04:17 <dankna> oh, binary?  ha
13:04:22 <c_wraith> no, hex
13:04:26 <c_wraith> :P
13:04:33 <dankna> sigh, I should have gotten that :)
13:04:42 <fax> > showHex 11
13:04:43 <lambdabot>   ""->
13:04:43 <lambdabot>    "b"
13:04:44 <lambdabot>  "a"->
13:04:44 <lambdabot>    "ba"
13:04:44 <lambdabot>  "aa"->
13:04:45 <lambdabot> [5 @more lines]
13:04:53 <dankna> > showHex 11 ""
13:04:54 <lambdabot>   "b"
13:04:58 <dankna> that's how you do that
13:05:04 <fax> > 0x1
13:05:05 <fax> > 0x11
13:05:05 <lambdabot>   1
13:05:06 <lambdabot>   17
13:05:06 <dankna> oh, you're fax, you knew that
13:05:16 <opqdonut> 0x1e11
13:05:20 <opqdonut> oops
13:05:25 <opqdonut> > 0x1e11
13:05:26 <lambdabot>   7697
13:05:26 <fax> > showHex (2 ^ 17) ""
13:05:27 <lambdabot>   "20000"
13:05:33 <fax> O_O
13:05:43 <fax> > 0x1e0x11
13:05:44 <lambdabot>   Not in scope: `x11'
13:06:01 <opqdonut> there's a reason for not supporting scientific notation for hex numbers :)
13:06:10 <pikhq> opqdonut: Hahah.
13:06:16 <dankna> I am amused
13:06:23 <fax> hexadecimal is unscientific
13:06:34 <opqdonut> some language had a syntax for float literals in hex
13:06:42 <opqdonut> mantissa and exponent separately or so
13:06:59 * Mathnerd314 checks docs
13:07:09 <arw_> fortran i guess...
13:07:11 <Mathnerd314> threadDelay take microseconds, not milliseconds
13:07:12 <humasect> gcc
13:07:28 <monochrom> Yeah, not even milliseconds.
13:08:00 <dankna> > (fromIntegral (maxBound :: Int)) / (1000000 * 60 * 60 * 24 * 365.26125)
13:08:01 <gwern> 'When I was an early teenager I picked up a book on CT at the local university library, after reading about 2 pages in and thinking: "Gee, if CT generalizes all these other theories, starting with it will make a great shortcut!" (like I said, a teenager ...). Anyway, when I got it home my dad, an applied mathematician, asked to see what book I had taken out. When he saw that it was CT, his reaction was probably worse than if it had been Playboy or ...
13:08:01 <lambdabot>   292262.0211350113
13:08:06 <monochrom> I wrote my own loop over threadDelay to sleep longer.
13:08:07 <gwern> ... Penthouse. My memory tells me that I first heard the classic "abstract nonsense" epithet as he then read me the riot act, but I imagine that aspect is a later reconstruction.'
13:09:04 <pikhq> gwern: ABSTRACT. EVERYTHING. BWAHAHAH.
13:09:36 <lament> "so I punched him"
13:10:10 <zygoloid> "and that's how category theory got me sent to prison"
13:12:10 <danderson> monochrom: package concurrent-extra has Control.Concurrent.Thread.Delay.delay, which is threadDelay with an Integer
13:12:30 <danderson> but yeah, it's pretty much doing the same thing.
13:13:42 <mightybyte> Is there a way to construct arbitrary values of a type specified by a string...something like fromDynamic except with a type signature of :: Typeable a => String -> Maybe a?
13:14:14 <kmc> a dynamic read, then?
13:14:19 <mightybyte> Yeah
13:14:25 <Cale> What?
13:14:27 <kmc> madness
13:14:32 <mightybyte> Except the String specifies the type, not the value.
13:14:32 <dankna> Data.Data might have it?
13:14:34 <kmc> oh
13:14:37 <kmc> then what's the value?
13:14:37 <Cale> I don't understand why you'd want that
13:15:24 <mightybyte> Well, it could be a value specified by function of a type class...i.e. class Default a where default :: a
13:16:06 <Cale> What's wrong with just using (Default a) => a then?
13:16:26 <mightybyte> Cale: I can, but I don't know how to do the dynamic part.
13:16:31 <dankna> you can't actually use your fromTypeName function without knowing the type of a
13:16:37 <byorgey> gwern: where's that quote from?
13:16:49 * Cale is more accustomed to the mindset that types don't exist at runtime
13:18:01 <mightybyte> I guess I could just create separate "witness" types, stuff them in a hash table, and look them up.
13:18:12 <Cale> What are you trying to accomplish?
13:18:20 <mightybyte> That's complicated.
13:18:39 <dankna> yes, but at this point I think we need to know your higher-level goals because it's very likely that we need to suggest alternatives
13:18:49 <mightybyte> Ok, let me start at the beginning.
13:19:10 <mightybyte> I have an input file language--right now it's basically name = value pairs.
13:19:16 <gwern> byorgey: teh internets
13:19:23 <mightybyte> where values can be numbers or lists
13:19:37 <Cale> okay
13:19:58 <mightybyte> I have a parser that reads them into a map and uses them that way.
13:20:13 <mightybyte> The way they are used depends on another parameter.
13:20:27 <Cale> You presumably have a type like   data Value = VNum Integer | VList [Value]   or something?
13:20:33 <mightybyte> Yeah
13:20:50 <mightybyte> But one future feature request is to expand the language.
13:21:00 <mightybyte> ...to allow arbitrary expressions
13:21:39 <mightybyte> I'm thinking I might as well use hint and give them all of Haskell, but only tell them about the capabilities they need at the moment.
13:21:50 <mightybyte> ...magically unveiling more when they ask for it down the road.
13:22:15 <dankna> that'll be complicated.  I decided against that approach for a scripting language in my own program, actually.
13:22:26 <dankna> but go on.
13:22:42 <Cale> You could just use Haskell source files directly as configuration, using hint.
13:22:48 <mightybyte> Yes
13:22:53 <Cale> (or one of the other options)
13:22:57 <mightybyte> That's exactly what I was thinking.
13:24:30 <mightybyte> I have a type class, call it class Computation where runComputation :: blah blah blah
13:24:38 <Cale> mightybyte: You would specify an interface of values which the user has to define, and hint will typecheck them all when it loads the thing.
13:24:46 <mightybyte> Yeah
13:24:47 <Cale> (well, GHC will, via hint)
13:24:49 <Twey> There's Lua too.
13:25:01 <Cale> and then you avoid the whole problem of dealing with things that are not the type you expect
13:25:09 <mightybyte> The input language is already a subset of Haskell, so it works really well.
13:25:22 <mightybyte> Cale: Precisely.
13:25:23 <Twey> I like that Lua lets you make config-filelike config files, rather than programs.
13:25:45 <dankna> I like that I don't have to use Lua :)
13:25:47 <mreh> any Englanders going to Utrecht?
13:25:48 <systemfault> Hey.. I compiled HEAD yesterday but the result was horribly slow.. Anyone has an idea of "why"?
13:25:53 <regalia> How would I got about finding the number of occurences in a list?
13:25:54 <mightybyte> But my problem is how to parameterize over this user-specified type.
13:25:55 <systemfault> (ghc)
13:26:04 <Cale> regalia: A combination of length and filter
13:26:11 <mightybyte> If the user wants computation A, then one set of variables is required.
13:26:21 <mightybyte> If computation B, then a different set.
13:26:38 <Cale> > length (filter (=='s') "Mississippi")
13:26:39 <regalia> Cale: :) thanks for making it so obvious, *facepalm*
13:26:39 <lambdabot>   4
13:26:39 <dankna> how many of these computations that they might want are there?
13:26:45 <mightybyte> One way to do this is to add another function getRequiredVariables :: [String] to the Computation type class.
13:27:12 <mightybyte> dankna: Well, more computations will be added over time and ongoing development.
13:27:14 <dankna> okay
13:27:25 <gwern> systemfault: slow binaries or slow itself?
13:27:34 <systemfault> gwern: The resulting binaries
13:27:51 <Cale> mightybyte: Basically, you define a datatype for each set of things that need to be user-specified, and get your users to construct a Haskell file defining a value of that type.
13:27:51 <systemfault> gwern: Like 9 times slower
13:27:55 <mightybyte> Instead of getRequiredVariables, I thought I might just create a data type to represent each computiation and it's required variables.
13:28:03 <Twey> > (fmap length . filter . (==)) 's' "Mississippi"
13:28:05 <lambdabot>   4
13:28:09 <mightybyte> Cale: Yes, that was exactly my intent.
13:28:18 <dankna> ah!
13:28:21 <dankna> multiparameter type classes
13:28:22 <systemfault> gwern: I used the perf profile in build.mk.sample and removed the "docs"
13:28:24 <mightybyte> But how to select that dynamically.
13:28:26 <dankna> Computation a b
13:28:34 <dankna> with method
13:28:37 <Cale> Why do you need to select it dynamically?
13:28:38 <dankna> getB :: b
13:28:47 <mightybyte> Hint has a function interpret :: String -> a -> m a
13:28:49 <systemfault> gwern: The point was to make a LLVM build
13:28:56 <mightybyte> ...where the second argument is a witness to the type you want.
13:29:13 <Cale> mightybyte: Right, and you *know* what type you want. It's whatever your interface type is.
13:29:23 * edwardk wvaes hello.
13:29:26 <Cale> Use (undefined :: MyInterface)
13:29:41 <mightybyte> Cale: But that's chosen by the user.
13:29:47 <mightybyte> Oh, just put the type class there?
13:29:48 <Cale> It can't possibly be
13:30:08 <Cale> In order for your program to use the resulting values, it needs to know what type of data it's got.
13:30:32 <Cale> So just use whatever type it is that your program wants.
13:30:48 <mightybyte> The previous implementation used something of a hack.
13:31:12 <mightybyte> data A = A, data B = B, ... representing the types of computations.
13:31:34 <Cale> That seems odd.
13:31:50 <mightybyte> Then data Computation = forall m. MyInterface m => Computation m
13:32:00 <mightybyte> And a map for lookup
13:32:36 <mightybyte> computations = Map.fromList [("A", Model A), ("B", Model B)]
13:33:41 <mightybyte> Oops, s/Model/Computation/
13:34:07 <Cale> huh, I'm not sure I follow what the idea here is.
13:34:39 <mightybyte> Well, then you just do a lookup into the map to figure out which instance of MyInterface you're using.
13:34:59 <mightybyte> (this was before the types A and B had the required variables as a part of their type.)
13:35:03 <Cale> Shouldn't you... already know that?
13:35:27 <Cale> hmm
13:35:28 <mightybyte> No, that's the point.  There are several different ones and the user chooses which one at runtime.
13:35:44 <dankna> *hem*
13:35:58 <dankna> multiparameter type classes
13:36:11 <Cale> okay, but you can move that choice upward, so that by the time it gets to interpreting a user program, you already know what type of value is in there...
13:36:12 <systemfault> gwern: Seems related to http://hackage.haskell.org/trac/ghc/ticket/3629
13:36:34 <tomberek> having problems with installing haskell packages in arch.  Can anyone lend a hand? (i've been trying on #arch-haskell to no avail)
13:36:44 <Cale> Maybe I just don't understand how this is supposed to work.
13:36:52 <gwern> systemfault: interesting
13:37:02 <Cale> You could also get the user to define a value of some type which has multiple constructors.
13:37:29 <Cale> and that way, they get to choose which of some set of interfaces they're defining
13:37:34 <mightybyte> Cale: Ahh, move it from the type level to the constructor level.
13:38:07 <Cale> Runtime choice -> Data,  Compile-time choice -> Types
13:38:22 <mightybyte> Instead of a type class with multiple instances, it's essentially switching to a single type with multiple constructors?
13:38:26 <Cale> yeah
13:38:36 <mightybyte> Ok.  I gotta run now.  I'll be back later.
13:38:50 <dankna> of course, you could use multiparameter type cla.....  okay, whatever :)
13:38:58 <dankna> good luck with it
13:39:15 <Cale> I don't really understand dankna's MPTC suggestion.
13:39:29 <dankna> I'm not certain I do either, but it strikes me as relevant
13:39:37 <dankna> he can have two related types - the type of the computation and the type of the input
13:39:47 <Cale> Oh, sure.
13:39:52 <dankna> and then a method which takes a witness of the former and gives a witness of the latter
13:40:00 <dankna> which is all he needs to call hint to get the interface
13:40:07 <Cale> I just think that since this is a runtime decision, types are the wrong mechanism.
13:40:21 <dankna> and you may be correct.  I haven't really thought this through.
13:40:39 <dankna> but that way he does keep the ability to not have to modify any central source file that has a list of all the instances.
13:40:52 <dankna> well, actually he'd still have to add the import, I think?
13:40:56 <tomberek> having problems with installing haskell packages in arch.  Can anyone lend a hand? (i've been trying on #arch-haskell to no avail)  *BUMP*
13:41:02 <dankna> tomberek: never used arch, sorry
13:41:22 <chelz> tomberek: the main archlinux channel might help
13:41:41 <AlexM> Hi
13:41:43 <AlexM> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24532#a24532
13:41:53 <AlexM> any idea why jumpBack gives a "Not in scope" error here?
13:42:00 <tomberek> chelz: i'll try
13:43:22 <AlexM> thanks :)
13:46:13 <monochrom> Dear AlexM: the where-clause is not visible to other equations, not even other equations defining the same exec' function.
13:46:31 <AlexM> oh
13:52:47 * leimy is having a fun lazy IO problem in the face of errors, and restarts :-)
14:10:07 <kmc> don't do lazy IO
14:12:48 <XniX23> if i do [x | x <- [1..10], condition1, condition2, condition3] , if condition1 fails, does haskell even look at condition 2?
14:13:13 <fax> no
14:13:14 <kmc> XniX23, probably not
14:13:19 <kmc> you care for performance reasons?
14:13:20 <XniX23> k tnx
14:13:21 <fax> ??
14:13:24 <fax> probability?
14:13:32 <kmc> i mean that i'm not sure of the order
14:13:49 <kmc> the Report gives the exact desugaring of list comprehensions
14:14:07 <XniX23> its not for performance, i want to do something if cond1 and 2 are true
14:14:20 <fax> use &&
14:14:29 <kmc> you could
14:14:46 <pokoko222> i wanna thank all haskell guys for pointing me in the right direction. here i am doing proofs in Spivak, and months ago i was like "why would i ever care about proofs" we dont do them at college which sucks, so i do it myself and feels like i am becoming math ninja ... lol
14:15:11 <tomberek> anyone here use Arch?
14:15:24 <fax> pokoko222 you must be kidding you can't even prove l'hopital
14:15:28 <XniX23> pokoko222 try online judges, those are cool
14:15:51 <enthymeme> I do, tomberek
14:15:53 <pokoko222> fax well i start with simple proofs take it easy ;)
14:16:04 <pokoko222> XniX23 links?
14:16:05 <fax> this IS simple
14:16:08 <fax> that's why I mentioned it
14:16:16 <kmc> fax, you misunderstand, the word "ninja" means "learn something for 2 hours then declare yourself an expert"
14:16:22 <pokoko222> fax ok it will probably come up soon since i do spivak
14:16:30 <XniX23> pokoko222 spoj.pl
14:16:36 <pokoko222> kmc i said "becoming a ninja" not "am a ninja"
14:16:42 <tomberek> enthymeme: i'm creating a new Arch install, and I can't get the packages and haskell working right
14:16:49 <enthymeme> oh?
14:17:03 <enthymeme> which packages? Is this a general arch problem?
14:17:03 <zakwilson> Is Text.Regex deprecated in favor of Text.Regex.Posix?
14:17:18 <enthymeme> I'm not generally great for arch questions because my install went off more or less without a hitch.
14:18:22 <tomberek> enthymeme: it's a AUR problem,, but every haskell package is causing me grief
14:18:32 <enthymeme> hmm
14:18:35 <enthymeme> I get that sometimes.
14:18:46 <SamB_web> ninja training takes a lot more than two hours, if any of the manga I've read on the subject is any indication ...
14:18:50 <enthymeme> like haskell-arrows I remember not being able to install, for some reason.
14:19:00 <tomberek> enthymeme: it's a makepkg issure (no i'm not using yaourt, but bauerbill)
14:19:00 <leimy> Yeah I'm thinking I'm going to try to make this stuff work with Iteratee somehow, but it's going to be a good bit of refactoring.
14:19:04 <enthymeme> I've got it now.
14:19:17 <enthymeme> ah, I use yaourt myself.  Is baurbill any good?
14:19:39 <monochrom> Ninja training is a neverending path. There is no going back. If you see Buddha, kill Buddha; if you see lambda, kill lambda.
14:20:07 <enthymeme> whatever happened to the Knights of the Lambda Calculus, monochrom?
14:20:15 <tomberek> enthymeme: i can't get either to work.. and apparently yaourt is no longer good for the haskell packages
14:20:22 <enthymeme> huh
14:20:23 <enthymeme> well
14:20:31 <enthymeme> that's strange, indeed.
14:20:39 <enthymeme> have you asked over in #archlinux?
14:20:44 <burp> sock <- socket AF_INET Stream 993 -- gives me "socket: protocol error (Protocol not supported)" why?
14:20:44 <tensorpudding> That koan doesn't translate well to lambda...
14:21:28 <fax> pokoko
14:21:34 <fax> pokoko222 can you prove chain rule
14:21:46 <lament> pokoko222: how old are you?
14:21:51 <pokoko222> fax no i work with very very simple proofs now
14:21:57 <fax> pokoko222 such as?
14:21:58 <monochrom> 222 years old, it says in the nick.
14:22:05 <pokoko222> fax well u got spivak?
14:22:10 <monochrom> Or perhaps 22.2
14:22:10 <fax> I've read it
14:22:40 <pastorn> YEEEEEEEEEEEES!
14:22:46 * pastorn parsed 4 bytes
14:22:49 <pastorn> <-- happy
14:22:59 <tensorpudding> hooray?
14:23:01 <m3ga> does the llvm backend for ghc require the llvm bindings from hackage or does ghc bundle its own bindings?
14:23:05 <mightybyte> dankna: Back.  In your MPTC solution, you'd use a functional dependency from the "witness" type to the computation type?
14:23:06 <pastorn> tensorpudding: indeed
14:23:17 <pastorn> tensorpudding: working on my TARGA loader... this is gonna be swell
14:23:18 <pokoko222> fax you have read it, have you solved it?
14:24:00 <fax> pokoko222, you can prove that the sum of the first n numbers is n(n+1)/2?
14:24:55 <enthymeme> Gauss did it when he was what, ten?  No pressure.
14:24:59 <burp> lol
14:25:06 <burp> sure, little gauss
14:25:21 <tensorpudding> Gauss was a little bit precocious though
14:25:23 <XniX23> fax: huh, does that proof need to be programmed?
14:25:30 <fax> XniX23 no
14:25:42 <fax> all the computational content is in the statement
14:25:51 <burp> I heard he did it when he was 6
14:26:05 <tensorpudding> You could probably prove it using Coq if you wanted
14:26:05 <mreh> imannuel kant was 5 feet tall
14:26:12 <mreh> immanuel*
14:26:19 <monochrom> He did it when he was n(n+1)/2 for some n.
14:26:37 <enthymeme> burp: your guess is as good as  mine.
14:26:53 <XniX23> monochrom that kinda skips some n's :D
14:26:55 <fax> you could nto prove it in Coq if you can not prove it on paper
14:27:09 <dankna> mightybite: yes, exactly
14:27:10 <tensorpudding> Well yeah.
14:27:12 <enthymeme> proving it on paper is pretty easy, though.
14:27:15 <dankna> *mightybyte
14:27:16 <XniX23> its rather easy to prove that
14:27:34 <tensorpudding> It's probably the second most famous visual proof, after the Pythagorean theorem
14:27:48 <monochrom> You could prove it in PVS without knowing how on paper. Just say "induction" and "grind".
14:27:52 <fax> XniX23, want a hard one? Every natural is the sum of three triangulars
14:27:56 <mreh> there's a junior skeptic on haskell cafe hijacking the whole mailing list
14:28:00 <mightybyte> dankna: Ok.
14:28:12 <enthymeme> junior skeptic, mreh?
14:28:31 <pokoko222> anyways i am now on simple dumb stuff proving things like: a<sqrt(ab)<(a+b)/2<b for 0<a<b
14:28:37 <mightybyte> dankna: Seems unnecessarily redundant to have that second type, but it does allow me to keep some of the advantages of the type class approach.
14:28:47 <mreh> ethymene: that guy yaking about evo psyc
14:29:00 <benmachine> whee AM/GM inequality
14:29:00 <mreh> enthymene that guy yaking about evo psyc
14:29:04 <enthymeme> I wasn't looking at it.
14:29:07 <fax> pokoko222 - how about 3rd root of abc < (a+b+c)/3?
14:29:10 <benmachine> simple, maybe, but pretty important I reckon
14:29:11 <XniX23> fax: what are triangulars?
14:29:14 <dankna> mightybyte: yeah...  as Cale was saying, you probably do want to try the data constructor approach
14:29:18 <fax> XniX23 -- the thing we were just talking about :S
14:29:35 <dankna> mightybyte: the second type is there because it's the FIRST type, the one you already had in your class
14:29:38 <tensorpudding> The proof that sum(1/2^n) -> 1/3 has a pretty picture too.
14:29:43 <benmachine> hmm I guess the AM/GM doesn't simply generalise from that
14:29:59 <mightybyte> Yeah
14:30:00 <dankna> once you determine what your first type is, you use a method of the MPTC to determine your second one
14:30:03 <pokoko222> fax good examples i think i have done the first one just a minute
14:30:13 <pokoko222> oh yeah that is easy, with induction i did it
14:30:15 <dankna> so I don't see any redundancy; both types are necessary to what you're doing
14:31:18 <fax> pokoko222 (should have wrote <=)
14:31:40 <XniX23> i hate my english skills -.-
14:31:57 <pokoko222> fax abc <= (a+b+c)/3 ?
14:32:12 <fax> no
14:32:38 <mightybyte> dankna: Ok, I think I'll give that a try.
14:32:45 <dankna> mightybyte - okay, tell me how it goes
14:32:59 <pokoko222> fax no what?
14:34:02 <monochrom> no to <pokoko222> fax abc <= (a+b+c)/3 ?
14:34:36 <monochrom> amazingly small context stack.
14:35:04 <tensorpudding> it's not hard to find a counter-example to abc <= (a+b+c)/2
14:36:43 <dankna> a = 1, b = -10, c = -10
14:36:50 <dankna> wait
14:36:51 <dankna> I did that wrong
14:37:04 <dankna> wait no, I did it right
14:37:19 <monochrom> @check
14:37:19 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
14:37:21 <fax> grr
14:37:38 <monochrom> @check \a b c -> a*b*c <= (a+b+c)/3
14:37:39 <lambdabot>   "Falsifiable, after 1 tests:\n0.0\n0.0\n-6.0\n"
14:37:43 <monochrom> @check \a b c -> a*b*c <= (a+b+c)/2
14:37:43 <lambdabot>   "Falsifiable, after 3 tests:\n-1.0\n0.5\n-0.5\n"
14:37:59 <monochrom> why work when there is software :)
14:38:04 <tensorpudding> It's easy to find them even if you restrict a,b,c to positive integers
14:38:28 <flux> @check \a b c -> a*b*c <= (a+b+c)/2 || (a < 0 || b < 0 || c < 0)
14:38:29 <lambdabot>   "Falsifiable, after 8 tests:\n3.75\n5.0\n3.8\n"
14:38:49 <tensorpudding> a=b=c > 1 is a class of counterexamples
14:38:57 <monochrom> @check \a b c -> (a>0 && b>0 && c>0) <= (a*b*c <= (a+b+c)/3)
14:38:58 <lambdabot>   "Falsifiable, after 19 tests:\n6.0\n9.5\n1.0\n"
14:39:01 <flux> when can we have that in quickecheck?-(
14:39:32 <tensorpudding> a^3 <= (3a)/3 = a
14:39:38 <tensorpudding> obviously false
14:39:44 <tensorpudding> for a > 1 an integer
14:39:49 <pokoko222> fax it would be cool if you can say what u wanna say clearly in one sentence that ends with "."
14:39:53 <monochrom> @check \a b c -> (a>0 && b>0 && c>0) <= (fromIntegral (a*b*c) <= fromIntegral (a+b+c) / 3)
14:39:54 <lambdabot>   "Falsifiable, after 42 tests:\n12\n9\n14\n"
14:40:25 <byorgey> flux: have what in quickcheck?
14:40:35 <fax> pokoko222 dude it was just the same thing you said except I replaced 2 with 3
14:40:36 <flux> byorgey, spitting out classes of counter-examples :)
14:40:54 <byorgey> flux: ?  It already does that.
14:41:05 <byorgey> the @check command just runs quickcheck.
14:41:16 <pokoko222> fax so is it < or <=
14:41:26 <[swift]_> argh.. i really wish ghci had a way to provide a stack trace
14:41:28 <fax> <=
14:41:33 <flux> byorgey, mm.. but it doesn't produce statements such as "a=b=c > 1 is a class of counterexamples"
14:41:37 <fax> if you let all the numbers be equal, both sides are equal
14:41:47 <flux> byorgey, it just produces certain examples from the class of counter-examples
14:41:56 <byorgey> flux: oh, I see.  yes, that's much harder =)
14:41:56 <[swift]_> one of my functions is recursing infinitely and i'm having a hard time finding the cause
14:42:11 <monochrom> ghci debugger has a way to provide the information
14:42:23 <pokoko222> fax ok i will try to solve
14:42:45 <Veinor> blah
14:42:47 <[swift]_> monochrom: how do you do it?
14:42:51 <Veinor> what's the usual way to format let statements
14:43:02 <monochrom> I don't actually know. I haven't needed a haskell debugger yet.
14:43:50 <aavogt> Veinor: there isn't a standard way?
14:44:04 <monochrom> There are several usual ways to format let statements. One is aligning "let" with "in" vertically.
14:44:18 <monochrom> There are several standards.
14:44:19 <aavogt> another is to put a newline right after the let
14:44:35 <Veinor> true
14:45:03 <aavogt> or if the bindings aren't recursive,     let x = y in\n let z = x in\n actual expression
14:45:29 <leimy> anyone mess with attoparsec-iteratee?
14:47:12 <leimy> transformers vs mtl?  Why pick one over the other?
14:48:21 <aavogt> they aren't very different
14:48:32 <pokoko222> fax are you bumping me? it is >=
14:48:37 <pokoko222> no way to be <=
14:48:45 <fax> it's <=
14:48:51 <leimy> Well I'm trying to figure out why iteratee is using transformers
14:49:04 <leimy> and how to deal with that when using mtl and transformers
14:49:07 <pokoko222> fax no way wrong, you want me to proove it is wrong?
14:49:17 <fax> it's not wrong
14:49:21 <fax> maybe you misread it
14:49:22 <pokoko222> by prooving abc >= (a+b+c)/3
14:49:31 <fax> I told you already it's not abc
14:50:02 <pokoko222> rewrite what u want me to proove please
14:51:57 <benmachine> cube root of abc
14:51:59 <zygoloid>  < monochrom> Dear AlexM: the where-clause is not visible to other equations, not even other equations defining the same exec' function.
14:52:16 <zygoloid> ^^ does anyone else think that would make for an awesome style of error message?
14:52:32 <Twey> Heheh.
14:52:39 <aavogt> that would be very difficult to implement
14:52:55 <aavogt> before you compile something, ghc should ask for your name like darcs
14:53:13 <benmachine> I'm sorry Dave, but I can't let you compile that?
14:53:31 <monochrom> That requires: for every unknown name, look through the whole file for where-clauses belonging to other equations.
14:53:32 <pokoko222> abc <= (a+b+c)^(1/3) benmachine?
14:54:14 <zygoloid> aavogt: finally a use for the 'real name' field in /etc/passwd
14:54:26 <benmachine> pokoko222: no that is not what I said at all
14:54:40 <Apocalisp> @type join . (fmap $ fmap join . Data.Traversable.traverse id)
14:54:40 <benmachine> abc^(1/3) <= (a+b+c)/3
14:54:41 <lambdabot> forall (m :: * -> *) a (f :: * -> *). (Monad f, Applicative f, Monad m, Data.Traversable.Traversable m) => f (m (f (m a))) -> f (m a)
14:54:42 <pokoko222> benmachine write what u said
14:54:45 <zygoloid> monochrom: yeah. and why not? :)
14:54:50 <pokoko222> ok
14:55:00 <fax> pokoko222, arithmetic mean of some number a1, ..., an is (a1+...+an)/n
14:55:14 <benmachine> @check \a b c -> (a*b*c)**(1/3) <= (a+b+c)/3
14:55:14 <fax> pokoko222, geometric means is nth root of (a1*...*an)
14:55:15 <lambdabot>   "Falsifiable, after 1 tests:\n0.0\n0.0\n-1.0\n"
14:55:23 <benmachine> oh
14:55:24 <pokoko222> fax yeah i know why u tell me that
14:55:30 <benmachine> @check \a b c -> abs (a*b*c)**(1/3) <= abs (a+b+c)/3
14:55:31 <lambdabot>   "Falsifiable, after 2 tests:\n1.0\n-1.5\n-1.5\n"
14:55:31 <fax> pokoko222, lol
14:55:40 <benmachine> oh bah
14:55:42 * benmachine bored now
14:56:38 <monochrom> because IMO we should spend time on replacing humans rather than helping humans.
14:56:38 <pokoko222> wow haskell can check stuff? i mean you can give it anything to "proove" ?
14:57:20 <monochrom> If we bother to program the computer to guess what the author means, why not usurp the author altogether and write in his stead?
14:57:51 <monochrom> Take the human out of the loop.
14:57:52 <zygoloid> monochrom: i suspect heuristics for error messages are easier and can be added incrementally...
14:58:07 <leimy> monochrom: didn't you see War Games?
14:58:18 <monochrom> Yes.
14:58:25 <tensorpudding> Hmm, he suddenly parted.
14:58:43 <tensorpudding> I was actually going to respond to him.
14:59:30 <zygoloid> though i'd be happy if ghc just stopped suggesting that i should define an instance of SomeoneElsesModule for SomeoneElsesType. i thought orphan instances were bad :)
15:00:03 <zygoloid> SomeoneElsesClass rather
15:00:53 <monochrom> The computer almost succeeded in taking all humans out of the loop, if not for that smart kid getting into the way.
15:01:27 <fax> :)
15:03:23 <XniX23> do math proofs really make you that better at problem solving?
15:03:24 <monochrom> pokoko222 was diappointed that a computer outperformed him.
15:03:45 <fax> XniX23 - I consider them the same thing
15:03:55 <tensorpudding> I feel sad every time my computer outperforms me by doing RSA encryption.
15:04:35 <zygoloid> i feel sad every time my computer outperforms me at typechecking
15:04:43 <XniX23> fax why? not all problems are mathematical
15:04:59 <fax> XniX23, yes but not all mathematical proofs are formal
15:05:39 <fax> XniX23, anyway it's like lifting weights
15:05:44 <monochrom> you should define "problem" and "problem solving" first
15:05:47 <Veinor> why does print "bi" print out b\232i ?
15:06:00 <fax> XniX23, If I lift a heavy book I will be just as strong as if I lift a bag of barely
15:06:05 <benmachine> > ord ''
15:06:06 <lambdabot>   233
15:06:08 <Saizan> Veinor: print uses show
15:06:11 <monochrom> otherwise you could just weasel with "how about solving the problem of eliminating social injustice".
15:06:14 <pikhq> Veinor: Doesn't print use "show"?
15:06:25 <Veinor> so what do I want?
15:06:27 <Saizan> Veinor: you want putStrLn or System.IO.UTF8.putStrLn, or something.
15:06:31 <Veinor> ah
15:06:44 <zygoloid> monochrom: well, you have a set of constraints, some deductive laws, ...
15:07:11 <XniX23> fax yes but youll get stronger lifting the heavier
15:07:21 <fax> :(
15:07:25 <Veinor> okay... that prints b### in my terminal emulator, but looks fine when I open it in, say, emacs
15:07:40 <pikhq> That's a problem with your terminal, then.
15:07:48 <tensorpudding> Maybe you need a terminal which supports a unicode font?
15:07:59 <Veinor> It does though, when I paste the >bi in it shows up normally
15:08:18 <pikhq> Look at locale.
15:08:32 <pikhq> LANG=?
15:08:39 <Veinor> en_US.utf-8
15:08:46 <Veinor> everything but LC_ALL is that, and LC_ALL is unset
15:10:18 <pikhq> Then... I have no clue what your terminal's doing.
15:12:29 <Veinor> yeah. :(
15:12:39 <tensorpudding> Which terminal is it?
15:12:54 <monochrom> why do people use weird terminal emulators?
15:13:28 <monochrom> "it's prettier and more customizable and more features"
15:13:42 <Twey> Yeah crazy urxvt-users
15:13:58 <monochrom> But if it doesn't have to display things correctly, I can give you one that's 10x prettier, 10x more customizable, 10x more features.
15:14:16 <tensorpudding> Which is?
15:14:22 <Ke> mplayer?
15:14:36 <FauxFaux> konsole. *runs*
15:14:48 <Twey> Konsole does Unicode pretty well
15:14:54 <Twey> The GTK-based terms, too
15:15:12 <tensorpudding> I've never had any unicode issues with urxvt.
15:15:36 <Stalafin> is there a way to say - x element interval? (so something shorter instead of x >= 0 && x <= 10)
15:16:53 <monochrom> Not in known libs.
15:17:01 <tensorpudding> You could write one.
15:17:59 <tensorpudding> n `inRange` (a,b), inRange :: (Num a) => a -> (a,a) -> Bool, say
15:18:07 <benmachine> :t inRange
15:18:08 <lambdabot> forall a. (Ix a) => (a, a) -> a -> Bool
15:18:15 <benmachine> mm?
15:18:24 <tensorpudding> Whoa! That was something I came up with on the spot.
15:18:27 <benmachine> :)
15:18:36 <tensorpudding> But that one uses Ix.
15:19:04 <tensorpudding> I don't think that, for instance, Complex Double's are instances of Ix, are they?
15:19:07 <monochrom> great minds think alike names.
15:19:24 <benmachine> tensorpudding: no, but complex intervals don't really make sense anyway
15:19:32 <tensorpudding> That's true.
15:19:46 <benmachine> it's true that not all the things you might want are Ix
15:19:58 <c_wraith> eh?  You can treat them as rectangles in the complex plane.  That makes enough sense
15:20:09 <benmachine> c_wraith: you can do I guess
15:20:23 <benmachine> but I don't know that you are ever really interested in rectangles in the complex plane
15:20:37 <benmachine> circles are more common
15:20:42 <benmachine> you can do them with modulus
15:21:02 <tensorpudding> You can provide an ordering on any finite subset of the Gaussian integers doing that, I suppose
15:21:25 <MattStrat> hey, im having problems with compiling haskell on OS X
15:21:37 <Veinor> what does 'GHCi runtime linker: fatal error: I found a duplicate definition for symbol blah blah blah' mean?
15:21:45 <MattStrat> can someone help me decipher my error?
15:22:10 <Veinor> MattStrat: why are you compiling it?
15:22:24 <benmachine> tensorpudding: well you can order complex numbers all you like, just not usually in any helpful ways
15:22:36 <tensorpudding> Hmm, you're allowed to do sort on any type which an instance of Ord, including say Rational.
15:22:48 <benmachine> MattStrat: we can't help you until we know what the error is :)
15:22:59 <MattStrat>  Could not find module `Data.Binary':
15:23:05 <tensorpudding> Even though Rational isn't a set that you can well-order using sort.
15:23:26 <MattStrat> and on another file:
15:23:27 <MattStrat> Could not find module `Codec.Compression.GZip':
15:23:30 <benmachine> tensorpudding: hmm? what do you mean?
15:23:41 <benmachine> MattStrat: sounds like you need some libraries!
15:23:50 <MattStrat> where would i get those?
15:23:52 <benmachine> MattStrat: what are you trying to install?
15:23:55 <c_wraith> benmachine: in sorted order, there's no "next" rational after 0
15:24:09 <c_wraith> benmachine: you *can* well-order rationals, but not according to sorted order
15:24:15 <MattStrat> some code a firend wrote
15:24:20 <MattStrat> *friend
15:24:35 <MattStrat> i installed the haskell platform, and then ghc thru macports as well
15:24:35 <tensorpudding> Yes, the well ordering theorem states that Q (and R!) can be well-ordered, but good luck trying.
15:24:48 <c_wraith> It's easy to well-order Q.  I've done it in haskell.  :)
15:24:54 <MattStrat> i thought these libraries would be included
15:24:58 <benmachine> c_wraith: oh, yeah, but that's not very surprising
15:25:05 <leimy> anyone else get annoyed when they hear terms that seem really really basic, but have complicated names?
15:25:14 <leimy> or rather, someone creates a new term for old technology?
15:25:17 <c_wraith> well-ordered R?  well, that's an act of faith.  :)
15:25:27 <benmachine> MattStrat: it's possible GHC is looking in the wrong place to find your platform?
15:25:32 <leimy> like how inversion-of-control is dependency injection is really just a couple of other names for CPS?
15:25:35 <tensorpudding> c_wraith: I "choose" to have faith in it.
15:25:38 <c_wraith> (yes, the axiom of choice is faith)
15:25:48 <benmachine> the axiom of choice isn't faith
15:25:52 <benmachine> well
15:25:59 <benmachine> if you say it's "true" then I guess it might be
15:26:13 <benmachine> but you don't really need to do that
15:26:14 <MattStrat> benmachine,are you saying i have the libraries but a path is set wrong somewhere?
15:26:14 <tensorpudding> CS has a rather large contingent of intuitionists and constructivists.
15:26:29 <zakwilson_> I think what MattStrat needs is a step-by-step "How to install GHC, cabal and the standard libraries on Mac OS".
15:26:34 <leimy> also CS has few people who seem interested in studying history
15:26:35 <benmachine> MattStrat: if your haskell-platform install was successful you should have them somewhere
15:26:47 <c_wraith> I just mean it's non-constructive.  Things are non-constructive have higher philosophical hurdles to get over. :)
15:27:01 <[swift]_> leimy: by CPS you mean continuation passing style, i assume?
15:27:03 <benmachine> it's all just axioms anyway
15:27:08 <leimy> [swift]_: yes :-)
15:27:16 <benmachine> maths isn't about what's true as much as what is implied by what
15:27:40 <leimy> It's just that I had an interview question where someone was asking me about dependency injection.
15:27:45 <leimy> and I hadnt heard that term.
15:27:53 <MattStrat> benmachine, how would i go about looking for them and fixing it so ghc can find them?
15:28:01 <leimy> then when they explained it I said "Oh CPS" and they were like "what the hell are you talking about?"
15:28:07 <leimy> net result... bad interview :-)
15:28:47 <leimy> then the more I read up on dependency injection the more I noticed it was something that was doable via CPS :-)
15:28:55 <leimy> This whole SOA crap bugs me too
15:28:55 <benmachine> MattStrat: I don't know for sure
15:29:26 <benmachine> MattStrat: wait, did you install haskell-platform via macports?
15:29:47 <ddarius> leimy: Dependency injection isn't even CPS.  It is just straightforward parameterization.
15:29:51 <MattStrat> no, benmachine
15:29:56 <ddarius> leimy: REST is CPS.
15:30:06 <MattStrat> haskell platform was installed from the dmg
15:30:30 <MattStrat> after that, i installed ghc AGAIN from macports
15:30:41 <benmachine> oh
15:30:42 <benmachine> why?
15:30:45 <leimy> ddarius: well it's doable via CPS, just as it's possible to do partial evaluation of a larger function by decomposing into continuations :-)
15:30:49 <MattStrat> because it wasnt working. heh.
15:30:53 <benmachine> oh
15:30:55 <benmachine> hmm
15:30:59 <leimy> ddarius: or in haskell, partially applying parameters to functions :-)
15:31:24 <benmachine> well, if it was me I'd try to get that fixed rather than try to squeeze a macports and non-macports installation together so that it works in some way
15:31:28 <benmachine> the latter sounds harder to me
15:31:37 <benmachine> but
15:31:50 <benmachine> I can't actually tell you which would work better
15:31:52 <leimy> anyway, I'm just irritated by how much gets re-invented without apparently looking at the work others have already done to address such needs.
15:31:56 <MattStrat> ok, if i were to start over, best way to install haskell is?
15:32:23 <benmachine> well, I installed GHC from the disk image and then cabal-install by hand, but I'm a bit weird like that
15:32:30 <benmachine> I don't know is the honest answer
15:32:33 <benmachine> are you on 10.6?
15:32:57 <m3ga> MattStrat: i am an irregular user of macports. i would recomment the HP dmg and then cabal-install any further libs you need
15:33:14 <MattStrat> ok, i dont have cabal it seems
15:33:17 <MattStrat> how do i get that?
15:33:37 <MattStrat> i have 2 computers. one 105, one 10.6. same error on both.
15:33:43 <MattStrat> *10.5
15:33:44 <benmachine> I thought it came with the platform
15:33:48 <zakwilson_> Is it possible that it's present, but not in your path?
15:33:57 <ddarius> leimy: Read http://martinfowler.com/articles/injection.html and when you get to constructor injection tell me how this is not mind-bleedingly obvious.
15:33:59 <benmachine> try: ls /usr/local/bin
15:34:01 <MattStrat> cabal
15:34:02 <MattStrat> -bash: cabal: command not found
15:34:12 <leimy> ddarius: I think I read that already... :-)
15:34:24 <leimy> This looks like something I've read like last week...
15:34:55 <ddarius> Probably.
15:34:57 <MattStrat> ls /usr/local/bin
15:34:57 <MattStrat> stuff	unstuff
15:35:04 <leimy> anyway, because it was discovered you can do it in Java... it's like the new hot shit everyone has to know :-)
15:35:28 <leimy> I tried to explain that a lot of the technology from AOP (Aspect Oriented Programming) came from Lisp folks :-)
15:35:30 <ddarius> leimy: You can do it in every programming language since 1960.
15:35:44 <EvanR-work> AOP.....
15:36:57 <leimy> ddarius: right but that page you just pointed to is listed by some other sites as "ground breaking"
15:38:10 <leimy> I mean doesn't STL in C++ achieve this with bind1st and the like?
15:42:58 <leimy> I should just stfu and get back to playing with iteratee :-)
15:44:00 <Stalafin> if i have the error: Probable fix: add a type signature that fixes these type variable(s); what does this mean?
15:44:26 <Eridius> Stalafin: it means the compiler thinks that adding an explicit type annotation will fix your problem
15:44:29 <mauke> that's not the error, that's a suggestion on how to fix the error
15:45:11 <EvanR-work> Stalafin: just guessing, but you missed some parentheses or missing a constructor which puts the types into the right form
15:45:41 <[swift]_> argh, doesn't ":break myFunc" set a breakpoint at myFunc in ghci? when i do that it just says "No breakpoints found at that location"
15:45:53 <aavogt> > read . show
15:45:54 <lambdabot>   {()->()}
15:46:56 <serhalp> I... really don't get Haskell's number system -- well, probably something much greater than that, actually, but I seem to have an especially hard time dealing with all the number types/classes.
15:47:19 <fax> me too
15:48:28 <[swift]_> man, this is a widespread problem... i can find posts on haskell-cafe, haskell newsgroups, etc from people who have this problem, but so far i haven't found an answer
15:48:46 <Mathnerd314> hint: don't use haskell
15:49:14 <mauke> serhalp: ignore all types except for Integer and Double
15:49:21 <mauke> learn other types later
15:49:59 <serhalp> Well, I'm using a function in a module that doesn't ignore other types. :)
15:50:14 <mauke> what's its type?
15:50:18 <Stalafin> EvanR-work: I really have a problem finding my mistake... would you mind looking at my function?
15:50:24 <Stalafin> EvanR-work: that is, program?
15:50:58 <serhalp> Okay, say I have a function, and its type is apparently [GHC.Word.Word8] -> something else.
15:51:17 <mauke> ok, list of bytes
15:51:28 <mauke> Word8 is like a restricted version of Integer
15:51:35 <mauke> its range is [0 .. 255]
15:51:43 <Twey> Word is the Haskell name for an unsigned integer.
15:51:49 <benmachine> Mathnerd314: as a strategy that is unlikely to catch on in #haskell
15:51:50 <Twey> 8 refers to its size, in bits.
15:52:17 <serhalp> How come if I pass a list of literal numbers to that function, it works fine, but if I define a list with those same values and call that function with that list, it doesn't work?
15:52:44 <serhalp> Sorry, should have sent all that in one message; I understand what a Word8 is.
15:52:48 <benmachine> serhalp: do you mean in ghci?
15:53:02 <mauke> serhalp: how do you define the list of numbers?
15:53:15 <Twey> > let f :: [Word8] -> (); f = const (); lst = [4, 5, 6] in (f [1, 2, 3], f lst)
15:53:16 <lambdabot>   ((),())
15:53:27 <Veinor> whoo
15:53:32 <Veinor> things that are not the same: XML, HTML
15:53:34 <[swift]_> alright, i figured it out. that message really needs some improvement. if you pass a module name to :load, as you would in a haskell source file, then you can't set breakpoints. if you pass the filename of the sourcecode of that module, you can.
15:53:41 <Mathnerd314> benmachine: so far I haven't found a better one. I'm all ears.
15:54:02 <benmachine> Mathnerd314: I didn't really get what it was in response to
15:54:09 <benmachine> but may I suggest, "use haskell"?
15:54:31 <serhalp> mauke: say, xs = [0x00, 0xAA]
15:54:38 <Mathnerd314> benmachine: one = programming language
15:55:31 <serhalp> benmachine: err, sort of: I was trying to deal with an issue in my code, so I've been testing simpler cases in ghci.  That example is in ghci, yes.
15:55:33 <benmachine> Mathnerd314: now I am entirely confused and suspect there has been a miscommunication
15:55:53 <mauke> serhalp: are you doing anything else with that list?
15:56:10 <benmachine> serhalp: this is probably to do with type defaulting, which you usually don't have to worry about in real code
15:56:37 <mauke> I blame the monomorphism restriction, but it's hard to tell without more context
15:56:39 <benmachine> and/or the monomorphism restriction
15:57:06 <benmachine> serhalp: if you give the list an explicit type signature (even a polymorphic one) that might help
15:57:42 <benmachine> e.g. let xs :: (Num n) => [n]; xs = [0x00, 0xAA]
15:58:53 <benmachine> hmm
15:59:22 <serhalp> That doesn't work anymore that defining it without a type.
15:59:35 <serhalp> than*
15:59:38 <mauke> serhalp: are you doing anything else with that list?
15:59:40 <benmachine> give a complete example?
15:59:47 <serhalp> mauke: nope
15:59:55 <mauke> what's the error message?
15:59:57 <benmachine> (also, you didn't do let xs = [foo] :: typesig, did you? because that doesn't work)
16:00:17 <benmachine> (you have to give the typesig and definition separately)
16:00:29 <serhalp> ... oh.
16:00:35 <serhalp> How can you even do that in ghci?
16:00:58 <mauke> xs = [0x00, 0xAA] doesn't work in ghci
16:01:16 <mauke> you might be giving me inaccurate information here
16:02:14 <serhalp> Well, with a let.
16:02:15 <EvanR> alright, back to mechanical graph reduction
16:02:31 <serhalp> I feel like there's something basic I'm not getting here.
16:03:00 <benmachine> serhalp: I don't think so
16:03:04 <mauke> yes, the monomorphism restriction
16:03:15 <benmachine> serhalp: I think you're just being screwed over by bits of the language acting in unexpected ways
16:03:19 <benmachine> and ghci being mean to you
16:03:32 <mauke> the MR only exists to haunt/taunt newbies
16:03:45 <benmachine> serhalp: let xs :: (Num n) => [n]; xs = [0x00, 0xAA] -- the semicolon lets you give a typesig alongside a definition
16:04:10 <mauke> compare :t xs
16:04:58 <serhalp> benmachine: ah, the ol' ambiguities-in-communicating-code-via-IRC issue: I assumed the semicolon was punctuation in the message.
16:05:32 <benmachine> serhalp: I don't blame you
16:06:40 <zygoloid> benmachine: portal flashbacks :)
16:07:08 <benmachine> heheh
16:07:49 <serhalp> So, wait, is that just a ghci thing?
16:08:41 <benmachine> serhalp: kiiiind of
16:08:52 <benmachine> serhalp: it's certainly much easier to trigger in ghci
16:08:55 <mauke> serhalp: no
16:08:58 <Stalafin> i can't figure out what the problem with my code is... it looks a little bit messy; but please just look at lines 60 and 61 of the main function; line 60 works, but line 61 will not; i figure, there is something wrong with the latticePrint function, but i don't quite understand the error: http://haskell.pastebin.com/mguYM3d3
16:10:00 <mauke> Stalafin: what error?
16:10:22 <Stalafin> mauke: Ambiguous type variable `t' in the constraints:
16:10:29 <mauke> go on
16:10:50 <benmachine> what constraints
16:11:10 <Stalafin> mauke: ah, okay; i will paste the whole error:http://haskell.pastebin.com/Gjr9h6ez
16:11:17 <Stalafin> mauke: at the bottom
16:11:50 <benmachine> ah
16:12:01 <mauke> oh, you're trying to use something both as an integer and as a double
16:12:14 <benmachine> if you look at the slab function
16:12:28 <benmachine> you compare x to floor (something)
16:12:30 <benmachine> :t floor
16:12:31 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
16:12:35 <Stalafin> but i thought i deactivated that sort of issue with {-# LANGUAGE NoMonomorphismRestriction #-}
16:12:38 <benmachine> so that forces x to be Integral
16:12:49 <mauke> Stalafin: you can't deactivate the type system
16:12:54 <serhalp> Hrm, well, my actual issue in my non-ghci code was that calling that same function with, say, [0x00, 0xAA] works as intended but if I define tmp = 0x00 and call it with [tmp, 0xAA], I'm told the type is wrong (that I provided an Integer).  How does that work?
16:12:55 <benmachine> in latticePrint you use / and * to force it to be Fractional
16:13:03 <mauke> Stalafin: and that's not what NoMonomorphismRestriction does
16:13:13 <benmachine> you can't have something both Integral and Fractional at once; you need some sort of coercion
16:13:38 <Stalafin> benmachine: so... how can i fix my problem?
16:13:47 <mauke> serhalp: are you doing anything else with tmp?
16:13:54 <benmachine> Stalafin: probably by applying fromIntegral or realToFrac somewhere
16:14:02 <mauke> or by using `div` instead of /
16:14:48 <benmachine> serhalp: you could try giving tmp an explicit type signature
16:14:52 <serhalp> mauke: no
16:15:06 <mauke> serhalp: then I have no idea, because that works here
16:15:32 <Stalafin> benmachine: what is the difference between a real and a frac?
16:15:41 <mauke> hmm, except hugs disagrees
16:15:42 <benmachine> Stalafin: Int and Integer are in the class Real
16:15:43 <mauke> wtf
16:16:08 <benmachine> Stalafin: Fractional contains only things that can be divided exactly, like Rational and Double
16:16:32 <mauke> serhalp: ok, for some reason hugs immediately monomorphs tmp to Integer
16:16:41 <benmachine> Stalafin: in a ghci session, do :i Real and :i Fractional
16:16:42 <serhalp> Data.ByteString.pack [0x00, 0xAA] -- works as intended
16:16:43 <serhalp> tmp = [0x00]
16:16:43 <serhalp> Data.ByteString.pack[tmp, 0xAA] -- Couldn't match expected type GHC.Word.Word8 against 'Integer'
16:16:54 <serhalp> This is with GHC, if that changes anything.
16:17:14 <mauke> serhalp: you should get a completely different error for that because [0x00] is not 0x00
16:17:20 <monochrom> monomorphism plus defaulting
16:17:23 <benmachine> serhalp: hold on, do you mean tmp = 0x00?
16:17:26 <regalia> :t [0x00]
16:17:27 <lambdabot> forall t. (Num t) => [t]
16:17:28 <serhalp> Err, that was a typo.  Yeah.
16:17:37 <mauke> monochrom: http://codepad.org/aoOD3tnE -- why does this work in ghc but not hugs?
16:17:42 <regalia> > let tmp = 0x00
16:17:43 <benmachine> serhalp: try adding tmp :: Word8 into the mix
16:17:43 <lambdabot>   not an expression: `let tmp = 0x00'
16:18:03 <serhalp> But that doesn't work because Word8 is a class and not a type, right?
16:18:07 <regalia> when I see it, once you assigne 0x00 to tmp, it turns into an Integer
16:18:12 <mauke> serhalp: Word8 is a type
16:18:19 <regalia> try :t tmp
16:18:19 <serhalp> regalia: why?
16:18:39 <serhalp> regalia: but this isn't in ghci
16:18:43 <mauke> monomorphism restriction, but I don't get why it doesn't turn into Word8
16:18:43 <benmachine> Word8 is a type, yeah, otherwise [Word8] wouldn't be valid
16:18:51 <regalia> just like typing in 0xF displays as 15
16:18:52 <benmachine> classes only appear on the left of =>s
16:18:59 <regalia> serhalp: Ah, I thought you were in ghci
16:19:29 <benmachine> serhalp: even if it was a class, an explicit type signature would still be useful
16:19:35 <benmachine> explicit type signatures are always useful
16:19:53 <benmachine> they may not fix the error but they often make the error message more useful
16:20:11 <serhalp> regalia: I thought once you need to show it, you need to infer a type, but otherwise it's undefined until something else lets it know what type it needs to be... or something.
16:20:42 <benmachine> the type should be resolved according to where it is used
16:20:45 <serhalp> benmachine: I know, but I couldn't figure out the right type signature to use
16:21:10 <benmachine> serhalp: ah, then you go "#haskell, what type signature should I use?" and we help you with that instead :)
16:21:28 <benmachine> or you use :t in ghci and steal/modify one of those
16:21:41 <benmachine> for example
16:21:43 <benmachine> :t pack
16:21:44 <lambdabot> Not in scope: `pack'
16:21:48 <benmachine> :t BS.pack
16:21:49 <lambdabot> [Word8] -> BSC.ByteString
16:21:58 <benmachine> if a -> b is a valid type, then a is
16:22:03 <benmachine> so [Word8] is a valid type
16:22:07 <benmachine> if [a] is a valid type then a is
16:22:10 <benmachine> so Word8 is a valid
16:22:16 <benmachine> so that's probably what you want
16:22:30 <mauke> alternatively
16:22:32 <mauke> :t 0x00
16:22:33 <lambdabot> forall t. (Num t) => t
16:22:39 <mauke> tmp :: (Num t) => t
16:22:48 <benmachine> yeah
16:23:19 <mauke> or {-# LANGUAGE NoMonomorphismRestriction #-}
16:23:25 <regalia> http://haskell.pastebin.com/7yPhLn2X
16:23:45 <EvanR> :t 'c'
16:23:46 <lambdabot> Char
16:23:48 <EvanR> :)
16:23:53 <EvanR> nice and simple
16:24:37 <Zeiris-> Is there some minimum metric of usefulness a Hackage package must fulfill?
16:24:51 <c_wraith> Zeiris-: not formally.
16:25:15 <c_wraith> Still, to put something on hackage, you should probably believe it's got some value to others.
16:26:28 <benmachine> Zeiris-: the penalty for not doing so is no worse than mockery/mild disapproval
16:26:55 <benmachine> Zeiris-: for some precedents, try http://hackage.haskell.org/package/empty
16:27:06 <benmachine> http://hackage.haskell.org/package/pony
16:27:06 <c_wraith> hell, I'm not sure if anyone other than me has ever used the package I put on hackage.
16:27:36 <benmachine> for a non-silly example
16:27:46 <benmachine> http://hackage.haskell.org/package/algebra this is a pretty low standard to overcome
16:27:48 <serhalp> Ah, jeez.  Apparently adding :: Word8 fixes it, although I was certain that was the very first thing I tried.  Well, thank you all!
16:29:08 <Zeiris-> I've got a library for defining 3D models via a pretty simple DSL. The only file format it writes to is obscure and not used by anything (afaik), and I haven't gotten around to reducing the number of vertices it produces... But the idea's kinda cool.
16:29:35 <Zeiris-> And I figure since I'm documenting+packaging it for self-education anyway, I might as well upload it in case it inspires anyone.
16:30:46 <serhalp> Actually, follow-up question: is there, by any chance, some way to... declare the (common) type of multiple declarations at once?  I guess I'm asking for an "int x, y;" equivalent.
16:31:36 <EvanR> > let ones = 1 : ones
16:31:37 <lambdabot>   not an expression: `let ones = 1 : ones'
16:31:39 <EvanR> > let ones = 1 : ones in ones
16:31:40 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
16:31:49 <benmachine> Zeiris-: personally I think disk space (and namespace) is cheap
16:31:59 <mauke> serhalp: x, y :: Int
16:33:08 <XniX23> haskell has some nice one liners <3
16:33:31 <ddarius> > fix (1:)
16:33:32 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
16:33:36 <mauke> > repeat 1
16:33:37 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
16:34:04 <EvanR> is : a function or a data constructor
16:34:09 <mauke> data constructor
16:34:15 <benmachine> special data constructor
16:34:31 <Saizan> data constructors are functions too, btw
16:34:36 <burp> :t (:)
16:34:36 <benmachine> I mean there's actually nothing that special about it
16:34:37 <lambdabot> forall a. a -> [a] -> [a]
16:34:41 <mauke> > nubBy(((>1).).gcd)[2..]
16:34:43 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
16:34:43 <benmachine> but it's considered special by the syntax
16:34:44 <EvanR> can you define constructors that are a symbol like +
16:34:45 <serhalp> mauke: but there's no way to define x and y at the same time, right?
16:34:52 <mauke> serhalp: x@y = 42
16:35:03 <Saizan> EvanR: they have to start with :
16:35:14 <Saizan> EvanR: e.g. ":+"
16:35:17 <XniX23> mauke what was that
16:35:18 <EvanR> oo
16:35:19 <Saizan> @src Complex
16:35:20 <lambdabot> data (RealFloat a) => Complex a = !a :+ !a
16:35:24 <mauke> XniX23: aliased binding
16:35:32 <serhalp> mauke: Sorry, that was unclear... not with the same values.  I mean define them both but declare their type as the same.
16:35:43 <mauke> serhalp: x, y :: Int; x = 1; y = 2
16:35:57 <serhalp> outside ghci?
16:36:11 <mauke> or inside, whatever you like
16:36:29 <Saizan> inside you've to put those in a let
16:36:42 <Saizan> (as usual)
16:36:42 <serhalp> Ah, and there's no way to do that without... repeating the identifiers?
16:37:04 <EvanR> is tuple a data constructor
16:37:12 <burp> :t (,)
16:37:13 <serhalp> (Don't ask, but I've got 200+ declarations of the same type here.)
16:37:13 <lambdabot> forall a b. a -> b -> (a, b)
16:37:18 <EvanR> more special syntax
16:37:22 <mauke> serhalp: well, for monomorphic types you can annotate the value instead of the identifier
16:37:28 <benmachine> serhalp: how about [x, y] = [1, 2] :: [Int]
16:37:29 <burp> what's special about it?
16:37:29 <mauke> serhalp: i.e. x = 1 :: Int
16:37:35 <mauke> or what benmachine said
16:38:19 * benmachine wonders if xs :: (Num n) => [n]; xs@[a, b, c] = [1, 2, 3] would do the right thing
16:38:22 <EvanR> burp: well its not of the form F x y z, or x :@ y
16:38:40 <burp> it's just infix
16:38:45 <XniX23> and i thought i was cool getting primes with [ x | x <- [2..8], ( y | y <- [2..x-1], x `mod` y == 0) == []] :(
16:38:47 <serhalp> benmachine: nice try, but they need to keep their identifiers
16:38:55 <EvanR> burp: so its really the comma
16:39:01 <Saizan> burp: no, you can't use ',' in operators
16:39:04 <benmachine> serhalp: huh?
16:39:11 <burp> hm
16:39:19 <EvanR> > 3 , 4
16:39:20 <lambdabot>   <no location info>: parse error on input `,'
16:39:27 <EvanR> > 3 `,` 4
16:39:28 <lambdabot>   <no location info>: parse error on input `,'
16:39:31 <serhalp> benmachine: damn, lots of typos tonight; that was "I need to keep"
16:39:33 <EvanR> > 3 (,) 4
16:39:33 <burp> ah you mean that, ok
16:39:33 <benmachine> hmm, that's interesting
16:39:34 <lambdabot>   Ambiguous type variable `t' in the constraint:
16:39:34 <lambdabot>    `GHC.Num.Num t' arising f...
16:39:40 <Saizan> > (,) 3 4
16:39:41 <lambdabot>   (3,4)
16:39:41 <burp> > 3 `(,)` 4
16:39:42 <lambdabot>   <no location info>: parse error on input `('
16:39:46 <mauke> serhalp: still "huh?"
16:39:55 <benmachine> serhalp: yeah, still don't get the problem
16:40:12 <benmachine> (in answer to my own question, it doesn't typecheck oddly enough)
16:40:17 <EvanR> the form (3, 4) must be special, i cant seem to do 3, 4 otherwise
16:40:22 <mauke> EvanR: it is
16:41:35 <burp> > let (#) = (,) in 3 # 4
16:41:36 <lambdabot>   <no location info>: parse error on input `)'
16:41:48 <burp> um what?
16:42:05 <Saizan> maybe it's MagicHash
16:42:10 <mauke> > let ( # ) = (,) in 3 # 4
16:42:25 <EvanR> > let (#) = (,) in (3 # 4)
16:42:29 <serhalp> Oh, I see.  I didn't know you could that, declaring things within a list like that.  That works, thanks again!
16:42:30 <burp> bot died? :D
16:42:31 <EvanR> it broke
16:42:34 <Saizan> (or unboxed tuples, whatever it's called)
16:42:41 <serhalp> Damn, I accidentally the whole message again
16:42:53 <lambdabot>   <no location info>: parse error on input `)'
16:42:55 <lambdabot>   (3,4)
16:43:03 <mauke> I win
16:43:16 <EvanR> ?
16:43:17 <EvanR> > let (#) = (,) in (3 # 4)
16:43:18 <lambdabot>   <no location info>: parse error on input `)'
16:43:21 <burp> hehe
16:43:25 <EvanR> ok
16:45:03 <XniX23_> how do i remove an element from a list?
16:45:04 <Saizan> the idea anyway is that while (,) denotes a function, all the syntax for tuples is special
16:45:20 <EvanR> XniX23_: theres delete
16:45:23 <EvanR> :t delete
16:45:24 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
16:45:42 <mauke> XniX23_: which element?
16:45:52 <EvanR> @src delete
16:45:52 <lambdabot> delete = deleteBy (==)
16:46:31 <XniX23_> lets say i have a list [6,7,4,3] id like to delete the number 3
16:46:41 <XniX23_> but not using init ofc
16:46:53 <EvanR> > delete 3 [6, 7, 4, 3]
16:46:54 <lambdabot>   [6,7,4]
16:46:55 <EvanR> ;)
16:46:58 <mauke> > filter (/= 3) [6,7,4,3]
16:46:59 <lambdabot>   [6,7,4]
16:47:00 <hasenov> hello, could someone help me turn the following expression into a "do" notation?
16:47:08 <hasenov> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24536#a24536
16:47:12 <burp> @src deleteBy
16:47:13 <lambdabot> deleteBy eq x []        = []
16:47:13 <lambdabot> deleteBy eq x (y:ys)    = if x `eq` y then ys else y : deleteBy eq x ys
16:47:15 <EvanR> > reverse (drop 1 (reverse [6, 7, 4, 3]))
16:47:16 <lambdabot>   [6,7,4]
16:47:45 <hasenov> either that, or remember there was some command on lambdabot to automatically transform into do notation
16:47:53 <mauke> hasenov: @redo
16:47:57 <mauke> I think
16:48:00 <Saizan> @redo let eval   = ST(accumIfNotSumOfTwoAbundants 0 12) >>= \a  -> ST(accumIfNotSumOfTwoAbundants a 13) >>= \b  -> ST(accumIfNotSumOfTwoAbundants b 14) >>= \c  -> return c in putStrLn . show $ applyST eval []
16:48:01 <lambdabot> Maybe you meant: do read todo undo
16:48:04 <mauke> @do 1 >> 2
16:48:04 <lambdabot> do { 1; 2}
16:48:06 <Veinor> okay, so I'm trying to use HXT to pull the RSS url from a webpage
16:48:09 <mauke> ok, it was @do :-(
16:48:15 <XniX23_> [x | x <- [6,7,4,3], x != 3]
16:48:19 <Saizan> @do let eval   = ST(accumIfNotSumOfTwoAbundants 0 12) >>= \a  -> ST(accumIfNotSumOfTwoAbundants a 13) >>= \b  -> ST(accumIfNotSumOfTwoAbundants b 14) >>= \c  -> return c in putStrLn . show $ applyST eval []
16:48:20 <lambdabot> let { eval = do { a <- ST (accumIfNotSumOfTwoAbundants 0 12); b <- ST (accumIfNotSumOfTwoAbundants a 13); c <- ST (accumIfNotSumOfTwoAbundants b 14); return c}} in putStrLn . show $ applyST eval []
16:48:28 <Veinor> via runX (readDocument [(a_validate, v_0)] "url" >>> rss)
16:48:31 <XniX23_> [x | x <- [6,7,4,3], x /= 3]
16:48:38 <XniX23_> ill cry
16:48:39 <Veinor> but it always tells me it's not valid, which I presume is because, well, HTML isn't XML
16:48:57 <burp> XniX23_: what's the problem with it?
16:49:19 <EvanR> XniX23_: ... whats wrong with delete
16:49:27 <XniX23_> whoa
16:49:32 <XniX23_> i thought what i wrote doesnt work
16:49:42 <XniX23_> nothing EvanR, ill try this now ^^ ty
16:49:49 <burp> or not inserting 3 at first :D
16:49:59 <EvanR> acausal programming!
16:50:17 <EvanR> just invent the ftl processor
16:50:18 <EvanR> ;)
16:50:34 <fax> fundamental theorem of l_______?
16:50:47 <hasenov> Saizan: thanks!
16:51:26 <Veinor> lambdabot
16:54:22 <EvanR> :t []
16:54:23 <lambdabot> forall a. [a]
16:55:04 <EvanR> hehehe. its type is list of something, but it has nothing ;)
16:55:14 <XniX23_> not in scope delete
16:55:22 <EvanR> import Data.List
16:55:23 <XniX23_> do i need to load something
16:55:25 <XniX23_> ok
16:55:35 <tensorpudding> When in doubt
16:55:38 <tensorpudding> @hoogle delete
16:55:38 <lambdabot> Data.HashTable delete :: HashTable key val -> key -> IO ()
16:55:39 <lambdabot> Data.IntMap delete :: Key -> IntMap a -> IntMap a
16:55:39 <lambdabot> Data.IntSet delete :: Int -> IntSet -> IntSet
16:55:48 <burp> fail ;)
16:56:57 <mauke> @index delete
16:56:57 <lambdabot> Data.HashTable, Data.IntMap, Data.IntSet, Data.List, Data.Map, Data.Set
16:57:16 <siracusa> Can someone help me with this code: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24537
16:57:29 <siracusa> I don't know how to write the second instance
16:57:59 <Veinor>  rss = deep (isElem >>> hasAttrValue "type" (=="application/rss+xml") >>> getAttrValue "href")
16:58:02 <Veinor> \o/
16:58:42 <burp> lookup :: Eq a => a -> [(a, b)] -> Maybe b
16:58:44 <mauke> :t lookup
16:58:45 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
16:58:51 <burp> using that from data.list is no good?
16:59:15 <EvanR> @src foldr
16:59:15 <lambdabot> foldr f z []     = z
16:59:16 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
16:59:33 <siracusa> burp: The problem is the instance declaration
16:59:56 <XniX23_> how can i write delete x*y z
17:00:16 <EvanR> delete (x*y) z
17:01:21 <applicative-rex> has anyone seen a nice implementation of the List monad that works correctly with infinite lists?
17:01:22 <burp> lookup = Data.List.lookup? doesn't that work?
17:01:43 <Cale> applicative-rex: It wouldn't satisfy the monad laws.
17:01:46 <applicative-rex> oh
17:01:54 <Cale> applicative-rex: (if I understand what you mean by "works with"
17:01:55 <Cale> )
17:01:55 <siracusa> burp: Lookup is of kind * -> * -> *, but [(v,k)] of kind *
17:01:57 <applicative-rex> :)
17:02:08 <burp> hm
17:02:15 <Cale> However, there is the logict package which provides the >>- operation that might be useful :)
17:02:20 <applicative-rex> ah
17:02:22 <applicative-rex> cool
17:02:34 <applicative-rex> does it do Cantor's diagonal product?
17:03:30 <siracusa> I need something like \k v -> [(k,v)] at type level :-)
17:03:38 <Veinor> that's what the Omega monad does iirc
17:04:04 <fax> type k v = [(k,v)]
17:04:05 <Veinor> > runOmega $ liftM2 (,) (each [0..]) (each [0..])
17:04:06 <lambdabot>   Not in scope: `runOmega'Not in scope: `each'Not in scope: `each'
17:04:17 <gloob1> hello i guys..i need to export enum..how can i do that?
17:04:42 <Cale> Omega isn't really a monad, unfortunately, so it's a little inappropriate that it defines an instance
17:05:27 <applicative-rex> cool, thanks
17:05:33 <applicative-rex> I'd love to chat but dinner calls...
17:06:08 <gwern> Veinor: why did you expect lambdabot to have Omeg installed?
17:06:17 <Veinor> couldn't hurt!
17:06:25 <EvanR> @src fibs
17:06:25 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
17:06:33 <gwern> it could've triggered a horrible bug and deleted the host!
17:06:41 <Veinor> oh noes!
17:07:12 <gwern> although I'd be perfectly happy to trash the host of lispy in exchange for revealing a major security hole in mueval :)
17:07:34 <lispy> gwern: you're evil :)
17:07:38 <XniX23_> is there a way i can write [x | x <- [1,2,3,4,5], x `mod` 2 == 0, (delete x a) /= [] ]
17:07:42 <XniX23_> where a is [1..10] so that a would change?
17:07:45 * lispy makes a note to install SELinux ASAP
17:07:46 <gwern> lispy: no, I just have a keen understanding of the greater good
17:07:57 <gwern> lispy: especially where the one suffering for the greater good ain't me
17:08:00 <siracusa> fax: Is it also possible without an extra Wrapper type synonym?
17:08:19 <gwern> XniX23_: I have no idea what you're asking
17:08:45 <EvanR> how does pattern matching work anyway, it seems so critical :S
17:08:52 <Veinor> magic!
17:09:18 <EvanR> f [] = ..., f (x:xs) = ...., how does it know which one to use for a given value
17:09:18 <monochrom> by translating to case-expression
17:09:24 <EvanR> [] and a:b are totally different
17:09:27 <XniX23_> i want to assign a value to a variable inside these brackets
17:09:35 <EvanR> monochrom: so how do those work
17:09:39 <systemfault> I'm missing something basic... How can I cast from Int -> Word64 ?
17:09:57 <Veinor> EvanR: it tries to see if f matches the 'pattern' []. if it does, it goes on
17:10:01 <monochrom> computer examines what's in memory and can tell
17:10:03 * gwern wonders if there's any encryption magic that automatically breaks/decrypts itself after a set time period without anyone doing anything
17:10:03 <Veinor> er, if the argument
17:10:03 <XniX23_> lets say id like to do something like this
17:10:16 <Veinor> gwern: digital fortreahahahahahaha I can't finisht that with a straight face. :P
17:10:20 <XniX23_> is there a way i can write [x | x <- [1,2,3,4,5], x `mod` 2 == 0, (let b = delete x a) /= [] ]
17:10:24 <XniX23_> woops
17:10:31 * gwern doesn't know Veinor's allusion
17:10:46 <XniX23_> without "is there a way i can write"
17:10:52 <monochrom> And of course "completely different" is good, not bad. If a pair of twins are not "completely different", how do you tell who's who?
17:11:02 <Veinor> digital fortress is a dan brown novel
17:11:04 <EvanR> monochrom: so, [] is a constant with value... empty list, 1:[2] is a cons. the values are typed?
17:11:13 <EvanR> err
17:11:18 <EvanR> yeah
17:11:19 <Veinor> that reveals that he knows nothing about cryptography
17:11:31 <theorbtwo> This is haskell.  *Everything* is typed.
17:11:34 <fax> uh
17:11:37 <Veinor> in particular: hand-soldering 2 million transistors to a circuit board is worthwhile, a 64-bit key takes twice as long to break as a 32-bit one
17:11:39 <monochrom> [] and 1:blah are stored in memory using different bit patterns.
17:11:40 <gwern> Veinor: well duh. he knows nothing about everything; logically he knows nothing about cryptography
17:11:42 <liyang> s/ about cryptpgraphy// <- fix'd.
17:11:42 <fax> dan brown write thing about 'bible code'?
17:11:44 <tensorpudding> Are the types typed?
17:11:44 <jmcarthur> XniX23_: i don't understand. are you wanting to delete x from a and name the result b? where are you wanting to use b?
17:12:16 <fax> not necessarily doesn't know anything but certainly doesn't care to give any accuracy...
17:12:17 <Veinor> and... oh god, it's horrible
17:12:19 <monochrom> It sounds like you need a complete CS education.
17:12:21 <Adamant> "everyone likes that Da Vinci Code book. Bullshit, I read it. It's for the dummies." - From Twitter feed 'Sh*t My Dad Says'
17:12:22 <EvanR> i know they are typed at the haskell level, but implementation, values have types there too
17:12:30 <fax> it is quite possible to know stuff and write nonsense just to get readers
17:12:42 <XniX23_> jmcarthur: i want to delete a number from b but if i do i delete n b, i get a list back
17:12:51 <XniX23_> i want that list to be a new b
17:12:53 <edwardk> fax: sure it is, just look at my blog!
17:13:03 <Adamant> fax: truth, but I don't think that is the case for Dan Brown
17:13:05 <fax> yeah exactly, abstract nonsense :P
17:13:14 <Veinor> I need to write a function, and it's either going to be called getRSSURLs or getRSSs or something similarly atrocious
17:13:17 <Veinor> :/
17:13:19 <EvanR> XniX23_: well, the list you get back has the n deleted
17:13:40 <EvanR> you cant change the value itself, only compute the answer
17:13:41 <edwardk> fax: what you don't know is i have a script that generates it all by scraping dpiponi's blog and swapping words around.
17:13:54 <gwern> it's easy to imagine a scheme - just release the key after a while. but that requires yuo to do something. and you can just make weak encryption, but then the date varies drastically from seconds for the NSA or botnetters or months and years for everyone else
17:13:55 <edwardk> Veinor: getRssUrls
17:14:00 <XniX23_> EvanR yes, now i need to store it in b somehow:)
17:14:00 <Veinor> I guess
17:14:06 <Veinor> but I already have fromHTML and fromCDATA @_@
17:14:08 <EvanR> XniX23_: you cant store stuff in variables ;)
17:14:14 <edwardk> fromHtml and fromCdata ;)
17:14:22 <gwern> what new data could become public after the release of the ciphertext? hm
17:14:38 <EvanR> XniX23_: what crazy programming method allows that ;)
17:14:46 <edwardk> you could get rid of the get and have rssURLs
17:14:51 <XniX23_> :tongue
17:14:53 <Veinor> gwern: set up an automated system to do so?
17:15:07 <XniX23_> EvanR seriously, how can i do that :D
17:15:12 <gwern> Veinor: doesn't work against an enemy who attacks you/cuts you off/murders you
17:15:13 <EvanR> im serious too
17:15:15 <EvanR> lol
17:15:27 <Veinor> hm
17:15:37 <XniX23_> lol
17:15:42 <Veinor> it relies on you knowing information in advance that few other people will know
17:16:00 <jmcarthur> XniX23_: *why* do you want this?
17:16:03 <Veinor> basically, it's only possible if you can predict the future
17:16:19 <gwern> Veinor: sure. time travel makes it trivial
17:16:30 <EvanR> told you. acausal programming
17:16:41 * hackagebot xhtml-combinators 0.2.2 - Fast and easy to use XHTML combinators.  http://hackage.haskell.org/package/xhtml-combinators-0.2.2 (AlasdairArmstrong)
17:16:51 <kynky> i predict that in a future from now that people will use IRC
17:16:59 <Veinor> gasp!
17:17:02 <lispy> Using time travel,  you can implement unsafeCoerce :: a -> b, in just 2 lines!
17:17:17 <jmcarthur> @src unsafeCoerce
17:17:17 <lambdabot> Source not found. Maybe you made a typo?
17:17:42 <Veinor> unsafeCoerce = unsafeCoerce#
17:17:50 <Veinor> :D
17:17:52 <EvanR> XniX23_: what you were describing was a database type thing. there is some data, and you delete an element from it with a command. haskell lets you do something like that with IO or State
17:18:10 <EvanR> but most problems dont require it
17:19:05 <jmcarthur> Veinor: you can actually implement it using unsafePerformIO and IORef, iirc
17:19:06 <MisterN> :t unsafeCoerce#
17:19:07 <lambdabot> Not in scope: `unsafeCoerce#'
17:19:13 <gloob1> how can i export/import structure like that please? : data MyEnum = a | b | c | d | e                     deriving (Eq)
17:20:19 <XniX23_> [x | x <- [2..1000], ([y | y <- [2..x-1], y*y < 1000, x `mod` y == 0]) == [], ([z| z <- a, z < 1000, (delete (x*z) b) /= [] ]) /= [] ] <-- thats what i want it for
17:21:22 <XniX23_> im trying to do sieve of eratosthenes, so i need to delete the multiples of primes from b list
17:21:36 <jmcarthur> XniX23_: i don't even see where you are using the result of this deletion
17:21:58 <XniX23_> jmcarthur yes, thats what i need :D to store the result in b
17:22:00 <gwern> Veinor: I suppose you could cheat a little on the problem and have subsequent messages include bits of the keys for previous messages
17:22:16 <jmcarthur> XniX23_: i think you have this all wrong ;)
17:22:25 <XniX23_> *cries*
17:22:39 <jmcarthur> Eratosthenes is the one where you iteratively remove multiples, right?
17:22:41 <XniX23_> i might not understand how data works in haskell yet
17:22:49 <XniX23_> jmcarthur yes
17:23:02 <jmcarthur> XniX23_: filter
17:23:08 <m3ga> people, anyone know if the llvm backend for ghc requires the llvm bindings from hackage or does ghc bundle its own bindings?
17:23:10 <jmcarthur> > filter even [1..]
17:23:11 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
17:23:24 <EvanR> XniX23_: to repeat a computation on the results of your computation, you use recursion or a combinator that does recursion
17:23:33 <Zao> m3ga: The Hackage packages is completely unrelated.
17:23:35 <Zao> -s
17:23:43 <zachk> @src all
17:23:43 <lambdabot> all p =  and . map p
17:23:55 <Zao> The hackage package is for emitting assorted LLVM stuff, not implementation magic for the GHC backend.
17:23:55 <zachk> @src flip
17:23:56 <lambdabot> flip f x y = f y x
17:24:11 <m3ga> Zao: thanks!
17:24:25 <jmcarthur> > filter ((`mod` 3) /= 0) . filter odd $ [4..]
17:24:26 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
17:24:27 <lambdabot>         against inferred ...
17:24:27 <EvanR> monochrom: so im thinking evaluating case expressions is a fundamental operation in evaluating programs
17:24:46 <jmcarthur> > filter ((/=0) . (`mod` 3)) . filter odd $ [4..]
17:24:47 <lambdabot>   [5,7,11,13,17,19,23,25,29,31,35,37,41,43,47,49,53,55,59,61,65,67,71,73,77,7...
17:25:04 <jmcarthur> starting to look familiar
17:25:06 <jmcarthur> ?
17:25:18 <XniX23_> that was fast lol
17:25:25 <jmcarthur> that's not the solution
17:25:29 <jmcarthur> but it's a direction
17:25:46 <byorgey> EvanR: indeed, case is one of the very few constructrs which is included in GHC's core language
17:26:02 <XniX23_> hmmmz i dont understand how that works tho :$
17:26:14 <jmcarthur> XniX23_: do you understand what filter does?
17:26:16 <jmcarthur> :t filter
17:26:17 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
17:26:32 <XniX23_> no, never used it
17:26:34 <jmcarthur> @src filter
17:26:34 <lambdabot> filter _ []     = []
17:26:35 <lambdabot> filter p (x:xs)
17:26:35 <lambdabot>     | p x       = x : filter p xs
17:26:35 <lambdabot>     | otherwise = filter p xs
17:26:41 <gwern> I remember hearing that blowfish was designed to be difficult to parallelize cracking and be adjustable. I wonder if there's a kind of encryption that's equally hard for all computers or clusters?
17:26:51 <XniX23_> i dont even understand what these information tells me yet ^^
17:27:10 <EvanR> byorgey: and it seems to be a non trivial operation ;)
17:27:18 <jmcarthur> XniX23_: filter returns a list of all the elements from the input list not matching the condition given
17:27:34 <jmcarthur> err
17:27:37 <jmcarthur> s/not//
17:27:41 <Adamant> gwern: in what sense?
17:27:52 <Adamant> you mean like, CPU vs GPU vs FPGA vs. ASIC?
17:28:18 <gwern> Adamant: takes roughly equal amounts of time to crack; there must be some sort of pathological operation that's hard to speed up
17:28:34 <jmcarthur> XniX23_: i accidently put that "not" in there because i was also thinking along the lines of saying that filter "removes" elements from the input list that don't match the given condition
17:28:37 <XniX23_> oh i see now, ty jmcarthur
17:28:39 <Adamant> equal amounts of time to crack on everything?
17:28:49 <gwern> hm. maybe memory accesses. the faster the computer these days, the bigger the penalty for accessing off-processor memory
17:29:08 <EvanR> the more you spend, the more you save mentality ;)
17:29:25 <gwern> Adamant: yeah, it'd let you have self-decrypting stuff - set the difficulty for a week, and now it will be revealed in a week or longer
17:29:45 <Adamant> that would require some kind of secured timebase
17:29:48 <Adamant> I would think
17:29:58 <Adamant> or someone external with a secured timebase
17:30:02 <gwern> Adamant: no no I mean set 'time investment to crack'
17:30:36 <gwern> (although an external clock might work through jiggery involving signatures and public/private keys)
17:31:04 <Mathnerd314> how many hpastes are there?
17:31:28 <c_wraith> unknowable.  it's open source
17:31:53 <Gracenotes> who knows if there is even a finite number of them
17:31:55 <Mathnerd314> how many are used on #haskell?
17:32:04 <Adamant> yeah, I'm sorry but I still don't really understand what you want. I mean, an ARM chip has a whole lot less resources than, say, an Amazon EC2 datacenter, but you want both to be able to decrypt things in about the same amount of time?
17:32:05 <liyang> over 9000
17:32:16 <Gracenotes> I'
17:32:24 <Gracenotes> I've only seen hpaste.org being used. or its friendly synonym.
17:32:32 <Adamant> but, the ARM would get some kind of assistance, either weaker crypto to break or external hints?
17:33:04 <Adamant> (or vice-versa, it would be scaled up for the EC2 datacenter)
17:33:16 <Adamant> ah, you mean the variable key length on Blowfish?
17:33:53 <gwern> Adamant: ideally yeah
17:34:12 <gwern> Adamant: I realize there likely exists no such operation, but it's interesting to think about
17:34:29 <Adamant> the big problem with that would be doing it for a long term.
17:35:24 <Adamant> like, especially if you're aiming at the low end, you can get very large jumps in computing power, say going from a PIC/AVR to even a cut down ARM
17:35:35 <Adamant> it's easier to estimate the high end
17:35:53 <Adamant> for the short term, it might be easier
17:35:54 <gwern> I wouldn't think it'd be too bad. whatever the pathological operation, there's a tremendous amount of inertia behind current computer design; it's not going to change just to break one obscure crypto operation
17:36:01 <gwern> and if there's one, there're probably more
17:36:19 <Adamant> it has to be pathological for decryption
17:36:25 <Adamant> not so much encryption
17:38:00 <gwern> hm. PRNGs are inherently serial, aren't they? they depend on all previous steps. maybe you could have a PRNG generating really really large keys, so large that bruteforcing the keys directly is infeasible, and the real key is how many keys deep into the PRNG you have to go
17:38:25 <Adamant> it is an interesting idea though. I don't see any compelling present use for it, but you could argue that about a lot of things we use right now when they were being developed. :P
17:38:31 <gwern> if the decryption key is the 50 trillionth output and the only way to reach it is to generate all previous keys...
17:38:31 <woggle> gwern: There are seekable CSPRNGs. Most notable is the key stream from any block cipher in CTR mode.
17:38:46 <gwern> hard to see how you could speed up cracking it with a botnet or NSA
17:39:47 <XniX23_> EvanR so what do i actually do when i say let n = [1,2,3] ?
17:39:48 <EvanR> depending on ALL previous steps?
17:39:57 <EvanR> gwern: i think we have a much more interesting generator in that case ;)
17:40:19 <EvanR> XniX23_: well its a definition of n
17:40:35 <EvanR> a constant applicative form, or in this case just a constant value
17:40:36 <XniX23_> not a variable where i can store something?
17:40:42 <EvanR> correct
17:40:42 <XniX23_> ohhh
17:40:48 <XniX23_> a constant :P
17:41:04 * Mathnerd314 counts hpaste.org, (moonpatio|unsafecoerce).(org|com|net), and unsafecoerce.net for a total of 8 hpaste domains...
17:41:06 <EvanR> yes, everything is a constant, set in stone when you write the code ;)
17:41:18 <XniX23_> hmmmz
17:41:19 <FliPPeh_> How can I suppress hsc2hs's "{-# INCLUDE ... #-}" pragmas? GHCi complains about them, and when I remove them it'll work anyways
17:41:23 <Gracenotes> Mathnerd314: they're not all the same thing? lies!
17:41:27 <XniX23_> sounds kinda hard lolz
17:41:46 <eb4890> gwern: If you did that, I'd pick random points in the prng space, and calculate from there. Hash every number and see if one of the parallel searches has found it. If so jump to where it found. Or something like that.
17:41:50 <EvanR> XniX23_: well at runtime function application happens, and its more lively
17:42:00 <Gracenotes> oh never mind, unsafecoerce is crawling with spam
17:42:13 <Mathnerd314> all of them are
17:42:34 <Mathnerd314> except hpaste
17:43:10 <gwern> EvanR: well, you'd want to make it depend on previous steps so you can't skip forward; then you can have n computers skipping forward by different amounts, and it's back to a parallel speedup
17:43:20 <XniX23_> so if i say let n = fact(100), whenever ill refer to n, it will calculate the number?
17:43:28 <Adamant> gwern: you might want to look at hashcash-type research
17:43:53 <gwern> eb4890: hm. I don't quite follow. you mean random 'points' consisting of intermediate inputs to the iterated algorithm?
17:43:58 <EvanR> gwern: if it depends on N previous steps or have a finite amount of space, then things are normal, but depending on all previous steps or infinite storage space lets you be... totally random?
17:44:44 <EvanR> XniX23_: i was about to get to that
17:45:11 <EvanR> XniX23_: now n is fact(100) which can be evaluated if you ever use it, and its some number
17:45:44 <EvanR> XniX23_: but how about let ones = 1 : ones
17:46:04 <Gracenotes> XniX23_: under some weird circumstances related to some monomorphism restriction (waaaa), it might calculate it every time, but this won't happen unless you specifically ask for it, which you shouldn't :)
17:47:50 <XniX23_> EvanR how can this ones code be valid, ones should be a list if im not mistaken?
17:47:56 <EvanR> it is
17:48:01 <gwern> Adamant: I've read a little about hashcash, but hashcash allows servers and whatnot, no? so isn't directly applicable
17:48:07 <XniX23_> oh no
17:48:10 <XniX23_> a list or a number
17:48:13 <XniX23_> ofc
17:48:15 <EvanR> a list
17:48:33 <EvanR> > let ones = 1 : ones in ones
17:48:34 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
17:48:38 <EvanR> \o/
17:48:38 <EvanR> ;)
17:49:00 <XniX23_> i dont get it :$
17:49:10 <Adamant> gwern: I mean more the crypto research it was based on. IIRC a known problem was scaling the hashcash stuff so it would work on both big desk/lap tops and for embedded/mobile devices as well
17:49:11 <EvanR> its the definition of a list with no end
17:49:27 <Adamant> which may or may not be relevant for what you want
17:49:38 <XniX23_> let ones = 1:1:1:1:1:[] should first add [] then 1 infront so it would be [1] and so on
17:49:49 <XniX23_> because the : is right associative
17:49:51 <EvanR> well i never wrote a :[]
17:49:53 <gwern> Adamant: oh. hm... might be relevant. have any links? I'm not sure what the right search terms would be
17:50:28 <EvanR> > let ones = 1 : ones in (take 6 ones)
17:50:29 <lambdabot>   [1,1,1,1,1,1]
17:50:31 <XniX23_> yes, thats whats bugging me, how can it be a list (or even know that the last thing on the end is a list)
17:50:32 <Adamant> gwern: not offhand, sadly. You could try asking in #crypto. Jafet pops in and out of here and there and may have links.
17:50:42 <Veinor> wait
17:50:50 <Veinor> why does HXT pull in the ghc package? O_o
17:50:55 <Veinor> oh wait
17:50:57 <EvanR> XniX23_: well ones is a list. so when i put ones as the right side, ... thats how it knows
17:50:59 <danderson> is there any module out there that can unencode HTML entities in a String?
17:51:01 <Veinor> no it doesn't, silly me
17:51:11 <danderson> (something that doesn't require parsing to an HTML AST, since this isn't HTML)
17:51:28 <XniX23_> EvanR why is ones a list?
17:51:33 <gwern> the hxt git repo is enormous
17:51:36 <EvanR> XniX23_: its defined as something : something
17:51:47 <EvanR> :t (:)
17:51:49 <lambdabot> forall a. a -> [a] -> [a]
17:52:08 <Veinor> it's not a darcs repo? :O
17:52:23 <EvanR> colon is the basic list constructor
17:52:24 <eb4890> gwern: I was thinking of a finite history window. And looking at different historys. I wonder if PRNGs tend to be reversible or not. If not you will get convergence. So starting from two different spots will come to the same value, eventually.
17:52:34 <gwern> Veinor: not anymore
17:52:51 <Veinor> oh wait, it does pull in ghc somehow
17:52:52 <Veinor> O_o
17:53:15 <gwern> eb4890: would a really large history window be exploitable?
17:53:59 <gwern> I don't think I've ever seen a git clone take this long before
17:55:52 <Veinor> jeez
17:56:31 <danderson> JDLSpeedy:
17:56:34 <danderson> gah
17:56:39 <danderson> sorry, irc client fail.
17:57:41 <XniX23_> EvanR if i say let n = 1:2:3:4:[], the first one added will be 4
17:58:00 <EvanR> XniX23_: well, that code doesnt really DO anything does it?
17:58:27 <gwern> Veinor: I don't see ghc anywhere in the hxt .cabal deps
17:58:35 <EvanR> XniX23_: let n = 1:2:3:4:[] in n, on the otherhand does, and the first thing to be evaluated will be the 1:...
17:58:42 <FliPPeh_> How can I suppress hsc2hs's "{-# INCLUDE ... #-}" pragmas? GHCi complains about them, and when I remove them it'll work anyways :/
17:58:46 * FliPPeh_ spams
17:59:02 <XniX23_> EvanR a list [1,2,3,4]
17:59:13 <EvanR> play computer
17:59:40 <XniX23_> what do you mean?
18:00:05 <EvanR> n -> 1:2:3:4:[] -> [1]:2:3:4:[] -> [1,2]:3:4:[] -> [1,2,3]:4:[] -> [1,2,3,4]:[] -> [1,2,3,4] ;)
18:00:19 <EvanR> hrm, that doesnt look right!
18:00:29 <tensorpudding> Wrong way
18:00:40 <EvanR> ok 4:[] first
18:00:40 <tensorpudding> 1:2:3:4:[] -> 1:2:3:[4]
18:00:41 <XniX23_> infix 5 :
18:00:43 <Veinor> gwern: I think one of its dependencies pulls it in
18:00:59 <XniX23_> its right associative, it should solve from right to left
18:01:09 <XniX23_> infixr 5 :   even
18:01:30 <EvanR> XniX23_: you were right. and thats how 1:ones works too. theres only 1 : to deal with there
18:01:30 <langtree> It solves it as 1:(2:(3:(4:([]))))
18:02:04 <EvanR> so if you have 1:(1:(1:(1:... then head on that is 1
18:02:17 <langtree> So, ones above is 1:(1:(1:...
18:03:36 <XniX23_> yes, but it cant add to head, because the priority is higher on the right side (to infinity)
18:03:46 <langtree> No.
18:03:58 <Gracenotes> infixr is just about how it interprets the syntax
18:04:12 <langtree> There is no order of operations, since Haskell doesn't have to evaluate the head or tail until it's told to.
18:04:17 <EvanR> XniX23_: the whole expression (which is infinite anyway) will not be computed all at once
18:04:22 <langtree> It evaluates either when needed.
18:06:10 <XniX23_> ohh..
18:06:32 <eb4890> gwern: I'm not sure. My instinct says a bigger window is better.  You have to get window length number of collisions in a row for it to converge properly.
18:07:19 <Gracenotes> XniX23_: somewhere in memory, suppose you have n defined as 1:2:[]. if you ask it to give you the next bit of info about n, it'll give you a (:) node with 1 and rest-of-the-list. If you ask about the rest of the list, it'll say that it's 2 and rest-of-that-list. If you ask further, it'll say the rest of that list if just [], the empty list.. there's nothing more.
18:07:39 <Gracenotes> *is just
18:07:58 <XniX23_> sounds like in prolog
18:08:14 <Gracenotes> for ones = 1:ones, you can keep on asking about the rest of the list again and again and it'll never end, like it's an evil loop
18:08:28 <EvanR> evil!
18:08:58 <gwern> Gracenotes: you go to I-CON?
18:09:00 <XniX23_> so basicaly what it does when i do 1:2:3:4:a is that it does [1] -> [1,2] -> [1,2,3] -> [1,2,3,4] -> Error ?
18:09:16 <EvanR> no
18:09:54 <Gracenotes> gwern: I didn't have the foresight for the magnitude of the fee, but I did hang about in the SAC
18:09:57 <monochrom> kiddy math taught you "order of operations". it was right because parsing and evaluating were merged. worked for kiddy math. but here parsing and evaluating are divorced, precedence only talks about parsing.
18:10:05 <gwern> Gracenotes: fee? learn about volunteering, plox
18:10:08 <EvanR> XniX23_: think of it as 1:(2:(3:(4:a)))
18:10:25 <Gracenotes> gwern: didn't have the foresight for that either, lol.
18:10:35 <gwern> foresight? you could sign up at any time
18:10:49 <gwern> although it gets harder to get 8 hours the longer in the weekend you wait :)
18:11:08 <eb4890> Speaking of prologish things, anybody played with curry? http://en.wikipedia.org/wiki/Curry_(programming_language). Is it useful?
18:11:33 <Gracenotes> gwern: did not parse
18:11:47 <XniX23_> EvanR it has to add them somehow, else the ones recursion would not add a single element.... or maybe i should go read some tutorial :D
18:11:49 <gwern> Gracenotes: error messages should come with line and column numbers
18:12:05 <EvanR> XniX23_: nothing is adding anything to anything, that IS the expression. all you did was write it. you didnt do any operation on it
18:12:08 <monochrom> Perhaps it's a mistake to merge parsing and evaluating for even kiddy math.  0 * (2398493 + 3982934) who is going to strictly follow the order and evaluate 2398493 + 3982934 first anyway?
18:12:17 <FliPPeh_> GAHHH
18:12:18 <Gracenotes> neuron #483291 would like to have a word with you
18:12:19 <EvanR> heh
18:12:23 <FliPPeh_> How do I get GHCI to shut up?
18:12:45 <FliPPeh_> include deprecated, no effect
18:13:09 <gwern> Gracenotes: but seriously, that's how volunteering works. you get a ticket and promise to work 8 hours at some point
18:13:52 <XniX23_> i think im thinking too much procedural here -.-'
18:13:54 <benmachine> XniX23_: the [1,2,3] syntax for lists is just a nicer way of writing 1:2:3:[], they mean exactly the same thing
18:14:15 <benmachine> 1:2:3:[] is : applied to the first element 1 and the list 2:3:[]
18:14:36 <XniX23_> they mean, or they end up being the same when 1:2:3:[] is "transformed" into [1,2,3,4] ?
18:14:45 <benmachine> there is no transformation
18:14:51 <benmachine> they are two ways of writing the same thing
18:14:58 <gwern> the question, said alice thoughtfully, is whether one word can mean so many things
18:14:59 <Gracenotes> er, 1:2:3:4:[]
18:15:00 <benmachine> to the compiled code they look exactly the same
18:15:35 <Gracenotes> gwern: did you go to see anything?
18:15:40 <gwern> if course
18:15:49 <XniX23_> yes but compiler does that or am i wrong?
18:16:19 <pikhq> XniX23_: The transformation is from [1,2,3,4] *to* 1:2:3:4:[].
18:16:32 <EvanR> and from 1:2:3:4:[] to a graph ;)
18:16:32 <benmachine> yeah
18:16:42 <benmachine> erm
18:16:45 <XniX23_> oh i see now ^^
18:16:46 <EvanR> and from a graph to machine code
18:16:53 <benmachine> well
18:16:58 <benmachine> that's all implementation detail
18:17:02 <EvanR> yeah
18:17:04 <benmachine> there are lots of ways of doing that bit
18:17:16 <monochrom> and from machine code to magnetic core alignment
18:17:25 <EvanR> the spirit inside the computer!
18:17:30 <benmachine> but the bit about [1,2,3,4] being the same as 1:2:3:4:[] is essential to the language
18:17:36 <pikhq> Bit more like ((:) 1 ((:) 2 ((:) 3 ((:) 4 [])))) first, I *think*. (*is* that the desugaring in Core)
18:17:36 <benmachine> every implementation has to obey that rule
18:17:40 <pikhq> ?
18:17:49 <monochrom> the phantom of the computer is there, inside the core...
18:17:50 <Gracenotes> eventually, let n = [1,2] in length n, might get transformed to: let c = [] in (let b = 2:c in (let n = 1:b in (length n)))
18:17:59 <monochrom> the phantom of the computer is there, inside the MIME...
18:18:30 <gwern> EvanR: I think you mean, the ghost in the shell
18:18:34 <pikhq> Likewise, [a..b] is desugared into enumFromTo a b...
18:18:39 <FliPPeh_> Anyone using hsc2hs here?
18:18:39 <EvanR> gwern: never saw it ;)
18:18:44 <danderson> wow, that's a combination of the nicest and ugliest hack I ever did
18:18:56 <monochrom> beauty and the beat?
18:19:02 <monochrom> oh bother typo
18:19:04 <Gracenotes> and the bit
18:19:10 <monochrom> hahaha
18:19:18 <XniX23_> but i still dont get how from 1:(2:(3:(4:([])))) compiler gets [1,2,3,4], what are the steps
18:19:28 <benmachine> XniX23_: what do you mean by "gets"
18:19:36 <danderson> grabbed the HTML entities map out of Python, emacs macro'd it into [(String, Int)], mapped an O(n) string replace over each tuple, and did a foldl' (.) id on the lot
18:19:37 <benmachine> XniX23_: why does it need to?
18:19:47 <monochrom> The compiler never goes back to [1,2,3,4].
18:19:51 <danderson> the result, one massive String -> String function that unescapes HTML entities
18:20:02 <danderson> and is O(n*m) on the size of the input and the number of entities
18:20:10 <monochrom> The compiler doesn't turn machine code into source code either.
18:20:13 <EvanR> XniX23_: the important part is the expression for the list. you can do computations on it, but you are stuck on the definition part
18:20:24 <Gracenotes> danderson: I salute you. well, better than doing a DFA-esque replacer by hand
18:20:33 <benmachine> danderson: foldl'? is seqing function composition actually any use?
18:20:48 <danderson> benmachine: dunno, my fingers kinda defaulted to that.
18:21:04 <benmachine> heh
18:21:05 <benmachine> okay
18:21:19 <XniX23_> oh i get now how this works lol, i thought that the "compiler official" form is [1,2,3,4] and not 1:2:3:4:[] ^^
18:21:24 <EvanR> XniX23_: write 1:(2:(3:(4:[]))) on your paper and try to evaluate "length (1:(2:(.... )))" with this
18:21:27 <EvanR> @src length
18:21:27 <lambdabot> Source not found.
18:21:31 <EvanR> >_<
18:21:34 <Gracenotes> what
18:21:58 <danderson> Gracenotes: a DFA would be nice for a libified version of this (hackage is conspicuously missing any kind of way to escape/unescape HTML entities)
18:21:59 <benmachine> > foldr (\_ xs -> 1 + xs) 0 [1,2,3,4,5]
18:22:00 <lambdabot>   5
18:22:02 <benmachine> everything is a foldr.
18:22:25 <Gracenotes> everything is TM tape
18:22:26 <danderson> but I just needed this function to clean up a database dump (converting a mysql-based blog to hakyll, need the raw text)
18:22:29 <EvanR> XniX23_: with length [] = 0; length (x:xs) = 1 + length xs
18:22:38 <danderson> so I haxxored it up.
18:22:39 <XniX23_> benmachine im sorry, i dont know haskell that well yet, its my second day using it so im obviously a noob
18:23:11 <benmachine> XniX23_: do not apologise for being new
18:23:12 <benmachine> well
18:23:14 <benmachine> you can if you like
18:23:17 <Gracenotes> it's times like these when I wished my graphics skills were better so I could finish my STG visualizer
18:23:18 <benmachine> but there is no obligation
18:24:23 <ddarius> Gracenotes: You can't draw squares and lines?
18:24:45 <mibygl> Can GHCi give me a list of everything defined in a given module?
18:24:57 <XniX23_> im wondering if knowing the language in that depth might affect my thinking...
18:25:02 <Gracenotes> and text. I wouldn't do it without actually showing the movement of things, though
18:25:04 <benmachine> mibygl: try :browse modulename
18:25:08 <EvanR> XniX23_: yes, which is good!
18:25:11 <benmachine> (you don't even need to import it iirc)
18:25:18 <Gracenotes> including the heap, and code segments themselves
18:25:26 <mibygl> benmachine: thanks.
18:25:28 <XniX23_> i've experienced in prolog that thinking too much what compiler will do is bad
18:26:27 <Gracenotes> well, prolog has cuts and other things that rely on your knowledge of how it works to tune its performance
18:26:31 <ddarius> XniX23_: You have to with Prolog.
18:26:50 <EvanR> XniX23_: the main moral to learn from functional is to do as much as you can in terms of computations, define your terms and combine functions to get the answer. rather than using commands to change values somewhere in some sequence
18:26:57 <ddarius> XniX23_: Other logic languages, admittedly none with anywhere near the traction of Prolog, handle this -much- better.
18:27:26 <Gracenotes> otherwise you could blow up a simple algorithm into exponential time, easily..
18:27:55 <EvanR> is haskell really meant for logic programming?
18:29:31 <mibygl> Gee, the Agda module is kind of complicated.
18:30:33 <wavewave> any good tutorial for parallel computation?
18:30:45 <wavewave> I am lost.
18:31:03 <XniX23_> i think ill have to continue reading my tutorial from where i left :D
18:31:16 <wavewave> par pseq ...
18:32:04 <byorgey> wavewave: maybe something here: http://research.microsoft.com/en-us/um/people/simonpj/papers/parallel/ ?
18:32:05 <wavewave> I am calculating some list.. and simply want to splice the list into 4-8 to feed them into multicore.
18:32:07 <XniX23_> btw... do i need to think prolog-like in that language to ease my coding?
18:32:23 <XniX23_> the head tail thing and all that..
18:32:55 <FliPPeh> I'm freaking out here
18:34:53 <Mathnerd314> FliPPeh: have you freaked out *enough*?
18:35:02 <FliPPeh> Mathnerd314: Probabl
18:35:03 <FliPPeh> y
18:35:28 <monochrom> Parallel haskell programming is a lot of parseqs away.
18:35:41 <wavewave> byorgey: it seems to me helpful. thx.
18:37:03 <wavewave> any further manual  on Control.Parallel.Strategy?
18:37:15 <FliPPeh> Is hsc2hs developed synchronously with GHC?
18:38:07 <Mathnerd314> FliPPeh: why are you using ghci instead of just ghc?
18:38:11 <FliPPeh> It includes the darn {-# INCLUDE #-} pragmas that GHC will complain over, there's no way to surpress that, OR the error message.
18:38:17 <wavewave> I am reading RWH chap 24, and got lost in Control.Parallel.Strategy..
18:38:21 <FliPPeh> Because I have no main module yet
18:38:28 <FliPPeh> And it's annoying when testing what I have so far
18:38:32 <FliPPeh> also way faster
18:39:10 <netytan> Hi guys. Its, I'd like to create a little function which returns 7 for 7, and 2 for everything else. Could someone show me how do write the pattern matching for this?
18:39:25 <FliPPeh> f 7 = 7
18:39:27 <FliPPeh> f _ = 2
18:39:38 <netytan> FliPPeh: you don't need parens?
18:39:43 <FliPPeh> Why so?
18:39:43 <jmcarthur> nope
18:39:45 <gloob1> is there any possible way how to empty data from channel?
18:39:59 <netytan> Thanks guys.
18:40:03 <FliPPeh> No prob!
18:43:54 <danderson> (isAlphaNum &&& isSpace >> uncurry (||))
18:43:54 <XniX23_> good night everyone, sweet dreams and thanks for help
18:44:06 <danderson> there must be an even less comprehensible way of stating that
18:44:20 <danderson> s/>>/>>>/
18:44:47 <Veinor> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24541#a24541
18:44:52 <Veinor> is there a more elegant way of writing that?
18:45:08 <wavewave> I ask more specific questions. How does parListChunk operate?
18:45:14 <Veinor> rssUrls is type String -> IO [String]
18:45:54 <Veinor> and getContent is too.
18:45:57 <wavewave> I have very long list of same operation and want to divide them to 2-4 threads basically.
18:46:00 <danderson> Veinor: first, I'd use Control.Applicative's <$> instead of liftM, to keep the flow
18:46:08 <danderson> eg. url <- head <$> getArgs
18:46:16 <Veinor> well, besides that
18:47:10 <danderson> Veinor: that seems the most readable.
18:47:44 <Veinor> (for the curious, I have a URL for a site, and I want to get the content of all the items in its rss feed)
18:48:20 <danderson> you could be naughty and fold everything into operators, eg. getContent =<< (head <$> rssUrls) =<< head <$> getArgs
18:48:38 <fsharp> guys does haskell have something like Clojure transients http://clojure.org/transients ?
18:49:09 <Veinor> yes, but ew
18:49:17 <Veinor> replying to danderson, dunno about transients
18:49:22 <danderson> hmm, actually, getContent . head =<< rssUrls . head =<< getArgs
18:49:33 <danderson> I wish I knew how to fold those heads away
18:50:06 * Veinor shrugs
18:50:11 <Veinor> maybe I should write a haskell rss parser
18:50:20 <danderson> well, you could always define <-< to smush head and =<< together
18:50:31 <danderson> but I'll stop now :P
18:50:40 * Veinor recoils in horror
18:50:57 * danderson backs away slowly from ghci
18:51:17 <danderson> Veinor: and re: haskell RSS parser
18:51:21 <danderson> you may incur brain damage
18:51:29 <Veinor> because of RSS?
18:51:41 <danderson> RSS is quite, quite mad
18:51:46 <Veinor> I am well aware that it is quite mad
18:51:59 <Veinor> I intend to stave off insanity by being very, very simple and not bothering to look at the standards :D
18:52:03 <danderson> but if you're willing to go mad, then yeah, it would be useful :P
18:52:06 <danderson> oh, that also works :D
18:52:13 <FliPPeh> I think XML is the worst invention ever made
18:52:33 <Veinor> in other words, I test it by running it against a wordpress site, slashdot, ars technica, and a couple other random sites
18:53:12 <Veinor> hm, it fails on the bbc
18:53:31 <Veinor> time to investigate why!
18:53:52 <danderson> lucky you; at work, we have to parse any and all standards-compliant RSS feeds
18:54:01 <Veinor> I'm sorry :(
18:54:05 <danderson> with warnings, correctly ignoring stuff we don't recognize...
18:54:31 <danderson> fortunately, I didn't have to write it.
18:54:32 <AlexM> Hry
18:54:35 <Veinor> okay, bbc.co.uk doesn't have an rss feed attached to it apparently
18:54:38 <AlexM> if*Hey
18:54:39 <AlexM> *Hey
18:54:40 <Veinor> that explains why it was failing to find one!
18:54:53 <AlexM> if something returns ST a you can't get just the a right?
18:55:03 <danderson> Veinor: try natulte.net ?
18:55:18 <danderson> last I checked, the feeds were supposed to be compliant
18:55:19 <benmachine> AlexM: if something returns (forall s. ST s a) then you can get the a
18:55:22 <benmachine> :t runST
18:55:23 <lambdabot> forall a. (forall s. ST s a) -> a
18:55:28 <Veinor> danderson: works
18:55:31 <AlexM> hmm
18:55:37 <benmachine> AlexM: I realise that complicated your question a bit :)
18:55:40 <benmachine> but try runST
18:55:42 <AlexM> yeah
18:55:52 <benmachine> but also it might not be exactly what you wanted?
18:55:54 <benmachine> I'm not sure
18:55:55 <AlexM> well
18:56:10 <AlexM> I need to get Inst
18:56:15 <AlexM> but this thing: fst $ fst $ apply (compile p l) l
18:56:19 <AlexM> returns ST Inst
18:56:23 <AlexM> so, I'm screwed :S
18:56:32 <danderson> runST would be what you want then
18:56:33 <benmachine> are you sure it's ST Inst and not ST s Inst
18:56:42 <Veinor> this is a choice sentence I got from running it on natulte:  What do I mean by changelogs? Historically, the term has meant something akin to "Our version control logs are machine code, this is damn fun !
18:56:43 <AlexM> yes, it's ST Inst
18:56:49 <Veinor> er, pair of sentences
18:56:49 <benmachine> weird
18:57:08 <benmachine> ST as in Control.Monad.ST?
18:57:16 <danderson> Veinor: er, that's wrong
18:57:23 <Veinor> yes, I know
18:57:28 <danderson> looks like you have a run-on set of paragraphs :)
18:57:31 <Veinor> it's a markov bot :P
18:57:36 <danderson> aah.
18:57:54 <danderson> then it makes complete sense and I'm happy to have contributed. Carry on :D
18:57:54 <Veinor> I call it 'dissociated blogosphere'
18:57:55 <benmachine> markov is a genius
18:57:58 <benmachine> was
18:58:08 <Veinor> a term which I am very happy to see does not already exist
18:58:13 <danderson> Veinor: I wrote one at one point that was also an IRC bot
18:58:18 <Veinor> ooh
18:58:23 <Veinor> I'm going to make this a web service
18:58:28 <danderson> you could ask it what it thought of <WORD>
18:58:35 <FliPPeh> Meh
18:58:40 <benmachine> benmachine.co.uk/cgi-bin/markov.cgi
18:58:40 <danderson> it would look that word up on Wikipedia, suck down the article that best matches
18:58:46 <SamB_XP> Veinor: it needs to learn to balance "
18:58:47 <FliPPeh> I'll just comment out the INCLUDE pragmas
18:58:47 <benmachine> oh, nice
18:58:47 <danderson> and produce a random "summary" of the article
18:58:51 <pastorn> is there a simpler way to do some super version of fmap over an array? what i want to do is to use a function :: (Ix i) => (i -> a -> (j,b)) -> Array i a -> Array j b
18:58:51 <Veinor> so you go to the URL, you give it a list of sites
18:59:03 <AlexM> benmachine: no, > data ST a = S (State -> (a, State))
18:59:07 <Veinor> and it mashes them all together and creates a new article
18:59:19 <Veinor> SamB_XP: how?
18:59:25 <Gracenotes> pastorn: Ix j, too?
18:59:25 <benmachine> AlexM: ah, you should really have said
18:59:36 <danderson> using that process, I did end up getting it to talk about how the president eats croissants and guns for breakfast
18:59:39 <danderson> which was nice.
18:59:41 <benmachine> AlexM: in order to get a value out of that you need a State value
18:59:54 <Veinor> haha
19:00:03 <Veinor>  http://github.com/veinor/dissociated-blogosphere/blob/master/dissociated-blogosphere.hs if you're curious
19:00:09 <pastorn> Gracenotes: not necesarily
19:00:21 <AlexM> oh wait
19:00:27 <gloob1> is there any possible way how to empty data from channel?
19:00:30 <AlexM> I didn't know you could have returns inside returns
19:00:34 <AlexM> That's fixed it
19:00:37 <Veinor> SamB_XP: I don't think you can balance quotes in markov chains without doing something really, really weird, like running until your quotes are balanced :P
19:00:42 <benmachine> AlexM: return is just a function, remember
19:00:43 <AlexM> I can return while I return ;)
19:00:48 <AlexM> LOL
19:00:52 <Gracenotes> pastorn: ..that would be somewhat difficult, with all the array creation methods requiring it
19:00:55 <pastorn> Gracenotes: the imortant thing is that the function i feed it depends on the array index
19:00:59 <benmachine> it's not magic like in C or whatever else
19:01:00 <AlexM> See, who said memes were useless...
19:01:40 <Gracenotes> pastorn: probably best bet is a to-list-from-list sort of thing
19:01:43 <pastorn> Gracenotes: shouldn't it be easy? just allocate an array of equal size, feed ix+elem to fun and put result in new array
19:01:51 <pastorn> Gracenotes: awww....
19:01:55 <danderson> Veinor: you can do an ugly approximation, eg. insert the closing quote at the next punctuation mark
19:01:55 <pastorn> Jonno_FTW: hello
19:02:06 <danderson> which would end up closing the quote around the end of a sentence, or around a comma
19:02:09 <Veinor> yeah, I need to do some postprocessing on the output text
19:02:12 <pastorn> Gracenotes: thanks
19:02:17 <Veinor> like removing spaces that come before periods
19:02:19 <Gracenotes> pastorn: I don't get how you can even determine equal size from i and j being different
19:02:22 <danderson> of course, it probably won't make any sense, but that's the whole point :)
19:02:30 <Jonno_FTW> how do i use Yi?
19:03:08 <Veinor> hm
19:03:15 <Veinor> I think this would work a lot better with a larger corpus
19:03:20 <Veinor> so, multiple sites
19:03:29 <Gracenotes> either that, or look at the source of GHC.Array and try to roll your own stuff, but it won't end up being too dissimilar from a list approach in the end, methinks
19:03:58 <pastorn> Gracenotes: maybe a *little* faster
19:04:00 <pastorn> like 2 ms
19:04:15 <danderson> Veinor: grab a wikipedia article dump and feed that in
19:04:20 <pastorn> *performance* *performance* *performance*
19:04:24 <Veinor> no, it doesn't have a fixed corpus
19:04:31 <danderson> 650GB of text input, that would be acceptable, no?
19:04:33 <Veinor> you give it URLs as corpus and it pulls stuff from their RSS feeds
19:04:48 <pastorn> Jonno_FTW: use VIM
19:04:50 <danderson> right, just suggesting how to bootstrap with a crapload of data :)
19:04:55 <pastorn> Jonno_FTW: more h4xx0r
19:04:55 <Veinor> so I give it ars technica, I get a new ars post
19:05:10 <Veinor> except it tends to have a lot of Read More-type stuff
19:05:22 <danderson> no cross-pollination?
19:05:30 <Veinor> what do you mean?
19:05:32 <danderson> you read one site, generate something for that site, and drop the data?
19:05:43 <danderson> or do you accumulate data from multiple sources as time goes on?
19:05:51 <Veinor> the former
19:06:16 <Veinor> which has obvious limitations as to the amount of text I can use
19:07:07 <Jonno_FTW> screw vim
19:07:08 <Jonno_FTW> i want yi
19:07:18 <pastorn> :(
19:07:25 <pastorn> cabal install yi?
19:07:30 <Veinor> I think it'd be really good if I could get a corpus from, like, language log, slashdot, ars, and... I don't know, lifehacker
19:07:37 <Jonno_FTW> it says it's installed
19:07:46 <pastorn> just run it then!
19:07:50 <Jonno_FTW> how?
19:07:56 <pastorn> $ yi
19:07:59 <FliPPeh> Man
19:08:01 <Jonno_FTW> yi does nothing at the command lin
19:08:02 <Jonno_FTW> e
19:08:04 <FliPPeh> Things get NASTY with FFI
19:08:12 <AlexM> benmachine: any idea what this means
19:08:12 <AlexM> afpcwk2.lhs:130:88:
19:08:12 <AlexM>     No instance for (Monad ((,) [Inst]))
19:08:13 <AlexM>       arising from a use of `return' at afpcwk2.lhs:130:88-98
19:08:13 <AlexM>     Possible fix: add an instance declaration for (Monad ((,) [Inst]))
19:08:13 <AlexM>     In the second argument of `($)', namely `return (p')'
19:08:13 <Veinor> "Tinkle writes "Toshiba's R & D Labs in Cambridge, UK have developed a system capable of real-time 3D modeling of the iPad as well as an order to stop selling the mobile device along with iPhones, iPods and Macs."
19:08:14 <AlexM>     In the first argument of `(++)', namely `(fst $ return (p'))'
19:08:16 <AlexM>     In the second argument of `(++)', namely
19:08:17 <Veinor> \o/
19:08:18 <AlexM>         `(fst $ return (p')) ++ [JUMP l'] ++ [LABEL l'']'
19:08:20 <pastorn> Jonno_FTW: $ yi someFile
19:08:20 <AlexM> Failed, modules loaded: none.
19:08:28 <benmachine> AlexM: oh my goodness pastebin
19:08:30 <AlexM> (Should have pastebinned it, i'm late + tured...)
19:08:32 <AlexM> *tired
19:08:36 <AlexM> Haha, see
19:08:58 <benmachine> you are using return in a context that suggests it should have type ([Inst], a)
19:09:01 <danderson> Veinor: it's scary how that almost makes as much sense as the usual articles :)
19:09:04 <benmachine> but that type isn't a monad, so return can't have that type
19:09:16 <Jonno_FTW> it says there is no command 'yi'
19:09:20 <AlexM> :|
19:09:22 <Veinor> danderson: I'm picking choice results here.
19:09:36 <FliPPeh> Jonno_FTW: Installed with cabal?
19:09:38 <Veinor> 'The US Department of Transportation's National Highway Traffic Safety Administration today said it was early afternoon. Instead, it was early afternoon.'
19:09:39 <Jonno_FTW> yes
19:09:47 <FliPPeh> It's probably not in your $PATH
19:09:54 <FliPPeh> Try ~/.cabal/bin/yi
19:09:59 <Veinor> haha
19:10:00 <Veinor> 'The US Department of Transportation's National Highway Traffic Safety Administration today said it was early afternoon. Instead, it was early afternoon.'
19:10:03 <Jonno_FTW> when i do cabal install yi, it says it's installed
19:10:04 <Veinor> whoops
19:10:09 <FliPPeh> Try ~/.cabal/bin/yi
19:10:10 <Veinor> "If you want to solve a major engineering mystery, why not bring in some of the world's first electric underpants that let you know that loses features throughout its lifecycle."
19:10:34 <AlexM> Oh
19:10:35 <AlexM> It works
19:10:36 <pastorn> export PATH=$PATH:~/.cabal/bin  # put this line in your .bashrc Jonno_FTW
19:10:45 <Jonno_FTW> ok thanks
19:10:51 <AlexM> benmachine: thanks! sorry for not pastebinn'ing the code..
19:11:03 <pastorn> Jonno_FTW: it might make do if you run hash after tat
19:11:05 <Veinor> don't you want PATH=~/.cabal/bin:$PATH
19:11:06 <Veinor> ?
19:11:06 <FliPPeh> ;q
19:11:07 <FliPPeh> Whoops
19:11:10 <FliPPeh> Ths is not vim
19:11:14 <pastorn> but you might have to start a new shell
19:11:26 <ddarius> FliPPeh: Wouldn't have worked in vim.
19:11:35 <FliPPeh> I know, semicolon
19:11:39 <FliPPeh> But it was meant to go to vim!
19:13:23 <Jonno_FTW> where in .bashrc do i put this?
19:13:30 <FliPPeh> Somewhere
19:13:53 <edwardk> > (zip <*> tail) [1..10]
19:13:54 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10)]
19:14:21 <FliPPeh> :t <*>
19:14:22 <lambdabot> parse error on input `<*>'
19:14:28 <FliPPeh> :t (<*>)
19:14:29 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
19:14:33 <FliPPeh> :t fmap
19:14:34 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
19:14:46 <Jonno_FTW> is it possible to make
19:14:51 <Jonno_FTW> Yi like Nano?
19:15:12 <edwardk> :t (zip <*>)
19:15:13 <lambdabot> forall a b. ([a] -> [b]) -> [a] -> [(a, b)]
19:16:46 <edwardk> > (zip <*> init) [1..10]
19:16:47 <lambdabot>   [(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9)]
19:16:52 <edwardk> how boring =)
19:17:32 <FliPPeh> Yi has an awful lot of dependencies
19:20:21 <pastorn> is there much overhead in reading an IORef
19:20:29 <pastorn> i have an index list and vertex array
19:20:37 <pastorn> both in IORefs
19:21:25 <pastorn> how expensive would it be to do 'readIORef' on my vertex array every time i want a vertex?
19:22:26 <Pseudonym> pastorn, readIORef is essentially just a pointer.
19:22:43 <Pseudonym> So it's much the same as any other dereference.
19:22:57 <Pseudonym> If it's in cache, it's cheap. :-)
19:22:59 <pastorn> i assume it's fast then?
19:23:04 <pastorn> heh, ok
19:23:23 <pastorn> well, it's going to work on an array, but the trouble is that this is haskell
19:23:34 <pastorn> so i don't really know where the *actual* values will be :)
19:25:09 <edwardk> hrmm can you get at the current line and file name from template haskell in a usable way?
19:25:14 <[swift]_> is there a library function in haskell for computing the cartesian product of two lists?
19:25:22 <edwardk> i could have sworn i did it before, but i'm blanking on how
19:25:26 <[swift]_> can't find one on hoogle
19:25:36 <ddarius> [swift]: liftM2 (,)
19:25:39 * edwardk remembers, jmacro did it.
19:25:43 <ddarius> or liftA2
19:26:41 <[swift]_> ddarius: hmm, i'll have to think a bit to understand how that works
19:26:50 <pastorn> [swift]_: you want zip
19:26:53 <pastorn> @type zip
19:26:54 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
19:26:56 <edwardk> pastorn: following an ioref is pretty cheap =)
19:27:07 <edwardk> pastorn that won't yield a cartesian product
19:27:09 <ddarius> [swift]_: Do you understand how [(x,y) | x <- xs, y <- ys] works?
19:27:10 <[swift]_> pastorn: that's not the cartesian product, tho, is it?
19:27:23 <pastorn> http://en.wikipedia.org/wiki/Cartesian_product
19:27:30 <pastorn> oh, that
19:27:32 <pastorn> sorry
19:27:32 <Gracenotes> zip gives you a sort of piecewise.. er, product
19:27:34 <pastorn> uhm..
19:27:37 <[swift]_> ddarius: haha, i haven't actually used list comprehensions so far in haskell
19:27:50 <ddarius> [swift]_: I rarely use them.
19:27:55 <pastorn> [swift]_: cart xs ys [ (x,y) | x <- xs, y <- ys ]
19:27:57 <edwardk> > [(x,y) | x <- [1,2] | y <- "abc" ]
19:27:58 <lambdabot>   [(1,'a'),(2,'b')]
19:28:04 <edwardk> that is zip
19:28:11 <edwardk> with , it is cartesian =)
19:28:21 * ddarius dislikes parallel list comprehensions.
19:28:32 <edwardk> ddarius: me too, they don't generalize nicely
19:28:54 <[swift]_> edwardk: hmm, this is very interesting!
19:29:05 <ddarius> edwardk: In my opinion, they are rarely (if ever?) a syntactic win.  They strike me as neither clearer nor conciser than an explicit zip.
19:29:32 <edwardk> ddarius: maybe if you had a bunch of guards mixed in, but i confess i've never seen that case ;)
19:31:11 <jbapple> Are there any Haskell libraries that are extracted from provably correct (to some particular specification) code?
19:31:16 <jbapple> http://mattam.org/research/russell/fingertrees.en.html
19:31:38 <[swift]_> ddarius: wow, reading about the list monad because of your liftM2 recommendation. i wish i had known about this earlier!
19:31:54 <jbapple> That's a start, but the ICFP paper seems to indicate that the extracted code is not used because of performance problems
19:32:07 <jbapple> (Section 6)
19:33:11 <edwardk> jbapple: well, mattam there has a bunch of stuff including a haskell prelude for coq, but i doubt they extract into anything pretty
19:33:25 <edwardk> jbapple: the galois folks do a lot of haskell proving.
19:33:51 <jbapple> edwardk: I had forgotten about the galois people, good point!
19:34:21 <edwardk> jbapple: in general haskell program extraction from coq winds up rather hideous
19:34:49 <edwardk> it is hard to use idiomatic native constructors, it loves to use Magic even when it doesn't need to, etc.
19:35:09 <jbapple> I am asking because I would like to see how other people are doing it, so open-source (or at least a description of the details) would be helpful.
19:35:23 <edwardk> it is hard to get something out of it that both the coq programmer and the haskell programmer can look at and say is both obviously correct and remotely idiomatic
19:35:43 <jbapple> I am moderately surprised about Magic.
19:36:09 <mm_freak> SPJ and greg morrisett proposed support for extensible records in haskell
19:36:13 <mm_freak> http://research.microsoft.com/en-us/um/people/simonpj/Haskell/records.html
19:36:19 <jbapple> I would not put "obviously correct" high on my list of wants if I were extracting from a Coq development that were proved correct
19:36:23 <mm_freak> that's the current state of this?  will this ever make it into haskell?
19:36:40 <mm_freak> perhaps as a GHC extension?
19:36:54 <edwardk> jbapple: my main goal would be to have the resulting library at least feel like a haskell lib, using prelude constructors, etc. you can do a lot of that but it is a lot of work
19:36:55 <ddarius> Magic with a capital 'M'.  Oh my!
19:38:01 <edwardk> mm_freak: like all haskell record proposals it is sitting in a wastebin somewhere or under a pile of other work to be done
19:38:21 <ddarius> mm_freak: There are -many- proposals to add "extensible records"/"first class modules" to Haskell.  The problem is that there are too many of them and no one seems to stand out particularly from the others.
19:38:30 <Cale> I think that particular proposal is awful compared to some others
19:38:40 <edwardk> and half of them want to overload . yet again ;)
19:38:51 <Cale> Yeah, especially the terrible syntax
19:39:01 <Pseudonym> This might just be me, but I don't think that the record problem can be solved without first solving the namespace problem.
19:39:01 <ddarius> edwardk: Might as well.  Do you want to castigate yet another identifier?
19:39:04 <Cale> Reusing the period is out of the question, in my mind.
19:39:06 <netytan> Hi guys. It's possible that I'm mistaken but pattern matching is a strictly top-down affair yes?
19:39:15 <jbapple> edwardk: I experienced a little bit of that (the mismatch b/w Coq constructors and Haskell constructors). Where did you discover this? When you say "mattam there has a", do you mean that the prelude is in his fingertree development?
19:39:22 <SamB_XP> netytan: yeah
19:39:32 <Cale> I don't think we ought to need to steal any identifiers. We might need a new lexical class for labels.
19:39:36 <mm_freak> Cale: yes, we've had that already =)
19:39:37 <edwardk> ddarius: i use . for field selection in my toy, i'm just saying that it is a rather overworked little operator ;)
19:39:40 <Pseudonym> netytan: There's also the ~ operator, which complicates things.
19:39:52 <ddarius> Pseudonym: In my opinion, the biggest day-to-day issues with the record system can be solved by a (likely) straight-forward extension to the namespace system.  Namely local (not first class) modules.
19:39:54 <mm_freak> but i think most of us agree that haskell does need a record system
19:40:01 <Pseudonym> Exactly.
19:40:02 <mm_freak> a serious on, that is
19:40:07 <ddarius> edwardk: You should overload juxtaposition.
19:40:15 <edwardk> ddarius: tried that =)
19:40:29 <Pseudonym> Well, not exactly, but yeah, I agree that this would be a rational solution to most problems.
19:40:32 <SamB_XP> mm_freak: it wants one a lot, at least ;-P
19:40:32 <Cale> I like the semantics in Daan Leijen's proposals, but I would advocate a very different syntax from that.
19:40:33 <Pseudonym> Even if it's not a complete solution.
19:40:35 <netytan> SamB_XP: A gentleman is insisting that patterns are matched "simultaneously". But I don't see how that would be possible since if more than one pattern could match there'd be chaos. Am I wrong here?
19:40:51 <Pseudonym> That way, you wouldn't have to overload . again.  It's just a module qualification.
19:41:10 <Cale> netytan: hm?
19:41:14 <Pseudonym> Unfortunately, HM type inference and overloading-in-namespaces don't mix well.
19:41:40 <Pseudonym> Mercury's solution wasn't pretty: just split the type inference system and risk combinatorial explosion.
19:41:45 <Cale> netytan: Patterns are matched in order, top to bottom
19:41:49 <edwardk> it becomes very ugly defining a let binding for overloaded juxtaposition. =) so you wind up playing annoying games to get the right juxtaposition operator without using juxtaposition
19:41:52 <Pseudonym> Though it did issue a warning if the problem got too big.
19:41:55 <ddarius> Pseudonym: I definitely don't intend to propose it as a complete solution, but as a lightweight, low-hanging fruit solution that is more orthogonal than making records declare their own namespace, e.g. it allows declaring multiple, mutually abstract types in a single module, another desirable thing.
19:42:07 * Pseudonym nods
19:42:10 <netytan> Cale: I was having a dicussion about pattern matching with a gentlemen and he made the following claims  The match cases are completely independent.
19:42:10 <netytan> They will be matched simultaneously using a dispatch table and not sequentially.
19:42:10 <netytan> Later match cases are not dependent upon earlier match cases at all.
19:42:20 <mm_freak> how about just implementing one?  i mean, if we only discuss the upsides and downsides, but never actually do something, no record system will ever get implemented  there isn't a perfect one after all
19:42:20 <Pseudonym> Once again, it's a problem that would be fixed if Haskell had a decent module system.
19:42:42 <netytan> Cale: do these claims make any sense to you?
19:42:42 <Cale> netytan: Well, the compiler might do a bunch of things.
19:42:43 <Pseudonym> The module system being Haskell's biggest outstanding wart IMO.
19:42:49 <Mathnerd314> so are there any decent module system proposals?
19:43:10 <ddarius> Pseudonym: I don't consider the module system particularly "warty" just very conservative.
19:43:11 <edwardk> Pseudonym: unfortunately that is the direction down which most 'hey we need better support for feature foo' proposals go, and why they never get finished ;)
19:43:12 <netytan> Cale: but however the compiler does it, only one piece of code will be chosen to evaluate, correct?
19:43:14 <Cale> netytan: But as far as the semantics are concerned, the cases are tried in order.
19:43:22 <Cale> Oh, certainly.
19:43:25 <netytan> Cale: Thanks :)
19:43:44 <mm_freak> well, what can i do about the namespace problem?  i'd like to use records with common field names at least
19:44:10 <mm_freak> i'm not so much in need of _extensible_ records, but a better syntax and a solution for the namespace problem would be nice
19:44:17 <Pseudonym> Unfortunately, "conservative" here means "the bare minimum required to be only just useful, and specified in such a way that it would be hard to replace".
19:44:18 <ddarius> mm_freak: I already mentioned my suggestion.
19:44:28 <Cale> netytan: Actually, one of the first things that the compiler does is to turn every pattern match into a nested bunch of case expressions where each case is matching on only one construcor
19:44:32 <Cale> constructor*
19:44:37 <ddarius> Pseudonym: Why do you say the latter part of your sentence?
19:44:52 <edwardk> netytan: few real compilers do that for any language. the main notation i can think of that allows it is dijkstra's
19:44:55 <mm_freak> ddarius: local modules?
19:44:56 <Pseudonym> ddarius: module Foo where (stuff)
19:45:01 <ddarius> mm_freak: Yes.
19:45:12 <Pseudonym> You're limited by what you can put in those parentheses.
19:45:31 <mm_freak> well, you could use constructor names in module syntax
19:45:34 <ddarius> mm_freak: There is a solution, today, for namespacing records.  Simply define each record in its own module.  The problem is that's very heavyweight when each module needs to be in its own file.
19:45:43 <mm_freak> data Point = Point { x :: Double, y :: Double }
19:45:47 <mm_freak> Point.x somePoint
19:45:58 <benmachine> poor .
19:46:10 <ddarius> Pseudonym: I don't understand.  How would you avoid that?
19:46:27 <mm_freak> but local modules would be better definitely
19:46:33 <Pseudonym> ddarius: I don't like the syntax, but here's a vaguely Mercury-like example.
19:46:35 <benmachine> local modules wouldn't necessarily be better
19:46:37 <Pseudonym> module Foo
19:46:37 <Cale> I don't consider the namespacing issue important.
19:46:41 <Pseudonym> interface:
19:46:42 <benmachine> they make it that much harder to track down names
19:46:44 <mm_freak> benmachine: better than my suggestion
19:46:46 <Pseudonym> f :: Int -> Int
19:46:50 <Pseudonym> implementation:
19:46:53 <Pseudonym> f x = x+1
19:46:56 <Cale> The more interesting part about having a good record system is row polymorphism.
19:47:08 <wfjackson3> hey, how do I learn haskell?
19:47:14 * wfjackson3 puts on his helmet
19:47:17 <Axman6> @where lyah
19:47:17 <lambdabot> http://www.learnyouahaskell.com/
19:47:17 <mm_freak> Cale: i do, because i have lots of common field names
19:47:21 <monochrom> like learning anything
19:47:22 * Veinor throws tin cans at wfjackson3
19:47:22 <krasno> @hoogle hSelect
19:47:23 <lambdabot> No results found
19:47:23 <Axman6> that's how
19:47:24 <Pseudonym> Why is that better?  It allows, for example, control over what typeclass instances are exported.
19:47:24 <edwardk> hrmm, thinking about a more idealized 'gettext' module for haskell. thinking about using a TH printf to compile the initial pattern and bake in the string lookup. with a couple of custom build hooks it should be able to build a module for each .po file and a locale list and check that the patterns match
19:47:27 <Cale> wfjackson3: Hang around here and ask questions, and check out one or more of the tutorials
19:47:34 <ddarius> Cale: I don't really care about row polymorphism, but parameterized and/or first-class modules would be very nice.
19:47:45 <wfjackson3> lol, shapr put me up to it
19:47:46 <mm_freak> Cale: and no, there isn't always a way to restructure my data types, because often they are completely unrelated
19:47:47 <krasno> Where can I find hSelect, as described in http://www.haskell.org/ghc/docs/5.00/set/select.html?
19:47:49 * shapr grins
19:47:52 <Cale> ddarius: I agree about that, though, yes :)
19:48:02 <jbapple> Here is some simple code that can be proved correct in Haskabelle: http://www.nijoruj.org/~as/2009/04/20/A-little-fun.html
19:48:09 <shapr> wfjackson3: I could give you the #haskell introduction, I haven't done that in years.
19:48:13 <Cale> mm_freak: If they're completely unrelated, you should come up with different names for the identifiers.
19:48:32 <deech> Hi all, since reading good code is the best way to master a language, are there any general tips for reading Haskell code?
19:48:36 <ddarius> Pseudonym: I do dislike the fact that Haskell doesn't have a notion of "interface file" upon occassion.
19:48:37 <Pseudonym> It seems to me that you have a source file, and some lines of that source file belong in the module interface and some in the implementation.
19:48:38 <Cale> Especially where they might both be in scope at the same time -- it just gets confusing to overload things like that
19:48:44 <mm_freak> Cale: the _types_ are unrelated, but they contain fields that have the same name
19:48:48 <edwardk> deech: top to bottom, left to right ;)
19:48:57 <Cale> But field names are never just names
19:48:57 <Axman6> ddarius: writing good code is a much better way to master a language
19:49:05 <Axman6> uh, deech, not ddarius
19:49:10 <deech> edwardk: nice ...
19:49:11 <Cale> They're also functions (or in some proposals, other sorts of values)
19:49:27 <Pseudonym> Moreover, the module Foo where (stuff) approach gives a _triple_ maintenance problem.
19:49:30 <Cale> and functions having the same name, but which are completely unrelated is just poor design.
19:49:34 <monochrom> If you have subtyping, the two types are related.
19:49:39 <deech> edwardk: or right to left in case of (.) and certain arrow/monad functions.
19:49:40 <Pseudonym> You declare a symbol's type, and implementation, AND the fact that it's exported.
19:49:49 <edwardk> deech: see, you're learning already =)
19:50:17 <Pseudonym> Cale: But they may be related in a way that's hard to do in a mathematically principled manner.
19:50:19 <deech> But that was actually a serious question. There was a really cool book called "Code Reading" that addressed this for C-type languages.
19:50:32 <mm_freak> Cale: a lot of my types contain a 'description' field
19:50:40 <deech> Nothing like this seems to exist in the Haskell space.
19:50:46 <edwardk> deech: well, usually i look at the type and try to infer what the function can do before i even look at its implementation
19:51:02 <edwardk> deech: and then i look at the body, ignoring the where clause if possible to see how it is put together
19:51:09 <Cale> mm_freak: prefixes
19:51:15 <mm_freak> Cale: and prefixes are ugly
19:51:16 <edwardk> deech: then i go fish through the where clause for how all the details work
19:51:20 <edwardk> deech: stuff like that?
19:51:21 <Cale> Nah, they're fine
19:51:35 * ddarius almost never reads others code, not presented in a paper, "just because."
19:51:36 <mm_freak> after all i chose haskell, because it's elegant  but prefixes aren't elegant IMO
19:51:41 <Cale> and they make it unambiguous what you're talking about when used out of context
19:51:58 <mm_freak> a proper record system would be elegant, where you can tell functions from fields
19:52:14 <Cale> "description" looks like a fine name sitting in the data declaration, but is needlessly amiguous when found in the middle of some composition chain
19:52:17 <deech> edwardk: Yes, but more in the context of how I would go about using a library that wasn't really well documented. I had a heck of a time doing the simplest things with HXT for example.
19:52:18 <pastorn> http://web.student.chalmers.se/~goranssa/haskelled_my_way_here.png
19:52:25 <pastorn> ^^ i did that!
19:52:30 <Cale> amb*
19:52:54 <edwardk> deech: tricky because haskell code is usually so thoroughly factored down into tiny combinators.
19:52:58 * ddarius suspects OpenGL did that, but he might be wrong.
19:53:05 <mm_freak> Cale: i think, such a function shouldn't be found in a composition chain  there should be a separate blahDescription function
19:53:20 <pastorn> ddarius: no, that is entirely correct
19:53:43 <pastorn> ddarius: built my own targa loader and everything (to be able to use a targa file i had as a height map :)
19:53:44 <edwardk> class Describable t where description :: t -> String
19:53:47 <edwardk> problem solved ;)
19:53:48 * ddarius wished kids learned basic graphics algorithms like the good ole days.
19:54:07 <mm_freak> edwardk: in some scenarios you would end up having lots and lots of these classes
19:54:09 <edwardk> ddarius: even in the good old days most kids didn't learn you have a selection bias ;)
19:54:17 <mm_freak> it sucks to write them and they are a workaround for the lack of a record system
19:54:21 <edwardk> mm_freak: yeah. i do =/
19:54:21 <Cale> yeah, if they're all nice and uniform, then you want a typeclass, and stop caring what the field is called so much :)
19:54:51 <ddarius> edwardk: I think you need more punctuation and even then are you simply making a blanket statement that most kids didn't learn?
19:54:53 <mm_freak> in the case of 'description' it sounds ok, but there are other field names, where this is bad
19:54:55 <Cale> But where you really want row polymorphism, simple product types aren't really a great answer
19:54:57 <mm_freak> like 'x'
19:55:05 <Pseudonym> ddarius, why have basic when you have Logo?
19:55:18 <deech> edwardk: Yes I really appreciate when authors like Bryan O Sullivan provide sample code and its output.
19:55:19 <mm_freak> if you used 'x' as a field name with the current "record system", you would definitely run into trouble
19:55:24 <edwardk> ddarius: yeah i could stand to use an extra . or two in that sentence
19:55:27 <ddarius> Pseudonym: I didn't have logo; I had (Q)BASIC.
19:55:47 <edwardk> deech: i'm terrible at providing examples for my code i confess
19:56:26 <mm_freak> further those type classes mean death to modularity
19:56:28 <deech> edwardk: is that because you assume that those who will use it already understand its terminology etc?
19:56:46 <ddarius> Pseudonym: And my QBASIC would have melted your retinas.
19:56:47 <mm_freak> as soon as you have two separate packages with common field names, that method fails dramatically
19:56:55 <edwardk> deech: nah, mostly coz by the time i get done implementing the library i go off and use it for my purpose of go explore something else
19:57:02 <edwardk> and publish to hackage as an afterthought ;)
19:57:04 <mm_freak> and you don't want to write a package "has-x" ;)
19:57:24 <SamB_XP> mm_freak: hmm, I heard Clean does something that would work fine for that ...
19:57:36 <deech> Because that was the feel I got from the HXT libary. It was  like, OK so you understand arrows, now let's make things interesting!
19:57:49 <Khronos> you guys happen to know of an orbit math/astronomy software package for haskell?
19:58:07 <mm_freak> SamB_XP: there is also HList, but i didn't like it that much
19:58:09 <Khronos> that will help calculate the RA and Dec of a distant planetary system
19:58:27 <Khronos> or other things of that nature
19:58:29 <SamB_XP> deech: the feel I got was "okay, so I didn't learn how to use export lists. so you have to wade through ALL of these functions, whether they're really useful or not!"
19:58:31 <Cale> Khronos: Have you checked on Hackage? That seems really specific.
19:58:53 <edwardk> Khronos: not as such but i'm pretty sure there are at least a few folks who have the mechanics for a hohmann transfer or bi-elliptic transfer lying around after the last ICFP contest ;)
19:58:54 <Cale> It doesn't seem like there's anything...
19:59:01 <ddarius> HXT doesn't actually need arrows...
19:59:03 <deech> SamB_XP: Maybe! But all fixable by one in-depth tutorial.
19:59:34 <SamB_XP> deech: and smaller export lists!
19:59:40 <edwardk> SamB_XP: the problem with the folks who do use export lists is they often hide the one combinator i needed ;)
19:59:47 <edwardk> or worse, the one constructor
20:00:07 <edwardk> great i appreciate you want encapsulation, but you didn't finish the library well enough! ;)
20:00:09 <Parkotron> Which is the better way to use any on a list of lists? "any (any checkFunc) listOfLists" or "any checkFunc (concat listOfLists)"?
20:00:11 <deech> here here! Documentation trumps export lists.
20:00:15 <ddarius> There are actually handy functions in the Report Prelude that aren't "exported"
20:00:24 <edwardk> any (any
20:00:29 <SamB_XP> edwardk: yeah, I'm just talking about not exporting all the little pieces you make something nice out of, which could just as easily be re-done
20:00:34 <Khronos> cool... hohmann transfer. I've read of that
20:00:45 <benmachine> :t any . any
20:00:46 <lambdabot> forall a. (a -> Bool) -> [[a]] -> Bool
20:01:02 <mm_freak> where was some GHC extension, which helps with records a bit
20:01:05 <Parkotron> edwardk: Thanks. That's what I expected.
20:01:08 <mm_freak> but i forgot its name
20:01:19 <benmachine> gmapQ (mkQ False checkFunc) listOfLists -- >_>
20:01:30 <benmachine> er
20:01:35 <benmachine> that's not right
20:01:56 <benmachine> everything (||) (mkQ False checkFunc)
20:02:00 <benmachine> :t everything (||) (mkQ False checkFunc)
20:02:01 <lambdabot> Not in scope: `checkFunc'
20:02:06 <benmachine> oh, right
20:02:14 <deech> On a related note, is there some way to search Hackage for packages use a certain package? Not to beat up on HXT but it would have been useful to read the source of projects that used it.
20:02:15 <benmachine> :t everything (||) . mkQ False
20:02:16 <lambdabot>     Couldn't match expected type `GenericQ Bool'
20:02:16 <lambdabot>            against inferred type `a -> Bool'
20:02:16 <lambdabot>     Probable cause: `mkQ' is applied to too few arguments
20:02:20 <benmachine> blork
20:02:27 <benmachine> :t \p -> everything (||) (mkQ False p)
20:02:28 <lambdabot> forall b a. (Data a, Typeable b) => (b -> Bool) -> a -> Bool
20:02:34 <jbapple> Here is another example of Haskell code proved correct, then extracted from Coq: http://homepages.cwi.nl/~milad/QArith/
20:02:57 <benmachine> deech: I remember there being a reverse dependencies thing turning up a while back, don't know where it is now though
20:03:01 <benmachine> probably googleable
20:03:41 <benmachine> http://bifunctor.homelinux.net/~roel/hackage/packages/archive/revdeps-list.html
20:03:58 <benmachine> :q
20:04:01 <edwardk> jbapple: data Prod a b = Pair b a is indicative of the whole 'reinvent the world' mindset that tends to pervade extracted coq code. Sumbool, etc.
20:04:03 <benmachine> that didn't happen
20:04:26 <ddarius> edwardk: "Sumbool" ?
20:04:42 <benmachine> deech: http://bifunctor.homelinux.net/~roel/cgi-bin/hackage-scripts/revdeps/hxt-8.5.2#direct
20:04:44 <edwardk> ddarius: the example he gave had data Sumbool = LLeft | RRight
20:04:55 <benmachine> deech: I don't think this is guaranteed to be up to date, but there you go
20:05:17 <deech> benmachine: holy moly, could've used this a while ago. Way to teach a man to fish!
20:05:24 <jbapple> edwardk: There are some extraction tools in Coq that allow one to set up correspondences b/w Haskell types and Coq types. I think the manual explicitly mentions sumbool as one of those
20:06:14 <benmachine> deech: :)
20:06:24 <jbapple> ddarius: In Coq, sometimes you need a type that looks like "Either P (Not P)", where whether P or Not P is true matters, but not the details of why P or Not P is true.
20:06:49 <edwardk> jbapple: yeah, but the lovely part is of course how well the extraction stuff is documnted for languages that aren't ocaml ;)
20:06:56 <mm_freak> i was just trying to find reverse dependencies using a shell command
20:07:00 <mm_freak> it's SLOOOOOW
20:07:06 <SamB_XP> edwardk: yeah, isn't it ?
20:07:24 <jbapple> edwardk: wspecially for modules
20:07:35 <mm_freak> one 'cabal info' takes more than a second, which makes that impractical =)
20:07:51 <edwardk> that was largely why i switched to agda. at least there they are new enough to have an excuse for no docs ;)
20:08:21 <mm_freak> btw, maybe hackage should start using multiple pages and a search form
20:08:42 <mm_freak> edwardk: "switched to agda"?
20:09:03 <SamB_XP> mm_freak: like if you ditched C++ for Java or whatever
20:09:16 <SamB_XP> only not so likely to be a good idea
20:09:20 <edwardk> mm_freak: from coq for anything i want to prove more than semi-formally
20:09:26 <mm_freak> ah, ok
20:09:36 * hackagebot afv 0.1.1 - Infinite state model checking of iterative C programs.  http://hackage.haskell.org/package/afv-0.1.1 (TomHawkins)
20:09:37 <mm_freak> i thought you're doing actual application development in agda =)
20:09:48 <edwardk> not any more ;)
20:10:04 <ddarius> edwardk: What do you mean no docs?  There's a PhD thesis!
20:10:10 <edwardk> agda is what drove me to work on kata ;)
20:10:15 <SamB_XP> ddarius: in english, even ?
20:10:22 <ddarius> SamB_XP: Yes.
20:10:28 <jbapple> But agda doesn't yet do extraction, right? Also, I think the compiler ("Lorenzo"?) is deprecated
20:10:34 <SamB_XP> that sure beats in french!
20:10:37 <jbapple> I mean, not  that those are must-haves
20:10:45 <mm_freak> edwardk: i only find "topkata", which is an opengl game =)
20:10:47 <jbapple> just in the domain of proving runnable code
20:11:04 <edwardk> mm_freak: pet language, #kata, i;ve bored folks here enough with it ;)
20:11:20 <mm_freak> ah, ok =)
20:12:05 <mm_freak> agda is a bit dangerous
20:12:27 <jbapple> mm_freak: because it is addictive?
20:12:31 * ddarius is safely guarded from Agda by emacs.
20:12:44 <stepcut> I have a bunch of threads. Each thread blocks until it recieves a command. Sometimes I want to send a command to a specific thread, but other times I want to broadcast a command to all the threads. I am not seeing the obvious way to do this..
20:12:55 <stepcut> ddarius: :)
20:13:07 <mm_freak> no, because it bends your mind the same way haskell does compared to languages like C
20:13:24 <mm_freak> you start seeing safety hazards everywhere even in haskell code
20:14:03 <ddarius> stepcut: How are you communicating between threads (T)Chans?
20:14:29 <stepcut> ddarius: write now, Chans, but I am not committed to that
20:14:56 <ddarius> stepcut: And do you have a current scheme for broadcasting?
20:15:11 <stepcut> ddarius: chans do broadcast (via dupChan), but if I need a second Chan to send private messages.. then I get stuck
20:15:27 <mm_freak> stepcut: well, the straightforward way would be to keep track of all channels and use mapM_
20:15:50 <stepcut> mm_freak: yeah, that doesn't seem very efficient ?
20:15:53 <mm_freak> (you need to keep track of then anyway)
20:16:41 <mm_freak> well, you aren't going to get more efficient with Chans, but in a recent benchmark i had 10,000 threads sending a total of one million messages (via MVar) in about three seconds
20:16:58 <stepcut> mm_freak: good enough :)
20:17:38 <ddarius> stepcut: An alternative is to use some kind of addressing scheme in the messages themselves analogous to how ethernet works.
20:18:18 <mm_freak> an MVar with a semaphore would do, too
20:18:27 <mm_freak> but then you need to keep track of the number of channels
20:18:55 <stepcut> ddarius: yeah, I thought of that as well, just always broadcast everything, and have each thread see if the message is relevant or not
20:19:04 <ddarius> Exactly.
20:19:29 <ddarius> I usually handle broadcast in the way mm_freak described.
20:20:19 <mm_freak> there is nothing wrong with mixing the two approaches
20:20:25 <stepcut> ddarius: yeah.. so either I can use mapM and only wake the threads that need to hear the message, or I can use dupChan and broadcast to everyone
20:20:25 <mm_freak> so you get something like broadcast groups
20:20:32 <mm_freak> also known as multicast =)
20:21:04 <mm_freak> in terms of performance the mapM approach is going to be faster
20:21:08 <stepcut> mm_freak: the problem I have with mixing the two results is that I don't see how to get a thread to listen for incoming messages on multiple channels with out doing a busy wait
20:21:23 <mm_freak> especially in multi-OS-thread scenarios
20:21:29 <ddarius> stepcut: Well, unless you need multicast, you'd only mapM_ when broadcasting.  You could just talk on the channel by itself when not broadcasting.
20:21:46 <SamB_XP> stepcut: there's always spawning two more ;-P
20:22:08 <ddarius> Of course, if you do need multicasting then the natural thing to do is just what you said; broadcast on a subcollection of the channels.
20:22:08 <mm_freak> stepcut: either split the thread further or use STM
20:22:20 <ddarius> stepcut: Use the CML library.
20:22:34 <ddarius> It's always very nice to have a "select" operation.
20:23:09 <ddarius> stepcut: Incidentally, you may or may not find some concurrency experiments I was fiddling around with earlier interesting.
20:23:43 <stepcut> hmm. Actually, maybe I will combine the two.. I think that my pattern is almost also a broadcast + a message to a single recipient. So I can just bundle those I guess. Everyone is going to have to wake up anyway.. though they will have to do an extra check to see if the private message was to them
20:24:30 <pookleblinky> Has anyone here tried the unsupported agda in AUR?
20:25:00 <mm_freak> stepcut: as soon as you have less than all threads to wake up, the broadcast approach is less efficient
20:25:18 <mm_freak> note that the waking up of a thread needs scheduling time and CPU time
20:25:24 <stepcut> mm_freak: right, that is why I wanted to avoid that
20:26:06 <mm_freak> on the other hand, with lightweight threads that's not so much of an issue, unless you have tens of thousands of threads
20:26:25 <mm_freak> however, it gets to be an issue as soon as you use multiple OS threads
20:26:40 <Zeiris> How can I export an "instance Num ADataType" from a module?
20:26:51 <ddarius> Zeiris: You can't not export it.
20:28:49 <Zeiris> What if ADataType is defined in a totally different module than the one I defined the instance Num ADataType in?
20:29:49 * pookleblinky finds that haskell-cabal in AUR depends on itself, thereby entering an infinite loop trying to install agda-executable. Argh.
20:29:59 <ColonelJ> help, I'm forgetting why pure code is good
20:30:09 <roconnor> ColonelJ: easy to reason about
20:30:19 <mm_freak> Zeiris: if both modules are in scope, the instance is, too
20:30:31 <pikhq> ColonelJ: LAMBDA WAS LAMBDA IS AND LAMBDA IS TO COME
20:31:11 <mm_freak> ColonelJ: it makes your code smaller by a factor of 5-10 compared to side-effectful programming
20:31:26 <mm_freak> (if your code base is based on that principle)
20:31:32 <ColonelJ> mm_freak: orly?
20:31:42 <roconnor> mm_freak: eh?
20:32:19 <mm_freak> haskell's base library is based on that principle, while for example C++'s STL is based on effectful programming
20:32:28 <mm_freak> haskell code is usually shorter
20:32:38 <mm_freak> that's what i mean
20:33:26 <SamB_XP> mm_freak: the type inference also helps a lot with that ;-)
20:33:32 <ColonelJ> heh
20:33:48 <Makoryu> mm_freak: Depends on the problem. There are tasks for which no language (even the perennially nefarious APL and its descendants) will help you write less code.
20:33:55 <mm_freak> SamB_XP: indeed =)
20:34:10 <mm_freak> Makoryu: do you know of a good example?
20:34:21 <pookleblinky> APL lets you write the Game Of Life in one line. That's gotta count for something.
20:34:38 <SamB_XP> pookleblinky: how many lines for hashlife ?
20:34:45 <Makoryu> mm_freak: GUI code usually leans that way. Not always, but usually.
20:35:07 <pookleblinky> http://blogs.mathworks.com/loren/2010/01/19/mathematical-recreations-tweetable-game-of-life/
20:35:12 <pookleblinky> holy crap.
20:35:27 <mm_freak> Makoryu: well, we have functional reactive programming as a good paradigm for that, but we're in lack of practical implementations
20:35:31 <mm_freak> "practical" as in "useful"
20:36:02 <Makoryu> pookleblinky: Most of the tricks that let you do that in APL would work in Haskell, too, if we had better datatype support (and slightly cleverer lifting operators)
20:36:32 <Makoryu> I'm not sure the current crop of vector/matrix libraries is up to the task
20:36:45 <Makoryu> mm_freak: Well, it helps a little.
20:36:49 <Makoryu> In theory.
20:37:13 <mm_freak> note that you express _a lot_ of dependencies and processing when designing a GUI
20:37:21 <Makoryu> Yup
20:37:28 <mm_freak> so i'd consider what we currently have as actually quite short
20:37:28 <Mr_Awesome> what would be an elegant way to make a list of every nth element of a given list?
20:37:55 <mm_freak> i remember implementing window/widget-based GUIs in times of borland c++ 2 for DOS
20:38:22 <mm_freak> that's what code would look like if we hadn't such excellent (!) language/library support for that
20:39:02 <mm_freak> > map head . takeWhile (not . null) . iterate (drop 3) $ [1..]
20:39:04 <lambdabot>   [1,4,7,10,13,16,19,22,25,28,31,34,37,40,43,46,49,52,55,58,61,64,67,70,73,76...
20:39:08 <mm_freak> @ Mr_Awesome
20:40:30 <ColonelJ> > [1,4..]
20:40:31 <lambdabot>   [1,4,7,10,13,16,19,22,25,28,31,34,37,40,43,46,49,52,55,58,61,64,67,70,73,76...
20:41:05 <Mr_Awesome> mm_freak: i see. that's similar to what i have. i suppose that's about the best that can be done.
20:41:19 <[swift]_> so i'm trying to specialize a simple function that uses liftM2 so that it only works with lists (ie, I want the monad to always be the list monad), but I can't figure out how to do it. here's the code: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24542#a24542
20:41:23 <mm_freak> > map head . takeWhile (not . null) . iterate (drop 3) $ "This is a test, where you can't use enumFromThen. =)"
20:41:24 <lambdabot>   "Tss s e uatsemoh.)"
20:41:33 <ColonelJ> > (\n -> [1,n+1..]) 4
20:41:34 <lambdabot>   [1,5,9,13,17,21,25,29,33,37,41,45,49,53,57,61,65,69,73,77,81,85,89,93,97,10...
20:41:56 <mm_freak> well, if you insist
20:43:01 <mm_freak> > let str = "This is a test, where you can't use enumFromThen. =)" in map (str !!) [0,3..length str - 1]
20:43:02 <lambdabot>   "Tss s e uatsemoh.)"
20:43:04 <mm_freak> =P
20:43:40 <Gracenotes> test.. failed?
20:44:19 <mm_freak> this is the UWPS
20:44:31 <mm_freak> unintentionally worst possible solution
20:44:53 <regalia> I'm using lookup to get an Integer out of an association list
20:44:56 <Makoryu> @pl \s i -> map (s !!) $ enumFromThenTo 0 i (length s - 1)
20:44:56 <lambdabot> ap ((.) . map . (!!)) (flip (enumFromThenTo 0) . subtract 1 . length)
20:45:00 <regalia> how can I get rid of the Just so I can add it?
20:45:05 <deech> Mr_Awesome: Check out my solution at http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24543#a24543
20:45:08 <mm_freak> > splitAt 7 . drop (42 - 15) . map head $ cake
20:45:09 <lambdabot>   ("TOOTOOT","ASCIICAT")
20:45:17 <Makoryu> > cake
20:45:18 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
20:45:21 <mm_freak> sorry, couldn't resist
20:45:24 <Makoryu> 
20:45:49 <Makoryu> > filter (isInfixOf "rhubarb") cake
20:45:50 <lambdabot>   ["Two cups rhubarb, sliced.","Two slash three cups granulated rhubarb.","On...
20:45:56 <mm_freak> regalia: don't get rid of it
20:45:56 <Makoryu> > filter (isInfixOf "fish") cake
20:45:57 <lambdabot>   ["Candy coated peanut butter pieces. Shaped like fish."]
20:46:01 <mm_freak> regalia: use fmap
20:46:09 <mm_freak> > fmap (+1) $ Just 4
20:46:10 <lambdabot>   Just 5
20:46:41 <regalia> mm_freak: Ok, I'll work it out, thanks
20:46:55 <BMeph> [swift]_: Thank you! ;)
20:47:01 <mm_freak> regalia: rationale: if part of your function can fail, the whole function can fail
20:47:03 <Makoryu> :t fromMaybe
20:47:04 <lambdabot> forall a. a -> Maybe a -> a
20:47:07 <mm_freak> so it should return a Maybe
20:47:15 <mm_freak> unless you can guarantee that it doesn't fail
20:47:20 <[swift]_> BMeph: ?
20:47:25 <mm_freak> (or do it the dirty way and work with 'error' or exceptions)
20:47:39 <Makoryu> mm_freak: Or with 'maybe' and a default value
20:47:45 <regalia> It will be impossible for 'Nothing' to come up
20:47:47 <Makoryu> > 5 `maybe` Just 12
20:47:48 <lambdabot>   Couldn't match expected type `a -> t'
20:47:48 <lambdabot>         against inferred type `Data.M...
20:47:51 <Makoryu> Whoops
20:47:53 <BMeph> [swift]_: For letting me tell you: UR DOIN IT RONG!! ;
20:47:56 <Gracenotes> hey, fromMaybe is all about default values
20:48:08 <mm_freak> Makoryu: true
20:48:10 <Makoryu> > 5 `fromMaybe` Just 12
20:48:11 <lambdabot>   12
20:48:18 <Makoryu> > 5 `fromMaybe` Nothing
20:48:19 <lambdabot>   5
20:48:35 <regalia> I think that's what I want :)
20:48:37 <[swift]_> BMeph: fair enough. so what would DOIN IT RITE consist of? =)
20:48:52 <mm_freak> regalia: maybe 'lookup' isn't what you want in the first place =)
20:49:19 <regalia> I just want to map values to ['A'..'Z']
20:49:22 <mm_freak> and as a side note, have a look at Data.Map ;)
20:49:25 <Gracenotes> though, program invariants (this variable cannot be Nothing) can be somewhat difficult to prove if they amount to some part of your program just *working* correctly or not
20:49:59 <regalia> lookup x (zip ['A'..'Z'] [1..])
20:50:31 <Gracenotes> regalia: hm, a data structure worth considering is an Array Char Integer
20:50:48 <mm_freak> yeah, or even UArray Word8 Word8
20:51:19 <regalia> I will look into that as well
20:51:48 <ColonelJ> is it pure enough to have an object which once modifies clones itself unless it is only referenced by that one thing that changes it
20:52:09 <Gracenotes> you can set it up so that arr['A'] will give you the first element of an array, and arr['Z'] will give you the last (in C notation here..)
20:52:24 <regalia> so no traversal?
20:52:33 <BMeph> [swift]_: Depends.  Do you just want lists, or lists-of-lists?
20:52:59 <Gracenotes> regalia: http://www.haskell.org/ghc/docs/latest/html/libraries/array-0.3.0.0/Data-Array-IArray.html - elems method, there is
20:53:05 <Gracenotes> or assocs
20:54:00 <[swift]_> BMeph: it'll be lists of lists, i suppose, as the embedded (++) pretty much requires that
20:54:11 <regalia> Gracenotes: Thank you :)
20:56:03 <[swift]_> BMeph: mainly the thing is that the behavior I intend that operator to have depends on the behavior of the list monad
20:57:01 <mm_freak> regalia: indexing is an O(1) operation with Array and UArray
20:57:16 <regalia> O(n) with lists
20:57:22 <mm_freak> it's about the fastest data structure for random access you get in haskell
20:58:09 <aavogt> O(o)
20:58:22 <Zeiris> Why does installing the newest version of Cabal from the darcs repo, not update /bin/cabal? It's still 1.8.0, even though I just built+installed 1.9.
20:58:26 <BMeph> [swift]_: ...and what behavior are you expecting?
20:58:43 <aavogt> Zeiris: Cabal or cabal-install?
20:58:57 <Zeiris> Is cabal-install an executable called "cabal"?
20:59:03 <mm_freak> Zeiris: yeah
20:59:06 <Zeiris> ...
20:59:29 <aavogt> perhaps you installed it --user?
20:59:42 <aavogt> and should be looking for $HOME/.cabal/bin/cabal?
20:59:45 <[swift]_> BMeph: basically the cartesian product of two lists of lists
20:59:58 <Zeiris> No. I installed cabal. I guess I need cabal-install, which is actually called cabal.
21:01:19 <c_wraith> Yeah, I can't agree with the people saying "cabal is not a package management tool" until the cabal-install executable is not named cabal
21:02:37 <BMeph> [swift]_: Then, you want something other than liftM2 (++). :)
21:02:41 <Zeiris> Does cabal-install even work with 6.12?
21:02:50 <ddarius> type Nat = [()]; instance Num Nat where (*) = (|*|)
21:02:54 <[swift]_> BMeph: it works as intended, actually
21:04:51 <[swift]_> > liftM2 (++) [[1,2], [3,4]] [[5,6], [7,8]]
21:04:53 <lambdabot>   [[1,2,5,6],[1,2,7,8],[3,4,5,6],[3,4,7,8]]
21:05:59 <[swift]_> BMeph: one might expect pairs instead of concatenation, i agree, but this version is more useful for my application
21:13:02 * BMeph thinks that looks more like a "cartesian/inner product" but that's just a WAG
21:16:41 <[swift]_> BMeph: that's a fair characterization
21:18:02 * aavogt wonders if any other _AG words name interesting classes of graph
21:20:14 <dankna> Anybody here who has opinions on the design of parser generators?  Would you care to critique my design?
21:20:30 <dankna> (Because Happy doesn't do shift actions, that's why :) )
21:21:24 <ddarius> dankna: There are quite a few options besides happy, e.g. frown and pappy.
21:21:31 <dankna> hmm
21:21:34 <dankna> let me look into those
21:22:53 <mm_freak> @pl \x y -> [x,y]
21:22:54 <lambdabot> (. return) . (:)
21:23:27 <mm_freak> > (\x y -> [x,y]) <$> [[1,2], [3,4]] <*> [[5,6], [7,8]]
21:23:28 <lambdabot>   [[[1,2],[5,6]],[[1,2],[7,8]],[[3,4],[5,6]],[[3,4],[7,8]]]
21:24:14 <dankna> Frown appears unmaintained and has the same lack of shift actions (you don't know what I went through even finding a copy of it, heh)
21:25:08 <dankna> Pappy is not shift-reduce, it's another formalism that I don't have time to learn :)
21:25:30 <dankna> although I'll save the thesis on it to read later, since it looks like something I ought to know about
21:29:29 <dankna> (context is that I have an existing parser which I don't want to rewrite for another formalism)
21:29:46 <dankna> (porting from one generator to another within the formalism is almost trivial; porting across formalisms much harder)
21:38:05 * hackagebot monad-parallel 0.5.1 - Parallel execution of monadic computations  http://hackage.haskell.org/package/monad-parallel-0.5.1 (MarioBlazevic)
21:40:06 * hackagebot monad-coroutine 0.5.1 - Coroutine monad transformer for suspending and resuming monadic computations  http://hackage.haskell.org/package/monad-coroutine-0.5.1 (MarioBlazevic)
21:40:08 * hackagebot scc 0.5.1 - Streaming component combinators  http://hackage.haskell.org/package/scc-0.5.1 (MarioBlazevic)
22:18:52 * harovali wonders about latest developments in haskel
22:19:47 <tensorpudding> haskell 2010, GHC 6.12 released, new haskell platform, Experimental LLVM backend
22:20:43 * harovali feels curious about new haskell platform
22:21:02 <mm_freak> i read that GHC 6.12 in its current state will make my code slower, is that true?
22:21:21 <mm_freak> it's related to the parallel GC
23:34:56 <alex404> Is there a way to read an uncompiled hs file from a compiled haskell program, so as to get something like .conf or .ini functionality?
23:36:09 <mm_freak> alex404: 'read'
23:36:22 <mm_freak> > read "Just (3, 4)" :: Maybe (Int, Int)
23:36:23 <lambdabot>   Just (3,4)
23:36:48 <alex404> Oh yah. Duh.
23:37:06 <mm_freak> should cover most cases, unless you need executable configuration files
23:40:04 <FunctorSalad_> (then you could use the ghc api... which is wrapped by hint for common cases)
23:40:13 <FunctorSalad_> ("hint" is a package)
23:40:20 <alex404> mm_freak: Is there a way to extract a variable name as well, i.e. get "foo = 3"
23:40:31 <mm_freak> alex404: use records
23:41:19 <mm_freak> date Config = Config { param1 :: String, param2 :: Integer }
23:41:24 <mjrosenb> oh man, i'm about to play a really fun game with haskell + postscript
23:41:43 <mm_freak> read "Config { param1 = \"blah\", param2 = 15 }"
23:42:07 <mm_freak> (assuming you derive Read)
23:42:13 <FunctorSalad_> neat trick
23:42:17 <alex404> You're so smart.
23:42:22 <FunctorSalad_> if you need a config really fast...
23:42:30 <mm_freak> yeah
23:42:40 <mm_freak> it works the other way around, too, of course, if you derive Show
23:43:14 <alex404> So I could e.g. manipulate program variables in both a conf file and gui?
23:43:24 <Gracenotes> there's also Data.Binary, if you feel like being more secretive (barely), which has trivial instances in many cases one would want to define
23:43:36 <mm_freak> alex404: not automagically
23:44:41 <mm_freak> i prefer text files
23:45:00 <mm_freak> but usually i write my own parser  it's easy
23:45:22 <alex404> Indeed. I'm just trying to learn to do clever things in haskell.
23:46:01 <mm_freak> i like to play with my monads =)
23:46:18 <FunctorSalad_> alex404: "Read" won't evaluate anything though
23:46:28 <FunctorSalad_> the derived Read instance, that is
23:46:29 <mm_freak> > sequence ["b", "lL", "a4A", "hH"]
23:46:30 <lambdabot>   ["blah","blaH","bl4h","bl4H","blAh","blAH","bLah","bLaH","bL4h","bL4H","bLA...
23:46:42 <FunctorSalad_> so you can't have "Config { param2 = 1 + 1 }" in your file
23:47:13 <alex404> FunctorSalad_: I imagine I'd have just a list of variables in the file, foo = bar
23:47:29 <alex404> FunctorSalad_: And wrap them in commans and braces and what before I fed it to read
23:47:49 <ezyang> Hey guys, suppose I have data constructors A B and C, and I want a type that says "A or B" and a type that says "A B or C".  Is there something more elegant than Type1 = A | B; Type2 = AorB Type1 | C
23:48:00 <mm_freak> alex404: why would you want to wrap yourself?
23:48:25 <alex404> mm_freak: So it doesn't uglify the conf file?
23:48:33 <mm_freak> i don't think there is anything wrong with haskell-like configuration files =)
23:48:50 <alex404> mm_freak: My users freak out if they even think they're looking at haskell code
23:49:00 <FunctorSalad_> heh
23:49:36 <mm_freak> ezyang: Either (A, B) (A, B, C)?
23:49:45 <FunctorSalad_> alex404: I suppose you could parse a list of assignments with haskell-src-exts, too
23:50:01 <ezyang> mm_freak: That's... not quite the semantics I want
23:50:05 <ezyang> I'm doing disjunction, not conjunction
23:50:07 <FunctorSalad_> (then you can even arbitrarily process the RHS as long as it's syntactically haskell)
23:50:19 <mm_freak> oh
23:50:30 <alex404> FunctorSalad_: What is it?
23:50:40 <FunctorSalad_> alex404: haskell parser :)
23:50:49 <FunctorSalad_> (to abstract syntax tree)
23:51:07 <dibblego> ezyang, Either is disjunction, (,) is conjunction; just put them together accordingly
23:51:32 <ezyang> dibblego: Right, but for some reason Either A (Either B C) hurts me eye
23:51:33 <mm_freak> yeah, although i missed a case
23:51:35 <alex404> FunctorSalad_: Ah, right. That's probably a bit heavyweight if I don't already know my way around it, eh?
23:52:02 <ezyang> And I still have to pattern match with the incredibly clunky (Right (Right C)), etc
23:52:08 <mm_freak> ezyang: in a 'data' definition the '|' is about the same as a better "Either"
23:52:19 <ezyang> mm_freak: *nod*
23:52:41 <dibblego> ezyang, create your own type then
23:52:53 <FunctorSalad_> ezyang: prefer A `Either` B `Either` C ?
23:52:55 <FunctorSalad_> :)
23:53:05 <mm_freak> hehe
23:53:08 <ezyang> FunctorSalad_: is that even valid syntax? :-)
23:53:13 <FunctorSalad_> alex404: yes, overkill for just a list of assignments
23:53:27 <FunctorSalad_> ezyang: yes; maybe some extension
23:53:27 <mm_freak> > Right 1 :: String `Either` Int
23:53:28 <lambdabot>   Right 1
23:53:32 <ezyang> coool
23:53:45 <mm_freak> but a custom type will be better
23:53:52 <ezyang> > Right (Right 1) :: String `Either` Integer `Either` Int
23:53:53 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
23:53:53 <lambdabot>         against inferred type ...
23:53:55 <FunctorSalad_> InfixTypes or something?
23:53:59 <alex404> FunctorSalad_: Well thanks for the tips, anyway.
23:54:03 <FunctorSalad_> I don't think it's TypeOperators
23:54:03 <FunctorSalad_> np
23:54:04 <ezyang> mm_freak: Nod.
23:54:23 <ezyang> mm_freak: Namespace will get pretty polluted that way, but it probably makes the most sense
23:54:25 <mm_freak> > Right 1 :: String `Either` Integer `Either` Int
23:54:26 <lambdabot>   Right 1
23:54:28 <FunctorSalad_> "Either" as infix is gramatically weird though
23:54:32 <mm_freak> `Either` is left-associative
23:54:44 <ezyang> mm_freak: Aha
23:54:45 <mm_freak> x `Either` y `Either` z = (x `Either` y) `Either` z
23:55:05 <mm_freak> but then at least do something like:
23:55:08 <mm_freak> type Or = Either
23:55:09 <mm_freak> =)
23:55:36 <ezyang> A natural follow up question is, what do you guys name your data constructors for arbitrary arity Either reimplementations?
23:55:51 <mm_freak> depends on the purpose
23:55:54 <FunctorSalad_> data (:+:) a b = L a | R b
23:55:59 <FunctorSalad_> is valid too with TypeOperators
23:56:09 <ezyang> FunctorSalad_: lol
23:56:13 <FunctorSalad_> (you can use it infix then, and declare the precedence just like on the value level)
23:56:29 <mm_freak> data Msg = QuitMsg String | GetStatusMsg (Status -> IO ())
23:56:43 <FunctorSalad_> ezyang: it works because haskell considers the colon upper-case :)
23:56:49 <ezyang> >.>
23:57:07 <ezyang> mm_freak: Ok, that's pretty reasonable. Prefix the full type name with the specific instance
23:57:38 <mm_freak> well, Either is as general as it could get  no reason to rename/reimplement it
23:57:50 <mm_freak> if you don't like it, write a custom type for your specific use case
23:58:02 <ezyang> one of the reasons I'm struggling with this is because I feel like the person who handed me the spec to design this datatype put so many really arbitrary restrictions on what could go in waht
23:58:08 <FunctorSalad_> the downside to custom types is that you don't get to use "either" and so on
23:58:30 <mm_freak> if your use case is really a general A+B+C * (A*B) * (A*B*C), then you need to invent names  ugly names probably =)
23:58:34 <FunctorSalad_> and everyone writes a slightly different Either clone as a result for parsers :|
23:58:43 <FunctorSalad_> ParseFailure, ParseFail, ParsingFailed ;)
23:58:43 <ezyang> mm_freak: Nope, not general.
23:58:46 <FunctorSalad_> (constructors)
23:59:04 <FunctorSalad_> ParseOK, ParseOk
23:59:06 <ezyang> it's some silly datatype for a book
23:59:21 <mm_freak> ezyang: well, maybe you should do some refactoring
23:59:29 <mm_freak> split it into multiple types
