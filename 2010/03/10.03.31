00:00:05 <ezyang> with chapters, sections, paragraphs and figures. paragraphs and figures are interchangeable, sections can contain sections but not chapters, pages can contain only paragraphs or figures
00:00:20 <FunctorSalad_> Either is just fine if Left means some sort of failure, as is conventional
00:00:20 <ezyang> mm_freak: Yeah, I think so too :-)
00:00:46 <mm_freak> data AllThree = AllThree A B C; data OneOfTwo = One2 A | Two2 B; data OneOfThree = One3 A | Two3 B | Three3 C
00:00:55 <wavewave> what is the situation of CUDA backend for Data Parallel Haskell?
00:00:55 <mm_freak> data MyType = AllThree | OneOfTwo | OneOfThree
00:01:18 <ezyang> I have another question: there's a pretty stanandard definition of a tree with data Tree a = Leaf a | Node (Tree a) (Tree a)
00:01:32 <ezyang> but this obviously doesn't give me an efficient way to ask "what's the parent of some node/tree).
00:01:39 <FunctorSalad_> zippers
00:01:39 <mm_freak> ezyang: in that case it's much easier =)
00:01:46 <wavewave> I mean GPGPU like NVIDIA.
00:01:48 <ezyang> FunctorSalad_: I suspected so
00:02:13 <ezyang> mm_freak: Which "case"?
00:02:46 <mm_freak> ezyang: the "book" case…  you can encode it nicely as a haskell data type
00:02:57 <ezyang> Yup
00:03:08 <mm_freak> note that types can well be recursive
00:03:09 <ezyang> I need to make a fuckton of these special-cased eithers though
00:03:19 <ezyang> mm_freak: yeah
00:03:25 <mm_freak> you won't need any Eithers =)
00:03:34 <ezyang> mm_freak: really?
00:03:51 <mm_freak> data Section = Section Title [Content]
00:03:52 <ezyang> if I do the obvious recursive type, it doesn't encode the restrictions on what can be in waht
00:04:06 <mm_freak> data Content = SectionContent Section | ParaContent Paragraph
00:04:07 <mm_freak> etc.
00:04:28 <ezyang> I'd call that a special case either, but I think we're in agreement
00:05:01 <systemfault> Hmm, I'm trying to compile ghc with LLVM on OSX 10.6, it compiles... but when I try to compile something with the resulting GHC, the executable is huge (32MB) and super slow.. Anyone has an idea^
00:05:01 <ezyang> Ugh. This is so boneheaded. "Define both a getBoss(x:Employee, a:Company) and a getEmployees(x:Employee, a:Company) method."
00:05:16 <ezyang> "No, I can't give you an efficient getBoss if you give me just an Employee and not a zipper"
00:05:27 <luqui> is there a library that handles measurement unit checking
00:05:27 <mm_freak> "method"?
00:05:38 <ezyang> mm_freak: We're pretending to be FPers in Java
00:05:46 <ezyang> they've even invented their own pseudocode FP syntax
00:05:53 <ezyang> (this is a homework assignment)
00:06:01 <ezyang> I've gone and asked them if I can do the assignment in Haskell.
00:06:47 <mm_freak> why would a sane person do FP (or any programming) in java?
00:07:07 <ezyang> mm_freak: Beats me.
00:07:13 <ezyang> According to my friends, the professor has a hard-on for Java.
00:07:29 <ezyang> There is a semi-vaguely good practical reason, in that they don't want to have to teach another language?
00:07:41 <ezyang> and that "you need to know how to be multiparadigm in any language!"
00:07:46 <dibblego> mm_freak, because it's better than doing not-FP in Java
00:07:58 <mm_freak> dibblego: for larger projects, indeed
00:08:41 <dibblego> mm_freak, the problem is why anyone would use Java and expect to not incur a huge penalty
00:08:49 <osfameron> Java has good libraries... might be a factor
00:08:54 <dibblego> no it doesn't
00:09:02 <mm_freak> it doesn't, but it's widely deployed
00:09:19 <osfameron> well, it has a wide range of mediocre ones? ;-)
00:09:30 <dibblego> I prefer "largely useless"
00:09:45 <ezyang> osfameron: "Well, we're not using them"
00:09:58 <mm_freak> osfameron: seemingly mediorcre
00:10:06 <mm_freak> and sold as good
00:10:24 <mm_freak> i remember trying to do FP in C#
00:10:30 <mm_freak> it worked to some extent, but it was difficult
00:10:33 <osfameron> I've heard the SOAP libraries are good
00:11:00 <osfameron> OK, so I'm a Perl programmer, and our soap libraries are pretty sucky to be honest
00:11:09 <dibblego> so are Java's
00:11:13 <mm_freak> microsoft seems to have learnt the value of side effect-free programming
00:11:17 <mm_freak> sun hasn't
00:11:23 <dibblego> mm_freak, I agree completely
00:11:50 <mm_freak> C# even has nice syntax for lambda functions =)
00:11:59 <mm_freak> (x,y,z) => x+y+z
00:12:26 <ezyang> Microsoft Research sounds like it would be a pretty cool place to work.
00:12:35 <mm_freak> yeah, i agree
00:13:16 <applicative> ezyang, just noticed this book chapter business.  Have you studied Text.Pandoc.Definition
00:13:18 <mm_freak> but sometimes i get the impression that a considerable amount of idiots work there, too
00:13:43 <ezyang> applicative: Nope.
00:13:44 <mm_freak> i remember one time i tried to write a parser monad for F#
00:14:01 <ezyang> applicative: Though, since this is a contrived pset problem, I'm not sure if that would help
00:14:04 <mm_freak> it took me hours to realize that the Bind function is uncurried
00:14:33 <mm_freak> yes, F# fully supports currying and yes, Bind is strictly F#-only
00:14:50 <applicative> but is there some idea of what is to be done with values in the 'book' type?
00:15:02 <applicative> or you're just supposed to define it.
00:15:09 <ezyang> applicative: Just supposed to define it
00:15:20 <mm_freak> and that was also the time when i realized that writing monads through fmap, pure and join is much easier than through pure and bind =)
00:15:39 <ezyang> Oh, the rich part is they want you to make all the values (Int,a) functors and do consistency checks on the numberings
00:15:41 <applicative> do the chapters and sections have headings and titiles?
00:16:00 <ezyang> nope!
00:16:05 <ezyang> why would you do something like that?
00:16:10 <ezyang> :o)
00:16:32 <ezyang> mm_freak: That seems a bit harsh (re idiots)
00:16:41 <mm_freak> yes, it is
00:17:13 <mm_freak> and i'm sorry for that…  but that was how i felt when almost giving up after hours of compiler errors that didn't make sense to me =)
00:17:51 <ezyang> :^)
00:19:10 <applicative> in pandoc, chapters, sections and subsections reduce to their headings or numbers.  They are of they type Block.  Paragraphs and figures are Blocks.  A document is a pair of metadata and a list of blocks.  It seems it coujldn't be so simple, but in writing the types one forgets the linear character of a book.
00:19:16 <ezyang> Anyway, going to bed now
00:19:29 <ezyang> hope they'll let me write the assignment in Haskell <fingers crossed>
00:19:47 <ezyang> applicative: Yeah.
00:20:08 <ezyang> From my small experience futzing with document types, it's really hard to capture both the semantic structure and the paged structure
00:20:41 <mm_freak> in general you would want to avoid mixing them anyway
00:20:56 <ezyang> yeah, but if you're a layout nut
00:22:57 <ezyang> you want to control precisely where the page breaks are
00:24:20 <mm_freak> no, some people want
00:24:24 <mm_freak> "you" don't
00:24:48 <ezyang> teehee
00:24:49 <mm_freak> unless you're compiling a newspaper, layout should be automatic
00:25:11 <osfameron> or a book.  or a flier.  or a poster.
00:25:20 <osfameron> or a poem
00:25:58 <ezyang> enh, books should have auto layout
00:26:20 <ezyang> someone should drag LaTeX kicking and screaming into the modern world
00:26:44 <mm_freak> i don't like LaTeX that much
00:26:47 <osfameron> I tried to typeset some of my dad's old children's stories using something like markdown2latex
00:26:55 <osfameron> it was a massive pain to do it automatically
00:27:10 <osfameron> and I ended up using some opensource dtp program in the end
00:27:34 <ezyang> not really surprising
00:27:35 <mm_freak> osfameron: at some point you just get it and then auto-layout becomes easy
00:27:38 <osfameron> as long as you don't want drop-caps/finely controlled positioning of images/control of kerning/etc. I'm sure automatic layout is lovely
00:27:59 <ezyang> I put up with raw LaTeX because the output is just so pretty
00:28:01 <mm_freak> actually as soon as you think in auto-layout, you'll find it increasingly difficult to do manual layout
00:28:09 <osfameron> mm_freak: I get auto-layout for writing a blog...
00:28:22 <ezyang> hyphenation, smart justification, kerning, page break attention, etc etc
00:28:26 <mm_freak> i get auto-layout for almost anything
00:28:49 <ezyang> anyway, off topic
00:28:59 <ezyang> g'night all!
00:29:03 <ezyang> thanks for the answers :-)
00:29:09 <mm_freak> good night
00:29:14 <osfameron> latex would certainly have been capable of what I wanted to do... markdown really wasn't
00:29:27 <Entroacceptor> 'raw latex' somehow that idea is funy
00:29:41 <osfameron> and latex is a massive pita, and I don't even begin to understand how to make it understand obscure things like images :-)
00:30:08 <mm_freak> well, LaTeX gets usable with a good document class
00:30:16 <mm_freak> i use 'memoir' for most things
00:30:19 <Entroacceptor> and images aren't much of a problem
00:30:42 <mm_freak> yeah…  though getting your floats to look the way you desired is =)
00:31:03 <Entroacceptor> how so?
00:31:22 <Entroacceptor> I only sometimes have trouble placing them
00:31:35 <mm_freak> dunno, somehow i'm never satisfied with the defaults
00:32:12 <osfameron> latex seems one step beyong "auto-layout" though, really
00:32:31 <osfameron> once you get to the point that you're tweaking finer details, it's no longer entirely semantic
00:32:42 <mm_freak> yeah
00:33:38 <mm_freak> but nothing is completely semantic and always looks the way you want =)
00:34:28 <altmattr> latex is not auto-layout
00:34:30 <altmattr> it wants to be
00:34:37 <altmattr> it wants you to think it is
00:34:40 <altmattr> but it is not
00:34:50 <altmattr> because nothing ever could be
00:35:35 <mm_freak> LaTeX has nice output, especially when it comes to math (where it really isn't auto-layout)
00:36:11 <altmattr> i wish there was a browser that used latex's kerning and hyphenation rules
00:38:47 <Entroacceptor> has any of you tried texmacs?
00:38:56 <mm_freak> Entroacceptor: yeah, i did
00:39:11 <Entroacceptor> I can't stand emacs for some reason, but I liked the idea
00:39:16 <Entroacceptor> how is it?
00:39:48 <mm_freak> the editor isn't that great…  the cursor likes to hide from you and it feels a little jerky
00:40:02 <mm_freak> also it's nowhere near LaTeX in terms of features
00:41:25 <mm_freak> although it's quite convenient for auto-generated stuff like graphs and diagrams
00:41:43 <mm_freak> and plots =)
00:42:18 <mm_freak> it's also very convenient for inputting math stuff
00:43:25 <McManiaC> theres no real alternative to latex for scientific papers etc :S
00:43:53 <mm_freak> XHTML =)
00:43:59 <McManiaC> nah
00:44:05 <mm_freak> that was sarcasm
00:44:08 <McManiaC> :P
00:44:16 <chr1s> I remember that there was some typed variant of tex.
00:44:34 <chr1s> one that produces helpful error messages
00:44:44 <McManiaC> hehe ok
00:45:21 <chr1s> it's quite hard to find though.
00:45:52 <McManiaC> auctex is the only reason for me to use emacs :>
00:47:09 <mm_freak> well, i like emacs =)
00:47:46 <mm_freak> particularly because of its good support for…  well…  any text format =)
00:48:44 <Ke> heh
00:48:56 <McManiaC> http://n-sch.de/xmonad/working.png =)
00:49:20 <Ke> in the year 2000 there will be latex variant that can include both eps and svg graphics
00:50:27 <Ke> what's that layout
00:50:39 <McManiaC> even though emacs isnt my favorite editor, auctex is one of the few usable latex editors :S
00:51:00 <Entroacceptor> yeah, that looks good...
00:51:21 <Entroacceptor> but so far I found emacs to be horrible to use :)
00:52:20 <McManiaC> it feels pretty simple after using vim
00:52:21 <McManiaC> ;D
00:53:22 <Entroacceptor> well, I'm using vim
00:53:49 <mm_freak> http://streitmacht.eu/scrshot.png =)
00:55:39 <McManiaC> in emacs you just start writing. you'll learn the key commands as you're using it
00:55:45 <McManiaC> vim is the other way around
00:55:45 <McManiaC> :>
00:56:07 <McManiaC> and you can use many of emacs core keys in vim too :>
00:56:20 <Entroacceptor> for some reason I learned the vim stuff on the way
00:56:31 <Entroacceptor> but never managed emacs
00:56:34 <mm_freak> vim has some great text editing capabilities, but i don't like it
00:56:36 <Entroacceptor> although I even tried the tutor
00:57:07 <Entroacceptor> but of course we'll all use Yi soon ;)
00:57:14 <mm_freak> or leksah
00:58:00 <McManiaC> yi looks nice but is still far away from beeing as powerfull as vim/emacs
00:58:09 <Entroacceptor> yes
00:58:13 <koala_man> it's funny when people get upset when they have to press 'i' before writing things and keep forgetting. but what if they forget to type 'emacs' first and just writes it all on the shell prompt?
00:59:36 <mm_freak> well, when i tried to use vim, i noticed that it has a much more cursorily understanding of the text format you're editing
00:59:44 <profmakx> mm_freak your ipv6 is b0rked
00:59:52 <mm_freak> ;)
01:00:04 <Entroacceptor> I like the idea of using true parsers in the editor
01:00:10 <McManiaC> mm_freak: yeh, you have to do more "by hand" than with emacs
01:00:17 <mm_freak> yeah
01:00:21 <McManiaC> but otoh this gives you more control over it, too
01:00:32 <Entroacceptor> can you give examples?
01:00:47 <mm_freak> Entroacceptor: indentation
01:00:47 <McManiaC> and with vim it's not very time consuming to do so =)
01:01:21 <mm_freak> emacs knows what i want to do…  i just hit tab
01:01:53 <McManiaC> you still have to hit it quite a few times before you'll get what you want sometimes
01:01:56 <McManiaC> =)
01:02:02 <mm_freak> and i don't buy the "less intelligence gives you more control, which is a good thing" argument
01:02:10 <mm_freak> according to that we should use C and not haskell ;)
01:02:17 <tomberek> hey, how are dependencies working out for everyone? cabal is working?  6.12 upgrade went smoothly?
01:02:31 <mm_freak> i'm using 6.10
01:03:45 <Entroacceptor> mm_freak: indentation works for me...
01:03:47 <tomberek> do you use Arch?
01:03:53 <Entroacceptor> ok, I have to set the shiftwidth
01:03:56 <mm_freak> gentoo here
01:04:11 <McManiaC> mm_freak: basic indention works ootb
01:04:12 <tomberek> does gentoo have haskell packages? or do you use cabal?
01:04:25 <McManiaC> everything else kand be done with ^d and ^t for example
01:04:30 <mm_freak> McManiaC: about having to hite tab multiple times…  that's for haskell and only with the legacy indenter
01:04:40 <mm_freak> the new indenter is much smarter, but i don't like it
01:04:54 <McManiaC> and if you want to get back, lets say 2 "indentions" this *can* be faster
01:04:58 <mm_freak> tomberek: gentoo has haskell packages
01:05:10 <tomberek> do you use those or cabal?
01:05:10 <mm_freak> GHC 6.12 is currently masked
01:05:26 <tomberek> or can you use either and mix it up with no ill effect?
01:05:37 <mm_freak> mostly i use gentoo packages except for one library, which isn't in the haskell overlay:  monadLib
01:06:40 <McManiaC> mm_freak: and as far as C vs haskell goes - even C can be faster than haskell ;P
01:07:02 <mm_freak> McManiaC: you can do that in emacs, too, but my indentation doesn't match tabs exactly
01:08:13 <McManiaC> of course you can do that in emacs too
01:08:21 <McManiaC> cant you do everything in emacs? ;)
01:08:32 <mm_freak> and there is always the option of using the new indenter, but what i really hate about it is that it autoindents when pressing enter
01:17:10 <tomberek> when you use cabal, do you generally do --global , or --prefix something?
01:18:54 <Cale> I install things as user, which is the default
01:19:08 <Twey> Ditto
01:19:33 <tomberek> Cale: i ask because I find sometimes things get installed to different places than i expect
01:20:41 <Cale> It helps to make sure that the ~/.cabal/bin directory is either a symlink to something in your $PATH, or is itself in your $PATH
01:21:05 <tomberek> yeah, i did that
01:21:09 <tomberek> *I'm generally on a rant at all package managers today.*
01:21:11 <mm_freak> ditto, as user
01:26:42 <ivanm> tomberek: is it the fault of the package managers or the lack of people managing the packages?
01:27:02 * ivanm uses system packages for everything on his machine at home
01:27:12 <ivanm> at uni I do per-user installs because I don't have root access
01:27:45 <tomberek> ivanm: well, i guess the people, but then again, i think there should be restrictions as strong as a type system for dependencies to be included and exact, and standards followed.
01:28:43 <ivanm> you obviously missed my point: if you don't like the lack of updates in your distro's haskell packages, get involved and help bring them up to scratch!
01:29:27 <tomberek> ah... well, i'm working on what i hope will become a package.. you can be sure I will make it accurate.
01:30:30 <chr1s> have you guys tried the nix package manager?
01:30:36 <chr1s> it's a purely functional one.
01:30:59 <tomberek> chr1s, i just tried it,,, not a fan
01:31:56 <tomberek> i like the idea, but not the execution
02:05:24 <ivanm> where be preflex?
02:15:10 <mjrosenb> argh
02:15:36 <mjrosenb> i am having some severeissues with runInteractiveProcess and hPutStrLn
02:15:46 <mjrosenb> has anyone used either of these before?
02:21:27 <kmc> i have used hPutStrLn, it is pretty standard
02:21:36 <kmc> @hoogle runInteractiveProcess
02:21:37 <lambdabot> No results found
02:21:43 <dv-> I've used runInteractiveProcess
02:21:54 <kmc> from System.Process?
02:22:05 <kmc> mjrosenb, what are your severeissues
02:22:18 <ivanm> mjrosenb: I bet I know what your problems are
02:22:20 * ivanm pulls out his blog post discussing this
02:22:32 <mjrosenb> i am having issues with writing into the Handle that corresponds to stdin.
02:22:35 <mjrosenb> it looks like the writes are not going anywhere
02:22:46 <ivanm> mjrosenb: http://ivanmiljenovic.wordpress.com/2009/12/10/command-inputoutput-and-blocking/
02:22:51 <ivanm> I bet that's your problem
02:24:00 <mjrosenb> while i look at that, my code is: http://paste.pocoo.org/show/195867/
02:25:43 <mjrosenb> it prints out the line of gibberish
02:25:53 <mjrosenb> but it never prints out the first line.
02:26:13 <ivanm> yeah, looks like my problem that I describe there
02:26:51 <ivanm> mjrosenb: you should also use forks, etc. when dealing with  runInteractiveProcess
02:27:45 <ivanm> e.g. http://hackage.haskell.org/packages/archive/graphviz/2999.8.0.0/doc/html/src/Data-GraphViz-Commands.html#graphvizWithHandle%27 (the cleaned up version of what's in the blog post)
02:31:07 <mjrosenb> ivanm: why would it run the second print line, but not the first without forkIO?
02:31:50 * dmwit takes a guess that it's block-buffered
02:32:00 <ivanm> mjrosenb: because its sent the String to the process, but the process is waiting for hClose
02:32:06 <ivanm> whereas the second goes straight to stdout
02:32:11 <mjrosenb> oic...
02:32:18 * mjrosenb sets lune buffering on it
02:32:26 <dmwit> Hard to say for sure without seeing writeto.sh, though.
02:33:14 <mjrosenb> cat - > out.txt
02:34:35 <tombee> How much of a threat is F# to Haskell?
02:34:46 <dmwit> threat?
02:35:21 <dmwit> Can't we all just get along?
02:35:30 <tombee> :)
02:36:15 <ivanm> *groan* I have to special case yet another function to distinguish whether empty String values are allowed or not :s
02:36:19 <tomberek> threat? are we at war?
02:36:35 <dmwit> Or, to answer another way: how much of a threat is peanut butter to bananas?
02:37:12 <dibblego> some people don't understand what it means to be divorced from the idea of language fanaticism
02:37:34 <tombee> Just wondering if the haskell community has seen any impact from F#
02:37:51 <dibblego> like I said :)
02:37:52 <fasta> I think I have to meet the first person who thinks F# as a language has anything but tools to offer over OCaml.
02:38:17 <tombee> Heh ok cool fasta :)
02:38:27 <dmwit> If anything, F# is a gateway drug to Haskell. =)
02:39:05 <arw_> well. running on the .net vm is a pro and a con at the same time. if you can use .net, its great, if not its a major problem.
02:39:52 <tombee> Cool thanks dmwit, I'd really like to spend some serious time learning Haskell, but the worry is how long is Haskell going to be around? :)
02:39:57 <fasta> The idea of being enthusiastic about what is in essence a proprietary platform puzzles me.
02:40:17 <tombee> I'm not a fan of the idea of F# :(
02:40:22 <ivanm> dibblego: did you see them thinking you were on an idiot on proggit?
02:40:30 <kmc> F# is just another "pragmatic alternative to Haskell"
02:40:37 <kmc> we need to market Haskell that way, and we will crush it
02:40:40 <fasta> If a company can decide on a day by day basis to take away what you have, what is the point of using it in the first place?
02:40:42 <arw_> fasta: not so much enthusiasm. more like relief, because what came before was even worse.
02:41:39 <kmc> tombee, it's been around 20 years already
02:41:43 <dmwit> fasta: Oh, for a second there I thought you were talking about PayPal. O_o
02:41:52 <tombee> Yeah I gather that kmc :)
02:42:09 <fasta> dmwit, everyone complains about PayPal, but at least it is a competitor.
02:42:22 <dibblego> ivanm, who?
02:42:29 <fasta> The concept of a "payment platform" and paying to pay is also ridiculous imho.
02:43:07 <dmwit> yeah
02:43:22 <fasta> Running a payment system should be the task of a government and it should take no more than one million euros to do so per year.
02:43:48 <fasta> Anything over that is guaranteed waste.
02:44:15 <ivanm> dibblego: http://www.reddit.com/r/programming/comments/bk8oq/how_to_discuss_functional_programming_and_look/
02:44:19 <fasta> (Numbers based on a small country. )
02:44:22 <arw_> fasta: look at the expenses of the average stock exchange for electricity, then we can talk about the 'one million euros per year'
02:44:30 <arw_> fasta: very small country :)
02:44:54 <dibblego> ivanm, how sad
02:45:09 <fasta> arw_, so what are these expenses? I don't see how you would need more than a room of computers to make it work for The Netherlands.
02:45:26 <fasta> arw_, and international transactions don't happen all the time currently.
02:45:39 <kmc> tombee, the ecosystem of compilers / libraries / tools around Haskell is mostly open-source stuff worked on by hundreds of people
02:45:54 <fasta> arw_, only a tiny fraction will be international.
02:46:12 <kmc> whereas F# is mostly driven by microsoft
02:46:49 <kmc> so F# seems more likely to suddenly "dry up" one day, if MS wants to put their efforts elsewhere
02:47:15 <fasta> Visual Basic 6 comes to mind.
02:47:18 <tombee> :)
02:47:55 <fasta> (not that I care anything about that language, I just remember the Internet being spammed by companies annoyed by MS)
02:48:08 <arw_> fasta: stock trading systems do huge numbers of transactions because there are programs trading that exploit tiniest price differences, either in time or in location of trade. thats also the reason why a good part of those trades will be international.
02:48:25 <tombee> This is true kmc, however, I'm sure microsoft will be keen to preach their 'cutting edge, functional programming language' :)
02:48:38 <fasta> arw_, I don't see how stock trading and having a bankaccount are related.
02:48:54 <fasta> arw_, you normally don't get a trading account when you open a bankaccount.
02:49:05 <kmc> tombee, sure, until they decide something else is better.  after all C# is a functional language too, maybe they will add enough features to make it a *good* functional language
02:49:26 <arw_> fasta: most banks i saw do that. either you get a free depot account or you get one for an euro a month or something.
02:49:37 <kmc> point is, for F# to dry up, only microsoft has to decide it's obsolete.  whereas for Haskell to dry up, all of the Haskell fanatics who work on it in their free time for fun have to decide it's obsolete
02:49:43 <fasta> arw_, a bank accounts costs anything between 40 and 100 euros per year depending on where you are in Europe. The same could be done for 1 euro per year.
02:49:50 <kmc> the latter i don't see happening unless Agda is really successful :D
02:50:07 <arw_> fasta: and besides, there is not much of a difference between shifting money and shifting stocks. and my bank account costs me 0 euros per year.
02:50:32 <fasta> arw_, 0 euros per year? Sure.
02:50:45 <arw_> fasta: dkb.de if you read german :)
02:50:54 <arw_> fasta: and there are others.
02:50:55 <kmc> you need fancy computers and networks in order to handle multi-gigabit data and trade feeds for thousands of market participants and to carry out complicated order-matching rules in fractions of microseconds
02:51:03 <kmc> this is obviously a real expense
02:51:09 <fasta> arw_, ok and can you also do European transactions?
02:51:13 <kmc> which has nothing to do with your damn checking account
02:51:14 <arw_> fasta: yes
02:51:24 <fasta> arw_, and anyone in Europe can open an account?
02:51:41 <arw_> fasta: not sure. anyone in germany yes, europe don't know.
02:51:57 <fasta> arw_, ok, well, maybe Germany is more sane then.
02:52:11 <tombee> I disagree fasta  ;)
02:52:49 <arw_> fasta: well, kind of sane. we also have some ripoff banks where you pay like 5eur per month and 20 cents per transaction (even incoming)...
02:53:12 <fasta> arw_, that's kind of the situation in France.
02:53:12 <kmc> in the US a checking account is almost always free
02:53:26 <tombee> I'm living in Germany currently, my bank account is free because I'm a 'praktikant'
02:53:36 <fasta> arw_, my Dutch account provides more service and is cheaper than the one in France.
02:53:39 <kmc> and insured to $250,000 by the government
02:53:46 <dibblego> ivanm, how sad :( I think I am going to study medicine
02:53:53 <fasta> arw_, (and still the Dutch account is far from free)
02:54:34 <fasta> arw_, and of course the French law dictates having a French account.
02:54:42 <fasta> arw_, so much for Europe...
02:55:00 <fasta> I would dump my French account immediately if I could.
02:55:05 <ivanm> dibblego: admittedly, when reading through the comments you do come off sounding a bit weird >_>
02:55:13 <ivanm> you sure you weren't high on some extra strong meds at the time? :p
02:55:33 <dibblego> ivanm, I was actually
02:55:56 <mreh> soda pressed?
02:55:57 <ivanm> that could be it then
02:56:01 <dibblego> ivanm, I was taking oxycodone and I don't think it is weird to address the question that was first stated
02:56:10 <ivanm> you read as being pretty incoherent and confrontational there
02:56:18 <fasta> arw_, that bank has an invalid certificate https://dkb.de/kontakt/index.html
02:56:25 <dibblego> ivanm, I asked a question; nothing more
02:56:48 <mreh> now now guys, please be nice
02:56:53 <arw_> fasta: just no redirect to www.dkb.de
02:57:15 <dibblego> mreh, there is nothing not nice about an honest discussion, try it
02:57:30 <mreh> is anyone going to Holland for the FP summer school?
02:57:42 <ivanm> dibblego: "I need to know what a functional language is." <-- I _think_ you were wanting Jameson to say what _he_ thinks an FP lang is
02:57:49 <ivanm> but it doesn't read like that
02:58:05 <fasta> arw_, it was a link from their own website. Kind of amateuristic imho.
02:58:06 <dibblego> ivanm, sure reads like that to me
02:58:18 <mreh> dibblego, politeness is a virtue
02:58:24 <arw_> fasta: agreed.
02:58:37 <dibblego> ivanm, furthermore, I think the term "functional language" is useless
02:58:44 <ivanm> dibblego: even before I read what the people on proggit were saying, it sounded like you were avoiding the issue to me
02:58:58 <dibblego> ivanm, I asked a question, nothing more. There was nothing to avoid
02:59:11 <ivanm> admittedly, Jameson's previous comment was stupid
02:59:22 <ivanm> dibblego: I'm not saying there was, it just _reads_ that way
02:59:32 <dibblego> ivanm, that's a projection bias
02:59:40 <ivanm> *shrug* could be
02:59:57 <dibblego> unless of course, there is something more, but there isn't; just a question
03:00:51 <mreh> man, the IT staff have padlocked these headphones to the other cables!
03:01:01 <mreh> I only want to borrow them
03:01:49 <tombee> cut the other cables
03:02:07 <fasta> mreh, they are pretty sure you want to steal them.
03:02:51 <mreh> they're paranoid :)
03:03:15 <tombee> Any recommendations for resources to learn haskell? Seems a large list of web resources and textbooks on the haskell wiki :p
03:03:31 <mreh> tombee: practice!
03:04:01 <tombee> :)
03:04:04 <metaperl> tombee: real world haskell was nice for me for the first few chapters
03:04:08 <mreh> tombee: go to a good summer school, that's something I have missed, alternately watch video lectures, there are so good ones on LtU
03:04:11 <arw_> tombee: practice, learn you a haskell and doing project euler in haskell.
03:04:19 <mreh> @google lambda the ultimate video lectures
03:04:20 <lambdabot> No Result Found.
03:04:21 <sioraiocht> project euler!
03:04:21 <metaperl> tombee: the text is free online
03:04:29 <sioraiocht> awesome use of haskell
03:04:38 <ivanm> dibblego: what I was getting that is whilst you may not have intended to seem confrontational/trollish/etc., that your writing style can be interpreted as being in that light
03:04:38 <tombee> Thanks, I'll check those out, video lectures sound good :)
03:04:43 * mreh has never done a project euler problem
03:04:46 <ivanm> @slap sioraiocht
03:04:47 * lambdabot hits sioraiocht with an assortment of kitchen utensils
03:04:57 <sioraiocht> ivanm: why the hate? =p
03:04:59 <mreh> tombee: they helped me get monads in no time
03:05:05 <dibblego> ivanm, I accept that and I simply do not care
03:05:06 <mreh> sioraiocht, just correction, not hate
03:05:08 <ivanm> we need to start the anti-project euler crusade!
03:05:29 <mreh> i'll paste a link for those vids
03:05:31 <dibblego> ivanm, I have no intention of obligation to appease those who seek out indications of ill intentions
03:05:35 <dibblego> s/of/or
03:05:38 <ivanm> sioraiocht: especially after Haskelllove's obsession with it, I highly loathe its existence
03:05:46 <sioraiocht> I didn't actually learn haskell via project euler
03:05:47 <mreh> hahah
03:06:05 <tombee> Thanks mreh, unfortunately the summer school isn't an option, as I'm working in Germany on an internship :(
03:06:07 <sioraiocht> I do them and try to et the best performance out of them
03:06:22 <ivanm> dibblego: right, but even to someone who _isn't_ seeking ill intentions (i.e. me) it read as being slightly... strange
03:06:25 <mreh> tombee: it's a week, tell them you want a week off
03:06:44 <mreh> fill in the requisite paper work and submit to your superiors
03:06:48 <dibblego> ivanm, either you are or there is something more than a question; one of those is true
03:07:04 <tombee> I've not got much leave left, need to save it for the end of my internship now.
03:07:09 <mreh> tombee: http://lambda-the-ultimate.org/node/1303
03:07:12 <tombee> Had to take emergency leave this week to get back to the UK.
03:07:16 <ivanm> dibblego: I'm not saying that you were or were not asking a question
03:07:18 <tombee> Thanks mreh.
03:07:25 <mreh> tell them it's career development
03:07:28 <ivanm> but you going and asking what a functional language is seems weird
03:07:31 <ivanm> considering you're a proponent of FP
03:07:43 <dibblego> ivanm, no I'm not; it's just a common charge levied against me
03:07:59 <mreh> I think we need a group hug
03:08:20 <ivanm> dibblego: so you _don't_ like FP? :o
03:08:27 <dibblego> mreh, please stop it; there is no problem here
03:08:38 <mreh> teehee
03:08:41 <dibblego> ivanm, no I don't not "like FP"
03:08:52 * koala_man hugs mreh 
03:08:55 <ivanm> mreh: I think it's just more that dibblego and I are agreeing with each other, we just don't realise it :p
03:09:01 <ivanm> dibblego: :o
03:09:15 <mreh> ivanm: it was a double negative
03:09:16 <dibblego> ivanm, I find "liking" anything quite silly, let alone something that is meaningless "FP"
03:09:24 <ivanm> what, you just prefer it to Java?
03:09:48 <dibblego> <dibblego> some people don't understand what it means to be divorced from the idea of language fanaticism
03:09:50 <koala_man> you mean your level of affection to something isn't relevant?
03:10:01 <ivanm> mreh: oh, right, missed the "not"
03:10:12 <dibblego> #haskell-blah?
03:10:16 <ivanm> fair enough
03:22:32 <dmhouse> Random straw poll: is it worth paying £390 rather than £330 (~ US$585 over US$510) to get Windows 7 rather than Vista, and a 500GB hard drive rather than a 320GB one? (Considering I'll be using Linux most of the time and, although I've ran out of room on my current 20GB hard drive, I think I'd struggle to fill a 500GB one.)
03:23:16 <arw_> dmhouse: i'd say no.
03:23:58 <arw_> dmhouse: a TB hard drive is just above 100eu, and a win7 upgrade is also not too expensive (depending on the edition)
03:24:07 <dmhouse> Sorry, that should be £390 rather than £340, but yeah.
03:24:16 <fasta> dmhouse, you should figure out for which OS the drivers are natively written.
03:24:20 <dmhouse> It seems a Win7 upgrade is ~£100.
03:24:31 <fasta> dmhouse, if it is is Vista (likely), pick Vista.
03:24:38 <dmhouse> fasta: they're different laptops
03:24:46 <dmhouse> But that's the only real differences in their spec.
03:25:24 <fasta> dmhouse, then I would say no, since you can get a bigger external harddrive much cheaper if needed.
03:25:34 <dmhouse> Ack, I fucked up the prices again: the two options are £390 for Win7 + 500GB vs £340 for Vista + 320GB.
03:25:38 <koala_man> external harddrives on laptops is not that fun
03:26:40 <dmhouse> Yeah, my main question is whether Windows 7 is worth the extra £50 I guess.
03:26:41 <fasta> dmhouse, also it depends on how you value your time ;)
03:26:56 <arw_> dmhouse: if you are mainly using linux, the nope.
03:27:01 <dmhouse> Okay
03:27:17 <arw_> dmhouse: if you are mainly using windows, then yes, because its faster and eats somewhat less ram...
03:28:08 * dmhouse still can't imagine filling the 4GB of RAM both options have, compared to his measly current 512MB...
03:29:02 <koala_man> more disk cache helps a lot
03:29:50 <yaxu> Hi all I'm having some confusion about types http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24549#a24549
03:30:34 <xerox> dmhouse: I vote yes
03:30:34 <yaxu> it seems I'm not allowed to have a list of type Param a
03:31:15 <dmhouse> yaxu: you're misunderstanding how type variables work
03:31:43 <dmhouse> yaxu: Param "foo" (1 :: Int) has type Foo Int. It does *not* have type Foo a.
03:32:21 <dmhouse> If it had type Foo a, then this means that you can assume the `test' bit has any type whatsoever. It doesn't; it has type Int.
03:32:37 <yaxu> dmhouse: Ok thanks I think I understand that
03:32:44 <dmhouse> You might be getting confused because if a function expects something of type Foo a, then you could pass it Foo Int.
03:33:02 <dmhouse> That's fine -- the function wants something with a general type and you pass it something with a specific type.
03:34:30 <dmhouse> Specialising is fine. But you can't generalise: if something expects a Foo Int, you can't pass it a Foo Float.
03:34:44 <yaxu> right OK, it is interesting that map f [a, b] doesn't work in this case when [f a, f b] does
03:34:59 <dmhouse> Indeed, they're not always the same thing.
03:35:09 <yaxu> so it wouldn't make sense to have a 'generalised' list
03:35:56 <dmhouse> yaxu: to have a generalised list would break quite a lot of things in Haskell's type system.
03:36:05 <yaxu> I suppose my code isn't idiomatic haskell if I'm running against this
03:36:55 <yaxu> thanks dmhouse
03:37:00 <dmhouse> xerox: why?
03:39:41 * hackagebot bytestring 0.9.1.6 - Fast, packed, strict and lazy byte arrays with a list interface  http://hackage.haskell.org/package/bytestring-0.9.1.6 (DuncanCoutts)
03:40:53 <ivanm> dcoutts: what bug was fixed this time?
03:41:41 <dcoutts> ivanm: an IO bug with unicode text handles, patch by JaffaCake
03:42:04 <ivanm> is this a likely/common bug?
03:42:11 <dcoutts> not really
03:42:16 <ivanm> *phew*
03:42:22 <ivanm> since bytestring is a boot library and all...
03:42:59 <dcoutts> happens when you hGetContents of a text mode Handle, when the underlying file contains invalid encoded text data
03:43:00 <JaffaCake> you have to be using lazy BSs, with a text-mode Handle, on a pipe or socket
03:43:10 <dcoutts> right, something that is non-blocking
03:43:17 <dcoutts> ie not just a file
03:43:48 <JaffaCake> setting the Handle to be binary mode should avoid it (although the bug reporter said it didn't, I don't understand why)
03:46:04 <ivanm> dcoutts: btw, do you know much about how to "safely" use unsafePerformIO?  I'm not sure how necessary the three bullet points listed here are: http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.2.0.0/System-IO-Unsafe.html
03:46:54 <fasta> ivanm, the FFI specifies this in a horrible manner such that nobody can tell.
03:47:04 <ivanm> heh, fair enough
03:47:31 <ivanm> I'm just wondering about my own usage of unsafePerformIO in graphviz; I can do the NOINLINE easily enough, but I"m not sure if the other two apply to what I'm doing
03:47:36 <fasta> ivanm, dcoutts_ might say something, but it will probably be based on what implementations do, not what the specification says.
03:47:54 <ivanm> *nod*
03:48:10 <ivanm> dcoutts: which suits me, as I care about using it properly in my code right _now_
03:48:59 <dcoutts> ivanm: the best advice is that the thing be externally pure
03:49:18 <ivanm> dcoutts: as in the IO action to be unsafe'd is pure?
03:49:22 <ivanm> @slap -fwarn-unused-do-bind
03:49:22 * lambdabot orders her trained monkeys to punch -fwarn-unused-do-bind
03:49:51 <dcoutts> ivanm: right
03:49:59 <ivanm> I've got that
03:50:23 <ivanm> (at least, I haven't managed to find a case where it isn't pure, but haven't bothered to trace down every single line in the C code to verify this)
03:50:26 <dcoutts> ivanm: that way it does not matter if it's duplicated, reordered, shared etc
03:50:33 <ivanm> *nod*
03:50:50 <dcoutts> the rules there are for things that are not pure, like allocating resources
03:50:55 <dcoutts> newIORef etc
03:51:22 <ivanm> aha
03:52:48 <dcoutts> which is indeed evil
03:56:39 <ivanm> agreed
03:56:46 <ivanm> dcoutts: so I don't have to bother about any of that?
03:56:47 <ivanm> \o/
03:57:11 <dmhouse> The docs should probably be updated to that effect.
03:57:48 <dcoutts> ivanm, dmhouse: it kind of says that already
03:58:09 <dmhouse> Hrm, I suppose it does. It could be clearer.
03:58:29 <dcoutts> "If the I/O computation wrapped in unsafePerformIO performs side effects..." it's not 100% clear if the following bits apply always or only if it has side effects
03:58:58 <dcoutts> JaffaCake: what reckon ye?
03:59:28 <JaffaCake> what docs are we talking about?
03:59:35 <dcoutts> http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.2.0.0/System-IO-Unsafe.html
03:59:47 <dcoutts> JaffaCake: unsafePerformIO, the list of things you have to do
04:00:11 <dcoutts> the questions was does that apply always, or just for IO actions that are impure
04:00:20 <dcoutts>  / have side effects
04:00:57 <JaffaCake> if there are no side effects, then nothing can go wrong
04:01:38 <JaffaCake> I would s/writing and compiling modules that use/using/
04:01:53 <dcoutts> JaffaCake: right, but it's not that clear from the text that the list of conditions applies only for things with side effects
04:02:37 <dcoutts> it wasn't obvious to ivanm, he was asking me if he has to bother with that if his IO action has no external side effects
04:02:38 <JaffaCake> and s/core dump/crash
04:02:55 <ivanm> dcoutts: exactly
04:03:12 <JaffaCake> ah, *external* side-effects
04:03:25 <JaffaCake> that's not the same as having no side effects
04:03:29 <ivanm> may I suggest providing documentation about when it's "safe" to use unsafePerformIO, and what to do if you're stupid enough to use it otherwise in definitely unsafe situations?
04:03:49 <ivanm> JaffaCake: well, technically nothing has no side effects (unless it isn't run)... >_>
04:04:04 <ivanm> how do differentiate between internal and external side effects?
04:04:44 <JaffaCake> well, it depends what you're referring to by "external"
04:04:53 <dcoutts> example: allocate; ffi call; free  vs  allocate and return a piece of memory
04:05:03 <JaffaCake> is that external to the IO action in the unsafePerformIO, or external to your library
04:05:27 <dcoutts> I was meaning external to the IO action in the unsafePerformIO
04:06:18 <JaffaCake> anyway, getting back to the original point, I think those 3 points apply only if there are side effects that could be visible outside the unsafePerformIO
04:06:34 <JaffaCake> we could make that clear, I agree
04:10:10 <fasta> JaffaCake, are you saying unsafePerformIO has actual meaning?
04:11:05 <JaffaCake> what do you mean by "actual meaning"?
04:11:08 <dcoutts> fasta: I don't think we're going that far :-)
04:11:43 <fasta> JaffaCake, I mean that someone can write a program using unsafePerformIO and point at the implementor and say "hello implementor, you made a mistake, because of this and that".
04:12:04 <fasta> JaffaCake, currently, unsafePerformIO does not really have that property.
04:12:31 <JaffaCake> there are safe uses of unsafePerformIO, but we're not explicitly listing them, that's correct
04:12:58 <JaffaCake> e.g. I'd expect 'unsafePerformIO $ return 42' to work
04:13:37 <blazemore_> Good afternoon
04:13:59 <blazemore_> How can I add an item t onto the beginning of a list of items ts?
04:14:18 <blazemore_> I have t and ts, a function is expecting a list and I need t to be the first item
04:14:18 <fasta> I think the most annoying part is "This value should be independent of the environment. "
04:14:39 <fasta> What is the "environment"?
04:14:56 <JaffaCake> fasta: that's deliberately vague
04:15:07 <fasta> JaffaCake, right, and that's what makes it useless.
04:15:19 <JaffaCake> if you say so :)
04:15:29 <fasta> JaffaCake, what is the point of using something if you don't know whether it will work in 10 years?
04:15:43 <JaffaCake> don't use it then
04:17:02 <dmhouse> blazemore_: use the (:) operator
04:17:08 <dmhouse> > 3 : [1,5,6]
04:17:09 <lambdabot>   [3,1,5,6]
04:17:38 <blazemore_> dmhouse:The function is expecting a list
04:17:50 <blazemore_> if I give it t:ts it will get... in this case a tuple
04:17:58 <blazemore_> It needs a list of tuples
04:18:08 <blazemore_> if I give it ts, it doesn't see t
04:18:15 <blazemore_> Because the first function was given t:ts
04:18:22 <dmhouse> blazemore_: hpaste.org -- paste some code
04:19:57 <ivanm> malcolmw: you around?
04:20:16 <blazemore_> http://pastebin.com/vd4LRjP6
04:20:28 <blazemore_> Scuse dodgy formatting, copypasta does that to me
04:20:41 <blazemore_> Code collaberation across platform means we mix spaces and tabs!
04:21:27 <blazemore_> value expects a list of items
04:21:47 <dmhouse> blazemore_: as well as using the (:) constructor in patterns to break lists up, you can use it as an operator to put things back together again. I.e., just do putStrLn (value k (t:ts))
04:21:47 <blazemore_> value k (t:ts) = ...
04:22:34 <blazemore_> Wow, thanks!
04:22:36 <dmhouse> But if you don't ever want to use the first item in the list, you can just do no pattern matching in the equation for value, i.e. "value k ts = ..." -- then ts is the whole list
04:22:47 <blazemore_> Possibly should have listened more in class!
04:22:51 <blazemore_> But thanks a lot
04:23:03 <blazemore_> Does Graham Hutton ever come on here?
04:23:11 <dibblego> !see grahamhutton
04:23:15 <dibblego> !seen grahamhutton
04:23:24 <ivanm> dibblego: preflex isn't here :s
04:23:29 <ivanm> blazemore_: very rarely, but yes
04:23:37 <dmhouse> blazemore_: I guess that function isn't finished yet, or else that parameter is completely pointless!
04:23:39 <dibblego> Last seen  : Mar 20 23:50:41 2010 (1 week, 3 days, 11:32:21 ago)
04:24:02 <blazemore_> It's part of a larger switch statement for an assignment where we emulate a database
04:24:09 <blazemore_> ^emulate^implement
04:24:10 <ivanm> dibblego: how'd you get that?
04:24:20 <dibblego> /msg nickserv info grahamhutton
04:24:21 <blazemore_> get what?
04:24:59 <blazemore_> He is my teacher
04:24:59 <HugoDaniel> Perhaps you haven't installed the profiling libraries for package `vector-0.5'?
04:25:02 <HugoDaniel> how do i solve this ?
04:25:15 <HugoDaniel> do i have to specify a special cabal parameter ?
04:25:32 <dmhouse> blazemore_: oh right, so that function carries on down below the case for "value"?
04:25:38 <blazemore_> lol yes
04:25:43 <blazemore_> it's one of around 8
04:25:45 <dmhouse> Got it
04:25:49 <blazemore_> each doing a very different thing
04:26:05 <blazemore_> Anyway thanks for your help, coursework deadline is 23:59:59 so have to hurry
04:26:48 <dmhouse> Enjoy.
04:30:07 <Botje> pfft. you still have 10 hours. move here :)
04:30:48 <ivanm> just under 1.5 hours here...
04:33:49 <HugoDaniel> There is no available version of cairo that satisfies >=0.9.11
04:33:50 <HugoDaniel> :(
04:34:52 <ivanm> HugoDaniel: gtk2hs
04:35:03 <ivanm> it's not on hackage (yet)
04:35:15 <HugoDaniel> ah yes
04:35:16 <HugoDaniel> :)
04:35:23 <HugoDaniel> yes yes, ive installed it now
04:36:40 <kalven> so... I need to add another parameter to a constructor that I have used in 150 or so places.. am I screwed?
04:37:25 <ivanm> kalven: if you're using it that much directly, you're probably doing it wrong
04:37:51 <blackdog> heya all
04:37:58 <ivanm> hey blackdog
04:38:02 <blackdog> there was a series of haskell lectures online at some point, right?
04:38:16 <ivanm> yeah, some microsoft thing
04:38:19 <blackdog> ivanm: hello mate. looking forward to the hackathon
04:38:25 <ivanm> \o/
04:38:31 <kalven> uhm, okay.
04:38:36 * ivanm wonders where his fellow compatriot in crime is...
04:39:58 <ivanm> kalven: if you use a record data structure, then you can add fields to it without affecting use by using a default value and just "editing" that...
04:40:12 <ivanm> blackdog: channel9.msdn.com
04:40:28 <ivanm> with Erik Meijer
04:41:00 <blackdog> ivanm: ah, righto.
04:41:06 <blackdog> with any luck there's an iphone rip
04:43:06 <ivanm> @ask malcolmw I have a situation with polyparse where I have two possibilities of what to parse, however they could both start the same; as it stands, if I try to parse the stricter one first (since the first value type can be parsed by either, but the latter can't), then when an intermediary combinator fails the entire thing fails rather than backtracking; any suggestions on what I can do?
04:43:06 <lambdabot> Consider it noted.
04:46:12 <blackdog> ivanm: there's always the classic filthy trick of factoring out the common part...
04:46:30 <ivanm> blackdog: the whole _thing_ is the common part ;-)
04:47:01 <ivanm> I'm trying to parse record labels in Dot format: thing is, a record label is just a specially formatted _normal_ label
04:54:38 <bremner> yeah, that is a nasty kludge
04:55:25 <ivanm> bremner: the entire Dot format is a nasty kludge IMHO ;-)
04:56:40 * ivanm decides to call it a night
04:56:41 <ivanm> bye all
04:57:00 <dankna> yes - it needs to be a database.  like it will be in my program ;)
04:57:04 <dankna> night then
04:57:21 <ivanm> dankna: wtf?
04:57:38 <dankna> what?  it makes sense.  a graph is easily represented by relational structures.
04:57:45 * ivanm is suddenly worried about how a database-based format for representing how to visualise graphs would look...
04:57:52 <dankna> heh heh heh
04:57:54 <ivanm> dankna: I'm talking about the Dot format...
04:57:58 <dankna> I know you are
04:57:58 <ivanm> not the graphs it represents
04:58:07 <ivanm> >_>
04:58:10 <ivanm> <_<
04:58:12 <dankna> I'm supporting it as an import format, actually
04:58:15 <dankna> so I'm familiar with it
04:58:22 <ivanm> dankna: oh? how?
04:58:30 <ivanm> (how are you importing it, that is)
04:58:44 <dankna> by, you know, parsing it :) I haven't written that code yet, so future tense might be more appropriate
04:59:00 <ivanm> dankna: I have an almost complete Dot parser in graphviz...
04:59:24 <dankna> I feel skittish about using other people's code in a commercial project, but I'll look at it if it's appropriately licensed
04:59:33 <ivanm> it's BSD3...
04:59:43 * ivanm would appreciate a cut however... >_>
04:59:44 <ivanm> :p
04:59:45 <dankna> cool
04:59:55 * ivanm <=== poor student
04:59:58 <dankna> well, if I wind up using your thing and I wind up making any money, I think that would be fair
05:00:14 <ivanm> dankna: well, you're lucky in that respect: it's only BSD3 because when I inherited it it was BSD3
05:00:20 <dankna> heh, cool
05:00:44 <dankna> yeah, I'm personally a BSD believer, I'm actually releasing some components of the commercial program under that license, the ones that make sense that way
05:00:49 <ivanm> dankna: see here for a list of parsing caveats (note that the Generalised module removes the ordering restriction): http://hackage.haskell.org/packages/archive/graphviz/2999.8.0.0/doc/html/Data-GraphViz-Types.html
05:01:38 <dankna> hmmm, I'd have to fix some of these caveats to use it, but I'd have to do the same code to use my own, so it would probably make sense to extend yours
05:01:48 <ivanm> I'm thinking of switching to a state-based printer/parser, which should remove some of the dodginess
05:01:58 <dankna> right
05:01:59 <ivanm> dankna: what kind of caveats do you have problems with?
05:02:27 <dankna> mostly it needs to deal sensibly with badly-formed input, in the same way that the original graphviz would
05:02:57 <dankna> I'm not looking at this too closely yet, but it looks like most of them are basically that issue
05:03:05 <ivanm> Note that pre-processor support is now almost complete (it doesn't support having comments, etc. within HTML-like labels; AFAIK that's the only problem with it now)
05:03:30 <dankna> the multiple edges defined on one line converted to singletons for example, I'd need to worry about
05:03:37 <dankna> *nod*
05:03:43 <ivanm> dankna: most input accepted by dot is accepted by the parser AFAIK (especially if you use the Generalised types)
05:03:57 <dankna> well, it looks like an impressive piece of work!
05:04:00 <dankna> I'll definitely keep it in mind
05:04:04 <ivanm> dankna: that means that "a -> b -> c -> d" gets converted to ["a -> b", "b -> c", "c -> d"]
05:04:29 <dankna> oh, I thought it meant that if you specified "a -> b" multiple times...
05:04:35 <dankna> that doesn't sound like a problem after all
05:04:36 <ivanm> nah
05:04:48 <ivanm> maybe I need to make that piece of the documentation clearer
05:05:13 <dankna> I wouldn't worry about it too much; if I were more familiar with the format I wouldn't have had that confusion.
05:05:17 <ivanm> and Nodes will soon be able to have port values defined in edges
05:05:27 * dankna nods
05:05:37 <ivanm> dankna: the only stuff that is likely to remain unparseable (properly, anyway) is stuff that's ambiguous
05:06:09 <ivanm> e.g. dot allows you to provide a port label of "n" to a node, even though that's a compass point
05:06:19 <dankna> well, I'd probably do some work (releasing my changes back to you, obviously) to make sure the ambiguous cases get handled the same way as the real graphviz handles them
05:06:25 <ivanm> my parser will treat it as a compass point (unless it's followed by a specific compass point)
05:06:29 * dankna nods
05:06:51 <dankna> don't expect any movement on this for about three months, the program is still maturing :)
05:06:52 <ivanm> dankna: the repo is on code.haskell.org ; I'll probably make a new release next week
05:06:55 <dankna> cool!
05:07:21 <ivanm> (getting this record-based labels parsed is what's currently holding it up; once that's done I just have to make sure that things like a:here -> b:there are parsed properly)
05:07:25 <ivanm> heh, fair enough
05:07:27 <dankna> and import formats are way down on my list of things that need doing right now.  but it IS on my list.
05:07:45 <dankna> *nod* makes sense
05:09:20 <dankna> well, thanks for pointing this out!
05:09:31 <ivanm> no worries
05:09:50 <ivanm> dankna: I'm just wanting to avoid having someone else spend their time and effort duplicating all this work _again_
05:09:57 * ivanm is still pissed off at galois about that
05:10:01 <dankna> yeah, no kidding
05:10:06 <dankna> oh, why, what did he do?
05:10:15 <ivanm> the company galois ;-)
05:10:18 <dankna> ah :)
05:10:32 <ivanm> last year, I said I was going to re-do printing and parsing to get them working properly, etc.
05:10:41 <ivanm> and then did so whilst on holidays in europe last august
05:11:04 <ivanm> during that time, however, galois hired Brian Lewis to write language-dot
05:11:09 <dankna> oy.
05:11:11 <dankna> I see.
05:11:46 <ivanm> which, apart from having a proper printer/parser at a time when the released version of my library didn't, the only advantage was that it had better support for HTML-like labels (since I had nfi what they were, since the docs for Graphviz are useless)
05:11:57 <dankna> right
05:12:10 <ivanm> anyway, the darcs version of my library now supports HTML-like labels
05:12:14 * dankna nods
05:12:22 <ivanm> so IMHO there is no reason to use language-dot now
05:12:33 <dankna> gotcha
05:12:50 <ivanm> especially since mine specifically states whats supported, whereas language-dot just knows that it's some XML field
05:12:55 <ivanm> anyway, I should hit the sack
05:12:58 <ivanm> g'night
05:12:58 <dankna> so you said
05:13:00 <dankna> okay, gnight
05:13:12 * hackagebot Cabal 1.8.0.4 - A framework for packaging Haskell software  http://hackage.haskell.org/package/Cabal-1.8.0.4 (DuncanCoutts)
05:13:14 <ivanm> (well, I did say I was still pissed about it... :p )
05:13:14 * hackagebot cabal-install 0.8.2 - The command-line interface for Cabal and Hackage.  http://hackage.haskell.org/package/cabal-install-0.8.2 (DuncanCoutts)
05:13:21 <FunctorSalad> ooh
05:13:26 <ivanm> dcoutts: *tsk, tsk* what bug did you fix _now_?
05:13:46 <FunctorSalad> thought that was the first 0.8x on hackage
05:13:50 <ivanm> dcoutts: and does cabal-install now support executables depending on the library from the same cabal file?
05:13:53 <ivanm> FunctorSalad: nope
05:14:01 <dcoutts> ivanm: now you might have believed that bytestring was bug free but you cannot have believed the same thing about cabal :-)
05:14:18 <dcoutts> ivanm: http://haskell.org/cabal/release/cabal-1.8.0.4/changelog
05:14:41 <ivanm> dcoutts: heh, it wasn't that I believed that bytestring was bug-free; it just would have been a PITA to have users upgrade if it had a major bug ;-)
05:16:09 <ivanm> dcoutts: the release/ directory doesn't seem to have cabal-install in htere properly...
05:16:20 <ivanm> http://haskell.org/cabal/release/cabal-install-latest/changelog <-- refers to 0.6.2 as being the latest...
05:16:31 <dcoutts> ivanm: yep it's not uploaded there yet
05:16:41 <ivanm> *nod*
05:16:52 <ivanm> dcoutts: so does c-i support exes depending on libs yet?
05:17:08 <dcoutts> ivanm: you'll have to wait for the changelog :-)
05:17:11 * dcoutts writes the changelog
05:17:21 <ivanm> you mean the changelog isn't in the tarball?
05:17:29 * ivanm feels ripped off...
05:35:36 <fasta> JaffaCake, the formal reading of unsafePerformIO is that only if the value is independent of the undefined object named the environment it is safe and otherwise it is not. In other words there are _no_ safe uses of unsafePerformIO other than wrapping pure values into a return for example. In other words it is a no-op. Given this demonstration I declare unsafePerformIO to be nothing more than space filling junk. I cannot imagine how anyone rational might possibly
05:35:36 <fasta>  think differently.
05:37:06 <JaffaCake> fasta: it's simply the case that we haven't explicitly formalised a safe subset of unsafePerformIO
05:37:16 <JaffaCake> if that troubles you, then don't use it
05:37:38 <JaffaCake> better still, why not try to formalise it?
05:38:09 <fasta> JaffaCake, that is formally equivalent to saying that unsafePerformIO has no safe uses. No-ops have no place in a standard.
05:38:22 <JaffaCake> it's not in a standard
05:38:40 <JaffaCake> and yes, there are no guaranteed safe uses of it
05:39:01 <fasta> It is an addendum to the report. What is the report, if not a standard? \
05:39:28 <JaffaCake> actually, we decided to remove it before adding the FFI spec to Haskell 2010
05:39:47 <JaffaCake> it is to be replaced by something that can only be used for marshaling in the FFI
05:40:07 <fasta> JaffaCake, that sounds like a good idea.
05:40:59 <fasta> JaffaCake, do you have an URL where this decision is being discussed?
05:42:00 <JaffaCake> http://hackage.haskell.org/trac/haskell-prime/wiki/ForeignFunctionInterface#unsafePerformIO
05:42:34 <dankna> what about its use for global mutable state?
05:42:56 <fasta> dankna, that falls under it of course.
05:43:11 <JaffaCake> dankna: that is not supported by Foreign.Marshal.unsafeLocalState
05:43:22 <dankna> Jaffa: yeah, I see that
05:43:48 <JaffaCake> you can still use unsafePerformIO, though it is not part of the standard and doesn't give you any guarantees
05:43:55 <dankna> well, I think you're moving in the right direction
05:44:46 <dankna> of trying to get rid of it
05:44:46 <dankna> and certainly I would never say you should standardize a function that we can't even describe what it does
05:44:49 <JaffaCake> I personally don't think we can get rid of it, but we can identify safe uses and make better APIs for those
05:44:58 <dankna> that's a good goal, yes
05:51:22 * hackagebot hakyll 2.0 - A simple static site generator library.  http://hackage.haskell.org/package/hakyll-2.0 (JasperVanDerJeugt)
06:08:56 <EvanR> JaffaCake: is it 'not safe' to use unsafePerformIO to read a file, parse it, and 'return' a constant value?
06:09:20 <JaffaCake> EvanR: no
06:09:39 <EvanR> not safe as in the reading may cause an error, or not safe as in if everything is OK the program may fail anyway
06:10:07 <JaffaCake> EvanR: the rest of the program might be writing to the same file, for example
06:10:22 <EvanR> and if it isnt?
06:10:31 <EvanR> and no other program is
06:10:46 <JaffaCake> if you can convince yourself that there are no side effects that affect the rest of the program, then perhaps arguably it is safe
06:11:04 <idnar> JaffaCake: I don't think the "other writers" problem has much to do with unsafePerformIO
06:11:15 <JaffaCake> although some would argue that it is not a pure value
06:11:41 <idnar> you have the same problem if another process is writing to the file, even while not using unsafePerformIO
06:11:43 <EvanR> are any values that come back from IO a pure?
06:12:01 <idnar> EvanR: values from a "return a" IO action
06:12:54 <idnar> also, I guess things like FFI bindings to pure functions
06:13:06 <JaffaCake> idnar: if the unsafePerformIO happened to be evaluated multiple times, it might give different answers: so unsafe in that sense
06:13:34 <idnar> oh, right
06:13:39 <JaffaCake> EvanR: there's an argument that says a particular expression should return the same value regardless of where or when it is run
06:13:56 <JaffaCake> e.g. ruling out things like System.Info.os
06:14:10 <jmcarthur> no, not ruling that out
06:14:16 <jmcarthur> that value is ugly
06:14:17 <JaffaCake> I'm not sure I subscribe to that
06:14:18 <jmcarthur> ;)
06:14:32 <EvanR> can we not consider all this stuff as input to the program
06:14:48 <fasta> Again, unsafePerformIO cannot be used for any purpose for which people might want to use it today in a safe way.
06:15:11 <EvanR> what is safe?
06:15:13 <fasta> unsafePerformIO (return 43::IO Int) is safe
06:15:24 <idnar> why is it not safe?
06:15:29 <idnar> oh, you said it is safe
06:15:32 * idnar checks his glasses
06:15:39 <jmcarthur> i subscribe to the definition of referential transparency that must also hold across different invocations of the same program, even on different architectures, but i acknowledge that there are other perfectly valid viewpoints
06:16:37 <jmcarthur> and it's not really anything religious to me. if i could think of a more descriptive word for it than "referential transparency" then i would use it
06:17:16 <JaffaCake> System.Info.os isn't really problematic if you think of it as being a different library implementation on different OSs
06:17:34 <JaffaCake> just forget about libraries, a Haskell program is a collection of .hs files
06:17:49 <jmcarthur> JaffaCake: what about distributed computing?
06:18:31 <JaffaCake> then you'd want to ensure that you were getting the same libraries wherever you ran a program, yes
06:19:17 <EvanR> oS = "cloud" ;)
06:19:32 <jmcarthur> what about the size of Int?
06:19:35 <arw_> os.indercloud.de
06:20:07 <jmcarthur> this argument has been made before. i digress
06:20:22 <jmcarthur> nothing new will come of it. i really should just make a up a new word
06:20:38 <SamB_XP> try Erlang ?
06:22:25 <FliPPeh> @src (<*>)
06:22:25 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
06:22:42 <FliPPeh> @src Control.Applicative.(<*>)
06:22:42 <lambdabot> Source not found. stty: unknown mode: doofus
06:22:45 <FliPPeh> Laaame.
06:27:48 <bastl> Hi. Is anyone online who is familiar with the multirec zipper ?
06:28:33 * hackagebot cpsa 2.0.3 - Symbolic cryptographic protocol analyzer  http://hackage.haskell.org/package/cpsa-2.0.3 (JohnRamsdell)
06:30:29 <HugoDaniel> i need to do some profiling on my app, but it uses vector, and ghc complains about me having to install the profiling for vector
06:30:33 <HugoDaniel> how do i do that ?
06:31:42 <bastl> kosmikus, dreixel and others from Utrecht, why is this? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=9135#a9135
06:33:05 <bastl> in short: are locations functorial via hmap ?
06:34:06 <HugoDaniel> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24550#a24550
06:34:25 <HugoDaniel> what does it say about my program ?
06:34:33 <HugoDaniel> what does MUT mean ?
06:35:07 <burp> everything that's not counted as init, gc and exit ;)
06:35:15 <HugoDaniel> ah ok
06:35:22 <HugoDaniel> so i really need profiling for this one :(
06:35:33 <burp> hr, no idea what it means exactly
06:35:44 <Igloo> mutator, i.e. doing what your program actually does
06:35:51 <HugoDaniel> ah ok
06:36:03 <HugoDaniel> it has to run in 1s
06:36:09 <HugoDaniel> it is currently runing in 3s
06:36:33 <HugoDaniel> let me paste the code
06:45:07 <stevenmarky> remove the system "sleep 2", done!
06:45:58 <HugoDaniel> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24551#a24551
06:45:59 <HugoDaniel> :D
06:50:31 <HugoDaniel> thats my code
06:59:03 <HugoDaniel> vector is amazing
07:00:04 <HugoDaniel> ive just changed this: foldr octaveFunc (0.0, 1.0, ix, iy, iz) [0 .. octaveCount]   into this: V.foldr octaveFunc (0.0, 1.0, ix, iy, iz) (V.generate octaveCount id)
07:00:06 * edwardk waves hello.
07:00:32 <HugoDaniel> and it dropped from real    0m3.032s  to real    0m2.679s
07:00:34 <edwardk> HugoDaniel: perlin noise?
07:00:34 <HugoDaniel> !!
07:00:42 <HugoDaniel> and octaveCount is 5 !
07:00:48 <HugoDaniel> i mean, its not that big
07:00:52 <HugoDaniel> yes edwardk :)
07:01:25 <edwardk> HugoDaniel: can you tune lacunarity and rotate octaves? =)
07:01:34 <HugoDaniel> yes
07:01:42 <HugoDaniel> lacunarity yes, rotate octaves not
07:01:44 <HugoDaniel> not yet
07:02:01 <HugoDaniel> i guess it would make things VERY slow :)
07:02:05 <HugoDaniel> even more
07:02:28 <HugoDaniel> its taking about 2.679s to show a perlin texture of 512x512 pixels
07:05:04 <HugoDaniel> 0m4.168s for 8 octaves
07:05:15 <HugoDaniel> i was generating with only 5 octaves
07:10:37 <HugoDaniel> ill just inline every function :)
07:22:53 * hackagebot uuagc 0.9.15 - Attribute Grammar System of Universiteit Utrecht  http://hackage.haskell.org/package/uuagc-0.9.15 (ArieMiddelkoop)
07:29:41 <MisterN> @src mapM
07:29:41 <lambdabot> mapM f as = sequence (map f as)
07:30:00 <MisterN> @src mapM_
07:30:00 <lambdabot> mapM_ f as = sequence_ (map f as)
07:30:07 <MisterN> :t sequence
07:30:08 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
07:30:35 <EvanR-work> No instance for
07:30:47 <EvanR-work> would be nice if it told me which class its not an instance of ;)
07:31:18 <MisterN> hmm this applicative paper claims that sequence is on IO monad
07:31:29 <MisterN> but lambdabot AND ghci say that sequence is generic on monads
07:31:35 <Saizan> mh
07:31:40 <MisterN> was that changed recently?
07:31:55 <Saizan> maybe it's just a simplification? i've only seen sequence defined for a generic monad
07:32:19 <Saizan> maybe their point is that instead it can be defined for every Applicative, which will be more generic anyway
07:32:54 <MisterN> ah maybe
07:37:31 <ijk11> Greetings, Haskellers.  I'm wondering if somebody can help me catch an InappropriateType exception, specifically.  System.IO.Error doesn't seem to provide a way to check for it.
07:37:43 <Entroacceptor> it's called Haskelletons ;)
07:37:52 <Ke> code.haskell.org/gentoo is down for a change
07:38:01 <dankna> you need Control.Exception
07:38:30 <EvanR-work> haskellites
07:38:31 <dankna> and the type of exception you catch is based on the type signature of the handler, which is usually a lambda expression
07:38:36 <dankna> Haskellies
07:38:55 <dankna> what is this, Perl where TMTOWTDI?  there should be consensus on this! :D
07:39:27 <EvanR-work> tim taudi
07:39:32 <Saizan> Igloo: http://code.haskell.org seems to be down
07:39:46 <ijk11> I did try catchJust before, but I'm still not clear on how I can identify the InappropriateType error.
07:40:08 <ijk11> The underlying goal here is to do getDirectoryContents on something that may not be a directory, and just return [] if that's the case.
07:40:17 <mreh> Haskelloids?
07:40:43 <EvanR-work> if an exception occurs in a forkIO and is uncaught, does that crash the parent thread
07:41:24 <Entroacceptor> I am HASKELLETOR!
07:41:41 <ijk11> having done the ioeGetErrorType, what can I do with that?  It's showable, but I can't test it against a string.
07:41:56 <dankna> you don't need to do ieoGetErrorType
07:42:21 <dankna> catch (do something that may fail) (\InappropriateType _ -> return Nothing)
07:42:41 <dankna> the pattern match on InappropriateType (which you may have to correct for the right number of arguments to the data constructor, I didn't look it up)
07:43:02 <dankna> is sufficient to give your handler the type InappropriateType -> IO (Maybe a)
07:43:21 <dankna> which is what catch wants
07:43:28 <ijk11> I get a "not in scope" error referencing InappropriateType.
07:43:33 <dankna> one sec
07:43:37 <dankna> @hoogle InappropriateType
07:43:37 <lambdabot> No results found
07:43:38 <ijk11> I can't seem to import it.
07:44:12 <ijk11> It is mentioned here:  http://haskell.org/ghc/docs/latest/html/libraries/haskell98-1.0.1.1/Directory.html#v%3AgetDirectoryContents
07:44:39 <Saizan> one way to import it is GHC.IO.Exception
07:44:50 <Saizan> though maybe there's a more official module exporting it
07:44:52 <dankna> ah, thanks Saizan.  I haven't used this before.
07:45:52 <ijk11> interesting.  And if I don't have GHC.IO.Exception?  I'm using runhaskell from GHC 6.10.4 if that matters.
07:47:02 <Saizan> there's no GHC.IO.Exception module on ghc-6.10.4?
07:47:17 <Saizan> you've to import it explicitly
07:47:33 <ijk11> behold:
07:47:34 <ijk11> qualia:FSStats adb$ runhaskell --version
07:47:34 <ijk11> runghc 6.10.4
07:47:34 <ijk11> qualia:FSStats adb$ runhaskell -XScopedTypeVariables bounded-du.lhs .
07:47:34 <ijk11> bounded-du.lhs:46:51:
07:47:35 <ijk11>     Not in scope: data constructor `InappropriateType'
07:47:46 <dankna> @hpaste
07:47:47 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
07:47:57 <Saizan> add "import GHC.IO.Exception" to the top of your modules.
07:48:09 <dankna> (below the "module" line)
07:48:14 <ijk11> yep, sorry, pasted wrong thing, will obey the bots and paste anew
07:48:27 <Saizan> ok :)
07:48:42 <EvanR-work> if i dont do --threaded does that mean forkIO threads will not execute concurrently?
07:48:45 <EvanR-work> what about forkOS
07:48:58 <ijk11> the haskell pastebin is very penis- and mortgage-focused at this time.
07:49:54 <dankna> ijk11: yeah, heh, we know. :(
07:49:54 <Saizan> use any pastebin you like
07:49:54 <Saizan> hpaste.org is less spammed :)
07:50:02 <pastorn> ghci loads my file and i get no errors but it says "Prelude Main>" and i don't have my file in scope :(
07:50:09 <pastorn> what happened?
07:50:21 <ijk11> http://pastebin.com/mXJp9Dv7
07:50:55 <dankna> ijk11: add "import GHC.IO.Exception" on a line by itself somewhere below your "module" line and above any actual code
07:51:22 <ijk11> yep, I've successfully imported modules before.  I'm pretty sure this one is missing.
07:51:31 <dankna> well, that's not what the error message says
07:51:40 <ijk11> hm.
07:51:49 <dankna> oh
07:51:51 <dankna> wait, it is
07:52:00 <dankna> sorry, I read the first thing
07:52:12 <dankna> hmm, I don't have a GHC 6.10.* around to test with
07:52:44 <Saizan> pastorn: touch your .hs and :reload
07:53:09 <ijk11> Given that the type is mentioned in the haskell98 docs, it seems odd that there isn't a generic haskell98 way to identify it.
07:53:33 <dankna> well, 1998 was 12 years ago and things have moved on a bit since then
07:53:59 <dankna> you're right that it's odd
07:54:16 <dankna> but it seems to be the case that you're expected to catch any IOError and re-throw the ones you don't want
07:54:40 <ijk11> Sure.  I can do that, as long as I can identify the ones I want in some way.  There's no predicate for InappropriateType, though.
07:54:54 <pastorn> Saizan: i found it... it was mess left over from a compilation that screwed me
07:54:58 <dankna> right hmm
07:55:10 <dankna> well, actually, you said above that you can't test it against a string, but that may be the only way
07:55:11 <dankna> ugly :(
07:55:28 <ijk11> OK.  So I do ioeGetErrorType and turn that into a string somehow?
07:55:36 <dankna> (show $ ioeGetErrorType e) == "InappropriateType"
07:55:40 <dankna> the actual string may vary
07:55:41 <ijk11> ah!  Duh.
07:55:43 <ijk11> Thanks.
07:55:46 <dankna> sure
07:56:03 <Saizan> maybe the InappropriateType case wasn't in haskell98? only the others?
07:56:22 <dankna> it seems likely that Haskell98 the spec didn't say what the errors were, that the errors themselves are an implementation detail
07:56:41 <dankna> I mean, the doc you linked describes the conditions that cause them in terms of POSIX errno values, which I can't imagine the spec doing
07:57:00 <dankna> I don't think ANY of those errors have constructors exported by haskell98
07:57:26 <Saizan> it's still weird that there are predicates about the other cases and not this, it suggets that it's been added later
07:57:35 <dankna> that is true.
07:58:07 <dankna> probably as a bug-fix, as in "oops, our code doesn't have any way to report this situation"
07:58:08 <Saizan> maybe you should file a bug report :)
07:58:31 <dankna> not me :)
07:59:07 <ijk11> Heh, maybe.  I'm coming to Haskell from the Unix world, and if I filed a bug report for everything that didn't work "normally", I wouldn't have time to do anything else
08:00:47 <ijk11> Thanks again;  I'm off.
08:02:09 <EvanR-work> how do i know if a library uses thread local storage, can i safely use forkIO with it if i dont use -threaded ?
08:03:09 <dcoutts_> EvanR-work: if a C lib uses tls then you can only interact with it from bound threads, not ordinary forkIO'ed threads. See the haddock docs on bound threads.
08:03:39 <EvanR-work> does hdbc fall into this category?
08:03:49 * dcoutts_ has no idea
08:03:53 <EvanR-work> :(
08:04:05 <dcoutts_> EvanR-work: the docs should say if it's a problem
08:04:06 <EvanR-work> for each library it seems they should advertise this
08:04:14 <EvanR-work> or is it relatively uncommon ?
08:04:20 <dcoutts_> it's uncommon
08:05:05 <EvanR-work> ok
08:05:12 <EvanR-work> i dont see any warnings, so i guess its ok
08:06:40 <XniX23_> you actually program haskell at work EvanR-work ?
08:06:49 <EvanR-work> at the moment
08:07:30 <dcoutts_> EvanR-work: the only one I'm aware of is OpenGL, there's probably a few others
08:07:47 <EvanR-work> good to know
08:17:14 <maltem> Given an abstract data type from a library that is just a newtype of a Ptr, is there a (nice) way to foreign-import a C function that uses the associated C type?
08:18:18 <dcoutts_> maltem: that would break abstraction
08:19:29 <maltem> I deliberately like to break this particular abstraction
08:19:44 <dcoutts_> maltem: that choice is open to the library author, not the user
08:19:58 <maltem> yeah I sent a patch already ;)
08:20:01 <dcoutts_> maltem: iirc, there used to be a bug in ghc where that was allowed, I think now it's only allowed when the newtype data constructor is visible
08:21:10 <maltem> (Fwiw, this is interfacing to cairo_xlib_surface_create)
08:25:19 <maltem> dcoutts_, do you think though that C bindings should generally keep Ptr's hidden?
08:25:27 <dcoutts_> maltem: a better interface might be to bind cairo_xlib_surface_create in the cairo lib and have it as a raw X11 Ptr
08:25:32 <dcoutts_> maltem: yes.
08:25:49 <malcolmw> ivanm: the important thing is to avoid 'commit' in the first branch, even after the two prefixes cease to look the same.  Then backtracking should happen just right.
08:25:49 <lambdabot> malcolmw: You have 1 new message. '/msg lambdabot @messages' to read it.
08:26:39 <jmcarthur> by opinion is that C bindings should expose an "Internal" module for these things, which most users would not import
08:26:43 <dcoutts_> maltem: the other alternative is to have a constructor for arbitrary cairo backends
08:27:02 <maltem> dcoutts, you mean to "ignore" the X11 package? To be clear, it's the X11 types that are the "problem"
08:27:12 <dcoutts_> jmcarthur: right, and even that need not expose the newtype wrappers
08:28:04 <dcoutts_> maltem: you mean the X11 package does not provide any way to get the xlib * out right? So cairo cannot work with the X11 package types.
08:28:08 <maltem> not exposing the contents defeats the point of having an "Internal" module, no? :)
08:28:46 <dcoutts_> maltem: it can provide functions rather than exposing constructors, still allows the data types to be changed later.
08:29:28 <maltem> dcoutts_, exactly, namely, the Display and Window types. Strangely, the contructor *is* exposed for the Screen type. (Maybe I shuffled something here)
08:29:38 <jmcarthur> yeah there's a happy middle ground between high abstraction and no abstraction which the Internal modules can expose
08:30:31 <jmcarthur> it should expose C-level types and soem conversions without exposing the implementation of the binding itself
08:30:39 <jmcarthur> at least, that is my ideal
08:30:41 <dcoutts_> jmcarthur: right
08:31:14 <maltem> displayToPtr - ok, I fear that would quickly get obsolete if someone does change the underlying representation. But I do get your general point
08:32:27 <dcoutts_> maltem: the other thing you'd have to worry about is finalisers, memory management
08:32:41 <dcoutts_> extracting a raw ptr isn't going to be safe from a mm pov
08:32:59 <maltem> mmh indeed
08:33:33 <jmcarthur> presumably such functions would be prefixed "unsafe"
08:33:45 <dcoutts_> jmcarthur: but it's so unsafe as to be useless
08:34:01 <dcoutts_> it'd have to return you a ForeignPtr including the finaliser
08:34:09 <ketil> uselessPerformIO - I like it
08:34:10 <jmcarthur> ah, you're right
08:34:39 <jmcarthur> i did not catch your drift at first
08:35:45 <EvanR-work> .. whats the operator for integer division
08:35:52 <jmcarthur> div
08:35:54 <MadHatterDude> EvanR: div
08:35:57 <EvanR-work> ah
08:36:09 <yottis> often used like "a `div` b"
08:36:17 <EvanR-work> right, i saw that
08:36:35 <MadHatterDude> what about quot?
08:36:55 <maltem> I'll have to look around a little at some C bindings to see the usual tricks for safe Ptr passing
08:37:17 <MadHatterDude> @pl \(f, g) (a, b) -> (f a, g b)
08:37:17 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (,)) .))
08:37:37 <MadHatterDude> there should be an arrow combinator like that
08:37:55 <EvanR-work> can i recursively call a function that may throw an exception from its own catch action
08:38:29 <EvanR-work> would be nice if once im in the handler, its like normal IO
08:39:04 <harlekin> MadHatterDude, there's (f *** g) $ (a, b).
08:39:19 <EvanR-work> http://pastebin.com/qtk2zH0F
08:39:25 <jmcarthur> :t uncurry (***)
08:39:26 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => (a b c, a b' c') -> a (b, b') (c, c')
08:39:33 <jmcarthur> :)
08:39:36 <MadHatterDude> harlekin: Doh! I didnd see that
08:40:05 <jmcarthur> :t uncurry (***) `asTypeOf` (\(f, g) (a, b) -> (f a, g b))
08:40:06 <lambdabot> forall b c b' c'. (b -> c, b' -> c') -> (b, b') -> (c, c')
08:41:49 <MadHatterDude> The problem I have is that I want to use arrow combinators to manipulate carthesion points
08:42:04 <fax>  why would you use arrow for this??
08:42:04 <MadHatterDude> (f *** g) $ (a, b) won't cut it
08:42:24 <MadHatterDude> fax: I use the arrow combinator operators on regular funtions
08:42:35 <MadHatterDude> fax: And theyre useful
08:43:17 <jmcarthur> MadHatterDude: why won't (***) cut it?
08:43:22 <jmcarthur> what do you need?
08:44:03 <fax> Idon't agree that they are useful
08:44:08 <MadHatterDude> jmc: I need something that will allow me to extract the functions in (+) *** (+) $ (a, b) and apply them toanother tuple
08:44:39 <MadHatterDude> jmc: thus: \(f, g) (a, b) -> (f a, g b)
08:45:02 <MadHatterDude> jmc: or \(f, g) -> f *** g if you will
08:45:19 <MadHatterDude> @pl \(f, g) -> f *** g
08:45:19 <lambdabot> uncurry (***)
08:45:28 <MadHatterDude> dmanit.
08:45:57 <jmcarthur> @let (***$) = uncurry (***)
08:45:58 <lambdabot>  Defined.
08:46:21 <jmcarthur> :t \fs xs ys -> fs ***$ xs ***$ ys
08:46:22 <lambdabot> forall b b' b1 c b'1 c'. (b -> b1 -> c, b' -> b'1 -> c') -> (b, b') -> (b1, b'1) -> (c, c')
08:48:16 <jmcarthur> > ((+), (-)) ***$ (5, 6) ***$ (3, 3)
08:48:17 <lambdabot>   (8,3)
09:01:49 <MisterN> @hoogle <-
09:01:49 <lambdabot> Text.Html (<->) :: (HTMLTABLE ht1, HTMLTABLE ht2) => ht1 -> ht2 -> HtmlTable
09:01:49 <lambdabot> Text.XHtml.Table (<->) :: (HTMLTABLE ht1, HTMLTABLE ht2) => ht1 -> ht2 -> HtmlTable
09:07:28 <mibygl> Ahoy.
09:09:08 <jmcarthur> arr
09:09:08 <mibygl> I'm looking for a function that breaks a string at a given string, like so: "foo::=bar" becomes Just ("foo","bar"), "foo::=bar::=baz" becomes Just ("foo","bar::=baz"), and "blah" becomes Nothing.
09:09:08 * mibygl swordfights jmcarthur.
09:09:15 <ezyang> @hoogle String -> String -> Maybe (String, string)
09:09:16 <lambdabot> Did you mean: String -> String -> Maybe (String, String) /count=20
09:09:16 <lambdabot> No results found
09:09:23 <fax> :t splitAt
09:09:24 <lambdabot> forall a. Int -> [a] -> ([a], [a])
09:09:28 <fax> hm
09:09:30 <ezyang> @hoogle String -> String -> Maybe (String, String)
09:09:31 <lambdabot> Data.List genericSplitAt :: Integral i => i -> [b] -> ([b], [b])
09:09:34 <fax> :t findIndex
09:09:35 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe Int
09:09:42 <fax> no that wont do it
09:09:45 <ezyang> Well, I guess you could scan the string for an index
09:09:49 <MisterN> @src splitAt
09:09:50 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
09:09:54 <ezyang> @hoogle String -> String -> Int
09:09:55 <lambdabot> Foreign.C.Error throwErrnoPath :: String -> FilePath -> IO a
09:09:55 <lambdabot> Data.Time.Format readTime :: ParseTime t => TimeLocale -> String -> String -> t
09:09:55 <lambdabot> Foreign.C.Error throwErrnoPathIfMinus1 :: Num a => String -> FilePath -> IO a -> IO a
09:10:10 <ezyang> "ah, just throw a parsing library at it"
09:10:26 <jmcarthur> ?hackage split
09:10:26 <lambdabot> http://hackage.haskell.org/package/split
09:11:28 <benmachine> it can probably be fairly easily implemented in terms of break/span
09:11:30 <mibygl> In theory, scanning for an index and all would be slow.  In practice, I doubt I'm going to be parsing anything more than a couple of kilobytes.
09:11:39 <jmcarthur> surprisingly the split package doesn't appear to have that. it does have splitOn :: Eq a => [a] -> [a] -> [[a]]
09:11:55 <mibygl> I want to go to MIT just so I can have a hostname like BRAIN-AND-COG-SEVEN-FORTY-TWO.MIT.EDU.
09:12:16 <mibygl> > splitOn "::=" "foo::=bar::=baz"
09:12:17 <lambdabot>   Not in scope: `splitOn'
09:12:24 <mibygl> @index splitOn
09:12:24 <lambdabot> bzzt
09:12:29 <benmachine> > break (==':') "foo::=bar::=baz"
09:12:29 <jmcarthur> splitOn is in the split package
09:12:30 <lambdabot>   ("foo","::=bar::=baz")
09:12:30 <mibygl> Grr.
09:12:30 <fax> :t splitOn
09:12:31 <lambdabot> Not in scope: `splitOn'
09:12:42 <benmachine> > break (==':') "foo:notasplit::=bar::=baz"
09:12:43 <mibygl> @hoogle break
09:12:43 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
09:12:43 <lambdabot> Data.ByteString break :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
09:12:43 <lambdabot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
09:12:43 <lambdabot>   ("foo",":notasplit::=bar::=baz")
09:12:50 <fax> :t runParser
09:12:51 <jmcarthur> mibygl: http://hackage.haskell.org/packages/archive/split/0.1.2/doc/html/Data-List-Split.html#v%3AsplitOn
09:12:51 <lambdabot> Not in scope: `runParser'
09:12:52 <benmachine> ^ so you have to do some checking/recursion
09:13:31 <mibygl> Maybe I could implement it myself easily enough.
09:14:36 <mibygl> There's probably a linear-time function that takes "foo" and returns [("","foo"),("f","oo"),("fo","o"),("foo","")], assuming that whatever calls it only reads a constant amount of the result.
09:15:01 <jmcarthur> looks like a zipper :)
09:15:41 <jmcarthur> use a zipper with isPrefixOf and you should be good
09:15:47 <fax> linear time? hm
09:15:55 <mibygl> Right.
09:16:01 <fax> no I don't htink so
09:16:07 <fax> you would have to reverse O(n) lists
09:16:34 <mibygl> Beest not ridiculous.
09:16:39 <maltem> yeah even if you start with the zipper, you'll still have to reverse the reversed lists
09:16:41 <fax> ?
09:16:50 <mibygl> Why do you need to reverse anything?
09:17:01 <fax> mibygl, well if my way is ridiculous, and your way is linear time ... show me :P
09:17:05 <jmcarthur> mibygl: appending to the end takes O(n) time
09:17:15 <maltem> mibygl, that's what a zipper would do
09:17:21 <mibygl> Don't append to the end.  Use the ShowS trick.
09:17:27 <mibygl> Or whatever that's called.
09:17:36 <benmachine> dlists
09:17:37 <dcoutts_> mibygl: for it to be linear time it'd have to put the first component in reverse order
09:17:39 <fax> oh that's a good idea
09:18:08 <dcoutts_> dlists lose sharing
09:18:09 <jmcarthur> the dlist idea is pretty good actually
09:18:13 <jmcarthur> oh
09:18:22 <jmcarthur> nevermind then
09:19:01 <fax> > let to s = (id,string) ; from (f,s) = f s ; next (f,x:xs) = (f . (x:),xs) in take 4 . iterate  next . to $ "foo"
09:19:02 <lambdabot>   Not in scope: `string'
09:19:10 <fax> > let to s = (id,s) ; from (f,s) = f s ; next (f,x:xs) = (f . (x:),xs) in take 4 . iterate  next . to $ "foo"
09:19:11 <lambdabot>   [(""->
09:19:11 <lambdabot>    ""
09:19:12 <lambdabot>  "a"->
09:19:12 <lambdabot>    "a"
09:19:12 <lambdabot>  "aa"->
09:19:13 <lambdabot> [5 @more lines]
09:19:19 <fax> > let to s = (id,s) ; from (f,s) = f s ; next (f,x:xs) = (f . (x:),xs) in map from (take 4 . iterate  next . to $ "foo")
09:19:20 <lambdabot>   ["foo","foo","foo","foo"]
09:19:27 <mibygl> scanninate x = scanninate' id x []; scanninate' f (x:xs) r = scanninate' (f.(x:)) xs ((f [], (x:xs)) : r); scanninate' _ [] r = r
09:19:31 <fax> > let to s = (id,s) ; from (f,s) = (f "", s) ; next (f,x:xs) = (f . (x:),xs) in map from (take 4 . iterate  next . to $ "foo")
09:19:32 <lambdabot>   [("","foo"),("f","oo"),("fo","o"),("foo","")]
09:19:41 <dcoutts_> fax: problem is you pay linear time to evaluate each dlist
09:19:54 <fax> dcoutts_, so it is equivalent to the reverse way?
09:20:01 <dcoutts_> fax: no
09:20:01 <jmcarthur> mibygl: a function that takes "foo" and returns [("","foo"),("f","oo"),("of","o"),("oof","")] could be done in linear time
09:20:09 <fax> hm
09:20:23 <jmcarthur> the dlist way wouldn't be bad for this case though since only one dlist will be evaluated
09:20:28 <dcoutts_> fax: reverse way pays only O(1) per list because all the tails are shared
09:20:30 <jmcarthur> not all of them
09:20:36 <dcoutts_> jmcarthur: that's ok then
09:21:06 <mibygl> And, of course, where I put (f.(x:)), substitute ((x:).f).
09:21:23 <mibygl> Or maybe I'm being stupid.
09:21:39 <mibygl> Yeah, i am.
09:21:58 <mibygl> (As is my shift key. Darn laptop keyboards not all being identical.)
09:22:27 <jmcarthur> > liftA2 zip inits tails "foo"  -- bad, but concise
09:22:28 <lambdabot>   [("","foo"),("f","oo"),("fo","o"),("foo","")]
09:22:32 <mibygl> I guess evaluating this dlist, as you call it, sounds like it will require linear time itself.
09:23:48 <ClaudiusMaximus> > (\l -> tails l `zip` (reverse . tails . reverse $ l)) "foo?"
09:23:49 <lambdabot>   [("foo?",""),("oo?","f"),("o?","of"),("?","oof"),("","?oof")]
09:24:03 <jmcarthur> mibygl: each dlist that you convert to a list will take linear time, but in the end you only need to convert one dlist to a list, so that would be okay
09:24:14 <mibygl> Right.
09:24:37 <mibygl> It would be neat if there were a List class, and a Character class, so that frickin' everything could be polymorphic.
09:24:42 <Itkovian> sequence.complete.org: logging in gives an error
09:24:51 <Itkovian> Warning: Table './drupalsequence/sessions' is marked as crashed and should be repaired
09:24:59 <Itkovian> Any idea who fixes this?
09:25:01 <jmcarthur> ?hackage ListLike
09:25:01 <lambdabot> http://hackage.haskell.org/package/ListLike
09:25:35 <jmcarthur> in my opinion ListLike is fairly ugly. we really should have more general type classes
09:25:44 <jmcarthur> but it's there if you want it
09:26:20 * dcoutts_ agrees with jmcarthur that it's ugly
09:26:33 <fax> so im confused what does the difference list buy you
09:26:34 <fax> ?
09:26:57 <mibygl> al-maisan: must you be announcing your AFKness so much?
09:26:59 <dcoutts_> fax: it gives you cheap append, but only when used in a non-persistent way
09:27:01 <jmcarthur> fax: constant time append, at the cost of free undo
09:27:06 <fax> no
09:27:08 <fax> > let to s = (id,s) ; from (f,s) = (f "", s) ; next (f,x:xs) = (f . (x:),xs) in map from (take 4 . iterate  next . to $ "foo")
09:27:09 <lambdabot>   [("","foo"),("f","oo"),("fo","o"),("foo","")]
09:27:11 <fax> ^ this
09:27:16 <al-maisan> mibygl: sorry .. will stop doing that now.
09:27:18 <fax> compared to zipper + map reverse
09:27:34 <jmcarthur> nothing
09:27:41 <dcoutts_> right
09:27:44 <fax> so mibygl was wrong
09:27:55 <jmcarthur> not wrong, just not using existing abstractions
09:28:01 <fax> wrong to call my way ridiculous
09:28:08 <fax> and that there's a linear time way to do this
09:28:10 <jmcarthur> ah, i didn't see that
09:28:35 <mibygl> fax: does you way use reversing?
09:28:38 <dcoutts_> fax: you've got to be pretty careful about analysing time complexity when dealing with lazyness
09:28:51 <dcoutts_> fax: it depends crucially on how much you want to evaluate
09:29:00 <fax> dcoutts yeah I am really bad at it and it's
09:29:10 <mibygl> If not, it's not the way I was calling ridiculous.
09:29:19 <dcoutts_> fax: eg what is the time complexity of (:) ?
09:29:27 <jmcarthur> reversing is not ridiculous
09:29:27 <fax> O(1) ?
09:29:42 <dcoutts_> fax: but it takes linear time to evaluate a list right?
09:29:53 <fax> yes
09:30:04 <zygoloid> fax: given that the caller only looks at a constant amount of the result, i think your method is linear time isn't it?
09:31:04 <jmcarthur> both the zipper+reversing and the dlist algorithms are linear given the evaluation order that would be imposed on it from this particular use case
09:32:05 <dcoutts_> fax: there's a couple methods, they basically require accounting for delayed costs and assigning them to the right bits of the data structure
09:46:32 <FliPPeh> Why do I love haskell so much, even though it won't let me understand it? :(
09:47:14 <Saizan> stockholm syndrome.
09:47:22 <FliPPeh> I believe so.
09:47:43 <FliPPeh> Even the strongest are not immune to it.
09:48:04 <ijk1> Haskell is a lovely language.  It just gets a bit clunky having to put unsafePerformIO $ in front of every other function call.
09:48:16 <ezyang> ijkl: !
09:48:40 <ijk1> well, come on, that's what, 20 characters?
09:48:55 <FliPPeh> 20 of 80!
09:49:06 <c_wraith> yeah, you should totally compose those IO actions and put unsafePerformIO in front of the composed action!  :)
09:49:42 <shapr> Saizan: Gothenburg Syndrome
09:49:45 <shapr> Saizan: Chalmers?
09:49:54 <shapr> Glasgow Syndrome?
09:50:35 <maltem> ijk1, but that adds up with all those return's you need to make the unsafePerformIO's typecheck
09:51:34 <Saizan> heh, Glasgow is not so compiler agnostic :)
09:52:24 <c_wraith> isn't unsafeInterleaveIO approximately return . unsafePerformIO ?
09:52:25 <shapr> I like haskell://Atom (Is that how you refer to a Hackage package specifically?) but I wish it were closer to a DSL.
09:52:52 <fax> shapr:  hackage://...
09:53:28 <shapr> lhs://
09:53:49 <dcoutts_> c_wraith: I'd not explain it that way. unsafeInterleaveIO has something approaching a semantics. unsafePerformIO does not.
09:54:55 <c_wraith> well.  semantics that include "also, using the returned data structure might result in asynchronous errors at any point"
09:55:24 <dcoutts_> c_wraith: the semantics is like that of forkIO
09:55:43 <dcoutts_> the effects can happen at any time later, or perhaps not at all
09:55:55 <dcoutts_> it's non-deterministic
09:56:38 <maltem> Yeah, unsafeInterleaveIO is safe in the sense that we don't have a semantics for IO anyways
09:57:19 <Saizan> except that you can actually control the "scheduler" by evaluation, but you might say that's not something the user should rely on
09:57:39 <dcoutts_> maltem: there are sensible semantics for subsets of IO (eg just IORefs, stdin/out) in terms of traces of primitive events
09:57:39 <Saizan> s/evaluation/strictness/
09:57:53 <dcoutts_> non-determinism is expressed as sets of permissible traces
09:58:06 <dcoutts_> as in CSP etc
09:58:33 <dcoutts_> Saizan: right, and the semantics say nothing about that except that it's a permissible trace
09:59:52 <dcoutts_> the point is, interleaving is mainly useful when there is no interference and thus no effect of the non-determinism
10:01:50 <c_wraith> does anyone ever use unsafeInterleaveST?  I'm having trouble seeing cases where that's not a total nightmare that doesn't contribute anything.
10:02:34 <dcoutts_> c_wraith: I'm thinking of using it instead of unsafeInterleaveIO in the zlib binding
10:02:56 <maltem> code.haskell.org not being reachable makes me sad
10:03:29 <c_wraith> dcoutts_: what's the case where it works without performing IO?
10:04:42 <dcoutts_> c_wraith: zlib calls have side effects but only to a locally allocated resource, that's just what ST is for
10:05:40 <c_wraith> dcoutts_: So you'd be implementing a new ST primitive, something that's neither STRef nor one of the STArrays?
10:06:01 <dcoutts_> c_wraith: right the mutable variable is the z_stream state held on the C side.
10:06:21 <c_wraith> that makes sense then.  Cool
10:06:32 <dcoutts_> maltem: reload
10:07:01 <edwardk> hrmm this vector based graph library may work out after all
10:07:36 <dcoutts_> c_wraith: the point is to allow me to expose a safe low level interface. Exposing an IO interface would be safe but it's not very useful because it's impure. Exposing an ST interface lets users safely runST
10:07:55 <dons> any mac users of  the Haskell Platform?
10:08:07 <ezrakilty> yeah
10:08:08 <c_wraith> dcoutts_: right.  That works out nicely
10:08:16 <maltem> dcoutts_, yay!
10:08:17 <dons> i'm helping Simon Thompson get it installed, and we can't find the cabal, alex or happy binaries
10:08:32 <dons> all other binaries seem to be symlinked from /usr/bin
10:08:49 <dons> which is good. but not cabal. does anyone know where they install, or are they missing (?!)
10:08:54 * shapr has no clue
10:09:01 <FliPPeh> Anything wrong with saving config to a file using "show", and re-parsing it back in with "reads"?
10:09:04 <FliPPeh> This seems too easy.
10:09:07 <shapr> But I have a friend with a mac, I could get her to test Haskell Platform.
10:09:14 <shapr> FliPPeh: Pretty standard approach.
10:09:29 <dcoutts_> FliPPeh: only downside is the format is fragile
10:09:30 <dons> well, macs make up 30% of the downloads, so someone must know where cabal-install lives :)
10:09:45 <dons> but i'm slightly concerned there's a bug in the installer, that it didn't put sym links in
10:09:50 <FliPPeh> dcoutts_: If the user messes up, every format will fail :)
10:09:51 <edwardk> dcoutts_/c_wraith: so you're adding an ST monad chunk-based API to haskell's zlb?
10:10:12 <c_wraith> dcoutts_: I hadn't previously considered the possibilities when combining ST with the FFI.  There are a lot of things that could work really well for.
10:10:18 <edwardk> FliPPeh: well, if you release a new version, and tweak the contents of the config, Read will probably fail
10:10:22 <dcoutts_> edwardk: right
10:10:33 <edwardk> dcoutts_: awesome
10:10:57 <dcoutts_> edwardk: I hope it'll help the people who want to do iterator style stuff
10:11:03 <edwardk> dcoutts_: definitely
10:11:14 <dcoutts_> but without compromising on purity or clean design etc
10:11:15 <edwardk> easy to plug it into iteratee, etc
10:11:15 <FliPPeh> edwardk: Oh, that wouldn't be that much of a problem, I could just let the program back up the current file, and create a new one with valid syntax and fill in some default stuff
10:11:37 <dcoutts_> edwardk: maybe, I'm not sure how they'll cope with the ST s parameter, they might not thank me ;-)
10:12:16 <edwardk> FliPPeh: yeah. i'm actually doing the cheesy 'serialized config' for kata's packages because i can't be bothered to write a full cabal-like parser
10:12:34 <edwardk> FliPPeh: figuring i'll revisit it and serialize something smarter later
10:13:00 <edwardk> i'm sure dcoutts_ here managed to some how make the core cabal parsing code reusable, but i haven't puzzled through it ;)
10:13:08 <dcoutts_> c_wraith: I've not fully explored it myself. It has the potential to help with the pure FFI marshaling problem.
10:13:26 <dcoutts_> edwardk: it'd need to be split out and cleaned up
10:13:39 <edwardk> dcoutts_: well, for instance you can use attoparsec over it, feeding the chunks from ST s
10:14:11 <dcoutts_> edwardk: also the config stuff is deliberately somewhat tied to the command line parsing/showing
10:14:29 <edwardk> dcoutts_: figured as much. for right now i'll just use the Read instance for my package definition and retrofit something later
10:14:36 <dcoutts_> we have to handle sets of command line flags and store them in corresponding format config files
10:14:50 <edwardk> my macro system isn't tied to the syntax of kata itself, so i may recycle it to do config rewriting, etc.
10:15:08 <edwardk> dcoutts_: yeah i noticed that. that is a very cool trick =)
10:15:21 <edwardk> dcoutts_: i had to basically inline cmdargs into my app to duplicate that functionality
10:15:27 <dcoutts_> edwardk: it could be done more cleanly
10:15:44 * dcoutts_ is never satisfied
10:15:55 <edwardk> dcoutts_:  basically i've been modeling the main command line for my compiler on cabal, rather than on, say, ghc.
10:16:16 <dcoutts_> edwardk: command line args are monoids! :-)
10:16:35 <dcoutts_> a collection of monoids, which itself is a monoid point-wise
10:16:40 <edwardk> dcoutts_: Seq String?
10:17:19 <dcoutts_> data FooArgs = FooArgs { fooBlahs  :: [Blah], fooThing :: Bool, ... }
10:17:28 <dcoutts_> each field is a monoid of some sort
10:17:33 <dcoutts_> usually bool or list
10:17:39 <edwardk> or Last
10:17:46 <dcoutts_> yes
10:18:00 <dcoutts_> and the set of them is a monoid
10:18:27 <dcoutts_> which allows you to use mappend to combine defaults and flags from different sources, eg config files + command line
10:18:32 <edwardk> so you have a reducer that builds a monoid off of your ambient config, and run it for a global/user config and the cmd line?
10:18:39 <ezyang> Besides the fact that I'm not using an applicative functor when I should, how could I clean up this code? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24556#a24556
10:18:47 <edwardk> that is a fairly clean abstraction
10:19:33 <edwardk> and actually the collection of monoids can be treated as a right-near semiring, it has more structure if you want it to, not sure that is useful here
10:19:43 <dcoutts_> edwardk: from cabal-install's Main: let configFlags'   = savedConfigureFlags config `mappend` configFlags
10:20:01 <edwardk> dcoutts_: ok, sold.
10:20:02 <dcoutts_> edwardk: dunno, but I thought you'd at least appreciate this level of structure
10:20:31 <aavogt> ezyang: need more HOFs
10:20:38 <edwardk> i was previously just generating a  (Config -> Config) from the cmd line
10:20:48 <dcoutts_> edwardk: in particular it lets you handle partial sets of flags
10:21:01 <ezyang> aavogt: I'd believe that
10:21:15 <ezyang> the types are being pesky though
10:21:20 <edwardk> one thought is of course, that if you start allowing gcc like command line arguments, some of them toggle on or off seemingly unrelated flags
10:21:41 <edwardk> so the monoid model breaks down
10:22:54 <ezyang> aavogt: I can't write a general function for checkMatterList and checkSectionMatterList without introducing typeclasses, and I don't want to do that
10:22:56 <edwardk> but you can also use that same machinery to talk about the monoid of 'effects of command args up to a point' is pretty sexy for dealing with what args are ineffect as of the 5th cmd line arg.
10:23:09 <edwardk> even if you're forced to work over Endo Config
10:23:14 <ezyang> (mostly because I'm going to have to translate this to another language w/o typeclases)
10:24:02 <dankna> hmmmm.... data DFA input = DFA Bool (Map input (DFA input)) ...
10:24:16 <dankna> or should it use one type for the whole state machine and another for the nodes thereof?  hmm
10:24:59 <dankna> oh, it needs to be two types for parallelism with NFA, which needs a set for start states.  okay.
10:25:24 <aavogt> ezyang: as in, checkMatterList  can be written in terms of foldr
10:25:28 <edwardk> dankna: newtype Mealy a b = Mealy { runMealy :: a -> (Mealy a b, b) }
10:26:00 <edwardk> newtype Moore a b = Moore { runMoore :: (b, a -> Moore a b) }
10:26:01 <ezyang> aavogt: Oh, sure
10:26:06 <ezyang> I guess I should go do that
10:26:21 <dankna> edwardk: hmm
10:26:55 <edwardk> dankna: a mealy machine takes a value to transition on and gives you a new state, and the output for that state.
10:27:16 <edwardk> a moore machine has a known value for its current state 'b', and a function that can take an input and yield the new state
10:27:22 <dankna> so I see :)
10:27:24 <edwardk> they turn out to be adjoint, etc.
10:27:29 * dankna nods
10:28:17 <edwardk> dankna: i slapped together a pile of cute little list origami stuff a year or so back for copumpkin you might find fun in this context: http://comonad.com/haskell/Origami.hs
10:28:27 <dankna> looking.
10:28:36 <dankna> I will say that I don't want to represent states as closures
10:28:42 <dankna> because closures can't be compared for identity
10:28:48 <dankna> which is required when converting an NFA to a DFA
10:28:58 <dankna> hm
10:29:05 <edwardk> dankna: yeah, then defunctionalize the -> into some structure
10:29:17 <dankna> actually, I'm going to need to give them unique IDs so I can compare the IDs, aren't I.
10:29:28 <dankna> because there's no concept of pointer equality in Haskell, is there.
10:29:40 <edwardk> dankna: stablenames, but the short answer is 'don't do it' ;)
10:29:45 <aavogt> ezyang: well maybe it's not so much cleaner because you end up with     foldr (\x (r,n) ->                 let (r, n') = checkMatter i n m
10:29:46 <dankna> hahaha yeah
10:29:51 <dankna> so unique IDs it is then
10:29:52 <ezyang> aavogt: Yeah, I noticed that
10:30:05 <ezyang> also, the recursive version threads "i" through the code
10:30:14 <ezyang> so you need to tuplify that
10:30:16 <aavogt> well you get the picture.. you need a fst or snd after the fold completes
10:30:22 <ezyang> yup
10:30:32 <edwardk> you can of course defunctionalize the notion of a current state into an id for comparison, and a map of inputs to new states
10:30:44 <dankna> yes, absolutely
10:31:10 <aavogt> @type mapAccumL
10:31:11 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
10:31:19 <ezyang> neat!
10:31:23 <dankna> when you say defunctionalize you mean, er, take a function that returns stuff and make it just a member accessor instead? :)
10:31:29 <ezyang> though, one could argue I should actually be using Maybe. :o)
10:31:34 <ezyang> (and a foldM)
10:32:12 <dankna> your "origami" thing makes my head spin.  I see lots of instance declarations for classes I haven't understood yet :)
10:33:48 <dankna> by the way, do you have opinions on the design of lexer and parser generators?  now is the time to share them :)
10:34:28 <dankna> (Happy doesn't support shift actions, that's why.)
10:38:53 <tommd> @seen preflex
10:38:54 <lambdabot> Unknown command, try @list
10:38:56 <tommd> grrr
10:39:28 <maltem> dankna, if they don't do something clever that a combinator library cannot do, then it's nicer to use such
10:39:54 <dankna> maltem: combinator libraries use backtracking and are O(something).  shift-reduce parsers are O(something smaller).
10:40:10 <maltem> That counts as "something clever" I guess
10:40:14 <dankna> yeah
10:41:36 <dankna> I also can't conceive of trying to write a grammar with over a hundred nonterminals in a combinator library, personally
10:41:39 <dankna> maybe it's a style thing
10:41:48 <dankna> but I think it would come out far more verbose than it already is
10:41:59 <xerox> like something=n and smaller=log(n) you get O(n) versus O(n log(n))
10:42:13 <dankna> xerox: haha, not quite :D
10:42:17 <xerox> dang
10:53:00 <mreh> i can has Haskell SOAP library?
10:53:32 <MisterN> mreh: no soap for you
10:53:43 <mreh> :(
10:54:27 <FliPPeh> Soap is fine unless you drop it at the wrong place and the wrong time.
10:54:31 <monochrom> use soap-free sodium laureth sulphate instead.
10:54:47 <mreh> I'm talking about the Simple Object Access Protocol
10:54:51 <mreh> ...duh
10:54:57 <monochrom> I'm trolling
10:54:58 <lament> why do you want to access simple objects?
10:55:10 <mreh> Amazon Wed Services
10:55:13 <mreh> Web*
10:55:20 <monochrom> Heh wed services
10:55:29 <lament> i'd wed an amazon
10:55:31 <mreh> here comes the bride
10:55:39 <lament> Brindle
10:55:47 <mreh> excuse me?
10:56:12 <monochrom> "find someone on the internet to marry! free shipping..."
10:56:35 <lament> marriage has been outsourced to India
10:56:36 <mreh> like a pillow... lulz
10:56:52 <mreh> @wn Brindle
10:56:54 <lambdabot> *** "brindle" wn "WordNet (r) 2.0"
10:56:54 <lambdabot> brindle
10:56:54 <lambdabot>      adj : having a gray or brown streak or a pattern or a patchy
10:56:54 <lambdabot>            coloring; used especially of the patterned fur of cats
10:56:54 <lambdabot>            [syn: {brindled}, {brinded}, {tabby}]
10:57:05 <monochrom> I don't know SOAP.
10:58:10 <mreh> me neither, but I'm willing to learn it just to do my map reduce homework
10:58:27 <mreh> rather than use *gasp* Java
11:01:00 <maltem> Is SOAP more bearable than Java?
11:01:33 <monochrom> "shoap library: A very basic SOAP package"
11:01:52 <c_wraith> soap?  Soap is maybe slightly more bearable than CORBA.
11:01:54 <c_wraith> maybe
11:02:38 <dmhouse> SOAP is only bearable in the presence of a good library.
11:03:09 <edwardk> dmhouse: even then that is subject to interpretation ;)
11:03:21 <dmhouse> If possible, find a library that uses SOAP under the hood and presents you with a sane interface to your desired web service.
11:03:43 <edwardk> maltem: that is like asking of HTML is more bearable than Haskell. Soap is a messaging protocol, not a language.
11:04:33 <mreh> there is no amazon web services haskell library unfortunately
11:04:48 <glguy> Can you use Template Haskell to generate comments that Haddock could then read?? I was thinking it would be nice for the haddock documentation to have a live example that never got out of date!
11:04:52 * mreh wishes there was
11:05:18 <c_wraith> there's a haskell library for S3....
11:05:34 <c_wraith> Do you mean a different amazon service?
11:05:42 <dankna> glguy: that's a really cool idea, but no you can't
11:05:50 <c_wraith> (I've used the S3 lib.  It does what it claims, with a pretty straight-forward interface)
11:06:08 <dankna> glguy: Haddock does apply TH before running, but TH doesn't allow you to generate comments.
11:07:44 <maltem> edwardk, read it in the context of mreh's "I'm willing to learn it … rather than use … Java"
11:07:54 <edwardk> ah
11:08:16 <mreh> c_wraith: EC2
11:08:38 <edwardk> i do wish that haddock had access to the contents of the .hi so it could fill in the constructed TH instances
11:08:39 <mreh> what is S3? the simple storage thing-a-ma-bob
11:08:43 <c_wraith> yes
11:08:52 <edwardk> rather than just rely on the source
11:10:32 <mreh> people have used EC2 to do GHC builds and the like, no-one has done any actual cloud computing with it though
11:12:31 * c_wraith gets to work putting up a prototype on EC2
11:14:10 <ijk1> Oh hey, what *are* the kids using for multi-host parallel Haskell these days?  Everything I found when I looked hadn't been touched in years.
11:14:30 <c_wraith> sadly, it's not a prototype in haskell
11:16:56 <monochrom> Yes, multi-host parallel haskell hasn't been touched in years.
11:24:27 <waern> glguy: the way it works right now, you could, if someone added support for it to the TH library
11:25:23 <waern> glguy: but I'm working on changing the way Haddock gets the comments so that that wouldn't work anymore
11:25:55 <glguy> :-S
11:26:14 <waern> removing them from the GHC AST completely...
11:26:35 <waern> hmm, although that's not strictly necessary
11:26:58 <waern> so the placeholders in the AST could be kept just to be able to write docs with TH
11:27:24 <waern> hmm...
11:31:30 <dankna> waern: but comments aren't part of TH's ASTs at all, are they?
11:32:16 <waern> dankna: don't think so, no. But that's not very hard to change
11:32:21 <dankna> true enough
11:32:55 <dankna> well, I look forward to it
11:45:50 <danten> hello, I'm a student and thinking about working on scion as a gsoc project. Thought I could check what you think about it, so what I wanna do is add holes like in agda-mode for emacs. Basically a hole is just undefined but the editor can help you refine it. Not sure if it makes sense.
11:47:32 <fax>  /j #gsoc
11:49:03 <danten> Well I thought that I wanna check what the haskell community thinks about it :) if they (you) think it would be useful. When programming in agda it is totally awesome and something really missed when going back to haskell.
11:50:22 <EvanR-work> danten: holes?
11:50:40 <fax> danten what did you program in agda?
11:50:46 <ezyang> you plug in undefined in some code that you haven't written yet
11:50:59 <EvanR-work> i usually define everything, put perhaps with a sensible default, and i put a comment like -- NOT DONE
11:51:22 <danten> fax: I programmed it for a course at chalmers, also some things for fun
11:51:37 <edwardk> EvanR-work: agda works a bit differently, it is really designed for interactive use like that
11:51:37 <fax> what things
11:51:55 <edwardk> EvanR-work: you set up the hole and let agda infer from the context filling in the text in your buffer
11:51:57 <EvanR-work> so its like an IDE
11:52:30 <edwardk> EvanR-work: yeah their workflow is stylized with the use of an agda mode for emacs
11:52:33 <danten> hmm for the course we implemented semantics from tapl, so operational semantics and fun stuff
11:52:56 <fax> danten cool and the proof s?
11:53:27 <danten> yes it becomes a nice workflow where you say I am not done here, what is the type of everything in scope that would help me?
11:54:33 <danten> we showed that smallstep was equivalent to bigstep for some easy bool language. Later I played with a language that had an interpreter and a compiler to a stack-machine and proved that they would yield the same result
11:55:28 <danten> also one cool thing is case-split which will automagically do a patternmatch on the expression based on the type, very nice :p
11:55:32 <edwardk> danten: i wonder if the 'hole' stuff could be implemented using template haskell by dropping a little TH fragment placeholder that returns an object of type 'a ', and then running over all of them asking for their types, though then you need something like Data/Typeable for its type to figure out it is, and then something to fill in the hole with viable content (expand out the lambdas etc)
11:55:34 <fax> cool
11:55:56 <edwardk> s/out it is/out what it is/
11:56:55 <danten> I noticed there exists a project on github named ghc-goals or something similar. But scion has it as feature request and I think it makes sense to have them there
11:58:19 <danten> edwardk, do you think that would be a good gsoc project?
11:58:35 <edwardk> danten: it'd be awkward in many ways to figure out where to start
11:58:54 <edwardk> danten: i.e. do you start by trying to hook into GHC? in which case that blows way out of proportion difficulty wise
11:59:07 <edwardk> danten: if you start by using haskell-src-exts you then need to give it a type checker to even start
11:59:25 <danten> hmm
11:59:33 <edwardk> danten: so both strike me as too big
11:59:41 <danten> fair enough
11:59:51 <edwardk> but i may have missed some brilliant insight into how to pull it together on a weekend ;)
12:01:00 <danten> hehe, well I havn't really any big idea at the moment. But scion has the ability to get the type of identifiers, so I thought if you could just create dummy undefines and then ask what type does are of
12:01:17 <fax> just stick it in an SCC
12:01:33 <fax> :t let what = what ; foo = 1 + what in what
12:01:34 <lambdabot> forall t. t
12:01:37 <fax> :t let what = what foo ; foo = 1 + what in what
12:01:38 <lambdabot>     Occurs check: cannot construct the infinite type: t = t1 -> t
12:01:39 <lambdabot>     Probable cause: `what' is applied to too many arguments
12:01:39 <lambdabot>     In the expression: what foo
12:01:48 <fax> oops
12:01:54 <fax> :t let what = const what foo ; foo = 1 + what in what
12:01:55 <lambdabot> forall a. (Num a) => a
12:02:21 <fax> {what,foo} is an SCC in the last case, but not the first
12:02:50 <edwardk> danten: you can always stick the implicit param annotations in =)
12:03:04 <danten> :p
12:03:25 <mjrosenb> i have a function part :: [a] -> [[[a]]] which given a list will return every possible partition of the list.
12:03:28 <danten> what is SCC? am I just missing a simple acronym?
12:03:44 <fax> um yeah it's from type systems
12:03:47 <edwardk> danten: there may very well be a nice way to get it out of the ghc api, by placing an a undefined there and asking about it
12:03:54 <edwardk> "Static Cost Center" IIRC
12:04:01 <Jaak> strongly connected component?
12:04:02 <fax> strongly connected component
12:04:04 <danten> ahh right
12:04:04 <mjrosenb> i currently map every [a] in the result onto a new value
12:04:08 <edwardk> it is not a "strongly connected component" in this context
12:04:15 <fax> is not?
12:04:19 <fax> why not
12:04:20 <edwardk> SCC in GHC anywys
12:04:32 <edwardk> when you annotate methods with it, it is for profiling purposes
12:04:39 <edwardk> the choice of acronym is rather unfortunate ;)
12:04:40 <fax> oh, nothing I said is GCC specific
12:04:47 <mjrosenb> can anyone think of a way to re-write this to avoid recomputing every value a large number of times?
12:04:47 <fax> GHC*
12:05:04 <edwardk> fax: ah, i was inferring from the surrounding conversation
12:06:55 <zygoloid> if you have multiple TH splices in a file, how hard is it to get them to communicate with each other (share variables etc)?
12:08:00 <edwardk> zygoloid: very good question, i find myself needing that right now for some template haskell gettext stuff i'm doing.
12:08:23 <zygoloid> i suppose you could communicate via the filesystem, but that seems /icky/
12:08:38 <zygoloid> perhaps a compile-time unsafePerformIO'd newIORef? :)
12:08:41 <edwardk> yeah
12:08:45 <fax> lol
12:08:47 <edwardk> the trick is getting the same io ref
12:09:16 <zygoloid> i guess you'd stand a chance if it was imported from another module
12:09:47 <zygoloid> in fact i think it'd have to be due to the staging restrictions
12:09:50 <Apocalisp> @hoogle f (a b c) -> a (f b) (f c)
12:09:50 <lambdabot> Prelude unzip :: [(a, b)] -> ([a], [b])
12:09:51 <lambdabot> Data.List unzip :: [(a, b)] -> ([a], [b])
12:10:47 <benmachine> is that like a generalised functor?
12:10:58 <Apocalisp> like a generalized applicative, I think
12:11:01 <Apocalisp> @type ap
12:11:02 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
12:11:04 <edwardk> right now i'm hacking on a typesafe TH printf that goes out and loads up translations from gettext po files and checks to make sure the format from there is compatible as well before merging the localized strings into the executable
12:11:05 <Apocalisp> umm
12:11:11 <Apocalisp> @type (<*>)
12:11:12 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
12:11:19 <edwardk> so it would be beneficial for me to only load the po files once
12:12:33 <Apocalisp> @hoogle a (f (a b c)) (a (f b) (f c))
12:12:33 <lambdabot> No results found
12:12:35 <Apocalisp> haha
12:13:19 <edwardk> zygoloid: the model being that you can just say gettext("Foo %s") <*> "Hello" -- and the usual translation tools apply
12:13:36 <edwardk> zygoloid: (though the need for parens there is somewhat unfortunate
12:14:17 <zygoloid> edwardk: you using CPP then? *shudder*
12:14:30 <edwardk> zygoloid: nope. the parens are so xgettext can find them
12:14:49 <edwardk> zygoloid: er sorry $(gettext("Foo %s")) <*> "Hello"
12:15:24 <edwardk> though i suppose there a #define _(s) = $(gettext s) -- would be less obtrusive
12:15:30 <edwardk> one of the rare cases
12:15:48 <zygoloid> yeah, would be slightly less visually noisy
12:16:33 <zygoloid> it's almost a pity the overloaded string literals extension can't kick in at compile time. almost. :)
12:16:41 <edwardk> the goal there is that xgettext can extract and build a .pot, you can use the usual tools to build the .po files, possibly as a custom build hook for cabal, and TH can bake them into the executable.
12:16:55 <zygoloid> seems pretty nifty to me :D
12:16:56 <edwardk> zygoloid: i still need the wrapper for gettext to find it
12:17:57 <edwardk> zygoloid: what i have right now works, but it builds a map of the msgids and looks it up at runtime, and so it can't give me a compile time error if the formats don't line up
12:18:07 <zygoloid> edwardk: well, if you can get a TH splice to happen you can write gettext("Foo %s") to a file when it's spliced ;-o
12:18:11 <edwardk> i'd like that a bad translation would be a compile time error rather than a runtime mess
12:18:27 <edwardk> zygoloid: you lose the surrounding comments for translators
12:18:28 <zygoloid> would be horribly multipass though
12:19:03 <edwardk> xgettext scrapes out any preceding comments and adds it for me to the output as a translation hint
12:21:41 <edwardk> zygoloid: i could also curry it so i could say something like gettext("Foo %s") locale arg arg arg as a pure function
12:21:52 <edwardk> rather than work in a reader for the choice of locale
12:22:34 <edwardk> hrmm
12:22:39 <edwardk> i guess those are the same thing
12:22:57 <edwardk> just be polymorphic in MonadReader Locale m =>
12:23:36 <edwardk> or bake a class Monad m => MonadLocale m where askLocale :: m Locale
12:23:49 <edwardk> with an instance for (Locale ->)
12:25:02 <edwardk> there is also another encoding i could use
12:26:49 <edwardk> i could use TH in a big 'module Locale where' -- which reads each of the po files and generates a Locale as a huge record with one method per input string.
12:27:17 <edwardk> and $(gettext string) becomes a simple translation of the string to the appropriate member selector from the Locale
12:27:34 <edwardk> so that would get me all of the po files read exactly once
12:27:51 <benmachine> why not use the member selectors directly?
12:28:01 <benmachine> oh I guess that wouldn't be easier
12:28:11 <siracusa> Is there a TH-based printf implementation that checks the argument types at compile-time?
12:28:12 <edwardk> benmachine: i need to emit them for gettext to find
12:28:19 <edwardk> siracusa: yeah, igloo wrote one in TH
12:28:30 <edwardk> siracusa: that is what i'm bastardizing to build this ;)
12:28:41 <siracusa> edwardk: Where can I find it?
12:29:00 <edwardk> http://hackage.haskell.org/package/Printf-TH
12:29:25 <edwardk> $(printf "Hello %s\n") "World"
12:29:38 <siracusa> Thanks
12:29:47 <aavogt> ooh, TH for translations
12:29:49 <edwardk> there are other variadic printfs, but they are of lesser safety
12:29:53 <edwardk> aavogt: yeah =)
12:30:06 <siracusa> I'm wondering why i didn't find it at hackage myself
12:30:15 <mdmkolbe> What is the name for the lattice over a set of objects, S, where forall s in S. (bottom < s and s < top), but otherwise all elements in S are incomparable? (Wrong channel but you guys are smart and I don't know a better place to ask.)
12:30:33 <edwardk> aavogt: i have one locale working right now, en@lolcat -- now i just need to do real translations once i have a stable enough set of diagnostic messages ;)
12:30:59 <edwardk> mdmkolbe: that is a sum of a node, the antichain of the elements and another node
12:32:22 <dankna> en@lolcat, hahaha
12:32:30 <edwardk> mdmkolbe: i've used the term discrete lattice for it before but i think that is a misnomer
12:32:39 <edwardk> dankna: a lolcale ;)
12:32:43 <dankna> haha, so it is
12:33:07 <edwardk> i thought about en@pirate but then figured my compiler was already being silly enough wasting memory on lolcat error messages
12:33:48 <dankna> this is true.
12:34:07 <edwardk> avast, ye have an error, current file newer than dependency '%s'
12:34:17 <mdmkolbe> edwardk: yes, that would be an accurate description of the lattice I'm after
12:34:29 <mightybyte> Anyone know why I get GhcException "unable to load package" when I try to interpret some code with Hint?
12:35:10 <Lemmih> mightybyte: Can you load the package in ghci?
12:36:47 <mightybyte> Lemmih: Yeah
12:37:47 <mightybyte> Lemmih: Oh wait, maybe not.
12:38:17 <mightybyte> Importing one of the package's exposed modules in ghci fails.
12:39:33 <mightybyte> But loading the module with :load works.
12:41:40 <Saizan> mightybyte: move out of the source tree for that package :)
12:42:30 <mightybyte> I just did, and it still doesn't work.
12:44:02 <Saizan> :load stopped to work too, i presume?
12:44:33 <mightybyte> Ahh, yes.
12:44:46 <mightybyte> module 'XYZ' is a package module
12:44:56 <Saizan> check that ghc-pkg sees the package as installed and that ghc-pkg check doesn't find it broken
12:44:58 <mightybyte> I thought I had exported it in my .cabal file
12:45:41 <mightybyte> Yep, ghc-pkg sees it and ghc-pkg check doesn't display anything.
12:46:20 <mightybyte> The module in question is in my exposed-modules section under Library
12:49:09 <asic> hi
12:49:26 <Saizan> and yet import or :m + in ghci won't work? i'd check that you're not mixing ghc installations and that the .hi files are there in the directory ghc-pkg thinks they should be
12:49:43 <mightybyte> :m works, but :load doesn't.
12:50:20 <Saizan> oh
12:50:33 <Saizan> but that should be fine with hint then, no?
12:50:53 <Saizan> :load is only when you want to interpret from source code
12:51:39 <Saizan> oh, sorry, that was the point.
12:51:45 <mightybyte> Nope.  I get the same "unable to load package" message.
12:52:17 <Saizan> would it be fine with setImports ["Foo"] rather than loadModules ["Foo"] ?
12:52:25 <Saizan> so that it'll use the installed module?
12:53:45 <mightybyte> I'm using setImports already.
12:54:40 <Raynes> lambdabot has some sort of privilege system, doesn't it?
12:54:54 <Saizan> there are some admins
12:55:33 <mightybyte> When I remove Foo from the setImports argument, the error changes to WontCompile and a bunch of "Not in scope" messages.
12:55:37 <Raynes> I was wondering how it makes sure the admins are really the admins. One could change their name in the absence of a certain admin and take control, could they not?
12:55:48 <Raynes> Or does it somehow check to see if they are identified?
12:56:07 <EvanR-work> hmmmmm. threadId <- (myThreadId >>= return . show); is there a better way :(
12:56:40 <Saizan> why show?
12:56:46 <dankna> Raynes: I assume it checks the +r attribute
12:56:59 <EvanR-work> right. threadId is already showable, so why do i need a string? because printf wont print my thread id :(
12:57:03 <dankna> which exists for that purpose
12:57:10 <EvanR-work> printf "%s" (show threadId)
12:57:24 <Saizan> i think you need some other thing than %s
12:57:32 <EvanR-work> yes
12:57:39 * hackagebot hmatrix-glpk 0.2.0 - Linear Programming based on GLPK  http://hackage.haskell.org/package/hmatrix-glpk-0.2.0 (AlbertoRuiz)
12:57:43 <Saizan> btw, foo >>= return . f = fmap f foo
12:57:56 <EvanR-work> ah ok
12:58:09 <EvanR-work> Saizan: well, Text.Printf doc doesnt have very many format codes...
12:58:35 <Saizan> = f <$> foo = liftM f (for Monads at least)
12:58:43 <mightybyte> Saizan: The package mentioned in the error message exports module Foo.  The code being interpreted by hint is in the module Bar.  First I do 'loadModules ["Bar"]', and then 'setImports ["Foo", "Bar", "Prelude"].
12:58:47 <Saizan> liftM f foo, of course
13:00:00 <Saizan> mightybyte: and it dies with the second, while you can :m + Foo in ghci and use one of the exported symbols fine?
13:00:33 <mightybyte> Yes
13:00:45 <EvanR-work> Saizan: well despite that, threadId <- fmap show myThreadId; is a lot nicer ;)
13:01:11 <EvanR-work> i should probably figure out htf that works tonight ;)
13:01:55 <Saizan> mightybyte: i don't know then :\
13:01:58 <mightybyte> :(
13:03:24 <pastorn> should i use (IORef State) or State = S { x :: IORef, y :: IORef, ...} ?
13:03:41 <pastorn> is one faster than the other?
13:03:46 <EvanR-work> look, OOP!
13:03:49 <EvanR-work> ;)
13:03:56 <pastorn> EvanR-work: wut?
13:03:59 <Saizan> nothing much to do with OOP
13:04:09 <Saizan> however they are pretty different semantically
13:04:33 <mightybyte> Saizan: Oh, right before that it gives me an error: "unknown symbol '__stginit_...'
13:04:34 <EvanR-work> an object with mutable members ;)
13:04:38 <dschoepe> pastorn: I'd guess that in most cases the first one is a lot more comfortable to use
13:04:53 <pastorn> dschoepe: yeah, that's probably true
13:05:00 <Saizan> mightybyte: oooh, something with the linker then
13:05:04 <pastorn> the second one might be faster...
13:05:15 <pastorn> ...or?
13:05:25 <pastorn> (someone should comment on this)
13:05:47 <pastorn> and.... ...silence... :(
13:05:59 <Saizan> i don't think any one is particularly faster in general
13:06:08 <pastorn> ok
13:06:26 <Saizan> either might be in some use cases and in particular wrt interactions with GC
13:06:54 <pastorn> how does the GC work with IORefs?
13:07:12 <pastorn> does it correctly collect overwritten values?
13:07:50 <Saizan> yes, but they might get collected later than you'd expect if they ended up in an old generation
13:08:06 <Saizan> (talking about GHC)
13:08:55 <pastorn> can you tag stuff to be collected?
13:09:03 <pastorn> or du you have literally no control?
13:09:28 <Saizan> you can call performGC but i don't think there's much more
13:09:35 <pastorn> oh?
13:09:38 <pastorn> that seems nice
13:09:47 <EvanR-work> you want to manually manage memory too? :)
13:09:50 <pastorn> @hoogle performGC
13:09:50 <lambdabot> System.Mem performGC :: IO ()
13:09:59 <pastorn> EvanR-work: when working with games you might
13:10:27 <pastorn> EvanR-work: for examle you might want to wait for low load opportunities until you collect
13:10:29 <mightybyte> Saizan: This is weird.  It seems to build properly, and I get a message "Installing library in ..." and "Registering foo-0.1"
13:10:49 <Tarrasch> > fmap (+) (pure 2) <*> (pure 5)
13:10:50 <lambdabot>   No instance for (GHC.Show.Show (f a))
13:10:50 <lambdabot>    arising from a use of `M1499485092...
13:11:15 <EvanR-work> pastorn: yeah, but ideally the gc does not take much work at one time. generational tries to solve that
13:11:17 <Tarrasch> When i write that in GHCi i simply get '7'. (quotes for clarity)
13:11:32 <Tarrasch> Why don't I get [7] or (Just 7) or something like that?
13:11:44 <Saizan> mightybyte: that's not a sign that the ghci linker will be able to link it back correctly :)
13:12:06 <pastorn> EvanR-work: how does it work? does i locate calls to performGC by code analysis or something?
13:12:12 <Saizan> Tarrasch: it defaults to the IO monad, and prints the result
13:12:16 <pastorn> (locate = place calls in your code)
13:12:43 <EvanR-work> it just collects new stuff often, old stuff seldom
13:12:44 <mightybyte> Saizan: But doesn't the success of :m indicate that it is linking it correctly?
13:12:53 <pastorn> huh?
13:13:07 <Tarrasch> Saizan, ahh.... And there is an instance show for (IO a) if there is for (a). Right?
13:13:08 <Saizan> mightybyte: no, that only means it read the .hi file
13:13:09 <pastorn> are stuff marked with "persistincy" tags or something?
13:13:18 <Polarina> Does anyone know of a library that can parse BIND9 files?
13:13:19 <EvanR-work> lots of times you allocate and immediately lose it, so generational concentrates effort on those
13:13:42 <Tarrasch> ok maybe not isntance show but ghci still can execute and show it*
13:13:46 <pastorn> EvanR-work: oh, like when you do function composition
13:13:56 <Saizan> Tarrasch: no, it's more complicated, ghci will basically try to run"(fmap (+) (pure 2) <*> (pure 5)) >>= print" if it typechecks
13:14:00 <EvanR-work> other hand, allocating a single big table that never gets lost, it will be in an old generation and not often checked
13:14:17 <Saizan> Tarrasch: yeah, the second :)
13:14:20 <Veinor> what Saizan said
13:14:29 <Tarrasch> aha
13:14:32 <mightybyte> Saizan: Then I did ":t Foo" and it gave me the correct type signature.  Does that indicate it got any further?
13:15:06 <Saizan> mightybyte: no, try with ":set -package $pkg-$ver"
13:15:09 <pastorn> Polarina: do you have a spec somewhere?
13:15:32 <Polarina> pastorn, spec?
13:15:42 <Polarina> pastorn, it's a text file.
13:15:44 <pastorn> oh, you want a library, not want to write one
13:16:07 <mightybyte> Saizan: That gives me "unknown package"
13:16:21 <Tarrasch> btw. have anyone of you ever find a use for the function 'map map'?
13:16:26 <fax> no
13:16:36 <pastorn> Tarrasch: but map (map f)
13:16:37 <Saizan> mightybyte: substituting the correct package name for $pkg and its version for $ver ?
13:16:43 <mightybyte> Yeah
13:16:44 <pastorn> @type map map
13:16:45 <lambdabot> forall a b. [a -> b] -> [[a] -> [b]]
13:17:10 <EvanR-work> array of functions to a array of functions on arrays ;)
13:17:12 <benmachine> :t fmap fmap
13:17:13 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
13:17:14 <pastorn> Tarrasch: i seldomly have a list of functions :)
13:17:23 <Saizan> mightybyte: and "ghc-pkg describe $pkg-$ver" ?
13:17:24 <benmachine> EvanR-work: list!
13:17:29 <benmachine> not array :P
13:17:31 <EvanR-work> right
13:17:31 <pastorn> benmachine: that looks sort of applicative :)
13:17:38 <EvanR-work> i keep saying array
13:17:43 <Saizan> mightybyte: if this works i think you're using ghc-pkg from one installation and ghci from another
13:18:03 <benmachine> pastorn: a little bit yes
13:18:14 <benmachine> pastorn: no idea what the result type is useful for though
13:18:20 <Tarrasch> Well it was a task to write down the type of map map in the Haskell School Of Expression. ^^
13:19:00 <mightybyte> Saizan: ghc-pkg describe shows it.
13:20:22 <EvanR-work> map map just blew my mind
13:21:05 <Tarrasch> EvanR-work, so does map foldl (in my case)
13:21:12 <EvanR-work> heh
13:21:26 <Saizan> mightybyte: no clear idea of what's going on, since :t worked..
13:21:28 <mightybyte> Saizan: Hmmm, I'm getting some warnings like this: "could not find link destinations for: Database.HaskellDB.Database.Database".  You think that's part of the problem?
13:21:44 <mightybyte> Saizan: I was thinking that was a haddock message, but maybe it's from the linker?
13:21:49 <benmachine> Database.Database.Database.Database?
13:21:55 <Saizan> that's an haddock message.
13:22:30 <Saizan> mightybyte: can you try with --disable-documentation, in the case it's interfering somehow?
13:23:13 <mightybyte> Ok, and I'll unregister the package and build clean just to be safe.
13:26:21 <FliPPeh> Anyone ever tried writing a CPU emulator in Haskell?
13:26:28 <FliPPeh> Like a z80
13:26:33 <FliPPeh> Or Intel 8080?
13:26:35 <pastorn> FliPPeh: there's a GB emulator
13:26:41 <pastorn> @where omegagb
13:26:41 <lambdabot> http://www.mutantlemon.com/omegagb/
13:26:43 <mightybyte> Saizan: Yep, those were haddock messages.  Still same problem.  ghci and hint give me the same linker error.
13:26:45 <FliPPeh> I've been playing with this idea
13:26:54 <FliPPeh> And still trying to decide between Haskell and C.
13:26:54 <pastorn> FliPPeh: that's as much Z80 as you'll ever get
13:26:57 <EvanR-work> why do some libraries throw exceptions that are not caught by catch and catchJust. HDBC makes you use catchSql ?
13:27:00 <pastorn> FliPPeh: haskell :D
13:27:11 <pastorn> FliPPeh: tere's also a NES emulator written in haskell :)
13:27:25 <FliPPeh> Hmm
13:27:27 <Saizan> mightybyte: you might need to ask the ghc folks :)
13:27:42 <pastorn> FliPPeh: but it might not be public code... it was a bachelors project last year at chalmers
13:28:12 <FliPPeh> I wouldn't be able to learn from it anyways :(
13:28:12 <mightybyte> Saizan: Ok, thanks for the help.
13:28:12 <mjrosenb> hey, anyone know want to help me reduce redundant computations?
13:28:30 <pastorn> FliPPeh: nah, but there's a report that was written
13:28:40 <EvanR-work> how is it possible to have redundant computations in haskell ;)
13:29:15 <mjrosenb> EvanR-work: let x = 2+2; y = 2+2 in putStrLn show x ++ " " ++ show y
13:29:43 <Saizan> FliPPeh: SamB_XP wrote a z80 emulator iirc
13:29:46 <EvanR-work> but 2+2 and 2+2 will be the same thing
13:29:56 <EvanR-work> so a sane implementation will only make one 2+2
13:30:00 <FliPPeh> Hmm
13:30:06 <benmachine> EvanR-work: not true
13:30:10 <Saizan> EvanR-work: in this case they get computed only once
13:30:27 <pastorn> FliPPeh: design your own assembly language and write your own little assembler + interpreter
13:30:30 <benmachine> it's not in general obvious when it's safe to do that
13:30:40 <EvanR-work> why not?
13:30:40 <Saizan> if you had (2+2,2+2) it'll get computed twice
13:30:45 <Saizan> (talking about GHC)
13:30:58 <mjrosenb> in my case, these computations are explicitly doing IO
13:30:59 <FliPPeh> pastorn: I have no idea how that would work in haskell.. it's all about moving bits around and stuff :/
13:31:02 <Saizan> EvanR-work: because common subexpression elimination is not always an optimization
13:31:12 <benmachine> EvanR-work: because holding on to the results of functions in case that function is called again can use memory
13:31:21 <benmachine> potentially quite a lot if you do it wrong
13:31:24 <pastorn> FliPPeh: design your own simple machine
13:31:41 <pastorn> let it have an 8 bit accumulator + 2*16bit registrys
13:31:44 <EvanR-work> wouldnt it be reducing memory so you dont have the same expressions lying around everyhwere
13:31:54 <pastorn> FliPPeh: and 64k ram
13:32:03 <benmachine> EvanR-work: [1 ..] uses up less memory unevaluated than evaluated, though
13:32:13 <Saizan> mjrosenb: there's a paper by oleg on explicit sharing, but that might be overkill, do you have more details about your problem to share?:)
13:32:27 <pastorn> then design a simple assembly language for this machine... cover ADD, SUB, AND, OR, XOR, JMP, BRANCH, RTS
13:32:30 <EvanR-work> thats true, but dont you need just one [1..], and stuff uses pieces of it
13:32:30 <pastorn> or something
13:32:38 <pastorn> FliPPeh: or maybe skip branching
13:32:46 <FliPPeh> :/
13:32:51 <pastorn> (if you don't want to make a stack thingy)
13:32:53 <mjrosenb> right, so i have a function parts :: [a] -> [[[a]]]; it takes a list "L" , and returns a list of every partition of L.
13:32:57 <Saizan> EvanR-work: the point is that keeping that expanded around is more costly than recomputing it
13:33:10 <pastorn> then define some opcodes, write an assembler and run stuff in it
13:33:26 <mjrosenb> i then map another function that does lots of slow IO over every [a] in the result of this
13:33:31 <EvanR-work> Saizan: so it gets collected when not used
13:34:11 <EvanR-work> if the N things that have that expression are evaluated
13:34:16 <benmachine> EvanR-work: the way I see it, every time it's obvious that the optimisation is safe (and many times when it isn't) it's easy to do yourself anyway
13:34:21 <mjrosenb> so if the original list is "abc", then the partitions are ["abc"], ["ab","c"], ["a","bc"], ["a","b","c"]
13:34:45 <mjrosenb> and i would then do io for "a", "b", and "c" twice
13:35:21 <Saizan> oh
13:35:31 <jmcarthur> pastorn: wait, where's the nes emulator?
13:35:39 <jmcarthur> or rather, what's the nes emulator
13:35:40 <Saizan> i'd just change parts so that it doesn't produce the duplicates, or i'd filter them out
13:35:42 <jmcarthur> i didn't know about it
13:35:52 <pastorn> jmcarthur: not available
13:35:56 <jmcarthur> aw :(
13:35:57 <pastorn> they never released it
13:36:01 <pastorn> it wasn't that good
13:36:08 <FliPPeh> pastorn: Do you think such an emulator could be built as a monad?
13:36:11 <pastorn> because they went about doing the graphics all wrong
13:36:24 <jmcarthur> FliPPeh: it seems strange to call a program a monad
13:36:30 <FliPPeh> Part of it
13:36:31 <mjrosenb> Saizan: right, but i need to aggregate the results for both ["ab","c"] and ["a","b","c"]
13:36:34 <FliPPeh> The emulating part
13:36:36 <jmcarthur> sure... many parts of it
13:36:41 <pastorn> jmcarthur: they *PERFECTLY* emulated the PPU instead of just having their own state keeping track of  what's going on in the PPU
13:36:58 <mjrosenb> i could pre-emptively do the IO for the n^2 sublists, but I am not sure how to go from the n^2 sublists to the 2^n partitions
13:37:09 <jmcarthur> FliPPeh: sure, a monad could be used to track the the vm state
13:37:09 <EvanR-work> pastorn: like, they have a geometric model with potential difference maps and EM physics simulation? :)
13:37:12 <pastorn> jmcarthur: implementing an emulator for all the PPU instructions and what not, then synced this with the 6502 emulator
13:37:33 <pastorn> FliPPeh: most definetly!
13:37:41 <Tarrasch> have they made a NES emulator in haskell?
13:37:56 <Saizan> mjrosenb: ah, then you want to do some memoization, probably with a Map String SingleResult
13:38:03 <mjrosenb> Saizan: esentially, i have foo :: [a] -> IO (b,[a]); mapM (mapM foo) (parts l)
13:38:03 <pastorn> FliPPeh: you don't happend to go ta princeton?
13:38:11 <FliPPeh> pastorn: Nope
13:39:01 <pastorn> they have some TOY language defined
13:39:05 <pastorn> but just make your own
13:39:19 <FliPPeh> If I only knew where to start
13:39:33 <pastorn> FliPPeh: have you ever programmed any assembler?
13:39:52 <FliPPeh> pastorn: I tried x86 once, but it didn't play nice with x86_64 here :/
13:39:54 <Saizan> mjrosenb: you can use StateT to keep the Map around
13:39:54 <Tarrasch> What's all this low-level "language" discussion I hear? :p
13:40:03 <FliPPeh> But I have a good idea about it
13:40:14 <pastorn> FliPPeh: you should start with maybe write yourself a gameboy or nes rom
13:40:32 <pastorn> that's a good start to get an idea of what you can an can't do
13:40:36 <EvanR-work> a haskell rom
13:40:48 <EvanR-work> ;)
13:40:53 <pastorn> FliPPeh: http://www.devrs.com/gb/docs.php
13:41:25 <EvanR-work> whats memory management like on the gameboy
13:41:30 <ivanm> malcolmw: you still around?
13:41:56 <pastorn> EvanR-work: hehe
13:42:02 <EvanR-work> non existent?
13:42:05 <pastorn> YOU FANNI GAI
13:42:05 <EvanR-work> lol
13:42:35 <mjrosenb> EvanR-work: well on the original NES, the cartriges could fake virtual ROM if they wanted to :-p
13:42:37 <pastorn> FliPPeh: here you have (what seems like) a well commented demo: http://www.devrs.com/gb/files/apocnow.zip
13:43:11 <FliPPeh> Are there any good SDKs for Linux? at least something I can test inside?
13:43:22 <mjrosenb> Saizan: are there any docs on this SingleResult?
13:43:26 <pastorn> FliPPeh: you only need a Z80 assembler and an emulator
13:43:39 <FliPPeh> kay
13:43:52 <mjrosenb> Saizan: also, i was thinking of something more along the lines of just pre-computing everything so i don't have to deal with memoizing
13:44:01 <pastorn> FliPPeh: on ubuntu i can install the package "z80asm"
13:45:35 <Saizan> mjrosenb: SingleResult was just meant to be the type of the result you get from processing a single string
13:46:13 <ivanm> @tell malcolmw except I'm not using commit; just oneOf and onFail...
13:46:13 <lambdabot> Consider it noted.
13:46:14 <pastorn> FliPPeh: here you go! http://duo.gbadev.org/asmschool.html
13:46:17 <dankna> naming question.  what would you call the type-class of things which can be fed into a lexer, with provided instances Char and Word8?
13:46:36 <Saizan> mjrosenb: well, isn't precomputing going to build some lookup table? i'm not sure how that's much different
13:46:46 <FliPPeh> pastorn: Thanks :)
13:47:19 <Saizan> dankna: "wrong"
13:47:32 <pastorn> FliPPeh: go through that tutorial and write some simple demos, then you'll have the hang of what it's about, then you're gonna know how to design your virtual machine in haskell :)
13:47:39 <dankna> Saizan: wrong?  really?
13:47:45 <Saizan> dankna: are you sure you don't want to parametrize on the stream type rather than the contents?
13:47:55 <dankna> I'm parametrizing on that too
13:47:57 <mjrosenb> Saizan: different from your solution or from what i have currently?
13:47:59 <dankna> rather
13:48:03 <dankna> I'm parametrizing on
13:48:09 <Saizan> mjrosenb: my solution
13:48:18 <dankna> a) the contents (there are pure-code parts of this that have nothing to do with the stream)
13:48:26 <dankna> b) the means of obtaining the contents (not the stream type precisely)
13:48:41 <mjrosenb> Saizan: because i've never used Map before :-p
13:48:47 <dankna> I could get more concrete about that but it would be easier not to until I've written it, haha
13:49:06 <Saizan> i aww
13:49:09 <Saizan> *see
13:49:24 <mjrosenb> also, why does the "standard libraries" link on h.o no longer go to the ghc boot library page?
13:49:31 <jmcarthur> dankna: class Foo what what what where what?
13:49:33 <Saizan> mh, if it were a parser you could say Token
13:49:38 <Saizan> for a lexer i'm not sure
13:49:47 <dankna> jmcarthur: I don't believe I understand the question, if that was a question :)
13:50:03 <dankna> yeah, exactly my thought, Saizan
13:50:11 <dankna> maybe I need to make up a word
13:50:14 <dankna> "Lexen"
13:50:15 <jmcarthur> dankna: fill in the whats and treat Foo as this type class you don't have a name for yet
13:50:26 <Saizan> mjrosenb: how are you going to store the precomputed results then?:)
13:50:29 <jmcarthur> dankna: it was a question in that i'm trying to understand what you are making :)
13:50:42 <dankna> jmcarthur: oh.
13:51:04 <Saizan> ah, yeah, tell us the methods and their types :)
13:51:08 <dankna> okay, one sec
13:51:49 <benmachine> isn't lexeme that?
13:52:04 <dankna> no, a lexeme is the same thing as a token
13:52:24 <dankna> or rather, a lexeme is output from a lexer and a token is input to a parser, which is /usually/ the same thing
13:52:25 <Saizan> maybe Character :)
13:52:36 <dankna> thought of that, but it would be misleading in the case of binary input
13:52:53 <mjrosenb> Saizan: this is a functional language, a list of course!
13:53:34 <jmcarthur> lists aren't necessarily the best data structure to use just because the language is functional ;)
13:53:54 <dankna> class (Ord content, Bounded content, Num num) => Foo content num | content -> num where { toNum :: content -> num }
13:54:05 <dankna> I believe that's the only method, plus it needs to have Ord and Bounded of course
13:54:09 <Saizan> mjrosenb: an association list? the API of Data.Map is quite similar :)
13:54:14 <fax> 'we don't use that kind of low level language here'
13:54:17 <fax> oops
13:54:21 <fax> mispaste
13:54:48 <jmcarthur> so it converts the content to a number? that's it?
13:55:02 <dankna> correct
13:55:25 <dankna> the implementation would be ord for Char and id for Word8
13:55:42 <benmachine> can't you just use fromEnum?
13:55:44 <jmcarthur> this doesn't seem to be very lexer specific
13:56:12 <dankna> well, maybe it's not very lexer specific.  let me take a moment to see if fromEnum does what I need.
13:56:30 <dankna> yes, I can just use fromEnum.  problem solved, haha.
13:56:31 <jmcarthur> > map fromEnum ['a'..'z']
13:56:32 <lambdabot>   [97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,1...
13:56:36 <jmcarthur> ;)
13:56:46 <dankna> good call, Ben :)
13:56:58 <mjrosenb> Saizan: yeah,
13:57:00 <jmcarthur> @instances Enum
13:57:00 <lambdabot> (), Bool, Char, Double, Float, Int, Integer, Ordering
13:57:22 <jmcarthur> meh, should be more. just not imported in lambdabot apparently
13:57:23 * dankna didn't know about the instances command, heh
13:57:37 <jmcarthur> @instances-importing Data.Word Enum
13:57:38 <lambdabot> (), Bool, Char, Double, Float, Int, Integer, Ordering, Word, Word16, Word32, Word64, Word8
13:57:43 <mjrosenb> Saizan: is there any way of coercing ST into IO, since everything is already in IO and i would preffer to not have to deal with a transformer.
13:57:46 <benmachine> dankna: :info in ghci is better
13:57:46 <dankna> excellent
13:57:50 <jmcarthur> mjrosenb: stToIO
13:57:56 <jmcarthur> :t stToIO
13:57:57 <lambdabot> Not in scope: `stToIO'
13:58:02 <jmcarthur> @hoogle stToIO
13:58:02 <lambdabot> Control.Monad.ST stToIO :: ST RealWorld a -> IO a
13:58:02 <lambdabot> Control.Monad.ST.Lazy stToIO :: ST RealWorld a -> IO a
13:58:02 <lambdabot> Control.Monad.ST unsafeSTToIO :: ST s a -> IO a
13:58:05 <Saizan> mjrosenb: i said StateT not ST
13:58:26 <mjrosenb> Saizan: i can read, i swear.
13:58:52 <Saizan> mjrosenb: however you can avoid StateT and just pass the Map around since you'd have to do this only in very little code i think
13:59:33 <mjrosenb> Saizan: i can pass thread it through mapM?
13:59:51 <mjrosenb> *pass/thread
14:00:43 <cocon> @pl (\i -> fmap (fromInteger i *))
14:00:44 <lambdabot> fmap . (*) . fromInteger
14:01:01 <cocon> how can i send a private message to the lambdabot?
14:01:13 <jmcarthur> cocon: /msg lambdabot <stuff>
14:01:13 <fax> /msg lambdabot
14:03:49 <Saizan> mjrosenb: oh, right, mapM is problematic for that, you'd have to use some sort of fold
14:05:21 <mjrosenb> actually
14:05:27 <mjrosenb> hrmm,
14:05:39 <mjrosenb> i can probably use map and filterM
14:05:41 <mjrosenb> err
14:05:45 <mjrosenb> not filterM
14:06:10 <mjrosenb> i only need the head of the output of a filter
14:07:07 <glguy> That'd be more of a "findM"
14:07:40 <mjrosenb> yeah.
14:07:44 <Saizan> i'd probably let xs = parts input; in do table <- fmap Map.fromList . mapM foo . nub . concat . parts; <pair each element of xs with the appropriate results from table>
14:10:14 <mjrosenb> Saizan: that looks like it'll work. Thanks!
14:12:11 <Saizan> where nub can be made O(n log n) rather than O(n^2) with an implementation that uses Ord
14:12:17 <Saizan> if you need that
14:13:05 <Saizan> and s/mapM foo/mapM (\x -> do v <- foo x; return (x,v))/
14:13:52 <mauke> :t liftM2 liftM (,) ?foo
14:13:53 <lambdabot> forall a1 (m :: * -> *) a. (Monad m, ?foo::a -> m a1) => a -> m (a, a1)
14:14:32 <fax> hmmmmmm
14:15:45 <dibblego> does ? denote a forall variable?
14:16:14 <mauke> what do you mean by "forall variable"?
14:16:30 <glguy> ? denotes an implicit parameter
14:16:37 <dibblego> @type \foo -> liftM2 liftM (,) foo
14:16:38 <mauke> ? tells the typechecker to make shit up
14:16:38 <lambdabot> forall a1 (m :: * -> *) a. (Monad m) => (a -> m a1) -> a -> m (a, a1)
14:16:45 <dibblego> ok
14:16:54 <glguy> implicit parameters are dynamically scoped variables
14:17:01 <mauke> oleg disagrees
14:19:17 <ivanm> @tell malcolmw what's failing to parse is that I have something like: "bracket (satisfy (== '"')) (satisfy (== '"')) $ sepBy1 parseValue (satisfy (== '|'))"; it parses a single value, but when it gets to parsing the separator it fails, and then fails to parse the closing "; however rather than failing and returning to the next parser in the oneOf list, it just dies when you try to evaluate what it "parsed" (complaining that it couldn't find the closing ")
14:19:17 <lambdabot> Consider it noted.
14:19:53 <jmcarthur> man i love regions
14:20:58 <benmachine> implicit parameters are largely a source of confusion
14:21:48 <dibblego> why? I use them in Scala all the time
14:22:11 <benmachine> scala is scala I don't know about scala
14:22:18 <benmachine> but I think in haskell they're just weird
14:23:19 <zygoloid> implicit parameters are a pretty natural extension to typeclasses imo
14:23:45 * jmcarthur doesn't understand implicit parameters
14:23:57 <mauke> I'm gonna teleport my parameters through the type system, so there
14:24:00 <zygoloid> (if we had the ability to have multiple instances of a typeclass for the same type, i think implicit parameters is roughly how they'd look)
14:24:11 * glguy would prefer that functions like getLine and print would interact with ?stdin and ?stdout
14:24:22 <jmcarthur> is it the same as agda's implicit parameters?
14:24:26 <mauke> that way lies perl
14:24:47 <glguy> no, agda's implicit parameters are parameters that you can infer from the surrounding context
14:25:25 * jmcarthur looks up haskell's implcit parameters to see if he can remember what they are
14:26:12 <pastorn> what are you talking about?
14:26:12 <glguy> > let example :: (?x :: Int) => Int ; example = ?x + 1 in (let ?x = 10 in example)
14:26:13 <lambdabot>   11
14:26:33 <pastorn> is implicit parameters the same as "locking" variables in partial evaluation?
14:27:01 <pastorn> so in 'map (f x y) xs', are x and y implicit parameters?
14:27:07 <benmachine> no
14:27:08 <glguy> no
14:27:14 <benmachine> implicit parameters are introduced with ?s
14:27:17 <pastorn> ok... :/
14:27:22 <glguy> In the example I just pasted, ?x is the implicit parameter
14:27:28 <pastorn> wut?
14:27:37 <zygoloid> implicit parameters are really simple. they convert 'f :: a -> b' into 'f :: (?x :: a) => b'
14:27:50 <jmcarthur> okay i just read documentation on it. looks nicer now than it did the first time i read about them
14:27:51 <benmachine> I don't quite get why that is better though
14:27:58 <zygoloid> and 'let ?x = foo in f' performs the opposite conversion
14:28:05 <glguy> they aren't "better", they are different
14:28:21 <glguy> think "reader monad"
14:28:28 <jmcarthur> they move parameter passing from the expression to the type
14:28:29 <zygoloid> they give you function arguments which are implicit and named
14:28:39 <benmachine> yeah I don't often use Reader either :P
14:29:13 <pastorn> hang on here
14:29:20 <benmachine> I like one way of doing things
14:29:34 <jmcarthur> benmachine: sorry, haskell offers many ways of doing things ;P
14:29:43 <pastorn> could i get back my x from f in 'map (f x) xs'?
14:29:55 <benmachine> pastorn: only if f agreed to it
14:30:04 <Zao> Not unless the results of the map includes an extractable x.
14:30:07 <pastorn> is that what implicit parameters are?
14:30:10 <benmachine> no
14:30:23 <pastorn> aww... linky to docs plz
14:30:28 <pastorn> jmcarthur: ^^
14:30:32 <jmcarthur> google
14:30:48 <jmcarthur> i read the hugs documentation in this case
14:30:55 <jmcarthur> since it was the first result
14:31:42 <pastorn> so you bind variable names in the type signature?
14:31:43 <pastorn> cool
14:49:37 <micah> haha 666 members
14:49:41 <rpglover64> Could someone help me resolve an issue attempting to cabal install lambdabot on a debian system that uses the apt as much as possible?
14:49:45 <FliPPeh> Now that was random
14:50:34 <pastorn> FliPPeh: you getting anywhere with that gameboy stuff
14:51:29 <rpglover64> I'm getting a failure because the "unix" package is installed by debian.
14:52:48 <FliPPeh> pastorn: I'm looking at it, except for different opcodes there's nothing new yet :)
14:52:50 <dankna> rpglover: sorry, can't help - I use Haskell on Debian but I built my own :/
14:53:06 <rpglover64> dankna: Thanks anyway.
14:53:08 <FliPPeh> I only need some setup to do actual coding
14:53:14 <pastorn> FliPPeh: try to get one of the examples compiled :)
14:53:17 <FliPPeh> Lesson 7 seems to cover it
14:53:28 <FliPPeh> But it seems rather windows-oriented
14:53:53 <pastorn> FliPPeh: well, there's a z80 assembler for *nix
14:54:03 <pastorn> i found it in apt, as i said :)
14:55:45 <FliPPeh> Not for me appearently :/
14:55:49 <FliPPeh> Only for 32 bit
14:56:03 <micah> my parser is still outputting crappy errors
14:56:37 <micah> http://gist.github.com/350967
14:56:43 <pastorn> FliPPeh: awww
14:56:45 <pastorn> FliPPeh: wine?
14:57:08 <pastorn> FliPPeh: but if you look into NES programming, then you can compile stuff :)
14:57:11 <FliPPeh> But that's windows stuff!
14:57:13 <pastorn> i know i did
14:58:27 <micah> my parser is outputting `unexpected [((line 1, column 1),!)]` instead of `unexpected !`
14:59:07 <pastorn> FliPPeh: i used this when i were doing NES programming tutorials: http://www.cc65.org/
14:59:45 <pastorn> FliPPeh: it comes complete with a c compiler, an assembler and a linker
14:59:54 <FliPPeh> hmmm!
15:00:23 <pastorn> FliPPeh: resouce bonanza! http://nesdev.parodius.com/
15:02:11 <pastorn> FliPPeh: you've got a pm :)
15:15:23 <micah> can anyone help me with my parsec bug?
15:15:38 <micah> http://gist.github.com/350967
15:15:51 <micah> my parser is outputting `unexpected [((line 1, column 1),!)]` instead of `unexpected !`
15:19:39 <EvanR-work> well
15:19:44 <siracusa> parsec bug?
15:19:46 <EvanR-work> program just segfaulted :(
15:19:52 <EvanR-work> how do i diagnose that
15:20:26 <micah> it was working earlier, actually
15:20:36 <micah> I changed some things that I thought were unrelated
15:20:37 <fax> EvanR: did ou use any unsafeCoerce or unsafePerformIO?
15:20:41 <micah> and now it doesn't work
15:20:46 <fax> EvanR: or CFFI?
15:20:51 <EvanR-work> fax: unsafePerformIO
15:21:03 <fax> then I would guess it's that first of all
15:21:11 <EvanR-work> :S
15:21:14 <fax> why did you use it?
15:21:25 <EvanR-work> foo = unsafePerformIO newEmptyMVar
15:21:29 <fax> why
15:21:38 <EvanR-work> to fix a sync problem in several threads
15:21:41 <fax> this is not the correct way to use mvars
15:21:48 <EvanR-work> im getting that
15:21:51 <EvanR-work> now what
15:21:53 <fax> oh okay
15:22:08 <fax> I just assumed you didn't know that since it's what you did
15:22:18 <XniX23> anyone here knows the magic square thing?
15:22:19 <EvanR-work> i really didnt know
15:22:28 <EvanR-work> i dont know the conditions on unsafePerformIO
15:23:00 <pickles> XniX23: you talking about that matrix where the cols and rows add up to the same thing?
15:23:12 <XniX23> pickles yes
15:23:44 <fax> 5
15:23:47 <XniX23> pickles and every number should appear only once in a matrix
15:23:51 <pickles> right
15:23:58 <fax> EvanR : never use it
15:24:02 <pickles> i know MATLAB has a function to do that
15:24:11 <EvanR-work> alright
15:24:12 <XniX23> oh do you have matlab?
15:24:15 <pickles> you might check on the mathworks site and try to port it
15:24:22 <pickles> not currently installed
15:24:34 <pickles> if you're on linux you might try the open source version: octave
15:24:41 <pickles> i dont know if it has that function or not though
15:24:42 * dankna misparsed that as "(pickles and every number) should appear only once in a matrix"
15:24:48 * dankna was confused
15:24:58 <pickles> rofl
15:25:03 <dankna> grin
15:25:08 <XniX23> i have octave, ill try this ^^
15:25:23 <XniX23> lool
15:25:32 <pickles> itll probably be the same fn name as the matlab version
15:25:48 <pickles> i think it's just like: magic(3) for a 3x3 or something
15:26:18 <fax> 5
15:26:20 <fax> ugh
15:27:43 <XniX23> pickles yes, it works but i get a matrix.. i want to get how many different magic squares a for n where matrix is n*n
15:27:53 <XniX23> are*
15:28:36 <lament> isn't there a formula for that
15:28:56 <XniX23> lament i dont know of any ^^
15:29:24 <fax> um
15:29:27 <fax> how many finite groups are there
15:29:32 <xerox> 3
15:30:00 <dmhouse> ... times infinity.
15:30:04 <pickles> maybe the mathworks page has something on it
15:30:13 <pickles> bbl, goin for a walk in BEAUTIFUL weather!
15:30:42 <fax> there is some relation of magic square and groups
15:30:46 <fax> ise't there
15:31:10 <jmcarthur> EvanR-work: the conditions on unsafePerformIO are don't use it unless you're writing a FFI binding or implementing a fancy new language feature ;)
15:31:21 <EvanR-work> ok
15:31:25 <jmcarthur> and even then, don't use it without consulting your deity of choice
15:33:33 <XniX23> fax i have no idea, 2nd year students have to write a program to get that ^^ i just thought it was an interesting problem
15:34:51 <jmcarthur> EvanR-work: anyway, for your particular need i'd say you should probably create the MVar in your main thread and pass it to your other threads as a parameter
15:34:57 <fax> it is
15:34:59 <monochrom> micah: It depends on what "show t" does.
15:35:09 <micah> oh I should post that too
15:35:24 <Mathnerd314> fax: I know "Latin Squares" are group tables
15:35:37 <EvanR-work> jmcarthur: thats what were going to do...
15:35:48 <micah> http://gist.github.com/350967
15:36:26 <fax> in what sense
15:36:28 <jmcarthur> EvanR-work: with unsafePerformIO?
15:37:01 <fax> Unsolved problems in mathematics
15:37:04 <fax> How many n×n magic squares for n>5?
15:37:08 <fax> according to wikipedia
15:37:27 <fax> @oies 1, 0, 1, 880, 275305224
15:37:27 <lambdabot>  Number of different magic squares of order n that can be formed from the num...
15:37:28 <lambdabot>  [1,0,1,880,275305224]
15:37:49 <jmcarthur> EvanR-work: i meant actually create it *in* your main thread. like:  main = do mvar <- newEmptyMVar; forkIO (threadA mvar); forkIO (threadB mvar)   and so on
15:37:49 <XniX23> whoa
15:37:54 <XniX23> thanks a lot fax
15:38:09 <jmcarthur> although for organizational purpose maybe not right there in you main function, but i think you get the point
15:38:33 <jmcarthur> basically, just don't try to make a global
15:41:19 <Sadache> hello everyone
15:41:33 <mjrosenb> Sadache: helol
15:41:40 <mjrosenb> s/ol/lo
15:42:00 <Sadache> I am looking for a function, or rather an infix operator that has the type (a -> b -> a)->(a -> b -> a) -> ( a -> b -> a)
15:42:31 <Sadache> I doubt it is a Reader b and a (a->a) inside
15:42:32 <c_wraith> how are the two operands supposed to interact?
15:42:42 <mjrosenb> Sadache: hoogle is your friend
15:42:54 <fax> (a -> b -> a)->(a -> b -> a) -> ( a -> b -> a)?
15:42:57 <fax> what would it do
15:42:59 <Sadache> mjrosenb: tried, nothing is there
15:43:01 <mjrosenb> Sadache: and you can make anything infix with ``
15:43:07 <Twey> Lies
15:43:26 <c_wraith> I mean...
15:43:27 <Sadache> fax: composes them
15:43:32 <Twey> > (+ 1) `id . id` 5
15:43:33 <c_wraith> const has that type signature. :)
15:43:33 <fax> how?
15:43:34 <lambdabot>   <no location info>: parse error on input `.'
15:43:46 <fax> oh so it uses the b twice
15:43:46 <Sadache> somehow to form a monoid with the function type?
15:43:58 <fax> ?djinn x :: (a -> b -> a)->(a -> b -> a) -> ( a -> b -> a)
15:43:58 <lambdabot> Cannot parse command
15:43:59 <mjrosenb> Twey: i wish that worked
15:44:05 <Sadache> it is the same b passed to everyone
15:44:09 <fax> ?djinn x :: (a -> b -> a) -> (a -> b -> a) -> (a -> b -> a)
15:44:10 <lambdabot> Cannot parse command
15:44:17 <fax> wdy can't it parse
15:44:18 <mjrosenb> fax: don't have teh x ::?
15:44:20 <fax> ?djinn  (a -> b -> a) -> (a -> b -> a) -> (a -> b -> a)
15:44:20 <lambdabot> f a _ b c = a b c
15:44:31 <fax> ?djinn  (a -> b -> a') -> ('a -> b -> a) -> (a -> b -> a)
15:44:31 <lambdabot> Cannot parse command
15:44:34 <Twey> mjrosenb: Aye
15:44:39 <fax> ?djinn  (a -> b -> x) -> (x -> b -> a) -> (a -> b -> a)
15:44:39 <lambdabot> f a b c d = b (a c d) d
15:44:41 <micah> > let hooray = id . id in (+ 1) `hooray` 5
15:44:42 <lambdabot>   6
15:45:02 <micah> hooray
15:45:25 <dmhouse> > foldr (flip (:)) [] "yarooh"
15:45:26 <lambdabot>   Occurs check: cannot construct the infinite type: b = [b]
15:45:37 <dmhouse> > reverse "yarooh" -- bah.
15:45:38 <lambdabot>   "hooray"
15:46:08 <xerox> > foldl (flip (:)) [] "hooray"
15:46:09 <lambdabot>   "yarooh"
15:46:15 <Sadache> fax: so it is somehow flipping both functions, lifting the (.) and then using it to compose them
15:46:17 <dmhouse> xerox: heh, I was about to say that
15:46:21 <xerox> :D
15:46:24 <monochrom> micah: I can't reproduce it. I got "unexpected y" fine in: main = parseTest (match (NameTok "x")) [(p, DelimTok 'y')] where p = initialPos "blah"
15:46:40 <Sadache> I know how to implement it, just want to know if there is something already in a standard library
15:47:11 <fax> Sadache is it?
15:47:17 <micah> heh I tried using match $ NumberTok 3 and now it worked
15:47:37 <micah> so apparently it's in something to do with my parseractions
15:47:49 <Sadache> fax: yes, isn't it?
15:48:25 <fax> not afaict
15:48:32 <Sadache> fax: some context, a -> a is a function for modifying a
15:48:47 <jmcarthur> @@ @pl @djinn (a -> b -> a) -> (a -> b -> a) -> (a -> b -> a)
15:48:47 <lambdabot>  f = const
15:48:52 <jmcarthur> ha
15:48:59 <Sadache> fax: but b is necessary sometimes
15:49:22 <EvanR> jmcarthur: yes, thats how we set up the program at first, the threads all were passed the chans they needed to do their jobs, do something and write results to another thread
15:49:29 <Sadache> flip (a->b->a) gives b->a->a
15:49:37 <fax> ok
15:50:17 <jmcarthur> @@ @pl @djinn (a -> b -> c) -> (c -> b -> a) -> (a -> b -> a)
15:50:17 <lambdabot>  f = flip flip id . ((flip . (ap .)) .) . flip ((.) . (.))
15:50:53 <jmcarthur> EvanR: why the change? just convenience?
15:51:02 <EvanR> jmcarthur: let me explain the current problem... i tried to carefully design the thing before writing it. two threads read the database, one writes, one does smtp. the i/o of this is pretty straight forward
15:51:13 <EvanR> it could be simpler
15:51:18 <EvanR> but i was told it needed to use the database
15:51:41 <EvanR> one thread, in order to send a mail, connects to the database does something and disconnects
15:51:54 <Sadache> (.) takes a->b and b->c, if i lift it,  it'd take c->a ->b and c->b->d right?
15:52:11 <EvanR> after it was all written, i was told that it was unacceptable and that it needed to 'keep the connection open, and also reconnect if the connection goes down
15:52:14 <EvanR> '
15:52:16 <jmcarthur> :t liftA2 (.)
15:52:17 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Applicative f1) => f1 (a -> b) -> f1 (f a) -> f1 (f b)
15:52:38 <micah> hmm this is strange
15:52:46 <jmcarthur> EvanR: ah, so you hacked in a global mvar for the connection handle?
15:52:48 <micah> it doesn't have the weirdness most of the time
15:52:52 <micah> when parsing most thigns
15:52:55 <sinelaw> hey
15:53:01 <jmcarthur> ho
15:53:12 <EvanR> jmcarthur: that was the first one. it was unsafePerformIO (connectToDb >>= newIORef) ;)
15:53:21 <jmcarthur> ah
15:53:29 <EvanR> then came to thread sync problems
15:53:31 <EvanR> the*
15:53:37 <jmcarthur> EvanR: yeah, you should do that in the main thread, not in a global
15:53:44 <jmcarthur> and then pass it to the other threads
15:53:53 <EvanR> if the database went down, then when it came back up the mailer chan would be backlogged and would start spamming everyone
15:53:57 <micah> maybe it's because I'm using eof
15:54:04 <EvanR> so we hacked in a sync mvar
15:54:09 <EvanR> then it segfaulted
15:54:16 <jmcarthur> yeah that's a bad thing to do
15:54:21 <micah> because it happens whenever I parse someting wiht an error and then >> eof
15:54:24 <jmcarthur> just create it in the main thread
15:54:32 <EvanR> the sync mvar can be done like that
15:54:49 <jmcarthur> can be, but that doesn't mean should be
15:54:59 <EvanR> jmcarthur: i mean passing
15:55:01 <jmcarthur> you can simply avoid many problems by just not using unsafePerformIO
15:55:03 <jmcarthur> ah
15:55:05 <jmcarthur> yeah
15:55:10 <jmcarthur> that's the "should be" one :)
15:55:11 <EvanR> but the reconnect thing
15:55:26 <dcoutts_> EvanR: globals are not a good design, it should always be possible to have a constructor in IO
15:55:32 <EvanR> the exception handler needs to reconnect (eventually) and return that new connection for the rest of the functions
15:55:34 <dcoutts_> EvanR: reconnect is orthogonal
15:55:43 <EvanR> how is reconnect orthogonal?
15:55:44 <Sadache> :t     \ a b-> (flip a)   `liftA2 (.)` (flip b)
15:55:45 <lambdabot> parse error on input `('
15:56:01 <micah> monochrom: I think it might come from using eof
15:56:01 <jmcarthur> EvanR: right, so you have an MVar for the connection and if a thread sees that it's disconnected it makes a new connection and puts that back into the MVar instead of the old one
15:56:08 <dcoutts_> EvanR: you can make your connection type internally contain an MVar with the real db connection object.
15:56:28 <EvanR> ok
15:56:43 <EvanR> so i shouldnt try to make a State ;)
15:56:43 <jmcarthur> that is you pass an MVar around, not the connection itself
15:56:49 <dcoutts_> EvanR: the external API should still be something like: newConnection :: Blah -> IO DBCon
15:56:58 <jmcarthur> EvanR: a Reader if anything
15:57:04 <dcoutts_> and no unsafe perform IO in sight
15:57:31 <dcoutts_> in any case, there's no such thing as a global variable :-)
15:57:43 * hackagebot funcmp 1.5 - Functional MetaPost  http://hackage.haskell.org/package/funcmp-1.5 (PeterSimons)
15:58:08 <jmcarthur> dcoutts_: isn't the unsafePerformIO hack a global variable?
15:58:19 <jmcarthur> unsafePerformIO $ newIORef foo
15:58:24 <EvanR> yes, global mutable variables are bad
15:58:37 <jmcarthur> it's hack and bad and ugly and stupid, but i'm pretty sure it qualifies as a global
15:58:44 <jmcarthur> oh, and you have to have NOINLINE on it
15:58:51 <dcoutts_> jmcarthur: apart from the fact that that is evil, it's not really global, it has a scope
15:58:59 <dcoutts_> there is always a scope
15:59:01 <jmcarthur> oh scope
15:59:06 <mjrosenb>  /me wants global variables that can be set at startup via config files or commandline arguments
15:59:11 <dcoutts_> is perhaps a better way of putting it than "no such thing as global"
15:59:28 <EvanR> lets elaborate on this db connection mvar thing
15:59:44 <mjrosenb> i would not mind them being in the IO monad, as long as the config file only gets read once
15:59:46 <EvanR> how to hide the using of the connection, exception, reconnect, transparently
16:00:24 <mjrosenb> but since they are static once they have been set, saying that they are in IO feels kindof silly.
16:00:26 <EvanR> withConnection conWrapper $ do \conn -> ...
16:00:27 <EvanR> ?
16:00:31 <dcoutts_> jmcarthur: in the IORef example it's a package-version/linker scope. I can get several in one process by linking in independent copies.
16:00:48 <monochrom> micah: Then it can't be helped, unless you switch to tokenPrim so that your token type is Token rather than (SourcePos,Token).
16:00:53 <jmcarthur> dcoutts_: i see. i was not thinking about module boundaries
16:01:20 <dcoutts_> EvanR: and your withConnection does the checking etc?
16:01:29 <monochrom> Or change Token to include position.
16:01:35 <EvanR> there is no way to tell if the connection is working
16:01:38 <EvanR> until you do the action
16:01:45 <EvanR> so withConnection uses an exception handler
16:01:50 <dcoutts_> EvanR: ok so it catches the exception and retries
16:01:58 <EvanR> and possibly writes the mvar
16:02:01 <dcoutts_> right
16:02:09 <EvanR> any reason why i use mvar and not IORef
16:02:14 <micah> I was thinking of using notFollowedBy advance
16:02:20 <micah> but that gave me some weird type error
16:02:31 <aavogt> or change eof
16:02:44 <dcoutts_> EvanR: MVars are for concurrency, they give you mutex/locking
16:03:02 <EvanR> there are two threads, and i will use one connection for eaech
16:03:24 <EvanR> no sharing of connections
16:03:48 <Sadache> :t    let high= `liftA2 (.)`  in   \ a b -> flip a `high`  flip b
16:03:49 <lambdabot> parse error on input ``'
16:04:02 <Sadache> :t    let high= liftA2 (.)  in   \ a b -> flip a `high`  flip b
16:04:03 <lambdabot> forall a a1 b (f :: * -> *). (Functor f) => (a -> a1 -> b) -> f (a1 -> a) -> a1 -> f b
16:04:03 <monochrom> eof calls notFollowedBy. eof's error message comes from notFollowedBy. There is no escape.
16:04:12 <dcoutts_> EvanR: you could make it thread safe by having withConnection always use the MVar, would prevent multiple threads using the same connection simultaneously
16:04:33 <aavogt> micah: or use a newtype TOK = TOK SourcePos Token that has the show instance you desire
16:04:51 <EvanR> that sounds more complex than simply not sharing the connection
16:05:03 <EvanR> i know its not hard to use an mvar as a lock, i just dont see the need
16:05:10 <micah> aavogt: that sounds like the best idea
16:05:20 <aavogt> monochrom: and notFollowedBy calls eof to get the error message?
16:05:21 <dcoutts_> EvanR: it's for safety
16:05:43 <micah> aavogt: I thought that eof was built on notFollowedBy
16:05:44 <EvanR> if i accidentally send my db connection to some thread, i have bigger problems
16:05:59 <EvanR> id probably want that to not work
16:06:11 <dcoutts_> EvanR: right or you could have it fail noisily
16:06:21 <monochrom> notFollowedBy does not call eof.
16:06:24 <EvanR> ok that makes more sense
16:06:47 <dcoutts_> EvanR: using tryTakeMVar
16:06:52 <EvanR> but so far in haskell i havent had to write very much code to check if i wrote my code right ;)
16:06:57 <mjrosenb> ghc does a pretty good job of detecting deadlocks in my experience
16:07:24 <dcoutts_> there would be no deadlock, just reduced concurrency if you had two threads sharing a connection
16:07:43 <Sadache> ok now a different question then, is there an instance of Reader for the Applicative class?
16:07:55 <aavogt> no, but it would be amusing if there was some mutual recursion of no escape
16:08:18 <dcoutts_> aavogt: right, and ghc would probably detect that
16:08:49 <dcoutts_> possibly, depending on what else had a reference to the connection MVar
16:09:11 <EvanR> im going to create that in a single thread, and only use it there
16:09:39 <Sadache> maybe i should use the Monad instance of Applicative to have an Applicative reader
16:09:49 <dmhouse> Holy Christ, early evidence of the Higgs' Boson: http://bit.ly/98jj3
16:09:59 <EvanR> im thinking that passing stuff around (one way) isnt that bad, especially if its IO, which should be careful anyway
16:10:14 <EvanR> no need for these crazy state monads
16:11:09 <Sadache> ok no one is interested seems
16:11:29 <jlouis> EvanR: StateT a IO is rather nice
16:11:34 <micah> progress!
16:11:38 <monochrom> http://bit.ly/98jj3 redirects to http://en.wikipedia.org/wiki/April_Fools%27_Day
16:11:39 <micah> but type errors
16:11:53 <EvanR> jlouis: i heard ridicule and disgust about it
16:12:43 <monochrom> ContT r (StateT X (ContT r' (StateT Y IO)))
16:13:58 <xerox> ?unmtl ContT r (StateT X (ContT r' (StateT Y IO)))
16:13:58 <lambdabot> err: `ContT r (StateT X (ContT r' (StateT Y IO)))' is not applied to enough arguments, giving `/\A. (A -> X -> (r -> X -> Y -> IO (r', Y)) -> Y -> IO (r', Y)) -> X -> (r -> X -> Y -> IO (r', Y)) ->
16:13:58 <lambdabot> Y -> IO (r', Y)'
16:14:02 <micah> HAHA it is working
16:14:03 <micah> almost
16:14:35 <jmcarthur> EvanR: well, in order to use forkIO you have to use the run function for whatever monad stack you're using anyway. within each thread you could use a monad to handle things, though
16:14:38 <micah> now it has square brackets around the thing
16:14:47 <micah> unexpected [!] instead of unexpected !
16:15:27 <monochrom> implement showsList or something for your Show instance
16:15:45 <monochrom> showList
16:16:11 <EvanR> jmcarthur: well the threads are mostly IO...
16:16:26 <jmcarthur> EvanR: what do you want State for then?
16:16:42 <EvanR> was talking about StateT ;)
16:17:05 <jmcarthur> meh, i was conflating the terms for brevity
16:17:17 <monochrom> @unmtl ContT r IO
16:17:17 <lambdabot> err: `ContT r IO' is not applied to enough arguments, giving `/\A. (A -> IO r) -> IO r'
16:17:23 <jmcarthur> EvanR: you still can't use StateT to maintain state across thread boundaries
16:17:24 <monochrom> @unmtl ContT r IO a
16:17:24 <lambdabot> (a -> IO r) -> IO r
16:17:27 <monochrom> Ah
16:17:53 <jmcarthur> EvanR: and you still have to use runStateT to use forkIO
16:18:01 <monochrom> @unmtl ContT r (StateT X (ContT r' (StateT Y IO))) arrmatey
16:18:01 <lambdabot> (arrmatey -> X -> (r -> X -> Y -> IO (r', Y)) -> Y -> IO (r', Y)) -> X -> (r -> X -> Y -> IO (r', Y)) -> Y -> IO (r', Y)
16:19:13 <monochrom> @unmtl ContT r (StateT matey (ContT r' (StateT matey IO))) ahoy
16:19:14 <lambdabot> (ahoy -> matey -> (r -> matey -> matey -> IO (r', matey)) -> matey -> IO (r', matey)) -> matey -> (r -> matey -> matey -> IO (r', matey)) -> matey -> IO (r', matey)
16:20:16 <xerox> ?arr
16:20:16 <lambdabot> I'll keel haul ya fer that!
16:20:19 <EvanR> jmcarthur: yes, yes. after forking
16:20:47 <jmcarthur> EvanR: what state will you be managing with it?
16:20:58 <monochrom> the united state
16:21:17 <EvanR> db connection
16:21:27 <jmcarthur> EvanR: okay, i recommend against that
16:21:29 <EvanR> would be terrible
16:21:33 <EvanR> yes
16:22:01 <jmcarthur> EvanR: if you want a monad for all this, i recommend: ReaderT (MVar DBConn) IO
16:22:20 <jmcarthur> EvanR: that way threads can make new db connections and stay in sync
16:22:33 <micah> ?arr
16:22:33 <lambdabot> I'll keel haul ya fer that!
16:22:38 <jmcarthur> anyway, i'm going home now. i'll check back here later and see how things are
16:22:45 <EvanR> heh
16:24:05 <jlouis> EvanR: I use a ReaderT a (StateT b IO) in combinatorrent for most of the work. The reader has read-only configuration and the State tracks.. well.. state
16:24:32 <EvanR> yeah
16:25:16 <EvanR> maybe if the whole progrm was designed like that in the first place to have this 'global state' then it would make sense
16:25:24 <EvanR> but not to slap on at the end to fix these stupid bugs
16:25:32 <EvanR> slash, changing specs
16:27:02 * EvanR gives up work, especially since work is over for today. back to implementing haskell with some sort of charged marble machine ;)
16:27:46 <micah> aight so everything is working fine except that
16:27:57 <micah> it's putting square brackets around the thing in the error
16:31:19 <micah> and I don't know how to get rid of them
16:31:58 <EvanR> micah: you are parsing?
16:32:40 <micah> EvanR: yes
16:34:12 <deech> Hi all, I am trying to understand arrows. I have a function : (arr (+1) >>> first), which adds one to the first element of a tuple. How do I run it on input, say (0,1)?
16:34:29 <mauke> :t arr (+1) >>> first
16:34:30 <lambdabot> forall (a :: * -> * -> *) b c d. (Num (a b c), Arrow a) => a b c -> a (b, d) (c, d)
16:34:38 <mauke> that looks wrong
16:35:48 <mauke> :t first (arr (+1))
16:35:49 <lambdabot> forall b (a :: * -> * -> *) d. (Num b, Arrow a) => a (b, d) (b, d)
16:35:51 <Ytinasni> > first (+1) $ (0,4)
16:35:52 <lambdabot>   (1,4)
16:36:06 <micah> don't arrows just turn into functions?
16:36:14 <micah> at least the normal arr thing?
16:36:24 <Ytinasni> micah: a function is a type of arrow, yes.
16:36:34 <deech> mauke: What did I do wrong?
16:36:52 <mauke> I don't know, I haven't actually used arrows
16:36:59 <mauke> also too tired to think clearly
16:37:08 <fax> arrows are silly
16:37:12 <mauke> but you can't have Num (a b c), Arrow a at the same time
16:37:27 <deech> Gottit! (first $ arr (+1)) (1,2)
16:37:35 <deech> I just don't know why its right.
16:37:46 <mauke> :t first
16:37:47 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
16:38:09 <mauke> first takes an arrow and turns it into a tupling arrow (where it only acts on the first part)
16:38:18 <mauke> arr turns a function into any arrow
16:38:22 <dankna> @hoogle [a] -> [(a, a)]
16:38:22 <lambdabot> Test.QuickCheck two :: Monad m => m a -> m (a, a)
16:38:22 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
16:38:22 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
16:38:23 <micah> fax: could you explain why? I don't know much about them
16:38:32 <fax> it's just my opinion
16:38:43 <micah> ok
16:38:48 <fax> they seem useless to me
16:38:51 <fax> and impractical
16:38:58 <micah> have you seen yampa/frp with arrows?
16:39:00 <fax> yes
16:39:34 <micah> why does eof output unexpected things in square brackets?
16:39:38 <deech> mauke: Awesome! Thanks!
16:40:29 <ezracooper> Earlier dons was asking about alex and happy binaries on MacOS. Haskell Platform installed them for me in /usr/local/bin/.
16:52:35 <fax> why are mathematicians against axiom of choice?
16:52:51 <jcreigh> they hate us for our freedoms.
16:52:53 <mauke> mathematicians don't want you to make any choices
16:52:53 <fax> it is because it breaks platonism?
16:53:05 <mauke> it's fascism, pure and simple
16:53:20 <twink> I've not heard of a mathematician who cares one way or the other about the axiom of choice.
16:54:02 <Mathnerd314> as my recent teacher explained it, "we'll just assume it's true and move on to the proof"
16:54:08 <fax> twink, that sounds like excluded middle
16:54:21 <QtPlatypus> Constructivists don't like it because it isn't constructive.
16:54:28 <fax> Mathnerd314 proof of choice?
16:54:57 <tensorpudding> You can prove choice, depending on your axioms.
16:55:09 <Mathnerd314> no, some abstract algebra result
16:55:12 <fax> ok
16:55:13 <QtPlatypus> And it results in counter-intuative results.
16:55:43 <pickles> i prefer cabinetry-intuitive results myself
16:55:55 <dankna> that was an awful pun
16:55:58 <fax> loll
16:56:07 <lament> ban pickles
16:56:09 <QtPlatypus> Mathnerd314: Isn't we just assume its true the very definition of axiom?
16:56:10 <Mathnerd314> actually, it was Zorn's lemma
16:56:13 <pickles> you were expecting something else from me?
16:56:26 <ddarius> Mathnerd314: Zorn's Lemma is equivalent to the Axiom of Choice.
16:56:42 <tensorpudding> A good many things are equivalent to choice
16:57:07 <Veinor> it annoys me that I have to do import Control.Applicative ((<$>))
16:57:29 <pickles> ... i would lament being banned...
16:57:40 * ddarius would prefer the consistency over saving some parens.
16:58:04 <tensorpudding> You'd prefer that Applicative were imported in the Prelude?
16:58:49 <fax> is youtube down
16:58:51 <Veinor> I wish I could say (<$>)
16:58:57 <Veinor> instead of ((<$>))
16:59:00 <Veinor> but consistency is good, yeah
16:59:06 <pickles> fax: is for me
16:59:24 <jcreigh> fax: yep: http://downforeveryoneorjustme.com/youtube.com
17:00:15 <Veinor> go to something that's not the front page, it has a different design
17:00:21 <Veinor> so like, http://www.youtube.com/watch?v=O3rSSd0opis
17:13:58 <Mathnerd314> > 1+ (read "1")
17:13:59 <lambdabot>   2
17:14:02 <Mathnerd314> > 1+ (read "1.1")
17:14:04 <lambdabot>   * Exception: Prelude.read: no parse
17:14:09 * Mathnerd314 celebrates
17:14:28 <aavogt> defaulting
17:14:35 <aavogt> > 1+ (read "1.1") :: Double
17:14:36 <lambdabot>   2.1
17:15:26 <aavogt> Mathnerd314: haskell doesn't (and can't) look at the value of the string to guess what the result type should be
17:16:15 <Mathnerd314> hmmm... is there a way to debug that?
17:16:45 <ben_m> Greetings! Do you people think one could get into gsoc by writing a game library for Haskell, or extending HaskellGame? A wrapper to SDL with convenience functions and such things :)
17:17:38 <aavogt> Mathnerd314: what is there to debug about that?
17:18:47 <Veinor> I have xs :: [t], f :: t -> IO t, and I want IO [t]
17:18:56 <benmachine> :t mapM
17:18:57 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
17:19:04 <Veinor> woo!
17:19:05 <Mathnerd314> aavogt: how Haskell assumes
17:19:22 <benmachine> @hoogle [t] -> (t -> IO t) -> IO [t]
17:19:22 <lambdabot> Control.Monad forM :: Monad m => [a] -> (a -> m b) -> m [b]
17:19:23 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
17:19:23 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
17:19:51 <Mathnerd314> aavogt: (I want to debug that)
17:23:16 <siracusa> Mathnerd314: The default is Integer IIRC
17:25:49 <Tordek> hi, I wondered if there's some tool that'll check my import statements and notify me of the one I'm not using
17:26:07 <mauke> doesn't ghc do that?
17:26:33 <m3ga> Tordek: ghc -fwarn-unused-imports
17:26:58 <Tordek> thanks
17:27:04 <mauke> -Wall
17:27:17 <m3ga> yeah, that too :-)
17:27:43 <m3ga> I alos like -Werror, but not everyone does.
17:28:05 <mauke> -Werror is made of fail
17:28:22 <mauke> use it in private if you like, but never in a release
17:29:02 <pickles> could anyone give me a quick explanation as to what -Wall and -O2 do?
17:29:12 <pickles> (that is an 'o', and not a zero, correct?)
17:29:23 <pickles> or should i just stfu and rtfm?
17:29:24 <mauke> -Wall enables a lot of warnings, -O2 enables more optimizations (-O1 enables optimizations)
17:29:36 <mauke> -O0 disables optimizations
17:29:46 <pickles> ah i c i c
17:29:49 <pickles> thx mauke
17:29:51 <m3ga> pickles: what OS are you on? if ifs linux or mac, 'man ghc' in a terminal should tell you
17:30:05 <pickles> i have dual boot but am currently in win
17:30:08 <benmachine> I don't have a ghc man page
17:30:09 <pikhq> -O2 or -O1 should be on almost always.
17:30:12 <Veinor> how do I profile a piece of haskell code?
17:30:13 <benmachine> oh
17:30:14 <benmachine> yes I do
17:30:16 <benmachine> how about that
17:30:20 <ben_m> I don't! :/
17:30:38 <benmachine> heh
17:30:38 <m3ga> Veinor:  there is a chapter in RWH on profiling which is excellent
17:30:40 <benmachine> sux4u
17:31:17 <m3ga> @google RWH
17:31:17 <lambdabot> No Result Found.
17:31:28 <m3ga> @google 'Real World Haskell'
17:31:29 <lambdabot> http://www.realworldhaskell.org/
17:31:30 <lambdabot> Title: Real World Haskell
17:31:49 <benmachine> @where rwh
17:31:49 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
17:32:14 <Veinor> oh hey, I need to install profiling libraries
17:32:20 <Veinor> how do I do so for, say, hxt?
17:32:50 <jlouis> Veinor: cabal install --reinstall hxt after mangling a bit in ~/.cabal/config
17:33:26 <jlouis> Veinor: you will end having to install profiling libraries for all dependencies as well though
17:34:27 <aavogt> Mathnerd314: if you want to see where you are defaulting types, that's a warning included with -Wall (there's probably a flag just for that one though)
17:34:59 <jlouis> -fwarn-type-defaults
17:35:15 <Veinor> hm
17:35:33 <Veinor> so hxt is being slow I think, because all the slow parts of my program (determined by print statements) are calling out to it
17:35:56 <aavogt> you cabal install -p Veinor
17:36:06 <Veinor> ah, okay
17:38:31 <Veinor> hm
17:38:37 <Veinor> I think this is partly IO being slow as well
17:39:22 <Veinor> but I'm not sure of that is the innate nature of IO and how much of that is haskell.
17:42:52 <aavogt> then compare vs. a filter with hxt that does nothing
17:43:14 <aavogt> writing input to output or whatever
17:44:21 <Veinor> well I tried speed testing against a local file instead of over the network, and that did speed it up
17:44:59 <Veinor> so I don't know @_@
17:46:18 <Veinor> is it a good idea to pass a URL to hxt's readDocument?
17:46:55 <Veinor> or does hxt have slow IO
17:49:30 <Veinor> or.... maybe this is just the internet not being instant
17:52:39 <Veinor> maybe I should just parallelize it!
17:52:47 * Mathnerd314 gets lost reading old #haskell logs
17:53:35 <aavogt> does hxt grab the input all at once, or as-needed?
17:56:04 <Veinor> I don't know.
17:57:31 <mm_freak> if the current changes in darcs will make a new package version, should i still 'darcs record' and then 'darcs tag' separately or does it suffice to just use 'darcs tag'?
18:00:42 <aavogt> I believe that the patch you make with darcs tag doesn't actually include any changes
18:00:54 <aavogt> it just specifies a set of dependencies
18:04:37 <mm_freak> ok
18:06:18 * hackagebot fastirc 0.2.0 - Fast Internet Relay Chat (IRC) library  http://hackage.haskell.org/package/fastirc-0.2.0 (ErtugrulSoeylemez)
18:12:41 <Veinor> hm
18:17:30 * Mathnerd314 wonders at http://www.haskell.org/haskellwiki/Research_area
18:21:18 <Veinor> are there any guides to control.concurrent?
18:23:45 <mm_freak> Veinor: the haddock docs don't suffice?
18:24:30 <Veinor> I mean, a beginner's guide to how to use it
18:25:43 <SamB_XP> mm_freak: the haddock docs are NEVER enough
18:26:15 <mm_freak> true
18:26:19 <pickles> Veinor: someone gave me a couple links the other day
18:26:25 <pickles> i havent looked at them all the way through yet
18:26:28 <pickles> they might help tho
18:26:33 <pickles> http://www.haskell.org/ghc/docs/6.10-latest/html/libraries/base/Control-Concurrent.html
18:26:36 <pickles> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent-MVar.html
18:26:40 <pickles> http://donsbot.wordpress.com/2009/09/05/defun-2009-multicore-programming-in-haskell-now/
18:27:13 <pickles> that last is a presentation on concurrent in haskell
18:27:16 <pickles> again, haven't read it all yet
18:29:37 <aavogt> @type pseq
18:29:38 <lambdabot> forall a b. a -> b -> b
18:29:41 <aavogt> @type seq
18:29:42 <lambdabot> forall a t. a -> t -> t
18:29:47 <aavogt> @type par
18:29:48 <lambdabot>     Ambiguous occurrence `par'
18:29:49 <lambdabot>     It could refer to either `Control.Parallel.par', imported from Control.Parallel
18:29:49 <lambdabot>                           or `Lava.Patterns.par', imported from Lava.Patterns at State/L.hs:75:0-19
18:29:57 <aavogt> @type Control.Parallel.par
18:29:58 <lambdabot> forall a b. a -> b -> b
18:30:00 <aavogt> @type const
18:30:01 <lambdabot> forall a b. a -> b -> a
18:30:32 <aavogt> the types are not enough to know how to use these functions
18:30:33 <Veinor> aaaaah, duplicate installations of bytestring
18:30:38 * Veinor flails
18:30:54 <aavogt> kill one?
18:31:05 <Veinor> how?
18:31:40 <ezyang> I thought cabal doesn't let you do that
18:32:21 <pickles> is it multiple installations? or are you running into the lazy vs non-lazy versions?
18:32:27 <aavogt> right, you have to take it to ghc-pkg
18:32:42 <Veinor> profile
18:32:50 <Veinor> I had to reinstall a bunch of crap to enable profiling
18:34:38 <mm_freak> when i want to push a set of changes, which don't make a new package version, what do i do with the 'Version' field in the cabal file?
18:34:50 <mm_freak> do i leave it unchanged or add a '_rc' or something?
18:35:35 <mm_freak> is there a best practice?
18:35:57 <m3ga> mm_freak: you pushing to a darcs repo or to hackage?
18:36:05 <mm_freak> darcs repo
18:36:11 <mm_freak> hence "push" =)
18:36:13 <m3ga> then it doesn't matter.
18:37:02 <mm_freak> is that a technical answer?  i'm rather asking for conventions
18:37:56 <m3ga> the cabal file is really only for hackage. darcs treats is just like another source file.
18:38:26 <m3ga> you can update any source file at any time, but when you release a new version, you update the cabal file first.
18:38:34 <mm_freak> background:  if someone gets or pulls the head, he would get "version: 1.2.0", but it's already different from version 1.2.0, which can be found as a release on hackage
18:38:37 <mm_freak> you know what i mean?
18:39:20 <mm_freak> should i add a remark or change the version number slightly to make this explicit?  or is that what people expect anyway?
18:39:27 <m3ga> what I do is as soon as I do a release, I update the version then so that the rev control version is ahead of the release version
18:40:08 <mm_freak> yeah, that makes sense, but is slightly dirty, too…  but i know i'm a perfectionist and i like to exaggerate sometimes =)
18:40:15 <Veinor> basically, I have a function of type a -> IO b, and I want to run it in parallel over a list. I can't use parMap because of the IO, what do I do?
18:40:39 <mm_freak> Veinor: mapM
18:40:41 <kmc> Veinor, you can use parMap but it probably won't do what you want
18:40:53 <kmc> it will evaluate the function in parallel and yield a list of IO actions
18:40:54 <Veinor> mm_freak: but that doesn't evaluate it in parallel
18:41:04 <mm_freak> it does, if you tell it to =)
18:41:06 <kmc> Veinor, do you want to *evaluate* in parallel or *execute* in parallel?
18:41:07 <mm_freak> mapM (forkIO . f) myList
18:41:11 <aavogt> mm_freak: you can add tags to the version   0.0-rc1 or whatever
18:41:21 <Sgeo> When will the new Haskell Platform be available for Windows?
18:41:24 <Veinor> kmc: the return value is the important part, whatever that means
18:41:26 <mm_freak> aavogt: yeah, that sounds like a clean solution
18:41:52 <Veinor> because they're basically fetching web pages
18:42:01 <kmc> Veinor, the return value of your function is an IO action
18:42:10 <kmc> you probably care about executing that action
18:42:15 <aavogt> then bump the version once you start with the changes that are incompatible
18:42:17 <kmc> not just evaluating the function to get an action
18:42:27 <Veinor> ok, I want to execute in parallel
18:42:35 <m3ga> Veinor: monad-parallel package on hackage will to paralell maps over monadic functions. i'm just starting to play with it myself.
18:42:42 <m3ga> s/to/do/
18:43:10 <aavogt> forkIO and appropriate Chans or MVars?
18:43:21 <Veinor> anything... simpler? :P
18:43:27 <mm_freak> that is simple
18:43:28 <aavogt> @hackage monad-parallel
18:43:28 <lambdabot> http://hackage.haskell.org/package/monad-parallel
18:43:40 <Veinor> well, is there a simle combinator I could use?
18:43:55 <Veinor> *simple
18:44:13 <Veinor> >_>
18:45:36 <aavogt> documentation for instances!!  http://hackage.haskell.org/packages/archive/monad-parallel/0.5.1/doc/html/Control-Monad-Parallel.html#t%3AMonadParallel
18:45:40 <mm_freak> do var <- newEmptyMVar; mapM (forkIO . (readFile >=> putMVar var)) ["/etc/passwd", "/etc/group"]; results <- replicateM 2 (takeMVar var); print results
18:45:54 <mm_freak> this reads /etc/passwd and /etc/group in parallel
18:46:26 <mm_freak> in fact using Chan may be even more convenient here
18:46:32 <aavogt> mm_freak: shouldn't that use a chan?
18:47:16 <aavogt> and also it might be important to force the result of readFile
18:47:27 <mm_freak> hmm, no, MVar is easier to use here
18:47:42 <aavogt> otherwise you end up doing the IO in a single thread when you print the results
18:47:54 <mm_freak> indeed
18:48:22 <mm_freak> well, i'd use B.readFile anyway =)
18:48:32 <mm_freak> where B = Data.ByteString.Char8
18:54:49 <mm_freak> aavogt: do you know how i can document instances?  just write the usual -- | before the declaration?
18:55:07 <aavogt> mm_freak: it looks that way from the source links
18:55:27 <SamB_XP> mm_freak: you can do that now ?
18:55:36 <kmc> seems like it is not too hard to roll it yourself, and is a good exercise in Control.Concurrent.*, but it's still complicated enough that something like monad-parallel should exist
18:55:39 <mm_freak> SamB_XP: look at aavogt's link
18:55:50 <SamB_XP> last I'd heard, it didn't yet work
18:55:56 * SamB_XP :-)
18:56:01 <kmc> if you're reading files to String, seq won't do much
18:56:07 <mm_freak> kmc: it's actually not that complicated, but it's…  well…  manual =)
18:56:11 <mm_freak> side effects and stuff
18:56:45 <mm_freak> (as a non-beginner you shouldn't use String that much anyway)
18:56:47 <kmc> you'll want to force fully to normal form, using Control.Parallel.Strategies or the strict-concurrency package
18:57:05 * aavogt wonders if it works for orphans too
18:57:06 <kmc> i don't agree, String is good for many things
18:57:17 <Veinor> mm_freak: that works, I think
18:57:18 <kmc> like all lists it is better as a control-flow structure, not a datastructure
18:57:33 <mm_freak> yeah, true
18:57:43 <mm_freak> but then better call it [Char] =)
18:58:02 <kmc> laziness unifies control flow and data flow the way that relativity unifies time and space
18:58:29 <fax> @remember kmc> laziness unifies control flow and data flow the way that relativity unifies time and space
18:58:29 <lambdabot> Nice!
18:58:47 <theorbtwo> So is there a reason that documents for beginners all point at String and not something more useful for actual string processing?
18:58:59 <theorbtwo> Are other things more complicated to use, or just a clear win?
18:58:59 <kmc> theorbtwo, String is useful, it's just slow
18:59:00 <SamB_XP> hmm, does that make laziness a manifestation of relativity ?
18:59:03 <mm_freak> theorbtwo: String is useful
18:59:08 <kmc> and docs for beginners should not emphasize efficiency
18:59:12 <ddarius> By making control-data-flow?
18:59:16 <kmc> especially in a language like Haskell, where the motto is "get it working, then make it fast"
18:59:21 <mm_freak> it's just slow, which is appropriate for beginners
18:59:37 <kmc> in C++ it is very hard to get it working and you make it fast along the way
18:59:49 <SamB_XP> kmc: hehehehehehehehe
19:00:01 <mm_freak> kmc: often you _think_ you make it fast
19:00:10 <theorbtwo> Hm.  I disagree.  If it's possible to trade speed for clarity or simplicity, by all means, you should do so in a beginner's document.
19:00:11 <mm_freak> making C++ code fast requires a lot of experience IMO
19:00:21 * ddarius would have little problem in recommending Data.Text or Data.ByteString to a beginner.
19:00:24 <kmc> theorbtwo, trade which way ;P
19:00:46 <theorbtwo> ...but if you can be fast, clear, and simple, there's no reason a beginner's document shouldn't teach good habits.
19:01:00 <kmc> theorbtwo, what about conceptual understanding?
19:01:01 <Sgeo> Wait, Strings are slow?
19:01:11 <mm_freak> ddarius: ditto, but those qualified imports add a lot of irrelevant clutter
19:01:12 <kmc> Sgeo, certain operations on String are slow
19:01:26 <kmc> because String is [Char] which is a lazy singly-linked list of boxed lazy characters
19:01:37 <kmc> theorbtwo, it is much easier to understand how String works and indeed implement it yourself in pure Haskell
19:01:42 <kmc> ByteString has a complicated and magical implementation
19:02:07 <theorbtwo> "Trade foo for bar" implies you are reducing the amount of foo and increasing the amount of bar.
19:02:10 <ddarius> Also the memory overhead per character for String is like an order of magnitude or two compared to ByteString.
19:02:24 <kmc> so if you want to teach the concepts behind Haskell, and not just how to get shit done, it is good to teach String early on
19:02:25 <Veinor> mm_freak: actually, no, that thing you posted isn't working
19:02:30 <mm_freak> besides those ugly toChunks and fromChunks functions, you aren't confronted with ByteString internals a lot
19:02:46 <mm_freak> Veinor: it works here in GHCi
19:02:49 <Veinor> well
19:02:52 <Veinor> it's working, but it's not faster
19:02:58 <kmc> and you also want to teach recursion early on (this is not a Haskell concept of course, but most CS programs do a terrible job covering it and many programmers are inexplicably mystified)
19:03:06 <kmc> and recursion on strings makes much more sense than recursion on ByteString
19:03:13 <mm_freak> Veinor: because it doesn't force the read strings inside of the threads
19:03:22 <mm_freak> Veinor: use deepseq or strict ByteStrings
19:03:38 <Veinor> I'm nowhere using ByteStrings to read data
19:03:45 <mm_freak> why?
19:03:57 <Veinor> well, hxt might be using ByteStrings
19:04:15 <Veinor> anyway, the point is
19:04:41 <Veinor> how would I go about using deepSeq to force evaluation? :P
19:05:23 <kmc> Veinor, look at Control.Parallel.Strategies
19:05:24 <tromp_> ery
19:05:37 <kmc> > [1,2,3] `using` rnf
19:05:43 <lambdabot>   [1,2,3]
19:05:47 <kmc> Veinor, like that
19:05:53 <Veinor> kmc: don't those not work on IO?
19:06:11 <Veinor> because there's no instance for NFData a => NFData (IO a)
19:06:40 <kmc> Veinor, er, why are you forcing an IO value?
19:06:46 <kmc> what's the point?
19:07:01 <c_wraith> to defeat unsafeInterleaveIO?
19:07:02 <Veinor> kmc: well, basically what I want to do is read web pages in parallel
19:07:15 <Sgeo> return "kmc" :: IO String
19:07:26 <kmc> Veinor, do you understand the difference between execution and evaluation?
19:07:33 <Veinor> not really.
19:07:52 <kmc> actually, there's not a clear "difference" because they are totally different
19:08:04 <kmc> Veinor, evaluation is what happens when you apply functions to arguments and then demand ("force") the result
19:08:10 <Veinor> okay.
19:08:17 <kmc> execution is what happens when you have an IO-recipe and you want to do  what the recipe says
19:08:22 <mm_freak> Veinor: if you just use lazy hGetContents, you're reading them in parallel
19:08:37 <mm_freak> well, not in parallel, but concurrently
19:08:39 <Veinor> mm_freak: I'm not calling hGetContents anywhere, I'm using hxt's readDocument
19:08:40 <kmc> evaluation is a fundamental part of Haskell.  execution is specific to the IO monad
19:08:42 <c_wraith> executing IO is, at the highest level, what results in forcing everything in a haskell program
19:08:46 <mm_freak> i don't know whether GHC knows how to distribute
19:09:08 <kmc> evaluating an IO action does not perform the IO
19:09:20 <kmc> because the action is just a "recipe".  you can determine what the recipe says without carrying it out
19:10:58 --- topic: '["Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/", "RIP Robin Milner"]'
19:10:58 --- topic: set by Pseudonym!~ajb@torchwood.alicorna.net on [Tue Mar 23 22:13:17 2010]
19:10:58 --- names: list (clog horms kniu StefanK mjonsson cads c_wraith triplez jsgf Sgeo SyntaxNinja gonsor futilius jethomas erg0t_ kmc theorbtwo FliPPeh_ brntbeer zakwilson mauke cheater2 metaperl mibygl ttmrichter nettok__ erikc ddarius ahlmal ccasin stepnem Amadiro Jantaro saccade twanvl_ Tordek [swift] nohluhtC Mathnerd314 trie Makoryu marcmo_ ville Ferdirand miclorb khiroc kyagrd kpreid OnionKnight ezracooper shrughes buntfalke sannysanoff raymonvw_ mejja Philippa Philonous)
19:10:58 --- names: list (shingo Pewpewarrows DigitalKiwi ptrf waterlaz magicman untwisted scm sioraiocht Darkone langtree cytzol tommd SecretofMana stulli Rotaerk sigh cyanoacry dreixel m3ga preflex sundaymorning Zeiris pickles XniX23 enthymeme njbartlett stepcut Polarina Raynes ozamosi regalia kynky THC4k mdmkolbe drwho path[l] pprakash jmelesky Mortomes dancor niksnut Adamant Eridius zax Trafalgard Ziphilt Cale glguy fonz eno planetbeing_ nagnatron jbapple scheibo hgolden leoncamel)
19:10:58 --- names: list (lopex danblick ksandstr jonafan monochrom ezrakilty noam jao Nshag kermit alex404 Laney Saizan jcreigh lanthan_ grub_booter_ siracusa Itkovian xinming_ dleslie fax arjanb drk-sd eldragon bgs000 smorg ybit objorn Spockz Nomad010 arsenm Mowah dfeuer Twigathy stevenmarky Mooloo dankna orlandu63 voker57 fnordus Cadynum JimmyRcom kfish kevinclark johanj_ dmhouse JaffaCake chr1s almaisan-away Ytinasni snr dv- gal_bolle cognominal tomberek s76_ IamMilan_ nzfrio)
19:10:58 --- names: list (hackagebot pookleblinky FauxFaux Counter-Strike Cthulhon|| baaba int-e ClaudiusMaximus JBGood Younder otto_s newsham jayne amiri pmaes levitation[A] Eelis araujo potatishandlarn Draconx|Laptop TacticalGrace Raku^ idnar Peaker ehamberg mdordal2 wisemanby nothingmuch KatrinaTheLamia bd_ MacCoaster AnAdorableNick desu somnium dcoutts_ lpsmith nick8325 ickabob hiredman Taggnostr jvogel ystael nathanic_work ivazquez|laptop Jaak `0660 u_quark a11235 IceDane Reisen)
19:10:58 --- names: list (teukka Astro Boney merehap lomeo pwerken nniro lyndon sjanssen dobie_gillis putnam felipe_ michael| sfuentes snorble Poeir Shown nwf eagletmt noddy eyck gogonkt sm Colours alexsuraci Tomas Feuerbach caligula_ stenobot2010 clanehin cozmic ernst kolmodin albertosantini sshc UnderTaLker tltstc dual waern pikhq geon geekagent mmmulani dino- Gracenotes alip jfredett ibt shapr savonarola JuanDaugherty TML QtPlatypus npouillard endojelly alexbobp mm_freak DrSyzygy)
19:10:58 --- names: list (welterde solidsnack blackdog AnMaster radhermit muep lefant arjanoosting Exteris Hunner noj dj_ryan aavogt BeZerk inimino Vulpyne dilinger Paradox924X theclaw _br_ nlogax \yrlnry tomaw osfameron MrDomino^ jamwt mux eintopf jleedev EvanR jml emias profmakx tilman dqd ray Tophan otulp CosmicRay majoh Ke mrshoe_ cebewee mornfall zenzike b4taylor Lemmih canvon guerrilla keseldud1 dufflebunk Rooz_ mattam PepeSilvia Nanar dmwit djahandarie systemfault ps-auxw)
19:10:58 --- names: list (sproingie quicksilver SubStack jd10 MarcWeber kar-1 hugin helgikrs ennen jrockway megaTherion Bassetts aiko_ duairc dumael neme4ta det tew88 tensorpudding dons jvoorhis revertTS Blub\0 ve fabjan aleator pettter samulihs_ kadoban__ dionoea koala_man thetallguy2 alexsdut1on sohum mietek poucet p_l \toothrot logiclost mfoemmel Cerulean Jiten lostman_ ido impl creichen geir__ eek_ tamiko zygoloid dcolish harlekin Khisanth nuba shachaf liesen_ vpetro_ thetallguy)
19:10:58 --- names: list (Valodim lenbust gds Gilly ibid Becquerel integral cods EvanR-work te_ Twey jql yahooooo lament anders^^ ezyang alios flux birkenfeld dju Veinor SamB_XP Mr_Awesome __marius__ lambdabot wto sebbe1991 M| twink saurik chromakode emptyness47_ anekos_ matthew-1 pkrumins mrd arw_ AndyP_ pippijn handheldPenguin absentia allbery_b agemo lsthemes ahf Liskni_si netcat encryptio mreggen dropdrive djinni notrael zsol liff And[y] PHO_ tumult BrianHV moshisushi tromp_)
19:10:58 --- names: list (gbacon Innominate saiam_ ToRA srcerer joni6128 arcatan mjrosenb edwtjo_ joga flori_ kwinz clarkb ahihi therp thoughtpolice regulate fihi09``` companio1_square CodeBlock periodic malcolmw andrewsw olsner c9s tmug elly jmtd @ChanServ Nereid luite kalven suiside Milo- StoneToad saccade__ mwoz sorrofix skaar sbok mle-lucca fry companion_cube thorkilnaur PsiOmega mlh dejones stroan jix beatmox go|dfish nornagon Aisling dcoutts Igloo deadguys lispy oeblink)
19:10:58 --- names: list (danderson bnjmn Ornedan Vanadium jlouis JDLSpeedy smiler taruti MasseR willb1 ath bolmar Bleadof Sisu hazridi Apocalisp MadX` dogmaT epmf koninkje SimonRC nasloc__ twn tomlok hellige_ emma mokus_ pshc ski Stephan212 shrimpx_ drhodes occamshatchet mrothe woggle mercury^ karld DustyDingo ingy gereedy dayz davidL OscZA uorygl Dementati McManiaC jmv_ brtk2 drbean Baughn igorgue pastorn b52 MisterN jmcarthur kosmikus The_third_man orbitz shepheb Vq Entroacceptor)
19:10:58 --- names: list (gnuvince yottis bbee tafryn dixie boyscared jyyou gdsx benmachine ziman opqdonut cao burp joed mq galdor Tinned_Tuna byorgey shawn nimred cjay Botje epokal edwinb trez Zao kennethd bremner Gabbie aslhk wagle kaol wolverian Deewiant mfp rtaycher xerox icee zachk tavelram etpace m4thrick StarFire shortcircuit)
19:11:04 <Veinor> right, right.
19:11:25 <kmc> now, there is this thing called "lazy IO", which is what you get with certain functions like readFile and getContents
19:11:34 <kmc> and these actually break the normal Haskell semantics
19:11:44 <jao> so say you get a list of files, compute an IO action for each one, but only execute them later, when the file might have disappeared or changed contents. is unsafePerformIO the only solution?
19:11:56 <kmc> jao, solution to what problem?
19:12:07 <Veinor> I think part of the problem is that I'm using readDocument which I don't know how it works
19:12:17 <kmc> *evaluation* of the string produced by readFile's action causes *execution* of an actual filesystem read
19:12:18 <jao> to the fact that i want the contents at the moment the action was created
19:12:26 <kmc> jao, then you should execute the action then
19:12:41 <Cale> jao: No, it won't even help.
19:12:43 <kmc> jao, consider mapM readFile versus map readFile
19:12:54 <kmc> the former gives you an IO action yielding contents of files, at that point in time
19:13:02 <Cale> unsafePerformIO will in fact *defer* execution to the point where you evaluate the answer.
19:13:03 <c_wraith> jao: there are always race conditions that make it possible for a file to vanish between getting a directory listing and operating on it
19:13:04 <kmc> the latter gives you a list of IO actions, which could be used to get contents at a future time
19:13:13 <Cale> While you want to execute the action immediately.
19:13:25 <mibygl> If your system has a race condition, the solution is not to make one of the contestants faster until it wins.
19:13:29 <kmc> jao, due to laziness it's not easy to say when the action was "created"
19:13:49 <kmc> only when it was executed -- because that "when" is relative to other actions as combined with (>>), not relative to evaluation
19:13:51 <mibygl> jao: anyway, you want to get the contents immediately after something?
19:14:12 <jao> imagine i'm writing a top monitor
19:14:27 <kmc> the point of monadic IO is that we *don't* have to think about when the actions are "created"
19:14:30 <jao> so i read the contents of a bunch of /proc files at two points
19:14:33 <kmc> because doing so is hard
19:14:33 <jao> in time
19:14:47 <jao> and compare their contents
19:15:26 <jao> i create two directory listings, and a bunch of actions getting those contents
19:15:48 <jao> but i want the contents at precise times
19:16:05 <jao> or, if you prefer, i want to know the precise times of the contents
19:16:13 <kmc> you mean real time?
19:16:25 <jao> let's say soft real time
19:16:42 <kmc> is the question here just "how do i list a directory and then read every file immediately"?
19:16:44 <mibygl> I don't know if Haskell is very good at real-time programming.
19:16:47 <jao> i want some control on the time difference
19:16:48 <kmc> or do you want something more precise?
19:16:50 <kmc> oh
19:17:12 <kmc> jao, that is hard to get in any language without using special realtime primitives provided by the OS
19:17:21 <kmc> it's got nothing to do with laziness
19:17:51 <jao> in a strict language, i just read the file, get a time, wait, read again, get the time again
19:17:59 <kmc> that's exactly what you'd do in Haskell
19:18:00 <mibygl> Then do that in Haskell.
19:18:01 <Veinor> oh whee, Network.HTTP is giving me a bus error
19:18:03 <Veinor> what the heck
19:18:16 <kmc> that's not "realtime" though
19:18:21 <jao> how do you wait?
19:18:25 <kmc> the OS can insert whatever delay it likes between your read and your getting time
19:18:28 <kmc> @hoogle threadDelay
19:18:28 <lambdabot> Control.Concurrent threadDelay :: Int -> IO ()
19:18:33 <kmc> jao, ^^^^ arg in microseconds
19:18:36 <jao> 'read the file the first time' is an action
19:18:46 <kmc> jao, have you done IO programming in Haskell?
19:19:26 <kmc> you would not use lazy IO for this task
19:19:38 <kmc> precisely because "lazy IO" is *unlike* normal IO + lazy evaluation
19:19:58 <mibygl> Where does Cabal keep its configuration stuff under Windows?
19:20:21 <jao> http://darcs.hacks-galore.org/darcsweb/jao?r=xmobar;a=headblob;f=/Plugins/Monitors/Top.hs
19:20:34 <jao> this is how i'm doing it for an xmobar plugin
19:20:58 <jao> kmc: okay, that's what i thought, and tried to do there
19:21:05 <jao> using withFile
19:21:08 <SamB_XP> mibygl: you tried %AppData% ?
19:21:24 <kmc> jao, yeah, you are using hGetLine, which is not lazy IO afaik
19:21:26 <kmc> should be fine
19:21:34 <SamB_XP> mibygl: surely it's somewhere in serProfile%! I hope!
19:21:58 <SamB_XP> mibygl: surely it's somewhere in %UserProfile%! I hope!
19:22:09 <SamB_XP> client ate the %U before
19:22:31 <jao> kmc: okay, thanks. i was just wondering.
19:22:33 <kmc> jao, it doesn't work?
19:22:46 <Sgeo> What is unsafeInteleaveST for, exactly?
19:22:55 <jao> kmc: yes, sort of. but it's a bit resouce hungry memory-wise
19:22:56 <jmillikin> @seen bos
19:22:56 <lambdabot> Unknown command, try @list
19:23:06 <SamB_XP> Sgeo: they tell me it's *actually* unsafe
19:23:08 <Sgeo> *unsafeInterleaveST
19:23:33 <kmc> it's like unsafeInterleaveIO isn't it?
19:23:35 <jao> kmc: but the leak, if there's one, could be in other parts of the program
19:23:47 <kmc> you'd use it to defer execution of an ST action until a particular value is forced
19:24:02 <Sgeo> Why wouldn't all ST be done like that?
19:24:11 <mibygl> Found it!
19:25:26 <kmc> Sgeo, because you want the relative ordering of ST actions to be based on how they are glued together
19:25:31 <kmc> not on when they evaluate to normal form
19:25:43 <kmc> again same as IO
19:26:16 <kmc> you want it to be a structural property of the action, not an operational property of how the action is computed
19:26:48 <SamB_XP> @hoogle ST.Lazy
19:26:48 <lambdabot> No results found
19:27:14 <mibygl> What a weird error.
19:27:20 <mibygl> documentation: True\hackage.haskell.org\00-index.tar: openBinaryFile: invalid argument (Invalid argument)
19:27:29 <kmc> strict ST means the values you put into an STRef are forced to whnf
19:27:33 <kmc> which is the default i believe
19:27:35 <mibygl> Under Windows.
19:27:53 <SamB_XP> kmc: okay, I don't exactly see how that buys you anything ...
19:29:52 <kmc> *shrug*
19:30:04 <kmc> would make more sense for the strict version to force to nf, like strict-concurrency
19:30:15 <Sgeo> whnf? nf?
19:30:25 <mibygl> (Weak head) normal form.
19:30:36 <mibygl> Hi, Sgeo.
19:30:41 <kmc> weak head normal form means that the outermost part of your expression is a constructor
19:30:48 <kmc> or something else irreducible, like a lambda
19:31:30 <kmc> normal form means you can't reduce *anywhere*
19:31:45 <kmc> (mod 7 3) is neither whnf nor nf, because the outermost thing is a function application and you can proceed by substituting into that function
19:32:41 <kmc> (Just (mod 7 3)) is whnf because the outermost thing is a constructor.  you can pattern match against (Just x) without evaluating the value inside at all.  and that's the relationship between pattern matching and whnf reduction -- it's the minimal amount of computation you need to do to resolve a 1-constructor-deep pattern match
19:32:51 <kmc> but it's not nf because the inside would reduce
19:32:59 <kmc> (Just 1) is both whnf and nf
19:33:28 <aavogt>  \x -> 1+1+x
19:33:34 <aavogt> how does that work for nf?
19:33:35 <tensorpudding> (hmm, are we doing lisp now?)
19:33:42 <kmc> tensorpudding, :D
19:33:46 <aavogt> rather, for NFData
19:33:56 <Sgeo> So all nf are whnf
19:34:02 <kmc> Sgeo, yes
19:34:02 <kmc> > (\x -> 1 + 1 + x) `using` rnf
19:34:03 <lambdabot>   No instance for (Control.Parallel.Strategies.NFData (t -> t))
19:34:04 <lambdabot>    arising fr...
19:34:15 <kmc> you can't deep-force a function in Haskell
19:34:15 <Sgeo> :t using
19:34:16 <lambdabot> forall a. a -> Strategy a -> a
19:34:34 <kmc> > case Just undefined of Just _ -> ()
19:34:34 * Sgeo needs to get back to C# stuff
19:34:35 <lambdabot>   ()
19:34:40 <kmc> > case Just undefined `using` rwhnf of Just _ -> ()
19:34:41 <lambdabot>   ()
19:34:43 <kmc> > case Just undefined `using` rnf of Just _ -> ()
19:34:44 <lambdabot>   Ambiguous type variable `a' in the constraint:
19:34:44 <lambdabot>    `Control.Parallel.Strateg...
19:34:47 <kmc> > case Just undefined :: Maybe Int `using` rnf of Just _ -> ()
19:34:48 <lambdabot>   Couldn't match expected type `using (Data.Maybe.Maybe
19:34:49 <lambdabot>                      ...
19:34:51 <kmc> bleh
19:34:58 <kmc> > case (Just undefined :: Maybe Int) `using` rnf of Just _ -> ()
19:34:59 <lambdabot>   * Exception: Prelude.undefined
19:35:11 <kmc> > case (Just undefined :: Maybe Int) `using` rwhnf of Just _ -> ()
19:35:12 <lambdabot>   ()
19:35:31 <kmc> Sgeo, :(
19:35:38 <Sgeo> Yeah
19:35:41 <kmc> use some monads in your C# code just for shits
19:35:45 <Sgeo> lol
19:36:11 <Sgeo> Is there any Haskell stuff in the Google Summer of Code?
19:36:24 <tensorpudding> C# has monads?
19:36:34 <jmcarthur> no language has monads
19:36:51 <jmcarthur> but some can create the abstraction
19:37:00 <jmcarthur> :)
19:37:07 <tensorpudding> Well, I suppose.
19:37:57 <Mathnerd314> I dunno... maybe monad could be built in pretty easily
19:38:16 <Mathnerd314> with nullable types and whatnot
19:38:18 <aavogt> `do' makes them pretty builtin
19:38:34 <aavogt> at least as far as syntax goes
19:40:37 <aavogt> I suppose your syntax could be almost overloaded enough to make layout-based stuff sensible
19:40:47 <Mathnerd314> ex?
19:41:27 <aavogt> http://www.haskell.org/haskellwiki/Accessible_layout_proposal
19:42:39 <Mathnerd314> :-)
19:43:24 <aavogt> you can do layout stuff with -XQuasiQuotes
19:43:59 <aavogt> though I don't think you can get the offset of the first character
19:44:18 <aavogt> so you have to write stuff like   [$qq|\n    stuff\n     more stuff |]
19:45:02 * aavogt isn't complaining because that style is better for everything except let
19:45:17 <aavogt> I'm not sure why I'm inconsistent with that
19:46:15 <aavogt> it may have to do with my tab key expanding to 4 spaces, which makes aligning with let  relatively easy
19:50:00 <scutigera> sortBy sortfn l  : if sortfn is (a -> a -> IO Ordering) how can I use it with sortBy, or can I ?
19:50:33 <tensorpudding> liftM sortfn maybe?
19:50:42 <scutigera> @t liftM
19:50:42 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
19:50:47 <tensorpudding> Or wait.
19:50:49 <scutigera> :t liftM
19:50:49 <Sgeo> :t liftM
19:50:50 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
19:50:50 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
19:50:56 <tensorpudding> @type sortBy
19:50:56 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
19:51:37 <tensorpudding> Doesn't look like it would work.
19:51:46 <tensorpudding> sortBy has the wrong type.
19:51:55 <scutigera> :t liftM2
19:51:56 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
19:52:52 <tensorpudding> The problem is that your sort function isn't IO (a -> a -> Ordering), but a -> a -> IO Ordering
19:52:55 <aavogt> right, sortBy is not implemented in a monadic style
19:53:22 <aavogt> it could have been written     sortBy :: Monad m => (a -> a -> m Ordering) -> [a] -> m [a]
19:53:23 * Veinor is still struggling with his IO parallelization... thingy
19:53:38 <scutigera> yeah, and it's all getCurrentTimeZone's fault...
19:53:40 * BMeph wants to do some renaming, to have a program with [$qq| moar nb|]
19:53:46 <SamB_XP> wouldn't that be sortByM ?
19:53:51 <aavogt> from which you could get back the original one with runIdentity
19:54:05 <SamB_XP> but I think it'd be pretty crazy ?
19:54:17 * BMeph hates his lack of typing skills... [$qq| moar nub|]
19:54:28 <Veinor> I have an f :: a -> IO b, and a list xs :: [a]; I need to execute f over xs in parallel
19:54:31 <aavogt> what's it do?
19:54:38 <Veinor> strictly.
19:54:39 <aavogt> BMeph: ^^
19:54:51 <fax> kinda want to be able to turn any function 'f' into 'map f' by writing fs
19:55:12 <BMeph> aavogt: Make php programmers cry! ;)
19:55:19 <aavogt> @type map
19:55:19 <jmcarthur> the layout rules aren't strictly monad-related though. you could hide the Prelude and define your own (>>=), return, and fail, then do notation would do something not monadic
19:55:20 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
19:55:28 <fax> filters odd list = map (filter odd) list
19:55:39 <tensorpudding> @type ap
19:55:40 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
19:55:41 <aavogt> jmcarthur: that's not in the standard though
19:55:45 <tensorpudding> hmm
19:56:12 <Veinor> someone in here gave me some code using Control.Concurrent, but even though it appears to start them in parallel, they always finish in the same order, so I'm assuming that they're not actually starting in parallel
19:56:18 <jmcarthur> does that standard specify desugaring rules or does it specify those specific bindings from Prelude?
19:56:34 <aavogt> > uncurry zip . liftM2 (,) inits tails $ "fmap"
19:56:35 <lambdabot>   [("","fmap"),("f","map"),("fm","ap"),("fma","p"),("fmap","")]
19:56:52 <aavogt> most of those names are taken ;)
19:57:25 <jmcarthur> > liftA2 zip inits tails "fmap"
19:57:26 <lambdabot>   [("","fmap"),("f","map"),("fm","ap"),("fma","p"),("fmap","")]
19:57:40 <Veinor> so, I have the parallelIO function which I intend to be a parallelized mapM, but it's not actually any faster
19:58:14 <kmc> Veinor, you wrote this?
19:58:15 <tensorpudding> @pl \x y -> do res <- f x y; return (\x y -> res)
19:58:15 <lambdabot> (line 1, column 24):
19:58:15 <lambdabot> unexpected ";"
19:58:15 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
19:58:25 <Veinor> kmc: mm_freak wrote parallelIO :P
19:58:25 <jmcarthur> are you using -threaded and +RTS -N?
19:58:25 <aavogt> BMeph: but also operationally?
19:58:50 <tensorpudding> No do-blocks in a @pl?
19:59:07 <Veinor> oh, whoops
19:59:09 <aavogt> @pl \y -> do { x <- y; return x }
19:59:09 <lambdabot> (line 1, column 10):
19:59:09 <jmcarthur> @@ @pl @undo \x y -> do res <- f x y; return (\x y -> res)
19:59:09 <lambdabot> unexpected "{"
19:59:09 <lambdabot> expecting variable, "(", operator or end of input
19:59:09 <lambdabot>  flip flip (return . const . const) . ((>>=) .) . f
19:59:47 <Makoryu> @pl \x y -> f x y >>= \res -> return (\x y -> res)
19:59:47 <lambdabot> flip flip (return . const . const) . ((>>=) .) . f
19:59:50 <Veinor> general question then: is downloading N urls O(N) even with parallelism?
19:59:58 <Veinor> that is, downloading the content
20:00:18 <tensorpudding> That's not pleasant looking
20:00:30 <Sgeo> Haskell is bad!
20:00:31 <jmcarthur> hmm, i think -threaded shouldn't really have an effect if that's what you're doing
20:00:36 <jmcarthur> Sgeo: ?
20:00:37 <Makoryu> tensorpudding: It's also not shorter.
20:00:49 <kmc> indeed, this is about concurrency not parallelism
20:00:51 <Sgeo> Wanting to know more about Haskell is the reason I didn't get important boring stuff done!
20:00:52 <Veinor> er, yeah
20:00:56 <Veinor> I need concurrency here
20:00:59 <kmc> you could have a 1-CPU machine and still get dramatic speedup
20:01:01 <aavogt> @pl \x y -> \x y -> \x y -> x y
20:01:02 <lambdabot> const (const (const (const (const (join id)))))
20:01:08 <tensorpudding> Eh, it also doesn't have the type I wanted.
20:01:10 <kmc> because most of your threads will be blocking anyway
20:01:37 <kmc> can i see the code to parallelIO?
20:01:57 <Veinor> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24566#a24566
20:02:26 <aavogt> Makoryu: you're aware that your second x y could be _ _, right?
20:02:41 <jmcarthur> forkIO . (f >=> putMVar var)  -- ugh, mixing directions in the same line
20:02:49 <kmc> scutigera, probably you should mapM something to get a list of values that can be sorted without IO
20:02:56 <kmc> maybe by tupling on some more data
20:02:59 <SamB_XP> Veinor: yes, it's still O(n), but the constants are likely smaller
20:03:04 <aavogt> sometimes sense it makes to write things backwards
20:03:05 <Veinor> well let's see
20:03:18 <Makoryu> aavogt: I didn't even notice... Just transformed the code without looking at what it meant >_>
20:04:07 <aavogt> that's what @pl can do too ;)
20:04:19 <Veinor> replacing concurrentIO with mapM, seeing how slow it goes
20:04:57 <Veinor> concurrentIO definitely is faster.
20:04:59 <kmc> that's a nice short function
20:05:01 <kmc> i hope it works
20:05:11 <kmc> cool
20:05:35 <jmcarthur> yeah i like that definition aside from bikeshedding
20:06:18 <kmc> it should use mapM_
20:06:34 <kmc> @. pl undo \f x -> do { var <- newEmptyMVar; mapM_ (forkIO . (f >=> putMVar var)) x; replicateM (length x) (takeMVar var) }
20:06:35 <lambdabot> ((newEmptyMVar >>=) .) . (`ap` ((. takeMVar) . replicateM . length)) . (liftM2 (>>) .) . flip . ((mapM_ . (forkIO .)) .) . (. putMVar) . (>=>)
20:06:49 <Veinor> ow!
20:06:57 <jmcarthur> length x kind of bothers me
20:07:17 <kmc> you could make a "counting mapM"
20:07:18 <jmcarthur> but that's because i'm picky
20:07:24 <kmc> so you only traverse x once
20:07:44 <jmcarthur> really, compared to the IO, it's usually going to be a tiny overhead
20:08:11 <jmcarthur> although perhaps combining it would allow the garbage collector to be happier sometimes
20:08:18 <tensorpudding> @djinn (a -> a -> m b) -> m (a -> a -> b)
20:08:19 <lambdabot> -- f cannot be realized.
20:08:28 <Veinor> yeah, for four URLs, pulling them down, finding an rss feed, pulling all the posts from the rss feed, and markoving up a new one
20:08:35 <Veinor> takes 4-5 seconds
20:08:44 <jmcarthur> oh i have an idea for it
20:09:18 <Veinor> which doesn't seem too horrible
20:09:32 <Veinor> for one feed it takes like, a second
20:09:42 <tensorpudding> @djinn (a -> a -> m (m b)) -> m (a -> a -> m b)
20:09:42 <lambdabot> -- f cannot be realized.
20:09:53 <scutigera> @djinn (a -> a -> IO Ordering) -> [a] -> [a]
20:09:53 <lambdabot> Error: Undefined type IO
20:10:06 <tensorpudding> I get the feeling @djinn doesn't know monads?
20:10:10 <kmc> @pl (\x (xs, n) -> (f x : xs, succ n))
20:10:10 <lambdabot> (`ap` snd) . (. fst) . flip flip succ . (((.) . (,)) .) . (:) . f
20:10:12 <scutigera> @djinn (a -> a -> m b) -> [a] -> [a]
20:10:12 <lambdabot> Error: Undefined type []
20:10:15 <kmc> :O
20:10:18 <kmc> must be a better way
20:10:38 <kmc> @pl (\(xs, n) -> (f x : xs, succ n))
20:10:38 <lambdabot> (f x :) *** succ
20:10:44 <scutigera> *shrug*
20:10:52 <Makoryu> @unpl flip flip succ
20:10:52 <lambdabot> (\ c f -> c f succ)
20:11:08 <tensorpudding> a monadic sortBy shouldn't be too hard, I guess?
20:11:34 <Mathnerd314> @djinn a -> a
20:11:34 <lambdabot> f a = a
20:11:41 <kmc> but it would expose many implementation details of the sorting function
20:12:05 <Mathnerd314> is there a name for the functions djinn can deduce?
20:12:22 <kmc> Mathnerd314, they are theorems of propositional logic
20:12:27 <kmc> i think all of them
20:12:49 <kmc> @djinn a -> (a -> b) -> b -- modus ponens
20:12:50 <lambdabot> Cannot parse command
20:12:54 <Veinor> maybe if I rewrote it using network.HTTP and readFromString or something instead, I could make it go faster
20:12:55 <kmc> @djinn a -> (a -> b) -> b
20:12:55 <lambdabot> f a b = b a
20:13:03 <Veinor> instead of relying on readDocument
20:13:12 <SamB_XP> kmc: is it first-order propositional logic ?
20:13:18 <kmc> i guess so?
20:13:22 <kmc> it's certainly not higher order
20:13:32 <kmc> you can't write quantifiers anywhere except the outside
20:13:35 <kmc> since it doesn't have rank N types
20:13:40 <scutigera> @djinn [m a] -> [a]
20:13:40 <lambdabot> Error: Undefined type []
20:13:45 <SamB_XP> also higher-order isn't decidable
20:13:47 <kmc> so i don't know if it's even safe to call it all of first-order
20:13:55 <kmc> Mathnerd314, do you know about the Curry-Howard Isomorphism?
20:14:05 <Mathnerd314> sorta
20:14:10 <tensorpudding> Hmm, Prelude sortBy uses mergesort.
20:14:15 <Sgeo> @djin m a -> (a -> m b) -> m b
20:14:15 <lambdabot> Maybe you meant: djinn djinn-add djinn-clr djinn-del djinn-env djinn-names djinn-ver
20:14:21 <Sgeo> @djinn m a -> (a -> m b) -> m b
20:14:21 <lambdabot> -- f cannot be realized.
20:14:24 <jmcarthur> Veinor: version that traverses the list only once: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24566#a24567
20:14:36 <SamB_XP> @djinn-env
20:14:36 <lambdabot> data () = ()
20:14:36 <lambdabot> data Either a b = Left a | Right b
20:14:36 <lambdabot> data Maybe a = Nothing | Just a
20:14:36 <lambdabot> data Bool = False | True
20:14:36 <lambdabot> data Void
20:14:38 <lambdabot> type Not x = x -> Void
20:14:40 <lambdabot> class Monad m where return :: a -> m a; (>>=) :: m a -> (a -> m b) -> m b
20:14:44 <lambdabot> class Eq a where (==) :: a -> a -> Bool
20:14:58 <SamB_XP> whoa
20:15:01 <jmcarthur> @djinn Monad m => m a -> (a -> m b) -> m b
20:15:01 <lambdabot> f = (>>=)
20:15:02 <SamB_XP> looks like a bug
20:15:04 <jmcarthur> :)
20:15:05 <tensorpudding> Rather, Data.List.sortBy
20:15:39 <ddarius> kmc: It is a decision procedure for intuitionistic propositional logic.  Classical logic can be handled by encoding.
20:16:02 <Sgeo> @djinn a -> (a -> b) -> b
20:16:02 <lambdabot> f a b = b a
20:16:15 <ddarius> SamB_XP: People add Monad to the Djinn environment, but it is not really capable of handling it.
20:16:22 <jmcarthur> Veinor: ignore what i just pasted
20:16:24 <jmcarthur> it won't work
20:16:53 <jmcarthur> it will sit there and block for each thread one at a time before forking more because i'm a dummy
20:17:07 <Veinor> yeah. was going to say >_>
20:17:10 <fax> Haskell's development environment (or better said: complete lack of it) is a joke compared to Visual Studio. And I wouldn't call major rewrites of the compiler all the fucking time as "commercial-grade". Most of the Haskell books/documentation is also painfully obsolete, esp. wr/t the new standard. Mark my words: In 1 year after VS 2k10 officially comes out, F# will gain more community momentum than all the other FLs combined.
20:17:17 <fax> looool
20:17:24 <jmcarthur> only way i can think of to traverse only once is to keep a count during the mapM and then use that instead of length x
20:17:28 <fax> brainwashed people
20:17:47 <kmc> "the new standard"
20:17:52 <kmc> oh no, hierarchical module names!
20:17:58 <kmc> stop the presses!
20:17:58 <aavogt> do the books really rely on n+k patterns?
20:18:00 <Pseudonym> To be fair, Visual Studio isn't too bad so long as you don't need to interoperate with any non-microsoft tools.
20:18:16 <Veinor> yeah. was going to say >_>
20:18:18 <Veinor> whoops
20:18:33 <SamB_XP> Pseudonym: does it really make that particularly hard ?
20:18:39 <Pseudonym> I found it so.
20:18:48 <SamB_XP> It seems pretty good lately ...
20:18:49 <Pseudonym> But perhaps I was insufficiently brainwashed into the VS way of doing things
20:19:00 <Pseudonym> I was using VS7 at the time.
20:19:03 <SamB_XP> ... it's just the docs aren't great
20:19:07 <Pseudonym> And it was pretty painful.
20:19:12 <SamB_XP> well, I was using, uh, 9 I think
20:19:17 <Pseudonym> What's the state of Haskell on Eclipse?
20:19:19 <SamB_XP> 2007 they call it
20:19:22 <Pseudonym> Right.
20:19:34 <Pseudonym> Yeah, the version I was using was the on ebefore that, I'm pretty sure.
20:19:52 <kmc> using microsoft tools isn't too bad as long as they do exactly what you want
20:19:54 <tensorpudding> I saw some screenshots of the new VS.
20:19:55 <kmc> seems tautological but okay
20:19:56 <ddarius> SamB_XP: 2007?
20:20:04 <Pseudonym> I found it pretty bad to integrate VS with subversion, for example.
20:20:10 <Pseudonym> I don't think I ever managed it.
20:20:12 <SamB_XP> oh, right, 2008
20:20:13 <SamB_XP> sorry
20:20:18 <SamB_XP> got mixed up w/ Office
20:20:21 <tensorpudding> I kinda wish they refactored the interface like they did with the ribbon in office.
20:20:30 <ddarius> Pseudonym: I'm using AnkhSVN with VS 2005 without any seeming trouble.
20:20:48 <SamB_XP> tensorpudding: I'm glad they didn't!
20:20:59 <ddarius> 2008 is significantly better than 2005 in several ways, but 2005 isn't too bad.
20:21:01 <Pseudonym> Oh, never heard of that.
20:21:01 <SamB_XP> the ribbon is really bothering me
20:21:13 <ddarius> Yeah, I really hate the "new" Office.
20:21:27 <SamB_XP> I don't so much mind the Office, it's just that Ribbon
20:21:35 <ddarius> (except for the docx/pptx/xslx formats)
20:21:46 <Pseudonym> Right, it was released in 2008, which is after when I was looking for something that does it.
20:21:48 <tensorpudding> I don't mean "use the ribbon" exactly.
20:21:54 <scutigera> figured it out: do l2 <- mapM f l1; let sortedl2 = sortBy comparefn l2; return sortedl2
20:21:55 <tensorpudding> But it's so "big" and complex.
20:21:56 <Veinor> I wonder if it'd be noticeably faster if I manually pulled stuff in as opposed to using readDocument.
20:22:17 <tensorpudding> That's aside from how resource-intensive Visual Studio is.
20:22:18 <SamB_XP> tensorpudding: that's normal
20:22:41 <fax> someone asked to find a function f such that f . f = negate
20:22:50 <SamB_XP> I never know where to find anything on the ribbon :-(
20:22:52 <fax> how would you even attack that
20:22:54 <jmcarthur> that's better i think http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24566#a24568
20:22:59 <jmcarthur> getting messy though
20:23:00 <tensorpudding> It's almost like professional software can't sell if it doesn't have massive menus, millions of buttons, and requires a manual to know how to do anything.
20:23:05 <theorbtwo> Multiply by i?
20:23:20 <SamB_XP> tensorpudding: that's not it
20:23:22 <fax> no complex numbers
20:23:27 <SamB_XP> it's just that there are so many things you want it to DO
20:23:34 <SamB_XP> and they didn't think of using M-x for it
20:23:45 <SamB_XP> I haven't a clue why not, but ...
20:23:46 <tensorpudding> Can't they have customized interfaces?
20:23:55 <SamB_XP> oh, sure
20:24:00 <Veinor> ... okay the mapM version isn't any slower than the parallelized version
20:24:01 <SamB_XP> you can change all the menus IIRC
20:24:22 <SamB_XP> at least, you could in VB6, so I sure hope you can in VS9!
20:24:28 <theorbtwo> Somebody, I think a microsoftie blog, one said that everybody only uses 20% of Word.  There's 10% everybody uses... but everybody has a different extra 10%.
20:24:45 <tensorpudding> Yeah.
20:24:55 <tensorpudding> Word is at least more intuitive than VS.
20:25:00 <SamB_XP> most people, believe it or not, haven't heard of Styles
20:25:09 <jmcarthur> :(
20:25:12 <SamB_XP> it's pretty sad
20:25:20 <tensorpudding> Because almost all lay-people have some sort of external notion on how documents look, and what you can do with them, outside of Word.
20:25:28 <Veinor> jmcarthur: I think I might be running into a problem here with hxt
20:25:35 <kmc> fax, constraints on the type of f?
20:25:40 <chrisdornan> I have been trying to install the new Haskell platform in user space in sys without GMP with little success; anyone succeeded?
20:25:41 <fax> R --> R
20:25:59 <Veinor> in particular, readDocument
20:26:12 <jmcarthur> not familiar enough with hxt to speculate
20:26:15 <Veinor> yeah.
20:26:19 <SamB_XP> chrisdornan: maybe you just need to install that in ~ ?
20:26:22 <Veinor> I think I'm just going to consider this 'finished' for now
20:26:43 <SamB_XP> now, I realize it's not fun to have to install a lib in ~
20:26:52 <chrisdornan> I have installed GMP: the problem is getting CABAL to add the -L pointing at it
20:27:00 <SamB_XP> it involves all that ~/.profile hacking ...
20:27:11 <SamB_XP> chrisdornan: oh...
20:27:24 <Veinor> it takes about... one second per url
20:27:26 <Veinor> which isn't bad
20:27:31 * SamB_XP wonders if dcoutts might have any tips?
20:27:58 <chrisdornan> indeed: what is the best way of finding out: dropping an email?
20:28:17 <SamB_XP> I was hoping he was just lurking ;-)
20:28:25 <chrisdornan> me too!
20:28:34 <SamB_XP> chrisdornan: did you look in the manual at least?
20:28:58 <chrisdornan> indeed and many MacOS users seem to have been in deep pain on this
20:29:15 <SamB_XP> checked stackoverflow ?
20:29:44 <chrisdornan> huh? stack overflow?
20:29:52 <SamB_XP> @google stackoverflow
20:29:53 <lambdabot> http://stackoverflow.com/
20:29:53 <lambdabot> Title: Stack Overflow
20:30:03 <chrisdornan> ahhhh!
20:31:11 <kmc> fax, find a f :: (Real, Bool) -> (Real, Bool) such that (f . f) (x, b) = (negate x, b)
20:31:15 <SamB_XP> (please create an account before asking a question so you can give people karma if you like their answers ;-)
20:31:31 <kmc> such as: f (x, False) = (negate x, True); f (x, True) = (x, False)
20:31:33 <kmc> that works right?
20:31:43 <fax> kmc I see what you mean that's clever
20:31:54 <kmc> then you need an invertible map between R and R x {0,1}
20:31:59 <fax> yeah
20:32:01 <fax> which exists
20:32:04 <kmc> sure
20:32:13 <kmc> but if you put it all together did i miss something?
20:32:25 <fax> what you said sounds great
20:32:56 <chrisdornan> Will do! Thanks SamB_XP and lambdabot.
20:33:27 <SamB_XP> @vixen is chrisdornan welcome?
20:33:27 <lambdabot> i'll hafta plead the fifth on that one.
20:33:46 <SamB_XP> @8ball is chrisdornan welcome?
20:33:47 <lambdabot> Unknown command, try @list
20:33:49 <SamB_XP> aww
20:34:42 <chrisdornan> man, extracting those welcomes is like pulling teath
20:36:42 <dankna> @faq is chrisdornan welcome?
20:36:42 <lambdabot> The answer is: Yes! Haskell can do that.
20:37:28 <Sgeo> @faq Is there a way to write f such that f somelist = whether or not length somelist is bottom?
20:37:28 <lambdabot> The answer is: Yes! Haskell can do that.
20:37:35 <Sgeo> lambdabot lies!
20:38:03 <dankna> haha
20:38:29 <theorbtwo> @faq Can Haskell tell me if P==NP?
20:38:29 <lambdabot> The answer is: Yes! Haskell can do that.
20:38:37 <dankna> Sgeo's was more stylish
20:38:54 <dankna> (P == NP iff N == 1 :D)
20:39:08 <scutigera> @faq can I write VS 2k10 using nothing but pure code ?
20:39:08 <lambdabot> The answer is: Yes! Haskell can do that.
20:39:19 <fax> lambdabot I don't wat empty promised
20:39:22 <fax> I want action
20:39:29 <SamB_XP> scutigera: it's too late!
20:39:41 <scutigera> SamB_XP: really, you did it ?
20:39:55 <SamB_XP> they've been putting out RCs for 2k10 already, I'm fairly certain
20:40:10 <scutigera> SamB_XP: yes indeed.
20:40:53 <scutigera> you know there's only 1 reason I might go back to SML over haskell and that's so I never have to deal with the #@$@$@$!!! IO Monad ever again. aaaaaaargh.
20:41:14 <SamB_XP> scutigera: but, in SML they don't even give you a Monad
20:41:22 <SamB_XP> they just throw sideeffects at you wherever!
20:41:35 <scutigera> SamB_XP: you type that like it's a bad thing.
20:41:59 <dankna> pure code is easier to verify
20:42:21 <fax> I don't think so
20:42:23 <theorbtwo> Verifying impure code is easy!
20:42:29 <theorbtwo> If I wrote it, it must be correct.
20:42:31 * theorbtwo ducks.
20:42:49 <dankna> smirk
20:42:53 <SamB_XP> theorbtwo: you forgot the "not" after "must"
20:43:04 <scutigera> danka: yeah, what's code verification done for me lately.  but I know dealing with IO makes everything harder to write and no more correct.
20:43:05 <fax> if you have to bend over backwards to purify some naturally ______ algorithm, that will mutilate the correctness argument
20:43:10 <kmc> scutigera, IO monad means first-class IO actions
20:43:17 <dankna> well, I mean, code verification is about more than just formal verification
20:43:19 <kmc> it's better than pretending that actions and functions are the same thing
20:43:26 <kmc> of course there is a steep learning curve
20:43:27 <dankna> anything you do that helps assure you your program is correct, that's a type of verification
20:43:30 <fax> scutigera: it's no harder to write, but you are accurate when you said it's no more correct
20:43:41 <kmc> however things like ST are more correct
20:43:47 <kmc> in that you know they avoid certain forms of mutation
20:43:48 <fax> scutigera: (obvious if you are a beginner it may be much harder but that is temporary and not intrinsic)
20:43:55 <interferon> if i have, say, a WriterT transforming an IO monad, do I always need to use liftIO to run IO actions?
20:44:06 <dankna> running a few test cases in ghci is verification.  not very GOOD verification - but it's better than running a few test cases in the Lisp repl because the type system adds a lot of weight to the answers.
20:44:07 <aavogt> yes
20:44:22 <fax> dankna, oh I thought you meant formal verification
20:44:39 <dankna> oh - no, sorry.  if I'd meant formal I would have said formal, but yeah, could have been clearer.
20:44:42 <interferon> aavogt: to me?
20:44:48 <aavogt> interferon: yes
20:44:49 <theorbtwo> On the other hand, I don't think any of the above is an excuse to not have proper unit tests.
20:44:50 <kmc> scutigera, once you study Haskell long enough you start to see that argument-dependence, side effects, and deferred evaluation are three different things and that mushing them together in one concept is worse than being precise
20:44:56 <interferon> awww
20:45:05 <Veinor> jmcarthur: in case you're curious, I just tested parallelIO with Network.HTTP
20:45:08 <Veinor> it definitely speeds it up
20:45:10 <interferon> that's so clunky
20:45:13 <dankna> sure - unit tests are very helpful
20:45:14 <SamB_XP> @src MonadTrans
20:45:14 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
20:45:21 <SamB_XP> @k MonadTrans
20:45:21 <lambdabot> Maybe you meant: karma karma+ karma- karma-all keal kind . ? @ v
20:45:24 <SamB_XP> @indk MonadTrans
20:45:24 <lambdabot> Maybe you meant: id index kind undo
20:45:29 <SamB_XP> @kind MonadTrans
20:45:30 <lambdabot> Class `MonadTrans' used as a type
20:45:30 <scutigera> fax: it's the "contamination" problem.  getCurrentTimeZone for example.  not really "IO" and my entire program is turning into 1 big do expressionn:-(
20:45:31 <theorbtwo> :k MonadTrans
20:45:32 <lambdabot> Class `MonadTrans' used as a type
20:45:39 * SamB_XP hates that
20:45:42 <Cale> interferon: fwiw, I almost never use monad transformers over IO
20:45:45 <SamB_XP> :i MonadTrans
20:45:51 <dankna> getCurrentTimeZone really is IO - what if it changes?
20:46:00 <kmc> scutigera, then you should get the time zone and pass it to pure code
20:46:04 <interferon> Cale: what kind of combinations do you generally use?
20:46:08 <Cale> interferon: IO already has everything and the kitchen sink, there's not really much need to transform it
20:46:12 <fax> scutigera: that sounds like you are just learning by screwing up :P
20:46:12 <Veinor> so I just need to futz around with hxt
20:46:22 <interferon> dankna: it's not referentially transparent - depends on system configuration
20:46:23 <fax> scutigera: giving up is fine but if you beat it you'll have learned something
20:46:26 <Veinor> and Network.HTTP
20:46:33 <Cale> Probably my favourite use of monad transformers is StateT over list or some other nondeterminism monad
20:46:46 <kmc> Cale, but implementation-wise, IO exceptions are very different from ErrorT, and IORef is very different from StateT
20:46:48 <SamB_XP> Cale: well, ReaderT and such can be useful ...
20:46:49 <dankna> interferon - yes, that's what I said
20:46:52 <kmc> also IO doesn't have continuations :D
20:47:01 <kmc> ContT IO is fun
20:47:08 <kmc> @unmtl ContT s IO a
20:47:08 <lambdabot> (a -> IO s) -> IO s
20:47:10 <Cale> Yeah, ContT is probably the only thing I'd consider using over IO
20:47:11 <scutigera> fax: it's just ANNOYING.
20:47:14 <SamB_XP> Cale: how many compilers do you write ?
20:47:25 <Cale> ReaderT isn't worth the trouble, just use an extra function parameter
20:47:29 <interferon> dankna: sorry, thought you were asking a question :)
20:47:40 <Cale> (at least most of the time, I've found that to be nicer)
20:47:41 <scutigera> kmc: I thought of that but I can't seem to figure out a way to do it without threading it through everything...
20:47:42 <dankna> interferon: oh - no, was responding to scutigera :) thanks though
20:47:43 <kmc> scutigera, maybe if you hpaste some code we can help you refactor it to avoid contamination
20:47:47 <fax> scutigera, sounds like fun to me :P
20:47:49 <kmc> scutigera, yes, you have to pass it everywhere
20:47:51 <interferon> Cale: so basically you'll use some transfomers to give you a final value and then at some other level you'll pass that value to an IO action?
20:48:01 * ddarius often does use an extra parameter rather than a Reader monad (transformer).
20:48:05 <Cale> interferon: ?
20:48:12 <kmc> scutigera, time zone is the sort of pseudo-constant thing where i might feel okay using unsafePerformIO
20:48:15 <scutigera> kmc: I wouldn't do that to you :-)
20:48:22 <interferon> Cale: sorry that wasn't very clear :)
20:48:23 <kmc> like Acme.Now :D
20:48:25 <Cale> interferon: I just don't use monad transformers anywhere near IO, mostly.
20:48:44 <kmc> i actually used that in a real practical program... a program which has undefined behavior if it's running at midnight :D
20:48:49 <Cale> interferon: They're handy for getting particular types of monads, but not really ones which involve doing I/O.
20:48:50 <dankna> haha
20:49:00 <dankna> don't feed the program after midnight?
20:49:05 <kmc> yes exactly
20:49:11 <dankna> (and don't get it wet)
20:49:15 <Cale> Another nice one is WriterT with the multiplication monoid over the list monad.
20:49:20 <SamB_XP> dankna: I was just going to mention that
20:49:25 <dankna> smirk
20:49:33 <Cale> You get a nice way to collect the probabilities of events.
20:50:08 <scutigera> kmc: I'm going with passing to pure functions.  I think that will be cleaner...
20:50:32 <scutigera> kmc: and I _love_ to re-write code for the 3rd time !
20:50:54 <aavogt> wait 'till the 4th time
20:51:06 <Cale> There are some other clever uses of the monad transformer machinery -- particularly, "unwrapping" some of the functions in Control.Monad with respect to some of the standard monads and monad transformers can produce lots of handy stuff.
20:51:20 <scutigera> aavogt: heh.
20:53:15 <ddarius> E.g. mapAccumL
20:54:10 <kmc> that monad zipper stuff is amazing
20:58:02 <kmc> is there a standard function like "floor" which goes towards zero instead of down?
20:58:30 <Cale> truncate?
20:58:30 <aavogt> > round (-0.5)
20:58:31 <lambdabot>   0
20:58:38 <dankna> :t signum
20:58:39 <lambdabot> forall a. (Num a) => a -> a
20:58:41 <kmc> thanks Cale
20:58:46 <tommd> @bot
20:58:46 <lambdabot> :)
20:59:05 <Cale> > map truncate [-2,-1.75..2]
20:59:06 <lambdabot>   [-2,-1,-1,-1,-1,0,0,0,0,0,0,0,1,1,1,1,2]
20:59:07 <scutigera> kmc: cool. this is working nicely...
20:59:17 <kmc> scutigera, you mean doing IO and passing it to pure code?
20:59:28 <kmc> @quote crunchy
20:59:28 <lambdabot> kmc says: the usual structure for a Haskell program is a crunchy IO shell with a  gooey chocolate pure function center
20:59:55 <kmc> this would be a good use case for JHC's top-level IO monad binds
21:00:00 <scutigera> kmc: yes. I'm not having to run it all over the place, and it's making it very clear where I have to do the date handling.
21:00:02 <pastorn> @pl \v -> f v >> g v >> h v
21:00:02 <lambdabot> ap ((>>) . liftM2 (>>) f g) h
21:00:04 <kmc> which is a slightly more principled way of doing the global unsafePerformIO hack
21:01:56 <aavogt> use implicit params
21:02:03 <SamB_XP> ewwwwwwwww
21:02:06 <kmc> nobody uses implicit params
21:02:08 <kmc> ...but maybe they should!
21:02:13 <SamB_XP> I use them
21:02:18 <SamB_XP> but only to get types from lambdabot
21:02:22 <aavogt> or this http://hackage.haskell.org/package/reflection
21:03:00 <kmc> how many milliolegs
21:19:13 <pastorn> ugh...
21:19:19 <pastorn> undocumented low-level stuff
21:20:06 <pastorn> i want to cast a [Word8] to a Ptr a
21:20:14 <pastorn> (actually i have a ByteString)
21:20:52 <scutigera> pastorn: figure it out ?
21:21:16 <pastorn> scutigera: ehm...
21:21:45 <pastorn> hmm...
21:21:51 <pastorn> @type newArray
21:21:52 <lambdabot> Not in scope: `newArray'
21:21:56 <pastorn> @hoogle newArray
21:21:56 <lambdabot> Data.Array.MArray newArray :: (MArray a e m, Ix i) => (i, i) -> e -> m (a i e)
21:21:56 <lambdabot> Foreign.Marshal.Array newArray :: Storable a => [a] -> IO (Ptr a)
21:21:56 <lambdabot> Foreign.Marshal.Array newArray0 :: Storable a => a -> [a] -> IO (Ptr a)
21:22:03 <scutigera> I think I may have that somewhere, I'm looking...
21:22:26 <pastorn> scutigera: it's for OpenGL stuff
21:23:09 <scutigera> yeah - what I have is an ffi thingy I wrote to write binary floats to a file through C.
21:23:41 <Makoryu> Hrm.
21:23:44 <pastorn> hmm... nevermind... i'll just write my own code
21:24:01 <pastorn> scutigera: have you used OpenGL in haskell?
21:24:46 <scutigera> I have a directory called hgl...
21:25:08 <scutigera> wow, and a hello.hs using HGL !
21:25:11 <A1kmm> I'm trying to use a type as the next layer in my monad tranformer, but I get this error "Type synonym `U.ModelBuilderT' should have 2 arguments, but has been given 1"
21:25:38 <A1kmm> How do I get a * -> * kinded type?
21:25:48 <scutigera> pastorn: what're trying to do ?
21:26:21 <pastorn> scutigera: hang on... making a past... just gonna find some stuff in the OpenGL docs...
21:26:41 <pastorn> scutigera: interleaved arrays
21:26:48 <scutigera> pastorn: doh! never mind, hgl is 2D graphics.  it's very nice though :-)
21:26:53 <pastorn> hehe
21:27:10 <Makoryu> Ergh. I have a list of objects running in a simulation, and every interaction has the potential to change the relationships between the objects in some way, and also to add and remove objects at (almost) any stage.
21:27:23 <scutigera> pastorn: sorry, I could have sworn I did some small test programs in H openGL...
21:27:32 <Makoryu> Is there a sane way to do this without falling back on mutable data structures?
21:28:24 <scutigera> sure, as long as your ok with re-copying the entire data structure...
21:28:36 <scutigera> but that wouldn't be sane, right ?
21:28:48 <pastorn> scutigera: it is sane... hang on...
21:29:08 * pastorn is writing stuff! don't stress him!
21:30:42 <aavogt> A1kmm: you probably have too many parentheses
21:31:24 <aavogt> :k IO
21:31:25 <lambdabot> * -> *
21:31:29 <aavogt> :k Reader Int
21:31:30 <lambdabot> * -> *
21:31:47 <aavogt> so leave off the last parameter
21:34:03 <A1kmm> aavogt: I have: type ModelBuilderT m a = S.StateT ReactionModel (U.ModelBuilderT m) a
21:35:13 <pastorn> scutigera: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24569#a24569
21:36:45 <aavogt> A1kmm: but how is U.ModelBuilderT defined?
21:37:10 <A1kmm> type ModelBuilderT m a = S.StateT UnitsDAEModel (R.ReaderT Units m) a
21:37:27 <A1kmm> I've used it as a monad transformer in other contexts successfully.
21:38:22 <aavogt> A1kmm: http://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html#type-synonyms
21:38:30 <scutigera> pastorn: sadly I can only offer words of encouragement.
21:38:48 <A1kmm> aavogt: I tried turning that on, but it just delayed the error to when I used ModelBuilderT
21:38:57 <pastorn> scutigera: heh... i have NO clue if my idea will ever work
21:39:03 <pastorn> it would be awesome if it did
21:39:14 <pastorn> i'm guessing i will segfault like noone ever before :)
21:39:15 <A1kmm> although I only turned it on for the file with the outer monad in it.
21:39:50 <aavogt> I'm not sure if you need it enabled where U.ModelBuilderT is defined
21:40:21 <scutigera> pastorn: it looks reasonable (seriously)
21:41:03 <aavogt> but even if you manage to compose your type synonyms like that... I'm not sure you end up with what you expect with the nested StateTs
21:41:12 <pastorn> scutigera: cool, thanks :)
21:42:03 <aavogt> A1kmm: so as-is you need   lift (modify f)   to change the UnitsDAEModel
21:42:05 <A1kmm> Enabling it in both files still just delays the error.
21:42:18 <aavogt> what does it mean to delay the error anyways?
21:42:35 <A1kmm> type ModelBuilder a = ModelBuilderT I.Identity a
21:42:40 <A1kmm> I get the error on that line instead.
21:43:21 <aavogt> the same error?
21:43:42 <A1kmm> "Type synonym `U.ModelBuilderT' should have 2 arguments, but has been given 1"
21:44:08 <A1kmm> So the same as before, but on a different line.
21:45:20 <pastorn> seriously, this is annoying...
21:45:23 <chrisdornan> BTW, I solved my problem of getting Cabal to work with a user-installed GNU Multi-Precision library
21:45:36 <pastorn> how do i make a GLfloat to a CFloat?
21:45:41 <chrisdornan> The solution was ridiculously simple (if a little heavy handed)
21:45:43 <A1kmm> and S.StateT definitely does want a * -> * kind, as an experiment I changed the line to "type ModelBuilderT m a = S.StateT ReactionModel (U.ModelBuilderT m a) a"
21:45:45 <pastorn> OR to a [Word8]?
21:46:00 <A1kmm> and got "Expected kind `* -> *', but `U.ModelBuilderT m a' has kind `*'"
21:46:10 <pastorn> @hoogle t -> [Word8]
21:46:10 <lambdabot> Prelude repeat :: a -> [a]
21:46:11 <lambdabot> Data.List repeat :: a -> [a]
21:46:11 <lambdabot> Data.ByteString unpack :: ByteString -> [Word8]
21:46:26 <pastorn> @hoogle t -> ByteString
21:46:26 <lambdabot> Data.ByteString unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
21:46:26 <lambdabot> Data.ByteString.Lazy unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
21:46:26 <lambdabot> Data.ByteString.Char8 unfoldr :: (a -> Maybe (Char, a)) -> a -> ByteString
21:46:46 <chrisdornan> I installed an ld shell script on the path that inserts the requisite -L flag pointing at the user-installed GMP
21:47:02 <aavogt> A1kmm: I don't think these issues exist when you use newtype instead with -XGeneralizedNewtypeDeriving
21:47:30 <aavogt> rather, I've never seen them using that
21:47:39 <chrisdornan> I raised this question a couple of hours ago and was referred to stackoverflow.
21:47:42 <A1kmm> I'll try that.
21:48:31 <chrisdornan> In phrasing the question I hit on the answer. I have logged it on stackoverflow.
21:55:23 <pastorn> anyone here good with FFI and types?
21:55:27 <pastorn> FLOATING_TYPE(GLfloat,tyConGLfloat,"GLfloat",CFloat)
21:55:55 <pastorn> ^^ does that have the same data representation as a C GLfloat?
22:47:49 <reedycreek> who
22:47:52 <reedycreek> who james
23:31:45 <edwardk1> i believe i finally had my first need for a real RankN as opposed to Rank2 type. (yes i realize you can rewrite the former down)
23:38:02 <kmc> rewrite how?
23:38:15 <kmc> callCC should have a rank-3 type and i ran into this problem while using ContT once
23:38:54 <edwardk1> the type i have right now is newtype Ann f s = Ann { runAnn :: forall r. (forall b. (f `Annotated` s) b -> r) -> r }
23:39:23 <edwardk1> which lets me avoid using an existential box by flipping it over into a universal.
23:39:38 <jbapple> Why is such avoidance desirable?
23:40:17 <edwardk1> jbapple: in general it is easier to deal with lexical scoping with universals than existentials because when an existential 'escapes' a function ghc flips out and kills people.
23:40:36 <edwardk1> a simple version
23:40:55 <jbapple> like a ninja
23:41:12 <edwardk1> data Foo = forall s. Foo { getArg :: s, getFun :: s -> Bool }
23:41:18 <edwardk1> you can never use getArg or getFun
23:41:22 <edwardk1> because an existential escapes the box
23:42:00 <edwardk1> so you have to destructure it through the constructor
23:42:15 <edwardk1> but if you dont want to give the end user access to the constructor, they are screwed
23:42:28 <edwardk1> you can't prevent the construction of the value AND use an existential box.
23:42:29 <jbapple> sure, but that type is semantically equivalent to newtype Bool, no?
23:42:38 <edwardk1> in this case, sure.
23:42:53 <edwardk1> but you can wrap one of the 's's in a functor, etc.
23:43:26 <edwardk1> so you get something that is far less clear cut, there is still an isomorphism, because it is a particular left kan extension here
23:44:13 <jbapple> Unlike GHC, I'm find with pattern matching on existentials. It's kan extensions that make *my* head explode.
23:44:19 <jbapple> *fine
23:44:22 <edwardk1> =)
23:44:42 <kmc> kaaaaaaan
23:44:55 <jbapple> that's exactly how I feel
23:45:13 <edwardk1> kmc: i made a startrek online character named haskell kan ;)
23:45:20 <kmc> nice
23:45:20 <edwardk1> just so i could use the emote
23:46:12 <jbapple> So, why , in your case, don't you want to use newtype to (forall b . (f `Annotated` s))?
23:46:32 <jbapple> sorry, (forall b . (f `Annotated` s) b)
23:46:45 <edwardk1> you mean something like exists b. (f `Annotated` s) b ?
23:46:59 <kmc> you can use an existential and then separately create these rank-N "accessors" right?
23:47:05 <kmc> there's probably no reason to do it that way
23:47:47 <edwardk1> kmc: i started there. i started with a data Ann f s = forall b. Ann (s b) (f b)
23:48:09 <edwardk1> runAnn (Ann (s b) (f b)) k = k (s b, f b)
23:48:13 <kmc> what does (Ann f s) represent?
23:48:47 <edwardk1> but that is an 'initial encoding', whereas the elimination encoding is more satisfying, and more clearly correct
23:49:47 <edwardk1> because the elimination encoding is reboxing up the args, you can of course eliminate that with the data Ann f s = forall s. Ann (s b, f b) representation, but now you have an extra bottom. which you need to eliminate with a strictness annotation.
23:50:30 <edwardk1> kmc: it is an f `Annotated` structure of type 's' where they share a brand that is determined by the values in 's'.
23:50:55 <edwardk1> in my case an (f `Annotated` Graph) b -- is a graph with a set of external annotations that rely on the shape of the graph.
23:51:19 <edwardk1> i.e. they map from vertex ids to values using a vector or intmap, or map keys onto vertex ids, etc.
23:52:53 <edwardk1> kmc: i use the context comonad, and some quantification tricks so i can share a brand with the context and the value when i want to be able to do tricky things like update the annotation as the shape of the graph changes
23:53:32 <edwardk1> so you can have a graph annotated with its strongly connected components, and the SCC annotation can be aware of how to handle transpose, so you can transpose a graph and get an f annotated graph of its transpose, trivially.
23:53:58 <edwardk1> otoh, an annotation of type Degree which tracks the indegree and outdegree of each node in the graphm when transposed would flip its indegree and outdegree numbers.
23:54:27 <edwardk1> which are just Node annotations that share a brand anyways, so you can extract them and use them like values on each of the nodes in the graph, without actually having to traverse the graph structure to plug them in
23:54:27 <dancor> how could it be that http://hackage.haskell.org/package/SMTPClient has no build error for ghc-6.12, but on ghc-6.12.1 for me it gives Network/SMTP/ClientSession.hs:242:16: Not in scope: data constructor `Message'
23:54:42 <dancor> i guess that could have changed in the minor version change
23:57:42 <kmc> edwardk1, sounds very cool
23:58:55 <edwardk1> kmc: i'm experimenting with it as the sort of ST s-like application for comonads.
23:59:13 <edwardk1> the brand keeps you from doing stupid things with something that is associated with a structure.
