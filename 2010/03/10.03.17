00:00:06 <edwardk> Yoneda has the opposite problem. you can go from Yoneda f :~> f, but you need an instance of Functor f to go the other way
00:00:57 <edwardk> ultimately to construct the isomorphism you need the ability to define a hask Functor over your type, even if you don't actually instantiate the class
00:00:57 <ski> anyway, i was pondering that GADT types doesn't necessarily create functors, even if you don't "use an argument both co- and contra- variantly"
00:01:37 <ski> of course, one can always try to add a data constructor `FMap :: (a -> b) -> (F a -> F b)' .. but this fails the `Functor' laws
00:01:43 <edwardk> yeah
00:01:59 <edwardk> you can of course 'yoneda-transform' each constructor
00:02:00 <ezyang> Yum, that was tasty
00:02:03 <ski> (unless you actually make a quotient type .. i.e. make the type abstract, and don't expose the difference in representation)
00:02:05 <edwardk> so that you can map it in place
00:02:50 <ski> but then, while pondering this, i realized you could "normalize" the `FMap' by always having exactly one `FMap' at the outermost level
00:03:00 <ski> (and on recursive levels, if a recursive type)
00:03:06 <edwardk> its not right though
00:03:10 <edwardk> because you can witness the FMap
00:03:19 <ski> i.e. i got
00:03:28 <ski>   data FunctorOf f :: * -> *
00:03:30 <ski>     where
00:03:45 <ski>     FMapIncl :: (a -> b) -> (f a -> FunctorOf f b)
00:04:01 <ski> which is your `CoYoneda' above
00:04:33 <edwardk> ski: http://comonad.com/haskell/parsimony/dist/doc/html/parsimony/Text-Parsimony-Prim.html uses the 'yoneda transform' to make 'Parser m t' into a Functor
00:04:49 <o-_-o> man...I have so much to learn
00:04:52 <edwardk> note the function in the Satisfy node
00:04:56 <ski> hm, i was not thinking about transforming each constructor .. but adding a new constructor
00:04:58 <ezyang> ==o-_-o
00:05:10 <o-_-o> =)
00:05:16 <edwardk> ski: yeah, i know what you're thinking of, but it fails a functor law, you put the burden on every user of your type ;)
00:05:21 <ski> only, with the above, i add a new constructor to a *wrapper* type, instead of directly into the (possibly recursive) type
00:05:39 <ski> how does it fails a `Functor' law ?
00:05:47 * ski thought he checked both laws
00:05:55 <o-_-o> all my life, I can sit and read the FP + haskell related blogs and it will never end
00:06:32 <o-_-o> does conal elliot hang out here ?
00:06:36 <edwardk> you can collapse FMap's next to FMaps to get a form of fmap fusion
00:06:40 <edwardk> o-_-o: yeah
00:06:56 <ski> yes
00:07:10 <o-_-o> edwardk, what nic does he go by ?
00:07:16 <ski> and you add an initial `FMap' with `incl :: f a -> FunctorOf f a'
00:07:16 <copumpkin> conal
00:07:19 <edwardk> but you can still see them when walking up or down the tree if you have a recursive type
00:07:20 * copumpkin snores
00:07:24 <o-_-o> ah...
00:07:54 <o-_-o> everybody seems to be somebody here
00:07:56 <ski> edwardk : yeah .. but i said to *not* add it to the recursive type, instead making the `FunctorOf' *wrapper* above :)
00:08:51 <edwardk> it just strikes me as far more natural to take the 'bad' constructor, add the existentially constrained argument, and the function, and then the fmap instance drops out naturally, as do the fmap laws.
00:08:52 <ski> so, instead of modifying `f', i just use `FunctorOf f', instead (or for `Mu f' i use `Mu (FunctorOf . f)')
00:09:13 <edwardk> yes, but now you have some sort of horrid traversal pattern.
00:09:34 <vap0r> Robert Pattinson dies at the end of Remember Me? In the TWIN TOWERS?
00:09:38 <ski> edwardk : also, after thinking about this, i realized i had made a special case of this before .. namely `FunctorOf IORef' :)
00:10:35 <ski> (edwardk : in practice, if you have control over the datatype, it is quite possibly better to go your route .. i'm just claiming that one can always use the other route)
00:10:39 <edwardk> i have enough trouble getting people to understand how to properly use ones that are manually transformed, let along to get them to use a combinator like that right ;)
00:11:22 <byorgey> o-_-o: everybody is somebody everywhere. =)
00:11:30 <edwardk> have you defined the FunctorOf (FunctorOf f) -> FunctorOf f join operation for it yet? =)
00:11:34 <SubStack> a DSL for glut like loli does for http would be most excellent
00:11:41 * SubStack tucks this idea away for safe keeping
00:11:45 <ski> edwardk : what do you suggest one use, instead of `CoYoneda IORef' ?
00:11:57 <edwardk> there you're stuck ;)
00:12:10 <ski> edwardk : yes, i was slightly surprised, when i noticed i could do that :D
00:12:22 <o-_-o> byorgey, I mean famous
00:12:24 <edwardk> i never said CoYoneda wasn't useful =)
00:12:58 <byorgey> o-_-o: I knew what you meant ;)  but I was still semi-serious
00:13:07 <o-_-o> I know :-)
00:13:21 <ski> edwardk : there's also `data Foo f :: * -> * where ContraFMap :: (b -> a) -> (f a -> Foo f b)' .. does this also have a standard name ?
00:13:59 <ski> (making a contravariant functor out of `f' .. like `Foo IORef' would be a writable sink, that is a contravariant functor)
00:14:12 <edwardk> not that i can think off of the top of my head, i wouldn't be surprised if you could choose appropriate categories to have it show up as a kan extension of one sort or the other
00:15:25 <edwardk> data Foo f = forall a. Foo (b -> a) (f a -> Foo f b) -- hrmm one sec
00:15:34 <edwardk> i think i do have a name for that somewhere
00:16:00 <ski> edwardk : re the `join' that i defined .. i wonder whether one could make some kind of terms over types of kind `* -> *', so that `FunctorOf'/`CoYoneda' works like a monad over these terms
00:16:26 <ski> edwardk : s/f a -> Foo f b/f a/
00:17:19 <edwardk> CoYoneda is a Comonad if f is a Comonad.
00:17:32 <o-_-o> is there some basic material on FRP anywhere ?
00:17:59 <edwardk> o-_-o: sure, the problem is that there are a half dozen serious contenders for what FRP means at any given point in time ;)
00:18:07 <ski> (o-_-o : maybe look at conals blog ?)
00:18:25 <o-_-o> edwardk, heh
00:18:41 <edwardk> data Foo f = forall a. Foo (b -> a) (f a) ?
00:18:47 <ski> yes
00:19:05 <ski> that's the same as `data Foo f :: * -> * where ContraFMap :: (b -> a) -> (f a -> Foo f b)'
00:19:06 <edwardk> erm
00:19:17 <ski> er, add a `b' parameter to the left of `=', too
00:19:28 <ski>   data Foo f b = forall a. Foo (b -> a) (f a)
00:19:55 <edwardk> isn't that just the colimit of (f + (->) b) ? -- it strikes me as kinda boring ;)
00:20:01 <ski> if s/b -> a/a -> b/, then you said this is `CoYoneda'
00:20:34 <edwardk> er
00:20:38 <edwardk> f * (->)b
00:22:07 <ski> well, it could be used to construct a contravariant functor out of any `f' .. which seems handy in some cases
00:22:16 <edwardk> the (b -> a) adds no value, since you can't use its result.
00:22:31 <ski> (just like `CoYoneda' can be used to construct a covariant functor out of any `f')
00:23:05 <ski> consider the case where `f' is `(-> Bool)', e.g.
00:23:11 <edwardk> desconstruct the values you packed into Foo, by using ContraFMap's constructor in pattern matching and you'll see, now do something with that first arg, its useless. you might be able to feed it something, but you have no use for the 'a' that results.
00:23:42 <ski> if `f' is `IORef', then i have
00:23:45 <edwardk> hrmm
00:23:46 <edwardk> ah
00:23:51 <edwardk> tricky
00:23:52 <ski>   data Foo IORef b = forall a. Foo (b -> a) (IORef a)
00:24:04 <edwardk> ok, i stand corrected
00:24:17 <ski> so, i can convert any `b' to some `a', which is then `writeIORef'ed with the reference
00:24:58 <dmwit> :t \xs ys -> map concat (transpose [xs, ys])
00:25:00 <lambdabot> forall a. [[a]] -> [[a]] -> [[a]]
00:25:54 <edwardk> @pl  \xs ys -> map concat (transpose [xs, ys])
00:25:55 <lambdabot> ((map join . transpose) .) . (. return) . (:)
00:26:55 <ski> @type \xs ys -> concat (transpose [xs, ys])
00:26:56 <lambdabot> forall a. [a] -> [a] -> [a]
00:27:19 <dmwit> It's a bit like (zipWith (++)), but doesn't drop the end of the short side.
00:27:39 <ski> @type zipWith (Prelude.++)
00:27:40 <lambdabot> forall a. [[a]] -> [[a]] -> [[a]]
00:29:17 <edwardk> ski: so Foo there is something like a 'ContraFunctorOf' using your terminology from earlier?
00:29:30 <ski> edwardk : anyway, if you happen to find any standard name for this latter `Foo', i'd be interested to hear it
00:29:33 <ski> yes
00:30:35 <edwardk> well, i'm thinking it is something like Yoneda for Hask^op
00:30:41 <ski> (`FunctorOf' was more or less a throw-away name .. i afterwards considered `FreeFunctor', but then remembered that you possibly might had met this type before :)
00:31:02 <edwardk> yeah, FunctorOf is definitely CoYoneda
00:31:41 * ski doesn't know these by heart, yet .. but it looked similar to some of the patterns you'd talked about
00:32:59 <edwardk> if nothing else i can use it to clean up some functional reference code of mine ;)
00:33:47 <ski> hm, elaborate ?
00:34:58 <edwardk> gah the type also looks a bit like something about representability
00:35:23 <edwardk> hrmm, well, say you had a 'functional reference' type like
00:35:23 * ski recalls there was some `Text.Parsimony.Prim' page to look at, too ..
00:36:35 <edwardk> data Field a f = Field { set :: a -> f -> a, get :: a -> f }
00:37:04 <ski> ok
00:37:09 <edwardk> oh, that, be warned it is from a horribly old version of the parser combinators i was using, one sec.
00:37:14 <edwardk> http://comonad.com/haskell/parsimony/dist/doc/html/parsimony/Text-Parsimony-Prim.html
00:37:25 <edwardk> look at the type for Satisfy in Parser m t a
00:37:48 <edwardk> removing some of the 'recognizer' vs. 'parser' noise that would be
00:38:18 <ski> would that be `Satisfy :: Fun m Bool a -> Parser m t a' before the "yoneda transform" ?
00:38:22 <edwardk> data Parser t a where Satisfy :: (t -> a) -> (t -> Bool) -> Parser t a; ...
00:38:31 <ski> (hm, no, scratch that)
00:38:33 <edwardk> which had started out life as
00:38:43 <edwardk> data Parser t a where Satisfy :: (t -> Bool) -> Parser t t
00:39:00 <edwardk> the (t -> a) was added to act as an 'fmap accumulator'
00:39:19 <ski> so that new `Satisfy' is really `FMapSatisfy', then
00:39:26 <edwardk> yeah
00:39:48 <edwardk> Pure m a has similar power
00:39:52 <edwardk> in the Pure :: node
00:39:52 <ski> i.e. `FMapSatisfy f p' corresponding to the old `fmap f (Satisfy p)' (assuming we had a `fmap')
00:40:47 <ski> .. yeah ?
00:40:50 <edwardk> yeah, but the key is there is no way to abuse the constructors to accidentally layer too many fmap nodes, and it you can just define the functor instance by putting the types where they fit
00:41:02 <edwardk> with no strange fixpoints ;)
00:41:20 <edwardk> interestingly the version i was using after this did manually tie the fixpoint
00:41:41 <edwardk> but i find it better to commute the fmaps as far down the tree as i can
00:41:48 <ski> *nod* .. like with using `CoYoneda' (using `Mu' for recursive things)
00:42:12 <ski> hm, but how do one determine which constructors to modify ?
00:42:32 <ski> <edwardk> but i find it better to commute the fmaps as far down the tree as i can
00:42:35 <edwardk> in my case they were the only ones constrained in the argument i was making 'functorial'
00:42:42 <ski> ^ ah, i suppose that is the guiding idea
00:43:38 <ski> so the `Pure' constructor was not affected by the "yoneda transform", then ?
00:43:50 <edwardk> the Pure nodes in that GADT just has a value, so those doesn't need to be transformed, you can fmap traditionally
00:44:02 <edwardk> Pure :: a -> Parser t a
00:44:11 <edwardk> er
00:44:14 <edwardk> the types there look like
00:44:18 <edwardk> Parser Recognizing t a
00:44:21 <edwardk> and Parser Parsing t a
00:44:33 <ski> what is the `Pure' type ?
00:44:48 <edwardk> Parsing and Recognizing just determing if we actually care about the phantom type
00:45:00 <edwardk> You'll cringe when you see this section of code ;)
00:45:12 * ski only sees `type Pure m :: * -> *' so supposes it is abstract
00:45:29 <edwardk> look up the def  class (Arrow (Fun m), Applicative (Pure m)) => Mode m where
00:46:10 <edwardk> instance Mode Parsing is pretty boring. type Pure Parsing = Id; type Fun Parsing = (->)
00:46:32 <ski> edwardk : so, you were saying that the "previous" `Pure :: a -> Parser t a' was translated to `Pure :: Pure m a -> Parser m t a', using the "yoneda transform" ? .. possibly introducing an auxilary type `Pure' in the process ?
00:46:41 <edwardk> but instance Mode Recognizing provides type Pure Recognizing = TrivialApplicative; and type Fun Recognizing = TrivialArrow
00:46:51 <edwardk> nah
00:47:15 <edwardk> the type 'Pure m a' exists so i can make recognizing parsers collapse epsilon nodes
00:47:37 <ski> how was it related to "<edwardk> Pure :: a -> Parser t a", then ?
00:47:58 * ski is just here after to understand how you did this "yoneda transform"
00:48:04 <edwardk> a Parser Parsing ... recognizes an attribute grammar. a Parser Recognizing extracts no information other than the truth of a successful parse
00:48:38 <edwardk> think of it as the difference between a right seminearring and an alternative. you either don't care about the alternative's type argument or you do
00:49:13 <edwardk> recognizing parsers don't care about the type argument, so they can unsafeCoerce Pure nodes, since the Pure nodes contain no information other than their presence
00:49:19 * ski doesn't have definitions of "right seminearring" nor "alternative" in head
00:49:25 <edwardk> you can fmap a recognizing parser, because the type argument doesn't have meaning
00:49:36 <ski> (hm, is that "alternative" as in loops with the alternative law ?)
00:49:41 <edwardk> and you can do that fmap by just using unsafeCoerce
00:49:48 <edwardk> alternative as in control.applicative.alternative
00:49:58 <edwardk> alternative is to applicative as monadplus is to monad
00:50:08 <ski> .. oh, that
00:51:04 * ski isn't really following the specific parsing context, here ..
00:51:06 <edwardk> the reason for 'Pure' and 'Fun' is so that when i'm dealing with a Parser Recognizing tokentype resultType, -- resultType is never used. so i could unify nodes that shared everything else
00:51:09 <edwardk> ok
00:51:16 <edwardk> lets look at the big picture
00:51:30 <edwardk> i'm taking an applicative and using it to build a context free attribute grammar
00:51:47 <ski> i was hoping i could understand the use of "yoneda transform" in this case, without having to understands the "why"s of `Parser' by itself
00:52:16 <edwardk> i may want to extract the attribute or not, if i don't care to extract the attribute, i can increase sharing in the nodes of my parser.
00:52:26 <edwardk> which asymptotically affects the runtime of my parsers
00:52:43 <ski> .. and you seemed to be saying that `Pure :: a -> Parser t a' was to be transformed into the current `Pure :: Pure m a -> Parser m t a' by the "yoneda transform"
00:52:52 <edwardk> Parser Recognizing... is used for a lot of my parser combinators to make whole branches of the parse tree run faster with increased sharing
00:52:54 <edwardk> no
00:52:58 <edwardk> only Satisfy =)
00:53:30 <ski> so, only `Satisfy' was changed, to make `Parser m t' into a functor, by "yoneda transform" ?
00:53:47 <edwardk> Satsify was transformed from Satisfy :: (t -> Bool) -> Parser t t -- to Satisfy (t -> a) -> (t -> Bool) -> Parser t a
00:54:06 <edwardk> Pure had an 'a' that could be fmapped traditionally.
00:54:33 <edwardk> Pure :: a -> Parser t a -- didn't need to be transformed. after all. tere is a perfectly valid definition of fmap for it. fmap f (Pure a) = Pure (f a)
00:54:38 <ski> (yes, i got that part :) .. i was wondering about the rest of the constructors .. which needed to be changed ?)
00:54:49 <edwardk> nothing
00:54:53 <edwardk> just Satisfy
00:54:55 <ski> ok, ty :)
00:54:58 <ski> yes
00:55:02 <ski> and if you had
00:55:12 <edwardk> sorry, its 4am here, i was a little slow on the uptake ;)
00:55:17 <ski>   Foo :: Bar m t a -> Parser m t a
00:55:19 <rtaycher> I'm trying to try h4sh when trying to compile it it says I need dependencies: plugins and fps, I can't find fps on hackage anybody know where it is, or is pfs and or h4sh unmaintied/uncompilable
00:55:31 <ski> then we just delegate the `fmap' to `Bar m t'
00:55:43 <ivanm> rtaycher: don't touch it, it's way too old
00:55:47 <ivanm> fps is the old name for bytestrings
00:55:55 <ivanm> and plugins will most likely not work either
00:55:59 <edwardk> ski: yeah, and if you can't fmap that, then CoYoneda transform it, etc.
00:56:10 <ski> edwardk : np. just trying to make sure i understood the basic idea
00:56:13 <ski> *nod*
00:56:27 <ski> so, you were to say something about
00:56:35 <ski>   data Field a f = Field { set :: a -> f -> a, get :: a -> f }
00:56:47 <rtaycher> it compiled at least, so is h4sh dead then, is there anything like it? it looked really cool
00:56:55 <ski> (in relation to `FunctorOf'/`CoYoneda' and/or `ContraFunctorOf')
00:56:58 <edwardk> yeah, not sure i recall any more =)
00:57:30 <ski> ok (probably my fault for bringing up the parser example you linked to, at that point :)
00:57:31 <ivanm> rtaycher: what is h4sh?
00:57:45 <ivanm> since it doesn't appear to be on hackage...
00:58:06 <edwardk> i think i was looking at using CoYoneda (Field a) and Yoneda (Field a) as the outcome of mapping it with a function from (a ->b) or (b -> a) respectively but i don't rightly recall
00:58:31 <rtaycher> its not I downloaded it from a darcs repo, from websit About: h4sh provides a set of Haskell List functions as normal unix shell commands. This allows us to use Haskell in shell scripts transparently.
00:58:56 <rtaycher> http://www.cse.unsw.edu.au/~dons/h4sh.html
00:58:57 <edwardk> it is neither a functor nor a contrafunctor, but it can let you restrict your access to one side or the other through coyoneda, or the contrayoneda thing or whatever it should be called you mentioned
00:59:01 <ivanm> there are varioius haskell shell projects
00:59:01 <ski> (hm, one last(?) question about the parser : is the reason for `Fun' only for efficiency (avoid copy) ?)
00:59:06 <ivanm> AFAIK they're pretty much all dead
00:59:26 <ski> edwardk : `Field' being ?
00:59:30 <ivanm> e.g. Hashell
00:59:31 <edwardk> well, with the TrivialApplicative it allows me to rebuild the CFG from the bottom up using memozing combinators
00:59:39 <ski> (the mathematical concept ?)
00:59:45 <edwardk> the data Field a f = Field ...
00:59:53 <ski> er .. sorry
00:59:56 <edwardk> being a name for a functional reference/field accessor
01:00:53 <ski> edwardk : right. enabling memoizing falls into "only for efficiency", here :)
01:01:03 <edwardk> yeah
01:01:27 <edwardk> only for efficiency being the difference between terminating in half a second and in my lifetime, but yes, only for efficiency ;)
01:01:36 <ski> exactly :)
01:02:58 <edwardk> that machinery which you don't care about is so that the combinators in http://comonad.com/haskell/parsimony/dist/doc/html/parsimony/Text-Parsimony-Combinators.html which feel like the parsec ones can be explicit about the fact that the applicative doesn't capture any information about certain parts of the input.
01:03:25 <edwardk> i.e. sepEndBy doesn't retain any information about the ranges that only were used in the separators
01:03:42 <ski> hm, i wonder what `CoYoneda (Field a)' means, since the argument of `Field a' is used both co- and contra- variantly ..
01:04:00 <edwardk> it should effectively 'shut off' access to one side of it
01:04:06 <edwardk> since you won't be able to get at it
01:04:18 <edwardk> er at the appropriate type to use it
01:05:10 <ski> (does that by itself improve efficiency (or responsiveness), though ?)
01:05:32 <edwardk> expanding it. data CoYoneda (Field a) r where CoYoneda :: (a -> r) -> Field a r -> CoYoneda (Field a) r
01:05:54 <edwardk> er
01:06:02 <edwardk> screwed that up
01:06:05 <ski> you need one more variable, in there
01:06:47 <ski> (er,hm, no i was thinking about unfolding `Field')
01:06:47 * hackagebot HTF 0.3.2 - The Haskell Test Framework  http://hackage.haskell.org/package/HTF-0.3.2 (StefanWehr)
01:07:07 <edwardk> data CoYoneda (Field a) r where CoYoneda :: (unknown -> r) -> Field a unknown -> CoYoneda (Field a) r
01:07:32 <edwardk> so I have an unknown -> r, and I have the field methods of a -> r -> a, and a -> r.
01:07:41 <ski> m
01:07:43 <edwardk> so given CoYoneda (Field a) r -- all I can use is the a -> r -> a
01:07:58 <edwardk> by plugging in unknown -> r
01:08:49 <Trinitron> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24046#a24046 halp plz.
01:08:56 <edwardk> erf
01:09:01 <edwardk> its too late, i need sleep ;)
01:09:20 <ski>   data CoYoneda_Field a :: * -> * where FMapIncl_Field :: (x -> b) -> (a -> x -> a) -> (a -> x) -> CoYoneda_Field a b
01:09:37 <ski> edwardk : ok. thanks for the info !
01:09:42 <edwardk> hrmm
01:10:21 <edwardk> so with a CoYonedaField a b -- you can extract a b, but you can't use the a -> x -> a side
01:10:37 <ski> (.. so it seems not that useful)
01:10:44 <edwardk> no that was what i wanted it for =)
01:10:52 <ski> oh, ok
01:11:46 <edwardk> coz i'd just be applying it like a transformer to get fmap-like functionality
01:12:10 <edwardk> similarly you should be able to use your contravariant version to shut off the other side
01:12:30 <ski> ok, so that is like restricting `IORef' to `IOReadRef', and then making that into a `Functor'
01:12:37 <edwardk> and you should be able to show that CoYoneda (CoYoneda f) a ~> CoYoneda f a
01:12:40 <edwardk> yeah
01:12:59 <ski> edwardk : as i mentioned, i *did* code that :)
01:13:03 <edwardk> the latter should allow you to apply the transforms
01:13:06 <SubStack> IORef *shudder*
01:13:08 <edwardk> yeah
01:13:24 <edwardk> er the latter should allow youy to apply the transforms, and then flatten them out
01:13:31 <ski> (which transforms ?)
01:14:04 <edwardk> taking (r -> s) -> Field a r -> CoYoneda (Field a) s
01:14:12 <ski> SubStack : isn't cleanly separated readable and writable views of `IORef' often somewhat better than `IORef' itself ?
01:14:24 <edwardk> or even just (r -> s) -> f r -> CoYoneda f s
01:14:34 <edwardk> (obviously)
01:14:36 * ski is not following
01:14:47 <ski> which transforms need flattening ?
01:14:57 <edwardk> CoYoneda :: (r -> s) -> f r -> CoYoneda f s -- works fine once
01:15:04 <edwardk> but apply it twice...
01:15:09 <ski> oh ..
01:15:11 <edwardk> then you have a CoYoneda (CoYoneda f) s
01:15:16 <ski> *nod*
01:15:23 <edwardk> which i'd hazard can be flattened to to CoYoneda f a
01:15:26 <edwardk> er CoYoneda f s
01:15:29 <Kostafey> Is there are simpler way to make roundBy http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24047#a24047
01:15:34 <SubStack> ski: I'm just shuddering remembering some terrible concurrency IORef bugs I had one time that required excessive amounts of refactoring to fix
01:15:55 * ski wants an internal language for the category of monads over `Hask' !
01:15:59 <edwardk> SubStack: MVars are your friends ;)
01:16:08 <ski> (or something similar)
01:16:31 <SubStack> indeed they are
01:16:57 <SubStack> glut examples should be publically shamed for using IORefs to much
01:17:09 <ski> SubStack : yeah, i'm just using `IORef' here as a generic "mutable reference cell" type .. for concurrency, you want some more safety, yes
01:17:47 <SubStack> s/to/so/
01:18:23 <SubStack> ski: still, if that code ever needs to be concurrent, it's going to be painful
01:18:57 <ski> (edwardk : btw, both `CoYoneda'/`FunctorOf' and `ContraFunctorOf' are `Functor2' and 'Monad2' in the sense of having that above `join' and similar operations)
01:19:12 <ski> SubStack : which code ?
01:19:19 <edwardk> Functor2/Monad2?
01:19:28 <ski>   class Functor2 t
01:19:30 <ski>     where
01:19:53 <ski>     fmap2 :: (forall a. f a -> g a) -> (forall a. t f a -> t g a)
01:20:01 <ski>   class Functor2 t => Monad2 t
01:20:03 <ski>     where
01:20:20 <ski>     return2 :: f a -> t f a
01:20:23 <SubStack> oh there is no code >_<
01:20:29 <SubStack> for the best then
01:20:31 <ski>     join2 :: t (t f) a -> t f a
01:20:40 <edwardk> ah
01:20:56 <ski> SubStack : just a general discussion .. what i said re `IORef' applies to `MVar',&c. just as well
01:21:17 <ski> (not the absence of `Functor' or `Monad' constraints on `f' and `g', there)
01:21:20 <ski> (s/not/note/)
01:21:34 <edwardk> yeah
01:21:48 <ski> i'm not sure how useful the above is, though
01:22:34 <edwardk> i think that is just a function of CoYoneda/Yoneda being a functor regardless of the type of its argument.
01:22:49 <ski> when i last looked at it, not many monad transformers (where `lift' is `return2') appeared to support `join2' (even with `Functor' or `Monad' constraints on 'f')
01:23:12 <edwardk> yeah
01:23:39 <edwardk> i have something similar in http://hackage.haskell.org/packages/archive/category-extras/0.53.0/doc/html/Control-Monad-HigherOrder.html
01:23:47 <edwardk> but the arguments are functors themselves
01:23:48 <ski> hm, but `CoYoneda'/`FunctorOf' and `ContraFunctorOf' doesn't seem to be `CoMonad2', though
01:24:07 <edwardk> check Yoneda perhaps?
01:25:28 <edwardk> the member i'm thinking of w.r.t. Monad2, etc. is the hfmap in HFunctor. ffmap is only needed for the domain i'm choosing to work in, but you could live without it for some uses. ghani and johann used the HFunctor minus ffmap to model things like GADTs using initial semantics, etc.
01:25:48 <ski> (yeah, i've mostly considered with `Functor' (or even `Monad') constraints, as you do .. just in this case, i didn't need to assume it)
01:26:01 <edwardk> yeah
01:26:06 <edwardk> there are cases where you can't
01:26:14 <edwardk> that is why i mentioned the ghani/johann paper
01:26:48 <ski> (hm, or do you do that ?)
01:27:05 <ski> what is that `(:~>)' ?
01:27:29 <edwardk> type (:~>) f g = forall a. f a -> g a
01:27:33 <ski> hm, it must be natural transformation of course .. silly me
01:27:36 <edwardk> yeah
01:28:10 <ski> but you don't have `Functor' constraints on `g' and `h' in `hfmap' ..
01:28:26 <edwardk> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.85.1152 uses an HFunctor like the one in my module
01:28:45 <ski> is that the "ghani/johann" (which i don't recall you mentioning) ?
01:28:53 <ski> s//paper /
01:29:23 <edwardk> they have another paper that doesn't have the Functor constraint at all because the HFunctor in that paper doesn't offer the ffmap functionality, because they only work over the 'discrete category' of Haske
01:29:25 <edwardk> er Hask
01:29:26 <ski> (hm, yes i suppose it is)
01:29:36 <edwardk> yeah it is
01:30:32 <edwardk> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.111.2948 seems to be the one I'm remembering with the lighter weight HFunctor
01:30:46 <edwardk> rather there was another preprint but this one seems to be the only one I can find at the moment
01:31:03 <edwardk> both are quite good
01:31:18 <edwardk> and might give you a better intuition for my Lan/Ran based ramblings ;)
01:31:51 <ski> no `hfmap :: (HFunctor t,Functor f,Functor g) => (f :~> g) -> (t f :~> t g)', though ?
01:32:02 <edwardk> nah
01:32:19 <edwardk> think about it
01:32:20 * ski str he needed that, for some examples
01:32:25 <edwardk> what could you use the Functor's for?
01:32:32 <ski> (maybe i misremember)
01:33:12 <ski> well, consider `t' being `StateT s' ?
01:33:26 <edwardk> perhaps you're thinking of 't's that affect the contents ?
01:33:26 <edwardk> ah
01:33:27 <edwardk> yes
01:33:28 <edwardk> ok
01:33:37 <edwardk> i do recall needing that type once now =)
01:33:58 <edwardk> i was playing around with 'Applicative Transformers'
01:34:05 <ski> (i don't recall any example needing `Monad' rather than `Functor' constraints, though, atm)
01:36:05 <ski> anyway, i probably shouldn't keep you any longer from misty-magic land ..
01:36:10 <edwardk> hah
01:36:21 <ski> edwardk : again, ty for the info
01:36:21 <edwardk> i'll only get an hour or so before i have to go into work anyways ;)
01:36:25 <edwardk> no worries
01:36:39 <edwardk> thanks for challenging my preconception on CoYoneda IORef ;)
01:37:02 <ski> np :)
01:37:07 <edwardk> sorry for the  parser tangent ;)
01:37:12 <edwardk> anyways night
01:38:39 * ski declares #haskell to be (relatively) free of Confusing Category Theoretic Jargon[tm], for some while at least
01:38:52 <SubStack> but for how long?
01:39:11 <ski> until you decide to bring it up again, of course :)
01:49:40 <Trinitron> Can I memoise a function that takes 2 arguments?
01:52:34 <Trinitron> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24050#a24050 Do you see something wrong with this code?
01:55:55 <Axman6> Trinitron: no function takes two arguments ;)
01:56:38 <Trinitron> Because when I run pal 0 0 it doesn't terminate.
01:57:05 <Trinitron> It should, it's only approximately 10000 iterations.
01:58:12 <ski> you should give a name to `max (pal (x+1) y) (pal x (y+1))' in a `where', instead of saying it twice
01:58:57 <ski> also, you want dynamic programming (e.g. by memoization)
01:59:28 <Trinitron> Can maps have a tuple as a key?
01:59:37 <Trinitron> 2-tuple
02:00:23 <ski> yes
02:00:45 <ski> but i suppose i would try with an array
02:02:17 <Trinitron> How do you use arrays?
02:03:04 <Axman6> by reading the docs, and seeing how they're used
02:03:24 <Axman6> well, technically that's how you learn to use them, but doing that is more helpful
02:04:43 <Trinitron> Why would I use an array, ski?
02:06:19 <Axman6> because you hve O(1) access to any element, and once a value in an array is evaluated, it doesn't need to be evaluated again
02:07:01 <ski> > let tabulate ran f = array ran [(i,f i) | i <- range ran] in tabulate ((2,2),(3,3)) (uncurry (^))
02:07:02 <lambdabot>   array ((2,2),(3,3)) [((2,2),4),((2,3),8),((3,2),9),((3,3),27)]
02:07:50 <ski> Trinitron : you can recursively define the array it terms of itself, once and for all (for each call giving values to parameters) .. and what Axman6 said
02:08:33 <Trinitron> Ah
02:08:39 <Trinitron> So no need for DP.
02:08:42 <Axman6> :t array
02:08:43 <ski> Trinitron : the above lambdabot example creates a two-dimensional array indexed by `2',`3' both on the rows and the columns
02:08:43 <lambdabot> forall i e. (Ix i) => (i, i) -> [(i, e)] -> Array i e
02:09:00 <ski> Trinitron : using this, you *do* a form of DP !
02:09:05 <Trinitron> ok
02:09:19 <ski> > let tabulate ran f = array ran [(i,f i) | i <- range ran] in tabulate ((2,2),(3,3)) (uncurry (^)) ! (3,2)
02:09:21 <lambdabot>   9
02:09:28 <ski> you use `(!)' to index in an array
02:10:01 <ski> if you like you can abstract out the building of the array from the actual function to use to populate the array
02:10:07 <Axman6> > let fibArr = array (0,100000) ((0,0):(1,1):[(n,fibArr !! (n-1) + fibArr !! (n-2)) | n <- [2..10000]]) in fibArr !! 1000
02:10:08 <lambdabot>   Couldn't match expected type `[a]'
02:10:08 <lambdabot>         against inferred type `GHC.Arr.A...
02:10:24 <Axman6> > let fibArr = array (0,100000) ((0,0):(1,1):[(n,fibArr ! (n-1) + fibArr ! (n-2)) | n <- [2..10000]]) in fibArr ! 1000
02:10:26 <lambdabot>   434665576869374564356885276750406258025646605173717804024817290895365554179...
02:10:29 <Axman6> > let fibArr = array (0,100000) ((0,0):(1,1):[(n,fibArr ! (n-1) + fibArr ! (n-2)) | n <- [2..10000]]) in fibArr ! 10000
02:10:30 <lambdabot>   336447648764317832666216120051075433103021484606800639065647699746800814421...
02:11:10 <Axman6> > let fib n = fibArr ! n where fibArr = array (0,n) ((0,0):(1,1):[(m,fibArr ! (m-1) + fibArr ! (m-2)) | m <- [2..10000]]) in fib 10000
02:11:11 <lambdabot>   336447648764317832666216120051075433103021484606800639065647699746800814421...
02:11:14 <Axman6> > let fib n = fibArr ! n where fibArr = array (0,n) ((0,0):(1,1):[(m,fibArr ! (m-1) + fibArr ! (m-2)) | m <- [2..10000]]) in fib 100000
02:11:16 <lambdabot>   * Exception: (Array.!): undefined array element
02:11:26 <Axman6> > let fib n = fibArr ! n where fibArr = array (0,n) ((0,0):(1,1):[(m,fibArr ! (m-1) + fibArr ! (m-2)) | m <- [2..n]]) in fib 10000
02:11:27 <lambdabot>   336447648764317832666216120051075433103021484606800639065647699746800814421...
02:11:31 <Axman6> > let fib n = fibArr ! n where fibArr = array (0,n) ((0,0):(1,1):[(m,fibArr ! (m-1) + fibArr ! (m-2)) | m <- [2..n]]) in fib 100000
02:11:36 <lambdabot>   mueval-core: Time limit exceeded
02:11:39 <Axman6> :(
02:12:05 <Axman6> anyway, that's how you efficiently memoise the fibonacci n function
02:16:07 <Saizan> not really
02:16:17 <Saizan> you've to eta-reduce that to make it work
02:16:21 <Trinitron> Heh, the topic is a list of strings. :D
02:16:50 <Trinitron> A string is just sugar for a list of characters.
02:16:52 <Saizan> mh, i might be wrong.
02:17:01 <ski> > (fixTabulate (0,100) $ \fib n -> if n < 2 then n else fib (n-1) + fib (n-2)) 100  -- the array abstracted out
02:17:03 <lambdabot>   354224848179261915075
02:17:05 <Saizan> Trinitron: yeah :)
02:17:06 <Trinitron> "abc" == ['a','b','c']
02:17:14 <Trinitron> > "abc" == ['a','b','c']
02:17:16 <lambdabot>   True
02:17:22 <Trinitron> QED
02:17:56 <Saizan> Axman6: ah, ok, what you wrote memoizes it within a single call
02:18:06 <Axman6> yeah
02:19:31 <ski> Trinitron : you could probably define your `pal' like `pal = curry . fixTabulate ((0,0),(100,100)) $ \pal_ (x,y) -> if x == 100 || y == 100 then 0 else ..(max (pal_ (x+1) y) (pal x (y+1)))..'
02:20:06 <Trinitron> What is the $ operator?
02:20:16 <ski> just low-precedence application
02:20:41 <ski> `foo $ \x -> ...' there can be written as `foo (\x -> ...)'
02:20:47 <systemfault> Noob here... What is fixTabulate?
02:21:15 <ski> systemfault : just a convenience for memoization i defined a couple of minutes ago in lambdabot :)
02:21:21 <ski> @type fixTabulate
02:21:22 <lambdabot> forall i e. (Ix i) => (i, i) -> ((i -> e) -> i -> e) -> i -> e
02:21:46 <systemfault> Ah :)
02:21:54 <Trinitron> Wow, a precedence operator. Now I've seen everything.
02:22:02 <ski> it takes the bounds of the internal array to construct, and a function which will be tied into a knot, with the array creation and access interleaving that
02:22:27 <ski> Trinitron : it's just a normal operator, nothing special with it
02:22:39 <Trinitron> I always go func (x+1)
02:22:48 <Trinitron> Instead I can go func $ x+1?
02:23:04 <ski> yes (but you shouldn't unless it becomed more readable)
02:23:09 <Trinitron> Which parses as func (x+1).
02:23:12 <Trinitron> OK.
02:23:14 <Trinitron> Cool thanks :D
02:23:24 <Trinitron> I'm learning more and more...
02:23:26 <int-e> @type tabulate
02:23:28 <lambdabot> forall i e. (Ix i) => (i, i) -> (i -> e) -> Array i e
02:23:52 <ski> int-e : i snarfed the name from SML or O'Caml .. it's often handy
02:23:58 <int-e> @type \bds f -> fix (tabulate bds f)
02:23:59 <lambdabot>     Couldn't match expected type `a -> a'
02:23:59 <lambdabot>            against inferred type `Array i e'
02:23:59 <lambdabot>     In the first argument of `fix', namely `(tabulate bds f)'
02:24:02 <Trinitron> http://www.haskell.com
02:24:03 <systemfault> I have so much to learn.. damn :)
02:25:03 <int-e> @type \bds f -> fix (\n -> tabulate bds f ! n)
02:25:04 <lambdabot> forall e. (Ix e) => (e, e) -> (e -> e) -> e
02:26:01 <int-e> ski: interesting. I used 'populate' [a lookup table] and 'lookup' so far.
02:26:21 <ski> how do you mean ?
02:26:47 <int-e> It's just about the vocabulary, 'populate' vs. 'tabulate'.
02:26:59 <ski> ok
02:27:08 <ski> i think of it as an "array lambda"
02:29:05 * ski just checked .. SML calls it `tabulate' and O'Caml calls it `init'
02:29:09 * hackagebot HTF 0.3.3 - The Haskell Test Framework  http://hackage.haskell.org/package/HTF-0.3.3 (StefanWehr)
02:29:31 <ski> (the former obviously appeared better to use in Haskell)
02:29:46 <Saizan> btw, this is all quite a waste to memoize a single run of fib, if it wasn't mentioned before
02:30:16 <ski> (int-e : or would the type of your `populate' be different that the type of `tabulate' ?)
02:30:22 <ski> sure
02:30:41 <ski> @type fixTabulate'
02:30:42 <lambdabot> forall i e. (Ix i) => (i, i) -> ((i -> e) -> i -> e) -> Array i e
02:31:48 <ski> (or simply bind the returned `i -> e' function, so as to reuse it)
02:35:01 <int-e> ski: the type of populate was MemoTrie t i => (i -> e) -> t e, so it's slightly different. The purpose is exactly the same.
02:35:17 <cads> Hmm, this is wierd
02:35:30 <cads> > sum [1..1000000]
02:35:31 <lambdabot>   * Exception: stack overflow
02:35:37 <ski> that counts as same enough, for me :)
02:35:48 <Saizan> > foldl' (+) 0 [1..1000000]
02:35:49 <lambdabot>   500000500000
02:35:54 <ski> another variant is to do like
02:36:25 <cads> >foldl (+) 0 [1..1000000]
02:36:53 <ski>   memo ((0,0),(100,100)) -> pal = \(x,y) -> ...(max (pal (x+1,y)) (pal (x,y+1)))...
02:37:08 <ski> where you tie your knot yourself
02:37:19 <Saizan> cads: sum is defined with foldl in the haskell report, there are some RULES to make it foldl' for some types, but they only fire when you compile with optimizations
02:38:29 <cads> > let sum (a:as) b = sum as (a+b); sum [] b = b in sum [1000000] 0
02:38:29 <lambdabot>   1000000
02:38:33 <ski> Trinitron : did you get something working ?
02:38:36 <cads> ah dang
02:38:42 <cads> > let sum (a:as) b = sum as (a+b); sum [] b = b in sum [1..1000000] 0
02:38:44 <lambdabot>   * Exception: stack overflow
02:39:22 <cads> saizan, I don't understand - that definition was tail recursive, where does the stack enter in this?
02:40:20 <int-e> cads: maybe this helps: sum terminates successfully. the stack overflow happens when the huge term (1+2+3+4+5+6+7...+1000000) is evaluated.
02:40:22 <Axman6> you're still building up a large thunk in the addition. force the b argument
02:40:43 <ski> > let sum as = sumAdd as 0 where sumAdd (a:as) b = b `seq` sumAdd as (a+b); sumAdd [] b = b in sum [1..1000000]
02:40:45 <lambdabot>   500000500000
02:41:43 * ski is amused that that is now no longer "textually" tail-recursive
02:41:56 <int-e> cads: because to evaluate ((...)+1000000) you first have to evaluate the (...) part. And the information about the pending addition is stored on the stack.
02:42:02 <ski> (hm, s/textually/literally/ ?)
02:42:29 <cads> int-e,hmm, I wasn't thinking that the term was getting built up
02:43:42 <int-e> cads: it should be noted that this is specific to how ghc (or the (spineless, tagless) G-machine) evaluates this expression.
02:45:09 <cads> > let sum (a:as) b = seq b $ sum as (a+b); sum [] b = b in sum [1..1000000] 0
02:45:11 <lambdabot>   500000500000
02:45:26 <int-e> ski: luckily, seq is lazy in its second argument :)
02:45:45 <int-e> err.
02:46:06 <int-e> I need a different term ...
02:47:48 <cads> so this seq takes the argument (a1 + 0) and turns it into a1 so that the next steps don't turn it into ((..((a1+0) + a2).....) + an).
02:47:54 <int-e> That remark was wrong, I need to think on what I really meant. Which is about the fact that seq does not create any 'pending' operations after evaluating a, because the second argument is returned directly.
02:48:35 <cads> it says in the referecne that seq a b  evaluates a to 'head normal form' and then returns b.
02:49:07 <Trinitron> ski, I'm giving it a rest at the moment.
02:49:16 <Trinitron> I'm chatting in Chinese in #ubuntu-cn
02:49:18 <Trinitron> :D
02:49:25 <ski> ok, no worries
02:49:34 <int-e> cads: yes, that's what it does.
02:49:45 <Trinitron> I'm a mega noob at Haskell
02:49:46 <Trinitron> .
02:52:59 * ski should probably look into some time how the spinless tagless G-machine works in detail ..
02:55:03 <cads> lear is nano-semantics :)
02:55:30 * hackagebot DPM 0.1.0 - Darcs Patch Manager  http://hackage.haskell.org/package/DPM-0.1.0 (StefanWehr)
02:55:57 <Peaker> how come \ is valid as rhs of infix operators, but not as a normal argument for application?
02:56:43 <Peaker> forM_ [1..10] \i -> .....    could have been slightly nicer
02:59:14 <carpdiem> quit
03:03:13 <carpdiem> i have a quick question about constructing infinite lists by passing them to themselves
03:03:58 <Saizan> ask :)
03:04:03 <carpdiem> i'm trying to get this infinite list of prime numbers to work, but it keeps timing out, and i'm not sure why it gets caught in an infinite loop
03:04:19 <ski> describe it or paste it ?
03:04:23 <carpdiem> primes = 2 : [x | x <- [3 ..], all (\p -> (gcd x p) == 1) primes]
03:04:59 <ski> `all' is trying to check the whole list, before you know all elements
03:05:16 <ski> also, `all' will never give `True' on an infinite list
03:05:21 <carpdiem> ahh
03:05:23 <Saizan> Peaker: idk, maybe some obscure corner of the grammar is getting in the way, but e.g. Agda allows that
03:05:36 <carpdiem> what's the best way to just check the existing elements of the list?
03:06:53 <Saizan> there's no way to tell which elements are "existing" (assuming that's well defined)
03:07:17 <ski> hm, i suppose one way is just checking with a prefix of the list .. the question then being how to determine which prefix
03:07:18 <Saizan> but you know you can check only the primes less that the square root of x
03:07:36 <ski> hm .. that could work
03:08:12 <carpdiem> @saizan - would that just involve putting another guard on the list comprehension?
03:08:12 <lambdabot> Unknown command, try @list
03:08:25 <ski> carpdiem : no
03:08:38 <ski> it would involve to passing all of `primes' to `all'
03:08:51 <ski> s/to passing/not passing/
03:09:19 <Saizan> > let primes = 2 : [x | x <- [3 ..], all (\p -> (gcd x p) == 1) $ takeWhile (\p -> p * p <= x) primes] in primes
03:09:20 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
03:09:45 <carpdiem> ahh
03:10:16 <carpdiem> i see now
03:10:18 <ski> carpdiem : btw, `(gcd x p) == 1' is simpler written as `gcd x p == 1' .. also, if you want, you could rewrite `\p -> ...' into `(1 ==) . gcd x'
03:10:18 <carpdiem> thanks!
03:11:02 <carpdiem> @ski - thanks for the tips!
03:11:02 <lambdabot> Maybe you meant: ask src wiki
03:11:08 <carpdiem> that's neat
03:13:22 <Peaker> has anyone here used graphics-drawingcombinators?
03:14:13 <ski> carpdiem : just fyi, `@' isn't typically used on IRC to attribute. the convention is to say `ski: ...' or `ski, ...' or something similar
03:15:30 <Peaker> I'm composing a rectangle + some text -- and when clearRender'ing it, I see the redraw of the rectangle and the text separately.. even though I'm using double buffering
03:16:01 <Axman6> ski: he left before you said that :(
03:17:52 <ski> :(
03:29:34 <cads> > let primes = 2 : [x | x <- [3 ..], all (\p -> mod x p /= 0) $ takeWhile (\p -> p * p <= x) primes] in primes
03:29:35 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
03:29:51 <cads> @src gcd
03:29:51 <lambdabot> gcd 0 0 = error "Prelude.gcd: gcd 0 0 is undefined"
03:29:51 <lambdabot> gcd x y = gcd' (abs x) (abs y)
03:29:51 <lambdabot>    where gcd' a 0  =  a
03:29:51 <lambdabot>          gcd' a b  =  gcd' b (a `rem` b)
03:30:02 <cads> @scr mod
03:30:02 <lambdabot> Maybe you meant: arr rc src
03:30:15 <cads> @src mod
03:30:15 <lambdabot> Source not found. I am sorry.
03:31:06 <cads> Is there a simple way to set up a timing test from inside ghci?
03:31:44 <Axman6> cads: mod = snd . divMod
03:31:44 <cads> > let primes = 2 : [x | x <- [3 ..], all (\p -> mod x p /= 0) $ takeWhile (\p -> p * p <= x) primes] in drop 10000 primes
03:31:47 <lambdabot>   [104743,104759,104761,104773,104779,104789,104801,104803,104827,104831,1048...
03:32:17 <cads> Axman6, :) how'd you look it up?
03:32:26 <Axman6> just remember it
03:32:56 <Axman6> it's something like that anyway (which it's usually a good idea to use divMod if you need to say find all the factors of a number)
03:39:37 <TacticalGrace> ivanm: I replied on the list
03:45:38 <Peaker> Found a bug in drawing combinators while trying to find a minimal example to reproduce it
03:46:43 <Peaker> apparently (FTGL.setFontFaceSize font 72 72 >> FTGL.getFontAdvance font str) is not so pure. unsafePerformIO on this somehow causes OpenGL to flicker
03:49:34 <Axman6> TacticalGrace: hooray :)
03:54:10 <ivanm> TacticalGrace: \o/
03:56:32 <Axman6> ivanm: ok, so... we're calling it AusHac2010, unless you can think of something more appropriate
03:56:53 <ivanm> Axman6: you don't like OzHackathon? :(
03:56:58 <ivanm> Axman6: got a wiki page or want me to do it?
03:57:05 <Axman6> i'm about to do it
03:57:09 <ivanm> (assuming, of course, I can work out how to make a new page)
03:57:15 <ivanm> k
03:57:21 <FliPPeh__> Is there a standard prelude function that repeatedly applies functions on something and returns the last result?
03:57:26 <Axman6> i was going to reply to TacticalGrace's email, and announce the page in that
03:57:50 <FliPPeh__> E.G. fseq reverse 3 [1,2,3] == reverse . reverse . reverse $ [1,2,3]
03:58:01 <ivanm> Axman6: for now, I think we should possibly just get people to list their names along with available weekends in that period, and then make a project section where people can nominate projects and put their names down
03:58:03 <ivanm> Axman6: works for me
03:58:12 <ClaudiusMaximus> > iterate (+1) 0 !! 42
03:58:13 <lambdabot>   42
03:58:27 <ivanm> yeah, iterate is probably your best bet
03:58:36 <ivanm> there's no "inline" version
03:58:45 <FliPPeh__> :)
03:58:46 <FliPPeh__> Thanks!
03:59:41 <ivanm> Axman6: don't forget to add a link from the general Hackathon page
03:59:49 <Axman6> ok
03:59:55 <ivanm> hmmm... HacDownUnder ? :p
04:00:15 <zygoloid> church numerals? 3 reverse [1,2,3] ;-)
04:00:56 <ivanm> zygoloid: yeah, but it's not inbuilt
04:01:07 <ivanm> and FliPPeh__ was after a "standard prelude function"
04:01:52 <ivanm> hmmm.... is a "non standard prelude function" a prelude function that isn't standard (in which case where is it) or a a function from a non-standard prelude? :p
04:03:14 <FliPPeh__> Yay
04:03:22 <FliPPeh__> iterate works fine with my bubbleSort implementation
04:05:20 * ivanm notices that we have a Time Lord in our midst...
04:05:41 <FliPPeh__> Or not... hmmm
04:05:53 <ivanm> FliPPeh__: best bet: you're doing it wrong
04:05:56 <FliPPeh__> "cannot construct infinite type: a = [a]"
04:06:07 <FliPPeh__>  21 bubbleSort :: (Ord a) => [a] -> [a] 22 bubbleSort l = take (length l) $ iterate bubble l
04:06:09 <ivanm> if you're trying to do a sort algorithm, then you shouldn't want to iterate it an arbitrary number of times
04:06:17 <ivanm> *shudder* that's atrocious
04:06:19 <Taejo> :t runState
04:06:21 <lambdabot> forall s a. State s a -> s -> (a, s)
04:06:29 <ivanm> FliPPeh__: standard bubble sort: use a parameter to tell if you've done any swaps
04:06:36 <ivanm> keep running it until that parameter is False
04:06:47 <FliPPeh__> :/
04:09:34 <FliPPeh__> http://www.codecodex.com/wiki/index.php?title=Bubble_sort#Haskell
04:09:43 <FliPPeh__> This one's doing it like I did
04:14:48 <FliPPeh__> @src iterate
04:14:49 <lambdabot> iterate f x =  x : iterate f (f x)
04:16:31 <Taejo> @pl iterate f x =  x : iterate f (f x)
04:16:32 <lambdabot> iterate = fix ((ap (:) .) . ((.) =<<))
04:16:54 <rajeshsr> what is @pl?
04:17:11 <Taejo> it translates functions into pointfree form
04:18:01 <FliPPeh__> @pl hello name = "Hello, " ++ name
04:18:01 <lambdabot> hello = ("Hello, " ++)
04:18:03 <FliPPeh__> Like this
04:18:26 <Taejo> @pl \x y z -> x*y+z
04:18:27 <lambdabot> ((+) .) . (*)
04:19:08 <Taejo> @pl flip2 f x y z = f x z y
04:19:08 <lambdabot> flip2 = (flip .)
04:20:43 <Peaker> Does anyone here know FTGL/OpenGL well?  Any idea why unsafePerformIO over FTGL.setFontFaceSize and FTGL.getFontAdvance   is wrong?
04:21:00 <Peaker> does FTGL touch OpenGL parameters?
04:21:17 <rajeshsr> Taejo, hmm! it doesn't give any understanding? does it? why care about point free form?
04:21:55 <Taejo> sometimes pointfree form is clearer because it doesn't introduce unnecessary names
04:22:05 <Peaker> GLUT/OpenGL/FTGL is so much more work than SDL :-(
04:22:10 <Taejo> but a lot of the time @pl gives ridiculously complex results
04:22:17 <Peaker> Unfortunately, SDL apparently doesn't work very well on OSX
04:22:31 <rajeshsr> Taejo, hmm, ok! thanks
04:22:39 <Taejo> http://haskell.org/haskellwiki/Pointfree
04:22:40 <Peaker> Taejo: A lot of times @pl produces complex results, while there is a very simple&concise point-free form
04:22:58 <Taejo> Peaker: I have noticed that
04:23:20 <Peaker> @pl is not aware of all the point-free combinators, not aware of SECs, etc.
04:23:20 <lambdabot> (line 1, column 47):
04:23:20 <lambdabot> unexpected ","
04:23:20 <lambdabot> expecting variable, "(", operator, "+", "-" or end of input
04:23:28 <Taejo> SECs?
04:23:32 <Peaker> @where SEC
04:23:32 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
04:23:40 <Taejo> oh, right
04:24:04 <zygoloid> @pl \f g h x y -> f (g x y) (h y)
04:24:05 <lambdabot> ((flip . (ap .)) .) . (.) . (.)
04:24:23 <Taejo> @pl \(x,y) -> (x, f y)
04:24:24 <lambdabot> second f
04:24:36 <zygoloid> @pl \f g x -> f x (g x)
04:24:36 <lambdabot> ap
04:24:40 <Peaker> Before knowing SEC, I had a real problem with FP (seemed really difficult/cumbersome to update nested things)
04:25:14 <zygoloid> Peaker: it still is, if those things are reachable through multiple paths
04:25:28 <Peaker> Before knowing MaybeT/EitherT/ContT I had a problem with imperative programming in Haskell, too -- inability to break out of loops
04:25:57 <Peaker> zygoloid: if you want to have multiple references to the "same" thing, just use a reference scheme
04:26:03 <Peaker> (keys/indices)
04:26:30 <zygoloid> Peaker: "just" makes it sound like that's trivial, and doesn't give up large amounts of clarity and simplicity
04:26:38 <Peaker> I can easily see how beginners - not knowing SECs, these transformers, and even struggling with monads, dismiss Haskell for being too "hard" or "cumbersome"
04:27:04 <Peaker> zygoloid: I haven't yet encountered that difficulty myself..
04:27:26 <zygoloid> Peaker: i'm hitting up against it in my representation of SSA form.
04:27:34 <Peaker> zygoloid: I imagine it wouldn't be that hard to write data.accessors that can see through references
04:28:11 <zygoloid> the simplicity of some of the core code is masked by calling various things to fiddle with maps
04:28:31 <Peaker> zygoloid: paste?
04:28:57 * twink never noticed SEC's being important
04:29:10 <zygoloid> at work at the moment, and my code is at home, sorry. i can try to remember to paste it tonight and get back to you tomorrow :)
04:29:31 <zygoloid> i'm pretty sure there's a way of rearranging it to make it beautiful but i've not found it yet :(
04:29:38 <opqdonut> i've been aware of SEC's but have never had any real use for them
04:29:48 <Taejo> twink: well, I use (.), map, first and second all the time, but I don't think of them as SECs
04:30:11 <Peaker> opqdonut: (fmap . fmap ...)
04:30:19 <zygoloid> Taejo: imo using first and fmap alone isn't SEC, but (first . fmap . second) is
04:30:41 <zygoloid> (that is, it's using them as composable combinators which makes it SEC IMO)
04:30:42 <Peaker> I've often used lens/accessors too, which I've discovered after SEC, and I place in the same category :)
04:31:02 <Peaker> The "naive" way to update nested fields in Haskell is pretty cumbersome/annoying
04:31:19 <zygoloid> record syntax doesn't help, too...
04:31:32 <dobblego> what's the naive way if not record syntax?
04:31:47 <Taejo> zygoloid: it's FP, I *expect* things to be composable :)
04:32:09 <Peaker> \container -> container{blah = blah container { wow = sucks (wow (blah container)) }}
04:32:27 <Peaker> (atBlah . atWow) sucks
04:32:49 <Peaker> dobblego: record syntax is the naive way - and it sucks
04:32:56 <dobblego> ok
04:33:17 <Younder> Are there any good LR parsers around?
04:33:41 <Younder> googeling got me exacty nothing
04:33:56 * twink remembers happy
04:34:23 <zygoloid> \x -> map (\(y,zs) -> (y, map ?f zs)) (?g x)
04:34:27 <zygoloid> (fmap . second . fmap) ?f ?g
04:34:39 <zygoloid> s/?// :)
04:34:48 <Younder> Twey, thx
04:35:04 <Younder> Twink, thx
04:39:09 * twink hasn't felt much need to update nested fields in a non-naive way
04:39:29 <FliPPeh__> Tehe, wikileaks.
04:42:25 <eevar2> what's the complexity of Data.List.sortBy ?
04:42:45 <ksf> mergesort
04:43:11 <ksf> that is, n log n and stable
04:43:15 <scotty> hello
04:43:40 <ksf> that's best, worse and average unlike quicksort, which has worst-case n^2
04:43:42 <eevar2> ksf: oki, thanks
04:43:56 <psykotic> quicksort: untrue.
04:44:04 <scotty> has anyone here messed with hopengl before?
04:44:12 <psykotic> the quickmedian finds a median in worst-case O(n) time.
04:44:21 <psykotic> if you use that for pivot selection, it's worst case n log n
04:44:42 <ksf> still, it isn't stable
04:44:50 <ksf> ...and relies on destructive updates
04:44:53 <psykotic> that can always be achieved
04:45:02 <psykotic> for stability, zip with [1..]
04:45:06 <psykotic> unzip after the fact
04:45:23 <psykotic> anyway, yes, it's not stable inherently
04:45:24 <Younder> I can't get cabal installed. I need network?
04:45:37 <ksf> you have network.
04:45:46 <psykotic> it's arguably whether it relies on destructive updates. there is a natural implementation using zippers.
04:45:50 <Younder> I kow that
04:45:51 <ksf> or I'm being imaginary, again.
04:46:15 <ksf> the bootstrap script downloads dependencies, iirc.
04:46:42 <ksf> and to use cabal you either need network or the package index and a lot of tgzs on your system
04:47:15 <xerox> > snd . M.findMax . M.fromList . zip [1..] $ [2,3,5,2,1,2,3,4,3,2,2]
04:47:15 <Younder> ubuntu... isn't that the platform of our founding father Simom P. Jones
04:47:16 <lambdabot>   2
04:47:42 <ksf> I'd assume he has a decent distro taste.
04:48:08 <Younder> ksf: he uses ubuntu
04:48:09 <bremner_> backtrack!
04:48:28 <ksf> well, the british hold the standard for bad taste after all, it seems.
04:49:01 <Jafet> ...the distro that mangles ghc distribution the worst
04:49:23 <Younder> Jafet, I've noticed
04:49:28 <benmachine> well, you don't *have* to go via your package manager
04:49:42 <ivanm> dobblego: you around?
04:49:48 <dobblego> yes
04:49:57 * ksf only installs ghc and xmonad via portage
04:49:58 <Younder> ben, ource installation is next yes
04:50:05 <Jafet> cabal is my package manager
04:50:19 <Alpounet> ha
04:50:25 <Alpounet> ivanm will get angry
04:50:27 <dobblego> ivanm, ?
04:50:37 <ivanm> even if you're not going to be able to make it to any proposed hackathon, would you be able to forward the wiki-page organisational email about it that Axman6 is about to send to the BFPG list?
04:50:39 <benmachine> Younder: you can download binary packages from the website
04:50:41 <ksf> ...I don't want to end up using twm in case I nuke ~/.cabal
04:50:47 <ivanm> (since I quit and thus can't send emails to it anymore :s)
04:50:47 <dobblego> ivanm, yes np
04:50:51 <ivanm> @slap Jafet
04:50:51 * lambdabot will count to five...
04:50:54 <ivanm> Alpounet: :D
04:50:56 <ivanm> dobblego: ta
04:50:56 * Jafet ducks
04:51:02 * hackagebot polyseq 0.1.2 - Taming Selective Strictness  http://hackage.haskell.org/package/polyseq-0.1.2 (DanielSeidel)
04:51:06 <dobblego> ivanm, got the link handy?
04:51:21 <Axman6> dobblego: working on it at the moment :)
04:51:30 <dobblego> ok, pm me when you're done
04:52:23 <ivanm> dobblego: if they have any specific queries about it, let them know they can email me (since some of them might recall who I am >_>)
04:52:30 <dobblego> ok
05:00:21 <Younder> Is Simon around?
05:00:30 <ivanm> Younder: which one? :p
05:02:08 <Younder> The one who contributed to writing GHC. (the Cambrige member of Microsoft Research) that one
05:02:22 <zygoloid> Simon Peyton Jones or Simon Marlow?
05:02:26 <mauke> which one?
05:03:03 <Younder> zygoloid, the first
05:03:04 <FliPPeh__> Why is there no XML package that allows XML documents to be built like Text.Xhtml?
05:03:23 <FliPPeh__> elem "Root" << elem "About" << cdata "Blah"
05:03:29 <zygoloid> preflex: seen simonpj
05:03:29 <preflex>  Sorry, I haven't seen simonpj
05:03:35 <FliPPeh__> I think I should because awesome in Haskell just to do that
05:04:36 <Axman6> Younder: they are both the main developers of GHC
05:04:51 <Younder> Axman6, so I figured
05:07:59 <Axman6> dobblego: http://www.haskell.org/haskellwiki/AusHac2010 if you're interested :)
05:08:15 <dobblego> ta
05:08:47 <Axman6> you planning on comming? or wil, you still be OS?
05:09:20 <dobblego> I am unwell
05:09:32 <Axman6> :(
05:10:57 <dobblego> I may be well by then though
05:11:58 <Younder> ivanm, well I have 3 Phd's (physics, mathematics, Computer Science), I am vary lazy and rely mostly on other peoples work (as do you)
05:12:18 <Younder> lol
05:14:45 <Younder> oddly I never learnes how to spell s/vary/very/
05:14:54 <Younder> learned
05:15:09 <Younder> rotfl
05:15:14 <Axman6> dobblego: i hope so :)
05:15:17 <Phyx-> Hello
05:15:53 <Phyx-> Does anyone know a way to for instance, given a string with a type convert it to some undefined value with the same type?
05:16:50 <Taejo> Phyx-: you mean you want to convert "Int" to (undefined :: Int) ?
05:17:03 <ivanm> Younder: just starting my PhD, and I do _some_ work...
05:17:07 <Phyx-> Taejo: yeah
05:17:15 <Saizan> Phyx-: use hint
05:17:15 <Axman6> ivanm: quit lying
05:17:38 <Phyx-> Saizan: thanks :), i'll look it up
05:17:39 <ivanm> Axman6: haskell work, not PhD work ;-)
05:17:46 <Axman6> :P
05:17:56 <Taejo> Phyx-: since types are known at compile time, it doesn't seem to be possible without hackery
05:18:00 <Axman6> ivanm: has the email shown up?
05:18:19 <Saizan> Taejo: unless you have a compiler in your program!
05:18:36 <ivanm> Axman6: yup
05:18:37 <Phyx-> Taejo: yeah I know, but since I have to know the size of "any" type I must do this :(
05:18:41 <Axman6> hooray :)
05:18:48 <Saizan> (which is what hint does)
05:18:57 <Phyx-> @package hint
05:18:57 <lambdabot> http://hackage.haskell.org/package/hint
05:19:02 <Axman6> that means it's time to sleep. night people
05:19:03 <Taejo> Saizan: right, but then it's not really a type in your program, it's a value
05:19:08 <Younder> OK, I will be offline for a while. I am replcaing my power supply.. later
05:19:09 <Saizan> Phyx-: but you also need Storable for that
05:20:05 <Phyx-> Saizan: yeah, if the program has gotten this far, So it would have been correct to say I want to support "any" value that's a storable instance
05:20:50 <Saizan> Phyx-: the more proper way would be to accept an existential which wraps the Storable context, rather than a String
05:21:52 <Phyx-> Saizan: unfortunately strings is all I have, I'm reading Haskell files and creating among others an export table for when you compile a shared lib on windows, and when using __stdcall I need the sizes of the arguments
05:22:19 <Taejo> Phyx-: hint is probably what you need
05:23:03 <Phyx-> Taejo: yeah, I'm looking at it now :)
05:24:10 <ivanm> preflex: seen blackdog_
05:24:10 <preflex>  blackdog_ was last seen on #haskell 53 days, 11 hours, 15 minutes and 1 second ago, saying: because of all the new dynamic library stuff
05:24:13 <ivanm> preflex: seen blackdog
05:24:13 <preflex>  blackdog was last seen on #haskell 11 hours, 35 minutes and 13 seconds ago, saying: are there any tools for managing separate ghc instances, like rvm for ruby?
05:24:21 <ivanm> blackdog_: you actually here?
05:27:01 * ivanm figures he should hit the sack around now...
05:27:17 <dobblego> same, but I'm high
05:28:53 <ivanm> you popping pills or something?
05:28:59 <dobblego> yes
05:29:11 <dobblego> prescribed pills
05:29:19 <ivanm> well, yes, I figured that
05:29:30 <ivanm> or else maximum strength non-prescription pain killers or the like
05:29:33 <dobblego> which are illegal in Singapore :(
05:31:07 * benmachine wonders if there is a market for homeopathic heroin
05:33:42 <koala_man> where does 'push' and 'closure' come from in this grapefruit example? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24066
05:36:52 <dobblego> where's the example from?
05:38:13 <MaciejP> koala_man: Aren't these not just variables?
05:41:00 <koala_man> dobblego: grapefruit-examples
05:42:00 <dobblego> load it into ghci and type :info closure
05:42:22 <koala_man> Top level: Not in scope: `closure'
05:42:51 <koala_man> but it compiles fine
05:43:03 <benmachine> I think MaciejP is right, they are pattern variables
05:43:08 <benmachine> they are bound by that expression
05:43:19 <benmachine> or rather, by the <- that follows them
05:43:30 <dobblego> ah so they are
05:43:53 <dobblego> closure appears to the left of <- modulo formatting
05:45:00 <koala_man> how about 'push'?
05:45:08 <benmachine> same
05:47:29 <koala_man> ah, in 'text'
05:50:07 <pokoko222> someone uses haskell for probability and statistics applications?
05:50:30 <Alpounet> I guess so
05:50:37 <Alpounet> moreover, there are some packages for that on hackage
05:59:14 <dantheman_> ?
06:06:59 <Alpounet> anyone ever played with http://hackage.haskell.org/packages/archive/fad/1.0/doc/html/Numeric-FAD.html ?
06:09:20 <dantheman_> Hey all, I have a question re creating nested structs for use with the ffi: e.g. http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=24068#a24068
06:09:27 <dantheman_> Is this possible?
06:10:31 <danderson> dantheman_: sounds possible. Alloc and serialize the inner struct, then stuff the Ptr into the outer struct
06:10:47 <dantheman_> e.g. can I create some kind of data type : data Top = MkTop CString CString Inner
06:11:00 <danderson> I don't have the hsc2hs incantations on hand, but I don't see why it wouldn't work.
06:11:05 <dantheman_> ah cool
06:11:07 <dantheman_> Thanks
06:11:22 <dantheman_> Just wanted to make sure there's no obvious reason for why it wouldn't work
06:12:02 <danderson> keep in mind I'm no FFI expert, but having written a reasonably non-trivial FFI, I don't see why it would be impossible
06:12:40 <danderson> dantheman_: see http://bitbucket.org/danderson/tunskell/src/tip/Tunskell/Local/Tun.hsc if you need an example of hsc2hs FFI code. It doesn't do nested structs, but it may give you a few pointers if you're new to FFI-ing
06:13:07 <benmachine> dantheman_: p.s. given that the FFI is to C and not C++, wouldn't that need to be struct inner *c;?
06:13:32 <poucet> danderson: random comments on your code?
06:13:32 <benmachine> it probably doesn't matter, just a thought
06:13:54 <dantheman_> Ya you're probably right, I just threw that up quickly!
06:14:05 <benmachine> k
06:14:26 <danderson> poucet: if you want, always open to suggestions
06:14:43 <dantheman_> The reason I was worried it might not be possible is due to a comment at the end of a section on structs in the haskell ffi cookbook
06:15:17 <dantheman_> Where it says:
06:15:19 <dantheman_> Unfortunately for the "struct { char *c_string_field; }" style there is no good general solution because you have to worry about allocating memory to have c_string_field point to.
06:17:02 <dantheman_> Whoops sorry, link here: http://www.haskell.org/haskellwiki/FFICookBook#Working_with_structs
06:18:45 <danderson> dantheman_: right, if you take a look at the code I linked, I ran into exactly that problem
06:19:06 <danderson> well, almost exactly. I had to do a bit of dancing with #ptr and memcpy's to fill in the struct correctly
06:19:35 <dantheman_> Ah right, but you managed to get round it?
06:27:34 * hackagebot graphics-drawingcombinators 1.2.2 - A functional interface to 2D drawing in OpenGL  http://hackage.haskell.org/package/graphics-drawingcombinators-1.2.2 (LukePalmer)
06:51:24 <FliPPeh__> http://codepad.org/MUjG0AUe
06:51:33 <FliPPeh__> Does #haskell like my haskell-fu? ;x
06:51:45 <FliPPeh__> I somehow think this code is unclean
06:51:51 <FliPPeh__> But I can't see why
06:52:01 <FliPPeh__> Except for "displayController"
06:54:01 <aavogt> FliPPeh__: this is purely stylistic, but do you know the function `maybe'?
06:55:24 <aavogt> oh, you use it elsewhere
07:00:55 <FliPPeh__> aavogt: Yep :)
07:01:13 <FliPPeh__> I just wanted a clear separation in those functions
07:26:22 <Desustorm> is there a way to concatenate lists in haskell? (like [1..5]:[6..7])
07:26:27 <ben> ++
07:26:32 <Desustorm> ah
07:26:33 <Desustorm> haha
07:26:34 <Desustorm> thanks
07:26:49 <ben> > [1..5] ++ [6..7]
07:26:49 <Desustorm> long day =)
07:26:50 <lambdabot>   [1,2,3,4,5,6,7]
07:27:14 <mreh> I need some Yampa signal functions to inherit a basic behaviour
07:28:01 <mreh> everything in my Yampa universe moves around a 2D space, and when they go off the edge of the screen, they teleport back to the other side
07:28:11 <dcoutts> tibbe: is anyone meeting up on Thursday evening btw? I'll be arriving ~8pm
07:28:12 <lambdabot> dcoutts: You have 2 new messages. '/msg lambdabot @messages' to read them.
07:28:20 <tibbe> dcoutts: I am
07:28:28 <tibbe> dcoutts: I think dons should be in by then
07:28:35 <mreh> I can't just do that in the graphics library because it messes with the collision detection
07:29:17 <dcoutts> tibbe: great, we should organise something. I'm sans mobile phone, but I expect I'll get on IRC from my hostel and I can call you.
07:29:46 <mreh> do you wish to be more like the great prophet Richard Stallman?
07:30:42 <dcoutts> mreh: were you talking to me?
07:30:50 <mreh> dcoutts: yes :)
07:31:04 <dcoutts> heh, I don't have the beard to be a great prophet
07:31:50 <tibbe> dcoutts: you can reach me at +41 78 79 78 230
07:32:11 <tibbe> dcoutts: were are you staying?
07:32:17 <byorgey> dcoutts: you have the hair though!
07:32:53 <mreh> the perfect place to conceal a tracking device
07:32:58 <mreh> cut it off!!
07:34:30 <mreh> do we have positive integers in haskell?
07:34:34 <tibbe> dcoutts: where/when do you want to meet?
07:34:39 <benmachine> > 2
07:34:40 <lambdabot>   2
07:34:46 <mreh> > minBound :: Word32
07:34:48 <benmachine> looks like it, mreh
07:34:48 <lambdabot>   0
07:34:56 <mreh> a positive integer class :)
07:35:07 <Jafet> You don't want zeroes?!
07:35:19 <mreh> zeros are acceptable
07:35:29 <benmachine> > negate 3 :: Word32
07:35:30 <lambdabot>   4294967293
07:35:33 <benmachine> hmm
07:35:46 <mreh> that doesn't make sense
07:35:56 <mreh> you can't negate a Word32
07:36:05 <benmachine> it makes sense in a perverse way
07:36:08 <mreh> that's twos complement as a straight binary number
07:36:11 <benmachine> > 4 + negate 3 :: Word32
07:36:13 <lambdabot>   1
07:36:34 <tibbe> dcoutts: I need to run and interview a candidate in a few mins
07:36:35 <mreh> > 4 + (negate 3 :: Word 32)
07:36:36 <Desustorm> hmm i'm getting some quite strange output when I'm running my haskell function
07:36:37 <lambdabot>   Only unit numeric type pattern is valid
07:36:39 <benmachine> actually
07:36:41 <tibbe> I should be online again at 5pm
07:36:45 <benmachine> that makes perfect sense
07:36:50 <benmachine> it's just modular arithmetic
07:36:52 <Ferdirand> > (negate 3) + 3 :: Word32
07:36:53 <lambdabot>   0
07:36:59 <Ferdirand> that is negation by definition :)
07:37:12 <mreh> that's coercion
07:37:16 <Desustorm> it should be outputting an [[a]] and all it's printing to the console is [
07:37:17 <benmachine> so it makes a ring, so Num is happy with it
07:37:18 <Desustorm> >_>
07:37:30 <benmachine> mreh: no, the type signature is forcing all the terms to be Word32
07:37:31 <mreh> you're doing the negation in Integer or Int
07:37:38 <mreh> hmm
07:37:42 <benmachine> because + preserves types and so does negate
07:37:47 <ketil> Desustorm: does it terminate?
07:37:50 <Desustorm> no
07:37:53 <benmachine> you can do it the long way if you like, you'll get exactly the same thing
07:37:54 <marcuy> !ping
07:38:00 * mreh no like
07:38:04 <marcuy> !ping benmachine
07:38:10 <ketil> > let x = (x+1) in [x]
07:38:15 <lambdabot>   mueval-core: Time limit exceeded
07:38:21 <benmachine> I am not pinged
07:38:29 <marcuy> ok
07:38:44 <ketil> hmm... no partial output here, I guess.  But that should do the same, I think.
07:38:45 <Jafet> > let x = (x+1) in x > 3
07:38:48 <Desustorm> ketil, does it mean i'm stuck in an infinite loop or something?
07:38:49 <lambdabot>   mueval-core: Time limit exceeded
07:39:51 <ketil> Desustorm, exactly.  Haskell evaluates your value, and prints [ as the constructor is (:) - i.e. it knows it is a list.
07:40:13 <ketil> ..but calculating the first element of the list loops, so it never progresses beyond that.
07:40:22 <Desustorm> Blah.
07:40:29 <Saizan> > take 1 $ show (undefined :: [Int])
07:40:30 <lambdabot>   "* Exception: Prelude.undefined
07:40:38 <Saizan> > take 1 $ (undefined :: [Int])
07:40:39 <lambdabot>   * Exception: Prelude.undefined
07:40:51 <Jafet> > fix error
07:40:52 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
07:41:00 <Desustorm> recursing (take 1 (drop (const-1) [1..5])) should leave me with [] surely..?
07:41:05 <ketil> > take 1 $ show [undefined::Int]
07:41:07 <lambdabot>   "["
07:41:21 <Desustorm> (drop (const-1) pack)*
07:41:25 <Saizan> i thought it'd be lazier :)
07:41:38 <benmachine> Desustorm: it'll leave you with take 1 (drop n [])
07:41:38 <Desustorm> > drop 100 [0..89]
07:41:39 <lambdabot>   []
07:41:43 <benmachine> I guess
07:41:49 <benmachine> no
07:42:17 <Desustorm> > take 1 []
07:42:17 <lambdabot>   []
07:42:19 <benmachine> it'll leave you with iteration of take 1 . drop n
07:42:24 <benmachine> I mean
07:42:47 <Desustorm> benmachine, http://pastebin.com/xCnjCci2
07:42:58 <Desustorm> is that an infinite loop? :<
07:44:07 <benmachine> doesn't look it
07:44:27 <Saizan> maybe it's just really slow
07:44:30 <benmachine> (p.s. const is a very common function, so it might not be a good idea to call your variables const, it will confuse people)
07:44:33 <Saizan> you're left-associating (++)
07:44:57 <Saizan> Desustorm: which inputs are you using to test it?
07:45:08 <Desustorm> lemme show you the whole function
07:45:20 <Desustorm> http://pastebin.com/Ln2GXuYV
07:46:29 <benmachine> Desustorm: hmm, your style of recursion is a little inefficient
07:46:36 <benmachine> or at least, not as lazy as it could be
07:47:00 <Desustorm> :|
07:47:05 <Saizan> yeah, you're trying to be tail recursive
07:47:45 <Saizan> Desustorm: so, how do you call deal?
07:48:33 <Desustorm> Saizan, deal 3 [0..8] for now
07:50:22 <fax> hat does deal do??
07:50:45 <byorgey> Desustorm: newhand looks like an infinite loop to me when const == 1
07:51:09 <Desustorm> it's supposed to deal cards out :p
07:51:16 <fax> what do you mean
07:51:16 <byorgey> if const == 1 it calls itself recursively with   newhand const (drop (const - 1) pack) ...  = newhand 1 (drop 0 pack) ... = newhand 1 pack ...
07:51:37 <Saizan> yeah
07:51:50 <Desustorm> oh yeah! good call byorgey
07:51:51 <Desustorm> :)
07:52:01 <byorgey> are you sure you want (const - 1) ?
07:52:08 <Desustorm> um
07:52:14 <Desustorm> haha no
07:52:45 <Desustorm> shouldn't program when i'm tired -_-
07:53:35 <Desustorm> hmm okay
07:54:01 <Desustorm> doesn't exactly work like i wanted it to, but thanks for the help.. it works :)
07:55:27 <Saizan> btw recursing with an accumulator like that is something that should be avoided if your accumulator is something that can be lazily produced like a list
07:55:57 <fax> Desustrom
07:56:01 <fax> whats 'deal'?
07:56:20 <Desustorm> deal is supposed to deal out a list of whatever to x number of hands
07:56:31 <Desustorm> it doesn't work though :p
07:56:35 <Desustorm> need to rethink my approach
07:59:02 <fax> Desustorm
07:59:05 <fax> I don't undesrtand that
07:59:20 <Desustorm> fax, i have a pack of cards
07:59:29 <Desustorm> the idea is to deal them out equally
07:59:32 <fax> okay so it's like  Pack Card
07:59:38 <Desustorm> e.g.
08:00:05 <fax> equally what if these's 3 people, 3|52 doesn't
08:00:31 <Desustorm> deal 3 [1..8] should return [[1,4,7],[2,5,8],[3,6]]
08:00:36 <Desustorm> should go to the first hand
08:00:36 <fax> oh I see
08:00:52 <Desustorm> don't think i'm doing it quite right :(
08:01:00 <fax> so it's like you take the first card off and hand it to A then you take the second card and hand it to B... and so on, around the table
08:01:04 <Ferdirand> that looks like transpose
08:01:20 <Desustorm> yeah
08:01:26 <Desustorm> Ferdirand, eh?
08:02:51 <quicksilver> > let groupsOf n = takeWhile (not.null) . map (take n) . iterate (drop n) in transpose $ groupsOf 3 [1..8]
08:02:52 <lambdabot>   [[1,4,7],[2,5,8],[3,6]]
08:03:05 <Ferdirand> give a man a fish, blah blah...
08:03:07 <quicksilver> groupsOf shouuld be in the standard lib but isn't.
08:03:10 <fax> Desustorm, you can program it directly using what I said
08:03:10 <Desustorm> O.O
08:03:22 <quicksilver> criticism accepted, Ferdirand
08:03:46 <Ferdirand> it wasn't criticism, actually, i was excusing myself for not providing more detail
08:03:54 <Ferdirand> but you were faster, as always :)
08:04:41 <fax> Desustorm, let me explain it better... suppose your deck of cards are like this:  [3 of heards, 5 of clubs, king of diamonds, ace of spades]
08:04:59 <fax> Desustorm, the first thing I would do is make a function that goes over the list one by one to make this:
08:05:35 <fax> [giveTo player1 (3 of heart), giveTo player2 (5 of clubs), giveTo player3 (king of diamonds), giveTo player1 (ace of spaces)]
08:06:02 <fax> Desustorm -- because with this, you can make a function that crunches down the whole deck into 3 piles based on which cares are given to who
08:07:26 <Desustorm> fax, easier said than done for me ;-;
08:07:36 <fax> if giveTo player card is a function, then you can use 'foldr' to turn it into   giveTo player1 (3 of heart) . giveTo player2 (5 of clubs) . giveTo player3 (king of diamonds) . giveTo player1 (ace of spaces) $ []
08:07:54 <fax> oops
08:07:59 <fax> should have said $ const []
08:08:04 <luqui> if it were easier done than said, why say it?
08:08:59 <Desustorm> luqui, what?
08:09:02 <fax> so we can represent the hand of each player by a function
08:09:14 <fax> hands :: Player -> [Card]
08:09:22 <fax> so now hands 1 = player 1's cards
08:09:27 <fax> and so on..
08:10:09 <Desustorm> hmm okay
08:10:14 <fax> it's easy to give a new card to a player "giveTo",   giveTo playerX card hands = \player -> if player == playerX then card : hands playerX else hands player
08:11:12 <fax> see that giveTo :: Player -> Card -> Hands -> Hands?
08:11:22 <fax> (type Hands = Player -> [Card])
08:13:24 <Ferdirand> I still think transpose is easier to understand
08:13:34 <fax> it is
08:14:03 <fax> The reason I described this way is that it is much easier to derive in a systematic way from the specification
08:14:27 <fax> the only way to realize that this can be implemented as transpose . chunk n is tremendous amounts of experience
08:15:38 * Desustorm makes deal version 5.0 ;-;
08:20:08 * hackagebot atom 1.0.1 - A DSL for embedded hard realtime applications.  http://hackage.haskell.org/package/atom-1.0.1 (TomHawkins)
08:30:04 <tallpaul> hi folks
08:30:20 <Saizan> hi
08:30:40 <tallpaul> whats the best way to parse LET/IN statements with parsec?
08:31:54 <tallpaul> I've generated a token-parser from Text.ParserCombinators.Token, and this is not aware of newlines.
08:32:12 <tallpaul> I want to parse something like:
08:32:13 <tallpaul> LET
08:32:16 <tallpaul>   x = 1
08:32:19 <tallpaul>   y = 2
08:32:20 <tallpaul> IN
08:32:22 <tallpaul>   x
08:32:40 <tallpaul> the tricky thing is between LET and IN
08:32:52 <aavogt> matching LET with IN is just like matching parentheses
08:32:53 <fax> tall paul what about
08:32:53 <fax> LET
08:32:57 <fax>  x = 1 y = 2
08:32:58 <fax> IN ...
08:32:59 <fax> ?
08:33:28 <tallpaul> If this works, I will also accept this. But I've already problems with the above.
08:33:48 <fax> no I am asking you
08:34:02 <fax> you decide what to program then write it :P
08:34:12 <tallpaul> This is not necessary.
08:34:21 <fax> what?
08:34:24 <Saizan> the toekn parser doesn't give you newline tokens?
08:34:31 <tallpaul> LET x = 1 y = 1 IN x
08:34:34 <tallpaul> no
08:34:44 <fax> by not necessary you mean it is a syntax error?
08:34:58 <tallpaul> I've tried it with sepBy1 parseLets Char.newLine
08:35:10 <tallpaul> Yes, this should be a syntax error.
08:35:13 <fax> okay,
08:35:25 <fax> so I think you can split into two stages: Lexing and parsing
08:35:50 <tallpaul> Yes, i've taken the lexer from parsec.
08:35:53 <fax> that way you can see  x = 1 NL y = 1  differently from  x = 1 y = 1
08:36:17 <mreh> how do I lift a binary operation to two Arrows again?
08:36:42 <mreh> :t liftA2
08:36:44 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
08:36:45 <tallpaul> fax: thats clear, my question is more specific on parsec. Why is sepBy1 parseLetStmt Char.newline not working.
08:36:54 <mreh> @instances Applicative
08:36:55 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
08:37:00 <quicksilver> the Arrow class in haskell doesn't know it's applicative, mreh
08:37:04 <quicksilver> (although it is)
08:37:17 <tallpaul> The token parser i've generated with parsec is not aware of newlines.
08:37:18 <fax> sepBy1 works
08:37:30 <fax> it must be something wrong with  parseLetStmt  or  Char.newline
08:37:54 <quicksilver> fax: I think tallpaul has chosen a lexer which dsicards newline infromation?
08:38:02 <quicksilver> fax: so the newlines aren't there for his parser to use.
08:38:05 <int-e> @type pure . uncurry
08:38:06 <lambdabot> forall (f :: * -> *) a b c. (Applicative f) => (a -> b -> c) -> f ((a, b) -> c)
08:38:10 <fax> okay that's why I went into detail about newlines and having NL tokenization
08:38:15 <tallpaul> quicksilver: i think so.
08:38:20 <int-e> @type arr . uncurry
08:38:21 <lambdabot> forall c (a :: * -> * -> *) a1 b. (Arrow a) => (a1 -> b -> c) -> a (a1, b) c
08:38:34 <quicksilver> I never use parsec's builtin tokenisers so I can't really help there
08:38:44 <int-e> quicksilver: something like that? plus the standard tupling stuff.
08:38:45 <Saizan> tallpaul: maybe you just have more whitespace around and you've to ignore it?
08:38:47 <quicksilver> I always write my own tokeniser + then use parsec for the parser, if I'm using parsec at all
08:38:51 <quicksilver> int-e: yes
08:39:39 <tallpaul> Is there a possibility to parse there LET/INs without sepBy1 ... newline
08:39:40 <Saizan> tallpaul: since the tokenizer in parsec is just an handy set of "lexical" parsers, you still work on String, right?
08:39:48 <tallpaul> Yes
08:39:55 <mreh> thanks int-e
08:40:36 <Saizan> tallpaul: i think you've to make parseLetStmt eat any surrounding whitespace
08:40:45 <Saizan> tallpaul: except for newlines
08:40:52 <tallpaul> Saizan: yes but how?
08:43:01 <tallpaul> Is there any trick to say something like: "take anything till X and use parser p on x".
08:43:22 <Saizan> with skipMany (satisfy (\c -> isSpace c && not (c == '\n')))
08:44:46 <Saizan> let spaces' = skipMany (satisfy (\c -> isSpace c && not (c == '\n'))) in sepBy1 (do spaces'; l <- parseLetStmt; spaces'; return l) newline
08:45:56 <Saizan> which is doing the lexing within the parsing, so maybe two distinct stages would be better.
08:47:24 <tallpaul> parseLetStmt eats the following whitespaces. So thats the problem.
08:47:39 <Saizan> ah, newlines too?
08:47:43 <tallpaul> Yes
08:47:46 <Saizan> that'd be a problem, yeah
08:48:19 <tallpaul> Okay, back to scratch: If I want also parse LET x = 1 y = 2 IN x, as told by fax.
08:48:44 <Desustorm> fax, what does giveTo playerX card hands =
08:48:44 <Desustorm>     \player -> if player == playerX
08:48:44 <Desustorm> mean
08:48:53 <Desustorm> i.e. where does \player come from
08:49:31 <ManateeLazyCat> Today, i compile gtk2hs, and found generate duplicate line "mtl-1.1.0.2-23ca4de7c573fd4df309067199a40634" in Makefile after `./configure'. I can compile if if i remove that duplicate from Makefile.
08:49:32 <lambdabot> ManateeLazyCat: You have 1 new message. '/msg lambdabot @messages' to read it.
08:49:52 <Saizan> tallpaul: do you allow only a single variable on the left of the let?
08:50:00 <tallpaul> yes
08:50:12 <Saizan> ok, then you can look for the =
08:50:41 <ManateeLazyCat> Same package, i haven't occur this problem before, something wrong with mtl? Or GHC environment?
08:50:44 <tallpaul> yes, but I found no function for this in parsec.
08:50:53 <tallpaul> parseTill or something
08:52:05 <Saizan> i think you've to do it with notFollowedBy
08:52:57 <tallpaul> i give it a try...
08:53:19 * Saizan isn't a parsing expert by far
08:53:46 <Saizan> however, this grammar seems to be harder
08:54:08 <gwern> @quote
08:54:08 <lambdabot> xDie says: <xDie> > 1.1.1.1.1.1.1.1.1.1.1.1 + 2.3
08:54:11 <fax> Desustorm: you don't know  \x -> m[x] ? lambda yet?
08:54:21 <gwern> > > 1.1.1.1.1.1.1.1.1.1.1.1 + 2.3
08:54:22 <Desustorm> fax, no
08:54:22 <lambdabot>   <no location info>: parse error on input `>'
08:54:27 <gwern> > 1.1.1.1.1.1.1.1.1.1.1.1 + 2.3
08:54:28 <lambdabot>   No instance for (GHC.Real.Fractional (a1 -> a))
08:54:29 <lambdabot>    arising from the literal...
08:54:41 * gwern wonders what xDie was expecting that to do
08:54:56 <fax> Desustorm, oh this is a really important part of haskel.. in this particular case you could write the function without it, but it's worth learning irrregardlessly
08:55:09 <copumpkin> o.O
08:55:22 <Desustorm> fax after this coursework I probably won't use haskell >_>
08:55:40 <fax> oh just forget everything I said hten
08:55:54 <copumpkin> Desustorm: you might as well learn the bare minimum, eh
08:56:04 <copumpkin> don't overexert your mind
08:56:10 <fax> you'd only want to take the route I said if you were going to want to learn haskell inside out
08:56:51 <Desustorm> copumpkin, i have a deadline
08:57:01 <Desustorm> it needs to work by then :|
08:57:15 <copumpkin> fair enough
08:57:16 <fax> you already have been shown a working implementation of this function?
08:57:24 <fax> so i am not sure why don'tyou  just use it :P
08:57:24 <copumpkin> I lose interest in helping people who aren't interested in the first place though
08:57:35 <copumpkin> no real satisfaction for me
08:58:09 <Desustorm> fax, my university's lab machine doesn't have the library that includes transpose :(
08:58:11 <benmachine> @faq can haskell actually be enjoyable even if you have a deadline approaching
08:58:12 <lambdabot> The answer is: Yes! Haskell can do that.
08:58:17 <fax> @src transpose
08:58:17 <lambdabot> transpose []             = []
08:58:17 <lambdabot> transpose ([]   : xss)   = transpose xss
08:58:17 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
08:58:24 <copumpkin> it's in Data.List
08:58:53 <Desustorm> i got "not in scope 'transpose'"
08:59:04 <fax> yeah man I just showed the source code
08:59:10 <fax> you can uuse that to define it
08:59:12 <Alpounet> do you import Data.List ?
08:59:23 <Desustorm> ahaha
08:59:24 <HugoDaniel> hi
08:59:27 <Desustorm> maybe not lemme check
08:59:29 <Alpounet> (which is part of the standard library)
08:59:33 <fax> Desustorm, this is what I was suggesting that you implement http://pastie.org/873973
09:00:19 <benmachine> fax: why deos giveTo use a lambda instead of an extra function parameter?
09:01:11 <fax> so I don't cut someones hand in two
09:01:37 <benmachine> oh, I think I see what you're doing
09:02:21 <benmachine> not sure I'd give that implementation to a newbie though :)
09:03:30 <fax> what implementation would you ? :)
09:03:58 <copumpkin> :t foldr (zipWith (:)) []
09:04:00 <lambdabot> forall a. [[a]] -> [[a]]
09:04:15 <Desustorm> hey fax I appreciate they help
09:04:23 <fax> Desustorm -- that's okay
09:04:24 <Desustorm> would be nice if i could spell :p
09:04:29 <Desustorm> :)
09:04:43 <benmachine> fax: I dunno it just seems that returning a list of functions from functions to functions is quite an advanced thing to do :P
09:04:53 <fax> benmachine, well it's functional programming
09:04:59 <fax> might as well use functions!
09:05:03 <benmachine> heh, true
09:05:19 <copumpkin> > foldr (zipWith (:)) [] [[1,2,3],[4,5,6],[7,8,9]]
09:05:21 <lambdabot>   []
09:05:25 <copumpkin> excellent!
09:05:29 <copumpkin> > foldl (zipWith (:)) [] [[1,2,3],[4,5,6],[7,8,9]]
09:05:30 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
09:05:35 <copumpkin> excellenter!
09:05:44 <benmachine> copumpkin: isn't the [] a problem there?
09:05:49 <copumpkin> > foldr (zipWith (:)) [[]] [[1,2,3],[4,5,6],[7,8,9]]
09:05:50 <lambdabot>   [[1,4,7]]
09:05:55 <copumpkin> :P
09:06:02 <Desustorm> now to get onto making a game ^^
09:06:03 <copumpkin> > foldr (zipWith (:)) (repeat []) [[1,2,3],[4,5,6],[7,8,9]]
09:06:05 <lambdabot>   [[1,4,7],[2,5,8],[3,6,9]]
09:06:12 <benmachine> wooo
09:06:17 <Cale> > split n [] = []; split n xs = let (us,vs) = splitAt n xs in us : split n vsghci> let split n [] = []; split n xs = let { (us,vs) = splitAt n xs} in us : split n vs in transpose (split 3 [5,6,8,9,7,5,4,2,3,1,5,6,7])
09:06:18 <lambdabot>   <no location info>: parse error on input `='
09:06:25 <Cale> > letsplit n [] = []; split n xs = let (us,vs) = splitAt n xs in us : split n vsghci> let split n [] = []; split n xs = let { (us,vs) = splitAt n xs} in us : split n vs in transpose (split 3 [5,6,8,9,7,5,4,2,3,1,5,6,7])
09:06:26 <lambdabot>   <no location info>: parse error on input `='
09:06:27 <Cale> oops
09:06:29 <Cale> > let split n [] = []; split n xs = let (us,vs) = splitAt n xs in us : split n vsghci> let split n [] = []; split n xs = let { (us,vs) = splitAt n xs} in us : split n vs in transpose (split 3 [5,6,8,9,7,5,4,2,3,1,5,6,7])
09:06:30 <lambdabot>   not an expression: `let split n [] = []; split n xs = let (us,vs) = splitAt...
09:06:33 <benmachine> vsghci>
09:06:46 <Cale> hmm
09:06:55 <fax> let split n [] = []; split n xs = let { (us,vs) = splitAt n xs} in us : split n vs in transpose (split 3 [5,6,8,9,7,5,4,2,3,1,5,6,7])
09:06:56 <Cale> > let split n [] = []; split n xs = let (us,vs) = splitAt n xs in us : split n vs let split n [] = []; split n xs = let { (us,vs) = splitAt n xs} in us : split n vs in transpose (split 3 [5,6,8,9,7,5,4,2,3,1,5,6,7])
09:06:57 <lambdabot>   <no location info>: parse error on input `let'
09:07:01 <Cale> oh, blah!
09:07:07 <Cale> I see what's happening now :)
09:07:15 <Cale> > let split n [] = []; split n xs = let{ (us,vs) = splitAt n xs} in us : split n vs in split 3 [5,6,8,9,7,5,4,2,3,1,5,6,7]
09:07:16 <lambdabot>   [[5,6,8],[9,7,5],[4,2,3],[1,5,6],[7]]
09:07:23 <Cale> > let split n [] = []; split n xs = let{ (us,vs) = splitAt n xs} in us : split n vs in transpose (split 3 [5,6,8,9,7,5,4,2,3,1,5,6,7])
09:07:24 <lambdabot>   [[5,9,4,1,7],[6,7,2,5],[8,5,3,6]]
09:10:15 <Desustorm> hmm what does groupsOf do?
09:14:20 <Cale> groupsOf?
09:14:24 <cads> wow sometimes it's very hard to deobfuscate functional code without introducing hopeless bugs
09:14:39 <Cale> cads: hehe, what code?
09:14:45 <cads> will post in a sec
09:15:20 <cads> Some code for turning a a natural number into its written english equivalent
09:15:21 <cads> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24076#a24076
09:15:27 <cads> ^ before
09:15:48 <cads> and now, if my latest edit hasn't introduced more bugs..
09:16:09 <fax> "natural number into its written english equivalent" -- bidirectionally?
09:16:27 <fax> (it is much fun to program this in a bidirectional way :P)
09:16:31 <cads> no, just turns  123 -> one hundred and twenty three
09:17:17 <cads> tell me how I did in cleaning it up : http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24077#a24077
09:17:48 <cads> still looks awful to me, but at least _I_ can see how the damn thing works now :)
09:18:22 <benmachine> I reckon using divMod more might be useful
09:18:53 <benmachine> not sure
09:19:03 <benmachine> but pretty much everywhere you have a div you also have a mod
09:20:06 <gwern> cads: who says one hundred and twentry three?
09:20:08 <rothwell> 'lo. quick question: is it possible to temporarily force cabal to build all source files, whether the build is really required or not?
09:20:14 <benmachine> gwern: \o.
09:20:18 <benmachine> it bothers me also that some matching is done in the equations and some in the guards
09:20:24 <gwern> rothwell: cabal clean && cabal configure && cabal build?
09:20:30 <benmachine> you should do everything in guards, imo
09:21:01 <benmachine> (in this case, only because it's either guards or both)
09:21:21 <rothwell> gwern: it'll only build the source files that export modules that are imported by other source files in the project
09:22:03 <Cale> gwern: I don't know about "twentry" ;) but I say 123 as "one hundred and twenty three"
09:22:05 <gwern> yes. so?
09:22:27 <Cale> How else would you say it? Drop the "and"?
09:22:41 <cads> gwern, that issue was brought up in the discussion for project euler problem 14 - apparently one hundred and twenty three is proper usage in the UK
09:22:49 <gwern> Cale: sure
09:23:11 <gwern> using 'and' clashes with lists
09:23:18 <benmachine> as a person from the UK I can affirm this claim
09:23:22 <fax> in context you would normally say something like  'give me a hundred and twenty three of those'
09:23:27 <benmachine> as a representative of the people of Britain
09:23:30 <fax> but to say the number on its own 'one hu...' is correct
09:23:55 <gwern> benmachine: you silly wankers. well, at least you get the serial comma right
09:24:02 <cads> in america we'd say 123.23  as "one hundred twenty three and twenty three hundredths", while in the uk they'd say "one hundred and twenty three point two three"
09:24:04 <MaciejP> Is a British 10^9 different from an American 10^9?
09:24:09 <rothwell> never mind... worked around it
09:24:15 <rothwell> cheers o/
09:24:31 <Cale> MaciejP: hehe
09:24:46 <gwern> cads: really? I say it 'point'. huh
09:24:47 <benmachine> there's some dispute over what a billion is
09:25:04 <benmachine> I thought american usage dominated but you do still find people using the long scale
09:25:17 <gwern> cads: iirc, most americans now say 'point' because it's too hard to remember how to turn twenty three hundreths into .23
09:25:21 <benmachine> gwern: what's the serial comma
09:25:23 <cads> hehe, my european million/billion code is broken
09:25:32 <gwern> benmachine: foo, bar, and baz vs foo, bar and baz
09:25:46 <benmachine> I've heard that called the oxford comma
09:25:51 <benmachine> it's not universal
09:26:00 <cads> gwern, working at a machine shop you commonly hear thousands, hundredths and tenths of inches, but I can see how common usage might be 'point'
09:26:08 <diegoeche> fuck I'm slow... It took me a while to understand "foldr (zipWith ( : )) (repeat [])"
09:26:17 <diegoeche> really nice code indeed
09:26:29 <Becquerel> benmachine: oxford is the best though
09:26:35 <lispy> > repeate []
09:26:36 <benmachine> Becquerel: obv
09:26:37 <lambdabot>   Not in scope: `repeate'
09:26:39 <lispy> oops
09:26:45 * benmachine quietly plots Becquerel's death
09:26:48 <gwern> lispy: ye olde haskelle?
09:26:56 <lispy> gwern: !
09:26:57 <lispy> hi
09:27:21 <benmachine> is lispy the person who I kept wondering where they'd got to
09:27:24 <benmachine> I can't remember
09:27:27 <benmachine> it was one of you ls
09:27:27 <Cale> diegoeche: It's similar to transpose, but drops extra elements on the floor.
09:27:34 <gwern> be advised! because of the great vowel shift, old haskell pronounces _|_ buttum, not bottom.
09:27:50 <lispy> benmachine: "wondering where they'd got to"?
09:28:20 <benmachine> lispy: there was someone I remembered from when I was learning haskell but hadn't seen much recently
09:28:25 <fax> cads why not delete it an write a bijective version instead?
09:28:29 <gwern> 'had we ram enough and time, lady, this laziness 'twere no crime'
09:28:31 <xarch> hello
09:28:38 <lispy> ah
09:28:51 <lispy> Yeah, Im not really a regular here these days
09:28:57 <lispy> But I was, once upon a time
09:28:57 <benmachine> oh right
09:28:58 <benmachine> hi!
09:29:19 <gwern> (we would sit down and backtrack and repine / to walk our long expression's spine)
09:29:22 <tensorpudding> so now you're an irregular?
09:29:28 <cads> fax, I was intrigued when you mentioned that, but I wouldn't know how to make a bijection for this except by writing a complementary parser to complete my already existing code
09:30:05 <lispy> tensorpudding: english_verby?
09:30:14 <lispy> Nah, not the same ring as lispy
09:30:17 <fax> cads, :D
09:30:39 <tensorpudding> irregular being the opposite of regular
09:30:55 <gwern> ('thou by the reverse Polish tree / shouldst booleans see')
09:31:20 <copumpkin> @check \xs -> transpose (transpose xs) == xs
09:31:21 <lambdabot>   "Falsifiable, after 1 tests:\n[[],[()]]\n"
09:31:48 <cads> fax a function  read such that   read.americanNumber = (id::Integer)  would mean I have to extend the number program for negative numbers and for numbers with absolute value greater than 10^301
09:31:53 <cads> that would be fun :)
09:31:54 <fax> cads, for the digits it's easy :   [ "one" <-> 1 , "two" <-> 2, ... ] where (<->) = (,)
09:32:36 <fax> you can easily project out functions  String -> <Integer> and Integer -> <String>
09:32:37 <cads> I guess that'd be (id::Integer->Integer)
09:32:40 <fax> (which are bijective)
09:32:45 <fax> inverses***
09:33:16 <fax> <>'s meaning obviously we have to give error messages and stuff, this is only bijective on inputs that parse correctly -- but that's what we want
09:33:37 <Taejo> Is it possible to compile files into a program as strings?
09:33:41 <c_wraith> what integer fails to give string output?
09:33:43 <fax> you need to build up some combinators next, like jusxtapotiion <-> multiplication
09:33:44 <benmachine> cads: you can eventually resort to "billion billion billion" etc.
09:33:44 <gwern> Taejo: yes
09:33:48 <gwern> Taejo: not fun though
09:33:52 <fax> to implement  three hundred <-> 3 * 100
09:33:58 <gwern> so. no vandalism on the wiki so far
09:33:59 <gwern> that's good
09:34:02 <c_wraith> gwern: it's not that hard.  just a short bit of TH
09:34:11 <gwern> c_wraith: any th is painful
09:34:22 <Taejo> gwern: probably easier to find an alternative solution, then
09:34:24 <gwern> byorgey: did you notice I got ashley to re-enable account creation?
09:34:37 <fax> and just take it from there
09:34:44 <gwern> Taejo: if you can install it as part of the cabal package, could just use the Paths_* mechanism
09:34:56 <fax> and <-> +
09:34:59 <fax> etc..
09:35:00 <copumpkin> dilemmata?
09:35:19 <Taejo> gwern: since I'm never going to distribute it, cabal seems overkill
09:35:26 <gwern> copumpkin: a lemma which is a dilemna, maybe
09:35:45 <copumpkin> well a dilemma is just two lemmas
09:36:02 <gwern> nooo! defeated by the etymology!
09:36:27 <gwern> copumpkin: fine, then it's a dilemma which manifested as a stigmata in the body of the prover
09:36:32 <Taejo> unsafePeformIO . readFile is probably the easiest
09:36:42 <copumpkin> Taejo: !!!!
09:36:45 <Alpounet> noooo
09:36:46 <copumpkin> zomg
09:37:08 <copumpkin> unsafePerformIO . fmap rnf . readFile
09:37:19 <Taejo> the files are static... the only reason not to make them string constants is that they're long
09:37:53 <gwern> ...then where do you expect the files to be stored?
09:38:14 <Taejo> gwern: since I'm not distributing, I can just hardcode their locations
09:38:39 <copumpkin> personal consumption only
09:38:51 <cads> fax, I like that idea about projecting out tuples  - toWord n = lst . find ((==n).fst) $ <(0,zero), (1,one)...>,  and toNumber n = fst . find ((==n).lst) $ <(0,zero), (1,one)...>  :)
09:38:51 <Taejo> yeah
09:42:32 <fax> cads, just occured to me:   "one" <-> 1  could be a parser that returns '1' for "one" if we instantiated <-> to be the obvious if thing, but it gives "one" for '1' if we instantiated it differently: some kind of choice operator to turn a list of these into something which parses any digit
09:42:46 <fax> so we needn't let (<->) = (,) like I wrote before
09:43:14 <MaciejP> copumpkin: What is rnf?
09:43:22 <copumpkin> reduce to normal form
09:43:26 <copumpkin> actually I meant deepseq
09:43:42 <copumpkin> which is like seq, but deep :P
09:47:09 <cads> fax, define a <-> b =  f such that f a = b and f b = a?
09:48:12 <fax> well if we let <-> = ... we get f a = b, and if we let <-> = ... then g b = a
09:48:20 <fax> but you have to implement <-> twice (different ways each time)
09:50:31 <zygoloid> Taejo: foo = $(stringE =<< runIO (readFile "foo"))
09:50:36 <zygoloid> ^^ i think something like that should work
09:51:10 <benmachine> oh I've done something like that
09:51:44 <benmachine> beginHTML = $(LitE . StringL <$> runIO (readFile "src/begin-html.template"))
09:52:30 <c_wraith> what do you people have against lift?
09:52:50 <c_wraith> $(lift =<< runIO (readFile "foo"))
09:53:30 <zygoloid> c_wraith: 1) i didn't know it existed, 2) its name clashes with MonadTrans
09:53:53 <zygoloid> (i thought you meant $(stringE =<< lift (readFile "foo")) at first)
09:54:03 <c_wraith> It's a bit overkill for strings, but for general data structures, it's awesome.
09:54:15 <c_wraith> and it at least works nicely for strings
09:55:30 <c_wraith> "convert this data structure to an expression representing it" is such a fundamental operation for template programming...
09:55:47 <zygoloid> yes, it seems like a great tool :)
09:55:53 <fax> quotation
09:56:29 <zygoloid> (but yes, a great tool with a poorly chosen name, i think)
09:56:31 <Taejo> zygoloid: cool! What's language extension do I need for that?
09:57:08 <zygoloid> Taejo: {-# LANGUAGE TemplateHaskell #-}
09:57:14 <Taejo> thanks
10:03:19 <cads> > let f (a,b) x = if x then show a else show b in f (1, "one") False
10:03:20 <lambdabot>   "\"one\""
10:03:52 <cads> > let f (a,b) x = if x then a else b in f (1, "one") False
10:03:53 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
10:03:53 <lambdabot>    arising from the literal ...
10:04:52 <cads> > let f (a,b) x = if x then show a else show b in f (1, "one") True
10:04:53 <lambdabot>   "1"
10:05:31 <cads> So we can't have a function that can return one a a fixed set of types, but we can get around it by returning strings.
10:06:18 <lowasser> Has anybody else found installing gtk2hs impossible?
10:06:36 <danderson> yes
10:06:41 <sm> lowasser: near-impossible, yes. port install gtk2hs worked for me on mac
10:06:44 * hackagebot erf-native 1.0.0.0 - Native Haskell implementation of the interface from the erf package  http://hackage.haskell.org/package/erf-native-1.0.0.0 (JamesCook)
10:06:54 <danderson> lowasser: its cabalization is in progress though, according to the mailing list
10:07:10 <cads> fax, I think I should study some parser-fu before I can think "elementary - a parser bijection!" Any suggestions for parser introductions and homework assignments?
10:07:16 <danderson> lowasser: there are beta-quality cabal source tarballs if you want to try that
10:07:43 <fax> cads, it should be two different functions f and g which are inversese
10:07:43 <lowasser> where?
10:07:50 <gwern> danderson: the gtk mailing list?
10:07:55 <fax> so f "one" = 1 and g 1 = "one"
10:08:22 <danderson> lowasser: http://www2.in.tum.de/~simona/
10:08:24 <fax> but implement them like this   f = parser table ; g = printer table
10:08:26 <danderson> gwern: the gtk2hs-devel list
10:08:38 <fax> where table is [("one",1)]
10:08:41 <fax> but like
10:08:45 <HugoDaniel> can i make this more verbose ? *** Exception: Prelude.read: no parse
10:08:49 <danderson> lowasser: you need to install in this order: buildtools, cairo, glib, pango, gtk
10:08:50 <fax> you can start there and change it to be more flexible
10:08:53 <Taejo> http://shemesh.larc.nasa.gov/images/humor-hard-to-sell.jpg
10:09:01 <fax> infact it shouldn't even be table yet...
10:09:54 <lowasser> how can so many packages depend on something so hard to install? ::eyeroll::
10:10:20 <danderson> lowasser: it's an oddity in the normally awesome hackage universe
10:10:25 <Taejo> lowasser: so many developers of those packages use an OS where it's not hard to install
10:10:25 <lowasser> clearly
10:10:51 <lowasser> I mean, I run Ubuntu, but the aptitude package only works with 6.10.4
10:11:03 <lowasser> which makes me sad =(
10:11:26 <danderson> lowasser: I actually wrote a small script that automates the install away for my ubuntu machines
10:11:41 <lowasser> oooh!
10:11:48 <lowasser> share with the world plz
10:12:01 <danderson> (I also have one which installs a complete haskell platform in ~/software, which is why I couldn't use the system package)
10:12:08 <lowasser> though I'm almost through installing from the link you sent me =)
10:12:29 <danderson> lowasser: I wrote it before finding the cabalized packages, so it's pretty much obsolete
10:12:34 <lowasser> awww
10:12:38 <danderson> hopefully the packages will find their way to hackage soon
10:12:42 <cads> fax so far I've implemented g, and I think I'll be able to implement f pretty well once I've read through a parser combinator paper. But this common 'table' data structure seems like some dynamically generated datastructure which lets you lookup either a number or a letter using different access functions. Is that what you're visiualizing?
10:13:01 <danderson> at which point I'll just add criterion to the list of packages to install for my haskell platform builder, and boom :)
10:14:19 <fax> the idea is to program a bijective function we write it in a language where everything is bijective
10:14:30 <fax> but this is not haskell, so we make a new language inside haskell
10:14:55 <copumpkin> what would a language where everything is bijective look like?
10:15:01 <fax> build it up peice by peice, starting with atomic elements and then pairs and so on
10:15:02 <copumpkin> bijecskell
10:15:03 <danderson> lowasser: if you care about having a haskell installation that is independent of the distro packaging, http://bitbucket.org/danderson/builders/src/tip/haskell
10:15:30 <cads> copumpkin, only monotonically increasing functions allowed!
10:16:01 <lowasser> fax: in such a language, encryption algorithms would be kind of hard
10:16:09 <fax> heh
10:16:12 <lowasser> like, you couldn't multiply two large primes!
10:16:25 <twink> Curry exists but falls somewhat short.
10:16:45 <copumpkin> sure you can
10:17:19 <fax> "of course you can, it only takes finite time!"
10:18:47 <cads> fax, I'll see if I can come up with a representation of a basic discrete isomorphic function using a collection of pairs for now
10:21:04 <fax> you need to know list monad as well by the way
10:21:19 <fax> I assume that you do
10:23:48 * hackagebot hfiar 0.1.0 - Four in a Row in Haskell!!  http://hackage.haskell.org/package/hfiar-0.1.0 (FernandoBenavides)
10:26:24 <cads> fax, I've read through examples but never used it to solve a real problem. Do you think I'd need it to implement composition of my discrete bijections?
10:28:01 <fax> it's for search like if you have multiple possibilites and don'tt know which one to take until later
10:28:35 <fax> like does "fifty" mean 50 or (50 +) ?
10:28:52 <fax> in the case "fifty." it means 50 but in "fifty two." it means (50 +)
10:29:01 <fax> so list monad is the way to deal with this type of case
10:29:20 <sepp2k> @pl (\k t -> chr $ a + flip mod 26 (ord k + ord t -2*a))
10:29:20 <lambdabot> ((chr . (a +) . flip mod 26) .) . flip flip (2 * a) . ((-) .) . (. ord) . (+) . ord
10:30:00 <jmcarthur> fax: you mean in "fifty-two" which is even more confusing ;)
10:35:04 <eevar> yay, space leaks are a lot easier to cope with after setting some reasonable pam_limits
10:40:02 <cads> fax, so in this case, parsing 'fifty' would create a list [50, 51, 52, ...], and then parsing an end of number token would collapse the list to a single value [50]?
10:40:31 <ErhardtMundt> BONUS, hey!
10:44:01 <cads> fax, I'll admit, I'm taking notes on the ideas here, and they're a bit beyond me, but I'm going to start with what I can understand so far and see how far I get and how much I get to find out as I go on :)
10:51:56 * hackagebot hfiar 0.1.1 - Four in a Row in Haskell!!  http://hackage.haskell.org/package/hfiar-0.1.1 (FernandoBenavides)
11:00:30 <fax> cads: "parsing 'fifty' would create a list [50, 51, 52, ...' sort of but rather than a list it's a function (\x -> 50 + x)
11:01:27 <fax> because there is two meanings to fiftey so we can parse it in two ways ... the correct one is figured out by the context after the word
11:02:47 <Cale> The empty string just has value 0
11:03:59 <lament> meanwhile in #math...
11:04:01 <lament> 11:04 <pokoko222> well i wanna get deep and for life with math, so i will take  my time to read stuff
11:04:09 <lament> <3
11:04:11 <medfly> is this haskelllove
11:04:15 <medfly> oh yes it is
11:04:15 <lament> yeah
11:08:07 <copumpkin> mmm
11:09:32 <cads> <pokoko222> i need information theory ninja mentor
11:09:57 <copumpkin> well, can't say he's not enthusiastic
11:10:59 <lament> @quote haskelllove
11:10:59 <lambdabot> lament says: <HaskellLove> Can eulers be solved in Prolog? <lament> HaskellLove: no <lament> prolog is not euler-complete
11:11:05 <lament> @quote pokoko
11:11:05 <lambdabot> No quotes match. That's something I cannot allow to happen.
11:16:24 * edwardk_ waves hello.
11:16:33 <fax> hi
11:19:22 <applicative> copumpkin:  for what it's worth, the film of Voevodsky's recent talk on type theory is linked here http://lists.seas.upenn.edu/pipermail/types-list/2010/001477.html
11:19:56 <fax> http://spikedmath.com/191.html
11:21:01 <applicative> copumpkin:  the notes for the talk conclude with "Pretheorem 8:  A proof of ”False” in Coq under the assumption of the equivalence, contractible choice and the excluded middle axioms would imply inconsistency of ZFC."  I recommend porting it to Agda
11:22:12 <roconnor> applicative: does that mean there is a model of Coq in ZFC?
11:22:15 <fax> wyh would you port to agda o_o
11:22:29 <applicative> fax: i'm kidding
11:22:34 <fax> oh
11:23:29 <mreh> what is the mathematics of getting an object to appear back on the other side of the screen?
11:23:33 <applicative> roconnor:  It's impenetrable, but that is certainly not intended.  The notion of a 'model in set theory' is one of the things he wants to get rid of, to put it very crudely
11:23:41 <mreh> it seems like it needs some kind of stateful calculation
11:23:57 <mreh> a moving object
11:24:28 <roconnor> mreh: I'm confused
11:24:44 <roconnor> mreh: what screen?  My screen has only one side (that displays stuff).
11:24:47 <mreh> it has an x,y co-ordinate that needs to map on a small range, but there needs to be a buffer either side of the screen
11:25:06 * hackagebot network-websocket 0.2 - WebSocket library  http://hackage.haskell.org/package/network-websocket-0.2 (MichaelMelanson)
11:25:11 <mreh> I'm using screen in the abstract sense, a 2D plane
11:25:19 <roconnor> mreh: oh you mean wrap around?
11:25:24 <mreh> yeah, that
11:25:39 <roconnor> so a torus, topologically speaking :D
11:25:50 <mreh> yes, i suppose
11:25:58 <roconnor> aka the 2D plain modulo a rectangular lattice
11:26:02 <roconnor> plane
11:26:02 <edwardk_> i've been playing around with fingertrees of bytestrings again, and trying to figure out how to use those to efficiently support utf8-encoded character-based indexing as well
11:26:11 <roconnor> mreh: you just use mod
11:26:19 <roconnor> on each of the coordinates
11:26:26 <Alpounet> edwardk_, I pretty much grasped Kan extensions, Codensity and all thanks to your explanations and some posts on your blog
11:26:39 <edwardk_> i'm wondering if a reasonable bytestring-like structure would be a bytestring that includes one additional integer in addition to the length: the number of 'high bytes' in the interval.
11:26:39 <Alpounet> thank to*
11:26:39 <roconnor> > -100 `mod` 640
11:26:40 <lambdabot>   -100
11:26:46 <roconnor> > (-100) `mod` 640
11:26:47 <lambdabot>   540
11:26:49 <mreh> roconnor: with a buffer it's not possible, how do I know that the ship is not in the buffer but near the opposite edge
11:26:52 <roconnor> > (650) `mod` 640
11:26:53 <lambdabot>   10
11:26:53 <Alpounet> these are awesome stuffs
11:26:55 <edwardk_> for any ascii encoded bytestring the high count would = 0, and you can use byte indexing perfectly
11:27:11 <mreh> roconnor: it doesn't work :)
11:27:30 <mreh> 540 is less than 640, the object needs to appear in the opposite buffer area
11:27:34 <edwardk_> then i can sum that count monoidally, just like the lengths of the segments
11:27:40 <sinelaw> ahoy
11:27:41 <gwern> edwardk_: that seems reasonable for Text; presumably there's already a type split between all-ascii and not
11:27:43 <copumpkin> edwardk_: seems like a neat idea
11:27:47 <roconnor> mreh: what do you mean by buffer, you mean the screen displays only a portion of valid possible possitions?
11:28:07 <mreh> roconnor: yes, to stop the object appearing too suddenly on the screen
11:28:14 <gwern> edwardk_: and actually, couldn't it just be a bit? what does knowing exactly how it's not 0 help you?
11:28:24 <roconnor> mreh: just mod by screen-size + buffer_size
11:28:33 <edwardk_> gwern: i'm trying to avoid Data.Text, and am thinking entirely in a utf8 encoded world. Data.Text seems to strike exactly the wrong balance for me. UTF16 is bloated, and still has to deal with surrogate pairs
11:28:44 <mreh> > -100 `mod` 640+10
11:28:45 <lambdabot>   -90
11:28:45 <roconnor> mreh: and clip away objects outside the screen-size
11:28:58 <roconnor> > (-100) `mod` 640+10 -- damn parsing
11:28:59 <lambdabot>   550
11:29:05 <edwardk_> gwern:  because i can subtract 1 from it everytime i use a 'word8 head' to skip past a high byte
11:29:07 <mreh> oh... mod gives you negative values
11:29:11 <roconnor> no
11:29:14 <mreh> no :)
11:29:16 <edwardk_> so i can rederive the value of that bit in later substrings
11:29:17 <mreh> duh
11:29:37 <edwardk_> and more importantly i get a VERY nice property when i look at fingertrees of these
11:29:39 <roconnor> > (-100) `mod` (640+10) -- more damn parsing
11:29:40 <lambdabot>   550
11:30:04 <gwern> edwardk_: the max high bit is a monoid?
11:30:13 <roconnor> > (-5) `mod` (640+10) -- more damn parsing
11:30:14 <lambdabot>   645
11:30:14 <mreh> > 550 `mod` (640+10)
11:30:15 <lambdabot>   550
11:30:31 <roconnor> if a position is greater than 640 then it is off screen and in the buffer
11:30:34 <edwardk_> if i'm seeking the 10000th character, i can seek to first chunk such that the sum of length - extras exceeds 10000.
11:30:36 <gwern> hm, didn't sigfpe use 'max value of any subtree' as an example in his monoid/fingertree blog?
11:30:52 <mreh> roconnor: the position is not a mutable value though
11:30:55 <edwardk_> so you can use it to quickly seek through the resulting fingertree to individual character positions
11:31:01 <mreh> it's an integral over the velocity of the object
11:31:07 <mreh> this is the problem
11:31:09 <edwardk_> so knowing the exact count adds a HUGE amount of speed to character based indexing
11:31:09 <applicative> whoa, the film of Voevodky's talk ends with live coding in Coq ...
11:31:25 <dmwit> gutsy
11:31:27 <copumpkin>  mmm speed
11:31:34 <roconnor> mreh: what does that have to do with wrapping and buffers?
11:31:48 <gwern> edwardk_: what's the downside?
11:31:51 <edwardk_> i don't care about the bit i need the exact count, it tells me how many fewer characters i have than bytes
11:31:53 <mreh> roconnor: this is done in Yampa
11:32:09 <mreh> I suppose I can switch into a new integral when the object goes off the edge...
11:32:21 <roconnor> Hmm, I don't know Yamap, but I don't see why there would be a problem.
11:32:26 <edwardk_> well, splitting within each bytestring in the fingertree has to count the number of high bytes in the shorter side
11:32:35 <fax> applicative??????????
11:32:42 <fax> NOw I don't beleive anything you say
11:32:46 <roconnor> just take whatever position Yampa gives and take it modulo (screen_size+buffer_size)
11:32:47 <copumpkin> lol
11:32:49 <mreh> roconnor: the position of the object is part of a stateful calculation
11:32:53 <fax> I still haven't figured how to f**** download the video
11:33:12 <edwardk_> so if i have a 1000 part fingertree, and i split it in the middle of the 534th chunk, i look at that chunk, figure out where i split it, take the shorter side and count the number of high bytes to rederive the value of the monoid.
11:33:19 <gwern> edwardk_: that doesn't sound too bad. the max bit is O(n), I take it, and each split would be of a smaller string
11:33:25 <roconnor> mreh: ah hmm
11:33:37 <mreh> roconnor: when that position is greater than 2*the screen size, I can't tell if I'm in the buffer or near the other edge
11:33:38 <roconnor> mreh: depending on what you are doing yampa would have to be aware you are on a torus
11:33:52 <edwardk_> its worst case is Data.Text's best case ;)
11:34:06 <edwardk_> and i'm using it in a fingertree rather than a list because i do a lot of appending of these
11:34:11 <copumpkin> Data.Text.Awesome
11:34:27 <edwardk_> copumpkin: =)
11:34:35 <gwern> so, O(n) on ever-decreasing - average splitting in half, obviously, so I guess it'd be asymptotically O(log n)?
11:34:37 <gwern> hm
11:34:37 <edwardk_> i was thinking ByteSeq ;)
11:34:46 <copumpkin> ew not Byte
11:34:52 <edwardk_> erm, not sure what you mean by O(n) there
11:35:00 <copumpkin> CharSeq?
11:35:01 <edwardk_> the fingertree contains two values in the monoid
11:35:18 <edwardk_> it is only within a given leaf that i need to do manual counting
11:35:22 <applicative> fax: it's quicktime, no trouble in safari...; just trade your loved ones for a macbook
11:35:34 <edwardk_> and the size of the leaf bytestrings should be bounded by a reasonable constant to minimize this effort
11:35:42 <edwardk_> also note, if the count is 0, no counting needs to be done
11:35:47 <edwardk_> so the common ascii case has a shortcut
11:35:51 <gwern> edwardk_: oh, the leaves aren't arbitrarily big?
11:36:03 <fax> I just want to save the damned data why do I have to stream it
11:36:03 <gwern> sounds good. the constant factors might be bad though
11:36:11 <roconnor> mreh: I'm not sure I can say much more without learning Yampa
11:36:11 <fax> frusrtaing
11:36:15 <mreh> no trouble running a proprietary video format in the browser it was designed for
11:36:18 <edwardk_> they can be, like a lazy bytestring, but the combinators that glue them together encourage a reasonable maximum size
11:36:26 <mreh> roconnor: it's a toughie
11:36:27 <copumpkin> fax: hold down option or alt while clicking the link
11:36:28 <edwardk_> when working with lazy bytestrings you tend not to have large chunks
11:36:55 <edwardk_> copumpkin: the question is what do you call the non 'Seq' components? =)
11:37:03 <gwern> copumpkin: no no, the code is up down left right a b select start!
11:37:04 <edwardk_> copumpkin: they sure aren't Chars
11:37:13 <edwardk_> CharString and CharSeq ? erf
11:37:22 <copumpkin> edwardk_: why not call it a Rope? it's basically the same idea
11:37:22 <edwardk_> CharString strikes me as a bit redundant ;)
11:37:40 <edwardk_> copumpkin: but what are the strict fragments with high byte counts called =)
11:37:50 <zygoloid> i'd think a Rope should be a rope, and this isn't :)
11:37:51 <copumpkin> Threads
11:37:58 <monochrom> chain
11:38:01 <copumpkin> zygoloid: it almost is
11:38:13 <zygoloid> its name should be something to do with UTF-8
11:38:18 <copumpkin> ew, no
11:38:22 <edwardk_> the code in kata called the whole concept a "Buffer", but that was when i was using strict bytestrings
11:38:27 <zygoloid> well, it depends if
11:38:28 <gwern> zygoloid: FUSeqs
11:38:33 <copumpkin> underlying representation is an implementation detail
11:38:38 <zygoloid> ... you want to expose that it's utf-8 internally
11:38:39 <sinelaw> conal, my only solution to the design problem was to drop (for the design) the parameterization on the monad, and define the semantic meaning specifcally for IO, that is: [[ Processor IO a b ]] = a -> b
11:38:58 <copumpkin> zygoloid: not in the name
11:39:03 <edwardk_> zygoloid: i plan to if only because it is reasonable to provide both char-wise and byte-wise operations over it.
11:39:03 <edwardk_> i use both currently
11:39:18 <edwardk_> chunks may not end on a character boundary
11:39:23 <sinelaw> conal, and obviously i still need to formulate the exact rules for Processor values that assures that the design reflects their behavior
11:39:26 <zygoloid> if the interface is utf-8y then utf-8 in the name seems not unreasonable.
11:39:45 <copumpkin> zygoloid: I'm a constructivist... does that mean it's reasonable?
11:39:49 <sinelaw> conal, such as assuring that I can also say [[ Ptr a ]]  = a
11:39:57 <fax> I need a program to save 'rtsp'
11:40:02 <zygoloid> copumpkin: it means it's reasonableness is non-negative :)
11:40:05 <fax> god dammit I hate mac
11:40:06 <sinelaw> fax gstreamer
11:40:19 <fax> yeah I can't use linux because I fail
11:40:32 <sinelaw> fax what?
11:40:33 <copumpkin> fax: what do you use?
11:40:34 <edwardk_> heh, Data.Prose ;)
11:40:44 <copumpkin> Data.Epic
11:40:54 <copumpkin> Data.Monic?
11:40:54 <sinelaw> Data.Useless
11:40:59 <fax> I have been trying to get working linux for years but it's always screwing up and have ot reinstall
11:40:59 <edwardk_> sinelaw: =P
11:41:10 <fax> so I just use mac which doesn't let you actually do anything
11:41:22 <copumpkin> sure it does
11:41:25 <sinelaw> fax ubuntu is nice
11:41:31 <sinelaw> and easy
11:41:40 <fax> sinelaw, my problem is having mac hardware that ubuntu breaks after a while
11:41:46 <sinelaw> fax gstreamer probably works on macs too
11:41:49 <fax> you boot up and it just gives a scrambled video with no way to fix
11:41:55 <sinelaw> oh
11:41:55 <edwardk_> well, these should have a very cheap down-convert process to Bytestrings, after all you just strip an Int off
11:42:02 <fax> I spent a coulple weeks trying to get arch to work but that wont even book
11:42:04 <fax> boot*
11:42:15 <fax> anyyway not much use complaining abou tthis here I guess it's just really irritating
11:42:26 <copumpkin> edwardk_: but what if I want infinite strings!?
11:42:27 <gwern> arch? why are you using arch if you 've never got linux working?
11:42:43 <gwern> that's like saying, 'I don't know how to install linux, so I'm going to use Linux From Scratch!'
11:42:43 <fax> I am not using arch
11:42:59 <fax> gwern that's a bad strategy?
11:42:59 <edwardk_> copumpkin: heh, well, there is that limitation. you are building a fingertree, which has strict branches, etc.
11:42:59 <copumpkin> I think we need a list of fingertrees of byte buffers
11:43:11 <gwern> fax: the problem with sink or swim is when you sink
11:43:27 <gwern> copumpkin: agh so many layerso f indirection
11:43:27 <edwardk_> copumpkin: you can implement that as a wrapper ;)
11:43:37 <copumpkin> gwern: I'm also going to wrap it in Identity
11:43:49 <copumpkin> edwardk_: okay, let me know when you release it and I'll make my wrapper :P
11:43:57 <gwern> despair! despair! this world of indirection has driven me to despair!
11:44:05 * gwern hangs self from nearest monad transformer stack
11:44:05 <edwardk_> hah
11:44:07 <edwardk_> mostly just sounding out the issues with it right now
11:44:26 <copumpkin> :)
11:44:36 <edwardk_> leaning towards utf8b decoding as well
11:44:51 <edwardk_> because it fits my particular needs ;)
11:45:03 <edwardk_> http://bsittler.livejournal.com/10381.html
11:45:53 <edwardk_> that way i can round trip from Prose to String and back safely, even if it contains illegal utf8
11:46:13 <fax> basically I can't use any of this stuff because someone smart hasn't made it work well for me
11:46:29 <edwardk_> which is important for a few of the monoids i have lying around
11:46:33 <fax> if I got a more standard type of computer then I am sure I would have no problem
11:47:14 <lowasser> oh god, gwern
11:47:18 <lowasser> don't do it
11:47:41 <lowasser> there's so much strictness in the world!
11:47:45 <edwardk_> hrmm, realizing that i can scan from either end of the bytestring fragments to count high bytes makes me happy
11:48:29 <lowasser> but anyway, no, if we convert a fingertree to use array-ish fragments, we have a C rope
11:48:40 <lowasser> except better than the C version, because cons and snoc are much better
11:48:47 <lowasser> I was thinking about this the other day
11:49:19 <edwardk_> lowasser: yeah. i've been using that for a long time
11:49:19 <edwardk_> lowasser: the trick above is to count the number of high bytes in the utf8 encoding present in each rope fragment
11:49:49 <edwardk_> to allow for fast char based indexing/splitting
11:49:49 <edwardk_> intermixed with byte based indexing/splitting
11:49:53 <lowasser> edwardk: wait, in haskell? or do you ust mean C ropes in general?
11:50:05 <lowasser> or did you implement finger trees in C? =P
11:50:05 <edwardk_> in haskell
11:50:08 <lowasser> ddddang
11:50:19 <lowasser> hawt
11:50:52 <edwardk_> gotta run
11:50:52 <edwardk_> i'll take a stab at implementing this tonight
11:51:19 <copumpkin> yay
11:51:48 <Younder> Have you seen the grant from the John Tempelton Foundation?
11:52:08 <Younder> deadline april 15'th
11:52:39 <mreh> that's for religious Darwinian apologeticists isn't it?
11:52:59 <Younder> I the 400 000$ bit
11:53:14 <Younder> mreh, no
11:53:14 <lament> pig fetuses!!!
11:53:32 <mreh> forged drawings :)
11:53:49 <HugoDaniel> i dont like read :( it doesn't read IS floating point numbers, like 1 000 000,123
11:53:50 <Younder> ^got
11:54:23 <mreh> HugoDaniel, IS?
11:54:31 <twink> What's IS?
11:54:36 <mreh> international standard?
11:54:39 <HugoDaniel> yes
11:54:58 <HugoDaniel> http://en.wikipedia.org/wiki/International_System_of_Units  SI i meant
11:54:58 <mreh> read reads in haskell code
11:55:09 <mreh> not SI
11:55:12 <twink> Looks tough to tokenize.
11:55:12 <HugoDaniel> what about this read "1 000 000,123"
11:55:21 <mreh> that's not haskell
11:55:29 * Younder just spends a 200 00$on a Cray and very happy to recieve that money
11:55:41 <sinelaw> what
11:55:42 <Younder> 200 000
11:55:47 <mreh> show and read are meant to be for haskell's use, not yours
11:56:04 <Younder> back to haskell
11:56:21 <HugoDaniel> what about this: read "123,321" ?
11:56:23 <Younder> I am writing the core of Formula in Haskell
11:56:35 <mreh> HugoDaniel: that's still not haskell syntax
11:56:47 <twink> Whitespace will hurt your efforts to tokenize IS numerals badly.
11:56:51 <Younder> HugoDaniel, loose the ,
11:57:00 <HugoDaniel> thats what im doing
11:57:08 <HugoDaniel> its fugly
11:57:12 <mreh> it's a bum that haskell doesn't take ',' as a 100 separator
11:57:23 <mreh> but you can use scientific notation if it makes your life easier
11:57:32 <zygoloid> mreh: what's the type of (-123,456)?
11:57:44 <mreh> (Int, Int)
11:58:02 <zygoloid> (my point was that , as a thousands separator would break that)
11:58:05 <HugoDaniel> the SI says that only a ',' or a '.' should be present, and its purpose is to separate the decimal values
11:58:22 <mreh> zygoloid: yes
11:58:41 <mreh> > 1e6
11:58:42 <lambdabot>   1000000.0
11:58:49 <mreh> > 1.11e6
11:58:49 <zygoloid> though i suppose it's no worse than (-123.456) except that . is seldom applied to numbers
11:58:50 <lambdabot>   1110000.0
11:58:56 <Younder> I's no a decimal value is it?
11:58:59 <aledge> > 1ee
11:59:00 <lambdabot>   Not in scope: `ee'
11:59:01 <Younder> not
11:59:15 <mreh> aledge: e is syntax
11:59:15 <Younder> well then..
11:59:19 <aledge> mreh i know
11:59:25 <mreh> :D
11:59:42 <mreh> haskell does not conform to SI as far as I am aware :)
11:59:49 <zygoloid> > let e = 1 in (+) 1e
11:59:50 <lambdabot>   2
12:00:01 <Younder> nreh: it does as far as I can see.
12:00:29 <Younder> nreh: where does it fail? mreh
12:00:38 <gwern> ... 1e parses as 1 e?
12:00:48 <mreh> you can't do things like: 1 000 000.01
12:00:59 <mreh> that's nonsensical
12:01:08 <Younder> 1 to the power og zip.. perfactly fine
12:01:17 <Younder> lol
12:01:30 <roconnor> > let e = 1 in (+) 0o1e
12:01:31 <lambdabot>   2
12:01:32 <gwern> sometimes I think haskell syntax really has gone too far
12:01:35 <roconnor> > let e = 1 in (+) 0x1e
12:01:36 <lambdabot>   {-3->27;-2->28;-1->29;0->30;1->31;2->32;3->33}
12:01:45 <zygoloid> haha lovely
12:02:02 <mreh> and useful also!
12:02:07 <roconnor> > (+) 0o18
12:02:08 <lambdabot>   9
12:02:28 <mauke> ok, that's just evil
12:02:31 <mreh> > 1 + 8
12:02:31 <lambdabot>   9
12:02:32 <mauke> what is this, perl?
12:02:36 <mreh> lol
12:02:57 <zygoloid> > let mm = 0.001 in (*) 5mm
12:02:59 <lambdabot>   5.0e-3
12:02:59 <mauke> (at least 018 is a tokenizer error in perl)
12:03:30 <zygoloid> > reads "0o18" :: [(Int,String)]
12:03:31 <lambdabot>   [(1,"8")]
12:03:45 <p_l> mauke: sometimes I suspect that some Haskell code looks like crack addict's love affair with reader macros in Lisp...
12:03:53 <zygoloid> > reads "0xEVIL" :: [(Int,String)]
12:03:54 <gwern> well, I don't really object to 018, since that's no weirder than say 1.810
12:03:55 <lambdabot>   [(14,"VIL")]
12:04:12 <Younder> zygoloid, I LOVE lisp...
12:04:26 <Younder> rotfl
12:04:34 <mreh> kick this guy
12:04:41 <gwern> p_l: that might be fun - take liskell and add enough macros that you've gotten back to haskell syntax
12:04:42 <mreh> just kidding
12:04:59 <roconnor> @quote stack-calculator
12:04:59 <lambdabot> stack-calculator says: let start f = f (); push s a f = f (a,s); add (a,(b,s)) f = f (a+b,s); end (a,_) = a in start push 2 push 3 add end
12:05:24 <Younder> Your lambdabot is very cool
12:05:40 <zygoloid> @vixen Tell Younder a little bit about yourself
12:05:41 <lambdabot> )
12:05:48 <gwern> p_l: such a thing would be haskelly in a sense - starting with simple syntax to get the more complex, instead of sort of hardwiring a lot of it
12:05:54 <zygoloid> @vixen More than that
12:05:54 <lambdabot> Most guys don't understand me, but we really seem to connect.
12:06:00 <b0fh_ua> Hi there! If I created module CarbonCopy/Storage/Storage.hs and CarbonCopy/Storage/Maildir/Basic.hs, and I want to import Storage into Basic - how should I do that? Use fully-qualified names?
12:06:01 <roconnor> > let start f = f (); end (a,_) = a; mm (a,b) = (a*10^-3,b) in start 5mm end
12:06:02 <lambdabot>   Not in scope: `^-'
12:06:09 <roconnor> > let start f = f (); end (a,_) = a; mm (a,b) = (a*10^^(-3),b) in start 5mm end
12:06:10 <lambdabot>   Ambiguous type variable `t' in the constraint:
12:06:10 <lambdabot>    `GHC.Real.Fractional t'
12:06:10 <lambdabot>  ...
12:06:23 <mreh> does anyone know the semantics of rSwitch in yampa?
12:06:25 <roconnor> ah crap
12:06:39 <mreh> I just give it a SF, but I don't understand what it does with it
12:07:04 <mreh> oh, they have a less efficient but clearer implementation apparently
12:07:07 <Younder> same thing with my AI's
12:07:20 <gwern> b0fh_ua: it'd be fully qualified I think
12:07:30 <b0fh_ua> that's sad
12:07:34 <Younder> casual conversation is not their forte
12:07:38 <mreh> Younder: could you fix my perceptron?
12:08:00 <Younder> that is my goal in life :)
12:08:11 <gwern> b0fh_ua: not sad - makes it easier to move stuff around between packages
12:08:13 <gwern> and in general
12:08:23 <roconnor> if (Int -> a) -> a were an instance of num then let mm = (*10^^(-3)) in 5mm would work.
12:09:01 <b0fh_ua> then I have to tune vim in some way to be able compile such kind of stuff
12:09:23 <mreh> Younder: a perceptron, if you are interested: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24082#a24082
12:09:49 <mreh> a broken perceptron
12:10:15 <Younder> mreh: I know what it is. I prefer Baesian inference.
12:10:38 <mreh> Younder: for fitting a function? that's a bit long winded
12:10:43 <mreh> it's a single layer perceptron
12:11:12 <gwern> mreh: but it's general. isn't that more haskelly?
12:11:14 <mreh> trained with back propagation with a sigmoid activation function
12:11:23 <Younder> gwern, it is
12:11:46 <Younder> mreh. the sigoid is soo passe
12:11:55 <Younder> sigmoid
12:12:00 <mreh> the task I have been given to build a perceptron, if I turned in a naive bayes classifier I would receive zero marks
12:12:24 <mreh> the sigmoid is better than the step function
12:12:38 <mreh> and I don't understand the tanh activation function
12:12:40 <Younder> so is shouting WOW ..
12:12:45 <Younder> lol
12:13:20 <monochrom> sigmoid and tanh are related. just some translation and scaling.
12:13:49 <mreh> the perceptron weights just keep falling and falling, it's weird
12:14:07 <monochrom> bugs
12:15:18 <mreh> given enough eyeballs: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24082#a24082
12:15:37 <mreh> lines 27-41, the update happens in w'
12:17:11 <Younder> The sigoid function is the loosers approcah to neural networks.. You got to do better mreh
12:17:48 <copumpkin> I prefer the tighters approach
12:18:08 <roconnor> Younder: what is the winner's approach?
12:18:40 <Younder> Baesian inference can do the whole neuron cluster roconnor
12:19:06 <Younder> wastly more efficent
12:19:10 <roconnor> I mean, what is the winner's approach to neural networks?
12:19:32 <copumpkin> using bayes to train a NN seems odd
12:19:35 <Younder> the approach is not to use them
12:19:39 <copumpkin> good
12:19:44 <copumpkin> I'm not a fan of NNs ;)
12:20:05 <monochrom> I'm not a fan of humanity.
12:20:17 <monochrom> Losers keep the human in the loop.
12:20:19 <copumpkin> I think people get boners over NNs because "omg we're related to them"
12:20:30 <Ke> Supreme robots >> humanity
12:21:17 <fax> if you connect the output of a neural network to the input does it become self conscious??
12:21:29 <Alpounet> Younder, there is a neural network library being under active development, if you're interested...
12:21:40 <p_l> fax: not
12:21:45 <copumpkin> fax: totally
12:22:11 <xerox> 'it' being the input, totally
12:22:36 <zygoloid> fax: yeah. it starts worrying about its appearance.
12:22:50 <monochrom> it says 'amirite?"
12:22:52 <copumpkin> the difference in connotation between self-conscious and self-aware is pretty extreme
12:23:10 <copumpkin> even though they mean roughly the same thing
12:23:25 <Younder> Alpounet, perhaps I didn't make myself clear.. I HATE neural nets as a approch to intelligence.
12:23:29 <twink> It'll spend hours doing its makeup in a 5x magnifying mirror.
12:23:54 <monochrom> but it'll do the makeup intelligently
12:24:29 <xerox> as much so as one would believe the make up was due to intelligent design
12:24:31 <Alpounet> Younder, oh ok
12:24:38 <Alpounet> Younder, like bayesian networks ?
12:24:44 <Alpounet> +do you
12:24:50 <twink> What, no evolution?
12:24:56 * copumpkin is all about the CRFs
12:25:06 <copumpkin> and/or markov logic networks
12:25:15 <Younder> Alpounet, baesian logic is intrinsically beautiful
12:25:35 <copumpkin> Younder: have you seen psykotic's fancy bayes topos stuff?
12:25:42 <Alpounet> huh copumpkin ?
12:26:22 <copumpkin> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23356
12:26:26 <copumpkin> Alpounet: huh to what?
12:26:34 <Younder> the trick is to do 10 000 neurons in one go. A function.
12:26:51 <Younder> sigh
12:27:15 <Alpounet> copumpkin, to what you said about psykotic's stuff
12:27:28 <copumpkin> Alpounet: I linked to the paste
12:27:38 <Alpounet> yeah, saw that
12:27:39 <Alpounet> thanks
12:27:41 <copumpkin> :)
12:28:06 <xerox> If AI worked at the time, now we'd be debugging using fMRI scans.
12:28:16 <danderson> bos: did you get my attoparsec patch in your email? (not sure if I set up my SMTP forwarder right, it may have been sent to spam)
12:31:19 <Younder> of cource I also like Perl..
12:31:37 <copumpkin> pervert!
12:31:57 <Younder> defpite it's knawly syntax lol
12:32:18 <conal> sinelaw: i still don't have a sense of what you're looking for, involving Processor, IO, and semantics.
12:33:35 <ErhardtMundt> afk
12:33:40 <Alpounet> @quote footprint
12:33:40 <lambdabot> No quotes match.
12:33:43 <Alpounet> hm
12:33:45 <ErhardtMundt> /away
12:34:15 <lowasser> anybody know how to deal with /home/lowasser/.cabal/lib/glib-0.10.5/ghc-6.12.1/HSglib-0.10.5.o: unknown symbol `g_value_unset' when building chart?
12:34:16 <Younder> gotta know what you gatta know
12:34:51 <Younder> like /leave
12:35:02 <ManateeLazyCat> I use command `darcs rollback --last 5`, and i found "Skipped rollback of 1 patch." output, how can i rollback that patch forcibly?
12:35:16 <Younder> -f
12:35:32 <lowasser> gahhh, I hate gtk and all its companions
12:35:36 <conal> sinelaw: my hunch is that you're wanting to implement some semantically pure abstractions on top of IO, and that you're looking for structure/rigor in doing so.  am i close?
12:37:15 <conal> lowasser: i'm with you.  and more broadly, i see functional/denotative programming as weighted down by legacy imperative OO GUI frameworks like gtk & wxwidgets.
12:37:44 <lowasser> yah
12:37:45 <conal> lowasser: like dinosaurs pulling us down into their tar pits
12:39:33 <Younder> conal, that IBM system is now lost in history
12:39:54 <lowasser> AHA, SUCCESS
12:40:01 <b0fh_ua> Hello! I have the datatype Message and constructor Email { from,to,subject :: String }. Now I want to create type MaildirMessage in another module, which should derive properties of Email constructor but add { filename :: String } property to hold the file name.
12:40:03 <conal> Younder: which ibm system?
12:40:26 <Younder> conal, look it up
12:40:36 <b0fh_ua> for some reason data MaildirMessage = MaildirMsg { filename :: String } deriving Email doesn't work
12:40:45 <conal> Younder: under what key?
12:40:46 <mauke> b0fh_ua: Email is not a class
12:40:52 <aledge> b0fh_ua, deriving doesn't mean what you think it means
12:41:06 <Twey> b0fh_ua: data MaildirMessage = MaildirMsg { filename :: String, email :: Message }
12:41:08 <Younder> conal, originally it was under MULTICS'
12:41:19 <conal> Younder: what are you responding to?
12:41:28 <ManateeLazyCat> conal: Or build Haskell toolkit framework. :) Joking.
12:41:32 <Younder> conal, you
12:41:45 <b0fh_ua> ah, looks like I mixed up typeclasses and data once again
12:41:49 <conal> does anyone have a clue what Younder is talking about?
12:42:05 <Younder> conal, yes
12:42:08 <b0fh_ua> so it is not possible to create inheritance of data types in Haskell?
12:42:13 <conal> anyone else?
12:42:26 <applicative> conal: no
12:42:42 <jmcarthur> not a clue
12:43:04 <monochrom> "that ibm system" "look it up" is uninformative.
12:43:22 <Younder> anyhow the multix system is ancient history. as is the dinosaur and tar bit
12:43:27 <monochrom> You would get OS/2 Warp that way.
12:44:03 <conal> Younder: for instance, to clarify you might share a quote that you're responding to
12:44:49 <jmcarthur> conal: i think Younder is responding to your dinosaur comment, but i don't really understand what it has to do with it
12:44:55 <monochrom> In the spirit of the scientific method and publish-or-perish, perhaps you should just ignore uninformative statements.
12:45:05 <Younder> conal, i's a book, with a dinosaur stuck in tar
12:45:35 <Hunner> monochrom: AIX?
12:45:39 <Younder> conal, if it's available on the net I can't find it
12:45:44 <ski> b0fh_ua : maybe you're thinking of subtyping ?
12:45:49 <conal> Younder: oh -- my dinosaur/tar-pit comment reminded you of a particular image on a book?
12:45:59 <ski> (if so, the answer is : no, Haskell doesn't have subtyping)
12:46:03 <Younder> conal,yes
12:46:06 <conal> ah
12:46:35 <monochrom> Hunner: Why should we guess? If the speaker is unable to speak sense, it is not our job to clarify it.
12:46:50 <conal> Younder: thx.  i was curious about what connection you might be making.
12:47:04 <Hunner> Myth of the man month... http://blog.ksplice.com/2010/03/quadruple-productivity-with-an-intern-army/ says it isn't true
12:47:45 <conal> monochrom: perhaps it's not that simple.  speaking "sense" depends on one's context.  so not a property solely of the utterance itself.
12:48:35 <conal> often people don't get what i'm saying, because the sense isn't apparent to them.
12:48:36 <monochrom> Sure, use context.
12:48:54 <conal> in which case an exchange can often help clarify.
12:49:13 <conal> i've come to see this phenomenon as how communication works in general.
12:49:28 <jmcarthur> this conversation reminds me of http://en.wikipedia.org/wiki/High_context_culture
12:49:32 <applicative> b0fh_ua: I wonder if you would do better without 'record syntax' for this, I feel like it's going to lead you astray.  Why not just   data Message = Email String String String
12:49:45 <conal> what's often tricky is predicting another person's context
12:50:24 <applicative> b0fh_ua: then    from (Email x _ _ ) = x      to (Email _ x _) = x    and so on
12:50:25 <conal> jmcarthur: thx for the link
12:50:37 <fax> hi conal
12:50:50 <conal> fax: hi
12:50:58 <ManateeLazyCat> I understand, if you want rollback last patch, you need rollback last *two* patches, otherwise, last patch will skip.
12:51:52 <jmcarthur> ManateeLazyCat: are you talking about darcs?
12:51:59 <ManateeLazyCat> jmcarthur: Yep.
12:52:11 <tibbe> dcoutts: around?
12:52:36 <Younder> really arn't there really any onl timers here. (form the 60's)
12:52:42 <Younder> old'
12:53:10 <ManateeLazyCat> jmcarthur: I want use "darcs rollback --last 5" rollback last patch of 5, so i need rollback last *two* patch when darcs prompted, if i just rollback last patch, darcs will skip last patch, and nothing changes.
12:53:35 <mreh> old timers? SPJ is pretty old
12:54:15 <ManateeLazyCat> jmcarthur: Simple, if i just want rollback last patch, i need argee patch (4/5) and (5/5).
12:54:24 <jmcarthur> ManateeLazyCat: is "last" referring to the latest patch (last in time) or the earliest patch (last in the sequence of prompts when rolling back)?
12:54:29 <mreh> most of the old timers don't have time to waste on irc i'll bet :)
12:54:45 <sinelaw> conal, yes.
12:54:47 <ManateeLazyCat> jmcarthur: earliest patch of 5
12:54:48 <Twey> (this is why we should avoid using ‘last’ to mean ‘previous’…)
12:54:55 <jmcarthur> ah
12:55:08 <ManateeLazyCat> jmcarthur: My analysis is right?
12:55:13 <jmcarthur> ManateeLazyCat: yeah, if patch 4 depends on patch 5 then you must roll back patch 4 in order to roll back patch 5
12:55:17 <b0fh_ua> ski: it depends on what suptyping is
12:55:21 <Younder> ManateeLazyCat, yes
12:55:37 <ManateeLazyCat> jmcarthur: I just confusion when first time use rollback command.
12:55:42 <mreh> does anyone know why I can't use variables from outside a rec block inside an arrow expression in a rec block?
12:55:46 <jmcarthur> ManateeLazyCat: if no patches depend on patch 5, though, you should be able to roll it back alone. it sounds like patch 4 depends on patch 5 in this case
12:55:51 * ManateeLazyCat Why darcs skip last patch? I want rollback it.
12:55:52 <mreh> I can pass them as input
12:56:06 <sinelaw> conal the idea is that _some_ of the things we do using IO, are actually somewhat equivalent to a -> b
12:56:15 <ManateeLazyCat> jmcarthur: Oh i see.
12:56:20 <sinelaw> if you find a way to hide the implementation details.
12:56:34 <Younder> I've never used darc's rollback command. But studying it's info. It should work as you say.
12:56:41 <sinelaw> conal in a way it's a replacement for unsafePerformIO that works in many more cases and also doesn't use any compiler trick.
12:56:47 <jmcarthur> ManateeLazyCat: basically, if i modify the same line in two patches and i want to roll back the earlier patch then darcs doesn't know what to do with the later one unless you also roll it back
12:56:47 <conal> sinelaw: and equivalent to other pure types
12:56:57 <sinelaw> conal yes. like the Ptr a thing.
12:56:59 <jmcarthur> *unless i also roll it back
12:56:59 <ManateeLazyCat> jmcarthur: So darcs will analysis those dependent automatically?
12:57:04 <jmcarthur> ManateeLazyCat: yes
12:57:11 <conal> sinelaw: all of haskell is implemented with unsafePerformIO, except for IO.
12:57:36 <ski> b0fh_ua : subtyping is that whenever `T0' is a subtype of `T1', then if an expression `e' has type `T0', then it can also be used as if having type `T1'
12:57:38 <ManateeLazyCat> jmcarthur: I can rollback earlier patch alone if haven't any dependent, otherwise darcs skip it for safe?
12:57:39 <sinelaw> conal but not everything is easy / even possible? to bind to using unsafePerformIO
12:57:45 <jmcarthur> ManateeLazyCat: exactly
12:58:01 <sinelaw> conal for example things that require global state for all their invocations
12:58:02 <Younder> ManateeLazyCat, yes, it analysises you commands
12:58:03 <conal> sinelaw: right.
12:58:12 <mreh> all of haskell is implemented using unsafePerformIO?
12:58:18 <ManateeLazyCat> Darcs is smart. :)
12:58:25 <jmcarthur> :)
12:58:28 <Younder> ManateeLazyCat, and it's dependants
12:58:34 <conal> sinelaw: i make my comment to point out that the question you're asking is an old & well-explored one.
12:58:43 <sinelaw> conal ah.
12:58:43 <Younder> ManateeLazyCat, yes
12:58:47 * imperative_cat is confused
12:58:52 <conal> sinelaw: and so there's some theory to look to.
12:59:07 <ski> b0fh_ua : e.g. a record type specifying fields `from',`to',`subject',`filename', all which should have values of type `String', is a subtype of the record type specifying fields `from',`to',`subject', all which should have values of type `String'
12:59:08 <Twey> pull tail >> tweak ears
12:59:08 <sinelaw> conal so is my solution also well-explored?
12:59:24 <conal> sinelaw: i don't know what your solution is
12:59:25 <sinelaw> conal in a way i want to _restrict_ what the IO monad was invented to allow
12:59:35 * imperative_cat is not amused
12:59:48 <yitz> mreh: i think he means that all non-IO code must ultimately be run unsafely in the IO monad.
12:59:51 <conal> sinelaw: as does all of functional/denotative programming
13:00:18 <sinelaw> conal, it's pretty simple. i'm sure it's been thought of. all i do is restrict usage of IO to a single pattern that (under certain conditions) should be equivalent to a -> b
13:00:21 <Younder> darcs is one of the things i love about haskell. so much better than git
13:00:23 <ManateeLazyCat> Infact, Darcs not need any Graphics Interface for friendly, because it always ask you many questions. :)
13:00:30 <conal> yitz: no.  i mean that there's a lot of imperative stuff inside the implementation of the pure building blocs we work with all the time.
13:00:47 <yitz> conal: oh ok
13:00:51 <conal> e.g. (+)
13:00:54 <sinelaw> conal that pattern is: nested allocations // deallocations and sequenced processing in the midst
13:00:57 <conal> and function application
13:01:08 <sinelaw> conal something like
13:01:09 <yitz> conal: why is (+) imperative?
13:01:39 <sinelaw> conal oops. something like Oleg's regions, though i didn't really try to understand that yet, and i think that one doesn't give the chaining / sequencing part
13:01:42 <conal> yitz: it's not.  the implementation is.  and conceptually wrapped in unsafePerformIO
13:01:44 <Younder> (+) 1 2 3 as opposed to 1 + 2 + 3'
13:01:55 <yitz> conal: true
13:01:56 <jmcarthur> sinelaw: what do you mean chaining and sequencing?
13:02:05 <Younder> wery LISP'ish
13:02:05 <mreh> Younder: huh?
13:02:06 <fax> Younder whuh?
13:02:13 <mreh> :)
13:02:23 <aledge> (+ 1 2 3 4 5)
13:02:23 <fax> (+ 1 2 3) in lisp
13:02:48 <mreh> + 1 2 has kind *
13:02:50 <tilarids> does anybody know when code.haskell.org will be online again?
13:03:23 <sinelaw> jmcarthur i mean: p1 >>> p2 on processors means: alloc p1; alloc p2; a -> process p1 -> b, b ->  process p2  -> c; free p2; free p1;
13:03:24 <conal> sinelaw: maybe there's something to be learned from runST
13:03:31 * ski dislikes the name `unsafePerformIO' .. it would be better if it was called `promiseIOPure' or something like that
13:03:59 <Zao> escapeHatch
13:03:59 * conal is with ski.  i also like 'performSafeIO' as an alternative.
13:04:22 <fax> haha
13:04:25 <conal> i meant 'safePerformIO', but i now i think i prefer 'performSafeIO'
13:04:26 <ski> (the emphasis shouldn't be on that "anything can happen", but that the proof obligation of safety in this case lies on the programmer, and if that is met, the compiler is not allowed to behave arbitrarily)
13:04:27 <jmcarthur> sinelaw: why not  alloc p1; a -> process p1 -> b; free p1; alloc p2; b -> process p2 -> c; free p2  ?
13:04:43 <conal> ski: yes!
13:04:50 <sinelaw> jmcarthur consider looping on the processing part
13:04:50 <fax> Younder?
13:04:54 <mreh> safePerformIO /= unsafePerformIO
13:05:11 <jmcarthur> sinelaw: oh, the arrow parts are persistant, not sequential steps?
13:05:12 * imperative_cat is very confused
13:05:12 <ManateeLazyCat> jmcarthur: I can revert any rollback patch even it have dependent between patches? rollback is always safe becase rollback is also new patch base on before ones, right?
13:05:15 <conal> mreh: right.  safePerformIO is a subset of unsafePerform
13:05:20 <ski> conal : imo, Mercury has understood this better than Haskell
13:05:35 <mreh> conal: agreed
13:05:54 <sinelaw> jmcarthur what do you mean
13:06:03 <jmcarthur> ManateeLazyCat: if other patches depend on the rollback patch, you can't unrecord/obliterate it without also unrecording/oblitering the other patches
13:06:03 <yitz> mreh: is cheshire known for imperative programming?
13:06:12 <mreh> I understand what you're talking about now
13:06:20 <jmcarthur> ManateeLazyCat: if no patch depends on it then it's safe to unrecord/obliterate
13:06:29 <jmcarthur> ManateeLazyCat: darcs will check this for you
13:06:31 <sinelaw> jmcarthur i supply a primitive for running the thing in the middle in a loop until a predicate occurs, so during that time i want to be inside the allocations
13:06:34 <mreh> yitz: more for its crumbly honey flavoured cheese
13:06:47 <jmcarthur> sinelaw: okay i see
13:06:52 <mreh> I think ogres live in cheshire too
13:07:02 <tilarids> anybody? I really want to get some code from code.haskell.org today and it is offline. What is going on with it?
13:07:08 <jmcarthur> sinelaw: i was unclear whether -> b  and -> c where mere bindings or if they were imperative assignments
13:07:11 <Younder> fax, perhaps there are dark corners of Haskell you have yet to learn.
13:07:23 <sinelaw> jmcarthur bindings, if i get what you mean.
13:07:26 * crumbly_honey_fl is confused
13:07:38 <mreh> yitz: have you seen lambda cats?
13:07:48 <ManateeLazyCat> jmcarthur: So if have dependent between patches, i still can undo, just i need undo more patches, right?
13:08:16 <yitz> mreh: a while back. but lambda cats don't continually appear and disappear. cheshire cats do.
13:08:18 <sinelaw> does runST have something like this? allowing both nested allocations and chaining the inner operations? with a functional interface?
13:08:22 <jmcarthur> sinelaw: you could use Writer to queue up some things you need to allocate and then allocate them all in one place in your run function
13:08:42 <sinelaw> jmcarthur i sort of do that with my combinators
13:09:05 <jmcarthur> perhaps State would be better to prevent allocating multiples of the same thing
13:09:09 <mreh> I need a yampa integral that switches back to zero upon sufficient evaluations
13:09:21 <ManateeLazyCat> sinelaw: runST remove all *temporary* variable from you function, and make your code more flexibility.
13:09:21 <jmcarthur> ManateeLazyCat: if i understand you correctly, yes
13:09:45 <mreh> not zero, but some value
13:09:47 <jmcarthur> yeah that's a good intuition. ST gives you temporary mutable variables
13:10:02 <sinelaw> jmcarthur but i actually do need to do IO
13:10:10 <ManateeLazyCat> jmcarthur: In technology, Darcs always safe, just harder to undo when have more dependent.
13:10:18 <jmcarthur> sinelaw: is your run function in the IO monad?
13:10:39 <sinelaw> jmcarthur in all cases i can think of, yes.
13:10:44 <ManateeLazyCat> sinelaw: You can use `lift` to run any IO moand in runStateT
13:10:58 <jmcarthur> ManateeLazyCat: yes. darcs will not allow you to end up with patches that are missing their dependencies at all
13:11:20 <jmcarthur> sinelaw: then you should be able to just wrap IO up in your abstraction, right?
13:11:26 <ManateeLazyCat> jmcarthur: Oh, so cool. I'm handling some bad patch in gtk2hs.
13:11:30 <sinelaw> ok i'll take a look at runST, but i'm skeptic it's what i need here.
13:11:38 <sinelaw> jmcarthur yes. I can.
13:11:44 <yitz> @hoogle stToIO
13:11:45 <lambdabot> Control.Monad.ST stToIO :: ST RealWorld a -> IO a
13:11:45 <lambdabot> Control.Monad.ST.Lazy stToIO :: ST RealWorld a -> IO a
13:11:45 <lambdabot> Control.Monad.ST unsafeSTToIO :: ST s a -> IO a
13:11:52 <mreh> why don't girls like me?
13:11:52 <ManateeLazyCat> sinelaw: Need example code for runStateT?
13:12:06 <ManateeLazyCat> sinelaw: I have many code about this.
13:12:09 <fax> Younder "perhaps there are dark corners of Haskell you have yet to learn" -- or you are just talking nonsense ?
13:12:10 <yitz> mreh: you can ask lambdabot, using @vixen
13:12:21 <mreh> @vixen Why don't girls like me?
13:12:21 <lambdabot> why don't you guess?
13:12:22 <fax> gonna go with option 2
13:12:29 <sinelaw> ManateeLazyCat thanks but i'll start by reading the docs / interface
13:12:33 * ManateeLazyCat pasted "runStateT example code." at http://paste2.org/get/721616
13:12:36 <ManateeLazyCat> sinelaw: Above.
13:12:37 <jmcarthur> @vixen Why do girls like me?
13:12:37 <lambdabot> first you tell me.
13:12:56 <ManateeLazyCat> sinelaw: runStateT not complicated once you understand.
13:12:56 <Twey> @vixen What is your name?
13:12:57 <lambdabot> My name is Emily
13:13:05 <mreh> is she a chat bot?
13:13:06 <jmcarthur> @vixen Do you like mreh?
13:13:06 <lambdabot> i'd say i like
13:13:07 <Twey> Emily she is indeed.
13:13:17 <mreh> oh Emily
13:13:21 <ManateeLazyCat> sinelaw: IMO, don't confusion with `s m a`, just try to use it in your code.
13:13:27 <yitz> @vixen are you a chat bot?
13:13:28 <lambdabot> no, why? do i seem "botty"?
13:13:39 <stevenmarky> Emily said botty lol.
13:13:42 <ManateeLazyCat> sinelaw: When you use many times, you will know: oh, it's so simple. :)
13:14:14 <sinelaw> jmcarthur http://github.com/sinelaw/cv-combinators/blob/master/src/Test.hs
13:14:33 <sinelaw> jmcarthur ^^^ usage of above library with IO actions to give an arrow interface
13:14:46 <ManateeLazyCat> sinelaw: The best thing is, once you use runStateT, you can remove all *temporary* variable in your function, and you can changes those *state code* sequence anytime.
13:15:00 <jmcarthur> sinelaw: what is it that you are unhappy with?
13:15:35 <sinelaw> ManateeLazyCat i actually really DON'T want to use mutable variables. i'm trying to get rid of any usage of them by wrapping things that do IO with my library.
13:15:37 <ManateeLazyCat> jmcarthur: I unhappy some many *temporary* variable in everywhere before StateT moand. :)
13:15:49 <Younder> seems beautiful to me
13:15:49 <sinelaw> sinelaw, the semantic model
13:16:11 <jmcarthur> sinelaw: oh so it's the interface you don't like, not the implementation?
13:16:12 <Younder> sinelaw, it is FUNCTIONAL
13:16:26 <ManateeLazyCat> sinelaw: Just transform *pure* variable in your function, then return new value by function.
13:16:40 <sinelaw> jmcarthur the interface looks good. it's just not precisely designed yet. so i can't be sure
13:16:47 <jmcarthur> ManateeLazyCat: i think sinelaw is using some impure FFI stuff
13:16:49 <sinelaw> Younder yes, i know.
13:16:51 <sinelaw> :)
13:17:11 <jmcarthur> ManateeLazyCat: so switching from IO to State is probably impossible
13:17:13 <ManateeLazyCat> sinelaw: Then you have many small *pure* functions, then you can use runStateT connect those small *pure* function with *bigger* pure fucntions.
13:17:44 <ManateeLazyCat> jmcarthur: So use TVar that separate IO Moand and STM Monad.
13:17:49 <sinelaw> Younder, jmcarthur btw, you can compare  that to: http://github.com/sinelaw/HOpenCV/blob/master/src/Test.hs
13:18:05 <Younder> don't use monads unless you have to
13:18:10 <jmcarthur> sinelaw: are you thinking about an applicative interface or something?
13:18:14 <jmcarthur> Younder: you never have to
13:18:19 <jmcarthur> Younder: monads are useful abstractions
13:18:23 <ManateeLazyCat> jmcarthur: Just make FFI stuff in IO Monad, then TVar contain non-FFI stuff.
13:18:28 <Younder> jmcarthur, I wish
13:18:29 <sinelaw> jmcarthur my datatype is already an instance of Category, Functor, Applicative and Arrow
13:18:32 <jmcarthur> ManateeLazyCat: why use TVars?
13:18:37 <jmcarthur> sinelaw: ah :)
13:18:51 <mreh> @vixen When I was young I asked my mother what shall I be.
13:18:51 <lambdabot> love is all you need, you know?
13:18:52 <jmcarthur> Younder: i'm serious (with the one exception of IO)
13:19:05 <mreh> she's good
13:19:17 <ManateeLazyCat> jmcarthur: One, TVar haven't mutex problem with MVar. TWo, TVar can as reference to some FFI stuff, example callback in gtk2hs.
13:19:26 <Younder> jmcarthur, you don't need them in IO either
13:19:29 <mreh> unless that was a coincidence she replied with a song lyric
13:19:32 <sinelaw> jmcarthur and i'm trying to eliminate (or hide) that need.
13:19:46 <ManateeLazyCat> jmcarthur: You don't know when those callback call, so you need use TVar transform-in it.
13:19:51 <Younder> jmcarthur, their just beneficcial
13:19:52 <jmcarthur> Younder: you do if you don't dig into the GHC modules
13:20:02 <jmcarthur> Younder: but you don't need monads for anything else
13:20:03 <sinelaw> even for things that can't be wrapped with unsafePerformIO
13:20:09 <ManateeLazyCat> jmcarthur: Because STM protected, so you won't do bad thing.
13:20:21 <FliPPeh__> Which big haskell project would you recommend to me, to learn about good haskell coding?
13:20:25 <FliPPeh__> XMonad? Lambdabot?
13:20:37 <jmcarthur> ManateeLazyCat: you must have info about what sinelaw is doing that i don't. i'm not aware of any concurrency issues
13:20:47 <Younder> jmcarthur, monads are the key to efficiency
13:20:55 <jmcarthur> Younder: efficiency?
13:20:58 <jmcarthur> monads are just an abstraction
13:21:00 <sinelaw> Younder why?
13:21:04 <kmc> saying "don't use monads unless you have to" is like saying "don't use map unless you have to"
13:21:05 <sinelaw> a monad is just an interface
13:21:18 <Younder> jmcarthur, (see purly functional data structures)
13:21:21 <mreh> FliPPeh__: I haven't done any of those, just do something you're interested in
13:21:30 <jmcarthur> Younder: monads have nothing to do with purely functional data structures
13:21:33 <mreh> if you're interested in tiling window managers
13:21:36 <mreh> do xmonad
13:21:49 <Younder> jmcarthur, no they don't
13:21:51 <jmcarthur> Younder: monads are just an abstraction. they don't make anything more efficient
13:22:02 <danderson> Younder: how does, say, the State monad, end up being more efficient than just a Foo -> Foo function?
13:22:06 <FliPPeh__> mreh: I've done quite a bit already, I just always fail when it comes to "advanced" stuff.. like making good use of typeclasses or monads
13:22:06 <Alpounet> FliPPeh__, xmonad, definitely
13:22:11 <Younder> you seem confused
13:22:23 <Alpounet> it is a nice piece of Haskell software
13:22:24 <jmcarthur> i'm only confused about what kind of point you are trying to make
13:22:30 <danderson> I tried implementing a BGP state machine with the State monad, but it ended up being uglier than just passing the state around explicitly
13:22:33 <jmcarthur> does anybody else understand what Younder is getting at?
13:22:38 <ManateeLazyCat> sinelaw: Yep. Like interface, make you can thinking high-level.
13:23:07 <jmcarthur> Younder: what is your native language?
13:23:08 <mreh> #haskell is not a competition last time I looked
13:23:17 <monochrom> you seem confused
13:23:22 <Younder> jmcarthur, norsk
13:23:37 <sinelaw> monochrom you seem confused
13:23:47 <monochrom> I seem confused too :)
13:23:58 * imperative_cat is confused
13:24:05 <mog> heh
13:24:05 <ManateeLazyCat> sinelaw: Me too.
13:24:06 <Younder> rotfl
13:24:07 <monochrom> hehehe
13:24:13 <MadHatterDude> Damn... I have a peice of C code that should by all means work.
13:24:30 <MadHatterDude> I widh I could do it in haskell...
13:24:39 <MadHatterDude> wish*
13:25:15 <ManateeLazyCat> MadHatterDude: Use FFI, then you don't rewrite it, just wrap it. :)
13:25:17 <mreh> FliPPeh___ typeclasses? how so?
13:25:52 <FliPPeh__> Don't know :/
13:25:53 <ManateeLazyCat> sinelaw: Search "All about Monad" in HaskellWiki. :)
13:26:01 <mreh> FliPPeh__, I use typclasses only when I'm writing monadic code
13:26:07 <mreh> i mean generic code
13:26:08 <mreh> bleh
13:26:45 <MadHatterDude> ManateeLazyCat: Yeah, but it operates on large arrays (bitmap pictures)
13:27:21 <mreh> is there an alternative to (id *** arr f)?
13:27:33 <mreh> is there an alternative to (id &&& arr f) even?
13:27:39 <mreh> the first is just "second"
13:27:44 <Younder> yes
13:27:44 <fax> :t id &&& arr f
13:27:45 <lambdabot> forall b c'. (Show b, SimpleReflect.FromExpr c') => b -> (b, c')
13:27:47 <fax> :t id &&& arr ?f
13:27:48 <sinelaw> MadHatterDude what does the lib do?
13:27:48 <lambdabot> forall b c'. (?f::b -> c') => b -> (b, c')
13:27:55 <specofdust> need help in c++
13:28:05 <sinelaw> mreh, Saizan knows all the equivalences :)
13:28:07 <Younder> mref: why do you care
13:28:09 <specofdust> anyone
13:28:24 <fax> specofdust I don't know C+
13:28:28 <MadHatterDude> sinelaw: its not a lib (yet) its a console tool for making pretty pictures of brownian motion (random walk)
13:28:29 <ManateeLazyCat> jmcarthur: Darcs is so smart, it rollback patch so easy. :)
13:28:38 <jmcarthur> specofdust: i know ##c++ isn't a very helpful bunch, but this isn't really in the scope of #haskell
13:28:43 <mreh> Younder: I keep writing it, I like to save typing
13:28:44 <ManateeLazyCat> jmcarthur: I just type "darcs rollback --help", then problem fix.
13:28:46 <jmcarthur> doh
13:28:52 <jmcarthur> ManateeLazyCat: yay!
13:28:56 <Younder> specofdust, join the 'C++' group then. This is haskell
13:29:06 <mreh> so I came all the way to an IRC channel to type the question out
13:29:13 <jmcarthur> mreh: i write that one a lot too
13:29:14 <fax> specofdust; why don't you rread the bruce eckel book??
13:29:15 <mreh> and then type responses to the answers
13:29:19 <fax> specofdust; it's about C++
13:29:29 <mreh> jmcarthur: It's loooon
13:29:30 <mreh> g
13:29:35 <sinelaw> MadHatterDude hmm.... you can use the FFI without bringing the images to haskell. i am JUST doing something like this with OpenCV.
13:29:38 <Alpounet> he has quit fax
13:29:45 <Younder> I HATE C++....
13:29:51 <sinelaw> me too.
13:30:06 <burp> not many here who like it
13:30:08 * ManateeLazyCat Webkit patch push by Axel can't compile pass, rollback it, re-push after test okay.
13:30:30 <ManateeLazyCat> Younder: Jave or C is better than C++
13:30:52 <stevenmarky> I like C++
13:30:56 <ManateeLazyCat> Younder: If you want the control of low-level, C enough
13:30:58 <lowasser> can we veto having this argument here?
13:31:02 <fax> you must be good at C++
13:31:06 <MadHatterDude> sinelaw: My problem isn't that great even, I just cannot for the life of me figgure out why I can somehow take a colour value, extract the red green and blue components, modify them, put them back together and put them in the bitmap, yet nothing happens,
13:31:12 <[swift]> i like templates =)
13:31:12 <jmcarthur> @pl \f -> id &&& arr f
13:31:12 <lambdabot> (id &&&) . arr
13:31:13 <lowasser> argue over non-Haskell languages elsewhere =P
13:31:20 <aavogt> so has anyone had success with graphics-drawingcombinators
13:31:30 <[swift]> haskell has templates too, or so i understand, so that's ideal
13:31:33 <lowasser> jmcarthur: that's equivalent to second (arr f), which might be easier
13:31:34 <jmcarthur> aavogt: i have had success with older versions. haven't tried latest
13:31:37 <FliPPeh__> !seen flippeh
13:31:40 <ManateeLazyCat> MadHatterDude: What's library you use? Yourself code?
13:31:43 <FliPPeh__> @seen flippeh__
13:31:43 <lambdabot> Unknown command, try @list
13:31:46 <FliPPeh__> :/
13:31:50 <FliPPeh__> I just want it to say my name
13:31:54 <MadHatterDude> [swift]: Haskell has polymnorfism and type constructors
13:31:55 <jmcarthur> lowasser: are you sure?
13:31:56 <ManateeLazyCat> MadHatterDude: Or you can consider switch to gtk2hs.
13:31:59 <ManateeLazyCat> :)
13:32:03 <Younder> fax, I am, I just hate it
13:32:03 <jmcarthur> :t \f -> id &&& arr f
13:32:04 <lambdabot> forall b c'. (b -> c') -> b -> (b, c')
13:32:05 <aavogt> I can get static stuff drawn, but I have not managed stuff with `sample'
13:32:07 <lowasser> almost, one mo'
13:32:11 <MadHatterDude> ManateeLazyCat: Yes, and I know it works.
13:32:13 <jmcarthur> :t \f -> second (arr f)
13:32:15 <lambdabot> forall b c (a :: * -> * -> *) d. (Arrow a) => (b -> c) -> a (d, b) (d, c)
13:32:15 <[swift]> MadHatterDude: isn't there template Haskell tho? i haven't used it, but i've seen it around
13:32:16 <aavogt> jmcarthur: have you managed to do stuff with the contents of  Image?
13:32:28 <lowasser> hmmm
13:32:29 <ManateeLazyCat> MadHatterDude: You can use cairo render it.
13:32:45 <MadHatterDude> [swift]: I think template haskell is more about compile time calculations but i'm not sure...
13:32:51 <jmcarthur> aavogt: it's been a while. let me check the docs and remind myself what i did
13:32:58 <[swift]> MadHatterDude: that's exactly what templates are for, though =)
13:33:02 <Younder> fax, mostly I program in C and Python. Then Haskell.
13:33:08 <lowasser> oh wait I was mixing up &&& and ***
13:33:13 <aavogt> thanks
13:33:20 <fax> okay
13:34:03 <MadHatterDude> ManateeLC: I just need to write it to a file (wirte(FILE*, image) wich I am sure works) I think it is in the colour-putting-back-together or the put-in-bitmap reoutine...
13:34:06 <thoughtpolice> template haskell == compile time code generation
13:34:22 <jmcarthur> aavogt: oh, sample is something i don't think i've used
13:34:54 <jmcarthur> aavogt: it wasn't around when i used the library
13:35:01 <kmc> you would use Template Haskell for some of the very fancy uses of C++ templates (or, say, LISP macros)
13:35:19 <kmc> and for a lot of things that can't be done with C++ templates
13:35:28 <kmc> like autogenerating boilerplate code from a datatype declaration
13:35:32 <ManateeLazyCat> MadHatterDude: In Gtk+ library have similar library? Perhaps haven't binding into gtk2hs....
13:35:37 <Younder> file handeling in Haskell sucks badly
13:35:37 <aavogt> hmm, it seems that with sample I do get some varying output, but the rendering isn't there
13:35:47 <jmcarthur> Younder: stop trolling
13:35:52 <thoughtpolice> one thing that's somewhat annoying about template haskell as a dependency is that when the syntax changes, the changes need to be (and should be) reflected in template-haskell, which sometimes breaks things.
13:35:52 <jmcarthur> :)
13:36:05 <ManateeLazyCat> MadHatterDude: So you need large list or matrix to contain those pixel?
13:36:08 <Younder> jmcarthur, I wish I was
13:36:09 <MadHatterDude> Younder: You just need to let go of you FILE*
13:36:23 <kmc> Haskell has some of the more straightforward forms of abstraction that are missing in C++, so we don't need to resort to compile-time metaprogramming as often
13:36:27 <jmcarthur> Younder: honestly, file handling in haskell isn't any different than any other language
13:36:27 <thoughtpolice> but that's fairly rare these days, noticably it happened with ghc 6.12 i believe
13:36:45 <jmcarthur> Younder: it may suck, but if it does then file handling in every language that i know of sucks
13:36:46 <kmc> TH is a powerful tool of last resort
13:36:54 <Younder> I  am actually a lisper so a (with-open file would be better
13:37:00 <MadHatterDude> ManateeLC: My program is only ~300 lines and I only have one bug. But yes.
13:37:07 <lament> I just fixed the last bug.
13:37:14 <sinelaw> in the universe.
13:37:18 <jmcarthur> Younder: you mean scoped file handles?
13:37:19 <kmc> Younder, you mean withFile?
13:37:22 <kmc> @type withFile
13:37:23 <lambdabot> Not in scope: `withFile'
13:37:28 <kmc> withFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r	
13:37:30 <jmcarthur> :t System.IO.withFile
13:37:31 <lambdabot> forall r. FilePath -> GHC.IOBase.IOMode -> (GHC.IOBase.Handle -> IO r) -> IO r
13:37:35 <thoughtpolice> Younder: why does it suck? i think there are some problems with lazy IO, built not file handling in general
13:37:39 <MadHatterDude> Younder: most interpreted lisps use FILE*
13:37:42 <monochrom> @type id &&& arr (const True)
13:37:43 <lambdabot> forall b. b -> (b, Bool)
13:37:54 <monochrom> Sorry!
13:37:59 <Younder> lazy IO IS the problem
13:38:08 <jmcarthur> then don't use lazy IO
13:38:09 <thoughtpolice> Younder: one neat thing is you can use a library called 'safer-file-handles' which uses types to guarantee that file handles don't leak
13:38:12 <fax> applicative?
13:38:13 <kmc> Younder, then don't use lazy IO.  it's not even an option in most languages
13:38:14 <monochrom> Err maybe it's useful afterall
13:38:18 <thoughtpolice> gah, i can't type today
13:38:34 <MadHatterDude> fax: You know fmap?
13:38:39 <fax> yes
13:38:43 <fax> lol
13:38:55 <fax> I mean the user called applicative
13:39:06 <MadHatterDude> fax: sry
13:39:22 <thoughtpolice> Younder: i agree with oleg, lazy IO is somewhat of an abomination when you consider a pure function is doing IO in the background (thanks unsafeInterleaveIO!), but iteratees are a decent solution that provide more deterministic resource guarantees
13:39:27 * MadHatterDude considers changing name to Comonad
13:40:45 <thoughtpolice> Younder: in general though, I just avoid lazy IO when possible
13:41:11 <Younder> OK, You need you monads to IO.And if you use them it works ok.
13:41:24 <jmcarthur> ...?
13:41:55 <jmcarthur> oh as opposed to lazy IO
13:42:03 * Younder always uses monads for I/O
13:42:14 <Younder> jmcarthur, yes
13:42:27 <jmcarthur> strict IO doesn't necessarily mean monadic
13:42:28 <Axman6> Younder: i don't believe there's much alternative
13:42:37 <jmcarthur> we just don't have a giid alternative yet
13:42:39 <MadHatterDude> Younder: Isn't Monadic IO usually  lazy
13:42:41 <jmcarthur> *good, even
13:42:43 <thoughtpolice> Younder: i'm not sure what you mean 'works ok', can you elaborate please?
13:42:45 <Younder> Axman6, there iisn't
13:43:16 <jmcarthur> FRP is an attempt, but i'm honestly not sure how to apply it to things like file operations
13:43:25 <Younder> MadHatterDude, no
13:43:38 <sinelaw> jmcarthur maybe with my lib :)
13:43:41 <MadHatterDude> Younder: ok...
13:44:29 <Younder> and i refuse to anser anyone with the title thougtpolice
13:44:29 <ManateeLazyCat> @seen Morrow
13:44:29 <lambdabot> Unknown command, try @list
13:44:35 <Alpounet> sinelaw, saving a capture to a file would then become the composition of an IO processor and a file processor ? =)
13:44:45 <ManateeLazyCat> @list
13:44:46 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
13:44:51 <sinelaw> Alpounet yes.
13:45:01 <Alpounet> neat
13:45:28 <sinelaw> Alpounet actually if you're doing video writing, opencv has stuff for that so i can implement it right now.
13:45:29 <thoughtpolice> Younder: :(
13:45:30 <jmcarthur> Younder: surely thoughtpolice is not actually trying to promote the idea of thought police
13:45:38 <sinelaw> jmcarthur so you claim.
13:45:49 <sinelaw> accomplice.
13:45:53 <sinelaw> accumpolice
13:46:04 <Axman6> ew
13:46:06 <allbery_b> preflex: seen Morrow
13:46:06 <preflex>  Sorry, I haven't seen Morrow
13:46:09 <sinelaw> accumpolice is a nice nick
13:46:15 <Axman6> preflex: seen mmorrow
13:46:16 <preflex>  mmorrow was last seen on #ghc 58 days, 17 hours, 48 minutes and 30 seconds ago, saying: * mmorrow is rtfm'ing
13:46:23 <ivanm> preflex: seen lunabot
13:46:23 <preflex>  lunabot was last seen on #haskell 46 days, 13 hours, 23 minutes and 36 seconds ago, saying:  31
13:46:24 <sinelaw> what's up with him :(
13:46:27 <Axman6> oh no :O
13:46:27 <allbery_b> I gather @seen got illed so preflex is doing it now.  "yay" bot proliferation
13:46:35 <Younder> change you nick..
13:46:42 <ManateeLazyCat> 58 days?
13:47:02 <Alpounet> sinelaw, no hurry
13:47:11 <Alpounet> it's more the combinator library that I fond of interest
13:47:15 <ivanm> allbery_b: @seen was removed a while back, since it kept leaking memory and was the main reason lambdabot kept crashing
13:47:17 <Alpounet> its application with OpenCV is of course great
13:47:35 <sinelaw> Alpounet yes :) it was what made me do it
13:47:39 * ivanm wishes that using @seen now just had lambdabot ask preflex or at least told the user to ask preflex 
13:47:41 <Younder> no, thoughtpolice
13:47:41 <sinelaw> but the library is general
13:47:43 <Alpounet> and can be the base to write a webcam sharing software, or so
13:48:01 <ManateeLazyCat> The author of regex-tdfa haven't update? I depend parsec-2.1.0.1 (too old).
13:48:02 * djahandarie waits for the day lambdabot is rewritten
13:48:02 <Alpounet> Inter-Bot Communication
13:48:04 <Younder> thoughtpolice is sucky name
13:48:05 <allbery_b> interesting.  I'm not seeing that with lopbot, only crashes I get are from ircd connection weirdness
13:48:27 <sinelaw> Alpounet i'm going to build a robot with it
13:48:33 <Saizan> djahandarie: rewrite it!
13:48:34 <fax> Matt Morrow <mjm2002@gmail.com>
13:48:36 <thoughtpolice> jmcarthur: in reality it wouldn't matter either way, because either i am not THE thought police, and you're safe, or i am, and it's already been decided whether or not you're a thoughtcriminal ;)
13:48:59 * thoughtpolice hasn't read that book in a looong time
13:49:15 <Alpounet> sinelaw, huh ? what will it do ?
13:49:32 * ManateeLazyCat pasted "ghc-pkg check" at http://paste2.org/get/721643
13:49:37 <ManateeLazyCat> Any problem with above?
13:49:48 <ivanm> thoughtpolice: which book?
13:49:59 <ManateeLazyCat> I have install those packages successful.
13:49:59 <djahandarie> Saizan, haha, I don't think it'd come out as nice as if some of the pros in here wrote it. ;)
13:50:01 <sinelaw> Alpounet chase people around maybe :)
13:50:07 <Younder> it is difficult to type
13:50:09 <sinelaw> Alpounet it's just a demonstration, it won't do much.
13:50:12 <thoughtpolice> ivanm: 1984
13:50:20 <ivanm> ahhh, yes
13:50:35 <Younder> th ends up as thorkilnaur_
13:50:36 <sinelaw> optimistic book
13:50:42 <Younder> lol
13:50:49 <ivanm> ManateeLazyCat: well, yes except you obviously upgraded/downgraded network and Cabal
13:50:57 <ivanm> so you need to rebuild the packages that depend upon it
13:51:02 <sinelaw> china is becoming like that, but also the UK is laying the technical foundations for it with all those cameras
13:51:12 <sinelaw> and other countries. </blah>
13:51:14 <ivanm> ManateeLazyCat: actually, looks like you stuffed up GHC
13:51:15 <Saizan> looks more like he reinstalled the same version.
13:51:22 <flazz> i'm expecting a Float but an Int is inferred, what can i do?
13:51:22 <ivanm> did you unregister the version of Cabal that came with GHC?
13:51:31 <ManateeLazyCat> ivanm: No.
13:51:41 <Saizan> ManateeLazyCat: can you paste "ghc-pkg list" too?
13:51:42 <MadHatterDude> I GOT IT! HAHA! Die you filthy bug!
13:51:42 <ManateeLazyCat> ivanm: I just install newest version Cabal.
13:51:43 <ivanm> ghc-pkg check says otherwise :p
13:51:49 <ManateeLazyCat> Saizan: Okay.
13:51:51 <ivanm> flazz: fromIntegral?
13:51:52 <Alpounet> sinelaw, chasing people would definitely be fun
13:52:04 <medfly> what use are so many cameras if you have no one to work the data?
13:52:08 <ivanm> ManateeLazyCat: well, yeah, except the newest version already came with GHC
13:52:11 <Alpounet> and nobody would ever dare to complain about Haskell not being good / ready for real world stuff
13:52:13 <Saizan> ivanm: you usually end up with that error by reinstalling the same version of Cabal
13:52:17 * ManateeLazyCat pasted "ghc-pkg list" at http://paste2.org/get/721646
13:52:20 <ivanm> and it unregistered GHC's internal one...
13:52:34 <ivanm> ManateeLazyCat: "ghc-pkg recache" might help
13:52:34 <ManateeLazyCat> ivanm: So how to fix?
13:52:44 <Saizan> ManateeLazyCat: ok, i see the problem
13:52:56 <MadHatterDude> Yay! My C-program works
13:53:01 <Saizan> ManateeLazyCat: you've Cabal-1.8.0.2 both on the global and in the user package db
13:53:12 <Younder> Alpounet, it is definatly ready
13:53:27 <Saizan> ManateeLazyCat: you've to unregister the one in the user db, ghc-pkg unregister --user Cabal-1.8.0.2
13:53:31 <sinelaw> Alpounet allthough the heavylifting videoprocessing stuff won't really be in haskell, as it's being done through FFI
13:53:37 <Younder> Alpounet, in all i's beuty
13:53:41 <copumpkin> preflex: xseen ivanm
13:53:42 <preflex>  ivanm was last seen on freenode/#haskell-blah 0 seconds ago, saying: heh
13:53:55 <Younder> it's
13:53:59 <Saizan> ManateeLazyCat: and you should do the same for HTTP-4000.0.9
13:54:00 <ivanm> copumpkin: you rang?
13:54:12 <copumpkin> ivanm: I was trying to embarrass you but it didn't work
13:54:15 <copumpkin> your heh saved the day
13:54:18 <ivanm> copumpkin: :D
13:54:21 <ivanm> heh++
13:54:27 <copumpkin> @karma heh
13:54:28 <lambdabot> heh has a karma of 1
13:54:34 <Alpounet> haha
13:54:38 <Alpounet> sinelaw, ok
13:54:54 <Saizan> ManateeLazyCat: and network-2.2.1.7
13:54:56 <Younder> @karma heh
13:54:56 <lambdabot> heh has a karma of 1
13:55:08 <ivanm> copumpkin--
13:55:12 <copumpkin> @karma
13:55:12 <lambdabot> You have a karma of 7
13:55:19 <Axman6> @karma
13:55:19 <lambdabot> You have a karma of 9
13:55:23 <Axman6> :o
13:55:24 <ezyang> @karma
13:55:24 <lambdabot> You have a karma of 1
13:55:25 <ivanm> @karma
13:55:26 <lambdabot> You have a karma of 19
13:55:28 <ivanm> :D
13:55:33 <MadHatterDude> @karma
13:55:33 <lambdabot> You have a karma of 0
13:55:34 <sinelaw> @karma
13:55:34 <mauke> preflex: karma C
13:55:34 <preflex>  C: 70605
13:55:34 <lambdabot> You have a karma of 0
13:55:35 <MadHatterDude> lol
13:55:41 <Saizan> ManateeLazyCat: if you've to recompile network against a different version of parsec you should unpack network and edit its cabal file so you get a different version
13:55:43 <Younder> I have a IQ of 170
13:55:44 <mauke> preflex: karma lambdabot
13:55:44 <preflex>  lambdabot: 14
13:55:51 <sinelaw> preflex: karma
13:55:51 <preflex>  sinelaw: -3
13:55:56 <sinelaw> :( :(
13:55:58 <sinelaw> :_(
13:56:00 <copumpkin> Younder: hundred sixty ten?
13:56:07 <mauke> preflex: karma
13:56:07 <preflex>  mauke: 242
13:56:13 <copumpkin> preflex: iq
13:56:21 <lament> I have a e-penis of 15in
13:56:24 <Younder> the top 30 0000 of the polulation
13:56:39 <monochrom> No wonder you can't write.
13:56:42 <fax> Younder do you go on any high IQ forums
13:56:45 <copumpkin> my e-penis is longer than both lament and Younder's
13:56:46 <Younder> whatever
13:56:51 <fax> ?
13:57:05 <fax> my erdos number is bigger than yours!!
13:57:15 <sinelaw> i'm continuous
13:57:21 <copumpkin> my pumpkin number is lower than any of yours
13:57:35 <lament> i'm erdos's son, my erdos number is epsilon
13:57:38 <Younder> fax, MENSA
13:57:39 * thoughtpolice has erdos-bacon number > 2
13:57:58 <sinelaw> i converge!
13:58:15 <sinelaw> in the lyupanov sense
13:58:16 <ivanm> thoughtpolice: "erdos-bacon number"? :o
13:58:22 <copumpkin> mensa feels like a circlejerk
13:58:46 <fax> I understand that having a high IQ could be difficult
13:58:50 <lament> ...really pleasant?
13:58:56 <copumpkin> lament: totally
13:59:05 <copumpkin> #haskell-circlejerk
13:59:08 <djahandarie> thoughtpolice, I wouldn't be suprised if mine was inf
13:59:08 <fax> it would be like the same as having lots of money or whatever
13:59:18 <lament> i'm in the MENSA branch of NAMBLA
13:59:21 <copumpkin> fax: yeah, it's tough
13:59:30 <ManateeLazyCat> I have unregister Cabal-1.8.0.2, HTTP-4000.0.9, network-2.2.17, but still break with `bin-package-db-0.0.0.0` with `ghc-6.12.1`
13:59:33 * copumpkin is in the GNAA-MENSA group
13:59:42 <MadHatterDude> "Ford?" "Yeah." "I think I'm a Monad." "I know how you feel." -- Hichhikers Guide to the Galaxy as preformed by #haskell
13:59:59 <Younder> rotfl
13:59:59 <monochrom> heh
14:00:06 <tensorpudding> preformed!
14:00:22 <MadHatterDude> tensor: I can't spell right now...
14:00:23 <fax> "It's lonely at the top"
14:00:26 <fax> that's what I mean
14:00:35 <copumpkin> fax: oh yeah, I know the feeling
14:00:49 <Younder> tensor..  feel anticipation
14:00:51 <fax> "any functor is the colimit of representible functors in a more on less canonical way"? ??
14:00:57 <copumpkin> the GNAA-MENSA group is so exclusive that I'm the only member :(
14:00:59 <fax> is that yoneda lemma?
14:01:15 <sinelaw> i have an IQ of 160i
14:01:18 <Younder> tensor..  I truly love differential geometry
14:01:53 <Alpounet> sinelaw, \aleph_{\infty} would have been better
14:01:57 <sinelaw> so when you square me, it's -25,600
14:02:16 * sinelaw barks
14:02:18 * copumpkin cubes sinelaw 
14:02:30 <MadHatterDude> sinelaw: I have an IQ of 46.1549335*Pi
14:02:41 * walenis skrab
14:02:59 <sinelaw> o h  k a y.
14:03:03 <lament> I have an IQ of 2
14:03:07 <lament> but it doubles every day
14:03:21 <sinelaw> so you're 1 day old?
14:03:25 <monochrom> On day 64 your head explodes
14:03:30 <lament> no, i just started taking magical pills
14:03:31 <MadHatterDude> lament: Oh crap, an Intelligence singularity!
14:03:36 <fax> lol
14:03:38 <lament> monochrom: on day 64 i will understand monads
14:03:41 <Younder> rotfl
14:03:47 <monochrom> same difference
14:03:56 <Younder> MadHatterDude, wtf
14:03:57 <copumpkin> @quote fuck
14:03:57 <lambdabot> dforsyth says: "under no circumstances would i fuck a dude, but if there was a nuclear bomb to my dick, theres no way id fuck a dude with a ponytail"
14:04:13 <FauxFaux> ...
14:04:13 <danderson> well, that was random
14:04:18 <sinelaw> oh my god
14:04:23 <tensorpudding> Why is that there?
14:04:33 <copumpkin> @quote fuck
14:04:34 <lambdabot> HaskellLove says: haha fuck yeah i am ninja... anyways... when someone asks u about monads ask him is he a programmer or a mathematician... to a programer u can explain it in 5 minutes, not tell him
14:04:34 <lambdabot> how complex it is so he goes studies a hole day and at night he says : wait why the fuck do i waste time, i will never use this
14:04:37 <ManateeLazyCat> ivanm: So how to avoid my problem? Don't install newer Cabal than the one in GHC?
14:04:41 <lament> lambdabot is in a bunch of channels other than #haskell
14:04:44 <Younder> wtf
14:04:52 <sinelaw> @quote psychobot
14:04:52 <lambdabot> psychobot says: let's eat grandma vs let's eat grandma aka interfacing with a guard
14:04:57 <Younder> rotfl
14:05:00 <sinelaw> @quote psychobot
14:05:00 <lambdabot> psychobot says:  category theory and I feel more tired after drinking a cup of communicating objects? it seems like having an if..then..else
14:05:07 <Younder> wysiwig
14:05:08 <fax> @quote category
14:05:08 <lambdabot> Anonymous says: A monad is a functor from a category to itself. Honestly, I don't know how I could make this any simpler.
14:05:10 <fax> @quote category
14:05:11 <lambdabot> EvilTerran says: [on category theory] the same place of nightmares that spawned zygohistomorphic prepromorphisms :P
14:05:16 <fax> @quote category
14:05:16 <lambdabot> copumpkin says: a monad is just a lax functor from a terminal bicategory, duh. fuck that monoid in category of endofunctors shit
14:05:21 <fax> @quote category
14:05:22 <lambdabot> DRMacIver says: I dread to think what category theory would look like after the software engineering world had got their grubby paws on it. Enterprisevariant functors. Commutative UML diagrams.
14:05:33 <Younder> give  your bot some work
14:05:48 <tibbe> dons: you there?
14:05:52 <lament> hahahaha commutative UML diagrams
14:06:04 <djahandarie> haha
14:06:12 <tensorpudding> @quote psychobot
14:06:12 <lambdabot> psychobot says: Divide and concise.
14:06:29 <sinelaw> @quote psychobot
14:06:29 <lambdabot> psychobot says: simpler let's eat, grandma vs let's eat grandma vs let's eat grandma vs let's eat newbies Eek! Peaker, learn anything the bot sees, i.e. commands etc, or ju
14:06:34 <sinelaw> @quote psychobot
14:06:35 <lambdabot> psychobot says:  A negative programming tools is a database.
14:06:49 <sinelaw> @quote lamabdabot
14:06:49 <lambdabot> No quotes match. I've seen penguins that can type better than that.
14:06:58 <sinelaw> @quote lambdabot
14:06:58 <lambdabot> lambdabot says: I know nothing about wadler.
14:07:16 <sinelaw> ok, finito.
14:07:17 <dons> tibbe:
14:07:24 <dons> yeah, boarding in 20 mins
14:07:41 <tibbe> dons: ok, sent you an email
14:07:46 <MadHatterDude> @quote Arrow
14:07:46 <lambdabot> monochrom says: Time flies like an Arrow. Space leaks like a Monad.
14:07:47 <tibbe> dons: lets meet at 7:30pm
14:07:52 <tibbe> dons: I sent you the details
14:07:53 <ManateeLazyCat> Why not GHC contain cabal-install directly?
14:08:01 <tibbe> dons: send me your phone no just in case
14:08:13 <MadHatterDude> @quote Comonad
14:08:13 <dons> ok. looks good.
14:08:13 <lambdabot> wli says: Monads are like constipation. Comonads are like Ex-Lax.
14:08:14 <monochrom> Because Haskell Platform contains cabal-install directly.
14:08:23 <Younder> I am one of the most arrogant distastfull people you will ever come across.
14:08:35 <monochrom> And I refuse to upgrade cabal-install beyond what Haskell Platform gives.
14:08:38 <dons> see you on the other side.
14:08:42 <MadHatterDude> @quote byte
14:08:42 <lambdabot> lilac says: linux kernel modules in haskell: now your gigabyte space leaks are in kernel mode!
14:08:44 <fax> @quote functor
14:08:44 <lambdabot> thermoplyae says: <thermoplyae> someone finally pointed out to me that a monad is an monoid-object in an endofunctor category <thermoplyae> i have no idea how i've never seen that before
14:08:46 <sinelaw> Younder i have already come accross the maximally arrogant distastfull person, and it wasn't you.
14:08:47 <Younder> I aslo won 2 500 000 dollars
14:08:58 <ManateeLazyCat> monochrom: I need install `mtl parsec network HTTP zlib Cabal cabal-install` after GHC.
14:09:07 <sinelaw> heh thermoplyae
14:09:13 <xerox> Younder comes from applying zorn's lemma
14:09:14 <sinelaw> preflex, seen thermoplyae
14:09:15 <preflex>  thermoplyae was last seen on #haskell 38 days, 21 hours, 49 minutes and 45 seconds ago, saying: no, leave it right here
14:09:17 <ManateeLazyCat> monochrom: Looks i install newer Cabal version than GHC have.
14:09:23 <monochrom> I got all of them from Haskell Platform.
14:09:36 <MadHatterDude> @quote quote
14:09:36 <lambdabot> lambdabot says: @quote lambdabot
14:09:49 * sinelaw goes back to learning about hilbert spaces and topological spaces
14:09:53 <ManateeLazyCat> monochrom: Haskell platform including GHC 6.12.1 ?
14:09:56 <MadHatterDude> wtf... Arrgh! recursion
14:10:08 <MadHatterDude> @quote C
14:10:09 <lambdabot> ddarius says: Alternatively, it could be arrived at from the continuity properties of exponentials.
14:10:09 <monochrom> No. current Haskell Platform is for 6.10.x
14:10:22 <MadHatterDude> @quote C++
14:10:23 <lambdabot> ghc says: More than one type pattern for a single generic type constructor
14:10:38 <MadHatterDude> @quote python
14:10:38 <lambdabot> BruceTurner says: It is a little known fact that, just like the programming language Python requires you to be familiar with a few stock Monty Python phrases, Haskell requires you to brush up your
14:10:38 <lambdabot> knowledge of The Simpsons.
14:10:39 <Younder> sinelaw, I am actually a egalitarian
14:11:03 <Younder> sinelaw, so perhaps you are right
14:11:05 <MadHatterDude> @quote perl
14:11:06 <lambdabot> ghc says: GHCi's bytecode generation machinery can't handle 64-bit code properly yet.
14:11:26 <MadHatterDude> @quote ghc
14:11:26 <lambdabot> ghc says: Kind signature on data type declaration has non-* return kind
14:11:31 <Younder> FA
14:11:51 <Younder> tht is totally unacceptable
14:11:52 <ManateeLazyCat> Looks i need reinstall GHC again. Bad.
14:11:56 <MadHatterDude> @quote bash
14:11:56 <lambdabot> psykotic says: Let me get this straight: in your tireless Lisp-bashing efforts you have now dragged out Prolog as an exemplar of practicality? *Prolog*? My goodness, you must be desperate!
14:12:06 <monochrom> You can play with lambdabot through pm too. /msg lambdabot @quote monochrom
14:12:22 <Younder> BASH
14:12:30 <twink> heh, I like that "Prolog as an exemplar of practicality" bit.
14:12:52 <Younder> Twink, me to
14:14:00 <Younder> gotta go out and get big and drunk and awfull, lateer
14:16:05 <ManateeLazyCat> monochrom: It's will better if Haskell platform synchronous with GHC release version.
14:16:17 <twink> Mercury might someday get to the "exemplar of practicality" stage, though the odds are vastly against it.
14:16:54 <monochrom> In practice Haskell Platform is eventually synced with GHC.
14:17:43 <twink> There are a few other logic language competitors out there aren't there? Curry, Oz, and something else.
14:18:31 <[swift]> can anyone suggest a good haskell library to represent and manipulate DAGs? (directed acyclic graphs)
14:18:42 <twink> fgl?
14:18:56 <mtnviewmark> is there anyway to control run-time profiling from within the program being profiled?  I'd like to be able to start/stop it, and dump the profile to a given handle
14:18:57 <ManateeLazyCat> For install cabal-install for GHC-6.12.1, i need below packages: "mtl parsec network HTTP zlib Cabal cabal-install", but i can't install package with user space that GHC have including, right?
14:19:11 <Alpounet> [swift], indeed, fgl is quite nice
14:19:14 <mtnviewmark> :hackage fgl
14:19:21 <[swift]> thanks! that's perfect
14:19:22 <[swift]> installing now
14:21:25 <mtnviewmark> any GHC profiling gurus?
14:22:45 <ivanm> ManateeLazyCat: no, don't _uninstall_ the one that comes with GHC
14:22:49 <ivanm> (or try to replace it)
14:23:06 <MadHatterDude> My Mersenne twister implementation gives bad distribution...
14:23:09 <ManateeLazyCat> ivanm: Too late, i have uninstall it.
14:23:22 <ski> twink : Twelf
14:23:34 <ManateeLazyCat> ivanm: for install cabal-install for GHC-6.12.1, need "mtl, parsec, network, HTTP, zlib, Cabal, cabal-install."
14:23:44 <ManateeLazyCat> ivanm: And GHC-6.12.1 have including Cabal
14:23:48 <ivanm> right
14:23:54 <ManateeLazyCat> ivanm: So i just don't need install Cabal
14:23:55 <twink> ski: I thought Twelf was more of a theorem prover, but maybe there's overlap.
14:24:00 <ivanm> ManateeLazyCat: exactly
14:24:37 <ManateeLazyCat> ivanm: Then won't unregist Cabal that in GHC, right?
14:25:09 <ivanm> right
14:25:56 <ski> (maybe the "something else" was Escher or Gdel ?)
14:26:26 <ManateeLazyCat> ivanm: Oh, i see, because i use "ghc --make Setup && ./Setup configure && ./Setup build && sudo ./Setup install" install Cabal. ghc will unregist global Cabal for user space, even Cabal have install.
14:26:43 <ManateeLazyCat> ivanm: If i use "cabal install foo" won't have this problem.
14:26:55 <ivanm> ManateeLazyCat: ummm.... why do ghc --make Setup?
14:27:13 <ivanm> old school way is: runhaskell Setup.hs configure && runhaskell Setup.hs build && runhaskell Setup.hs install
14:27:36 <ivanm> ManateeLazyCat: cabal install does exactly that, just that it defaults to per-user installs
14:28:20 <monochrom> ghc --make Setup does not hurt.
14:28:55 <ivanm> hurt, no
14:28:58 <ivanm> usual, no
14:29:03 <flazz> the function calcStats is driving me crazy, http://gist.github.com/335726 can someone explain wat is going on?
14:29:04 <copumpkin> om nom
14:29:08 <monochrom> I always do it. Faster.
14:29:28 <ManateeLazyCat> ivanm: monochrom Which?
14:29:43 <ivanm> monochrom: is it really noticeably faster?
14:29:47 <monochrom> Yes!
14:30:14 <ManateeLazyCat> ivanm: monochrom I just copy from HaskellWiki.
14:30:53 <ManateeLazyCat> ivanm: It's looks "ghc --make" haven't any hurt.
14:31:04 <ManateeLazyCat> ivanm: I don't understand "usual, no"?
14:31:13 <ManateeLazyCat> ivanm: Have special case?
14:31:24 <ivanm> ManateeLazyCat: it's not the usual way of doing it that I've seen
14:31:38 <applicative> flazz:  s is an Integer if it is the length of a list
14:32:02 <mtnviewmark> flazz -- why   Stats(Float, Float, Float) rather than Stats Float Float Float?
14:32:06 <ManateeLazyCat> ivanm: Okay, thanks for your help on Cabal, i hope won't have problem after reinstall.
14:32:09 <mtnviewmark> do you really want them in a tuple?
14:32:11 <applicative> @type length ['a','b']
14:32:12 <lambdabot> Int
14:32:42 <monochrom> On 2GHz, 1GB computers, the speed difference is unimportant perhaps. But for a long time I was on a 1GHz, 0.5GB computer. Reloading ghci three times is stupid on such a computer.
14:32:49 <mtnviewmark> @info (^)
14:32:49 <lambdabot> (^)
14:33:05 <mtnviewmark> flazz - I think you want  ^ 2 not ** 2
14:34:58 <monochrom> Most haskell hackers have enjoyed 4-core 4GHz 8GB monsters (and 4-head 42" screens) for like 10 years so of course none of them would care to compile Setup.hs
14:35:11 <flazz> mtnviewmark: Stats(...) is my ignorance
14:35:36 <Zao> I compile Setup.hs manually.
14:35:41 <mtnviewmark> ah - no need for those parens, or the ons in the last line of calcStats
14:35:42 <Zao> Never knew about runhaskell :)
14:35:55 <ManateeLazyCat> monochrom: Yep, because GHC eat too much memory.
14:36:09 <Zao> I hear that swap is nice.
14:36:24 <jmcarthur> doesn't cabal-install compile Setup?
14:36:33 <jmcarthur> Zao: swap is slow
14:36:38 <Zao> Probably. Fancy new utilities.
14:36:42 * ivanm never did the runhaskell method because he got Gentoo to do it for him! :D
14:36:51 <ManateeLazyCat> monochrom: Speical when compile big pacakge, perhaps is a bug of GHC.
14:37:07 <ManateeLazyCat> ivanm: But Gentoo need much time. :)
14:37:18 <mtnviewmark> so, no one knows a way to control profiling from within the profiled program?  Sigh...
14:37:18 <monochrom> @quote Cale gentoo
14:37:19 <lambdabot> Cale says: Gentoo is a massive waste of electricity.
14:37:23 <jmcarthur> i do wonder how often ghc is space-profiled
14:37:23 <monochrom> hehe
14:37:28 * ivanm avoids bringing this argument back up again by going off to uni
14:37:33 <lowasser> aughhhhh, have I said I hate GTK before?
14:37:48 <Zao> lowasser: Probably.
14:37:50 <monochrom> Yes you said you hate GTK.
14:38:00 <lowasser> well, actually that's not the problem at the moment
14:38:02 <lowasser> now that I think of it
14:38:07 <ManateeLazyCat> lowasser: Why?
14:38:16 <lowasser> so I try installing template-haskell-2.3.0.1
14:38:33 <lowasser> it fails, and I have to go into the source to manually fix something
14:38:42 <monochrom> I hate software
14:38:46 <lowasser> then I try installing data-accessor-template
14:38:47 <ManateeLazyCat> Now "ghc-pkg check" works well.
14:38:57 <lowasser> and it says     Bad interface file: /home/lowasser/.cabal/lib/template-haskell-2.3.0.1/ghc-6.12.1/Language/Haskell/TH/Syntax.hi        Something is amiss; requested module  template-haskell-2.3.0.1:Language.Haskell.TH.Syntax differs from name found in the interface file template-haskell:Language.Haskell.TH.Syntax
14:39:51 * ManateeLazyCat "Don't install pacakge that GHC have including", another tips .... :) 
14:40:08 <lowasser> data-accessor-template claims to require the old version
14:41:22 <ManateeLazyCat> "Don't use cabal upgrade", I remember once, i upgrade it, make some package depend different version. And worse, i recompile gtk2hs again ....
14:42:51 <MaciejP> cabal upgrade is really bad if you're not 100% sure about what you are doing.
14:42:57 <WofFS> > foldr (\x a -> (let c = drop 13 . dropWhile (/=x) $ (take 39 $ cycle ['A'..'Z']) ++ (take 39 $ cycle ['a'..'z']) in if null c then x else head c) : a) [] "fgnegrq jvgu Unfxryy bar jrrx ntb"
14:42:58 <lambdabot>   "started with Haskell one week ago"
14:43:41 <lowasser> I don't use cabal upgrade
14:44:45 <monochrom> If you can write "started with Haskell one week ago" that way, you have made astonishing progress. :)
14:45:18 <gwern> @wn hue
14:45:20 <lambdabot> *** "hue" wn "WordNet (r) 2.0"
14:45:20 <lambdabot> hue
14:45:20 <lambdabot>      n : the quality of a color as determined by its dominant
14:45:20 <lambdabot>          wavelength [syn: {chromaticity}]
14:45:20 <lambdabot>      v 1: take on color or become colored; "In highlights it hued to a
14:45:22 <lambdabot>           dull silver-grey"
14:45:24 <lambdabot>      2: suffuse with color [syn: {imbue}, {tinge}]
14:45:38 <gwern> hm. where's the hue of 'hue and cry'?
14:46:02 <ManateeLazyCat> I was thinking, need add another package named "cabal-bundle" that including "mtl, parsec, network, HTTP, zlib, Cabal, cabal-install", then user don't need install those package one by one.
14:46:25 <yitz> @wn hew
14:46:26 <lambdabot> *** "hew" wn "WordNet (r) 2.0"
14:46:26 <lambdabot> hew
14:46:27 <lambdabot>      v 1: make or shape as with an axe; "hew out a path in the rock"
14:46:27 <lambdabot>           [syn: {hew out}]
14:46:27 <lambdabot>      2: strike with an axe; cut down, strike; "hew an oak"
14:46:27 <gwern> ManateeLazyCat: what's the point of an empty package depending on those?
14:46:28 <lambdabot>      [also: {hewn}]
14:46:29 <Lycurgus> gwern, is that "hew" spelled the same?
14:46:34 <gwern> Lycurgus: no
14:46:52 <gwern> 'In common law, a hue and cry (Latin, hutesium et clamor, "a horn and shouting", or from ME "hu", and AF "cri") is a process by which bystanders are summoned ...'
14:47:10 <Lycurgus> ah
14:47:23 <ManateeLazyCat> gwern: Before you install cabal-install, you need download those packages, and will confusion with newbie.
14:47:40 <gwern> ManateeLazyCat: but you would need to install them anyway
14:48:04 <gwern> cabal-install's bootstrap script is basically as simple & easy for one than 4 or 5
14:48:05 <WofFS> monochrom, :-) thanks to http://learnyouahaskell.com/
14:48:22 <tommd> I'lll learn you a Haskell!
14:48:32 <ManateeLazyCat> "bootstrap script" where?
14:49:07 <tommd> ManateeLazyCat: ./bootstrap.sh in the cabal-install source root, I think.
14:49:27 <fax> I hate that bootstrap stuff but it does work (sometimes)
14:50:16 <monochrom> I hate software.
14:50:56 <yitz> monochrom: so fix it
14:50:58 <ManateeLazyCat> tommd: ./bootstrap.sh will install Cabal anyway?
14:51:31 <tommd> ManateeLazyCat: It should build it (assuming you are on a *nix OS) but I think the decision to install is left up to you.
14:51:42 <yitz> monochrom: better yet, file a bug report on trac and simon will fix it
14:51:42 <tommd> Once you run it things should be apparent.
14:52:27 <ManateeLazyCat> tommd: It's bad if this script install Cabal anyway and don't search in GHC first.
14:52:33 <tommd> ManateeLazyCat: From the script:
14:52:33 <tommd> # It works by downloading and installing the Cabal, zlib and
14:52:33 <tommd> # HTTP packages. It then installs cabal-install itself.
14:52:33 <tommd> # It expects to be run inside the cabal-install directory.
14:53:33 <tommd> ManateeLazyCat: Why do you say that?  It is perfectly safe to upgrade the Cabal library and even highly recommended.
14:53:53 <ManateeLazyCat> tommd: NO.
14:54:52 <tommd> ManateeLazyCat: YES!
14:54:54 <ManateeLazyCat> tommd: Example, GHC-6.12.1 have including Cabal, if you install Cabal again, then it will unregist Cabal global by user space. Then you run "ghc-pkg check" will broken `bin-package` and `ghc-6.12.1`
14:55:30 <ManateeLazyCat> tommd: You can try install Cabal after you install GHC-6.12.1, then run "ghc-pkg check", then you know what's happen.
14:56:36 <ManateeLazyCat> tommd: It's perfect if that script use "ghc-pkg list" check first, if have any package including in GHC list, just skip.
14:56:59 <tommd> ManateeLazyCat: Sorry to hear about your troubles, but I have GHC-6.12.1 and just _now_ reinstalled Cabal with no issues.
14:57:31 <ManateeLazyCat> tommd: Oh? I reading ./bootstrap.sh
14:57:33 <Darkone> So, Baughn refered me here, saying that I'll need to all if I want to try and really learn #haskell, but what would you say the best tutorials are on it?
14:57:43 <MadHatterDude> It worries me that my get_rand_int has bad distribution...
14:57:46 <Darkone> s/to all/you all
14:58:02 <Baughn> Darkone: Learn you a haskell is still a good one. :)
14:58:02 <copumpkin> Darkone: the interactive ones you get by asking questions in here and tinkering on your own
14:58:35 <Darkone> Kay, I'll start on that one after I finish reading this introduction.
14:58:48 <ManateeLazyCat> tommd: I have read source code, looks author have found this problem, and use "ghc-pkg list" filter. :)
14:58:51 <Darkone> Nice job, whoever did it :P The sort example really hooked me :V
14:59:05 <ManateeLazyCat> tommd: Good, ./bootstrap.sh is simple.
14:59:07 <Baughn> Darkone: It's actually a really lousy sort, but it does /look/ nice. :P
14:59:17 <tommd> That would be duncan, say thanks Duncan!
14:59:32 <Darkone> Yes.
14:59:39 <Darkone> It demonstrates the point
15:01:38 <ManateeLazyCat> tommd: Yep, thanks Duncan. :)
15:02:24 <Veinor> how can I find which HXT package I need to import to get, say isXText?
15:03:12 <harlekin> Veinor, use hayoo or hoogle.
15:03:52 <Veinor> ah, hayoo
15:04:50 <Veinor> ... crap
15:05:10 <Veinor> the HXT documentation on the wiki doesn't work. :(
15:06:12 <jmcarthur> nice, bitc is coming back
15:06:20 <byorgey> gwern: no, I hadn't noticed!  How did you do that?  And how will spam accounts be dealt with?
15:06:38 <gwern> byorgey: I asked politely! They will be burnt with fire!
15:06:42 <jmcarthur> http://www.coyotos.org/pipermail/bitc-dev/2010-March/001809.html
15:07:06 <byorgey> gwern: and what are the technical specifications of said 'fire'?
15:07:17 <monochrom> Veinor: With 99% probability you shouldn't even care about isXText.
15:07:22 <byorgey> gwern: I am in favor, BTW, creating accounts was getting freaking annoying, but I'm just curious
15:07:24 <gwern> byorgey: a plasma at >400 degrees fahrenheit
15:07:29 <byorgey> sweet.
15:08:22 <jlouis> with a highly radioactive lump of plutonium next to them while being burned?
15:08:45 <byorgey> jlouis: those we reserve for the actual people who created the accounts.
15:11:55 <Veinor> monochrom: I was just using it because that's what the HXT thing on the wiki uses
15:12:09 <Veinor> anyway, right now my problem is: given an XML file, pull out everything between <foo> tags
15:13:03 <aavogt> byorgey: did you get a message from me that for diagrams (on hackage) that the containers dependency range can be expanded?
15:13:18 <byorgey> aavogt: ah, yes I did, thanks
15:13:29 <byorgey> just haven't gotten around to re-uploading it
15:13:47 <aavogt> no worries
15:14:24 <monochrom> Veinor:  readDocument somethingsomething >>> isElem >>> hasName "foo" >>> getText   (import Text.XML.HXT.Arrow, that's all you need 99% of the time)
15:14:27 * Alpounet loves diagrams
15:14:54 * aavogt too
15:15:02 <byorgey> aavogt: I'm pretty buried in writing an ICFP paper at the moment =)
15:15:04 <monochrom> Veinor: oops. readDocument somethingsomething >>> isElem >>> hasName "foo" >>> getChildren >>> getText
15:15:32 <aavogt> monochrom: without arrow sugar?
15:15:43 <monochrom> You can abbreviate ">>> getChildren" by "/>"
15:16:05 <Veinor> monochrom: not working; keep in mind the foo's are nested deep within the XML
15:16:05 <monochrom> What is arrow sugar?
15:16:13 <monochrom> Oh oops!
15:16:18 <Veinor> yeah, my fault
15:16:52 <monochrom> readDocument somethingsomething >>> deep (isElem >>> hasName "foo" >>> getChildren >>> getText)
15:17:05 <aavogt> monochrom: -XArrows
15:17:27 <monochrom> No need for -XArrows so far.
15:17:56 <Dephyrial> :Qa
15:17:59 <monochrom> If you don't see "proc" "do" "-<" "-<<" there is no sugar.
15:18:03 <Dephyrial> that was for vim, sorry
15:18:34 <aavogt> monochrom: I mean whether you would use it to abbreviate the >>> ?
15:18:34 <Veinor> monochrom: that worked, thanks
15:19:39 <monochrom> No, the sugar doesn't help until we've got branching nonlinear dataflow.
15:19:45 * edwardk waves hello,
15:19:59 * byorgey waves to edwardk 
15:20:02 <edwardk> copumpkin: i took the rather unimaginative name Data.Buffer for my test ;)
15:20:09 <Veinor> context: I'm writing a script that takes an RSS feed, extracts post bodies, and generates a new one via MARKOV CHAINS :o
15:20:16 <copumpkin> edwardk: hah, what's the package name gonna be?
15:20:30 <edwardk> copumpkin: not sure yet
15:20:46 <copumpkin> oh nice
15:20:47 <copumpkin> buffer isn't taken
15:20:53 <monochrom> When you find yourself using first, second, &&&, ***, tuple construction and tuple destruction heavily, sugar will be nicer.
15:20:56 <edwardk> copumpkin: so far the refactoring is going smoothly. i basically just snapshotted Data.ByteString
15:20:57 <edwardk> yeah
15:21:03 <copumpkin> cool
15:21:14 <copumpkin> you gonna try to do stream fusion over it
15:21:15 <edwardk> and then added the calculations to track the extra high bits
15:21:15 <copumpkin> ?
15:21:25 <edwardk> Data.ByteString.Fusion is currently empty ;)
15:21:41 <edwardk> so i'll implement it when i see something there ;)
15:22:24 <edwardk> right now the main thing i want is something like a Data.Text.Lazy that isn't a pig to index into
15:22:35 <edwardk> and i think that this will do nicely
15:22:37 <copumpkin> cool
15:23:14 <copumpkin> I guess you can build one from a flat buffer with no copying
15:23:22 <copumpkin> you just need to build the tree on top of it and make slices of the buffer
15:23:47 <edwardk> you only need the tree if you want fast indexing. i don't even bother creating that on the leaves
15:24:02 <copumpkin> oh, so even that will be optional?
15:24:12 <edwardk> and you only even want THAT when the leaf has high bits
15:24:33 <edwardk> because a leaf that is a bytestring with no high bits can be indexed in O(1)
15:24:38 <copumpkin> yeah
15:25:04 <copumpkin> are you going to just chunk things up regularly or try to maximize O(1) chunks?
15:25:14 <copumpkin> (i.e., make them as wide as possible)
15:25:41 <edwardk> so i'll probably want to make the mechanism that inserts buffers into the fingertree check to see if the buffer has high bits, and if not, insert it whole hog, if so, chunk it up into smaller pieces so that you can do faster seeking/splitting
15:26:05 <edwardk> but the more logic that goes in there, the slower it'll be
15:26:20 <edwardk> right now the only check that i have is that i don't insert empty chunks
15:26:42 <Veinor> I need to patch lambdabot or goa or whatever is generating these 'Main: caught (and ignoring) too few bytes. Failed reading at byte position 8' things
15:26:59 <corey> can anyone help me with some php? i suck at it
15:27:05 <Veinor> but that means... I'll have to learn darcs D:
15:27:15 <mauke> corey: wrong channel
15:27:19 <copumpkin> corey: people in (#)#php can
15:27:22 <corey> where should i go
15:27:26 <mauke> corey: a php channel
15:27:45 <copumpkin> clearly if you want php help you should join the visual basic channel
15:27:48 <monochrom> Veinor: something about utf-8 vs iso-latin-1
15:27:48 <Alpounet> where can I find cairo ?
15:27:48 <copumpkin> duh
15:28:36 <monochrom> In Egypt.
15:28:54 <copumpkin> it's part of gtk2hs
15:28:55 <edwardk> 'sudo apt-get remove php5' -- is about the only advice you're likely to find about it here
15:28:56 <copumpkin> or one the nile
15:29:19 <FliPPeh__> Are there mirrors for xmonad?
15:29:23 <Alpounet> oh yeah right
15:29:28 <ddarius> Veinor: darcs is really easy
15:29:31 <monochrom> 30°3′29″N 31°13′44″E
15:29:33 <FliPPeh__> code.haskell.org is dead
15:31:39 <aavogt> is this correct that ghc lists  MonomorphismRestriction in --supported-languages?
15:31:50 <copumpkin> yeah
15:31:53 <SyntaxNinja> FliPPeh__: shoudl be back up
15:32:16 <aavogt> should it list NoMonomorphismRestriction because that's the extension to the standard?
15:32:30 <copumpkin> it should list that too
15:32:41 <dmwit> It doesn't.
15:32:52 <aavogt> copumpkin: there are -XNoBlahBlah variants for every language option
15:32:54 <dmwit> Can you stick a "No" in front of any of the LANGUAGE extensions?
15:32:54 <copumpkin> maybe it supports a No- prefix to all extensions?
15:33:03 <dmwit> hm
15:33:10 <dmwit> Seems we are all on the same page here3.
15:33:17 <copumpkin> :)
15:33:41 <aavogt> it's really a question of what the list means
15:33:59 <ben> So by extension, are there NoNoBlahBlah variants too?
15:34:04 <aavogt> anyways, it's annoying because vim's haskell mode only inserts extensions from that lists
15:34:09 <copumpkin> -XNoUndecidableInstances
15:34:20 <monochrom> hahahaha ben
15:34:53 <Veinor> -XNoNoNoNoNoNoNoNoNoNoNOMonomorphismRestriction
15:34:59 <aavogt> so is this worth a ticket?
15:35:34 <monochrom> sudo apt-get purge vim vim-tiny vim-gnome vim-gtk vim-nox
15:35:51 <aavogt> apt-get purge?
15:36:01 <Veinor> purge deletes config files too
15:36:43 * aavogt wonders why apt-get is misnamed
15:36:52 <monochrom> alias vim emacs
15:37:22 <aavogt> at least with cabal install, the program doesn't uninstall stuff, so we don't have to worry about that cognitive dissonance
15:37:45 <lpsmith> is there a way to specify --haddock-option in my ~/.cabal/config
15:37:46 <lpsmith> ?
15:38:05 * monochrom doesn't care about meaningful names
15:39:40 <aavogt> lpsmith: no. There's a ticket on that, I believe
15:40:25 <MisterN> monochrom: makes you a true haskell user.
15:43:17 <aavogt> well it's one thing for a name to be meaningless, it's another if you write   \(xs:x) -> ...
15:43:45 <Darkone> Would you guys recommend an IDE to start out with, or just the text editor + GHC. If the former, which would you recommend?
15:44:17 <aavogt> emacs is an IDE
15:44:42 <monochrom> start out? emacs is fine. vim is fine too.
15:44:43 <aavogt> and it's haskell mode is apparently quite nice
15:44:55 <Veinor> haskell-mode is decent, yeah
15:45:14 <Veinor> it indents, it syntax hilights, it provides types (although I'm not sure to what extent)
15:45:19 <[swift]> argh. has anyone used FGL? The documentation is out of date and I'm not sure what type I need to give to the gr parameter of the Graph class
15:45:22 <Darkone> For windows :V
15:45:38 <Veinor> emacs running under cygwin/x11 for windows
15:45:43 <monochrom> emacs for windows. vim for windows.
15:46:24 <monochrom> Oh actually, why not run a VM and put linux inside.
15:46:48 <aavogt> [swift]: how exactly do you give a parameter to a class? You use certain instances of that class which are listed in the haddock documentation under the class
15:46:56 <Veinor> can you write IO [a] -> [IO a]? what about the other way around?
15:47:02 <copumpkin> nope
15:47:07 <copumpkin> the other way around is sequence
15:47:33 <aavogt> @type repeat . fmap head
15:47:34 <lambdabot> forall a (f :: * -> *). (Functor f) => f [a] -> [f a]
15:47:35 <copumpkin> if IO were Traversable, you could do it your way too
15:47:46 <copumpkin> aavogt: lol
15:47:48 <Darkone> monochrom, time and lack of... uhh.. word for comfort?
15:47:53 <[swift]> aavogt: indeed, my question was asked imprecisely. but actually a better question might be: how do i view the haddock documentation? (i installed FGL with cabal)
15:48:07 <[swift]> aavogt: i've been using the docs on the author's website so far
15:48:09 <aavogt> @hackage fgl
15:48:09 <lambdabot> http://hackage.haskell.org/package/fgl
15:48:28 <Darkone> I actually have a somewhat ancient fedora VM on a flash drive from my ITS class >.>
15:48:29 <aavogt> http://hackage.haskell.org/packages/archive/fgl/5.4.2.2/doc/html/Data-Graph-Inductive-Graph.html#t%3AGraph
15:49:10 <aavogt> unfortunately, haddock doesn't do justice to qualified names... but the links are correct
15:49:27 <[swift]> aavogt: thanks! i'll try to help myself based upon this
15:52:10 <gloob1> hello guys is it possible to send data between forked processes?
15:52:39 <gloob1> or make something like variable shared between processes for reading?
15:52:42 <mauke> no, processes can't communicate with each other
15:52:51 <mauke> that's why operating systems just don't work
15:52:52 <Ke> forkIO is not forked process
15:53:01 <ivanm> Axman6: well, we have upvotes at least, even if no comments
15:53:08 <Ke> gloob1: on unix used pipes
15:53:17 <gloob1> ou
15:53:20 <integral> if you're thinking about multi-threading in haskell there's channels and tvars
15:53:41 <Alpounet> he's rather thinking about IPC
15:54:01 <gloob1> Ke> it is not?
15:54:11 <monochrom> I estimate 90% probability it is not a haskell question.
15:54:41 <integral> gloob1: normally with this confusion reigning, the person asking the question can help by giving some more specific information to get a more precise answer
15:54:54 <Ke> gloob1: afaik the implementation is threaded not forked
15:55:48 <Ke> gloob1: this is relevant if you want to do exec
15:55:53 <gloob1> i have client-server app and i call forkIO for every client that connects and the main purpose of the server is to send data from one client to another (like simple chat server where two clients can comunicate)..but the thing is that i need to append some data to messages before i send it to other client..and this message is generated every 2ms
15:56:21 <dmwit> forkIO does not start a new process.
15:56:30 <copumpkin> or even a new OS thread
15:56:46 <dmwit> mmm
15:56:49 <jlouis> copumpkin: unless... :)
15:56:52 <dmwit> I guess it's not guaranteed to, though it may, right?
15:56:54 <gloob1> i thought that it makes new process :O
15:56:58 <copumpkin> the OS threads are pooled
15:57:01 <monochrom> You can use MVar or Chan to have two forkIO'ees talk to each other.
15:57:08 <dmwit> forkProcess makes a new process. =P
15:57:09 <copumpkin> you get them at startup, and a forkIO might get run on a separate thread
15:57:18 <copumpkin> even forkOS doesn't make you a new thread
15:57:22 <gloob1> aha
15:57:27 <copumpkin> (a new OS thread, that is)
15:57:28 * integral thinks they're "processes" in a theoretical sense at least
15:57:37 <monochrom> Even talking between forkIO'ee and forkIO'er.
15:57:41 <fax> integarl?
15:58:32 <gloob1> so which way is easier?..MVar or Chan?
15:58:47 <monochrom> Chan
15:58:49 <copumpkin> I'd use a Chan if you're passing messages around
15:58:59 <copumpkin> with an MVar you'd probably just be reinventing a Chan
15:59:09 <gloob1> hehe
15:59:13 <kmc> forkIO starts a new process in Erlang-speak
15:59:18 <kmc> not in UNIX-speak
15:59:27 <monochrom> An honest answer depends on what you really do.
15:59:37 <gloob1> copumpkin: okay i'll try it..thanks a lot!
15:59:52 <kmc> anyway gloob1 read chapters 24, 27, 28 of Real World Haskell if you have not already
15:59:54 <kmc> it's free online
16:00:12 <gloob1> kmc: ok i will..thanks
16:01:41 <kmc> to be precise: forkIO is not guaranteed to fork a new OS thread, and in GHC, it never (?) does
16:02:19 <kmc> forkOS will sometimes create an OS thread, but that thread sits idle between FFI calls -- it does not participate in Haskell evaluation
16:03:52 <byorgey> aavogt: ping
16:06:37 <benmachine> I think forkIO creates an unbound thread i.e. one which is free to move between CPU cores because it is not tied to an OS thread
16:06:48 <copumpkin> yep
16:06:59 <copumpkin> well, move between OS threads
16:07:06 <benmachine> yeah
16:07:32 <benmachine> it must be possible for forkIO to create a new OS thread otherwise you wouldn't normally get actual multiprocessing
16:07:39 <copumpkin> nope
16:07:49 <copumpkin> calling +RTS -Nx is what gives you more OS threads
16:07:55 <benmachine> oic
16:08:02 <fax> "The only downside to going that route is that you'll then be forced into (a dialect of) Python or C as the programming languages. Which is like forcing a category theorist to make the choice between working in either an untyped HOL or 'raw' ZFC" -- not using haskell
16:08:05 <benmachine> and then the forkIOs can potter around them
16:08:18 <kmc> the computation part of a forkOS thread moves among those threads too
16:08:37 <kmc> the only difference is that FFI calls from a forkOS'ed thread are guaranteed to be made by the same OS-level thread
16:08:50 <benmachine> hm
16:09:14 <artzz_> hi again
16:09:36 <artzz_> how would you make an easy function to get the first half elements of a list, and then another one to get the other part?
16:09:49 <benmachine> the first half?
16:09:55 <benmachine> why would you want to do that?
16:09:58 <artzz_> like, [1 2 3 4] => [1,2]
16:10:01 <Zao> Find length, split on the result.
16:10:02 <artzz_> just trying
16:10:17 <dmwit> :t splitAt
16:10:18 <lambdabot> forall a. Int -> [a] -> ([a], [a])
16:10:21 <artzz_> yes but I thought there would be a fancy way with haskell, just thinking
16:10:25 <artzz_> oh nice, built in func
16:10:25 <benmachine> this isn't something that would come up in an actual application ever :P
16:10:27 <monochrom> > let n = length [1,2,3,4] in splitAt (n `div` 2) [1,2,3,4]
16:10:29 <lambdabot>   ([1,2],[3,4])
16:10:29 <kmc> artzz_, it's not very efficient, because of how lists are built
16:10:32 <benmachine> lists aren't usually used like that
16:10:40 <kmc> if you have something composed of equal-sized halves, you should be representing it as a tree in the first place
16:10:42 <monochrom> I bet it's just homework.
16:10:56 <artzz_> kmc: yes, that's what I was thinking too. I'm used to imperative programming and some things sound to me that are going to be really slow with haskell
16:10:56 <benmachine> which you just solved, I notice :P
16:10:58 <Zao> kmc: Or an array.
16:10:59 <kmc> lists are made of "head + rest"; trees are made of "first half + second half"
16:11:02 <artzz_> but I know it's not made for speed anyways
16:11:06 <byorgey> O NOES SOMEONE IS DOING SOMETHING IN A NON-OPTIMAL WAY
16:11:12 <Zao> byorgey: Burn them!
16:11:18 <byorgey> sheesh, it's ok people =)
16:11:19 <kmc> speed is not the #1 goal, but we can achieve quite good speed
16:11:25 <Zao> Convert their misguided energy into useful heat!
16:11:27 <kmc> you just have to use the right data structures
16:11:35 <kmc> i.e. don't treat lists like random-access arrays
16:11:36 <kmc> anyway bbl
16:11:40 <artzz_> is it possible to link a haskell func (ghc) with C?
16:11:43 <artzz_> like, calling from/to c?
16:11:46 <Zao> Yes.
16:11:50 <Zao> Both ways.
16:11:51 <benmachine> look up the FFI
16:11:51 <artzz_> nice
16:11:53 <merijn> artzz_: Yes, via the FFI
16:11:55 <byorgey> yes, it is, see the foreign function interface
16:11:57 <artzz_> I'll have to try that
16:12:04 <kmc> artzz_, yes, read chapter 17 of Real World Haskell, available free online
16:12:04 <Zao> splitInHalf [1..] -- *twiddle thumbs*
16:12:13 <artzz_> yes, I am at chapter 4
16:12:14 <artzz_> nice book
16:12:17 <kmc> :)
16:12:17 <benmachine> it's surprisingly simple but not trivial
16:12:27 <monochrom> cycle "yes, see FFI"
16:12:42 <Zao> Hrm, it would be possible to construct a splitInHalf that would work fine on infinite lists, wouldn't it?
16:12:43 <benmachine> contrapuntal fugues etc.
16:12:53 <benmachine> Zao: eer, no
16:12:54 <merijn> At the risk of being called a heretic, is it possible to do inheritance with ADTs?
16:12:55 <Zao> At least if you only force bits of the first half.
16:13:09 <Zao> Forcing the second one would obviously take some time.
16:13:11 <benmachine> Zao: oh, maybe kinda sorta
16:13:12 <monochrom> Where does the first half end?
16:13:20 <benmachine> monochrom: you don't need to know
16:13:22 <merijn> Zao: half an infinite list is an infinite list
16:13:28 <benmachine> you just need to know where it doesn't end :P
16:13:37 <merijn> splitInHalf [1..] = [1..]
16:13:43 <benmachine> quite
16:13:52 <benmachine> it's possible to do that in implementation
16:13:57 <Zao> In order to take N from the first half, you must evaluate 2N.
16:13:58 <c_wraith> yeah, you can implement splitInHalf such that it half-works on infinite lists
16:14:03 <aavogt> yeah, you just need to know that the list is at least twice as long as the first half
16:14:20 <amxx> a list with 20m elements is a bad idea, lazy or not, right?
16:14:23 <dmwit> merijn: You can get that effect with the Natural data type and genericLength.
16:14:23 <monochrom> I see.
16:14:35 <benmachine> amxx: depends
16:14:45 <c_wraith> amxx: depends.  If used properly, it might never be in memory all at once.  In which case it might be fine.
16:14:46 <benmachine> amxx: given that infinite lists are not a bad idea, maybe not
16:14:56 <merijn> dmwit: Wait, is that an answer to my inheritance question or my stupid splitInHalf example?
16:15:02 <amxx> I'm reading the stuff from a database
16:15:07 <dmwit> merijn: I thrive on stupidity.
16:15:12 <benmachine> amxx: also, if you're handling gigabyte files you're going to have to deal with huge data structures at some point
16:15:26 <amxx> which should be lazy
16:15:37 <benmachine> but there aren't easy solutions to hard problems :p
16:15:47 <pickles> sure there are
16:15:49 <amxx> and there is one operation i need to perform on every record
16:15:54 <pickles> you just have to look harder
16:15:56 <dmwit> merijn: Inheritance is basically open type sums, which Haskell doesn't really have.
16:16:01 <dmwit> merijn: Though we do have closed type sums. =)
16:16:14 <dmwit> Which is good enough for a lot of stuff.
16:16:18 * copumpkin does his arithmetic with his fingers
16:16:26 <copumpkin> we have open type sums with typeclasses
16:16:34 <dmwit> ...sort of
16:16:34 * monochrom does his arithmetic with his fingers and iPod Touch
16:16:35 <merijn> dmwit: I suppose that answer would help me quite a lot more if I knew what open type sums and closed type sums are
16:16:49 <copumpkin> yeah, not quite the same
16:16:54 <copumpkin> but it's not too terrible
16:17:09 <dmwit> merijn: A type sum is a type that can be one of several other types.
16:17:19 <monochrom> "closed" is non-extensible. "open" is extensible.
16:17:21 <mauke> A | B | C
16:17:23 <dmwit> merijn: For example, data Either a b = Left a | Right b -- is a sum of the types "a" and "b".
16:17:37 <aavogt> > let half = concatMap (\(b,x) -> guard b >> return x) . zip (cycle [True,False]); splitHalf xs = (zipWith const xs (half xs),drop (length (half xs)) xs) in splitHalf [1..]
16:17:38 <lambdabot>   ([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
16:17:39 <dmwit> merijn: And monochrom has beat me to explaining the other bit.
16:17:40 <dmwit> =)
16:17:48 <monochrom> and yeah, "sum" means having alternatives.
16:18:10 <aavogt> > let half = concatMap (\(b,x) -> guard b >> return x) . zip (cycle [True,False]); splitHalf xs = (zipWith const xs (half xs),drop (length (half xs)) xs) in splitHalf [1..10]
16:18:11 <benmachine> I remember when I worked out why sum and product of types were called that
16:18:11 <lambdabot>   ([1,2,3,4,5],[6,7,8,9,10])
16:18:15 <merijn> dmwit: Oh, I know Either yeah, but that's not what I need
16:18:16 <merijn> Basically, what I want is trivial inheritance. i.e. I have a bunch of data structures with a common set of fields and a disjunct set of fields and don't want to implement the common set + accessor functions for each data structure
16:18:17 <benmachine> I was going to write a thing about it but I never did
16:18:20 <jmcarthur> inheritance is open type sums from a certain type theoretic point of view, but there's also the issue of implementation inheritance
16:18:44 <dmwit> > let f xs = take (genericLength xs `div` S (S O)) xs in f [1..]
16:18:45 <lambdabot>   Not in scope: data constructor `S'Not in scope: data constructor `S'Not in ...
16:18:47 <dmwit> aww
16:19:07 <copumpkin> > 2 :: Natural
16:19:08 <lambdabot>   Not in scope: type constructor or class `Natural'
16:19:10 <copumpkin> bah
16:19:11 <pickles> so, does lambdabot have a run/stack limit, or is it possible to send it into an inf recursive loop?
16:19:18 <monochrom> Did you know?  data Haha = Firstly { n::Integer} | Secondly { n::Integer, b::Bool } | Thirdly { b::Bool } | Fourthly
16:19:30 <benmachine> all programs have a stack limit :P
16:19:37 <pickles> yeah, but i mean will it quit
16:19:38 <dmwit> pickles: Give it a try!
16:19:39 <dmwit> =)
16:19:44 <benmachine> lambdabot also has a time limit
16:19:46 <merijn> I mean, what I really just need is need is a "C struct" which I can subclass to add additional fields. I could trivially do that by doubling the fields for each data structure, but I'm lazy as hell
16:19:48 <pickles> or will it run till it crashes?
16:19:48 <monochrom> lambdabot imposes a time limit too.
16:19:59 <pickles> ah
16:20:03 <dmwit> pickles: Try it, try it!
16:20:12 <jmcarthur> merijn: class HasFoo a where getFoo :: a ; data Foo = Foo Int ; instance HasFoo Foo where getFoo (Foo x) = x ; data Bar = Bar Foo String ; instance HasFoo Bar where getFoo (Bar foo _) = getFoo foo
16:20:29 <jmcarthur> merijn: Bar "inherits" from Foo, in that example
16:20:33 <dmwit> See if you can find an exploit. We sure have been... for like ten years. =)
16:20:38 <pickles> dmwit: i think i've been in this room too short a time to pull such an asshole move ;)
16:20:41 <jmcarthur> merijn: and both Foo and Bar implement getFoo
16:20:44 <benmachine> > let x = x in x
16:20:48 <lambdabot>   mueval-core: Time limit exceeded
16:20:52 <benmachine> tada
16:20:55 <pickles> hehe
16:20:58 <dmwit> pickles: Okay, one of us will try it for you. ;-)
16:21:01 <monochrom> I surely found an exploit.
16:21:06 <monochrom> > putStrLn "x"
16:21:07 <lambdabot>   <IO ()>
16:21:13 <monochrom> > putStrLn "<IO ()>"
16:21:14 <lambdabot>   <IO ()>
16:21:17 <monochrom> Hacked.
16:21:24 <amxx> omg
16:21:26 <Peaker> ;-)
16:21:34 <dmwit> sploits, onoes!
16:21:43 <merijn> jmcarthur: Hold on, I'll look at that more closely to see if its what I mean
16:21:49 <benmachine> > print putStrLn
16:21:49 <ddarius> putStrLn wouldn't write to IRC
16:21:50 <lambdabot>   <IO ()>
16:22:03 <benmachine> ddarius: it might do!
16:22:15 <ddarius> > fix print
16:22:15 <lambdabot>   <IO ()>
16:22:34 <benmachine> if you made some bizarre use of dupTo and so forth
16:23:01 <dmwit> Oh, yeah, I guess there has to be a Show instance for (IO ()) for \bot to pull this magic in the first place.
16:23:04 <dmwit> That's pretty funny.
16:23:34 <jmcarthur> merijn: i could even take it a step farther:  data Baz a = Baz a Double ; instance HasFoo a => HasFoo (Baz a) where getFoo (Baz x _) = getFoo x
16:23:48 <jmcarthur> merijn: so there Baz has a foo if its parameter has a foo
16:23:57 <pickles> > data Pickles = Dill | Gerkin
16:23:59 <lambdabot>   <no location info>: parse error on input `data'
16:24:17 <pickles> darn
16:24:18 <Peaker> pickles: only expressions :-(
16:24:23 <pickles> :(
16:24:53 <fax> yeah it is really weird that you can't add new data... such a shame
16:24:55 <Peaker> are these the pickles brothers?
16:25:33 <jmcarthur> it would be awesome if we could define new type in let and where
16:25:37 <jmcarthur> *new types
16:25:53 <aavogt> tuples and Either
16:25:54 <jlouis> jmcarthur: Standard ML can
16:25:59 <jlouis> it is really useful
16:26:00 <Peaker> lexically scoped newtypes with Monoid instances!
16:26:00 <jmcarthur> jlouis: yeah i know
16:26:13 <aavogt> implicit params anybody?
16:26:43 <jlouis> jmcarthur: and exceptions... though one may regard that as a nasty loophole
16:26:44 <jmcarthur> Peaker: yeah that would be a pretty cool use of it
16:27:18 <pickles> Peaker: only part of the pickle family
16:27:26 <jmcarthur> would require instances in let and where, too, though
16:27:55 <Peaker> jmcarthur: it would make manual dict passing and type-classes equivalent in power
16:28:04 <benmachine> pickle instance Dill
16:28:09 <jmcarthur> yup
16:28:22 <Peaker> jmcarthur: Yeah, lexically scoped newtypes don't matter that much I think, mainly the instances matter.
16:28:26 <benmachine> where class Monad m
16:28:27 <Peaker> (for power considerations)
16:28:37 <benmachine> oh hey
16:28:40 <jmcarthur> eh, i would like the scoped types too
16:28:56 <benmachine> nested type classes!
16:28:58 <Peaker> jmcarthur: well those can be passed as type arguments.. instances can't accept arguments
16:29:04 <benmachine> this as an idea makes no sense whatsoever
16:29:14 <jmcarthur> benmachine: there's constraint families
16:29:25 <jmcarthur> well, the idea exists anyway
16:29:28 <jmcarthur> no extension yet
16:29:29 <aavogt> that's because the existing haskell has closed your mind to such insanities
16:29:46 <benmachine> heh
16:29:46 <jmcarthur> benmachine: i want a constraint families extension though
16:29:53 <benmachine> it sounds interesting
16:29:55 <Peaker> "anything you do, I can do meta" -- if you have meta-types = classes, meta-classes = constraint-families, you'll end up in infinite meta-land
16:29:57 <benmachine> first-class EVERYTHING
16:30:03 <benmachine> (wait, isn't that basically just lisp)
16:30:06 <EvanR> how is haskell with databases
16:30:15 <ickabob> could somone explain to me what a haddock interface is?
16:30:23 <aavogt> it is a file
16:30:32 <ickabob> aavogt: used for what?
16:30:33 <jmcarthur> benmachine: http://tomschrijvers.blogspot.com/2009/11/haskell-type-constraints-unleashed.html
16:31:56 <aavogt> ickabob: It's used by haddock to generate indexes (so listings of modules from multiple packages) and also maybe for knowing which instances exist when documenting a class
16:32:22 <aavogt> I'm just taking a guess at the latter
16:32:34 <jmcarthur> benmachine: it's not really nested type classes, but it's similar in power
16:33:11 <ickabob> aavogt: thanks
16:33:55 <jlouis> EvanR: http://hackage.haskell.org/packages/archive/pkg-list.html look up "Databases"
16:34:01 <merijn> jmcarthur: Your example works, but still a lot more verbose then I'd want. Example construction of what I'm referring to http://dpaste.com/173153/ and some fictional syntax representing the type of shortcut I'm looking for.
16:34:52 <EvanR> so HDBC has mysql now
16:35:07 <creichen> Hmm.  If I'm folding a (concrete) list into an (abstract) set datatype, would that still be a catamorphism?
16:35:27 <fax> merijn?? data Bar = Bar { foo :: Foo , ... } ?
16:35:42 <jlouis> EvanR: I haven't *used* any of those, mind you
16:35:48 <jmcarthur> merijn: really you want to be composing data structures to get more complex ones, not making complex ones that you use in the raw
16:36:01 <Peaker> creichen: the fold function itself would be the catamorphism (of the list)
16:36:08 <lispy> Did someone need a database library?
16:36:11 <Peaker> creichen: how you use the catamorphism function is a different thing
16:36:18 * lispy has been using Takusen lately
16:36:21 <jmcarthur> merijn: that is, you make simple data structures with simple operations and then compose them to automagically get more complex structures with more complex operations
16:36:30 <jmcarthur> semiautmagically, anyway
16:36:34 <EvanR> jlouis: hmmmm
16:36:42 <lispy> It has some bugs in the ODBC drivers, but the native MySQL and Postgres backends seem to be solid
16:37:03 <creichen> Peaker: that makes sense to me, thanks!
16:37:10 <lispy> I think Alistair will be releasing some bug fixes for the ODBC backend now too
16:37:11 <jmcarthur> fax: that was the suggestion i made. merijn is just wanting to use the same accessors for both types
16:37:33 <jmcarthur> fax: like you would get with implementation inheritance in an OO language
16:37:40 <lispy> EvanR: so does that answer your question?
16:37:44 <fax> the idea is to write out the data definitions in your own made up syntax
16:37:47 <EvanR> lispy: yes
16:37:48 <lispy> I didn't use HDBC because it's GPL
16:37:51 <fax> then translate it into real haskell
16:37:56 <jmcarthur> lol
16:38:04 <fax> then you can not worry about having to write out lots of typeclass instances manually
16:38:13 <EvanR> is GPL not a common license for haskell code
16:38:16 <fax> one day, the IDE, Eclipse will help us to program by automating these tasks
16:38:35 <lispy> EvanR: BSD3 is highly recommended
16:38:44 <jmcarthur> EvanR: i would say it has a lower-than-normal rate of use in the haskell community, but not necessarily uncommon
16:38:48 <lispy> EvanR: I didn't use GPL because this is at work
16:38:53 <pickles> you'd thinkg that libaries would use BSD since it's more a dev liscense, whereas GPL is an end user liscense
16:38:56 <fax> I want to make an algebra program
16:38:59 <jmcarthur> EvanR: i'm a fan of permissive licenses and a lot of others are too, but not all
16:39:03 <fax> but I cant do it with current languages
16:39:13 <fax> so I am thinking about making an sort of umm
16:39:27 <merijn> jmcarthur: I know, I'm just trying to figure out the way to get where I want with the least amount of typing. I'm messing around with writing a game in haskell, which means I have various data types with for instance locations and size. And want the least amount of writing to be able to use them polymorphically
16:39:27 <fax> heireacrly diagram, and have ti turn into the source code with gaps where you got to implement
16:39:30 <EvanR> that is a relevant topic for me, since... i might have to write a program for work
16:39:38 <EvanR> and it might be least painful in haskell
16:39:45 <fax> merijn,
16:39:48 <fax> I have an idea!!
16:39:54 <fax> but I should try it out first
16:39:56 <jmcarthur> merijn: then you have a location type and a size type
16:39:57 <lispy> EvanR: Some people have argued that because of cross module inlining the GPL is especially problematic for Haskell.  I'm not a lawyer, so I don't know if it's a meaningful case.
16:39:59 <fax> because it might go wrontg :D
16:40:14 <merijn> EvanR: I'm personally a fan of new style BSD/MIT licenses for open source code
16:40:38 <ddarius> fax: Is your algebra program going to solve undecidable problems?
16:40:51 <fax> ddarius, not all of them!
16:41:04 <EvanR> lispy: cross module inlining?
16:41:17 <jmcarthur> merijn: okay, say you have an Enemy data structure
16:41:21 <EvanR> i hate it when linking method somehow has legal significance
16:41:38 <jmcarthur> merijn: the idea is that instead of putting the enemies location and size into the structure, you keep that information separate entirely
16:41:45 <fax> ddarius, I just want to implement all the algorithms I know into a computer... then have a way to write scripts which conncet them together --- I think I could prove theorems with it but I have huge amounts of foundational stuff to implement before I can do anything :(
16:41:46 <jlouis> EvanR: functions from GPL code can be inlined across module boundaries, thus poisoning the rest of the code
16:41:56 <EvanR> ok but what about LGPL
16:42:01 <merijn> jmcarthur: Of course, but each "object" (not in the OO sense of the world) has those, but those won't all be the same data types. So I want to figure out a generic way of describing those kinds of structures. But maybe I should just type class that kinda thing liberally
16:42:15 <jmcarthur> merijn: so you could pass around just Enemy when that's all you need, or you could pass around (Enemy, Location) when you need both
16:42:20 <EvanR> jlouis: and doesnt any form of linking result in GPL poisoning
16:42:31 <[cz]sleepwalker> hello guys, how can i cast one type to another (GLfloat to GLsizei)?
16:42:46 <jlouis> EvanR: I am not the one making the argument. Honestly, I couldn't care less about licenses
16:42:53 <merijn> jmcarthur: That's nonsensical as a location is an inherent value of an "Enemy" type.
16:43:01 <jmcarthur> merijn: no it's not
16:43:30 <jmcarthur> merijn: i'd argue that it's more nonsensical for a location to be an integral description of any object in a game world
16:43:34 <jmcarthur> :)
16:43:43 <jmcarthur> *integral part of the description
16:43:47 <merijn> Why? If it doesn't have a location is does not exist
16:43:51 <merijn> s/is/it
16:44:00 <jmcarthur> merijn: does having a location make it exist?
16:44:16 <merijn> jmcarthur: In my view, yes
16:44:34 <jmcarthur> merijn: have you ever coded a large game engine?
16:44:49 <jmcarthur> merijn: you typically end up keeping object positions in a separate collection anyway
16:45:02 <merijn> I'd say an object is a set of values location, status, size, what not.
16:45:05 <jlouis> merijn: without the split location, you end up into troubles when you want to generate a new Enemy, but does not yet know where to place it
16:45:13 <jmcarthur> merijn: then you are thinking like a true OO programmer
16:45:21 <merijn> jmcarthur: I suppose
16:45:28 <jmcarthur> merijn: but haskell is not OO, and OO is not the only design strategy out there
16:45:33 <EvanR> its object oriented when you think you can change those values
16:45:43 <EvanR> and should
16:45:46 <EvanR> like keeping a small database
16:45:47 <[swift]> to me the main reason to keep the locations separate is that you are going to need to search them fast, eg for collisions
16:45:59 <EvanR> and you end up in hell
16:46:01 <jmcarthur> [swift]: that's one reason
16:46:05 <[swift]> it makes sense to hold locations in a data structure optimized for that
16:46:20 <merijn> jmcarthur: You don't need to tell me that OO isn't the only way.
16:46:31 <merijn> [swift]: Ok, I'll grant you that location might have been a bad example
16:46:39 <jmcarthur> merijn: i only point out the "obvious" because it's not always obvious
16:46:42 <jlouis> I am passionate at pointing out that OO is never the way :)
16:46:45 <merijn> But the argument then still holds for things like status and size
16:46:52 <jmcarthur> merijn: i'm not making any assumptions about your knowledge, for the record
16:46:59 <jmcarthur> merijn: nope :) i disagree
16:47:23 <jmcarthur> merijn: most functions that use your Enemy type don't care about all of that data at once
16:48:14 <jmcarthur> merijn: your physics want location usually and size sometimes, your ai wants status, your rendering code wants textures, etc.
16:48:26 <EvanR> ai wants position
16:48:31 <jmcarthur> EvanR: sure
16:48:38 <jmcarthur> but i'm just saying these a cross cutting concerns
16:48:48 <jmcarthur> putting them all in a single object isn't really helpful
16:48:48 <merijn> jmcarthur: Yeah, I'm scrapping physics for the sake of simplicity and rendering is optional for now :p
16:48:58 <EvanR> heh
16:49:24 <jmcarthur> and in fact putting them all in a single object places additional burden on you to maintain invariants that would not be necessary otherwise
16:49:27 <merijn> jmcarthur: So you're suggestion would more be to keep (for example) trees for each data type indexed by an ID and only store that ID inside the object?
16:49:39 <jmcarthur> merijn: not necessarily an id either
16:49:55 <jmcarthur> although that wouldn't necessarily be bad
16:50:22 <Cale> merijn: What's the question?
16:50:29 <merijn> jmcarthur: Well, you need some sort of way of finding information on whatever object your referring to at the moment
16:50:35 <jmcarthur> merijn: true
16:50:54 <dmwit> Hahaha. "The 'acronym theory,' that a hard G should be used [in GIF] because it's 'Graphics' and not 'Jraphics,' simply does not hold water [unless you also pronounce 'JPEG' as 'JFEG']."
16:51:20 <EvanR> i say gif as in jraphics
16:51:31 <pickles> same
16:51:37 <EvanR> or giraffe for that mater
16:51:39 <fax> merijn, I made an example for you
16:51:52 <fax> http://dpaste.com/173156/
16:52:09 <merijn> Cale: I'm screwing around with writing a game in haskell to start doing non-trivial haskell programming. Brain storming ideas on handling objects (not in the OO sense) having the same data in a generic/polymorphic way (like http://dpaste.com/173153/)
16:52:09 <jmcarthur> merijn: i'm also not saying you have to *always* keep that data separate. i wouldn't recommend just passing around a bunch of gigantic collections and always indexing into them. you can always stick data together for as long as it makes sense to and then "forget" the association again later
16:52:52 <Cale> merijn: How are these data going to be used?
16:52:58 <Alpounet> byorgey, are you still working on the new version of diagrams ?
16:53:19 <byorgey> Alpounet: yes, in a general sense
16:53:30 <byorgey> as in, I have not worked on it recently but am planning to return to it soon
16:53:37 <byorgey> where soon = after April 2.
16:53:39 <Cale> How about the non-fictional syntax:  data Bar = Bar { foo :: Foo, spam :: String, blam :: Int } ?
16:53:53 <fax> Cale I tried that -- it didn't work :(
16:54:08 <Cale> What didn't work?
16:54:08 <fax> Cale, so now I'm trying to scare him <http://dpaste.com/173156/> intro submission
16:54:23 <fax> Cale, suggesting to contain foo inside Bar
16:54:26 <merijn> Cale: Yeah, someone suggested that too. I think I'll just use something like that combined with moving some data into more global containers
16:54:37 <Alpounet> byorgey, ok, nice. What will your paper be about by the way ?
16:54:48 <fax> merijn you saw my paste though?
16:54:52 <merijn> fax: Yeah
16:54:54 <Cale> merijn: What are these separate types with lots of similar fields?
16:55:06 <fax> well ?
16:55:16 <ivanm> latest email on -cafe looks like homework...
16:55:28 <Cale> merijn: (The example gives no indication on how these things are going to be used)
16:55:34 <jmcarthur> Cale: imagine a game with many types of objects on the game world. they will all share certain kind of properties such as locations
16:55:38 <fax> you can actualyl get rid of 'Element' with a bit more work too
16:55:45 <byorgey> Alpounet: about the implementation of my combinatorial species library, and using combinatorial species to be able to talk more precisely about algebraic data types
16:55:47 <fax> but that's type families
16:55:56 <Cale> If you're doing objects in a game world, probably you want to model them differently from this.
16:56:09 <merijn> Cale: Think of various objects having locations, size, status. Although as discussed earlier you'd probably store some of that in more global data structures (i.e. location)
16:56:52 <Alpounet> byorgey, oh nice! that's related to your research iirc
16:56:56 <Cale> Instead of encoding an object as the product of some defining properties, encode them as the product of operations which apply to all the game objects.
16:57:04 <jmcarthur> data WorldObject = WorldObject Position etc...   data Enemy = Status etc...
16:57:14 <Cale> That tends to unify all the game objects into a single type nicely.
16:57:23 <jmcarthur> ah yeah, that's good to bring up too
16:57:32 <jmcarthur> i was focusing merely on data
16:57:48 <fax> hm nice thing about this record system is that
16:57:56 <merijn> Cale: Yeah, I need to wean myself of my OO intuition
16:58:01 <fax> you can permute them and (if there ar not duplicates) it's the same thing
16:58:11 <Cale> merijn: Well, I'm suggesting a more "OO" approach, effectively.
16:58:22 <byorgey> Alpounet: yes, writing about one's research is the recommended way to write papers ;)
16:58:24 <Eelis> how come's there's no "cabal uninstall" ?
16:58:26 <Cale> For something like a game, it's not inappropriate to do this. :)
16:58:37 <merijn> Cale: I know, but its a different kind of OO
16:58:43 <fax> same kind of OO
16:58:52 <Cale> An object *is* how its methods respond.
16:59:06 <lispy> Eelis: because we're purely functional, no destructive updates :)
16:59:15 <merijn> Normally I'd model the state, now it makes more sense to model the interactions
16:59:17 <Eelis> lispy: i really hope you're kidding
16:59:36 * fax has not found cabal to be completely 'functional'
16:59:55 <Cale> and so what you can do is to define a type whose values consist of implementations of those methods, and then to construct objects with 'private' fields, just use functions with parameters
17:00:12 <lispy> Eelis: There is no uninstall, but 1) cabal accepts patches, 2) you can ghc-pkg unregister, 3) cabal install --reinstall exists for most cases
17:00:18 <ddarius> Eelis: Look at NixOS
17:00:23 <Cale> The function (constructor) parameters are the 'private' bits, and the record fields are the 'public' bits.
17:00:37 <Eelis> lispy: i see. (2) will suffice for me i think. thanks
17:00:49 <Eelis> ddarius: i'm looking to uninstall a cabal package, not install another OS :P
17:01:08 <Cale> and you can keep things pure if you want -- just make any operation that would have mutated an object instead produce a new version of it
17:01:29 <monochrom> After the third world war, cabal will have uninstall. This is because that will be the first time authors of cabal run out of disk space and can't buy new disks.
17:01:31 <merijn> Cale: Oh well, I'll let all the suggestions sink in for tonight and go back to the drawing board tomorrow :)
17:01:37 <Cale> (by possibly mutual recursion, though you needn't always think of it that way)
17:01:46 <Cale> merijn: I have a little article...
17:01:53 <Cale> http://cale.yi.org/index.php/A_look_at_OO_from_Haskell
17:02:32 <merijn> Cale: I'll check it out, thanks
17:03:12 <twink> cale.yi.org doesn't resolve here
17:03:16 <Cale> oh?
17:03:17 <Cale> hmm
17:03:23 <merijn> Works here
17:03:32 <monochrom> 99.247.170.113 if you want
17:03:34 <Cale> You can try cale.x.im perhaps
17:03:49 <Cale> Yeah, that's the right IP.
17:04:15 <twink> I resolved it from elsewhere yeah.
17:09:18 <scotty> hello
17:10:34 <monochrom> Cale: If you like, steal this to add overridable implementations to objects: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=8583
17:12:08 <scotty> does anyone here do opengl programming in haskell?
17:12:58 <monochrom> I don't but other people here do.
17:13:17 <Zao> Once.
17:13:45 <scotty> i'm just now running through some examples for hopengl
17:14:43 <scotty> i've been getting pretty poor performance which is surprising to me
17:15:08 <Darkone> Okay, I give. What's Vim/emacs like for haskell? I have too limited of experience with it. My experience was that it looks useful if you elarn it, but it's a charlie foxtrot if you don't know how to use it.
17:15:17 <EvanR> can i do an action when the program is ended via control c
17:15:23 <EvanR> signal handler
17:15:26 <EvanR> something
17:15:41 <Zao> Darkone: Both are usable.
17:15:42 <scotty> i was sort of wondering what other peoples' experiences were
17:15:54 <mauke> EvanR: yes
17:15:55 <Zao> At least some oddballs in here use Emacs, and I use vim fine with haskell-mode.
17:16:24 <ivanm> @slap Zao
17:16:24 * lambdabot karate-chops Zao into two equally sized halves
17:16:25 <Darkone> I kind of prefer being able to use my mouse for most selections, and generic copy/paste/etc shortcuts. I had to use vim a bit in class, and managed to get consistently annoyed with the whole esc->command thing
17:16:32 <mauke> EvanR: installHandler keyboardSignal (Catch foo) Nothing
17:16:41 <ivanm> Zao: just because we use emacs doesn't make us oddballs
17:16:45 <EvanR> cool
17:16:54 <ivanm> (we might be oddballs, but there's no causality involved! :p )
17:16:59 <ivanm> Darkone: there are other editors available
17:17:03 <ivanm> depending on OS, etc.
17:17:08 <mauke> Darkone: vim has that
17:17:17 <mreh> this function is a monster, could someone suggest improvements: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24087#a24087
17:17:18 <mauke> mouse selection and copy/paste, I mean
17:18:03 <Zao> Darkone: You might be happy with Leksah.
17:18:09 <Darkone> Yea, spent the last while working on trying to get eclipse FP2 working right, until fidning out that to install the new version of it, you have to do some stuff out of eclipse. I was following a thing for .1, hoping it worked :P
17:18:09 <Zao> Darkone: Or if you're strange, Eclipse.
17:18:31 <ivanm> Zao: except leksah is a pain to build, etc.
17:18:40 <Darkone> Zao, what is the smoothest way to do leskah, from a Windows 7 with nothing on it standpoint?
17:19:03 <ivanm> Darkone: there are pre-built exes of leksah IIRC
17:19:07 <Zao> Install gtk2hs installer, install leksah.
17:19:08 <Darkone> I just installed the platform, and GHC 6.12 I think
17:19:21 * mreh uses a text editor
17:19:26 <Zao> 43080     Mar 15 Hamish Mackenzi (  15) [Haskell-cafe] ANNOUNCE: Mac and Windows installers for Leksah 0.8 prerelease available
17:19:36 <Zao> http://leksah.org/news.html
17:22:42 <monochrom> Darkone: emacs and haskell is like heaven.
17:23:10 <pickles> imma have to learn emacs or vi one of these days
17:23:24 <pickles> my friend says the GDP of the world will rise 1% when i do
17:24:17 <merijn> pickles: s/vi/vim
17:24:23 <merijn> vi sucks balls
17:24:51 <merijn> Learning vim on the other hand, was the best time investment I ever did.
17:25:03 <merijn> Well, starting to learn vim. I don't think I'll ever finish
17:25:10 <jcreigh> if he doesn't know vim, what are the odds he understands s/vi/vim/? :)
17:25:14 <pickles> ah, one of those types of projects
17:25:25 <pickles> yes, i was puzzling over that line
17:25:32 <merijn> jcreigh: sed and a bunch of other tools use the same syntax
17:25:36 <Darkone> jcreigh, common usage
17:25:42 <merijn> I'm pretty sure vi/vim copied it from sed and friends
17:25:45 <Darkone> On the internet that is.
17:25:48 <Darkone> :P
17:26:09 <jcreigh> merijn: or sed and vi both copied it from ed. I'm not 100% sure.
17:26:13 <monochrom> Oh common internet usage. The common internet usage is "*vim" rather than "s/vi/vim"
17:26:16 <Darkone> Alot of people use s// to make corrections. I use it when the correction isn't blatantly obvious :V
17:26:16 <merijn> pickles: It's a regex replace meaning (S)ubstitute the first part with the second part
17:26:31 <ddarius> Common Internet usage is not common.
17:26:39 <EvanR> i just patented s/// a few days ago. therefore they all copied to from me, retroactively
17:26:49 <monochrom> And I like to tease people with: so if you just want to delete a word do you write "*"?
17:26:51 <Darkone> Common enough where I hang out >.>
17:26:56 <pickles> hehe
17:27:12 <merijn> monochrom: That's common usage in the teen/facebook demographic :p s// is more common in the hacker demographic
17:27:14 <Axman6> EvanR: sadly, i patented the use of the / for all useful purposes. pay up!
17:27:31 <EvanR> i just patented your soul
17:27:34 <pickles> can i patent it for non-useful purposes?
17:27:35 * Axman6 sues all unix OS vendors
17:27:53 <mreh> do we have a good IDE that will do refactoring for haskell yet?
17:27:59 <monochrom> No.
17:28:07 <mauke> monochrom: no, you write -word
17:28:21 <mreh> a good text editor even?
17:28:30 <monochrom> Oh I thought they preferred to be completely ambiguous.
17:28:39 <pickles> (btw, thx for the explanations)
17:28:40 <monochrom> emacs is a good text editor
17:28:49 <mreh> does it refactor?
17:28:54 <monochrom> err, but not refactor
17:29:05 <mreh> poo poo
17:29:19 <monochrom> We run out of PhD students to do refactoring.
17:29:30 <mreh> heh
17:29:32 <jcreigh> it is a bit of a shame, given out deliciously refactorable Haskell should be...
17:29:51 <Darkone> ...
17:29:51 <ivanm> you mean get HaRe working on modern haskell code?
17:29:55 <Darkone> GAHRGH?!
17:29:58 <EvanR> but it would require coding a gui ;)
17:30:50 <mreh> haskell has the danger of never really growing out of hanging around in its bedroom talking on IRC
17:31:00 <mreh> for that reason
17:31:13 <pickles> i was wondering why so many ppl were here on st patti's day...
17:31:26 <mreh> we have no friends
17:31:38 <EvanR> Network.recvFrom is discouraged?
17:31:39 <merijn> mreh: Automatic refactoring is for crappy languages that have so much boiler plate automatic refactoring is needed and doable
17:31:42 <ivanm> is it? *shrug*
17:31:47 <ivanm> I'm here because I'm at uni
17:31:56 <ivanm> merijn: go see HaRe then
17:32:06 <mreh> merijn: what about namespace refactoring, that's a massive pain
17:32:07 <ivanm> unless you include Haskell as a "crappy language"
17:32:12 <merijn> pickles: Because no one here celebrates St Patrick's day?
17:32:16 <mreh> automatic import statements
17:32:22 <merijn> ivanm: All languages are crap :p
17:32:35 <mreh> those things would all be nice
17:32:36 <merijn> Some just more so then others :)
17:32:43 <Philonous> Argh, why would someone use T as the name for every second Class/Type in a rather big project? Are speaking names not fashionable anymore? "C y' => y' -> T t t' y y' yv -> T t t' y y' yv" -- ouch
17:32:51 <mreh> hehe
17:32:53 <pickles> merjin: valid argument
17:32:55 <Darkone> Noob question time: How can I get gtk2hs to install for 6.12.1?
17:33:02 <mreh> Henning Theilman strikes again
17:33:26 <pickles> darkone: what os/distro?
17:33:35 <mreh> Philonous, what project is that from?
17:33:36 <Philonous> mreh: Heh, this actually is his code
17:33:52 <mreh> Philonous, he's the only person that write code like, of whom I am aware
17:33:53 <Philonous> mreh: synthesizer
17:33:57 <Darkone> pickles, Windows 7 Pro
17:34:07 <mreh> Philippa, hudak's yampa synth?
17:34:15 <pickles> hm, not used that
17:34:22 <Darkone> Yea, I'm having all sorts of fun in a crash course on installing packages ;_;
17:34:24 <pickles> barely installed cabal on xp myself
17:34:25 <mreh> Philonous, ^^
17:34:32 <pickles> in kubuntu had to use their pkg mgr
17:35:19 <Philonous> mreh: No, no FRP, just ordinary signal processing by Thielemann
17:35:36 <pickles> darkone: u have cabal installed?
17:35:39 <mreh> ooh, fun
17:35:58 <Darkone> I think so, currrently palying with it. On a side note, this strikes me as funny for some reason
17:36:08 <Darkone> To upgrade, run: cabal install cabal-install
17:36:24 <Darkone> YAY ITS WORKING
17:36:24 <pickles> heheh, yah, almost recursive
17:36:26 <Philonous> mreh: I have written jack bindings and wanted to produce some noise
17:36:37 <Darkone> Something actually worked, TRIUMPH!
17:37:07 <pickles> darkone: be careful, you know what they say happens when you play with your caballs
17:37:10 <mreh> the tools are there, I want to see more Haskell art
17:37:11 <Darkone> ...And then it failed. Time to go back, and run cmd as admin
17:37:22 <mreh> Haskelloids is on its way lads
17:37:57 <Darkone> There we go.
17:39:15 <Darkone> And now it's not.
17:39:26 <Darkone> pickles, cabal is installed it apears.
17:39:47 <Philonous> mreh: Well, I had trouble finding any sensible library for outputting sound
17:39:49 * ivanm points out that Cabal comes with GHC...
17:39:57 <pickles> hm...
17:40:00 <Darkone> But, trying to use it to install leksah complains about not having glib, gtk, gtksourcereview2
17:40:08 <EvanR> yeah, how is haskell in the world of audio
17:40:13 <mreh> Philonous, Haskore?
17:40:14 <Darkone> And then complains that no available version of those exists.
17:40:15 <ivanm> Darkone: install gtk2hs
17:40:35 <ivanm> gtk2hs isn't cabalised, and so isn't on hackage; hence cabal-install can't install it
17:40:36 <pickles> hooray ivanm, always supplementing my lack of knowledge! (thx!)
17:40:40 <Darkone> Which is related to gtk2hs not installing properly for GHC 6.12.1
17:40:52 <Darkone> Apparently. I probably screwed something up.
17:40:52 <ivanm> pickles: what this time?
17:41:14 <ivanm> Darkone: there is as yet no release for gtk2hs that is compatible with 6.12
17:41:14 <pickles> my not knowing much about cabal
17:41:17 <Darkone> So, I installed haskell platform, and 6.12.1
17:41:18 <Philonous> mreh: As I understand it, haskore is a system for processing scores, but it relies on 3rd-party libraries for actually speaking to the hard ware
17:41:19 <ivanm> aha
17:41:20 <Zao> ivanm: Sure there is.
17:41:28 <ivanm> Zao: there was a release made? :o
17:41:32 <Darkone> Zao, save me? D:
17:41:35 <Zao> ivanm: leksah 0.8 includes it at least.
17:41:41 * ivanm doens't recall seeing any announcements
17:41:42 <Zao> Which I linked, up there.
17:41:46 <Zao> ivanm: A post on the list.
17:41:47 <ivanm> Zao: maybe they took a snapshot...
17:41:52 <ivanm> or manually applied the patch
17:41:57 <Zao> http://leksah.org/news.html
17:41:59 <ivanm> which list? cafe?
17:42:09 <Zao> Also, http://haskell.org/gtk2hs/archives/2010/01/18/compiling-with-ghc-612/
17:42:10 <Zao> Yes.
17:42:59 <ivanm> as I said, there's no _release_ of gtk2hs that works with 6.12
17:43:15 <ivanm> the live version works, manually applying a patch onto the latest release works
17:43:17 <Zao> I assumed there were, as leksah supposedly does it.
17:43:30 <mreh> Philonous, yes, that's correct, are there not CSound bindings?
17:43:34 <Zao> I stand slightly corrected.
17:43:49 <ivanm> mreh: have a look on hackage yourself!
17:44:03 * ivanm vaguely recalls hearing something about csound libraries for haskell
17:45:24 <Philonous> mreh: I don't think CSound would be terribly usefull, as it is a sound processing language in it's own right rather than a sound server
17:45:42 <EvanR> port audio
17:46:18 <EvanR> however, if you want to generate sound from algorithms you might want c sound
17:47:16 <pickles> anyone know of a lib for reading plain wave/pcm files
17:47:17 <pickles> ?
17:47:51 <EvanR> would probably be trivial in haskell ;)
17:47:56 <Darkone> Blargarg it worked. THERE WE GO.
17:48:28 <Darkone> Downloaded and threw grep and wget in with the haskell bin, and it started >.>
17:49:15 <Philonous> I wonder what the problem with portaudio was. Anyhow, I've already written my own jack bindings.
17:50:47 <Darkone> Alright. Anyone here actually use leksah?
17:51:25 <Darkone> Need advice on what I need to select for haskell source paths
17:55:34 <Darkone> Victory! No clue whether it actually worked, but it's running!
17:59:40 <SirFrancisDrake> hi there
17:59:59 <ivanm> greetings SirFrancisDrake
18:00:07 <ivanm> a bit out of your time, aren't you? :p
18:00:26 <EvanR> after installing a signal handler, is there an IO command which causes the program to sleep indefinitely
18:00:37 <SirFrancisDrake> I guess. But that's kind of my usual problem
18:00:39 <tensorpudding> There is no Spanish Armada here.
18:00:46 <ivanm> SirFrancisDrake: how's the bowls going?
18:00:54 * ivanm quite enjoyed Crackerjack...
18:04:16 <ClaudiusMaximus> pickles: http://hackage.haskell.org/package/hsndfile
18:04:27 <ClaudiusMaximus> (not used it myself)
18:04:56 <pickles> sweet, thx ClaudiusMaximus
18:08:14 <gloob1> can you see where the problem is?
18:08:14 <gloob1> msg <- (show posX)  ++ " " ++ (show posY)
18:08:14 <gloob1>     hPutStrLn hdl msg
18:08:14 <gloob1> ghc says:
18:08:14 <gloob1> Couldn't match expected type `String' against inferred type `Char'
18:08:33 <aavogt> gloob1: you want  let msg =
18:08:54 <gloob1> oh:) thanks
18:08:57 <Zao> <- sucks things out of monads. It tries to extract Chars from the String.
18:09:03 <Zao> In the List monad.
18:09:46 <aavogt> but you should be in IO if you want to use hPutStrLn
18:10:27 <tensorpudding> if a monad is like a milkshake, then <- is like a straw
18:10:33 <EvanR> lol
18:10:40 <fax> loool
18:10:54 <EvanR> now i want a milkshake
18:10:59 <EvanR> dammit
18:10:59 <ivanm> not _another_ monad simile...
18:11:00 * aavogt wants a monad
18:11:04 <pikhq> If a monad is like a burrito, then <- is still like a straw. However, you're sick for trying to drink a burrito.
18:11:29 <EvanR> they should have called Monad Burrito instead
18:11:37 <pickles> i thought they were burritos?
18:11:38 <EvanR> less intimidation and confusion
18:11:49 <pickles> so, it's like a blended up burrito milkshake?
18:12:28 <Alpounet> yay, burrito transformers
18:12:55 <pickles> would they be decepticons?
18:13:13 <aavogt> > uncurry zip (inits "burrito",tails "monad")
18:13:13 <lambdabot>   [("","monad"),("b","onad"),("bu","nad"),("bur","ad"),("burr","d"),("burri",...
18:13:22 <EvanR> lol
18:13:53 <aavogt> > uncurry (zipWith (++)) (inits "monad",tails "burrito")
18:13:55 <lambdabot>   ["burrito","murrito","morrito","monrito","monaito","monadto"]
18:14:36 <pickles> Monadito!
18:14:40 <aavogt> but perhaps there are better combinations
18:16:33 <SirFrancisDrake> monrito sounds also good
18:17:45 <pickles> ciao jao
18:18:40 <pikhq> > [x++y|x<-inits "monad"|y<-tails "burrito"]
18:18:41 <lambdabot>   ["burrito","murrito","morrito","monrito","monaito","monadto"]
18:21:11 <aavogt> > length $ do _ <- inits "monad"; _ <- tails "burrito"; return ()
18:21:12 <lambdabot>   48
18:22:40 <aavogt> > (2*) $ length $ do _ <- tail $ inits "monad"; _ <- tail $ tails "burrito"; return ()
18:22:41 <lambdabot>   70
18:23:21 <aavogt> hmm, that's not too many options
18:27:32 <Darkone> Uhhmmm
18:28:46 <Darkone> Trying to use leksah, leksah-server.exe: can't find a package database at C:\Program Files (x86)\Haskell Platform\2009.2.0.2\package.conf.d
18:29:09 <Darkone> There's a package.conf, but no package.conf.d    what is the .d file?
18:30:30 <theorbtwo> Darkone: Generally, foo.d is a directory full of files, and you consider each of them a foo.
18:30:54 <Saizan> Darkone: since 6.12 the package db started being a directory, rather than a file
18:31:17 <Saizan> so maybe leksah is confused.
18:31:29 <Darkone> It's as confused as I am :P
18:31:30 <ivanm> if this is a precompiled version, it probably expects GHC 6.12
18:31:42 <Darkone> I have GHC 6.12.1
18:31:56 <Darkone> And I was trying to add the Haskell Platform stuff as a source folder
18:32:19 <Saizan> the haskell platform is for 6.10, afaik
18:32:28 <Darkone> Yea, it comes with 6.10.4
18:32:58 <tensorpudding> There will be a new version of the platform soon though.
18:34:31 <ivanm> this weekend hopefully
18:34:49 * ivanm wonders why SirFrancisDrake came here, since he didn't really say anything or ask any questions
18:35:11 <jcreigh> some people just lurk.
18:35:18 <pickles> like me!
18:35:21 <tensorpudding> He was looking for the Spanish Armada.
18:35:29 <theorbtwo> Lurking in a channel like this can teach you a decent bit.
18:35:37 <HugoDaniel>  :)
18:35:42 <pickles> or confuse the hell outof you
18:35:49 <theorbtwo> Yes, that too.
18:35:55 <HugoDaniel> lets all define a Lurk monad
18:36:08 <pickles> lambdabot won't let you :(
18:36:12 <HugoDaniel> oh
18:37:24 <ddarius> lambdabot: @attack!
18:37:24 <lambdabot> Unknown command, try @list
18:37:42 <pickles> rofl
18:38:34 <ivanm> preflex: seen blackdog_
18:38:34 <preflex>  blackdog_ was last seen on #haskell 54 days, 29 minutes and 25 seconds ago, saying: because of all the new dynamic library stuff
18:42:13 <pickles> prefix: seen [|]
18:42:22 <pickles> gah
18:42:29 <pickles> preflex: seen [|]
18:42:29 <preflex>  Sorry, I haven't seen [|]
18:43:01 <aavogt> preflex: seen jrib
18:43:01 <preflex>  jrib was last seen on #xmonad 8 days, 7 hours, 12 minutes and 38 seconds ago, saying: Bruners: if you want a guess, mine would be that something else is resetting it
18:43:19 <pickles> preflex: seen the-invisible-woman
18:43:20 <preflex>  Sorry, I haven't seen the-invisible-woman
18:43:31 <aavogt> pickles: perhaps preflex only sees people that talk
18:43:42 <pickles> mm, could be
18:43:48 <ivanm> yes, strangely enough
18:43:48 <pickles> that las was for the humor of it
18:59:38 <pickles> lambdabot: putStrLn "preflex: seen pickles"
19:01:17 <pickles> wrong syntax?
19:01:26 <pickles> gah
19:01:40 <pickles> > putStrLn "preflex: seen lambdabot"
19:01:41 <lambdabot>   <IO ()>
19:01:52 <copumpkin> it won't work
19:01:57 <pickles> dang
19:02:03 <pickles> something im doing wrong?
19:02:12 <copumpkin> lambdabot won't run IO, first of all
19:02:18 <dankna> no, it just doesn't run IO
19:02:21 <copumpkin> second, it inserts a space before everything it outputs
19:02:29 <copumpkin> precisely to stop you from triggering other bots with it
19:02:31 <dankna> haha, somebody thought of that before, haha
19:02:36 <pickles> hehe
19:03:40 <Cale> > text "preflex: seen lambdabot"
19:03:42 <lambdabot>   preflex: seen lambdabot
19:03:50 <tommd> preflex: seen tibble
19:03:50 <preflex>  Sorry, I haven't seen tibble
19:03:53 <tommd> yes you have!
19:04:02 <nnp> hey guys, I have a 7 line function that currently won't compile (It's here http://haskell.pastebin.com/iLAeUnFT). The error is ERROR "./Tmp.hs":6 - Syntax error in expression (unexpected `(') when I try loading it in hugs. Any pointers in the correct direction are appreciated
19:04:02 <Cale> preflex: seen tibbe
19:04:02 <preflex>  tibbe was last seen on #haskell 4 hours, 56 minutes and 1 second ago, saying: dons: send me your phone no just in case
19:04:06 <ivanm> except for lambdabot's extra space prefix...
19:04:09 <tommd> right!
19:04:10 <tommd> oops
19:04:42 <Cale> nnp: Indentation: the ( in (curr, remain) should align with the b in begin from the previous line
19:04:54 <copumpkin> nnp: might want to dump the hugs
19:05:04 <copumpkin> nnp: GHC is better all around unless you have a particular reason for using hugs
19:05:06 <ivanm> Cale: *sigh* took me forever to explain something like that to my students yesterday
19:05:15 <Cale> nnp: Since those definitions are siblings, they should line up vertically.
19:05:15 <dankna> nnp: I strongly suspect you meant (begin : (curr : traceToList remain))
19:05:25 <ivanm> first I did it up the front of the class, then I had to go around to half of them and explain it one-on-one :s
19:05:27 <nnp> doh
19:05:28 <pickles> > text "hm...\n"
19:05:29 <lambdabot>   hm...
19:05:30 <dankna> nnp: that probably isn't your problem, but it's another problem
19:05:47 <nnp> yea, the problem was indentation (or at least that problem was)
19:06:00 * ivanm swears that biologists pick up programming easier than engineers do
19:06:11 <dankna> ivanm, that's an interesting assertion
19:06:13 <Cale> nnp: You should also get into the habit of pattern matching more
19:06:32 <ivanm> dankna: last year I helped teach first year science students python
19:06:32 <tommd> @tell tibbe I seem to remember Johan saying you and he had worked out a new network package architecture?  Is that true or is my memory faulty and it would still be worthwhile for me to propose a new architecture + initial code?
19:06:32 <lambdabot> Consider it noted.
19:06:45 <copumpkin> tommd: tibbe is Johan
19:06:46 <ivanm> this year I'm tutoring first year CS + Eng students in Haskell
19:06:51 <Cale> nnp: Occurrences of the head and tail functions together in a definition are often a good sign that you're not using enough pattern matching :)
19:06:57 <tommd> copumpkin: #@$#@ that explains a lot!
19:07:00 <ivanm> even stuff like proper indentation was picked up easier by the biologists
19:07:03 <tommd> thanks.
19:07:04 <copumpkin> :)
19:07:11 <dankna> ivanm: well... it's not directly comparable, but I think you might have some sample bias
19:07:18 <dankna> people who want to be "scientists"
19:07:24 <ivanm> dankna: in what sense?
19:07:26 <tommd> @tell tibbe ok, so I got my names crossed - still - have you worked out a new architecture or is a new one still needed?
19:07:27 <lambdabot> Consider it noted.
19:07:32 <dankna> versus people who want to be associated with the glamour of computers
19:07:39 <dankna> in the sense of the students
19:07:48 <ivanm> well, the cities were different as well... maybe Brisbanites are smarter than Canberrans?
19:07:57 <dankna> first-year students in most disciplines are not typical of the students who graduate in those disciplines
19:08:08 <ivanm> dankna: the science students also understood why programming was important more than the engineers do
19:08:09 <pickles> @tell lambdabot > text "hello"
19:08:10 <lambdabot> Nice try ;)
19:08:13 <pickles> rofl
19:08:22 <jmcarthur> lol
19:08:25 <dankna> ivanm: it's certainly an interesting observation
19:09:09 <theorbtwo> I think science students go in expecting to need to learn a lot of math, so learning programming too doesn't seem so odd.
19:09:30 <theorbtwo> Engeneering students epxect to be mostly learning about their discipline, not the related stuff.
19:09:57 <nnp> cale: oh, cool. So you'd recommend instead of using guards I would use f x:xs style patterns for the function definition?
19:10:08 <pickles> i would agree w/ that theorbtwo, as a former eng student
19:10:08 <nnp> (also, this channel is like scary busy)
19:10:19 <pickles> npp: we're just bored ;)
19:10:29 <dankna> there are a lot of possible explanations...  it would be fascinating to do a real study on the subject
19:10:51 <ivanm> theorbtwo: hell no; this was a course teaching first year science students maths + programming + basic science stuff
19:10:54 <nnp> I'm generally lucky to have sufficiently esoteric interests that > 30 users is a novelty for me :P
19:11:00 <ivanm> the biologists were complaining about the maths
19:11:11 <ivanm> (until they got into the course and worked out that, you know, maths can be _useful_)
19:11:12 <Cale> nnp: yeah, f [x] = ... for the length 1 case, and f (x:xs) for the rest
19:11:15 <aavogt> they don't usually have much math to do
19:11:17 <dudelylama> Hello, I feel a bit dense asking, but why is [3,2,1] > [2,10,100] True?
19:11:26 <ivanm> dudelylama: 3 > 2
19:11:35 <Cale> dudelylama: Because it compares the lists like you'd compare words in a dictionary
19:11:38 <aavogt> dudelylama: because the ord instance sorts things like in a dictionary
19:11:47 <ivanm> > [1,2] < [1,2,3]
19:11:48 <lambdabot>   True
19:12:29 <Cale> nnp: Note that calling length is also a bad thing for efficiency/correctness in general, since lists can be infinite and length will just spin forever if that happens. (Sometimes it's still what you want, but if you can avoid it, it's often a good idea)
19:12:33 <dudelylama> Blah...still not following...
19:12:54 <ivanm> dudelylama: it compares the two first elements; if they're the same it compares the two second elements, etc.
19:12:57 <dankna> dudelylama: step one of comparing [a, b, c] to [d, e, f]: compare a to d
19:12:57 <Cale> dudelylama: To compare two nonempty lists, compare the first elements, then, if they're equal, compare the tails
19:13:09 <Cale> dudelylama: and the empty list is smaller than anything else
19:13:12 <ivanm> @src [a] ord
19:13:12 <lambdabot> Source not found. It can only be attributed to human error.
19:13:13 <dudelylama> Got it
19:13:15 <aavogt> > sortBy (on compare length `mappend` compare) ["aardvark","bad","badly"]
19:13:15 <ivanm> @src [a] compare
19:13:15 <lambdabot> Source not found. Wrong!  You cheating scum!
19:13:16 <lambdabot>   ["bad","badly","aardvark"]
19:13:16 <nnp> cale: noted, cheers
19:13:25 <dankna> dudelylama: if a /= d, you're done.  otherwise take the tails and recurse.
19:13:36 <dudelylama> Excellent - Thank you much
19:13:45 <dudelylama> The light just turned on =)
19:13:49 <dankna> good :)
19:14:03 <dudelylama> Thanks again, I'm sure you'll see me again!
19:14:36 <dwchandl1r> hi
19:14:44 <Cale> hi
19:15:31 <dwchandler> <-- newbie
19:15:57 <dwchandler> I've got a little data type question or two...
19:16:16 <QtPlatypus> dwchandler: Just ask your question
19:16:43 <dwchandler> I'm trying to make polygons with points that can be either cartesian or spherical, but not mixed
19:17:08 <ivanm> ... OK ...
19:17:08 <Cale> okay
19:17:10 <dwchandler> so I have: data Point = Cartesian ... | Spherical ...
19:17:16 <dankna> no
19:17:27 <copumpkin> you want a GADT and type-level tags
19:17:35 <dankna> data CartesianPoint = CartesianPoint ...
19:17:37 <copumpkin> or maybe not even a GADT
19:17:39 <Cale> Nah, you don't need a GADT
19:17:39 <ivanm> copumpkin: a GADT? really? Why?
19:17:41 <copumpkin> a phantom type parameter
19:17:41 <dankna> data SphericalPoint = SphericalPoint
19:17:44 <ivanm> about to say...
19:17:50 <ivanm> copumpkin: not sure about even needing that
19:18:02 <copumpkin> depends how closed you want it
19:18:06 <ivanm> maybe even just: data Polygon pointType = Polygon [pointType]
19:18:07 <dankna> I don't understand GADTs yet, so I came up with the simple solution :)
19:18:08 <ivanm> or something like that
19:18:24 <copumpkin> his original solution is closed
19:18:31 <copumpkin> a GADT would give you consistency and still be closed
19:18:32 <Cale> Just separate types for Cartesian and Spherical points, and then a polygon type which has cases where a polygon is either a list of Cartesian points, or a list of Spherical points.
19:19:08 <copumpkin> (and would save you duplication :P)
19:19:29 <dwchandler> I'll be wanting to use points for other things than polygons, so I'll need to do the same for every consumer?
19:19:30 <ivanm> copumpkin: care to provide a sketch of such a type?
19:19:30 <aavogt> hmm, if you use phantom types, you'd need to write a typeclass to determine which coordinate system you use
19:19:41 <Cale> data Polygon = CartesianPoly [CartesianPoint] | SphericalPoly [SphericalPoint]
19:19:41 <ivanm> dwchandler: pretty much
19:19:59 <ivanm> dwchandler: depends on what you're going to do
19:20:03 <Cale> dwchandler: It all depends on how much you want to check things at compile time.
19:20:22 <ivanm> if you have a typeclass of point types, then you can just use a type parameter to represent that point type
19:20:29 <pickles> well, nite all
19:20:42 <ivanm> otherwise, an approach like Cales would work (but might involve some duplication depending on how you use it)
19:20:42 <copumpkin> data Cartesian; data Spherical; data Point a b where Cartesian :: a -> a -> a -> Point a Cartesian; Spherical :: a -> a -> a -> Point a Spherical
19:20:43 <aavogt>  data Point a = Point Int Int; data Polygon a = Polygon [Point a]
19:20:51 <Cale> dwchandler: It may be more convenient just to create functions which convert and be sure to apply them.
19:21:28 <aavogt> copumpkin: you can't use deriving clauses with that notation, right?
19:21:28 <dwchandler> Cale: I'll have both sorts at once and convert between them
19:21:32 <ivanm> aavogt: what happens if I want (Point 2.3 4) ? :p
19:21:42 <copumpkin> aavogt: probably not
19:22:01 <aavogt> ivanm: I didn't parameterize over the ordinate type for clarity
19:22:14 <aavogt> or whatever you call the pieces of the coordinate
19:22:16 <ivanm> that's what _you_ say! :p
19:22:25 <aavogt> I agree
19:23:01 <dwchandler> interesting. thanks for the tips so far :)
19:28:05 <Zeiris_> Is there some equivalent to the Erlang bit syntax in Haskell? Is such a thing possible?
19:28:22 <jmcarthur> man, there's nothing quite like the feeling of a clean build system with testing and convenient build flags and other niceties
19:28:42 <jmcarthur> Zeiris_: we don't have one that i know of but maybe a quasiquoter would be appropriate?
19:32:12 <sphericalchicken> hm... I seem to have written a program such that when you run it, it just hangs.  It's not using CPU or waiting for input.  What'd I do?
19:32:41 <EvanR> must be waiting for something
19:32:43 <aavogt> perhaps easier to implement is a function that outputs variously sized tuples
19:32:58 <aavogt> (ie. using a typeclass), and then using -XViewPatterns
19:33:03 <sphericalchicken> I vaguely recall hitting something similar a while ago, but I can't recall what it was.
19:34:34 <sphericalchicken> ^C twice stops it, at least. :-P
19:36:00 <aavogt> Zeiris_: but that would be noisier than the quasiquoter:   [$bit| ... whatever erlang's syntax is |] -> expression,   vs.    (bit -> Just (a,b,c,d))  -> expression
19:36:30 <aavogt> then again, tuples might not be expressive enough
19:40:21 <ksf> http://hackage.haskell.org/package/HFuse-0.2.1
19:40:23 <ksf> mhhh
19:40:27 * ksf as a unixgasm
19:44:52 <hireprogrammer> Hello looking for programmer to do something quick for $100
19:45:02 <nnp> in a function that takes type [String] how do you pattern match such that if your pattern is [x:xs] x and xs are Strings, not Chars (using f [x:xs] seems to match against a single element list and splits the string instead of the list)?
19:45:31 <nnp> I'll pastebin an example for clarity
19:45:39 <hireprogrammer> HIRING PROGRAMMER FOR QUICK THING $100
19:46:16 <ivanm> hireprogrammer: go to rentacoder or something then
19:46:44 <ksf> there's haskell coders on rentacoder?
19:47:02 <nnp> http://haskell.pastebin.com/FNJTdENh
19:47:11 <ivanm> ksf: who knows
19:47:18 <ivanm> some Indian will probably claim they know Haskell
19:47:28 <ivanm> this is, of course, assuming that he wants to hire a Haskell programmer
19:47:51 <ddarius> ivanm: It's not like the results aren't easily verifiable.
19:47:59 <tensorpudding> Maybe he's just trolling all the programming channels on freenode.
19:48:07 <ivanm> tensorpudding: that's my guess
19:48:11 <nnp> or any programmer... did he say it was a coding job? Maybe he wants a coder to walk a dog
19:48:25 <ivanm> ddarius: *shrug* they've claimed to be able to solve the halting problem before though
19:49:02 <ddarius> Presumably you don't pay them until receipt of something meeting the specification.
19:49:16 <ezyang> nnp:  You've got your list matching syntax wrong. You actually want (x:xs)
19:49:55 <nnp> ack, epic fail
19:52:39 <CcSsNET> very funny ^
19:52:43 <CcSsNET> sorta
19:52:54 <nnp> this time last week I was decided to take the opportunity of an easy programming task to learn haskell....should have done it in Python :P
19:53:10 <pookleblinky> ivanm, I saw that bid too.
19:53:11 <nnp> 'I was decided'...jesus I can even get English syntax correct today
19:53:26 <pookleblinky> iirc, they removed all the proposals though.
19:53:28 <ezyang> nnp: Tis good for learning
19:55:32 <nnp> aye, almost all the heavy lifting in this app is done in C++ but I had a bunch of data processing/graph analysis that needs to be done so I figured I'd take the opportunity to finally learn Haskell
19:55:42 <nnp> or failing that, make an ass of myself in front of 600 people :D
19:55:56 <nnp> +/- a bot or two
19:56:09 <CcSsNET> mmm 600 people yay?
19:56:49 * CcSsNET just looked at the user list
19:57:03 <jeffwheeler> nnp: most of us aren't paying attention :)
19:57:13 <CcSsNET> exactly
19:57:50 <dwchandler> just a few at a time
19:58:17 <b52> i ran into a little problem while doing an excersie from rwh: http://paste.pocoo.org/show/191001/
19:58:33 <b52> could someone give me a little advice whats wrong?
19:58:51 <ddarius> The interpreter probably can.
19:58:54 <jmcarthur> dang i wish i could put Rational in an unboxed vector
19:59:08 <b52> the function should check if a list is a palindrom or not
19:59:16 <monochrom> b52: isPal' :: Eq a => [a] -> Bool
19:59:19 <ddarius> jmcarthur: Can you put Integers in at all?
19:59:23 <jmcarthur> nope
19:59:29 <jmcarthur> only Int
19:59:43 <jmcarthur> which makes sense, but it sucks
20:00:26 <monochrom> You can't even put Integer in unboxed vector anyway
20:00:35 <b52> monochrom: thanks
20:00:46 <jmcarthur> i would do Ratio Int, but i need to avoid the overflow in this case
20:02:02 <theorbtwo> b52: It is sometimes useful to leave off the type declaration, load it up in ghci, and ask what it thinks the type is (with :t).
20:02:29 <jeffwheeler> j
20:02:32 <jeffwheeler> err, sorry
20:02:38 <theorbtwo> It's probably what you wanted it to be, and even if not, it will tell you something about what you actually wrote, as oppsoed to what you intended to write.
20:03:14 * jmcarthur throws in a bunch of type families so he can do this code the way he wants
20:03:28 <b52> theorbtwo: ok thanks, ill just specify the type to get a better feeling
20:04:09 <theorbtwo> Oh, by all means, specify the type, but if ghc doesn't agree with you about what the type should be, it can be helpful to ask what it thinks.
20:05:24 <ivanm> @tell Axman6 that's it, David Terei can't make it in July, so we'll have to go with September :p
20:05:24 <lambdabot> Consider it noted.
20:05:51 <dancor> so why isn't hbuild in hackagedb
20:06:02 <dancor> Saizan: ^^
20:06:28 <dancor> too ironic?
20:06:55 * ksf thinks hackage should list the number of warnings the test builds give, to make people care about them.
20:07:14 <dancor> agreezy
20:08:00 <dancor> i guess hbuild depends on unstable cabal
20:08:49 <ivanm> never heard of hbuild before
20:09:05 <ivanm> ksf: first we need Cabal to know about tests
20:09:09 <ivanm> (which is a GSoC proposal)
20:09:17 <ivanm> since atm there's no standardised way of running tests
20:09:20 <dancor> hbuild rocks
20:09:22 <aavogt> hmm, cabal test?
20:09:38 <ivanm> aavogt: that's a hack in cabal-install which requires putting an extra hook into Setup.hs
20:09:38 <theorbtwo> It doesn't?
20:09:44 * theorbtwo is quite surprised.
20:09:50 <ksf> ...I don't mean running the tests. just grep the build log for warnings
20:10:16 <ivanm> http://hackage.haskell.org/trac/summer-of-code/ticket/1581
20:10:21 <ivanm> ksf: ahhh
20:10:31 <ivanm> ksf: -Wall output you mean?
20:10:35 <ksf> while -Werror is evil, stuff should still compile without any warnings, at least at the time when you upload a package
20:10:36 <ksf> yes
20:11:17 <ivanm> ksf: there are some exceptions
20:11:27 <ksf> possibly filtered into categories, such as deprecation warnings
20:11:35 <b52> i want to use sortBy from Data.List but import Data.List doesnt work, what does the trickß
20:11:52 <ivanm> -Wall complains about my code due to a couple of orphaned instances, and because I do some imports just for haddock to make links but which -Wall says aren't needed
20:11:55 <monochrom> import Data.List works.
20:11:59 <ivanm> b52: in what?
20:12:01 <ivanm> ghci?
20:12:01 <ksf> ...and "just an import warning" vs e.g. incomplete patterns
20:12:04 <ivanm> :m + Data.List
20:12:13 <b52> its a soure file i load in ghci
20:12:19 <SamB_XP> ksf: what kind of import warning ?
20:12:26 <ivanm> what's the actual error message it comes up with?
20:12:32 <ivanm> SamB_XP: unused imports I think he means
20:12:36 <ksf> yep.
20:12:40 <b52> t.hs:9:0: parse error on input `import'
20:12:42 <SamB_XP> ah, yes, that kind is non-bad
20:12:49 <ivanm> b52: is it up the top of your file?
20:12:52 <SamB_XP> but there may be others that are bad?
20:12:52 <b52> no
20:12:53 <ksf> where it tells you to switch to import Foo () to import instances
20:12:55 <ivanm> you have to have all the imports before your actual code
20:13:21 <b52> is it mandatory be up the top of my file?
20:13:23 <ivanm> ksf: so they need to be categorised into "possible code smell" vs "something that really should be fixed"
20:13:30 <ksf> yep.
20:13:32 <ivanm> even then, it could be a judgement warning
20:13:40 <ivanm> s/warning/issue/
20:13:42 <SamB_XP> b52: it must be before anything except the "module Foo (...) where" bit
20:13:54 <ivanm> b52: yup; after your module Foo where but before any function/variable definitions
20:14:03 <ivanm> SamB_XP: well, comments are allowed... ;-)
20:14:16 <b52> thanks
20:14:18 <SamB_XP> comments are something now ?
20:14:18 <aavogt> cabal already supports the point "We want to be able to run tests on a library that is not installed yet. This will rely on support in Cabal for registering a package inplace in a local package db, and building test code against that. "
20:14:20 <ksf> I don't care whether it's biased
20:14:28 <theorbtwo> As are not-really-comment {-# pragma.
20:14:46 <ksf> ...it can be argued that every warning should be possible to disable, in some way, at the source level.
20:14:55 <SamB_XP> theorbtwo: those are iffier
20:14:57 <ivanm> theorbtwo: well, they're comments for compilers that don't understand them...
20:14:58 <aavogt> with the experimental library-with-executables feature in Cabal 1.8
20:15:14 <ivanm> aavogt: I'm still waiting for cabal-install to support that...
20:15:19 <SamB_XP> > f {-# BLAH #-} x
20:15:20 <lambdabot>   Ambiguous type variable `a' in the constraints:
20:15:20 <lambdabot>    `GHC.Show.Show a'
20:15:20 <lambdabot>      a...
20:15:22 <aavogt> ivanm: there are patches for that
20:15:25 <SamB_XP> > f {-# BLAH #-} x :: Expr
20:15:26 <lambdabot>   f x
20:15:28 <SamB_XP> huh
20:15:29 <ivanm> aavogt: :o
20:15:31 <SamB_XP> what do you know
20:15:42 <SamB_XP> > f {-# INLINE x #-} x :: Expr
20:15:43 <lambdabot>   <no location info>: parse error on input `{-# INLINE'
20:15:49 <ivanm> also, didn't byorgey go and add support to have it duplicate mkcabal's functionality?
20:16:00 <ksf> ...also, separate the code compile phase from the haddock phase.
20:16:19 <SamB_XP> ksf: not possible
20:16:21 <ksf> and possibly generate haddock for failed modules by stripping all comments.
20:16:29 <ivanm> we need haddock-specific CPP-style macros
20:16:35 <SamB_XP> that is possible
20:16:49 <ksf> SamB_XP, I mean don't report the build as failed just because haddock failed.
20:16:55 <SamB_XP> ksf: ah, that is
20:17:08 <ivanm> so you can have extra imports just to make haddock do links but that way won't have -Wall complaining
20:17:09 <SamB_XP> but haddocking a failing-to-build package won't work
20:17:13 <ivanm> ksf: yeah
20:17:24 <ivanm> ksf: and try to build docs even if deps can't be found
20:17:27 <ksf> if it doesn't build, I guess #ifndef __HADDOCK__ is the way to go
20:17:35 <SamB_XP> ivanm: that won't work though
20:17:50 <SamB_XP> it won't be able to typecheck your code, then
20:17:55 <ksf> I think the main problem is missing ffi stuff.
20:18:21 <SamB_XP> oh, missing foreign libs would be no problem ...
20:18:26 <ksf> actually, a simpler solution would be to allow uploading haddock docs
20:18:50 <SamB_XP> ... as long as they're needed by the code *in* the package whose docs you are building
20:19:24 <ksf> c2hs fails without installed headers
20:19:50 <SamB_XP> oh, point
20:20:02 <SamB_XP> so you're almost always screwed then
20:20:14 <aavogt> ivanm: see blackh's patches here: http://hackage.haskell.org/trac/hackage/ticket/89
20:20:23 <ksf> well you can upload haddock docs
20:20:44 <ksf> or supply headers that aren't distributed by hackage
20:21:03 <ksf> while the docs may not be totally accurate then, at least there _are_ docs.
20:21:37 <aavogt> depends how wrong the docs are
20:21:54 <aavogt> it would be important to note that the docs were uploaded rather than generated
20:22:14 <aavogt> or have some other way to at least check that the versions match up
20:22:38 <ivanm> aavogt: is that ticket for Cabal or cabal-install?
20:23:07 <aavogt> ivanm: it's got patches for both, but that ticket is for Cabal
20:23:49 <ivanm> aha, looks like dcoutts hasn't applied the cabal-install patch yet
20:24:28 <ivanm> @ask dcoutts if you run out of things to do at zurihac, how about letting cabal-install deal with packages with an executable that depends on the library? pretty please?
20:24:29 <lambdabot> Consider it noted.
20:24:58 <aavogt> ivanm: I think the idea was to finish up the thesis first
20:25:15 <ivanm> aavogt: he's going to zurihac; I doubt he's going to be working on his thesis there :p
20:32:55 <sphericalchicken> I found the origin of my random hang...  a recursive definition, but not in a good way.  minimal example: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24088#a24088
20:34:44 <Cale> sphericalchicken: Yeah, especially with the threaded runtime system the loop detection doesn't always work.
20:35:36 <Cale> Well, I should say, it doesn't always work the same way by throwing an exception like that.
20:36:03 <ivanm> Cale: you going to come to AusHack? :p
20:36:20 <sphericalchicken> Cale: Yeah, I'm just surprised it doesn't even chew on the CPU.  All's well that ends well, though.
20:36:24 <Cale> In the threaded runtime (which is on in GHCi by default, and is enabled while compiling with -threaded), the blackhole behaviour is to simply wait.
20:36:40 <Cale> (until perhaps another thread ends up finishing the evaluation of the value)
20:37:26 <Cale> ivanm: Yeah, I'll just buy a plane ticket with my $50. ;)
20:37:37 <ivanm> you only have $50 to your name? ;o
20:37:51 <sphericalchicken> Interesting...  Does that apply to compiled code also?  I don't think I have any explicit multi-threading in my larger codebase, but it seemed to be just waiting for nothing also.
20:38:18 <Cale> sphericalchicken: Yes. It applies to code that's been compiled with the -threaded switch.
20:40:17 <sphericalchicken> All right.  I'm not using that personally, but maybe something else is...  strings execFile | grep threaded  gives me something, at least.
20:40:22 <monochrom> It is important to know you have a bug. It is not important to make sure the bug consumes CPU or aborts.
20:41:11 <aavogt> if it consumes cpu you might not know that it's a bug
20:41:34 <aavogt> perhaps your set of input parameters results in a computation that won't finish anytime soon
20:42:06 <sphericalchicken> Granted, but if it was doing something it might be easier to find the loop.
20:42:58 <sphericalchicken> In this case I was being a little too sloppy with my variable names and had re-used one in the middle of a "where" block.
20:43:10 <SamB_XP> > let x = x in x
20:43:14 <lambdabot>   mueval-core: Time limit exceeded
20:43:34 * monochrom should have worded that in a way to please Cale. "It is not important to make sure the bug consumes massive electricity" :)
20:43:34 <SamB_XP> so, they haven't figured out how to do <<loop>> with threaded then ?
20:44:21 <SamB_XP> monochrom: electricity is rarely particularly massful
20:44:58 <ivanm> SamB_XP: huh? electrons have mass...
20:45:00 <blackh> ivanm: I've been trying to get Duncan to apply my ticket 89 patch for months. :)
20:45:06 <ivanm> blackh: heh
20:45:07 <SamB_XP> ivanm: not MUCH
20:45:19 <ivanm> true
20:45:27 <ivanm> then again, define MUCH
20:45:42 <blackh> It all works for me with my patches, but let me know how you get on.  It'd be nice to add another note to the ticket saying it works (or doesn't, as the case may be).
20:46:38 <Cale> SamB_XP: Well, it's conceptually more difficult to have it throw an exception with -threaded, since when you reach a blackhole, it's not clear that it's because of a loop, or because some other thread is evaluating the same value.
20:46:50 <ivanm> blackh: if you remind me on the weekend I'll try it out
20:47:03 <SamB_XP> Cale: yeah, but these are *simons* we speak of
20:47:14 <SamB_XP> you'd think one or the other would have thought of something by now!
20:47:28 <ivanm> SamB_XP: maybe they're too busy thinking of cooler things?
20:47:34 <SamB_XP> or maybe even some simon not NAMED simon!
20:48:04 <ivanm> heh
20:48:14 <blackh> ivanm: I'm disappearing offline for two weeks. There's no trick to installing the latest cabal + cabal-install with these two patches, anyway. It should all work smoothly on ghc 6.10 or 6.12
20:48:19 <Cale> Maybe you could have a different-looking blackhole for each Haskell evaluation context, so the HEC that's running can know to throw an exception when it sees a blackhole that it put there.
20:48:26 <ivanm> black: OK, fair enough
20:48:30 <ivanm> you going on holidays I take it?
20:48:43 <Cale> (not sure that would actually work, but it seems like it might)
20:48:43 <blackh> Yes, I really need a break!
20:48:55 <ivanm> black: where to?
20:49:40 <blackh> ivanm: Patea, which is a small town in New Zealand that's famous for one thing only: This music video: http://www.youtube.com/watch?v=DQLUygS0IAQ
20:49:51 <ivanm> heh
20:49:53 <SamB_XP> Cale: why not?
20:49:57 <SamB_XP> it should be pretty simple
20:50:17 <ivanm> blackh: hang on, you're a kiwi?
20:50:48 <blackh> ivanm: Yeah. I like Patea. The least pretentious place on earth. :)
20:51:04 <ivanm> you coming to AusHack then? :p
20:51:18 <m3ga> i met blackh in nz in january. said he was a kiwi
20:51:19 <blackh> ivanm: I'm seriously considering it but I've gotta talk to my family.
20:51:27 <ivanm> fair enough
20:51:34 <m3ga> hi blackh!
20:52:12 <blackh> m3ga: Hi! Playing with DDC some more is slipping down my to-do list, but it's still on it. :)
20:52:40 <m3ga> :-) i've been really busy too. haven't fixed a but in about 2 weeks.
20:53:19 <m3ga> but did get a new laptop which compiles DDC 6-8 times faster than the one it replaced. should make me more productive
20:53:21 <blackh> Well, hamishmack tells me he's going to AusHack so maybe there will be two kiwis there.
21:19:40 <ivanm> interesting reason to hate Cabal: "The main problem I have with Cabal is that it absolutely refuses to work with tabs. I normally use tabs instead of spaces when writing Haskell code; although this is generally frowned upon in Haskell at least compilers support it. Cabal chooses to be different, however, by forcing the use of spaces instead of tabs."
21:20:17 <ivanm> (this is comment number 3 here: http://ivanmiljenovic.wordpress.com/2010/03/15/repeat-after-me-cabal-is-not-a-package-manager/#comments )
21:22:36 <ivanm> dwchandler: didn't you like any of our solutions that you resorted to -cafe?
21:28:11 <Axman6> ivanm: lame!
21:28:12 <lambdabot> Axman6: You have 1 new message. '/msg lambdabot @messages' to read it.
21:28:19 <ivanm> Axman6: what is?
21:28:45 <Axman6> Davad not being able to come, but hopefully Manuel will know enough about it to help get some work done
21:28:51 <Axman6> David*
21:30:50 <ivanm> yeah
21:30:55 <m3ga> Axman6: the llvm guy?
21:32:17 <ivanm> m3ga: yeah
21:32:17 <Axman6> yeah
21:32:38 <ivanm> blackh says he's a maybe, has to check with his family first
21:32:51 <Axman6> excellent :)
21:33:02 <Axman6> we might be able to do some shootout hacking together too
21:33:38 <ivanm> Axman6: so we've got you, me, maybe TacticalGrace, blackdog_, hamish and ben as definites so far
21:33:44 <ivanm> with blackh as a maybe
21:34:10 <ivanm> chak prefers 18 July
21:34:30 <ivanm> Axman6: which means you have uni the next day ;-)
21:35:13 <ivanm> WE NEED MOAR PPL!
21:35:50 <shapr> wut?
21:36:00 <ivanm> AusHack2010!
21:36:06 <ivanm> http://www.haskell.org/haskellwiki/AusHac2010
21:36:13 <ivanm> shapr: you going to come? ;-)
21:36:23 <shapr> I wish... no transportation funds.
21:36:28 <ivanm> :(
21:36:34 <shapr> Maybe next year.
21:36:49 <Axman6> ivanm: bah :(
21:37:33 <ivanm> Axman6: would the 18th still be OK?
21:38:08 <ivanm> just means we either have to leave sydney early enough, you miss out on classes on the monday (or at least monday morning) or you go to classes with insufficient sleep
21:38:59 <ivanm> who is Erik de Castro Lopo? is he on here?
21:39:09 <ivanm> m3ga: ^^ is that you?
21:39:36 <m3ga> yep, was last time i checked
21:39:39 <ivanm> heh
21:40:02 <ivanm> care to either add your details to the wiki page or else give them to myself or Axman6 so that we can?
21:40:06 <ivanm> bernie pope also expressed interest
21:41:29 <ivanm> Axman6: any idea if ben sent the details to fp-syd yet?
21:41:31 <Axman6> ah, so you're Erik m3ga
21:41:37 <Axman6> ivanm:  i sent them
21:41:43 <ivanm> good-o
21:41:49 <Axman6> ivanm: i could probably make the 18th
21:42:11 <ivanm> well, that looks like the best weekend then if TacticalGrace prefers it
21:42:19 <Axman6> m3ga: are you the one who keeps filing bugs with DDC?
21:42:24 <m3ga> yes
21:42:35 <m3ga> and i have > 100 commits to darcs
21:42:39 <ivanm> heh
21:43:10 <m3ga> in fact 163 commits
21:43:18 <Axman6> heh, Clem was trying to remember your name yesterday when we asked him if he'd like to come to AusHac
21:43:40 <m3ga> yeah, i met Clem and SAPLING
21:43:45 <ivanm> oh, Clem was talking about m3ga?
21:43:52 <Axman6> m3ga: you might have met me too then :)
21:44:15 <m3ga> yeah i think so. Ben introduced us
21:44:17 <byorgey> ivanm: yes, try 'cabal init'
21:44:21 <ivanm> byorgey: \o/
21:44:29 <byorgey> ivanm: and I should point out it does a lot *more* than what mkcabal did
21:44:49 <byorgey> it's not super-polished, though, patches and suggestions most welcome
21:44:55 <ivanm> byorgey: just noticed... very nice!
21:45:02 <byorgey> you know, I should really write about that on my blog
21:45:06 <byorgey> people don't seem to know about it
21:45:22 <ivanm> byorgey: main suggestions I can think of: 1) multiple categories, 2) how do you define stability?
21:45:45 <Axman6> m3ga: did you come to the pub with us afterwards?
21:45:50 <byorgey> I don't think the format itself lets you have multiple categories.
21:46:02 <byorgey> hmm, is stability not one of the options it prompts you for?
21:46:05 <byorgey> I forget
21:46:11 <m3ga> yes, *and* i drank beer
21:46:32 <byorgey> of course, you can always go edit the .cabal file it generates afterwards
21:46:50 <ivanm> byorgey: you can have multiple categories
21:47:08 <Axman6> m3ga: ha, good to hear :)
21:47:13 <byorgey> oh, really?  hum, missed that.  I'll add it to my todo list
21:47:13 <ivanm> byorgey: it prompts for stability, but I've never heard of a quantisataion (however you spell it) of what they mean ;-)
21:47:26 <byorgey> oh, hehe
21:47:26 <ivanm> m3ga: you're just showing off because I don't, aren't you...
21:47:42 <byorgey> it's supposed to be some sort of indication of 'how likely is this to break/change'
21:47:45 <m3ga> any idiot can drink beer
21:47:49 <ivanm> byorgey: I've seen a lot of packages call themselves "experimental" and they tend to stay that way...
21:47:54 <ivanm> hmmm...
21:47:55 <byorgey> yeah, that's the problem.
21:48:06 <byorgey> this has been discussed before but with no good resuolution.
21:48:14 <byorgey> s/uo/o/
21:48:22 <ivanm> "stable" == "unlikely to change"; "provisional" == "might make small changes to improve it", etc.?
21:49:00 <ivanm> byorgey: cabal: /scratch/ghc-6.12.1/distrib/installer-scripts/MacOS: does not exist
21:49:19 <byorgey> yeah, something like that... and maybe it's supposed to indicate the likely presence of bugs too
21:49:23 <ivanm> no idea why it was looking there; /scratch is just where I _built_ ghc, not where its installed to
21:49:31 <byorgey> ivanm: what, you got that error from 'cabal init'?
21:49:37 <ivanm> yup
21:49:42 <byorgey> yikes, I have no idea
21:49:53 <ivanm> byorgey: wait, I know why
21:50:01 <ivanm> I'm just doing it in various /tmp directories, etc.
21:50:13 <ivanm> and cabal init is trying to find all .hs files to add to the .cabal file (I think)
21:50:20 <ivanm> so it crashes when it comes to one that doesn't exist/work
21:50:31 <byorgey> oh, yes, that's probably it
21:50:33 <ivanm> so if I did it in a _real_ project directory it would probably work properly ;-)
21:50:45 <byorgey> but it shouldn't crash, why would it find something that doesn't exist?
21:50:49 <byorgey> weird
21:51:11 <ivanm> another crash bug: cabal: /tmp/pulse-a7kaqGHss6Yh/native: inappropriate type
21:51:24 <ivanm> byorgey: looks like it doesn't fail gracefully and ignore dodgy files
21:52:07 <byorgey> ok, I'll add that to the list too
21:53:28 <byorgey> hmm, maybe I should wait to write about this on my blog until I have time to actually fix the flood of suggestions/bug reports I am likely to get =)
21:54:24 <ivanm> heh
21:59:51 <lpsmith> ok,  here's a problem:  you have to scrub a record with a lot of fields,  and the validator might either return an error or rewrite the field into a more canonical form.    In this application,  you want to return many errors instead of the first.   How do you structure the code?
22:00:14 <ivanm> "scrub a record"?
22:00:26 <ivanm> use a Writer monad to record the errors
22:00:50 <edwardk> preflex: xseen dons
22:00:50 <preflex>  dons was last seen on freenode/#haskell 7 hours, 52 minutes and 12 seconds ago, saying: see you on the other side.
22:01:30 <lpsmith> yeah, that would work;  though I was trying to fuse the validation into something I probably shouldn't have
22:01:34 <lpsmith> Thanks!
22:02:36 <edwardk> @ask dons is the definition of map in Data.ByteString correct? it uses inlinePerformIO around a call to 'create' which definitely performs allocation, though, the documentation for inlinePerformIO states to never ever use it around something that allocates. All of the other inlinePerformIO operations seem to obey that stricture
22:02:36 <lambdabot> Consider it noted.
22:03:14 <lpsmith> @define { gather (Left a) (Left b) = Left (a ++ b) ; gather (Left a) (Right _) = Left a ; gather (Right _) (Left b) = Left b ; gather (Right a) (Right b) = Right (a,b) }
22:03:44 <lpsmith> I've found that useful,  but it gets messy with lots and lots of fields
22:04:33 <ivanm> yeah, it would
22:06:02 <ivanm> Axman6: oh, what was that computer shop you were telling me about the other day?
22:07:49 <lpsmith> hmm...  although,  using a writer monad has the downside that I might need two records,  if I want to change the types here and there.   Dealing with records is definitely not Haskell's strongest suit :-/
22:12:59 <lpsmith> The conceptually cleanest solutions lead to a lot of boilerplate;  maybe TH is in order; I dunno.
22:13:16 <ivanm> or one of the boilerplate libraries?
22:13:17 <Axman6> ivanm: eh?
22:13:23 <ivanm> or something like fc-labels
22:13:33 <ivanm> Axman6: you were telling me the other day about some computer shop you bought something from
22:14:31 <Axman6> was it the monitor i bought?
22:25:31 <Axman6> oh no...
22:25:48 <Axman6> well, i just got split from some ~500 users
